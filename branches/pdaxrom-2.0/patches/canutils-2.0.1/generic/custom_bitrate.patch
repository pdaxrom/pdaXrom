Subject: [PATCH 1/1] canconfig: Provide custom bitrate settings
From: Juergen Beisert <j.beisert@pengutronix.de>

This patch provides a custom bitrate setting for cases where it is impossible
to use the SIOCSCANCUSTOMBITTIME ioctl instead (for example closed source), but
a special hardware setting is required to meet external constraints. Or this
feature can be used, when the auto calculation for the CAN settings fails.

This works on a per interface base and baudrate base. If not used, everything
falls back to the previous behaviour.

Signed-off-by: Juergen Beisert <j.beisert@pengutronix.de>

Note: Not intended for any mainline, as this is an interim version until
mainline accepts the required new IOCTL for this feature

--- 

Index: ChangeLog
===================================================================
--- ChangeLog.orig
+++ ChangeLog
@@ -1,3 +1,17 @@
+2007-10-08 Juergen Beisert
+
+	* command line: change command line options to set a custom bitrate
+
+2007-10-05 Juergen Beisert
+
+	* release: 2.0.2 with support for custom bitrates.
+	 Note: This feature is currently experimental and not in mainline.
+	 To use it the kernel needs a special patch!
+
+2007-10-02 Juergen Beisert
+
+	* canconfig: adding support for manually calculated bit rate configurations
+
 2005-03-16 Robert Schwebel 
 
 	* framework: collected all tools and autotoolized
Index: src/canconfig.c
===================================================================
--- src/canconfig.c.orig
+++ src/canconfig.c
@@ -2,6 +2,7 @@
  * canutils/canconfig.c
  *
  * Copyright (C) 2005 Marc Kleine-Budde <mkl@pengutronix.de>, Pengutronix
+ * Copyright (C) 2007 Juergen Beisert <jbe@pengutronix.de>, Pengutronix
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the version 2 of the GNU General Public License 
@@ -40,7 +41,12 @@
 #ifndef MIN
 #define MIN(a, b) ((a) < (b) ? (a) : (b))
 #endif
-				      
+
+#define kHz 1000
+
+#define CONFIG_FILE_NAME "/etc/canconfig.conf"
+#define CONFIG_FILE_NAME_SP "/etc/canconfig-%s.conf"
+
 int             s;
 struct ifreq	ifr;
 
@@ -51,13 +57,21 @@ static void help(void)
 		"BR := <baudrate>\n\t\t"
 		"canconfig <dev> mode MODE\n\t\t"
 		"MODE := { start }\n\t"
-		"canconfig <dev> state\n"
+		"canconfig <dev> setentry [ VALs ]\n\t\t"
+		"VALs := <bitrate | tq | err | prop_seg | phase_seg1 | phase_seg2 | sjw | sam>\n\t\t"
+		" bitrate <nominal bit rate to be set [Hz]>\n\t\t"
+		" tq <time quantum in ns>\n\t\t"
+		" err <max. allowed error in pps>\n\t\t"
+		" prop_seg <no. in tq>\n\t\t"
+		" phase_seg1 <no. in tq>\n\t\t"
+		" phase_seg2 <no. in tq\n\t\t"
+		" sjw <no. in tq>\n\t\t"
+		" sam <1 | 0> 1 for 3 times sampling, 0 else\n"
 		);
 
 	exit(EXIT_FAILURE);
 }
 
-
 static void do_show_baudrate(int argc, char* argv[])
 {
 	uint32_t *baudrate = (uint32_t *)&ifr.ifr_ifru;
@@ -72,7 +86,7 @@ static void do_show_baudrate(int argc, c
 
 	if (*baudrate != -1)
 		fprintf(stdout,
-			"%s: baudrate %d\n", ifr.ifr_name, *baudrate / 1000);
+			"%s: baudrate %d\n", ifr.ifr_name, *baudrate / kHz);
 	else 
 		fprintf(stdout,
 			"%s: baudrate unknown\n", ifr.ifr_name);
@@ -85,7 +99,7 @@ static void do_set_baudrate(int argc, ch
 	uint32_t *baudrate = (uint32_t *)&ifr.ifr_ifru;
 	int i;
 
-	*baudrate = (uint32_t)strtoul(argv[3], NULL, 0) * 1000;
+	*baudrate = (uint32_t)strtoul(argv[3], NULL, 0) * kHz;
 	if (*baudrate == 0) {
 		fprintf(stderr, "invalid baudrate\n");
 		exit(EXIT_FAILURE);
@@ -128,10 +142,129 @@ static void cmd_mode(int argc, char *arg
 		perror("ioctl");
 		exit(EXIT_FAILURE);
 	}
-		
+
 	exit(EXIT_SUCCESS);
 }
 
+/*
+ * setup a custom bitrate for a specific interface
+ * Options are:
+ * canconfig <interface> setentry
+ * [bitrate <number>] | [tq <number>] | [err <number>] [prop_seg <number>] |
+ *     [phase_seg1 <number>] | [phase_seg2 <number>] | [sjw <number>] | [sam <number>]
+ */
+static void cmd_setentry(int argc, char *argv[])
+{
+	int done, i;
+	struct can_bit_time_custom *bit_time = (struct can_bit_time_custom *)&ifr.ifr_ifru;
+
+	/* mark each field as unintialised */
+	bit_time->bit_rate = bit_time->tq = bit_time->bit_error = -1;
+	bit_time->prop_seg = bit_time->phase_seg1 =
+			bit_time->phase_seg2 = -1;
+	bit_time->sjw = -1;
+	bit_time->sam = -1;
+
+	/* runtime testing until everything here is in mainline */
+	if (sizeof(struct can_bit_time_custom) > sizeof(ifr.ifr_ifru)) {
+		printf("Error can_bit_time_custom to large! (%d, %d)",
+		       sizeof(struct can_bit_time_custom), sizeof(ifr.ifr_ifru));
+		exit(EXIT_FAILURE);
+	}
+
+	/*
+	 * Note: all values must be given. There is no default
+	 * value for any one of these
+	 */
+	if (argc < 19)
+		help();
+
+	done = 3;
+
+	while ((done + 1) < argc) {
+		if (!strcmp(argv[done], "bitrate")) {
+			bit_time->bit_rate = (uint32_t)strtoul(argv[++done], NULL, 0);
+			done++;
+			continue;
+		}
+		if (!strcmp(argv[done], "tq")) {
+			bit_time->tq = (uint32_t)strtoul(argv[++done], NULL, 0);
+			done++;
+			continue;
+		}
+		if (!strcmp(argv[done], "err")) {
+			bit_time->bit_error = (uint32_t)strtoul(argv[++done], NULL, 0);
+			done++;
+			continue;
+		}
+		if (!strcmp(argv[done], "prop_seg")) {
+			bit_time->prop_seg = (uint32_t)strtoul(argv[++done], NULL, 0);
+			done++;
+			continue;
+		}
+		if (!strcmp(argv[done], "phase_seg1")) {
+			bit_time->phase_seg1 = (uint32_t)strtoul(argv[++done], NULL, 0);
+			done++;
+			continue;
+		}
+		if (!strcmp(argv[done], "phase_seg2")) {
+			bit_time->phase_seg2 = (uint32_t)strtoul(argv[++done], NULL, 0);
+			done++;
+			continue;
+		}
+		if (!strcmp(argv[done], "sjw")) {
+			bit_time->sjw = (uint32_t)strtoul(argv[++done], NULL, 0);
+			done++;
+			continue;
+		}
+		if (!strcmp(argv[done], "sam")) {
+			bit_time->sam = (int)strtoul(argv[++done], NULL, 0);
+			done++;
+			continue;
+		}
+	}
+
+	if (bit_time->bit_rate == -1) {
+		fprintf(stderr, "missing bit_rate value!\n");
+		exit(EXIT_FAILURE);
+	}
+	if (bit_time->tq == -1) {
+		fprintf(stderr, "missing tq value!\n");
+		exit(EXIT_FAILURE);
+	}
+	if (bit_time->bit_error == -1) {
+		fprintf(stderr, "missing err value!\n");
+		exit(EXIT_FAILURE);
+	}
+	if (bit_time->prop_seg == (__u8)-1) {
+		fprintf(stderr, "missing prop_seg value!\n");
+		exit(EXIT_FAILURE);
+	}
+	if (bit_time->phase_seg1 == (__u8)-1) {
+		fprintf(stderr, "missing phase_seg1 value!\n");
+		exit(EXIT_FAILURE);
+	}
+	if (bit_time->phase_seg2 == (__u8)-1) {
+		fprintf(stderr, "missing phase_seg2 value!\n");
+		exit(EXIT_FAILURE);
+	}
+	if (bit_time->sjw == -1) {
+		fprintf(stderr, "missing sjw value!\n");
+		exit(EXIT_FAILURE);
+	}
+	if (bit_time->sam == -1) {
+		fprintf(stderr, "missing sam value!\n");
+		exit(EXIT_FAILURE);
+	}
+
+	i = ioctl(s, SIOCSCANDEDBITTIME, &ifr);
+	if (i < 0) {
+		perror("ioctl");
+		exit(EXIT_FAILURE);
+	}
+
+	exit(EXIT_SUCCESS);
+}
 
 #if 0
 static void do_show_state(int argc, char *argv[])
@@ -189,7 +322,7 @@ int main(int argc, char *argv[])
 {
 	if ((argc < 2) || !strcmp(argv[1], "--help"))
 		help();
-	
+
 	if ((s = socket(AF_CAN, SOCK_RAW, CAN_RAW)) < 0) {
 		perror("socket");
 		exit(EXIT_FAILURE);
@@ -204,6 +337,9 @@ int main(int argc, char *argv[])
 		cmd_baudrate(argc, argv);
 	if (!strcmp(argv[2], "mode"))
 		cmd_mode(argc, argv);
+	if (!strcmp(argv[2], "setentry"))
+		cmd_setentry(argc, argv);
+
 /* 	if (!strcmp(argv[2], "state")) */
 /* 		cmd_state(argc, argv); */
 
