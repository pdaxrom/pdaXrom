Subject: [patch] kvm: make vcpu_load/put preemptible
From: Ingo Molnar <mingo@elte.hu>

make vcpu_load/put preemptible.

Signed-off-by: Ingo Molnar <mingo@elte.hu>
---
 drivers/kvm/kvm_main.c |    8 ++++----
 drivers/kvm/svm.c      |   13 ++++++++++---
 drivers/kvm/vmx.c      |   15 ++++++++++++---
 3 files changed, 26 insertions(+), 10 deletions(-)

Index: linux-2.6.23.1-rt5/drivers/kvm/kvm_main.c
===================================================================
--- linux-2.6.23.1-rt5.orig/drivers/kvm/kvm_main.c
+++ linux-2.6.23.1-rt5/drivers/kvm/kvm_main.c
@@ -2902,7 +2902,7 @@ static int kvm_reboot(struct notifier_bl
 		 * in vmx root mode.
 		 */
 		printk(KERN_INFO "kvm: exiting hardware virtualization\n");
-		on_each_cpu(hardware_disable, NULL, 0, 1);
+		schedule_on_each_cpu(hardware_disable, NULL, 0, 1);
 	}
 	return NOTIFY_OK;
 }
@@ -3129,7 +3129,7 @@ int kvm_init_arch(struct kvm_arch_ops *o
 	if (r < 0)
 		goto out;
 
-	on_each_cpu(hardware_enable, NULL, 0, 1);
+	schedule_on_each_cpu(hardware_enable, NULL, 0, 1);
 	r = register_cpu_notifier(&kvm_cpu_notifier);
 	if (r)
 		goto out_free_1;
@@ -3161,7 +3161,7 @@ out_free_2:
 	unregister_reboot_notifier(&kvm_reboot_notifier);
 	unregister_cpu_notifier(&kvm_cpu_notifier);
 out_free_1:
-	on_each_cpu(hardware_disable, NULL, 0, 1);
+	schedule_on_each_cpu(hardware_disable, NULL, 0, 1);
 	kvm_arch_ops->hardware_unsetup();
 out:
 	kvm_arch_ops = NULL;
@@ -3175,7 +3175,7 @@ void kvm_exit_arch(void)
 	sysdev_class_unregister(&kvm_sysdev_class);
 	unregister_reboot_notifier(&kvm_reboot_notifier);
 	unregister_cpu_notifier(&kvm_cpu_notifier);
-	on_each_cpu(hardware_disable, NULL, 0, 1);
+	schedule_on_each_cpu(hardware_disable, NULL, 0, 1);
 	kvm_arch_ops->hardware_unsetup();
 	kvm_arch_ops = NULL;
 }
Index: linux-2.6.23.1-rt5/drivers/kvm/svm.c
===================================================================
--- linux-2.6.23.1-rt5.orig/drivers/kvm/svm.c
+++ linux-2.6.23.1-rt5/drivers/kvm/svm.c
@@ -613,9 +613,17 @@ static void svm_free_vcpu(struct kvm_vcp
 
 static void svm_vcpu_load(struct kvm_vcpu *vcpu)
 {
-	int cpu, i;
+	int cpu = raw_smp_processor_id(), i;
+	cpumask_t this_mask = cpumask_of_cpu(cpu);
+
+	/*
+	 * Keep the context preemptible, but do not migrate
+	 * away to another CPU. TODO: make sure this persists.
+	 * Save/restore original mask.
+	 */
+	if (unlikely(!cpus_equal(current->cpus_allowed, this_mask)))
+		set_cpus_allowed(current, cpumask_of_cpu(cpu));
 
-	cpu = get_cpu();
 	if (unlikely(cpu != vcpu->cpu)) {
 		u64 tsc_this, delta;
 
@@ -641,7 +649,6 @@ static void svm_vcpu_put(struct kvm_vcpu
 		wrmsrl(host_save_user_msrs[i], vcpu->svm->host_user_msrs[i]);
 
 	rdtscll(vcpu->host_tsc);
-	put_cpu();
 }
 
 static void svm_vcpu_decache(struct kvm_vcpu *vcpu)
Index: linux-2.6.23.1-rt5/drivers/kvm/vmx.c
===================================================================
--- linux-2.6.23.1-rt5.orig/drivers/kvm/vmx.c
+++ linux-2.6.23.1-rt5/drivers/kvm/vmx.c
@@ -366,6 +366,8 @@ static void vmx_load_host_state(struct k
 
 		reload_tss();
 	}
+	preempt_enable();
+
 	save_msrs(vcpu->guest_msrs, vcpu->save_nmsrs);
 	load_msrs(vcpu->host_msrs, vcpu->save_nmsrs);
 	if (msr_efer_need_save_restore(vcpu))
@@ -379,10 +381,17 @@ static void vmx_load_host_state(struct k
 static void vmx_vcpu_load(struct kvm_vcpu *vcpu)
 {
 	u64 phys_addr = __pa(vcpu->vmcs);
-	int cpu;
 	u64 tsc_this, delta;
+	int cpu = raw_smp_processor_id();
+	cpumask_t this_mask = cpumask_of_cpu(cpu);
 
-	cpu = get_cpu();
+	/*
+	 * Keep the context preemptible, but do not migrate
+	 * away to another CPU. TODO: make sure this persists.
+	 * Save/restore original mask.
+	 */
+	if (unlikely(!cpus_equal(current->cpus_allowed, this_mask)))
+		set_cpus_allowed(current, cpumask_of_cpu(cpu));
 
 	if (vcpu->cpu != cpu)
 		vcpu_clear(vcpu);
@@ -428,7 +437,6 @@ static void vmx_vcpu_put(struct kvm_vcpu
 {
 	vmx_load_host_state(vcpu);
 	kvm_put_guest_fpu(vcpu);
-	put_cpu();
 }
 
 static void vmx_fpu_activate(struct kvm_vcpu *vcpu)
@@ -2022,6 +2030,7 @@ again:
 		if (test_and_clear_bit(KVM_TLB_FLUSH, &vcpu->requests))
 		    vmx_flush_tlb(vcpu);
 
+	preempt_disable();
 	asm (
 		/* Store host registers */
 #ifdef CONFIG_X86_64
