Subject: Coding style fixes
From: Marc Kleine-Budde <mkl@pengutronix.de>

This patch is a coding style fix only.
4 spaces are replaced by 1 tab
no space between function and opening bracket
space between c-keywords and opening bracket

Signed-off-by: Marc Kleine-Budde <mkl@penugtronix.de>

---
 drivers/input/touchscreen/pxa-wm97xx.c  |   38 ++++----
 drivers/input/touchscreen/wm97xx-core.c |  148 ++++++++++++++++----------------
 include/linux/wm97xx.h                  |  121 +++++++++++++-------------
 3 files changed, 157 insertions(+), 150 deletions(-)

Index: drivers/input/touchscreen/pxa-wm97xx.c
===================================================================
--- drivers/input/touchscreen/pxa-wm97xx.c.orig
+++ drivers/input/touchscreen/pxa-wm97xx.c
@@ -108,7 +108,7 @@ MODULE_PARM_DESC(ac97_touch_slot, "Touch
 
 /* flush AC97 slot 5 FIFO on pxa machines */
 #ifdef CONFIG_PXA27x
-void wm97xx_acc_pen_up (struct wm97xx* wm)
+void wm97xx_acc_pen_up(struct wm97xx* wm)
 {
 	set_current_state(TASK_INTERRUPTIBLE);
 	schedule_timeout(1);
@@ -117,7 +117,7 @@ void wm97xx_acc_pen_up (struct wm97xx* w
 		MODR;
 }
 #else
-void wm97xx_acc_pen_up (struct wm97xx* wm)
+void wm97xx_acc_pen_up(struct wm97xx* wm)
 {
 	int count = 16;
 	set_current_state(TASK_INTERRUPTIBLE);
@@ -130,7 +130,7 @@ void wm97xx_acc_pen_up (struct wm97xx* w
 }
 #endif
 
-int wm97xx_acc_pen_down (struct wm97xx* wm)
+int wm97xx_acc_pen_down(struct wm97xx* wm)
 {
 	u16 x, y, p = 0x100 | WM97XX_ADCSEL_PRES;
 	int reads = 0;
@@ -226,7 +226,7 @@ int wm97xx_acc_startup(struct wm97xx* wm
 
 void wm97xx_acc_shutdown(struct wm97xx* wm)
 {
-    /* codec specific deconfig */
+	/* codec specific deconfig */
 	if (pen_int) {
 		switch (wm->id & 0xffff) {
 			case WM9705_ID2:
@@ -244,40 +244,40 @@ void wm97xx_acc_shutdown(struct wm97xx* 
 static struct wm97xx_mach_ops pxa_mach_ops = {
 	.acc_enabled = 1,
 	.acc_pen_up = wm97xx_acc_pen_up,
-    .acc_pen_down = wm97xx_acc_pen_down,
-    .acc_startup = wm97xx_acc_startup,
-    .acc_shutdown = wm97xx_acc_shutdown,
+	.acc_pen_down = wm97xx_acc_pen_down,
+	.acc_startup = wm97xx_acc_startup,
+	.acc_shutdown = wm97xx_acc_shutdown,
 };
 
 int pxa_wm97xx_probe(struct device *dev)
 {
-    struct wm97xx *wm = dev->driver_data;
-    return wm97xx_register_mach_ops (wm, &pxa_mach_ops);
+	struct wm97xx *wm = dev->driver_data;
+	return wm97xx_register_mach_ops(wm, &pxa_mach_ops);
 }
 
 int pxa_wm97xx_remove(struct device *dev)
 {
 	struct wm97xx *wm = dev->driver_data;
-    wm97xx_unregister_mach_ops (wm);
-    return 0;
+	wm97xx_unregister_mach_ops (wm);
+	return 0;
 }
 
-static struct device_driver  pxa_wm97xx_driver = {
-    .name = "wm97xx-touchscreen",
-    .bus = &wm97xx_bus_type,
-    .owner = THIS_MODULE,
-    .probe = pxa_wm97xx_probe,
-    .remove = pxa_wm97xx_remove
+static struct device_driver pxa_wm97xx_driver = {
+	.name = "wm97xx-touchscreen",
+	.bus = &wm97xx_bus_type,
+	.owner = THIS_MODULE,
+	.probe = pxa_wm97xx_probe,
+	.remove = pxa_wm97xx_remove
 };
 
 static int __init pxa_wm97xx_init(void)
 {
-    return driver_register(&pxa_wm97xx_driver);
+	return driver_register(&pxa_wm97xx_driver);
 }
 
 static void __exit pxa_wm97xx_exit(void)
 {
-    driver_unregister(&pxa_wm97xx_driver);
+	driver_unregister(&pxa_wm97xx_driver);
 }
 
 module_init(pxa_wm97xx_init);
Index: drivers/input/touchscreen/wm97xx-core.c
===================================================================
--- drivers/input/touchscreen/wm97xx-core.c.orig
+++ drivers/input/touchscreen/wm97xx-core.c
@@ -148,15 +148,15 @@ EXPORT_SYMBOL_GPL(wm97xx_reg_read);
 void wm97xx_reg_write(struct wm97xx *wm, u16 reg, u16 val)
 {
 	/* cache digitiser registers */
-	if(reg >= AC97_WM9713_DIG1 && reg <= AC97_WM9713_DIG3)
+	if (reg >= AC97_WM9713_DIG1 && reg <= AC97_WM9713_DIG3)
 		wm->dig[(reg - AC97_WM9713_DIG1) >> 1] = val;
 
 	/* cache gpio regs */
-	if(reg >= AC97_GPIO_CFG && reg <= AC97_MISC_AFE)
+	if (reg >= AC97_GPIO_CFG && reg <= AC97_MISC_AFE)
 		wm->gpio[(reg - AC97_GPIO_CFG) >> 1] = val;
 
 	/* wm9713 irq reg */
-	if(reg == 0x5a)
+	if (reg == 0x5a)
 		wm->misc = val;
 
 	if (wm->ac97)
@@ -414,10 +414,10 @@ static int wm97xx_read_samples(struct wm
 
 	mutex_lock(&wm->codec_mutex);
 
-    if (wm->mach_ops && wm->mach_ops->acc_enabled)
-	   rc = wm->mach_ops->acc_pen_down(wm);
-    else
-        rc = wm->codec->poll_touch(wm, &data);
+	if (wm->mach_ops && wm->mach_ops->acc_enabled)
+		rc = wm->mach_ops->acc_pen_down(wm);
+	else
+		rc = wm->codec->poll_touch(wm, &data);
 
 	if (rc & RC_PENUP) {
 		if (wm->pen_is_down) {
@@ -596,7 +596,7 @@ static void wm97xx_ts_input_close(struct
  */
 static int wm97xx_bus_match(struct device *dev, struct device_driver *drv)
 {
-    return !(strcmp(dev->bus_id,drv->name));
+	return !(strcmp(dev->bus_id,drv->name));
 }
 
 /*
@@ -605,35 +605,35 @@ static int wm97xx_bus_match(struct devic
  */
 static int wm97xx_bus_suspend(struct device *dev, pm_message_t state)
 {
-    int ret = 0;
+	int ret = 0;
 
-    if (dev->driver && dev->driver->suspend)
-        ret = dev->driver->suspend(dev, state);
+	if (dev->driver && dev->driver->suspend)
+		ret = dev->driver->suspend(dev, state);
 
-    return ret;
+	return ret;
 }
 
 static int wm97xx_bus_resume(struct device *dev)
 {
-    int ret = 0;
+	int ret = 0;
 
-    if (dev->driver && dev->driver->resume)
-        ret = dev->driver->resume(dev);
+	if (dev->driver && dev->driver->resume)
+		ret = dev->driver->resume(dev);
 
-    return ret;
+	return ret;
 }
 
 struct bus_type wm97xx_bus_type = {
-    .name       = "wm97xx",
-    .match      = wm97xx_bus_match,
-    .suspend    = wm97xx_bus_suspend,
-    .resume     = wm97xx_bus_resume,
+	.name       = "wm97xx",
+	.match      = wm97xx_bus_match,
+	.suspend    = wm97xx_bus_suspend,
+	.resume     = wm97xx_bus_resume,
 };
 EXPORT_SYMBOL_GPL(wm97xx_bus_type);
 
 static void  wm97xx_release(struct device *dev)
 {
-    kfree(dev);
+	kfree(dev);
 }
 
 static int wm97xx_probe(struct device *dev)
@@ -643,7 +643,7 @@ static int wm97xx_probe(struct device *d
 
 	if (!(wm = kzalloc(sizeof(struct wm97xx), GFP_KERNEL)))
 		return -ENOMEM;
-    mutex_init(&wm->codec_mutex);
+	mutex_init(&wm->codec_mutex);
 
 	init_waitqueue_head(&wm->pen_irq_wait);
 	wm->dev = dev;
@@ -658,16 +658,16 @@ static int wm97xx_probe(struct device *d
 	}
 
 	wm->id = wm97xx_reg_read(wm, AC97_VENDOR_ID2);
-	if(wm->id != wm97xx_codec.id) {
+	if (wm->id != wm97xx_codec.id) {
 		err("could not find a the selected codec, please build for wm97%2x", wm->id & 0xff);
 		kfree(wm);
 		return -ENODEV;
 	}
 
-	if((wm->input_dev = input_allocate_device()) == NULL) {
-        kfree(wm);
+	if ((wm->input_dev = input_allocate_device()) == NULL) {
+		kfree(wm);
 		return -ENOMEM;
-    }
+	}
 
 	/* set up touch configuration */
 	info("detected a wm97%2x codec", wm->id & 0xff);
@@ -689,10 +689,10 @@ static int wm97xx_probe(struct device *d
 	wm->input_dev->absfuzz[ABS_PRESSURE] = abs_p[2];
 	wm->input_dev->private = wm;
 	wm->codec = &wm97xx_codec;
-	if((ret = input_register_device(wm->input_dev)) < 0) {
+	if ((ret = input_register_device(wm->input_dev)) < 0) {
 		kfree(wm);
 		return -ENOMEM;
-    }
+	}
 
 	/* set up physical characteristics */
 	wm->codec->digitiser_ioctl(wm, WM97XX_PHY_INIT);
@@ -706,43 +706,43 @@ static int wm97xx_probe(struct device *d
 	wm->gpio[5] = wm97xx_reg_read(wm, AC97_MISC_AFE);
 
 	/* register our battery device */
-    if (!(wm->battery_dev = kzalloc(sizeof(struct device), GFP_KERNEL))) {
-    	ret = -ENOMEM;
-        goto batt_err;
-    }
-    wm->battery_dev->bus = &wm97xx_bus_type;
-    strcpy(wm->battery_dev->bus_id,"wm97xx-battery");
-    wm->battery_dev->driver_data = wm;
-    wm->battery_dev->parent = dev;
-    wm->battery_dev->release = wm97xx_release;
-    if((ret = device_register(wm->battery_dev)) < 0)
-    	goto batt_reg_err;
+	if (!(wm->battery_dev = kzalloc(sizeof(struct device), GFP_KERNEL))) {
+		ret = -ENOMEM;
+		goto batt_err;
+	}
+	wm->battery_dev->bus = &wm97xx_bus_type;
+	strcpy(wm->battery_dev->bus_id, "wm97xx-battery");
+	wm->battery_dev->driver_data = wm;
+	wm->battery_dev->parent = dev;
+	wm->battery_dev->release = wm97xx_release;
+	if ((ret = device_register(wm->battery_dev)) < 0)
+		goto batt_reg_err;
 
 	/* register our extended touch device (for machine specific extensions) */
-    if (!(wm->touch_dev = kzalloc(sizeof(struct device), GFP_KERNEL))) {
-    	ret = -ENOMEM;
-        goto touch_err;
-    }
-    wm->touch_dev->bus = &wm97xx_bus_type;
-    strcpy(wm->touch_dev->bus_id,"wm97xx-touchscreen");
-    wm->touch_dev->driver_data = wm;
-    wm->touch_dev->parent = dev;
-    wm->touch_dev->release = wm97xx_release;
-    if((ret = device_register(wm->touch_dev)) < 0)
-    	goto touch_reg_err;
+	if (!(wm->touch_dev = kzalloc(sizeof(struct device), GFP_KERNEL))) {
+		ret = -ENOMEM;
+		goto touch_err;
+	}
+	wm->touch_dev->bus = &wm97xx_bus_type;
+	strcpy(wm->touch_dev->bus_id, "wm97xx-touchscreen");
+	wm->touch_dev->driver_data = wm;
+	wm->touch_dev->parent = dev;
+	wm->touch_dev->release = wm97xx_release;
+	if ((ret = device_register(wm->touch_dev)) < 0)
+		goto touch_reg_err;
 
-    return ret;
+	return ret;
 
-touch_reg_err:
+ touch_reg_err:
 	kfree(wm->touch_dev);
-touch_err:
-    device_unregister(wm->battery_dev);
-batt_reg_err:
+ touch_err:
+	device_unregister(wm->battery_dev);
+ batt_reg_err:
 	kfree(wm->battery_dev);
-batt_err:
-    input_unregister_device(wm->input_dev);
-    kfree(wm);
-    return ret;
+ batt_err:
+	input_unregister_device(wm->input_dev);
+	kfree(wm);
+	return ret;
 }
 
 static int wm97xx_remove(struct device *dev)
@@ -758,7 +758,7 @@ static int wm97xx_remove(struct device *
 	}
 	device_unregister(wm->battery_dev);
 	device_unregister(wm->touch_dev);
-    input_unregister_device(wm->input_dev);
+	input_unregister_device(wm->input_dev);
 
 	kfree(wm);
 	return 0;
@@ -770,10 +770,10 @@ int wm97xx_resume(struct device* dev)
 	struct wm97xx *wm = dev_get_drvdata(dev);
 
 	/* restore digitiser and gpio's */
-	if(wm->id == WM9713_ID2) {
+	if (wm->id == WM9713_ID2) {
 		wm97xx_reg_write(wm, AC97_WM9713_DIG1, wm->dig[0]);
 		wm97xx_reg_write(wm, 0x5a, wm->misc);
-		if(wm->ts_use_count) {
+		if (wm->ts_use_count) {
 			u16 reg = wm97xx_reg_read(wm, AC97_EXTENDED_MID) & 0x7fff;
 			wm97xx_reg_write(wm, AC97_EXTENDED_MID, reg);
 		}
@@ -802,21 +802,21 @@ int wm97xx_resume(struct device* dev)
 int wm97xx_register_mach_ops(struct wm97xx *wm, struct wm97xx_mach_ops *mach_ops)
 {
 	mutex_lock(&wm->codec_mutex);
-    if(wm->mach_ops) {
-    	mutex_unlock(&wm->codec_mutex);
-    	return -EINVAL;
-    }
-    wm->mach_ops = mach_ops;
-    mutex_unlock(&wm->codec_mutex);
-    return 0;
+	if (wm->mach_ops) {
+		mutex_unlock(&wm->codec_mutex);
+		return -EINVAL;
+	}
+	wm->mach_ops = mach_ops;
+	mutex_unlock(&wm->codec_mutex);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(wm97xx_register_mach_ops);
 
 void wm97xx_unregister_mach_ops(struct wm97xx *wm)
 {
 	mutex_lock(&wm->codec_mutex);
-    wm->mach_ops = NULL;
-    mutex_unlock(&wm->codec_mutex);
+	wm->mach_ops = NULL;
+	mutex_unlock(&wm->codec_mutex);
 }
 EXPORT_SYMBOL_GPL(wm97xx_unregister_mach_ops);
 
@@ -834,15 +834,15 @@ static int __init wm97xx_init(void)
 	int ret;
 
 	info("version %s liam.girdwood@wolfsonmicro.com", WM_CORE_VERSION);
-    if((ret = bus_register(&wm97xx_bus_type)) < 0)
-    	return ret;
+	if ((ret = bus_register(&wm97xx_bus_type)) < 0)
+		return ret;
 	return driver_register(&wm97xx_driver);
 }
 
 static void __exit wm97xx_exit(void)
 {
 	driver_unregister(&wm97xx_driver);
-    bus_unregister(&wm97xx_bus_type);
+	bus_unregister(&wm97xx_bus_type);
 }
 
 module_init(wm97xx_init);
Index: include/linux/wm97xx.h
===================================================================
--- include/linux/wm97xx.h.orig
+++ include/linux/wm97xx.h
@@ -21,20 +21,20 @@
 #define AC97_WM97XX_DIGITISER1		0x76
 #define AC97_WM97XX_DIGITISER2		0x78
 #define AC97_WM97XX_DIGITISER_RD 	0x7a
-#define AC97_WM9713_DIG1			0x74
-#define AC97_WM9713_DIG2			AC97_WM97XX_DIGITISER1
-#define AC97_WM9713_DIG3			AC97_WM97XX_DIGITISER2
+#define AC97_WM9713_DIG1		0x74
+#define AC97_WM9713_DIG2		AC97_WM97XX_DIGITISER1
+#define AC97_WM9713_DIG3		AC97_WM97XX_DIGITISER2
 
 /*
  * WM97xx register bits
  */
-#define WM97XX_POLL			0x8000	/* initiate a polling measurement */
+#define WM97XX_POLL		0x8000	/* initiate a polling measurement */
 #define WM97XX_ADCSEL_X		0x1000	/* x coord measurement */
 #define WM97XX_ADCSEL_Y		0x2000	/* y coord measurement */
 #define WM97XX_ADCSEL_PRES	0x3000	/* pressure measurement */
 #define WM97XX_ADCSEL_MASK	0x7000
-#define WM97XX_COO			0x0800	/* enable coordinate mode */
-#define WM97XX_CTC			0x0400	/* enable continuous mode */
+#define WM97XX_COO		0x0800	/* enable coordinate mode */
+#define WM97XX_CTC		0x0400	/* enable continuous mode */
 #define WM97XX_CM_RATE_93	0x0000	/* 93.75Hz continuous rate */
 #define WM97XX_CM_RATE_187	0x0100	/* 187.5Hz continuous rate */
 #define WM97XX_CM_RATE_375	0x0200	/* 375Hz continuous rate */
@@ -47,13 +47,13 @@
 #define WM97XX_RATE(i)		(((i & 3) << 8) | ((i & 4) ? 0xf0 : 0))
 #define WM97XX_DELAY(i)		((i << 4) & 0x00f0)	/* sample delay times */
 #define WM97XX_DELAY_MASK	0x00f0
-#define WM97XX_SLEN			0x0008	/* slot read back enable */
+#define WM97XX_SLEN		0x0008	/* slot read back enable */
 #define WM97XX_SLT(i)		((i - 5) & 0x7)	/* touchpanel slot selection (5-11) */
 #define WM97XX_SLT_MASK		0x0007
 #define WM97XX_PRP_DETW		0x4000	/* pen detect on, digitiser off, wake up */
 #define WM97XX_PRP_DET		0x8000	/* pen detect on, digitiser off, no wake up */
 #define WM97XX_PRP_DET_DIG	0xc000	/* pen detect on, digitiser on */
-#define WM97XX_RPR			0x2000	/* wake up on pen down */
+#define WM97XX_RPR		0x2000	/* wake up on pen down */
 #define WM97XX_PEN_DOWN		0x8000	/* pen is down */
 #define WM97XX_ADCSRC_MASK	0x7000	/* ADC source mask */
 
@@ -64,10 +64,10 @@
 
 
 /* WM9712 Bits */
-#define WM9712_45W			0x1000	/* set for 5-wire touchscreen */
-#define WM9712_PDEN			0x0800	/* measure only when pen down */
-#define WM9712_WAIT			0x0200	/* wait until adc is read before next sample */
-#define WM9712_PIL			0x0100	/* current used for pressure measurement. set 400uA else 200uA */
+#define WM9712_45W		0x1000	/* set for 5-wire touchscreen */
+#define WM9712_PDEN		0x0800	/* measure only when pen down */
+#define WM9712_WAIT		0x0200	/* wait until adc is read before next sample */
+#define WM9712_PIL		0x0100	/* current used for pressure measurement. set 400uA else 200uA */
 #define WM9712_MASK_HI		0x0040	/* hi on mask pin (47) stops conversions */
 #define WM9712_MASK_EDGE	0x0080	/* rising/falling edge on pin delays sample */
 #define	WM9712_MASK_SYNC	0x00c0	/* rising/falling edge on mask initiates sample */
@@ -79,13 +79,13 @@
 #define AC97_WM9712_REV		0x58
 
 /* WM9705 Bits */
-#define WM9705_PDEN			0x1000	/* measure only when pen is down */
-#define WM9705_PINV			0x0800	/* inverts sense of pen down output */
-#define WM9705_BSEN			0x0400	/* BUSY flag enable, pin47 is 1 when busy */
-#define WM9705_BINV			0x0200	/* invert BUSY (pin47) output */
-#define WM9705_WAIT			0x0100	/* wait until adc is read before next sample */
-#define WM9705_PIL			0x0080	/* current used for pressure measurement. set 400uA else 200uA */
-#define WM9705_PHIZ			0x0040	/* set PHONE and PCBEEP inputs to high impedance */
+#define WM9705_PDEN		0x1000	/* measure only when pen is down */
+#define WM9705_PINV		0x0800	/* inverts sense of pen down output */
+#define WM9705_BSEN		0x0400	/* BUSY flag enable, pin47 is 1 when busy */
+#define WM9705_BINV		0x0200	/* invert BUSY (pin47) output */
+#define WM9705_WAIT		0x0100	/* wait until adc is read before next sample */
+#define WM9705_PIL		0x0080	/* current used for pressure measurement. set 400uA else 200uA */
+#define WM9705_PHIZ		0x0040	/* set PHONE and PCBEEP inputs to high impedance */
 #define WM9705_MASK_HI		0x0010	/* hi on mask stops conversions */
 #define WM9705_MASK_EDGE	0x0020	/* rising/falling edge on pin delays sample */
 #define	WM9705_MASK_SYNC	0x0030	/* rising/falling edge on mask initiates sample */
@@ -94,27 +94,27 @@
 
 /* WM9713 Bits */
 #define WM9713_PDPOL		0x0400	/* Pen down polarity */
-#define WM9713_POLL			0x0200	/* initiate a polling measurement */
-#define WM9713_CTC			0x0100	/* enable continuous mode */
+#define WM9713_POLL		0x0200	/* initiate a polling measurement */
+#define WM9713_CTC		0x0100	/* enable continuous mode */
 #define WM9713_ADCSEL_X		0x0002	/* X measurement */
 #define WM9713_ADCSEL_Y		0x0004	/* Y measurement */
 #define WM9713_ADCSEL_PRES	0x0008	/* Pressure measurement */
-#define WM9713_COO			0x0001	/* enable coordinate mode */
-#define WM9713_PDEN			0x0800	/* measure only when pen down */
+#define WM9713_COO		0x0001	/* enable coordinate mode */
+#define WM9713_PDEN		0x0800	/* measure only when pen down */
 #define WM9713_ADCSEL_MASK	0x00fe	/* ADC selection mask */
-#define WM9713_WAIT			0x0200	/* coordinate wait */
+#define WM9713_WAIT		0x0200	/* coordinate wait */
 
 /* AUX ADC ID's */
-#define TS_COMP1			0x0
-#define TS_COMP2			0x1
-#define TS_BMON				0x2
-#define TS_WIPER			0x3
+#define TS_COMP1		0x0
+#define TS_COMP2		0x1
+#define TS_BMON			0x2
+#define TS_WIPER		0x3
 
 /* ID numbers */
-#define WM97XX_ID1			0x574d
-#define WM9712_ID2			0x4c12
-#define WM9705_ID2			0x4c05
-#define WM9713_ID2			0x4c13
+#define WM97XX_ID1		0x574d
+#define WM9712_ID2		0x4c12
+#define WM9705_ID2		0x4c05
+#define WM9713_ID2		0x4c13
 
 /* Codec GPIO's */
 #define WM97XX_MAX_GPIO		16
@@ -151,7 +151,8 @@
    so the handler should not sleep or wait for pendown irq) */
 #define RC_PENDOWN			0x00000008
 
-/* The wm97xx driver provides a private API for writing platform-specific
+/*
+ * The wm97xx driver provides a private API for writing platform-specific
  * drivers.
  */
 
@@ -162,35 +163,40 @@ struct wm97xx_data {
     int p;
 };
 
-/* Codec GPIO status
+/*
+ * Codec GPIO status
  */
 typedef enum {
     WM97XX_GPIO_HIGH,
     WM97XX_GPIO_LOW
 } wm97xx_gpio_status_t;
 
-/* Codec GPIO direction
+/*
+ * Codec GPIO direction
  */
 typedef enum {
     WM97XX_GPIO_IN,
     WM97XX_GPIO_OUT
 } wm97xx_gpio_dir_t;
 
-/* Codec GPIO polarity
+/*
+ * Codec GPIO polarity
  */
 typedef enum {
     WM97XX_GPIO_POL_HIGH,
     WM97XX_GPIO_POL_LOW
 } wm97xx_gpio_pol_t;
 
-/* Codec GPIO sticky
+/*
+ * Codec GPIO sticky
  */
 typedef enum {
     WM97XX_GPIO_STICKY,
     WM97XX_GPIO_NOTSTICKY
 } wm97xx_gpio_sticky_t;
 
-/* Codec GPIO wake
+/*
+ * Codec GPIO wake
  */
 typedef enum {
     WM97XX_GPIO_WAKE,
@@ -215,7 +221,7 @@ extern struct wm97xx_codec_drv wm97xx_co
  */
 struct wm97xx_codec_drv {
 	u16 id;
-    char *name;
+	char *name;
 	int (*poll_sample) (struct wm97xx *, int adcsel, int *sample);	/* read 1 sample */
 	int (*poll_touch) (struct wm97xx *, struct wm97xx_data *);	/* read X,Y,[P] in poll */
 	int (*digitiser_ioctl) (struct wm97xx *, int cmd);
@@ -228,14 +234,14 @@ struct wm97xx_mach_ops {
 
 	/* accelerated touch readback - coords are transmited on AC97 link */
 	int acc_enabled;
-    void (*acc_pen_up) (struct wm97xx *);
-    int (*acc_pen_down) (struct wm97xx *);
-    int (*acc_startup) (struct wm97xx *);
-    void (*acc_shutdown) (struct wm97xx *);
-
-    /* pre and post sample - can be used to minimise any analog noise */
-    void (*pre_sample) (int);  /* function to run before sampling */
-    void (*post_sample) (int);  /* function to run after sampling */
+	void (*acc_pen_up) (struct wm97xx *);
+	int (*acc_pen_down) (struct wm97xx *);
+	int (*acc_startup) (struct wm97xx *);
+	void (*acc_shutdown) (struct wm97xx *);
+
+	/* pre and post sample - can be used to minimise any analog noise */
+	void (*pre_sample) (int);  /* function to run before sampling */
+	void (*post_sample) (int);  /* function to run after sampling */
 };
 
 struct wm97xx {
@@ -245,26 +251,27 @@ struct wm97xx {
 	struct input_dev* input_dev;	/* touchscreen input device */
 	struct snd_ac97 *ac97;		/* ALSA codec access */
 	struct device *dev;		/* ALSA device */
-    struct device *battery_dev;
-    struct device *touch_dev;
-    struct wm97xx_mach_ops *mach_ops;
-    struct mutex codec_mutex;
+	struct device *battery_dev;
+	struct device *touch_dev;
+	struct wm97xx_mach_ops *mach_ops;
+	struct mutex codec_mutex;
 	struct completion ts_init;
 	struct completion ts_exit;
 	struct task_struct *ts_task;
-	unsigned int pen_irq;	/* Pen IRQ number in use */
+	unsigned int pen_irq;		/* Pen IRQ number in use */
 	wait_queue_head_t pen_irq_wait;	/* Pen IRQ wait queue */
 	struct workqueue_struct *pen_irq_workq;
 	struct work_struct pen_event_work;
-	u16 acc_slot; /* AC97 slot used for acc touch data */
-	u16 acc_rate; /* acc touch data rate */
+	u16 acc_slot;			/* AC97 slot used for acc touch data */
+	u16 acc_rate;			/* acc touch data rate */
 	unsigned int ts_use_count;
-	unsigned pen_is_down:1;	/* Pen is down */
-	unsigned aux_waiting:1;	/* aux measurement waiting */
+	unsigned pen_is_down:1;		/* Pen is down */
+	unsigned aux_waiting:1;		/* aux measurement waiting */
 	unsigned pen_probably_down:1;	/* used in polling mode */
 };
 
-/* Codec GPIO access (not supported on WM9705)
+/*
+ * Codec GPIO access (not supported on WM9705)
  * This can be used to set/get codec GPIO and Virtual GPIO status.
  */
 wm97xx_gpio_status_t wm97xx_get_gpio(struct wm97xx *wm, u32 gpio);
