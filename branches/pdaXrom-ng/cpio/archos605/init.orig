#!/bin/sh

NEWROOT_PATH="/new-root"
ROOT_PATH="/mnt/system"
MEDIA_PATH="/mnt/data"
USB_MOUNT_POINT="/mnt/data/System/UPDATE"
RECOVERY_SCRIPT="/etc/scripts/recovery.sh"
AOS_INSTALL_SCRIPT="/etc/scripts/aos_install.sh"
HDD_LOCK_RECOVERY_SCRIPT="/etc/scripts/hdd_lock_recovery.sh"
AUID=/bin/auid
AUI=/bin/aui
SYS_INFO=/bin/sys_info
AOSPARSER=/bin/aosparser
CRAMFSCHECKER=/bin/echo

HDD_LOCK=/bin/echo

GETFLASHPARAM=/bin/getflashparam
INSMOD=/sbin/insmod
RMMOD=/sbin/rmmod
MOUNT=/bin/mount
UMOUNT=/bin/umount
MKDIR=/bin/mkdir

DIRTY_CALIBRATION_FILENAME=$ROOT_PATH"/calibration_is_dirty"

DO_UPDATE=0
DO_USB_HOST_UPDATE=0
DO_BOOT=0
UPDATE_DONE=0
RECOVERY_ERROR_CODE=""
HDMI_LOADED=0
CPIO_FAILED=0

mount -t proc proc /proc
mount -t sysfs sysfs /sys
#mount -t tmpfs tmpfs /tmp

ln -s /proc/mounts /etc/mtab 

CMDLINE=`cat /proc/cmdline`

for param in $CMDLINE ; do
    case "$param" in
        root=*|init=*|media=*)
            eval "$param"
            ;;
    esac
done

if [ -z "$media" ] ; then
    media=/dev/hda1
fi

if [ -z "$root" ] ; then
    root=/dev/hda2
fi

#starts aui deamon
# not redirected output to /dev/null in order to test aui
$AUID &

#/bin/sh
#exit 0
sleep 1
	
FORCE_RECOVERY=0
RECOVERY_COUNTER=3
while [  $RECOVERY_COUNTER -gt 0 ]; do
	KEY=`$AUI --get-recovery`

	echo "recovery key ($RECOVERY_COUNTER) => $KEY"
	
	if [ "$KEY" = "recovery=1" ] ; then
		echo "forcing recovery ..."
		FORCE="forcing"
		DO_UPDATE=1
		FORCE_RECOVERY=1
		RECOVERY_ERROR_CODE="101"
		let RECOVERY_COUNTER=0
	elif [ "$KEY" = "recovery=2" ] ; then
		echo "recovery : will loop ..."
		let RECOVERY_COUNTER-=1
		sleep 1
	else
		echo "recovery : exiting loop ..."
		let RECOVERY_COUNTER=0
	fi
done

KEY=`$AUI --stop-recovery`

###abcd42wqyde

PRODUCT_NAME=`$SYS_INFO p`
AOS_FILENAME=`$SYS_INFO f`
AOS_EXTENSION="aos"
AOS_FULLFILENAME="$MEDIA_PATH/pwnd"
#e_$AOS_FILENAME.$AOS_EXTENSION"
MEDIA_PARTITION_LABEL=`$SYS_INFO l`
echo "CPIO SYS_INFO - PRODUCT $PRODUCT_NAME - FAT LABEL $MEDIA_PARTITION_LABEL - AOSFILENAME $AOS_FILENAME"
POS=`$GETFLASHPARAM 1008`
echo "POS $POS"

if [ "$PRODUCT_NAME" = "a705" ]; then
PRESS_BUTTON_REQUEST="press and hold TV/LCD button to restart"
else
PRESS_BUTTON_REQUEST="press OK to restart"
fi

echo "starting hdd lock"
$HDD_LOCK
hdd_lock_result=$?
if [  $hdd_lock_result -eq 2 ] ; then
# hdd bad serial
	if [ "$PRODUCT_NAME" = "archostv+" ] ; then
		$AUI --setvideooutput 2
	fi
$HDD_LOCK_RECOVERY_SCRIPT /dev/hda $root $ROOT_PATH $media $MEDIA_PATH $MEDIA_PARTITION_LABEL $AOS_FULLFILENAME
fi

install_hdmi()
{
	if [ $HDMI_LOADED -eq 0 ] ; then
		$INSMOD /lib/modules/ad98xx.ko
		$INSMOD /lib/modules/ad9889_hdmi.ko
		let HDMI_LOADED=1
	fi
}

uninstall_hdmi()
{
	if [ $HDMI_LOADED -eq 1 ] ; then		
		$RMMOD ad9889_hdmi
		$RMMOD ad98xx
		let HDMI_LOADED=0
	fi
}

install_usb_host()
{
	$MKDIR $USB_MOUNT_POINT
#install all usb moduled needed
	$INSMOD /lib/modules/usbcore.ko
	$INSMOD /lib/modules/musb_hdrc.ko mode_default=1 use_dma=1
	$INSMOD /lib/modules/scsi_mod.ko
	$INSMOD /lib/modules/sd_mod.ko
	$INSMOD /lib/modules/sg.ko
	$INSMOD /lib/modules/usb-storage.ko
}

uninstall_usb_host()
{
#uninstall usb host drivers
	$RMMOD usb-storage
	$RMMOD sg
	$RMMOD sd_mod
	$RMMOD scsi_mod
	$RMMOD musb_hdrc
	$RMMOD usbcore	
}

nice_usb_host_wait_screen()
{
	#GIVE some times to the driver layer to check USB disk on the bus
	sleep 1
	$AUI -c message -T "Recovery"  -a centered -t "Checking for an update on a USB key... (5s)"
	sleep 1
	$AUI -c message -T "Recovery"  -a centered -t "Checking for an update on a USB key... (4s)"
	sleep 1
	$AUI -c message -T "Recovery"  -a centered -t "Checking for an update on a USB key... (3s)"
	sleep 1
	$AUI -c message -T "Recovery"  -a centered -t "Checking for an update on a USB key... (2s)"
	sleep 1
	$AUI -c message -T "Recovery"  -a centered -t "Checking for an update on a USB key... (1s)"
	sleep 1
}

detect_usb_host_update()
{
	CHOICE=0
	# USBHOST detection
	echo "usbhost update detection..."
	
	#mount USB disk
	#try the two way of mounting the device... it is not very nice to do that ...
	$MOUNT -t vfat -o noatime,utf8,shortname=mixed /dev/sda $USB_MOUNT_POINT
	$MOUNT -t vfat -o noatime,utf8,shortname=mixed /dev/sda1 $USB_MOUNT_POINT
	# check for aos file
	let AOS_EXIST=0
	echo "looking for $USB_MOUNT_POINT/firmware_$AOS_FILENAME.$AOS_EXTENSION..."
	if [ -e "$USB_MOUNT_POINT/firmware_$AOS_FILENAME.$AOS_EXTENSION" ] ; then
		let AOS_EXIST=1
	fi
	echo "AOS FILES $AOS_EXIST"
	if [ $AOS_EXIST -ne 0 ] ; then
		KEY=`$AUI -c select -T "Recovery" -a centered \
                     -t "Update your device with the file - firmware_$AOS_FILENAME.$AOS_EXTENSION - ?" \
                     -t "Yes" -t No --blocked`
		CHOICE=`$AUI --get-selected`
		if [ $CHOICE = "selected=1" ] || [ $KEY = "key=esc" ] ; then
			let DO_USB_HOST_UPDATE=0
			$AUI -c message -T "Recovery"  -a centered -t "Update skipped..." 
		else
			let DO_USB_HOST_UPDATE=1
		fi
	fi
	if [ $DO_USB_HOST_UPDATE -eq 1 ] ; then
		$AUI -c message -T "Recovery"  -a centered -t "Update in progress..." 
		if [ $AOS_EXIST -eq 1 ] ; then
			echo "executing $USB_MOUNT_POINT/firmware_$AOS_FILENAME.$AOS_EXTENSION..."
#		$AOSPARSER "$USB_MOUNT_POINT/firmware_$AOS_FILENAME.$AOS_EXTENSION" $ROOT_PATH # > /dev/null 2>&1
			AOS_RET=0

			
			if [ $AOS_RET -ne 0 ] ; then
				echo "update failed (code $AOS_RET)"
				$AUI -c select -T "Recovery" -a centered -t "Update failed (code $AOS_RET)." -t "press OK to restart" --blocked
# reboot
				let DO_BOOT=0
				break
			else
				sync
				echo "update successful"
				$AUI -c select -T "Recovery" -a centered -t "Update successful. You can unplug your USB disk now." -t "press OK to restart" --blocked
				let UPDATE_DONE=1
# reboot
				let DO_BOOT=0
				break
			fi
		else
			echo "update failed (firmware_$AOS_FILENAME.$AOS_EXTENSION not found)"
				$AUI -c select -T "Recovery" -a centered -t "Update failed (firmware_$AOS_FILENAME.$AOS_EXTENSION not found)." -t "press OK to restart" --blocked
# reboot
				let DO_BOOT=0
				break
		fi

		
		let DO_UPDATE=0
		let DO_USB_HOST_UPDATE=0
	fi
	#unmount USB disk
	$UMOUNT $USB_MOUNT_POINT
}


COUNTER=4
while [  $COUNTER -gt 0 ]; do
	
	mount -t ext3 -o rw $root $ROOT_PATH > /dev/null 2>&1 
	ROOT_FAILED=$?
	if [ $ROOT_FAILED -ne 0 ] ; then
		echo "mounting ext3 failed"
		if [ -z "$RECOVERY_ERROR_CODE" ]
		then
		    RECOVERY_ERROR_CODE="102"
		fi
	fi
	
	mount -t vfat -o rw,noatime,utf8,shortname=mixed $media $MEDIA_PATH > /dev/null 2>&1 
	MEDIA_FAILED=$?
	if [ $MEDIA_FAILED -ne 0 ] ; then
		echo "mounting media failed"
		if [ -z "$RECOVERY_ERROR_CODE" ]
		then
		    RECOVERY_ERROR_CODE="103"
		fi
	else
		# check if media is actually a FAT32 (and not a FAT12/16)
		if [ "`dd if=$media bs=1 skip=22 count=2 2> /dev/null`" != "`echo -ne \"\000\000\"`" ] || [ "`dd if=$media bs=1 skip=36 count=4 2> /dev/null`" = "`echo -ne \"\000\000\000\000\"`" ]; then
			echo "media is not a FAT32"
			MEDIA_FAILED=1
			umount $MEDIA_PATH
			if [ -z "$RECOVERY_ERROR_CODE" ]; then
				RECOVERY_ERROR_CODE="107"
			fi
		fi
	fi
	if [ "$PRODUCT_NAME" = "archostv+" ] ; then
		install_hdmi
	fi
	#one mount failed -> start recovery
	if [ $ROOT_FAILED -ne 0 ] || [ $MEDIA_FAILED -ne 0 ] || [ $FORCE_RECOVERY -eq 1 ] ; then
		echo "$FORCE recovery..."
		if [ "$PRODUCT_NAME" = "archostv+" ] ; then
			$AUI -c startvideoouttoggle
			KEY=`$AUI -c select -T "Recovery" -a centered\
                                  -t "Would you like to use a USB key to update your device?"\
                                  -t No -t "Yes" --blocked`
			CHOICE=`$AUI --get-selected`
			if [ $CHOICE = "selected=0" ] || [ $KEY = "key=esc" ] ; then
				let DO_USB_HOST_UPDATE=0
			else
				let DO_USB_HOST_UPDATE=1
				KEY=`$AUI -c select -T "Recovery" -a centered -t "Plug your USB key into the USB Host port (file named firmware_$AOS_FILENAME.$AOS_EXTENSION must be at the root level of the USB key)"\
                                -t "OK" --blocked`
			fi
		fi
		if [ $DO_USB_HOST_UPDATE -eq 1 ] ; then
			$AUI -c message -T "Recovery"  -a centered\
                             -t "Checking for an update on a USB key..."
			install_usb_host			
			echo "detect_usb_host_update"
			nice_usb_host_wait_screen
			#test if there is an update via usb_host
			detect_usb_host_update
			uninstall_usb_host
		else
			# unmount filesystems in preparation of USB connection
			if [ $ROOT_FAILED -eq 0 ]; then
				umount $ROOT_PATH
			fi
			if [ $MEDIA_FAILED -eq 0 ]; then
				umount $MEDIA_PATH
			fi
	
			# always enable the battery charger when running the recovery
			echo "1" > /sys/devices/system/battery/battery0/force_state
	
			$RECOVERY_SCRIPT /dev/hda $ROOT_FAILED $MEDIA_FAILED $DO_UPDATE $root $media $MEDIA_PARTITION_LABEL "$RECOVERY_ERROR_CODE" $MEDIA_PATH $PRODUCT_NAME
			result=$?
	
			echo "-1" > /sys/devices/system/battery/battery0/force_state
	
			if [  $result -eq 2 ] ; then
				echo "skipping recovery"
				let FORCE_RECOVERY=0
				let DO_BOOT=1
			elif [  $result -eq 3 ] ; then
				mount -t ext3 -o rw $root $ROOT_PATH > /dev/null 2>&1 
				mount_result=$?
	
				if [ $mount_result -eq 0 ] ; then
					echo "writing dirty file "$DIRTY_CALIBRATION_FILENAME
					echo > $DIRTY_CALIBRATION_FILENAME
					umount $ROOT_PATH
				else
					echo "cannot writing dirty file"
				fi
				echo "and skipping recovery"
				let FORCE_RECOVERY=0
				let DO_BOOT=1
	
			elif [ $result -ne 0 ] ; then
				echo "recovery failed."
				# reboot
				let DO_BOOT=0
				break
			else
				let DO_UPDATE=2
				let FORCE_RECOVERY=0	
			fi
		fi
	else		
		#test if an update has been done via usb host
		if [ $UPDATE_DONE -eq 0 ] ; then			
			# check for aos file
			let AOS_EXIST=0
			echo "looking for $AOS_FULLFILENAME..."
			if [ -d $AOS_FULLFILENAME ] ; then
				let AOS_EXIST=1
			fi
			echo "AOS FILES $AOS_EXIST"
			if [ $AOS_EXIST -ne 0 ] && [ $UPDATE_DONE -eq 0 ] && [ $DO_UPDATE -eq 2 ] ; then
				$AUI -c message -T "Update"  -a centered -t "update file exists. updating..." 
				if [ $AOS_EXIST -eq 1 ] ; then
					echo "executing $AOS_FULLFILENAME..."
					cp $AOS_FULLFILENAME/* $ROOT_PATH 

					AOS_RET=0

				fi
	
				if [ $AOS_RET -ne 0 ] ; then
					echo "update failed (code $AOS_RET)"
					$AUI -c select -T "Update" -a centered -t "update failed (code $AOS_RET)" -t $PRESS_BUTTON_REQUEST --blocked
					# reboot
					let DO_BOOT=0
					break
				else
					sync
					echo "update successful"
					$AUI -c select -T "Update" -a centered -t "update successful" -t $PRESS_BUTTON_REQUEST --blocked
					let UPDATE_DONE=1
					# reboot
					let DO_BOOT=0
					break
				fi
			else
				$AUI -c stopvideoouttoggle
				#normaly boot
				echo "booting normally (no aos file found)..."
	
				# if a605, check for CPIO on drive
				if [ "$PRODUCT_NAME" = "a605" -o "$PRODUCT_NAME" = "a705" -o "$PRODUCT_NAME" = "a405hdd" ] && [ ! -e "${ROOT_PATH}/cpio.secure" ] ; then
					echo "CPIO missing on ext3"
					let CPIO_FAILED=1
					RECOVERY_ERROR_CODE="108"
				elif [ -e $ROOT_PATH/rootfs.cramfs.secure ] ; then
					$CRAMFSCHECKER $ROOT_PATH/rootfs.cramfs.secure
	
					if [ $? -eq 0 ] ; then
						dd if=$ROOT_PATH/rootfs.cramfs.secure of=/dev/ram0 bs=256 skip=1
						mount -t cramfs -o loop /dev/ram0 $NEWROOT_PATH # > /dev/null 2>&1
					
						if [ $? -eq 0 ] ; then
							let DO_BOOT=1
							break
						else
							echo "mounting secured cramfs failed"
							RECOVERY_ERROR_CODE="106"
						fi
					else
						echo "Secured cramfs check failed"
						RECOVERY_ERROR_CODE="105"
					fi
	
				else
					echo "no secured cramfs file found"	
					RECOVERY_ERROR_CODE="104"
				fi
	
				let DO_UPDATE=1
				let FORCE_RECOVERY=1
			fi
		fi #UPDATE DONE from usb host = 0
	fi
	
	if [ "x`mount | grep $ROOT_PATH`" != "x" ] ; then	
		umount $ROOT_PATH > /dev/null 2>&1	
		if [ $? -ne 0 ] ; then
	
			let DO_BOOT=0
			break
		fi
	fi
	
	let UMOUNT_COUNTER=6
	while [  "x`mount | grep $MEDIA_PATH`" != "x" ] && [ $UMOUNT_COUNTER -gt 0 ]; do
		umount $MEDIA_PATH > /dev/null 2>&1 
		
		sleep 1
		
		let UMOUNT_COUNTER-=1
	done

	if [ $? -ne 0 ]; then
	
		let DO_BOOT=0	
		break
	fi
		
	let COUNTER-=1
done

#if [ "$PRODUCT_NAME" = "archostv+" ] ; then
#	uninstall_hdmi
#fi
# interactive shell in order to test aui
# /bin/ash

if [ "$PRODUCT_NAME" = "a605" -o "$PRODUCT_NAME" = "a705" -o "$PRODUCT_NAME" = "a405hdd" ] && [ $CPIO_FAILED -ne 0 ] ; then
	let DO_BOOT=0
fi

if [ "$PRODUCT_NAME" = "a705" ]; then
	OLD_LABEL=`/bin/fatvollabel $media`
	
	if [ "x$OLD_LABEL" != "xA705" ]; then
		echo "change volume name $OLD_LABEL to A705"
		/bin/fatvollabel $media A705
	fi
fi

if [ "$PRODUCT_NAME" = "a405hdd" ]; then
	OLD_LABEL=`/bin/fatvollabel $media`
	
	if [ "x$OLD_LABEL" != "xA405" ]; then
		echo "change volume name $OLD_LABEL to A405"
		/bin/fatvollabel $media A405
	fi
fi



if [ $DO_BOOT -eq 1 ] && [ $COUNTER -gt 0 ] ; then

	# Should POS be launched or avos?
	if [ $POS -ne 0 ] ; then
		$CRAMFSCHECKER $ROOT_PATH/posfs.cramfs.secure
		if [ $? -ne 0 ] ; then
			echo "Secured pos cramfs check failed"
			let POS=0
		fi
	fi
	export POS
	export ROOT_PATH

	if [ -z "$init" ] ; then
    	init=/sbin/init
	fi

	#terminate User Interface Deamon
	$AUI --terminate > /dev/null 2>&1 


	# Move /proc over.  The LFS bootscripts can handle it, and doing it
	# this way means that we don't need to include any umount binary.

	#mount -o move $MEDIA_PATH $NEWROOT_PATH/media
	#mount -o move /proc $NEWROOT_PATH/proc
	
	umount $MEDIA_PATH
	umount $ROOT_PATH
	umount /sys
	umount /proc

	echo "SWITCHING TO REAL ROOT"
	exec run-init $NEWROOT_PATH $init "$@"

else
	echo "REBOOT"
	# restart
#	if [ "$PRODUCT_NAME" = "archostv+" ] ; then
#		$AUI -c reboot
#	else
		umount $MEDIA_PATH
		umount $ROOT_PATH
		/sbin/reboot
#	fi
	while true; do sleep 1; done
fi
