diff -Nur u-boot-2006-04-18-1106/board/corgi/Makefile u-boot-2006-04-18-1106-new/board/corgi/Makefile
--- u-boot-2006-04-18-1106/board/corgi/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2006-04-18-1106-new/board/corgi/Makefile	2006-07-05 11:19:44.000000000 +0000
@@ -0,0 +1,51 @@
+#
+# board/Akita/Makefile
+#
+# (C) Copyright 2006 Alexander Chukov <sash@pdaXrom.org>
+#
+# (C) Copyright 2000
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= corgi.o nand.o kbd.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -Nur u-boot-2006-04-18-1106/board/corgi/config.mk u-boot-2006-04-18-1106-new/board/corgi/config.mk
--- u-boot-2006-04-18-1106/board/corgi/config.mk	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2006-04-18-1106-new/board/corgi/config.mk	2006-07-05 11:19:44.000000000 +0000
@@ -0,0 +1 @@
+TEXT_BASE = 0xa1000000
diff -Nur u-boot-2006-04-18-1106/board/corgi/corgi.c u-boot-2006-04-18-1106-new/board/corgi/corgi.c
--- u-boot-2006-04-18-1106/board/corgi/corgi.c	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2006-04-18-1106-new/board/corgi/corgi.c	2006-07-05 11:19:44.000000000 +0000
@@ -0,0 +1,87 @@
+/*
+ * board/corgi/corgi.c
+ *
+ * Configuration settings for the Sharp Zaurus SL-C7x0/860.
+ *
+ * (C) Copyright 2006 Alexander Chukov <sash@pdaXrom.org>
+ *
+ * portions from adsvix board configuration:
+ * (C) Copyright 2004
+ * Robert Whaley, Applied Data Systems, Inc. rwhaley@applieddata.net
+ * (C) Copyright 2002
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+/* ------------------------------------------------------------------------- */
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	/* memory and cpu-speed are setup before relocation */
+	/* so we do _nothing_ here */
+
+	/* arch number of Sharp Zaurus Corgi : MACH_TYPE_CORGI */
+	gd->bd->bi_arch_number = 423;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0xa0000100;
+
+	/* set cpu turbo mode */
+	set_turbo_mode();
+
+	corgikbd_init();
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+	setenv("stdout", "serial");
+	setenv("stderr", "serial");
+	return 0;
+}
+
+
+int dram_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+	gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
+	gd->bd->bi_dram[2].start = PHYS_SDRAM_3;
+	gd->bd->bi_dram[2].size = PHYS_SDRAM_3_SIZE;
+	gd->bd->bi_dram[3].start = PHYS_SDRAM_4;
+	gd->bd->bi_dram[3].size = PHYS_SDRAM_4_SIZE;
+
+	return 0;
+}
diff -Nur u-boot-2006-04-18-1106/board/corgi/kbd.c u-boot-2006-04-18-1106-new/board/corgi/kbd.c
--- u-boot-2006-04-18-1106/board/corgi/kbd.c	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2006-04-18-1106-new/board/corgi/kbd.c	2006-07-05 11:19:44.000000000 +0000
@@ -0,0 +1,202 @@
+/*
+ * board/corgi/kbd.c
+ *
+ * Keyboard driver for the Sharp Zaurus SL-C7x0/860.
+ *
+ * (C) Copyright 2006 Alexander Chukov <sash@pdaXrom.org>
+ *
+ * portions from:
+ *
+ * linux/drivers/input/keyboard/spitzkbd.c
+ *
+ * Keyboard driver for Sharp Corgi models (SL-C7xx)
+ *
+ * Copyright (C) 2005 Richard Purdie
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <config.h>
+#include <version.h>
+#include <asm/arch/pxa-regs.h>
+
+#define GPIO_DFLT_LOW		0x400
+#define GPIO_DFLT_HIGH		0x800
+
+void pxa_gpio_mode(int gpio_mode)
+{
+	int gpio = gpio_mode & GPIO_MD_MASK_NR;
+	int fn = (gpio_mode & GPIO_MD_MASK_FN) >> 8;
+	int gafr;
+
+	if (gpio_mode & GPIO_DFLT_LOW)
+		GPCR(gpio) = GPIO_bit(gpio);
+	else if (gpio_mode & GPIO_DFLT_HIGH)
+		GPSR(gpio) = GPIO_bit(gpio);
+	if (gpio_mode & GPIO_MD_MASK_DIR)
+		GPDR(gpio) |= GPIO_bit(gpio);
+	else
+		GPDR(gpio) &= ~GPIO_bit(gpio);
+	gafr = GAFR(gpio) & ~(0x3 << (((gpio) & 0xf)*2));
+	GAFR(gpio) = gafr |  (fn  << (((gpio) & 0xf)*2));
+}
+
+/*
+ * Corgi Keyboard Definitions
+ */
+#define CORGI_KEY_STROBE_NUM		(12)
+#define CORGI_KEY_SENSE_NUM			(8)
+#define CORGI_GPIO_ALL_STROBE_BIT	(0x00003ffc)
+#define CORGI_GPIO_HIGH_SENSE_BIT	(0xfc000000)
+#define CORGI_GPIO_HIGH_SENSE_RSHIFT	(26)
+#define CORGI_GPIO_LOW_SENSE_BIT	(0x00000003)
+#define CORGI_GPIO_LOW_SENSE_LSHIFT	(6)
+#define CORGI_GPIO_STROBE_BIT(a)	GPIO_bit(66+(a))
+#define CORGI_GPIO_SENSE_BIT(a)		GPIO_bit(58+(a))
+#define CORGI_GAFR_ALL_STROBE_BIT	(0x0ffffff0)
+#define CORGI_GAFR_HIGH_SENSE_BIT	(0xfff00000)
+#define CORGI_GAFR_LOW_SENSE_BIT	(0x0000000f)
+#define CORGI_GPIO_KEY_SENSE(a)		(58+(a))
+#define CORGI_GPIO_KEY_STROBE(a)	(66+(a))
+
+#define CORGI_GPIO_AK_INT			(4)	/* Headphone Jack Control Interrupt */
+
+#define KB_ROWS				8
+#define KB_COLS				12
+#define KB_ROWMASK(r)		(1 << (r))
+#define SCANCODE(r,c)		( ((r)<<4) + (c) + 1 )
+/* zero code, 124 scancodes */
+#define	NR_SCANCODES		( SCANCODE(KB_ROWS-1,KB_COLS-1) +1 +1 )
+
+#define SCAN_INTERVAL		(50) /* ms */
+#define HINGE_SCAN_INTERVAL	(250) /* ms */
+
+#define KB_DISCHARGE_DELAY	10
+#define KB_ACTIVATE_DELAY	10
+
+static inline void corgikbd_discharge_all(void)
+{
+	/* STROBE All HiZ */
+	GPCR2  = CORGI_GPIO_ALL_STROBE_BIT;
+	GPDR2 &= ~CORGI_GPIO_ALL_STROBE_BIT;
+}
+
+static inline void corgikbd_activate_all(void)
+{
+	/* STROBE ALL -> High */
+	GPSR2  = CORGI_GPIO_ALL_STROBE_BIT;
+	GPDR2 |= CORGI_GPIO_ALL_STROBE_BIT;
+
+	udelay(KB_DISCHARGE_DELAY);
+
+	/* Clear any interrupts we may have triggered when altering the GPIO lines */
+	GEDR1 = CORGI_GPIO_HIGH_SENSE_BIT;
+	GEDR2 = CORGI_GPIO_LOW_SENSE_BIT;
+}
+
+static inline void corgikbd_activate_col(int col)
+{
+	/* STROBE col -> High, not col -> HiZ */
+	GPSR2 = CORGI_GPIO_STROBE_BIT(col);
+	GPDR2 = (GPDR2 & ~CORGI_GPIO_ALL_STROBE_BIT) | CORGI_GPIO_STROBE_BIT(col);
+}
+
+static inline void corgikbd_reset_col(int col)
+{
+	/* STROBE col -> Low */
+	GPCR2 = CORGI_GPIO_STROBE_BIT(col);
+	/* STROBE col -> out, not col -> HiZ */
+	GPDR2 = (GPDR2 & ~CORGI_GPIO_ALL_STROBE_BIT) | CORGI_GPIO_STROBE_BIT(col);
+}
+
+#define GET_ROWS_STATUS(c)	(((GPLR1 & CORGI_GPIO_HIGH_SENSE_BIT) >> CORGI_GPIO_HIGH_SENSE_RSHIFT) | ((GPLR2 & CORGI_GPIO_LOW_SENSE_BIT) << CORGI_GPIO_LOW_SENSE_LSHIFT))
+
+static int corgikbd_scankeyboard(void)
+{
+	unsigned int row, col, rowd;
+	unsigned int num_pressed;
+	int ret = -1;
+
+	num_pressed = 0;
+	for (col = 0; col < KB_COLS; col++) {
+		corgikbd_discharge_all();
+		udelay(KB_DISCHARGE_DELAY);
+
+		corgikbd_activate_col(col);
+		udelay(KB_ACTIVATE_DELAY);
+
+		rowd = GET_ROWS_STATUS(col);
+		for (row = 0; row < KB_ROWS; row++) {
+			unsigned int scancode, pressed;
+
+			scancode = SCANCODE(row, col);
+			pressed = rowd & KB_ROWMASK(row);
+
+			if (pressed)
+			    ret = scancode;
+		}
+		corgikbd_reset_col(col);
+	}
+
+	corgikbd_activate_all();
+
+	return ret;
+}
+
+void corgikbd_init(void)
+{
+	int i;
+	
+	/* Setup sense interrupts - RisingEdge Detect, sense lines as inputs */
+	for (i = 0; i < CORGI_KEY_SENSE_NUM; i++)
+		pxa_gpio_mode(CORGI_GPIO_KEY_SENSE(i) | GPIO_IN);
+
+	/* Set Strobe lines as outputs - set high */
+	for (i = 0; i < CORGI_KEY_STROBE_NUM; i++)
+		pxa_gpio_mode(CORGI_GPIO_KEY_STROBE(i) | GPIO_OUT | GPIO_DFLT_HIGH);
+
+	/* Setup the headphone jack as an input */
+	pxa_gpio_mode(CORGI_GPIO_AK_INT | GPIO_IN);
+}
+
+int do_testkey(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int scan;
+	
+	if (argc < 2)
+		return 1;
+
+	scan = corgikbd_scankeyboard();
+
+
+//	if (scan >= 0)
+//		printf("Scan = %d\n", scan);
+//	else
+//		printf("Nothing!\n");
+
+	return !(simple_strtol(argv[1], NULL, 10) == scan);
+}
+
+U_BOOT_CMD(
+	testkey,   2,      1,      do_testkey,
+	"testkey - compare pressed key with arg\n",
+	"<key scancode>"
+);
diff -Nur u-boot-2006-04-18-1106/board/corgi/lowlevel_init.S u-boot-2006-04-18-1106-new/board/corgi/lowlevel_init.S
--- u-boot-2006-04-18-1106/board/corgi/lowlevel_init.S	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2006-04-18-1106-new/board/corgi/lowlevel_init.S	2006-07-05 11:19:44.000000000 +0000
@@ -0,0 +1,136 @@
+/*
+ * board/corgi/lowlevel_init.S
+ *
+ * Configuration settings for the Sharp Zaurus SL-C7x0/860.
+ *
+ * (C) Copyright 2006 Alexander Chukov <sash@pdaXrom.org>
+ *
+ * This was originally from the Lubbock u-boot port and from BLOB with cleanup
+ *
+ * NOTE: I haven't clean this up considerably, just enough to get it
+ * running. See hal_platform_setup.h for the source. See
+ * board/cradle/lowlevel_init.S for another PXA250 setup that is
+ * much cleaner.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/arch/pxa-regs.h>
+
+/* wait for coprocessor write complete */
+   .macro CPWAIT reg
+   mrc	p15,0,\reg,c2,c0,0
+   mov	\reg,\reg
+   sub	pc,pc,#4
+   .endm
+
+/*********** Write out to HEX 7 segment leds *********/
+
+#undef DEBUG_HEXLOG
+
+#ifdef DEBUG_HEXLOG
+#define LEDCTL		0x08000040
+#define LEDDAT1	0x08000010
+#define LEDDAT2	0x08000014
+
+.macro wait, count
+	mov		r10, \count
+0:
+	subs	r10, r10, #1
+	bne		0b
+.endm
+
+.macro hexlog_init
+	ldr		r11, =LEDCTL
+	mov		r10, #0xff
+	str		r10, [r11]
+	ldr		r11, =LEDDAT2
+	mov		r10, #0xFFFFFFFF
+	str		r10, [r11]
+	ldr		r11, =LEDDAT1
+	mov		r10, #0x0
+	str		r10, [r11]
+.endm
+
+.macro hexlog, val
+	ldr		r11, =LEDCTL
+	mov		r10, #0xff
+	str		r10, [r11]
+	ldr		r11, =LEDDAT2
+	mov		r10, #0xFFFFFFFF
+	str		r10, [r11]
+
+	ldr		r11, =LEDDAT1
+	mov		r10, \val
+	str		r10, [r11]
+
+	wait		#0x400000
+.endm
+
+#else
+
+.macro hexlog_init
+	nop
+.endm
+
+.macro hexlog, val
+	nop
+.endm
+
+#endif
+
+/***********************************/
+
+/*
+ *	Memory setup
+ */
+
+.globl lowlevel_init
+lowlevel_init:
+
+	mov	pc, lr
+
+.globl set_turbo_mode
+
+set_turbo_mode:
+	/* Turn on turbo mode */
+	mrc	p14, 0, r2, c6, c0, 0
+	orr	r2, r2, #0x3		/* Turbo, Freq change */
+	mcr	p14, 0, r2, c6, c0, 0
+
+
+	/* Setup vectors */
+	ldr	r0, =TEXT_BASE
+	ldr	r1, =TEXT_BASE+0x40
+	ldr	r2, =0x0
+1:
+	ldr	r3, [r0]
+	str	r3, [r2]
+	add	r0, r0, #4
+	add	r2, r2, #4
+	cmp	r0, r1
+	bne	1b
+
+	ldr	r0, =0x0
+	ldr	r1, [r0, #4]
+	str	r1, [r0]
+
+	mov	pc, lr
diff -Nur u-boot-2006-04-18-1106/board/corgi/nand.c u-boot-2006-04-18-1106-new/board/corgi/nand.c
--- u-boot-2006-04-18-1106/board/corgi/nand.c	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2006-04-18-1106-new/board/corgi/nand.c	2006-07-05 11:19:44.000000000 +0000
@@ -0,0 +1,157 @@
+/*
+ * board/corgi/nand.c
+ *
+ * NAND driver for the Sharp Zaurus SL-C7x0/860.
+ *
+ * (C) Copyright 2006 Alexander Chukov <sash@pdaXrom.org>
+ *
+ * portions from mtd nand driver:
+ *
+ * drivers/mtd/nand/sharpsl.c
+ *
+ * Copyright (C) 2004 Richard Purdie
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+
+#include <nand.h>
+#include <linux/mtd/nand_ecc.h>
+
+static int sharpsl_io_base = CFG_NAND_BASE;
+
+/* register offset */
+#define ECCLPLB	 	sharpsl_io_base+0x00	/* line parity 7 - 0 bit */
+#define ECCLPUB	 	sharpsl_io_base+0x04	/* line parity 15 - 8 bit */
+#define ECCCP	   	sharpsl_io_base+0x08	/* column parity 5 - 0 bit */
+#define ECCCNTR	 	sharpsl_io_base+0x0C	/* ECC byte counter */
+#define ECCCLRR	 	sharpsl_io_base+0x10	/* cleare ECC */
+#define FLASHIO	 	sharpsl_io_base+0x14	/* Flash I/O */
+#define FLASHCTL	sharpsl_io_base+0x18	/* Flash Control */
+
+/* Flash control bit */
+#define FLRYBY		(1 << 5)
+#define FLCE1		(1 << 4)
+#define FLWP		(1 << 3)
+#define FLALE		(1 << 2)
+#define FLCLE		(1 << 1)
+#define FLCE0		(1 << 0)
+
+#define readb(address) *((volatile unsigned char *)(address))
+#define writeb(v, address) *((volatile unsigned char *)(address))=v
+
+/*
+ *	hardware specific access to control-lines
+ */
+static void
+sharpsl_nand_hwcontrol(struct mtd_info* mtd, int cmd)
+{
+	switch (cmd) {
+	case NAND_CTL_SETCLE:
+		writeb(readb(FLASHCTL) | FLCLE, FLASHCTL);
+		break;
+	case NAND_CTL_CLRCLE:
+		writeb(readb(FLASHCTL) & ~FLCLE, FLASHCTL);
+		break;
+
+	case NAND_CTL_SETALE:
+		writeb(readb(FLASHCTL) | FLALE, FLASHCTL);
+		break;
+	case NAND_CTL_CLRALE:
+		writeb(readb(FLASHCTL) & ~FLALE, FLASHCTL);
+		break;
+
+	case NAND_CTL_SETNCE:
+		writeb(readb(FLASHCTL) & ~(FLCE0|FLCE1), FLASHCTL);
+		break;
+	case NAND_CTL_CLRNCE:
+		writeb(readb(FLASHCTL) | (FLCE0|FLCE1), FLASHCTL);
+		break;
+	}
+}
+
+static int
+sharpsl_nand_dev_ready(struct mtd_info* mtd)
+{
+	return !((readb(FLASHCTL) & FLRYBY) == 0);
+}
+
+static void
+sharpsl_nand_enable_hwecc(struct mtd_info* mtd, int mode)
+{
+	writeb(0 ,ECCCLRR);
+}
+
+static int
+sharpsl_nand_calculate_ecc(struct mtd_info* mtd, const u_char* dat,
+				u_char* ecc_code)
+{
+	ecc_code[0] = ~readb(ECCLPUB);
+	ecc_code[1] = ~readb(ECCLPLB);
+	ecc_code[2] = (~readb(ECCCP) << 2) | 0x03;
+	return readb(ECCCNTR) != 0;
+}
+
+static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+
+static struct nand_bbt_descr sharpsl_bbt = {
+	.options = 0,
+	.offs = 4,
+	.len = 2,
+	.pattern = scan_ff_pattern
+};
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+void board_nand_init(struct nand_chip *nand)
+{
+	writeb(readb(FLASHCTL) | FLWP, FLASHCTL);
+
+	nand->IO_ADDR_R = FLASHIO;
+	nand->IO_ADDR_W = FLASHIO;
+	nand->hwcontrol = sharpsl_nand_hwcontrol;
+	nand->dev_ready = sharpsl_nand_dev_ready;
+	nand->eccmode = NAND_ECC_HW3_256;
+	nand->chip_delay = 15;
+	nand->badblock_pattern = &sharpsl_bbt;
+	nand->enable_hwecc = sharpsl_nand_enable_hwecc;
+	nand->calculate_ecc = sharpsl_nand_calculate_ecc;
+	nand->correct_data = nand_correct_data;
+}
+#endif /* (CONFIG_COMMANDS & CFG_CMD_NAND) */
diff -Nur u-boot-2006-04-18-1106/board/corgi/u-boot.lds u-boot-2006-04-18-1106-new/board/corgi/u-boot.lds
--- u-boot-2006-04-18-1106/board/corgi/u-boot.lds	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2006-04-18-1106-new/board/corgi/u-boot.lds	2006-07-05 11:19:44.000000000 +0000
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/pxa/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Nur u-boot-2006-04-18-1106/include/configs/corgi.h u-boot-2006-04-18-1106-new/include/configs/corgi.h
--- u-boot-2006-04-18-1106/include/configs/corgi.h	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2006-04-18-1106-new/include/configs/corgi.h	2006-07-13 11:19:04.000000000 +0000
@@ -0,0 +1,326 @@
+/*
+ * include/configs/corgi.h
+ *
+ * Configuration settings for the Sharp Zaurus SL-C7x0/C860.
+ *
+ * (C) Copyright 2006 Alexander Chukov <sash@pdaXrom.org>
+ *
+ * portions from adsvix board configuration:
+ * (C) Copyright 2004
+ * Robert Whaley, Applied Data Systems, Inc. rwhaley@applieddata.net
+ * (C) Copyright 2002
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+
+#undef SKIP_CONFIG_RELOCATE_UBOOT
+
+#undef CONFIG_HARD_I2C
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_PXA250		1	/* This is an PXA255 CPU    */
+#define CONFIG_CORGI		1	/* on Sharp Zaurus Corgi    */
+//#define CONFIG_MMC			1
+#define BOARD_LATE_INIT		1
+
+#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff */
+
+#define RTC			1
+
+/*
+ * Size of malloc() pool
+ */
+//#define CFG_MALLOC_LEN	    (CFG_ENV_SIZE + 128*1024)
+#define CFG_MALLOC_LEN	    (CFG_ENV_SIZE + 256*1024)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_FFUART	       1       /* we use FFUART on Mainstone */
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_BAUDRATE	       115200
+//#define CONFIG_DOS_PARTITION   1
+
+#undef CONFIG_SHOW_BOOT_PROGRESS
+
+#if 1
+#define	CONFIG_BOOTDELAY	1
+#define CONFIG_AUTOBOOT_PROMPT  "Autobooting in %d seconds\n"
+
+#define	CONFIG_BOOTCOMMAND						\
+	"if testkey 102 ; "												\
+	"then "														\
+		"nand read.logical 0xa0800000 0x00060000 0x00540000; "							\
+		"setenv bootargs console=ttyS0,115200 console=tty1 root=/dev/ram rw ramdisk_size=8192; " 		\
+		"bootm; "												\
+	"fi; "														\
+	"if testkey 49 ; "												\
+	"then "														\
+		"nand read.logical 0xa0800000 0x005a0000 0x00160000; "							\
+		"setenv bootargs console=ttyS0,115200 console=tty1 root=/dev/mmcblk0p1; " 				\
+		"bootm; "												\
+	"fi; "														\
+	"if testkey 65 ; "												\
+	"then "														\
+		"nand read.logical 0xa0800000 0x005a0000 0x00160000; "							\
+		"setenv bootargs console=ttyS0,115200 console=tty1 root=/dev/hda1; "			 		\
+		"bootm; "												\
+	"fi; "														\
+	"if testkey 81 ; "												\
+	"then "														\
+		"nand read.logical 0xa0800000 0x005a0000 0x00160000; "							\
+		"setenv bootargs console=ttyS0,115200 console=tty1 root=/dev/hdc1; "			 		\
+		"bootm; "												\
+	"fi; "														\
+	"nand read.logical 0xa0800000 0x005a0000 0x00160000; "								\
+	"setenv bootargs console=ttyS0,115200 console=tty1 root=/dev/mtdblock2 rootfstype=jffs2; " 			\
+	"bootm; "
+#else
+#define CONFIG_BOOTCOMMAND	"" // "run boot_flash"
+#endif
+
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 console=tty1 root=/dev/ram rw ramdisk_size=8192"
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_CMDLINE_TAG	 1	/* enable passing of ATAGs	*/
+#define CONFIG_INITRD_TAG	 1
+
+#define CONFIG_COMMANDS		((				\
+				    CONFIG_CMD_DFL 	| 	\
+				    CFG_CMD_NAND 	|	\
+				    CFG_CMD_JFFS2	 	\
+				    ) & ~(			\
+				    CFG_CMD_NET 	| 	\
+				    CFG_CMD_FLASH 	| 	\
+				    CFG_CMD_IMLS 	 	\
+				))
+
+//				    CFG_CMD_ENV
+			
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400		/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CFG_HUSH_PARSER		1
+#define CFG_PROMPT_HUSH_PS2	"> "
+
+#define CFG_LONGHELP				/* undef to save memory		*/
+#define CFG_PROMPT		"U-Boot> "	/* Monitor Command Prompt */
+
+#define CFG_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+#define CFG_DEVICE_NULLDEV	1
+
+#define CFG_MEMTEST_START	0xa0400000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0xa0800000	/* 4 ... 8 MB in DRAM	*/
+
+#undef	CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CFG_LOAD_ADDR		0xa0800000	/* default load address */
+
+#define CFG_HZ			3686400		/* incrementer freq: 3.6864 MHz */
+#define CFG_CPUSPEED		0x207		/* need to look more closely, I think this is Turbo = 2x, L=91Mhz */
+
+						/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define CFG_MMC_BASE		0xF0000000
+
+/*
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	4	   /* we have 2 banks of DRAM */
+#define PHYS_SDRAM_1		0xa0000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+#define PHYS_SDRAM_2		0xa4000000 /* SDRAM Bank #2 */
+#define PHYS_SDRAM_2_SIZE	0x00000000 /* 0 MB */
+#define PHYS_SDRAM_3		0xa8000000 /* SDRAM Bank #3 */
+#define PHYS_SDRAM_3_SIZE	0x00000000 /* 0 MB */
+#define PHYS_SDRAM_4		0xac000000 /* SDRAM Bank #4 */
+#define PHYS_SDRAM_4_SIZE	0x00000000 /* 0 MB */
+
+#define PHYS_FLASH_1		0xd4000000 /* Flash Bank #1 */
+
+#define CFG_DRAM_BASE		0xa0000000
+#define CFG_DRAM_SIZE		0x04000000
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/*
+ * GPIO settings for Mainstone
+ */
+
+#define CFG_GPSR0_VAL		0x00708800
+#define CFG_GPSR1_VAL		0x03cf0002
+#define CFG_GPSR2_VAL		0x0021FC00
+#define CFG_GPSR3_VAL		0x00000000
+
+#define CFG_GPCR0_VAL		0x00001000
+#define CFG_GPCR1_VAL		0x00000000
+#define CFG_GPCR2_VAL		0x00000000
+#define CFG_GPCR3_VAL		0x00000000
+
+#define CFG_GPDR0_VAL		0xC27B9C04
+#define CFG_GPDR1_VAL		0x00EFAA83
+#define CFG_GPDR2_VAL		0x0E23FC00
+#define CFG_GPDR3_VAL		0x001E1F81
+
+#define CFG_GAFR0_L_VAL		0x94F00000
+#define CFG_GAFR0_U_VAL		0x015A859A
+#define CFG_GAFR1_L_VAL		0x999A955A
+#define CFG_GAFR1_U_VAL		0x0005A4AA
+#define CFG_GAFR2_L_VAL		0x6AA00000
+#define CFG_GAFR2_U_VAL		0x55A8041A
+#define CFG_GAFR3_L_VAL		0x56AA955A
+#define CFG_GAFR3_U_VAL		0x00000001
+
+#define CFG_PSSR_VAL		0x20	// ???????????
+
+/*
+ * PCMCIA and CF Interfaces
+ */
+#define CFG_MECR_VAL		0x00000001
+#define CFG_MCMEM0_VAL		0x00010204
+#define CFG_MCMEM1_VAL		0x00010204
+#define CFG_MCATT0_VAL		0x00010204
+#define CFG_MCATT1_VAL		0x00010204
+#define CFG_MCIO0_VAL		0x0000c108
+#define CFG_MCIO1_VAL		0x0001c108
+
+//#define CONFIG_PXA_PCMCIA 1
+//#define CONFIG_PXA_IDE 1
+
+#define CONFIG_PCMCIA_SLOT_A 1
+/* just to keep build system happy  */
+
+#define CFG_PCMCIA_MEM_ADDR     0x28000000
+#define CFG_PCMCIA_MEM_SIZE     0x04000000
+
+#define CFG_IDE_MAXBUS		1
+/* max. 1 IDE bus		*/
+#define CFG_IDE_MAXDEVICE	1
+/* max. 1 drive per IDE bus	*/
+
+#define CFG_ATA_IDE0_OFFSET	0x0000
+
+#define CFG_ATA_BASE_ADDR	0x20000000
+
+/* Offset for data I/O			*/
+#define CFG_ATA_DATA_OFFSET	0x1f0
+
+/* Offset for normal register accesses	*/
+#define CFG_ATA_REG_OFFSET	0x1f0
+
+/* Offset for alternate registers	*/
+#define CFG_ATA_ALT_OFFSET	0x3f0
+
+#define CFG_NO_FLASH 1
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	512	/* max number of sectors on one chip	*/
+
+/*-----------------------------------------------------------------------
+ * NAND-FLASH stuff
+ *-----------------------------------------------------------------------
+ */
+#undef CFG_NAND_LEGACY
+
+/* NAND debugging */
+//#define CONFIG_MTD_DEBUG
+//#define CONFIG_MTD_DEBUG_VERBOSE 3
+
+#define CFG_NAND_BASE		0xd4000000
+#define CFG_MAX_NAND_DEVICE	1	/* Max number of NAND devices		*/
+#define NAND_MAX_CHIPS 		1
+
+//#define CONFIG_MTD_NAND_VERIFY_WRITE 1  /* verify all writes!!!         */
+//#define CFG_NAND_SKIP_BAD_DOT_I      1  /* ".i" read skips bad blocks   */
+
+#define CONFIG_JFFS2_NAND 1			/* jffs2 on nand support */
+#define NAND_CACHE_PAGES 16			/* size of nand cache in 512 bytes pages */
+
+#define NAND_ALLOW_ERASE_ALL	1
+
+/*
+ * JFFS2 partitions
+ *
+ */
+/* No command line, one static partition */
+//#undef CONFIG_JFFS2_CMDLINE
+//#define CONFIG_JFFS2_DEV		"nand0"
+//#define CONFIG_JFFS2_PART_SIZE		0xFFFFFFFF
+//#define CONFIG_JFFS2_PART_OFFSET	0x00060000
+
+/* mtdparts command line support */
+/* Note: fake mtd_id used, no linux mtd map file */
+
+#define CONFIG_JFFS2_CMDLINE
+#define MTDIDS_DEFAULT		"nand0=laze-0"
+//#define MTDPARTS_DEFAULT	"mtdparts=laze-0:256k(uboot),128k(env),-(jffs2)"
+#define MTDPARTS_DEFAULT	"mtdparts=laze-0:7168k(Logical),-(JFFS2)"
+
+/*
+ * SHARP SL NAND logical partition
+ */
+#define NAND_LOGICAL		1
+#define NAND_LOGICAL_SIZE	0x700000
+
+/*
+ * Environment
+ */
+
+#define CFG_ENV_IS_IN_NAND	1
+#define CFG_ENV_OFFSET		0x40000
+//#define CFG_ENV_OFFSET_REDUND	0x44000
+#define CFG_ENV_SIZE		0x20000
+
+#endif	/* __CONFIG_H */
diff -Nur u-boot-2006-04-18-1106/board/corgi/kbd.c u-boot-2006-04-18-1106-new/board/corgi/kbd.c
--- u-boot-2006-04-18-1106/board/corgi/kbd.c	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2006-04-18-1106-new/board/corgi/kbd.c	2006-07-05 11:19:44.000000000 +0000
@@ -0,0 +1,202 @@
+/*
+ * board/corgi/kbd.c
+ *
+ * Keyboard driver for the Sharp Zaurus SL-C7x0/860.
+ *
+ * (C) Copyright 2006 Alexander Chukov <sash@pdaXrom.org>
+ *
+ * portions from:
+ *
+ * linux/drivers/input/keyboard/spitzkbd.c
+ *
+ * Keyboard driver for Sharp Corgi models (SL-C7xx)
+ *
+ * Copyright (C) 2005 Richard Purdie
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <config.h>
+#include <version.h>
+#include <asm/arch/pxa-regs.h>
+
+#define GPIO_DFLT_LOW		0x400
+#define GPIO_DFLT_HIGH		0x800
+
+void pxa_gpio_mode(int gpio_mode)
+{
+	int gpio = gpio_mode & GPIO_MD_MASK_NR;
+	int fn = (gpio_mode & GPIO_MD_MASK_FN) >> 8;
+	int gafr;
+
+	if (gpio_mode & GPIO_DFLT_LOW)
+		GPCR(gpio) = GPIO_bit(gpio);
+	else if (gpio_mode & GPIO_DFLT_HIGH)
+		GPSR(gpio) = GPIO_bit(gpio);
+	if (gpio_mode & GPIO_MD_MASK_DIR)
+		GPDR(gpio) |= GPIO_bit(gpio);
+	else
+		GPDR(gpio) &= ~GPIO_bit(gpio);
+	gafr = GAFR(gpio) & ~(0x3 << (((gpio) & 0xf)*2));
+	GAFR(gpio) = gafr |  (fn  << (((gpio) & 0xf)*2));
+}
+
+/*
+ * Corgi Keyboard Definitions
+ */
+#define CORGI_KEY_STROBE_NUM		(12)
+#define CORGI_KEY_SENSE_NUM			(8)
+#define CORGI_GPIO_ALL_STROBE_BIT	(0x00003ffc)
+#define CORGI_GPIO_HIGH_SENSE_BIT	(0xfc000000)
+#define CORGI_GPIO_HIGH_SENSE_RSHIFT	(26)
+#define CORGI_GPIO_LOW_SENSE_BIT	(0x00000003)
+#define CORGI_GPIO_LOW_SENSE_LSHIFT	(6)
+#define CORGI_GPIO_STROBE_BIT(a)	GPIO_bit(66+(a))
+#define CORGI_GPIO_SENSE_BIT(a)		GPIO_bit(58+(a))
+#define CORGI_GAFR_ALL_STROBE_BIT	(0x0ffffff0)
+#define CORGI_GAFR_HIGH_SENSE_BIT	(0xfff00000)
+#define CORGI_GAFR_LOW_SENSE_BIT	(0x0000000f)
+#define CORGI_GPIO_KEY_SENSE(a)		(58+(a))
+#define CORGI_GPIO_KEY_STROBE(a)	(66+(a))
+
+#define CORGI_GPIO_AK_INT			(4)	/* Headphone Jack Control Interrupt */
+
+#define KB_ROWS				8
+#define KB_COLS				12
+#define KB_ROWMASK(r)		(1 << (r))
+#define SCANCODE(r,c)		( ((r)<<4) + (c) + 1 )
+/* zero code, 124 scancodes */
+#define	NR_SCANCODES		( SCANCODE(KB_ROWS-1,KB_COLS-1) +1 +1 )
+
+#define SCAN_INTERVAL		(50) /* ms */
+#define HINGE_SCAN_INTERVAL	(250) /* ms */
+
+#define KB_DISCHARGE_DELAY	10
+#define KB_ACTIVATE_DELAY	10
+
+static inline void corgikbd_discharge_all(void)
+{
+	/* STROBE All HiZ */
+	GPCR2  = CORGI_GPIO_ALL_STROBE_BIT;
+	GPDR2 &= ~CORGI_GPIO_ALL_STROBE_BIT;
+}
+
+static inline void corgikbd_activate_all(void)
+{
+	/* STROBE ALL -> High */
+	GPSR2  = CORGI_GPIO_ALL_STROBE_BIT;
+	GPDR2 |= CORGI_GPIO_ALL_STROBE_BIT;
+
+	udelay(KB_DISCHARGE_DELAY);
+
+	/* Clear any interrupts we may have triggered when altering the GPIO lines */
+	GEDR1 = CORGI_GPIO_HIGH_SENSE_BIT;
+	GEDR2 = CORGI_GPIO_LOW_SENSE_BIT;
+}
+
+static inline void corgikbd_activate_col(int col)
+{
+	/* STROBE col -> High, not col -> HiZ */
+	GPSR2 = CORGI_GPIO_STROBE_BIT(col);
+	GPDR2 = (GPDR2 & ~CORGI_GPIO_ALL_STROBE_BIT) | CORGI_GPIO_STROBE_BIT(col);
+}
+
+static inline void corgikbd_reset_col(int col)
+{
+	/* STROBE col -> Low */
+	GPCR2 = CORGI_GPIO_STROBE_BIT(col);
+	/* STROBE col -> out, not col -> HiZ */
+	GPDR2 = (GPDR2 & ~CORGI_GPIO_ALL_STROBE_BIT) | CORGI_GPIO_STROBE_BIT(col);
+}
+
+#define GET_ROWS_STATUS(c)	(((GPLR1 & CORGI_GPIO_HIGH_SENSE_BIT) >> CORGI_GPIO_HIGH_SENSE_RSHIFT) | ((GPLR2 & CORGI_GPIO_LOW_SENSE_BIT) << CORGI_GPIO_LOW_SENSE_LSHIFT))
+
+static int corgikbd_scankeyboard(void)
+{
+	unsigned int row, col, rowd;
+	unsigned int num_pressed;
+	int ret = -1;
+
+	num_pressed = 0;
+	for (col = 0; col < KB_COLS; col++) {
+		corgikbd_discharge_all();
+		udelay(KB_DISCHARGE_DELAY);
+
+		corgikbd_activate_col(col);
+		udelay(KB_ACTIVATE_DELAY);
+
+		rowd = GET_ROWS_STATUS(col);
+		for (row = 0; row < KB_ROWS; row++) {
+			unsigned int scancode, pressed;
+
+			scancode = SCANCODE(row, col);
+			pressed = rowd & KB_ROWMASK(row);
+
+			if (pressed)
+			    ret = scancode;
+		}
+		corgikbd_reset_col(col);
+	}
+
+	corgikbd_activate_all();
+
+	return ret;
+}
+
+void corgikbd_init(void)
+{
+	int i;
+	
+	/* Setup sense interrupts - RisingEdge Detect, sense lines as inputs */
+	for (i = 0; i < CORGI_KEY_SENSE_NUM; i++)
+		pxa_gpio_mode(CORGI_GPIO_KEY_SENSE(i) | GPIO_IN);
+
+	/* Set Strobe lines as outputs - set high */
+	for (i = 0; i < CORGI_KEY_STROBE_NUM; i++)
+		pxa_gpio_mode(CORGI_GPIO_KEY_STROBE(i) | GPIO_OUT | GPIO_DFLT_HIGH);
+
+	/* Setup the headphone jack as an input */
+	pxa_gpio_mode(CORGI_GPIO_AK_INT | GPIO_IN);
+}
+
+int do_testkey(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int scan;
+	
+	if (argc < 2)
+		return 1;
+
+	scan = corgikbd_scankeyboard();
+
+
+//	if (scan >= 0)
+//		printf("Scan = %d\n", scan);
+//	else
+//		printf("Nothing!\n");
+
+	return !(simple_strtol(argv[1], NULL, 10) == scan);
+}
+
+U_BOOT_CMD(
+	testkey,   2,      1,      do_testkey,
+	"testkey - compare pressed key with arg\n",
+	"<key scancode>"
+);
