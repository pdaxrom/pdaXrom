From jan.altenberg@linutronix.de Tue Jun 19 16:07:25 2007
Return-Path: <jan.altenberg@linutronix.de>
X-Spam-Checker-Version: SpamAssassin 3.1.7-deb (2006-10-05) on debian
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=AWL autolearn=unavailable 
	version=3.1.7-deb
Received: from [192.168.0.182] (unknown [91.89.185.36]) (using SSLv3 with
	cipher RC4-MD5 (128/128 bits)) (No client certificate requested) by
	mail.tglx.de (Postfix) with ESMTP id C80AC65C065; Tue, 19 Jun 2007 16:07:25
	+0200 (CEST)
Subject: freeze with mcount_enabled=1
From: Jan Altenberg <jan.altenberg@linutronix.de>
To: Ingo Molnar <mingo@elte.hu>
Cc: tglx@linutronix.de
Content-Type: text/plain
Date: Tue, 19 Jun 2007 16:07:25 +0200
Message-Id: <1182262045.3793.111.camel@bender>
Mime-Version: 1.0
X-Mailer: Evolution 2.8.3 (2.8.3-2.fc6) 
X-Evolution-Source: imap://tglx%40linutronix.de@localhost:8993/
Content-Transfer-Encoding: 8bit

Hi Ingo,
Hi Thomas,

I've seen reproducable freezes on ARM for user triggered latency traces
with mcount_enabled = 1:

echo 1 > /proc/sys/kernel/mcount_enabled
cyclictest -p80 -n -b 300

ends up in a frozen system. I added some instrumentation to the latency
tracer code and it looks like the freeze happens when _trace_cmdline()
is called from user_trace_start().
_trace_cmdline() calls ____trace() and after that we freeze...

With the following Patch, the freezes seem to disappear (tested on a
SAM926x and an EP93). I think, this isn't the correct solution, but it
might give you an idea, what goes wrong.

Let me know, if you have something new for testing.

Regards,
	Jan
---

---
 kernel/latency_trace.c |    2 ++
 1 file changed, 2 insertions(+)

Index: linux-2.6.23.1-rt5/kernel/latency_trace.c
===================================================================
--- linux-2.6.23.1-rt5.orig/kernel/latency_trace.c
+++ linux-2.6.23.1-rt5/kernel/latency_trace.c
@@ -2365,10 +2365,12 @@ long user_trace_start(void)
 #endif
 	reset_trace_idx(cpu, tr);
 
+	atomic_inc(&tr->disabled);
 	tr->critical_sequence = max_sequence;
 	tr->preempt_timestamp = get_monotonic_cycles();
 	tr->critical_start = CALLER_ADDR0;
 	_trace_cmdline(cpu, tr);
+	atomic_dec(&tr->disabled);
 	mcount();
 
 	WARN_ON(!irqs_disabled());
