diff -Nur tint2-0.11/AUTHORS tint2-read-only/AUTHORS
--- tint2-0.11/AUTHORS	2009-11-06 01:48:26.000000000 +0600
+++ tint2-read-only/AUTHORS	2010-12-23 00:02:32.329666193 +0600
@@ -1,6 +1,6 @@
 
 tint2 is developped by :
-- Thierry Lorthiois <lorthiois@bbsoft.fr>
+- Thierry Lorthiois <lorthiois@bbsoft.fr> from Omega distribution
 - Andreas Fink <andreas.fink85@googlemail.com>
 - Euan Freeman <euan04@gmail.com> (tintwizard)
 - Christian Ruppert <Spooky85@gmail.com> (autotools build system)
diff -Nur tint2-0.11/ChangeLog tint2-read-only/ChangeLog
--- tint2-0.11/ChangeLog	2010-06-26 19:41:52.000000000 +0700
+++ tint2-read-only/ChangeLog	2010-12-23 00:02:32.329666193 +0600
@@ -1,5 +1,6 @@
 2010-06-26
 - unhide tint2 panel when dragging something
+- battery FreeBSD uses the new ACPI API (thx to yamagi.burmeister)
 
 2010-06-16
 - Set _NET_WM_ICON_GEOMETRY for every task
diff -Nur tint2-0.11/CMakeLists.txt tint2-read-only/CMakeLists.txt
--- tint2-0.11/CMakeLists.txt	2010-06-16 04:38:14.000000000 +0700
+++ tint2-read-only/CMakeLists.txt	2010-12-23 00:02:32.329666193 +0600
@@ -3,18 +3,18 @@
 
 include( FindPkgConfig )
 include( CheckLibraryExists )
-pkg_check_modules( X11 REQUIRED x11 xcomposite xdamage xinerama xrender xrandr )
+pkg_check_modules( X11 REQUIRED x11 xcomposite xdamage xinerama xrender xrandr>=1.3 )
 pkg_check_modules( PANGOCAIRO REQUIRED pangocairo )
 pkg_check_modules( PANGO REQUIRED pango )
 pkg_check_modules( CAIRO REQUIRED cairo )
 pkg_check_modules( GLIB2 REQUIRED glib-2.0 )
 pkg_check_modules( GOBJECT2 REQUIRED gobject-2.0 )
-pkg_check_modules( IMLIB2 REQUIRED imlib2 )
+pkg_check_modules( IMLIB2 REQUIRED imlib2>=1.4.2 )
 find_library( RT_LIBRARY rt )
 
-if( NOT (X11_FOUND AND PANGOCAIRO_FOUND AND PANGO_FOUND AND CAIRO_FOUND AND GLIB2_FOUND AND GOBJECT2_FOUND AND IMLIB2_FOUND) )
+if( NOT X11_FOUND OR NOT PANGOCAIRO_FOUND OR NOT PANGO_FOUND OR NOT CAIRO_FOUND OR NOT GLIB2_FOUND OR NOT GOBJECT2_FOUND OR NOT IMLIB2_FOUND )
   message( FATAL_ERROR "Not all dependencies fulfilled. See http://code.google.com/p/tint2/wiki/Install" )
-endif( NOT (X11_FOUND AND PANGOCAIRO_FOUND AND PANGO_FOUND AND CAIRO_FOUND AND GLIB2_FOUND AND GOBJECT2_FOUND AND IMLIB2_FOUND) )
+endif( NOT X11_FOUND OR NOT PANGOCAIRO_FOUND OR NOT PANGO_FOUND OR NOT CAIRO_FOUND OR NOT GLIB2_FOUND OR NOT GOBJECT2_FOUND OR NOT IMLIB2_FOUND )
 
 string( REPLACE ";" " " FLAGS_REPLACED "${IMLIB2_LDFLAGS}" )
 set( CMAKE_REQUIRED_FLAGS "${FLAGS_REPLACED}" )
@@ -29,6 +29,7 @@
                      src/clock
                      src/systray
                      src/taskbar
+                     src/launcher
                      src/tooltip
                      src/util
                      ${X11_INCLUDE_DIRS}
@@ -45,8 +46,12 @@
              src/tint.c
              src/clock/clock.c
              src/systray/systraybar.c
+             src/launcher/launcher.c
+             src/launcher/xsettings-client.c
+             src/launcher/xsettings-common.c
              src/taskbar/task.c
              src/taskbar/taskbar.c
+             src/taskbar/taskbarname.c
              src/tooltip/tooltip.c
              src/util/area.c
              src/util/common.c
@@ -62,17 +67,17 @@
   add_definitions( -DENABLE_BATTERY )
 endif( ENABLE_BATTERY )
 
+set( MANDIR share/man CACHE PATH "Directory for man pages" )
+set( DATADIR share CACHE PATH "Directory for shared data" )
+set( SYSCONFDIR /etc CACHE PATH "Directory for configuration files" )
+set( DOCDIR share/doc/tint2 CACHE PATH "Directory for documentation files" )
+
 if( ENABLE_TINT2CONF )
   add_definitions( -DHAVE_VERSION_H )
   add_subdirectory( src/tint2conf )
   add_dependencies( tint2conf version )
 endif( ENABLE_TINT2CONF )
 
-set( MANDIR share/man CACHE PATH "Directory for man pages" )
-set( DATADIR share CACHE PATH "Directory for shared data" )
-set( SYSCONFDIR /etc CACHE PATH "Directory for configuration files" )
-set( DOCDIR share/doc/tint2 CACHE PATH "Directory for documentation files" )
-
 add_custom_target( version ALL "${PROJECT_SOURCE_DIR}/get_svnrev.sh" "\"${PROJECT_SOURCE_DIR}\"" )
 
 link_directories( ${X11_LIBRARY_DIRS}
diff -Nur tint2-0.11/get_svnrev.sh tint2-read-only/get_svnrev.sh
--- tint2-0.11/get_svnrev.sh	2010-06-26 19:41:58.000000000 +0700
+++ tint2-read-only/get_svnrev.sh	2010-12-23 00:02:32.329666193 +0600
@@ -1 +1,27 @@
-echo "#define VERSION_STRING \"0.11\"" > version.h
+#!/bin/sh
+
+FALLBACK=\"0.11-svn\"
+
+if [ $# -eq 0 ]; then
+  DIR=.
+else
+  DIR=$1
+fi
+
+if [ -f version.h ]; then
+  REV_OLD=$(cat version.h  | cut -d" " -f3)
+else
+  REV_OLD=\"\"
+fi
+
+if [ -x "$(which svnversion 2>/dev/null)" -a -d "${DIR}/.svn" ] ; then
+  REV=\"$(svnversion -n ${DIR})\"
+else
+  REV=${FALLBACK}
+fi
+
+if [ ${REV_OLD} != ${REV} ]; then
+  echo "Building new version.h"
+  echo "Rev_old: ${REV_OLD} Rev: ${REV}"
+  echo "#define VERSION_STRING ${REV}" > version.h
+fi
diff -Nur tint2-0.11/make_release.sh tint2-read-only/make_release.sh
--- tint2-0.11/make_release.sh	1970-01-01 07:00:00.000000000 +0700
+++ tint2-read-only/make_release.sh	2010-12-23 00:02:32.329666193 +0600
@@ -0,0 +1,23 @@
+#!/bin/bash
+
+# usage: ./make_release.sh RELEASE_VERSION_NUMBER
+
+if [[ $# -ne 1 ]]; then
+  echo "usage: $0 RELEASE_VERSION_NUMBER"
+  exit
+fi
+
+DIR=tint2-${1}
+echo "Making release ${DIR}"
+rm -Rf ${DIR}
+svn export . ${DIR} > /dev/null
+
+# delete unneeded files
+rm -f ${DIR}/configure ${DIR}/make_release.sh
+
+# replace get_svnrev.sh by a simple echo command
+echo "echo \"#define VERSION_STRING \\\"${1}\\\"\" > version.h" > ${DIR}/get_svnrev.sh
+
+# create tarball and remove the exported directory
+tar -cjf ${DIR}.tar.bz2 ${DIR}
+rm -Rf ${DIR}
diff -Nur tint2-0.11/sample/icon_and_text_1.tint2rc tint2-read-only/sample/icon_and_text_1.tint2rc
--- tint2-0.11/sample/icon_and_text_1.tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/icon_and_text_1.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -56,6 +56,7 @@
 task_active_background_id = 2
 task_urgent_background_id = 2
 task_iconified_background_id = 3
+task_tooltip = 0
 
 # Task Icons
 task_icon_asb = 70 0 0
@@ -90,7 +91,6 @@
 clock_rclick_command = orage
 
 # Tooltips
-tooltip = 0
 tooltip_padding = 2 2
 tooltip_show_timeout = 0.7
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/sample/icon_and_text_2.tint2rc tint2-read-only/sample/icon_and_text_2.tint2rc
--- tint2-0.11/sample/icon_and_text_2.tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/icon_and_text_2.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -56,6 +56,7 @@
 task_active_background_id = 2
 task_urgent_background_id = 2
 task_iconified_background_id = 3
+task_tooltip = 0
 
 # Task Icons
 task_icon_asb = 80 0 0
@@ -89,7 +90,6 @@
 clock_rclick_command = gsimplecal
 
 # Tooltips
-tooltip = 0
 tooltip_padding = 5 0
 tooltip_show_timeout = 0.7
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/sample/icon_and_text_3.tint2rc tint2-read-only/sample/icon_and_text_3.tint2rc
--- tint2-0.11/sample/icon_and_text_3.tint2rc	2010-05-15 21:43:01.000000000 +0700
+++ tint2-read-only/sample/icon_and_text_3.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -62,6 +62,7 @@
 task_active_background_id = 3
 task_urgent_background_id = 4
 task_iconified_background_id = 2
+task_tooltip = 1
 
 # Task Icons
 task_icon_asb = 80 0 0
@@ -95,7 +96,6 @@
 clock_rclick_command = gsimplecal
 
 # Tooltips
-tooltip = 1
 tooltip_padding = 5 0
 tooltip_show_timeout = 1.2
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/sample/icon_and_text_4.tint2rc tint2-read-only/sample/icon_and_text_4.tint2rc
--- tint2-0.11/sample/icon_and_text_4.tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/icon_and_text_4.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -62,6 +62,7 @@
 task_active_background_id = 1
 task_urgent_background_id = 4
 task_iconified_background_id = 2
+task_tooltip = 0
 
 # Task Icons
 task_icon_asb = 100 0 0
@@ -95,7 +96,6 @@
 clock_background_id = 1
 
 # Tooltips
-tooltip = 0
 tooltip_padding = 0 0
 tooltip_show_timeout = 0
 tooltip_hide_timeout = 0
diff -Nur tint2-0.11/sample/icon_only_1.tint2rc tint2-read-only/sample/icon_only_1.tint2rc
--- tint2-0.11/sample/icon_only_1.tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/icon_only_1.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -74,6 +74,7 @@
 task_active_background_id = 5
 task_urgent_background_id = 6
 task_iconified_background_id = 0
+task_tooltip = 1
 
 # Task Icons
 task_icon_asb = 100 -25 -8
@@ -109,7 +110,6 @@
 clock_rclick_command = gsimplecal
 
 # Tooltips
-tooltip = 1
 tooltip_padding = 5 3
 tooltip_show_timeout = 0.8
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/sample/icon_only_2.tint2rc tint2-read-only/sample/icon_only_2.tint2rc
--- tint2-0.11/sample/icon_only_2.tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/icon_only_2.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -62,6 +62,7 @@
 task_active_background_id = 3
 task_urgent_background_id = 3
 task_iconified_background_id = 0
+task_tooltip = 1
 
 # Task Icons
 task_icon_asb = 90 -100 -20
@@ -97,7 +98,6 @@
 clock_rclick_command = gsimplecal
 
 # Tooltips
-tooltip = 1
 tooltip_padding = 2 2
 tooltip_show_timeout = 0.9
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/sample/icon_only_3.tint2rc tint2-read-only/sample/icon_only_3.tint2rc
--- tint2-0.11/sample/icon_only_3.tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/icon_only_3.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -62,6 +62,7 @@
 task_active_background_id = 2
 task_urgent_background_id = 4
 task_iconified_background_id = 0
+task_tooltip = 0
 
 # Task Icons
 task_icon_asb = 70 0 0
@@ -86,7 +87,6 @@
 systray_icon_asb = 100 0 0
 
 # Tooltips
-tooltip = 0
 tooltip_padding = 2 2
 tooltip_show_timeout = 0.7
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/sample/icon_only_4.tint2rc tint2-read-only/sample/icon_only_4.tint2rc
--- tint2-0.11/sample/icon_only_4.tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/icon_only_4.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -62,6 +62,7 @@
 task_active_background_id = 2
 task_urgent_background_id = 4
 task_iconified_background_id = 3
+task_tooltip = 1
 
 # Task Icons
 task_icon_asb = 90 0 0
@@ -86,7 +87,6 @@
 systray_icon_asb = 100 0 -10
 
 # Tooltips
-tooltip = 1
 tooltip_padding = 5 0
 tooltip_show_timeout = 0.8
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/sample/icon_only_6.tint2rc tint2-read-only/sample/icon_only_6.tint2rc
--- tint2-0.11/sample/icon_only_6.tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/icon_only_6.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -62,6 +62,7 @@
 task_active_background_id = 2
 task_urgent_background_id = 2
 task_iconified_background_id = 3
+task_tooltip = 1
 
 # Task Icons
 task_icon_asb = 100 0 0
@@ -97,7 +98,6 @@
 clock_rclick_command = zenity --calendar
 
 # Tooltips
-tooltip = 1
 tooltip_padding = 3 2
 tooltip_show_timeout = 0.9
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/sample/icon_only_7.tint2rc tint2-read-only/sample/icon_only_7.tint2rc
--- tint2-0.11/sample/icon_only_7.tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/icon_only_7.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -56,6 +56,7 @@
 task_active_background_id = 3
 task_urgent_background_id = 0
 task_iconified_background_id = 0
+task_tooltip = 1
 
 # Task Icons
 task_icon_asb = 100 0 0
@@ -93,7 +94,6 @@
 time2_timezone = :Europe/Moscow
 
 # Tooltips
-tooltip = 1
 tooltip_padding = 5 4
 tooltip_show_timeout = 0.8
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/sample/text_only_1.tint2rc tint2-read-only/sample/text_only_1.tint2rc
--- tint2-0.11/sample/text_only_1.tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/text_only_1.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -68,6 +68,7 @@
 task_active_background_id = 1
 task_urgent_background_id = 0
 task_iconified_background_id = 4
+task_tooltip = 0
 
 # Task Icons
 task_icon_asb = 100 -90 -15
@@ -103,7 +104,6 @@
 clock_rclick_command = gsimplecal
 
 # Tooltips
-tooltip = 0
 tooltip_padding = 5 5
 tooltip_show_timeout = 0.7
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/sample/text_only_2.tint2rc tint2-read-only/sample/text_only_2.tint2rc
--- tint2-0.11/sample/text_only_2.tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/text_only_2.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -68,6 +68,7 @@
 task_active_background_id = 1
 task_urgent_background_id = 0
 task_iconified_background_id = 4
+task_tooltip = 0
 
 # Task Icons
 task_icon_asb = 100 -90 -15
@@ -103,7 +104,6 @@
 clock_rclick_command = gsimplecal
 
 # Tooltips
-tooltip = 0
 tooltip_padding = 5 5
 tooltip_show_timeout = 0.7
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/sample/text_only_3.tint2rc tint2-read-only/sample/text_only_3.tint2rc
--- tint2-0.11/sample/text_only_3.tint2rc	2010-05-18 15:50:17.000000000 +0700
+++ tint2-read-only/sample/text_only_3.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -50,6 +50,7 @@
 task_active_background_id = 2
 task_urgent_background_id = 2
 task_iconified_background_id = 0
+task_tooltip = 0
 
 # Task Icons
 task_icon_asb = 100 0 0
@@ -81,7 +82,6 @@
 clock_background_id = 0
 
 # Tooltips
-tooltip = 0
 tooltip_padding = 2 2
 tooltip_show_timeout = 0.5
 tooltip_hide_timeout = 1.2
diff -Nur tint2-0.11/sample/text_only_4.tint2rc tint2-read-only/sample/text_only_4.tint2rc
--- tint2-0.11/sample/text_only_4.tint2rc	2010-05-18 15:50:17.000000000 +0700
+++ tint2-read-only/sample/text_only_4.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -50,6 +50,7 @@
 task_active_background_id = 2
 task_urgent_background_id = 2
 task_iconified_background_id = 1
+task_tooltip = 0
 
 # Task Icons
 task_icon_asb = 100 0 0
@@ -74,7 +75,6 @@
 systray_icon_asb = 100 -100 -15
 
 # Tooltips
-tooltip = 0
 tooltip_padding = 0 0
 tooltip_show_timeout = 0
 tooltip_hide_timeout = 0
diff -Nur tint2-0.11/sample/text_only_5.tint2rc tint2-read-only/sample/text_only_5.tint2rc
--- tint2-0.11/sample/text_only_5.tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/text_only_5.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -56,6 +56,7 @@
 task_active_background_id = 2
 task_urgent_background_id = 2
 task_iconified_background_id = 1
+task_tooltip = 1
 
 # Task Icons
 task_icon_asb = 50 0 0
@@ -87,7 +88,6 @@
 clock_background_id = 0
 
 # Tooltips
-tooltip = 1
 tooltip_padding = 3 3
 tooltip_show_timeout = 1.5
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/sample/text_only_6.tint2rc tint2-read-only/sample/text_only_6.tint2rc
--- tint2-0.11/sample/text_only_6.tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/text_only_6.tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -56,6 +56,7 @@
 task_active_background_id = 2
 task_urgent_background_id = 2
 task_iconified_background_id = 0
+task_tooltip = 0
 
 # Task Icons
 task_icon_asb = 100 -90 -15
@@ -80,7 +81,6 @@
 systray_icon_asb = 100 -70 -15
 
 # Tooltips
-tooltip = 0
 tooltip_padding = 5 5
 tooltip_show_timeout = 0.7
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/sample/tint2rc tint2-read-only/sample/tint2rc
--- tint2-0.11/sample/tint2rc	2010-05-10 02:38:01.000000000 +0700
+++ tint2-read-only/sample/tint2rc	2010-12-23 00:02:31.919615891 +0600
@@ -56,6 +56,7 @@
 task_active_background_id = 2
 task_urgent_background_id = 2
 task_iconified_background_id = 3
+task_tooltip = 0
 
 # Task Icons
 task_icon_asb = 70 0 0
@@ -90,7 +91,6 @@
 clock_rclick_command = orage
 
 # Tooltips
-tooltip = 0
 tooltip_padding = 2 2
 tooltip_show_timeout = 0.7
 tooltip_hide_timeout = 0.3
diff -Nur tint2-0.11/src/battery/battery.c tint2-read-only/src/battery/battery.c
--- tint2-0.11/src/battery/battery.c	2010-06-12 01:47:26.000000000 +0700
+++ tint2-read-only/src/battery/battery.c	2010-12-23 00:02:32.279485615 +0600
@@ -24,20 +24,22 @@
 #include <cairo-xlib.h>
 #include <pango/pangocairo.h>
 
-#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
+#if defined(__OpenBSD__) || defined(__NetBSD__)
 #include <machine/apmvar.h>
 #include <err.h>
 #include <sys/ioctl.h>
 #include <unistd.h>
 #endif
 
+#if defined(__FreeBSD__)
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#endif
+
 #include "window.h"
 #include "server.h"
-#include "area.h"
 #include "panel.h"
-#include "taskbar.h"
 #include "battery.h"
-#include "clock.h"
 #include "timer.h"
 #include "common.h"
 
@@ -59,34 +61,38 @@
 char *path_current_now;
 char *path_status;
 
-#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
+#if defined(__OpenBSD__) || defined(__NetBSD__)
 int apm_fd;
 #endif
 
-
 void update_batterys(void* arg)
 {
-	int i;
+	int old_percentage = battery_state.percentage;
+	int16_t old_hours = battery_state.time.hours;
+	int8_t old_minutes = battery_state.time.minutes;
+	
 	update_battery();
+	if (old_percentage == battery_state.percentage && old_hours == battery_state.time.hours && old_minutes == battery_state.time.minutes)
+		return;
+
+	int i;
 	for (i=0 ; i < nb_panel ; i++) {
 		if (battery_state.percentage >= percentage_hide) {
 			if (panel1[i].battery.area.on_screen == 1) {
-				panel1[i].battery.area.on_screen = 0;
-				// force resize on panel
-				panel1[i].area.resize = 1;
+				hide(&panel1[i].battery.area);
 				panel_refresh = 1;
 			}
-			continue;
 		}
 		else {
 			if (panel1[i].battery.area.on_screen == 0) {
-				panel1[i].battery.area.on_screen = 1;
-				// force resize on panel
-				panel1[i].area.resize = 1;
+				show(&panel1[i].battery.area);
 				panel_refresh = 1;
 			}
 		}
-		panel1[i].battery.area.resize = 1;
+		if (panel1[i].battery.area.on_screen == 1) {
+			panel1[i].battery.area.resize = 1;
+			panel_refresh = 1;
+		}
 	}
 }
 
@@ -103,7 +109,10 @@
 	path_energy_full = 0;
 	path_current_now = 0;
 	path_status = 0;
-#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
+	battery_state.percentage = 0;
+	battery_state.time.hours = 0;
+	battery_state.time.minutes = 0;
+#if defined(__OpenBSD__) || defined(__NetBSD__)
 	apm_fd = -1;
 #endif
 }
@@ -117,8 +126,9 @@
 	if (path_current_now) g_free(path_current_now);
 	if (path_status) g_free(path_status);
 	if (battery_low_cmd) g_free(battery_low_cmd);
+	if (battery_timeout) stop_timeout(battery_timeout);
 
-#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
+#if defined(__OpenBSD__) || defined(__NetBSD__)
 	if ((apm_fd != -1) && (close(apm_fd) == -1))
 		warn("cannot close /dev/apm");
 #endif
@@ -129,7 +139,7 @@
 {
 	if (!battery_enabled) return;
 
-#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
+#if defined(__OpenBSD__) || defined(__NetBSD__)
 	apm_fd = open("/dev/apm", O_RDONLY);
 	if (apm_fd < 0) {
 		warn("init_battery: failed to open /dev/apm.");
@@ -137,7 +147,7 @@
 		return;
 	}
 
-#else
+#elif !defined(__FreeBSD__)
 	// check battery
 	GDir *directory = 0;
 	GError *error = NULL;
@@ -184,8 +194,14 @@
 		}
 		g_free(path2);
 	}
-	if (path_energy_now && path_energy_full) {
+
+	path_current_now = g_build_filename(battery_dir, "power_now", NULL);
+	if (!g_file_test (path_current_now, G_FILE_TEST_EXISTS)) {
+		g_free(path_current_now);
 		path_current_now = g_build_filename(battery_dir, "current_now", NULL);
+	}
+
+	if (path_energy_now && path_energy_full) {
 		path_status = g_build_filename(battery_dir, "status", NULL);
 
 		// check file
@@ -218,7 +234,6 @@
 {
 	Panel *panel = (Panel*)p;
 	Battery *battery = &panel->battery;
-	int bat_percentage_height, bat_percentage_height_ink, bat_time_height, bat_time_height_ink;
 
 	if (!battery_enabled)
 		return;
@@ -226,49 +241,29 @@
 	battery->area.parent = p;
 	battery->area.panel = p;
 	battery->area._draw_foreground = draw_battery;
+	battery->area.size_mode = SIZE_BY_CONTENT;
 	battery->area._resize = resize_battery;
-	battery->area.resize = 1;
-	battery->area.redraw = 1;
 	battery->area.on_screen = 1;
-
-	update_battery(&battery_state);
-	snprintf(buf_bat_percentage, sizeof(buf_bat_percentage), "%d%%", battery_state.percentage);
-	snprintf(buf_bat_time, sizeof(buf_bat_time), "%02d:%02d", battery_state.time.hours, battery_state.time.minutes);
-
-	get_text_size(bat1_font_desc, &bat_percentage_height_ink, &bat_percentage_height, panel->area.height, buf_bat_percentage, strlen(buf_bat_percentage));
-	get_text_size(bat2_font_desc, &bat_time_height_ink, &bat_time_height, panel->area.height, buf_bat_time, strlen(buf_bat_time));
-
-	if (panel_horizontal) {
-		// panel horizonal => fixed height and posy
-		battery->area.posy = panel->area.bg->border.width + panel->area.paddingy;
-		battery->area.height = panel->area.height - (2 * battery->area.posy);
-	}
-	else {
-		// panel vertical => fixed width, height, posy and posx
-		battery->area.posy = panel->clock.area.posy + panel->clock.area.height + panel->area.paddingx;
-		battery->area.height = (2 * battery->area.paddingxlr) + (bat_time_height + bat_percentage_height);
-		battery->area.posx = panel->area.bg->border.width + panel->area.paddingy;
-		battery->area.width = panel->area.width - (2 * panel->area.bg->border.width) - (2 * panel->area.paddingy);
-	}
-
-	battery->bat1_posy = (battery->area.height - bat_percentage_height) / 2;
-	battery->bat1_posy -= ((bat_time_height_ink + 2) / 2);
-	battery->bat2_posy = battery->bat1_posy + bat_percentage_height + 2 - (bat_percentage_height - bat_percentage_height_ink)/2 - (bat_time_height - bat_time_height_ink)/2;
+	battery->area.resize = 1;
 }
 
 
 void update_battery() {
-#if !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__NetBSD__)
+#if !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__FreeBSD__)
 	// unused on OpenBSD, silence compiler warnings
 	FILE *fp;
 	char tmp[25];
 	int64_t current_now = 0;
 #endif
+#if defined(__FreeBSD__)
+	int sysctl_out =  0;
+	size_t len = 0;
+#endif
 	int64_t energy_now = 0, energy_full = 0;
 	int seconds = 0;
 	int8_t new_percentage = 0;
 
-#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
+#if defined(__OpenBSD__) || defined(__NetBSD__)
 	struct apm_power_info info;
 	if (ioctl(apm_fd, APM_IOC_GETPOWER, &(info)) < 0)
 		warn("power update: APM_IOC_GETPOWER");
@@ -298,6 +293,45 @@
 
 	new_percentage = info.battery_life;
 
+#elif defined(__FreeBSD__)
+	len = sizeof(sysctl_out);
+
+	if (sysctlbyname("hw.acpi.battery.state", &sysctl_out, &len, NULL, 0) != 0)
+		fprintf(stderr, "power update: no such sysctl");
+
+	// attemp to map the battery state to linux
+	battery_state.state = BATTERY_UNKNOWN;
+
+	switch(sysctl_out) {
+		case 1:
+			battery_state.state = BATTERY_DISCHARGING;
+			break;
+		case 2:
+			battery_state.state = BATTERY_CHARGING;
+			break;
+		default:
+			battery_state.state = BATTERY_FULL;
+			break;
+	}
+
+	// no mapping for freebsd
+	energy_full = 0;
+	energy_now = 0;
+
+	if (sysctlbyname("hw.acpi.battery.time", &sysctl_out, &len, NULL, 0) != 0)
+		seconds = -1;
+	else
+		seconds = sysctl_out * 60;
+
+	// charging or error
+	if (seconds < 0)
+		seconds = 0;
+
+	if (sysctlbyname("hw.acpi.battery.life", &sysctl_out, &len, NULL, 0) != 0)
+		new_percentage = -1;
+	else
+		new_percentage = sysctl_out;
+
 #else
 	fp = fopen(path_status, "r");
 	if(fp != NULL) {
@@ -401,69 +435,45 @@
 }
 
 
-void resize_battery(void *obj)
+int resize_battery(void *obj)
 {
 	Battery *battery = obj;
-	PangoLayout *layout;
-	int percentage_width, time_width, new_width;
+	Panel *panel = battery->area.panel;
+	int bat_percentage_height, bat_percentage_width, bat_percentage_height_ink;
+	int bat_time_height, bat_time_width, bat_time_height_ink;
+	int ret = 0;
 
-	percentage_width = time_width = 0;
 	battery->area.redraw = 1;
-
+	
 	snprintf(buf_bat_percentage, sizeof(buf_bat_percentage), "%d%%", battery_state.percentage);
 	if(battery_state.state == BATTERY_FULL) {
 		strcpy(buf_bat_time, "Full");
 	} else {
 		snprintf(buf_bat_time, sizeof(buf_bat_time), "%02d:%02d", battery_state.time.hours, battery_state.time.minutes);
 	}
-	// vertical panel doen't adjust width
-	if (!panel_horizontal) return;
-
-	cairo_surface_t *cs;
-	cairo_t *c;
-	Pixmap pmap;
-	pmap = XCreatePixmap(server.dsp, server.root_win, battery->area.width, battery->area.height, server.depth);
-
-	cs = cairo_xlib_surface_create(server.dsp, pmap, server.visual, battery->area.width, battery->area.height);
-	c = cairo_create(cs);
-	layout = pango_cairo_create_layout(c);
+	get_text_size2(bat1_font_desc, &bat_percentage_height_ink, &bat_percentage_height, &bat_percentage_width, panel->area.height, panel->area.width, buf_bat_percentage, strlen(buf_bat_percentage));
+	get_text_size2(bat2_font_desc, &bat_time_height_ink, &bat_time_height, &bat_time_width, panel->area.height, panel->area.width, buf_bat_time, strlen(buf_bat_time));
 
-	// check width
-	pango_layout_set_font_description(layout, bat1_font_desc);
-	pango_layout_set_indent(layout, 0);
-	pango_layout_set_text(layout, buf_bat_percentage, strlen(buf_bat_percentage));
-	pango_layout_get_pixel_size(layout, &percentage_width, NULL);
-
-	pango_layout_set_font_description(layout, bat2_font_desc);
-	pango_layout_set_indent(layout, 0);
-	pango_layout_set_text(layout, buf_bat_time, strlen(buf_bat_time));
-	pango_layout_get_pixel_size(layout, &time_width, NULL);
-
-	if(percentage_width > time_width) new_width = percentage_width;
-	else new_width = time_width;
-
-	new_width += (2*battery->area.paddingxlr) + (2*battery->area.bg->border.width);
-
-	int old_width = battery->area.width;
-
-	Panel *panel = ((Area*)obj)->panel;
-	battery->area.width = new_width + 1;
-	battery->area.posx = panel->area.width - battery->area.width - panel->area.paddingxlr - panel->area.bg->border.width;
-	if (panel->clock.area.on_screen)
-		battery->area.posx -= (panel->clock.area.width + panel->area.paddingx);
-
-	if(new_width > old_width || new_width < (old_width-6)) {
-		// refresh and resize other objects on panel
-		// we try to limit the number of refresh
-		// printf("battery_width %d, new_width %d\n", battery->area.width, new_width);
-		panel->area.resize = 1;
-		systray.area.resize = 1;
-		panel_refresh = 1;
-	}
-
-	g_object_unref (layout);
-	cairo_destroy (c);
-	cairo_surface_destroy (cs);
-	XFreePixmap (server.dsp, pmap);
+	if (panel_horizontal) {
+		int new_size = (bat_percentage_width > bat_time_width) ? bat_percentage_width : bat_time_width;
+		new_size += (2*battery->area.paddingxlr) + (2*battery->area.bg->border.width);
+		if (new_size > battery->area.width || new_size < (battery->area.width-2)) {
+			// we try to limit the number of resize
+			battery->area.width =  new_size;
+			battery->bat1_posy = ((battery->area.height - bat_percentage_height) / 2) - ((bat_time_height_ink + 2) / 2);
+			battery->bat2_posy = battery->bat1_posy + bat_percentage_height + 2 - (bat_percentage_height - bat_percentage_height_ink)/2 - (bat_time_height - bat_time_height_ink)/2;
+			ret = 1;
+		}
+	}
+	else {
+		int new_size = bat_percentage_height + bat_time_height + (2 * (battery->area.paddingxlr + battery->area.bg->border.width));
+		if (new_size > battery->area.height || new_size < (battery->area.height-2)) {
+			battery->area.height =  new_size;
+			battery->bat1_posy = ((battery->area.height - bat_percentage_height) / 2) - ((bat_time_height_ink + 2) / 2);
+			battery->bat2_posy = battery->bat1_posy + bat_percentage_height + 2 - (bat_percentage_height - bat_percentage_height_ink)/2 - (bat_time_height - bat_time_height_ink)/2;
+			ret = 1;
+		}
+	}
+	return ret;
 }
 
diff -Nur tint2-0.11/src/battery/battery.h tint2-read-only/src/battery/battery.h
--- tint2-0.11/src/battery/battery.h	2010-04-18 21:28:45.000000000 +0700
+++ tint2-read-only/src/battery/battery.h	2010-12-23 00:02:32.279485615 +0600
@@ -71,6 +71,6 @@
 
 void draw_battery(void *obj, cairo_t *c);
 
-void resize_battery(void *obj);
+int  resize_battery(void *obj);
 
 #endif
diff -Nur tint2-0.11/src/clock/clock.c tint2-read-only/src/clock/clock.c
--- tint2-0.11/src/clock/clock.c	2010-06-12 01:47:26.000000000 +0700
+++ tint2-read-only/src/clock/clock.c	2010-12-23 00:02:32.288892915 +0600
@@ -2,7 +2,7 @@
 *
 * Tint2 : clock
 *
-* Copyright (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr)
+* Copyright (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2
@@ -26,9 +26,7 @@
 
 #include "window.h"
 #include "server.h"
-#include "area.h"
 #include "panel.h"
-#include "taskbar.h"
 #include "clock.h"
 #include "timer.h"
 #include "common.h"
@@ -45,9 +43,9 @@
 struct timeval time_clock;
 PangoFontDescription *time1_font_desc;
 PangoFontDescription *time2_font_desc;
-static char buf_time[40];
-static char buf_date[40];
-static char buf_tooltip[40];
+static char buf_time[256];
+static char buf_date[256];
+static char buf_tooltip[512];
 int clock_enabled;
 static timeout* clock_timeout;
 
@@ -80,6 +78,7 @@
 	if (time_tooltip_timezone) g_free(time_tooltip_timezone);
 	if (clock_lclick_command) g_free(clock_lclick_command);
 	if (clock_rclick_command) g_free(clock_rclick_command);
+	if (clock_timeout) stop_timeout(clock_timeout);
 }
 
 
@@ -144,45 +143,19 @@
 {
 	Panel *panel =(Panel*)p;
 	Clock *clock = &panel->clock;
-	int time_height, time_height_ink, date_height, date_height_ink;
 
 	clock->area.parent = p;
 	clock->area.panel = p;
 	clock->area._draw_foreground = draw_clock;
+	clock->area.size_mode = SIZE_BY_CONTENT;
 	clock->area._resize = resize_clock;
+	// check consistency
+	if (time1_format == 0)
+		return;
+
 	clock->area.resize = 1;
-	clock->area.redraw = 1;
 	clock->area.on_screen = 1;
 
-	strftime(buf_time, sizeof(buf_time), time1_format, clock_gettime_for_tz(time1_timezone));
-	get_text_size(time1_font_desc, &time_height_ink, &time_height, panel->area.height, buf_time, strlen(buf_time));
-	if (time2_format) {
-		strftime(buf_date, sizeof(buf_date), time2_format, clock_gettime_for_tz(time2_timezone));
-		get_text_size(time2_font_desc, &date_height_ink, &date_height, panel->area.height, buf_date, strlen(buf_date));
-	}
-
-	if (panel_horizontal) {
-		// panel horizonal => fixed height and posy
-		clock->area.posy = panel->area.bg->border.width + panel->area.paddingy;
-		clock->area.height = panel->area.height - (2 * clock->area.posy);
-	}
-	else {
-		// panel vertical => fixed width, height, posy and posx
-		clock->area.posy = panel->area.bg->border.width + panel->area.paddingxlr;
-		clock->area.height = (2 * clock->area.paddingxlr) + (time_height + date_height);
-		clock->area.posx = panel->area.bg->border.width + panel->area.paddingy;
-		clock->area.width = panel->area.width - (2 * panel->area.bg->border.width) - (2 * panel->area.paddingy);
-	}
-
-	clock->time1_posy = (clock->area.height - time_height) / 2;
-	if (time2_format) {
-		strftime(buf_date, sizeof(buf_date), time2_format, clock_gettime_for_tz(time2_timezone));
-		get_text_size(time2_font_desc, &date_height_ink, &date_height, panel->area.height, buf_date, strlen(buf_date));
-
-		clock->time1_posy -= ((date_height_ink + 2) / 2);
-		clock->time2_posy = clock->time1_posy + time_height + 2 - (time_height - time_height_ink)/2 - (date_height - date_height_ink)/2;
-	}
-
 	if (time_tooltip_format) {
 		clock->area._get_tooltip_text = clock_get_tooltip;
 		strftime(buf_tooltip, sizeof(buf_tooltip), time_tooltip_format, clock_gettime_for_tz(time_tooltip_timezone));
@@ -224,69 +197,51 @@
 }
 
 
-void resize_clock (void *obj)
+int resize_clock (void *obj)
 {
 	Clock *clock = obj;
-	PangoLayout *layout;
-	int time_width, date_width, new_width;
+	Panel *panel = clock->area.panel;
+	int time_height_ink, time_height, time_width, date_height_ink, date_height, date_width, ret = 0;
 
 	clock->area.redraw = 1;
-	time_width = date_width = 0;
+	
+	date_height = date_width = 0;
 	strftime(buf_time, sizeof(buf_time), time1_format, clock_gettime_for_tz(time1_timezone));
-	if (time2_format)
-		strftime(buf_date, sizeof(buf_date), time2_format, clock_gettime_for_tz(time2_timezone));
-
-	// vertical panel doen't adjust width
-	if (!panel_horizontal) return;
-
-	//printf("  resize_clock\n");
-	cairo_surface_t *cs;
-	cairo_t *c;
-	Pixmap pmap;
-	pmap = XCreatePixmap (server.dsp, server.root_win, clock->area.width, clock->area.height, server.depth);
-
-	cs = cairo_xlib_surface_create (server.dsp, pmap, server.visual, clock->area.width, clock->area.height);
-	c = cairo_create (cs);
-	layout = pango_cairo_create_layout (c);
-
-	// check width
-	pango_layout_set_font_description (layout, time1_font_desc);
-	pango_layout_set_indent(layout, 0);
-	pango_layout_set_text (layout, buf_time, strlen(buf_time));
-	pango_layout_get_pixel_size (layout, &time_width, NULL);
+	get_text_size2(time1_font_desc, &time_height_ink, &time_height, &time_width, panel->area.height, panel->area.width, buf_time, strlen(buf_time));
 	if (time2_format) {
-		pango_layout_set_font_description (layout, time2_font_desc);
-		pango_layout_set_indent(layout, 0);
-		pango_layout_set_text (layout, buf_date, strlen(buf_date));
-		pango_layout_get_pixel_size (layout, &date_width, NULL);
+		strftime(buf_date, sizeof(buf_date), time2_format, clock_gettime_for_tz(time2_timezone));
+		get_text_size2(time2_font_desc, &date_height_ink, &date_height, &date_width, panel->area.height, panel->area.width, buf_date, strlen(buf_date));
 	}
 
-	if (time_width > date_width) new_width = time_width;
-	else new_width = date_width;
-	new_width += (2*clock->area.paddingxlr) + (2*clock->area.bg->border.width);
-
-	Panel *panel = ((Area*)obj)->panel;
-	if (new_width > clock->area.width || new_width < (clock->area.width-6)) {
-		// resize clock
-		// we try to limit the number of resize
-		// printf("clock_width %d, new_width %d\n", clock->area.width, new_width);
-		clock->area.width = new_width + 1;
-
-		// resize other objects on panel
-		panel->area.resize = 1;
-#ifdef ENABLE_BATTERY
-		panel->battery.area.resize = 1;
-#endif
-		systray.area.resize = 1;
-		panel_refresh = 1;
+	if (panel_horizontal) {
+		int new_size = (time_width > date_width) ? time_width : date_width;
+		new_size += (2*clock->area.paddingxlr) + (2*clock->area.bg->border.width);
+		if (new_size > clock->area.width || new_size < (clock->area.width-6)) {
+			// we try to limit the number of resize
+			clock->area.width = new_size + 1;
+			clock->time1_posy = (clock->area.height - time_height) / 2;
+			if (time2_format) {
+				clock->time1_posy -= ((date_height_ink + 2) / 2);
+				clock->time2_posy = clock->time1_posy + time_height + 2 - (time_height - time_height_ink)/2 - (date_height - date_height_ink)/2;
+			}
+			ret = 1;
+		}
+	}
+	else {
+		int new_size = time_height + date_height + (2 * (clock->area.paddingxlr + clock->area.bg->border.width));
+		if (new_size != clock->area.height) {
+			// we try to limit the number of resize
+			clock->area.height =  new_size;
+			clock->time1_posy = (clock->area.height - time_height) / 2;
+			if (time2_format) {
+				clock->time1_posy -= ((date_height_ink + 2) / 2);
+				clock->time2_posy = clock->time1_posy + time_height + 2 - (time_height - time_height_ink)/2 - (date_height - date_height_ink)/2;
+			}
+			ret = 1;
+		}
 	}
-	clock->area.posx = panel->area.width - clock->area.width - panel->area.paddingxlr - panel->area.bg->border.width;
-
 
-	g_object_unref (layout);
-	cairo_destroy (c);
-	cairo_surface_destroy (cs);
-	XFreePixmap (server.dsp, pmap);
+	return ret;
 }
 
 
@@ -301,6 +256,6 @@
 		command = clock_rclick_command;
 		break;
 	}
-  tint_exec(command);
+	tint_exec(command);
 }
 
diff -Nur tint2-0.11/src/clock/clock.h tint2-read-only/src/clock/clock.h
--- tint2-0.11/src/clock/clock.h	2010-04-18 21:28:45.000000000 +0700
+++ tint2-read-only/src/clock/clock.h	2010-12-23 00:02:32.288892915 +0600
@@ -49,7 +49,7 @@
 
 void draw_clock (void *obj, cairo_t *c);
 
-void resize_clock (void *obj);
+int  resize_clock (void *obj);
 
 void clock_action(int button);
 
diff -Nur tint2-0.11/src/config.c tint2-read-only/src/config.c
--- tint2-0.11/src/config.c	2010-06-12 19:25:21.000000000 +0700
+++ tint2-read-only/src/config.c	2010-12-23 00:02:32.319656009 +0600
@@ -3,7 +3,7 @@
 * Tint2 : read/write config file
 *
 * Copyright (C) 2007 Pål Staurland (staura@gmail.com)
-* Modified (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr)
+* Modified (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2
@@ -40,7 +40,9 @@
 #include "panel.h"
 #include "task.h"
 #include "taskbar.h"
+#include "taskbarname.h"
 #include "systraybar.h"
+#include "launcher.h"
 #include "clock.h"
 #include "config.h"
 #include "window.h"
@@ -58,14 +60,14 @@
 // --------------------------------------------------
 // backward compatibility
 // detect if it's an old config file (==1)
-static int old_config_file;
+static int new_config_file;
 
 
 void default_config()
 {
 	config_path = 0;
 	snapshot_path = 0;
-	old_config_file = 1;
+	new_config_file = 0;
 }
 
 void cleanup_config()
@@ -234,6 +236,31 @@
 			panel_config.area.height = atoi(value2);
 		}
 	}
+	else if (strcmp (key, "panel_items") == 0) {
+		new_config_file = 1;
+		panel_items_order = strdup(value);
+		int j;
+		for (j=0 ; j < strlen(panel_items_order) ; j++) {
+			if (panel_items_order[j] == 'L')
+				launcher_enabled = 1;
+			if (panel_items_order[j] == 'T')
+				taskbar_enabled = 1;
+			if (panel_items_order[j] == 'B') {
+#ifdef ENABLE_BATTERY
+				battery_enabled = 1;
+#else
+				fprintf(stderr, "tint2 is build without battery support\n");
+#endif
+			}
+			if (panel_items_order[j] == 'S') {
+				// systray disabled in snapshot mode
+				if (snapshot_path == 0)
+					systray_enabled = 1;
+			}
+			if (panel_items_order[j] == 'C')			
+				clock_enabled = 1;
+		}
+	}
 	else if (strcmp (key, "panel_margin") == 0) {
 		extract_values(value, &value1, &value2, &value3);
 		panel_config.marginx = atoi (value1);
@@ -279,7 +306,7 @@
 	else if (strcmp (key, "panel_dock") == 0)
 		panel_dock = atoi (value);
 	else if (strcmp (key, "urgent_nb_of_blink") == 0)
-		max_tick_urgent = (atoi (value) * 2) + 1;
+		max_tick_urgent = atoi (value);
 	else if (strcmp (key, "panel_layer") == 0) {
 		if (strcmp(value, "bottom") == 0)
 			panel_layer = BOTTOM_LAYER;
@@ -290,15 +317,6 @@
 	}
 
 	/* Battery */
-	else if (strcmp (key, "battery") == 0) {
-#ifdef ENABLE_BATTERY
-		if(atoi(value) == 1)
-			battery_enabled = 1;
-#else
-		if(atoi(value) == 1)
-			fprintf(stderr, "tint2 is build without battery support\n");
-#endif
-	}
 	else if (strcmp (key, "battery_low_status") == 0) {
 #ifdef ENABLE_BATTERY
 		battery_low_status = atoi(value);
@@ -355,6 +373,16 @@
 
 	/* Clock */
 	else if (strcmp (key, "time1_format") == 0) {
+		if (new_config_file == 0) {
+			clock_enabled = 1;
+			if (panel_items_order) {
+				char* tmp = g_strconcat(panel_items_order, "C", NULL);
+				g_free( panel_items_order );
+				panel_items_order = tmp;
+			}
+			else 
+				panel_items_order = g_strdup("C");
+		}
 		if (strlen(value) > 0) {
 			time1_format = strdup (value);
 			clock_enabled = 1;
@@ -426,14 +454,48 @@
 	else if (strcmp (key, "taskbar_background_id") == 0) {
 		int id = atoi (value);
 		id = (id < backgrounds->len && id >= 0) ? id : 0;
-		panel_config.g_taskbar.bg = &g_array_index(backgrounds, Background, id);
-		panel_config.g_taskbar.area.bg = panel_config.g_taskbar.bg;
+		panel_config.g_taskbar.background[TASKBAR_NORMAL] = &g_array_index(backgrounds, Background, id);
+		if (panel_config.g_taskbar.background[TASKBAR_ACTIVE] == 0)
+			panel_config.g_taskbar.background[TASKBAR_ACTIVE] = panel_config.g_taskbar.background[TASKBAR_NORMAL];
 	}
 	else if (strcmp (key, "taskbar_active_background_id") == 0) {
 		int id = atoi (value);
 		id = (id < backgrounds->len && id >= 0) ? id : 0;
-		panel_config.g_taskbar.bg_active = &g_array_index(backgrounds, Background, id);
-		panel_config.g_taskbar.use_active = 1;
+		panel_config.g_taskbar.background[TASKBAR_ACTIVE] = &g_array_index(backgrounds, Background, id);
+	}
+	else if (strcmp (key, "taskbar_name") == 0) {
+		taskbarname_enabled = atoi (value);
+	}
+	else if (strcmp (key, "taskbar_name_padding") == 0) {
+		extract_values(value, &value1, &value2, &value3);
+		panel_config.g_taskbar.area_name.paddingxlr = panel_config.g_taskbar.area_name.paddingx = atoi (value1);
+	}
+	else if (strcmp (key, "taskbar_name_background_id") == 0) {
+		int id = atoi (value);
+		id = (id < backgrounds->len && id >= 0) ? id : 0;
+		panel_config.g_taskbar.background_name[TASKBAR_NORMAL] = &g_array_index(backgrounds, Background, id);
+		if (panel_config.g_taskbar.background_name[TASKBAR_ACTIVE] == 0)
+			panel_config.g_taskbar.background_name[TASKBAR_ACTIVE] = panel_config.g_taskbar.background_name[TASKBAR_NORMAL];
+	}
+	else if (strcmp (key, "taskbar_name_active_background_id") == 0) {
+		int id = atoi (value);
+		id = (id < backgrounds->len && id >= 0) ? id : 0;
+		panel_config.g_taskbar.background_name[TASKBAR_ACTIVE] = &g_array_index(backgrounds, Background, id);
+	}
+	else if (strcmp (key, "taskbar_name_font") == 0) {
+		taskbarname_font_desc = pango_font_description_from_string (value);
+	}
+	else if (strcmp (key, "taskbar_name_font_color") == 0) {
+		extract_values(value, &value1, &value2, &value3);
+		get_color (value1, taskbarname_font.color);
+		if (value2) taskbarname_font.alpha = (atoi (value2) / 100.0);
+		else taskbarname_font.alpha = 0.5;
+	}
+	else if (strcmp (key, "taskbar_name_active_font_color") == 0) {
+		extract_values(value, &value1, &value2, &value3);
+		get_color (value1, taskbarname_active_font.color);
+		if (value2) taskbarname_active_font.alpha = (atoi (value2) / 100.0);
+		else taskbarname_active_font.alpha = 0.5;
 	}
 
 	/* Task */
@@ -495,17 +557,22 @@
 		panel_config.g_task.config_background_mask |= (1<<status);
 		if (status == TASK_NORMAL) panel_config.g_task.area.bg = panel_config.g_task.background[TASK_NORMAL];
 	}
+	// "tooltip" is deprecated but here for backwards compatibility
+	else if (strcmp (key, "task_tooltip") == 0 || strcmp(key, "tooltip") == 0)
+		panel_config.g_task.tooltip_enabled = atoi(value);
 
 	/* Systray */
-	// systray disabled in snapshot mode
-	else if (strcmp (key, "systray") == 0 && snapshot_path == 0) {
-		systray_enabled = atoi(value);
-		// systray is latest option added. files without 'systray' are old.
-		old_config_file = 0;
-	}
-	else if (strcmp (key, "systray_padding") == 0 && snapshot_path == 0) {
-		if (old_config_file)
+	else if (strcmp (key, "systray_padding") == 0) {
+		if (new_config_file == 0 && systray_enabled == 0) {
 			systray_enabled = 1;
+			if (panel_items_order) {
+				char* tmp = g_strconcat(panel_items_order, "S", NULL);
+				g_free( panel_items_order );
+				panel_items_order = tmp;
+			}
+			else
+				panel_items_order = g_strdup("S");
+		}
 		extract_values(value, &value1, &value2, &value3);
 		systray.area.paddingxlr = systray.area.paddingx = atoi (value1);
 		if (value2) systray.area.paddingy = atoi (value2);
@@ -536,9 +603,32 @@
 		systray.brightness = atoi(value3);
 	}
 
+	/* Launcher */
+	else if (strcmp (key, "launcher_padding") == 0) {
+		extract_values(value, &value1, &value2, &value3);
+		panel_config.launcher.area.paddingxlr = panel_config.launcher.area.paddingx = atoi (value1);
+		if (value2) panel_config.launcher.area.paddingy = atoi (value2);
+		if (value3) panel_config.launcher.area.paddingx = atoi (value3);
+	}
+	else if (strcmp (key, "launcher_background_id") == 0) {
+		int id = atoi (value);
+		id = (id < backgrounds->len && id >= 0) ? id : 0;
+		panel_config.launcher.area.bg = &g_array_index(backgrounds, Background, id);
+	}
+	else if (strcmp(key, "launcher_icon_size") == 0) {
+		launcher_max_icon_size = atoi(value);
+	}
+	else if (strcmp(key, "launcher_item_app") == 0) {
+		char *app = strdup(value);
+		panel_config.launcher.list_apps = g_slist_append(panel_config.launcher.list_apps, app);
+	}
+	else if (strcmp(key, "launcher_icon_theme") == 0) {
+		// if XSETTINGS manager running, tint2 use it.
+		if (!icon_theme_name)
+			icon_theme_name = strdup(value);
+	}
+
 	/* Tooltip */
-	else if (strcmp (key, "tooltip") == 0)
-		g_tooltip.enabled = atoi(value);
 	else if (strcmp (key, "tooltip_show_timeout") == 0) {
 		int timeout_msec = 1000*atof(value);
 		g_tooltip.show_timeout_msec = timeout_msec;
@@ -600,6 +690,35 @@
 		}
 	}
 
+	// old config option
+	else if (strcmp(key, "systray") == 0) {
+		if (new_config_file == 0) {
+			systray_enabled = atoi(value);
+			if (systray_enabled) {
+				if (panel_items_order) {
+					char* tmp = g_strconcat(panel_items_order, "S", NULL);
+					g_free( panel_items_order );
+					panel_items_order = tmp;
+				}
+				else
+					panel_items_order = g_strdup("S");
+			}
+		}
+	}
+	else if (strcmp(key, "battery") == 0) {
+		if (new_config_file == 0) {
+			battery_enabled = atoi(value);
+			if (battery_enabled) {
+				if (panel_items_order) {
+					char* tmp = g_strconcat(panel_items_order, "B", NULL);
+					g_free( panel_items_order );
+					panel_items_order = tmp;
+				}
+				else
+					panel_items_order = g_strdup("B");
+			}
+		}
+	}
 	else
 		fprintf(stderr, "tint2 : invalid option \"%s\",\n  upgrade tint2 or correct your config file\n", key);
 
@@ -672,6 +791,18 @@
 		}
 	}
 	fclose (fp);
+	
+	// append Taskbar item
+	if (new_config_file == 0) {
+		taskbar_enabled = 1;
+		if (panel_items_order) {
+			char* tmp = g_strconcat( "T", panel_items_order, NULL );
+			g_free(panel_items_order);
+			panel_items_order = tmp;
+		}
+		else 
+			panel_items_order = g_strdup("T");
+	}
 
 	return 1;
 }
diff -Nur tint2-0.11/src/launcher/launcher.c tint2-read-only/src/launcher/launcher.c
--- tint2-0.11/src/launcher/launcher.c	1970-01-01 07:00:00.000000000 +0700
+++ tint2-read-only/src/launcher/launcher.c	2010-12-23 00:02:32.099584902 +0600
@@ -0,0 +1,961 @@
+/**************************************************************************
+* Tint2 : launcher
+*
+* Copyright (C) 2010       (mrovi@interfete-web-club.com)
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version 2
+* as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+**************************************************************************/
+
+#include <string.h>
+#include <stdio.h>
+#include <cairo.h>
+#include <cairo-xlib.h>
+#include <pango/pangocairo.h>
+#include <unistd.h>
+#include <signal.h>
+#include <stdlib.h>
+
+#include "window.h"
+#include "server.h"
+#include "area.h"
+#include "panel.h"
+#include "taskbar.h"
+#include "launcher.h"
+
+int launcher_enabled;
+int launcher_max_icon_size;
+char *icon_theme_name; 
+XSettingsClient *xsettings_client;
+
+#define ICON_FALLBACK "exec"
+
+char *icon_path(Launcher *launcher, const char *icon_name, int size);
+void launcher_load_themes(Launcher *launcher);
+void free_desktop_entry(DesktopEntry *entry);
+int launcher_read_desktop_file(const char *path, DesktopEntry *entry);
+Imlib_Image scale_icon(Imlib_Image original, int icon_size);
+void free_icon(Imlib_Image icon);
+void free_icon_theme(IconTheme *theme);
+
+
+void default_launcher()
+{
+	launcher_enabled = 0;
+	launcher_max_icon_size = 0;
+	icon_theme_name = 0;
+	xsettings_client = NULL;
+}
+
+
+void init_launcher()
+{
+	if (launcher_enabled) {
+		// if XSETTINGS manager running, tint2 read the icon_theme_name.
+		xsettings_client = xsettings_client_new(server.dsp, server.screen, xsettings_notify_cb, NULL, NULL);
+	}
+}
+
+
+void init_launcher_panel(void *p)
+{
+	Panel *panel =(Panel*)p;
+	Launcher *launcher = &panel->launcher;
+
+	launcher->area.parent = p;
+	launcher->area.panel = p;
+	launcher->area._draw_foreground = draw_launcher;
+	launcher->area.size_mode = SIZE_BY_CONTENT;
+	launcher->area._resize = resize_launcher;
+	launcher->area.resize = 1;
+	launcher->area.redraw = 1;
+
+	// check consistency
+	if (launcher->list_apps == NULL)
+		return;
+
+	launcher->area.on_screen = 1;
+	panel_refresh = 1;
+
+	launcher_load_themes(launcher);
+	launcher_load_icons(launcher);
+}
+
+
+void cleanup_launcher()
+{
+	int i;
+
+	if (xsettings_client)
+		xsettings_client_destroy(xsettings_client);
+	for (i = 0 ; i < nb_panel ; i++) {
+		Panel *panel = &panel1[i];
+		Launcher *launcher = &panel->launcher;		
+		cleanup_launcher_theme(launcher);
+		
+		GSList *l;
+		for (l = launcher->list_apps; l ; l = l->next) {
+			free(l->data);
+		}
+		g_slist_free(launcher->list_apps);
+		launcher->list_apps = NULL;
+	}
+	g_free(icon_theme_name);
+	launcher_enabled = 0;
+}
+
+
+void cleanup_launcher_theme(Launcher *launcher)
+{
+	free_area(&launcher->area);
+	GSList *l;
+	for (l = launcher->list_icons; l ; l = l->next) {
+		LauncherIcon *launcherIcon = (LauncherIcon*)l->data;
+		if (launcherIcon) {
+			free_icon(launcherIcon->icon_scaled);
+			free_icon(launcherIcon->icon_original);
+			free(launcherIcon->icon_name);
+			free(launcherIcon->icon_path);
+			free(launcherIcon->cmd);
+		}
+		free(launcherIcon);
+	}
+	g_slist_free(launcher->list_icons);
+
+	for (l = launcher->list_themes; l ; l = l->next) {
+		IconTheme *theme = (IconTheme*) l->data;
+		free_icon_theme(theme);
+		free(theme);
+	}
+	g_slist_free(launcher->list_themes);
+	launcher->list_icons = launcher->list_themes = NULL;
+}
+
+
+int resize_launcher(void *obj)
+{
+	Launcher *launcher = obj;
+	GSList *l;
+	int count, icon_size;
+	int icons_per_column=1, icons_per_row=1, marging=0;
+
+	if (panel_horizontal)
+		icon_size = launcher->area.height;
+	else
+		icon_size = launcher->area.width;
+	icon_size = icon_size - (2 * launcher->area.bg->border.width) - (2 * launcher->area.paddingy);
+	if (launcher_max_icon_size > 0 && icon_size > launcher_max_icon_size)
+		icon_size = launcher_max_icon_size;
+
+	// Resize icons if necessary
+	for (l = launcher->list_icons; l ; l = l->next) {
+		LauncherIcon *launcherIcon = (LauncherIcon *)l->data;
+		if (launcherIcon->icon_size != icon_size || !launcherIcon->icon_original) {
+			launcherIcon->icon_size = icon_size;
+
+			// Get the path for an icon file with the new size
+			char *new_icon_path = icon_path(launcher, launcherIcon->icon_name, launcherIcon->icon_size);
+			if (!new_icon_path) {
+				// Draw a blank icon
+				free_icon(launcherIcon->icon_original);
+				launcherIcon->icon_original = NULL;
+				free_icon(launcherIcon->icon_scaled);
+				launcherIcon->icon_scaled = NULL;
+				new_icon_path = icon_path(launcher, ICON_FALLBACK, launcherIcon->icon_size);
+				if (new_icon_path) {
+					launcherIcon->icon_original = imlib_load_image(new_icon_path);
+					fprintf(stderr, "launcher.c %d: Using icon %s\n", __LINE__, new_icon_path);
+					free(new_icon_path);
+				}
+				launcherIcon->icon_scaled = scale_icon(launcherIcon->icon_original, icon_size);
+				continue;
+			}
+			if (launcherIcon->icon_path && strcmp(new_icon_path, launcherIcon->icon_path) == 0) {
+				// If it's the same file just rescale
+				free_icon(launcherIcon->icon_scaled);
+				launcherIcon->icon_scaled = scale_icon(launcherIcon->icon_original, icon_size);
+				free(new_icon_path);
+				fprintf(stderr, "launcher.c %d: Using icon %s\n", __LINE__, launcherIcon->icon_path);
+			} else {
+				// Free the old files
+				free_icon(launcherIcon->icon_original);
+				free_icon(launcherIcon->icon_scaled);
+				// Load the new file and scale
+				launcherIcon->icon_original = imlib_load_image(new_icon_path);
+				launcherIcon->icon_scaled = scale_icon(launcherIcon->icon_original, launcherIcon->icon_size);
+				free(launcherIcon->icon_path);
+				launcherIcon->icon_path = new_icon_path;
+				fprintf(stderr, "launcher.c %d: Using icon %s\n", __LINE__, launcherIcon->icon_path);
+			}
+		}
+	}
+	
+	count = g_slist_length(launcher->list_icons);
+
+	if (panel_horizontal) {
+		if (!count) launcher->area.width = 0;
+		else {
+			int height = launcher->area.height - 2*launcher->area.bg->border.width - 2*launcher->area.paddingy;
+			// here icons_per_column always higher than 0
+			icons_per_column = (height+launcher->area.paddingx) / (icon_size+launcher->area.paddingx);
+			marging = height - (icons_per_column-1)*(icon_size+launcher->area.paddingx) - icon_size;
+			icons_per_row = count / icons_per_column + (count%icons_per_column != 0);
+			launcher->area.width = (2 * launcher->area.bg->border.width) + (2 * launcher->area.paddingxlr) + (icon_size * icons_per_row) + ((icons_per_row-1) * launcher->area.paddingx);
+		}
+	}
+	else {
+		if (!count) launcher->area.height = 0;
+		else {
+			int width = launcher->area.width - 2*launcher->area.bg->border.width - 2*launcher->area.paddingy;
+			// here icons_per_row always higher than 0
+			icons_per_row = (width+launcher->area.paddingx) / (icon_size+launcher->area.paddingx);
+			marging = width - (icons_per_row-1)*(icon_size+launcher->area.paddingx) - icon_size;
+			icons_per_column = count / icons_per_row+ (count%icons_per_row != 0);
+			launcher->area.height = (2 * launcher->area.bg->border.width) + (2 * launcher->area.paddingxlr) + (icon_size * icons_per_column) + ((icons_per_column-1) * launcher->area.paddingx);
+		}
+	}
+
+	int i, posx, posy;
+	int start = launcher->area.bg->border.width + launcher->area.paddingy + marging/2;
+	if (panel_horizontal) {
+		posy = start;
+		posx = launcher->area.bg->border.width + launcher->area.paddingxlr;
+	}
+	else {
+		posx = start;
+		posy = launcher->area.bg->border.width + launcher->area.paddingxlr;
+	}
+
+	for (i=1, l = launcher->list_icons; l ; i++, l = l->next) {
+		LauncherIcon *launcherIcon = (LauncherIcon*)l->data;
+		
+		launcherIcon->y = posy;
+		launcherIcon->x = posx;
+		//printf("launcher %d : %d,%d\n", i, posx, posy);
+		if (panel_horizontal) {
+			if (i % icons_per_column)
+				posy += icon_size + launcher->area.paddingx;
+			else {
+				posy = start;
+				posx += (icon_size + launcher->area.paddingx);
+			}
+		}
+		else {
+			if (i % icons_per_row)
+				posx += icon_size + launcher->area.paddingx;
+			else {
+				posx = start;
+				posy += (icon_size + launcher->area.paddingx);
+			}
+		}
+	}
+	return 1;
+}
+
+
+void draw_launcher(void *obj, cairo_t *c)
+{
+	Launcher *launcher = obj;
+	GSList *l;
+	if (launcher->list_icons == 0) return;
+
+	for (l = launcher->list_icons; l ; l = l->next) {
+		LauncherIcon *launcherIcon = (LauncherIcon*)l->data;
+		int pos_x = launcherIcon->x;
+		int pos_y = launcherIcon->y;
+		Imlib_Image icon_scaled = launcherIcon->icon_scaled;
+		// Render
+		imlib_context_set_image (icon_scaled);
+		if (server.real_transparency) {
+			render_image(launcher->area.pix, pos_x, pos_y, imlib_image_get_width(), imlib_image_get_height() );
+		}
+		else {
+			imlib_context_set_drawable(launcher->area.pix);
+			imlib_render_image_on_drawable (pos_x, pos_y);
+		}
+	}
+}
+
+Imlib_Image scale_icon(Imlib_Image original, int icon_size)
+{
+	Imlib_Image icon_scaled;
+	if (original) {
+		imlib_context_set_image (original);
+		icon_scaled = imlib_create_cropped_scaled_image(0, 0, imlib_image_get_width(), imlib_image_get_height(), icon_size, icon_size);
+	} else {
+		icon_scaled = imlib_create_image(icon_size, icon_size);
+		imlib_context_set_image (icon_scaled);
+		imlib_context_set_color(255, 255, 255, 255);
+		imlib_image_fill_rectangle(0, 0, icon_size, icon_size);
+	}
+	return icon_scaled;
+}
+
+void free_icon(Imlib_Image icon)
+{
+	if (icon) {
+		imlib_context_set_image(icon);
+		imlib_free_image();
+	}
+}
+
+void launcher_action(LauncherIcon *icon)
+{
+	char *cmd = malloc(strlen(icon->cmd) + 10);
+	sprintf(cmd, "(%s&)", icon->cmd);
+	tint_exec(cmd);
+	free(cmd);
+}
+
+/***************** Freedesktop app.desktop and icon theme handling  *********************/
+/* http://standards.freedesktop.org/desktop-entry-spec/ */
+/* http://standards.freedesktop.org/icon-theme-spec/ */
+
+// Splits line at first '=' and returns 1 if successful, and parts are not empty
+// key and value point to the parts
+int parse_dektop_line(char *line, char **key, char **value)
+{
+	char *p;
+	int found = 0;
+	*key = line;
+	for (p = line; *p; p++) {
+		if (*p == '=') {
+			*value = p + 1;
+			*p = 0;
+			found = 1;
+			break;
+		}
+	}
+	if (!found)
+		return 0;
+	if (found && (strlen(*key) == 0 || strlen(*value) == 0))
+		return 0;
+	return 1;
+}
+
+int parse_theme_line(char *line, char **key, char **value)
+{
+	return parse_dektop_line(line, key, value);
+}
+
+void expand_exec(DesktopEntry *entry, const char *path)
+{
+	// Expand % in exec
+	// %i -> --icon Icon
+	// %c -> Name
+	// %k -> path
+	if (entry->exec) {
+		char *exec2 = malloc(strlen(entry->exec) + (entry->name ? strlen(entry->name) : 1) + (entry->icon ? strlen(entry->icon) : 1) + 100);
+		char *p, *q;
+		// p will never point to an escaped char
+		for (p = entry->exec, q = exec2; *p; p++, q++) {
+			*q = *p; // Copy
+			if (*p == '\\') {
+				p++, q++;
+				// Copy the escaped char
+				if (*p == '%') // For % we delete the backslash, i.e. write % over it
+					q--;
+				*q = *p;
+				if (!*p) break;
+				continue;
+			}
+			if (*p == '%') {
+				p++;
+				if (!*p) break;
+				if (*p == 'i' && entry->icon != NULL) {
+					sprintf(q, "--icon '%s'", entry->icon);
+					q += strlen("--icon ''");
+					q += strlen(entry->icon);
+					q--; // To balance the q++ in the for
+				} else if (*p == 'c' && entry->name != NULL) {
+					sprintf(q, "'%s'", entry->name);
+					q += strlen("''");
+					q += strlen(entry->name);
+					q--; // To balance the q++ in the for
+				} else if (*p == 'c') {
+					sprintf(q, "'%s'", path);
+					q += strlen("''");
+					q += strlen(path);
+					q--; // To balance the q++ in the for
+				} else {
+					// We don't care about other expansions
+					q--; // Delete the last % from q
+				}
+				continue;
+			}
+		}
+		*q = '\0';
+		free(entry->exec);
+		entry->exec = exec2;
+	}
+}
+
+//TODO Use UTF8 when parsing the file
+int launcher_read_desktop_file(const char *path, DesktopEntry *entry)
+{
+	FILE *fp;
+	char line[4096];
+	char *key, *value;
+
+	entry->name = entry->icon = entry->exec = NULL;
+
+	if ((fp = fopen(path, "rt")) == NULL) {
+		fprintf(stderr, "Could not open file %s\n", path);
+		return 0;
+	}
+
+	while (fgets(line, sizeof(line), fp) != NULL) {
+		int len = strlen(line);
+		if (len == 0)
+			continue;
+		line[len - 1] = '\0';
+		if (parse_dektop_line(line, &key, &value)) {
+			if (strcmp(key, "Name") == 0) {
+				entry->name = strdup(value);
+			} else if (strcmp(key, "Exec") == 0) {
+				entry->exec = strdup(value);
+			} else if (strcmp(key, "Icon") == 0) {
+				entry->icon = strdup(value);
+			}
+		}
+	}
+	fclose (fp);
+	// From this point:
+	// entry->name, entry->icon, entry->exec will never be empty strings (can be NULL though)
+
+	expand_exec(entry, path);
+	
+	return 1;
+}
+
+void free_desktop_entry(DesktopEntry *entry)
+{
+	free(entry->name);
+	free(entry->icon);
+	free(entry->exec);
+}
+
+void test_launcher_read_desktop_file()
+{
+	fprintf(stdout, "\033[1;33m");
+	DesktopEntry entry;
+	launcher_read_desktop_file("/usr/share/applications/firefox.desktop", &entry);
+	printf("Name:%s Icon:%s Exec:%s\n", entry.name, entry.icon, entry.exec);
+	fprintf(stdout, "\033[0m");
+}
+
+//TODO Use UTF8 when parsing the file
+IconTheme *load_theme(char *name)
+{
+	// Look for name/index.theme in $HOME/.icons, /usr/share/icons, /usr/share/pixmaps (stop at the first found)
+	// Parse index.theme -> list of IconThemeDir with attributes
+	// Return IconTheme*
+
+	IconTheme *theme;
+	char *file_name;
+	FILE *f;
+	char line[2048];
+
+	if (name == NULL)
+		return NULL;
+
+	file_name = g_build_filename(g_get_home_dir(), ".icons", name, "index.theme", NULL);
+	if (!g_file_test(file_name, G_FILE_TEST_EXISTS)) {
+		g_free (file_name);
+		file_name = g_build_filename("/usr/share/icons", name, "index.theme", NULL);
+		if (!g_file_test(file_name, G_FILE_TEST_EXISTS)) {
+			g_free (file_name);
+			file_name = g_build_filename("/usr/share/pixmaps", name, "index.theme", NULL);
+			if (!g_file_test(file_name, G_FILE_TEST_EXISTS)) {
+				g_free (file_name);
+				file_name = NULL;
+			}
+		}
+	}
+
+	if (!file_name) {
+		return NULL;
+	}
+
+	if ((f = fopen(file_name, "rt")) == NULL) {
+		fprintf(stderr, "Could not open theme '%s'\n", file_name);
+		return NULL;
+	}
+
+	g_free (file_name);
+
+	theme = calloc(1, sizeof(IconTheme));
+	theme->name = strdup(name);
+	theme->list_inherits = NULL;
+	theme->list_directories = NULL;
+
+	IconThemeDir *current_dir = NULL;
+	int inside_header = 1;
+	while (fgets(line, sizeof(line), f) != NULL) {
+		char *key, *value;
+		
+		int line_len = strlen(line);
+		if (line_len >= 1) {
+			if (line[line_len - 1] == '\n') {
+				line[line_len - 1] = '\0';
+				line_len--;
+			}
+		}
+
+		if (line_len == 0)
+			continue;
+
+		if (inside_header) {
+			if (parse_theme_line(line, &key, &value)) {
+				if (strcmp(key, "Inherits") == 0) {
+					// value is like oxygen,wood,default
+					char *token;
+					token = strtok(value, ",\n");
+					while (token != NULL)
+					{
+						theme->list_inherits = g_slist_append(theme->list_inherits, strdup(token));
+						token = strtok(NULL, ",\n");
+					}
+				} else if (strcmp(key, "Directories") == 0) {
+					// value is like 48x48/apps,48x48/mimetypes,32x32/apps,scalable/apps,scalable/mimetypes
+					char *token;
+					token = strtok(value, ",\n");
+					while (token != NULL)
+					{
+						IconThemeDir *dir = calloc(1, sizeof(IconThemeDir));
+						dir->name = strdup(token);
+						dir->max_size = dir->min_size = dir->size = -1;
+						dir->type = ICON_DIR_TYPE_THRESHOLD;
+						dir->threshold = 2;
+						theme->list_directories = g_slist_append(theme->list_directories, dir);
+						token = strtok(NULL, ",\n");
+					}
+				}
+			}
+		} else if (current_dir != NULL) {
+			if (parse_theme_line(line, &key, &value)) {
+				if (strcmp(key, "Size") == 0) {
+					// value is like 24
+					sscanf(value, "%d", &current_dir->size);
+					if (current_dir->max_size == -1)
+						current_dir->max_size = current_dir->size;
+					if (current_dir->min_size == -1)
+						current_dir->min_size = current_dir->size;
+				} else if (strcmp(key, "MaxSize") == 0) {
+					// value is like 24
+					sscanf(value, "%d", &current_dir->max_size);
+				} else if (strcmp(key, "MinSize") == 0) {
+					// value is like 24
+					sscanf(value, "%d", &current_dir->min_size);
+				} else if (strcmp(key, "Threshold") == 0) {
+					// value is like 2
+					sscanf(value, "%d", &current_dir->threshold);
+				} else if (strcmp(key, "Type") == 0) {
+					// value is Fixed, Scalable or Threshold : default to scalable for unknown Type.
+					if (strcmp(value, "Fixed") == 0) {
+						current_dir->type = ICON_DIR_TYPE_FIXED;
+					} else if (strcmp(value, "Threshold") == 0) {
+						current_dir->type = ICON_DIR_TYPE_THRESHOLD;
+					} else {
+						current_dir->type = ICON_DIR_TYPE_SCALABLE;
+					}
+				} else if (strcmp(key, "Context") == 0) {
+					// usual values: Actions, Applications, Devices, FileSystems, MimeTypes
+					current_dir->context = strdup(value);
+				}
+			}
+		}
+
+		if (line[0] == '[' && line[line_len - 1] == ']' && strcmp(line, "[Icon Theme]") != 0) {
+			inside_header = 0;
+			current_dir = NULL;
+			line[line_len - 1] = '\0';
+			char *dir_name = line + 1;
+			GSList* dir_item = theme->list_directories;
+			while (dir_item != NULL)
+			{
+				IconThemeDir *dir = dir_item->data;
+				if (strcmp(dir->name, dir_name) == 0) {
+					current_dir = dir;
+					break;
+				}
+				dir_item = g_slist_next(dir_item);
+			}
+		}
+	}
+	fclose(f);
+	
+	return theme;
+}
+
+void free_icon_theme(IconTheme *theme)
+{
+	free(theme->name);
+	GSList *l_inherits;
+	for (l_inherits = theme->list_inherits; l_inherits ; l_inherits = l_inherits->next) {
+		free(l_inherits->data);
+	}
+	GSList *l_dir;
+	for (l_dir = theme->list_directories; l_dir ; l_dir = l_dir->next) {
+		IconThemeDir *dir = (IconThemeDir *)l_dir->data;
+		free(dir->name);
+		free(dir->context);
+		free(l_dir->data);
+	}
+}
+
+void test_launcher_read_theme_file()
+{
+	fprintf(stdout, "\033[1;33m");
+	IconTheme *theme = load_theme("oxygen");
+	if (!theme) {
+		printf("Could not load theme\n");
+		return;
+	}
+	printf("Loaded theme: %s\n", theme->name);
+	GSList* item = theme->list_inherits;
+	while (item != NULL)
+	{
+		printf("Inherits:%s\n", (char*)item->data);
+		item = g_slist_next(item);
+	}
+	item = theme->list_directories;
+	while (item != NULL)
+	{
+		IconThemeDir *dir = item->data;
+		printf("Dir:%s Size=%d MinSize=%d MaxSize=%d Threshold=%d Type=%s Context=%s\n",
+			   dir->name, dir->size, dir->min_size, dir->max_size, dir->threshold,
+			   dir->type == ICON_DIR_TYPE_FIXED ? "Fixed" :
+			   dir->type == ICON_DIR_TYPE_SCALABLE ? "Scalable" :
+			   dir->type == ICON_DIR_TYPE_THRESHOLD ? "Threshold" : "?????",
+			   dir->context);
+		item = g_slist_next(item);
+	}
+	fprintf(stdout, "\033[0m");
+}
+
+
+// Populates the list_icons list
+void launcher_load_icons(Launcher *launcher)
+{
+	// Load apps (.desktop style launcher items)
+	GSList* app = launcher->list_apps;
+	while (app != NULL) {
+		DesktopEntry entry;
+		launcher_read_desktop_file(app->data, &entry);
+		if (entry.exec) {
+			LauncherIcon *launcherIcon = calloc(1, sizeof(LauncherIcon));
+			launcherIcon->is_app_desktop = 1;
+			launcherIcon->cmd = strdup(entry.exec);
+			launcherIcon->icon_name = entry.icon ? strdup(entry.icon) : strdup(ICON_FALLBACK);
+			launcherIcon->icon_size = 1;
+			free_desktop_entry(&entry);
+			launcher->list_icons = g_slist_append(launcher->list_icons, launcherIcon);
+		}
+		app = g_slist_next(app);
+	}
+}
+
+
+// Populates the list_themes list
+void launcher_load_themes(Launcher *launcher)
+{
+	// load the user theme, all the inherited themes recursively (DFS), and the hicolor theme
+	// avoid inheritance loops
+	if (!icon_theme_name) {
+		fprintf(stderr, "Missing launcher theme, default to 'hicolor'.\n");
+		icon_theme_name = "hicolor";
+	}
+	else
+		fprintf(stderr, "Loading %s. Icon theme :", icon_theme_name);
+
+	GSList *queue = g_slist_append(NULL, strdup(icon_theme_name));
+	GSList *queued = g_slist_append(NULL, strdup(icon_theme_name));
+
+	int hicolor_loaded = 0;
+	while (queue || !hicolor_loaded) {
+		if (!queue) {
+			GSList* queued_item = queued;
+			while (queued_item != NULL) {
+				if (strcmp(queued_item->data, "hicolor") == 0) {
+					hicolor_loaded = 1;
+					break;
+				}
+				queued_item = g_slist_next(queued_item);
+			}
+			if (hicolor_loaded)
+				break;
+			queue = g_slist_append(queue, strdup("hicolor"));
+			queued = g_slist_append(queued, strdup("hicolor"));
+		}
+		
+		char *name = queue->data;
+		queue = g_slist_remove(queue, name);
+
+		fprintf(stderr, " '%s',", name);
+		IconTheme *theme = load_theme(name);
+		if (theme != NULL) {
+			launcher->list_themes = g_slist_append(launcher->list_themes, theme);
+
+			GSList* item = theme->list_inherits;
+			int pos = 0;
+			while (item != NULL)
+			{
+				char *parent = item->data;
+				int duplicate = 0;
+				GSList* queued_item = queued;
+				while (queued_item != NULL) {
+					if (strcmp(queued_item->data, parent) == 0) {
+						duplicate = 1;
+						break;
+					}
+					queued_item = g_slist_next(queued_item);
+				}
+				if (!duplicate) {
+					queue = g_slist_insert(queue, strdup(parent), pos);
+					pos++;
+					queued = g_slist_append(queued, strdup(parent));
+				}
+				item = g_slist_next(item);
+			}
+		}
+	}
+	fprintf(stderr, "\n");
+
+	// Free the queue
+	GSList *l;
+	for (l = queue; l ; l = l->next)
+		free(l->data);
+	g_slist_free(queue);
+	for (l = queued; l ; l = l->next)
+		free(l->data);
+	g_slist_free(queued);
+}
+
+int directory_matches_size(IconThemeDir *dir, int size)
+{
+	if (dir->type == ICON_DIR_TYPE_FIXED) {
+		return dir->size == size;
+	} else if (dir->type == ICON_DIR_TYPE_SCALABLE) {
+		return dir->min_size <= size && size <= dir->max_size;
+	} else /*if (dir->type == ICON_DIR_TYPE_THRESHOLD)*/ {
+		return dir->size - dir->threshold <= size && size <= dir->size + dir->threshold;
+	}
+}
+
+int directory_size_distance(IconThemeDir *dir, int size)
+{
+	if (dir->type == ICON_DIR_TYPE_FIXED) {
+		return abs(dir->size - size);
+	} else if (dir->type == ICON_DIR_TYPE_SCALABLE) {
+		if (size < dir->min_size) {
+			return dir->min_size - size;
+		} else if (size > dir->max_size) {
+			return size - dir->max_size;
+		} else {
+			return 0;
+		}
+	} else /*if (dir->type == ICON_DIR_TYPE_THRESHOLD)*/ {
+		if (size < dir->size - dir->threshold) {
+			return dir->min_size - size;
+		} else if (size > dir->size + dir->threshold) {
+			return size - dir->max_size;
+		} else {
+			return 0;
+		}
+	}
+}
+
+// Returns the full path to an icon file (or NULL) given the icon name
+char *icon_path(Launcher *launcher, const char *icon_name, int size)
+{
+	if (icon_name == NULL)
+		return NULL;
+	
+	// If the icon_name is already a path and the file exists, return it
+	if (strstr(icon_name, "/") == icon_name) {
+		if (g_file_test(icon_name, G_FILE_TEST_EXISTS))
+			return strdup(icon_name);
+		else
+			return NULL;
+	}
+
+	GSList *basenames = NULL;
+	char *home_icons = g_build_filename(g_get_home_dir(), ".icons", NULL);
+	basenames = g_slist_append(basenames, home_icons);
+	basenames = g_slist_append(basenames, "/usr/share/icons");
+	basenames = g_slist_append(basenames, "/usr/share/pixmaps");
+
+	GSList *extensions = NULL;
+	extensions = g_slist_append(extensions, ".png");
+	extensions = g_slist_append(extensions, ".xpm");
+	// if the icon name already contains one of the extensions (e.g. vlc.png instead of vlc) add a special entry
+	GSList *ext;
+	for (ext = extensions; ext; ext = g_slist_next(ext)) {
+		char *extension = (char*) ext->data;
+		if (strlen(icon_name) > strlen(extension) &&
+			strcmp(extension, icon_name + strlen(icon_name) - strlen(extension)) == 0) {
+			extensions = g_slist_append(extensions, "");
+			break;
+		}
+	}
+
+	GSList *theme;
+	// Stage 1: exact size match
+	// the theme must have a higher priority than having an exact size match, so we will just use
+	// the code that searches for the best size match (it will find the exact size match if one exists)
+	/*
+	for (theme = launcher->list_themes; theme; theme = g_slist_next(theme)) {
+		GSList *dir;
+		for (dir = ((IconTheme*)theme->data)->list_directories; dir; dir = g_slist_next(dir)) {
+			if (directory_matches_size((IconThemeDir*)dir->data, size)) {
+				GSList *base;
+				for (base = basenames; base; base = g_slist_next(base)) {
+					GSList *ext;
+					for (ext = extensions; ext; ext = g_slist_next(ext)) {
+						char *base_name = (char*) base->data;
+						char *theme_name = ((IconTheme*)theme->data)->name;
+						char *dir_name = ((IconThemeDir*)dir->data)->name;
+						char *extension = (char*) ext->data;
+						char *file_name = malloc(strlen(base_name) + strlen(theme_name) +
+							strlen(dir_name) + strlen(icon_name) + strlen(extension) + 100);
+						// filename = directory/$(themename)/subdirectory/iconname.extension
+						sprintf(file_name, "%s/%s/%s/%s%s", base_name, theme_name, dir_name, icon_name, extension);
+						//printf("found exact: %s\n", file_name);
+						//printf("checking %s\n", file_name);
+						if (g_file_test(file_name, G_FILE_TEST_EXISTS)) {
+							g_slist_free(basenames);
+							g_slist_free(extensions);
+							g_free(home_icons);
+							return file_name;
+						} else {
+							free(file_name);
+							file_name = NULL;
+						}
+					}
+				}
+			}
+		}
+	}
+	g_free (file_name);
+	*/
+
+	// Stage 2: best size match
+	// Contrary to the freedesktop spec, we are not choosing the closest icon in size, but the next larger icon
+	// otherwise the quality is usually crap (for size 22, if you can choose 16 or 32, you're better with 32)
+	// We do fallback to the closest size if we cannot find a larger or equal icon
+	
+	// These 3 variables are used for keeping the closest size match
+	int minimal_size = INT_MAX;
+	char *best_file_name = NULL;
+	GSList *best_file_theme = NULL;
+	
+	// These 3 variables are used for keeping the next larger match
+	int next_larger_size = -1;
+	char *next_larger = NULL;
+	GSList *next_larger_theme = NULL;
+	
+	for (theme = launcher->list_themes; theme; theme = g_slist_next(theme)) {
+		GSList *dir;
+		for (dir = ((IconTheme*)theme->data)->list_directories; dir; dir = g_slist_next(dir)) {
+			GSList *base;
+			for (base = basenames; base; base = g_slist_next(base)) {
+				GSList *ext;
+				for (ext = extensions; ext; ext = g_slist_next(ext)) {
+					char *base_name = (char*) base->data;
+					char *theme_name = ((IconTheme*)theme->data)->name;
+					char *dir_name = ((IconThemeDir*)dir->data)->name;
+					char *extension = (char*) ext->data;
+					char *file_name = malloc(strlen(base_name) + strlen(theme_name) +
+					strlen(dir_name) + strlen(icon_name) + strlen(extension) + 100);
+					// filename = directory/$(themename)/subdirectory/iconname.extension
+					sprintf(file_name, "%s/%s/%s/%s%s", base_name, theme_name, dir_name, icon_name, extension);
+					if (g_file_test(file_name, G_FILE_TEST_EXISTS)) {
+						//printf("found: %s\n", file_name);
+						// Closest match
+						if (directory_size_distance((IconThemeDir*)dir->data, size) < minimal_size && (!best_file_theme ? 1 : theme == best_file_theme)) {
+							if (best_file_name) {
+								free(best_file_name);
+								best_file_name = NULL;
+							}
+							best_file_name = strdup(file_name);
+							minimal_size = directory_size_distance((IconThemeDir*)dir->data, size);
+							best_file_theme = theme;
+							//printf("best_file_name = %s; minimal_size = %d\n", best_file_name, minimal_size);
+						}
+						// Next larger match
+						if (((IconThemeDir*)dir->data)->size >= size &&
+							(next_larger_size == -1 || ((IconThemeDir*)dir->data)->size < next_larger_size) &&
+							(!next_larger_theme ? 1 : theme == next_larger_theme)) {
+							if (next_larger) {
+								free(next_larger);
+								next_larger = NULL;
+							}
+							next_larger = strdup(file_name);
+							next_larger_size = ((IconThemeDir*)dir->data)->size;
+							next_larger_theme = theme;
+							//printf("next_larger = %s; next_larger_size = %d\n", next_larger, next_larger_size);
+						}
+					}
+					free(file_name);
+				}
+			}
+		}
+	}
+	if (next_larger) {
+		g_slist_free(basenames);
+		g_slist_free(extensions);
+		free(best_file_name);
+		g_free(home_icons);
+		return next_larger;
+	}
+	if (best_file_name) {
+		g_slist_free(basenames);
+		g_slist_free(extensions);
+		g_free(home_icons);
+		return best_file_name;
+	}
+
+	// Stage 3: look in unthemed icons
+	{
+		GSList *base;
+		for (base = basenames; base; base = g_slist_next(base)) {
+			GSList *ext;
+			for (ext = extensions; ext; ext = g_slist_next(ext)) {
+				char *base_name = (char*) base->data;
+				char *extension = (char*) ext->data;
+				char *file_name = malloc(strlen(base_name) + strlen(icon_name) +
+					strlen(extension) + 100);
+				// filename = directory/iconname.extension
+				sprintf(file_name, "%s/%s%s", base_name, icon_name, extension);
+				//printf("checking %s\n", file_name);
+				if (g_file_test(file_name, G_FILE_TEST_EXISTS)) {
+					g_slist_free(basenames);
+					g_slist_free(extensions);
+					g_free(home_icons);
+					return file_name;
+				} else {
+					free(file_name);
+					file_name = NULL;
+				}
+			}
+		}
+	}
+
+	fprintf(stderr, "Could not find icon %s\n", icon_name);
+
+	g_slist_free(basenames);
+	g_slist_free(extensions);
+	g_free(home_icons);
+	return NULL;
+}
+
diff -Nur tint2-0.11/src/launcher/launcher.h tint2-read-only/src/launcher/launcher.h
--- tint2-0.11/src/launcher/launcher.h	1970-01-01 07:00:00.000000000 +0700
+++ tint2-read-only/src/launcher/launcher.h	2010-12-23 00:02:32.099584902 +0600
@@ -0,0 +1,84 @@
+/**************************************************************************
+ * Copyright (C) 2010       (mrovi@interfete-web-club.com)
+ *
+ *
+ **************************************************************************/
+
+#ifndef LAUNCHER_H
+#define LAUNCHER_H
+
+#include "common.h"
+#include "area.h"
+#include "xsettings-client.h"
+
+typedef struct Launcher {
+	// always start with area
+	Area area;
+	GSList *list_apps;			// List of char*, each is a path to a app.desktop file
+	GSList *list_icons; 		// List of LauncherIcon*
+	GSList *list_themes;		// List of IconTheme*
+} Launcher;
+
+typedef struct LauncherIcon {
+	Imlib_Image icon_scaled;
+	Imlib_Image icon_original;
+	char *cmd;
+	char *icon_name;
+	char *icon_path;
+	int icon_size;
+	int is_app_desktop;
+	int x, y;
+} LauncherIcon;
+
+typedef struct DesktopEntry {
+	char *name;
+	char *exec;
+	char *icon;
+} DesktopEntry;
+
+#define ICON_DIR_TYPE_SCALABLE 0
+#define ICON_DIR_TYPE_FIXED 1
+#define ICON_DIR_TYPE_THRESHOLD 2
+typedef struct IconThemeDir {
+	char *name;
+	int size;
+	int type;
+	int max_size;
+	int min_size;
+	int threshold;
+	char *context;
+} IconThemeDir;
+
+typedef struct IconTheme {
+	char *name;
+	GSList *list_inherits; // each item is a char* (theme name)
+	GSList *list_directories; // each item is an IconThemeDir*
+} IconTheme;
+
+extern int launcher_enabled;
+extern int launcher_max_icon_size;
+extern char *icon_theme_name; 	// theme name
+extern XSettingsClient *xsettings_client;
+
+// default global data
+void default_launcher();
+
+// initialize launcher : y position, precision, ...
+void init_launcher();
+void init_launcher_panel(void *panel);
+void cleanup_launcher();
+void cleanup_launcher_theme(Launcher *launcher);
+
+int  resize_launcher(void *obj);
+void draw_launcher (void *obj, cairo_t *c);
+
+// Populates the list_themes list
+void launcher_load_themes(Launcher *launcher);
+// Populates the list_icons list
+void launcher_load_icons(Launcher *launcher);
+void launcher_action(LauncherIcon *icon);
+
+void test_launcher_read_desktop_file();
+void test_launcher_read_theme_file();
+
+#endif
diff -Nur tint2-0.11/src/launcher/xsettings-client.c tint2-read-only/src/launcher/xsettings-client.c
--- tint2-0.11/src/launcher/xsettings-client.c	1970-01-01 07:00:00.000000000 +0700
+++ tint2-read-only/src/launcher/xsettings-client.c	2010-12-23 00:02:32.099584902 +0600
@@ -0,0 +1,480 @@
+/*
+ * Copyright © 2001 Red Hat, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Red Hat not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  Red Hat makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * RED HAT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL RED HAT
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Owen Taylor, Red Hat, Inc.
+ */
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <X11/Xlib.h>
+#include <X11/Xmd.h>		/* For CARD16 */
+
+#include "xsettings-client.h"
+#include "server.h"
+#include "panel.h"
+#include "launcher.h"
+
+struct _XSettingsClient
+{
+	Display *display;
+	int screen;
+	XSettingsNotifyFunc notify;
+	XSettingsWatchFunc watch;
+	void *cb_data;
+
+	Window manager_window;
+	XSettingsList *settings;
+};
+
+
+void xsettings_notify_cb (const char *name, XSettingsAction action, XSettingsSetting *setting, void *data)
+{
+	//printf("xsettings_notify_cb\n");
+	if ((action == XSETTINGS_ACTION_NEW || action == XSETTINGS_ACTION_CHANGED) && name != NULL && setting != NULL) {
+		if (!strcmp(name, "Net/IconThemeName") && setting->type == XSETTINGS_TYPE_STRING) {
+			if (icon_theme_name) {
+				if (strcmp(icon_theme_name, setting->data.v_string) == 0)
+					return;
+				g_free(icon_theme_name);
+			}
+			icon_theme_name = strdup(setting->data.v_string);
+			
+			int i;
+			for (i = 0 ; i < nb_panel ; i++) {
+				Launcher *launcher = &panel1[i].launcher;
+				cleanup_launcher_theme(launcher);
+				launcher_load_themes(launcher);
+				launcher_load_icons(launcher);
+				launcher->area.resize = 1;
+			}
+		}
+	}
+}
+
+
+static void notify_changes (XSettingsClient *client, XSettingsList *old_list)
+{
+	XSettingsList *old_iter = old_list;
+	XSettingsList *new_iter = client->settings;
+
+	if (!client->notify)
+		return;
+
+	while (old_iter || new_iter) {
+		int cmp;
+
+		if (old_iter && new_iter)
+			cmp = strcmp (old_iter->setting->name, new_iter->setting->name);
+		else if (old_iter)
+			cmp = -1;
+		else
+			cmp = 1;
+
+		if (cmp < 0) {
+			client->notify (old_iter->setting->name, XSETTINGS_ACTION_DELETED, NULL, client->cb_data);
+		}
+		else if (cmp == 0) {
+			if (!xsettings_setting_equal (old_iter->setting, new_iter->setting))
+				client->notify (old_iter->setting->name, XSETTINGS_ACTION_CHANGED, new_iter->setting, client->cb_data);
+		}
+		else {
+			client->notify (new_iter->setting->name, XSETTINGS_ACTION_NEW, new_iter->setting, client->cb_data);
+		}
+
+		if (old_iter)
+			old_iter = old_iter->next;
+		if (new_iter)
+			new_iter = new_iter->next;
+	}
+}
+
+
+static int ignore_errors (Display *display, XErrorEvent *event)
+{
+	return True;
+}
+
+static char local_byte_order = '\0';
+
+#define BYTES_LEFT(buffer) ((buffer)->data + (buffer)->len - (buffer)->pos)
+
+static XSettingsResult fetch_card16 (XSettingsBuffer *buffer, CARD16 *result)
+{
+	CARD16 x;
+
+	if (BYTES_LEFT (buffer) < 2)
+		return XSETTINGS_ACCESS;
+
+	x = *(CARD16 *)buffer->pos;
+	buffer->pos += 2;
+
+	if (buffer->byte_order == local_byte_order)
+		*result = x;
+	else
+		*result = (x << 8) | (x >> 8);
+
+	return XSETTINGS_SUCCESS;
+}
+
+
+static XSettingsResult fetch_ushort (XSettingsBuffer *buffer, unsigned short  *result) 
+{
+	CARD16 x;
+	XSettingsResult r;  
+
+	r = fetch_card16 (buffer, &x);
+	if (r == XSETTINGS_SUCCESS)
+		*result = x;
+
+	return r;
+}
+
+
+static XSettingsResult fetch_card32 (XSettingsBuffer *buffer, CARD32 *result)
+{
+	CARD32 x;
+
+	if (BYTES_LEFT (buffer) < 4)
+		return XSETTINGS_ACCESS;
+
+	x = *(CARD32 *)buffer->pos;
+	buffer->pos += 4;
+
+	if (buffer->byte_order == local_byte_order)
+		*result = x;
+	else
+		*result = (x << 24) | ((x & 0xff00) << 8) | ((x & 0xff0000) >> 8) | (x >> 24);
+
+	return XSETTINGS_SUCCESS;
+}
+
+static XSettingsResult fetch_card8 (XSettingsBuffer *buffer, CARD8 *result)
+{
+  if (BYTES_LEFT (buffer) < 1)
+    return XSETTINGS_ACCESS;
+
+  *result = *(CARD8 *)buffer->pos;
+  buffer->pos += 1;
+
+  return XSETTINGS_SUCCESS;
+}
+
+#define XSETTINGS_PAD(n,m) ((n + m - 1) & (~(m-1)))
+
+static XSettingsList *parse_settings (unsigned char *data, size_t len)
+{
+	XSettingsBuffer buffer;
+	XSettingsResult result = XSETTINGS_SUCCESS;
+	XSettingsList *settings = NULL;
+	CARD32 serial;
+	CARD32 n_entries;
+	CARD32 i;
+	XSettingsSetting *setting = NULL;
+
+	local_byte_order = xsettings_byte_order ();
+
+	buffer.pos = buffer.data = data;
+	buffer.len = len;
+
+	result = fetch_card8 (&buffer, (CARD8*)&buffer.byte_order);
+	if (buffer.byte_order != MSBFirst && buffer.byte_order != LSBFirst) {
+		fprintf (stderr, "Invalid byte order %x in XSETTINGS property\n", buffer.byte_order);
+		result = XSETTINGS_FAILED;
+		goto out;
+	}
+
+	buffer.pos += 3;
+
+	result = fetch_card32 (&buffer, &serial);
+	if (result != XSETTINGS_SUCCESS)
+		goto out;
+
+	result = fetch_card32 (&buffer, &n_entries);
+	if (result != XSETTINGS_SUCCESS)
+		goto out;
+
+	for (i = 0; i < n_entries; i++) {
+		CARD8 type;
+		CARD16 name_len;
+		CARD32 v_int;
+		size_t pad_len;
+
+		result = fetch_card8 (&buffer, &type);
+		if (result != XSETTINGS_SUCCESS)
+			goto out;
+
+		buffer.pos += 1;
+
+		result = fetch_card16 (&buffer, &name_len);
+		if (result != XSETTINGS_SUCCESS)
+			goto out;
+
+		pad_len = XSETTINGS_PAD(name_len, 4);
+		if (BYTES_LEFT (&buffer) < pad_len) {
+			result = XSETTINGS_ACCESS;
+			goto out;
+		}
+
+		setting = malloc (sizeof *setting);
+		if (!setting) {
+			result = XSETTINGS_NO_MEM;
+			goto out;
+		}
+		setting->type = XSETTINGS_TYPE_INT; /* No allocated memory */
+
+		setting->name = malloc (name_len + 1);
+		if (!setting->name) {
+			result = XSETTINGS_NO_MEM;
+			goto out;
+		}
+
+		memcpy (setting->name, buffer.pos, name_len);
+		setting->name[name_len] = '\0';
+		buffer.pos += pad_len;
+
+		result = fetch_card32 (&buffer, &v_int);
+		if (result != XSETTINGS_SUCCESS)
+			goto out;
+		setting->last_change_serial = v_int;
+
+		switch (type) {
+			case XSETTINGS_TYPE_INT:
+			result = fetch_card32 (&buffer, &v_int);
+			if (result != XSETTINGS_SUCCESS)
+				goto out;
+			setting->data.v_int = (INT32)v_int;
+			break;
+			case XSETTINGS_TYPE_STRING:
+			result = fetch_card32 (&buffer, &v_int);
+			if (result != XSETTINGS_SUCCESS)
+				goto out;
+
+			pad_len = XSETTINGS_PAD (v_int, 4);
+			if (v_int + 1 == 0 || /* Guard against wrap-around */
+			BYTES_LEFT (&buffer) < pad_len) {
+				result = XSETTINGS_ACCESS;
+				goto out;
+			}
+
+			setting->data.v_string = malloc (v_int + 1);
+			if (!setting->data.v_string) {
+				result = XSETTINGS_NO_MEM;
+				goto out;
+			}
+
+			memcpy (setting->data.v_string, buffer.pos, v_int);
+			setting->data.v_string[v_int] = '\0';
+			buffer.pos += pad_len;
+			break;
+			case XSETTINGS_TYPE_COLOR:
+			result = fetch_ushort (&buffer, &setting->data.v_color.red);
+			if (result != XSETTINGS_SUCCESS)
+				goto out;
+			result = fetch_ushort (&buffer, &setting->data.v_color.green);
+			if (result != XSETTINGS_SUCCESS)
+				goto out;
+			result = fetch_ushort (&buffer, &setting->data.v_color.blue);
+			if (result != XSETTINGS_SUCCESS)
+				goto out;
+			result = fetch_ushort (&buffer, &setting->data.v_color.alpha);
+			if (result != XSETTINGS_SUCCESS)
+				goto out;
+			break;
+			default:
+			/* Quietly ignore unknown types */
+			break;
+		}
+
+		setting->type = type;
+
+		result = xsettings_list_insert (&settings, setting);
+		if (result != XSETTINGS_SUCCESS)
+		goto out;
+
+		setting = NULL;
+	}
+
+	out:
+
+	if (result != XSETTINGS_SUCCESS) {
+		switch (result) {
+			case XSETTINGS_NO_MEM:
+			fprintf(stderr, "Out of memory reading XSETTINGS property\n");
+			break;
+			case XSETTINGS_ACCESS:
+			fprintf(stderr, "Invalid XSETTINGS property (read off end)\n");
+			break;
+			case XSETTINGS_DUPLICATE_ENTRY:
+			fprintf (stderr, "Duplicate XSETTINGS entry for '%s'\n", setting->name);
+			case XSETTINGS_FAILED:
+			case XSETTINGS_SUCCESS:
+			case XSETTINGS_NO_ENTRY:
+			break;
+		}
+
+		if (setting)
+			xsettings_setting_free (setting);
+
+		xsettings_list_free (settings);
+		settings = NULL;
+	}
+
+	return settings;
+}
+
+
+static void read_settings (XSettingsClient *client)
+{
+	Atom type;
+	int format;
+	unsigned long n_items;
+	unsigned long bytes_after;
+	unsigned char *data;
+	int result;
+
+	int (*old_handler) (Display *, XErrorEvent *);
+
+	XSettingsList *old_list = client->settings;
+	client->settings = NULL;
+
+	old_handler = XSetErrorHandler (ignore_errors);
+	result = XGetWindowProperty (client->display, client->manager_window, server.atom._XSETTINGS_SETTINGS, 0, LONG_MAX, False, server.atom._XSETTINGS_SETTINGS, &type, &format, &n_items, &bytes_after, &data);
+	XSetErrorHandler (old_handler);
+
+	if (result == Success && type == server.atom._XSETTINGS_SETTINGS) {
+		if (format != 8) {
+			fprintf (stderr, "Invalid format for XSETTINGS property %d", format);
+		}
+		else
+			client->settings = parse_settings (data, n_items);
+		XFree (data);
+	}
+
+	notify_changes (client, old_list);
+	xsettings_list_free (old_list);
+}
+
+
+static void check_manager_window (XSettingsClient *client)
+{
+	if (client->manager_window && client->watch)
+		client->watch (client->manager_window, False, 0, client->cb_data);
+
+	XGrabServer (client->display);
+
+	client->manager_window = XGetSelectionOwner (server.dsp, server.atom._XSETTINGS_SCREEN);
+	if (client->manager_window)
+		XSelectInput (server.dsp, client->manager_window, PropertyChangeMask | StructureNotifyMask);
+
+	XUngrabServer (client->display);
+	XFlush (client->display);
+
+	if (client->manager_window && client->watch)
+		client->watch (client->manager_window, True, PropertyChangeMask | StructureNotifyMask, client->cb_data);
+
+	read_settings (client);
+}
+
+
+XSettingsClient *xsettings_client_new (Display *display, int screen, XSettingsNotifyFunc notify, XSettingsWatchFunc watch, void *cb_data) 
+{
+	XSettingsClient *client;
+
+	client = malloc (sizeof *client);
+	if (!client)
+		return NULL;
+
+	client->display = display;
+	client->screen = screen;
+	client->notify = notify;
+	client->watch = watch;
+	client->cb_data = cb_data;
+
+	client->manager_window = None;
+	client->settings = NULL;
+
+	if (client->watch)
+		client->watch (RootWindow (display, screen), True, StructureNotifyMask,	client->cb_data);
+
+	check_manager_window (client);
+
+	if (client->manager_window == None) {
+		printf("NO XSETTINGS manager, tint2 use config 'launcher_icon_theme'.\n");
+		free (client);
+		return NULL;
+	}
+	else
+		return client;
+}
+
+
+void xsettings_client_destroy (XSettingsClient *client)
+{
+	if (client->watch)
+		client->watch (RootWindow (client->display, client->screen), False, 0, client->cb_data);
+	if (client->manager_window && client->watch)
+		client->watch (client->manager_window, False, 0, client->cb_data);
+
+	xsettings_list_free (client->settings);
+	free (client);
+}
+
+
+XSettingsResult xsettings_client_get_setting (XSettingsClient *client, const char *name, XSettingsSetting **setting)
+{
+	XSettingsSetting *search = xsettings_list_lookup (client->settings, name);
+	if (search) {
+		*setting = xsettings_setting_copy (search);
+		return *setting ? XSETTINGS_SUCCESS : XSETTINGS_NO_MEM;
+	}
+	else
+		return XSETTINGS_NO_ENTRY;
+}
+
+
+Bool xsettings_client_process_event (XSettingsClient *client, XEvent *xev)
+{
+	/* The checks here will not unlikely cause us to reread
+	* the properties from the manager window a number of
+	* times when the manager changes from A->B. But manager changes
+	* are going to be pretty rare.
+	*/
+	if (xev->xany.window == RootWindow (server.dsp, server.screen)) {
+		if (xev->xany.type == ClientMessage && xev->xclient.message_type == server.atom.MANAGER) {
+			check_manager_window (client);
+			return True;
+		}
+	}
+	else if (xev->xany.window == client->manager_window) {
+		if (xev->xany.type == DestroyNotify) {
+			check_manager_window (client);
+			return True;
+		}
+		else if (xev->xany.type == PropertyNotify) {
+			read_settings (client);
+			return True;
+		}
+	}
+
+	return False;
+}
+
diff -Nur tint2-0.11/src/launcher/xsettings-client.h tint2-read-only/src/launcher/xsettings-client.h
--- tint2-0.11/src/launcher/xsettings-client.h	1970-01-01 07:00:00.000000000 +0700
+++ tint2-read-only/src/launcher/xsettings-client.h	2010-12-23 00:02:32.099584902 +0600
@@ -0,0 +1,57 @@
+/*
+ * Copyright © 2001 Red Hat, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Red Hat not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  Red Hat makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * RED HAT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL RED HAT
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Owen Taylor, Red Hat, Inc.
+ */
+#ifndef XSETTINGS_CLIENT_H
+#define XSETTINGS_CLIENT_H
+
+#include <X11/Xlib.h>
+#include "xsettings-common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+typedef struct _XSettingsClient XSettingsClient;
+
+typedef enum 
+{
+  XSETTINGS_ACTION_NEW,
+  XSETTINGS_ACTION_CHANGED,
+  XSETTINGS_ACTION_DELETED
+} XSettingsAction;
+
+typedef void (*XSettingsNotifyFunc) (const char *name, XSettingsAction action, XSettingsSetting *setting, void *cb_data);
+typedef void (*XSettingsWatchFunc) (Window window, Bool is_start, long mask, void *cb_data);
+
+XSettingsClient *xsettings_client_new (Display *display, int screen, XSettingsNotifyFunc notify, XSettingsWatchFunc watch, void *cb_data);
+void xsettings_client_destroy (XSettingsClient *client);
+Bool xsettings_client_process_event (XSettingsClient *client, XEvent *xev);
+
+void xsettings_notify_cb (const char *name, XSettingsAction action, XSettingsSetting *setting, void *data);
+
+XSettingsResult xsettings_client_get_setting (XSettingsClient *client, const char *name, XSettingsSetting **setting);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* XSETTINGS_CLIENT_H */
diff -Nur tint2-0.11/src/launcher/xsettings-common.c tint2-read-only/src/launcher/xsettings-common.c
--- tint2-0.11/src/launcher/xsettings-common.c	1970-01-01 07:00:00.000000000 +0700
+++ tint2-read-only/src/launcher/xsettings-common.c	2010-12-23 00:02:32.099584902 +0600
@@ -0,0 +1,268 @@
+/*
+ * Copyright © 2001 Red Hat, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Red Hat not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  Red Hat makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * RED HAT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL RED HAT
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Owen Taylor, Red Hat, Inc.
+ */
+#include "string.h"
+#include "stdlib.h"
+
+#include <X11/Xlib.h>
+#include <X11/Xmd.h>		/* For CARD32 */
+
+#include "xsettings-common.h"
+
+XSettingsSetting *
+xsettings_setting_copy (XSettingsSetting *setting)
+{
+  XSettingsSetting *result;
+  size_t str_len;
+  
+  result = malloc (sizeof *result);
+  if (!result)
+    return NULL;
+
+  str_len = strlen (setting->name);
+  result->name = malloc (str_len + 1);
+  if (!result->name)
+    goto err;
+
+  memcpy (result->name, setting->name, str_len + 1);
+
+  result->type = setting->type;
+
+  switch (setting->type)
+    {
+    case XSETTINGS_TYPE_INT:
+      result->data.v_int = setting->data.v_int;
+      break;
+    case XSETTINGS_TYPE_COLOR:
+      result->data.v_color = setting->data.v_color;
+      break;
+    case XSETTINGS_TYPE_STRING:
+      str_len = strlen (setting->data.v_string);
+      result->data.v_string = malloc (str_len + 1);
+      if (!result->data.v_string)
+	goto err;
+
+      memcpy (result->data.v_string, setting->data.v_string, str_len + 1);
+      break;
+      default:
+      break;      
+    }
+
+  result->last_change_serial = setting->last_change_serial;
+
+  return result;
+
+ err:
+  if (result->name)
+    free (result->name);
+  free (result);
+  
+  return NULL;
+}
+
+XSettingsList *
+xsettings_list_copy (XSettingsList *list)
+{
+  XSettingsList *new = NULL;
+  XSettingsList *old_iter = list;
+  XSettingsList *new_iter = NULL;
+
+  while (old_iter)
+    {
+      XSettingsList *new_node;
+
+      new_node = malloc (sizeof *new_node);
+      if (!new_node)
+	goto error;
+
+      new_node->setting = xsettings_setting_copy (old_iter->setting);
+      if (!new_node->setting)
+	{
+	  free (new_node);
+	  goto error;
+	}
+
+      if (new_iter)
+	new_iter->next = new_node;
+      else
+	new = new_node;
+
+      new_iter = new_node;
+      
+      old_iter = old_iter->next;
+    }
+
+  return new;
+
+ error:
+  xsettings_list_free (new);
+  return NULL;
+}
+
+int
+xsettings_setting_equal (XSettingsSetting *setting_a,
+			 XSettingsSetting *setting_b)
+{
+  if (setting_a->type != setting_b->type)
+    return 0;
+
+  if (strcmp (setting_a->name, setting_b->name) != 0)
+    return 0;
+
+  switch (setting_a->type)
+    {
+    case XSETTINGS_TYPE_INT:
+      return setting_a->data.v_int == setting_b->data.v_int;
+    case XSETTINGS_TYPE_COLOR:
+      return (setting_a->data.v_color.red == setting_b->data.v_color.red &&
+	      setting_a->data.v_color.green == setting_b->data.v_color.green &&
+	      setting_a->data.v_color.blue == setting_b->data.v_color.blue &&
+	      setting_a->data.v_color.alpha == setting_b->data.v_color.alpha);
+    case XSETTINGS_TYPE_STRING:
+      return strcmp (setting_a->data.v_string, setting_b->data.v_string) == 0;
+    default:
+      break;      
+    }
+
+  return 0;
+}
+
+void
+xsettings_setting_free (XSettingsSetting *setting)
+{
+  if (setting->type == XSETTINGS_TYPE_STRING)
+    free (setting->data.v_string);
+
+  if (setting->name)
+    free (setting->name);
+  
+  free (setting);
+}
+
+void
+xsettings_list_free (XSettingsList *list)
+{
+  while (list)
+    {
+      XSettingsList *next = list->next;
+
+      xsettings_setting_free (list->setting);
+      free (list);
+
+      list = next;
+    }
+}
+
+XSettingsResult
+xsettings_list_insert (XSettingsList    **list,
+		       XSettingsSetting  *setting)
+{
+  XSettingsList *node;
+  XSettingsList *iter;
+  XSettingsList *last = NULL;
+
+  node = malloc (sizeof *node);
+  if (!node)
+    return XSETTINGS_NO_MEM;
+  node->setting = setting;
+
+  iter = *list;
+  while (iter)
+    {
+      int cmp = strcmp (setting->name, iter->setting->name);
+
+      if (cmp < 0)
+	break;
+      else if (cmp == 0)
+	{
+	  free (node);
+	  return XSETTINGS_DUPLICATE_ENTRY;
+	}
+
+      last = iter;
+      iter = iter->next;
+    }
+  
+  if (last)
+    last->next = node;
+  else
+    *list = node;
+  
+  node->next = iter;
+  
+  return XSETTINGS_SUCCESS;
+}
+
+XSettingsResult
+xsettings_list_delete (XSettingsList **list,
+		       const char     *name)
+{
+  XSettingsList *iter;
+  XSettingsList *last = NULL;
+
+  iter = *list;
+  while (iter)
+    {
+      if (strcmp (name, iter->setting->name) == 0)
+	{
+	  if (last)
+	    last->next = iter->next;
+	  else
+	    *list = iter->next;
+  
+	  xsettings_setting_free (iter->setting);
+	  free (iter);
+
+	  return XSETTINGS_SUCCESS;
+	}
+
+      last = iter;
+      iter = iter->next;
+    }
+
+  return XSETTINGS_FAILED;
+}
+
+XSettingsSetting *
+xsettings_list_lookup (XSettingsList *list,
+		       const char    *name)
+{
+  XSettingsList *iter;
+
+  iter = list;
+  while (iter)
+    {
+      if (strcmp (name, iter->setting->name) == 0)
+	return iter->setting;
+
+      iter = iter->next;
+    }
+
+  return NULL;
+}
+
+char
+xsettings_byte_order (void)
+{
+  CARD32 myint = 0x01020304;
+  return (*(char *)&myint == 1) ? MSBFirst : LSBFirst;
+}
diff -Nur tint2-0.11/src/launcher/xsettings-common.h tint2-read-only/src/launcher/xsettings-common.h
--- tint2-0.11/src/launcher/xsettings-common.h	1970-01-01 07:00:00.000000000 +0700
+++ tint2-read-only/src/launcher/xsettings-common.h	2010-12-23 00:02:32.099584902 +0600
@@ -0,0 +1,111 @@
+/*
+ * Copyright © 2001 Red Hat, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Red Hat not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  Red Hat makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * RED HAT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL RED HAT
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Owen Taylor, Red Hat, Inc.
+ */
+#ifndef XSETTINGS_COMMON_H
+#define XSETTINGS_COMMON_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+typedef struct _XSettingsBuffer  XSettingsBuffer;
+typedef struct _XSettingsColor   XSettingsColor;
+typedef struct _XSettingsList    XSettingsList;
+typedef struct _XSettingsSetting XSettingsSetting;
+
+/* Types of settings possible. Enum values correspond to
+ * protocol values.
+ */
+typedef enum 
+{
+  XSETTINGS_TYPE_INT     = 0,
+  XSETTINGS_TYPE_STRING  = 1,
+  XSETTINGS_TYPE_COLOR   = 2,
+  XSETTINGS_TYPE_NONE    = 0xff
+} XSettingsType;
+
+typedef enum
+{
+  XSETTINGS_SUCCESS,
+  XSETTINGS_NO_MEM,
+  XSETTINGS_ACCESS,
+  XSETTINGS_FAILED,
+  XSETTINGS_NO_ENTRY,
+  XSETTINGS_DUPLICATE_ENTRY
+} XSettingsResult;
+
+struct _XSettingsBuffer
+{
+  char byte_order;
+  size_t len;
+  unsigned char *data;
+  unsigned char *pos;
+};
+
+struct _XSettingsColor
+{
+  unsigned short red, green, blue, alpha;
+};
+
+struct _XSettingsList
+{
+  XSettingsSetting *setting;
+  XSettingsList *next;
+};
+
+struct _XSettingsSetting
+{
+  char *name;
+  XSettingsType type;
+  
+  union {
+    int v_int;
+    char *v_string;
+    XSettingsColor v_color;
+  } data;
+
+  unsigned long last_change_serial;
+};
+
+XSettingsSetting *xsettings_setting_copy  (XSettingsSetting *setting);
+void              xsettings_setting_free  (XSettingsSetting *setting);
+int               xsettings_setting_equal (XSettingsSetting *setting_a,
+					   XSettingsSetting *setting_b);
+
+void              xsettings_list_free   (XSettingsList     *list);
+XSettingsList    *xsettings_list_copy   (XSettingsList     *list);
+XSettingsResult   xsettings_list_insert (XSettingsList    **list,
+					 XSettingsSetting  *setting);
+XSettingsSetting *xsettings_list_lookup (XSettingsList     *list,
+					 const char        *name);
+XSettingsResult   xsettings_list_delete (XSettingsList    **list,
+					 const char        *name);
+
+char xsettings_byte_order (void);
+
+#define XSETTINGS_PAD(n,m) ((n + m - 1) & (~(m-1)))
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* XSETTINGS_COMMON_H */
diff -Nur tint2-0.11/src/panel.c tint2-read-only/src/panel.c
--- tint2-0.11/src/panel.c	2010-06-26 19:35:35.000000000 +0700
+++ tint2-read-only/src/panel.c	2010-12-23 00:02:32.319656009 +0600
@@ -1,7 +1,7 @@
 /**************************************************************************
 *
 * Copyright (C) 2008 Pål Staurland (staura@gmail.com)
-* Modified (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr)
+* Modified (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2
@@ -58,6 +58,7 @@
 int panel_autohide_hide_timeout;
 int panel_autohide_height;
 int panel_strut_policy;
+char *panel_items_order;
 
 int  max_tick_urgent;
 
@@ -79,6 +80,7 @@
 	task_dragged = 0;
 	panel_horizontal = 1;
 	panel_position = CENTER;
+	panel_items_order = 0;
 	panel_autohide = 0;
 	panel_autohide_show_timeout = 0;
 	panel_autohide_hide_timeout = 0;
@@ -87,7 +89,7 @@
 	panel_dock = 0;  // default not in the dock
 	panel_layer = BOTTOM_LAYER;  // default is bottom layer
 	wm_menu = 0;
-	max_tick_urgent = 7;
+	max_tick_urgent = 14;
 	backgrounds = g_array_new(0, 0, sizeof(Background));
 
 	memset(&panel_config, 0, sizeof(Panel));
@@ -103,6 +105,8 @@
 	if (!panel1) return;
 
 	cleanup_taskbar();
+	// taskbarname_font_desc freed here because cleanup_taskbarname() called on _NET_NUMBER_OF_DESKTOPS
+	if (taskbarname_font_desc)	pango_font_description_free(taskbarname_font_desc);
 
 	int i;
 	Panel *p;
@@ -115,6 +119,7 @@
 		if (p->main_win) XDestroyWindow(server.dsp, p->main_win);
 	}
 
+	if (panel_items_order) g_free(panel_items_order);
 	if (panel1) free(panel1);
 	if (backgrounds)
 		g_array_free(backgrounds, 1);
@@ -123,7 +128,7 @@
 
 void init_panel()
 {
-	int i;
+	int i, k;
 	Panel *p;
 
 	if (panel_config.monitor > (server.nb_monitor-1)) {
@@ -134,10 +139,12 @@
 
 	init_tooltip();
 	init_systray();
+	init_launcher();
 	init_clock();
 #ifdef ENABLE_BATTERY
 	init_battery();
 #endif
+	init_taskbar();
 
 	// number of panels (one monitor or 'all' monitors)
 	if (panel_config.monitor >= 0)
@@ -156,32 +163,34 @@
 
 		if (panel_config.monitor < 0)
 			p->monitor = i;
+		if ( p->area.bg == 0 )
+			p->area.bg = &g_array_index(backgrounds, Background, 0);
 		p->area.parent = p;
 		p->area.panel = p;
 		p->area.on_screen = 1;
 		p->area.resize = 1;
+		p->area.size_mode = SIZE_BY_LAYOUT;
 		p->area._resize = resize_panel;
-		p->g_taskbar.area.parent = p;
-		p->g_taskbar.area.panel = p;
-		p->g_task.area.panel = p;
 		init_panel_size_and_position(p);
-		// add childs
-		if (clock_enabled) {
-			init_clock_panel(p);
-			p->area.list = g_slist_append(p->area.list, &p->clock);
-		}
+		// add childs according to panel_items
+		for (k=0 ; k < strlen(panel_items_order) ; k++) {
+			if (panel_items_order[k] == 'L') 
+				init_launcher_panel(p);
+			if (panel_items_order[k] == 'T')
+				init_taskbar_panel(p);
 #ifdef ENABLE_BATTERY
-		if (battery_enabled) {
-			init_battery_panel(p);
-			p->area.list = g_slist_append(p->area.list, &p->battery);
-		}
+			if (panel_items_order[k] == 'B')
+				init_battery_panel(p);
 #endif
-		// systray only on first panel
-		if (systray.area.on_screen && i == 0) {
-			init_systray_panel(p);
-			p->area.list = g_slist_append(p->area.list, &systray);
-			refresh_systray = 1;
+			if (panel_items_order[k] == 'S') {
+				// TODO : check systray is only on 1 panel
+				init_systray_panel(p);
+				refresh_systray = 1;
+			}
+			if (panel_items_order[k] == 'C')
+				init_clock_panel(p);
 		}
+		set_panel_items_order(p);
 
 		// catch some events
 		XSetWindowAttributes att = { .colormap=server.colormap, .background_pixel=0, .border_pixel=0 };
@@ -189,7 +198,7 @@
 		p->main_win = XCreateWindow(server.dsp, server.root_win, p->posx, p->posy, p->area.width, p->area.height, 0, server.depth, InputOutput, server.visual, mask, &att);
 
 		long event_mask = ExposureMask|ButtonPressMask|ButtonReleaseMask|ButtonMotionMask;
-		if (g_tooltip.enabled)
+		if (p->g_task.tooltip_enabled || p->clock.area._get_tooltip_text)
 			event_mask |= PointerMotionMask|LeaveWindowMask;
 		if (panel_autohide)
 			event_mask |= LeaveWindowMask|EnterWindowMask;
@@ -209,11 +218,10 @@
 
 		if (panel_autohide)
 			add_timeout(panel_autohide_hide_timeout, 0, autohide_hide, p);
+		
+		visible_taskbar(p);
 	}
 
-	panel_refresh = 1;
-	init_taskbar();
-	visible_object();
 	task_refresh_tasklist();
 	active_task();
 }
@@ -293,107 +301,27 @@
 }
 
 
-void resize_panel(void *obj)
+int resize_panel(void *obj)
 {
-	Panel *panel = (Panel*)obj;
-
-	if (panel_horizontal) {
-		int taskbar_width, modulo_width = 0;
-
-		taskbar_width = panel->area.width - (2 * panel->area.paddingxlr) - (2 * panel->area.bg->border.width);
-		if (panel->clock.area.on_screen && panel->clock.area.width)
-			taskbar_width -= (panel->clock.area.width + panel->area.paddingx);
-	#ifdef ENABLE_BATTERY
-		if (panel->battery.area.on_screen && panel->battery.area.width)
-			taskbar_width -= (panel->battery.area.width + panel->area.paddingx);
-	#endif
-		// TODO : systray only on first panel. search better implementation !
-		if (systray.area.on_screen && systray.area.width && panel == &panel1[0])
-			taskbar_width -= (systray.area.width + panel->area.paddingx);
-
-		if (panel_mode == MULTI_DESKTOP) {
-			int width = taskbar_width - ((panel->nb_desktop-1) * panel->area.paddingx);
-			taskbar_width = width / panel->nb_desktop;
-			modulo_width = width % panel->nb_desktop;
-		}
-
-		// change posx and width for all taskbar
-		int i, posx;
-		posx = panel->area.bg->border.width + panel->area.paddingxlr;
-		for (i=0 ; i < panel->nb_desktop ; i++) {
-			panel->taskbar[i].area.posx = posx;
-			panel->taskbar[i].area.width = taskbar_width;
-			panel->taskbar[i].area.resize = 1;
-			if (modulo_width) {
-				panel->taskbar[i].area.width++;
-				modulo_width--;
-			}
-			//printf("taskbar %d : posx %d, width, %d, posy %d\n", i, posx, panel->taskbar[i].area.width, posx + panel->taskbar[i].area.width);
-			if (panel_mode == MULTI_DESKTOP)
-				posx += panel->taskbar[i].area.width + panel->area.paddingx;
-		}
-	}
-	else {
-		int taskbar_height, modulo_height = 0;
-		int i, posy;
-
-		taskbar_height = panel->area.height - (2 * panel->area.paddingxlr) - (2 * panel->area.bg->border.width);
-		if (panel->clock.area.on_screen && panel->clock.area.height)
-			taskbar_height -= (panel->clock.area.height + panel->area.paddingx);
-	#ifdef ENABLE_BATTERY
-		if (panel->battery.area.on_screen && panel->battery.area.height)
-			taskbar_height -= (panel->battery.area.height + panel->area.paddingx);
-	#endif
-		// TODO : systray only on first panel. search better implementation !
-		if (systray.area.on_screen && systray.area.height && panel == &panel1[0])
-			taskbar_height -= (systray.area.height + panel->area.paddingx);
-
-		posy = panel->area.height - panel->area.bg->border.width - panel->area.paddingxlr - taskbar_height;
-		if (panel_mode == MULTI_DESKTOP) {
-			int height = taskbar_height - ((panel->nb_desktop-1) * panel->area.paddingx);
-			taskbar_height = height / panel->nb_desktop;
-			modulo_height = height % panel->nb_desktop;
-		}
-
-		// change posy and height for all taskbar
+	resize_by_layout(obj, 0);
+	
+	//printf("resize_panel\n");
+	if (panel_mode != MULTI_DESKTOP && taskbar_enabled) {
+		// propagate width/height on hidden taskbar
+		int i, width, height;
+		Panel *panel = (Panel*)obj;
+		width = panel->taskbar[server.desktop].area.width;
+		height = panel->taskbar[server.desktop].area.height;
 		for (i=0 ; i < panel->nb_desktop ; i++) {
-			panel->taskbar[i].area.posy = posy;
-			panel->taskbar[i].area.height = taskbar_height;
+			panel->taskbar[i].area.width = width;
+			panel->taskbar[i].area.height = height;
 			panel->taskbar[i].area.resize = 1;
-			if (modulo_height) {
-				panel->taskbar[i].area.height++;
-				modulo_height--;
-			}
-			if (panel_mode == MULTI_DESKTOP)
-				posy += panel->taskbar[i].area.height + panel->area.paddingx;
 		}
 	}
+	return 0;
 }
 
 
-void visible_object()
-{
-	Panel *panel;
-	int i, j;
-
-	for (i=0 ; i < nb_panel ; i++) {
-		panel = &panel1[i];
-
-		Taskbar *taskbar;
-		for (j=0 ; j < panel->nb_desktop ; j++) {
-			taskbar = &panel->taskbar[j];
-			if (panel_mode != MULTI_DESKTOP && taskbar->desktop != server.desktop) {
-				// SINGLE_DESKTOP and not current desktop
-				taskbar->area.on_screen = 0;
-			}
-			else {
-				taskbar->area.on_screen = 1;
-			}
-		}
-	}
-	panel_refresh = 1;
-}
-
 void update_strut(Panel* p)
 {
 	if (panel_strut_policy == STRUT_NONE) {
@@ -449,6 +377,37 @@
 }
 
 
+void set_panel_items_order(Panel *p)
+{
+	int k, j;
+	
+	if (p->area.list) {
+		g_slist_free(p->area.list);
+		p->area.list = 0;
+	}
+
+	for (k=0 ; k < strlen(panel_items_order) ; k++) {
+		if (panel_items_order[k] == 'L') 
+			p->area.list = g_slist_append(p->area.list, &p->launcher);
+		if (panel_items_order[k] == 'T') {
+			for (j=0 ; j < p->nb_desktop ; j++)
+				p->area.list = g_slist_append(p->area.list, &p->taskbar[j]);
+		}
+#ifdef ENABLE_BATTERY
+		if (panel_items_order[k] == 'B') 
+			p->area.list = g_slist_append(p->area.list, &p->battery);
+#endif
+		if (panel_items_order[k] == 'S') {
+			// TODO : check systray is only on 1 panel
+			p->area.list = g_slist_append(p->area.list, &systray);
+		}
+		if (panel_items_order[k] == 'C')
+			p->area.list = g_slist_append(p->area.list, &p->clock);
+	}
+	init_rendering(&p->area, 0);
+}
+
+
 void set_panel_properties(Panel *p)
 {
 	XStoreName (server.dsp, p->main_win, "tint2");
@@ -493,7 +452,7 @@
 	XChangeProperty(server.dsp, p->main_win, server.atom._MOTIF_WM_HINTS, server.atom._MOTIF_WM_HINTS, 32, PropModeReplace, (unsigned char *) prop, 5);
 
 	// XdndAware - Register for Xdnd events
-	int version=5;
+	Atom version=4;
 	XChangeProperty(server.dsp, p->main_win, server.atom.XdndAware, XA_ATOM, 32, PropModeReplace, (unsigned char*)&version, 1);
 
 	update_strut(p);
@@ -569,12 +528,23 @@
 		a = l0->data;
 		set_redraw(a);
 	}
-	// reset task 'state_pix'
-	int i;
+	
+	// reset task/taskbar 'state_pix'
+	int i, k;
 	Taskbar *tskbar;
 	for (i=0 ; i < p->nb_desktop ; i++) {
 		tskbar = &p->taskbar[i];
-		for (l0 = tskbar->area.list; l0 ; l0 = l0->next) {
+		for (k=0; k<TASKBAR_STATE_COUNT; ++k) {
+			if (tskbar->state_pix[k]) XFreePixmap(server.dsp, tskbar->state_pix[k]);
+			tskbar->state_pix[k] = 0;
+			if (tskbar->bar_name.state_pix[k]) XFreePixmap(server.dsp, tskbar->bar_name.state_pix[k]);
+			tskbar->bar_name.state_pix[k] = 0;
+		}
+		tskbar->area.pix = 0;
+		tskbar->bar_name.area.pix = 0;
+		l0 = tskbar->area.list;
+		if (taskbarname_enabled) l0 = l0->next;
+		for (; l0 ; l0 = l0->next) {
 			set_task_redraw((Task *)l0->data);
 		}
 	}
@@ -624,7 +594,9 @@
 	if ( (tskbar = click_taskbar(panel, x, y)) ) {
 		if (panel_horizontal) {
 			Task *tsk;
-			for (l0 = tskbar->area.list; l0 ; l0 = l0->next) {
+			l0 = tskbar->area.list;
+			if (taskbarname_enabled) l0 = l0->next;
+			for (; l0 ; l0 = l0->next) {
 				tsk = l0->data;
 				if (tsk->area.on_screen && x >= tsk->area.posx && x <= (tsk->area.posx + tsk->area.width)) {
 					return tsk;
@@ -633,7 +605,9 @@
 		}
 		else {
 			Task *tsk;
-			for (l0 = tskbar->area.list; l0 ; l0 = l0->next) {
+			l0 = tskbar->area.list;
+			if (taskbarname_enabled) l0 = l0->next;
+			for (; l0 ; l0 = l0->next) {
 				tsk = l0->data;
 				if (tsk->area.on_screen && y >= tsk->area.posy && y <= (tsk->area.posy + tsk->area.height)) {
 					return tsk;
@@ -645,6 +619,43 @@
 }
 
 
+Launcher *click_launcher (Panel *panel, int x, int y)
+{
+	Launcher *launcher = &panel->launcher;
+	
+	if (panel_horizontal) {
+		if (launcher->area.on_screen && x >= launcher->area.posx && x <= (launcher->area.posx + launcher->area.width))
+			return launcher;
+	}
+	else {
+		if (launcher->area.on_screen && y >= launcher->area.posy && y <= (launcher->area.posy + launcher->area.height))
+			return launcher;
+	}
+	return NULL;
+}
+
+
+LauncherIcon *click_launcher_icon (Panel *panel, int x, int y)
+{
+	GSList *l0;
+	Launcher *launcher;
+
+	//printf("Click x=%d y=%d\n", x, y);
+	if ( (launcher = click_launcher(panel, x, y)) ) {
+		LauncherIcon *icon;
+		for (l0 = launcher->list_icons; l0 ; l0 = l0->next) {
+			icon = l0->data;
+			if (x >= (launcher->area.posx + icon->x) && x <= (launcher->area.posx + icon->x + icon->icon_size) &&
+				y >= (launcher->area.posy + icon->y) && y <= (launcher->area.posy + icon->y + icon->icon_size)) {
+				//printf("Hit rect x=%d y=%d xmax=%d ymax=%d\n", launcher->area.posx + icon->x, launcher->area.posy + icon->y, launcher->area.posx + icon->x + icon->width, launcher->area.posy + icon->y + icon->height);
+				return icon;
+			}
+		}
+	}
+	return NULL;
+}
+
+
 int click_padding(Panel *panel, int x, int y)
 {
 	if (panel_horizontal) {
diff -Nur tint2-0.11/src/panel.h tint2-read-only/src/panel.h
--- tint2-0.11/src/panel.h	2010-06-26 19:35:35.000000000 +0700
+++ tint2-read-only/src/panel.h	2010-12-23 00:02:32.319656009 +0600
@@ -19,6 +19,7 @@
 #include "task.h"
 #include "taskbar.h"
 #include "systraybar.h"
+#include "launcher.h"
 
 #ifdef ENABLE_BATTERY
 #include "battery.h"
@@ -58,6 +59,7 @@
 extern int panel_autohide_hide_timeout;
 extern int panel_autohide_height;  // for vertical panels this is of course the width
 extern int panel_strut_policy;
+extern char *panel_items_order;
 
 extern int  max_tick_urgent;
 
@@ -107,6 +109,8 @@
 	Battery battery;
 #endif
 
+	Launcher launcher;
+
 	// autohide
 	int is_hidden;
 	int hidden_width, hidden_height;
@@ -131,10 +135,10 @@
 void init_panel();
 
 void init_panel_size_and_position(Panel *panel);
-void resize_panel(void *obj);
+int  resize_panel(void *obj);
 
+void set_panel_items_order(Panel *p);
 void set_panel_properties(Panel *p);
-void visible_object();
 
 // draw background panel
 void set_panel_background(Panel *p);
@@ -144,6 +148,8 @@
 
 Taskbar *click_taskbar (Panel *panel, int x, int y);
 Task *click_task (Panel *panel, int x, int y);
+Launcher *click_launcher (Panel *panel, int x, int y);
+LauncherIcon *click_launcher_icon (Panel *panel, int x, int y);
 int click_padding(Panel *panel, int x, int y);
 int click_clock(Panel *panel, int x, int y);
 Area* click_area(Panel *panel, int x, int y);
diff -Nur tint2-0.11/src/server.c tint2-read-only/src/server.c
--- tint2-0.11/src/server.c	2010-06-26 19:35:35.000000000 +0700
+++ tint2-read-only/src/server.c	2010-12-23 00:02:32.319656009 +0600
@@ -36,8 +36,10 @@
 void server_init_atoms ()
 {
 	server.atom._XROOTPMAP_ID = XInternAtom (server.dsp, "_XROOTPMAP_ID", False);
+	server.atom._XROOTMAP_ID = XInternAtom (server.dsp, "_XROOTMAP_ID", False);
 	server.atom._NET_CURRENT_DESKTOP = XInternAtom (server.dsp, "_NET_CURRENT_DESKTOP", False);
 	server.atom._NET_NUMBER_OF_DESKTOPS = XInternAtom (server.dsp, "_NET_NUMBER_OF_DESKTOPS", False);
+	server.atom._NET_DESKTOP_NAMES = XInternAtom (server.dsp, "_NET_DESKTOP_NAMES", False);
 	server.atom._NET_DESKTOP_GEOMETRY = XInternAtom (server.dsp, "_NET_DESKTOP_GEOMETRY", False);
 	server.atom._NET_DESKTOP_VIEWPORT = XInternAtom (server.dsp, "_NET_DESKTOP_VIEWPORT", False);
 	server.atom._NET_ACTIVE_WINDOW = XInternAtom (server.dsp, "_NET_ACTIVE_WINDOW", False);
@@ -79,17 +81,21 @@
 	server.atom.__SWM_VROOT = XInternAtom(server.dsp, "__SWM_VROOT", False);
 	server.atom._MOTIF_WM_HINTS = XInternAtom(server.dsp, "_MOTIF_WM_HINTS", False);
 	server.atom.WM_HINTS = XInternAtom(server.dsp, "WM_HINTS", False);
+	char *name = g_strdup_printf("_XSETTINGS_S%d", DefaultScreen(server.dsp));
+	server.atom._XSETTINGS_SCREEN = XInternAtom(server.dsp, name, False);
+	g_free(name);
+	server.atom._XSETTINGS_SETTINGS = XInternAtom(server.dsp, "_XSETTINGS_SETTINGS", False);
 
 	// systray protocol
-	char *name_trayer = g_strdup_printf("_NET_SYSTEM_TRAY_S%d", DefaultScreen(server.dsp));
-	server.atom._NET_SYSTEM_TRAY_SCREEN = XInternAtom(server.dsp, name_trayer, False);
+	name = g_strdup_printf("_NET_SYSTEM_TRAY_S%d", DefaultScreen(server.dsp));
+	server.atom._NET_SYSTEM_TRAY_SCREEN = XInternAtom(server.dsp, name, False);
+	g_free(name);
 	server.atom._NET_SYSTEM_TRAY_OPCODE = XInternAtom(server.dsp, "_NET_SYSTEM_TRAY_OPCODE", False);
 	server.atom.MANAGER = XInternAtom(server.dsp, "MANAGER", False);
 	server.atom._NET_SYSTEM_TRAY_MESSAGE_DATA = XInternAtom(server.dsp, "_NET_SYSTEM_TRAY_MESSAGE_DATA", False);
 	server.atom._NET_SYSTEM_TRAY_ORIENTATION = XInternAtom(server.dsp, "_NET_SYSTEM_TRAY_ORIENTATION", False);
 	server.atom._XEMBED = XInternAtom(server.dsp, "_XEMBED", False);
 	server.atom._XEMBED_INFO = XInternAtom(server.dsp, "_XEMBED_INFO", False);
-	g_free(name_trayer);
 
 	// drag 'n' drop
 	server.atom.XdndAware = XInternAtom(server.dsp, "XdndAware", False);
@@ -170,8 +176,8 @@
 
 	result = XGetWindowProperty(server.dsp, win, at, 0, 0x7fffffff, False, type, &type_ret, &format_ret, &nitems_ret, &bafter_ret, &prop_value);
 
-	/* Send back resultcount */
-	if (num_results) *num_results = nitems_ret;
+	// Send back resultcount
+	if (num_results) *num_results = (int)nitems_ret;
 
 	if (result == Success && prop_value) return prop_value;
 	else return 0;
@@ -183,16 +189,17 @@
 	Pixmap ret = None;
 
 	unsigned long *res;
-	int  c = 2;
+	Atom pixmap_atoms[] = { server.atom._XROOTPMAP_ID, server.atom._XROOTMAP_ID };
+	int i;
 
-	do {
-		res = server_get_property (server.root_win, server.atom._XROOTPMAP_ID, XA_PIXMAP, 0);
+	for (i=0; i<sizeof(pixmap_atoms)/sizeof(Atom); ++i) {
+		res = server_get_property (server.root_win, pixmap_atoms[i], XA_PIXMAP, 0);
 		if (res) {
 			ret = *((Pixmap*)res);
 			XFree(res);
 			break;
 		}
-	} while (--c > 0);
+	}
 	server.root_pmap = ret;
 
 	if (server.root_pmap == None)
@@ -302,7 +309,7 @@
 			i++;
 		}
 next:
-		for (j=i; j<server.nb_monitor; ++j)
+		for (j=i; j<nbmonitor; ++j)
 			if (server.monitor[j].names)
 				g_strfreev(server.monitor[j].names);
 		server.nb_monitor = i;
diff -Nur tint2-0.11/src/server.h tint2-read-only/src/server.h
--- tint2-0.11/src/server.h	2010-06-26 19:35:35.000000000 +0700
+++ tint2-read-only/src/server.h	2010-12-23 00:02:32.319656009 +0600
@@ -17,8 +17,10 @@
 typedef struct Global_atom
 {
 	Atom _XROOTPMAP_ID;
+	Atom _XROOTMAP_ID;
 	Atom _NET_CURRENT_DESKTOP;
 	Atom _NET_NUMBER_OF_DESKTOPS;
+	Atom _NET_DESKTOP_NAMES;
 	Atom _NET_DESKTOP_GEOMETRY;
 	Atom _NET_DESKTOP_VIEWPORT;
 	Atom _NET_ACTIVE_WINDOW;
@@ -49,7 +51,7 @@
 	Atom _NET_WM_VISIBLE_NAME;
 	Atom _NET_WM_STRUT;
 	Atom _NET_WM_ICON;
-  Atom _NET_WM_ICON_GEOMETRY;
+	Atom _NET_WM_ICON_GEOMETRY;
 	Atom _NET_CLOSE_WINDOW;
 	Atom UTF8_STRING;
 	Atom _NET_SUPPORTING_WM_CHECK;
@@ -66,6 +68,8 @@
 	Atom _NET_SYSTEM_TRAY_ORIENTATION;
 	Atom _XEMBED;
 	Atom _XEMBED_INFO;
+	Atom _XSETTINGS_SCREEN;
+	Atom _XSETTINGS_SETTINGS;
 	Atom XdndAware;
 	Atom XdndPosition;
 	Atom XdndStatus;
diff -Nur tint2-0.11/src/systray/systraybar.c tint2-read-only/src/systray/systraybar.c
--- tint2-0.11/src/systray/systraybar.c	2010-06-09 22:31:18.000000000 +0700
+++ tint2-read-only/src/systray/systraybar.c	2010-12-23 00:02:32.319656009 +0600
@@ -1,7 +1,7 @@
 /**************************************************************************
 * Tint2 : systraybar
 *
-* Copyright (C) 2009 thierry lorthiois (lorthiois@bbsoft.fr)
+* Copyright (C) 2009 thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
 * based on 'docker-1.5' from Ben Jansens.
 *
 * This program is free software; you can redistribute it and/or
@@ -61,6 +61,8 @@
 	systray.alpha = 100;
 	systray.sort = 3;
 	systray.area._draw_foreground = draw_systray;
+	systray.area._on_change_layout = on_change_systray;
+	systray.area.size_mode = SIZE_BY_CONTENT;
 	systray.area._resize = resize_systray;
 }
 
@@ -89,27 +91,25 @@
 		systray.alpha = 100;
 		systray.brightness = systray.saturation = 0;
 	}
-	systray.area.resize = 1;
-	systray.area.redraw = 1;
-	systray.area.on_screen = 1;
-	refresh_systray = 0;
 }
 
 
 void init_systray_panel(void *p)
 {
-	Panel *panel =(Panel*)p;
-
-	if (panel_horizontal) {
-		systray.area.posy = panel->area.bg->border.width + panel->area.paddingy;
-		systray.area.height = panel->area.height - (2 * systray.area.posy);
-	}
-	else {
-		systray.area.posx = panel->area.bg->border.width + panel->area.paddingy;
-		systray.area.width = panel->area.width - (2 * panel->area.bg->border.width) - (2 * panel->area.paddingy);
-	}
 	systray.area.parent = p;
 	systray.area.panel = p;
+	
+	GSList *l;
+	int count = 0;
+	for (l = systray.list_icons; l ; l = l->next) {
+		if (!((TrayWindow*)l->data)->hide)
+			count++;
+	}
+	if (count == 0)
+		hide(&systray.area);
+	else 
+		show(&systray.area);
+	refresh_systray = 0;
 }
 
 
@@ -125,22 +125,19 @@
 }
 
 
-void resize_systray(void *obj)
+int resize_systray(void *obj)
 {
 	Systraybar *sysbar = obj;
-	Panel *panel = sysbar->area.panel;
-	TrayWindow *traywin;
 	GSList *l;
-	int count, icon_size;
-	int icons_per_column=1, icons_per_row=1, marging=0;
+	int count;
 
 	if (panel_horizontal)
-		icon_size = sysbar->area.height;
+		sysbar->icon_size = sysbar->area.height;
 	else
-		icon_size = sysbar->area.width;
-	icon_size = icon_size - (2 * sysbar->area.bg->border.width) - (2 * sysbar->area.paddingy);
-	if (systray_max_icon_size > 0 && icon_size > systray_max_icon_size)
-		icon_size = systray_max_icon_size;
+		sysbar->icon_size = sysbar->area.width;
+	sysbar->icon_size = sysbar->icon_size - (2 * sysbar->area.bg->border.width) - (2 * sysbar->area.paddingy);
+	if (systray_max_icon_size > 0 && sysbar->icon_size > systray_max_icon_size)
+		sysbar->icon_size = systray_max_icon_size;
 	count = 0;
 	for (l = systray.list_icons; l ; l = l->next) {
 		if (!((TrayWindow*)l->data)->hide)
@@ -149,46 +146,32 @@
 	//printf("count %d\n", count);
 
 	if (panel_horizontal) {
-		if (!count) systray.area.width = 0;
-		else {
-			int height = sysbar->area.height - 2*sysbar->area.bg->border.width - 2*sysbar->area.paddingy;
-			// here icons_per_column always higher than 0
-			icons_per_column = (height+sysbar->area.paddingx) / (icon_size+sysbar->area.paddingx);
-			marging = height - (icons_per_column-1)*(icon_size+sysbar->area.paddingx) - icon_size;
-			icons_per_row = count / icons_per_column + (count%icons_per_column != 0);
-			systray.area.width = (2 * systray.area.bg->border.width) + (2 * systray.area.paddingxlr) + (icon_size * icons_per_row) + ((icons_per_row-1) * systray.area.paddingx);
-		}
-
-		systray.area.posx = panel->area.width - panel->area.bg->border.width - panel->area.paddingxlr - systray.area.width;
-		if (panel->clock.area.on_screen)
-			systray.area.posx -= (panel->clock.area.width + panel->area.paddingx);
-#ifdef ENABLE_BATTERY
-		if (panel->battery.area.on_screen)
-			systray.area.posx -= (panel->battery.area.width + panel->area.paddingx);
-#endif
+		int height = sysbar->area.height - 2*sysbar->area.bg->border.width - 2*sysbar->area.paddingy;
+		// here icons_per_column always higher than 0
+		sysbar->icons_per_column = (height+sysbar->area.paddingx) / (sysbar->icon_size+sysbar->area.paddingx);
+		sysbar->marging = height - (sysbar->icons_per_column-1)*(sysbar->icon_size+sysbar->area.paddingx) - sysbar->icon_size;
+		sysbar->icons_per_row = count / sysbar->icons_per_column + (count%sysbar->icons_per_column != 0);
+		systray.area.width = (2 * systray.area.bg->border.width) + (2 * systray.area.paddingxlr) + (sysbar->icon_size * sysbar->icons_per_row) + ((sysbar->icons_per_row-1) * systray.area.paddingx);
 	}
 	else {
-		if (!count) systray.area.height = 0;
-		else {
-			int width = sysbar->area.width - 2*sysbar->area.bg->border.width - 2*sysbar->area.paddingy;
-			// here icons_per_row always higher than 0
-			icons_per_row = (width+sysbar->area.paddingx) / (icon_size+sysbar->area.paddingx);
-			marging = width - (icons_per_row-1)*(icon_size+sysbar->area.paddingx) - icon_size;
-			icons_per_column = count / icons_per_row+ (count%icons_per_row != 0);
-			systray.area.height = (2 * systray.area.bg->border.width) + (2 * systray.area.paddingxlr) + (icon_size * icons_per_column) + ((icons_per_column-1) * systray.area.paddingx);
-		}
-
-		systray.area.posy = panel->area.bg->border.width + panel->area.paddingxlr;
-		if (panel->clock.area.on_screen)
-			systray.area.posy += (panel->clock.area.height + panel->area.paddingx);
-#ifdef ENABLE_BATTERY
-		if (panel->battery.area.on_screen)
-			systray.area.posy += (panel->battery.area.height + panel->area.paddingx);
-#endif
+		int width = sysbar->area.width - 2*sysbar->area.bg->border.width - 2*sysbar->area.paddingy;
+		// here icons_per_row always higher than 0
+		sysbar->icons_per_row = (width+sysbar->area.paddingx) / (sysbar->icon_size+sysbar->area.paddingx);
+		sysbar->marging = width - (sysbar->icons_per_row-1)*(sysbar->icon_size+sysbar->area.paddingx) - sysbar->icon_size;
+		sysbar->icons_per_column = count / sysbar->icons_per_row+ (count%sysbar->icons_per_row != 0);
+		systray.area.height = (2 * systray.area.bg->border.width) + (2 * systray.area.paddingxlr) + (sysbar->icon_size * sysbar->icons_per_column) + ((sysbar->icons_per_column-1) * systray.area.paddingx);
 	}
+	return 1;
+}
+
 
+void on_change_systray (void *obj)
+{
+	// here, systray.area.posx/posy are defined by rendering engine. so we can calculate position of tray icon.
+	Systraybar *sysbar = obj;
+	Panel *panel = sysbar->area.panel;
 	int i, posx, posy;
-	int start = panel->area.bg->border.width + panel->area.paddingy + systray.area.bg->border.width + systray.area.paddingy +marging/2;
+	int start = panel->area.bg->border.width + panel->area.paddingy + systray.area.bg->border.width + systray.area.paddingy + sysbar->marging/2;
 	if (panel_horizontal) {
 		posy = start;
 		posx = systray.area.posx + systray.area.bg->border.width + systray.area.paddingxlr;
@@ -198,37 +181,38 @@
 		posy = systray.area.posy + systray.area.bg->border.width + systray.area.paddingxlr;
 	}
 
+	TrayWindow *traywin;
+	GSList *l;
 	for (i=1, l = systray.list_icons; l ; i++, l = l->next) {
 		traywin = (TrayWindow*)l->data;
 		if (traywin->hide) continue;
 
 		traywin->y = posy;
 		traywin->x = posx;
-		traywin->width = icon_size;
-		traywin->height = icon_size;
+		//printf("systray %d : %d,%d\n", i, posx, posy);
+		traywin->width = sysbar->icon_size;
+		traywin->height = sysbar->icon_size;
 		if (panel_horizontal) {
-			if (i % icons_per_column)
-				posy += icon_size + sysbar->area.paddingx;
+			if (i % sysbar->icons_per_column)
+				posy += sysbar->icon_size + sysbar->area.paddingx;
 			else {
 				posy = start;
-				posx += (icon_size + systray.area.paddingx);
+				posx += (sysbar->icon_size + systray.area.paddingx);
 			}
 		}
 		else {
-			if (i % icons_per_row)
-				posx += icon_size + systray.area.paddingx;
+			if (i % sysbar->icons_per_row)
+				posx += sysbar->icon_size + systray.area.paddingx;
 			else {
 				posx = start;
-				posy += (icon_size + systray.area.paddingx);
+				posy += (sysbar->icon_size + systray.area.paddingx);
 			}
 		}
 
 		// position and size the icon window
-		XMoveResizeWindow(server.dsp, traywin->id, traywin->x, traywin->y, icon_size, icon_size);
-		XResizeWindow(server.dsp, traywin->tray_id, icon_size, icon_size);
+		XMoveResizeWindow(server.dsp, traywin->id, traywin->x, traywin->y, sysbar->icon_size, sysbar->icon_size);
+		XResizeWindow(server.dsp, traywin->tray_id, sysbar->icon_size, sysbar->icon_size);
 	}
-	// resize force the redraw
-	systray.area.redraw = 1;
 }
 
 
@@ -277,7 +261,7 @@
 
 	// v0.3 trayer specification. tint2 always horizontal.
 	// Vertical panel will draw the systray horizontal.
-	int orient = 0;
+	long orient = 0;
 	XChangeProperty(server.dsp, net_sel_win, server.atom._NET_SYSTEM_TRAY_ORIENTATION, XA_CARDINAL, 32, PropModeReplace, (unsigned char *) &orient, 1);
 	VisualID vid;
 	if (server.visual32 && (systray.alpha != 100 || systray.brightness != 0 || systray.saturation != 0))
@@ -373,9 +357,11 @@
 	if ( XGetWindowAttributes(server.dsp, id, &attr) == False ) return FALSE;
 	unsigned long mask = 0;
 	XSetWindowAttributes set_attr;
+	Visual* visual = server.visual;
 	//printf("icon with depth: %d, width %d, height %d\n", attr.depth, attr.width, attr.height);
-	printf("icon with depth: %d\n", attr.depth);
+	//printf("icon with depth: %d\n", attr.depth);
 	if (attr.depth != server.depth || systray.alpha != 100 || systray.brightness != 0 || systray.saturation != 0) {
+		visual = attr.visual;
 		set_attr.colormap = attr.colormap;
 		set_attr.background_pixel = 0;
 		set_attr.border_pixel = 0;
@@ -386,7 +372,7 @@
 		mask = CWBackPixmap;
 	}
 	Window parent_window;
-	parent_window = XCreateWindow(server.dsp, panel->main_win, 0, 0, 30, 30, 0, attr.depth, InputOutput, attr.visual, mask, &set_attr);
+	parent_window = XCreateWindow(server.dsp, panel->main_win, 0, 0, 30, 30, 0, attr.depth, InputOutput, visual, mask, &set_attr);
 	old = XSetErrorHandler(window_error_handler);
 	XReparentWindow(server.dsp, id, parent_window, 0, 0);
 	XSync(server.dsp, False);
@@ -443,13 +429,15 @@
 	traywin->depth = attr.depth;
 	traywin->damage = 0;
 
+	if (systray.area.on_screen == 0)
+		show(&systray.area);
+
 	if (systray.sort == 3)
 		systray.list_icons = g_slist_prepend(systray.list_icons, traywin);
 	else if (systray.sort == 2)
 		systray.list_icons = g_slist_append(systray.list_icons, traywin);
 	else
 		systray.list_icons = g_slist_insert_sorted(systray.list_icons, traywin, compare_traywindows);
-	systray.area.resize = 1;
 	//printf("add_icon id %lx, %d\n", id, g_slist_length(systray.list_icons));
 
 	// watch for the icon trying to resize itself!
@@ -465,8 +453,8 @@
 	if (!traywin->hide && !panel->is_hidden)
 		XMapRaised(server.dsp, traywin->id);
 
-	// changed in systray force resize on panel
-	panel->area.resize = 1;
+	// changed in systray
+	systray.area.resize = 1;
 	panel_refresh = 1;
 	return TRUE;
 }
@@ -478,7 +466,6 @@
 
 	// remove from our list
 	systray.list_icons = g_slist_remove(systray.list_icons, traywin);
-	systray.area.resize = 1;
 	//printf("remove_icon id %lx, %d\n", traywin->id);
 
 	XSelectInput(server.dsp, traywin->tray_id, NoEventMask);
@@ -498,9 +485,18 @@
 		stop_timeout(traywin->render_timeout);
 	g_free(traywin);
 
-	// changed in systray force resize on panel
-	Panel *panel = systray.area.panel;
-	panel->area.resize = 1;
+	// check empty systray
+	int count = 0;
+	GSList *l;
+	for (l = systray.list_icons; l ; l = l->next) {
+		if (!((TrayWindow*)l->data)->hide)
+			count++;
+	}
+	if (count == 0)
+		hide(&systray.area);
+		
+	// changed in systray
+	systray.area.resize = 1;
 	panel_refresh = 1;
 }
 
@@ -537,6 +533,11 @@
 	// we made also sure, that we always have a 32 bit visual, i.e. we can safely create 32 bit pixmaps here
 	TrayWindow* traywin = t;
 	traywin->render_timeout = 0;
+	if ( traywin->width == 0 || traywin->height == 0 ) {
+		// reschedule rendering since the geometry information has not yet been processed (can happen on slow cpu)
+		systray_render_icon(traywin);
+		return;
+	}
 
 	// good systray icons support 32 bit depth, but some icons are still 24 bit.
 	// We create a heuristic mask for these icons, i.e. we get the rgb value in the top left corner, and
diff -Nur tint2-0.11/src/systray/systraybar.h tint2-read-only/src/systray/systraybar.h
--- tint2-0.11/src/systray/systraybar.h	2010-04-18 21:28:45.000000000 +0700
+++ tint2-read-only/src/systray/systraybar.h	2010-12-23 00:02:32.319656009 +0600
@@ -28,6 +28,7 @@
 	GSList *list_icons;
 	int sort;
 	int alpha, saturation, brightness;
+	int icon_size, icons_per_column, icons_per_row, marging;
 } Systraybar;
 
 
@@ -63,7 +64,8 @@
 void init_systray_panel(void *p);
 
 void draw_systray(void *obj, cairo_t *c);
-void resize_systray(void *obj);
+int  resize_systray(void *obj);
+void on_change_systray(void *obj);
 
 
 // systray protocol
diff -Nur tint2-0.11/src/taskbar/taskbar.c tint2-read-only/src/taskbar/taskbar.c
--- tint2-0.11/src/taskbar/taskbar.c	2010-06-16 22:00:48.000000000 +0700
+++ tint2-read-only/src/taskbar/taskbar.c	2010-12-23 00:02:32.269452205 +0600
@@ -2,7 +2,7 @@
 *
 * Tint2 : taskbar
 *
-* Copyright (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr)
+* Copyright (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2
@@ -41,160 +41,37 @@
 
 Task *task_active;
 Task *task_drag;
+int taskbar_enabled;
 
 guint win_hash(gconstpointer key) { return (guint)*((Window*)key); }
 gboolean win_compare(gconstpointer a, gconstpointer b) { return (*((Window*)a) == *((Window*)b)); }
 void free_ptr_array(gpointer data) { g_ptr_array_free(data, 1); }
 
-void init_taskbar()
-{
-	Panel *panel;
-	int i, j;
-
-	if (win_to_task_table == 0)
-		win_to_task_table = g_hash_table_new_full(win_hash, win_compare, free, free_ptr_array);
-
-	task_active = 0;
-	task_drag = 0;
-
-	for (i=0 ; i < nb_panel ; i++) {
-		panel = &panel1[i];
-
-		if (panel->taskbar) {
-			free(panel->taskbar);
-			panel->taskbar = 0;
-		}
-
-		if (panel->g_taskbar.bg == 0) {
-			panel->g_taskbar.bg = &g_array_index(backgrounds, Background, 0);
-			panel->g_taskbar.area.bg = panel->g_taskbar.bg;
-		}
-		if (panel->g_taskbar.bg_active == 0)
-			panel->g_taskbar.bg_active = panel->g_taskbar.bg;
-		if (panel->g_task.area.bg == 0)
-			panel->g_task.area.bg = &g_array_index(backgrounds, Background, 0);
-
-		// taskbar
-		panel->g_taskbar.area._resize = resize_taskbar;
-		panel->g_taskbar.area.redraw = 1;
-		panel->g_taskbar.area.on_screen = 1;
-		if (panel_horizontal) {
-			panel->g_taskbar.area.posy = panel->area.bg->border.width + panel->area.paddingy;
-			panel->g_taskbar.area.height = panel->area.height - (2 * panel->g_taskbar.area.posy);
-		}
-		else {
-			panel->g_taskbar.area.posx = panel->area.bg->border.width + panel->area.paddingy;
-			panel->g_taskbar.area.width = panel->area.width - (2 * panel->g_taskbar.area.posx);
-		}
-
-		// task
-		panel->g_task.area._draw_foreground = draw_task;
-		panel->g_task.area.redraw = 1;
-		panel->g_task.area.on_screen = 1;
-		if ((panel->g_task.config_asb_mask & (1<<TASK_NORMAL)) == 0) {
-			panel->g_task.alpha[TASK_NORMAL] = 100;
-			panel->g_task.saturation[TASK_NORMAL] = 0;
-			panel->g_task.brightness[TASK_NORMAL] = 0;
-		}
-		if ((panel->g_task.config_asb_mask & (1<<TASK_ACTIVE)) == 0) {
-			panel->g_task.alpha[TASK_ACTIVE] = panel->g_task.alpha[TASK_NORMAL];
-			panel->g_task.saturation[TASK_ACTIVE] = panel->g_task.saturation[TASK_NORMAL];
-			panel->g_task.brightness[TASK_ACTIVE] = panel->g_task.brightness[TASK_NORMAL];
-		}
-		if ((panel->g_task.config_asb_mask & (1<<TASK_ICONIFIED)) == 0) {
-			panel->g_task.alpha[TASK_ICONIFIED] = panel->g_task.alpha[TASK_NORMAL];
-			panel->g_task.saturation[TASK_ICONIFIED] = panel->g_task.saturation[TASK_NORMAL];
-			panel->g_task.brightness[TASK_ICONIFIED] = panel->g_task.brightness[TASK_NORMAL];
-		}
-		if ((panel->g_task.config_asb_mask & (1<<TASK_URGENT)) == 0) {
-			panel->g_task.alpha[TASK_URGENT] = panel->g_task.alpha[TASK_ACTIVE];
-			panel->g_task.saturation[TASK_URGENT] = panel->g_task.saturation[TASK_ACTIVE];
-			panel->g_task.brightness[TASK_URGENT] = panel->g_task.brightness[TASK_ACTIVE];
-		}
-		if ((panel->g_task.config_font_mask & (1<<TASK_NORMAL)) == 0) panel->g_task.font[TASK_NORMAL] = (Color){{0, 0, 0}, 0};
-		if ((panel->g_task.config_font_mask & (1<<TASK_ACTIVE)) == 0) panel->g_task.font[TASK_ACTIVE] = panel->g_task.font[TASK_NORMAL];
-		if ((panel->g_task.config_font_mask & (1<<TASK_ICONIFIED)) == 0) panel->g_task.font[TASK_ICONIFIED] = panel->g_task.font[TASK_NORMAL];
-		if ((panel->g_task.config_font_mask & (1<<TASK_URGENT)) == 0) panel->g_task.font[TASK_URGENT] = panel->g_task.font[TASK_ACTIVE];
-		if ((panel->g_task.config_font_mask & (1<<TASK_NORMAL)) == 0) panel->g_task.background[TASK_NORMAL] = &g_array_index(backgrounds, Background, 0);
-		if ((panel->g_task.config_background_mask & (1<<TASK_ACTIVE)) == 0) panel->g_task.background[TASK_ACTIVE] = panel->g_task.background[TASK_NORMAL];
-		if ((panel->g_task.config_background_mask & (1<<TASK_ICONIFIED)) == 0) panel->g_task.background[TASK_ICONIFIED] = panel->g_task.background[TASK_NORMAL];
-		if ((panel->g_task.config_background_mask & (1<<TASK_URGENT)) == 0) panel->g_task.background[TASK_URGENT] = panel->g_task.background[TASK_ACTIVE];
-
-		if (panel_horizontal) {
-			panel->g_task.area.posy = panel->g_taskbar.area.posy + panel->g_taskbar.bg->border.width + panel->g_taskbar.area.paddingy;
-			panel->g_task.area.height = panel->area.height - (2 * panel->g_task.area.posy);
-		}
-		else {
-			panel->g_task.area.posx = panel->g_taskbar.area.posx + panel->g_taskbar.bg->border.width + panel->g_taskbar.area.paddingy;
-			panel->g_task.area.width = panel->area.width - (2 * panel->g_task.area.posx);
-			panel->g_task.area.height = panel->g_task.maximum_height;
-		}
-
-		int k;
-		for (k=0; k<TASK_STATE_COUNT; ++k) {
-			if (panel->g_task.background[k]->border.rounded > panel->g_task.area.height/2) {
-				printf("task%sbackground_id has a too large rounded value. Please fix your tint2rc\n", k==0 ? "_" : k==1 ? "_active_" : k==2 ? "_iconified_" : "_urgent_");
-				g_array_append_val(backgrounds, *panel->g_task.background[k]);
-				panel->g_task.background[k] = &g_array_index(backgrounds, Background, backgrounds->len-1);
-				panel->g_task.background[k]->border.rounded = panel->g_task.area.height/2;
-			}
-		}
-
-		// compute vertical position : text and icon
-		int height_ink, height;
-		get_text_size(panel->g_task.font_desc, &height_ink, &height, panel->area.height, "TAjpg", 5);
-
-		if (!panel->g_task.maximum_width && panel_horizontal)
-			panel->g_task.maximum_width = server.monitor[panel->monitor].width;
-
-		panel->g_task.text_posx = panel->g_task.background[0]->border.width + panel->g_task.area.paddingxlr;
-		panel->g_task.text_height = panel->g_task.area.height - (2 * panel->g_task.area.paddingy);
-		if (panel->g_task.icon) {
-			panel->g_task.icon_size1 = panel->g_task.area.height - (2 * panel->g_task.area.paddingy);
-			panel->g_task.text_posx += panel->g_task.icon_size1;
-			panel->g_task.icon_posy = (panel->g_task.area.height - panel->g_task.icon_size1) / 2;
-		}
-		//printf("monitor %d, task_maximum_width %d\n", panel->monitor, panel->g_task.maximum_width);
-
-		Taskbar *tskbar;
-		panel->nb_desktop = server.nb_desktop;
-		panel->taskbar = calloc(panel->nb_desktop, sizeof(Taskbar));
-		for (j=0 ; j < panel->nb_desktop ; j++) {
-			tskbar = &panel->taskbar[j];
-			memcpy(&tskbar->area, &panel->g_taskbar, sizeof(Area));
-			tskbar->desktop = j;
-			if (j == server.desktop && panel->g_taskbar.use_active)
-				tskbar->area.bg = panel->g_taskbar.bg_active;
-
-			// add taskbar to the panel
-			panel->area.list = g_slist_append(panel->area.list, tskbar);
-		}
-	}
-}
-
-void taskbar_remove_task(gpointer key, gpointer value, gpointer user_data)
-{
-	remove_task(task_get_task(*(Window*)key));
-}
 
 void default_taskbar()
 {
 	win_to_task_table = 0;
 	urgent_timeout = 0;
 	urgent_list = 0;
+	taskbar_enabled = 0;
+	default_taskbarname();
 }
 
 void cleanup_taskbar()
 {
 	Panel *panel;
 	Taskbar *tskbar;
-	int i, j;
+	int i, j, k;
 
+	cleanup_taskbarname();
 	if (win_to_task_table) g_hash_table_foreach(win_to_task_table, taskbar_remove_task, 0);
 	for (i=0 ; i < nb_panel ; i++) {
 		panel = &panel1[i];
 		for (j=0 ; j < panel->nb_desktop ; j++) {
 			tskbar = &panel->taskbar[j];
+			for (k=0; k<TASKBAR_STATE_COUNT; ++k) {
+				if (tskbar->state_pix[k]) XFreePixmap(server.dsp, tskbar->state_pix[k]);
+			}
 			free_area (&tskbar->area);
 			// remove taskbar from the panel
 			panel->area.list = g_slist_remove(panel->area.list, tskbar);
@@ -212,6 +89,156 @@
 }
 
 
+void init_taskbar()
+{
+	if (win_to_task_table == 0)
+		win_to_task_table = g_hash_table_new_full(win_hash, win_compare, free, free_ptr_array);
+
+	task_active = 0;
+	task_drag = 0;
+}
+
+
+void init_taskbar_panel(void *p)
+{
+	Panel *panel =(Panel*)p;
+	int j;
+
+	if (panel->g_taskbar.background[TASKBAR_NORMAL] == 0) {
+		panel->g_taskbar.background[TASKBAR_NORMAL] = &g_array_index(backgrounds, Background, 0);
+		panel->g_taskbar.background[TASKBAR_ACTIVE] = &g_array_index(backgrounds, Background, 0);
+	}
+	if (panel->g_taskbar.background_name[TASKBAR_NORMAL] == 0) {
+		panel->g_taskbar.background_name[TASKBAR_NORMAL] = &g_array_index(backgrounds, Background, 0);
+		panel->g_taskbar.background_name[TASKBAR_ACTIVE] = &g_array_index(backgrounds, Background, 0);
+	}
+	if (panel->g_task.area.bg == 0)
+		panel->g_task.area.bg = &g_array_index(backgrounds, Background, 0);
+
+	// taskbar name
+	panel->g_taskbar.area_name.panel = panel;
+	panel->g_taskbar.area_name.size_mode = SIZE_BY_CONTENT;
+	panel->g_taskbar.area_name._resize = resize_taskbarname;
+	panel->g_taskbar.area_name._draw_foreground = draw_taskbarname;
+	panel->g_taskbar.area_name._on_change_layout = 0;
+	panel->g_taskbar.area_name.resize = 1;
+	panel->g_taskbar.area_name.on_screen = 1;
+
+	// taskbar
+	panel->g_taskbar.area.parent = panel;
+	panel->g_taskbar.area.panel = panel;
+	panel->g_taskbar.area.size_mode = SIZE_BY_LAYOUT;
+	panel->g_taskbar.area._resize = resize_taskbar;
+	panel->g_taskbar.area._draw_foreground = draw_taskbar;
+	panel->g_taskbar.area._on_change_layout = on_change_taskbar;
+	panel->g_taskbar.area.resize = 1;
+	panel->g_taskbar.area.on_screen = 1;
+	if (panel_horizontal) {
+		panel->g_taskbar.area.posy = panel->area.bg->border.width + panel->area.paddingy;
+		panel->g_taskbar.area.height = panel->area.height - (2 * panel->g_taskbar.area.posy);
+		panel->g_taskbar.area_name.posy = panel->g_taskbar.area.posy;
+		panel->g_taskbar.area_name.height = panel->g_taskbar.area.height;
+	}
+	else {
+		panel->g_taskbar.area.posx = panel->area.bg->border.width + panel->area.paddingy;
+		panel->g_taskbar.area.width = panel->area.width - (2 * panel->g_taskbar.area.posx);
+		panel->g_taskbar.area_name.posx = panel->g_taskbar.area.posx;
+		panel->g_taskbar.area_name.width = panel->g_taskbar.area.width;
+	}
+
+	// task
+	panel->g_task.area.panel = panel;
+	panel->g_task.area.size_mode = SIZE_BY_LAYOUT;
+	panel->g_task.area._draw_foreground = draw_task;
+	panel->g_task.area._on_change_layout = on_change_task;
+	panel->g_task.area.resize = 1;
+	panel->g_task.area.on_screen = 1;
+	if ((panel->g_task.config_asb_mask & (1<<TASK_NORMAL)) == 0) {
+		panel->g_task.alpha[TASK_NORMAL] = 100;
+		panel->g_task.saturation[TASK_NORMAL] = 0;
+		panel->g_task.brightness[TASK_NORMAL] = 0;
+	}
+	if ((panel->g_task.config_asb_mask & (1<<TASK_ACTIVE)) == 0) {
+		panel->g_task.alpha[TASK_ACTIVE] = panel->g_task.alpha[TASK_NORMAL];
+		panel->g_task.saturation[TASK_ACTIVE] = panel->g_task.saturation[TASK_NORMAL];
+		panel->g_task.brightness[TASK_ACTIVE] = panel->g_task.brightness[TASK_NORMAL];
+	}
+	if ((panel->g_task.config_asb_mask & (1<<TASK_ICONIFIED)) == 0) {
+		panel->g_task.alpha[TASK_ICONIFIED] = panel->g_task.alpha[TASK_NORMAL];
+		panel->g_task.saturation[TASK_ICONIFIED] = panel->g_task.saturation[TASK_NORMAL];
+		panel->g_task.brightness[TASK_ICONIFIED] = panel->g_task.brightness[TASK_NORMAL];
+	}
+	if ((panel->g_task.config_asb_mask & (1<<TASK_URGENT)) == 0) {
+		panel->g_task.alpha[TASK_URGENT] = panel->g_task.alpha[TASK_ACTIVE];
+		panel->g_task.saturation[TASK_URGENT] = panel->g_task.saturation[TASK_ACTIVE];
+		panel->g_task.brightness[TASK_URGENT] = panel->g_task.brightness[TASK_ACTIVE];
+	}
+	if ((panel->g_task.config_font_mask & (1<<TASK_NORMAL)) == 0) panel->g_task.font[TASK_NORMAL] = (Color){{0, 0, 0}, 0};
+	if ((panel->g_task.config_font_mask & (1<<TASK_ACTIVE)) == 0) panel->g_task.font[TASK_ACTIVE] = panel->g_task.font[TASK_NORMAL];
+	if ((panel->g_task.config_font_mask & (1<<TASK_ICONIFIED)) == 0) panel->g_task.font[TASK_ICONIFIED] = panel->g_task.font[TASK_NORMAL];
+	if ((panel->g_task.config_font_mask & (1<<TASK_URGENT)) == 0) panel->g_task.font[TASK_URGENT] = panel->g_task.font[TASK_ACTIVE];
+	if ((panel->g_task.config_font_mask & (1<<TASK_NORMAL)) == 0) panel->g_task.background[TASK_NORMAL] = &g_array_index(backgrounds, Background, 0);
+	if ((panel->g_task.config_background_mask & (1<<TASK_ACTIVE)) == 0) panel->g_task.background[TASK_ACTIVE] = panel->g_task.background[TASK_NORMAL];
+	if ((panel->g_task.config_background_mask & (1<<TASK_ICONIFIED)) == 0) panel->g_task.background[TASK_ICONIFIED] = panel->g_task.background[TASK_NORMAL];
+	if ((panel->g_task.config_background_mask & (1<<TASK_URGENT)) == 0) panel->g_task.background[TASK_URGENT] = panel->g_task.background[TASK_ACTIVE];
+
+	if (panel_horizontal) {
+		panel->g_task.area.posy = panel->g_taskbar.area.posy + panel->g_taskbar.background[TASKBAR_NORMAL]->border.width + panel->g_taskbar.area.paddingy;
+		panel->g_task.area.height = panel->area.height - (2 * panel->g_task.area.posy);
+	}
+	else {
+		panel->g_task.area.posx = panel->g_taskbar.area.posx + panel->g_taskbar.background[TASKBAR_NORMAL]->border.width + panel->g_taskbar.area.paddingy;
+		panel->g_task.area.width = panel->area.width - (2 * panel->g_task.area.posx);
+		panel->g_task.area.height = panel->g_task.maximum_height;
+	}
+
+	for (j=0; j<TASK_STATE_COUNT; ++j) {
+		if (panel->g_task.background[j]->border.rounded > panel->g_task.area.height/2) {
+			printf("task%sbackground_id has a too large rounded value. Please fix your tint2rc\n", j==0 ? "_" : j==1 ? "_active_" : j==2 ? "_iconified_" : "_urgent_");
+			g_array_append_val(backgrounds, *panel->g_task.background[j]);
+			panel->g_task.background[j] = &g_array_index(backgrounds, Background, backgrounds->len-1);
+			panel->g_task.background[j]->border.rounded = panel->g_task.area.height/2;
+		}
+	}
+
+	// compute vertical position : text and icon
+	int height_ink, height;
+	get_text_size(panel->g_task.font_desc, &height_ink, &height, panel->area.height, "TAjpg", 5);
+
+	if (!panel->g_task.maximum_width && panel_horizontal)
+		panel->g_task.maximum_width = server.monitor[panel->monitor].width;
+
+	panel->g_task.text_posx = panel->g_task.background[0]->border.width + panel->g_task.area.paddingxlr;
+	panel->g_task.text_height = panel->g_task.area.height - (2 * panel->g_task.area.paddingy);
+	if (panel->g_task.icon) {
+		panel->g_task.icon_size1 = panel->g_task.area.height - (2 * panel->g_task.area.paddingy);
+		panel->g_task.text_posx += panel->g_task.icon_size1;
+		panel->g_task.icon_posy = (panel->g_task.area.height - panel->g_task.icon_size1) / 2;
+	}
+	//printf("monitor %d, task_maximum_width %d\n", panel->monitor, panel->g_task.maximum_width);
+
+	Taskbar *tskbar;
+	panel->nb_desktop = server.nb_desktop;
+	panel->taskbar = calloc(server.nb_desktop, sizeof(Taskbar));
+	for (j=0 ; j < panel->nb_desktop ; j++) {
+		tskbar = &panel->taskbar[j];
+		memcpy(&tskbar->area, &panel->g_taskbar.area, sizeof(Area));
+		tskbar->desktop = j;
+		if (j == server.desktop)
+			tskbar->area.bg = panel->g_taskbar.background[TASKBAR_ACTIVE];
+		else
+			tskbar->area.bg = panel->g_taskbar.background[TASKBAR_NORMAL];
+	}
+	init_taskbarname_panel(panel);
+}
+
+
+void taskbar_remove_task(gpointer key, gpointer value, gpointer user_data)
+{
+	remove_task(task_get_task(*(Window*)key));
+}
+
+
 Task *task_get_task (Window win)
 {
 	GPtrArray* task_group = task_get_tasks(win);
@@ -224,7 +251,7 @@
 
 GPtrArray* task_get_tasks(Window win)
 {
-	if (win_to_task_table)
+	if (win_to_task_table && taskbar_enabled)
 		return g_hash_table_lookup(win_to_task_table, &win);
 	else
 		return 0;
@@ -236,6 +263,7 @@
 	Window *win;
 	int num_results, i;
 
+	if (!taskbar_enabled) return;
 	win = server_get_property (server.root_win, server.atom._NET_CLIENT_LIST, XA_WINDOW, &num_results);
 	if (!win) return;
 
@@ -259,99 +287,103 @@
 }
 
 
-void resize_taskbar(void *obj)
+void draw_taskbar (void *obj, cairo_t *c)
 {
-	Taskbar *taskbar = (Taskbar*)obj;
-	Panel *panel = (Panel*)taskbar->area.panel;
-	Task *tsk;
-	GSList *l;
-	int  task_count, border_width;
+	Taskbar *taskbar = obj;
+	int state = (taskbar->desktop == server.desktop) ? TASKBAR_ACTIVE : TASKBAR_NORMAL;
+	
+	taskbar->state_pix[state] = taskbar->area.pix;
+}
 
-	//printf("resize_taskbar : posx et width des taches\n");
-	taskbar->area.redraw = 1;
 
-	border_width = taskbar->area.bg->border.width;
+int resize_taskbar(void *obj)
+{
+	Taskbar *taskbar = (Taskbar*)obj;
+	Panel *panel = (Panel*)taskbar->area.panel;
+	int text_width;
 
+	//printf("resize_taskbar %d %d\n", taskbar->area.posx, taskbar->area.posy);
 	if (panel_horizontal) {
-		int  pixel_width, modulo_width=0;
-		int  x, taskbar_width;
-
-		// new task width for 'desktop'
-		task_count = g_slist_length(taskbar->area.list);
-		if (!task_count) pixel_width = panel->g_task.maximum_width;
-		else {
-			taskbar_width = taskbar->area.width - (2 * border_width) - (2 * panel->g_taskbar.area.paddingxlr);
-			if (task_count>1) taskbar_width -= ((task_count-1) * panel->g_taskbar.area.paddingx);
-
-			pixel_width = taskbar_width / task_count;
-			if (pixel_width > panel->g_task.maximum_width)
-				pixel_width = panel->g_task.maximum_width;
-			else
-				modulo_width = taskbar_width % task_count;
+		resize_by_layout(obj, panel->g_task.maximum_width);
+		
+		text_width = panel->g_task.maximum_width;
+		GSList *l = taskbar->area.list;
+		if (taskbarname_enabled) l = l->next;
+		if (l != NULL) {
+			text_width = ((Task *)l->data)->area.width;
 		}
+		taskbar->text_width = text_width - panel->g_task.text_posx - panel->g_task.area.bg->border.width - panel->g_task.area.paddingx;
+	}
+	else {
+		resize_by_layout(obj, panel->g_task.maximum_height);
+		
+		taskbar->text_width = taskbar->area.width - (2 * panel->g_taskbar.area.paddingy) - panel->g_task.text_posx -	panel->g_task.area.bg->border.width - panel->g_task.area.paddingx;
+	}
+	return 0;
+}
 
-		taskbar->task_width = pixel_width;
-		taskbar->task_modulo = modulo_width;
-		taskbar->text_width = pixel_width - panel->g_task.text_posx - panel->g_task.area.bg->border.width - panel->g_task.area.paddingx;
-
-		// change pos_x and width for all tasks
-		x = taskbar->area.posx + border_width + taskbar->area.paddingxlr;
-		for (l = taskbar->area.list; l ; l = l->next) {
-			tsk = l->data;
-			if (!tsk->area.on_screen) continue;
-			tsk->area.posx = x;
-			set_task_redraw(tsk);  // always redraw task, because the background could have changed (taskbar_active_id)
-			tsk->area.width = pixel_width;
-			long value[] = { panel->posx+x, panel->posy, pixel_width, panel->area.height };
-			XChangeProperty (server.dsp, tsk->win, server.atom._NET_WM_ICON_GEOMETRY, XA_CARDINAL, 32, PropModeReplace, (unsigned char*)value, 4);
-
-			if (modulo_width) {
-				tsk->area.width++;
-				modulo_width--;
-			}
 
-			x += tsk->area.width + panel->g_taskbar.area.paddingx;
-		}
+void on_change_taskbar (void *obj)
+{
+	Taskbar *tskbar = obj;
+	int k;
+
+	// reset Pixmap when position/size changed
+	for (k=0; k<TASKBAR_STATE_COUNT; ++k) {
+		if (tskbar->state_pix[k]) XFreePixmap(server.dsp, tskbar->state_pix[k]);
+		tskbar->state_pix[k] = 0;
 	}
-	else {
-		int  pixel_height, modulo_height=0;
-		int  y, taskbar_height;
+	tskbar->area.pix = 0;
+	tskbar->area.redraw = 1;
+}
 
-		// new task width for 'desktop'
-		task_count = g_slist_length(taskbar->area.list);
-		if (!task_count) pixel_height = panel->g_task.maximum_height;
-		else {
-			taskbar_height = taskbar->area.height - (2 * border_width) - (2 * panel->g_taskbar.area.paddingxlr);
-			if (task_count>1) taskbar_height -= ((task_count-1) * panel->g_taskbar.area.paddingx);
 
-			pixel_height = taskbar_height / task_count;
-			if (pixel_height > panel->g_task.maximum_height)
-				pixel_height = panel->g_task.maximum_height;
-			else
-				modulo_height = taskbar_height % task_count;
+void set_taskbar_state(Taskbar *tskbar, int state)
+{
+	tskbar->area.bg = panel1[0].g_taskbar.background[state];
+	tskbar->area.pix = tskbar->state_pix[state];
+	if (taskbarname_enabled) {
+		tskbar->bar_name.area.bg = panel1[0].g_taskbar.background_name[state];
+		tskbar->bar_name.area.pix = tskbar->bar_name.state_pix[state];
+	}
+	if (panel_mode != MULTI_DESKTOP) { 
+		if (state == TASKBAR_NORMAL)
+			tskbar->area.on_screen = 0;
+		else
+			tskbar->area.on_screen = 1;
+	}
+	if (tskbar->area.on_screen == 1) {
+		if (tskbar->state_pix[state] == 0)
+			tskbar->area.redraw = 1;
+		if (taskbarname_enabled && tskbar->bar_name.state_pix[state] == 0)
+			tskbar->bar_name.area.redraw = 1;
+		if (panel_mode == MULTI_DESKTOP && panel1[0].g_taskbar.background[TASKBAR_NORMAL] != panel1[0].g_taskbar.background[TASKBAR_ACTIVE]) {
+			GSList *l = tskbar->area.list;
+			if (taskbarname_enabled) l = l->next;
+			for ( ; l ; l = l->next)
+				set_task_redraw(l->data);
 		}
+	}
+	panel_refresh = 1;
+}
 
-		taskbar->task_width = pixel_height;
-		taskbar->task_modulo = modulo_height;
-		taskbar->text_width = taskbar->area.width - (2 * panel->g_taskbar.area.paddingy) - panel->g_task.text_posx - panel->g_task.area.bg->border.width - panel->g_task.area.paddingx;
-
-		// change pos_y and height for all tasks
-		y = taskbar->area.posy + border_width + taskbar->area.paddingxlr;
-		for (l = taskbar->area.list; l ; l = l->next) {
-			tsk = l->data;
-			if (!tsk->area.on_screen) continue;
-			tsk->area.posy = y;
-			set_task_redraw(tsk);  // always redraw task, because the background could have changed (taskbar_active_id)
-			tsk->area.height = pixel_height;
-			long value[] = { panel->posx, panel->posy+y, panel->area.width, pixel_height };
-			XChangeProperty (server.dsp, tsk->win, server.atom._NET_WM_ICON_GEOMETRY, XA_CARDINAL, 32, PropModeReplace, (unsigned char*)value, 4);
-
-			if (modulo_height) {
-				tsk->area.height++;
-				modulo_height--;
-			}
 
-			y += tsk->area.height + panel->g_taskbar.area.paddingx;
+void visible_taskbar(void *p)
+{
+	Panel *panel =(Panel*)p;
+	int j;
+
+	Taskbar *taskbar;
+	for (j=0 ; j < panel->nb_desktop ; j++) {
+		taskbar = &panel->taskbar[j];
+		if (panel_mode != MULTI_DESKTOP && taskbar->desktop != server.desktop) {
+			// SINGLE_DESKTOP and not current desktop
+			taskbar->area.on_screen = 0;
+		}
+		else {
+			taskbar->area.on_screen = 1;
 		}
 	}
+	panel_refresh = 1;
 }
+
diff -Nur tint2-0.11/src/taskbar/taskbar.h tint2-read-only/src/taskbar/taskbar.h
--- tint2-0.11/src/taskbar/taskbar.h	2010-04-23 21:37:39.000000000 +0700
+++ tint2-read-only/src/taskbar/taskbar.h	2010-12-23 00:02:32.269452205 +0600
@@ -9,10 +9,23 @@
 #define TASKBAR_H
 
 #include "task.h"
+#include "taskbarname.h"
 
+enum { TASKBAR_NORMAL, TASKBAR_ACTIVE, TASKBAR_STATE_COUNT };
 extern GHashTable* win_to_task_table;
 extern Task *task_active;
 extern Task *task_drag;
+extern int taskbar_enabled;
+
+
+typedef struct {
+	// always start with area
+	Area area;
+	Pixmap state_pix[TASKBAR_STATE_COUNT];
+
+	char *name;
+	int  posy;
+} Taskbarname;
 
 // tint2 use one taskbar per desktop.
 typedef struct {
@@ -20,20 +33,20 @@
 	Area area;
 
 	int desktop;
+	Pixmap state_pix[TASKBAR_STATE_COUNT];
 
+	Taskbarname bar_name;
+	
 	// task parameters
-	int task_width;
-	int task_modulo;
 	int text_width;
 } Taskbar;
 
-
 typedef struct {
 	//always start with area
 	Area area;
-	Background* bg;
-	Background* bg_active;
-	int use_active;
+	Area area_name;
+	Background* background[TASKBAR_STATE_COUNT];
+	Background* background_name[TASKBAR_STATE_COUNT];
 } Global_taskbar;
 
 
@@ -44,12 +57,20 @@
 void cleanup_taskbar();
 
 void init_taskbar();
+void init_taskbar_panel(void *p);
 
+void draw_taskbar (void *obj, cairo_t *c);
+void taskbar_remove_task(gpointer key, gpointer value, gpointer user_data);
 Task *task_get_task (Window win);
 GPtrArray* task_get_tasks(Window win);
 void task_refresh_tasklist ();
 
-void resize_taskbar(void *obj);
+int  resize_taskbar(void *obj);
+void on_change_taskbar (void *obj);
+void set_taskbar_state(Taskbar *tskbar, int state);
+
+// show/hide taskbar according to current desktop
+void visible_taskbar(void *p);
 
 
 #endif
diff -Nur tint2-0.11/src/taskbar/taskbarname.c tint2-read-only/src/taskbar/taskbarname.c
--- tint2-0.11/src/taskbar/taskbarname.c	1970-01-01 07:00:00.000000000 +0700
+++ tint2-read-only/src/taskbar/taskbarname.c	2010-12-23 00:02:32.269452205 +0600
@@ -0,0 +1,161 @@
+/**************************************************************************
+*
+* Tint2 : taskbarname
+*
+* Copyright (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version 2
+* as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+**************************************************************************/
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/Xatom.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <glib.h>
+#include <Imlib2.h>
+
+#include "window.h"
+#include "panel.h"
+#include "taskbar.h"
+#include "server.h"
+#include "taskbarname.h"
+
+int taskbarname_enabled;
+PangoFontDescription *taskbarname_font_desc;
+Color taskbarname_font;
+Color taskbarname_active_font;
+
+
+void default_taskbarname()
+{
+	taskbarname_enabled = 0;
+	taskbarname_font_desc = 0;
+}
+
+
+void init_taskbarname_panel(void *p)
+{
+	Panel *panel =(Panel*)p;
+	Taskbar *tskbar;
+	int j;
+	
+	if (!taskbarname_enabled) return;
+	
+	GSList *l, *list = server_get_name_of_desktop();
+	for (j=0, l=list ; j < panel->nb_desktop ; j++) {
+		tskbar = &panel->taskbar[j];
+		memcpy(&tskbar->bar_name.area, &panel->g_taskbar.area_name, sizeof(Area));
+		tskbar->bar_name.area.parent = tskbar;
+		if (j == server.desktop)
+			tskbar->bar_name.area.bg = panel->g_taskbar.background_name[TASKBAR_ACTIVE];
+		else
+			tskbar->bar_name.area.bg = panel->g_taskbar.background_name[TASKBAR_NORMAL];
+
+		// use desktop number if name is missing
+		if (l) {
+			tskbar->bar_name.name = g_strdup(l->data);
+			l = l->next;
+		}
+		else
+			tskbar->bar_name.name = g_strdup_printf("%d", j+1);
+		
+		// append the name at the beginning of taskbar
+		tskbar->area.list = g_slist_append(tskbar->area.list, &tskbar->bar_name);
+	}
+
+	for (l=list ; l ; l = l->next)
+		g_free(l->data);
+	g_slist_free(list);
+}
+
+
+void cleanup_taskbarname()
+{
+	int i, j, k;
+	Panel *panel;
+	Taskbar *tskbar;
+
+	for (i=0 ; i < nb_panel ; i++) {
+		panel = &panel1[i];
+		for (j=0 ; j < panel->nb_desktop ; j++) {
+			tskbar = &panel->taskbar[j];
+			if (tskbar->bar_name.name)	g_free(tskbar->bar_name.name);
+			free_area (&tskbar->bar_name.area);
+			for (k=0; k<TASKBAR_STATE_COUNT; ++k) {
+				if (tskbar->bar_name.state_pix[k]) XFreePixmap(server.dsp, tskbar->bar_name.state_pix[k]);
+			}
+			tskbar->area.list = g_slist_remove(tskbar->area.list, &tskbar->bar_name);
+		}
+	}
+}
+
+
+void draw_taskbarname (void *obj, cairo_t *c)
+{
+	Taskbarname *taskbar_name = obj;
+	Taskbar *taskbar = taskbar_name->area.parent;
+	PangoLayout *layout;
+	Color *config_text = (taskbar->desktop == server.desktop) ? &taskbarname_active_font : &taskbarname_font;
+
+	int state = (taskbar->desktop == server.desktop) ? TASKBAR_ACTIVE : TASKBAR_NORMAL;
+	taskbar_name->state_pix[state] = taskbar_name->area.pix;
+	
+	// draw content
+	layout = pango_cairo_create_layout (c);
+	pango_layout_set_font_description (layout, taskbarname_font_desc);
+	pango_layout_set_width (layout, taskbar_name->area.width * PANGO_SCALE);
+	pango_layout_set_alignment (layout, PANGO_ALIGN_CENTER);
+	pango_layout_set_text (layout, taskbar_name->name, strlen(taskbar_name->name));
+
+	cairo_set_source_rgba (c, config_text->color[0], config_text->color[1], config_text->color[2], config_text->alpha);
+
+	pango_cairo_update_layout (c, layout);
+	cairo_move_to (c, 0, taskbar_name->posy);
+	pango_cairo_show_layout (c, layout);
+
+	g_object_unref (layout);
+	//printf("draw_taskbarname %s ******************************\n", taskbar_name->name);
+}
+
+
+int resize_taskbarname(void *obj)
+{
+	Taskbarname *taskbar_name = obj;
+	Panel *panel = taskbar_name->area.panel;
+	int name_height, name_width, name_height_ink;
+	int ret = 0;
+
+	taskbar_name->area.redraw = 1;
+	get_text_size2(taskbarname_font_desc, &name_height_ink, &name_height, &name_width, panel->area.height, panel->area.width, taskbar_name->name, strlen(taskbar_name->name));
+
+	if (panel_horizontal) {
+		int new_size = name_width + (2* (taskbar_name->area.paddingxlr + taskbar_name->area.bg->border.width));
+		if (new_size != taskbar_name->area.width) {
+			taskbar_name->area.width = new_size;
+			taskbar_name->posy = (taskbar_name->area.height - name_height) / 2;
+			ret = 1;
+		}
+	}
+	else {
+		int new_size = name_height + (2 * (taskbar_name->area.paddingxlr + taskbar_name->area.bg->border.width));
+		if (new_size != taskbar_name->area.height) {
+			taskbar_name->area.height =  new_size;
+			taskbar_name->posy = (taskbar_name->area.height - name_height) / 2;
+			ret = 1;
+		}
+	}
+	return ret;
+}
+
diff -Nur tint2-0.11/src/taskbar/taskbarname.h tint2-read-only/src/taskbar/taskbarname.h
--- tint2-0.11/src/taskbar/taskbarname.h	1970-01-01 07:00:00.000000000 +0700
+++ tint2-read-only/src/taskbar/taskbarname.h	2010-12-23 00:02:32.269452205 +0600
@@ -0,0 +1,27 @@
+/**************************************************************************
+* Copyright (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr)
+**************************************************************************/
+
+#ifndef TASKBARNAME_H
+#define TASKBARNAME_H
+
+#include "common.h"
+#include "area.h"
+
+extern int taskbarname_enabled;
+extern PangoFontDescription *taskbarname_font_desc;
+extern Color taskbarname_font;
+extern Color taskbarname_active_font;
+
+void default_taskbarname();
+void cleanup_taskbarname();
+
+void init_taskbarname_panel(void *p);
+
+void draw_taskbarname(void *obj, cairo_t *c);
+
+int  resize_taskbarname(void *obj);
+
+
+#endif
+
diff -Nur tint2-0.11/src/taskbar/task.c tint2-read-only/src/taskbar/task.c
--- tint2-0.11/src/taskbar/task.c	2010-04-20 05:06:23.000000000 +0700
+++ tint2-read-only/src/taskbar/task.c	2010-12-23 00:02:32.269452205 +0600
@@ -3,7 +3,7 @@
 * Tint2 : task
 *
 * Copyright (C) 2007 Pål Staurland (staura@gmail.com)
-* Modified (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr)
+* Modified (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2
@@ -96,7 +96,8 @@
 			new_tsk2->area.on_screen = 0;
 		}
 		new_tsk2->title = new_tsk.title;
-		new_tsk2->area._get_tooltip_text = task_get_tooltip;
+		if (panel1[monitor].g_task.tooltip_enabled)
+			new_tsk2->area._get_tooltip_text = task_get_tooltip;
 		for (k=0; k<TASK_STATE_COUNT; ++k) {
 			new_tsk2->icon[k] = new_tsk.icon[k];
 			new_tsk2->state_pix[k] = 0;
@@ -159,12 +160,12 @@
 }
 
 
-void get_title(Task *tsk)
+int get_title(Task *tsk)
 {
 	Panel *panel = tsk->area.panel;
 	char *title, *name;
 
-	if (!panel->g_task.text && !g_tooltip.enabled) return;
+	if (!panel->g_task.text && !panel->g_task.tooltip_enabled) return 0;
 
 	name = server_get_property (tsk->win, server.atom._NET_WM_VISIBLE_NAME, server.atom.UTF8_STRING, 0);
 	if (!name || !strlen(name)) {
@@ -184,9 +185,16 @@
 	else title[0] = 0;
 	strcat(title, name);
 	if (name) XFree (name);
-
-	if (tsk->title)
-		free(tsk->title);
+	
+	if (tsk->title) {
+		// check unecessary title change
+		if (strcmp(tsk->title, title) == 0) {
+			free(title);
+			return 0;
+		}
+		else
+			free(tsk->title);
+	} 
 
 	tsk->title = title;
 	GPtrArray* task_group = task_get_tasks(tsk->win);
@@ -198,7 +206,7 @@
 			set_task_redraw(tsk2);
 		}
 	}
-	set_task_redraw(tsk);
+	return 1;
 }
 
 
@@ -209,7 +217,7 @@
 	int i;
 	Imlib_Image img = NULL;
 	XWMHints *hints = 0;
-	long *data = 0;
+	gulong *data = 0;
 
 	int k;
 	for (k=0; k<TASK_STATE_COUNT; ++k) {
@@ -224,10 +232,9 @@
 	if (data) {
 		// get ARGB icon
 		int w, h;
-		long *tmp_data;
+		gulong *tmp_data;
 
 		tmp_data = get_best_icon (data, get_icon_count (data, i), i, &w, &h, panel->g_task.icon_size1);
-
 #ifdef __x86_64__
 		DATA32 icon_data[w * h];
 		int length = w * h;
@@ -304,7 +311,6 @@
 			set_task_redraw(tsk2);
 		}
 	}
-	set_task_redraw(tsk);
 }
 
 
@@ -343,6 +349,7 @@
 	Color *config_text;
 	int width=0, height;
 	Panel *panel = (Panel*)tsk->area.panel;
+	//printf("draw_task %d %d\n", tsk->area.posx, tsk->area.posy);
 
 	if (panel->g_task.text) {
 		/* Layout */
@@ -386,6 +393,19 @@
 }
 
 
+void on_change_task (void *obj)
+{
+	Task *tsk = obj;
+	Panel *panel = (Panel*)tsk->area.panel;
+
+	long value[] = { panel->posx+tsk->area.posx, panel->posy+tsk->area.posy, tsk->area.width, tsk->area.height };
+	XChangeProperty (server.dsp, tsk->win, server.atom._NET_WM_ICON_GEOMETRY, XA_CARDINAL, 32, PropModeReplace, (unsigned char*)value, 4);
+	
+	// reset Pixmap when position/size changed
+	set_task_redraw(tsk);
+}
+
+
 Task *next_task(Task *tsk)
 {
 	if (tsk == 0)
@@ -395,7 +415,9 @@
 	Task *tsk1;
 	Taskbar* tskbar = tsk->area.parent;
 
-	for (l0 = tskbar->area.list; l0 ; l0 = l0->next) {
+	l0 = tskbar->area.list;
+	if (taskbarname_enabled) l0 = l0->next;
+	for (; l0 ; l0 = l0->next) {
 		tsk1 = l0->data;
 		if (tsk1 == tsk) {
 			if (l0->next == 0) l0 = tskbar->area.list;
@@ -417,7 +439,9 @@
 	Taskbar* tskbar = tsk->area.parent;
 
 	tsk2 = 0;
-	for (l0 = tskbar->area.list; l0 ; l0 = l0->next) {
+	l0 = tskbar->area.list;
+	if (taskbarname_enabled) l0 = l0->next;
+	for (; l0 ; l0 = l0->next) {
 		tsk1 = l0->data;
 		if (tsk1 == tsk) {
 			if (l0 == tskbar->area.list) {
@@ -444,9 +468,11 @@
 	//printf("Change active task %ld\n", w1);
 
 	if (w1) {
-		Window w2;
-		if (XGetTransientForHint(server.dsp, w1, &w2) != 0)
-			if (w2 && !task_get_tasks(w1)) w1 = w2;
+		if (!task_get_tasks(w1)) {
+			Window w2;
+			while (XGetTransientForHint(server.dsp, w1, &w2))
+				w1 = w2;
+		}
 		set_task_state((task_active = task_get_task(w1)), TASK_ACTIVE);
 	}
 }
diff -Nur tint2-0.11/src/taskbar/task.h tint2-read-only/src/taskbar/task.h
--- tint2-0.11/src/taskbar/task.h	2010-04-20 04:44:40.000000000 +0700
+++ tint2-read-only/src/taskbar/task.h	2010-12-23 00:02:32.269452205 +0600
@@ -44,6 +44,7 @@
 	PangoFontDescription *font_desc;
 	Color font[TASK_STATE_COUNT];
 	int config_font_mask;
+	int tooltip_enabled;
 } Global_task;
 
 
@@ -69,9 +70,10 @@
 void remove_task (Task *tsk);
 
 void draw_task (void *obj, cairo_t *c);
+void on_change_task (void *obj);
 
 void get_icon (Task *tsk);
-void get_title(Task *tsk);
+int  get_title(Task *tsk);
 void active_task();
 void set_task_state(Task* tsk, int state);
 void set_task_redraw(Task* tsk);
diff -Nur tint2-0.11/src/tint2conf/CMakeLists.txt tint2-read-only/src/tint2conf/CMakeLists.txt
--- tint2-0.11/src/tint2conf/CMakeLists.txt	2010-06-14 13:20:41.000000000 +0700
+++ tint2-read-only/src/tint2conf/CMakeLists.txt	2010-12-23 00:02:32.219328648 +0600
@@ -35,11 +35,16 @@
                                  ${GTHREAD2_LIBRARIES}
                                  ${GTK2_LIBRARIES} )
 
+if ( NOT DATADIR )
+  set( DATADIR share )
+endif( NOT DATADIR )
+
 add_definitions( -DINSTALL_PREFIX=\"${CMAKE_INSTALL_PREFIX}\" )
 set_target_properties( tint2conf PROPERTIES COMPILE_FLAGS "-Wall -pthread" )
 set_target_properties( tint2conf PROPERTIES LINK_FLAGS "-pthread" )
 
 install( TARGETS tint2conf DESTINATION bin )
 install( PROGRAMS tintwizard.py DESTINATION bin )
-install( FILES tint2conf.png tint2conf.svg DESTINATION share/pixmaps )
-install( FILES tint2conf.desktop DESTINATION share/applications )
+install( FILES taskbar.svg DESTINATION ${DATADIR}/icons/hicolor/scalable/apps )
+install( FILES tint2conf.desktop DESTINATION ${DATADIR}/applications )
+install( CODE "execute_process(COMMAND gtk-update-icon-cache -f -t ${DATADIR}/icons/hicolor WORKING_DIRECTORY ${CMAKE_INSTALL_PREFIX})" )
diff -Nur tint2-0.11/src/tint2conf/main.c tint2-read-only/src/tint2conf/main.c
--- tint2-0.11/src/tint2conf/main.c	2010-06-16 22:11:43.000000000 +0700
+++ tint2-read-only/src/tint2conf/main.c	2010-12-23 00:02:32.219328648 +0600
@@ -2,7 +2,7 @@
 *
 * Tint2conf
 *
-* Copyright (C) 2009 Thierry lorthiois (lorthiois@bbsoft.fr)
+* Copyright (C) 2009 Thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2
@@ -92,11 +92,11 @@
 	"    </menu>"
 	"  </menubar>"
 	"  <toolbar  name='ToolBar'>"
-	"    <toolitem action='ThemeProperties'/>"
+//	"    <toolitem action='ThemeProperties'/>"
 	"    <toolitem action='ViewApply'/>"
 	"  </toolbar>"
 	"  <popup  name='ThemePopup'>"
-	"    <menuitem action='ThemeProperties'/>"
+//	"    <menuitem action='ThemeProperties'/>"
 	"    <menuitem action='EditRefresh'/>"
 	"    <menuitem action='ViewApply'/>"
 	"    <separator/>"
@@ -132,6 +132,8 @@
 	g_thread_init( NULL );
 	read_config();
 	initTheme();
+	g_set_application_name (_("tint2conf"));
+	gtk_window_set_default_icon_name("taskbar");
 
 	// define main layout : container, menubar, toolbar
 	g_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
@@ -164,10 +166,6 @@
 	// load themes
 	load_theme(g_theme_view);
 
-	/* temporaire !!!!!!!!!!!!!!
-	GtkWidget *prop = create_properties();
-	gtk_window_present(GTK_WINDOW(prop));
-	//*/
 	gtk_widget_show_all(g_window);
 	gtk_main ();
 	return 0;
@@ -189,7 +187,7 @@
 								"comments", _("Theming tool for tint2 panel"),
 								"version", VERSION_STRING,
 								"copyright", _("Copyright 2009 tint2 team\nTint2 License GNU GPL version 2\nTintwizard License GNU GPL version 3"),
-								"logo-icon-name", NULL, "authors", authors,
+								"logo-icon-name", "taskbar", "authors", authors,
 								/* Translators: translate "translator-credits" as
 									your name to have it appear in the credits in the "About"
 									dialog */
@@ -329,22 +327,23 @@
 	GtkTreeSelection *sel;
 	GtkTreeIter iter;
 	GtkTreeModel *model;
-	char *file, *cmd;
+	char *file;
 
 	sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(g_theme_view));
 	if (gtk_tree_selection_get_selected(GTK_TREE_SELECTION(sel), &model, &iter)) {
 		gtk_tree_model_get(model, &iter, COL_THEME_FILE, &file,  -1);
-/*
+//*
 		GtkWidget *prop;
 		prop = create_properties();
 		gtk_window_present(GTK_WINDOW(prop));
 		//printf("menuProperties : fin\n");
-*/
-
-		cmd = g_strdup_printf("%s \'%s\' &", g_cmd_property, file);
+//*/
+/*
+		char *cmd = g_strdup_printf("%s \'%s\' &", g_cmd_property, file);
 		printf("cmd %s\n", cmd);
 		system(cmd);
 		g_free(cmd);
+		//*/
 		g_free(file);
 		
 	}
@@ -580,7 +579,7 @@
 	}
 	g_width = 500;
 	g_height = 350;
-	g_cmd_property = g_strconcat( "python ", INSTALL_PREFIX, "/bin/tintwizard.py", (void*)0 );
+	g_cmd_property = g_strconcat( "/usr/bin/env python ", INSTALL_PREFIX, "/bin/tintwizard.py", (void*)0 );
 
 	// load config
 	path = g_build_filename (g_get_user_config_dir(), "tint2", "tint2confrc", NULL);
diff -Nur tint2-0.11/src/tint2conf/properties.c tint2-read-only/src/tint2conf/properties.c
--- tint2-0.11/src/tint2conf/properties.c	2010-06-16 22:11:43.000000000 +0700
+++ tint2-read-only/src/tint2conf/properties.c	2010-12-23 00:02:32.219328648 +0600
@@ -1,3 +1,21 @@
+/**************************************************************************
+*
+* Tint2conf
+*
+* Copyright (C) 2009 Thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version 2
+* as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+**************************************************************************/
 
 #include "main.h"
 #include "properties.h"
@@ -9,6 +27,7 @@
 void change_paragraph(GtkWidget  *widget);
 void create_general(GtkWidget  *parent);
 void create_panel(GtkWidget  *parent);
+void create_launcher(GtkWidget  *parent);
 void create_taskbar(GtkWidget  *parent);
 void create_task(GtkWidget  *parent);
 void create_clock(GtkWidget  *parent);
@@ -22,14 +41,14 @@
 {
 	GtkWidget  *view, *dialog_vbox3, *button, *notebook;
 	GtkTooltips *tooltips;
-	GtkWidget *page_panel, *page_taskbar,  *page_battery, *page_clock, *page_tooltip, *page_systemtray, *page_task, *page_background;
+	GtkWidget *page_panel, *page_launcher,  *page_taskbar,  *page_battery, *page_clock, *page_tooltip, *page_systemtray, *page_task, *page_background;
 	GtkWidget *label;
 
 	tooltips = gtk_tooltips_new ();
 
 	// global layer
 	view = gtk_dialog_new ();
-	gtk_window_set_title (GTK_WINDOW (view), _("Preferences"));
+	gtk_window_set_title (GTK_WINDOW (view), _("Properties"));
 	gtk_window_set_modal (GTK_WINDOW (view), TRUE);
 	gtk_window_set_skip_pager_hint (GTK_WINDOW (view), TRUE);
 	gtk_window_set_type_hint (GTK_WINDOW (view), GDK_WINDOW_TYPE_HINT_DIALOG);
@@ -59,15 +78,6 @@
 	GTK_WIDGET_SET_FLAGS (button, GTK_CAN_DEFAULT);
 
 	// notebook
-	/*
-	label = gtk_label_new (_("General"));
-	gtk_widget_show (label);
-	page_general = gtk_vbox_new (FALSE, DEFAULT_HOR_SPACING);
-	gtk_container_set_border_width(GTK_CONTAINER(page_general), 10);
-	gtk_widget_show (page_general);
-	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), page_general, label);
-	create_general(page_general);
-*/
 	label = gtk_label_new (_("Panel"));
 	gtk_widget_show (label);
 	page_panel = gtk_vbox_new (FALSE, DEFAULT_HOR_SPACING);
@@ -76,6 +86,14 @@
 	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), page_panel, label);
 	create_panel(page_panel);
 
+	label = gtk_label_new (_("Launcher"));
+	gtk_widget_show (label);
+	page_launcher = gtk_vbox_new (FALSE, DEFAULT_HOR_SPACING);
+	gtk_container_set_border_width(GTK_CONTAINER(page_launcher), 10);
+	gtk_widget_show (page_launcher);
+	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), page_launcher, label);
+	create_launcher(page_launcher);
+
 	label = gtk_label_new (_("Taskbar"));
 	gtk_widget_show (label);
 	page_taskbar = gtk_vbox_new (FALSE, DEFAULT_HOR_SPACING);
@@ -132,7 +150,6 @@
 	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), page_background, label);
 	create_background(page_background);
 	
-printf("create_properties : fin\n");
 	return view;
 }
 
@@ -147,88 +164,33 @@
 }
 
 
-void create_general(GtkWidget  *parent)
-{
-}
-
-
 void create_panel(GtkWidget  *parent)
 {
 	int i;
 	GtkWidget  *screen_position[12];
 	GtkWidget  *table, *hbox, *frame;
-	GtkWidget  *margin_x, *margin_y, *combo_strut_policy, *combo_layer, *combo_width_type, *combo_height_type, *combo_monitor, *combo_background;
+	GtkWidget  *margin_x, *margin_y, *combo_strut_policy, *combo_layer, *combo_width_type, *combo_height_type, *combo_monitor, *combo_background, *items_order;
 	GtkWidget  *label;
 
-	label = gtk_label_new (_("<b>Position and size</b>"));
+	label = gtk_label_new (_("<b>Position, size and items order</b>"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
 	gtk_widget_show (label);
 	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
-    hbox = gtk_hbox_new (FALSE, 20);
-    gtk_widget_show (hbox);
-    gtk_box_pack_start (GTK_BOX (parent), hbox, FALSE, FALSE, 0);
-    
-    table = gtk_table_new (2, 10, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (hbox), table, FALSE, FALSE, 0);
+	hbox = gtk_hbox_new (FALSE, 20);
+	gtk_widget_show (hbox);
+	gtk_box_pack_start (GTK_BOX (parent), hbox, FALSE, FALSE, 0);
+
+	// left marging
+	table = gtk_table_new (2, 1, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (hbox), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
-	label = gtk_label_new (_("Width"));
-	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
-	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
-
-	margin_x = gtk_spin_button_new_with_range (0, 9000, 1);
-	gtk_widget_show (margin_x);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
-
-	combo_width_type = gtk_combo_box_new_text ();
-	gtk_widget_show (combo_width_type);
-	gtk_table_attach (GTK_TABLE (table), combo_width_type, 4, 5, 0, 1, GTK_FILL, 0, 0, 0);
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_width_type), _("Percent"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_width_type), _("Pixels"));
-
-	label = gtk_label_new (_("Marging x"));
-	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
-	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
-
-	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
-	gtk_widget_show (margin_x);
-	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 8, 9, 0, 1, GTK_FILL, 0, 0, 0);
-
-	label = gtk_label_new (_("Height"));
-	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
-	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
-
-	margin_y = gtk_spin_button_new_with_range (0, 9000, 1);
-	gtk_widget_show (margin_y);
-	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
-
-	combo_height_type = gtk_combo_box_new_text ();
-	gtk_widget_show (combo_height_type);
-	gtk_table_attach (GTK_TABLE (table), combo_height_type, 4, 5, 1, 2, GTK_FILL, 0, 0, 0);
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_height_type), _("Percent"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_height_type), _("Pixels"));
-
-	label = gtk_label_new (_("Marging y"));
-	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
-	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 7, 8, 1, 2, GTK_FILL, 0, 0, 0);
-
-	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
-	gtk_widget_show (margin_y);
-	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_y, 8, 9, 1, 2,  GTK_FILL, 0, 0, 0);
-
-    table = gtk_table_new (5, 5, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (hbox), table, FALSE, FALSE, 0);
-    
+	table = gtk_table_new (5, 5, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (hbox), table, FALSE, FALSE, 0);
 	for (i = 0; i < 12; ++i) {
 		screen_position[i] = gtk_toggle_button_new ();
 		gtk_widget_show (screen_position[i]);
@@ -254,66 +216,78 @@
 	gtk_table_attach_defaults (GTK_TABLE (table), screen_position[10], 2, 3, 4, 5);
 	gtk_table_attach_defaults (GTK_TABLE (table), screen_position[11], 3, 4, 4, 5);
 
-	frame = gtk_frame_new (NULL);
-	gtk_widget_show (frame);
-	gtk_box_pack_start (GTK_BOX (hbox), frame, FALSE, TRUE, 0);
-	gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_NONE);
+	table = gtk_table_new (3, 8, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (hbox), table, FALSE, FALSE, 0);
+	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
+	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
-	label = gtk_label_new (_("<b>Appearance</b>"));
+	label = gtk_label_new (_("Width"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
-	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
 	gtk_widget_show (label);
-	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 1, 2, 0, 1, GTK_FILL, 0, 0, 0);
 
-    table = gtk_table_new (2, 10, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
-	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
-	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
+	margin_x = gtk_spin_button_new_with_range (0, 9000, 1);
+	gtk_widget_show (margin_x);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
+
+	combo_width_type = gtk_combo_box_new_text ();
+	gtk_widget_show (combo_width_type);
+	gtk_table_attach (GTK_TABLE (table), combo_width_type, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_width_type), _("Percent"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_width_type), _("Pixels"));
 
-	label = gtk_label_new (_("Padding horizontal"));
+	label = gtk_label_new (_("Marging x"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
 
 	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
 	gtk_widget_show (margin_x);
 	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
 
-	label = gtk_label_new (_("Background"));
+	label = gtk_label_new (_("Height"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 1, 2, 1, 2, GTK_FILL, 0, 0, 0);
 
-	combo_background = gtk_combo_box_new_text ();
-	gtk_widget_show (combo_background);
-	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 1"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 2"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 3"));
+	margin_y = gtk_spin_button_new_with_range (0, 9000, 1);
+	gtk_widget_show (margin_y);
+	gtk_table_attach (GTK_TABLE (table), margin_y, 2, 3, 1, 2,  GTK_FILL, 0, 0, 0);
 
-	label = gtk_label_new (_("Padding vertical"));
+	label = gtk_label_new (_("Items order"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 1, 2, 2, 3, GTK_FILL, 0, 0, 0);
 
-	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
-	gtk_widget_show (margin_y);
-	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
+	items_order = gtk_entry_new ();
+	gtk_widget_show (items_order);
+	gtk_entry_set_width_chars (GTK_ENTRY (items_order), 15);
+	gtk_table_attach (GTK_TABLE (table), items_order, 2, 4, 2, 3, GTK_FILL, 0, 0, 0);
 
-	label = gtk_label_new (_("Spacing"));
+	change_paragraph(parent);
+
+	combo_height_type = gtk_combo_box_new_text ();
+	gtk_widget_show (combo_height_type);
+	gtk_table_attach (GTK_TABLE (table), combo_height_type, 3, 4, 1, 2, GTK_FILL, 0, 0, 0);
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_height_type), _("Percent"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_height_type), _("Pixels"));
+
+	label = gtk_label_new (_("Marging y"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
 	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 1, 2, GTK_FILL, 0, 0, 0);
 
-	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
-	gtk_widget_show (margin_x);
-	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 1, 2, GTK_FILL, 0, 0, 0);
+	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_y);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_y, 7, 8, 1, 2,  GTK_FILL, 0, 0, 0);
 
-	change_paragraph(parent);
+	frame = gtk_frame_new (NULL);
+	gtk_widget_show (frame);
+	gtk_box_pack_start (GTK_BOX (hbox), frame, FALSE, TRUE, 0);
+	gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_NONE);
 
 	label = gtk_label_new (_("<b>Autohide</b>"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
@@ -321,9 +295,9 @@
 	gtk_widget_show (label);
 	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
 
-    table = gtk_table_new (2, 10, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (2, 10, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
@@ -350,7 +324,7 @@
 	gtk_widget_show (label);
 	gtk_table_attach (GTK_TABLE (table), label, 8, 9, 0, 1, GTK_FILL, 0, 0, 0);
 
-	label = gtk_label_new (_("Hidden height"));
+	label = gtk_label_new (_("Hidden size"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
 	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
@@ -376,15 +350,71 @@
 
 	change_paragraph(parent);
 	
+	label = gtk_label_new (_("<b>Appearance</b>"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
+	gtk_widget_show (label);
+	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
+
+	table = gtk_table_new (2, 10, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
+	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
+
+	label = gtk_label_new (_("Horizontal padding"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Background"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
+
+	combo_background = gtk_combo_box_new_text ();
+	gtk_widget_show (combo_background);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 1"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 2"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 3"));
+
+	label = gtk_label_new (_("Vertical padding"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+
+	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_y);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Spacing"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 1, 2, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 1, 2, GTK_FILL, 0, 0, 0);
+
+	change_paragraph(parent);
+
 	label = gtk_label_new (_("<b>Window manager</b>"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
 	gtk_widget_show (label);
 	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
 
-    table = gtk_table_new (2, 12, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (2, 12, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
@@ -417,9 +447,9 @@
 	gtk_widget_show (combo_layer);
 	gtk_entry_set_max_length (GTK_ENTRY (combo_layer), 3);
 	gtk_table_attach (GTK_TABLE (table), combo_layer, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_layer), _("Top"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_layer), _("Normal"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_layer), _("Bottom"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_layer), _("top"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_layer), _("normal"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_layer), _("bottom"));
 
 	label = gtk_label_new (_("Strut policy"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
@@ -430,9 +460,9 @@
 	gtk_widget_show (combo_strut_policy);
 	gtk_entry_set_max_length (GTK_ENTRY (combo_strut_policy), 3);
 	gtk_table_attach (GTK_TABLE (table), combo_strut_policy, 7, 8, 1, 2, GTK_FILL, 0, 0, 0);
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_strut_policy), _("Follow size"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_strut_policy), _("Minimum"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_strut_policy), _("None"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_strut_policy), _("follow_size"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_strut_policy), _("minimum"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_strut_policy), _("none"));
 
 	label = gtk_label_new (_("Monitor"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
@@ -448,26 +478,16 @@
 }
 
 
-void create_taskbar(GtkWidget  *parent)
+void create_launcher(GtkWidget  *parent)
 {
 	GtkWidget  *table, *label;
 	GtkWidget  *margin_x, *margin_y, *combo_background;
 
-    table = gtk_table_new (1, 2, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
-	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
-	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
-
-	label = gtk_label_new (_("Show all desktop"));
+	label = gtk_label_new (_("<b>Applications</b>"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 0, 1, 0, 1, GTK_FILL, 0, 0, 0);
-
-	margin_x = gtk_check_button_new ();
-	gtk_widget_show (margin_x);
-	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 1, 2, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
 
 	change_paragraph(parent);
 
@@ -477,13 +497,13 @@
 	gtk_widget_show (label);
 	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
 
-    table = gtk_table_new (2, 12, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (6, 10, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
-
-	label = gtk_label_new (_("Padding horizontal"));
+	
+	label = gtk_label_new (_("Horizontal padding"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
 	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
@@ -493,129 +513,210 @@
 	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
 	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
 
+	label = gtk_label_new (_("Vertical padding"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+
+	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_y);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
+
 	label = gtk_label_new (_("Spacing"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 2, 3, GTK_FILL, 0, 0, 0);
 
 	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
 	gtk_widget_show (margin_x);
 	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 2, 3, GTK_FILL, 0, 0, 0);
 
-	label = gtk_label_new (_("Background inactive"));
+	label = gtk_label_new (_("Background"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 10, 11, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
 
 	combo_background = gtk_combo_box_new_text ();
 	gtk_widget_show (combo_background);
-	gtk_table_attach (GTK_TABLE (table), combo_background, 11, 12, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
 	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 1"));
 	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 2"));
 	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 3"));
 
-	label = gtk_label_new (_("Padding vertical"));
+	label = gtk_label_new (_("Icon size"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 1, 2, GTK_FILL, 0, 0, 0);
 
-	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
-	gtk_widget_show (margin_y);
-	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
+	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 1, 2, GTK_FILL, 0, 0, 0);
 
-	label = gtk_label_new (_("Background active"));
+	label = gtk_label_new (_("Icon theme"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 10, 11, 1, 2, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 2, 3, GTK_FILL, 0, 0, 0);
 
 	combo_background = gtk_combo_box_new_text ();
 	gtk_widget_show (combo_background);
-	gtk_table_attach (GTK_TABLE (table), combo_background, 11, 12, 1, 2, GTK_FILL, 0, 0, 0);
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 1"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 2"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 3"));
+	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 2, 3, GTK_FILL, 0, 0, 0);
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Theme 1"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Theme 2"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Theme 3"));
 
 	change_paragraph(parent);
 }
 
 
-void create_task(GtkWidget  *parent)
+void create_taskbar(GtkWidget  *parent)
 {
-	GtkWidget  *table, *label, *notebook, *page_task;
-	GtkWidget  *margin_x, *combo_background;
-
-	label = gtk_label_new (_("<b>Mouse action</b>"));
-	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
-	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
-	gtk_widget_show (label);
-	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
+	GtkWidget  *table, *label;
+	GtkWidget  *margin_x, *margin_y, *combo_background;
 
-    table = gtk_table_new (2, 10, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (2, 2, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
-	label = gtk_label_new (_("Middle click"));
+	label = gtk_label_new (_("Show all desktop"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 0, 1, 0, 1, GTK_FILL, 0, 0, 0);
 
-	combo_background = gtk_combo_box_new_text ();
-	gtk_widget_show (combo_background);
-	gtk_table_attach (GTK_TABLE (table), combo_background, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("None"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Close"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Toggle"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Iconify"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Shade"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Toggle iconify"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Maximize restore"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Desktop left"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Next task"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Previous task"));
+	margin_x = gtk_check_button_new ();
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 1, 2, 0, 1, GTK_FILL, 0, 0, 0);
 
-	label = gtk_label_new (_("Wheel scroll up"));
+	label = gtk_label_new (_("Show taskbar name"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 0, 1, 1, 2, GTK_FILL, 0, 0, 0);
 
-	combo_background = gtk_combo_box_new_text ();
-	gtk_widget_show (combo_background);
-	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("None"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Close"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Toggle"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Iconify"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Shade"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Toggle iconify"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Maximize restore"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Desktop left"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Next task"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Previous task"));
+	margin_x = gtk_check_button_new ();
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 1, 2, 1, 2, GTK_FILL, 0, 0, 0);
 
-	label = gtk_label_new (_("Right click"));
+	change_paragraph(parent);
+
+	label = gtk_label_new (_("<b>Appearance</b>"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
 
-	combo_background = gtk_combo_box_new_text ();
-	gtk_widget_show (combo_background);
-	gtk_table_attach (GTK_TABLE (table), combo_background, 3, 4, 1, 2, GTK_FILL, 0, 0, 0);
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("None"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Close"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Toggle"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Iconify"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Shade"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Toggle iconify"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Maximize restore"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Desktop left"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Next task"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Previous task"));
+	table = gtk_table_new (3, 12, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
+	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
-	label = gtk_label_new (_("Wheel scroll down"));
+	label = gtk_label_new (_("Horizontal padding"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Vertical padding"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+
+	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_y);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Spacing"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 2, 3, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 2, 3, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Normal background"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
+
+	combo_background = gtk_combo_box_new_text ();
+	gtk_widget_show (combo_background);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 1"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 2"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 3"));
+
+	label = gtk_label_new (_("Active background"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 1, 2, GTK_FILL, 0, 0, 0);
+
+	combo_background = gtk_combo_box_new_text ();
+	gtk_widget_show (combo_background);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 1, 2, GTK_FILL, 0, 0, 0);
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 1"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 2"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 3"));
+
+	change_paragraph(parent);
+
+	label = gtk_label_new (_("<b>Name appearance</b>"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
+	gtk_widget_show (label);
+	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
+
+	table = gtk_table_new (2, 12, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
+	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
+
+	label = gtk_label_new (_("Horizontal padding"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Vertical padding"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+
+	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_y);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Normal background"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
+
+	combo_background = gtk_combo_box_new_text ();
+	gtk_widget_show (combo_background);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 1"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 2"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 3"));
+
+	label = gtk_label_new (_("Active background"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
 	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 1, 2, GTK_FILL, 0, 0, 0);
@@ -623,16 +724,110 @@
 	combo_background = gtk_combo_box_new_text ();
 	gtk_widget_show (combo_background);
 	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 1, 2, GTK_FILL, 0, 0, 0);
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("None"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Close"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Toggle"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Iconify"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Shade"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Toggle iconify"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Maximize restore"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Desktop left"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Next task"));
-	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Previous task"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 1"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 2"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 3"));
+
+	change_paragraph(parent);
+}
+
+
+void create_task(GtkWidget  *parent)
+{
+	GtkWidget  *table, *label, *notebook, *page_task;
+	GtkWidget  *margin_x, *combo_background;
+
+	label = gtk_label_new (_("<b>Mouse action</b>"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
+	gtk_widget_show (label);
+	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
+
+	table = gtk_table_new (2, 10, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
+	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
+
+	label = gtk_label_new (_("Middle click"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
+
+	combo_background = gtk_combo_box_new_text ();
+	gtk_widget_show (combo_background);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("none"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("close"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("toggle"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("iconify"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("shade"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("toggle_iconify"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("maximize_restore"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("desktop_left"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("desktop_right"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("next_task"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("previous_task"));
+
+	label = gtk_label_new (_("Wheel scroll up"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
+
+	combo_background = gtk_combo_box_new_text ();
+	gtk_widget_show (combo_background);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("none"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("close"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("toggle"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("iconify"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("shade"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("toggle_iconify"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("maximize_restore"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("desktop_left"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("desktop_right"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("next_task"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("previous_task"));
+
+	label = gtk_label_new (_("Right click"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+
+	combo_background = gtk_combo_box_new_text ();
+	gtk_widget_show (combo_background);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 3, 4, 1, 2, GTK_FILL, 0, 0, 0);
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("none"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("close"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("toggle"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("iconify"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("shade"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("toggle_iconify"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("maximize_restore"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("desktop_left"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("desktop_right"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("next_task"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("previous_task"));
+
+	label = gtk_label_new (_("Wheel scroll down"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 1, 2, GTK_FILL, 0, 0, 0);
+
+	combo_background = gtk_combo_box_new_text ();
+	gtk_widget_show (combo_background);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 1, 2, GTK_FILL, 0, 0, 0);
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("none"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("close"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("toggle"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("iconify"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("shade"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("toggle_iconify"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("maximize_restore"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("desktop_left"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("desktop_right"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("next_task"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("previous_task"));
 
 	change_paragraph(parent);
 
@@ -642,9 +837,9 @@
 	gtk_widget_show (label);
 	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
 
-    table = gtk_table_new (4, 10, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (4, 10, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
@@ -731,27 +926,84 @@
 	GtkWidget  *margin_x, *margin_y, *combo_background;
 	GtkWidget  *label;
 
-    table = gtk_table_new (1, 2, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (1, 2, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
-	label = gtk_label_new (_("Show clock"));
+//	change_paragraph(parent);
+
+	label = gtk_label_new (_("<b>Format and timezone</b>"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);	gtk_widget_show (label);
+	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
+
+	table = gtk_table_new (3, 10, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
+	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
+
+	label = gtk_label_new (_("First line"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 0, 1, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
 
-	margin_x = gtk_check_button_new ();
+	margin_x = gtk_entry_new ();
 	gtk_widget_show (margin_x);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 1, 2, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_entry_set_width_chars (GTK_ENTRY (margin_x), 15);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
 
-	change_paragraph(parent);
+	label = gtk_label_new (_("Second line"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
 
-	label = gtk_label_new (_("<b>Format and timezone</b>"));
+	margin_x = gtk_entry_new ();
+	gtk_widget_show (margin_x);
+	gtk_entry_set_width_chars (GTK_ENTRY (margin_x), 15);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 1, 2, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Tooltip"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
-	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);	gtk_widget_show (label);
-	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 2, 3, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_entry_new ();
+	gtk_widget_show (margin_x);
+	gtk_entry_set_width_chars (GTK_ENTRY (margin_x), 15);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 2, 3, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("First line"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_entry_new ();
+	gtk_widget_show (margin_x);
+	gtk_entry_set_width_chars (GTK_ENTRY (margin_x), 20);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Second line"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 1, 2, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_entry_new ();
+	gtk_widget_show (margin_x);
+	gtk_entry_set_width_chars (GTK_ENTRY (margin_x), 20);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 1, 2, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Tooltip"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 2, 3, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_entry_new ();
+	gtk_widget_show (margin_x);
+	gtk_entry_set_width_chars (GTK_ENTRY (margin_x), 20);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 2, 3, GTK_FILL, 0, 0, 0);
 
 	change_paragraph(parent);
 
@@ -761,6 +1013,32 @@
 	gtk_widget_show (label);
 	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
 
+	table = gtk_table_new (2, 10, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
+	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
+
+	label = gtk_label_new (_("Left click command"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_entry_new ();
+	gtk_widget_show (margin_x);
+	gtk_entry_set_width_chars (GTK_ENTRY (margin_x), 12);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Right click command"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_entry_new ();
+	gtk_widget_show (margin_x);
+	gtk_entry_set_width_chars (GTK_ENTRY (margin_x), 12);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+
 	change_paragraph(parent);
 
 	label = gtk_label_new (_("<b>Appearance</b>"));
@@ -769,13 +1047,13 @@
 	gtk_widget_show (label);
 	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
 
-    table = gtk_table_new (3, 10, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (3, 10, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
-	label = gtk_label_new (_("Padding horizontal"));
+	label = gtk_label_new (_("Horizontal padding"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
 	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
@@ -785,46 +1063,56 @@
 	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
 	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
 
+	label = gtk_label_new (_("Vertical padding"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+
+	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_y);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
+
 	label = gtk_label_new (_("Background"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 2, 3, GTK_FILL, 0, 0, 0);
 
 	combo_background = gtk_combo_box_new_text ();
 	gtk_widget_show (combo_background);
-	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 3, 4, 2, 3, GTK_FILL, 0, 0, 0);
 	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 1"));
 	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 2"));
 	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 3"));
 
-	label = gtk_label_new (_("Padding vertical"));
+	label = gtk_label_new (_("Font first line"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
 
-	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
-	gtk_widget_show (margin_y);
-	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
+	margin_x = gtk_font_button_new ();
+	gtk_widget_show (margin_x);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+//	gtk_font_button_set_show_style (GTK_FONT_BUTTON (margin_x), FALSE);
 
-	label = gtk_label_new (_("Font color"));
+	label = gtk_label_new (_("Font second line"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 2, 3, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 1, 2, GTK_FILL, 0, 0, 0);
 
-	margin_x = gtk_color_button_new();
-	gtk_color_button_set_use_alpha(GTK_COLOR_BUTTON(margin_x), TRUE);
+	margin_x = gtk_font_button_new ();
 	gtk_widget_show (margin_x);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 2, 3, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 1, 2, GTK_FILL, 0, 0, 0);
+//	gtk_font_button_set_show_style (GTK_FONT_BUTTON (margin_x), FALSE);
 
-	label = gtk_label_new (_("Font"));
+	label = gtk_label_new (_("Font color"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
 	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 2, 3, GTK_FILL, 0, 0, 0);
 
-	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
+	margin_x = gtk_color_button_new();
+	gtk_color_button_set_use_alpha(GTK_COLOR_BUTTON(margin_x), TRUE);
 	gtk_widget_show (margin_x);
-	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
 	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 2, 3, GTK_FILL, 0, 0, 0);
 
 	change_paragraph(parent);
@@ -834,26 +1122,124 @@
 void create_systemtray(GtkWidget  *parent)
 {
 	GtkWidget  *table;
-	GtkWidget  *margin_x;
+	GtkWidget  *margin_x, *margin_y, *combo_background;
 	GtkWidget  *label;
 
-    table = gtk_table_new (1, 2, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (2, 2, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
-	label = gtk_label_new (_("Show notification"));
+	label = gtk_label_new (_("Icon ordering"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 0, 1, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 0, 1, 1, 2, GTK_FILL, 0, 0, 0);
 
-	margin_x = gtk_check_button_new ();
-	gtk_widget_show (margin_x);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 1, 2, 0, 1, GTK_FILL, 0, 0, 0);
+	combo_background = gtk_combo_box_new_text ();
+	gtk_widget_show (combo_background);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 1, 2, 1, 2, GTK_FILL, 0, 0, 0);
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("ascending"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("descending"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("left2right"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("right2left"));
 
 	change_paragraph(parent);
 
+	label = gtk_label_new (_("<b>Appearance</b>"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
+	gtk_widget_show (label);
+	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
+
+	table = gtk_table_new (6, 10, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
+	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
+	
+	label = gtk_label_new (_("Horizontal padding"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Vertical padding"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+
+	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_y);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Spacing"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 2, 3, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 2, 3, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Background"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 3, 4, GTK_FILL, 0, 0, 0);
+
+	combo_background = gtk_combo_box_new_text ();
+	gtk_widget_show (combo_background);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 3, 4, 3, 4, GTK_FILL, 0, 0, 0);
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 1"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 2"));
+	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 3"));
+
+	label = gtk_label_new (_("Icon size"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Icon opacity"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 1, 2, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_spin_button_new_with_range (0, 100, 1);
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 1, 2, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Icon saturation"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 2, 3, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_spin_button_new_with_range (-100, 100, 1);
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 2, 3, GTK_FILL, 0, 0, 0);
+
+	label = gtk_label_new (_("Icon brightness"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 3, 4, GTK_FILL, 0, 0, 0);
+
+	margin_x = gtk_spin_button_new_with_range (-100, 100, 1);
+	gtk_widget_show (margin_x);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 3, 4, GTK_FILL, 0, 0, 0);
+
 }
 
 
@@ -863,32 +1249,21 @@
 	GtkWidget  *margin_x, *margin_y, *combo_background;
 	GtkWidget  *label;
 
-    table = gtk_table_new (1, 2, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (1, 2, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
-	label = gtk_label_new (_("Show battery"));
-	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
-	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 0, 1, 0, 1, GTK_FILL, 0, 0, 0);
-
-	margin_x = gtk_check_button_new ();
-	gtk_widget_show (margin_x);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 1, 2, 0, 1, GTK_FILL, 0, 0, 0);
-
-	change_paragraph(parent);
-
 	label = gtk_label_new (_("<b>Event</b>"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_label_set_use_markup (GTK_LABEL (label), TRUE);
 	gtk_widget_show (label);
 	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
 
-    table = gtk_table_new (2, 10, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (2, 10, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
@@ -930,13 +1305,13 @@
 	gtk_widget_show (label);
 	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
 
-    table = gtk_table_new (4, 10, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (4, 10, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
-	label = gtk_label_new (_("Padding horizontal"));
+	label = gtk_label_new (_("Horizontal padding"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
 	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
@@ -946,57 +1321,57 @@
 	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
 	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
 
+	label = gtk_label_new (_("Vertical padding"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+
+	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_y);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
+
 	label = gtk_label_new (_("Background"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 2, 3, GTK_FILL, 0, 0, 0);
 
 	combo_background = gtk_combo_box_new_text ();
 	gtk_widget_show (combo_background);
-	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 3, 4, 2, 3, GTK_FILL, 0, 0, 0);
 	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 1"));
 	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 2"));
 	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 3"));
 
-	label = gtk_label_new (_("Padding vertical"));
+	label = gtk_label_new (_("Font first line"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
 
-	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
-	gtk_widget_show (margin_y);
-	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
+	margin_x = gtk_font_button_new ();
+	gtk_widget_show (margin_x);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+//	gtk_font_button_set_show_style (GTK_FONT_BUTTON (margin_x), FALSE);
 
-	label = gtk_label_new (_("Font color"));
+	label = gtk_label_new (_("Font second line"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
 	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 1, 2, GTK_FILL, 0, 0, 0);
 
-	margin_x = gtk_color_button_new();
-	gtk_color_button_set_use_alpha(GTK_COLOR_BUTTON(margin_x), TRUE);
+	margin_x = gtk_font_button_new ();
 	gtk_widget_show (margin_x);
 	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 1, 2, GTK_FILL, 0, 0, 0);
+//	gtk_font_button_set_show_style (GTK_FONT_BUTTON (margin_x), FALSE);
 
-	label = gtk_label_new (_("Font first line"));
-	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
-	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 2, 3, GTK_FILL, 0, 0, 0);
-
-	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
-	gtk_widget_show (margin_x);
-	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 2, 3, GTK_FILL, 0, 0, 0);
-
-	label = gtk_label_new (_("Font second line"));
+	label = gtk_label_new (_("Font color"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 3, 4, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 2, 3, GTK_FILL, 0, 0, 0);
 
-	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
+	margin_x = gtk_color_button_new();
+	gtk_color_button_set_use_alpha(GTK_COLOR_BUTTON(margin_x), TRUE);
 	gtk_widget_show (margin_x);
-	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 3, 4, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 2, 3, GTK_FILL, 0, 0, 0);
 
 	change_paragraph(parent);
 }
@@ -1008,9 +1383,9 @@
 	GtkWidget  *margin_x, *margin_y, *combo_background;
 	GtkWidget  *label;
 
-    table = gtk_table_new (1, 2, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (1, 2, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
@@ -1031,9 +1406,9 @@
 	gtk_widget_show (label);
 	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
 
-    table = gtk_table_new (2, 10, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (2, 10, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
@@ -1073,13 +1448,13 @@
 	gtk_widget_show (label);
 	gtk_box_pack_start(GTK_BOX (parent), label, FALSE, FALSE, 0);
 
-    table = gtk_table_new (3, 10, FALSE);
-    gtk_widget_show (table);
-    gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
+	table = gtk_table_new (3, 10, FALSE);
+	gtk_widget_show (table);
+	gtk_box_pack_start (GTK_BOX (parent), table, FALSE, FALSE, 0);
 	gtk_table_set_row_spacings (GTK_TABLE (table), ROW_SPACING);
 	gtk_table_set_col_spacings (GTK_TABLE (table), COL_SPACING);
 
-	label = gtk_label_new (_("Padding horizontal"));
+	label = gtk_label_new (_("Horizontal padding"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
 	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 0, 1, GTK_FILL, 0, 0, 0);
@@ -1089,54 +1464,55 @@
 	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
 	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 0, 1, GTK_FILL, 0, 0, 0);
 
+	label = gtk_label_new (_("Vertical padding"));
+	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
+	gtk_widget_show (label);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+
+	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
+	gtk_widget_show (margin_y);
+	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
+	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
+
 	label = gtk_label_new (_("Background"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 2, 3, GTK_FILL, 0, 0, 0);
 
 	combo_background = gtk_combo_box_new_text ();
 	gtk_widget_show (combo_background);
-	gtk_table_attach (GTK_TABLE (table), combo_background, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), combo_background, 3, 4, 2, 3, GTK_FILL, 0, 0, 0);
 	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 1"));
 	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 2"));
 	gtk_combo_box_append_text (GTK_COMBO_BOX (combo_background), _("Back 3"));
 
-	label = gtk_label_new (_("Padding vertical"));
+	label = gtk_label_new (_("Font"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 1, 2, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 0, 1, GTK_FILL, 0, 0, 0);
 
-	margin_y = gtk_spin_button_new_with_range (0, 500, 1);
-	gtk_widget_show (margin_y);
-	gtk_entry_set_max_length (GTK_ENTRY (margin_y), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_y, 3, 4, 1, 2,  GTK_FILL, 0, 0, 0);
+	margin_x = gtk_font_button_new ();
+	gtk_widget_show (margin_x);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 0, 1, GTK_FILL, 0, 0, 0);
+//	gtk_font_button_set_show_style (GTK_FONT_BUTTON (margin_x), FALSE);
 
 	label = gtk_label_new (_("Font color"));
 	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
 	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 2, 3, 2, 3, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 1, 2, GTK_FILL, 0, 0, 0);
 
 	margin_x = gtk_color_button_new();
 	gtk_color_button_set_use_alpha(GTK_COLOR_BUTTON(margin_x), TRUE);
 	gtk_widget_show (margin_x);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 3, 4, 2, 3, GTK_FILL, 0, 0, 0);
-
-	label = gtk_label_new (_("Font"));
-	gtk_misc_set_alignment (GTK_MISC (label), 0, 0);
-	gtk_widget_show (label);
-	gtk_table_attach (GTK_TABLE (table), label, 6, 7, 2, 3, GTK_FILL, 0, 0, 0);
-
-	margin_x = gtk_spin_button_new_with_range (0, 500, 1);
-	gtk_widget_show (margin_x);
-	gtk_entry_set_max_length (GTK_ENTRY (margin_x), 3);
-	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 2, 3, GTK_FILL, 0, 0, 0);
+	gtk_table_attach (GTK_TABLE (table), margin_x, 7, 8, 1, 2, GTK_FILL, 0, 0, 0);
 
 	change_paragraph(parent);
-
 }
 
 
 void create_background(GtkWidget  *parent)
 {
+
+	change_paragraph(parent);
 }
 
diff -Nur tint2-0.11/src/tint2conf/taskbar.svg tint2-read-only/src/tint2conf/taskbar.svg
--- tint2-0.11/src/tint2conf/taskbar.svg	1970-01-01 07:00:00.000000000 +0700
+++ tint2-read-only/src/tint2conf/taskbar.svg	2010-12-23 00:02:32.219328648 +0600
@@ -0,0 +1,436 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:xlink="http://www.w3.org/1999/xlink"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   version="1.1"
+   width="48"
+   height="48"
+   id="svg1325"
+   inkscape:version="0.47 r22583"
+   sodipodi:docname="taskbar.svg"
+   inkscape:export-filename="/home/omega_dist/4_devel_open_source/9_tint/tint2/src/tint2conf/tint2conf.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <metadata
+     id="metadata50">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <sodipodi:namedview
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1"
+     objecttolerance="10"
+     gridtolerance="10"
+     guidetolerance="10"
+     inkscape:pageopacity="0"
+     inkscape:pageshadow="2"
+     inkscape:window-width="1440"
+     inkscape:window-height="837"
+     id="namedview48"
+     showgrid="false"
+     inkscape:zoom="4.9166667"
+     inkscape:cx="-69.254237"
+     inkscape:cy="21.9661"
+     inkscape:window-x="-2"
+     inkscape:window-y="1"
+     inkscape:window-maximized="1"
+     inkscape:current-layer="svg1325" />
+  <defs
+     id="defs1327">
+    <inkscape:perspective
+       sodipodi:type="inkscape:persp3d"
+       inkscape:vp_x="0 : 24 : 1"
+       inkscape:vp_y="0 : 1000 : 0"
+       inkscape:vp_z="48 : 24 : 1"
+       inkscape:persp3d-origin="24 : 16 : 1"
+       id="perspective52" />
+    <linearGradient
+       id="linearGradient4708">
+      <stop
+         id="stop4710"
+         style="stop-color:white;stop-opacity:1"
+         offset="0" />
+      <stop
+         id="stop4712"
+         style="stop-color:black;stop-opacity:1"
+         offset="0.57954973" />
+      <stop
+         id="stop4714"
+         style="stop-color:black;stop-opacity:1"
+         offset="1" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2270">
+      <stop
+         id="stop2272"
+         style="stop-color:white;stop-opacity:1"
+         offset="0" />
+      <stop
+         id="stop2274"
+         style="stop-color:white;stop-opacity:0"
+         offset="1" />
+    </linearGradient>
+    <linearGradient
+       x1="20"
+       y1="18"
+       x2="20"
+       y2="46"
+       id="linearGradient2851"
+       xlink:href="#linearGradient2270"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="translate(0,-9.9999992)" />
+    <linearGradient
+       x1="30"
+       y1="17"
+       x2="30"
+       y2="47"
+       id="linearGradient2854"
+       xlink:href="#linearGradient2181"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="translate(0,-9.9999992)" />
+    <linearGradient
+       x1="63.397362"
+       y1="-12.489107"
+       x2="63.397362"
+       y2="5.4675598"
+       id="linearGradient2685"
+       xlink:href="#linearGradient4873"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.5436509,0,0,1.5436158,-80.015712,21.419381)" />
+    <linearGradient
+       id="linearGradient4873">
+      <stop
+         id="stop4875"
+         style="stop-color:white;stop-opacity:1"
+         offset="0" />
+      <stop
+         id="stop4877"
+         style="stop-color:white;stop-opacity:0"
+         offset="1" />
+    </linearGradient>
+    <radialGradient
+       cx="23.895569"
+       cy="3.9900031"
+       r="20.397499"
+       fx="23.895569"
+       fy="3.9900031"
+       id="radialGradient2688"
+       xlink:href="#linearGradient3242-187-536"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0,1.7008781,-2.245129,0,24.958071,-40.236051)" />
+    <linearGradient
+       id="linearGradient3242-187-536">
+      <stop
+         id="stop2778"
+         style="stop-color:#8badea;stop-opacity:1"
+         offset="0" />
+      <stop
+         id="stop2780"
+         style="stop-color:#6396cd;stop-opacity:1"
+         offset="0.26238" />
+      <stop
+         id="stop2782"
+         style="stop-color:#3b7caf;stop-opacity:1"
+         offset="0.66093999" />
+      <stop
+         id="stop2784"
+         style="stop-color:#194c70;stop-opacity:1"
+         offset="1" />
+    </linearGradient>
+    <linearGradient
+       x1="18.379412"
+       y1="44.980297"
+       x2="18.379412"
+       y2="3.0816143"
+       id="linearGradient2690"
+       xlink:href="#linearGradient2490-182-124"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.7126612,0,0,0.7126613,-1.1038706,-1.1038704)" />
+    <linearGradient
+       id="linearGradient2490-182-124">
+      <stop
+         id="stop2788"
+         style="stop-color:#1f4b6a;stop-opacity:1"
+         offset="0" />
+      <stop
+         id="stop2790"
+         style="stop-color:#4083c2;stop-opacity:1"
+         offset="1" />
+    </linearGradient>
+    <radialGradient
+       cx="62.625"
+       cy="4.625"
+       r="10.625"
+       fx="62.625"
+       fy="4.625"
+       id="radialGradient2693"
+       xlink:href="#linearGradient8838"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.5058824,0,0,0.37647,-78.305888,26.258824)" />
+    <linearGradient
+       id="linearGradient8838">
+      <stop
+         id="stop8840"
+         style="stop-color:black;stop-opacity:1"
+         offset="0" />
+      <stop
+         id="stop8842"
+         style="stop-color:black;stop-opacity:0"
+         offset="1" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2181">
+      <stop
+         id="stop2183"
+         style="stop-color:#f0f0f0;stop-opacity:1"
+         offset="0" />
+      <stop
+         id="stop2185"
+         style="stop-color:#d3d3d3;stop-opacity:1"
+         offset="1" />
+    </linearGradient>
+    <linearGradient
+       x1="50.23077"
+       y1="22"
+       x2="53"
+       y2="22"
+       id="linearGradient4720"
+       xlink:href="#linearGradient4708"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(4.3333333,0,0,1,-176.66667,0)" />
+    <mask
+       id="mask4716">
+      <rect
+         width="52"
+         height="32"
+         x="1"
+         y="6"
+         id="rect4718"
+         style="fill:url(#linearGradient4720);fill-opacity:1;stroke:none" />
+    </mask>
+    <linearGradient
+       x1="50.23077"
+       y1="22"
+       x2="53"
+       y2="22"
+       id="linearGradient4726"
+       xlink:href="#linearGradient4708"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(4.3333333,0,0,1,-176.66667,0)" />
+    <mask
+       id="mask4722">
+      <rect
+         width="52"
+         height="32"
+         x="1"
+         y="6"
+         id="rect4724"
+         style="fill:url(#linearGradient4726);fill-opacity:1;stroke:none" />
+    </mask>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4873"
+       id="linearGradient2861"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.8085571,0,0,0.74493792,-86.459085,24.622683)"
+       x1="63.397362"
+       y1="-12.489107"
+       x2="63.397362"
+       y2="5.4675598" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3242-187-536"
+       id="radialGradient2864"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0,0.82083158,-2.630416,0,36.52927,-5.1317867)"
+       cx="23.895569"
+       cy="3.9900031"
+       fx="23.895569"
+       fy="3.9900031"
+       r="20.397499" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2490-182-124"
+       id="linearGradient2866"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.83496113,0,0,0.34392523,5.994833,13.753123)"
+       x1="18.379412"
+       y1="44.980297"
+       x2="18.379412"
+       y2="3.0816143" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient8838"
+       id="radialGradient2869"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.7643072,0,0,0.18168172,-84.455838,26.958163)"
+       cx="62.625"
+       cy="4.625"
+       fx="62.625"
+       fy="4.625"
+       r="10.625" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient8838"
+       id="radialGradient2876"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.7643072,0,0,0.18168172,-84.455838,26.958163)"
+       cx="62.625"
+       cy="4.625"
+       fx="62.625"
+       fy="4.625"
+       r="10.625" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3242-187-536"
+       id="radialGradient2878"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0,0.82083158,-2.630416,0,36.52927,-5.1317867)"
+       cx="23.895569"
+       cy="3.9900031"
+       fx="23.895569"
+       fy="3.9900031"
+       r="20.397499" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2490-182-124"
+       id="linearGradient2880"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.83496113,0,0,0.34392523,5.994833,13.753123)"
+       x1="18.379412"
+       y1="44.980297"
+       x2="18.379412"
+       y2="3.0816143" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4873"
+       id="linearGradient2882"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.8085571,0,0,0.74493792,-86.459085,24.622683)"
+       x1="63.397362"
+       y1="-12.489107"
+       x2="63.397362"
+       y2="5.4675598" />
+    <inkscape:perspective
+       id="perspective2924"
+       inkscape:persp3d-origin="0.5 : 0.33333333 : 1"
+       inkscape:vp_z="1 : 0.5 : 1"
+       inkscape:vp_y="0 : 1000 : 0"
+       inkscape:vp_x="0 : 0.5 : 1"
+       sodipodi:type="inkscape:persp3d" />
+    <linearGradient
+       x1="30"
+       y1="17"
+       x2="30"
+       y2="47"
+       id="linearGradient2854-0"
+       xlink:href="#linearGradient2181-7"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="translate(0,-9.9999992)" />
+    <linearGradient
+       id="linearGradient2181-7">
+      <stop
+         id="stop2183-8"
+         style="stop-color:#f0f0f0;stop-opacity:1"
+         offset="0" />
+      <stop
+         id="stop2185-6"
+         style="stop-color:#d3d3d3;stop-opacity:1"
+         offset="1" />
+    </linearGradient>
+    <mask
+       id="mask4722-8">
+      <rect
+         width="52"
+         height="32"
+         x="1"
+         y="6"
+         id="rect4724-8"
+         style="fill:url(#linearGradient4726-4);fill-opacity:1;stroke:none" />
+    </mask>
+    <linearGradient
+       x1="50.23077"
+       y1="22"
+       x2="53"
+       y2="22"
+       id="linearGradient4726-4"
+       xlink:href="#linearGradient4708-3"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(4.3333333,0,0,1,-176.66667,0)" />
+    <linearGradient
+       id="linearGradient4708-3">
+      <stop
+         id="stop4710-1"
+         style="stop-color:white;stop-opacity:1"
+         offset="0" />
+      <stop
+         id="stop4712-4"
+         style="stop-color:black;stop-opacity:1"
+         offset="0.57954973" />
+      <stop
+         id="stop4714-9"
+         style="stop-color:black;stop-opacity:1"
+         offset="1" />
+    </linearGradient>
+    <linearGradient
+       y2="47"
+       x2="30"
+       y1="17"
+       x1="30"
+       gradientTransform="translate(0,-9.9999992)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2940"
+       xlink:href="#linearGradient2181-7"
+       inkscape:collect="always" />
+    <inkscape:perspective
+       id="perspective2894"
+       inkscape:persp3d-origin="0.5 : 0.33333333 : 1"
+       inkscape:vp_z="1 : 0.5 : 1"
+       inkscape:vp_y="0 : 1000 : 0"
+       inkscape:vp_x="0 : 0.5 : 1"
+       sodipodi:type="inkscape:persp3d" />
+  </defs>
+  <rect
+     width="46"
+     height="29"
+     x="2.5"
+     y="7.5"
+     mask="url(#mask4722)"
+     id="rect1333"
+     style="fill:url(#linearGradient2854);fill-opacity:1;stroke:#2c2c2c;stroke-width:2;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0"
+     transform="translate(-0.20338983,3.4237288)" />
+  <rect
+     width="45"
+     height="27"
+     x="3.5"
+     y="8.5"
+     mask="url(#mask4716)"
+     id="rect2210"
+     style="opacity:0.7;fill:none;stroke:url(#linearGradient2851);stroke-width:0.99999976;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0"
+     transform="translate(-0.20338983,3.4237288)" />
+  <rect
+     style="fill:#ffffff;fill-opacity:1;stroke:#333424;stroke-width:1.5;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0.69999999999999996"
+     id="rect6306"
+     width="29.45332"
+     height="9.5719652"
+     x="10.697065"
+     y="21.044527"
+     rx="1.4456253"
+     ry="1.6443363" />
+</svg>
diff -Nur tint2-0.11/src/tint2conf/theme_view.c tint2-read-only/src/tint2conf/theme_view.c
--- tint2-0.11/src/tint2conf/theme_view.c	2010-06-14 22:08:51.000000000 +0700
+++ tint2-read-only/src/tint2conf/theme_view.c	2010-12-23 00:02:32.219328648 +0600
@@ -1,3 +1,21 @@
+/**************************************************************************
+*
+* Tint2conf
+*
+* Copyright (C) 2009 Thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License version 2
+* as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+**************************************************************************/
 
 
 #include "main.h"
@@ -107,12 +125,12 @@
 
 		pixWidth = gdk_pixbuf_get_width(pixbuf);
 		pixHeight = gdk_pixbuf_get_height(pixbuf);
-		if (g_width_list < pixWidth) {
+		if (g_width_list != pixWidth) {
 			g_width_list = pixWidth;
 			changeSize = TRUE;
 		}
-		if (g_height_list < (pixHeight+6)) {
-			g_height_list = pixHeight+6;
+		if (g_height_list != (pixHeight+30)) {
+			g_height_list = pixHeight+30;
 			changeSize = TRUE;
 		}
 		if (changeSize)
diff -Nur tint2-0.11/src/tint2conf/tint2conf.desktop tint2-read-only/src/tint2conf/tint2conf.desktop
--- tint2-0.11/src/tint2conf/tint2conf.desktop	2010-06-11 19:21:30.000000000 +0700
+++ tint2-read-only/src/tint2conf/tint2conf.desktop	2010-12-23 00:02:32.219328648 +0600
@@ -143,7 +143,7 @@
 Comment[ur_PK]=پینل کی ترتیبات
 Comment[zh_CN]=自定义面板设置
 Exec=tint2conf
-Icon=tint2conf
+Icon=taskbar
 Terminal=false
 Categories=Settings;DesktopSettings;
 
Двоичные файлы tint2-0.11/src/tint2conf/tint2conf.png и tint2-read-only/src/tint2conf/tint2conf.png различаются
diff -Nur tint2-0.11/src/tint2conf/tint2conf.svg tint2-read-only/src/tint2conf/tint2conf.svg
--- tint2-0.11/src/tint2conf/tint2conf.svg	2010-06-12 15:55:58.000000000 +0700
+++ tint2-read-only/src/tint2conf/tint2conf.svg	1970-01-01 07:00:00.000000000 +0700
@@ -1,349 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:xlink="http://www.w3.org/1999/xlink"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   version="1.1"
-   width="48"
-   height="48"
-   id="svg1325"
-   inkscape:version="0.47 r22583"
-   sodipodi:docname="tint2conf.svg"
-   inkscape:export-filename="/home/omega_dist/4_devel_open_source/9_tint/tint2/src/tint2conf/tint2conf.png"
-   inkscape:export-xdpi="90"
-   inkscape:export-ydpi="90">
-  <metadata
-     id="metadata50">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <sodipodi:namedview
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1"
-     objecttolerance="10"
-     gridtolerance="10"
-     guidetolerance="10"
-     inkscape:pageopacity="0"
-     inkscape:pageshadow="2"
-     inkscape:window-width="1024"
-     inkscape:window-height="715"
-     id="namedview48"
-     showgrid="false"
-     inkscape:zoom="4.9166667"
-     inkscape:cx="-14.440678"
-     inkscape:cy="21.9661"
-     inkscape:window-x="0"
-     inkscape:window-y="1"
-     inkscape:window-maximized="1"
-     inkscape:current-layer="svg1325" />
-  <defs
-     id="defs1327">
-    <inkscape:perspective
-       sodipodi:type="inkscape:persp3d"
-       inkscape:vp_x="0 : 24 : 1"
-       inkscape:vp_y="0 : 1000 : 0"
-       inkscape:vp_z="48 : 24 : 1"
-       inkscape:persp3d-origin="24 : 16 : 1"
-       id="perspective52" />
-    <linearGradient
-       id="linearGradient4708">
-      <stop
-         id="stop4710"
-         style="stop-color:white;stop-opacity:1"
-         offset="0" />
-      <stop
-         id="stop4712"
-         style="stop-color:black;stop-opacity:1"
-         offset="0.57954973" />
-      <stop
-         id="stop4714"
-         style="stop-color:black;stop-opacity:1"
-         offset="1" />
-    </linearGradient>
-    <linearGradient
-       id="linearGradient2270">
-      <stop
-         id="stop2272"
-         style="stop-color:white;stop-opacity:1"
-         offset="0" />
-      <stop
-         id="stop2274"
-         style="stop-color:white;stop-opacity:0"
-         offset="1" />
-    </linearGradient>
-    <linearGradient
-       x1="20"
-       y1="18"
-       x2="20"
-       y2="46"
-       id="linearGradient2851"
-       xlink:href="#linearGradient2270"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="translate(0,-9.9999992)" />
-    <linearGradient
-       x1="30"
-       y1="17"
-       x2="30"
-       y2="47"
-       id="linearGradient2854"
-       xlink:href="#linearGradient2181"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="translate(0,-9.9999992)" />
-    <linearGradient
-       x1="63.397362"
-       y1="-12.489107"
-       x2="63.397362"
-       y2="5.4675598"
-       id="linearGradient2685"
-       xlink:href="#linearGradient4873"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(1.5436509,0,0,1.5436158,-80.015712,21.419381)" />
-    <linearGradient
-       id="linearGradient4873">
-      <stop
-         id="stop4875"
-         style="stop-color:white;stop-opacity:1"
-         offset="0" />
-      <stop
-         id="stop4877"
-         style="stop-color:white;stop-opacity:0"
-         offset="1" />
-    </linearGradient>
-    <radialGradient
-       cx="23.895569"
-       cy="3.9900031"
-       r="20.397499"
-       fx="23.895569"
-       fy="3.9900031"
-       id="radialGradient2688"
-       xlink:href="#linearGradient3242-187-536"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(0,1.7008781,-2.245129,0,24.958071,-40.236051)" />
-    <linearGradient
-       id="linearGradient3242-187-536">
-      <stop
-         id="stop2778"
-         style="stop-color:#8badea;stop-opacity:1"
-         offset="0" />
-      <stop
-         id="stop2780"
-         style="stop-color:#6396cd;stop-opacity:1"
-         offset="0.26238" />
-      <stop
-         id="stop2782"
-         style="stop-color:#3b7caf;stop-opacity:1"
-         offset="0.66093999" />
-      <stop
-         id="stop2784"
-         style="stop-color:#194c70;stop-opacity:1"
-         offset="1" />
-    </linearGradient>
-    <linearGradient
-       x1="18.379412"
-       y1="44.980297"
-       x2="18.379412"
-       y2="3.0816143"
-       id="linearGradient2690"
-       xlink:href="#linearGradient2490-182-124"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(0.7126612,0,0,0.7126613,-1.1038706,-1.1038704)" />
-    <linearGradient
-       id="linearGradient2490-182-124">
-      <stop
-         id="stop2788"
-         style="stop-color:#1f4b6a;stop-opacity:1"
-         offset="0" />
-      <stop
-         id="stop2790"
-         style="stop-color:#4083c2;stop-opacity:1"
-         offset="1" />
-    </linearGradient>
-    <radialGradient
-       cx="62.625"
-       cy="4.625"
-       r="10.625"
-       fx="62.625"
-       fy="4.625"
-       id="radialGradient2693"
-       xlink:href="#linearGradient8838"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(1.5058824,0,0,0.37647,-78.305888,26.258824)" />
-    <linearGradient
-       id="linearGradient8838">
-      <stop
-         id="stop8840"
-         style="stop-color:black;stop-opacity:1"
-         offset="0" />
-      <stop
-         id="stop8842"
-         style="stop-color:black;stop-opacity:0"
-         offset="1" />
-    </linearGradient>
-    <linearGradient
-       id="linearGradient2181">
-      <stop
-         id="stop2183"
-         style="stop-color:#f0f0f0;stop-opacity:1"
-         offset="0" />
-      <stop
-         id="stop2185"
-         style="stop-color:#d3d3d3;stop-opacity:1"
-         offset="1" />
-    </linearGradient>
-    <linearGradient
-       x1="50.23077"
-       y1="22"
-       x2="53"
-       y2="22"
-       id="linearGradient4720"
-       xlink:href="#linearGradient4708"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(4.3333333,0,0,1,-176.66667,0)" />
-    <mask
-       id="mask4716">
-      <rect
-         width="52"
-         height="32"
-         x="1"
-         y="6"
-         id="rect4718"
-         style="fill:url(#linearGradient4720);fill-opacity:1;stroke:none" />
-    </mask>
-    <linearGradient
-       x1="50.23077"
-       y1="22"
-       x2="53"
-       y2="22"
-       id="linearGradient4726"
-       xlink:href="#linearGradient4708"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(4.3333333,0,0,1,-176.66667,0)" />
-    <mask
-       id="mask4722">
-      <rect
-         width="52"
-         height="32"
-         x="1"
-         y="6"
-         id="rect4724"
-         style="fill:url(#linearGradient4726);fill-opacity:1;stroke:none" />
-    </mask>
-    <linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4873"
-       id="linearGradient2861"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(1.8085571,0,0,0.74493792,-86.459085,24.622683)"
-       x1="63.397362"
-       y1="-12.489107"
-       x2="63.397362"
-       y2="5.4675598" />
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient3242-187-536"
-       id="radialGradient2864"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(0,0.82083158,-2.630416,0,36.52927,-5.1317867)"
-       cx="23.895569"
-       cy="3.9900031"
-       fx="23.895569"
-       fy="3.9900031"
-       r="20.397499" />
-    <linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient2490-182-124"
-       id="linearGradient2866"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(0.83496113,0,0,0.34392523,5.994833,13.753123)"
-       x1="18.379412"
-       y1="44.980297"
-       x2="18.379412"
-       y2="3.0816143" />
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient8838"
-       id="radialGradient2869"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(1.7643072,0,0,0.18168172,-84.455838,26.958163)"
-       cx="62.625"
-       cy="4.625"
-       fx="62.625"
-       fy="4.625"
-       r="10.625" />
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient8838"
-       id="radialGradient2876"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(1.7643072,0,0,0.18168172,-84.455838,26.958163)"
-       cx="62.625"
-       cy="4.625"
-       fx="62.625"
-       fy="4.625"
-       r="10.625" />
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient3242-187-536"
-       id="radialGradient2878"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(0,0.82083158,-2.630416,0,36.52927,-5.1317867)"
-       cx="23.895569"
-       cy="3.9900031"
-       fx="23.895569"
-       fy="3.9900031"
-       r="20.397499" />
-    <linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient2490-182-124"
-       id="linearGradient2880"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(0.83496113,0,0,0.34392523,5.994833,13.753123)"
-       x1="18.379412"
-       y1="44.980297"
-       x2="18.379412"
-       y2="3.0816143" />
-    <linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4873"
-       id="linearGradient2882"
-       gradientUnits="userSpaceOnUse"
-       gradientTransform="matrix(1.8085571,0,0,0.74493792,-86.459085,24.622683)"
-       x1="63.397362"
-       y1="-12.489107"
-       x2="63.397362"
-       y2="5.4675598" />
-  </defs>
-  <rect
-     width="46"
-     height="29"
-     x="2.5"
-     y="7.5"
-     mask="url(#mask4722)"
-     id="rect1333"
-     style="fill:url(#linearGradient2854);fill-opacity:1;stroke:#323232;stroke-width:0.99999952;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0"
-     transform="translate(-0.20338983,3.4237288)" />
-  <rect
-     width="45"
-     height="27"
-     x="3.5"
-     y="8.5"
-     mask="url(#mask4716)"
-     id="rect2210"
-     style="opacity:0.7;fill:none;stroke:url(#linearGradient2851);stroke-width:0.99999976;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0"
-     transform="translate(-0.20338983,3.4237288)" />
-</svg>
diff -Nur tint2-0.11/src/tint.c tint2-read-only/src/tint.c
--- tint2-0.11/src/tint.c	2010-12-22 23:48:06.348910045 +0600
+++ tint2-read-only/src/tint.c	2010-12-23 00:02:32.319656009 +0600
@@ -3,7 +3,7 @@
 * Tint2 panel
 *
 * Copyright (C) 2007 Pål Staurland (staura@gmail.com)
-* Modified (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr)
+* Modified (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2
@@ -38,9 +38,11 @@
 #include "task.h"
 #include "taskbar.h"
 #include "systraybar.h"
+#include "launcher.h"
 #include "panel.h"
 #include "tooltip.h"
 #include "timer.h"
+#include "xsettings-client.h"
 
 
 void signal_handler(int sig)
@@ -63,6 +65,7 @@
 	default_battery();
 #endif
 	default_clock();
+	default_launcher();
 	default_taskbar();
 	default_tooltip();
 	default_panel();
@@ -91,11 +94,12 @@
 	// Set signal handler
 	signal_pending = 0;
 	struct sigaction sa = { .sa_handler = signal_handler };
+	struct sigaction sa_chld = { .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDWAIT };
 	sigaction(SIGUSR1, &sa, 0);
 	sigaction(SIGINT, &sa, 0);
 	sigaction(SIGTERM, &sa, 0);
 	sigaction(SIGHUP, &sa, 0);
-//	signal(SIGCHLD, SIG_IGN);		// don't have to wait() after fork()
+	sigaction(SIGCHLD, &sa_chld, 0);
 
 	// BSD does not support pselect(), therefore we have to use select and hope that we do not
 	// end up in a race condition there (see 'man select()' on a linux machine for more information)
@@ -132,7 +136,7 @@
 	setlocale (LC_ALL, "");
 	// config file use '.' as decimal separator
 	setlocale(LC_NUMERIC, "POSIX");
-
+	
 	// load default icon
 	gchar *path;
 	const gchar * const *data_dirs;
@@ -153,14 +157,14 @@
 
 void cleanup()
 {
-	cleanup_timeout();
 	cleanup_systray();
-	cleanup_panel();
 	cleanup_tooltip();
 	cleanup_clock();
+	cleanup_launcher();
 #ifdef ENABLE_BATTERY
 	cleanup_battery();
 #endif
+	cleanup_panel();
 	cleanup_config();
 
 	if (default_icon) {
@@ -170,6 +174,7 @@
 	imlib_context_disconnect_display();
 
 	cleanup_server();
+	cleanup_timeout();
 	if (server.dsp) XCloseDisplay(server.dsp);
 }
 
@@ -182,7 +187,7 @@
 		panel->area.width = server.monitor[0].width;
 
 	panel->temp_pmap = XCreatePixmap(server.dsp, server.root_win, panel->area.width, panel->area.height, server.depth);
-	refresh(&panel->area);
+	rendering(panel);
 
 	Imlib_Image img = NULL;
 	imlib_context_set_drawable(panel->temp_pmap);
@@ -277,7 +282,15 @@
 		else
 			return 0;
 	}
-	// no task clicked --> check if taskbar clicked
+	LauncherIcon *icon = click_launcher_icon(panel, e->x, e->y);
+	if (icon) {
+		if (e->button == 1) {
+			return 1;
+		} else {
+			return 0;
+		}
+	}
+	// no launcher/task clicked --> check if taskbar clicked
 	Taskbar *tskbar = click_taskbar(panel, e->x, e->y);
 	if (tskbar && e->button == 1 && panel_mode == MULTI_DESKTOP)
 		return 1;
@@ -359,8 +372,10 @@
 		Taskbar * drag_taskbar = (Taskbar*)task_drag->area.parent;
 		drag_taskbar->area.list = g_slist_remove(drag_taskbar->area.list, task_drag);
 
-		if(event_taskbar->area.posx > drag_taskbar->area.posx || event_taskbar->area.posy > drag_taskbar->area.posy)
-			event_taskbar->area.list = g_slist_prepend(event_taskbar->area.list, task_drag);
+		if(event_taskbar->area.posx > drag_taskbar->area.posx || event_taskbar->area.posy > drag_taskbar->area.posy) {
+			int i = (taskbarname_enabled) ? 1 : 0;
+			event_taskbar->area.list = g_slist_insert(event_taskbar->area.list, task_drag, i);
+		}
 		else
 			event_taskbar->area.list = g_slist_append(event_taskbar->area.list, task_drag);
 
@@ -420,6 +435,15 @@
 		return;
 	}
 
+	if ( click_launcher(panel, e->xbutton.x, e->xbutton.y)) {
+		LauncherIcon *icon = click_launcher_icon(panel, e->xbutton.x, e->xbutton.y);
+		if (icon) {
+			launcher_action(icon);
+		}
+		task_drag = 0;
+		return;
+	}
+
 	Taskbar *tskbar;
 	if ( !(tskbar = click_taskbar(panel, e->xbutton.x, e->xbutton.y)) ) {
 		// TODO: check better solution to keep window below
@@ -458,19 +482,54 @@
 	Window win = e->xproperty.window;
 	Atom at = e->xproperty.atom;
 
+	if (xsettings_client)
+		xsettings_client_process_event(xsettings_client, e);
 	if (win == server.root_win) {
 		if (!server.got_root_win) {
 			XSelectInput (server.dsp, server.root_win, PropertyChangeMask|StructureNotifyMask);
 			server.got_root_win = 1;
 		}
 
+		// Change name of desktops
+		else if (at == server.atom._NET_DESKTOP_NAMES) {
+			if (!taskbarname_enabled) return;
+			GSList *l, *list = server_get_name_of_desktop();
+			int j;
+			gchar *name;
+			Taskbar *tskbar;
+			for (i=0 ; i < nb_panel ; i++) {
+				for (j=0, l=list ; j < panel1[i].nb_desktop ; j++) {
+					if (l) {
+						name = g_strdup(l->data);
+						l = l->next;
+					}
+					else
+						name = g_strdup_printf("%d", j+1);
+					tskbar = &panel1[i].taskbar[j];
+					if (strcmp(name, tskbar->bar_name.name) != 0) {
+						g_free(tskbar->bar_name.name);
+						tskbar->bar_name.name = name;
+						tskbar->bar_name.area.resize = 1;
+					}
+					else
+						g_free(name);
+				}
+			}
+			for (l=list ; l ; l = l->next)
+				g_free(l->data);
+			g_slist_free(list);
+			panel_refresh = 1;
+		}
 		// Change number of desktops
 		else if (at == server.atom._NET_NUMBER_OF_DESKTOPS) {
+			if (!taskbar_enabled) return;
 			server.nb_desktop = server_get_number_of_desktop ();
 			cleanup_taskbar();
 			init_taskbar();
-			visible_object();
 			for (i=0 ; i < nb_panel ; i++) {
+				init_taskbar_panel(&panel1[i]);
+				set_panel_items_order(&panel1[i]);
+				visible_taskbar(&panel1[i]);
 				panel1[i].area.resize = 1;
 			}
 			task_refresh_tasklist();
@@ -479,28 +538,22 @@
 		}
 		// Change desktop
 		else if (at == server.atom._NET_CURRENT_DESKTOP) {
+			if (!taskbar_enabled) return;
 			int old_desktop = server.desktop;
 			server.desktop = server_get_current_desktop ();
 			for (i=0 ; i < nb_panel ; i++) {
 				Panel *panel = &panel1[i];
-				if (panel_mode == MULTI_DESKTOP && panel->g_taskbar.use_active) {
-					// redraw both taskbar
-					if (server.nb_desktop > old_desktop) {
-						// can happen if last desktop is deleted and we've been on the last desktop
-						panel->taskbar[old_desktop].area.bg = panel->g_taskbar.bg;
-						panel->taskbar[old_desktop].area.resize = 1;
-					}
-					panel->taskbar[server.desktop].area.bg = panel->g_taskbar.bg_active;
-					panel->taskbar[server.desktop].area.resize = 1;
-					panel_refresh = 1;
-				}
+				set_taskbar_state(&panel->taskbar[old_desktop], TASKBAR_NORMAL);
+				set_taskbar_state(&panel->taskbar[server.desktop], TASKBAR_ACTIVE);
 				// check ALLDESKTOP task => resize taskbar
 				Taskbar *tskbar;
 				Task *tsk;
 				GSList *l;
 				if (server.nb_desktop > old_desktop) {
 					tskbar = &panel->taskbar[old_desktop];
-					for (l = tskbar->area.list; l ; l = l->next) {
+					l = tskbar->area.list;
+					if (taskbarname_enabled) l = l->next;
+					for (; l ; l = l->next) {
 						tsk = l->data;
 						if (tsk->desktop == ALLDESKTOP) {
 							tsk->area.on_screen = 0;
@@ -510,7 +563,9 @@
 					}
 				}
 				tskbar = &panel->taskbar[server.desktop];
-				for (l = tskbar->area.list; l ; l = l->next) {
+				l = tskbar->area.list;
+				if (taskbarname_enabled) l = l->next;
+				for (; l ; l = l->next) {
 					tsk = l->data;
 					if (tsk->desktop == ALLDESKTOP) {
 						tsk->area.on_screen = 1;
@@ -518,9 +573,6 @@
 					}
 				}
 			}
-			if (panel_mode != MULTI_DESKTOP) {
-				visible_object();
-			}
 		}
 		// Window list
 		else if (at == server.atom._NET_CLIENT_LIST) {
@@ -532,7 +584,7 @@
 			active_task();
 			panel_refresh = 1;
 		}
-		else if (at == server.atom._XROOTPMAP_ID) {
+		else if (at == server.atom._XROOTPMAP_ID || at == server.atom._XROOTMAP_ID) {
 			// change Wallpaper
 			for (i=0 ; i < nb_panel ; i++) {
 				set_panel_background(&panel1[i]);
@@ -564,12 +616,13 @@
 
 		// Window title changed
 		if (at == server.atom._NET_WM_VISIBLE_NAME || at == server.atom._NET_WM_NAME || at == server.atom.WM_NAME) {
-			get_title(tsk);
-			if (g_tooltip.mapped && (g_tooltip.area == (Area*)tsk)) {
-				tooltip_copy_text((Area*)tsk);
-				tooltip_update();
+			if (get_title(tsk)) {
+				if (g_tooltip.mapped && (g_tooltip.area == (Area*)tsk)) {
+					tooltip_copy_text((Area*)tsk);
+					tooltip_update();
+				}
+				panel_refresh = 1;
 			}
-			panel_refresh = 1;
 		}
 		// Demand attention
 		else if (at == server.atom._NET_WM_STATE) {
@@ -754,7 +807,7 @@
 				else {
 					if (panel->temp_pmap) XFreePixmap(server.dsp, panel->temp_pmap);
 					panel->temp_pmap = XCreatePixmap(server.dsp, server.root_win, panel->area.width, panel->area.height, server.depth);
-					refresh(&panel->area);
+					rendering(panel);
 					XCopyArea(server.dsp, panel->temp_pmap, panel->main_win, server.gc, 0, 0, panel->area.width, panel->area.height, 0, 0);
 				}
 			}
@@ -820,19 +873,17 @@
 						if (e.xmotion.state & button_mask)
 							event_button_motion_notify (&e);
 
-						if (!g_tooltip.enabled) break;
 						Panel* panel = get_panel(e.xmotion.window);
 						Area* area = click_area(panel, e.xmotion.x, e.xmotion.y);
 						if (area->_get_tooltip_text)
-							tooltip_trigger_show(area, panel, e.xmotion.x_root, e.xmotion.y_root);
+							tooltip_trigger_show(area, panel, &e);
 						else
 							tooltip_trigger_hide();
 						break;
 					}
 
 					case LeaveNotify:
-						if (g_tooltip.enabled)
-							tooltip_trigger_hide();
+						tooltip_trigger_hide();
 						break;
 
 					case Expose:
@@ -862,7 +913,7 @@
 							signal_pending = SIGUSR1;
 							break;
 						}
-						if (e.xany.window == g_tooltip.window || !systray.area.on_screen)
+						if (e.xany.window == g_tooltip.window || !systray_enabled)
 							break;
 						for (it = systray.list_icons; it; it = g_slist_next(it)) {
 							if (((TrayWindow*)it->data)->tray_id == e.xany.window) {
@@ -870,7 +921,7 @@
 								break;
 							}
 						}
-					break;
+						break;
 
 					case ClientMessage:
 						ev = &e.xclient;
@@ -882,7 +933,7 @@
 								// Start real_transparency
 								signal_pending = SIGUSR1;
 						}
-						if (systray.area.on_screen && e.xclient.message_type == server.atom._NET_SYSTEM_TRAY_OPCODE && e.xclient.format == 32 && e.xclient.window == net_sel_win) {
+						if (systray_enabled && e.xclient.message_type == server.atom._NET_SYSTEM_TRAY_OPCODE && e.xclient.format == 32 && e.xclient.window == net_sel_win) {
 							net_message(&e.xclient);
 						}
 						else if (e.xclient.message_type == server.atom.XdndPosition) {
diff -Nur tint2-0.11/src/tooltip/tooltip.c tint2-read-only/src/tooltip/tooltip.c
--- tint2-0.11/src/tooltip/tooltip.c	2010-04-20 05:06:23.000000000 +0700
+++ tint2-read-only/src/tooltip/tooltip.c	2010-12-23 00:02:32.279485615 +0600
@@ -75,10 +75,13 @@
 }
 
 
-void tooltip_trigger_show(Area* area, Panel* p, int x_root, int y_root)
+void tooltip_trigger_show(Area* area, Panel* p, XEvent *e)
 {
-	x = x_root;
-	y = y_root;
+	// Position the tooltip in the center of the area
+	x = area->posx + area->width / 2 + e->xmotion.x_root - e->xmotion.x;
+	y = area->posy + area->height / 2 + e->xmotion.y_root - e->xmotion.y;
+	if (!panel_horizontal)
+		y -= height/2;
 	g_tooltip.panel = p;
 	if (g_tooltip.mapped && g_tooltip.area != area) {
 		tooltip_copy_text(area);
@@ -93,10 +96,10 @@
 
 void tooltip_show(void* arg)
 {
-  int mx, my;
-  Window w;
-  XTranslateCoordinates( server.dsp, server.root_win, g_tooltip.panel->main_win, x, y, &mx, &my, &w);
-  Area* area = click_area(g_tooltip.panel, mx, my);
+	int mx, my;
+	Window w;
+	XTranslateCoordinates( server.dsp, server.root_win, g_tooltip.panel->main_win, x, y, &mx, &my, &w);
+	Area* area = click_area(g_tooltip.panel, mx, my);
 	stop_tooltip_timeout();
 	if (!g_tooltip.mapped && area->_get_tooltip_text) {
 		tooltip_copy_text(area);
@@ -148,22 +151,22 @@
 	Panel* panel = g_tooltip.panel;
 	int screen_width = server.monitor[panel->monitor].x + server.monitor[panel->monitor].width;
 	int screen_height = server.monitor[panel->monitor].y + server.monitor[panel->monitor].height;
-	if ( x+width <= screen_width && y+height <= screen_height && x>=0 && y>=0)
+	if ( x+width <= screen_width && y+height <= screen_height && x>=server.monitor[panel->monitor].x && y>=server.monitor[panel->monitor].y )
 		return;    // no adjustment needed
 
 	if (panel_horizontal) {
 		min_x=0;
-		max_width=screen_width;
-		max_height=screen_height-panel->area.height;
+		max_width=server.monitor[panel->monitor].width;
+		max_height=server.monitor[panel->monitor].height-panel->area.height;
 		if (panel_position & BOTTOM)
 			min_y=0;
 		else
 			min_y=panel->area.height;
 	}
 	else {
-		max_width=screen_width-panel->area.width;
+		max_width=server.monitor[panel->monitor].width-panel->area.width;
 		min_y=0;
-		max_height=screen_height;
+		max_height=server.monitor[panel->monitor].height;
 		if (panel_position & LEFT)
 			min_x=panel->area.width;
 		else
diff -Nur tint2-0.11/src/tooltip/tooltip.h tint2-read-only/src/tooltip/tooltip.h
--- tint2-0.11/src/tooltip/tooltip.h	2010-04-18 21:28:45.000000000 +0700
+++ tint2-read-only/src/tooltip/tooltip.h	2010-12-23 00:02:32.279485615 +0600
@@ -30,7 +30,6 @@
 	Window window;
 	int show_timeout_msec;
 	int hide_timeout_msec;
-	Bool enabled;
 	Bool mapped;
 	int paddingx;
 	int paddingy;
@@ -50,7 +49,7 @@
 void cleanup_tooltip();
 
 void init_tooltip();
-void tooltip_trigger_show(Area* area, Panel* p, int x, int y);
+void tooltip_trigger_show(Area* area, Panel* p, XEvent *e);
 void tooltip_show(void* /*arg*/);
 void tooltip_update();
 void tooltip_trigger_hide();
diff -Nur tint2-0.11/src/util/area.c tint2-read-only/src/util/area.c
--- tint2-0.11/src/util/area.c	2010-04-18 19:07:36.000000000 +0700
+++ tint2-read-only/src/util/area.c	2010-12-23 00:02:32.309514087 +0600
@@ -2,7 +2,7 @@
 *
 * Tint2 : area
 *
-* Copyright (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr)
+* Copyright (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2
@@ -31,24 +31,183 @@
 #include "panel.h"
 
 
-// 1) resize child
-// 2) resize parent
-// 3) redraw parent
-// 4) redraw child
+/************************************************************
+ * !!! This design is experimental and not yet fully implemented !!!!!!!!!!!!!
+ * 
+ * DATA ORGANISATION :
+ * Areas in tint2 are similar to widgets in a GUI. 
+ * All graphical objects (panel, taskbar, task, systray, clock, ...) 'inherit' an abstract class 'Area'.
+ * This class 'Area' manage the background, border, size, position and padding.
+ * Area is at the begining of each object (&object == &area).
+ * 
+ * tint2 define one panel per monitor. And each panel have a tree of Area.
+ * The root of the tree is Panel.Area. And task, clock, systray, taskbar,... are nodes.
+ * 
+ * The tree give the localisation of each object :
+ * - tree's root is in the background while tree's leafe are foreground objects
+ * - position of a node/Area depend on the layout : parent's position (posx, posy), size of previous brothers and parent's padding
+ * - size of a node/Area depend on the content (SIZE_BY_CONTENT objects) or on the layout (SIZE_BY_LAYOUT objects) 
+ * 
+ * DRAWING AND LAYERING ENGINE :
+ * Redrawing an object (like the clock) could come from an 'external event' (date change) 
+ * or from a 'layering event' (position change).
+ * The following 'drawing engine' take care of :
+ * - posx/posy of all Area
+ * - 'layering event' propagation between object
+ * 1) browse tree SIZE_BY_CONTENT
+ *  - resize SIZE_BY_CONTENT node : children are resized before parent
+ * 	- if 'size' changed then 'resize = 1' on the parent
+ * 2) browse tree SIZE_BY_LAYOUT and POSITION
+ *  - resize SIZE_BY_LAYOUT node : parent is resized before children
+ *  - calculate position (posx,posy) : parent is calculated before children
+ * 	- if 'position' changed then 'redraw = 1'
+ * 3) browse tree REDRAW
+ *  - redraw needed objects : parent is drawn before children
+ *
+ * CONFIGURE PANEL'S LAYOUT :
+ * 'panel_items' parameter (in config) define the list and the order of nodes in tree's panel.
+ * 'panel_items = SC' define a panel with just Systray and Clock.
+ * So the tree 'Panel.Area' will have 2 childs (Systray and Clock).
+ *
+ ************************************************************/
+
+void init_rendering(void *obj, int pos)
+{
+	Area *a = (Area*)obj;
+	
+	// initialize fixed position/size
+	GSList *l;
+	for (l = a->list; l ; l = l->next) {
+		Area *child = ((Area*)l->data);
+		if (panel_horizontal) {
+			child->posy = pos + a->bg->border.width + a->paddingy;
+			child->height = a->height - (2 * (a->bg->border.width + a->paddingy));
+			init_rendering(child, child->posy);
+		}
+		else {
+			child->posx = pos + a->bg->border.width + a->paddingy;
+			child->width = a->width - (2 * (a->bg->border.width + a->paddingy));
+			init_rendering(child, child->posx);
+		}
+	}
+}
+
+
+void rendering(void *obj)
+{
+	Panel *panel = (Panel*)obj;
+
+	size_by_content(&panel->area);
+	size_by_layout(&panel->area, 0, 1);
+	
+	refresh(&panel->area);
+}
+
+
+void size_by_content (Area *a)
+{
+	// don't resize hiden objects
+	if (!a->on_screen) return;
+
+	// children node are resized before its parent
+	GSList *l;
+	for (l = a->list; l ; l = l->next)
+		size_by_content(l->data);
+	
+	// calculate area's size
+	a->on_changed = 0;
+	if (a->resize && a->size_mode == SIZE_BY_CONTENT) {
+		a->resize = 0;
+
+		if (a->_resize) {
+			if (a->_resize(a)) {
+				// 'size' changed => 'resize = 1' on the parent
+				((Area*)a->parent)->resize = 1;
+				a->on_changed = 1;
+			}
+		}
+	}
+}
+
+
+void size_by_layout (Area *a, int pos, int level)
+{
+	// don't resize hiden objects
+	if (!a->on_screen) return;
+
+	// parent node is resized before its children
+	// calculate area's size
+	GSList *l;
+	if (a->resize && a->size_mode == SIZE_BY_LAYOUT) {
+		a->resize = 0;
+
+		if (a->_resize) {
+			a->_resize(a);
+			// resize childs with SIZE_BY_LAYOUT
+			for (l = a->list; l ; l = l->next) {
+				Area *child = ((Area*)l->data);
+				if (child->size_mode == SIZE_BY_LAYOUT && child->list)
+					child->resize = 1;
+			}
+		}
+	}
+
+	// update position of childs
+	pos += a->paddingxlr + a->bg->border.width;
+	int i=0;
+	for (l = a->list; l ; l = l->next) {
+		Area *child = ((Area*)l->data);
+		if (!child->on_screen) continue;
+		i++;
+		
+		if (panel_horizontal) {
+			if (pos != child->posx) {
+				// pos changed => redraw
+				child->posx = pos;
+				child->on_changed = 1;
+			}
+		}
+		else {
+			if (pos != child->posy) {
+				// pos changed => redraw
+				child->posy = pos;
+				child->on_changed = 1;
+			}
+		}
+		
+		/*// position of each visible object
+		int k;
+		for (k=0 ; k < level ; k++) printf("  ");
+		printf("tree level %d, object %d, pos %d, %s\n", level, i, pos, (child->size_mode == SIZE_BY_LAYOUT) ? "SIZE_BY_LAYOUT" : "SIZE_BY_CONTENT");*/
+		size_by_layout(child, pos, level+1);
+		
+		if (panel_horizontal)
+			pos += child->width + a->paddingx;
+		else
+			pos += child->height + a->paddingx;
+	}	
+
+	if (a->on_changed) {
+		// pos/size changed
+		a->redraw = 1;
+		if (a->_on_change_layout)
+			a->_on_change_layout (a);
+	}
+}
+
+
 void refresh (Area *a)
 {
 	// don't draw and resize hide objects
 	if (!a->on_screen) return;
 
-	size(a);
-
 	// don't draw transparent objects (without foreground and without background)
 	if (a->redraw) {
 		a->redraw = 0;
 		// force redraw of child
-		GSList *l;
-		for (l = a->list ; l ; l = l->next)
-			set_redraw(l->data);
+		//GSList *l;
+		//for (l = a->list ; l ; l = l->next)
+			//((Area*)l->data)->redraw = 1;
 
 		//printf("draw area posx %d, width %d\n", a->posx, a->width);
 		draw(a);
@@ -65,23 +224,95 @@
 }
 
 
-void size (Area *a)
+int resize_by_layout(void *obj, int maximum_size)
 {
-	GSList *l;
+	Area *child, *a = (Area*)obj;
+	int size, nb_by_content=0, nb_by_layout=0;
 
-	if (a->resize) {
-		a->resize = 0;
-		// force the resize of childs
-		for (l = a->list; l ; l = l->next) {
-			Area *area = (Area*)l->data;
-			area->resize = 1;
-			size(area);
+	if (panel_horizontal) {		
+		// detect free size for SIZE_BY_LAYOUT's Area
+		size = a->width - (2 * (a->paddingxlr + a->bg->border.width));
+		GSList *l;
+		for (l = a->list ; l ; l = l->next) {
+			child = (Area*)l->data;
+			if (child->on_screen && child->size_mode == SIZE_BY_CONTENT) {
+				size -= child->width;
+				nb_by_content++;
+			}
+			if (child->on_screen && child->size_mode == SIZE_BY_LAYOUT)
+				nb_by_layout++;
+		}
+		//printf("  resize_by_layout Deb %d, %d\n", nb_by_content, nb_by_layout);
+		if (nb_by_content+nb_by_layout)
+			size -= ((nb_by_content+nb_by_layout-1) * a->paddingx);
+
+		int width=0, modulo=0, old_width;
+		if (nb_by_layout) {
+			width = size / nb_by_layout;
+			modulo = size % nb_by_layout;
+			if (width > maximum_size && maximum_size != 0) {
+				width = maximum_size;
+				modulo = 0;
+			}
 		}
 
-		// resize can generate a redraw
-		if (a->_resize)
-			a->_resize(a);
+		// resize SIZE_BY_LAYOUT objects
+		for (l = a->list ; l ; l = l->next) {
+			child = (Area*)l->data;
+			if (child->on_screen && child->size_mode == SIZE_BY_LAYOUT) {
+				old_width = child->width;
+				child->width = width;
+				if (modulo) {
+					child->width++;
+					modulo--;
+				}
+				if (child->width != old_width)
+					child->on_changed = 1;
+			}
+		}
 	}
+	else {
+		// detect free size for SIZE_BY_LAYOUT's Area
+		size = a->height - (2 * (a->paddingxlr + a->bg->border.width));
+		GSList *l;
+		for (l = a->list ; l ; l = l->next) {
+			child = (Area*)l->data;
+			if (child->on_screen && child->size_mode == SIZE_BY_CONTENT) {
+				size -= child->height;
+				nb_by_content++;
+			}
+			if (child->on_screen && child->size_mode == SIZE_BY_LAYOUT)
+				nb_by_layout++;
+		}
+		if (nb_by_content+nb_by_layout)
+			size -= ((nb_by_content+nb_by_layout-1) * a->paddingx);
+
+		int height=0, modulo=0, old_height;
+		if (nb_by_layout) {
+			height = size / nb_by_layout;
+			modulo = size % nb_by_layout;
+			if (height > maximum_size && maximum_size != 0) {
+				height = maximum_size;
+				modulo = 0;
+			}
+		}
+
+		// resize SIZE_BY_LAYOUT objects
+		for (l = a->list ; l ; l = l->next) {
+			child = (Area*)l->data;
+			if (child->on_screen && child->size_mode == SIZE_BY_LAYOUT) {
+				old_height = child->height;
+				child->height = height;
+				if (modulo) {
+					child->height++;
+					modulo--;
+				}
+				if (child->height != old_height)
+					child->on_changed = 1;
+			}
+		}
+	}
+	return 0;
 }
 
 
@@ -94,6 +325,26 @@
 		set_redraw(l->data);
 }
 
+void hide(Area *a)
+{
+	Area *parent = (Area*)a->parent;
+
+	a->on_screen = 0;
+	parent->resize = 1;
+	if (panel_horizontal)
+		a->width = 0;
+	else
+		a->height = 0;
+}
+
+void show(Area *a)
+{
+	Area *parent = (Area*)a->parent;
+
+	a->on_screen = 1;
+	parent->resize = 1;
+	a->resize = 1;
+}
 
 void draw (Area *a)
 {
@@ -137,9 +388,9 @@
 		draw_rect(c, a->bg->border.width/2.0, a->bg->border.width/2.0, a->width - a->bg->border.width, a->height - a->bg->border.width, a->bg->border.rounded);
 		/*
 		// convert : radian = degre * M_PI/180
-		// définir le dégradé dans un carré de (0,0) (100,100)
-		// ensuite ce dégradé est extrapolé selon le ratio width/height
-		// dans repère (0, 0) (100, 100)
+		// definir le degrade dans un carre de (0,0) (100,100)
+		// ensuite ce degrade est extrapoler selon le ratio width/height
+		// dans repere (0, 0) (100, 100)
 		double X0, Y0, X1, Y1, degre;
 		// x = X * (a->width / 100), y = Y * (a->height / 100)
 		double x0, y0, x1, y1;
@@ -148,13 +399,13 @@
 		X1 = 100;
 		Y1 = 0;
 		degre = 45;
-		// et ensuite faire la changement d'unité du repère
-		// car ce qui doit resté inchangée est les traits et pas la direction
+		// et ensuite faire la changement d'unite du repere
+		// car ce qui doit reste inchangee est les traits et pas la direction
 
-		// il faut d'abord appliquer une rotation de 90° (et -180° si l'angle est supérieur à 180°)
-		// ceci peut être appliqué une fois pour toute au départ
-		// ensuite calculer l'angle dans le nouveau repère
-		// puis faire une rotation de 90°
+		// il faut d'abord appliquer une rotation de 90 (et -180 si l'angle est superieur a  180)
+		// ceci peut etre applique une fois pour toute au depart
+		// ensuite calculer l'angle dans le nouveau repare
+		// puis faire une rotation de 90
 		x0 = X0 * ((double)a->width / 100);
 		x1 = X1 * ((double)a->width / 100);
 		y0 = Y0 * ((double)a->height / 100);
diff -Nur tint2-0.11/src/util/area.h tint2-read-only/src/util/area.h
--- tint2-0.11/src/util/area.h	2010-01-09 06:11:01.000000000 +0600
+++ tint2-read-only/src/util/area.h	2010-12-23 00:02:32.309514087 +0600
@@ -47,6 +47,10 @@
 } Background;
 
 
+// way to calculate the size
+// SIZE_BY_LAYOUT objects : taskbar and task
+// SIZE_BY_CONTENT objects : clock, battery, launcher, systray
+enum { SIZE_BY_LAYOUT, SIZE_BY_CONTENT };
 
 typedef struct {
 	// coordinate relative to panel window
@@ -59,8 +63,12 @@
 	// list of child : Area object
 	GSList *list;
 
+	// object visible on screen. 
+	// An object (like systray) could be enabled but hidden (because no tray icon).
 	int on_screen;
-	// need compute position and width
+	// way to calculate the size (SIZE_BY_CONTENT or SIZE_BY_LAYOUT)
+	int size_mode;
+	// need to calculate position and width
 	int resize;
 	// need redraw Pixmap
 	int redraw;
@@ -74,22 +82,34 @@
 
 	// each object can overwrite following function
 	void (*_draw_foreground)(void *obj, cairo_t *c);
-	void (*_resize)(void *obj);
-	void (*_add_child)(void *obj);
-	int (*_remove_child)(void *obj);
+	// update area's content and update size (width/heith). 
+	// return '1' if size changed, '0' otherwise.
+	int (*_resize)(void *obj);
+	// after pos/size changed, the rendering engine will call _on_change_layout(Area*)
+	int on_changed;
+	void (*_on_change_layout)(void *obj);
 	const char* (*_get_tooltip_text)(void *obj);
 } Area;
 
+// on startup, initialize fixed pos/size
+void init_rendering(void *obj, int pos);
 
-
+void rendering(void *obj);
+void size_by_content (Area *a);
+void size_by_layout (Area *a, int pos, int level);
 // draw background and foreground
 void refresh (Area *a);
-
-void size (Area *a);
+ 
+// generic resize for SIZE_BY_LAYOUT objects
+int resize_by_layout(void *obj, int maximum_size);
 
 // set 'redraw' on an area and childs
 void set_redraw (Area *a);
 
+// hide/unhide area
+void hide(Area *a);
+void show(Area *a);
+
 // draw pixmap
 void draw (Area *a);
 void draw_background (Area *a, cairo_t *c);
diff -Nur tint2-0.11/src/util/common.c tint2-read-only/src/util/common.c
--- tint2-0.11/src/util/common.c	2010-06-12 01:47:26.000000000 +0700
+++ tint2-read-only/src/util/common.c	2010-12-23 00:02:32.309514087 +0600
@@ -3,7 +3,7 @@
 * Tint2 : common windows function
 *
 * Copyright (C) 2007 Pål Staurland (staura@gmail.com)
-* Modified (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr)
+* Modified (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2
diff -Nur tint2-0.11/src/util/timer.c tint2-read-only/src/util/timer.c
--- tint2-0.11/src/util/timer.c	2010-04-24 00:27:34.000000000 +0700
+++ tint2-read-only/src/util/timer.c	2010-12-23 00:02:32.309514087 +0600
@@ -77,6 +77,10 @@
 		free(t);
 		timeout_list = g_slist_remove(timeout_list, t);
 	}
+	if (multi_timeouts) {
+		g_hash_table_destroy(multi_timeouts);
+		multi_timeouts = 0;
+	}
 }
 
 /** Implementation notes for timeouts: The timeouts are kept in a GSList sorted by their
@@ -394,6 +398,7 @@
 
 	if (g_slist_length(mth->timeout_list) == 1) {
 		timeout* last_timeout = mth->timeout_list->data;
+		mth->timeout_list = g_slist_remove(mth->timeout_list, last_timeout);
 		free(last_timeout->multi_timeout);
 		last_timeout->multi_timeout = 0;
 		g_hash_table_remove(multi_timeouts, last_timeout);
diff -Nur tint2-0.11/src/util/window.c tint2-read-only/src/util/window.c
--- tint2-0.11/src/util/window.c	2010-02-09 04:44:56.000000000 +0600
+++ tint2-read-only/src/util/window.c	2010-12-23 00:02:32.309514087 +0600
@@ -3,7 +3,7 @@
 * Tint2 : common windows function
 *
 * Copyright (C) 2007 Pål Staurland (staura@gmail.com)
-* Modified (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr)
+* Modified (C) 2008 thierry lorthiois (lorthiois@bbsoft.fr) from Omega distribution
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2
@@ -87,9 +87,12 @@
 			return 1;
 		}
 		// do not add transient_for windows if the transient window is already in the taskbar
-		if ( XGetTransientForHint(server.dsp, win, &window) && task_get_tasks(window) ) {
-			XFree(at);
-			return 1;
+		window=win;
+		while ( XGetTransientForHint(server.dsp, window, &window) ) {
+			if ( task_get_tasks(window) ) {
+				XFree(at);
+				return 1;
+			}
 		}
 	}
 	XFree(at);
@@ -200,6 +203,26 @@
 }
 
 
+GSList *server_get_name_of_desktop ()
+{
+	int count, j;
+	GSList *list = NULL;
+	gchar *data_ptr, *ptr;
+	data_ptr = server_get_property (server.root_win, server.atom._NET_DESKTOP_NAMES, server.atom.UTF8_STRING, &count);
+	if (data_ptr) {
+		list = g_slist_append(list, g_strdup(data_ptr));
+		for (j = 0; j < count-1; j++) {
+			if (*(data_ptr + j)	== '\0') {
+				ptr = (gchar*)data_ptr + j + 1;
+				list = g_slist_append(list, g_strdup(ptr));
+			}
+		}
+		XFree(data_ptr);
+	}
+	return list;
+}
+
+
 int server_get_current_desktop ()
 {
 	return get_property32(server.root_win, server.atom._NET_CURRENT_DESKTOP, XA_CARDINAL);
@@ -218,17 +241,17 @@
 }
 
 
-int get_icon_count (long *data, int num)
+int get_icon_count (gulong *data, int num)
 {
 	int count, pos, w, h;
 
 	count = 0;
 	pos = 0;
-	while (pos < num) {
+	while (pos+2 < num) {
 		w = data[pos++];
 		h = data[pos++];
 		pos += w * h;
-		if (pos > num || w * h == 0) break;
+		if (pos > num || w <= 0 || h <= 0) break;
 		count++;
 	}
 
@@ -236,10 +259,10 @@
 }
 
 
-long *get_best_icon (long *data, int icon_count, int num, int *iw, int *ih, int best_icon_size)
+gulong *get_best_icon (gulong *data, int icon_count, int num, int *iw, int *ih, int best_icon_size)
 {
 	int width[icon_count], height[icon_count], pos, i, w, h;
-	long *icon_data[icon_count];
+	gulong *icon_data[icon_count];
 
 	/* List up icons */
 	pos = 0;
@@ -307,3 +330,29 @@
 }
 
 
+void get_text_size2(PangoFontDescription *font, int *height_ink, int *height, int *width, int panel_height, int panel_with, char *text, int len)
+{
+	PangoRectangle rect_ink, rect;
+
+	Pixmap pmap = XCreatePixmap (server.dsp, server.root_win, panel_height, panel_height, server.depth);
+
+	cairo_surface_t *cs = cairo_xlib_surface_create (server.dsp, pmap, server.visual, panel_height, panel_with);
+	cairo_t *c = cairo_create (cs);
+
+	PangoLayout *layout = pango_cairo_create_layout (c);
+	pango_layout_set_font_description (layout, font);
+	pango_layout_set_text (layout, text, len);
+
+	pango_layout_get_pixel_extents(layout, &rect_ink, &rect);
+	*height_ink = rect_ink.height;
+	*height = rect.height;
+	*width = rect.width;
+	//printf("dimension : %d - %d\n", rect_ink.height, rect.height);
+
+	g_object_unref (layout);
+	cairo_destroy (c);
+	cairo_surface_destroy (cs);
+	XFreePixmap (server.dsp, pmap);
+}
+
+
diff -Nur tint2-0.11/src/util/window.h tint2-read-only/src/util/window.h
--- tint2-0.11/src/util/window.h	2009-09-08 04:41:21.000000000 +0700
+++ tint2-read-only/src/util/window.h	2010-12-23 00:02:32.309514087 +0600
@@ -9,6 +9,7 @@
 #ifndef WINDOW_H
 #define WINDOW_H
 
+#include <glib.h>
 #include <pango/pangocairo.h>
 
 
@@ -17,13 +18,14 @@
 void set_close (Window win);
 int server_get_current_desktop ();
 int server_get_number_of_desktop ();
+GSList *server_get_name_of_desktop ();
 int window_is_iconified (Window win);
 int window_is_urgent (Window win);
 int window_is_hidden (Window win);
 int window_is_active (Window win);
 int window_is_skip_taskbar (Window win);
-int get_icon_count (long *data, int num);
-long *get_best_icon (long *data, int icon_count, int num, int *iw, int *ih, int best_icon_size);
+int get_icon_count (gulong *data, int num);
+gulong *get_best_icon (gulong *data, int icon_count, int num, int *iw, int *ih, int best_icon_size);
 void window_maximize_restore (Window win);
 void window_toggle_shade (Window win);
 int window_get_desktop (Window win);
@@ -32,6 +34,7 @@
 Window window_get_active ();
 
 void get_text_size(PangoFontDescription *font, int *height_ink, int *height, int panel_height, char *text, int len);
+void get_text_size2(PangoFontDescription *font, int *height_ink, int *height, int *width, int panel_height, int panel_with, char *text, int len);
 
 
 #endif
