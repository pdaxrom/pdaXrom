diff -Nur linux-2.6.36-rc7/arch/powerpc/configs/ps3_defconfig ps3-linux/arch/powerpc/configs/ps3_defconfig
--- linux-2.6.36-rc7/arch/powerpc/configs/ps3_defconfig	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/configs/ps3_defconfig	2010-12-04 16:17:46.419965840 +0600
@@ -1,56 +1,474 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.36-rc1
+# Tue Aug 17 15:27:31 2010
+#
 CONFIG_PPC64=y
+
+#
+# Processor support
+#
+CONFIG_PPC_BOOK3S_64=y
+# CONFIG_PPC_BOOK3E_64 is not set
+CONFIG_PPC_BOOK3S=y
+# CONFIG_POWER4_ONLY is not set
+CONFIG_POWER3=y
+CONFIG_POWER4=y
 CONFIG_TUNE_CELL=y
+CONFIG_PPC_FPU=y
 CONFIG_ALTIVEC=y
+# CONFIG_VSX is not set
+CONFIG_PPC_STD_MMU=y
+CONFIG_PPC_STD_MMU_64=y
+CONFIG_PPC_MM_SLICES=y
+CONFIG_VIRT_CPU_ACCOUNTING=y
+CONFIG_PPC_HAVE_PMU_SUPPORT=y
+CONFIG_PPC_PERF_CTRS=y
 CONFIG_SMP=y
 CONFIG_NR_CPUS=2
+CONFIG_64BIT=y
+CONFIG_WORD_SIZE=64
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_MMU=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_IRQ_PER_CPU=y
+CONFIG_NR_IRQS=512
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_ILOG2_U32=y
+CONFIG_ARCH_HAS_ILOG2_U64=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_ARCH_NO_VIRT_TO_BUS=y
+CONFIG_PPC=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_COMPAT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_PPC_OF=y
+# CONFIG_PPC_UDBG_16550 is not set
+# CONFIG_GENERIC_TBSYNC is not set
+CONFIG_AUDIT_ARCH=y
+CONFIG_GENERIC_BUG=y
+# CONFIG_DEFAULT_UIMAGE is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+# CONFIG_PPC_DCR_NATIVE is not set
+# CONFIG_PPC_DCR_MMIO is not set
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
 CONFIG_EXPERIMENTAL=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
 CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=64
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
 CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
 CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
 CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
 CONFIG_KALLSYMS_EXTRA_PASS=y
-# CONFIG_PERF_EVENTS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
 # CONFIG_COMPAT_BRK is not set
 CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
 CONFIG_PROFILING=y
 CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_SYSCALL_WRAPPERS=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
 CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
 CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_FREEZER is not set
+
+#
+# Platform support
+#
 # CONFIG_PPC_PSERIES is not set
+# CONFIG_PPC_ISERIES is not set
 # CONFIG_PPC_PMAC is not set
+# CONFIG_PPC_MAPLE is not set
+# CONFIG_PPC_PASEMI is not set
 CONFIG_PPC_PS3=y
+
+#
+# PS3 Platform Options
+#
+# CONFIG_PS3_ADVANCED is not set
+CONFIG_PS3_HTAB_SIZE=20
+# CONFIG_PS3_DYNAMIC_DMA is not set
+CONFIG_PS3_VUART=y
+CONFIG_PS3_PS3AV=y
+CONFIG_PS3_SYS_MANAGER=y
+CONFIG_PS3_STORAGE=y
 CONFIG_PS3_DISK=y
 CONFIG_PS3_ROM=y
 CONFIG_PS3_FLASH=y
 CONFIG_PS3_VRAM=m
 CONFIG_PS3_LPM=m
+CONFIG_OPROFILE_PS3=y
+CONFIG_PS3_DEBUG_BOOT_MEM_LIMIT=-1
+CONFIG_PS3_DEBUG_HOT_PLUG_MEM_LIMIT=-1
+CONFIG_PPC_CELL=y
+# CONFIG_PPC_CELL_NATIVE is not set
+# CONFIG_PPC_IBM_CELL_BLADE is not set
+# CONFIG_PPC_CELLEB is not set
+# CONFIG_PPC_CELL_QPACE is not set
+
+#
+# Cell Broadband Engine options
+#
+CONFIG_SPU_FS=m
+CONFIG_SPU_FS_64K_LS=y
+CONFIG_SPU_BASE=y
+# CONFIG_PQ2ADS is not set
 # CONFIG_PPC_OF_BOOT_TRAMPOLINE is not set
+# CONFIG_IPIC is not set
+# CONFIG_MPIC is not set
+# CONFIG_MPIC_WEIRD is not set
+# CONFIG_PPC_I8259 is not set
+# CONFIG_U3_DART is not set
+# CONFIG_PPC_RTAS is not set
+# CONFIG_MMIO_NVRAM is not set
+# CONFIG_PPC_MPC106 is not set
+# CONFIG_PPC_970_NAP is not set
+# CONFIG_PPC_INDIRECT_IO is not set
+# CONFIG_GENERIC_IOMAP is not set
+# CONFIG_CPU_FREQ is not set
+# CONFIG_FSL_ULI1575 is not set
+# CONFIG_SIMPLE_GPIO is not set
+
+#
+# Kernel options
+#
+CONFIG_TICK_ONESHOT=y
+# CONFIG_NO_HZ is not set
 CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_HAVE_AOUT is not set
 CONFIG_BINFMT_MISC=y
+CONFIG_HUGETLB_PAGE_SIZE_VARIABLE=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_SWIOTLB is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_ARCH_HAS_WALK_MEMORY=y
+CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE=y
 CONFIG_KEXEC=y
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_IRQ_ALL_CPUS is not set
 CONFIG_SPARSE_IRQ=y
+# CONFIG_NUMA is not set
+CONFIG_MAX_ACTIVE_REGIONS=256
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SYS_SUPPORTS_HUGETLBFS=y
+CONFIG_SELECT_MEMORY_MODEL=y
+# CONFIG_FLATMEM_MANUAL is not set
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
 # CONFIG_SPARSEMEM_VMEMMAP is not set
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_MEMORY_HOTPLUG=y
+CONFIG_MEMORY_HOTPLUG_SPARSE=y
+# CONFIG_MEMORY_HOTREMOVE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ARCH_MEMORY_PROBE=y
+CONFIG_PPC_HAS_HASH_64K=y
+CONFIG_PPC_4K_PAGES=y
+# CONFIG_PPC_64K_PAGES is not set
+CONFIG_FORCE_MAX_ZONEORDER=13
 CONFIG_SCHED_SMT=y
 CONFIG_CMDLINE_BOOL=y
 CONFIG_CMDLINE=""
+CONFIG_EXTRA_TARGETS=""
 CONFIG_PM=y
 CONFIG_PM_DEBUG=y
+# CONFIG_PM_ADVANCED_DEBUG is not set
+# CONFIG_PM_VERBOSE is not set
+# CONFIG_HIBERNATION is not set
+# CONFIG_PM_RUNTIME is not set
 # CONFIG_SECCOMP is not set
+CONFIG_ISA_DMA_API=y
+
+#
+# Bus options
+#
+CONFIG_ZONE_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_PPC_PCI_CHOICE=y
 # CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+# CONFIG_HAS_RAPIDIO is not set
+# CONFIG_RELOCATABLE is not set
+CONFIG_PAGE_OFFSET=0xc000000000000000
+CONFIG_KERNEL_START=0xc000000000000000
+CONFIG_PHYSICAL_START=0x00000000
 CONFIG_NET=y
+CONFIG_COMPAT_NETLINK_MESSAGES=y
+
+#
+# Networking options
+#
 CONFIG_PACKET=y
 CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
 # CONFIG_INET_XFRM_MODE_TRANSPORT is not set
 # CONFIG_INET_XFRM_MODE_TUNNEL is not set
 # CONFIG_INET_XFRM_MODE_BEET is not set
 # CONFIG_INET_LRO is not set
 # CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
 CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+CONFIG_RPS=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
 CONFIG_BT=m
 CONFIG_BT_L2CAP=m
 CONFIG_BT_SCO=m
@@ -60,133 +478,1079 @@
 CONFIG_BT_BNEP_MC_FILTER=y
 CONFIG_BT_BNEP_PROTO_FILTER=y
 CONFIG_BT_HIDP=m
+
+#
+# Bluetooth device drivers
+#
 CONFIG_BT_HCIBTUSB=m
+# CONFIG_BT_HCIUART is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+# CONFIG_BT_ATH3K is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
 CONFIG_CFG80211=m
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
 # CONFIG_WIRELESS_EXT_SYSFS is not set
+# CONFIG_LIB80211 is not set
 CONFIG_MAC80211=m
+CONFIG_MAC80211_HAS_RC=y
 CONFIG_MAC80211_RC_PID=y
 # CONFIG_MAC80211_RC_MINSTREL is not set
+CONFIG_MAC80211_RC_DEFAULT_PID=y
+CONFIG_MAC80211_RC_DEFAULT="pid"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_LEDS is not set
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
 # CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+
+#
+# Flattened Device Tree and Open Firmware support
+#
 CONFIG_PROC_DEVICETREE=y
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_DYNAMIC=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_DEVICE=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
 CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=65535
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
 CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
 CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
 CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
 CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
 CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
 # CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
 CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
 CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+# CONFIG_DM_CRYPT is not set
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
 CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
 CONFIG_NET_ETHERNET=y
+CONFIG_MII=m
+# CONFIG_ETHOC is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_NETDEV_1000=y
 CONFIG_GELIC_NET=y
 CONFIG_GELIC_WIRELESS=y
+# CONFIG_XILINX_LL_TEMAC is not set
 # CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN=y
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_ATH_COMMON is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_P54_COMMON is not set
+# CONFIG_RT2X00 is not set
+# CONFIG_WL12XX is not set
+# CONFIG_ZD1211RW is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
 CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
 # CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_CDC_EEM is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
 # CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
 # CONFIG_USB_NET_CDC_SUBSET is not set
 # CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_USB_SIERRA_NET=m
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
 CONFIG_PPP=m
 CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_FILTER is not set
 CONFIG_PPP_ASYNC=m
+# CONFIG_PPP_SYNC_TTY is not set
 CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
 CONFIG_PPPOE=m
+# CONFIG_SLIP is not set
+CONFIG_SLHC=m
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
 CONFIG_INPUT_FF_MEMLESS=m
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
 # CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 CONFIG_INPUT_JOYDEV=m
 CONFIG_INPUT_EVDEV=m
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
 # CONFIG_INPUT_KEYBOARD is not set
 # CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
 # CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_GRLIB_GAISLER_APBUART is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
 # CONFIG_LEGACY_PTYS is not set
+# CONFIG_HVC_UDBG is not set
+# CONFIG_IPMI_HANDLER is not set
 # CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_MFD_SUPPORT=y
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
 CONFIG_VIDEO_OUTPUT_CONTROL=m
 CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_OF is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_IBM_GXT4500 is not set
 CONFIG_FB_PS3=y
+CONFIG_FB_PS3_DEFAULT_SIZE_M=9
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
 # CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
 CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
 CONFIG_LOGO=y
+CONFIG_FB_LOGO_EXTRA=y
 # CONFIG_LOGO_LINUX_MONO is not set
 # CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
 CONFIG_SOUND=m
+# CONFIG_SOUND_OSS_CORE is not set
 CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=m
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
 # CONFIG_SND_DRIVERS is not set
+CONFIG_SND_PPC=y
+CONFIG_SND_PS3=m
+CONFIG_SND_PS3_DEFAULT_START_DELAY=2000
+CONFIG_SND_USB=y
 CONFIG_SND_USB_AUDIO=m
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_USX2Y is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
 CONFIG_HIDRAW=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+# CONFIG_HID_PID is not set
 CONFIG_USB_HIDDEV=y
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_3M_PCT is not set
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX_FF is not set
 CONFIG_HID_APPLE=m
 CONFIG_HID_BELKIN=m
+# CONFIG_HID_CANDO is not set
 CONFIG_HID_CHERRY=m
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EGALAX is not set
+# CONFIG_HID_ELECOM is not set
 CONFIG_HID_EZKEY=m
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_GYRATION is not set
 CONFIG_HID_TWINHAN=m
+# CONFIG_HID_KENSINGTON is not set
 CONFIG_HID_LOGITECH=m
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_HID_MAGICMOUSE is not set
 CONFIG_HID_MICROSOFT=m
+# CONFIG_HID_MOSART is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_QUANTA is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_ROCCAT_KONE is not set
+# CONFIG_HID_SAMSUNG is not set
 CONFIG_HID_SONY=m
+# CONFIG_HID_STANTUM is not set
 CONFIG_HID_SUNPLUS=m
+# CONFIG_HID_GREENASIA is not set
 CONFIG_HID_SMARTJOYPLUS=m
+# CONFIG_SMARTJOYPLUS_FF is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
 CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
 CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
 CONFIG_USB_DEVICEFS=y
 # CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
 CONFIG_USB_MON=m
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
 CONFIG_USB_EHCI_HCD=m
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
 CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_BIG_ENDIAN_MMIO=y
 # CONFIG_USB_EHCI_HCD_PPC_OF is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
 CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_HCD_PPC_OF_BE is not set
+# CONFIG_USB_OHCI_HCD_PPC_OF_LE is not set
+# CONFIG_USB_OHCI_HCD_PPC_OF is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+CONFIG_USB_OHCI_BIG_ENDIAN_MMIO=y
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# Enable Host or Gadget support to see Inventra options
+#
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
 CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=m
 CONFIG_RTC_CLASS=m
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_GENERIC is not set
 CONFIG_RTC_DRV_PS3=m
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
 CONFIG_EXT2_FS=m
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=m
 # CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
 CONFIG_EXT4_FS=y
-CONFIG_INOTIFY=y
+CONFIG_EXT4_FS_XATTR=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=m
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
 CONFIG_QUOTA=y
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
 CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
 CONFIG_AUTOFS_FS=m
 CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
 CONFIG_ISO9660_FS=m
 CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
 CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+# CONFIG_MSDOS_FS is not set
 CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
 CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
 CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
 CONFIG_ROOT_NFS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CEPH_FS is not set
 CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_UPCALL is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_DFS_UPCALL is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
 CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
 CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
 CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
 CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_COMPRESS=m
+CONFIG_LZO_DECOMPRESS=m
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
 CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
 CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
 CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
 CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_DEBUG_LOCK_ALLOC=y
 CONFIG_PROVE_LOCKING=y
+# CONFIG_PROVE_RCU is not set
+CONFIG_LOCKDEP=y
+# CONFIG_LOCK_STAT is not set
 CONFIG_DEBUG_LOCKDEP=y
+CONFIG_TRACE_IRQFLAGS=y
 CONFIG_DEBUG_SPINLOCK_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
 CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
 CONFIG_DEBUG_WRITECOUNT=y
 CONFIG_DEBUG_MEMORY_INIT=y
 CONFIG_DEBUG_LIST=y
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_RCU_TORTURE_TEST is not set
 # CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
 CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_RING_BUFFER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_TRACING_SUPPORT=y
 # CONFIG_FTRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_PPC_DISABLE_WERROR is not set
+CONFIG_PPC_WERROR=y
+CONFIG_PRINT_STACK_DEPTH=64
 CONFIG_DEBUG_STACKOVERFLOW=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_PPC_EMULATED_STATS is not set
+# CONFIG_CODE_PATCHING_SELFTEST is not set
+# CONFIG_FTR_FIXUP_SELFTEST is not set
+# CONFIG_MSI_BITMAP_SELFTEST is not set
+# CONFIG_XMON is not set
+# CONFIG_VIRQ_DEBUG is not set
+# CONFIG_BOOTX_TEXT is not set
+# CONFIG_PPC_EARLY_DEBUG is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_KEYS_COMPAT=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_MANAGER_TESTS is not set
+CONFIG_CRYPTO_GF128MUL=m
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
 CONFIG_CRYPTO_CCM=m
 CONFIG_CRYPTO_GCM=m
+CONFIG_CRYPTO_SEQIV=m
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=m
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=m
+# CONFIG_CRYPTO_LRW is not set
 CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+CONFIG_CRYPTO_GHASH=m
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
 CONFIG_CRYPTO_MICHAEL_MIC=m
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=m
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
 CONFIG_CRYPTO_SALSA20=m
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
 CONFIG_CRYPTO_LZO=m
+
+#
+# Random Number Generation
+#
 # CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_PPC_CLOCK is not set
+# CONFIG_VIRTUALIZATION is not set
diff -Nur linux-2.6.36-rc7/arch/powerpc/include/asm/cell-pmu.h ps3-linux/arch/powerpc/include/asm/cell-pmu.h
--- linux-2.6.36-rc7/arch/powerpc/include/asm/cell-pmu.h	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/include/asm/cell-pmu.h	2010-12-04 16:17:46.419965840 +0600
@@ -75,33 +75,136 @@
 	pm_start_stop,
 };
 
-/* Routines for reading/writing the PMU registers. */
-extern u32  cbe_read_phys_ctr(u32 cpu, u32 phys_ctr);
-extern void cbe_write_phys_ctr(u32 cpu, u32 phys_ctr, u32 val);
-extern u32  cbe_read_ctr(u32 cpu, u32 ctr);
-extern void cbe_write_ctr(u32 cpu, u32 ctr, u32 val);
-
-extern u32  cbe_read_pm07_control(u32 cpu, u32 ctr);
-extern void cbe_write_pm07_control(u32 cpu, u32 ctr, u32 val);
-extern u32  cbe_read_pm(u32 cpu, enum pm_reg_name reg);
-extern void cbe_write_pm(u32 cpu, enum pm_reg_name reg, u32 val);
-
-extern u32  cbe_get_ctr_size(u32 cpu, u32 phys_ctr);
-extern void cbe_set_ctr_size(u32 cpu, u32 phys_ctr, u32 ctr_size);
-
-extern void cbe_enable_pm(u32 cpu);
-extern void cbe_disable_pm(u32 cpu);
-
-extern void cbe_read_trace_buffer(u32 cpu, u64 *buf);
-
-extern void cbe_enable_pm_interrupts(u32 cpu, u32 thread, u32 mask);
-extern void cbe_disable_pm_interrupts(u32 cpu);
-extern u32  cbe_get_and_clear_pm_interrupts(u32 cpu);
-extern void cbe_sync_irq(int node);
-
 #define CBE_COUNT_SUPERVISOR_MODE       0
 #define CBE_COUNT_HYPERVISOR_MODE       1
 #define CBE_COUNT_PROBLEM_MODE          2
 #define CBE_COUNT_ALL_MODES             3
 
+/**
+ * struct cell_pmu_ops - Provides a platfrom independent PMU abstraction.
+ * @priv: Void pointer variable for platform driver use.
+ */
+
+struct cell_pmu_ops {
+	void* priv;
+	u32 (*read_phys_ctr)(void* p, u32 cpu, u32 phys_ctr);
+	void (*write_phys_ctr)(void* p, u32 cpu, u32 phys_ctr, u32 val);
+	u32 (*read_ctr)(void* p, u32 cpu, u32 ctr);
+	void (*write_ctr)(void* p, u32 cpu, u32 ctr, u32 val);
+	u32 (*read_pm07_control)(void* p, u32 cpu, u32 ctr);
+	void (*write_pm07_control)(void* p, u32 cpu, u32 ctr, u32 val);
+	u32 (*read_pm)(void* p, u32 cpu, enum pm_reg_name reg);
+	void (*write_pm)(void* p, u32 cpu, enum pm_reg_name reg, u32 val);
+	u32  (*get_ctr_size)(void* p, u32 cpu, u32 phys_ctr);
+	void (*set_ctr_size)(void* p, u32 cpu, u32 phys_ctr, u32 ctr_size);
+	void (*enable_pm)(void* p, u32 cpu);
+	void (*disable_pm)(void* p, u32 cpu);
+	void (*read_trace_buffer)(void* p, u32 cpu, u64 *buf);
+	u32  (*get_and_clear_pm_interrupts)(void* p, u32 cpu);
+	void (*enable_pm_interrupts)(void* p, u32 cpu, u32 thread, u32 mask);
+	void (*disable_pm_interrupts)(void* p, u32 cpu);
+	void (*sync_irq)(void* p, int node);
+};
+
+extern const struct cell_pmu_ops *cell_pmu_ops;
+
+/**
+ * cell_pmu_ops_init - Initialize the cell_pmu_ops pointer.
+ * @ops: A platfrom specific instance of struct cell_pmu_ops.
+ */
+
+static inline void cell_pmu_ops_init(const struct cell_pmu_ops *ops)
+{
+	cell_pmu_ops = ops;
+}
+
+/* Routines for reading/writing the PMU registers. */
+
+static inline u32 cbe_read_phys_ctr(u32 cpu, u32 phys_ctr)
+{
+	return cell_pmu_ops->read_phys_ctr(cell_pmu_ops->priv, cpu, phys_ctr);
+}
+
+static inline void cbe_write_phys_ctr(u32 cpu, u32 phys_ctr, u32 val)
+{
+	cell_pmu_ops->write_phys_ctr(cell_pmu_ops->priv, cpu, phys_ctr, val);
+}
+
+static inline u32 cbe_read_ctr(u32 cpu, u32 ctr)
+{
+	return cell_pmu_ops->read_ctr(cell_pmu_ops->priv, cpu, ctr);
+}
+
+static inline void cbe_write_ctr(u32 cpu, u32 ctr, u32 val)
+{
+	cell_pmu_ops->write_ctr(cell_pmu_ops->priv, cpu, ctr, val);
+}
+
+static inline u32  cbe_read_pm07_control(u32 cpu, u32 ctr)
+{
+	return cell_pmu_ops->read_pm07_control(cell_pmu_ops->priv, cpu, ctr);
+}
+
+static inline void cbe_write_pm07_control(u32 cpu, u32 ctr, u32 val)
+{
+	cell_pmu_ops->write_pm07_control(cell_pmu_ops->priv, cpu, ctr, val);
+}
+
+static inline u32  cbe_read_pm(u32 cpu, enum pm_reg_name reg)
+{
+	return cell_pmu_ops->read_pm(cell_pmu_ops->priv, cpu, reg);
+}
+
+static inline void cbe_write_pm(u32 cpu, enum pm_reg_name reg, u32 val)
+{
+	cell_pmu_ops->write_pm(cell_pmu_ops->priv, cpu, reg, val);
+}
+
+static inline u32 cbe_get_ctr_size(u32 cpu, u32 phys_ctr)
+{
+	return cell_pmu_ops->get_ctr_size(cell_pmu_ops->priv, cpu, phys_ctr);
+}
+
+static inline void cbe_set_ctr_size(u32 cpu, u32 phys_ctr, u32 ctr_size)
+{
+	cell_pmu_ops->set_ctr_size(cell_pmu_ops->priv, cpu, phys_ctr, ctr_size);
+}
+
+static inline void cbe_enable_pm(u32 cpu)
+{
+	cell_pmu_ops->enable_pm(cell_pmu_ops->priv, cpu);
+}
+
+static inline void cbe_disable_pm(u32 cpu)
+{
+	return cell_pmu_ops->disable_pm(cell_pmu_ops->priv, cpu);
+}
+
+static inline void cbe_read_trace_buffer(u32 cpu, u64 *buf)
+{
+	cell_pmu_ops->read_trace_buffer(cell_pmu_ops->priv, cpu, buf);
+}
+
+static inline void cbe_enable_pm_interrupts(u32 cpu, u32 thread, u32 mask)
+{
+	cell_pmu_ops->enable_pm_interrupts(cell_pmu_ops->priv, cpu, thread,
+		mask);
+}
+
+static inline void cbe_disable_pm_interrupts(u32 cpu)
+{
+	cell_pmu_ops->disable_pm_interrupts(cell_pmu_ops->priv, cpu);
+}
+
+static inline u32  cbe_get_and_clear_pm_interrupts(u32 cpu)
+{
+	return cell_pmu_ops->get_and_clear_pm_interrupts(cell_pmu_ops->priv,
+		cpu);
+}
+
+static inline void cbe_sync_irq(int node)
+{
+	cell_pmu_ops->sync_irq(cell_pmu_ops->priv, node);
+}
+
 #endif /* __ASM_CELL_PMU_H__ */
diff -Nur linux-2.6.36-rc7/arch/powerpc/include/asm/lv1call.h ps3-linux/arch/powerpc/include/asm/lv1call.h
--- linux-2.6.36-rc7/arch/powerpc/include/asm/lv1call.h	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/include/asm/lv1call.h	2010-12-04 16:17:46.429575857 +0600
@@ -230,7 +230,7 @@
 LV1_CALL(write_htab_entry,                              4, 0,   1 )
 LV1_CALL(construct_virtual_address_space,               3, 2,   2 )
 LV1_CALL(invalidate_htab_entries,                       5, 0,   3 )
-LV1_CALL(get_virtual_address_space_id_of_ppe,           1, 1,   4 )
+LV1_CALL(get_virtual_address_space_id_of_ppe,           0, 1,   4 )
 LV1_CALL(query_logical_partition_address_region_info,   1, 5,   6 )
 LV1_CALL(select_virtual_address_space,                  1, 0,   7 )
 LV1_CALL(pause,                                         1, 0,   9 )
@@ -263,7 +263,7 @@
 LV1_CALL(get_spe_irq_outlet,                            2, 1,  78 )
 LV1_CALL(set_spe_privilege_state_area_1_register,       3, 0,  79 )
 LV1_CALL(create_repository_node,                        6, 0,  90 )
-LV1_CALL(get_repository_node_value,                     5, 2,  91 )
+LV1_CALL(read_repository_node,                          5, 2,  91 )
 LV1_CALL(modify_repository_node_value,                  6, 0,  92 )
 LV1_CALL(remove_repository_node,                        4, 0,  93 )
 LV1_CALL(read_htab_entries,                             2, 5,  95 )
@@ -275,7 +275,7 @@
 LV1_CALL(destruct_io_irq_outlet,                        1, 0, 121 )
 LV1_CALL(map_htab,                                      1, 1, 122 )
 LV1_CALL(unmap_htab,                                    1, 0, 123 )
-LV1_CALL(get_version_info,                              0, 1, 127 )
+LV1_CALL(get_version_info,                              0, 2, 127 )
 LV1_CALL(insert_htab_entry,                             6, 3, 158 )
 LV1_CALL(read_virtual_uart,                             3, 1, 162 )
 LV1_CALL(write_virtual_uart,                            3, 1, 163 )
@@ -293,9 +293,9 @@
 LV1_CALL(net_add_multicast_address,                     4, 0, 185 )
 LV1_CALL(net_remove_multicast_address,                  4, 0, 186 )
 LV1_CALL(net_start_tx_dma,                              4, 0, 187 )
-LV1_CALL(net_stop_tx_dma,                               3, 0, 188 )
+LV1_CALL(net_stop_tx_dma,                               2, 0, 188 )
 LV1_CALL(net_start_rx_dma,                              4, 0, 189 )
-LV1_CALL(net_stop_rx_dma,                               3, 0, 190 )
+LV1_CALL(net_stop_rx_dma,                               2, 0, 190 )
 LV1_CALL(net_set_interrupt_status_indicator,            4, 0, 191 )
 LV1_CALL(net_set_interrupt_mask,                        4, 0, 193 )
 LV1_CALL(net_control,                                   6, 2, 194 )
@@ -315,7 +315,7 @@
 LV1_CALL(gpu_context_iomap,                             5, 0, 221 )
 LV1_CALL(gpu_context_attribute,                         6, 0, 225 )
 LV1_CALL(gpu_context_intr,                              1, 1, 227 )
-LV1_CALL(gpu_attribute,                                 5, 0, 228 )
+LV1_CALL(gpu_attribute,                                 3, 0, 228 )
 LV1_CALL(get_rtc,                                       0, 2, 232 )
 LV1_CALL(set_ppe_periodic_tracer_frequency,             1, 0, 240 )
 LV1_CALL(start_ppe_periodic_tracer,                     5, 0, 241 )
diff -Nur linux-2.6.36-rc7/arch/powerpc/include/asm/oprofile_impl.h ps3-linux/arch/powerpc/include/asm/oprofile_impl.h
--- linux-2.6.36-rc7/arch/powerpc/include/asm/oprofile_impl.h	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/include/asm/oprofile_impl.h	2010-12-04 16:17:46.429575857 +0600
@@ -65,6 +65,7 @@
 extern struct op_powerpc_model op_model_power4;
 extern struct op_powerpc_model op_model_7450;
 extern struct op_powerpc_model op_model_cell;
+extern struct op_powerpc_model op_model_ps3;
 extern struct op_powerpc_model op_model_pa6t;
 
 
diff -Nur linux-2.6.36-rc7/arch/powerpc/include/asm/ps3.h ps3-linux/arch/powerpc/include/asm/ps3.h
--- linux-2.6.36-rc7/arch/powerpc/include/asm/ps3.h	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/include/asm/ps3.h	2010-12-04 16:17:46.429575857 +0600
@@ -503,28 +503,11 @@
 void ps3_set_pm_bookmark(u64 tag, u64 incident, u64 th_id);
 int ps3_set_signal(u64 rtas_signal_group, u8 signal_bit, u16 sub_unit,
 	u8 bus_word);
-
-u32 ps3_read_phys_ctr(u32 cpu, u32 phys_ctr);
-void ps3_write_phys_ctr(u32 cpu, u32 phys_ctr, u32 val);
-u32 ps3_read_ctr(u32 cpu, u32 ctr);
-void ps3_write_ctr(u32 cpu, u32 ctr, u32 val);
-
-u32 ps3_read_pm07_control(u32 cpu, u32 ctr);
-void ps3_write_pm07_control(u32 cpu, u32 ctr, u32 val);
-u32 ps3_read_pm(u32 cpu, enum pm_reg_name reg);
-void ps3_write_pm(u32 cpu, enum pm_reg_name reg, u32 val);
-
-u32 ps3_get_ctr_size(u32 cpu, u32 phys_ctr);
-void ps3_set_ctr_size(u32 cpu, u32 phys_ctr, u32 ctr_size);
-
-void ps3_enable_pm(u32 cpu);
-void ps3_disable_pm(u32 cpu);
-void ps3_enable_pm_interrupts(u32 cpu, u32 thread, u32 mask);
-void ps3_disable_pm_interrupts(u32 cpu);
-
-u32 ps3_get_and_clear_pm_interrupts(u32 cpu);
-void ps3_sync_irq(int node);
 u32 ps3_get_hw_thread_id(int cpu);
 u64 ps3_get_spe_id(void *arg);
 
+/* kernel debug routines */
+
+int ps3_debug_setup_dabr(u64 address, unsigned int dabr_flags);
+
 #endif
diff -Nur linux-2.6.36-rc7/arch/powerpc/include/asm/udbg.h ps3-linux/arch/powerpc/include/asm/udbg.h
--- linux-2.6.36-rc7/arch/powerpc/include/asm/udbg.h	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/include/asm/udbg.h	2010-12-04 16:17:46.439495759 +0600
@@ -52,6 +52,7 @@
 extern void __init udbg_init_40x_realmode(void);
 extern void __init udbg_init_cpm(void);
 extern void __init udbg_init_usbgecko(void);
+extern void __init udbg_init_ps3gelic(void);
 
 #endif /* __KERNEL__ */
 #endif /* _ASM_POWERPC_UDBG_H */
diff -Nur linux-2.6.36-rc7/arch/powerpc/Kconfig.debug ps3-linux/arch/powerpc/Kconfig.debug
--- linux-2.6.36-rc7/arch/powerpc/Kconfig.debug	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/Kconfig.debug	2010-12-04 16:17:46.359339233 +0600
@@ -267,6 +267,14 @@
 	  Select this to enable early debugging for Nintendo GameCube/Wii
 	  consoles via an external USB Gecko adapter.
 
+config PPC_EARLY_DEBUG_PS3GELIC
+	bool "Early debugging through the PS3 Ethernet port"
+	depends on PPC_PS3
+	select PS3GELIC_UDBG
+	help
+	  Select this to enable early debugging for the PlayStation3 via
+	  UDP broadcasts sent out through the Ethernet port.
+
 endchoice
 
 config PPC_EARLY_DEBUG_44x_PHYSLOW
diff -Nur linux-2.6.36-rc7/arch/powerpc/kernel/irq.c ps3-linux/arch/powerpc/kernel/irq.c
--- linux-2.6.36-rc7/arch/powerpc/kernel/irq.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/kernel/irq.c	2010-12-04 16:17:46.449966421 +0600
@@ -186,8 +186,8 @@
 	 * Any HV call will have this side effect.
 	 */
 	if (firmware_has_feature(FW_FEATURE_PS3_LV1)) {
-		u64 tmp;
-		lv1_get_version_info(&tmp);
+		u64 tmp, tmp2;
+		lv1_get_version_info(&tmp, &tmp2);
 	}
 
 	__hard_irq_enable();
diff -Nur linux-2.6.36-rc7/arch/powerpc/kernel/process.c ps3-linux/arch/powerpc/kernel/process.c
--- linux-2.6.36-rc7/arch/powerpc/kernel/process.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/kernel/process.c	2010-12-04 16:17:46.449966421 +0600
@@ -269,6 +269,9 @@
 {
 	siginfo_t info;
 
+	printk("%s:%d: address %016lxh, code %08lxh\n",
+		__func__, __LINE__, address, error_code);
+
 	if (notify_die(DIE_DABR_MATCH, "dabr_match", regs, error_code,
 			11, SIGSEGV) == NOTIFY_STOP)
 		return;
@@ -279,6 +282,13 @@
 	/* Clear the DABR */
 	set_dabr(0);
 
+	if (!user_mode(regs)) {
+		show_regs(regs);
+		printk("%s:%d: done: address %016lxh\n", __func__, __LINE__,
+		address);
+		return;
+	}
+
 	/* Deliver the signal to userspace */
 	info.si_signo = SIGTRAP;
 	info.si_errno = 0;
diff -Nur linux-2.6.36-rc7/arch/powerpc/kernel/setup_64.c ps3-linux/arch/powerpc/kernel/setup_64.c
--- linux-2.6.36-rc7/arch/powerpc/kernel/setup_64.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/kernel/setup_64.c	2010-12-04 16:17:46.459789658 +0600
@@ -10,7 +10,8 @@
  *      2 of the License, or (at your option) any later version.
  */
 
-#undef DEBUG
+//#undef DEBUG
+#define DEBUG
 
 #include <linux/module.h>
 #include <linux/string.h>
diff -Nur linux-2.6.36-rc7/arch/powerpc/kernel/setup-common.c ps3-linux/arch/powerpc/kernel/setup-common.c
--- linux-2.6.36-rc7/arch/powerpc/kernel/setup-common.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/kernel/setup-common.c	2010-12-04 16:17:46.459789658 +0600
@@ -10,7 +10,8 @@
  *      2 of the License, or (at your option) any later version.
  */
 
-#undef DEBUG
+//#undef DEBUG
+#define DEBUG
 
 #include <linux/module.h>
 #include <linux/string.h>
diff -Nur linux-2.6.36-rc7/arch/powerpc/kernel/udbg.c ps3-linux/arch/powerpc/kernel/udbg.c
--- linux-2.6.36-rc7/arch/powerpc/kernel/udbg.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/kernel/udbg.c	2010-12-04 16:17:46.459789658 +0600
@@ -62,6 +62,8 @@
 	udbg_init_cpm();
 #elif defined(CONFIG_PPC_EARLY_DEBUG_USBGECKO)
 	udbg_init_usbgecko();
+#elif defined(CONFIG_PPC_EARLY_DEBUG_PS3GELIC)
+	udbg_init_ps3gelic();
 #endif
 
 #ifdef CONFIG_PPC_EARLY_DEBUG
diff -Nur linux-2.6.36-rc7/arch/powerpc/mm/fault.c ps3-linux/arch/powerpc/mm/fault.c
--- linux-2.6.36-rc7/arch/powerpc/mm/fault.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/mm/fault.c	2010-12-04 16:17:46.469967076 +0600
@@ -148,7 +148,8 @@
 		return 0;
 
 	/* On a kernel SLB miss we can only check for a valid exception entry */
-	if (!user_mode(regs) && (address >= TASK_SIZE))
+	if (!user_mode(regs) && (address >= TASK_SIZE)
+		&& !(error_code & DSISR_DABRMATCH))
 		return SIGSEGV;
 
 #if !(defined(CONFIG_4xx) || defined(CONFIG_BOOKE) || \
diff -Nur linux-2.6.36-rc7/arch/powerpc/oprofile/common.c ps3-linux/arch/powerpc/oprofile/common.c
--- linux-2.6.36-rc7/arch/powerpc/oprofile/common.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/oprofile/common.c	2010-12-04 16:17:46.469967076 +0600
@@ -200,10 +200,23 @@
 
 	switch (cur_cpu_spec->oprofile_type) {
 #ifdef CONFIG_PPC_BOOK3S_64
-#ifdef CONFIG_OPROFILE_CELL
+#if defined(CONFIG_OPROFILE_CELL) || defined(CONFIG_OPROFILE_PS3)
 		case PPC_OPROFILE_CELL:
-			if (firmware_has_feature(FW_FEATURE_LPAR))
+			printk("%s:%d: \n", __func__, __LINE__);
+			if (firmware_has_feature(FW_FEATURE_PS3_LV1)) {
+				printk("%s:%d: \n", __func__, __LINE__);
+				model = &op_model_ps3;
+				ops->sync_start = model->sync_start;
+				ops->sync_stop = model->sync_stop;
+				break;
+			}
+
+			if (firmware_has_feature(FW_FEATURE_LPAR)) {
+				printk("%s:%d: \n", __func__, __LINE__);
 				return -ENODEV;
+			}
+
+			printk("%s:%d: \n", __func__, __LINE__);
 			model = &op_model_cell;
 			ops->sync_start = model->sync_start;
 			ops->sync_stop = model->sync_stop;
@@ -230,8 +243,10 @@
 			break;
 #endif
 		default:
+			printk("%s:%d: \n", __func__, __LINE__);
 			return -ENODEV;
 	}
+	printk("%s:%d: \n", __func__, __LINE__);
 
 	model->num_counters = cur_cpu_spec->num_pmcs;
 
diff -Nur linux-2.6.36-rc7/arch/powerpc/oprofile/Makefile ps3-linux/arch/powerpc/oprofile/Makefile
--- linux-2.6.36-rc7/arch/powerpc/oprofile/Makefile	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/oprofile/Makefile	2010-12-04 16:17:46.469967076 +0600
@@ -16,6 +16,7 @@
 oprofile-$(CONFIG_OPROFILE_CELL) += op_model_cell.o \
 		cell/spu_profiler.o cell/vma_map.o \
 		cell/spu_task_sync.o
+oprofile-$(CONFIG_OPROFILE_PS3) += op_model_ps3.o
 oprofile-$(CONFIG_PPC_BOOK3S_64) += op_model_rs64.o op_model_power4.o op_model_pa6t.o
 oprofile-$(CONFIG_FSL_EMB_PERFMON) += op_model_fsl_emb.o
 oprofile-$(CONFIG_6xx) += op_model_7450.o
diff -Nur linux-2.6.36-rc7/arch/powerpc/oprofile/op_model_ps3.c ps3-linux/arch/powerpc/oprofile/op_model_ps3.c
--- linux-2.6.36-rc7/arch/powerpc/oprofile/op_model_ps3.c	1970-01-01 07:00:00.000000000 +0700
+++ ps3-linux/arch/powerpc/oprofile/op_model_ps3.c	2010-12-04 16:17:46.479908789 +0600
@@ -0,0 +1,767 @@
+/*
+ * PS3 OProfile support
+ *
+ * This file based on op_model_cell.c, but the spu profiling has not
+ * been implemented yet.
+ *
+ * Copyright (C) 2007 Sony Computer Entertainment Inc.
+ * Copyright 2007 Sony Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307 USA
+ */
+
+#include <linux/cpufreq.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/kthread.h>
+#include <linux/oprofile.h>
+#include <linux/percpu.h>
+#include <linux/smp.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/firmware.h>
+#include <linux/io.h>
+#include <linux/ptrace.h>
+#include <asm/cell-pmu.h>
+#include <asm/cputable.h>
+#include <asm/oprofile_impl.h>
+#include <asm/processor.h>
+#include <asm/prom.h>
+#include <asm/reg.h>
+#include <asm/system.h>
+#include <asm/cell-regs.h>
+#include <asm/pmc.h>
+#include <asm/irq_regs.h>
+#include <asm/ps3.h>
+
+#include "../platforms/cell/interrupt.h"
+#include "cell/pr_util.h"
+
+#define OP_ERR(f, x...)  pr_info("pmu: " f "\n", ## x)
+#define OP_DBG(f, x...)  pr_debug("pmu: " f "\n", ## x)
+
+/*
+ * spu_cycle_reset is the number of cycles between samples.
+ * This variable is used for SPU profiling and should ONLY be set
+ * at the beginning of cell_reg_setup; otherwise, it's read-only.
+ */
+static unsigned int spu_cycle_reset;
+
+#define NUM_SPUS_PER_NODE    8
+#define SPU_CYCLES_EVENT_NUM 2	/*  event number for SPU_CYCLES */
+
+#define PPU_CYCLES_EVENT_NUM 1	/*  event number for CYCLES */
+#define PPU_CYCLES_GRP_NUM   1	/* special group number for identifying
+				 * PPU_CYCLES event
+				 */
+#define CBE_COUNT_ALL_CYCLES 0x42800000 /* PPU cycle event specifier */
+
+#define NUM_THREADS 2         /* number of physical threads in
+			       * physical processor
+			       */
+#define NUM_DEBUG_BUS_WORDS 4
+#define NUM_INPUT_BUS_WORDS 2
+
+#define MAX_SPU_COUNT 0xFFFFFF	/* maximum 24 bit LFSR value */
+
+struct pmc_cntrl_data {
+	unsigned long vcntr;
+	unsigned long evnts;
+	unsigned long masks;
+	unsigned long enabled;
+};
+
+struct pm_signal {
+	u16 cpu;		/* Processor to modify */
+	u16 sub_unit;		/* hw subunit this applies to (if applicable)*/
+	short int signal_group; /* Signal Group to Enable/Disable */
+	u8 bus_word;		/* Enable/Disable on this Trace/Trigger/Event
+				 * Bus Word(s) (bitmask)
+				 */
+	u8 bit;			/* Trigger/Event bit (if applicable) */
+};
+
+struct pm_cntrl {
+	u16 enable;
+	u16 stop_at_max;
+	u16 trace_mode;
+	u16 freeze;
+	u16 count_mode;
+};
+
+static struct {
+	u32 group_control;
+	u32 debug_bus_control;
+	struct pm_cntrl pm_cntrl;
+	u32 pm07_cntrl[NR_PHYS_CTRS];
+} pm_regs;
+
+#define GET_SUB_UNIT(x) ((x & 0x0000f000) >> 12)
+#define GET_BUS_WORD(x) ((x & 0x000000f0) >> 4)
+#define GET_BUS_TYPE(x) ((x & 0x00000300) >> 8)
+#define GET_POLARITY(x) ((x & 0x00000002) >> 1)
+#define GET_COUNT_CYCLES(x) (x & 0x00000001)
+#define GET_INPUT_CONTROL(x) ((x & 0x00000004) >> 2)
+
+static DEFINE_PER_CPU(unsigned long[NR_PHYS_CTRS], pmc_values);
+
+static struct pmc_cntrl_data pmc_cntrl[NUM_THREADS][NR_PHYS_CTRS];
+
+/*
+ * Interpetation of hdw_thread:
+ * 0 - even virtual cpus 0, 2, 4,...
+ * 1 - odd virtual cpus 1, 3, 5, ...
+ *
+ * FIXME: this is strictly wrong, we need to clean this up in a number
+ * of places. It works for now. -arnd
+ */
+static u32 hdw_thread;
+
+static u32 virt_cntr_inter_mask;
+static struct timer_list timer_virt_cntr;
+
+/*
+ * pm_signal needs to be global since it is initialized in
+ * cell_reg_setup at the time when the necessary information
+ * is available.
+ */
+static struct pm_signal pm_signal[NR_PHYS_CTRS];
+
+static u32 reset_value[NR_PHYS_CTRS];
+static u32 count_value[NR_PHYS_CTRS];
+static int num_counters;
+static int oprofile_running;
+static DEFINE_SPINLOCK(virt_cntr_lock);
+
+static u32 ctr_enabled;
+
+static unsigned char input_bus[NUM_INPUT_BUS_WORDS];
+
+static u32 ps3_cpu_to_node(int cpu)
+{
+	return 0;
+}
+
+static int pm_activate_signals(u32 node, u32 count)
+{
+	int i, j;
+	struct pm_signal pm_signal_local[NR_PHYS_CTRS];
+
+	/*
+	 * There is no debug setup required for the cycles event.
+	 * Note that only events in the same group can be used.
+	 * Otherwise, there will be conflicts in correctly routing
+	 * the signals on the debug bus.  It is the responsiblity
+	 * of the OProfile user tool to check the events are in
+	 * the same group.
+	 */
+	i = 0;
+	for (j = 0; j < count; j++) {
+		if (pm_signal[j].signal_group != PPU_CYCLES_GRP_NUM) {
+
+			/* fw expects physical cpu # */
+			pm_signal_local[i].cpu = node;
+			pm_signal_local[i].signal_group
+			    = pm_signal[j].signal_group;
+			pm_signal_local[i].bus_word =
+			    pm_signal[j].bus_word;
+			pm_signal_local[i].sub_unit =
+			    pm_signal[j].sub_unit;
+			pm_signal_local[i].bit = pm_signal[j].bit;
+			ps3_set_signal(pm_signal[j].signal_group,
+				       pm_signal[j].bit,
+				       pm_signal[j].sub_unit,
+				       pm_signal[j].bus_word);
+			i++;
+		}
+	}
+	return 0;
+}
+
+/*
+ * PM Signal functions
+ */
+static void set_pm_event(u32 ctr, int event, u32 unit_mask)
+{
+	struct pm_signal *p;
+	u32 signal_bit;
+	u32 bus_word, bus_type, count_cycles, polarity, input_control;
+	int j, i;
+
+	if (event == PPU_CYCLES_EVENT_NUM) {
+		/* Special Event: Count all cpu cycles */
+		pm_regs.pm07_cntrl[ctr] = CBE_COUNT_ALL_CYCLES;
+		p = &(pm_signal[ctr]);
+		p->signal_group = PPU_CYCLES_GRP_NUM;
+		p->bus_word = 1;
+		p->sub_unit = 0;
+		p->bit = 0;
+		goto out;
+	} else {
+		pm_regs.pm07_cntrl[ctr] = 0;
+	}
+
+	bus_word = GET_BUS_WORD(unit_mask);
+	bus_type = GET_BUS_TYPE(unit_mask);
+	count_cycles = GET_COUNT_CYCLES(unit_mask);
+	polarity = GET_POLARITY(unit_mask);
+	input_control = GET_INPUT_CONTROL(unit_mask);
+	signal_bit = (event % 100);
+
+	p = &(pm_signal[ctr]);
+
+	p->signal_group = event / 100;
+	p->bus_word = bus_word;
+	p->sub_unit = GET_SUB_UNIT(unit_mask);
+
+	/*
+	 * This parameter is used to specify the target physical/logical
+	 * PPE/SPE object.
+	 */
+	if (p->signal_group < 42 || 56 < p->signal_group)
+		p->sub_unit = 1;
+
+	pm_regs.pm07_cntrl[ctr] = 0;
+	pm_regs.pm07_cntrl[ctr] |= PM07_CTR_COUNT_CYCLES(count_cycles);
+	pm_regs.pm07_cntrl[ctr] |= PM07_CTR_POLARITY(polarity);
+	pm_regs.pm07_cntrl[ctr] |= PM07_CTR_INPUT_CONTROL(input_control);
+
+	/*
+	 * Some of the islands signal selection is based on 64 bit words.
+	 * The debug bus words are 32 bits, the input words to the performance
+	 * counters are defined as 32 bits.  Need to convert the 64 bit island
+	 * specification to the appropriate 32 input bit and bus word for the
+	 * performance counter event selection.  See the CELL Performance
+	 * monitoring signals manual and the Perf cntr hardware descriptions
+	 * for the details.
+	 */
+	if (input_control == 0) {
+		if (signal_bit > 31) {
+			signal_bit -= 32;
+			if (bus_word == 0x3)
+				bus_word = 0x2;
+			else if (bus_word == 0xc)
+				bus_word = 0x8;
+		}
+
+		if ((bus_type == 0) && p->signal_group >= 60)
+			bus_type = 2;
+		if ((bus_type == 0) &&
+		    (30 <= p->signal_group && p->signal_group <= 40))
+			bus_type = 2;
+		if ((bus_type == 1) && p->signal_group >= 50)
+			bus_type = 0;
+
+		pm_regs.pm07_cntrl[ctr] |= PM07_CTR_INPUT_MUX(signal_bit);
+	} else {
+		pm_regs.pm07_cntrl[ctr] = 0;
+		p->bit = signal_bit;
+	}
+
+	for (i = 0; i < NUM_DEBUG_BUS_WORDS; i++) {
+		if (bus_word & (1 << i)) {
+			pm_regs.debug_bus_control |=
+				(bus_type << (30 - (2 * i)));
+			for (j = 0; j < NUM_INPUT_BUS_WORDS; j++) {
+				if (input_bus[j] == 0xff) {
+					input_bus[j] = i;
+					pm_regs.group_control |=
+						(i << (30 - (2 * j)));
+
+					break;
+				}
+			}
+		}
+	}
+	OP_DBG("pm07_ctrl[%d] : 0x%x", ctr, pm_regs.pm07_cntrl[ctr]);
+	OP_DBG("group_control : 0x%x", pm_regs.group_control);
+	OP_DBG("debug_bus_control : 0x%x", pm_regs.debug_bus_control);
+out:
+	;
+}
+
+static void write_pm_cntrl(int cpu)
+{
+	/*
+	 * Oprofile will use 32 bit counters, set bits 7:10 to 0
+	 * pmregs.pm_cntrl is a global
+	 */
+
+	u32 val = 0;
+	if (pm_regs.pm_cntrl.enable == 1)
+		val |= CBE_PM_ENABLE_PERF_MON;
+
+	if (pm_regs.pm_cntrl.stop_at_max == 1)
+		val |= CBE_PM_STOP_AT_MAX;
+
+	if (pm_regs.pm_cntrl.trace_mode == 1)
+		val |= CBE_PM_TRACE_MODE_SET(pm_regs.pm_cntrl.trace_mode);
+
+	if (pm_regs.pm_cntrl.freeze == 1)
+		val |= CBE_PM_FREEZE_ALL_CTRS;
+
+	/*
+	 * Routine set_count_mode must be called previously to set
+	 * the count mode based on the user selection of user and kernel.
+	 */
+	val |= CBE_PM_COUNT_MODE_SET(pm_regs.pm_cntrl.count_mode);
+	cbe_write_pm(cpu, pm_control, val);
+}
+
+static inline void
+set_count_mode(u32 kernel, u32 user)
+{
+	OP_DBG("set_count_mode k:%d u:%d", kernel, user);
+	/*
+	 * The user must specify user and kernel if they want them. If
+	 *  neither is specified, OProfile will count in hypervisor mode.
+	 *  pm_regs.pm_cntrl is a global
+	 *
+	 *  NOTE : PS3 hypervisor rejects ALL_MODES and HYPERVISOR_MODE.
+	 *         So, ALL_MODES and HYPERVISOR_MODE are changed to
+	 *         PROBLEM_MODE.
+	 */
+	if (kernel) {
+		if (user)
+			pm_regs.pm_cntrl.count_mode =
+				CBE_COUNT_PROBLEM_MODE;
+		else
+			pm_regs.pm_cntrl.count_mode =
+				CBE_COUNT_SUPERVISOR_MODE;
+	} else {
+		if (user)
+			pm_regs.pm_cntrl.count_mode =
+				CBE_COUNT_PROBLEM_MODE;
+		else
+			pm_regs.pm_cntrl.count_mode =
+				CBE_COUNT_PROBLEM_MODE;
+	}
+}
+
+static inline void enable_ctr(u32 cpu, u32 ctr, u32 *pm07_cntrl)
+{
+
+	pm07_cntrl[ctr] |= CBE_PM_CTR_ENABLE;
+	cbe_write_pm07_control(cpu, ctr, pm07_cntrl[ctr]);
+}
+
+static void add_sample(u32 cpu)
+{
+	struct pt_regs *regs;
+	u64 pc;
+	int is_kernel;
+	int i;
+	u32 value;
+
+	regs = get_irq_regs();
+	if (oprofile_running == 1) {
+		pc = regs->nip;
+		is_kernel = is_kernel_addr(pc);
+
+		for (i = 0; i < num_counters; ++i) {
+			value = cbe_read_ctr(cpu, i);
+			if (value >= count_value[i] && count_value[i] != 0) {
+				OP_DBG("pmu:add_sample ctr:%d"
+				       " value:0x%x reset:0x%x count:0x%x",
+				       i, value, reset_value[i],
+				       count_value[i]);
+				oprofile_add_pc(pc, is_kernel, i);
+				cbe_write_ctr(cpu, i, reset_value[i]);
+			}
+		}
+	}
+}
+
+/*
+ * Oprofile is expected to collect data on all CPUs simultaneously.
+ * However, there is one set of performance counters per node.	There are
+ * two hardware threads or virtual CPUs on each node.  Hence, OProfile must
+ * multiplex in time the performance counter collection on the two virtual
+ * CPUs.  The multiplexing of the performance counters is done by this
+ * virtual counter routine.
+ *
+ * The pmc_values used below is defined as 'per-cpu' but its use is
+ * more akin to 'per-node'.  We need to store two sets of counter
+ * values per node -- one for the previous run and one for the next.
+ * The per-cpu[NR_PHYS_CTRS] gives us the storage we need.  Each odd/even
+ * pair of per-cpu arrays is used for storing the previous and next
+ * pmc values for a given node.
+ * NOTE: We use the per-cpu variable to improve cache performance.
+ *
+ * This routine will alternate loading the virtual counters for
+ * virtual CPUs
+ */
+static void cell_virtual_cntr(unsigned long data)
+{
+	int i, prev_hdw_thread, next_hdw_thread;
+	u32 cpu;
+	unsigned long flags;
+
+	/*
+	 * Make sure that the interrupt_hander and the virt counter are
+	 * not both playing with the counters on the same node.
+	 */
+
+	spin_lock_irqsave(&virt_cntr_lock, flags);
+
+	prev_hdw_thread = hdw_thread;
+
+	/* switch the cpu handling the interrupts */
+	hdw_thread = 1 ^ hdw_thread;
+	next_hdw_thread = hdw_thread;
+
+	pm_regs.group_control = 0;
+	pm_regs.debug_bus_control = 0;
+
+	for (i = 0; i < NUM_INPUT_BUS_WORDS; i++)
+		input_bus[i] = 0xff;
+
+	/*
+	 * There are some per thread events.  Must do the
+	 * set event, for the thread that is being started
+	 */
+	for (i = 0; i < num_counters; i++)
+		set_pm_event(i,
+			pmc_cntrl[next_hdw_thread][i].evnts,
+			pmc_cntrl[next_hdw_thread][i].masks);
+
+	/*
+	 * The following is done only once per each node, but
+	 * we need cpu #, not node #, to pass to the cbe_xxx functions.
+	 */
+	for_each_online_cpu(cpu) {
+		if (ps3_get_hw_thread_id(cpu))
+			continue;
+
+		/*
+		 * stop counters, save counter values, restore counts
+		 * for previous thread
+		 */
+		cbe_disable_pm(cpu);
+		cbe_disable_pm_interrupts(cpu);
+
+		/*
+		 * Add sample data at here.
+		 * Because PS3 hypervisor does not have
+		 * the performance monitor interrupt feature.
+		 */
+		add_sample(cpu);
+
+		/*
+		 * Switch to the other thread. Change the interrupt
+		 * and control regs to be scheduled on the CPU
+		 * corresponding to the thread to execute.
+		 */
+		for (i = 0; i < num_counters; i++) {
+			if (pmc_cntrl[next_hdw_thread][i].enabled) {
+				/*
+				 * There are some per thread events.
+				 * Must do the set event, enable_cntr
+				 * for each cpu.
+				 */
+				enable_ctr(cpu, i,
+					   pm_regs.pm07_cntrl);
+			} else {
+				cbe_write_pm07_control(cpu, i, 0);
+			}
+		}
+
+		/* Enable interrupts on the CPU thread that is starting */
+		cbe_enable_pm_interrupts(cpu, next_hdw_thread,
+					 virt_cntr_inter_mask);
+		cbe_enable_pm(cpu);
+	}
+
+	spin_unlock_irqrestore(&virt_cntr_lock, flags);
+
+	mod_timer(&timer_virt_cntr, jiffies + HZ / 10);
+}
+
+static void start_virt_cntrs(void)
+{
+	init_timer(&timer_virt_cntr);
+	timer_virt_cntr.function = cell_virtual_cntr;
+	timer_virt_cntr.data = 0UL;
+	timer_virt_cntr.expires = jiffies + HZ / 10;
+	add_timer(&timer_virt_cntr);
+}
+
+/* This function is called once for all cpus combined */
+static int cell_reg_setup(struct op_counter_config *ctr,
+			struct op_system_config *sys, int num_ctrs)
+{
+	int i, j, cpu;
+	int ret;
+
+	spu_cycle_reset = 0;
+
+	ret = ps3_lpm_open(PS3_LPM_TB_TYPE_NONE, NULL, 0);
+	if (ret) {
+		OP_ERR("lpm_open error. %d", ret);
+		return -EFAULT;
+	}
+
+	if (ctr[0].event == SPU_CYCLES_EVENT_NUM)
+		spu_cycle_reset = ctr[0].count;
+
+	num_counters = num_ctrs;
+
+	pm_regs.group_control = 0;
+	pm_regs.debug_bus_control = 0;
+
+	/* setup the pm_control register */
+	memset(&pm_regs.pm_cntrl, 0, sizeof(struct pm_cntrl));
+	pm_regs.pm_cntrl.stop_at_max = 1;
+	pm_regs.pm_cntrl.trace_mode = 0;
+	pm_regs.pm_cntrl.freeze = 1;
+
+	set_count_mode(sys->enable_kernel, sys->enable_user);
+
+	/* Setup the thread 0 events */
+	for (i = 0; i < num_ctrs; ++i) {
+
+		pmc_cntrl[0][i].evnts = ctr[i].event;
+		pmc_cntrl[0][i].masks = ctr[i].unit_mask;
+		pmc_cntrl[0][i].enabled = ctr[i].enabled;
+		pmc_cntrl[0][i].vcntr = i;
+
+		for_each_possible_cpu(j)
+			per_cpu(pmc_values, j)[i] = 0;
+	}
+
+	/*
+	 * Setup the thread 1 events, map the thread 0 event to the
+	 * equivalent thread 1 event.
+	 */
+	for (i = 0; i < num_ctrs; ++i) {
+		if ((ctr[i].event >= 2100) && (ctr[i].event <= 2111))
+			pmc_cntrl[1][i].evnts = ctr[i].event + 19;
+		else if (ctr[i].event == 2203)
+			pmc_cntrl[1][i].evnts = ctr[i].event;
+		else if ((ctr[i].event >= 2200) && (ctr[i].event <= 2215))
+			pmc_cntrl[1][i].evnts = ctr[i].event + 16;
+		else
+			pmc_cntrl[1][i].evnts = ctr[i].event;
+
+		pmc_cntrl[1][i].masks = ctr[i].unit_mask;
+		pmc_cntrl[1][i].enabled = ctr[i].enabled;
+		pmc_cntrl[1][i].vcntr = i;
+	}
+
+	for (i = 0; i < NUM_INPUT_BUS_WORDS; i++)
+		input_bus[i] = 0xff;
+
+	/*
+	 * Our counters count up, and "count" refers to
+	 * how much before the next interrupt, and we interrupt
+	 * on overflow.	 So we calculate the starting value
+	 * which will give us "count" until overflow.
+	 * Then we set the events on the enabled counters.
+	 */
+	for (i = 0; i < num_counters; ++i) {
+		/* start with virtual counter set 0 */
+		if (pmc_cntrl[0][i].enabled) {
+			reset_value[i] = 0;
+			count_value[i] = ctr[i].count;
+			set_pm_event(i,
+				     pmc_cntrl[0][i].evnts,
+				     pmc_cntrl[0][i].masks);
+
+			/* global, used by cell_cpu_setup */
+			ctr_enabled |= (1 << i);
+		}
+	}
+
+	/* initialize the previous counts for the virtual cntrs */
+	for_each_online_cpu(cpu)
+		for (i = 0; i < num_counters; ++i)
+			per_cpu(pmc_values, cpu)[i] = reset_value[i];
+
+	return 0;
+}
+
+
+
+/* This function is called once for each cpu */
+static int cell_cpu_setup(struct op_counter_config *cntr)
+{
+	u32 cpu = smp_processor_id();
+	u32 num_enabled = 0;
+	int i;
+
+	if (spu_cycle_reset)
+		return 0;
+
+	/* There is one performance monitor per processor chip (i.e. node),
+	 * so we only need to perform this function once per node.
+	 */
+	if (ps3_get_hw_thread_id(cpu))
+		return 0;
+
+	/* Stop all counters */
+	cbe_disable_pm(cpu);
+	cbe_disable_pm_interrupts(cpu);
+
+	cbe_write_pm(cpu, pm_interval, 0);
+	cbe_write_pm(cpu, pm_start_stop, 0);
+	cbe_write_pm(cpu, group_control, pm_regs.group_control);
+	cbe_write_pm(cpu, debug_bus_control, pm_regs.debug_bus_control);
+	write_pm_cntrl(cpu);
+
+	for (i = 0; i < num_counters; ++i) {
+		if (ctr_enabled & (1 << i)) {
+			pm_signal[num_enabled].cpu = ps3_cpu_to_node(cpu);
+			num_enabled++;
+		}
+	}
+
+	return pm_activate_signals(ps3_cpu_to_node(cpu), num_enabled);
+}
+
+
+static int cell_global_start_spu(struct op_counter_config *ctr)
+{
+	return -ENOSYS;
+}
+
+static int cell_global_start_ppu(struct op_counter_config *ctr)
+{
+	u32 cpu, i;
+	u32 interrupt_mask = 0;
+
+	/* This routine gets called once for the system.
+	 * There is one performance monitor per node, so we
+	 * only need to perform this function once per node.
+	 */
+	for_each_online_cpu(cpu) {
+		if (ps3_get_hw_thread_id(cpu))
+			continue;
+
+		interrupt_mask = 0;
+
+		for (i = 0; i < num_counters; ++i) {
+			if (ctr_enabled & (1 << i)) {
+				cbe_write_ctr(cpu, i, reset_value[i]);
+				enable_ctr(cpu, i, pm_regs.pm07_cntrl);
+				interrupt_mask |=
+				    CBE_PM_CTR_OVERFLOW_INTR(i);
+			} else {
+				/* Disable counter */
+				cbe_write_pm07_control(cpu, i, 0);
+			}
+		}
+
+		cbe_get_and_clear_pm_interrupts(cpu);
+		cbe_enable_pm_interrupts(cpu, hdw_thread, interrupt_mask);
+		cbe_enable_pm(cpu);
+	}
+
+	virt_cntr_inter_mask = interrupt_mask;
+	oprofile_running = 1;
+	/* complete the previous store */
+	smp_wmb();
+
+	/*
+	 * NOTE: start_virt_cntrs will result in cell_virtual_cntr() being
+	 * executed which manipulates the PMU.	We start the "virtual counter"
+	 * here so that we do not need to synchronize access to the PMU in
+	 * the above for-loop.
+	 */
+	start_virt_cntrs();
+
+	return 0;
+}
+
+static int cell_global_start(struct op_counter_config *ctr)
+{
+	if (spu_cycle_reset)
+		return cell_global_start_spu(ctr);
+	else
+		return cell_global_start_ppu(ctr);
+}
+
+static void cell_global_stop_spu(void)
+{
+}
+
+static void cell_global_stop_ppu(void)
+{
+	int cpu;
+
+	/*
+	 * This routine will be called once for the system.
+	 * There is one performance monitor per node, so we
+	 * only need to perform this function once per node.
+	 */
+	del_timer_sync(&timer_virt_cntr);
+	oprofile_running = 0;
+	/* complete the previous store */
+	smp_wmb();
+
+	for_each_online_cpu(cpu) {
+		if (ps3_get_hw_thread_id(cpu))
+			continue;
+
+		/* Stop the counters */
+		cbe_disable_pm(cpu);
+
+		/* Deactivate the signals */
+		ps3_set_signal(0, 0, 0, 0);	/*clear all */
+
+		/* Deactivate interrupts */
+		cbe_disable_pm_interrupts(cpu);
+	}
+}
+
+static void cell_global_stop(void)
+{
+	if (spu_cycle_reset)
+		cell_global_stop_spu();
+	else
+		cell_global_stop_ppu();
+}
+
+
+/*
+ * This function is called from the generic OProfile
+ * driver.  When profiling PPUs, we need to do the
+ * generic sync start; otherwise, do spu_sync_start.
+ */
+static int cell_sync_start(void)
+{
+	OP_ERR("PS3 oprofile support");
+	return DO_GENERIC_SYNC;
+}
+
+static int cell_sync_stop(void)
+{
+	int ret;
+
+	ret = ps3_lpm_close();
+	if (ret)
+		OP_ERR("lpm_close error. %d", ret);
+
+	return 1;
+}
+
+struct op_powerpc_model op_model_ps3 = {
+	.reg_setup = cell_reg_setup,
+	.cpu_setup = cell_cpu_setup,
+	.global_start = cell_global_start,
+	.global_stop = cell_global_stop,
+	.sync_start = cell_sync_start,
+	.sync_stop = cell_sync_stop,
+};
diff -Nur linux-2.6.36-rc7/arch/powerpc/platforms/cell/Makefile ps3-linux/arch/powerpc/platforms/cell/Makefile
--- linux-2.6.36-rc7/arch/powerpc/platforms/cell/Makefile	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/platforms/cell/Makefile	2010-12-04 16:17:46.489967276 +0600
@@ -1,5 +1,6 @@
 obj-$(CONFIG_PPC_CELL_COMMON)		+= cbe_regs.o interrupt.o pervasive.o
 
+obj-$(CONFIG_PPC_CELL)			+= pmu-core.o
 obj-$(CONFIG_PPC_CELL_NATIVE)		+= iommu.o setup.o spider-pic.o \
 					   pmu.o io-workarounds.o spider-pci.o
 obj-$(CONFIG_CBE_RAS)			+= ras.o
diff -Nur linux-2.6.36-rc7/arch/powerpc/platforms/cell/pmu.c ps3-linux/arch/powerpc/platforms/cell/pmu.c
--- linux-2.6.36-rc7/arch/powerpc/platforms/cell/pmu.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/platforms/cell/pmu.c	2010-12-04 16:17:46.489967276 +0600
@@ -66,124 +66,10 @@
 	} while (0)
 
 /*
- * Physical counter registers.
- * Each physical counter can act as one 32-bit counter or two 16-bit counters.
- */
-
-u32 cbe_read_phys_ctr(u32 cpu, u32 phys_ctr)
-{
-	u32 val_in_latch, val = 0;
-
-	if (phys_ctr < NR_PHYS_CTRS) {
-		READ_SHADOW_REG(val_in_latch, counter_value_in_latch);
-
-		/* Read the latch or the actual counter, whichever is newer. */
-		if (val_in_latch & (1 << phys_ctr)) {
-			READ_SHADOW_REG(val, pm_ctr[phys_ctr]);
-		} else {
-			READ_MMIO_UPPER32(val, pm_ctr[phys_ctr]);
-		}
-	}
-
-	return val;
-}
-EXPORT_SYMBOL_GPL(cbe_read_phys_ctr);
-
-void cbe_write_phys_ctr(u32 cpu, u32 phys_ctr, u32 val)
-{
-	struct cbe_pmd_shadow_regs *shadow_regs;
-	u32 pm_ctrl;
-
-	if (phys_ctr < NR_PHYS_CTRS) {
-		/* Writing to a counter only writes to a hardware latch.
-		 * The new value is not propagated to the actual counter
-		 * until the performance monitor is enabled.
-		 */
-		WRITE_WO_MMIO(pm_ctr[phys_ctr], val);
-
-		pm_ctrl = cbe_read_pm(cpu, pm_control);
-		if (pm_ctrl & CBE_PM_ENABLE_PERF_MON) {
-			/* The counters are already active, so we need to
-			 * rewrite the pm_control register to "re-enable"
-			 * the PMU.
-			 */
-			cbe_write_pm(cpu, pm_control, pm_ctrl);
-		} else {
-			shadow_regs = cbe_get_cpu_pmd_shadow_regs(cpu);
-			shadow_regs->counter_value_in_latch |= (1 << phys_ctr);
-		}
-	}
-}
-EXPORT_SYMBOL_GPL(cbe_write_phys_ctr);
-
-/*
- * "Logical" counter registers.
- * These will read/write 16-bits or 32-bits depending on the
- * current size of the counter. Counters 4 - 7 are always 16-bit.
- */
-
-u32 cbe_read_ctr(u32 cpu, u32 ctr)
-{
-	u32 val;
-	u32 phys_ctr = ctr & (NR_PHYS_CTRS - 1);
-
-	val = cbe_read_phys_ctr(cpu, phys_ctr);
-
-	if (cbe_get_ctr_size(cpu, phys_ctr) == 16)
-		val = (ctr < NR_PHYS_CTRS) ? (val >> 16) : (val & 0xffff);
-
-	return val;
-}
-EXPORT_SYMBOL_GPL(cbe_read_ctr);
-
-void cbe_write_ctr(u32 cpu, u32 ctr, u32 val)
-{
-	u32 phys_ctr;
-	u32 phys_val;
-
-	phys_ctr = ctr & (NR_PHYS_CTRS - 1);
-
-	if (cbe_get_ctr_size(cpu, phys_ctr) == 16) {
-		phys_val = cbe_read_phys_ctr(cpu, phys_ctr);
-
-		if (ctr < NR_PHYS_CTRS)
-			val = (val << 16) | (phys_val & 0xffff);
-		else
-			val = (val & 0xffff) | (phys_val & 0xffff0000);
-	}
-
-	cbe_write_phys_ctr(cpu, phys_ctr, val);
-}
-EXPORT_SYMBOL_GPL(cbe_write_ctr);
-
-/*
- * Counter-control registers.
- * Each "logical" counter has a corresponding control register.
- */
-
-u32 cbe_read_pm07_control(u32 cpu, u32 ctr)
-{
-	u32 pm07_control = 0;
-
-	if (ctr < NR_CTRS)
-		READ_SHADOW_REG(pm07_control, pm07_control[ctr]);
-
-	return pm07_control;
-}
-EXPORT_SYMBOL_GPL(cbe_read_pm07_control);
-
-void cbe_write_pm07_control(u32 cpu, u32 ctr, u32 val)
-{
-	if (ctr < NR_CTRS)
-		WRITE_WO_MMIO(pm07_control[ctr], val);
-}
-EXPORT_SYMBOL_GPL(cbe_write_pm07_control);
-
-/*
  * Other PMU control registers. Most of these are write-only.
  */
 
-u32 cbe_read_pm(u32 cpu, enum pm_reg_name reg)
+static u32 mmio_read_pm(__maybe_unused void* p, u32 cpu, enum pm_reg_name reg)
 {
 	u32 val = 0;
 
@@ -223,9 +109,9 @@
 
 	return val;
 }
-EXPORT_SYMBOL_GPL(cbe_read_pm);
 
-void cbe_write_pm(u32 cpu, enum pm_reg_name reg, u32 val)
+static void mmio_write_pm(__maybe_unused void* p, u32 cpu, enum pm_reg_name reg,
+	u32 val)
 {
 	switch (reg) {
 	case group_control:
@@ -261,31 +147,30 @@
 		break;
 	}
 }
-EXPORT_SYMBOL_GPL(cbe_write_pm);
 
 /*
  * Get/set the size of a physical counter to either 16 or 32 bits.
  */
 
-u32 cbe_get_ctr_size(u32 cpu, u32 phys_ctr)
+static u32 mmio_get_ctr_size(__maybe_unused void* p, u32 cpu, u32 phys_ctr)
 {
 	u32 pm_ctrl, size = 0;
 
 	if (phys_ctr < NR_PHYS_CTRS) {
-		pm_ctrl = cbe_read_pm(cpu, pm_control);
+		pm_ctrl = mmio_read_pm(p, cpu, pm_control);
 		size = (pm_ctrl & CBE_PM_16BIT_CTR(phys_ctr)) ? 16 : 32;
 	}
 
 	return size;
 }
-EXPORT_SYMBOL_GPL(cbe_get_ctr_size);
 
-void cbe_set_ctr_size(u32 cpu, u32 phys_ctr, u32 ctr_size)
+static void mmio_set_ctr_size(__maybe_unused void* p, u32 cpu, u32 phys_ctr,
+	u32 ctr_size)
 {
 	u32 pm_ctrl;
 
 	if (phys_ctr < NR_PHYS_CTRS) {
-		pm_ctrl = cbe_read_pm(cpu, pm_control);
+		pm_ctrl = mmio_read_pm(p, cpu, pm_control);
 		switch (ctr_size) {
 		case 16:
 			pm_ctrl |= CBE_PM_16BIT_CTR(phys_ctr);
@@ -295,17 +180,126 @@
 			pm_ctrl &= ~CBE_PM_16BIT_CTR(phys_ctr);
 			break;
 		}
-		cbe_write_pm(cpu, pm_control, pm_ctrl);
+		mmio_write_pm(p, cpu, pm_control, pm_ctrl);
+	}
+}
+
+/*
+ * Physical counter registers.
+ * Each physical counter can act as one 32-bit counter or two 16-bit counters.
+ */
+
+static u32 mmio_read_phys_ctr(__maybe_unused void* p, u32 cpu, u32 phys_ctr)
+{
+	u32 val_in_latch, val = 0;
+
+	if (phys_ctr < NR_PHYS_CTRS) {
+		READ_SHADOW_REG(val_in_latch, counter_value_in_latch);
+
+		/* Read the latch or the actual counter, whichever is newer. */
+		if (val_in_latch & (1 << phys_ctr)) {
+			READ_SHADOW_REG(val, pm_ctr[phys_ctr]);
+		} else {
+			READ_MMIO_UPPER32(val, pm_ctr[phys_ctr]);
+		}
+	}
+
+	return val;
+}
+
+static void mmio_write_phys_ctr(__maybe_unused void* p, u32 cpu, u32 phys_ctr,
+	u32 val)
+{
+	struct cbe_pmd_shadow_regs *shadow_regs;
+	u32 pm_ctrl;
+
+	if (phys_ctr < NR_PHYS_CTRS) {
+		/* Writing to a counter only writes to a hardware latch.
+		 * The new value is not propagated to the actual counter
+		 * until the performance monitor is enabled.
+		 */
+		WRITE_WO_MMIO(pm_ctr[phys_ctr], val);
+
+		pm_ctrl = mmio_read_pm(p, cpu, pm_control);
+		if (pm_ctrl & CBE_PM_ENABLE_PERF_MON) {
+			/* The counters are already active, so we need to
+			 * rewrite the pm_control register to "re-enable"
+			 * the PMU.
+			 */
+			mmio_write_pm(p, cpu, pm_control, pm_ctrl);
+		} else {
+			shadow_regs = cbe_get_cpu_pmd_shadow_regs(cpu);
+			shadow_regs->counter_value_in_latch |= (1 << phys_ctr);
+		}
+	}
+}
+
+/*
+ * "Logical" counter registers.
+ * These will read/write 16-bits or 32-bits depending on the
+ * current size of the counter. Counters 4 - 7 are always 16-bit.
+ */
+
+static u32 mmio_read_ctr(__maybe_unused void* p, u32 cpu, u32 ctr)
+{
+	u32 val;
+	u32 phys_ctr = ctr & (NR_PHYS_CTRS - 1);
+
+	val = mmio_read_phys_ctr(p, cpu, phys_ctr);
+
+	if (mmio_get_ctr_size(p, cpu, phys_ctr) == 16)
+		val = (ctr < NR_PHYS_CTRS) ? (val >> 16) : (val & 0xffff);
+
+	return val;
+}
+
+static void mmio_write_ctr(__maybe_unused void* p, u32 cpu, u32 ctr, u32 val)
+{
+	u32 phys_ctr;
+	u32 phys_val;
+
+	phys_ctr = ctr & (NR_PHYS_CTRS - 1);
+
+	if (mmio_get_ctr_size(p, cpu, phys_ctr) == 16) {
+		phys_val = mmio_read_phys_ctr(p, cpu, phys_ctr);
+
+		if (ctr < NR_PHYS_CTRS)
+			val = (val << 16) | (phys_val & 0xffff);
+		else
+			val = (val & 0xffff) | (phys_val & 0xffff0000);
 	}
+
+	mmio_write_phys_ctr(p, cpu, phys_ctr, val);
+}
+
+/*
+ * Counter-control registers.
+ * Each "logical" counter has a corresponding control register.
+ */
+
+static u32 mmio_read_pm07_control(__maybe_unused void* p, u32 cpu, u32 ctr)
+{
+	u32 pm07_control = 0;
+
+	if (ctr < NR_CTRS)
+		READ_SHADOW_REG(pm07_control, pm07_control[ctr]);
+
+	return pm07_control;
+}
+
+static void mmio_write_pm07_control(__maybe_unused void* p, u32 cpu, u32 ctr,
+	u32 val)
+{
+	if (ctr < NR_CTRS)
+		WRITE_WO_MMIO(pm07_control[ctr], val);
 }
-EXPORT_SYMBOL_GPL(cbe_set_ctr_size);
 
 /*
  * Enable/disable the entire performance monitoring unit.
  * When we enable the PMU, all pending writes to counters get committed.
  */
 
-void cbe_enable_pm(u32 cpu)
+static void mmio_enable_pm(__maybe_unused void* p, u32 cpu)
 {
 	struct cbe_pmd_shadow_regs *shadow_regs;
 	u32 pm_ctrl;
@@ -313,18 +307,16 @@
 	shadow_regs = cbe_get_cpu_pmd_shadow_regs(cpu);
 	shadow_regs->counter_value_in_latch = 0;
 
-	pm_ctrl = cbe_read_pm(cpu, pm_control) | CBE_PM_ENABLE_PERF_MON;
-	cbe_write_pm(cpu, pm_control, pm_ctrl);
+	pm_ctrl = mmio_read_pm(p, cpu, pm_control) | CBE_PM_ENABLE_PERF_MON;
+	mmio_write_pm(p, cpu, pm_control, pm_ctrl);
 }
-EXPORT_SYMBOL_GPL(cbe_enable_pm);
 
-void cbe_disable_pm(u32 cpu)
+static void mmio_disable_pm(__maybe_unused void* p, u32 cpu)
 {
 	u32 pm_ctrl;
-	pm_ctrl = cbe_read_pm(cpu, pm_control) & ~CBE_PM_ENABLE_PERF_MON;
-	cbe_write_pm(cpu, pm_control, pm_ctrl);
+	pm_ctrl = mmio_read_pm(p, cpu, pm_control) & ~CBE_PM_ENABLE_PERF_MON;
+	mmio_write_pm(p, cpu, pm_control, pm_ctrl);
 }
-EXPORT_SYMBOL_GPL(cbe_disable_pm);
 
 /*
  * Reading from the trace_buffer.
@@ -332,51 +324,85 @@
  * the second half automatically increments the trace_address.
  */
 
-void cbe_read_trace_buffer(u32 cpu, u64 *buf)
+static void mmio_read_trace_buffer(__maybe_unused void* p, u32 cpu, u64 *buf)
 {
 	struct cbe_pmd_regs __iomem *pmd_regs = cbe_get_cpu_pmd_regs(cpu);
 
 	*buf++ = in_be64(&pmd_regs->trace_buffer_0_63);
 	*buf++ = in_be64(&pmd_regs->trace_buffer_64_127);
 }
-EXPORT_SYMBOL_GPL(cbe_read_trace_buffer);
 
 /*
  * Enabling/disabling interrupts for the entire performance monitoring unit.
  */
 
-u32 cbe_get_and_clear_pm_interrupts(u32 cpu)
+static u32 mmio_get_and_clear_pm_interrupts(__maybe_unused void* p, u32 cpu)
 {
 	/* Reading pm_status clears the interrupt bits. */
-	return cbe_read_pm(cpu, pm_status);
+	return mmio_read_pm(p, cpu, pm_status);
 }
-EXPORT_SYMBOL_GPL(cbe_get_and_clear_pm_interrupts);
 
-void cbe_enable_pm_interrupts(u32 cpu, u32 thread, u32 mask)
+static void mmio_enable_pm_interrupts(__maybe_unused void* p, u32 cpu,
+	u32 thread, u32 mask)
 {
 	/* Set which node and thread will handle the next interrupt. */
 	iic_set_interrupt_routing(cpu, thread, 0);
 
 	/* Enable the interrupt bits in the pm_status register. */
 	if (mask)
-		cbe_write_pm(cpu, pm_status, mask);
+		mmio_write_pm(p, cpu, pm_status, mask);
 }
-EXPORT_SYMBOL_GPL(cbe_enable_pm_interrupts);
 
-void cbe_disable_pm_interrupts(u32 cpu)
+static void mmio_disable_pm_interrupts(__maybe_unused void* p, u32 cpu)
 {
-	cbe_get_and_clear_pm_interrupts(cpu);
-	cbe_write_pm(cpu, pm_status, 0);
+	mmio_get_and_clear_pm_interrupts(p, cpu);
+	mmio_write_pm(p, cpu, pm_status, 0);
 }
-EXPORT_SYMBOL_GPL(cbe_disable_pm_interrupts);
 
-static irqreturn_t cbe_pm_irq(int irq, void *dev_id)
+static void mmio_sync_irq(__maybe_unused void* p, int node)
+{
+	unsigned int irq;
+
+	irq = irq_find_mapping(NULL,
+			       IIC_IRQ_IOEX_PMI
+			       | (node << IIC_IRQ_NODE_SHIFT));
+
+	if (irq == NO_IRQ) {
+		printk(KERN_WARNING "ERROR, unable to get existing irq %d " \
+		"for node %d\n", irq, node);
+		return;
+	}
+
+	synchronize_irq(irq);
+}
+
+static const struct cell_pmu_ops cell_pmu_ops_mmio = {
+	.read_phys_ctr               = mmio_read_phys_ctr,
+	.write_phys_ctr              = mmio_write_phys_ctr,
+	.read_ctr                    = mmio_read_ctr,
+	.write_ctr	             = mmio_write_ctr,
+	.read_pm07_control           = mmio_read_pm07_control,
+	.write_pm07_control          = mmio_write_pm07_control,
+	.read_pm                     = mmio_read_pm,
+	.write_pm                    = mmio_write_pm,
+	.get_ctr_size                = mmio_get_ctr_size,
+	.set_ctr_size                = mmio_set_ctr_size,
+	.enable_pm                   = mmio_enable_pm,
+	.disable_pm                  = mmio_disable_pm,
+	.read_trace_buffer           = mmio_read_trace_buffer,
+	.get_and_clear_pm_interrupts = mmio_get_and_clear_pm_interrupts,
+	.enable_pm_interrupts        = mmio_enable_pm_interrupts,
+	.disable_pm_interrupts       = mmio_disable_pm_interrupts,
+	.sync_irq                    = mmio_sync_irq,
+};
+
+static irqreturn_t mmio_pm_irq(int irq, void *dev_id)
 {
 	perf_irq(get_irq_regs());
 	return IRQ_HANDLED;
 }
 
-static int __init cbe_init_pm_irq(void)
+static int __init mmio_init_pm_irq(void)
 {
 	unsigned int irq;
 	int rc, node;
@@ -390,7 +416,7 @@
 			return -EINVAL;
 		}
 
-		rc = request_irq(irq, cbe_pm_irq,
+		rc = request_irq(irq, mmio_pm_irq,
 				 IRQF_DISABLED, "cbe-pmu-0", NULL);
 		if (rc) {
 			printk("ERROR: Request for irq on node %d failed\n",
@@ -401,23 +427,11 @@
 
 	return 0;
 }
-machine_arch_initcall(cell, cbe_init_pm_irq);
 
-void cbe_sync_irq(int node)
+static int __init mmio_pmu_init(void)
 {
-	unsigned int irq;
-
-	irq = irq_find_mapping(NULL,
-			       IIC_IRQ_IOEX_PMI
-			       | (node << IIC_IRQ_NODE_SHIFT));
-
-	if (irq == NO_IRQ) {
-		printk(KERN_WARNING "ERROR, unable to get existing irq %d " \
-		"for node %d\n", irq, node);
-		return;
-	}
-
-	synchronize_irq(irq);
+	cell_pmu_ops_init(&cell_pmu_ops_mmio);
+	return mmio_init_pm_irq();
 }
-EXPORT_SYMBOL_GPL(cbe_sync_irq);
 
+machine_arch_initcall(cell, mmio_pmu_init);
diff -Nur linux-2.6.36-rc7/arch/powerpc/platforms/cell/pmu-core.c ps3-linux/arch/powerpc/platforms/cell/pmu-core.c
--- linux-2.6.36-rc7/arch/powerpc/platforms/cell/pmu-core.c	1970-01-01 07:00:00.000000000 +0700
+++ ps3-linux/arch/powerpc/platforms/cell/pmu-core.c	2010-12-04 16:17:46.489967276 +0600
@@ -0,0 +1,31 @@
+/*
+ * Core support for Cell Performance Monitor Unit.
+ *
+ *  Copyright (C) 2008 Sony Computer Entertainment Inc.
+ *  Copyright 2008 Sony Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/cell-pmu.h>
+
+
+/**
+ * cell_pmu_ops - Global pointer to the platform specific cell_pmu_ops instance.
+ */
+
+const struct cell_pmu_ops *cell_pmu_ops;
+EXPORT_SYMBOL_GPL(cell_pmu_ops);
diff -Nur linux-2.6.36-rc7/arch/powerpc/platforms/ps3/device-init.c ps3-linux/arch/powerpc/platforms/ps3/device-init.c
--- linux-2.6.36-rc7/arch/powerpc/platforms/ps3/device-init.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/platforms/ps3/device-init.c	2010-12-04 16:17:46.509965763 +0600
@@ -18,6 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#define DEBUG
+
 #include <linux/delay.h>
 #include <linux/freezer.h>
 #include <linux/kernel.h>
diff -Nur linux-2.6.36-rc7/arch/powerpc/platforms/ps3/gelic_udbg.c ps3-linux/arch/powerpc/platforms/ps3/gelic_udbg.c
--- linux-2.6.36-rc7/arch/powerpc/platforms/ps3/gelic_udbg.c	1970-01-01 07:00:00.000000000 +0700
+++ ps3-linux/arch/powerpc/platforms/ps3/gelic_udbg.c	2010-12-04 16:17:46.509965763 +0600
@@ -0,0 +1,267 @@
+/*
+ * arch/powerpc/platforms/ps3/gelic_udbg.c
+ *
+ * udbg debug output routine via GELIC UDP broadcasts
+ * Copyright (C) 2010 Hector Martin <hector@marcansoft.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ */
+
+#include <asm/io.h>
+#include <asm/udbg.h>
+#include <asm/lv1call.h>
+
+#ifdef CONFIG_PS3GELIC_UDBG
+
+#define GELIC_LV1_GET_MAC_ADDRESS 1
+#define GELIC_LV1_GET_VLAN_ID 4
+#define GELIC_LV1_VLAN_TX_ETHERNET_0 2
+
+#define GELIC_DESCR_DMA_STAT_MASK 0xf0000000
+#define GELIC_DESCR_DMA_CARDOWNED 0xa0000000
+
+#define GELIC_DESCR_TX_DMA_IKE 0x00080000
+#define GELIC_DESCR_TX_DMA_NO_CHKSUM 0x00000000
+#define GELIC_DESCR_TX_DMA_FRAME_TAIL 0x00040000
+
+#define GELIC_DESCR_DMA_CMD_NO_CHKSUM	\
+	(GELIC_DESCR_DMA_CARDOWNED | GELIC_DESCR_TX_DMA_IKE | \
+	GELIC_DESCR_TX_DMA_NO_CHKSUM)
+
+#define DEBUG_PORT 18194
+
+static int bus_id = 1;
+static int dev_id = 0;
+
+static u64 bus_addr;
+
+static int inited = 0;
+
+struct gelic_descr {
+	/* as defined by the hardware */
+	u32 buf_addr;
+	u32 buf_size;
+	u32 next_descr_addr;
+	u32 dmac_cmd_status;
+	u32 result_size;
+	u32 valid_size;	/* all zeroes for tx */
+	u32 data_status;
+	u32 data_error;	/* all zeroes for tx */
+} __attribute__((aligned(32)));
+
+struct ethhdr {
+	u8 dest[6];
+	u8 src[6];
+	u16 type;
+} __attribute__((packed));
+
+struct vlantag {
+	u16 vlan;
+	u16 subtype;
+} __attribute__((packed));
+
+struct iphdr {
+	u8 ver_len;
+	u8 dscp_ecn;
+	u16 total_length;
+	u16 ident;
+	u16 frag_off_flags;
+	u8 ttl;
+	u8 proto;
+	u16 checksum;
+	u32 src;
+	u32 dest;
+} __attribute__((packed));
+
+struct udphdr {
+	u16 src;
+	u16 dest;
+	u16 len;
+	u16 checksum;
+} __attribute__((packed));
+
+static __iomem struct ethhdr *h_eth;
+static __iomem struct vlantag *h_vlan;
+static __iomem struct iphdr *h_ip;
+static __iomem struct udphdr *h_udp;
+
+static __iomem char *pmsg;
+static __iomem char *pmsgc;
+
+#define MAX_MESSAGE_SIZE 1000
+
+struct debug_block {
+	volatile struct gelic_descr descr;
+	u8 pkt[1520];
+} __attribute__((packed));
+
+static __iomem struct debug_block dbg __attribute__((aligned(32)));
+
+static int header_size;
+
+static void map_dma_mem(int bus_id, int dev_id, void *start, size_t len, u64 *r_bus_addr)
+{
+	s64 result;
+	u64 real_addr = ((u64)start) & 0x0FFFFFFFFFFFFFFFUL;
+	u64 real_end = real_addr + len;
+	u64 map_start = real_addr & ~0xfff;
+	u64 map_end = (real_end + 0xfff) & ~0xfff;
+	u64 bus_addr = 0;
+
+	u64 flags = 0xf800000000000000UL;
+
+	result = lv1_allocate_device_dma_region(bus_id, dev_id, map_end - map_start, 12, 0, &bus_addr);
+	if (result)
+		lv1_panic(0);
+
+	result = lv1_map_device_dma_region(bus_id, dev_id, map_start, bus_addr, map_end - map_start, flags);
+	if (result)
+		lv1_panic(0);
+
+	*r_bus_addr = bus_addr + real_addr - map_start;
+}
+
+static int unmap_dma_mem(int bus_id, int dev_id, u64 bus_addr, size_t len)
+{
+	s64 result;
+	u64 real_bus_addr;
+
+	real_bus_addr = bus_addr & ~0xfff;
+	len += bus_addr - real_bus_addr;
+	len = (len + 0xfff) & ~0xfff;
+
+	result = lv1_unmap_device_dma_region(bus_id, dev_id, real_bus_addr, len);
+	if (result)
+		return result;
+
+	return lv1_free_device_dma_region(bus_id, dev_id, real_bus_addr);
+}
+
+static void gelic_debug_init(void)
+{
+	s64 result;
+	u64 v2;
+	u64 mac;
+	u64 vlan_id;
+
+	result = lv1_open_device(bus_id, dev_id, 0);
+	if (result)
+		lv1_panic(0);
+
+	map_dma_mem(bus_id, dev_id, &dbg, sizeof(dbg), &bus_addr);
+
+	memset(&dbg, 0, sizeof(dbg));
+
+	dbg.descr.buf_addr = bus_addr + offsetof(struct debug_block, pkt);
+
+	result = lv1_net_control(bus_id, dev_id, GELIC_LV1_GET_MAC_ADDRESS, 0, 0, 0, &mac, &v2);
+	if (result)
+		lv1_panic(0);
+
+	mac <<= 16;
+
+	h_eth = (struct ethhdr*)dbg.pkt;
+
+	memset(&h_eth->dest, 0xff, 6);
+	memcpy(&h_eth->src, &mac, 6);
+
+	header_size = sizeof(struct ethhdr);
+
+	result = lv1_net_control(bus_id, dev_id, GELIC_LV1_GET_VLAN_ID, \
+							 GELIC_LV1_VLAN_TX_ETHERNET_0, 0, 0, &vlan_id, &v2);
+	if (result == 0) {
+		h_eth->type = 0x8100;
+
+		header_size += sizeof(struct vlantag);
+		h_vlan = (struct vlantag*)(h_eth+1);
+		h_vlan->vlan = vlan_id;
+		h_vlan->subtype = 0x0800;
+		h_ip = (struct iphdr*)(h_vlan+1);
+	} else {
+		h_eth->type = 0x0800;
+		h_ip = (struct iphdr*)(h_eth+1);
+	}
+
+	header_size += sizeof(struct iphdr);
+	h_ip->ver_len = 0x45;
+	h_ip->ttl = 10;
+	h_ip->proto = 0x11;
+	h_ip->src = 0x00000000;
+	h_ip->dest = 0xffffffff;
+
+	header_size += sizeof(struct udphdr);
+	h_udp = (struct udphdr*)(h_ip+1);
+	h_udp->src = DEBUG_PORT;
+	h_udp->dest = DEBUG_PORT;
+
+	pmsgc = pmsg = (char*)(h_udp+1);
+}
+
+static void gelic_debug_shutdown(void)
+{
+	unmap_dma_mem(bus_id, dev_id, bus_addr, sizeof(dbg));
+	lv1_close_device(bus_id, dev_id);
+}
+
+static void gelic_sendbuf(int msgsize)
+{
+	u16 *p;
+	u32 sum;
+	int i;
+
+	dbg.descr.buf_size = header_size + msgsize;
+	h_ip->total_length = msgsize + sizeof(struct udphdr) + sizeof(struct iphdr);
+	h_udp->len = msgsize + sizeof(struct udphdr);
+
+	h_ip->checksum = 0;
+	sum = 0;
+	p = (u16*)h_ip;
+	for (i=0; i<5; i++)
+		sum += *p++;
+	h_ip->checksum = ~(sum + (sum>>16));
+
+	dbg.descr.dmac_cmd_status = GELIC_DESCR_DMA_CMD_NO_CHKSUM | GELIC_DESCR_TX_DMA_FRAME_TAIL;
+	dbg.descr.result_size = 0;
+	dbg.descr.data_status = 0;
+
+	lv1_net_start_tx_dma(bus_id, dev_id, bus_addr, 0);
+
+	while ((dbg.descr.dmac_cmd_status & GELIC_DESCR_DMA_STAT_MASK) == GELIC_DESCR_DMA_CARDOWNED);
+}
+
+static void ps3gelic_udbg_putc(char ch)
+{
+	*pmsgc++ = ch;
+	if (ch == '\n' || (pmsgc-pmsg) >= MAX_MESSAGE_SIZE) {
+		gelic_sendbuf(pmsgc-pmsg);
+		pmsgc = pmsg;
+	}
+}
+
+void __init udbg_init_ps3gelic(void)
+{
+	if (inited)
+		return;
+	gelic_debug_init();
+ 	udbg_putc = ps3gelic_udbg_putc;
+	inited = 1;
+}
+
+void udbg_shutdown_ps3gelic(void)
+{
+	if (!inited)
+		return;
+	udbg_putc = NULL;
+	gelic_debug_shutdown();
+	inited = 0;
+}
+
+EXPORT_SYMBOL(udbg_shutdown_ps3gelic);
+
+#endif /* CONFIG_PPC_EARLY_DEBUG_PS3GELIC */
+
+
diff -Nur linux-2.6.36-rc7/arch/powerpc/platforms/ps3/Kconfig ps3-linux/arch/powerpc/platforms/ps3/Kconfig
--- linux-2.6.36-rc7/arch/powerpc/platforms/ps3/Kconfig	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/platforms/ps3/Kconfig	2010-12-04 16:17:46.499967545 +0600
@@ -148,4 +148,55 @@
 	  profiling support of the Cell processor with programs like
 	  oprofile and perfmon2, then say Y or M, otherwise say N.
 
+config OPROFILE_PS3
+	def_bool y
+	depends on PPC_PS3 && (OPROFILE = m || OPROFILE = y)
+	select PS3_LPM
+
+config PS3_DEBUG_BOOT_MEM_LIMIT
+	depends on PPC_PS3
+	int  "PS3 Limit available boot memory"
+	range -1 1024
+	default -1
+	help
+	  This is a debug option used for memory stress testing.  Enter
+	  a value in units of MiB to limit available boot memory.
+
+	  If unsure, choose the default to disable this option.
+
+	  A negative value will disable this option.  A value of zero (0)
+	  will have maximum effect and the system can not boot.  The
+	  retail console reports 128 MiB of boot memory, this option
+	  will have no effect with a value of 128 or greater.
+
+config PS3_DEBUG_HOT_PLUG_MEM_LIMIT
+	depends on PPC_PS3
+	int  "PS3 Limit available hot plug memory"
+	range -1 1024
+	default -1
+	help
+	  This is a debug option used for memory stress testing.  Enter
+	  a value in units of MiB to limit available hot plug memory.
+
+	  If unsure, choose the default to disable this option.
+
+	  A negative value will disable this option.  A value of zero (0)
+	  will have maximum effect and the system will boot without hot
+	  plug memory.  Since the retail console reports about 128 MiB of
+	  hot plug memory, this option will have no effect with a value
+	  of 128 or greater.
+
+config PS3GELIC_UDBG
+	bool "PS3 udbg output via UDP broadcasts on Ethernet"
+	depends on PPC_PS3
+	help
+	  Enables udbg early debugging output by sending broadcast UDP
+	  via the Ethernet port (UDP port number 18194).
+
+	  This driver uses a trivial implementation and is independent
+	  from the main network driver.
+
+	  If in doubt, say N here.
+
+
 endmenu
diff -Nur linux-2.6.36-rc7/arch/powerpc/platforms/ps3/Makefile ps3-linux/arch/powerpc/platforms/ps3/Makefile
--- linux-2.6.36-rc7/arch/powerpc/platforms/ps3/Makefile	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/platforms/ps3/Makefile	2010-12-04 16:17:46.499967545 +0600
@@ -5,3 +5,4 @@
 obj-$(CONFIG_SMP) += smp.o
 obj-$(CONFIG_SPU_BASE) += spu.o
 obj-y += device-init.o
+obj-$(CONFIG_PS3GELIC_UDBG) += gelic_udbg.o
diff -Nur linux-2.6.36-rc7/arch/powerpc/platforms/ps3/mm.c ps3-linux/arch/powerpc/platforms/ps3/mm.c
--- linux-2.6.36-rc7/arch/powerpc/platforms/ps3/mm.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/platforms/ps3/mm.c	2010-12-04 16:17:46.509965763 +0600
@@ -18,6 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#define DEBUG
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/memory_hotplug.h>
@@ -110,6 +112,7 @@
 	u64 htab_size;
 	struct mem_region rm;
 	struct mem_region r1;
+	int destroy_r1;
 };
 
 #define debug_dump_map(x) _debug_dump_map(x, __func__, __LINE__)
@@ -287,51 +290,48 @@
 	}
 }
 
-/**
- * ps3_mm_add_memory - hot add memory
- */
-
-static int __init ps3_mm_add_memory(void)
+static int ps3_mm_scan_memory(unsigned long node, const char *uname, int depth, void *data)
 {
-	int result;
-	unsigned long start_addr;
-	unsigned long start_pfn;
-	unsigned long nr_pages;
+	struct mem_region *r = data;
+	void *p;
+	u64 prop[2];
+	unsigned long l;
+	char *type = of_get_flat_dt_prop(node, "device_type", NULL);
 
-	if (!firmware_has_feature(FW_FEATURE_PS3_LV1))
-		return -ENODEV;
-
-	BUG_ON(!mem_init_done);
-
-	start_addr = map.rm.size;
-	start_pfn = start_addr >> PAGE_SHIFT;
-	nr_pages = (map.r1.size + PAGE_SIZE - 1) >> PAGE_SHIFT;
-
-	DBG("%s:%d: start_addr %lxh, start_pfn %lxh, nr_pages %lxh\n",
-		__func__, __LINE__, start_addr, start_pfn, nr_pages);
+	if (type == NULL)
+		return 0;
+	if (strcmp(type, "memory") != 0)
+		return 0;
 
-	result = add_memory(0, start_addr, map.r1.size);
+	p = of_get_flat_dt_prop(node, "sony,lv1-highmem", &l);
+	if (p == NULL)
+		return 0;
 
-	if (result) {
-		pr_err("%s:%d: add_memory failed: (%d)\n",
-			__func__, __LINE__, result);
-		return result;
-	}
+	BUG_ON(l != sizeof(prop));
+	memcpy(prop, p, sizeof(prop));
 
-	memblock_add(start_addr, map.r1.size);
-	memblock_analyze();
+	r->base = prop[0];
+	r->size = prop[1];
+	r->offset = r->base - map.rm.size;
 
-	result = online_pages(start_pfn, nr_pages);
+	return -1;
+}
 
-	if (result)
-		pr_err("%s:%d: online_pages failed: (%d)\n",
-			__func__, __LINE__, result);
+static int ps3_mm_get_devtree_highmem(struct mem_region *r)
+{
+	r->size = r->base = r->offset = 0;
+	of_scan_flat_dt(ps3_mm_scan_memory, r);
 
-	return result;
+	if (r->base && r->size) {
+		DBG("%s:%d got high region from devtree: %llxh %llxh\n",
+		__func__, __LINE__, r->base, r->size);
+		return 0;
+	} else {
+		DBG("%s:%d no high region in devtree...\n", __func__, __LINE__);
+		return -1;
+	}
 }
 
-device_initcall(ps3_mm_add_memory);
-
 /*============================================================================*/
 /* dma routines                                                               */
 /*============================================================================*/
@@ -1217,13 +1217,49 @@
 	BUG_ON(map.rm.base);
 	BUG_ON(!map.rm.size);
 
+#if defined(CONFIG_PS3_DEBUG_BOOT_MEM_LIMIT) \
+	&& ((CONFIG_PS3_DEBUG_BOOT_MEM_LIMIT) >= 0)
+{
+	u64 orig_size = map.rm.size;
+
+	map.rm.size = min(map.rm.size,
+		(CONFIG_PS3_DEBUG_BOOT_MEM_LIMIT) * 1024 * 1024);
+	map.total -= orig_size - map.rm.size;
+	pr_info("Limiting boot RAM to 0x%llx (%llu MiB)\n", map.rm.size,
+		map.rm.size / (1024 * 1024));
+}
+#endif
+
+#if defined(CONFIG_PS3_DEBUG_HOT_PLUG_MEM_LIMIT) \
+	&& ((CONFIG_PS3_DEBUG_HOT_PLUG_MEM_LIMIT) >= 0)
+	map.total = min(map.total, map.rm.size
+		+ (CONFIG_PS3_DEBUG_HOT_PLUG_MEM_LIMIT) * 1024 * 1024);
+	pr_info("Limiting total RAM to 0x%llx (%llu MiB)\n", map.total,
+		map.total / (1024 * 1024));
+#endif
 
 	/* arrange to do this in ps3_mm_add_memory */
-	ps3_mm_region_create(&map.r1, map.total - map.rm.size);
+
+	if (ps3_mm_get_devtree_highmem(&map.r1) == 0) {
+		map.destroy_r1 = 0;
+	} else {
+		ps3_mm_region_create(&map.r1, map.total - map.rm.size);
+		map.destroy_r1 = 1;
+	}
 
 	/* correct map.total for the real total amount of memory we use */
 	map.total = map.rm.size + map.r1.size;
 
+	if (!map.r1.size) {
+		DBG("%s:%d: no region 1, not adding memory\n", __func__, __LINE__);
+	} else {
+		DBG("%s:%d: adding memory: start %llxh, size %llxh\n",
+			__func__, __LINE__, map.rm.size, map.r1.size);
+
+		memblock_add(map.rm.size, map.r1.size);
+		memblock_analyze();
+	}
+
 	DBG(" <- %s:%d\n", __func__, __LINE__);
 }
 
@@ -1233,5 +1269,6 @@
 
 void ps3_mm_shutdown(void)
 {
-	ps3_mm_region_destroy(&map.r1);
+	if (map.destroy_r1)
+		ps3_mm_region_destroy(&map.r1);
 }
diff -Nur linux-2.6.36-rc7/arch/powerpc/platforms/ps3/os-area.c ps3-linux/arch/powerpc/platforms/ps3/os-area.c
--- linux-2.6.36-rc7/arch/powerpc/platforms/ps3/os-area.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/platforms/ps3/os-area.c	2010-12-04 16:17:46.509965763 +0600
@@ -18,6 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#define DEBUG
+
 #include <linux/kernel.h>
 #include <linux/io.h>
 #include <linux/workqueue.h>
diff -Nur linux-2.6.36-rc7/arch/powerpc/platforms/ps3/repository.c ps3-linux/arch/powerpc/platforms/ps3/repository.c
--- linux-2.6.36-rc7/arch/powerpc/platforms/ps3/repository.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/platforms/ps3/repository.c	2010-12-04 16:17:46.509965763 +0600
@@ -131,11 +131,11 @@
 		lpar_id = id;
 	}
 
-	result = lv1_get_repository_node_value(lpar_id, n1, n2, n3, n4, &v1,
+	result = lv1_read_repository_node(lpar_id, n1, n2, n3, n4, &v1,
 		&v2);
 
 	if (result) {
-		pr_debug("%s:%d: lv1_get_repository_node_value failed: %s\n",
+		pr_debug("%s:%d: lv1_read_repository_node failed: %s\n",
 			__func__, __LINE__, ps3_result(result));
 		dump_node_name(lpar_id, n1, n2, n3, n4);
 		return -ENOENT;
@@ -184,7 +184,7 @@
 	enum ps3_bus_type *bus_type)
 {
 	int result;
-	u64 v1;
+	u64 v1 = 0;
 
 	result = read_node(PS3_LPAR_ID_PME,
 		make_first_field("bus", bus_index),
@@ -199,7 +199,7 @@
 	unsigned int *num_dev)
 {
 	int result;
-	u64 v1;
+	u64 v1 = 0;
 
 	result = read_node(PS3_LPAR_ID_PME,
 		make_first_field("bus", bus_index),
@@ -239,7 +239,7 @@
 	unsigned int dev_index, enum ps3_dev_type *dev_type)
 {
 	int result;
-	u64 v1;
+	u64 v1 = 0;
 
 	result = read_node(PS3_LPAR_ID_PME,
 		make_first_field("bus", bus_index),
@@ -256,8 +256,8 @@
 	enum ps3_interrupt_type *intr_type, unsigned int *interrupt_id)
 {
 	int result;
-	u64 v1;
-	u64 v2;
+	u64 v1 = 0;
+	u64 v2 = 0;
 
 	result = read_node(PS3_LPAR_ID_PME,
 		make_first_field("bus", bus_index),
@@ -275,7 +275,7 @@
 	enum ps3_reg_type *reg_type)
 {
 	int result;
-	u64 v1;
+	u64 v1 = 0;
 
 	result = read_node(PS3_LPAR_ID_PME,
 		make_first_field("bus", bus_index),
@@ -615,7 +615,7 @@
 	unsigned int dev_index, unsigned int *num_regions)
 {
 	int result;
-	u64 v1;
+	u64 v1 = 0;
 
 	result = read_node(PS3_LPAR_ID_PME,
 		make_first_field("bus", bus_index),
@@ -631,7 +631,7 @@
 	unsigned int *region_id)
 {
 	int result;
-	u64 v1;
+	u64 v1 = 0;
 
 	result = read_node(PS3_LPAR_ID_PME,
 	    make_first_field("bus", bus_index),
@@ -786,7 +786,7 @@
 int ps3_repository_read_num_spu_reserved(unsigned int *num_spu_reserved)
 {
 	int result;
-	u64 v1;
+	u64 v1 = 0;
 
 	result = read_node(PS3_LPAR_ID_CURRENT,
 		make_first_field("bi", 0),
@@ -805,7 +805,7 @@
 int ps3_repository_read_num_spu_resource_id(unsigned int *num_resource_id)
 {
 	int result;
-	u64 v1;
+	u64 v1 = 0;
 
 	result = read_node(PS3_LPAR_ID_CURRENT,
 		make_first_field("bi", 0),
@@ -827,8 +827,8 @@
 	enum ps3_spu_resource_type *resource_type, unsigned int *resource_id)
 {
 	int result;
-	u64 v1;
-	u64 v2;
+	u64 v1 = 0;
+	u64 v2 = 0;
 
 	result = read_node(PS3_LPAR_ID_CURRENT,
 		make_first_field("bi", 0),
@@ -854,7 +854,7 @@
 int ps3_repository_read_boot_dat_size(unsigned int *size)
 {
 	int result;
-	u64 v1;
+	u64 v1 = 0;
 
 	result = read_node(PS3_LPAR_ID_CURRENT,
 		make_first_field("bi", 0),
@@ -869,7 +869,7 @@
 int ps3_repository_read_vuart_av_port(unsigned int *port)
 {
 	int result;
-	u64 v1;
+	u64 v1 = 0;
 
 	result = read_node(PS3_LPAR_ID_CURRENT,
 		make_first_field("bi", 0),
@@ -884,7 +884,7 @@
 int ps3_repository_read_vuart_sysmgr_port(unsigned int *port)
 {
 	int result;
-	u64 v1;
+	u64 v1 = 0;
 
 	result = read_node(PS3_LPAR_ID_CURRENT,
 		make_first_field("bi", 0),
@@ -919,7 +919,7 @@
 int ps3_repository_read_num_be(unsigned int *num_be)
 {
 	int result;
-	u64 v1;
+	u64 v1 = 0;
 
 	result = read_node(PS3_LPAR_ID_PME,
 		make_first_field("ben", 0),
@@ -1050,7 +1050,7 @@
 
 		pr_debug("%s:%d (%u:%u) reg_type %u, bus_addr %lxh, len %lxh\n",
 			__func__, __LINE__, repo->bus_index, repo->dev_index,
-			reg_type, bus_addr, len);
+			reg_type, (unsigned long)bus_addr, (unsigned long)len);
 	}
 
 	pr_debug(" <- %s:%d\n", __func__, __LINE__);
@@ -1077,8 +1077,9 @@
 
 	pr_debug("%s:%d  (%u:%u): port %lu, blk_size %lu, num_blocks "
 		 "%lu, num_regions %u\n",
-		 __func__, __LINE__, repo->bus_index, repo->dev_index, port,
-		 blk_size, num_blocks, num_regions);
+		 __func__, __LINE__, repo->bus_index, repo->dev_index,
+		(unsigned long)port, (unsigned long)blk_size,
+		(unsigned long)num_blocks, num_regions);
 
 	for (region_index = 0; region_index < num_regions; region_index++) {
 		unsigned int region_id;
@@ -1096,7 +1097,8 @@
 
 		pr_debug("%s:%d (%u:%u) region_id %u, start %lxh, size %lxh\n",
 			__func__, __LINE__, repo->bus_index, repo->dev_index,
-			region_id, region_start, region_size);
+			region_id, (unsigned long)region_start,
+			(unsigned long)region_size);
 	}
 
 out:
@@ -1136,7 +1138,7 @@
 
 		pr_debug("%s:%d  (%u:%u): dev_type %u, dev_id %lu\n", __func__,
 			__LINE__, repo->bus_index, repo->dev_index,
-			repo->dev_type, repo->dev_id);
+			repo->dev_type, (unsigned long)repo->dev_id);
 
 		ps3_repository_dump_resource_info(repo);
 
@@ -1193,7 +1195,7 @@
 
 		pr_debug("%s:%d bus_%u: bus_type %u, bus_id %lu, num_dev %u\n",
 			__func__, __LINE__, repo.bus_index, repo.bus_type,
-			repo.bus_id, num_dev);
+			(unsigned long)repo.bus_id, num_dev);
 
 		dump_device_info(&repo, num_dev);
 	}
diff -Nur linux-2.6.36-rc7/arch/powerpc/platforms/ps3/setup.c ps3-linux/arch/powerpc/platforms/ps3/setup.c
--- linux-2.6.36-rc7/arch/powerpc/platforms/ps3/setup.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/platforms/ps3/setup.c	2010-12-04 16:17:46.509965763 +0600
@@ -36,6 +36,8 @@
 
 #include "platform.h"
 
+#define DEBUG
+
 #if defined(DEBUG)
 #define DBG udbg_printf
 #else
@@ -190,12 +192,44 @@
 	return lv1_set_dabr(dabr, DABR_KERNEL | DABR_USER) ? -1 : 0;
 }
 
+/**
+ * ps3_debug_setup_dabr - Setup the DABR for kernel use.
+ * @dabr_flags: DABR_DATA_WRITE, DABR_DATA_READ, DABR_TRANSLATION
+ */
+
+int ps3_debug_setup_dabr(u64 address, unsigned int dabr_flags)
+{
+	int result;
+	u64 reg;
+
+	BUG_ON(dabr_flags
+		& ~(DABR_DATA_WRITE | DABR_DATA_READ | DABR_TRANSLATION));
+
+	/* PS3 seems to need DABR_TRANSLATION set to work */
+
+	reg = (address & -8L) | dabr_flags | DABR_TRANSLATION;
+
+	printk("%s: address %016llxh, flags %xh = %016llxh\n", __func__,
+		address, dabr_flags, reg);
+
+	result = ps3_set_dabr(reg);
+
+	if (result)
+		printk("%s: failed: %d %s\n", __func__, result,
+			ps3_result(result));
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(ps3_debug_setup_dabr);
+
 static void __init ps3_setup_arch(void)
 {
+	u64 tmp;
 
 	DBG(" -> %s:%d\n", __func__, __LINE__);
 
-	lv1_get_version_info(&ps3_firmware_version.raw);
+	lv1_get_version_info(&ps3_firmware_version.raw, &tmp);
+
 	printk(KERN_INFO "PS3 firmware version %u.%u.%u\n",
 	       ps3_firmware_version.major, ps3_firmware_version.minor,
 	       ps3_firmware_version.rev);
diff -Nur linux-2.6.36-rc7/arch/powerpc/platforms/ps3/spu.c ps3-linux/arch/powerpc/platforms/ps3/spu.c
--- linux-2.6.36-rc7/arch/powerpc/platforms/ps3/spu.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/arch/powerpc/platforms/ps3/spu.c	2010-12-04 16:17:46.509965763 +0600
@@ -18,6 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#define DEBUG
+
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/slab.h>
@@ -153,7 +155,7 @@
 	u64 id;
 
 	lv1_get_logical_ppe_id(&id);
-	lv1_get_virtual_address_space_id_of_ppe(id, &id);
+	lv1_get_virtual_address_space_id_of_ppe(&id);
 
 	return id;
 }
@@ -420,11 +422,13 @@
 		if (result)
 			break;
 
-		if (resource_type == PS3_SPU_RESOURCE_TYPE_EXCLUSIVE) {
+		if (resource_type & PS3_SPU_RESOURCE_TYPE_EXCLUSIVE) {
 			result = fn((void*)(unsigned long)resource_id);
 
 			if (result)
 				break;
+		} else {
+			pr_debug("%s:%d: SPU %d is not exclusive (type 0x%lx)\n", __func__, __LINE__, i, resource_type);
 		}
 	}
 
diff -Nur linux-2.6.36-rc7/drivers/net/ps3_gelic_net.c ps3-linux/drivers/net/ps3_gelic_net.c
--- linux-2.6.36-rc7/drivers/net/ps3_gelic_net.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/drivers/net/ps3_gelic_net.c	2010-12-04 16:17:47.859966781 +0600
@@ -26,7 +26,8 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#undef DEBUG
+//#undef DEBUG
+#define DEBUG
 
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -56,6 +57,9 @@
 MODULE_DESCRIPTION("Gelic Network driver");
 MODULE_LICENSE("GPL");
 
+#ifdef CONFIG_PPC_EARLY_DEBUG_PS3GELIC
+void udbg_shutdown_ps3gelic(void);
+#endif
 
 static inline void gelic_card_enable_rxdmac(struct gelic_card *card);
 static inline void gelic_card_disable_rxdmac(struct gelic_card *card);
@@ -639,10 +643,10 @@
 	int status;
 
 	/* this hvc blocks until the DMA in progress really stopped */
-	status = lv1_net_stop_rx_dma(bus_id(card), dev_id(card), 0);
+	status = lv1_net_stop_rx_dma(bus_id(card), dev_id(card));
 	if (status)
 		dev_err(ctodev(card),
-			"lv1_net_stop_rx_dma faild, %d\n", status);
+			"lv1_net_stop_rx_dma failed, %d\n", status);
 }
 
 /**
@@ -657,10 +661,10 @@
 	int status;
 
 	/* this hvc blocks until the DMA in progress really stopped */
-	status = lv1_net_stop_tx_dma(bus_id(card), dev_id(card), 0);
+	status = lv1_net_stop_tx_dma(bus_id(card), dev_id(card));
 	if (status)
 		dev_err(ctodev(card),
-			"lv1_net_stop_tx_dma faild, status=%d\n", status);
+			"lv1_net_stop_tx_dma failed, status=%d\n", status);
 }
 
 /**
@@ -986,10 +990,6 @@
 	int dmac_chain_ended;
 
 	status = gelic_descr_get_status(descr);
-	/* is this descriptor terminated with next_descr == NULL? */
-	dmac_chain_ended =
-		be32_to_cpu(descr->dmac_cmd_status) &
-		GELIC_DESCR_RX_DMA_CHAIN_END;
 
 	if (status == GELIC_DESCR_DMA_CARDOWNED)
 		return 0;
@@ -1052,6 +1052,11 @@
 	/* ok, we've got a packet in descr */
 	gelic_net_pass_skb_up(descr, card, netdev);
 refill:
+
+	/* is the current descriptor terminated with next_descr == NULL? */
+	dmac_chain_ended =
+		be32_to_cpu(descr->dmac_cmd_status) &
+		GELIC_DESCR_RX_DMA_CHAIN_END;
 	/*
 	 * So that always DMAC can see the end
 	 * of the descriptor chain to avoid
@@ -1080,10 +1085,9 @@
 	 * If dmac chain was met, DMAC stopped.
 	 * thus re-enable it
 	 */
-	if (dmac_chain_ended) {
-		card->rx_dma_restart_required = 1;
-		dev_dbg(ctodev(card), "reenable rx dma scheduled\n");
-	}
+
+	if (dmac_chain_ended)
+		gelic_card_enable_rxdmac(card);
 
 	return 1;
 }
@@ -1149,11 +1153,6 @@
 
 	status &= card->irq_mask;
 
-	if (card->rx_dma_restart_required) {
-		card->rx_dma_restart_required = 0;
-		gelic_card_enable_rxdmac(card);
-	}
-
 	if (status & GELIC_CARD_RXINT) {
 		gelic_card_rx_irq_off(card);
 		napi_schedule(&card->napi);
@@ -1687,6 +1686,11 @@
 	int result;
 
 	pr_debug("%s: called\n", __func__);
+
+#ifdef CONFIG_PPC_EARLY_DEBUG_PS3GELIC
+	udbg_shutdown_ps3gelic();
+#endif
+
 	result = ps3_open_hv_device(dev);
 
 	if (result) {
diff -Nur linux-2.6.36-rc7/drivers/net/ps3_gelic_net.h ps3-linux/drivers/net/ps3_gelic_net.h
--- linux-2.6.36-rc7/drivers/net/ps3_gelic_net.h	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/drivers/net/ps3_gelic_net.h	2010-12-04 16:17:47.859966781 +0600
@@ -289,7 +289,6 @@
 
 	struct gelic_descr_chain tx_chain;
 	struct gelic_descr_chain rx_chain;
-	int rx_dma_restart_required;
 	int rx_csum;
 	/*
 	 * tx_lock guards tx descriptor list and
diff -Nur linux-2.6.36-rc7/drivers/ps3/ps3av.c ps3-linux/drivers/ps3/ps3av.c
--- linux-2.6.36-rc7/drivers/ps3/ps3av.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/drivers/ps3/ps3av.c	2010-12-04 16:17:48.189846622 +0600
@@ -18,6 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#define DEBUG
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/delay.h>
diff -Nur linux-2.6.36-rc7/drivers/ps3/ps3-lpm.c ps3-linux/drivers/ps3/ps3-lpm.c
--- linux-2.6.36-rc7/drivers/ps3/ps3-lpm.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/drivers/ps3/ps3-lpm.c	2010-12-04 16:17:48.169341426 +0600
@@ -18,6 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#define DEBUG
+
 #include <linux/slab.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -145,20 +147,16 @@
 	PS3_LPM_DEFAULT_TB_CACHE_SIZE = 0x4000,
 };
 
-/**
- * lpm_priv - Static instance of the lpm data.
- *
- * Since the exported routines don't support the notion of a device
- * instance we need to hold the instance in this static variable
- * and then only allow at most one instance at a time to be created.
- */
-
-static struct ps3_lpm_priv *lpm_priv;
+static struct device *sbd(struct ps3_lpm_priv *p)
+{
+	BUG_ON(!p || !p->sbd);
+	return &p->sbd->core;
+}
 
-static struct device *sbd_core(void)
+static struct ps3_lpm_priv *to_priv(void *p)
 {
-	BUG_ON(!lpm_priv || !lpm_priv->sbd);
-	return &lpm_priv->sbd->core;
+	BUG_ON(!p);
+	return p;
 }
 
 /**
@@ -201,28 +199,150 @@
 EXPORT_SYMBOL_GPL(ps3_set_pm_bookmark);
 
 /**
+ * ps3_read_pm - Read Other LPM control registers.
+ */
+
+static u32 ps3_read_pm(void *p, u32 cpu, enum pm_reg_name reg)
+{
+	struct ps3_lpm_priv *priv = to_priv(p);
+	int result = 0;
+	u64 val = 0;
+
+	switch (reg) {
+	case pm_control:
+		return priv->shadow.pm_control;
+	case trace_address:
+		return CBE_PM_TRACE_BUF_EMPTY;
+	case pm_start_stop:
+		return priv->shadow.pm_start_stop;
+	case pm_interval:
+		result = lv1_set_lpm_interval(priv->lpm_id, 0, 0, &val);
+		if (result) {
+			val = 0;
+			dev_dbg(sbd(priv), "%s:%u: lv1 set_inteval failed: "
+				"reg %u, %s\n", __func__, __LINE__, reg,
+				ps3_result(result));
+		}
+		return (u32)val;
+	case group_control:
+		return priv->shadow.group_control;
+	case debug_bus_control:
+		return priv->shadow.debug_bus_control;
+	case pm_status:
+		result = lv1_get_lpm_interrupt_status(priv->lpm_id,
+						      &val);
+		if (result) {
+			val = 0;
+			dev_dbg(sbd(priv), "%s:%u: lv1 get_lpm_status failed: "
+				"reg %u, %s\n", __func__, __LINE__, reg,
+				ps3_result(result));
+		}
+		return (u32)val;
+	case ext_tr_timer:
+		return 0;
+	default:
+		dev_dbg(sbd(priv), "%s:%u: unknown reg: %d\n", __func__,
+			__LINE__, reg);
+		BUG();
+		break;
+	}
+
+	return 0;
+}
+
+/**
+ * ps3_write_pm - Write Other LPM control registers.
+ */
+
+static void ps3_write_pm(void* p, u32 cpu, enum pm_reg_name reg,
+	u32 val)
+{
+	struct ps3_lpm_priv *priv = to_priv(p);
+	int result = 0;
+	u64 dummy;
+
+	switch (reg) {
+	case group_control:
+		if (val != priv->shadow.group_control)
+			result = lv1_set_lpm_group_control(priv->lpm_id,
+							   val,
+							   PS3_WRITE_PM_MASK,
+							   &dummy);
+		priv->shadow.group_control = val;
+		break;
+	case debug_bus_control:
+		if (val != priv->shadow.debug_bus_control)
+			result = lv1_set_lpm_debug_bus_control(priv->lpm_id,
+							      val,
+							      PS3_WRITE_PM_MASK,
+							      &dummy);
+		priv->shadow.debug_bus_control = val;
+		break;
+	case pm_control:
+		if (use_start_stop_bookmark)
+			val |= (PS3_PM_CONTROL_PPU_TH0_BOOKMARK |
+				PS3_PM_CONTROL_PPU_TH1_BOOKMARK);
+		if (val != priv->shadow.pm_control)
+			result = lv1_set_lpm_general_control(priv->lpm_id,
+							     val,
+							     PS3_WRITE_PM_MASK,
+							     0, 0, &dummy,
+							     &dummy);
+		priv->shadow.pm_control = val;
+		break;
+	case pm_interval:
+		result = lv1_set_lpm_interval(priv->lpm_id, val,
+					      PS3_WRITE_PM_MASK, &dummy);
+		break;
+	case pm_start_stop:
+		if (val != priv->shadow.pm_start_stop)
+			result = lv1_set_lpm_trigger_control(priv->lpm_id,
+							     val,
+							     PS3_WRITE_PM_MASK,
+							     &dummy);
+		priv->shadow.pm_start_stop = val;
+		break;
+	case trace_address:
+	case ext_tr_timer:
+	case pm_status:
+		break;
+	default:
+		dev_dbg(sbd(priv), "%s:%u: unknown reg: %d\n", __func__,
+			__LINE__, reg);
+		BUG();
+		break;
+	}
+
+	if (result)
+		dev_err(sbd(priv), "%s:%u: lv1 set_control failed: "
+			"reg %u, %s\n", __func__, __LINE__, reg,
+			ps3_result(result));
+}
+
+/**
  * ps3_read_phys_ctr - Read physical counter registers.
  *
  * Each physical counter can act as one 32 bit counter or as two 16 bit
  * counters.
  */
 
-u32 ps3_read_phys_ctr(u32 cpu, u32 phys_ctr)
+static u32 ps3_read_phys_ctr(void* p, u32 cpu, u32 phys_ctr)
 {
+	struct ps3_lpm_priv *priv = to_priv(p);
 	int result;
 	u64 counter0415;
 	u64 counter2637;
 
 	if (phys_ctr >= NR_PHYS_CTRS) {
-		dev_dbg(sbd_core(), "%s:%u: phys_ctr too big: %u\n", __func__,
+		dev_dbg(sbd(priv), "%s:%u: phys_ctr too big: %u\n", __func__,
 			__LINE__, phys_ctr);
 		return 0;
 	}
 
-	result = lv1_set_lpm_counter(lpm_priv->lpm_id, 0, 0, 0, 0, &counter0415,
+	result = lv1_set_lpm_counter(priv->lpm_id, 0, 0, 0, 0, &counter0415,
 				     &counter2637);
 	if (result) {
-		dev_err(sbd_core(), "%s:%u: lv1_set_lpm_counter failed: "
+		dev_err(sbd(priv), "%s:%u: lv1_set_lpm_counter failed: "
 			"phys_ctr %u, %s\n", __func__, __LINE__, phys_ctr,
 			ps3_result(result));
 		return 0;
@@ -242,7 +362,6 @@
 	}
 	return 0;
 }
-EXPORT_SYMBOL_GPL(ps3_read_phys_ctr);
 
 /**
  * ps3_write_phys_ctr - Write physical counter registers.
@@ -251,8 +370,10 @@
  * counters.
  */
 
-void ps3_write_phys_ctr(u32 cpu, u32 phys_ctr, u32 val)
+static void ps3_write_phys_ctr(void* p, u32 cpu, u32 phys_ctr,
+	u32 val)
 {
+	struct ps3_lpm_priv *priv = to_priv(p);
 	u64 counter0415;
 	u64 counter0415_mask;
 	u64 counter2637;
@@ -260,7 +381,7 @@
 	int result;
 
 	if (phys_ctr >= NR_PHYS_CTRS) {
-		dev_dbg(sbd_core(), "%s:%u: phys_ctr too big: %u\n", __func__,
+		dev_dbg(sbd(priv), "%s:%u: phys_ctr too big: %u\n", __func__,
 			__LINE__, phys_ctr);
 		return;
 	}
@@ -294,16 +415,69 @@
 		BUG();
 	}
 
-	result = lv1_set_lpm_counter(lpm_priv->lpm_id,
+	result = lv1_set_lpm_counter(priv->lpm_id,
 				     counter0415, counter0415_mask,
 				     counter2637, counter2637_mask,
 				     &counter0415, &counter2637);
 	if (result)
-		dev_err(sbd_core(), "%s:%u: lv1_set_lpm_counter failed: "
+		dev_err(sbd(priv), "%s:%u: lv1_set_lpm_counter failed: "
 			"phys_ctr %u, val %u, %s\n", __func__, __LINE__,
 			phys_ctr, val, ps3_result(result));
 }
-EXPORT_SYMBOL_GPL(ps3_write_phys_ctr);
+
+/**
+ * ps3_get_ctr_size - Get the size of a physical counter.
+ *
+ * Returns either 16 or 32.
+ */
+
+static u32 ps3_get_ctr_size(void* p, u32 cpu, u32 phys_ctr)
+{
+	struct ps3_lpm_priv *priv = to_priv(p);
+	u32 pm_ctrl;
+
+	if (phys_ctr >= NR_PHYS_CTRS) {
+		dev_dbg(sbd(priv), "%s:%u: phys_ctr too big: %u\n", __func__,
+			__LINE__, phys_ctr);
+		return 0;
+	}
+
+	pm_ctrl = ps3_read_pm(p, cpu, pm_control);
+	return (pm_ctrl & CBE_PM_16BIT_CTR(phys_ctr)) ? 16 : 32;
+}
+
+/**
+ * ps3_set_ctr_size - Set the size of a physical counter to 16 or 32 bits.
+ */
+
+static void ps3_set_ctr_size(void* p, u32 cpu, u32 phys_ctr,
+	u32 ctr_size)
+{
+	struct ps3_lpm_priv *priv = to_priv(p);
+	u32 pm_ctrl;
+
+	if (phys_ctr >= NR_PHYS_CTRS) {
+		dev_dbg(sbd(priv), "%s:%u: phys_ctr too big: %u\n", __func__,
+			__LINE__, phys_ctr);
+		return;
+	}
+
+	pm_ctrl = ps3_read_pm(p, cpu, pm_control);
+
+	switch (ctr_size) {
+	case 16:
+		pm_ctrl |= CBE_PM_16BIT_CTR(phys_ctr);
+		ps3_write_pm(p, cpu, pm_control, pm_ctrl);
+		break;
+
+	case 32:
+		pm_ctrl &= ~CBE_PM_16BIT_CTR(phys_ctr);
+		ps3_write_pm(p, cpu, pm_control, pm_ctrl);
+		break;
+	default:
+		BUG();
+	}
+}
 
 /**
  * ps3_read_ctr - Read counter.
@@ -312,19 +486,18 @@
  * Counters 4, 5, 6 & 7 are always 16 bit.
  */
 
-u32 ps3_read_ctr(u32 cpu, u32 ctr)
+static u32 ps3_read_ctr(void* p, u32 cpu, u32 ctr)
 {
 	u32 val;
 	u32 phys_ctr = ctr & (NR_PHYS_CTRS - 1);
 
-	val = ps3_read_phys_ctr(cpu, phys_ctr);
+	val = ps3_read_phys_ctr(p, cpu, phys_ctr);
 
-	if (ps3_get_ctr_size(cpu, phys_ctr) == 16)
+	if (ps3_get_ctr_size(p, cpu, phys_ctr) == 16)
 		val = (ctr < NR_PHYS_CTRS) ? (val >> 16) : (val & 0xffff);
 
 	return val;
 }
-EXPORT_SYMBOL_GPL(ps3_read_ctr);
 
 /**
  * ps3_write_ctr - Write counter.
@@ -333,15 +506,15 @@
  * Counters 4, 5, 6 & 7 are always 16 bit.
  */
 
-void ps3_write_ctr(u32 cpu, u32 ctr, u32 val)
+static void ps3_write_ctr(void* p, u32 cpu, u32 ctr, u32 val)
 {
 	u32 phys_ctr;
 	u32 phys_val;
 
 	phys_ctr = ctr & (NR_PHYS_CTRS - 1);
 
-	if (ps3_get_ctr_size(cpu, phys_ctr) == 16) {
-		phys_val = ps3_read_phys_ctr(cpu, phys_ctr);
+	if (ps3_get_ctr_size(p, cpu, phys_ctr) == 16) {
+		phys_val = ps3_read_phys_ctr(p, cpu, phys_ctr);
 
 		if (ctr < NR_PHYS_CTRS)
 			val = (val << 16) | (phys_val & 0xffff);
@@ -349,9 +522,8 @@
 			val = (val & 0xffff) | (phys_val & 0xffff0000);
 	}
 
-	ps3_write_phys_ctr(cpu, phys_ctr, val);
+	ps3_write_phys_ctr(p, cpu, phys_ctr, val);
 }
-EXPORT_SYMBOL_GPL(ps3_write_ctr);
 
 /**
  * ps3_read_pm07_control - Read counter control registers.
@@ -359,11 +531,10 @@
  * Each logical counter has a corresponding control register.
  */
 
-u32 ps3_read_pm07_control(u32 cpu, u32 ctr)
+static u32 ps3_read_pm07_control(void* p, u32 cpu, u32 ctr)
 {
 	return 0;
 }
-EXPORT_SYMBOL_GPL(ps3_read_pm07_control);
 
 /**
  * ps3_write_pm07_control - Write counter control registers.
@@ -371,199 +542,138 @@
  * Each logical counter has a corresponding control register.
  */
 
-void ps3_write_pm07_control(u32 cpu, u32 ctr, u32 val)
+static void ps3_write_pm07_control(void* p, u32 cpu, u32 ctr,
+	u32 val)
 {
+	struct ps3_lpm_priv *priv = to_priv(p);
 	int result;
 	static const u64 mask = 0xFFFFFFFFFFFFFFFFULL;
 	u64 old_value;
 
 	if (ctr >= NR_CTRS) {
-		dev_dbg(sbd_core(), "%s:%u: ctr too big: %u\n", __func__,
+		dev_dbg(sbd(priv), "%s:%u: ctr too big: %u\n", __func__,
 			__LINE__, ctr);
 		return;
 	}
 
-	result = lv1_set_lpm_counter_control(lpm_priv->lpm_id, ctr, val, mask,
+	result = lv1_set_lpm_counter_control(priv->lpm_id, ctr, val, mask,
 					     &old_value);
 	if (result)
-		dev_err(sbd_core(), "%s:%u: lv1_set_lpm_counter_control "
+		dev_err(sbd(priv), "%s:%u: lv1_set_lpm_counter_control "
 			"failed: ctr %u, %s\n", __func__, __LINE__, ctr,
 			ps3_result(result));
 }
-EXPORT_SYMBOL_GPL(ps3_write_pm07_control);
 
 /**
- * ps3_read_pm - Read Other LPM control registers.
+ * ps3_enable_pm - Enable the entire performance monitoring unit.
+ *
+ * When we enable the LPM, all pending writes to counters get committed.
  */
 
-u32 ps3_read_pm(u32 cpu, enum pm_reg_name reg)
+static void ps3_enable_pm(void* p, u32 cpu)
 {
-	int result = 0;
-	u64 val = 0;
+	struct ps3_lpm_priv *priv = to_priv(p);
+	int result;
+	u64 tmp;
+	int insert_bookmark = 0;
 
-	switch (reg) {
-	case pm_control:
-		return lpm_priv->shadow.pm_control;
-	case trace_address:
-		return CBE_PM_TRACE_BUF_EMPTY;
-	case pm_start_stop:
-		return lpm_priv->shadow.pm_start_stop;
-	case pm_interval:
-		result = lv1_set_lpm_interval(lpm_priv->lpm_id, 0, 0, &val);
-		if (result) {
-			val = 0;
-			dev_dbg(sbd_core(), "%s:%u: lv1 set_inteval failed: "
-				"reg %u, %s\n", __func__, __LINE__, reg,
-				ps3_result(result));
-		}
-		return (u32)val;
-	case group_control:
-		return lpm_priv->shadow.group_control;
-	case debug_bus_control:
-		return lpm_priv->shadow.debug_bus_control;
-	case pm_status:
-		result = lv1_get_lpm_interrupt_status(lpm_priv->lpm_id,
-						      &val);
-		if (result) {
-			val = 0;
-			dev_dbg(sbd_core(), "%s:%u: lv1 get_lpm_status failed: "
-				"reg %u, %s\n", __func__, __LINE__, reg,
-				ps3_result(result));
+	priv->tb_count = 0;
+
+	if (use_start_stop_bookmark) {
+		if (!(priv->shadow.pm_start_stop &
+			(PS3_PM_START_STOP_START_MASK
+			| PS3_PM_START_STOP_STOP_MASK))) {
+			result = lv1_set_lpm_trigger_control(priv->lpm_id,
+				(PS3_PM_START_STOP_PPU_TH0_BOOKMARK_START |
+				PS3_PM_START_STOP_PPU_TH1_BOOKMARK_START |
+				PS3_PM_START_STOP_PPU_TH0_BOOKMARK_STOP |
+				PS3_PM_START_STOP_PPU_TH1_BOOKMARK_STOP),
+				0xFFFFFFFFFFFFFFFFULL, &tmp);
+
+			if (result)
+				dev_err(sbd(priv), "%s:%u: "
+					"lv1_set_lpm_trigger_control failed: "
+					"%s\n", __func__, __LINE__,
+					ps3_result(result));
+
+			insert_bookmark = !result;
 		}
-		return (u32)val;
-	case ext_tr_timer:
-		return 0;
-	default:
-		dev_dbg(sbd_core(), "%s:%u: unknown reg: %d\n", __func__,
-			__LINE__, reg);
-		BUG();
-		break;
 	}
 
-	return 0;
+	result = lv1_start_lpm(priv->lpm_id);
+
+	if (result)
+		dev_err(sbd(priv), "%s:%u: lv1_start_lpm failed: %s\n",
+			__func__, __LINE__, ps3_result(result));
+
+	if (use_start_stop_bookmark && !result && insert_bookmark)
+		ps3_set_bookmark(get_tb() | PS3_PM_BOOKMARK_START);
 }
-EXPORT_SYMBOL_GPL(ps3_read_pm);
 
 /**
- * ps3_write_pm - Write Other LPM control registers.
+ * ps3_disable_pm - Disable the entire performance monitoring unit.
  */
 
-void ps3_write_pm(u32 cpu, enum pm_reg_name reg, u32 val)
+static void ps3_disable_pm(void* p, u32 cpu)
 {
-	int result = 0;
-	u64 dummy;
+	struct ps3_lpm_priv *priv = to_priv(p);
+	int result;
+	u64 tmp;
 
-	switch (reg) {
-	case group_control:
-		if (val != lpm_priv->shadow.group_control)
-			result = lv1_set_lpm_group_control(lpm_priv->lpm_id,
-							   val,
-							   PS3_WRITE_PM_MASK,
-							   &dummy);
-		lpm_priv->shadow.group_control = val;
-		break;
-	case debug_bus_control:
-		if (val != lpm_priv->shadow.debug_bus_control)
-			result = lv1_set_lpm_debug_bus_control(lpm_priv->lpm_id,
-							      val,
-							      PS3_WRITE_PM_MASK,
-							      &dummy);
-		lpm_priv->shadow.debug_bus_control = val;
-		break;
-	case pm_control:
-		if (use_start_stop_bookmark)
-			val |= (PS3_PM_CONTROL_PPU_TH0_BOOKMARK |
-				PS3_PM_CONTROL_PPU_TH1_BOOKMARK);
-		if (val != lpm_priv->shadow.pm_control)
-			result = lv1_set_lpm_general_control(lpm_priv->lpm_id,
-							     val,
-							     PS3_WRITE_PM_MASK,
-							     0, 0, &dummy,
-							     &dummy);
-		lpm_priv->shadow.pm_control = val;
-		break;
-	case pm_interval:
-		result = lv1_set_lpm_interval(lpm_priv->lpm_id, val,
-					      PS3_WRITE_PM_MASK, &dummy);
-		break;
-	case pm_start_stop:
-		if (val != lpm_priv->shadow.pm_start_stop)
-			result = lv1_set_lpm_trigger_control(lpm_priv->lpm_id,
-							     val,
-							     PS3_WRITE_PM_MASK,
-							     &dummy);
-		lpm_priv->shadow.pm_start_stop = val;
-		break;
-	case trace_address:
-	case ext_tr_timer:
-	case pm_status:
-		break;
-	default:
-		dev_dbg(sbd_core(), "%s:%u: unknown reg: %d\n", __func__,
-			__LINE__, reg);
-		BUG();
-		break;
-	}
+	ps3_set_bookmark(get_tb() | PS3_PM_BOOKMARK_STOP);
 
-	if (result)
-		dev_err(sbd_core(), "%s:%u: lv1 set_control failed: "
-			"reg %u, %s\n", __func__, __LINE__, reg,
-			ps3_result(result));
-}
-EXPORT_SYMBOL_GPL(ps3_write_pm);
+	result = lv1_stop_lpm(priv->lpm_id, &tmp);
+
+	if (result) {
+		if(result != LV1_WRONG_STATE)
+			dev_err(sbd(priv), "%s:%u: lv1_stop_lpm failed: %s\n",
+				__func__, __LINE__, ps3_result(result));
+		return;
+	}
+
+	priv->tb_count = tmp;
+
+	dev_dbg(sbd(priv), "%s:%u: tb_count %llu (%llxh)\n", __func__, __LINE__,
+		priv->tb_count, priv->tb_count);
+}
 
 /**
- * ps3_get_ctr_size - Get the size of a physical counter.
+ * ps3_get_and_clear_pm_interrupts -
  *
- * Returns either 16 or 32.
+ * Clearing interrupts for the entire performance monitoring unit.
+ * Reading pm_status clears the interrupt bits.
  */
 
-u32 ps3_get_ctr_size(u32 cpu, u32 phys_ctr)
+static u32 ps3_get_and_clear_pm_interrupts(void* p, u32 cpu)
 {
-	u32 pm_ctrl;
-
-	if (phys_ctr >= NR_PHYS_CTRS) {
-		dev_dbg(sbd_core(), "%s:%u: phys_ctr too big: %u\n", __func__,
-			__LINE__, phys_ctr);
-		return 0;
-	}
-
-	pm_ctrl = ps3_read_pm(cpu, pm_control);
-	return (pm_ctrl & CBE_PM_16BIT_CTR(phys_ctr)) ? 16 : 32;
+	return ps3_read_pm(p, cpu, pm_status);
 }
-EXPORT_SYMBOL_GPL(ps3_get_ctr_size);
 
 /**
- * ps3_set_ctr_size - Set the size of a physical counter to 16 or 32 bits.
+ * ps3_enable_pm_interrupts -
+ *
+ * Enabling interrupts for the entire performance monitoring unit.
+ * Enables the interrupt bits in the pm_status register.
  */
 
-void ps3_set_ctr_size(u32 cpu, u32 phys_ctr, u32 ctr_size)
+static void ps3_enable_pm_interrupts(void* p, u32 cpu, u32 thread,
+	u32 mask)
 {
-	u32 pm_ctrl;
-
-	if (phys_ctr >= NR_PHYS_CTRS) {
-		dev_dbg(sbd_core(), "%s:%u: phys_ctr too big: %u\n", __func__,
-			__LINE__, phys_ctr);
-		return;
-	}
-
-	pm_ctrl = ps3_read_pm(cpu, pm_control);
+	if (mask)
+		ps3_write_pm(p, cpu, pm_status, mask);
+}
 
-	switch (ctr_size) {
-	case 16:
-		pm_ctrl |= CBE_PM_16BIT_CTR(phys_ctr);
-		ps3_write_pm(cpu, pm_control, pm_ctrl);
-		break;
+/**
+ * ps3_enable_pm_interrupts -
+ *
+ * Disabling interrupts for the entire performance monitoring unit.
+ */
 
-	case 32:
-		pm_ctrl &= ~CBE_PM_16BIT_CTR(phys_ctr);
-		ps3_write_pm(cpu, pm_control, pm_ctrl);
-		break;
-	default:
-		BUG();
-	}
+static void ps3_disable_pm_interrupts(void* p, u32 cpu)
+{
+	ps3_get_and_clear_pm_interrupts(p, cpu);
+	ps3_write_pm(p, cpu, pm_status, 0);
 }
-EXPORT_SYMBOL_GPL(ps3_set_ctr_size);
 
 static u64 pm_translate_signal_group_number_on_island2(u64 subgroup)
 {
@@ -669,6 +779,22 @@
 	return PM_ISLAND8_BASE_SIGNAL_GROUP_NUMBER + subgroup;
 }
 
+/**
+ * lpm_priv - Static instance of the lpm data.
+ *
+ * Since some of the exported routines don't support the notion of a device
+ * instance we need to hold the instance in this static variable
+ * and then only allow at most one instance at a time to be created.
+ */
+
+static struct ps3_lpm_priv *lpm_priv;
+
+static struct device *sbd_core(void)
+{
+	BUG_ON(!lpm_priv || !lpm_priv->sbd);
+	return &lpm_priv->sbd->core;
+}
+
 static u64 pm_signal_group_to_ps3_lv1_signal_group(u64 group)
 {
 	u64 island;
@@ -733,8 +859,8 @@
 	case 8:
 		return pm_translate_signal_group_number_on_island8(subgroup);
 	default:
-		dev_dbg(sbd_core(), "%s:%u: island not found: %llu\n", __func__,
-			__LINE__, group);
+		dev_dbg(sbd_core(), "%s:%u: island not found: %llu\n",
+			__func__, __LINE__, group);
 		BUG();
 		break;
 	}
@@ -766,9 +892,9 @@
 				 signal_select, attr1, attr2, attr3);
 	if (ret)
 		dev_err(sbd_core(),
-			"%s:%u: error:%d 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx\n",
-			__func__, __LINE__, ret, lv1_signal_group, bus_select,
-			signal_select, attr1, attr2, attr3);
+			"%s:%u: error %s: 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx 0x%llx\n",
+			__func__, __LINE__, ps3_result(ret), lv1_signal_group,
+			bus_select, signal_select, attr1, attr2, attr3);
 
 	return ret;
 }
@@ -842,77 +968,117 @@
 EXPORT_SYMBOL_GPL(ps3_get_hw_thread_id);
 
 /**
- * ps3_enable_pm - Enable the entire performance monitoring unit.
- *
- * When we enable the LPM, all pending writes to counters get committed.
+ * ps3_lpm_open - Open the logical performance monitor device.
+ * @tb_type: Specifies the type of trace buffer lv1 sould use for this lpm
+ *  instance, specified by one of enum ps3_lpm_tb_type.
+ * @tb_cache: Optional user supplied buffer to use as the trace buffer cache.
+ *  If NULL, the driver will allocate and manage an internal buffer.
+ *  Unused when when @tb_type is PS3_LPM_TB_TYPE_NONE.
+ * @tb_cache_size: The size in bytes of the user supplied @tb_cache buffer.
+ *  Unused when @tb_cache is NULL or @tb_type is PS3_LPM_TB_TYPE_NONE.
  */
 
-void ps3_enable_pm(u32 cpu)
+int ps3_lpm_open(enum ps3_lpm_tb_type tb_type, void *tb_cache,
+	u64 tb_cache_size)
 {
 	int result;
-	u64 tmp;
-	int insert_bookmark = 0;
+	u64 tb_size;
 
-	lpm_priv->tb_count = 0;
+	BUG_ON(!lpm_priv);
+	BUG_ON(tb_type != PS3_LPM_TB_TYPE_NONE
+		&& tb_type != PS3_LPM_TB_TYPE_INTERNAL);
 
-	if (use_start_stop_bookmark) {
-		if (!(lpm_priv->shadow.pm_start_stop &
-			(PS3_PM_START_STOP_START_MASK
-			| PS3_PM_START_STOP_STOP_MASK))) {
-			result = lv1_set_lpm_trigger_control(lpm_priv->lpm_id,
-				(PS3_PM_START_STOP_PPU_TH0_BOOKMARK_START |
-				PS3_PM_START_STOP_PPU_TH1_BOOKMARK_START |
-				PS3_PM_START_STOP_PPU_TH0_BOOKMARK_STOP |
-				PS3_PM_START_STOP_PPU_TH1_BOOKMARK_STOP),
-				0xFFFFFFFFFFFFFFFFULL, &tmp);
+	if (tb_type == PS3_LPM_TB_TYPE_NONE && tb_cache)
+		dev_dbg(sbd_core(), "%s:%u: bad in vals\n", __func__, __LINE__);
 
-			if (result)
-				dev_err(sbd_core(), "%s:%u: "
-					"lv1_set_lpm_trigger_control failed: "
-					"%s\n", __func__, __LINE__,
-					ps3_result(result));
+	if (!atomic_add_unless(&lpm_priv->open, 1, 1)) {
+		dev_dbg(sbd_core(), "%s:%u: busy\n", __func__, __LINE__);
+		return -EBUSY;
+	}
 
-			insert_bookmark = !result;
+	/* Note tb_cache needs 128 byte alignment. */
+
+	if (tb_type == PS3_LPM_TB_TYPE_NONE) {
+		lpm_priv->tb_cache_size = 0;
+		lpm_priv->tb_cache_internal = NULL;
+		lpm_priv->tb_cache = NULL;
+	} else if (tb_cache) {
+		if (tb_cache != (void *)_ALIGN_UP((unsigned long)tb_cache, 128)
+			|| tb_cache_size != _ALIGN_UP(tb_cache_size, 128)) {
+			dev_err(sbd_core(), "%s:%u: unaligned tb_cache\n",
+				__func__, __LINE__);
+			result = -EINVAL;
+			goto fail_align;
 		}
+		lpm_priv->tb_cache_size = tb_cache_size;
+		lpm_priv->tb_cache_internal = NULL;
+		lpm_priv->tb_cache = tb_cache;
+	} else {
+		lpm_priv->tb_cache_size = PS3_LPM_DEFAULT_TB_CACHE_SIZE;
+		lpm_priv->tb_cache_internal = kzalloc(
+			lpm_priv->tb_cache_size + 127, GFP_KERNEL);
+		if (!lpm_priv->tb_cache_internal) {
+			dev_err(sbd_core(), "%s:%u: alloc internal tb_cache "
+				"failed\n", __func__, __LINE__);
+			result = -ENOMEM;
+			goto fail_malloc;
+		}
+		lpm_priv->tb_cache = (void *)_ALIGN_UP(
+			(unsigned long)lpm_priv->tb_cache_internal, 128);
 	}
 
-	result = lv1_start_lpm(lpm_priv->lpm_id);
+	result = lv1_construct_lpm(lpm_priv->node_id, tb_type, 0, 0,
+				ps3_mm_phys_to_lpar(__pa(lpm_priv->tb_cache)),
+				lpm_priv->tb_cache_size, &lpm_priv->lpm_id,
+				&lpm_priv->outlet_id, &tb_size);
 
-	if (result)
-		dev_err(sbd_core(), "%s:%u: lv1_start_lpm failed: %s\n",
+	if (result) {
+		dev_err(sbd_core(), "%s:%u: lv1_construct_lpm failed: %s\n",
 			__func__, __LINE__, ps3_result(result));
+		result = -EINVAL;
+		goto fail_construct;
+	}
 
-	if (use_start_stop_bookmark && !result && insert_bookmark)
-		ps3_set_bookmark(get_tb() | PS3_PM_BOOKMARK_START);
+	lpm_priv->shadow.pm_control = PS3_LPM_SHADOW_REG_INIT;
+	lpm_priv->shadow.pm_start_stop = PS3_LPM_SHADOW_REG_INIT;
+	lpm_priv->shadow.group_control = PS3_LPM_SHADOW_REG_INIT;
+	lpm_priv->shadow.debug_bus_control = PS3_LPM_SHADOW_REG_INIT;
+
+	dev_dbg(sbd_core(), "%s:%u: lpm_id 0x%llx, outlet_id 0x%llx, "
+		"tb_size 0x%llx\n", __func__, __LINE__, lpm_priv->lpm_id,
+		lpm_priv->outlet_id, tb_size);
+
+	return 0;
+
+fail_construct:
+	kfree(lpm_priv->tb_cache_internal);
+	lpm_priv->tb_cache_internal = NULL;
+fail_malloc:
+fail_align:
+	atomic_dec(&lpm_priv->open);
+	return result;
 }
-EXPORT_SYMBOL_GPL(ps3_enable_pm);
+EXPORT_SYMBOL_GPL(ps3_lpm_open);
 
 /**
- * ps3_disable_pm - Disable the entire performance monitoring unit.
+ * ps3_lpm_close - Close the lpm device.
+ *
  */
 
-void ps3_disable_pm(u32 cpu)
+int ps3_lpm_close(void)
 {
-	int result;
-	u64 tmp;
-
-	ps3_set_bookmark(get_tb() | PS3_PM_BOOKMARK_STOP);
-
-	result = lv1_stop_lpm(lpm_priv->lpm_id, &tmp);
+	dev_dbg(sbd_core(), "%s:%u\n", __func__, __LINE__);
 
-	if (result) {
-		if(result != LV1_WRONG_STATE)
-			dev_err(sbd_core(), "%s:%u: lv1_stop_lpm failed: %s\n",
-				__func__, __LINE__, ps3_result(result));
-		return;
-	}
+	lv1_destruct_lpm(lpm_priv->lpm_id);
+	lpm_priv->lpm_id = 0;
 
-	lpm_priv->tb_count = tmp;
+	kfree(lpm_priv->tb_cache_internal);
+	lpm_priv->tb_cache_internal = NULL;
 
-	dev_dbg(sbd_core(), "%s:%u: tb_count %llu (%llxh)\n", __func__, __LINE__,
-		lpm_priv->tb_count, lpm_priv->tb_count);
+	atomic_dec(&lpm_priv->open);
+	return 0;
 }
-EXPORT_SYMBOL_GPL(ps3_disable_pm);
+EXPORT_SYMBOL_GPL(ps3_lpm_close);
 
 /**
  * ps3_lpm_copy_tb - Copy data from the trace buffer to a kernel buffer.
@@ -1032,178 +1198,52 @@
 }
 EXPORT_SYMBOL_GPL(ps3_lpm_copy_tb_to_user);
 
-/**
- * ps3_get_and_clear_pm_interrupts -
- *
- * Clearing interrupts for the entire performance monitoring unit.
- * Reading pm_status clears the interrupt bits.
- */
-
-u32 ps3_get_and_clear_pm_interrupts(u32 cpu)
-{
-	return ps3_read_pm(cpu, pm_status);
-}
-EXPORT_SYMBOL_GPL(ps3_get_and_clear_pm_interrupts);
-
-/**
- * ps3_enable_pm_interrupts -
- *
- * Enabling interrupts for the entire performance monitoring unit.
- * Enables the interrupt bits in the pm_status register.
- */
-
-void ps3_enable_pm_interrupts(u32 cpu, u32 thread, u32 mask)
-{
-	if (mask)
-		ps3_write_pm(cpu, pm_status, mask);
-}
-EXPORT_SYMBOL_GPL(ps3_enable_pm_interrupts);
-
-/**
- * ps3_enable_pm_interrupts -
- *
- * Disabling interrupts for the entire performance monitoring unit.
- */
-
-void ps3_disable_pm_interrupts(u32 cpu)
-{
-	ps3_get_and_clear_pm_interrupts(cpu);
-	ps3_write_pm(cpu, pm_status, 0);
-}
-EXPORT_SYMBOL_GPL(ps3_disable_pm_interrupts);
-
-/**
- * ps3_lpm_open - Open the logical performance monitor device.
- * @tb_type: Specifies the type of trace buffer lv1 sould use for this lpm
- *  instance, specified by one of enum ps3_lpm_tb_type.
- * @tb_cache: Optional user supplied buffer to use as the trace buffer cache.
- *  If NULL, the driver will allocate and manage an internal buffer.
- *  Unused when when @tb_type is PS3_LPM_TB_TYPE_NONE.
- * @tb_cache_size: The size in bytes of the user supplied @tb_cache buffer.
- *  Unused when @tb_cache is NULL or @tb_type is PS3_LPM_TB_TYPE_NONE.
- */
-
-int ps3_lpm_open(enum ps3_lpm_tb_type tb_type, void *tb_cache,
-	u64 tb_cache_size)
-{
-	int result;
-	u64 tb_size;
-
-	BUG_ON(!lpm_priv);
-	BUG_ON(tb_type != PS3_LPM_TB_TYPE_NONE
-		&& tb_type != PS3_LPM_TB_TYPE_INTERNAL);
-
-	if (tb_type == PS3_LPM_TB_TYPE_NONE && tb_cache)
-		dev_dbg(sbd_core(), "%s:%u: bad in vals\n", __func__, __LINE__);
-
-	if (!atomic_add_unless(&lpm_priv->open, 1, 1)) {
-		dev_dbg(sbd_core(), "%s:%u: busy\n", __func__, __LINE__);
-		return -EBUSY;
-	}
-
-	/* Note tb_cache needs 128 byte alignment. */
-
-	if (tb_type == PS3_LPM_TB_TYPE_NONE) {
-		lpm_priv->tb_cache_size = 0;
-		lpm_priv->tb_cache_internal = NULL;
-		lpm_priv->tb_cache = NULL;
-	} else if (tb_cache) {
-		if (tb_cache != (void *)_ALIGN_UP((unsigned long)tb_cache, 128)
-			|| tb_cache_size != _ALIGN_UP(tb_cache_size, 128)) {
-			dev_err(sbd_core(), "%s:%u: unaligned tb_cache\n",
-				__func__, __LINE__);
-			result = -EINVAL;
-			goto fail_align;
-		}
-		lpm_priv->tb_cache_size = tb_cache_size;
-		lpm_priv->tb_cache_internal = NULL;
-		lpm_priv->tb_cache = tb_cache;
-	} else {
-		lpm_priv->tb_cache_size = PS3_LPM_DEFAULT_TB_CACHE_SIZE;
-		lpm_priv->tb_cache_internal = kzalloc(
-			lpm_priv->tb_cache_size + 127, GFP_KERNEL);
-		if (!lpm_priv->tb_cache_internal) {
-			dev_err(sbd_core(), "%s:%u: alloc internal tb_cache "
-				"failed\n", __func__, __LINE__);
-			result = -ENOMEM;
-			goto fail_malloc;
-		}
-		lpm_priv->tb_cache = (void *)_ALIGN_UP(
-			(unsigned long)lpm_priv->tb_cache_internal, 128);
-	}
-
-	result = lv1_construct_lpm(lpm_priv->node_id, tb_type, 0, 0,
-				ps3_mm_phys_to_lpar(__pa(lpm_priv->tb_cache)),
-				lpm_priv->tb_cache_size, &lpm_priv->lpm_id,
-				&lpm_priv->outlet_id, &tb_size);
-
-	if (result) {
-		dev_err(sbd_core(), "%s:%u: lv1_construct_lpm failed: %s\n",
-			__func__, __LINE__, ps3_result(result));
-		result = -EINVAL;
-		goto fail_construct;
-	}
-
-	lpm_priv->shadow.pm_control = PS3_LPM_SHADOW_REG_INIT;
-	lpm_priv->shadow.pm_start_stop = PS3_LPM_SHADOW_REG_INIT;
-	lpm_priv->shadow.group_control = PS3_LPM_SHADOW_REG_INIT;
-	lpm_priv->shadow.debug_bus_control = PS3_LPM_SHADOW_REG_INIT;
-
-	dev_dbg(sbd_core(), "%s:%u: lpm_id 0x%llx, outlet_id 0x%llx, "
-		"tb_size 0x%llx\n", __func__, __LINE__, lpm_priv->lpm_id,
-		lpm_priv->outlet_id, tb_size);
-
-	return 0;
-
-fail_construct:
-	kfree(lpm_priv->tb_cache_internal);
-	lpm_priv->tb_cache_internal = NULL;
-fail_malloc:
-fail_align:
-	atomic_dec(&lpm_priv->open);
-	return result;
-}
-EXPORT_SYMBOL_GPL(ps3_lpm_open);
-
-/**
- * ps3_lpm_close - Close the lpm device.
- *
- */
-
-int ps3_lpm_close(void)
-{
-	dev_dbg(sbd_core(), "%s:%u\n", __func__, __LINE__);
-
-	lv1_destruct_lpm(lpm_priv->lpm_id);
-	lpm_priv->lpm_id = 0;
-
-	kfree(lpm_priv->tb_cache_internal);
-	lpm_priv->tb_cache_internal = NULL;
-
-	atomic_dec(&lpm_priv->open);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ps3_lpm_close);
+static struct cell_pmu_ops cell_pmu_ops_ps3 = {
+	.read_phys_ctr               = ps3_read_phys_ctr,
+	.write_phys_ctr              = ps3_write_phys_ctr,
+	.read_ctr                    = ps3_read_ctr,
+	.write_ctr	             = ps3_write_ctr,
+	.read_pm07_control           = ps3_read_pm07_control,
+	.write_pm07_control          = ps3_write_pm07_control,
+	.read_pm                     = ps3_read_pm,
+	.write_pm                    = ps3_write_pm,
+	.get_ctr_size                = ps3_get_ctr_size,
+	.set_ctr_size                = ps3_set_ctr_size,
+	.enable_pm                   = ps3_enable_pm,
+	.disable_pm                  = ps3_disable_pm,
+//	.read_trace_buffer           = ps3_read_trace_buffer, ...todo
+	.get_and_clear_pm_interrupts = ps3_get_and_clear_pm_interrupts,
+	.enable_pm_interrupts        = ps3_enable_pm_interrupts,
+	.disable_pm_interrupts       = ps3_disable_pm_interrupts,
+//	.sync_irq                    = ps3_sync_irq, ...this seems generic
+};
 
 static int __devinit ps3_lpm_probe(struct ps3_system_bus_device *dev)
 {
+	struct ps3_lpm_priv *priv;
+
 	dev_dbg(&dev->core, " -> %s:%u\n", __func__, __LINE__);
 
-	if (lpm_priv) {
+	if (cell_pmu_ops_ps3.priv) {
 		dev_info(&dev->core, "%s:%u: called twice\n",
 			__func__, __LINE__);
 		return -EBUSY;
 	}
 
-	lpm_priv = kzalloc(sizeof(*lpm_priv), GFP_KERNEL);
+	priv = kzalloc(sizeof(struct ps3_lpm_priv), GFP_KERNEL);
 
-	if (!lpm_priv)
+	if (!priv)
 		return -ENOMEM;
 
-	lpm_priv->sbd = dev;
-	lpm_priv->node_id = dev->lpm.node_id;
-	lpm_priv->pu_id = dev->lpm.pu_id;
-	lpm_priv->rights = dev->lpm.rights;
+	priv->sbd = dev;
+	priv->node_id = dev->lpm.node_id;
+	priv->pu_id = dev->lpm.pu_id;
+	priv->rights = dev->lpm.rights;
+
+	cell_pmu_ops_ps3.priv = priv;
+	cell_pmu_ops_init(&cell_pmu_ops_ps3);
+
+	lpm_priv = priv;
 
 	dev_info(&dev->core, " <- %s:%u:\n", __func__, __LINE__);
 
diff -Nur linux-2.6.36-rc7/drivers/ps3/ps3stor_lib.c ps3-linux/drivers/ps3/ps3stor_lib.c
--- linux-2.6.36-rc7/drivers/ps3/ps3stor_lib.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/drivers/ps3/ps3stor_lib.c	2010-12-04 16:17:48.189846622 +0600
@@ -18,6 +18,8 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
+#define DEBUG
+
 #include <linux/dma-mapping.h>
 
 #include <asm/lv1call.h>
diff -Nur linux-2.6.36-rc7/drivers/ps3/ps3-sys-manager.c ps3-linux/drivers/ps3/ps3-sys-manager.c
--- linux-2.6.36-rc7/drivers/ps3/ps3-sys-manager.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/drivers/ps3/ps3-sys-manager.c	2010-12-04 16:17:48.169341426 +0600
@@ -18,6 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#define DEBUG
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/workqueue.h>
diff -Nur linux-2.6.36-rc7/drivers/usb/host/ehci.h ps3-linux/drivers/usb/host/ehci.h
--- linux-2.6.36-rc7/drivers/usb/host/ehci.h	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/drivers/usb/host/ehci.h	2010-12-04 16:17:48.859342872 +0600
@@ -132,7 +132,10 @@
 	unsigned		broken_periodic:1;
 	unsigned		fs_i_thresh:1;	/* Intel iso scheduling */
 
-	/* required for usb32 quirk */
+	/* perform post CMD_RESET and CMD_LRESET work-arounds */
+	void	(*post_reset) (struct ehci_hcd *ehci);
+
+/* required for usb32 quirk */
 	#define OHCI_CTRL_HCFS          (3 << 6)
 	#define OHCI_USB_OPER           (2 << 6)
 	#define OHCI_USB_SUSPEND        (3 << 6)
diff -Nur linux-2.6.36-rc7/drivers/usb/host/ehci-hcd.c ps3-linux/drivers/usb/host/ehci-hcd.c
--- linux-2.6.36-rc7/drivers/usb/host/ehci-hcd.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/drivers/usb/host/ehci-hcd.c	2010-12-04 16:17:48.859342872 +0600
@@ -218,7 +218,7 @@
 	int error;
 
 	error = handshake(ehci, ptr, mask, done, usec);
-	if (error) {
+	if (WARN_ON(error)) {
 		ehci_halt(ehci);
 		ehci_to_hcd(ehci)->state = HC_STATE_HALT;
 		ehci_err(ehci, "force halt; handshake %p %08x %08x -> %d\n",
@@ -265,6 +265,9 @@
 	retval = handshake (ehci, &ehci->regs->command,
 			    CMD_RESET, 0, 250 * 1000);
 
+	if (ehci->post_reset)
+		ehci->post_reset(ehci);
+
 	if (ehci->has_hostpc) {
 		ehci_writel(ehci, USBMODE_EX_HC | USBMODE_EX_VBPS,
 			(u32 __iomem *)(((u8 *)ehci->regs) + USBMODE_EX));
@@ -581,6 +584,8 @@
 	hw = ehci->async->hw;
 	hw->hw_next = QH_NEXT(ehci, ehci->async->qh_dma);
 	hw->hw_info1 = cpu_to_hc32(ehci, QH_HEAD);
+	hw->hw_info1 |= cpu_to_hc32(ehci, (2 << 28));	/* RL = 2 */
+	hw->hw_info1 |= cpu_to_hc32(ehci, (1 << 7));	/* I = 1 */
 	hw->hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);
 	hw->hw_qtd_next = EHCI_LIST_END(ehci);
 	ehci->async->qh_state = QH_STATE_LINKED;
@@ -607,6 +612,7 @@
 			park = min(park, (unsigned) 3);
 			temp |= CMD_PARK;
 			temp |= park << 8;
+			BUG_ON("PS3 Errata 226: ehci park");
 		}
 		ehci_dbg(ehci, "park %d\n", park);
 	}
@@ -688,6 +694,9 @@
 	ehci_writel(ehci, ehci->command, &ehci->regs->command);
 	dbg_cmd (ehci, "init", ehci->command);
 
+	if (ehci->post_reset)
+		ehci->post_reset(ehci);
+
 	/*
 	 * Start, enabling full USB 2.0 functionality ... usb 1.1 devices
 	 * are explicitly handed to companion controller(s), so no TT is
diff -Nur linux-2.6.36-rc7/drivers/usb/host/ehci-hub.c ps3-linux/drivers/usb/host/ehci-hub.c
--- linux-2.6.36-rc7/drivers/usb/host/ehci-hub.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/drivers/usb/host/ehci-hub.c	2010-12-04 16:17:48.859342872 +0600
@@ -415,8 +415,13 @@
 	temp = 0;
 	if (ehci->async->qh_next.qh)
 		temp |= CMD_ASE;
-	if (ehci->periodic_sched)
+	if (ehci->periodic_sched) {
 		temp |= CMD_PSE;
+		if (temp & CMD_RUN && !(temp & CMD_ASE)) {
+			dbg_cmd(ehci, __func__, temp);
+			WARN_ON("PS3 Errata 253");
+		}
+	}
 	if (temp) {
 		ehci->command |= temp;
 		ehci_writel(ehci, ehci->command, &ehci->regs->command);
diff -Nur linux-2.6.36-rc7/drivers/usb/host/ehci-ps3.c ps3-linux/drivers/usb/host/ehci-ps3.c
--- linux-2.6.36-rc7/drivers/usb/host/ehci-ps3.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/drivers/usb/host/ehci-ps3.c	2010-12-04 16:17:48.859342872 +0600
@@ -21,6 +21,58 @@
 #include <asm/firmware.h>
 #include <asm/ps3.h>
 
+/**
+ * enum ps3_ehci_hc_insnreg - PS3 HC internal setup register offsets.
+ *
+ * Offsets in bytes from the EHCI operational regs (ehci->regs).
+ **/
+
+enum ps3_ehci_hc_insnreg {
+	ps3_ehci_hc_insnreg01 = 0x084,
+	ps3_ehci_hc_insnreg02 = 0x088,
+	ps3_ehci_hc_insnreg03 = 0x08c,
+};
+
+#define ps3_dump_insnreg(_h) _ps3_dump_insnreg(_h, __func__, __LINE__)
+static void _ps3_dump_insnreg(struct ehci_hcd *ehci, const char *func,
+	int line)
+{
+	unsigned int v1;
+	unsigned int v2;
+	unsigned int v3;
+
+	v1 = readl_be((void __iomem *)ehci->regs + ps3_ehci_hc_insnreg01);
+	v2 = readl_be((void __iomem *)ehci->regs + ps3_ehci_hc_insnreg02);
+	v3 = readl_be((void __iomem *)ehci->regs + ps3_ehci_hc_insnreg03);
+
+	ehci_info(ehci, "%s:%d: insnreg: {%8.8xh, %8.8xh, %8.8xh}\n", func,
+		line, v1, v2, v3);
+}
+
+static void ps3_ehci_post_reset(struct ehci_hcd *ehci)
+{
+	/* PS3 EHCI HC errata fix 316 - The PS3 EHCI HC will reset its
+	 * internal INSNREGXX setup regs back to the chip default values
+	 * on Host Controller Reset (CMD_RESET) or Light Host Controller
+	 * Reset (CMD_LRESET).  The work-around for this is for the HC
+	 * driver to re-initialise these regs when ever the HC is reset.
+	 */
+
+	ps3_dump_insnreg(ehci);
+
+	/* Set burst transfer counts to 256 out, 32 in. */
+
+	writel_be(0x01000020, (void __iomem *)ehci->regs +
+		ps3_ehci_hc_insnreg01);
+
+	/* Enable burst transfer counts. */
+
+	writel_be(0x00000001, (void __iomem *)ehci->regs +
+		ps3_ehci_hc_insnreg03);
+
+	ps3_dump_insnreg(ehci);
+}
+
 static int ps3_ehci_hc_reset(struct usb_hcd *hcd)
 {
 	int result;
@@ -32,6 +84,8 @@
 	ehci->regs = hcd->regs + HC_LENGTH(ehci_readl(ehci,
 		&ehci->caps->hc_capbase));
 
+	ehci->post_reset = ps3_ehci_post_reset;
+
 	dbg_hcs_params(ehci, "reset");
 	dbg_hcc_params(ehci, "reset");
 
@@ -52,6 +106,57 @@
 	return result;
 }
 
+static int __maybe_unused ps3_ehci_bus_suspend(struct usb_hcd *hcd)
+{
+	int result = 0;
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	ehci_dbg(ehci, "%s:%d\n", __func__, __LINE__);
+
+	/*
+	 * The PS3 EHCI HC stops the root hub after both root hub ports are
+	 * suspended.  The EHCI root hub driver expects the root hub to still
+	 * be running when ehci_bus_suspend() is called.  Forcing the HC into
+	 * the HALT state here will allow a successful suspend.
+	 */
+
+	ehci_halt(ehci);
+	ehci_to_hcd(ehci)->state = HC_STATE_SUSPENDED;
+
+#if defined(CONFIG_PM)
+	result = ehci_bus_suspend(hcd);
+#endif
+	WARN_ON(result);
+
+	return result;
+}
+
+static int __maybe_unused ps3_ehci_bus_resume(struct usb_hcd *hcd)
+{
+	int result;
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	ehci_dbg(ehci, "%s:%d\n", __func__, __LINE__);
+
+	/*
+	 * Putting the HC into the RUN state here will get the root hub
+	 * running and allow a successful resume.
+	 */
+
+	ehci->command |= CMD_RUN;
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
+
+	result = handshake(ehci, &ehci->regs->status, STS_HALT, 0, 250 * 1000);
+	WARN_ON(result);
+
+#if defined(CONFIG_PM)
+	result = ehci_bus_resume(hcd);
+#endif
+	WARN_ON(result);
+
+	return result;
+}
+
 static const struct hc_driver ps3_ehci_hc_driver = {
 	.description		= hcd_name,
 	.product_desc		= "PS3 EHCI Host Controller",
@@ -70,8 +175,8 @@
 	.hub_status_data	= ehci_hub_status_data,
 	.hub_control		= ehci_hub_control,
 #if defined(CONFIG_PM)
-	.bus_suspend		= ehci_bus_suspend,
-	.bus_resume		= ehci_bus_resume,
+	.bus_suspend		= ps3_ehci_bus_suspend,
+	.bus_resume		= ps3_ehci_bus_resume,
 #endif
 	.relinquish_port	= ehci_relinquish_port,
 	.port_handed_over	= ehci_port_handed_over,
@@ -207,6 +312,14 @@
 
 	tmp = hcd->irq;
 
+	/*
+	 * Putting the HC into the RUN state here will get the root hub
+	 * running and allow a successful usb_remove_hcd().
+	 */
+
+#if defined(CONFIG_PM)
+	ps3_ehci_bus_resume(hcd);
+#endif
 	ehci_shutdown(hcd);
 	usb_remove_hcd(hcd);
 
diff -Nur linux-2.6.36-rc7/drivers/usb/host/ehci-q.c ps3-linux/drivers/usb/host/ehci-q.c
--- linux-2.6.36-rc7/drivers/usb/host/ehci-q.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/drivers/usb/host/ehci-q.c	2010-12-04 16:17:48.859342872 +0600
@@ -18,6 +18,58 @@
 
 /* this file is part of ehci-hcd.c */
 
+static unsigned int qh_mult(u32 cpu_info2)
+{
+	return (unsigned int)((cpu_info2 >> 30) & 3);
+}
+
+static unsigned int qh_to_mult(struct ehci_hcd *ehci,
+	const struct ehci_qh_hw *qh)
+{
+	u32 cpu_info2 = hc32_to_cpup(ehci, &qh->hw_info2);
+
+	return qh_mult(cpu_info2);
+}
+
+static unsigned int qh_mpl(u32 cpu_info1)
+{
+	return (unsigned int)((cpu_info1 >> 16) & 0x7ff);
+}
+
+static unsigned int qh_to_mpl(struct ehci_hcd *ehci,
+	const struct ehci_qh_hw *qh)
+{
+	u32 cpu_info1 = hc32_to_cpup(ehci, &qh->hw_info1);
+
+	return qh_mpl(cpu_info1);
+}
+
+static unsigned int qtd_offset(u32 cpu_buf_0)
+{
+	return (unsigned int)(cpu_buf_0 & 0xfff);
+}
+
+static unsigned int qtd_to_offset(struct ehci_hcd *ehci,
+	const struct ehci_qtd *qtd)
+{
+	u32 cpu_buf_0 = hc32_to_cpup(ehci, &qtd->hw_buf[0]);
+
+	return qtd_offset(cpu_buf_0);
+}
+
+static unsigned int qh_rl(u32 cpu_info1)
+{
+	return (unsigned int)((cpu_info1 >> 28) & 0xf);
+}
+
+static unsigned int qh_to_rl(struct ehci_hcd *ehci,
+	const struct ehci_qh_hw *qh)
+{
+	u32 cpu_info1 = hc32_to_cpup(ehci, &qh->hw_info1);
+
+	return qh_rl(cpu_info1);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -51,6 +103,30 @@
 
 	/* one buffer entry per 4K ... first might be short or unaligned */
 	qtd->hw_buf[0] = cpu_to_hc32(ehci, (u32)addr);
+
+	if (qtd->urb->dev->speed == USB_SPEED_HIGH
+		&& qtd_to_offset(ehci, qtd)) {
+		if (qtd_to_offset(ehci, qtd) + len > 4096) {
+			ehci_warn(ehci,
+				"%s:%d: offset: %4.4xh (%d), len: %4.4xh (%d), end: %4.4xh (%d) **\n",
+				__func__, __LINE__,
+				qtd_to_offset(ehci, qtd), qtd_to_offset(ehci, qtd),
+				(unsigned int)len, (unsigned int)len,
+				qtd_to_offset(ehci, qtd) + (unsigned int)len,
+				qtd_to_offset(ehci, qtd) + (unsigned int)len);
+			//dump_stack();
+			BUG_ON("PS3 Errata 295");
+		} else if (0) {
+			ehci_warn(ehci,
+				"%s:%d: offset: %4.4xh (%d), len: %4.4xh (%d), end: %4.4xh (%d)\n",
+				__func__, __LINE__,
+				qtd_to_offset(ehci, qtd), qtd_to_offset(ehci, qtd),
+				(unsigned int)len, (unsigned int)len,
+				qtd_to_offset(ehci, qtd) + (unsigned int)len,
+				qtd_to_offset(ehci, qtd) + (unsigned int)len);
+		}
+	}
+
 	qtd->hw_buf_hi[0] = cpu_to_hc32(ehci, (u32)(addr >> 32));
 	count = 0x1000 - (buf & 0x0fff);	/* rest of that page */
 	if (likely (len < count))		/* ... iff needed */
@@ -923,12 +999,15 @@
 
 	case USB_SPEED_HIGH:		/* no TT involved */
 		info1 |= (2 << 12);	/* EPS "high" */
+		info1 |= (2 << 28);	/* RL = 2 */
 		if (type == PIPE_CONTROL) {
+			ehci_info(ehci, "%s:%d: PIPE_CONTROL\n", __func__, __LINE__);
 			info1 |= (EHCI_TUNE_RL_HS << 28);
 			info1 |= 64 << 16;	/* usb2 fixed maxpacket */
 			info1 |= 1 << 14;	/* toggle from qtd */
 			info2 |= (EHCI_TUNE_MULT_HS << 30);
 		} else if (type == PIPE_BULK) {
+			ehci_info(ehci, "%s:%d: PIPE_BULK\n", __func__, __LINE__);
 			info1 |= (EHCI_TUNE_RL_HS << 28);
 			/* The USB spec says that high speed bulk endpoints
 			 * always use 512 byte maxpacket.  But some device
@@ -939,9 +1018,34 @@
 			info1 |= max_packet(maxp) << 16;
 			info2 |= (EHCI_TUNE_MULT_HS << 30);
 		} else {		/* PIPE_INTERRUPT */
+			ehci_info(ehci, "%s:%d: PIPE_INTERRUPT\n", __func__, __LINE__);
 			info1 |= max_packet (maxp) << 16;
 			info2 |= hb_mult (maxp) << 30;
 		}
+		if (qh_mult(info2) > 2) {
+			ehci_info(ehci,
+				"%s:%d: qh_mult: %8.8xh -> %d *\n",
+				__func__, __LINE__, (unsigned int)info2,
+				qh_mult(info2));
+			BUG_ON("PS3 Errata 226");
+		}
+		if (!is_power_of_2(qh_mpl(info1)))
+			ehci_warn(ehci,
+				"%s:%d: max packet: %8.8xh -> %4.4xh (%d) *align\n",
+				__func__, __LINE__, (unsigned int)info1,
+				qh_mpl(info1), qh_mpl(info1));
+		if (qh_mpl(info1) > 0xc00)
+			ehci_info(ehci,
+				"%s:%d: max packet: %8.8xh -> %4.4xh (%d) *long\n",
+				__func__, __LINE__, (unsigned int)info1,
+				qh_mpl(info1), qh_mpl(info1));
+		if (qh_rl(info1) == 0) {
+			ehci_info(ehci,
+				"%s:%d: qh_rl: %8.8xh -> %d *\n",
+				__func__, __LINE__, (unsigned int)info1,
+				qh_rl(info1));
+			BUG_ON("PS3 Errata 236");
+		}
 		break;
 	default:
 		dbg ("bogus dev %p speed %d", urb->dev, urb->dev->speed);
@@ -1095,6 +1199,32 @@
 			urb->hcpriv = qh_get (qh);
 		}
 	}
+	if (urb->dev->speed == USB_SPEED_HIGH) {
+		if(qh_to_mult(ehci, qh->hw) > 2) {
+			ehci_info(ehci, "%s:%d: %8.8xh: %4.4xh (%d) **\n",
+				__func__, __LINE__,
+				(unsigned int)qh->hw->hw_info1,
+				qh_to_mult(ehci, qh->hw),
+				qh_to_mult(ehci, qh->hw));
+			BUG_ON("PS3 Errata 226");
+		}
+		if (!is_power_of_2(qh_to_mpl(ehci, qh->hw))) {
+			ehci_info(ehci, "%s:%d: %8.8xh: %4.4xh (%d) **\n",
+				__func__, __LINE__,
+				(unsigned int)qh->hw->hw_info1,
+				qh_to_mpl(ehci, qh->hw),
+				qh_to_mpl(ehci, qh->hw));
+			BUG_ON("PS3 Errata 295");
+		}
+		if (qh_to_rl(ehci, qh->hw) == 0) {
+			ehci_info(ehci,
+				"%s:%d: qh_rl: %8.8xh -> %d *\n",
+				__func__, __LINE__,
+				(unsigned int)qh->hw->hw_info1,
+				qh_to_rl(ehci, qh->hw));
+			BUG_ON("PS3 Errata 226");
+		}
+	}
 	return qh;
 }
 
@@ -1218,6 +1348,10 @@
 		if (ehci_to_hcd(ehci)->state != HC_STATE_HALT
 				&& !ehci->reclaim) {
 			/* ... and CMD_IAAD clear */
+			if (cmd & CMD_RUN && cmd & CMD_PSE) {
+				/* this doesn't hit the HC bug */
+				dbg_cmd(ehci, __func__, cmd);
+			}
 			ehci_writel(ehci, cmd & ~CMD_ASE,
 				    &ehci->regs->command);
 			wmb ();
diff -Nur linux-2.6.36-rc7/drivers/usb/host/ehci-sched.c ps3-linux/drivers/usb/host/ehci-sched.c
--- linux-2.6.36-rc7/drivers/usb/host/ehci-sched.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/drivers/usb/host/ehci-sched.c	2010-12-04 16:17:48.859342872 +0600
@@ -21,6 +21,32 @@
 
 /*-------------------------------------------------------------------------*/
 
+static unsigned int sitd_offset(u32 cpu_buf_0)
+{
+	return (unsigned int)(cpu_buf_0 & 0xfff);
+}
+
+static unsigned int sitd_to_offset(struct ehci_hcd *ehci,
+	const struct ehci_sitd *sitd)
+{
+	u32 cpu_buf_0 = hc32_to_cpup(ehci, &sitd->hw_buf[0]);
+
+	return sitd_offset(cpu_buf_0);
+}
+
+static unsigned int itd_offset(u32 cpu_trans)
+{
+	return (unsigned int)(cpu_trans & 0x7ff);
+}
+
+static unsigned int itd_to_offset(struct ehci_hcd *ehci,
+	const struct ehci_itd *itd, unsigned int slot)
+{
+	u32 cpu_trans = hc32_to_cpup(ehci, &itd->hw_transaction[slot]);
+
+	return sitd_offset(cpu_trans);
+}
+
 /*
  * EHCI scheduled transaction support:  interrupt, iso, split iso
  * These are called "periodic" transactions in the EHCI spec.
@@ -468,6 +494,10 @@
 		return status;
 
 	cmd = ehci_readl(ehci, &ehci->regs->command) | CMD_PSE;
+	if (cmd & CMD_RUN && !(cmd & CMD_ASE)) {
+		dbg_cmd(ehci, __func__, cmd);
+		WARN_ON("PS3 Errata 253");
+	}
 	ehci_writel(ehci, cmd, &ehci->regs->command);
 	/* posted write ... PSS happens later */
 	ehci_to_hcd(ehci)->state = HC_STATE_RUNNING;
@@ -1544,6 +1574,16 @@
 
 	itd->hw_transaction[uframe] = uf->transaction;
 	itd->hw_transaction[uframe] |= cpu_to_hc32(ehci, pg << 12);
+
+	if (itd_to_offset(ehci, itd, uframe) > 0x400) {
+		ehci_warn(ehci,
+			"%s:%d: itd_offset: %4.4xh (%d) **\n",
+			__func__, __LINE__,
+			itd_to_offset(ehci, itd, uframe),
+			itd_to_offset(ehci, itd, uframe));
+		BUG_ON("PS3 Errata 295");
+	}
+
 	itd->hw_bufp[pg] |= cpu_to_hc32(ehci, uf->bufp & ~(u32)0);
 	itd->hw_bufp_hi[pg] |= cpu_to_hc32(ehci, (u32)(uf->bufp >> 32));
 
@@ -1554,6 +1594,7 @@
 		itd->pg = ++pg;
 		itd->hw_bufp[pg] |= cpu_to_hc32(ehci, bufp & ~(u32)0);
 		itd->hw_bufp_hi[pg] |= cpu_to_hc32(ehci, (u32)(bufp >> 32));
+		BUG_ON("PS3 Errata 295: itd cross");
 	}
 }
 
@@ -1970,11 +2011,27 @@
 
 	bufp = uf->bufp;
 	sitd->hw_buf[0] = cpu_to_hc32(ehci, bufp);
+
+	if (sitd_offset(bufp) > 0xC00) {
+		ehci_warn(ehci,
+			"%s:%d: sitd_offset: %8.8xh: %4.4xh (%d) **\n",
+			__func__, __LINE__,
+			(unsigned int)bufp,
+			sitd_offset(bufp), sitd_offset(bufp));
+		BUG_ON("PS3 Errata 295");
+	}
 	sitd->hw_buf_hi[0] = cpu_to_hc32(ehci, bufp >> 32);
 
 	sitd->hw_buf[1] = cpu_to_hc32(ehci, uf->buf1);
-	if (uf->cross)
+	if (uf->cross) {
+		ehci_warn(ehci,
+			"%s:%d: sitd_offset: %8.8xh: %4.4xh (%d) **\n",
+			__func__, __LINE__,
+			(unsigned int)bufp,
+			sitd_offset(bufp), sitd_offset(bufp));
+		BUG_ON("PS3 Errata 295: sitd uf->cross");
 		bufp += 4096;
+	}
 	sitd->hw_buf_hi[1] = cpu_to_hc32(ehci, bufp >> 32);
 	sitd->index = index;
 }
diff -Nur linux-2.6.36-rc7/kernel/irq/manage.c ps3-linux/kernel/irq/manage.c
--- linux-2.6.36-rc7/kernel/irq/manage.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/kernel/irq/manage.c	2010-12-04 16:17:49.609965188 +0600
@@ -15,6 +15,10 @@
 #include <linux/slab.h>
 #include <linux/sched.h>
 
+#ifdef CONFIG_PPC_PS3
+#include <asm/firmware.h>
+#endif
+
 #include "internals.h"
 
 /**
@@ -904,6 +908,16 @@
 
 		if (action->dev_id == dev_id)
 			break;
+
+#ifdef CONFIG_PPC_PS3
+		if (firmware_has_feature(FW_FEATURE_PS3_LV1)) {
+			pr_debug("%s:%d: irq %u bad dev_id: request_irq(%p) != "
+				"free_irq(%p)\n" , __func__, __LINE__, irq,
+				action->dev_id, dev_id);
+			BUG();
+		}
+#endif
+
 		action_ptr = &action->next;
 	}
 
diff -Nur linux-2.6.36-rc7/pmake.sh ps3-linux/pmake.sh
--- linux-2.6.36-rc7/pmake.sh	1970-01-01 07:00:00.000000000 +0700
+++ ps3-linux/pmake.sh	2010-12-04 16:17:49.859342298 +0600
@@ -0,0 +1,3 @@
+#!/bin/bash
+make INSTALL_MOD_PATH=/home/marcansoft/sony/ps3/nfsroot/ ARCH=powerpc CROSS_COMPILE="$PS3DEV/bin/powerpc64-linux-" "$@"
+[[ -e vmlinux ]] && powerpc64-unknown-linux-gnu-objcopy -S vmlinux vmlinux.stripped
diff -Nur linux-2.6.36-rc7/ps3linux_config ps3-linux/ps3linux_config
--- linux-2.6.36-rc7/ps3linux_config	1970-01-01 07:00:00.000000000 +0700
+++ ps3-linux/ps3linux_config	2010-12-04 16:17:49.859342298 +0600
@@ -0,0 +1,1420 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.36-rc7
+# Sat Oct 30 03:27:46 2010
+#
+CONFIG_PPC64=y
+
+#
+# Processor support
+#
+CONFIG_PPC_BOOK3S_64=y
+# CONFIG_PPC_BOOK3E_64 is not set
+CONFIG_PPC_BOOK3S=y
+CONFIG_POWER4_ONLY=y
+CONFIG_POWER4=y
+CONFIG_TUNE_CELL=y
+CONFIG_PPC_FPU=y
+CONFIG_ALTIVEC=y
+# CONFIG_VSX is not set
+CONFIG_PPC_STD_MMU=y
+CONFIG_PPC_STD_MMU_64=y
+CONFIG_PPC_MM_SLICES=y
+CONFIG_VIRT_CPU_ACCOUNTING=y
+CONFIG_PPC_HAVE_PMU_SUPPORT=y
+CONFIG_PPC_PERF_CTRS=y
+CONFIG_SMP=y
+CONFIG_NR_CPUS=2
+CONFIG_64BIT=y
+CONFIG_WORD_SIZE=64
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_MMU=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_IRQ_PER_CPU=y
+CONFIG_NR_IRQS=512
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_ILOG2_U32=y
+CONFIG_ARCH_HAS_ILOG2_U64=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_ARCH_NO_VIRT_TO_BUS=y
+CONFIG_PPC=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_COMPAT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_PPC_OF=y
+# CONFIG_PPC_UDBG_16550 is not set
+# CONFIG_GENERIC_TBSYNC is not set
+CONFIG_AUDIT_ARCH=y
+CONFIG_GENERIC_BUG=y
+# CONFIG_DEFAULT_UIMAGE is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+# CONFIG_PPC_DCR_NATIVE is not set
+# CONFIG_PPC_DCR_MMIO is not set
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=64
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_SYSCALL_WRAPPERS=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_FREEZER is not set
+
+#
+# Platform support
+#
+# CONFIG_PPC_PSERIES is not set
+# CONFIG_PPC_ISERIES is not set
+# CONFIG_PPC_PMAC is not set
+# CONFIG_PPC_MAPLE is not set
+# CONFIG_PPC_PASEMI is not set
+CONFIG_PPC_PS3=y
+
+#
+# PS3 Platform Options
+#
+CONFIG_PS3_ADVANCED=y
+CONFIG_PS3_HTAB_SIZE=20
+# CONFIG_PS3_DYNAMIC_DMA is not set
+CONFIG_PS3_VUART=y
+CONFIG_PS3_PS3AV=y
+CONFIG_PS3_SYS_MANAGER=y
+CONFIG_PS3_STORAGE=y
+CONFIG_PS3_DISK=y
+CONFIG_PS3_ROM=y
+CONFIG_PS3_FLASH=y
+CONFIG_PS3_VRAM=m
+CONFIG_PS3_LPM=m
+CONFIG_OPROFILE_PS3=y
+CONFIG_PS3_DEBUG_BOOT_MEM_LIMIT=-1
+CONFIG_PS3_DEBUG_HOT_PLUG_MEM_LIMIT=-1
+CONFIG_PS3GELIC_UDBG=y
+CONFIG_PPC_CELL=y
+# CONFIG_PPC_CELL_NATIVE is not set
+# CONFIG_PPC_IBM_CELL_BLADE is not set
+# CONFIG_PPC_CELLEB is not set
+# CONFIG_PPC_CELL_QPACE is not set
+
+#
+# Cell Broadband Engine options
+#
+CONFIG_SPU_FS=m
+CONFIG_SPU_FS_64K_LS=y
+CONFIG_SPU_BASE=y
+# CONFIG_PQ2ADS is not set
+# CONFIG_PPC_OF_BOOT_TRAMPOLINE is not set
+# CONFIG_IPIC is not set
+# CONFIG_MPIC is not set
+# CONFIG_MPIC_WEIRD is not set
+# CONFIG_PPC_I8259 is not set
+# CONFIG_U3_DART is not set
+# CONFIG_PPC_RTAS is not set
+# CONFIG_MMIO_NVRAM is not set
+# CONFIG_MPIC_U3_HT_IRQS is not set
+# CONFIG_PPC_MPC106 is not set
+# CONFIG_PPC_970_NAP is not set
+# CONFIG_PPC_INDIRECT_IO is not set
+# CONFIG_GENERIC_IOMAP is not set
+# CONFIG_CPU_FREQ is not set
+# CONFIG_FSL_ULI1575 is not set
+# CONFIG_SIMPLE_GPIO is not set
+
+#
+# Kernel options
+#
+CONFIG_TICK_ONESHOT=y
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_HUGETLB_PAGE_SIZE_VARIABLE=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_SWIOTLB is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_ARCH_HAS_WALK_MEMORY=y
+CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE=y
+CONFIG_KEXEC=y
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_IRQ_ALL_CPUS is not set
+CONFIG_SPARSE_IRQ=y
+# CONFIG_NUMA is not set
+CONFIG_MAX_ACTIVE_REGIONS=256
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SYS_SUPPORTS_HUGETLBFS=y
+CONFIG_SELECT_MEMORY_MODEL=y
+# CONFIG_FLATMEM_MANUAL is not set
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+# CONFIG_SPARSEMEM_VMEMMAP is not set
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_MEMORY_HOTPLUG=y
+CONFIG_MEMORY_HOTPLUG_SPARSE=y
+# CONFIG_MEMORY_HOTREMOVE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ARCH_MEMORY_PROBE=y
+CONFIG_PPC_HAS_HASH_64K=y
+CONFIG_PPC_4K_PAGES=y
+# CONFIG_PPC_64K_PAGES is not set
+CONFIG_FORCE_MAX_ZONEORDER=13
+CONFIG_SCHED_SMT=y
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE=""
+CONFIG_EXTRA_TARGETS=""
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_ADVANCED_DEBUG is not set
+# CONFIG_PM_VERBOSE is not set
+# CONFIG_HIBERNATION is not set
+# CONFIG_PM_RUNTIME is not set
+# CONFIG_SECCOMP is not set
+CONFIG_ISA_DMA_API=y
+
+#
+# Bus options
+#
+CONFIG_ZONE_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_PPC_PCI_CHOICE=y
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS is not set
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+# CONFIG_HAS_RAPIDIO is not set
+# CONFIG_RELOCATABLE is not set
+CONFIG_PAGE_OFFSET=0xc000000000000000
+CONFIG_KERNEL_START=0xc000000000000000
+CONFIG_PHYSICAL_START=0x00000000
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+CONFIG_RPS=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+
+#
+# Flattened Device Tree and Open Firmware support
+#
+CONFIG_PROC_DEVICETREE=y
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_DYNAMIC=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_DEVICE=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65535
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BLK_DEV_DM is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=m
+# CONFIG_ETHOC is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_NETDEV_1000=y
+CONFIG_GELIC_NET=y
+# CONFIG_XILINX_LL_TEMAC is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_CDC_EEM is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_USB_SIERRA_NET=m
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+CONFIG_NETCONSOLE=m
+# CONFIG_NETCONSOLE_DYNAMIC is not set
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=m
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=m
+CONFIG_INPUT_EVDEV=m
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_GRLIB_GAISLER_APBUART is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_HVC_UDBG is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+# CONFIG_MFD_SUPPORT is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=m
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_OF is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+CONFIG_FB_PS3=y
+CONFIG_FB_PS3_DEFAULT_SIZE_M=8
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+CONFIG_FB_LOGO_EXTRA=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+# CONFIG_HID_PID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+CONFIG_USB_KBD=m
+CONFIG_USB_MOUSE=m
+
+#
+# Special HID drivers
+#
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=m
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_BIG_ENDIAN_MMIO=y
+# CONFIG_USB_EHCI_HCD_PPC_OF is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_HCD_PPC_OF_BE is not set
+# CONFIG_USB_OHCI_HCD_PPC_OF_LE is not set
+# CONFIG_USB_OHCI_HCD_PPC_OF is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+CONFIG_USB_OHCI_BIG_ENDIAN_MMIO=y
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# Enable Host or Gadget support to see Inventra options
+#
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+# CONFIG_USB_EZUSB is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+CONFIG_USB_SERIAL_CP210X=m
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=m
+CONFIG_RTC_CLASS=m
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_GENERIC is not set
+CONFIG_RTC_DRV_PS3=m
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=m
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=m
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_XATTR=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=m
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+CONFIG_QUOTA=y
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+CONFIG_AUTOFS_FS=m
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_UPCALL is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_DFS_UPCALL is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_LZO_COMPRESS=m
+CONFIG_LZO_DECOMPRESS=m
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+CONFIG_DEBUG_SPINLOCK_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_DEBUG_WRITECOUNT=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_DEBUG_LIST=y
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_RING_BUFFER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_PPC_DISABLE_WERROR is not set
+CONFIG_PPC_WERROR=y
+CONFIG_PRINT_STACK_DEPTH=64
+CONFIG_DEBUG_STACKOVERFLOW=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_PPC_EMULATED_STATS is not set
+# CONFIG_CODE_PATCHING_SELFTEST is not set
+# CONFIG_FTR_FIXUP_SELFTEST is not set
+# CONFIG_MSI_BITMAP_SELFTEST is not set
+# CONFIG_XMON is not set
+# CONFIG_VIRQ_DEBUG is not set
+# CONFIG_BOOTX_TEXT is not set
+CONFIG_PPC_EARLY_DEBUG=y
+CONFIG_PPC_EARLY_DEBUG_PS3GELIC=y
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_KEYS_COMPAT=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=m
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=m
+CONFIG_CRYPTO_GCM=m
+CONFIG_CRYPTO_SEQIV=m
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=m
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=m
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+CONFIG_CRYPTO_GHASH=m
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=m
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+CONFIG_CRYPTO_SALSA20=m
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=m
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_PPC_CLOCK is not set
+# CONFIG_VIRTUALIZATION is not set
diff -Nur linux-2.6.36-rc7/scripts/oprofile-test ps3-linux/scripts/oprofile-test
--- linux-2.6.36-rc7/scripts/oprofile-test	1970-01-01 07:00:00.000000000 +0700
+++ ps3-linux/scripts/oprofile-test	2010-12-04 16:17:49.879349880 +0600
@@ -0,0 +1,104 @@
+#!/bin/sh -x
+
+name=oprofile
+prefixes="/usr"
+
+for prefix in ${prefixes}; do
+
+	if [ ! -d ${prefix} ]; then
+		echo "$0: bad prefix: '${prefix}'"
+		echo "$0: -- ${name} FAILED --"
+		exit 1
+	fi
+
+	dir=${prefix}/bin
+
+	if [ ! -d ${dir} ]; then
+		echo "$0: can't find root dir: '${dir}'"
+		echo "$0: -- ${name} FAILED --"
+		exit 1
+	fi
+
+	prog=${dir}/opcontrol
+
+	if [ ! -f ${prog} ] ; then
+		echo "$0: can't find progam: '${prog}'"
+		echo "$0: -- ${name} FAILED --"
+		exit 1
+	fi
+
+	prog=${dir}/opreport
+
+	if [ ! -f ${prog} ] ; then
+		echo "$0: can't find progam: '${prog}'"
+		echo "$0: -- ${name} FAILED --"
+		exit 1
+	fi
+
+	time=`date +%y.%m.%d-%H.%M.%S`
+	log=/root/${name}-dump-`hostname`-`uname -r`-${time}.dmp
+
+	echo "$0: root dir = '${dir}'"
+	echo "$0: log = '$log'"
+
+	${dir}/opcontrol --shutdown
+	${dir}/opcontrol --reset
+	${dir}/opcontrol --reset
+	rm -rf /var/lib/oprofile/*
+
+	if [ ! -f /boot/vmlinux ] ; then
+		echo "$0: can't find: '/boot/vmlinux'"
+		echo "$0: -- ${name} FAILED --"
+		exit 1
+	fi
+
+	${dir}/opcontrol --vmlinux=/boot/vmlinux
+
+	if [ $? -ne 0 ]; then
+		echo "$0: opcontrol --vmlinux failed."
+		echo "$0: -- ${name} FAILED --"
+		exit -1
+	fi
+
+	${dir}/opcontrol --event=cache_hit:10000 --event=cache_miss:10000
+
+	if [ $? -ne 0 ]; then
+		echo "$0: opcontrol --event=cache_hit:10000 --event=cache_miss:10000 failed."
+	fi
+
+	${dir}/opcontrol --verbose --start
+
+	if [ $? -ne 0 ]; then
+		echo "$0: opcontrol --start failed."
+		echo "$0: -- ${name} FAILED --"
+		exit -1
+	fi
+
+	echo sleeping 25 sec...
+	sleep 25
+
+	${dir}/opcontrol --dump
+
+	if [ $? -ne 0 ]; then
+		echo "$0: opcontrol --dump failed."
+		echo "$0: -- ${name} FAILED --"
+		exit -1
+	fi
+
+	${dir}/opreport
+
+	if [ $? -ne 0 ]; then
+		echo "$0: opreport failed."
+		echo "$0: -- ${name} FAILED --"
+		exit -1
+	fi
+
+	${dir}/opcontrol --shutdown
+	${dir}/opcontrol --reset
+	${dir}/opcontrol --reset
+	rm -rf /var/lib/oprofile/*
+
+	echo "$0: ++ ${name} OK ++"
+done
+
+exit 0
diff -Nur linux-2.6.36-rc7/sound/ppc/snd_ps3.c ps3-linux/sound/ppc/snd_ps3.c
--- linux-2.6.36-rc7/sound/ppc/snd_ps3.c	2010-10-07 03:39:52.000000000 +0700
+++ ps3-linux/sound/ppc/snd_ps3.c	2010-12-04 16:17:50.019342025 +0600
@@ -875,7 +875,7 @@
 		(0x0fUL << 12) |
 		(PS3_AUDIO_IOID);
 
-	ret = lv1_gpu_attribute(0x100, 0x007, val, 0, 0);
+	ret = lv1_gpu_attribute(0x100, 0x007, val);
 	if (ret)
 		pr_info("%s: gpu_attribute failed %d\n", __func__,
 			ret);
