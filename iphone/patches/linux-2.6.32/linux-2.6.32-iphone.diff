diff -Nur linux-2.6.32-orig/arch/alpha/kernel/osf_sys.c iDroid-Project-kernel_common-9e90fd2/arch/alpha/kernel/osf_sys.c
--- linux-2.6.32-orig/arch/alpha/kernel/osf_sys.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/alpha/kernel/osf_sys.c	2010-11-18 21:05:30.000000000 +0600
@@ -178,25 +178,18 @@
 		unsigned long, prot, unsigned long, flags, unsigned long, fd,
 		unsigned long, off)
 {
-	struct file *file = NULL;
-	unsigned long ret = -EBADF;
+	unsigned long ret = -EINVAL;
 
 #if 0
 	if (flags & (_MAP_HASSEMAPHORE | _MAP_INHERIT | _MAP_UNALIGNED))
 		printk("%s: unimplemented OSF mmap flags %04lx\n", 
 			current->comm, flags);
 #endif
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	down_write(&current->mm->mmap_sem);
-	ret = do_mmap(file, addr, len, prot, flags, off);
-	up_write(&current->mm->mmap_sem);
-	if (file)
-		fput(file);
+	if ((off + PAGE_ALIGN(len)) < off)
+		goto out;
+	if (off & ~PAGE_MASK)
+		goto out;
+	ret = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
  out:
 	return ret;
 }
diff -Nur linux-2.6.32-orig/arch/arm/boot/compressed/head.S iDroid-Project-kernel_common-9e90fd2/arch/arm/boot/compressed/head.S
--- linux-2.6.32-orig/arch/arm/boot/compressed/head.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/boot/compressed/head.S	2010-11-18 21:05:30.000000000 +0600
@@ -21,7 +21,7 @@
 
 #if defined(CONFIG_DEBUG_ICEDCC)
 
-#ifdef CONFIG_CPU_V6
+#ifdef defined(CONFIG_CPU_V6) || defined(CONFIG_CPU_V7)
 		.macro	loadsp, rb
 		.endm
 		.macro	writeb, ch, rb
@@ -620,6 +620,8 @@
 @		b	__arm6_mmu_cache_off
 @		b	__armv3_mmu_cache_flush
 
+#if !defined(CONFIG_CPU_V7)
+		/* This collides with some V7 IDs, preventing correct detection */
 		.word	0x00000000		@ old ARM ID
 		.word	0x0000f000
 		mov	pc, lr
@@ -628,6 +630,7 @@
  THUMB(		nop				)
 		mov	pc, lr
  THUMB(		nop				)
+#endif
 
 		.word	0x41007000		@ ARM7/710
 		.word	0xfff8fe00
diff -Nur linux-2.6.32-orig/arch/arm/boot/compressed/misc.c iDroid-Project-kernel_common-9e90fd2/arch/arm/boot/compressed/misc.c
--- linux-2.6.32-orig/arch/arm/boot/compressed/misc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/boot/compressed/misc.c	2010-11-18 21:05:30.000000000 +0600
@@ -33,7 +33,7 @@
 
 #ifdef CONFIG_DEBUG_ICEDCC
 
-#ifdef CONFIG_CPU_V6
+#if defined(CONFIG_CPU_V6) || defined(CONFIG_CPU_V7)
 
 static void icedcc_putc(int ch)
 {
diff -Nur linux-2.6.32-orig/arch/arm/configs/iphone3g_defconfig iDroid-Project-kernel_common-9e90fd2/arch/arm/configs/iphone3g_defconfig
--- linux-2.6.32-orig/arch/arm/configs/iphone3g_defconfig	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/configs/iphone3g_defconfig	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,1550 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32.9
+# Thu Jun 10 02:36:42 2010
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_USER_SCHED is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+# CONFIG_CGROUP_NS is not set
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
+CONFIG_AIO=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+# CONFIG_MODULE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_MACH_APPLE_IPHONE=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_BCMRING is not set
+CONFIG_S3C_DEV_USB_HSOTG=y
+
+#
+# Apple iPhone platform type
+#
+# CONFIG_IPHONE_2G is not set
+CONFIG_IPHONE_3G=y
+# CONFIG_IPODTOUCH_1G is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_V6=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+# CONFIG_ARM_ERRATA_411920 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+CONFIG_CONSOLE_EARLYSUSPEND=y
+# CONFIG_FB_EARLYSUSPEND is not set
+# CONFIG_APM_EMULATION is not set
+# CONFIG_PM_RUNTIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE=y
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_ARPD=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_STP=y
+CONFIG_BRIDGE=y
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+CONFIG_CFG80211_DEFAULT_PS_VALUE=0
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_LIB80211=y
+# CONFIG_LIB80211_DEBUG is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_PARTITIONS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_HAVE_MTD_OTP=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_DATAFLASH=y
+CONFIG_MTD_DATAFLASH_WRITE_VERIFY=y
+CONFIG_MTD_DATAFLASH_OTP=y
+CONFIG_MTD_M25P80=y
+CONFIG_M25PXX_USE_FAST_READ=y
+CONFIG_MTD_SST25L=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND_IDS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+CONFIG_IPHONE_BLK=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+CONFIG_ANDROID_PMEM=y
+CONFIG_ICS932S401=y
+CONFIG_IPHONE_3G_VIBRATOR=y
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_KERNEL_DEBUGGER_CORE is not set
+CONFIG_ISL29003=y
+# CONFIG_UID_STAT is not set
+# CONFIG_WL127X_RFKILL is not set
+# CONFIG_APANIC is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+CONFIG_EEPROM_LEGACY=y
+CONFIG_EEPROM_MAX6875=y
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+CONFIG_SMC91X=y
+# CONFIG_DM9000 is not set
+CONFIG_ENC28J60=y
+CONFIG_ENC28J60_WRITEVERIFY=y
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+CONFIG_KS8851=y
+# CONFIG_KS8851_MLL is not set
+CONFIG_NETDEV_1000=y
+CONFIG_NETDEV_10000=y
+CONFIG_WLAN=y
+# CONFIG_WLAN_PRE80211 is not set
+CONFIG_WLAN_80211=y
+CONFIG_LIBERTAS=y
+CONFIG_LIBERTAS_SDIO=y
+# CONFIG_LIBERTAS_SPI is not set
+# CONFIG_LIBERTAS_DEBUG is not set
+# CONFIG_HOSTAP is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_KEYRESET is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_GPIO_IPHONE=y
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_APPLE_IPHONE is not set
+CONFIG_TOUCHSCREEN_APPLE_ZEPHYR2=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYCHORD is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_GPIO is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_APPLE_IPHONE=y
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+CONFIG_I2C_GPIO=y
+CONFIG_I2C_OCORES=y
+CONFIG_I2C_SIMTEC=y
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+CONFIG_SENSORS_TSL2550=y
+# CONFIG_SENSORS_PCA963X is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+CONFIG_BATTERY_IPHONE=y
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13783 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_APPLE_IPHONE=y
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_IPHONE=y
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+CONFIG_FONT_MINI_4x6=y
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+# CONFIG_LOGO_LINUX_CLUT224 is not set
+CONFIG_LOGO_ANDROID_CLUT224=y
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+# CONFIG_SND_SPI is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_APPLE_IPHONE=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+CONFIG_SND_SOC_ALL_CODECS=y
+CONFIG_SND_SOC_WM_HUBS=y
+CONFIG_SND_SOC_AD1836=y
+CONFIG_SND_SOC_AD1938=y
+CONFIG_SND_SOC_AD73311=y
+CONFIG_SND_SOC_AK4104=y
+CONFIG_SND_SOC_AK4535=y
+CONFIG_SND_SOC_AK4642=y
+CONFIG_SND_SOC_CS4270=y
+CONFIG_SND_SOC_L3=y
+CONFIG_SND_SOC_PCM3008=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_SND_SOC_SSM2602=y
+CONFIG_SND_SOC_TLV320AIC23=y
+CONFIG_SND_SOC_TLV320AIC26=y
+CONFIG_SND_SOC_TLV320AIC3X=y
+CONFIG_SND_SOC_UDA134X=y
+CONFIG_SND_SOC_UDA1380=y
+CONFIG_SND_SOC_WM8510=y
+CONFIG_SND_SOC_WM8523=y
+CONFIG_SND_SOC_WM8580=y
+CONFIG_SND_SOC_WM8728=y
+CONFIG_SND_SOC_WM8731=y
+CONFIG_SND_SOC_WM8750=y
+CONFIG_SND_SOC_WM8753=y
+CONFIG_SND_SOC_WM8776=y
+CONFIG_SND_SOC_WM8900=y
+CONFIG_SND_SOC_WM8903=y
+CONFIG_SND_SOC_WM8940=y
+CONFIG_SND_SOC_WM8960=y
+CONFIG_SND_SOC_WM8961=y
+CONFIG_SND_SOC_WM8971=y
+CONFIG_SND_SOC_WM8974=y
+CONFIG_SND_SOC_WM8988=y
+CONFIG_SND_SOC_WM8990=y
+CONFIG_SND_SOC_WM8991=y
+CONFIG_SND_SOC_WM8993=y
+CONFIG_SND_SOC_WM9081=y
+CONFIG_SND_SOC_MAX9877=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+# CONFIG_HID_PID is not set
+
+#
+# Special HID drivers
+#
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+CONFIG_USB_GADGET_S3C_HSOTG=y
+CONFIG_USB_S3C_HSOTG=y
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DWC_OTG is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_ANDROID=y
+CONFIG_USB_ANDROID_ACM=y
+CONFIG_USB_ANDROID_ADB=y
+# CONFIG_USB_ANDROID_MASS_STORAGE is not set
+# CONFIG_USB_ANDROID_RNDIS is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+# CONFIG_MMC_PARANOID_SD_INIT is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_SDIO_IPHONE=y
+# CONFIG_MMC_AT91 is not set
+# CONFIG_MMC_ATMELMCI is not set
+CONFIG_MMC_SPI=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_SWITCH=y
+# CONFIG_SWITCH_GPIO is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_ECHO is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+# CONFIG_ANDROID_RAM_CONSOLE is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+# CONFIG_ANDROID_TIMED_GPIO is not set
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+
+#
+# Qualcomm MSM Camera And Video
+#
+
+#
+# Camera Sensor Selection
+#
+# CONFIG_DST is not set
+# CONFIG_POHMELFS is not set
+# CONFIG_PLAN9AUTH is not set
+
+#
+# RAR Register Driver
+#
+# CONFIG_RAR_REGISTER is not set
+# CONFIG_IIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+CONFIG_HFSPLUS_FS=y
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_9BYTE_TAGS is not set
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+# CONFIG_YAFFS_EMPTY_LOST_AND_FOUND is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+# CONFIG_NFSD_V4 is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=y
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_PAGE_POISONING is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_BOOT_TRACER is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_PCBC=y
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+CONFIG_CRC7=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff -Nur linux-2.6.32-orig/arch/arm/configs/msm_defconfig iDroid-Project-kernel_common-9e90fd2/arch/arm/configs/msm_defconfig
--- linux-2.6.32-orig/arch/arm/configs/msm_defconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/configs/msm_defconfig	2010-11-18 21:05:30.000000000 +0600
@@ -69,6 +69,7 @@
 CONFIG_SIGNALFD=y
 CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
 CONFIG_VM_EVENT_COUNTERS=y
 CONFIG_SLAB=y
 # CONFIG_SLUB is not set
@@ -256,6 +257,7 @@
 CONFIG_UNIX=y
 # CONFIG_NET_KEY is not set
 CONFIG_INET=y
+CONFIG_ANDROID_PARANOID_NETWORK=y
 # CONFIG_IP_MULTICAST is not set
 # CONFIG_IP_ADVANCED_ROUTER is not set
 CONFIG_IP_FIB_HASH=y
diff -Nur linux-2.6.32-orig/arch/arm/include/asm/cacheflush.h iDroid-Project-kernel_common-9e90fd2/arch/arm/include/asm/cacheflush.h
--- linux-2.6.32-orig/arch/arm/include/asm/cacheflush.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/include/asm/cacheflush.h	2010-11-18 21:05:30.000000000 +0600
@@ -381,7 +381,7 @@
  * Harvard caches are synchronised for the user space address range.
  * This is used for the ARM private sys_cacheflush system call.
  */
-#define flush_cache_user_range(vma,start,end) \
+#define flush_cache_user_range(start,end) \
 	__cpuc_coherent_user_range((start) & PAGE_MASK, PAGE_ALIGN(end))
 
 /*
diff -Nur linux-2.6.32-orig/arch/arm/include/asm/mman.h iDroid-Project-kernel_common-9e90fd2/arch/arm/include/asm/mman.h
--- linux-2.6.32-orig/arch/arm/include/asm/mman.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/include/asm/mman.h	2010-11-18 21:05:30.000000000 +0600
@@ -1 +1,4 @@
 #include <asm-generic/mman.h>
+
+#define arch_mmap_check(addr, len, flags) \
+	(((flags) & MAP_FIXED && (addr) < FIRST_USER_ADDRESS) ? -EINVAL : 0)
diff -Nur linux-2.6.32-orig/arch/arm/include/asm/ptrace.h iDroid-Project-kernel_common-9e90fd2/arch/arm/include/asm/ptrace.h
--- linux-2.6.32-orig/arch/arm/include/asm/ptrace.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/include/asm/ptrace.h	2010-11-18 21:05:30.000000000 +0600
@@ -150,7 +150,11 @@
  */
 static inline int valid_user_regs(struct pt_regs *regs)
 {
-	if (user_mode(regs) && (regs->ARM_cpsr & PSR_I_BIT) == 0) {
+	long mode = regs->ARM_cpsr & MODE_MASK;
+
+	if (((mode == USR_MODE) ||
+	     ((elf_hwcap & HWCAP_26BIT) && (mode == USR26_MODE))) &&
+	    (regs->ARM_cpsr & PSR_I_BIT) == 0) {
 		regs->ARM_cpsr &= ~(PSR_F_BIT | PSR_A_BIT);
 		return 1;
 	}
diff -Nur linux-2.6.32-orig/arch/arm/Kconfig iDroid-Project-kernel_common-9e90fd2/arch/arm/Kconfig
--- linux-2.6.32-orig/arch/arm/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -206,6 +206,22 @@
 	prompt "ARM system type"
 	default ARCH_VERSATILE
 
+config MACH_APPLE_IPHONE
+	bool "Apple iPhone"
+	select GENERIC_TIME
+	select GENERIC_CLOCKEVENTS
+	select SERIAL_CORE
+	select SERIAL_CORE_CONSOLE
+	select FB
+	select FB_DEFERRED_IO
+	select FRAMEBUFFER_CONSOLE
+	select FB_APPLE_IPHONE
+	select HAVE_CLK
+	select GENERIC_GPIO
+        select S3C_DEV_USB_HSOTG
+	help
+	  Apple's iPhone!
+
 config ARCH_AAEC2000
 	bool "Agilent AAEC-2000 based"
 	select CPU_ARM920T
@@ -778,6 +794,8 @@
 
 source "arch/arm/mach-versatile/Kconfig"
 
+source "arch/arm/mach-apple_iphone/Kconfig"
+
 source "arch/arm/mach-aaec2000/Kconfig"
 
 source "arch/arm/mach-realview/Kconfig"
diff -Nur linux-2.6.32-orig/arch/arm/kernel/calls.S iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/calls.S
--- linux-2.6.32-orig/arch/arm/kernel/calls.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/calls.S	2010-11-18 21:05:30.000000000 +0600
@@ -172,7 +172,7 @@
 /* 160 */	CALL(sys_sched_get_priority_min)
 		CALL(sys_sched_rr_get_interval)
 		CALL(sys_nanosleep)
-		CALL(sys_arm_mremap)
+		CALL(sys_mremap)
 		CALL(sys_setresuid16)
 /* 165 */	CALL(sys_getresuid16)
 		CALL(sys_ni_syscall)		/* vm86 */
diff -Nur linux-2.6.32-orig/arch/arm/kernel/debug.S iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/debug.S
--- linux-2.6.32-orig/arch/arm/kernel/debug.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/debug.S	2010-11-18 21:05:30.000000000 +0600
@@ -22,7 +22,7 @@
 #if defined(CONFIG_DEBUG_ICEDCC)
 		@@ debug using ARM EmbeddedICE DCC channel
 
-#if defined(CONFIG_CPU_V6)
+#if defined(CONFIG_CPU_V6) || defined(CONFIG_CPU_V7)
 
 		.macro	addruart, rx
 		.endm
diff -Nur linux-2.6.32-orig/arch/arm/kernel/entry-armv.S iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/entry-armv.S
--- linux-2.6.32-orig/arch/arm/kernel/entry-armv.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/entry-armv.S	2010-11-18 21:05:30.000000000 +0600
@@ -741,10 +741,11 @@
 #endif
 #if defined(CONFIG_HAS_TLS_REG)
 	mcr	p15, 0, r3, c13, c0, 3		@ set TLS register
-#elif !defined(CONFIG_TLS_REG_EMUL)
+//#elif !defined(CONFIG_TLS_REG_EMUL)
+#endif
 	mov	r4, #0xffff0fff
 	str	r3, [r4, #-15]			@ TLS val at 0xffff0ff0
-#endif
+//#endif
 #ifdef CONFIG_MMU
 	mcr	p15, 0, r6, c3, c0, 0		@ Set domain register
 #endif
diff -Nur linux-2.6.32-orig/arch/arm/kernel/entry-common.S iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/entry-common.S
--- linux-2.6.32-orig/arch/arm/kernel/entry-common.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/entry-common.S	2010-11-18 21:05:30.000000000 +0600
@@ -416,12 +416,12 @@
 		tst	r5, #PGOFF_MASK
 		moveq	r5, r5, lsr #PAGE_SHIFT - 12
 		streq	r5, [sp, #4]
-		beq	do_mmap2
+		beq	sys_mmap_pgoff
 		mov	r0, #-EINVAL
 		mov	pc, lr
 #else
 		str	r5, [sp, #4]
-		b	do_mmap2
+		b	sys_mmap_pgoff
 #endif
 ENDPROC(sys_mmap2)
 
diff -Nur linux-2.6.32-orig/arch/arm/kernel/process.c iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/process.c
--- linux-2.6.32-orig/arch/arm/kernel/process.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/process.c	2010-11-18 21:05:30.000000000 +0600
@@ -206,6 +206,77 @@
 	arm_pm_restart(reboot_mode, cmd);
 }
 
+/*
+ * dump a block of kernel memory from around the given address
+ */
+static void show_data(unsigned long addr, int nbytes, const char *name)
+{
+	int	i, j;
+	int	nlines;
+	u32	*p;
+
+	/*
+	 * don't attempt to dump non-kernel addresses or
+	 * values that are probably just small negative numbers
+	 */
+	if (addr < PAGE_OFFSET || addr > -256UL)
+		return;
+
+	printk("\n%s: %#lx:\n", name, addr);
+
+	/*
+	 * round address down to a 32 bit boundary
+	 * and always dump a multiple of 32 bytes
+	 */
+	p = (u32 *)(addr & ~(sizeof(u32) - 1));
+	nbytes += (addr & (sizeof(u32) - 1));
+	nlines = (nbytes + 31) / 32;
+
+
+	for (i = 0; i < nlines; i++) {
+		/*
+		 * just display low 16 bits of address to keep
+		 * each line of the dump < 80 characters
+		 */
+		printk("%04lx ", (unsigned long)p & 0xffff);
+		for (j = 0; j < 8; j++) {
+			u32	data;
+			if (probe_kernel_address(p, data)) {
+				printk(" ********");
+			} else {
+				printk(" %08x", data);
+			}
+			++p;
+		}
+		printk("\n");
+	}
+}
+
+static void show_extra_register_data(struct pt_regs *regs, int nbytes)
+{
+	mm_segment_t fs;
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	show_data(regs->ARM_pc - nbytes, nbytes * 2, "PC");
+	show_data(regs->ARM_lr - nbytes, nbytes * 2, "LR");
+	show_data(regs->ARM_sp - nbytes, nbytes * 2, "SP");
+	show_data(regs->ARM_ip - nbytes, nbytes * 2, "IP");
+	show_data(regs->ARM_fp - nbytes, nbytes * 2, "FP");
+	show_data(regs->ARM_r0 - nbytes, nbytes * 2, "R0");
+	show_data(regs->ARM_r1 - nbytes, nbytes * 2, "R1");
+	show_data(regs->ARM_r2 - nbytes, nbytes * 2, "R2");
+	show_data(regs->ARM_r3 - nbytes, nbytes * 2, "R3");
+	show_data(regs->ARM_r4 - nbytes, nbytes * 2, "R4");
+	show_data(regs->ARM_r5 - nbytes, nbytes * 2, "R5");
+	show_data(regs->ARM_r6 - nbytes, nbytes * 2, "R6");
+	show_data(regs->ARM_r7 - nbytes, nbytes * 2, "R7");
+	show_data(regs->ARM_r8 - nbytes, nbytes * 2, "R8");
+	show_data(regs->ARM_r9 - nbytes, nbytes * 2, "R9");
+	show_data(regs->ARM_r10 - nbytes, nbytes * 2, "R10");
+	set_fs(fs);
+}
+
 void __show_regs(struct pt_regs *regs)
 {
 	unsigned long flags;
@@ -264,6 +335,8 @@
 		printk("Control: %08x%s\n", ctrl, buf);
 	}
 #endif
+
+	show_extra_register_data(regs, 128);
 }
 
 void show_regs(struct pt_regs * regs)
diff -Nur linux-2.6.32-orig/arch/arm/kernel/signal.c iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/signal.c
--- linux-2.6.32-orig/arch/arm/kernel/signal.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/signal.c	2010-11-18 21:05:30.000000000 +0600
@@ -517,6 +517,14 @@
 
 static inline void setup_syscall_restart(struct pt_regs *regs)
 {
+	if (regs->ARM_ORIG_r0 == -ERESTARTNOHAND ||
+	    regs->ARM_ORIG_r0 == -ERESTARTSYS ||
+	    regs->ARM_ORIG_r0 == -ERESTARTNOINTR ||
+	    regs->ARM_ORIG_r0 == -ERESTART_RESTARTBLOCK) {
+		/* the syscall cannot be safely restarted, return -EINTR instead */
+		regs->ARM_r0 = -EINTR;
+		return;
+	}
 	regs->ARM_r0 = regs->ARM_ORIG_r0;
 	regs->ARM_pc -= thumb_mode(regs) ? 2 : 4;
 }
@@ -649,6 +657,7 @@
 	 */
 	if (syscall) {
 		if (regs->ARM_r0 == -ERESTART_RESTARTBLOCK) {
+			regs->ARM_r0 = -EAGAIN; /* prevent multiple restarts */
 			if (thumb_mode(regs)) {
 				regs->ARM_r7 = __NR_restart_syscall - __NR_SYSCALL_BASE;
 				regs->ARM_pc -= 2;
diff -Nur linux-2.6.32-orig/arch/arm/kernel/sys_arm.c iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/sys_arm.c
--- linux-2.6.32-orig/arch/arm/kernel/sys_arm.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/sys_arm.c	2010-11-18 21:05:30.000000000 +0600
@@ -28,41 +28,6 @@
 #include <linux/ipc.h>
 #include <linux/uaccess.h>
 
-extern unsigned long do_mremap(unsigned long addr, unsigned long old_len,
-			       unsigned long new_len, unsigned long flags,
-			       unsigned long new_addr);
-
-/* common code for old and new mmaps */
-inline long do_mmap2(
-	unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags,
-	unsigned long fd, unsigned long pgoff)
-{
-	int error = -EINVAL;
-	struct file * file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-
-	if (flags & MAP_FIXED && addr < FIRST_USER_ADDRESS)
-		goto out;
-
-	error = -EBADF;
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:
-	return error;
-}
-
 struct mmap_arg_struct {
 	unsigned long addr;
 	unsigned long len;
@@ -84,29 +49,11 @@
 	if (a.offset & ~PAGE_MASK)
 		goto out;
 
-	error = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);
+	error = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);
 out:
 	return error;
 }
 
-asmlinkage unsigned long
-sys_arm_mremap(unsigned long addr, unsigned long old_len,
-	       unsigned long new_len, unsigned long flags,
-	       unsigned long new_addr)
-{
-	unsigned long ret = -EINVAL;
-
-	if (flags & MREMAP_FIXED && new_addr < FIRST_USER_ADDRESS)
-		goto out;
-
-	down_write(&current->mm->mmap_sem);
-	ret = do_mremap(addr, old_len, new_len, flags, new_addr);
-	up_write(&current->mm->mmap_sem);
-
-out:
-	return ret;
-}
-
 /*
  * Perform the select(nd, in, out, ex, tv) and mmap() system
  * calls.
diff -Nur linux-2.6.32-orig/arch/arm/kernel/traps.c iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/traps.c
--- linux-2.6.32-orig/arch/arm/kernel/traps.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/kernel/traps.c	2010-11-18 21:05:30.000000000 +0600
@@ -438,7 +438,9 @@
 		if (end > vma->vm_end)
 			end = vma->vm_end;
 
-		flush_cache_user_range(vma, start, end);
+		up_read(&mm->mmap_sem);
+		flush_cache_user_range(start, end);
+		return;
 	}
 	up_read(&mm->mmap_sem);
 }
@@ -505,7 +507,8 @@
 		thread->tp_value = regs->ARM_r0;
 #if defined(CONFIG_HAS_TLS_REG)
 		asm ("mcr p15, 0, %0, c13, c0, 3" : : "r" (regs->ARM_r0) );
-#elif !defined(CONFIG_TLS_REG_EMUL)
+//#elif !defined(CONFIG_TLS_REG_EMUL)
+#endif
 		/*
 		 * User space must never try to access this directly.
 		 * Expect your app to break eventually if you do so.
@@ -513,7 +516,7 @@
 		 * (see entry-armv.S for details)
 		 */
 		*((unsigned int *)0xffff0ff0) = regs->ARM_r0;
-#endif
+//#endif
 		return 0;
 
 #ifdef CONFIG_NEEDS_SYSCALL_FOR_CMPXCHG
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/clock.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/clock.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/clock.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/clock.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,114 @@
+/*
+ *  arch/arm/mach-apple_iphone/clock.c
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/iphone-clock.h>
+
+// Constants
+#define NUM_PLL 4
+#define FREQUENCY_BASE 12000000
+#define PLL0_INFREQ_DIV FREQUENCY_BASE /* 12 MHz */
+#define PLL1_INFREQ_DIV FREQUENCY_BASE /* 12 MHz */
+#define PLL2_INFREQ_DIV FREQUENCY_BASE /* 12 MHz */
+#define PLL3_INFREQ_DIV 13500000 /* 13.5 MHz */
+#define PLL0_INFREQ_MULT 0x4000
+#define PLL1_INFREQ_MULT 0x4000
+#define PLL2_INFREQ_MULT 0x4000
+#define PLL3_INFREQ_MULT FREQUENCY_BASE
+
+// Devices
+#define CLOCK1 IO_ADDRESS(0x3C500000)
+
+// Registers
+#define CLOCK1_CONFIG0 0x0
+#define CLOCK1_CONFIG1 0x4
+#define CLOCK1_CONFIG2 0x8
+#define CLOCK1_PLL0CON 0x20
+#define CLOCK1_PLL1CON 0x24
+#define CLOCK1_PLL2CON 0x28
+#define CLOCK1_PLL3CON 0x2C
+#define CLOCK1_PLLMODE 0x44
+#define CLOCK1_CL2_GATES 0x48
+#define CLOCK1_CL3_GATES 0x4C
+
+// Values
+#define CLOCK1_Separator 0x20
+
+#define CLOCK1_CLOCKPLL(x) GET_BITS((x), 12, 2)
+#define CLOCK1_CLOCKDIVIDER(x) (GET_BITS((x), 0, 4) + 1)
+#define CLOCK1_CLOCKHASDIVIDER(x) GET_BITS((x), 8, 1)
+
+#define CLOCK1_MEMORYPLL(x) GET_BITS((x), 12, 2)
+#define CLOCK1_MEMORYDIVIDER(x) (GET_BITS((x), 16, 4) + 1)
+#define CLOCK1_MEMORYHASDIVIDER(x) GET_BITS((x), 24, 1)
+
+#define CLOCK1_BUSPLL(x) GET_BITS((x), 12, 2)
+#define CLOCK1_BUSDIVIDER(x) (GET_BITS((x), 16, 4) + 1)
+#define CLOCK1_BUSHASDIVIDER(x) GET_BITS((x), 24, 1)
+
+#define CLOCK1_UNKNOWNPLL(x) GET_BITS((x), 12, 2)
+#define CLOCK1_UNKNOWNDIVIDER1(x) (GET_BITS((x), 0, 4) + 1)
+#define CLOCK1_UNKNOWNDIVIDER2(x) (GET_BITS((x), 4, 4) + 1)
+#define CLOCK1_UNKNOWNDIVIDER(x) (CLOCK1_UNKNOWNDIVIDER1(x) * CLOCK1_UNKNOWNDIVIDER2(x))
+#define CLOCK1_UNKNOWNHASDIVIDER(x) GET_BITS((x), 8, 1)
+
+#define CLOCK1_PERIPHERALDIVIDER(x) GET_BITS((x), 20, 2)
+
+#define CLOCK1_DISPLAYPLL(x) GET_BITS((x), 28, 2)
+#define CLOCK1_DISPLAYDIVIDER(x) GET_BITS((x), 16, 4)
+#define CLOCK1_DISPLAYHASDIVIDER(x) GET_BITS((x), 24, 1)
+
+#define CLOCK1_PLLMODE_ONOFF(x, y) (((x) >> (y)) & 0x1)
+#define CLOCK1_PLLMODE_DIVIDERMODE(x, y) (((x) >> (y + 4)) & 0x1)
+#define CLOCK1_PLLMODE_DIVIDE 1
+#define CLOCK1_PLLMODE_MULTIPLY 0
+
+#define CLOCK1_MDIV(x) (((x) >> 8) & 0x3FF)
+#define CLOCK1_PDIV(x) (((x) >> 24) & 0x3F)
+#define CLOCK1_SDIV(x) ((x) & 0x3)
+
+void iphone_clock_gate_switch(u32 gate, int on_off) {
+	u32 gate_register;
+	u32 gate_flag;
+	u32 gates;
+
+	if(gate < CLOCK1_Separator) {
+		gate_register = CLOCK1 + CLOCK1_CL2_GATES;
+		gate_flag = gate;
+	} else {
+		gate_register = CLOCK1 + CLOCK1_CL3_GATES;
+		gate_flag = gate - CLOCK1_Separator;
+	}
+
+	gates = __raw_readl(gate_register);
+
+	if(on_off) {
+		gates &= ~(1 << gate_flag);
+	} else {
+		gates |= 1 << gate_flag;
+	}
+
+	__raw_writel(gates, gate_register);
+
+}
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/core.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/core.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/core.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/core.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,43 @@
+/*
+ *  linux/arch/arm/mach-apple_iphone/core.h
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IPHONE_H
+#define __ASM_ARCH_IPHONE_H
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/time.h>
+#include <asm/mach/irq.h>
+
+extern void __init iphone_init(void);
+extern void __init iphone_init_irq(void);
+extern void __init iphone_map_io(void);
+
+extern struct sys_timer iphone_timer;
+
+extern struct platform_device s3c_device_usb_hsotg;
+#endif
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/dma.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/dma.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/dma.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/dma.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,575 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+
+#include <mach/hardware.h>
+#include <mach/iphone-dma.h>
+#include <mach/dma.h>
+#include <mach/iphone-clock.h>
+
+#define GET_BITS(x, start, length) ((((u32)(x)) << (32 - ((start) + (length)))) >> (32 - (length)))
+
+static const int ControllerLookupTable[] = {
+	1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1,
+	2, 2, 2, 2, 2,
+	2, 2, 2, 2, 3,
+	3, 3, 3, 3, 3,
+	3
+};
+
+static const u32 AddressLookupTable[] = {
+	0x3CC00024, 0x3CC00020, 0x3CC08024, 0x3CC08020, 0x3CC0C024,
+	0x3CC0C020, 0x3CC10024, 0x3CC10020, 0x38A00080, 0x38300040,
+	0x3CE00020, 0x3CE00010, 0x3D200020, 0x3D200010, 0x3CD00038,
+	0x3CD00010, 0x3D400038, 0x3D400010, 0x3CB00010, 0x3CA00038,
+	0x3CA00010, 0x3C300020, 0x3C300010, 0x3CC04024, 0x3CC04020,
+	0
+};
+
+static const u32 PeripheralLookupTable[][IPHONE_DMA_NUMCONTROLLERS] = {
+	{0x07, 0x10}, {0x06, 0x10}, {0x0B, 0x10}, {0x0A, 0x10}, {0x0D, 0x10},
+	{0x0C, 0x10}, {0x0F, 0x10}, {0x0E, 0x10}, {0x02, 0x10}, {0x03, 0x10},
+	{0x10, 0x0D}, {0x10, 0x0C}, {0x10, 0x0F}, {0x10, 0x0E}, {0x10, 0x03},
+	{0x10, 0x02}, {0x10, 0x05}, {0x10, 0x04}, {0x10, 0x06}, {0x01, 0x01},
+	{0x00, 0x00}, {0x05, 0x0B}, {0x04, 0x0A}, {0x09, 0x09}, {0x08, 0x08},
+	{0x00, 0x00}
+};
+
+static volatile DMARequest requests[IPHONE_DMA_NUMCONTROLLERS][IPHONE_DMA_NUMCHANNELS];
+static DMALinkedList* DMALists[IPHONE_DMA_NUMCONTROLLERS][IPHONE_DMA_NUMCHANNELS];
+static dma_addr_t DMAListsPhys[IPHONE_DMA_NUMCONTROLLERS][IPHONE_DMA_NUMCHANNELS];
+static size_t DMAListsSize[IPHONE_DMA_NUMCONTROLLERS][IPHONE_DMA_NUMCHANNELS];
+
+static void dispatchRequest(volatile DMARequest *request);
+
+static irqreturn_t dmaIRQHandler(int irq, void* pController);
+
+static volatile int Controller0FreeChannels[IPHONE_DMA_NUMCHANNELS] = {0};
+static volatile int Controller1FreeChannels[IPHONE_DMA_NUMCHANNELS] = {0};
+static spinlock_t freeChannelsLock;
+
+static struct device* dma_dev;
+
+int iphone_dma_setup(void) {
+	int ret;
+
+	iphone_clock_gate_switch(DMAC0_CLOCKGATE, 1);
+	iphone_clock_gate_switch(DMAC1_CLOCKGATE, 1);
+
+	memset(requests, 0, sizeof(requests));
+
+        ret = request_irq(DMAC0_INTERRUPT, dmaIRQHandler, IRQF_DISABLED, "iphone_dma", (void*) 1);
+        ret = request_irq(DMAC1_INTERRUPT, dmaIRQHandler, IRQF_DISABLED, "iphone_dma", (void*) 2);
+
+	spin_lock_init(&freeChannelsLock);
+
+	return ret;
+}
+
+static irqreturn_t dmaIRQHandler(int irq, void* pController) {
+	u32 intTCStatusReg;
+	u32 intTCClearReg;
+	u32 intTCStatus;
+	int channel;
+	u32 controller = (u32)pController;
+
+	if(controller == 1) {
+		intTCStatusReg = DMAC0 + DMACIntTCStatus;
+		intTCClearReg = DMAC0 + DMACIntTCClear;
+	} else {
+		intTCStatusReg = DMAC1 + DMACIntTCStatus;
+		intTCClearReg = DMAC1 + DMACIntTCClear;
+	}
+
+	intTCStatus = __raw_readl(intTCStatusReg);
+
+	for(channel = 0; channel < IPHONE_DMA_NUMCHANNELS; channel++) {
+		if((intTCStatus & (1 << channel)) != 0) {
+			dispatchRequest(&requests[controller - 1][channel]);
+			__raw_writel(1 << channel, intTCClearReg);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int getFreeChannel(int* controller, int* channel) {
+	int i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&freeChannelsLock, flags);
+	if((*controller & (1 << 0)) != 0) {
+		for(i = 0; i < IPHONE_DMA_NUMCHANNELS; i++) {
+			if(Controller0FreeChannels[i] == 0) {
+				*controller = 1;
+				*channel = i;
+				Controller0FreeChannels[i] = 1;
+				spin_unlock_irqrestore(&freeChannelsLock, flags);
+				return 0;
+			}
+		}
+	}
+
+	if((*controller & (1 << 1)) != 0) {
+		for(i = 0; i < IPHONE_DMA_NUMCHANNELS; i++) {
+			if(Controller1FreeChannels[i] == 0) {
+				*controller = 2;
+				*channel = i;
+				Controller1FreeChannels[i] = 1;
+				spin_unlock_irqrestore(&freeChannelsLock, flags);
+				return 0;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&freeChannelsLock, flags);
+
+	return ERROR_BUSY;
+}
+
+void iphone_dma_set_done_handler(int* controller, int* channel, void (*done_handler)(int controller, int channel, void* token), void* token)
+{
+	requests[*controller - 1][*channel].token = token;
+	requests[*controller - 1][*channel].done_handler = done_handler;
+}
+
+int iphone_dma_request(int Source, int SourceTransferWidth, int SourceBurstSize, int Destination, int DestinationTransferWidth, int DestinationBurstSize, int* controller, int* channel) {
+	u32 DMACControl;
+	u32 DMACConfig;
+	u32 config;
+	int x;
+
+	if(*controller == 0) {
+		*controller = ControllerLookupTable[Source] & ControllerLookupTable[Destination];
+
+		if(*controller == 0) {
+			return ERROR_DMA;
+		}
+
+		while(getFreeChannel(controller, channel) == ERROR_BUSY);
+		requests[*controller - 1][*channel].started = true;
+		requests[*controller - 1][*channel].done = false;
+		requests[*controller - 1][*channel].done_handler = NULL;
+		requests[*controller - 1][*channel].controller = *controller;
+		requests[*controller - 1][*channel].channel = *channel;
+	}
+
+	if(*controller == 1) {
+		DMACControl = DMAC0 + DMAC0Control0 + (*channel * DMAChannelRegSize);
+		DMACConfig = DMAC0 + DMACConfiguration;
+	} else if(*controller == 2) {
+		DMACControl = DMAC1 + DMAC0Control0 + (*channel * DMAChannelRegSize);
+		DMACConfig = DMAC1 + DMACConfiguration;
+	} else {
+		return ERROR_DMA;
+	}
+
+	config = 0;
+
+	__raw_writel(DMACConfiguration_ENABLE, DMACConfig);
+
+	config |= (SourceTransferWidth / 2) << DMAC0Control0_SWIDTHSHIFT; // 4 -> 2, 2 -> 1, 1 -> 0
+	config |= (DestinationTransferWidth / 2) << DMAC0Control0_DWIDTHSHIFT; // 4 -> 2, 2 -> 1, 1 -> 0
+
+	for(x = 0; x < 7; x++) {
+		if((1 << (x + 1)) >= SourceBurstSize) {
+			config |= x << DMAC0Control0_SBSIZESHIFT;
+			break;
+		}
+	}
+	for(x = 0; x < 7; x++) {
+		if((1 << (x + 1)) >= DestinationBurstSize) {
+			config |= x << DMAC0Control0_DBSIZESHIFT;
+			break;
+		}
+	}
+
+	config |= 1 << DMAC0Control0_TERMINALCOUNTINTERRUPTENABLE;
+	config |= 1 << DMAC0Control0_SOURCEAHBMASTERSELECT;
+
+	__raw_writel(config, DMACControl);
+
+	return 0;
+}
+
+dma_addr_t iphone_dma_dstpos(int controller, int channel) {
+	u32 regOffset = channel * DMAChannelRegSize;
+
+	if(controller == 1) {
+		regOffset += DMAC0;
+	} else if(controller == 2) {
+		regOffset += DMAC1;
+	}
+
+	return __raw_readl(regOffset + DMAC0DestAddress);
+}
+
+dma_addr_t iphone_dma_srcpos(int controller, int channel) {
+	u32 regOffset = channel * DMAChannelRegSize;
+
+	if(controller == 1) {
+		regOffset += DMAC0;
+	} else if(controller == 2) {
+		regOffset += DMAC1;
+	}
+
+	return __raw_readl(regOffset + DMAC0SrcAddress);
+}
+
+size_t iphone_dma_continue_list_size(dma_addr_t Source, dma_addr_t Destination, int size, int* controller, int* channel)
+{
+	int transfers;
+	int segments;
+	u32 regControl0;
+	u32 regOffset = (*channel * DMAChannelRegSize);
+
+	if(*controller == 1)
+		regOffset += DMAC0;
+	else if(*controller == 2)
+		regOffset += DMAC1;
+
+	regControl0 = regOffset + DMAC0Control0;
+
+	transfers = size / (1 << DMAC0Control0_DWIDTH(__raw_readl(regControl0)));
+	segments = (transfers + (0xE00 - 1))/0xE00;
+
+	return segments * sizeof(DMALinkedList);
+}
+
+void iphone_dma_create_continue_list(dma_addr_t Source, dma_addr_t Destination, int size, int* controller, int* channel,
+		DMALinkedList** continueList, dma_addr_t* phys, size_t* list_size, DMALinkedList** last)
+{
+	int transfers;
+	int segments;
+	u32 src;
+	u32 dest;
+	DMALinkedList* list;
+	DMALinkedList* item;
+	dma_addr_t listPhys;
+	dma_addr_t itemPhys;
+	u32 control;
+	u32 width_shift;
+	u32 regControl0;
+	u32 sourceIncrement = 0;
+	u32 destinationIncrement = 0;
+	u32 regOffset = (*channel * DMAChannelRegSize);
+
+	if(*controller == 1)
+		regOffset += DMAC0;
+	else if(*controller == 2)
+		regOffset += DMAC1;
+
+	regControl0 = regOffset + DMAC0Control0;
+
+	control = __raw_readl(regControl0) & ~(DMAC0Control0_SIZEMASK | DMAC0Control0_SOURCEINCREMENT | DMAC0Control0_DESTINATIONINCREMENT | (1 << DMAC0Control0_TERMINALCOUNTINTERRUPTENABLE));
+	width_shift = DMAC0Control0_DWIDTH(__raw_readl(regControl0));
+	transfers = size / (1 << width_shift);
+
+	segments = (transfers + (0xE00 - 1))/0xE00;
+
+	if(*list_size >= (segments * sizeof(DMALinkedList)))
+	{
+		list = *continueList;
+		listPhys = *phys;
+	} else
+	{
+		*list_size = segments * sizeof(DMALinkedList);
+		list = dma_alloc_writecombine(dma_dev, *list_size, &listPhys, GFP_KERNEL);
+		*continueList = list;
+	}
+
+	if(Source <= (sizeof(AddressLookupTable)/sizeof(u32))) {
+		if(Destination <= (sizeof(AddressLookupTable)/sizeof(u32))) {
+			src = AddressLookupTable[Source];
+			dest = AddressLookupTable[Destination];
+		} else {
+			src = AddressLookupTable[Source];
+			dest = Destination;
+			destinationIncrement = 1 << DMAC0Control0_DESTINATIONINCREMENT;
+		}
+	} else {
+		if(Destination <= (sizeof(AddressLookupTable)/sizeof(u32))) {
+			src = Source;
+			dest = AddressLookupTable[Destination];
+			sourceIncrement = 1 << DMAC0Control0_SOURCEINCREMENT;
+		} else {
+			src = Source;
+			dest = Destination;
+			sourceIncrement = 1 << DMAC0Control0_SOURCEINCREMENT;
+			destinationIncrement = 1 << DMAC0Control0_DESTINATIONINCREMENT;
+		}
+	}
+
+	item = list;
+	itemPhys = listPhys;
+
+	while(transfers > 0)
+	{
+		unsigned int curTransfer = (transfers > 0xE00) ? 0xE00 : transfers;
+
+		item->control = destinationIncrement | sourceIncrement | control | (curTransfer & DMAC0Control0_SIZEMASK);
+		item->source = src;
+		item->destination = dest;
+		item->next = itemPhys + sizeof(DMALinkedList);
+
+		if(sourceIncrement != 0)
+			src += 0xE00 << width_shift;
+
+		if(destinationIncrement != 0)
+			dest += 0xE00 << width_shift;
+
+		transfers -= curTransfer;
+		itemPhys = item->next;
+		++item;
+	}
+
+	--item;
+	item->control |= 1 << DMAC0Control0_TERMINALCOUNTINTERRUPTENABLE;
+	item->next = 0;
+
+	if(last)
+		*last = item;
+
+	*phys = listPhys;
+	return;
+}
+
+int iphone_dma_prepare(dma_addr_t Source, dma_addr_t Destination, int size, DMALinkedList* continueList, int* controller, int* channel)
+{
+	u32 regSrcAddress;
+	u32 regDestAddress;
+	u32 regLLI;
+	u32 regControl0;
+	u32 regConfiguration;
+	DMALinkedList* list = NULL;
+	dma_addr_t listPhys = 0;
+	size_t listSize = 0;
+	u32 sourcePeripheral = 0;
+	u32 destPeripheral = 0;
+	u32 flowControl = 0;
+	u32 regOffset = (*channel * DMAChannelRegSize);
+
+	if(*controller == 1)
+		regOffset += DMAC0;
+	else if(*controller == 2)
+		regOffset += DMAC1;
+
+	regSrcAddress = regOffset + DMAC0SrcAddress;
+	regDestAddress = regOffset + DMAC0DestAddress;
+	regLLI = regOffset + DMAC0LLI;
+	regControl0 = regOffset + DMAC0Control0;
+	regConfiguration = regOffset + DMAC0Configuration;
+
+	if(DMALists[*controller - 1][*channel])
+	{
+		dma_free_writecombine(dma_dev, DMAListsSize[*controller -  1][*channel], DMALists[*controller - 1][*channel], DMAListsPhys[*controller - 1][*channel]);
+		DMALists[*controller - 1][*channel] = NULL;
+	}
+
+	if(!continueList)
+	{
+		iphone_dma_create_continue_list(Source, Destination, size, controller, channel, &list, &listPhys, &listSize, NULL);
+
+		DMALists[*controller - 1][*channel] = list;
+		DMAListsPhys[*controller - 1][*channel] = listPhys;
+		DMAListsSize[*controller - 1][*channel] = listSize;
+
+		continueList = list;
+	}
+
+	if(Source <= (sizeof(AddressLookupTable)/sizeof(u32))) {
+		if(Destination <= (sizeof(AddressLookupTable)/sizeof(u32))) {
+			sourcePeripheral = PeripheralLookupTable[Source][*controller - 1];
+			destPeripheral = PeripheralLookupTable[Destination][*controller - 1];
+			flowControl =  DMAC0Configuration_FLOWCNTRL_P2P;
+		} else {
+			sourcePeripheral = PeripheralLookupTable[Source][*controller - 1];
+			destPeripheral = PeripheralLookupTable[IPHONE_DMA_MEMORY][*controller - 1];
+			flowControl =  DMAC0Configuration_FLOWCNTRL_P2M;
+		}
+	} else {
+		if(Destination <= (sizeof(AddressLookupTable)/sizeof(u32))) {
+			sourcePeripheral = PeripheralLookupTable[IPHONE_DMA_MEMORY][*controller - 1];
+			destPeripheral = PeripheralLookupTable[Destination][*controller - 1];
+			flowControl =  DMAC0Configuration_FLOWCNTRL_M2P;
+		} else {
+			sourcePeripheral = PeripheralLookupTable[IPHONE_DMA_MEMORY][*controller - 1];
+			destPeripheral = PeripheralLookupTable[IPHONE_DMA_MEMORY][*controller - 1];
+			flowControl =  DMAC0Configuration_FLOWCNTRL_M2M;
+		}
+	}
+
+	__raw_writel(DMAC0Configuration_TERMINALCOUNTINTERRUPTMASK
+			| (flowControl << DMAC0Configuration_FLOWCNTRLSHIFT)
+			| (destPeripheral << DMAC0Configuration_DESTPERIPHERALSHIFT)
+			| (sourcePeripheral << DMAC0Configuration_SRCPERIPHERALSHIFT), regConfiguration);
+
+	__raw_writel(continueList->control, regControl0);
+	__raw_writel(continueList->source, regSrcAddress);
+	__raw_writel(continueList->destination, regDestAddress);
+	__raw_writel(continueList->next, regLLI);
+
+	return 0;
+}
+
+int iphone_dma_perform(dma_addr_t Source, dma_addr_t Destination, int size, DMALinkedList* continueList, int* controller, int* channel) {
+	int ret;
+
+	ret = iphone_dma_prepare(Source, Destination, size, continueList, controller, channel);
+
+	if(ret != 0)
+		return ret;
+
+	iphone_dma_resume(*controller, *channel);
+	return 0;
+}
+
+void iphone_dma_pause(int controller, int channel) {
+	u32 regOffset = channel * DMAChannelRegSize;
+
+	if(controller == 1) {
+		regOffset += DMAC0;
+	} else if(controller == 2) {
+		regOffset += DMAC1;
+	}
+
+	__raw_writel(__raw_readl(regOffset + DMAC0Configuration) & ~DMAC0Configuration_CHANNELENABLED,
+			regOffset + DMAC0Configuration);
+}
+
+void iphone_dma_resume(int controller, int channel) {
+	u32 regOffset = channel * DMAChannelRegSize;
+
+	if(controller == 1) {
+		regOffset += DMAC0;
+	} else if(controller == 2) {
+		regOffset += DMAC1;
+	}
+
+	__raw_writel(__raw_readl(regOffset + DMAC0Configuration) | DMAC0Configuration_CHANNELENABLED,
+			regOffset + DMAC0Configuration);
+}
+
+int iphone_dma_finish(int controller, int channel, int timeout) {
+	unsigned long flags;
+	int ret = 0;
+	unsigned long timeout_jiffies;
+
+	timeout_jiffies = msecs_to_jiffies(timeout) + 1;
+		requests[controller - 1][channel].task = current;
+
+	set_current_state(TASK_INTERRUPTIBLE);
+	if(!requests[controller - 1][channel].done)
+		timeout_jiffies = schedule_timeout(timeout_jiffies);
+	set_current_state(TASK_RUNNING);
+
+	if(!requests[controller - 1][channel].done)
+		ret = -1;
+
+	requests[controller - 1][channel].started = false;
+	requests[controller - 1][channel].done = false;
+	requests[controller - 1][channel].task = NULL;
+
+	spin_lock_irqsave(&freeChannelsLock, flags);
+	if(controller == 1)
+		Controller0FreeChannels[channel] = 0;
+	else if(controller == 2)
+		Controller1FreeChannels[channel] = 0;
+	spin_unlock_irqrestore(&freeChannelsLock, flags);
+
+	return ret;
+}
+
+static void dispatchRequest(volatile DMARequest *request) {
+	// TODO: Implement this
+	request->done = true;
+
+	if(request->task)
+	{
+		wake_up_process(request->task);
+	}
+
+	if(request->done_handler)
+	{
+		request->done_handler(request->controller, request->channel, request->token);
+}
+}
+
+static u64 iphone_dma_dmamask = DMA_BIT_MASK(32);
+
+static int __devinit iphone_dma_probe(struct platform_device *pdev)
+{
+	dma_dev = &pdev->dev;
+	return 0;
+}
+
+static int __devexit iphone_dma_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct resource iphone_dma_resources[] = {
+	[0] = {
+		.start  = DMAC0_PA,
+		.end    = DMAC0_PA + 0x1000 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = DMAC1_PA,
+		.end    = DMAC1_PA + 0x1000 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[2] = {
+		.start  = DMAC0_INTERRUPT,
+		.end    = DMAC1_INTERRUPT,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device iphone_dma = {
+	.name           = "iphone-dma",
+	.id             = -1,
+	.num_resources  = ARRAY_SIZE(iphone_dma_resources),
+	.resource       = iphone_dma_resources,
+	.dev		= {
+		.dma_mask		= &iphone_dma_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32)
+	}
+};
+
+static struct platform_driver iphone_dma_driver = {
+	.driver         = {
+		.name   = "iphone-dma",
+		.owner  = THIS_MODULE,
+	},
+	.probe          = iphone_dma_probe,
+	.remove         = __devexit_p(iphone_dma_remove),
+	.suspend        = NULL,
+	.resume         = NULL,
+};
+
+static int __init iphone_dma_modinit(void)
+{
+	memset(DMALists, 0, sizeof(DMALists));
+	return platform_driver_register(&iphone_dma_driver);
+}
+
+static void __exit iphone_dma_modexit(void)
+{
+	platform_driver_unregister(&iphone_dma_driver);
+}
+
+module_init(iphone_dma_modinit);
+module_exit(iphone_dma_modexit);
+
+MODULE_DESCRIPTION("iPhone DMA Controller");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/ftl.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/ftl.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/ftl.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/ftl.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,2569 @@
+#include <linux/io.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <ftl/vfl.h>
+#include <ftl/ftl.h>
+#include <mach/iphone-clock.h>
+
+#define LOG printk
+#define LOGDBG(format, ...)
+
+typedef struct FTLCxtLog {
+	u32 usn;					// 0x0
+	u16 wVbn;					// 0x4
+	u16 wLbn;					// 0x6
+	u16* wPageOffsets;				// 0x8
+	u16 pagesUsed;				// 0xC
+	u16 pagesCurrent;				// 0xE
+	u32 isSequential;				// 0x10
+} FTLCxtLog;
+
+typedef struct FTLCxtElement2 {
+	u16 field_0;				// 0x0
+	u16 field_2;				// 0x2
+} FTLCxtElement2;
+
+typedef struct FTLCxt {
+	u32 usnDec;				// 0x0
+	u32 nextblockusn;				// 0x4
+	u16 wNumOfFreeVb;				// 0x8
+	u16 nextFreeIdx;				// 0xA
+	u16 swapCounter;				// 0xC
+	u16 awFreeVb[20];				// 0xE
+	u16 field_36;				// 0x36
+	u32 pages_for_pawMapTable[18];		// 0x38
+	u32 pages_for_pawEraseCounterTable[36];	// 0x80
+	u32 pages_for_wPageOffsets[34];		// 0x110
+	u16* pawMapTable;				// 0x198
+	u16* pawEraseCounterTable;			// 0x19C
+	u16* wPageOffsets;				// 0x1A0
+	FTLCxtLog pLog[18];				// 0x1A4
+	u32 eraseCounterPagesDirty;		// 0x30C
+	u16 unk3;					// 0x310
+	u16 FTLCtrlBlock[3];			// 0x312
+	u32 FTLCtrlPage;				// 0x318
+	u32 clean;					// 0x31C
+	u32 pages_for_pawReadCounterTable[36];	// 0x320
+	u16* pawReadCounterTable;			// 0x3B0
+	FTLCxtElement2 elements2[5];			// 0x3B4
+	u32 field_3C8;				// 0x3C8
+	u32 totalReadCount;			// 0x3CC
+	u32 page_for_FTLCountsTable;		// 0x3D0
+	u32 hasFTLCountsTable;			// 0x3D4, set to -1 if yes
+	u8 field_3D8[0x420];			// 0x3D8
+	u32 versionLower;				// 0x7F8
+	u32 versionUpper;				// 0x7FC
+} FTLCxt;
+
+typedef struct FTLCountsTableType {
+	u64 totalPagesWritten;		// 0x0
+	u64 totalPagesRead;		// 0x8
+	u64 totalWrites;			// 0x10
+	u64 totalReads;			// 0x18
+	u64 compactScatteredCount;		// 0x20
+	u64 copyMergeWhileFullCount;	// 0x28
+	u64 copyMergeWhileNotFullCount;	// 0x30
+	u64 simpleMergeCount;		// 0x38
+	u64 blockSwapCount;		// 0x40
+	u64 ftlRestoresCount;		// 0x48
+	u64 field_50;
+} FTLCountsTableType;
+
+typedef enum FTLStruct {
+	FTLCountsTableSID = 0x1000200
+} FTLStruct;
+
+typedef enum VFLStruct {
+	VFLData1SID = 0x2000200,
+	VFLData5SID = 0x2000500
+} VFLStruct;
+
+#define FTL_ID_V1 0x43303033
+#define FTL_ID_V2 0x43303034
+#define FTL_ID_V3 0x43303035
+
+// Shared counters
+
+VFLData1Type VFLData1;
+static uint8_t VFLData5[0xF8];
+
+#ifdef FTL_PROFILE
+u64 TotalWriteTime;
+u64 TotalSyncTime;
+extern u64 Time_wait_for_ecc_interrupt;
+extern u64 Time_wait_for_ready;
+extern u64 Time_wait_for_address_done;
+extern u64 Time_wait_for_command_done;
+extern u64 Time_wait_for_transfer_done;
+extern u64 Time_wait_for_nand_bank_ready;
+extern u64 Time_nand_write;
+extern u64 Time_iphone_dma_finish;
+#endif
+
+// Global Buffers
+
+extern NANDData* NANDGeometry;
+extern NANDFTLData* FTLData;
+
+static u8* PageBuffer;
+static SpareData* FTLSpareBuffer;
+
+static FTLCountsTableType FTLCountsTable;
+static FTLCxt* pstFTLCxt;
+static FTLCxt* FTLCxtBuffer;
+static u32* ScatteredVirtualPageNumberBuffer;
+static bool CleanFreeVb;
+
+// Synchronization
+
+static DEFINE_MUTEX(ftl_mutex);
+
+// Prototypes
+
+static bool ftl_merge(FTLCxtLog* pLog);
+static bool ftl_open_read_counter_tables(void);
+
+static int FTL_Init(void) {
+	int i;
+	memset(&FTLCountsTable, 0, 0x58);
+
+	PageBuffer = (u8*) kmalloc(NANDGeometry->bytesPerPage, GFP_KERNEL | GFP_DMA);
+	pstFTLCxt = FTLCxtBuffer = (FTLCxt*) kmalloc(sizeof(FTLCxt), GFP_KERNEL | GFP_DMA);
+	if(pstFTLCxt == NULL)
+		return -1;
+	memset(pstFTLCxt->field_3D8, 0, sizeof(pstFTLCxt->field_3D8));
+
+	pstFTLCxt->eraseCounterPagesDirty = 0;
+
+	pstFTLCxt->pawMapTable = (u16*) kmalloc(NANDGeometry->userSuBlksTotal * sizeof(u16), GFP_KERNEL);
+	pstFTLCxt->wPageOffsets = (u16*) kmalloc((NANDGeometry->pagesPerSuBlk * 18) * sizeof(u16), GFP_KERNEL);
+	pstFTLCxt->pawEraseCounterTable = (u16*) kmalloc((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16), GFP_KERNEL);
+	pstFTLCxt->pawReadCounterTable = (u16*) kmalloc((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16), GFP_KERNEL);
+
+	FTLSpareBuffer = (SpareData*) kmalloc(NANDGeometry->pagesPerSuBlk * sizeof(SpareData), GFP_KERNEL | GFP_DMA);
+
+	ScatteredVirtualPageNumberBuffer = (u32*) kmalloc(NANDGeometry->pagesPerSuBlk * sizeof(u32*), GFP_KERNEL);
+
+	if(!pstFTLCxt->pawMapTable || !pstFTLCxt->wPageOffsets || !pstFTLCxt->pawEraseCounterTable || !FTLCxtBuffer->pawReadCounterTable || ! FTLSpareBuffer || !ScatteredVirtualPageNumberBuffer)
+		return -1;
+
+	for(i = 0; i < 18; i++) {
+		pstFTLCxt->pLog[i].wPageOffsets = pstFTLCxt->wPageOffsets + (i * NANDGeometry->pagesPerSuBlk);
+		memset(pstFTLCxt->pLog[i].wPageOffsets, 0xFF, NANDGeometry->pagesPerSuBlk * 2);
+		pstFTLCxt->pLog[i].isSequential = 1;
+		pstFTLCxt->pLog[i].pagesUsed = 0;
+		pstFTLCxt->pLog[i].pagesCurrent = 0;
+	}
+
+	return 0;
+}
+
+static void FTL_64bit_sum(u64* src, u64* dest, int size) {
+	int i;
+	for(i = 0; i < size / sizeof(u64); i++) {
+		dest[i] += src[i];
+	}
+}
+
+static bool ftl_set_free_vb(u16 block)
+{
+	// get to the end of the ring buffer
+	int nextFreeVb = (pstFTLCxt->nextFreeIdx + pstFTLCxt->wNumOfFreeVb) % 20;
+	++pstFTLCxt->wNumOfFreeVb;
+
+	++pstFTLCxt->pawEraseCounterTable[block];
+	pstFTLCxt->pawReadCounterTable[block] = 0;
+
+	if(VFL_Erase(block) != 0)
+	{
+		LOG("ftl: failed to release a virtual block from the pool\n");
+		return false;
+	}
+
+	pstFTLCxt->awFreeVb[nextFreeVb] = block;
+
+	return true;
+}
+
+static bool ftl_get_free_vb(u16* block)
+{
+	int i;
+
+	int chosenVbIdx = 20;
+	int curFreeIdx = pstFTLCxt->nextFreeIdx;
+	u16 smallestEC = 0xFFFF;
+	u16 chosenVb;
+
+	for(i = 0; i < pstFTLCxt->wNumOfFreeVb; ++i)
+	{
+		if(pstFTLCxt->awFreeVb[curFreeIdx] != 0xFFFF)
+		{
+			if(pstFTLCxt->pawEraseCounterTable[pstFTLCxt->awFreeVb[curFreeIdx]] < smallestEC)
+			{
+				smallestEC = pstFTLCxt->pawEraseCounterTable[pstFTLCxt->awFreeVb[curFreeIdx]];
+				chosenVbIdx = curFreeIdx;
+			}
+		}
+		curFreeIdx = (curFreeIdx + 1) % 20;
+	}
+
+	if(chosenVbIdx > 19)
+	{
+		LOG("ftl: could not find a free vb!\n");
+		return false;
+	}
+
+	chosenVb = pstFTLCxt->awFreeVb[chosenVbIdx];
+
+	if(chosenVbIdx != pstFTLCxt->nextFreeIdx)
+	{
+		// swap
+		pstFTLCxt->awFreeVb[chosenVbIdx] = pstFTLCxt->awFreeVb[pstFTLCxt->nextFreeIdx];
+		pstFTLCxt->awFreeVb[pstFTLCxt->nextFreeIdx] = chosenVb;
+	}
+
+	if(chosenVb > (NANDGeometry->userSuBlksTotal + 23))
+	{
+		LOG("ftl: invalid free vb\n");
+		return false;
+	}
+
+	--pstFTLCxt->wNumOfFreeVb;
+	if(pstFTLCxt->wNumOfFreeVb > 19)
+	{
+		LOG("ftl: invalid freeVbn\n");
+		return false;
+	}
+
+	if(pstFTLCxt->nextFreeIdx > 19)
+	{
+		LOG("ftl: invalid vbListTail\n");
+		return false;
+	}
+
+	// increment cursor
+	pstFTLCxt->nextFreeIdx = (pstFTLCxt->nextFreeIdx + 1) % 20;
+
+	*block = chosenVb;
+	return true;
+}
+
+static bool ftl_next_ctrl_page(void)
+{
+	int i;
+	int blockIdx;
+
+	++pstFTLCxt->FTLCtrlPage;
+	if((pstFTLCxt->FTLCtrlPage % NANDGeometry->pagesPerSuBlk) != 0)
+	{
+		--pstFTLCxt->usnDec;
+		return true;
+	}
+
+	// find old block to swap out
+
+	for(i = 0; i < 3; ++i)
+	{
+		if(((pstFTLCxt->FTLCtrlBlock[i] + 1) * NANDGeometry->pagesPerSuBlk) == pstFTLCxt->FTLCtrlPage)
+			break;
+	}
+
+	blockIdx = (i + 1) % 3;
+
+	if((pstFTLCxt->eraseCounterPagesDirty % 30) > 2)
+	{
+		LOG("ftl: reusing ctrl block at: %d\n", pstFTLCxt->FTLCtrlBlock[blockIdx]);
+
+		++pstFTLCxt->eraseCounterPagesDirty;
+		++pstFTLCxt->pawEraseCounterTable[pstFTLCxt->FTLCtrlBlock[blockIdx]];
+		++pstFTLCxt->pawReadCounterTable[pstFTLCxt->FTLCtrlBlock[blockIdx]];
+		if(VFL_Erase(pstFTLCxt->FTLCtrlBlock[blockIdx]) != 0)
+		{
+			LOG("ftl: next_ctrl_page failed to erase and markEC(0x%X)\n", pstFTLCxt->FTLCtrlBlock[blockIdx]);
+			return false;
+		}
+
+		pstFTLCxt->FTLCtrlPage = pstFTLCxt->FTLCtrlBlock[blockIdx] * NANDGeometry->pagesPerSuBlk;
+		--pstFTLCxt->usnDec;
+
+		return true;
+	} else
+	{
+		u16 newBlock;
+		u16 oldBlock;
+
+		++pstFTLCxt->eraseCounterPagesDirty;
+
+		if(!ftl_get_free_vb(&newBlock))
+		{
+			LOG("ftl: next_ctrl_page failed to get free VB\n");
+			return false;
+		}
+
+		LOG("ftl: allocated new ctrl block at: %d\n", newBlock);
+
+		oldBlock = pstFTLCxt->FTLCtrlBlock[blockIdx];
+
+		pstFTLCxt->FTLCtrlBlock[blockIdx] = newBlock;
+		pstFTLCxt->FTLCtrlPage = newBlock * NANDGeometry->pagesPerSuBlk;
+
+		if(!ftl_set_free_vb(oldBlock))
+		{
+			LOG("ftl: next_ctrl_page failed to set free VB\n");
+			return false;
+		}
+
+
+		if(VFL_StoreFTLCtrlBlock(pstFTLCxt->FTLCtrlBlock) == 0)
+		{
+			--pstFTLCxt->usnDec;
+			return true;
+		} else
+		{
+			LOG("ftl: next_ctrl_page failed to store FTLCtrlBlock info in VFL\n");
+			return false;
+		}
+	}
+}
+
+// Return whether the block is sequential and also the highest USN of pages
+// found in that block. Assumption: for any pages p_i, p_j in a block where
+// i < j, usn(p_i) <= usn(p_j)
+static bool determine_block_type(u16 block, u32* highest_usn)
+{
+	bool isSequential = true;
+	u8* pageBuffer = (u8*) kmalloc(NANDGeometry->bytesPerPage, GFP_KERNEL | GFP_DMA);
+	SpareData* spareData = (SpareData*) kmalloc(NANDGeometry->bytesPerSpare, GFP_KERNEL | GFP_DMA);
+
+	u32 max = 0;
+	int page;
+	for(page = NANDGeometry->pagesPerSuBlk - 1; page >= 0; --page)
+	{
+		int ret = VFL_Read(block * NANDGeometry->pagesPerSuBlk + page, pageBuffer, (u8*) spareData, true);
+		if(ret != 0)
+			continue;
+
+		if(spareData->user.usn > max)
+			max = spareData->user.usn;
+
+		if((spareData->user.logicalPageNumber % NANDGeometry->pagesPerSuBlk) != page)
+			isSequential = false;
+	}
+
+	kfree(spareData);
+	kfree(pageBuffer);
+
+	*highest_usn = max;
+
+	return isSequential;
+}
+
+// Assumptions: same conditions that FTL_Open would have been called in.
+static bool FTL_Restore(void)
+{
+	u16* blockMap = (u16*) kmalloc((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16), GFP_KERNEL);
+	u8* isEmpty = (u8*) kmalloc((NANDGeometry->userSuBlksTotal + 23) * sizeof(u8), GFP_KERNEL);
+	u8* nonSequential = (u8*) kmalloc((NANDGeometry->userSuBlksTotal + 23) * sizeof(u8), GFP_KERNEL);
+	u32* usnA = (u32*) kmalloc(sizeof(u32) * NANDGeometry->pagesPerSuBlk, GFP_KERNEL);
+	u32* usnB = (u32*) kmalloc(sizeof(u32) * NANDGeometry->pagesPerSuBlk, GFP_KERNEL);
+	u32* lpnA = (u32*) kmalloc(sizeof(u32) * NANDGeometry->pagesPerSuBlk, GFP_KERNEL);
+	u32* lpnB = (u32*) kmalloc(sizeof(u32) * NANDGeometry->pagesPerSuBlk, GFP_KERNEL);
+
+	u16* awFreeVb = &pstFTLCxt->awFreeVb[0];
+	u16* pawMapTable = pstFTLCxt->pawMapTable;
+	u16* pawEraseCounterTable = pstFTLCxt->pawEraseCounterTable;
+	void* pawReadCounterTable = pstFTLCxt->pawReadCounterTable;
+	u16* wPageOffsets = pstFTLCxt->wPageOffsets;
+	FTLCxtLog* pLog = &pstFTLCxt->pLog[0];
+
+	int i;
+	int block;
+	void* FTLCtrlBlock;
+	u32 ftlCtrlBlock;
+	u32 minUsnDec;
+	int ftlCxtFound;
+	int page;
+	u32 highest_usn;
+	int numLogs;
+
+	LOG("ftl: restore searching for latest FTL context...\n");
+
+	// Step 0, find and load the last readable FTLCxt, so we can have a base erase counter data and
+	// goodies. It is not really mandatory though; we could just make a new one.
+
+	if((FTLCtrlBlock = VFL_GetFTLCtrlBlock()) == NULL)
+	{
+		LOG("ftl: restore could not get FTL control blocks from VFL!\n");
+		goto error_release;
+	}
+
+	memcpy(pstFTLCxt->FTLCtrlBlock, FTLCtrlBlock, sizeof(pstFTLCxt->FTLCtrlBlock));
+
+	ftlCtrlBlock = 0xffff;
+	minUsnDec = 0xffffffff;
+	ftlCxtFound = false;
+	for(i = 0; i < sizeof(pstFTLCxt->FTLCtrlBlock)/sizeof(u16); ++i)
+	{
+		u32 blockUSNDec;
+
+		// read the first page of the block
+		int ret = VFL_Read(NANDGeometry->pagesPerSuBlk * pstFTLCxt->FTLCtrlBlock[i], PageBuffer, (u8*) FTLSpareBuffer, true);
+		if(ret != 0)
+			continue;	// this block errored out!
+
+		// 0x43 is the lowest type of FTL control data. Apparently 0x4F would be the highest type.
+		if((FTLSpareBuffer->type1 - 0x43) > 0xC)
+			continue;	// this block doesn't have FTL data in it! Try the next one
+
+		if(ftlCtrlBlock != 0xffff && FTLSpareBuffer->meta.usnDec >= minUsnDec)
+			continue;	// we've seen a newer FTLCxtBlock before
+
+		// this is the latest so far
+		ftlCtrlBlock = pstFTLCxt->FTLCtrlBlock[i];
+
+		blockUSNDec = FTLSpareBuffer->meta.usnDec;
+
+		for(page = NANDGeometry->pagesPerSuBlk - 1; page > 0; page--)
+		{
+			ret = VFL_Read(NANDGeometry->pagesPerSuBlk * ftlCtrlBlock + page, PageBuffer, (u8*) FTLSpareBuffer, true);
+			if(ret == 1) {
+				continue;
+			} else if(ret == 0 && FTLSpareBuffer->type1 == 0x43) { // 43 is FTLCxtBlock
+				minUsnDec = blockUSNDec;
+				memcpy(pstFTLCxt, PageBuffer, sizeof(FTLCxt));
+
+				// we just overwrote our good FTLCtrlBlock info, fill it in again.
+				memcpy(pstFTLCxt->FTLCtrlBlock, FTLCtrlBlock, sizeof(pstFTLCxt->FTLCtrlBlock));
+				ftlCxtFound = true;
+				break;
+			}
+		}
+	}
+
+	if(!ftlCxtFound)
+	{
+		LOG("ftl: restore could not find ANY FTL contexts!\n");
+		goto error_release;
+	}
+
+	LOG("ftl: restore found useable FTL context with usnDec = 0x%x\n", pstFTLCxt->usnDec);
+
+	// Reset the pointers
+	pstFTLCxt->pawMapTable = pawMapTable;
+	pstFTLCxt->pawEraseCounterTable = pawEraseCounterTable;
+	pstFTLCxt->pawReadCounterTable = pawReadCounterTable;
+	pstFTLCxt->wPageOffsets = wPageOffsets;
+
+	// Clean out now almost certainly invalid values
+
+	memset(&FTLCountsTable, 0, 0x58);
+
+	pstFTLCxt->clean = 0;
+
+	for(i = 0; i < 18; ++i)
+	{
+		pLog[i].wPageOffsets = pstFTLCxt->wPageOffsets + (i * NANDGeometry->pagesPerSuBlk);
+		memset(pLog[i].wPageOffsets, 0xFF, NANDGeometry->pagesPerSuBlk * sizeof(u16));
+		pLog[i].isSequential = 1;
+		pLog[i].pagesUsed = 0;
+		pLog[i].pagesCurrent = 0;
+		pLog[i].wVbn = 0xFFFF;
+	}
+
+	for(i = 0; i < 20; ++i)
+		awFreeVb[i] = 0xFFFF;
+
+	pstFTLCxt->nextFreeIdx = 0;
+	pstFTLCxt->wNumOfFreeVb = 0;
+
+	// Read back the counter tables... those are still useful.
+	if(!ftl_open_read_counter_tables())
+	{
+		LOG("ftl: restore could not read back the counter tables from the FTL context!\n");
+		goto error_release;
+	}
+
+	++FTLCountsTable.ftlRestoresCount;
+
+	// next time we commit, do it on a fresh block
+	block = pstFTLCxt->FTLCtrlPage / NANDGeometry->pagesPerSuBlk;
+	pstFTLCxt->FTLCtrlPage = (block * NANDGeometry->pagesPerSuBlk) + NANDGeometry->pagesPerSuBlk - 1;
+
+	numLogs = 0;
+
+	// Step one, create an overview of which virtual blocks have pages belonging to which logical blocks.
+	// Mark any blocks discovered to be empty. Also to save time in the next step, if a block is proven
+	// to be non-sequential, mark it as such.
+
+	for(block = 0; block < (NANDGeometry->userSuBlksTotal + 23); ++block)
+	{
+		if((block % 1000) == 0)
+		{
+			LOG("ftl: restore scanning virtual blocks %d - %d\n", block,
+					block + ((((NANDGeometry->userSuBlksTotal + 23) - block) > 1000) ? 999 : ((NANDGeometry->userSuBlksTotal + 23) - block - 1)));
+		}
+
+		blockMap[block] = 0xFFFF;
+		isEmpty[block] = 1;
+		nonSequential[block] = 0;
+
+		for(page = 0; page < NANDGeometry->pagesPerSuBlk; ++page)
+		{
+			int ret = VFL_Read(block * NANDGeometry->pagesPerSuBlk + page, PageBuffer, (u8*) FTLSpareBuffer, true);
+
+			if(ret == ERROR_EMPTYBLOCK)
+				continue;
+
+			isEmpty[block] = 0;
+
+			if(ret != 0)
+				continue;
+
+			if(FTLSpareBuffer->type1 >= 0x43 && FTLSpareBuffer->type1 <= 0x4F)
+				break;
+
+			// wtf is this? well, we'll just count it as empty
+			if(FTLSpareBuffer->type1 != 0x40 && FTLSpareBuffer->type1 != 0x41)
+				continue;
+
+			if((FTLSpareBuffer->user.logicalPageNumber % NANDGeometry->pagesPerSuBlk) != page)
+				nonSequential[block] = 1;
+
+			blockMap[block] = FTLSpareBuffer->user.logicalPageNumber / NANDGeometry->pagesPerSuBlk;
+			break;
+		}
+	}
+
+	// Step two, make sure each logical block has a mapping to virtual block. If more than one virtual
+	// block contain pages to a logical block, pick which one is a mapping block and which one is a
+	// log block based on whether the entries are sequential and which ones have the highest USN. If
+	// no virtual block for a logical block is found, then it must have been empty so we select an
+	// empty block to use as its virtual block.
+
+	LOG("ftl: restore creating mapping table...\n");
+
+	for(block = 0; block < NANDGeometry->userSuBlksTotal; ++block)
+	{
+		u16 mapCandidate = 0xFFFF;
+		u32 mapCandidateUSN = 0xFFFFFFFF;
+		u16 logCandidate = 0xFFFF;
+		u32 logCandidateUSN = 0xFFFFFFFF;
+		u16 candidate;
+
+		if((block % 1000) == 0)
+		{
+			LOG("ftl: restore scanning logical blocks %d - %d\r\n", block,
+					block + (((NANDGeometry->userSuBlksTotal - block) > 1000) ? 999 : (NANDGeometry->userSuBlksTotal - block - 1)));
+		}
+
+		for(candidate = 0; candidate < (NANDGeometry->userSuBlksTotal + 23); ++candidate)
+		{
+			u32 candidateUSN;
+			bool origMCSeq;
+			bool newMCSeq;
+			u16 newLCandidate;
+			u32 newLCandidateUSN;
+
+			if(blockMap[candidate] != block)
+				continue;
+
+			if(nonSequential[candidate])
+			{
+				if(logCandidate == 0xFFFF)
+				{
+					logCandidate = candidate;
+					continue;
+				}
+				if(logCandidateUSN == 0xFFFFFFFF)
+					determine_block_type(logCandidate, &logCandidateUSN);
+
+				determine_block_type(candidate, &candidateUSN);
+
+				if(logCandidateUSN < candidateUSN)
+				{
+					logCandidate = candidate;
+					logCandidateUSN = candidateUSN;
+				}
+			} else if(mapCandidate == 0xFFFF)
+			{
+				mapCandidate = candidate;
+				continue;
+			}
+
+			origMCSeq = true;
+			if(mapCandidateUSN == 0xFFFFFFFF)
+				origMCSeq = determine_block_type(mapCandidate, &mapCandidateUSN);
+
+			newMCSeq = determine_block_type(candidate, &candidateUSN);
+
+			if(origMCSeq && newMCSeq)
+			{
+				if(mapCandidateUSN > candidateUSN)
+				{
+					newLCandidate = candidate;
+					newLCandidateUSN = candidateUSN;
+				} else
+				{
+					newLCandidate = mapCandidate;
+					newLCandidateUSN = mapCandidateUSN;
+					mapCandidate = candidate;
+					mapCandidateUSN = candidateUSN;
+				}
+			} else if(origMCSeq && !newMCSeq)
+			{
+				newLCandidate = candidate;
+				newLCandidateUSN = candidateUSN;
+			} else if(!origMCSeq && newMCSeq)
+			{
+				newLCandidate = mapCandidate;
+				newLCandidateUSN = mapCandidateUSN;
+				mapCandidate = candidate;
+				mapCandidateUSN = candidateUSN;
+			} else
+			{
+				// neither is sequential! Then we'll unset the map candidate and decide
+				// the newest one to be the potential new log candidate.
+				if(mapCandidateUSN > candidateUSN)
+				{
+					newLCandidate = mapCandidate;
+					newLCandidateUSN = mapCandidateUSN;
+				} else
+				{
+					newLCandidate = candidate;
+					newLCandidateUSN = candidateUSN;
+				}
+				mapCandidate = 0xFFFF;
+				mapCandidateUSN = 0xFFFFFFFF;
+			}
+
+			if(logCandidate == 0xFFFF)
+			{
+				logCandidate = newLCandidate;
+				logCandidateUSN = newLCandidateUSN;
+				continue;
+			}
+
+			if(logCandidateUSN == 0xFFFFFFFF)
+				determine_block_type(logCandidate, &logCandidateUSN);
+
+			if(logCandidateUSN < newLCandidateUSN)
+			{
+				logCandidate = newLCandidate;
+				logCandidateUSN = newLCandidateUSN;
+			}
+		}
+
+		if(mapCandidate == 0xFFFF)
+		{
+			for(candidate = 0; candidate < (NANDGeometry->userSuBlksTotal + 23); ++candidate)
+			{
+				if(isEmpty[candidate])
+				{
+					mapCandidate = candidate;
+					isEmpty[candidate] = 0;
+					break;
+				}
+			}
+
+			if(mapCandidate == 0xFFFF)
+			{
+				LOG("ftl: restore failed, didn't find enough empty blocks to pair with orphan logical blocks.\n");
+				goto error_release;
+			}
+		}
+
+		pawMapTable[block] = mapCandidate;
+		blockMap[mapCandidate] = 0;
+
+		if(logCandidate != 0xFFFF)
+		{
+			pLog[numLogs].wLbn = block;
+			pLog[numLogs].wVbn = logCandidate;
+			++numLogs;
+
+			blockMap[logCandidate] = 0;
+		}
+	}
+
+	// Step three
+	// At this point, pawMapTable ought to be correct. We can also assert that all blocks that were originally
+	// either in pawMapTable or pLog, we have put in pawMapTable or pLog. The rest are either the three control
+	// blocks, or the free vbs. Therefore, we look for blocks that were not marked as pawMapTable or pLog and
+	// also not a control block and mark them as free vbs.
+
+	LOG("ftl: restore determing free vbs...\n");
+
+	for(block = 0; block < (NANDGeometry->userSuBlksTotal + 23); ++block)
+	{
+		if(blockMap[block] == 0)
+			continue;
+
+		for(i = 0; i < 3; ++i)
+		{
+			if(block == pstFTLCxt->FTLCtrlBlock[i])
+				break;
+		}
+
+		if(i < 3)
+			continue;
+
+		awFreeVb[pstFTLCxt->wNumOfFreeVb++] = block;
+	}
+
+	LOG("ftl: restore wNumOfFreeVb = %d, number of log vbs = %d\n",
+			pstFTLCxt->wNumOfFreeVb, numLogs);
+
+	// Now we do a consistency check. The total number of virtual blocks accessible by
+	// our FTL is the number of user superblocks + 3 control blocks + 20 blocks divided
+	// between free blocks and log blocks. It can get down to 3 free blocks and 17 log
+	// blocks (defined by the size of the log block array, and explicitly guarded by
+	// ftl_prepare_log), or up to 20 free blocks and 0 log blocks (there is space for
+	// 20 free vbs). That counts up to the + 23 number you see everywhere. Therefore,
+	// the number of free vbs and the number of log blocks used must equal 20.
+	if((pstFTLCxt->wNumOfFreeVb + numLogs) != 20)
+	{
+		LOG("ftl: restore failed, we are missing pool blocks!\n");
+		goto error_release;
+	}
+
+	// Step four. Now for those blocks that have log entries, we must decide how to
+	// populate the page offsets table, i.e. divide the logical block between these
+	// two blocks. Assumption: if block L is the log block for block B, pick any
+	// page u from L and v from B -- usn(u) > usn(v). This is because after the
+	// map block is written, any further write to it will hit the log block for it
+	// and increment the USN.
+
+	// This keeps track of the highest USN for all log blocks.
+	highest_usn = 0;
+
+	for(i = 0; i < numLogs; ++i)
+	{
+		// Since we always store the highest USN block as the map in step two
+		// to ensure we always end up with the two highest USN blocks, we
+		// could have the ordering swapped. Figure out the correct one.
+
+		u16 blockA = pawMapTable[pLog[i].wLbn];
+		u16 blockB = pLog[i].wVbn;
+		bool aSequential = true;
+		bool bSequential = true;
+		u32 aHighestUSN = 0;
+		u32 bHighestUSN = 0;
+		u32* mapBlockUSN;
+		u32* mapBlockLPN;
+		u32* logBlockUSN;
+		u32* logBlockLPN;
+
+		// Populate information about these two blocks
+
+		for(page = NANDGeometry->pagesPerSuBlk - 1; page >= 0; --page)
+		{
+			int ret = VFL_Read((blockA * NANDGeometry->pagesPerSuBlk) + page, PageBuffer, (u8*) FTLSpareBuffer, true);
+			if(ret == ERROR_EMPTYBLOCK)
+				usnA[page] = 0;
+			else
+		{
+				usnA[page] = FTLSpareBuffer->user.usn;
+				lpnA[page] = FTLSpareBuffer->user.logicalPageNumber;
+
+				if(usnA[page] > aHighestUSN)
+					aHighestUSN = usnA[page];
+
+				if((FTLSpareBuffer->user.logicalPageNumber % NANDGeometry->pagesPerSuBlk) != page)
+					aSequential = false;
+			}
+		}
+
+		for(page = NANDGeometry->pagesPerSuBlk - 1; page >= 0; --page)
+			{
+			int ret = VFL_Read((blockB * NANDGeometry->pagesPerSuBlk) + page, PageBuffer, (u8*) FTLSpareBuffer, true);
+			if(ret == ERROR_EMPTYBLOCK)
+				usnB[page] = 0;
+			else
+			{
+				usnB[page] = FTLSpareBuffer->user.usn;
+				lpnB[page] = FTLSpareBuffer->user.logicalPageNumber;
+
+				if(usnB[page] > bHighestUSN)
+					bHighestUSN = usnB[page];
+
+				if((FTLSpareBuffer->user.logicalPageNumber % NANDGeometry->pagesPerSuBlk) != page)
+					bSequential = false;
+			}
+		}
+
+		// Determine which is which
+		if((aSequential && bSequential && bHighestUSN > aHighestUSN) || aSequential)
+		{
+			pLog[i].wVbn = blockB;
+			pawMapTable[pLog[i].wLbn] = blockA;
+			mapBlockUSN = usnA;
+			logBlockUSN = usnB;
+			mapBlockLPN = lpnA;
+			logBlockLPN = lpnB;
+			if(bHighestUSN > highest_usn)
+				highest_usn = bHighestUSN;
+		} else if((aSequential && bSequential && bHighestUSN <= aHighestUSN) || bSequential)
+		{
+			pLog[i].wVbn = blockA;
+			pawMapTable[pLog[i].wLbn] = blockB;
+			mapBlockUSN = usnB;
+			logBlockUSN = usnA;
+			mapBlockLPN = lpnB;
+			logBlockLPN = lpnA;
+			if(aHighestUSN > highest_usn)
+				highest_usn = aHighestUSN;
+		} else
+			{
+			LOG("ftl: restore failed, we have two non-sequential blocks!\n");
+				goto error_release;
+			}
+
+		// okay, now we will populate the log block with the correct information.
+
+		for(page = NANDGeometry->pagesPerSuBlk - 1; page >= 0; --page)
+		{
+			int logOffset;
+
+			// check if empty
+			if(logBlockUSN[page] == 0)
+				continue;
+
+			// we set it to after the first non-empty page
+			if(pLog[i].pagesUsed == 0)
+				pLog[i].pagesUsed = page + 1;
+
+			logOffset = logBlockLPN[page] % NANDGeometry->pagesPerSuBlk;
+
+			// is there a newer copy of this page already in this log block?
+			if(pLog[i].wPageOffsets[logOffset] != 0xFFFF)
+				continue;
+
+			// if not, we'll use it since it's the most recent.
+			pLog[i].wPageOffsets[logOffset] = page;
+			++pLog[i].pagesCurrent;
+
+			if(logOffset != page)
+				pLog[i].isSequential = 0;
+		}
+
+		if(pLog[i].pagesUsed != pLog[i].pagesCurrent)
+			pLog[i].isSequential = 0;
+
+		LOG("ftl: restore -- log %d, wLbn = %d, wVbn = %d, pagesUsed = %d, pagesCurrent = %d, isSequential = %d\n",
+				i, pLog[i].wLbn, pLog[i].wVbn, pLog[i].pagesUsed, pLog[i].pagesCurrent, pLog[i].isSequential);
+	}
+
+	pstFTLCxt->nextblockusn = highest_usn + 1;
+
+	for(i = 0; i < numLogs; ++i)
+	{
+		pLog[i].usn = pstFTLCxt->nextblockusn - 1;
+	}
+
+	LOG("ftl: restore successful!\n");
+
+	kfree(usnA);
+	kfree(usnB);
+	kfree(lpnA);
+	kfree(lpnB);
+	kfree(blockMap);
+	kfree(nonSequential);
+	kfree(isEmpty);
+
+	return true;
+
+error_release:
+	kfree(usnA);
+	kfree(usnB);
+	kfree(lpnA);
+	kfree(lpnB);
+	kfree(blockMap);
+	kfree(nonSequential);
+	kfree(isEmpty);
+
+	return false;
+}
+
+static bool FTL_GetStruct(FTLStruct type, void** data, int* size) {
+	switch(type) {
+		case FTLCountsTableSID:
+			*data = &FTLCountsTable;
+			*size = sizeof(FTLCountsTable);
+			return true;
+		default:
+			return false;
+	}
+}
+
+static bool VFL_GetStruct(FTLStruct type, void** data, int* size) {
+	switch(type) {
+		case VFLData1SID:
+			*data = &VFLData1;
+			*size = sizeof(VFLData1);
+			return true;
+		case VFLData5SID:
+			*data = VFLData5;
+			*size = 0xF8;
+			return true;
+		default:
+			return false;
+	}
+}
+
+static bool sum_data(u8* pageBuffer) {
+	void* data;
+	int size;
+	FTL_GetStruct(FTLCountsTableSID, &data, &size);
+	FTL_64bit_sum((u64*)pageBuffer, (u64*)data, size);
+	VFL_GetStruct(VFLData1SID, &data, &size);
+	FTL_64bit_sum((u64*)(pageBuffer + 0x200), (u64*)data, size);
+	VFL_GetStruct(VFLData5SID, &data, &size);
+	FTL_64bit_sum((u64*)(pageBuffer + 0x400), (u64*)data, size);
+	return true;
+}
+
+static bool ftl_open_read_counter_tables(void)
+{
+	int i;
+	int pagesToRead;
+	bool success;
+
+	pagesToRead = ((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) / NANDGeometry->bytesPerPage;
+	if((((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) % NANDGeometry->bytesPerPage) != 0)
+		pagesToRead++;
+
+	success = false;
+
+	for(i = 0; i < pagesToRead; i++) {
+		int toRead;
+		if(VFL_Read(pstFTLCxt->pages_for_pawEraseCounterTable[i], PageBuffer, (u8*) FTLSpareBuffer, true) != 0)
+		{
+			success = false;
+			goto release;
+		}
+
+		toRead = NANDGeometry->bytesPerPage;
+		if(toRead > (((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) - (i * NANDGeometry->bytesPerPage))) {
+			toRead = ((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) - (i * NANDGeometry->bytesPerPage);
+		}
+
+		memcpy(((u8*)pstFTLCxt->pawEraseCounterTable) + (i * NANDGeometry->bytesPerPage), PageBuffer, toRead);
+	}
+
+	LOG("ftl: Detected version %x %x\n", FTLCxtBuffer->versionLower, FTLCxtBuffer->versionUpper);
+	if(FTLCxtBuffer->versionLower == 0x46560001 && FTLCxtBuffer->versionUpper == 0xB9A9FFFE) {
+		pagesToRead = ((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) / NANDGeometry->bytesPerPage;
+		if((((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) % NANDGeometry->bytesPerPage) != 0)
+			pagesToRead++;
+
+		success = true;
+		for(i = 0; i < pagesToRead; i++) {
+			int toRead;
+			if(VFL_Read(pstFTLCxt->pages_for_pawReadCounterTable[i], PageBuffer, (u8*) FTLSpareBuffer, true) != 0) {
+				success = false;
+				break;
+			}
+
+			toRead = NANDGeometry->bytesPerPage;
+			if(toRead > (((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) - (i * NANDGeometry->bytesPerPage))) {
+				toRead = ((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) - (i * NANDGeometry->bytesPerPage);
+			}
+
+			memcpy(((u8*)pstFTLCxt->pawReadCounterTable) + (i * NANDGeometry->bytesPerPage), PageBuffer, toRead);
+		}
+
+		if((pstFTLCxt->hasFTLCountsTable + 1) == 0) {
+			int x = pstFTLCxt->page_for_FTLCountsTable / NANDGeometry->pagesPerSuBlk;
+			if(x == 0 || x <= NANDGeometry->userSuBlksTotal) {
+				if(VFL_Read(pstFTLCxt->page_for_FTLCountsTable, PageBuffer, (u8*) FTLSpareBuffer, true) != 0)
+				{
+					success = false;
+					goto release;
+				}
+
+				sum_data(PageBuffer);
+			}
+		}
+	} else {
+		LOG("ftl: updating the FTL from seemingly compatible version\n");
+		for(i = 0; i < (NANDGeometry->userSuBlksTotal + 23); i++) {
+			pstFTLCxt->pawReadCounterTable[i] = 0x1388;
+		}
+
+		for(i = 0; i < 5; i++) {
+			pstFTLCxt->elements2[i].field_0 = -1;
+			pstFTLCxt->elements2[i].field_2 = -1;
+		}
+
+		pstFTLCxt->field_3C8 = 0;
+		pstFTLCxt->clean = 0;
+		FTLCxtBuffer->versionLower = 0x46560000;
+		FTLCxtBuffer->versionUpper = 0xB9A9FFFF;
+
+		success = true;
+	}
+
+release:
+	return success;
+}
+
+static int FTL_Open(int* pagesAvailable, int* bytesPerPage) {
+	int ret;
+	int i;
+	int pagesToRead;
+
+	u16* pawMapTable = pstFTLCxt->pawMapTable;
+	u16* pawEraseCounterTable = pstFTLCxt->pawEraseCounterTable;
+	void* pawReadCounterTable = pstFTLCxt->pawReadCounterTable;
+	u16* wPageOffsets = pstFTLCxt->wPageOffsets;
+	int ftlCxtFound;
+	u32 ftlCtrlBlock;
+	u32 minUsnDec;
+
+	void* FTLCtrlBlock;
+	if((FTLCtrlBlock = VFL_GetFTLCtrlBlock()) == NULL)
+		goto FTL_Open_Error;
+
+	memcpy(pstFTLCxt->FTLCtrlBlock, FTLCtrlBlock, sizeof(pstFTLCxt->FTLCtrlBlock));
+
+	// First thing is to get the latest FTLCtrlBlock from the FTLCtrlBlock. It will have the lowest spare.usnDec
+	// Again, since a ring buffer is used, the lowest usnDec FTLCxt will be in the FTLCtrlBlock whose first page
+	// has the lowest usnDec
+	ftlCtrlBlock = 0xffff;
+	minUsnDec = 0xffffffff;
+	for(i = 0; i < sizeof(pstFTLCxt->FTLCtrlBlock)/sizeof(u16); i++) {
+		// read the first page of the block
+		ret = VFL_Read(NANDGeometry->pagesPerSuBlk * pstFTLCxt->FTLCtrlBlock[i], PageBuffer, (u8*) FTLSpareBuffer, true);
+		if(ret == -EINVAL) {
+			goto FTL_Open_Error;
+		}
+
+		// 0x43 is the lowest type of FTL control data. Apparently 0x4F would be the highest type.
+		if((FTLSpareBuffer->type1 - 0x43) > 0xC)
+			continue;	// this block doesn't have FTL data in it! Try the next one
+
+		if(ret != 0)
+			continue;	// this block errored out!
+
+		if(ftlCtrlBlock != 0xffff && FTLSpareBuffer->meta.usnDec >= minUsnDec)
+			continue;	// we've seen a newer FTLCxtBlock before
+
+		// this is the latest so far
+		minUsnDec = FTLSpareBuffer->meta.usnDec;
+		ftlCtrlBlock = pstFTLCxt->FTLCtrlBlock[i];
+	}
+
+
+	if(ftlCtrlBlock == 0xffff) {
+		LOG("ftl: Cannot find context!\n");
+		goto FTL_Open_Error_Release;
+	}
+
+	LOG("ftl: Successfully found FTL context block: %d\n", ftlCtrlBlock);
+
+	// The last readable page in this block ought to be a FTLCxt block! If it's any other ftl control page
+	// then the shut down was unclean. FTLCxt ought never be the very first page.
+	ftlCxtFound = false;
+	for(i = NANDGeometry->pagesPerSuBlk - 1; i > 0; i--) {
+		ret = VFL_Read(NANDGeometry->pagesPerSuBlk * ftlCtrlBlock + i, PageBuffer, (u8*) FTLSpareBuffer, true);
+		if(ret == 1) {
+			continue;
+		} else if(ret == 0 && FTLSpareBuffer->type1 == 0x43) { // 43 is FTLCxtBlock
+			memcpy(FTLCxtBuffer, PageBuffer, sizeof(FTLCxt));
+			ftlCxtFound = true;
+			break;
+		} else {
+			if(ret == 0)
+				LOG("ftl: Possible unclean shutdown, last FTL metadata type written was 0x%x\n", FTLSpareBuffer->type1);
+			else
+				LOG("ftl: Error reading FTL context block.\n");
+
+			ftlCxtFound = false;
+			break;
+		}
+	}
+
+	if(!ftlCxtFound)
+		goto FTL_Open_Error_Release;
+
+	LOG("ftl: Successfully read FTL context block. usnDec = 0x%x\n", pstFTLCxt->usnDec);
+
+	// Restore now possibly overwritten (by data from NAND) pointers from backed up copies
+	pstFTLCxt->pawMapTable = pawMapTable;
+	pstFTLCxt->pawEraseCounterTable = pawEraseCounterTable;
+	pstFTLCxt->pawReadCounterTable = pawReadCounterTable;
+	pstFTLCxt->wPageOffsets = wPageOffsets;
+
+	for(i = 0; i < 18; i++) {
+		pstFTLCxt->pLog[i].wPageOffsets = pstFTLCxt->wPageOffsets + (i * NANDGeometry->pagesPerSuBlk);
+	}
+
+	pagesToRead = (NANDGeometry->userSuBlksTotal * sizeof(u16)) / NANDGeometry->bytesPerPage;
+	if(((NANDGeometry->userSuBlksTotal * sizeof(u16)) % NANDGeometry->bytesPerPage) != 0)
+		pagesToRead++;
+
+	for(i = 0; i < pagesToRead; i++) {
+		int toRead;
+		if(VFL_Read(pstFTLCxt->pages_for_pawMapTable[i], PageBuffer, (u8*) FTLSpareBuffer, true) != 0)
+			goto FTL_Open_Error_Release;
+
+		toRead = NANDGeometry->bytesPerPage;
+		if(toRead > ((NANDGeometry->userSuBlksTotal * sizeof(u16)) - (i * NANDGeometry->bytesPerPage))) {
+			toRead = (NANDGeometry->userSuBlksTotal * sizeof(u16)) - (i * NANDGeometry->bytesPerPage);
+		}
+
+		memcpy(((u8*)pstFTLCxt->pawMapTable) + (i * NANDGeometry->bytesPerPage), PageBuffer, toRead);
+	}
+
+	pagesToRead = (NANDGeometry->pagesPerSuBlk * (17 * sizeof(u16))) / NANDGeometry->bytesPerPage;
+	if(((NANDGeometry->pagesPerSuBlk * (17 * sizeof(u16))) % NANDGeometry->bytesPerPage) != 0)
+		pagesToRead++;
+
+	for(i = 0; i < pagesToRead; i++) {
+		int toRead;
+		if(VFL_Read(pstFTLCxt->pages_for_wPageOffsets[i], PageBuffer, (u8*) FTLSpareBuffer, true) != 0)
+			goto FTL_Open_Error_Release;
+
+		toRead = NANDGeometry->bytesPerPage;
+		if(toRead > ((NANDGeometry->pagesPerSuBlk * (17 * sizeof(u16))) - (i * NANDGeometry->bytesPerPage))) {
+			toRead = (NANDGeometry->pagesPerSuBlk * (17 * sizeof(u16))) - (i * NANDGeometry->bytesPerPage);
+		}
+
+		memcpy(((u8*)pstFTLCxt->wPageOffsets) + (i * NANDGeometry->bytesPerPage), PageBuffer, toRead);
+	}
+
+	pagesToRead = ((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) / NANDGeometry->bytesPerPage;
+	if((((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) % NANDGeometry->bytesPerPage) != 0)
+		pagesToRead++;
+
+	for(i = 0; i < pagesToRead; i++) {
+		int toRead;
+		if(VFL_Read(pstFTLCxt->pages_for_pawEraseCounterTable[i], PageBuffer, (u8*) FTLSpareBuffer, true) != 0)
+			goto FTL_Open_Error_Release;
+
+		toRead = NANDGeometry->bytesPerPage;
+		if(toRead > (((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) - (i * NANDGeometry->bytesPerPage))) {
+			toRead = ((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) - (i * NANDGeometry->bytesPerPage);
+		}
+
+		memcpy(((u8*)pstFTLCxt->pawEraseCounterTable) + (i * NANDGeometry->bytesPerPage), PageBuffer, toRead);
+	}
+
+	if(ftl_open_read_counter_tables()) {
+		CleanFreeVb = true;
+		LOG("ftl: FTL successfully opened!\n");
+		*pagesAvailable = NANDGeometry->userPagesTotal;
+		*bytesPerPage = NANDGeometry->bytesPerPage;
+		return 0;
+	}
+
+FTL_Open_Error_Release:
+
+FTL_Open_Error:
+	LOG("ftl: FTL_Open cannot load FTLCxt!\n");
+	CleanFreeVb = false;
+	if(FTL_Restore() != false) {
+		*pagesAvailable = NANDGeometry->userPagesTotal;
+		*bytesPerPage = NANDGeometry->bytesPerPage;
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+}
+
+u32 FTL_map_page(FTLCxtLog* pLog, int lbn, int offset) {
+	if(pLog && pLog->wPageOffsets[offset] != 0xFFFF) {
+		if(((pLog->wVbn * NANDGeometry->pagesPerSuBlk) + pLog->wPageOffsets[offset] + 1) != 0)
+		{
+			return (pLog->wVbn * NANDGeometry->pagesPerSuBlk) + pLog->wPageOffsets[offset];
+		}
+	}
+
+	return (pstFTLCxt->pawMapTable[lbn] * NANDGeometry->pagesPerSuBlk) + offset;
+}
+
+static inline FTLCxtLog* ftl_get_log(u16 lbn)
+{
+	int i;
+	for(i = 0; i < 17; i++) {
+		if(pstFTLCxt->pLog[i].wVbn == 0xFFFF)
+			continue;
+
+		if(pstFTLCxt->pLog[i].wLbn == lbn) {
+			return &pstFTLCxt->pLog[i];
+		}
+	}
+	return NULL;
+}
+
+int FTL_Read_private(u32 logicalPageNumber, int totalPagesToRead, u8* pBuf)
+{
+	int i;
+	int hasError = false;
+	int lbn;
+	int offset;
+	int ret;
+	int pagesRead;
+	int pagesToRead;
+	int currentLogicalPageNumber;
+	FTLCxtLog* pLog;
+
+	FTLCountsTable.totalPagesRead += totalPagesToRead;
+	++FTLCountsTable.totalReads;
+	pstFTLCxt->totalReadCount++;
+
+	if(!pBuf)
+	{
+		return -EINVAL;
+	}
+
+	if(totalPagesToRead == 0 || (logicalPageNumber + totalPagesToRead) > NANDGeometry->userPagesTotal)
+	{
+		LOG("ftl: invalid input parameters\n");
+		return -EINVAL;
+	}
+
+	lbn = logicalPageNumber / NANDGeometry->pagesPerSuBlk;
+	offset = logicalPageNumber - (lbn * NANDGeometry->pagesPerSuBlk);
+
+	pLog = ftl_get_log(lbn);
+
+	ret = 0;
+	pagesRead = 0;
+	currentLogicalPageNumber = logicalPageNumber;
+
+	while(true) {
+		int readSuccessful;
+		int loop;
+
+		// Read as much as we can from the first logical block
+		pagesToRead = NANDGeometry->pagesPerSuBlk - offset;
+		if(pagesToRead >= (totalPagesToRead - pagesRead))
+			pagesToRead = totalPagesToRead - pagesRead;
+
+		if(pLog != NULL) {
+			// we have a scatter entry for this logical block, so we use it
+			for(i = 0; i < pagesToRead; i++) {
+				ScatteredVirtualPageNumberBuffer[i] = FTL_map_page(pLog, lbn, offset + i);
+				if((ScatteredVirtualPageNumberBuffer[i] / NANDGeometry->pagesPerSuBlk) == pLog->wVbn) {
+					// This particular page is mapped within one of the log blocks, so we increment for the log block
+					pstFTLCxt->pawReadCounterTable[ScatteredVirtualPageNumberBuffer[i] / NANDGeometry->pagesPerSuBlk]++;
+				} else {
+					// This particular page is mapped to the main block itself, so we increment for that block
+					pstFTLCxt->pawReadCounterTable[pstFTLCxt->pawMapTable[lbn]]++;
+				}
+			}
+
+			readSuccessful = VFL_ReadScatteredPagesInVb(ScatteredVirtualPageNumberBuffer, pagesToRead, pBuf + (pagesRead * NANDGeometry->bytesPerPage), FTLSpareBuffer);
+		} else {
+			// VFL_ReadMultiplePagesInVb has a different calling convention and implementation than the equivalent iBoot function.
+			// Ours is a bit less optimized, and just calls VFL_Read for each page.
+			pstFTLCxt->pawReadCounterTable[pstFTLCxt->pawMapTable[lbn]] += pagesToRead;
+			readSuccessful = VFL_ReadMultiplePagesInVb(pstFTLCxt->pawMapTable[lbn], offset, pagesToRead, pBuf + (pagesRead * NANDGeometry->bytesPerPage), FTLSpareBuffer);
+		}
+
+		loop = 0;
+		if(readSuccessful) {
+			// check ECC mark for all pages
+			for(i = 0; i < pagesToRead; i++) {
+				if(FTLSpareBuffer[i].eccMark == 0xFF)
+					continue;
+
+				LOG("ftl: CHECK_FTL_ECC_MARK (0x%x, 0x%x, 0x%x, 0x%x)\n", lbn, offset, i, FTLSpareBuffer[i].eccMark);
+				hasError = true;
+			}
+
+			pagesRead += pagesToRead;
+			currentLogicalPageNumber += pagesToRead;
+			offset += pagesToRead;
+
+			if(pagesRead == totalPagesToRead) {
+				goto FTL_Read_Done;
+			}
+
+			loop = false;
+		} else {
+			loop = true;
+		}
+
+		do {
+			if(pagesRead != totalPagesToRead && NANDGeometry->pagesPerSuBlk != offset) {
+				// there's some remaining pages we have not read before. handle them individually
+
+				int virtualPage = FTL_map_page(pLog, lbn, offset);
+				ret = VFL_Read(virtualPage, pBuf + (NANDGeometry->bytesPerPage * pagesRead), (u8*) FTLSpareBuffer, true);
+
+				if(ret == -EINVAL)
+					goto FTL_Read_Error_Release;
+
+				if(ret == -EIO || FTLSpareBuffer->eccMark != 0xFF) {
+					// ecc error
+					LOG("ftl: ECC error, ECC mark is: %x\n", FTLSpareBuffer->eccMark);
+					hasError = true;
+					if(pLog) {
+						virtualPage = FTL_map_page(pLog, lbn, offset);
+						LOG("ftl: lbn 0x%x pLog->wVbn 0x%x pawMapTable 0x%x offset 0x%x vpn 0x%x\n", lbn, pLog->wVbn, pstFTLCxt->pawMapTable[lbn], offset, virtualPage);
+					} else {
+						virtualPage = FTL_map_page(NULL, lbn, offset);
+						LOG("ftl: lbn 0x%x pawMapTable 0x%x offset 0x%x vpn 0x%x\n", lbn, pstFTLCxt->pawMapTable[lbn], offset, virtualPage);
+					}
+				}
+
+				if(ret == 0) {
+					if(FTLSpareBuffer->user.logicalPageNumber != offset) {
+						// that's not the page we expected there
+						LOG("ftl: error, dwWrittenLpn(0x%x) != dwLpn(0x%x)\n", FTLSpareBuffer->user.logicalPageNumber, offset);
+					}
+				}
+
+				pagesRead++;
+				currentLogicalPageNumber++;
+				offset++;
+				if(pagesRead == totalPagesToRead) {
+					goto FTL_Read_Done;
+				}
+			}
+
+			if(offset == NANDGeometry->pagesPerSuBlk) {
+				// go to the next block
+
+				lbn++;
+				if(lbn >= NANDGeometry->userSuBlksTotal)
+					goto FTL_Read_Error_Release;
+
+				pLog = ftl_get_log(lbn);
+
+				offset = 0;
+				break;
+			}
+		} while(loop);
+	}
+
+FTL_Read_Done:
+	if(hasError) {
+		LOG("ftl: USER_DATA_ERROR, failed with (0x%x, 0x%x, %p)\n", logicalPageNumber, totalPagesToRead, pBuf);
+		return -EIO;
+	}
+
+	return 0;
+
+FTL_Read_Error_Release:
+	LOG("ftl: _FTLRead error!\n");
+	return ret;
+}
+
+int FTL_Read(u32 logicalPageNumber, int totalPagesToRead, u8* pBuf)
+{
+	int ret;
+	mutex_lock(&ftl_mutex);
+	ret = FTL_Read_private(logicalPageNumber, totalPagesToRead, pBuf);
+	mutex_unlock(&ftl_mutex);
+	return ret;
+}
+
+static bool ftl_commit_cxt(void)
+{
+	int eraseCounterPages;
+	int readCounterPages;
+	int mapPages;
+	int offsetsPages;
+
+	// TODO: We should use the StoreCxt for this. Not only would we be able to more easily do
+	// multiplanar writes, but if any of this fails, we can back out without changes to our
+	// working context
+
+	int i;
+	int totalPages;
+	int pagesToWrite;
+
+	u16 curBlock;
+
+	// We need to precalculate how many pages we'd need to write to determine if we should start a new block.
+
+	eraseCounterPages = ((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) / NANDGeometry->bytesPerPage;
+	if((((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) % NANDGeometry->bytesPerPage) != 0)
+		eraseCounterPages++;
+
+	readCounterPages = eraseCounterPages;
+
+	mapPages = (NANDGeometry->userSuBlksTotal * sizeof(u16)) / NANDGeometry->bytesPerPage;
+	if(((NANDGeometry->userSuBlksTotal * sizeof(u16)) % NANDGeometry->bytesPerPage) != 0)
+		mapPages++;
+
+	offsetsPages = (NANDGeometry->pagesPerSuBlk * (17 * sizeof(u16))) / NANDGeometry->bytesPerPage;
+	if(((NANDGeometry->pagesPerSuBlk * (17 * sizeof(u16))) % NANDGeometry->bytesPerPage) != 0)
+		offsetsPages++;
+
+	totalPages = eraseCounterPages + readCounterPages + mapPages + offsetsPages + 1 /* for the SID */ + 1 /* for FTLCxt */;
+
+	curBlock = pstFTLCxt->FTLCtrlPage / NANDGeometry->pagesPerSuBlk;
+	if((pstFTLCxt->FTLCtrlPage + totalPages) >= ((curBlock * NANDGeometry->pagesPerSuBlk) + NANDGeometry->pagesPerSuBlk))
+	{
+		// looks like we would be overflowing into the next block, force the next ctrl page to be on a fresh
+		// block in that case
+		pstFTLCxt->FTLCtrlPage = (curBlock * NANDGeometry->pagesPerSuBlk) + NANDGeometry->pagesPerSuBlk - 1;
+	}
+
+	pagesToWrite = eraseCounterPages;
+
+	for(i = 0; i < pagesToWrite; i++) {
+		int toWrite;
+		if(!ftl_next_ctrl_page())
+		{
+			LOG("ftl: cannot allocate next FTL ctrl page\n");
+			goto error_release;
+		}
+
+		pstFTLCxt->pages_for_pawEraseCounterTable[i] = pstFTLCxt->FTLCtrlPage;
+
+		toWrite = NANDGeometry->bytesPerPage;
+		if(toWrite > (((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) - (i * NANDGeometry->bytesPerPage))) {
+			toWrite = ((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) - (i * NANDGeometry->bytesPerPage);
+		}
+
+		memcpy(PageBuffer, ((u8*)pstFTLCxt->pawEraseCounterTable) + (i * NANDGeometry->bytesPerPage), toWrite);
+		memset(PageBuffer + toWrite, 0, NANDGeometry->bytesPerPage - toWrite);
+
+		memset(FTLSpareBuffer, 0xFF, sizeof(SpareData));
+		FTLSpareBuffer->meta.usnDec = pstFTLCxt->usnDec;
+		FTLSpareBuffer->type1 = 0x46;
+		FTLSpareBuffer->meta.idx = i;
+
+		if(VFL_Write(pstFTLCxt->pages_for_pawEraseCounterTable[i], PageBuffer, (u8*) FTLSpareBuffer) != 0)
+			goto error_release;
+	}
+
+	pagesToWrite = readCounterPages;
+
+	for(i = 0; i < pagesToWrite; i++) {
+		int toWrite;
+
+		if(!ftl_next_ctrl_page())
+		{
+			LOG("ftl: cannot allocate next FTL ctrl page\n");
+			goto error_release;
+		}
+
+		pstFTLCxt->pages_for_pawReadCounterTable[i] = pstFTLCxt->FTLCtrlPage;
+
+		toWrite = NANDGeometry->bytesPerPage;
+		if(toWrite > (((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) - (i * NANDGeometry->bytesPerPage))) {
+			toWrite = ((NANDGeometry->userSuBlksTotal + 23) * sizeof(u16)) - (i * NANDGeometry->bytesPerPage);
+		}
+
+		memcpy(PageBuffer, ((u8*)pstFTLCxt->pawReadCounterTable) + (i * NANDGeometry->bytesPerPage), toWrite);
+		memset(PageBuffer + toWrite, 0, NANDGeometry->bytesPerPage - toWrite);
+
+		memset(FTLSpareBuffer, 0xFF, sizeof(SpareData));
+		FTLSpareBuffer->meta.usnDec = pstFTLCxt->usnDec;
+		FTLSpareBuffer->type1 = 0x49;
+		FTLSpareBuffer->meta.idx = i;
+
+		if(VFL_Write(pstFTLCxt->pages_for_pawReadCounterTable[i], PageBuffer, (u8*) FTLSpareBuffer) != 0)
+			goto error_release;
+	}
+
+	pagesToWrite = mapPages;
+
+	for(i = 0; i < pagesToWrite; i++) {
+		int toWrite;
+		if(!ftl_next_ctrl_page())
+		{
+			LOG("ftl: cannot allocate next FTL ctrl page\n");
+			goto error_release;
+		}
+
+		pstFTLCxt->pages_for_pawMapTable[i] = pstFTLCxt->FTLCtrlPage;
+
+		toWrite = NANDGeometry->bytesPerPage;
+		if(toWrite > ((NANDGeometry->userSuBlksTotal * sizeof(u16)) - (i * NANDGeometry->bytesPerPage))) {
+			toWrite = (NANDGeometry->userSuBlksTotal * sizeof(u16)) - (i * NANDGeometry->bytesPerPage);
+		}
+
+		memcpy(PageBuffer, ((u8*)pstFTLCxt->pawMapTable) + (i * NANDGeometry->bytesPerPage), toWrite);
+		memset(PageBuffer + toWrite, 0, NANDGeometry->bytesPerPage - toWrite);
+
+		memset(FTLSpareBuffer, 0xFF, sizeof(SpareData));
+		FTLSpareBuffer->meta.usnDec = pstFTLCxt->usnDec;
+		FTLSpareBuffer->type1 = 0x44;
+		FTLSpareBuffer->meta.idx = i;
+
+		if(VFL_Write(pstFTLCxt->pages_for_pawMapTable[i], PageBuffer, (u8*) FTLSpareBuffer) != 0)
+			goto error_release;
+	}
+
+	pagesToWrite = offsetsPages;
+
+	for(i = 0; i < pagesToWrite; i++) {
+		int toWrite;
+		if(!ftl_next_ctrl_page())
+		{
+			LOG("ftl: cannot allocate next FTL ctrl page\n");
+			goto error_release;
+		}
+
+		pstFTLCxt->pages_for_wPageOffsets[i] = pstFTLCxt->FTLCtrlPage;
+
+		toWrite = NANDGeometry->bytesPerPage;
+		if(toWrite > ((NANDGeometry->pagesPerSuBlk * (17 * sizeof(u16))) - (i * NANDGeometry->bytesPerPage))) {
+			toWrite = (NANDGeometry->pagesPerSuBlk * (17 * sizeof(u16))) - (i * NANDGeometry->bytesPerPage);
+		}
+
+		memcpy(PageBuffer, ((u8*)pstFTLCxt->wPageOffsets) + (i * NANDGeometry->bytesPerPage), toWrite);
+		memset(PageBuffer + toWrite, 0, NANDGeometry->bytesPerPage - toWrite);
+
+		memset(FTLSpareBuffer, 0xFF, sizeof(SpareData));
+		FTLSpareBuffer->meta.usnDec = pstFTLCxt->usnDec;
+		FTLSpareBuffer->type1 = 0x45;
+		FTLSpareBuffer->meta.idx = i;
+
+		if(VFL_Write(pstFTLCxt->pages_for_wPageOffsets[i], PageBuffer, (u8*) FTLSpareBuffer) != 0)
+			goto error_release;
+	}
+
+	{
+		u32 unkSID;
+		void* data;
+		int size;
+
+
+		if(!ftl_next_ctrl_page())
+		{
+			LOG("ftl: cannot allocate next FTL ctrl page\n");
+			goto error_release;
+		}
+
+		pstFTLCxt->page_for_FTLCountsTable = pstFTLCxt->FTLCtrlPage;
+		pstFTLCxt->hasFTLCountsTable = 0xFFFFFFFF;
+
+		memset(PageBuffer, 0, NANDGeometry->bytesPerPage);
+
+		FTL_GetStruct(FTLCountsTableSID, &data, &size);
+		memcpy(PageBuffer, data, size);
+		VFL_GetStruct(VFLData1SID, &data, &size);
+		memcpy(PageBuffer + 0x200, data, size);
+		VFL_GetStruct(VFLData5SID, &data, &size);
+		memcpy(PageBuffer + 0x400, data, size);
+
+		unkSID = 0x10001;
+		memcpy(PageBuffer + NANDGeometry->bytesPerPage - sizeof(unkSID), &unkSID, sizeof(unkSID));
+
+		memset(FTLSpareBuffer, 0xFF, sizeof(SpareData));
+		FTLSpareBuffer->meta.usnDec = pstFTLCxt->usnDec;
+		FTLSpareBuffer->type1 = 0x47;
+		FTLSpareBuffer->meta.idx = 0;
+
+		if(VFL_Write(pstFTLCxt->page_for_FTLCountsTable, PageBuffer, (u8*) FTLSpareBuffer) != 0)
+			goto error_release;
+	}
+
+	if(!ftl_next_ctrl_page())
+	{
+		LOG("ftl: cannot allocate next FTL ctrl page\n");
+		goto error_release;
+	}
+
+	pstFTLCxt->clean = 1;
+
+	memset(FTLSpareBuffer, 0xFF, sizeof(SpareData));
+	FTLSpareBuffer->meta.usnDec = pstFTLCxt->usnDec;
+	FTLSpareBuffer->type1 = 0x43;
+	if(VFL_Write(pstFTLCxt->FTLCtrlPage, (u8*) pstFTLCxt, (u8*) FTLSpareBuffer) != 0)
+		goto error_release;
+
+	return true;
+
+error_release:
+	LOG("ftl: error committing FTLCxt!\n");
+
+	return false;
+}
+
+void check_for_dirty_free_vb(u8* pageBuffer, SpareData* spareData)
+{
+	int i;
+	int curFreeIdx = pstFTLCxt->nextFreeIdx;
+
+	if(CleanFreeVb)
+		return;
+
+	for(i = 0; i < pstFTLCxt->wNumOfFreeVb; ++i)
+	{
+		if(pstFTLCxt->awFreeVb[curFreeIdx] != 0xFFFF)
+		{
+			int page;
+			int block = pstFTLCxt->awFreeVb[curFreeIdx];
+			for(page = 0; page < NANDGeometry->pagesPerSuBlk; ++page)
+			{
+				int ret = VFL_Read(block * NANDGeometry->pagesPerSuBlk + page, pageBuffer, (u8*) spareData, true);
+
+				if(ret == ERROR_EMPTYBLOCK)
+					continue;
+
+				LOG("ftl: free block %d has non-empty pages.\r\n", block);
+				VFL_Erase(block);
+				break;
+			}
+		}
+		curFreeIdx = (curFreeIdx + 1) % 20;
+	}
+
+	CleanFreeVb = true;
+}
+
+static bool ftl_mark_unclean(void)
+{
+	int i;
+	u8* pageBuffer;
+	u8* spareBuffer;
+
+	if(!pstFTLCxt->clean)
+		return true;
+
+	pageBuffer = (u8*) kmalloc(NANDGeometry->bytesPerPage, GFP_KERNEL | GFP_DMA);
+	spareBuffer = (u8*) kmalloc(NANDGeometry->bytesPerSpare, GFP_KERNEL | GFP_DMA);
+	if(!pageBuffer || !spareBuffer)
+	{
+		LOG("ftl: ftl_mark_unclean: out of memory\n");
+		return false;
+	}
+
+	check_for_dirty_free_vb(pageBuffer, (SpareData*) spareBuffer);
+
+	for(i = 0; i < 3; ++i)
+	{
+		u16 block;
+
+		if(!ftl_next_ctrl_page())
+		{
+			LOG("ftl: ftl_mark_unclean: could not get a ctrl page\n");
+			goto error_release;
+		}
+
+		memset(pageBuffer, 0xFF, NANDGeometry->bytesPerPage);
+		((SpareData*)spareBuffer)->type1 = 0x4F;
+
+		if(VFL_Write(pstFTLCxt->FTLCtrlPage, pageBuffer, spareBuffer) == 0)
+		{
+			pstFTLCxt->clean = 0;
+			kfree(pageBuffer);
+			kfree(spareBuffer);
+			return true;
+		}
+
+		// have an error, try again on the next block.
+		block = pstFTLCxt->FTLCtrlPage / NANDGeometry->pagesPerSuBlk;
+		pstFTLCxt->FTLCtrlPage = (block * NANDGeometry->pagesPerSuBlk) + NANDGeometry->pagesPerSuBlk - 1;
+	}
+
+	LOG("ftl: ftl_mark_unclean failed!\n");
+
+error_release:
+	kfree(pageBuffer);
+	kfree(spareBuffer);
+	return false;
+}
+
+static FTLCxtLog* ftl_prepare_log(u16 lbn)
+{
+	FTLCxtLog* pLog = ftl_get_log(lbn);
+
+	if(pLog == NULL)
+	{
+		int i;
+		for(i = 0; i < 17; ++i)
+		{
+			if((pstFTLCxt->pLog[i].wVbn != 0xFFFF) && (pstFTLCxt->pLog[i].pagesUsed == 0))
+			{
+				pLog = &pstFTLCxt->pLog[i];
+				break;
+			}
+		}
+
+		if(pLog == NULL)
+		{
+			if(pstFTLCxt->wNumOfFreeVb < 3)
+			{
+				LOG("ftl: prepare_log WARNING: Pool block leak detected!\n");
+				return NULL;
+			} else if(pstFTLCxt->wNumOfFreeVb == 3)
+			{
+				if(!ftl_merge(NULL))
+				{
+					LOG("ftl: block merged failed!\n");
+					return NULL;
+				}
+			}
+
+			for(i = 0; i < 17; ++i)
+			{
+				if(pstFTLCxt->pLog[i].wVbn == 0xFFFF)
+				       break;
+			}
+
+			pLog = &pstFTLCxt->pLog[i];
+
+			if(!ftl_get_free_vb(&pLog->wVbn))
+			{
+				LOG("ftl: prepare_log could not get free vb\n");
+				return NULL;
+			}
+		}
+
+		memset(pLog->wPageOffsets, 0xFF, NANDGeometry->pagesPerSuBlk * sizeof(u16));
+		pLog->wLbn = lbn;
+		pLog->pagesUsed = 0;
+		pLog->pagesCurrent = 0;
+		pLog->isSequential = 1;
+
+#ifdef IPHONE_DEBUG
+		LOG("ftl: new log for lbn %d is %d\n", pLog->wLbn, pLog->wVbn);
+#endif
+	}
+
+	pLog->usn = pstFTLCxt->nextblockusn - 1;
+
+	return pLog;
+}
+
+static inline void ftl_check_still_sequential(FTLCxtLog* pLog, u32 page)
+{
+	if((pLog->pagesUsed != pLog->pagesCurrent) || (pLog->wPageOffsets[page] != page))
+		pLog->isSequential = 0;
+}
+
+static bool ftl_copy_page(u32 src, u32 dest, u32 lpn, u32 isSequential)
+{
+	u8* pageBuffer = kmalloc(NANDGeometry->bytesPerPage, GFP_KERNEL | GFP_DMA);
+	SpareData* spareData = (SpareData*) kmalloc(NANDGeometry->bytesPerSpare, GFP_KERNEL | GFP_DMA);
+
+	int ret = VFL_Read(src, pageBuffer, (u8*) spareData, true);
+
+	memset(spareData, 0xFF, NANDGeometry->bytesPerSpare);
+
+	if(ret == ERROR_EMPTYBLOCK)
+		memset(pageBuffer, 0, NANDGeometry->bytesPerPage);
+	else if(ret != 0)
+		spareData->eccMark = 0x55;
+
+	// FIXME: In CPICH, not all uses of this seem to increment this value. Find out whose fail it is.
+	// Incrementing shouldn't hurt, though.
+	spareData->user.usn = ++pstFTLCxt->nextblockusn;
+	spareData->user.logicalPageNumber = lpn;
+
+	// This isn't always done either
+	if(isSequential == 1 && ((dest % NANDGeometry->pagesPerSuBlk) == (NANDGeometry->pagesPerSuBlk - 1)))
+		spareData->type1 = 0x41;
+	else
+		spareData->type1 = 0x40;
+
+	ret = VFL_Write(dest, pageBuffer, (u8*) spareData);
+	if(ret != 0)
+		goto error_release;
+
+	kfree(pageBuffer);
+	kfree(spareData);
+	return true;
+
+error_release:
+	kfree(pageBuffer);
+	kfree(spareData);
+
+	return false;
+}
+
+static bool ftl_copy_block(u16 lSrc, u16 vDest)
+{
+	int i;
+	int error = false;
+	u8* pageBuffer = kmalloc(NANDGeometry->bytesPerPage, GFP_KERNEL | GFP_DMA);
+	SpareData* spareData = (SpareData*) kmalloc(NANDGeometry->bytesPerSpare, GFP_KERNEL | GFP_DMA);
+
+	++pstFTLCxt->nextblockusn;
+
+	for(i = 0; i < NANDGeometry->pagesPerSuBlk; ++i)
+	{
+		int ret = FTL_Read_private(lSrc * NANDGeometry->pagesPerSuBlk + i, 1, pageBuffer);
+		memset(spareData, 0xFF, NANDGeometry->bytesPerSpare);
+		if(ret)
+			spareData->eccMark = 0x55;
+
+		spareData->user.logicalPageNumber = lSrc * NANDGeometry->pagesPerSuBlk + i;
+		spareData->user.usn = pstFTLCxt->nextblockusn;
+		if(i == (NANDGeometry->pagesPerSuBlk - 1))
+			spareData->type1 = 0x41;
+		else
+			spareData->type1 = 0x40;
+
+		if(VFL_Write(vDest * NANDGeometry->pagesPerSuBlk + i, pageBuffer, (u8*) spareData) != 0)
+		{
+			error = true;
+			break;
+		}
+	}
+
+	if(error)
+	{
+		++pstFTLCxt->pawEraseCounterTable[vDest];
+		pstFTLCxt->pawReadCounterTable[vDest] = 0;
+
+		if(VFL_Erase(vDest) != 0)
+		{
+			LOG("ftl: ftl_copy_block failed to erase after failure!\n");
+			goto error_release;
+		}
+
+		LOG("ftl: ftl_copy_block failed!\n");
+		goto error_release;
+	}
+
+	kfree(pageBuffer);
+	kfree(spareData);
+	return true;
+
+error_release:
+	kfree(pageBuffer);
+	kfree(spareData);
+
+	return false;
+}
+
+static bool ftl_compact_scattered(FTLCxtLog* pLog)
+{
+	int error;
+	int i;
+
+	LOG("ftl: ftl_compact_scattered\n");
+
+	++FTLCountsTable.compactScatteredCount;
+
+	if(pLog->pagesCurrent == 0)
+	{
+		// nothing useful in here, just release it.
+		if(!ftl_set_free_vb(pLog->wVbn))
+		{
+			LOG("ftl: ftl_compact_scattered cannot release vb!\n");
+		}
+
+		pLog->wVbn = 0xFFFF;
+		++pstFTLCxt->swapCounter;
+		return true;
+	}
+
+	// make a backup
+	pstFTLCxt->pLog[17].usn  = pLog->usn;
+	pstFTLCxt->pLog[17].wVbn  = pLog->wVbn;
+	pstFTLCxt->pLog[17].wLbn  = pLog->wLbn;
+	pstFTLCxt->pLog[17].pagesUsed  = pLog->pagesUsed;
+	pstFTLCxt->pLog[17].pagesCurrent  = pLog->pagesCurrent;
+	pstFTLCxt->pLog[17].isSequential  = pLog->isSequential;
+
+	memcpy(pstFTLCxt->pLog[17].wPageOffsets, pLog->wPageOffsets, NANDGeometry->pagesPerSuBlk);
+
+	error = false;
+
+	for(i = 0; i < 4; ++i)
+	{
+		int page;
+		u16 newBlock;
+		if(!ftl_get_free_vb(&newBlock))
+		{
+			LOG("ftl: ftl_compact_scattered ran out of free vb!\n");
+			goto error_release;
+		}
+
+		pLog->pagesUsed = 0;
+		pLog->pagesCurrent = 0;
+		pLog->isSequential = 1;
+		pLog->wVbn = newBlock;
+
+		for(page = 0; page < NANDGeometry->pagesPerSuBlk; ++page)
+		{
+			if(pLog->wPageOffsets[page] != 0xFFFF)
+			{
+				u32 lpn = pLog->wLbn * NANDGeometry->pagesPerSuBlk + page;
+				u32 newPage = newBlock * NANDGeometry->pagesPerSuBlk + pLog->pagesUsed;
+				u32 oldPage = pstFTLCxt->pLog[17].wVbn * NANDGeometry->pagesPerSuBlk + pLog->wPageOffsets[page];
+				if(!ftl_copy_page(oldPage, newPage, lpn, pLog->isSequential))
+				{
+					error = true;
+					break;
+				}
+				pLog->wPageOffsets[page] = pLog->pagesUsed++;
+				++pLog->pagesCurrent;
+				ftl_check_still_sequential(pLog, page);
+			}
+		}
+
+		if(pstFTLCxt->pLog[17].pagesCurrent != pLog->pagesCurrent)
+			error = true;
+
+		if(!error)
+		{
+			if(!ftl_set_free_vb(pstFTLCxt->pLog[17].wVbn))
+			{
+				LOG("ftl: ftl_compact_scattered could not set old Vb free!\n");
+				goto error_release;
+			}
+
+			return true;
+		}
+
+		if(!ftl_set_free_vb(pLog->wVbn))
+		{
+			LOG("ftl: ftl_compact_scattered could not set failed Vb free!\n");
+			// better just to continue anyway
+		}
+
+		// restore the backup
+		pLog->usn = pstFTLCxt->pLog[17].usn;
+		pLog->wVbn = pstFTLCxt->pLog[17].wVbn;
+		pLog->wLbn = pstFTLCxt->pLog[17].wLbn;
+		pLog->pagesUsed = pstFTLCxt->pLog[17].pagesUsed;
+		pLog->pagesCurrent = pstFTLCxt->pLog[17].pagesCurrent;
+		pLog->isSequential = pstFTLCxt->pLog[17].isSequential;
+
+		memcpy(pLog->wPageOffsets, pstFTLCxt->pLog[17].wPageOffsets, NANDGeometry->pagesPerSuBlk);
+	}
+
+error_release:
+	return false;
+}
+
+static bool ftl_simple_merge(FTLCxtLog* pLog)
+{
+	int i;
+	int error = false;
+	u16 block;
+
+	LOG("ftl: ftl_simple_merge\n");
+
+	++FTLCountsTable.simpleMergeCount;
+
+	for(i = 0; i < 4; ++i)
+	{
+		if(!ftl_get_free_vb(&block))
+		{
+			LOG("ftl: ftl_simple_merge can't get free vb!\n");
+			return false;
+		}
+
+		if(ftl_copy_block(pLog->wLbn, block))
+		{
+			error = false;
+			break;
+		}
+
+		error = true;
+		if(!ftl_set_free_vb(block))
+		{
+			LOG("ftl: ftl_simple_merge can't set free vb after failure!\n");
+			return false;
+		}
+	}
+
+	if(error)
+	{
+		LOG("ftl: ftl_simple_merge failed!\n");
+		return false;
+	}
+
+	if(!ftl_set_free_vb(pLog->wVbn))
+	{
+			LOG("ftl: ftl_simple_merge can't set free scatter vb!\n");
+			return false;
+	}
+
+	pLog->wVbn = 0xFFFF;
+
+	if(!ftl_set_free_vb(pstFTLCxt->pawMapTable[pLog->wLbn]))
+	{
+			LOG("ftl: ftl_simple_merge can't set free map vb!\n");
+			return false;
+	}
+
+	pstFTLCxt->pawMapTable[pLog->wLbn] = block;
+
+	return true;
+}
+
+static bool ftl_copy_merge(FTLCxtLog* pLog)
+{
+	LOG("ftl: ftl_copy_merge\n");
+
+	if((pLog->isSequential != 1) || (pLog->pagesCurrent != pLog->pagesUsed))
+	{
+		LOG("ftl: attempted ftl_copy_merge on non-sequential scatter block!\n");
+		return false;
+	}
+
+	if(pLog->pagesUsed >= NANDGeometry->pagesPerSuBlk)
+		++FTLCountsTable.copyMergeWhileFullCount;
+	else
+		++FTLCountsTable.copyMergeWhileNotFullCount;
+
+	for(; pLog->pagesUsed < NANDGeometry->pagesPerSuBlk; ++pLog->pagesUsed)
+	{
+		u32 lpn = pLog->wLbn * NANDGeometry->pagesPerSuBlk  + pLog->pagesUsed;
+		u32 newPage = pLog->wVbn * NANDGeometry->pagesPerSuBlk + pLog->pagesUsed;
+		u32 oldPage = pstFTLCxt->pawMapTable[pLog->wLbn] * NANDGeometry->pagesPerSuBlk + pLog->pagesUsed;
+
+		// wtf, this isn't really all sequential!
+		if(pLog->wPageOffsets[pLog->pagesUsed] != 0xFFFF)
+			return ftl_simple_merge(pLog);
+
+		// try the simple merge if this fails
+		if(!ftl_copy_page(oldPage, newPage, lpn, 1))
+			return ftl_simple_merge(pLog);
+	}
+
+	if(!ftl_set_free_vb(pstFTLCxt->pawMapTable[pLog->wLbn]))
+	{
+			LOG("ftl: ftl_copy_merge can't set free map vb!\n");
+			return false;
+	}
+
+	// replace it with our now completed block
+	pstFTLCxt->pawMapTable[pLog->wLbn] = pLog->wVbn;
+
+	// set this log block as free
+	pLog->wVbn = 0xFFFF;
+
+	return true;
+}
+
+static bool ftl_merge(FTLCxtLog* pLog)
+{
+	u32 oldest = 0xFFFFFFFF;
+	u32 mostCurrent = 0;
+
+	if(!ftl_mark_unclean())
+	{
+		LOG("ftl: merge failed - cannot open new mark context\n");
+		return false;
+	}
+
+	if(pLog == NULL)
+	{
+		int i;
+
+		// find one to swap out
+		for(i = 0; i < 17; ++i)
+		{
+			if(pstFTLCxt->pLog[i].wVbn == 0xFFFF)
+				continue;
+
+			if(pstFTLCxt->pLog[i].pagesUsed == 0 || pstFTLCxt->pLog[i].pagesCurrent == 0)
+			{
+				LOG("ft: merge error - we still have logs that can be used instead!\n");
+				return false;
+			}
+
+			if(pstFTLCxt->pLog[i].usn < oldest || (pstFTLCxt->pLog[i].usn == oldest && pstFTLCxt->pLog[i].pagesCurrent > mostCurrent))
+			{
+				pLog = &pstFTLCxt->pLog[i];
+				oldest = pstFTLCxt->pLog[i].usn;
+				mostCurrent = pstFTLCxt->pLog[i].pagesCurrent;
+			}
+		}
+
+		if(pLog == NULL)
+			return false;
+	} else if(pLog->pagesCurrent < (NANDGeometry->pagesPerSuBlk / 2))
+	{
+		// less than half the pages in this log seems to be current, let's get rid of the crap and just reuse this one.
+
+		++pstFTLCxt->swapCounter;
+		return ftl_compact_scattered(pLog);
+	}
+
+	if(pLog->isSequential == 1)
+	{
+		if(!ftl_copy_merge(pLog))
+		{
+			LOG("ftl: simple merge failed\n");
+			return false;
+		}
+		++pstFTLCxt->swapCounter;
+		return true;
+	}
+	else
+	{
+		if(!ftl_simple_merge(pLog))
+		{
+			LOG("ftl: simple merge failed\n");
+			return false;
+		}
+		++pstFTLCxt->swapCounter;
+		return true;
+	}
+}
+
+bool ftl_auto_wearlevel(void)
+{
+	int i;
+	u16 smallestEraseCount = 0xFFFF;
+	u16 leastErasedBlock = 0;
+	u16 leastErasedBlockLbn = 0;
+	u16 largestEraseCount = 0;
+	u16 mostErasedFreeBlock = 0;
+	u16 mostErasedFreeBlockIdx = 20;
+
+	LOG("ftl: ftl_auto_wearlevel\n");
+
+	if(!ftl_mark_unclean())
+	{
+		LOG("ftl: auto wearlevel failed due to mark_unclean failure\n");
+		return false;
+	}
+
+	for(i = 0; i < pstFTLCxt->wNumOfFreeVb; ++i)
+	{
+		int idx = (pstFTLCxt->nextFreeIdx + i) % 20;
+
+		if(pstFTLCxt->awFreeVb[idx] == 0xFFFF)
+			continue;
+
+		if((mostErasedFreeBlockIdx == 20) || pstFTLCxt->pawEraseCounterTable[pstFTLCxt->awFreeVb[idx]] > largestEraseCount)
+		{
+			mostErasedFreeBlockIdx = idx;
+			mostErasedFreeBlock = pstFTLCxt->awFreeVb[idx];
+			largestEraseCount = pstFTLCxt->pawEraseCounterTable[mostErasedFreeBlock];
+		}
+	}
+
+	for(i = 0; i < NANDGeometry->userSuBlksTotal; ++i)
+	{
+		if(pstFTLCxt->pawEraseCounterTable[pstFTLCxt->pawMapTable[i]] > largestEraseCount)
+			largestEraseCount = pstFTLCxt->pawEraseCounterTable[pstFTLCxt->pawMapTable[i]];
+
+		// don't swap stuff with log blocks attached
+		if(ftl_get_log(i) != NULL)
+			continue;
+
+		if(pstFTLCxt->pawEraseCounterTable[pstFTLCxt->pawMapTable[i]] < smallestEraseCount)
+		{
+			leastErasedBlockLbn = i;
+			leastErasedBlock = pstFTLCxt->pawMapTable[i];
+			smallestEraseCount = pstFTLCxt->pawEraseCounterTable[leastErasedBlock];
+		}
+	}
+
+	if(largestEraseCount == 0)
+		return true;
+
+	if((largestEraseCount - smallestEraseCount) < 5)
+		return true;
+
+	++pstFTLCxt->pawEraseCounterTable[mostErasedFreeBlock];
+	pstFTLCxt->pawReadCounterTable[mostErasedFreeBlock] = 0;
+
+	if(VFL_Erase(mostErasedFreeBlock) != 0)
+	{
+		LOG("ftl: auto wear-level cannot erase most erased free block\n");
+		return false;
+	}
+
+	++FTLCountsTable.blockSwapCount;
+
+	if(!ftl_copy_block(leastErasedBlockLbn, mostErasedFreeBlock))
+	{
+		LOG("ftl: auto wear-level cannot copy least erased to most erased\n");
+		return false;
+	}
+
+	pstFTLCxt->pawMapTable[leastErasedBlockLbn] = mostErasedFreeBlock;
+
+	++pstFTLCxt->pawEraseCounterTable[leastErasedBlock];
+	pstFTLCxt->pawReadCounterTable[leastErasedBlock] = 0;
+
+	if(VFL_Erase(leastErasedBlock) != 0)
+	{
+		LOG("ftl: auto wear-level cannot erase previously least erased block\n");
+		return false;
+	}
+
+	pstFTLCxt->awFreeVb[mostErasedFreeBlockIdx] = leastErasedBlock;
+
+	return true;
+}
+
+static int FTL_Write_private(u32 logicalPageNumber, int totalPagesToWrite, u8* pBuf)
+{
+	int i;
+
+	//LOG("FTL_Write start\n");
+#ifdef IPHONE_DEBUG
+	LOG("request to write %d pages at %d\r\n", totalPagesToWrite, logicalPageNumber);
+#endif
+
+	FTLCountsTable.totalPagesWritten += totalPagesToWrite;
+	++FTLCountsTable.totalWrites;
+
+	if(!pBuf) {
+		return -EINVAL;
+	}
+
+	if(totalPagesToWrite == 0 || (logicalPageNumber + totalPagesToWrite) > NANDGeometry->userPagesTotal) {
+		LOG("ftl: write has invalid input parameters\n");
+		return -EINVAL;
+	}
+
+	if(!ftl_mark_unclean())
+	{
+		LOG("ftl: write could not mark FTL as unclean!\n");
+		return -EINVAL;
+	}
+
+	for(i = 0; i < totalPagesToWrite; )
+	{
+		int lbn = (logicalPageNumber + i) / NANDGeometry->pagesPerSuBlk;
+		int offset = (logicalPageNumber + i) - (lbn * NANDGeometry->pagesPerSuBlk);
+
+		FTLCxtLog* pLog = ftl_prepare_log(lbn);
+
+		if(pLog == NULL)
+		{
+			LOG("ftl: write failed to prepare log!\n");
+			goto error_release;
+		}
+
+		if(offset == 0 && (totalPagesToWrite - i) >= NANDGeometry->pagesPerSuBlk)
+		{
+			// we are replacing an entire block
+
+			u16 vblock;
+			int j;
+
+			if(pLog->pagesUsed != 0)
+			{
+				// we can't use this log block since it's not empty, get rid of it.
+				if(!ftl_set_free_vb(pLog->wVbn))
+				{
+					LOG("ftl: write failed to set a free Vb when replacing an entire block!\n");
+					goto error_release;
+				}
+
+				if(!ftl_get_free_vb(&vblock))
+				{
+					LOG("ftl: write failed to get a free Vb for replacing an entire block!\n");
+					goto error_release;
+				}
+			} else
+			{
+				// we can just use this empty log block
+				vblock = pLog->wVbn;
+			}
+
+			// don't need this log block anymore, we're now a full map block
+			pLog->wVbn = 0xFFFF;
+
+			++pstFTLCxt->nextblockusn;
+
+			for(j = 0; j < NANDGeometry->pagesPerSuBlk; ++j)
+			{
+				int tries;
+
+				memset(FTLSpareBuffer, 0xFF, NANDGeometry->bytesPerSpare);
+				FTLSpareBuffer->user.logicalPageNumber = logicalPageNumber + i + j;
+				FTLSpareBuffer->user.usn = pstFTLCxt->nextblockusn;
+				if(j == (NANDGeometry->pagesPerSuBlk - 1))
+					FTLSpareBuffer->type1 = 0x41;
+				else
+					FTLSpareBuffer->type1 = 0x40;
+
+				for(tries = 0; tries < 4; ++tries)
+				{
+					if(VFL_Write((vblock * NANDGeometry->pagesPerSuBlk) + j,
+							pBuf + ((i + j) * (NANDGeometry->bytesPerPage)), (u8*) FTLSpareBuffer) == 0)
+						break;
+				}
+
+				if(tries == 4)
+				{
+					LOG("ftl: write error during writing replacement block!\n");
+					// FIXME: no real error handling here!
+				}
+			}
+
+			if(!ftl_set_free_vb(pstFTLCxt->pawMapTable[lbn]))
+			{
+				LOG("ftl: write failed to set a free Vb after writing replacement block!\n");
+				goto error_release;
+			}
+
+			pstFTLCxt->pawMapTable[lbn] = vblock;
+#ifdef IPHONE_DEBUG
+			LOG("ftl: replacing block with stuff from offset %d\n", (i * (NANDGeometry->bytesPerPage)));
+#endif
+			i += NANDGeometry->pagesPerSuBlk;
+		} else
+		{
+			int pagesCanWrite;
+			int j;
+
+			// we'll have to use the log since we're not replacing the whole block
+
+			if(pLog->pagesUsed == NANDGeometry->pagesPerSuBlk)
+			{
+#ifdef IPHONE_DEBUG
+				int orig = pLog->wVbn;
+#endif
+
+				// oh no, this log is full. we have to commit it
+				if(!ftl_merge(pLog))
+				{
+					LOG("ftl: write failed to merge in the log!\n");
+					goto error_release;
+				}
+
+				pLog = ftl_prepare_log(lbn);
+
+				if(pLog == NULL)
+				{
+					LOG("ftl: write failed to prepare log after merging!\n");
+					goto error_release;
+				}
+#ifdef IPHONE_DEBUG
+				LOG("ftl: replaced pLog for wLbn %d wVbn %d => %d\n", pLog->wLbn, orig, pLog->wVbn);
+#endif
+			}
+
+			pagesCanWrite = totalPagesToWrite - i;
+
+			// don't overflow the log
+			if(pagesCanWrite > (NANDGeometry->pagesPerSuBlk - pLog->pagesUsed))
+				pagesCanWrite = NANDGeometry->pagesPerSuBlk - pLog->pagesUsed;
+
+			// don't write pages belonging to some other block here
+			if(pagesCanWrite > (NANDGeometry->pagesPerSuBlk - offset))
+				pagesCanWrite = NANDGeometry->pagesPerSuBlk - offset;
+
+			for(j = 0; j < pagesCanWrite; ++j)
+			{
+				int tries;
+				int abspage;
+
+				memset(FTLSpareBuffer, 0xFF, NANDGeometry->bytesPerSpare);
+				FTLSpareBuffer->user.logicalPageNumber = logicalPageNumber + i + j;
+				FTLSpareBuffer->user.usn = ++pstFTLCxt->nextblockusn;
+				if((pLog->pagesUsed == (NANDGeometry->pagesPerSuBlk - 1)) && pLog->isSequential)
+					FTLSpareBuffer->type1 = 0x41;
+				else
+					FTLSpareBuffer->type1 = 0x40;
+
+				for(tries = 0; tries < 4; ++tries)
+				{
+					abspage = pLog->wVbn * NANDGeometry->pagesPerSuBlk + pLog->pagesUsed;
+
+					if(VFL_Write(abspage,
+							pBuf + ((i + j) * (NANDGeometry->bytesPerPage)), (u8*) FTLSpareBuffer) == 0)
+						break;
+					++pLog->pagesUsed;
+				}
+
+				if(tries == 4)
+				{
+					LOG("ftl: write error during writing to log!\n");
+					// FIXME: no real error handling here
+				}
+
+				if(pLog->wPageOffsets[offset + j] == 0xFFFF)
+				{
+					// This page wasn't current before but now it is
+					++pLog->pagesCurrent;
+				}
+
+				pLog->wPageOffsets[offset + j] = pLog->pagesUsed;
+				++pLog->pagesUsed;
+
+				if(pLog->isSequential == 1)
+					ftl_check_still_sequential(pLog, offset + j);
+
+#ifdef IPHONE_DEBUG
+				LOG("ftl: filling out block %d log entry %d = %d logical (%d, %d) with stuff from offset %d\n", pLog->wVbn,
+						pLog->pagesUsed - 1,
+						abspage, pLog->wLbn, offset + j, ((i + j) * (NANDGeometry->bytesPerPage)));
+#endif
+
+			}
+
+			i += pagesCanWrite;
+		}
+
+	}
+
+	if(pstFTLCxt->swapCounter >= 300)
+	{
+		int tries;
+		for(tries = 0; tries < 4; ++tries)
+		{
+			if(ftl_auto_wearlevel())
+			{
+				pstFTLCxt->swapCounter -= 20;
+				break;
+			}
+		}
+	}
+
+	//LOG("FTL_Write end\n");
+	return 0;
+
+error_release:
+	//LOG("FTL_Write end\n");
+	return -EINVAL;
+}
+
+int FTL_Write(u32 logicalPageNumber, int totalPagesToWrite, u8* pBuf)
+{
+	int ret;
+
+#ifdef FTL_PROFILE
+	u64 startTime;
+#endif
+
+	mutex_lock(&ftl_mutex);
+
+#ifdef FTL_PROFILE
+	Time_wait_for_ecc_interrupt = 0;
+	Time_wait_for_ready = 0;
+	Time_wait_for_address_done = 0;
+	Time_wait_for_command_done = 0;
+	Time_wait_for_transfer_done = 0;
+	Time_wait_for_nand_bank_ready = 0;
+	Time_nand_write = 0;
+	Time_iphone_dma_finish = 0;
+	TotalWriteTime = 0;
+	startTime = iphone_microtime();
+#endif
+
+	ret = FTL_Write_private(logicalPageNumber, totalPagesToWrite, pBuf);
+
+#ifdef FTL_PROFILE
+	TotalWriteTime += iphone_microtime() - startTime;
+	LOG("write complete in %llu: ecc = %llu, ready = %llu, addr = %llu, cmd = %llu, xfer = %llu, bankrdy = %llu, dma = %llu, write = %llu, active = %llu\n",
+			TotalWriteTime,
+			Time_wait_for_ecc_interrupt,
+			Time_wait_for_ready,
+			Time_wait_for_address_done,
+			Time_wait_for_command_done,
+			Time_wait_for_transfer_done,
+			Time_wait_for_nand_bank_ready,
+			Time_iphone_dma_finish,
+			Time_nand_write,
+			TotalWriteTime - Time_wait_for_ecc_interrupt - Time_wait_for_ready - Time_wait_for_address_done - Time_wait_for_command_done - Time_wait_for_transfer_done - Time_wait_for_nand_bank_ready - Time_iphone_dma_finish
+			);
+#endif
+
+	mutex_unlock(&ftl_mutex);
+	return ret;
+}
+
+bool ftl_sync(void)
+{
+	int tries;
+
+#ifdef FTL_PROFILE
+	u64 startTime;
+#endif
+
+	mutex_lock(&ftl_mutex);
+	//LOG("ftl_sync start\n");
+
+#ifdef FTL_PROFILE
+	startTime = iphone_microtime();
+#endif
+
+	if(pstFTLCxt->clean)
+	{
+		LOG("ftl_sync end\n");
+		mutex_unlock(&ftl_mutex);
+		return true;
+	}
+
+	check_for_dirty_free_vb(PageBuffer, FTLSpareBuffer);
+
+	if(pstFTLCxt->swapCounter >= 20)
+	{
+		for(tries = 0; tries < 4; ++ tries)
+		{
+			if(ftl_auto_wearlevel())
+			{
+				pstFTLCxt->swapCounter -= 20;
+				break;
+			}
+		}
+	}
+
+	for(tries = 0; tries < 4; ++ tries)
+	{
+		if(ftl_commit_cxt())
+		{
+			//LOG("ftl_sync end\n");
+
+#ifdef FTL_PROFILE
+			TotalSyncTime += iphone_microtime() - startTime;
+#endif
+			mutex_unlock(&ftl_mutex);
+			return true;
+		} else
+		{
+			// have some kind of error, try again on a new block
+			u16 block = pstFTLCxt->FTLCtrlPage / NANDGeometry->pagesPerSuBlk;
+			pstFTLCxt->FTLCtrlPage = (block * NANDGeometry->pagesPerSuBlk) + NANDGeometry->pagesPerSuBlk - 1;
+		}
+	}
+
+	//LOG("ftl_sync end\n");
+
+#ifdef FTL_PROFILE
+	TotalSyncTime += iphone_microtime() - startTime;
+#endif
+
+	mutex_unlock(&ftl_mutex);
+	return false;
+}
+
+int ftl_setup(void)
+{
+	int pagesAvailable;
+	int bytesPerPage;
+
+	mutex_lock(&ftl_mutex);
+
+	if(VFL_Init() != 0)
+	{
+		LOG("ftl: VFL_Init failed\n");
+		mutex_unlock(&ftl_mutex);
+		return -1;
+	}
+
+	if(VFL_Verify() != 0)
+	{
+		LOG("ftl: VFL_Verify failed\n");
+		mutex_unlock(&ftl_mutex);
+		return -1;
+	}
+
+	if(VFL_Open() != 0) {
+		LOG("ftl: VFL_Open failed\n");
+		mutex_unlock(&ftl_mutex);
+		return -1;
+	}
+
+	if(FTL_Init() != 0) {
+		LOG("ftl: FTL_Init failed\n");
+		mutex_unlock(&ftl_mutex);
+		return -1;
+	}
+
+	if(FTL_Open(&pagesAvailable, &bytesPerPage) != 0) {
+		LOG("ftl: FTL_Open failed\n");
+		mutex_unlock(&ftl_mutex);
+		return -1;
+	}
+
+	mutex_unlock(&ftl_mutex);
+
+	return 0;
+}
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/gpio.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/gpio.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/gpio.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/gpio.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,354 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/sysdev.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/gpio_keys.h>
+#include <linux/switch.h>
+#include <linux/platform_device.h>
+
+#include <mach/iphone-clock.h>
+#include <mach/gpio.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+
+#define GET_BITS(x, start, length) ((((u32)(x)) << (32 - ((start) + (length)))) >> (32 - (length)))
+
+#define GPIO_INTTYPE_MASK 0x1
+#define GPIO_INTTYPE_EDGE 0x0
+#define GPIO_INTTYPE_LEVEL GPIO_INTTYPE_MASK
+
+#define GPIO_INTLEVEL_MASK 0x2
+#define GPIO_INTLEVEL_LOW 0x0
+#define GPIO_INTLEVEL_HIGH GPIO_INTLEVEL_MASK
+
+#define GPIO_AUTOFLIP_MASK 0x4
+#define GPIO_AUTOFLIP_NO 0x0
+#define GPIO_AUTOFLIP_YES GPIO_AUTOFLIP_MASK
+
+bool autoflip[IPHONE_NR_GPIO_IRQS];
+
+static GPIORegisters* GPIORegs = (GPIORegisters*) GPIO;
+
+static irqreturn_t gpio_handle_interrupt(int irq, void* pToken);
+static void iphone_gpio_interrupt_enable(unsigned int irq);
+static void iphone_gpio_interrupt_disable(unsigned int irq);
+static void iphone_gpio_interrupt_ack(unsigned int irq);
+static int iphone_gpio_interrupt_set_type(unsigned int irq, unsigned int flags);
+
+static struct irq_chip iphone_gpio_irq_chip = {
+	.name = "iphone_gpio",
+	.mask = iphone_gpio_interrupt_disable,
+	.unmask = iphone_gpio_interrupt_enable,
+	.ack = iphone_gpio_interrupt_ack,
+	.set_type = iphone_gpio_interrupt_set_type,
+};
+
+static struct gpio_keys_button iphone_gpio_keys_table[] = {
+	{
+		.gpio = GPIO_BUTTONS_HOME,
+		.code = 229,
+		.desc = "MENU",
+		.active_low = 0,
+		.wakeup = 0,
+		.debounce_interval = 20,
+	},
+	{
+		.gpio = GPIO_BUTTONS_HOLD,
+		.code = 158,
+		.desc = "BACK",
+		.active_low = 0,
+		.wakeup = 0,
+		.debounce_interval = 20,
+	},
+	/* we'll map these to more useful keys until somebody comes up with a better solution */
+#ifndef CONFIG_IPODTOUCH_1G
+    {
+            .gpio = GPIO_BUTTONS_VOLUP,
+            .code = 61,
+            .desc = "CALL",
+            .active_low = 1,
+            .wakeup = 0,
+            .debounce_interval = 20,
+    },
+    {
+            .gpio = GPIO_BUTTONS_VOLDOWN,
+            .code = 102,
+            .desc = "CALL",
+            .active_low = 1,
+            .wakeup = 0,
+            .debounce_interval = 20,
+    },
+#endif
+/*	{
+		.gpio = GPIO_BUTTONS_VOLUP,
+		.code = 115,
+		.desc = "VOLUME_UP",
+		.active_low = 1,
+		.wakeup = 0,
+		.debounce_interval = 20,
+	},
+	{
+		.gpio = GPIO_BUTTONS_VOLDOWN,
+		.code = 114,
+		.desc = "VOLUME_DOWN",
+		.active_low = 1,
+		.wakeup = 0,
+		.debounce_interval = 20,
+	},*/
+};
+
+static struct gpio_keys_platform_data iphone_gpio_keys_data = {
+	.buttons = iphone_gpio_keys_table,
+	.nbuttons = ARRAY_SIZE(iphone_gpio_keys_table),
+};
+
+static struct platform_device iphone_device_gpiokeys = {
+	.name = "gpio-keys",
+	.dev = {
+		.platform_data = &iphone_gpio_keys_data,
+	},
+};
+
+#ifndef CONFIG_IPHONE_3G
+static struct gpio_switch_platform_data headset_switch_data = {
+	.name = "h2w",
+#ifdef CONFIG_IPHONE_2G
+	.gpio = 0x1402,
+	.state_on = "0",
+	.state_off = "1",
+#else
+	.gpio = 0x1205,
+	.state_on = "1",
+	.state_off = "0",
+#endif
+	.irq_flags = IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW,
+};
+
+static struct platform_device headset_switch_device = {
+	.name = "switch-gpio",
+	.dev = {
+		.platform_data = &headset_switch_data,
+	}
+}; 
+#endif
+
+static int iphone_gpio_setup(void) {
+	int i;
+	int ret;
+
+	for(i = 0; i < GPIO_NUMINTGROUPS; i++) {
+		// writes to all the interrupt status register to acknowledge and discard any pending
+		writel(GPIO_INTSTAT_RESET, GPIOIC + GPIO_INTSTAT + (i * 0x4));
+
+		// disable all interrupts
+		writel(GPIO_INTEN_RESET, GPIOIC + GPIO_INTEN + (i * 0x4));
+	}
+
+	for(i = 0; i < IPHONE_NR_GPIO_IRQS; i++)
+	{
+		autoflip[i] = false;
+		set_irq_chip(IPHONE_GPIO_IRQS + i, &iphone_gpio_irq_chip);
+		set_irq_handler(IPHONE_GPIO_IRQS + i, handle_level_irq);
+		set_irq_flags(IPHONE_GPIO_IRQS + i, IRQF_VALID);
+	}
+
+        ret = request_irq(0x21, gpio_handle_interrupt, IRQF_DISABLED, "iphone_gpio", (void*) 0);
+	if(ret)
+		return ret;
+
+        ret = request_irq(0x20, gpio_handle_interrupt, IRQF_DISABLED, "iphone_gpio", (void*) 1);
+	if(ret)
+		return ret;
+
+        ret = request_irq(0x1f, gpio_handle_interrupt, IRQF_DISABLED, "iphone_gpio", (void*) 2);
+	if(ret)
+		return ret;
+
+        ret = request_irq(0x03, gpio_handle_interrupt, IRQF_DISABLED, "iphone_gpio", (void*) 3);
+	if(ret)
+		return ret;
+
+        ret = request_irq(0x02, gpio_handle_interrupt, IRQF_DISABLED, "iphone_gpio", (void*) 4);
+	if(ret)
+		return ret;
+
+        ret = request_irq(0x01, gpio_handle_interrupt, IRQF_DISABLED, "iphone_gpio", (void*) 5);
+	if(ret)
+		return ret;
+
+        ret = request_irq(0x00, gpio_handle_interrupt, IRQF_DISABLED, "iphone_gpio", (void*) 6);
+	if(ret)
+		return ret;
+
+	iphone_clock_gate_switch(GPIO_CLOCKGATE, 1);
+
+	platform_device_register(&iphone_device_gpiokeys);
+#ifndef CONFIG_IPHONE_3G
+	platform_device_register(&headset_switch_device);
+#endif
+	printk("iphone-gpio: GPIO input devices registered\n");
+
+	return 0;
+}
+
+module_init(iphone_gpio_setup);
+
+int iphone_gpio_pin_state(int port) {
+	return ((GPIORegs[GET_BITS(port, 8, 5)].DAT & (1 << GET_BITS(port, 0, 3))) != 0);
+}
+
+void iphone_gpio_custom_io(int port, int bits) {
+	writel(((GET_BITS(port, 8, 5) & GPIO_IO_MAJMASK) << GPIO_IO_MAJSHIFT)
+				| ((GET_BITS(port, 0, 3) & GPIO_IO_MINMASK) << GPIO_IO_MINSHIFT)
+				| ((bits & GPIO_IO_UMASK) << GPIO_IO_USHIFT), GPIO + GPIO_IO);
+}
+
+void iphone_gpio_pin_reset(int port) {
+	iphone_gpio_custom_io(port, 0);
+}
+
+void iphone_gpio_pin_output(int port, int bit) {
+	iphone_gpio_custom_io(port, 0xE | bit); // 0b111U, where U is the argument
+}
+
+int iphone_gpio_detect_configuration(void) {
+	static int hasDetected = 0;
+	static int detectedConfig = 0;
+
+	if(hasDetected) {
+		return detectedConfig;
+	}
+
+	detectedConfig = (iphone_gpio_pin_state(GPIO_DETECT3) ? 1 : 0) | ((iphone_gpio_pin_state(GPIO_DETECT2) ? 1 : 0) << 1) | ((iphone_gpio_pin_state(GPIO_DETECT1) ? 1 : 0) << 2);
+	hasDetected = 1;
+	return detectedConfig;
+}
+
+static void iphone_gpio_interrupt_enable(unsigned int irq)
+{
+	int interrupt = irq - IPHONE_GPIO_IRQS;
+	int group = interrupt >> 5;
+	int index = interrupt & 0x1f;
+
+	writel(readl(GPIOIC + GPIO_INTEN + (0x4 * group)) | (1 << index), GPIOIC + GPIO_INTEN + (0x4 * group));
+}
+
+static void iphone_gpio_interrupt_disable(unsigned int irq)
+{
+	int interrupt = irq - IPHONE_GPIO_IRQS;
+	int group = interrupt >> 5;
+	int index = interrupt & 0x1f;
+	int mask = ~(1 << index);
+
+	writel(readl(GPIOIC + GPIO_INTEN + (0x4 * group)) & mask, GPIOIC + GPIO_INTEN + (0x4 * group));
+}
+
+static void iphone_gpio_interrupt_ack(unsigned int irq)
+{
+	int interrupt = irq - IPHONE_GPIO_IRQS;
+	int group = interrupt >> 5;
+	int index = interrupt & 0x1f;
+	writel(1 << index, GPIOIC + GPIO_INTSTAT + (0x4 * group));
+}
+
+
+static int iphone_gpio_interrupt_set_type(unsigned int irq, unsigned int flags)
+{
+	int interrupt = irq - IPHONE_GPIO_IRQS;
+	int group = interrupt >> 5;
+	int index = interrupt & 0x1f;
+	int mask = ~(1 << index);
+	int level;
+	int type;
+
+	if((flags & IRQ_TYPE_EDGE_FALLING) || (flags & IRQ_TYPE_EDGE_RISING))
+	{
+		type = 0;
+		set_irq_handler(irq, handle_edge_irq);
+	}
+
+	if((flags & IRQ_TYPE_LEVEL_HIGH) || (flags & IRQ_TYPE_LEVEL_HIGH))
+	{
+		type = 1;
+		set_irq_handler(irq, handle_level_irq);
+	}
+
+	if((flags & IRQ_TYPE_EDGE_FALLING) || (flags & IRQ_TYPE_LEVEL_LOW))
+		level = 0;
+
+	if((flags & IRQ_TYPE_EDGE_RISING) || (flags & IRQ_TYPE_LEVEL_HIGH))
+		level = 1;
+
+	if((flags & IRQ_TYPE_EDGE_FALLING) && (flags & IRQ_TYPE_EDGE_RISING))
+		autoflip[interrupt] = true;
+	else if((flags & IRQ_TYPE_LEVEL_LOW) && (flags & IRQ_TYPE_LEVEL_HIGH))
+		autoflip[interrupt] = true;
+	else
+		autoflip[interrupt] = false;
+
+	writel((readl(GPIOIC + GPIO_INTTYPE + (0x4 * group)) & mask) | ((type ? 1 : 0) << index), GPIOIC + GPIO_INTTYPE + (0x4 * group));
+
+	writel((readl(GPIOIC + GPIO_INTLEVEL + (0x4 * group)) & mask) | ((level ? 1 : 0) << index), GPIOIC + GPIO_INTLEVEL + (0x4 * group));
+
+	return 0;
+}
+
+static irqreturn_t gpio_handle_interrupt(int irq, void* pToken)
+{
+	u32 token = (u32) pToken;
+	u32 statReg = GPIOIC + GPIO_INTSTAT + (0x4 * token);
+
+	int stat;
+
+	while((stat = readl(statReg)) != 0)
+	{
+		int i;
+		for(i = 0; i < 32; ++i)
+		{
+			if(stat & 1)
+			{
+				int num = (token << 5) + i;
+
+				if(autoflip[num])
+					writel(readl(GPIOIC + GPIO_INTLEVEL + (0x4 * token)) ^ (1 << i), GPIOIC + GPIO_INTLEVEL + (0x4 * token));
+
+				generic_handle_irq(IPHONE_GPIO_IRQS + num);
+			}
+
+			stat >>= 1;
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+int gpio_to_irq(unsigned gpio)
+{
+	if(gpio >= 0x1600 && gpio < 0x1700)
+	{
+		return IPHONE_GPIO_IRQS + (gpio - 0x1600 + 0x28);
+	} else if(gpio == 0x1402)
+	{
+		return IPHONE_GPIO_IRQS + 0x3A;
+	} else if(gpio == 0x1205)
+	{
+		return IPHONE_GPIO_IRQS + 0x4D;
+	}
+
+	return -1;
+}
+
+int irq_to_gpio(unsigned irq)
+{
+	if(irq > IPHONE_GPIO_IRQS)
+	{
+		if(irq >= (IPHONE_GPIO_IRQS + 0x28))
+			return (irq - IPHONE_GPIO_IRQS - 0x28) + 0x1600;
+		else
+			return -1;
+	}
+
+	return -1;
+}
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/i2c.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/i2c.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/i2c.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/i2c.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,387 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <mach/iphone-i2c.h>
+#include <mach/gpio.h>
+#include <mach/iphone-clock.h>
+#include <mach/hardware.h>
+#include <mach/i2c.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <linux/sysdev.h>
+#include <linux/io.h>
+
+static const I2CInfo I2CInit[] = {
+			{NULL, 0, I2CNoError, 0, 0, 0, I2CDone, 0, 0, 0, 0, 0, NULL, 0, NULL, I2C0_SCL_GPIO, I2C0_SDA_GPIO, I2C0 + IICCON, I2C0 + IICSTAT, I2C0 + IICADD, I2C0 + IICDS, I2C0 + IICLC,
+				I2C0 + IICREG14, I2C0 + IICREG18, I2C0 + IICREG1C, I2C0 + IICREG20},
+			{NULL, 0, I2CNoError, 0, 0, 0, I2CDone, 0, 0, 0, 0, 0, NULL, 0, NULL, I2C1_SCL_GPIO, I2C1_SDA_GPIO, I2C1 + IICCON, I2C1 + IICSTAT, I2C1 + IICADD, I2C1 + IICDS, I2C1 + IICLC,
+				I2C1 + IICREG14, I2C1 + IICREG18, I2C1 + IICREG1C, I2C1 + IICREG20}
+		};
+
+static I2CInfo I2C[2];
+
+static void init_i2c(I2CInfo* i2c, u32 frequency);
+static I2CError iphone_i2c_readwrite(I2CInfo* i2c);
+static void do_i2c(I2CInfo* i2c);
+
+static struct i2c_adapter iphone_i2c0;
+static struct i2c_adapter iphone_i2c1;
+
+static int initialized = 0;
+
+static int iphone_i2c_setup(void) {
+	printk("iphone-i2c: inside setup...\n");
+	memcpy(I2C, I2CInit, sizeof(I2CInfo) * 2);
+
+	I2C[0].rw_sem = (struct mutex *)kzalloc(sizeof(struct mutex), GFP_KERNEL);
+	I2C[1].rw_sem = (struct mutex *)kzalloc(sizeof(struct mutex), GFP_KERNEL);
+
+	mutex_init(I2C[0].rw_sem);
+	mutex_init(I2C[1].rw_sem);
+
+	iphone_clock_gate_switch(I2C0_CLOCKGATE, 1);
+	iphone_clock_gate_switch(I2C1_CLOCKGATE, 1);
+
+	init_i2c(&I2C[0], FREQUENCY_PERIPHERAL / 100000);
+	init_i2c(&I2C[1], FREQUENCY_PERIPHERAL / 100000);
+	printk("iphone-i2c: done setup!\n");
+	initialized = 1;
+	return 0;
+}
+
+I2CError iphone_i2c_recv(int bus, int iicaddr, int send_stop, void* buffer, int len) {
+	I2CError ret;
+	mutex_lock(I2C[bus].rw_sem);
+	I2C[bus].address = iicaddr;
+	I2C[bus].is_write = 0;
+	I2C[bus].send_stop = send_stop;
+	I2C[bus].bufferLen = len;
+	I2C[bus].buffer = (uint8_t*) buffer;
+	ret = iphone_i2c_readwrite(&I2C[bus]);
+	mutex_unlock(I2C[bus].rw_sem);
+	return ret;
+}
+
+I2CError iphone_i2c_send(int bus, int iicaddr, int send_stop, const void* buffer, int len) {
+	I2CError ret;
+	mutex_lock(I2C[bus].rw_sem);
+	I2C[bus].address = iicaddr;
+	I2C[bus].is_write = 1;
+	I2C[bus].send_stop = send_stop;
+	I2C[bus].bufferLen = len;
+	I2C[bus].buffer = (uint8_t*) buffer;
+	ret = iphone_i2c_readwrite(&I2C[bus]);
+	mutex_unlock(I2C[bus].rw_sem);
+	return ret;
+}
+
+static void init_i2c(I2CInfo* i2c, u32 frequency) {
+	int prescaler, divisorRequired;
+	int i;
+	printk("iphone-i2c: start initializing!\n");
+	i2c->frequency = 2560000 / frequency;
+	divisorRequired = 640000 / i2c->frequency;
+	if(divisorRequired < 512) {
+		// round up
+		i2c->iiccon_settings = IICCON_INIT | IICCON_TXCLKSRC_FPCLK16;
+		prescaler = ((divisorRequired + 0x1F) >> 5) - 1;
+	} else {
+		i2c->iiccon_settings = IICCON_INIT | IICCON_TXCLKSRC_FPCLK512;
+		prescaler = ((divisorRequired + 0x1FF) >> 9) - 1;
+	}
+
+	if(prescaler == 0)
+		prescaler = 1;
+
+	i2c->iiccon_settings |= prescaler;
+
+	iphone_gpio_custom_io(i2c->iic_sda_gpio, 0xE); // pull sda low?
+
+	for(i = 0; i < 19; i++) {
+		iphone_gpio_custom_io(i2c->iic_scl_gpio, ((i % 2) == 1) ? 0xE : 0x0);
+		udelay(5);
+	}
+
+	iphone_gpio_custom_io(i2c->iic_scl_gpio, 0x2);	// generate stop condition?
+	iphone_gpio_custom_io(i2c->iic_sda_gpio, 0x2);
+	printk("iphone-i2c: init done!\n");
+}
+
+static I2CError iphone_i2c_readwrite(I2CInfo* i2c) {
+	__raw_writel(i2c->iiccon_settings, i2c->register_IICCON);
+
+	i2c->iiccon_settings |= IICCON_ACKGEN;
+	i2c->state = I2CSetup;
+	i2c->operation_result = 0;
+	i2c->error_code = I2CNoError;
+
+	__raw_writel(IICCON_INIT, i2c->register_20);
+
+	do_i2c(i2c);
+
+	if(i2c->error_code != I2CNoError)
+		return i2c->error_code;
+
+	while(1) {
+		int hardware_status;
+		do {
+			hardware_status = __raw_readl(i2c->register_20);
+			__raw_writel(hardware_status, i2c->register_20);
+			i2c->operation_result &= ~hardware_status;
+			udelay(5);
+		} while(hardware_status != 0);
+
+		if(i2c->state == I2CDone) {
+			break;
+		}
+
+		do_i2c(i2c);
+	}
+	
+	if(i2c->error_code != I2CNoError)
+	{
+		printk("I2C %s Command Failed!\n", i2c->is_write ? "Write" : "Read");
+	}
+	return i2c->error_code;
+}
+
+static void do_i2c(I2CInfo* i2c) {
+	int proceed = 0;
+	while(i2c->operation_result == 0 || proceed) {
+		proceed = 0;
+		switch(i2c->state) {
+			case I2CSetup:
+				__raw_writel(i2c->iiccon_settings | IICCON_ACKGEN, i2c->register_IICCON);
+				i2c->operation_result = OPERATION_SEND;
+				if(i2c->is_write) {
+					__raw_writel(i2c->address & ~1, i2c->register_IICDS);
+					i2c->current_iicstat =
+						(IICSTAT_MODE_MASTERTX << IICSTAT_MODE_SHIFT)
+						| (IICSTAT_STARTSTOPGEN_START << IICSTAT_STARTSTOPGEN_SHIFT)
+						| (1 << IICSTAT_DATAOUTPUT_ENABLE_SHIFT);
+					i2c->state = I2CTx;
+				} else {
+					__raw_writel(i2c->address | 1, i2c->register_IICDS);
+					i2c->current_iicstat =
+						(IICSTAT_MODE_MASTERRX << IICSTAT_MODE_SHIFT)
+						| (IICSTAT_STARTSTOPGEN_START << IICSTAT_STARTSTOPGEN_SHIFT)
+						| (1 << IICSTAT_DATAOUTPUT_ENABLE_SHIFT);
+					i2c->state = I2CRxSetup;
+				}
+				__raw_writel(i2c->current_iicstat, i2c->register_IICSTAT);
+				i2c->cursor = 0;
+				break;
+			case I2CTx:
+				if((__raw_readl(i2c->register_IICSTAT) & IICSTAT_LASTRECEIVEDBIT) == 0) {
+					if(i2c->cursor != i2c->bufferLen) {
+						// need to send more from the register list
+						i2c->operation_result = OPERATION_SEND;
+						__raw_writel(i2c->buffer[i2c->cursor++], i2c->register_IICDS);
+						__raw_writel(i2c->iiccon_settings | IICCON_INTPENDING | IICCON_ACKGEN, i2c->register_IICCON);
+					} else {
+						i2c->state = I2CFinish;
+						proceed = 1;
+					}
+				} else {
+					// ack not received
+					printk("iphone-i2c: ack not received before byte %d\n", i2c->cursor);
+					i2c->error_code = -1;
+					i2c->state = I2CFinish;
+					proceed = 1;
+				}
+				break;
+			case I2CRx:
+				i2c->buffer[i2c->cursor++] = __raw_readl(i2c->register_IICDS);
+				// fall into I2CRxSetup
+			case I2CRxSetup:
+				if(i2c->cursor != 0 || (__raw_readl(i2c->register_IICSTAT) & IICSTAT_LASTRECEIVEDBIT) == 0) {
+					if(i2c->cursor != i2c->bufferLen) {
+						if((i2c->bufferLen - i2c->cursor) == 1) {
+							// last byte
+							i2c->iiccon_settings &= ~IICCON_ACKGEN;
+						}
+						i2c->operation_result = OPERATION_SEND;
+						__raw_writel(i2c->iiccon_settings | IICCON_INTPENDING, i2c->register_IICCON);
+						i2c->state = I2CRx;
+					} else {
+						i2c->state = I2CFinish;
+					}
+				} else {
+					i2c->error_code = -1;
+					i2c->state = I2CFinish;
+					proceed = 1;
+				}
+				break;
+			case I2CFinish:
+				i2c->operation_result = OPERATION_CONDITIONCHANGE;
+				/* Is this legal? */
+				if(i2c->send_stop) {
+					i2c->current_iicstat &= ~(IICSTAT_STARTSTOPGEN_MASK << IICSTAT_STARTSTOPGEN_SHIFT);
+					if(i2c->is_write) {
+						// turn off the tx bit in the mode
+						i2c->current_iicstat &= ~(IICSTAT_MODE_SLAVETX << IICSTAT_MODE_SHIFT);
+					}
+				} else {
+					i2c->current_iicstat = (IICSTAT_MODE_MASTERRX << IICSTAT_MODE_SHIFT) | (IICSTAT_STARTSTOPGEN_MASK << IICSTAT_STARTSTOPGEN_SHIFT);
+				}
+
+				__raw_writel(i2c->current_iicstat, i2c->register_IICSTAT);
+				__raw_writel(i2c->iiccon_settings | IICCON_INTPENDING, i2c->register_IICCON);
+				i2c->state =I2CDone;
+				break;
+			case I2CDone:
+				// should not occur
+				break;
+		}
+	}
+}
+
+static int iphone_i2c_xfer(struct i2c_adapter *adapter,
+			      struct i2c_msg *msgs, int num)
+{
+	int ret = 0;
+	int bus, send_stop, i;
+	struct i2c_msg *msg;
+	for(i=0; i<num; i++)
+	{
+		msg = &msgs[i];
+		send_stop = (i == num-1) || (msgs[i+1].addr != msg->addr);
+		bus = adapter->nr;
+
+		if(msg->flags & I2C_M_RD)
+			ret = iphone_i2c_recv(bus, msg->addr, send_stop, msg->buf, msg->len);
+		else			
+			ret = iphone_i2c_send(bus, msg->addr, send_stop, msg->buf, msg->len);
+
+		if(ret != I2CNoError)
+			return -EIO;
+	}
+
+	return num;
+}
+
+/*	TEMPORARY LEGACY SUPPORT	*/
+
+I2CError iphone_i2c_rx(int bus, int iicaddr, const uint8_t* registers, int num_regs, void* buffer, int len)
+{
+         I2CError ret;
+         struct i2c_msg xfer[2];
+ 
+         /* Write register */
+         xfer[0].addr = iicaddr;
+         xfer[0].flags = 0;
+         xfer[0].len = num_regs;
+         xfer[0].buf = (u8 *)registers;
+
+         xfer[1].addr = iicaddr;
+         xfer[1].flags = I2C_M_RD;
+         xfer[1].len = len;
+         xfer[1].buf = (u8 *)buffer;
+ 
+         ret = iphone_i2c_xfer(NULL, xfer, 2);
+         return ret;
+}
+
+I2CError iphone_i2c_tx(int bus, int iicaddr, void* buffer, int len)
+{
+         I2CError ret;
+         struct i2c_msg xfer[1];
+ 
+         /* Write register */
+         xfer[0].addr = iicaddr;
+         xfer[0].flags = 0;
+         xfer[0].len = len;
+         xfer[0].buf = (u8 *)buffer;
+ 
+         ret = iphone_i2c_xfer(NULL, xfer, 1);
+         return ret;
+}
+
+
+static u32 iphone_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BYTE_DATA;
+}
+
+static const struct i2c_algorithm iphone_i2c_algorithm = {
+	.master_xfer		= iphone_i2c_xfer,
+	.functionality		= iphone_i2c_func,
+};
+
+static struct i2c_adapter iphone_i2c0 = {
+	.nr 		= 0,
+	.owner		= THIS_MODULE,
+	.class    	= 0, 
+	.algo		= &iphone_i2c_algorithm,
+};
+
+static struct i2c_adapter iphone_i2c1 = {
+	.nr 		= 1,
+	.owner		= THIS_MODULE,
+	.class    	= 0, 
+	.algo		= &iphone_i2c_algorithm,
+};
+
+static int __init iphone_i2c_init(void)
+{
+	int ret = 0;
+
+	iphone_i2c_setup();	
+	printk("iphone-i2c: Initialising I2C busses!\n");
+
+	ret = i2c_add_numbered_adapter(&iphone_i2c0);
+	if(ret)
+	{
+		printk("iphone-i2c: Failed to add I2C Bus #0: %d\n", ret);
+		return ret;
+	}
+
+	ret = i2c_add_numbered_adapter(&iphone_i2c1);
+	if(ret)
+	{
+		printk("iphone-i2c: Failed to add I2C Bus #1: %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static void __exit iphone_i2c_exit(void)
+{
+	i2c_del_adapter(&iphone_i2c0);
+	i2c_del_adapter(&iphone_i2c1);
+}
+
+module_init(iphone_i2c_init);
+module_exit(iphone_i2c_exit);
+
+static struct resource iphone_i2c_resources[] = {
+	[0] = {
+		.start  = I2C0,
+		.end    = I2C0 + 0x1000 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = I2C1,
+		.end    = I2C1 + 0x1000 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device iphone_i2c = {
+	.name           = "iphone-i2c",
+	.id             = -1,
+	.num_resources  = ARRAY_SIZE(iphone_i2c_resources),
+	.resource       = iphone_i2c_resources,
+};
+
+MODULE_AUTHOR("Fredrik Gustafsson <frgustaf@kth.se>");
+MODULE_DESCRIPTION("iPhone i2c adapter");
+MODULE_LICENSE("GPL");
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/ftl/ftl.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/ftl/ftl.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/ftl/ftl.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/ftl/ftl.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,9 @@
+#ifndef IPHONE_FTL_H
+#define IPHONE_FTL_H
+
+int ftl_setup(void);
+bool ftl_sync(void);
+int FTL_Write(u32 logicalPageNumber, int totalPagesToWrite, u8* pBuf);
+int FTL_Read(u32 logicalPageNumber, int totalPagesToRead, u8* pBuf);
+
+#endif
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/ftl/nand.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/ftl/nand.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/ftl/nand.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/ftl/nand.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,75 @@
+#ifndef IPHONE_NAND_H
+#define IPHONE_NAND_H
+#include <linux/io.h>
+
+typedef struct NANDFTLData {
+	u16 sysSuBlks;
+	u16 field_2;
+	u16 field_4;		// reservoir blocks?
+	u16 field_6;
+	u16 field_8;
+} NANDFTLData;
+
+typedef struct SpareData {
+	union {
+		struct {
+			u32 logicalPageNumber;
+			u32 usn;
+		} __attribute__ ((packed)) user;
+
+		struct {
+			u32 usnDec;
+			u16 idx;
+			u8 field_6;
+			u8 field_7;
+		} __attribute__ ((packed)) meta;
+	};
+
+	u8 type2;
+	u8 type1;
+	u8 eccMark;
+	u8 field_B;
+
+} __attribute__ ((packed)) SpareData;
+
+typedef struct NANDData {
+	u32 field_0;
+	u16 field_4;
+	u16 sectorsPerPage;
+	u16 pagesPerBlock;
+	u16 pagesPerSuBlk;
+	u32 pagesPerBank;
+	u32 pagesTotal;
+	u16 suBlksTotal;
+	u16 userSuBlksTotal;
+	u32 userPagesTotal;
+	u16 blocksPerBank;
+	u16 bytesPerPage;
+	u16 bytesPerSpare;
+	u16 field_22;
+	u32 field_24;
+	u32 DeviceID;
+	u16 banksTotal;
+	u8 field_2E;
+	u8 field_2F;
+	int* banksTable;
+} NANDData;
+
+#define SECTOR_SIZE 512
+
+#define ERROR_EMPTYBLOCK 1
+#define ERROR_ECC 2
+
+extern struct platform_device iphone_nand;
+
+int nand_read(int bank, int page, u8* buffer, u8* spare, bool doECC, bool checkBlank);
+int nand_read_multiple(u16* bank, u32* pages, u8* main, SpareData* spare, int pagesCount);
+int nand_read_alternate_ecc(int bank, int page, u8* buffer);
+int nand_erase(int bank, int block);
+int nand_write(int bank, int page, u8* buffer, u8* spare, bool doECC);
+int nand_bank_reset(int bank, int timeout);
+NANDFTLData* nand_get_ftl_data(void);
+NANDData* nand_get_geometry(void);
+int nand_setup(void);
+
+#endif
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/ftl/vfl.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/ftl/vfl.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/ftl/vfl.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/ftl/vfl.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,30 @@
+#ifndef IPHONE_VFL_H
+#define IPHONE_VFL_H
+
+#include <linux/io.h>
+#include <ftl/nand.h>
+
+typedef struct VFLData1Type {
+	u64 field_0;
+	u64 field_8;
+	u64 field_10;
+	u64 field_18;
+	u64 field_20;
+	u64 field_28;
+	u64 field_30;
+	u64 field_38;
+	u64 field_40;
+} VFLData1Type;
+
+int VFL_Verify(void);
+int VFL_Init(void);
+int VFL_Open(void);
+int VFL_StoreFTLCtrlBlock(u16* ftlctrlblock);
+u16* VFL_GetFTLCtrlBlock(void);
+bool VFL_ReadScatteredPagesInVb(u32* virtualPageNumber, int count, u8* main, SpareData* spare);
+bool VFL_ReadMultiplePagesInVb(int logicalBlock, int logicalPage, int count, u8* main, SpareData* spare);
+int VFL_Write(u32 virtualPageNumber, u8* buffer, u8* spare);
+int VFL_Read(u32 virtualPageNumber, u8* buffer, u8* spare, bool empty_ok);
+int VFL_Erase(u16 block);
+
+#endif
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/accel.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/accel.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/accel.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/accel.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,39 @@
+#ifndef HW_ACCEL_H
+#define HW_ACCEL_H
+
+// See http://www.st.com/stonline/products/literature/ds/12726.pdf
+
+#define ACCEL_I2C_BUS 0
+
+// could be 0x72 and 0x73 as well
+#define ACCEL_SETADDR	0x3A
+#define ACCEL_GETADDR	0x3B
+
+#define ACCEL_WHOAMI	0x0F
+#define ACCEL_CTRL_REG1	0x20
+#define ACCEL_CTRL_REG2	0x21
+#define ACCEL_STATUS	0x27
+#define ACCEL_OUTX	0x29
+#define ACCEL_OUTY	0x2B
+#define ACCEL_OUTZ	0x2D
+
+#define ACCEL_WHOAMI_VALUE	0x3B
+
+#define ACCEL_CTRL_REG1_DR	(1 << 7)
+#define ACCEL_CTRL_REG1_PD	(1 << 6)
+#define ACCEL_CTRL_REG1_FS	(1 << 5)
+#define ACCEL_CTRL_REG1_STP	(1 << 4)
+#define ACCEL_CTRL_REG1_STM	(1 << 3)
+#define ACCEL_CTRL_REG1_ZEN	(1 << 2)
+#define ACCEL_CTRL_REG1_YEN	(1 << 1)
+#define ACCEL_CTRL_REG1_XEN	(1 << 0)
+
+#define ACCEL_CTRL_REG2_SIM	(1 << 7)
+#define ACCEL_CTRL_REG2_BOOT	(1 << 6)
+#define ACCEL_CTRL_REG2_FDS	(1 << 4)
+#define ACCEL_CTRL_REG2_HPEN2	(1 << 3)
+#define ACCEL_CTRL_REG2_HPEN1	(1 << 2)
+#define ACCEL_CTRL_REG2_HP2	(1 << 1)
+#define ACCEL_CTRL_REG2_HP1	(1 << 0)
+
+#endif
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/debug-macro.S iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/debug-macro.S
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/debug-macro.S	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/debug-macro.S	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,33 @@
+/* arch/arm/mach-apple_iphone/include/mach/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include <mach/hardware.h>
+
+		.macro	addruart, rx, tmp
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		ldreq	\rx, =0x3CC00000
+		ldrne	\rx, =IO_ADDRESS(0x3CC00000)
+		.endm
+
+		.macro  senduart, rd, rx
+		str     \rd, [\rx, #0x20]       @ UTXH
+		.endm
+
+		.macro  waituart, rd, rx
+		.endm
+
+		.macro  busyuart, rd, rx
+1001:		ldr     \rd, [\rx, #0x10]	@ UTRSTAT
+		tst     \rd, #1 << 2
+		beq	1001b
+		.endm
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/dma.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/dma.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/dma.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/dma.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,63 @@
+#ifndef IPHONE_HW_DMA_H
+#define IPHONE_HW_DMA_H
+
+#include <mach/hardware.h>
+
+// This thing appears to be a PL080
+
+// Device
+#define DMAC0_PA 0x38200000
+#define DMAC1_PA 0x39900000
+#define DMAC0 IO_ADDRESS(DMAC0_PA)
+#define DMAC1 IO_ADDRESS(DMAC1_PA)
+
+// Registers
+#define DMACIntStatus 0
+#define DMACIntTCStatus 0x4
+#define DMACIntTCClear 0x8
+#define DMACConfiguration 0x30
+#define DMAC0SrcAddress 0x100
+#define DMAC0DestAddress 0x104
+#define DMAC0LLI 0x108
+#define DMAC0Control0 0x10C
+#define DMAC0Configuration 0x110
+
+// Values
+#define DMAC0_INTERRUPT 0x10
+#define DMAC1_INTERRUPT 0x11
+#define DMAC0_CLOCKGATE 0x19
+#define DMAC1_CLOCKGATE 0x1A
+
+#define IPHONE_DMA_NUMCHANNELS 8
+#define IPHONE_DMA_NUMCONTROLLERS 2
+
+#define DMAChannelRegSize 32
+#define DMACConfiguration_ENABLE 1
+#define DMAC0Control0_SWIDTHSHIFT 18
+#define DMAC0Control0_DWIDTHSHIFT 21
+#define DMAC0Control0_DWIDTH(x) GET_BITS(x, 21, 3)
+#define DMAC0Control0_WIDTHBYTE 0
+#define DMAC0Control0_WIDTHHALFWORD 1
+#define DMAC0Control0_WIDTHWORD 2
+#define DMAC0Control0_SBSIZESHIFT 12
+#define DMAC0Control0_DBSIZESHIFT 15
+#define DMAC0Control0_TERMINALCOUNTINTERRUPTENABLE 31
+#define DMAC0Control0_SOURCEAHBMASTERSELECT 24
+#define DMAC0Control0_SOURCEAHBMASTERSELECT 24
+#define DMAC0Control0_SOURCEINCREMENT 26
+#define DMAC0Control0_DESTINATIONINCREMENT 27
+#define DMAC0Control0_SIZEMASK 0xFFF
+
+#define DMAC0Configuration_SRCPERIPHERALSHIFT 1
+#define DMAC0Configuration_DESTPERIPHERALSHIFT 6
+#define DMAC0Configuration_FLOWCNTRLSHIFT 11
+#define DMAC0Configuration_FLOWCNTRLMASK 0x7
+#define DMAC0Configuration_FLOWCNTRL_M2M 0x0
+#define DMAC0Configuration_FLOWCNTRL_M2P 0x1
+#define DMAC0Configuration_FLOWCNTRL_P2M 0x2
+#define DMAC0Configuration_FLOWCNTRL_P2P 0x3
+#define DMAC0Configuration_CHANNELENABLED (1 << 0)
+#define DMAC0Configuration_TERMINALCOUNTINTERRUPTMASK (1 << 15)
+
+#endif
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/entry-macro.S iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/entry-macro.S
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/entry-macro.S	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/entry-macro.S	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,32 @@
+/*
+ * arch/arm/mach-apple_iphone/include/mach/entry-macro.S
+ *
+ * Low-level IRQ helper macros for the Apple iPhone
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <mach/hardware.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr	\base, =IO_ADDRESS(0x38E00000)
+		ldr	\irqstat, [\base, #0]           @ get masked status
+		cmp	\irqstat, #0
+		addeq	\base, \base, #0x1000
+		ldreq	\irqstat, [\base, #0]           @ get masked status
+		cmpeq	\irqstat, #0
+		ldr	\irqnr, [\base, #0xF00]         @ read for VICADDR[01]
+		.endm
+
+		.macro irq_prio_table
+		.endm
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/gpio.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/gpio.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/gpio.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/gpio.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,139 @@
+#ifndef IPHONE_HW_GPIO_H
+#define IPHONE_HW_GPIO_H
+
+#include <linux/interrupt.h>
+#include <mach/hardware.h>
+
+// Device
+#define GPIOIC IO_ADDRESS(0x39A00000)	/* probably a part of the system controller */
+#define GPIO IO_ADDRESS(0x3E400000)
+
+// Registers
+#define GPIO_INTLEVEL 0x80
+#define GPIO_INTSTAT 0xA0
+#define GPIO_INTEN 0xC0
+#define GPIO_INTTYPE 0xE0
+#define GPIO_FSEL 0x320
+
+#define GPIO_IO 0x320
+
+// Values
+#define GPIO_NUMINTGROUPS 7
+#define GPIO_INTSTAT_RESET 0xFFFFFFFF
+#define GPIO_INTEN_RESET 0
+
+#define GPIO_IO_MAJSHIFT 16
+#define GPIO_IO_MAJMASK 0x1F
+#define GPIO_IO_MINSHIFT 8
+#define GPIO_IO_MINMASK 0x7
+#define GPIO_IO_USHIFT 0
+#define GPIO_IO_UMASK 0xF
+
+#define GPIO_CLOCKGATE 0x2C
+
+#define GPIO_DETECT1 0xE04
+#define GPIO_DETECT2 0xE05
+#define GPIO_DETECT3 0xE06
+
+#define GPIO_BUTTONS_HOME_IPHONE 0x1600
+#define GPIO_BUTTONS_HOME_IPOD 0x1606
+
+#ifdef CONFIG_IPODTOUCH_1G
+#define GPIO_BUTTONS_HOME GPIO_BUTTONS_HOME_IPOD
+#define GPIO_BUTTONS_HOME_IRQ 0x2E
+#else
+#define GPIO_BUTTONS_HOME GPIO_BUTTONS_HOME_IPHONE
+#define GPIO_BUTTONS_HOME_IRQ 0x28
+#endif
+
+#define GPIO_BUTTONS_HOLD 0x1605
+#define GPIO_BUTTONS_HOLD_IRQ 0x2D
+
+#ifndef CONFIG_IPODTOUCH_1G
+#define GPIO_BUTTONS_VOLUP 0x1601
+#define GPIO_BUTTONS_VOLUP_IRQ 0x29
+
+#define GPIO_BUTTONS_VOLDOWN 0x1602
+#define GPIO_BUTTONS_VOLDOWN_IRQ 0x2A
+
+#define GPIO_BUTTONS_RINGERAB 0x1603
+#define GPIO_BUTTONS_RINGERAB_IRQ 0x2B
+#endif
+
+typedef struct GPIORegisters {
+	volatile uint32_t CON;
+	volatile uint32_t DAT;
+	volatile uint32_t PUD;
+	volatile uint32_t CONSLP;
+	volatile uint32_t PUDSLP;
+	volatile uint32_t unused1;
+	volatile uint32_t unused2;
+	volatile uint32_t unused3;
+} GPIORegisters;
+
+int iphone_gpio_pin_state(int port);
+void iphone_gpio_custom_io(int port, int bits);
+void iphone_gpio_pin_reset(int port);
+void iphone_gpio_pin_output(int port, int bit);
+int iphone_gpio_detect_configuration(void);
+int gpio_to_irq(unsigned gpio);
+int irq_to_gpio(unsigned irq);
+
+static inline int gpio_request(unsigned gpio, const char *label)
+{
+	return 0;
+}
+
+static inline void gpio_free(unsigned gpio)
+{
+}
+
+static inline int gpio_get_value(unsigned gpio)
+{
+	return iphone_gpio_pin_state(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+	iphone_gpio_pin_output(gpio, value);
+}
+
+static inline int gpio_cansleep(unsigned gpio)
+{
+	return 0;
+}
+
+static inline int gpio_get_value_cansleep(unsigned gpio)
+{
+	might_sleep();
+	return gpio_get_value(gpio);
+}
+
+static inline void gpio_set_value_cansleep(unsigned gpio, int value)
+{
+	might_sleep();
+	gpio_set_value(gpio, value);
+}
+
+static inline int gpio_is_valid(int number)
+{
+	if(number > 0 && number < 0x1808)
+		return 1;
+	else
+		return 0;
+}
+
+static inline int gpio_direction_input(unsigned gpio)
+{
+	iphone_gpio_pin_reset(gpio);
+	return 0;
+}
+
+static inline int gpio_direction_output(unsigned gpio, int value)
+{
+	iphone_gpio_pin_output(gpio, value);
+	return 0;
+}
+
+#endif
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/hardware.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/hardware.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/hardware.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/hardware.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,31 @@
+/*
+ *  arch/arm/mach-versatile/include/mach/hardware.h
+ *
+ *  This file contains the hardware definitions of the Versatile boards.
+ *
+ *  Copyright (C) 2003 ARM Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <mach/platform.h>
+
+/* macro to get at IO space when running virtually */
+#define IO_ADDRESS(x)		(((x) - 0x38000000) + 0xf0000000)
+
+#endif
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/i2c.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/i2c.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/i2c.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/i2c.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,57 @@
+#ifndef IPHONE_HW_I2C_H
+#define IPHONE_HW_I2C_H
+
+#include <mach/hardware.h>
+
+// Device
+#define I2C0 IO_ADDRESS(0x3C600000)
+#define I2C1 IO_ADDRESS(0x3C900000)
+
+// Registers
+#define IICCON 0x0
+#define IICSTAT 0x4
+#define IICADD 0x8
+#define IICDS 0xC
+#define IICLC 0x10
+#define IICREG14 0x14
+#define IICREG18 0x18
+#define IICREG1C 0x1C
+#define IICREG20 0x20
+
+// Values
+#define IICCON_INIT 0x3F00
+#define IICCON_ACKGEN (1 << 7)
+#define IICCON_TXCLKSRC_FPCLK16 (0 << 6)
+#define IICCON_TXCLKSRC_FPCLK512 (1 << 6)
+#define IICCON_INTENABLE (1 << 5)
+#define IICCON_INTPENDING (1 << 4)
+#define IICCON_TXCLKPRESCALEMASK 0xF
+
+#define IICSTAT_MODE_SLAVERX 0
+#define IICSTAT_MODE_SLAVETX 1
+#define IICSTAT_MODE_MASTERRX 2
+#define IICSTAT_MODE_MASTERTX 3
+#define IICSTAT_MODE_SHIFT 6
+#define IICSTAT_MODE_MASK 3
+#define IICSTAT_STARTSTOPGEN_START 1
+#define IICSTAT_STARTSTOPGEN_STOP 0
+#define IICSTAT_STARTSTOPGEN_MASK 1
+#define IICSTAT_STARTSTOPGEN_SHIFT 5
+#define IICSTAT_DATAOUTPUT_ENABLE_SHIFT 4
+#define IICSTAT_LASTRECEIVEDBIT (1 << 0)
+
+#define I2C0_SCL_GPIO 0xB02
+#define I2C0_SDA_GPIO 0xB03
+#define I2C1_SCL_GPIO 0x801
+#define I2C1_SDA_GPIO 0x802
+
+#define I2C0_CLOCKGATE 0x24
+#define I2C1_CLOCKGATE 0x26
+
+#define TXFREQ 25000
+
+#define OPERATION_SEND (1 << 8)
+#define OPERATION_CONDITIONCHANGE (1 << 13)
+
+#endif
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/io.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/io.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/io.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/io.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,32 @@
+/*
+ *  arch/arm/mach-apple_iphone/include/mach/io.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *)addr;
+}
+#define __io(a)	__io(a)
+#define __mem_pci(a)		(a)
+
+#endif
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/iphone-clock.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/iphone-clock.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/iphone-clock.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/iphone-clock.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,33 @@
+/*
+ *  arch/arm/mach-apple_iphone/clock.h
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define FREQUENCY_CPU 412000000
+#define FREQUENCY_MEMORY 137333333
+#define FREQUENCY_BUS 103000000
+#define FREQUENCY_PERIPHERAL 51500000
+#define FREQUENCY_DISPLAY 54000000
+#define FREQUENCY_FIXED 24000000
+#define FREQUENCY_TIMEBASE 6000000
+#define FREQUENCY_BASE 12000000
+
+extern int iphone_power_ctrl(u32 device, int on_off);
+extern void iphone_clock_gate_switch(u32 gate, int on_off);
+extern u64 iphone_microtime(void);
+extern int iphone_has_elapsed(u64 startTime, u64 elapsedTime);
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/iphone-dma.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/iphone-dma.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/iphone-dma.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/iphone-dma.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,53 @@
+#ifndef IPHONE_DMA_H
+#define IPHONE_DMA_H
+#include <linux/sched.h>
+
+#define ERROR_DMA 0x13
+#define ERROR_BUSY 0x15
+#define ERROR_ALIGN 0x9
+
+typedef void request_done(int controller, int channel, void* token);
+
+typedef volatile struct DMARequest {
+	bool started;
+	bool done;
+	struct task_struct* task;
+	int controller;
+	int channel;
+	void (*done_handler)(int controller, int channel, void* token);
+	void* token;
+	// TODO: fill this thing out
+} DMARequest;
+
+typedef struct DMALinkedList {
+    u32 source;
+    u32 destination;
+    u32 next;
+    u32 control;
+} DMALinkedList;
+
+#define IPHONE_DMA_I2S0_RX 19
+#define IPHONE_DMA_I2S0_TX 20
+#define IPHONE_DMA_I2S1_RX 14
+#define IPHONE_DMA_I2S1_TX 15
+#define IPHONE_DMA_MEMORY 25
+#define IPHONE_DMA_NAND 8
+
+extern struct platform_device iphone_dma;
+
+int iphone_dma_setup(void);
+int iphone_dma_request(int Source, int SourceTransferWidth, int SourceBurstSize, int Destination, int DestinationTransferWidth, int DestinationBurstSize, int* controller, int* channel);
+void iphone_dma_set_done_handler(int* controller, int* channel, void (*done_handler)(int controller, int channel, void* token), void* token);
+void iphone_dma_create_continue_list(dma_addr_t Source, dma_addr_t Destination, int size, int* controller, int* channel,
+		DMALinkedList** continueList, dma_addr_t* phys, size_t* list_size, DMALinkedList** last);
+size_t iphone_dma_continue_list_size(dma_addr_t Source, dma_addr_t Destination, int size, int* controller, int* channel);
+int iphone_dma_prepare(dma_addr_t Source, dma_addr_t Destination, int size, DMALinkedList* continueList, int* controller, int* channel);
+int iphone_dma_perform(dma_addr_t Source, dma_addr_t Destination, int size, DMALinkedList* continueList, int* controller, int* channel);
+int iphone_dma_finish(int controller, int channel, int timeout);
+dma_addr_t iphone_dma_dstpos(int controller, int channel);
+dma_addr_t iphone_dma_srcpos(int controller, int channel);
+void iphone_dma_resume(int controller, int channel);
+void iphone_dma_pause(int controller, int channel);
+
+#endif
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/iphone-i2c.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/iphone-i2c.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/iphone-i2c.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/iphone-i2c.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,56 @@
+#ifndef I2C_H
+#define I2C_H
+
+typedef enum I2CError {
+	I2CNoError = 0
+} I2CError;
+
+typedef enum I2CState {
+	I2CDone = 0,
+	I2CSetup = 1,
+	I2CTx = 2,
+	I2CRx = 3,
+	I2CRxSetup = 4,
+	I2CFinish = 5
+} I2CState;
+
+
+typedef struct I2CInfo {
+	struct mutex* rw_sem;
+	uint32_t frequency;
+	I2CError error_code;
+	int is_write;
+	int cursor;
+	int send_stop;
+	I2CState state;
+	int operation_result;
+	uint32_t address;
+	uint32_t iiccon_settings;
+	uint32_t current_iicstat;
+	int num_regs;
+	const uint8_t* registers;
+	int bufferLen;
+	uint8_t* buffer;
+	uint32_t iic_scl_gpio;
+	uint32_t iic_sda_gpio;
+	uint32_t register_IICCON;
+	uint32_t register_IICSTAT;
+	uint32_t register_IICADD;
+	uint32_t register_IICDS;
+	uint32_t register_IICLC;
+	uint32_t register_14;
+	uint32_t register_18;
+	uint32_t register_1C;
+	uint32_t register_20;
+} I2CInfo;
+
+extern struct platform_device iphone_i2c;
+
+I2CError iphone_i2c_recv(int bus, int iicaddr, int send_stop, void* buffer, int len);
+I2CError iphone_i2c_send(int bus, int iicaddr, int send_stop, const void* buffer, int len);
+
+/* Legacy support */
+I2CError iphone_i2c_rx(int bus, int iicaddr, const uint8_t* registers, int num_regs, void* buffer, int len);
+I2CError iphone_i2c_tx(int bus, int iicaddr, void* buffer, int len);
+
+#endif
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/iphone-spi.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/iphone-spi.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/iphone-spi.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/iphone-spi.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,41 @@
+#ifndef IPHONE_SPI_H
+#define IPHONE_SPI_H
+
+#define GPIO_SPI0_CS0_IPHONE 0x400
+#define GPIO_SPI0_CS0_IPOD 0x700
+
+#ifdef CONFIG_IPODTOUCH_1G
+#define GPIO_SPI2_CS0 0x1804
+#define GPIO_SPI2_CS1 0x705
+#endif
+
+#ifdef CONFIG_IPHONE_2G
+#define GPIO_SPI2_CS0 0x705
+#endif
+
+#ifdef CONFIG_IPODTOUCH_1G
+#define GPIO_SPI0_CS0 GPIO_SPI0_CS0_IPOD
+#else
+#define GPIO_SPI0_CS0 GPIO_SPI0_CS0_IPHONE
+#endif
+
+#define GPIO_SPI1_CS0 0x1800
+
+#ifdef CONFIG_IPHONE_3G
+#define GPIO_SPI0_CS1 0x705
+#define GPIO_SPI0_CS2 0x706
+#endif
+
+typedef enum SPIOption13 {
+	SPIOption13Setting0 = 8,
+	SPIOption13Setting1 = 16,
+	SPIOption13Setting2 = 32
+} SPIOption13;
+
+void iphone_spi_set_baud(int port, int baud, SPIOption13 option13, bool isMaster, bool isActiveLow, bool lastClockEdgeMissing);
+int iphone_spi_tx(int port, const u8* buffer, int len, bool block, bool unknown);
+int iphone_spi_rx(int port, u8* buffer, int len, bool block, bool noTransmitJunk);
+int iphone_spi_txrx(int port, const u8* outBuffer, int outLen, u8* inBuffer, int inLen, bool block);
+
+#endif
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/irqs.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/irqs.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/irqs.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/irqs.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,27 @@
+/*
+ *  arch/arm/mach-apple_iphone/include/mach/irqs.h
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <mach/platform.h>
+
+#define IPHONE_NR_VIC_IRQS 0x40
+#define IPHONE_NR_GPIO_IRQS (7 * 32)
+#define IPHONE_GPIO_IRQS IPHONE_NR_VIC_IRQS
+#define NR_IRQS	(IPHONE_NR_VIC_IRQS + IPHONE_NR_GPIO_IRQS)
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/map.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/map.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/map.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/map.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,17 @@
+#ifndef __ASM_ARCH_MAP_H
+#define __ASM_ARCH_MAP_H __FILE__
+
+#include <mach/hardware.h>
+
+#define S3C_PA_USB_HSPHY    (0x3C400000)
+#define S3C_VA_USB_HSPHY    IO_ADDRESS(0x3C400000)
+
+#define S3C_PA_USB_HSOTG    (0x38400000)
+#define S3C_VA_USB_HSOTG    IO_ADDRESS(0x38400000)
+
+#define IPHONE_USB_POWER    (0x200)
+#define IPHONE_USB_CLOCK    (0x2)
+#define IPHONE_USBPHY_CLOCK (0x23)
+#define IPHONE_EDRAM_CLOCK  (0x1B)
+
+#endif
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/memory.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/memory.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/memory.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/memory.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,28 @@
+/*
+ *  arch/arm/mach-versatile/include/mach/memory.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x00000000)
+
+#endif
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/nand.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/nand.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/nand.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/nand.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,59 @@
+#ifndef IPHONE_HW_NAND_H
+#define IPHONE_HW_NAND_H
+#include <mach/hardware.h>
+
+// Device
+#define NAND IO_ADDRESS(0x38A00000)
+#define NANDECC IO_ADDRESS(0x38F00000)
+#define NAND_CLOCK_GATE1 0x8
+#define NAND_CLOCK_GATE2 0xC
+#define NANDECC_INT 0x2B
+
+
+// Registers
+#define NAND_CONFIG 0x0
+#define NAND_CON 0x4
+#define NAND_CMD 0x8
+#define NAND_CONFIG3 0xC
+#define NAND_CONFIG4 0x2C
+#define NAND_CONFIG5 0x10
+#define NAND_TRANSFERSIZE 0x30
+#define NAND_CONFIG6 0x44
+#define NAND_STATUS 0x48
+#define NAND_DMA_SOURCE 0x80
+#define NAND_SETUP 0x100
+
+#define NANDECC_DATA 0x4
+#define NANDECC_ECC 0x8
+#define NANDECC_START 0xC
+#define NANDECC_STATUS 0x10
+#define NANDECC_SETUP 0x14
+#define NANDECC_CLEARINT 0x40
+
+// Values
+
+#define NAND_CONFIG_DEFAULTS 0x801
+#define NAND_CONFIG_SETTING1SHIFT 12
+#define NAND_CONFIG_SETTING2SHIFT 16
+#define NAND_CONFIG_SETTING1MASK 0x7
+#define NAND_CONFIG_SETTING2MASK 0x7
+#define NAND_CONFIG_DMASETTINGSHIFT 10
+
+#define NAND_CMD_RESET 0xFF
+#define NAND_CMD_ID 0x90
+#define NAND_CMD_READSTATUS 0x70
+#define NAND_CMD_READ 0x30
+
+#define NAND_CONFIG4_TRANSFERSETTING 4
+
+#define NAND_CON_ADDRESSDONE (1 << 0)
+#define NAND_CON_SETTING1 0xC0
+#define NAND_CON_SETTING2 0x80
+#define NAND_CON_BEGINTRANSFER (1 << 1)
+
+#define NAND_STATUS_READY 0x1
+
+#define NAND_NUM_BANKS 8
+
+#endif
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/platform.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/platform.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/platform.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/platform.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,24 @@
+/*
+ * arch/arm/mach-apple_iphone/include/mach/platform.h
+ *
+ * Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __address_h
+#define __address_h                     1
+
+#endif
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/pmu.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/pmu.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/pmu.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/pmu.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,125 @@
+#ifndef IPHONE_HW_PMU_H
+#define IPHONE_HW_PMU_H
+
+#define POWER_PCF50633 ((defined(CONFIG_IPHONE_3G)||defined(CONFIG_IPHONE_2G)||defined(CONFIG_IPODTOUCH_1G)) && defined(CONFIG_MFD_PCF50633))
+
+#if POWER_PCF50633
+#include <linux/mfd/pcf50633/core.h>
+#include <linux/mfd/pcf50633/pmic.h>
+#include <linux/mfd/pcf50633/adc.h>
+#include <linux/mfd/pcf50633/mbc.h>
+#endif
+
+#ifdef CONFIG_IPHONE_PMU
+
+#ifdef CONFIG_IPODTOUCH_1G
+#define PMU_I2C_BUS 1
+#else
+#define PMU_I2C_BUS 0
+#endif
+
+// Power
+#define PMU_SETADDR	0xE6
+#define PMU_GETADDR	0xE7
+// Registers
+#define PMU_MAXREG	0xF
+
+// Values
+
+#define PMU_GPIO_CHARGER_IDENTIFY_DN_IPHONE 0x1404
+#define PMU_GPIO_CHARGER_IDENTIFY_DP_IPHONE 0x1405
+#define PMU_GPIO_CHARGER_IDENTIFY_DN_IPOD 0x1603
+#define PMU_GPIO_CHARGER_IDENTIFY_DP_IPOD 0x1604
+
+#ifdef CONFIG_IPODTOUCH_1G
+#define PMU_GPIO_CHARGER_IDENTIFY_DN PMU_GPIO_CHARGER_IDENTIFY_DN_IPOD
+#define PMU_GPIO_CHARGER_IDENTIFY_DP PMU_GPIO_CHARGER_IDENTIFY_DN_IPOD
+#else
+#define PMU_GPIO_CHARGER_IDENTIFY_DN PMU_GPIO_CHARGER_IDENTIFY_DN_IPHONE
+#define PMU_GPIO_CHARGER_IDENTIFY_DP PMU_GPIO_CHARGER_IDENTIFY_DN_IPHONE
+#endif
+
+#define PMU_GPIO_CHARGER_USB_SUSPEND 0x1704
+#define PMU_GPIO_CHARGER_SUSPEND 0x1706
+#define PMU_GPIO_CHARGER_SHUTDOWN 0x1707
+#define PMU_GPIO_CHARGER_USB_500_1000 0x1705
+#define PMU_GPIO_CHARGER_USB_1000 0x704
+
+#define PMU_OOCSHDWN 0xC
+#define PMU_ADCC3 0x52
+#define PMU_ADCC2 0x53
+#define PMU_ADCC1 0x54
+#define PMU_ADCS3 0x57
+#define PMU_ADCS1 0x55
+#define PMU_MBCS1 0x4B
+#define PMU_RTCSC 0x59
+#define PMU_RTCMN 0x5A
+#define PMU_RTCHR 0x5B
+#define PMU_RTCWD 0x5C
+#define PMU_RTCDT 0x5D
+#define PMU_RTCMT 0x5E
+#define PMU_RTCYR 0x5F
+
+#define PMU_RTCSC_MASK 0x7F
+#define PMU_RTCMN_MASK 0x7F
+#define PMU_RTCHR_MASK 0x3F
+#define PMU_RTCWD_MASK 0x07
+#define PMU_RTCDT_MASK 0x3F
+#define PMU_RTCMT_MASK 0x1F
+#define PMU_RTCYR_MASK 0xFF
+
+#define PMU_OOCSHDWN_GOSTBY (1 << 0)
+
+#define PMU_MBCS1_ADAPTPRES (1 << 2)
+#define PMU_MBCS1_USBOK (1 << 0)
+
+#define PMU_ADCC1_ADCINMUX_SHIFT 4
+#define PMU_ADCC1_ADCINMUX_MASK 0xF
+#define PMU_ADCC1_ADC_AV_SHIFT 2
+#define PMU_ADCC1_ADCSTART 0x1
+#define PMU_ADCC1_ADCRES 0x2
+
+#define PMU_ADCC1_ADC_AV_1 0x0
+#define PMU_ADCC1_ADC_AV_4 0x1
+#define PMU_ADCC1_ADC_AV_8 0x2
+#define PMU_ADCC1_ADC_AV_16 0x3
+
+#define PMU_ADCC1_ADCINMUX_BATSNS_DIV 0x0
+#define PMU_ADCC1_ADCINMUX_BATSNS_SUB 0x1
+#define PMU_ADCC1_ADCINMUX_ADCIN2_DIV 0x2
+#define PMU_ADCC1_ADCINMUX_ADCIN2_SUB 0x3
+#define PMU_ADCC1_ADCINMUX_BATTEMP 0x6
+#define PMU_ADCC1_ADCINMUX_ADCIN1 0x7
+
+typedef struct PMURegisterData {
+        uint8_t reg;
+        uint8_t data;
+} PMURegisterData;
+
+typedef enum PowerSupplyType {
+	PowerSupplyTypeError,
+	PowerSupplyTypeBattery,
+	PowerSupplyTypeFirewire,
+	PowerSupplyTypeUSBHost,
+	PowerSupplyTypeUSBBrick500mA,
+	PowerSupplyTypeUSBBrick1000mA
+} PowerSupplyType;
+
+int iphone_pmu_get_battery_voltage(void);
+void iphone_pmu_charge_settings(int UseUSB, int SuspendUSB, int StopCharger);
+PowerSupplyType iphone_pmu_get_power_supply(void);
+
+int iphone_pmu_write_regs(const PMURegisterData* regs, int num);
+
+#endif
+
+#if POWER_PCF50633
+extern struct pcf50633_platform_data pcf50633_pdata;
+#endif
+
+extern void pcf50633_power_off(void);
+
+void iphone_init_suspend(void);
+
+#endif
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/system.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/system.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/system.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/system.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,41 @@
+/*
+ *  arch/arm/mach-apple_iphone/include/mach/system.h
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode, const char* cmd)
+{
+	__raw_writel(0x100000, IO_ADDRESS(0x3E300000));
+}
+
+#endif
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/timex.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/timex.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/timex.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/timex.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,23 @@
+/*
+ *  arch/arm/mach-apple_iphone/include/mach/timex.h
+ *
+ *  Apple iPhone timex specifications
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define CLOCK_TICK_RATE		12000000
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/uart.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/uart.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/uart.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/uart.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,99 @@
+/*
+ *  arch/arm/mach-apple_iphone/include/mach/uart.h
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _IPHONE_MACH_UART_H
+#define _IPHONE_MACH_UART_H
+
+// Devices
+#define UART IO_ADDRESS(0x3CC00000)
+
+// Registers
+#define UART0 0x0
+#define UART1 0x4000
+#define UART2 0x8000
+#define UART3 0xC000
+#define UART4 0x10000
+
+#define UART_ULCON 0x0
+#define UART_UCON 0x4
+#define UART_UFCON 0x8
+#define UART_UMCON 0xC
+#define UART_UTRSTAT 0x10
+#define UART_UERSTAT 0x14
+#define UART_UFSTAT 0x18
+#define UART_UMSTAT 0x1C
+#define UART_UTXH 0x20
+#define UART_URXH 0x24
+#define UART_UBAUD 0x28
+#define UART_UINTP 0x2C
+
+// Values
+#define NUM_UARTS 5
+#define UART_CLOCKGATE 0x29
+
+#define UART_CLOCK_SELECTION_MASK (0x3 << 10) // Bit 10-11
+#define UART_CLOCK_SELECTION_SHIFT 10 // Bit 10-11
+#define UART_UCON_UNKMASK 0x7000
+#define UART_UCON_LOOPBACKMODE (0x1 << 5)
+#define UART_UCON_RXMODE_SHIFT 0
+#define UART_UCON_RXMODE_MASK (0x3 << UART_UCON_RXMODE_SHIFT)
+#define UART_UCON_TXMODE_SHIFT 2
+#define UART_UCON_TXMODE_MASK (0x3 << UART_UCON_TXMODE_SHIFT)
+
+#define UART_FIFO_RESET_TX 0x4
+#define UART_FIFO_RESET_RX 0x2
+#define UART_FIFO_ENABLE 0x1
+
+#define UART_DIVVAL_MASK 0x0000FFFF
+#define UART_SAMPLERATE_MASK 0x00030000 // Bit 16-17
+#define UART_SAMPLERATE_SHIFT 16
+
+#define UART_UCON_MODE_DISABLE 0
+#define UART_UCON_MODE_IRQORPOLL 1
+#define UART_UCON_MODE_DMA0 2
+#define UART_UCON_MODE_DMA1 3
+
+#define UART_CLOCK_PCLK 0
+#define UART_CLOCK_EXT_UCLK0 1
+#define UART_CLOCK_EXT_UCLK1 3
+
+#define UART_SAMPLERATE_4 2
+#define UART_SAMPLERATE_8 1
+#define UART_SAMPLERATE_16 0
+
+#define UART_UMCON_AFC_BIT 0x10
+#define UART_UMCON_NRTS_BIT 0x1
+
+#define UART_UTRSTAT_TRANSMITTEREMPTY 0x4
+#define UART_UTRSTAT_RECEIVEDATAREADY 0x1
+
+#define UART_UMSTAT_CTS 0x1
+
+#define UART_UFSTAT_TXFIFO_FULL (0x1 << 9)
+#define UART_UFSTAT_RXFIFO_FULL (0x1 << 8)
+#define UART_UFSTAT_RXCOUNT_MASK 0xF
+
+#define UART_5BITS 0
+#define UART_6BITS 1
+#define UART_7BITS 2
+#define UART_8BITS 3
+
+#endif
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/uncompress.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/uncompress.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/uncompress.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/uncompress.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,49 @@
+/*
+ *  arch/arm/mach-apple_iphone/include/mach/uncompress.h
+ *
+ *  Copyright (C) 2008 Apple iPhone
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define IPHONE_UART_UFSTAT_TXFIFO_FULL (0x1 << 9)
+#define IPHONE_UART_UTRSTAT_TRANSMITTEREMPTY 0x4
+#define IPHONE_UART0_UTRSTAT (*(volatile unsigned char*)(0x3CC00000 + 0x0 + 0x10))
+#define IPHONE_UART0_UFSTAT (*(volatile unsigned char*)(0x3CC00000 + 0x0 + 0x18))
+#define IPHONE_UART0_UTXH (*(volatile unsigned char*)(0x3CC00000 + 0x0 + 0x20))
+
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+	while ((IPHONE_UART0_UTRSTAT & IPHONE_UART_UTRSTAT_TRANSMITTEREMPTY) == 0)
+		barrier();
+
+	IPHONE_UART0_UTXH = c;
+
+}
+
+static inline void flush(void)
+{
+	while ((IPHONE_UART0_UTRSTAT & IPHONE_UART_UTRSTAT_TRANSMITTEREMPTY) == 0)
+		barrier();
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/usb.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/usb.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/usb.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/usb.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,28 @@
+/*
+ *  arch/arm/mach-apple_iphone/include/mach/usb.h
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef IPHONE_HW_USB_H
+#define IPHONE_HW_USB_H
+
+//extern struct platform_device s3c_device_usb_hsotg;
+void init_iphone_usb(void);
+
+#endif
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/vmalloc.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/vmalloc.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/mach/vmalloc.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/mach/vmalloc.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,21 @@
+/*
+ *  arch/arm/mach-versatile/include/mach/vmalloc.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END		(0xE0000000)
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/plat/regs-sys.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/plat/regs-sys.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/plat/regs-sys.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/plat/regs-sys.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,6 @@
+#ifndef REGS_SYS_H
+#define REGS_SYS_H
+
+#include <mach/hardware.h>
+
+#endif
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/plat/regs-usb-hsotg.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/plat/regs-usb-hsotg.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/plat/regs-usb-hsotg.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/plat/regs-usb-hsotg.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,377 @@
+/* arch/arm/plat-s3c/include/plat/regs-usb-hsotg.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      http://armlinux.simtec.co.uk/
+ *      Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C - USB2.0 Highspeed/OtG device block registers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __PLAT_S3C64XX_REGS_USB_HSOTG_H
+#define __PLAT_S3C64XX_REGS_USB_HSOTG_H __FILE__
+
+#define S3C_HSOTG_REG(x) (x)
+
+#define S3C_GOTGCTL				S3C_HSOTG_REG(0x000)
+#define S3C_GOTGCTL_BSESVLD			(1 << 19)
+#define S3C_GOTGCTL_ASESVLD			(1 << 18)
+#define S3C_GOTGCTL_DBNC_SHORT			(1 << 17)
+#define S3C_GOTGCTL_CONID_B			(1 << 16)
+#define S3C_GOTGCTL_DEVHNPEN			(1 << 11)
+#define S3C_GOTGCTL_HSSETHNPEN			(1 << 10)
+#define S3C_GOTGCTL_HNPREQ			(1 << 9)
+#define S3C_GOTGCTL_HSTNEGSCS			(1 << 8)
+#define S3C_GOTGCTL_SESREQ			(1 << 1)
+#define S3C_GOTGCTL_SESREQSCS			(1 << 0)
+
+#define S3C_GOTGINT				S3C_HSOTG_REG(0x004)
+#define S3C_GOTGINT_DbnceDone			(1 << 19)
+#define S3C_GOTGINT_ADevTOUTChg			(1 << 18)
+#define S3C_GOTGINT_HstNegDet			(1 << 17)
+#define S3C_GOTGINT_HstnegSucStsChng		(1 << 9)
+#define S3C_GOTGINT_SesReqSucStsChng		(1 << 8)
+#define S3C_GOTGINT_SesEndDet			(1 << 2)
+
+#define S3C_GAHBCFG				S3C_HSOTG_REG(0x008)
+#define S3C_GAHBCFG_PTxFEmpLvl			(1 << 8)
+#define S3C_GAHBCFG_NPTxFEmpLvl			(1 << 7)
+#define S3C_GAHBCFG_DMAEn			(1 << 5)
+#define S3C_GAHBCFG_HBstLen_MASK		(0xf << 1)
+#define S3C_GAHBCFG_HBstLen_SHIFT		(1)
+#define S3C_GAHBCFG_HBstLen_Single		(0x0 << 1)
+#define S3C_GAHBCFG_HBstLen_Incr		(0x1 << 1)
+#define S3C_GAHBCFG_HBstLen_Incr4		(0x3 << 1)
+#define S3C_GAHBCFG_HBstLen_Incr8		(0x5 << 1)
+#define S3C_GAHBCFG_HBstLen_Incr16		(0x7 << 1)
+#define S3C_GAHBCFG_GlblIntrEn			(1 << 0)
+
+#define S3C_GUSBCFG				S3C_HSOTG_REG(0x00C)
+#define S3C_GUSBCFG_PHYLPClkSel			(1 << 15)
+#define S3C_GUSBCFG_HNPCap			(1 << 9)
+#define S3C_GUSBCFG_SRPCap			(1 << 8)
+#define S3C_GUSBCFG_PHYIf16			(1 << 3)
+#define S3C_GUSBCFG_TOutCal_MASK		(0x7 << 0)
+#define S3C_GUSBCFG_TOutCal_SHIFT		(0)
+#define S3C_GUSBCFG_TOutCal_LIMIT		(0x7)
+#define S3C_GUSBCFG_TOutCal(_x)			((_x) << 0)
+
+#define S3C_GRSTCTL				S3C_HSOTG_REG(0x010)
+
+#define S3C_GRSTCTL_AHBIdle			(1 << 31)
+#define S3C_GRSTCTL_DMAReq			(1 << 30)
+#define S3C_GRSTCTL_TxFNum_MASK			(0x1f << 6)
+#define S3C_GRSTCTL_TxFNum_SHIFT		(6)
+#define S3C_GRSTCTL_TxFNum_LIMIT		(0x1f)
+#define S3C_GRSTCTL_TxFNum(_x)			((_x) << 6)
+#define S3C_GRSTCTL_TxFFlsh			(1 << 5)
+#define S3C_GRSTCTL_RxFFlsh			(1 << 4)
+#define S3C_GRSTCTL_INTknQFlsh			(1 << 3)
+#define S3C_GRSTCTL_FrmCntrRst			(1 << 2)
+#define S3C_GRSTCTL_HSftRst			(1 << 1)
+#define S3C_GRSTCTL_CSftRst			(1 << 0)
+
+#define S3C_GINTSTS				S3C_HSOTG_REG(0x014)
+#define S3C_GINTMSK				S3C_HSOTG_REG(0x018)
+
+#define S3C_GINTSTS_WkUpInt			(1 << 31)
+#define S3C_GINTSTS_SessReqInt			(1 << 30)
+#define S3C_GINTSTS_DisconnInt			(1 << 29)
+#define S3C_GINTSTS_ConIDStsChng		(1 << 28)
+#define S3C_GINTSTS_PTxFEmp			(1 << 26)
+#define S3C_GINTSTS_HChInt			(1 << 25)
+#define S3C_GINTSTS_PrtInt			(1 << 24)
+#define S3C_GINTSTS_FetSusp			(1 << 22)
+#define S3C_GINTSTS_incompIP			(1 << 21)
+#define S3C_GINTSTS_IncomplSOIN			(1 << 20)
+#define S3C_GINTSTS_OEPInt			(1 << 19)
+#define S3C_GINTSTS_IEPInt			(1 << 18)
+#define S3C_GINTSTS_EPMis			(1 << 17)
+#define S3C_GINTSTS_EOPF			(1 << 15)
+#define S3C_GINTSTS_ISOutDrop			(1 << 14)
+#define S3C_GINTSTS_EnumDone			(1 << 13)
+#define S3C_GINTSTS_USBRst			(1 << 12)
+#define S3C_GINTSTS_USBSusp			(1 << 11)
+#define S3C_GINTSTS_ErlySusp			(1 << 10)
+#define S3C_GINTSTS_GOUTNakEff			(1 << 7)
+#define S3C_GINTSTS_GINNakEff			(1 << 6)
+#define S3C_GINTSTS_NPTxFEmp			(1 << 5)
+#define S3C_GINTSTS_RxFLvl			(1 << 4)
+#define S3C_GINTSTS_SOF				(1 << 3)
+#define S3C_GINTSTS_OTGInt			(1 << 2)
+#define S3C_GINTSTS_ModeMis			(1 << 1)
+#define S3C_GINTSTS_CurMod_Host			(1 << 0)
+
+#define S3C_GRXSTSR				S3C_HSOTG_REG(0x01C)
+#define S3C_GRXSTSP				S3C_HSOTG_REG(0x020)
+
+#define S3C_GRXSTS_FN_MASK			(0x7f << 25)
+#define S3C_GRXSTS_FN_SHIFT			(25)
+
+#define S3C_GRXSTS_PktSts_MASK			(0xf << 17)
+#define S3C_GRXSTS_PktSts_SHIFT			(17)
+#define S3C_GRXSTS_PktSts_GlobalOutNAK		(0x1 << 17)
+#define S3C_GRXSTS_PktSts_OutRX			(0x2 << 17)
+#define S3C_GRXSTS_PktSts_OutDone		(0x3 << 17)
+#define S3C_GRXSTS_PktSts_SetupDone		(0x4 << 17)
+#define S3C_GRXSTS_PktSts_SetupRX		(0x6 << 17)
+
+#define S3C_GRXSTS_DPID_MASK			(0x3 << 15)
+#define S3C_GRXSTS_DPID_SHIFT			(15)
+#define S3C_GRXSTS_ByteCnt_MASK			(0x7ff << 4)
+#define S3C_GRXSTS_ByteCnt_SHIFT		(4)
+#define S3C_GRXSTS_EPNum_MASK			(0xf << 0)
+#define S3C_GRXSTS_EPNum_SHIFT			(0)
+
+#define S3C_GRXFSIZ				S3C_HSOTG_REG(0x024)
+
+#define S3C_GNPTXFSIZ				S3C_HSOTG_REG(0x028)
+
+#define S3C_GNPTXFSIZ_NPTxFDep_MASK		(0xffff << 16)
+#define S3C_GNPTXFSIZ_NPTxFDep_SHIFT		(16)
+#define S3C_GNPTXFSIZ_NPTxFDep_LIMIT		(0xffff)
+#define S3C_GNPTXFSIZ_NPTxFDep(_x)		((_x) << 16)
+#define S3C_GNPTXFSIZ_NPTxFStAddr_MASK		(0xffff << 0)
+#define S3C_GNPTXFSIZ_NPTxFStAddr_SHIFT		(0)
+#define S3C_GNPTXFSIZ_NPTxFStAddr_LIMIT		(0xffff)
+#define S3C_GNPTXFSIZ_NPTxFStAddr(_x)		((_x) << 0)
+
+#define S3C_GNPTXSTS				S3C_HSOTG_REG(0x02C)
+
+#define S3C_GNPTXSTS_NPtxQTop_MASK		(0x7f << 24)
+#define S3C_GNPTXSTS_NPtxQTop_SHIFT		(24)
+
+#define S3C_GNPTXSTS_NPTxQSpcAvail_MASK		(0xff << 16)
+#define S3C_GNPTXSTS_NPTxQSpcAvail_SHIFT	(16)
+#define S3C_GNPTXSTS_NPTxQSpcAvail_GET(_v)	(((_v) >> 16) & 0xff)
+
+#define S3C_GNPTXSTS_NPTxFSpcAvail_MASK		(0xffff << 0)
+#define S3C_GNPTXSTS_NPTxFSpcAvail_SHIFT	(0)
+#define S3C_GNPTXSTS_NPTxFSpcAvail_GET(_v)	(((_v) >> 0) & 0xffff)
+
+
+#define S3C_HPTXFSIZ				S3C_HSOTG_REG(0x100)
+
+#define S3C_DPTXFSIZn(_a)			S3C_HSOTG_REG(0x104 + (((_a) - 1) * 4))
+
+#define S3C_DPTXFSIZn_DPTxFSize_MASK		(0xffff << 16)
+#define S3C_DPTXFSIZn_DPTxFSize_SHIFT		(16)
+#define S3C_DPTXFSIZn_DPTxFSize_GET(_v)		(((_v) >> 16) & 0xffff)
+#define S3C_DPTXFSIZn_DPTxFSize_LIMIT		(0xffff)
+#define S3C_DPTXFSIZn_DPTxFSize(_x)		((_x) << 16)
+
+#define S3C_DPTXFSIZn_DPTxFStAddr_MASK		(0xffff << 0)
+#define S3C_DPTXFSIZn_DPTxFStAddr_SHIFT		(0)
+
+/* Device mode registers */
+#define S3C_DCFG				S3C_HSOTG_REG(0x800)
+
+#define S3C_DCFG_EPMisCnt_MASK			(0x1f << 18)
+#define S3C_DCFG_EPMisCnt_SHIFT			(18)
+#define S3C_DCFG_EPMisCnt_LIMIT			(0x1f)
+#define S3C_DCFG_EPMisCnt(_x)			((_x) << 18)
+
+#define S3C_DCFG_PerFrInt_MASK			(0x3 << 11)
+#define S3C_DCFG_PerFrInt_SHIFT			(11)
+#define S3C_DCFG_PerFrInt_LIMIT			(0x3)
+#define S3C_DCFG_PerFrInt(_x)			((_x) << 11)
+
+#define S3C_DCFG_DevAddr_MASK			(0x7f << 4)
+#define S3C_DCFG_DevAddr_SHIFT			(4)
+#define S3C_DCFG_DevAddr_LIMIT			(0x7f)
+#define S3C_DCFG_DevAddr(_x)			((_x) << 4)
+
+#define S3C_DCFG_NZStsOUTHShk			(1 << 2)
+
+#define S3C_DCFG_DevSpd_MASK			(0x3 << 0)
+#define S3C_DCFG_DevSpd_SHIFT			(0)
+#define S3C_DCFG_DevSpd_HS			(0x0 << 0)
+#define S3C_DCFG_DevSpd_FS			(0x1 << 0)
+#define S3C_DCFG_DevSpd_LS			(0x2 << 0)
+#define S3C_DCFG_DevSpd_FS48			(0x3 << 0)
+
+#define S3C_DCTL				S3C_HSOTG_REG(0x804)
+
+#define S3C_DCTL_PWROnPrgDone			(1 << 11)
+#define S3C_DCTL_CGOUTNak			(1 << 10)
+#define S3C_DCTL_SGOUTNak			(1 << 9)
+#define S3C_DCTL_CGNPInNAK			(1 << 8)
+#define S3C_DCTL_SGNPInNAK			(1 << 7)
+#define S3C_DCTL_TstCtl_MASK			(0x7 << 4)
+#define S3C_DCTL_TstCtl_SHIFT			(4)
+#define S3C_DCTL_GOUTNakSts			(1 << 3)
+#define S3C_DCTL_GNPINNakSts			(1 << 2)
+#define S3C_DCTL_SftDiscon			(1 << 1)
+#define S3C_DCTL_RmtWkUpSig			(1 << 0)
+
+#define S3C_DSTS				S3C_HSOTG_REG(0x808)
+
+#define S3C_DSTS_SOFFN_MASK			(0x3fff << 8)
+#define S3C_DSTS_SOFFN_SHIFT			(8)
+#define S3C_DSTS_SOFFN_LIMIT			(0x3fff)
+#define S3C_DSTS_SOFFN(_x)			((_x) << 8)
+#define S3C_DSTS_ErraticErr			(1 << 3)
+#define S3C_DSTS_EnumSpd_MASK			(0x3 << 1)
+#define S3C_DSTS_EnumSpd_SHIFT			(1)
+#define S3C_DSTS_EnumSpd_HS			(0x0 << 1)
+#define S3C_DSTS_EnumSpd_FS			(0x1 << 1)
+#define S3C_DSTS_EnumSpd_LS			(0x2 << 1)
+#define S3C_DSTS_EnumSpd_FS48			(0x3 << 1)
+
+#define S3C_DSTS_SuspSts			(1 << 0)
+
+#define S3C_DIEPMSK				S3C_HSOTG_REG(0x810)
+
+#define S3C_DIEPMSK_INEPNakEffMsk		(1 << 6)
+#define S3C_DIEPMSK_INTknEPMisMsk		(1 << 5)
+#define S3C_DIEPMSK_INTknTXFEmpMsk		(1 << 4)
+#define S3C_DIEPMSK_TimeOUTMsk			(1 << 3)
+#define S3C_DIEPMSK_AHBErrMsk			(1 << 2)
+#define S3C_DIEPMSK_EPDisbldMsk			(1 << 1)
+#define S3C_DIEPMSK_XferComplMsk		(1 << 0)
+
+#define S3C_DOEPMSK				S3C_HSOTG_REG(0x814)
+
+#define S3C_DOEPMSK_Back2BackSetup		(1 << 6)
+#define S3C_DOEPMSK_OUTTknEPdisMsk		(1 << 4)
+#define S3C_DOEPMSK_SetupMsk			(1 << 3)
+#define S3C_DOEPMSK_AHBErrMsk			(1 << 2)
+#define S3C_DOEPMSK_EPDisbldMsk			(1 << 1)
+#define S3C_DOEPMSK_XferComplMsk		(1 << 0)
+
+#define S3C_DAINT				S3C_HSOTG_REG(0x818)
+#define S3C_DAINTMSK				S3C_HSOTG_REG(0x81C)
+
+#define S3C_DAINT_OutEP_SHIFT			(16)
+#define S3C_DAINT_OutEP(x)			(1 << ((x) + 16))
+#define S3C_DAINT_InEP(x)			(1 << (x))
+
+#define S3C_DTKNQR1				S3C_HSOTG_REG(0x820)
+#define S3C_DTKNQR2				S3C_HSOTG_REG(0x824)
+#define S3C_DTKNQR3				S3C_HSOTG_REG(0x830)
+#define S3C_DTKNQR4				S3C_HSOTG_REG(0x834)
+
+#define S3C_DVBUSDIS				S3C_HSOTG_REG(0x828)
+#define S3C_DVBUSPULSE				S3C_HSOTG_REG(0x82C)
+
+#define S3C_DIEPCTL0				S3C_HSOTG_REG(0x900)
+#define S3C_DOEPCTL0				S3C_HSOTG_REG(0xB00)
+#define S3C_DIEPCTL(_a)				S3C_HSOTG_REG(0x900 + ((_a) * 0x20))
+#define S3C_DOEPCTL(_a)				S3C_HSOTG_REG(0xB00 + ((_a) * 0x20))
+
+/* EP0 specialness:
+ * bits[29..28] - reserved (no SetD0PID, SetD1PID)
+ * bits[25..22] - should always be zero, this isn't a periodic endpoint
+ * bits[10..0] - MPS setting differenct for EP0
+*/
+#define S3C_D0EPCTL_MPS_MASK			(0x3 << 0)
+#define S3C_D0EPCTL_MPS_SHIFT			(0)
+#define S3C_D0EPCTL_MPS_64			(0x0 << 0)
+#define S3C_D0EPCTL_MPS_32			(0x1 << 0)
+#define S3C_D0EPCTL_MPS_16			(0x2 << 0)
+#define S3C_D0EPCTL_MPS_8			(0x3 << 0)
+
+#define S3C_DxEPCTL_EPEna			(1 << 31)
+#define S3C_DxEPCTL_EPDis			(1 << 30)
+#define S3C_DxEPCTL_SetD1PID			(1 << 29)
+#define S3C_DxEPCTL_SetOddFr			(1 << 29)
+#define S3C_DxEPCTL_SetD0PID			(1 << 28)
+#define S3C_DxEPCTL_SetEvenFr			(1 << 28)
+#define S3C_DxEPCTL_SNAK			(1 << 27)
+#define S3C_DxEPCTL_CNAK			(1 << 26)
+#define S3C_DxEPCTL_TxFNum_MASK			(0xf << 22)
+#define S3C_DxEPCTL_TxFNum_SHIFT		(22)
+#define S3C_DxEPCTL_TxFNum_LIMIT		(0xf)
+#define S3C_DxEPCTL_TxFNum(_x)			((_x) << 22)
+
+#define S3C_DxEPCTL_Stall			(1 << 21)
+#define S3C_DxEPCTL_Snp				(1 << 20)
+#define S3C_DxEPCTL_EPType_MASK			(0x3 << 18)
+#define S3C_DxEPCTL_EPType_SHIFT		(18)
+#define S3C_DxEPCTL_EPType_Control		(0x0 << 18)
+#define S3C_DxEPCTL_EPType_Iso			(0x1 << 18)
+#define S3C_DxEPCTL_EPType_Bulk			(0x2 << 18)
+#define S3C_DxEPCTL_EPType_Intterupt		(0x3 << 18)
+
+#define S3C_DxEPCTL_NAKsts			(1 << 17)
+#define S3C_DxEPCTL_DPID			(1 << 16)
+#define S3C_DxEPCTL_EOFrNum			(1 << 16)
+#define S3C_DxEPCTL_USBActEp			(1 << 15)
+#define S3C_DxEPCTL_NextEp_MASK			(0xf << 11)
+#define S3C_DxEPCTL_NextEp_SHIFT		(11)
+#define S3C_DxEPCTL_NextEp_LIMIT		(0xf)
+#define S3C_DxEPCTL_NextEp(_x)			((_x) << 11)
+
+#define S3C_DxEPCTL_MPS_MASK			(0x7ff << 0)
+#define S3C_DxEPCTL_MPS_SHIFT			(0)
+#define S3C_DxEPCTL_MPS_LIMIT			(0x7ff)
+#define S3C_DxEPCTL_MPS(_x)			((_x) << 0)
+
+#define S3C_DIEPINT(_a)				S3C_HSOTG_REG(0x908 + ((_a) * 0x20))
+#define S3C_DOEPINT(_a)				S3C_HSOTG_REG(0xB08 + ((_a) * 0x20))
+
+#define S3C_DxEPINT_INEPNakEff			(1 << 6)
+#define S3C_DxEPINT_Back2BackSetup		(1 << 6)
+#define S3C_DxEPINT_INTknEPMis			(1 << 5)
+#define S3C_DxEPINT_INTknTXFEmp			(1 << 4)
+#define S3C_DxEPINT_OUTTknEPdis			(1 << 4)
+#define S3C_DxEPINT_Timeout			(1 << 3)
+#define S3C_DxEPINT_Setup			(1 << 3)
+#define S3C_DxEPINT_AHBErr			(1 << 2)
+#define S3C_DxEPINT_EPDisbld			(1 << 1)
+#define S3C_DxEPINT_XferCompl			(1 << 0)
+
+#define S3C_DIEPTSIZ0				S3C_HSOTG_REG(0x910)
+
+#define S3C_DIEPTSIZ0_PktCnt_MASK		(0x3 << 19)
+#define S3C_DIEPTSIZ0_PktCnt_SHIFT		(19)
+#define S3C_DIEPTSIZ0_PktCnt_LIMIT		(0x3)
+#define S3C_DIEPTSIZ0_PktCnt(_x)		((_x) << 19)
+
+#define S3C_DIEPTSIZ0_XferSize_MASK		(0x7f << 0)
+#define S3C_DIEPTSIZ0_XferSize_SHIFT		(0)
+#define S3C_DIEPTSIZ0_XferSize_LIMIT		(0x7f)
+#define S3C_DIEPTSIZ0_XferSize(_x)		((_x) << 0)
+
+
+#define DOEPTSIZ0				S3C_HSOTG_REG(0xB10)
+#define S3C_DOEPTSIZ0_SUPCnt_MASK		(0x3 << 29)
+#define S3C_DOEPTSIZ0_SUPCnt_SHIFT		(29)
+#define S3C_DOEPTSIZ0_SUPCnt_LIMIT		(0x3)
+#define S3C_DOEPTSIZ0_SUPCnt(_x)		((_x) << 29)
+
+#define S3C_DOEPTSIZ0_PktCnt			(1 << 19)
+#define S3C_DOEPTSIZ0_XferSize_MASK		(0x7f << 0)
+#define S3C_DOEPTSIZ0_XferSize_SHIFT		(0)
+
+#define S3C_DIEPTSIZ(_a)			S3C_HSOTG_REG(0x910 + ((_a) * 0x20))
+#define S3C_DOEPTSIZ(_a)			S3C_HSOTG_REG(0xB10 + ((_a) * 0x20))
+
+#define S3C_DxEPTSIZ_MC_MASK			(0x3 << 29)
+#define S3C_DxEPTSIZ_MC_SHIFT			(29)
+#define S3C_DxEPTSIZ_MC_LIMIT			(0x3)
+#define S3C_DxEPTSIZ_MC(_x)			((_x) << 29)
+
+#define S3C_DxEPTSIZ_PktCnt_MASK		(0x3ff << 19)
+#define S3C_DxEPTSIZ_PktCnt_SHIFT		(19)
+#define S3C_DxEPTSIZ_PktCnt_GET(_v)		(((_v) >> 19) & 0x3ff)
+#define S3C_DxEPTSIZ_PktCnt_LIMIT		(0x3ff)
+#define S3C_DxEPTSIZ_PktCnt(_x)			((_x) << 19)
+
+#define S3C_DxEPTSIZ_XferSize_MASK		(0x7ffff << 0)
+#define S3C_DxEPTSIZ_XferSize_SHIFT		(0)
+#define S3C_DxEPTSIZ_XferSize_GET(_v)		(((_v) >> 0) & 0x7ffff)
+#define S3C_DxEPTSIZ_XferSize_LIMIT		(0x7ffff)
+#define S3C_DxEPTSIZ_XferSize(_x)		((_x) << 0)
+
+
+#define S3C_DIEPDMA(_a)				S3C_HSOTG_REG(0x914 + ((_a) * 0x20))
+#define S3C_DOEPDMA(_a)				S3C_HSOTG_REG(0xB14 + ((_a) * 0x20))
+
+#define S3C_EPFIFO(_a)				S3C_HSOTG_REG(0x1000 + ((_a) * 0x1000))
+
+#endif /* __PLAT_S3C64XX_REGS_USB_HSOTG_H */
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/plat/regs-usb-hsotg-phy.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/plat/regs-usb-hsotg-phy.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/plat/regs-usb-hsotg-phy.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/plat/regs-usb-hsotg-phy.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,50 @@
+/* arch/arm/plat-s3c/include/plat/regs-usb-hsotg-phy.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      http://armlinux.simtec.co.uk/
+ *      Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C - USB2.0 Highspeed/OtG device PHY registers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/* Note, this is a seperate header file as some of the clock framework
+ * needs to touch this if the clk_48m is used as the USB OHCI or other
+ * peripheral source.
+*/
+
+#ifndef __PLAT_S3C64XX_REGS_USB_HSOTG_PHY_H
+#define __PLAT_S3C64XX_REGS_USB_HSOTG_PHY_H __FILE__
+
+/* S3C64XX_PA_USB_HSPHY */
+
+#define S3C_HSOTG_PHYREG(x)	((x) + S3C_VA_USB_HSPHY)
+
+#define S3C_PHYPWR				S3C_HSOTG_PHYREG(0x00)
+#define SRC_PHYPWR_OTG_DISABLE			(1 << 4)
+#define SRC_PHYPWR_ANALOG_POWERDOWN		(1 << 3)
+#define SRC_PHYPWR_FORCE_SUSPEND		(1 << 1)
+
+#define S3C_PHYCLK				S3C_HSOTG_PHYREG(0x04)
+#define S3C_PHYCLK_MODE_USB11			(1 << 6)
+#define S3C_PHYCLK_EXT_OSC			(1 << 5)
+#define S3C_PHYCLK_CLK_FORCE			(1 << 4)
+#define S3C_PHYCLK_ID_PULL			(1 << 2)
+#define S3C_PHYCLK_CLKSEL_MASK			(0x3 << 0)
+#define S3C_PHYCLK_CLKSEL_SHIFT			(0)
+#define S3C_PHYCLK_CLKSEL_48M			(0x0 << 0)
+#define S3C_PHYCLK_CLKSEL_12M			(0x2 << 0)
+#define S3C_PHYCLK_CLKSEL_24M			(0x3 << 0)
+
+#define S3C_RSTCON				S3C_HSOTG_PHYREG(0x08)
+#define S3C_RSTCON_PHYCLK			(1 << 2)
+#define S3C_RSTCON_HCLK				(1 << 2)
+#define S3C_RSTCON_PHY				(1 << 0)
+
+#define S3C_PHYTUNE				S3C_HSOTG_PHYREG(0x20)
+
+#endif /* __PLAT_S3C64XX_REGS_USB_HSOTG_PHY_H */
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/plat/udc-hs.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/plat/udc-hs.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/include/plat/udc-hs.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/include/plat/udc-hs.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,29 @@
+/* arch/arm/plat-s3c/include/plat/udc-hs.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * S3C USB2.0 High-speed / OtG platform information
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+enum s3c_hostg_dmamode {
+	S3C_HSOTG_DMA_NONE,	/* do not use DMA at-all */
+	S3C_HSOTG_DMA_ONLY,	/* always use DMA */
+	S3C_HSOTG_DMA_DRV,	/* DMA is chosen by driver */
+};
+
+/**
+ * struct s3c_hsotg_plat - platform data for high-speed otg/udc
+ * @dma: Whether to use DMA or not.
+ * @is_osc: The clock source is an oscillator, not a crystal
+ */
+struct s3c_hsotg_plat {
+	enum s3c_hostg_dmamode	dma;
+	unsigned int		is_osc : 1;
+};
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/iphone_battery.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/iphone_battery.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/iphone_battery.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/iphone_battery.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,271 @@
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <mach/pmu.h>
+
+static int iphone_battery_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val);
+
+static int iphone_power_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val);
+
+static char* supply_list[] =
+{
+	"battery",
+};
+
+static enum power_supply_property iphone_battery_properties[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+};
+
+static enum power_supply_property iphone_power_properties[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static struct power_supply battery =
+{
+	.name = "battery",
+	.type = POWER_SUPPLY_TYPE_BATTERY,
+	.properties = iphone_battery_properties,
+	.num_properties = ARRAY_SIZE(iphone_battery_properties),
+	.get_property = iphone_battery_get_property,
+};
+
+static struct power_supply ac =
+{
+	.name = "ac",
+	.type = POWER_SUPPLY_TYPE_MAINS,
+	.supplied_to = supply_list,
+	.num_supplicants = ARRAY_SIZE(supply_list),
+	.properties = iphone_power_properties,
+	.num_properties = ARRAY_SIZE(iphone_power_properties),
+	.get_property = iphone_power_get_property,
+};
+
+static struct power_supply usb =
+{
+	.name = "usb",
+	.type = POWER_SUPPLY_TYPE_USB,
+	.supplied_to = supply_list,
+	.num_supplicants = ARRAY_SIZE(supply_list),
+	.properties = iphone_power_properties,
+	.num_properties = ARRAY_SIZE(iphone_power_properties),
+	.get_property = iphone_power_get_property,
+};
+
+struct iphone_battery_info {
+	struct mutex lock;
+	struct delayed_work monitor_work;
+
+	int voltage;
+	int level;
+	PowerSupplyType type;
+};
+
+static struct iphone_battery_info iphone_batt_info;
+
+static void iphone_battery_update_status(bool send_updates)
+{
+	int voltage;
+	int level;
+	PowerSupplyType type;
+	PowerSupplyType old_type;
+	bool changed = false;
+
+	mutex_lock(&iphone_batt_info.lock);
+	type = iphone_pmu_get_power_supply();
+	voltage = iphone_pmu_get_battery_voltage();
+	iphone_pmu_charge_settings(1, 0, 0);
+
+	old_type = iphone_batt_info.type;
+	
+	if(iphone_batt_info.voltage != voltage)
+		changed = true;
+	
+	level = ((voltage - 3500) * 100) / (4200 - 3500);
+	if(level < 0)
+		level = 0;
+	if(level > 100)
+		level = 100;
+
+	iphone_batt_info.type = type;
+	iphone_batt_info.voltage = voltage;
+	iphone_batt_info.level = level;
+	mutex_unlock(&iphone_batt_info.lock);
+
+	if(send_updates)
+	{
+		if(type != old_type)
+		{
+			if(old_type == PowerSupplyTypeUSBHost)
+				power_supply_changed(&usb);
+			else if(old_type != PowerSupplyTypeBattery)
+				power_supply_changed(&ac);
+
+			if(type == PowerSupplyTypeUSBHost)
+				power_supply_changed(&usb);
+			else if(type != PowerSupplyTypeBattery)
+				power_supply_changed(&ac);
+		}
+
+		if(changed)
+			power_supply_changed(&battery);
+	}
+}
+
+static void iphone_battery_work(struct work_struct* work)
+{
+	const int interval = msecs_to_jiffies(60 * 1000);
+	iphone_battery_update_status(true);
+	schedule_delayed_work(&iphone_batt_info.monitor_work, interval);
+}
+
+static int iphone_power_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	PowerSupplyType type;
+
+	iphone_battery_update_status(false);
+
+	mutex_lock(&iphone_batt_info.lock);
+	type = iphone_batt_info.type;
+	mutex_unlock(&iphone_batt_info.lock);
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_ONLINE:
+			if (psy->type == POWER_SUPPLY_TYPE_MAINS) {
+				val->intval = ((type ==  PowerSupplyTypeUSBBrick500mA || type == PowerSupplyTypeUSBBrick1000mA) ? 1 : 0);
+			} else if (psy->type == POWER_SUPPLY_TYPE_USB) {
+				val->intval = (type ==  PowerSupplyTypeUSBHost ? 1 : 0);
+			} else
+				val->intval = 0;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int iphone_battery_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	PowerSupplyType type;
+	int voltage;
+	int level;
+
+	iphone_battery_update_status(false);
+
+	mutex_lock(&iphone_batt_info.lock);
+	type = iphone_batt_info.type;
+	voltage = iphone_batt_info.voltage;
+	level = iphone_batt_info.level;
+	mutex_unlock(&iphone_batt_info.lock);
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+			if(type == PowerSupplyTypeBattery)
+			{
+			       val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+			} else
+			{
+				if(level == 100)
+				       	val->intval = POWER_SUPPLY_STATUS_FULL;
+				else
+				       	val->intval = POWER_SUPPLY_STATUS_CHARGING;
+			}
+			break;
+		case POWER_SUPPLY_PROP_HEALTH:
+			val->intval = POWER_SUPPLY_HEALTH_GOOD;
+			/* TODO: we might need to set POWER_SUPPLY_HEALTH_OVERHEAT if we figure out the battery temperature stuff */
+			break;
+		case POWER_SUPPLY_PROP_PRESENT:
+			val->intval = 1;
+			break;
+		case POWER_SUPPLY_PROP_TECHNOLOGY:
+			val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+			break;
+		case POWER_SUPPLY_PROP_CAPACITY:
+			val->intval = level;
+			break;
+		case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+			val->intval = voltage * 1000;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int iphone_battery_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = power_supply_register(&pdev->dev, &battery);
+	if(ret)
+		dev_err(&pdev->dev, "failed to register battery power supply!\n");
+
+	ret = power_supply_register(&pdev->dev, &ac);
+	if(ret)
+		dev_err(&pdev->dev, "failed to register AC power supply!\n");
+
+	ret = power_supply_register(&pdev->dev, &usb);
+	if(ret)
+		dev_err(&pdev->dev, "failed to register USB power supply!\n");
+
+	iphone_battery_work(NULL);
+
+	return 0;
+}
+
+static struct platform_driver iphone_battery_driver = {
+	.probe  = iphone_battery_probe,
+	.driver = {
+		.name   = "iphone-battery",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static struct platform_device iphone_battery_device = {
+	.name = "iphone-battery",
+	.id = -1,
+};
+
+
+static int __init iphone_battery_init(void)
+{
+	int ret;
+
+	mutex_init(&iphone_batt_info.lock);
+	INIT_DELAYED_WORK(&iphone_batt_info.monitor_work, iphone_battery_work);
+	
+	ret = platform_driver_register(&iphone_battery_driver);
+	if (!ret) {
+		ret = platform_device_register(&iphone_battery_device);
+
+		if (ret != 0) {
+			platform_driver_unregister(&iphone_battery_driver);
+		}
+	}
+
+	return ret;
+}
+
+module_init(iphone_battery_init);
+MODULE_DESCRIPTION("iPhone Battery Driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/iphone_bl.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/iphone_bl.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/iphone_bl.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/iphone_bl.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,173 @@
+/*
+ *  Backlight Driver for the iPhone Backlight
+ *
+ *  Copyright (c) 2010 Patrick Wildt
+ *
+ *  Based on kb6886_bl.c by Claudio Nieder
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+#include <mach/pmu.h>
+
+#define LCD_MAX_BACKLIGHT 45
+#define LCD_BACKLIGHT_REG 0x28
+#define LCD_BACKLIGHT_REGMASK 0x3F
+
+static const PMURegisterData backlightOffData = {0x29, 0x0};
+
+static const PMURegisterData backlightData[] = {
+        {0x17, 0x1},
+        {0x2A, 0x0},
+        {0x28, 0x22},
+        {0x29, 0x1},
+        {0x2A, 0x6}
+};
+
+static void iphone_bl_set_intensity(int level)
+{
+        if(level == 0) {
+                iphone_pmu_write_regs(&backlightOffData, 1);
+        } else {
+                PMURegisterData myBacklightData[sizeof(backlightData)/sizeof(PMURegisterData)];
+
+                memcpy(myBacklightData, backlightData, sizeof(myBacklightData));
+
+                if(level <= LCD_MAX_BACKLIGHT) {
+                        int i;
+                        for(i = 0; i < (sizeof(myBacklightData)/sizeof(PMURegisterData)); i++) {
+                                if(myBacklightData[i].reg == LCD_BACKLIGHT_REG) {
+                                        myBacklightData[i].data = level & LCD_BACKLIGHT_REGMASK;
+                                }
+                        }
+                }
+                iphone_pmu_write_regs(myBacklightData, sizeof(myBacklightData)/sizeof(PMURegisterData));
+        }
+}
+
+struct iphonebl_machinfo {
+	int max_intensity;
+	int default_intensity;
+	int limit_mask;
+	void (*set_bl_intensity)(int intensity);
+};
+
+static struct iphonebl_machinfo iphone_bl_machinfo = {
+	.max_intensity = 0x2d,
+	.default_intensity = 0x14,
+//	.limit_mask = 0x7f,
+	.set_bl_intensity = iphone_bl_set_intensity,
+};
+
+static struct platform_device iphonebl_device = {
+	.name		= "iphone-bl",
+	.dev		= {
+		.platform_data	= &iphone_bl_machinfo,
+	},
+	.id		= -1,
+};
+
+static struct platform_device *devices[] __initdata = {
+	&iphonebl_device,
+};
+
+/*
+ * Back to driver
+ */
+
+static int iphonebl_intensity;
+static struct backlight_device *iphone_backlight_device;
+static struct iphonebl_machinfo *bl_machinfo;
+
+static int iphonebl_send_intensity(struct backlight_device *bd)
+{
+	int intensity = bd->props.brightness;
+
+	if (bd->props.power != FB_BLANK_UNBLANK)
+		intensity = 0;
+	if (bd->props.fb_blank != FB_BLANK_UNBLANK)
+		intensity = 0;
+
+	bl_machinfo->set_bl_intensity(intensity);
+
+	iphonebl_intensity = intensity;
+	return 0;
+}
+
+static int iphonebl_get_intensity(struct backlight_device *bd)
+{
+	return iphonebl_intensity;
+}
+
+static struct backlight_ops iphonebl_ops = {
+	.get_brightness = iphonebl_get_intensity,
+	.update_status  = iphonebl_send_intensity,
+};
+
+static int iphonebl_probe(struct platform_device *pdev)
+{
+	struct iphonebl_machinfo *machinfo = pdev->dev.platform_data;
+
+	bl_machinfo = machinfo;
+	if (!machinfo->limit_mask)
+		machinfo->limit_mask = -1;
+
+	iphone_backlight_device = backlight_device_register("iphone-bl",
+		&pdev->dev, NULL, &iphonebl_ops);
+	if (IS_ERR(iphone_backlight_device))
+		return PTR_ERR(iphone_backlight_device);
+
+	platform_set_drvdata(pdev, iphone_backlight_device);
+
+	iphone_backlight_device->props.max_brightness = machinfo->max_intensity;
+	iphone_backlight_device->props.power = FB_BLANK_UNBLANK;
+	iphone_backlight_device->props.brightness = machinfo->default_intensity;
+	backlight_update_status(iphone_backlight_device);
+
+	return 0;
+}
+
+static int iphonebl_remove(struct platform_device *pdev)
+{
+	struct backlight_device *bd = platform_get_drvdata(pdev);
+
+	backlight_device_unregister(bd);
+
+	return 0;
+}
+
+static struct platform_driver iphonebl_driver = {
+	.probe		= iphonebl_probe,
+	.remove		= iphonebl_remove,
+	.driver		= {
+		.name	= "iphone-bl",
+	},
+};
+
+static int __init iphone_init(void)
+{
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+	return platform_driver_register(&iphonebl_driver);
+}
+
+static void __exit iphone_exit(void)
+{
+	platform_driver_unregister(&iphonebl_driver);
+}
+
+module_init(iphone_init);
+module_exit(iphone_exit);
+
+MODULE_AUTHOR("Patrick Wildt <webmaster@patrick-wildt.de");
+MODULE_DESCRIPTION("iPhone Backlight Driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/iphone.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/iphone.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/iphone.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/iphone.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,319 @@
+/*
+ *  linux/arch/arm/mach-apple_iphone/iphone.c
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/io.h>
+#include <linux/i2c.h>
+#include <linux/power_supply.h>
+#include <linux/pm.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+#include <asm/mach/irq.h>
+
+#include "core.h"
+#include "lcd.h"
+#include <mach/iphone-dma.h>
+#include <mach/iphone-i2c.h>
+#include <mach/usb.h>
+#include <mach/pmu.h>
+
+#include <linux/platform_device.h>
+
+#include <ftl/nand.h>
+
+#include <asm/system.h>
+#include <mach/system.h>
+
+static struct map_desc iphone_io_desc[] __initdata = {
+	{
+		.virtual	=  IO_ADDRESS(0x3CC00000),
+		.pfn		= __phys_to_pfn(0x3CC00000),
+		.length		= SZ_2M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x3C500000),
+		.pfn		= __phys_to_pfn(0x3C500000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x38E00000),
+		.pfn		= __phys_to_pfn(0x38E00000),
+		.length		= SZ_8K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x38E02000),
+		.pfn		= __phys_to_pfn(0x38E02000),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x3E300000),
+		.pfn		= __phys_to_pfn(0x3E300000),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x3E200000),
+		.pfn		= __phys_to_pfn(0x3E200000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x38400000),
+		.pfn		= __phys_to_pfn(0x38400000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x38D00000),
+		.pfn		= __phys_to_pfn(0x38D00000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x3C400000),
+		.pfn		= __phys_to_pfn(0x3C400000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x39A00000),
+		.pfn		= __phys_to_pfn(0x39A00000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x38900000),
+		.pfn		= __phys_to_pfn(0x38900000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x38A00000),
+		.pfn		= __phys_to_pfn(0x38A00000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x38F00000),
+		.pfn		= __phys_to_pfn(0x38F00000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x38200000),
+		.pfn		= __phys_to_pfn(0x38200000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x39900000),
+		.pfn		= __phys_to_pfn(0x39900000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x3C600000),
+		.pfn		= __phys_to_pfn(0x3C600000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x3C900000),
+		.pfn		= __phys_to_pfn(0x3C900000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x39A00000),
+		.pfn		= __phys_to_pfn(0x39A00000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x3E400000),
+		.pfn		= __phys_to_pfn(0x3E400000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x3CA00000),
+		.pfn		= __phys_to_pfn(0x3CA00000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x3CD00000),
+		.pfn		= __phys_to_pfn(0x3CD00000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x3E500000),
+		.pfn		= __phys_to_pfn(0x3E500000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x3C300000),
+		.pfn		= __phys_to_pfn(0x3C300000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x3CE00000),
+		.pfn		= __phys_to_pfn(0x3CE00000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	=  IO_ADDRESS(0x3D200000),
+		.pfn		= __phys_to_pfn(0x3D200000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+};
+
+void __init iphone_map_io(void)
+{
+	printk("iphone: initializing io map\n");
+	iotable_init(iphone_io_desc, ARRAY_SIZE(iphone_io_desc));
+}
+
+static struct i2c_board_info __initdata iphone_i2c0[] = {
+#ifdef CONFIG_IPHONE_2G
+	{
+		I2C_BOARD_INFO("iphone-accel", 0x3a),
+	},
+#if POWER_PCF50633
+	{
+		I2C_BOARD_INFO("pcf50633", 0xe6),
+		.irq = IPHONE_GPIO_IRQS + 0x55,
+		.platform_data = &pcf50633_pdata,
+	},
+#endif
+#ifdef CONFIG_IPHONE_PMU
+	{
+		I2C_BOARD_INFO("iphone-pmu", 0xe6),
+	},
+#endif
+	{
+		I2C_BOARD_INFO("tsl2561", 0x92),
+	},
+	{
+		I2C_BOARD_INFO("wm8758", 0x34),
+	},
+#endif
+#ifdef CONFIG_IPHONE_3G
+	{
+		I2C_BOARD_INFO("iphone-accel", 0x3a),
+	},
+#if POWER_PCF50633
+	{
+		I2C_BOARD_INFO("pcf50633", 0xe6),
+		.irq = IPHONE_GPIO_IRQS + 0x55,
+		.platform_data = &pcf50633_pdata,
+	},
+#endif
+#ifdef CONFIG_IPHONE_PMU
+	{
+		I2C_BOARD_INFO("iphone-pmu", 0xe6),
+	},
+#endif
+	{
+		I2C_BOARD_INFO("wm8991", 0x36),
+	},
+	{
+		I2C_BOARD_INFO("isl29003", 0x88),
+	},
+#endif
+#ifdef CONFIG_IPODTOUCH_1G
+	{
+		I2C_BOARD_INFO("iphone-accel", 0x3a),
+	},
+#endif
+};
+
+static struct i2c_board_info __initdata iphone_i2c1[] = {
+#ifdef CONFIG_IPODTOUCH_1G
+#if POWER_PCF50633
+	{
+		I2C_BOARD_INFO("pcf50633", 0xe6),
+		.irq = IPHONE_GPIO_IRQS + 0x55,
+		.platform_data = &pcf50633_pdata,
+	},
+#endif
+#ifdef CONFIG_IPHONE_PMU
+	{
+		I2C_BOARD_INFO("iphone-pmu", 0xe6),
+	},
+#endif
+	{
+		I2C_BOARD_INFO("wm8758", 0x34),
+	},
+#endif
+};
+
+void iphone_power_off(void)
+{
+#if POWER_PCF50633
+	pcf50633_power_off();
+#endif
+	arch_reset('h', NULL);
+}
+
+void __init iphone_init(void)
+{
+	pm_power_off = &iphone_power_off;
+
+	printk("iphone: platform init\r\n");
+	iphone_dma_setup();
+
+	iphone_init_suspend();
+
+	i2c_register_board_info(0, iphone_i2c0, ARRAY_SIZE(iphone_i2c0));
+	i2c_register_board_info(1, iphone_i2c1, ARRAY_SIZE(iphone_i2c1));
+
+	platform_device_register(&iphone_dma);
+	platform_device_register(&iphone_nand);
+	platform_device_register(&iphone_i2c);
+}
+
+MACHINE_START(APPLE_IPHONE, "Apple iPhone")
+	/* Maintainer: iPhone Linux */
+	.phys_io	= 0x38000000,
+	.io_pg_offst	= (IO_ADDRESS(0x38000000) >> 18) & 0xfffc,
+	.boot_params	= 0x09000000,
+	.map_io		= iphone_map_io,
+	.init_irq	= iphone_init_irq,
+	.timer		= &iphone_timer,
+	.init_machine	= iphone_init,
+MACHINE_END
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/irq.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/irq.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/irq.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/irq.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,148 @@
+/*
+ *  arch/arm/mach-apple_iphone/irq.c
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/sysdev.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+
+// Devices
+#define EDGEIC IO_ADDRESS(0x38E02000)
+
+// Registers
+#define EDGEICCONFIG0 0x0
+#define EDGEICCONFIG1 0x4
+#define EDGEICLOWSTATUS 0x8
+#define EDGEICHIGHSTATUS 0xC
+
+// Values
+#define EDGEIC_CONFIG0RESET 0
+#define EDGEIC_CONFIG1RESET 0
+
+// Constants
+
+#define VIC_MaxInterrupt 0x40
+#define VIC_InterruptSeparator 0x20
+
+// Devices
+
+#define VIC0 IO_ADDRESS(0x38E00000)
+#define VIC1 IO_ADDRESS(0x38E01000)
+
+// Registers
+
+#define VICIRQSTATUS 0x000
+#define VICRAWINTR 0x8
+#define VICINTSELECT 0xC
+#define VICINTENABLE 0x10
+#define VICINTENCLEAR 0x14
+#define VICSWPRIORITYMASK 0x24
+#define VICVECTADDRS 0x100
+#define VICADDRESS 0xF00
+#define VICPERIPHID0 0xFE0
+#define VICPERIPHID1 0xFE4
+#define VICPERIPHID2 0xFE8
+#define VICPERIPHID3 0xFEC
+
+static inline void iphone_irq_eoi(unsigned int irqno)
+{
+	if(irqno < VIC_InterruptSeparator) {
+		__raw_writel(1, VIC0 + VICADDRESS);
+	} else {
+		__raw_writel(1, VIC1 + VICADDRESS);
+	}
+}
+
+static inline void iphone_irq_mask(unsigned int irqno)
+{
+	if(irqno < VIC_InterruptSeparator) {
+		__raw_writel(__raw_readl(VIC0 + VICINTENABLE) & ~(1 << irqno), VIC0 + VICINTENABLE);
+	} else {
+		__raw_writel(__raw_readl(VIC1 + VICINTENABLE) & ~(1 << (irqno - VIC_InterruptSeparator)), VIC1 + VICINTENABLE);
+	}
+}
+
+static inline void iphone_irq_unmask(unsigned int irqno)
+{
+	if(irqno < VIC_InterruptSeparator) {
+		__raw_writel(__raw_readl(VIC0 + VICINTENABLE) | (1 << irqno), VIC0 + VICINTENABLE);
+	} else {
+		__raw_writel(__raw_readl(VIC1 + VICINTENABLE) | (1 << (irqno - VIC_InterruptSeparator)), VIC1 + VICINTENABLE);
+	}
+}
+
+static struct irq_chip iphone_irq_fasteoi_chip = {
+	.name = "iphone_vic",
+	.eoi = iphone_irq_eoi,
+	.mask = iphone_irq_mask,
+	.unmask = iphone_irq_unmask,
+};
+
+void __init iphone_init_irq(void)
+{
+	int i;
+
+	printk("iphone-irq: initializing\n");
+	if((0xfff & (__raw_readl(VIC0 + VICPERIPHID0) | (__raw_readl(VIC0 + VICPERIPHID1) << 8) | (__raw_readl(VIC0 + VICPERIPHID2) << 16) | (__raw_readl(VIC0 + VICPERIPHID3) << 24))) != 0x192) {
+		printk("iphone-irq: incorrect device id\n");
+		return;
+	}
+
+	if((0xfff & (__raw_readl(VIC1 + VICPERIPHID0) | (__raw_readl(VIC1 + VICPERIPHID1) << 8) | (__raw_readl(VIC1 + VICPERIPHID2) << 16) | (__raw_readl(VIC1 + VICPERIPHID3) << 24))) != 0x192) {
+		printk("iphone-irq: incorrect device id\n");
+		return;
+	}
+
+	__raw_writel(EDGEIC_CONFIG0RESET, EDGEIC + EDGEICCONFIG0);
+	__raw_writel(EDGEIC_CONFIG1RESET, EDGEIC + EDGEICCONFIG1);
+
+	__raw_writel(0xFFFFFFFF, VIC0 + VICINTENCLEAR); // disable all interrupts
+	__raw_writel(0xFFFFFFFF, VIC1 + VICINTENCLEAR);
+
+	__raw_writel(0, VIC0 + VICINTSELECT); // 0 means to use IRQs, 1 means to use FIQs, so use all IRQs
+	__raw_writel(0, VIC1 + VICINTSELECT);
+
+	__raw_writel(0xffff, VIC0 + VICSWPRIORITYMASK); // unmask all 16 interrupt levels
+	__raw_writel(0xffff, VIC1 + VICSWPRIORITYMASK);
+
+	// Set interrupt vector addresses to the interrupt number. This will signal the interrupt handler to consult the handler tables
+	for(i = 0; i < VIC_InterruptSeparator; i++)
+	{
+		__raw_writel(i, VIC0 + VICVECTADDRS + (i * 4));
+		__raw_writel(VIC_InterruptSeparator + i, VIC1 + VICVECTADDRS + (i * 4));
+
+		set_irq_chip(i, &iphone_irq_fasteoi_chip);
+		set_irq_handler(i, handle_fasteoi_irq);
+		set_irq_flags(i, IRQF_VALID);
+
+		set_irq_chip(VIC_InterruptSeparator + i, &iphone_irq_fasteoi_chip);
+		set_irq_handler(VIC_InterruptSeparator + i, handle_fasteoi_irq);
+		set_irq_flags(VIC_InterruptSeparator + i, IRQF_VALID);
+	}
+
+	printk("iphone-irq: finished initialization\n");
+}
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/Kconfig iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/Kconfig
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/Kconfig	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,43 @@
+menu "Apple iPhone platform type"
+	depends on MACH_APPLE_IPHONE
+
+choice
+	prompt "Model"
+	default IPHONE_2G
+
+config IPHONE_2G
+	bool "iPhone 2G"
+	help
+	  Select this option if the device is an iPhone 2G.
+
+config IPHONE_3G
+	bool "iPhone 3G"
+	help
+	  Select this option if the device is an iPhone 3G.
+
+config IPODTOUCH_1G
+	bool "iPod touch 1G"
+	help
+	  Select this option if the device is an iPod touch 1G.
+
+endchoice
+
+config IPHONE_PMU
+	bool "iPhone PMU Driver (obsolete)"
+	default n
+	help
+		Select this option to enable the obsolete PMU driver.
+
+config IPHONE_BATTERY
+	bool "iPhone Battery Driver"
+	depends on IPHONE_PMU
+	help
+		Select this option to enable the iPhone battery support with the PMU.
+
+config IPHONE_BACKLIGHT
+	bool "iPhone Backlight Driver"
+	depends on IPHONE_PMU && BACKLIGHT_CLASS_DEVICE
+	help
+		Select this option to enable the iPhone backlight driver.
+
+endmenu
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/lcd.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/lcd.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/lcd.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/lcd.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,21 @@
+/*
+ *  arch/arm/mach-apple_iphone/lcd.h
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+extern int iphonefb_init(void);
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/Makefile iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/Makefile
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,9 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y							+= iphone.o irq.o timer.o power.o clock.o dma.o gpio.o i2c.o spi.o usb.o vfl.o ftl.o nand.o pcf50633.o suspend.o
+
+obj-$(CONFIG_IPHONE_PMU)		+= pmu.o
+obj-$(CONFIG_IPHONE_BATTERY)	+= iphone_battery.o
+obj-$(CONFIG_IPHONE_BACKLIGHT)	+= iphone_bl.o
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/Makefile.boot iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/Makefile.boot
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/Makefile.boot	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/Makefile.boot	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,4 @@
+   zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/nand.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/nand.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/nand.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/nand.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,1154 @@
+#include <mach/hardware.h>
+#include <ftl/nand.h>
+#include <mach/iphone-dma.h>
+#include <mach/iphone-clock.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <ftl/ftl.h>
+
+#define LOG printk
+#define LOGDBG(format, ...)
+
+// Device
+#define NAND_PA 0x38A00000
+#define NANDECC_PA 0x38F00000
+
+#define NAND IO_ADDRESS(NAND_PA)
+#define NANDECC IO_ADDRESS(NANDECC_PA)
+#define NAND_CLOCK_GATE1 0x8
+#define NAND_CLOCK_GATE2 0xC
+#define NANDECC_INT 0x2B
+#define NAND_INT 0x14
+
+// Registers
+#define FMCTRL0 0x0
+#define FMCTRL1 0x4
+#define NAND_CMD 0x8
+#define FMADDR0 0xC
+#define FMANUM 0x2C
+#define FMADDR1 0x10
+#define FMDNUM 0x30
+#define NAND_REG_44 0x44
+#define FMCSTAT 0x48
+#define FMFIFO 0x80
+#define RSCTRL 0x100
+
+#define NANDECC_DATA 0x4
+#define NANDECC_ECC 0x8
+#define NANDECC_START 0xC
+#define NANDECC_STATUS 0x10
+#define NANDECC_SETUP 0x14
+#define NANDECC_CLEARINT 0x40
+
+// Values
+
+#define FMCTRL_TWH_SHIFT 12
+#define FMCTRL_TWP_SHIFT 16
+#define FMCTRL_TWH_MASK 0x7
+#define FMCTRL_TWP_MASK 0x7
+#define FMCTRL0_DMASETTINGSHIFT 10
+#define FMCTRL0_ON 1
+#define FMCTRL0_WPB 0x800
+
+#define NAND_CMD_RESET 0xFF
+#define NAND_CMD_ID 0x90
+#define NAND_CMD_READSTATUS 0x70
+#define NAND_CMD_READ 0x30
+
+#define FMANUM_TRANSFERSETTING 4
+
+#define FMCTRL1_DOTRANSADDR (1 << 0)
+#define FMCTRL1_CLEARALL (FMCTRL1_FLUSHFIFOS | 0x720)
+#define FMCTRL1_FLUSHFIFOS (FMCTRL1_FLUSHRXFIFO | FMCTRL1_FLUSHTXFIFO)
+#define FMCTRL1_FLUSHTXFIFO 0x40
+#define FMCTRL1_FLUSHRXFIFO 0x80
+#define FMCTRL1_DOREADDATA (1 << 1)
+
+#define FMCSTAT_READY 0x1
+
+#define NAND_NUM_BANKS 8
+
+// NAND database
+
+typedef struct NANDDeviceType {
+	uint32_t id;
+	uint16_t blocksPerBank;
+	uint16_t pagesPerBlock;
+	uint16_t sectorsPerPage;
+	uint16_t bytesPerSpare;
+	uint8_t WPPulseTime;
+	uint8_t WEHighHoldTime;
+	uint8_t NANDSetting3;
+	uint8_t NANDSetting4;
+	uint32_t userSuBlksTotal;
+	uint32_t ecc1;
+	uint32_t ecc2;
+} NANDDeviceType;
+
+static const NANDDeviceType SupportedDevices[] = {
+	{0x2555D5EC, 8192, 128, 4, 64, 4, 2, 4, 2, 7744, 4, 6},
+	{0xB614D5EC, 4096, 128, 8, 128, 4, 2, 4, 2, 3872, 4, 6},
+	{0xB655D7EC, 8192, 128, 8, 128, 4, 2, 4, 2, 7744, 4, 6},
+	{0xA514D3AD, 4096, 128, 4, 64, 4, 2, 4, 2, 3872, 4, 6},
+	{0xA555D5AD, 8192, 128, 4, 64, 4, 2, 4, 2, 7744, 4, 6},
+	{0xB614D5AD, 4096, 128, 8, 128, 4, 2, 4, 2, 3872, 4, 6},
+	{0xB655D7AD, 8192, 128, 8, 128, 4, 2, 4, 2, 7744, 4, 6},
+	{0xA585D598, 8320, 128, 4, 64, 6, 2, 4, 2, 7744, 4, 6},
+	{0xBA94D598, 4096, 128, 8, 216, 6, 2, 4, 2, 3872, 8, 8},
+	{0xBA95D798, 8192, 128, 8, 216, 6, 2, 4, 2, 7744, 8, 8},
+	{0x3ED5D789, 8192, 128, 8, 216, 4, 2, 4, 2, 7744, 8, 8},
+	{0x3E94D589, 4096, 128, 8, 216, 4, 2, 4, 2, 3872, 8, 8},
+	{0x3ED5D72C, 8192, 128, 8, 216, 4, 2, 4, 2, 7744, 8, 8},
+	{0x3E94D52C, 4096, 128, 8, 216, 4, 2, 4, 2, 3872, 8, 8},
+	{0}
+};
+
+// NAND configuration
+
+static u8 WEHighHoldTime;
+static u8 WPPulseTime;
+static bool LargePages;
+static int ECCType = 0;
+static int ECCType2;
+static u32 TotalECCDataSize;
+static const bool NoMultibankCmdStatus = true;
+static int NumValidBanks = 0;
+
+static NANDData Geometry;
+static NANDFTLData FTLData;
+
+// NAND state data
+
+static int banksTable[NAND_NUM_BANKS];
+
+// Global buffers
+
+static u8* aTemporaryReadEccBuf;
+static u8* aTemporarySBuf;
+
+// Linux stuff
+
+static struct device *nand_dev;
+
+#ifdef FTL_PROFILE
+static bool InWrite = false;
+u64 Time_wait_for_ecc_interrupt = 0;
+u64 Time_wait_for_ready = 0;
+u64 Time_wait_for_address_done = 0;
+u64 Time_wait_for_command_done = 0;
+u64 Time_wait_for_transfer_done = 0;
+u64 Time_wait_for_nand_bank_ready = 0;
+u64 Time_nand_write = 0;
+u64 Time_iphone_dma_finish = 0;
+#endif
+
+#define VIC1 IO_ADDRESS(0x38E01000)
+#define VICRAWINTR 0x8
+#define VIC_InterruptSeparator 0x20
+static int wait_for_ecc_interrupt(int timeout)
+{
+	u64 startTime = iphone_microtime();
+	u32 mask = (1 << (NANDECC_INT - VIC_InterruptSeparator));
+	while((readl(VIC1 + VICRAWINTR) & mask) == 0) {
+		yield();
+		if(iphone_has_elapsed(startTime, timeout * 1000)) {
+			return -ETIMEDOUT;
+		}
+	}
+
+	writel(1, NANDECC + NANDECC_CLEARINT);
+
+#ifdef FTL_PROFILE
+	if(InWrite) Time_wait_for_ecc_interrupt += iphone_microtime() - startTime;
+#endif
+
+	if((readl(VIC1 + VICRAWINTR) & mask) == 0) {
+		return 0;
+	} else {
+		return -ETIMEDOUT;
+	}
+}
+
+static int ecc_finish(dma_addr_t sectorDMA, dma_addr_t eccDMA, int sectors) {
+	int ret;
+	if((ret = wait_for_ecc_interrupt(500)) != 0)
+		return ret;
+
+	dma_unmap_single(nand_dev, sectorDMA, sectors * SECTOR_SIZE, DMA_BIDIRECTIONAL);
+	dma_unmap_single(nand_dev, eccDMA, sectors* 20, DMA_BIDIRECTIONAL);
+
+	if((readl(NANDECC + NANDECC_STATUS) & 0x1) != 0)
+		return ERROR_ECC;
+
+	return 0;
+}
+
+static int ecc_perform(int setting, int sectors, u8* sectorData, u8* eccData) {
+	dma_addr_t sectorDMA = dma_map_single(nand_dev, sectorData, sectors * SECTOR_SIZE, DMA_BIDIRECTIONAL);
+	dma_addr_t eccDMA = dma_map_single(nand_dev, eccData, sectors * 20, DMA_BIDIRECTIONAL);
+
+	writel(1, NANDECC + NANDECC_CLEARINT);
+	writel(((sectors - 1) & 0x3) | setting, NANDECC + NANDECC_SETUP);
+	writel(sectorDMA, NANDECC + NANDECC_DATA);
+	writel(eccDMA, NANDECC + NANDECC_ECC);
+
+	writel(1, NANDECC + NANDECC_START);
+
+	return ecc_finish(sectorDMA, eccDMA, sectors);
+}
+
+static int ecc_generate(int setting, int sectors, u8* sectorData, u8* eccData) {
+	dma_addr_t sectorDMA = dma_map_single(nand_dev, sectorData, sectors * SECTOR_SIZE, DMA_BIDIRECTIONAL);
+	dma_addr_t eccDMA = dma_map_single(nand_dev, eccData, sectors * 20, DMA_BIDIRECTIONAL);
+
+	writel(1, NANDECC + NANDECC_CLEARINT);
+	writel(((sectors - 1) & 0x3) | setting, NANDECC + NANDECC_SETUP);
+	writel(virt_to_phys(sectorData), NANDECC + NANDECC_DATA);
+	writel(virt_to_phys(eccData), NANDECC + NANDECC_ECC);
+
+	writel(2, NANDECC + NANDECC_START);
+
+	return ecc_finish(sectorDMA, eccDMA, sectors);
+}
+
+static int checkECC(int setting, u8* data, u8* ecc) {
+	int eccSize = 0;
+	u8* dataPtr = data;
+	u8* eccPtr = ecc;
+	int sectorsLeft = Geometry.sectorsPerPage;
+
+	if(setting == 4) {
+		eccSize = 15;
+	} else if(setting == 8) {
+		eccSize = 20;
+	} else if(setting == 0) {
+		eccSize = 10;
+	} else {
+		return ERROR_ECC;
+	}
+
+	while(sectorsLeft > 0) {
+		int toCheck;
+		if(sectorsLeft > 4)
+			toCheck = 4;
+		else
+			toCheck = sectorsLeft;
+
+		if(LargePages) {
+			// If there are more than 4 sectors in a page...
+			int i;
+			for(i = 0; i < toCheck; i++) {
+				// loop through each sector that we have to check this time's ECC
+				u8* x = &eccPtr[eccSize * i]; // first byte of ECC
+				u8* y = x + eccSize - 1; // last byte of ECC
+				while(x < y) {
+					// swap the byte order of them
+					u8 t = *y;
+					*y = *x;
+					*x = t;
+					x++;
+					y--;
+				}
+			}
+		}
+
+		if(ecc_perform(setting, toCheck, dataPtr, eccPtr) != 0)
+			return ERROR_ECC;
+
+		dataPtr += toCheck * SECTOR_SIZE;
+		eccPtr += toCheck * eccSize;
+		sectorsLeft -= toCheck;
+	}
+
+	return 0;
+}
+
+static int generateECC(int setting, u8* data, u8* ecc) {
+	int eccSize = 0;
+	u8* dataPtr = data;
+	u8* eccPtr = ecc;
+	int sectorsLeft = Geometry.sectorsPerPage;
+
+	if(setting == 4) {
+		eccSize = 15;
+	} else if(setting == 8) {
+		eccSize = 20;
+	} else if(setting == 0) {
+		eccSize = 10;
+	} else {
+		return ERROR_ECC;
+	}
+
+	while(sectorsLeft > 0) {
+		int toCheck;
+		if(sectorsLeft > 4)
+			toCheck = 4;
+		else
+			toCheck = sectorsLeft;
+
+		ecc_generate(setting, toCheck, dataPtr, eccPtr);
+
+		if(LargePages) {
+			// If there are more than 4 sectors in a page...
+			int i;
+			for(i = 0; i < toCheck; i++) {
+				// loop through each sector that we have generated this time's ECC
+				u8* x = &eccPtr[eccSize * i]; // first byte of ECC
+				u8* y = x + eccSize - 1; // last byte of ECC
+				while(x < y) {
+					// swap the byte order of them
+					u8 t = *y;
+					*y = *x;
+					*x = t;
+					x++;
+					y--;
+				}
+			}
+		}
+
+		dataPtr += toCheck * SECTOR_SIZE;
+		eccPtr += toCheck * eccSize;
+		sectorsLeft -= toCheck;
+	}
+
+	return 0;
+}
+
+static int wait_for_ready(int timeout) {
+	u64 startTime;
+	if((readl(NAND + FMCSTAT) & FMCSTAT_READY) != 0) {
+		return 0;
+	}
+
+	startTime = iphone_microtime();
+	while((readl(NAND + FMCSTAT) & FMCSTAT_READY) == 0) {
+		yield();
+		if(iphone_has_elapsed(startTime, timeout * 1000)) {
+			return -ETIMEDOUT;
+		}
+	}
+
+#ifdef FTL_PROFILE
+	if(InWrite) Time_wait_for_ready += iphone_microtime() - startTime;
+#endif
+
+	return 0;
+}
+
+static int wait_for_address_done(int timeout) {
+	u64 startTime;
+	if((readl(NAND + FMCSTAT) & (1 << 2)) != 0) {
+		writel(1 << 2, NAND + FMCSTAT);
+		return 0;
+	}
+
+	startTime = iphone_microtime();
+	while((readl(NAND + FMCSTAT) & (1 << 2)) == 0) {
+		yield();
+		if(iphone_has_elapsed(startTime, timeout * 1000)) {
+			return -ETIMEDOUT;
+		}
+	}
+
+	writel(1 << 2, NAND + FMCSTAT);
+
+#ifdef FTL_PROFILE
+	if(InWrite) Time_wait_for_address_done += iphone_microtime() - startTime;
+#endif
+
+	return 0;
+}
+
+static int wait_for_command_done(int bank, int timeout) {
+	u32 toTest;
+
+	u64 startTime = iphone_microtime();
+	if(NoMultibankCmdStatus)
+		bank = 0;
+	else
+		bank &= 0xffff;
+
+	toTest = 1 << (bank + 4);
+
+	while((readl(NAND + FMCSTAT) & toTest) == 0) {
+		yield();
+		if(iphone_has_elapsed(startTime, timeout * 1000)) {
+			return -ETIMEDOUT;
+		}
+	}
+
+	writel(toTest, NAND + FMCSTAT);
+
+#ifdef FTL_PROFILE
+	if(InWrite) Time_wait_for_command_done += iphone_microtime() - startTime;
+#endif
+
+	return 0;
+}
+
+static int wait_for_transfer_done(int timeout) {
+	u64 startTime;
+	if((readl(NAND + FMCSTAT) & (1 << 3)) != 0) {
+		writel(1 << 3, NAND + FMCSTAT);
+		return 0;
+	}
+
+	startTime = iphone_microtime();
+	while((readl(NAND + FMCSTAT) & (1 << 3)) == 0) {
+		yield();
+		if(iphone_has_elapsed(startTime, timeout * 1000)) {
+			return -ETIMEDOUT;
+		}
+	}
+
+	writel(1 << 3, NAND + FMCSTAT);
+
+#ifdef FTL_PROFILE
+	if(InWrite) Time_wait_for_transfer_done += iphone_microtime() - startTime;
+#endif
+
+	return 0;
+}
+
+int nand_read_status(void)
+{
+	int status;
+
+	writel(readl(NAND + NAND_REG_44) & ~(1 << 4), NAND + NAND_REG_44);
+	writel(FMCTRL1_CLEARALL, NAND + FMCTRL1);
+	writel(NAND_CMD_READSTATUS, NAND + NAND_CMD);
+	writel(0, NAND + FMDNUM);
+	writel(FMCTRL1_CLEARALL | FMCTRL1_DOREADDATA, NAND + FMCTRL1);
+
+	wait_for_transfer_done(500);
+
+	status = readl(NAND + FMFIFO);
+	writel(FMCTRL1_CLEARALL, NAND + FMCTRL1);
+	writel(1 << 3, NAND + FMCSTAT);
+	writel(readl(NAND + NAND_REG_44) | (1 << 2), NAND + NAND_REG_44);
+
+	return status;
+}
+
+static int wait_for_nand_bank_ready(int bank)
+{
+	u32 toTest;
+	u64 startTime;
+
+	writel(((WEHighHoldTime & FMCTRL_TWH_MASK) << FMCTRL_TWH_SHIFT) | ((WPPulseTime & FMCTRL_TWP_MASK) << FMCTRL_TWP_SHIFT)
+			| (1 << (banksTable[bank] + 1)) | FMCTRL0_ON | FMCTRL0_WPB, NAND + FMCTRL0);
+
+	toTest = 1 << (bank + 4);
+	if((readl(NAND + FMCSTAT) & toTest) != 0)
+	{
+		writel(toTest, NAND + FMCSTAT);
+	}
+
+	writel(FMCTRL1_FLUSHFIFOS, NAND + FMCTRL1);
+	writel(NAND_CMD_READSTATUS, NAND + NAND_CMD);
+	wait_for_ready(500);
+
+	startTime = iphone_microtime();
+	while(true)
+	{
+		u32 data;
+
+		writel(0, NAND + FMDNUM);
+		writel(FMCTRL1_DOREADDATA, NAND + FMCTRL1);
+
+		if(wait_for_transfer_done(500) != 0)
+		{
+			LOG("nand: wait_for_nand_bank_ready: wait for transfer done timed out\n");
+			return -ETIMEDOUT;
+		}
+
+
+		data = readl(NAND + FMFIFO);
+		writel(FMCTRL1_FLUSHRXFIFO, NAND + FMCTRL1);
+		if((data & (1 << 6)) == 0)
+		{
+			if(iphone_has_elapsed(startTime, 500 * 1000))
+			{
+				LOG("nand: wait_for_nand_bank_ready: wait for bit 6 of DMA timed out\n");
+				return -ETIMEDOUT;
+			}
+		} else
+		{
+			break;
+		}
+	}
+
+	writel(0, NAND + NAND_CMD);
+	wait_for_ready(500);
+
+#ifdef FTL_PROFILE
+	if(InWrite) Time_wait_for_nand_bank_ready += iphone_microtime() - startTime;
+#endif
+
+	return 0;
+}
+
+static int transferFromFlash(void* buffer, int size) {
+	int controller = 0;
+	int channel = 0;
+	dma_addr_t dma;
+
+#ifdef FTL_PROFILE
+	u64 startTime;
+#endif
+
+	if((((u32)buffer) & 0x3) != 0) {
+		// the buffer needs to be aligned for DMA, last two bits have to be clear
+		return -EINVAL;
+	}
+
+	writel(readl(NAND + FMCTRL0) | (1 << FMCTRL0_DMASETTINGSHIFT), NAND + FMCTRL0);
+	writel(size - 1, NAND + FMDNUM);
+	writel(FMCTRL1_DOREADDATA, NAND + FMCTRL1);
+
+	dma = dma_map_single(nand_dev, buffer, size, DMA_FROM_DEVICE);
+
+	iphone_dma_request(IPHONE_DMA_NAND, 4, 4, IPHONE_DMA_MEMORY, 4, 4, &controller, &channel);
+	iphone_dma_perform(IPHONE_DMA_NAND, (u32)dma, size, 0, &controller, &channel);
+
+#ifdef FTL_PROFILE
+	startTime = iphone_microtime();
+#endif
+
+	if(iphone_dma_finish(controller, channel, 500) != 0) {
+		LOG("nand: dma timed out\n");
+		return -ETIMEDOUT;
+	}
+
+#ifdef FTL_PROFILE
+	if(InWrite) Time_iphone_dma_finish += iphone_microtime() - startTime;
+#endif
+
+	if(wait_for_transfer_done(500) != 0) {
+		LOG("nand: waiting for transfer done timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	writel(FMCTRL1_FLUSHFIFOS, NAND + FMCTRL1);
+
+	dma_unmap_single(nand_dev, dma, size, DMA_FROM_DEVICE);
+
+	return 0;
+}
+
+static int transferToFlash(void* buffer, int size) {
+	int controller = 0;
+	int channel = 0;
+	dma_addr_t dma;
+
+#ifdef FTL_PROFILE
+	u64 startTime;
+#endif
+
+	if((((u32)buffer) & 0x3) != 0) {
+		// the buffer needs to be aligned for DMA, last two bits have to be clear
+		return -EINVAL;
+	}
+
+	writel(readl(NAND + FMCTRL0) | (1 << FMCTRL0_DMASETTINGSHIFT), NAND + FMCTRL0);
+	writel(size - 1, NAND + FMDNUM);
+	writel(0x7F4, NAND + FMCTRL1);
+
+	dma = dma_map_single(nand_dev, buffer, size, DMA_TO_DEVICE);
+
+	iphone_dma_request(IPHONE_DMA_MEMORY, 4, 4, IPHONE_DMA_NAND, 4, 4, &controller, &channel);
+	iphone_dma_perform((u32)dma, IPHONE_DMA_NAND, size, 0, &controller, &channel);
+
+#ifdef FTL_PROFILE
+	startTime = iphone_microtime();
+#endif
+
+	if(iphone_dma_finish(controller, channel, 500) != 0) {
+		LOG("nand: dma timed out\n");
+		return -ETIMEDOUT;
+	}
+
+#ifdef FTL_PROFILE
+	if(InWrite) Time_iphone_dma_finish += iphone_microtime() - startTime;
+#endif
+
+	if(wait_for_transfer_done(500) != 0) {
+		LOG("nand: waiting for transfer done timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	writel(FMCTRL1_FLUSHFIFOS, NAND + FMCTRL1);
+
+	dma_unmap_single(nand_dev, dma, size, DMA_TO_DEVICE);
+
+	return 0;
+}
+
+static bool isEmptyBlock(u8* buffer, int size) {
+	int i;
+	int found = 0;
+	for(i = 0; i < size; i++) {
+		if(buffer[i] != 0xFF) {
+			found++;
+		}
+	}
+
+	if(found <= 1)
+		return true;
+	else
+		return false;
+}
+
+int nand_read(int bank, int page, u8* buffer, u8* spare, bool doECC, bool checkBlank)
+{
+	bool eccFailed;
+
+	if(bank >= Geometry.banksTotal)
+		return -EINVAL;
+
+	if(page >= Geometry.pagesPerBank)
+		return -EINVAL;
+
+	if(buffer == NULL && spare == NULL)
+		return -EINVAL;
+
+#ifdef FTL_PROFILE
+	InWrite = true;
+#endif
+
+	writel(((WEHighHoldTime & FMCTRL_TWH_MASK) << FMCTRL_TWH_SHIFT) | ((WPPulseTime & FMCTRL_TWP_MASK) << FMCTRL_TWP_SHIFT)
+		| (1 << (banksTable[bank] + 1)) | FMCTRL0_ON | FMCTRL0_WPB, NAND + FMCTRL0);
+
+	writel(0, NAND + NAND_CMD);
+	if(wait_for_ready(500) != 0) {
+		LOG("nand: bank setting failed\n");
+		goto FIL_read_error;
+	}
+
+	writel(FMANUM_TRANSFERSETTING, NAND + FMANUM);
+
+	if(buffer) {
+		writel(page << 16, NAND + FMADDR0); // lower bits of the page number to the upper bits of CONFIG3
+		writel((page >> 16) & 0xFF, NAND + FMADDR1); // upper bits of the page number
+
+	} else {
+		writel((page << 16) | Geometry.bytesPerPage, NAND + FMADDR0); // lower bits of the page number to the upper bits of CONFIG3
+		writel((page >> 16) & 0xFF, NAND + FMADDR1); // upper bits of the page number
+	}
+
+	writel(FMCTRL1_DOTRANSADDR, NAND + FMCTRL1);
+	if(wait_for_address_done(500) != 0) {
+		LOG("nand: sending address failed\n");
+		goto FIL_read_error;
+	}
+
+	writel(NAND_CMD_READ, NAND + NAND_CMD);
+	if(wait_for_ready(500) != 0) {
+		LOG("nand: sending read command failed\n");
+		goto FIL_read_error;
+	}
+
+	if(wait_for_nand_bank_ready(bank) != 0) {
+		LOG("nand: nand bank not ready after a long time\n");
+		goto FIL_read_error;
+	}
+
+	if(buffer) {
+		if(transferFromFlash(buffer, Geometry.bytesPerPage) != 0) {
+			LOG("nand: transferFromFlash failed\n");
+			goto FIL_read_error;
+		}
+	}
+
+	if(transferFromFlash(aTemporarySBuf, Geometry.bytesPerSpare) != 0) {
+		LOG("nand: transferFromFlash for spare failed\n");
+		goto FIL_read_error;
+	}
+
+	eccFailed = false;
+	if(doECC) {
+		if(buffer) {
+			eccFailed = (checkECC(ECCType, buffer, aTemporarySBuf + sizeof(SpareData)) != 0);
+		}
+
+		memcpy(aTemporaryReadEccBuf, aTemporarySBuf, sizeof(SpareData));
+		if(ecc_perform(ECCType, 1, aTemporaryReadEccBuf, aTemporarySBuf + sizeof(SpareData) + TotalECCDataSize) != 0)
+		{
+			memset(aTemporaryReadEccBuf, 0xFF, SECTOR_SIZE);
+			eccFailed |= 1;
+		}
+	}
+
+	if(spare) {
+		if(doECC) {
+			// We can only copy the first 12 bytes because the rest is probably changed by the ECC check routine
+			memcpy(spare, aTemporaryReadEccBuf, sizeof(SpareData));
+		} else {
+			memcpy(spare, aTemporarySBuf, Geometry.bytesPerSpare);
+		}
+	}
+
+	if(eccFailed || checkBlank) {
+		if(isEmptyBlock(aTemporarySBuf, Geometry.bytesPerSpare) != 0) {
+#ifdef FTL_PROFILE
+			InWrite = false;
+#endif
+			return ERROR_EMPTYBLOCK;
+		} else if(eccFailed) {
+#ifdef FTL_PROFILE
+			InWrite = false;
+#endif
+			return -EIO;
+		}
+	}
+
+#ifdef FTL_PROFILE
+	InWrite = false;
+#endif
+	return 0;
+
+FIL_read_error:
+	nand_bank_reset(bank, 100);
+#ifdef FTL_PROFILE
+	InWrite = false;
+#endif
+	return -EIO;
+}
+
+int nand_read_multiple(u16* bank, u32* pages, u8* main, SpareData* spare, int pagesCount)
+{
+	int i;
+	unsigned int ret;
+	for(i = 0; i < pagesCount; i++) {
+		ret = nand_read(bank[i], pages[i], main, (u8*) &spare[i], true, true);
+		if(ret > 1)
+			return ret;
+
+		main += Geometry.bytesPerPage;
+	}
+
+	return 0;
+}
+
+int nand_read_alternate_ecc(int bank, int page, u8* buffer) {
+	int ret;
+	if((ret = nand_read(bank, page, buffer, aTemporarySBuf, false, true)) != 0) {
+		LOGDBG("nand: Raw read failed.\n");
+		return ret;
+	}
+
+	if(checkECC(ECCType2, buffer, aTemporarySBuf) != 0) {
+		LOGDBG("nand: Alternate ECC check failed, but raw read succeeded.\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+int nand_erase(int bank, int block)
+{
+	int pageAddr;
+
+	if(bank >= Geometry.banksTotal)
+		return -EINVAL;
+
+	if(block >= Geometry.blocksPerBank)
+		return -EINVAL;
+
+	pageAddr = block * Geometry.pagesPerBlock;
+
+	writel(((WEHighHoldTime & FMCTRL_TWH_MASK) << FMCTRL_TWH_SHIFT) | ((WPPulseTime & FMCTRL_TWP_MASK) << FMCTRL_TWP_SHIFT)
+		| (1 << (banksTable[bank] + 1)) | FMCTRL0_ON | FMCTRL0_WPB, NAND + FMCTRL0);
+
+	writel(FMCTRL1_CLEARALL, NAND + FMCTRL1);
+	writel(0x60, NAND + NAND_CMD);
+
+	writel(2, NAND + FMANUM);
+	writel(pageAddr, NAND + FMADDR0);
+	writel(FMCTRL1_DOTRANSADDR, NAND + FMCTRL1);
+
+	if(wait_for_address_done(500) != 0) {
+		LOG("nand (nand_erase): wait for address complete failed\n");
+		goto FIL_erase_error;
+	}
+
+	writel(0xD0, NAND + NAND_CMD);
+	wait_for_ready(500);
+
+	while((nand_read_status() & (1 << 6)) == 0);
+
+	if(nand_read_status() & 0x1)
+		return -1;
+	else
+		return 0;
+
+FIL_erase_error:
+	return -1;
+}
+
+int nand_write(int bank, int page, u8* buffer, u8* spare, bool doECC)
+{
+#ifdef FTL_PROFILE
+	u64 startTime;
+#endif
+
+	if(bank >= Geometry.banksTotal)
+		return -EINVAL;
+
+	if(page >= Geometry.pagesPerBank)
+		return -EINVAL;
+
+	if(buffer == NULL && spare == NULL)
+		return -EINVAL;
+
+#ifdef FTL_PROFILE
+	InWrite = true;
+	startTime = iphone_microtime();
+#endif
+
+	if(doECC) {
+		memcpy(aTemporarySBuf, spare, sizeof(SpareData));
+		if(generateECC(ECCType, buffer, aTemporarySBuf + sizeof(SpareData)) != 0) {
+			LOG("nand: Unexpected error during ECC generation\n");
+#ifdef FTL_PROFILE
+			InWrite = false;
+#endif
+			return -EINVAL;
+		}
+
+		memset(aTemporaryReadEccBuf, 0xFF, SECTOR_SIZE);
+		memcpy(aTemporaryReadEccBuf, spare, sizeof(SpareData));
+
+		ecc_generate(ECCType, 1, aTemporaryReadEccBuf, aTemporarySBuf + sizeof(SpareData) + TotalECCDataSize);
+	}
+
+	writel(((WEHighHoldTime & FMCTRL_TWH_MASK) << FMCTRL_TWH_SHIFT) | ((WPPulseTime & FMCTRL_TWP_MASK) << FMCTRL_TWP_SHIFT)
+		| (1 << (banksTable[bank] + 1)) | FMCTRL0_ON | FMCTRL0_WPB, NAND + FMCTRL0);
+
+	writel(0x80, NAND + NAND_CMD);
+	if(wait_for_ready(500) != 0) {
+		LOG("nand: bank setting failed\n");
+		goto FIL_write_error;
+	}
+
+	writel(FMANUM_TRANSFERSETTING, NAND + FMANUM);
+
+	if(buffer) {
+		writel(page << 16, NAND + FMADDR0); // lower bits of the page number to the upper bits of CONFIG3
+		writel((page >> 16) & 0xFF, NAND + FMADDR1); // upper bits of the page number
+	} else {
+		writel((page << 16) | Geometry.bytesPerPage, NAND + FMADDR0); // lower bits of the page number to the upper bits of CONFIG3
+		writel((page >> 16) & 0xFF, NAND + FMADDR1); // upper bits of the page number
+	}
+
+	writel(FMCTRL1_DOTRANSADDR, NAND + FMCTRL1);
+	if(wait_for_address_done(500) != 0) {
+		LOG("nand: setup transfer failed\n");
+		goto FIL_write_error;
+	}
+
+	if(buffer) {
+		if(transferToFlash(buffer, Geometry.bytesPerPage) != 0) {
+			LOG("nand: transferToFlash failed\n");
+			goto FIL_write_error;
+		}
+	}
+
+	if(transferToFlash(aTemporarySBuf, Geometry.bytesPerSpare) != 0) {
+		LOG("nand: transferToFlash for spare failed\n");
+		goto FIL_write_error;
+	}
+
+	writel(0x10, NAND + NAND_CMD);
+	wait_for_ready(500);
+
+	while((nand_read_status() & (1 << 6)) == 0);
+
+	if(nand_read_status() & 0x1)
+	{
+#ifdef FTL_PROFILE
+		Time_nand_write += iphone_microtime() - startTime;
+		InWrite = false;
+#endif
+		return -1;
+	} else
+	{
+#ifdef FTL_PROFILE
+		Time_nand_write += iphone_microtime() - startTime;
+		InWrite = false;
+#endif
+		return 0;
+	}
+
+#ifdef FTL_PROFILE
+	Time_nand_write += iphone_microtime() - startTime;
+	InWrite = false;
+#endif
+	return 0;
+
+FIL_write_error:
+	nand_bank_reset(bank, 100);
+#ifdef FTL_PROFILE
+	Time_nand_write += iphone_microtime() - startTime;
+	InWrite = false;
+#endif
+	return -EIO;
+}
+
+int nand_bank_reset(int bank, int timeout)
+{
+	int ret;
+
+	writel(((WEHighHoldTime & FMCTRL_TWH_MASK) << FMCTRL_TWH_SHIFT) | ((WPPulseTime & FMCTRL_TWP_MASK) << FMCTRL_TWP_SHIFT)
+			| (1 << (banksTable[bank] + 1)) | FMCTRL0_ON | FMCTRL0_WPB, NAND + FMCTRL0);
+
+	writel(NAND_CMD_RESET, NAND + NAND_CMD);
+
+	ret = wait_for_ready(timeout);
+	if(ret == 0) {
+		ret = wait_for_command_done(bank, timeout);
+		msleep(1);
+		return ret;
+	} else {
+		msleep(1);
+		return ret;
+	}
+}
+
+NANDFTLData* nand_get_ftl_data(void)
+{
+	return &FTLData;
+}
+
+NANDData* nand_get_geometry(void)
+{
+	return &Geometry;
+}
+
+int nand_setup(void)
+{
+	int bank;
+	const NANDDeviceType* nandType = NULL;
+	const NANDDeviceType* candidate;
+	u32 id;
+
+	WEHighHoldTime = 7;
+	WPPulseTime = 7;
+
+	LOG("nand: Probing flash controller...\n");
+
+	iphone_clock_gate_switch(NAND_CLOCK_GATE1, true);
+	iphone_clock_gate_switch(NAND_CLOCK_GATE2, true);
+
+	for(bank = 0; bank < NAND_NUM_BANKS; bank++) {
+		banksTable[bank] = bank;
+	}
+
+	NumValidBanks = 0;
+
+	writel(0, NAND + RSCTRL);
+	writel(readl(NAND + RSCTRL) | (ECCType << 4), NAND + RSCTRL);
+
+	for(bank = 0; bank < NAND_NUM_BANKS; bank++) {
+		nand_bank_reset(bank, 100);
+
+		writel(FMCTRL1_FLUSHFIFOS, NAND + FMCTRL1);
+		writel(((WEHighHoldTime & FMCTRL_TWH_MASK) << FMCTRL_TWH_SHIFT) | ((WPPulseTime & FMCTRL_TWP_MASK) << FMCTRL_TWP_SHIFT)
+			| (1 << (banksTable[bank] + 1)) | FMCTRL0_ON | FMCTRL0_WPB, NAND + FMCTRL0);
+
+		writel(NAND_CMD_ID, NAND + NAND_CMD);
+
+		wait_for_ready(500);
+
+		writel(0, NAND + FMANUM);
+		writel(0, NAND + FMADDR0);
+		writel(FMCTRL1_DOTRANSADDR, NAND + FMCTRL1);
+
+		wait_for_address_done(500);
+		wait_for_command_done(bank, 100);
+
+		writel(8, NAND + FMDNUM);
+		writel(FMCTRL1_DOREADDATA, NAND + FMCTRL1);
+
+		wait_for_transfer_done(500);
+		id = readl(NAND + FMFIFO);
+		candidate = SupportedDevices;
+		while(candidate->id != 0) {
+			if(candidate->id == id) {
+				if(nandType == NULL) {
+					nandType = candidate;
+				} else if(nandType != candidate) {
+					LOG("nand: Mismatched device IDs (0x%08x after 0x%08x)\n", id, nandType->id);
+					return -EINVAL;
+				}
+				banksTable[NumValidBanks++] = bank;
+			}
+			candidate++;
+		}
+
+		writel(FMCTRL1_FLUSHFIFOS, NAND + FMCTRL1);
+	}
+
+	if(nandType == NULL) {
+		LOG("nand: No supported NAND found\n");
+		return -EINVAL;
+	}
+
+	Geometry.DeviceID = nandType->id;
+	Geometry.banksTable = banksTable;
+
+	WPPulseTime = (((FREQUENCY_BUS * (nandType->WPPulseTime + 1)) + 99999999)/100000000) - 1;
+	WEHighHoldTime = (((FREQUENCY_BUS * (nandType->WEHighHoldTime + 1)) + 99999999)/100000000) - 1;
+
+	if(WPPulseTime > 7)
+		WPPulseTime = 7;
+
+	if(WEHighHoldTime > 7)
+		WEHighHoldTime = 7;
+
+	Geometry.blocksPerBank = nandType->blocksPerBank;
+	Geometry.banksTotal = NumValidBanks;
+	Geometry.sectorsPerPage = nandType->sectorsPerPage;
+	Geometry.userSuBlksTotal = nandType->userSuBlksTotal;
+	Geometry.bytesPerSpare = nandType->bytesPerSpare;
+	Geometry.field_2E = 4;
+	Geometry.field_2F = 3;
+	Geometry.pagesPerBlock = nandType->pagesPerBlock;
+
+	if(Geometry.sectorsPerPage > 4) {
+		LargePages = true;
+	} else {
+		LargePages = false;
+	}
+
+	if(nandType->ecc1 == 6) {
+		ECCType = 4;
+		TotalECCDataSize = Geometry.sectorsPerPage * 15;
+	} else if(nandType->ecc1 == 8) {
+		ECCType = 8;
+		TotalECCDataSize = Geometry.sectorsPerPage * 20;
+	} else if(nandType->ecc1 == 4) {
+		ECCType = 0;
+		TotalECCDataSize = Geometry.sectorsPerPage * 10;
+	}
+
+	if(nandType->ecc2 == 6) {
+		ECCType2 = 4;
+	} else if(nandType->ecc2 == 8) {
+		ECCType2 = 8;
+	} else if(nandType->ecc2 == 4) {
+		ECCType2 = 0;
+	}
+
+	Geometry.field_4 = 5;
+	Geometry.bytesPerPage = SECTOR_SIZE * Geometry.sectorsPerPage;
+	Geometry.pagesPerBank = Geometry.pagesPerBlock * Geometry.blocksPerBank;
+	Geometry.pagesTotal = Geometry.pagesPerBank * Geometry.banksTotal;
+	Geometry.pagesPerSuBlk = Geometry.pagesPerBlock * Geometry.banksTotal;
+	Geometry.userPagesTotal = Geometry.userSuBlksTotal * Geometry.pagesPerSuBlk;
+	Geometry.suBlksTotal = (Geometry.banksTotal * Geometry.blocksPerBank) / Geometry.banksTotal;
+
+	FTLData.field_2 = Geometry.suBlksTotal - Geometry.userSuBlksTotal - 28;
+	FTLData.sysSuBlks = FTLData.field_2 + 4;
+	FTLData.field_4 = FTLData.field_2 + 5;
+	FTLData.field_6 = 3;
+	FTLData.field_8 = 23;
+	if(FTLData.field_8 == 0)
+		Geometry.field_22 = 0;
+
+	{
+		int bits = 0;
+		int i = FTLData.field_8;
+		while((i <<= 1) != 0) {
+			bits++;
+		}
+
+		Geometry.field_22 = bits;
+	}
+
+	LOG("nand: DEVICE: %08x\n", Geometry.DeviceID);
+	LOG("nand: BANKS_TOTAL: %d\n", Geometry.banksTotal);
+	LOG("nand: BLOCKS_PER_BANK: %d\n", Geometry.blocksPerBank);
+	LOG("nand: SUBLKS_TOTAL: %d\n", Geometry.suBlksTotal);
+	LOG("nand: USER_SUBLKS_TOTAL: %d\n", Geometry.userSuBlksTotal);
+	LOG("nand: PAGES_PER_SUBLK: %d\n", Geometry.pagesPerSuBlk);
+	LOG("nand: PAGES_PER_BANK: %d\n", Geometry.pagesPerBank);
+	LOG("nand: SECTORS_PER_PAGE: %d\n", Geometry.sectorsPerPage);
+	LOG("nand: BYTES_PER_SPARE: %d\n", Geometry.bytesPerSpare);
+	LOG("nand: BYTES_PER_PAGE: %d\n", Geometry.bytesPerPage);
+	LOG("nand: PAGES_PER_BLOCK: %d\n", Geometry.pagesPerBlock);
+
+	aTemporaryReadEccBuf = (uint8_t*) kmalloc(Geometry.bytesPerPage, GFP_KERNEL | GFP_DMA);
+	memset(aTemporaryReadEccBuf, 0xFF, SECTOR_SIZE);
+
+	aTemporarySBuf = (uint8_t*) kmalloc(Geometry.bytesPerSpare, GFP_KERNEL | GFP_DMA);
+
+	return 0;
+}
+
+static int __devinit iphone_nand_probe(struct platform_device *pdev)
+{
+	nand_dev = &pdev->dev;
+	return 0;
+}
+
+static int __devexit iphone_nand_remove(struct platform_device *pdev)
+{
+	kfree(aTemporarySBuf);
+	kfree(aTemporaryReadEccBuf);
+	return 0;
+}
+
+static struct resource iphone_nand_resources[] = {
+	[0] = {
+		.start  = NAND_PA,
+		.end    = NAND_PA + 0x1000 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = NANDECC_PA,
+		.end    = NANDECC_PA + 0x1000 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[2] = {
+		.start  = NANDECC_INT,
+		.end    = NANDECC_INT,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device iphone_nand = {
+	.name           = "iphone-nand",
+	.id             = -1,
+	.num_resources  = ARRAY_SIZE(iphone_nand_resources),
+	.resource       = iphone_nand_resources,
+};
+
+static struct platform_driver iphone_nand_driver = {
+	.driver         = {
+		.name   = "iphone-nand",
+		.owner  = THIS_MODULE,
+	},
+	.probe          = iphone_nand_probe,
+	.remove         = __devexit_p(iphone_nand_remove),
+	.suspend        = NULL,
+	.resume         = NULL,
+};
+
+static int __init iphone_nand_modinit(void)
+{
+	        return platform_driver_register(&iphone_nand_driver);
+}
+
+static void __exit iphone_nand_modexit(void)
+{
+	        platform_driver_unregister(&iphone_nand_driver);
+}
+
+module_init(iphone_nand_modinit);
+module_exit(iphone_nand_modexit);
+
+MODULE_DESCRIPTION("iPhone NAND Flash Media Interface");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/pcf50633.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/pcf50633.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/pcf50633.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/pcf50633.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,330 @@
+/*
+ * pcf50633 - PCF50633 Platform-side data and code.
+ *
+ * Copyright 2010 Ricky Taylor
+ *
+ * This file is part of iDroid. An android distribution for Apple products.
+ * For more information, please visit http://www.idroidproject.org/.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/delay.h>
+#include <linux/power_supply.h>
+
+#include <mach/pmu.h>
+
+#if POWER_PCF50633
+
+struct platform_device iphone_backlight = {
+	.name           = "pcf50633-backlight",
+	.id             = -1,
+	.num_resources  = 0,
+};
+
+static struct power_supply iphone_battery;
+static struct pcf50633 *pcf50633;
+static struct {
+	struct delayed_work monitor_work;
+
+	int voltage;
+	int level;
+} iphone_battery_info;
+
+static void iphone_battery_update_status(struct pcf50633 *pcf, void *unused, int res)
+{
+	const int interval = msecs_to_jiffies(60 * 1000);
+
+	int voltage = (res*6000)/1023;
+	int level = ((voltage - 3500) * 100) / (4200 - 3500);
+	if(level < 0)
+		level = 0;
+	if(level > 100)
+		level = 100;
+	
+	dev_info(pcf50633->dev, "V:%d, L:%d\n", voltage, level);
+
+	iphone_battery_info.voltage = voltage;
+	iphone_battery_info.level = level;
+
+	power_supply_changed(&iphone_battery);
+
+	if(unused)
+		schedule_delayed_work(&iphone_battery_info.monitor_work, interval);
+}
+
+static void iphone_battery_work(struct work_struct* work)
+{
+	const int interval = msecs_to_jiffies(60 * 1000);
+
+	if(platform_get_drvdata(pcf50633->adc_pdev) == NULL || pcf50633_adc_async_read(pcf50633, PCF50633_ADCC1_MUX_BATSNS_RES, PCF50633_ADCC1_AVERAGE_16, &iphone_battery_update_status, (void*)1) < 0)
+	{
+		dev_err(pcf50633->dev, "failed to get battery level\n");
+		schedule_delayed_work(&iphone_battery_info.monitor_work, interval);
+	}
+}
+
+static int iphone_battery_get_property(struct power_supply *psy,
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	int charging = 0;
+	int status = 0;
+
+	if(pcf50633 && platform_get_drvdata(pcf50633->mbc_pdev))
+	{
+		status = pcf50633_mbc_get_status(pcf50633);
+		charging = (status & (PCF50633_MBC_USB_ONLINE | PCF50633_MBC_ADAPTER_ONLINE)) != 0;
+	}
+	else
+		dev_err(pcf50633->dev, "failed to contact mbc for charging state.\n");
+
+	dev_info(pcf50633->dev, "status: %d, charging: %d.\n", status, charging);
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+			if(charging)
+			{
+				if(iphone_battery_info.level == 100)
+				       	val->intval = POWER_SUPPLY_STATUS_FULL;
+				else
+				       	val->intval = POWER_SUPPLY_STATUS_CHARGING;
+			}
+			else
+			{
+			    val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+			}
+			break;
+		case POWER_SUPPLY_PROP_HEALTH:
+			val->intval = POWER_SUPPLY_HEALTH_GOOD;
+			/* TODO: we might need to set POWER_SUPPLY_HEALTH_OVERHEAT if we figure out the battery temperature stuff */
+			break;
+		case POWER_SUPPLY_PROP_PRESENT:
+			val->intval = (iphone_battery_info.voltage > 0) ? 1: 0;
+			break;
+		case POWER_SUPPLY_PROP_TECHNOLOGY:
+			val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+			break;
+		case POWER_SUPPLY_PROP_CAPACITY:
+			val->intval = iphone_battery_info.level;
+			break;
+		case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+			val->intval = iphone_battery_info.voltage * 1000;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static enum power_supply_property iphone_battery_properties[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+};
+
+static char* iphone_batteries[] = {
+	"battery",
+};
+
+static struct power_supply iphone_battery = {
+	.name = "battery",
+	.type = POWER_SUPPLY_TYPE_BATTERY,
+	.properties = iphone_battery_properties,
+	.num_properties = ARRAY_SIZE(iphone_battery_properties),
+	.get_property = iphone_battery_get_property,
+};
+
+static void pcf50633_event_callback(struct pcf50633 *_pcf, int _i)
+{
+	if(platform_get_drvdata(pcf50633->adc_pdev) == NULL || pcf50633_adc_async_read(pcf50633, PCF50633_ADCC1_MUX_BATSNS_RES, PCF50633_ADCC1_AVERAGE_16, &iphone_battery_update_status, NULL) < 0)
+	{
+		dev_err(pcf50633->dev, "failed to get battery level\n");
+	}
+
+	power_supply_changed(&iphone_battery);
+}
+
+static void pcf50633_probe_done(struct pcf50633 *_pcf)
+{
+	int ret;
+
+	pcf50633 = _pcf;
+
+	iphone_battery_info.voltage = 0;
+	iphone_battery_info.level = 50;
+
+	ret = power_supply_register(_pcf->dev, &iphone_battery);
+	if(ret)
+		dev_err(_pcf->dev, "failed to register battery power supply!\n");
+
+	INIT_DELAYED_WORK(&iphone_battery_info.monitor_work, iphone_battery_work);
+
+	iphone_backlight.dev.platform_data = _pcf;
+	if(platform_device_register(&iphone_backlight) < 0)
+		dev_err(_pcf->dev, "failed to create backlight driver!\n");
+	
+	// Start the battery level watcher.
+	iphone_battery_work(NULL);
+}
+
+struct pcf50633_platform_data pcf50633_pdata = {
+	.resumers = {
+		[0] =	PCF50633_INT1_USBINS |
+			PCF50633_INT1_USBREM |
+			PCF50633_INT1_ALARM,
+		[1] =	PCF50633_INT2_ONKEYF,
+		[2] =	PCF50633_INT3_ONKEY1S,
+		[3] =	PCF50633_INT4_LOWSYS |
+			PCF50633_INT4_LOWBAT |
+			PCF50633_INT4_HIGHTMP,
+	},
+
+	.reg_init_data = {
+		[PCF50633_REGULATOR_AUTO] = {
+			.constraints = {
+				.min_uV = 3300000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.always_on = 1,
+				.apply_uV = 1,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+		},
+		[PCF50633_REGULATOR_DOWN1] = {
+			.constraints = {
+				.min_uV = 1300000,
+				.max_uV = 1600000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.always_on = 1,
+				.apply_uV = 1,
+			},
+		},
+		[PCF50633_REGULATOR_DOWN2] = {
+			.constraints = {
+				.min_uV = 1800000,
+				.max_uV = 1800000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+				.always_on = 1,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+		},
+		[PCF50633_REGULATOR_HCLDO] = {
+			.constraints = {
+				.min_uV = 2000000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+				.always_on = 1,
+			},
+		},
+		[PCF50633_REGULATOR_LDO1] = {
+			.constraints = {
+				.min_uV = 3300000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+				.state_mem = {
+					.enabled = 0,
+				},
+			},
+		},
+		[PCF50633_REGULATOR_LDO2] = {
+			.constraints = {
+				.min_uV = 3300000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+		},
+		[PCF50633_REGULATOR_LDO3] = {
+			.constraints = {
+				.min_uV = 3000000,
+				.max_uV = 3000000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+		},
+		[PCF50633_REGULATOR_LDO4] = {
+			.constraints = {
+				.min_uV = 3200000,
+				.max_uV = 3200000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+		},
+		[PCF50633_REGULATOR_LDO5] = {
+			.constraints = {
+				.min_uV = 3000000,
+				.max_uV = 3000000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+		},
+		[PCF50633_REGULATOR_LDO6] = {
+			.constraints = {
+				.min_uV = 3000000,
+				.max_uV = 3000000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+			},
+		},
+		[PCF50633_REGULATOR_MEMLDO] = {
+			.constraints = {
+				.min_uV = 1800000,
+				.max_uV = 1800000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+		},
+
+	},
+
+	.probe_done = &pcf50633_probe_done,
+	.mbc_event_callback = &pcf50633_event_callback,
+
+	.batteries = iphone_batteries,
+	.num_batteries = ARRAY_SIZE(iphone_batteries),
+};
+
+#endif
+
+void pcf50633_power_off(void)
+{
+#if POWER_PCF50633
+	if(pcf50633)
+	{
+		pcf50633_reg_write(pcf50633, 0x0d, 0x1); // Only ONKEY can wake the device up.
+		pcf50633_reg_write(pcf50633, 0x0f, 0x7); // Set the debounce for ONKEY to 2s.
+		pcf50633_reg_write(pcf50633, 0x76, 0x80); // No idea what this does.
+		pcf50633_reg_write(pcf50633, PCF50633_REG_OOCSHDWN, 2 | 1); // Yes, we're setting a reserved bit.
+
+		printk("PCF50633 shutdown complete.\n");
+	}
+#endif
+}
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/pmu.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/pmu.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/pmu.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/pmu.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,318 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/i2c.h>
+#include <mach/pmu.h>
+#include <linux/i2c.h>
+#include <mach/gpio.h>
+
+
+static struct i2c_client *pmu_i2c;
+static struct rtc_device *rtc;
+
+
+static int iphone_pmu_get_reg(int reg) {
+	return i2c_smbus_read_byte_data(pmu_i2c, reg);
+}
+
+static int iphone_pmu_get_regs(int reg, uint8_t* out, int count) {
+	struct i2c_msg xfer[2];
+	int ret;
+ 
+	xfer[0].addr = PMU_GETADDR;
+	xfer[0].flags = 0;
+	xfer[0].len = 1;
+	xfer[0].buf = (u8 *)&reg;
+
+	xfer[1].addr = PMU_GETADDR;
+	xfer[1].flags = I2C_M_RD;
+	xfer[1].len = count;
+	xfer[1].buf = (u8 *)out;
+ 
+	ret = i2c_transfer(pmu_i2c->adapter, xfer, 2);
+
+	return ret;
+}
+
+static int iphone_pmu_write_reg(int reg, int data, int verify) {
+	uint8_t buffer = 0;
+
+	i2c_smbus_write_byte_data(pmu_i2c, reg, data);
+
+	if(!verify)
+		return 0;
+
+	buffer = iphone_pmu_get_reg(reg);
+
+	if(buffer == data)
+		return 0;
+	else
+		return -1;
+}
+
+static int query_adc(int flags) {
+	uint8_t lower;
+	iphone_pmu_write_reg(PMU_ADCC3, 0, 0);
+	iphone_pmu_write_reg(PMU_ADCC3, 0, 0);
+	udelay(30);
+	iphone_pmu_write_reg(PMU_ADCC2, 0, 0);
+	iphone_pmu_write_reg(PMU_ADCC1, PMU_ADCC1_ADCSTART | (PMU_ADCC1_ADC_AV_16 << PMU_ADCC1_ADC_AV_SHIFT) | flags, 0);
+	msleep(30);
+	lower = iphone_pmu_get_reg(PMU_ADCS3);
+	if((lower & 0x80) == 0x80) {
+		uint8_t upper = iphone_pmu_get_reg(PMU_ADCS1);
+		return ((upper << 2) | (lower & 0x3)) * 6000 / 1023;
+	} else {
+		return -1;
+	}
+}
+
+static PowerSupplyType identify_usb_charger(void) {
+	int dn;
+	int dp;
+	int x;
+
+	iphone_gpio_pin_output(PMU_GPIO_CHARGER_IDENTIFY_DN, 1);
+	dn = query_adc(PMU_ADCC1_ADCINMUX_ADCIN2_DIV << PMU_ADCC1_ADCINMUX_SHIFT);
+	if(dn < 0)
+		dn = 0;
+	iphone_gpio_pin_output(PMU_GPIO_CHARGER_IDENTIFY_DN, 0);
+
+	iphone_gpio_pin_output(PMU_GPIO_CHARGER_IDENTIFY_DP, 1);
+	dp = query_adc(PMU_ADCC1_ADCINMUX_ADCIN2_DIV << PMU_ADCC1_ADCINMUX_SHIFT);
+	if(dp < 0)
+		dp = 0;
+	iphone_gpio_pin_output(PMU_GPIO_CHARGER_IDENTIFY_DP, 0);
+
+	if(dn < 99 || dp < 99) {
+		return PowerSupplyTypeUSBHost;
+	}
+
+	x = (dn * 1000) / dp;
+	if((x - 1291) <= 214) {
+		return PowerSupplyTypeUSBBrick1000mA;
+	}
+
+	if((x - 901) <= 219 && dn <= 367 ) {
+		return PowerSupplyTypeUSBBrick500mA;
+	} else {
+		return PowerSupplyTypeUSBHost;
+	}
+}
+
+PowerSupplyType iphone_pmu_get_power_supply(void) {
+	int mbcs1 = iphone_pmu_get_reg(PMU_MBCS1);
+
+	if(mbcs1 & PMU_MBCS1_ADAPTPRES)
+		return PowerSupplyTypeFirewire;
+
+	if(mbcs1 & PMU_MBCS1_USBOK)
+		return identify_usb_charger();
+	else
+		return PowerSupplyTypeBattery;
+
+}
+
+void iphone_pmu_charge_settings(int UseUSB, int SuspendUSB, int StopCharger)
+{
+	PowerSupplyType type = iphone_pmu_get_power_supply();
+
+	if(type != PowerSupplyTypeUSBHost)	// No need to suspend USB, since we're not plugged into a USB host
+		SuspendUSB = 0;
+
+	if(SuspendUSB)
+		iphone_gpio_pin_output(PMU_GPIO_CHARGER_USB_SUSPEND, 1);
+	else
+		iphone_gpio_pin_output(PMU_GPIO_CHARGER_USB_SUSPEND, 0);
+
+	if(StopCharger) {
+		iphone_gpio_pin_output(PMU_GPIO_CHARGER_SUSPEND, 1);
+		iphone_gpio_pin_output(PMU_GPIO_CHARGER_SHUTDOWN, 1);
+	} else {
+		iphone_gpio_pin_output(PMU_GPIO_CHARGER_SUSPEND, 0);
+		iphone_gpio_pin_output(PMU_GPIO_CHARGER_SHUTDOWN, 0);
+	}
+
+	if(type == PowerSupplyTypeUSBBrick500mA || type == PowerSupplyTypeUSBBrick1000mA || (type == PowerSupplyTypeUSBHost && UseUSB))
+		iphone_gpio_pin_output(PMU_GPIO_CHARGER_USB_500_1000, 1);
+	else
+		iphone_gpio_pin_output(PMU_GPIO_CHARGER_USB_500_1000, 0);
+
+	if(type == PowerSupplyTypeUSBBrick1000mA)
+		iphone_gpio_pin_output(PMU_GPIO_CHARGER_USB_1000, 1);
+	else
+		iphone_gpio_pin_output(PMU_GPIO_CHARGER_USB_1000, 0);
+}
+
+int iphone_pmu_get_battery_voltage(void)
+{
+	return query_adc(PMU_ADCC1_ADCINMUX_BATSNS_DIV << PMU_ADCC1_ADCINMUX_SHIFT);
+}
+
+int iphone_pmu_write_regs(const PMURegisterData* regs, int num) {
+	int i;
+	for(i = 0; i < num; i++) {
+		iphone_pmu_write_reg(regs[i].reg, regs[i].data, 1);
+	}
+
+	return 0;
+}
+
+static void iphone_pmu_write_oocshdwn(int data) {
+	uint8_t registers[1];
+	uint8_t discardData[5];
+	uint8_t poweroffData[] = {7, 0xAA, 0xFC, 0x0, 0x0, 0x0};
+	registers[0] = 2;
+
+	i2c_master_send(pmu_i2c, registers, sizeof(registers));
+	i2c_master_recv(pmu_i2c, discardData, sizeof(data));
+	i2c_master_send(pmu_i2c, poweroffData, sizeof(poweroffData));
+	//iphone_i2c_rx(PMU_I2C_BUS, PMU_GETADDR, registers, sizeof(registers), discardData, sizeof(data));
+	//iphone_i2c_tx(PMU_I2C_BUS, PMU_SETADDR, poweroffData, sizeof(poweroffData));
+	iphone_pmu_write_reg(PMU_OOCSHDWN, data, 0);
+	while(1) {
+		udelay(100000);
+	}
+}
+
+static void iphone_pmu_poweroff(void) {
+	//lcd_shutdown();
+	iphone_pmu_write_oocshdwn(PMU_OOCSHDWN_GOSTBY);
+}
+
+
+/*static int iphone_pmu_get_dayofweek(void) {
+	return iphone_pmu_get_reg(PMU_RTCWD) & PMU_RTCWD_MASK;
+}
+
+static int iphone_pmu_set_dayofweek(int num) {
+	return iphone_pmu_write_reg(PMU_RTCWD, num & PMU_RTCWD_MASK, 0);
+}*/
+
+static unsigned long iphone_pmu_get_epoch(void)
+{
+	unsigned long secs;
+	s32 offset;
+	u8 rtc_data[PMU_RTCYR - PMU_RTCSC + 1];
+	u8 rtc_data2[PMU_RTCYR - PMU_RTCSC + 1];
+
+	do
+	{
+		iphone_pmu_get_regs(PMU_RTCSC, rtc_data, PMU_RTCYR - PMU_RTCSC + 1);
+		iphone_pmu_get_regs(PMU_RTCSC, rtc_data2, PMU_RTCYR - PMU_RTCSC + 1);
+	} while(rtc_data2[0] != rtc_data[0]);
+
+	secs = mktime(
+			2000 + bcd2bin(rtc_data[PMU_RTCYR - PMU_RTCSC] & PMU_RTCYR_MASK),
+			rtc_data[PMU_RTCMT - PMU_RTCSC] & PMU_RTCMT_MASK,
+			bcd2bin(rtc_data[PMU_RTCDT - PMU_RTCSC] & PMU_RTCDT_MASK),
+			bcd2bin(rtc_data[PMU_RTCHR - PMU_RTCSC] & PMU_RTCHR_MASK),
+			bcd2bin(rtc_data[PMU_RTCMN - PMU_RTCSC] & PMU_RTCMN_MASK),
+			bcd2bin(rtc_data[0] & PMU_RTCSC_MASK)
+			);
+
+	iphone_pmu_get_regs(0x6B, (u8*) &offset, sizeof(offset));
+
+	secs += offset;
+	return secs;
+}
+
+
+static int iphone_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)
+{
+	rtc_time_to_tm(iphone_pmu_get_epoch(), rtc_tm);
+	return 0;
+}
+
+static int iphone_rtc_settime(struct device *dev, struct rtc_time *rtc_tm)
+{
+	unsigned long secs;
+	unsigned long cur;
+	s32 offset;
+	rtc_tm_to_time(rtc_tm, &secs);
+	cur = iphone_pmu_get_epoch();
+	offset = secs - cur;
+
+	iphone_pmu_write_reg(0x6B, offset & 0xFF, 0);
+	iphone_pmu_write_reg(0x6C, (offset >> 8) & 0xFF, 0);
+	iphone_pmu_write_reg(0x6D, (offset >> 16) & 0xFF, 0);
+	iphone_pmu_write_reg(0x6E, (offset >> 24) & 0xFF, 0);
+
+	return 0;
+}
+
+static const struct rtc_class_ops iphone_rtcops = {
+	.read_time	= iphone_rtc_gettime,
+	.set_time	= iphone_rtc_settime,
+};
+
+static int pmu_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	int ret = 0;
+	pmu_i2c = i2c;
+
+	rtc = rtc_device_register("iphone", &i2c->dev, &iphone_rtcops,
+			THIS_MODULE);
+
+	if (IS_ERR(rtc)) {
+		dev_err(&i2c->dev, "cannot attach rtc\n");
+		ret = PTR_ERR(rtc);
+		goto err_nortc;
+	}
+
+	return 0;
+
+err_nortc:
+
+	return ret;
+}
+
+static int __devexit pmu_i2c_remove(struct i2c_client *client)
+{
+	pmu_i2c = NULL;
+	rtc_device_unregister(rtc);
+	return 0;
+}
+
+static const struct i2c_device_id pmu_i2c_id[] = {
+	{ "iphone-pmu", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, pmu_i2c_id);
+
+static struct i2c_driver pmu_i2c_driver = {
+	.driver = {
+		.name = "iphone-pmu",
+		.owner = THIS_MODULE,
+	},
+	.probe = pmu_i2c_probe,
+	.remove = pmu_i2c_remove,
+	.id_table = pmu_i2c_id,
+};
+
+static int __init pmu_modinit(void)
+{
+	int ret;
+
+	ret = i2c_add_driver(&pmu_i2c_driver);
+	if (ret != 0)
+		pr_err("pmu: Unable to register I2C driver: %d\n", ret);
+	return ret;
+}
+module_init(pmu_modinit);
+
+static void __exit pmu_exit(void)
+{
+	i2c_del_driver(&pmu_i2c_driver);
+}
+module_exit(pmu_exit);
+
+
+MODULE_DESCRIPTION("iPhone pmu driver");
+MODULE_AUTHOR("Fredrik Gustafsson <frgsutaf@kth.se>");
+MODULE_LICENSE("GPL");
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/power.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/power.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/power.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/power.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,45 @@
+/*
+ *  arch/arm/mach-apple_iphone/power.c
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/iphone-clock.h>
+
+#define POWER IO_ADDRESS(0x39A00000)	/* probably a part of the system controller */
+
+#define POWER_ONCTRL 0xC
+#define POWER_OFFCTRL 0x10
+#define POWER_SETSTATE 0x8
+#define POWER_STATE 0x14
+
+int iphone_power_ctrl(u32 device, int on_off) {
+	if(on_off) {
+		__raw_writel(device, POWER + POWER_ONCTRL);
+	} else {
+		__raw_writel(device, POWER + POWER_OFFCTRL);
+	}
+
+	/* wait for the new state to take effect */
+	while((__raw_readl(POWER + POWER_SETSTATE) & device) != (__raw_readl(POWER + POWER_STATE) & device));
+
+	return 0;
+}
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/spi.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/spi.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/spi.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/spi.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,432 @@
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <mach/hardware.h>
+#include <linux/io.h>
+#include <linux/sched.h>
+
+#include <mach/iphone-clock.h>
+#include <mach/iphone-spi.h>
+
+#define GET_BITS(x, start, length) ((((u32)(x)) << (32 - ((start) + (length)))) >> (32 - (length)))
+
+// Device
+#define CHIPID IO_ADDRESS(0x3E500000)
+
+// Registers
+#define SPICLOCKTYPE 0x4
+
+// Values
+#define GET_SPICLOCKTYPE(x) GET_BITS(x, 24, 4)
+
+#define SPI0 IO_ADDRESS(0x3C300000)
+#define SPI1 IO_ADDRESS(0x3CE00000)
+#define SPI2 IO_ADDRESS(0x3D200000)
+
+// Registers
+
+#define CONTROL 0x0
+#define SETUP 0x4
+#define STATUS 0x8
+#define UNKREG1 0xC
+#define TXDATA 0x10
+#define RXDATA 0x20
+#define CLKDIVIDER 0x30
+#define UNKREG2 0x34
+#define UNKREG3 0x38
+
+// Values
+#define MAX_TX_BUFFER 8
+#define TX_BUFFER_LEFT(x) GET_BITS(status, 4, 4)
+#define RX_BUFFER_LEFT(x) GET_BITS(status, 8, 4)
+
+#define CLOCK_SHIFT 12
+#define MAX_DIVIDER 0x3FF
+
+#define SPI0_CLOCKGATE 0x22
+#define SPI1_CLOCKGATE 0x2B
+#define SPI2_CLOCKGATE 0x2F
+
+#define SPI0_IRQ 0x9
+#define SPI1_IRQ 0xA
+#define SPI2_IRQ 0xB
+
+#define NUM_SPIPORTS 3
+
+typedef struct SPIRegister {
+	u32 control;
+	u32 setup;
+	u32 status;
+	u32 unkReg1;
+	u32 txData;
+	u32 rxData;
+	u32 clkDivider;
+	u32 unkReg2;
+	u32 unkReg3;
+} SPIRegister;
+
+typedef enum SPIClockSource {
+	PCLK = 0,
+	NCLK = 1
+} SPIClockSource;
+
+typedef struct SPIInfo {
+	int option13;
+	bool isActiveLow;
+	bool lastClockEdgeMissing;
+	SPIClockSource clockSource;
+	int baud;
+	bool isMaster;
+	bool useDMA;
+	const volatile u8* txBuffer;
+	volatile int txCurrentLen;
+	volatile int txTotalLen;
+	volatile u8* rxBuffer;
+	volatile int rxCurrentLen;
+	volatile int rxTotalLen;
+	volatile int counter;
+	volatile bool txDone;
+	volatile bool rxDone;
+
+	struct completion complete;
+} SPIInfo;
+
+static const SPIRegister SPIRegs[NUM_SPIPORTS] = {
+	{SPI0 + CONTROL, SPI0 + SETUP, SPI0 + STATUS, SPI0 + UNKREG1, SPI0 + TXDATA, SPI0 + RXDATA, SPI0 + CLKDIVIDER, SPI0 + UNKREG2, SPI0 + UNKREG3},
+	{SPI1 + CONTROL, SPI1 + SETUP, SPI1 + STATUS, SPI1 + UNKREG1, SPI1 + TXDATA, SPI1 + RXDATA, SPI1 + CLKDIVIDER, SPI1 + UNKREG2, SPI1 + UNKREG3},
+	{SPI2 + CONTROL, SPI2 + SETUP, SPI2 + STATUS, SPI2 + UNKREG1, SPI2 + TXDATA, SPI2 + RXDATA, SPI2 + CLKDIVIDER, SPI2 + UNKREG2, SPI2 + UNKREG3}
+};
+
+static SPIInfo spi_info[NUM_SPIPORTS];
+
+static irqreturn_t spiIRQHandler(int irq, void* pPort);
+
+int __init iphone_spi_setup(void)
+{
+	int i;
+	int ret;
+
+	iphone_clock_gate_switch(SPI0_CLOCKGATE, 1);
+	iphone_clock_gate_switch(SPI1_CLOCKGATE, 1);
+	iphone_clock_gate_switch(SPI2_CLOCKGATE, 1);
+
+	memset(spi_info, 0, sizeof(SPIInfo) * NUM_SPIPORTS);
+
+	for(i = 0; i < NUM_SPIPORTS; i++)
+	{
+		spi_info[i].clockSource = NCLK;
+		init_completion(&spi_info[i].complete);
+		writel(0, SPIRegs[i].control);
+	}
+
+        ret = request_irq(SPI0_IRQ, spiIRQHandler, IRQF_DISABLED, "iphone_spi", (void*) 0);
+	if(ret)
+		return ret;
+
+        ret = request_irq(SPI1_IRQ, spiIRQHandler, IRQF_DISABLED, "iphone_spi", (void*) 1);
+	if(ret)
+		return ret;
+
+        ret = request_irq(SPI2_IRQ, spiIRQHandler, IRQF_DISABLED, "iphone_spi", (void*) 2);
+	if(ret)
+		return ret;
+
+	return 0;
+}
+module_init(iphone_spi_setup);
+
+static int chipid_spi_clocktype(void)
+{
+	return GET_SPICLOCKTYPE(readl(CHIPID + SPICLOCKTYPE));
+}
+
+void iphone_spi_set_baud(int port, int baud, SPIOption13 option13, bool isMaster, bool isActiveLow, bool lastClockEdgeMissing)
+{
+	u32 clockFrequency;
+	u32 divider;
+	u32 options;
+
+	if(port > (NUM_SPIPORTS - 1))
+		return;
+
+	writel(0, SPIRegs[port].control);
+
+	switch(option13)
+	{
+		case SPIOption13Setting0:
+			spi_info[port].option13 = 0;
+			break;
+
+		case SPIOption13Setting1:
+			spi_info[port].option13 = 1;
+			break;
+
+		case SPIOption13Setting2:
+			spi_info[port].option13 = 2;
+			break;
+	}
+
+	spi_info[port].isActiveLow = isActiveLow;
+	spi_info[port].lastClockEdgeMissing = lastClockEdgeMissing;
+
+	if(spi_info[port].clockSource == PCLK)
+	{
+		clockFrequency = FREQUENCY_PERIPHERAL;
+	} else
+	{
+		clockFrequency = FREQUENCY_FIXED;
+	}
+
+	if(chipid_spi_clocktype() != 0)
+	{
+		divider = clockFrequency / baud;
+		if(divider < 2)
+			divider = 2;
+	} else
+	{
+		divider = clockFrequency / (baud * 2 - 1);
+	}
+
+	if(divider > MAX_DIVIDER)
+	{
+		return;
+	}
+
+	writel(divider, SPIRegs[port].clkDivider);
+	spi_info[port].baud = baud;
+	spi_info[port].isMaster = isMaster;
+
+	options = (lastClockEdgeMissing << 1)
+			| (isActiveLow << 2)
+			| ((isMaster ? 0x3 : 0) << 3)
+			| ((spi_info[port].useDMA ? 0x2 : 0x3D) << 5)
+			| (spi_info[port].clockSource << CLOCK_SHIFT)
+			| spi_info[port].option13 << 13;
+
+	writel(options, SPIRegs[port].setup);
+	writel(0, SPIRegs[port].unkReg1);
+	writel(1, SPIRegs[port].control);
+
+}
+
+void wait_for_ready(int port)
+{
+	while(GET_BITS(readl(SPIRegs[port].status), 4, 4) != 0)
+	{
+		yield();
+	}
+}
+
+int iphone_spi_tx(int port, const u8* buffer, int len, bool block, bool unknown)
+{
+	int i;
+
+	if(port > (NUM_SPIPORTS - 1))
+		return -1;
+
+	writel(readl(SPIRegs[port].control) | (1 << 2), SPIRegs[port].control);
+	writel(readl(SPIRegs[port].control) | (1 << 3), SPIRegs[port].control);
+
+	spi_info[port].txBuffer = buffer;
+
+	if(len > MAX_TX_BUFFER)
+		spi_info[port].txCurrentLen = MAX_TX_BUFFER;
+	else
+		spi_info[port].txCurrentLen = len;
+
+	spi_info[port].txTotalLen = len;
+	spi_info[port].txDone = false;
+
+	if(!unknown)
+	{
+		writel(0, SPIRegs[port].unkReg2);
+	}
+
+	for(i = 0; i < spi_info[port].txCurrentLen; i++)
+	{
+		writel(buffer[i], SPIRegs[port].txData);
+	}
+
+	INIT_COMPLETION(spi_info[port].complete);
+
+	writel(1, SPIRegs[port].control);
+
+	if(block)
+	{
+		wait_for_completion(&spi_info[port].complete);
+		wait_for_ready(port);
+		return len;
+	} else
+	{
+		return 0;
+	}
+}
+
+int iphone_spi_rx(int port, u8* buffer, int len, bool block, bool noTransmitJunk)
+{
+	if(port > (NUM_SPIPORTS - 1))
+		return -1;
+
+	writel(readl(SPIRegs[port].control) | (1 << 2), SPIRegs[port].control);
+	writel(readl(SPIRegs[port].control) | (1 << 3), SPIRegs[port].control);
+
+	spi_info[port].rxBuffer = buffer;
+	spi_info[port].rxDone = false;
+	spi_info[port].rxCurrentLen = 0;
+	spi_info[port].rxTotalLen = len;
+	spi_info[port].counter = 0;
+
+	if(!noTransmitJunk) {
+		writel(readl(SPIRegs[port].setup) | 1, SPIRegs[port].setup);
+	}
+
+	writel(len, SPIRegs[port].unkReg2);
+
+	INIT_COMPLETION(spi_info[port].complete);
+
+	writel(1, SPIRegs[port].control);
+
+	if(block)
+	{
+		wait_for_completion(&spi_info[port].complete);
+
+		if(!noTransmitJunk)
+			writel(readl(SPIRegs[port].setup) & ~1, SPIRegs[port].setup);
+
+		return len;
+	} else {
+		return 0;
+	}
+}
+
+int iphone_spi_txrx(int port, const u8* outBuffer, int outLen, u8* inBuffer, int inLen, bool block)
+{
+	int i;
+
+	if(port > (NUM_SPIPORTS - 1))
+		return -1;
+
+	writel(readl(SPIRegs[port].control) | (1 << 2), SPIRegs[port].control);
+	writel(readl(SPIRegs[port].control) | (1 << 3), SPIRegs[port].control);
+
+	spi_info[port].txBuffer = outBuffer;
+
+	if(outLen > MAX_TX_BUFFER)
+		spi_info[port].txCurrentLen = MAX_TX_BUFFER;
+	else
+		spi_info[port].txCurrentLen = outLen;
+
+	spi_info[port].txTotalLen = outLen;
+	spi_info[port].txDone = false;
+
+	spi_info[port].rxBuffer = inBuffer;
+	spi_info[port].rxDone = false;
+	spi_info[port].rxCurrentLen = 0;
+	spi_info[port].rxTotalLen = inLen;
+	spi_info[port].counter = 0;
+
+	for(i = 0; i < spi_info[port].txCurrentLen; i++)
+		writel(outBuffer[i], SPIRegs[port].txData);
+
+	writel(inLen, SPIRegs[port].unkReg2);
+
+	INIT_COMPLETION(spi_info[port].complete);
+
+	writel(1, SPIRegs[port].control);
+
+	if(block)
+	{
+		wait_for_completion(&spi_info[port].complete);
+		wait_for_ready(port);
+		return inLen;
+	} else
+	{
+		return 0;
+	}
+}
+
+static irqreturn_t spiIRQHandler(int irq, void* pPort)
+{
+	int i;
+	u32 status;
+	int port = (int)pPort;
+
+	if(port > (NUM_SPIPORTS - 1))
+		return IRQ_HANDLED;
+
+	status = readl(SPIRegs[port].status);
+	if(status & (1 << 3))
+		spi_info[port].counter++;
+
+	if(status & (1 << 1))
+	{
+		while(true)
+		{
+			// take care of tx
+			if(spi_info[port].txBuffer != NULL)
+			{
+				if(spi_info[port].txCurrentLen < spi_info[port].txTotalLen)
+				{
+					int toTX = spi_info[port].txTotalLen - spi_info[port].txCurrentLen;
+					int canTX = MAX_TX_BUFFER - TX_BUFFER_LEFT(status);
+
+					if(toTX > canTX)
+						toTX = canTX;
+
+					for(i = 0; i < toTX; i++)
+					{
+						writel(spi_info[port].txBuffer[spi_info[port].txCurrentLen + i], SPIRegs[port].txData);
+					}
+
+					spi_info[port].txCurrentLen += toTX;
+
+				} else
+				{
+					spi_info[port].txDone = true;
+					spi_info[port].txBuffer = NULL;
+				}
+			}
+
+dorx:
+			// take care of rx
+			if(spi_info[port].rxBuffer == NULL)
+				break;
+
+			{
+				int toRX = spi_info[port].rxTotalLen - spi_info[port].rxCurrentLen;
+				int canRX = GET_BITS(status, 8, 4);
+
+				if(toRX > canRX)
+					toRX = canRX;
+
+				for(i = 0; i < toRX; i++)
+				{
+					spi_info[port].rxBuffer[spi_info[port].rxCurrentLen + i] = readl(SPIRegs[port].rxData);
+				}
+
+				spi_info[port].rxCurrentLen += toRX;
+
+				if(spi_info[port].rxCurrentLen < spi_info[port].rxTotalLen)
+					break;
+
+				spi_info[port].rxDone = true;
+				spi_info[port].rxBuffer = NULL;
+			}
+
+		}
+
+
+	} else  if(status & (1 << 0))
+	{
+		// jump into middle of the loop to handle rx only, stupidly
+		goto dorx;
+	}
+
+	// acknowledge interrupt handling complete
+	writel(status, SPIRegs[port].status);
+
+	if((!spi_info[port].rxBuffer || spi_info[port].rxDone) && (!spi_info[port].txBuffer || spi_info[port].txDone))
+		complete(&spi_info[port].complete);
+
+	return IRQ_HANDLED;
+}
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/suspend.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/suspend.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/suspend.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/suspend.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,49 @@
+#include <mach/pmu.h>
+#include <linux/suspend.h>
+#include <linux/earlysuspend.h>
+
+static suspend_state_t iphone_suspend_state = PM_SUSPEND_ON;
+
+static int iphone_suspend_valid(suspend_state_t _state)
+{
+	return suspend_valid_only_mem(_state);
+}
+
+static int iphone_suspend_begin(suspend_state_t _state)
+{
+	iphone_suspend_state = _state;
+	return 0;
+}
+
+static void iphone_suspend_end(void)
+{
+	iphone_suspend_state = PM_SUSPEND_ON;
+}
+
+static int iphone_suspend_prepare(void)
+{
+	return 0;
+}
+
+static int iphone_suspend_enter(suspend_state_t _state)
+{
+	return 0;
+}
+
+static void iphone_suspend_finish(void)
+{
+}
+
+static struct platform_suspend_ops iphone_suspend_ops = {
+	.valid = &iphone_suspend_valid,
+	.begin = &iphone_suspend_begin,
+	.end = &iphone_suspend_end,
+	.prepare = &iphone_suspend_prepare,
+	.enter = &iphone_suspend_enter,
+	.finish = &iphone_suspend_finish,
+};
+
+void iphone_init_suspend(void)
+{
+	suspend_set_ops(&iphone_suspend_ops);
+}
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/timer.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/timer.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/timer.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/timer.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,431 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/clockchips.h>
+
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+
+#include <asm/irq.h>
+#include <asm/mach/time.h>
+#include <mach/hardware.h>
+#include <mach/iphone-clock.h>
+
+// Constants
+#define EventTimer 4
+#define TicksPerSec 12000000
+#ifdef CONFIG_IPHONE_3G
+#define VibratorTimer 5
+#endif
+
+// Devices
+
+#define TIMER IO_ADDRESS(0x3E200000)
+
+// Registers
+
+#define TIMER_0 0x0
+#define TIMER_1 0x20
+#define TIMER_2 0x40
+#define TIMER_3 0x60
+#define TIMER_4 0xA0
+#define TIMER_5 0xC0
+#define TIMER_6 0xE0
+#define TIMER_CONFIG 0
+#define TIMER_STATE 0x4
+#define TIMER_COUNT_BUFFER 0x8
+#define TIMER_COUNT_BUFFER2 0xC
+#define TIMER_PRESCALER 0x10
+#define TIMER_UNKNOWN3 0x14
+#define TIMER_TICKSHIGH 0x80
+#define TIMER_TICKSLOW 0x84
+#define TIMER_UNKREG0 0x88
+#define TIMER_UNKREG1 0x8C
+#define TIMER_UNKREG2 0x90
+#define TIMER_UNKREG3 0x94
+#define TIMER_UNKREG4 0x98
+#define TIMER_IRQSTAT 0x10000
+#define TIMER_IRQLATCH 0xF8
+
+// Timer
+#define NUM_TIMERS 7
+#define TIMER_CLOCKGATE 0x25
+#define TIMER_IRQ 0x7
+#define TIMER_STATE_START 1
+#define TIMER_STATE_STOP 0
+#define TIMER_STATE_MANUALUPDATE 2
+#define TIMER_UNKREG0_RESET1 0xA
+#define TIMER_UNKREG0_RESET2 0x18010
+#define TIMER_UNKREG1_RESET 0xFFFFFFFF
+#define TIMER_UNKREG2_RESET 0xFFFFFFFF
+#define TIMER_UNKREG3_RESET 0xFFFFFFFF
+#define TIMER_UNKREG4_RESET 0xFFFFFFFF
+#define TIMER_DIVIDER1 4
+#define TIMER_DIVIDER2 0
+#define TIMER_DIVIDER4 1
+#define TIMER_DIVIDER16 2
+#define TIMER_DIVIDER64 3
+#define TIMER_SPECIALTIMER_BIT0 0x1000000
+#define TIMER_SPECIALTIMER_BIT1 0x2000000
+
+#define TIMER_Separator 4
+
+typedef void (*TimerHandler)(void);
+
+typedef struct TimerRegisters {
+	u32	config;
+	u32	state;
+	u32	count_buffer;
+	u32	count_buffer2;
+	u32	prescaler;
+	u32	cur_count;
+} TimerRegisters;
+
+typedef struct TimerInfo {
+	int	option6;
+	u32	divider;
+	u32	unknown1;
+	TimerHandler	handler1;
+	TimerHandler	handler2;
+	TimerHandler	handler3;
+} TimerInfo;
+
+const TimerRegisters HWTimers[] = {
+		{	TIMER + TIMER_0 + TIMER_CONFIG, TIMER + TIMER_0 + TIMER_STATE, TIMER + TIMER_0 + TIMER_COUNT_BUFFER,
+			TIMER + TIMER_0 + TIMER_COUNT_BUFFER2, TIMER + TIMER_0 + TIMER_PRESCALER, TIMER + TIMER_0 + TIMER_UNKNOWN3 },
+		{	TIMER + TIMER_1 + TIMER_CONFIG, TIMER + TIMER_1 + TIMER_STATE, TIMER + TIMER_1 + TIMER_COUNT_BUFFER,
+			TIMER + TIMER_1 + TIMER_COUNT_BUFFER2, TIMER + TIMER_1 + TIMER_PRESCALER, TIMER + TIMER_1 + TIMER_UNKNOWN3 },
+		{	TIMER + TIMER_2 + TIMER_CONFIG, TIMER + TIMER_2 + TIMER_STATE, TIMER + TIMER_2 + TIMER_COUNT_BUFFER,
+			TIMER + TIMER_2 + TIMER_COUNT_BUFFER2, TIMER + TIMER_2 + TIMER_PRESCALER, TIMER + TIMER_2 + TIMER_UNKNOWN3 },
+		{	TIMER + TIMER_3 + TIMER_CONFIG, TIMER + TIMER_3 + TIMER_STATE, TIMER + TIMER_3 + TIMER_COUNT_BUFFER,
+			TIMER + TIMER_3 + TIMER_COUNT_BUFFER2, TIMER + TIMER_3 + TIMER_PRESCALER, TIMER + TIMER_3 + TIMER_UNKNOWN3 },
+		{	TIMER + TIMER_4 + TIMER_CONFIG, TIMER + TIMER_4 + TIMER_STATE, TIMER + TIMER_4 + TIMER_COUNT_BUFFER,
+			TIMER + TIMER_4 + TIMER_COUNT_BUFFER2, TIMER + TIMER_4 + TIMER_PRESCALER, TIMER + TIMER_4 + TIMER_UNKNOWN3 },
+		{	TIMER + TIMER_5 + TIMER_CONFIG, TIMER + TIMER_5 + TIMER_STATE, TIMER + TIMER_5 + TIMER_COUNT_BUFFER,
+			TIMER + TIMER_5 + TIMER_COUNT_BUFFER2, TIMER + TIMER_5 + TIMER_PRESCALER, TIMER + TIMER_5 + TIMER_UNKNOWN3 },
+		{	TIMER + TIMER_6 + TIMER_CONFIG, TIMER + TIMER_6 + TIMER_STATE, TIMER + TIMER_6 + TIMER_COUNT_BUFFER,
+			TIMER + TIMER_6 + TIMER_COUNT_BUFFER2, TIMER + TIMER_6 + TIMER_PRESCALER, TIMER + TIMER_6 + TIMER_UNKNOWN3 }
+	};
+
+TimerInfo Timers[7];
+
+static void timer_init_rtc(void)
+{
+	__raw_writel(TIMER_UNKREG0_RESET1, TIMER + TIMER_UNKREG0);
+	__raw_writel(TIMER_UNKREG2_RESET, TIMER + TIMER_UNKREG2);
+	__raw_writel(TIMER_UNKREG1_RESET, TIMER + TIMER_UNKREG1);
+	__raw_writel(TIMER_UNKREG4_RESET, TIMER + TIMER_UNKREG4);
+	__raw_writel(TIMER_UNKREG3_RESET, TIMER + TIMER_UNKREG3);
+	__raw_writel(TIMER_UNKREG0_RESET2, TIMER + TIMER_UNKREG0);
+}
+
+int timer_on_off(int timer_id, int on_off) {
+	if(timer_id < NUM_TIMERS) {
+		if(on_off == 1) {
+			__raw_writel(TIMER_STATE_START, HWTimers[timer_id].state);
+		} else {
+			__raw_writel(TIMER_STATE_STOP, HWTimers[timer_id].state);
+		}
+
+		return 0;
+	} else if(timer_id == NUM_TIMERS) {
+		if(on_off == 1) {
+			// clear bits 0, 1, 2, 3
+			__raw_writel(__raw_readl(TIMER + TIMER_UNKREG0) & ~(0xF), TIMER + TIMER_UNKREG0);
+		} else {
+			// set bits 1, 3
+			__raw_writel(__raw_readl(TIMER + TIMER_UNKREG0) | 0xA, TIMER + TIMER_UNKREG0);
+		}
+		return 0;
+	} else {
+		/* invalid timer id */
+		return -1;
+	}
+}
+
+static int timer_stop_all(void)
+{
+	int i;
+	for(i = 0; i < NUM_TIMERS; i++) {
+		timer_on_off(i, 0);
+	}
+	timer_on_off(NUM_TIMERS, 0);
+
+	return 0;
+}
+
+static int timer_setup_clk(int timer_id, int type, int divider, u32 unknown1) {
+	if(type == 2) {
+		Timers[timer_id].option6 = 0;
+		Timers[timer_id].divider = 6;
+	} else {
+		if(type == 1) {
+			Timers[timer_id].option6 = 1;
+		} else {
+			Timers[timer_id].option6 = 0;
+		}
+
+		/* translate divider into divider code */
+		switch(divider) {
+			case 1:
+				Timers[timer_id].divider = TIMER_DIVIDER1;
+				break;
+			case 2:
+				Timers[timer_id].divider = TIMER_DIVIDER2;
+				break;
+			case 4:
+				Timers[timer_id].divider = TIMER_DIVIDER4;
+				break;
+			case 16:
+				Timers[timer_id].divider = TIMER_DIVIDER16;
+				break;
+			case 64:
+				Timers[timer_id].divider = TIMER_DIVIDER64;
+				break;
+			default:
+				/* invalid divider */
+				return -1;
+		}
+	}
+
+	Timers[timer_id].unknown1 = unknown1;
+
+	return 0;
+}
+
+int timer_init(int timer_id, u32 interval, u32 interval2, u32 prescaler, u32 z, int option24, int option28, int option11, int option5, int interrupts) {
+	u32 config;
+
+	if(timer_id >= NUM_TIMERS || timer_id < 0) {
+		return -1;
+	}
+
+	/* need to turn it off, since we're messing with the settings */
+	timer_on_off(timer_id, 0);
+
+	if(interrupts)
+		config = 0x7000; /* set bits 12, 13, 14 */
+	else
+		config = 0;
+
+	/* these two options are only supported on timers 4, 5, 6 */
+	if(timer_id >= TIMER_Separator) {
+		config |= (option24 ? (1 << 24) : 0) | (option28 ? 1 << 28: 0);
+	}
+
+	/* set the rest of the options */
+	config |= (Timers[timer_id].divider << 8)
+			| (z << 3)
+			| (option5 ? (1 << 5) : 0)
+			| (Timers[timer_id].option6 ? (1 << 6) : 0)
+			| (option11 ? (1 << 11) : 0);
+
+	__raw_writel(config, HWTimers[timer_id].config);
+	__raw_writel(interval, HWTimers[timer_id].count_buffer);
+	__raw_writel(interval2, HWTimers[timer_id].count_buffer2);
+	__raw_writel(prescaler, HWTimers[timer_id].prescaler);
+
+	// apply the settings
+	__raw_writel(TIMER_STATE_MANUALUPDATE, HWTimers[timer_id].state);
+
+	return 0;
+}
+
+static void iphone_timer_get_rtc_ticks(u64* ticks) {
+	register u32 ticksHigh;
+	register u32 ticksLow;
+	register u32 ticksHigh2;
+
+	/* try to get a good read where the lower bits remain the same after reading the higher bits */
+	do {
+		ticksHigh = __raw_readl(TIMER + TIMER_TICKSHIGH);
+		ticksLow = __raw_readl(TIMER + TIMER_TICKSLOW);
+		ticksHigh2 = __raw_readl(TIMER + TIMER_TICKSHIGH);
+	} while(ticksHigh != ticksHigh2);
+
+	*ticks = (((u64)ticksHigh) << 32) | ticksLow;
+}
+
+u64 iphone_microtime(void) {
+        u64 ticks;
+
+        iphone_timer_get_rtc_ticks(&ticks);
+	// FIXME: Unreliable for large tick values
+        return ((u32)(ticks >> 2))/3;
+}
+
+int iphone_has_elapsed(u64 startTime, u64 elapsedTime) {
+	if((iphone_microtime() - startTime) >= elapsedTime)
+		return 1;
+	else
+		return 0;
+}
+
+static void callTimerHandler(int timer_id, uint32_t flags) {
+	if((flags & (1 << 2)) != 0) {
+		if(Timers[timer_id].handler1)
+			Timers[timer_id].handler1();
+	}
+
+	if((flags & (1 << 1)) != 0) {
+		if(Timers[timer_id].handler3)
+			Timers[timer_id].handler3();
+	}
+
+	if((flags & (1 << 0)) != 0) {
+		if(Timers[timer_id].handler2)
+			Timers[timer_id].handler2();
+	}
+}
+
+static irqreturn_t iphone_timer_interrupt(int irq, void* dev_id) {
+	int i;
+	/* this function does not implement incrementing a counter at dword_18022B28 like Apple's */
+	uint32_t stat = __raw_readl(TIMER + TIMER_IRQSTAT);
+
+	/* signal timer is being handled */
+	volatile register uint32_t discard = __raw_readl(TIMER + TIMER_IRQLATCH); discard --;
+
+	if(stat & TIMER_SPECIALTIMER_BIT0) {
+		__raw_writel(__raw_readl(TIMER + TIMER_UNKREG0) | TIMER_SPECIALTIMER_BIT0, TIMER + TIMER_UNKREG0);
+	}
+
+	if(stat & TIMER_SPECIALTIMER_BIT1) {
+		__raw_writel(__raw_readl(TIMER + TIMER_UNKREG0) | TIMER_SPECIALTIMER_BIT1, TIMER + TIMER_UNKREG0);
+	}
+
+	for(i = TIMER_Separator; i < NUM_TIMERS; i++) {
+		callTimerHandler(i, stat >> (8 * (NUM_TIMERS - i - 1)));
+	}
+
+	/* signal timer has been handled */
+	__raw_writel(stat, TIMER + TIMER_IRQLATCH);
+
+	return IRQ_HANDLED;
+}
+
+static void timer_fired(void);
+
+static void iphone_timer_setup(void)
+{
+	/* stop/cleanup any existing timers */
+	timer_stop_all();
+
+	/* do some voodoo */
+	timer_init_rtc();
+
+	Timers[EventTimer].handler2 = timer_fired;
+}
+
+static void iphone_timer_set_mode(enum clock_event_mode mode,
+			      struct clock_event_device *evt)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_RESUME:
+	case CLOCK_EVT_MODE_PERIODIC:
+		timer_on_off(EventTimer, 1);
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		timer_on_off(EventTimer, 0);
+		break;
+	}
+}
+
+static int iphone_timer_set_next_event(unsigned long cycles,
+				    struct clock_event_device *evt)
+{
+	timer_init(EventTimer, cycles, 0, 0, 0, 0, 0, 0, 0, 1);
+	return 0;
+}
+
+static cycle_t iphone_timer_read(struct clocksource *cs)
+{
+	u64 ticks;
+	iphone_timer_get_rtc_ticks(&ticks);
+	return ticks;
+}
+
+struct clock_event_device clockevent =
+{
+	.name = "iphone_timer",
+	.features = CLOCK_EVT_FEAT_PERIODIC,
+	.rating = 200,
+	.set_next_event = iphone_timer_set_next_event,
+	.set_mode = iphone_timer_set_mode,
+};
+
+struct clocksource clocksource =
+{
+	.name = "iphone_timer",
+	.rating = 200,
+	.read = iphone_timer_read,
+	.mask = CLOCKSOURCE_MASK(64),
+	.shift = 24,
+	.flags = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static struct irqaction iphone_timer_irq = {
+	.name		= "iPhone Timer Tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= iphone_timer_interrupt,
+};
+
+static void timer_fired(void)
+{
+	struct clock_event_device *evt = &clockevent;
+	evt->event_handler(evt);
+}
+
+static void __init iphone_timer_init(void)
+{
+	int i;
+	int res;
+
+	printk("iphone-timer: initializing\n");
+
+	for(i = 0; i < NUM_TIMERS; i++) {
+		timer_setup_clk(i, 1, 2, 0);
+	}
+
+	iphone_timer_setup();
+
+	clockevents_calc_mult_shift(&clockevent, FREQUENCY_BASE, 4);
+	clockevent.max_delta_ns = clockevent_delta2ns(0xF0000000, &clockevent);
+	clockevent.min_delta_ns = clockevent_delta2ns(4, &clockevent);
+	clockevent.cpumask = cpumask_of(0);
+
+	clocksource.mult = clocksource_hz2mult(FREQUENCY_BASE, clocksource.shift);
+
+	res = clocksource_register(&clocksource);
+	if(res)
+	{
+		printk("iphone-timer: failed to register clock source\n");
+		return;
+	}
+
+	res = setup_irq(TIMER_IRQ, &iphone_timer_irq);
+	if(res)
+	{
+		printk("iphone-timer: failed to setup irq\n");
+		return;
+	}
+
+	clockevents_register_device(&clockevent);
+
+	printk("iphone-timer: finished initialization: (cycles * %u) >> %u = ns and (cycles << %u) / %u = ns\n", clocksource.mult, clocksource.shift,
+			clockevent.shift, clockevent.mult);
+}
+
+struct sys_timer iphone_timer = {
+	.init		= iphone_timer_init,
+};
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/usb.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/usb.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/usb.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/usb.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,205 @@
+/*
+ *  arch/arm/mach-apple_iphone/usb.c
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+#include <linux/usb/android_composite.h>
+
+#include <mach/map.h>
+
+#include "core.h"
+
+static struct resource s3c_usb_hsotg_resources[] = {
+	[0] = {
+		.start	= S3C_PA_USB_HSOTG,
+		.end	= S3C_PA_USB_HSOTG + SZ_256K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+
+	[1] = {
+		.start	= S3C_PA_USB_HSPHY,
+		.end	= S3C_PA_USB_HSPHY + SZ_256K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+
+	[2] = {
+		.start	= 0x13,
+		.end	= 0x13,
+		.flags	= IORESOURCE_IRQ,
+        },
+};
+
+struct platform_device s3c_device_usb_hsotg = {
+#ifdef CONFIG_USB_GADGET_S3C_HSOTG
+	.name		= "s3c-hsotg",
+#else
+	.name		= "dwc_otg",
+#endif
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(s3c_usb_hsotg_resources),
+	.resource	= s3c_usb_hsotg_resources,
+
+	.dev = {
+		.dma_mask			= DMA_BIT_MASK(32),
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	}
+};
+
+#ifdef CONFIG_USB_ANDROID
+char *android_usb_functions[] = {
+#ifdef CONFIG_USB_ANDROID_ADB
+	"adb",
+#endif
+#ifdef CONFIG_USB_ANDROID_ACM
+	"acm",
+#endif
+#ifdef CONFIG_USB_ANDROID_MASS_STORAGE
+	"usb_mass_storage",
+#endif
+#ifdef CONFIG_USB_ANDROID_RNDIS
+	"rndis",
+#endif
+};
+
+static struct android_usb_product android_products[] = {
+	{
+		.product_id	= 0x1234,
+		.num_functions	= ARRAY_SIZE(android_usb_functions),
+		.functions	= android_usb_functions,
+	},
+};
+
+struct android_usb_platform_data android_usb_config = {
+#ifdef CONFIG_IPHONE_3G
+	.product_name		= "iPhone3G",
+#endif
+#ifdef CONFIG_IPHONE_2G
+	.product_name		= "iPhone2G",
+#endif
+#ifdef CONFIG_IPODTOUCH_1G
+	.product_name		= "iPodTouch1G",
+#endif
+
+	//.vendor_id			= TODO,
+	//.product_id			= 0x1234,
+	.manufacturer_name	= "Apple",
+	.serial_number		= "0123456789", // TODO: Do we need to bother with this?
+
+	.version			= 0x0100,
+
+	.products			= android_products,
+	.num_products		= ARRAY_SIZE(android_products),
+
+	.functions			= android_usb_functions,
+	.num_functions		= ARRAY_SIZE(android_usb_functions),
+};
+
+struct platform_device android_usb = {
+	.name			= "android_usb",
+	.dev			= {
+		.platform_data = &android_usb_config,
+	}
+};
+
+struct usb_mass_storage_platform_data android_usb_storage_config = {
+	.vendor		= "Apple",
+
+#ifdef CONFIG_IPHONE_3G
+	.product	= "iPhone3G",
+#endif
+
+#ifdef CONFIG_IPHONE_2G
+	.product	= "iPhone2G",
+#endif
+#ifdef CONFIG_IPODTOUCH_1G
+	.product	= "iPodTouch1G",
+#endif
+
+	.release	= 1,
+
+	.nluns		= 1, // TODO: What the hell does this number mean?
+};
+
+struct platform_device android_usb_storage = {
+	.name	= "usb_mass_storage",
+	.dev	= {
+		.platform_data = &android_usb_storage_config,
+	}
+};
+
+struct usb_ether_platform_data android_usb_ether_config = {
+	.vendorDescr	= "Apple",
+	//.vendorID		= 0x1d8c, // TODO: What should we use as the vendor ID?
+};
+
+struct platform_device android_usb_ether = {
+	.name			= "rndis",
+	.dev			= {
+		.platform_data = &android_usb_ether_config,
+	}
+};
+#endif
+
+static int __init iphone_usb_init(void)
+{
+	int ret;
+	ret = platform_device_register(&s3c_device_usb_hsotg);
+	if (ret)
+		goto out;
+#ifdef CONFIG_USB_ANDROID
+	ret = platform_device_register(&android_usb_ether);
+	if (ret)
+		goto out_s3c;
+	ret = platform_device_register(&android_usb_storage);
+	if (ret)
+		goto out_android_ether;
+	ret = platform_device_register(&android_usb);
+	if (ret)
+		goto out_android_storage;
+#endif
+	return 0;
+
+#ifdef CONFIG_USB_ANDROID
+out_android_storage:
+	platform_device_unregister(&android_usb_storage);
+out_android_ether:
+	platform_device_unregister(&android_usb_ether);
+out_s3c:
+	platform_device_unregister(&s3c_device_usb_hsotg);
+#endif
+
+out:
+	printk(KERN_INFO "iphone-usb: Initialization failed.");
+	return ret;
+}
+
+static void __exit iphone_usb_exit(void)
+{
+#ifdef CONFIG_USB_ANDROID
+	platform_device_unregister(&android_usb);
+	platform_device_unregister(&android_usb_storage);
+	platform_device_unregister(&android_usb_ether);
+#endif
+	platform_device_unregister(&s3c_device_usb_hsotg);
+}
+
+module_init(iphone_usb_init);
+module_exit(iphone_usb_exit);
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/usb.h iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/usb.h
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/usb.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/usb.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,162 @@
+/*
+ *  arch/arm/mach-apple_iphone/usb.h
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef IPHONE_USB_H
+#define IPHONE_USB_H
+
+// values we're using
+#define USB_MAX_PACKETSIZE 64
+#define USB_SETUP_PACKETS_AT_A_TIME 1
+#define CONTROL_SEND_BUFFER_LEN 0x80
+#define CONTROL_RECV_BUFFER_LEN 0x80
+#define TX_QUEUE_LEN 0x80
+
+// one packet at a time
+#define USB_MULTICOUNT 1
+
+#define OPENIBOOT_INTERFACE_CLASS 0xFF
+#define OPENIBOOT_INTERFACE_SUBCLASS 0xFF
+#define OPENIBOOT_INTERFACE_PROTOCOL 0x51
+
+#define USB_LANGID_ENGLISH_US 0x0409
+
+#define USBError 0xEEE
+
+typedef enum USBState {
+	USBStart = 0,
+	USBPowered = 1,
+	USBDefault = 2,
+	USBAddress = 3,
+	USBConfigured = 4,
+
+	// Values higher than USBError(0xEEE) are error conditions
+	USBUnknownDescriptorRequest = 0xEEE,
+	USBUnknownRequest = 0xEEF
+} USBState;
+
+typedef enum USBDirection {
+	USBOut = 0,
+	USBIn = 1,
+	USBBiDir = 2
+} USBDirection;
+
+typedef enum USBTransferType {
+	USBControl = 0,
+	USBIsochronous = 1,
+	USBBulk = 2,
+	USBInterrupt = 3
+} USBTransferType;
+
+typedef enum USBSynchronisationType {
+	USBNoSynchronization = 0,
+	USBAsynchronous = 1,
+	USBAdaptive = 2,
+	USBSynchronous = 3
+} USBSynchronisationType;
+
+typedef enum USBUsageType {
+	USBDataEndpoint = 0,
+	USBFeedbackEndpoint = 1,
+	USBExplicitFeedbackEndpoint = 2
+} USBUsageType;
+
+enum USBDescriptorType {
+	USBDeviceDescriptorType = 1,
+	USBConfigurationDescriptorType = 2,
+	USBStringDescriptorType = 3,
+	USBInterfaceDescriptorType = 4,
+	USBEndpointDescriptorType = 5,
+	USBDeviceQualifierDescriptorType = 6
+};
+
+typedef void (*USBEndpointHandler)(u32 token);
+
+typedef struct USBEndpointHandlerInfo {
+	USBEndpointHandler	handler;
+	u32		token;
+} USBEndpointHandlerInfo;
+
+typedef struct USBEndpointBidirHandlerInfo {
+	USBEndpointHandlerInfo in;
+	USBEndpointHandlerInfo out;
+} USBEndpointBidirHandlerInfo;
+
+typedef struct USBEPRegisters {
+	volatile u32 control;
+	volatile u32 field_4;
+	volatile u32 interrupt;
+	volatile u32 field_8;
+	volatile u32 transferSize;
+	volatile void* dmaAddress;
+	volatile u32 field_18;
+	volatile u32 field_1C;
+} USBEPRegisters;
+
+typedef struct USBDeviceQualifierDescriptor {
+	u8 bLength;
+	u8 bDescriptorType;
+	u16 bcdUSB;
+	u8 bDeviceClass;
+	u8 bDeviceSubClass;
+	u8 bDeviceProtocol;
+	u8 bMaxPacketSize;
+	u8 bNumConfigurations;
+	u8 bReserved;
+} __attribute__ ((__packed__)) USBDeviceQualifierDescriptor;
+
+#define OPENIBOOTCMD_DUMPBUFFER 0
+#define OPENIBOOTCMD_DUMPBUFFER_LEN 1
+#define OPENIBOOTCMD_DUMPBUFFER_GOAHEAD 2
+#define OPENIBOOTCMD_SENDCOMMAND 3
+#define OPENIBOOTCMD_SENDCOMMAND_GOAHEAD 4
+
+typedef struct OpenIBootCmd {
+	u32 command;
+	u32 dataLen;
+}  __attribute__ ((__packed__)) OpenIBootCmd;
+
+#define USBSetupPacketRequestTypeDirection(x) GET_BITS(x, 7, 1)
+#define USBSetupPacketRequestTypeType(x) GET_BITS(x, 5, 2)
+#define USBSetupPacketRequestTypeRecpient(x) GET_BITS(x, 0, 5)
+
+#define USBSetupPacketHostToDevice 0
+#define USBSetupPacketDeviceToHost 1
+#define USBSetupPacketStandard 0
+#define USBSetupPacketClass 1
+#define USBSetupPacketVendor 2
+#define USBSetupPacketRecpientDevice 0
+#define USBSetupPacketRecpientInterface 1
+#define USBSetupPacketRecpientEndpoint 2
+#define USBSetupPacketRecpientOther 3
+
+#define USB_CLEAR_FEATURE 1
+#define USB_GET_CONFIGURATION 8
+#define USB_GET_DESCRIPTOR 6
+#define USB_GET_INTERFACE 10
+#define USB_GET_STATUS 0
+#define USB_SET_ADDRESS 5
+#define USB_SET_CONFIGURATION 9
+#define USB_SET_DESCRIPTOR 7
+#define USB_SET_FEATURE 3
+#define USB_SET_INTERFACE 11
+#define USB_SYNCH_FRAME 12
+
+#endif
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-apple_iphone/vfl.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/vfl.c
--- linux-2.6.32-orig/arch/arm/mach-apple_iphone/vfl.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-apple_iphone/vfl.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,798 @@
+#include <linux/io.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <ftl/nand.h>
+#include <ftl/vfl.h>
+
+#define LOG printk
+#define LOGDBG(format, ...)
+
+typedef struct VFLCxt {
+	u32 usnInc;				// 0x000
+	u16 FTLCtrlBlock[3];			// 0x004
+	u8 unk1[2];				// 0x00A
+	u32 usnDec;				// 0x00C
+	u16 activecxtblock;			// 0x010
+	u16 nextcxtpage;				// 0x012
+	u8 unk2[2];				// 0x014
+	u16 field_16;				// 0x016
+	u16 field_18;				// 0x018
+	u16 numReservedBlocks;			// 0x01A
+	u16 reservedBlockPoolStart;		// 0x01C
+	u16 totalReservedBlocks;			// 0x01E
+	u16 reservedBlockPoolMap[0x334];		// 0x020
+	u8 badBlockTable[0x11a];			// 0x688
+	u16 VFLCxtBlock[4];			// 0x7A2
+	u16 remappingScheduledStart;		// 0x7AA
+	u8 unk3[0x4C];				// 0x7AC
+	u32 checksum1;				// 0x7F8
+	u32 checksum2;				// 0x7FC
+} VFLCxt;
+
+#define FTL_ID_V1 0x43303033
+#define FTL_ID_V2 0x43303034
+#define FTL_ID_V3 0x43303035
+
+//#define IPHONE_DEBUG
+
+// Shared Counters
+
+extern VFLData1Type VFLData1;
+
+// Shared configuration
+
+NANDData* NANDGeometry;
+NANDFTLData* FTLData;
+
+// Global Buffers
+
+static u8* PageBuffer;
+static u8* SpareBuffer;
+
+static VFLCxt* pstVFLCxt = NULL;
+static u8* pstBBTArea = NULL;
+static u32* ScatteredPageNumberBuffer = NULL;
+static u16* ScatteredBankNumberBuffer = NULL;
+static int curVFLusnInc = 0;
+
+// Prototypes
+
+static bool findDeviceInfoBBT(int bank, void* deviceInfoBBT)
+{
+	int lowestBlock = NANDGeometry->blocksPerBank - (NANDGeometry->blocksPerBank / 10);
+	int block;
+
+	for(block = NANDGeometry->blocksPerBank - 1; block >= lowestBlock; block--) {
+		int page;
+		int badBlockCount = 0;
+		for(page = 0; page < NANDGeometry->pagesPerBlock; page++) {
+			int ret;
+
+			if(badBlockCount > 2) {
+				LOGDBG("ftl: findDeviceInfoBBT - too many bad pages, skipping block %d\n", block);
+				break;
+			}
+
+			ret = nand_read_alternate_ecc(bank, (block * NANDGeometry->pagesPerBlock) + page, PageBuffer);
+			if(ret != 0) {
+				if(ret == 1) {
+					LOGDBG("ftl: findDeviceInfoBBT - found 'badBlock' on bank %d, page %d\n", (block * NANDGeometry->pagesPerBlock) + page);
+					badBlockCount++;
+				}
+
+				LOGDBG("ftl: findDeviceInfoBBT - skipping bank %d, page %d\n", (block * NANDGeometry->pagesPerBlock) + page);
+				continue;
+			}
+
+			if(memcmp(PageBuffer, "DEVICEINFOBBT\0\0\0", 16) == 0) {
+				if(deviceInfoBBT) {
+					memcpy(deviceInfoBBT, PageBuffer + 0x38, *((u32*)(PageBuffer + 0x34)));
+				}
+
+				return true;
+			} else {
+				LOGDBG("ftl: did not find signature on bank %d, page %d\n", (block * NANDGeometry->pagesPerBlock) + page);
+			}
+		}
+	}
+
+	return false;
+}
+
+// pageBuffer and spareBuffer are represented by single BUF struct within Whimory
+static bool nand_read_vfl_cxt_page(int bank, int block, int page, u8* pageBuffer, u8* spareBuffer) {
+	int i;
+	for(i = 0; i < 8; i++) {
+		if(nand_read(bank, (block * NANDGeometry->pagesPerBlock) + page + i, pageBuffer, spareBuffer, true, true) == 0) {
+			SpareData* spareData = (SpareData*) spareBuffer;
+			if(spareData->type2 == 0 && spareData->type1 == 0x80)
+				return true;
+		}
+	}
+	return false;
+}
+
+static void vfl_checksum(void* data, int size, u32* a, u32* b) {
+	int i;
+	u32* buffer = (u32*) data;
+	u32 x = 0;
+	u32 y = 0;
+	for(i = 0; i < (size / 4); i++) {
+		x += buffer[i];
+		y ^= buffer[i];
+	}
+
+	*a = x + 0xAABBCCDD;
+	*b = y ^ 0xAABBCCDD;
+}
+
+static bool vfl_gen_checksum(int bank) {
+	vfl_checksum(&pstVFLCxt[bank], (u32)&pstVFLCxt[bank].checksum1 - (u32)&pstVFLCxt[bank], &pstVFLCxt[bank].checksum1, &pstVFLCxt[bank].checksum2);
+	return false;
+}
+
+static bool vfl_check_checksum(int bank) {
+	u32 checksum1;
+	u32 checksum2;
+	static int counter = 0;
+
+	counter++;
+
+	vfl_checksum(&pstVFLCxt[bank], (u32)&pstVFLCxt[bank].checksum1 - (u32)&pstVFLCxt[bank], &checksum1, &checksum2);
+
+	// Yeah, this looks fail, but this is actually the logic they use
+	if(checksum1 == pstVFLCxt[bank].checksum1)
+		return true;
+
+	if(checksum2 != pstVFLCxt[bank].checksum2)
+		return true;
+
+	return false;
+}
+
+
+static int vfl_store_cxt(int bank)
+{
+	int i;
+	int good;
+	SpareData* spareData = (SpareData*) SpareBuffer;
+
+	--pstVFLCxt[bank].usnDec;
+	pstVFLCxt[bank].usnInc = ++curVFLusnInc;
+	pstVFLCxt[bank].nextcxtpage += 8;
+	vfl_gen_checksum(bank);
+
+	memset(spareData, 0xFF, NANDGeometry->bytesPerSpare);
+	spareData->meta.usnDec = pstVFLCxt[bank].usnDec;
+	spareData->type2 = 0;
+	spareData->type1 = 0x80;
+
+	for(i = 0; i < 8; ++i)
+	{
+		u32 index = pstVFLCxt[bank].activecxtblock;
+		u32 block = pstVFLCxt[bank].VFLCxtBlock[index];
+		u32 page = block * NANDGeometry->pagesPerBlock;
+		page += pstVFLCxt[bank].nextcxtpage - 8 + i;
+		nand_write(bank, page, (u8*) &pstVFLCxt[bank], (u8*) spareData, true);
+	}
+
+	good = 0;
+	for(i = 0; i < 8; ++i)
+	{
+		u32 index = pstVFLCxt[bank].activecxtblock;
+		u32 block = pstVFLCxt[bank].VFLCxtBlock[index];
+		u32 page = block * NANDGeometry->pagesPerBlock;
+		page += pstVFLCxt[bank].nextcxtpage - 8 + i;
+		if(nand_read(bank, page, PageBuffer, (u8*) spareData, true, true) != 0)
+			continue;
+
+		if(memcmp(PageBuffer, &pstVFLCxt[bank], sizeof(VFLCxt)) != 0)
+			continue;
+
+		if(spareData->type2 == 0 && spareData->type1 == 0x80)
+			++good;
+
+	}
+
+	return (good > 3) ? 0 : -1;
+}
+
+static int vfl_commit_cxt(int bank)
+{
+	u32 cur;
+	u32 block;
+
+	if((pstVFLCxt[bank].nextcxtpage + 8) <= NANDGeometry->pagesPerBlock)
+		if(vfl_store_cxt(bank) == 0)
+			return 0;
+
+	cur = pstVFLCxt[bank].activecxtblock;
+	block = cur;
+
+	while(true)
+	{
+		int i;
+
+		block = (block + 1) % 4;
+		if(block == cur)
+			break;
+
+		// try to erase 4 times
+		for(i = 0; i < 4; ++i)
+		{
+			if(nand_erase(bank, pstVFLCxt[bank].VFLCxtBlock[block]) == 0)
+				break;
+		}
+
+		if(i == 4)
+			continue;
+
+		pstVFLCxt[bank].activecxtblock = block;
+		pstVFLCxt[bank].nextcxtpage = 0;
+		if(vfl_store_cxt(bank) == 0)
+			return 0;
+	}
+
+	LOG("ftl: failed to commit VFL context!\n");
+	return -1;
+}
+
+static void virtual_page_number_to_virtual_address(u32 dwVpn, u16* virtualBank, u16* virtualBlock, u16* virtualPage) {
+	*virtualBank = dwVpn % NANDGeometry->banksTotal;
+	*virtualBlock = dwVpn / NANDGeometry->pagesPerSuBlk;
+	*virtualPage = (dwVpn / NANDGeometry->banksTotal) % NANDGeometry->pagesPerBlock;
+}
+
+// badBlockTable is a bit array with 8 virtual blocks in one bit entry
+static bool isGoodBlock(u8* badBlockTable, u16 virtualBlock) {
+	int index = virtualBlock/8;
+	return ((badBlockTable[index / 8] >> (7 - (index % 8))) & 0x1) == 0x1;
+}
+
+static u16 virtual_block_to_physical_block(u16 virtualBank, u16 virtualBlock) {
+	int pwDesPbn;
+
+	if(isGoodBlock(pstVFLCxt[virtualBank].badBlockTable, virtualBlock))
+		return virtualBlock;
+
+	for(pwDesPbn = 0; pwDesPbn < pstVFLCxt[virtualBank].numReservedBlocks; pwDesPbn++) {
+		if(pstVFLCxt[virtualBank].reservedBlockPoolMap[pwDesPbn] == virtualBlock) {
+			if(pwDesPbn >= NANDGeometry->blocksPerBank) {
+				LOG("ftl: Destination physical block for remapping is greater than number of blocks per bank!");
+			}
+			return pstVFLCxt[virtualBank].reservedBlockPoolStart + pwDesPbn;
+		}
+	}
+
+	return virtualBlock;
+}
+
+static bool vfl_check_remap_scheduled(int bank, u16 block)
+{
+	int i;
+	for(i = 0x333; i > 0 && i > pstVFLCxt[bank].remappingScheduledStart; --i)
+	{
+		if(pstVFLCxt[bank].reservedBlockPoolMap[i] == block)
+			return true;
+	}
+
+	return false;
+}
+
+static bool vfl_schedule_block_for_remap(int bank, u16 block)
+{
+	if(vfl_check_remap_scheduled(bank, block))
+		return true;
+
+	LOG("ftl: attempting to schedule bank %d, block %d for remap!\n", bank, block);
+
+	// don't do anything for right now to avoid consequences for false positives
+	return false;
+
+	if(pstVFLCxt[bank].remappingScheduledStart == (pstVFLCxt[bank].numReservedBlocks + 10))
+	{
+		// oh crap, we only have 10 free spares left. back out now.
+		return false;
+	}
+
+	// stick this into the list
+	--pstVFLCxt[bank].remappingScheduledStart;
+	pstVFLCxt[bank].reservedBlockPoolMap[pstVFLCxt[bank].remappingScheduledStart] = block;
+	vfl_gen_checksum(bank);
+
+	return vfl_commit_cxt(bank);
+}
+
+static void vfl_set_good_block(int bank, u16 block, int isGood)
+{
+	int index = block / 8;
+	u8 bit = 1 << (7 - (index % 8));
+	if(isGood)
+		pstVFLCxt[bank].badBlockTable[index / 8] |= bit;
+	else
+		pstVFLCxt[bank].badBlockTable[index / 8] &= ~bit;
+}
+
+static u16 vfl_remap_block(int bank, u16 block)
+{
+	u16 newBlock = 0;
+	int newBlockIdx;
+	int i;
+
+	if(bank >= NANDGeometry->banksTotal || block >= NANDGeometry->blocksPerBank)
+		return 0;
+
+	LOG("ftl: attempting to remap bank %d, block %d\n", bank, block);
+	return 0;
+
+	// find a reserved block that is not being used
+	for(i = 0; i < pstVFLCxt[bank].totalReservedBlocks; ++i)
+	{
+		if(pstVFLCxt[bank].reservedBlockPoolMap[i] == 0)
+		{
+			newBlock = pstVFLCxt[bank].reservedBlockPoolStart + i;
+			newBlockIdx = i;
+			break;
+		}
+	}
+
+	// none found
+	if(newBlock == 0)
+		return 0;
+
+	// try to erase newly allocated reserved block nine times
+	for(i = 0; i < 9; ++i)
+	{
+		if(nand_erase(bank, newBlock) == 0)
+			break;
+	}
+
+	for(i = 0; i < newBlockIdx; ++i)
+	{
+		// mark any reserved block previously remapped for this block as bad
+		if(pstVFLCxt[bank].reservedBlockPoolMap[i] == block)
+			pstVFLCxt[bank].reservedBlockPoolMap[i] = 0xFFFF;
+	}
+
+	pstVFLCxt[bank].reservedBlockPoolMap[newBlockIdx] = block;
+	++pstVFLCxt[bank].numReservedBlocks;
+	vfl_set_good_block(bank, block, false);
+
+	return newBlock;
+}
+
+static void vfl_mark_remap_done(int bank, u16 block)
+{
+	u16 start;
+	u16 lastscheduled;
+	int i;
+
+	LOG("ftl: attempt to mark remap as done for bank %d, block %d\n", bank, block);
+	return;
+
+	start = pstVFLCxt[bank].remappingScheduledStart;
+	lastscheduled = pstVFLCxt[bank].reservedBlockPoolMap[start];
+	for (i = 0x333; i > 0 && i > start; i--)
+	{
+		if (pstVFLCxt[bank].reservedBlockPoolMap[i] == block)
+		{
+			// replace the done entry with the last one
+			if(i != start && i != 0x333)
+				pstVFLCxt[bank].reservedBlockPoolMap[i] = lastscheduled;
+
+			++pstVFLCxt[bank].remappingScheduledStart;
+			return;
+		}
+	}
+}
+
+static bool hasDeviceInfoBBT(void)
+{
+	int bank;
+	bool good = true;
+	for(bank = 0; bank < NANDGeometry->banksTotal; bank++) {
+		good = findDeviceInfoBBT(bank, NULL);
+		if(!good)
+			return false;
+	}
+
+	return good;
+}
+
+int VFL_Erase(u16 block) {
+	u16 physicalBlock;
+	int ret;
+	int bank;
+	int i;
+
+	block = block + FTLData->field_4;
+
+	for(bank = 0; bank < NANDGeometry->banksTotal; ++bank) {
+		if(vfl_check_remap_scheduled(bank, block))
+		{
+			vfl_remap_block(bank, block);
+			vfl_mark_remap_done(bank, block);
+			vfl_commit_cxt(bank);
+		}
+
+		physicalBlock = virtual_block_to_physical_block(bank, block);
+
+		for(i = 0; i < 3; ++i)
+		{
+			ret = nand_erase(bank, physicalBlock);
+			if(ret == 0)
+				break;
+		}
+
+		if(ret) {
+			LOG("ftl: block erase failed for bank %d, block %d\n", bank, block);
+			// FIXME: properly handle this
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+int VFL_Read(u32 virtualPageNumber, u8* buffer, u8* spare, bool empty_ok)
+{
+	u16 virtualBank;
+	u16 virtualBlock;
+	u16 virtualPage;
+	u16 physicalBlock;
+	u32 dwVpn;
+
+	int page;
+	int ret;
+
+	VFLData1.field_8++;
+	VFLData1.field_20++;
+
+	dwVpn = virtualPageNumber + (NANDGeometry->pagesPerSuBlk * FTLData->field_4);
+	if(dwVpn >= NANDGeometry->pagesTotal) {
+		LOG("ftl: dwVpn overflow: %d\n", dwVpn);
+		return -EINVAL;
+	}
+
+	if(dwVpn < NANDGeometry->pagesPerSuBlk) {
+		LOG("ftl: dwVpn underflow: %d\n", dwVpn);
+	}
+
+	virtual_page_number_to_virtual_address(dwVpn, &virtualBank, &virtualBlock, &virtualPage);
+	physicalBlock = virtual_block_to_physical_block(virtualBank, virtualBlock);
+
+	page = physicalBlock * NANDGeometry->pagesPerBlock + virtualPage;
+
+#ifdef IPHONE_DEBUG
+	LOG("ftl: vfl_read: vpn: %u, bank %d, page %u\n", virtualPageNumber, virtualBank, page);
+#endif
+
+	ret = nand_read(virtualBank, page, buffer, spare, true, true);
+
+	if(!empty_ok && ret == ERROR_EMPTYBLOCK)
+	{
+		ret = -EIO;
+	}
+
+	if(ret == -EINVAL || ret == -EIO) {
+		nand_bank_reset(virtualBank, 100);
+		ret = nand_read(virtualBank, page, buffer, spare, true, true);
+		if(!empty_ok && ret == ERROR_EMPTYBLOCK) {
+			return -EIO;
+		}
+
+		if(ret == -EINVAL || ret == -EIO)
+			return ret;
+	}
+
+	if(ret == ERROR_EMPTYBLOCK) {
+		if(spare) {
+			memset(spare, 0xFF, sizeof(SpareData));
+		}
+	}
+
+	return ret;
+}
+
+int VFL_Write(u32 virtualPageNumber, u8* buffer, u8* spare)
+{
+	u16 virtualBank;
+	u16 virtualBlock;
+	u16 virtualPage;
+	u16 physicalBlock;
+
+	u32 dwVpn;
+
+	int page;
+	int ret;
+
+	dwVpn = virtualPageNumber + (NANDGeometry->pagesPerSuBlk * FTLData->field_4);
+	if(dwVpn >= NANDGeometry->pagesTotal) {
+		LOG("ftl: dwVpn overflow: %d\n", dwVpn);
+		return -EINVAL;
+	}
+
+	if(dwVpn < NANDGeometry->pagesPerSuBlk) {
+		LOG("ftl: dwVpn underflow: %d\n", dwVpn);
+	}
+
+	virtual_page_number_to_virtual_address(dwVpn, &virtualBank, &virtualBlock, &virtualPage);
+	physicalBlock = virtual_block_to_physical_block(virtualBank, virtualBlock);
+
+	page = physicalBlock * NANDGeometry->pagesPerBlock + virtualPage;
+
+#ifdef IPHONE_DEBUG
+	LOG("ftl: vfl_write: vpn: %u, bank %d, page %u\n", virtualPageNumber, virtualBank, page);
+#endif
+
+		ret = nand_read(virtualBank, page, PageBuffer, SpareBuffer, true, true);
+	if(ret != ERROR_EMPTYBLOCK)
+	{
+		LOG("ftl: WTF trying to write to a non-blank page! vpn = %u bank = %d page = %u\r\n", virtualPageNumber, virtualBank, page);
+		return -1;
+	}
+
+	ret = nand_write(virtualBank, page, buffer, spare, true);
+	if(ret == 0)
+		return 0;
+
+	++pstVFLCxt[virtualBank].field_16;
+	vfl_gen_checksum(virtualBank);
+	vfl_schedule_block_for_remap(virtualBank, virtualBlock);
+
+	return -1;
+}
+
+bool VFL_ReadMultiplePagesInVb(int logicalBlock, int logicalPage, int count, u8* main, SpareData* spare)
+{
+	int i;
+	int currentPage = logicalPage;
+	for(i = 0; i < count; i++) {
+		int ret = VFL_Read((logicalBlock * NANDGeometry->pagesPerSuBlk) + currentPage, main + (NANDGeometry->bytesPerPage * i), (u8*) &spare[i], true);
+		currentPage++;
+		if(ret != 0)
+			return false;
+	}
+	return true;
+}
+
+bool VFL_ReadScatteredPagesInVb(u32* virtualPageNumber, int count, u8* main, SpareData* spare)
+{
+	int i;
+	int ret;
+
+	VFLData1.field_8 += count;
+	VFLData1.field_20++;
+
+	for(i = 0; i < count; i++) {
+		u32 dwVpn = virtualPageNumber[i] + (NANDGeometry->pagesPerSuBlk * FTLData->field_4);
+		u16 virtualBlock;
+		u16 virtualPage;
+		u16 physicalBlock;
+
+		virtual_page_number_to_virtual_address(dwVpn, &ScatteredBankNumberBuffer[i], &virtualBlock, &virtualPage);
+		physicalBlock = virtual_block_to_physical_block(ScatteredBankNumberBuffer[i], virtualBlock);
+		ScatteredPageNumberBuffer[i] = physicalBlock * NANDGeometry->pagesPerBlock + virtualPage;
+#ifdef IPHONE_DEBUG
+		LOG("ftl: vfl_read (scattered): vpn: %u, bank  %d, page %u\n", virtualPageNumber[i], ScatteredBankNumberBuffer[i], ScatteredPageNumberBuffer[i]);
+#endif
+	}
+
+	ret = nand_read_multiple(ScatteredBankNumberBuffer, ScatteredPageNumberBuffer, main, spare, count);
+
+	if(ret != 0)
+		return false;
+	else
+		return true;
+}
+
+u16* VFL_GetFTLCtrlBlock(void)
+{
+	int bank = 0;
+	int max = 0;
+	u16* FTLCtrlBlock = NULL;
+	for(bank = 0; bank < NANDGeometry->banksTotal; bank++)
+	{
+		int cur = pstVFLCxt[bank].usnInc;
+		if(max <= cur) {
+			max = cur;
+			FTLCtrlBlock = pstVFLCxt[bank].FTLCtrlBlock;
+		}
+	}
+
+	return FTLCtrlBlock;
+}
+
+int VFL_Open(void)
+{
+	void* FTLCtrlBlock;
+	u16 buffer[3];
+
+	int bank = 0;
+	for(bank = 0; bank < NANDGeometry->banksTotal; bank++) {
+		VFLCxt* curVFLCxt;
+		int i;
+		int minUsn;
+		int VFLCxtIdx;
+		int last;
+		int page;
+
+		if(!findDeviceInfoBBT(bank, pstBBTArea)) {
+			LOG("ftl: findDeviceInfoBBT failed\n");
+			return -1;
+		}
+
+		if(bank >= NANDGeometry->banksTotal) {
+			return -1;
+		}
+
+		curVFLCxt = &pstVFLCxt[bank];
+
+		// Any VFLCxt page will contain an up-to-date list of all blocks used to store VFLCxt pages. Find any such
+		// page in the system area.
+
+		for(i = 1; i < FTLData->sysSuBlks; i++) {
+			// so pstBBTArea is a bit array of some sort
+			if(!(pstBBTArea[i / 8] & (1 << (i  & 0x7))))
+				continue;
+
+			if(nand_read_vfl_cxt_page(bank, i, 0, PageBuffer, SpareBuffer) == true) {
+				memcpy(curVFLCxt->VFLCxtBlock, ((VFLCxt*)PageBuffer)->VFLCxtBlock, sizeof(curVFLCxt->VFLCxtBlock));
+				break;
+			}
+		}
+
+		if(i == FTLData->sysSuBlks) {
+			LOG("ftl: cannot find readable VFLCxtBlock\n");
+			return -1;
+		}
+
+		// Since VFLCxtBlock is a ringbuffer, if blockA.page0.spare.usnDec < blockB.page0.usnDec, then for any page a
+	        // in blockA and any page b in blockB, a.spare.usNDec < b.spare.usnDec. Therefore, to begin finding the
+		// page/VFLCxt with the lowest usnDec, we should just look at the first page of each block in the ring.
+		minUsn = 0xFFFFFFFF;
+		VFLCxtIdx = 4;
+		for(i = 0; i < 4; i++) {
+			SpareData* spareData;
+			u16 block = curVFLCxt->VFLCxtBlock[i];
+			if(block == 0xFFFF)
+				continue;
+
+			if(nand_read_vfl_cxt_page(bank, block, 0, PageBuffer, SpareBuffer) != true)
+				continue;
+
+			spareData = (SpareData*) SpareBuffer;
+			if(spareData->meta.usnDec > 0 && spareData->meta.usnDec <= minUsn) {
+				minUsn = spareData->meta.usnDec;
+				VFLCxtIdx = i;
+			}
+		}
+
+		if(VFLCxtIdx == 4) {
+			LOG("ftl: cannot find readable VFLCxtBlock index in spares\n");
+			return -1;
+		}
+
+		// VFLCxts are stored in the block such that they are duplicated 8 times. Therefore, we only need to
+		// read every 8th page, and nand_read_vfl_cxt_page will try the 7 subsequent pages if the first was
+		// no good. The last non-blank page will have the lowest spare.usnDec and highest usnInc for VFLCxt
+		// in all the land (and is the newest).
+		last = 0;
+		for(page = 8; page < NANDGeometry->pagesPerBlock; page += 8) {
+			if(nand_read_vfl_cxt_page(bank, curVFLCxt->VFLCxtBlock[VFLCxtIdx], page, PageBuffer, SpareBuffer) == false) {
+				break;
+			}
+
+			last = page;
+		}
+
+		if(nand_read_vfl_cxt_page(bank, curVFLCxt->VFLCxtBlock[VFLCxtIdx], last, PageBuffer, SpareBuffer) == false) {
+			LOG("ftl: cannot find readable VFLCxt\n");
+			return -1;
+		}
+
+		// Aha, so the upshot is that this finds the VFLCxt and copies it into pstVFLCxt
+		memcpy(&pstVFLCxt[bank], PageBuffer, sizeof(VFLCxt));
+
+		// This is the newest VFLCxt across all banks
+		if(curVFLCxt->usnInc >= curVFLusnInc) {
+			curVFLusnInc = curVFLCxt->usnInc;
+		}
+
+		// Verify the checksum
+		if(vfl_check_checksum(bank) == false) {
+			LOG("ftl: VFLCxt has bad checksum\n");
+			return -1;
+		}
+	}
+
+	// retrieve the FTL control blocks from the latest VFL across all banks.
+	FTLCtrlBlock = VFL_GetFTLCtrlBlock();
+
+	// Need a buffer because eventually we'll copy over the source
+	memcpy(buffer, FTLCtrlBlock, sizeof(buffer));
+
+	// Then we update the VFLCxts on every bank with that information.
+	for(bank = 0; bank < NANDGeometry->banksTotal; bank++) {
+		memcpy(pstVFLCxt[bank].FTLCtrlBlock, buffer, sizeof(buffer));
+		vfl_gen_checksum(bank);
+	}
+
+	return 0;
+}
+
+int VFL_Init(void)
+{
+	nand_setup();
+
+	NANDGeometry = nand_get_geometry();
+	FTLData = nand_get_ftl_data();
+
+	memset(&VFLData1, 0, sizeof(VFLData1));
+	if(pstVFLCxt == NULL) {
+		pstVFLCxt = kmalloc(NANDGeometry->banksTotal * sizeof(VFLCxt), GFP_KERNEL | GFP_DMA);
+		if(pstVFLCxt == NULL)
+			return -1;
+	}
+
+	if(pstBBTArea == NULL) {
+		pstBBTArea = (u8*) kmalloc((NANDGeometry->blocksPerBank + 7) / 8, GFP_KERNEL | GFP_DMA);
+		if(pstBBTArea == NULL)
+			return -1;
+	}
+
+	if(ScatteredPageNumberBuffer == NULL && ScatteredBankNumberBuffer == NULL) {
+		ScatteredPageNumberBuffer = (u32*) kmalloc(NANDGeometry->pagesPerSuBlk * 4, GFP_KERNEL | GFP_DMA);
+		ScatteredBankNumberBuffer = (u16*) kmalloc(NANDGeometry->pagesPerSuBlk * 4, GFP_KERNEL | GFP_DMA);
+		if(ScatteredPageNumberBuffer == NULL || ScatteredBankNumberBuffer == NULL)
+			return -1;
+	}
+
+	PageBuffer = (u8*) kmalloc(NANDGeometry->bytesPerPage, GFP_KERNEL | GFP_DMA);
+	SpareBuffer = (u8*) kmalloc(NANDGeometry->bytesPerSpare, GFP_KERNEL | GFP_DMA);
+
+	curVFLusnInc = 0;
+
+	return 0;
+}
+
+int VFL_StoreFTLCtrlBlock(u16* ftlctrlblock)
+{
+	int bank;
+	for(bank = 0; bank < NANDGeometry->banksTotal; bank++)
+		memcpy(pstVFLCxt[bank].FTLCtrlBlock, ftlctrlblock, sizeof(pstVFLCxt[bank].FTLCtrlBlock));
+
+	// pick a semi-random bank to commit
+	return vfl_commit_cxt(curVFLusnInc % NANDGeometry->banksTotal);
+}
+
+int VFL_Verify(void)
+{
+	int i;
+	int foundSignature = false;
+
+	LOGDBG("ftl: Attempting to read %d pages from first block of first bank.\n", NANDGeometry->pagesPerBlock);
+	for(i = 0; i < NANDGeometry->pagesPerBlock; i++) {
+		int ret;
+		if((ret = nand_read_alternate_ecc(0, i, PageBuffer)) == 0) {
+			u32 id = *((u32*) PageBuffer);
+			if(id == FTL_ID_V1 || id == FTL_ID_V2 || id == FTL_ID_V3) {
+				LOG("ftl: Found production format: %x\n", id);
+				foundSignature = true;
+				break;
+			} else {
+				LOGDBG("ftl: Found non-matching signature: %x\n", ((u32*) PageBuffer));
+			}
+		} else {
+			LOGDBG("ftl: page %d of first bank is unreadable: %x!\n", i, ret);
+		}
+	}
+
+	if(!foundSignature || !hasDeviceInfoBBT()) {
+		LOG("ftl: no signature or production format.\n");
+		return -1;
+	}
+
+	return 0;
+}
+
diff -Nur linux-2.6.32-orig/arch/arm/mach-davinci/dm646x.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-davinci/dm646x.c
--- linux-2.6.32-orig/arch/arm/mach-davinci/dm646x.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-davinci/dm646x.c	2010-11-18 21:05:30.000000000 +0600
@@ -789,7 +789,14 @@
 		.part_no	= 0xb770,
 		.manufacturer	= 0x017,
 		.cpu_id		= DAVINCI_CPU_ID_DM6467,
-		.name		= "dm6467",
+		.name		= "dm6467_rev1.x",
+	},
+	{
+		.variant	= 0x1,
+		.part_no	= 0xb770,
+		.manufacturer	= 0x017,
+		.cpu_id		= DAVINCI_CPU_ID_DM6467,
+		.name		= "dm6467_rev3.x",
 	},
 };
 
diff -Nur linux-2.6.32-orig/arch/arm/mach-pxa/em-x270.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-pxa/em-x270.c
--- linux-2.6.32-orig/arch/arm/mach-pxa/em-x270.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mach-pxa/em-x270.c	2010-11-18 21:05:30.000000000 +0600
@@ -497,16 +497,15 @@
 		goto err_free_vbus_gpio;
 
 	/* USB Hub power-on and reset */
-	gpio_direction_output(usb_hub_reset, 0);
+	gpio_direction_output(usb_hub_reset, 1);
+	gpio_direction_output(GPIO9_USB_VBUS_EN, 0);
 	regulator_enable(em_x270_usb_ldo);
-	gpio_set_value(usb_hub_reset, 1);
 	gpio_set_value(usb_hub_reset, 0);
+	gpio_set_value(usb_hub_reset, 1);
 	regulator_disable(em_x270_usb_ldo);
 	regulator_enable(em_x270_usb_ldo);
-	gpio_set_value(usb_hub_reset, 1);
-
-	/* enable VBUS */
-	gpio_direction_output(GPIO9_USB_VBUS_EN, 1);
+	gpio_set_value(usb_hub_reset, 0);
+	gpio_set_value(GPIO9_USB_VBUS_EN, 1);
 
 	return 0;
 
diff -Nur linux-2.6.32-orig/arch/arm/Makefile iDroid-Project-kernel_common-9e90fd2/arch/arm/Makefile
--- linux-2.6.32-orig/arch/arm/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -169,6 +169,7 @@
 machine-$(CONFIG_ARCH_VERSATILE)	:= versatile
 machine-$(CONFIG_ARCH_W90X900)		:= w90x900
 machine-$(CONFIG_FOOTBRIDGE)		:= footbridge
+machine-$(CONFIG_MACH_APPLE_IPHONE)	:= apple_iphone
 machine-$(CONFIG_ARCH_MXC91231)		:= mxc91231
 
 # Platform directory name.  This list is sorted alphanumerically
diff -Nur linux-2.6.32-orig/arch/arm/mm/cache-v6.S iDroid-Project-kernel_common-9e90fd2/arch/arm/mm/cache-v6.S
--- linux-2.6.32-orig/arch/arm/mm/cache-v6.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mm/cache-v6.S	2010-11-18 21:05:30.000000000 +0600
@@ -248,6 +248,11 @@
  *	- end     - virtual end address of region
  */
 ENTRY(v6_dma_flush_range)
+#ifdef CONFIG_CACHE_FLUSH_RANGE_LIMIT
+	sub	r2, r1, r0
+	cmp	r2, #CONFIG_CACHE_FLUSH_RANGE_LIMIT
+	bhi	v6_dma_flush_dcache_all
+#endif
 	bic	r0, r0, #D_CACHE_LINE_SIZE - 1
 1:
 #ifdef HARVARD_CACHE
@@ -262,6 +267,18 @@
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
 	mov	pc, lr
 
+#ifdef CONFIG_CACHE_FLUSH_RANGE_LIMIT
+v6_dma_flush_dcache_all:
+	mov	r0, #0
+#ifdef HARVARD_CACHE
+	mcr	p15, 0, r0, c7, c14, 0		@ D cache clean+invalidate
+#else
+	mcr	p15, 0, r0, c7, c15, 0		@ Cache clean+invalidate
+#endif
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
+	mov	pc, lr
+#endif
+
 	__INITDATA
 
 	.type	v6_cache_fns, #object
diff -Nur linux-2.6.32-orig/arch/arm/mm/Kconfig iDroid-Project-kernel_common-9e90fd2/arch/arm/mm/Kconfig
--- linux-2.6.32-orig/arch/arm/mm/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mm/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -388,7 +388,8 @@
 
 # ARMv6
 config CPU_V6
-	bool "Support ARM V6 processor" if ARCH_INTEGRATOR || MACH_REALVIEW_EB || MACH_REALVIEW_PBX
+	bool "Support ARM V6 processor" if ARCH_INTEGRATOR || MACH_REALVIEW_EB || MACH_REALVIEW_PBX || MACH_APPLE_IPHONE
+	default y if MACH_APPLE_IPHONE
 	select CPU_32v6
 	select CPU_ABRT_EV6
 	select CPU_PABRT_V6
diff -Nur linux-2.6.32-orig/arch/arm/mm/mmap.c iDroid-Project-kernel_common-9e90fd2/arch/arm/mm/mmap.c
--- linux-2.6.32-orig/arch/arm/mm/mmap.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/arm/mm/mmap.c	2010-11-18 21:05:30.000000000 +0600
@@ -54,7 +54,8 @@
 	 * We enforce the MAP_FIXED case.
 	 */
 	if (flags & MAP_FIXED) {
-		if (aliasing && flags & MAP_SHARED && addr & (SHMLBA - 1))
+		if (aliasing && flags & MAP_SHARED &&
+		    (addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1))
 			return -EINVAL;
 		return addr;
 	}
diff -Nur linux-2.6.32-orig/arch/avr32/include/asm/syscalls.h iDroid-Project-kernel_common-9e90fd2/arch/avr32/include/asm/syscalls.h
--- linux-2.6.32-orig/arch/avr32/include/asm/syscalls.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/avr32/include/asm/syscalls.h	2010-11-18 21:05:30.000000000 +0600
@@ -29,10 +29,6 @@
 			       struct pt_regs *);
 asmlinkage int sys_rt_sigreturn(struct pt_regs *);
 
-/* kernel/sys_avr32.c */
-asmlinkage long sys_mmap2(unsigned long, unsigned long, unsigned long,
-			  unsigned long, unsigned long, off_t);
-
 /* mm/cache.c */
 asmlinkage int sys_cacheflush(int, void __user *, size_t);
 
diff -Nur linux-2.6.32-orig/arch/avr32/kernel/sys_avr32.c iDroid-Project-kernel_common-9e90fd2/arch/avr32/kernel/sys_avr32.c
--- linux-2.6.32-orig/arch/avr32/kernel/sys_avr32.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/avr32/kernel/sys_avr32.c	2010-11-18 21:05:30.000000000 +0600
@@ -5,39 +5,8 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-#include <linux/errno.h>
-#include <linux/fs.h>
-#include <linux/file.h>
-#include <linux/mm.h>
 #include <linux/unistd.h>
 
-#include <asm/mman.h>
-#include <asm/uaccess.h>
-#include <asm/syscalls.h>
-
-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
-			  unsigned long prot, unsigned long flags,
-			  unsigned long fd, off_t offset)
-{
-	int error = -EBADF;
-	struct file *file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			return error;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, offset);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-	return error;
-}
-
 int kernel_execve(const char *file, char **argv, char **envp)
 {
 	register long scno asm("r8") = __NR_execve;
diff -Nur linux-2.6.32-orig/arch/avr32/kernel/syscall-stubs.S iDroid-Project-kernel_common-9e90fd2/arch/avr32/kernel/syscall-stubs.S
--- linux-2.6.32-orig/arch/avr32/kernel/syscall-stubs.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/avr32/kernel/syscall-stubs.S	2010-11-18 21:05:30.000000000 +0600
@@ -61,7 +61,7 @@
 __sys_mmap2:
 	pushm	lr
 	st.w	--sp, ARG6
-	call	sys_mmap2
+	call	sys_mmap_pgoff
 	sub	sp, -4
 	popm	pc
 
diff -Nur linux-2.6.32-orig/arch/blackfin/include/asm/page.h iDroid-Project-kernel_common-9e90fd2/arch/blackfin/include/asm/page.h
--- linux-2.6.32-orig/arch/blackfin/include/asm/page.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/blackfin/include/asm/page.h	2010-11-18 21:05:30.000000000 +0600
@@ -10,4 +10,9 @@
 #include <asm-generic/page.h>
 #define MAP_NR(addr) (((unsigned long)(addr)-PAGE_OFFSET) >> PAGE_SHIFT)
 
+#define VM_DATA_DEFAULT_FLAGS \
+	(VM_READ | VM_WRITE | \
+	((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
+		 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
 #endif
diff -Nur linux-2.6.32-orig/arch/blackfin/kernel/sys_bfin.c iDroid-Project-kernel_common-9e90fd2/arch/blackfin/kernel/sys_bfin.c
--- linux-2.6.32-orig/arch/blackfin/kernel/sys_bfin.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/blackfin/kernel/sys_bfin.c	2010-11-18 21:05:30.000000000 +0600
@@ -22,39 +22,6 @@
 #include <asm/cacheflush.h>
 #include <asm/dma.h>
 
-/* common code for old and new mmaps */
-static inline long
-do_mmap2(unsigned long addr, unsigned long len,
-	 unsigned long prot, unsigned long flags,
-	 unsigned long fd, unsigned long pgoff)
-{
-	int error = -EBADF;
-	struct file *file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
- out:
-	return error;
-}
-
-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
-			  unsigned long prot, unsigned long flags,
-			  unsigned long fd, unsigned long pgoff)
-{
-	return do_mmap2(addr, len, prot, flags, fd, pgoff);
-}
-
 asmlinkage void *sys_sram_alloc(size_t size, unsigned long flags)
 {
 	return sram_alloc_with_lsl(size, flags);
diff -Nur linux-2.6.32-orig/arch/blackfin/mach-common/entry.S iDroid-Project-kernel_common-9e90fd2/arch/blackfin/mach-common/entry.S
--- linux-2.6.32-orig/arch/blackfin/mach-common/entry.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/blackfin/mach-common/entry.S	2010-11-18 21:05:30.000000000 +0600
@@ -1422,7 +1422,7 @@
 	.long _sys_ni_syscall	/* streams2 */
 	.long _sys_vfork		/* 190 */
 	.long _sys_getrlimit
-	.long _sys_mmap2
+	.long _sys_mmap_pgoff
 	.long _sys_truncate64
 	.long _sys_ftruncate64
 	.long _sys_stat64	/* 195 */
diff -Nur linux-2.6.32-orig/arch/cris/kernel/sys_cris.c iDroid-Project-kernel_common-9e90fd2/arch/cris/kernel/sys_cris.c
--- linux-2.6.32-orig/arch/cris/kernel/sys_cris.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/cris/kernel/sys_cris.c	2010-11-18 21:05:30.000000000 +0600
@@ -26,31 +26,6 @@
 #include <asm/uaccess.h>
 #include <asm/segment.h>
 
-/* common code for old and new mmaps */
-static inline long
-do_mmap2(unsigned long addr, unsigned long len, unsigned long prot,
-        unsigned long flags, unsigned long fd, unsigned long pgoff)
-{
-        int error = -EBADF;
-        struct file * file = NULL;
-
-        flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-        if (!(flags & MAP_ANONYMOUS)) {
-                file = fget(fd);
-                if (!file)
-                        goto out;
-        }
-
-        down_write(&current->mm->mmap_sem);
-        error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-        up_write(&current->mm->mmap_sem);
-
-        if (file)
-                fput(file);
-out:
-        return error;
-}
-
 asmlinkage unsigned long old_mmap(unsigned long __user *args)
 {        
 	unsigned long buffer[6];
@@ -63,7 +38,7 @@
 	if (buffer[5] & ~PAGE_MASK) /* verify that offset is on page boundary */
 		goto out;
 
-	err = do_mmap2(buffer[0], buffer[1], buffer[2], buffer[3],
+	err = sys_mmap_pgoff(buffer[0], buffer[1], buffer[2], buffer[3],
                        buffer[4], buffer[5] >> PAGE_SHIFT);
 out:
 	return err;
@@ -73,7 +48,8 @@
 sys_mmap2(unsigned long addr, unsigned long len, unsigned long prot,
           unsigned long flags, unsigned long fd, unsigned long pgoff)
 {
-        return do_mmap2(addr, len, prot, flags, fd, pgoff);
+	/* bug(?): 8Kb pages here */
+        return sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);
 }
 
 /*
diff -Nur linux-2.6.32-orig/arch/frv/include/asm/page.h iDroid-Project-kernel_common-9e90fd2/arch/frv/include/asm/page.h
--- linux-2.6.32-orig/arch/frv/include/asm/page.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/frv/include/asm/page.h	2010-11-18 21:05:30.000000000 +0600
@@ -63,12 +63,10 @@
 #define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
 
 
-#ifdef CONFIG_MMU
 #define VM_DATA_DEFAULT_FLAGS \
 	(VM_READ | VM_WRITE | \
 	((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
 		 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
-#endif
 
 #endif /* __ASSEMBLY__ */
 
diff -Nur linux-2.6.32-orig/arch/frv/kernel/sys_frv.c iDroid-Project-kernel_common-9e90fd2/arch/frv/kernel/sys_frv.c
--- linux-2.6.32-orig/arch/frv/kernel/sys_frv.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/frv/kernel/sys_frv.c	2010-11-18 21:05:30.000000000 +0600
@@ -31,9 +31,6 @@
 			  unsigned long prot, unsigned long flags,
 			  unsigned long fd, unsigned long pgoff)
 {
-	int error = -EBADF;
-	struct file * file = NULL;
-
 	/* As with sparc32, make sure the shift for mmap2 is constant
 	   (12), no matter what PAGE_SIZE we have.... */
 
@@ -41,69 +38,10 @@
 	   trying to map something we can't */
 	if (pgoff & ((1 << (PAGE_SHIFT - 12)) - 1))
 		return -EINVAL;
-	pgoff >>= PAGE_SHIFT - 12;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:
-	return error;
-}
-
-#if 0 /* DAVIDM - do we want this */
-struct mmap_arg_struct64 {
-	__u32 addr;
-	__u32 len;
-	__u32 prot;
-	__u32 flags;
-	__u64 offset; /* 64 bits */
-	__u32 fd;
-};
-
-asmlinkage long sys_mmap64(struct mmap_arg_struct64 *arg)
-{
-	int error = -EFAULT;
-	struct file * file = NULL;
-	struct mmap_arg_struct64 a;
-	unsigned long pgoff;
-
-	if (copy_from_user(&a, arg, sizeof(a)))
-		return -EFAULT;
-
-	if ((long)a.offset & ~PAGE_MASK)
-		return -EINVAL;
-
-	pgoff = a.offset >> PAGE_SHIFT;
-	if ((a.offset >> PAGE_SHIFT) != pgoff)
-		return -EINVAL;
-
-	if (!(a.flags & MAP_ANONYMOUS)) {
-		error = -EBADF;
-		file = fget(a.fd);
-		if (!file)
-			goto out;
-	}
-	a.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, a.addr, a.len, a.prot, a.flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-	if (file)
-		fput(file);
-out:
-	return error;
+	return sys_mmap_pgoff(addr, len, prot, flags, fd,
+			      pgoff >> (PAGE_SHIFT - 12));
 }
-#endif
 
 /*
  * sys_ipc() is the de-multiplexer for the SysV IPC calls..
diff -Nur linux-2.6.32-orig/arch/h8300/kernel/syscalls.S iDroid-Project-kernel_common-9e90fd2/arch/h8300/kernel/syscalls.S
--- linux-2.6.32-orig/arch/h8300/kernel/syscalls.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/h8300/kernel/syscalls.S	2010-11-18 21:05:30.000000000 +0600
@@ -206,7 +206,7 @@
 	.long SYMBOL_NAME(sys_ni_syscall)	/* streams2 */
 	.long SYMBOL_NAME(sys_vfork)            /* 190 */
 	.long SYMBOL_NAME(sys_getrlimit)
-	.long SYMBOL_NAME(sys_mmap2)
+	.long SYMBOL_NAME(sys_mmap_pgoff)
 	.long SYMBOL_NAME(sys_truncate64)
 	.long SYMBOL_NAME(sys_ftruncate64)
 	.long SYMBOL_NAME(sys_stat64)		/* 195 */
diff -Nur linux-2.6.32-orig/arch/h8300/kernel/sys_h8300.c iDroid-Project-kernel_common-9e90fd2/arch/h8300/kernel/sys_h8300.c
--- linux-2.6.32-orig/arch/h8300/kernel/sys_h8300.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/h8300/kernel/sys_h8300.c	2010-11-18 21:05:30.000000000 +0600
@@ -26,39 +26,6 @@
 #include <asm/traps.h>
 #include <asm/unistd.h>
 
-/* common code for old and new mmaps */
-static inline long do_mmap2(
-	unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags,
-	unsigned long fd, unsigned long pgoff)
-{
-	int error = -EBADF;
-	struct file * file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:
-	return error;
-}
-
-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags,
-	unsigned long fd, unsigned long pgoff)
-{
-	return do_mmap2(addr, len, prot, flags, fd, pgoff);
-}
-
 /*
  * Perform the select(nd, in, out, ex, tv) and mmap() system
  * calls. Linux/m68k cloned Linux/i386, which didn't use to be able to
@@ -87,58 +54,12 @@
 	if (a.offset & ~PAGE_MASK)
 		goto out;
 
-	a.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-
-	error = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);
+	error = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,
+			       a.offset >> PAGE_SHIFT);
 out:
 	return error;
 }
 
-#if 0 /* DAVIDM - do we want this */
-struct mmap_arg_struct64 {
-	__u32 addr;
-	__u32 len;
-	__u32 prot;
-	__u32 flags;
-	__u64 offset; /* 64 bits */
-	__u32 fd;
-};
-
-asmlinkage long sys_mmap64(struct mmap_arg_struct64 *arg)
-{
-	int error = -EFAULT;
-	struct file * file = NULL;
-	struct mmap_arg_struct64 a;
-	unsigned long pgoff;
-
-	if (copy_from_user(&a, arg, sizeof(a)))
-		return -EFAULT;
-
-	if ((long)a.offset & ~PAGE_MASK)
-		return -EINVAL;
-
-	pgoff = a.offset >> PAGE_SHIFT;
-	if ((a.offset >> PAGE_SHIFT) != pgoff)
-		return -EINVAL;
-
-	if (!(a.flags & MAP_ANONYMOUS)) {
-		error = -EBADF;
-		file = fget(a.fd);
-		if (!file)
-			goto out;
-	}
-	a.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, a.addr, a.len, a.prot, a.flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-	if (file)
-		fput(file);
-out:
-	return error;
-}
-#endif
-
 struct sel_arg_struct {
 	unsigned long n;
 	fd_set *inp, *outp, *exp;
diff -Nur linux-2.6.32-orig/arch/ia64/ia32/sys_ia32.c iDroid-Project-kernel_common-9e90fd2/arch/ia64/ia32/sys_ia32.c
--- linux-2.6.32-orig/arch/ia64/ia32/sys_ia32.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/ia64/ia32/sys_ia32.c	2010-11-18 21:05:30.000000000 +0600
@@ -858,6 +858,9 @@
 
 	prot = get_prot32(prot);
 
+	if (flags & MAP_HUGETLB)
+		return -ENOMEM;
+
 #if PAGE_SHIFT > IA32_PAGE_SHIFT
 	mutex_lock(&ia32_mmap_mutex);
 	{
diff -Nur linux-2.6.32-orig/arch/ia64/include/asm/io.h iDroid-Project-kernel_common-9e90fd2/arch/ia64/include/asm/io.h
--- linux-2.6.32-orig/arch/ia64/include/asm/io.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/ia64/include/asm/io.h	2010-11-18 21:05:30.000000000 +0600
@@ -424,6 +424,8 @@
 extern void __iomem * ioremap(unsigned long offset, unsigned long size);
 extern void __iomem * ioremap_nocache (unsigned long offset, unsigned long size);
 extern void iounmap (volatile void __iomem *addr);
+extern void __iomem * early_ioremap (unsigned long phys_addr, unsigned long size);
+extern void early_iounmap (volatile void __iomem *addr, unsigned long size);
 
 /*
  * String version of IO memory access ops:
diff -Nur linux-2.6.32-orig/arch/ia64/kernel/sys_ia64.c iDroid-Project-kernel_common-9e90fd2/arch/ia64/kernel/sys_ia64.c
--- linux-2.6.32-orig/arch/ia64/kernel/sys_ia64.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/ia64/kernel/sys_ia64.c	2010-11-18 21:05:30.000000000 +0600
@@ -100,51 +100,7 @@
 asmlinkage unsigned long
 ia64_brk (unsigned long brk)
 {
-	unsigned long rlim, retval, newbrk, oldbrk;
-	struct mm_struct *mm = current->mm;
-
-	/*
-	 * Most of this replicates the code in sys_brk() except for an additional safety
-	 * check and the clearing of r8.  However, we can't call sys_brk() because we need
-	 * to acquire the mmap_sem before we can do the test...
-	 */
-	down_write(&mm->mmap_sem);
-
-	if (brk < mm->end_code)
-		goto out;
-	newbrk = PAGE_ALIGN(brk);
-	oldbrk = PAGE_ALIGN(mm->brk);
-	if (oldbrk == newbrk)
-		goto set_brk;
-
-	/* Always allow shrinking brk. */
-	if (brk <= mm->brk) {
-		if (!do_munmap(mm, newbrk, oldbrk-newbrk))
-			goto set_brk;
-		goto out;
-	}
-
-	/* Check against unimplemented/unmapped addresses: */
-	if ((newbrk - oldbrk) > RGN_MAP_LIMIT || REGION_OFFSET(newbrk) > RGN_MAP_LIMIT)
-		goto out;
-
-	/* Check against rlimit.. */
-	rlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;
-	if (rlim < RLIM_INFINITY && brk - mm->start_data > rlim)
-		goto out;
-
-	/* Check against existing mmap mappings. */
-	if (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE))
-		goto out;
-
-	/* Ok, looks good - let it rip. */
-	if (do_brk(oldbrk, newbrk-oldbrk) != oldbrk)
-		goto out;
-set_brk:
-	mm->brk = brk;
-out:
-	retval = mm->brk;
-	up_write(&mm->mmap_sem);
+	unsigned long retval = sys_brk(brk);
 	force_successful_syscall_return();
 	return retval;
 }
@@ -185,39 +141,6 @@
 	return 0;
 }
 
-static inline unsigned long
-do_mmap2 (unsigned long addr, unsigned long len, int prot, int flags, int fd, unsigned long pgoff)
-{
-	struct file *file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			return -EBADF;
-
-		if (!file->f_op || !file->f_op->mmap) {
-			addr = -ENODEV;
-			goto out;
-		}
-	}
-
-	/* Careful about overflows.. */
-	len = PAGE_ALIGN(len);
-	if (!len || len > TASK_SIZE) {
-		addr = -EINVAL;
-		goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	addr = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-out:	if (file)
-		fput(file);
-	return addr;
-}
-
 /*
  * mmap2() is like mmap() except that the offset is expressed in units
  * of PAGE_SIZE (instead of bytes).  This allows to mmap2() (pieces
@@ -226,7 +149,7 @@
 asmlinkage unsigned long
 sys_mmap2 (unsigned long addr, unsigned long len, int prot, int flags, int fd, long pgoff)
 {
-	addr = do_mmap2(addr, len, prot, flags, fd, pgoff);
+	addr = sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);
 	if (!IS_ERR((void *) addr))
 		force_successful_syscall_return();
 	return addr;
@@ -238,7 +161,7 @@
 	if (offset_in_page(off) != 0)
 		return -EINVAL;
 
-	addr = do_mmap2(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
+	addr = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
 	if (!IS_ERR((void *) addr))
 		force_successful_syscall_return();
 	return addr;
diff -Nur linux-2.6.32-orig/arch/ia64/mm/ioremap.c iDroid-Project-kernel_common-9e90fd2/arch/ia64/mm/ioremap.c
--- linux-2.6.32-orig/arch/ia64/mm/ioremap.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/ia64/mm/ioremap.c	2010-11-18 21:05:30.000000000 +0600
@@ -22,6 +22,12 @@
 }
 
 void __iomem *
+early_ioremap (unsigned long phys_addr, unsigned long size)
+{
+	return __ioremap(phys_addr);
+}
+
+void __iomem *
 ioremap (unsigned long phys_addr, unsigned long size)
 {
 	void __iomem *addr;
@@ -102,6 +108,11 @@
 EXPORT_SYMBOL(ioremap_nocache);
 
 void
+early_iounmap (volatile void __iomem *addr, unsigned long size)
+{
+}
+
+void
 iounmap (volatile void __iomem *addr)
 {
 	if (REGION_NUMBER(addr) == RGN_GATE)
diff -Nur linux-2.6.32-orig/arch/m32r/kernel/syscall_table.S iDroid-Project-kernel_common-9e90fd2/arch/m32r/kernel/syscall_table.S
--- linux-2.6.32-orig/arch/m32r/kernel/syscall_table.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/m32r/kernel/syscall_table.S	2010-11-18 21:05:30.000000000 +0600
@@ -191,7 +191,7 @@
 	.long sys_ni_syscall		/* streams2 */
 	.long sys_vfork			/* 190 */
 	.long sys_getrlimit
-	.long sys_mmap2
+	.long sys_mmap_pgoff
 	.long sys_truncate64
 	.long sys_ftruncate64
 	.long sys_stat64		/* 195 */
diff -Nur linux-2.6.32-orig/arch/m32r/kernel/sys_m32r.c iDroid-Project-kernel_common-9e90fd2/arch/m32r/kernel/sys_m32r.c
--- linux-2.6.32-orig/arch/m32r/kernel/sys_m32r.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/m32r/kernel/sys_m32r.c	2010-11-18 21:05:30.000000000 +0600
@@ -76,30 +76,6 @@
 	return oldval;
 }
 
-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags,
-	unsigned long fd, unsigned long pgoff)
-{
-	int error = -EBADF;
-	struct file *file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:
-	return error;
-}
-
 /*
  * sys_ipc() is the de-multiplexer for the SysV IPC calls..
  *
diff -Nur linux-2.6.32-orig/arch/m68k/kernel/sys_m68k.c iDroid-Project-kernel_common-9e90fd2/arch/m68k/kernel/sys_m68k.c
--- linux-2.6.32-orig/arch/m68k/kernel/sys_m68k.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/m68k/kernel/sys_m68k.c	2010-11-18 21:05:30.000000000 +0600
@@ -29,37 +29,16 @@
 #include <asm/page.h>
 #include <asm/unistd.h>
 
-/* common code for old and new mmaps */
-static inline long do_mmap2(
-	unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags,
-	unsigned long fd, unsigned long pgoff)
-{
-	int error = -EBADF;
-	struct file * file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:
-	return error;
-}
-
 asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
 	unsigned long prot, unsigned long flags,
 	unsigned long fd, unsigned long pgoff)
 {
-	return do_mmap2(addr, len, prot, flags, fd, pgoff);
+	/*
+	 * This is wrong for sun3 - there PAGE_SIZE is 8Kb,
+	 * so we need to shift the argument down by 1; m68k mmap64(3)
+	 * (in libc) expects the last argument of mmap2 in 4Kb units.
+	 */
+	return sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);
 }
 
 /*
@@ -90,57 +69,11 @@
 	if (a.offset & ~PAGE_MASK)
 		goto out;
 
-	a.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-
-	error = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);
-out:
-	return error;
-}
-
-#if 0
-struct mmap_arg_struct64 {
-	__u32 addr;
-	__u32 len;
-	__u32 prot;
-	__u32 flags;
-	__u64 offset; /* 64 bits */
-	__u32 fd;
-};
-
-asmlinkage long sys_mmap64(struct mmap_arg_struct64 *arg)
-{
-	int error = -EFAULT;
-	struct file * file = NULL;
-	struct mmap_arg_struct64 a;
-	unsigned long pgoff;
-
-	if (copy_from_user(&a, arg, sizeof(a)))
-		return -EFAULT;
-
-	if ((long)a.offset & ~PAGE_MASK)
-		return -EINVAL;
-
-	pgoff = a.offset >> PAGE_SHIFT;
-	if ((a.offset >> PAGE_SHIFT) != pgoff)
-		return -EINVAL;
-
-	if (!(a.flags & MAP_ANONYMOUS)) {
-		error = -EBADF;
-		file = fget(a.fd);
-		if (!file)
-			goto out;
-	}
-	a.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, a.addr, a.len, a.prot, a.flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-	if (file)
-		fput(file);
+	error = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,
+			       a.offset >> PAGE_SHIFT);
 out:
 	return error;
 }
-#endif
 
 struct sel_arg_struct {
 	unsigned long n;
diff -Nur linux-2.6.32-orig/arch/m68knommu/kernel/syscalltable.S iDroid-Project-kernel_common-9e90fd2/arch/m68knommu/kernel/syscalltable.S
--- linux-2.6.32-orig/arch/m68knommu/kernel/syscalltable.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/m68knommu/kernel/syscalltable.S	2010-11-18 21:05:30.000000000 +0600
@@ -210,7 +210,7 @@
 	.long sys_ni_syscall	/* streams2 */
 	.long sys_vfork		/* 190 */
 	.long sys_getrlimit
-	.long sys_mmap2
+	.long sys_mmap_pgoff
 	.long sys_truncate64
 	.long sys_ftruncate64
 	.long sys_stat64	/* 195 */
diff -Nur linux-2.6.32-orig/arch/m68knommu/kernel/sys_m68k.c iDroid-Project-kernel_common-9e90fd2/arch/m68knommu/kernel/sys_m68k.c
--- linux-2.6.32-orig/arch/m68knommu/kernel/sys_m68k.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/m68knommu/kernel/sys_m68k.c	2010-11-18 21:05:30.000000000 +0600
@@ -27,39 +27,6 @@
 #include <asm/cacheflush.h>
 #include <asm/unistd.h>
 
-/* common code for old and new mmaps */
-static inline long do_mmap2(
-	unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags,
-	unsigned long fd, unsigned long pgoff)
-{
-	int error = -EBADF;
-	struct file * file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:
-	return error;
-}
-
-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags,
-	unsigned long fd, unsigned long pgoff)
-{
-	return do_mmap2(addr, len, prot, flags, fd, pgoff);
-}
-
 /*
  * Perform the select(nd, in, out, ex, tv) and mmap() system
  * calls. Linux/m68k cloned Linux/i386, which didn't use to be able to
@@ -88,9 +55,8 @@
 	if (a.offset & ~PAGE_MASK)
 		goto out;
 
-	a.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-
-	error = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);
+	error = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,
+				a.offset >> PAGE_SHIFT);
 out:
 	return error;
 }
diff -Nur linux-2.6.32-orig/arch/microblaze/kernel/syscall_table.S iDroid-Project-kernel_common-9e90fd2/arch/microblaze/kernel/syscall_table.S
--- linux-2.6.32-orig/arch/microblaze/kernel/syscall_table.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/microblaze/kernel/syscall_table.S	2010-11-18 21:05:30.000000000 +0600
@@ -196,7 +196,7 @@
 	.long sys_ni_syscall		/* reserved for streams2 */
 	.long sys_vfork		/* 190 */
 	.long sys_getrlimit
-	.long sys_mmap2			/* mmap2 */
+	.long sys_mmap_pgoff		/* mmap2 */
 	.long sys_truncate64
 	.long sys_ftruncate64
 	.long sys_stat64		/* 195 */
diff -Nur linux-2.6.32-orig/arch/microblaze/kernel/sys_microblaze.c iDroid-Project-kernel_common-9e90fd2/arch/microblaze/kernel/sys_microblaze.c
--- linux-2.6.32-orig/arch/microblaze/kernel/sys_microblaze.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/microblaze/kernel/sys_microblaze.c	2010-11-18 21:05:30.000000000 +0600
@@ -62,46 +62,14 @@
 	return error;
 }
 
-asmlinkage long
-sys_mmap2(unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags,
-	unsigned long fd, unsigned long pgoff)
-{
-	struct file *file = NULL;
-	int ret = -EBADF;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file) {
-			printk(KERN_INFO "no fd in mmap\r\n");
-			goto out;
-		}
-	}
-
-	down_write(&current->mm->mmap_sem);
-	ret = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-	if (file)
-		fput(file);
-out:
-	return ret;
-}
-
 asmlinkage long sys_mmap(unsigned long addr, unsigned long len,
 			unsigned long prot, unsigned long flags,
 			unsigned long fd, off_t pgoff)
 {
-	int err = -EINVAL;
-
-	if (pgoff & ~PAGE_MASK) {
-		printk(KERN_INFO "no pagemask in mmap\r\n");
-		goto out;
-	}
+	if (pgoff & ~PAGE_MASK)
+		return -EINVAL;
 
-	err = sys_mmap2(addr, len, prot, flags, fd, pgoff >> PAGE_SHIFT);
-out:
-	return err;
+	return sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff >> PAGE_SHIFT);
 }
 
 /*
diff -Nur linux-2.6.32-orig/arch/mips/kernel/linux32.c iDroid-Project-kernel_common-9e90fd2/arch/mips/kernel/linux32.c
--- linux-2.6.32-orig/arch/mips/kernel/linux32.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/mips/kernel/linux32.c	2010-11-18 21:05:30.000000000 +0600
@@ -67,28 +67,13 @@
 	unsigned long, prot, unsigned long, flags, unsigned long, fd,
 	unsigned long, pgoff)
 {
-	struct file * file = NULL;
 	unsigned long error;
 
 	error = -EINVAL;
 	if (pgoff & (~PAGE_MASK >> 12))
 		goto out;
-	pgoff >>= PAGE_SHIFT-12;
-
-	if (!(flags & MAP_ANONYMOUS)) {
-		error = -EBADF;
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-	if (file)
-		fput(file);
-
+	error = sys_mmap_pgoff(addr, len, prot, flags, fd,
+			       pgoff >> (PAGE_SHIFT-12));
 out:
 	return error;
 }
diff -Nur linux-2.6.32-orig/arch/mips/kernel/syscall.c iDroid-Project-kernel_common-9e90fd2/arch/mips/kernel/syscall.c
--- linux-2.6.32-orig/arch/mips/kernel/syscall.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/mips/kernel/syscall.c	2010-11-18 21:05:30.000000000 +0600
@@ -93,7 +93,8 @@
 		 * We do not accept a shared mapping if it would violate
 		 * cache aliasing constraints.
 		 */
-		if ((flags & MAP_SHARED) && (addr & shm_align_mask))
+		if ((flags & MAP_SHARED) &&
+		    ((addr - (pgoff << PAGE_SHIFT)) & shm_align_mask))
 			return -EINVAL;
 		return addr;
 	}
@@ -129,31 +130,6 @@
 	}
 }
 
-/* common code for old and new mmaps */
-static inline unsigned long
-do_mmap2(unsigned long addr, unsigned long len, unsigned long prot,
-        unsigned long flags, unsigned long fd, unsigned long pgoff)
-{
-	unsigned long error = -EBADF;
-	struct file * file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:
-	return error;
-}
-
 SYSCALL_DEFINE6(mips_mmap, unsigned long, addr, unsigned long, len,
 	unsigned long, prot, unsigned long, flags, unsigned long,
 	fd, off_t, offset)
@@ -164,7 +140,7 @@
 	if (offset & ~PAGE_MASK)
 		goto out;
 
-	result = do_mmap2(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);
+	result = sys_mmap_pgoff(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);
 
 out:
 	return result;
@@ -177,7 +153,7 @@
 	if (pgoff & (~PAGE_MASK >> 12))
 		return -EINVAL;
 
-	return do_mmap2(addr, len, prot, flags, fd, pgoff >> (PAGE_SHIFT-12));
+	return sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff >> (PAGE_SHIFT-12));
 }
 
 save_static_function(sys_fork);
diff -Nur linux-2.6.32-orig/arch/mn10300/include/asm/mman.h iDroid-Project-kernel_common-9e90fd2/arch/mn10300/include/asm/mman.h
--- linux-2.6.32-orig/arch/mn10300/include/asm/mman.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/mn10300/include/asm/mman.h	2010-11-18 21:05:30.000000000 +0600
@@ -1 +1,6 @@
 #include <asm-generic/mman.h>
+
+#define MIN_MAP_ADDR	PAGE_SIZE	/* minimum fixed mmap address */
+
+#define arch_mmap_check(addr, len, flags) \
+	(((flags) & MAP_FIXED && (addr) < MIN_MAP_ADDR) ? -EINVAL : 0)
diff -Nur linux-2.6.32-orig/arch/mn10300/kernel/entry.S iDroid-Project-kernel_common-9e90fd2/arch/mn10300/kernel/entry.S
--- linux-2.6.32-orig/arch/mn10300/kernel/entry.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/mn10300/kernel/entry.S	2010-11-18 21:05:30.000000000 +0600
@@ -578,7 +578,7 @@
 	.long sys_ni_syscall	/* reserved for streams2 */
 	.long sys_vfork		/* 190 */
 	.long sys_getrlimit
-	.long sys_mmap2
+	.long sys_mmap_pgoff
 	.long sys_truncate64
 	.long sys_ftruncate64
 	.long sys_stat64	/* 195 */
diff -Nur linux-2.6.32-orig/arch/mn10300/kernel/sys_mn10300.c iDroid-Project-kernel_common-9e90fd2/arch/mn10300/kernel/sys_mn10300.c
--- linux-2.6.32-orig/arch/mn10300/kernel/sys_mn10300.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/mn10300/kernel/sys_mn10300.c	2010-11-18 21:05:30.000000000 +0600
@@ -23,47 +23,13 @@
 
 #include <asm/uaccess.h>
 
-#define MIN_MAP_ADDR	PAGE_SIZE	/* minimum fixed mmap address */
-
-/*
- * memory mapping syscall
- */
-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
-			  unsigned long prot, unsigned long flags,
-			  unsigned long fd, unsigned long pgoff)
-{
-	struct file *file = NULL;
-	long error = -EINVAL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-
-	if (flags & MAP_FIXED && addr < MIN_MAP_ADDR)
-		goto out;
-
-	error = -EBADF;
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:
-	return error;
-}
-
 asmlinkage long old_mmap(unsigned long addr, unsigned long len,
 			 unsigned long prot, unsigned long flags,
 			 unsigned long fd, unsigned long offset)
 {
 	if (offset & ~PAGE_MASK)
 		return -EINVAL;
-	return sys_mmap2(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);
+	return sys_mmap_pgoff(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);
 }
 
 struct sel_arg_struct {
diff -Nur linux-2.6.32-orig/arch/parisc/kernel/sys_parisc.c iDroid-Project-kernel_common-9e90fd2/arch/parisc/kernel/sys_parisc.c
--- linux-2.6.32-orig/arch/parisc/kernel/sys_parisc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/parisc/kernel/sys_parisc.c	2010-11-18 21:05:30.000000000 +0600
@@ -110,37 +110,14 @@
 	return addr;
 }
 
-static unsigned long do_mmap2(unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags, unsigned long fd,
-	unsigned long pgoff)
-{
-	struct file * file = NULL;
-	unsigned long error = -EBADF;
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file != NULL)
-		fput(file);
-out:
-	return error;
-}
-
 asmlinkage unsigned long sys_mmap2(unsigned long addr, unsigned long len,
 	unsigned long prot, unsigned long flags, unsigned long fd,
 	unsigned long pgoff)
 {
 	/* Make sure the shift for mmap2 is constant (12), no matter what PAGE_SIZE
 	   we have. */
-	return do_mmap2(addr, len, prot, flags, fd, pgoff >> (PAGE_SHIFT - 12));
+	return sys_mmap_pgoff(addr, len, prot, flags, fd,
+			      pgoff >> (PAGE_SHIFT - 12));
 }
 
 asmlinkage unsigned long sys_mmap(unsigned long addr, unsigned long len,
@@ -148,7 +125,8 @@
 		unsigned long offset)
 {
 	if (!(offset & ~PAGE_MASK)) {
-		return do_mmap2(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);
+		return sys_mmap_pgoff(addr, len, prot, flags, fd,
+					offset >> PAGE_SHIFT);
 	} else {
 		return -EINVAL;
 	}
diff -Nur linux-2.6.32-orig/arch/powerpc/include/asm/elf.h iDroid-Project-kernel_common-9e90fd2/arch/powerpc/include/asm/elf.h
--- linux-2.6.32-orig/arch/powerpc/include/asm/elf.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/powerpc/include/asm/elf.h	2010-11-18 21:05:30.000000000 +0600
@@ -236,14 +236,10 @@
 #ifdef __powerpc64__
 # define SET_PERSONALITY(ex)					\
 do {								\
-	unsigned long new_flags = 0;				\
 	if ((ex).e_ident[EI_CLASS] == ELFCLASS32)		\
-		new_flags = _TIF_32BIT;				\
-	if ((current_thread_info()->flags & _TIF_32BIT)		\
-	    != new_flags)					\
-		set_thread_flag(TIF_ABI_PENDING);		\
+		set_thread_flag(TIF_32BIT);			\
 	else							\
-		clear_thread_flag(TIF_ABI_PENDING);		\
+		clear_thread_flag(TIF_32BIT);			\
 	if (personality(current->personality) != PER_LINUX32)	\
 		set_personality(PER_LINUX |			\
 			(current->personality & (~PER_MASK)));	\
diff -Nur linux-2.6.32-orig/arch/powerpc/include/asm/module.h iDroid-Project-kernel_common-9e90fd2/arch/powerpc/include/asm/module.h
--- linux-2.6.32-orig/arch/powerpc/include/asm/module.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/powerpc/include/asm/module.h	2010-11-18 21:05:30.000000000 +0600
@@ -87,5 +87,10 @@
 void sort_ex_table(struct exception_table_entry *start,
 		   struct exception_table_entry *finish);
 
+#ifdef CONFIG_MODVERSIONS
+#define ARCH_RELOCATES_KCRCTAB
+
+extern const unsigned long reloc_start[];
+#endif
 #endif /* __KERNEL__ */
 #endif	/* _ASM_POWERPC_MODULE_H */
diff -Nur linux-2.6.32-orig/arch/powerpc/include/asm/thread_info.h iDroid-Project-kernel_common-9e90fd2/arch/powerpc/include/asm/thread_info.h
--- linux-2.6.32-orig/arch/powerpc/include/asm/thread_info.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/powerpc/include/asm/thread_info.h	2010-11-18 21:05:30.000000000 +0600
@@ -111,7 +111,6 @@
 #define TIF_NOTIFY_RESUME	13	/* callback before returning to user */
 #define TIF_FREEZE		14	/* Freezing for suspend */
 #define TIF_RUNLATCH		15	/* Is the runlatch enabled? */
-#define TIF_ABI_PENDING		16	/* 32/64 bit switch needed */
 
 /* as above, but as bit values */
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
@@ -129,7 +128,6 @@
 #define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
 #define _TIF_FREEZE		(1<<TIF_FREEZE)
 #define _TIF_RUNLATCH		(1<<TIF_RUNLATCH)
-#define _TIF_ABI_PENDING	(1<<TIF_ABI_PENDING)
 #define _TIF_SYSCALL_T_OR_A	(_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT|_TIF_SECCOMP)
 
 #define _TIF_USER_WORK_MASK	(_TIF_SIGPENDING | _TIF_NEED_RESCHED | \
diff -Nur linux-2.6.32-orig/arch/powerpc/kernel/align.c iDroid-Project-kernel_common-9e90fd2/arch/powerpc/kernel/align.c
--- linux-2.6.32-orig/arch/powerpc/kernel/align.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/powerpc/kernel/align.c	2010-11-18 21:05:30.000000000 +0600
@@ -642,10 +642,14 @@
  */
 static int emulate_vsx(unsigned char __user *addr, unsigned int reg,
 		       unsigned int areg, struct pt_regs *regs,
-		       unsigned int flags, unsigned int length)
+		       unsigned int flags, unsigned int length,
+		       unsigned int elsize)
 {
 	char *ptr;
+	unsigned long *lptr;
 	int ret = 0;
+	int sw = 0;
+	int i, j;
 
 	flush_vsx_to_thread(current);
 
@@ -654,19 +658,35 @@
 	else
 		ptr = (char *) &current->thread.vr[reg - 32];
 
-	if (flags & ST)
-		ret = __copy_to_user(addr, ptr, length);
-        else {
-		if (flags & SPLT){
-			ret = __copy_from_user(ptr, addr, length);
-			ptr += length;
+	lptr = (unsigned long *) ptr;
+
+	if (flags & SW)
+		sw = elsize-1;
+
+	for (j = 0; j < length; j += elsize) {
+		for (i = 0; i < elsize; ++i) {
+			if (flags & ST)
+				ret |= __put_user(ptr[i^sw], addr + i);
+			else
+				ret |= __get_user(ptr[i^sw], addr + i);
 		}
-		ret |= __copy_from_user(ptr, addr, length);
+		ptr  += elsize;
+		addr += elsize;
 	}
-	if (flags & U)
-		regs->gpr[areg] = regs->dar;
-	if (ret)
+
+	if (!ret) {
+		if (flags & U)
+			regs->gpr[areg] = regs->dar;
+
+		/* Splat load copies the same data to top and bottom 8 bytes */
+		if (flags & SPLT)
+			lptr[1] = lptr[0];
+		/* For 8 byte loads, zero the top 8 bytes */
+		else if (!(flags & ST) && (8 == length))
+			lptr[1] = 0;
+	} else
 		return -EFAULT;
+
 	return 1;
 }
 #endif
@@ -767,16 +787,25 @@
 
 #ifdef CONFIG_VSX
 	if ((instruction & 0xfc00003e) == 0x7c000018) {
-		/* Additional register addressing bit (64 VSX vs 32 FPR/GPR */
+		unsigned int elsize;
+
+		/* Additional register addressing bit (64 VSX vs 32 FPR/GPR) */
 		reg |= (instruction & 0x1) << 5;
 		/* Simple inline decoder instead of a table */
+		/* VSX has only 8 and 16 byte memory accesses */
+		nb = 8;
 		if (instruction & 0x200)
 			nb = 16;
-		else if (instruction & 0x080)
-			nb = 8;
-		else
-			nb = 4;
+
+		/* Vector stores in little-endian mode swap individual
+		   elements, so process them separately */
+		elsize = 4;
+		if (instruction & 0x80)
+			elsize = 8;
+
 		flags = 0;
+		if (regs->msr & MSR_LE)
+			flags |= SW;
 		if (instruction & 0x100)
 			flags |= ST;
 		if (instruction & 0x040)
@@ -787,7 +816,7 @@
 			nb = 8;
 		}
 		PPC_WARN_EMULATED(vsx);
-		return emulate_vsx(addr, reg, areg, regs, flags, nb);
+		return emulate_vsx(addr, reg, areg, regs, flags, nb, elsize);
 	}
 #endif
 	/* A size of 0 indicates an instruction we don't support, with
diff -Nur linux-2.6.32-orig/arch/powerpc/kernel/pci-common.c iDroid-Project-kernel_common-9e90fd2/arch/powerpc/kernel/pci-common.c
--- linux-2.6.32-orig/arch/powerpc/kernel/pci-common.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/powerpc/kernel/pci-common.c	2010-11-18 21:05:30.000000000 +0600
@@ -1107,6 +1107,12 @@
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		struct dev_archdata *sd = &dev->dev.archdata;
 
+		/* Cardbus can call us to add new devices to a bus, so ignore
+		 * those who are already fully discovered
+		 */
+		if (dev->is_added)
+			continue;
+
 		/* Setup OF node pointer in archdata */
 		sd->of_node = pci_device_to_OF_node(dev);
 
@@ -1147,6 +1153,13 @@
 }
 EXPORT_SYMBOL(pcibios_fixup_bus);
 
+void __devinit pci_fixup_cardbus(struct pci_bus *bus)
+{
+	/* Now fixup devices on that bus */
+	pcibios_setup_bus_devices(bus);
+}
+
+
 static int skip_isa_ioresource_align(struct pci_dev *dev)
 {
 	if ((ppc_pci_flags & PPC_PCI_CAN_SKIP_ISA_ALIGN) &&
diff -Nur linux-2.6.32-orig/arch/powerpc/kernel/process.c iDroid-Project-kernel_common-9e90fd2/arch/powerpc/kernel/process.c
--- linux-2.6.32-orig/arch/powerpc/kernel/process.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/powerpc/kernel/process.c	2010-11-18 21:05:30.000000000 +0600
@@ -554,18 +554,6 @@
 
 void flush_thread(void)
 {
-#ifdef CONFIG_PPC64
-	struct thread_info *t = current_thread_info();
-
-	if (test_ti_thread_flag(t, TIF_ABI_PENDING)) {
-		clear_ti_thread_flag(t, TIF_ABI_PENDING);
-		if (test_ti_thread_flag(t, TIF_32BIT))
-			clear_ti_thread_flag(t, TIF_32BIT);
-		else
-			set_ti_thread_flag(t, TIF_32BIT);
-	}
-#endif
-
 	discard_lazy_cpu_state();
 
 	if (current->thread.dabr) {
diff -Nur linux-2.6.32-orig/arch/powerpc/kernel/syscalls.c iDroid-Project-kernel_common-9e90fd2/arch/powerpc/kernel/syscalls.c
--- linux-2.6.32-orig/arch/powerpc/kernel/syscalls.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/powerpc/kernel/syscalls.c	2010-11-18 21:05:30.000000000 +0600
@@ -140,7 +140,6 @@
 			unsigned long prot, unsigned long flags,
 			unsigned long fd, unsigned long off, int shift)
 {
-	struct file * file = NULL;
 	unsigned long ret = -EINVAL;
 
 	if (!arch_validate_prot(prot))
@@ -151,20 +150,8 @@
 			goto out;
 		off >>= shift;
 	}
-		
-	ret = -EBADF;
-	if (!(flags & MAP_ANONYMOUS)) {
-		if (!(file = fget(fd)))
-			goto out;
-	}
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 
-	down_write(&current->mm->mmap_sem);
-	ret = do_mmap_pgoff(file, addr, len, prot, flags, off);
-	up_write(&current->mm->mmap_sem);
-	if (file)
-		fput(file);
+	ret = sys_mmap_pgoff(addr, len, prot, flags, fd, off);
 out:
 	return ret;
 }
diff -Nur linux-2.6.32-orig/arch/powerpc/kernel/vector.S iDroid-Project-kernel_common-9e90fd2/arch/powerpc/kernel/vector.S
--- linux-2.6.32-orig/arch/powerpc/kernel/vector.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/powerpc/kernel/vector.S	2010-11-18 21:05:30.000000000 +0600
@@ -58,7 +58,7 @@
 	 * all 1's
 	 */
 	mfspr	r4,SPRN_VRSAVE
-	cmpdi	0,r4,0
+	cmpwi	0,r4,0
 	bne+	1f
 	li	r4,-1
 	mtspr	SPRN_VRSAVE,r4
diff -Nur linux-2.6.32-orig/arch/powerpc/kernel/vmlinux.lds.S iDroid-Project-kernel_common-9e90fd2/arch/powerpc/kernel/vmlinux.lds.S
--- linux-2.6.32-orig/arch/powerpc/kernel/vmlinux.lds.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/powerpc/kernel/vmlinux.lds.S	2010-11-18 21:05:30.000000000 +0600
@@ -38,6 +38,9 @@
 #endif
 SECTIONS
 {
+	. = 0;
+	reloc_start = .;
+
 	. = KERNELBASE;
 
 /*
diff -Nur linux-2.6.32-orig/arch/powerpc/sysdev/fsl_pci.c iDroid-Project-kernel_common-9e90fd2/arch/powerpc/sysdev/fsl_pci.c
--- linux-2.6.32-orig/arch/powerpc/sysdev/fsl_pci.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/powerpc/sysdev/fsl_pci.c	2010-11-18 21:05:30.000000000 +0600
@@ -392,8 +392,22 @@
 DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_MPC8641, quirk_fsl_pcie_header);
 DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_MPC8641D, quirk_fsl_pcie_header);
 DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_MPC8610, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P1011E, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P1011, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P1013E, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P1013, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P1020E, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P1020, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P1022E, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P1022, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P2010E, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P2010, quirk_fsl_pcie_header);
 DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P2020E, quirk_fsl_pcie_header);
 DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P2020, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P4040E, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P4040, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P4080E, quirk_fsl_pcie_header);
+DECLARE_PCI_FIXUP_HEADER(0x1957, PCI_DEVICE_ID_P4080, quirk_fsl_pcie_header);
 #endif /* CONFIG_PPC_85xx || CONFIG_PPC_86xx */
 
 #if defined(CONFIG_PPC_83xx) || defined(CONFIG_PPC_MPC512x)
diff -Nur linux-2.6.32-orig/arch/s390/include/asm/kvm.h iDroid-Project-kernel_common-9e90fd2/arch/s390/include/asm/kvm.h
--- linux-2.6.32-orig/arch/s390/include/asm/kvm.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/s390/include/asm/kvm.h	2010-11-18 21:05:30.000000000 +0600
@@ -1,6 +1,5 @@
 #ifndef __LINUX_KVM_S390_H
 #define __LINUX_KVM_S390_H
-
 /*
  * asm-s390/kvm.h - KVM s390 specific structures and definitions
  *
@@ -15,6 +14,8 @@
  */
 #include <linux/types.h>
 
+#define __KVM_S390
+
 /* for KVM_GET_REGS and KVM_SET_REGS */
 struct kvm_regs {
 	/* general purpose regs for s390 */
diff -Nur linux-2.6.32-orig/arch/s390/kernel/compat_linux.c iDroid-Project-kernel_common-9e90fd2/arch/s390/kernel/compat_linux.c
--- linux-2.6.32-orig/arch/s390/kernel/compat_linux.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/s390/kernel/compat_linux.c	2010-11-18 21:05:30.000000000 +0600
@@ -683,38 +683,6 @@
 	u32	offset;
 };
 
-/* common code for old and new mmaps */
-static inline long do_mmap2(
-	unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags,
-	unsigned long fd, unsigned long pgoff)
-{
-	struct file * file = NULL;
-	unsigned long error = -EBADF;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	if (!IS_ERR((void *) error) && error + len >= 0x80000000ULL) {
-		/* Result is out of bounds.  */
-		do_munmap(current->mm, addr, len);
-		error = -ENOMEM;
-	}
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:    
-	return error;
-}
-
-
 asmlinkage unsigned long
 old32_mmap(struct mmap_arg_struct_emu31 __user *arg)
 {
@@ -728,7 +696,8 @@
 	if (a.offset & ~PAGE_MASK)
 		goto out;
 
-	error = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT); 
+	error = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,
+			       a.offset >> PAGE_SHIFT);
 out:
 	return error;
 }
@@ -741,7 +710,7 @@
 
 	if (copy_from_user(&a, arg, sizeof(a)))
 		goto out;
-	error = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset);
+	error = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd, a.offset);
 out:
 	return error;
 }
diff -Nur linux-2.6.32-orig/arch/s390/kernel/entry64.S iDroid-Project-kernel_common-9e90fd2/arch/s390/kernel/entry64.S
--- linux-2.6.32-orig/arch/s390/kernel/entry64.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/s390/kernel/entry64.S	2010-11-18 21:05:30.000000000 +0600
@@ -549,6 +549,7 @@
 	mvc	__THREAD_per+__PER_access_id(1,%r8),__LC_PER_ACCESS_ID
 	oi	__TI_flags+7(%r9),_TIF_SINGLE_STEP # set TIF_SINGLE_STEP
 	TRACE_IRQS_ON
+	lmg	%r2,%r6,SP_R2(%r15)	# load svc arguments
 	stosm	__SF_EMPTY(%r15),0x03	# reenable interrupts
 	j	sysc_do_svc
 
diff -Nur linux-2.6.32-orig/arch/s390/kernel/entry.S iDroid-Project-kernel_common-9e90fd2/arch/s390/kernel/entry.S
--- linux-2.6.32-orig/arch/s390/kernel/entry.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/s390/kernel/entry.S	2010-11-18 21:05:30.000000000 +0600
@@ -571,6 +571,7 @@
 	mvc	__THREAD_per+__PER_access_id(1,%r8),__LC_PER_ACCESS_ID
 	oi	__TI_flags+3(%r9),_TIF_SINGLE_STEP # set TIF_SINGLE_STEP
 	TRACE_IRQS_ON
+	lm	%r2,%r6,SP_R2(%r15)	# load svc arguments
 	stosm	__SF_EMPTY(%r15),0x03	# reenable interrupts
 	b	BASED(sysc_do_svc)
 
diff -Nur linux-2.6.32-orig/arch/s390/kernel/head64.S iDroid-Project-kernel_common-9e90fd2/arch/s390/kernel/head64.S
--- linux-2.6.32-orig/arch/s390/kernel/head64.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/s390/kernel/head64.S	2010-11-18 21:05:30.000000000 +0600
@@ -83,6 +83,8 @@
 	slr	%r0,%r0 		# set cpuid to zero
 	sigp	%r1,%r0,0x12		# switch to esame mode
 	sam64				# switch to 64 bit mode
+	llgfr	%r13,%r13		# clear high-order half of base reg
+	lmh	%r0,%r15,.Lzero64-.LPG1(%r13)	# clear high-order half
 	lctlg	%c0,%c15,.Lctl-.LPG1(%r13)	# load control registers
 	lg	%r12,.Lparmaddr-.LPG1(%r13)	# pointer to parameter area
 					# move IPL device to lowcore
@@ -127,6 +129,7 @@
 .L4malign:.quad 0xffffffffffc00000
 .Lscan2g:.quad	0x80000000 + 0x20000 - 8	# 2GB + 128K - 8
 .Lnop:	.long	0x07000700
+.Lzero64:.fill	16,4,0x0
 #ifdef CONFIG_ZFCPDUMP
 .Lcurrent_cpu:
 	.long 0x0
diff -Nur linux-2.6.32-orig/arch/s390/kernel/sys_s390.c iDroid-Project-kernel_common-9e90fd2/arch/s390/kernel/sys_s390.c
--- linux-2.6.32-orig/arch/s390/kernel/sys_s390.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/s390/kernel/sys_s390.c	2010-11-18 21:05:30.000000000 +0600
@@ -32,32 +32,6 @@
 #include <asm/uaccess.h>
 #include "entry.h"
 
-/* common code for old and new mmaps */
-static inline long do_mmap2(
-	unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags,
-	unsigned long fd, unsigned long pgoff)
-{
-	long error = -EBADF;
-	struct file * file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:
-	return error;
-}
-
 /*
  * Perform the select(nd, in, out, ex, tv) and mmap() system
  * calls. Linux for S/390 isn't able to handle more than 5
@@ -81,7 +55,7 @@
 
 	if (copy_from_user(&a, arg, sizeof(a)))
 		goto out;
-	error = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset);
+	error = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd, a.offset);
 out:
 	return error;
 }
@@ -98,7 +72,7 @@
 	if (a.offset & ~PAGE_MASK)
 		goto out;
 
-	error = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);
+	error = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);
 out:
 	return error;
 }
diff -Nur linux-2.6.32-orig/arch/s390/kvm/intercept.c iDroid-Project-kernel_common-9e90fd2/arch/s390/kvm/intercept.c
--- linux-2.6.32-orig/arch/s390/kvm/intercept.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/s390/kvm/intercept.c	2010-11-18 21:05:30.000000000 +0600
@@ -213,7 +213,7 @@
 	return rc2;
 }
 
-static const intercept_handler_t intercept_funcs[0x48 >> 2] = {
+static const intercept_handler_t intercept_funcs[] = {
 	[0x00 >> 2] = handle_noop,
 	[0x04 >> 2] = handle_instruction,
 	[0x08 >> 2] = handle_prog,
@@ -230,7 +230,7 @@
 	intercept_handler_t func;
 	u8 code = vcpu->arch.sie_block->icptcode;
 
-	if (code & 3 || code > 0x48)
+	if (code & 3 || (code >> 2) >= ARRAY_SIZE(intercept_funcs))
 		return -ENOTSUPP;
 	func = intercept_funcs[code >> 2];
 	if (func)
diff -Nur linux-2.6.32-orig/arch/s390/kvm/kvm-s390.c iDroid-Project-kernel_common-9e90fd2/arch/s390/kvm/kvm-s390.c
--- linux-2.6.32-orig/arch/s390/kvm/kvm-s390.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/s390/kvm/kvm-s390.c	2010-11-18 21:05:30.000000000 +0600
@@ -116,10 +116,16 @@
 
 int kvm_dev_ioctl_check_extension(long ext)
 {
+	int r;
+
 	switch (ext) {
+	case KVM_CAP_S390_PSW:
+		r = 1;
+		break;
 	default:
-		return 0;
+		r = 0;
 	}
+	return r;
 }
 
 /* Section: vm related */
@@ -419,8 +425,10 @@
 	vcpu_load(vcpu);
 	if (atomic_read(&vcpu->arch.sie_block->cpuflags) & CPUSTAT_RUNNING)
 		rc = -EBUSY;
-	else
-		vcpu->arch.sie_block->gpsw = psw;
+	else {
+		vcpu->run->psw_mask = psw.mask;
+		vcpu->run->psw_addr = psw.addr;
+	}
 	vcpu_put(vcpu);
 	return rc;
 }
@@ -508,9 +516,6 @@
 
 	switch (kvm_run->exit_reason) {
 	case KVM_EXIT_S390_SIEIC:
-		vcpu->arch.sie_block->gpsw.mask = kvm_run->s390_sieic.mask;
-		vcpu->arch.sie_block->gpsw.addr = kvm_run->s390_sieic.addr;
-		break;
 	case KVM_EXIT_UNKNOWN:
 	case KVM_EXIT_INTR:
 	case KVM_EXIT_S390_RESET:
@@ -519,6 +524,9 @@
 		BUG();
 	}
 
+	vcpu->arch.sie_block->gpsw.mask = kvm_run->psw_mask;
+	vcpu->arch.sie_block->gpsw.addr = kvm_run->psw_addr;
+
 	might_fault();
 
 	do {
@@ -538,8 +546,6 @@
 		/* intercept cannot be handled in-kernel, prepare kvm-run */
 		kvm_run->exit_reason         = KVM_EXIT_S390_SIEIC;
 		kvm_run->s390_sieic.icptcode = vcpu->arch.sie_block->icptcode;
-		kvm_run->s390_sieic.mask     = vcpu->arch.sie_block->gpsw.mask;
-		kvm_run->s390_sieic.addr     = vcpu->arch.sie_block->gpsw.addr;
 		kvm_run->s390_sieic.ipa      = vcpu->arch.sie_block->ipa;
 		kvm_run->s390_sieic.ipb      = vcpu->arch.sie_block->ipb;
 		rc = 0;
@@ -551,6 +557,9 @@
 		rc = 0;
 	}
 
+	kvm_run->psw_mask     = vcpu->arch.sie_block->gpsw.mask;
+	kvm_run->psw_addr     = vcpu->arch.sie_block->gpsw.addr;
+
 	if (vcpu->sigset_active)
 		sigprocmask(SIG_SETMASK, &sigsaved, NULL);
 
diff -Nur linux-2.6.32-orig/arch/s390/kvm/sigp.c iDroid-Project-kernel_common-9e90fd2/arch/s390/kvm/sigp.c
--- linux-2.6.32-orig/arch/s390/kvm/sigp.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/s390/kvm/sigp.c	2010-11-18 21:05:30.000000000 +0600
@@ -188,9 +188,9 @@
 
 	/* make sure that the new value is valid memory */
 	address = address & 0x7fffe000u;
-	if ((copy_from_guest(vcpu, &tmp,
-		(u64) (address + vcpu->arch.sie_block->gmsor) , 1)) ||
-	   (copy_from_guest(vcpu, &tmp, (u64) (address +
+	if ((copy_from_user(&tmp, (void __user *)
+		(address + vcpu->arch.sie_block->gmsor) , 1)) ||
+	   (copy_from_user(&tmp, (void __user *)(address +
 			vcpu->arch.sie_block->gmsor + PAGE_SIZE), 1))) {
 		*reg |= SIGP_STAT_INVALID_PARAMETER;
 		return 1; /* invalid parameter */
diff -Nur linux-2.6.32-orig/arch/score/kernel/sys_score.c iDroid-Project-kernel_common-9e90fd2/arch/score/kernel/sys_score.c
--- linux-2.6.32-orig/arch/score/kernel/sys_score.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/score/kernel/sys_score.c	2010-11-18 21:05:30.000000000 +0600
@@ -36,34 +36,16 @@
 sys_mmap2(unsigned long addr, unsigned long len, unsigned long prot,
 	  unsigned long flags, unsigned long fd, unsigned long pgoff)
 {
-	int error = -EBADF;
-	struct file *file = NULL;
-
-	if (pgoff & (~PAGE_MASK >> 12))
-		return -EINVAL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			return error;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-
-	return error;
+	return sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);
 }
 
 asmlinkage long
 sys_mmap(unsigned long addr, unsigned long len, unsigned long prot,
-	unsigned long flags, unsigned long fd, off_t pgoff)
+	unsigned long flags, unsigned long fd, off_t offset)
 {
-	return sys_mmap2(addr, len, prot, flags, fd, pgoff >> PAGE_SHIFT);
+	if (unlikely(offset & ~PAGE_MASK))
+		return -EINVAL;
+	return sys_mmap_pgoff(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);
 }
 
 asmlinkage long
diff -Nur linux-2.6.32-orig/arch/sh/include/asm/pgtable_32.h iDroid-Project-kernel_common-9e90fd2/arch/sh/include/asm/pgtable_32.h
--- linux-2.6.32-orig/arch/sh/include/asm/pgtable_32.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sh/include/asm/pgtable_32.h	2010-11-18 21:05:30.000000000 +0600
@@ -344,7 +344,8 @@
 #define pte_special(pte)	((pte).pte_low & _PAGE_SPECIAL)
 
 #ifdef CONFIG_X2TLB
-#define pte_write(pte)		((pte).pte_high & _PAGE_EXT_USER_WRITE)
+#define pte_write(pte) \
+	((pte).pte_high & (_PAGE_EXT_USER_WRITE | _PAGE_EXT_KERN_WRITE))
 #else
 #define pte_write(pte)		((pte).pte_low & _PAGE_RW)
 #endif
@@ -358,7 +359,7 @@
  * individually toggled (and user permissions are entirely decoupled from
  * kernel permissions), we attempt to couple them a bit more sanely here.
  */
-PTE_BIT_FUNC(high, wrprotect, &= ~_PAGE_EXT_USER_WRITE);
+PTE_BIT_FUNC(high, wrprotect, &= ~(_PAGE_EXT_USER_WRITE | _PAGE_EXT_KERN_WRITE));
 PTE_BIT_FUNC(high, mkwrite, |= _PAGE_EXT_USER_WRITE | _PAGE_EXT_KERN_WRITE);
 PTE_BIT_FUNC(high, mkhuge, |= _PAGE_SZHUGE);
 #else
diff -Nur linux-2.6.32-orig/arch/sh/kernel/process_64.c iDroid-Project-kernel_common-9e90fd2/arch/sh/kernel/process_64.c
--- linux-2.6.32-orig/arch/sh/kernel/process_64.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sh/kernel/process_64.c	2010-11-18 21:05:30.000000000 +0600
@@ -367,7 +367,7 @@
 void flush_thread(void)
 {
 
-	/* Called by fs/exec.c (flush_old_exec) to remove traces of a
+	/* Called by fs/exec.c (setup_new_exec) to remove traces of a
 	 * previously running executable. */
 #ifdef CONFIG_SH_FPU
 	if (last_task_used_math == current) {
diff -Nur linux-2.6.32-orig/arch/sh/kernel/sys_sh.c iDroid-Project-kernel_common-9e90fd2/arch/sh/kernel/sys_sh.c
--- linux-2.6.32-orig/arch/sh/kernel/sys_sh.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sh/kernel/sys_sh.c	2010-11-18 21:05:30.000000000 +0600
@@ -28,37 +28,13 @@
 #include <asm/cacheflush.h>
 #include <asm/cachectl.h>
 
-static inline long
-do_mmap2(unsigned long addr, unsigned long len, unsigned long prot,
-	 unsigned long flags, int fd, unsigned long pgoff)
-{
-	int error = -EBADF;
-	struct file *file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:
-	return error;
-}
-
 asmlinkage int old_mmap(unsigned long addr, unsigned long len,
 	unsigned long prot, unsigned long flags,
 	int fd, unsigned long off)
 {
 	if (off & ~PAGE_MASK)
 		return -EINVAL;
-	return do_mmap2(addr, len, prot, flags, fd, off>>PAGE_SHIFT);
+	return sys_mmap_pgoff(addr, len, prot, flags, fd, off>>PAGE_SHIFT);
 }
 
 asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
@@ -74,7 +50,7 @@
 
 	pgoff >>= PAGE_SHIFT - 12;
 
-	return do_mmap2(addr, len, prot, flags, fd, pgoff);
+	return sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);
 }
 
 /*
diff -Nur linux-2.6.32-orig/arch/sh/mm/mmap.c iDroid-Project-kernel_common-9e90fd2/arch/sh/mm/mmap.c
--- linux-2.6.32-orig/arch/sh/mm/mmap.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sh/mm/mmap.c	2010-11-18 21:05:30.000000000 +0600
@@ -54,7 +54,8 @@
 		/* We do not accept a shared mapping if it would violate
 		 * cache aliasing constraints.
 		 */
-		if ((flags & MAP_SHARED) && (addr & shm_align_mask))
+		if ((flags & MAP_SHARED) &&
+		    ((addr - (pgoff << PAGE_SHIFT)) & shm_align_mask))
 			return -EINVAL;
 		return addr;
 	}
diff -Nur linux-2.6.32-orig/arch/sparc/include/asm/elf_64.h iDroid-Project-kernel_common-9e90fd2/arch/sparc/include/asm/elf_64.h
--- linux-2.6.32-orig/arch/sparc/include/asm/elf_64.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/include/asm/elf_64.h	2010-11-18 21:05:30.000000000 +0600
@@ -196,17 +196,10 @@
 #define ELF_PLATFORM	(NULL)
 
 #define SET_PERSONALITY(ex)				\
-do {	unsigned long new_flags = current_thread_info()->flags; \
-	new_flags &= _TIF_32BIT;			\
-	if ((ex).e_ident[EI_CLASS] == ELFCLASS32)	\
-		new_flags |= _TIF_32BIT;		\
+do {	if ((ex).e_ident[EI_CLASS] == ELFCLASS32)	\
+		set_thread_flag(TIF_32BIT);		\
 	else						\
-		new_flags &= ~_TIF_32BIT;		\
-	if ((current_thread_info()->flags & _TIF_32BIT) \
-	    != new_flags)				\
-		set_thread_flag(TIF_ABI_PENDING);	\
-	else						\
-		clear_thread_flag(TIF_ABI_PENDING);	\
+		clear_thread_flag(TIF_32BIT);		\
 	/* flush_thread will update pgd cache */	\
 	if (personality(current->personality) != PER_LINUX32)	\
 		set_personality(PER_LINUX |		\
diff -Nur linux-2.6.32-orig/arch/sparc/include/asm/thread_info_64.h iDroid-Project-kernel_common-9e90fd2/arch/sparc/include/asm/thread_info_64.h
--- linux-2.6.32-orig/arch/sparc/include/asm/thread_info_64.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/include/asm/thread_info_64.h	2010-11-18 21:05:30.000000000 +0600
@@ -227,12 +227,11 @@
 /* flag bit 8 is available */
 #define TIF_SECCOMP		9	/* secure computing */
 #define TIF_SYSCALL_AUDIT	10	/* syscall auditing active */
-/* flag bit 11 is available */
 /* NOTE: Thread flags >= 12 should be ones we have no interest
  *       in using in assembly, else we can't use the mask as
  *       an immediate value in instructions such as andcc.
  */
-#define TIF_ABI_PENDING		12
+/* flag bit 12 is available */
 #define TIF_MEMDIE		13
 #define TIF_POLLING_NRFLAG	14
 #define TIF_FREEZE		15	/* is freezing for suspend */
@@ -246,7 +245,6 @@
 #define _TIF_32BIT		(1<<TIF_32BIT)
 #define _TIF_SECCOMP		(1<<TIF_SECCOMP)
 #define _TIF_SYSCALL_AUDIT	(1<<TIF_SYSCALL_AUDIT)
-#define _TIF_ABI_PENDING	(1<<TIF_ABI_PENDING)
 #define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
 #define _TIF_FREEZE		(1<<TIF_FREEZE)
 
diff -Nur linux-2.6.32-orig/arch/sparc/kernel/ldc.c iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/ldc.c
--- linux-2.6.32-orig/arch/sparc/kernel/ldc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/ldc.c	2010-11-18 21:05:30.000000000 +0600
@@ -1242,13 +1242,13 @@
 	snprintf(lp->tx_irq_name, LDC_IRQ_NAME_MAX, "%s TX", name);
 
 	err = request_irq(lp->cfg.rx_irq, ldc_rx,
-			  IRQF_SAMPLE_RANDOM | IRQF_DISABLED | IRQF_SHARED,
+			  IRQF_SAMPLE_RANDOM | IRQF_DISABLED,
 			  lp->rx_irq_name, lp);
 	if (err)
 		return err;
 
 	err = request_irq(lp->cfg.tx_irq, ldc_tx,
-			  IRQF_SAMPLE_RANDOM | IRQF_DISABLED | IRQF_SHARED,
+			  IRQF_SAMPLE_RANDOM | IRQF_DISABLED,
 			  lp->tx_irq_name, lp);
 	if (err) {
 		free_irq(lp->cfg.rx_irq, lp);
diff -Nur linux-2.6.32-orig/arch/sparc/kernel/nmi.c iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/nmi.c
--- linux-2.6.32-orig/arch/sparc/kernel/nmi.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/nmi.c	2010-11-18 21:05:30.000000000 +0600
@@ -96,7 +96,6 @@
 	int cpu = smp_processor_id();
 
 	clear_softint(1 << irq);
-	pcr_ops->write(PCR_PIC_PRIV);
 
 	local_cpu_data().__nmi_count++;
 
@@ -105,6 +104,8 @@
 	if (notify_die(DIE_NMI, "nmi", regs, 0,
 		       pt_regs_trap_type(regs), SIGINT) == NOTIFY_STOP)
 		touched = 1;
+	else
+		pcr_ops->write(PCR_PIC_PRIV);
 
 	sum = kstat_irqs_cpu(0, cpu);
 	if (__get_cpu_var(nmi_touch)) {
diff -Nur linux-2.6.32-orig/arch/sparc/kernel/of_device_64.c iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/of_device_64.c
--- linux-2.6.32-orig/arch/sparc/kernel/of_device_64.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/of_device_64.c	2010-11-18 21:05:30.000000000 +0600
@@ -104,9 +104,19 @@
 	int i;
 
 	/* Check address type match */
-	if ((addr[0] ^ range[0]) & 0x03000000)
-		return -EINVAL;
+	if (!((addr[0] ^ range[0]) & 0x03000000))
+		goto type_match;
+
+	/* Special exception, we can map a 64-bit address into
+	 * a 32-bit range.
+	 */
+	if ((addr[0] & 0x03000000) == 0x03000000 &&
+	    (range[0] & 0x03000000) == 0x02000000)
+		goto type_match;
+
+	return -EINVAL;
 
+type_match:
 	if (of_out_of_range(addr + 1, range + 1, range + na + pna,
 			    na - 1, ns))
 		return -EINVAL;
diff -Nur linux-2.6.32-orig/arch/sparc/kernel/perf_event.c iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/perf_event.c
--- linux-2.6.32-orig/arch/sparc/kernel/perf_event.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/perf_event.c	2010-11-18 21:05:30.000000000 +0600
@@ -986,6 +986,17 @@
 	data.addr = 0;
 
 	cpuc = &__get_cpu_var(cpu_hw_events);
+
+	/* If the PMU has the TOE IRQ enable bits, we need to do a
+	 * dummy write to the %pcr to clear the overflow bits and thus
+	 * the interrupt.
+	 *
+	 * Do this before we peek at the counters to determine
+	 * overflow so we don't lose any events.
+	 */
+	if (sparc_pmu->irq_bit)
+		pcr_ops->write(cpuc->pcr);
+
 	for (idx = 0; idx < MAX_HWEVENTS; idx++) {
 		struct perf_event *event = cpuc->events[idx];
 		struct hw_perf_event *hwc;
diff -Nur linux-2.6.32-orig/arch/sparc/kernel/process_64.c iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/process_64.c
--- linux-2.6.32-orig/arch/sparc/kernel/process_64.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/process_64.c	2010-11-18 21:05:30.000000000 +0600
@@ -365,14 +365,6 @@
 	struct thread_info *t = current_thread_info();
 	struct mm_struct *mm;
 
-	if (test_ti_thread_flag(t, TIF_ABI_PENDING)) {
-		clear_ti_thread_flag(t, TIF_ABI_PENDING);
-		if (test_ti_thread_flag(t, TIF_32BIT))
-			clear_ti_thread_flag(t, TIF_32BIT);
-		else
-			set_ti_thread_flag(t, TIF_32BIT);
-	}
-
 	mm = t->task->mm;
 	if (mm)
 		tsb_context_switch(mm);
diff -Nur linux-2.6.32-orig/arch/sparc/kernel/sys_sparc_32.c iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/sys_sparc_32.c
--- linux-2.6.32-orig/arch/sparc/kernel/sys_sparc_32.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/sys_sparc_32.c	2010-11-18 21:05:30.000000000 +0600
@@ -45,7 +45,8 @@
 		/* We do not accept a shared mapping if it would violate
 		 * cache aliasing constraints.
 		 */
-		if ((flags & MAP_SHARED) && (addr & (SHMLBA - 1)))
+		if ((flags & MAP_SHARED) &&
+		    ((addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)))
 			return -EINVAL;
 		return addr;
 	}
@@ -79,15 +80,6 @@
 	}
 }
 
-asmlinkage unsigned long sparc_brk(unsigned long brk)
-{
-	if(ARCH_SUN4C) {
-		if ((brk & 0xe0000000) != (current->mm->brk & 0xe0000000))
-			return current->mm->brk;
-	}
-	return sys_brk(brk);
-}
-
 /*
  * sys_pipe() is the normal C calling standard for creating
  * a pipe. It's not the way unix traditionally does this, though.
@@ -234,31 +226,6 @@
 }
 
 /* Linux version of mmap */
-static unsigned long do_mmap2(unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags, unsigned long fd,
-	unsigned long pgoff)
-{
-	struct file * file = NULL;
-	unsigned long retval = -EBADF;
-
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	len = PAGE_ALIGN(len);
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-
-	down_write(&current->mm->mmap_sem);
-	retval = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:
-	return retval;
-}
 
 asmlinkage unsigned long sys_mmap2(unsigned long addr, unsigned long len,
 	unsigned long prot, unsigned long flags, unsigned long fd,
@@ -266,14 +233,16 @@
 {
 	/* Make sure the shift for mmap2 is constant (12), no matter what PAGE_SIZE
 	   we have. */
-	return do_mmap2(addr, len, prot, flags, fd, pgoff >> (PAGE_SHIFT - 12));
+	return sys_mmap_pgoff(addr, len, prot, flags, fd,
+			      pgoff >> (PAGE_SHIFT - 12));
 }
 
 asmlinkage unsigned long sys_mmap(unsigned long addr, unsigned long len,
 	unsigned long prot, unsigned long flags, unsigned long fd,
 	unsigned long off)
 {
-	return do_mmap2(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
+	/* no alignment check? */
+	return sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
 }
 
 long sparc_remap_file_pages(unsigned long start, unsigned long size,
@@ -287,27 +256,6 @@
 				    (pgoff >> (PAGE_SHIFT - 12)), flags);
 }
 
-extern unsigned long do_mremap(unsigned long addr,
-	unsigned long old_len, unsigned long new_len,
-	unsigned long flags, unsigned long new_addr);
-                
-asmlinkage unsigned long sparc_mremap(unsigned long addr,
-	unsigned long old_len, unsigned long new_len,
-	unsigned long flags, unsigned long new_addr)
-{
-	unsigned long ret = -EINVAL;
-
-	if (unlikely(sparc_mmap_check(addr, old_len)))
-		goto out;
-	if (unlikely(sparc_mmap_check(new_addr, new_len)))
-		goto out;
-	down_write(&current->mm->mmap_sem);
-	ret = do_mremap(addr, old_len, new_len, flags, new_addr);
-	up_write(&current->mm->mmap_sem);
-out:
-	return ret;       
-}
-
 /* we come to here via sys_nis_syscall so it can setup the regs argument */
 asmlinkage unsigned long
 c_sys_nis_syscall (struct pt_regs *regs)
diff -Nur linux-2.6.32-orig/arch/sparc/kernel/sys_sparc_64.c iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/sys_sparc_64.c
--- linux-2.6.32-orig/arch/sparc/kernel/sys_sparc_64.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/sys_sparc_64.c	2010-11-18 21:05:30.000000000 +0600
@@ -317,10 +317,14 @@
 unsigned long get_fb_unmapped_area(struct file *filp, unsigned long orig_addr, unsigned long len, unsigned long pgoff, unsigned long flags)
 {
 	unsigned long align_goal, addr = -ENOMEM;
+	unsigned long (*get_area)(struct file *, unsigned long,
+				  unsigned long, unsigned long, unsigned long);
+
+	get_area = current->mm->get_unmapped_area;
 
 	if (flags & MAP_FIXED) {
 		/* Ok, don't mess with it. */
-		return get_unmapped_area(NULL, orig_addr, len, pgoff, flags);
+		return get_area(NULL, orig_addr, len, pgoff, flags);
 	}
 	flags &= ~MAP_SHARED;
 
@@ -333,7 +337,7 @@
 		align_goal = (64UL * 1024);
 
 	do {
-		addr = get_unmapped_area(NULL, orig_addr, len + (align_goal - PAGE_SIZE), pgoff, flags);
+		addr = get_area(NULL, orig_addr, len + (align_goal - PAGE_SIZE), pgoff, flags);
 		if (!(addr & ~PAGE_MASK)) {
 			addr = (addr + (align_goal - 1UL)) & ~(align_goal - 1UL);
 			break;
@@ -351,7 +355,7 @@
 	 * be obtained.
 	 */
 	if (addr & ~PAGE_MASK)
-		addr = get_unmapped_area(NULL, orig_addr, len, pgoff, flags);
+		addr = get_area(NULL, orig_addr, len, pgoff, flags);
 
 	return addr;
 }
@@ -399,18 +403,6 @@
 	}
 }
 
-SYSCALL_DEFINE1(sparc_brk, unsigned long, brk)
-{
-	/* People could try to be nasty and use ta 0x6d in 32bit programs */
-	if (test_thread_flag(TIF_32BIT) && brk >= STACK_TOP32)
-		return current->mm->brk;
-
-	if (unlikely(straddles_64bit_va_hole(current->mm->brk, brk)))
-		return current->mm->brk;
-
-	return sys_brk(brk);
-}
-                                                                
 /*
  * sys_pipe() is the normal C calling standard for creating
  * a pipe. It's not the way unix traditionally does this, though.
@@ -568,23 +560,13 @@
 		unsigned long, prot, unsigned long, flags, unsigned long, fd,
 		unsigned long, off)
 {
-	struct file * file = NULL;
-	unsigned long retval = -EBADF;
-
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	len = PAGE_ALIGN(len);
+	unsigned long retval = -EINVAL;
 
-	down_write(&current->mm->mmap_sem);
-	retval = do_mmap(file, addr, len, prot, flags, off);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
+	if ((off + PAGE_ALIGN(len)) < off)
+		goto out;
+	if (off & ~PAGE_MASK)
+		goto out;
+	retval = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
 out:
 	return retval;
 }
@@ -614,12 +596,6 @@
 
 	if (test_thread_flag(TIF_32BIT))
 		goto out;
-	if (unlikely(new_len >= VA_EXCLUDE_START))
-		goto out;
-	if (unlikely(sparc_mmap_check(addr, old_len)))
-		goto out;
-	if (unlikely(sparc_mmap_check(new_addr, new_len)))
-		goto out;
 
 	down_write(&current->mm->mmap_sem);
 	ret = do_mremap(addr, old_len, new_len, flags, new_addr);
diff -Nur linux-2.6.32-orig/arch/sparc/kernel/systbls_32.S iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/systbls_32.S
--- linux-2.6.32-orig/arch/sparc/kernel/systbls_32.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/systbls_32.S	2010-11-18 21:05:30.000000000 +0600
@@ -19,7 +19,7 @@
 /*0*/	.long sys_restart_syscall, sys_exit, sys_fork, sys_read, sys_write
 /*5*/	.long sys_open, sys_close, sys_wait4, sys_creat, sys_link
 /*10*/  .long sys_unlink, sunos_execv, sys_chdir, sys_chown16, sys_mknod
-/*15*/	.long sys_chmod, sys_lchown16, sparc_brk, sys_nis_syscall, sys_lseek
+/*15*/	.long sys_chmod, sys_lchown16, sys_brk, sys_nis_syscall, sys_lseek
 /*20*/	.long sys_getpid, sys_capget, sys_capset, sys_setuid16, sys_getuid16
 /*25*/	.long sys_vmsplice, sys_ptrace, sys_alarm, sys_sigaltstack, sys_pause
 /*30*/	.long sys_utime, sys_lchown, sys_fchown, sys_access, sys_nice
@@ -67,7 +67,7 @@
 /*235*/	.long sys_fstatfs64, sys_llseek, sys_mlock, sys_munlock, sys_mlockall
 /*240*/	.long sys_munlockall, sys_sched_setparam, sys_sched_getparam, sys_sched_setscheduler, sys_sched_getscheduler
 /*245*/	.long sys_sched_yield, sys_sched_get_priority_max, sys_sched_get_priority_min, sys_sched_rr_get_interval, sys_nanosleep
-/*250*/	.long sparc_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
+/*250*/	.long sys_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
 /*255*/	.long sys_sync_file_range, sys_clock_settime, sys_clock_gettime, sys_clock_getres, sys_clock_nanosleep
 /*260*/	.long sys_sched_getaffinity, sys_sched_setaffinity, sys_timer_settime, sys_timer_gettime, sys_timer_getoverrun
 /*265*/	.long sys_timer_delete, sys_timer_create, sys_nis_syscall, sys_io_setup, sys_io_destroy
diff -Nur linux-2.6.32-orig/arch/sparc/kernel/systbls_64.S iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/systbls_64.S
--- linux-2.6.32-orig/arch/sparc/kernel/systbls_64.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/systbls_64.S	2010-11-18 21:05:30.000000000 +0600
@@ -21,7 +21,7 @@
 /*0*/	.word sys_restart_syscall, sys32_exit, sys_fork, sys_read, sys_write
 /*5*/	.word sys32_open, sys_close, sys32_wait4, sys32_creat, sys_link
 /*10*/  .word sys_unlink, sunos_execv, sys_chdir, sys_chown16, sys32_mknod
-/*15*/	.word sys_chmod, sys_lchown16, sys_sparc_brk, sys32_perfctr, sys32_lseek
+/*15*/	.word sys_chmod, sys_lchown16, sys_brk, sys32_perfctr, sys32_lseek
 /*20*/	.word sys_getpid, sys_capget, sys_capset, sys_setuid16, sys_getuid16
 /*25*/	.word sys32_vmsplice, compat_sys_ptrace, sys_alarm, sys32_sigaltstack, sys_pause
 /*30*/	.word compat_sys_utime, sys_lchown, sys_fchown, sys32_access, sys32_nice
@@ -96,7 +96,7 @@
 /*0*/	.word sys_restart_syscall, sparc_exit, sys_fork, sys_read, sys_write
 /*5*/	.word sys_open, sys_close, sys_wait4, sys_creat, sys_link
 /*10*/  .word sys_unlink, sys_nis_syscall, sys_chdir, sys_chown, sys_mknod
-/*15*/	.word sys_chmod, sys_lchown, sys_sparc_brk, sys_perfctr, sys_lseek
+/*15*/	.word sys_chmod, sys_lchown, sys_brk, sys_perfctr, sys_lseek
 /*20*/	.word sys_getpid, sys_capget, sys_capset, sys_setuid, sys_getuid
 /*25*/	.word sys_vmsplice, sys_ptrace, sys_alarm, sys_sigaltstack, sys_nis_syscall
 /*30*/	.word sys_utime, sys_nis_syscall, sys_nis_syscall, sys_access, sys_nice
diff -Nur linux-2.6.32-orig/arch/sparc/kernel/systbls.h iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/systbls.h
--- linux-2.6.32-orig/arch/sparc/kernel/systbls.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/kernel/systbls.h	2010-11-18 21:05:30.000000000 +0600
@@ -9,7 +9,6 @@
 struct new_utsname;
 
 extern asmlinkage unsigned long sys_getpagesize(void);
-extern asmlinkage unsigned long sparc_brk(unsigned long brk);
 extern asmlinkage long sparc_pipe(struct pt_regs *regs);
 extern asmlinkage long sys_ipc(unsigned int call, int first,
 			       unsigned long second,
diff -Nur linux-2.6.32-orig/arch/sparc/lib/mcount.S iDroid-Project-kernel_common-9e90fd2/arch/sparc/lib/mcount.S
--- linux-2.6.32-orig/arch/sparc/lib/mcount.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/lib/mcount.S	2010-11-18 21:05:30.000000000 +0600
@@ -64,8 +64,9 @@
 2:	 sethi		%hi(softirq_stack), %g3
 	or		%g3, %lo(softirq_stack), %g3
 	ldx		[%g3 + %g1], %g7
+	sub		%g7, STACK_BIAS, %g7
 	cmp		%sp, %g7
-	bleu,pt		%xcc, 2f
+	bleu,pt		%xcc, 3f
 	 sethi		%hi(THREAD_SIZE), %g3
 	add		%g7, %g3, %g7
 	cmp		%sp, %g7
@@ -75,7 +76,7 @@
 	 * again, we are already trying to output the stack overflow
 	 * message.
 	 */
-	sethi		%hi(ovstack), %g7		! cant move to panic stack fast enough
+3:	sethi		%hi(ovstack), %g7		! cant move to panic stack fast enough
 	 or		%g7, %lo(ovstack), %g7
 	add		%g7, OVSTACKSIZE, %g3
 	sub		%g3, STACK_BIAS + 192, %g3
diff -Nur linux-2.6.32-orig/arch/sparc/Makefile iDroid-Project-kernel_common-9e90fd2/arch/sparc/Makefile
--- linux-2.6.32-orig/arch/sparc/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/sparc/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -27,6 +27,7 @@
 LDFLAGS        := -m elf32_sparc
 CHECKFLAGS     += -D__sparc__
 export BITS    := 32
+UTS_MACHINE    := sparc
 
 #KBUILD_CFLAGS += -g -pipe -fcall-used-g5 -fcall-used-g7
 KBUILD_CFLAGS += -m32 -pipe -mno-fpu -fcall-used-g5 -fcall-used-g7
@@ -46,6 +47,7 @@
 
 LDFLAGS              := -m elf64_sparc
 export BITS          := 64
+UTS_MACHINE          := sparc64
 
 KBUILD_CFLAGS += -m64 -pipe -mno-fpu -mcpu=ultrasparc -mcmodel=medlow   \
                  -ffixed-g4 -ffixed-g5 -fcall-used-g7 -Wno-sign-compare \
diff -Nur linux-2.6.32-orig/arch/um/kernel/syscall.c iDroid-Project-kernel_common-9e90fd2/arch/um/kernel/syscall.c
--- linux-2.6.32-orig/arch/um/kernel/syscall.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/um/kernel/syscall.c	2010-11-18 21:05:30.000000000 +0600
@@ -8,6 +8,7 @@
 #include "linux/mm.h"
 #include "linux/sched.h"
 #include "linux/utsname.h"
+#include "linux/syscalls.h"
 #include "asm/current.h"
 #include "asm/mman.h"
 #include "asm/uaccess.h"
@@ -37,31 +38,6 @@
 	return ret;
 }
 
-/* common code for old and new mmaps */
-long sys_mmap2(unsigned long addr, unsigned long len,
-	       unsigned long prot, unsigned long flags,
-	       unsigned long fd, unsigned long pgoff)
-{
-	long error = -EBADF;
-	struct file * file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
- out:
-	return error;
-}
-
 long old_mmap(unsigned long addr, unsigned long len,
 	      unsigned long prot, unsigned long flags,
 	      unsigned long fd, unsigned long offset)
@@ -70,7 +46,7 @@
 	if (offset & ~PAGE_MASK)
 		goto out;
 
-	err = sys_mmap2(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);
+	err = sys_mmap_pgoff(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);
  out:
 	return err;
 }
diff -Nur linux-2.6.32-orig/arch/um/sys-i386/shared/sysdep/syscalls.h iDroid-Project-kernel_common-9e90fd2/arch/um/sys-i386/shared/sysdep/syscalls.h
--- linux-2.6.32-orig/arch/um/sys-i386/shared/sysdep/syscalls.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/um/sys-i386/shared/sysdep/syscalls.h	2010-11-18 21:05:30.000000000 +0600
@@ -20,7 +20,3 @@
 #define EXECUTE_SYSCALL(syscall, regs) \
 	((long (*)(struct syscall_args)) \
 	 (*sys_call_table[syscall]))(SYSCALL_ARGS(&regs->regs))
-
-extern long sys_mmap2(unsigned long addr, unsigned long len,
-		      unsigned long prot, unsigned long flags,
-		      unsigned long fd, unsigned long pgoff);
diff -Nur linux-2.6.32-orig/arch/x86/ia32/ia32_aout.c iDroid-Project-kernel_common-9e90fd2/arch/x86/ia32/ia32_aout.c
--- linux-2.6.32-orig/arch/x86/ia32/ia32_aout.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/ia32/ia32_aout.c	2010-11-18 21:05:30.000000000 +0600
@@ -308,14 +308,15 @@
 	if (retval)
 		return retval;
 
-	regs->cs = __USER32_CS;
-	regs->r8 = regs->r9 = regs->r10 = regs->r11 = regs->r12 =
-		regs->r13 = regs->r14 = regs->r15 = 0;
-
 	/* OK, This is the point of no return */
 	set_personality(PER_LINUX);
 	set_thread_flag(TIF_IA32);
-	clear_thread_flag(TIF_ABI_PENDING);
+
+	setup_new_exec(bprm);
+
+	regs->cs = __USER32_CS;
+	regs->r8 = regs->r9 = regs->r10 = regs->r11 = regs->r12 =
+		regs->r13 = regs->r14 = regs->r15 = 0;
 
 	current->mm->end_code = ex.a_text +
 		(current->mm->start_code = N_TXTADDR(ex));
diff -Nur linux-2.6.32-orig/arch/x86/ia32/ia32entry.S iDroid-Project-kernel_common-9e90fd2/arch/x86/ia32/ia32entry.S
--- linux-2.6.32-orig/arch/x86/ia32/ia32entry.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/ia32/ia32entry.S	2010-11-18 21:05:30.000000000 +0600
@@ -696,7 +696,7 @@
 	.quad quiet_ni_syscall		/* streams2 */
 	.quad stub32_vfork            /* 190 */
 	.quad compat_sys_getrlimit
-	.quad sys32_mmap2
+	.quad sys_mmap_pgoff
 	.quad sys32_truncate64
 	.quad sys32_ftruncate64
 	.quad sys32_stat64		/* 195 */
diff -Nur linux-2.6.32-orig/arch/x86/ia32/sys_ia32.c iDroid-Project-kernel_common-9e90fd2/arch/x86/ia32/sys_ia32.c
--- linux-2.6.32-orig/arch/x86/ia32/sys_ia32.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/ia32/sys_ia32.c	2010-11-18 21:05:30.000000000 +0600
@@ -155,9 +155,6 @@
 asmlinkage long sys32_mmap(struct mmap_arg_struct __user *arg)
 {
 	struct mmap_arg_struct a;
-	struct file *file = NULL;
-	unsigned long retval;
-	struct mm_struct *mm ;
 
 	if (copy_from_user(&a, arg, sizeof(a)))
 		return -EFAULT;
@@ -165,22 +162,8 @@
 	if (a.offset & ~PAGE_MASK)
 		return -EINVAL;
 
-	if (!(a.flags & MAP_ANONYMOUS)) {
-		file = fget(a.fd);
-		if (!file)
-			return -EBADF;
-	}
-
-	mm = current->mm;
-	down_write(&mm->mmap_sem);
-	retval = do_mmap_pgoff(file, a.addr, a.len, a.prot, a.flags,
+	return sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,
 			       a.offset>>PAGE_SHIFT);
-	if (file)
-		fput(file);
-
-	up_write(&mm->mmap_sem);
-
-	return retval;
 }
 
 asmlinkage long sys32_mprotect(unsigned long start, size_t len,
@@ -539,30 +522,6 @@
 	return ret;
 }
 
-asmlinkage long sys32_mmap2(unsigned long addr, unsigned long len,
-			    unsigned long prot, unsigned long flags,
-			    unsigned long fd, unsigned long pgoff)
-{
-	struct mm_struct *mm = current->mm;
-	unsigned long error;
-	struct file *file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			return -EBADF;
-	}
-
-	down_write(&mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&mm->mmap_sem);
-
-	if (file)
-		fput(file);
-	return error;
-}
-
 asmlinkage long sys32_olduname(struct oldold_utsname __user *name)
 {
 	char *arch = "x86_64";
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/amd_iommu.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/amd_iommu.h
--- linux-2.6.32-orig/arch/x86/include/asm/amd_iommu.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/amd_iommu.h	2010-11-18 21:05:30.000000000 +0600
@@ -32,6 +32,7 @@
 extern void amd_iommu_flush_all_devices(void);
 extern void amd_iommu_shutdown(void);
 extern void amd_iommu_apply_erratum_63(u16 devid);
+extern void amd_iommu_init_api(void);
 #else
 static inline int amd_iommu_init(void) { return -ENODEV; }
 static inline void amd_iommu_detect(void) { }
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/cpu_debug.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/cpu_debug.h
--- linux-2.6.32-orig/arch/x86/include/asm/cpu_debug.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/cpu_debug.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,127 +0,0 @@
-#ifndef _ASM_X86_CPU_DEBUG_H
-#define _ASM_X86_CPU_DEBUG_H
-
-/*
- * CPU x86 architecture debug
- *
- * Copyright(C) 2009 Jaswinder Singh Rajput
- */
-
-/* Register flags */
-enum cpu_debug_bit {
-/* Model Specific Registers (MSRs)					*/
-	CPU_MC_BIT,				/* Machine Check	*/
-	CPU_MONITOR_BIT,			/* Monitor		*/
-	CPU_TIME_BIT,				/* Time			*/
-	CPU_PMC_BIT,				/* Performance Monitor	*/
-	CPU_PLATFORM_BIT,			/* Platform		*/
-	CPU_APIC_BIT,				/* APIC			*/
-	CPU_POWERON_BIT,			/* Power-on		*/
-	CPU_CONTROL_BIT,			/* Control		*/
-	CPU_FEATURES_BIT,			/* Features control	*/
-	CPU_LBRANCH_BIT,			/* Last Branch		*/
-	CPU_BIOS_BIT,				/* BIOS			*/
-	CPU_FREQ_BIT,				/* Frequency		*/
-	CPU_MTTR_BIT,				/* MTRR			*/
-	CPU_PERF_BIT,				/* Performance		*/
-	CPU_CACHE_BIT,				/* Cache		*/
-	CPU_SYSENTER_BIT,			/* Sysenter		*/
-	CPU_THERM_BIT,				/* Thermal		*/
-	CPU_MISC_BIT,				/* Miscellaneous	*/
-	CPU_DEBUG_BIT,				/* Debug		*/
-	CPU_PAT_BIT,				/* PAT			*/
-	CPU_VMX_BIT,				/* VMX			*/
-	CPU_CALL_BIT,				/* System Call		*/
-	CPU_BASE_BIT,				/* BASE Address		*/
-	CPU_VER_BIT,				/* Version ID		*/
-	CPU_CONF_BIT,				/* Configuration	*/
-	CPU_SMM_BIT,				/* System mgmt mode	*/
-	CPU_SVM_BIT,				/*Secure Virtual Machine*/
-	CPU_OSVM_BIT,				/* OS-Visible Workaround*/
-/* Standard Registers							*/
-	CPU_TSS_BIT,				/* Task Stack Segment	*/
-	CPU_CR_BIT,				/* Control Registers	*/
-	CPU_DT_BIT,				/* Descriptor Table	*/
-/* End of Registers flags						*/
-	CPU_REG_ALL_BIT,			/* Select all Registers	*/
-};
-
-#define	CPU_REG_ALL		(~0)		/* Select all Registers	*/
-
-#define	CPU_MC			(1 << CPU_MC_BIT)
-#define	CPU_MONITOR		(1 << CPU_MONITOR_BIT)
-#define	CPU_TIME		(1 << CPU_TIME_BIT)
-#define	CPU_PMC			(1 << CPU_PMC_BIT)
-#define	CPU_PLATFORM		(1 << CPU_PLATFORM_BIT)
-#define	CPU_APIC		(1 << CPU_APIC_BIT)
-#define	CPU_POWERON		(1 << CPU_POWERON_BIT)
-#define	CPU_CONTROL		(1 << CPU_CONTROL_BIT)
-#define	CPU_FEATURES		(1 << CPU_FEATURES_BIT)
-#define	CPU_LBRANCH		(1 << CPU_LBRANCH_BIT)
-#define	CPU_BIOS		(1 << CPU_BIOS_BIT)
-#define	CPU_FREQ		(1 << CPU_FREQ_BIT)
-#define	CPU_MTRR		(1 << CPU_MTTR_BIT)
-#define	CPU_PERF		(1 << CPU_PERF_BIT)
-#define	CPU_CACHE		(1 << CPU_CACHE_BIT)
-#define	CPU_SYSENTER		(1 << CPU_SYSENTER_BIT)
-#define	CPU_THERM		(1 << CPU_THERM_BIT)
-#define	CPU_MISC		(1 << CPU_MISC_BIT)
-#define	CPU_DEBUG		(1 << CPU_DEBUG_BIT)
-#define	CPU_PAT			(1 << CPU_PAT_BIT)
-#define	CPU_VMX			(1 << CPU_VMX_BIT)
-#define	CPU_CALL		(1 << CPU_CALL_BIT)
-#define	CPU_BASE		(1 << CPU_BASE_BIT)
-#define	CPU_VER			(1 << CPU_VER_BIT)
-#define	CPU_CONF		(1 << CPU_CONF_BIT)
-#define	CPU_SMM			(1 << CPU_SMM_BIT)
-#define	CPU_SVM			(1 << CPU_SVM_BIT)
-#define	CPU_OSVM		(1 << CPU_OSVM_BIT)
-#define	CPU_TSS			(1 << CPU_TSS_BIT)
-#define	CPU_CR			(1 << CPU_CR_BIT)
-#define	CPU_DT			(1 << CPU_DT_BIT)
-
-/* Register file flags */
-enum cpu_file_bit {
-	CPU_INDEX_BIT,				/* index		*/
-	CPU_VALUE_BIT,				/* value		*/
-};
-
-#define	CPU_FILE_VALUE		(1 << CPU_VALUE_BIT)
-
-#define MAX_CPU_FILES		512
-
-struct cpu_private {
-	unsigned		cpu;
-	unsigned		type;
-	unsigned		reg;
-	unsigned		file;
-};
-
-struct cpu_debug_base {
-	char			*name;		/* Register name	*/
-	unsigned		flag;		/* Register flag	*/
-	unsigned		write;		/* Register write flag	*/
-};
-
-/*
- * Currently it looks similar to cpu_debug_base but once we add more files
- * cpu_file_base will go in different direction
- */
-struct cpu_file_base {
-	char			*name;		/* Register file name	*/
-	unsigned		flag;		/* Register file flag	*/
-	unsigned		write;		/* Register write flag	*/
-};
-
-struct cpu_cpuX_base {
-	struct dentry		*dentry;	/* Register dentry	*/
-	int			init;		/* Register index file	*/
-};
-
-struct cpu_debug_range {
-	unsigned		min;		/* Register range min	*/
-	unsigned		max;		/* Register range max	*/
-	unsigned		flag;		/* Supported flags	*/
-};
-
-#endif /* _ASM_X86_CPU_DEBUG_H */
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/elf.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/elf.h
--- linux-2.6.32-orig/arch/x86/include/asm/elf.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/elf.h	2010-11-18 21:05:30.000000000 +0600
@@ -197,14 +197,8 @@
 	set_fs(USER_DS);				\
 } while (0)
 
-#define COMPAT_SET_PERSONALITY(ex)			\
-do {							\
-	if (test_thread_flag(TIF_IA32))			\
-		clear_thread_flag(TIF_ABI_PENDING);	\
-	else						\
-		set_thread_flag(TIF_ABI_PENDING);	\
-	current->personality |= force_personality32;	\
-} while (0)
+void set_personality_ia32(void);
+#define COMPAT_SET_PERSONALITY(ex) set_personality_ia32()
 
 #define COMPAT_ELF_PLATFORM			("i686")
 
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/hpet.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/hpet.h
--- linux-2.6.32-orig/arch/x86/include/asm/hpet.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/hpet.h	2010-11-18 21:05:30.000000000 +0600
@@ -66,6 +66,7 @@
 extern unsigned long hpet_address;
 extern unsigned long force_hpet_address;
 extern int hpet_force_user;
+extern u8 hpet_msi_disable;
 extern int is_hpet_enabled(void);
 extern int hpet_enable(void);
 extern void hpet_disable(void);
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/irq_vectors.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/irq_vectors.h
--- linux-2.6.32-orig/arch/x86/include/asm/irq_vectors.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/irq_vectors.h	2010-11-18 21:05:30.000000000 +0600
@@ -113,7 +113,7 @@
  */
 #define LOCAL_PENDING_VECTOR		0xec
 
-#define UV_BAU_MESSAGE			0xec
+#define UV_BAU_MESSAGE			0xea
 
 /*
  * Self IPI vector for machine checks
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/kvm_emulate.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/kvm_emulate.h
--- linux-2.6.32-orig/arch/x86/include/asm/kvm_emulate.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/kvm_emulate.h	2010-11-18 21:05:30.000000000 +0600
@@ -129,7 +129,7 @@
 	u8 seg_override;
 	unsigned int d;
 	unsigned long regs[NR_VCPU_REGS];
-	unsigned long eip;
+	unsigned long eip, eip_orig;
 	/* modrm */
 	u8 modrm;
 	u8 modrm_mod;
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/kvm_host.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/kvm_host.h
--- linux-2.6.32-orig/arch/x86/include/asm/kvm_host.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/kvm_host.h	2010-11-18 21:05:30.000000000 +0600
@@ -412,6 +412,7 @@
 	unsigned long irq_sources_bitmap;
 	unsigned long irq_states[KVM_IOAPIC_NUM_PINS];
 	u64 vm_init_tsc;
+	s64 kvmclock_offset;
 };
 
 struct kvm_vm_stat {
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/mce.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/mce.h
--- linux-2.6.32-orig/arch/x86/include/asm/mce.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/mce.h	2010-11-18 21:05:30.000000000 +0600
@@ -214,5 +214,11 @@
 
 void mce_log_therm_throt_event(__u64 status);
 
+#ifdef CONFIG_X86_THERMAL_VECTOR
+extern void mcheck_intel_therm_init(void);
+#else
+static inline void mcheck_intel_therm_init(void) { }
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _ASM_X86_MCE_H */
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/msr.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/msr.h
--- linux-2.6.32-orig/arch/x86/include/asm/msr.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/msr.h	2010-11-18 21:05:30.000000000 +0600
@@ -27,6 +27,18 @@
 	};
 };
 
+struct msr_info {
+	u32 msr_no;
+	struct msr reg;
+	struct msr *msrs;
+	int err;
+};
+
+struct msr_regs_info {
+	u32 *regs;
+	int err;
+};
+
 static inline unsigned long long native_read_tscp(unsigned int *aux)
 {
 	unsigned long low, high;
@@ -244,11 +256,14 @@
 
 #define write_rdtscp_aux(val) wrmsr(0xc0000103, (val), 0)
 
+struct msr *msrs_alloc(void);
+void msrs_free(struct msr *msrs);
+
 #ifdef CONFIG_SMP
 int rdmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h);
 int wrmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h);
-void rdmsr_on_cpus(const cpumask_t *mask, u32 msr_no, struct msr *msrs);
-void wrmsr_on_cpus(const cpumask_t *mask, u32 msr_no, struct msr *msrs);
+void rdmsr_on_cpus(const struct cpumask *mask, u32 msr_no, struct msr *msrs);
+void wrmsr_on_cpus(const struct cpumask *mask, u32 msr_no, struct msr *msrs);
 int rdmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h);
 int wrmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h);
 int rdmsr_safe_regs_on_cpu(unsigned int cpu, u32 regs[8]);
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/processor.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/processor.h
--- linux-2.6.32-orig/arch/x86/include/asm/processor.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/processor.h	2010-11-18 21:05:30.000000000 +0600
@@ -180,7 +180,7 @@
 				unsigned int *ecx, unsigned int *edx)
 {
 	/* ecx is often an input as well as an output. */
-	asm("cpuid"
+	asm volatile("cpuid"
 	    : "=a" (*eax),
 	      "=b" (*ebx),
 	      "=c" (*ecx),
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/syscalls.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/syscalls.h
--- linux-2.6.32-orig/arch/x86/include/asm/syscalls.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/syscalls.h	2010-11-18 21:05:30.000000000 +0600
@@ -55,8 +55,6 @@
 struct oldold_utsname;
 struct old_utsname;
 
-asmlinkage long sys_mmap2(unsigned long, unsigned long, unsigned long,
-			  unsigned long, unsigned long, unsigned long);
 asmlinkage int old_mmap(struct mmap_arg_struct __user *);
 asmlinkage int old_select(struct sel_arg_struct __user *);
 asmlinkage int sys_ipc(uint, int, int, int, void __user *, long);
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/sys_ia32.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/sys_ia32.h
--- linux-2.6.32-orig/arch/x86/include/asm/sys_ia32.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/sys_ia32.h	2010-11-18 21:05:30.000000000 +0600
@@ -62,9 +62,6 @@
 asmlinkage long sys32_personality(unsigned long);
 asmlinkage long sys32_sendfile(int, int, compat_off_t __user *, s32);
 
-asmlinkage long sys32_mmap2(unsigned long, unsigned long, unsigned long,
-			    unsigned long, unsigned long, unsigned long);
-
 struct oldold_utsname;
 struct old_utsname;
 asmlinkage long sys32_olduname(struct oldold_utsname __user *);
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/thread_info.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/thread_info.h
--- linux-2.6.32-orig/arch/x86/include/asm/thread_info.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/thread_info.h	2010-11-18 21:05:30.000000000 +0600
@@ -86,7 +86,6 @@
 #define TIF_NOTSC		16	/* TSC is not accessible in userland */
 #define TIF_IA32		17	/* 32bit process */
 #define TIF_FORK		18	/* ret_from_fork */
-#define TIF_ABI_PENDING		19
 #define TIF_MEMDIE		20
 #define TIF_DEBUG		21	/* uses debug registers */
 #define TIF_IO_BITMAP		22	/* uses I/O bitmap */
@@ -110,7 +109,6 @@
 #define _TIF_NOTSC		(1 << TIF_NOTSC)
 #define _TIF_IA32		(1 << TIF_IA32)
 #define _TIF_FORK		(1 << TIF_FORK)
-#define _TIF_ABI_PENDING	(1 << TIF_ABI_PENDING)
 #define _TIF_DEBUG		(1 << TIF_DEBUG)
 #define _TIF_IO_BITMAP		(1 << TIF_IO_BITMAP)
 #define _TIF_FREEZE		(1 << TIF_FREEZE)
diff -Nur linux-2.6.32-orig/arch/x86/include/asm/uv/uv_hub.h iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/uv/uv_hub.h
--- linux-2.6.32-orig/arch/x86/include/asm/uv/uv_hub.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/include/asm/uv/uv_hub.h	2010-11-18 21:05:30.000000000 +0600
@@ -31,20 +31,20 @@
  *		  contiguous (although various IO spaces may punch holes in
  *		  it)..
  *
- * 	N	- Number of bits in the node portion of a socket physical
- * 		  address.
+ *	N	- Number of bits in the node portion of a socket physical
+ *		  address.
  *
- * 	NASID   - network ID of a router, Mbrick or Cbrick. Nasid values of
- * 	 	  routers always have low bit of 1, C/MBricks have low bit
- * 		  equal to 0. Most addressing macros that target UV hub chips
- * 		  right shift the NASID by 1 to exclude the always-zero bit.
- * 		  NASIDs contain up to 15 bits.
+ *	NASID   - network ID of a router, Mbrick or Cbrick. Nasid values of
+ *		  routers always have low bit of 1, C/MBricks have low bit
+ *		  equal to 0. Most addressing macros that target UV hub chips
+ *		  right shift the NASID by 1 to exclude the always-zero bit.
+ *		  NASIDs contain up to 15 bits.
  *
  *	GNODE   - NASID right shifted by 1 bit. Most mmrs contain gnodes instead
  *		  of nasids.
  *
- * 	PNODE   - the low N bits of the GNODE. The PNODE is the most useful variant
- * 		  of the nasid for socket usage.
+ *	PNODE   - the low N bits of the GNODE. The PNODE is the most useful variant
+ *		  of the nasid for socket usage.
  *
  *
  *  NumaLink Global Physical Address Format:
@@ -71,12 +71,12 @@
  *
  *
  * APICID format
- * 	NOTE!!!!!! This is the current format of the APICID. However, code
- * 	should assume that this will change in the future. Use functions
- * 	in this file for all APICID bit manipulations and conversion.
+ *	NOTE!!!!!! This is the current format of the APICID. However, code
+ *	should assume that this will change in the future. Use functions
+ *	in this file for all APICID bit manipulations and conversion.
  *
- * 		1111110000000000
- * 		5432109876543210
+ *		1111110000000000
+ *		5432109876543210
  *		pppppppppplc0cch
  *		sssssssssss
  *
@@ -89,9 +89,9 @@
  *	Note: Processor only supports 12 bits in the APICID register. The ACPI
  *	      tables hold all 16 bits. Software needs to be aware of this.
  *
- * 	      Unless otherwise specified, all references to APICID refer to
- * 	      the FULL value contained in ACPI tables, not the subset in the
- * 	      processor APICID register.
+ *	      Unless otherwise specified, all references to APICID refer to
+ *	      the FULL value contained in ACPI tables, not the subset in the
+ *	      processor APICID register.
  */
 
 
@@ -151,16 +151,16 @@
 };
 
 DECLARE_PER_CPU(struct uv_hub_info_s, __uv_hub_info);
-#define uv_hub_info 		(&__get_cpu_var(__uv_hub_info))
+#define uv_hub_info		(&__get_cpu_var(__uv_hub_info))
 #define uv_cpu_hub_info(cpu)	(&per_cpu(__uv_hub_info, cpu))
 
 /*
  * Local & Global MMR space macros.
- * 	Note: macros are intended to be used ONLY by inline functions
- * 	in this file - not by other kernel code.
- * 		n -  NASID (full 15-bit global nasid)
- * 		g -  GNODE (full 15-bit global nasid, right shifted 1)
- * 		p -  PNODE (local part of nsids, right shifted 1)
+ *	Note: macros are intended to be used ONLY by inline functions
+ *	in this file - not by other kernel code.
+ *		n -  NASID (full 15-bit global nasid)
+ *		g -  GNODE (full 15-bit global nasid, right shifted 1)
+ *		p -  PNODE (local part of nsids, right shifted 1)
  */
 #define UV_NASID_TO_PNODE(n)		(((n) >> 1) & uv_hub_info->pnode_mask)
 #define UV_PNODE_TO_GNODE(p)		((p) |uv_hub_info->gnode_extra)
@@ -213,8 +213,8 @@
 /*
  * Macros for converting between kernel virtual addresses, socket local physical
  * addresses, and UV global physical addresses.
- * 	Note: use the standard __pa() & __va() macros for converting
- * 	      between socket virtual and socket physical addresses.
+ *	Note: use the standard __pa() & __va() macros for converting
+ *	      between socket virtual and socket physical addresses.
  */
 
 /* socket phys RAM --> UV global physical address */
@@ -265,21 +265,18 @@
  * Access global MMRs using the low memory MMR32 space. This region supports
  * faster MMR access but not all MMRs are accessible in this space.
  */
-static inline unsigned long *uv_global_mmr32_address(int pnode,
-				unsigned long offset)
+static inline unsigned long *uv_global_mmr32_address(int pnode, unsigned long offset)
 {
 	return __va(UV_GLOBAL_MMR32_BASE |
 		       UV_GLOBAL_MMR32_PNODE_BITS(pnode) | offset);
 }
 
-static inline void uv_write_global_mmr32(int pnode, unsigned long offset,
-				 unsigned long val)
+static inline void uv_write_global_mmr32(int pnode, unsigned long offset, unsigned long val)
 {
 	writeq(val, uv_global_mmr32_address(pnode, offset));
 }
 
-static inline unsigned long uv_read_global_mmr32(int pnode,
-						 unsigned long offset)
+static inline unsigned long uv_read_global_mmr32(int pnode, unsigned long offset)
 {
 	return readq(uv_global_mmr32_address(pnode, offset));
 }
@@ -288,25 +285,32 @@
  * Access Global MMR space using the MMR space located at the top of physical
  * memory.
  */
-static inline unsigned long *uv_global_mmr64_address(int pnode,
-				unsigned long offset)
+static inline unsigned long *uv_global_mmr64_address(int pnode, unsigned long offset)
 {
 	return __va(UV_GLOBAL_MMR64_BASE |
 		    UV_GLOBAL_MMR64_PNODE_BITS(pnode) | offset);
 }
 
-static inline void uv_write_global_mmr64(int pnode, unsigned long offset,
-				unsigned long val)
+static inline void uv_write_global_mmr64(int pnode, unsigned long offset, unsigned long val)
 {
 	writeq(val, uv_global_mmr64_address(pnode, offset));
 }
 
-static inline unsigned long uv_read_global_mmr64(int pnode,
-						 unsigned long offset)
+static inline unsigned long uv_read_global_mmr64(int pnode, unsigned long offset)
 {
 	return readq(uv_global_mmr64_address(pnode, offset));
 }
 
+static inline void uv_write_global_mmr8(int pnode, unsigned long offset, unsigned char val)
+{
+	writeb(val, uv_global_mmr64_address(pnode, offset));
+}
+
+static inline unsigned char uv_read_global_mmr8(int pnode, unsigned long offset)
+{
+	return readb(uv_global_mmr64_address(pnode, offset));
+}
+
 /*
  * Access hub local MMRs. Faster than using global space but only local MMRs
  * are accessible.
@@ -426,11 +430,17 @@
 	}
 }
 
+static inline unsigned long uv_scir_offset(int apicid)
+{
+	return SCIR_LOCAL_MMR_BASE | (apicid & 0x3f);
+}
+
 static inline void uv_set_cpu_scir_bits(int cpu, unsigned char value)
 {
 	if (uv_cpu_hub_info(cpu)->scir.state != value) {
+		uv_write_global_mmr8(uv_cpu_to_pnode(cpu),
+				uv_cpu_hub_info(cpu)->scir.offset, value);
 		uv_cpu_hub_info(cpu)->scir.state = value;
-		uv_write_local_mmr8(uv_cpu_hub_info(cpu)->scir.offset, value);
 	}
 }
 
diff -Nur linux-2.6.32-orig/arch/x86/Kconfig iDroid-Project-kernel_common-9e90fd2/arch/x86/Kconfig
--- linux-2.6.32-orig/arch/x86/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -984,12 +984,6 @@
 	  with major 203 and minors 0 to 31 for /dev/cpu/0/cpuid to
 	  /dev/cpu/31/cpuid.
 
-config X86_CPU_DEBUG
-	tristate "/sys/kernel/debug/x86/cpu/* - CPU Debug support"
-	---help---
-	  If you select this option, this will provide various x86 CPUs
-	  information through debugfs.
-
 choice
 	prompt "High Memory Support"
 	default HIGHMEM4G if !X86_NUMAQ
diff -Nur linux-2.6.32-orig/arch/x86/Kconfig.cpu iDroid-Project-kernel_common-9e90fd2/arch/x86/Kconfig.cpu
--- linux-2.6.32-orig/arch/x86/Kconfig.cpu	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/Kconfig.cpu	2010-11-18 21:05:30.000000000 +0600
@@ -400,7 +400,7 @@
 
 config X86_CMPXCHG64
 	def_bool y
-	depends on !M386 && !M486
+	depends on X86_PAE || X86_64 || MCORE2 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || MATOM
 
 # this should be set for all -march=.. options where the compiler
 # generates cmov.
diff -Nur linux-2.6.32-orig/arch/x86/kernel/acpi/cstate.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/acpi/cstate.c
--- linux-2.6.32-orig/arch/x86/kernel/acpi/cstate.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/acpi/cstate.c	2010-11-18 21:05:30.000000000 +0600
@@ -48,7 +48,7 @@
 	 * P4, Core and beyond CPUs
 	 */
 	if (c->x86_vendor == X86_VENDOR_INTEL &&
-	    (c->x86 > 0xf || (c->x86 == 6 && c->x86_model >= 14)))
+	    (c->x86 > 0xf || (c->x86 == 6 && c->x86_model >= 0x0f)))
 			flags->bm_control = 0;
 }
 EXPORT_SYMBOL(acpi_processor_power_init_bm_check);
diff -Nur linux-2.6.32-orig/arch/x86/kernel/amd_iommu.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/amd_iommu.c
--- linux-2.6.32-orig/arch/x86/kernel/amd_iommu.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/amd_iommu.c	2010-11-18 21:05:30.000000000 +0600
@@ -540,7 +540,7 @@
 static void flush_devices_by_domain(struct protection_domain *domain)
 {
 	struct amd_iommu *iommu;
-	int i;
+	unsigned long i;
 
 	for (i = 0; i <= amd_iommu_last_bdf; ++i) {
 		if ((domain == NULL && amd_iommu_pd_table[i] == NULL) ||
@@ -1230,9 +1230,10 @@
 
 	/*
 	 * If we run in passthrough mode the device must be assigned to the
-	 * passthrough domain if it is detached from any other domain
+	 * passthrough domain if it is detached from any other domain.
+	 * Make sure we can deassign from the pt_domain itself.
 	 */
-	if (iommu_pass_through) {
+	if (iommu_pass_through && domain != pt_domain) {
 		struct amd_iommu *iommu = amd_iommu_rlookup_table[devid];
 		__attach_device(iommu, pt_domain, devid);
 	}
@@ -2047,10 +2048,10 @@
 	struct pci_dev *dev = NULL;
 	struct dma_ops_domain *dma_dom;
 	struct amd_iommu *iommu;
-	u16 devid;
+	u16 devid, __devid;
 
 	while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
-		devid = calc_devid(dev->bus->number, dev->devfn);
+		__devid = devid = calc_devid(dev->bus->number, dev->devfn);
 		if (devid > amd_iommu_last_bdf)
 			continue;
 		devid = amd_iommu_alias_table[devid];
@@ -2065,6 +2066,10 @@
 		init_unity_mappings_for_device(dma_dom, devid);
 		dma_dom->target_dev = devid;
 
+		attach_device(iommu, &dma_dom->domain, devid);
+		if (__devid != devid)
+			attach_device(iommu, &dma_dom->domain, __devid);
+
 		list_add_tail(&dma_dom->list, &iommu_pd_list);
 	}
 }
@@ -2079,6 +2084,11 @@
 	.dma_supported = amd_iommu_dma_supported,
 };
 
+void __init amd_iommu_init_api(void)
+{
+	register_iommu(&amd_iommu_ops);
+}
+
 /*
  * The function which clues the AMD IOMMU driver into dma_ops.
  */
@@ -2120,8 +2130,6 @@
 	/* Make the driver finally visible to the drivers */
 	dma_ops = &amd_iommu_dma_ops;
 
-	register_iommu(&amd_iommu_ops);
-
 	bus_register_notifier(&pci_bus_type, &device_nb);
 
 	amd_iommu_stats_init();
diff -Nur linux-2.6.32-orig/arch/x86/kernel/amd_iommu_init.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/amd_iommu_init.c
--- linux-2.6.32-orig/arch/x86/kernel/amd_iommu_init.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/amd_iommu_init.c	2010-11-18 21:05:30.000000000 +0600
@@ -136,6 +136,11 @@
 					   system */
 
 /*
+ * Set to true if ACPI table parsing and hardware intialization went properly
+ */
+static bool amd_iommu_initialized;
+
+/*
  * Pointer to the device table which is shared by all AMD IOMMUs
  * it is indexed by the PCI device id or the HT unit id and contains
  * information about the domain the device belongs to as well as the
@@ -913,6 +918,8 @@
 	}
 	WARN_ON(p != end);
 
+	amd_iommu_initialized = true;
+
 	return 0;
 }
 
@@ -925,7 +932,7 @@
  *
  ****************************************************************************/
 
-static int __init iommu_setup_msi(struct amd_iommu *iommu)
+static int iommu_setup_msi(struct amd_iommu *iommu)
 {
 	int r;
 
@@ -1263,6 +1270,9 @@
 	if (acpi_table_parse("IVRS", init_iommu_all) != 0)
 		goto free;
 
+	if (!amd_iommu_initialized)
+		goto free;
+
 	if (acpi_table_parse("IVRS", init_memory_definitions) != 0)
 		goto free;
 
@@ -1278,9 +1288,12 @@
 		ret = amd_iommu_init_passthrough();
 	else
 		ret = amd_iommu_init_dma_ops();
+
 	if (ret)
 		goto free;
 
+	amd_iommu_init_api();
+
 	enable_iommus();
 
 	if (iommu_pass_through)
diff -Nur linux-2.6.32-orig/arch/x86/kernel/apic/apic.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/apic/apic.c
--- linux-2.6.32-orig/arch/x86/kernel/apic/apic.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/apic/apic.c	2010-11-18 21:05:30.000000000 +0600
@@ -246,7 +246,7 @@
  */
 static void native_apic_write_dummy(u32 reg, u32 v)
 {
-	WARN_ON_ONCE((cpu_has_apic || !disable_apic));
+	WARN_ON_ONCE(cpu_has_apic && !disable_apic);
 }
 
 static u32 native_apic_read_dummy(u32 reg)
diff -Nur linux-2.6.32-orig/arch/x86/kernel/apic/apic_flat_64.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/apic/apic_flat_64.c
--- linux-2.6.32-orig/arch/x86/kernel/apic/apic_flat_64.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/apic/apic_flat_64.c	2010-11-18 21:05:30.000000000 +0600
@@ -240,6 +240,11 @@
 		printk(KERN_DEBUG "system APIC only can use physical flat");
 		return 1;
 	}
+
+	if (!strncmp(oem_id, "IBM", 3) && !strncmp(oem_table_id, "EXA", 3)) {
+		printk(KERN_DEBUG "IBM Summit detected, will use apic physical");
+		return 1;
+	}
 #endif
 
 	return 0;
diff -Nur linux-2.6.32-orig/arch/x86/kernel/apic/io_apic.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/apic/io_apic.c
--- linux-2.6.32-orig/arch/x86/kernel/apic/io_apic.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/apic/io_apic.c	2010-11-18 21:05:30.000000000 +0600
@@ -3157,6 +3157,7 @@
 			continue;
 
 		desc_new = move_irq_desc(desc_new, node);
+		cfg_new = desc_new->chip_data;
 
 		if (__assign_irq_vector(new, cfg_new, apic->target_cpus()) == 0)
 			irq = new;
diff -Nur linux-2.6.32-orig/arch/x86/kernel/apic/x2apic_uv_x.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/apic/x2apic_uv_x.c
--- linux-2.6.32-orig/arch/x86/kernel/apic/x2apic_uv_x.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/apic/x2apic_uv_x.c	2010-11-18 21:05:30.000000000 +0600
@@ -364,13 +364,13 @@
 
 enum map_type {map_wb, map_uc};
 
-static __init void map_high(char *id, unsigned long base, int shift,
-			    int max_pnode, enum map_type map_type)
+static __init void map_high(char *id, unsigned long base, int pshift,
+			int bshift, int max_pnode, enum map_type map_type)
 {
 	unsigned long bytes, paddr;
 
-	paddr = base << shift;
-	bytes = (1UL << shift) * (max_pnode + 1);
+	paddr = base << pshift;
+	bytes = (1UL << bshift) * (max_pnode + 1);
 	printk(KERN_INFO "UV: Map %s_HI 0x%lx - 0x%lx\n", id, paddr,
 						paddr + bytes);
 	if (map_type == map_uc)
@@ -386,7 +386,7 @@
 
 	gru.v = uv_read_local_mmr(UVH_RH_GAM_GRU_OVERLAY_CONFIG_MMR);
 	if (gru.s.enable)
-		map_high("GRU", gru.s.base, shift, max_pnode, map_wb);
+		map_high("GRU", gru.s.base, shift, shift, max_pnode, map_wb);
 }
 
 static __init void map_mmr_high(int max_pnode)
@@ -396,7 +396,7 @@
 
 	mmr.v = uv_read_local_mmr(UVH_RH_GAM_MMR_OVERLAY_CONFIG_MMR);
 	if (mmr.s.enable)
-		map_high("MMR", mmr.s.base, shift, max_pnode, map_uc);
+		map_high("MMR", mmr.s.base, shift, shift, max_pnode, map_uc);
 }
 
 static __init void map_mmioh_high(int max_pnode)
@@ -406,7 +406,8 @@
 
 	mmioh.v = uv_read_local_mmr(UVH_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR);
 	if (mmioh.s.enable)
-		map_high("MMIOH", mmioh.s.base, shift, max_pnode, map_uc);
+		map_high("MMIOH", mmioh.s.base, shift, mmioh.s.m_io,
+			max_pnode, map_uc);
 }
 
 static __init void uv_rtc_init(void)
@@ -607,8 +608,10 @@
 	uv_rtc_init();
 
 	for_each_present_cpu(cpu) {
+		int apicid = per_cpu(x86_cpu_to_apicid, cpu);
+
 		nid = cpu_to_node(cpu);
-		pnode = uv_apicid_to_pnode(per_cpu(x86_cpu_to_apicid, cpu));
+		pnode = uv_apicid_to_pnode(apicid);
 		blade = boot_pnode_to_blade(pnode);
 		lcpu = uv_blade_info[blade].nr_possible_cpus;
 		uv_blade_info[blade].nr_possible_cpus++;
@@ -629,15 +632,13 @@
 		uv_cpu_hub_info(cpu)->gnode_extra = gnode_extra;
 		uv_cpu_hub_info(cpu)->global_mmr_base = mmr_base;
 		uv_cpu_hub_info(cpu)->coherency_domain_number = sn_coherency_id;
-		uv_cpu_hub_info(cpu)->scir.offset = SCIR_LOCAL_MMR_BASE + lcpu;
+		uv_cpu_hub_info(cpu)->scir.offset = uv_scir_offset(apicid);
 		uv_node_to_blade[nid] = blade;
 		uv_cpu_to_blade[cpu] = blade;
 		max_pnode = max(pnode, max_pnode);
 
-		printk(KERN_DEBUG "UV: cpu %d, apicid 0x%x, pnode %d, nid %d, "
-			"lcpu %d, blade %d\n",
-			cpu, per_cpu(x86_cpu_to_apicid, cpu), pnode, nid,
-			lcpu, blade);
+		printk(KERN_DEBUG "UV: cpu %d, apicid 0x%x, pnode %d, nid %d, lcpu %d, blade %d\n",
+			cpu, apicid, pnode, nid, lcpu, blade);
 	}
 
 	/* Add blade/pnode info for nodes without cpus */
diff -Nur linux-2.6.32-orig/arch/x86/kernel/cpu/cpu_debug.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/cpu_debug.c
--- linux-2.6.32-orig/arch/x86/kernel/cpu/cpu_debug.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/cpu_debug.c	1970-01-01 07:00:00.000000000 +0700
@@ -1,688 +0,0 @@
-/*
- * CPU x86 architecture debug code
- *
- * Copyright(C) 2009 Jaswinder Singh Rajput
- *
- * For licencing details see kernel-base/COPYING
- */
-
-#include <linux/interrupt.h>
-#include <linux/compiler.h>
-#include <linux/seq_file.h>
-#include <linux/debugfs.h>
-#include <linux/kprobes.h>
-#include <linux/uaccess.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/percpu.h>
-#include <linux/signal.h>
-#include <linux/errno.h>
-#include <linux/sched.h>
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/smp.h>
-
-#include <asm/cpu_debug.h>
-#include <asm/paravirt.h>
-#include <asm/system.h>
-#include <asm/traps.h>
-#include <asm/apic.h>
-#include <asm/desc.h>
-
-static DEFINE_PER_CPU(struct cpu_cpuX_base [CPU_REG_ALL_BIT], cpu_arr);
-static DEFINE_PER_CPU(struct cpu_private * [MAX_CPU_FILES], priv_arr);
-static DEFINE_PER_CPU(int, cpu_priv_count);
-
-static DEFINE_MUTEX(cpu_debug_lock);
-
-static struct dentry *cpu_debugfs_dir;
-
-static struct cpu_debug_base cpu_base[] = {
-	{ "mc",		CPU_MC,		0	},
-	{ "monitor",	CPU_MONITOR,	0	},
-	{ "time",	CPU_TIME,	0	},
-	{ "pmc",	CPU_PMC,	1	},
-	{ "platform",	CPU_PLATFORM,	0	},
-	{ "apic",	CPU_APIC,	0	},
-	{ "poweron",	CPU_POWERON,	0	},
-	{ "control",	CPU_CONTROL,	0	},
-	{ "features",	CPU_FEATURES,	0	},
-	{ "lastbranch",	CPU_LBRANCH,	0	},
-	{ "bios",	CPU_BIOS,	0	},
-	{ "freq",	CPU_FREQ,	0	},
-	{ "mtrr",	CPU_MTRR,	0	},
-	{ "perf",	CPU_PERF,	0	},
-	{ "cache",	CPU_CACHE,	0	},
-	{ "sysenter",	CPU_SYSENTER,	0	},
-	{ "therm",	CPU_THERM,	0	},
-	{ "misc",	CPU_MISC,	0	},
-	{ "debug",	CPU_DEBUG,	0	},
-	{ "pat",	CPU_PAT,	0	},
-	{ "vmx",	CPU_VMX,	0	},
-	{ "call",	CPU_CALL,	0	},
-	{ "base",	CPU_BASE,	0	},
-	{ "ver",	CPU_VER,	0	},
-	{ "conf",	CPU_CONF,	0	},
-	{ "smm",	CPU_SMM,	0	},
-	{ "svm",	CPU_SVM,	0	},
-	{ "osvm",	CPU_OSVM,	0	},
-	{ "tss",	CPU_TSS,	0	},
-	{ "cr",		CPU_CR,		0	},
-	{ "dt",		CPU_DT,		0	},
-	{ "registers",	CPU_REG_ALL,	0	},
-};
-
-static struct cpu_file_base cpu_file[] = {
-	{ "index",	CPU_REG_ALL,	0	},
-	{ "value",	CPU_REG_ALL,	1	},
-};
-
-/* CPU Registers Range */
-static struct cpu_debug_range cpu_reg_range[] = {
-	{ 0x00000000, 0x00000001, CPU_MC,	},
-	{ 0x00000006, 0x00000007, CPU_MONITOR,	},
-	{ 0x00000010, 0x00000010, CPU_TIME,	},
-	{ 0x00000011, 0x00000013, CPU_PMC,	},
-	{ 0x00000017, 0x00000017, CPU_PLATFORM,	},
-	{ 0x0000001B, 0x0000001B, CPU_APIC,	},
-	{ 0x0000002A, 0x0000002B, CPU_POWERON,	},
-	{ 0x0000002C, 0x0000002C, CPU_FREQ,	},
-	{ 0x0000003A, 0x0000003A, CPU_CONTROL,	},
-	{ 0x00000040, 0x00000047, CPU_LBRANCH,	},
-	{ 0x00000060, 0x00000067, CPU_LBRANCH,	},
-	{ 0x00000079, 0x00000079, CPU_BIOS,	},
-	{ 0x00000088, 0x0000008A, CPU_CACHE,	},
-	{ 0x0000008B, 0x0000008B, CPU_BIOS,	},
-	{ 0x0000009B, 0x0000009B, CPU_MONITOR,	},
-	{ 0x000000C1, 0x000000C4, CPU_PMC,	},
-	{ 0x000000CD, 0x000000CD, CPU_FREQ,	},
-	{ 0x000000E7, 0x000000E8, CPU_PERF,	},
-	{ 0x000000FE, 0x000000FE, CPU_MTRR,	},
-
-	{ 0x00000116, 0x0000011E, CPU_CACHE,	},
-	{ 0x00000174, 0x00000176, CPU_SYSENTER,	},
-	{ 0x00000179, 0x0000017B, CPU_MC,	},
-	{ 0x00000186, 0x00000189, CPU_PMC,	},
-	{ 0x00000198, 0x00000199, CPU_PERF,	},
-	{ 0x0000019A, 0x0000019A, CPU_TIME,	},
-	{ 0x0000019B, 0x0000019D, CPU_THERM,	},
-	{ 0x000001A0, 0x000001A0, CPU_MISC,	},
-	{ 0x000001C9, 0x000001C9, CPU_LBRANCH,	},
-	{ 0x000001D7, 0x000001D8, CPU_LBRANCH,	},
-	{ 0x000001D9, 0x000001D9, CPU_DEBUG,	},
-	{ 0x000001DA, 0x000001E0, CPU_LBRANCH,	},
-
-	{ 0x00000200, 0x0000020F, CPU_MTRR,	},
-	{ 0x00000250, 0x00000250, CPU_MTRR,	},
-	{ 0x00000258, 0x00000259, CPU_MTRR,	},
-	{ 0x00000268, 0x0000026F, CPU_MTRR,	},
-	{ 0x00000277, 0x00000277, CPU_PAT,	},
-	{ 0x000002FF, 0x000002FF, CPU_MTRR,	},
-
-	{ 0x00000300, 0x00000311, CPU_PMC,	},
-	{ 0x00000345, 0x00000345, CPU_PMC,	},
-	{ 0x00000360, 0x00000371, CPU_PMC,	},
-	{ 0x0000038D, 0x00000390, CPU_PMC,	},
-	{ 0x000003A0, 0x000003BE, CPU_PMC,	},
-	{ 0x000003C0, 0x000003CD, CPU_PMC,	},
-	{ 0x000003E0, 0x000003E1, CPU_PMC,	},
-	{ 0x000003F0, 0x000003F2, CPU_PMC,	},
-
-	{ 0x00000400, 0x00000417, CPU_MC,	},
-	{ 0x00000480, 0x0000048B, CPU_VMX,	},
-
-	{ 0x00000600, 0x00000600, CPU_DEBUG,	},
-	{ 0x00000680, 0x0000068F, CPU_LBRANCH,	},
-	{ 0x000006C0, 0x000006CF, CPU_LBRANCH,	},
-
-	{ 0x000107CC, 0x000107D3, CPU_PMC,	},
-
-	{ 0xC0000080, 0xC0000080, CPU_FEATURES,	},
-	{ 0xC0000081, 0xC0000084, CPU_CALL,	},
-	{ 0xC0000100, 0xC0000102, CPU_BASE,	},
-	{ 0xC0000103, 0xC0000103, CPU_TIME,	},
-
-	{ 0xC0010000, 0xC0010007, CPU_PMC,	},
-	{ 0xC0010010, 0xC0010010, CPU_CONF,	},
-	{ 0xC0010015, 0xC0010015, CPU_CONF,	},
-	{ 0xC0010016, 0xC001001A, CPU_MTRR,	},
-	{ 0xC001001D, 0xC001001D, CPU_MTRR,	},
-	{ 0xC001001F, 0xC001001F, CPU_CONF,	},
-	{ 0xC0010030, 0xC0010035, CPU_BIOS,	},
-	{ 0xC0010044, 0xC0010048, CPU_MC,	},
-	{ 0xC0010050, 0xC0010056, CPU_SMM,	},
-	{ 0xC0010058, 0xC0010058, CPU_CONF,	},
-	{ 0xC0010060, 0xC0010060, CPU_CACHE,	},
-	{ 0xC0010061, 0xC0010068, CPU_SMM,	},
-	{ 0xC0010069, 0xC001006B, CPU_SMM,	},
-	{ 0xC0010070, 0xC0010071, CPU_SMM,	},
-	{ 0xC0010111, 0xC0010113, CPU_SMM,	},
-	{ 0xC0010114, 0xC0010118, CPU_SVM,	},
-	{ 0xC0010140, 0xC0010141, CPU_OSVM,	},
-	{ 0xC0011022, 0xC0011023, CPU_CONF,	},
-};
-
-static int is_typeflag_valid(unsigned cpu, unsigned flag)
-{
-	int i;
-
-	/* Standard Registers should be always valid */
-	if (flag >= CPU_TSS)
-		return 1;
-
-	for (i = 0; i < ARRAY_SIZE(cpu_reg_range); i++) {
-		if (cpu_reg_range[i].flag == flag)
-			return 1;
-	}
-
-	/* Invalid */
-	return 0;
-}
-
-static unsigned get_cpu_range(unsigned cpu, unsigned *min, unsigned *max,
-			      int index, unsigned flag)
-{
-	if (cpu_reg_range[index].flag == flag) {
-		*min = cpu_reg_range[index].min;
-		*max = cpu_reg_range[index].max;
-	} else
-		*max = 0;
-
-	return *max;
-}
-
-/* This function can also be called with seq = NULL for printk */
-static void print_cpu_data(struct seq_file *seq, unsigned type,
-			   u32 low, u32 high)
-{
-	struct cpu_private *priv;
-	u64 val = high;
-
-	if (seq) {
-		priv = seq->private;
-		if (priv->file) {
-			val = (val << 32) | low;
-			seq_printf(seq, "0x%llx\n", val);
-		} else
-			seq_printf(seq, " %08x: %08x_%08x\n",
-				   type, high, low);
-	} else
-		printk(KERN_INFO " %08x: %08x_%08x\n", type, high, low);
-}
-
-/* This function can also be called with seq = NULL for printk */
-static void print_msr(struct seq_file *seq, unsigned cpu, unsigned flag)
-{
-	unsigned msr, msr_min, msr_max;
-	struct cpu_private *priv;
-	u32 low, high;
-	int i;
-
-	if (seq) {
-		priv = seq->private;
-		if (priv->file) {
-			if (!rdmsr_safe_on_cpu(priv->cpu, priv->reg,
-					       &low, &high))
-				print_cpu_data(seq, priv->reg, low, high);
-			return;
-		}
-	}
-
-	for (i = 0; i < ARRAY_SIZE(cpu_reg_range); i++) {
-		if (!get_cpu_range(cpu, &msr_min, &msr_max, i, flag))
-			continue;
-
-		for (msr = msr_min; msr <= msr_max; msr++) {
-			if (rdmsr_safe_on_cpu(cpu, msr, &low, &high))
-				continue;
-			print_cpu_data(seq, msr, low, high);
-		}
-	}
-}
-
-static void print_tss(void *arg)
-{
-	struct pt_regs *regs = task_pt_regs(current);
-	struct seq_file *seq = arg;
-	unsigned int seg;
-
-	seq_printf(seq, " RAX\t: %016lx\n", regs->ax);
-	seq_printf(seq, " RBX\t: %016lx\n", regs->bx);
-	seq_printf(seq, " RCX\t: %016lx\n", regs->cx);
-	seq_printf(seq, " RDX\t: %016lx\n", regs->dx);
-
-	seq_printf(seq, " RSI\t: %016lx\n", regs->si);
-	seq_printf(seq, " RDI\t: %016lx\n", regs->di);
-	seq_printf(seq, " RBP\t: %016lx\n", regs->bp);
-	seq_printf(seq, " ESP\t: %016lx\n", regs->sp);
-
-#ifdef CONFIG_X86_64
-	seq_printf(seq, " R08\t: %016lx\n", regs->r8);
-	seq_printf(seq, " R09\t: %016lx\n", regs->r9);
-	seq_printf(seq, " R10\t: %016lx\n", regs->r10);
-	seq_printf(seq, " R11\t: %016lx\n", regs->r11);
-	seq_printf(seq, " R12\t: %016lx\n", regs->r12);
-	seq_printf(seq, " R13\t: %016lx\n", regs->r13);
-	seq_printf(seq, " R14\t: %016lx\n", regs->r14);
-	seq_printf(seq, " R15\t: %016lx\n", regs->r15);
-#endif
-
-	asm("movl %%cs,%0" : "=r" (seg));
-	seq_printf(seq, " CS\t:             %04x\n", seg);
-	asm("movl %%ds,%0" : "=r" (seg));
-	seq_printf(seq, " DS\t:             %04x\n", seg);
-	seq_printf(seq, " SS\t:             %04lx\n", regs->ss & 0xffff);
-	asm("movl %%es,%0" : "=r" (seg));
-	seq_printf(seq, " ES\t:             %04x\n", seg);
-	asm("movl %%fs,%0" : "=r" (seg));
-	seq_printf(seq, " FS\t:             %04x\n", seg);
-	asm("movl %%gs,%0" : "=r" (seg));
-	seq_printf(seq, " GS\t:             %04x\n", seg);
-
-	seq_printf(seq, " EFLAGS\t: %016lx\n", regs->flags);
-
-	seq_printf(seq, " EIP\t: %016lx\n", regs->ip);
-}
-
-static void print_cr(void *arg)
-{
-	struct seq_file *seq = arg;
-
-	seq_printf(seq, " cr0\t: %016lx\n", read_cr0());
-	seq_printf(seq, " cr2\t: %016lx\n", read_cr2());
-	seq_printf(seq, " cr3\t: %016lx\n", read_cr3());
-	seq_printf(seq, " cr4\t: %016lx\n", read_cr4_safe());
-#ifdef CONFIG_X86_64
-	seq_printf(seq, " cr8\t: %016lx\n", read_cr8());
-#endif
-}
-
-static void print_desc_ptr(char *str, struct seq_file *seq, struct desc_ptr dt)
-{
-	seq_printf(seq, " %s\t: %016llx\n", str, (u64)(dt.address | dt.size));
-}
-
-static void print_dt(void *seq)
-{
-	struct desc_ptr dt;
-	unsigned long ldt;
-
-	/* IDT */
-	store_idt((struct desc_ptr *)&dt);
-	print_desc_ptr("IDT", seq, dt);
-
-	/* GDT */
-	store_gdt((struct desc_ptr *)&dt);
-	print_desc_ptr("GDT", seq, dt);
-
-	/* LDT */
-	store_ldt(ldt);
-	seq_printf(seq, " LDT\t: %016lx\n", ldt);
-
-	/* TR */
-	store_tr(ldt);
-	seq_printf(seq, " TR\t: %016lx\n", ldt);
-}
-
-static void print_dr(void *arg)
-{
-	struct seq_file *seq = arg;
-	unsigned long dr;
-	int i;
-
-	for (i = 0; i < 8; i++) {
-		/* Ignore db4, db5 */
-		if ((i == 4) || (i == 5))
-			continue;
-		get_debugreg(dr, i);
-		seq_printf(seq, " dr%d\t: %016lx\n", i, dr);
-	}
-
-	seq_printf(seq, "\n MSR\t:\n");
-}
-
-static void print_apic(void *arg)
-{
-	struct seq_file *seq = arg;
-
-#ifdef CONFIG_X86_LOCAL_APIC
-	seq_printf(seq, " LAPIC\t:\n");
-	seq_printf(seq, " ID\t\t: %08x\n",  apic_read(APIC_ID) >> 24);
-	seq_printf(seq, " LVR\t\t: %08x\n",  apic_read(APIC_LVR));
-	seq_printf(seq, " TASKPRI\t: %08x\n",  apic_read(APIC_TASKPRI));
-	seq_printf(seq, " ARBPRI\t\t: %08x\n",  apic_read(APIC_ARBPRI));
-	seq_printf(seq, " PROCPRI\t: %08x\n",  apic_read(APIC_PROCPRI));
-	seq_printf(seq, " LDR\t\t: %08x\n",  apic_read(APIC_LDR));
-	seq_printf(seq, " DFR\t\t: %08x\n",  apic_read(APIC_DFR));
-	seq_printf(seq, " SPIV\t\t: %08x\n",  apic_read(APIC_SPIV));
-	seq_printf(seq, " ISR\t\t: %08x\n",  apic_read(APIC_ISR));
-	seq_printf(seq, " ESR\t\t: %08x\n",  apic_read(APIC_ESR));
-	seq_printf(seq, " ICR\t\t: %08x\n",  apic_read(APIC_ICR));
-	seq_printf(seq, " ICR2\t\t: %08x\n",  apic_read(APIC_ICR2));
-	seq_printf(seq, " LVTT\t\t: %08x\n",  apic_read(APIC_LVTT));
-	seq_printf(seq, " LVTTHMR\t: %08x\n",  apic_read(APIC_LVTTHMR));
-	seq_printf(seq, " LVTPC\t\t: %08x\n",  apic_read(APIC_LVTPC));
-	seq_printf(seq, " LVT0\t\t: %08x\n",  apic_read(APIC_LVT0));
-	seq_printf(seq, " LVT1\t\t: %08x\n",  apic_read(APIC_LVT1));
-	seq_printf(seq, " LVTERR\t\t: %08x\n",  apic_read(APIC_LVTERR));
-	seq_printf(seq, " TMICT\t\t: %08x\n",  apic_read(APIC_TMICT));
-	seq_printf(seq, " TMCCT\t\t: %08x\n",  apic_read(APIC_TMCCT));
-	seq_printf(seq, " TDCR\t\t: %08x\n",  apic_read(APIC_TDCR));
-	if (boot_cpu_has(X86_FEATURE_EXTAPIC)) {
-		unsigned int i, v, maxeilvt;
-
-		v = apic_read(APIC_EFEAT);
-		maxeilvt = (v >> 16) & 0xff;
-		seq_printf(seq, " EFEAT\t\t: %08x\n", v);
-		seq_printf(seq, " ECTRL\t\t: %08x\n", apic_read(APIC_ECTRL));
-
-		for (i = 0; i < maxeilvt; i++) {
-			v = apic_read(APIC_EILVTn(i));
-			seq_printf(seq, " EILVT%d\t\t: %08x\n", i, v);
-		}
-	}
-#endif /* CONFIG_X86_LOCAL_APIC */
-	seq_printf(seq, "\n MSR\t:\n");
-}
-
-static int cpu_seq_show(struct seq_file *seq, void *v)
-{
-	struct cpu_private *priv = seq->private;
-
-	if (priv == NULL)
-		return -EINVAL;
-
-	switch (cpu_base[priv->type].flag) {
-	case CPU_TSS:
-		smp_call_function_single(priv->cpu, print_tss, seq, 1);
-		break;
-	case CPU_CR:
-		smp_call_function_single(priv->cpu, print_cr, seq, 1);
-		break;
-	case CPU_DT:
-		smp_call_function_single(priv->cpu, print_dt, seq, 1);
-		break;
-	case CPU_DEBUG:
-		if (priv->file == CPU_INDEX_BIT)
-			smp_call_function_single(priv->cpu, print_dr, seq, 1);
-		print_msr(seq, priv->cpu, cpu_base[priv->type].flag);
-		break;
-	case CPU_APIC:
-		if (priv->file == CPU_INDEX_BIT)
-			smp_call_function_single(priv->cpu, print_apic, seq, 1);
-		print_msr(seq, priv->cpu, cpu_base[priv->type].flag);
-		break;
-
-	default:
-		print_msr(seq, priv->cpu, cpu_base[priv->type].flag);
-		break;
-	}
-	seq_printf(seq, "\n");
-
-	return 0;
-}
-
-static void *cpu_seq_start(struct seq_file *seq, loff_t *pos)
-{
-	if (*pos == 0) /* One time is enough ;-) */
-		return seq;
-
-	return NULL;
-}
-
-static void *cpu_seq_next(struct seq_file *seq, void *v, loff_t *pos)
-{
-	(*pos)++;
-
-	return cpu_seq_start(seq, pos);
-}
-
-static void cpu_seq_stop(struct seq_file *seq, void *v)
-{
-}
-
-static const struct seq_operations cpu_seq_ops = {
-	.start		= cpu_seq_start,
-	.next		= cpu_seq_next,
-	.stop		= cpu_seq_stop,
-	.show		= cpu_seq_show,
-};
-
-static int cpu_seq_open(struct inode *inode, struct file *file)
-{
-	struct cpu_private *priv = inode->i_private;
-	struct seq_file *seq;
-	int err;
-
-	err = seq_open(file, &cpu_seq_ops);
-	if (!err) {
-		seq = file->private_data;
-		seq->private = priv;
-	}
-
-	return err;
-}
-
-static int write_msr(struct cpu_private *priv, u64 val)
-{
-	u32 low, high;
-
-	high = (val >> 32) & 0xffffffff;
-	low = val & 0xffffffff;
-
-	if (!wrmsr_safe_on_cpu(priv->cpu, priv->reg, low, high))
-		return 0;
-
-	return -EPERM;
-}
-
-static int write_cpu_register(struct cpu_private *priv, const char *buf)
-{
-	int ret = -EPERM;
-	u64 val;
-
-	ret = strict_strtoull(buf, 0, &val);
-	if (ret < 0)
-		return ret;
-
-	/* Supporting only MSRs */
-	if (priv->type < CPU_TSS_BIT)
-		return write_msr(priv, val);
-
-	return ret;
-}
-
-static ssize_t cpu_write(struct file *file, const char __user *ubuf,
-			     size_t count, loff_t *off)
-{
-	struct seq_file *seq = file->private_data;
-	struct cpu_private *priv = seq->private;
-	char buf[19];
-
-	if ((priv == NULL) || (count >= sizeof(buf)))
-		return -EINVAL;
-
-	if (copy_from_user(&buf, ubuf, count))
-		return -EFAULT;
-
-	buf[count] = 0;
-
-	if ((cpu_base[priv->type].write) && (cpu_file[priv->file].write))
-		if (!write_cpu_register(priv, buf))
-			return count;
-
-	return -EACCES;
-}
-
-static const struct file_operations cpu_fops = {
-	.owner		= THIS_MODULE,
-	.open		= cpu_seq_open,
-	.read		= seq_read,
-	.write		= cpu_write,
-	.llseek		= seq_lseek,
-	.release	= seq_release,
-};
-
-static int cpu_create_file(unsigned cpu, unsigned type, unsigned reg,
-			   unsigned file, struct dentry *dentry)
-{
-	struct cpu_private *priv = NULL;
-
-	/* Already intialized */
-	if (file == CPU_INDEX_BIT)
-		if (per_cpu(cpu_arr[type].init, cpu))
-			return 0;
-
-	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (priv == NULL)
-		return -ENOMEM;
-
-	priv->cpu = cpu;
-	priv->type = type;
-	priv->reg = reg;
-	priv->file = file;
-	mutex_lock(&cpu_debug_lock);
-	per_cpu(priv_arr[type], cpu) = priv;
-	per_cpu(cpu_priv_count, cpu)++;
-	mutex_unlock(&cpu_debug_lock);
-
-	if (file)
-		debugfs_create_file(cpu_file[file].name, S_IRUGO,
-				    dentry, (void *)priv, &cpu_fops);
-	else {
-		debugfs_create_file(cpu_base[type].name, S_IRUGO,
-				    per_cpu(cpu_arr[type].dentry, cpu),
-				    (void *)priv, &cpu_fops);
-		mutex_lock(&cpu_debug_lock);
-		per_cpu(cpu_arr[type].init, cpu) = 1;
-		mutex_unlock(&cpu_debug_lock);
-	}
-
-	return 0;
-}
-
-static int cpu_init_regfiles(unsigned cpu, unsigned int type, unsigned reg,
-			     struct dentry *dentry)
-{
-	unsigned file;
-	int err = 0;
-
-	for (file = 0; file <  ARRAY_SIZE(cpu_file); file++) {
-		err = cpu_create_file(cpu, type, reg, file, dentry);
-		if (err)
-			return err;
-	}
-
-	return err;
-}
-
-static int cpu_init_msr(unsigned cpu, unsigned type, struct dentry *dentry)
-{
-	struct dentry *cpu_dentry = NULL;
-	unsigned reg, reg_min, reg_max;
-	int i, err = 0;
-	char reg_dir[12];
-	u32 low, high;
-
-	for (i = 0; i < ARRAY_SIZE(cpu_reg_range); i++) {
-		if (!get_cpu_range(cpu, &reg_min, &reg_max, i,
-				   cpu_base[type].flag))
-			continue;
-
-		for (reg = reg_min; reg <= reg_max; reg++) {
-			if (rdmsr_safe_on_cpu(cpu, reg, &low, &high))
-				continue;
-
-			sprintf(reg_dir, "0x%x", reg);
-			cpu_dentry = debugfs_create_dir(reg_dir, dentry);
-			err = cpu_init_regfiles(cpu, type, reg, cpu_dentry);
-			if (err)
-				return err;
-		}
-	}
-
-	return err;
-}
-
-static int cpu_init_allreg(unsigned cpu, struct dentry *dentry)
-{
-	struct dentry *cpu_dentry = NULL;
-	unsigned type;
-	int err = 0;
-
-	for (type = 0; type <  ARRAY_SIZE(cpu_base) - 1; type++) {
-		if (!is_typeflag_valid(cpu, cpu_base[type].flag))
-			continue;
-		cpu_dentry = debugfs_create_dir(cpu_base[type].name, dentry);
-		per_cpu(cpu_arr[type].dentry, cpu) = cpu_dentry;
-
-		if (type < CPU_TSS_BIT)
-			err = cpu_init_msr(cpu, type, cpu_dentry);
-		else
-			err = cpu_create_file(cpu, type, 0, CPU_INDEX_BIT,
-					      cpu_dentry);
-		if (err)
-			return err;
-	}
-
-	return err;
-}
-
-static int cpu_init_cpu(void)
-{
-	struct dentry *cpu_dentry = NULL;
-	struct cpuinfo_x86 *cpui;
-	char cpu_dir[12];
-	unsigned cpu;
-	int err = 0;
-
-	for (cpu = 0; cpu < nr_cpu_ids; cpu++) {
-		cpui = &cpu_data(cpu);
-		if (!cpu_has(cpui, X86_FEATURE_MSR))
-			continue;
-
-		sprintf(cpu_dir, "cpu%d", cpu);
-		cpu_dentry = debugfs_create_dir(cpu_dir, cpu_debugfs_dir);
-		err = cpu_init_allreg(cpu, cpu_dentry);
-
-		pr_info("cpu%d(%d) debug files %d\n",
-			cpu, nr_cpu_ids, per_cpu(cpu_priv_count, cpu));
-		if (per_cpu(cpu_priv_count, cpu) > MAX_CPU_FILES) {
-			pr_err("Register files count %d exceeds limit %d\n",
-				per_cpu(cpu_priv_count, cpu), MAX_CPU_FILES);
-			per_cpu(cpu_priv_count, cpu) = MAX_CPU_FILES;
-			err = -ENFILE;
-		}
-		if (err)
-			return err;
-	}
-
-	return err;
-}
-
-static int __init cpu_debug_init(void)
-{
-	cpu_debugfs_dir = debugfs_create_dir("cpu", arch_debugfs_dir);
-
-	return cpu_init_cpu();
-}
-
-static void __exit cpu_debug_exit(void)
-{
-	int i, cpu;
-
-	if (cpu_debugfs_dir)
-		debugfs_remove_recursive(cpu_debugfs_dir);
-
-	for (cpu = 0; cpu <  nr_cpu_ids; cpu++)
-		for (i = 0; i < per_cpu(cpu_priv_count, cpu); i++)
-			kfree(per_cpu(priv_arr[i], cpu));
-}
-
-module_init(cpu_debug_init);
-module_exit(cpu_debug_exit);
-
-MODULE_AUTHOR("Jaswinder Singh Rajput");
-MODULE_DESCRIPTION("CPU Debug module");
-MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/arch/x86/kernel/cpu/cpufreq/powernow-k8.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/cpufreq/powernow-k8.c
--- linux-2.6.32-orig/arch/x86/kernel/cpu/cpufreq/powernow-k8.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/cpufreq/powernow-k8.c	2010-11-18 21:05:30.000000000 +0600
@@ -1351,6 +1351,7 @@
 
 	kfree(data->powernow_table);
 	kfree(data);
+	per_cpu(powernow_data, pol->cpu) = NULL;
 
 	return 0;
 }
@@ -1370,7 +1371,7 @@
 	int err;
 
 	if (!data)
-		return -EINVAL;
+		return 0;
 
 	smp_call_function_single(cpu, query_values_on_cpu, &err, true);
 	if (err)
diff -Nur linux-2.6.32-orig/arch/x86/kernel/cpu/intel.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/intel.c
--- linux-2.6.32-orig/arch/x86/kernel/cpu/intel.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/intel.c	2010-11-18 21:05:30.000000000 +0600
@@ -70,7 +70,6 @@
 	if (c->x86_power & (1 << 8)) {
 		set_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);
 		set_cpu_cap(c, X86_FEATURE_NONSTOP_TSC);
-		set_cpu_cap(c, X86_FEATURE_TSC_RELIABLE);
 		sched_clock_stable = 1;
 	}
 
diff -Nur linux-2.6.32-orig/arch/x86/kernel/cpu/intel_cacheinfo.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/intel_cacheinfo.c
--- linux-2.6.32-orig/arch/x86/kernel/cpu/intel_cacheinfo.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/intel_cacheinfo.c	2010-11-18 21:05:30.000000000 +0600
@@ -94,7 +94,7 @@
 	{ 0xd1, LVL_3,    1024 },	/* 4-way set assoc, 64 byte line size */
 	{ 0xd2, LVL_3,    2048 },	/* 4-way set assoc, 64 byte line size */
 	{ 0xd6, LVL_3,    1024 },	/* 8-way set assoc, 64 byte line size */
-	{ 0xd7, LVL_3,    2038 },	/* 8-way set assoc, 64 byte line size */
+	{ 0xd7, LVL_3,    2048 },	/* 8-way set assoc, 64 byte line size */
 	{ 0xd8, LVL_3,    4096 },	/* 12-way set assoc, 64 byte line size */
 	{ 0xdc, LVL_3,    2048 },	/* 12-way set assoc, 64 byte line size */
 	{ 0xdd, LVL_3,    4096 },	/* 12-way set assoc, 64 byte line size */
@@ -102,6 +102,9 @@
 	{ 0xe2, LVL_3,    2048 },	/* 16-way set assoc, 64 byte line size */
 	{ 0xe3, LVL_3,    4096 },	/* 16-way set assoc, 64 byte line size */
 	{ 0xe4, LVL_3,    8192 },	/* 16-way set assoc, 64 byte line size */
+	{ 0xea, LVL_3,    12288 },	/* 24-way set assoc, 64 byte line size */
+	{ 0xeb, LVL_3,    18432 },	/* 24-way set assoc, 64 byte line size */
+	{ 0xec, LVL_3,    24576 },	/* 24-way set assoc, 64 byte line size */
 	{ 0x00, 0, 0}
 };
 
diff -Nur linux-2.6.32-orig/arch/x86/kernel/cpu/Makefile iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/Makefile
--- linux-2.6.32-orig/arch/x86/kernel/cpu/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -18,8 +18,6 @@
 obj-$(CONFIG_X86_32)	+= bugs.o cmpxchg.o
 obj-$(CONFIG_X86_64)	+= bugs_64.o
 
-obj-$(CONFIG_X86_CPU_DEBUG)		+= cpu_debug.o
-
 obj-$(CONFIG_CPU_SUP_INTEL)		+= intel.o
 obj-$(CONFIG_CPU_SUP_AMD)		+= amd.o
 obj-$(CONFIG_CPU_SUP_CYRIX_32)		+= cyrix.o
diff -Nur linux-2.6.32-orig/arch/x86/kernel/cpu/mcheck/mce.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/mcheck/mce.c
--- linux-2.6.32-orig/arch/x86/kernel/cpu/mcheck/mce.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/mcheck/mce.c	2010-11-18 21:05:30.000000000 +0600
@@ -1374,13 +1374,14 @@
 	struct timer_list *t = &__get_cpu_var(mce_timer);
 	int *n = &__get_cpu_var(mce_next_interval);
 
+	setup_timer(t, mcheck_timer, smp_processor_id());
+
 	if (mce_ignore_ce)
 		return;
 
 	*n = check_interval * HZ;
 	if (!*n)
 		return;
-	setup_timer(t, mcheck_timer, smp_processor_id());
 	t->expires = round_jiffies(jiffies + *n);
 	add_timer_on(t, smp_processor_id());
 }
@@ -1991,9 +1992,11 @@
 		break;
 	case CPU_DOWN_FAILED:
 	case CPU_DOWN_FAILED_FROZEN:
-		t->expires = round_jiffies(jiffies +
+		if (!mce_ignore_ce && check_interval) {
+			t->expires = round_jiffies(jiffies +
 					   __get_cpu_var(mce_next_interval));
-		add_timer_on(t, cpu);
+			add_timer_on(t, cpu);
+		}
 		smp_call_function_single(cpu, mce_reenable_cpu, &action, 1);
 		break;
 	case CPU_POST_DEAD:
diff -Nur linux-2.6.32-orig/arch/x86/kernel/cpu/mcheck/therm_throt.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/mcheck/therm_throt.c
--- linux-2.6.32-orig/arch/x86/kernel/cpu/mcheck/therm_throt.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/mcheck/therm_throt.c	2010-11-18 21:05:30.000000000 +0600
@@ -49,6 +49,8 @@
 
 static atomic_t therm_throt_en	= ATOMIC_INIT(0);
 
+static u32 lvtthmr_init __read_mostly;
+
 #ifdef CONFIG_SYSFS
 #define define_therm_throt_sysdev_one_ro(_name)				\
 	static SYSDEV_ATTR(_name, 0444, therm_throt_sysdev_show_##_name, NULL)
@@ -254,14 +256,27 @@
 	ack_APIC_irq();
 }
 
+void __init mcheck_intel_therm_init(void)
+{
+	/*
+	 * This function is only called on boot CPU. Save the init thermal
+	 * LVT value on BSP and use that value to restore APs' thermal LVT
+	 * entry BIOS programmed later
+	 */
+	if (cpu_has(&boot_cpu_data, X86_FEATURE_ACPI) &&
+		cpu_has(&boot_cpu_data, X86_FEATURE_ACC))
+		lvtthmr_init = apic_read(APIC_LVTTHMR);
+}
+
 void intel_init_thermal(struct cpuinfo_x86 *c)
 {
 	unsigned int cpu = smp_processor_id();
 	int tm2 = 0;
 	u32 l, h;
 
-	/* Thermal monitoring depends on ACPI and clock modulation*/
-	if (!cpu_has(c, X86_FEATURE_ACPI) || !cpu_has(c, X86_FEATURE_ACC))
+	/* Thermal monitoring depends on APIC, ACPI and clock modulation */
+	if (!cpu_has_apic || !cpu_has(c, X86_FEATURE_ACPI) ||
+		!cpu_has(c, X86_FEATURE_ACC))
 		return;
 
 	/*
@@ -270,7 +285,20 @@
 	 * since it might be delivered via SMI already:
 	 */
 	rdmsr(MSR_IA32_MISC_ENABLE, l, h);
-	h = apic_read(APIC_LVTTHMR);
+
+	/*
+	 * The initial value of thermal LVT entries on all APs always reads
+	 * 0x10000 because APs are woken up by BSP issuing INIT-SIPI-SIPI
+	 * sequence to them and LVT registers are reset to 0s except for
+	 * the mask bits which are set to 1s when APs receive INIT IPI.
+	 * Always restore the value that BIOS has programmed on AP based on
+	 * BSP's info we saved since BIOS is always setting the same value
+	 * for all threads/cores
+	 */
+	apic_write(APIC_LVTTHMR, lvtthmr_init);
+
+	h = lvtthmr_init;
+
 	if ((l & MSR_IA32_MISC_ENABLE_TM1) && (h & APIC_DM_SMI)) {
 		printk(KERN_DEBUG
 		       "CPU%d: Thermal monitoring handled by SMI\n", cpu);
diff -Nur linux-2.6.32-orig/arch/x86/kernel/cpu/perfctr-watchdog.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/perfctr-watchdog.c
--- linux-2.6.32-orig/arch/x86/kernel/cpu/perfctr-watchdog.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpu/perfctr-watchdog.c	2010-11-18 21:05:30.000000000 +0600
@@ -712,7 +712,7 @@
 	switch (boot_cpu_data.x86_vendor) {
 	case X86_VENDOR_AMD:
 		if (boot_cpu_data.x86 != 6 && boot_cpu_data.x86 != 15 &&
-		    boot_cpu_data.x86 != 16)
+		    boot_cpu_data.x86 != 16 && boot_cpu_data.x86 != 17)
 			return;
 		wd_ops = &k7_wd_ops;
 		break;
diff -Nur linux-2.6.32-orig/arch/x86/kernel/cpuid.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpuid.c
--- linux-2.6.32-orig/arch/x86/kernel/cpuid.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/cpuid.c	2010-11-18 21:05:30.000000000 +0600
@@ -192,7 +192,8 @@
 	int i, err = 0;
 	i = 0;
 
-	if (register_chrdev(CPUID_MAJOR, "cpu/cpuid", &cpuid_fops)) {
+	if (__register_chrdev(CPUID_MAJOR, 0, NR_CPUS,
+			      "cpu/cpuid", &cpuid_fops)) {
 		printk(KERN_ERR "cpuid: unable to get major %d for cpuid\n",
 		       CPUID_MAJOR);
 		err = -EBUSY;
@@ -221,7 +222,7 @@
 	}
 	class_destroy(cpuid_class);
 out_chrdev:
-	unregister_chrdev(CPUID_MAJOR, "cpu/cpuid");
+	__unregister_chrdev(CPUID_MAJOR, 0, NR_CPUS, "cpu/cpuid");
 out:
 	return err;
 }
@@ -233,7 +234,7 @@
 	for_each_online_cpu(cpu)
 		cpuid_device_destroy(cpu);
 	class_destroy(cpuid_class);
-	unregister_chrdev(CPUID_MAJOR, "cpu/cpuid");
+	__unregister_chrdev(CPUID_MAJOR, 0, NR_CPUS, "cpu/cpuid");
 	unregister_hotcpu_notifier(&cpuid_class_cpu_notifier);
 }
 
diff -Nur linux-2.6.32-orig/arch/x86/kernel/hpet.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/hpet.c
--- linux-2.6.32-orig/arch/x86/kernel/hpet.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/hpet.c	2010-11-18 21:05:30.000000000 +0600
@@ -33,6 +33,8 @@
  * HPET address is set in acpi/boot.c, when an ACPI entry exists
  */
 unsigned long				hpet_address;
+u8					hpet_msi_disable;
+
 #ifdef CONFIG_PCI_MSI
 static unsigned long			hpet_num_timers;
 #endif
@@ -584,6 +586,9 @@
 	unsigned int num_timers_used = 0;
 	int i;
 
+	if (hpet_msi_disable)
+		return;
+
 	id = hpet_readl(HPET_ID);
 
 	num_timers = ((id & HPET_ID_NUMBER) >> HPET_ID_NUMBER_SHIFT);
@@ -911,6 +916,9 @@
 	hpet_reserve_platform_timers(hpet_readl(HPET_ID));
 	hpet_print_config();
 
+	if (hpet_msi_disable)
+		return 0;
+
 	for_each_online_cpu(cpu) {
 		hpet_cpuhp_notify(NULL, CPU_ONLINE, (void *)(long)cpu);
 	}
diff -Nur linux-2.6.32-orig/arch/x86/kernel/msr.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/msr.c
--- linux-2.6.32-orig/arch/x86/kernel/msr.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/msr.c	2010-11-18 21:05:30.000000000 +0600
@@ -251,7 +251,7 @@
 	int i, err = 0;
 	i = 0;
 
-	if (register_chrdev(MSR_MAJOR, "cpu/msr", &msr_fops)) {
+	if (__register_chrdev(MSR_MAJOR, 0, NR_CPUS, "cpu/msr", &msr_fops)) {
 		printk(KERN_ERR "msr: unable to get major %d for msr\n",
 		       MSR_MAJOR);
 		err = -EBUSY;
@@ -279,7 +279,7 @@
 		msr_device_destroy(i);
 	class_destroy(msr_class);
 out_chrdev:
-	unregister_chrdev(MSR_MAJOR, "cpu/msr");
+	__unregister_chrdev(MSR_MAJOR, 0, NR_CPUS, "cpu/msr");
 out:
 	return err;
 }
@@ -290,7 +290,7 @@
 	for_each_online_cpu(cpu)
 		msr_device_destroy(cpu);
 	class_destroy(msr_class);
-	unregister_chrdev(MSR_MAJOR, "cpu/msr");
+	__unregister_chrdev(MSR_MAJOR, 0, NR_CPUS, "cpu/msr");
 	unregister_hotcpu_notifier(&msr_class_cpu_notifier);
 }
 
diff -Nur linux-2.6.32-orig/arch/x86/kernel/pci-calgary_64.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/pci-calgary_64.c
--- linux-2.6.32-orig/arch/x86/kernel/pci-calgary_64.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/pci-calgary_64.c	2010-11-18 21:05:30.000000000 +0600
@@ -318,13 +318,15 @@
 
 	pdev = to_pci_dev(dev);
 
+	/* search up the device tree for an iommu */
 	pbus = pdev->bus;
-
-	/* is the device behind a bridge? Look for the root bus */
-	while (pbus->parent)
+	do {
+		tbl = pci_iommu(pbus);
+		if (tbl && tbl->it_busno == pbus->number)
+			break;
+		tbl = NULL;
 		pbus = pbus->parent;
-
-	tbl = pci_iommu(pbus);
+	} while (pbus);
 
 	BUG_ON(tbl && (tbl->it_busno != pbus->number));
 
diff -Nur linux-2.6.32-orig/arch/x86/kernel/pci-dma.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/pci-dma.c
--- linux-2.6.32-orig/arch/x86/kernel/pci-dma.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/pci-dma.c	2010-11-18 21:05:30.000000000 +0600
@@ -214,7 +214,7 @@
 		if (!strncmp(p, "allowdac", 8))
 			forbid_dac = 0;
 		if (!strncmp(p, "nodac", 5))
-			forbid_dac = -1;
+			forbid_dac = 1;
 		if (!strncmp(p, "usedac", 6)) {
 			forbid_dac = -1;
 			return 1;
diff -Nur linux-2.6.32-orig/arch/x86/kernel/pci-gart_64.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/pci-gart_64.c
--- linux-2.6.32-orig/arch/x86/kernel/pci-gart_64.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/pci-gart_64.c	2010-11-18 21:05:30.000000000 +0600
@@ -856,7 +856,7 @@
 #endif
 	if (isdigit(*p) && get_option(&p, &arg))
 		iommu_size = arg;
-	if (!strncmp(p, "fullflush", 8))
+	if (!strncmp(p, "fullflush", 9))
 		iommu_fullflush = 1;
 	if (!strncmp(p, "nofullflush", 11))
 		iommu_fullflush = 0;
diff -Nur linux-2.6.32-orig/arch/x86/kernel/process_64.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/process_64.c
--- linux-2.6.32-orig/arch/x86/kernel/process_64.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/process_64.c	2010-11-18 21:05:30.000000000 +0600
@@ -540,6 +540,17 @@
 	return do_fork(clone_flags, newsp, regs, 0, parent_tid, child_tid);
 }
 
+void set_personality_ia32(void)
+{
+	/* inherit personality from parent */
+
+	/* Make sure to be in 32bit mode */
+	set_thread_flag(TIF_IA32);
+
+	/* Prepare the first "return" to user space */
+	current_thread_info()->status |= TS_COMPAT;
+}
+
 unsigned long get_wchan(struct task_struct *p)
 {
 	unsigned long stack;
diff -Nur linux-2.6.32-orig/arch/x86/kernel/process.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/process.c
--- linux-2.6.32-orig/arch/x86/kernel/process.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/process.c	2010-11-18 21:05:30.000000000 +0600
@@ -91,18 +91,6 @@
 {
 	struct task_struct *tsk = current;
 
-#ifdef CONFIG_X86_64
-	if (test_tsk_thread_flag(tsk, TIF_ABI_PENDING)) {
-		clear_tsk_thread_flag(tsk, TIF_ABI_PENDING);
-		if (test_tsk_thread_flag(tsk, TIF_IA32)) {
-			clear_tsk_thread_flag(tsk, TIF_IA32);
-		} else {
-			set_tsk_thread_flag(tsk, TIF_IA32);
-			current_thread_info()->status |= TS_COMPAT;
-		}
-	}
-#endif
-
 	clear_tsk_thread_flag(tsk, TIF_DEBUG);
 
 	tsk->thread.debugreg0 = 0;
diff -Nur linux-2.6.32-orig/arch/x86/kernel/ptrace.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/ptrace.c
--- linux-2.6.32-orig/arch/x86/kernel/ptrace.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/ptrace.c	2010-11-18 21:05:30.000000000 +0600
@@ -408,14 +408,14 @@
 {
 	if (kbuf) {
 		unsigned long *k = kbuf;
-		while (count > 0) {
+		while (count >= sizeof(*k)) {
 			*k++ = getreg(target, pos);
 			count -= sizeof(*k);
 			pos += sizeof(*k);
 		}
 	} else {
 		unsigned long __user *u = ubuf;
-		while (count > 0) {
+		while (count >= sizeof(*u)) {
 			if (__put_user(getreg(target, pos), u++))
 				return -EFAULT;
 			count -= sizeof(*u);
@@ -434,14 +434,14 @@
 	int ret = 0;
 	if (kbuf) {
 		const unsigned long *k = kbuf;
-		while (count > 0 && !ret) {
+		while (count >= sizeof(*k) && !ret) {
 			ret = putreg(target, pos, *k++);
 			count -= sizeof(*k);
 			pos += sizeof(*k);
 		}
 	} else {
 		const unsigned long  __user *u = ubuf;
-		while (count > 0 && !ret) {
+		while (count >= sizeof(*u) && !ret) {
 			unsigned long word;
 			ret = __get_user(word, u++);
 			if (ret)
@@ -1219,14 +1219,14 @@
 {
 	if (kbuf) {
 		compat_ulong_t *k = kbuf;
-		while (count > 0) {
+		while (count >= sizeof(*k)) {
 			getreg32(target, pos, k++);
 			count -= sizeof(*k);
 			pos += sizeof(*k);
 		}
 	} else {
 		compat_ulong_t __user *u = ubuf;
-		while (count > 0) {
+		while (count >= sizeof(*u)) {
 			compat_ulong_t word;
 			getreg32(target, pos, &word);
 			if (__put_user(word, u++))
@@ -1247,14 +1247,14 @@
 	int ret = 0;
 	if (kbuf) {
 		const compat_ulong_t *k = kbuf;
-		while (count > 0 && !ret) {
+		while (count >= sizeof(*k) && !ret) {
 			ret = putreg32(target, pos, *k++);
 			count -= sizeof(*k);
 			pos += sizeof(*k);
 		}
 	} else {
 		const compat_ulong_t __user *u = ubuf;
-		while (count > 0 && !ret) {
+		while (count >= sizeof(*u) && !ret) {
 			compat_ulong_t word;
 			ret = __get_user(word, u++);
 			if (ret)
diff -Nur linux-2.6.32-orig/arch/x86/kernel/quirks.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/quirks.c
--- linux-2.6.32-orig/arch/x86/kernel/quirks.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/quirks.c	2010-11-18 21:05:30.000000000 +0600
@@ -491,6 +491,19 @@
 		break;
 	}
 }
+
+/*
+ * HPET MSI on some boards (ATI SB700/SB800) has side effect on
+ * floppy DMA. Disable HPET MSI on such platforms.
+ */
+static void force_disable_hpet_msi(struct pci_dev *unused)
+{
+	hpet_msi_disable = 1;
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS,
+			 force_disable_hpet_msi);
+
 #endif
 
 #if defined(CONFIG_PCI) && defined(CONFIG_NUMA)
diff -Nur linux-2.6.32-orig/arch/x86/kernel/reboot.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/reboot.c
--- linux-2.6.32-orig/arch/x86/kernel/reboot.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/reboot.c	2010-11-18 21:05:30.000000000 +0600
@@ -203,6 +203,15 @@
 			DMI_MATCH(DMI_BOARD_NAME, "0T656F"),
 		},
 	},
+	{	/* Handle problems with rebooting on Dell OptiPlex 760 with 0G919G*/
+		.callback = set_bios_reboot,
+		.ident = "Dell OptiPlex 760",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 760"),
+			DMI_MATCH(DMI_BOARD_NAME, "0G919G"),
+		},
+	},
 	{	/* Handle problems with rebooting on Dell 2400's */
 		.callback = set_bios_reboot,
 		.ident = "Dell PowerEdge 2400",
@@ -259,6 +268,14 @@
 			DMI_MATCH(DMI_PRODUCT_NAME, "SBC-FITPC2"),
 		},
 	},
+	{       /* Handle problems with rebooting on ASUS P4S800 */
+		.callback = set_bios_reboot,
+		.ident = "ASUS P4S800",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
+			DMI_MATCH(DMI_BOARD_NAME, "P4S800"),
+		},
+	},
 	{ }
 };
 
diff -Nur linux-2.6.32-orig/arch/x86/kernel/setup.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/setup.c
--- linux-2.6.32-orig/arch/x86/kernel/setup.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/setup.c	2010-11-18 21:05:30.000000000 +0600
@@ -109,6 +109,7 @@
 #ifdef CONFIG_X86_64
 #include <asm/numa_64.h>
 #endif
+#include <asm/mce.h>
 
 /*
  * end_pfn only includes RAM, while max_pfn_mapped includes all e820 entries.
@@ -666,19 +667,27 @@
 			DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix/MSC"),
 		},
 	},
-	{
 	/*
-	 * AMI BIOS with low memory corruption was found on Intel DG45ID board.
-	 * It hase different DMI_BIOS_VENDOR = "Intel Corp.", for now we will
+	 * AMI BIOS with low memory corruption was found on Intel DG45ID and
+	 * DG45FC boards.
+	 * It has a different DMI_BIOS_VENDOR = "Intel Corp.", for now we will
 	 * match only DMI_BOARD_NAME and see if there is more bad products
 	 * with this vendor.
 	 */
+	{
 		.callback = dmi_low_memory_corruption,
 		.ident = "AMI BIOS",
 		.matches = {
 			DMI_MATCH(DMI_BOARD_NAME, "DG45ID"),
 		},
 	},
+	{
+		.callback = dmi_low_memory_corruption,
+		.ident = "AMI BIOS",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "DG45FC"),
+		},
+	},
 #endif
 	{}
 };
@@ -1031,6 +1040,8 @@
 #endif
 #endif
 	x86_init.oem.banner();
+
+	mcheck_intel_therm_init();
 }
 
 #ifdef CONFIG_X86_32
diff -Nur linux-2.6.32-orig/arch/x86/kernel/syscall_table_32.S iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/syscall_table_32.S
--- linux-2.6.32-orig/arch/x86/kernel/syscall_table_32.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/syscall_table_32.S	2010-11-18 21:05:30.000000000 +0600
@@ -191,7 +191,7 @@
 	.long sys_ni_syscall	/* reserved for streams2 */
 	.long ptregs_vfork	/* 190 */
 	.long sys_getrlimit
-	.long sys_mmap2
+	.long sys_mmap_pgoff
 	.long sys_truncate64
 	.long sys_ftruncate64
 	.long sys_stat64	/* 195 */
diff -Nur linux-2.6.32-orig/arch/x86/kernel/sys_i386_32.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/sys_i386_32.c
--- linux-2.6.32-orig/arch/x86/kernel/sys_i386_32.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/sys_i386_32.c	2010-11-18 21:05:30.000000000 +0600
@@ -24,31 +24,6 @@
 
 #include <asm/syscalls.h>
 
-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
-			  unsigned long prot, unsigned long flags,
-			  unsigned long fd, unsigned long pgoff)
-{
-	int error = -EBADF;
-	struct file *file = NULL;
-	struct mm_struct *mm = current->mm;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:
-	return error;
-}
-
 /*
  * Perform the select(nd, in, out, ex, tv) and mmap() system
  * calls. Linux/i386 didn't use to be able to handle more than
@@ -77,7 +52,7 @@
 	if (a.offset & ~PAGE_MASK)
 		goto out;
 
-	err = sys_mmap2(a.addr, a.len, a.prot, a.flags,
+	err = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags,
 			a.fd, a.offset >> PAGE_SHIFT);
 out:
 	return err;
diff -Nur linux-2.6.32-orig/arch/x86/kernel/sys_x86_64.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/sys_x86_64.c
--- linux-2.6.32-orig/arch/x86/kernel/sys_x86_64.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/sys_x86_64.c	2010-11-18 21:05:30.000000000 +0600
@@ -23,26 +23,11 @@
 		unsigned long, fd, unsigned long, off)
 {
 	long error;
-	struct file *file;
-
 	error = -EINVAL;
 	if (off & ~PAGE_MASK)
 		goto out;
 
-	error = -EBADF;
-	file = NULL;
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, off >> PAGE_SHIFT);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
+	error = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
 out:
 	return error;
 }
diff -Nur linux-2.6.32-orig/arch/x86/kernel/tlb_uv.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/tlb_uv.c
--- linux-2.6.32-orig/arch/x86/kernel/tlb_uv.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/tlb_uv.c	2010-11-18 21:05:30.000000000 +0600
@@ -817,10 +817,8 @@
 	 */
 	apicid = blade_to_first_apicid(blade);
 	pa = uv_read_global_mmr64(pnode, UVH_BAU_DATA_CONFIG);
-	if ((pa & 0xff) != UV_BAU_MESSAGE) {
-		uv_write_global_mmr64(pnode, UVH_BAU_DATA_CONFIG,
+	uv_write_global_mmr64(pnode, UVH_BAU_DATA_CONFIG,
 				      ((apicid << 32) | UV_BAU_MESSAGE));
-	}
 	return 0;
 }
 
diff -Nur linux-2.6.32-orig/arch/x86/kernel/tsc.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/tsc.c
--- linux-2.6.32-orig/arch/x86/kernel/tsc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kernel/tsc.c	2010-11-18 21:05:30.000000000 +0600
@@ -763,6 +763,7 @@
 {
 	if (!tsc_unstable) {
 		tsc_unstable = 1;
+		sched_clock_stable = 0;
 		printk(KERN_INFO "Marking TSC unstable due to %s\n", reason);
 		/* Change only the rating, when not registered */
 		if (clocksource_tsc.mult)
diff -Nur linux-2.6.32-orig/arch/x86/kvm/emulate.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kvm/emulate.c
--- linux-2.6.32-orig/arch/x86/kvm/emulate.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kvm/emulate.c	2010-11-18 21:05:30.000000000 +0600
@@ -613,6 +613,9 @@
 {
 	int rc = 0;
 
+	/* x86 instructions are limited to 15 bytes. */
+	if (eip + size - ctxt->decode.eip_orig > 15)
+		return X86EMUL_UNHANDLEABLE;
 	eip += ctxt->cs_base;
 	while (size--) {
 		rc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);
@@ -871,7 +874,7 @@
 	/* Shadow copy of register state. Committed on successful emulation. */
 
 	memset(c, 0, sizeof(struct decode_cache));
-	c->eip = kvm_rip_read(ctxt->vcpu);
+	c->eip = c->eip_orig = kvm_rip_read(ctxt->vcpu);
 	ctxt->cs_base = seg_base(ctxt, VCPU_SREG_CS);
 	memcpy(c->regs, ctxt->vcpu->arch.regs, sizeof c->regs);
 
diff -Nur linux-2.6.32-orig/arch/x86/kvm/i8254.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kvm/i8254.c
--- linux-2.6.32-orig/arch/x86/kvm/i8254.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kvm/i8254.c	2010-11-18 21:05:30.000000000 +0600
@@ -465,6 +465,9 @@
 		return -EOPNOTSUPP;
 
 	addr &= KVM_PIT_CHANNEL_MASK;
+	if (addr == 3)
+		return 0;
+
 	s = &pit_state->channels[addr];
 
 	mutex_lock(&pit_state->lock);
diff -Nur linux-2.6.32-orig/arch/x86/kvm/lapic.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kvm/lapic.c
--- linux-2.6.32-orig/arch/x86/kvm/lapic.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kvm/lapic.c	2010-11-18 21:05:30.000000000 +0600
@@ -374,6 +374,12 @@
 		if (unlikely(!apic_enabled(apic)))
 			break;
 
+		if (trig_mode) {
+			apic_debug("level trig mode for vector %d", vector);
+			apic_set_vector(vector, apic->regs + APIC_TMR);
+		} else
+			apic_clear_vector(vector, apic->regs + APIC_TMR);
+
 		result = !apic_test_and_set_irr(vector, apic);
 		trace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,
 					  trig_mode, vector, !result);
@@ -384,11 +390,6 @@
 			break;
 		}
 
-		if (trig_mode) {
-			apic_debug("level trig mode for vector %d", vector);
-			apic_set_vector(vector, apic->regs + APIC_TMR);
-		} else
-			apic_clear_vector(vector, apic->regs + APIC_TMR);
 		kvm_vcpu_kick(vcpu);
 		break;
 
@@ -1156,6 +1157,7 @@
 	hrtimer_cancel(&apic->lapic_timer.timer);
 	update_divide_count(apic);
 	start_apic_timer(apic);
+	apic->irr_pending = true;
 }
 
 void __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)
diff -Nur linux-2.6.32-orig/arch/x86/kvm/mmu.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kvm/mmu.c
--- linux-2.6.32-orig/arch/x86/kvm/mmu.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kvm/mmu.c	2010-11-18 21:05:30.000000000 +0600
@@ -477,7 +477,7 @@
 
 	addr = gfn_to_hva(kvm, gfn);
 	if (kvm_is_error_hva(addr))
-		return page_size;
+		return PT_PAGE_TABLE_LEVEL;
 
 	down_read(&current->mm->mmap_sem);
 	vma = find_vma(current->mm, addr);
@@ -515,11 +515,9 @@
 	if (host_level == PT_PAGE_TABLE_LEVEL)
 		return host_level;
 
-	for (level = PT_DIRECTORY_LEVEL; level <= host_level; ++level) {
-
+	for (level = PT_DIRECTORY_LEVEL; level <= host_level; ++level)
 		if (has_wrprotected_page(vcpu->kvm, large_gfn, level))
 			break;
-	}
 
 	return level - 1;
 }
diff -Nur linux-2.6.32-orig/arch/x86/kvm/paging_tmpl.h iDroid-Project-kernel_common-9e90fd2/arch/x86/kvm/paging_tmpl.h
--- linux-2.6.32-orig/arch/x86/kvm/paging_tmpl.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kvm/paging_tmpl.h	2010-11-18 21:05:30.000000000 +0600
@@ -150,7 +150,9 @@
 		walker->table_gfn[walker->level - 1] = table_gfn;
 		walker->pte_gpa[walker->level - 1] = pte_gpa;
 
-		kvm_read_guest(vcpu->kvm, pte_gpa, &pte, sizeof(pte));
+		if (kvm_read_guest(vcpu->kvm, pte_gpa, &pte, sizeof(pte)))
+			goto not_present;
+
 		trace_kvm_mmu_paging_element(pte, walker->level);
 
 		if (!is_present_gpte(pte))
@@ -455,8 +457,6 @@
 static void FNAME(invlpg)(struct kvm_vcpu *vcpu, gva_t gva)
 {
 	struct kvm_shadow_walk_iterator iterator;
-	pt_element_t gpte;
-	gpa_t pte_gpa = -1;
 	int level;
 	u64 *sptep;
 	int need_flush = 0;
@@ -471,10 +471,6 @@
 		if (level == PT_PAGE_TABLE_LEVEL  ||
 		    ((level == PT_DIRECTORY_LEVEL && is_large_pte(*sptep))) ||
 		    ((level == PT_PDPE_LEVEL && is_large_pte(*sptep)))) {
-			struct kvm_mmu_page *sp = page_header(__pa(sptep));
-
-			pte_gpa = (sp->gfn << PAGE_SHIFT);
-			pte_gpa += (sptep - sp->spt) * sizeof(pt_element_t);
 
 			if (is_shadow_present_pte(*sptep)) {
 				rmap_remove(vcpu->kvm, sptep);
@@ -493,18 +489,6 @@
 	if (need_flush)
 		kvm_flush_remote_tlbs(vcpu->kvm);
 	spin_unlock(&vcpu->kvm->mmu_lock);
-
-	if (pte_gpa == -1)
-		return;
-	if (kvm_read_guest_atomic(vcpu->kvm, pte_gpa, &gpte,
-				  sizeof(pt_element_t)))
-		return;
-	if (is_present_gpte(gpte) && (gpte & PT_ACCESSED_MASK)) {
-		if (mmu_topup_memory_caches(vcpu))
-			return;
-		kvm_mmu_pte_write(vcpu, pte_gpa, (const u8 *)&gpte,
-				  sizeof(pt_element_t), 0);
-	}
 }
 
 static gpa_t FNAME(gva_to_gpa)(struct kvm_vcpu *vcpu, gva_t vaddr)
diff -Nur linux-2.6.32-orig/arch/x86/kvm/x86.c iDroid-Project-kernel_common-9e90fd2/arch/x86/kvm/x86.c
--- linux-2.6.32-orig/arch/x86/kvm/x86.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/kvm/x86.c	2010-11-18 21:05:30.000000000 +0600
@@ -484,16 +484,19 @@
  * and KVM_SET_MSRS, and KVM_GET_MSR_INDEX_LIST.
  *
  * This list is modified at module load time to reflect the
- * capabilities of the host cpu.
+ * capabilities of the host cpu. This capabilities test skips MSRs that are
+ * kvm-specific. Those are put in the beginning of the list.
  */
+
+#define KVM_SAVE_MSRS_BEGIN	2
 static u32 msrs_to_save[] = {
+	MSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,
 	MSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,
 	MSR_K6_STAR,
 #ifdef CONFIG_X86_64
 	MSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,
 #endif
-	MSR_IA32_TSC, MSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,
-	MSR_IA32_PERF_STATUS, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA
+	MSR_IA32_TSC, MSR_IA32_PERF_STATUS, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA
 };
 
 static unsigned num_msrs_to_save;
@@ -580,7 +583,7 @@
 {
 	static int version;
 	struct pvclock_wall_clock wc;
-	struct timespec now, sys, boot;
+	struct timespec boot;
 
 	if (!wall_clock)
 		return;
@@ -595,9 +598,7 @@
 	 * wall clock specified here.  guest system time equals host
 	 * system time for us, thus we must fill in host boot time here.
 	 */
-	now = current_kernel_time();
-	ktime_get_ts(&sys);
-	boot = ns_to_timespec(timespec_to_ns(&now) - timespec_to_ns(&sys));
+	getboottime(&boot);
 
 	wc.sec = boot.tv_sec;
 	wc.nsec = boot.tv_nsec;
@@ -672,12 +673,14 @@
 	local_irq_save(flags);
 	kvm_get_msr(v, MSR_IA32_TSC, &vcpu->hv_clock.tsc_timestamp);
 	ktime_get_ts(&ts);
+	monotonic_to_bootbased(&ts);
 	local_irq_restore(flags);
 
 	/* With all the info we got, fill in the values */
 
 	vcpu->hv_clock.system_time = ts.tv_nsec +
-				     (NSEC_PER_SEC * (u64)ts.tv_sec);
+				     (NSEC_PER_SEC * (u64)ts.tv_sec) + v->kvm->arch.kvmclock_offset;
+
 	/*
 	 * The interface expects us to write an even number signaling that the
 	 * update is finished. Since the guest won't see the intermediate
@@ -1224,6 +1227,7 @@
 	case KVM_CAP_PIT2:
 	case KVM_CAP_PIT_STATE2:
 	case KVM_CAP_SET_IDENTITY_MAP_ADDR:
+	case KVM_CAP_ADJUST_CLOCK:
 		r = 1;
 		break;
 	case KVM_CAP_COALESCED_MMIO:
@@ -2421,6 +2425,44 @@
 		r = 0;
 		break;
 	}
+	case KVM_SET_CLOCK: {
+		struct timespec now;
+		struct kvm_clock_data user_ns;
+		u64 now_ns;
+		s64 delta;
+
+		r = -EFAULT;
+		if (copy_from_user(&user_ns, argp, sizeof(user_ns)))
+			goto out;
+
+		r = -EINVAL;
+		if (user_ns.flags)
+			goto out;
+
+		r = 0;
+		ktime_get_ts(&now);
+		now_ns = timespec_to_ns(&now);
+		delta = user_ns.clock - now_ns;
+		kvm->arch.kvmclock_offset = delta;
+		break;
+	}
+	case KVM_GET_CLOCK: {
+		struct timespec now;
+		struct kvm_clock_data user_ns;
+		u64 now_ns;
+
+		ktime_get_ts(&now);
+		now_ns = timespec_to_ns(&now);
+		user_ns.clock = kvm->arch.kvmclock_offset + now_ns;
+		user_ns.flags = 0;
+
+		r = -EFAULT;
+		if (copy_to_user(argp, &user_ns, sizeof(user_ns)))
+			goto out;
+		r = 0;
+		break;
+	}
+
 	default:
 		;
 	}
@@ -2433,7 +2475,8 @@
 	u32 dummy[2];
 	unsigned i, j;
 
-	for (i = j = 0; i < ARRAY_SIZE(msrs_to_save); i++) {
+	/* skip the first msrs in the list. KVM-specific */
+	for (i = j = KVM_SAVE_MSRS_BEGIN; i < ARRAY_SIZE(msrs_to_save); i++) {
 		if (rdmsr_safe(msrs_to_save[i], &dummy[0], &dummy[1]) < 0)
 			continue;
 		if (j < i)
@@ -4762,12 +4805,13 @@
 				       GFP_KERNEL);
 	if (!vcpu->arch.mce_banks) {
 		r = -ENOMEM;
-		goto fail_mmu_destroy;
+		goto fail_free_lapic;
 	}
 	vcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;
 
 	return 0;
-
+fail_free_lapic:
+	kvm_free_lapic(vcpu);
 fail_mmu_destroy:
 	kvm_mmu_destroy(vcpu);
 fail_free_pio_data:
@@ -4778,6 +4822,7 @@
 
 void kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)
 {
+	kfree(vcpu->arch.mce_banks);
 	kvm_free_lapic(vcpu);
 	down_read(&vcpu->kvm->slots_lock);
 	kvm_mmu_destroy(vcpu);
diff -Nur linux-2.6.32-orig/arch/x86/lib/Makefile iDroid-Project-kernel_common-9e90fd2/arch/x86/lib/Makefile
--- linux-2.6.32-orig/arch/x86/lib/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/lib/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -2,14 +2,14 @@
 # Makefile for x86 specific library files.
 #
 
-obj-$(CONFIG_SMP) := msr.o
+obj-$(CONFIG_SMP) += msr-smp.o
 
 lib-y := delay.o
 lib-y += thunk_$(BITS).o
 lib-y += usercopy_$(BITS).o getuser.o putuser.o
 lib-y += memcpy_$(BITS).o
 
-obj-y += msr-reg.o msr-reg-export.o
+obj-y += msr.o msr-reg.o msr-reg-export.o
 
 ifeq ($(CONFIG_X86_32),y)
         obj-y += atomic64_32.o
diff -Nur linux-2.6.32-orig/arch/x86/lib/msr.c iDroid-Project-kernel_common-9e90fd2/arch/x86/lib/msr.c
--- linux-2.6.32-orig/arch/x86/lib/msr.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/lib/msr.c	2010-11-18 21:05:30.000000000 +0600
@@ -1,226 +1,23 @@
 #include <linux/module.h>
 #include <linux/preempt.h>
-#include <linux/smp.h>
 #include <asm/msr.h>
 
-struct msr_info {
-	u32 msr_no;
-	struct msr reg;
-	struct msr *msrs;
-	int off;
-	int err;
-};
-
-static void __rdmsr_on_cpu(void *info)
-{
-	struct msr_info *rv = info;
-	struct msr *reg;
-	int this_cpu = raw_smp_processor_id();
-
-	if (rv->msrs)
-		reg = &rv->msrs[this_cpu - rv->off];
-	else
-		reg = &rv->reg;
-
-	rdmsr(rv->msr_no, reg->l, reg->h);
-}
-
-static void __wrmsr_on_cpu(void *info)
-{
-	struct msr_info *rv = info;
-	struct msr *reg;
-	int this_cpu = raw_smp_processor_id();
-
-	if (rv->msrs)
-		reg = &rv->msrs[this_cpu - rv->off];
-	else
-		reg = &rv->reg;
-
-	wrmsr(rv->msr_no, reg->l, reg->h);
-}
-
-int rdmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h)
-{
-	int err;
-	struct msr_info rv;
-
-	memset(&rv, 0, sizeof(rv));
-
-	rv.msr_no = msr_no;
-	err = smp_call_function_single(cpu, __rdmsr_on_cpu, &rv, 1);
-	*l = rv.reg.l;
-	*h = rv.reg.h;
-
-	return err;
-}
-EXPORT_SYMBOL(rdmsr_on_cpu);
-
-int wrmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h)
-{
-	int err;
-	struct msr_info rv;
-
-	memset(&rv, 0, sizeof(rv));
-
-	rv.msr_no = msr_no;
-	rv.reg.l = l;
-	rv.reg.h = h;
-	err = smp_call_function_single(cpu, __wrmsr_on_cpu, &rv, 1);
-
-	return err;
-}
-EXPORT_SYMBOL(wrmsr_on_cpu);
-
-/* rdmsr on a bunch of CPUs
- *
- * @mask:       which CPUs
- * @msr_no:     which MSR
- * @msrs:       array of MSR values
- *
- */
-void rdmsr_on_cpus(const cpumask_t *mask, u32 msr_no, struct msr *msrs)
-{
-	struct msr_info rv;
-	int this_cpu;
-
-	memset(&rv, 0, sizeof(rv));
-
-	rv.off    = cpumask_first(mask);
-	rv.msrs	  = msrs;
-	rv.msr_no = msr_no;
-
-	this_cpu = get_cpu();
-
-	if (cpumask_test_cpu(this_cpu, mask))
-		__rdmsr_on_cpu(&rv);
-
-	smp_call_function_many(mask, __rdmsr_on_cpu, &rv, 1);
-	put_cpu();
-}
-EXPORT_SYMBOL(rdmsr_on_cpus);
-
-/*
- * wrmsr on a bunch of CPUs
- *
- * @mask:       which CPUs
- * @msr_no:     which MSR
- * @msrs:       array of MSR values
- *
- */
-void wrmsr_on_cpus(const cpumask_t *mask, u32 msr_no, struct msr *msrs)
-{
-	struct msr_info rv;
-	int this_cpu;
-
-	memset(&rv, 0, sizeof(rv));
-
-	rv.off    = cpumask_first(mask);
-	rv.msrs   = msrs;
-	rv.msr_no = msr_no;
-
-	this_cpu = get_cpu();
-
-	if (cpumask_test_cpu(this_cpu, mask))
-		__wrmsr_on_cpu(&rv);
-
-	smp_call_function_many(mask, __wrmsr_on_cpu, &rv, 1);
-	put_cpu();
-}
-EXPORT_SYMBOL(wrmsr_on_cpus);
-
-/* These "safe" variants are slower and should be used when the target MSR
-   may not actually exist. */
-static void __rdmsr_safe_on_cpu(void *info)
-{
-	struct msr_info *rv = info;
-
-	rv->err = rdmsr_safe(rv->msr_no, &rv->reg.l, &rv->reg.h);
-}
-
-static void __wrmsr_safe_on_cpu(void *info)
-{
-	struct msr_info *rv = info;
-
-	rv->err = wrmsr_safe(rv->msr_no, rv->reg.l, rv->reg.h);
-}
-
-int rdmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h)
+struct msr *msrs_alloc(void)
 {
-	int err;
-	struct msr_info rv;
+	struct msr *msrs = NULL;
 
-	memset(&rv, 0, sizeof(rv));
+	msrs = alloc_percpu(struct msr);
+	if (!msrs) {
+		pr_warning("%s: error allocating msrs\n", __func__);
+		return NULL;
+	}
 
-	rv.msr_no = msr_no;
-	err = smp_call_function_single(cpu, __rdmsr_safe_on_cpu, &rv, 1);
-	*l = rv.reg.l;
-	*h = rv.reg.h;
-
-	return err ? err : rv.err;
+	return msrs;
 }
-EXPORT_SYMBOL(rdmsr_safe_on_cpu);
+EXPORT_SYMBOL(msrs_alloc);
 
-int wrmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h)
+void msrs_free(struct msr *msrs)
 {
-	int err;
-	struct msr_info rv;
-
-	memset(&rv, 0, sizeof(rv));
-
-	rv.msr_no = msr_no;
-	rv.reg.l = l;
-	rv.reg.h = h;
-	err = smp_call_function_single(cpu, __wrmsr_safe_on_cpu, &rv, 1);
-
-	return err ? err : rv.err;
-}
-EXPORT_SYMBOL(wrmsr_safe_on_cpu);
-
-/*
- * These variants are significantly slower, but allows control over
- * the entire 32-bit GPR set.
- */
-struct msr_regs_info {
-	u32 *regs;
-	int err;
-};
-
-static void __rdmsr_safe_regs_on_cpu(void *info)
-{
-	struct msr_regs_info *rv = info;
-
-	rv->err = rdmsr_safe_regs(rv->regs);
-}
-
-static void __wrmsr_safe_regs_on_cpu(void *info)
-{
-	struct msr_regs_info *rv = info;
-
-	rv->err = wrmsr_safe_regs(rv->regs);
-}
-
-int rdmsr_safe_regs_on_cpu(unsigned int cpu, u32 *regs)
-{
-	int err;
-	struct msr_regs_info rv;
-
-	rv.regs   = regs;
-	rv.err    = -EIO;
-	err = smp_call_function_single(cpu, __rdmsr_safe_regs_on_cpu, &rv, 1);
-
-	return err ? err : rv.err;
-}
-EXPORT_SYMBOL(rdmsr_safe_regs_on_cpu);
-
-int wrmsr_safe_regs_on_cpu(unsigned int cpu, u32 *regs)
-{
-	int err;
-	struct msr_regs_info rv;
-
-	rv.regs = regs;
-	rv.err  = -EIO;
-	err = smp_call_function_single(cpu, __wrmsr_safe_regs_on_cpu, &rv, 1);
-
-	return err ? err : rv.err;
+	free_percpu(msrs);
 }
-EXPORT_SYMBOL(wrmsr_safe_regs_on_cpu);
+EXPORT_SYMBOL(msrs_free);
diff -Nur linux-2.6.32-orig/arch/x86/lib/msr-smp.c iDroid-Project-kernel_common-9e90fd2/arch/x86/lib/msr-smp.c
--- linux-2.6.32-orig/arch/x86/lib/msr-smp.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/lib/msr-smp.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,204 @@
+#include <linux/module.h>
+#include <linux/preempt.h>
+#include <linux/smp.h>
+#include <asm/msr.h>
+
+static void __rdmsr_on_cpu(void *info)
+{
+	struct msr_info *rv = info;
+	struct msr *reg;
+	int this_cpu = raw_smp_processor_id();
+
+	if (rv->msrs)
+		reg = per_cpu_ptr(rv->msrs, this_cpu);
+	else
+		reg = &rv->reg;
+
+	rdmsr(rv->msr_no, reg->l, reg->h);
+}
+
+static void __wrmsr_on_cpu(void *info)
+{
+	struct msr_info *rv = info;
+	struct msr *reg;
+	int this_cpu = raw_smp_processor_id();
+
+	if (rv->msrs)
+		reg = per_cpu_ptr(rv->msrs, this_cpu);
+	else
+		reg = &rv->reg;
+
+	wrmsr(rv->msr_no, reg->l, reg->h);
+}
+
+int rdmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h)
+{
+	int err;
+	struct msr_info rv;
+
+	memset(&rv, 0, sizeof(rv));
+
+	rv.msr_no = msr_no;
+	err = smp_call_function_single(cpu, __rdmsr_on_cpu, &rv, 1);
+	*l = rv.reg.l;
+	*h = rv.reg.h;
+
+	return err;
+}
+EXPORT_SYMBOL(rdmsr_on_cpu);
+
+int wrmsr_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h)
+{
+	int err;
+	struct msr_info rv;
+
+	memset(&rv, 0, sizeof(rv));
+
+	rv.msr_no = msr_no;
+	rv.reg.l = l;
+	rv.reg.h = h;
+	err = smp_call_function_single(cpu, __wrmsr_on_cpu, &rv, 1);
+
+	return err;
+}
+EXPORT_SYMBOL(wrmsr_on_cpu);
+
+static void __rwmsr_on_cpus(const struct cpumask *mask, u32 msr_no,
+			    struct msr *msrs,
+			    void (*msr_func) (void *info))
+{
+	struct msr_info rv;
+	int this_cpu;
+
+	memset(&rv, 0, sizeof(rv));
+
+	rv.msrs	  = msrs;
+	rv.msr_no = msr_no;
+
+	this_cpu = get_cpu();
+
+	if (cpumask_test_cpu(this_cpu, mask))
+		msr_func(&rv);
+
+	smp_call_function_many(mask, msr_func, &rv, 1);
+	put_cpu();
+}
+
+/* rdmsr on a bunch of CPUs
+ *
+ * @mask:       which CPUs
+ * @msr_no:     which MSR
+ * @msrs:       array of MSR values
+ *
+ */
+void rdmsr_on_cpus(const struct cpumask *mask, u32 msr_no, struct msr *msrs)
+{
+	__rwmsr_on_cpus(mask, msr_no, msrs, __rdmsr_on_cpu);
+}
+EXPORT_SYMBOL(rdmsr_on_cpus);
+
+/*
+ * wrmsr on a bunch of CPUs
+ *
+ * @mask:       which CPUs
+ * @msr_no:     which MSR
+ * @msrs:       array of MSR values
+ *
+ */
+void wrmsr_on_cpus(const struct cpumask *mask, u32 msr_no, struct msr *msrs)
+{
+	__rwmsr_on_cpus(mask, msr_no, msrs, __wrmsr_on_cpu);
+}
+EXPORT_SYMBOL(wrmsr_on_cpus);
+
+/* These "safe" variants are slower and should be used when the target MSR
+   may not actually exist. */
+static void __rdmsr_safe_on_cpu(void *info)
+{
+	struct msr_info *rv = info;
+
+	rv->err = rdmsr_safe(rv->msr_no, &rv->reg.l, &rv->reg.h);
+}
+
+static void __wrmsr_safe_on_cpu(void *info)
+{
+	struct msr_info *rv = info;
+
+	rv->err = wrmsr_safe(rv->msr_no, rv->reg.l, rv->reg.h);
+}
+
+int rdmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 *l, u32 *h)
+{
+	int err;
+	struct msr_info rv;
+
+	memset(&rv, 0, sizeof(rv));
+
+	rv.msr_no = msr_no;
+	err = smp_call_function_single(cpu, __rdmsr_safe_on_cpu, &rv, 1);
+	*l = rv.reg.l;
+	*h = rv.reg.h;
+
+	return err ? err : rv.err;
+}
+EXPORT_SYMBOL(rdmsr_safe_on_cpu);
+
+int wrmsr_safe_on_cpu(unsigned int cpu, u32 msr_no, u32 l, u32 h)
+{
+	int err;
+	struct msr_info rv;
+
+	memset(&rv, 0, sizeof(rv));
+
+	rv.msr_no = msr_no;
+	rv.reg.l = l;
+	rv.reg.h = h;
+	err = smp_call_function_single(cpu, __wrmsr_safe_on_cpu, &rv, 1);
+
+	return err ? err : rv.err;
+}
+EXPORT_SYMBOL(wrmsr_safe_on_cpu);
+
+/*
+ * These variants are significantly slower, but allows control over
+ * the entire 32-bit GPR set.
+ */
+static void __rdmsr_safe_regs_on_cpu(void *info)
+{
+	struct msr_regs_info *rv = info;
+
+	rv->err = rdmsr_safe_regs(rv->regs);
+}
+
+static void __wrmsr_safe_regs_on_cpu(void *info)
+{
+	struct msr_regs_info *rv = info;
+
+	rv->err = wrmsr_safe_regs(rv->regs);
+}
+
+int rdmsr_safe_regs_on_cpu(unsigned int cpu, u32 *regs)
+{
+	int err;
+	struct msr_regs_info rv;
+
+	rv.regs   = regs;
+	rv.err    = -EIO;
+	err = smp_call_function_single(cpu, __rdmsr_safe_regs_on_cpu, &rv, 1);
+
+	return err ? err : rv.err;
+}
+EXPORT_SYMBOL(rdmsr_safe_regs_on_cpu);
+
+int wrmsr_safe_regs_on_cpu(unsigned int cpu, u32 *regs)
+{
+	int err;
+	struct msr_regs_info rv;
+
+	rv.regs = regs;
+	rv.err  = -EIO;
+	err = smp_call_function_single(cpu, __wrmsr_safe_regs_on_cpu, &rv, 1);
+
+	return err ? err : rv.err;
+}
+EXPORT_SYMBOL(wrmsr_safe_regs_on_cpu);
diff -Nur linux-2.6.32-orig/arch/x86/Makefile_32.cpu iDroid-Project-kernel_common-9e90fd2/arch/x86/Makefile_32.cpu
--- linux-2.6.32-orig/arch/x86/Makefile_32.cpu	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/Makefile_32.cpu	2010-11-18 21:05:30.000000000 +0600
@@ -46,6 +46,13 @@
 # cpu entries
 cflags-$(CONFIG_X86_GENERIC) 	+= $(call tune,generic,$(call tune,i686))
 
+# Work around the pentium-mmx code generator madness of gcc4.4.x which
+# does stack alignment by generating horrible code _before_ the mcount
+# prologue (push %ebp, mov %esp, %ebp) which breaks the function graph
+# tracer assumptions. For i686, generic, core2 this is set by the
+# compiler anyway
+cflags-$(CONFIG_FUNCTION_GRAPH_TRACER) += $(call cc-option,-maccumulate-outgoing-args)
+
 # Bug fix for binutils: this option is required in order to keep
 # binutils from generating NOPL instructions against our will.
 ifneq ($(CONFIG_X86_P6_NOP),y)
diff -Nur linux-2.6.32-orig/arch/x86/mm/srat_64.c iDroid-Project-kernel_common-9e90fd2/arch/x86/mm/srat_64.c
--- linux-2.6.32-orig/arch/x86/mm/srat_64.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/mm/srat_64.c	2010-11-18 21:05:30.000000000 +0600
@@ -229,9 +229,11 @@
 			printk(KERN_ERR "SRAT: Hotplug zone not continuous. Partly ignored\n");
 	}
 
-	if (changed)
+	if (changed) {
+		node_set(node, cpu_nodes_parsed);
 		printk(KERN_INFO "SRAT: hot plug zone found %Lx - %Lx\n",
 				 nd->start, nd->end);
+	}
 }
 
 /* Callback for parsing of the Proximity Domain <-> Memory Area mappings */
diff -Nur linux-2.6.32-orig/arch/x86/oprofile/nmi_int.c iDroid-Project-kernel_common-9e90fd2/arch/x86/oprofile/nmi_int.c
--- linux-2.6.32-orig/arch/x86/oprofile/nmi_int.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/oprofile/nmi_int.c	2010-11-18 21:05:30.000000000 +0600
@@ -222,7 +222,7 @@
 
 	/* move to next set */
 	si += model->num_counters;
-	if ((si > model->num_virt_counters) || (counter_config[si].count == 0))
+	if ((si >= model->num_virt_counters) || (counter_config[si].count == 0))
 		per_cpu(switch_index, cpu) = 0;
 	else
 		per_cpu(switch_index, cpu) = si;
@@ -598,6 +598,7 @@
 	case 15: case 23:
 		*cpu_type = "i386/core_2";
 		break;
+	case 0x2e:
 	case 26:
 		spec = &op_arch_perfmon_spec;
 		*cpu_type = "i386/core_i7";
diff -Nur linux-2.6.32-orig/arch/x86/pci/i386.c iDroid-Project-kernel_common-9e90fd2/arch/x86/pci/i386.c
--- linux-2.6.32-orig/arch/x86/pci/i386.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/pci/i386.c	2010-11-18 21:05:30.000000000 +0600
@@ -282,6 +282,15 @@
 		return -EINVAL;
 
 	prot = pgprot_val(vma->vm_page_prot);
+
+	/*
+ 	 * Return error if pat is not enabled and write_combine is requested.
+ 	 * Caller can followup with UC MINUS request and add a WC mtrr if there
+ 	 * is a free mtrr slot.
+ 	 */
+	if (!pat_enabled && write_combine)
+		return -EINVAL;
+
 	if (pat_enabled && write_combine)
 		prot |= _PAGE_CACHE_WC;
 	else if (pat_enabled || boot_cpu_data.x86 > 3)
diff -Nur linux-2.6.32-orig/arch/x86/xen/enlighten.c iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/enlighten.c
--- linux-2.6.32-orig/arch/x86/xen/enlighten.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/enlighten.c	2010-11-18 21:05:30.000000000 +0600
@@ -138,24 +138,23 @@
  */
 void xen_vcpu_restore(void)
 {
-	if (have_vcpu_info_placement) {
-		int cpu;
+	int cpu;
 
-		for_each_online_cpu(cpu) {
-			bool other_cpu = (cpu != smp_processor_id());
+	for_each_online_cpu(cpu) {
+		bool other_cpu = (cpu != smp_processor_id());
 
-			if (other_cpu &&
-			    HYPERVISOR_vcpu_op(VCPUOP_down, cpu, NULL))
-				BUG();
+		if (other_cpu &&
+		    HYPERVISOR_vcpu_op(VCPUOP_down, cpu, NULL))
+			BUG();
 
-			xen_vcpu_setup(cpu);
+		xen_setup_runstate_info(cpu);
 
-			if (other_cpu &&
-			    HYPERVISOR_vcpu_op(VCPUOP_up, cpu, NULL))
-				BUG();
-		}
+		if (have_vcpu_info_placement)
+			xen_vcpu_setup(cpu);
 
-		BUG_ON(!have_vcpu_info_placement);
+		if (other_cpu &&
+		    HYPERVISOR_vcpu_op(VCPUOP_up, cpu, NULL))
+			BUG();
 	}
 }
 
@@ -1182,6 +1181,8 @@
 
 	xen_raw_console_write("about to get started...\n");
 
+	xen_setup_runstate_info(0);
+
 	/* Start the world */
 #ifdef CONFIG_X86_32
 	i386_start_kernel();
diff -Nur linux-2.6.32-orig/arch/x86/xen/mmu.c iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/mmu.c
--- linux-2.6.32-orig/arch/x86/xen/mmu.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/mmu.c	2010-11-18 21:05:30.000000000 +0600
@@ -185,7 +185,7 @@
 }
 
 /* Build the parallel p2m_top_mfn structures */
-static void __init xen_build_mfn_list_list(void)
+void xen_build_mfn_list_list(void)
 {
 	unsigned pfn, idx;
 
diff -Nur linux-2.6.32-orig/arch/x86/xen/smp.c iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/smp.c
--- linux-2.6.32-orig/arch/x86/xen/smp.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/smp.c	2010-11-18 21:05:30.000000000 +0600
@@ -295,6 +295,7 @@
 		(unsigned long)task_stack_page(idle) -
 		KERNEL_STACK_OFFSET + THREAD_SIZE;
 #endif
+	xen_setup_runstate_info(cpu);
 	xen_setup_timer(cpu);
 	xen_init_lock_cpu(cpu);
 
diff -Nur linux-2.6.32-orig/arch/x86/xen/suspend.c iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/suspend.c
--- linux-2.6.32-orig/arch/x86/xen/suspend.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/suspend.c	2010-11-18 21:05:30.000000000 +0600
@@ -1,4 +1,5 @@
 #include <linux/types.h>
+#include <linux/clockchips.h>
 
 #include <xen/interface/xen.h>
 #include <xen/grant_table.h>
@@ -27,6 +28,8 @@
 
 void xen_post_suspend(int suspend_cancelled)
 {
+	xen_build_mfn_list_list();
+
 	xen_setup_shared_info();
 
 	if (suspend_cancelled) {
@@ -44,7 +47,19 @@
 
 }
 
+static void xen_vcpu_notify_restore(void *data)
+{
+	unsigned long reason = (unsigned long)data;
+
+	/* Boot processor notified via generic timekeeping_resume() */
+	if ( smp_processor_id() == 0)
+		return;
+
+	clockevents_notify(reason, NULL);
+}
+
 void xen_arch_resume(void)
 {
-	/* nothing */
+	smp_call_function(xen_vcpu_notify_restore,
+			       (void *)CLOCK_EVT_NOTIFY_RESUME, 1);
 }
diff -Nur linux-2.6.32-orig/arch/x86/xen/time.c iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/time.c
--- linux-2.6.32-orig/arch/x86/xen/time.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/time.c	2010-11-18 21:05:30.000000000 +0600
@@ -100,7 +100,7 @@
 	return per_cpu(runstate, vcpu).state == RUNSTATE_runnable;
 }
 
-static void setup_runstate_info(int cpu)
+void xen_setup_runstate_info(int cpu)
 {
 	struct vcpu_register_runstate_memory_area area;
 
@@ -434,7 +434,7 @@
 		name = "<timer kasprintf failed>";
 
 	irq = bind_virq_to_irqhandler(VIRQ_TIMER, cpu, xen_timer_interrupt,
-				      IRQF_DISABLED|IRQF_PERCPU|IRQF_NOBALANCING,
+				      IRQF_DISABLED|IRQF_PERCPU|IRQF_NOBALANCING|IRQF_TIMER,
 				      name, NULL);
 
 	evt = &per_cpu(xen_clock_events, cpu);
@@ -442,8 +442,6 @@
 
 	evt->cpumask = cpumask_of(cpu);
 	evt->irq = irq;
-
-	setup_runstate_info(cpu);
 }
 
 void xen_teardown_timer(int cpu)
@@ -494,6 +492,7 @@
 
 	setup_force_cpu_cap(X86_FEATURE_TSC);
 
+	xen_setup_runstate_info(cpu);
 	xen_setup_timer(cpu);
 	xen_setup_cpu_clockevents();
 }
diff -Nur linux-2.6.32-orig/arch/x86/xen/xen-asm_64.S iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/xen-asm_64.S
--- linux-2.6.32-orig/arch/x86/xen/xen-asm_64.S	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/xen-asm_64.S	2010-11-18 21:05:30.000000000 +0600
@@ -96,7 +96,7 @@
 	pushq $__USER32_CS
 	pushq %rcx
 
-	pushq $VGCF_in_syscall
+	pushq $0
 1:	jmp hypercall_iret
 ENDPATCH(xen_sysret32)
 RELOC(xen_sysret32, 1b+1)
@@ -151,7 +151,7 @@
 ENTRY(xen_sysenter_target)
 	lea 16(%rsp), %rsp	/* strip %rcx, %r11 */
 	mov $-ENOSYS, %rax
-	pushq $VGCF_in_syscall
+	pushq $0
 	jmp hypercall_iret
 ENDPROC(xen_syscall32_target)
 ENDPROC(xen_sysenter_target)
diff -Nur linux-2.6.32-orig/arch/x86/xen/xen-ops.h iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/xen-ops.h
--- linux-2.6.32-orig/arch/x86/xen/xen-ops.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/x86/xen/xen-ops.h	2010-11-18 21:05:30.000000000 +0600
@@ -25,6 +25,7 @@
 
 void xen_setup_mfn_list_list(void);
 void xen_setup_shared_info(void);
+void xen_build_mfn_list_list(void);
 void xen_setup_machphys_mapping(void);
 pgd_t *xen_setup_kernel_pagetable(pgd_t *pgd, unsigned long max_pfn);
 void xen_ident_map_ISA(void);
@@ -41,6 +42,7 @@
 
 void xen_init_irq_ops(void);
 void xen_setup_timer(int cpu);
+void xen_setup_runstate_info(int cpu);
 void xen_teardown_timer(int cpu);
 cycle_t xen_clocksource_read(void);
 void xen_setup_cpu_clockevents(void);
diff -Nur linux-2.6.32-orig/arch/xtensa/include/asm/syscall.h iDroid-Project-kernel_common-9e90fd2/arch/xtensa/include/asm/syscall.h
--- linux-2.6.32-orig/arch/xtensa/include/asm/syscall.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/xtensa/include/asm/syscall.h	2010-11-18 21:05:30.000000000 +0600
@@ -13,8 +13,6 @@
 asmlinkage long xtensa_execve(char*, char**, char**, struct pt_regs*);
 asmlinkage long xtensa_clone(unsigned long, unsigned long, struct pt_regs*);
 asmlinkage long xtensa_pipe(int __user *);
-asmlinkage long xtensa_mmap2(unsigned long, unsigned long, unsigned long,
-    			     unsigned long, unsigned long, unsigned long);
 asmlinkage long xtensa_ptrace(long, long, long, long);
 asmlinkage long xtensa_sigreturn(struct pt_regs*);
 asmlinkage long xtensa_rt_sigreturn(struct pt_regs*);
diff -Nur linux-2.6.32-orig/arch/xtensa/include/asm/unistd.h iDroid-Project-kernel_common-9e90fd2/arch/xtensa/include/asm/unistd.h
--- linux-2.6.32-orig/arch/xtensa/include/asm/unistd.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/xtensa/include/asm/unistd.h	2010-11-18 21:05:30.000000000 +0600
@@ -189,7 +189,7 @@
 /* File Map / Shared Memory Operations */
 
 #define __NR_mmap2 				 80
-__SYSCALL( 80, xtensa_mmap2, 6)
+__SYSCALL( 80, sys_mmap_pgoff, 6)
 #define __NR_munmap 				 81
 __SYSCALL( 81, sys_munmap, 2)
 #define __NR_mprotect 				 82
diff -Nur linux-2.6.32-orig/arch/xtensa/kernel/syscall.c iDroid-Project-kernel_common-9e90fd2/arch/xtensa/kernel/syscall.c
--- linux-2.6.32-orig/arch/xtensa/kernel/syscall.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/arch/xtensa/kernel/syscall.c	2010-11-18 21:05:30.000000000 +0600
@@ -57,31 +57,6 @@
 	return error;
 }
 
-
-asmlinkage long xtensa_mmap2(unsigned long addr, unsigned long len,
-   			     unsigned long prot, unsigned long flags,
-			     unsigned long fd, unsigned long pgoff)
-{
-	int error = -EBADF;
-	struct file * file = NULL;
-
-	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
-	if (!(flags & MAP_ANONYMOUS)) {
-		file = fget(fd);
-		if (!file)
-			goto out;
-	}
-
-	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
-	up_write(&current->mm->mmap_sem);
-
-	if (file)
-		fput(file);
-out:
-	return error;
-}
-
 asmlinkage long xtensa_shmat(int shmid, char __user *shmaddr, int shmflg)
 {
 	unsigned long ret;
diff -Nur linux-2.6.32-orig/block/blk-core.c iDroid-Project-kernel_common-9e90fd2/block/blk-core.c
--- linux-2.6.32-orig/block/blk-core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/block/blk-core.c	2010-11-18 21:05:30.000000000 +0600
@@ -1569,11 +1569,12 @@
 
 		if (unlikely(block_dump)) {
 			char b[BDEVNAME_SIZE];
-			printk(KERN_DEBUG "%s(%d): %s block %Lu on %s\n",
+			printk(KERN_DEBUG "%s(%d): %s block %Lu on %s (%u sectors)\n",
 			current->comm, task_pid_nr(current),
 				(rw & WRITE) ? "WRITE" : "READ",
 				(unsigned long long)bio->bi_sector,
-				bdevname(bio->bi_bdev, b));
+				bdevname(bio->bi_bdev, b),
+				count);
 		}
 	}
 
diff -Nur linux-2.6.32-orig/block/blk-settings.c iDroid-Project-kernel_common-9e90fd2/block/blk-settings.c
--- linux-2.6.32-orig/block/blk-settings.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/block/blk-settings.c	2010-11-18 21:05:30.000000000 +0600
@@ -560,6 +560,28 @@
 EXPORT_SYMBOL(blk_stack_limits);
 
 /**
+ * bdev_stack_limits - adjust queue limits for stacked drivers
+ * @t:	the stacking driver limits (top device)
+ * @bdev:  the component block_device (bottom)
+ * @start:  first data sector within component device
+ *
+ * Description:
+ *    Merges queue limits for a top device and a block_device.  Returns
+ *    0 if alignment didn't change.  Returns -1 if adding the bottom
+ *    device caused misalignment.
+ */
+int bdev_stack_limits(struct queue_limits *t, struct block_device *bdev,
+		      sector_t start)
+{
+	struct request_queue *bq = bdev_get_queue(bdev);
+
+	start += get_start_sect(bdev);
+
+	return blk_stack_limits(t, &bq->limits, start << 9);
+}
+EXPORT_SYMBOL(bdev_stack_limits);
+
+/**
  * disk_stack_limits - adjust queue limits for stacked drivers
  * @disk:  MD/DM gendisk (top)
  * @bdev:  the underlying block device (bottom)
diff -Nur linux-2.6.32-orig/block/genhd.c iDroid-Project-kernel_common-9e90fd2/block/genhd.c
--- linux-2.6.32-orig/block/genhd.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/block/genhd.c	2010-11-18 21:05:30.000000000 +0600
@@ -994,6 +994,22 @@
 	free_part_stats(&disk->part0);
 	kfree(disk);
 }
+
+static int disk_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct gendisk *disk = dev_to_disk(dev);
+	struct disk_part_iter piter;
+	struct hd_struct *part;
+	int cnt = 0;
+
+	disk_part_iter_init(&piter, disk, 0);
+	while((part = disk_part_iter_next(&piter)))
+		cnt++;
+	disk_part_iter_exit(&piter);
+	add_uevent_var(env, "NPARTS=%u", cnt);
+	return 0;
+}
+
 struct class block_class = {
 	.name		= "block",
 };
@@ -1012,6 +1028,7 @@
 	.groups		= disk_attr_groups,
 	.release	= disk_release,
 	.devnode	= block_devnode,
+	.uevent		= disk_uevent,
 };
 
 #ifdef CONFIG_PROC_FS
diff -Nur linux-2.6.32-orig/Documentation/android.txt iDroid-Project-kernel_common-9e90fd2/Documentation/android.txt
--- linux-2.6.32-orig/Documentation/android.txt	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/Documentation/android.txt	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,121 @@
+				=============
+				A N D R O I D
+				=============
+
+Copyright (C) 2009 Google, Inc.
+Written by Mike Chan <mike@android.com>
+
+CONTENTS:
+---------
+
+1. Android
+  1.1 Required enabled config options
+  1.2 Required disabled config options
+  1.3 Recommended enabled config options
+2. Contact
+
+
+1. Android
+==========
+
+Android (www.android.com) is an open source operating system for mobile devices.
+This document describes configurations needed to run the Android framework on
+top of the Linux kernel.
+
+To see a working defconfig look at msm_defconfig or goldfish_defconfig
+which can be found at http://android.git.kernel.org in kernel/common.git
+and kernel/msm.git
+
+
+1.1 Required enabled config options
+-----------------------------------
+After building a standard defconfig, ensure that these options are enabled in
+your .config or defconfig if they are not already. Based off the msm_defconfig.
+You should keep the rest of the default options enabled in the defconfig
+unless you know what you are doing.
+
+ANDROID_PARANOID_NETWORK
+ASHMEM
+CONFIG_FB_MODE_HELPERS
+CONFIG_FONT_8x16
+CONFIG_FONT_8x8
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+DAB
+EARLYSUSPEND
+FB
+FB_CFB_COPYAREA
+FB_CFB_FILLRECT
+FB_CFB_IMAGEBLIT
+FB_DEFERRED_IO
+FB_TILEBLITTING
+HIGH_RES_TIMERS
+INOTIFY
+INOTIFY_USER
+INPUT_EVDEV
+INPUT_GPIO
+INPUT_MISC
+LEDS_CLASS
+LEDS_GPIO
+LOCK_KERNEL
+LkOGGER
+LOW_MEMORY_KILLER
+MISC_DEVICES
+NEW_LEDS
+NO_HZ
+POWER_SUPPLY
+PREEMPT
+RAMFS
+RTC_CLASS
+RTC_LIB
+SWITCH
+SWITCH_GPIO
+TMPFS
+UID_STAT
+UID16
+USB_FUNCTION
+USB_FUNCTION_ADB
+USER_WAKELOCK
+VIDEO_OUTPUT_CONTROL
+WAKELOCK
+YAFFS_AUTO_YAFFS2
+YAFFS_FS
+YAFFS_YAFFS1
+YAFFS_YAFFS2
+
+
+1.2 Required disabled config options
+------------------------------------
+CONFIG_YAFFS_DISABLE_LAZY_LOAD
+DNOTIFY
+
+
+1.3 Recommended enabled config options
+------------------------------
+ANDROID_PMEM
+ANDROID_RAM_CONSOLE
+ANDROID_RAM_CONSOLE_ERROR_CORRECTION
+SCHEDSTATS
+DEBUG_PREEMPT
+DEBUG_MUTEXES
+DEBUG_SPINLOCK_SLEEP
+DEBUG_INFO
+FRAME_POINTER
+CPU_FREQ
+CPU_FREQ_TABLE
+CPU_FREQ_DEFAULT_GOV_ONDEMAND
+CPU_FREQ_GOV_ONDEMAND
+CRC_CCITT
+EMBEDDED
+INPUT_TOUCHSCREEN
+I2C
+I2C_BOARDINFO
+LOG_BUF_SHIFT=17
+SERIAL_CORE
+SERIAL_CORE_CONSOLE
+
+
+2. Contact
+==========
+website: http://android.git.kernel.org
+
+mailing-lists: android-kernel@googlegroups.com
diff -Nur linux-2.6.32-orig/Documentation/Changes iDroid-Project-kernel_common-9e90fd2/Documentation/Changes
--- linux-2.6.32-orig/Documentation/Changes	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/Documentation/Changes	2010-11-18 21:05:30.000000000 +0600
@@ -49,6 +49,8 @@
 o  udev                   081                     # udevinfo -V
 o  grub                   0.93                    # grub --version
 o  mcelog		  0.6
+o  iptables               1.4.1                   # iptables -V
+
 
 Kernel compilation
 ==================
diff -Nur linux-2.6.32-orig/Documentation/DocBook/Makefile iDroid-Project-kernel_common-9e90fd2/Documentation/DocBook/Makefile
--- linux-2.6.32-orig/Documentation/DocBook/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/Documentation/DocBook/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -32,10 +32,10 @@
 
 ###
 # The targets that may be used.
-PHONY += xmldocs sgmldocs psdocs pdfdocs htmldocs mandocs installmandocs cleandocs media
+PHONY += xmldocs sgmldocs psdocs pdfdocs htmldocs mandocs installmandocs cleandocs xmldoclinks
 
 BOOKS := $(addprefix $(obj)/,$(DOCBOOKS))
-xmldocs: $(BOOKS)
+xmldocs: $(BOOKS) xmldoclinks
 sgmldocs: xmldocs
 
 PS := $(patsubst %.xml, %.ps, $(BOOKS))
@@ -45,15 +45,24 @@
 pdfdocs: $(PDF)
 
 HTML := $(sort $(patsubst %.xml, %.html, $(BOOKS)))
-htmldocs: media $(HTML)
+htmldocs: $(HTML)
 	$(call build_main_index)
+	$(call build_images)
 
 MAN := $(patsubst %.xml, %.9, $(BOOKS))
 mandocs: $(MAN)
 
-media:
-	mkdir -p $(srctree)/Documentation/DocBook/media/
-	cp $(srctree)/Documentation/DocBook/dvb/*.png $(srctree)/Documentation/DocBook/v4l/*.gif $(srctree)/Documentation/DocBook/media/
+build_images = mkdir -p $(objtree)/Documentation/DocBook/media/ && \
+	       cp $(srctree)/Documentation/DocBook/dvb/*.png $(srctree)/Documentation/DocBook/v4l/*.gif $(objtree)/Documentation/DocBook/media/
+
+xmldoclinks:
+ifneq ($(objtree),$(srctree))
+	for dep in dvb media-entities.tmpl media-indices.tmpl v4l; do \
+		rm -f $(objtree)/Documentation/DocBook/$$dep \
+		&& ln -s $(srctree)/Documentation/DocBook/$$dep $(objtree)/Documentation/DocBook/ \
+		|| exit; \
+	done
+endif
 
 installmandocs: mandocs
 	mkdir -p /usr/local/man/man9/
diff -Nur linux-2.6.32-orig/Documentation/filesystems/ext4.txt iDroid-Project-kernel_common-9e90fd2/Documentation/filesystems/ext4.txt
--- linux-2.6.32-orig/Documentation/filesystems/ext4.txt	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/Documentation/filesystems/ext4.txt	2010-11-18 21:05:30.000000000 +0600
@@ -153,8 +153,8 @@
 			identified through its new major/minor numbers encoded
 			in devnum.
 
-noload			Don't load the journal on mounting.  Note that
-                     	if the filesystem was not unmounted cleanly,
+norecovery		Don't load the journal on mounting.  Note that
+noload			if the filesystem was not unmounted cleanly,
                      	skipping the journal replay will lead to the
                      	filesystem containing inconsistencies that can
                      	lead to any number of problems.
@@ -196,7 +196,7 @@
 			also be used to enable or disable barriers, for
 			consistency with other ext4 mount options.
 
-inode_readahead=n	This tuning parameter controls the maximum
+inode_readahead_blks=n	This tuning parameter controls the maximum
 			number of inode table blocks that ext4's inode
 			table readahead algorithm will pre-read into
 			the buffer cache.  The default value is 32 blocks.
@@ -353,6 +353,12 @@
 			system crashes before the delayed allocation
 			blocks are forced to disk.
 
+discard		Controls whether ext4 should issue discard/TRIM
+nodiscard(*)		commands to the underlying block device when
+			blocks are freed.  This is useful for SSD devices
+			and sparse/thinly-provisioned LUNs, but it is off
+			by default until sufficient testing has been done.
+
 Data Mode
 =========
 There are 3 different data modes:
diff -Nur linux-2.6.32-orig/Documentation/IO-mapping.txt iDroid-Project-kernel_common-9e90fd2/Documentation/IO-mapping.txt
--- linux-2.6.32-orig/Documentation/IO-mapping.txt	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/Documentation/IO-mapping.txt	2010-11-18 21:05:30.000000000 +0600
@@ -1,208 +1,82 @@
-[ NOTE: The virt_to_bus() and bus_to_virt() functions have been
-	superseded by the functionality provided by the PCI DMA interface
-	(see Documentation/PCI/PCI-DMA-mapping.txt).  They continue
-	to be documented below for historical purposes, but new code
-	must not use them. --davidm 00/12/12 ]
-
-[ This is a mail message in response to a query on IO mapping, thus the
-  strange format for a "document" ]
-
-The AHA-1542 is a bus-master device, and your patch makes the driver give the
-controller the physical address of the buffers, which is correct on x86
-(because all bus master devices see the physical memory mappings directly). 
-
-However, on many setups, there are actually _three_ different ways of looking
-at memory addresses, and in this case we actually want the third, the
-so-called "bus address". 
-
-Essentially, the three ways of addressing memory are (this is "real memory",
-that is, normal RAM--see later about other details): 
-
- - CPU untranslated.  This is the "physical" address.  Physical address 
-   0 is what the CPU sees when it drives zeroes on the memory bus.
-
- - CPU translated address. This is the "virtual" address, and is 
-   completely internal to the CPU itself with the CPU doing the appropriate
-   translations into "CPU untranslated". 
-
- - bus address. This is the address of memory as seen by OTHER devices, 
-   not the CPU. Now, in theory there could be many different bus 
-   addresses, with each device seeing memory in some device-specific way, but
-   happily most hardware designers aren't actually actively trying to make
-   things any more complex than necessary, so you can assume that all 
-   external hardware sees the memory the same way. 
-
-Now, on normal PCs the bus address is exactly the same as the physical
-address, and things are very simple indeed. However, they are that simple
-because the memory and the devices share the same address space, and that is
-not generally necessarily true on other PCI/ISA setups. 
-
-Now, just as an example, on the PReP (PowerPC Reference Platform), the 
-CPU sees a memory map something like this (this is from memory):
-
-	0-2 GB		"real memory"
-	2 GB-3 GB	"system IO" (inb/out and similar accesses on x86)
-	3 GB-4 GB 	"IO memory" (shared memory over the IO bus)
-
-Now, that looks simple enough. However, when you look at the same thing from
-the viewpoint of the devices, you have the reverse, and the physical memory
-address 0 actually shows up as address 2 GB for any IO master.
-
-So when the CPU wants any bus master to write to physical memory 0, it 
-has to give the master address 0x80000000 as the memory address.
-
-So, for example, depending on how the kernel is actually mapped on the 
-PPC, you can end up with a setup like this:
-
- physical address:	0
- virtual address:	0xC0000000
- bus address:		0x80000000
-
-where all the addresses actually point to the same thing.  It's just seen 
-through different translations..
-
-Similarly, on the Alpha, the normal translation is
-
- physical address:	0
- virtual address:	0xfffffc0000000000
- bus address:		0x40000000
-
-(but there are also Alphas where the physical address and the bus address
-are the same). 
-
-Anyway, the way to look up all these translations, you do
-
-	#include <asm/io.h>
-
-	phys_addr = virt_to_phys(virt_addr);
-	virt_addr = phys_to_virt(phys_addr);
-	 bus_addr = virt_to_bus(virt_addr);
-	virt_addr = bus_to_virt(bus_addr);
-
-Now, when do you need these?
-
-You want the _virtual_ address when you are actually going to access that 
-pointer from the kernel. So you can have something like this:
-
-	/*
-	 * this is the hardware "mailbox" we use to communicate with
-	 * the controller. The controller sees this directly.
-	 */
-	struct mailbox {
-		__u32 status;
-		__u32 bufstart;
-		__u32 buflen;
-		..
-	} mbox;
-
-		unsigned char * retbuffer;
-
-		/* get the address from the controller */
-		retbuffer = bus_to_virt(mbox.bufstart);
-		switch (retbuffer[0]) {
-			case STATUS_OK:
-				...
-
-on the other hand, you want the bus address when you have a buffer that 
-you want to give to the controller:
-
-	/* ask the controller to read the sense status into "sense_buffer" */
-	mbox.bufstart = virt_to_bus(&sense_buffer);
-	mbox.buflen = sizeof(sense_buffer);
-	mbox.status = 0;
-	notify_controller(&mbox);
-
-And you generally _never_ want to use the physical address, because you can't
-use that from the CPU (the CPU only uses translated virtual addresses), and
-you can't use it from the bus master. 
-
-So why do we care about the physical address at all? We do need the physical
-address in some cases, it's just not very often in normal code.  The physical
-address is needed if you use memory mappings, for example, because the
-"remap_pfn_range()" mm function wants the physical address of the memory to
-be remapped as measured in units of pages, a.k.a. the pfn (the memory
-management layer doesn't know about devices outside the CPU, so it
-shouldn't need to know about "bus addresses" etc).
-
-NOTE NOTE NOTE! The above is only one part of the whole equation. The above
-only talks about "real memory", that is, CPU memory (RAM). 
-
-There is a completely different type of memory too, and that's the "shared
-memory" on the PCI or ISA bus. That's generally not RAM (although in the case
-of a video graphics card it can be normal DRAM that is just used for a frame
-buffer), but can be things like a packet buffer in a network card etc. 
-
-This memory is called "PCI memory" or "shared memory" or "IO memory" or
-whatever, and there is only one way to access it: the readb/writeb and
-related functions. You should never take the address of such memory, because
-there is really nothing you can do with such an address: it's not
-conceptually in the same memory space as "real memory" at all, so you cannot
-just dereference a pointer. (Sadly, on x86 it _is_ in the same memory space,
-so on x86 it actually works to just deference a pointer, but it's not
-portable). 
-
-For such memory, you can do things like
-
- - reading:
-	/*
-	 * read first 32 bits from ISA memory at 0xC0000, aka
-	 * C000:0000 in DOS terms
-	 */
-	unsigned int signature = isa_readl(0xC0000);
-
- - remapping and writing:
-	/*
-	 * remap framebuffer PCI memory area at 0xFC000000,
-	 * size 1MB, so that we can access it: We can directly
-	 * access only the 640k-1MB area, so anything else
-	 * has to be remapped.
-	 */
-	char * baseptr = ioremap(0xFC000000, 1024*1024);
-
-	/* write a 'A' to the offset 10 of the area */
-	writeb('A',baseptr+10);
-
-	/* unmap when we unload the driver */
-	iounmap(baseptr);
-
- - copying and clearing:
-	/* get the 6-byte Ethernet address at ISA address E000:0040 */
-	memcpy_fromio(kernel_buffer, 0xE0040, 6);
-	/* write a packet to the driver */
-	memcpy_toio(0xE1000, skb->data, skb->len);
-	/* clear the frame buffer */
-	memset_io(0xA0000, 0, 0x10000);
-
-OK, that just about covers the basics of accessing IO portably.  Questions?
-Comments? You may think that all the above is overly complex, but one day you
-might find yourself with a 500 MHz Alpha in front of you, and then you'll be
-happy that your driver works ;)
-
-Note that kernel versions 2.0.x (and earlier) mistakenly called the
-ioremap() function "vremap()".  ioremap() is the proper name, but I
-didn't think straight when I wrote it originally.  People who have to
-support both can do something like:
- 
-	/* support old naming silliness */
-	#if LINUX_VERSION_CODE < 0x020100                                     
-	#define ioremap vremap
-	#define iounmap vfree                                                     
-	#endif
- 
-at the top of their source files, and then they can use the right names
-even on 2.0.x systems. 
-
-And the above sounds worse than it really is.  Most real drivers really
-don't do all that complex things (or rather: the complexity is not so
-much in the actual IO accesses as in error handling and timeouts etc). 
-It's generally not hard to fix drivers, and in many cases the code
-actually looks better afterwards:
-
-	unsigned long signature = *(unsigned int *) 0xC0000;
-		vs
-	unsigned long signature = readl(0xC0000);
+The io_mapping functions in linux/io-mapping.h provide an abstraction for
+efficiently mapping small regions of an I/O device to the CPU. The initial
+usage is to support the large graphics aperture on 32-bit processors where
+ioremap_wc cannot be used to statically map the entire aperture to the CPU
+as it would consume too much of the kernel address space.
 
-I think the second version actually is more readable, no?
+A mapping object is created during driver initialization using
 
-		Linus
+	struct io_mapping *io_mapping_create_wc(unsigned long base,
+						unsigned long size)
 
+		'base' is the bus address of the region to be made
+		mappable, while 'size' indicates how large a mapping region to
+		enable. Both are in bytes.
+
+		This _wc variant provides a mapping which may only be used
+		with the io_mapping_map_atomic_wc or io_mapping_map_wc.
+
+With this mapping object, individual pages can be mapped either atomically
+or not, depending on the necessary scheduling environment. Of course, atomic
+maps are more efficient:
+
+	void *io_mapping_map_atomic_wc(struct io_mapping *mapping,
+				       unsigned long offset)
+
+		'offset' is the offset within the defined mapping region.
+		Accessing addresses beyond the region specified in the
+		creation function yields undefined results. Using an offset
+		which is not page aligned yields an undefined result. The
+		return value points to a single page in CPU address space.
+
+		This _wc variant returns a write-combining map to the
+		page and may only be used with mappings created by
+		io_mapping_create_wc
+
+		Note that the task may not sleep while holding this page
+		mapped.
+
+	void io_mapping_unmap_atomic(void *vaddr)
+
+		'vaddr' must be the the value returned by the last
+		io_mapping_map_atomic_wc call. This unmaps the specified
+		page and allows the task to sleep once again.
+
+If you need to sleep while holding the lock, you can use the non-atomic
+variant, although they may be significantly slower.
+
+	void *io_mapping_map_wc(struct io_mapping *mapping,
+				unsigned long offset)
+
+		This works like io_mapping_map_atomic_wc except it allows
+		the task to sleep while holding the page mapped.
+
+	void io_mapping_unmap(void *vaddr)
+
+		This works like io_mapping_unmap_atomic, except it is used
+		for pages mapped with io_mapping_map_wc.
+
+At driver close time, the io_mapping object must be freed:
+
+	void io_mapping_free(struct io_mapping *mapping)
+
+Current Implementation:
+
+The initial implementation of these functions uses existing mapping
+mechanisms and so provides only an abstraction layer and no new
+functionality.
+
+On 64-bit processors, io_mapping_create_wc calls ioremap_wc for the whole
+range, creating a permanent kernel-visible mapping to the resource. The
+map_atomic and map functions add the requested offset to the base of the
+virtual address returned by ioremap_wc.
+
+On 32-bit processors with HIGHMEM defined, io_mapping_map_atomic_wc uses
+kmap_atomic_pfn to map the specified page in an atomic fashion;
+kmap_atomic_pfn isn't really supposed to be used with device pages, but it
+provides an efficient mapping for this usage.
+
+On 32-bit processors without HIGHMEM defined, io_mapping_map_atomic_wc and
+io_mapping_map_wc both use ioremap_wc, a terribly inefficient function which
+performs an IPI to inform all processors about the new mapping. This results
+in a significant performance penalty.
diff -Nur linux-2.6.32-orig/Documentation/kernel-parameters.txt iDroid-Project-kernel_common-9e90fd2/Documentation/kernel-parameters.txt
--- linux-2.6.32-orig/Documentation/kernel-parameters.txt	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/Documentation/kernel-parameters.txt	2010-11-18 21:05:30.000000000 +0600
@@ -2645,6 +2645,8 @@
 			to a common usb-storage quirk flag as follows:
 				a = SANE_SENSE (collect more than 18 bytes
 					of sense data);
+				b = BAD_SENSE (don't collect more than 18
+					bytes of sense data);
 				c = FIX_CAPACITY (decrease the reported
 					device capacity by one sector);
 				h = CAPACITY_HEURISTICS (decrease the
diff -Nur linux-2.6.32-orig/Documentation/kvm/api.txt iDroid-Project-kernel_common-9e90fd2/Documentation/kvm/api.txt
--- linux-2.6.32-orig/Documentation/kvm/api.txt	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/Documentation/kvm/api.txt	2010-11-18 21:05:30.000000000 +0600
@@ -593,6 +593,42 @@
 	} chip;
 };
 
+4.27 KVM_GET_CLOCK
+
+Capability: KVM_CAP_ADJUST_CLOCK
+Architectures: x86
+Type: vm ioctl
+Parameters: struct kvm_clock_data (out)
+Returns: 0 on success, -1 on error
+
+Gets the current timestamp of kvmclock as seen by the current guest. In
+conjunction with KVM_SET_CLOCK, it is used to ensure monotonicity on scenarios
+such as migration.
+
+struct kvm_clock_data {
+	__u64 clock;  /* kvmclock current value */
+	__u32 flags;
+	__u32 pad[9];
+};
+
+4.28 KVM_SET_CLOCK
+
+Capability: KVM_CAP_ADJUST_CLOCK
+Architectures: x86
+Type: vm ioctl
+Parameters: struct kvm_clock_data (in)
+Returns: 0 on success, -1 on error
+
+Sets the current timestamp of kvmclock to the valued specific in its parameter.
+In conjunction with KVM_GET_CLOCK, it is used to ensure monotonicity on scenarios
+such as migration.
+
+struct kvm_clock_data {
+	__u64 clock;  /* kvmclock current value */
+	__u32 flags;
+	__u32 pad[9];
+};
+
 5. The kvm_run structure
 
 Application code obtains a pointer to the kvm_run structure by
diff -Nur linux-2.6.32-orig/Documentation/video4linux/CARDLIST.saa7134 iDroid-Project-kernel_common-9e90fd2/Documentation/video4linux/CARDLIST.saa7134
--- linux-2.6.32-orig/Documentation/video4linux/CARDLIST.saa7134	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/Documentation/video4linux/CARDLIST.saa7134	2010-11-18 21:05:30.000000000 +0600
@@ -172,3 +172,4 @@
 171 -> Beholder BeholdTV X7                     [5ace:7595]
 172 -> RoverMedia TV Link Pro FM                [19d1:0138]
 173 -> Zolid Hybrid TV Tuner PCI                [1131:2004]
+174 -> Asus Europa Hybrid OEM                   [1043:4847]
diff -Nur linux-2.6.32-orig/Documentation/video4linux/gspca.txt iDroid-Project-kernel_common-9e90fd2/Documentation/video4linux/gspca.txt
--- linux-2.6.32-orig/Documentation/video4linux/gspca.txt	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/Documentation/video4linux/gspca.txt	2010-11-18 21:05:30.000000000 +0600
@@ -37,6 +37,7 @@
 ov519		041e:4060	Creative Live! VISTA VF0350
 ov519		041e:4061	Creative Live! VISTA VF0400
 ov519		041e:4064	Creative Live! VISTA VF0420
+ov519		041e:4067	Creative Live! Cam Video IM (VF0350)
 ov519		041e:4068	Creative Live! VISTA VF0470
 spca561		0458:7004	Genius VideoCAM Express V2
 sunplus		0458:7006	Genius Dsc 1.3 Smart
diff -Nur linux-2.6.32-orig/drivers/acpi/bus.c iDroid-Project-kernel_common-9e90fd2/drivers/acpi/bus.c
--- linux-2.6.32-orig/drivers/acpi/bus.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/acpi/bus.c	2010-11-18 21:05:30.000000000 +0600
@@ -344,6 +344,167 @@
 
 EXPORT_SYMBOL(acpi_bus_can_wakeup);
 
+static void acpi_print_osc_error(acpi_handle handle,
+	struct acpi_osc_context *context, char *error)
+{
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER};
+	int i;
+
+	if (ACPI_FAILURE(acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer)))
+		printk(KERN_DEBUG "%s\n", error);
+	else {
+		printk(KERN_DEBUG "%s:%s\n", (char *)buffer.pointer, error);
+		kfree(buffer.pointer);
+	}
+	printk(KERN_DEBUG"_OSC request data:");
+	for (i = 0; i < context->cap.length; i += sizeof(u32))
+		printk("%x ", *((u32 *)(context->cap.pointer + i)));
+	printk("\n");
+}
+
+static u8 hex_val(unsigned char c)
+{
+	return isdigit(c) ? c - '0' : toupper(c) - 'A' + 10;
+}
+
+static acpi_status acpi_str_to_uuid(char *str, u8 *uuid)
+{
+	int i;
+	static int opc_map_to_uuid[16] = {6, 4, 2, 0, 11, 9, 16, 14, 19, 21,
+		24, 26, 28, 30, 32, 34};
+
+	if (strlen(str) != 36)
+		return AE_BAD_PARAMETER;
+	for (i = 0; i < 36; i++) {
+		if (i == 8 || i == 13 || i == 18 || i == 23) {
+			if (str[i] != '-')
+				return AE_BAD_PARAMETER;
+		} else if (!isxdigit(str[i]))
+			return AE_BAD_PARAMETER;
+	}
+	for (i = 0; i < 16; i++) {
+		uuid[i] = hex_val(str[opc_map_to_uuid[i]]) << 4;
+		uuid[i] |= hex_val(str[opc_map_to_uuid[i] + 1]);
+	}
+	return AE_OK;
+}
+
+acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context)
+{
+	acpi_status status;
+	struct acpi_object_list input;
+	union acpi_object in_params[4];
+	union acpi_object *out_obj;
+	u8 uuid[16];
+	u32 errors;
+	struct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};
+
+	if (!context)
+		return AE_ERROR;
+	if (ACPI_FAILURE(acpi_str_to_uuid(context->uuid_str, uuid)))
+		return AE_ERROR;
+	context->ret.length = ACPI_ALLOCATE_BUFFER;
+	context->ret.pointer = NULL;
+
+	/* Setting up input parameters */
+	input.count = 4;
+	input.pointer = in_params;
+	in_params[0].type 		= ACPI_TYPE_BUFFER;
+	in_params[0].buffer.length 	= 16;
+	in_params[0].buffer.pointer	= uuid;
+	in_params[1].type 		= ACPI_TYPE_INTEGER;
+	in_params[1].integer.value 	= context->rev;
+	in_params[2].type 		= ACPI_TYPE_INTEGER;
+	in_params[2].integer.value	= context->cap.length/sizeof(u32);
+	in_params[3].type		= ACPI_TYPE_BUFFER;
+	in_params[3].buffer.length 	= context->cap.length;
+	in_params[3].buffer.pointer 	= context->cap.pointer;
+
+	status = acpi_evaluate_object(handle, "_OSC", &input, &output);
+	if (ACPI_FAILURE(status))
+		return status;
+
+	if (!output.length)
+		return AE_NULL_OBJECT;
+
+	out_obj = output.pointer;
+	if (out_obj->type != ACPI_TYPE_BUFFER
+		|| out_obj->buffer.length != context->cap.length) {
+		acpi_print_osc_error(handle, context,
+			"_OSC evaluation returned wrong type");
+		status = AE_TYPE;
+		goto out_kfree;
+	}
+	/* Need to ignore the bit0 in result code */
+	errors = *((u32 *)out_obj->buffer.pointer) & ~(1 << 0);
+	if (errors) {
+		if (errors & OSC_REQUEST_ERROR)
+			acpi_print_osc_error(handle, context,
+				"_OSC request failed");
+		if (errors & OSC_INVALID_UUID_ERROR)
+			acpi_print_osc_error(handle, context,
+				"_OSC invalid UUID");
+		if (errors & OSC_INVALID_REVISION_ERROR)
+			acpi_print_osc_error(handle, context,
+				"_OSC invalid revision");
+		if (errors & OSC_CAPABILITIES_MASK_ERROR) {
+			if (((u32 *)context->cap.pointer)[OSC_QUERY_TYPE]
+			    & OSC_QUERY_ENABLE)
+				goto out_success;
+			status = AE_SUPPORT;
+			goto out_kfree;
+		}
+		status = AE_ERROR;
+		goto out_kfree;
+	}
+out_success:
+	context->ret.length = out_obj->buffer.length;
+	context->ret.pointer = kmalloc(context->ret.length, GFP_KERNEL);
+	if (!context->ret.pointer) {
+		status =  AE_NO_MEMORY;
+		goto out_kfree;
+	}
+	memcpy(context->ret.pointer, out_obj->buffer.pointer,
+		context->ret.length);
+	status =  AE_OK;
+
+out_kfree:
+	kfree(output.pointer);
+	if (status != AE_OK)
+		context->ret.pointer = NULL;
+	return status;
+}
+EXPORT_SYMBOL(acpi_run_osc);
+
+static u8 sb_uuid_str[] = "0811B06E-4A27-44F9-8D60-3CBBC22E7B48";
+static void acpi_bus_osc_support(void)
+{
+	u32 capbuf[2];
+	struct acpi_osc_context context = {
+		.uuid_str = sb_uuid_str,
+		.rev = 1,
+		.cap.length = 8,
+		.cap.pointer = capbuf,
+	};
+	acpi_handle handle;
+
+	capbuf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
+	capbuf[OSC_SUPPORT_TYPE] = OSC_SB_PR3_SUPPORT; /* _PR3 is in use */
+#if defined(CONFIG_ACPI_PROCESSOR_AGGREGATOR) ||\
+			defined(CONFIG_ACPI_PROCESSOR_AGGREGATOR_MODULE)
+	capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_PAD_SUPPORT;
+#endif
+
+#if defined(CONFIG_ACPI_PROCESSOR) || defined(CONFIG_ACPI_PROCESSOR_MODULE)
+	capbuf[OSC_SUPPORT_TYPE] |= OSC_SB_PPC_OST_SUPPORT;
+#endif
+	if (ACPI_FAILURE(acpi_get_handle(NULL, "\\_SB", &handle)))
+		return;
+	if (ACPI_SUCCESS(acpi_run_osc(handle, &context)))
+		kfree(context.ret.pointer);
+	/* do we need to check the returned cap? Sounds no */
+}
+
 /* --------------------------------------------------------------------------
                                 Event Management
    -------------------------------------------------------------------------- */
@@ -734,6 +895,8 @@
 	status = acpi_ec_ecdt_probe();
 	/* Ignore result. Not having an ECDT is not fatal. */
 
+	acpi_bus_osc_support();
+
 	status = acpi_initialize_objects(ACPI_FULL_INITIALIZATION);
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX "Unable to initialize ACPI objects\n");
diff -Nur linux-2.6.32-orig/drivers/acpi/button.c iDroid-Project-kernel_common-9e90fd2/drivers/acpi/button.c
--- linux-2.6.32-orig/drivers/acpi/button.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/acpi/button.c	2010-11-18 21:05:30.000000000 +0600
@@ -282,6 +282,13 @@
 	if (ret == NOTIFY_DONE)
 		ret = blocking_notifier_call_chain(&acpi_lid_notifier, state,
 						   device);
+	if (ret == NOTIFY_DONE || ret == NOTIFY_OK) {
+		/*
+		 * It is also regarded as success if the notifier_chain
+		 * returns NOTIFY_OK or NOTIFY_DONE.
+		 */
+		ret = 0;
+	}
 	return ret;
 }
 
diff -Nur linux-2.6.32-orig/drivers/acpi/ec.c iDroid-Project-kernel_common-9e90fd2/drivers/acpi/ec.c
--- linux-2.6.32-orig/drivers/acpi/ec.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/acpi/ec.c	2010-11-18 21:05:30.000000000 +0600
@@ -201,14 +201,13 @@
 	spin_unlock_irqrestore(&ec->curr_lock, flags);
 }
 
-static void acpi_ec_gpe_query(void *ec_cxt);
+static int acpi_ec_sync_query(struct acpi_ec *ec);
 
-static int ec_check_sci(struct acpi_ec *ec, u8 state)
+static int ec_check_sci_sync(struct acpi_ec *ec, u8 state)
 {
 	if (state & ACPI_EC_FLAG_SCI) {
 		if (!test_and_set_bit(EC_FLAGS_QUERY_PENDING, &ec->flags))
-			return acpi_os_execute(OSL_EC_BURST_HANDLER,
-				acpi_ec_gpe_query, ec);
+			return acpi_ec_sync_query(ec);
 	}
 	return 0;
 }
@@ -249,11 +248,6 @@
 {
 	unsigned long tmp;
 	int ret = 0;
-	pr_debug(PREFIX "transaction start\n");
-	/* disable GPE during transaction if storm is detected */
-	if (test_bit(EC_FLAGS_GPE_STORM, &ec->flags)) {
-		acpi_disable_gpe(NULL, ec->gpe);
-	}
 	if (EC_FLAGS_MSI)
 		udelay(ACPI_EC_MSI_UDELAY);
 	/* start transaction */
@@ -265,20 +259,9 @@
 		clear_bit(EC_FLAGS_QUERY_PENDING, &ec->flags);
 	spin_unlock_irqrestore(&ec->curr_lock, tmp);
 	ret = ec_poll(ec);
-	pr_debug(PREFIX "transaction end\n");
 	spin_lock_irqsave(&ec->curr_lock, tmp);
 	ec->curr = NULL;
 	spin_unlock_irqrestore(&ec->curr_lock, tmp);
-	if (test_bit(EC_FLAGS_GPE_STORM, &ec->flags)) {
-		/* check if we received SCI during transaction */
-		ec_check_sci(ec, acpi_ec_read_status(ec));
-		/* it is safe to enable GPE outside of transaction */
-		acpi_enable_gpe(NULL, ec->gpe);
-	} else if (t->irq_count > ACPI_EC_STORM_THRESHOLD) {
-		pr_info(PREFIX "GPE storm detected, "
-			"transactions will use polling mode\n");
-		set_bit(EC_FLAGS_GPE_STORM, &ec->flags);
-	}
 	return ret;
 }
 
@@ -321,7 +304,26 @@
 		status = -ETIME;
 		goto end;
 	}
+	pr_debug(PREFIX "transaction start\n");
+	/* disable GPE during transaction if storm is detected */
+	if (test_bit(EC_FLAGS_GPE_STORM, &ec->flags)) {
+		acpi_disable_gpe(NULL, ec->gpe);
+	}
+
 	status = acpi_ec_transaction_unlocked(ec, t);
+
+	/* check if we received SCI during transaction */
+	ec_check_sci_sync(ec, acpi_ec_read_status(ec));
+	if (test_bit(EC_FLAGS_GPE_STORM, &ec->flags)) {
+		msleep(1);
+		/* it is safe to enable GPE outside of transaction */
+		acpi_enable_gpe(NULL, ec->gpe);
+	} else if (t->irq_count > ACPI_EC_STORM_THRESHOLD) {
+		pr_info(PREFIX "GPE storm detected, "
+			"transactions will use polling mode\n");
+		set_bit(EC_FLAGS_GPE_STORM, &ec->flags);
+	}
+	pr_debug(PREFIX "transaction end\n");
 end:
 	if (ec->global_lock)
 		acpi_release_global_lock(glk);
@@ -443,7 +445,7 @@
 
 EXPORT_SYMBOL(ec_transaction);
 
-static int acpi_ec_query(struct acpi_ec *ec, u8 * data)
+static int acpi_ec_query_unlocked(struct acpi_ec *ec, u8 * data)
 {
 	int result;
 	u8 d;
@@ -452,20 +454,16 @@
 				.wlen = 0, .rlen = 1};
 	if (!ec || !data)
 		return -EINVAL;
-
 	/*
 	 * Query the EC to find out which _Qxx method we need to evaluate.
 	 * Note that successful completion of the query causes the ACPI_EC_SCI
 	 * bit to be cleared (and thus clearing the interrupt source).
 	 */
-
-	result = acpi_ec_transaction(ec, &t);
+	result = acpi_ec_transaction_unlocked(ec, &t);
 	if (result)
 		return result;
-
 	if (!d)
 		return -ENODATA;
-
 	*data = d;
 	return 0;
 }
@@ -509,43 +507,78 @@
 
 EXPORT_SYMBOL_GPL(acpi_ec_remove_query_handler);
 
-static void acpi_ec_gpe_query(void *ec_cxt)
+static void acpi_ec_run(void *cxt)
 {
-	struct acpi_ec *ec = ec_cxt;
-	u8 value = 0;
-	struct acpi_ec_query_handler *handler, copy;
-
-	if (!ec || acpi_ec_query(ec, &value))
+	struct acpi_ec_query_handler *handler = cxt;
+	if (!handler)
 		return;
-	mutex_lock(&ec->lock);
+	pr_debug(PREFIX "start query execution\n");
+	if (handler->func)
+		handler->func(handler->data);
+	else if (handler->handle)
+		acpi_evaluate_object(handler->handle, NULL, NULL, NULL);
+	pr_debug(PREFIX "stop query execution\n");
+	kfree(handler);
+}
+
+static int acpi_ec_sync_query(struct acpi_ec *ec)
+{
+	u8 value = 0;
+	int status;
+	struct acpi_ec_query_handler *handler, *copy;
+	if ((status = acpi_ec_query_unlocked(ec, &value)))
+		return status;
 	list_for_each_entry(handler, &ec->list, node) {
 		if (value == handler->query_bit) {
 			/* have custom handler for this bit */
-			memcpy(&copy, handler, sizeof(copy));
-			mutex_unlock(&ec->lock);
-			if (copy.func) {
-				copy.func(copy.data);
-			} else if (copy.handle) {
-				acpi_evaluate_object(copy.handle, NULL, NULL, NULL);
-			}
-			return;
+			copy = kmalloc(sizeof(*handler), GFP_KERNEL);
+			if (!copy)
+				return -ENOMEM;
+			memcpy(copy, handler, sizeof(*copy));
+			pr_debug(PREFIX "push query execution (0x%2x) on queue\n", value);
+			return acpi_os_execute(OSL_GPE_HANDLER,
+				acpi_ec_run, copy);
 		}
 	}
+	return 0;
+}
+
+static void acpi_ec_gpe_query(void *ec_cxt)
+{
+	struct acpi_ec *ec = ec_cxt;
+	if (!ec)
+		return;
+	mutex_lock(&ec->lock);
+	acpi_ec_sync_query(ec);
 	mutex_unlock(&ec->lock);
 }
 
+static void acpi_ec_gpe_query(void *ec_cxt);
+
+static int ec_check_sci(struct acpi_ec *ec, u8 state)
+{
+	if (state & ACPI_EC_FLAG_SCI) {
+		if (!test_and_set_bit(EC_FLAGS_QUERY_PENDING, &ec->flags)) {
+			pr_debug(PREFIX "push gpe query to the queue\n");
+			return acpi_os_execute(OSL_NOTIFY_HANDLER,
+				acpi_ec_gpe_query, ec);
+		}
+	}
+	return 0;
+}
+
 static u32 acpi_ec_gpe_handler(void *data)
 {
 	struct acpi_ec *ec = data;
-	u8 status;
 
 	pr_debug(PREFIX "~~~> interrupt\n");
-	status = acpi_ec_read_status(ec);
 
-	advance_transaction(ec, status);
-	if (ec_transaction_done(ec) && (status & ACPI_EC_FLAG_IBF) == 0)
+	advance_transaction(ec, acpi_ec_read_status(ec));
+	if (ec_transaction_done(ec) &&
+	    (acpi_ec_read_status(ec) & ACPI_EC_FLAG_IBF) == 0) {
 		wake_up(&ec->wait);
-	ec_check_sci(ec, status);
+		ec_check_sci(ec, acpi_ec_read_status(ec));
+	}
 	return ACPI_INTERRUPT_HANDLED;
 }
 
@@ -916,6 +949,7 @@
 /* MSI EC needs special treatment, enable it */
 static int ec_flag_msi(const struct dmi_system_id *id)
 {
+	printk(KERN_DEBUG PREFIX "Detected MSI hardware, enabling workarounds.\n");
 	EC_FLAGS_MSI = 1;
 	EC_FLAGS_VALIDATE_ECDT = 1;
 	return 0;
@@ -928,8 +962,13 @@
 	DMI_MATCH(DMI_BOARD_NAME, "JFL92") }, NULL},
 	{
 	ec_flag_msi, "MSI hardware", {
-	DMI_MATCH(DMI_BIOS_VENDOR, "Micro-Star"),
-	DMI_MATCH(DMI_CHASSIS_VENDOR, "MICRO-Star") }, NULL},
+	DMI_MATCH(DMI_BIOS_VENDOR, "Micro-Star")}, NULL},
+	{
+	ec_flag_msi, "MSI hardware", {
+	DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star")}, NULL},
+	{
+	ec_flag_msi, "MSI hardware", {
+	DMI_MATCH(DMI_CHASSIS_VENDOR, "MICRO-Star")}, NULL},
 	{
 	ec_validate_ecdt, "ASUS hardware", {
 	DMI_MATCH(DMI_BIOS_VENDOR, "ASUS") }, NULL},
diff -Nur linux-2.6.32-orig/drivers/acpi/processor_idle.c iDroid-Project-kernel_common-9e90fd2/drivers/acpi/processor_idle.c
--- linux-2.6.32-orig/drivers/acpi/processor_idle.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/acpi/processor_idle.c	2010-11-18 21:05:30.000000000 +0600
@@ -110,6 +110,14 @@
 	  DMI_MATCH(DMI_BIOS_VENDOR,"Phoenix Technologies LTD"),
 	  DMI_MATCH(DMI_BIOS_VERSION,"SHE845M0.86C.0013.D.0302131307")},
 	 (void *)2},
+	{ set_max_cstate, "Pavilion zv5000", {
+	  DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+	  DMI_MATCH(DMI_PRODUCT_NAME,"Pavilion zv5000 (DS502A#ABA)")},
+	 (void *)1},
+	{ set_max_cstate, "Asus L8400B", {
+	  DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
+	  DMI_MATCH(DMI_PRODUCT_NAME,"L8400B series Notebook PC")},
+	 (void *)1},
 	{},
 };
 
@@ -299,6 +307,17 @@
 	pr->power.states[ACPI_STATE_C2].latency = acpi_gbl_FADT.C2latency;
 	pr->power.states[ACPI_STATE_C3].latency = acpi_gbl_FADT.C3latency;
 
+	/*
+	 * FADT specified C2 latency must be less than or equal to
+	 * 100 microseconds.
+	 */
+	if (acpi_gbl_FADT.C2latency > ACPI_PROCESSOR_MAX_C2_LATENCY) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"C2 latency too large [%d]\n", acpi_gbl_FADT.C2latency));
+		/* invalidate C2 */
+		pr->power.states[ACPI_STATE_C2].address = 0;
+	}
+
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  "lvl2[0x%08x] lvl3[0x%08x]\n",
 			  pr->power.states[ACPI_STATE_C2].address,
@@ -495,16 +514,6 @@
 		return;
 
 	/*
-	 * C2 latency must be less than or equal to 100
-	 * microseconds.
-	 */
-	else if (cx->latency > ACPI_PROCESSOR_MAX_C2_LATENCY) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "latency too large [%d]\n", cx->latency));
-		return;
-	}
-
-	/*
 	 * Otherwise we've met all of our C2 requirements.
 	 * Normalize the C2 latency to expidite policy
 	 */
diff -Nur linux-2.6.32-orig/drivers/acpi/scan.c iDroid-Project-kernel_common-9e90fd2/drivers/acpi/scan.c
--- linux-2.6.32-orig/drivers/acpi/scan.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/acpi/scan.c	2010-11-18 21:05:30.000000000 +0600
@@ -1357,6 +1357,9 @@
 {
 	struct acpi_bus_ops ops;
 
+	if (!device)
+		return -EINVAL;
+
 	memset(&ops, 0, sizeof(ops));
 	ops.acpi_op_start = 1;
 
diff -Nur linux-2.6.32-orig/drivers/ata/ahci.c iDroid-Project-kernel_common-9e90fd2/drivers/ata/ahci.c
--- linux-2.6.32-orig/drivers/ata/ahci.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/ata/ahci.c	2010-11-18 21:05:30.000000000 +0600
@@ -113,6 +113,7 @@
 	board_ahci_mcp65	= 6,
 	board_ahci_nopmp	= 7,
 	board_ahci_yesncq	= 8,
+	board_ahci_nosntf	= 9,
 
 	/* global controller registers */
 	HOST_CAP		= 0x00, /* host capabilities */
@@ -235,6 +236,7 @@
 	AHCI_HFLAG_NO_SUSPEND		= (1 << 10), /* don't suspend */
 	AHCI_HFLAG_SRST_TOUT_IS_OFFLINE	= (1 << 11), /* treat SRST timeout as
 							link offline */
+	AHCI_HFLAG_NO_SNTF		= (1 << 12), /* no sntf */
 
 	/* ap->flags bits */
 
@@ -508,7 +510,7 @@
 		.udma_mask	= ATA_UDMA6,
 		.port_ops	= &ahci_ops,
 	},
-	/* board_ahci_yesncq */
+	[board_ahci_yesncq] =
 	{
 		AHCI_HFLAGS	(AHCI_HFLAG_YES_NCQ),
 		.flags		= AHCI_FLAG_COMMON,
@@ -516,6 +518,14 @@
 		.udma_mask	= ATA_UDMA6,
 		.port_ops	= &ahci_ops,
 	},
+	[board_ahci_nosntf] =
+	{
+		AHCI_HFLAGS	(AHCI_HFLAG_NO_SNTF),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
 };
 
 static const struct pci_device_id ahci_pci_tbl[] = {
@@ -531,7 +541,7 @@
 	{ PCI_VDEVICE(INTEL, 0x2683), board_ahci }, /* ESB2 */
 	{ PCI_VDEVICE(INTEL, 0x27c6), board_ahci }, /* ICH7-M DH */
 	{ PCI_VDEVICE(INTEL, 0x2821), board_ahci }, /* ICH8 */
-	{ PCI_VDEVICE(INTEL, 0x2822), board_ahci }, /* ICH8 */
+	{ PCI_VDEVICE(INTEL, 0x2822), board_ahci_nosntf }, /* ICH8 */
 	{ PCI_VDEVICE(INTEL, 0x2824), board_ahci }, /* ICH8 */
 	{ PCI_VDEVICE(INTEL, 0x2829), board_ahci }, /* ICH8M */
 	{ PCI_VDEVICE(INTEL, 0x282a), board_ahci }, /* ICH8M */
@@ -849,6 +859,12 @@
 		cap &= ~HOST_CAP_PMP;
 	}
 
+	if ((cap & HOST_CAP_SNTF) && (hpriv->flags & AHCI_HFLAG_NO_SNTF)) {
+		dev_printk(KERN_INFO, &pdev->dev,
+			   "controller can't do SNTF, turning off CAP_SNTF\n");
+		cap &= ~HOST_CAP_SNTF;
+	}
+
 	if (pdev->vendor == PCI_VENDOR_ID_JMICRON && pdev->device == 0x2361 &&
 	    port_map != 1) {
 		dev_printk(KERN_INFO, &pdev->dev,
@@ -2852,6 +2868,21 @@
 			},
 			.driver_data = "F.23",	/* cutoff BIOS version */
 		},
+		/*
+		 * Acer eMachines G725 has the same problem.  BIOS
+		 * V1.03 is known to be broken.  V3.04 is known to
+		 * work.  Inbetween, there are V1.06, V2.06 and V3.03
+		 * that we don't have much idea about.  For now,
+		 * blacklist anything older than V3.04.
+		 */
+		{
+			.ident = "G725",
+			.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR, "eMachines"),
+				DMI_MATCH(DMI_PRODUCT_NAME, "eMachines G725"),
+			},
+			.driver_data = "V3.04",	/* cutoff BIOS version */
+		},
 		{ }	/* terminate list */
 	};
 	const struct dmi_system_id *dmi = dmi_first_match(sysids);
diff -Nur linux-2.6.32-orig/drivers/ata/ata_piix.c iDroid-Project-kernel_common-9e90fd2/drivers/ata/ata_piix.c
--- linux-2.6.32-orig/drivers/ata/ata_piix.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/ata/ata_piix.c	2010-11-18 21:05:30.000000000 +0600
@@ -869,10 +869,10 @@
 				(timings[pio][1] << 8);
 		}
 
-		if (ap->udma_mask) {
+		if (ap->udma_mask)
 			udma_enable &= ~(1 << devid);
-			pci_write_config_word(dev, master_port, master_data);
-		}
+
+		pci_write_config_word(dev, master_port, master_data);
 	}
 	/* Don't scribble on 0x48 if the controller does not support UDMA */
 	if (ap->udma_mask)
diff -Nur linux-2.6.32-orig/drivers/ata/libata-core.c iDroid-Project-kernel_common-9e90fd2/drivers/ata/libata-core.c
--- linux-2.6.32-orig/drivers/ata/libata-core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/ata/libata-core.c	2010-11-18 21:05:30.000000000 +0600
@@ -3790,21 +3790,45 @@
 int sata_link_resume(struct ata_link *link, const unsigned long *params,
 		     unsigned long deadline)
 {
+	int tries = ATA_LINK_RESUME_TRIES;
 	u32 scontrol, serror;
 	int rc;
 
 	if ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))
 		return rc;
 
-	scontrol = (scontrol & 0x0f0) | 0x300;
+	/*
+	 * Writes to SControl sometimes get ignored under certain
+	 * controllers (ata_piix SIDPR).  Make sure DET actually is
+	 * cleared.
+	 */
+	do {
+		scontrol = (scontrol & 0x0f0) | 0x300;
+		if ((rc = sata_scr_write(link, SCR_CONTROL, scontrol)))
+			return rc;
+		/*
+		 * Some PHYs react badly if SStatus is pounded
+		 * immediately after resuming.  Delay 200ms before
+		 * debouncing.
+		 */
+		msleep(200);
 
-	if ((rc = sata_scr_write(link, SCR_CONTROL, scontrol)))
-		return rc;
+		/* is SControl restored correctly? */
+		if ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))
+			return rc;
+	} while ((scontrol & 0xf0f) != 0x300 && --tries);
 
-	/* Some PHYs react badly if SStatus is pounded immediately
-	 * after resuming.  Delay 200ms before debouncing.
-	 */
-	msleep(200);
+	if ((scontrol & 0xf0f) != 0x300) {
+		ata_link_printk(link, KERN_ERR,
+				"failed to resume link (SControl %X)\n",
+				scontrol);
+		return 0;
+	}
+
+	if (tries < ATA_LINK_RESUME_TRIES)
+		ata_link_printk(link, KERN_WARNING,
+				"link resume succeeded after %d retries\n",
+				ATA_LINK_RESUME_TRIES - tries);
 
 	if ((rc = sata_link_debounce(link, params, deadline)))
 		return rc;
diff -Nur linux-2.6.32-orig/drivers/ata/libata-eh.c iDroid-Project-kernel_common-9e90fd2/drivers/ata/libata-eh.c
--- linux-2.6.32-orig/drivers/ata/libata-eh.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/ata/libata-eh.c	2010-11-18 21:05:30.000000000 +0600
@@ -2019,8 +2019,9 @@
 			qc->err_mask &= ~(AC_ERR_DEV | AC_ERR_OTHER);
 
 		/* determine whether the command is worth retrying */
-		if (!(qc->err_mask & AC_ERR_INVALID) &&
-		    ((qc->flags & ATA_QCFLAG_IO) || qc->err_mask != AC_ERR_DEV))
+		if (qc->flags & ATA_QCFLAG_IO ||
+		    (!(qc->err_mask & AC_ERR_INVALID) &&
+		     qc->err_mask != AC_ERR_DEV))
 			qc->flags |= ATA_QCFLAG_RETRY;
 
 		/* accumulate error info */
diff -Nur linux-2.6.32-orig/drivers/ata/libata-sff.c iDroid-Project-kernel_common-9e90fd2/drivers/ata/libata-sff.c
--- linux-2.6.32-orig/drivers/ata/libata-sff.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/ata/libata-sff.c	2010-11-18 21:05:30.000000000 +0600
@@ -893,6 +893,9 @@
 				       do_write);
 	}
 
+	if (!do_write)
+		flush_dcache_page(page);
+
 	qc->curbytes += qc->sect_size;
 	qc->cursg_ofs += qc->sect_size;
 
diff -Nur linux-2.6.32-orig/drivers/ata/pata_cmd64x.c iDroid-Project-kernel_common-9e90fd2/drivers/ata/pata_cmd64x.c
--- linux-2.6.32-orig/drivers/ata/pata_cmd64x.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/ata/pata_cmd64x.c	2010-11-18 21:05:30.000000000 +0600
@@ -219,7 +219,7 @@
 		regU |= udma_data[adev->dma_mode - XFER_UDMA_0] << shift;
 		/* Merge the control bits */
 		regU |= 1 << adev->devno; /* UDMA on */
-		if (adev->dma_mode > 2)	/* 15nS timing */
+		if (adev->dma_mode > XFER_UDMA_2) /* 15nS timing */
 			regU |= 4 << adev->devno;
 	} else {
 		regU &= ~ (1 << adev->devno);	/* UDMA off */
diff -Nur linux-2.6.32-orig/drivers/ata/pata_hpt37x.c iDroid-Project-kernel_common-9e90fd2/drivers/ata/pata_hpt37x.c
--- linux-2.6.32-orig/drivers/ata/pata_hpt37x.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/ata/pata_hpt37x.c	2010-11-18 21:05:30.000000000 +0600
@@ -24,7 +24,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"pata_hpt37x"
-#define DRV_VERSION	"0.6.12"
+#define DRV_VERSION	"0.6.14"
 
 struct hpt_clock {
 	u8	xfer_speed;
@@ -404,9 +404,8 @@
 
 	pci_read_config_dword(pdev, addr1, &reg);
 	mode = hpt37x_find_mode(ap, adev->pio_mode);
-	mode &= ~0x8000000;	/* No FIFO in PIO */
-	mode &= ~0x30070000;	/* Leave config bits alone */
-	reg &= 0x30070000;	/* Strip timing bits */
+	mode &= 0xCFC3FFFF;	/* Leave DMA bits alone */
+	reg &= ~0xCFC3FFFF;	/* Strip timing bits */
 	pci_write_config_dword(pdev, addr1, reg | mode);
 }
 
@@ -423,8 +422,7 @@
 {
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 	u32 addr1, addr2;
-	u32 reg;
-	u32 mode;
+	u32 reg, mode, mask;
 	u8 fast;
 
 	addr1 = 0x40 + 4 * (adev->devno + 2 * ap->port_no);
@@ -436,11 +434,12 @@
 	fast |= 0x01;
 	pci_write_config_byte(pdev, addr2, fast);
 
+	mask = adev->dma_mode < XFER_UDMA_0 ? 0x31C001FF : 0x303C0000;
+
 	pci_read_config_dword(pdev, addr1, &reg);
 	mode = hpt37x_find_mode(ap, adev->dma_mode);
-	mode |= 0x8000000;	/* FIFO in MWDMA or UDMA */
-	mode &= ~0xC0000000;	/* Leave config bits alone */
-	reg &= 0xC0000000;	/* Strip timing bits */
+	mode &= mask;
+	reg &= ~mask;
 	pci_write_config_dword(pdev, addr1, reg | mode);
 }
 
@@ -508,9 +507,8 @@
 	mode = hpt37x_find_mode(ap, adev->pio_mode);
 
 	printk("Find mode for %d reports %X\n", adev->pio_mode, mode);
-	mode &= ~0x80000000;	/* No FIFO in PIO */
-	mode &= ~0x30070000;	/* Leave config bits alone */
-	reg &= 0x30070000;	/* Strip timing bits */
+	mode &= 0xCFC3FFFF;	/* Leave DMA bits alone */
+	reg &= ~0xCFC3FFFF;	/* Strip timing bits */
 	pci_write_config_dword(pdev, addr1, reg | mode);
 }
 
@@ -527,8 +525,7 @@
 {
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 	u32 addr1, addr2;
-	u32 reg;
-	u32 mode;
+	u32 reg, mode, mask;
 	u8 fast;
 
 	addr1 = 0x40 + 4 * (adev->devno + 2 * ap->port_no);
@@ -539,12 +536,13 @@
 	fast &= ~0x07;
 	pci_write_config_byte(pdev, addr2, fast);
 
+	mask = adev->dma_mode < XFER_UDMA_0 ? 0x31C001FF : 0x303C0000;
+
 	pci_read_config_dword(pdev, addr1, &reg);
 	mode = hpt37x_find_mode(ap, adev->dma_mode);
 	printk("Find mode for DMA %d reports %X\n", adev->dma_mode, mode);
-	mode &= ~0xC0000000;	/* Leave config bits alone */
-	mode |= 0x80000000;	/* FIFO in MWDMA or UDMA */
-	reg &= 0xC0000000;	/* Strip timing bits */
+	mode &= mask;
+	reg &= ~mask;
 	pci_write_config_dword(pdev, addr1, reg | mode);
 }
 
diff -Nur linux-2.6.32-orig/drivers/ata/pata_hpt3x2n.c iDroid-Project-kernel_common-9e90fd2/drivers/ata/pata_hpt3x2n.c
--- linux-2.6.32-orig/drivers/ata/pata_hpt3x2n.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/ata/pata_hpt3x2n.c	2010-11-18 21:05:30.000000000 +0600
@@ -8,7 +8,7 @@
  * Copyright (C) 1999-2003		Andre Hedrick <andre@linux-ide.org>
  * Portions Copyright (C) 2001	        Sun Microsystems, Inc.
  * Portions Copyright (C) 2003		Red Hat Inc
- * Portions Copyright (C) 2005-2007	MontaVista Software, Inc.
+ * Portions Copyright (C) 2005-2009	MontaVista Software, Inc.
  *
  *
  * TODO
@@ -25,7 +25,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"pata_hpt3x2n"
-#define DRV_VERSION	"0.3.4"
+#define DRV_VERSION	"0.3.8"
 
 enum {
 	HPT_PCI_FAST	=	(1 << 31),
@@ -185,9 +185,8 @@
 
 	pci_read_config_dword(pdev, addr1, &reg);
 	mode = hpt3x2n_find_mode(ap, adev->pio_mode);
-	mode &= ~0x8000000;	/* No FIFO in PIO */
-	mode &= ~0x30070000;	/* Leave config bits alone */
-	reg &= 0x30070000;	/* Strip timing bits */
+	mode &= 0xCFC3FFFF;	/* Leave DMA bits alone */
+	reg &= ~0xCFC3FFFF;	/* Strip timing bits */
 	pci_write_config_dword(pdev, addr1, reg | mode);
 }
 
@@ -204,8 +203,7 @@
 {
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 	u32 addr1, addr2;
-	u32 reg;
-	u32 mode;
+	u32 reg, mode, mask;
 	u8 fast;
 
 	addr1 = 0x40 + 4 * (adev->devno + 2 * ap->port_no);
@@ -216,11 +214,12 @@
 	fast &= ~0x07;
 	pci_write_config_byte(pdev, addr2, fast);
 
+	mask = adev->dma_mode < XFER_UDMA_0 ? 0x31C001FF : 0x303C0000;
+
 	pci_read_config_dword(pdev, addr1, &reg);
 	mode = hpt3x2n_find_mode(ap, adev->dma_mode);
-	mode |= 0x8000000;	/* FIFO in MWDMA or UDMA */
-	mode &= ~0xC0000000;	/* Leave config bits alone */
-	reg &= 0xC0000000;	/* Strip timing bits */
+	mode &= mask;
+	reg &= ~mask;
 	pci_write_config_dword(pdev, addr1, reg | mode);
 }
 
@@ -263,7 +262,7 @@
 
 static void hpt3x2n_set_clock(struct ata_port *ap, int source)
 {
-	void __iomem *bmdma = ap->ioaddr.bmdma_addr;
+	void __iomem *bmdma = ap->ioaddr.bmdma_addr - ap->port_no * 8;
 
 	/* Tristate the bus */
 	iowrite8(0x80, bmdma+0x73);
@@ -273,9 +272,9 @@
 	iowrite8(source, bmdma+0x7B);
 	iowrite8(0xC0, bmdma+0x79);
 
-	/* Reset state machines */
-	iowrite8(0x37, bmdma+0x70);
-	iowrite8(0x37, bmdma+0x74);
+	/* Reset state machines, avoid enabling the disabled channels */
+	iowrite8(ioread8(bmdma+0x70) | 0x32, bmdma+0x70);
+	iowrite8(ioread8(bmdma+0x74) | 0x32, bmdma+0x74);
 
 	/* Complete reset */
 	iowrite8(0x00, bmdma+0x79);
@@ -285,21 +284,10 @@
 	iowrite8(0x00, bmdma+0x77);
 }
 
-/* Check if our partner interface is busy */
-
-static int hpt3x2n_pair_idle(struct ata_port *ap)
-{
-	struct ata_host *host = ap->host;
-	struct ata_port *pair = host->ports[ap->port_no ^ 1];
-
-	if (pair->hsm_task_state == HSM_ST_IDLE)
-		return 1;
-	return 0;
-}
-
 static int hpt3x2n_use_dpll(struct ata_port *ap, int writing)
 {
 	long flags = (long)ap->host->private_data;
+
 	/* See if we should use the DPLL */
 	if (writing)
 		return USE_DPLL;	/* Needed for write */
@@ -308,20 +296,35 @@
 	return 0;
 }
 
+static int hpt3x2n_qc_defer(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	struct ata_port *alt = ap->host->ports[ap->port_no ^ 1];
+	int rc, flags = (long)ap->host->private_data;
+	int dpll = hpt3x2n_use_dpll(ap, qc->tf.flags & ATA_TFLAG_WRITE);
+
+	/* First apply the usual rules */
+	rc = ata_std_qc_defer(qc);
+	if (rc != 0)
+		return rc;
+
+	if ((flags & USE_DPLL) != dpll && alt->qc_active)
+		return ATA_DEFER_PORT;
+	return 0;
+}
+
 static unsigned int hpt3x2n_qc_issue(struct ata_queued_cmd *qc)
 {
-	struct ata_taskfile *tf = &qc->tf;
 	struct ata_port *ap = qc->ap;
 	int flags = (long)ap->host->private_data;
+	int dpll = hpt3x2n_use_dpll(ap, qc->tf.flags & ATA_TFLAG_WRITE);
 
-	if (hpt3x2n_pair_idle(ap)) {
-		int dpll = hpt3x2n_use_dpll(ap, (tf->flags & ATA_TFLAG_WRITE));
-		if ((flags & USE_DPLL) != dpll) {
-			if (dpll == 1)
-				hpt3x2n_set_clock(ap, 0x21);
-			else
-				hpt3x2n_set_clock(ap, 0x23);
-		}
+	if ((flags & USE_DPLL) != dpll) {
+		flags &= ~USE_DPLL;
+		flags |= dpll;
+		ap->host->private_data = (void *)(long)flags;
+
+		hpt3x2n_set_clock(ap, dpll ? 0x21 : 0x23);
 	}
 	return ata_sff_qc_issue(qc);
 }
@@ -338,6 +341,8 @@
 	.inherits	= &ata_bmdma_port_ops,
 
 	.bmdma_stop	= hpt3x2n_bmdma_stop,
+
+	.qc_defer	= hpt3x2n_qc_defer,
 	.qc_issue	= hpt3x2n_qc_issue,
 
 	.cable_detect	= hpt3x2n_cable_detect,
@@ -455,7 +460,7 @@
 	unsigned int f_low, f_high;
 	int adjust;
 	unsigned long iobase = pci_resource_start(dev, 4);
-	void *hpriv = NULL;
+	void *hpriv = (void *)USE_DPLL;
 	int rc;
 
 	rc = pcim_enable_device(dev);
@@ -543,7 +548,7 @@
 	/* Set our private data up. We only need a few flags so we use
 	   it directly */
 	if (pci_mhz > 60) {
-		hpriv = (void *)PCI66;
+		hpriv = (void *)(PCI66 | USE_DPLL);
 		/*
 		 * On  HPT371N, if ATA clock is 66 MHz we must set bit 2 in
 		 * the MISC. register to stretch the UltraDMA Tss timing.
diff -Nur linux-2.6.32-orig/drivers/base/class.c iDroid-Project-kernel_common-9e90fd2/drivers/base/class.c
--- linux-2.6.32-orig/drivers/base/class.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/base/class.c	2010-11-18 21:05:30.000000000 +0600
@@ -59,6 +59,8 @@
 	else
 		pr_debug("class '%s' does not have a release() function, "
 			 "be careful\n", class->name);
+
+	kfree(cp);
 }
 
 static struct sysfs_ops class_sysfs_ops = {
diff -Nur linux-2.6.32-orig/drivers/base/core.c iDroid-Project-kernel_common-9e90fd2/drivers/base/core.c
--- linux-2.6.32-orig/drivers/base/core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/base/core.c	2010-11-18 21:05:30.000000000 +0600
@@ -56,7 +56,14 @@
  */
 const char *dev_driver_string(const struct device *dev)
 {
-	return dev->driver ? dev->driver->name :
+	struct device_driver *drv;
+
+	/* dev->driver can change to NULL underneath us because of unbinding,
+	 * so be careful about accessing it.  dev->bus and dev->class should
+	 * never change once they are set, so they don't need special care.
+	 */
+	drv = ACCESS_ONCE(dev->driver);
+	return drv ? drv->name :
 			(dev->bus ? dev->bus->name :
 			(dev->class ? dev->class->name : ""));
 }
diff -Nur linux-2.6.32-orig/drivers/base/devtmpfs.c iDroid-Project-kernel_common-9e90fd2/drivers/base/devtmpfs.c
--- linux-2.6.32-orig/drivers/base/devtmpfs.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/base/devtmpfs.c	2010-11-18 21:05:30.000000000 +0600
@@ -353,6 +353,7 @@
 {
 	int err;
 	struct vfsmount *mnt;
+	char options[] = "mode=0755";
 
 	err = register_filesystem(&dev_fs_type);
 	if (err) {
@@ -361,7 +362,7 @@
 		return err;
 	}
 
-	mnt = kern_mount(&dev_fs_type);
+	mnt = kern_mount_data(&dev_fs_type, options);
 	if (IS_ERR(mnt)) {
 		err = PTR_ERR(mnt);
 		printk(KERN_ERR "devtmpfs: unable to create devtmpfs %i\n", err);
diff -Nur linux-2.6.32-orig/drivers/base/power/main.c iDroid-Project-kernel_common-9e90fd2/drivers/base/power/main.c
--- linux-2.6.32-orig/drivers/base/power/main.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/base/power/main.c	2010-11-18 21:05:30.000000000 +0600
@@ -25,6 +25,7 @@
 #include <linux/resume-trace.h>
 #include <linux/rwsem.h>
 #include <linux/interrupt.h>
+#include <linux/timer.h>
 
 #include "../base.h"
 #include "power.h"
@@ -43,6 +44,9 @@
 
 static DEFINE_MUTEX(dpm_list_mtx);
 
+static void dpm_drv_timeout(unsigned long data);
+static DEFINE_TIMER(dpm_drv_wd, dpm_drv_timeout, 0, 0);
+
 /*
  * Set once the preparation of devices for a PM transition has started, reset
  * before starting to resume devices.  Protected by dpm_list_mtx.
@@ -432,6 +436,45 @@
 }
 
 /**
+ *	dpm_drv_timeout - Driver suspend / resume watchdog handler
+ *	@data: struct device which timed out
+ *
+ * 	Called when a driver has timed out suspending or resuming.
+ * 	There's not much we can do here to recover so
+ * 	BUG() out for a crash-dump
+ *
+ */
+static void dpm_drv_timeout(unsigned long data)
+{
+	struct device *dev = (struct device *) data;
+
+	printk(KERN_EMERG "**** DPM device timeout: %s (%s)\n", dev_name(dev),
+	       (dev->driver ? dev->driver->name : "no driver"));
+	BUG();
+}
+
+/**
+ *	dpm_drv_wdset - Sets up driver suspend/resume watchdog timer.
+ *	@dev: struct device which we're guarding.
+ *
+ */
+static void dpm_drv_wdset(struct device *dev)
+{
+	dpm_drv_wd.data = (unsigned long) dev;
+	mod_timer(&dpm_drv_wd, jiffies + (HZ * 3));
+}
+
+/**
+ *	dpm_drv_wdclr - clears driver suspend/resume watchdog timer.
+ *	@dev: struct device which we're no longer guarding.
+ *
+ */
+static void dpm_drv_wdclr(struct device *dev)
+{
+	del_timer_sync(&dpm_drv_wd);
+}
+
+/**
  * dpm_resume - Execute "resume" callbacks for non-sysdev devices.
  * @state: PM transition of the system being carried out.
  *
@@ -689,7 +732,9 @@
 		get_device(dev);
 		mutex_unlock(&dpm_list_mtx);
 
+		dpm_drv_wdset(dev);
 		error = device_suspend(dev, state);
+		dpm_drv_wdclr(dev);
 
 		mutex_lock(&dpm_list_mtx);
 		if (error) {
diff -Nur linux-2.6.32-orig/drivers/base/power/runtime.c iDroid-Project-kernel_common-9e90fd2/drivers/base/power/runtime.c
--- linux-2.6.32-orig/drivers/base/power/runtime.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/base/power/runtime.c	2010-11-18 21:05:30.000000000 +0600
@@ -777,7 +777,7 @@
 	}
 
 	if (parent) {
-		spin_lock(&parent->power.lock);
+		spin_lock_nested(&parent->power.lock, SINGLE_DEPTH_NESTING);
 
 		/*
 		 * It is invalid to put an active child under a parent that is
diff -Nur linux-2.6.32-orig/drivers/block/cciss.c iDroid-Project-kernel_common-9e90fd2/drivers/block/cciss.c
--- linux-2.6.32-orig/drivers/block/cciss.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/block/cciss.c	2010-11-18 21:05:30.000000000 +0600
@@ -339,6 +339,9 @@
 	if (*pos > h->highest_lun)
 		return 0;
 
+	if (drv == NULL) /* it's possible for h->drv[] to have holes. */
+		return 0;
+
 	if (drv->heads == 0)
 		return 0;
 
diff -Nur linux-2.6.32-orig/drivers/block/iphone-block.c iDroid-Project-kernel_common-9e90fd2/drivers/block/iphone-block.c
--- linux-2.6.32-orig/drivers/block/iphone-block.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/block/iphone-block.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,347 @@
+#include <linux/blkdev.h>
+#include <linux/hdreg.h>
+#include <ftl/ftl.h>
+#include <ftl/nand.h>
+#include <linux/sched.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+
+// 2^9 = 512
+#define SECTOR_SHIFT 9
+
+extern NANDData* NANDGeometry;
+
+static struct
+{
+	spinlock_t lock;
+	struct gendisk* gd;
+	struct block_device* bdev;
+	struct request_queue* queue;
+	int sectorSize;
+	int pageShift;
+	int majorNum;
+
+	struct request* req;
+	bool processing;
+	u8* bounceBuffer;
+} iphone_block_device;
+
+static void ftl_workqueue_handler(struct work_struct* work);
+
+DECLARE_WORK(ftl_workqueue, &ftl_workqueue_handler);
+static struct workqueue_struct* ftl_wq;
+
+static void iphone_block_scatter_gather(struct request* req, bool gather)
+{
+	unsigned int offset = 0;
+	struct req_iterator iter;
+	struct bio_vec *bvec;
+	unsigned int i = 0;
+	size_t size;
+	void *buf;
+
+	rq_for_each_segment(bvec, req, iter) {
+		unsigned long flags;
+		//printk("%s:%u: bio %u: %u segs %u sectors from %lu\n",
+		//		__func__, __LINE__, i, bio_segments(iter.bio),
+		//		bio_sectors(iter.bio), (unsigned long) iter.bio->bi_sector);
+
+		size = bvec->bv_len;
+		buf = bvec_kmap_irq(bvec, &flags);
+		if (gather)
+			memcpy(iphone_block_device.bounceBuffer + offset, buf, size);
+		else
+			memcpy(buf, iphone_block_device.bounceBuffer + offset, size);
+		offset += size;
+		flush_kernel_dcache_page(bvec->bv_page);
+		bvec_kunmap_irq(bvec, &flags);
+		i++;
+	}
+
+	//printk("scatter_gather total: %d / %d\n", offset, NANDGeometry->pagesPerSuBlk * NANDGeometry->bytesPerPage);
+
+}
+
+static void ftl_workqueue_handler(struct work_struct* work)
+{
+	unsigned long flags;
+	bool dir_out;
+	int ret;
+
+	//printk("ftl_workqueue_handler enter\n");
+
+	while(true)
+	{
+		u32 lpn;
+		u32 numPages;
+		u32 remainder;
+
+		//printk("ftl_workqueue_handler loop\n");
+
+		spin_lock_irqsave(&iphone_block_device.lock, flags);
+		if(iphone_block_device.req == NULL || iphone_block_device.processing)
+		{
+			spin_unlock_irqrestore(&iphone_block_device.lock, flags);
+			//printk("ftl_workqueue_handler exit\n");
+			return;
+		}
+
+		iphone_block_device.processing = true;
+		spin_unlock_irqrestore(&iphone_block_device.lock, flags);
+
+		if(blk_fs_request(iphone_block_device.req))
+		{
+			lpn = blk_rq_pos(iphone_block_device.req) >> (iphone_block_device.pageShift - SECTOR_SHIFT);
+			numPages = blk_rq_bytes(iphone_block_device.req) / iphone_block_device.sectorSize;
+			remainder = numPages * iphone_block_device.sectorSize - blk_rq_bytes(iphone_block_device.req);
+
+			if(remainder)
+			{
+				printk("iphone_block: requested not page aligned number of bytes (%d bytes)\n", blk_rq_bytes(iphone_block_device.req));
+				blk_end_request_all(iphone_block_device.req, -EINVAL);
+			} else
+			{
+				if(rq_data_dir(iphone_block_device.req))
+				{
+					dir_out = true;
+					iphone_block_scatter_gather(iphone_block_device.req, true);
+				} else
+				{
+					dir_out = false;
+				}
+
+
+				if(dir_out)
+				{
+					//printk("FTL_Write enter: %p\n", iphone_block_device.req);
+					ret = FTL_Write(lpn, numPages, iphone_block_device.bounceBuffer);
+					//printk("FTL_Write exit: %p\n", iphone_block_device.req);
+				} else
+				{
+					//printk("FTL_Read enter: %p\n", iphone_block_device.req);
+					ret = FTL_Read(lpn, numPages, iphone_block_device.bounceBuffer);
+					//printk("FTL_Read exit: %p\n", iphone_block_device.req);
+				}
+
+				if(!dir_out)
+				{
+					iphone_block_scatter_gather(iphone_block_device.req, false);
+				}
+
+				blk_end_request_all(iphone_block_device.req, ret);
+			}
+		} else if (iphone_block_device.req->cmd_type == REQ_TYPE_LINUX_BLOCK && iphone_block_device.req->cmd[0] == REQ_LB_OP_FLUSH)
+		{
+			ftl_sync();
+
+			blk_end_request_all(iphone_block_device.req, 0);
+		} else
+		{
+			blk_end_request_all(iphone_block_device.req, -EINVAL);
+		}
+		spin_lock_irqsave(&iphone_block_device.lock, flags);
+		iphone_block_device.processing = false;
+		iphone_block_device.req = blk_fetch_request(iphone_block_device.queue);
+		spin_unlock_irqrestore(&iphone_block_device.lock, flags);
+	}
+}
+
+static int iphone_block_busy(struct request_queue *q)
+{
+	int ret = (iphone_block_device.req == NULL) ? 0 : 1;
+	printk("iphone_block_busy: %d\n", ret);
+	return ret;
+}
+
+static int iphone_block_getgeo(struct block_device* bdev, struct hd_geometry* geo)
+{
+	long size = (NANDGeometry->pagesPerSuBlk * NANDGeometry->userSuBlksTotal) * (iphone_block_device.sectorSize >> SECTOR_SHIFT);
+
+	geo->heads = 64;
+	geo->sectors = 32;
+	geo->cylinders = size / (geo->heads * geo->sectors);
+
+	return 0;
+}
+
+static int iphone_block_open(struct block_device* bdev, fmode_t mode)
+{
+	return 0;
+}
+
+static int iphone_block_release(struct gendisk *disk, fmode_t mode)
+{
+	ftl_sync();
+	return 0;
+}
+
+static int iphone_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, unsigned long arg)
+{
+	switch(cmd)
+	{
+		case BLKFLSBUF:
+			ftl_sync();
+			return 0;
+		default:
+			return -ENOTTY;
+	}
+}
+
+static void iphone_block_request(struct request_queue* q)
+{
+	if(iphone_block_device.req)
+	{
+		//printk("not queueing request due to busy\n");
+		return;
+	}
+
+	iphone_block_device.req = blk_fetch_request(q);
+
+	//printk("scheduling work: %p\n", iphone_block_device.req);
+	queue_work(ftl_wq, &ftl_workqueue);
+}
+
+static struct block_device_operations iphone_block_fops =
+{
+	.owner		= THIS_MODULE,
+	.getgeo		= iphone_block_getgeo,
+	.open		= iphone_block_open,
+	.release	= iphone_block_release,
+	.ioctl		= iphone_block_ioctl
+};
+
+static int iphone_block_probe(struct platform_device *pdev)
+{
+	int i;
+
+	ftl_wq = create_workqueue("iphone_ftl_worker");
+
+	if(ftl_setup() != 0)
+		return -EIO;
+
+	for(i = 0; i < 31; ++i)
+	{
+		if((1 << i) == NANDGeometry->bytesPerPage)
+		{
+			iphone_block_device.pageShift = i;
+			break;
+		}
+	}
+
+	spin_lock_init(&iphone_block_device.lock);
+
+	iphone_block_device.processing = false;
+	iphone_block_device.req = NULL;
+
+	iphone_block_device.bounceBuffer = (u8*) kmalloc(NANDGeometry->pagesPerSuBlk * NANDGeometry->bytesPerPage, GFP_KERNEL | GFP_DMA);
+	if(!iphone_block_device.bounceBuffer)
+		return -EIO;
+
+	iphone_block_device.sectorSize = NANDGeometry->bytesPerPage;
+	iphone_block_device.majorNum = register_blkdev(0, "nand");
+
+	iphone_block_device.gd = alloc_disk(5);
+	if(!iphone_block_device.gd)
+		goto out_unregister;
+
+	iphone_block_device.gd->major = iphone_block_device.majorNum;
+	iphone_block_device.gd->first_minor = 0;
+	iphone_block_device.gd->fops = &iphone_block_fops;
+	iphone_block_device.gd->private_data = &iphone_block_device;
+	strcpy(iphone_block_device.gd->disk_name, "nand0");
+
+	iphone_block_device.queue = blk_init_queue(iphone_block_request, &iphone_block_device.lock);
+	if(!iphone_block_device.queue)
+		goto out_put_disk;
+
+	blk_queue_lld_busy(iphone_block_device.queue, iphone_block_busy);
+	blk_queue_bounce_limit(iphone_block_device.queue, BLK_BOUNCE_ANY);
+	blk_queue_max_sectors(iphone_block_device.queue, NANDGeometry->pagesPerSuBlk * (iphone_block_device.sectorSize >> SECTOR_SHIFT));
+	blk_queue_max_segment_size(iphone_block_device.queue, NANDGeometry->pagesPerSuBlk * iphone_block_device.sectorSize);
+	blk_queue_physical_block_size(iphone_block_device.queue, iphone_block_device.sectorSize);
+	blk_queue_logical_block_size(iphone_block_device.queue, iphone_block_device.sectorSize);
+	iphone_block_device.gd->queue = iphone_block_device.queue;
+
+	set_capacity(iphone_block_device.gd, (NANDGeometry->pagesPerSuBlk * NANDGeometry->userSuBlksTotal) * (iphone_block_device.sectorSize >> SECTOR_SHIFT));
+	add_disk(iphone_block_device.gd);
+
+	printk("iphone-block: block device registered with major num %d\n", iphone_block_device.majorNum);
+
+	return 0;
+
+out_put_disk:
+	put_disk(iphone_block_device.gd);
+
+out_unregister:
+	unregister_blkdev(iphone_block_device.majorNum, "nand");
+	kfree(iphone_block_device.bounceBuffer);
+
+	return -ENOMEM;
+}
+
+static int iphone_block_remove(struct platform_device *pdev)
+{
+	del_gendisk(iphone_block_device.gd);
+	put_disk(iphone_block_device.gd);
+	blk_cleanup_queue(iphone_block_device.queue);
+	unregister_blkdev(iphone_block_device.majorNum, "nand");
+	flush_workqueue(ftl_wq);
+	kfree(iphone_block_device.bounceBuffer);
+	ftl_sync();
+	printk("iphone-block: block device unregistered\n");
+	return 0;
+}
+
+static void iphone_block_shutdown(struct platform_device *pdev)
+{
+	ftl_sync();
+}
+
+static struct platform_driver iphone_block_driver = {
+	.probe = iphone_block_probe,
+	.remove = iphone_block_remove,
+	.suspend = NULL, /* optional but recommended */
+	.resume = NULL,   /* optional but recommended */
+	.shutdown = iphone_block_shutdown,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "iphone-block",
+	},
+};
+
+static struct platform_device iphone_block_dev = {
+	.name = "iphone-block",
+	.id = -1,
+};
+
+    /*
+     *  Setup
+     */
+
+static int __init iphone_block_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&iphone_block_driver);
+
+	if (!ret) {
+		ret = platform_device_register(&iphone_block_dev);
+
+		if (ret != 0) {
+			platform_driver_unregister(&iphone_block_driver);
+		}
+	}
+
+	return ret;
+}
+
+static void __exit iphone_block_exit(void)
+{
+	platform_device_unregister(&iphone_block_dev);
+	platform_driver_unregister(&iphone_block_driver);
+}
+
+module_init(iphone_block_init);
+module_exit(iphone_block_exit);
+
diff -Nur linux-2.6.32-orig/drivers/block/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/block/Kconfig
--- linux-2.6.32-orig/drivers/block/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/block/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -15,6 +15,10 @@
 
 if BLK_DEV
 
+config IPHONE_BLK
+	tristate "iPhone NAND block device"
+	depends on MACH_APPLE_IPHONE
+
 config BLK_DEV_FD
 	tristate "Normal floppy disk support"
 	depends on ARCH_MAY_HAVE_PC_FDC
diff -Nur linux-2.6.32-orig/drivers/block/loop.c iDroid-Project-kernel_common-9e90fd2/drivers/block/loop.c
--- linux-2.6.32-orig/drivers/block/loop.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/block/loop.c	2010-11-18 21:05:30.000000000 +0600
@@ -1202,6 +1202,37 @@
 
 	mutex_lock_nested(&lo->lo_ctl_mutex, 1);
 	switch (cmd) {
+	case BLKROSET:
+		if(arg)
+		{
+			if((lo->lo_flags & LO_FLAGS_READ_ONLY) == 0)
+			{
+				/* Read-write to read-only */
+		loop_flush(lo);
+		lo->lo_flags |= LO_FLAGS_READ_ONLY;
+				set_device_ro(bdev, 1);
+		drop_file_write_access(lo->lo_backing_file);
+		lo->lo_backing_file->f_mode &= ~FMODE_WRITE;
+		err = 0;
+			} else
+			{
+				/* Read-only to read-only */
+				err = 0;
+			}
+		} else
+		{
+			if((lo->lo_flags & LO_FLAGS_READ_ONLY) == 0)
+			{
+				/* Read-write to read-write */
+				err = 0;
+			} else
+			{
+				/* Read-only to read-write */
+				/* Unsupported; just open the file again for writing and use LOOP_CHANGE_FD */
+				err = -EINVAL;
+			}
+		}
+		break;
 	case LOOP_SET_FD:
 		err = loop_set_fd(lo, mode, bdev, arg);
 		break;
@@ -1385,6 +1416,7 @@
 		arg = (unsigned long) compat_ptr(arg);
 	case LOOP_SET_FD:
 	case LOOP_CHANGE_FD:
+	case BLKROSET:
 		err = lo_ioctl(bdev, mode, cmd, arg);
 		break;
 	default:
diff -Nur linux-2.6.32-orig/drivers/block/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/block/Makefile
--- linux-2.6.32-orig/drivers/block/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/block/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -24,6 +24,7 @@
 obj-$(CONFIG_MG_DISK)		+= mg_disk.o
 obj-$(CONFIG_SUNVDC)		+= sunvdc.o
 obj-$(CONFIG_BLK_DEV_OSD)	+= osdblk.o
+obj-$(CONFIG_IPHONE_BLK)	+= iphone-block.o
 
 obj-$(CONFIG_BLK_DEV_UMEM)	+= umem.o
 obj-$(CONFIG_BLK_DEV_NBD)	+= nbd.o
diff -Nur linux-2.6.32-orig/drivers/block/pktcdvd.c iDroid-Project-kernel_common-9e90fd2/drivers/block/pktcdvd.c
--- linux-2.6.32-orig/drivers/block/pktcdvd.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/block/pktcdvd.c	2010-11-18 21:05:30.000000000 +0600
@@ -322,7 +322,7 @@
 	pkt_kobj_remove(pd->kobj_stat);
 	pkt_kobj_remove(pd->kobj_wqueue);
 	if (class_pktcdvd)
-		device_destroy(class_pktcdvd, pd->pkt_dev);
+		device_unregister(pd->dev);
 }
 
 
diff -Nur linux-2.6.32-orig/drivers/bluetooth/btusb.c iDroid-Project-kernel_common-9e90fd2/drivers/bluetooth/btusb.c
--- linux-2.6.32-orig/drivers/bluetooth/btusb.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/bluetooth/btusb.c	2010-11-18 21:05:30.000000000 +0600
@@ -307,6 +307,7 @@
 		return;
 
 	usb_anchor_urb(urb, &data->bulk_anchor);
+	usb_mark_last_busy(data->udev);
 
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
diff -Nur linux-2.6.32-orig/drivers/char/agp/intel-agp.c iDroid-Project-kernel_common-9e90fd2/drivers/char/agp/intel-agp.c
--- linux-2.6.32-orig/drivers/char/agp/intel-agp.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/char/agp/intel-agp.c	2010-11-18 21:05:30.000000000 +0600
@@ -178,6 +178,7 @@
 	 * popup and for the GTT.
 	 */
 	int gtt_entries;			/* i830+ */
+	int gtt_total_size;
 	union {
 		void __iomem *i9xx_flush_page;
 		void *i8xx_flush_page;
@@ -1153,7 +1154,7 @@
 	readl(intel_private.registers+I810_PGETBL_CTL);	/* PCI Posting. */
 
 	if (agp_bridge->driver->needs_scratch_page) {
-		for (i = intel_private.gtt_entries; i < current_size->num_entries; i++) {
+		for (i = intel_private.gtt_entries; i < intel_private.gtt_total_size; i++) {
 			writel(agp_bridge->scratch_page, intel_private.gtt+i);
 		}
 		readl(intel_private.gtt+i-1);	/* PCI Posting. */
@@ -1308,6 +1309,8 @@
 	if (!intel_private.gtt)
 		return -ENOMEM;
 
+	intel_private.gtt_total_size = gtt_map_size / 4;
+
 	temp &= 0xfff80000;
 
 	intel_private.registers = ioremap(temp, 128 * 4096);
@@ -1395,6 +1398,8 @@
 	if (!intel_private.gtt)
 		return -ENOMEM;
 
+	intel_private.gtt_total_size = gtt_size / 4;
+
 	intel_private.registers = ioremap(temp, 128 * 4096);
 	if (!intel_private.registers) {
 		iounmap(intel_private.gtt);
diff -Nur linux-2.6.32-orig/drivers/char/dcc_tty.c iDroid-Project-kernel_common-9e90fd2/drivers/char/dcc_tty.c
--- linux-2.6.32-orig/drivers/char/dcc_tty.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/char/dcc_tty.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,326 @@
+/* drivers/char/dcc_tty.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/console.h>
+#include <linux/hrtimer.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+
+MODULE_DESCRIPTION("DCC TTY Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+static spinlock_t g_dcc_tty_lock = SPIN_LOCK_UNLOCKED;
+static struct hrtimer g_dcc_timer;
+static char g_dcc_buffer[16];
+static int g_dcc_buffer_head;
+static int g_dcc_buffer_count;
+static unsigned g_dcc_write_delay_usecs = 1;
+static struct tty_driver *g_dcc_tty_driver;
+static struct tty_struct *g_dcc_tty;
+static int g_dcc_tty_open_count;
+
+static void dcc_poll_locked(void)
+{
+	char ch;
+	int rch;
+	int written;
+
+	while (g_dcc_buffer_count) {
+		ch = g_dcc_buffer[g_dcc_buffer_head];
+		asm(
+			"mrc 14, 0, r15, c0, c1, 0\n"
+			"mcrcc 14, 0, %1, c0, c5, 0\n"
+			"movcc %0, #1\n"
+			"movcs %0, #0\n"
+			: "=r" (written)
+			: "r" (ch)
+		);
+		if (written) {
+			if (ch == '\n')
+				g_dcc_buffer[g_dcc_buffer_head] = '\r';
+			else {
+				g_dcc_buffer_head = (g_dcc_buffer_head + 1) % ARRAY_SIZE(g_dcc_buffer);
+				g_dcc_buffer_count--;
+				if (g_dcc_tty)
+					tty_wakeup(g_dcc_tty);
+			}
+			g_dcc_write_delay_usecs = 1;
+		} else {
+			if (g_dcc_write_delay_usecs > 0x100)
+				break;
+			g_dcc_write_delay_usecs <<= 1;
+			udelay(g_dcc_write_delay_usecs);
+		}
+	}
+
+	if (g_dcc_tty && !test_bit(TTY_THROTTLED, &g_dcc_tty->flags)) {
+		asm(
+			"mrc 14, 0, %0, c0, c1, 0\n"
+			"tst %0, #(1 << 30)\n"
+			"moveq %0, #-1\n"
+			"mrcne 14, 0, %0, c0, c5, 0\n"
+			: "=r" (rch)
+		);
+		if (rch >= 0) {
+			ch = rch;
+			tty_insert_flip_string(g_dcc_tty, &ch, 1);
+			tty_flip_buffer_push(g_dcc_tty);
+		}
+	}
+
+
+	if (g_dcc_buffer_count)
+		hrtimer_start(&g_dcc_timer, ktime_set(0, g_dcc_write_delay_usecs * NSEC_PER_USEC), HRTIMER_MODE_REL);
+	else
+		hrtimer_start(&g_dcc_timer, ktime_set(0, 20 * NSEC_PER_MSEC), HRTIMER_MODE_REL);
+}
+
+static int dcc_tty_open(struct tty_struct * tty, struct file * filp)
+{
+	int ret;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&g_dcc_tty_lock, irq_flags);
+	if (g_dcc_tty == NULL || g_dcc_tty == tty) {
+		g_dcc_tty = tty;
+		g_dcc_tty_open_count++;
+		ret = 0;
+	} else
+		ret = -EBUSY;
+	spin_unlock_irqrestore(&g_dcc_tty_lock, irq_flags);
+
+	printk("dcc_tty_open, tty %p, f_flags %x, returned %d\n", tty, filp->f_flags, ret);
+
+	return ret;
+}
+
+static void dcc_tty_close(struct tty_struct * tty, struct file * filp)
+{
+	printk("dcc_tty_close, tty %p, f_flags %x\n", tty, filp->f_flags);
+	if (g_dcc_tty == tty) {
+		if (--g_dcc_tty_open_count == 0)
+			g_dcc_tty = NULL;
+	}
+}
+
+static int dcc_write(const unsigned char *buf_start, int count)
+{
+	const unsigned char *buf = buf_start;
+	unsigned long irq_flags;
+	int copy_len;
+	int space_left;
+	int tail;
+
+	if (count < 1)
+		return 0;
+
+	spin_lock_irqsave(&g_dcc_tty_lock, irq_flags);
+	do {
+		tail = (g_dcc_buffer_head + g_dcc_buffer_count) % ARRAY_SIZE(g_dcc_buffer);
+		copy_len = ARRAY_SIZE(g_dcc_buffer) - tail;
+		space_left = ARRAY_SIZE(g_dcc_buffer) - g_dcc_buffer_count;
+		if (copy_len > space_left)
+			copy_len = space_left;
+		if (copy_len > count)
+			copy_len = count;
+		memcpy(&g_dcc_buffer[tail], buf, copy_len);
+		g_dcc_buffer_count += copy_len;
+		buf += copy_len;
+		count -= copy_len;
+		if (copy_len < count && copy_len < space_left) {
+			space_left -= copy_len;
+			copy_len = count;
+			if (copy_len > space_left) {
+				copy_len = space_left;
+			}
+			memcpy(g_dcc_buffer, buf, copy_len);
+			buf += copy_len;
+			count -= copy_len;
+			g_dcc_buffer_count += copy_len;
+		}
+		dcc_poll_locked();
+		space_left = ARRAY_SIZE(g_dcc_buffer) - g_dcc_buffer_count;
+	} while(count && space_left);
+	spin_unlock_irqrestore(&g_dcc_tty_lock, irq_flags);
+	return buf - buf_start;
+}
+
+static int dcc_tty_write(struct tty_struct * tty, const unsigned char *buf, int count)
+{
+	int ret;
+	/* printk("dcc_tty_write %p, %d\n", buf, count); */
+	ret = dcc_write(buf, count);
+	if (ret != count)
+		printk("dcc_tty_write %p, %d, returned %d\n", buf, count, ret);
+	return ret;
+}
+
+static int dcc_tty_write_room(struct tty_struct *tty)
+{
+	int space_left;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&g_dcc_tty_lock, irq_flags);
+	space_left = ARRAY_SIZE(g_dcc_buffer) - g_dcc_buffer_count;
+	spin_unlock_irqrestore(&g_dcc_tty_lock, irq_flags);
+	return space_left;
+}
+
+static int dcc_tty_chars_in_buffer(struct tty_struct *tty)
+{
+	int ret;
+	asm(
+		"mrc 14, 0, %0, c0, c1, 0\n"
+		"mov %0, %0, LSR #30\n"
+		"and %0, %0, #1\n"
+		: "=r" (ret)
+	);
+	return ret;
+}
+
+static void dcc_tty_unthrottle(struct tty_struct * tty)
+{
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&g_dcc_tty_lock, irq_flags);
+	dcc_poll_locked();
+	spin_unlock_irqrestore(&g_dcc_tty_lock, irq_flags);
+}
+
+static enum hrtimer_restart dcc_tty_timer_func(struct hrtimer *timer)
+{
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&g_dcc_tty_lock, irq_flags);
+	dcc_poll_locked();
+	spin_unlock_irqrestore(&g_dcc_tty_lock, irq_flags);
+	return HRTIMER_NORESTART;
+}
+
+void dcc_console_write(struct console *co, const char *b, unsigned count)
+{
+#if 1
+	dcc_write(b, count);
+#else
+	/* blocking printk */
+	while (count > 0) {
+		int written;
+		written = dcc_write(b, count);
+		if (written) {
+			b += written;
+			count -= written;
+		}
+	}
+#endif
+}
+
+static struct tty_driver *dcc_console_device(struct console *c, int *index)
+{
+	*index = 0;
+	return g_dcc_tty_driver;
+}
+
+static int __init dcc_console_setup(struct console *co, char *options)
+{
+	if (co->index != 0)
+		return -ENODEV;
+	return 0;
+}
+
+
+static struct console dcc_console =
+{
+	.name		= "ttyDCC",
+	.write		= dcc_console_write,
+	.device		= dcc_console_device,
+	.setup		= dcc_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+};
+
+static struct tty_operations dcc_tty_ops = {
+	.open = dcc_tty_open,
+	.close = dcc_tty_close,
+	.write = dcc_tty_write,
+	.write_room = dcc_tty_write_room,
+	.chars_in_buffer = dcc_tty_chars_in_buffer,
+	.unthrottle = dcc_tty_unthrottle,
+};
+
+static int __init dcc_tty_init(void)
+{
+	int ret;
+
+	hrtimer_init(&g_dcc_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	g_dcc_timer.function = dcc_tty_timer_func;
+
+	g_dcc_tty_driver = alloc_tty_driver(1);
+	if (!g_dcc_tty_driver) {
+		printk(KERN_ERR "dcc_tty_probe: alloc_tty_driver failed\n");
+		ret = -ENOMEM;
+		goto err_alloc_tty_driver_failed;
+	}
+	g_dcc_tty_driver->owner = THIS_MODULE;
+	g_dcc_tty_driver->driver_name = "dcc";
+	g_dcc_tty_driver->name = "ttyDCC";
+	g_dcc_tty_driver->major = 0; // auto assign
+	g_dcc_tty_driver->minor_start = 0;
+	g_dcc_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
+	g_dcc_tty_driver->subtype = SERIAL_TYPE_NORMAL;
+	g_dcc_tty_driver->init_termios = tty_std_termios;
+	g_dcc_tty_driver->flags = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	tty_set_operations(g_dcc_tty_driver, &dcc_tty_ops);
+	ret = tty_register_driver(g_dcc_tty_driver);
+	if (ret) {
+		printk(KERN_ERR "dcc_tty_probe: tty_register_driver failed, %d\n", ret);
+		goto err_tty_register_driver_failed;
+	}
+	tty_register_device(g_dcc_tty_driver, 0, NULL);
+
+	register_console(&dcc_console);
+	hrtimer_start(&g_dcc_timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+
+	return 0;
+
+err_tty_register_driver_failed:
+	put_tty_driver(g_dcc_tty_driver);
+	g_dcc_tty_driver = NULL;
+err_alloc_tty_driver_failed:
+	return ret;
+}
+
+static void  __exit dcc_tty_exit(void)
+{
+	int ret;
+
+	tty_unregister_device(g_dcc_tty_driver, 0);
+	ret = tty_unregister_driver(g_dcc_tty_driver);
+	if (ret < 0) {
+		printk(KERN_ERR "dcc_tty_remove: tty_unregister_driver failed, %d\n", ret);
+	} else {
+		put_tty_driver(g_dcc_tty_driver);
+	}
+	g_dcc_tty_driver = NULL;
+}
+
+module_init(dcc_tty_init);
+module_exit(dcc_tty_exit);
+
+
diff -Nur linux-2.6.32-orig/drivers/char/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/char/Kconfig
--- linux-2.6.32-orig/drivers/char/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/char/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -88,6 +88,19 @@
 	 information. For framebuffer console users, please refer to
 	 <file:Documentation/fb/fbcon.txt>.
 
+config DEVMEM
+	bool "Memory device driver"
+	default y
+	help
+	  The memory driver provides two character devices, mem and kmem, which
+	  provide access to the system's memory. The mem device is a view of
+	  physical memory, and each byte in the device corresponds to the
+	  matching physical address. The kmem device is the same as mem, but
+	  the addresses correspond to the kernel's virtual address space rather
+	  than physical memory. These devices are standard parts of a Linux
+	  system and most users should say Y here. You might say N if very
+	  security conscience or memory is tight.
+
 config DEVKMEM
 	bool "/dev/kmem virtual device support"
 	default y
@@ -1116,6 +1129,10 @@
 	depends on ISA || PCI
 	default y
 
+config DCC_TTY
+	tristate "DCC tty driver"
+	depends on ARM
+
 source "drivers/s390/char/Kconfig"
 
 endmenu
diff -Nur linux-2.6.32-orig/drivers/char/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/char/Makefile
--- linux-2.6.32-orig/drivers/char/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/char/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -107,6 +107,7 @@
 obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM)		+= tpm/
 
+obj-$(CONFIG_DCC_TTY)		+= dcc_tty.o
 obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
 
 obj-$(CONFIG_JS_RTC)		+= js-rtc.o
diff -Nur linux-2.6.32-orig/drivers/char/mem.c iDroid-Project-kernel_common-9e90fd2/drivers/char/mem.c
--- linux-2.6.32-orig/drivers/char/mem.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/char/mem.c	2010-11-18 21:05:30.000000000 +0600
@@ -35,6 +35,19 @@
 # include <linux/efi.h>
 #endif
 
+static inline unsigned long size_inside_page(unsigned long start,
+					     unsigned long size)
+{
+	unsigned long sz;
+
+	if (-start & (PAGE_SIZE - 1))
+		sz = -start & (PAGE_SIZE - 1);
+	else
+		sz = PAGE_SIZE;
+
+	return min_t(unsigned long, sz, size);
+}
+
 /*
  * Architectures vary in how they handle caching for addresses
  * outside of main memory.
@@ -80,6 +93,7 @@
 }
 #endif
 
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM)
 #ifdef CONFIG_STRICT_DEVMEM
 static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 {
@@ -105,7 +119,9 @@
 	return 1;
 }
 #endif
+#endif
 
+#ifdef CONFIG_DEVMEM
 void __attribute__((weak)) unxlate_dev_mem_ptr(unsigned long phys, void *addr)
 {
 }
@@ -254,6 +270,9 @@
 	*ppos += written;
 	return written;
 }
+#endif	/* CONFIG_DEVMEM */
+
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM)
 
 int __attribute__((weak)) phys_mem_access_prot_allowed(struct file *file,
 	unsigned long pfn, unsigned long size, pgprot_t *vma_prot)
@@ -340,6 +359,7 @@
 	}
 	return 0;
 }
+#endif	/* CONFIG_DEVMEM */
 
 #ifdef CONFIG_DEVKMEM
 static int mmap_kmem(struct file * file, struct vm_area_struct * vma)
@@ -408,6 +428,7 @@
 	unsigned long p = *ppos;
 	ssize_t low_count, read, sz;
 	char * kbuf; /* k-addr because vread() takes vmlist_lock rwlock */
+	int err = 0;
 
 	read = 0;
 	if (p < (unsigned long) high_memory) {
@@ -430,15 +451,7 @@
 		}
 #endif
 		while (low_count > 0) {
-			/*
-			 * Handle first page in case it's not aligned
-			 */
-			if (-p & (PAGE_SIZE - 1))
-				sz = -p & (PAGE_SIZE - 1);
-			else
-				sz = PAGE_SIZE;
-
-			sz = min_t(unsigned long, sz, low_count);
+			sz = size_inside_page(p, low_count);
 
 			/*
 			 * On ia64 if a page has been mapped somewhere as
@@ -462,16 +475,18 @@
 		if (!kbuf)
 			return -ENOMEM;
 		while (count > 0) {
-			int len = count;
+			int len = size_inside_page(p, count);
 
-			if (len > PAGE_SIZE)
-				len = PAGE_SIZE;
+			if (!is_vmalloc_or_module_addr((void *)p)) {
+				err = -ENXIO;
+				break;
+			}
 			len = vread(kbuf, (char *)p, len);
 			if (!len)
 				break;
 			if (copy_to_user(buf, kbuf, len)) {
-				free_page((unsigned long)kbuf);
-				return -EFAULT;
+				err = -EFAULT;
+				break;
 			}
 			count -= len;
 			buf += len;
@@ -480,8 +495,8 @@
 		}
 		free_page((unsigned long)kbuf);
 	}
- 	*ppos = p;
- 	return read;
+	*ppos = p;
+	return read ? read : err;
 }
 
 
@@ -510,15 +525,8 @@
 
 	while (count > 0) {
 		char *ptr;
-		/*
-		 * Handle first page in case it's not aligned
-		 */
-		if (-realp & (PAGE_SIZE - 1))
-			sz = -realp & (PAGE_SIZE - 1);
-		else
-			sz = PAGE_SIZE;
 
-		sz = min_t(unsigned long, sz, count);
+		sz = size_inside_page(realp, count);
 
 		/*
 		 * On ia64 if a page has been mapped somewhere as
@@ -557,6 +565,7 @@
 	ssize_t virtr = 0;
 	ssize_t written;
 	char * kbuf; /* k-addr because vwrite() takes vmlist_lock rwlock */
+	int err = 0;
 
 	if (p < (unsigned long) high_memory) {
 
@@ -578,20 +587,20 @@
 		if (!kbuf)
 			return wrote ? wrote : -ENOMEM;
 		while (count > 0) {
-			int len = count;
+			int len = size_inside_page(p, count);
 
-			if (len > PAGE_SIZE)
-				len = PAGE_SIZE;
+			if (!is_vmalloc_or_module_addr((void *)p)) {
+				err = -ENXIO;
+				break;
+			}
 			if (len) {
 				written = copy_from_user(kbuf, buf, len);
 				if (written) {
-					if (wrote + virtr)
-						break;
-					free_page((unsigned long)kbuf);
-					return -EFAULT;
+					err = -EFAULT;
+					break;
 				}
 			}
-			len = vwrite(kbuf, (char *)p, len);
+			vwrite(kbuf, (char *)p, len);
 			count -= len;
 			buf += len;
 			virtr += len;
@@ -600,8 +609,8 @@
 		free_page((unsigned long)kbuf);
 	}
 
- 	*ppos = p;
- 	return virtr + wrote;
+	*ppos = p;
+	return virtr + wrote ? : err;
 }
 #endif
 
@@ -730,6 +739,8 @@
 	return file->f_pos = 0;
 }
 
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM) || defined(CONFIG_DEVPORT)
+
 /*
  * The memory devices use the full 32/64 bits of the offset, and so we cannot
  * check against negative addresses: they are ok. The return value is weird,
@@ -761,10 +772,14 @@
 	return ret;
 }
 
+#endif
+
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM) || defined(CONFIG_DEVPORT)
 static int open_port(struct inode * inode, struct file * filp)
 {
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
 }
+#endif
 
 #define zero_lseek	null_lseek
 #define full_lseek      null_lseek
@@ -774,6 +789,7 @@
 #define open_kmem	open_mem
 #define open_oldmem	open_mem
 
+#ifdef CONFIG_DEVMEM
 static const struct file_operations mem_fops = {
 	.llseek		= memory_lseek,
 	.read		= read_mem,
@@ -782,6 +798,7 @@
 	.open		= open_mem,
 	.get_unmapped_area = get_unmapped_area_mem,
 };
+#endif
 
 #ifdef CONFIG_DEVKMEM
 static const struct file_operations kmem_fops = {
@@ -870,7 +887,9 @@
 	const struct file_operations *fops;
 	struct backing_dev_info *dev_info;
 } devlist[] = {
+#ifdef CONFIG_DEVMEM
 	 [1] = { "mem", 0, &mem_fops, &directly_mappable_cdev_bdi },
+#endif
 #ifdef CONFIG_DEVKMEM
 	 [2] = { "kmem", 0, &kmem_fops, &directly_mappable_cdev_bdi },
 #endif
diff -Nur linux-2.6.32-orig/drivers/char/nozomi.c iDroid-Project-kernel_common-9e90fd2/drivers/char/nozomi.c
--- linux-2.6.32-orig/drivers/char/nozomi.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/char/nozomi.c	2010-11-18 21:05:30.000000000 +0600
@@ -1629,10 +1629,10 @@
 
 	dc->open_ttys--;
 	port->count--;
-	tty_port_tty_set(port, NULL);
 
 	if (port->count == 0) {
 		DBG1("close: %d", nport->token_dl);
+		tty_port_tty_set(port, NULL);
 		spin_lock_irqsave(&dc->spin_mutex, flags);
 		dc->last_ier &= ~(nport->token_dl);
 		writew(dc->last_ier, dc->reg_ier);
diff -Nur linux-2.6.32-orig/drivers/char/random.c iDroid-Project-kernel_common-9e90fd2/drivers/char/random.c
--- linux-2.6.32-orig/drivers/char/random.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/char/random.c	2010-11-18 21:05:30.000000000 +0600
@@ -1051,12 +1051,6 @@
 				/* like a named pipe */
 	}
 
-	/*
-	 * If we gave the user some bytes, update the access time.
-	 */
-	if (count)
-		file_accessed(file);
-
 	return (count ? count : retval);
 }
 
@@ -1107,7 +1101,6 @@
 			    size_t count, loff_t *ppos)
 {
 	size_t ret;
-	struct inode *inode = file->f_path.dentry->d_inode;
 
 	ret = write_pool(&blocking_pool, buffer, count);
 	if (ret)
@@ -1116,8 +1109,6 @@
 	if (ret)
 		return ret;
 
-	inode->i_mtime = current_fs_time(inode->i_sb);
-	mark_inode_dirty(inode);
 	return (ssize_t)count;
 }
 
diff -Nur linux-2.6.32-orig/drivers/char/tpm/tpm_infineon.c iDroid-Project-kernel_common-9e90fd2/drivers/char/tpm/tpm_infineon.c
--- linux-2.6.32-orig/drivers/char/tpm/tpm_infineon.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/char/tpm/tpm_infineon.c	2010-11-18 21:05:30.000000000 +0600
@@ -39,12 +39,12 @@
 struct tpm_inf_dev {
 	int iotype;
 
-	void __iomem *mem_base;		/* MMIO ioremap'd addr */
-	unsigned long map_base;		/* phys MMIO base */
-	unsigned long map_size;		/* MMIO region size */
-	unsigned int index_off;		/* index register offset */
+	void __iomem *mem_base;	/* MMIO ioremap'd addr */
+	unsigned long map_base;	/* phys MMIO base */
+	unsigned long map_size;	/* MMIO region size */
+	unsigned int index_off;	/* index register offset */
 
-	unsigned int data_regs;		/* Data registers */
+	unsigned int data_regs;	/* Data registers */
 	unsigned int data_size;
 
 	unsigned int config_port;	/* IO Port config index reg */
@@ -406,14 +406,14 @@
 	.miscdev = {.fops = &inf_ops,},
 };
 
-static const struct pnp_device_id tpm_pnp_tbl[] = {
+static const struct pnp_device_id tpm_inf_pnp_tbl[] = {
 	/* Infineon TPMs */
 	{"IFX0101", 0},
 	{"IFX0102", 0},
 	{"", 0}
 };
 
-MODULE_DEVICE_TABLE(pnp, tpm_pnp_tbl);
+MODULE_DEVICE_TABLE(pnp, tpm_inf_pnp_tbl);
 
 static int __devinit tpm_inf_pnp_probe(struct pnp_dev *dev,
 				       const struct pnp_device_id *dev_id)
@@ -430,7 +430,7 @@
 	if (pnp_port_valid(dev, 0) && pnp_port_valid(dev, 1) &&
 	    !(pnp_port_flags(dev, 0) & IORESOURCE_DISABLED)) {
 
-	    	tpm_dev.iotype = TPM_INF_IO_PORT;
+		tpm_dev.iotype = TPM_INF_IO_PORT;
 
 		tpm_dev.config_port = pnp_port_start(dev, 0);
 		tpm_dev.config_size = pnp_port_len(dev, 0);
@@ -459,9 +459,9 @@
 			goto err_last;
 		}
 	} else if (pnp_mem_valid(dev, 0) &&
-	           !(pnp_mem_flags(dev, 0) & IORESOURCE_DISABLED)) {
+		   !(pnp_mem_flags(dev, 0) & IORESOURCE_DISABLED)) {
 
-	    	tpm_dev.iotype = TPM_INF_IO_MEM;
+		tpm_dev.iotype = TPM_INF_IO_MEM;
 
 		tpm_dev.map_base = pnp_mem_start(dev, 0);
 		tpm_dev.map_size = pnp_mem_len(dev, 0);
@@ -563,11 +563,11 @@
 			 "product id 0x%02x%02x"
 			 "%s\n",
 			 tpm_dev.iotype == TPM_INF_IO_PORT ?
-				tpm_dev.config_port :
-				tpm_dev.map_base + tpm_dev.index_off,
+			 tpm_dev.config_port :
+			 tpm_dev.map_base + tpm_dev.index_off,
 			 tpm_dev.iotype == TPM_INF_IO_PORT ?
-				tpm_dev.data_regs :
-				tpm_dev.map_base + tpm_dev.data_regs,
+			 tpm_dev.data_regs :
+			 tpm_dev.map_base + tpm_dev.data_regs,
 			 version[0], version[1],
 			 vendorid[0], vendorid[1],
 			 productid[0], productid[1], chipname);
@@ -607,20 +607,55 @@
 			iounmap(tpm_dev.mem_base);
 			release_mem_region(tpm_dev.map_base, tpm_dev.map_size);
 		}
+		tpm_dev_vendor_release(chip);
 		tpm_remove_hardware(chip->dev);
 	}
 }
 
+static int tpm_inf_pnp_suspend(struct pnp_dev *dev, pm_message_t pm_state)
+{
+	struct tpm_chip *chip = pnp_get_drvdata(dev);
+	int rc;
+	if (chip) {
+		u8 savestate[] = {
+			0, 193,	/* TPM_TAG_RQU_COMMAND */
+			0, 0, 0, 10,	/* blob length (in bytes) */
+			0, 0, 0, 152	/* TPM_ORD_SaveState */
+		};
+		dev_info(&dev->dev, "saving TPM state\n");
+		rc = tpm_inf_send(chip, savestate, sizeof(savestate));
+		if (rc < 0) {
+			dev_err(&dev->dev, "error while saving TPM state\n");
+			return rc;
+		}
+	}
+	return 0;
+}
+
+static int tpm_inf_pnp_resume(struct pnp_dev *dev)
+{
+	/* Re-configure TPM after suspending */
+	tpm_config_out(ENABLE_REGISTER_PAIR, TPM_INF_ADDR);
+	tpm_config_out(IOLIMH, TPM_INF_ADDR);
+	tpm_config_out((tpm_dev.data_regs >> 8) & 0xff, TPM_INF_DATA);
+	tpm_config_out(IOLIML, TPM_INF_ADDR);
+	tpm_config_out((tpm_dev.data_regs & 0xff), TPM_INF_DATA);
+	/* activate register */
+	tpm_config_out(TPM_DAR, TPM_INF_ADDR);
+	tpm_config_out(0x01, TPM_INF_DATA);
+	tpm_config_out(DISABLE_REGISTER_PAIR, TPM_INF_ADDR);
+	/* disable RESET, LP and IRQC */
+	tpm_data_out(RESET_LP_IRQC_DISABLE, CMD);
+	return tpm_pm_resume(&dev->dev);
+}
+
 static struct pnp_driver tpm_inf_pnp_driver = {
 	.name = "tpm_inf_pnp",
-	.driver = {
-		.owner = THIS_MODULE,
-		.suspend = tpm_pm_suspend,
-		.resume = tpm_pm_resume,
-	},
-	.id_table = tpm_pnp_tbl,
+	.id_table = tpm_inf_pnp_tbl,
 	.probe = tpm_inf_pnp_probe,
-	.remove = __devexit_p(tpm_inf_pnp_remove),
+	.suspend = tpm_inf_pnp_suspend,
+	.resume = tpm_inf_pnp_resume,
+	.remove = __devexit_p(tpm_inf_pnp_remove)
 };
 
 static int __init init_inf(void)
@@ -638,5 +673,5 @@
 
 MODULE_AUTHOR("Marcel Selhorst <m.selhorst@sirrix.com>");
 MODULE_DESCRIPTION("Driver for Infineon TPM SLD 9630 TT 1.1 / SLB 9635 TT 1.2");
-MODULE_VERSION("1.9");
+MODULE_VERSION("1.9.2");
 MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/drivers/char/tty_io.c iDroid-Project-kernel_common-9e90fd2/drivers/char/tty_io.c
--- linux-2.6.32-orig/drivers/char/tty_io.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/char/tty_io.c	2010-11-18 21:05:30.000000000 +0600
@@ -1930,8 +1930,10 @@
 			pid = task_pid(current);
 			type = PIDTYPE_PID;
 		}
+		get_pid(pid);
 		spin_unlock_irqrestore(&tty->ctrl_lock, flags);
 		retval = __f_setown(filp, pid, type, 0);
+		put_pid(pid);
 		if (retval)
 			goto out;
 	} else {
diff -Nur linux-2.6.32-orig/drivers/connector/connector.c iDroid-Project-kernel_common-9e90fd2/drivers/connector/connector.c
--- linux-2.6.32-orig/drivers/connector/connector.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/connector/connector.c	2010-11-18 21:05:30.000000000 +0600
@@ -36,17 +36,6 @@
 MODULE_AUTHOR("Evgeniy Polyakov <zbr@ioremap.net>");
 MODULE_DESCRIPTION("Generic userspace <-> kernelspace connector.");
 
-static u32 cn_idx = CN_IDX_CONNECTOR;
-static u32 cn_val = CN_VAL_CONNECTOR;
-
-module_param(cn_idx, uint, 0);
-module_param(cn_val, uint, 0);
-MODULE_PARM_DESC(cn_idx, "Connector's main device idx.");
-MODULE_PARM_DESC(cn_val, "Connector's main device val.");
-
-static DEFINE_MUTEX(notify_lock);
-static LIST_HEAD(notify_list);
-
 static struct cn_dev cdev;
 
 static int cn_already_initialized;
@@ -210,54 +199,6 @@
 }
 
 /*
- * Notification routing.
- *
- * Gets id and checks if there are notification request for it's idx
- * and val.  If there are such requests notify the listeners with the
- * given notify event.
- *
- */
-static void cn_notify(struct cb_id *id, u32 notify_event)
-{
-	struct cn_ctl_entry *ent;
-
-	mutex_lock(&notify_lock);
-	list_for_each_entry(ent, &notify_list, notify_entry) {
-		int i;
-		struct cn_notify_req *req;
-		struct cn_ctl_msg *ctl = ent->msg;
-		int idx_found, val_found;
-
-		idx_found = val_found = 0;
-
-		req = (struct cn_notify_req *)ctl->data;
-		for (i = 0; i < ctl->idx_notify_num; ++i, ++req) {
-			if (id->idx >= req->first &&
-					id->idx < req->first + req->range) {
-				idx_found = 1;
-				break;
-			}
-		}
-
-		for (i = 0; i < ctl->val_notify_num; ++i, ++req) {
-			if (id->val >= req->first &&
-					id->val < req->first + req->range) {
-				val_found = 1;
-				break;
-			}
-		}
-
-		if (idx_found && val_found) {
-			struct cn_msg m = { .ack = notify_event, };
-
-			memcpy(&m.id, id, sizeof(m.id));
-			cn_netlink_send(&m, ctl->group, GFP_KERNEL);
-		}
-	}
-	mutex_unlock(&notify_lock);
-}
-
-/*
  * Callback add routing - adds callback with given ID and name.
  * If there is registered callback with the same ID it will not be added.
  *
@@ -276,8 +217,6 @@
 	if (err)
 		return err;
 
-	cn_notify(id, 0);
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(cn_add_callback);
@@ -295,111 +234,9 @@
 	struct cn_dev *dev = &cdev;
 
 	cn_queue_del_callback(dev->cbdev, id);
-	cn_notify(id, 1);
 }
 EXPORT_SYMBOL_GPL(cn_del_callback);
 
-/*
- * Checks two connector's control messages to be the same.
- * Returns 1 if they are the same or if the first one is corrupted.
- */
-static int cn_ctl_msg_equals(struct cn_ctl_msg *m1, struct cn_ctl_msg *m2)
-{
-	int i;
-	struct cn_notify_req *req1, *req2;
-
-	if (m1->idx_notify_num != m2->idx_notify_num)
-		return 0;
-
-	if (m1->val_notify_num != m2->val_notify_num)
-		return 0;
-
-	if (m1->len != m2->len)
-		return 0;
-
-	if ((m1->idx_notify_num + m1->val_notify_num) * sizeof(*req1) !=
-	    m1->len)
-		return 1;
-
-	req1 = (struct cn_notify_req *)m1->data;
-	req2 = (struct cn_notify_req *)m2->data;
-
-	for (i = 0; i < m1->idx_notify_num; ++i) {
-		if (req1->first != req2->first || req1->range != req2->range)
-			return 0;
-		req1++;
-		req2++;
-	}
-
-	for (i = 0; i < m1->val_notify_num; ++i) {
-		if (req1->first != req2->first || req1->range != req2->range)
-			return 0;
-		req1++;
-		req2++;
-	}
-
-	return 1;
-}
-
-/*
- * Main connector device's callback.
- *
- * Used for notification of a request's processing.
- */
-static void cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)
-{
-	struct cn_ctl_msg *ctl;
-	struct cn_ctl_entry *ent;
-	u32 size;
-
-	if (msg->len < sizeof(*ctl))
-		return;
-
-	ctl = (struct cn_ctl_msg *)msg->data;
-
-	size = (sizeof(*ctl) + ((ctl->idx_notify_num +
-				 ctl->val_notify_num) *
-				sizeof(struct cn_notify_req)));
-
-	if (msg->len != size)
-		return;
-
-	if (ctl->len + sizeof(*ctl) != msg->len)
-		return;
-
-	/*
-	 * Remove notification.
-	 */
-	if (ctl->group == 0) {
-		struct cn_ctl_entry *n;
-
-		mutex_lock(&notify_lock);
-		list_for_each_entry_safe(ent, n, &notify_list, notify_entry) {
-			if (cn_ctl_msg_equals(ent->msg, ctl)) {
-				list_del(&ent->notify_entry);
-				kfree(ent);
-			}
-		}
-		mutex_unlock(&notify_lock);
-
-		return;
-	}
-
-	size += sizeof(*ent);
-
-	ent = kzalloc(size, GFP_KERNEL);
-	if (!ent)
-		return;
-
-	ent->msg = (struct cn_ctl_msg *)(ent + 1);
-
-	memcpy(ent->msg, ctl, size - sizeof(*ent));
-
-	mutex_lock(&notify_lock);
-	list_add(&ent->notify_entry, &notify_list);
-	mutex_unlock(&notify_lock);
-}
-
 static int cn_proc_show(struct seq_file *m, void *v)
 {
 	struct cn_queue_dev *dev = cdev.cbdev;
@@ -437,11 +274,8 @@
 static int __devinit cn_init(void)
 {
 	struct cn_dev *dev = &cdev;
-	int err;
 
 	dev->input = cn_rx_skb;
-	dev->id.idx = cn_idx;
-	dev->id.val = cn_val;
 
 	dev->nls = netlink_kernel_create(&init_net, NETLINK_CONNECTOR,
 					 CN_NETLINK_USERS + 0xf,
@@ -457,14 +291,6 @@
 
 	cn_already_initialized = 1;
 
-	err = cn_add_callback(&dev->id, "connector", &cn_callback);
-	if (err) {
-		cn_already_initialized = 0;
-		cn_queue_free_dev(dev->cbdev);
-		netlink_kernel_release(dev->nls);
-		return -EINVAL;
-	}
-
 	proc_net_fops_create(&init_net, "connector", S_IRUGO, &cn_file_ops);
 
 	return 0;
@@ -478,7 +304,6 @@
 
 	proc_net_remove(&init_net, "connector");
 
-	cn_del_callback(&dev->id);
 	cn_queue_free_dev(dev->cbdev);
 	netlink_kernel_release(dev->nls);
 }
diff -Nur linux-2.6.32-orig/drivers/cpufreq/cpufreq_ondemand.c iDroid-Project-kernel_common-9e90fd2/drivers/cpufreq/cpufreq_ondemand.c
--- linux-2.6.32-orig/drivers/cpufreq/cpufreq_ondemand.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/cpufreq/cpufreq_ondemand.c	2010-11-18 21:05:30.000000000 +0600
@@ -576,7 +576,9 @@
 	/* We want all CPUs to do sampling nearly on same jiffy */
 	int delay = usecs_to_jiffies(dbs_tuners_ins.sampling_rate);
 
-	delay -= jiffies % delay;
+	if (num_online_cpus() > 1)
+		delay -= jiffies % delay;
+
 	mutex_lock(&dbs_info->timer_mutex);
 
 	/* Common NORMAL_SAMPLE setup */
diff -Nur linux-2.6.32-orig/drivers/cpuidle/governors/menu.c iDroid-Project-kernel_common-9e90fd2/drivers/cpuidle/governors/menu.c
--- linux-2.6.32-orig/drivers/cpuidle/governors/menu.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/cpuidle/governors/menu.c	2010-11-18 21:05:30.000000000 +0600
@@ -18,6 +18,7 @@
 #include <linux/hrtimer.h>
 #include <linux/tick.h>
 #include <linux/sched.h>
+#include <linux/math64.h>
 
 #define BUCKETS 12
 #define RESOLUTION 1024
@@ -169,6 +170,12 @@
 
 static void menu_update(struct cpuidle_device *dev);
 
+/* This implements DIV_ROUND_CLOSEST but avoids 64 bit division */
+static u64 div_round64(u64 dividend, u32 divisor)
+{
+	return div_u64(dividend + (divisor / 2), divisor);
+}
+
 /**
  * menu_select - selects the next idle state to enter
  * @dev: the CPU
@@ -209,9 +216,8 @@
 		data->correction_factor[data->bucket] = RESOLUTION * DECAY;
 
 	/* Make sure to round up for half microseconds */
-	data->predicted_us = DIV_ROUND_CLOSEST(
-		data->expected_us * data->correction_factor[data->bucket],
-		RESOLUTION * DECAY);
+	data->predicted_us = div_round64(data->expected_us * data->correction_factor[data->bucket],
+					 RESOLUTION * DECAY);
 
 	/*
 	 * We want to default to C1 (hlt), not to busy polling
diff -Nur linux-2.6.32-orig/drivers/crypto/padlock-sha.c iDroid-Project-kernel_common-9e90fd2/drivers/crypto/padlock-sha.c
--- linux-2.6.32-orig/drivers/crypto/padlock-sha.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/crypto/padlock-sha.c	2010-11-18 21:05:30.000000000 +0600
@@ -57,6 +57,23 @@
 	return crypto_shash_update(&dctx->fallback, data, length);
 }
 
+static int padlock_sha_export(struct shash_desc *desc, void *out)
+{
+	struct padlock_sha_desc *dctx = shash_desc_ctx(desc);
+
+	return crypto_shash_export(&dctx->fallback, out);
+}
+
+static int padlock_sha_import(struct shash_desc *desc, const void *in)
+{
+	struct padlock_sha_desc *dctx = shash_desc_ctx(desc);
+	struct padlock_sha_ctx *ctx = crypto_shash_ctx(desc->tfm);
+
+	dctx->fallback.tfm = ctx->fallback;
+	dctx->fallback.flags = desc->flags & CRYPTO_TFM_REQ_MAY_SLEEP;
+	return crypto_shash_import(&dctx->fallback, in);
+}
+
 static inline void padlock_output_block(uint32_t *src,
 		 	uint32_t *dst, size_t count)
 {
@@ -235,7 +252,10 @@
 	.update 	=	padlock_sha_update,
 	.finup  	=	padlock_sha1_finup,
 	.final  	=	padlock_sha1_final,
+	.export		=	padlock_sha_export,
+	.import		=	padlock_sha_import,
 	.descsize	=	sizeof(struct padlock_sha_desc),
+	.statesize	=	sizeof(struct sha1_state),
 	.base		=	{
 		.cra_name		=	"sha1",
 		.cra_driver_name	=	"sha1-padlock",
@@ -256,7 +276,10 @@
 	.update 	=	padlock_sha_update,
 	.finup  	=	padlock_sha256_finup,
 	.final  	=	padlock_sha256_final,
+	.export		=	padlock_sha_export,
+	.import		=	padlock_sha_import,
 	.descsize	=	sizeof(struct padlock_sha_desc),
+	.statesize	=	sizeof(struct sha256_state),
 	.base		=	{
 		.cra_name		=	"sha256",
 		.cra_driver_name	=	"sha256-padlock",
diff -Nur linux-2.6.32-orig/drivers/dma/at_hdmac.c iDroid-Project-kernel_common-9e90fd2/drivers/dma/at_hdmac.c
--- linux-2.6.32-orig/drivers/dma/at_hdmac.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/dma/at_hdmac.c	2010-11-18 21:05:30.000000000 +0600
@@ -815,7 +815,7 @@
 	dev_vdbg(chan2dev(chan), "is_tx_complete: %d (d%d, u%d)\n",
 			cookie, done ? *done : 0, used ? *used : 0);
 
-	spin_lock_bh(atchan->lock);
+	spin_lock_bh(&atchan->lock);
 
 	last_complete = atchan->completed_cookie;
 	last_used = chan->cookie;
@@ -830,7 +830,7 @@
 		ret = dma_async_is_complete(cookie, last_complete, last_used);
 	}
 
-	spin_unlock_bh(atchan->lock);
+	spin_unlock_bh(&atchan->lock);
 
 	if (done)
 		*done = last_complete;
diff -Nur linux-2.6.32-orig/drivers/dma/ioat/dma.c iDroid-Project-kernel_common-9e90fd2/drivers/dma/ioat/dma.c
--- linux-2.6.32-orig/drivers/dma/ioat/dma.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/dma/ioat/dma.c	2010-11-18 21:05:30.000000000 +0600
@@ -1032,7 +1032,7 @@
 	dma->dev = &pdev->dev;
 
 	if (!dma->chancnt) {
-		dev_err(dev, "zero channels detected\n");
+		dev_err(dev, "channel enumeration error\n");
 		goto err_setup_interrupts;
 	}
 
diff -Nur linux-2.6.32-orig/drivers/dma/ioat/dma.h iDroid-Project-kernel_common-9e90fd2/drivers/dma/ioat/dma.h
--- linux-2.6.32-orig/drivers/dma/ioat/dma.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/dma/ioat/dma.h	2010-11-18 21:05:30.000000000 +0600
@@ -60,6 +60,7 @@
  * @dca: direct cache access context
  * @intr_quirk: interrupt setup quirk (for ioat_v1 devices)
  * @enumerate_channels: hw version specific channel enumeration
+ * @reset_hw: hw version specific channel (re)initialization
  * @cleanup_tasklet: select between the v2 and v3 cleanup routines
  * @timer_fn: select between the v2 and v3 timer watchdog routines
  * @self_test: hardware version specific self test for each supported op type
@@ -78,6 +79,7 @@
 	struct dca_provider *dca;
 	void (*intr_quirk)(struct ioatdma_device *device);
 	int (*enumerate_channels)(struct ioatdma_device *device);
+	int (*reset_hw)(struct ioat_chan_common *chan);
 	void (*cleanup_tasklet)(unsigned long data);
 	void (*timer_fn)(unsigned long data);
 	int (*self_test)(struct ioatdma_device *device);
@@ -264,6 +266,22 @@
 	writeb(IOAT_CHANCMD_SUSPEND, chan->reg_base + IOAT_CHANCMD_OFFSET(ver));
 }
 
+static inline void ioat_reset(struct ioat_chan_common *chan)
+{
+	u8 ver = chan->device->version;
+
+	writeb(IOAT_CHANCMD_RESET, chan->reg_base + IOAT_CHANCMD_OFFSET(ver));
+}
+
+static inline bool ioat_reset_pending(struct ioat_chan_common *chan)
+{
+	u8 ver = chan->device->version;
+	u8 cmd;
+
+	cmd = readb(chan->reg_base + IOAT_CHANCMD_OFFSET(ver));
+	return (cmd & IOAT_CHANCMD_RESET) == IOAT_CHANCMD_RESET;
+}
+
 static inline void ioat_set_chainaddr(struct ioat_dma_chan *ioat, u64 addr)
 {
 	struct ioat_chan_common *chan = &ioat->base;
diff -Nur linux-2.6.32-orig/drivers/dma/ioat/dma_v2.c iDroid-Project-kernel_common-9e90fd2/drivers/dma/ioat/dma_v2.c
--- linux-2.6.32-orig/drivers/dma/ioat/dma_v2.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/dma/ioat/dma_v2.c	2010-11-18 21:05:30.000000000 +0600
@@ -239,20 +239,50 @@
 		__ioat2_start_null_desc(ioat);
 }
 
-static void ioat2_restart_channel(struct ioat2_dma_chan *ioat)
+int ioat2_quiesce(struct ioat_chan_common *chan, unsigned long tmo)
 {
-	struct ioat_chan_common *chan = &ioat->base;
-	unsigned long phys_complete;
+	unsigned long end = jiffies + tmo;
+	int err = 0;
 	u32 status;
 
 	status = ioat_chansts(chan);
 	if (is_ioat_active(status) || is_ioat_idle(status))
 		ioat_suspend(chan);
 	while (is_ioat_active(status) || is_ioat_idle(status)) {
+		if (tmo && time_after(jiffies, end)) {
+			err = -ETIMEDOUT;
+			break;
+		}
 		status = ioat_chansts(chan);
 		cpu_relax();
 	}
 
+	return err;
+}
+
+int ioat2_reset_sync(struct ioat_chan_common *chan, unsigned long tmo)
+{
+	unsigned long end = jiffies + tmo;
+	int err = 0;
+
+	ioat_reset(chan);
+	while (ioat_reset_pending(chan)) {
+		if (end && time_after(jiffies, end)) {
+			err = -ETIMEDOUT;
+			break;
+		}
+		cpu_relax();
+	}
+
+	return err;
+}
+
+static void ioat2_restart_channel(struct ioat2_dma_chan *ioat)
+{
+	struct ioat_chan_common *chan = &ioat->base;
+	unsigned long phys_complete;
+
+	ioat2_quiesce(chan, 0);
 	if (ioat_cleanup_preamble(chan, &phys_complete))
 		__cleanup(ioat, phys_complete);
 
@@ -318,6 +348,19 @@
 	spin_unlock_bh(&chan->cleanup_lock);
 }
 
+static int ioat2_reset_hw(struct ioat_chan_common *chan)
+{
+	/* throw away whatever the channel was doing and get it initialized */
+	u32 chanerr;
+
+	ioat2_quiesce(chan, msecs_to_jiffies(100));
+
+	chanerr = readl(chan->reg_base + IOAT_CHANERR_OFFSET);
+	writel(chanerr, chan->reg_base + IOAT_CHANERR_OFFSET);
+
+	return ioat2_reset_sync(chan, msecs_to_jiffies(200));
+}
+
 /**
  * ioat2_enumerate_channels - find and initialize the device's channels
  * @device: the device to be enumerated
@@ -360,6 +403,10 @@
 				  (unsigned long) ioat);
 		ioat->xfercap_log = xfercap_log;
 		spin_lock_init(&ioat->ring_lock);
+		if (device->reset_hw(&ioat->base)) {
+			i = 0;
+			break;
+		}
 	}
 	dma->chancnt = i;
 	return i;
@@ -467,7 +514,6 @@
 	struct ioat2_dma_chan *ioat = to_ioat2_chan(c);
 	struct ioat_chan_common *chan = &ioat->base;
 	struct ioat_ring_ent **ring;
-	u32 chanerr;
 	int order;
 
 	/* have we already been set up? */
@@ -477,12 +523,6 @@
 	/* Setup register to interrupt and write completion status on error */
 	writew(IOAT_CHANCTRL_RUN, chan->reg_base + IOAT_CHANCTRL_OFFSET);
 
-	chanerr = readl(chan->reg_base + IOAT_CHANERR_OFFSET);
-	if (chanerr) {
-		dev_err(to_dev(chan), "CHANERR = %x, clearing\n", chanerr);
-		writel(chanerr, chan->reg_base + IOAT_CHANERR_OFFSET);
-	}
-
 	/* allocate a completion writeback area */
 	/* doing 2 32bit writes to mmio since 1 64b write doesn't work */
 	chan->completion = pci_pool_alloc(chan->device->completion_pool,
@@ -746,13 +786,7 @@
 	tasklet_disable(&chan->cleanup_task);
 	del_timer_sync(&chan->timer);
 	device->cleanup_tasklet((unsigned long) ioat);
-
-	/* Delay 100ms after reset to allow internal DMA logic to quiesce
-	 * before removing DMA descriptor resources.
-	 */
-	writeb(IOAT_CHANCMD_RESET,
-	       chan->reg_base + IOAT_CHANCMD_OFFSET(chan->device->version));
-	mdelay(100);
+	device->reset_hw(chan);
 
 	spin_lock_bh(&ioat->ring_lock);
 	descs = ioat2_ring_space(ioat);
@@ -839,6 +873,7 @@
 	int err;
 
 	device->enumerate_channels = ioat2_enumerate_channels;
+	device->reset_hw = ioat2_reset_hw;
 	device->cleanup_tasklet = ioat2_cleanup_tasklet;
 	device->timer_fn = ioat2_timer_event;
 	device->self_test = ioat_dma_self_test;
diff -Nur linux-2.6.32-orig/drivers/dma/ioat/dma_v2.h iDroid-Project-kernel_common-9e90fd2/drivers/dma/ioat/dma_v2.h
--- linux-2.6.32-orig/drivers/dma/ioat/dma_v2.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/dma/ioat/dma_v2.h	2010-11-18 21:05:30.000000000 +0600
@@ -185,6 +185,8 @@
 void __ioat2_issue_pending(struct ioat2_dma_chan *ioat);
 void ioat2_cleanup_tasklet(unsigned long data);
 void ioat2_timer_event(unsigned long data);
+int ioat2_quiesce(struct ioat_chan_common *chan, unsigned long tmo);
+int ioat2_reset_sync(struct ioat_chan_common *chan, unsigned long tmo);
 extern struct kobj_type ioat2_ktype;
 extern struct kmem_cache *ioat2_cache;
 #endif /* IOATDMA_V2_H */
diff -Nur linux-2.6.32-orig/drivers/dma/ioat/dma_v3.c iDroid-Project-kernel_common-9e90fd2/drivers/dma/ioat/dma_v3.c
--- linux-2.6.32-orig/drivers/dma/ioat/dma_v3.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/dma/ioat/dma_v3.c	2010-11-18 21:05:30.000000000 +0600
@@ -650,9 +650,11 @@
 
 	num_descs = ioat2_xferlen_to_descs(ioat, len);
 	/* we need 2x the number of descriptors to cover greater than 3
-	 * sources
+	 * sources (we need 1 extra source in the q-only continuation
+	 * case and 3 extra sources in the p+q continuation case.
 	 */
-	if (src_cnt > 3 || flags & DMA_PREP_CONTINUE) {
+	if (src_cnt + dmaf_p_disabled_continue(flags) > 3 ||
+	    (dmaf_continue(flags) && !dmaf_p_disabled_continue(flags))) {
 		with_ext = 1;
 		num_descs *= 2;
 	} else
@@ -1128,6 +1130,45 @@
 	return 0;
 }
 
+static int ioat3_reset_hw(struct ioat_chan_common *chan)
+{
+	/* throw away whatever the channel was doing and get it
+	 * initialized, with ioat3 specific workarounds
+	 */
+	struct ioatdma_device *device = chan->device;
+	struct pci_dev *pdev = device->pdev;
+	u32 chanerr;
+	u16 dev_id;
+	int err;
+
+	ioat2_quiesce(chan, msecs_to_jiffies(100));
+
+	chanerr = readl(chan->reg_base + IOAT_CHANERR_OFFSET);
+	writel(chanerr, chan->reg_base + IOAT_CHANERR_OFFSET);
+
+	/* -= IOAT ver.3 workarounds =- */
+	/* Write CHANERRMSK_INT with 3E07h to mask out the errors
+	 * that can cause stability issues for IOAT ver.3, and clear any
+	 * pending errors
+	 */
+	pci_write_config_dword(pdev, IOAT_PCI_CHANERRMASK_INT_OFFSET, 0x3e07);
+	err = pci_read_config_dword(pdev, IOAT_PCI_CHANERR_INT_OFFSET, &chanerr);
+	if (err) {
+		dev_err(&pdev->dev, "channel error register unreachable\n");
+		return err;
+	}
+	pci_write_config_dword(pdev, IOAT_PCI_CHANERR_INT_OFFSET, chanerr);
+
+	/* Clear DMAUNCERRSTS Cfg-Reg Parity Error status bit
+	 * (workaround for spurious config parity error after restart)
+	 */
+	pci_read_config_word(pdev, IOAT_PCI_DEVICE_ID_OFFSET, &dev_id);
+	if (dev_id == PCI_DEVICE_ID_INTEL_IOAT_TBG0)
+		pci_write_config_dword(pdev, IOAT_PCI_DMAUNCERRSTS_OFFSET, 0x10);
+
+	return ioat2_reset_sync(chan, msecs_to_jiffies(200));
+}
+
 int __devinit ioat3_dma_probe(struct ioatdma_device *device, int dca)
 {
 	struct pci_dev *pdev = device->pdev;
@@ -1137,10 +1178,10 @@
 	struct ioat_chan_common *chan;
 	bool is_raid_device = false;
 	int err;
-	u16 dev_id;
 	u32 cap;
 
 	device->enumerate_channels = ioat2_enumerate_channels;
+	device->reset_hw = ioat3_reset_hw;
 	device->self_test = ioat3_dma_self_test;
 	dma = &device->common;
 	dma->device_prep_dma_memcpy = ioat2_dma_prep_memcpy_lock;
@@ -1216,19 +1257,6 @@
 	dma->device_prep_dma_xor_val = NULL;
 	#endif
 
-	/* -= IOAT ver.3 workarounds =- */
-	/* Write CHANERRMSK_INT with 3E07h to mask out the errors
-	 * that can cause stability issues for IOAT ver.3
-	 */
-	pci_write_config_dword(pdev, IOAT_PCI_CHANERRMASK_INT_OFFSET, 0x3e07);
-
-	/* Clear DMAUNCERRSTS Cfg-Reg Parity Error status bit
-	 * (workaround for spurious config parity error after restart)
-	 */
-	pci_read_config_word(pdev, IOAT_PCI_DEVICE_ID_OFFSET, &dev_id);
-	if (dev_id == PCI_DEVICE_ID_INTEL_IOAT_TBG0)
-		pci_write_config_dword(pdev, IOAT_PCI_DMAUNCERRSTS_OFFSET, 0x10);
-
 	err = ioat_probe(device);
 	if (err)
 		return err;
diff -Nur linux-2.6.32-orig/drivers/dma/ioat/registers.h iDroid-Project-kernel_common-9e90fd2/drivers/dma/ioat/registers.h
--- linux-2.6.32-orig/drivers/dma/ioat/registers.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/dma/ioat/registers.h	2010-11-18 21:05:30.000000000 +0600
@@ -27,6 +27,7 @@
 
 #define IOAT_PCI_DEVICE_ID_OFFSET		0x02
 #define IOAT_PCI_DMAUNCERRSTS_OFFSET		0x148
+#define IOAT_PCI_CHANERR_INT_OFFSET		0x180
 #define IOAT_PCI_CHANERRMASK_INT_OFFSET		0x184
 
 /* MMIO Device Registers */
diff -Nur linux-2.6.32-orig/drivers/edac/amd64_edac.c iDroid-Project-kernel_common-9e90fd2/drivers/edac/amd64_edac.c
--- linux-2.6.32-orig/drivers/edac/amd64_edac.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/edac/amd64_edac.c	2010-11-18 21:05:30.000000000 +0600
@@ -13,6 +13,8 @@
 static int ecc_enable_override;
 module_param(ecc_enable_override, int, 0644);
 
+static struct msr *msrs;
+
 /* Lookup table for all possible MC control instances */
 struct amd64_pvt;
 static struct mem_ctl_info *mci_lookup[EDAC_MAX_NUMNODES];
@@ -2618,6 +2620,90 @@
 	return empty;
 }
 
+/* get all cores on this DCT */
+static void get_cpus_on_this_dct_cpumask(struct cpumask *mask, int nid)
+{
+	int cpu;
+
+	for_each_online_cpu(cpu)
+		if (amd_get_nb_id(cpu) == nid)
+			cpumask_set_cpu(cpu, mask);
+}
+
+/* check MCG_CTL on all the cpus on this node */
+static bool amd64_nb_mce_bank_enabled_on_node(int nid)
+{
+	cpumask_var_t mask;
+	int cpu, nbe;
+	bool ret = false;
+
+	if (!zalloc_cpumask_var(&mask, GFP_KERNEL)) {
+		amd64_printk(KERN_WARNING, "%s: error allocating mask\n",
+			     __func__);
+		return false;
+	}
+
+	get_cpus_on_this_dct_cpumask(mask, nid);
+
+	rdmsr_on_cpus(mask, MSR_IA32_MCG_CTL, msrs);
+
+	for_each_cpu(cpu, mask) {
+		struct msr *reg = per_cpu_ptr(msrs, cpu);
+		nbe = reg->l & K8_MSR_MCGCTL_NBE;
+
+		debugf0("core: %u, MCG_CTL: 0x%llx, NB MSR is %s\n",
+			cpu, reg->q,
+			(nbe ? "enabled" : "disabled"));
+
+		if (!nbe)
+			goto out;
+	}
+	ret = true;
+
+out:
+	free_cpumask_var(mask);
+	return ret;
+}
+
+static int amd64_toggle_ecc_err_reporting(struct amd64_pvt *pvt, bool on)
+{
+	cpumask_var_t cmask;
+	int cpu;
+
+	if (!zalloc_cpumask_var(&cmask, GFP_KERNEL)) {
+		amd64_printk(KERN_WARNING, "%s: error allocating mask\n",
+			     __func__);
+		return false;
+	}
+
+	get_cpus_on_this_dct_cpumask(cmask, pvt->mc_node_id);
+
+	rdmsr_on_cpus(cmask, MSR_IA32_MCG_CTL, msrs);
+
+	for_each_cpu(cpu, cmask) {
+
+		struct msr *reg = per_cpu_ptr(msrs, cpu);
+
+		if (on) {
+			if (reg->l & K8_MSR_MCGCTL_NBE)
+				pvt->flags.ecc_report = 1;
+
+			reg->l |= K8_MSR_MCGCTL_NBE;
+		} else {
+			/*
+			 * Turn off ECC reporting only when it was off before
+			 */
+			if (!pvt->flags.ecc_report)
+				reg->l &= ~K8_MSR_MCGCTL_NBE;
+		}
+	}
+	wrmsr_on_cpus(cmask, MSR_IA32_MCG_CTL, msrs);
+
+	free_cpumask_var(cmask);
+
+	return 0;
+}
+
 /*
  * Only if 'ecc_enable_override' is set AND BIOS had ECC disabled, do "we"
  * enable it.
@@ -2625,17 +2711,12 @@
 static void amd64_enable_ecc_error_reporting(struct mem_ctl_info *mci)
 {
 	struct amd64_pvt *pvt = mci->pvt_info;
-	const cpumask_t *cpumask = cpumask_of_node(pvt->mc_node_id);
-	int cpu, idx = 0, err = 0;
-	struct msr msrs[cpumask_weight(cpumask)];
-	u32 value;
-	u32 mask = K8_NBCTL_CECCEn | K8_NBCTL_UECCEn;
+	int err = 0;
+	u32 value, mask = K8_NBCTL_CECCEn | K8_NBCTL_UECCEn;
 
 	if (!ecc_enable_override)
 		return;
 
-	memset(msrs, 0, sizeof(msrs));
-
 	amd64_printk(KERN_WARNING,
 		"'ecc_enable_override' parameter is active, "
 		"Enabling AMD ECC hardware now: CAUTION\n");
@@ -2651,16 +2732,9 @@
 	value |= mask;
 	pci_write_config_dword(pvt->misc_f3_ctl, K8_NBCTL, value);
 
-	rdmsr_on_cpus(cpumask, K8_MSR_MCGCTL, msrs);
-
-	for_each_cpu(cpu, cpumask) {
-		if (msrs[idx].l & K8_MSR_MCGCTL_NBE)
-			set_bit(idx, &pvt->old_mcgctl);
-
-		msrs[idx].l |= K8_MSR_MCGCTL_NBE;
-		idx++;
-	}
-	wrmsr_on_cpus(cpumask, K8_MSR_MCGCTL, msrs);
+	if (amd64_toggle_ecc_err_reporting(pvt, ON))
+		amd64_printk(KERN_WARNING, "Error enabling ECC reporting over "
+					   "MCGCTL!\n");
 
 	err = pci_read_config_dword(pvt->misc_f3_ctl, K8_NBCFG, &value);
 	if (err)
@@ -2701,17 +2775,12 @@
 
 static void amd64_restore_ecc_error_reporting(struct amd64_pvt *pvt)
 {
-	const cpumask_t *cpumask = cpumask_of_node(pvt->mc_node_id);
-	int cpu, idx = 0, err = 0;
-	struct msr msrs[cpumask_weight(cpumask)];
-	u32 value;
-	u32 mask = K8_NBCTL_CECCEn | K8_NBCTL_UECCEn;
+	int err = 0;
+	u32 value, mask = K8_NBCTL_CECCEn | K8_NBCTL_UECCEn;
 
 	if (!pvt->nbctl_mcgctl_saved)
 		return;
 
-	memset(msrs, 0, sizeof(msrs));
-
 	err = pci_read_config_dword(pvt->misc_f3_ctl, K8_NBCTL, &value);
 	if (err)
 		debugf0("Reading K8_NBCTL failed\n");
@@ -2721,66 +2790,9 @@
 	/* restore the NB Enable MCGCTL bit */
 	pci_write_config_dword(pvt->misc_f3_ctl, K8_NBCTL, value);
 
-	rdmsr_on_cpus(cpumask, K8_MSR_MCGCTL, msrs);
-
-	for_each_cpu(cpu, cpumask) {
-		msrs[idx].l &= ~K8_MSR_MCGCTL_NBE;
-		msrs[idx].l |=
-			test_bit(idx, &pvt->old_mcgctl) << K8_MSR_MCGCTL_NBE;
-		idx++;
-	}
-
-	wrmsr_on_cpus(cpumask, K8_MSR_MCGCTL, msrs);
-}
-
-/* get all cores on this DCT */
-static void get_cpus_on_this_dct_cpumask(cpumask_t *mask, int nid)
-{
-	int cpu;
-
-	for_each_online_cpu(cpu)
-		if (amd_get_nb_id(cpu) == nid)
-			cpumask_set_cpu(cpu, mask);
-}
-
-/* check MCG_CTL on all the cpus on this node */
-static bool amd64_nb_mce_bank_enabled_on_node(int nid)
-{
-	cpumask_t mask;
-	struct msr *msrs;
-	int cpu, nbe, idx = 0;
-	bool ret = false;
-
-	cpumask_clear(&mask);
-
-	get_cpus_on_this_dct_cpumask(&mask, nid);
-
-	msrs = kzalloc(sizeof(struct msr) * cpumask_weight(&mask), GFP_KERNEL);
-	if (!msrs) {
-		amd64_printk(KERN_WARNING, "%s: error allocating msrs\n",
-			      __func__);
-		 return false;
-	}
-
-	rdmsr_on_cpus(&mask, MSR_IA32_MCG_CTL, msrs);
-
-	for_each_cpu(cpu, &mask) {
-		nbe = msrs[idx].l & K8_MSR_MCGCTL_NBE;
-
-		debugf0("core: %u, MCG_CTL: 0x%llx, NB MSR is %s\n",
-			cpu, msrs[idx].q,
-			(nbe ? "enabled" : "disabled"));
-
-		if (!nbe)
-			goto out;
-
-		idx++;
-	}
-	ret = true;
-
-out:
-	kfree(msrs);
-	return ret;
+	if (amd64_toggle_ecc_err_reporting(pvt, OFF))
+		amd64_printk(KERN_WARNING, "Error restoring ECC reporting over "
+					   "MCGCTL!\n");
 }
 
 /*
@@ -2789,10 +2801,11 @@
  * the memory system completely. A command line option allows to force-enable
  * hardware ECC later in amd64_enable_ecc_error_reporting().
  */
-static const char *ecc_warning =
-	"WARNING: ECC is disabled by BIOS. Module will NOT be loaded.\n"
-	" Either Enable ECC in the BIOS, or set 'ecc_enable_override'.\n"
-	" Also, use of the override can cause unknown side effects.\n";
+static const char *ecc_msg =
+	"ECC disabled in the BIOS or no ECC capability, module will not load.\n"
+	" Either enable ECC checking or force module loading by setting "
+	"'ecc_enable_override'.\n"
+	" (Note that use of the override may cause unknown side effects.)\n";
 
 static int amd64_check_ecc_enabled(struct amd64_pvt *pvt)
 {
@@ -2807,7 +2820,7 @@
 
 	ecc_enabled = !!(value & K8_NBCFG_ECC_ENABLE);
 	if (!ecc_enabled)
-		amd64_printk(KERN_WARNING, "This node reports that Memory ECC "
+		amd64_printk(KERN_NOTICE, "This node reports that Memory ECC "
 			     "is currently disabled, set F3x%x[22] (%s).\n",
 			     K8_NBCFG, pci_name(pvt->misc_f3_ctl));
 	else
@@ -2815,18 +2828,17 @@
 
 	nb_mce_en = amd64_nb_mce_bank_enabled_on_node(pvt->mc_node_id);
 	if (!nb_mce_en)
-		amd64_printk(KERN_WARNING, "NB MCE bank disabled, set MSR "
+		amd64_printk(KERN_NOTICE, "NB MCE bank disabled, set MSR "
 			     "0x%08x[4] on node %d to enable.\n",
 			     MSR_IA32_MCG_CTL, pvt->mc_node_id);
 
 	if (!ecc_enabled || !nb_mce_en) {
 		if (!ecc_enable_override) {
-			amd64_printk(KERN_WARNING, "%s", ecc_warning);
+			amd64_printk(KERN_NOTICE, "%s", ecc_msg);
 			return -ENODEV;
 		}
-	} else
-		/* CLEAR the override, since BIOS controlled it */
 		ecc_enable_override = 0;
+	}
 
 	return 0;
 }
@@ -2909,7 +2921,6 @@
 	pvt->ext_model		= boot_cpu_data.x86_model >> 4;
 	pvt->mc_type_index	= mc_type_index;
 	pvt->ops		= family_ops(mc_type_index);
-	pvt->old_mcgctl		= 0;
 
 	/*
 	 * We have the dram_f2_ctl device as an argument, now go reserve its
@@ -3071,16 +3082,15 @@
 
 	amd64_free_mc_sibling_devices(pvt);
 
-	kfree(pvt);
-	mci->pvt_info = NULL;
-
-	mci_lookup[pvt->mc_node_id] = NULL;
-
 	/* unregister from EDAC MCE */
 	amd_report_gart_errors(false);
 	amd_unregister_ecc_decoder(amd64_decode_bus_error);
 
 	/* Free the EDAC CORE resources */
+	mci->pvt_info = NULL;
+	mci_lookup[pvt->mc_node_id] = NULL;
+
+	kfree(pvt);
 	edac_mc_free(mci);
 }
 
@@ -3157,23 +3167,29 @@
 static int __init amd64_edac_init(void)
 {
 	int nb, err = -ENODEV;
+	bool load_ok = false;
 
 	edac_printk(KERN_INFO, EDAC_MOD_STR, EDAC_AMD64_VERSION "\n");
 
 	opstate_init();
 
 	if (cache_k8_northbridges() < 0)
-		return err;
+		goto err_ret;
+
+	msrs = msrs_alloc();
+	if (!msrs)
+		goto err_ret;
 
 	err = pci_register_driver(&amd64_pci_driver);
 	if (err)
-		return err;
+		goto err_pci;
 
 	/*
 	 * At this point, the array 'pvt_lookup[]' contains pointers to alloc'd
 	 * amd64_pvt structs. These will be used in the 2nd stage init function
 	 * to finish initialization of the MC instances.
 	 */
+	err = -ENODEV;
 	for (nb = 0; nb < num_k8_northbridges; nb++) {
 		if (!pvt_lookup[nb])
 			continue;
@@ -3181,16 +3197,21 @@
 		err = amd64_init_2nd_stage(pvt_lookup[nb]);
 		if (err)
 			goto err_2nd_stage;
-	}
 
-	amd64_setup_pci_device();
+		load_ok = true;
+	}
 
-	return 0;
+	if (load_ok) {
+		amd64_setup_pci_device();
+		return 0;
+	}
 
 err_2nd_stage:
-	debugf0("2nd stage failed\n");
 	pci_unregister_driver(&amd64_pci_driver);
-
+err_pci:
+	msrs_free(msrs);
+	msrs = NULL;
+err_ret:
 	return err;
 }
 
@@ -3200,6 +3221,9 @@
 		edac_pci_release_generic_ctl(amd64_ctl_pci);
 
 	pci_unregister_driver(&amd64_pci_driver);
+
+	msrs_free(msrs);
+	msrs = NULL;
 }
 
 module_init(amd64_edac_init);
diff -Nur linux-2.6.32-orig/drivers/edac/amd64_edac.h iDroid-Project-kernel_common-9e90fd2/drivers/edac/amd64_edac.h
--- linux-2.6.32-orig/drivers/edac/amd64_edac.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/edac/amd64_edac.h	2010-11-18 21:05:30.000000000 +0600
@@ -147,6 +147,8 @@
 #define MAX_CS_COUNT			8
 #define DRAM_REG_COUNT			8
 
+#define ON true
+#define OFF false
 
 /*
  * PCI-defined configuration space registers
@@ -386,10 +388,7 @@
 #define K8_NBCAP_DUAL_NODE		BIT(1)
 #define K8_NBCAP_DCT_DUAL		BIT(0)
 
-/*
- * MSR Regs
- */
-#define K8_MSR_MCGCTL			0x017b
+/* MSRs */
 #define K8_MSR_MCGCTL_NBE		BIT(4)
 
 #define K8_MSR_MC4CTL			0x0410
@@ -487,7 +486,6 @@
 	/* Save old hw registers' values before we modified them */
 	u32 nbctl_mcgctl_saved;		/* When true, following 2 are valid */
 	u32 old_nbctl;
-	unsigned long old_mcgctl;	/* per core on this node */
 
 	/* MC Type Index value: socket F vs Family 10h */
 	u32 mc_type_index;
@@ -495,6 +493,7 @@
 	/* misc settings */
 	struct flags {
 		unsigned long cf8_extcfg:1;
+		unsigned long ecc_report:1;
 	} flags;
 };
 
diff -Nur linux-2.6.32-orig/drivers/edac/i5000_edac.c iDroid-Project-kernel_common-9e90fd2/drivers/edac/i5000_edac.c
--- linux-2.6.32-orig/drivers/edac/i5000_edac.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/edac/i5000_edac.c	2010-11-18 21:05:30.000000000 +0600
@@ -577,7 +577,13 @@
 		debugf0("\tUncorrected bits= 0x%x\n", ue_errors);
 
 		branch = EXTRACT_FBDCHAN_INDX(info->ferr_nf_fbd);
-		channel = branch;
+
+		/*
+		 * According with i5000 datasheet, bit 28 has no significance
+		 * for errors M4Err-M12Err and M17Err-M21Err, on FERR_NF_FBD
+		 */
+		channel = branch & 2;
+
 		bank = NREC_BANK(info->nrecmema);
 		rank = NREC_RANK(info->nrecmema);
 		rdwr = NREC_RDWR(info->nrecmema);
diff -Nur linux-2.6.32-orig/drivers/firewire/core-card.c iDroid-Project-kernel_common-9e90fd2/drivers/firewire/core-card.c
--- linux-2.6.32-orig/drivers/firewire/core-card.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/firewire/core-card.c	2010-11-18 21:05:30.000000000 +0600
@@ -57,6 +57,9 @@
 static LIST_HEAD(descriptor_list);
 static int descriptor_count;
 
+/* ROM header, bus info block, root dir header, capabilities = 7 quadlets */
+static size_t config_rom_length = 1 + 4 + 1 + 1;
+
 #define BIB_CRC(v)		((v) <<  0)
 #define BIB_CRC_LENGTH(v)	((v) << 16)
 #define BIB_INFO_LENGTH(v)	((v) << 24)
@@ -72,7 +75,7 @@
 #define BIB_CMC			((1) << 30)
 #define BIB_IMC			((1) << 31)
 
-static u32 *generate_config_rom(struct fw_card *card, size_t *config_rom_length)
+static u32 *generate_config_rom(struct fw_card *card)
 {
 	struct fw_descriptor *desc;
 	static u32 config_rom[256];
@@ -131,7 +134,7 @@
 	for (i = 0; i < j; i += length + 1)
 		length = fw_compute_block_crc(config_rom + i);
 
-	*config_rom_length = j;
+	WARN_ON(j != config_rom_length);
 
 	return config_rom;
 }
@@ -140,17 +143,24 @@
 {
 	struct fw_card *card;
 	u32 *config_rom;
-	size_t length;
 
 	list_for_each_entry (card, &card_list, link) {
-		config_rom = generate_config_rom(card, &length);
-		card->driver->set_config_rom(card, config_rom, length);
+		config_rom = generate_config_rom(card);
+		card->driver->set_config_rom(card, config_rom,
+					     config_rom_length);
 	}
 }
 
+static size_t required_space(struct fw_descriptor *desc)
+{
+	/* descriptor + entry into root dir + optional immediate entry */
+	return desc->length + 1 + (desc->immediate > 0 ? 1 : 0);
+}
+
 int fw_core_add_descriptor(struct fw_descriptor *desc)
 {
 	size_t i;
+	int ret;
 
 	/*
 	 * Check descriptor is valid; the length of all blocks in the
@@ -166,15 +176,21 @@
 
 	mutex_lock(&card_mutex);
 
-	list_add_tail(&desc->link, &descriptor_list);
-	descriptor_count++;
-	if (desc->immediate > 0)
+	if (config_rom_length + required_space(desc) > 256) {
+		ret = -EBUSY;
+	} else {
+		list_add_tail(&desc->link, &descriptor_list);
+		config_rom_length += required_space(desc);
 		descriptor_count++;
-	update_config_roms();
+		if (desc->immediate > 0)
+			descriptor_count++;
+		update_config_roms();
+		ret = 0;
+	}
 
 	mutex_unlock(&card_mutex);
 
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL(fw_core_add_descriptor);
 
@@ -183,6 +199,7 @@
 	mutex_lock(&card_mutex);
 
 	list_del(&desc->link);
+	config_rom_length -= required_space(desc);
 	descriptor_count--;
 	if (desc->immediate > 0)
 		descriptor_count--;
@@ -436,7 +453,6 @@
 		u32 max_receive, u32 link_speed, u64 guid)
 {
 	u32 *config_rom;
-	size_t length;
 	int ret;
 
 	card->max_receive = max_receive;
@@ -445,8 +461,8 @@
 
 	mutex_lock(&card_mutex);
 
-	config_rom = generate_config_rom(card, &length);
-	ret = card->driver->enable(card, config_rom, length);
+	config_rom = generate_config_rom(card);
+	ret = card->driver->enable(card, config_rom, config_rom_length);
 	if (ret == 0)
 		list_add_tail(&card->link, &card_list);
 
diff -Nur linux-2.6.32-orig/drivers/firewire/ohci.c iDroid-Project-kernel_common-9e90fd2/drivers/firewire/ohci.c
--- linux-2.6.32-orig/drivers/firewire/ohci.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/firewire/ohci.c	2010-11-18 21:05:30.000000000 +0600
@@ -2209,6 +2209,13 @@
 	page     = payload >> PAGE_SHIFT;
 	offset   = payload & ~PAGE_MASK;
 	rest     = p->payload_length;
+	/*
+	 * The controllers I've tested have not worked correctly when
+	 * second_req_count is zero.  Rather than do something we know won't
+	 * work, return an error
+	 */
+	if (rest == 0)
+		return -EINVAL;
 
 	/* FIXME: make packet-per-buffer/dual-buffer a context option */
 	while (rest > 0) {
@@ -2262,7 +2269,7 @@
 					unsigned long payload)
 {
 	struct iso_context *ctx = container_of(base, struct iso_context, base);
-	struct descriptor *d = NULL, *pd = NULL;
+	struct descriptor *d, *pd;
 	struct fw_iso_packet *p = packet;
 	dma_addr_t d_bus, page_bus;
 	u32 z, header_z, rest;
@@ -2300,8 +2307,9 @@
 		d->data_address = cpu_to_le32(d_bus + (z * sizeof(*d)));
 
 		rest = payload_per_buffer;
+		pd = d;
 		for (j = 1; j < z; j++) {
-			pd = d + j;
+			pd++;
 			pd->control = cpu_to_le16(DESCRIPTOR_STATUS |
 						  DESCRIPTOR_INPUT_MORE);
 
@@ -2404,6 +2412,7 @@
 
 #define PCI_VENDOR_ID_AGERE		PCI_VENDOR_ID_ATT
 #define PCI_DEVICE_ID_AGERE_FW643	0x5901
+#define PCI_DEVICE_ID_TI_TSB43AB23	0x8024
 
 static int __devinit pci_probe(struct pci_dev *dev,
 			       const struct pci_device_id *ent)
@@ -2469,7 +2478,8 @@
 #if !defined(CONFIG_X86_32)
 	/* dual-buffer mode is broken with descriptor addresses above 2G */
 	if (dev->vendor == PCI_VENDOR_ID_TI &&
-	    dev->device == PCI_DEVICE_ID_TI_TSB43AB22)
+	    (dev->device == PCI_DEVICE_ID_TI_TSB43AB22 ||
+	     dev->device == PCI_DEVICE_ID_TI_TSB43AB23))
 		ohci->use_dualbuffer = false;
 #endif
 
diff -Nur linux-2.6.32-orig/drivers/firmware/dmi_scan.c iDroid-Project-kernel_common-9e90fd2/drivers/firmware/dmi_scan.c
--- linux-2.6.32-orig/drivers/firmware/dmi_scan.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/firmware/dmi_scan.c	2010-11-18 21:05:30.000000000 +0600
@@ -429,7 +429,7 @@
 	for (i = 0; i < ARRAY_SIZE(dmi->matches); i++) {
 		int s = dmi->matches[i].slot;
 		if (s == DMI_NONE)
-			continue;
+			break;
 		if (dmi_ident[s]
 		    && strstr(dmi_ident[s], dmi->matches[i].substr))
 			continue;
@@ -440,6 +440,15 @@
 }
 
 /**
+ *	dmi_is_end_of_table - check for end-of-table marker
+ *	@dmi: pointer to the dmi_system_id structure to check
+ */
+static bool dmi_is_end_of_table(const struct dmi_system_id *dmi)
+{
+	return dmi->matches[0].slot == DMI_NONE;
+}
+
+/**
  *	dmi_check_system - check system DMI data
  *	@list: array of dmi_system_id structures to match against
  *		All non-null elements of the list must match
@@ -457,7 +466,7 @@
 	int count = 0;
 	const struct dmi_system_id *d;
 
-	for (d = list; d->ident; d++)
+	for (d = list; !dmi_is_end_of_table(d); d++)
 		if (dmi_matches(d)) {
 			count++;
 			if (d->callback && d->callback(d))
@@ -484,7 +493,7 @@
 {
 	const struct dmi_system_id *d;
 
-	for (d = list; d->ident; d++)
+	for (d = list; !dmi_is_end_of_table(d); d++)
 		if (dmi_matches(d))
 			return d;
 
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/ati_pcigart.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/ati_pcigart.c
--- linux-2.6.32-orig/drivers/gpu/drm/ati_pcigart.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/ati_pcigart.c	2010-11-18 21:05:30.000000000 +0600
@@ -39,8 +39,7 @@
 				       struct drm_ati_pcigart_info *gart_info)
 {
 	gart_info->table_handle = drm_pci_alloc(dev, gart_info->table_size,
-						PAGE_SIZE,
-						gart_info->table_mask);
+						PAGE_SIZE);
 	if (gart_info->table_handle == NULL)
 		return -ENOMEM;
 
@@ -112,6 +111,13 @@
 	if (gart_info->gart_table_location == DRM_ATI_GART_MAIN) {
 		DRM_DEBUG("PCI: no table in VRAM: using normal RAM\n");
 
+		if (pci_set_dma_mask(dev->pdev, gart_info->table_mask)) {
+			DRM_ERROR("fail to set dma mask to 0x%Lx\n",
+				  gart_info->table_mask);
+			ret = 1;
+			goto done;
+		}
+
 		ret = drm_ati_alloc_pcigart_table(dev, gart_info);
 		if (ret) {
 			DRM_ERROR("cannot allocate PCI GART page!\n");
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/drm_bufs.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/drm_bufs.c
--- linux-2.6.32-orig/drivers/gpu/drm/drm_bufs.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/drm_bufs.c	2010-11-18 21:05:30.000000000 +0600
@@ -326,7 +326,7 @@
 		 * As we're limiting the address to 2^32-1 (or less),
 		 * casting it down to 32 bits is no problem, but we
 		 * need to point to a 64bit variable first. */
-		dmah = drm_pci_alloc(dev, map->size, map->size, 0xffffffffUL);
+		dmah = drm_pci_alloc(dev, map->size, map->size);
 		if (!dmah) {
 			kfree(map);
 			return -ENOMEM;
@@ -885,7 +885,7 @@
 
 	while (entry->buf_count < count) {
 
-		dmah = drm_pci_alloc(dev, PAGE_SIZE << page_order, 0x1000, 0xfffffffful);
+		dmah = drm_pci_alloc(dev, PAGE_SIZE << page_order, 0x1000);
 
 		if (!dmah) {
 			/* Set count correctly so we free the proper amount. */
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/drm_crtc_helper.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/drm_crtc_helper.c
--- linux-2.6.32-orig/drivers/gpu/drm/drm_crtc_helper.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/drm_crtc_helper.c	2010-11-18 21:05:30.000000000 +0600
@@ -1020,6 +1020,9 @@
 {
 	int count = 0;
 
+	/* disable all the possible outputs/crtcs before entering KMS mode */
+	drm_helper_disable_unused_functions(dev);
+
 	drm_fb_helper_parse_command_line(dev);
 
 	count = drm_helper_probe_connector_modes(dev,
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/drm_gem.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/drm_gem.c
--- linux-2.6.32-orig/drivers/gpu/drm/drm_gem.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/drm_gem.c	2010-11-18 21:05:30.000000000 +0600
@@ -142,19 +142,6 @@
 	if (IS_ERR(obj->filp))
 		goto free;
 
-	/* Basically we want to disable the OOM killer and handle ENOMEM
-	 * ourselves by sacrificing pages from cached buffers.
-	 * XXX shmem_file_[gs]et_gfp_mask()
-	 */
-	mapping_set_gfp_mask(obj->filp->f_path.dentry->d_inode->i_mapping,
-			     GFP_HIGHUSER |
-			     __GFP_COLD |
-			     __GFP_FS |
-			     __GFP_RECLAIMABLE |
-			     __GFP_NORETRY |
-			     __GFP_NOWARN |
-			     __GFP_NOMEMALLOC);
-
 	kref_init(&obj->refcount);
 	kref_init(&obj->handlecount);
 	obj->size = size;
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/drm_irq.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/drm_irq.c
--- linux-2.6.32-orig/drivers/gpu/drm/drm_irq.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/drm_irq.c	2010-11-18 21:05:30.000000000 +0600
@@ -429,15 +429,21 @@
 
 	spin_lock_irqsave(&dev->vbl_lock, irqflags);
 	/* Going from 0->1 means we have to enable interrupts again */
-	if (atomic_add_return(1, &dev->vblank_refcount[crtc]) == 1 &&
-	    !dev->vblank_enabled[crtc]) {
-		ret = dev->driver->enable_vblank(dev, crtc);
-		DRM_DEBUG("enabling vblank on crtc %d, ret: %d\n", crtc, ret);
-		if (ret)
+	if (atomic_add_return(1, &dev->vblank_refcount[crtc]) == 1) {
+		if (!dev->vblank_enabled[crtc]) {
+			ret = dev->driver->enable_vblank(dev, crtc);
+			DRM_DEBUG("enabling vblank on crtc %d, ret: %d\n", crtc, ret);
+			if (ret)
+				atomic_dec(&dev->vblank_refcount[crtc]);
+			else {
+				dev->vblank_enabled[crtc] = 1;
+				drm_update_vblank_count(dev, crtc);
+			}
+		}
+	} else {
+		if (!dev->vblank_enabled[crtc]) {
 			atomic_dec(&dev->vblank_refcount[crtc]);
-		else {
-			dev->vblank_enabled[crtc] = 1;
-			drm_update_vblank_count(dev, crtc);
+			ret = -EINVAL;
 		}
 	}
 	spin_unlock_irqrestore(&dev->vbl_lock, irqflags);
@@ -464,6 +470,18 @@
 }
 EXPORT_SYMBOL(drm_vblank_put);
 
+void drm_vblank_off(struct drm_device *dev, int crtc)
+{
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&dev->vbl_lock, irqflags);
+	DRM_WAKEUP(&dev->vbl_queue[crtc]);
+	dev->vblank_enabled[crtc] = 0;
+	dev->last_vblank[crtc] = dev->driver->get_vblank_counter(dev, crtc);
+	spin_unlock_irqrestore(&dev->vbl_lock, irqflags);
+}
+EXPORT_SYMBOL(drm_vblank_off);
+
 /**
  * drm_vblank_pre_modeset - account for vblanks across mode sets
  * @dev: DRM device
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/drm_pci.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/drm_pci.c
--- linux-2.6.32-orig/drivers/gpu/drm/drm_pci.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/drm_pci.c	2010-11-18 21:05:30.000000000 +0600
@@ -47,8 +47,7 @@
 /**
  * \brief Allocate a PCI consistent memory block, for DMA.
  */
-drm_dma_handle_t *drm_pci_alloc(struct drm_device * dev, size_t size, size_t align,
-				dma_addr_t maxaddr)
+drm_dma_handle_t *drm_pci_alloc(struct drm_device * dev, size_t size, size_t align)
 {
 	drm_dma_handle_t *dmah;
 #if 1
@@ -63,11 +62,6 @@
 	if (align > size)
 		return NULL;
 
-	if (pci_set_dma_mask(dev->pdev, maxaddr) != 0) {
-		DRM_ERROR("Setting pci dma mask failed\n");
-		return NULL;
-	}
-
 	dmah = kmalloc(sizeof(drm_dma_handle_t), GFP_KERNEL);
 	if (!dmah)
 		return NULL;
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/i915_debugfs.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_debugfs.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/i915_debugfs.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_debugfs.c	2010-11-18 21:05:30.000000000 +0600
@@ -288,7 +288,7 @@
 	list_for_each_entry(obj_priv, &dev_priv->mm.active_list, list) {
 		obj = obj_priv->obj;
 		if (obj->read_domains & I915_GEM_DOMAIN_COMMAND) {
-		    ret = i915_gem_object_get_pages(obj);
+		    ret = i915_gem_object_get_pages(obj, 0);
 		    if (ret) {
 			    DRM_ERROR("Failed to get pages: %d\n", ret);
 			    spin_unlock(&dev_priv->mm.active_list_lock);
@@ -384,37 +384,7 @@
 	return 0;
 }
 
-static int i915_registers_info(struct seq_file *m, void *data) {
-	struct drm_info_node *node = (struct drm_info_node *) m->private;
-	struct drm_device *dev = node->minor->dev;
-	drm_i915_private_t *dev_priv = dev->dev_private;
-	uint32_t reg;
-
-#define DUMP_RANGE(start, end) \
-	for (reg=start; reg < end; reg += 4) \
-	seq_printf(m, "%08x\t%08x\n", reg, I915_READ(reg));
-
-	DUMP_RANGE(0x00000, 0x00fff);   /* VGA registers */
-	DUMP_RANGE(0x02000, 0x02fff);   /* instruction, memory, interrupt control registers */
-	DUMP_RANGE(0x03000, 0x031ff);   /* FENCE and PPGTT control registers */
-	DUMP_RANGE(0x03200, 0x03fff);   /* frame buffer compression registers */
-	DUMP_RANGE(0x05000, 0x05fff);   /* I/O control registers */
-	DUMP_RANGE(0x06000, 0x06fff);   /* clock control registers */
-	DUMP_RANGE(0x07000, 0x07fff);   /* 3D internal debug registers */
-	DUMP_RANGE(0x07400, 0x088ff);   /* GPE debug registers */
-	DUMP_RANGE(0x0a000, 0x0afff);   /* display palette registers */
-	DUMP_RANGE(0x10000, 0x13fff);   /* MMIO MCHBAR */
-	DUMP_RANGE(0x30000, 0x3ffff);   /* overlay registers */
-	DUMP_RANGE(0x60000, 0x6ffff);   /* display engine pipeline registers */
-	DUMP_RANGE(0x70000, 0x72fff);   /* display and cursor registers */
-	DUMP_RANGE(0x73000, 0x73fff);   /* performance counters */
-
-	return 0;
-}
-
-
 static struct drm_info_list i915_debugfs_list[] = {
-	{"i915_regs", i915_registers_info, 0},
 	{"i915_gem_active", i915_gem_object_list_info, 0, (void *) ACTIVE_LIST},
 	{"i915_gem_flushing", i915_gem_object_list_info, 0, (void *) FLUSHING_LIST},
 	{"i915_gem_inactive", i915_gem_object_list_info, 0, (void *) INACTIVE_LIST},
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/i915_dma.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_dma.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/i915_dma.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_dma.c	2010-11-18 21:05:30.000000000 +0600
@@ -123,7 +123,7 @@
 	drm_i915_private_t *dev_priv = dev->dev_private;
 	/* Program Hardware Status Page */
 	dev_priv->status_page_dmah =
-		drm_pci_alloc(dev, PAGE_SIZE, PAGE_SIZE, 0xffffffff);
+		drm_pci_alloc(dev, PAGE_SIZE, PAGE_SIZE);
 
 	if (!dev_priv->status_page_dmah) {
 		DRM_ERROR("Can not allocate hardware status page\n");
@@ -1111,7 +1111,8 @@
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct drm_mm_node *compressed_fb, *compressed_llb;
-	unsigned long cfb_base, ll_base;
+	unsigned long cfb_base;
+	unsigned long ll_base = 0;
 
 	/* Leave 1M for line length buffer & misc. */
 	compressed_fb = drm_mm_search_free(&dev_priv->vram, size, 4096, 0);
@@ -1251,6 +1252,8 @@
 	if (ret)
 		goto destroy_ringbuffer;
 
+	intel_modeset_init(dev);
+
 	ret = drm_irq_install(dev);
 	if (ret)
 		goto destroy_ringbuffer;
@@ -1265,8 +1268,6 @@
 
 	I915_WRITE(INSTPM, (1 << 5) | (1 << 21));
 
-	intel_modeset_init(dev);
-
 	drm_helper_initial_config(dev);
 
 	return 0;
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/i915_drv.h iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_drv.h
--- linux-2.6.32-orig/drivers/gpu/drm/i915/i915_drv.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_drv.h	2010-11-18 21:05:30.000000000 +0600
@@ -467,6 +467,15 @@
 		struct list_head flushing_list;
 
 		/**
+		 * List of objects currently pending a GPU write flush.
+		 *
+		 * All elements on this list will belong to either the
+		 * active_list or flushing_list, last_rendering_seqno can
+		 * be used to differentiate between the two elements.
+		 */
+		struct list_head gpu_write_list;
+
+		/**
 		 * LRU list of objects which are not in the ringbuffer and
 		 * are ready to unbind, but are still in the GTT.
 		 *
@@ -546,6 +555,7 @@
 	struct timer_list idle_timer;
 	bool busy;
 	u16 orig_clock;
+	struct drm_connector *int_lvds_connector;
 } drm_i915_private_t;
 
 /** driver private structure attached to each drm_gem_object */
@@ -557,6 +567,8 @@
 
 	/** This object's place on the active/flushing/inactive lists */
 	struct list_head list;
+	/** This object's place on GPU write list */
+	struct list_head gpu_write_list;
 
 	/** This object's place on the fenced object LRU */
 	struct list_head fence_list;
@@ -813,15 +825,17 @@
 int i915_gem_do_init(struct drm_device *dev, unsigned long start,
 		     unsigned long end);
 int i915_gem_idle(struct drm_device *dev);
+int i915_lp_ring_sync(struct drm_device *dev);
 int i915_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf);
 int i915_gem_object_set_to_gtt_domain(struct drm_gem_object *obj,
 				      int write);
+int i915_gem_object_set_to_display_plane(struct drm_gem_object *obj);
 int i915_gem_attach_phys_object(struct drm_device *dev,
 				struct drm_gem_object *obj, int id);
 void i915_gem_detach_phys_object(struct drm_device *dev,
 				 struct drm_gem_object *obj);
 void i915_gem_free_all_phys_object(struct drm_device *dev);
-int i915_gem_object_get_pages(struct drm_gem_object *obj);
+int i915_gem_object_get_pages(struct drm_gem_object *obj, gfp_t gfpmask);
 void i915_gem_object_put_pages(struct drm_gem_object *obj);
 void i915_gem_release(struct drm_device * dev, struct drm_file *file_priv);
 
@@ -957,6 +971,7 @@
 #define IS_I85X(dev) ((dev)->pci_device == 0x3582)
 #define IS_I855(dev) ((dev)->pci_device == 0x3582)
 #define IS_I865G(dev) ((dev)->pci_device == 0x2572)
+#define IS_I8XX(dev) (IS_I830(dev) || IS_845G(dev) || IS_I85X(dev) || IS_I865G(dev))
 
 #define IS_I915G(dev) ((dev)->pci_device == 0x2582 || (dev)->pci_device == 0x258a)
 #define IS_I915GM(dev) ((dev)->pci_device == 0x2592)
@@ -1018,9 +1033,12 @@
  */
 #define HAS_128_BYTE_Y_TILING(dev) (IS_I9XX(dev) && !(IS_I915G(dev) || \
 						      IS_I915GM(dev)))
+#define SUPPORTS_DIGITAL_OUTPUTS(dev)	(IS_I9XX(dev) && !IS_IGD(dev))
 #define SUPPORTS_INTEGRATED_HDMI(dev)	(IS_G4X(dev) || IS_IGDNG(dev))
 #define SUPPORTS_INTEGRATED_DP(dev)	(IS_G4X(dev) || IS_IGDNG(dev))
 #define SUPPORTS_EDP(dev)		(IS_IGDNG_M(dev))
+#define SUPPORTS_TV(dev)		(IS_I9XX(dev) && IS_MOBILE(dev) && \
+					!IS_IGDNG(dev) && !IS_IGD(dev))
 #define I915_HAS_HOTPLUG(dev) (IS_I945G(dev) || IS_I945GM(dev) || IS_G33(dev) || IS_I965G(dev))
 /* dsparb controlled by hw only */
 #define DSPARB_HWCONTROL(dev) (IS_G4X(dev) || IS_IGDNG(dev))
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/i915_gem.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_gem.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/i915_gem.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_gem.c	2010-11-18 21:05:30.000000000 +0600
@@ -277,7 +277,7 @@
 
 	mutex_lock(&dev->struct_mutex);
 
-	ret = i915_gem_object_get_pages(obj);
+	ret = i915_gem_object_get_pages(obj, 0);
 	if (ret != 0)
 		goto fail_unlock;
 
@@ -321,40 +321,24 @@
 	return ret;
 }
 
-static inline gfp_t
-i915_gem_object_get_page_gfp_mask (struct drm_gem_object *obj)
-{
-	return mapping_gfp_mask(obj->filp->f_path.dentry->d_inode->i_mapping);
-}
-
-static inline void
-i915_gem_object_set_page_gfp_mask (struct drm_gem_object *obj, gfp_t gfp)
-{
-	mapping_set_gfp_mask(obj->filp->f_path.dentry->d_inode->i_mapping, gfp);
-}
-
 static int
 i915_gem_object_get_pages_or_evict(struct drm_gem_object *obj)
 {
 	int ret;
 
-	ret = i915_gem_object_get_pages(obj);
+	ret = i915_gem_object_get_pages(obj, __GFP_NORETRY | __GFP_NOWARN);
 
 	/* If we've insufficient memory to map in the pages, attempt
 	 * to make some space by throwing out some old buffers.
 	 */
 	if (ret == -ENOMEM) {
 		struct drm_device *dev = obj->dev;
-		gfp_t gfp;
 
 		ret = i915_gem_evict_something(dev, obj->size);
 		if (ret)
 			return ret;
 
-		gfp = i915_gem_object_get_page_gfp_mask(obj);
-		i915_gem_object_set_page_gfp_mask(obj, gfp & ~__GFP_NORETRY);
-		ret = i915_gem_object_get_pages(obj);
-		i915_gem_object_set_page_gfp_mask (obj, gfp);
+		ret = i915_gem_object_get_pages(obj, 0);
 	}
 
 	return ret;
@@ -790,7 +774,7 @@
 
 	mutex_lock(&dev->struct_mutex);
 
-	ret = i915_gem_object_get_pages(obj);
+	ret = i915_gem_object_get_pages(obj, 0);
 	if (ret != 0)
 		goto fail_unlock;
 
@@ -1288,6 +1272,7 @@
 	list->hash.key = list->file_offset_node->start;
 	if (drm_ht_insert_item(&mm->offset_hash, &list->hash)) {
 		DRM_ERROR("failed to add to map hash\n");
+		ret = -ENOMEM;
 		goto out_free_mm;
 	}
 
@@ -1567,6 +1552,8 @@
 	else
 		list_move_tail(&obj_priv->list, &dev_priv->mm.inactive_list);
 
+	BUG_ON(!list_empty(&obj_priv->gpu_write_list));
+
 	obj_priv->last_rendering_seqno = 0;
 	if (obj_priv->active) {
 		obj_priv->active = 0;
@@ -1637,7 +1624,8 @@
 		struct drm_i915_gem_object *obj_priv, *next;
 
 		list_for_each_entry_safe(obj_priv, next,
-					 &dev_priv->mm.flushing_list, list) {
+					 &dev_priv->mm.gpu_write_list,
+					 gpu_write_list) {
 			struct drm_gem_object *obj = obj_priv->obj;
 
 			if ((obj->write_domain & flush_domains) ==
@@ -1645,6 +1633,7 @@
 				uint32_t old_write_domain = obj->write_domain;
 
 				obj->write_domain = 0;
+				list_del_init(&obj_priv->gpu_write_list);
 				i915_gem_object_move_to_active(obj, seqno);
 
 				trace_i915_gem_object_change_domain(obj,
@@ -1820,12 +1809,8 @@
 	mutex_unlock(&dev->struct_mutex);
 }
 
-/**
- * Waits for a sequence number to be signaled, and cleans up the
- * request and object lists appropriately for that event.
- */
 static int
-i915_wait_request(struct drm_device *dev, uint32_t seqno)
+i915_do_wait_request(struct drm_device *dev, uint32_t seqno, int interruptible)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
 	u32 ier;
@@ -1852,10 +1837,15 @@
 
 		dev_priv->mm.waiting_gem_seqno = seqno;
 		i915_user_irq_get(dev);
-		ret = wait_event_interruptible(dev_priv->irq_queue,
-					       i915_seqno_passed(i915_get_gem_seqno(dev),
-								 seqno) ||
-					       atomic_read(&dev_priv->mm.wedged));
+		if (interruptible)
+			ret = wait_event_interruptible(dev_priv->irq_queue,
+				i915_seqno_passed(i915_get_gem_seqno(dev), seqno) ||
+				atomic_read(&dev_priv->mm.wedged));
+		else
+			wait_event(dev_priv->irq_queue,
+				i915_seqno_passed(i915_get_gem_seqno(dev), seqno) ||
+				atomic_read(&dev_priv->mm.wedged));
+
 		i915_user_irq_put(dev);
 		dev_priv->mm.waiting_gem_seqno = 0;
 
@@ -1879,6 +1869,34 @@
 	return ret;
 }
 
+/**
+ * Waits for a sequence number to be signaled, and cleans up the
+ * request and object lists appropriately for that event.
+ */
+static int
+i915_wait_request(struct drm_device *dev, uint32_t seqno)
+{
+	return i915_do_wait_request(dev, seqno, 1);
+}
+
+/**
+ * Waits for the ring to finish up to the latest request. Usefull for waiting
+ * for flip events, e.g for the overlay support. */
+int i915_lp_ring_sync(struct drm_device *dev)
+{
+	uint32_t seqno;
+	int ret;
+
+	seqno = i915_add_request(dev, NULL, 0);
+
+	if (seqno == 0)
+		return -ENOMEM;
+
+	ret = i915_do_wait_request(dev, seqno, 0);
+	BUG_ON(ret == -ERESTARTSYS);
+	return ret;
+}
+
 static void
 i915_gem_flush(struct drm_device *dev,
 	       uint32_t invalidate_domains,
@@ -1947,7 +1965,7 @@
 #endif
 		BEGIN_LP_RING(2);
 		OUT_RING(cmd);
-		OUT_RING(0); /* noop */
+		OUT_RING(MI_NOOP);
 		ADVANCE_LP_RING();
 	}
 }
@@ -2009,9 +2027,6 @@
 	/* blow away mappings if mapped through GTT */
 	i915_gem_release_mmap(obj);
 
-	if (obj_priv->fence_reg != I915_FENCE_REG_NONE)
-		i915_gem_clear_fence_reg(obj);
-
 	/* Move the object to the CPU domain to ensure that
 	 * any possible CPU writes while it's not in the GTT
 	 * are flushed when we go to remap it. This will
@@ -2027,6 +2042,10 @@
 
 	BUG_ON(obj_priv->active);
 
+	/* release the fence reg _after_ flushing */
+	if (obj_priv->fence_reg != I915_FENCE_REG_NONE)
+		i915_gem_clear_fence_reg(obj);
+
 	if (obj_priv->agp_mem != NULL) {
 		drm_unbind_agp(obj_priv->agp_mem);
 		drm_free_agp(obj_priv->agp_mem, obj->size / PAGE_SIZE);
@@ -2087,8 +2106,8 @@
 i915_gem_evict_everything(struct drm_device *dev)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
-	uint32_t seqno;
 	int ret;
+	uint32_t seqno;
 	bool lists_empty;
 
 	spin_lock(&dev_priv->mm.active_list_lock);
@@ -2110,6 +2129,8 @@
 	if (ret)
 		return ret;
 
+	BUG_ON(!list_empty(&dev_priv->mm.flushing_list));
+
 	ret = i915_gem_evict_from_inactive_list(dev);
 	if (ret)
 		return ret;
@@ -2217,7 +2238,8 @@
 }
 
 int
-i915_gem_object_get_pages(struct drm_gem_object *obj)
+i915_gem_object_get_pages(struct drm_gem_object *obj,
+			  gfp_t gfpmask)
 {
 	struct drm_i915_gem_object *obj_priv = obj->driver_private;
 	int page_count, i;
@@ -2243,7 +2265,10 @@
 	inode = obj->filp->f_path.dentry->d_inode;
 	mapping = inode->i_mapping;
 	for (i = 0; i < page_count; i++) {
-		page = read_mapping_page(mapping, i, NULL);
+		page = read_cache_page_gfp(mapping, i,
+					   mapping_gfp_mask (mapping) |
+					   __GFP_COLD |
+					   gfpmask);
 		if (IS_ERR(page)) {
 			ret = PTR_ERR(page);
 			i915_gem_object_put_pages(obj);
@@ -2566,12 +2591,9 @@
 	drm_i915_private_t *dev_priv = dev->dev_private;
 	struct drm_i915_gem_object *obj_priv = obj->driver_private;
 	struct drm_mm_node *free_space;
-	bool retry_alloc = false;
+	gfp_t gfpmask =  __GFP_NORETRY | __GFP_NOWARN;
 	int ret;
 
-	if (dev_priv->mm.suspended)
-		return -EBUSY;
-
 	if (obj_priv->madv != I915_MADV_WILLNEED) {
 		DRM_ERROR("Attempting to bind a purgeable object\n");
 		return -EINVAL;
@@ -2613,15 +2635,7 @@
 	DRM_INFO("Binding object of size %zd at 0x%08x\n",
 		 obj->size, obj_priv->gtt_offset);
 #endif
-	if (retry_alloc) {
-		i915_gem_object_set_page_gfp_mask (obj,
-						   i915_gem_object_get_page_gfp_mask (obj) & ~__GFP_NORETRY);
-	}
-	ret = i915_gem_object_get_pages(obj);
-	if (retry_alloc) {
-		i915_gem_object_set_page_gfp_mask (obj,
-						   i915_gem_object_get_page_gfp_mask (obj) | __GFP_NORETRY);
-	}
+	ret = i915_gem_object_get_pages(obj, gfpmask);
 	if (ret) {
 		drm_mm_put_block(obj_priv->gtt_space);
 		obj_priv->gtt_space = NULL;
@@ -2631,9 +2645,9 @@
 			ret = i915_gem_evict_something(dev, obj->size);
 			if (ret) {
 				/* now try to shrink everyone else */
-				if (! retry_alloc) {
-				    retry_alloc = true;
-				    goto search_free;
+				if (gfpmask) {
+					gfpmask = 0;
+					goto search_free;
 				}
 
 				return ret;
@@ -2711,7 +2725,7 @@
 	old_write_domain = obj->write_domain;
 	i915_gem_flush(dev, 0, obj->write_domain);
 	seqno = i915_add_request(dev, NULL, obj->write_domain);
-	obj->write_domain = 0;
+	BUG_ON(obj->write_domain);
 	i915_gem_object_move_to_active(obj, seqno);
 
 	trace_i915_gem_object_change_domain(obj,
@@ -2811,6 +2825,57 @@
 	return 0;
 }
 
+/*
+ * Prepare buffer for display plane. Use uninterruptible for possible flush
+ * wait, as in modesetting process we're not supposed to be interrupted.
+ */
+int
+i915_gem_object_set_to_display_plane(struct drm_gem_object *obj)
+{
+	struct drm_device *dev = obj->dev;
+	struct drm_i915_gem_object *obj_priv = obj->driver_private;
+	uint32_t old_write_domain, old_read_domains;
+	int ret;
+
+	/* Not valid to be called on unbound objects. */
+	if (obj_priv->gtt_space == NULL)
+		return -EINVAL;
+
+	i915_gem_object_flush_gpu_write_domain(obj);
+
+	/* Wait on any GPU rendering and flushing to occur. */
+	if (obj_priv->active) {
+#if WATCH_BUF
+		DRM_INFO("%s: object %p wait for seqno %08x\n",
+			  __func__, obj, obj_priv->last_rendering_seqno);
+#endif
+		ret = i915_do_wait_request(dev, obj_priv->last_rendering_seqno, 0);
+		if (ret != 0)
+			return ret;
+	}
+
+	old_write_domain = obj->write_domain;
+	old_read_domains = obj->read_domains;
+
+	obj->read_domains &= I915_GEM_DOMAIN_GTT;
+
+	i915_gem_object_flush_cpu_write_domain(obj);
+
+	/* It should now be out of any other write domains, and we can update
+	 * the domain values for our changes.
+	 */
+	BUG_ON((obj->write_domain & ~I915_GEM_DOMAIN_GTT) != 0);
+	obj->read_domains |= I915_GEM_DOMAIN_GTT;
+	obj->write_domain = I915_GEM_DOMAIN_GTT;
+	obj_priv->dirty = 1;
+
+	trace_i915_gem_object_change_domain(obj,
+					    old_read_domains,
+					    old_write_domain);
+
+	return 0;
+}
+
 /**
  * Moves a single object to the CPU read, and possibly write domain.
  *
@@ -3731,16 +3796,23 @@
 		i915_gem_flush(dev,
 			       dev->invalidate_domains,
 			       dev->flush_domains);
-		if (dev->flush_domains)
+		if (dev->flush_domains & I915_GEM_GPU_DOMAINS)
 			(void)i915_add_request(dev, file_priv,
 					       dev->flush_domains);
 	}
 
 	for (i = 0; i < args->buffer_count; i++) {
 		struct drm_gem_object *obj = object_list[i];
+		struct drm_i915_gem_object *obj_priv = obj->driver_private;
 		uint32_t old_write_domain = obj->write_domain;
 
 		obj->write_domain = obj->pending_write_domain;
+		if (obj->write_domain)
+			list_move_tail(&obj_priv->gpu_write_list,
+				       &dev_priv->mm.gpu_write_list);
+		else
+			list_del_init(&obj_priv->gpu_write_list);
+
 		trace_i915_gem_object_change_domain(obj,
 						    obj->read_domains,
 						    old_write_domain);
@@ -4133,6 +4205,7 @@
 	obj_priv->obj = obj;
 	obj_priv->fence_reg = I915_FENCE_REG_NONE;
 	INIT_LIST_HEAD(&obj_priv->list);
+	INIT_LIST_HEAD(&obj_priv->gpu_write_list);
 	INIT_LIST_HEAD(&obj_priv->fence_list);
 	obj_priv->madv = I915_MADV_WILLNEED;
 
@@ -4584,6 +4657,7 @@
 	spin_lock_init(&dev_priv->mm.active_list_lock);
 	INIT_LIST_HEAD(&dev_priv->mm.active_list);
 	INIT_LIST_HEAD(&dev_priv->mm.flushing_list);
+	INIT_LIST_HEAD(&dev_priv->mm.gpu_write_list);
 	INIT_LIST_HEAD(&dev_priv->mm.inactive_list);
 	INIT_LIST_HEAD(&dev_priv->mm.request_list);
 	INIT_LIST_HEAD(&dev_priv->mm.fence_list);
@@ -4638,7 +4712,7 @@
 
 	phys_obj->id = id;
 
-	phys_obj->handle = drm_pci_alloc(dev, size, 0, 0xffffffff);
+	phys_obj->handle = drm_pci_alloc(dev, size, 0);
 	if (!phys_obj->handle) {
 		ret = -ENOMEM;
 		goto kfree_obj;
@@ -4696,7 +4770,7 @@
 	if (!obj_priv->phys_obj)
 		return;
 
-	ret = i915_gem_object_get_pages(obj);
+	ret = i915_gem_object_get_pages(obj, 0);
 	if (ret)
 		goto out;
 
@@ -4754,7 +4828,7 @@
 	obj_priv->phys_obj = dev_priv->mm.phys_objs[id - 1];
 	obj_priv->phys_obj->cur_obj = obj;
 
-	ret = i915_gem_object_get_pages(obj);
+	ret = i915_gem_object_get_pages(obj, 0);
 	if (ret) {
 		DRM_ERROR("failed to get page list\n");
 		goto out;
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/i915_irq.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_irq.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/i915_irq.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_irq.c	2010-11-18 21:05:30.000000000 +0600
@@ -255,7 +255,6 @@
 	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
 	int ret = IRQ_NONE;
 	u32 de_iir, gt_iir, de_ier;
-	u32 new_de_iir, new_gt_iir;
 	struct drm_i915_master_private *master_priv;
 
 	/* disable master interrupt before clearing iir  */
@@ -266,35 +265,31 @@
 	de_iir = I915_READ(DEIIR);
 	gt_iir = I915_READ(GTIIR);
 
-	for (;;) {
-		if (de_iir == 0 && gt_iir == 0)
-			break;
-
-		ret = IRQ_HANDLED;
-
-		I915_WRITE(DEIIR, de_iir);
-		new_de_iir = I915_READ(DEIIR);
-		I915_WRITE(GTIIR, gt_iir);
-		new_gt_iir = I915_READ(GTIIR);
+	if (de_iir == 0 && gt_iir == 0)
+		goto done;
 
-		if (dev->primary->master) {
-			master_priv = dev->primary->master->driver_priv;
-			if (master_priv->sarea_priv)
-				master_priv->sarea_priv->last_dispatch =
-					READ_BREADCRUMB(dev_priv);
-		}
+	ret = IRQ_HANDLED;
 
-		if (gt_iir & GT_USER_INTERRUPT) {
-			u32 seqno = i915_get_gem_seqno(dev);
-			dev_priv->mm.irq_gem_seqno = seqno;
-			trace_i915_gem_request_complete(dev, seqno);
-			DRM_WAKEUP(&dev_priv->irq_queue);
-		}
+	if (dev->primary->master) {
+		master_priv = dev->primary->master->driver_priv;
+		if (master_priv->sarea_priv)
+			master_priv->sarea_priv->last_dispatch =
+				READ_BREADCRUMB(dev_priv);
+	}
 
-		de_iir = new_de_iir;
-		gt_iir = new_gt_iir;
+	if (gt_iir & GT_USER_INTERRUPT) {
+		u32 seqno = i915_get_gem_seqno(dev);
+		dev_priv->mm.irq_gem_seqno = seqno;
+		trace_i915_gem_request_complete(dev, seqno);
+		DRM_WAKEUP(&dev_priv->irq_queue);
+		dev_priv->hangcheck_count = 0;
+		mod_timer(&dev_priv->hangcheck_timer, jiffies + DRM_I915_HANGCHECK_PERIOD);
 	}
 
+	I915_WRITE(GTIIR, gt_iir);
+	I915_WRITE(DEIIR, de_iir);
+
+done:
 	I915_WRITE(DEIER, de_ier);
 	(void)I915_READ(DEIER);
 
@@ -1049,6 +1044,10 @@
 	(void) I915_READ(IER);
 }
 
+/*
+ * Must be called after intel_modeset_init or hotplug interrupts won't be
+ * enabled correctly.
+ */
 int i915_driver_irq_postinstall(struct drm_device *dev)
 {
 	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
@@ -1071,19 +1070,23 @@
 	if (I915_HAS_HOTPLUG(dev)) {
 		u32 hotplug_en = I915_READ(PORT_HOTPLUG_EN);
 
-		/* Leave other bits alone */
-		hotplug_en |= HOTPLUG_EN_MASK;
+		/* Note HDMI and DP share bits */
+		if (dev_priv->hotplug_supported_mask & HDMIB_HOTPLUG_INT_STATUS)
+			hotplug_en |= HDMIB_HOTPLUG_INT_EN;
+		if (dev_priv->hotplug_supported_mask & HDMIC_HOTPLUG_INT_STATUS)
+			hotplug_en |= HDMIC_HOTPLUG_INT_EN;
+		if (dev_priv->hotplug_supported_mask & HDMID_HOTPLUG_INT_STATUS)
+			hotplug_en |= HDMID_HOTPLUG_INT_EN;
+		if (dev_priv->hotplug_supported_mask & SDVOC_HOTPLUG_INT_STATUS)
+			hotplug_en |= SDVOC_HOTPLUG_INT_EN;
+		if (dev_priv->hotplug_supported_mask & SDVOB_HOTPLUG_INT_STATUS)
+			hotplug_en |= SDVOB_HOTPLUG_INT_EN;
+		if (dev_priv->hotplug_supported_mask & CRT_HOTPLUG_INT_STATUS)
+			hotplug_en |= CRT_HOTPLUG_INT_EN;
+		/* Ignore TV since it's buggy */
+
 		I915_WRITE(PORT_HOTPLUG_EN, hotplug_en);
 
-		dev_priv->hotplug_supported_mask = CRT_HOTPLUG_INT_STATUS |
-			TV_HOTPLUG_INT_STATUS | SDVOC_HOTPLUG_INT_STATUS |
-			SDVOB_HOTPLUG_INT_STATUS;
-		if (IS_G4X(dev)) {
-			dev_priv->hotplug_supported_mask |=
-				HDMIB_HOTPLUG_INT_STATUS |
-				HDMIC_HOTPLUG_INT_STATUS |
-				HDMID_HOTPLUG_INT_STATUS;
-		}
 		/* Enable in IER... */
 		enable_mask |= I915_DISPLAY_PORT_INTERRUPT;
 		/* and unmask in IMR */
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/i915_reg.h iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_reg.h
--- linux-2.6.32-orig/drivers/gpu/drm/i915/i915_reg.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_reg.h	2010-11-18 21:05:30.000000000 +0600
@@ -329,6 +329,7 @@
 #define   FBC_CTL_PERIODIC	(1<<30)
 #define   FBC_CTL_INTERVAL_SHIFT (16)
 #define   FBC_CTL_UNCOMPRESSIBLE (1<<14)
+#define   FBC_C3_IDLE		(1<<13)
 #define   FBC_CTL_STRIDE_SHIFT	(5)
 #define   FBC_CTL_FENCENO	(1<<0)
 #define FBC_COMMAND		0x0320c
@@ -405,6 +406,13 @@
 # define GPIO_DATA_VAL_IN		(1 << 12)
 # define GPIO_DATA_PULLUP_DISABLE	(1 << 13)
 
+#define GMBUS0			0x5100
+#define GMBUS1			0x5104
+#define GMBUS2			0x5108
+#define GMBUS3			0x510c
+#define GMBUS4			0x5110
+#define GMBUS5			0x5120
+
 /*
  * Clock control & power management
  */
@@ -863,14 +871,6 @@
 #define CRT_HOTPLUG_DETECT_VOLTAGE_475MV	(1 << 2)
 #define CRT_HOTPLUG_MASK			(0x3fc) /* Bits 9-2 */
 #define CRT_FORCE_HOTPLUG_MASK			0xfffffe1f
-#define HOTPLUG_EN_MASK (HDMIB_HOTPLUG_INT_EN | \
-			 HDMIC_HOTPLUG_INT_EN |	  \
-			 HDMID_HOTPLUG_INT_EN |	  \
-			 SDVOB_HOTPLUG_INT_EN |	  \
-			 SDVOC_HOTPLUG_INT_EN |	  \
-			 TV_HOTPLUG_INT_EN |	  \
-			 CRT_HOTPLUG_INT_EN)
-
 
 #define PORT_HOTPLUG_STAT	0x61114
 #define   HDMIB_HOTPLUG_INT_STATUS		(1 << 29)
@@ -968,6 +968,8 @@
 #define   LVDS_PORT_EN			(1 << 31)
 /* Selects pipe B for LVDS data.  Must be set on pre-965. */
 #define   LVDS_PIPEB_SELECT		(1 << 30)
+/* LVDS dithering flag on 965/g4x platform */
+#define   LVDS_ENABLE_DITHER		(1 << 25)
 /* Enable border for unscaled (or aspect-scaled) display */
 #define   LVDS_BORDER_ENABLE		(1 << 15)
 /*
@@ -1737,6 +1739,8 @@
 
 /* Display & cursor control */
 
+/* dithering flag on Ironlake */
+#define PIPE_ENABLE_DITHER	(1 << 4)
 /* Pipe A */
 #define PIPEADSL		0x70000
 #define PIPEACONF		0x70008
@@ -2157,6 +2161,13 @@
 #define PCH_GPIOE               0xc5020
 #define PCH_GPIOF               0xc5024
 
+#define PCH_GMBUS0		0xc5100
+#define PCH_GMBUS1		0xc5104
+#define PCH_GMBUS2		0xc5108
+#define PCH_GMBUS3		0xc510c
+#define PCH_GMBUS4		0xc5110
+#define PCH_GMBUS5		0xc5120
+
 #define PCH_DPLL_A              0xc6014
 #define PCH_DPLL_B              0xc6018
 
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/i915_suspend.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_suspend.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/i915_suspend.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/i915_suspend.c	2010-11-18 21:05:30.000000000 +0600
@@ -27,7 +27,7 @@
 #include "drmP.h"
 #include "drm.h"
 #include "i915_drm.h"
-#include "i915_drv.h"
+#include "intel_drv.h"
 
 static bool i915_pipe_enabled(struct drm_device *dev, enum pipe pipe)
 {
@@ -846,6 +846,9 @@
 	for (i = 0; i < 3; i++)
 		I915_WRITE(SWF30 + (i << 2), dev_priv->saveSWF2[i]);
 
+	/* I2C state */
+	intel_i2c_reset_gmbus(dev);
+
 	return 0;
 }
 
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/intel_crt.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_crt.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/intel_crt.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_crt.c	2010-11-18 21:05:30.000000000 +0600
@@ -185,6 +185,9 @@
 	adpa = I915_READ(PCH_ADPA);
 
 	adpa &= ~ADPA_CRT_HOTPLUG_MASK;
+	/* disable HPD first */
+	I915_WRITE(PCH_ADPA, adpa);
+	(void)I915_READ(PCH_ADPA);
 
 	adpa |= (ADPA_CRT_HOTPLUG_PERIOD_128 |
 			ADPA_CRT_HOTPLUG_WARMUP_10MS |
@@ -576,4 +579,6 @@
 	drm_connector_helper_add(connector, &intel_crt_connector_helper_funcs);
 
 	drm_sysfs_connector_add(connector);
+
+	dev_priv->hotplug_supported_mask |= CRT_HOTPLUG_INT_STATUS;
 }
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/intel_display.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_display.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/intel_display.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_display.c	2010-11-18 21:05:30.000000000 +0600
@@ -988,6 +988,8 @@
 
 	/* enable it... */
 	fbc_ctl = FBC_CTL_EN | FBC_CTL_PERIODIC;
+	if (IS_I945GM(dev))
+		fbc_ctl |= FBC_C3_IDLE; /* 945 needs special SR handling */
 	fbc_ctl |= (dev_priv->cfb_pitch & 0xff) << FBC_CTL_STRIDE_SHIFT;
 	fbc_ctl |= (interval & 0x2fff) << FBC_CTL_INTERVAL_SHIFT;
 	if (obj_priv->tiling_mode != I915_TILING_NONE)
@@ -1251,7 +1253,7 @@
 		return ret;
 	}
 
-	ret = i915_gem_object_set_to_gtt_domain(obj, 1);
+	ret = i915_gem_object_set_to_display_plane(obj);
 	if (ret != 0) {
 		i915_gem_object_unpin(obj);
 		mutex_unlock(&dev->struct_mutex);
@@ -1473,6 +1475,10 @@
 	int trans_vsync_reg = (pipe == 0) ? TRANS_VSYNC_A : TRANS_VSYNC_B;
 	u32 temp;
 	int tries = 5, j, n;
+	u32 pipe_bpc;
+
+	temp = I915_READ(pipeconf_reg);
+	pipe_bpc = temp & PIPE_BPC_MASK;
 
 	/* XXX: When our outputs are all unaware of DPMS modes other than off
 	 * and on, we should map those modes to DRM_MODE_DPMS_OFF in the CRTC.
@@ -1482,6 +1488,15 @@
 	case DRM_MODE_DPMS_STANDBY:
 	case DRM_MODE_DPMS_SUSPEND:
 		DRM_DEBUG("crtc %d dpms on\n", pipe);
+
+		if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {
+			temp = I915_READ(PCH_LVDS);
+			if ((temp & LVDS_PORT_EN) == 0) {
+				I915_WRITE(PCH_LVDS, temp | LVDS_PORT_EN);
+				POSTING_READ(PCH_LVDS);
+			}
+		}
+
 		if (HAS_eDP) {
 			/* enable eDP PLL */
 			igdng_enable_pll_edp(crtc);
@@ -1495,6 +1510,12 @@
 
 			/* enable PCH FDI RX PLL, wait warmup plus DMI latency */
 			temp = I915_READ(fdi_rx_reg);
+			/*
+			 * make the BPC in FDI Rx be consistent with that in
+			 * pipeconf reg.
+			 */
+			temp &= ~(0x7 << 16);
+			temp |= (pipe_bpc << 11);
 			I915_WRITE(fdi_rx_reg, temp | FDI_RX_PLL_ENABLE |
 					FDI_SEL_PCDCLK |
 					FDI_DP_PORT_WIDTH_X4); /* default 4 lanes */
@@ -1635,6 +1656,12 @@
 
 			/* enable PCH transcoder */
 			temp = I915_READ(transconf_reg);
+			/*
+			 * make the BPC in transcoder be consistent with
+			 * that in pipeconf reg.
+			 */
+			temp &= ~PIPE_BPC_MASK;
+			temp |= pipe_bpc;
 			I915_WRITE(transconf_reg, temp | TRANS_ENABLE);
 			I915_READ(transconf_reg);
 
@@ -1666,8 +1693,6 @@
 	case DRM_MODE_DPMS_OFF:
 		DRM_DEBUG("crtc %d dpms off\n", pipe);
 
-		i915_disable_vga(dev);
-
 		/* Disable display plane */
 		temp = I915_READ(dspcntr_reg);
 		if ((temp & DISPLAY_PLANE_ENABLE) != 0) {
@@ -1677,6 +1702,8 @@
 			I915_READ(dspbase_reg);
 		}
 
+		i915_disable_vga(dev);
+
 		/* disable cpu pipe, disable after all planes disabled */
 		temp = I915_READ(pipeconf_reg);
 		if ((temp & PIPEACONF_ENABLE) != 0) {
@@ -1697,9 +1724,15 @@
 		} else
 			DRM_DEBUG("crtc %d is disabled\n", pipe);
 
-		if (HAS_eDP) {
-			igdng_disable_pll_edp(crtc);
+		udelay(100);
+
+		/* Disable PF */
+		temp = I915_READ(pf_ctl_reg);
+		if ((temp & PF_ENABLE) != 0) {
+			I915_WRITE(pf_ctl_reg, temp & ~PF_ENABLE);
+			I915_READ(pf_ctl_reg);
 		}
+		I915_WRITE(pf_win_size, 0);
 
 		/* disable CPU FDI tx and PCH FDI rx */
 		temp = I915_READ(fdi_tx_reg);
@@ -1707,6 +1740,9 @@
 		I915_READ(fdi_tx_reg);
 
 		temp = I915_READ(fdi_rx_reg);
+		/* BPC in FDI rx is consistent with that in pipeconf */
+		temp &= ~(0x07 << 16);
+		temp |= (pipe_bpc << 11);
 		I915_WRITE(fdi_rx_reg, temp & ~FDI_RX_ENABLE);
 		I915_READ(fdi_rx_reg);
 
@@ -1725,6 +1761,13 @@
 
 		udelay(100);
 
+		if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {
+			temp = I915_READ(PCH_LVDS);
+			I915_WRITE(PCH_LVDS, temp & ~LVDS_PORT_EN);
+			I915_READ(PCH_LVDS);
+			udelay(100);
+		}
+
 		/* disable PCH transcoder */
 		temp = I915_READ(transconf_reg);
 		if ((temp & TRANS_ENABLE) != 0) {
@@ -1743,6 +1786,13 @@
 				}
 			}
 		}
+		temp = I915_READ(transconf_reg);
+		/* BPC in transcoder is consistent with that in pipeconf */
+		temp &= ~PIPE_BPC_MASK;
+		temp |= pipe_bpc;
+		I915_WRITE(transconf_reg, temp);
+		I915_READ(transconf_reg);
+		udelay(100);
 
 		/* disable PCH DPLL */
 		temp = I915_READ(pch_dpll_reg);
@@ -1751,14 +1801,20 @@
 			I915_READ(pch_dpll_reg);
 		}
 
-		temp = I915_READ(fdi_rx_reg);
-		if ((temp & FDI_RX_PLL_ENABLE) != 0) {
-			temp &= ~FDI_SEL_PCDCLK;
-			temp &= ~FDI_RX_PLL_ENABLE;
-			I915_WRITE(fdi_rx_reg, temp);
-			I915_READ(fdi_rx_reg);
+		if (HAS_eDP) {
+			igdng_disable_pll_edp(crtc);
 		}
 
+		temp = I915_READ(fdi_rx_reg);
+		temp &= ~FDI_SEL_PCDCLK;
+		I915_WRITE(fdi_rx_reg, temp);
+		I915_READ(fdi_rx_reg);
+
+		temp = I915_READ(fdi_rx_reg);
+		temp &= ~FDI_RX_PLL_ENABLE;
+		I915_WRITE(fdi_rx_reg, temp);
+		I915_READ(fdi_rx_reg);
+
 		/* Disable CPU FDI TX PLL */
 		temp = I915_READ(fdi_tx_reg);
 		if ((temp & FDI_TX_PLL_ENABLE) != 0) {
@@ -1767,16 +1823,8 @@
 			udelay(100);
 		}
 
-		/* Disable PF */
-		temp = I915_READ(pf_ctl_reg);
-		if ((temp & PF_ENABLE) != 0) {
-			I915_WRITE(pf_ctl_reg, temp & ~PF_ENABLE);
-			I915_READ(pf_ctl_reg);
-		}
-		I915_WRITE(pf_win_size, 0);
-
 		/* Wait for the clocks to turn off. */
-		udelay(150);
+		udelay(100);
 		break;
 	}
 }
@@ -1845,6 +1893,7 @@
 		intel_update_watermarks(dev);
 		/* Give the overlay scaler a chance to disable if it's on this pipe */
 		//intel_crtc_dpms_video(crtc, FALSE); TODO
+		drm_vblank_off(dev, pipe);
 
 		if (dev_priv->cfb_plane == plane &&
 		    dev_priv->display.disable_fbc)
@@ -2491,6 +2540,10 @@
 		sr_entries = roundup(sr_entries / cacheline_size, 1);
 		DRM_DEBUG("self-refresh entries: %d\n", sr_entries);
 		I915_WRITE(FW_BLC_SELF, FW_BLC_SELF_EN);
+	} else {
+		/* Turn off self refresh if both pipes are enabled */
+		I915_WRITE(FW_BLC_SELF, I915_READ(FW_BLC_SELF)
+					& ~FW_BLC_SELF_EN);
 	}
 
 	DRM_DEBUG("Setting FIFO watermarks - A: %d, B: %d, SR %d\n",
@@ -2509,15 +2562,43 @@
 		   (cursor_sr << DSPFW_CURSOR_SR_SHIFT));
 }
 
-static void i965_update_wm(struct drm_device *dev, int unused, int unused2,
-			   int unused3, int unused4)
+static void i965_update_wm(struct drm_device *dev, int planea_clock,
+			   int planeb_clock, int sr_hdisplay, int pixel_size)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
+	unsigned long line_time_us;
+	int sr_clock, sr_entries, srwm = 1;
 
-	DRM_DEBUG("Setting FIFO watermarks - A: 8, B: 8, C: 8, SR 8\n");
+	/* Calc sr entries for one plane configs */
+	if (sr_hdisplay && (!planea_clock || !planeb_clock)) {
+		/* self-refresh has much higher latency */
+		const static int sr_latency_ns = 12000;
+
+		sr_clock = planea_clock ? planea_clock : planeb_clock;
+		line_time_us = ((sr_hdisplay * 1000) / sr_clock);
+
+		/* Use ns/us then divide to preserve precision */
+		sr_entries = (((sr_latency_ns / line_time_us) + 1) *
+			      pixel_size * sr_hdisplay) / 1000;
+		sr_entries = roundup(sr_entries / I915_FIFO_LINE_SIZE, 1);
+		DRM_DEBUG("self-refresh entries: %d\n", sr_entries);
+		srwm = I945_FIFO_SIZE - sr_entries;
+		if (srwm < 0)
+			srwm = 1;
+		srwm &= 0x3f;
+		I915_WRITE(FW_BLC_SELF, FW_BLC_SELF_EN);
+	} else {
+		/* Turn off self refresh if both pipes are enabled */
+		I915_WRITE(FW_BLC_SELF, I915_READ(FW_BLC_SELF)
+					& ~FW_BLC_SELF_EN);
+	}
+
+	DRM_DEBUG_KMS("Setting FIFO watermarks - A: 8, B: 8, C: 8, SR %d\n",
+		      srwm);
 
 	/* 965 has limitations... */
-	I915_WRITE(DSPFW1, (8 << 16) | (8 << 8) | (8 << 0));
+	I915_WRITE(DSPFW1, (srwm << DSPFW_SR_SHIFT) | (8 << 16) | (8 << 8) |
+		   (8 << 0));
 	I915_WRITE(DSPFW2, (8 << 8) | (8 << 0));
 }
 
@@ -2578,6 +2659,10 @@
 		if (srwm < 0)
 			srwm = 1;
 		I915_WRITE(FW_BLC_SELF, FW_BLC_SELF_EN | (srwm & 0x3f));
+	} else {
+		/* Turn off self refresh if both pipes are enabled */
+		I915_WRITE(FW_BLC_SELF, I915_READ(FW_BLC_SELF)
+					& ~FW_BLC_SELF_EN);
 	}
 
 	DRM_DEBUG("Setting FIFO watermarks - A: %d, B: %d, C: %d, SR %d\n",
@@ -2854,6 +2939,18 @@
 
 		/* determine panel color depth */
 		temp = I915_READ(pipeconf_reg);
+		temp &= ~PIPE_BPC_MASK;
+		if (is_lvds) {
+			int lvds_reg = I915_READ(PCH_LVDS);
+			/* the BPC will be 6 if it is 18-bit LVDS panel */
+			if ((lvds_reg & LVDS_A3_POWER_MASK) == LVDS_A3_POWER_UP)
+				temp |= PIPE_8BPC;
+			else
+				temp |= PIPE_6BPC;
+		} else
+			temp |= PIPE_8BPC;
+		I915_WRITE(pipeconf_reg, temp);
+		I915_READ(pipeconf_reg);
 
 		switch (temp & PIPE_BPC_MASK) {
 		case PIPE_8BPC:
@@ -3081,7 +3178,20 @@
 		 * appropriately here, but we need to look more thoroughly into how
 		 * panels behave in the two modes.
 		 */
-
+		/* set the dithering flag */
+		if (IS_I965G(dev)) {
+			if (dev_priv->lvds_dither) {
+				if (IS_IGDNG(dev))
+					pipeconf |= PIPE_ENABLE_DITHER;
+				else
+					lvds |= LVDS_ENABLE_DITHER;
+			} else {
+				if (IS_IGDNG(dev))
+					pipeconf &= ~PIPE_ENABLE_DITHER;
+				else
+					lvds &= ~LVDS_ENABLE_DITHER;
+			}
+		}
 		I915_WRITE(lvds_reg, lvds);
 		I915_READ(lvds_reg);
 	}
@@ -3665,125 +3775,6 @@
 	queue_work(dev_priv->wq, &dev_priv->idle_work);
 }
 
-void intel_increase_renderclock(struct drm_device *dev, bool schedule)
-{
-	drm_i915_private_t *dev_priv = dev->dev_private;
-
-	if (IS_IGDNG(dev))
-		return;
-
-	if (!dev_priv->render_reclock_avail) {
-		DRM_DEBUG("not reclocking render clock\n");
-		return;
-	}
-
-	/* Restore render clock frequency to original value */
-	if (IS_G4X(dev) || IS_I9XX(dev))
-		pci_write_config_word(dev->pdev, GCFGC, dev_priv->orig_clock);
-	else if (IS_I85X(dev))
-		pci_write_config_word(dev->pdev, HPLLCC, dev_priv->orig_clock);
-	DRM_DEBUG("increasing render clock frequency\n");
-
-	/* Schedule downclock */
-	if (schedule)
-		mod_timer(&dev_priv->idle_timer, jiffies +
-			  msecs_to_jiffies(GPU_IDLE_TIMEOUT));
-}
-
-void intel_decrease_renderclock(struct drm_device *dev)
-{
-	drm_i915_private_t *dev_priv = dev->dev_private;
-
-	if (IS_IGDNG(dev))
-		return;
-
-	if (!dev_priv->render_reclock_avail) {
-		DRM_DEBUG("not reclocking render clock\n");
-		return;
-	}
-
-	if (IS_G4X(dev)) {
-		u16 gcfgc;
-
-		/* Adjust render clock... */
-		pci_read_config_word(dev->pdev, GCFGC, &gcfgc);
-
-		/* Down to minimum... */
-		gcfgc &= ~GM45_GC_RENDER_CLOCK_MASK;
-		gcfgc |= GM45_GC_RENDER_CLOCK_266_MHZ;
-
-		pci_write_config_word(dev->pdev, GCFGC, gcfgc);
-	} else if (IS_I965G(dev)) {
-		u16 gcfgc;
-
-		/* Adjust render clock... */
-		pci_read_config_word(dev->pdev, GCFGC, &gcfgc);
-
-		/* Down to minimum... */
-		gcfgc &= ~I965_GC_RENDER_CLOCK_MASK;
-		gcfgc |= I965_GC_RENDER_CLOCK_267_MHZ;
-
-		pci_write_config_word(dev->pdev, GCFGC, gcfgc);
-	} else if (IS_I945G(dev) || IS_I945GM(dev)) {
-		u16 gcfgc;
-
-		/* Adjust render clock... */
-		pci_read_config_word(dev->pdev, GCFGC, &gcfgc);
-
-		/* Down to minimum... */
-		gcfgc &= ~I945_GC_RENDER_CLOCK_MASK;
-		gcfgc |= I945_GC_RENDER_CLOCK_166_MHZ;
-
-		pci_write_config_word(dev->pdev, GCFGC, gcfgc);
-	} else if (IS_I915G(dev)) {
-		u16 gcfgc;
-
-		/* Adjust render clock... */
-		pci_read_config_word(dev->pdev, GCFGC, &gcfgc);
-
-		/* Down to minimum... */
-		gcfgc &= ~I915_GC_RENDER_CLOCK_MASK;
-		gcfgc |= I915_GC_RENDER_CLOCK_166_MHZ;
-
-		pci_write_config_word(dev->pdev, GCFGC, gcfgc);
-	} else if (IS_I85X(dev)) {
-		u16 hpllcc;
-
-		/* Adjust render clock... */
-		pci_read_config_word(dev->pdev, HPLLCC, &hpllcc);
-
-		/* Up to maximum... */
-		hpllcc &= ~GC_CLOCK_CONTROL_MASK;
-		hpllcc |= GC_CLOCK_133_200;
-
-		pci_write_config_word(dev->pdev, HPLLCC, hpllcc);
-	}
-	DRM_DEBUG("decreasing render clock frequency\n");
-}
-
-/* Note that no increase function is needed for this - increase_renderclock()
- *  will also rewrite these bits
- */
-void intel_decrease_displayclock(struct drm_device *dev)
-{
-	if (IS_IGDNG(dev))
-		return;
-
-	if (IS_I945G(dev) || IS_I945GM(dev) || IS_I915G(dev) ||
-	    IS_I915GM(dev)) {
-		u16 gcfgc;
-
-		/* Adjust render clock... */
-		pci_read_config_word(dev->pdev, GCFGC, &gcfgc);
-
-		/* Down to minimum... */
-		gcfgc &= ~0xf0;
-		gcfgc |= 0x80;
-
-		pci_write_config_word(dev->pdev, GCFGC, gcfgc);
-	}
-}
-
 #define CRTC_IDLE_TIMEOUT 1000 /* ms */
 
 static void intel_crtc_idle_timer(unsigned long arg)
@@ -3897,12 +3888,6 @@
 
 	mutex_lock(&dev->struct_mutex);
 
-	/* GPU isn't processing, downclock it. */
-	if (!dev_priv->busy) {
-		intel_decrease_renderclock(dev);
-		intel_decrease_displayclock(dev);
-	}
-
 	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
 		/* Skip inactive CRTCs */
 		if (!crtc->fb)
@@ -3937,7 +3922,6 @@
 		return;
 
 	dev_priv->busy = true;
-	intel_increase_renderclock(dev, true);
 
 	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
 		if (!crtc->fb)
@@ -4118,37 +4102,51 @@
 		if (I915_READ(PCH_DP_D) & DP_DETECTED)
 			intel_dp_init(dev, PCH_DP_D);
 
-	} else if (IS_I9XX(dev)) {
+	} else if (SUPPORTS_DIGITAL_OUTPUTS(dev)) {
 		bool found = false;
 
 		if (I915_READ(SDVOB) & SDVO_DETECTED) {
+			DRM_DEBUG_KMS("probing SDVOB\n");
 			found = intel_sdvo_init(dev, SDVOB);
-			if (!found && SUPPORTS_INTEGRATED_HDMI(dev))
+			if (!found && SUPPORTS_INTEGRATED_HDMI(dev)) {
+				DRM_DEBUG_KMS("probing HDMI on SDVOB\n");
 				intel_hdmi_init(dev, SDVOB);
+			}
 
-			if (!found && SUPPORTS_INTEGRATED_DP(dev))
+			if (!found && SUPPORTS_INTEGRATED_DP(dev)) {
+				DRM_DEBUG_KMS("probing DP_B\n");
 				intel_dp_init(dev, DP_B);
+			}
 		}
 
 		/* Before G4X SDVOC doesn't have its own detect register */
 
-		if (I915_READ(SDVOB) & SDVO_DETECTED)
+		if (I915_READ(SDVOB) & SDVO_DETECTED) {
+			DRM_DEBUG_KMS("probing SDVOC\n");
 			found = intel_sdvo_init(dev, SDVOC);
+		}
 
 		if (!found && (I915_READ(SDVOC) & SDVO_DETECTED)) {
 
-			if (SUPPORTS_INTEGRATED_HDMI(dev))
+			if (SUPPORTS_INTEGRATED_HDMI(dev)) {
+				DRM_DEBUG_KMS("probing HDMI on SDVOC\n");
 				intel_hdmi_init(dev, SDVOC);
-			if (SUPPORTS_INTEGRATED_DP(dev))
+			}
+			if (SUPPORTS_INTEGRATED_DP(dev)) {
+				DRM_DEBUG_KMS("probing DP_C\n");
 				intel_dp_init(dev, DP_C);
+			}
 		}
 
-		if (SUPPORTS_INTEGRATED_DP(dev) && (I915_READ(DP_D) & DP_DETECTED))
+		if (SUPPORTS_INTEGRATED_DP(dev) &&
+		    (I915_READ(DP_D) & DP_DETECTED)) {
+			DRM_DEBUG_KMS("probing DP_D\n");
 			intel_dp_init(dev, DP_D);
-	} else
+		}
+	} else if (IS_I8XX(dev))
 		intel_dvo_init(dev);
 
-	if (IS_I9XX(dev) && IS_MOBILE(dev) && !IS_IGDNG(dev))
+	if (SUPPORTS_TV(dev))
 		intel_tv_init(dev);
 
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
@@ -4442,7 +4440,6 @@
 		del_timer_sync(&intel_crtc->idle_timer);
 	}
 
-	intel_increase_renderclock(dev, false);
 	del_timer_sync(&dev_priv->idle_timer);
 
 	mutex_unlock(&dev->struct_mutex);
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/intel_dp.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_dp.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/intel_dp.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_dp.c	2010-11-18 21:05:30.000000000 +0600
@@ -1254,11 +1254,11 @@
 	else
 		intel_output->type = INTEL_OUTPUT_DISPLAYPORT;
 
-	if (output_reg == DP_B)
+	if (output_reg == DP_B || output_reg == PCH_DP_B)
 		intel_output->clone_mask = (1 << INTEL_DP_B_CLONE_BIT);
-	else if (output_reg == DP_C)
+	else if (output_reg == DP_C || output_reg == PCH_DP_C)
 		intel_output->clone_mask = (1 << INTEL_DP_C_CLONE_BIT);
-	else if (output_reg == DP_D)
+	else if (output_reg == DP_D || output_reg == PCH_DP_D)
 		intel_output->clone_mask = (1 << INTEL_DP_D_CLONE_BIT);
 
 	if (IS_eDP(intel_output)) {
@@ -1290,14 +1290,20 @@
 			break;
 		case DP_B:
 		case PCH_DP_B:
+			dev_priv->hotplug_supported_mask |=
+				HDMIB_HOTPLUG_INT_STATUS;
 			name = "DPDDC-B";
 			break;
 		case DP_C:
 		case PCH_DP_C:
+			dev_priv->hotplug_supported_mask |=
+				HDMIC_HOTPLUG_INT_STATUS;
 			name = "DPDDC-C";
 			break;
 		case DP_D:
 		case PCH_DP_D:
+			dev_priv->hotplug_supported_mask |=
+				HDMID_HOTPLUG_INT_STATUS;
 			name = "DPDDC-D";
 			break;
 	}
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/intel_drv.h iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_drv.h
--- linux-2.6.32-orig/drivers/gpu/drm/i915/intel_drv.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_drv.h	2010-11-18 21:05:30.000000000 +0600
@@ -134,6 +134,8 @@
 int intel_ddc_get_modes(struct intel_output *intel_output);
 extern bool intel_ddc_probe(struct intel_output *intel_output);
 void intel_i2c_quirk_set(struct drm_device *dev, bool enable);
+void intel_i2c_reset_gmbus(struct drm_device *dev);
+
 extern void intel_crt_init(struct drm_device *dev);
 extern void intel_hdmi_init(struct drm_device *dev, int sdvox_reg);
 extern bool intel_sdvo_init(struct drm_device *dev, int output_device);
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/intel_fb.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_fb.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/intel_fb.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_fb.c	2010-11-18 21:05:30.000000000 +0600
@@ -148,7 +148,7 @@
 
 	mutex_lock(&dev->struct_mutex);
 
-	ret = i915_gem_object_pin(fbo, PAGE_SIZE);
+	ret = i915_gem_object_pin(fbo, 64*1024);
 	if (ret) {
 		DRM_ERROR("failed to pin fb: %d\n", ret);
 		goto out_unref;
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/intel_hdmi.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_hdmi.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/intel_hdmi.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_hdmi.c	2010-11-18 21:05:30.000000000 +0600
@@ -254,21 +254,26 @@
 	if (sdvox_reg == SDVOB) {
 		intel_output->clone_mask = (1 << INTEL_HDMIB_CLONE_BIT);
 		intel_output->ddc_bus = intel_i2c_create(dev, GPIOE, "HDMIB");
+		dev_priv->hotplug_supported_mask |= HDMIB_HOTPLUG_INT_STATUS;
 	} else if (sdvox_reg == SDVOC) {
 		intel_output->clone_mask = (1 << INTEL_HDMIC_CLONE_BIT);
 		intel_output->ddc_bus = intel_i2c_create(dev, GPIOD, "HDMIC");
+		dev_priv->hotplug_supported_mask |= HDMIC_HOTPLUG_INT_STATUS;
 	} else if (sdvox_reg == HDMIB) {
 		intel_output->clone_mask = (1 << INTEL_HDMID_CLONE_BIT);
 		intel_output->ddc_bus = intel_i2c_create(dev, PCH_GPIOE,
 								"HDMIB");
+		dev_priv->hotplug_supported_mask |= HDMIB_HOTPLUG_INT_STATUS;
 	} else if (sdvox_reg == HDMIC) {
 		intel_output->clone_mask = (1 << INTEL_HDMIE_CLONE_BIT);
 		intel_output->ddc_bus = intel_i2c_create(dev, PCH_GPIOD,
 								"HDMIC");
+		dev_priv->hotplug_supported_mask |= HDMIC_HOTPLUG_INT_STATUS;
 	} else if (sdvox_reg == HDMID) {
 		intel_output->clone_mask = (1 << INTEL_HDMIF_CLONE_BIT);
 		intel_output->ddc_bus = intel_i2c_create(dev, PCH_GPIOF,
 								"HDMID");
+		dev_priv->hotplug_supported_mask |= HDMID_HOTPLUG_INT_STATUS;
 	}
 	if (!intel_output->ddc_bus)
 		goto err_connector;
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/intel_i2c.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_i2c.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/intel_i2c.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_i2c.c	2010-11-18 21:05:30.000000000 +0600
@@ -118,6 +118,23 @@
 	udelay(I2C_RISEFALL_TIME); /* wait for the line to change state */
 }
 
+/* Clears the GMBUS setup.  Our driver doesn't make use of the GMBUS I2C
+ * engine, but if the BIOS leaves it enabled, then that can break our use
+ * of the bit-banging I2C interfaces.  This is notably the case with the
+ * Mac Mini in EFI mode.
+ */
+void
+intel_i2c_reset_gmbus(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
+	if (IS_IGDNG(dev)) {
+		I915_WRITE(PCH_GMBUS0, 0);
+	} else {
+		I915_WRITE(GMBUS0, 0);
+	}
+}
+
 /**
  * intel_i2c_create - instantiate an Intel i2c bus using the specified GPIO reg
  * @dev: DRM device
@@ -168,6 +185,8 @@
 	if(i2c_bit_add_bus(&chan->adapter))
 		goto out_free;
 
+	intel_i2c_reset_gmbus(dev);
+
 	/* JJJ:  raise SCL and SDA? */
 	intel_i2c_quirk_set(dev, true);
 	set_data(chan, 1);
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/intel_lvds.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_lvds.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/intel_lvds.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_lvds.c	2010-11-18 21:05:30.000000000 +0600
@@ -602,12 +602,33 @@
 /* Some lid devices report incorrect lid status, assume they're connected */
 static const struct dmi_system_id bad_lid_status[] = {
 	{
+		.ident = "Compaq nx9020",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+			DMI_MATCH(DMI_BOARD_NAME, "3084"),
+		},
+	},
+	{
+		.ident = "Samsung SX20S",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Samsung Electronics"),
+			DMI_MATCH(DMI_BOARD_NAME, "SX20S"),
+		},
+	},
+	{
 		.ident = "Aspire One",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire one"),
 		},
 	},
+	{
+		.ident = "PC-81005",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "MALATA"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "PC-81005"),
+		},
+	},
 	{ }
 };
 
@@ -679,7 +700,14 @@
 	struct drm_i915_private *dev_priv =
 		container_of(nb, struct drm_i915_private, lid_notifier);
 	struct drm_device *dev = dev_priv->dev;
+	struct drm_connector *connector = dev_priv->int_lvds_connector;
 
+	/*
+	 * check and update the status of LVDS connector after receiving
+	 * the LID nofication event.
+	 */
+	if (connector)
+		connector->status = connector->funcs->detect(connector);
 	if (!acpi_lid_open()) {
 		dev_priv->modeset_on_lid = 1;
 		return NOTIFY_OK;
@@ -1085,6 +1113,8 @@
 		DRM_DEBUG("lid notifier registration failed\n");
 		dev_priv->lid_notifier.notifier_call = NULL;
 	}
+	/* keep the LVDS connector */
+	dev_priv->int_lvds_connector = connector;
 	drm_sysfs_connector_add(connector);
 	return;
 
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/intel_sdvo.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_sdvo.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/intel_sdvo.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_sdvo.c	2010-11-18 21:05:30.000000000 +0600
@@ -472,14 +472,63 @@
 }
 
 /**
- * Don't check status code from this as it switches the bus back to the
- * SDVO chips which defeats the purpose of doing a bus switch in the first
- * place.
+ * Try to read the response after issuie the DDC switch command. But it
+ * is noted that we must do the action of reading response and issuing DDC
+ * switch command in one I2C transaction. Otherwise when we try to start
+ * another I2C transaction after issuing the DDC bus switch, it will be
+ * switched to the internal SDVO register.
  */
 static void intel_sdvo_set_control_bus_switch(struct intel_output *intel_output,
 					      u8 target)
 {
-	intel_sdvo_write_cmd(intel_output, SDVO_CMD_SET_CONTROL_BUS_SWITCH, &target, 1);
+	struct intel_sdvo_priv *sdvo_priv = intel_output->dev_priv;
+	u8 out_buf[2], cmd_buf[2], ret_value[2], ret;
+	struct i2c_msg msgs[] = {
+		{
+			.addr = sdvo_priv->slave_addr >> 1,
+			.flags = 0,
+			.len = 2,
+			.buf = out_buf,
+		},
+		/* the following two are to read the response */
+		{
+			.addr = sdvo_priv->slave_addr >> 1,
+			.flags = 0,
+			.len = 1,
+			.buf = cmd_buf,
+		},
+		{
+			.addr = sdvo_priv->slave_addr >> 1,
+			.flags = I2C_M_RD,
+			.len = 1,
+			.buf = ret_value,
+		},
+	};
+
+	intel_sdvo_debug_write(intel_output, SDVO_CMD_SET_CONTROL_BUS_SWITCH,
+					&target, 1);
+	/* write the DDC switch command argument */
+	intel_sdvo_write_byte(intel_output, SDVO_I2C_ARG_0, target);
+
+	out_buf[0] = SDVO_I2C_OPCODE;
+	out_buf[1] = SDVO_CMD_SET_CONTROL_BUS_SWITCH;
+	cmd_buf[0] = SDVO_I2C_CMD_STATUS;
+	cmd_buf[1] = 0;
+	ret_value[0] = 0;
+	ret_value[1] = 0;
+
+	ret = i2c_transfer(intel_output->i2c_bus, msgs, 3);
+	if (ret != 3) {
+		/* failure in I2C transfer */
+		DRM_DEBUG_KMS("I2c transfer returned %d\n", ret);
+		return;
+	}
+	if (ret_value[0] != SDVO_CMD_STATUS_SUCCESS) {
+		DRM_DEBUG_KMS("DDC switch command returns response %d\n",
+					ret_value[0]);
+		return;
+	}
+	return;
 }
 
 static bool intel_sdvo_set_target_input(struct intel_output *intel_output, bool target_0, bool target_1)
@@ -1589,6 +1638,32 @@
 	edid = drm_get_edid(&intel_output->base,
 			    intel_output->ddc_bus);
 
+	/* This is only applied to SDVO cards with multiple outputs */
+	if (edid == NULL && intel_sdvo_multifunc_encoder(intel_output)) {
+		uint8_t saved_ddc, temp_ddc;
+		saved_ddc = sdvo_priv->ddc_bus;
+		temp_ddc = sdvo_priv->ddc_bus >> 1;
+		/*
+		 * Don't use the 1 as the argument of DDC bus switch to get
+		 * the EDID. It is used for SDVO SPD ROM.
+		 */
+		while(temp_ddc > 1) {
+			sdvo_priv->ddc_bus = temp_ddc;
+			edid = drm_get_edid(&intel_output->base,
+				intel_output->ddc_bus);
+			if (edid) {
+				/*
+				 * When we can get the EDID, maybe it is the
+				 * correct DDC bus. Update it.
+				 */
+				sdvo_priv->ddc_bus = temp_ddc;
+				break;
+			}
+			temp_ddc >>= 1;
+		}
+		if (edid == NULL)
+			sdvo_priv->ddc_bus = saved_ddc;
+	}
 	/* when there is no edid and no monitor is connected with VGA
 	 * port, try to use the CRT ddc to read the EDID for DVI-connector
 	 */
@@ -2668,6 +2743,7 @@
 
 bool intel_sdvo_init(struct drm_device *dev, int output_device)
 {
+	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct drm_connector *connector;
 	struct intel_output *intel_output;
 	struct intel_sdvo_priv *sdvo_priv;
@@ -2714,10 +2790,12 @@
 		intel_output->ddc_bus = intel_i2c_create(dev, GPIOE, "SDVOB DDC BUS");
 		sdvo_priv->analog_ddc_bus = intel_i2c_create(dev, GPIOA,
 						"SDVOB/VGA DDC BUS");
+		dev_priv->hotplug_supported_mask |= SDVOB_HOTPLUG_INT_STATUS;
 	} else {
 		intel_output->ddc_bus = intel_i2c_create(dev, GPIOE, "SDVOC DDC BUS");
 		sdvo_priv->analog_ddc_bus = intel_i2c_create(dev, GPIOA,
 						"SDVOC/VGA DDC BUS");
+		dev_priv->hotplug_supported_mask |= SDVOC_HOTPLUG_INT_STATUS;
 	}
 
 	if (intel_output->ddc_bus == NULL)
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/i915/intel_tv.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_tv.c
--- linux-2.6.32-orig/drivers/gpu/drm/i915/intel_tv.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/i915/intel_tv.c	2010-11-18 21:05:30.000000000 +0600
@@ -1213,20 +1213,17 @@
 		tv_ctl |= TV_TRILEVEL_SYNC;
 	if (tv_mode->pal_burst)
 		tv_ctl |= TV_PAL_BURST;
+
 	scctl1 = 0;
-	/* dda1 implies valid video levels */
-	if (tv_mode->dda1_inc) {
+	if (tv_mode->dda1_inc)
 		scctl1 |= TV_SC_DDA1_EN;
-	}
-
 	if (tv_mode->dda2_inc)
 		scctl1 |= TV_SC_DDA2_EN;
-
 	if (tv_mode->dda3_inc)
 		scctl1 |= TV_SC_DDA3_EN;
-
 	scctl1 |= tv_mode->sc_reset;
-	scctl1 |= video_levels->burst << TV_BURST_LEVEL_SHIFT;
+	if (video_levels)
+		scctl1 |= video_levels->burst << TV_BURST_LEVEL_SHIFT;
 	scctl1 |= tv_mode->dda1_inc << TV_SCDDA1_INC_SHIFT;
 
 	scctl2 = tv_mode->dda2_size << TV_SCDDA2_SIZE_SHIFT |
@@ -1804,6 +1801,8 @@
 	drm_connector_attach_property(connector,
 				   dev->mode_config.tv_bottom_margin_property,
 				   tv_priv->margin[TV_MARGIN_BOTTOM]);
+
+	dev_priv->hotplug_supported_mask |= TV_HOTPLUG_INT_STATUS;
 out:
 	drm_sysfs_connector_add(connector);
 }
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/radeon/atombios_crtc.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/atombios_crtc.c
--- linux-2.6.32-orig/drivers/gpu/drm/radeon/atombios_crtc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/atombios_crtc.c	2010-11-18 21:05:30.000000000 +0600
@@ -241,6 +241,7 @@
 {
 	struct drm_device *dev = crtc->dev;
 	struct radeon_device *rdev = dev->dev_private;
+	struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);
 
 	switch (mode) {
 	case DRM_MODE_DPMS_ON:
@@ -248,20 +249,21 @@
 		if (ASIC_IS_DCE3(rdev))
 			atombios_enable_crtc_memreq(crtc, 1);
 		atombios_blank_crtc(crtc, 0);
+		if (rdev->family < CHIP_R600)
+			drm_vblank_post_modeset(dev, radeon_crtc->crtc_id);
+		radeon_crtc_load_lut(crtc);
 		break;
 	case DRM_MODE_DPMS_STANDBY:
 	case DRM_MODE_DPMS_SUSPEND:
 	case DRM_MODE_DPMS_OFF:
+		if (rdev->family < CHIP_R600)
+			drm_vblank_pre_modeset(dev, radeon_crtc->crtc_id);
 		atombios_blank_crtc(crtc, 1);
 		if (ASIC_IS_DCE3(rdev))
 			atombios_enable_crtc_memreq(crtc, 0);
 		atombios_enable_crtc(crtc, 0);
 		break;
 	}
-
-	if (mode != DRM_MODE_DPMS_OFF) {
-		radeon_crtc_load_lut(crtc);
-	}
 }
 
 static void
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/radeon/atom.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/atom.c
--- linux-2.6.32-orig/drivers/gpu/drm/radeon/atom.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/atom.c	2010-11-18 21:05:30.000000000 +0600
@@ -607,7 +607,7 @@
 	uint8_t count = U8((*ptr)++);
 	SDEBUG("   count: %d\n", count);
 	if (arg == ATOM_UNIT_MICROSEC)
-		schedule_timeout_uninterruptible(usecs_to_jiffies(count));
+		udelay(count);
 	else
 		schedule_timeout_uninterruptible(msecs_to_jiffies(count));
 }
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/radeon/radeon_atombios.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/radeon_atombios.c
--- linux-2.6.32-orig/drivers/gpu/drm/radeon/radeon_atombios.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/radeon_atombios.c	2010-11-18 21:05:30.000000000 +0600
@@ -135,6 +135,14 @@
 		}
 	}
 
+	/* HIS X1300 is DVI+VGA, not DVI+DVI */
+	if ((dev->pdev->device == 0x7146) &&
+	    (dev->pdev->subsystem_vendor == 0x17af) &&
+	    (dev->pdev->subsystem_device == 0x2058)) {
+		if (supported_device == ATOM_DEVICE_DFP1_SUPPORT)
+			return false;
+	}
+
 	/* Funky macbooks */
 	if ((dev->pdev->device == 0x71C5) &&
 	    (dev->pdev->subsystem_vendor == 0x106b) &&
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/radeon/radeon_legacy_crtc.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/radeon_legacy_crtc.c
--- linux-2.6.32-orig/drivers/gpu/drm/radeon/radeon_legacy_crtc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/radeon_legacy_crtc.c	2010-11-18 21:05:30.000000000 +0600
@@ -292,8 +292,7 @@
 	uint32_t mask;
 
 	if (radeon_crtc->crtc_id)
-		mask = (RADEON_CRTC2_EN |
-			RADEON_CRTC2_DISP_DIS |
+		mask = (RADEON_CRTC2_DISP_DIS |
 			RADEON_CRTC2_VSYNC_DIS |
 			RADEON_CRTC2_HSYNC_DIS |
 			RADEON_CRTC2_DISP_REQ_EN_B);
@@ -305,7 +304,7 @@
 	switch (mode) {
 	case DRM_MODE_DPMS_ON:
 		if (radeon_crtc->crtc_id)
-			WREG32_P(RADEON_CRTC2_GEN_CNTL, RADEON_CRTC2_EN, ~mask);
+			WREG32_P(RADEON_CRTC2_GEN_CNTL, RADEON_CRTC2_EN, ~(RADEON_CRTC2_EN | mask));
 		else {
 			WREG32_P(RADEON_CRTC_GEN_CNTL, RADEON_CRTC_EN, ~(RADEON_CRTC_EN |
 									 RADEON_CRTC_DISP_REQ_EN_B));
@@ -319,7 +318,7 @@
 	case DRM_MODE_DPMS_OFF:
 		drm_vblank_pre_modeset(dev, radeon_crtc->crtc_id);
 		if (radeon_crtc->crtc_id)
-			WREG32_P(RADEON_CRTC2_GEN_CNTL, mask, ~mask);
+			WREG32_P(RADEON_CRTC2_GEN_CNTL, mask, ~(RADEON_CRTC2_EN | mask));
 		else {
 			WREG32_P(RADEON_CRTC_GEN_CNTL, RADEON_CRTC_DISP_REQ_EN_B, ~(RADEON_CRTC_EN |
 										    RADEON_CRTC_DISP_REQ_EN_B));
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/radeon/radeon_test.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/radeon_test.c
--- linux-2.6.32-orig/drivers/gpu/drm/radeon/radeon_test.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/radeon_test.c	2010-11-18 21:05:30.000000000 +0600
@@ -42,8 +42,8 @@
 	/* Number of tests =
 	 * (Total GTT - IB pool - writeback page - ring buffer) / test size
 	 */
-	n = (rdev->mc.gtt_size - RADEON_IB_POOL_SIZE*64*1024 - RADEON_GPU_PAGE_SIZE -
-	     rdev->cp.ring_size) / size;
+	n = ((u32)(rdev->mc.gtt_size - RADEON_IB_POOL_SIZE*64*1024 - RADEON_GPU_PAGE_SIZE -
+	     rdev->cp.ring_size)) / size;
 
 	gtt_obj = kzalloc(n * sizeof(*gtt_obj), GFP_KERNEL);
 	if (!gtt_obj) {
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/radeon/rs600.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/rs600.c
--- linux-2.6.32-orig/drivers/gpu/drm/radeon/rs600.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/rs600.c	2010-11-18 21:05:30.000000000 +0600
@@ -301,9 +301,7 @@
 
 void rs600_gpu_init(struct radeon_device *rdev)
 {
-	/* FIXME: HDP same place on rs600 ? */
 	r100_hdp_reset(rdev);
-	/* FIXME: is this correct ? */
 	r420_pipes_init(rdev);
 	/* Wait for mc idle */
 	if (rs600_mc_wait_for_idle(rdev))
@@ -312,9 +310,20 @@
 
 void rs600_vram_info(struct radeon_device *rdev)
 {
-	/* FIXME: to do or is these values sane ? */
 	rdev->mc.vram_is_ddr = true;
 	rdev->mc.vram_width = 128;
+
+	rdev->mc.real_vram_size = RREG32(RADEON_CONFIG_MEMSIZE);
+	rdev->mc.mc_vram_size = rdev->mc.real_vram_size;
+
+	rdev->mc.aper_base = drm_get_resource_start(rdev->ddev, 0);
+	rdev->mc.aper_size = drm_get_resource_len(rdev->ddev, 0);
+
+	if (rdev->mc.mc_vram_size > rdev->mc.aper_size)
+		rdev->mc.mc_vram_size = rdev->mc.aper_size;
+
+	if (rdev->mc.real_vram_size > rdev->mc.aper_size)
+		rdev->mc.real_vram_size = rdev->mc.aper_size;
 }
 
 void rs600_bandwidth_update(struct radeon_device *rdev)
diff -Nur linux-2.6.32-orig/drivers/gpu/drm/radeon/rs690.c iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/rs690.c
--- linux-2.6.32-orig/drivers/gpu/drm/radeon/rs690.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/gpu/drm/radeon/rs690.c	2010-11-18 21:05:30.000000000 +0600
@@ -131,24 +131,25 @@
 
 void rs690_vram_info(struct radeon_device *rdev)
 {
-	uint32_t tmp;
 	fixed20_12 a;
 
 	rs400_gart_adjust_size(rdev);
-	/* DDR for all card after R300 & IGP */
+
 	rdev->mc.vram_is_ddr = true;
-	/* FIXME: is this correct for RS690/RS740 ? */
-	tmp = RREG32(RADEON_MEM_CNTL);
-	if (tmp & R300_MEM_NUM_CHANNELS_MASK) {
-		rdev->mc.vram_width = 128;
-	} else {
-		rdev->mc.vram_width = 64;
-	}
+	rdev->mc.vram_width = 128;
+
 	rdev->mc.real_vram_size = RREG32(RADEON_CONFIG_MEMSIZE);
 	rdev->mc.mc_vram_size = rdev->mc.real_vram_size;
 
 	rdev->mc.aper_base = drm_get_resource_start(rdev->ddev, 0);
 	rdev->mc.aper_size = drm_get_resource_len(rdev->ddev, 0);
+
+	if (rdev->mc.mc_vram_size > rdev->mc.aper_size)
+		rdev->mc.mc_vram_size = rdev->mc.aper_size;
+
+	if (rdev->mc.real_vram_size > rdev->mc.aper_size)
+		rdev->mc.real_vram_size = rdev->mc.aper_size;
+
 	rs690_pm_info(rdev);
 	/* FIXME: we should enforce default clock in case GPU is not in
 	 * default setup
diff -Nur linux-2.6.32-orig/drivers/hid/hid-apple.c iDroid-Project-kernel_common-9e90fd2/drivers/hid/hid-apple.c
--- linux-2.6.32-orig/drivers/hid/hid-apple.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hid/hid-apple.c	2010-11-18 21:05:30.000000000 +0600
@@ -431,6 +431,13 @@
 		.driver_data = APPLE_HAS_FN | APPLE_ISO_KEYBOARD },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_JIS),
 		.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI),
+		.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO),
+		.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN |
+			APPLE_ISO_KEYBOARD },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS),
+		.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY),
 		.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY),
diff -Nur linux-2.6.32-orig/drivers/hid/hid-core.c iDroid-Project-kernel_common-9e90fd2/drivers/hid/hid-core.c
--- linux-2.6.32-orig/drivers/hid/hid-core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hid/hid-core.c	2010-11-18 21:05:30.000000000 +0600
@@ -1287,6 +1287,9 @@
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_ANSI) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_ISO) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_JIS) },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI) },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO) },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_BELKIN, USB_DEVICE_ID_FLIP_KVM) },
diff -Nur linux-2.6.32-orig/drivers/hid/hid-ids.h iDroid-Project-kernel_common-9e90fd2/drivers/hid/hid-ids.h
--- linux-2.6.32-orig/drivers/hid/hid-ids.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hid/hid-ids.h	2010-11-18 21:05:30.000000000 +0600
@@ -88,6 +88,9 @@
 #define USB_DEVICE_ID_APPLE_WELLSPRING3_ANSI	0x0236
 #define USB_DEVICE_ID_APPLE_WELLSPRING3_ISO	0x0237
 #define USB_DEVICE_ID_APPLE_WELLSPRING3_JIS	0x0238
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI  0x0239
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO   0x023a
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS   0x023b
 #define USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY	0x030a
 #define USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY	0x030b
 #define USB_DEVICE_ID_APPLE_ATV_IRCONTROL	0x8241
diff -Nur linux-2.6.32-orig/drivers/hid/usbhid/hid-core.c iDroid-Project-kernel_common-9e90fd2/drivers/hid/usbhid/hid-core.c
--- linux-2.6.32-orig/drivers/hid/usbhid/hid-core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hid/usbhid/hid-core.c	2010-11-18 21:05:30.000000000 +0600
@@ -998,7 +998,8 @@
 	usbhid->urbctrl->transfer_dma = usbhid->ctrlbuf_dma;
 	usbhid->urbctrl->transfer_flags |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP);
 
-	usbhid_init_reports(hid);
+	if (!(hid->quirks & HID_QUIRK_NO_INIT_REPORTS))
+		usbhid_init_reports(hid);
 
 	set_bit(HID_STARTED, &usbhid->iofl);
 
diff -Nur linux-2.6.32-orig/drivers/hid/usbhid/hid-quirks.c iDroid-Project-kernel_common-9e90fd2/drivers/hid/usbhid/hid-quirks.c
--- linux-2.6.32-orig/drivers/hid/usbhid/hid-quirks.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hid/usbhid/hid-quirks.c	2010-11-18 21:05:30.000000000 +0600
@@ -280,7 +280,7 @@
 	if (idVendor == USB_VENDOR_ID_NCR &&
 			idProduct >= USB_DEVICE_ID_NCR_FIRST &&
 			idProduct <= USB_DEVICE_ID_NCR_LAST)
-			return HID_QUIRK_NOGET;
+			return HID_QUIRK_NO_INIT_REPORTS;
 
 	down_read(&dquirks_rwsem);
 	bl_entry = usbhid_exists_dquirk(idVendor, idProduct);
diff -Nur linux-2.6.32-orig/drivers/hwmon/adt7462.c iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/adt7462.c
--- linux-2.6.32-orig/drivers/hwmon/adt7462.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/adt7462.c	2010-11-18 21:05:30.000000000 +0600
@@ -97,7 +97,7 @@
 #define		ADT7462_PIN24_SHIFT		6
 #define		ADT7462_PIN26_VOLT_INPUT	0x08
 #define		ADT7462_PIN25_VOLT_INPUT	0x20
-#define		ADT7462_PIN28_SHIFT		6	/* cfg3 */
+#define		ADT7462_PIN28_SHIFT		4	/* cfg3 */
 #define		ADT7462_PIN28_VOLT		0x5
 
 #define ADT7462_REG_ALARM1			0xB8
@@ -182,7 +182,7 @@
  *
  * Some, but not all, of these voltages have low/high limits.
  */
-#define ADT7462_VOLT_COUNT	12
+#define ADT7462_VOLT_COUNT	13
 
 #define ADT7462_VENDOR		0x41
 #define ADT7462_DEVICE		0x62
diff -Nur linux-2.6.32-orig/drivers/hwmon/coretemp.c iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/coretemp.c
--- linux-2.6.32-orig/drivers/hwmon/coretemp.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/coretemp.c	2010-11-18 21:05:30.000000000 +0600
@@ -33,6 +33,7 @@
 #include <linux/list.h>
 #include <linux/platform_device.h>
 #include <linux/cpu.h>
+#include <linux/pci.h>
 #include <asm/msr.h>
 #include <asm/processor.h>
 
@@ -161,6 +162,7 @@
 	int usemsr_ee = 1;
 	int err;
 	u32 eax, edx;
+	struct pci_dev *host_bridge;
 
 	/* Early chips have no MSR for TjMax */
 
@@ -168,11 +170,21 @@
 		usemsr_ee = 0;
 	}
 
-	/* Atoms seems to have TjMax at 90C */
+	/* Atom CPUs */
 
 	if (c->x86_model == 0x1c) {
 		usemsr_ee = 0;
-		tjmax = 90000;
+
+		host_bridge = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
+
+		if (host_bridge && host_bridge->vendor == PCI_VENDOR_ID_INTEL
+		    && (host_bridge->device == 0xa000	/* NM10 based nettop */
+		    || host_bridge->device == 0xa010))	/* NM10 based netbook */
+			tjmax = 100000;
+		else
+			tjmax = 90000;
+
+		pci_dev_put(host_bridge);
 	}
 
 	if ((c->x86_model > 0xe) && (usemsr_ee)) {
diff -Nur linux-2.6.32-orig/drivers/hwmon/fschmd.c iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/fschmd.c
--- linux-2.6.32-orig/drivers/hwmon/fschmd.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/fschmd.c	2010-11-18 21:05:30.000000000 +0600
@@ -767,6 +767,7 @@
 static int watchdog_open(struct inode *inode, struct file *filp)
 {
 	struct fschmd_data *pos, *data = NULL;
+	int watchdog_is_open;
 
 	/* We get called from drivers/char/misc.c with misc_mtx hold, and we
 	   call misc_register() from fschmd_probe() with watchdog_data_mutex
@@ -781,10 +782,12 @@
 		}
 	}
 	/* Note we can never not have found data, so we don't check for this */
-	kref_get(&data->kref);
+	watchdog_is_open = test_and_set_bit(0, &data->watchdog_is_open);
+	if (!watchdog_is_open)
+		kref_get(&data->kref);
 	mutex_unlock(&watchdog_data_mutex);
 
-	if (test_and_set_bit(0, &data->watchdog_is_open))
+	if (watchdog_is_open)
 		return -EBUSY;
 
 	/* Start the watchdog */
diff -Nur linux-2.6.32-orig/drivers/hwmon/iphone-accel.c iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/iphone-accel.c
--- linux-2.6.32-orig/drivers/hwmon/iphone-accel.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/iphone-accel.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,260 @@
+/*
+ * drivers/hwmon/iphone_accel.c - driver for iPhone/iPod Accelerometer
+ *
+ * Copyright (C) 2010 Patrick Wildt <webmaster@patrick-wildt.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ * addons by Dario Russo, (turbominchiameister@gmail.com)
+ * based on the work of Kalhan Trisal and Alan Cox
+ */
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/io.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <mach/accel.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/input-polldev.h>
+
+#define CTRL_REG1				0x20
+#define CTRL_REG1_POWER_DOWN			(1<<6)
+
+struct iphone_accel_info *accel_info;
+
+struct iphone_accel_info {
+	struct i2c_device *i2c_dev;
+	struct i2c_client *i2c_client;
+	struct input_dev *input_dev;
+	struct input_polled_dev *idev;
+	struct mutex lock;
+	struct work_struct work;
+	unsigned int flags;
+	unsigned int working;
+	u_int8_t regs[0x40];
+};
+
+int accel_read_reg(int reg) {
+	return i2c_smbus_read_byte_data(accel_info->i2c_client, reg);
+}
+
+void accel_write_reg(int reg, int data) {
+	i2c_smbus_write_byte_data(accel_info->i2c_client, reg, data);
+}
+
+/* Sysfs methods */
+static int iphone_accel_read(int *x, int *y, int *z) {
+	*x = (signed char)accel_read_reg(ACCEL_OUTX);
+	*y = (signed char)accel_read_reg(ACCEL_OUTY);
+	*z = (signed char)accel_read_reg(ACCEL_OUTZ);
+
+	return 0;
+}
+
+/* Sysfs Files */
+static ssize_t power_mode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int val;
+
+	val = accel_read_reg(CTRL_REG1) & CTRL_REG1_POWER_DOWN;
+	if (val == CTRL_REG1_POWER_DOWN)
+		val = 1;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t power_mode_store(struct device *dev,
+		struct device_attribute *attr, const  char *buf, size_t count)
+{
+	unsigned int ret_val;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&accel_info->lock);
+
+	ret_val = accel_read_reg( CTRL_REG1);
+	ret_val &= 0xBF;
+
+	switch(val) {
+		case 1:
+			ret_val |= CTRL_REG1_POWER_DOWN;
+		case 0:
+			accel_write_reg( CTRL_REG1, ret_val);
+			break;
+		default:
+			mutex_unlock(&accel_info->lock);
+			return -EINVAL;
+	}
+	mutex_unlock(&accel_info->lock);
+	return count;
+}
+
+
+static DEVICE_ATTR(power_state, S_IRUGO | S_IWUSR, power_mode_show, power_mode_store);
+
+static struct attribute *iphone_accel_attributes[] = {
+	&dev_attr_power_state.attr,
+	NULL,
+};
+
+static struct attribute_group iphone_accel_attribute_group = {
+	.attrs = iphone_accel_attributes,
+};
+
+
+static void iphone_accel_input_poll(struct input_polled_dev *idev)
+{
+	int x,y,z;
+	iphone_accel_read(&x,&y,&z);
+
+#ifdef CONFIG_IPODTOUCH_1G
+	input_report_abs(idev->input, ABS_X, -x);
+#else
+	input_report_abs(idev->input, ABS_X, x);
+#endif
+
+#ifdef CONFIG_IPHONE_2G
+	input_report_abs(idev->input, ABS_Y, -y);
+	input_report_abs(idev->input, ABS_Z, -z); 
+#else
+	input_report_abs(idev->input, ABS_Y, y);
+	input_report_abs(idev->input, ABS_Z, z);
+#endif
+
+}
+
+static int __devinit iphone_accel_probe(struct i2c_client *i2c,
+                            const struct i2c_device_id *device_id)
+{
+	int ret;
+	int whoami;
+
+	accel_info=kzalloc(sizeof(*accel_info), GFP_KERNEL);
+	if (!accel_info)
+		return -ENOMEM;
+
+	mutex_init(&accel_info->lock);
+
+	accel_info->idev=input_allocate_polled_device();
+	accel_info->idev->poll = iphone_accel_input_poll;
+	accel_info->idev->poll_interval = 50;
+	accel_info->input_dev=accel_info->idev->input;
+	accel_info->i2c_client=i2c;
+
+	ret = sysfs_create_group(&accel_info->i2c_client->dev.kobj, &iphone_accel_attribute_group);
+	if (ret)
+		goto out;
+
+	whoami = accel_read_reg(ACCEL_WHOAMI);
+	if(whoami != ACCEL_WHOAMI_VALUE) {
+		printk(KERN_INFO "iphone-accel: incorrect whoami value\n");
+		goto out_sysfs;
+	}
+
+	accel_write_reg(ACCEL_CTRL_REG2, ACCEL_CTRL_REG2_BOOT);
+	accel_write_reg(ACCEL_CTRL_REG1, ACCEL_CTRL_REG1_PD | ACCEL_CTRL_REG1_XEN | ACCEL_CTRL_REG1_YEN | ACCEL_CTRL_REG1_ZEN);
+
+	accel_info->input_dev->name = "ST LIS331DL 3 axis-accelerometer";
+	accel_info->input_dev->phys       = "iphone_accel/input0";
+	accel_info->input_dev->id.bustype = BUS_I2C;
+	accel_info->input_dev->id.vendor = 0;
+	accel_info->input_dev->dev.parent = &i2c->dev;
+
+	set_bit(EV_ABS, accel_info->input_dev->evbit);
+	set_bit(ABS_X, accel_info->input_dev->absbit);
+	set_bit(ABS_Y, accel_info->input_dev->absbit);
+	set_bit(ABS_Z, accel_info->input_dev->absbit);
+
+	ret = input_register_polled_device(accel_info->idev);
+	if (ret)
+		goto out_sysfs;
+
+	printk( "iphone_accel: device successfully initialized.\n");
+	return 0;
+
+out_sysfs:
+	sysfs_remove_group(&accel_info->i2c_client->dev.kobj, &iphone_accel_attribute_group);
+out:
+	printk(KERN_INFO "iphone_accel: error initializing\n");
+	return -1;
+}
+
+static int __devexit iphone_accel_remove(struct i2c_client *client)
+{
+	sysfs_remove_group(&accel_info->i2c_client->dev.kobj, &iphone_accel_attribute_group);
+	input_unregister_polled_device(accel_info->idev);
+	input_free_polled_device(accel_info->idev);
+	kfree(accel_info);
+
+	return 0;
+}
+
+static const struct i2c_device_id iphone_accel_i2c_id[] = {
+	{ "iphone-accel", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, iphone_accel_i2c_id);
+
+static struct i2c_driver iphone_accel_driver = {
+	.driver	= {
+		.name = "iphone-accel",
+		.owner = THIS_MODULE,
+	},
+	.probe = iphone_accel_probe,
+	.remove = iphone_accel_remove,
+	.id_table = iphone_accel_i2c_id,
+};
+
+
+/* Module stuff */
+
+static int __init iphone_accel_init(void)
+{
+	int ret;
+
+	ret = i2c_add_driver(&iphone_accel_driver);
+	if (ret) {
+		printk("iphone_accel: unable to register I2C driver: %d\n", ret);
+		goto out;
+	}
+
+	printk(KERN_INFO "iphone_accel: driver successfully loaded.\n");
+	return 0;
+
+out:
+	i2c_del_driver(&iphone_accel_driver);
+	printk(KERN_WARNING "iphone_accel: driver init failed (ret=%d)!\n", ret);
+	return ret;
+}
+
+static void __exit iphone_accel_exit(void)
+{
+	i2c_del_driver(&iphone_accel_driver);
+	printk(KERN_INFO "iphone_accel: driver unloaded.\n");
+}
+
+module_init(iphone_accel_init);
+module_exit(iphone_accel_exit);
+
+MODULE_AUTHOR("Patrick Wildt <webmaster@patrick-wildt.de>");
+MODULE_DESCRIPTION("iPhone Accelerometer Driver");
+MODULE_LICENSE("GPL v2");
diff -Nur linux-2.6.32-orig/drivers/hwmon/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/Kconfig
--- linux-2.6.32-orig/drivers/hwmon/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -374,7 +374,7 @@
 
 config SENSORS_CORETEMP
 	tristate "Intel Core/Core2/Atom temperature sensor"
-	depends on X86 && EXPERIMENTAL
+	depends on X86 && PCI && EXPERIMENTAL
 	help
 	  If you say yes here you get support for the temperature
 	  sensor inside your CPU. Most of the family 6 CPUs
@@ -408,6 +408,11 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called ibmpex.
 
+config SENSORS_IPHONE_ACCEL
+	tristate "iPhone/iPod Accelerometer"
+	select INPUT_POLLDEV
+	depends on (IPHONE_3G || IPHONE_2G || IPODTOUCH_1G) && I2C
+
 config SENSORS_IT87
 	tristate "ITE IT87xx and compatibles"
 	select HWMON_VID
diff -Nur linux-2.6.32-orig/drivers/hwmon/lm78.c iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/lm78.c
--- linux-2.6.32-orig/drivers/hwmon/lm78.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/lm78.c	2010-11-18 21:05:30.000000000 +0600
@@ -870,17 +870,16 @@
 static int __init lm78_isa_found(unsigned short address)
 {
 	int val, save, found = 0;
+	int port;
 
-	/* We have to request the region in two parts because some
-	   boards declare base+4 to base+7 as a PNP device */
-	if (!request_region(address, 4, "lm78")) {
-		pr_debug("lm78: Failed to request low part of region\n");
-		return 0;
-	}
-	if (!request_region(address + 4, 4, "lm78")) {
-		pr_debug("lm78: Failed to request high part of region\n");
-		release_region(address, 4);
-		return 0;
+	/* Some boards declare base+0 to base+7 as a PNP device, some base+4
+	 * to base+7 and some base+5 to base+6. So we better request each port
+	 * individually for the probing phase. */
+	for (port = address; port < address + LM78_EXTENT; port++) {
+		if (!request_region(port, 1, "lm78")) {
+			pr_debug("lm78: Failed to request port 0x%x\n", port);
+			goto release;
+		}
 	}
 
 #define REALLY_SLOW_IO
@@ -944,8 +943,8 @@
 			val & 0x80 ? "LM79" : "LM78", (int)address);
 
  release:
-	release_region(address + 4, 4);
-	release_region(address, 4);
+	for (port--; port >= address; port--)
+		release_region(port, 1);
 	return found;
 }
 
diff -Nur linux-2.6.32-orig/drivers/hwmon/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/Makefile
--- linux-2.6.32-orig/drivers/hwmon/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -49,6 +49,7 @@
 obj-$(CONFIG_SENSORS_ULTRA45)	+= ultra45_env.o
 obj-$(CONFIG_SENSORS_HDAPS)	+= hdaps.o
 obj-$(CONFIG_SENSORS_I5K_AMB)	+= i5k_amb.o
+obj-$(CONFIG_SENSORS_IPHONE_ACCEL)	+= iphone-accel.o
 obj-$(CONFIG_SENSORS_IBMAEM)	+= ibmaem.o
 obj-$(CONFIG_SENSORS_IBMPEX)	+= ibmpex.o
 obj-$(CONFIG_SENSORS_IT87)	+= it87.o
diff -Nur linux-2.6.32-orig/drivers/hwmon/sht15.c iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/sht15.c
--- linux-2.6.32-orig/drivers/hwmon/sht15.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/sht15.c	2010-11-18 21:05:30.000000000 +0600
@@ -305,7 +305,7 @@
 	int d1 = 0;
 	int i;
 
-	for (i = 1; i < ARRAY_SIZE(temppoints) - 1; i++)
+	for (i = 1; i < ARRAY_SIZE(temppoints); i++)
 		/* Find pointer to interpolate */
 		if (data->supply_uV > temppoints[i - 1].vdd) {
 			d1 = (data->supply_uV/1000 - temppoints[i - 1].vdd)
@@ -332,12 +332,12 @@
 
 	const int c1 = -4;
 	const int c2 = 40500; /* x 10 ^ -6 */
-	const int c3 = 2800; /* x10 ^ -9 */
+	const int c3 = -2800; /* x10 ^ -9 */
 
 	RHlinear = c1*1000
 		+ c2 * data->val_humid/1000
 		+ (data->val_humid * data->val_humid * c3)/1000000;
-	return (temp - 25000) * (10000 + 800 * data->val_humid)
+	return (temp - 25000) * (10000 + 80 * data->val_humid)
 		/ 1000000 + RHlinear;
 }
 
diff -Nur linux-2.6.32-orig/drivers/hwmon/w83781d.c iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/w83781d.c
--- linux-2.6.32-orig/drivers/hwmon/w83781d.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/hwmon/w83781d.c	2010-11-18 21:05:30.000000000 +0600
@@ -1818,17 +1818,17 @@
 w83781d_isa_found(unsigned short address)
 {
 	int val, save, found = 0;
+	int port;
 
-	/* We have to request the region in two parts because some
-	   boards declare base+4 to base+7 as a PNP device */
-	if (!request_region(address, 4, "w83781d")) {
-		pr_debug("w83781d: Failed to request low part of region\n");
-		return 0;
-	}
-	if (!request_region(address + 4, 4, "w83781d")) {
-		pr_debug("w83781d: Failed to request high part of region\n");
-		release_region(address, 4);
-		return 0;
+	/* Some boards declare base+0 to base+7 as a PNP device, some base+4
+	 * to base+7 and some base+5 to base+6. So we better request each port
+	 * individually for the probing phase. */
+	for (port = address; port < address + W83781D_EXTENT; port++) {
+		if (!request_region(port, 1, "w83781d")) {
+			pr_debug("w83781d: Failed to request port 0x%x\n",
+				 port);
+			goto release;
+		}
 	}
 
 #define REALLY_SLOW_IO
@@ -1902,8 +1902,8 @@
 			val == 0x30 ? "W83782D" : "W83781D", (int)address);
 
  release:
-	release_region(address + 4, 4);
-	release_region(address, 4);
+	for (port--; port >= address; port--)
+		release_region(port, 1);
 	return found;
 }
 
diff -Nur linux-2.6.32-orig/drivers/i2c/busses/i2c-pca-isa.c iDroid-Project-kernel_common-9e90fd2/drivers/i2c/busses/i2c-pca-isa.c
--- linux-2.6.32-orig/drivers/i2c/busses/i2c-pca-isa.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/i2c/busses/i2c-pca-isa.c	2010-11-18 21:05:30.000000000 +0600
@@ -75,7 +75,7 @@
 	unsigned long timeout;
 
 	if (irq > -1) {
-		ret = wait_event_interruptible_timeout(pca_wait,
+		ret = wait_event_timeout(pca_wait,
 				pca_isa_readbyte(pd, I2C_PCA_CON)
 				& I2C_PCA_CON_SI, pca_isa_ops.timeout);
 	} else {
@@ -96,7 +96,7 @@
 }
 
 static irqreturn_t pca_handler(int this_irq, void *dev_id) {
-	wake_up_interruptible(&pca_wait);
+	wake_up(&pca_wait);
 	return IRQ_HANDLED;
 }
 
diff -Nur linux-2.6.32-orig/drivers/i2c/busses/i2c-pca-platform.c iDroid-Project-kernel_common-9e90fd2/drivers/i2c/busses/i2c-pca-platform.c
--- linux-2.6.32-orig/drivers/i2c/busses/i2c-pca-platform.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/i2c/busses/i2c-pca-platform.c	2010-11-18 21:05:30.000000000 +0600
@@ -84,7 +84,7 @@
 	unsigned long timeout;
 
 	if (i2c->irq) {
-		ret = wait_event_interruptible_timeout(i2c->wait,
+		ret = wait_event_timeout(i2c->wait,
 			i2c->algo_data.read_byte(i2c, I2C_PCA_CON)
 			& I2C_PCA_CON_SI, i2c->adap.timeout);
 	} else {
@@ -122,7 +122,7 @@
 	if ((i2c->algo_data.read_byte(i2c, I2C_PCA_CON) & I2C_PCA_CON_SI) == 0)
 		return IRQ_NONE;
 
-	wake_up_interruptible(&i2c->wait);
+	wake_up(&i2c->wait);
 
 	return IRQ_HANDLED;
 }
diff -Nur linux-2.6.32-orig/drivers/i2c/busses/i2c-tiny-usb.c iDroid-Project-kernel_common-9e90fd2/drivers/i2c/busses/i2c-tiny-usb.c
--- linux-2.6.32-orig/drivers/i2c/busses/i2c-tiny-usb.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/i2c/busses/i2c-tiny-usb.c	2010-11-18 21:05:30.000000000 +0600
@@ -13,6 +13,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/module.h>
+#include <linux/types.h>
 
 /* include interfaces to usb layer */
 #include <linux/usb.h>
@@ -31,8 +32,8 @@
 #define CMD_I2C_IO_END		(1<<1)
 
 /* i2c bit delay, default is 10us -> 100kHz */
-static int delay = 10;
-module_param(delay, int, 0);
+static unsigned short delay = 10;
+module_param(delay, ushort, 0);
 MODULE_PARM_DESC(delay, "bit delay in microseconds, "
 		 "e.g. 10 for 100kHz (default is 100kHz)");
 
@@ -109,7 +110,7 @@
 
 static u32 usb_func(struct i2c_adapter *adapter)
 {
-	u32 func;
+	__le32 func;
 
 	/* get functionality from adapter */
 	if (usb_read(adapter, CMD_GET_FUNC, 0, 0, &func, sizeof(func)) !=
@@ -118,7 +119,7 @@
 		return 0;
 	}
 
-	return func;
+	return le32_to_cpu(func);
 }
 
 /* This is the actual algorithm we define */
@@ -216,8 +217,7 @@
 		 "i2c-tiny-usb at bus %03d device %03d",
 		 dev->usb_dev->bus->busnum, dev->usb_dev->devnum);
 
-	if (usb_write(&dev->adapter, CMD_SET_DELAY,
-		      cpu_to_le16(delay), 0, NULL, 0) != 0) {
+	if (usb_write(&dev->adapter, CMD_SET_DELAY, delay, 0, NULL, 0) != 0) {
 		dev_err(&dev->adapter.dev,
 			"failure setting delay to %dus\n", delay);
 		retval = -EIO;
diff -Nur linux-2.6.32-orig/drivers/i2c/chips/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/i2c/chips/Kconfig
--- linux-2.6.32-orig/drivers/i2c/chips/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/i2c/chips/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -26,4 +26,14 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called tsl2550.
 
+config SENSORS_PCA963X
+	tristate "Philips PCA963X 4-bit I2C-bus LED"
+	depends on I2C && EXPERIMENTAL
+	help
+	 If you say yes here you get support for the Philips PCA963X
+	 4-bit I2C-bus LED.
+
+	 This driver can also be built as a module.  If so, the module
+	 will be called pca963X.
+
 endmenu
diff -Nur linux-2.6.32-orig/drivers/i2c/chips/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/i2c/chips/Makefile
--- linux-2.6.32-orig/drivers/i2c/chips/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/i2c/chips/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -11,6 +11,7 @@
 #
 
 obj-$(CONFIG_DS1682)		+= ds1682.o
+obj-$(CONFIG_SENSORS_PCA963X)	+= pca963x.o
 obj-$(CONFIG_SENSORS_TSL2550)	+= tsl2550.o
 
 ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
diff -Nur linux-2.6.32-orig/drivers/i2c/chips/pca963x.c iDroid-Project-kernel_common-9e90fd2/drivers/i2c/chips/pca963x.c
--- linux-2.6.32-orig/drivers/i2c/chips/pca963x.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/i2c/chips/pca963x.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,430 @@
+/* pca963x.c - 4-bit I2C-bus LED driver
+ *
+ * Copyright (C) 2008 HTC Corporation.
+ * Author: Shan-Fu Chiou <sfchiou@gmail.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/leds.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+
+static uint8_t address[] = { 0x02, 0x03, 0x04 };
+static DEFINE_SPINLOCK(pca963x_lock);
+
+enum op_t {
+	OP_SET_BLINK,
+	OP_SET_GRPPWM,
+	OP_SET_GRPFREQ,
+	OP_SET_BLUE_BRIGHTNESS,
+	OP_SET_GREEN_BRIGHTNESS,
+	OP_SET_RED_BRIGHTNESS,
+};
+
+enum power_mode {
+	MODE_SLEEP,
+	MODE_NORMAL,
+};
+
+struct pca963x_t {
+	uint8_t colors[3];
+	uint8_t blink;
+	uint8_t grppwm;
+	uint8_t grpfreq;
+};
+
+struct pca963x_data {
+	struct pca963x_t data;
+	uint8_t dirty;
+	uint8_t status;
+	enum power_mode mode;
+	struct work_struct work;
+	struct i2c_client *client;
+	struct led_classdev leds[3];	/* blue, green, red */
+};
+
+static ssize_t pca963x_blink_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	if (((pca963x->dirty >> OP_SET_BLINK) & 0x01))
+		flush_scheduled_work();
+	return sprintf(buf, "%u\n", pca963x->data.blink);
+}
+
+static ssize_t pca963x_blink_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	int val = -1;
+
+	sscanf(buf, "%u", &val);
+	if (val < 0 || val > 1)
+		return -EINVAL;
+
+	spin_lock(&pca963x_lock);
+	pca963x->dirty |= 1 << OP_SET_BLINK;
+	pca963x->data.blink = val;
+	spin_unlock(&pca963x_lock);
+	schedule_work(&pca963x->work);
+
+	return count;
+}
+
+static DEVICE_ATTR(blink, 0644, pca963x_blink_show, pca963x_blink_store);
+
+static ssize_t pca963x_grpfreq_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	if (((pca963x->dirty >> OP_SET_GRPFREQ) & 0x01))
+		flush_scheduled_work();
+	return sprintf(buf, "%u\n", pca963x->data.grpfreq);
+}
+
+static ssize_t pca963x_grpfreq_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+
+	if (val > 0xff)
+		return -EINVAL;
+
+	spin_lock(&pca963x_lock);
+	pca963x->dirty |= 1 << OP_SET_GRPFREQ;
+	pca963x->data.grpfreq = val;
+	spin_unlock(&pca963x_lock);
+	schedule_work(&pca963x->work);
+
+	return count;
+}
+
+static DEVICE_ATTR(grpfreq, 0644, pca963x_grpfreq_show, pca963x_grpfreq_store);
+
+static ssize_t pca963x_grppwm_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	if (((pca963x->dirty >> OP_SET_GRPPWM) & 0x01))
+		flush_scheduled_work();
+	return sprintf(buf, "%u\n", pca963x->data.grppwm);
+}
+
+static ssize_t pca963x_grppwm_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+
+	if (val > 0xff)
+		return -EINVAL;
+
+	spin_lock(&pca963x_lock);
+	pca963x->dirty |= 1 << OP_SET_GRPPWM;
+	pca963x->data.grppwm = val;
+	spin_unlock(&pca963x_lock);
+	schedule_work(&pca963x->work);
+
+	return count;
+}
+
+static DEVICE_ATTR(grppwm, 0644, pca963x_grppwm_show, pca963x_grppwm_store);
+
+static void led_brightness_set(struct led_classdev *led_cdev,
+			       enum led_brightness brightness)
+{
+	struct pca963x_data *pca963x;
+	int idx = 2;
+
+	spin_lock(&pca963x_lock);
+	if (!strcmp(led_cdev->name, "blue")) {
+		idx = 0;
+	} else if (!strcmp(led_cdev->name, "green")) {
+		idx = 1;
+	} else {
+		idx = 2;
+	}
+	pca963x = container_of(led_cdev, struct pca963x_data, leds[idx]);
+	pca963x->data.colors[idx] = brightness;
+	pca963x->dirty |= (1 << (OP_SET_BLUE_BRIGHTNESS + idx));
+	spin_unlock(&pca963x_lock);
+
+	schedule_work(&pca963x->work);
+
+}
+
+static void pca963x_update_brightness(struct pca963x_data *pca963x, int idx,
+				      int brightness)
+{
+	if (brightness > LED_OFF) {
+		if (brightness == LED_FULL) {
+			pca963x->status &= ~(1 << idx);
+			pca963x->status |= (1 << (idx + 4));
+		} else {
+			pca963x->status |= (1 << idx);
+			pca963x->status &= ~(1 << (idx + 4));
+		}
+	} else {
+		pca963x->status &= ~(1 << idx);
+		pca963x->status &= ~(1 << (idx + 4));
+	}
+	i2c_smbus_write_byte_data(pca963x->client, address[idx], brightness);
+}
+
+static void pca963x_work_func(struct work_struct *work)
+{
+	int ret;
+	uint8_t dirty = 0;
+	struct pca963x_t work_data;
+	struct pca963x_data *pca963x =
+	    container_of(work, struct pca963x_data, work);
+
+	spin_lock(&pca963x_lock);
+	work_data = pca963x->data;
+	dirty = pca963x->dirty;
+	pca963x->dirty = 0;
+	spin_unlock(&pca963x_lock);
+
+	ret = i2c_smbus_read_byte_data(pca963x->client, 0x00);
+	/* check if should switch to normal mode */
+	if (!pca963x->mode) {
+		i2c_smbus_write_byte_data(pca963x->client, 0x00, 0x01);
+		pca963x->mode = MODE_NORMAL;
+		i2c_smbus_write_byte_data(pca963x->client, 0x08, 0xFF);
+	}
+
+	if ((dirty >> OP_SET_BLINK) & 0x01) {
+		ret = i2c_smbus_read_byte_data(pca963x->client, 0x01);
+		if (work_data.blink)	/* enable blinking */
+			i2c_smbus_write_byte_data(pca963x->client, 0x01,
+						  ret | 0x20);
+		else {
+			/* set group duty cycle control to default */
+			i2c_smbus_write_byte_data(pca963x->client, 0x06, 0xFF);
+			/* set group frequency to default */
+			i2c_smbus_write_byte_data(pca963x->client, 0x07, 0x00);
+			/* enable dimming */
+			i2c_smbus_write_byte_data(pca963x->client, 0x01,
+						  ret & 0xDF);
+		}
+	}
+
+	if ((dirty >> OP_SET_GRPPWM) & 0x01) {
+		i2c_smbus_write_byte_data(pca963x->client, 0x06,
+					  work_data.grppwm);
+	}
+
+	if ((dirty >> OP_SET_GRPFREQ) & 0x01) {
+		i2c_smbus_write_byte_data(pca963x->client, 0x07,
+					  work_data.grpfreq);
+	}
+
+	if ((dirty >> OP_SET_BLUE_BRIGHTNESS) & 0x01)
+		pca963x_update_brightness(pca963x, 0, work_data.colors[0]);
+
+	if ((dirty >> OP_SET_GREEN_BRIGHTNESS) & 0x01)
+		pca963x_update_brightness(pca963x, 1, work_data.colors[1]);
+
+	if ((dirty >> OP_SET_RED_BRIGHTNESS) & 0x01)
+		pca963x_update_brightness(pca963x, 2, work_data.colors[2]);
+
+	/* check if could go to low power mode */
+	if (((pca963x->status & 0x0F) == 0) && (!work_data.blink)) {
+		i2c_smbus_write_byte_data(pca963x->client, 0x08, 0xAA);
+		i2c_smbus_write_byte_data(pca963x->client, 0x00, 0x11);
+		pca963x->mode = MODE_SLEEP;
+	}
+}
+
+static void set_pca963x_default(struct i2c_client *client)
+{
+	i2c_smbus_write_byte_data(client, 0x00, 0x01);
+	i2c_smbus_write_byte_data(client, 0x01, 0x00);
+	/* set all LEDx brightness off */
+	i2c_smbus_write_byte_data(client, address[0], LED_OFF);
+	i2c_smbus_write_byte_data(client, address[1], LED_OFF);
+	i2c_smbus_write_byte_data(client, address[2], LED_OFF);
+	/* set group duty cycle control to default */
+	i2c_smbus_write_byte_data(client, 0x06, 0xFF);
+	/* set group frequency to default */
+	i2c_smbus_write_byte_data(client, 0x07, 0x00);
+	/*
+	 * set LEDx individual brightness and group dimming/blinking
+	 * can be controlled by * its PWMx register and GRPPWM registers.
+	 */
+	i2c_smbus_write_byte_data(client, 0x08, 0xFF);
+	/* low power mode. oscillator off */
+	i2c_smbus_write_byte_data(client, 0x00, 0x11);
+}
+
+static int pca963x_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	int ret = 0;
+
+	struct pca963x_data *pca963x;
+
+	if (!i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_BYTE_DATA)) {
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	pca963x = kzalloc(sizeof(struct pca963x_data), GFP_KERNEL);
+	if (pca963x == NULL) {
+		ret = -ENOMEM;
+		goto err_alloc_failed;
+	}
+
+	INIT_WORK(&pca963x->work, pca963x_work_func);
+
+	pca963x->client = client;
+
+	pca963x->leds[0].name = "blue";
+	pca963x->leds[0].brightness = LED_OFF;
+	pca963x->leds[0].brightness_set = led_brightness_set;
+
+	pca963x->leds[1].name = "green";
+	pca963x->leds[1].brightness = LED_OFF;
+	pca963x->leds[1].brightness_set = led_brightness_set;
+
+	pca963x->leds[2].name = "red";
+	pca963x->leds[2].brightness = LED_OFF;
+	pca963x->leds[2].brightness_set = led_brightness_set;
+
+	pca963x->dirty = 0;
+	pca963x->status = 0;
+
+	pca963x->data.colors[0] = LED_OFF;
+	pca963x->data.colors[1] = LED_OFF;
+	pca963x->data.colors[2] = LED_OFF;
+	pca963x->data.blink = 0;
+	pca963x->data.grppwm = 0;
+	pca963x->data.grpfreq = 0;
+	i2c_set_clientdata(client, pca963x);
+
+	set_pca963x_default(client);
+	pca963x->mode = MODE_SLEEP;
+
+	/* blue */
+	ret = led_classdev_register(&client->dev, &pca963x->leds[0]);
+	if (ret < 0) {
+		printk(KERN_ERR "pca963x: led_classdev_register failed\n");
+		goto err_led0_classdev_register_failed;
+	}
+	/* green */
+	ret = led_classdev_register(&client->dev, &pca963x->leds[1]);
+	if (ret < 0) {
+		printk(KERN_ERR "pca963x: led_classdev_register failed\n");
+		goto err_led1_classdev_register_failed;
+	}
+	/* red */
+	ret = led_classdev_register(&client->dev, &pca963x->leds[2]);
+	if (ret < 0) {
+		printk(KERN_ERR "pca963x: led_classdev_register failed\n");
+		goto err_led2_classdev_register_failed;
+	}
+
+	ret = device_create_file(&client->dev, &dev_attr_blink);
+	ret = device_create_file(&client->dev, &dev_attr_grppwm);
+	ret = device_create_file(&client->dev, &dev_attr_grpfreq);
+
+	return 0;
+
+err_led2_classdev_register_failed:
+	led_classdev_unregister(&pca963x->leds[2]);
+err_led1_classdev_register_failed:
+	led_classdev_unregister(&pca963x->leds[1]);
+err_led0_classdev_register_failed:
+	led_classdev_unregister(&pca963x->leds[0]);
+err_alloc_failed:
+	kfree(pca963x);
+exit:
+	return ret;
+}
+
+static int pca963x_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	flush_scheduled_work();
+	return 0;
+}
+
+static int pca963x_remove(struct i2c_client *client)
+{
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	cancel_work_sync(&pca963x->work);
+	device_remove_file(&client->dev, &dev_attr_blink);
+	device_remove_file(&client->dev, &dev_attr_grppwm);
+	device_remove_file(&client->dev, &dev_attr_grpfreq);
+	set_pca963x_default(client);
+	led_classdev_unregister(&pca963x->leds[0]);
+	led_classdev_unregister(&pca963x->leds[1]);
+	led_classdev_unregister(&pca963x->leds[2]);
+
+	kfree(pca963x);
+	return 0;
+}
+
+static const struct i2c_device_id pca963x_id[] = {
+	{ "pca963x", 0 },
+	{ }
+};
+
+static struct i2c_driver pca963x_driver = {
+	.driver = {
+		   .name = "pca963x",
+		   },
+	.probe = pca963x_probe,
+	.suspend = pca963x_suspend,
+	.remove = pca963x_remove,
+	.id_table = pca963x_id,
+};
+
+static int __init pca963x_init(void)
+{
+	return i2c_add_driver(&pca963x_driver);
+}
+
+static void __exit pca963x_exit(void)
+{
+	i2c_del_driver(&pca963x_driver);
+}
+
+MODULE_AUTHOR("Shan-Fu Chiou <sfchiou@gmail.com>");
+MODULE_DESCRIPTION("pca963x driver");
+MODULE_LICENSE("GPL");
+
+module_init(pca963x_init);
+module_exit(pca963x_exit);
diff -Nur linux-2.6.32-orig/drivers/i2c/i2c-core.c iDroid-Project-kernel_common-9e90fd2/drivers/i2c/i2c-core.c
--- linux-2.6.32-orig/drivers/i2c/i2c-core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/i2c/i2c-core.c	2010-11-18 21:05:30.000000000 +0600
@@ -801,6 +801,9 @@
 				 adap->dev.parent);
 #endif
 
+	/* device name is gone after device_unregister */
+	dev_dbg(&adap->dev, "adapter [%s] unregistered\n", adap->name);
+
 	/* clean up the sysfs representation */
 	init_completion(&adap->dev_released);
 	device_unregister(&adap->dev);
@@ -813,8 +816,6 @@
 	idr_remove(&i2c_adapter_idr, adap->nr);
 	mutex_unlock(&core_lock);
 
-	dev_dbg(&adap->dev, "adapter [%s] unregistered\n", adap->name);
-
 	/* Clear the device structure in case this adapter is ever going to be
 	   added again */
 	memset(&adap->dev, 0, sizeof(adap->dev));
diff -Nur linux-2.6.32-orig/drivers/ide/slc90e66.c iDroid-Project-kernel_common-9e90fd2/drivers/ide/slc90e66.c
--- linux-2.6.32-orig/drivers/ide/slc90e66.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/ide/slc90e66.c	2010-11-18 21:05:30.000000000 +0600
@@ -91,8 +91,7 @@
 
 		if (!(reg48 & u_flag))
 			pci_write_config_word(dev, 0x48, reg48|u_flag);
-		/* FIXME: (reg4a & a_speed) ? */
-		if ((reg4a & u_speed) != u_speed) {
+		if ((reg4a & a_speed) != u_speed) {
 			pci_write_config_word(dev, 0x4a, reg4a & ~a_speed);
 			pci_read_config_word(dev, 0x4a, &reg4a);
 			pci_write_config_word(dev, 0x4a, reg4a|u_speed);
diff -Nur linux-2.6.32-orig/drivers/infiniband/hw/ipath/ipath_fs.c iDroid-Project-kernel_common-9e90fd2/drivers/infiniband/hw/ipath/ipath_fs.c
--- linux-2.6.32-orig/drivers/infiniband/hw/ipath/ipath_fs.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/infiniband/hw/ipath/ipath_fs.c	2010-11-18 21:05:30.000000000 +0600
@@ -346,10 +346,8 @@
 	list_for_each_entry_safe(dd, tmp, &ipath_dev_list, ipath_list) {
 		spin_unlock_irqrestore(&ipath_devs_lock, flags);
 		ret = create_device_files(sb, dd);
-		if (ret) {
-			deactivate_locked_super(sb);
+		if (ret)
 			goto bail;
-		}
 		spin_lock_irqsave(&ipath_devs_lock, flags);
 	}
 
diff -Nur linux-2.6.32-orig/drivers/infiniband/ulp/ipoib/ipoib_main.c iDroid-Project-kernel_common-9e90fd2/drivers/infiniband/ulp/ipoib/ipoib_main.c
--- linux-2.6.32-orig/drivers/infiniband/ulp/ipoib/ipoib_main.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/infiniband/ulp/ipoib/ipoib_main.c	2010-11-18 21:05:30.000000000 +0600
@@ -884,6 +884,7 @@
 
 	neigh->neighbour = neighbour;
 	neigh->dev = dev;
+	memset(&neigh->dgid.raw, 0, sizeof (union ib_gid));
 	*to_ipoib_neigh(neighbour) = neigh;
 	skb_queue_head_init(&neigh->queue);
 	ipoib_cm_set(neigh, NULL);
diff -Nur linux-2.6.32-orig/drivers/input/evdev.c iDroid-Project-kernel_common-9e90fd2/drivers/input/evdev.c
--- linux-2.6.32-orig/drivers/input/evdev.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/evdev.c	2010-11-18 21:05:30.000000000 +0600
@@ -20,6 +20,7 @@
 #include <linux/input.h>
 #include <linux/major.h>
 #include <linux/device.h>
+#include <linux/wakelock.h>
 #include "input-compat.h"
 
 struct evdev {
@@ -43,6 +44,8 @@
 	struct fasync_struct *fasync;
 	struct evdev *evdev;
 	struct list_head node;
+	struct wake_lock wake_lock;
+	char name[28];
 };
 
 static struct evdev *evdev_table[EVDEV_MINORS];
@@ -55,6 +58,7 @@
 	 * Interrupts are disabled, just acquire the lock
 	 */
 	spin_lock(&client->buffer_lock);
+	wake_lock_timeout(&client->wake_lock, 5 * HZ);
 	client->buffer[client->head++] = *event;
 	client->head &= EVDEV_BUFFER_SIZE - 1;
 	spin_unlock(&client->buffer_lock);
@@ -71,8 +75,11 @@
 	struct evdev *evdev = handle->private;
 	struct evdev_client *client;
 	struct input_event event;
+	struct timespec ts;
 
-	do_gettimeofday(&event.time);
+	ktime_get_ts(&ts);
+	event.time.tv_sec = ts.tv_sec;
+	event.time.tv_usec = ts.tv_nsec / NSEC_PER_USEC;
 	event.type = type;
 	event.code = code;
 	event.value = value;
@@ -233,6 +240,7 @@
 	mutex_unlock(&evdev->mutex);
 
 	evdev_detach_client(evdev, client);
+	wake_lock_destroy(&client->wake_lock);
 	kfree(client);
 
 	evdev_close_device(evdev);
@@ -269,6 +277,9 @@
 	}
 
 	spin_lock_init(&client->buffer_lock);
+	snprintf(client->name, sizeof(client->name), "%s-%d",
+			dev_name(&evdev->dev), task_tgid_vnr(current));
+	wake_lock_init(&client->wake_lock, WAKE_LOCK_SUSPEND, client->name);
 	client->evdev = evdev;
 	evdev_attach_client(evdev, client);
 
@@ -332,6 +343,8 @@
 	if (have_event) {
 		*event = client->buffer[client->tail++];
 		client->tail &= EVDEV_BUFFER_SIZE - 1;
+		if (client->head == client->tail)
+			wake_unlock(&client->wake_lock);
 	}
 
 	spin_unlock_irq(&client->buffer_lock);
diff -Nur linux-2.6.32-orig/drivers/input/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/input/Kconfig
--- linux-2.6.32-orig/drivers/input/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -149,6 +149,15 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called apm-power.
 
+config INPUT_KEYRESET
+	tristate "Reset key"
+	depends on INPUT
+	---help---
+	  Say Y here if you want to reboot when some keys are pressed;
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called keyreset.
+
 config XEN_KBDDEV_FRONTEND
 	tristate "Xen virtual keyboard and mouse support"
 	depends on XEN_FBDEV_FRONTEND
diff -Nur linux-2.6.32-orig/drivers/input/keyboard/iphone_gpio_keys.c iDroid-Project-kernel_common-9e90fd2/drivers/input/keyboard/iphone_gpio_keys.c
--- linux-2.6.32-orig/drivers/input/keyboard/iphone_gpio_keys.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/keyboard/iphone_gpio_keys.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,292 @@
+/*
+ * Driver for keys on GPIO lines capable of generating interrupts.
+ *
+ * Copyright 2005 Phil Blundell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+#include <linux/pm.h>
+#include <linux/sysctl.h>
+#include <linux/proc_fs.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/gpio_keys.h>
+#include <linux/workqueue.h>
+
+#include <asm/gpio.h>
+
+struct gpio_button_data {
+	struct gpio_keys_button *button;
+	struct input_dev *input;
+	struct timer_list timer;
+	struct work_struct work;
+};
+
+struct gpio_keys_drvdata {
+	struct input_dev *input;
+	struct gpio_button_data data[0];
+};
+
+static void gpio_keys_report_event(struct work_struct *work)
+{
+	struct gpio_button_data *bdata =
+		container_of(work, struct gpio_button_data, work);
+	struct gpio_keys_button *button = bdata->button;
+	struct input_dev *input = bdata->input;
+	unsigned int type = button->type ?: EV_KEY;
+	int state = (gpio_get_value(button->gpio) ? 1 : 0) ^ button->active_low;
+
+	input_event(input, type, button->code, !!state);
+	input_sync(input);
+}
+
+static void gpio_keys_timer(unsigned long _data)
+{
+	struct gpio_button_data *data = (struct gpio_button_data *)_data;
+
+	schedule_work(&data->work);
+}
+
+static irqreturn_t gpio_keys_isr(int irq, void *dev_id)
+{
+	struct gpio_button_data *bdata = dev_id;
+	struct gpio_keys_button *button = bdata->button;
+
+	BUG_ON(irq != gpio_to_irq(button->gpio));
+
+	if (button->debounce_interval)
+		mod_timer(&bdata->timer,
+			jiffies + msecs_to_jiffies(button->debounce_interval));
+	else
+		schedule_work(&bdata->work);
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit gpio_keys_probe(struct platform_device *pdev)
+{
+	struct gpio_keys_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_keys_drvdata *ddata;
+	struct input_dev *input;
+	int i, error;
+	int wakeup = 0;
+
+	ddata = kzalloc(sizeof(struct gpio_keys_drvdata) +
+			pdata->nbuttons * sizeof(struct gpio_button_data),
+			GFP_KERNEL);
+	input = input_allocate_device();
+	if (!ddata || !input) {
+		error = -ENOMEM;
+		goto fail1;
+	}
+
+	platform_set_drvdata(pdev, ddata);
+
+	input->name = pdev->name;
+	input->phys = "gpio-keys/input0";
+	input->dev.parent = &pdev->dev;
+
+	input->id.bustype = BUS_HOST;
+	input->id.vendor = 0x0001;
+	input->id.product = 0x0001;
+	input->id.version = 0x0100;
+
+	/* Enable auto repeat feature of Linux input subsystem */
+	if (pdata->rep)
+		__set_bit(EV_REP, input->evbit);
+
+	ddata->input = input;
+
+	for (i = 0; i < pdata->nbuttons; i++) {
+		struct gpio_keys_button *button = &pdata->buttons[i];
+		struct gpio_button_data *bdata = &ddata->data[i];
+		int irq;
+		unsigned int type = button->type ?: EV_KEY;
+
+		bdata->input = input;
+		bdata->button = button;
+		setup_timer(&bdata->timer,
+			    gpio_keys_timer, (unsigned long)bdata);
+		INIT_WORK(&bdata->work, gpio_keys_report_event);
+
+		error = gpio_request(button->gpio, button->desc ?: "gpio_keys");
+		if (error < 0) {
+			pr_err("gpio-keys: failed to request GPIO %d,"
+				" error %d\n", button->gpio, error);
+			goto fail2;
+		}
+
+		error = gpio_direction_input(button->gpio);
+		if (error < 0) {
+			pr_err("gpio-keys: failed to configure input"
+				" direction for GPIO %d, error %d\n",
+				button->gpio, error);
+			gpio_free(button->gpio);
+			goto fail2;
+		}
+
+		irq = gpio_to_irq(button->gpio);
+		if (irq < 0) {
+			error = irq;
+			pr_err("gpio-keys: Unable to get irq number"
+				" for GPIO %d, error %d\n",
+				button->gpio, error);
+			gpio_free(button->gpio);
+			goto fail2;
+		}
+
+		error = request_irq(irq, gpio_keys_isr,
+				    IRQF_SHARED |
+				    IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW,
+				    button->desc ? button->desc : "gpio_keys",
+				    bdata);
+		if (error) {
+			pr_err("gpio-keys: Unable to claim irq %d; error %d\n",
+				irq, error);
+			gpio_free(button->gpio);
+			goto fail2;
+		}
+
+		if (button->wakeup)
+			wakeup = 1;
+
+		input_set_capability(input, type, button->code);
+	}
+
+	error = input_register_device(input);
+	if (error) {
+		pr_err("gpio-keys: Unable to register input device, "
+			"error: %d\n", error);
+		goto fail2;
+	}
+
+	device_init_wakeup(&pdev->dev, wakeup);
+
+	return 0;
+
+ fail2:
+	while (--i >= 0) {
+		free_irq(gpio_to_irq(pdata->buttons[i].gpio), &ddata->data[i]);
+		if (pdata->buttons[i].debounce_interval)
+			del_timer_sync(&ddata->data[i].timer);
+		cancel_work_sync(&ddata->data[i].work);
+		gpio_free(pdata->buttons[i].gpio);
+	}
+
+	platform_set_drvdata(pdev, NULL);
+ fail1:
+	input_free_device(input);
+	kfree(ddata);
+
+	return error;
+}
+
+static int __devexit gpio_keys_remove(struct platform_device *pdev)
+{
+	struct gpio_keys_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_keys_drvdata *ddata = platform_get_drvdata(pdev);
+	struct input_dev *input = ddata->input;
+	int i;
+
+	device_init_wakeup(&pdev->dev, 0);
+
+	for (i = 0; i < pdata->nbuttons; i++) {
+		int irq = gpio_to_irq(pdata->buttons[i].gpio);
+		free_irq(irq, &ddata->data[i]);
+		if (pdata->buttons[i].debounce_interval)
+			del_timer_sync(&ddata->data[i].timer);
+		cancel_work_sync(&ddata->data[i].work);
+		gpio_free(pdata->buttons[i].gpio);
+	}
+
+	input_unregister_device(input);
+
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+static int gpio_keys_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct gpio_keys_platform_data *pdata = pdev->dev.platform_data;
+	int i;
+
+	if (device_may_wakeup(&pdev->dev)) {
+		for (i = 0; i < pdata->nbuttons; i++) {
+			struct gpio_keys_button *button = &pdata->buttons[i];
+			if (button->wakeup) {
+				int irq = gpio_to_irq(button->gpio);
+				enable_irq_wake(irq);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int gpio_keys_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct gpio_keys_platform_data *pdata = pdev->dev.platform_data;
+	int i;
+
+	if (device_may_wakeup(&pdev->dev)) {
+		for (i = 0; i < pdata->nbuttons; i++) {
+			struct gpio_keys_button *button = &pdata->buttons[i];
+			if (button->wakeup) {
+				int irq = gpio_to_irq(button->gpio);
+				disable_irq_wake(irq);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops gpio_keys_pm_ops = {
+	.suspend	= gpio_keys_suspend,
+	.resume		= gpio_keys_resume,
+};
+#endif
+
+static struct platform_driver gpio_keys_device_driver = {
+	.probe		= gpio_keys_probe,
+	.remove		= __devexit_p(gpio_keys_remove),
+	.driver		= {
+		.name	= "gpio-keys",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm	= &gpio_keys_pm_ops,
+#endif
+	}
+};
+
+static int __init gpio_keys_init(void)
+{
+	return platform_driver_register(&gpio_keys_device_driver);
+}
+
+static void __exit gpio_keys_exit(void)
+{
+	platform_driver_unregister(&gpio_keys_device_driver);
+}
+
+module_init(gpio_keys_init);
+module_exit(gpio_keys_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Phil Blundell <pb@handhelds.org>");
+MODULE_DESCRIPTION("Keyboard driver for CPU GPIOs");
+MODULE_ALIAS("platform:gpio-keys");
diff -Nur linux-2.6.32-orig/drivers/input/keyboard/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/input/keyboard/Kconfig
--- linux-2.6.32-orig/drivers/input/keyboard/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/keyboard/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -180,6 +180,13 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called gpio_keys.
 
+config KEYBOARD_GPIO_IPHONE
+	tristate "GPIO Buttons for iPhone"
+	depends on GENERIC_GPIO
+	help
+	  Use flipping level GPIO interrupts rather than edge
+          interrupts.
+
 config KEYBOARD_MATRIX
 	tristate "GPIO driven matrix keypad support"
 	depends on GENERIC_GPIO
diff -Nur linux-2.6.32-orig/drivers/input/keyboard/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/input/keyboard/Makefile
--- linux-2.6.32-orig/drivers/input/keyboard/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/keyboard/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -13,6 +13,7 @@
 obj-$(CONFIG_KEYBOARD_CORGI)		+= corgikbd.o
 obj-$(CONFIG_KEYBOARD_EP93XX)		+= ep93xx_keypad.o
 obj-$(CONFIG_KEYBOARD_GPIO)		+= gpio_keys.o
+obj-$(CONFIG_KEYBOARD_GPIO_IPHONE)	+= iphone_gpio_keys.o
 obj-$(CONFIG_KEYBOARD_HIL)		+= hil_kbd.o
 obj-$(CONFIG_KEYBOARD_HIL_OLD)		+= hilkbd.o
 obj-$(CONFIG_KEYBOARD_HP6XX)		+= jornada680_kbd.o
diff -Nur linux-2.6.32-orig/drivers/input/keyreset.c iDroid-Project-kernel_common-9e90fd2/drivers/input/keyreset.c
--- linux-2.6.32-orig/drivers/input/keyreset.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/keyreset.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,229 @@
+/* drivers/input/keyreset.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/input.h>
+#include <linux/keyreset.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/reboot.h>
+#include <linux/sched.h>
+#include <linux/syscalls.h>
+
+
+struct keyreset_state {
+	struct input_handler input_handler;
+	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
+	unsigned long upbit[BITS_TO_LONGS(KEY_CNT)];
+	unsigned long key[BITS_TO_LONGS(KEY_CNT)];
+	spinlock_t lock;
+	int key_down_target;
+	int key_down;
+	int key_up;
+	int restart_disabled;
+};
+
+int restart_requested;
+static void deferred_restart(struct work_struct *dummy)
+{
+	restart_requested = 2;
+	sys_sync();
+	restart_requested = 3;
+	kernel_restart(NULL);
+}
+static DECLARE_WORK(restart_work, deferred_restart);
+
+static void keyreset_event(struct input_handle *handle, unsigned int type,
+			   unsigned int code, int value)
+{
+	unsigned long flags;
+	struct keyreset_state *state = handle->private;
+
+	if (type != EV_KEY)
+		return;
+
+	if (code >= KEY_MAX)
+		return;
+
+	if (!test_bit(code, state->keybit))
+		return;
+
+	spin_lock_irqsave(&state->lock, flags);
+	if (!test_bit(code, state->key) == !value)
+		goto done;
+	__change_bit(code, state->key);
+	if (test_bit(code, state->upbit)) {
+		if (value) {
+			state->restart_disabled = 1;
+			state->key_up++;
+		} else
+			state->key_up--;
+	} else {
+		if (value)
+			state->key_down++;
+		else
+			state->key_down--;
+	}
+	if (state->key_down == 0 && state->key_up == 0)
+		state->restart_disabled = 0;
+
+	pr_debug("reset key changed %d %d new state %d-%d-%d\n", code, value,
+		 state->key_down, state->key_up, state->restart_disabled);
+
+	if (value && !state->restart_disabled &&
+	    state->key_down == state->key_down_target) {
+		state->restart_disabled = 1;
+		if (restart_requested)
+			panic("keyboard reset failed, %d", restart_requested);
+		pr_info("keyboard reset\n");
+		schedule_work(&restart_work);
+		restart_requested = 1;
+	}
+done:
+	spin_unlock_irqrestore(&state->lock, flags);
+}
+
+static int keyreset_connect(struct input_handler *handler,
+					  struct input_dev *dev,
+					  const struct input_device_id *id)
+{
+	int i;
+	int ret;
+	struct input_handle *handle;
+	struct keyreset_state *state =
+		container_of(handler, struct keyreset_state, input_handler);
+
+	for (i = 0; i < KEY_MAX; i++) {
+		if (test_bit(i, state->keybit) && test_bit(i, dev->keybit))
+			break;
+	}
+	if (i == KEY_MAX)
+		return -ENODEV;
+
+	handle = kzalloc(sizeof(*handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = "keyreset";
+	handle->private = state;
+
+	ret = input_register_handle(handle);
+	if (ret)
+		goto err_input_register_handle;
+
+	ret = input_open_device(handle);
+	if (ret)
+		goto err_input_open_device;
+
+	pr_info("using input dev %s for key reset\n", dev->name);
+
+	return 0;
+
+err_input_open_device:
+	input_unregister_handle(handle);
+err_input_register_handle:
+	kfree(handle);
+	return ret;
+}
+
+static void keyreset_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+static const struct input_device_id keyreset_ids[] = {
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(input, keyreset_ids);
+
+static int keyreset_probe(struct platform_device *pdev)
+{
+	int ret;
+	int key, *keyp;
+	struct keyreset_state *state;
+	struct keyreset_platform_data *pdata = pdev->dev.platform_data;
+
+	if (!pdata)
+		return -EINVAL;
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+
+	spin_lock_init(&state->lock);
+	keyp = pdata->keys_down;
+	while ((key = *keyp++)) {
+		if (key >= KEY_MAX)
+			continue;
+		state->key_down_target++;
+		__set_bit(key, state->keybit);
+	}
+	if (pdata->keys_up) {
+		keyp = pdata->keys_up;
+		while ((key = *keyp++)) {
+			if (key >= KEY_MAX)
+				continue;
+			__set_bit(key, state->keybit);
+			__set_bit(key, state->upbit);
+		}
+	}
+	state->input_handler.event = keyreset_event;
+	state->input_handler.connect = keyreset_connect;
+	state->input_handler.disconnect = keyreset_disconnect;
+	state->input_handler.name = KEYRESET_NAME;
+	state->input_handler.id_table = keyreset_ids;
+	ret = input_register_handler(&state->input_handler);
+	if (ret) {
+		kfree(state);
+		return ret;
+	}
+	platform_set_drvdata(pdev, state);
+	return 0;
+}
+
+int keyreset_remove(struct platform_device *pdev)
+{
+	struct keyreset_state *state = platform_get_drvdata(pdev);
+	input_unregister_handler(&state->input_handler);
+	kfree(state);
+	return 0;
+}
+
+
+struct platform_driver keyreset_driver = {
+	.driver.name = KEYRESET_NAME,
+	.probe = keyreset_probe,
+	.remove = keyreset_remove,
+};
+
+static int __init keyreset_init(void)
+{
+	return platform_driver_register(&keyreset_driver);
+}
+
+static void __exit keyreset_exit(void)
+{
+	return platform_driver_unregister(&keyreset_driver);
+}
+
+module_init(keyreset_init);
+module_exit(keyreset_exit);
diff -Nur linux-2.6.32-orig/drivers/input/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/input/Makefile
--- linux-2.6.32-orig/drivers/input/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -23,5 +23,6 @@
 obj-$(CONFIG_INPUT_MISC)	+= misc/
 
 obj-$(CONFIG_INPUT_APMPOWER)	+= apm-power.o
+obj-$(CONFIG_INPUT_KEYRESET)	+= keyreset.o
 
 obj-$(CONFIG_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
diff -Nur linux-2.6.32-orig/drivers/input/misc/gpio_axis.c iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/gpio_axis.c
--- linux-2.6.32-orig/drivers/input/misc/gpio_axis.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/gpio_axis.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,191 @@
+/* drivers/input/misc/gpio_axis.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/interrupt.h>
+
+struct gpio_axis_state {
+	struct gpio_event_input_devs *input_devs;
+	struct gpio_event_axis_info *info;
+	uint32_t pos;
+};
+
+uint16_t gpio_axis_4bit_gray_map_table[] = {
+	[0x0] = 0x0, [0x1] = 0x1, /* 0000 0001 */
+	[0x3] = 0x2, [0x2] = 0x3, /* 0011 0010 */
+	[0x6] = 0x4, [0x7] = 0x5, /* 0110 0111 */
+	[0x5] = 0x6, [0x4] = 0x7, /* 0101 0100 */
+	[0xc] = 0x8, [0xd] = 0x9, /* 1100 1101 */
+	[0xf] = 0xa, [0xe] = 0xb, /* 1111 1110 */
+	[0xa] = 0xc, [0xb] = 0xd, /* 1010 1011 */
+	[0x9] = 0xe, [0x8] = 0xf, /* 1001 1000 */
+};
+uint16_t gpio_axis_4bit_gray_map(struct gpio_event_axis_info *info, uint16_t in)
+{
+	return gpio_axis_4bit_gray_map_table[in];
+}
+
+uint16_t gpio_axis_5bit_singletrack_map_table[] = {
+	[0x10] = 0x00, [0x14] = 0x01, [0x1c] = 0x02, /*     10000 10100 11100 */
+	[0x1e] = 0x03, [0x1a] = 0x04, [0x18] = 0x05, /*     11110 11010 11000 */
+	[0x08] = 0x06, [0x0a] = 0x07, [0x0e] = 0x08, /*    01000 01010 01110  */
+	[0x0f] = 0x09, [0x0d] = 0x0a, [0x0c] = 0x0b, /*    01111 01101 01100  */
+	[0x04] = 0x0c, [0x05] = 0x0d, [0x07] = 0x0e, /*   00100 00101 00111   */
+	[0x17] = 0x0f, [0x16] = 0x10, [0x06] = 0x11, /*   10111 10110 00110   */
+	[0x02] = 0x12, [0x12] = 0x13, [0x13] = 0x14, /*  00010 10010 10011    */
+	[0x1b] = 0x15, [0x0b] = 0x16, [0x03] = 0x17, /*  11011 01011 00011    */
+	[0x01] = 0x18, [0x09] = 0x19, [0x19] = 0x1a, /* 00001 01001 11001     */
+	[0x1d] = 0x1b, [0x15] = 0x1c, [0x11] = 0x1d, /* 11101 10101 10001     */
+};
+uint16_t gpio_axis_5bit_singletrack_map(
+	struct gpio_event_axis_info *info, uint16_t in)
+{
+	return gpio_axis_5bit_singletrack_map_table[in];
+}
+
+static void gpio_event_update_axis(struct gpio_axis_state *as, int report)
+{
+	struct gpio_event_axis_info *ai = as->info;
+	int i;
+	int change;
+	uint16_t state = 0;
+	uint16_t pos;
+	uint16_t old_pos = as->pos;
+	for (i = ai->count - 1; i >= 0; i--)
+		state = (state << 1) | gpio_get_value(ai->gpio[i]);
+	pos = ai->map(ai, state);
+	if (ai->flags & GPIOEAF_PRINT_RAW)
+		pr_info("axis %d-%d raw %x, pos %d -> %d\n",
+			ai->type, ai->code, state, old_pos, pos);
+	if (report && pos != old_pos) {
+		if (ai->type == EV_REL) {
+			change = (ai->decoded_size + pos - old_pos) %
+				  ai->decoded_size;
+			if (change > ai->decoded_size / 2)
+				change -= ai->decoded_size;
+			if (change == ai->decoded_size / 2) {
+				if (ai->flags & GPIOEAF_PRINT_EVENT)
+					pr_info("axis %d-%d unknown direction, "
+						"pos %d -> %d\n", ai->type,
+						ai->code, old_pos, pos);
+				change = 0; /* no closest direction */
+			}
+			if (ai->flags & GPIOEAF_PRINT_EVENT)
+				pr_info("axis %d-%d change %d\n",
+					ai->type, ai->code, change);
+			input_report_rel(as->input_devs->dev[ai->dev],
+						ai->code, change);
+		} else {
+			if (ai->flags & GPIOEAF_PRINT_EVENT)
+				pr_info("axis %d-%d now %d\n",
+					ai->type, ai->code, pos);
+			input_event(as->input_devs->dev[ai->dev],
+					ai->type, ai->code, pos);
+		}
+		input_sync(as->input_devs->dev[ai->dev]);
+	}
+	as->pos = pos;
+}
+
+static irqreturn_t gpio_axis_irq_handler(int irq, void *dev_id)
+{
+	struct gpio_axis_state *as = dev_id;
+	gpio_event_update_axis(as, 1);
+	return IRQ_HANDLED;
+}
+
+int gpio_event_axis_func(struct gpio_event_input_devs *input_devs,
+			 struct gpio_event_info *info, void **data, int func)
+{
+	int ret;
+	int i;
+	int irq;
+	struct gpio_event_axis_info *ai;
+	struct gpio_axis_state *as;
+
+	ai = container_of(info, struct gpio_event_axis_info, info);
+	if (func == GPIO_EVENT_FUNC_SUSPEND) {
+		for (i = 0; i < ai->count; i++)
+			disable_irq(gpio_to_irq(ai->gpio[i]));
+		return 0;
+	}
+	if (func == GPIO_EVENT_FUNC_RESUME) {
+		for (i = 0; i < ai->count; i++)
+			enable_irq(gpio_to_irq(ai->gpio[i]));
+		return 0;
+	}
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		*data = as = kmalloc(sizeof(*as), GFP_KERNEL);
+		if (as == NULL) {
+			ret = -ENOMEM;
+			goto err_alloc_axis_state_failed;
+		}
+		as->input_devs = input_devs;
+		as->info = ai;
+		if (ai->dev >= input_devs->count) {
+			pr_err("gpio_event_axis: bad device index %d >= %d "
+				"for %d:%d\n", ai->dev, input_devs->count,
+				ai->type, ai->code);
+			ret = -EINVAL;
+			goto err_bad_device_index;
+		}
+
+		input_set_capability(input_devs->dev[ai->dev],
+				     ai->type, ai->code);
+		if (ai->type == EV_ABS) {
+			input_set_abs_params(input_devs->dev[ai->dev], ai->code,
+					     0, ai->decoded_size - 1, 0, 0);
+		}
+		for (i = 0; i < ai->count; i++) {
+			ret = gpio_request(ai->gpio[i], "gpio_event_axis");
+			if (ret < 0)
+				goto err_request_gpio_failed;
+			ret = gpio_direction_input(ai->gpio[i]);
+			if (ret < 0)
+				goto err_gpio_direction_input_failed;
+			ret = irq = gpio_to_irq(ai->gpio[i]);
+			if (ret < 0)
+				goto err_get_irq_num_failed;
+			ret = request_irq(irq, gpio_axis_irq_handler,
+					  IRQF_TRIGGER_RISING |
+					  IRQF_TRIGGER_FALLING,
+					  "gpio_event_axis", as);
+			if (ret < 0)
+				goto err_request_irq_failed;
+		}
+		gpio_event_update_axis(as, 0);
+		return 0;
+	}
+
+	ret = 0;
+	as = *data;
+	for (i = ai->count - 1; i >= 0; i--) {
+		free_irq(gpio_to_irq(ai->gpio[i]), as);
+err_request_irq_failed:
+err_get_irq_num_failed:
+err_gpio_direction_input_failed:
+		gpio_free(ai->gpio[i]);
+err_request_gpio_failed:
+		;
+	}
+err_bad_device_index:
+	kfree(as);
+	*data = NULL;
+err_alloc_axis_state_failed:
+	return ret;
+}
diff -Nur linux-2.6.32-orig/drivers/input/misc/gpio_event.c iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/gpio_event.c
--- linux-2.6.32-orig/drivers/input/misc/gpio_event.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/gpio_event.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,259 @@
+/* drivers/input/misc/gpio_event.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/earlysuspend.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/gpio_event.h>
+#include <linux/hrtimer.h>
+#include <linux/platform_device.h>
+
+struct gpio_event {
+	struct gpio_event_input_devs *input_devs;
+	const struct gpio_event_platform_data *info;
+	struct early_suspend early_suspend;
+	void *state[0];
+};
+
+static int gpio_input_event(
+	struct input_dev *dev, unsigned int type, unsigned int code, int value)
+{
+	int i;
+	int devnr;
+	int ret = 0;
+	int tmp_ret;
+	struct gpio_event_info **ii;
+	struct gpio_event *ip = input_get_drvdata(dev);
+
+	for (devnr = 0; devnr < ip->input_devs->count; devnr++)
+		if (ip->input_devs->dev[devnr] == dev)
+			break;
+	if (devnr == ip->input_devs->count) {
+		pr_err("gpio_input_event: unknown device %p\n", dev);
+		return -EIO;
+	}
+
+	for (i = 0, ii = ip->info->info; i < ip->info->info_count; i++, ii++) {
+		if ((*ii)->event) {
+			tmp_ret = (*ii)->event(ip->input_devs, *ii,
+						&ip->state[i],
+						devnr, type, code, value);
+			if (tmp_ret)
+				ret = tmp_ret;
+		}
+	}
+	return ret;
+}
+
+static int gpio_event_call_all_func(struct gpio_event *ip, int func)
+{
+	int i;
+	int ret;
+	struct gpio_event_info **ii;
+
+	if (func == GPIO_EVENT_FUNC_INIT || func == GPIO_EVENT_FUNC_RESUME) {
+		ii = ip->info->info;
+		for (i = 0; i < ip->info->info_count; i++, ii++) {
+			if ((*ii)->func == NULL) {
+				ret = -ENODEV;
+				pr_err("gpio_event_probe: Incomplete pdata, "
+					"no function\n");
+				goto err_no_func;
+			}
+			if (func == GPIO_EVENT_FUNC_RESUME && (*ii)->no_suspend)
+				continue;
+			ret = (*ii)->func(ip->input_devs, *ii, &ip->state[i],
+					  func);
+			if (ret) {
+				pr_err("gpio_event_probe: function failed\n");
+				goto err_func_failed;
+			}
+		}
+		return 0;
+	}
+
+	ret = 0;
+	i = ip->info->info_count;
+	ii = ip->info->info + i;
+	while (i > 0) {
+		i--;
+		ii--;
+		if ((func & ~1) == GPIO_EVENT_FUNC_SUSPEND && (*ii)->no_suspend)
+			continue;
+		(*ii)->func(ip->input_devs, *ii, &ip->state[i], func & ~1);
+err_func_failed:
+err_no_func:
+		;
+	}
+	return ret;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void gpio_event_suspend(struct early_suspend *h)
+{
+	struct gpio_event *ip;
+	ip = container_of(h, struct gpio_event, early_suspend);
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_SUSPEND);
+	ip->info->power(ip->info, 0);
+}
+
+void gpio_event_resume(struct early_suspend *h)
+{
+	struct gpio_event *ip;
+	ip = container_of(h, struct gpio_event, early_suspend);
+	ip->info->power(ip->info, 1);
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_RESUME);
+}
+#endif
+
+static int __init gpio_event_probe(struct platform_device *pdev)
+{
+	int err;
+	struct gpio_event *ip;
+	struct gpio_event_platform_data *event_info;
+	int dev_count = 1;
+	int i;
+	int registered = 0;
+
+	event_info = pdev->dev.platform_data;
+	if (event_info == NULL) {
+		pr_err("gpio_event_probe: No pdata\n");
+		return -ENODEV;
+	}
+	if ((!event_info->name && !event_info->names[0]) ||
+	    !event_info->info || !event_info->info_count) {
+		pr_err("gpio_event_probe: Incomplete pdata\n");
+		return -ENODEV;
+	}
+	if (!event_info->name)
+		while (event_info->names[dev_count])
+			dev_count++;
+	ip = kzalloc(sizeof(*ip) +
+		     sizeof(ip->state[0]) * event_info->info_count +
+		     sizeof(*ip->input_devs) +
+		     sizeof(ip->input_devs->dev[0]) * dev_count, GFP_KERNEL);
+	if (ip == NULL) {
+		err = -ENOMEM;
+		pr_err("gpio_event_probe: Failed to allocate private data\n");
+		goto err_kp_alloc_failed;
+	}
+	ip->input_devs = (void*)&ip->state[event_info->info_count];
+	platform_set_drvdata(pdev, ip);
+
+	for (i = 0; i < dev_count; i++) {
+		struct input_dev *input_dev = input_allocate_device();
+		if (input_dev == NULL) {
+			err = -ENOMEM;
+			pr_err("gpio_event_probe: "
+				"Failed to allocate input device\n");
+			goto err_input_dev_alloc_failed;
+		}
+		input_set_drvdata(input_dev, ip);
+		input_dev->name = event_info->name ?
+					event_info->name : event_info->names[i];
+		input_dev->event = gpio_input_event;
+		ip->input_devs->dev[i] = input_dev;
+	}
+	ip->input_devs->count = dev_count;
+	ip->info = event_info;
+	if (event_info->power) {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+		ip->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+		ip->early_suspend.suspend = gpio_event_suspend;
+		ip->early_suspend.resume = gpio_event_resume;
+		register_early_suspend(&ip->early_suspend);
+#endif
+		ip->info->power(ip->info, 1);
+	}
+
+	err = gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_INIT);
+	if (err)
+		goto err_call_all_func_failed;
+
+	for (i = 0; i < dev_count; i++) {
+		err = input_register_device(ip->input_devs->dev[i]);
+		if (err) {
+			pr_err("gpio_event_probe: Unable to register %s "
+				"input device\n", ip->input_devs->dev[i]->name);
+			goto err_input_register_device_failed;
+		}
+		registered++;
+	}
+
+	return 0;
+
+err_input_register_device_failed:
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_UNINIT);
+err_call_all_func_failed:
+	if (event_info->power) {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&ip->early_suspend);
+#endif
+		ip->info->power(ip->info, 0);
+	}
+	for (i = 0; i < registered; i++)
+		input_unregister_device(ip->input_devs->dev[i]);
+	for (i = dev_count - 1; i >= registered; i--) {
+		input_free_device(ip->input_devs->dev[i]);
+err_input_dev_alloc_failed:
+		;
+	}
+	kfree(ip);
+err_kp_alloc_failed:
+	return err;
+}
+
+static int gpio_event_remove(struct platform_device *pdev)
+{
+	struct gpio_event *ip = platform_get_drvdata(pdev);
+	int i;
+
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_UNINIT);
+	if (ip->info->power) {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&ip->early_suspend);
+#endif
+		ip->info->power(ip->info, 0);
+	}
+	for (i = 0; i < ip->input_devs->count; i++)
+		input_unregister_device(ip->input_devs->dev[i]);
+	kfree(ip);
+	return 0;
+}
+
+static struct platform_driver gpio_event_driver = {
+	.probe		= gpio_event_probe,
+	.remove		= gpio_event_remove,
+	.driver		= {
+		.name	= GPIO_EVENT_DEV_NAME,
+	},
+};
+
+static int __devinit gpio_event_init(void)
+{
+	return platform_driver_register(&gpio_event_driver);
+}
+
+static void __exit gpio_event_exit(void)
+{
+	platform_driver_unregister(&gpio_event_driver);
+}
+
+module_init(gpio_event_init);
+module_exit(gpio_event_exit);
+
+MODULE_DESCRIPTION("GPIO Event Driver");
+MODULE_LICENSE("GPL");
+
diff -Nur linux-2.6.32-orig/drivers/input/misc/gpio_input.c iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/gpio_input.c
--- linux-2.6.32-orig/drivers/input/misc/gpio_input.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/gpio_input.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,352 @@
+/* drivers/input/misc/gpio_input.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/wakelock.h>
+
+enum {
+	DEBOUNCE_UNSTABLE     = BIT(0),	/* Got irq, while debouncing */
+	DEBOUNCE_PRESSED      = BIT(1),
+	DEBOUNCE_NOTPRESSED   = BIT(2),
+	DEBOUNCE_WAIT_IRQ     = BIT(3),	/* Stable irq state */
+	DEBOUNCE_POLL         = BIT(4),	/* Stable polling state */
+
+	DEBOUNCE_UNKNOWN =
+		DEBOUNCE_PRESSED | DEBOUNCE_NOTPRESSED,
+};
+
+struct gpio_key_state {
+	struct gpio_input_state *ds;
+	uint8_t debounce;
+};
+
+struct gpio_input_state {
+	struct gpio_event_input_devs *input_devs;
+	const struct gpio_event_input_info *info;
+	struct hrtimer timer;
+	int use_irq;
+	int debounce_count;
+	spinlock_t irq_lock;
+	struct wake_lock wake_lock;
+	struct gpio_key_state key_state[0];
+};
+
+static enum hrtimer_restart gpio_event_input_timer_func(struct hrtimer *timer)
+{
+	int i;
+	int pressed;
+	struct gpio_input_state *ds =
+		container_of(timer, struct gpio_input_state, timer);
+	unsigned gpio_flags = ds->info->flags;
+	unsigned npolarity;
+	int nkeys = ds->info->keymap_size;
+	const struct gpio_event_direct_entry *key_entry;
+	struct gpio_key_state *key_state;
+	unsigned long irqflags;
+	uint8_t debounce;
+
+#if 0
+	key_entry = kp->keys_info->keymap;
+	key_state = kp->key_state;
+	for (i = 0; i < nkeys; i++, key_entry++, key_state++)
+		pr_info("gpio_read_detect_status %d %d\n", key_entry->gpio,
+			gpio_read_detect_status(key_entry->gpio));
+#endif
+	key_entry = ds->info->keymap;
+	key_state = ds->key_state;
+	spin_lock_irqsave(&ds->irq_lock, irqflags);
+	for (i = 0; i < nkeys; i++, key_entry++, key_state++) {
+		debounce = key_state->debounce;
+		if (debounce & DEBOUNCE_WAIT_IRQ)
+			continue;
+		if (key_state->debounce & DEBOUNCE_UNSTABLE) {
+			debounce = key_state->debounce = DEBOUNCE_UNKNOWN;
+			enable_irq(gpio_to_irq(key_entry->gpio));
+			pr_info("gpio_keys_scan_keys: key %x-%x, %d "
+				"(%d) continue debounce\n",
+				ds->info->type, key_entry->code,
+				i, key_entry->gpio);
+		}
+		npolarity = !(gpio_flags & GPIOEDF_ACTIVE_HIGH);
+		pressed = gpio_get_value(key_entry->gpio) ^ npolarity;
+		if (debounce & DEBOUNCE_POLL) {
+			if (pressed == !(debounce & DEBOUNCE_PRESSED)) {
+				ds->debounce_count++;
+				key_state->debounce = DEBOUNCE_UNKNOWN;
+				if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+					pr_info("gpio_keys_scan_keys: key %x-"
+						"%x, %d (%d) start debounce\n",
+						ds->info->type, key_entry->code,
+						i, key_entry->gpio);
+			}
+			continue;
+		}
+		if (pressed && (debounce & DEBOUNCE_NOTPRESSED)) {
+			if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+				pr_info("gpio_keys_scan_keys: key %x-%x, %d "
+					"(%d) debounce pressed 1\n",
+					ds->info->type, key_entry->code,
+					i, key_entry->gpio);
+			key_state->debounce = DEBOUNCE_PRESSED;
+			continue;
+		}
+		if (!pressed && (debounce & DEBOUNCE_PRESSED)) {
+			if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+				pr_info("gpio_keys_scan_keys: key %x-%x, %d "
+					"(%d) debounce pressed 0\n",
+					ds->info->type, key_entry->code,
+					i, key_entry->gpio);
+			key_state->debounce = DEBOUNCE_NOTPRESSED;
+			continue;
+		}
+		/* key is stable */
+		ds->debounce_count--;
+		if (ds->use_irq)
+			key_state->debounce |= DEBOUNCE_WAIT_IRQ;
+		else
+			key_state->debounce |= DEBOUNCE_POLL;
+		if (gpio_flags & GPIOEDF_PRINT_KEYS)
+			pr_info("gpio_keys_scan_keys: key %x-%x, %d (%d) "
+				"changed to %d\n", ds->info->type,
+				key_entry->code, i, key_entry->gpio, pressed);
+		input_event(ds->input_devs->dev[key_entry->dev], ds->info->type,
+			    key_entry->code, pressed);
+	}
+
+#if 0
+	key_entry = kp->keys_info->keymap;
+	key_state = kp->key_state;
+	for (i = 0; i < nkeys; i++, key_entry++, key_state++) {
+		pr_info("gpio_read_detect_status %d %d\n", key_entry->gpio,
+			gpio_read_detect_status(key_entry->gpio));
+	}
+#endif
+
+	if (ds->debounce_count)
+		hrtimer_start(timer, ds->info->debounce_time, HRTIMER_MODE_REL);
+	else if (!ds->use_irq)
+		hrtimer_start(timer, ds->info->poll_time, HRTIMER_MODE_REL);
+	else
+		wake_unlock(&ds->wake_lock);
+
+	spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t gpio_event_input_irq_handler(int irq, void *dev_id)
+{
+	struct gpio_key_state *ks = dev_id;
+	struct gpio_input_state *ds = ks->ds;
+	int keymap_index = ks - ds->key_state;
+	const struct gpio_event_direct_entry *key_entry;
+	unsigned long irqflags;
+	int pressed;
+
+	if (!ds->use_irq)
+		return IRQ_HANDLED;
+
+	key_entry = &ds->info->keymap[keymap_index];
+
+	if (ds->info->debounce_time.tv64) {
+		spin_lock_irqsave(&ds->irq_lock, irqflags);
+		if (ks->debounce & DEBOUNCE_WAIT_IRQ) {
+			ks->debounce = DEBOUNCE_UNKNOWN;
+			if (ds->debounce_count++ == 0) {
+				wake_lock(&ds->wake_lock);
+				hrtimer_start(
+					&ds->timer, ds->info->debounce_time,
+					HRTIMER_MODE_REL);
+			}
+			if (ds->info->flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+				pr_info("gpio_event_input_irq_handler: "
+					"key %x-%x, %d (%d) start debounce\n",
+					ds->info->type, key_entry->code,
+					keymap_index, key_entry->gpio);
+		} else {
+			disable_irq_nosync(irq);
+			ks->debounce = DEBOUNCE_UNSTABLE;
+		}
+		spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+	} else {
+		pressed = gpio_get_value(key_entry->gpio) ^
+			!(ds->info->flags & GPIOEDF_ACTIVE_HIGH);
+		if (ds->info->flags & GPIOEDF_PRINT_KEYS)
+			pr_info("gpio_event_input_irq_handler: key %x-%x, %d "
+				"(%d) changed to %d\n",
+				ds->info->type, key_entry->code, keymap_index,
+				key_entry->gpio, pressed);
+		input_event(ds->input_devs->dev[key_entry->dev], ds->info->type,
+			    key_entry->code, pressed);
+	}
+	return IRQ_HANDLED;
+}
+
+static int gpio_event_input_request_irqs(struct gpio_input_state *ds)
+{
+	int i;
+	int err;
+	unsigned int irq;
+	unsigned long req_flags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;
+
+	for (i = 0; i < ds->info->keymap_size; i++) {
+		err = irq = gpio_to_irq(ds->info->keymap[i].gpio);
+		if (err < 0)
+			goto err_gpio_get_irq_num_failed;
+		err = request_irq(irq, gpio_event_input_irq_handler,
+				  req_flags, "gpio_keys", &ds->key_state[i]);
+		if (err) {
+			pr_err("gpio_event_input_request_irqs: request_irq "
+				"failed for input %d, irq %d\n",
+				ds->info->keymap[i].gpio, irq);
+			goto err_request_irq_failed;
+		}
+		enable_irq_wake(irq);
+	}
+	return 0;
+
+	for (i = ds->info->keymap_size - 1; i >= 0; i--) {
+		free_irq(gpio_to_irq(ds->info->keymap[i].gpio),
+			 &ds->key_state[i]);
+err_request_irq_failed:
+err_gpio_get_irq_num_failed:
+		;
+	}
+	return err;
+}
+
+int gpio_event_input_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func)
+{
+	int ret;
+	int i;
+	unsigned long irqflags;
+	struct gpio_event_input_info *di;
+	struct gpio_input_state *ds = *data;
+
+	di = container_of(info, struct gpio_event_input_info, info);
+
+	if (func == GPIO_EVENT_FUNC_SUSPEND) {
+		if (ds->use_irq)
+			for (i = 0; i < di->keymap_size; i++)
+				disable_irq(gpio_to_irq(di->keymap[i].gpio));
+		hrtimer_cancel(&ds->timer);
+		return 0;
+	}
+	if (func == GPIO_EVENT_FUNC_RESUME) {
+		spin_lock_irqsave(&ds->irq_lock, irqflags);
+		if (ds->use_irq)
+			for (i = 0; i < di->keymap_size; i++)
+				enable_irq(gpio_to_irq(di->keymap[i].gpio));
+		hrtimer_start(&ds->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+		spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+		return 0;
+	}
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		if (ktime_to_ns(di->poll_time) <= 0)
+			di->poll_time = ktime_set(0, 20 * NSEC_PER_MSEC);
+
+		*data = ds = kzalloc(sizeof(*ds) + sizeof(ds->key_state[0]) *
+					di->keymap_size, GFP_KERNEL);
+		if (ds == NULL) {
+			ret = -ENOMEM;
+			pr_err("gpio_event_input_func: "
+				"Failed to allocate private data\n");
+			goto err_ds_alloc_failed;
+		}
+		ds->debounce_count = di->keymap_size;
+		ds->input_devs = input_devs;
+		ds->info = di;
+		wake_lock_init(&ds->wake_lock, WAKE_LOCK_SUSPEND, "gpio_input");
+		spin_lock_init(&ds->irq_lock);
+
+		for (i = 0; i < di->keymap_size; i++) {
+			int dev = di->keymap[i].dev;
+			if (dev >= input_devs->count) {
+				pr_err("gpio_event_input_func: bad device "
+					"index %d >= %d for key code %d\n",
+					dev, input_devs->count,
+					di->keymap[i].code);
+				ret = -EINVAL;
+				goto err_bad_keymap;
+			}
+			input_set_capability(input_devs->dev[dev], di->type,
+					     di->keymap[i].code);
+			ds->key_state[i].ds = ds;
+			ds->key_state[i].debounce = DEBOUNCE_UNKNOWN;
+		}
+
+		for (i = 0; i < di->keymap_size; i++) {
+			ret = gpio_request(di->keymap[i].gpio, "gpio_kp_in");
+			if (ret) {
+				pr_err("gpio_event_input_func: gpio_request "
+					"failed for %d\n", di->keymap[i].gpio);
+				goto err_gpio_request_failed;
+			}
+			ret = gpio_direction_input(di->keymap[i].gpio);
+			if (ret) {
+				pr_err("gpio_event_input_func: "
+					"gpio_direction_input failed for %d\n",
+					di->keymap[i].gpio);
+				goto err_gpio_configure_failed;
+			}
+		}
+
+		ret = gpio_event_input_request_irqs(ds);
+
+		spin_lock_irqsave(&ds->irq_lock, irqflags);
+		ds->use_irq = ret == 0;
+
+		pr_info("GPIO Input Driver: Start gpio inputs for %s%s in %s "
+			"mode\n", input_devs->dev[0]->name,
+			(input_devs->count > 1) ? "..." : "",
+			ret == 0 ? "interrupt" : "polling");
+
+		hrtimer_init(&ds->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ds->timer.function = gpio_event_input_timer_func;
+		hrtimer_start(&ds->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+		spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+		return 0;
+	}
+
+	ret = 0;
+	spin_lock_irqsave(&ds->irq_lock, irqflags);
+	hrtimer_cancel(&ds->timer);
+	if (ds->use_irq) {
+		for (i = di->keymap_size - 1; i >= 0; i--) {
+			free_irq(gpio_to_irq(di->keymap[i].gpio),
+				 &ds->key_state[i]);
+		}
+	}
+	spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+
+	for (i = di->keymap_size - 1; i >= 0; i--) {
+err_gpio_configure_failed:
+		gpio_free(di->keymap[i].gpio);
+err_gpio_request_failed:
+		;
+	}
+err_bad_keymap:
+	wake_lock_destroy(&ds->wake_lock);
+	kfree(ds);
+err_ds_alloc_failed:
+	return ret;
+}
diff -Nur linux-2.6.32-orig/drivers/input/misc/gpio_matrix.c iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/gpio_matrix.c
--- linux-2.6.32-orig/drivers/input/misc/gpio_matrix.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/gpio_matrix.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,422 @@
+/* drivers/input/misc/gpio_matrix.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/hrtimer.h>
+#include <linux/interrupt.h>
+#include <linux/wakelock.h>
+
+struct gpio_kp {
+	struct gpio_event_input_devs *input_devs;
+	struct gpio_event_matrix_info *keypad_info;
+	struct hrtimer timer;
+	struct wake_lock wake_lock;
+	int current_output;
+	unsigned int use_irq:1;
+	unsigned int key_state_changed:1;
+	unsigned int last_key_state_changed:1;
+	unsigned int some_keys_pressed:2;
+	unsigned long keys_pressed[0];
+};
+
+static void clear_phantom_key(struct gpio_kp *kp, int out, int in)
+{
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	int key_index = out * mi->ninputs + in;
+	unsigned short keyentry = mi->keymap[key_index];
+	unsigned short keycode = keyentry & MATRIX_KEY_MASK;
+	unsigned short dev = keyentry >> MATRIX_CODE_BITS;
+
+	if (!test_bit(keycode, kp->input_devs->dev[dev]->key)) {
+		if (mi->flags & GPIOKPF_PRINT_PHANTOM_KEYS)
+			pr_info("gpiomatrix: phantom key %x, %d-%d (%d-%d) "
+				"cleared\n", keycode, out, in,
+				mi->output_gpios[out], mi->input_gpios[in]);
+		__clear_bit(key_index, kp->keys_pressed);
+	} else {
+		if (mi->flags & GPIOKPF_PRINT_PHANTOM_KEYS)
+			pr_info("gpiomatrix: phantom key %x, %d-%d (%d-%d) "
+				"not cleared\n", keycode, out, in,
+				mi->output_gpios[out], mi->input_gpios[in]);
+	}
+}
+
+static int restore_keys_for_input(struct gpio_kp *kp, int out, int in)
+{
+	int rv = 0;
+	int key_index;
+
+	key_index = out * kp->keypad_info->ninputs + in;
+	while (out < kp->keypad_info->noutputs) {
+		if (test_bit(key_index, kp->keys_pressed)) {
+			rv = 1;
+			clear_phantom_key(kp, out, in);
+		}
+		key_index += kp->keypad_info->ninputs;
+		out++;
+	}
+	return rv;
+}
+
+static void remove_phantom_keys(struct gpio_kp *kp)
+{
+	int out, in, inp;
+	int key_index;
+
+	if (kp->some_keys_pressed < 3)
+		return;
+
+	for (out = 0; out < kp->keypad_info->noutputs; out++) {
+		inp = -1;
+		key_index = out * kp->keypad_info->ninputs;
+		for (in = 0; in < kp->keypad_info->ninputs; in++, key_index++) {
+			if (test_bit(key_index, kp->keys_pressed)) {
+				if (inp == -1) {
+					inp = in;
+					continue;
+				}
+				if (inp >= 0) {
+					if (!restore_keys_for_input(kp, out + 1,
+									inp))
+						break;
+					clear_phantom_key(kp, out, inp);
+					inp = -2;
+				}
+				restore_keys_for_input(kp, out, in);
+			}
+		}
+	}
+}
+
+static void report_key(struct gpio_kp *kp, int key_index, int out, int in)
+{
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	int pressed = test_bit(key_index, kp->keys_pressed);
+	unsigned short keyentry = mi->keymap[key_index];
+	unsigned short keycode = keyentry & MATRIX_KEY_MASK;
+	unsigned short dev = keyentry >> MATRIX_CODE_BITS;
+
+	if (pressed != test_bit(keycode, kp->input_devs->dev[dev]->key)) {
+		if (keycode == KEY_RESERVED) {
+			if (mi->flags & GPIOKPF_PRINT_UNMAPPED_KEYS)
+				pr_info("gpiomatrix: unmapped key, %d-%d "
+					"(%d-%d) changed to %d\n",
+					out, in, mi->output_gpios[out],
+					mi->input_gpios[in], pressed);
+		} else {
+			if (mi->flags & GPIOKPF_PRINT_MAPPED_KEYS)
+				pr_info("gpiomatrix: key %x, %d-%d (%d-%d) "
+					"changed to %d\n", keycode,
+					out, in, mi->output_gpios[out],
+					mi->input_gpios[in], pressed);
+			input_report_key(kp->input_devs->dev[dev], keycode, pressed);
+		}
+	}
+}
+
+static enum hrtimer_restart gpio_keypad_timer_func(struct hrtimer *timer)
+{
+	int out, in;
+	int key_index;
+	int gpio;
+	struct gpio_kp *kp = container_of(timer, struct gpio_kp, timer);
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	unsigned gpio_keypad_flags = mi->flags;
+	unsigned polarity = !!(gpio_keypad_flags & GPIOKPF_ACTIVE_HIGH);
+
+	out = kp->current_output;
+	if (out == mi->noutputs) {
+		out = 0;
+		kp->last_key_state_changed = kp->key_state_changed;
+		kp->key_state_changed = 0;
+		kp->some_keys_pressed = 0;
+	} else {
+		key_index = out * mi->ninputs;
+		for (in = 0; in < mi->ninputs; in++, key_index++) {
+			gpio = mi->input_gpios[in];
+			if (gpio_get_value(gpio) ^ !polarity) {
+				if (kp->some_keys_pressed < 3)
+					kp->some_keys_pressed++;
+				kp->key_state_changed |= !__test_and_set_bit(
+						key_index, kp->keys_pressed);
+			} else
+				kp->key_state_changed |= __test_and_clear_bit(
+						key_index, kp->keys_pressed);
+		}
+		gpio = mi->output_gpios[out];
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(gpio, !polarity);
+		else
+			gpio_direction_input(gpio);
+		out++;
+	}
+	kp->current_output = out;
+	if (out < mi->noutputs) {
+		gpio = mi->output_gpios[out];
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(gpio, polarity);
+		else
+			gpio_direction_output(gpio, polarity);
+		hrtimer_start(timer, mi->settle_time, HRTIMER_MODE_REL);
+		return HRTIMER_NORESTART;
+	}
+	if (gpio_keypad_flags & GPIOKPF_DEBOUNCE) {
+		if (kp->key_state_changed) {
+			hrtimer_start(&kp->timer, mi->debounce_delay,
+				      HRTIMER_MODE_REL);
+			return HRTIMER_NORESTART;
+		}
+		kp->key_state_changed = kp->last_key_state_changed;
+	}
+	if (kp->key_state_changed) {
+		if (gpio_keypad_flags & GPIOKPF_REMOVE_SOME_PHANTOM_KEYS)
+			remove_phantom_keys(kp);
+		key_index = 0;
+		for (out = 0; out < mi->noutputs; out++)
+			for (in = 0; in < mi->ninputs; in++, key_index++)
+				report_key(kp, key_index, out, in);
+	}
+	if (!kp->use_irq || kp->some_keys_pressed) {
+		hrtimer_start(timer, mi->poll_time, HRTIMER_MODE_REL);
+		return HRTIMER_NORESTART;
+	}
+
+	/* No keys are pressed, reenable interrupt */
+	for (out = 0; out < mi->noutputs; out++) {
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(mi->output_gpios[out], polarity);
+		else
+			gpio_direction_output(mi->output_gpios[out], polarity);
+	}
+	for (in = 0; in < mi->ninputs; in++)
+		enable_irq(gpio_to_irq(mi->input_gpios[in]));
+	wake_unlock(&kp->wake_lock);
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t gpio_keypad_irq_handler(int irq_in, void *dev_id)
+{
+	int i;
+	struct gpio_kp *kp = dev_id;
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	unsigned gpio_keypad_flags = mi->flags;
+
+	if (!kp->use_irq) /* ignore interrupt while registering the handler */
+		return IRQ_HANDLED;
+
+	for (i = 0; i < mi->ninputs; i++)
+		disable_irq_nosync(gpio_to_irq(mi->input_gpios[i]));
+	for (i = 0; i < mi->noutputs; i++) {
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(mi->output_gpios[i],
+				!(gpio_keypad_flags & GPIOKPF_ACTIVE_HIGH));
+		else
+			gpio_direction_input(mi->output_gpios[i]);
+	}
+	wake_lock(&kp->wake_lock);
+	hrtimer_start(&kp->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+	return IRQ_HANDLED;
+}
+
+static int gpio_keypad_request_irqs(struct gpio_kp *kp)
+{
+	int i;
+	int err;
+	unsigned int irq;
+	unsigned long request_flags;
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+
+	switch (mi->flags & (GPIOKPF_ACTIVE_HIGH|GPIOKPF_LEVEL_TRIGGERED_IRQ)) {
+	default:
+		request_flags = IRQF_TRIGGER_FALLING;
+		break;
+	case GPIOKPF_ACTIVE_HIGH:
+		request_flags = IRQF_TRIGGER_RISING;
+		break;
+	case GPIOKPF_LEVEL_TRIGGERED_IRQ:
+		request_flags = IRQF_TRIGGER_LOW;
+		break;
+	case GPIOKPF_LEVEL_TRIGGERED_IRQ | GPIOKPF_ACTIVE_HIGH:
+		request_flags = IRQF_TRIGGER_HIGH;
+		break;
+	}
+
+	for (i = 0; i < mi->ninputs; i++) {
+		err = irq = gpio_to_irq(mi->input_gpios[i]);
+		if (err < 0)
+			goto err_gpio_get_irq_num_failed;
+		err = request_irq(irq, gpio_keypad_irq_handler, request_flags,
+				  "gpio_kp", kp);
+		if (err) {
+			pr_err("gpiomatrix: request_irq failed for input %d, "
+				"irq %d\n", mi->input_gpios[i], irq);
+			goto err_request_irq_failed;
+		}
+		err = set_irq_wake(irq, 1);
+		if (err) {
+			pr_err("gpiomatrix: set_irq_wake failed for input %d, "
+				"irq %d\n", mi->input_gpios[i], irq);
+		}
+		disable_irq(irq);
+	}
+	return 0;
+
+	for (i = mi->noutputs - 1; i >= 0; i--) {
+		free_irq(gpio_to_irq(mi->input_gpios[i]), kp);
+err_request_irq_failed:
+err_gpio_get_irq_num_failed:
+		;
+	}
+	return err;
+}
+
+int gpio_event_matrix_func(struct gpio_event_input_devs *input_devs,
+	struct gpio_event_info *info, void **data, int func)
+{
+	int i;
+	int err;
+	int key_count;
+	struct gpio_kp *kp;
+	struct gpio_event_matrix_info *mi;
+
+	mi = container_of(info, struct gpio_event_matrix_info, info);
+	if (func == GPIO_EVENT_FUNC_SUSPEND || func == GPIO_EVENT_FUNC_RESUME) {
+		/* TODO: disable scanning */
+		return 0;
+	}
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		if (mi->keymap == NULL ||
+		   mi->input_gpios == NULL ||
+		   mi->output_gpios == NULL) {
+			err = -ENODEV;
+			pr_err("gpiomatrix: Incomplete pdata\n");
+			goto err_invalid_platform_data;
+		}
+		key_count = mi->ninputs * mi->noutputs;
+
+		*data = kp = kzalloc(sizeof(*kp) + sizeof(kp->keys_pressed[0]) *
+				     BITS_TO_LONGS(key_count), GFP_KERNEL);
+		if (kp == NULL) {
+			err = -ENOMEM;
+			pr_err("gpiomatrix: Failed to allocate private data\n");
+			goto err_kp_alloc_failed;
+		}
+		kp->input_devs = input_devs;
+		kp->keypad_info = mi;
+		for (i = 0; i < key_count; i++) {
+			unsigned short keyentry = mi->keymap[i];
+			unsigned short keycode = keyentry & MATRIX_KEY_MASK;
+			unsigned short dev = keyentry >> MATRIX_CODE_BITS;
+			if (dev >= input_devs->count) {
+				pr_err("gpiomatrix: bad device index %d >= "
+					"%d for key code %d\n",
+					dev, input_devs->count, keycode);
+				err = -EINVAL;
+				goto err_bad_keymap;
+			}
+			if (keycode && keycode <= KEY_MAX)
+				input_set_capability(input_devs->dev[dev],
+							EV_KEY, keycode);
+		}
+
+		for (i = 0; i < mi->noutputs; i++) {
+			if (gpio_cansleep(mi->output_gpios[i])) {
+				pr_err("gpiomatrix: unsupported output gpio %d,"
+					" can sleep\n", mi->output_gpios[i]);
+				err = -EINVAL;
+				goto err_request_output_gpio_failed;
+			}
+			err = gpio_request(mi->output_gpios[i], "gpio_kp_out");
+			if (err) {
+				pr_err("gpiomatrix: gpio_request failed for "
+					"output %d\n", mi->output_gpios[i]);
+				goto err_request_output_gpio_failed;
+			}
+			if (mi->flags & GPIOKPF_DRIVE_INACTIVE)
+				err = gpio_direction_output(mi->output_gpios[i],
+					!(mi->flags & GPIOKPF_ACTIVE_HIGH));
+			else
+				err = gpio_direction_input(mi->output_gpios[i]);
+			if (err) {
+				pr_err("gpiomatrix: gpio_configure failed for "
+					"output %d\n", mi->output_gpios[i]);
+				goto err_output_gpio_configure_failed;
+			}
+		}
+		for (i = 0; i < mi->ninputs; i++) {
+			err = gpio_request(mi->input_gpios[i], "gpio_kp_in");
+			if (err) {
+				pr_err("gpiomatrix: gpio_request failed for "
+					"input %d\n", mi->input_gpios[i]);
+				goto err_request_input_gpio_failed;
+			}
+			err = gpio_direction_input(mi->input_gpios[i]);
+			if (err) {
+				pr_err("gpiomatrix: gpio_direction_input failed"
+					" for input %d\n", mi->input_gpios[i]);
+				goto err_gpio_direction_input_failed;
+			}
+		}
+		kp->current_output = mi->noutputs;
+		kp->key_state_changed = 1;
+
+		hrtimer_init(&kp->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		kp->timer.function = gpio_keypad_timer_func;
+		wake_lock_init(&kp->wake_lock, WAKE_LOCK_SUSPEND, "gpio_kp");
+		err = gpio_keypad_request_irqs(kp);
+		kp->use_irq = err == 0;
+
+		pr_info("GPIO Matrix Keypad Driver: Start keypad matrix for "
+			"%s%s in %s mode\n", input_devs->dev[0]->name,
+			(input_devs->count > 1) ? "..." : "",
+			kp->use_irq ? "interrupt" : "polling");
+
+		if (kp->use_irq)
+			wake_lock(&kp->wake_lock);
+		hrtimer_start(&kp->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+
+		return 0;
+	}
+
+	err = 0;
+	kp = *data;
+
+	if (kp->use_irq)
+		for (i = mi->noutputs - 1; i >= 0; i--)
+			free_irq(gpio_to_irq(mi->input_gpios[i]), kp);
+
+	hrtimer_cancel(&kp->timer);
+	wake_lock_destroy(&kp->wake_lock);
+	for (i = mi->noutputs - 1; i >= 0; i--) {
+err_gpio_direction_input_failed:
+		gpio_free(mi->input_gpios[i]);
+err_request_input_gpio_failed:
+		;
+	}
+	for (i = mi->noutputs - 1; i >= 0; i--) {
+err_output_gpio_configure_failed:
+		gpio_free(mi->output_gpios[i]);
+err_request_output_gpio_failed:
+		;
+	}
+err_bad_keymap:
+	kfree(kp);
+err_kp_alloc_failed:
+err_invalid_platform_data:
+	return err;
+}
diff -Nur linux-2.6.32-orig/drivers/input/misc/gpio_output.c iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/gpio_output.c
--- linux-2.6.32-orig/drivers/input/misc/gpio_output.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/gpio_output.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,97 @@
+/* drivers/input/misc/gpio_output.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+
+int gpio_event_output_event(
+	struct gpio_event_input_devs *input_devs, struct gpio_event_info *info,
+	void **data, unsigned int dev, unsigned int type,
+	unsigned int code, int value)
+{
+	int i;
+	struct gpio_event_output_info *oi;
+	oi = container_of(info, struct gpio_event_output_info, info);
+	if (type != oi->type)
+		return 0;
+	if (!(oi->flags & GPIOEDF_ACTIVE_HIGH))
+		value = !value;
+	for (i = 0; i < oi->keymap_size; i++)
+		if (dev == oi->keymap[i].dev && code == oi->keymap[i].code)
+			gpio_set_value(oi->keymap[i].gpio, value);
+	return 0;
+}
+
+int gpio_event_output_func(
+	struct gpio_event_input_devs *input_devs, struct gpio_event_info *info,
+	void **data, int func)
+{
+	int ret;
+	int i;
+	struct gpio_event_output_info *oi;
+	oi = container_of(info, struct gpio_event_output_info, info);
+
+	if (func == GPIO_EVENT_FUNC_SUSPEND || func == GPIO_EVENT_FUNC_RESUME)
+		return 0;
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		int output_level = !(oi->flags & GPIOEDF_ACTIVE_HIGH);
+
+		for (i = 0; i < oi->keymap_size; i++) {
+			int dev = oi->keymap[i].dev;
+			if (dev >= input_devs->count) {
+				pr_err("gpio_event_output_func: bad device "
+					"index %d >= %d for key code %d\n",
+					dev, input_devs->count,
+					oi->keymap[i].code);
+				ret = -EINVAL;
+				goto err_bad_keymap;
+			}
+			input_set_capability(input_devs->dev[dev], oi->type,
+					     oi->keymap[i].code);
+		}
+
+		for (i = 0; i < oi->keymap_size; i++) {
+			ret = gpio_request(oi->keymap[i].gpio,
+					   "gpio_event_output");
+			if (ret) {
+				pr_err("gpio_event_output_func: gpio_request "
+					"failed for %d\n", oi->keymap[i].gpio);
+				goto err_gpio_request_failed;
+			}
+			ret = gpio_direction_output(oi->keymap[i].gpio,
+						    output_level);
+			if (ret) {
+				pr_err("gpio_event_output_func: "
+					"gpio_direction_output failed for %d\n",
+					oi->keymap[i].gpio);
+				goto err_gpio_direction_output_failed;
+			}
+		}
+		return 0;
+	}
+
+	ret = 0;
+	for (i = oi->keymap_size - 1; i >= 0; i--) {
+err_gpio_direction_output_failed:
+		gpio_free(oi->keymap[i].gpio);
+err_gpio_request_failed:
+		;
+	}
+err_bad_keymap:
+	return ret;
+}
+
diff -Nur linux-2.6.32-orig/drivers/input/misc/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/Kconfig
--- linux-2.6.32-orig/drivers/input/misc/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -132,6 +132,17 @@
 	  To compile this driver as a module, choose M here: the module will be
 	  called ati_remote2.
 
+config INPUT_KEYCHORD
+	tristate "Key chord input driver support"
+	help
+	  Say Y here if you want to enable the key chord driver
+	  accessible at /dev/keychord.  This driver can be used
+	  for receiving notifications when client specified key
+	  combinations are pressed.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called keychord.
+
 config INPUT_KEYSPAN_REMOTE
 	tristate "Keyspan DMR USB remote control (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
@@ -240,6 +251,11 @@
 	  To compile this driver as a module, choose M here: the module will be
 	  called winbond_cir.
 
+config INPUT_GPIO
+	tristate "GPIO driver support"
+	help
+	  Say Y here if you want to support gpio based keys, wheels etc...
+
 config HP_SDC_RTC
 	tristate "HP SDC Real Time Clock"
 	depends on (GSC || HP300) && SERIO
diff -Nur linux-2.6.32-orig/drivers/input/misc/keychord.c iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/keychord.c
--- linux-2.6.32-orig/drivers/input/misc/keychord.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/keychord.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,387 @@
+/*
+ *  drivers/input/misc/keychord.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/smp_lock.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/keychord.h>
+#include <linux/sched.h>
+
+#define KEYCHORD_NAME		"keychord"
+#define BUFFER_SIZE			16
+
+MODULE_AUTHOR("Mike Lockwood <lockwood@android.com>");
+MODULE_DESCRIPTION("Key chord input driver");
+MODULE_SUPPORTED_DEVICE("keychord");
+MODULE_LICENSE("GPL");
+
+#define NEXT_KEYCHORD(kc) ((struct input_keychord *) \
+		((char *)kc + sizeof(struct input_keychord) + \
+		kc->count * sizeof(kc->keycodes[0])))
+
+struct keychord_device {
+	struct input_handler	input_handler;
+	int			registered;
+
+	/* list of keychords to monitor */
+	struct input_keychord	*keychords;
+	int			keychord_count;
+
+	/* bitmask of keys contained in our keychords */
+	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
+	/* current state of the keys */
+	unsigned long keystate[BITS_TO_LONGS(KEY_CNT)];
+	/* number of keys that are currently pressed */
+	int key_down;
+
+	/* second input_device_id is needed for null termination */
+	struct input_device_id  device_ids[2];
+
+	spinlock_t		lock;
+	wait_queue_head_t	waitq;
+	unsigned char		head;
+	unsigned char		tail;
+	__u16			buff[BUFFER_SIZE];
+};
+
+static int check_keychord(struct keychord_device *kdev,
+		struct input_keychord *keychord)
+{
+	int i;
+
+	if (keychord->count != kdev->key_down)
+		return 0;
+
+	for (i = 0; i < keychord->count; i++) {
+		if (!test_bit(keychord->keycodes[i], kdev->keystate))
+			return 0;
+	}
+
+	/* we have a match */
+	return 1;
+}
+
+static void keychord_event(struct input_handle *handle, unsigned int type,
+			   unsigned int code, int value)
+{
+	struct keychord_device *kdev = handle->private;
+	struct input_keychord *keychord;
+	unsigned long flags;
+	int i, got_chord = 0;
+
+	if (type != EV_KEY || code >= KEY_MAX)
+		return;
+
+	spin_lock_irqsave(&kdev->lock, flags);
+	/* do nothing if key state did not change */
+	if (!test_bit(code, kdev->keystate) == !value)
+		goto done;
+	__change_bit(code, kdev->keystate);
+	if (value)
+		kdev->key_down++;
+	else
+		kdev->key_down--;
+
+	/* don't notify on key up */
+	if (!value)
+		goto done;
+	/* ignore this event if it is not one of the keys we are monitoring */
+	if (!test_bit(code, kdev->keybit))
+		goto done;
+
+	keychord = kdev->keychords;
+	if (!keychord)
+		goto done;
+
+	/* check to see if the keyboard state matches any keychords */
+	for (i = 0; i < kdev->keychord_count; i++) {
+		if (check_keychord(kdev, keychord)) {
+			kdev->buff[kdev->head] = keychord->id;
+			kdev->head = (kdev->head + 1) % BUFFER_SIZE;
+			got_chord = 1;
+			break;
+		}
+		/* skip to next keychord */
+		keychord = NEXT_KEYCHORD(keychord);
+	}
+
+done:
+	spin_unlock_irqrestore(&kdev->lock, flags);
+
+	if (got_chord)
+		wake_up_interruptible(&kdev->waitq);
+}
+
+static int keychord_connect(struct input_handler *handler,
+					  struct input_dev *dev,
+					  const struct input_device_id *id)
+{
+	int i, ret;
+	struct input_handle *handle;
+	struct keychord_device *kdev =
+		container_of(handler, struct keychord_device, input_handler);
+
+	/*
+	 * ignore this input device if it does not contain any keycodes
+	 * that we are monitoring
+	 */
+	for (i = 0; i < KEY_MAX; i++) {
+		if (test_bit(i, kdev->keybit) && test_bit(i, dev->keybit))
+			break;
+	}
+	if (i == KEY_MAX)
+		return -ENODEV;
+
+	handle = kzalloc(sizeof(*handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = KEYCHORD_NAME;
+	handle->private = kdev;
+
+	ret = input_register_handle(handle);
+	if (ret)
+		goto err_input_register_handle;
+
+	ret = input_open_device(handle);
+	if (ret)
+		goto err_input_open_device;
+
+	pr_info("keychord: using input dev %s for fevent\n", dev->name);
+
+	return 0;
+
+err_input_open_device:
+	input_unregister_handle(handle);
+err_input_register_handle:
+	kfree(handle);
+	return ret;
+}
+
+static void keychord_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+/*
+ * keychord_read is used to read keychord events from the driver
+ */
+static ssize_t keychord_read(struct file *file, char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	struct keychord_device *kdev = file->private_data;
+	__u16   id;
+	int retval;
+	unsigned long flags;
+
+	if (count < sizeof(id))
+		return -EINVAL;
+	count = sizeof(id);
+
+	if (kdev->head == kdev->tail && (file->f_flags & O_NONBLOCK))
+		return -EAGAIN;
+
+	retval = wait_event_interruptible(kdev->waitq,
+			kdev->head != kdev->tail);
+	if (retval)
+		return retval;
+
+	spin_lock_irqsave(&kdev->lock, flags);
+	/* pop a keychord ID off the queue */
+	id = kdev->buff[kdev->tail];
+	kdev->tail = (kdev->tail + 1) % BUFFER_SIZE;
+	spin_unlock_irqrestore(&kdev->lock, flags);
+
+	if (copy_to_user(buffer, &id, count))
+		return -EFAULT;
+
+	return count;
+}
+
+/*
+ * keychord_write is used to configure the driver
+ */
+static ssize_t keychord_write(struct file *file, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	struct keychord_device *kdev = file->private_data;
+	struct input_keychord *keychords = 0;
+	struct input_keychord *keychord, *next, *end;
+	int ret, i, key;
+	unsigned long flags;
+
+	if (count < sizeof(struct input_keychord))
+		return -EINVAL;
+	keychords = kzalloc(count, GFP_KERNEL);
+	if (!keychords)
+		return -ENOMEM;
+
+	/* read list of keychords from userspace */
+	if (copy_from_user(keychords, buffer, count)) {
+		kfree(keychords);
+		return -EFAULT;
+	}
+
+	/* unregister handler before changing configuration */
+	if (kdev->registered) {
+		input_unregister_handler(&kdev->input_handler);
+		kdev->registered = 0;
+	}
+
+	spin_lock_irqsave(&kdev->lock, flags);
+	/* clear any existing configuration */
+	kfree(kdev->keychords);
+	kdev->keychords = 0;
+	kdev->keychord_count = 0;
+	kdev->key_down = 0;
+	memset(kdev->keybit, 0, sizeof(kdev->keybit));
+	memset(kdev->keystate, 0, sizeof(kdev->keystate));
+	kdev->head = kdev->tail = 0;
+
+	keychord = keychords;
+	end = (struct input_keychord *)((char *)keychord + count);
+
+	while (keychord < end) {
+		next = NEXT_KEYCHORD(keychord);
+		if (keychord->count <= 0 || next > end) {
+			pr_err("keychord: invalid keycode count %d\n",
+				keychord->count);
+			goto err_unlock_return;
+		}
+		if (keychord->version != KEYCHORD_VERSION) {
+			pr_err("keychord: unsupported version %d\n",
+				keychord->version);
+			goto err_unlock_return;
+		}
+
+		/* keep track of the keys we are monitoring in keybit */
+		for (i = 0; i < keychord->count; i++) {
+			key = keychord->keycodes[i];
+			if (key < 0 || key >= KEY_CNT) {
+				pr_err("keychord: keycode %d out of range\n",
+					key);
+				goto err_unlock_return;
+			}
+			__set_bit(key, kdev->keybit);
+		}
+
+		kdev->keychord_count++;
+		keychord = next;
+	}
+
+	kdev->keychords = keychords;
+	spin_unlock_irqrestore(&kdev->lock, flags);
+
+	ret = input_register_handler(&kdev->input_handler);
+	if (ret) {
+		kfree(keychords);
+		kdev->keychords = 0;
+		return ret;
+	}
+	kdev->registered = 1;
+
+	return count;
+
+err_unlock_return:
+	spin_unlock_irqrestore(&kdev->lock, flags);
+	kfree(keychords);
+	return -EINVAL;
+}
+
+static unsigned int keychord_poll(struct file *file, poll_table *wait)
+{
+	struct keychord_device *kdev = file->private_data;
+
+	poll_wait(file, &kdev->waitq, wait);
+
+	if (kdev->head != kdev->tail)
+		return POLLIN | POLLRDNORM;
+
+	return 0;
+}
+
+static int keychord_open(struct inode *inode, struct file *file)
+{
+	struct keychord_device *kdev;
+
+	kdev = kzalloc(sizeof(struct keychord_device), GFP_KERNEL);
+	if (!kdev)
+		return -ENOMEM;
+
+	spin_lock_init(&kdev->lock);
+	init_waitqueue_head(&kdev->waitq);
+
+	kdev->input_handler.event = keychord_event;
+	kdev->input_handler.connect = keychord_connect;
+	kdev->input_handler.disconnect = keychord_disconnect;
+	kdev->input_handler.name = KEYCHORD_NAME;
+	kdev->input_handler.id_table = kdev->device_ids;
+
+	kdev->device_ids[0].flags = INPUT_DEVICE_ID_MATCH_EVBIT;
+	__set_bit(EV_KEY, kdev->device_ids[0].evbit);
+
+	file->private_data = kdev;
+
+	return 0;
+}
+
+static int keychord_release(struct inode *inode, struct file *file)
+{
+	struct keychord_device *kdev = file->private_data;
+
+	if (kdev->registered)
+		input_unregister_handler(&kdev->input_handler);
+	kfree(kdev);
+
+	return 0;
+}
+
+static const struct file_operations keychord_fops = {
+	.owner		= THIS_MODULE,
+	.open		= keychord_open,
+	.release	= keychord_release,
+	.read		= keychord_read,
+	.write		= keychord_write,
+	.poll		= keychord_poll,
+};
+
+static struct miscdevice keychord_misc = {
+	.fops		= &keychord_fops,
+	.name		= KEYCHORD_NAME,
+	.minor		= MISC_DYNAMIC_MINOR,
+};
+
+static int __init keychord_init(void)
+{
+	return misc_register(&keychord_misc);
+}
+
+static void __exit keychord_exit(void)
+{
+	misc_deregister(&keychord_misc);
+}
+
+module_init(keychord_init);
+module_exit(keychord_exit);
diff -Nur linux-2.6.32-orig/drivers/input/misc/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/Makefile
--- linux-2.6.32-orig/drivers/input/misc/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -12,8 +12,10 @@
 obj-$(CONFIG_INPUT_CM109)		+= cm109.o
 obj-$(CONFIG_INPUT_COBALT_BTNS)		+= cobalt_btns.o
 obj-$(CONFIG_INPUT_DM355EVM)		+= dm355evm_keys.o
+obj-$(CONFIG_INPUT_GPIO)		+= gpio_event.o gpio_matrix.o gpio_input.o gpio_output.o gpio_axis.o
 obj-$(CONFIG_HP_SDC_RTC)		+= hp_sdc_rtc.o
 obj-$(CONFIG_INPUT_IXP4XX_BEEPER)	+= ixp4xx-beeper.o
+obj-$(CONFIG_INPUT_KEYCHORD)		+= keychord.o
 obj-$(CONFIG_INPUT_KEYSPAN_REMOTE)	+= keyspan_remote.o
 obj-$(CONFIG_INPUT_M68K_BEEP)		+= m68kspkr.o
 obj-$(CONFIG_INPUT_PCAP)		+= pcap_keys.o
diff -Nur linux-2.6.32-orig/drivers/input/misc/winbond-cir.c iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/winbond-cir.c
--- linux-2.6.32-orig/drivers/input/misc/winbond-cir.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/misc/winbond-cir.c	2010-11-18 21:05:30.000000000 +0600
@@ -768,7 +768,7 @@
 		return;
 	}
 
-	dev_info(dev, "IR-RC6 ad 0x%02X cm 0x%02X cu 0x%04X "
+	dev_dbg(dev, "IR-RC6 ad 0x%02X cm 0x%02X cu 0x%04X "
 		"toggle %u mode %u scan 0x%08X\n",
 		address,
 		command,
diff -Nur linux-2.6.32-orig/drivers/input/mouse/alps.c iDroid-Project-kernel_common-9e90fd2/drivers/input/mouse/alps.c
--- linux-2.6.32-orig/drivers/input/mouse/alps.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/mouse/alps.c	2010-11-18 21:05:30.000000000 +0600
@@ -5,6 +5,7 @@
  * Copyright (c) 2003-2005 Peter Osterlund <petero2@telia.com>
  * Copyright (c) 2004 Dmitry Torokhov <dtor@mail.ru>
  * Copyright (c) 2005 Vojtech Pavlik <vojtech@suse.cz>
+ * Copyright (c) 2009 Sebastian Kapfer <sebastian_kapfer@gmx.net>
  *
  * ALPS detection, tap switching and status querying info is taken from
  * tpconfig utility (by C. Scott Ananian and Bruce Kall).
@@ -35,6 +36,8 @@
 #define ALPS_OLDPROTO	0x10
 #define ALPS_PASS	0x20
 #define ALPS_FW_BK_2	0x40
+#define ALPS_PS2_INTERLEAVED	0x80	/* 3-byte PS/2 packet interleaved with
+					   6-byte ALPS packet */
 
 static const struct alps_model_info alps_model_data[] = {
 	{ { 0x32, 0x02, 0x14 },	0xf8, 0xf8, ALPS_PASS | ALPS_DUALPOINT }, /* Toshiba Salellite Pro M10 */
@@ -55,7 +58,9 @@
 	{ { 0x20, 0x02, 0x0e },	0xf8, 0xf8, ALPS_PASS | ALPS_DUALPOINT }, /* XXX */
 	{ { 0x22, 0x02, 0x0a },	0xf8, 0xf8, ALPS_PASS | ALPS_DUALPOINT },
 	{ { 0x22, 0x02, 0x14 }, 0xff, 0xff, ALPS_PASS | ALPS_DUALPOINT }, /* Dell Latitude D600 */
-	{ { 0x62, 0x02, 0x14 }, 0xcf, 0xcf, ALPS_PASS | ALPS_DUALPOINT }, /* Dell Latitude E6500 */
+	/* Dell Latitude E5500, E6400, E6500, Precision M4400 */
+	{ { 0x62, 0x02, 0x14 }, 0xcf, 0xcf,
+		ALPS_PASS | ALPS_DUALPOINT | ALPS_PS2_INTERLEAVED },
 	{ { 0x73, 0x02, 0x50 }, 0xcf, 0xcf, ALPS_FW_BK_1 },		  /* Dell Vostro 1400 */
 };
 
@@ -66,20 +71,88 @@
  */
 
 /*
- * ALPS abolute Mode - new format
+ * PS/2 packet format
+ *
+ * byte 0:  0    0 YSGN XSGN    1    M    R    L
+ * byte 1: X7   X6   X5   X4   X3   X2   X1   X0
+ * byte 2: Y7   Y6   Y5   Y4   Y3   Y2   Y1   Y0
+ *
+ * Note that the device never signals overflow condition.
+ *
+ * ALPS absolute Mode - new format
  *
  * byte 0:  1    ?    ?    ?    1    ?    ?    ?
  * byte 1:  0   x6   x5   x4   x3   x2   x1   x0
- * byte 2:  0   x10  x9   x8   x7    ?  fin  ges
+ * byte 2:  0  x10   x9   x8   x7    ?  fin  ges
  * byte 3:  0   y9   y8   y7    1    M    R    L
  * byte 4:  0   y6   y5   y4   y3   y2   y1   y0
  * byte 5:  0   z6   z5   z4   z3   z2   z1   z0
  *
+ * Dualpoint device -- interleaved packet format
+ *
+ * byte 0:    1    1    0    0    1    1    1    1
+ * byte 1:    0   x6   x5   x4   x3   x2   x1   x0
+ * byte 2:    0  x10   x9   x8   x7    0  fin  ges
+ * byte 3:    0    0 YSGN XSGN    1    1    1    1
+ * byte 4:   X7   X6   X5   X4   X3   X2   X1   X0
+ * byte 5:   Y7   Y6   Y5   Y4   Y3   Y2   Y1   Y0
+ * byte 6:    0   y9   y8   y7    1    m    r    l
+ * byte 7:    0   y6   y5   y4   y3   y2   y1   y0
+ * byte 8:    0   z6   z5   z4   z3   z2   z1   z0
+ *
+ * CAPITALS = stick, miniscules = touchpad
+ *
  * ?'s can have different meanings on different models,
  * such as wheel rotation, extra buttons, stick buttons
  * on a dualpoint, etc.
  */
 
+static bool alps_is_valid_first_byte(const struct alps_model_info *model,
+				     unsigned char data)
+{
+	return (data & model->mask0) == model->byte0;
+}
+
+static void alps_report_buttons(struct psmouse *psmouse,
+				struct input_dev *dev1, struct input_dev *dev2,
+				int left, int right, int middle)
+{
+	struct alps_data *priv = psmouse->private;
+	const struct alps_model_info *model = priv->i;
+
+	if (model->flags & ALPS_PS2_INTERLEAVED) {
+		struct input_dev *dev;
+
+		/*
+		 * If shared button has already been reported on the
+		 * other device (dev2) then this event should be also
+		 * sent through that device.
+		 */
+		dev = test_bit(BTN_LEFT, dev2->key) ? dev2 : dev1;
+		input_report_key(dev, BTN_LEFT, left);
+
+		dev = test_bit(BTN_RIGHT, dev2->key) ? dev2 : dev1;
+		input_report_key(dev, BTN_RIGHT, right);
+
+		dev = test_bit(BTN_MIDDLE, dev2->key) ? dev2 : dev1;
+		input_report_key(dev, BTN_MIDDLE, middle);
+
+		/*
+		 * Sync the _other_ device now, we'll do the first
+		 * device later once we report the rest of the events.
+		 */
+		input_sync(dev2);
+	} else {
+		/*
+		 * For devices with non-interleaved packets we know what
+		 * device buttons belong to so we can simply report them.
+		 */
+		input_report_key(dev1, BTN_LEFT, left);
+		input_report_key(dev1, BTN_RIGHT, right);
+		input_report_key(dev1, BTN_MIDDLE, middle);
+	}
+}
+
 static void alps_process_packet(struct psmouse *psmouse)
 {
 	struct alps_data *priv = psmouse->private;
@@ -89,18 +162,6 @@
 	int x, y, z, ges, fin, left, right, middle;
 	int back = 0, forward = 0;
 
-	if ((packet[0] & 0xc8) == 0x08) {   /* 3-byte PS/2 packet */
-		input_report_key(dev2, BTN_LEFT,   packet[0] & 1);
-		input_report_key(dev2, BTN_RIGHT,  packet[0] & 2);
-		input_report_key(dev2, BTN_MIDDLE, packet[0] & 4);
-		input_report_rel(dev2, REL_X,
-			packet[1] ? packet[1] - ((packet[0] << 4) & 0x100) : 0);
-		input_report_rel(dev2, REL_Y,
-			packet[2] ? ((packet[0] << 3) & 0x100) - packet[2] : 0);
-		input_sync(dev2);
-		return;
-	}
-
 	if (priv->i->flags & ALPS_OLDPROTO) {
 		left = packet[2] & 0x10;
 		right = packet[2] & 0x08;
@@ -136,18 +197,13 @@
 		input_report_rel(dev2, REL_X,  (x > 383 ? (x - 768) : x));
 		input_report_rel(dev2, REL_Y, -(y > 255 ? (y - 512) : y));
 
-		input_report_key(dev2, BTN_LEFT, left);
-		input_report_key(dev2, BTN_RIGHT, right);
-		input_report_key(dev2, BTN_MIDDLE, middle);
+		alps_report_buttons(psmouse, dev2, dev, left, right, middle);
 
-		input_sync(dev);
 		input_sync(dev2);
 		return;
 	}
 
-	input_report_key(dev, BTN_LEFT, left);
-	input_report_key(dev, BTN_RIGHT, right);
-	input_report_key(dev, BTN_MIDDLE, middle);
+	alps_report_buttons(psmouse, dev, dev2, left, right, middle);
 
 	/* Convert hardware tap to a reasonable Z value */
 	if (ges && !fin) z = 40;
@@ -188,25 +244,168 @@
 	input_sync(dev);
 }
 
+static void alps_report_bare_ps2_packet(struct psmouse *psmouse,
+					unsigned char packet[],
+					bool report_buttons)
+{
+	struct alps_data *priv = psmouse->private;
+	struct input_dev *dev2 = priv->dev2;
+
+	if (report_buttons)
+		alps_report_buttons(psmouse, dev2, psmouse->dev,
+				packet[0] & 1, packet[0] & 2, packet[0] & 4);
+
+	input_report_rel(dev2, REL_X,
+		packet[1] ? packet[1] - ((packet[0] << 4) & 0x100) : 0);
+	input_report_rel(dev2, REL_Y,
+		packet[2] ? ((packet[0] << 3) & 0x100) - packet[2] : 0);
+
+	input_sync(dev2);
+}
+
+static psmouse_ret_t alps_handle_interleaved_ps2(struct psmouse *psmouse)
+{
+	struct alps_data *priv = psmouse->private;
+
+	if (psmouse->pktcnt < 6)
+		return PSMOUSE_GOOD_DATA;
+
+	if (psmouse->pktcnt == 6) {
+		/*
+		 * Start a timer to flush the packet if it ends up last
+		 * 6-byte packet in the stream. Timer needs to fire
+		 * psmouse core times out itself. 20 ms should be enough
+		 * to decide if we are getting more data or not.
+		 */
+		mod_timer(&priv->timer, jiffies + msecs_to_jiffies(20));
+		return PSMOUSE_GOOD_DATA;
+	}
+
+	del_timer(&priv->timer);
+
+	if (psmouse->packet[6] & 0x80) {
+
+		/*
+		 * Highest bit is set - that means we either had
+		 * complete ALPS packet and this is start of the
+		 * next packet or we got garbage.
+		 */
+
+		if (((psmouse->packet[3] |
+		      psmouse->packet[4] |
+		      psmouse->packet[5]) & 0x80) ||
+		    (!alps_is_valid_first_byte(priv->i, psmouse->packet[6]))) {
+			dbg("refusing packet %x %x %x %x "
+			    "(suspected interleaved ps/2)\n",
+			    psmouse->packet[3], psmouse->packet[4],
+			    psmouse->packet[5], psmouse->packet[6]);
+			return PSMOUSE_BAD_DATA;
+		}
+
+		alps_process_packet(psmouse);
+
+		/* Continue with the next packet */
+		psmouse->packet[0] = psmouse->packet[6];
+		psmouse->pktcnt = 1;
+
+	} else {
+
+		/*
+		 * High bit is 0 - that means that we indeed got a PS/2
+		 * packet in the middle of ALPS packet.
+		 *
+		 * There is also possibility that we got 6-byte ALPS
+		 * packet followed  by 3-byte packet from trackpoint. We
+		 * can not distinguish between these 2 scenarios but
+		 * becase the latter is unlikely to happen in course of
+		 * normal operation (user would need to press all
+		 * buttons on the pad and start moving trackpoint
+		 * without touching the pad surface) we assume former.
+		 * Even if we are wrong the wost thing that would happen
+		 * the cursor would jump but we should not get protocol
+		 * desynchronization.
+		 */
+
+		alps_report_bare_ps2_packet(psmouse, &psmouse->packet[3],
+					    false);
+
+		/*
+		 * Continue with the standard ALPS protocol handling,
+		 * but make sure we won't process it as an interleaved
+		 * packet again, which may happen if all buttons are
+		 * pressed. To avoid this let's reset the 4th bit which
+		 * is normally 1.
+		 */
+		psmouse->packet[3] = psmouse->packet[6] & 0xf7;
+		psmouse->pktcnt = 4;
+	}
+
+	return PSMOUSE_GOOD_DATA;
+}
+
+static void alps_flush_packet(unsigned long data)
+{
+	struct psmouse *psmouse = (struct psmouse *)data;
+
+	serio_pause_rx(psmouse->ps2dev.serio);
+
+	if (psmouse->pktcnt == 6) {
+
+		/*
+		 * We did not any more data in reasonable amount of time.
+		 * Validate the last 3 bytes and process as a standard
+		 * ALPS packet.
+		 */
+		if ((psmouse->packet[3] |
+		     psmouse->packet[4] |
+		     psmouse->packet[5]) & 0x80) {
+			dbg("refusing packet %x %x %x "
+			    "(suspected interleaved ps/2)\n",
+			    psmouse->packet[3], psmouse->packet[4],
+			    psmouse->packet[5]);
+		} else {
+			alps_process_packet(psmouse);
+		}
+		psmouse->pktcnt = 0;
+	}
+
+	serio_continue_rx(psmouse->ps2dev.serio);
+}
+
 static psmouse_ret_t alps_process_byte(struct psmouse *psmouse)
 {
 	struct alps_data *priv = psmouse->private;
+	const struct alps_model_info *model = priv->i;
 
 	if ((psmouse->packet[0] & 0xc8) == 0x08) { /* PS/2 packet */
 		if (psmouse->pktcnt == 3) {
-			alps_process_packet(psmouse);
+			alps_report_bare_ps2_packet(psmouse, psmouse->packet,
+						    true);
 			return PSMOUSE_FULL_PACKET;
 		}
 		return PSMOUSE_GOOD_DATA;
 	}
 
-	if ((psmouse->packet[0] & priv->i->mask0) != priv->i->byte0)
+	/* Check for PS/2 packet stuffed in the middle of ALPS packet. */
+
+	if ((model->flags & ALPS_PS2_INTERLEAVED) &&
+	    psmouse->pktcnt >= 4 && (psmouse->packet[3] & 0x0f) == 0x0f) {
+		return alps_handle_interleaved_ps2(psmouse);
+	}
+
+	if (!alps_is_valid_first_byte(model, psmouse->packet[0])) {
+		dbg("refusing packet[0] = %x (mask0 = %x, byte0 = %x)\n",
+		    psmouse->packet[0], model->mask0, model->byte0);
 		return PSMOUSE_BAD_DATA;
+	}
 
 	/* Bytes 2 - 6 should have 0 in the highest bit */
 	if (psmouse->pktcnt >= 2 && psmouse->pktcnt <= 6 &&
-	    (psmouse->packet[psmouse->pktcnt - 1] & 0x80))
+	    (psmouse->packet[psmouse->pktcnt - 1] & 0x80)) {
+		dbg("refusing packet[%i] = %x\n",
+		    psmouse->pktcnt - 1, psmouse->packet[psmouse->pktcnt - 1]);
 		return PSMOUSE_BAD_DATA;
+	}
 
 	if (psmouse->pktcnt == 6) {
 		alps_process_packet(psmouse);
@@ -445,6 +644,7 @@
 	struct alps_data *priv = psmouse->private;
 
 	psmouse_reset(psmouse);
+	del_timer_sync(&priv->timer);
 	input_unregister_device(priv->dev2);
 	kfree(priv);
 }
@@ -461,6 +661,8 @@
 		goto init_fail;
 
 	priv->dev2 = dev2;
+	setup_timer(&priv->timer, alps_flush_packet, (unsigned long)psmouse);
+
 	psmouse->private = priv;
 
 	if (alps_hw_init(psmouse, &version))
diff -Nur linux-2.6.32-orig/drivers/input/mouse/alps.h iDroid-Project-kernel_common-9e90fd2/drivers/input/mouse/alps.h
--- linux-2.6.32-orig/drivers/input/mouse/alps.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/mouse/alps.h	2010-11-18 21:05:30.000000000 +0600
@@ -23,6 +23,7 @@
 	char phys[32];			/* Phys */
 	const struct alps_model_info *i;/* Info */
 	int prev_fin;			/* Finger bit from previous packet */
+	struct timer_list timer;
 };
 
 #ifdef CONFIG_MOUSE_PS2_ALPS
diff -Nur linux-2.6.32-orig/drivers/input/mouse/psmouse-base.c iDroid-Project-kernel_common-9e90fd2/drivers/input/mouse/psmouse-base.c
--- linux-2.6.32-orig/drivers/input/mouse/psmouse-base.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/mouse/psmouse-base.c	2010-11-18 21:05:30.000000000 +0600
@@ -667,19 +667,6 @@
 		max_proto = PSMOUSE_IMEX;
 	}
 
-/*
- * Try Finger Sensing Pad
- */
-	if (max_proto > PSMOUSE_IMEX) {
-		if (fsp_detect(psmouse, set_properties) == 0) {
-			if (!set_properties || fsp_init(psmouse) == 0)
-				return PSMOUSE_FSP;
-/*
- * Init failed, try basic relative protocols
- */
-			max_proto = PSMOUSE_IMEX;
-		}
-	}
 
 	if (max_proto > PSMOUSE_IMEX) {
 		if (genius_detect(psmouse, set_properties) == 0)
@@ -696,6 +683,21 @@
 	}
 
 /*
+ * Try Finger Sensing Pad. We do it here because its probe upsets
+ * Trackpoint devices (causing TP_READ_ID command to time out).
+ */
+	if (max_proto > PSMOUSE_IMEX) {
+		if (fsp_detect(psmouse, set_properties) == 0) {
+			if (!set_properties || fsp_init(psmouse) == 0)
+				return PSMOUSE_FSP;
+/*
+ * Init failed, try basic relative protocols
+ */
+			max_proto = PSMOUSE_IMEX;
+		}
+	}
+
+/*
  * Reset to defaults in case the device got confused by extended
  * protocol probes. Note that we follow up with full reset because
  * some mice put themselves to sleep when they see PSMOUSE_RESET_DIS.
diff -Nur linux-2.6.32-orig/drivers/input/serio/i8042-x86ia64io.h iDroid-Project-kernel_common-9e90fd2/drivers/input/serio/i8042-x86ia64io.h
--- linux-2.6.32-orig/drivers/input/serio/i8042-x86ia64io.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/serio/i8042-x86ia64io.h	2010-11-18 21:05:30.000000000 +0600
@@ -67,10 +67,12 @@
 
 #include <linux/dmi.h>
 
-static struct dmi_system_id __initdata i8042_dmi_noloop_table[] = {
+static const struct dmi_system_id __initconst i8042_dmi_noloop_table[] = {
 	{
-		/* AUX LOOP command does not raise AUX IRQ */
-		.ident = "Arima-Rioworks HDAMB",
+		/*
+		 * Arima-Rioworks HDAMB -
+		 * AUX LOOP command does not raise AUX IRQ
+		 */
 		.matches = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "RIOWORKS"),
 			DMI_MATCH(DMI_BOARD_NAME, "HDAMB"),
@@ -78,7 +80,7 @@
 		},
 	},
 	{
-		.ident = "ASUS G1S",
+		/* ASUS G1S */
 		.matches = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer Inc."),
 			DMI_MATCH(DMI_BOARD_NAME, "G1S"),
@@ -86,8 +88,7 @@
 		},
 	},
 	{
-		/* AUX LOOP command does not raise AUX IRQ */
-		.ident = "ASUS P65UP5",
+		/* ASUS P65UP5 - AUX LOOP command does not raise AUX IRQ */
 		.matches = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
 			DMI_MATCH(DMI_BOARD_NAME, "P/I-P65UP5"),
@@ -95,7 +96,6 @@
 		},
 	},
 	{
-		.ident = "Compaq Proliant 8500",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Compaq"),
 			DMI_MATCH(DMI_PRODUCT_NAME , "ProLiant"),
@@ -103,7 +103,6 @@
 		},
 	},
 	{
-		.ident = "Compaq Proliant DL760",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Compaq"),
 			DMI_MATCH(DMI_PRODUCT_NAME , "ProLiant"),
@@ -111,7 +110,7 @@
 		},
 	},
 	{
-		.ident = "OQO Model 01",
+		/* OQO Model 01 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "OQO"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "ZEPTO"),
@@ -119,8 +118,7 @@
 		},
 	},
 	{
-		/* AUX LOOP does not work properly */
-		.ident = "ULI EV4873",
+		/* ULI EV4873 - AUX LOOP does not work properly */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "ULI"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "EV4873"),
@@ -128,7 +126,7 @@
 		},
 	},
 	{
-		.ident = "Microsoft Virtual Machine",
+		/* Microsoft Virtual Machine */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Virtual Machine"),
@@ -136,7 +134,7 @@
 		},
 	},
 	{
-		.ident = "Medion MAM 2070",
+		/* Medion MAM 2070 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Notebook"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "MAM 2070"),
@@ -144,7 +142,7 @@
 		},
 	},
 	{
-		.ident = "Blue FB5601",
+		/* Blue FB5601 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "blue"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "FB5601"),
@@ -152,7 +150,7 @@
 		},
 	},
 	{
-		.ident = "Gigabyte M912",
+		/* Gigabyte M912 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "GIGABYTE"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "M912"),
@@ -160,7 +158,14 @@
 		},
 	},
 	{
-		.ident = "HP DV9700",
+		/* Gigabyte M1022M netbook */
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "Gigabyte Technology Co.,Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "M1022E"),
+			DMI_MATCH(DMI_BOARD_VERSION, "1.02"),
+		},
+	},
+	{
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion dv9700"),
@@ -177,72 +182,72 @@
  * ... apparently some Toshibas don't like MUX mode either and
  * die horrible death on reboot.
  */
-static struct dmi_system_id __initdata i8042_dmi_nomux_table[] = {
+static const struct dmi_system_id __initconst i8042_dmi_nomux_table[] = {
 	{
-		.ident = "Fujitsu Lifebook P7010/P7010D",
+		/* Fujitsu Lifebook P7010/P7010D */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "P7010"),
 		},
 	},
 	{
-		.ident = "Fujitsu Lifebook P7010",
+		/* Fujitsu Lifebook P7010 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "0000000000"),
 		},
 	},
 	{
-		.ident = "Fujitsu Lifebook P5020D",
+		/* Fujitsu Lifebook P5020D */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "LifeBook P Series"),
 		},
 	},
 	{
-		.ident = "Fujitsu Lifebook S2000",
+		/* Fujitsu Lifebook S2000 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "LifeBook S Series"),
 		},
 	},
 	{
-		.ident = "Fujitsu Lifebook S6230",
+		/* Fujitsu Lifebook S6230 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "LifeBook S6230"),
 		},
 	},
 	{
-		.ident = "Fujitsu T70H",
+		/* Fujitsu T70H */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "FMVLT70H"),
 		},
 	},
 	{
-		.ident = "Fujitsu-Siemens Lifebook T3010",
+		/* Fujitsu-Siemens Lifebook T3010 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "LIFEBOOK T3010"),
 		},
 	},
 	{
-		.ident = "Fujitsu-Siemens Lifebook E4010",
+		/* Fujitsu-Siemens Lifebook E4010 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "LIFEBOOK E4010"),
 		},
 	},
 	{
-		.ident = "Fujitsu-Siemens Amilo Pro 2010",
+		/* Fujitsu-Siemens Amilo Pro 2010 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "AMILO Pro V2010"),
 		},
 	},
 	{
-		.ident = "Fujitsu-Siemens Amilo Pro 2030",
+		/* Fujitsu-Siemens Amilo Pro 2030 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "AMILO PRO V2030"),
@@ -253,7 +258,7 @@
 		 * No data is coming from the touchscreen unless KBC
 		 * is in legacy mode.
 		 */
-		.ident = "Panasonic CF-29",
+		/* Panasonic CF-29 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Matsushita"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "CF-29"),
@@ -261,10 +266,10 @@
 	},
 	{
 		/*
-		 * Errors on MUX ports are reported without raising AUXDATA
+		 * HP Pavilion DV4017EA -
+		 * errors on MUX ports are reported without raising AUXDATA
 		 * causing "spurious NAK" messages.
 		 */
-		.ident = "HP Pavilion DV4017EA",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Pavilion dv4000 (EA032EA#ABF)"),
@@ -272,9 +277,9 @@
 	},
 	{
 		/*
-		 * Like DV4017EA does not raise AUXERR for errors on MUX ports.
+		 * HP Pavilion ZT1000 -
+		 * like DV4017EA does not raise AUXERR for errors on MUX ports.
 		 */
-		.ident = "HP Pavilion ZT1000",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion Notebook PC"),
@@ -283,44 +288,41 @@
 	},
 	{
 		/*
-		 * Like DV4017EA does not raise AUXERR for errors on MUX ports.
+		 * HP Pavilion DV4270ca -
+		 * like DV4017EA does not raise AUXERR for errors on MUX ports.
 		 */
-		.ident = "HP Pavilion DV4270ca",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Pavilion dv4000 (EH476UA#ABL)"),
 		},
 	},
 	{
-		.ident = "Toshiba P10",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Satellite P10"),
 		},
 	},
 	{
-		.ident = "Toshiba Equium A110",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "EQUIUM A110"),
 		},
 	},
 	{
-		.ident = "Alienware Sentia",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "ALIENWARE"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Sentia"),
 		},
 	},
 	{
-		.ident = "Sharp Actius MM20",
+		/* Sharp Actius MM20 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "SHARP"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "PC-MM20 Series"),
 		},
 	},
 	{
-		.ident = "Sony Vaio FS-115b",
+		/* Sony Vaio FS-115b */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FS115B"),
@@ -328,73 +330,72 @@
 	},
 	{
 		/*
-		 * Reset and GET ID commands issued via KBD port are
+		 * Sony Vaio FZ-240E -
+		 * reset and GET ID commands issued via KBD port are
 		 * sometimes being delivered to AUX3.
 		 */
-		.ident = "Sony Vaio FZ-240E",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FZ240E"),
 		},
 	},
 	{
-		.ident = "Amoi M636/A737",
+		/* Amoi M636/A737 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Amoi Electronics CO.,LTD."),
 			DMI_MATCH(DMI_PRODUCT_NAME, "M636/A737 platform"),
 		},
 	},
 	{
-		.ident = "Lenovo 3000 n100",
+		/* Lenovo 3000 n100 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "076804U"),
 		},
 	},
 	{
-		.ident = "Acer Aspire 1360",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire 1360"),
 		},
 	},
 	{
-		.ident = "Gericom Bellagio",
+		/* Gericom Bellagio */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Gericom"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "N34AS6"),
 		},
 	},
 	{
-		.ident = "IBM 2656",
+		/* IBM 2656 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "IBM"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "2656"),
 		},
 	},
 	{
-		.ident = "Dell XPS M1530",
+		/* Dell XPS M1530 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 			DMI_MATCH(DMI_PRODUCT_NAME, "XPS M1530"),
 		},
 	},
 	{
-		.ident = "Compal HEL80I",
+		/* Compal HEL80I */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "COMPAL"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "HEL80I"),
 		},
 	},
 	{
-		.ident = "Dell Vostro 1510",
+		/* Dell Vostro 1510 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Vostro1510"),
 		},
 	},
 	{
-		.ident = "Acer Aspire 5536",
+		/* Acer Aspire 5536 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire 5536"),
@@ -404,65 +405,65 @@
 	{ }
 };
 
-static struct dmi_system_id __initdata i8042_dmi_reset_table[] = {
+static const struct dmi_system_id __initconst i8042_dmi_reset_table[] = {
 	{
-		.ident = "MSI Wind U-100",
+		/* MSI Wind U-100 */
 		.matches = {
 			DMI_MATCH(DMI_BOARD_NAME, "U-100"),
 			DMI_MATCH(DMI_BOARD_VENDOR, "MICRO-STAR INTERNATIONAL CO., LTD"),
 		},
 	},
 	{
-		.ident = "LG Electronics X110",
+		/* LG Electronics X110 */
 		.matches = {
 			DMI_MATCH(DMI_BOARD_NAME, "X110"),
 			DMI_MATCH(DMI_BOARD_VENDOR, "LG Electronics Inc."),
 		},
 	},
 	{
-		.ident = "Acer Aspire One 150",
+		/* Acer Aspire One 150 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "AOA150"),
 		},
 	},
 	{
-		.ident = "Advent 4211",
+		/* Advent 4211 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "DIXONSXP"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Advent 4211"),
 		},
 	},
 	{
-		.ident = "Medion Akoya Mini E1210",
+		/* Medion Akoya Mini E1210 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "MEDION"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "E1210"),
 		},
 	},
 	{
-		.ident = "Mivvy M310",
+		/* Mivvy M310 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "VIOOO"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "N10"),
 		},
 	},
 	{
-		.ident = "Dell Vostro 1320",
+		/* Dell Vostro 1320 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Vostro 1320"),
 		},
 	},
 	{
-		.ident = "Dell Vostro 1520",
+		/* Dell Vostro 1520 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Vostro 1520"),
 		},
 	},
 	{
-		.ident = "Dell Vostro 1720",
+		/* Dell Vostro 1720 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Vostro 1720"),
@@ -472,16 +473,16 @@
 };
 
 #ifdef CONFIG_PNP
-static struct dmi_system_id __initdata i8042_dmi_nopnp_table[] = {
+static const struct dmi_system_id __initconst i8042_dmi_nopnp_table[] = {
 	{
-		.ident = "Intel MBO Desktop D845PESV",
+		/* Intel MBO Desktop D845PESV */
 		.matches = {
 			DMI_MATCH(DMI_BOARD_NAME, "D845PESV"),
 			DMI_MATCH(DMI_BOARD_VENDOR, "Intel Corporation"),
 		},
 	},
 	{
-		.ident = "MSI Wind U-100",
+		/* MSI Wind U-100 */
 		.matches = {
 			DMI_MATCH(DMI_BOARD_NAME, "U-100"),
 			DMI_MATCH(DMI_BOARD_VENDOR, "MICRO-STAR INTERNATIONAL CO., LTD"),
@@ -490,27 +491,23 @@
 	{ }
 };
 
-static struct dmi_system_id __initdata i8042_dmi_laptop_table[] = {
+static const struct dmi_system_id __initconst i8042_dmi_laptop_table[] = {
 	{
-		.ident = "Portable",
 		.matches = {
 			DMI_MATCH(DMI_CHASSIS_TYPE, "8"), /* Portable */
 		},
 	},
 	{
-		.ident = "Laptop",
 		.matches = {
 			DMI_MATCH(DMI_CHASSIS_TYPE, "9"), /* Laptop */
 		},
 	},
 	{
-		.ident = "Notebook",
 		.matches = {
 			DMI_MATCH(DMI_CHASSIS_TYPE, "10"), /* Notebook */
 		},
 	},
 	{
-		.ident = "Sub-Notebook",
 		.matches = {
 			DMI_MATCH(DMI_CHASSIS_TYPE, "14"), /* Sub-Notebook */
 		},
@@ -525,58 +522,65 @@
  * Originally, this was just confined to older laptops, but a few Acer laptops
  * have turned up in 2007 that also need this again.
  */
-static struct dmi_system_id __initdata i8042_dmi_dritek_table[] = {
+static const struct dmi_system_id __initconst i8042_dmi_dritek_table[] = {
+	{
+		/* Acer Aspire 5610 */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire 5610"),
+		},
+	},
 	{
-		.ident = "Acer Aspire 5630",
+		/* Acer Aspire 5630 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire 5630"),
 		},
 	},
 	{
-		.ident = "Acer Aspire 5650",
+		/* Acer Aspire 5650 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire 5650"),
 		},
 	},
 	{
-		.ident = "Acer Aspire 5680",
+		/* Acer Aspire 5680 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire 5680"),
 		},
 	},
 	{
-		.ident = "Acer Aspire 5720",
+		/* Acer Aspire 5720 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire 5720"),
 		},
 	},
 	{
-		.ident = "Acer Aspire 9110",
+		/* Acer Aspire 9110 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire 9110"),
 		},
 	},
 	{
-		.ident = "Acer TravelMate 660",
+		/* Acer TravelMate 660 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "TravelMate 660"),
 		},
 	},
 	{
-		.ident = "Acer TravelMate 2490",
+		/* Acer TravelMate 2490 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "TravelMate 2490"),
 		},
 	},
 	{
-		.ident = "Acer TravelMate 4280",
+		/* Acer TravelMate 4280 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Acer"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "TravelMate 4280"),
diff -Nur linux-2.6.32-orig/drivers/input/touchscreen/iphone-mt.c iDroid-Project-kernel_common-9e90fd2/drivers/input/touchscreen/iphone-mt.c
--- linux-2.6.32-orig/drivers/input/touchscreen/iphone-mt.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/touchscreen/iphone-mt.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,1011 @@
+/*
+ * iphone-mt.c - Zephyr Touchscreen driver, used in iPhone.
+ *
+ * Authors: Yidou Wang, Patrick Wildt, Ricky Taylor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/firmware.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <mach/iphone-spi.h>
+#include <mach/gpio.h>
+
+#ifdef CONFIG_IPHONE_2G
+#define MT_GPIO_POWER 0x804
+#define MT_ATN_INTERRUPT 0xa3
+#else
+#define MT_GPIO_POWER 0x701
+#define MT_ATN_INTERRUPT 0x9b
+#endif
+
+#ifdef CONFIG_IPHONE_3G
+#define MT_SPI 1
+#define MT_SPI_CS GPIO_SPI1_CS0
+#else
+#define MT_SPI 2
+#define MT_SPI_CS GPIO_SPI2_CS0
+#endif
+
+#define MT_INFO_FAMILYID 0xD1
+#define MT_INFO_SENSORINFO 0xD3
+#define MT_INFO_SENSORREGIONDESC 0xD0
+#define MT_INFO_SENSORREGIONPARAM 0xA1
+#define MT_INFO_SENSORDIM 0xD9
+
+typedef struct MTFrameHeader
+{
+	u8 type;
+	u8 frameNum;
+	u8 headerLen;
+	u8 unk_3;
+	u32 timestamp;
+	u8 unk_8;
+	u8 unk_9;
+	u8 unk_A;
+	u8 unk_B;
+	u16 unk_C;
+	u16 isImage;
+
+	u8 numFingers;
+	u8 fingerDataLen;
+	u16 unk_12;
+	u16 unk_14;
+	u16 unk_16;
+} MTFrameHeader;
+
+typedef struct FingerData
+{
+	u8 id;
+	u8 event;
+	u8 unk_2;
+	u8 unk_3;
+	s16 x;
+	s16 y;
+	s16 rel_x;
+	s16 rel_y;
+	u16 size_major;
+	u16 size_minor;
+	u16 orientation;
+	u16 force_major;
+	u16 force_minor;
+	u16 unk_16;
+	u16 unk_18;
+	u16 unk_1A;
+} FingerData;
+
+#define MAX_FINGER_ORIENTATION  16384
+
+static irqreturn_t multitouch_atn(int irq, void* pToken);
+
+volatile int GotATN;
+spinlock_t GotATNLock;
+
+static u8* OutputPacket;
+static u8* InputPacket;
+static u8* GetInfoPacket;
+static u8* GetResultPacket;
+
+static int InterfaceVersion;
+static int MaxPacketSize;
+static int FamilyID;
+static int SensorWidth;
+static int SensorHeight;
+static int SensorColumns;
+static int SensorRows;
+static int BCDVersion;
+static int Endianness;
+static u8* SensorRegionDescriptor;
+static int SensorRegionDescriptorLen;
+static u8* SensorRegionParam;
+static int SensorRegionParamLen;
+
+static u8 SensorMinPressure = 100;
+
+// This is flipped between 0x64 and 0x65 for every transaction
+static int CurNOP;
+
+typedef struct MTSPISetting
+{
+	int speed;
+	int txDelay;
+	int rxDelay;
+} MTSPISetting;
+
+const MTSPISetting MTNormalSpeed = {83000, 5, 10};
+const MTSPISetting MTFastSpeed = {4500000, 0, 10};
+
+#define NORMAL_SPEED (&MTNormalSpeed)
+#define FAST_SPEED (&MTFastSpeed)
+
+static int mt_spi_txrx(const MTSPISetting* setting, const u8* outBuffer, int outLen, u8* inBuffer, int inLen);
+static int mt_spi_tx(const MTSPISetting* setting, const u8* outBuffer, int outLen);
+
+static int makeBootloaderDataPacket(u8* output, u32 destAddress, const u8* data, int dataLen, int* cksumOut);
+static bool verifyUpload(int checksum);
+static void sendExecutePacket(void);
+static void sendBlankDataPacket(void);
+
+static bool loadASpeedFirmware(const u8* firmware, int len);
+static bool loadMainFirmware(const u8* firmware, int len);
+static bool determineInterfaceVersion(void);
+
+static bool getReportInfo(int id, u8* err, u16* len);
+static bool getReport(int id, u8* buffer, int* outLen);
+
+static bool readFrameLength(int* len);
+static int readFrame(void);
+static bool readResultData(int len);
+
+static void newPacket(const u8* data, int len);
+static void multitouch_atn_handler(struct work_struct* work);
+
+bool MultitouchOn = false;
+bool FirmwareLoaded = false;
+
+static struct device* multitouch_dev = NULL;
+struct input_dev* input_dev;
+
+u8* aspeed_fw;
+size_t aspeed_fw_size;
+u8* main_fw;
+size_t main_fw_size;
+
+DECLARE_WORK(multitouch_workqueue, &multitouch_atn_handler);
+
+void multitouch_on(void)
+{
+	if(!MultitouchOn)
+	{
+		printk("multitouch: powering on\n");
+		iphone_gpio_pin_output(MT_GPIO_POWER, 0);
+		msleep(200);
+		iphone_gpio_pin_output(MT_GPIO_POWER, 1);
+
+		msleep(15);
+		MultitouchOn = true;
+	}
+}
+
+int multitouch_setup(const u8* ASpeedFirmware, int ASpeedFirmwareLen, const u8* mainFirmware, int mainFirmwareLen)
+{
+	int i;
+	int ret;
+
+	printk("multitouch: A-Speed firmware at 0x%08x - 0x%08x, Main firmware at 0x%08x - 0x%08x\n",
+			(u32) ASpeedFirmware, (u32)(ASpeedFirmware + ASpeedFirmwareLen),
+			(u32) mainFirmware, (u32)(mainFirmware + mainFirmwareLen));
+
+	OutputPacket = (u8*) kmalloc(0x400, GFP_KERNEL);
+	InputPacket = (u8*) kmalloc(0x400, GFP_KERNEL);
+	GetInfoPacket = (u8*) kmalloc(0x400, GFP_KERNEL);
+	GetResultPacket = (u8*) kmalloc(0x400, GFP_KERNEL);
+
+	memset(GetInfoPacket, 0x82, 0x400);
+	memset(GetResultPacket, 0x68, 0x400);
+
+	request_irq(MT_ATN_INTERRUPT + IPHONE_GPIO_IRQS, multitouch_atn, IRQF_TRIGGER_FALLING, "iphone-multitouch", (void*) 0);
+
+	multitouch_on();
+
+	printk("multitouch: Sending A-Speed firmware...\n");
+	if(!loadASpeedFirmware(ASpeedFirmware, ASpeedFirmwareLen))
+	{
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return -1;
+	}
+
+	msleep(1);
+
+	printk("multitouch: Sending main firmware...\n");
+	if(!loadMainFirmware(mainFirmware, mainFirmwareLen))
+	{
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return -1;
+	}
+
+	msleep(1);
+
+	printk("multitouch: Determining interface version...\n");
+	if(!determineInterfaceVersion())
+	{
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return -1;
+	}
+
+	{
+		u8 reportBuffer[MaxPacketSize];
+		int reportLen;
+
+		if(!getReport(MT_INFO_FAMILYID, reportBuffer, &reportLen))
+		{
+			printk("multitouch: failed getting family id!\n");
+			kfree(InputPacket);
+			kfree(OutputPacket);
+			kfree(GetInfoPacket);
+			kfree(GetResultPacket);
+			return -1;
+		}
+
+		FamilyID = reportBuffer[0];
+
+		if(!getReport(MT_INFO_SENSORINFO, reportBuffer, &reportLen))
+		{
+			printk("multitouch: failed getting sensor info!\n");
+			kfree(InputPacket);
+			kfree(OutputPacket);
+			kfree(GetInfoPacket);
+			kfree(GetResultPacket);
+			return -1;
+		}
+
+		SensorColumns = reportBuffer[2];
+		SensorRows = reportBuffer[1];
+		BCDVersion = ((reportBuffer[3] & 0xFF) << 8) | (reportBuffer[4] & 0xFF);
+		Endianness = reportBuffer[0];
+
+		if(!getReport(MT_INFO_SENSORREGIONDESC, reportBuffer, &reportLen))
+		{
+			printk("multitouch: failed getting sensor region descriptor!\n");
+			kfree(InputPacket);
+			kfree(OutputPacket);
+			kfree(GetInfoPacket);
+			kfree(GetResultPacket);
+			return -1;
+		}
+
+		SensorRegionDescriptorLen = reportLen;
+		SensorRegionDescriptor = (u8*) kmalloc(reportLen, GFP_KERNEL);
+		memcpy(SensorRegionDescriptor, reportBuffer, reportLen);
+
+		if(!getReport(MT_INFO_SENSORREGIONPARAM, reportBuffer, &reportLen))
+		{
+			printk("multitouch: failed getting sensor region param!\n");
+			kfree(InputPacket);
+			kfree(OutputPacket);
+			kfree(GetInfoPacket);
+			kfree(GetResultPacket);
+			kfree(SensorRegionDescriptor);
+			return -1;
+		}
+
+		SensorRegionParamLen = reportLen;
+		SensorRegionParam = (u8*) kmalloc(reportLen, GFP_KERNEL);
+		memcpy(SensorRegionParam, reportBuffer, reportLen);
+
+		if(!getReport(MT_INFO_SENSORDIM, reportBuffer, &reportLen))
+		{
+			printk("multitouch: failed getting sensor surface dimensions!\n");
+			kfree(InputPacket);
+			kfree(OutputPacket);
+			kfree(GetInfoPacket);
+			kfree(GetResultPacket);
+			kfree(SensorRegionDescriptor);
+			kfree(SensorRegionParam);
+			return -1;
+		}
+
+		SensorWidth = (9000 - *((u32*)&reportBuffer[0])) * 84 / 73;
+		SensorHeight = (13850 - *((u32*)&reportBuffer[4])) * 84 / 73;
+	}
+
+	printk("Family ID                : 0x%x\n", FamilyID);
+	printk("Sensor rows              : 0x%x\n", SensorRows);
+	printk("Sensor columns           : 0x%x\n", SensorColumns);
+	printk("Sensor width             : 0x%x\n", SensorWidth);
+	printk("Sensor height            : 0x%x\n", SensorHeight);
+	printk("BCD Version              : 0x%x\n", BCDVersion);
+	printk("Endianness               : 0x%x\n", Endianness);
+	printk("Sensor region descriptor :");
+	for(i = 0; i < SensorRegionDescriptorLen; ++i)
+		printk(" %02x", SensorRegionDescriptor[i]);
+	printk("\n");
+
+	printk("Sensor region param      :");
+	for(i = 0; i < SensorRegionParamLen; ++i)
+		printk(" %02x", SensorRegionParam[i]);
+	printk("\n");
+
+	input_dev = input_allocate_device();
+	if(!input_dev)
+	{
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		kfree(SensorRegionDescriptor);
+		kfree(SensorRegionParam);
+		return -1;
+	}
+
+
+	input_dev->name = "iPhone Zephyr Multitouch Screen";
+	input_dev->phys = "multitouch0";
+	input_dev->id.vendor = 0x05AC;
+	input_dev->id.product = 0;
+	input_dev->id.version = 0x0000;
+	input_dev->dev.parent = multitouch_dev;
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	input_set_abs_params(input_dev, ABS_X, 0, SensorWidth, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, SensorHeight, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, max(SensorHeight, SensorWidth), 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0, max(SensorHeight, SensorWidth), 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, max(SensorHeight, SensorWidth), 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, max(SensorHeight, SensorWidth), 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_ORIENTATION, -MAX_FINGER_ORIENTATION, MAX_FINGER_ORIENTATION, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, SensorWidth, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, SensorHeight, 0, 0);
+
+	/* not sure what the actual max is */
+	input_set_abs_params(input_dev, ABS_MT_TRACKING_ID, 0, 32, 0, 0);
+
+	ret = input_register_device(input_dev);
+	if(ret != 0)
+	{
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		kfree(SensorRegionDescriptor);
+		kfree(SensorRegionParam);
+		return -1;
+	}
+
+	CurNOP = 0x64;
+	GotATN = 0;
+	spin_lock_init(&GotATNLock);
+
+	FirmwareLoaded = true;
+
+	readFrame();
+
+	return 0;
+}
+
+static void multitouch_atn_handler(struct work_struct* work)
+{
+	unsigned long flags;
+
+	if(!FirmwareLoaded)
+		return;
+
+	spin_lock_irqsave(&GotATNLock, flags);
+	while(GotATN)
+	{
+		--GotATN;
+		spin_unlock_irqrestore(&GotATNLock, flags);
+		while(readFrame() == 1);
+		spin_lock_irqsave(&GotATNLock, flags);
+	}
+	spin_unlock_irqrestore(&GotATNLock, flags);
+}
+
+static void newPacket(const u8* data, int len)
+{
+	int i;
+	FingerData* finger;
+	MTFrameHeader* header = (MTFrameHeader*) data;
+	if(header->type != 0x44 && header->type != 0x43)
+		printk("multitouch: unknown frame type 0x%x\n", header->type);
+
+	finger = (FingerData*)(data + (header->headerLen));
+
+	if(header->headerLen < 12)
+		printk("multitouch: no finger data in frame\n");
+
+	for(i = 0; i < header->numFingers; ++i)
+	{
+		if(finger->force_major > SensorMinPressure)
+		{
+			finger->force_major -= SensorMinPressure;
+		}
+		else
+			finger->force_major = 0;
+
+		if(finger->force_minor > SensorMinPressure)
+		{
+			finger->force_minor -= SensorMinPressure;
+		}
+		else 
+			finger->force_minor = 0;
+
+		if(finger->force_major > 0 || 
+				finger->force_minor > 0)
+		{
+			input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, finger->force_major);
+			input_report_abs(input_dev, ABS_MT_TOUCH_MINOR, finger->force_minor);
+			input_report_abs(input_dev, ABS_MT_WIDTH_MAJOR, finger->size_major);
+			input_report_abs(input_dev, ABS_MT_WIDTH_MINOR, finger->size_minor);
+			input_report_abs(input_dev, ABS_MT_ORIENTATION, MAX_FINGER_ORIENTATION - finger->orientation);
+			input_report_abs(input_dev, ABS_MT_TRACKING_ID, finger->id);
+			input_report_abs(input_dev, ABS_MT_POSITION_X, finger->x);
+			input_report_abs(input_dev, ABS_MT_POSITION_Y, SensorHeight - finger->y);
+		}
+
+		input_mt_sync(input_dev);
+
+		finger = (FingerData*) (((u8*) finger) + header->fingerDataLen);
+	}
+
+	if(header->numFingers > 0)
+	{
+		finger = (FingerData*)(data + (header->headerLen));
+
+		if (finger->force_minor > 0)
+		{
+			input_report_abs(input_dev, ABS_X, finger->x);
+			input_report_abs(input_dev, ABS_Y, SensorHeight - finger->y);
+			input_report_key(input_dev, BTN_TOUCH, finger->size_minor > 0);
+		}
+		else input_report_key(input_dev, BTN_TOUCH, 0);
+	}
+
+	input_sync(input_dev);
+}
+
+static int readFrame()
+{
+	int try = 0;
+
+	for(try = 0; try < 4; ++try)
+	{
+		int len = 0;
+		if(!readFrameLength(&len))
+		{
+			printk("multitouch: error getting frame length\n");
+			msleep(1);
+			continue;
+		}
+
+		if(len)
+		{
+			if(!readResultData(len + 1))
+			{
+				printk("multitouch: error getting frame data\n");
+				msleep(1);
+				continue;
+			}
+
+			if(CurNOP == 0x64)
+				CurNOP = 0x65;
+			else
+				CurNOP = 0x64;
+
+			return 1;
+		}
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static bool readResultData(int len)
+{
+	int try = 0;
+	for(try = 0; try < 4; ++try)
+	{
+		int checksum;
+		int myChecksum;
+		int i;
+
+		mt_spi_txrx(NORMAL_SPEED, GetResultPacket, len, InputPacket, len);
+
+		if(InputPacket[0] != 0xAA)
+		{
+			msleep(1);
+			continue;
+		}
+
+		checksum = ((InputPacket[len - 2] & 0xFF) << 8) | (InputPacket[len - 1] & 0xFF);
+		myChecksum = 0;
+
+		for(i = 1; i < (len - 2); ++i)
+			myChecksum += InputPacket[i];
+
+		myChecksum &= 0xFFFF;
+
+		if(myChecksum != checksum)
+		{
+			msleep(1);
+			continue;
+		}
+
+		newPacket(InputPacket + 1, len - 3);
+		return true;
+	}
+
+	return false;
+
+}
+
+static bool readFrameLength(int* len)
+{
+	int try;
+	u8 tx[8];
+	u8 rx[8];
+	memset(tx, CurNOP, sizeof(tx));
+
+	try = 0;
+	for(try = 0; try < 4; ++try)
+	{
+		int tLen;
+		int tLenCkSum;
+		int checksum;
+
+		mt_spi_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+		if(rx[0] != 0xAA)
+		{
+			msleep(1);
+			continue;
+		}
+
+		tLen = ((rx[4] & 0xFF) << 8) | (rx[5] & 0xFF);
+		tLenCkSum = (rx[4] + rx[5]) & 0xFFFF;
+		checksum = ((rx[6] & 0xFF) << 8) | (rx[7] & 0xFF);
+		if(tLenCkSum != checksum)
+		{
+			msleep(1);
+			continue;
+		}
+
+		if(tLen > MaxPacketSize)
+		{
+			printk("multitouch: device unexpectedly requested to transfer a %d byte packet. Max size = %d\n", tLen, MaxPacketSize);
+			msleep(1);
+			continue;
+		}
+
+		*len = tLen;
+
+		return true;
+	}
+
+	return false;
+}
+
+static bool getReport(int id, u8* buffer, int* outLen)
+{
+	u8 err;
+	u16 len;
+	int try;
+	if(!getReportInfo(id, &err, &len))
+		return false;
+
+	if(err)
+		return false;
+
+	try = 0;
+	for(try = 0; try < 4; ++try)
+	{
+		int checksum;
+		int myChecksum;
+		int i;
+
+		GetInfoPacket[1] = id;
+		mt_spi_txrx(NORMAL_SPEED, GetInfoPacket, len + 6, InputPacket, len + 6);
+
+		if(InputPacket[0] != 0xAA)
+		{
+			msleep(1);
+			continue;
+		}
+
+		checksum = ((InputPacket[len + 4] & 0xFF) << 8) | (InputPacket[len + 5] & 0xFF);
+		myChecksum = id;
+
+		for(i = 0; i < len; ++i)
+			myChecksum += InputPacket[i + 4];
+
+		myChecksum &= 0xFFFF;
+
+		if(myChecksum != checksum)
+		{
+			msleep(1);
+			continue;
+		}
+
+		*outLen = len;
+		memcpy(buffer, &InputPacket[4], len);
+
+		return true;
+	}
+
+	return false;
+}
+
+static bool getReportInfo(int id, u8* err, u16* len)
+{
+	u8 tx[8];
+	u8 rx[8];
+
+	int try;
+	for(try = 0; try < 4; ++try)
+	{
+		int checksum;
+		int myChecksum;
+
+		memset(tx, 0x8F, 8);
+		tx[1] = id;
+
+		mt_spi_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+		if(rx[0] != 0xAA)
+		{
+			msleep(1);
+			continue;
+		}
+
+		checksum = ((rx[6] & 0xFF) << 8) | (rx[7] & 0xFF);
+		myChecksum = (id + rx[4] + rx[5]) & 0xFFFF;
+
+		if(checksum != myChecksum)
+		{
+			msleep(1);
+			continue;
+		}
+
+		*err = (rx[4] >> 4) & 0xF;
+		*len = ((rx[4] & 0xF) << 8) | (rx[5] & 0xFF);
+
+		return true;
+	}
+
+	return false;
+}
+
+static bool determineInterfaceVersion()
+{
+	u8 tx[4];
+	u8 rx[4];
+
+	int try;
+	for(try = 0; try < 4; ++try)
+	{
+		memset(tx, 0xD0, 4);
+
+		mt_spi_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+		if(rx[0] == 0xAA)
+		{
+			InterfaceVersion = rx[1];
+			MaxPacketSize = (rx[2] << 8) | rx[3];
+
+			printk("multitouch: interface version %d, max packet size: %d\n", InterfaceVersion, MaxPacketSize);
+			return true;
+		}
+
+		InterfaceVersion = 0;
+		MaxPacketSize = 1000;
+		msleep(3);
+	}
+
+	printk("multitouch: failed getting interface version!\n");
+
+	return false;
+}
+
+static bool loadASpeedFirmware(const u8* firmware, int len)
+{
+	u32 address = 0x40000000;
+	const u8* data = firmware;
+	int left = len;
+
+	while(left > 0)
+	{
+		int checksum;
+		int try;
+		int toUpload = left;
+		if(toUpload > 0x3F8)
+			toUpload = 0x3F8;
+
+		makeBootloaderDataPacket(OutputPacket, address, data, toUpload, &checksum);
+
+		for(try = 0; try < 5; ++try)
+		{
+			printk("multitouch: uploading data packet\n");
+			mt_spi_tx(NORMAL_SPEED, OutputPacket, 0x400);
+
+			udelay(300);
+
+			if(verifyUpload(checksum))
+				break;
+		}
+
+		if(try == 5)
+			return false;
+
+		address += toUpload;
+		data += toUpload;
+		left -= toUpload;
+	}
+
+	sendExecutePacket();
+
+	return true;
+}
+
+static bool loadMainFirmware(const u8* firmware, int len)
+{
+	int checksum = 0;
+
+	int i;
+	for(i = 0; i < len; ++i)
+		checksum += firmware[i];
+
+	for(i = 0; i < 5; ++i)
+	{
+		sendBlankDataPacket();
+
+		printk("multitouch: uploading main firmware\n");
+		mt_spi_tx(FAST_SPEED, firmware, len);
+
+		if(verifyUpload(checksum))
+			break;
+	}
+
+	if(i == 5)
+		return false;
+
+	sendExecutePacket();
+
+	return true;
+}
+
+static bool verifyUpload(int checksum)
+{
+	u8 tx[4];
+	u8 rx[4];
+
+	tx[0] = 5;
+	tx[1] = 0;
+	tx[2] = 0;
+	tx[3] = 6;
+
+	mt_spi_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+	if(rx[0] != 0xD0 || rx[1] != 0x0)
+	{
+		printk("multitouch: data verification failed type bytes, got %02x %02x %02x %02x -- %x\n", rx[0], rx[1], rx[2], rx[3], checksum);
+		return false;
+	}
+
+	if(rx[2] != ((checksum >> 8) & 0xFF))
+	{
+		printk("multitouch: data verification failed upper checksum, %02x != %02x\n", rx[2], (checksum >> 8) & 0xFF);
+		return false;
+	}
+
+	if(rx[3] != (checksum & 0xFF))
+	{
+		printk("multitouch: data verification failed lower checksum, %02x != %02x\n", rx[3], checksum & 0xFF);
+		return false;
+	}
+
+	printk("multitouch: data verification successful\n");
+	return true;
+}
+
+
+static void sendExecutePacket(void)
+{
+	u8 tx[4];
+	u8 rx[4];
+
+	tx[0] = 0xC4;
+	tx[1] = 0;
+	tx[2] = 0;
+	tx[3] = 0xC4;
+
+	mt_spi_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+	printk("multitouch: execute packet sent\n");
+}
+
+static void sendBlankDataPacket(void)
+{
+	u8 tx[4];
+	u8 rx[4];
+
+	tx[0] = 0xC2;
+	tx[1] = 0;
+	tx[2] = 0;
+	tx[3] = 0;
+
+	mt_spi_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+	printk("multitouch: blank data packet sent\n");
+}
+
+static int makeBootloaderDataPacket(u8* output, u32 destAddress, const u8* data, int dataLen, int* cksumOut)
+{
+	int checksum;
+	int i;
+
+	if(dataLen > 0x3F8)
+		dataLen = 0x3F8;
+
+	output[0] = 0xC2;
+	output[1] = (destAddress >> 24) & 0xFF;
+	output[2] = (destAddress >> 16) & 0xFF;
+	output[3] = (destAddress >> 8) & 0xFF;
+	output[4] = destAddress & 0xFF;
+	output[5] = 0;
+
+	checksum = 0;
+
+	for(i = 0; i < dataLen; ++i)
+	{
+		u8 byte = data[i];
+		checksum += byte;
+		output[6 + i] = byte;
+	}
+
+	for(i = 0; i < 6; ++i)
+	{
+		checksum += output[i];
+	}
+
+	memset(output + dataLen + 6, 0, 0x3F8 - dataLen);
+	output[0x3FE] = (checksum >> 8) & 0xFF;
+	output[0x3FF] = checksum & 0xFF;
+
+	*cksumOut = checksum;
+
+	return dataLen;
+}
+
+static irqreturn_t multitouch_atn(int irq, void* pToken)
+{
+	unsigned long flags;
+
+	if(!FirmwareLoaded)
+		return IRQ_HANDLED;
+
+	spin_lock_irqsave(&GotATNLock, flags);
+	++GotATN;
+	spin_unlock_irqrestore(&GotATNLock, flags);
+
+	schedule_work(&multitouch_workqueue);
+	return IRQ_HANDLED;
+}
+
+
+int mt_spi_tx(const MTSPISetting* setting, const u8* outBuffer, int outLen)
+{
+	int ret;
+	iphone_spi_set_baud(MT_SPI, setting->speed, SPIOption13Setting0, 1, 1, 1);
+	iphone_gpio_pin_output(MT_SPI_CS, 0);
+	msleep(setting->txDelay);
+	ret = iphone_spi_tx(MT_SPI, outBuffer, outLen, true, false);
+	iphone_gpio_pin_output(MT_SPI_CS, 1);
+	return ret;
+}
+
+int mt_spi_txrx(const MTSPISetting* setting, const u8* outBuffer, int outLen, u8* inBuffer, int inLen)
+{
+	int ret;
+	iphone_spi_set_baud(MT_SPI, setting->speed, SPIOption13Setting0, 1, 1, 1);
+	iphone_gpio_pin_output(MT_SPI_CS, 0);
+	msleep(setting->rxDelay);
+	ret = iphone_spi_txrx(MT_SPI, outBuffer, outLen, inBuffer, inLen, true);
+	iphone_gpio_pin_output(MT_SPI_CS, 1);
+	return ret;
+}
+
+static void got_main(const struct firmware* fw, void *context)
+{
+	if(!fw)
+	{
+		printk("multitouch: couldn't get main firmware, trying again...\n");
+		request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG, "zephyr_main.bin", multitouch_dev, NULL, got_main);
+		return;
+	}
+
+	main_fw = kmalloc(fw->size, GFP_KERNEL);
+	main_fw_size = fw->size;
+	memcpy(main_fw, fw->data, fw->size);
+
+	printk("multitouch: initializing multitouch\n");
+	multitouch_setup(aspeed_fw, aspeed_fw_size, main_fw, main_fw_size);
+
+	/* caller will call release_firmware */
+}
+
+static void got_aspeed(const struct firmware* fw, void *context)
+{
+	if(!fw)
+	{
+		printk("multitouch: couldn't get a-speed firmware, trying again...\n");
+		request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG, "zephyr_aspeed.bin", multitouch_dev, NULL, got_aspeed);
+		return;
+	}
+
+	aspeed_fw = kmalloc(fw->size, GFP_KERNEL);
+	aspeed_fw_size = fw->size;
+	memcpy(aspeed_fw, fw->data, fw->size);
+
+	printk("multitouch: requesting main firmware\n");
+	request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG, "zephyr_main.bin", multitouch_dev, NULL, got_main);
+
+	/* caller will call release_firmware */
+}
+
+static int iphone_multitouch_probe(struct platform_device *pdev)
+{
+	/* this driver is such a hack */
+	if(multitouch_dev)
+		return -EBUSY;
+
+	multitouch_dev = &pdev->dev;
+
+	printk("multitouch: requesting A-Speed firmware\n");
+	return request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG, "zephyr_aspeed.bin", multitouch_dev, NULL, got_aspeed);
+}
+
+static int iphone_multitouch_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver iphone_multitouch_driver = {
+	.probe = iphone_multitouch_probe,
+	.remove = iphone_multitouch_remove,
+	.suspend = NULL, /* optional but recommended */
+	.resume = NULL,   /* optional but recommended */
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "iphone-multitouch",
+	},
+};
+
+static struct platform_device iphone_multitouch_dev = {
+	.name = "iphone-multitouch",
+	.id = -1,
+};
+
+static int __init iphone_multitouch_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&iphone_multitouch_driver);
+
+	if (!ret) {
+		ret = platform_device_register(&iphone_multitouch_dev);
+
+		if (ret != 0) {
+			platform_driver_unregister(&iphone_multitouch_driver);
+		}
+	}
+	return ret;
+}
+
+static void __exit iphone_multitouch_exit(void)
+{
+	platform_device_unregister(&iphone_multitouch_dev);
+	platform_driver_unregister(&iphone_multitouch_driver);
+}
+
+module_init(iphone_multitouch_init);
+module_exit(iphone_multitouch_exit);
+
+MODULE_DESCRIPTION("iPhone Zephyr multitouch driver");
+MODULE_AUTHOR("Yiduo Wang");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/drivers/input/touchscreen/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/input/touchscreen/Kconfig
--- linux-2.6.32-orig/drivers/input/touchscreen/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/touchscreen/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -11,6 +11,14 @@
 
 if INPUT_TOUCHSCREEN
 
+config TOUCHSCREEN_APPLE_IPHONE
+	tristate "Apple iPhone Zephyr TouchScreen (iPhone 2G)"
+	depends on MACH_APPLE_IPHONE
+
+config TOUCHSCREEN_APPLE_ZEPHYR2
+	tristate "Apple iPhone Zephyr2 TouchScreen (iPhone 3G+)"
+	depends on MACH_APPLE_IPHONE
+
 config TOUCHSCREEN_ADS7846
 	tristate "ADS7846/TSC2046 and ADS7843 based touchscreens"
 	depends on SPI_MASTER
@@ -271,6 +279,12 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called migor_ts.
 
+config TOUCHSCREEN_SYNAPTICS_I2C_RMI
+	tristate "Synaptics i2c touchscreen"
+	depends on I2C
+	help
+	  This enables support for Synaptics RMI over I2C based touchscreens.
+
 config TOUCHSCREEN_TOUCHRIGHT
 	tristate "Touchright serial touchscreen"
 	select SERIO
diff -Nur linux-2.6.32-orig/drivers/input/touchscreen/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/input/touchscreen/Makefile
--- linux-2.6.32-orig/drivers/input/touchscreen/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/touchscreen/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -6,6 +6,8 @@
 
 wm97xx-ts-y := wm97xx-core.o
 
+obj-$(CONFIG_TOUCHSCREEN_APPLE_IPHONE)	+= iphone-mt.o
+obj-$(CONFIG_TOUCHSCREEN_APPLE_ZEPHYR2) += zephyr2.o
 obj-$(CONFIG_TOUCHSCREEN_AD7877)	+= ad7877.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879)	+= ad7879.o
 obj-$(CONFIG_TOUCHSCREEN_ADS7846)	+= ads7846.o
@@ -26,6 +28,7 @@
 obj-$(CONFIG_TOUCHSCREEN_HTCPEN)	+= htcpen.o
 obj-$(CONFIG_TOUCHSCREEN_USB_COMPOSITE)	+= usbtouchscreen.o
 obj-$(CONFIG_TOUCHSCREEN_PENMOUNT)	+= penmount.o
+obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI)	+= synaptics_i2c_rmi.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHIT213)	+= touchit213.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHRIGHT)	+= touchright.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHWIN)	+= touchwin.o
diff -Nur linux-2.6.32-orig/drivers/input/touchscreen/synaptics_i2c_rmi.c iDroid-Project-kernel_common-9e90fd2/drivers/input/touchscreen/synaptics_i2c_rmi.c
--- linux-2.6.32-orig/drivers/input/touchscreen/synaptics_i2c_rmi.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/touchscreen/synaptics_i2c_rmi.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,674 @@
+/* drivers/input/keyboard/synaptics_i2c_rmi.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/earlysuspend.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/synaptics_i2c_rmi.h>
+
+static struct workqueue_struct *synaptics_wq;
+
+struct synaptics_ts_data {
+	uint16_t addr;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	int use_irq;
+	bool has_relative_report;
+	struct hrtimer timer;
+	struct work_struct  work;
+	uint16_t max[2];
+	int snap_state[2][2];
+	int snap_down_on[2];
+	int snap_down_off[2];
+	int snap_up_on[2];
+	int snap_up_off[2];
+	int snap_down[2];
+	int snap_up[2];
+	uint32_t flags;
+	int reported_finger_count;
+	int8_t sensitivity_adjust;
+	int (*power)(int on);
+	struct early_suspend early_suspend;
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void synaptics_ts_early_suspend(struct early_suspend *h);
+static void synaptics_ts_late_resume(struct early_suspend *h);
+#endif
+
+static int synaptics_init_panel(struct synaptics_ts_data *ts)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x10); /* page select = 0x10 */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
+		goto err_page_select_failed;
+	}
+	ret = i2c_smbus_write_byte_data(ts->client, 0x41, 0x04); /* Set "No Clip Z" */
+	if (ret < 0)
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for No Clip Z\n");
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0x44,
+					ts->sensitivity_adjust);
+	if (ret < 0)
+		pr_err("synaptics_ts: failed to set Sensitivity Adjust\n");
+
+err_page_select_failed:
+	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x04); /* page select = 0x04 */
+	if (ret < 0)
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf0, 0x81); /* normal operation, 80 reports per second */
+	if (ret < 0)
+		printk(KERN_ERR "synaptics_ts_resume: i2c_smbus_write_byte_data failed\n");
+	return ret;
+}
+
+static void synaptics_ts_work_func(struct work_struct *work)
+{
+	int i;
+	int ret;
+	int bad_data = 0;
+	struct i2c_msg msg[2];
+	uint8_t start_reg;
+	uint8_t buf[15];
+	struct synaptics_ts_data *ts = container_of(work, struct synaptics_ts_data, work);
+	int buf_len = ts->has_relative_report ? 15 : 13;
+
+	msg[0].addr = ts->client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = &start_reg;
+	start_reg = 0x00;
+	msg[1].addr = ts->client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = buf_len;
+	msg[1].buf = buf;
+
+	/* printk("synaptics_ts_work_func\n"); */
+	for (i = 0; i < ((ts->use_irq && !bad_data) ? 1 : 10); i++) {
+		ret = i2c_transfer(ts->client->adapter, msg, 2);
+		if (ret < 0) {
+			printk(KERN_ERR "synaptics_ts_work_func: i2c_transfer failed\n");
+			bad_data = 1;
+		} else {
+			/* printk("synaptics_ts_work_func: %x %x %x %x %x %x" */
+			/*        " %x %x %x %x %x %x %x %x %x, ret %d\n", */
+			/*        buf[0], buf[1], buf[2], buf[3], */
+			/*        buf[4], buf[5], buf[6], buf[7], */
+			/*        buf[8], buf[9], buf[10], buf[11], */
+			/*        buf[12], buf[13], buf[14], ret); */
+			if ((buf[buf_len - 1] & 0xc0) != 0x40) {
+				printk(KERN_WARNING "synaptics_ts_work_func:"
+				       " bad read %x %x %x %x %x %x %x %x %x"
+				       " %x %x %x %x %x %x, ret %d\n",
+				       buf[0], buf[1], buf[2], buf[3],
+				       buf[4], buf[5], buf[6], buf[7],
+				       buf[8], buf[9], buf[10], buf[11],
+				       buf[12], buf[13], buf[14], ret);
+				if (bad_data)
+					synaptics_init_panel(ts);
+				bad_data = 1;
+				continue;
+			}
+			bad_data = 0;
+			if ((buf[buf_len - 1] & 1) == 0) {
+				/* printk("read %d coordinates\n", i); */
+				break;
+			} else {
+				int pos[2][2];
+				int f, a;
+				int base;
+				/* int x = buf[3] | (uint16_t)(buf[2] & 0x1f) << 8; */
+				/* int y = buf[5] | (uint16_t)(buf[4] & 0x1f) << 8; */
+				int z = buf[1];
+				int w = buf[0] >> 4;
+				int finger = buf[0] & 7;
+
+				/* int x2 = buf[3+6] | (uint16_t)(buf[2+6] & 0x1f) << 8; */
+				/* int y2 = buf[5+6] | (uint16_t)(buf[4+6] & 0x1f) << 8; */
+				/* int z2 = buf[1+6]; */
+				/* int w2 = buf[0+6] >> 4; */
+				/* int finger2 = buf[0+6] & 7; */
+
+				/* int dx = (int8_t)buf[12]; */
+				/* int dy = (int8_t)buf[13]; */
+				int finger2_pressed;
+
+				/* printk("x %4d, y %4d, z %3d, w %2d, F %d, 2nd: x %4d, y %4d, z %3d, w %2d, F %d, dx %4d, dy %4d\n", */
+				/*	x, y, z, w, finger, */
+				/*	x2, y2, z2, w2, finger2, */
+				/*	dx, dy); */
+
+				base = 2;
+				for (f = 0; f < 2; f++) {
+					uint32_t flip_flag = SYNAPTICS_FLIP_X;
+					for (a = 0; a < 2; a++) {
+						int p = buf[base + 1];
+						p |= (uint16_t)(buf[base] & 0x1f) << 8;
+						if (ts->flags & flip_flag)
+							p = ts->max[a] - p;
+						if (ts->flags & SYNAPTICS_SNAP_TO_INACTIVE_EDGE) {
+							if (ts->snap_state[f][a]) {
+								if (p <= ts->snap_down_off[a])
+									p = ts->snap_down[a];
+								else if (p >= ts->snap_up_off[a])
+									p = ts->snap_up[a];
+								else
+									ts->snap_state[f][a] = 0;
+							} else {
+								if (p <= ts->snap_down_on[a]) {
+									p = ts->snap_down[a];
+									ts->snap_state[f][a] = 1;
+								} else if (p >= ts->snap_up_on[a]) {
+									p = ts->snap_up[a];
+									ts->snap_state[f][a] = 1;
+								}
+							}
+						}
+						pos[f][a] = p;
+						base += 2;
+						flip_flag <<= 1;
+					}
+					base += 2;
+					if (ts->flags & SYNAPTICS_SWAP_XY)
+						swap(pos[f][0], pos[f][1]);
+				}
+				if (z) {
+					input_report_abs(ts->input_dev, ABS_X, pos[0][0]);
+					input_report_abs(ts->input_dev, ABS_Y, pos[0][1]);
+				}
+				input_report_abs(ts->input_dev, ABS_PRESSURE, z);
+				input_report_abs(ts->input_dev, ABS_TOOL_WIDTH, w);
+				input_report_key(ts->input_dev, BTN_TOUCH, finger);
+				finger2_pressed = finger > 1 && finger != 7;
+				input_report_key(ts->input_dev, BTN_2, finger2_pressed);
+				if (finger2_pressed) {
+					input_report_abs(ts->input_dev, ABS_HAT0X, pos[1][0]);
+					input_report_abs(ts->input_dev, ABS_HAT0Y, pos[1][1]);
+				}
+
+				if (!finger)
+					z = 0;
+				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, z);
+				input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, pos[0][0]);
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, pos[0][1]);
+				input_mt_sync(ts->input_dev);
+				if (finger2_pressed) {
+					input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, z);
+					input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+					input_report_abs(ts->input_dev, ABS_MT_POSITION_X, pos[1][0]);
+					input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, pos[1][1]);
+					input_mt_sync(ts->input_dev);
+				} else if (ts->reported_finger_count > 1) {
+					input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+					input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0);
+					input_mt_sync(ts->input_dev);
+				}
+				ts->reported_finger_count = finger;
+				input_sync(ts->input_dev);
+			}
+		}
+	}
+	if (ts->use_irq)
+		enable_irq(ts->client->irq);
+}
+
+static enum hrtimer_restart synaptics_ts_timer_func(struct hrtimer *timer)
+{
+	struct synaptics_ts_data *ts = container_of(timer, struct synaptics_ts_data, timer);
+	/* printk("synaptics_ts_timer_func\n"); */
+
+	queue_work(synaptics_wq, &ts->work);
+
+	hrtimer_start(&ts->timer, ktime_set(0, 12500000), HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t synaptics_ts_irq_handler(int irq, void *dev_id)
+{
+	struct synaptics_ts_data *ts = dev_id;
+
+	/* printk("synaptics_ts_irq_handler\n"); */
+	disable_irq_nosync(ts->client->irq);
+	queue_work(synaptics_wq, &ts->work);
+	return IRQ_HANDLED;
+}
+
+static int synaptics_ts_probe(
+	struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct synaptics_ts_data *ts;
+	uint8_t buf0[4];
+	uint8_t buf1[8];
+	struct i2c_msg msg[2];
+	int ret = 0;
+	uint16_t max_x, max_y;
+	int fuzz_x, fuzz_y, fuzz_p, fuzz_w;
+	struct synaptics_i2c_rmi_platform_data *pdata;
+	unsigned long irqflags;
+	int inactive_area_left;
+	int inactive_area_right;
+	int inactive_area_top;
+	int inactive_area_bottom;
+	int snap_left_on;
+	int snap_left_off;
+	int snap_right_on;
+	int snap_right_off;
+	int snap_top_on;
+	int snap_top_off;
+	int snap_bottom_on;
+	int snap_bottom_off;
+	uint32_t panel_version;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		printk(KERN_ERR "synaptics_ts_probe: need I2C_FUNC_I2C\n");
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL) {
+		ret = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+	INIT_WORK(&ts->work, synaptics_ts_work_func);
+	ts->client = client;
+	i2c_set_clientdata(client, ts);
+	pdata = client->dev.platform_data;
+	if (pdata)
+		ts->power = pdata->power;
+	if (ts->power) {
+		ret = ts->power(1);
+		if (ret < 0) {
+			printk(KERN_ERR "synaptics_ts_probe power on failed\n");
+			goto err_power_failed;
+		}
+	}
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf4, 0x01); /* device command = reset */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed\n");
+		/* fail? */
+	}
+	{
+		int retry = 10;
+		while (retry-- > 0) {
+			ret = i2c_smbus_read_byte_data(ts->client, 0xe4);
+			if (ret >= 0)
+				break;
+			msleep(100);
+		}
+	}
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: Product Major Version %x\n", ret);
+	panel_version = ret << 8;
+	ret = i2c_smbus_read_byte_data(ts->client, 0xe5);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: Product Minor Version %x\n", ret);
+	panel_version |= ret;
+
+	ret = i2c_smbus_read_byte_data(ts->client, 0xe3);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: product property %x\n", ret);
+
+	if (pdata) {
+		while (pdata->version > panel_version)
+			pdata++;
+		ts->flags = pdata->flags;
+		ts->sensitivity_adjust = pdata->sensitivity_adjust;
+		irqflags = pdata->irqflags;
+		inactive_area_left = pdata->inactive_left;
+		inactive_area_right = pdata->inactive_right;
+		inactive_area_top = pdata->inactive_top;
+		inactive_area_bottom = pdata->inactive_bottom;
+		snap_left_on = pdata->snap_left_on;
+		snap_left_off = pdata->snap_left_off;
+		snap_right_on = pdata->snap_right_on;
+		snap_right_off = pdata->snap_right_off;
+		snap_top_on = pdata->snap_top_on;
+		snap_top_off = pdata->snap_top_off;
+		snap_bottom_on = pdata->snap_bottom_on;
+		snap_bottom_off = pdata->snap_bottom_off;
+		fuzz_x = pdata->fuzz_x;
+		fuzz_y = pdata->fuzz_y;
+		fuzz_p = pdata->fuzz_p;
+		fuzz_w = pdata->fuzz_w;
+	} else {
+		irqflags = 0;
+		inactive_area_left = 0;
+		inactive_area_right = 0;
+		inactive_area_top = 0;
+		inactive_area_bottom = 0;
+		snap_left_on = 0;
+		snap_left_off = 0;
+		snap_right_on = 0;
+		snap_right_off = 0;
+		snap_top_on = 0;
+		snap_top_off = 0;
+		snap_bottom_on = 0;
+		snap_bottom_off = 0;
+		fuzz_x = 0;
+		fuzz_y = 0;
+		fuzz_p = 0;
+		fuzz_w = 0;
+	}
+
+	ret = i2c_smbus_read_byte_data(ts->client, 0xf0);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: device control %x\n", ret);
+
+	ret = i2c_smbus_read_byte_data(ts->client, 0xf1);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: interrupt enable %x\n", ret);
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf1, 0); /* disable interrupt */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed\n");
+		goto err_detect_failed;
+	}
+
+	msg[0].addr = ts->client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf0;
+	buf0[0] = 0xe0;
+	msg[1].addr = ts->client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 8;
+	msg[1].buf = buf1;
+	ret = i2c_transfer(ts->client->adapter, msg, 2);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_transfer failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: 0xe0: %x %x %x %x %x %x %x %x\n",
+	       buf1[0], buf1[1], buf1[2], buf1[3],
+	       buf1[4], buf1[5], buf1[6], buf1[7]);
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x10); /* page select = 0x10 */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
+		goto err_detect_failed;
+	}
+	ret = i2c_smbus_read_word_data(ts->client, 0x02);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		goto err_detect_failed;
+	}
+	ts->has_relative_report = !(ret & 0x100);
+	printk(KERN_INFO "synaptics_ts_probe: Sensor properties %x\n", ret);
+	ret = i2c_smbus_read_word_data(ts->client, 0x04);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		goto err_detect_failed;
+	}
+	ts->max[0] = max_x = (ret >> 8 & 0xff) | ((ret & 0x1f) << 8);
+	ret = i2c_smbus_read_word_data(ts->client, 0x06);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		goto err_detect_failed;
+	}
+	ts->max[1] = max_y = (ret >> 8 & 0xff) | ((ret & 0x1f) << 8);
+	if (ts->flags & SYNAPTICS_SWAP_XY)
+		swap(max_x, max_y);
+
+	ret = synaptics_init_panel(ts); /* will also switch back to page 0x04 */
+	if (ret < 0) {
+		printk(KERN_ERR "synaptics_init_panel failed\n");
+		goto err_detect_failed;
+	}
+
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) {
+		ret = -ENOMEM;
+		printk(KERN_ERR "synaptics_ts_probe: Failed to allocate input device\n");
+		goto err_input_dev_alloc_failed;
+	}
+	ts->input_dev->name = "synaptics-rmi-touchscreen";
+	set_bit(EV_SYN, ts->input_dev->evbit);
+	set_bit(EV_KEY, ts->input_dev->evbit);
+	set_bit(BTN_TOUCH, ts->input_dev->keybit);
+	set_bit(BTN_2, ts->input_dev->keybit);
+	set_bit(EV_ABS, ts->input_dev->evbit);
+	inactive_area_left = inactive_area_left * max_x / 0x10000;
+	inactive_area_right = inactive_area_right * max_x / 0x10000;
+	inactive_area_top = inactive_area_top * max_y / 0x10000;
+	inactive_area_bottom = inactive_area_bottom * max_y / 0x10000;
+	snap_left_on = snap_left_on * max_x / 0x10000;
+	snap_left_off = snap_left_off * max_x / 0x10000;
+	snap_right_on = snap_right_on * max_x / 0x10000;
+	snap_right_off = snap_right_off * max_x / 0x10000;
+	snap_top_on = snap_top_on * max_y / 0x10000;
+	snap_top_off = snap_top_off * max_y / 0x10000;
+	snap_bottom_on = snap_bottom_on * max_y / 0x10000;
+	snap_bottom_off = snap_bottom_off * max_y / 0x10000;
+	fuzz_x = fuzz_x * max_x / 0x10000;
+	fuzz_y = fuzz_y * max_y / 0x10000;
+	ts->snap_down[!!(ts->flags & SYNAPTICS_SWAP_XY)] = -inactive_area_left;
+	ts->snap_up[!!(ts->flags & SYNAPTICS_SWAP_XY)] = max_x + inactive_area_right;
+	ts->snap_down[!(ts->flags & SYNAPTICS_SWAP_XY)] = -inactive_area_top;
+	ts->snap_up[!(ts->flags & SYNAPTICS_SWAP_XY)] = max_y + inactive_area_bottom;
+	ts->snap_down_on[!!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_left_on;
+	ts->snap_down_off[!!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_left_off;
+	ts->snap_up_on[!!(ts->flags & SYNAPTICS_SWAP_XY)] = max_x - snap_right_on;
+	ts->snap_up_off[!!(ts->flags & SYNAPTICS_SWAP_XY)] = max_x - snap_right_off;
+	ts->snap_down_on[!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_top_on;
+	ts->snap_down_off[!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_top_off;
+	ts->snap_up_on[!(ts->flags & SYNAPTICS_SWAP_XY)] = max_y - snap_bottom_on;
+	ts->snap_up_off[!(ts->flags & SYNAPTICS_SWAP_XY)] = max_y - snap_bottom_off;
+	printk(KERN_INFO "synaptics_ts_probe: max_x %d, max_y %d\n", max_x, max_y);
+	printk(KERN_INFO "synaptics_ts_probe: inactive_x %d %d, inactive_y %d %d\n",
+	       inactive_area_left, inactive_area_right,
+	       inactive_area_top, inactive_area_bottom);
+	printk(KERN_INFO "synaptics_ts_probe: snap_x %d-%d %d-%d, snap_y %d-%d %d-%d\n",
+	       snap_left_on, snap_left_off, snap_right_on, snap_right_off,
+	       snap_top_on, snap_top_off, snap_bottom_on, snap_bottom_off);
+	input_set_abs_params(ts->input_dev, ABS_X, -inactive_area_left, max_x + inactive_area_right, fuzz_x, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, -inactive_area_top, max_y + inactive_area_bottom, fuzz_y, 0);
+	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, fuzz_p, 0);
+	input_set_abs_params(ts->input_dev, ABS_TOOL_WIDTH, 0, 15, fuzz_w, 0);
+	input_set_abs_params(ts->input_dev, ABS_HAT0X, -inactive_area_left, max_x + inactive_area_right, fuzz_x, 0);
+	input_set_abs_params(ts->input_dev, ABS_HAT0Y, -inactive_area_top, max_y + inactive_area_bottom, fuzz_y, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, -inactive_area_left, max_x + inactive_area_right, fuzz_x, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, -inactive_area_top, max_y + inactive_area_bottom, fuzz_y, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, fuzz_p, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 15, fuzz_w, 0);
+	/* ts->input_dev->name = ts->keypad_info->name; */
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		printk(KERN_ERR "synaptics_ts_probe: Unable to register %s input device\n", ts->input_dev->name);
+		goto err_input_register_device_failed;
+	}
+	if (client->irq) {
+		ret = request_irq(client->irq, synaptics_ts_irq_handler, irqflags, client->name, ts);
+		if (ret == 0) {
+			ret = i2c_smbus_write_byte_data(ts->client, 0xf1, 0x01); /* enable abs int */
+			if (ret)
+				free_irq(client->irq, ts);
+		}
+		if (ret == 0)
+			ts->use_irq = 1;
+		else
+			dev_err(&client->dev, "request_irq failed\n");
+	}
+	if (!ts->use_irq) {
+		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ts->timer.function = synaptics_ts_timer_func;
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ts->early_suspend.suspend = synaptics_ts_early_suspend;
+	ts->early_suspend.resume = synaptics_ts_late_resume;
+	register_early_suspend(&ts->early_suspend);
+#endif
+
+	printk(KERN_INFO "synaptics_ts_probe: Start touchscreen %s in %s mode\n", ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");
+
+	return 0;
+
+err_input_register_device_failed:
+	input_free_device(ts->input_dev);
+
+err_input_dev_alloc_failed:
+err_detect_failed:
+err_power_failed:
+	kfree(ts);
+err_alloc_data_failed:
+err_check_functionality_failed:
+	return ret;
+}
+
+static int synaptics_ts_remove(struct i2c_client *client)
+{
+	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
+	unregister_early_suspend(&ts->early_suspend);
+	if (ts->use_irq)
+		free_irq(client->irq, ts);
+	else
+		hrtimer_cancel(&ts->timer);
+	input_unregister_device(ts->input_dev);
+	kfree(ts);
+	return 0;
+}
+
+static int synaptics_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int ret;
+	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->use_irq)
+		disable_irq(client->irq);
+	else
+		hrtimer_cancel(&ts->timer);
+	ret = cancel_work_sync(&ts->work);
+	if (ret && ts->use_irq) /* if work was pending disable-count is now 2 */
+		enable_irq(client->irq);
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf1, 0); /* disable interrupt */
+	if (ret < 0)
+		printk(KERN_ERR "synaptics_ts_suspend: i2c_smbus_write_byte_data failed\n");
+
+	ret = i2c_smbus_write_byte_data(client, 0xf0, 0x86); /* deep sleep */
+	if (ret < 0)
+		printk(KERN_ERR "synaptics_ts_suspend: i2c_smbus_write_byte_data failed\n");
+	if (ts->power) {
+		ret = ts->power(0);
+		if (ret < 0)
+			printk(KERN_ERR "synaptics_ts_resume power off failed\n");
+	}
+	return 0;
+}
+
+static int synaptics_ts_resume(struct i2c_client *client)
+{
+	int ret;
+	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->power) {
+		ret = ts->power(1);
+		if (ret < 0)
+			printk(KERN_ERR "synaptics_ts_resume power on failed\n");
+	}
+
+	synaptics_init_panel(ts);
+
+	if (ts->use_irq)
+		enable_irq(client->irq);
+
+	if (!ts->use_irq)
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	else
+		i2c_smbus_write_byte_data(ts->client, 0xf1, 0x01); /* enable abs int */
+
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void synaptics_ts_early_suspend(struct early_suspend *h)
+{
+	struct synaptics_ts_data *ts;
+	ts = container_of(h, struct synaptics_ts_data, early_suspend);
+	synaptics_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+static void synaptics_ts_late_resume(struct early_suspend *h)
+{
+	struct synaptics_ts_data *ts;
+	ts = container_of(h, struct synaptics_ts_data, early_suspend);
+	synaptics_ts_resume(ts->client);
+}
+#endif
+
+static const struct i2c_device_id synaptics_ts_id[] = {
+	{ SYNAPTICS_I2C_RMI_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver synaptics_ts_driver = {
+	.probe		= synaptics_ts_probe,
+	.remove		= synaptics_ts_remove,
+#ifndef CONFIG_HAS_EARLYSUSPEND
+	.suspend	= synaptics_ts_suspend,
+	.resume		= synaptics_ts_resume,
+#endif
+	.id_table	= synaptics_ts_id,
+	.driver = {
+		.name	= SYNAPTICS_I2C_RMI_NAME,
+	},
+};
+
+static int __devinit synaptics_ts_init(void)
+{
+	synaptics_wq = create_singlethread_workqueue("synaptics_wq");
+	if (!synaptics_wq)
+		return -ENOMEM;
+	return i2c_add_driver(&synaptics_ts_driver);
+}
+
+static void __exit synaptics_ts_exit(void)
+{
+	i2c_del_driver(&synaptics_ts_driver);
+	if (synaptics_wq)
+		destroy_workqueue(synaptics_wq);
+}
+
+module_init(synaptics_ts_init);
+module_exit(synaptics_ts_exit);
+
+MODULE_DESCRIPTION("Synaptics Touchscreen Driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/drivers/input/touchscreen/zephyr2.c iDroid-Project-kernel_common-9e90fd2/drivers/input/touchscreen/zephyr2.c
--- linux-2.6.32-orig/drivers/input/touchscreen/zephyr2.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/input/touchscreen/zephyr2.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,1364 @@
+/*
+ * zephyr2.c - Zephyr2 Touchscreen driver, used in iPhone.
+ *
+ * Authors: Yidou Wang, Patrick Wildt, Ricky Taylor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/firmware.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <mach/iphone-spi.h>
+#include <mach/gpio.h>
+
+#ifdef CONFIG_IPHONE_2G
+#	define MT_GPIO_POWER 0x804
+#	define MT_ATN_INTERRUPT 0xa3
+#else
+#	define MT_GPIO_POWER 0x701
+#	define MT_ATN_INTERRUPT 0x9b
+#endif
+
+#ifdef CONFIG_IPHONE_3G
+#	define MT_SPI 1
+#	define MT_SPI_CS GPIO_SPI1_CS0
+#else
+#	define MT_SPI 2
+#	define MT_SPI_CS GPIO_SPI2_CS0
+#endif
+
+#define MT_INFO_FAMILYID 0xD1
+#define MT_INFO_SENSORINFO 0xD3
+#define MT_INFO_SENSORREGIONDESC 0xD0
+#define MT_INFO_SENSORREGIONPARAM 0xA1
+#define MT_INFO_SENSORDIM 0xD9
+
+#define MAX_FINGER_ORIENTATION  16384
+#define MAX_BUFFER_SIZE 0x400
+
+#define NORMAL_SPEED (&MTNormalSpeed)
+#define FAST_SPEED (&MTFastSpeed)
+
+typedef struct MTFrameHeader
+{
+	u8 type;
+	u8 frameNum;
+	u8 headerLen;
+	u8 unk_3;
+	u32 timestamp;
+	u8 unk_8;
+	u8 unk_9;
+	u8 unk_A;
+	u8 unk_B;
+	u16 unk_C;
+	u16 isImage;
+
+	u8 numFingers;
+	u8 fingerDataLen;
+	u16 unk_12;
+	u16 unk_14;
+	u16 unk_16;
+} MTFrameHeader;
+
+typedef struct FingerData
+{
+	u8 id;
+	u8 event;
+	u8 unk_2;
+	u8 unk_3;
+	s16 x;
+	s16 y;
+	s16 rel_x;
+	s16 rel_y;
+	u16 size_major;
+	u16 size_minor;
+	u16 orientation;
+	u16 force_major;
+	u16 force_minor;
+	u16 unk_16;
+	u16 unk_18;
+	u16 unk_1A;
+} FingerData;
+
+typedef struct MTSPISetting
+{
+	int speed;
+	int txDelay;
+	int rxDelay;
+} MTSPISetting;
+
+const MTSPISetting MTNormalSpeed = {83000, 5, 10};
+const MTSPISetting MTFastSpeed = {4500000, 0, 5};
+
+static u8* OutputPacket;
+static u8* InputPacket;
+static u8* GetInfoPacket;
+static u8* GetResultPacket;
+
+static int InterfaceVersion;
+static int MaxPacketSize;
+static int FamilyID;
+static int FlipNOP;
+static int SensorWidth;
+static int SensorHeight;
+static int SensorColumns;
+static int SensorRows;
+static int BCDVersion;
+static int Endianness;
+static u8* SensorRegionDescriptor;
+static int SensorRegionDescriptorLen;
+static u8* SensorRegionParam;
+static int SensorRegionParamLen;
+
+static u8 SensorMinPressure = 100;
+
+static int CurNOP;
+
+static bool FirmwareLoaded = false;
+static int z2_atn_count = 0;
+
+static struct device* multitouch_dev = NULL;
+static struct input_dev* input_dev;
+
+static u8* constructed_fw;
+static size_t constructed_fw_size;
+static u8 proxcal_fw[512];
+static size_t proxcal_fw_size;
+static u8 cal_fw[512];
+static size_t cal_fw_size;
+
+static int makeBootloaderDataPacket(u8* output, u32 destAddress, const u8* data, int dataLen, int* cksumOut);
+static void sendExecutePacket(void);
+
+static bool loadConstructedFirmware(const u8* firmware, int len);
+static int loadProxCal(const u8* firmware, int len);
+static int loadCal(const u8* firmware, int len);
+static bool determineInterfaceVersion(void);
+
+static bool getReportInfo(int id, u8* err, u16* len);
+static bool getReport(int id, u8* buffer, int* outLen);
+
+static void newPacket(const u8* data, int len);
+
+static u32 z2_getU32(u8 *_buf)
+{
+	return (_buf[2] << 24)
+		| (_buf[3] << 16)
+		| (_buf[0] << 8)
+		| _buf[1];
+}
+
+static void z2_makeU32(u8 *_buf, u32 _val)
+{
+	_buf[2] = _val >> 24;
+	_buf[3] = (_val >> 16) & 0xFF;
+	_buf[0] = (_val >> 8) & 0xFF;
+	_buf[1] = _val & 0xFF;
+}
+static u16 z2_getU16(u8 *_buf)
+{
+	return (_buf[0] << 8)
+		| _buf[1];
+}
+
+static void z2_makeU16(u8 *_buf, u16 _val)
+{
+	_buf[0] = _val >> 8;
+	_buf[1] = _val & 0xFF;
+}
+
+static u16 z2_getU16R(u8 *_buf)
+{
+	return (_buf[1] << 8)
+		| _buf[0];
+}
+
+static void z2_makeU16R(u8 *_buf, u16 _val)
+{
+	_buf[1] = _val >> 8;
+	_buf[0] = _val & 0xFF;
+}
+
+static u32 z2_u32Sum(u8 *_buf, u32 _len)
+{
+	u32 i;
+	u32 checksum = 0;
+
+	for(i = 0; i < _len; i++)
+	{
+		checksum += _buf[i];
+	}
+
+	return checksum;
+}
+
+static u16 z2_u16Sum(u8 *_buf, u32 _len)
+{
+	u32 i;
+	u16 checksum = 0;
+
+	for(i = 0; i < _len; i++)
+	{
+		checksum += _buf[i];
+	}
+
+	return checksum;
+}
+
+static u16 z2_makeU16Sum(u8 *_buf, u32 _len)
+{
+	u16 chk = z2_u16Sum(_buf, _len);
+	z2_makeU16(_buf+_len, chk);
+	return chk;
+}
+
+static u16 z2_makeU16SumR(u8 *_buf, u32 _len)
+{
+	u16 chk = z2_u16Sum(_buf, _len);
+	z2_makeU16R(_buf+_len, chk);
+	return chk;
+}
+
+static u32 z2_makeU32Sum(u8 *_buf, u32 _len)
+{
+	u32 chk = z2_u32Sum(_buf, _len);
+	z2_makeU32(_buf+_len, chk);
+	return chk;
+}
+
+int z2_tx(const MTSPISetting* setting, const u8* outBuffer, int outLen)
+{
+	int ret;
+	iphone_spi_set_baud(MT_SPI, setting->speed, SPIOption13Setting0, 1, 1, 1);
+	iphone_gpio_pin_output(MT_SPI_CS, 0);
+	msleep(setting->txDelay);
+	ret = iphone_spi_tx(MT_SPI, outBuffer, outLen, true, false);
+	iphone_gpio_pin_output(MT_SPI_CS, 1);
+	return ret;
+}
+
+int z2_txrx(const MTSPISetting* setting, const u8* outBuffer, int outLen, u8* inBuffer, int inLen)
+{
+	int ret;
+	iphone_spi_set_baud(MT_SPI, setting->speed, SPIOption13Setting0, 1, 1, 1);
+	iphone_gpio_pin_output(MT_SPI_CS, 0);
+	msleep(setting->rxDelay);
+	ret = iphone_spi_txrx(MT_SPI, outBuffer, outLen, inBuffer, inLen, true);
+	iphone_gpio_pin_output(MT_SPI_CS, 1);
+	return ret;
+}
+
+static u16 z2_shortAck(void)
+{
+	u8 tx[2];
+	u8 rx[2];
+
+	z2_makeU16(tx, 0x1aa1);
+
+	z2_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+	return z2_getU16(rx);
+}
+
+static u32 z2_longAck(void)
+{
+	u8 tx[8];
+	u8 rx[8];
+
+	z2_makeU16(tx, 0x1aa1);
+
+	z2_makeU16(tx+2, 0x18e1);
+	z2_makeU16(tx+4, 0x18e1);
+	z2_makeU16(tx+6, 0x18e1);
+
+	z2_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+	return z2_getU32(rx+2);
+}
+
+static u32 readRegister(u32 address)
+{
+	u8 tx[8];
+	u8 rx[8];
+
+	z2_makeU16(tx, 0x1c73);
+	z2_makeU32(tx+2, address);
+	z2_makeU16Sum(tx+2, 4);
+
+	z2_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+	return z2_longAck();
+}
+
+static u32 writeRegister(u32 address, u32 value, u32 mask)
+{
+	u8 tx[16];
+	u8 rx[16];
+
+	z2_makeU16(tx, 0x1e33);
+	z2_makeU32(tx+2, address);
+	z2_makeU32(tx+6, mask);
+	z2_makeU32(tx+10, value);
+	z2_makeU16Sum(tx+2, sizeof(u32)*3);
+
+	z2_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+	return z2_shortAck() == 0x4AD1;
+}
+
+
+static void newPacket(const u8* data, int len)
+{
+	int i;
+	FingerData* finger;
+	MTFrameHeader* header = (MTFrameHeader*) data;
+	if(header->type != 0x44 && header->type != 0x43)
+		printk("zephyr2: unknown frame type 0x%x\n", header->type);
+
+	finger = (FingerData*)(data + (header->headerLen));
+
+	if(header->headerLen < 12)
+		printk("zephyr2: no finger data in frame\n");
+
+	for(i = 0; i < header->numFingers; ++i)
+	{
+		if(finger->force_major > SensorMinPressure)
+		{
+			finger->force_major -= SensorMinPressure;
+		}
+		else
+			finger->force_major = 0;
+
+		if(finger->force_minor > SensorMinPressure)
+		{
+			finger->force_minor -= SensorMinPressure;
+		}
+		else 
+			finger->force_minor = 0;
+
+		if(finger->force_major > 0 &&
+				finger->force_minor > 0)
+		{
+			input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, finger->force_major);
+			input_report_abs(input_dev, ABS_MT_TOUCH_MINOR, finger->force_minor);
+			input_report_abs(input_dev, ABS_MT_WIDTH_MAJOR, finger->size_major);
+			input_report_abs(input_dev, ABS_MT_WIDTH_MINOR, finger->size_minor);
+			input_report_abs(input_dev, ABS_MT_ORIENTATION, MAX_FINGER_ORIENTATION - finger->orientation);
+			input_report_abs(input_dev, ABS_MT_TRACKING_ID, finger->id);
+			input_report_abs(input_dev, ABS_MT_POSITION_X, finger->x);
+			input_report_abs(input_dev, ABS_MT_POSITION_Y, SensorHeight - finger->y);
+		}
+
+		input_mt_sync(input_dev);
+
+		finger = (FingerData*) (((u8*) finger) + header->fingerDataLen);
+	}
+
+	if(header->numFingers > 0)
+	{
+		finger = (FingerData*)(data + (header->headerLen));
+
+		if (finger->force_minor > 0) {
+			input_report_abs(input_dev, ABS_X, finger->x);
+			input_report_abs(input_dev, ABS_Y, SensorHeight - finger->y);
+			input_report_key(input_dev, BTN_TOUCH, finger->size_minor > 0);
+		}
+		else input_report_key(input_dev, BTN_TOUCH, 0);
+	}
+
+	input_sync(input_dev);
+
+}
+
+static bool readResultData(int len)
+{
+	u32 checksum;
+	int i;
+	int packetLen;
+
+	if(len > MAX_BUFFER_SIZE)
+	{
+		printk("zephyr2: Result too big for buffer! We have %d bytes, we need %d bytes!\n", MAX_BUFFER_SIZE, len);
+		len = MAX_BUFFER_SIZE;
+	}
+
+	memset(GetResultPacket, 0, MAX_BUFFER_SIZE);
+
+	if(FlipNOP)
+		GetResultPacket[0] = 0xEB;
+	else
+		GetResultPacket[0] = 0xEA;
+
+	GetResultPacket[1] = CurNOP;
+	GetResultPacket[2] = 1;
+
+	checksum = 0;
+	for(i = 0; i < 14; ++i)
+		checksum += GetResultPacket[i];
+
+	GetResultPacket[len - 2] = checksum & 0xFF;
+	GetResultPacket[len - 1] = (checksum >> 8) & 0xFF;
+
+	z2_txrx(NORMAL_SPEED, GetResultPacket, len, InputPacket, len);
+
+	if(InputPacket[0] != 0xEA && !(FlipNOP && InputPacket[0] == 0xEB))
+	{
+		printk("zephyr2: frame header wrong: got 0x%02X\n", InputPacket[0]);
+		msleep(1);
+		return false;
+	}
+
+	checksum = 0;
+	for(i = 0; i < 5; ++i)
+		checksum += InputPacket[i];
+
+	if((checksum & 0xFF) != 0)
+	{
+		printk("zephyr2: LSB of first five bytes of frame not zero: got 0x%02X\n", checksum);
+		msleep(1);
+		return false;
+	}
+
+	packetLen = (InputPacket[2] & 0xFF) | ((InputPacket[3] & 0xFF) << 8);
+
+	if(packetLen <= 2)
+		return true;
+
+	checksum = 0;
+	for(i = 5; i < (5 + packetLen - 2); ++i)
+		checksum += InputPacket[i];
+	if((InputPacket[len - 2] | (InputPacket[len - 1] << 8)) != checksum)
+	{
+		printk("zephyr2: packet checksum wrong 0x%02X instead of 0x%02X\n", checksum, (InputPacket[len - 2] | (InputPacket[len - 1] << 8)));
+		msleep(1);
+		return false;
+	}
+
+	newPacket(InputPacket + 5, packetLen - 2);
+	return true;
+}
+
+static bool z2_readFrameLength(int* len)
+{
+	u8 tx[16];
+	u8 rx[16];
+	u32 checksum;
+
+	memset(tx, 0, sizeof(tx));
+
+	if(FlipNOP)
+		tx[0] = 0xEB;
+	else
+		tx[0] = 0xEA;
+
+	tx[1] = CurNOP;
+	tx[2] = 0;
+
+	z2_makeU16SumR(tx, 14);
+
+	z2_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+	checksum = z2_u16Sum(rx, 14);
+	if((rx[14] | (rx[15] << 8)) != checksum)
+	{
+		udelay(1000);
+		return false;
+	}
+
+	*len = (rx[1] & 0xFF) | ((rx[2] & 0xFF) << 8);
+
+	return true;
+}
+
+static int z2_readFrame(void)
+{
+	int ret = 0;
+	int len = 0;
+
+	if(!z2_readFrameLength(&len))
+	{
+		printk("zephyr2: error getting frame length\r\n");
+		len = 0;
+		ret = -1;
+	}
+
+	if(len)
+	{
+		if(!readResultData(len + 5))
+		{
+			printk("zephyr2: error getting frame data\r\n");
+			msleep(1);
+			ret = -1;
+		}
+
+		ret = 1;
+	}
+
+	if(FlipNOP)
+	{
+		if(CurNOP == 1)
+			CurNOP = 2;
+		else
+			CurNOP = 1;
+	}
+
+	return ret;
+}
+
+
+static int shortControlRead(int id, u8* buffer, int size)
+{
+	u32 checksum;
+	int i;
+
+	memset(GetInfoPacket, 0, MAX_BUFFER_SIZE);
+	GetInfoPacket[0] = 0xE6;
+	GetInfoPacket[1] = id;
+	GetInfoPacket[2] = 0;
+	GetInfoPacket[3] = size & 0xFF;
+	GetInfoPacket[4] = (size >> 8) & 0xFF;
+
+	checksum = 0;
+	for(i = 0; i < 5; ++i)
+		checksum += GetInfoPacket[i];
+
+	GetInfoPacket[14] = checksum & 0xFF;
+	GetInfoPacket[15] = (checksum >> 8) & 0xFF;
+
+	z2_txrx(NORMAL_SPEED, GetInfoPacket, 16, InputPacket, 16);
+
+	udelay(25);
+
+	GetInfoPacket[2] = 1;
+
+	z2_txrx(NORMAL_SPEED, GetInfoPacket, 16, InputPacket, 16);
+
+	checksum = 0;
+	for(i = 0; i < 14; ++i)
+		checksum += InputPacket[i];
+
+	if((InputPacket[14] | (InputPacket[15] << 8)) != checksum)
+		return false;
+
+	memcpy(buffer, &InputPacket[3], size);
+
+	return true;
+}
+
+static int longControlRead(int id, u8* buffer, int size)
+{
+	u32 checksum;
+	int i;
+
+	memset(GetInfoPacket, 0, 0x200);
+	GetInfoPacket[0] = 0xE7;
+	GetInfoPacket[1] = id;
+	GetInfoPacket[2] = 0;
+	GetInfoPacket[3] = size & 0xFF;
+	GetInfoPacket[4] = (size >> 8) & 0xFF;
+
+	checksum = 0;
+	for(i = 0; i < 5; ++i)
+		checksum += GetInfoPacket[i];
+
+	GetInfoPacket[14] = checksum & 0xFF;
+	GetInfoPacket[15] = (checksum >> 8) & 0xFF;
+
+	z2_txrx(NORMAL_SPEED, GetInfoPacket, 16, InputPacket, 16);
+
+	GetInfoPacket[2] = 1;
+	GetInfoPacket[14] = 0;
+	GetInfoPacket[15] = 0;
+	GetInfoPacket[3 + size] = checksum & 0xFF;
+	GetInfoPacket[3 + size + 1] = (checksum >> 8) & 0xFF;
+
+	z2_txrx(NORMAL_SPEED, GetInfoPacket, size + 5, InputPacket, size + 5);
+
+	checksum = 0;
+	for(i = 0; i < (size + 3); ++i)
+		checksum += InputPacket[i];
+
+	if((InputPacket[3 + size] | (InputPacket[3 + size + 1] << 8)) != checksum)
+		return false;
+
+	memcpy(buffer, &InputPacket[3], size);
+
+	return true;
+}
+
+static bool getReportInfo(int id, u8* err, u16* len)
+{
+	u8 tx[16];
+	u8 rx[16];
+	u32 checksum;
+	int i;
+	int try;
+
+	for(try = 0; try < 4; ++try)
+	{
+		memset(tx, 0, sizeof(tx));
+
+		tx[0] = 0xE3;
+		tx[1] = id;
+
+		checksum = 0;
+		for(i = 0; i < 14; ++i)
+			checksum += tx[i];
+
+		tx[14] = checksum & 0xFF;
+		tx[15] = (checksum >> 8) & 0xFF;
+
+		z2_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+		if(rx[0] != 0xE3)
+			continue;
+
+		checksum = 0;
+		for(i = 0; i < 14; ++i)
+			checksum += rx[i];
+
+		if((rx[14] | (rx[15] << 8)) != checksum)
+			continue;
+
+		*err = rx[2];
+		*len = (rx[4] << 8) | rx[3];
+
+		return true;
+	}
+
+	return false;
+}
+
+static bool getReport(int id, u8* buffer, int* outLen)
+{
+	u8 err;
+	u16 len;
+	int try;
+
+	if(!getReportInfo(id, &err, &len))
+		return false;
+
+	if(err)
+		return false;
+
+	*outLen = len;
+
+	for(try = 0; try < 4; ++try)
+	{
+		if(len < 12)
+		{
+			if(shortControlRead(id, buffer, len))
+				return true;
+		} else
+		{
+			if(longControlRead(id, buffer, len))
+				return true;
+		}
+	}
+
+	return false;
+}
+
+static bool determineInterfaceVersion(void)
+{
+	u8 tx[16];
+	u8 rx[16];
+	u32 checksum;
+	int i;
+	int try;
+
+	memset(tx, 0, sizeof(tx));
+
+	tx[0] = 0xE2;
+
+	checksum = 0;
+	for(i = 0; i < 14; ++i)
+		checksum += tx[i];
+
+	// Note that the byte order changes to little-endian after main firmware load
+
+	tx[14] = checksum & 0xFF;
+	tx[15] = (checksum >> 8) & 0xFF;
+
+	for(try = 0; try < 4; ++try)
+	{
+		z2_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+		if(rx[0] == 0xE2)
+		{
+			checksum = 0;
+			for(i = 0; i < 14; ++i)
+				checksum += rx[i];
+
+			if((rx[14] | (rx[15] << 8)) == checksum)
+			{
+				InterfaceVersion = rx[2];
+				MaxPacketSize = (rx[4] << 8) | rx[3];
+				printk("zephyr2: interface version %d, max packet size: %d\n", InterfaceVersion, MaxPacketSize);
+
+				return true;
+			}
+		}
+
+		InterfaceVersion = 0;
+		MaxPacketSize = 1000;
+		msleep(3);
+	}
+
+	printk("zephyr2: failed getting interface version!\n");
+
+	return false;
+}
+
+static bool loadConstructedFirmware(const u8* firmware, int len)
+{
+	int try;
+
+	for(try = 0; try < 5; ++try)
+	{
+
+		printk("zephyr2: uploading firmware\n");
+
+		z2_tx(FAST_SPEED, firmware, len);
+
+		udelay(300);
+
+		if(z2_shortAck() == 0x4BC1)
+			return true;
+
+	}
+
+	return false;
+}
+
+static int loadProxCal(const u8* firmware, int len)
+{
+	u32 address = 0x400180;
+	const u8* data = firmware;
+	int left = (len + 3) & ~0x3;
+	int try;
+
+	while(left > 0)
+	{
+		int toUpload = left;
+		if(toUpload > (MAX_BUFFER_SIZE - 0x10))
+		{
+			printk("zephyr2: prox-cal too big for buffer.\n");
+			toUpload = MAX_BUFFER_SIZE - 0x10;
+		}
+
+		OutputPacket[0] = 0x18;
+		OutputPacket[1] = 0xE1;
+
+		makeBootloaderDataPacket(OutputPacket + 2, address, data, toUpload, NULL);
+
+		for(try = 0; try < 5; ++try)
+		{
+			printk("zephyr2: uploading prox calibration data packet\r\n");
+
+			z2_tx(FAST_SPEED, OutputPacket, toUpload + 0x10);
+			udelay(300);
+
+			if(z2_shortAck() == 0x4BC1)
+				break;
+		}
+
+		if(try == 5)
+			return false;
+
+		address += toUpload;
+		data += toUpload;
+		left -= toUpload;
+	}
+
+	return true;
+}
+
+static int loadCal(const u8* firmware, int len)
+{
+	u32 address = 0x400200;
+	const u8* data = firmware;
+	int left = (len + 3) & ~0x3;
+	int try;
+
+	while(left > 0)
+	{
+		int toUpload = left;
+		if(toUpload > 0x3F0)
+			toUpload = 0x3F0;
+
+		OutputPacket[0] = 0x18;
+		OutputPacket[1] = 0xE1;
+
+		makeBootloaderDataPacket(OutputPacket + 2, address, data, toUpload, NULL);
+
+		for(try = 0; try < 5; ++try)
+		{
+			printk("zephyr2: uploading calibration data packet\r\n");
+
+			z2_tx(FAST_SPEED, OutputPacket, toUpload + 0x10);
+			udelay(300);
+
+			if(z2_shortAck() == 0x4BC1)
+				break;
+		}
+
+		if(try == 5)
+			return false;
+
+		address += toUpload;
+		data += toUpload;
+		left -= toUpload;
+	}
+
+	return true;
+}
+
+static u32 z2_getCalibration(void)
+{
+	u8 tx[2];
+	u8 rx[2];
+
+	tx[0] = 0x1F;
+	tx[1] = 0x01;
+
+	printk("zephyr2: requesting calibration...\n");
+
+	z2_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+	msleep(65);
+
+	return z2_longAck();
+}
+
+static int z2_calibrate(void)
+{
+	u32 z2_version;
+
+	z2_version = readRegister(0x10008FFC);
+
+	printk("zephyr2: detected Zephyr2 version 0x%0X\n", z2_version);
+
+	if(z2_version != 0x5A020028 && z2_version != 0x5A02002A) // TODO: What the hell causes this to crash? ;_;
+	{
+#define init_register(addr, a, b) if(!writeRegister(addr, (a), (b))) { \
+	printk("zephyr2: error initialising register " #addr "\n"); return false; }
+
+		printk("zephyr2: Initialising Registers...\n");
+		// -- BEGIN INITIALISING REGISTERS -- //
+
+		init_register(0x10001C04, 0x16E4, 0x1FFF);
+		init_register(0x10001C08, 0x840000, 0xFF0000);
+		init_register(0x1000300C, 0x05, 0x85);
+		init_register(0x1000304C, 0x20, 0xFFFFFFFF);
+
+		// --- END INITIALISING REGISTERS --- //
+		printk("zephyr2: Initialised Registers\n");
+
+#undef init_register
+	}
+
+	printk("zephyr2: calibration complete with 0x%x\n", z2_getCalibration());
+
+	return true;
+}
+
+static void sendExecutePacket(void)
+{
+	u8 tx[12];
+	u8 rx[12];
+
+	tx[0] = 0x1D;
+	tx[1] = 0x53;
+
+	tx[2] = 0x18;
+	tx[3] = 0x00;
+	tx[4] = 0x10;
+	tx[5] = 0x00;
+	tx[6] = 0x00;
+	tx[7] = 0x01;
+	tx[8] = 0x00;
+	tx[9] = 0x00;
+
+	z2_makeU16Sum(tx+2, 8);
+	z2_txrx(NORMAL_SPEED, tx, sizeof(tx), rx, sizeof(rx));
+
+	printk("zephyr2: execute packet sent\r\n");
+}
+
+static int makeBootloaderDataPacket(u8* output, u32 destAddress, const u8* data, int dataLen, int* cksumOut)
+{
+	u32 checksum;
+	int i;
+
+	// This seems to be middle-endian! I've never seen this before.
+
+	output[0] = 0x30;
+	output[1] = 0x01;
+	z2_makeU16(output+2, dataLen >> 2);
+	z2_makeU32(output+4, destAddress);
+	z2_makeU16Sum(output+2, 6);
+
+	for(i = 0; i < dataLen; i += 4)
+	{
+		output[10 + i + 0] = data[i + 1];
+		output[10 + i + 1] = data[i + 0];
+		output[10 + i + 2] = data[i + 3];
+		output[10 + i + 3] = data[i + 2];
+	}
+
+	checksum = z2_makeU32Sum(output+10, dataLen);
+
+	if(cksumOut)
+		*cksumOut = checksum;
+
+	return dataLen;
+}
+
+static spinlock_t z2_atn_count_lock;
+
+static void z2_atn_handler(struct work_struct* work)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&z2_atn_count_lock, flags);
+	while(z2_atn_count > 0)
+	{
+		--z2_atn_count;
+		spin_unlock_irqrestore(&z2_atn_count_lock, flags);
+		z2_readFrame();
+		spin_lock_irqsave(&z2_atn_count_lock, flags);
+	}
+	spin_unlock_irqrestore(&z2_atn_count_lock, flags);
+}
+DECLARE_WORK(z2_queue, &z2_atn_handler);
+
+static irqreturn_t z2_irq(int irq, void* pToken)
+{
+	unsigned long flags;
+
+	if(!FirmwareLoaded)
+		return IRQ_HANDLED;
+
+	spin_lock_irqsave(&z2_atn_count_lock, flags);
+	++z2_atn_count;
+	spin_unlock_irqrestore(&z2_atn_count_lock, flags);
+
+	schedule_work(&z2_queue);
+
+	return IRQ_HANDLED;
+}
+
+int z2_setup(const u8* constructedFirmware, int constructedFirmwareLen, const u8* prox_cal, int prox_cal_size, const u8* cal, int cal_size)
+{
+	int i;
+	int ret;
+	int err;
+	u8* reportBuffer;
+	int reportLen;
+
+	spin_lock_init(&z2_atn_count_lock);
+
+	if(!prox_cal)
+	{
+		printk("zephyr2: could not find proximity calibration data\n");
+		return -1;
+	}
+
+	if(!cal)
+	{
+		printk("zephyr2: could not find calibration data\n");
+		return -1;
+	}
+
+	printk("zephyr2: Firmware at 0x%08x - 0x%08x\n",
+			(u32) constructedFirmware, (u32)(constructedFirmware + constructedFirmwareLen));
+
+	OutputPacket = (u8*) kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);
+	InputPacket = (u8*) kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);
+	GetInfoPacket = (u8*) kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);
+	GetResultPacket = (u8*) kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);
+
+	if(request_irq(MT_ATN_INTERRUPT + IPHONE_GPIO_IRQS, z2_irq, IRQF_TRIGGER_FALLING, "iphone-multitouch", (void*) 0))
+	{
+		printk("zephyr2: Failed to request z2 interrupt.\n");
+		return -1;
+	}
+
+	// Power up the device (turn it off then on again. ;])
+	printk("zephyr2: Powering Up Multitouch!\n");
+	iphone_gpio_pin_output(MT_GPIO_POWER, 0);
+	msleep(200);
+
+	iphone_gpio_pin_output(MT_GPIO_POWER, 1);
+	msleep(15);
+
+	for(i = 0; i < 4; ++i)
+	{
+		iphone_gpio_pin_output(0x606, 0);
+		msleep(200);
+		iphone_gpio_pin_output(0x606, 1);
+		msleep(15);
+
+		// Send Firmware
+		printk("zephyr2: Sending Firmware...\n");
+		if(loadConstructedFirmware(constructedFirmware, constructedFirmwareLen))
+		{
+			break;
+		}
+	}
+
+	if(i == 4)
+	{
+			printk("zephyr2: could not load preconstructed firmware\n");
+			err = -1;
+			kfree(InputPacket);
+			kfree(OutputPacket);
+			kfree(GetInfoPacket);
+			kfree(GetResultPacket);
+			return err;
+	}
+
+	printk("zephyr2: loaded %d byte preconstructed firmware\n", constructedFirmwareLen);
+
+#ifndef CONFIG_IPODTOUCH_1G
+	if(!loadProxCal(prox_cal, prox_cal_size))
+	{
+		printk("zephyr2: could not load proximity calibration data\n");
+		err = -1;
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return err;
+	}
+
+	printk("zephyr2: loaded %d byte proximity calibration data\n", prox_cal_size);
+#endif
+
+	if(!loadCal(cal, cal_size))
+	{
+		printk("zephyr2: could not load calibration data\n");
+		err = -1;
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return err;
+	}
+
+
+	printk("zephyr2: loaded %d byte calibration data\n", cal_size);
+
+	if(!z2_calibrate())
+	{
+		err = -1;
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return err;
+	}
+
+	sendExecutePacket();
+
+	msleep(1);
+
+	printk("zephyr2: Determining interface version...\n");
+	if(!determineInterfaceVersion())
+	{
+		err = -1;
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return err;
+	}
+
+	reportBuffer = (u8*) kmalloc(MaxPacketSize, GFP_KERNEL);
+
+	if(!getReport(MT_INFO_FAMILYID, reportBuffer, &reportLen))
+	{
+		printk("zephyr2: failed getting family id!\n");
+		err = -1;
+		kfree(reportBuffer);
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return err;
+	}
+
+	FamilyID = reportBuffer[0];
+
+	if(!getReport(MT_INFO_SENSORINFO, reportBuffer, &reportLen))
+	{
+		printk("zephyr2: failed getting sensor info!\r\n");
+		err = -1;
+		kfree(reportBuffer);
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return err;
+	}
+
+	SensorColumns = reportBuffer[2];
+	SensorRows = reportBuffer[1];
+	BCDVersion = ((reportBuffer[3] & 0xFF) << 8) | (reportBuffer[4] & 0xFF);
+	Endianness = reportBuffer[0];
+
+
+	if(!getReport(MT_INFO_SENSORREGIONDESC, reportBuffer, &reportLen))
+	{
+		printk("zephyr2: failed getting sensor region descriptor!\r\n");
+		err = -1;
+		kfree(reportBuffer);
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return err;
+	}
+
+
+	SensorRegionDescriptorLen = reportLen;
+	SensorRegionDescriptor = (u8*) kmalloc(reportLen, GFP_KERNEL);
+	memcpy(SensorRegionDescriptor, reportBuffer, reportLen);
+
+	if(!getReport(MT_INFO_SENSORREGIONPARAM, reportBuffer, &reportLen))
+	{
+		printk("zephyr2: failed getting sensor region param!\r\n");
+		err = -1;
+		kfree(SensorRegionDescriptor);
+		kfree(reportBuffer);
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return err;
+	}
+
+
+	SensorRegionParamLen = reportLen;
+	SensorRegionParam = (u8*) kmalloc(reportLen, GFP_KERNEL);
+	memcpy(SensorRegionParam, reportBuffer, reportLen);
+
+	if(!getReport(MT_INFO_SENSORDIM, reportBuffer, &reportLen))
+	{
+		printk("zephyr2: failed getting sensor surface dimensions!\r\n");
+		err = -1;
+		kfree(SensorRegionParam);
+		kfree(SensorRegionDescriptor);
+		kfree(reportBuffer);
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return err;
+	}
+
+
+	SensorWidth = (9000 - *((u32*)&reportBuffer[0])) * 84 / 73;
+	SensorHeight = (13850 - *((u32*)&reportBuffer[4])) * 84 / 73;
+
+	printk("Family ID                : 0x%x\n", FamilyID);
+	printk("Sensor rows              : 0x%x\n", SensorRows);
+	printk("Sensor columns           : 0x%x\n", SensorColumns);
+	printk("Sensor width             : 0x%x\n", SensorWidth);
+	printk("Sensor height            : 0x%x\n", SensorHeight);
+	printk("BCD Version              : 0x%x\n", BCDVersion);
+	printk("Endianness               : 0x%x\n", Endianness);
+	printk("Sensor region descriptor :");
+
+	for(i = 0; i < SensorRegionDescriptorLen; ++i)
+		printk(" %02x", SensorRegionDescriptor[i]);
+	printk("\n");
+
+	printk("Sensor region param      :");
+	for(i = 0; i < SensorRegionParamLen; ++i)
+		printk(" %02x", SensorRegionParam[i]);
+	printk("\n");
+
+	if(BCDVersion > 0x23)
+		FlipNOP = true;
+	else
+		FlipNOP = false;
+
+	kfree(reportBuffer);
+
+
+	input_dev = input_allocate_device();
+	if(!input_dev)
+	{
+		err = -1;
+		kfree(SensorRegionParam);
+		kfree(SensorRegionDescriptor);
+		kfree(reportBuffer);
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return err;
+	}
+
+	input_dev->name = "iPhone Zephyr 2 Multitouch Screen";
+	input_dev->phys = "multitouch0";
+	input_dev->id.vendor = 0x05AC;
+	input_dev->id.product = 0;
+	input_dev->id.version = 0x0000;
+	input_dev->dev.parent = multitouch_dev;
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	input_set_abs_params(input_dev, ABS_X, 0, SensorWidth, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, SensorHeight, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, max(SensorHeight, SensorWidth), 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0, max(SensorHeight, SensorWidth), 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, max(SensorHeight, SensorWidth), 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, max(SensorHeight, SensorWidth), 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_ORIENTATION, -MAX_FINGER_ORIENTATION, MAX_FINGER_ORIENTATION, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, SensorWidth, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, SensorHeight, 0, 0);
+
+	/* not sure what the actual max is */
+	input_set_abs_params(input_dev, ABS_MT_TRACKING_ID, 0, 32, 0, 0);
+
+	ret = input_register_device(input_dev);
+	if(ret != 0)
+	{
+		err = -1;
+		kfree(SensorRegionParam);
+		kfree(SensorRegionDescriptor);
+		kfree(reportBuffer);
+		kfree(InputPacket);
+		kfree(OutputPacket);
+		kfree(GetInfoPacket);
+		kfree(GetResultPacket);
+		return err;
+	}
+
+	CurNOP = 1;
+
+	FirmwareLoaded = true;
+
+	z2_readFrame();
+
+	return 0;
+}
+
+static void got_constructed(const struct firmware* fw, void *context)
+{
+	if(!fw)
+	{
+		printk("zephyr2: couldn't get firmware, trying again...\n");
+		request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG, "zephyr2.bin", multitouch_dev, NULL, got_constructed);
+		return;
+	}
+
+	constructed_fw = kmalloc(fw->size, GFP_KERNEL);
+	constructed_fw_size = fw->size;
+	memcpy(constructed_fw, fw->data, fw->size);
+
+	z2_setup(constructed_fw, constructed_fw_size, proxcal_fw, proxcal_fw_size, cal_fw, cal_fw_size);
+
+	/* caller will call release_firmware */
+}
+
+static int iphone_multitouch_probe(struct platform_device *pdev)
+{
+	/* this driver is such a hack */
+	if(multitouch_dev)
+		return -EBUSY;
+
+	multitouch_dev = &pdev->dev;
+
+	printk("zephyr2: requesting Firmware\n");
+	return request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG, "zephyr2.bin", multitouch_dev, NULL, got_constructed);
+}
+
+static int iphone_multitouch_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver iphone_multitouch_driver = {
+	.probe = iphone_multitouch_probe,
+	.remove = iphone_multitouch_remove,
+	.suspend = NULL, /* optional but recommended */
+	.resume = NULL,   /* optional but recommended */
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "iphone-multitouch",
+	},
+};
+
+static struct platform_device iphone_multitouch_dev = {
+	.name = "iphone-multitouch",
+	.id = -1,
+};
+
+static int __init iphone_multitouch_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&iphone_multitouch_driver);
+
+	if (!ret) {
+		ret = platform_device_register(&iphone_multitouch_dev);
+
+		if (ret != 0) {
+			platform_driver_unregister(&iphone_multitouch_driver);
+		}
+	}
+	return ret;
+}
+
+static void __exit iphone_multitouch_exit(void)
+{
+	platform_device_unregister(&iphone_multitouch_dev);
+	platform_driver_unregister(&iphone_multitouch_driver);
+}
+
+module_init(iphone_multitouch_init);
+module_exit(iphone_multitouch_exit);
+
+#include <asm/setup.h>
+#define ATAG_IPHONE_PROX_CAL   0x54411004
+#define ATAG_IPHONE_MT_CAL     0x54411005
+
+struct atag_iphone_cal_data {
+	u32 size;
+	u8  data[];
+};
+
+static int __init parse_tag_prox_cal(const struct tag *tag)
+{
+	const struct atag_iphone_cal_data* cal_tag = (const struct atag_iphone_cal_data*)(((const u8*)tag) + sizeof(struct tag_header));
+
+	proxcal_fw_size = cal_tag->size;
+	memcpy(proxcal_fw, cal_tag->data, proxcal_fw_size);
+
+	return 0;
+}
+__tagtable(ATAG_IPHONE_PROX_CAL, parse_tag_prox_cal);
+
+static int __init parse_tag_mt_cal(const struct tag *tag)
+{
+	const struct atag_iphone_cal_data* cal_tag = (const struct atag_iphone_cal_data*)(((const u8*)tag) + sizeof(struct tag_header));
+
+	cal_fw_size = cal_tag->size;
+	memcpy(cal_fw, cal_tag->data, cal_fw_size);
+
+	return 0;
+}
+__tagtable(ATAG_IPHONE_MT_CAL, parse_tag_mt_cal);
+
+MODULE_DESCRIPTION("iPhone Zephyr 2 Multitouch Driver");
+MODULE_AUTHOR("Yiduo Wang");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/drivers/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/Kconfig
--- linux-2.6.32-orig/drivers/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -90,6 +90,8 @@
 
 source "drivers/leds/Kconfig"
 
+source "drivers/switch/Kconfig"
+
 source "drivers/accessibility/Kconfig"
 
 source "drivers/infiniband/Kconfig"
diff -Nur linux-2.6.32-orig/drivers/leds/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/leds/Kconfig
--- linux-2.6.32-orig/drivers/leds/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/leds/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -301,6 +301,12 @@
 	  This allows LEDs to be initialised in the ON state.
 	  If unsure, say Y.
 
+config LEDS_TRIGGER_SLEEP
+	tristate "LED Sleep Mode Trigger"
+	depends on LEDS_TRIGGERS && HAS_EARLYSUSPEND
+	help
+	  This turns LEDs on when the screen is off but the cpu still running.
+
 comment "iptables trigger is under Netfilter config (LED target)"
 	depends on LEDS_TRIGGERS
 
diff -Nur linux-2.6.32-orig/drivers/leds/ledtrig-sleep.c iDroid-Project-kernel_common-9e90fd2/drivers/leds/ledtrig-sleep.c
--- linux-2.6.32-orig/drivers/leds/ledtrig-sleep.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/leds/ledtrig-sleep.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,80 @@
+/* drivers/leds/ledtrig-sleep.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/earlysuspend.h>
+#include <linux/leds.h>
+#include <linux/suspend.h>
+
+static int ledtrig_sleep_pm_callback(struct notifier_block *nfb,
+					unsigned long action,
+					void *ignored);
+
+DEFINE_LED_TRIGGER(ledtrig_sleep)
+static struct notifier_block ledtrig_sleep_pm_notifier = {
+	.notifier_call = ledtrig_sleep_pm_callback,
+	.priority = 0,
+};
+
+static void ledtrig_sleep_early_suspend(struct early_suspend *h)
+{
+	led_trigger_event(ledtrig_sleep, LED_FULL);
+}
+
+static void ledtrig_sleep_early_resume(struct early_suspend *h)
+{
+	led_trigger_event(ledtrig_sleep, LED_OFF);
+}
+
+static struct early_suspend ledtrig_sleep_early_suspend_handler = {
+	.suspend = ledtrig_sleep_early_suspend,
+	.resume = ledtrig_sleep_early_resume,
+};
+
+static int ledtrig_sleep_pm_callback(struct notifier_block *nfb,
+					unsigned long action,
+					void *ignored)
+{
+	switch (action) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		led_trigger_event(ledtrig_sleep, LED_OFF);
+		return NOTIFY_OK;
+	case PM_POST_HIBERNATION:
+	case PM_POST_SUSPEND:
+		led_trigger_event(ledtrig_sleep, LED_FULL);
+		return NOTIFY_OK;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int __init ledtrig_sleep_init(void)
+{
+	led_trigger_register_simple("sleep", &ledtrig_sleep);
+	register_pm_notifier(&ledtrig_sleep_pm_notifier);
+	register_early_suspend(&ledtrig_sleep_early_suspend_handler);
+	return 0;
+}
+
+static void __exit ledtrig_sleep_exit(void)
+{
+	unregister_early_suspend(&ledtrig_sleep_early_suspend_handler);
+	unregister_pm_notifier(&ledtrig_sleep_pm_notifier);
+	led_trigger_unregister_simple(ledtrig_sleep);
+}
+
+module_init(ledtrig_sleep_init);
+module_exit(ledtrig_sleep_exit);
+
diff -Nur linux-2.6.32-orig/drivers/leds/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/leds/Makefile
--- linux-2.6.32-orig/drivers/leds/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/leds/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -40,3 +40,4 @@
 obj-$(CONFIG_LEDS_TRIGGER_BACKLIGHT)	+= ledtrig-backlight.o
 obj-$(CONFIG_LEDS_TRIGGER_GPIO)		+= ledtrig-gpio.o
 obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON)	+= ledtrig-default-on.o
+obj-$(CONFIG_LEDS_TRIGGER_SLEEP)	+= ledtrig-sleep.o
diff -Nur linux-2.6.32-orig/drivers/lguest/segments.c iDroid-Project-kernel_common-9e90fd2/drivers/lguest/segments.c
--- linux-2.6.32-orig/drivers/lguest/segments.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/lguest/segments.c	2010-11-18 21:05:30.000000000 +0600
@@ -179,8 +179,10 @@
 	 * We assume the Guest has the same number of GDT entries as the
 	 * Host, otherwise we'd have to dynamically allocate the Guest GDT.
 	 */
-	if (num >= ARRAY_SIZE(cpu->arch.gdt))
+	if (num >= ARRAY_SIZE(cpu->arch.gdt)) {
 		kill_guest(cpu, "too many gdt entries %i", num);
+		return;
+	}
 
 	/* Set it up, then fix it. */
 	cpu->arch.gdt[num].a = lo;
diff -Nur linux-2.6.32-orig/drivers/macintosh/therm_adt746x.c iDroid-Project-kernel_common-9e90fd2/drivers/macintosh/therm_adt746x.c
--- linux-2.6.32-orig/drivers/macintosh/therm_adt746x.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/macintosh/therm_adt746x.c	2010-11-18 21:05:30.000000000 +0600
@@ -79,6 +79,7 @@
 	u8			limits[3];
 	int			last_speed[2];
 	int			last_var[2];
+	int			pwm_inv[2];
 };
 
 static enum {ADT7460, ADT7467} therm_type;
@@ -229,19 +230,23 @@
 	
 	if (speed >= 0) {
 		manual = read_reg(th, MANUAL_MODE[fan]);
+		manual &= ~INVERT_MASK;
 		write_reg(th, MANUAL_MODE[fan],
-			(manual|MANUAL_MASK) & (~INVERT_MASK));
+			manual | MANUAL_MASK | th->pwm_inv[fan]);
 		write_reg(th, FAN_SPD_SET[fan], speed);
 	} else {
 		/* back to automatic */
 		if(therm_type == ADT7460) {
 			manual = read_reg(th,
 				MANUAL_MODE[fan]) & (~MANUAL_MASK);
-
+			manual &= ~INVERT_MASK;
+			manual |= th->pwm_inv[fan];
 			write_reg(th,
 				MANUAL_MODE[fan], manual|REM_CONTROL[fan]);
 		} else {
 			manual = read_reg(th, MANUAL_MODE[fan]);
+			manual &= ~INVERT_MASK;
+			manual |= th->pwm_inv[fan];
 			write_reg(th, MANUAL_MODE[fan], manual&(~AUTO_MASK));
 		}
 	}
@@ -418,6 +423,10 @@
 
 	thermostat = th;
 
+	/* record invert bit status because fw can corrupt it after suspend */
+	th->pwm_inv[0] = read_reg(th, MANUAL_MODE[0]) & INVERT_MASK;
+	th->pwm_inv[1] = read_reg(th, MANUAL_MODE[1]) & INVERT_MASK;
+
 	/* be sure to really write fan speed the first time */
 	th->last_speed[0] = -2;
 	th->last_speed[1] = -2;
diff -Nur linux-2.6.32-orig/drivers/macintosh/windfarm_smu_controls.c iDroid-Project-kernel_common-9e90fd2/drivers/macintosh/windfarm_smu_controls.c
--- linux-2.6.32-orig/drivers/macintosh/windfarm_smu_controls.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/macintosh/windfarm_smu_controls.c	2010-11-18 21:05:30.000000000 +0600
@@ -202,6 +202,8 @@
 		fct->ctrl.name = "cpu-front-fan-1";
 	else if (!strcmp(l, "CPU A PUMP"))
 		fct->ctrl.name = "cpu-pump-0";
+	else if (!strcmp(l, "CPU B PUMP"))
+		fct->ctrl.name = "cpu-pump-1";
 	else if (!strcmp(l, "Slots Fan") || !strcmp(l, "Slots fan") ||
 		 !strcmp(l, "EXPANSION SLOTS INTAKE"))
 		fct->ctrl.name = "slots-fan";
diff -Nur linux-2.6.32-orig/drivers/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/Makefile
--- linux-2.6.32-orig/drivers/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -94,6 +94,7 @@
 obj-$(CONFIG_MMC)		+= mmc/
 obj-$(CONFIG_MEMSTICK)		+= memstick/
 obj-$(CONFIG_NEW_LEDS)		+= leds/
+obj-$(CONFIG_SWITCH)		+= switch/
 obj-$(CONFIG_INFINIBAND)	+= infiniband/
 obj-$(CONFIG_SGI_SN)		+= sn/
 obj-y				+= firmware/
diff -Nur linux-2.6.32-orig/drivers/md/bitmap.c iDroid-Project-kernel_common-9e90fd2/drivers/md/bitmap.c
--- linux-2.6.32-orig/drivers/md/bitmap.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/md/bitmap.c	2010-11-18 21:05:30.000000000 +0600
@@ -1078,23 +1078,31 @@
  *			out to disk
  */
 
-void bitmap_daemon_work(struct bitmap *bitmap)
+void bitmap_daemon_work(mddev_t *mddev)
 {
+	struct bitmap *bitmap;
 	unsigned long j;
 	unsigned long flags;
 	struct page *page = NULL, *lastpage = NULL;
 	int blocks;
 	void *paddr;
 
-	if (bitmap == NULL)
+	/* Use a mutex to guard daemon_work against
+	 * bitmap_destroy.
+	 */
+	mutex_lock(&mddev->bitmap_mutex);
+	bitmap = mddev->bitmap;
+	if (bitmap == NULL) {
+		mutex_unlock(&mddev->bitmap_mutex);
 		return;
+	}
 	if (time_before(jiffies, bitmap->daemon_lastrun + bitmap->daemon_sleep*HZ))
 		goto done;
 
 	bitmap->daemon_lastrun = jiffies;
 	if (bitmap->allclean) {
 		bitmap->mddev->thread->timeout = MAX_SCHEDULE_TIMEOUT;
-		return;
+		goto done;
 	}
 	bitmap->allclean = 1;
 
@@ -1203,6 +1211,7 @@
  done:
 	if (bitmap->allclean == 0)
 		bitmap->mddev->thread->timeout = bitmap->daemon_sleep * HZ;
+	mutex_unlock(&mddev->bitmap_mutex);
 }
 
 static bitmap_counter_t *bitmap_get_counter(struct bitmap *bitmap,
@@ -1541,9 +1550,9 @@
 	 */
 	sleep = bitmap->daemon_sleep;
 	bitmap->daemon_sleep = 0;
-	bitmap_daemon_work(bitmap);
-	bitmap_daemon_work(bitmap);
-	bitmap_daemon_work(bitmap);
+	bitmap_daemon_work(mddev);
+	bitmap_daemon_work(mddev);
+	bitmap_daemon_work(mddev);
 	bitmap->daemon_sleep = sleep;
 	bitmap_update_sb(bitmap);
 }
@@ -1574,6 +1583,7 @@
 	kfree(bp);
 	kfree(bitmap);
 }
+
 void bitmap_destroy(mddev_t *mddev)
 {
 	struct bitmap *bitmap = mddev->bitmap;
@@ -1581,7 +1591,9 @@
 	if (!bitmap) /* there was no bitmap */
 		return;
 
+	mutex_lock(&mddev->bitmap_mutex);
 	mddev->bitmap = NULL; /* disconnect from the md device */
+	mutex_unlock(&mddev->bitmap_mutex);
 	if (mddev->thread)
 		mddev->thread->timeout = MAX_SCHEDULE_TIMEOUT;
 
diff -Nur linux-2.6.32-orig/drivers/md/bitmap.h iDroid-Project-kernel_common-9e90fd2/drivers/md/bitmap.h
--- linux-2.6.32-orig/drivers/md/bitmap.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/md/bitmap.h	2010-11-18 21:05:30.000000000 +0600
@@ -282,7 +282,7 @@
 void bitmap_cond_end_sync(struct bitmap *bitmap, sector_t sector);
 
 void bitmap_unplug(struct bitmap *bitmap);
-void bitmap_daemon_work(struct bitmap *bitmap);
+void bitmap_daemon_work(mddev_t *mddev);
 #endif
 
 #endif
diff -Nur linux-2.6.32-orig/drivers/md/dm-crypt.c iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-crypt.c
--- linux-2.6.32-orig/drivers/md/dm-crypt.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-crypt.c	2010-11-18 21:05:30.000000000 +0600
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 2003 Christophe Saout <christophe@saout.de>
  * Copyright (C) 2004 Clemens Fruhwirth <clemens@endorphin.org>
- * Copyright (C) 2006-2008 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2006-2009 Red Hat, Inc. All rights reserved.
  *
  * This file is released under the GPL.
  */
@@ -71,10 +71,21 @@
 	int (*ctr)(struct crypt_config *cc, struct dm_target *ti,
 		   const char *opts);
 	void (*dtr)(struct crypt_config *cc);
-	const char *(*status)(struct crypt_config *cc);
+	int (*init)(struct crypt_config *cc);
+	int (*wipe)(struct crypt_config *cc);
 	int (*generator)(struct crypt_config *cc, u8 *iv, sector_t sector);
 };
 
+struct iv_essiv_private {
+	struct crypto_cipher *tfm;
+	struct crypto_hash *hash_tfm;
+	u8 *salt;
+};
+
+struct iv_benbi_private {
+	int shift;
+};
+
 /*
  * Crypt: maps a linear range of a block device
  * and encrypts / decrypts at the same time.
@@ -102,8 +113,8 @@
 	struct crypt_iv_operations *iv_gen_ops;
 	char *iv_mode;
 	union {
-		struct crypto_cipher *essiv_tfm;
-		int benbi_shift;
+		struct iv_essiv_private essiv;
+		struct iv_benbi_private benbi;
 	} iv_gen_private;
 	sector_t iv_offset;
 	unsigned int iv_size;
@@ -169,88 +180,114 @@
 	return 0;
 }
 
-static int crypt_iv_essiv_ctr(struct crypt_config *cc, struct dm_target *ti,
-			      const char *opts)
+/* Initialise ESSIV - compute salt but no local memory allocations */
+static int crypt_iv_essiv_init(struct crypt_config *cc)
 {
-	struct crypto_cipher *essiv_tfm;
-	struct crypto_hash *hash_tfm;
+	struct iv_essiv_private *essiv = &cc->iv_gen_private.essiv;
 	struct hash_desc desc;
 	struct scatterlist sg;
-	unsigned int saltsize;
-	u8 *salt;
 	int err;
 
-	if (opts == NULL) {
+	sg_init_one(&sg, cc->key, cc->key_size);
+	desc.tfm = essiv->hash_tfm;
+	desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;
+
+	err = crypto_hash_digest(&desc, &sg, cc->key_size, essiv->salt);
+	if (err)
+		return err;
+
+	return crypto_cipher_setkey(essiv->tfm, essiv->salt,
+				    crypto_hash_digestsize(essiv->hash_tfm));
+}
+
+/* Wipe salt and reset key derived from volume key */
+static int crypt_iv_essiv_wipe(struct crypt_config *cc)
+{
+	struct iv_essiv_private *essiv = &cc->iv_gen_private.essiv;
+	unsigned salt_size = crypto_hash_digestsize(essiv->hash_tfm);
+
+	memset(essiv->salt, 0, salt_size);
+
+	return crypto_cipher_setkey(essiv->tfm, essiv->salt, salt_size);
+}
+
+static void crypt_iv_essiv_dtr(struct crypt_config *cc)
+{
+	struct iv_essiv_private *essiv = &cc->iv_gen_private.essiv;
+
+	crypto_free_cipher(essiv->tfm);
+	essiv->tfm = NULL;
+
+	crypto_free_hash(essiv->hash_tfm);
+	essiv->hash_tfm = NULL;
+
+	kzfree(essiv->salt);
+	essiv->salt = NULL;
+}
+
+static int crypt_iv_essiv_ctr(struct crypt_config *cc, struct dm_target *ti,
+			      const char *opts)
+{
+	struct crypto_cipher *essiv_tfm = NULL;
+	struct crypto_hash *hash_tfm = NULL;
+	u8 *salt = NULL;
+	int err;
+
+	if (!opts) {
 		ti->error = "Digest algorithm missing for ESSIV mode";
 		return -EINVAL;
 	}
 
-	/* Hash the cipher key with the given hash algorithm */
+	/* Allocate hash algorithm */
 	hash_tfm = crypto_alloc_hash(opts, 0, CRYPTO_ALG_ASYNC);
 	if (IS_ERR(hash_tfm)) {
 		ti->error = "Error initializing ESSIV hash";
-		return PTR_ERR(hash_tfm);
+		err = PTR_ERR(hash_tfm);
+		goto bad;
 	}
 
-	saltsize = crypto_hash_digestsize(hash_tfm);
-	salt = kmalloc(saltsize, GFP_KERNEL);
-	if (salt == NULL) {
+	salt = kzalloc(crypto_hash_digestsize(hash_tfm), GFP_KERNEL);
+	if (!salt) {
 		ti->error = "Error kmallocing salt storage in ESSIV";
-		crypto_free_hash(hash_tfm);
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto bad;
 	}
 
-	sg_init_one(&sg, cc->key, cc->key_size);
-	desc.tfm = hash_tfm;
-	desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;
-	err = crypto_hash_digest(&desc, &sg, cc->key_size, salt);
-	crypto_free_hash(hash_tfm);
-
-	if (err) {
-		ti->error = "Error calculating hash in ESSIV";
-		kfree(salt);
-		return err;
-	}
-
-	/* Setup the essiv_tfm with the given salt */
+	/* Allocate essiv_tfm */
 	essiv_tfm = crypto_alloc_cipher(cc->cipher, 0, CRYPTO_ALG_ASYNC);
 	if (IS_ERR(essiv_tfm)) {
 		ti->error = "Error allocating crypto tfm for ESSIV";
-		kfree(salt);
-		return PTR_ERR(essiv_tfm);
+		err = PTR_ERR(essiv_tfm);
+		goto bad;
 	}
 	if (crypto_cipher_blocksize(essiv_tfm) !=
 	    crypto_ablkcipher_ivsize(cc->tfm)) {
 		ti->error = "Block size of ESSIV cipher does "
 			    "not match IV size of block cipher";
-		crypto_free_cipher(essiv_tfm);
-		kfree(salt);
-		return -EINVAL;
-	}
-	err = crypto_cipher_setkey(essiv_tfm, salt, saltsize);
-	if (err) {
-		ti->error = "Failed to set key for ESSIV cipher";
-		crypto_free_cipher(essiv_tfm);
-		kfree(salt);
-		return err;
+		err = -EINVAL;
+		goto bad;
 	}
-	kfree(salt);
 
-	cc->iv_gen_private.essiv_tfm = essiv_tfm;
+	cc->iv_gen_private.essiv.salt = salt;
+	cc->iv_gen_private.essiv.tfm = essiv_tfm;
+	cc->iv_gen_private.essiv.hash_tfm = hash_tfm;
+
 	return 0;
-}
 
-static void crypt_iv_essiv_dtr(struct crypt_config *cc)
-{
-	crypto_free_cipher(cc->iv_gen_private.essiv_tfm);
-	cc->iv_gen_private.essiv_tfm = NULL;
+bad:
+	if (essiv_tfm && !IS_ERR(essiv_tfm))
+		crypto_free_cipher(essiv_tfm);
+	if (hash_tfm && !IS_ERR(hash_tfm))
+		crypto_free_hash(hash_tfm);
+	kfree(salt);
+	return err;
 }
 
 static int crypt_iv_essiv_gen(struct crypt_config *cc, u8 *iv, sector_t sector)
 {
 	memset(iv, 0, cc->iv_size);
 	*(u64 *)iv = cpu_to_le64(sector);
-	crypto_cipher_encrypt_one(cc->iv_gen_private.essiv_tfm, iv, iv);
+	crypto_cipher_encrypt_one(cc->iv_gen_private.essiv.tfm, iv, iv);
 	return 0;
 }
 
@@ -273,7 +310,7 @@
 		return -EINVAL;
 	}
 
-	cc->iv_gen_private.benbi_shift = 9 - log;
+	cc->iv_gen_private.benbi.shift = 9 - log;
 
 	return 0;
 }
@@ -288,7 +325,7 @@
 
 	memset(iv, 0, cc->iv_size - sizeof(u64)); /* rest is cleared below */
 
-	val = cpu_to_be64(((u64)sector << cc->iv_gen_private.benbi_shift) + 1);
+	val = cpu_to_be64(((u64)sector << cc->iv_gen_private.benbi.shift) + 1);
 	put_unaligned(val, (__be64 *)(iv + cc->iv_size - sizeof(u64)));
 
 	return 0;
@@ -308,6 +345,8 @@
 static struct crypt_iv_operations crypt_iv_essiv_ops = {
 	.ctr       = crypt_iv_essiv_ctr,
 	.dtr       = crypt_iv_essiv_dtr,
+	.init      = crypt_iv_essiv_init,
+	.wipe      = crypt_iv_essiv_wipe,
 	.generator = crypt_iv_essiv_gen
 };
 
@@ -1039,6 +1078,12 @@
 	    cc->iv_gen_ops->ctr(cc, ti, ivopts) < 0)
 		goto bad_ivmode;
 
+	if (cc->iv_gen_ops && cc->iv_gen_ops->init &&
+	    cc->iv_gen_ops->init(cc) < 0) {
+		ti->error = "Error initialising IV";
+		goto bad_slab_pool;
+	}
+
 	cc->iv_size = crypto_ablkcipher_ivsize(tfm);
 	if (cc->iv_size)
 		/* at least a 64 bit sector number should fit in our buffer */
@@ -1278,6 +1323,7 @@
 static int crypt_message(struct dm_target *ti, unsigned argc, char **argv)
 {
 	struct crypt_config *cc = ti->private;
+	int ret = -EINVAL;
 
 	if (argc < 2)
 		goto error;
@@ -1287,10 +1333,22 @@
 			DMWARN("not suspended during key manipulation.");
 			return -EINVAL;
 		}
-		if (argc == 3 && !strnicmp(argv[1], MESG_STR("set")))
-			return crypt_set_key(cc, argv[2]);
-		if (argc == 2 && !strnicmp(argv[1], MESG_STR("wipe")))
+		if (argc == 3 && !strnicmp(argv[1], MESG_STR("set"))) {
+			ret = crypt_set_key(cc, argv[2]);
+			if (ret)
+				return ret;
+			if (cc->iv_gen_ops && cc->iv_gen_ops->init)
+				ret = cc->iv_gen_ops->init(cc);
+			return ret;
+		}
+		if (argc == 2 && !strnicmp(argv[1], MESG_STR("wipe"))) {
+			if (cc->iv_gen_ops && cc->iv_gen_ops->wipe) {
+				ret = cc->iv_gen_ops->wipe(cc);
+				if (ret)
+					return ret;
+			}
 			return crypt_wipe_key(cc);
+		}
 	}
 
 error:
diff -Nur linux-2.6.32-orig/drivers/md/dm-exception-store.c iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-exception-store.c
--- linux-2.6.32-orig/drivers/md/dm-exception-store.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-exception-store.c	2010-11-18 21:05:30.000000000 +0600
@@ -216,7 +216,8 @@
 		type = get_type("N");
 	else {
 		ti->error = "Persistent flag is not P or N";
-		return -EINVAL;
+		r = -EINVAL;
+		goto bad_type;
 	}
 
 	if (!type) {
diff -Nur linux-2.6.32-orig/drivers/md/dm-ioctl.c iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-ioctl.c
--- linux-2.6.32-orig/drivers/md/dm-ioctl.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-ioctl.c	2010-11-18 21:05:30.000000000 +0600
@@ -56,6 +56,11 @@
  */
 static DECLARE_RWSEM(_hash_lock);
 
+/*
+ * Protects use of mdptr to obtain hash cell name and uuid from mapped device.
+ */
+static DEFINE_MUTEX(dm_hash_cells_mutex);
+
 static void init_buckets(struct list_head *buckets)
 {
 	unsigned int i;
@@ -206,7 +211,9 @@
 		list_add(&cell->uuid_list, _uuid_buckets + hash_str(uuid));
 	}
 	dm_get(md);
+	mutex_lock(&dm_hash_cells_mutex);
 	dm_set_mdptr(md, cell);
+	mutex_unlock(&dm_hash_cells_mutex);
 	up_write(&_hash_lock);
 
 	return 0;
@@ -224,7 +231,9 @@
 	/* remove from the dev hash */
 	list_del(&hc->uuid_list);
 	list_del(&hc->name_list);
+	mutex_lock(&dm_hash_cells_mutex);
 	dm_set_mdptr(hc->md, NULL);
+	mutex_unlock(&dm_hash_cells_mutex);
 
 	table = dm_get_table(hc->md);
 	if (table) {
@@ -321,7 +330,9 @@
 	 */
 	list_del(&hc->name_list);
 	old_name = hc->name;
+	mutex_lock(&dm_hash_cells_mutex);
 	hc->name = new_name;
+	mutex_unlock(&dm_hash_cells_mutex);
 	list_add(&hc->name_list, _name_buckets + hash_str(new_name));
 
 	/*
@@ -1582,8 +1593,7 @@
 	if (!md)
 		return -ENXIO;
 
-	dm_get(md);
-	down_read(&_hash_lock);
+	mutex_lock(&dm_hash_cells_mutex);
 	hc = dm_get_mdptr(md);
 	if (!hc || hc->md != md) {
 		r = -ENXIO;
@@ -1596,8 +1606,7 @@
 		strcpy(uuid, hc->uuid ? : "");
 
 out:
-	up_read(&_hash_lock);
-	dm_put(md);
+	mutex_unlock(&dm_hash_cells_mutex);
 
 	return r;
 }
diff -Nur linux-2.6.32-orig/drivers/md/dm-log-userspace-transfer.c iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-log-userspace-transfer.c
--- linux-2.6.32-orig/drivers/md/dm-log-userspace-transfer.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-log-userspace-transfer.c	2010-11-18 21:05:30.000000000 +0600
@@ -172,11 +172,15 @@
 {
 	int r = 0;
 	size_t dummy = 0;
-	int overhead_size =
-		sizeof(struct dm_ulog_request *) + sizeof(struct cn_msg);
+	int overhead_size = sizeof(struct dm_ulog_request) + sizeof(struct cn_msg);
 	struct dm_ulog_request *tfr = prealloced_ulog_tfr;
 	struct receiving_pkg pkg;
 
+	/*
+	 * Given the space needed to hold the 'struct cn_msg' and
+	 * 'struct dm_ulog_request' - do we have enough payload
+	 * space remaining?
+	 */
 	if (data_size > (DM_ULOG_PREALLOCED_SIZE - overhead_size)) {
 		DMINFO("Size of tfr exceeds preallocated size");
 		return -EINVAL;
@@ -191,7 +195,7 @@
 	 */
 	mutex_lock(&dm_ulog_lock);
 
-	memset(tfr, 0, DM_ULOG_PREALLOCED_SIZE - overhead_size);
+	memset(tfr, 0, DM_ULOG_PREALLOCED_SIZE - sizeof(struct cn_msg));
 	memcpy(tfr->uuid, uuid, DM_UUID_LEN);
 	tfr->luid = luid;
 	tfr->seq = dm_ulog_seq++;
diff -Nur linux-2.6.32-orig/drivers/md/dm-snap.c iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-snap.c
--- linux-2.6.32-orig/drivers/md/dm-snap.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-snap.c	2010-11-18 21:05:30.000000000 +0600
@@ -553,6 +553,8 @@
 	hash_size = min(origin_dev_size, cow_dev_size) >> s->store->chunk_shift;
 	hash_size = min(hash_size, max_buckets);
 
+	if (hash_size < 64)
+		hash_size = 64;
 	hash_size = rounddown_pow_of_two(hash_size);
 	if (init_exception_table(&s->complete, hash_size,
 				 DM_CHUNK_CONSECUTIVE_BITS))
@@ -1152,10 +1154,11 @@
 	unsigned sz = 0;
 	struct dm_snapshot *snap = ti->private;
 
-	down_write(&snap->lock);
-
 	switch (type) {
 	case STATUSTYPE_INFO:
+
+		down_write(&snap->lock);
+
 		if (!snap->valid)
 			DMEMIT("Invalid");
 		else {
@@ -1171,6 +1174,9 @@
 			else
 				DMEMIT("Unknown");
 		}
+
+		up_write(&snap->lock);
+
 		break;
 
 	case STATUSTYPE_TABLE:
@@ -1185,8 +1191,6 @@
 		break;
 	}
 
-	up_write(&snap->lock);
-
 	return 0;
 }
 
diff -Nur linux-2.6.32-orig/drivers/md/dm-stripe.c iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-stripe.c
--- linux-2.6.32-orig/drivers/md/dm-stripe.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-stripe.c	2010-11-18 21:05:30.000000000 +0600
@@ -110,7 +110,7 @@
 	}
 
 	stripes = simple_strtoul(argv[0], &end, 10);
-	if (*end) {
+	if (!stripes || *end) {
 		ti->error = "Invalid stripe count";
 		return -EINVAL;
 	}
diff -Nur linux-2.6.32-orig/drivers/md/dm-table.c iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-table.c
--- linux-2.6.32-orig/drivers/md/dm-table.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-table.c	2010-11-18 21:05:30.000000000 +0600
@@ -499,16 +499,15 @@
 		return 0;
 	}
 
-	if (blk_stack_limits(limits, &q->limits, start << 9) < 0)
-		DMWARN("%s: target device %s is misaligned: "
+	if (bdev_stack_limits(limits, bdev, start) < 0)
+		DMWARN("%s: adding target device %s caused an alignment inconsistency: "
 		       "physical_block_size=%u, logical_block_size=%u, "
 		       "alignment_offset=%u, start=%llu",
 		       dm_device_name(ti->table->md), bdevname(bdev, b),
 		       q->limits.physical_block_size,
 		       q->limits.logical_block_size,
 		       q->limits.alignment_offset,
-		       (unsigned long long) start << 9);
-
+		       (unsigned long long) start << SECTOR_SHIFT);
 
 	/*
 	 * Check if merge fn is supported.
@@ -1025,9 +1024,9 @@
 		 * for the table.
 		 */
 		if (blk_stack_limits(limits, &ti_limits, 0) < 0)
-			DMWARN("%s: target device "
+			DMWARN("%s: adding target device "
 			       "(start sect %llu len %llu) "
-			       "is misaligned",
+			       "caused an alignment inconsistency",
 			       dm_device_name(table->md),
 			       (unsigned long long) ti->begin,
 			       (unsigned long long) ti->len);
@@ -1079,15 +1078,6 @@
 			       struct queue_limits *limits)
 {
 	/*
-	 * Each target device in the table has a data area that should normally
-	 * be aligned such that the DM device's alignment_offset is 0.
-	 * FIXME: Propagate alignment_offsets up the stack and warn of
-	 *	  sub-optimal or inconsistent settings.
-	 */
-	limits->alignment_offset = 0;
-	limits->misaligned = 0;
-
-	/*
 	 * Copy table's limits to the DM device's request_queue
 	 */
 	q->limits = *limits;
diff -Nur linux-2.6.32-orig/drivers/md/dm-uevent.c iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-uevent.c
--- linux-2.6.32-orig/drivers/md/dm-uevent.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/md/dm-uevent.c	2010-11-18 21:05:30.000000000 +0600
@@ -139,14 +139,13 @@
 		list_del_init(&event->elist);
 
 		/*
-		 * Need to call dm_copy_name_and_uuid from here for now.
-		 * Context of previous var adds and locking used for
-		 * hash_cell not compatable.
+		 * When a device is being removed this copy fails and we
+		 * discard these unsent events.
 		 */
 		if (dm_copy_name_and_uuid(event->md, event->name,
 					  event->uuid)) {
-			DMERR("%s: dm_copy_name_and_uuid() failed",
-			      __func__);
+			DMINFO("%s: skipping sending uevent for lost device",
+			       __func__);
 			goto uevent_free;
 		}
 
diff -Nur linux-2.6.32-orig/drivers/md/md.c iDroid-Project-kernel_common-9e90fd2/drivers/md/md.c
--- linux-2.6.32-orig/drivers/md/md.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/md/md.c	2010-11-18 21:05:30.000000000 +0600
@@ -282,7 +282,9 @@
 	if (!atomic_dec_and_lock(&mddev->active, &all_mddevs_lock))
 		return;
 	if (!mddev->raid_disks && list_empty(&mddev->disks) &&
-	    !mddev->hold_active) {
+	    mddev->ctime == 0 && !mddev->hold_active) {
+		/* Array is not configured at all, and not held active,
+		 * so destroy it */
 		list_del(&mddev->all_mddevs);
 		if (mddev->gendisk) {
 			/* we did a probe so need to clean up.
@@ -367,6 +369,7 @@
 
 	mutex_init(&new->open_mutex);
 	mutex_init(&new->reconfig_mutex);
+	mutex_init(&new->bitmap_mutex);
 	INIT_LIST_HEAD(&new->disks);
 	INIT_LIST_HEAD(&new->all_mddevs);
 	init_timer(&new->safemode_timer);
@@ -4170,7 +4173,7 @@
 	mddev->barriers_work = 1;
 	mddev->ok_start_degraded = start_dirty_degraded;
 
-	if (start_readonly)
+	if (start_readonly && mddev->ro == 0)
 		mddev->ro = 2; /* read-only, but switch on first write */
 
 	err = mddev->pers->run(mddev);
@@ -5070,6 +5073,10 @@
 		mddev->minor_version = info->minor_version;
 		mddev->patch_version = info->patch_version;
 		mddev->persistent = !info->not_persistent;
+		/* ensure mddev_put doesn't delete this now that there
+		 * is some minimal configuration.
+		 */
+		mddev->ctime         = get_seconds();
 		return 0;
 	}
 	mddev->major_version = MD_MAJOR_VERSION;
@@ -6629,7 +6636,7 @@
 
 
 	if (mddev->bitmap)
-		bitmap_daemon_work(mddev->bitmap);
+		bitmap_daemon_work(mddev);
 
 	if (mddev->ro)
 		return;
diff -Nur linux-2.6.32-orig/drivers/md/md.h iDroid-Project-kernel_common-9e90fd2/drivers/md/md.h
--- linux-2.6.32-orig/drivers/md/md.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/md/md.h	2010-11-18 21:05:30.000000000 +0600
@@ -289,6 +289,7 @@
 								* hot-adding a bitmap.  It should
 								* eventually be settable by sysfs.
 								*/
+	struct mutex			bitmap_mutex;
 
 	struct list_head		all_mddevs;
 };
diff -Nur linux-2.6.32-orig/drivers/md/raid5.c iDroid-Project-kernel_common-9e90fd2/drivers/md/raid5.c
--- linux-2.6.32-orig/drivers/md/raid5.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/md/raid5.c	2010-11-18 21:05:30.000000000 +0600
@@ -5432,11 +5432,11 @@
 		    !test_bit(Faulty, &rdev->flags)) {
 			if (raid5_add_disk(mddev, rdev) == 0) {
 				char nm[20];
-				if (rdev->raid_disk >= conf->previous_raid_disks)
+				if (rdev->raid_disk >= conf->previous_raid_disks) {
 					set_bit(In_sync, &rdev->flags);
-				else
+					added_devices++;
+				} else
 					rdev->recovery_offset = 0;
-				added_devices++;
 				sprintf(nm, "rd%d", rdev->raid_disk);
 				if (sysfs_create_link(&mddev->kobj,
 						      &rdev->kobj, nm))
@@ -5448,9 +5448,12 @@
 				break;
 		}
 
+	/* When a reshape changes the number of devices, ->degraded
+	 * is measured against the large of the pre and post number of
+	 * devices.*/
 	if (mddev->delta_disks > 0) {
 		spin_lock_irqsave(&conf->device_lock, flags);
-		mddev->degraded = (conf->raid_disks - conf->previous_raid_disks)
+		mddev->degraded += (conf->raid_disks - conf->previous_raid_disks)
 			- added_devices;
 		spin_unlock_irqrestore(&conf->device_lock, flags);
 	}
diff -Nur linux-2.6.32-orig/drivers/media/common/tuners/mxl5007t.c iDroid-Project-kernel_common-9e90fd2/drivers/media/common/tuners/mxl5007t.c
--- linux-2.6.32-orig/drivers/media/common/tuners/mxl5007t.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/media/common/tuners/mxl5007t.c	2010-11-18 21:05:30.000000000 +0600
@@ -196,7 +196,7 @@
 	i = j = 0;
 
 	while (reg_pair1[i].reg || reg_pair1[i].val) {
-		while (reg_pair2[j].reg || reg_pair2[j].reg) {
+		while (reg_pair2[j].reg || reg_pair2[j].val) {
 			if (reg_pair1[i].reg != reg_pair2[j].reg) {
 				j++;
 				continue;
diff -Nur linux-2.6.32-orig/drivers/media/dvb/dvb-core/dmxdev.c iDroid-Project-kernel_common-9e90fd2/drivers/media/dvb/dvb-core/dmxdev.c
--- linux-2.6.32-orig/drivers/media/dvb/dvb-core/dmxdev.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/media/dvb/dvb-core/dmxdev.c	2010-11-18 21:05:30.000000000 +0600
@@ -761,7 +761,6 @@
 	dvb_ringbuffer_init(&dmxdevfilter->buffer, NULL, 8192);
 	dmxdevfilter->type = DMXDEV_TYPE_NONE;
 	dvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_ALLOCATED);
-	INIT_LIST_HEAD(&dmxdevfilter->feed.ts);
 	init_timer(&dmxdevfilter->timer);
 
 	dvbdev->users++;
@@ -887,6 +886,7 @@
 	dmxdevfilter->type = DMXDEV_TYPE_PES;
 	memcpy(&dmxdevfilter->params, params,
 	       sizeof(struct dmx_pes_filter_params));
+	INIT_LIST_HEAD(&dmxdevfilter->feed.ts);
 
 	dvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_SET);
 
diff -Nur linux-2.6.32-orig/drivers/media/dvb/siano/smsusb.c iDroid-Project-kernel_common-9e90fd2/drivers/media/dvb/siano/smsusb.c
--- linux-2.6.32-orig/drivers/media/dvb/siano/smsusb.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/media/dvb/siano/smsusb.c	2010-11-18 21:05:30.000000000 +0600
@@ -533,8 +533,18 @@
 		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
 	{ USB_DEVICE(0x2040, 0xb910),
 		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
+	{ USB_DEVICE(0x2040, 0xb980),
+		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
+	{ USB_DEVICE(0x2040, 0xb990),
+		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
 	{ USB_DEVICE(0x2040, 0xc000),
 		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
+	{ USB_DEVICE(0x2040, 0xc010),
+		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
+	{ USB_DEVICE(0x2040, 0xc080),
+		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
+	{ USB_DEVICE(0x2040, 0xc090),
+		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
 	{ } /* Terminating entry */
 	};
 
diff -Nur linux-2.6.32-orig/drivers/media/video/gspca/ov519.c iDroid-Project-kernel_common-9e90fd2/drivers/media/video/gspca/ov519.c
--- linux-2.6.32-orig/drivers/media/video/gspca/ov519.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/media/video/gspca/ov519.c	2010-11-18 21:05:30.000000000 +0600
@@ -3364,6 +3364,7 @@
 	{USB_DEVICE(0x041e, 0x4061), .driver_info = BRIDGE_OV519 },
 	{USB_DEVICE(0x041e, 0x4064),
 	 .driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },
+	{USB_DEVICE(0x041e, 0x4067), .driver_info = BRIDGE_OV519 },
 	{USB_DEVICE(0x041e, 0x4068),
 	 .driver_info = BRIDGE_OV519 | BRIDGE_INVERT_LED },
 	{USB_DEVICE(0x045e, 0x028c), .driver_info = BRIDGE_OV519 },
diff -Nur linux-2.6.32-orig/drivers/media/video/gspca/sn9c20x.c iDroid-Project-kernel_common-9e90fd2/drivers/media/video/gspca/sn9c20x.c
--- linux-2.6.32-orig/drivers/media/video/gspca/sn9c20x.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/media/video/gspca/sn9c20x.c	2010-11-18 21:05:30.000000000 +0600
@@ -2319,7 +2319,7 @@
 		}
 	}
 	if (avg_lum > MAX_AVG_LUM) {
-		if (sd->gain - 1 >= 0) {
+		if (sd->gain >= 1) {
 			sd->gain--;
 			set_gain(gspca_dev);
 		}
diff -Nur linux-2.6.32-orig/drivers/media/video/gspca/sunplus.c iDroid-Project-kernel_common-9e90fd2/drivers/media/video/gspca/sunplus.c
--- linux-2.6.32-orig/drivers/media/video/gspca/sunplus.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/media/video/gspca/sunplus.c	2010-11-18 21:05:30.000000000 +0600
@@ -705,7 +705,7 @@
 		rc = spca504B_PollingDataReady(gspca_dev);
 
 		/* Init the cam width height with some values get on init ? */
-		reg_w_riv(dev, 0x31, 0, 0x04);
+		reg_w_riv(dev, 0x31, 0x04, 0);
 		spca504B_WaitCmdStatus(gspca_dev);
 		rc = spca504B_PollingDataReady(gspca_dev);
 		break;
@@ -807,14 +807,14 @@
 	default:
 /*	case BRIDGE_SPCA533: */
 /*	case BRIDGE_SPCA504B: */
-		reg_w_riv(dev, 0, 0x00, 0x21ad);	/* hue */
-		reg_w_riv(dev, 0, 0x01, 0x21ac);	/* sat/hue */
-		reg_w_riv(dev, 0, 0x00, 0x21a3);	/* gamma */
+		reg_w_riv(dev, 0, 0x21ad, 0x00);	/* hue */
+		reg_w_riv(dev, 0, 0x21ac, 0x01);	/* sat/hue */
+		reg_w_riv(dev, 0, 0x21a3, 0x00);	/* gamma */
 		break;
 	case BRIDGE_SPCA536:
-		reg_w_riv(dev, 0, 0x40, 0x20f5);
-		reg_w_riv(dev, 0, 0x01, 0x20f4);
-		reg_w_riv(dev, 0, 0x00, 0x2089);
+		reg_w_riv(dev, 0, 0x20f5, 0x40);
+		reg_w_riv(dev, 0, 0x20f4, 0x01);
+		reg_w_riv(dev, 0, 0x2089, 0x00);
 		break;
 	}
 	if (pollreg)
@@ -888,11 +888,11 @@
 	switch (sd->bridge) {
 	case BRIDGE_SPCA504B:
 		reg_w_riv(dev, 0x1d, 0x00, 0);
-		reg_w_riv(dev, 0, 0x01, 0x2306);
-		reg_w_riv(dev, 0, 0x00, 0x0d04);
-		reg_w_riv(dev, 0, 0x00, 0x2000);
-		reg_w_riv(dev, 0, 0x13, 0x2301);
-		reg_w_riv(dev, 0, 0x00, 0x2306);
+		reg_w_riv(dev, 0, 0x2306, 0x01);
+		reg_w_riv(dev, 0, 0x0d04, 0x00);
+		reg_w_riv(dev, 0, 0x2000, 0x00);
+		reg_w_riv(dev, 0, 0x2301, 0x13);
+		reg_w_riv(dev, 0, 0x2306, 0x00);
 		/* fall thru */
 	case BRIDGE_SPCA533:
 		spca504B_PollingDataReady(gspca_dev);
@@ -1011,7 +1011,7 @@
 			spca504B_WaitCmdStatus(gspca_dev);
 			break;
 		default:
-			reg_w_riv(dev, 0x31, 0, 0x04);
+			reg_w_riv(dev, 0x31, 0x04, 0);
 			spca504B_WaitCmdStatus(gspca_dev);
 			spca504B_PollingDataReady(gspca_dev);
 			break;
diff -Nur linux-2.6.32-orig/drivers/media/video/ov511.c iDroid-Project-kernel_common-9e90fd2/drivers/media/video/ov511.c
--- linux-2.6.32-orig/drivers/media/video/ov511.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/media/video/ov511.c	2010-11-18 21:05:30.000000000 +0600
@@ -5878,7 +5878,7 @@
 		goto error;
 	}
 
-	mutex_lock(&ov->lock);
+	mutex_unlock(&ov->lock);
 
 	return 0;
 
diff -Nur linux-2.6.32-orig/drivers/media/video/saa7134/saa7134-cards.c iDroid-Project-kernel_common-9e90fd2/drivers/media/video/saa7134/saa7134-cards.c
--- linux-2.6.32-orig/drivers/media/video/saa7134/saa7134-cards.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/media/video/saa7134/saa7134-cards.c	2010-11-18 21:05:30.000000000 +0600
@@ -5279,6 +5279,30 @@
 			.amux = TV,
 		},
 	},
+	[SAA7134_BOARD_ASUS_EUROPA_HYBRID] = {
+		.name           = "Asus Europa Hybrid OEM",
+		.audio_clock    = 0x00187de7,
+		.tuner_type     = TUNER_PHILIPS_TD1316,
+		.radio_type     = UNSET,
+		.tuner_addr	= 0x61,
+		.radio_addr	= ADDR_UNSET,
+		.tda9887_conf   = TDA9887_PRESENT | TDA9887_PORT1_ACTIVE,
+		.mpeg           = SAA7134_MPEG_DVB,
+		.inputs = { {
+			.name   = name_tv,
+			.vmux   = 3,
+			.amux   = TV,
+			.tv     = 1,
+		}, {
+			.name   = name_comp1,
+			.vmux   = 4,
+			.amux   = LINE2,
+		}, {
+			.name   = name_svideo,
+			.vmux   = 8,
+			.amux   = LINE2,
+		} },
+	},
 
 };
 
@@ -6418,6 +6442,12 @@
 		.subdevice    = 0x2004,
 		.driver_data  = SAA7134_BOARD_ZOLID_HYBRID_PCI,
 	}, {
+		.vendor       = PCI_VENDOR_ID_PHILIPS,
+		.device       = PCI_DEVICE_ID_PHILIPS_SAA7134,
+		.subvendor    = 0x1043,
+		.subdevice    = 0x4847,
+		.driver_data  = SAA7134_BOARD_ASUS_EUROPA_HYBRID,
+	}, {
 		/* --- boards without eeprom + subsystem ID --- */
 		.vendor       = PCI_VENDOR_ID_PHILIPS,
 		.device       = PCI_DEVICE_ID_PHILIPS_SAA7134,
@@ -7079,6 +7109,7 @@
 		/* break intentionally omitted */
 	case SAA7134_BOARD_VIDEOMATE_DVBT_300:
 	case SAA7134_BOARD_ASUS_EUROPA2_HYBRID:
+	case SAA7134_BOARD_ASUS_EUROPA_HYBRID:
 	{
 
 		/* The Philips EUROPA based hybrid boards have the tuner
diff -Nur linux-2.6.32-orig/drivers/media/video/saa7134/saa7134-dvb.c iDroid-Project-kernel_common-9e90fd2/drivers/media/video/saa7134/saa7134-dvb.c
--- linux-2.6.32-orig/drivers/media/video/saa7134/saa7134-dvb.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/media/video/saa7134/saa7134-dvb.c	2010-11-18 21:05:30.000000000 +0600
@@ -1116,6 +1116,7 @@
 		break;
 	case SAA7134_BOARD_PHILIPS_EUROPA:
 	case SAA7134_BOARD_VIDEOMATE_DVBT_300:
+	case SAA7134_BOARD_ASUS_EUROPA_HYBRID:
 		fe0->dvb.frontend = dvb_attach(tda10046_attach,
 					       &philips_europa_config,
 					       &dev->i2c_adap);
diff -Nur linux-2.6.32-orig/drivers/media/video/saa7134/saa7134.h iDroid-Project-kernel_common-9e90fd2/drivers/media/video/saa7134/saa7134.h
--- linux-2.6.32-orig/drivers/media/video/saa7134/saa7134.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/media/video/saa7134/saa7134.h	2010-11-18 21:05:30.000000000 +0600
@@ -297,6 +297,7 @@
 #define SAA7134_BOARD_BEHOLD_X7             171
 #define SAA7134_BOARD_ROVERMEDIA_LINK_PRO_FM 172
 #define SAA7134_BOARD_ZOLID_HYBRID_PCI		173
+#define SAA7134_BOARD_ASUS_EUROPA_HYBRID	174
 
 #define SAA7134_MAXBOARDS 32
 #define SAA7134_INPUT_MAX 8
diff -Nur linux-2.6.32-orig/drivers/media/video/uvc/uvc_ctrl.c iDroid-Project-kernel_common-9e90fd2/drivers/media/video/uvc/uvc_ctrl.c
--- linux-2.6.32-orig/drivers/media/video/uvc/uvc_ctrl.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/media/video/uvc/uvc_ctrl.c	2010-11-18 21:05:30.000000000 +0600
@@ -1405,7 +1405,7 @@
 	size = entity->processing.bControlSize;
 
 	for (i = 0; i < ARRAY_SIZE(blacklist); ++i) {
-		if (!usb_match_id(dev->intf, &blacklist[i].id))
+		if (!usb_match_one_id(dev->intf, &blacklist[i].id))
 			continue;
 
 		if (blacklist[i].index >= 8 * size ||
diff -Nur linux-2.6.32-orig/drivers/message/fusion/mptbase.c iDroid-Project-kernel_common-9e90fd2/drivers/message/fusion/mptbase.c
--- linux-2.6.32-orig/drivers/message/fusion/mptbase.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/message/fusion/mptbase.c	2010-11-18 21:05:30.000000000 +0600
@@ -4330,6 +4330,8 @@
 
 	if (ioc->bus_type == SPI)
 		num_chain *= MPT_SCSI_CAN_QUEUE;
+	else if (ioc->bus_type == SAS)
+		num_chain *= MPT_SAS_CAN_QUEUE;
 	else
 		num_chain *= MPT_FC_CAN_QUEUE;
 
diff -Nur linux-2.6.32-orig/drivers/message/fusion/mptscsih.c iDroid-Project-kernel_common-9e90fd2/drivers/message/fusion/mptscsih.c
--- linux-2.6.32-orig/drivers/message/fusion/mptscsih.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/message/fusion/mptscsih.c	2010-11-18 21:05:30.000000000 +0600
@@ -1720,7 +1720,7 @@
 		dtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "task abort: "
 		   "Command not in the active list! (sc=%p)\n", ioc->name,
 		   SCpnt));
-		retval = 0;
+		retval = SUCCESS;
 		goto out;
 	}
 
diff -Nur linux-2.6.32-orig/drivers/mfd/wm8350-core.c iDroid-Project-kernel_common-9e90fd2/drivers/mfd/wm8350-core.c
--- linux-2.6.32-orig/drivers/mfd/wm8350-core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mfd/wm8350-core.c	2010-11-18 21:05:30.000000000 +0600
@@ -134,8 +134,7 @@
 	    wm8350->reg_cache[WM8350_SECURITY] == WM8350_UNLOCK_KEY)
 		return 0;
 
-	if ((reg == WM8350_GPIO_CONFIGURATION_I_O) ||
-	    (reg >= WM8350_GPIO_FUNCTION_SELECT_1 &&
+	if ((reg >= WM8350_GPIO_FUNCTION_SELECT_1 &&
 	     reg <= WM8350_GPIO_FUNCTION_SELECT_4) ||
 	    (reg >= WM8350_BATTERY_CHARGER_CONTROL_1 &&
 	     reg <= WM8350_BATTERY_CHARGER_CONTROL_3))
diff -Nur linux-2.6.32-orig/drivers/misc/apanic.c iDroid-Project-kernel_common-9e90fd2/drivers/misc/apanic.c
--- linux-2.6.32-orig/drivers/misc/apanic.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/misc/apanic.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,606 @@
+/* drivers/misc/apanic.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Author: San Mehat <san@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/wakelock.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/mtd/mtd.h>
+#include <linux/notifier.h>
+#include <linux/mtd/mtd.h>
+#include <linux/debugfs.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/preempt.h>
+
+extern void ram_console_enable_console(int);
+
+struct panic_header {
+	u32 magic;
+#define PANIC_MAGIC 0xdeadf00d
+
+	u32 version;
+#define PHDR_VERSION   0x01
+
+	u32 console_offset;
+	u32 console_length;
+
+	u32 threads_offset;
+	u32 threads_length;
+};
+
+struct apanic_data {
+	struct mtd_info		*mtd;
+	struct panic_header	curr;
+	void			*bounce;
+	struct proc_dir_entry	*apanic_console;
+	struct proc_dir_entry	*apanic_threads;
+};
+
+static struct apanic_data drv_ctx;
+static struct work_struct proc_removal_work;
+static DEFINE_MUTEX(drv_mutex);
+
+static unsigned int *apanic_bbt;
+static unsigned int apanic_erase_blocks;
+static unsigned int apanic_good_blocks;
+
+static void set_bb(unsigned int block, unsigned int *bbt)
+{
+	unsigned int flag = 1;
+
+	BUG_ON(block >= apanic_erase_blocks);
+
+	flag = flag << (block%32);
+	apanic_bbt[block/32] |= flag;
+	apanic_good_blocks--;
+}
+
+static unsigned int get_bb(unsigned int block, unsigned int *bbt)
+{
+	unsigned int flag;
+
+	BUG_ON(block >= apanic_erase_blocks);
+
+	flag = 1 << (block%32);
+	return apanic_bbt[block/32] & flag;
+}
+
+static void alloc_bbt(struct mtd_info *mtd, unsigned int *bbt)
+{
+	int bbt_size;
+	apanic_erase_blocks = (mtd->size)>>(mtd->erasesize_shift);
+	bbt_size = (apanic_erase_blocks+32)/32;
+
+	apanic_bbt = kmalloc(bbt_size*4, GFP_KERNEL);
+	memset(apanic_bbt, 0, bbt_size*4);
+	apanic_good_blocks = apanic_erase_blocks;
+}
+static void scan_bbt(struct mtd_info *mtd, unsigned int *bbt)
+{
+	int i;
+
+	for (i = 0; i < apanic_erase_blocks; i++) {
+		if (mtd->block_isbad(mtd, i*mtd->erasesize))
+			set_bb(i, apanic_bbt);
+	}
+}
+
+#define APANIC_INVALID_OFFSET 0xFFFFFFFF
+
+static unsigned int phy_offset(struct mtd_info *mtd, unsigned int offset)
+{
+	unsigned int logic_block = offset>>(mtd->erasesize_shift);
+	unsigned int phy_block;
+	unsigned good_block = 0;
+
+	for (phy_block = 0; phy_block < apanic_erase_blocks; phy_block++) {
+		if (!get_bb(phy_block, apanic_bbt))
+			good_block++;
+		if (good_block == (logic_block + 1))
+			break;
+	}
+
+	if (good_block != (logic_block + 1))
+		return APANIC_INVALID_OFFSET;
+
+	return offset + ((phy_block-logic_block)<<mtd->erasesize_shift);
+}
+
+static void apanic_erase_callback(struct erase_info *done)
+{
+	wait_queue_head_t *wait_q = (wait_queue_head_t *) done->priv;
+	wake_up(wait_q);
+}
+
+static int apanic_proc_read(char *buffer, char **start, off_t offset,
+			       int count, int *peof, void *dat)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	size_t file_length;
+	off_t file_offset;
+	unsigned int page_no;
+	off_t page_offset;
+	int rc;
+	size_t len;
+
+	if (!count)
+		return 0;
+
+	mutex_lock(&drv_mutex);
+
+	switch ((int) dat) {
+	case 1:	/* apanic_console */
+		file_length = ctx->curr.console_length;
+		file_offset = ctx->curr.console_offset;
+		break;
+	case 2:	/* apanic_threads */
+		file_length = ctx->curr.threads_length;
+		file_offset = ctx->curr.threads_offset;
+		break;
+	default:
+		pr_err("Bad dat (%d)\n", (int) dat);
+		mutex_unlock(&drv_mutex);
+		return -EINVAL;
+	}
+
+	if ((offset + count) > file_length) {
+		mutex_unlock(&drv_mutex);
+		return 0;
+	}
+
+	/* We only support reading a maximum of a flash page */
+	if (count > ctx->mtd->writesize)
+		count = ctx->mtd->writesize;
+
+	page_no = (file_offset + offset) / ctx->mtd->writesize;
+	page_offset = (file_offset + offset) % ctx->mtd->writesize;
+
+
+	if (phy_offset(ctx->mtd, (page_no * ctx->mtd->writesize))
+		== APANIC_INVALID_OFFSET) {
+		pr_err("apanic: reading an invalid address\n");
+		mutex_unlock(&drv_mutex);
+		return -EINVAL;
+	}
+	rc = ctx->mtd->read(ctx->mtd,
+		phy_offset(ctx->mtd, (page_no * ctx->mtd->writesize)),
+		ctx->mtd->writesize,
+		&len, ctx->bounce);
+
+	if (page_offset)
+		count -= page_offset;
+	memcpy(buffer, ctx->bounce + page_offset, count);
+
+	*start = count;
+
+	if ((offset + count) == file_length)
+		*peof = 1;
+
+	mutex_unlock(&drv_mutex);
+	return count;
+}
+
+static void mtd_panic_erase(void)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	struct erase_info erase;
+	DECLARE_WAITQUEUE(wait, current);
+	wait_queue_head_t wait_q;
+	int rc, i;
+
+	init_waitqueue_head(&wait_q);
+	erase.mtd = ctx->mtd;
+	erase.callback = apanic_erase_callback;
+	erase.len = ctx->mtd->erasesize;
+	erase.priv = (u_long)&wait_q;
+	for (i = 0; i < ctx->mtd->size; i += ctx->mtd->erasesize) {
+		erase.addr = i;
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&wait_q, &wait);
+
+		if (get_bb(erase.addr>>ctx->mtd->erasesize_shift, apanic_bbt)) {
+			printk(KERN_WARNING
+			       "apanic: Skipping erase of bad "
+			       "block @%llx\n", erase.addr);
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&wait_q, &wait);
+			continue;
+		}
+
+		rc = ctx->mtd->erase(ctx->mtd, &erase);
+		if (rc) {
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&wait_q, &wait);
+			printk(KERN_ERR
+			       "apanic: Erase of 0x%llx, 0x%llx failed\n",
+			       (unsigned long long) erase.addr,
+			       (unsigned long long) erase.len);
+			if (rc == -EIO) {
+				if (ctx->mtd->block_markbad(ctx->mtd,
+							    erase.addr)) {
+					printk(KERN_ERR
+					       "apanic: Err marking blk bad\n");
+					goto out;
+				}
+				printk(KERN_INFO
+				       "apanic: Marked a bad block"
+				       " @%llx\n", erase.addr);
+				set_bb(erase.addr>>ctx->mtd->erasesize_shift,
+					apanic_bbt);
+				continue;
+			}
+			goto out;
+		}
+		schedule();
+		remove_wait_queue(&wait_q, &wait);
+	}
+	printk(KERN_DEBUG "apanic: %s partition erased\n",
+	       CONFIG_APANIC_PLABEL);
+out:
+	return;
+}
+
+static void apanic_remove_proc_work(struct work_struct *work)
+{
+	struct apanic_data *ctx = &drv_ctx;
+
+	mutex_lock(&drv_mutex);
+	mtd_panic_erase();
+	memset(&ctx->curr, 0, sizeof(struct panic_header));
+	if (ctx->apanic_console) {
+		remove_proc_entry("apanic_console", NULL);
+		ctx->apanic_console = NULL;
+	}
+	if (ctx->apanic_threads) {
+		remove_proc_entry("apanic_threads", NULL);
+		ctx->apanic_threads = NULL;
+	}
+	mutex_unlock(&drv_mutex);
+}
+
+static int apanic_proc_write(struct file *file, const char __user *buffer,
+				unsigned long count, void *data)
+{
+	schedule_work(&proc_removal_work);
+	return count;
+}
+
+static void mtd_panic_notify_add(struct mtd_info *mtd)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	struct panic_header *hdr = ctx->bounce;
+	size_t len;
+	int rc;
+	int    proc_entry_created = 0;
+
+	if (strcmp(mtd->name, CONFIG_APANIC_PLABEL))
+		return;
+
+	ctx->mtd = mtd;
+
+	alloc_bbt(mtd, apanic_bbt);
+	scan_bbt(mtd, apanic_bbt);
+
+	if (apanic_good_blocks == 0) {
+		printk(KERN_ERR "apanic: no any good blocks?!\n");
+		goto out_err;
+	}
+
+	rc = mtd->read(mtd, phy_offset(mtd, 0), mtd->writesize,
+			&len, ctx->bounce);
+	if (rc && rc == -EBADMSG) {
+		printk(KERN_WARNING
+		       "apanic: Bad ECC on block 0 (ignored)\n");
+	} else if (rc && rc != -EUCLEAN) {
+		printk(KERN_ERR "apanic: Error reading block 0 (%d)\n", rc);
+		goto out_err;
+	}
+
+	if (len != mtd->writesize) {
+		printk(KERN_ERR "apanic: Bad read size (%d)\n", rc);
+		goto out_err;
+	}
+
+	printk(KERN_INFO "apanic: Bound to mtd partition '%s'\n", mtd->name);
+
+	if (hdr->magic != PANIC_MAGIC) {
+		printk(KERN_INFO "apanic: No panic data available\n");
+		mtd_panic_erase();
+		return;
+	}
+
+	if (hdr->version != PHDR_VERSION) {
+		printk(KERN_INFO "apanic: Version mismatch (%d != %d)\n",
+		       hdr->version, PHDR_VERSION);
+		mtd_panic_erase();
+		return;
+	}
+
+	memcpy(&ctx->curr, hdr, sizeof(struct panic_header));
+
+	printk(KERN_INFO "apanic: c(%u, %u) t(%u, %u)\n",
+	       hdr->console_offset, hdr->console_length,
+	       hdr->threads_offset, hdr->threads_length);
+
+	if (hdr->console_length) {
+		ctx->apanic_console = create_proc_entry("apanic_console",
+						      S_IFREG | S_IRUGO, NULL);
+		if (!ctx->apanic_console)
+			printk(KERN_ERR "%s: failed creating procfile\n",
+			       __func__);
+		else {
+			ctx->apanic_console->read_proc = apanic_proc_read;
+			ctx->apanic_console->write_proc = apanic_proc_write;
+			ctx->apanic_console->size = hdr->console_length;
+			ctx->apanic_console->data = (void *) 1;
+			proc_entry_created = 1;
+		}
+	}
+
+	if (hdr->threads_length) {
+		ctx->apanic_threads = create_proc_entry("apanic_threads",
+						       S_IFREG | S_IRUGO, NULL);
+		if (!ctx->apanic_threads)
+			printk(KERN_ERR "%s: failed creating procfile\n",
+			       __func__);
+		else {
+			ctx->apanic_threads->read_proc = apanic_proc_read;
+			ctx->apanic_threads->write_proc = apanic_proc_write;
+			ctx->apanic_threads->size = hdr->threads_length;
+			ctx->apanic_threads->data = (void *) 2;
+			proc_entry_created = 1;
+		}
+	}
+
+	if (!proc_entry_created)
+		mtd_panic_erase();
+
+	return;
+out_err:
+	ctx->mtd = NULL;
+}
+
+static void mtd_panic_notify_remove(struct mtd_info *mtd)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	if (mtd == ctx->mtd) {
+		ctx->mtd = NULL;
+		printk(KERN_INFO "apanic: Unbound from %s\n", mtd->name);
+	}
+}
+
+static struct mtd_notifier mtd_panic_notifier = {
+	.add	= mtd_panic_notify_add,
+	.remove	= mtd_panic_notify_remove,
+};
+
+static int in_panic = 0;
+
+static int apanic_writeflashpage(struct mtd_info *mtd, loff_t to,
+				 const u_char *buf)
+{
+	int rc;
+	size_t wlen;
+	int panic = in_interrupt() | in_atomic();
+
+	if (panic && !mtd->panic_write) {
+		printk(KERN_EMERG "%s: No panic_write available\n", __func__);
+		return 0;
+	} else if (!panic && !mtd->write) {
+		printk(KERN_EMERG "%s: No write available\n", __func__);
+		return 0;
+	}
+
+	to = phy_offset(mtd, to);
+	if (to == APANIC_INVALID_OFFSET) {
+		printk(KERN_EMERG "apanic: write to invalid address\n");
+		return 0;
+	}
+
+	if (panic)
+		rc = mtd->panic_write(mtd, to, mtd->writesize, &wlen, buf);
+	else
+		rc = mtd->write(mtd, to, mtd->writesize, &wlen, buf);
+
+	if (rc) {
+		printk(KERN_EMERG
+		       "%s: Error writing data to flash (%d)\n",
+		       __func__, rc);
+		return rc;
+	}
+
+	return wlen;
+}
+
+extern int log_buf_copy(char *dest, int idx, int len);
+extern void log_buf_clear(void);
+
+/*
+ * Writes the contents of the console to the specified offset in flash.
+ * Returns number of bytes written
+ */
+static int apanic_write_console(struct mtd_info *mtd, unsigned int off)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	int saved_oip;
+	int idx = 0;
+	int rc, rc2;
+	unsigned int last_chunk = 0;
+
+	while (!last_chunk) {
+		saved_oip = oops_in_progress;
+		oops_in_progress = 1;
+		rc = log_buf_copy(ctx->bounce, idx, mtd->writesize);
+		if (rc < 0)
+			break;
+
+		if (rc != mtd->writesize)
+			last_chunk = rc;
+
+		oops_in_progress = saved_oip;
+		if (rc <= 0)
+			break;
+		if (rc != mtd->writesize)
+			memset(ctx->bounce + rc, 0, mtd->writesize - rc);
+
+		rc2 = apanic_writeflashpage(mtd, off, ctx->bounce);
+		if (rc2 <= 0) {
+			printk(KERN_EMERG
+			       "apanic: Flash write failed (%d)\n", rc2);
+			return idx;
+		}
+		if (!last_chunk)
+			idx += rc2;
+		else
+			idx += last_chunk;
+		off += rc2;
+	}
+	return idx;
+}
+
+static int apanic(struct notifier_block *this, unsigned long event,
+			void *ptr)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	struct panic_header *hdr = (struct panic_header *) ctx->bounce;
+	int console_offset = 0;
+	int console_len = 0;
+	int threads_offset = 0;
+	int threads_len = 0;
+	int rc;
+
+	if (in_panic)
+		return NOTIFY_DONE;
+	in_panic = 1;
+#ifdef CONFIG_PREEMPT
+	/* Ensure that cond_resched() won't try to preempt anybody */
+	add_preempt_count(PREEMPT_ACTIVE);
+#endif
+	touch_softlockup_watchdog();
+
+	if (!ctx->mtd)
+		goto out;
+
+	if (ctx->curr.magic) {
+		printk(KERN_EMERG "Crash partition in use!\n");
+		goto out;
+	}
+	console_offset = ctx->mtd->writesize;
+
+	/*
+	 * Write out the console
+	 */
+	console_len = apanic_write_console(ctx->mtd, console_offset);
+	if (console_len < 0) {
+		printk(KERN_EMERG "Error writing console to panic log! (%d)\n",
+		       console_len);
+		console_len = 0;
+	}
+
+	/*
+	 * Write out all threads
+	 */
+	threads_offset = ALIGN(console_offset + console_len,
+			       ctx->mtd->writesize);
+	if (!threads_offset)
+		threads_offset = ctx->mtd->writesize;
+
+	ram_console_enable_console(0);
+
+	log_buf_clear();
+	show_state_filter(0);
+	threads_len = apanic_write_console(ctx->mtd, threads_offset);
+	if (threads_len < 0) {
+		printk(KERN_EMERG "Error writing threads to panic log! (%d)\n",
+		       threads_len);
+		threads_len = 0;
+	}
+
+	/*
+	 * Finally write the panic header
+	 */
+	memset(ctx->bounce, 0, PAGE_SIZE);
+	hdr->magic = PANIC_MAGIC;
+	hdr->version = PHDR_VERSION;
+
+	hdr->console_offset = console_offset;
+	hdr->console_length = console_len;
+
+	hdr->threads_offset = threads_offset;
+	hdr->threads_length = threads_len;
+
+	rc = apanic_writeflashpage(ctx->mtd, 0, ctx->bounce);
+	if (rc <= 0) {
+		printk(KERN_EMERG "apanic: Header write failed (%d)\n",
+		       rc);
+		goto out;
+	}
+
+	printk(KERN_EMERG "apanic: Panic dump sucessfully written to flash\n");
+
+ out:
+#ifdef CONFIG_PREEMPT
+	sub_preempt_count(PREEMPT_ACTIVE);
+#endif
+	in_panic = 0;
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block panic_blk = {
+	.notifier_call	= apanic,
+};
+
+static int panic_dbg_get(void *data, u64 *val)
+{
+	apanic(NULL, 0, NULL);
+	return 0;
+}
+
+static int panic_dbg_set(void *data, u64 val)
+{
+	BUG();
+	return -1;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(panic_dbg_fops, panic_dbg_get, panic_dbg_set, "%llu\n");
+
+int __init apanic_init(void)
+{
+	register_mtd_user(&mtd_panic_notifier);
+	atomic_notifier_chain_register(&panic_notifier_list, &panic_blk);
+	debugfs_create_file("apanic", 0644, NULL, NULL, &panic_dbg_fops);
+	memset(&drv_ctx, 0, sizeof(drv_ctx));
+	drv_ctx.bounce = (void *) __get_free_page(GFP_KERNEL);
+	INIT_WORK(&proc_removal_work, apanic_remove_proc_work);
+	printk(KERN_INFO "Android kernel panic handler initialized (bind=%s)\n",
+	       CONFIG_APANIC_PLABEL);
+	return 0;
+}
+
+module_init(apanic_init);
diff -Nur linux-2.6.32-orig/drivers/misc/enclosure.c iDroid-Project-kernel_common-9e90fd2/drivers/misc/enclosure.c
--- linux-2.6.32-orig/drivers/misc/enclosure.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/misc/enclosure.c	2010-11-18 21:05:30.000000000 +0600
@@ -391,6 +391,7 @@
 	[ENCLOSURE_STATUS_NOT_INSTALLED] = "not installed",
 	[ENCLOSURE_STATUS_UNKNOWN] = "unknown",
 	[ENCLOSURE_STATUS_UNAVAILABLE] = "unavailable",
+	[ENCLOSURE_STATUS_MAX] = NULL,
 };
 
 static const char *const enclosure_type [] = {
diff -Nur linux-2.6.32-orig/drivers/misc/iphone3g-vibrator.c iDroid-Project-kernel_common-9e90fd2/drivers/misc/iphone3g-vibrator.c
--- linux-2.6.32-orig/drivers/misc/iphone3g-vibrator.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/misc/iphone3g-vibrator.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,131 @@
+/* drivers/misc/iphone3g-vibrator.c
+ *
+ * Author: Patrick Wildt <webmaster@patrick-wildt.de>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/hrtimer.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+
+#include <linux/timed_output.h>
+
+#define TicksPerSec 12000000
+#define VibratorTimer 5
+
+extern int timer_init(int timer_id, u32 interval, u32 interval2, u32 prescaler, u32 z, int option24, int option28, int option11, int option5, int interrupts);
+extern int timer_on_off(int timer_id, int on_off);
+extern u64 iphone_microtime(void);
+
+static u64 iphone_vibrator_end;
+static int iphone_vibrator_stop;
+static int iphone_vibrator_last_timeout;
+static u32 iphone_vibrator_waiting;
+static int iphone_queue_running;
+
+void iphone_vibrator_enable(struct timed_output_dev *iphone_vibrator_dev, int timeout) {
+	u32 count, countRun;
+	int prescaler, id;
+
+	id = ++iphone_vibrator_waiting;
+
+	iphone_vibrator_stop = 1;
+
+	while(iphone_queue_running) {
+		if (id != iphone_vibrator_waiting)
+			return;
+		msleep(100);
+	}
+
+	if (id != iphone_vibrator_waiting)
+		return;
+
+	iphone_vibrator_waiting = 0;
+	iphone_vibrator_stop = 0;
+	iphone_queue_running = 1;
+
+	if (timeout < 0) {
+		timer_init(VibratorTimer, 0, 1, 0, 0, 0, 0, 0, 0, 0);
+		timer_on_off(VibratorTimer, 1);
+		goto out;
+	}
+
+	if (timeout < 1) {
+		if (iphone_vibrator_last_timeout<0) {
+			timer_init(VibratorTimer, 0, 1, 0, 0, 0, 0, 0, 1, 0);
+			timer_on_off(VibratorTimer, 1);
+		}
+		timer_on_off(VibratorTimer, 0);
+		goto out;
+	}
+
+	timeout *= 1000;
+
+	iphone_vibrator_end = iphone_microtime() + timeout;
+        count = timeout * (TicksPerSec/1000000);
+        while(!iphone_vibrator_stop) {
+                countRun = count;
+                if (count > TicksPerSec)
+                        countRun = TicksPerSec;
+                prescaler = 1;
+                while(countRun > 0xFFFF)
+                {
+                        countRun >>= 1;
+                        prescaler <<= 1;
+                }
+
+		timer_init(VibratorTimer, 0, countRun, prescaler - 1, 0, 0, 0, 0, 1, 0);
+                timer_on_off(VibratorTimer, 1);
+                if (TicksPerSec > count)
+			goto out;
+                count -= TicksPerSec;
+                msleep(1000);
+        }
+
+out:
+	iphone_vibrator_last_timeout = timeout;
+	iphone_vibrator_end = 0;
+	iphone_queue_running = 0;
+}
+
+int iphone_vibrator_get_time(struct timed_output_dev *iphone_vibrator_dev) {
+        if (iphone_vibrator_end == 0)
+                return 0;
+        if (iphone_vibrator_end > iphone_microtime())
+                return 0;
+        return((int)(iphone_vibrator_end - iphone_microtime()));
+}
+
+struct timed_output_dev iphone_vibrator_dev = {
+        .name = "vibrator",
+        .enable = iphone_vibrator_enable,
+        .get_time = iphone_vibrator_get_time,
+};
+
+static int __init iphone_vibrator_init(void)
+{
+	return timed_output_dev_register(&iphone_vibrator_dev);
+}
+
+static void __exit iphone_vibrator_exit(void)
+{
+	timed_output_dev_unregister(&iphone_vibrator_dev);
+}
+
+module_init(iphone_vibrator_init);
+module_exit(iphone_vibrator_exit);
+
+MODULE_AUTHOR("Patrick Wildt <webmaster@patrick-wildt.de>");
+MODULE_DESCRIPTION("iPhone 3G Vibrator Driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/drivers/misc/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/misc/Kconfig
--- linux-2.6.32-orig/drivers/misc/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/misc/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -13,6 +13,10 @@
 
 if MISC_DEVICES
 
+config ANDROID_PMEM
+	bool "Android pmem allocator"
+	default y
+
 config ATMEL_PWM
 	tristate "Atmel AT32/AT91 PWM support"
 	depends on AVR32 || ARCH_AT91SAM9263 || ARCH_AT91SAM9RL || ARCH_AT91CAP9
@@ -138,6 +142,10 @@
 	  This driver can also be built as a module. If so, the module
 	  will be called ics932s401.
 
+config IPHONE_3G_VIBRATOR
+	tristate "iPhone 3G Vibrator"
+	depends on IPHONE_3G
+
 config ATMEL_SSC
 	tristate "Device driver for Atmel SSC peripheral"
 	depends on AVR32 || ARCH_AT91
@@ -159,6 +167,13 @@
 	  driver (SCSI/ATA) which supports enclosures
 	  or a SCSI enclosure device (SES) to use these services.
 
+config KERNEL_DEBUGGER_CORE
+	bool "Kernel Debugger Core"
+	default n
+	---help---
+	  Generic kernel debugging command processor used by low level
+	  (interrupt context) platform-specific debuggers.
+
 config SGI_XP
 	tristate "Support communication between SGI SSIs"
 	depends on NET
@@ -246,6 +261,33 @@
 	  To compile this driver as a module, choose M here: the module will
 	  be called ep93xx_pwm.
 
+config UID_STAT
+	bool "UID based statistics tracking exported to /proc/uid_stat"
+	default n
+
+config WL127X_RFKILL
+	tristate "Bluetooth power control driver for TI wl127x"
+	depends on RFKILL
+	default n
+	---help---
+	 Creates an rfkill entry in sysfs for power control of Bluetooth
+	 TI wl127x chips.
+
+config APANIC
+	bool "Android kernel panic diagnostics driver"
+	default n
+	---help---
+	 Driver which handles kernel panics and attempts to write
+	 critical debugging data to flash.
+
+config APANIC_PLABEL
+	string "Android panic dump flash partition label"
+	depends on APANIC
+	default "kpanic"
+	---help---
+	 If your platform uses a different flash partition label for storing
+ 	 crashdumps, enter it here.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff -Nur linux-2.6.32-orig/drivers/misc/kernel_debugger.c iDroid-Project-kernel_common-9e90fd2/drivers/misc/kernel_debugger.c
--- linux-2.6.32-orig/drivers/misc/kernel_debugger.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/misc/kernel_debugger.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,79 @@
+/* drivers/android/kernel_debugger.c
+ *
+ * Guts of the kernel debugger.
+ * Needs something to actually push commands to it.
+ *
+ * Copyright (C) 2007-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/ctype.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/sysrq.h>
+#include <linux/kernel_debugger.h>
+
+#define dprintf(fmt...) (ctxt->printf(ctxt->cookie, fmt))
+
+static void do_ps(struct kdbg_ctxt *ctxt)
+{
+	struct task_struct *g, *p;
+	unsigned state;
+	static const char stat_nam[] = "RSDTtZX";
+
+	dprintf("pid   ppid  prio task            pc\n");
+	read_lock(&tasklist_lock);
+	do_each_thread(g, p) {
+		state = p->state ? __ffs(p->state) + 1 : 0;
+		dprintf("%5d %5d %4d ", p->pid, p->parent->pid, p->prio);
+		dprintf("%-13.13s %c", p->comm,
+			state >= sizeof(stat_nam) ? '?' : stat_nam[state]);
+		if (state == TASK_RUNNING)
+			dprintf(" running\n");
+		else
+			dprintf(" %08lx\n", thread_saved_pc(p));
+	} while_each_thread(g, p);
+	read_unlock(&tasklist_lock);
+}
+
+int log_buf_copy(char *dest, int idx, int len);
+extern int do_syslog(int type, char __user *bug, int count);
+static void do_sysrq(struct kdbg_ctxt *ctxt, char rq)
+{
+	char buf[128];
+	int ret;
+	int idx = 0;
+	do_syslog(5 /* clear */, NULL, 0);
+	__handle_sysrq(rq, NULL, 0);
+	while (1) {
+		ret = log_buf_copy(buf, idx, sizeof(buf) - 1);
+		if (ret <= 0)
+			break;
+		buf[ret] = 0;
+		dprintf("%s", buf);
+		idx += ret;
+	}
+}
+
+int kernel_debugger(struct kdbg_ctxt *ctxt, char *cmd)
+{
+	if (!strcmp(cmd, "ps"))
+		do_ps(ctxt);
+	if (!strcmp(cmd, "sysrq"))
+		do_sysrq(ctxt, 'h');
+	if (!strncmp(cmd, "sysrq ", 6))
+		do_sysrq(ctxt, cmd[6]);
+
+	return 0;
+}
+
diff -Nur linux-2.6.32-orig/drivers/misc/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/misc/Makefile
--- linux-2.6.32-orig/drivers/misc/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/misc/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -12,14 +12,20 @@
 obj-$(CONFIG_TIFM_CORE)       	+= tifm_core.o
 obj-$(CONFIG_TIFM_7XX1)       	+= tifm_7xx1.o
 obj-$(CONFIG_PHANTOM)		+= phantom.o
+obj-$(CONFIG_ANDROID_PMEM)	+= pmem.o
 obj-$(CONFIG_SGI_IOC4)		+= ioc4.o
 obj-$(CONFIG_ENCLOSURE_SERVICES) += enclosure.o
+obj-$(CONFIG_KERNEL_DEBUGGER_CORE)	+= kernel_debugger.o
 obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
 obj-$(CONFIG_SGI_XP)		+= sgi-xp/
 obj-$(CONFIG_SGI_GRU)		+= sgi-gru/
 obj-$(CONFIG_HP_ILO)		+= hpilo.o
 obj-$(CONFIG_ISL29003)		+= isl29003.o
 obj-$(CONFIG_EP93XX_PWM)	+= ep93xx_pwm.o
+obj-$(CONFIG_UID_STAT)		+= uid_stat.o
 obj-$(CONFIG_C2PORT)		+= c2port/
 obj-y				+= eeprom/
 obj-y				+= cb710/
+obj-$(CONFIG_WL127X_RFKILL)	+= wl127x-rfkill.o
+obj-$(CONFIG_APANIC)		+= apanic.o
+obj-$(CONFIG_IPHONE_3G_VIBRATOR)	+= iphone3g-vibrator.o
diff -Nur linux-2.6.32-orig/drivers/misc/pmem.c iDroid-Project-kernel_common-9e90fd2/drivers/misc/pmem.c
--- linux-2.6.32-orig/drivers/misc/pmem.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/misc/pmem.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,1345 @@
+/* drivers/android/pmem.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/list.h>
+#include <linux/debugfs.h>
+#include <linux/android_pmem.h>
+#include <linux/mempolicy.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/cacheflush.h>
+
+#define PMEM_MAX_DEVICES 10
+#define PMEM_MAX_ORDER 128
+#define PMEM_MIN_ALLOC PAGE_SIZE
+
+#define PMEM_DEBUG 1
+
+/* indicates that a refernce to this file has been taken via get_pmem_file,
+ * the file should not be released until put_pmem_file is called */
+#define PMEM_FLAGS_BUSY 0x1
+/* indicates that this is a suballocation of a larger master range */
+#define PMEM_FLAGS_CONNECTED 0x1 << 1
+/* indicates this is a master and not a sub allocation and that it is mmaped */
+#define PMEM_FLAGS_MASTERMAP 0x1 << 2
+/* submap and unsubmap flags indicate:
+ * 00: subregion has never been mmaped
+ * 10: subregion has been mmaped, reference to the mm was taken
+ * 11: subretion has ben released, refernece to the mm still held
+ * 01: subretion has been released, reference to the mm has been released
+ */
+#define PMEM_FLAGS_SUBMAP 0x1 << 3
+#define PMEM_FLAGS_UNSUBMAP 0x1 << 4
+
+
+struct pmem_data {
+	/* in alloc mode: an index into the bitmap
+	 * in no_alloc mode: the size of the allocation */
+	int index;
+	/* see flags above for descriptions */
+	unsigned int flags;
+	/* protects this data field, if the mm_mmap sem will be held at the
+	 * same time as this sem, the mm sem must be taken first (as this is
+	 * the order for vma_open and vma_close ops */
+	struct rw_semaphore sem;
+	/* info about the mmaping process */
+	struct vm_area_struct *vma;
+	/* task struct of the mapping process */
+	struct task_struct *task;
+	/* process id of teh mapping process */
+	pid_t pid;
+	/* file descriptor of the master */
+	int master_fd;
+	/* file struct of the master */
+	struct file *master_file;
+	/* a list of currently available regions if this is a suballocation */
+	struct list_head region_list;
+	/* a linked list of data so we can access them for debugging */
+	struct list_head list;
+#if PMEM_DEBUG
+	int ref;
+#endif
+};
+
+struct pmem_bits {
+	unsigned allocated:1;		/* 1 if allocated, 0 if free */
+	unsigned order:7;		/* size of the region in pmem space */
+};
+
+struct pmem_region_node {
+	struct pmem_region region;
+	struct list_head list;
+};
+
+#define PMEM_DEBUG_MSGS 0
+#if PMEM_DEBUG_MSGS
+#define DLOG(fmt,args...) \
+	do { printk(KERN_INFO "[%s:%s:%d] "fmt, __FILE__, __func__, __LINE__, \
+		    ##args); } \
+	while (0)
+#else
+#define DLOG(x...) do {} while (0)
+#endif
+
+struct pmem_info {
+	struct miscdevice dev;
+	/* physical start address of the remaped pmem space */
+	unsigned long base;
+	/* vitual start address of the remaped pmem space */
+	unsigned char __iomem *vbase;
+	/* total size of the pmem space */
+	unsigned long size;
+	/* number of entries in the pmem space */
+	unsigned long num_entries;
+	/* pfn of the garbage page in memory */
+	unsigned long garbage_pfn;
+	/* index of the garbage page in the pmem space */
+	int garbage_index;
+	/* the bitmap for the region indicating which entries are allocated
+	 * and which are free */
+	struct pmem_bits *bitmap;
+	/* indicates the region should not be managed with an allocator */
+	unsigned no_allocator;
+	/* indicates maps of this region should be cached, if a mix of
+	 * cached and uncached is desired, set this and open the device with
+	 * O_SYNC to get an uncached region */
+	unsigned cached;
+	unsigned buffered;
+	/* in no_allocator mode the first mapper gets the whole space and sets
+	 * this flag */
+	unsigned allocated;
+	/* for debugging, creates a list of pmem file structs, the
+	 * data_list_sem should be taken before pmem_data->sem if both are
+	 * needed */
+	struct semaphore data_list_sem;
+	struct list_head data_list;
+	/* pmem_sem protects the bitmap array
+	 * a write lock should be held when modifying entries in bitmap
+	 * a read lock should be held when reading data from bits or
+	 * dereferencing a pointer into bitmap
+	 *
+	 * pmem_data->sem protects the pmem data of a particular file
+	 * Many of the function that require the pmem_data->sem have a non-
+	 * locking version for when the caller is already holding that sem.
+	 *
+	 * IF YOU TAKE BOTH LOCKS TAKE THEM IN THIS ORDER:
+	 * down(pmem_data->sem) => down(bitmap_sem)
+	 */
+	struct rw_semaphore bitmap_sem;
+
+	long (*ioctl)(struct file *, unsigned int, unsigned long);
+	int (*release)(struct inode *, struct file *);
+};
+
+static struct pmem_info pmem[PMEM_MAX_DEVICES];
+static int id_count;
+
+#define PMEM_IS_FREE(id, index) !(pmem[id].bitmap[index].allocated)
+#define PMEM_ORDER(id, index) pmem[id].bitmap[index].order
+#define PMEM_BUDDY_INDEX(id, index) (index ^ (1 << PMEM_ORDER(id, index)))
+#define PMEM_NEXT_INDEX(id, index) (index + (1 << PMEM_ORDER(id, index)))
+#define PMEM_OFFSET(index) (index * PMEM_MIN_ALLOC)
+#define PMEM_START_ADDR(id, index) (PMEM_OFFSET(index) + pmem[id].base)
+#define PMEM_LEN(id, index) ((1 << PMEM_ORDER(id, index)) * PMEM_MIN_ALLOC)
+#define PMEM_END_ADDR(id, index) (PMEM_START_ADDR(id, index) + \
+	PMEM_LEN(id, index))
+#define PMEM_START_VADDR(id, index) (PMEM_OFFSET(id, index) + pmem[id].vbase)
+#define PMEM_END_VADDR(id, index) (PMEM_START_VADDR(id, index) + \
+	PMEM_LEN(id, index))
+#define PMEM_REVOKED(data) (data->flags & PMEM_FLAGS_REVOKED)
+#define PMEM_IS_PAGE_ALIGNED(addr) (!((addr) & (~PAGE_MASK)))
+#define PMEM_IS_SUBMAP(data) ((data->flags & PMEM_FLAGS_SUBMAP) && \
+	(!(data->flags & PMEM_FLAGS_UNSUBMAP)))
+
+static int pmem_release(struct inode *, struct file *);
+static int pmem_mmap(struct file *, struct vm_area_struct *);
+static int pmem_open(struct inode *, struct file *);
+static long pmem_ioctl(struct file *, unsigned int, unsigned long);
+
+struct file_operations pmem_fops = {
+	.release = pmem_release,
+	.mmap = pmem_mmap,
+	.open = pmem_open,
+	.unlocked_ioctl = pmem_ioctl,
+};
+
+static int get_id(struct file *file)
+{
+	return MINOR(file->f_dentry->d_inode->i_rdev);
+}
+
+int is_pmem_file(struct file *file)
+{
+	int id;
+
+	if (unlikely(!file || !file->f_dentry || !file->f_dentry->d_inode))
+		return 0;
+	id = get_id(file);
+	if (unlikely(id >= PMEM_MAX_DEVICES))
+		return 0;
+	if (unlikely(file->f_dentry->d_inode->i_rdev !=
+	     MKDEV(MISC_MAJOR, pmem[id].dev.minor)))
+		return 0;
+	return 1;
+}
+
+static int has_allocation(struct file *file)
+{
+	struct pmem_data *data;
+	/* check is_pmem_file first if not accessed via pmem_file_ops */
+
+	if (unlikely(!file->private_data))
+		return 0;
+	data = (struct pmem_data *)file->private_data;
+	if (unlikely(data->index < 0))
+		return 0;
+	return 1;
+}
+
+static int is_master_owner(struct file *file)
+{
+	struct file *master_file;
+	struct pmem_data *data;
+	int put_needed, ret = 0;
+
+	if (!is_pmem_file(file) || !has_allocation(file))
+		return 0;
+	data = (struct pmem_data *)file->private_data;
+	if (PMEM_FLAGS_MASTERMAP & data->flags)
+		return 1;
+	master_file = fget_light(data->master_fd, &put_needed);
+	if (master_file && data->master_file == master_file)
+		ret = 1;
+	fput_light(master_file, put_needed);
+	return ret;
+}
+
+static int pmem_free(int id, int index)
+{
+	/* caller should hold the write lock on pmem_sem! */
+	int buddy, curr = index;
+	DLOG("index %d\n", index);
+
+	if (pmem[id].no_allocator) {
+		pmem[id].allocated = 0;
+		return 0;
+	}
+	/* clean up the bitmap, merging any buddies */
+	pmem[id].bitmap[curr].allocated = 0;
+	/* find a slots buddy Buddy# = Slot# ^ (1 << order)
+	 * if the buddy is also free merge them
+	 * repeat until the buddy is not free or end of the bitmap is reached
+	 */
+	do {
+		buddy = PMEM_BUDDY_INDEX(id, curr);
+		if (PMEM_IS_FREE(id, buddy) &&
+				PMEM_ORDER(id, buddy) == PMEM_ORDER(id, curr)) {
+			PMEM_ORDER(id, buddy)++;
+			PMEM_ORDER(id, curr)++;
+			curr = min(buddy, curr);
+		} else {
+			break;
+		}
+	} while (curr < pmem[id].num_entries);
+
+	return 0;
+}
+
+static void pmem_revoke(struct file *file, struct pmem_data *data);
+
+static int pmem_release(struct inode *inode, struct file *file)
+{
+	struct pmem_data *data = (struct pmem_data *)file->private_data;
+	struct pmem_region_node *region_node;
+	struct list_head *elt, *elt2;
+	int id = get_id(file), ret = 0;
+
+
+	down(&pmem[id].data_list_sem);
+	/* if this file is a master, revoke all the memory in the connected
+	 *  files */
+	if (PMEM_FLAGS_MASTERMAP & data->flags) {
+		struct pmem_data *sub_data;
+		list_for_each(elt, &pmem[id].data_list) {
+			sub_data = list_entry(elt, struct pmem_data, list);
+			down_read(&sub_data->sem);
+			if (PMEM_IS_SUBMAP(sub_data) &&
+			    file == sub_data->master_file) {
+				up_read(&sub_data->sem);
+				pmem_revoke(file, sub_data);
+			}  else
+				up_read(&sub_data->sem);
+		}
+	}
+	list_del(&data->list);
+	up(&pmem[id].data_list_sem);
+
+
+	down_write(&data->sem);
+
+	/* if its not a conencted file and it has an allocation, free it */
+	if (!(PMEM_FLAGS_CONNECTED & data->flags) && has_allocation(file)) {
+		down_write(&pmem[id].bitmap_sem);
+		ret = pmem_free(id, data->index);
+		up_write(&pmem[id].bitmap_sem);
+	}
+
+	/* if this file is a submap (mapped, connected file), downref the
+	 * task struct */
+	if (PMEM_FLAGS_SUBMAP & data->flags)
+		if (data->task) {
+			put_task_struct(data->task);
+			data->task = NULL;
+		}
+
+	file->private_data = NULL;
+
+	list_for_each_safe(elt, elt2, &data->region_list) {
+		region_node = list_entry(elt, struct pmem_region_node, list);
+		list_del(elt);
+		kfree(region_node);
+	}
+	BUG_ON(!list_empty(&data->region_list));
+
+	up_write(&data->sem);
+	kfree(data);
+	if (pmem[id].release)
+		ret = pmem[id].release(inode, file);
+
+	return ret;
+}
+
+static int pmem_open(struct inode *inode, struct file *file)
+{
+	struct pmem_data *data;
+	int id = get_id(file);
+	int ret = 0;
+
+	DLOG("current %u file %p(%d)\n", current->pid, file, file_count(file));
+	/* setup file->private_data to indicate its unmapped */
+	/*  you can only open a pmem device one time */
+	if (file->private_data != NULL)
+		return -1;
+	data = kmalloc(sizeof(struct pmem_data), GFP_KERNEL);
+	if (!data) {
+		printk("pmem: unable to allocate memory for pmem metadata.");
+		return -1;
+	}
+	data->flags = 0;
+	data->index = -1;
+	data->task = NULL;
+	data->vma = NULL;
+	data->pid = 0;
+	data->master_file = NULL;
+#if PMEM_DEBUG
+	data->ref = 0;
+#endif
+	INIT_LIST_HEAD(&data->region_list);
+	init_rwsem(&data->sem);
+
+	file->private_data = data;
+	INIT_LIST_HEAD(&data->list);
+
+	down(&pmem[id].data_list_sem);
+	list_add(&data->list, &pmem[id].data_list);
+	up(&pmem[id].data_list_sem);
+	return ret;
+}
+
+static unsigned long pmem_order(unsigned long len)
+{
+	int i;
+
+	len = (len + PMEM_MIN_ALLOC - 1)/PMEM_MIN_ALLOC;
+	len--;
+	for (i = 0; i < sizeof(len)*8; i++)
+		if (len >> i == 0)
+			break;
+	return i;
+}
+
+static int pmem_allocate(int id, unsigned long len)
+{
+	/* caller should hold the write lock on pmem_sem! */
+	/* return the corresponding pdata[] entry */
+	int curr = 0;
+	int end = pmem[id].num_entries;
+	int best_fit = -1;
+	unsigned long order = pmem_order(len);
+
+	if (pmem[id].no_allocator) {
+		DLOG("no allocator");
+		if ((len > pmem[id].size) || pmem[id].allocated)
+			return -1;
+		pmem[id].allocated = 1;
+		return len;
+	}
+
+	if (order > PMEM_MAX_ORDER)
+		return -1;
+	DLOG("order %lx\n", order);
+
+	/* look through the bitmap:
+	 * 	if you find a free slot of the correct order use it
+	 * 	otherwise, use the best fit (smallest with size > order) slot
+	 */
+	while (curr < end) {
+		if (PMEM_IS_FREE(id, curr)) {
+			if (PMEM_ORDER(id, curr) == (unsigned char)order) {
+				/* set the not free bit and clear others */
+				best_fit = curr;
+				break;
+			}
+			if (PMEM_ORDER(id, curr) > (unsigned char)order &&
+			    (best_fit < 0 ||
+			     PMEM_ORDER(id, curr) < PMEM_ORDER(id, best_fit)))
+				best_fit = curr;
+		}
+		curr = PMEM_NEXT_INDEX(id, curr);
+	}
+
+	/* if best_fit < 0, there are no suitable slots,
+	 * return an error
+	 */
+	if (best_fit < 0) {
+		printk("pmem: no space left to allocate!\n");
+		return -1;
+	}
+
+	/* now partition the best fit:
+	 * 	split the slot into 2 buddies of order - 1
+	 * 	repeat until the slot is of the correct order
+	 */
+	while (PMEM_ORDER(id, best_fit) > (unsigned char)order) {
+		int buddy;
+		PMEM_ORDER(id, best_fit) -= 1;
+		buddy = PMEM_BUDDY_INDEX(id, best_fit);
+		PMEM_ORDER(id, buddy) = PMEM_ORDER(id, best_fit);
+	}
+	pmem[id].bitmap[best_fit].allocated = 1;
+	return best_fit;
+}
+
+static pgprot_t phys_mem_access_prot(struct file *file, pgprot_t vma_prot)
+{
+	int id = get_id(file);
+#ifdef pgprot_noncached
+	if (pmem[id].cached == 0 || file->f_flags & O_SYNC)
+		return pgprot_noncached(vma_prot);
+#endif
+#ifdef pgprot_ext_buffered
+	else if (pmem[id].buffered)
+		return pgprot_ext_buffered(vma_prot);
+#endif
+	return vma_prot;
+}
+
+static unsigned long pmem_start_addr(int id, struct pmem_data *data)
+{
+	if (pmem[id].no_allocator)
+		return PMEM_START_ADDR(id, 0);
+	else
+		return PMEM_START_ADDR(id, data->index);
+
+}
+
+static void *pmem_start_vaddr(int id, struct pmem_data *data)
+{
+	return pmem_start_addr(id, data) - pmem[id].base + pmem[id].vbase;
+}
+
+static unsigned long pmem_len(int id, struct pmem_data *data)
+{
+	if (pmem[id].no_allocator)
+		return data->index;
+	else
+		return PMEM_LEN(id, data->index);
+}
+
+static int pmem_map_garbage(int id, struct vm_area_struct *vma,
+			    struct pmem_data *data, unsigned long offset,
+			    unsigned long len)
+{
+	int i, garbage_pages = len >> PAGE_SHIFT;
+
+	vma->vm_flags |= VM_IO | VM_RESERVED | VM_PFNMAP | VM_SHARED | VM_WRITE;
+	for (i = 0; i < garbage_pages; i++) {
+		if (vm_insert_pfn(vma, vma->vm_start + offset + (i * PAGE_SIZE),
+		    pmem[id].garbage_pfn))
+			return -EAGAIN;
+	}
+	return 0;
+}
+
+static int pmem_unmap_pfn_range(int id, struct vm_area_struct *vma,
+				struct pmem_data *data, unsigned long offset,
+				unsigned long len)
+{
+	int garbage_pages;
+	DLOG("unmap offset %lx len %lx\n", offset, len);
+
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(len));
+
+	garbage_pages = len >> PAGE_SHIFT;
+	zap_page_range(vma, vma->vm_start + offset, len, NULL);
+	pmem_map_garbage(id, vma, data, offset, len);
+	return 0;
+}
+
+static int pmem_map_pfn_range(int id, struct vm_area_struct *vma,
+			      struct pmem_data *data, unsigned long offset,
+			      unsigned long len)
+{
+	DLOG("map offset %lx len %lx\n", offset, len);
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(vma->vm_start));
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(vma->vm_end));
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(len));
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(offset));
+
+	if (io_remap_pfn_range(vma, vma->vm_start + offset,
+		(pmem_start_addr(id, data) + offset) >> PAGE_SHIFT,
+		len, vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static int pmem_remap_pfn_range(int id, struct vm_area_struct *vma,
+			      struct pmem_data *data, unsigned long offset,
+			      unsigned long len)
+{
+	/* hold the mm semp for the vma you are modifying when you call this */
+	BUG_ON(!vma);
+	zap_page_range(vma, vma->vm_start + offset, len, NULL);
+	return pmem_map_pfn_range(id, vma, data, offset, len);
+}
+
+static void pmem_vma_open(struct vm_area_struct *vma)
+{
+	struct file *file = vma->vm_file;
+	struct pmem_data *data = file->private_data;
+	int id = get_id(file);
+	/* this should never be called as we don't support copying pmem
+	 * ranges via fork */
+	BUG_ON(!has_allocation(file));
+	down_write(&data->sem);
+	/* remap the garbage pages, forkers don't get access to the data */
+	pmem_unmap_pfn_range(id, vma, data, 0, vma->vm_start - vma->vm_end);
+	up_write(&data->sem);
+}
+
+static void pmem_vma_close(struct vm_area_struct *vma)
+{
+	struct file *file = vma->vm_file;
+	struct pmem_data *data = file->private_data;
+
+	DLOG("current %u ppid %u file %p count %d\n", current->pid,
+	     current->parent->pid, file, file_count(file));
+	if (unlikely(!is_pmem_file(file) || !has_allocation(file))) {
+		printk(KERN_WARNING "pmem: something is very wrong, you are "
+		       "closing a vm backing an allocation that doesn't "
+		       "exist!\n");
+		return;
+	}
+	down_write(&data->sem);
+	if (data->vma == vma) {
+		data->vma = NULL;
+		if ((data->flags & PMEM_FLAGS_CONNECTED) &&
+		    (data->flags & PMEM_FLAGS_SUBMAP))
+			data->flags |= PMEM_FLAGS_UNSUBMAP;
+	}
+	/* the kernel is going to free this vma now anyway */
+	up_write(&data->sem);
+}
+
+static struct vm_operations_struct vm_ops = {
+	.open = pmem_vma_open,
+	.close = pmem_vma_close,
+};
+
+static int pmem_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct pmem_data *data;
+	int index;
+	unsigned long vma_size =  vma->vm_end - vma->vm_start;
+	int ret = 0, id = get_id(file);
+
+	if (vma->vm_pgoff || !PMEM_IS_PAGE_ALIGNED(vma_size)) {
+#if PMEM_DEBUG
+		printk(KERN_ERR "pmem: mmaps must be at offset zero, aligned"
+				" and a multiple of pages_size.\n");
+#endif
+		return -EINVAL;
+	}
+
+	data = (struct pmem_data *)file->private_data;
+	down_write(&data->sem);
+	/* check this file isn't already mmaped, for submaps check this file
+	 * has never been mmaped */
+	if ((data->flags & PMEM_FLAGS_MASTERMAP) ||
+	    (data->flags & PMEM_FLAGS_SUBMAP) ||
+	    (data->flags & PMEM_FLAGS_UNSUBMAP)) {
+#if PMEM_DEBUG
+		printk(KERN_ERR "pmem: you can only mmap a pmem file once, "
+		       "this file is already mmaped. %x\n", data->flags);
+#endif
+		ret = -EINVAL;
+		goto error;
+	}
+	/* if file->private_data == unalloced, alloc*/
+	if (data && data->index == -1) {
+		down_write(&pmem[id].bitmap_sem);
+		index = pmem_allocate(id, vma->vm_end - vma->vm_start);
+		up_write(&pmem[id].bitmap_sem);
+		data->index = index;
+	}
+	/* either no space was available or an error occured */
+	if (!has_allocation(file)) {
+		ret = -EINVAL;
+		printk("pmem: could not find allocation for map.\n");
+		goto error;
+	}
+
+	if (pmem_len(id, data) < vma_size) {
+#if PMEM_DEBUG
+		printk(KERN_WARNING "pmem: mmap size [%lu] does not match"
+		       "size of backing region [%lu].\n", vma_size,
+		       pmem_len(id, data));
+#endif
+		ret = -EINVAL;
+		goto error;
+	}
+
+	vma->vm_pgoff = pmem_start_addr(id, data) >> PAGE_SHIFT;
+	vma->vm_page_prot = phys_mem_access_prot(file, vma->vm_page_prot);
+
+	if (data->flags & PMEM_FLAGS_CONNECTED) {
+		struct pmem_region_node *region_node;
+		struct list_head *elt;
+		if (pmem_map_garbage(id, vma, data, 0, vma_size)) {
+			printk("pmem: mmap failed in kernel!\n");
+			ret = -EAGAIN;
+			goto error;
+		}
+		list_for_each(elt, &data->region_list) {
+			region_node = list_entry(elt, struct pmem_region_node,
+						 list);
+			DLOG("remapping file: %p %lx %lx\n", file,
+				region_node->region.offset,
+				region_node->region.len);
+			if (pmem_remap_pfn_range(id, vma, data,
+						 region_node->region.offset,
+						 region_node->region.len)) {
+				ret = -EAGAIN;
+				goto error;
+			}
+		}
+		data->flags |= PMEM_FLAGS_SUBMAP;
+		get_task_struct(current->group_leader);
+		data->task = current->group_leader;
+		data->vma = vma;
+#if PMEM_DEBUG
+		data->pid = current->pid;
+#endif
+		DLOG("submmapped file %p vma %p pid %u\n", file, vma,
+		     current->pid);
+	} else {
+		if (pmem_map_pfn_range(id, vma, data, 0, vma_size)) {
+			printk(KERN_INFO "pmem: mmap failed in kernel!\n");
+			ret = -EAGAIN;
+			goto error;
+		}
+		data->flags |= PMEM_FLAGS_MASTERMAP;
+		data->pid = current->pid;
+	}
+	vma->vm_ops = &vm_ops;
+error:
+	up_write(&data->sem);
+	return ret;
+}
+
+/* the following are the api for accessing pmem regions by other drivers
+ * from inside the kernel */
+int get_pmem_user_addr(struct file *file, unsigned long *start,
+		   unsigned long *len)
+{
+	struct pmem_data *data;
+	if (!is_pmem_file(file) || !has_allocation(file)) {
+#if PMEM_DEBUG
+		printk(KERN_INFO "pmem: requested pmem data from invalid"
+				  "file.\n");
+#endif
+		return -1;
+	}
+	data = (struct pmem_data *)file->private_data;
+	down_read(&data->sem);
+	if (data->vma) {
+		*start = data->vma->vm_start;
+		*len = data->vma->vm_end - data->vma->vm_start;
+	} else {
+		*start = 0;
+		*len = 0;
+	}
+	up_read(&data->sem);
+	return 0;
+}
+
+int get_pmem_addr(struct file *file, unsigned long *start,
+		  unsigned long *vstart, unsigned long *len)
+{
+	struct pmem_data *data;
+	int id;
+
+	if (!is_pmem_file(file) || !has_allocation(file)) {
+		return -1;
+	}
+
+	data = (struct pmem_data *)file->private_data;
+	if (data->index == -1) {
+#if PMEM_DEBUG
+		printk(KERN_INFO "pmem: requested pmem data from file with no "
+		       "allocation.\n");
+		return -1;
+#endif
+	}
+	id = get_id(file);
+
+	down_read(&data->sem);
+	*start = pmem_start_addr(id, data);
+	*len = pmem_len(id, data);
+	*vstart = (unsigned long)pmem_start_vaddr(id, data);
+	up_read(&data->sem);
+#if PMEM_DEBUG
+	down_write(&data->sem);
+	data->ref++;
+	up_write(&data->sem);
+#endif
+	return 0;
+}
+
+int get_pmem_file(int fd, unsigned long *start, unsigned long *vstart,
+		  unsigned long *len, struct file **filp)
+{
+	struct file *file;
+
+	file = fget(fd);
+	if (unlikely(file == NULL)) {
+		printk(KERN_INFO "pmem: requested data from file descriptor "
+		       "that doesn't exist.");
+		return -1;
+	}
+
+	if (get_pmem_addr(file, start, vstart, len))
+		goto end;
+
+	if (filp)
+		*filp = file;
+	return 0;
+end:
+	fput(file);
+	return -1;
+}
+
+void put_pmem_file(struct file *file)
+{
+	struct pmem_data *data;
+	int id;
+
+	if (!is_pmem_file(file))
+		return;
+	id = get_id(file);
+	data = (struct pmem_data *)file->private_data;
+#if PMEM_DEBUG
+	down_write(&data->sem);
+	if (data->ref == 0) {
+		printk("pmem: pmem_put > pmem_get %s (pid %d)\n",
+		       pmem[id].dev.name, data->pid);
+		BUG();
+	}
+	data->ref--;
+	up_write(&data->sem);
+#endif
+	fput(file);
+}
+
+void flush_pmem_file(struct file *file, unsigned long offset, unsigned long len)
+{
+	struct pmem_data *data;
+	int id;
+	void *vaddr;
+	struct pmem_region_node *region_node;
+	struct list_head *elt;
+	void *flush_start, *flush_end;
+
+	if (!is_pmem_file(file) || !has_allocation(file)) {
+		return;
+	}
+
+	id = get_id(file);
+	data = (struct pmem_data *)file->private_data;
+	if (!pmem[id].cached || file->f_flags & O_SYNC)
+		return;
+
+	down_read(&data->sem);
+	vaddr = pmem_start_vaddr(id, data);
+	/* if this isn't a submmapped file, flush the whole thing */
+	if (unlikely(!(data->flags & PMEM_FLAGS_CONNECTED))) {
+		dmac_flush_range(vaddr, vaddr + pmem_len(id, data));
+		goto end;
+	}
+	/* otherwise, flush the region of the file we are drawing */
+	list_for_each(elt, &data->region_list) {
+		region_node = list_entry(elt, struct pmem_region_node, list);
+		if ((offset >= region_node->region.offset) &&
+		    ((offset + len) <= (region_node->region.offset +
+			region_node->region.len))) {
+			flush_start = vaddr + region_node->region.offset;
+			flush_end = flush_start + region_node->region.len;
+			dmac_flush_range(flush_start, flush_end);
+			break;
+		}
+	}
+end:
+	up_read(&data->sem);
+}
+
+static int pmem_connect(unsigned long connect, struct file *file)
+{
+	struct pmem_data *data = (struct pmem_data *)file->private_data;
+	struct pmem_data *src_data;
+	struct file *src_file;
+	int ret = 0, put_needed;
+
+	down_write(&data->sem);
+	/* retrieve the src file and check it is a pmem file with an alloc */
+	src_file = fget_light(connect, &put_needed);
+	DLOG("connect %p to %p\n", file, src_file);
+	if (!src_file) {
+		printk("pmem: src file not found!\n");
+		ret = -EINVAL;
+		goto err_no_file;
+	}
+	if (unlikely(!is_pmem_file(src_file) || !has_allocation(src_file))) {
+		printk(KERN_INFO "pmem: src file is not a pmem file or has no "
+		       "alloc!\n");
+		ret = -EINVAL;
+		goto err_bad_file;
+	}
+	src_data = (struct pmem_data *)src_file->private_data;
+
+	if (has_allocation(file) && (data->index != src_data->index)) {
+		printk("pmem: file is already mapped but doesn't match this"
+		       " src_file!\n");
+		ret = -EINVAL;
+		goto err_bad_file;
+	}
+	data->index = src_data->index;
+	data->flags |= PMEM_FLAGS_CONNECTED;
+	data->master_fd = connect;
+	data->master_file = src_file;
+
+err_bad_file:
+	fput_light(src_file, put_needed);
+err_no_file:
+	up_write(&data->sem);
+	return ret;
+}
+
+static void pmem_unlock_data_and_mm(struct pmem_data *data,
+				    struct mm_struct *mm)
+{
+	up_write(&data->sem);
+	if (mm != NULL) {
+		up_write(&mm->mmap_sem);
+		mmput(mm);
+	}
+}
+
+static int pmem_lock_data_and_mm(struct file *file, struct pmem_data *data,
+				 struct mm_struct **locked_mm)
+{
+	int ret = 0;
+	struct mm_struct *mm = NULL;
+	*locked_mm = NULL;
+lock_mm:
+	down_read(&data->sem);
+	if (PMEM_IS_SUBMAP(data)) {
+		mm = get_task_mm(data->task);
+		if (!mm) {
+#if PMEM_DEBUG
+			printk("pmem: can't remap task is gone!\n");
+#endif
+			up_read(&data->sem);
+			return -1;
+		}
+	}
+	up_read(&data->sem);
+
+	if (mm)
+		down_write(&mm->mmap_sem);
+
+	down_write(&data->sem);
+	/* check that the file didn't get mmaped before we could take the
+	 * data sem, this should be safe b/c you can only submap each file
+	 * once */
+	if (PMEM_IS_SUBMAP(data) && !mm) {
+		pmem_unlock_data_and_mm(data, mm);
+		up_write(&data->sem);
+		goto lock_mm;
+	}
+	/* now check that vma.mm is still there, it could have been
+	 * deleted by vma_close before we could get the data->sem */
+	if ((data->flags & PMEM_FLAGS_UNSUBMAP) && (mm != NULL)) {
+		/* might as well release this */
+		if (data->flags & PMEM_FLAGS_SUBMAP) {
+			put_task_struct(data->task);
+			data->task = NULL;
+			/* lower the submap flag to show the mm is gone */
+			data->flags &= ~(PMEM_FLAGS_SUBMAP);
+		}
+		pmem_unlock_data_and_mm(data, mm);
+		return -1;
+	}
+	*locked_mm = mm;
+	return ret;
+}
+
+int pmem_remap(struct pmem_region *region, struct file *file,
+		      unsigned operation)
+{
+	int ret;
+	struct pmem_region_node *region_node;
+	struct mm_struct *mm = NULL;
+	struct list_head *elt, *elt2;
+	int id = get_id(file);
+	struct pmem_data *data = (struct pmem_data *)file->private_data;
+
+	/* pmem region must be aligned on a page boundry */
+	if (unlikely(!PMEM_IS_PAGE_ALIGNED(region->offset) ||
+		 !PMEM_IS_PAGE_ALIGNED(region->len))) {
+#if PMEM_DEBUG
+		printk("pmem: request for unaligned pmem suballocation "
+		       "%lx %lx\n", region->offset, region->len);
+#endif
+		return -EINVAL;
+	}
+
+	/* if userspace requests a region of len 0, there's nothing to do */
+	if (region->len == 0)
+		return 0;
+
+	/* lock the mm and data */
+	ret = pmem_lock_data_and_mm(file, data, &mm);
+	if (ret)
+		return 0;
+
+	/* only the owner of the master file can remap the client fds
+	 * that back in it */
+	if (!is_master_owner(file)) {
+#if PMEM_DEBUG
+		printk("pmem: remap requested from non-master process\n");
+#endif
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/* check that the requested range is within the src allocation */
+	if (unlikely((region->offset > pmem_len(id, data)) ||
+		     (region->len > pmem_len(id, data)) ||
+		     (region->offset + region->len > pmem_len(id, data)))) {
+#if PMEM_DEBUG
+		printk(KERN_INFO "pmem: suballoc doesn't fit in src_file!\n");
+#endif
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (operation == PMEM_MAP) {
+		region_node = kmalloc(sizeof(struct pmem_region_node),
+			      GFP_KERNEL);
+		if (!region_node) {
+			ret = -ENOMEM;
+#if PMEM_DEBUG
+			printk(KERN_INFO "No space to allocate metadata!");
+#endif
+			goto err;
+		}
+		region_node->region = *region;
+		list_add(&region_node->list, &data->region_list);
+	} else if (operation == PMEM_UNMAP) {
+		int found = 0;
+		list_for_each_safe(elt, elt2, &data->region_list) {
+			region_node = list_entry(elt, struct pmem_region_node,
+				      list);
+			if (region->len == 0 ||
+			    (region_node->region.offset == region->offset &&
+			    region_node->region.len == region->len)) {
+				list_del(elt);
+				kfree(region_node);
+				found = 1;
+			}
+		}
+		if (!found) {
+#if PMEM_DEBUG
+			printk("pmem: Unmap region does not map any mapped "
+				"region!");
+#endif
+			ret = -EINVAL;
+			goto err;
+		}
+	}
+
+	if (data->vma && PMEM_IS_SUBMAP(data)) {
+		if (operation == PMEM_MAP)
+			ret = pmem_remap_pfn_range(id, data->vma, data,
+						   region->offset, region->len);
+		else if (operation == PMEM_UNMAP)
+			ret = pmem_unmap_pfn_range(id, data->vma, data,
+						   region->offset, region->len);
+	}
+
+err:
+	pmem_unlock_data_and_mm(data, mm);
+	return ret;
+}
+
+static void pmem_revoke(struct file *file, struct pmem_data *data)
+{
+	struct pmem_region_node *region_node;
+	struct list_head *elt, *elt2;
+	struct mm_struct *mm = NULL;
+	int id = get_id(file);
+	int ret = 0;
+
+	data->master_file = NULL;
+	ret = pmem_lock_data_and_mm(file, data, &mm);
+	/* if lock_data_and_mm fails either the task that mapped the fd, or
+	 * the vma that mapped it have already gone away, nothing more
+	 * needs to be done */
+	if (ret)
+		return;
+	/* unmap everything */
+	/* delete the regions and region list nothing is mapped any more */
+	if (data->vma)
+		list_for_each_safe(elt, elt2, &data->region_list) {
+			region_node = list_entry(elt, struct pmem_region_node,
+						 list);
+			pmem_unmap_pfn_range(id, data->vma, data,
+					     region_node->region.offset,
+					     region_node->region.len);
+			list_del(elt);
+			kfree(region_node);
+	}
+	/* delete the master file */
+	pmem_unlock_data_and_mm(data, mm);
+}
+
+static void pmem_get_size(struct pmem_region *region, struct file *file)
+{
+	struct pmem_data *data = (struct pmem_data *)file->private_data;
+	int id = get_id(file);
+
+	if (!has_allocation(file)) {
+		region->offset = 0;
+		region->len = 0;
+		return;
+	} else {
+		region->offset = pmem_start_addr(id, data);
+		region->len = pmem_len(id, data);
+	}
+	DLOG("offset %lx len %lx\n", region->offset, region->len);
+}
+
+
+static long pmem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct pmem_data *data;
+	int id = get_id(file);
+
+	switch (cmd) {
+	case PMEM_GET_PHYS:
+		{
+			struct pmem_region region;
+			DLOG("get_phys\n");
+			if (!has_allocation(file)) {
+				region.offset = 0;
+				region.len = 0;
+			} else {
+				data = (struct pmem_data *)file->private_data;
+				region.offset = pmem_start_addr(id, data);
+				region.len = pmem_len(id, data);
+			}
+			printk(KERN_INFO "pmem: request for physical address of pmem region "
+					"from process %d.\n", current->pid);
+			if (copy_to_user((void __user *)arg, &region,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			break;
+		}
+	case PMEM_MAP:
+		{
+			struct pmem_region region;
+			if (copy_from_user(&region, (void __user *)arg,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			data = (struct pmem_data *)file->private_data;
+			return pmem_remap(&region, file, PMEM_MAP);
+		}
+		break;
+	case PMEM_UNMAP:
+		{
+			struct pmem_region region;
+			if (copy_from_user(&region, (void __user *)arg,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			data = (struct pmem_data *)file->private_data;
+			return pmem_remap(&region, file, PMEM_UNMAP);
+			break;
+		}
+	case PMEM_GET_SIZE:
+		{
+			struct pmem_region region;
+			DLOG("get_size\n");
+			pmem_get_size(&region, file);
+			if (copy_to_user((void __user *)arg, &region,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			break;
+		}
+	case PMEM_GET_TOTAL_SIZE:
+		{
+			struct pmem_region region;
+			DLOG("get total size\n");
+			region.offset = 0;
+			get_id(file);
+			region.len = pmem[id].size;
+			if (copy_to_user((void __user *)arg, &region,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			break;
+		}
+	case PMEM_ALLOCATE:
+		{
+			if (has_allocation(file))
+				return -EINVAL;
+			data = (struct pmem_data *)file->private_data;
+			data->index = pmem_allocate(id, arg);
+			break;
+		}
+	case PMEM_CONNECT:
+		DLOG("connect\n");
+		return pmem_connect(arg, file);
+		break;
+	case PMEM_CACHE_FLUSH:
+		{
+			struct pmem_region region;
+			DLOG("flush\n");
+			if (copy_from_user(&region, (void __user *)arg,
+					   sizeof(struct pmem_region)))
+				return -EFAULT;
+			flush_pmem_file(file, region.offset, region.len);
+			break;
+		}
+	default:
+		if (pmem[id].ioctl)
+			return pmem[id].ioctl(file, cmd, arg);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+#if PMEM_DEBUG
+static ssize_t debug_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t debug_read(struct file *file, char __user *buf, size_t count,
+			  loff_t *ppos)
+{
+	struct list_head *elt, *elt2;
+	struct pmem_data *data;
+	struct pmem_region_node *region_node;
+	int id = (int)file->private_data;
+	const int debug_bufmax = 4096;
+	static char buffer[4096];
+	int n = 0;
+
+	DLOG("debug open\n");
+	n = scnprintf(buffer, debug_bufmax,
+		      "pid #: mapped regions (offset, len) (offset,len)...\n");
+
+	down(&pmem[id].data_list_sem);
+	list_for_each(elt, &pmem[id].data_list) {
+		data = list_entry(elt, struct pmem_data, list);
+		down_read(&data->sem);
+		n += scnprintf(buffer + n, debug_bufmax - n, "pid %u:",
+				data->pid);
+		list_for_each(elt2, &data->region_list) {
+			region_node = list_entry(elt2, struct pmem_region_node,
+				      list);
+			n += scnprintf(buffer + n, debug_bufmax - n,
+					"(%lx,%lx) ",
+					region_node->region.offset,
+					region_node->region.len);
+		}
+		n += scnprintf(buffer + n, debug_bufmax - n, "\n");
+		up_read(&data->sem);
+	}
+	up(&pmem[id].data_list_sem);
+
+	n++;
+	buffer[n] = 0;
+	return simple_read_from_buffer(buf, count, ppos, buffer, n);
+}
+
+static struct file_operations debug_fops = {
+	.read = debug_read,
+	.open = debug_open,
+};
+#endif
+
+#if 0
+static struct miscdevice pmem_dev = {
+	.name = "pmem",
+	.fops = &pmem_fops,
+};
+#endif
+
+int pmem_setup(struct android_pmem_platform_data *pdata,
+	       long (*ioctl)(struct file *, unsigned int, unsigned long),
+	       int (*release)(struct inode *, struct file *))
+{
+	int err = 0;
+	int i, index = 0;
+	int id = id_count;
+	id_count++;
+
+	pmem[id].no_allocator = pdata->no_allocator;
+	pmem[id].cached = pdata->cached;
+	pmem[id].buffered = pdata->buffered;
+	pmem[id].base = pdata->start;
+	pmem[id].size = pdata->size;
+	pmem[id].ioctl = ioctl;
+	pmem[id].release = release;
+	init_rwsem(&pmem[id].bitmap_sem);
+	init_MUTEX(&pmem[id].data_list_sem);
+	INIT_LIST_HEAD(&pmem[id].data_list);
+	pmem[id].dev.name = pdata->name;
+	pmem[id].dev.minor = id;
+	pmem[id].dev.fops = &pmem_fops;
+	printk(KERN_INFO "%s: %d init\n", pdata->name, pdata->cached);
+
+	err = misc_register(&pmem[id].dev);
+	if (err) {
+		printk(KERN_ALERT "Unable to register pmem driver!\n");
+		goto err_cant_register_device;
+	}
+	pmem[id].num_entries = pmem[id].size / PMEM_MIN_ALLOC;
+
+	pmem[id].bitmap = kmalloc(pmem[id].num_entries *
+				  sizeof(struct pmem_bits), GFP_KERNEL);
+	if (!pmem[id].bitmap)
+		goto err_no_mem_for_metadata;
+
+	memset(pmem[id].bitmap, 0, sizeof(struct pmem_bits) *
+					  pmem[id].num_entries);
+
+	for (i = sizeof(pmem[id].num_entries) * 8 - 1; i >= 0; i--) {
+		if ((pmem[id].num_entries) &  1<<i) {
+			PMEM_ORDER(id, index) = i;
+			index = PMEM_NEXT_INDEX(id, index);
+		}
+	}
+
+	if (pmem[id].cached)
+		pmem[id].vbase = ioremap_cached(pmem[id].base,
+						pmem[id].size);
+#ifdef ioremap_ext_buffered
+	else if (pmem[id].buffered)
+		pmem[id].vbase = ioremap_ext_buffered(pmem[id].base,
+						      pmem[id].size);
+#endif
+	else
+		pmem[id].vbase = ioremap(pmem[id].base, pmem[id].size);
+
+	if (pmem[id].vbase == 0)
+		goto error_cant_remap;
+
+	pmem[id].garbage_pfn = page_to_pfn(alloc_page(GFP_KERNEL));
+	if (pmem[id].no_allocator)
+		pmem[id].allocated = 0;
+
+#if PMEM_DEBUG
+	debugfs_create_file(pdata->name, S_IFREG | S_IRUGO, NULL, (void *)id,
+			    &debug_fops);
+#endif
+	return 0;
+error_cant_remap:
+	kfree(pmem[id].bitmap);
+err_no_mem_for_metadata:
+	misc_deregister(&pmem[id].dev);
+err_cant_register_device:
+	return -1;
+}
+
+static int pmem_probe(struct platform_device *pdev)
+{
+	struct android_pmem_platform_data *pdata;
+
+	if (!pdev || !pdev->dev.platform_data) {
+		printk(KERN_ALERT "Unable to probe pmem!\n");
+		return -1;
+	}
+	pdata = pdev->dev.platform_data;
+	return pmem_setup(pdata, NULL, NULL);
+}
+
+
+static int pmem_remove(struct platform_device *pdev)
+{
+	int id = pdev->id;
+	__free_page(pfn_to_page(pmem[id].garbage_pfn));
+	misc_deregister(&pmem[id].dev);
+	return 0;
+}
+
+static struct platform_driver pmem_driver = {
+	.probe = pmem_probe,
+	.remove = pmem_remove,
+	.driver = { .name = "android_pmem" }
+};
+
+
+static int __init pmem_init(void)
+{
+	return platform_driver_register(&pmem_driver);
+}
+
+static void __exit pmem_exit(void)
+{
+	platform_driver_unregister(&pmem_driver);
+}
+
+module_init(pmem_init);
+module_exit(pmem_exit);
+
diff -Nur linux-2.6.32-orig/drivers/misc/uid_stat.c iDroid-Project-kernel_common-9e90fd2/drivers/misc/uid_stat.c
--- linux-2.6.32-orig/drivers/misc/uid_stat.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/misc/uid_stat.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,153 @@
+/* drivers/misc/uid_stat.c
+ *
+ * Copyright (C) 2008 - 2009 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/atomic.h>
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/stat.h>
+#include <linux/uid_stat.h>
+
+static DEFINE_SPINLOCK(uid_lock);
+static LIST_HEAD(uid_list);
+static struct proc_dir_entry *parent;
+
+struct uid_stat {
+	struct list_head link;
+	uid_t uid;
+	atomic_t tcp_rcv;
+	atomic_t tcp_snd;
+};
+
+static struct uid_stat *find_uid_stat(uid_t uid) {
+	unsigned long flags;
+	struct uid_stat *entry;
+
+	spin_lock_irqsave(&uid_lock, flags);
+	list_for_each_entry(entry, &uid_list, link) {
+		if (entry->uid == uid) {
+			spin_unlock_irqrestore(&uid_lock, flags);
+			return entry;
+		}
+	}
+	spin_unlock_irqrestore(&uid_lock, flags);
+	return NULL;
+}
+
+static int tcp_snd_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	int len;
+	unsigned int bytes;
+	char *p = page;
+	struct uid_stat *uid_entry = (struct uid_stat *) data;
+	if (!data)
+		return 0;
+
+	bytes = (unsigned int) (atomic_read(&uid_entry->tcp_snd) + INT_MIN);
+	p += sprintf(p, "%u\n", bytes);
+	len = (p - page) - off;
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+	return len;
+}
+
+static int tcp_rcv_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	int len;
+	unsigned int bytes;
+	char *p = page;
+	struct uid_stat *uid_entry = (struct uid_stat *) data;
+	if (!data)
+		return 0;
+
+	bytes = (unsigned int) (atomic_read(&uid_entry->tcp_rcv) + INT_MIN);
+	p += sprintf(p, "%u\n", bytes);
+	len = (p - page) - off;
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+	return len;
+}
+
+/* Create a new entry for tracking the specified uid. */
+static struct uid_stat *create_stat(uid_t uid) {
+	unsigned long flags;
+	char uid_s[32];
+	struct uid_stat *new_uid;
+	struct proc_dir_entry *entry;
+
+	/* Create the uid stat struct and append it to the list. */
+	if ((new_uid = kmalloc(sizeof(struct uid_stat), GFP_KERNEL)) == NULL)
+		return NULL;
+
+	new_uid->uid = uid;
+	/* Counters start at INT_MIN, so we can track 4GB of network traffic. */
+	atomic_set(&new_uid->tcp_rcv, INT_MIN);
+	atomic_set(&new_uid->tcp_snd, INT_MIN);
+
+	spin_lock_irqsave(&uid_lock, flags);
+	list_add_tail(&new_uid->link, &uid_list);
+	spin_unlock_irqrestore(&uid_lock, flags);
+
+	sprintf(uid_s, "%d", uid);
+	entry = proc_mkdir(uid_s, parent);
+
+	/* Keep reference to uid_stat so we know what uid to read stats from. */
+	create_proc_read_entry("tcp_snd", S_IRUGO, entry , tcp_snd_read_proc,
+		(void *) new_uid);
+
+	create_proc_read_entry("tcp_rcv", S_IRUGO, entry, tcp_rcv_read_proc,
+		(void *) new_uid);
+
+	return new_uid;
+}
+
+int update_tcp_snd(uid_t uid, int size) {
+	struct uid_stat *entry;
+	if ((entry = find_uid_stat(uid)) == NULL &&
+		((entry = create_stat(uid)) == NULL)) {
+			return -1;
+	}
+	atomic_add(size, &entry->tcp_snd);
+	return 0;
+}
+
+int update_tcp_rcv(uid_t uid, int size) {
+	struct uid_stat *entry;
+	if ((entry = find_uid_stat(uid)) == NULL &&
+		((entry = create_stat(uid)) == NULL)) {
+			return -1;
+	}
+	atomic_add(size, &entry->tcp_rcv);
+	return 0;
+}
+
+static int __init uid_stat_init(void)
+{
+	parent = proc_mkdir("uid_stat", NULL);
+	if (!parent) {
+		pr_err("uid_stat: failed to create proc entry\n");
+		return -1;
+	}
+	return 0;
+}
+
+__initcall(uid_stat_init);
diff -Nur linux-2.6.32-orig/drivers/misc/wl127x-rfkill.c iDroid-Project-kernel_common-9e90fd2/drivers/misc/wl127x-rfkill.c
--- linux-2.6.32-orig/drivers/misc/wl127x-rfkill.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/misc/wl127x-rfkill.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,121 @@
+/*
+ * Bluetooth TI wl127x rfkill power control via GPIO
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ * Copyright (C) 2008 Texas Instruments
+ * Initial code: Pavan Savoy <pavan.savoy@gmail.com> (wl127x_power.c)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/rfkill.h>
+#include <linux/platform_device.h>
+#include <linux/wl127x-rfkill.h>
+
+static int wl127x_rfkill_set_power(void *data, enum rfkill_state state)
+{
+	int nshutdown_gpio = (int) data;
+
+	switch (state) {
+	case RFKILL_STATE_UNBLOCKED:
+		gpio_set_value(nshutdown_gpio, 1);
+		break;
+	case RFKILL_STATE_SOFT_BLOCKED:
+		gpio_set_value(nshutdown_gpio, 0);
+		break;
+	default:
+		printk(KERN_ERR "invalid bluetooth rfkill state %d\n", state);
+	}
+	return 0;
+}
+
+static int wl127x_rfkill_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+	struct wl127x_rfkill_platform_data *pdata = pdev->dev.platform_data;
+	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;  /* off */
+
+	rc = gpio_request(pdata->nshutdown_gpio, "wl127x_nshutdown_gpio");
+	if (unlikely(rc))
+		return rc;
+
+	rc = gpio_direction_output(pdata->nshutdown_gpio, 0);
+	if (unlikely(rc))
+		return rc;
+
+	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
+	wl127x_rfkill_set_power(NULL, default_state);
+
+	pdata->rfkill = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
+	if (unlikely(!pdata->rfkill))
+		return -ENOMEM;
+
+	pdata->rfkill->name = "wl127x";
+	pdata->rfkill->state = default_state;
+	/* userspace cannot take exclusive control */
+	pdata->rfkill->user_claim_unsupported = 1;
+	pdata->rfkill->user_claim = 0;
+	pdata->rfkill->data = (void *) pdata->nshutdown_gpio;
+	pdata->rfkill->toggle_radio = wl127x_rfkill_set_power;
+
+	rc = rfkill_register(pdata->rfkill);
+
+	if (unlikely(rc))
+		rfkill_free(pdata->rfkill);
+
+	return 0;
+}
+
+static int wl127x_rfkill_remove(struct platform_device *pdev)
+{
+	struct wl127x_rfkill_platform_data *pdata = pdev->dev.platform_data;
+
+	rfkill_unregister(pdata->rfkill);
+	rfkill_free(pdata->rfkill);
+	gpio_free(pdata->nshutdown_gpio);
+
+	return 0;
+}
+
+static struct platform_driver wl127x_rfkill_platform_driver = {
+	.probe = wl127x_rfkill_probe,
+	.remove = wl127x_rfkill_remove,
+	.driver = {
+		   .name = "wl127x-rfkill",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init wl127x_rfkill_init(void)
+{
+	return platform_driver_register(&wl127x_rfkill_platform_driver);
+}
+
+static void __exit wl127x_rfkill_exit(void)
+{
+	platform_driver_unregister(&wl127x_rfkill_platform_driver);
+}
+
+module_init(wl127x_rfkill_init);
+module_exit(wl127x_rfkill_exit);
+
+MODULE_ALIAS("platform:wl127x");
+MODULE_DESCRIPTION("wl127x-rfkill");
+MODULE_AUTHOR("Motorola");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/drivers/mmc/card/block.c iDroid-Project-kernel_common-9e90fd2/drivers/mmc/card/block.c
--- linux-2.6.32-orig/drivers/mmc/card/block.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mmc/card/block.c	2010-11-18 21:05:30.000000000 +0600
@@ -85,7 +85,14 @@
 	mutex_lock(&open_lock);
 	md->usage--;
 	if (md->usage == 0) {
+		int devmaj = MAJOR(disk_devt(md->disk));
 		int devidx = MINOR(disk_devt(md->disk)) >> MMC_SHIFT;
+
+		if (!devmaj)
+			devidx = md->disk->first_minor >> MMC_SHIFT;
+
+		blk_cleanup_queue(md->queue.queue);
+
 		__clear_bit(devidx, dev_use);
 
 		put_disk(md->disk);
@@ -234,6 +241,33 @@
 	return cmd.resp[0];
 }
 
+static int
+mmc_blk_set_blksize(struct mmc_blk_data *md, struct mmc_card *card)
+{
+	struct mmc_command cmd;
+	int err;
+
+	/* Block-addressed cards ignore MMC_SET_BLOCKLEN. */
+	if (mmc_card_blockaddr(card))
+		return 0;
+
+	mmc_claim_host(card->host);
+	cmd.opcode = MMC_SET_BLOCKLEN;
+	cmd.arg = 512;
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
+	err = mmc_wait_for_cmd(card->host, &cmd, 5);
+	mmc_release_host(card->host);
+
+	if (err) {
+		printk(KERN_ERR "%s: unable to set block size to %d: %d\n",
+			md->disk->disk_name, cmd.arg, err);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
 static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 {
 	struct mmc_blk_data *md = mq->data;
@@ -241,6 +275,13 @@
 	struct mmc_blk_request brq;
 	int ret = 1, disable_multi = 0;
 
+#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
+	if (mmc_bus_needs_resume(card->host)) {
+		mmc_resume_bus(card->host);
+		mmc_blk_set_blksize(md, card);
+	}
+#endif
+
 	mmc_claim_host(card->host);
 
 	do {
@@ -344,6 +385,8 @@
 				continue;
 			}
 			status = get_card_status(card, req);
+		} else if (disable_multi == 1) {
+			disable_multi = 0;
 		}
 
 		if (brq.cmd.error) {
@@ -555,32 +598,6 @@
 	return ERR_PTR(ret);
 }
 
-static int
-mmc_blk_set_blksize(struct mmc_blk_data *md, struct mmc_card *card)
-{
-	struct mmc_command cmd;
-	int err;
-
-	/* Block-addressed cards ignore MMC_SET_BLOCKLEN. */
-	if (mmc_card_blockaddr(card))
-		return 0;
-
-	mmc_claim_host(card->host);
-	cmd.opcode = MMC_SET_BLOCKLEN;
-	cmd.arg = 512;
-	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
-	err = mmc_wait_for_cmd(card->host, &cmd, 5);
-	mmc_release_host(card->host);
-
-	if (err) {
-		printk(KERN_ERR "%s: unable to set block size to %d: %d\n",
-			md->disk->disk_name, cmd.arg, err);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
 static int mmc_blk_probe(struct mmc_card *card)
 {
 	struct mmc_blk_data *md;
@@ -609,10 +626,14 @@
 		cap_str, md->read_only ? "(ro)" : "");
 
 	mmc_set_drvdata(card, md);
+#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
+	mmc_set_bus_resume_policy(card->host, 1);
+#endif
 	add_disk(md->disk);
 	return 0;
 
  out:
+	mmc_cleanup_queue(&md->queue);
 	mmc_blk_put(md);
 
 	return err;
@@ -632,6 +653,9 @@
 		mmc_blk_put(md);
 	}
 	mmc_set_drvdata(card, NULL);
+#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
+	mmc_set_bus_resume_policy(card->host, 0);
+#endif
 }
 
 #ifdef CONFIG_PM
@@ -650,7 +674,9 @@
 	struct mmc_blk_data *md = mmc_get_drvdata(card);
 
 	if (md) {
+#ifndef CONFIG_MMC_BLOCK_DEFERRED_RESUME
 		mmc_blk_set_blksize(md, card);
+#endif
 		mmc_queue_resume(&md->queue);
 	}
 	return 0;
diff -Nur linux-2.6.32-orig/drivers/mmc/card/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/mmc/card/Kconfig
--- linux-2.6.32-orig/drivers/mmc/card/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mmc/card/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -32,6 +32,15 @@
 
 	  If unsure, say Y here.
 
+config MMC_BLOCK_DEFERRED_RESUME
+	bool "Deferr MMC layer resume until I/O is requested"
+	depends on MMC_BLOCK
+	default n
+	help
+	  Say Y here to enable deferred MMC resume until I/O
+	  is requested. This will reduce overall resume latency and
+	  save power when theres an SD card inserted but not being used.
+
 config SDIO_UART
 	tristate "SDIO UART/GPS class support"
 	help
diff -Nur linux-2.6.32-orig/drivers/mmc/card/queue.c iDroid-Project-kernel_common-9e90fd2/drivers/mmc/card/queue.c
--- linux-2.6.32-orig/drivers/mmc/card/queue.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mmc/card/queue.c	2010-11-18 21:05:30.000000000 +0600
@@ -90,9 +90,10 @@
 	struct request *req;
 
 	if (!mq) {
-		printk(KERN_ERR "MMC: killing requests for dead queue\n");
-		while ((req = blk_fetch_request(q)) != NULL)
+		while ((req = blk_fetch_request(q)) != NULL) {
+			req->cmd_flags |= REQ_QUIET;
 			__blk_end_request_all(req, -EIO);
+		}
 		return;
 	}
 
@@ -223,17 +224,18 @@
 	struct request_queue *q = mq->queue;
 	unsigned long flags;
 
-	/* Mark that we should start throwing out stragglers */
-	spin_lock_irqsave(q->queue_lock, flags);
-	q->queuedata = NULL;
-	spin_unlock_irqrestore(q->queue_lock, flags);
-
 	/* Make sure the queue isn't suspended, as that will deadlock */
 	mmc_queue_resume(mq);
 
 	/* Then terminate our worker thread */
 	kthread_stop(mq->thread);
 
+	/* Empty the queue */
+	spin_lock_irqsave(q->queue_lock, flags);
+	q->queuedata = NULL;
+	blk_start_queue(q);
+	spin_unlock_irqrestore(q->queue_lock, flags);
+
  	if (mq->bounce_sg)
  		kfree(mq->bounce_sg);
  	mq->bounce_sg = NULL;
@@ -245,8 +247,6 @@
 		kfree(mq->bounce_buf);
 	mq->bounce_buf = NULL;
 
-	blk_cleanup_queue(mq->queue);
-
 	mq->card = NULL;
 }
 EXPORT_SYMBOL(mmc_cleanup_queue);
diff -Nur linux-2.6.32-orig/drivers/mmc/core/core.c iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/core.c
--- linux-2.6.32-orig/drivers/mmc/core/core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/core.c	2010-11-18 21:05:30.000000000 +0600
@@ -22,6 +22,7 @@
 #include <linux/scatterlist.h>
 #include <linux/log2.h>
 #include <linux/regulator/consumer.h>
+#include <linux/wakelock.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -38,6 +39,7 @@
 #include "sdio_ops.h"
 
 static struct workqueue_struct *workqueue;
+static struct wake_lock mmc_delayed_work_wake_lock;
 
 /*
  * Enabling software CRCs on the data blocks can be a significant (30%)
@@ -53,6 +55,7 @@
 static int mmc_schedule_delayed_work(struct delayed_work *work,
 				     unsigned long delay)
 {
+	wake_lock(&mmc_delayed_work_wake_lock);
 	return queue_delayed_work(workqueue, work, delay);
 }
 
@@ -529,9 +532,12 @@
 
 	/* If the host is claimed then we do not want to disable it anymore */
 	if (!mmc_try_claim_host(host))
-		return;
+		goto out;
 	mmc_host_do_disable(host, 1);
 	mmc_do_release_host(host);
+
+out:
+	wake_unlock(&mmc_delayed_work_wake_lock);
 }
 
 /**
@@ -891,12 +897,7 @@
 	 */
 	mmc_delay(10);
 
-	if (host->f_min > 400000) {
-		pr_warning("%s: Minimum clock frequency too high for "
-				"identification mode\n", mmc_hostname(host));
-		host->ios.clock = host->f_min;
-	} else
-		host->ios.clock = 400000;
+	host->ios.clock = host->f_min;
 
 	host->ios.power_mode = MMC_POWER_ON;
 	mmc_set_ios(host);
@@ -961,6 +962,30 @@
 	spin_unlock_irqrestore(&host->lock, flags);
 }
 
+int mmc_resume_bus(struct mmc_host *host)
+{
+	if (!mmc_bus_needs_resume(host))
+		return -EINVAL;
+
+	printk("%s: Starting deferred resume\n", mmc_hostname(host));
+	host->bus_resume_flags &= ~MMC_BUSRESUME_NEEDS_RESUME;
+	mmc_bus_get(host);
+	if (host->bus_ops && !host->bus_dead) {
+		mmc_power_up(host);
+		BUG_ON(!host->bus_ops->resume);
+		host->bus_ops->resume(host);
+	}
+
+	if (host->bus_ops->detect && !host->bus_dead)
+		host->bus_ops->detect(host);
+
+	mmc_bus_put(host);
+	printk("%s: Deferred resume completed\n", mmc_hostname(host));
+	return 0;
+}
+
+EXPORT_SYMBOL(mmc_resume_bus);
+
 /*
  * Assign a mmc bus handler to a host. Only one bus handler may control a
  * host at any given time.
@@ -1041,6 +1066,7 @@
 		container_of(work, struct mmc_host, detect.work);
 	u32 ocr;
 	int err;
+	int extend_wakelock = 0;
 
 	mmc_bus_get(host);
 
@@ -1048,6 +1074,12 @@
 	if ((host->bus_ops != NULL) && host->bus_ops->detect && !host->bus_dead)
 		host->bus_ops->detect(host);
 
+	/* If the card was removed the bus will be marked
+	 * as dead - extend the wakelock so userspace
+	 * can respond */
+	if (host->bus_dead)
+		extend_wakelock = 1;
+
 	mmc_bus_put(host);
 
 
@@ -1084,6 +1116,7 @@
 	if (!err) {
 		if (mmc_attach_sdio(host, ocr))
 			mmc_power_off(host);
+		extend_wakelock = 1;
 		goto out;
 	}
 
@@ -1094,6 +1127,7 @@
 	if (!err) {
 		if (mmc_attach_sd(host, ocr))
 			mmc_power_off(host);
+		extend_wakelock = 1;
 		goto out;
 	}
 
@@ -1104,6 +1138,7 @@
 	if (!err) {
 		if (mmc_attach_mmc(host, ocr))
 			mmc_power_off(host);
+		extend_wakelock = 1;
 		goto out;
 	}
 
@@ -1111,6 +1146,11 @@
 	mmc_power_off(host);
 
 out:
+	if (extend_wakelock)
+		wake_lock_timeout(&mmc_delayed_work_wake_lock, HZ / 2);
+	else
+		wake_unlock(&mmc_delayed_work_wake_lock);
+
 	if (host->caps & MMC_CAP_NEEDS_POLL)
 		mmc_schedule_delayed_work(&host->detect, HZ);
 }
@@ -1238,6 +1278,9 @@
 {
 	int err = 0;
 
+	if (mmc_bus_needs_resume(host))
+		return 0;
+
 	if (host->caps & MMC_CAP_DISABLE)
 		cancel_delayed_work(&host->disable);
 	cancel_delayed_work(&host->detect);
@@ -1279,6 +1322,12 @@
 	int err = 0;
 
 	mmc_bus_get(host);
+	if (host->bus_resume_flags & MMC_BUSRESUME_MANUAL_RESUME) {
+		host->bus_resume_flags |= MMC_BUSRESUME_NEEDS_RESUME;
+		mmc_bus_put(host);
+		return 0;
+	}
+
 	if (host->bus_ops && !host->bus_dead) {
 		mmc_power_up(host);
 		mmc_select_voltage(host, host->ocr);
@@ -1312,10 +1361,28 @@
 
 #endif
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+void mmc_set_embedded_sdio_data(struct mmc_host *host,
+				struct sdio_cis *cis,
+				struct sdio_cccr *cccr,
+				struct sdio_embedded_func *funcs,
+				int num_funcs)
+{
+	host->embedded_sdio_data.cis = cis;
+	host->embedded_sdio_data.cccr = cccr;
+	host->embedded_sdio_data.funcs = funcs;
+	host->embedded_sdio_data.num_funcs = num_funcs;
+}
+
+EXPORT_SYMBOL(mmc_set_embedded_sdio_data);
+#endif
+
 static int __init mmc_init(void)
 {
 	int ret;
 
+	wake_lock_init(&mmc_delayed_work_wake_lock, WAKE_LOCK_SUSPEND, "mmc_delayed_work");
+
 	workqueue = create_singlethread_workqueue("kmmcd");
 	if (!workqueue)
 		return -ENOMEM;
@@ -1350,6 +1417,7 @@
 	mmc_unregister_host_class();
 	mmc_unregister_bus();
 	destroy_workqueue(workqueue);
+	wake_lock_destroy(&mmc_delayed_work_wake_lock);
 }
 
 subsys_initcall(mmc_init);
diff -Nur linux-2.6.32-orig/drivers/mmc/core/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/Kconfig
--- linux-2.6.32-orig/drivers/mmc/core/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -14,3 +14,19 @@
 	  This option is usually just for embedded systems which use
 	  a MMC/SD card for rootfs. Most people should say N here.
 
+config MMC_EMBEDDED_SDIO
+	boolean "MMC embedded SDIO device support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  If you say Y here, support will be added for embedded SDIO
+	  devices which do not contain the necessary enumeration
+	  support in hardware to be properly detected.
+
+config MMC_PARANOID_SD_INIT
+	bool "Enable paranoid SD card initialization (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  If you say Y here, the MMC layer will be extra paranoid
+	  about re-trying SD init requests. This can be a useful
+	  work-around for buggy controllers and hardware. Enable
+	  if you are experiencing issues with SD detection.
diff -Nur linux-2.6.32-orig/drivers/mmc/core/mmc.c iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/mmc.c
--- linux-2.6.32-orig/drivers/mmc/core/mmc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/mmc.c	2010-11-18 21:05:30.000000000 +0600
@@ -207,7 +207,7 @@
 	}
 
 	card->ext_csd.rev = ext_csd[EXT_CSD_REV];
-	if (card->ext_csd.rev > 3) {
+	if (card->ext_csd.rev > 5) {
 		printk(KERN_ERR "%s: unrecognised EXT_CSD structure "
 			"version %d\n", mmc_hostname(card->host),
 			card->ext_csd.rev);
diff -Nur linux-2.6.32-orig/drivers/mmc/core/sd.c iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/sd.c
--- linux-2.6.32-orig/drivers/mmc/core/sd.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/sd.c	2010-11-18 21:05:30.000000000 +0600
@@ -336,7 +336,9 @@
 	int err;
 	u32 cid[4];
 	unsigned int max_dtr;
-
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries;
+#endif
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
@@ -439,11 +441,29 @@
 		err = mmc_decode_scr(card);
 		if (err < 0)
 			goto free_card;
-
 		/*
 		 * Fetch switch information from card.
 		 */
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+		for (retries = 1; retries <= 3; retries++) {
+			err = mmc_read_switch(card);
+			if (!err) {
+				if (retries > 1) {
+					printk(KERN_WARNING
+					       "%s: recovered\n", 
+					       mmc_hostname(host));
+				}
+				break;
+			} else {
+				printk(KERN_WARNING
+				       "%s: read switch failed (attempt %d)\n",
+				       mmc_hostname(host), retries);
+			}
+		}
+#else
 		err = mmc_read_switch(card);
+#endif
+
 		if (err)
 			goto free_card;
 	}
@@ -538,18 +558,36 @@
  */
 static void mmc_sd_detect(struct mmc_host *host)
 {
-	int err;
+	int err = 0;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+        int retries = 5;
+#endif
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
-
+       
 	mmc_claim_host(host);
 
 	/*
 	 * Just check if our card has been removed.
 	 */
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	while(retries) {
+		err = mmc_send_status(host->card, NULL);
+		if (err) {
+			retries--;
+			udelay(5);
+			continue;
+		}
+		break;
+	}
+	if (!retries) {
+		printk(KERN_ERR "%s(%s): Unable to re-detect card (%d)\n",
+		       __func__, mmc_hostname(host), err);
+	}
+#else
 	err = mmc_send_status(host->card, NULL);
-
+#endif
 	mmc_release_host(host);
 
 	if (err) {
@@ -587,12 +625,31 @@
 static int mmc_sd_resume(struct mmc_host *host)
 {
 	int err;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries;
+#endif
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	retries = 5;
+	while (retries) {
+		err = mmc_sd_init_card(host, host->ocr, host->card);
+
+		if (err) {
+			printk(KERN_ERR "%s: Re-init card rc = %d (retries = %d)\n",
+			       mmc_hostname(host), err, retries);
+			mdelay(5);
+			retries--;
+			continue;
+		}
+		break;
+	}
+#else
 	err = mmc_sd_init_card(host, host->ocr, host->card);
+#endif
 	mmc_release_host(host);
 
 	return err;
@@ -658,6 +715,9 @@
 int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 {
 	int err;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries;
+#endif
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
@@ -706,9 +766,27 @@
 	/*
 	 * Detect and init the card.
 	 */
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	retries = 5;
+	while (retries) {
+		err = mmc_sd_init_card(host, host->ocr, NULL);
+		if (err) {
+			retries--;
+			continue;
+		}
+		break;
+	}
+
+	if (!retries) {
+		printk(KERN_ERR "%s: mmc_sd_init_card() failure (err = %d)\n",
+		       mmc_hostname(host), err);
+		goto err;
+	}
+#else
 	err = mmc_sd_init_card(host, host->ocr, NULL);
 	if (err)
 		goto err;
+#endif
 
 	mmc_release_host(host);
 
diff -Nur linux-2.6.32-orig/drivers/mmc/core/sdio_bus.c iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/sdio_bus.c
--- linux-2.6.32-orig/drivers/mmc/core/sdio_bus.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/sdio_bus.c	2010-11-18 21:05:30.000000000 +0600
@@ -20,6 +20,10 @@
 #include "sdio_cis.h"
 #include "sdio_bus.h"
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+#include <linux/mmc/host.h>
+#endif
+
 /* show configuration fields */
 #define sdio_config_attr(field, format_string)				\
 static ssize_t								\
@@ -199,7 +203,14 @@
 {
 	struct sdio_func *func = dev_to_sdio_func(dev);
 
-	sdio_free_func_cis(func);
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	/*
+	 * If this device is embedded then we never allocated
+	 * cis tables for this func
+	 */
+	if (!func->card->host->embedded_sdio_data.funcs)
+#endif
+		sdio_free_func_cis(func);
 
 	if (func->info)
 		kfree(func->info);
diff -Nur linux-2.6.32-orig/drivers/mmc/core/sdio.c iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/sdio.c
--- linux-2.6.32-orig/drivers/mmc/core/sdio.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/sdio.c	2010-11-18 21:05:30.000000000 +0600
@@ -24,6 +24,10 @@
 #include "sdio_ops.h"
 #include "sdio_cis.h"
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+#include <linux/mmc/sdio_ids.h>
+#endif
+
 static int sdio_read_fbr(struct sdio_func *func)
 {
 	int ret;
@@ -279,19 +283,35 @@
 			goto remove;
 	}
 
-	/*
-	 * Read the common registers.
-	 */
-	err = sdio_read_cccr(card);
-	if (err)
-		goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	if (host->embedded_sdio_data.cccr)
+		memcpy(&card->cccr, host->embedded_sdio_data.cccr, sizeof(struct sdio_cccr));
+	else {
+#endif
+		/*
+		 * Read the common registers.
+		 */
+		err = sdio_read_cccr(card);
+		if (err)
+			goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	}
+#endif
 
-	/*
-	 * Read the common CIS tuples.
-	 */
-	err = sdio_read_common_cis(card);
-	if (err)
-		goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	if (host->embedded_sdio_data.cis)
+		memcpy(&card->cis, host->embedded_sdio_data.cis, sizeof(struct sdio_cis));
+	else {
+#endif
+		/*
+		 * Read the common CIS tuples.
+		 */
+		err = sdio_read_common_cis(card);
+		if (err)
+			goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	}
+#endif
 
 	if (oldcard) {
 		int same = (card->cis.vendor == oldcard->cis.vendor &&
@@ -518,6 +538,11 @@
 	 */
 	card->sdio_funcs = funcs = (ocr & 0x70000000) >> 28;
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	if (host->embedded_sdio_data.funcs)
+		card->sdio_funcs = funcs = host->embedded_sdio_data.num_funcs;
+#endif
+
 	/*
 	 * If needed, disconnect card detection pull-up resistor.
 	 */
@@ -529,9 +554,27 @@
 	 * Initialize (but don't add) all present functions.
 	 */
 	for (i = 0;i < funcs;i++) {
-		err = sdio_init_func(host->card, i + 1);
-		if (err)
-			goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+		if (host->embedded_sdio_data.funcs) {
+			struct sdio_func *tmp;
+
+			tmp = sdio_alloc_func(host->card);
+			if (IS_ERR(tmp))
+				goto remove;
+			tmp->num = (i + 1);
+			card->sdio_func[i] = tmp;
+			tmp->class = host->embedded_sdio_data.funcs[i].f_class;
+			tmp->max_blksize = host->embedded_sdio_data.funcs[i].f_maxblksize;
+			tmp->vendor = card->cis.vendor;
+			tmp->device = card->cis.device;
+		} else {
+#endif
+			err = sdio_init_func(host->card, i + 1);
+			if (err)
+				goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+		}
+#endif
 	}
 
 	mmc_release_host(host);
@@ -573,3 +616,82 @@
 	return err;
 }
 
+int sdio_reset_comm(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	u32 ocr;
+	int err;
+
+	printk("%s():\n", __func__);
+	mmc_claim_host(host);
+
+	mmc_go_idle(host);
+
+	mmc_set_clock(host, host->f_min);
+
+	err = mmc_send_io_op_cond(host, 0, &ocr);
+	if (err)
+		goto err;
+
+	host->ocr = mmc_select_voltage(host, ocr);
+	if (!host->ocr) {
+		err = -EINVAL;
+		goto err;
+	}
+
+	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
+	if (err)
+		goto err;
+
+	if (mmc_host_is_spi(host)) {
+		err = mmc_spi_set_crc(host, use_spi_crc);
+		if (err)
+		goto err;
+	}
+
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_send_relative_addr(host, &card->rca);
+		if (err)
+			goto err;
+		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
+	}
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_select_card(card);
+		if (err)
+			goto err;
+	}
+
+	/*
+	 * Switch to high-speed (if supported).
+	 */
+	err = sdio_enable_hs(card);
+	if (err)
+		goto err;
+
+	/*
+	 * Change to the card's maximum speed.
+	 */
+	if (mmc_card_highspeed(card)) {
+		/*
+		 * The SDIO specification doesn't mention how
+		 * the CIS transfer speed register relates to
+		 * high-speed, but it seems that 50 MHz is
+		 * mandatory.
+		 */
+		mmc_set_clock(host, 50000000);
+	} else {
+		mmc_set_clock(host, card->cis.max_dtr);
+	}
+
+	err = sdio_enable_wide(card);
+	if (err)
+		goto err;
+	mmc_release_host(host);
+	return 0;
+err:
+	printk("%s: Error resetting SDIO communications (%d)\n",
+	       mmc_hostname(host), err);
+	mmc_release_host(host);
+	return err;
+}
+EXPORT_SYMBOL(sdio_reset_comm);
diff -Nur linux-2.6.32-orig/drivers/mmc/core/sdio_io.c iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/sdio_io.c
--- linux-2.6.32-orig/drivers/mmc/core/sdio_io.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mmc/core/sdio_io.c	2010-11-18 21:05:30.000000000 +0600
@@ -378,6 +378,39 @@
 EXPORT_SYMBOL_GPL(sdio_readb);
 
 /**
+ *	sdio_readb_ext - read a single byte from a SDIO function
+ *	@func: SDIO function to access
+ *	@addr: address to read
+ *	@err_ret: optional status value from transfer
+ *	@in: value to add to argument
+ *
+ *	Reads a single byte from the address space of a given SDIO
+ *	function. If there is a problem reading the address, 0xff
+ *	is returned and @err_ret will contain the error code.
+ */
+unsigned char sdio_readb_ext(struct sdio_func *func, unsigned int addr,
+	int *err_ret, unsigned in)
+{
+	int ret;
+	unsigned char val;
+
+	BUG_ON(!func);
+
+	if (err_ret)
+		*err_ret = 0;
+
+	ret = mmc_io_rw_direct(func->card, 0, func->num, addr, (u8)in, &val);
+	if (ret) {
+		if (err_ret)
+			*err_ret = ret;
+		return 0xFF;
+	}
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(sdio_readb_ext);
+
+/**
  *	sdio_writeb - write a single byte to a SDIO function
  *	@func: SDIO function to access
  *	@b: byte to write
diff -Nur linux-2.6.32-orig/drivers/mmc/host/iphone-sdio.c iDroid-Project-kernel_common-9e90fd2/drivers/mmc/host/iphone-sdio.c
--- linux-2.6.32-orig/drivers/mmc/host/iphone-sdio.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mmc/host/iphone-sdio.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,805 @@
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <mach/iphone-clock.h>
+#include <linux/workqueue.h>
+#include <mach/gpio.h>
+
+#define SDIO_PA 0x38D00000
+#define SDIO_CLOCKGATE 0xB
+#define SDIO_INT 0x2A
+
+#ifdef CONFIG_IPODTOUCH_1G
+#define SDIO_GPIO_POWER 0x1701
+#endif
+
+#ifndef CONFIG_IPODTOUCH_1G
+#define SDIO_GPIO_DEVICE_RESET 0x607
+#endif
+
+#define SDIO_CTRL       0x0
+#define SDIO_DCTRL      0x4
+#define SDIO_CMD        0x8
+#define SDIO_ARGU       0xC
+#define SDIO_STATE      0x10
+#define SDIO_STAC       0x14
+#define SDIO_DSTA       0x18
+#define SDIO_FSTA       0x1C
+#define SDIO_RESP0      0x20
+#define SDIO_RESP1      0x24
+#define SDIO_RESP2      0x28
+#define SDIO_RESP3      0x2C
+#define SDIO_CLKDIV     0x30
+#define SDIO_CSR        0x34
+#define SDIO_IRQ        0x38
+#define SDIO_IRQMASK    0x3C
+#define SDIO_BADDR      0x44
+#define SDIO_BLKLEN     0x48
+#define SDIO_NUMBLK     0x4C
+#define SDIO_REMBLK     0x50
+
+#define sdio_set_reg(reg, x) writel((x), sdio->regs + (reg))
+#define sdio_get_reg(reg) readl(sdio->regs + (reg))
+
+struct iphone_sdio
+{
+	struct device*		dev;
+	struct resource*	regs_res;
+	void __iomem*		regs;
+	struct mmc_host*	mmc;
+	struct mmc_request*	mrq;
+	bool			irq_enabled;
+	int			errors;
+	spinlock_t		lock;
+};
+
+static struct iphone_sdio* sdio_driver;
+
+static void sdio_workqueue_handler(struct work_struct* work);
+static void sdio_reset_handler(struct work_struct* work);
+
+DECLARE_WORK(sdio_workqueue, &sdio_workqueue_handler);
+DECLARE_DELAYED_WORK(sdio_reset_workqueue, &sdio_reset_handler);
+static struct workqueue_struct* sdio_wq;
+
+static inline void sdio_check_for_irq(struct iphone_sdio* sdio)
+{
+	unsigned long flags;
+	bool gotIRQ = false;
+
+	spin_lock_irqsave(&sdio->lock, flags);
+	if(sdio->irq_enabled)
+	{
+		u32 irqstat = sdio_get_reg(SDIO_IRQ);
+
+		//printk("irqstat: %x\n", irqstat);
+		if(irqstat & 2)
+		{
+			sdio_set_reg(SDIO_IRQ, 2);
+			gotIRQ = true;
+			//printk("got sdio IRQ!\n");
+		}
+	}
+	spin_unlock_irqrestore(&sdio->lock, flags);
+
+	if(gotIRQ)
+			mmc_signal_sdio_irq(sdio->mmc);
+		}
+
+static irqreturn_t sdio_irq(int irq, void *pw)
+{
+	struct iphone_sdio* sdio = pw;
+
+	//printk("in sdio irq\n");
+	sdio_check_for_irq(sdio);
+	//printk("out of sdio irq\n");
+
+	return IRQ_HANDLED;
+}
+
+int sdio_wait_for_ready(struct iphone_sdio* sdio, int timeout)
+{
+	// wait for CMD_STATE to be CMD_IDLE, and DAT_STATE to be DAT_IDLE
+	u64 startTime = iphone_microtime();
+	while(sdio_get_reg(SDIO_STATE) != 0)
+	{
+		if(iphone_has_elapsed(startTime, timeout * 1000)) {
+			return -ETIMEDOUT;
+		}
+		yield();
+	}
+
+	return 0;
+
+}
+
+static int sdio_wait_for_cmd_ready(struct iphone_sdio* sdio, int timeout)
+{
+	// wait for the command to be ready to transmit
+	u64 startTime = iphone_microtime();
+	while((sdio_get_reg(SDIO_DSTA) & 1) == 0)
+	{
+		if(iphone_has_elapsed(startTime, timeout * 1000)) {
+			return -ETIMEDOUT;
+		}
+		yield();
+	}
+
+	return 0;
+}
+
+static int sdio_execute_command(struct iphone_sdio* sdio, int timeout)
+{
+	u32 status;
+	u64 startTime;
+
+	// set the execute bit
+	sdio_set_reg(SDIO_CMD, sdio_get_reg(SDIO_CMD) | (1 << 31));
+
+	// wait for the command to at least get transmitted
+	startTime = iphone_microtime();
+	while(((sdio_get_reg(SDIO_DSTA) >> 2) & 1) == 0)
+	{
+		if(iphone_has_elapsed(startTime, timeout * 1000)) {
+			return -ETIMEDOUT;
+		}
+		yield();
+	}
+
+	// wait for the command status to get back to idle
+	// the reason command sent status is checked first is to avoid race conditions
+	// where the state hasn't yet transitioned from idle
+	while(((sdio_get_reg(SDIO_STATE) >> 4) & 7) != 0)
+	{
+		yield();
+		// No check here because device has its own timeout status
+	}
+
+	status = sdio_get_reg(SDIO_DSTA);
+	return ((u32)(status >> 15));
+}
+
+
+static void sdio_clear_state(struct iphone_sdio* sdio)
+{
+	// clear current status
+	sdio_set_reg(SDIO_STAC, sdio_get_reg(SDIO_DSTA));
+}
+
+static int sdio_reset(struct iphone_sdio* sdio)
+{
+	int ret;
+
+#ifdef SDIO_GPIO_POWER
+	iphone_gpio_pin_output(SDIO_GPIO_POWER, 0);
+	msleep(5);
+	iphone_gpio_pin_output(SDIO_GPIO_POWER, 1);
+	msleep(10);
+#endif
+
+#ifdef SDIO_GPIO_DEVICE_RESET
+	iphone_gpio_pin_output(SDIO_GPIO_DEVICE_RESET, 1);
+	msleep(5);
+	iphone_gpio_pin_output(SDIO_GPIO_DEVICE_RESET, 0);
+	msleep(10);
+#endif
+
+	ret = sdio_wait_for_ready(sdio, 100);
+	if(ret)
+		return ret;
+
+	sdio_clear_state(sdio);
+
+	return 0;
+}
+
+static int sdio_init(struct iphone_sdio* sdio)
+{
+	iphone_clock_gate_switch(SDIO_CLOCKGATE, 1);
+
+	// SDCLK = PCLK/128 ~= 400 KHz
+	sdio_set_reg(SDIO_CLKDIV, 1 << 7);
+
+	// Reset FIFO
+	sdio_set_reg(SDIO_DCTRL, 0x3);
+	sdio_set_reg(SDIO_DCTRL, 0x0);
+
+	// Enable SDIO, with 1-bit card bus.
+	sdio_set_reg(SDIO_CTRL, 0x1);
+
+	// Clear status
+	sdio_set_reg(SDIO_STAC, 0xFFFFFFFF);
+
+	// Clear IRQ
+	sdio_set_reg(SDIO_IRQ, 0xFFFFFFFF);
+
+	if(sdio_reset(sdio) != 0)
+	{
+		dev_err(sdio->dev, "error resetting card\n");
+		return -1;
+	}
+
+	// Enable checking for SDIO irqs
+	sdio_set_reg(SDIO_CSR, 2);
+
+	// Enable xfer done IRQ
+	sdio_set_reg(SDIO_IRQMASK, 0);
+
+	return 0;
+}
+
+static inline u32 setup_cmd(struct mmc_command* cmd)
+{
+	u32 x = cmd->opcode;
+
+	if(cmd->flags & MMC_CMD_AC)
+	{
+		x |= 2 << 6;
+	} else if(cmd->flags & MMC_CMD_ADTC)
+	{
+		x |= 3 << 6;
+		if(likely(cmd->data != NULL))
+		{
+			if(cmd->data->flags & MMC_DATA_READ)
+				x |= 0 << 8;
+			else if(cmd->data->flags & MMC_DATA_WRITE)
+				x |= 1 << 8;
+		}
+	} else if(cmd->flags & MMC_CMD_BC)
+	{
+		x |= 0 << 6;
+	} else if(cmd->flags & MMC_CMD_BCR)
+	{
+		x |= 1 << 6;
+	}
+
+	if(mmc_resp_type(cmd) == MMC_RSP_NONE)
+		x |= 0 << 16;
+	else if(mmc_resp_type(cmd) == MMC_RSP_R1)
+		x |= 1 << 16;
+	else if(mmc_resp_type(cmd) == MMC_RSP_R1B)
+		x |= 1 << 16;
+	else if(mmc_resp_type(cmd) == MMC_RSP_R2)
+		x |= 2 << 16;
+/*	else if(mmc_resp_type(cmd) == MMC_RSP_R3)
+		x |= 3 << 16;*/
+	else if(mmc_resp_type(cmd) == MMC_RSP_R4)
+		x |= 4 << 16;
+	else if(mmc_resp_type(cmd) == MMC_RSP_R5)
+		x |= 5 << 16;
+	else if(mmc_resp_type(cmd) == MMC_RSP_R6)
+		x |= 6 << 16;
+
+	if(cmd->flags & MMC_RSP_136)
+		x |= 1 << 20;
+
+	return x;
+}
+
+static void sdio_reinit(struct iphone_sdio* sdio)
+{
+	sdio->errors = -1;
+	mmc_detect_change(sdio->mmc, 0);
+	schedule_delayed_work(&sdio_reset_workqueue, msecs_to_jiffies(500));
+}
+
+static void sdio_workqueue_handler(struct work_struct* work)
+{
+	int ret;
+	struct iphone_sdio* sdio = sdio_driver;
+	struct mmc_request* mrq = sdio->mrq;
+	struct mmc_command* cmd;
+	int status;
+
+	if(unlikely(sdio->mrq == NULL))
+	{
+		dev_warn(sdio->dev, "sdio_workqueue_handler called without any work!\n");
+		return;
+	}
+
+	cmd = mrq->cmd;
+
+	//dev_info(sdio->dev, "executing command %d, arg %08x\n", cmd->opcode, cmd->arg);
+
+	sdio_set_reg(SDIO_IRQMASK, sdio_get_reg(SDIO_IRQMASK) & ~2);
+
+	sdio_clear_state(sdio);
+
+	ret = sdio_wait_for_ready(sdio, 100);
+	if(ret)
+	{
+		dev_info(sdio->dev, "problem waiting for ready");
+		goto sdio_error;
+	}
+
+	if(cmd->data)
+	{
+		int i;
+		struct scatterlist *sg;
+		int segs = 0;
+
+		//dev_info(sdio->dev, "setting up data command %d, arg %08x, blklen = %d, numblk = %d\n", cmd->opcode, cmd->arg, cmd->data->blksz, cmd->data->blocks);
+
+		if(cmd->data->flags & MMC_DATA_READ)
+			segs = dma_map_sg(sdio->dev, cmd->data->sg, cmd->data->sg_len, DMA_FROM_DEVICE);
+		else if(cmd->data->flags & MMC_DATA_WRITE)
+			segs = dma_map_sg(sdio->dev, cmd->data->sg, cmd->data->sg_len, DMA_TO_DEVICE);
+
+		if(segs != 1)
+		{
+			// undo whatever we did
+			if(cmd->data->flags & MMC_DATA_READ)
+				dma_unmap_sg(sdio->dev, cmd->data->sg, segs, DMA_FROM_DEVICE);
+			else if(cmd->data->flags & MMC_DATA_WRITE)
+				dma_unmap_sg(sdio->dev, cmd->data->sg, segs, DMA_TO_DEVICE);
+
+			dev_err(sdio->dev, "scatterlist must have only one entry!\n");
+			ret = -EINVAL;
+			goto sdio_error;
+		}
+
+		for_each_sg(cmd->data->sg, sg, segs, i)
+		{
+			sdio_set_reg(SDIO_BADDR, sg_dma_address(sg));
+		}
+
+		sdio_set_reg(SDIO_BLKLEN, cmd->data->blksz);
+		sdio_set_reg(SDIO_NUMBLK, cmd->data->blocks);
+
+		if(cmd->data->blocks == 1)
+			sdio_set_reg(SDIO_CTRL, sdio_get_reg(SDIO_CTRL) & ~0x8000);
+		else
+			sdio_set_reg(SDIO_CTRL, sdio_get_reg(SDIO_CTRL) | 0x8000);
+
+		// reset the FIFOs
+		sdio_set_reg(SDIO_DCTRL, 3);
+		sdio_set_reg(SDIO_DCTRL, 0);
+
+		// disable block transfer done IRQ since we will be polling
+		//sdio_set_reg(SDIO_IRQMASK, sdio_get_reg(SDIO_IRQMASK) & ~3);
+		//sdio_set_reg(SDIO_IRQMASK, sdio_get_reg(SDIO_IRQMASK) & ~1);
+	}
+
+	sdio_set_reg(SDIO_ARGU, cmd->arg);
+	sdio_set_reg(SDIO_CMD, setup_cmd(cmd));
+	//dev_info(sdio->dev, "SDIO_CMD = %08x\n", sdio_get_reg(SDIO_CMD));
+
+	ret = sdio_wait_for_cmd_ready(sdio, 100);
+	if(ret)
+	{
+		dev_info(sdio->dev, "problem waiting for cmd ready");
+		goto sdio_error;
+	}
+
+	status = sdio_execute_command(sdio, 100);
+	if(status < 0)
+	{
+		dev_info(sdio->dev, "problem with execute command");
+		ret = status;
+		goto sdio_error;
+	}
+
+	//dev_info(sdio->dev, "after execute status = %08x\n", sdio_get_reg(SDIO_DSTA));
+
+	// check for timeout
+	if(status & 1)
+	{
+		dev_info(sdio->dev, "controller signalled command timeout");
+		ret = -ETIMEDOUT;
+		goto sdio_error;
+	}
+
+	// check for response index and end bit errors
+	if(status & 6)
+	{
+		dev_info(sdio->dev, "index or end bit error\n");
+		ret = -EILSEQ;
+		goto sdio_error;
+	}
+
+	// check for CRC error if necessary
+	if((cmd->flags & MMC_RSP_CRC) && (status & 8))
+	{
+		dev_info(sdio->dev, "CRC error\n");
+		ret = -EILSEQ;
+		goto sdio_error;
+	}
+
+	// looks like the command is non-errone
+	cmd->error = 0;
+
+	// populate response if necessary
+	if(cmd->flags & MMC_RSP_PRESENT)
+	{
+		cmd->resp[0] = sdio_get_reg(SDIO_RESP0);
+		if(cmd->flags & MMC_RSP_136)
+		{
+			cmd->resp[1] = sdio_get_reg(SDIO_RESP1);
+			cmd->resp[2] = sdio_get_reg(SDIO_RESP2);
+			cmd->resp[3] = sdio_get_reg(SDIO_RESP3);
+		}
+	}
+
+	if(cmd->data)
+	{
+		u64 startTime;
+
+		sdio_clear_state(sdio);
+		sdio_set_reg(SDIO_DCTRL, 0x10);
+
+		startTime = iphone_microtime();
+		while((sdio_get_reg(SDIO_IRQ) & 1) == 0)
+		{
+			if(iphone_has_elapsed(startTime, cmd->data->timeout_ns))
+			{
+				ret = -ETIMEDOUT;
+				goto sdio_error;
+			}
+			yield();
+		}
+
+		// re-enable IRQs
+		sdio_set_reg(SDIO_IRQ, 1);
+		//sdio_set_reg(SDIO_IRQMASK, sdio_get_reg(SDIO_IRQMASK) | 3);
+		//sdio_set_reg(SDIO_IRQMASK, sdio_get_reg(SDIO_IRQMASK) | 1);
+
+		status = sdio_get_reg(SDIO_DSTA) >> 19;
+		if(((cmd->data->flags & MMC_DATA_WRITE) && status != 2) || ((cmd->data->flags & MMC_DATA_READ) && status != 0))
+		{
+			dev_info(sdio->dev, "Data error for command %d, arg %08x, blklen = %d, numblk = %d, dsta=0x%08x\n", cmd->opcode, cmd->arg, cmd->data->blksz, cmd->data->blocks, sdio_get_reg(SDIO_DSTA));
+			cmd->data->error = -EILSEQ;
+			cmd->data->bytes_xfered = 0;
+			sdio->mrq = NULL;
+			mmc_request_done(sdio->mmc, mrq);
+			return;
+		}
+
+		if(cmd->data->flags & MMC_DATA_READ)
+			dma_unmap_sg(sdio->dev, cmd->data->sg, 1, DMA_FROM_DEVICE);
+		else if(cmd->data->flags & MMC_DATA_WRITE)
+			dma_unmap_sg(sdio->dev, cmd->data->sg, 1, DMA_TO_DEVICE);
+
+		sdio_set_reg(SDIO_CTRL, sdio_get_reg(SDIO_CTRL) & ~0x8000);
+
+		cmd->data->error = 0;
+		cmd->data->bytes_xfered = cmd->data->blksz * cmd->data->blocks;
+
+		//dev_info(sdio->dev, "data successful!\n");
+	}
+
+	sdio->mrq = NULL;
+	mmc_request_done(sdio->mmc, mrq);
+
+	if(sdio->irq_enabled)
+	{
+		sdio_set_reg(SDIO_IRQMASK, sdio_get_reg(SDIO_IRQMASK) | 2);
+		sdio_check_for_irq(sdio);
+	}
+
+	//dev_info(sdio->dev, "command successful!\n");
+	return;
+
+sdio_error:
+	dev_info(sdio->dev, "execution error %d for command %d, arg %08x\n", ret, cmd->opcode, cmd->arg);
+	++sdio->errors;
+	cmd->error = ret;
+	if(cmd->data)
+	{
+		cmd->data->error = ret;
+		cmd->data->bytes_xfered = 0;
+	}
+
+	sdio->mrq = NULL;
+	mmc_request_done(sdio->mmc, mrq);
+
+	if(sdio->errors > 3)
+	{
+		dev_err(sdio->dev, "too many errors -- signalling Instrument of God and notifying MMC core\n");
+		sdio_reinit(sdio);
+	}
+
+}
+
+static void sdio_reset_handler(struct work_struct* work)
+{
+	struct iphone_sdio* sdio = sdio_driver;
+	dev_err(sdio->dev, "Instrument of God activated, resetting SDIO and notifying MMC core\n");
+	sdio_reset(sdio);
+	sdio->errors = 0;
+	mmc_detect_change(sdio->mmc, 0);
+}
+
+static void iphone_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct iphone_sdio* sdio = mmc_priv(mmc);
+
+	if(unlikely(sdio->errors == -1))
+	{
+		dev_err(sdio->dev, "got request while SDIO is in a dead state\n");
+		mrq->cmd->error = -EINVAL;
+		if(mrq->cmd->data)
+			mrq->cmd->data->error = -EINVAL;
+
+		mmc_request_done(mmc, mrq);
+		return;
+	}
+
+	if(unlikely(sdio->mrq != NULL))
+	{
+		dev_err(sdio->dev, "got request before last request was finished!\n");
+		mrq->cmd->error = -EINVAL;
+		if(mrq->cmd->data)
+			mrq->cmd->data->error = -EINVAL;
+
+		mmc_request_done(mmc, mrq);
+		return;
+	}
+
+	//dev_info(sdio->dev, "queueing request\n");
+
+	sdio->mrq = mrq;
+	queue_work(sdio_wq, &sdio_workqueue);
+}
+
+static void iphone_sdio_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct iphone_sdio* sdio = mmc_priv(mmc);
+	int shift = 0;
+
+	while((FREQUENCY_PERIPHERAL >> (shift + 1)) > ios->clock)
+		++shift;
+
+	if(shift > 7)
+		shift = 7;
+
+	sdio_set_reg(SDIO_CLKDIV, 1 << shift);
+
+	if(ios->bus_width == MMC_BUS_WIDTH_1)
+		sdio_set_reg(SDIO_CTRL, sdio_get_reg(SDIO_CTRL) & (~(3 << 2)));
+	else if(ios->bus_width == MMC_BUS_WIDTH_4)
+		sdio_set_reg(SDIO_CTRL, (sdio_get_reg(SDIO_CTRL) & (~(3 << 2))) | (1 << 2));
+	else if(ios->bus_width == MMC_BUS_WIDTH_8)
+		sdio_set_reg(SDIO_CTRL, (sdio_get_reg(SDIO_CTRL) & (~(3 << 2))) | (2 << 2));
+
+	//dev_info(sdio->dev, "set_ios clock = %u (%d), width %d, ctrl = %08x, vdd = %d\n", ios->clock, shift, 1 << ios->bus_width, sdio_get_reg(SDIO_CTRL), ios->vdd);
+}
+
+static void iphone_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	unsigned long flags;
+	struct iphone_sdio* sdio = mmc_priv(mmc);
+
+	//dev_info(sdio->dev, "enable irq: %d\n", enable);
+
+	if(enable)
+	{
+		spin_lock_irqsave(&sdio->lock, flags);
+		sdio->irq_enabled = true;
+		sdio_set_reg(SDIO_IRQMASK, sdio_get_reg(SDIO_IRQMASK) | 2);
+		spin_unlock_irqrestore(&sdio->lock, flags);
+		sdio_check_for_irq(sdio);
+	} else
+	{
+		spin_lock_irqsave(&sdio->lock, flags);
+		sdio->irq_enabled = false;
+		sdio_set_reg(SDIO_IRQMASK, sdio_get_reg(SDIO_IRQMASK) & ~2);
+		spin_unlock_irqrestore(&sdio->lock, flags);
+	}
+}
+
+static struct mmc_host_ops iphone_sdio_ops = {
+	.request		= iphone_sdio_request,
+	.set_ios		= iphone_sdio_set_ios,
+	.enable_sdio_irq	= iphone_enable_sdio_irq,
+};
+
+ssize_t iphone_sdio_show_reset(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "0\n");
+}
+
+ssize_t iphone_sdio_store_reset(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct iphone_sdio* sdio = sdio_driver;
+	int doReset = 0;
+	sscanf(buf, "%d", &doReset);
+	if(doReset)
+	{
+		dev_info(sdio->dev, "reinitializing SDIO card\n");
+		sdio_reinit(sdio);
+	}
+
+	return strnlen(buf, PAGE_SIZE);
+}
+
+
+DEVICE_ATTR(reset, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP, iphone_sdio_show_reset, iphone_sdio_store_reset);
+
+static int __devinit iphone_sdio_probe(struct platform_device* pdev)
+{
+	int ret;
+	struct resource* res;
+	struct iphone_sdio* sdio;
+	struct mmc_host* mmc;
+	struct device* dev = &pdev->dev;
+
+	sdio_wq = create_workqueue("iphone_sdio_worker");
+	if(!sdio_wq)
+	{
+		dev_err(dev, "cannot get worker thread\n");
+		return -ENOMEM;
+	}
+
+	mmc = mmc_alloc_host(sizeof(struct iphone_sdio), dev);
+	if(!mmc)
+	{
+		dev_err(dev, "cannot get memory\n");
+		return -ENOMEM;
+	}
+
+	sdio = mmc_priv(mmc);
+	sdio_driver = sdio;
+
+	sdio->irq_enabled = false;
+	sdio->mrq = NULL;
+	sdio->dev = dev;
+	sdio->mmc = mmc;
+	sdio->errors = 0;
+	spin_lock_init(&sdio->lock);
+	platform_set_drvdata(pdev, sdio);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(!res)
+	{
+		dev_err(dev, "cannot find register resource 0\n");
+		ret = -EINVAL;
+		goto err_mem;
+	}
+
+	sdio->regs_res = request_mem_region(res->start, resource_size(res), dev_name(dev));
+	if(!sdio->regs_res)
+	{
+		dev_err(dev, "cannot reserve registers\n");
+		ret = -ENOENT;
+		goto err_mem;
+	}
+
+	sdio->regs = ioremap(res->start, resource_size(res));
+	if(!sdio->regs)
+	{
+		dev_err(dev, "cannot map registers\n");
+		ret = -ENXIO;
+		goto err_regs_res;
+	}
+
+	ret = request_irq(SDIO_INT, sdio_irq, IRQF_DISABLED, dev_name(dev), sdio);
+	if(ret < 0)
+	{
+		dev_err(dev, "cannot claim IRQ\n");
+		goto err_regs;
+	}
+
+	if(sdio_init(sdio) < 0)
+	{
+		dev_err(dev, "error initializing SDIO\n");
+		goto err_regs;
+	}
+
+	mmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_NONREMOVABLE | MMC_CAP_SDIO_IRQ | MMC_CAP_SD_HIGHSPEED;
+	mmc->ops = &iphone_sdio_ops;
+	mmc->f_min = FREQUENCY_PERIPHERAL / 256;
+	mmc->f_max = FREQUENCY_PERIPHERAL / 2;
+	mmc->ocr_avail = ~0x7f;
+
+	mmc->max_phys_segs = 1;
+	mmc->max_hw_segs = 1;
+	mmc->max_blk_size = 4095;
+	mmc->max_blk_count = 4095;
+	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+	mmc->max_seg_size = mmc->max_req_size;
+
+	ret = mmc_add_host(mmc);
+	if (ret < 0)
+		goto err_remove_host;
+
+	device_create_file(dev, &dev_attr_reset);
+	dev_info(dev, "SDIO host started with regs at 0x%p, interrupt %d\n", sdio->regs, SDIO_INT);
+
+	return 0;
+
+err_remove_host:
+	mmc_remove_host(mmc);
+	mmc_free_host(mmc);
+
+err_regs:
+	iounmap(sdio->regs);
+
+err_regs_res:
+	release_resource(sdio->regs_res);
+	kfree(sdio->regs_res);
+
+err_mem:
+	kfree(sdio);
+	return ret;
+}
+
+static int __devexit iphone_sdio_remove(struct platform_device* pdev)
+{
+	struct iphone_sdio* sdio = platform_get_drvdata(pdev);
+
+	device_remove_file(&pdev->dev, &dev_attr_reset);
+
+	flush_workqueue(sdio_wq);
+
+	free_irq(SDIO_INT, sdio);
+	iounmap(sdio->regs);
+
+	release_resource(sdio->regs_res);
+	kfree(sdio->regs_res);
+
+	kfree(sdio);
+
+	sdio_driver = NULL;
+
+	return 0;
+}
+
+static struct resource iphone_sdio_resources[] = {
+	[0] = {
+		.start  = SDIO_PA,
+		.end    = SDIO_PA + 0x1000 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = SDIO_INT,
+		.end    = SDIO_INT,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device iphone_sdio = {
+	.name           = "iphone-sdio",
+	.id             = -1,
+	.num_resources  = ARRAY_SIZE(iphone_sdio_resources),
+	.resource       = iphone_sdio_resources,
+};
+
+static struct platform_driver iphone_sdio_driver = {
+	.driver         = {
+		.name   = "iphone-sdio",
+		.owner  = THIS_MODULE,
+	},
+	.probe          = iphone_sdio_probe,
+	.remove         = __devexit_p(iphone_sdio_remove),
+	.suspend        = NULL,
+	.resume         = NULL,
+};
+
+static int __init iphone_sdio_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&iphone_sdio_driver);
+	if(!ret)
+	{
+		ret = platform_device_register(&iphone_sdio);
+	}
+
+	return ret;
+}
+
+static void __exit iphone_sdio_exit(void)
+{
+	platform_device_unregister(&iphone_sdio);
+	platform_driver_unregister(&iphone_sdio_driver);
+}
+
+
+module_init(iphone_sdio_init);
+module_exit(iphone_sdio_exit);
diff -Nur linux-2.6.32-orig/drivers/mmc/host/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/mmc/host/Kconfig
--- linux-2.6.32-orig/drivers/mmc/host/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mmc/host/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -119,6 +119,10 @@
 
 	  YMMV.
 
+config SDIO_IPHONE
+	tristate "iPhone SDIO support"
+	depends on MACH_APPLE_IPHONE
+
 config MMC_OMAP
 	tristate "TI OMAP Multimedia Card Interface support"
 	depends on ARCH_OMAP
diff -Nur linux-2.6.32-orig/drivers/mmc/host/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/mmc/host/Makefile
--- linux-2.6.32-orig/drivers/mmc/host/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mmc/host/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -6,6 +6,7 @@
 	EXTRA_CFLAGS		+= -DDEBUG
 endif
 
+obj-$(CONFIG_SDIO_IPHONE)	+= iphone-sdio.o
 obj-$(CONFIG_MMC_ARMMMCI)	+= mmci.o
 obj-$(CONFIG_MMC_PXA)		+= pxamci.o
 obj-$(CONFIG_MMC_IMX)		+= imxmmc.o
diff -Nur linux-2.6.32-orig/drivers/mtd/nand/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/mtd/nand/Kconfig
--- linux-2.6.32-orig/drivers/mtd/nand/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mtd/nand/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -1,5 +1,12 @@
 # drivers/mtd/nand/Kconfig
 
+config MTD_NAND_IDS
+	tristate "Include chip ids for known NAND devices."
+	depends on MTD
+	help
+	  Useful for NAND drivers that do not use the NAND subsystem but
+	  still like to take advantage of the known chip information.
+
 menuconfig MTD_NAND
 	tristate "NAND Device Support"
 	depends on MTD
@@ -103,9 +110,6 @@
 	help
 	  Support for NAND flash on Technologic Systems TS-7250 platform.
 
-config MTD_NAND_IDS
-	tristate
-
 config MTD_NAND_AU1550
 	tristate "Au1550/1200 NAND support"
 	depends on SOC_AU1200 || SOC_AU1550
diff -Nur linux-2.6.32-orig/drivers/mtd/nand/nand_base.c iDroid-Project-kernel_common-9e90fd2/drivers/mtd/nand/nand_base.c
--- linux-2.6.32-orig/drivers/mtd/nand/nand_base.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mtd/nand/nand_base.c	2010-11-18 21:05:30.000000000 +0600
@@ -2672,6 +2672,44 @@
 	return 0;
 }
 
+static void nand_panic_wait(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	int i;
+
+	if (chip->state != FL_READY)
+		for (i = 0; i < 40; i++) {
+			if (chip->dev_ready(mtd))
+				break;
+			mdelay(10);
+		}
+	chip->state = FL_READY;
+}
+
+static int nand_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
+			    size_t *retlen, const u_char *buf)
+{
+	struct nand_chip *chip = mtd->priv;
+	int ret;
+
+	/* Do not allow reads past end of device */
+	if ((to + len) > mtd->size)
+		return -EINVAL;
+	if (!len)
+		return 0;
+
+	nand_panic_wait(mtd);
+
+	chip->ops.len = len;
+	chip->ops.datbuf = (uint8_t *)buf;
+	chip->ops.oobbuf = NULL;
+
+	ret = nand_do_write_ops(mtd, to, &chip->ops);
+
+	*retlen = chip->ops.retlen;
+	return ret;
+}
+
 
 /**
  * nand_scan_tail - [NAND Interface] Scan for the NAND device
@@ -2879,6 +2917,7 @@
 	mtd->write = nand_write;
 	mtd->read_oob = nand_read_oob;
 	mtd->write_oob = nand_write_oob;
+	mtd->panic_write = nand_panic_write;
 	mtd->sync = nand_sync;
 	mtd->lock = NULL;
 	mtd->unlock = NULL;
diff -Nur linux-2.6.32-orig/drivers/mtd/ubi/cdev.c iDroid-Project-kernel_common-9e90fd2/drivers/mtd/ubi/cdev.c
--- linux-2.6.32-orig/drivers/mtd/ubi/cdev.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mtd/ubi/cdev.c	2010-11-18 21:05:30.000000000 +0600
@@ -853,7 +853,6 @@
 			break;
 		}
 
-		req.name[req.name_len] = '\0';
 		err = verify_mkvol_req(ubi, &req);
 		if (err)
 			break;
diff -Nur linux-2.6.32-orig/drivers/mtd/ubi/upd.c iDroid-Project-kernel_common-9e90fd2/drivers/mtd/ubi/upd.c
--- linux-2.6.32-orig/drivers/mtd/ubi/upd.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mtd/ubi/upd.c	2010-11-18 21:05:30.000000000 +0600
@@ -147,12 +147,15 @@
 	}
 
 	if (bytes == 0) {
+		err = ubi_wl_flush(ubi);
+		if (err)
+			return err;
+
 		err = clear_update_marker(ubi, vol, 0);
 		if (err)
 			return err;
-		err = ubi_wl_flush(ubi);
-		if (!err)
-			vol->updating = 0;
+		vol->updating = 0;
+		return 0;
 	}
 
 	vol->upd_buf = vmalloc(ubi->leb_size);
@@ -362,16 +365,16 @@
 
 	ubi_assert(vol->upd_received <= vol->upd_bytes);
 	if (vol->upd_received == vol->upd_bytes) {
+		err = ubi_wl_flush(ubi);
+		if (err)
+			return err;
 		/* The update is finished, clear the update marker */
 		err = clear_update_marker(ubi, vol, vol->upd_bytes);
 		if (err)
 			return err;
-		err = ubi_wl_flush(ubi);
-		if (err == 0) {
-			vol->updating = 0;
-			err = to_write;
-			vfree(vol->upd_buf);
-		}
+		vol->updating = 0;
+		err = to_write;
+		vfree(vol->upd_buf);
 	}
 
 	return err;
diff -Nur linux-2.6.32-orig/drivers/mtd/ubi/vtbl.c iDroid-Project-kernel_common-9e90fd2/drivers/mtd/ubi/vtbl.c
--- linux-2.6.32-orig/drivers/mtd/ubi/vtbl.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/mtd/ubi/vtbl.c	2010-11-18 21:05:30.000000000 +0600
@@ -566,6 +566,7 @@
 		vol->reserved_pebs = be32_to_cpu(vtbl[i].reserved_pebs);
 		vol->alignment = be32_to_cpu(vtbl[i].alignment);
 		vol->data_pad = be32_to_cpu(vtbl[i].data_pad);
+		vol->upd_marker = vtbl[i].upd_marker;
 		vol->vol_type = vtbl[i].vol_type == UBI_VID_DYNAMIC ?
 					UBI_DYNAMIC_VOLUME : UBI_STATIC_VOLUME;
 		vol->name_len = be16_to_cpu(vtbl[i].name_len);
diff -Nur linux-2.6.32-orig/drivers/net/atl1c/atl1c.h iDroid-Project-kernel_common-9e90fd2/drivers/net/atl1c/atl1c.h
--- linux-2.6.32-orig/drivers/net/atl1c/atl1c.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/atl1c/atl1c.h	2010-11-18 21:05:30.000000000 +0600
@@ -534,6 +534,9 @@
 #define __AT_TESTING        0x0001
 #define __AT_RESETTING      0x0002
 #define __AT_DOWN           0x0003
+	u8 work_event;
+#define ATL1C_WORK_EVENT_RESET 		0x01
+#define ATL1C_WORK_EVENT_LINK_CHANGE	0x02
 	u32 msg_enable;
 
 	bool have_msi;
@@ -545,8 +548,7 @@
 	spinlock_t tx_lock;
 	atomic_t irq_sem;
 
-	struct work_struct reset_task;
-	struct work_struct link_chg_task;
+	struct work_struct common_task;
 	struct timer_list watchdog_timer;
 	struct timer_list phy_config_timer;
 
diff -Nur linux-2.6.32-orig/drivers/net/atl1c/atl1c_main.c iDroid-Project-kernel_common-9e90fd2/drivers/net/atl1c/atl1c_main.c
--- linux-2.6.32-orig/drivers/net/atl1c/atl1c_main.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/atl1c/atl1c_main.c	2010-11-18 21:05:30.000000000 +0600
@@ -198,27 +198,12 @@
 
 void atl1c_reinit_locked(struct atl1c_adapter *adapter)
 {
-
 	WARN_ON(in_interrupt());
 	atl1c_down(adapter);
 	atl1c_up(adapter);
 	clear_bit(__AT_RESETTING, &adapter->flags);
 }
 
-static void atl1c_reset_task(struct work_struct *work)
-{
-	struct atl1c_adapter *adapter;
-	struct net_device *netdev;
-
-	adapter = container_of(work, struct atl1c_adapter, reset_task);
-	netdev = adapter->netdev;
-
-	netif_device_detach(netdev);
-	atl1c_down(adapter);
-	atl1c_up(adapter);
-	netif_device_attach(netdev);
-}
-
 static void atl1c_check_link_status(struct atl1c_adapter *adapter)
 {
 	struct atl1c_hw *hw = &adapter->hw;
@@ -275,18 +260,6 @@
 	}
 }
 
-/*
- * atl1c_link_chg_task - deal with link change event Out of interrupt context
- * @netdev: network interface device structure
- */
-static void atl1c_link_chg_task(struct work_struct *work)
-{
-	struct atl1c_adapter *adapter;
-
-	adapter = container_of(work, struct atl1c_adapter, link_chg_task);
-	atl1c_check_link_status(adapter);
-}
-
 static void atl1c_link_chg_event(struct atl1c_adapter *adapter)
 {
 	struct net_device *netdev = adapter->netdev;
@@ -311,20 +284,40 @@
 			adapter->link_speed = SPEED_0;
 		}
 	}
-	schedule_work(&adapter->link_chg_task);
+
+	adapter->work_event |= ATL1C_WORK_EVENT_LINK_CHANGE;
+	schedule_work(&adapter->common_task);
 }
 
-static void atl1c_del_timer(struct atl1c_adapter *adapter)
+static void atl1c_common_task(struct work_struct *work)
 {
-	del_timer_sync(&adapter->phy_config_timer);
+	struct atl1c_adapter *adapter;
+	struct net_device *netdev;
+
+	adapter = container_of(work, struct atl1c_adapter, common_task);
+	netdev = adapter->netdev;
+
+	if (adapter->work_event & ATL1C_WORK_EVENT_RESET) {
+		netif_device_detach(netdev);
+		atl1c_down(adapter);
+		atl1c_up(adapter);
+		netif_device_attach(netdev);
+		return;
+	}
+
+	if (adapter->work_event & ATL1C_WORK_EVENT_LINK_CHANGE)
+		atl1c_check_link_status(adapter);
+
+	return;
 }
 
-static void atl1c_cancel_work(struct atl1c_adapter *adapter)
+
+static void atl1c_del_timer(struct atl1c_adapter *adapter)
 {
-	cancel_work_sync(&adapter->reset_task);
-	cancel_work_sync(&adapter->link_chg_task);
+	del_timer_sync(&adapter->phy_config_timer);
 }
 
+
 /*
  * atl1c_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
@@ -334,7 +327,8 @@
 	struct atl1c_adapter *adapter = netdev_priv(netdev);
 
 	/* Do the reset outside of interrupt context */
-	schedule_work(&adapter->reset_task);
+	adapter->work_event |= ATL1C_WORK_EVENT_RESET;
+	schedule_work(&adapter->common_task);
 }
 
 /*
@@ -1536,7 +1530,8 @@
 			/* reset MAC */
 			hw->intr_mask &= ~ISR_ERROR;
 			AT_WRITE_REG(hw, REG_IMR, hw->intr_mask);
-			schedule_work(&adapter->reset_task);
+			adapter->work_event |= ATL1C_WORK_EVENT_RESET;
+			schedule_work(&adapter->common_task);
 			break;
 		}
 
@@ -2200,8 +2195,7 @@
 	struct net_device *netdev = adapter->netdev;
 
 	atl1c_del_timer(adapter);
-	atl1c_cancel_work(adapter);
-
+	adapter->work_event = 0; /* clear all event */
 	/* signal that we're down so the interrupt handler does not
 	 * reschedule our watchdog timer */
 	set_bit(__AT_DOWN, &adapter->flags);
@@ -2601,8 +2595,8 @@
 			adapter->hw.mac_addr[4], adapter->hw.mac_addr[5]);
 
 	atl1c_hw_set_mac_addr(&adapter->hw);
-	INIT_WORK(&adapter->reset_task, atl1c_reset_task);
-	INIT_WORK(&adapter->link_chg_task, atl1c_link_chg_task);
+	INIT_WORK(&adapter->common_task, atl1c_common_task);
+	adapter->work_event = 0;
 	err = register_netdev(netdev);
 	if (err) {
 		dev_err(&pdev->dev, "register netdevice failed\n");
diff -Nur linux-2.6.32-orig/drivers/net/atl1e/atl1e_main.c iDroid-Project-kernel_common-9e90fd2/drivers/net/atl1e/atl1e_main.c
--- linux-2.6.32-orig/drivers/net/atl1e/atl1e_main.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/atl1e/atl1e_main.c	2010-11-18 21:05:30.000000000 +0600
@@ -1666,41 +1666,6 @@
 			}
 			return 0;
 		}
-
-		if (offload_type & SKB_GSO_TCPV6) {
-			real_len = (((unsigned char *)ipv6_hdr(skb) - skb->data)
-					+ ntohs(ipv6_hdr(skb)->payload_len));
-			if (real_len < skb->len)
-				pskb_trim(skb, real_len);
-
-			/* check payload == 0 byte ? */
-			hdr_len = (skb_transport_offset(skb) + tcp_hdrlen(skb));
-			if (unlikely(skb->len == hdr_len)) {
-				/* only xsum need */
-				dev_warn(&pdev->dev,
-					"IPV6 tso with zero data??\n");
-				goto check_sum;
-			} else {
-				tcp_hdr(skb)->check = ~csum_ipv6_magic(
-						&ipv6_hdr(skb)->saddr,
-						&ipv6_hdr(skb)->daddr,
-						0, IPPROTO_TCP, 0);
-				tpd->word3 |= 1 << TPD_IP_VERSION_SHIFT;
-				hdr_len >>= 1;
-				tpd->word3 |= (hdr_len & TPD_V6_IPHLLO_MASK) <<
-					TPD_V6_IPHLLO_SHIFT;
-				tpd->word3 |= ((hdr_len >> 3) &
-					TPD_V6_IPHLHI_MASK) <<
-					TPD_V6_IPHLHI_SHIFT;
-				tpd->word3 |= (tcp_hdrlen(skb) >> 2 &
-					TPD_TCPHDRLEN_MASK) <<
-					TPD_TCPHDRLEN_SHIFT;
-				tpd->word3 |= ((skb_shinfo(skb)->gso_size) &
-					TPD_MSS_MASK) << TPD_MSS_SHIFT;
-					tpd->word3 |= 1 << TPD_SEGMENT_EN_SHIFT;
-			}
-		}
-		return 0;
 	}
 
 check_sum:
@@ -2289,7 +2254,6 @@
 		NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
 	netdev->features |= NETIF_F_LLTX;
 	netdev->features |= NETIF_F_TSO;
-	netdev->features |= NETIF_F_TSO6;
 
 	return 0;
 }
diff -Nur linux-2.6.32-orig/drivers/net/b44.c iDroid-Project-kernel_common-9e90fd2/drivers/net/b44.c
--- linux-2.6.32-orig/drivers/net/b44.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/b44.c	2010-11-18 21:05:30.000000000 +0600
@@ -1505,8 +1505,7 @@
 		for (k = 0; k< ethaddr_bytes; k++) {
 			ppattern[offset + magicsync +
 				(j * ETH_ALEN) + k] = macaddr[k];
-			len++;
-			set_bit(len, (unsigned long *) pmask);
+			set_bit(len++, (unsigned long *) pmask);
 		}
 	}
 	return len - 1;
diff -Nur linux-2.6.32-orig/drivers/net/bcm63xx_enet.c iDroid-Project-kernel_common-9e90fd2/drivers/net/bcm63xx_enet.c
--- linux-2.6.32-orig/drivers/net/bcm63xx_enet.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/bcm63xx_enet.c	2010-11-18 21:05:30.000000000 +0600
@@ -1248,9 +1248,15 @@
 	drvinfo->n_stats = BCM_ENET_STATS_LEN;
 }
 
-static int bcm_enet_get_stats_count(struct net_device *netdev)
+static int bcm_enet_get_sset_count(struct net_device *netdev,
+					int string_set)
 {
-	return BCM_ENET_STATS_LEN;
+	switch (string_set) {
+	case ETH_SS_STATS:
+		return BCM_ENET_STATS_LEN;
+	default:
+		return -EINVAL;
+	}
 }
 
 static void bcm_enet_get_strings(struct net_device *netdev,
@@ -1476,7 +1482,7 @@
 
 static struct ethtool_ops bcm_enet_ethtool_ops = {
 	.get_strings		= bcm_enet_get_strings,
-	.get_stats_count	= bcm_enet_get_stats_count,
+	.get_sset_count		= bcm_enet_get_sset_count,
 	.get_ethtool_stats      = bcm_enet_get_ethtool_stats,
 	.get_settings		= bcm_enet_get_settings,
 	.set_settings		= bcm_enet_set_settings,
diff -Nur linux-2.6.32-orig/drivers/net/benet/be_cmds.h iDroid-Project-kernel_common-9e90fd2/drivers/net/benet/be_cmds.h
--- linux-2.6.32-orig/drivers/net/benet/be_cmds.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/benet/be_cmds.h	2010-11-18 21:05:30.000000000 +0600
@@ -154,7 +154,8 @@
 	u8 domain;		/* dword 0 */
 	u32 timeout;		/* dword 1 */
 	u32 request_length;	/* dword 2 */
-	u32 rsvd;		/* dword 3 */
+	u8 version;		/* dword 3 */
+	u8 rsvd[3];		/* dword 3 */
 };
 
 #define RESP_HDR_INFO_OPCODE_SHIFT	0	/* bits 0 - 7 */
diff -Nur linux-2.6.32-orig/drivers/net/benet/be.h iDroid-Project-kernel_common-9e90fd2/drivers/net/benet/be.h
--- linux-2.6.32-orig/drivers/net/benet/be.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/benet/be.h	2010-11-18 21:05:30.000000000 +0600
@@ -35,20 +35,31 @@
 #define DRV_VER			"2.101.205"
 #define DRV_NAME		"be2net"
 #define BE_NAME			"ServerEngines BladeEngine2 10Gbps NIC"
+#define BE3_NAME		"ServerEngines BladeEngine3 10Gbps NIC"
 #define OC_NAME			"Emulex OneConnect 10Gbps NIC"
+#define OC_NAME1		"Emulex OneConnect 10Gbps NIC (be3)"
 #define DRV_DESC		BE_NAME "Driver"
 
 #define BE_VENDOR_ID 		0x19a2
 #define BE_DEVICE_ID1		0x211
+#define BE_DEVICE_ID2		0x221
 #define OC_DEVICE_ID1		0x700
 #define OC_DEVICE_ID2		0x701
+#define OC_DEVICE_ID3		0x710
 
 static inline char *nic_name(struct pci_dev *pdev)
 {
-	if (pdev->device == OC_DEVICE_ID1 || pdev->device == OC_DEVICE_ID2)
+	switch (pdev->device) {
+	case OC_DEVICE_ID1:
+	case OC_DEVICE_ID2:
 		return OC_NAME;
-	else
+	case OC_DEVICE_ID3:
+		return OC_NAME1;
+	case BE_DEVICE_ID2:
+		return BE3_NAME;
+	default:
 		return BE_NAME;
+	}
 }
 
 /* Number of bytes of an RX frame that are copied to skb->data */
@@ -261,8 +272,13 @@
 	u32 cap;
 	u32 rx_fc;		/* Rx flow control */
 	u32 tx_fc;		/* Tx flow control */
+	u8 generation;		/* BladeEngine ASIC generation */
 };
 
+/* BladeEngine Generation numbers */
+#define BE_GEN2 2
+#define BE_GEN3 3
+
 extern const struct ethtool_ops be_ethtool_ops;
 
 #define drvr_stats(adapter)		(&adapter->stats.drvr_stats)
diff -Nur linux-2.6.32-orig/drivers/net/benet/be_main.c iDroid-Project-kernel_common-9e90fd2/drivers/net/benet/be_main.c
--- linux-2.6.32-orig/drivers/net/benet/be_main.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/benet/be_main.c	2010-11-18 21:05:30.000000000 +0600
@@ -31,8 +31,10 @@
 
 static DEFINE_PCI_DEVICE_TABLE(be_dev_ids) = {
 	{ PCI_DEVICE(BE_VENDOR_ID, BE_DEVICE_ID1) },
+	{ PCI_DEVICE(BE_VENDOR_ID, BE_DEVICE_ID2) },
 	{ PCI_DEVICE(BE_VENDOR_ID, OC_DEVICE_ID1) },
 	{ PCI_DEVICE(BE_VENDOR_ID, OC_DEVICE_ID2) },
+	{ PCI_DEVICE(BE_VENDOR_ID, OC_DEVICE_ID3) },
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, be_dev_ids);
@@ -1942,6 +1944,7 @@
 static int be_map_pci_bars(struct be_adapter *adapter)
 {
 	u8 __iomem *addr;
+	int pcicfg_reg;
 
 	addr = ioremap_nocache(pci_resource_start(adapter->pdev, 2),
 			pci_resource_len(adapter->pdev, 2));
@@ -1955,8 +1958,13 @@
 		goto pci_map_err;
 	adapter->db = addr;
 
-	addr = ioremap_nocache(pci_resource_start(adapter->pdev, 1),
-			pci_resource_len(adapter->pdev, 1));
+	if (adapter->generation == BE_GEN2)
+		pcicfg_reg = 1;
+	else
+		pcicfg_reg = 0;
+
+	addr = ioremap_nocache(pci_resource_start(adapter->pdev, pcicfg_reg),
+			pci_resource_len(adapter->pdev, pcicfg_reg));
 	if (addr == NULL)
 		goto pci_map_err;
 	adapter->pcicfg = addr;
@@ -2026,6 +2034,7 @@
 	cmd->va = pci_alloc_consistent(adapter->pdev, cmd->size, &cmd->dma);
 	if (cmd->va == NULL)
 		return -1;
+	memset(cmd->va, 0, cmd->size);
 	return 0;
 }
 
@@ -2099,6 +2108,20 @@
 		goto rel_reg;
 	}
 	adapter = netdev_priv(netdev);
+
+	switch (pdev->device) {
+	case BE_DEVICE_ID1:
+	case OC_DEVICE_ID1:
+		adapter->generation = BE_GEN2;
+		break;
+	case BE_DEVICE_ID2:
+	case OC_DEVICE_ID2:
+		adapter->generation = BE_GEN3;
+		break;
+	default:
+		adapter->generation = 0;
+	}
+
 	adapter->pdev = pdev;
 	pci_set_drvdata(pdev, adapter);
 	adapter->netdev = netdev;
diff -Nur linux-2.6.32-orig/drivers/net/e1000/e1000.h iDroid-Project-kernel_common-9e90fd2/drivers/net/e1000/e1000.h
--- linux-2.6.32-orig/drivers/net/e1000/e1000.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/e1000/e1000.h	2010-11-18 21:05:30.000000000 +0600
@@ -326,6 +326,8 @@
 	/* for ioport free */
 	int bars;
 	int need_ioport;
+
+	bool discarding;
 };
 
 enum e1000_state_t {
diff -Nur linux-2.6.32-orig/drivers/net/e1000/e1000_main.c iDroid-Project-kernel_common-9e90fd2/drivers/net/e1000/e1000_main.c
--- linux-2.6.32-orig/drivers/net/e1000/e1000_main.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/e1000/e1000_main.c	2010-11-18 21:05:30.000000000 +0600
@@ -1698,18 +1698,6 @@
 	rctl &= ~E1000_RCTL_SZ_4096;
 	rctl |= E1000_RCTL_BSEX;
 	switch (adapter->rx_buffer_len) {
-		case E1000_RXBUFFER_256:
-			rctl |= E1000_RCTL_SZ_256;
-			rctl &= ~E1000_RCTL_BSEX;
-			break;
-		case E1000_RXBUFFER_512:
-			rctl |= E1000_RCTL_SZ_512;
-			rctl &= ~E1000_RCTL_BSEX;
-			break;
-		case E1000_RXBUFFER_1024:
-			rctl |= E1000_RCTL_SZ_1024;
-			rctl &= ~E1000_RCTL_BSEX;
-			break;
 		case E1000_RXBUFFER_2048:
 		default:
 			rctl |= E1000_RCTL_SZ_2048;
@@ -3154,13 +3142,7 @@
 	 *  however with the new *_jumbo_rx* routines, jumbo receives will use
 	 *  fragmented skbs */
 
-	if (max_frame <= E1000_RXBUFFER_256)
-		adapter->rx_buffer_len = E1000_RXBUFFER_256;
-	else if (max_frame <= E1000_RXBUFFER_512)
-		adapter->rx_buffer_len = E1000_RXBUFFER_512;
-	else if (max_frame <= E1000_RXBUFFER_1024)
-		adapter->rx_buffer_len = E1000_RXBUFFER_1024;
-	else if (max_frame <= E1000_RXBUFFER_2048)
+	if (max_frame <= E1000_RXBUFFER_2048)
 		adapter->rx_buffer_len = E1000_RXBUFFER_2048;
 	else
 #if (PAGE_SIZE >= E1000_RXBUFFER_16384)
@@ -3827,13 +3809,22 @@
 
 		length = le16_to_cpu(rx_desc->length);
 		/* !EOP means multiple descriptors were used to store a single
-		 * packet, also make sure the frame isn't just CRC only */
-		if (unlikely(!(status & E1000_RXD_STAT_EOP) || (length <= 4))) {
+		 * packet, if thats the case we need to toss it.  In fact, we
+		 * to toss every packet with the EOP bit clear and the next
+		 * frame that _does_ have the EOP bit set, as it is by
+		 * definition only a frame fragment
+		 */
+		if (unlikely(!(status & E1000_RXD_STAT_EOP)))
+			adapter->discarding = true;
+
+		if (adapter->discarding) {
 			/* All receives must fit into a single buffer */
 			E1000_DBG("%s: Receive packet consumed multiple"
 				  " buffers\n", netdev->name);
 			/* recycle */
 			buffer_info->skb = skb;
+			if (status & E1000_RXD_STAT_EOP)
+				adapter->discarding = false;
 			goto next_desc;
 		}
 
diff -Nur linux-2.6.32-orig/drivers/net/e1000e/e1000.h iDroid-Project-kernel_common-9e90fd2/drivers/net/e1000e/e1000.h
--- linux-2.6.32-orig/drivers/net/e1000e/e1000.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/e1000e/e1000.h	2010-11-18 21:05:30.000000000 +0600
@@ -417,6 +417,7 @@
 /* CRC Stripping defines */
 #define FLAG2_CRC_STRIPPING               (1 << 0)
 #define FLAG2_HAS_PHY_WAKEUP              (1 << 1)
+#define FLAG2_IS_DISCARDING               (1 << 2)
 
 #define E1000_RX_DESC_PS(R, i)	    \
 	(&(((union e1000_rx_desc_packet_split *)((R).desc))[i]))
diff -Nur linux-2.6.32-orig/drivers/net/e1000e/netdev.c iDroid-Project-kernel_common-9e90fd2/drivers/net/e1000e/netdev.c
--- linux-2.6.32-orig/drivers/net/e1000e/netdev.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/e1000e/netdev.c	2010-11-18 21:05:30.000000000 +0600
@@ -482,14 +482,24 @@
 
 		length = le16_to_cpu(rx_desc->length);
 
-		/* !EOP means multiple descriptors were used to store a single
-		 * packet, also make sure the frame isn't just CRC only */
-		if (!(status & E1000_RXD_STAT_EOP) || (length <= 4)) {
+		/*
+		 * !EOP means multiple descriptors were used to store a single
+		 * packet, if that's the case we need to toss it.  In fact, we
+		 * need to toss every packet with the EOP bit clear and the
+		 * next frame that _does_ have the EOP bit set, as it is by
+		 * definition only a frame fragment
+		 */
+		if (unlikely(!(status & E1000_RXD_STAT_EOP)))
+			adapter->flags2 |= FLAG2_IS_DISCARDING;
+
+		if (adapter->flags2 & FLAG2_IS_DISCARDING) {
 			/* All receives must fit into a single buffer */
 			e_dbg("%s: Receive packet consumed multiple buffers\n",
 			      netdev->name);
 			/* recycle */
 			buffer_info->skb = skb;
+			if (status & E1000_RXD_STAT_EOP)
+				adapter->flags2 &= ~FLAG2_IS_DISCARDING;
 			goto next_desc;
 		}
 
@@ -747,10 +757,16 @@
 				 PCI_DMA_FROMDEVICE);
 		buffer_info->dma = 0;
 
-		if (!(staterr & E1000_RXD_STAT_EOP)) {
+		/* see !EOP comment in other rx routine */
+		if (!(staterr & E1000_RXD_STAT_EOP))
+			adapter->flags2 |= FLAG2_IS_DISCARDING;
+
+		if (adapter->flags2 & FLAG2_IS_DISCARDING) {
 			e_dbg("%s: Packet Split buffers didn't pick up the "
 			      "full packet\n", netdev->name);
 			dev_kfree_skb_irq(skb);
+			if (staterr & E1000_RXD_STAT_EOP)
+				adapter->flags2 &= ~FLAG2_IS_DISCARDING;
 			goto next_desc;
 		}
 
@@ -1120,6 +1136,7 @@
 
 	rx_ring->next_to_clean = 0;
 	rx_ring->next_to_use = 0;
+	adapter->flags2 &= ~FLAG2_IS_DISCARDING;
 
 	writel(0, adapter->hw.hw_addr + rx_ring->head);
 	writel(0, adapter->hw.hw_addr + rx_ring->tail);
@@ -2330,18 +2347,6 @@
 	rctl &= ~E1000_RCTL_SZ_4096;
 	rctl |= E1000_RCTL_BSEX;
 	switch (adapter->rx_buffer_len) {
-	case 256:
-		rctl |= E1000_RCTL_SZ_256;
-		rctl &= ~E1000_RCTL_BSEX;
-		break;
-	case 512:
-		rctl |= E1000_RCTL_SZ_512;
-		rctl &= ~E1000_RCTL_BSEX;
-		break;
-	case 1024:
-		rctl |= E1000_RCTL_SZ_1024;
-		rctl &= ~E1000_RCTL_BSEX;
-		break;
 	case 2048:
 	default:
 		rctl |= E1000_RCTL_SZ_2048;
@@ -4321,13 +4326,7 @@
 	 * fragmented skbs
 	 */
 
-	if (max_frame <= 256)
-		adapter->rx_buffer_len = 256;
-	else if (max_frame <= 512)
-		adapter->rx_buffer_len = 512;
-	else if (max_frame <= 1024)
-		adapter->rx_buffer_len = 1024;
-	else if (max_frame <= 2048)
+	if (max_frame <= 2048)
 		adapter->rx_buffer_len = 2048;
 	else
 		adapter->rx_buffer_len = 4096;
diff -Nur linux-2.6.32-orig/drivers/net/e100.c iDroid-Project-kernel_common-9e90fd2/drivers/net/e100.c
--- linux-2.6.32-orig/drivers/net/e100.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/e100.c	2010-11-18 21:05:30.000000000 +0600
@@ -1817,6 +1817,7 @@
 				  &nic->cbs_dma_addr);
 	if (!nic->cbs)
 		return -ENOMEM;
+	memset(nic->cbs, 0, count * sizeof(struct cb));
 
 	for (cb = nic->cbs, i = 0; i < count; cb++, i++) {
 		cb->next = (i + 1 < count) ? cb + 1 : nic->cbs;
@@ -1825,7 +1826,6 @@
 		cb->dma_addr = nic->cbs_dma_addr + i * sizeof(struct cb);
 		cb->link = cpu_to_le32(nic->cbs_dma_addr +
 			((i+1) % count) * sizeof(struct cb));
-		cb->skb = NULL;
 	}
 
 	nic->cb_to_use = nic->cb_to_send = nic->cb_to_clean = nic->cbs;
diff -Nur linux-2.6.32-orig/drivers/net/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/net/Kconfig
--- linux-2.6.32-orig/drivers/net/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -3113,6 +3113,23 @@
 	  and session setup). One such daemon is OpenL2TP
 	  (http://openl2tp.sourceforge.net/).
 
+config PPPOLAC
+	tristate "PPP on L2TP Access Concentrator"
+	depends on PPP && INET
+	help
+	  L2TP (RFC 2661) is a tunneling protocol widely used in virtual private
+	  networks. This driver handles L2TP data packets between a UDP socket
+	  and a PPP channel, but only permits one session per socket. Thus it is
+	  fairly simple and suited for clients.
+
+config PPPOPNS
+	tristate "PPP on PPTP Network Server"
+	depends on PPP && INET
+	help
+	  PPTP (RFC 2637) is a tunneling protocol widely used in virtual private
+	  networks. This driver handles PPTP data packets between a RAW socket
+	  and a PPP channel. It is fairly simple and easy to use.
+
 config SLIP
 	tristate "SLIP (serial line) support"
 	---help---
diff -Nur linux-2.6.32-orig/drivers/net/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/net/Makefile
--- linux-2.6.32-orig/drivers/net/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -158,6 +158,8 @@
 obj-$(CONFIG_PPP_MPPE) += ppp_mppe.o
 obj-$(CONFIG_PPPOE) += pppox.o pppoe.o
 obj-$(CONFIG_PPPOL2TP) += pppox.o pppol2tp.o
+obj-$(CONFIG_PPPOLAC) += pppox.o pppolac.o
+obj-$(CONFIG_PPPOPNS) += pppox.o pppopns.o
 
 obj-$(CONFIG_SLIP) += slip.o
 obj-$(CONFIG_SLHC) += slhc.o
diff -Nur linux-2.6.32-orig/drivers/net/pppolac.c iDroid-Project-kernel_common-9e90fd2/drivers/net/pppolac.c
--- linux-2.6.32-orig/drivers/net/pppolac.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/pppolac.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,380 @@
+/* drivers/net/pppolac.c
+ *
+ * Driver for PPP on L2TP Access Concentrator / PPPoLAC Socket (RFC 2661)
+ *
+ * Copyright (C) 2009 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/* This driver handles L2TP data packets between a UDP socket and a PPP channel.
+ * To keep things simple, only one session per socket is permitted. Packets are
+ * sent via the socket, so it must keep connected to the same address. One must
+ * not set sequencing in ICCN but let LNS controll it. Currently this driver
+ * only works on IPv4 due to the lack of UDP encapsulation support in IPv6. */
+
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/skbuff.h>
+#include <linux/file.h>
+#include <linux/netdevice.h>
+#include <linux/net.h>
+#include <linux/udp.h>
+#include <linux/ppp_defs.h>
+#include <linux/if_ppp.h>
+#include <linux/if_pppox.h>
+#include <linux/ppp_channel.h>
+#include <net/tcp_states.h>
+#include <asm/uaccess.h>
+
+#define L2TP_CONTROL_BIT	0x80
+#define L2TP_LENGTH_BIT		0x40
+#define L2TP_SEQUENCE_BIT	0x08
+#define L2TP_OFFSET_BIT		0x02
+#define L2TP_VERSION		0x02
+#define L2TP_VERSION_MASK	0x0F
+
+#define PPP_ADDR	0xFF
+#define PPP_CTRL	0x03
+
+union unaligned {
+	__u32 u32;
+} __attribute__((packed));
+
+static inline union unaligned *unaligned(void *ptr)
+{
+	return (union unaligned *)ptr;
+}
+
+static int pppolac_recv_core(struct sock *sk_udp, struct sk_buff *skb)
+{
+	struct sock *sk = (struct sock *)sk_udp->sk_user_data;
+	struct pppolac_opt *opt = &pppox_sk(sk)->proto.lac;
+	__u8 bits;
+	__u8 *ptr;
+
+	/* Drop the packet if it is too short. */
+	if (skb->len < sizeof(struct udphdr) + 6)
+		goto drop;
+
+	/* Put it back if it is a control packet. */
+	if (skb->data[sizeof(struct udphdr)] & L2TP_CONTROL_BIT)
+		return opt->backlog_rcv(sk_udp, skb);
+
+	/* Skip UDP header. */
+	skb_pull(skb, sizeof(struct udphdr));
+
+	/* Check the version. */
+	if ((skb->data[1] & L2TP_VERSION_MASK) != L2TP_VERSION)
+		goto drop;
+	bits = skb->data[0];
+	ptr = &skb->data[2];
+
+	/* Check the length if it is present. */
+	if (bits & L2TP_LENGTH_BIT) {
+		if ((ptr[0] << 8 | ptr[1]) != skb->len)
+			goto drop;
+		ptr += 2;
+	}
+
+	/* Skip all fields including optional ones. */
+	if (!skb_pull(skb, 6 + (bits & L2TP_SEQUENCE_BIT ? 4 : 0) +
+			(bits & L2TP_LENGTH_BIT ? 2 : 0) +
+			(bits & L2TP_OFFSET_BIT ? 2 : 0)))
+		goto drop;
+
+	/* Skip the offset padding if it is present. */
+	if (bits & L2TP_OFFSET_BIT &&
+			!skb_pull(skb, skb->data[-2] << 8 | skb->data[-1]))
+		goto drop;
+
+	/* Check the tunnel and the session. */
+	if (unaligned(ptr)->u32 != opt->local)
+		goto drop;
+
+	/* Check the sequence if it is present. According to RFC 2661 section
+	 * 5.4, the only thing to do is to update opt->sequencing. */
+	opt->sequencing = bits & L2TP_SEQUENCE_BIT;
+
+	/* Skip PPP address and control if they are present. */
+	if (skb->len >= 2 && skb->data[0] == PPP_ADDR &&
+			skb->data[1] == PPP_CTRL)
+		skb_pull(skb, 2);
+
+	/* Fix PPP protocol if it is compressed. */
+	if (skb->len >= 1 && skb->data[0] & 1)
+		skb_push(skb, 1)[0] = 0;
+
+	/* Finally, deliver the packet to PPP channel. */
+	skb_orphan(skb);
+	ppp_input(&pppox_sk(sk)->chan, skb);
+	return NET_RX_SUCCESS;
+drop:
+	kfree_skb(skb);
+	return NET_RX_DROP;
+}
+
+static int pppolac_recv(struct sock *sk_udp, struct sk_buff *skb)
+{
+	sock_hold(sk_udp);
+	sk_receive_skb(sk_udp, skb, 0);
+	return 0;
+}
+
+static struct sk_buff_head delivery_queue;
+
+static void pppolac_xmit_core(struct work_struct *delivery_work)
+{
+	mm_segment_t old_fs = get_fs();
+	struct sk_buff *skb;
+
+	set_fs(KERNEL_DS);
+	while ((skb = skb_dequeue(&delivery_queue))) {
+		struct sock *sk_udp = skb->sk;
+		struct kvec iov = {.iov_base = skb->data, .iov_len = skb->len};
+		struct msghdr msg = {
+			.msg_iov = (struct iovec *)&iov,
+			.msg_iovlen = 1,
+			.msg_flags = MSG_NOSIGNAL | MSG_DONTWAIT,
+		};
+		sk_udp->sk_prot->sendmsg(NULL, sk_udp, &msg, skb->len);
+		kfree_skb(skb);
+	}
+	set_fs(old_fs);
+}
+
+static DECLARE_WORK(delivery_work, pppolac_xmit_core);
+
+static int pppolac_xmit(struct ppp_channel *chan, struct sk_buff *skb)
+{
+	struct sock *sk_udp = (struct sock *)chan->private;
+	struct pppolac_opt *opt = &pppox_sk(sk_udp->sk_user_data)->proto.lac;
+
+	/* Install PPP address and control. */
+	skb_push(skb, 2);
+	skb->data[0] = PPP_ADDR;
+	skb->data[1] = PPP_CTRL;
+
+	/* Install L2TP header. */
+	if (opt->sequencing) {
+		skb_push(skb, 10);
+		skb->data[0] = L2TP_SEQUENCE_BIT;
+		skb->data[6] = opt->sequence >> 8;
+		skb->data[7] = opt->sequence;
+		skb->data[8] = 0;
+		skb->data[9] = 0;
+		opt->sequence++;
+	} else {
+		skb_push(skb, 6);
+		skb->data[0] = 0;
+	}
+	skb->data[1] = L2TP_VERSION;
+	unaligned(&skb->data[2])->u32 = opt->remote;
+
+	/* Now send the packet via the delivery queue. */
+	skb_set_owner_w(skb, sk_udp);
+	skb_queue_tail(&delivery_queue, skb);
+	schedule_work(&delivery_work);
+	return 1;
+}
+
+/******************************************************************************/
+
+static struct ppp_channel_ops pppolac_channel_ops = {
+	.start_xmit = pppolac_xmit,
+};
+
+static int pppolac_connect(struct socket *sock, struct sockaddr *useraddr,
+	int addrlen, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct pppox_sock *po = pppox_sk(sk);
+	struct sockaddr_pppolac *addr = (struct sockaddr_pppolac *)useraddr;
+	struct socket *sock_udp = NULL;
+	struct sock *sk_udp;
+	int error;
+
+	if (addrlen != sizeof(struct sockaddr_pppolac) ||
+			!addr->local.tunnel || !addr->local.session ||
+			!addr->remote.tunnel || !addr->remote.session) {
+		return -EINVAL;
+	}
+
+	lock_sock(sk);
+	error = -EALREADY;
+	if (sk->sk_state != PPPOX_NONE)
+		goto out;
+
+	sock_udp = sockfd_lookup(addr->udp_socket, &error);
+	if (!sock_udp)
+		goto out;
+	sk_udp = sock_udp->sk;
+	lock_sock(sk_udp);
+
+	/* Remove this check when IPv6 supports UDP encapsulation. */
+	error = -EAFNOSUPPORT;
+	if (sk_udp->sk_family != AF_INET)
+		goto out;
+	error = -EPROTONOSUPPORT;
+	if (sk_udp->sk_protocol != IPPROTO_UDP)
+		goto out;
+	error = -EDESTADDRREQ;
+	if (sk_udp->sk_state != TCP_ESTABLISHED)
+		goto out;
+	error = -EBUSY;
+	if (udp_sk(sk_udp)->encap_type || sk_udp->sk_user_data)
+		goto out;
+	if (!sk_udp->sk_bound_dev_if) {
+		struct dst_entry *dst = sk_dst_get(sk_udp);
+		error = -ENODEV;
+		if (!dst)
+			goto out;
+		sk_udp->sk_bound_dev_if = dst->dev->ifindex;
+		dst_release(dst);
+	}
+
+	po->chan.hdrlen = 12;
+	po->chan.private = sk_udp;
+	po->chan.ops = &pppolac_channel_ops;
+	po->chan.mtu = PPP_MTU - 80;
+	po->proto.lac.local = unaligned(&addr->local)->u32;
+	po->proto.lac.remote = unaligned(&addr->remote)->u32;
+	po->proto.lac.backlog_rcv = sk_udp->sk_backlog_rcv;
+
+	error = ppp_register_channel(&po->chan);
+	if (error)
+		goto out;
+
+	sk->sk_state = PPPOX_CONNECTED;
+	udp_sk(sk_udp)->encap_type = UDP_ENCAP_L2TPINUDP;
+	udp_sk(sk_udp)->encap_rcv = pppolac_recv;
+	sk_udp->sk_backlog_rcv = pppolac_recv_core;
+	sk_udp->sk_user_data = sk;
+out:
+	if (sock_udp) {
+		release_sock(sk_udp);
+		if (error)
+			sockfd_put(sock_udp);
+	}
+	release_sock(sk);
+	return error;
+}
+
+static int pppolac_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	if (!sk)
+		return 0;
+
+	lock_sock(sk);
+	if (sock_flag(sk, SOCK_DEAD)) {
+		release_sock(sk);
+		return -EBADF;
+	}
+
+	if (sk->sk_state != PPPOX_NONE) {
+		struct sock *sk_udp = (struct sock *)pppox_sk(sk)->chan.private;
+		lock_sock(sk_udp);
+		pppox_unbind_sock(sk);
+		udp_sk(sk_udp)->encap_type = 0;
+		udp_sk(sk_udp)->encap_rcv = NULL;
+		sk_udp->sk_backlog_rcv = pppox_sk(sk)->proto.lac.backlog_rcv;
+		sk_udp->sk_user_data = NULL;
+		release_sock(sk_udp);
+		sockfd_put(sk_udp->sk_socket);
+	}
+
+	sock_orphan(sk);
+	sock->sk = NULL;
+	release_sock(sk);
+	sock_put(sk);
+	return 0;
+}
+
+/******************************************************************************/
+
+static struct proto pppolac_proto = {
+	.name = "PPPOLAC",
+	.owner = THIS_MODULE,
+	.obj_size = sizeof(struct pppox_sock),
+};
+
+static struct proto_ops pppolac_proto_ops = {
+	.family = PF_PPPOX,
+	.owner = THIS_MODULE,
+	.release = pppolac_release,
+	.bind = sock_no_bind,
+	.connect = pppolac_connect,
+	.socketpair = sock_no_socketpair,
+	.accept = sock_no_accept,
+	.getname = sock_no_getname,
+	.poll = sock_no_poll,
+	.ioctl = pppox_ioctl,
+	.listen = sock_no_listen,
+	.shutdown = sock_no_shutdown,
+	.setsockopt = sock_no_setsockopt,
+	.getsockopt = sock_no_getsockopt,
+	.sendmsg = sock_no_sendmsg,
+	.recvmsg = sock_no_recvmsg,
+	.mmap = sock_no_mmap,
+};
+
+static int pppolac_create(struct net *net, struct socket *sock)
+{
+	struct sock *sk;
+
+	sk = sk_alloc(net, PF_PPPOX, GFP_KERNEL, &pppolac_proto);
+	if (!sk)
+		return -ENOMEM;
+
+	sock_init_data(sock, sk);
+	sock->state = SS_UNCONNECTED;
+	sock->ops = &pppolac_proto_ops;
+	sk->sk_protocol = PX_PROTO_OLAC;
+	sk->sk_state = PPPOX_NONE;
+	return 0;
+}
+
+/******************************************************************************/
+
+static struct pppox_proto pppolac_pppox_proto = {
+	.create = pppolac_create,
+	.owner = THIS_MODULE,
+};
+
+static int __init pppolac_init(void)
+{
+	int error;
+
+	error = proto_register(&pppolac_proto, 0);
+	if (error)
+		return error;
+
+	error = register_pppox_proto(PX_PROTO_OLAC, &pppolac_pppox_proto);
+	if (error)
+		proto_unregister(&pppolac_proto);
+	else
+		skb_queue_head_init(&delivery_queue);
+	return error;
+}
+
+static void __exit pppolac_exit(void)
+{
+	unregister_pppox_proto(PX_PROTO_OLAC);
+	proto_unregister(&pppolac_proto);
+}
+
+module_init(pppolac_init);
+module_exit(pppolac_exit);
+
+MODULE_DESCRIPTION("PPP on L2TP Access Concentrator (PPPoLAC)");
+MODULE_AUTHOR("Chia-chi Yeh <chiachi@android.com>");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/drivers/net/pppopns.c iDroid-Project-kernel_common-9e90fd2/drivers/net/pppopns.c
--- linux-2.6.32-orig/drivers/net/pppopns.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/pppopns.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,357 @@
+/* drivers/net/pppopns.c
+ *
+ * Driver for PPP on PPTP Network Server / PPPoPNS Socket (RFC 2637)
+ *
+ * Copyright (C) 2009 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/* This driver handles PPTP data packets between a RAW socket and a PPP channel.
+ * The socket is created in the kernel space and connected to the same address
+ * of the control socket. To keep things simple, packets are always sent with
+ * sequence but without acknowledgement. This driver should work on both IPv4
+ * and IPv6. */
+
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/skbuff.h>
+#include <linux/file.h>
+#include <linux/netdevice.h>
+#include <linux/net.h>
+#include <linux/ppp_defs.h>
+#include <linux/if.h>
+#include <linux/if_ppp.h>
+#include <linux/if_pppox.h>
+#include <linux/ppp_channel.h>
+#include <asm/uaccess.h>
+
+#define GRE_HEADER_SIZE		8
+
+#define PPTP_GRE_BITS		htons(0x2001)
+#define PPTP_GRE_BITS_MASK	htons(0xEF7F)
+#define PPTP_GRE_SEQ_BIT	htons(0x1000)
+#define PPTP_GRE_ACK_BIT	htons(0x0080)
+#define PPTP_GRE_TYPE		htons(0x880B)
+
+#define PPP_ADDR	0xFF
+#define PPP_CTRL	0x03
+
+struct header {
+	__u16	bits;
+	__u16	type;
+	__u16	length;
+	__u16	call;
+	__u32	sequence;
+} __attribute__((packed));
+
+static int pppopns_recv_core(struct sock *sk_raw, struct sk_buff *skb)
+{
+	struct sock *sk = (struct sock *)sk_raw->sk_user_data;
+	struct pppopns_opt *opt = &pppox_sk(sk)->proto.pns;
+	struct header *hdr;
+
+	/* Skip transport header */
+	skb_pull(skb, skb_transport_header(skb) - skb->data);
+
+	/* Drop the packet if it is too short. */
+	if (skb->len < GRE_HEADER_SIZE)
+		goto drop;
+
+	/* Check the header. */
+	hdr = (struct header *)skb->data;
+	if (hdr->type != PPTP_GRE_TYPE || hdr->call != opt->local ||
+			(hdr->bits & PPTP_GRE_BITS_MASK) != PPTP_GRE_BITS)
+		goto drop;
+
+	/* Skip all fields including optional ones. */
+	if (!skb_pull(skb, GRE_HEADER_SIZE +
+			(hdr->bits & PPTP_GRE_SEQ_BIT ? 4 : 0) +
+			(hdr->bits & PPTP_GRE_ACK_BIT ? 4 : 0)))
+		goto drop;
+
+	/* Check the length. */
+	if (skb->len != ntohs(hdr->length))
+		goto drop;
+
+	/* Skip PPP address and control if they are present. */
+	if (skb->len >= 2 && skb->data[0] == PPP_ADDR &&
+			skb->data[1] == PPP_CTRL)
+		skb_pull(skb, 2);
+
+	/* Fix PPP protocol if it is compressed. */
+	if (skb->len >= 1 && skb->data[0] & 1)
+		skb_push(skb, 1)[0] = 0;
+
+	/* Finally, deliver the packet to PPP channel. */
+	skb_orphan(skb);
+	ppp_input(&pppox_sk(sk)->chan, skb);
+	return NET_RX_SUCCESS;
+drop:
+	kfree_skb(skb);
+	return NET_RX_DROP;
+}
+
+static void pppopns_recv(struct sock *sk_raw, int length)
+{
+	struct sk_buff *skb;
+	while ((skb = skb_dequeue(&sk_raw->sk_receive_queue))) {
+		sock_hold(sk_raw);
+		sk_receive_skb(sk_raw, skb, 0);
+	}
+}
+
+static struct sk_buff_head delivery_queue;
+
+static void pppopns_xmit_core(struct work_struct *delivery_work)
+{
+	mm_segment_t old_fs = get_fs();
+	struct sk_buff *skb;
+
+	set_fs(KERNEL_DS);
+	while ((skb = skb_dequeue(&delivery_queue))) {
+		struct sock *sk_raw = skb->sk;
+		struct kvec iov = {.iov_base = skb->data, .iov_len = skb->len};
+		struct msghdr msg = {
+			.msg_iov = (struct iovec *)&iov,
+			.msg_iovlen = 1,
+			.msg_flags = MSG_NOSIGNAL | MSG_DONTWAIT,
+		};
+		sk_raw->sk_prot->sendmsg(NULL, sk_raw, &msg, skb->len);
+		kfree_skb(skb);
+	}
+	set_fs(old_fs);
+}
+
+static DECLARE_WORK(delivery_work, pppopns_xmit_core);
+
+static int pppopns_xmit(struct ppp_channel *chan, struct sk_buff *skb)
+{
+	struct sock *sk_raw = (struct sock *)chan->private;
+	struct pppopns_opt *opt = &pppox_sk(sk_raw->sk_user_data)->proto.pns;
+	struct header *hdr;
+	__u16 length;
+
+	/* Install PPP address and control. */
+	skb_push(skb, 2);
+	skb->data[0] = PPP_ADDR;
+	skb->data[1] = PPP_CTRL;
+	length = skb->len;
+
+	/* Install PPTP GRE header. */
+	hdr = (struct header *)skb_push(skb, 12);
+	hdr->bits = PPTP_GRE_BITS | PPTP_GRE_SEQ_BIT;
+	hdr->type = PPTP_GRE_TYPE;
+	hdr->length = htons(length);
+	hdr->call = opt->remote;
+	hdr->sequence = htonl(opt->sequence);
+	opt->sequence++;
+
+	/* Now send the packet via the delivery queue. */
+	skb_set_owner_w(skb, sk_raw);
+	skb_queue_tail(&delivery_queue, skb);
+	schedule_work(&delivery_work);
+	return 1;
+}
+
+/******************************************************************************/
+
+static struct ppp_channel_ops pppopns_channel_ops = {
+	.start_xmit = pppopns_xmit,
+};
+
+static int pppopns_connect(struct socket *sock, struct sockaddr *useraddr,
+	int addrlen, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct pppox_sock *po = pppox_sk(sk);
+	struct sockaddr_pppopns *addr = (struct sockaddr_pppopns *)useraddr;
+	struct sockaddr_storage ss;
+	struct socket *sock_tcp = NULL;
+	struct socket *sock_raw = NULL;
+	struct sock *sk_tcp;
+	struct sock *sk_raw;
+	int error;
+
+	if (addrlen != sizeof(struct sockaddr_pppopns))
+		return -EINVAL;
+
+	lock_sock(sk);
+	error = -EALREADY;
+	if (sk->sk_state != PPPOX_NONE)
+		goto out;
+
+	sock_tcp = sockfd_lookup(addr->tcp_socket, &error);
+	if (!sock_tcp)
+		goto out;
+	sk_tcp = sock_tcp->sk;
+	error = -EPROTONOSUPPORT;
+	if (sk_tcp->sk_protocol != IPPROTO_TCP)
+		goto out;
+	addrlen = sizeof(struct sockaddr_storage);
+	error = kernel_getpeername(sock_tcp, (struct sockaddr *)&ss, &addrlen);
+	if (error)
+		goto out;
+	if (!sk_tcp->sk_bound_dev_if) {
+		struct dst_entry *dst = sk_dst_get(sk_tcp);
+		error = -ENODEV;
+		if (!dst)
+			goto out;
+		sk_tcp->sk_bound_dev_if = dst->dev->ifindex;
+		dst_release(dst);
+	}
+
+	error = sock_create(ss.ss_family, SOCK_RAW, IPPROTO_GRE, &sock_raw);
+	if (error)
+		goto out;
+	sk_raw = sock_raw->sk;
+	sk_raw->sk_bound_dev_if = sk_tcp->sk_bound_dev_if;
+	error = kernel_connect(sock_raw, (struct sockaddr *)&ss, addrlen, 0);
+	if (error)
+		goto out;
+
+	po->chan.hdrlen = 14;
+	po->chan.private = sk_raw;
+	po->chan.ops = &pppopns_channel_ops;
+	po->chan.mtu = PPP_MTU - 80;
+	po->proto.pns.local = addr->local;
+	po->proto.pns.remote = addr->remote;
+	po->proto.pns.data_ready = sk_raw->sk_data_ready;
+	po->proto.pns.backlog_rcv = sk_raw->sk_backlog_rcv;
+
+	error = ppp_register_channel(&po->chan);
+	if (error)
+		goto out;
+
+	sk->sk_state = PPPOX_CONNECTED;
+	lock_sock(sk_raw);
+	sk_raw->sk_data_ready = pppopns_recv;
+	sk_raw->sk_backlog_rcv = pppopns_recv_core;
+	sk_raw->sk_user_data = sk;
+	release_sock(sk_raw);
+out:
+	if (sock_tcp)
+		sockfd_put(sock_tcp);
+	if (error && sock_raw)
+		sock_release(sock_raw);
+	release_sock(sk);
+	return error;
+}
+
+static int pppopns_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	if (!sk)
+		return 0;
+
+	lock_sock(sk);
+	if (sock_flag(sk, SOCK_DEAD)) {
+		release_sock(sk);
+		return -EBADF;
+	}
+
+	if (sk->sk_state != PPPOX_NONE) {
+		struct sock *sk_raw = (struct sock *)pppox_sk(sk)->chan.private;
+		lock_sock(sk_raw);
+		pppox_unbind_sock(sk);
+		sk_raw->sk_data_ready = pppox_sk(sk)->proto.pns.data_ready;
+		sk_raw->sk_backlog_rcv = pppox_sk(sk)->proto.pns.backlog_rcv;
+		sk_raw->sk_user_data = NULL;
+		release_sock(sk_raw);
+		sock_release(sk_raw->sk_socket);
+	}
+
+	sock_orphan(sk);
+	sock->sk = NULL;
+	release_sock(sk);
+	sock_put(sk);
+	return 0;
+}
+
+/******************************************************************************/
+
+static struct proto pppopns_proto = {
+	.name = "PPPOPNS",
+	.owner = THIS_MODULE,
+	.obj_size = sizeof(struct pppox_sock),
+};
+
+static struct proto_ops pppopns_proto_ops = {
+	.family = PF_PPPOX,
+	.owner = THIS_MODULE,
+	.release = pppopns_release,
+	.bind = sock_no_bind,
+	.connect = pppopns_connect,
+	.socketpair = sock_no_socketpair,
+	.accept = sock_no_accept,
+	.getname = sock_no_getname,
+	.poll = sock_no_poll,
+	.ioctl = pppox_ioctl,
+	.listen = sock_no_listen,
+	.shutdown = sock_no_shutdown,
+	.setsockopt = sock_no_setsockopt,
+	.getsockopt = sock_no_getsockopt,
+	.sendmsg = sock_no_sendmsg,
+	.recvmsg = sock_no_recvmsg,
+	.mmap = sock_no_mmap,
+};
+
+static int pppopns_create(struct net *net, struct socket *sock)
+{
+	struct sock *sk;
+
+	sk = sk_alloc(net, PF_PPPOX, GFP_KERNEL, &pppopns_proto);
+	if (!sk)
+		return -ENOMEM;
+
+	sock_init_data(sock, sk);
+	sock->state = SS_UNCONNECTED;
+	sock->ops = &pppopns_proto_ops;
+	sk->sk_protocol = PX_PROTO_OPNS;
+	sk->sk_state = PPPOX_NONE;
+	return 0;
+}
+
+/******************************************************************************/
+
+static struct pppox_proto pppopns_pppox_proto = {
+	.create = pppopns_create,
+	.owner = THIS_MODULE,
+};
+
+static int __init pppopns_init(void)
+{
+	int error;
+
+	error = proto_register(&pppopns_proto, 0);
+	if (error)
+		return error;
+
+	error = register_pppox_proto(PX_PROTO_OPNS, &pppopns_pppox_proto);
+	if (error)
+		proto_unregister(&pppopns_proto);
+	else
+		skb_queue_head_init(&delivery_queue);
+	return error;
+}
+
+static void __exit pppopns_exit(void)
+{
+	unregister_pppox_proto(PX_PROTO_OPNS);
+	proto_unregister(&pppopns_proto);
+}
+
+module_init(pppopns_init);
+module_exit(pppopns_exit);
+
+MODULE_DESCRIPTION("PPP on PPTP Network Server (PPPoPNS)");
+MODULE_AUTHOR("Chia-chi Yeh <chiachi@android.com>");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/drivers/net/qlge/qlge_main.c iDroid-Project-kernel_common-9e90fd2/drivers/net/qlge/qlge_main.c
--- linux-2.6.32-orig/drivers/net/qlge/qlge_main.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/qlge/qlge_main.c	2010-11-18 21:05:30.000000000 +0600
@@ -3310,10 +3310,8 @@
 
 	/* Initialize the port and set the max framesize. */
 	status = qdev->nic_ops->port_initialize(qdev);
-       if (status) {
-              QPRINTK(qdev, IFUP, ERR, "Failed to start port.\n");
-              return status;
-       }
+	if (status)
+		QPRINTK(qdev, IFUP, ERR, "Failed to start port.\n");
 
 	/* Set up the MAC address and frame routing filter. */
 	status = ql_cam_route_initialize(qdev);
@@ -3714,9 +3712,6 @@
 	struct sockaddr *addr = p;
 	int status;
 
-	if (netif_running(ndev))
-		return -EBUSY;
-
 	if (!is_valid_ether_addr(addr->sa_data))
 		return -EADDRNOTAVAIL;
 	memcpy(ndev->dev_addr, addr->sa_data, ndev->addr_len);
@@ -3868,8 +3863,7 @@
 				    struct net_device *ndev, int cards_found)
 {
 	struct ql_adapter *qdev = netdev_priv(ndev);
-	int pos, err = 0;
-	u16 val16;
+	int err = 0;
 
 	memset((void *)qdev, 0, sizeof(*qdev));
 	err = pci_enable_device(pdev);
@@ -3881,18 +3875,12 @@
 	qdev->ndev = ndev;
 	qdev->pdev = pdev;
 	pci_set_drvdata(pdev, ndev);
-	pos = pci_find_capability(pdev, PCI_CAP_ID_EXP);
-	if (pos <= 0) {
-		dev_err(&pdev->dev, PFX "Cannot find PCI Express capability, "
-			"aborting.\n");
-		return pos;
-	} else {
-		pci_read_config_word(pdev, pos + PCI_EXP_DEVCTL, &val16);
-		val16 &= ~PCI_EXP_DEVCTL_NOSNOOP_EN;
-		val16 |= (PCI_EXP_DEVCTL_CERE |
-			  PCI_EXP_DEVCTL_NFERE |
-			  PCI_EXP_DEVCTL_FERE | PCI_EXP_DEVCTL_URRE);
-		pci_write_config_word(pdev, pos + PCI_EXP_DEVCTL, val16);
+
+	/* Set PCIe read request size */
+	err = pcie_set_readrq(pdev, 4096);
+	if (err) {
+		dev_err(&pdev->dev, "Set readrq failed.\n");
+		goto err_out;
 	}
 
 	err = pci_request_regions(pdev, DRV_NAME);
diff -Nur linux-2.6.32-orig/drivers/net/qlge/qlge_mpi.c iDroid-Project-kernel_common-9e90fd2/drivers/net/qlge/qlge_mpi.c
--- linux-2.6.32-orig/drivers/net/qlge/qlge_mpi.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/qlge/qlge_mpi.c	2010-11-18 21:05:30.000000000 +0600
@@ -446,6 +446,9 @@
 		ql_aen_lost(qdev, mbcp);
 		break;
 
+	case AEN_DCBX_CHG:
+		/* Need to support AEN 8110 */
+		break;
 	default:
 		QPRINTK(qdev, DRV, ERR,
 			"Unsupported AE %.08x.\n", mbcp->mbox_out[0]);
diff -Nur linux-2.6.32-orig/drivers/net/sfc/tx.c iDroid-Project-kernel_common-9e90fd2/drivers/net/sfc/tx.c
--- linux-2.6.32-orig/drivers/net/sfc/tx.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/sfc/tx.c	2010-11-18 21:05:30.000000000 +0600
@@ -821,8 +821,6 @@
 					   tx_queue->efx->type->txd_ring_mask];
 		efx_tsoh_free(tx_queue, buffer);
 		EFX_BUG_ON_PARANOID(buffer->skb);
-		buffer->len = 0;
-		buffer->continuation = true;
 		if (buffer->unmap_len) {
 			unmap_addr = (buffer->dma_addr + buffer->len -
 				      buffer->unmap_len);
@@ -836,6 +834,8 @@
 					       PCI_DMA_TODEVICE);
 			buffer->unmap_len = 0;
 		}
+		buffer->len = 0;
+		buffer->continuation = true;
 	}
 }
 
diff -Nur linux-2.6.32-orig/drivers/net/sky2.c iDroid-Project-kernel_common-9e90fd2/drivers/net/sky2.c
--- linux-2.6.32-orig/drivers/net/sky2.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/sky2.c	2010-11-18 21:05:30.000000000 +0600
@@ -1806,7 +1806,8 @@
 	sky2->tx_cons = idx;
 	smp_mb();
 
-	if (tx_avail(sky2) > MAX_SKB_TX_LE + 4)
+	/* Wake unless it's detached, and called e.g. from sky2_down() */
+	if (tx_avail(sky2) > MAX_SKB_TX_LE + 4 && netif_device_present(dev))
 		netif_wake_queue(dev);
 }
 
diff -Nur linux-2.6.32-orig/drivers/net/starfire.c iDroid-Project-kernel_common-9e90fd2/drivers/net/starfire.c
--- linux-2.6.32-orig/drivers/net/starfire.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/starfire.c	2010-11-18 21:05:30.000000000 +0600
@@ -1063,7 +1063,7 @@
 	if (retval) {
 		printk(KERN_ERR "starfire: Failed to load firmware \"%s\"\n",
 		       FIRMWARE_RX);
-		return retval;
+		goto out_init;
 	}
 	if (fw_rx->size % 4) {
 		printk(KERN_ERR "starfire: bogus length %zu in \"%s\"\n",
@@ -1108,6 +1108,9 @@
 	release_firmware(fw_tx);
 out_rx:
 	release_firmware(fw_rx);
+out_init:
+	if (retval)
+		netdev_close(dev);
 	return retval;
 }
 
diff -Nur linux-2.6.32-orig/drivers/net/usb/rtl8150.c iDroid-Project-kernel_common-9e90fd2/drivers/net/usb/rtl8150.c
--- linux-2.6.32-orig/drivers/net/usb/rtl8150.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/usb/rtl8150.c	2010-11-18 21:05:30.000000000 +0600
@@ -324,7 +324,7 @@
 		dbg("%02X:", netdev->dev_addr[i]);
 	dbg("%02X\n", netdev->dev_addr[i]);
 	/* Set the IDR registers. */
-	set_registers(dev, IDR, sizeof(netdev->dev_addr), netdev->dev_addr);
+	set_registers(dev, IDR, netdev->addr_len, netdev->dev_addr);
 #ifdef EEPROM_WRITE
 	{
 	u8 cr;
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ath/ar9170/usb.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ar9170/usb.c
--- linux-2.6.32-orig/drivers/net/wireless/ath/ar9170/usb.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ar9170/usb.c	2010-11-18 21:05:30.000000000 +0600
@@ -68,8 +68,10 @@
 	{ USB_DEVICE(0x0cf3, 0x1002) },
 	/* Cace Airpcap NX */
 	{ USB_DEVICE(0xcace, 0x0300) },
-	/* D-Link DWA 160A */
+	/* D-Link DWA 160 A1 */
 	{ USB_DEVICE(0x07d1, 0x3c10) },
+	/* D-Link DWA 160 A2 */
+	{ USB_DEVICE(0x07d1, 0x3a09) },
 	/* Netgear WNDA3100 */
 	{ USB_DEVICE(0x0846, 0x9010) },
 	/* Netgear WN111 v2 */
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ath/ath5k/base.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath5k/base.c
--- linux-2.6.32-orig/drivers/net/wireless/ath/ath5k/base.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath5k/base.c	2010-11-18 21:05:30.000000000 +0600
@@ -2349,6 +2349,9 @@
 	 */
 	ath5k_stop_locked(sc);
 
+	/* Set PHY calibration interval */
+	ah->ah_cal_intval = ath5k_calinterval;
+
 	/*
 	 * The basic interface to setting the hardware in a good
 	 * state is ``reset''.  On return the hardware is known to
@@ -2376,10 +2379,6 @@
 
 	/* Set ack to be sent at low bit-rates */
 	ath5k_hw_set_ack_bitrate_high(ah, false);
-
-	/* Set PHY calibration inteval */
-	ah->ah_cal_intval = ath5k_calinterval;
-
 	ret = 0;
 done:
 	mmiowb();
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ath/ath5k/eeprom.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath5k/eeprom.c
--- linux-2.6.32-orig/drivers/net/wireless/ath/ath5k/eeprom.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath5k/eeprom.c	2010-11-18 21:05:30.000000000 +0600
@@ -97,6 +97,7 @@
 	struct ath5k_eeprom_info *ee = &ah->ah_capabilities.cap_eeprom;
 	int ret;
 	u16 val;
+	u32 cksum, offset, eep_max = AR5K_EEPROM_INFO_MAX;
 
 	/*
 	 * Read values from EEPROM and store them in the capability structure
@@ -111,20 +112,44 @@
 	if (ah->ah_ee_version < AR5K_EEPROM_VERSION_3_0)
 		return 0;
 
-#ifdef notyet
 	/*
 	 * Validate the checksum of the EEPROM date. There are some
 	 * devices with invalid EEPROMs.
 	 */
-	for (cksum = 0, offset = 0; offset < AR5K_EEPROM_INFO_MAX; offset++) {
+	AR5K_EEPROM_READ(AR5K_EEPROM_SIZE_UPPER, val);
+	if (val) {
+		eep_max = (val & AR5K_EEPROM_SIZE_UPPER_MASK) <<
+			   AR5K_EEPROM_SIZE_ENDLOC_SHIFT;
+		AR5K_EEPROM_READ(AR5K_EEPROM_SIZE_LOWER, val);
+		eep_max = (eep_max | val) - AR5K_EEPROM_INFO_BASE;
+
+		/*
+		 * Fail safe check to prevent stupid loops due
+		 * to busted EEPROMs. XXX: This value is likely too
+		 * big still, waiting on a better value.
+		 */
+		if (eep_max > (3 * AR5K_EEPROM_INFO_MAX)) {
+			ATH5K_ERR(ah->ah_sc, "Invalid max custom EEPROM size: "
+				  "%d (0x%04x) max expected: %d (0x%04x)\n",
+				  eep_max, eep_max,
+				  3 * AR5K_EEPROM_INFO_MAX,
+				  3 * AR5K_EEPROM_INFO_MAX);
+			return -EIO;
+		}
+	}
+
+	for (cksum = 0, offset = 0; offset < eep_max; offset++) {
 		AR5K_EEPROM_READ(AR5K_EEPROM_INFO(offset), val);
 		cksum ^= val;
 	}
 	if (cksum != AR5K_EEPROM_INFO_CKSUM) {
-		ATH5K_ERR(ah->ah_sc, "Invalid EEPROM checksum 0x%04x\n", cksum);
+		ATH5K_ERR(ah->ah_sc, "Invalid EEPROM "
+			  "checksum: 0x%04x eep_max: 0x%04x (%s)\n",
+			  cksum, eep_max,
+			  eep_max == AR5K_EEPROM_INFO_MAX ?
+				"default size" : "custom size");
 		return -EIO;
 	}
-#endif
 
 	AR5K_EEPROM_READ_HDR(AR5K_EEPROM_ANT_GAIN(ah->ah_ee_version),
 	    ee_ant_gain);
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ath/ath5k/eeprom.h iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath5k/eeprom.h
--- linux-2.6.32-orig/drivers/net/wireless/ath/ath5k/eeprom.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath5k/eeprom.h	2010-11-18 21:05:30.000000000 +0600
@@ -37,6 +37,14 @@
 #define AR5K_EEPROM_RFKILL_POLARITY_S	1
 
 #define AR5K_EEPROM_REG_DOMAIN		0x00bf	/* EEPROM regdom */
+
+/* FLASH(EEPROM) Defines for AR531X chips */
+#define AR5K_EEPROM_SIZE_LOWER		0x1b /* size info -- lower */
+#define AR5K_EEPROM_SIZE_UPPER		0x1c /* size info -- upper */
+#define AR5K_EEPROM_SIZE_UPPER_MASK	0xfff0
+#define AR5K_EEPROM_SIZE_UPPER_SHIFT	4
+#define AR5K_EEPROM_SIZE_ENDLOC_SHIFT	12
+
 #define AR5K_EEPROM_CHECKSUM		0x00c0	/* EEPROM checksum */
 #define AR5K_EEPROM_INFO_BASE		0x00c0	/* EEPROM header */
 #define AR5K_EEPROM_INFO_MAX		(0x400 - AR5K_EEPROM_INFO_BASE)
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ath/ath5k/phy.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath5k/phy.c
--- linux-2.6.32-orig/drivers/net/wireless/ath/ath5k/phy.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath5k/phy.c	2010-11-18 21:05:30.000000000 +0600
@@ -2954,8 +2954,6 @@
 		ATH5K_ERR(ah->ah_sc, "invalid tx power: %u\n", txpower);
 		return -EINVAL;
 	}
-	if (txpower == 0)
-		txpower = AR5K_TUNE_DEFAULT_TXPOWER;
 
 	/* Reset TX power values */
 	memset(&ah->ah_txpower, 0, sizeof(ah->ah_txpower));
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/ath9k.h iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/ath9k.h
--- linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/ath9k.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/ath9k.h	2010-11-18 21:05:30.000000000 +0600
@@ -139,6 +139,7 @@
 	dma_addr_t bf_daddr;		/* physical addr of desc */
 	dma_addr_t bf_buf_addr;		/* physical addr of data buffer */
 	bool bf_stale;
+	bool bf_isnullfunc;
 	u16 bf_flags;
 	struct ath_buf_state bf_state;
 	dma_addr_t bf_dmacontext;
@@ -524,6 +525,8 @@
 #define SC_OP_BEACON_SYNC       BIT(19)
 #define SC_OP_BTCOEX_ENABLED    BIT(20)
 #define SC_OP_BT_PRIORITY_DETECTED BIT(21)
+#define SC_OP_NULLFUNC_COMPLETED   BIT(22)
+#define SC_OP_PS_ENABLED	BIT(23)
 
 struct ath_bus_ops {
 	void		(*read_cachesize)(struct ath_softc *sc, int *csz);
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/hw.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/hw.c
--- linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/hw.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/hw.c	2010-11-18 21:05:30.000000000 +0600
@@ -880,12 +880,11 @@
 	}
 }
 
-static void ath9k_hw_init_11a_eeprom_fix(struct ath_hw *ah)
+static void ath9k_hw_init_eeprom_fix(struct ath_hw *ah)
 {
 	u32 i, j;
 
-	if ((ah->hw_version.devid == AR9280_DEVID_PCI) &&
-	    test_bit(ATH9K_MODE_11A, ah->caps.wireless_modes)) {
+	if (ah->hw_version.devid == AR9280_DEVID_PCI) {
 
 		/* EEPROM Fixup */
 		for (i = 0; i < ah->iniModes.ia_rows; i++) {
@@ -937,6 +936,11 @@
 	DPRINTF(ah->ah_sc, ATH_DBG_RESET, "serialize_regmode is %d\n",
 		ah->config.serialize_regmode);
 
+	if (AR_SREV_9285(ah) || AR_SREV_9271(ah))
+		ah->config.max_txtrig_level = MAX_TX_FIFO_THRESHOLD >> 1;
+	else
+		ah->config.max_txtrig_level = MAX_TX_FIFO_THRESHOLD;
+
 	if (!ath9k_hw_macversion_supported(ah->hw_version.macVersion)) {
 		DPRINTF(ah->ah_sc, ATH_DBG_FATAL,
 			"Mac Chip Rev 0x%02x.%x is not supported by "
@@ -975,7 +979,7 @@
 
 	ath9k_hw_init_mode_gain_regs(ah);
 	ath9k_hw_fill_cap_info(ah);
-	ath9k_hw_init_11a_eeprom_fix(ah);
+	ath9k_hw_init_eeprom_fix(ah);
 
 	r = ath9k_hw_init_macaddr(ah);
 	if (r) {
@@ -3670,7 +3674,11 @@
 		pCap->keycache_size = AR_KEYTABLE_SIZE;
 
 	pCap->hw_caps |= ATH9K_HW_CAP_FASTCC;
-	pCap->tx_triglevel_max = MAX_TX_FIFO_THRESHOLD;
+
+	if (AR_SREV_9285(ah) || AR_SREV_9271(ah))
+		pCap->tx_triglevel_max = MAX_TX_FIFO_THRESHOLD >> 1;
+	else
+		pCap->tx_triglevel_max = MAX_TX_FIFO_THRESHOLD;
 
 	if (AR_SREV_9285_10_OR_LATER(ah))
 		pCap->num_gpio_pins = AR9285_NUM_GPIO;
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/hw.h iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/hw.h
--- linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/hw.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/hw.h	2010-11-18 21:05:30.000000000 +0600
@@ -218,6 +218,7 @@
 #define AR_SPUR_FEEQ_BOUND_HT20 10
 	int spurmode;
 	u16 spurchans[AR_EEPROM_MODAL_SPURS][2];
+	u8 max_txtrig_level;
 };
 
 enum ath9k_int {
@@ -407,7 +408,7 @@
  * Using de Bruijin sequence to to look up 1's index in a 32 bit number
  * debruijn32 = 0000 0111 0111 1100 1011 0101 0011 0001
  */
-#define debruijn32 0x077CB531UL
+#define debruijn32 0x077CB531U
 
 struct ath_gen_timer_configuration {
 	u32 next_addr;
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/mac.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/mac.c
--- linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/mac.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/mac.c	2010-11-18 21:05:30.000000000 +0600
@@ -70,7 +70,7 @@
 	u32 txcfg, curLevel, newLevel;
 	enum ath9k_int omask;
 
-	if (ah->tx_trig_level >= MAX_TX_FIFO_THRESHOLD)
+	if (ah->tx_trig_level >= ah->config.max_txtrig_level)
 		return false;
 
 	omask = ath9k_hw_set_interrupts(ah, ah->mask_reg & ~ATH9K_INT_GLOBAL);
@@ -79,7 +79,7 @@
 	curLevel = MS(txcfg, AR_FTRIG);
 	newLevel = curLevel;
 	if (bIncTrigLevel) {
-		if (curLevel < MAX_TX_FIFO_THRESHOLD)
+		if (curLevel < ah->config.max_txtrig_level)
 			newLevel++;
 	} else if (curLevel > MIN_TX_FIFO_THRESHOLD)
 		newLevel--;
@@ -155,7 +155,7 @@
 		wait = wait_time;
 		while (ath9k_hw_numtxpending(ah, q)) {
 			if ((--wait) == 0) {
-				DPRINTF(ah->ah_sc, ATH_DBG_QUEUE,
+				DPRINTF(ah->ah_sc, ATH_DBG_FATAL,
 					"Failed to stop TX DMA in 100 "
 					"msec after killing last frame\n");
 				break;
@@ -222,6 +222,8 @@
 	ds->ds_txstat.ts_status = 0;
 	ds->ds_txstat.ts_flags = 0;
 
+	if (ads->ds_txstatus1 & AR_FrmXmitOK)
+		ds->ds_txstat.ts_status |= ATH9K_TX_ACKED;
 	if (ads->ds_txstatus1 & AR_ExcessiveRetries)
 		ds->ds_txstat.ts_status |= ATH9K_TXERR_XRETRY;
 	if (ads->ds_txstatus1 & AR_Filtered)
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/mac.h iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/mac.h
--- linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/mac.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/mac.h	2010-11-18 21:05:30.000000000 +0600
@@ -76,6 +76,10 @@
 #define ATH9K_TXERR_FIFO           0x04
 #define ATH9K_TXERR_XTXOP          0x08
 #define ATH9K_TXERR_TIMER_EXPIRED  0x10
+#define ATH9K_TX_ACKED		   0x20
+#define ATH9K_TXERR_MASK						\
+	(ATH9K_TXERR_XRETRY | ATH9K_TXERR_FILT | ATH9K_TXERR_FIFO |	\
+	 ATH9K_TXERR_XTXOP | ATH9K_TXERR_TIMER_EXPIRED)
 
 #define ATH9K_TX_BA                0x01
 #define ATH9K_TX_PWRMGMT           0x02
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/main.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/main.c
--- linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/main.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/main.c	2010-11-18 21:05:30.000000000 +0600
@@ -2147,6 +2147,9 @@
 		return; /* another wiphy still in use */
 	}
 
+	/* Ensure HW is awake when we try to shut it down. */
+	ath9k_ps_wakeup(sc);
+
 	if (sc->sc_flags & SC_OP_BTCOEX_ENABLED) {
 		ath9k_hw_btcoex_disable(sc->sc_ah);
 		if (sc->btcoex_info.btcoex_scheme == ATH_BTCOEX_CFG_3WIRE)
@@ -2167,6 +2170,9 @@
 	/* disable HAL and put h/w to sleep */
 	ath9k_hw_disable(sc->sc_ah);
 	ath9k_hw_configpcipowersave(sc->sc_ah, 1, 1);
+	ath9k_ps_restore(sc);
+
+	/* Finally, put the chip in FULL SLEEP mode */
 	ath9k_hw_setpower(sc->sc_ah, ATH9K_PM_FULL_SLEEP);
 
 	sc->sc_flags |= SC_OP_INVALID;
@@ -2277,10 +2283,12 @@
 	if ((sc->sc_ah->opmode == NL80211_IFTYPE_AP) ||
 	    (sc->sc_ah->opmode == NL80211_IFTYPE_ADHOC) ||
 	    (sc->sc_ah->opmode == NL80211_IFTYPE_MESH_POINT)) {
+		ath9k_ps_wakeup(sc);
 		ath9k_hw_stoptxdma(sc->sc_ah, sc->beacon.beaconq);
-		ath_beacon_return(sc, avp);
+		ath9k_ps_restore(sc);
 	}
 
+	ath_beacon_return(sc, avp);
 	sc->sc_flags &= ~SC_OP_BEACONS;
 
 	for (i = 0; i < ARRAY_SIZE(sc->beacon.bslot); i++) {
@@ -2327,6 +2335,7 @@
 
 	if (changed & IEEE80211_CONF_CHANGE_PS) {
 		if (conf->flags & IEEE80211_CONF_PS) {
+			sc->sc_flags |= SC_OP_PS_ENABLED;
 			if (!(ah->caps.hw_caps &
 			      ATH9K_HW_CAP_AUTOSLEEP)) {
 				if ((sc->imask & ATH9K_INT_TIM_TIMER) == 0) {
@@ -2334,11 +2343,17 @@
 					ath9k_hw_set_interrupts(sc->sc_ah,
 							sc->imask);
 				}
-				ath9k_hw_setrxabort(sc->sc_ah, 1);
 			}
 			sc->ps_enabled = true;
+			if ((sc->sc_flags & SC_OP_NULLFUNC_COMPLETED)) {
+				sc->sc_flags &= ~SC_OP_NULLFUNC_COMPLETED;
+				sc->ps_enabled = true;
+				ath9k_hw_setrxabort(sc->sc_ah, 1);
+			}
 		} else {
 			sc->ps_enabled = false;
+			sc->sc_flags &= ~(SC_OP_PS_ENABLED |
+					  SC_OP_NULLFUNC_COMPLETED);
 			ath9k_hw_setpower(sc->sc_ah, ATH9K_PM_AWAKE);
 			if (!(ah->caps.hw_caps &
 			      ATH9K_HW_CAP_AUTOSLEEP)) {
@@ -2717,15 +2732,21 @@
 	case IEEE80211_AMPDU_RX_STOP:
 		break;
 	case IEEE80211_AMPDU_TX_START:
+		ath9k_ps_wakeup(sc);
 		ath_tx_aggr_start(sc, sta, tid, ssn);
 		ieee80211_start_tx_ba_cb_irqsafe(hw, sta->addr, tid);
+		ath9k_ps_restore(sc);
 		break;
 	case IEEE80211_AMPDU_TX_STOP:
+		ath9k_ps_wakeup(sc);
 		ath_tx_aggr_stop(sc, sta, tid);
 		ieee80211_stop_tx_ba_cb_irqsafe(hw, sta->addr, tid);
+		ath9k_ps_restore(sc);
 		break;
 	case IEEE80211_AMPDU_TX_OPERATIONAL:
+		ath9k_ps_wakeup(sc);
 		ath_tx_aggr_resume(sc, sta, tid);
+		ath9k_ps_restore(sc);
 		break;
 	default:
 		DPRINTF(sc, ATH_DBG_FATAL, "Unknown AMPDU action\n");
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/reg.h iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/reg.h
--- linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/reg.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/reg.h	2010-11-18 21:05:30.000000000 +0600
@@ -969,10 +969,10 @@
 #define AR_GPIO_INPUT_EN_VAL_BT_ACTIVE_S         4
 #define AR_GPIO_INPUT_EN_VAL_RFSILENT_DEF        0x00000080
 #define AR_GPIO_INPUT_EN_VAL_RFSILENT_DEF_S      7
+#define AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_BB      0x00000400
+#define AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_BB_S    10
 #define AR_GPIO_INPUT_EN_VAL_BT_ACTIVE_BB        0x00001000
 #define AR_GPIO_INPUT_EN_VAL_BT_ACTIVE_BB_S      12
-#define AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_BB      0x00001000
-#define AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_BB_S    1
 #define AR_GPIO_INPUT_EN_VAL_RFSILENT_BB         0x00008000
 #define AR_GPIO_INPUT_EN_VAL_RFSILENT_BB_S       15
 #define AR_GPIO_RTC_RESET_OVERRIDE_ENABLE        0x00010000
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/xmit.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/xmit.c
--- linux-2.6.32-orig/drivers/net/wireless/ath/ath9k/xmit.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ath/ath9k/xmit.c	2010-11-18 21:05:30.000000000 +0600
@@ -1076,10 +1076,10 @@
 	if (npend) {
 		int r;
 
-		DPRINTF(sc, ATH_DBG_XMIT, "Unable to stop TxDMA. Reset HAL!\n");
+		DPRINTF(sc, ATH_DBG_FATAL, "Unable to stop TxDMA. Reset HAL!\n");
 
 		spin_lock_bh(&sc->sc_resetlock);
-		r = ath9k_hw_reset(ah, sc->sc_ah->curchan, true);
+		r = ath9k_hw_reset(ah, sc->sc_ah->curchan, false);
 		if (r)
 			DPRINTF(sc, ATH_DBG_FATAL,
 				"Unable to reset hardware; reset status %d\n",
@@ -1563,7 +1563,7 @@
 
 	bf->bf_frmlen = skb->len + FCS_LEN - (hdrlen & 3);
 
-	if (conf_is_ht(&sc->hw->conf) && !is_pae(skb))
+	if (conf_is_ht(&sc->hw->conf))
 		bf->bf_state.bf_type |= BUF_HT;
 
 	bf->bf_flags = setup_tx_flags(sc, skb, txctl->txq);
@@ -1592,6 +1592,13 @@
 	}
 
 	bf->bf_buf_addr = bf->bf_dmacontext;
+
+	if (ieee80211_is_nullfunc(fc) && ieee80211_has_pm(fc)) {
+		bf->bf_isnullfunc = true;
+		sc->sc_flags &= ~SC_OP_NULLFUNC_COMPLETED;
+	} else
+		bf->bf_isnullfunc = false;
+
 	return 0;
 }
 
@@ -1641,7 +1648,7 @@
 			goto tx_done;
 		}
 
-		if (tx_info->flags & IEEE80211_TX_CTL_AMPDU) {
+		if ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) && !is_pae(skb)) {
 			/*
 			 * Try aggregation if it's a unicast data frame
 			 * and the destination is HT capable.
@@ -1989,6 +1996,15 @@
 		if (ds == txq->axq_gatingds)
 			txq->axq_gatingds = NULL;
 
+		if (bf->bf_isnullfunc &&
+		    (ds->ds_txstat.ts_status & ATH9K_TX_ACKED)) {
+			if ((sc->sc_flags & SC_OP_PS_ENABLED)) {
+				sc->ps_enabled = true;
+				ath9k_hw_setrxabort(sc->sc_ah, 1);
+			} else
+				sc->sc_flags |= SC_OP_NULLFUNC_COMPLETED;
+		}
+
 		/*
 		 * Remove ath_buf's of the same transmit unit from txq,
 		 * however leave the last descriptor back as the holding
@@ -2004,7 +2020,7 @@
 		if (bf_isaggr(bf))
 			txq->axq_aggr_depth--;
 
-		txok = (ds->ds_txstat.ts_status == 0);
+		txok = !(ds->ds_txstat.ts_status & ATH9K_TXERR_MASK);
 		txq->axq_tx_inprogress = false;
 		spin_unlock_bh(&txq->axq_lock);
 
@@ -2065,7 +2081,9 @@
 
 	if (needreset) {
 		DPRINTF(sc, ATH_DBG_RESET, "tx hung, resetting the chip\n");
+		ath9k_ps_wakeup(sc);
 		ath_reset(sc, false);
+		ath9k_ps_restore(sc);
 	}
 
 	ieee80211_queue_delayed_work(sc->hw, &sc->tx_complete_work,
diff -Nur linux-2.6.32-orig/drivers/net/wireless/b43/b43.h iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/b43/b43.h
--- linux-2.6.32-orig/drivers/net/wireless/b43/b43.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/b43/b43.h	2010-11-18 21:05:30.000000000 +0600
@@ -117,6 +117,7 @@
 #define B43_MMIO_TSF_2			0x636	/* core rev < 3 only */
 #define B43_MMIO_TSF_3			0x638	/* core rev < 3 only */
 #define B43_MMIO_RNG			0x65A
+#define B43_MMIO_IFSSLOT		0x684	/* Interframe slot time */
 #define B43_MMIO_IFSCTL			0x688 /* Interframe space control */
 #define  B43_MMIO_IFSCTL_USE_EDCF	0x0004
 #define B43_MMIO_POWERUP_DELAY		0x6A8
diff -Nur linux-2.6.32-orig/drivers/net/wireless/b43/main.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/b43/main.c
--- linux-2.6.32-orig/drivers/net/wireless/b43/main.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/b43/main.c	2010-11-18 21:05:30.000000000 +0600
@@ -628,10 +628,17 @@
 static void b43_set_slot_time(struct b43_wldev *dev, u16 slot_time)
 {
 	/* slot_time is in usec. */
-	if (dev->phy.type != B43_PHYTYPE_G)
+	/* This test used to exit for all but a G PHY. */
+	if (b43_current_band(dev->wl) == IEEE80211_BAND_5GHZ)
 		return;
-	b43_write16(dev, 0x684, 510 + slot_time);
-	b43_shm_write16(dev, B43_SHM_SHARED, 0x0010, slot_time);
+	b43_write16(dev, B43_MMIO_IFSSLOT, 510 + slot_time);
+	/* Shared memory location 0x0010 is the slot time and should be
+	 * set to slot_time; however, this register is initially 0 and changing
+	 * the value adversely affects the transmit rate for BCM4311
+	 * devices. Until this behavior is unterstood, delete this step
+	 *
+	 * b43_shm_write16(dev, B43_SHM_SHARED, 0x0010, slot_time);
+	 */
 }
 
 static void b43_short_slot_timing_enable(struct b43_wldev *dev)
diff -Nur linux-2.6.32-orig/drivers/net/wireless/b43/rfkill.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/b43/rfkill.c
--- linux-2.6.32-orig/drivers/net/wireless/b43/rfkill.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/b43/rfkill.c	2010-11-18 21:05:30.000000000 +0600
@@ -33,8 +33,14 @@
 		      & B43_MMIO_RADIO_HWENABLED_HI_MASK))
 			return 1;
 	} else {
-		if (b43_status(dev) >= B43_STAT_STARTED &&
-		    b43_read16(dev, B43_MMIO_RADIO_HWENABLED_LO)
+		/* To prevent CPU fault on PPC, do not read a register
+		 * unless the interface is started; however, on resume
+		 * for hibernation, this routine is entered early. When
+		 * that happens, unconditionally return TRUE.
+		 */
+		if (b43_status(dev) < B43_STAT_STARTED)
+			return 1;
+		if (b43_read16(dev, B43_MMIO_RADIO_HWENABLED_LO)
 		    & B43_MMIO_RADIO_HWENABLED_LO_MASK)
 			return 1;
 	}
diff -Nur linux-2.6.32-orig/drivers/net/wireless/b43legacy/rfkill.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/b43legacy/rfkill.c
--- linux-2.6.32-orig/drivers/net/wireless/b43legacy/rfkill.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/b43legacy/rfkill.c	2010-11-18 21:05:30.000000000 +0600
@@ -34,6 +34,13 @@
 		      & B43legacy_MMIO_RADIO_HWENABLED_HI_MASK))
 			return 1;
 	} else {
+		/* To prevent CPU fault on PPC, do not read a register
+		 * unless the interface is started; however, on resume
+		 * for hibernation, this routine is entered early. When
+		 * that happens, unconditionally return TRUE.
+		 */
+		if (b43legacy_status(dev) < B43legacy_STAT_STARTED)
+			return 1;
 		if (b43legacy_read16(dev, B43legacy_MMIO_RADIO_HWENABLED_LO)
 		    & B43legacy_MMIO_RADIO_HWENABLED_LO_MASK)
 			return 1;
diff -Nur linux-2.6.32-orig/drivers/net/wireless/ipw2x00/ipw2100.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ipw2x00/ipw2100.c
--- linux-2.6.32-orig/drivers/net/wireless/ipw2x00/ipw2100.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/ipw2x00/ipw2100.c	2010-11-18 21:05:30.000000000 +0600
@@ -6487,6 +6487,16 @@
 }
 #endif
 
+static void ipw2100_shutdown(struct pci_dev *pci_dev)
+{
+	struct ipw2100_priv *priv = pci_get_drvdata(pci_dev);
+
+	/* Take down the device; powers it off, etc. */
+	ipw2100_down(priv);
+
+	pci_disable_device(pci_dev);
+}
+
 #define IPW2100_DEV_ID(x) { PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, x }
 
 static struct pci_device_id ipw2100_pci_id_table[] __devinitdata = {
@@ -6550,6 +6560,7 @@
 	.suspend = ipw2100_suspend,
 	.resume = ipw2100_resume,
 #endif
+	.shutdown = ipw2100_shutdown,
 };
 
 /**
diff -Nur linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl3945-base.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl3945-base.c
--- linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl3945-base.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl3945-base.c	2010-11-18 21:05:30.000000000 +0600
@@ -562,6 +562,9 @@
 	txq = &priv->txq[txq_id];
 	q = &txq->q;
 
+	if ((iwl_queue_space(q) < q->high_mark))
+		goto drop;
+
 	spin_lock_irqsave(&priv->lock, flags);
 
 	idx = get_cmd_index(q, q->write_ptr, 0);
@@ -3854,9 +3857,11 @@
 	/* Tell mac80211 our characteristics */
 	hw->flags = IEEE80211_HW_SIGNAL_DBM |
 		    IEEE80211_HW_NOISE_DBM |
-		    IEEE80211_HW_SPECTRUM_MGMT |
-		    IEEE80211_HW_SUPPORTS_PS |
-		    IEEE80211_HW_SUPPORTS_DYNAMIC_PS;
+		    IEEE80211_HW_SPECTRUM_MGMT;
+
+	if (!priv->cfg->broken_powersave)
+		hw->flags |= IEEE80211_HW_SUPPORTS_PS |
+			     IEEE80211_HW_SUPPORTS_DYNAMIC_PS;
 
 	hw->wiphy->interface_modes =
 		BIT(NL80211_IFTYPE_STATION) |
diff -Nur linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-3945.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-3945.c
--- linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-3945.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-3945.c	2010-11-18 21:05:30.000000000 +0600
@@ -2895,6 +2895,7 @@
 	.mod_params = &iwl3945_mod_params,
 	.use_isr_legacy = true,
 	.ht_greenfield_support = false,
+	.broken_powersave = true,
 };
 
 static struct iwl_cfg iwl3945_abg_cfg = {
@@ -2909,6 +2910,7 @@
 	.mod_params = &iwl3945_mod_params,
 	.use_isr_legacy = true,
 	.ht_greenfield_support = false,
+	.broken_powersave = true,
 };
 
 struct pci_device_id iwl3945_hw_card_ids[] = {
diff -Nur linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-4965.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-4965.c
--- linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-4965.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-4965.c	2010-11-18 21:05:30.000000000 +0600
@@ -1337,7 +1337,7 @@
 	iwl4965_interpolate_chan(priv, channel, &ch_eeprom_info);
 
 	/* calculate tx gain adjustment based on power supply voltage */
-	voltage = priv->calib_info->voltage;
+	voltage = le16_to_cpu(priv->calib_info->voltage);
 	init_voltage = (s32)le32_to_cpu(priv->card_alive_init.voltage);
 	voltage_compensation =
 	    iwl4965_get_voltage_compensation(voltage, init_voltage);
@@ -2087,7 +2087,7 @@
 	struct ieee80211_tx_info *info;
 	struct iwl4965_tx_resp *tx_resp = (void *)&pkt->u.raw[0];
 	u32  status = le32_to_cpu(tx_resp->u.status);
-	int tid = MAX_TID_COUNT;
+	int tid = MAX_TID_COUNT - 1;
 	int sta_id;
 	int freed;
 	u8 *qc = NULL;
diff -Nur linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-5000.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-5000.c
--- linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-5000.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-5000.c	2010-11-18 21:05:30.000000000 +0600
@@ -460,14 +460,15 @@
 static int iwl5000_set_Xtal_calib(struct iwl_priv *priv)
 {
 	struct iwl_calib_xtal_freq_cmd cmd;
-	u16 *xtal_calib = (u16 *)iwl_eeprom_query_addr(priv, EEPROM_5000_XTAL);
+	__le16 *xtal_calib =
+		(__le16 *)iwl_eeprom_query_addr(priv, EEPROM_5000_XTAL);
 
 	cmd.hdr.op_code = IWL_PHY_CALIBRATE_CRYSTAL_FRQ_CMD;
 	cmd.hdr.first_group = 0;
 	cmd.hdr.groups_num = 1;
 	cmd.hdr.data_valid = 1;
-	cmd.cap_pin1 = (u8)xtal_calib[0];
-	cmd.cap_pin2 = (u8)xtal_calib[1];
+	cmd.cap_pin1 = le16_to_cpu(xtal_calib[0]);
+	cmd.cap_pin2 = le16_to_cpu(xtal_calib[1]);
 	return iwl_calib_set(&priv->calib_results[IWL_CALIB_XTAL],
 			     (u8 *)&cmd, sizeof(cmd));
 }
@@ -1665,6 +1666,7 @@
 	.valid_rx_ant = ANT_ABC,
 	.need_pll_cfg = true,
 	.ht_greenfield_support = true,
+	.use_rts_for_ht = true, /* use rts/cts protection */
 };
 
 struct iwl_cfg iwl5100_bg_cfg = {
@@ -1716,6 +1718,7 @@
 	.valid_rx_ant = ANT_AB,
 	.need_pll_cfg = true,
 	.ht_greenfield_support = true,
+	.use_rts_for_ht = true, /* use rts/cts protection */
 };
 
 struct iwl_cfg iwl5350_agn_cfg = {
@@ -1733,6 +1736,7 @@
 	.valid_rx_ant = ANT_ABC,
 	.need_pll_cfg = true,
 	.ht_greenfield_support = true,
+	.use_rts_for_ht = true, /* use rts/cts protection */
 };
 
 struct iwl_cfg iwl5150_agn_cfg = {
@@ -1750,6 +1754,7 @@
 	.valid_rx_ant = ANT_AB,
 	.need_pll_cfg = true,
 	.ht_greenfield_support = true,
+	.use_rts_for_ht = true, /* use rts/cts protection */
 };
 
 MODULE_FIRMWARE(IWL5000_MODULE_FIRMWARE(IWL5000_UCODE_API_MAX));
diff -Nur linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-5000-hw.h iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-5000-hw.h
--- linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-5000-hw.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-5000-hw.h	2010-11-18 21:05:30.000000000 +0600
@@ -92,11 +92,15 @@
 
 static inline s32 iwl_temp_calib_to_offset(struct iwl_priv *priv)
 {
-	u16 *temp_calib = (u16 *)iwl_eeprom_query_addr(priv,
-						       EEPROM_5000_TEMPERATURE);
-	/* offset =  temperature -  voltage / coef */
-	s32 offset = (s32)(temp_calib[0] - temp_calib[1] / IWL_5150_VOLTAGE_TO_TEMPERATURE_COEFF);
-	return offset;
+	u16 temperature, voltage;
+	__le16 *temp_calib =
+		(__le16 *)iwl_eeprom_query_addr(priv, EEPROM_5000_TEMPERATURE);
+
+	temperature = le16_to_cpu(temp_calib[0]);
+	voltage = le16_to_cpu(temp_calib[1]);
+
+	/* offset = temp - volt / coeff */
+	return (s32)(temperature - voltage / IWL_5150_VOLTAGE_TO_TEMPERATURE_COEFF);
 }
 
 /* Fixed (non-configurable) rx data from phy */
diff -Nur linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-agn-rs.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-agn-rs.c
--- linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-agn-rs.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-agn-rs.c	2010-11-18 21:05:30.000000000 +0600
@@ -2808,7 +2808,7 @@
 		repeat_rate--;
 	}
 
-	lq_cmd->agg_params.agg_frame_cnt_limit = LINK_QUAL_AGG_FRAME_LIMIT_MAX;
+	lq_cmd->agg_params.agg_frame_cnt_limit = LINK_QUAL_AGG_FRAME_LIMIT_DEF;
 	lq_cmd->agg_params.agg_dis_start_th = LINK_QUAL_AGG_DISABLE_START_DEF;
 	lq_cmd->agg_params.agg_time_limit =
 		cpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);
diff -Nur linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-core.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-core.c
--- linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-core.c	2010-11-18 21:05:30.000000000 +0600
@@ -2645,6 +2645,7 @@
 		if ((le16_to_cpu(priv->staging_rxon.channel) != ch))
 			priv->staging_rxon.flags = 0;
 
+		iwl_set_rxon_ht(priv, ht_conf);
 		iwl_set_rxon_channel(priv, conf->channel);
 
 		iwl_set_flags_for_band(priv, conf->channel->band);
diff -Nur linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-dev.h iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-dev.h
--- linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-dev.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-dev.h	2010-11-18 21:05:30.000000000 +0600
@@ -703,7 +703,7 @@
 extern int iwl_queue_space(const struct iwl_queue *q);
 static inline int iwl_queue_used(const struct iwl_queue *q, int i)
 {
-	return q->write_ptr > q->read_ptr ?
+	return q->write_ptr >= q->read_ptr ?
 		(i >= q->read_ptr && i < q->write_ptr) :
 		!(i < q->read_ptr && i >= q->write_ptr);
 }
@@ -1149,7 +1149,7 @@
 	u32 last_beacon_time;
 	u64 last_tsf;
 
-	/* eeprom */
+	/* eeprom -- this is in the card's little endian byte order */
 	u8 *eeprom;
 	int    nvm_device_type;
 	struct iwl_eeprom_calib_info *calib_info;
diff -Nur linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-eeprom.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-eeprom.c
--- linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-eeprom.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-eeprom.c	2010-11-18 21:05:30.000000000 +0600
@@ -337,7 +337,7 @@
 	return ret;
 }
 
-static int iwl_read_otp_word(struct iwl_priv *priv, u16 addr, u16 *eeprom_data)
+static int iwl_read_otp_word(struct iwl_priv *priv, u16 addr, __le16 *eeprom_data)
 {
 	int ret = 0;
 	u32 r;
@@ -370,7 +370,7 @@
 				CSR_OTP_GP_REG_ECC_CORR_STATUS_MSK);
 		IWL_ERR(priv, "Correctable OTP ECC error, continue read\n");
 	}
-	*eeprom_data = le16_to_cpu((__force __le16)(r >> 16));
+	*eeprom_data = cpu_to_le16(r >> 16);
 	return 0;
 }
 
@@ -379,7 +379,8 @@
  */
 static bool iwl_is_otp_empty(struct iwl_priv *priv)
 {
-	u16 next_link_addr = 0, link_value;
+	u16 next_link_addr = 0;
+	__le16 link_value;
 	bool is_empty = false;
 
 	/* locate the beginning of OTP link list */
@@ -409,7 +410,8 @@
 static int iwl_find_otp_image(struct iwl_priv *priv,
 					u16 *validblockaddr)
 {
-	u16 next_link_addr = 0, link_value = 0, valid_addr;
+	u16 next_link_addr = 0, valid_addr;
+	__le16 link_value = 0;
 	int usedblocks = 0;
 
 	/* set addressing mode to absolute to traverse the link list */
@@ -429,7 +431,7 @@
 		 * check for more block on the link list
 		 */
 		valid_addr = next_link_addr;
-		next_link_addr = link_value * sizeof(u16);
+		next_link_addr = le16_to_cpu(link_value) * sizeof(u16);
 		IWL_DEBUG_INFO(priv, "OTP blocks %d addr 0x%x\n",
 			       usedblocks, next_link_addr);
 		if (iwl_read_otp_word(priv, next_link_addr, &link_value))
@@ -463,7 +465,7 @@
  */
 int iwl_eeprom_init(struct iwl_priv *priv)
 {
-	u16 *e;
+	__le16 *e;
 	u32 gp = iwl_read32(priv, CSR_EEPROM_GP);
 	int sz;
 	int ret;
@@ -482,7 +484,7 @@
 		ret = -ENOMEM;
 		goto alloc_err;
 	}
-	e = (u16 *)priv->eeprom;
+	e = (__le16 *)priv->eeprom;
 
 	ret = priv->cfg->ops->lib->eeprom_ops.verify_signature(priv);
 	if (ret < 0) {
@@ -521,7 +523,7 @@
 		}
 		for (addr = validblockaddr; addr < validblockaddr + sz;
 		     addr += sizeof(u16)) {
-			u16 eeprom_data;
+			__le16 eeprom_data;
 
 			ret = iwl_read_otp_word(priv, addr, &eeprom_data);
 			if (ret)
@@ -545,7 +547,7 @@
 				goto done;
 			}
 			r = _iwl_read_direct32(priv, CSR_EEPROM_REG);
-			e[addr / 2] = le16_to_cpu((__force __le16)(r >> 16));
+			e[addr / 2] = cpu_to_le16(r >> 16);
 		}
 	}
 	ret = 0;
@@ -709,7 +711,8 @@
 	ch_info->ht40_min_power = 0;
 	ch_info->ht40_scan_power = eeprom_ch->max_power_avg;
 	ch_info->ht40_flags = eeprom_ch->flags;
-	ch_info->ht40_extension_channel &= ~clear_ht40_extension_channel;
+	if (eeprom_ch->flags & EEPROM_CHANNEL_VALID)
+		ch_info->ht40_extension_channel &= ~clear_ht40_extension_channel;
 
 	return 0;
 }
diff -Nur linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-eeprom.h iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-eeprom.h
--- linux-2.6.32-orig/drivers/net/wireless/iwlwifi/iwl-eeprom.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwlwifi/iwl-eeprom.h	2010-11-18 21:05:30.000000000 +0600
@@ -133,7 +133,7 @@
  *
  */
 struct iwl_eeprom_enhanced_txpwr {
-	u16 reserved;
+	__le16 common;
 	s8 chain_a_max;
 	s8 chain_b_max;
 	s8 chain_c_max;
@@ -347,7 +347,7 @@
 struct iwl_eeprom_calib_info {
 	u8 saturation_power24;	/* half-dBm (e.g. "34" = 17 dBm) */
 	u8 saturation_power52;	/* half-dBm */
-	s16 voltage;		/* signed */
+	__le16 voltage;		/* signed */
 	struct iwl_eeprom_calib_subband_info
 		band_info[EEPROM_TX_POWER_BANDS];
 } __attribute__ ((packed));
diff -Nur linux-2.6.32-orig/drivers/net/wireless/iwmc3200wifi/iwm.h iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwmc3200wifi/iwm.h
--- linux-2.6.32-orig/drivers/net/wireless/iwmc3200wifi/iwm.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/iwmc3200wifi/iwm.h	2010-11-18 21:05:30.000000000 +0600
@@ -258,7 +258,7 @@
 
 	struct sk_buff_head rx_list;
 	struct list_head rx_tickets;
-	struct list_head rx_packets[IWM_RX_ID_HASH];
+	struct list_head rx_packets[IWM_RX_ID_HASH + 1];
 	struct workqueue_struct *rx_wq;
 	struct work_struct rx_worker;
 
diff -Nur linux-2.6.32-orig/drivers/net/wireless/libertas/hostcmd.h iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/libertas/hostcmd.h
--- linux-2.6.32-orig/drivers/net/wireless/libertas/hostcmd.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/libertas/hostcmd.h	2010-11-18 21:05:30.000000000 +0600
@@ -662,6 +662,15 @@
 	u8 value[LBS_EEPROM_READ_LEN];
 } __attribute__ ((packed));
 
+struct cmd_ds_802_11_cal_data_ext {
+	struct cmd_header hdr;
+	__le16 action;
+	__le16 revision;
+	__le16 len;
+#define LBS_CAL_DATA_LEN 0x400
+	u8 data[LBS_CAL_DATA_LEN];
+} __attribute__ ((packed));
+
 struct cmd_ds_802_11_tpc_cfg {
 	struct cmd_header hdr;
 
diff -Nur linux-2.6.32-orig/drivers/net/wireless/libertas/host.h iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/libertas/host.h
--- linux-2.6.32-orig/drivers/net/wireless/libertas/host.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/libertas/host.h	2010-11-18 21:05:30.000000000 +0600
@@ -72,6 +72,7 @@
 #define CMD_802_11_SLEEP_PARAMS			0x0066
 #define CMD_802_11_INACTIVITY_TIMEOUT		0x0067
 #define CMD_802_11_SLEEP_PERIOD			0x0068
+#define CMD_802_11_CAL_DATA_EXT                 0x006D
 #define CMD_802_11_TPC_CFG			0x0072
 #define CMD_802_11_PA_CFG			0x0073
 #define CMD_802_11_FW_WAKE_METHOD		0x0074
diff -Nur linux-2.6.32-orig/drivers/net/wireless/libertas/if_sdio.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/libertas/if_sdio.c
--- linux-2.6.32-orig/drivers/net/wireless/libertas/if_sdio.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/libertas/if_sdio.c	2010-11-18 21:05:30.000000000 +0600
@@ -126,6 +126,9 @@
 	struct work_struct	packet_worker;
 
 	u8			rx_unit;
+
+	u8			*helper_fw;
+	size_t			helper_fw_size;
 };
 
 /********************************************************************/
@@ -457,29 +460,20 @@
 /* Firmware                                                         */
 /********************************************************************/
 
-static int if_sdio_prog_helper(struct if_sdio_card *card)
+static int if_sdio_prog_helper(struct if_sdio_card *card, const u8* firmware, size_t size)
 {
 	int ret;
 	u8 status;
-	const struct firmware *fw;
 	unsigned long timeout;
 	u8 *chunk_buffer;
 	u32 chunk_size;
-	const u8 *firmware;
-	size_t size;
 
 	lbs_deb_enter(LBS_DEB_SDIO);
 
-	ret = request_firmware(&fw, card->helper, &card->func->dev);
-	if (ret) {
-		lbs_pr_err("can't load helper firmware\n");
-		goto out;
-	}
-
 	chunk_buffer = kzalloc(64, GFP_KERNEL);
 	if (!chunk_buffer) {
 		ret = -ENOMEM;
-		goto release_fw;
+		goto out;
 	}
 
 	sdio_claim_host(card->func);
@@ -488,9 +482,6 @@
 	if (ret)
 		goto release;
 
-	firmware = fw->data;
-	size = fw->size;
-
 	while (size) {
 		timeout = jiffies + HZ;
 		while (1) {
@@ -560,8 +551,6 @@
 release:
 	sdio_release_host(card->func);
 	kfree(chunk_buffer);
-release_fw:
-	release_firmware(fw);
 
 out:
 	if (ret)
@@ -572,29 +561,21 @@
 	return ret;
 }
 
-static int if_sdio_prog_real(struct if_sdio_card *card)
+static int if_sdio_prog_real(struct if_sdio_card *card, const u8* firmware, size_t size)
 {
 	int ret;
 	u8 status;
-	const struct firmware *fw;
 	unsigned long timeout;
 	u8 *chunk_buffer;
 	u32 chunk_size;
-	const u8 *firmware;
-	size_t size, req_size;
+	size_t req_size;
 
 	lbs_deb_enter(LBS_DEB_SDIO);
 
-	ret = request_firmware(&fw, card->firmware, &card->func->dev);
-	if (ret) {
-		lbs_pr_err("can't load firmware\n");
-		goto out;
-	}
-
 	chunk_buffer = kzalloc(512, GFP_KERNEL);
 	if (!chunk_buffer) {
 		ret = -ENOMEM;
-		goto release_fw;
+		goto out;
 	}
 
 	sdio_claim_host(card->func);
@@ -603,9 +584,6 @@
 	if (ret)
 		goto release;
 
-	firmware = fw->data;
-	size = fw->size;
-
 	while (size) {
 		timeout = jiffies + HZ;
 		while (1) {
@@ -695,8 +673,6 @@
 release:
 	sdio_release_host(card->func);
 	kfree(chunk_buffer);
-release_fw:
-	release_firmware(fw);
 
 out:
 	if (ret)
@@ -707,7 +683,7 @@
 	return ret;
 }
 
-static int if_sdio_prog_firmware(struct if_sdio_card *card)
+static int if_sdio_prog_firmware(struct if_sdio_card *card, const u8* helper, size_t helper_size, const u8* real, size_t real_size)
 {
 	int ret;
 	u16 scratch;
@@ -728,11 +704,11 @@
 		goto success;
 	}
 
-	ret = if_sdio_prog_helper(card);
+	ret = if_sdio_prog_helper(card, helper, helper_size);
 	if (ret)
 		goto out;
 
-	ret = if_sdio_prog_real(card);
+	ret = if_sdio_prog_real(card, real, real_size);
 	if (ret)
 		goto out;
 
@@ -748,6 +724,57 @@
 	return ret;
 }
 
+static int if_sdio_probe_complete(struct if_sdio_card *card);
+
+static void if_sdio_got_firmware(const struct firmware* fw, void *context)
+{
+	u8* firmware;
+	size_t size;
+	struct if_sdio_card *card = context;
+
+	if(!fw)
+	{
+		lbs_pr_err("unable to obtain main firmware, trying again...");
+		request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG, card->firmware, &card->func->dev, card, if_sdio_got_firmware);
+		return;
+	}
+
+	firmware = kmalloc(fw->size, GFP_KERNEL);
+	size = fw->size;
+	memcpy(firmware, fw->data, fw->size);
+
+	if(if_sdio_prog_firmware(card, card->helper_fw, card->helper_fw_size, firmware, size) != 0)
+		goto release_fw;
+
+	if_sdio_probe_complete(card);
+
+release_fw:
+	kfree(card->helper_fw);
+	kfree(firmware);
+
+	/* caller will release_firmware for us */
+}
+
+static void if_sdio_got_helper(const struct firmware* fw, void *context)
+{
+	struct if_sdio_card *card = context;
+
+	if(fw)
+	{
+		card->helper_fw = kmalloc(fw->size, GFP_KERNEL);
+		card->helper_fw_size = fw->size;
+		memcpy(card->helper_fw, fw->data, fw->size);
+
+		request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG, card->firmware, &card->func->dev, card, if_sdio_got_firmware);
+	} else
+	{
+		lbs_pr_err("unable to obtain helper firmware, trying again...");
+		request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG, card->helper, &card->func->dev, card, if_sdio_got_helper);
+	}
+
+	/* caller will release_firmware for us */
+}
+
 /*******************************************************************/
 /* Libertas callbacks                                              */
 /*******************************************************************/
@@ -875,11 +902,95 @@
 	lbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);
 }
 
+static int if_sdio_probe_complete(struct if_sdio_card *card)
+{
+	int ret;
+	struct lbs_private *priv;
+	struct if_sdio_packet *packet;
+	struct sdio_func *func = card->func;
+
+	lbs_deb_enter(LBS_DEB_SDIO);
+
+	priv = lbs_add_card(card, &func->dev);
+	if (!priv) {
+		ret = -ENOMEM;
+		goto reclaim;
+	}
+
+	card->priv = priv;
+
+	priv->card = card;
+	priv->hw_host_to_card = if_sdio_host_to_card;
+
+	priv->fw_ready = 1;
+
+	sdio_claim_host(func);
+
+	/*
+	 * Get rx_unit if the chip is SD8688 or newer.
+	 * SD8385 & SD8686 do not have rx_unit.
+	 */
+	if ((card->model != IF_SDIO_MODEL_8385)
+			&& (card->model != IF_SDIO_MODEL_8686))
+		card->rx_unit = if_sdio_read_rx_unit(card);
+	else
+		card->rx_unit = 0;
+
+	/*
+	 * Enable interrupts now that everything is set up
+	 */
+	sdio_writeb(func, 0x0f, IF_SDIO_H_INT_MASK, &ret);
+	sdio_release_host(func);
+	if (ret)
+		goto reclaim;
+
+	/*
+	 * FUNC_INIT is required for SD8688 WLAN/BT multiple functions
+	 */
+	if (card->model == IF_SDIO_MODEL_8688) {
+		struct cmd_header cmd;
+
+		memset(&cmd, 0, sizeof(cmd));
+
+		lbs_deb_sdio("send function INIT command\n");
+		if (__lbs_cmd(priv, CMD_FUNC_INIT, &cmd, sizeof(cmd),
+				lbs_cmd_copyback, (unsigned long) &cmd))
+			lbs_pr_alert("CMD_FUNC_INIT cmd failed\n");
+	}
+
+	ret = lbs_start_card(priv);
+	if (ret)
+		goto err_activate_card;
+
+out:
+	lbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);
+
+	return ret;
+
+err_activate_card:
+	flush_workqueue(card->workqueue);
+	lbs_remove_card(priv);
+reclaim:
+	sdio_claim_host(func);
+	sdio_release_irq(func);
+	sdio_disable_func(func);
+	sdio_release_host(func);
+	destroy_workqueue(card->workqueue);
+	while (card->packets) {
+		packet = card->packets;
+		card->packets = card->packets->next;
+		kfree(packet);
+	}
+
+	kfree(card);
+
+	goto out;
+}
+
 static int if_sdio_probe(struct sdio_func *func,
 		const struct sdio_device_id *id)
 {
 	struct if_sdio_card *card;
-	struct lbs_private *priv;
 	int ret, i;
 	unsigned int model;
 	struct if_sdio_packet *packet;
@@ -984,69 +1095,15 @@
 			func->class, func->vendor, func->device,
 			model, (unsigned)card->ioport);
 
-	ret = if_sdio_prog_firmware(card);
-	if (ret)
-		goto reclaim;
-
-	priv = lbs_add_card(card, &func->dev);
-	if (!priv) {
-		ret = -ENOMEM;
-		goto reclaim;
-	}
-
-	card->priv = priv;
-
-	priv->card = card;
-	priv->hw_host_to_card = if_sdio_host_to_card;
-
-	priv->fw_ready = 1;
-
-	sdio_claim_host(func);
-
-	/*
-	 * Get rx_unit if the chip is SD8688 or newer.
-	 * SD8385 & SD8686 do not have rx_unit.
-	 */
-	if ((card->model != IF_SDIO_MODEL_8385)
-			&& (card->model != IF_SDIO_MODEL_8686))
-		card->rx_unit = if_sdio_read_rx_unit(card);
-	else
-		card->rx_unit = 0;
-
-	/*
-	 * Enable interrupts now that everything is set up
-	 */
-	sdio_writeb(func, 0x0f, IF_SDIO_H_INT_MASK, &ret);
-	sdio_release_host(func);
+	ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG, card->helper, &card->func->dev, card, if_sdio_got_helper);
 	if (ret)
 		goto reclaim;
 
-	/*
-	 * FUNC_INIT is required for SD8688 WLAN/BT multiple functions
-	 */
-	if (card->model == IF_SDIO_MODEL_8688) {
-		struct cmd_header cmd;
-
-		memset(&cmd, 0, sizeof(cmd));
-
-		lbs_deb_sdio("send function INIT command\n");
-		if (__lbs_cmd(priv, CMD_FUNC_INIT, &cmd, sizeof(cmd),
-				lbs_cmd_copyback, (unsigned long) &cmd))
-			lbs_pr_alert("CMD_FUNC_INIT cmd failed\n");
-	}
-
-	ret = lbs_start_card(priv);
-	if (ret)
-		goto err_activate_card;
-
 out:
 	lbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);
 
 	return ret;
 
-err_activate_card:
-	flush_workqueue(card->workqueue);
-	lbs_remove_card(priv);
 reclaim:
 	sdio_claim_host(func);
 release_int:
diff -Nur linux-2.6.32-orig/drivers/net/wireless/libertas/main.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/libertas/main.c
--- linux-2.6.32-orig/drivers/net/wireless/libertas/main.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/libertas/main.c	2010-11-18 21:05:30.000000000 +0600
@@ -24,6 +24,41 @@
 #include "assoc.h"
 #include "cmd.h"
 
+
+/* Begin iPhone ATAG stuff */
+
+static u8 iphone_mac[6];
+static u8 iphone_wifi_cal[0x400];
+static size_t iphone_wifi_cal_size = 0;
+
+#include <asm/setup.h>
+#define ATAG_IPHONE_WIFI 0x54411002
+
+struct atag_iphone_wifi {
+	u8         mac[6];
+	u32        calSize;
+	u8         cal[];
+};
+
+struct atag_iphone_type {
+	u32        type;
+};
+
+static int __init parse_tag_wifi(const struct tag *tag)
+{
+	const struct atag_iphone_wifi* wifi_tag = (const struct atag_iphone_wifi*)(((const u8*)tag) + sizeof(struct tag_header));
+
+	memcpy(iphone_mac, wifi_tag->mac, 6);
+	iphone_wifi_cal_size = wifi_tag->calSize;
+	memset(iphone_wifi_cal, 0, sizeof(iphone_wifi_cal));
+	memcpy(iphone_wifi_cal, wifi_tag->cal, iphone_wifi_cal_size);
+
+	return 0;
+}
+__tagtable(ATAG_IPHONE_WIFI, parse_tag_wifi);
+
+/* End iPhone ATAG stuff */
+
 #define DRIVER_RELEASE_VERSION "323.p0"
 const char lbs_driver_version[] = "COMM-USB8388-" DRIVER_RELEASE_VERSION
 #ifdef  DEBUG
@@ -991,6 +1026,86 @@
 }
 EXPORT_SYMBOL_GPL(lbs_resume);
 
+static int lbs_set_rf_reg(struct lbs_private* priv, u16 offset, u8 value)
+{
+	struct lbs_offset_value offval;
+	int ret;
+
+	offval.offset = offset;
+	offval.value = value;
+
+	ret = lbs_prepare_and_send_command(priv,
+				CMD_BBP_REG_ACCESS, CMD_ACT_SET,
+				CMD_OPTION_WAITFORRSP, 0, &offval);
+
+	return ret;
+}
+
+static int lbs_set_mac_reg(struct lbs_private* priv, u16 offset, u32 value)
+{
+	struct lbs_offset_value offval;
+	int ret;
+
+	offval.offset = offset;
+	offval.value = value;
+
+	ret = lbs_prepare_and_send_command(priv,
+				CMD_MAC_REG_ACCESS, CMD_ACT_SET,
+				CMD_OPTION_WAITFORRSP, 0, &offval);
+
+	return ret;
+}
+
+static int lbs_get_mac_reg(struct lbs_private* priv, u16 offset, u32* value)
+{
+	struct lbs_offset_value offval;
+	int ret;
+
+	offval.offset = offset;
+	offval.value = 0;
+
+	ret = lbs_prepare_and_send_command(priv,
+				CMD_MAC_REG_ACCESS, CMD_ACT_GET,
+				CMD_OPTION_WAITFORRSP, 0, &offval);
+
+	*value = priv->offsetvalue.value;
+
+	return ret;
+}
+
+static int lbs_set_bbp_reg(struct lbs_private* priv, u16 offset, u8 value)
+{
+	struct lbs_offset_value offval;
+	int ret;
+
+	offval.offset = offset;
+	offval.value = value;
+
+	ret = lbs_prepare_and_send_command(priv,
+				CMD_RF_REG_ACCESS, CMD_ACT_SET,
+				CMD_OPTION_WAITFORRSP, 0, &offval);
+
+	return ret;
+}
+
+static void lbs_set_tx_cal_data(struct lbs_private *priv)
+{
+	struct cmd_ds_802_11_cal_data_ext* cmd;
+	int ret;
+
+	cmd = kzalloc(sizeof(struct cmd_ds_802_11_cal_data_ext), GFP_KERNEL);
+
+	cmd->hdr.size = cpu_to_le16(sizeof(struct cmd_ds_802_11_cal_data_ext) - LBS_CAL_DATA_LEN + sizeof(iphone_wifi_cal));
+	cmd->action = cpu_to_le16(CMD_ACT_SET);
+	cmd->revision = cpu_to_le16(0);
+	cmd->len = cpu_to_le16(sizeof(iphone_wifi_cal));
+
+	memcpy(cmd->data, iphone_wifi_cal, sizeof(iphone_wifi_cal));
+
+	ret = lbs_cmd_with_response(priv, CMD_802_11_CAL_DATA_EXT, cmd);
+	kfree(cmd);
+}
+
 /**
  * @brief This function gets the HW spec from the firmware and sets
  *        some basic parameters.
@@ -1000,17 +1115,94 @@
  */
 static int lbs_setup_firmware(struct lbs_private *priv)
 {
+	struct sleep_params sp;
 	int ret = -1;
+	u32 macv;
 	s16 curlevel = 0, minlevel = 0, maxlevel = 0;
 
 	lbs_deb_enter(LBS_DEB_FW);
 
+	sp.sp_error = 5000;
+	sp.sp_offset = 500;
+	sp.sp_stabletime = 4000;
+	sp.sp_calcontrol = 2;
+	sp.sp_extsleepclk = 2;
+	sp.sp_reserved = 0;
+
+	ret = lbs_cmd_802_11_sleep_params(priv, CMD_ACT_SET, &sp);
+	if (ret)
+		goto done;
+
 	/* Read MAC address from firmware */
 	memset(priv->current_addr, 0xff, ETH_ALEN);
 	ret = lbs_update_hw_spec(priv);
 	if (ret)
 		goto done;
 
+	if(iphone_wifi_cal_size > 0)
+	{
+		/* Initialize wifi variables from baseband NVRAM */
+
+		struct cmd_ds_802_11_mac_address cmd;
+
+		cmd.hdr.size = cpu_to_le16(sizeof(cmd));
+		cmd.action = cpu_to_le16(CMD_ACT_SET);
+		memcpy(cmd.macadd, iphone_mac, ETH_ALEN);
+
+		ret = lbs_cmd_with_response(priv, CMD_802_11_MAC_ADDRESS, &cmd);
+		if (ret) {
+			lbs_deb_net("set MAC address failed\n");
+			goto done;
+		}
+
+		memcpy(priv->current_addr, iphone_mac, ETH_ALEN);
+		memcpy(priv->dev->dev_addr, iphone_mac, ETH_ALEN);
+
+		lbs_set_tx_cal_data(priv);
+	}
+
+	lbs_set_mac_control(priv);
+
+	ret = lbs_set_radio(priv, RADIO_PREAMBLE_LONG, 1);
+	if (ret)
+		goto done;
+
+	lbs_set_rf_reg(priv, 0x50, 0x50);
+	lbs_set_rf_reg(priv, 0x6B, 0xAE);
+	lbs_set_mac_reg(priv, 0xA240, 0xA3000);
+
+	// 2G = 0, 3G = 1, iPod = 2
+
+	// 2G config
+#ifdef CONFIG_IPHONE_2G
+	lbs_set_mac_reg(priv, 0xA5AC, 0xC8);
+	lbs_set_mac_reg(priv, 0xA5B0, 0xC8 << 2);
+	lbs_set_mac_reg(priv, 0xA5A8, 0xAF << 3);
+	lbs_set_mac_reg(priv, 0xA5B4, 0xAF << 4);
+	lbs_set_mac_reg(priv, 0xA5A4, 0xAF << 4);
+	lbs_set_mac_reg(priv, 0xA58C, 0x40214);
+	lbs_set_mac_reg(priv, 0xA5A0, 0x524D);
+	lbs_set_mac_reg(priv, 0xA5F0, 0xA2271814);
+#endif
+
+	// 3G config
+#ifdef CONFIG_IPHONE_3G
+	lbs_set_mac_reg(priv, 0xA58C, 0x40212);
+	lbs_set_mac_reg(priv, 0xA5A0, 0x524D);
+	lbs_set_mac_reg(priv, 0xA5F0, 0xA2271814);
+	lbs_set_bbp_reg(priv, 0xE9, 0xB1);
+	lbs_set_bbp_reg(priv, 0xEF, 0xC);
+	lbs_set_rf_reg(priv, 0x32, 0x5D);
+	lbs_set_rf_reg(priv, 0x6B, 0xAE);
+#endif
+
+	// iPod touch config
+#ifdef CONFIG_IPODTOUCH_1G
+	lbs_set_mac_reg(priv, 0xA58C, 0x40212);
+	lbs_set_mac_reg(priv, 0xA5A0, 0xD24D);
+	lbs_set_mac_reg(priv, 0xA5F0, 0xA027181C);
+#endif
+
 	/* Read power levels if available */
 	ret = lbs_get_tx_power(priv, &curlevel, &minlevel, &maxlevel);
 	if (ret == 0) {
@@ -1019,7 +1211,11 @@
 		priv->txpower_max = maxlevel;
 	}
 
-	lbs_set_mac_control(priv);
+	lbs_set_bbp_reg(priv, 0x4E, 0x1B);
+
+	lbs_get_mac_reg(priv, 0x2048, &macv);
+	lbs_set_mac_reg(priv, 0x2048, macv | 0x80);
+
 done:
 	lbs_deb_leave_args(LBS_DEB_FW, "ret %d", ret);
 	return ret;
diff -Nur linux-2.6.32-orig/drivers/net/wireless/libertas/scan.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/libertas/scan.c
--- linux-2.6.32-orig/drivers/net/wireless/libertas/scan.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/libertas/scan.c	2010-11-18 21:05:30.000000000 +0600
@@ -58,6 +58,8 @@
 
 #define DEFAULT_MAX_SCAN_AGE (15 * HZ)
 
+int libertas_current_scan_mode = CMD_SCAN_TYPE_ACTIVE;
+
 static int lbs_ret_80211_scan(struct lbs_private *priv, unsigned long dummy,
 			      struct cmd_header *resp);
 
@@ -158,7 +160,7 @@
 	 *   be changed to passive on a per channel basis if restricted by
 	 *   regulatory requirements (11d or 11h)
 	 */
-	scantype = CMD_SCAN_TYPE_ACTIVE;
+	scantype = libertas_current_scan_mode;
 
 	for (rgnidx = 0; rgnidx < ARRAY_SIZE(priv->region_channel); rgnidx++) {
 		if (priv->enable11d && (priv->connect_status != LBS_CONNECTED)
@@ -399,11 +401,8 @@
 	chan_count = lbs_scan_create_channel_list(priv, chan_list);
 
 	netif_stop_queue(priv->dev);
-	netif_carrier_off(priv->dev);
-	if (priv->mesh_dev) {
+	if (priv->mesh_dev)
 		netif_stop_queue(priv->mesh_dev);
-		netif_carrier_off(priv->mesh_dev);
-	}
 
 	/* Prepare to continue an interrupted scan */
 	lbs_deb_scan("chan_count %d, scan_channel %d\n",
@@ -467,16 +466,13 @@
 	priv->scan_channel = 0;
 
 out:
-	if (priv->connect_status == LBS_CONNECTED) {
-		netif_carrier_on(priv->dev);
-		if (!priv->tx_pending_len)
-			netif_wake_queue(priv->dev);
-	}
-	if (priv->mesh_dev && (priv->mesh_connect_status == LBS_CONNECTED)) {
-		netif_carrier_on(priv->mesh_dev);
-		if (!priv->tx_pending_len)
-			netif_wake_queue(priv->mesh_dev);
-	}
+	if (priv->connect_status == LBS_CONNECTED && !priv->tx_pending_len)
+		netif_wake_queue(priv->dev);
+
+	if (priv->mesh_dev && (priv->mesh_connect_status == LBS_CONNECTED) &&
+	    !priv->tx_pending_len)
+		netif_wake_queue(priv->mesh_dev);
+
 	kfree(chan_list);
 
 	lbs_deb_leave_args(LBS_DEB_SCAN, "ret %d", ret);
diff -Nur linux-2.6.32-orig/drivers/net/wireless/libertas/wext.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/libertas/wext.c
--- linux-2.6.32-orig/drivers/net/wireless/libertas/wext.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/libertas/wext.c	2010-11-18 21:05:30.000000000 +0600
@@ -1953,10 +1953,8 @@
 	if (priv->connect_status == LBS_CONNECTED) {
 		memcpy(extra, priv->curbssparams.ssid,
 		       priv->curbssparams.ssid_len);
-		extra[priv->curbssparams.ssid_len] = '\0';
 	} else {
 		memset(extra, 0, 32);
-		extra[priv->curbssparams.ssid_len] = '\0';
 	}
 	/*
 	 * If none, we may want to get the one that was set
@@ -2137,6 +2135,100 @@
 	return ret;
 }
 
+extern int libertas_current_scan_mode;
+
+static int lbs_priv_cmds(struct net_device *dev, struct iw_request_info *info,
+		   struct iw_point *dwrq, char *extra)
+{
+	int ret = 0;
+	struct lbs_private *priv = dev->ml_priv;
+
+	lbs_deb_enter(LBS_DEB_WEXT);
+
+	extra = kzalloc(dwrq->length, GFP_KERNEL);
+	if(!extra)
+	{
+		lbs_deb_leave(LBS_DEB_WEXT);
+		return -ENOMEM;
+	}
+
+	if(copy_from_user(extra, dwrq->pointer, dwrq->length))
+	{
+		ret = -EFAULT;
+		goto out;
+	}
+
+	if(strncasecmp(extra, "START", dwrq->length) == 0)
+	{
+		printk("libertas: ignoring START command\n");
+	} else if(strncasecmp(extra, "STOP", dwrq->length) == 0)
+	{
+		printk("libertas: ignoring STOP command\n");
+	} else if(strncasecmp(extra, "RSSI", dwrq->length) == 0)
+	{
+		if (priv->connect_status == LBS_CONNECTED)
+		{
+			int rssi;
+			int level;
+			int noise;
+
+			level = CAL_RSSI(priv->SNR[TYPE_BEACON][TYPE_NOAVG], priv->NF[TYPE_BEACON][TYPE_NOAVG]);
+
+			if (priv->NF[TYPE_BEACON][TYPE_NOAVG] == 0)
+				noise = MRVDRV_NF_DEFAULT_SCAN_VALUE;
+			else
+				noise = CAL_NF(priv->NF[TYPE_BEACON][TYPE_NOAVG]);
+
+			rssi = level - noise;
+
+			memcpy(extra, priv->curbssparams.ssid, priv->curbssparams.ssid_len);
+			sprintf(extra + priv->curbssparams.ssid_len, " Rssi %d", rssi);
+
+			dwrq->length = strlen(extra) + 1;
+
+			if(copy_to_user(dwrq->pointer, extra, dwrq->length))
+			{
+				ret = -EFAULT;
+				goto out;
+			}
+		} else {
+			ret = -1;
+			goto out;
+		}
+	} else if(strncasecmp(extra, "LINKSPEED", dwrq->length) == 0)
+	{
+		sprintf(extra, "LinkSpeed %d", (priv->cur_rate * 5) / 10);
+		dwrq->length = strlen(extra) + 1;
+		if(copy_to_user(dwrq->pointer, extra, dwrq->length))
+		{
+			ret = -EFAULT;
+			goto out;
+		}
+	} else if(strncasecmp(extra, "MACADDR", dwrq->length) == 0)
+	{
+		sprintf(extra, "Macaddr = %02X.%02X.%02X.%02X.%02X.%02X",
+				priv->current_addr[0], priv->current_addr[1], priv->current_addr[2],
+				priv->current_addr[3], priv->current_addr[4], priv->current_addr[5]);
+		dwrq->length = strlen(extra) + 1;
+		if(copy_to_user(dwrq->pointer, extra, dwrq->length))
+		{
+			ret = -EFAULT;
+			goto out;
+		}
+	} else if(strncasecmp(extra, "SCAN-ACTIVE", dwrq->length) == 0)
+	{
+		libertas_current_scan_mode = CMD_SCAN_TYPE_ACTIVE;
+	} else if(strncasecmp(extra, "SCAN-PASSIVE", dwrq->length) == 0)
+	{
+		libertas_current_scan_mode = CMD_SCAN_TYPE_PASSIVE;
+	}
+
+out:
+	kfree(extra);
+	lbs_deb_leave(LBS_DEB_WEXT);
+	return ret;
+}
+
 /*
  * iwconfig settable callbacks
  */
@@ -2153,7 +2245,7 @@
 	(iw_handler) NULL,	/* SIOCGIWSENS */
 	(iw_handler) NULL,	/* SIOCSIWRANGE */
 	(iw_handler) lbs_get_range,	/* SIOCGIWRANGE */
-	(iw_handler) NULL,	/* SIOCSIWPRIV */
+	(iw_handler) lbs_priv_cmds,	/* SIOCSIWPRIV */
 	(iw_handler) NULL,	/* SIOCGIWPRIV */
 	(iw_handler) NULL,	/* SIOCSIWSTATS */
 	(iw_handler) NULL,	/* SIOCGIWSTATS */
diff -Nur linux-2.6.32-orig/drivers/net/wireless/orinoco/wext.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/orinoco/wext.c
--- linux-2.6.32-orig/drivers/net/wireless/orinoco/wext.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/orinoco/wext.c	2010-11-18 21:05:30.000000000 +0600
@@ -23,7 +23,7 @@
 #define MAX_RID_LEN 1024
 
 /* Helper routine to record keys
- * Do not call from interrupt context */
+ * It is called under orinoco_lock so it may not sleep */
 static int orinoco_set_key(struct orinoco_private *priv, int index,
 			   enum orinoco_alg alg, const u8 *key, int key_len,
 			   const u8 *seq, int seq_len)
@@ -32,14 +32,14 @@
 	kzfree(priv->keys[index].seq);
 
 	if (key_len) {
-		priv->keys[index].key = kzalloc(key_len, GFP_KERNEL);
+		priv->keys[index].key = kzalloc(key_len, GFP_ATOMIC);
 		if (!priv->keys[index].key)
 			goto nomem;
 	} else
 		priv->keys[index].key = NULL;
 
 	if (seq_len) {
-		priv->keys[index].seq = kzalloc(seq_len, GFP_KERNEL);
+		priv->keys[index].seq = kzalloc(seq_len, GFP_ATOMIC);
 		if (!priv->keys[index].seq)
 			goto free_key;
 	} else
diff -Nur linux-2.6.32-orig/drivers/net/wireless/rt2x00/rt61pci.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/rt2x00/rt61pci.c
--- linux-2.6.32-orig/drivers/net/wireless/rt2x00/rt61pci.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/rt2x00/rt61pci.c	2010-11-18 21:05:30.000000000 +0600
@@ -2538,6 +2538,11 @@
 	unsigned int i;
 
 	/*
+	 * Disable powersaving as default.
+	 */
+	rt2x00dev->hw->wiphy->ps_default = false;
+
+	/*
 	 * Initialize all hw fields.
 	 */
 	rt2x00dev->hw->flags =
diff -Nur linux-2.6.32-orig/drivers/net/wireless/rtl818x/rtl8187_dev.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/rtl818x/rtl8187_dev.c
--- linux-2.6.32-orig/drivers/net/wireless/rtl818x/rtl8187_dev.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/rtl818x/rtl8187_dev.c	2010-11-18 21:05:30.000000000 +0600
@@ -65,6 +65,7 @@
 	/* Sitecom */
 	{USB_DEVICE(0x0df6, 0x000d), .driver_info = DEVICE_RTL8187},
 	{USB_DEVICE(0x0df6, 0x0028), .driver_info = DEVICE_RTL8187B},
+	{USB_DEVICE(0x0df6, 0x0029), .driver_info = DEVICE_RTL8187B},
 	/* Sphairon Access Systems GmbH */
 	{USB_DEVICE(0x114B, 0x0150), .driver_info = DEVICE_RTL8187},
 	/* Dick Smith Electronics */
@@ -1329,6 +1330,7 @@
 	struct ieee80211_channel *channel;
 	const char *chip_name;
 	u16 txpwr, reg;
+	u16 product_id = le16_to_cpu(udev->descriptor.idProduct);
 	int err, i;
 
 	dev = ieee80211_alloc_hw(sizeof(*priv), &rtl8187_ops);
@@ -1488,6 +1490,13 @@
 		(*channel++).hw_value = txpwr & 0xFF;
 		(*channel++).hw_value = txpwr >> 8;
 	}
+	/* Handle the differing rfkill GPIO bit in different models */
+	priv->rfkill_mask = RFKILL_MASK_8187_89_97;
+	if (product_id == 0x8197 || product_id == 0x8198) {
+		eeprom_93cx6_read(&eeprom, RTL8187_EEPROM_SELECT_GPIO, &reg);
+		if (reg & 0xFF00)
+			priv->rfkill_mask = RFKILL_MASK_8198;
+	}
 
 	/*
 	 * XXX: Once this driver supports anything that requires
@@ -1516,9 +1525,9 @@
 	mutex_init(&priv->conf_mutex);
 	skb_queue_head_init(&priv->b_tx_status.queue);
 
-	printk(KERN_INFO "%s: hwaddr %pM, %s V%d + %s\n",
+	printk(KERN_INFO "%s: hwaddr %pM, %s V%d + %s, rfkill mask %d\n",
 	       wiphy_name(dev->wiphy), dev->wiphy->perm_addr,
-	       chip_name, priv->asic_rev, priv->rf->name);
+	       chip_name, priv->asic_rev, priv->rf->name, priv->rfkill_mask);
 
 #ifdef CONFIG_RTL8187_LEDS
 	eeprom_93cx6_read(&eeprom, 0x3F, &reg);
diff -Nur linux-2.6.32-orig/drivers/net/wireless/rtl818x/rtl8187.h iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/rtl818x/rtl8187.h
--- linux-2.6.32-orig/drivers/net/wireless/rtl818x/rtl8187.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/rtl818x/rtl8187.h	2010-11-18 21:05:30.000000000 +0600
@@ -23,6 +23,7 @@
 #define RTL8187_EEPROM_TXPWR_CHAN_1	0x16	/* 3 channels */
 #define RTL8187_EEPROM_TXPWR_CHAN_6	0x1B	/* 2 channels */
 #define RTL8187_EEPROM_TXPWR_CHAN_4	0x3D	/* 2 channels */
+#define RTL8187_EEPROM_SELECT_GPIO	0x3B
 
 #define RTL8187_REQT_READ	0xC0
 #define RTL8187_REQT_WRITE	0x40
@@ -31,6 +32,9 @@
 
 #define RTL8187_MAX_RX		0x9C4
 
+#define RFKILL_MASK_8187_89_97	0x2
+#define RFKILL_MASK_8198	0x4
+
 struct rtl8187_rx_info {
 	struct urb *urb;
 	struct ieee80211_hw *dev;
@@ -123,6 +127,7 @@
 	u8 noise;
 	u8 slot_time;
 	u8 aifsn[4];
+	u8 rfkill_mask;
 	struct {
 		__le64 buf;
 		struct sk_buff_head queue;
diff -Nur linux-2.6.32-orig/drivers/net/wireless/rtl818x/rtl8187_rfkill.c iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/rtl818x/rtl8187_rfkill.c
--- linux-2.6.32-orig/drivers/net/wireless/rtl818x/rtl8187_rfkill.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/net/wireless/rtl818x/rtl8187_rfkill.c	2010-11-18 21:05:30.000000000 +0600
@@ -25,10 +25,10 @@
 	u8 gpio;
 
 	gpio = rtl818x_ioread8(priv, &priv->map->GPIO0);
-	rtl818x_iowrite8(priv, &priv->map->GPIO0, gpio & ~0x02);
+	rtl818x_iowrite8(priv, &priv->map->GPIO0, gpio & ~priv->rfkill_mask);
 	gpio = rtl818x_ioread8(priv, &priv->map->GPIO1);
 
-	return gpio & 0x02;
+	return gpio & priv->rfkill_mask;
 }
 
 void rtl8187_rfkill_init(struct ieee80211_hw *hw)
diff -Nur linux-2.6.32-orig/drivers/pci/dmar.c iDroid-Project-kernel_common-9e90fd2/drivers/pci/dmar.c
--- linux-2.6.32-orig/drivers/pci/dmar.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/pci/dmar.c	2010-11-18 21:05:30.000000000 +0600
@@ -582,6 +582,8 @@
 	return 0;
 }
 
+static int bios_warned;
+
 int __init check_zero_address(void)
 {
 	struct acpi_table_dmar *dmar;
@@ -601,6 +603,9 @@
 		}
 
 		if (entry_header->type == ACPI_DMAR_TYPE_HARDWARE_UNIT) {
+			void __iomem *addr;
+			u64 cap, ecap;
+
 			drhd = (void *)entry_header;
 			if (!drhd->address) {
 				/* Promote an attitude of violence to a BIOS engineer today */
@@ -609,17 +614,40 @@
 				     dmi_get_system_info(DMI_BIOS_VENDOR),
 				     dmi_get_system_info(DMI_BIOS_VERSION),
 				     dmi_get_system_info(DMI_PRODUCT_VERSION));
-#ifdef CONFIG_DMAR
-				dmar_disabled = 1;
-#endif
-				return 0;
+				bios_warned = 1;
+				goto failed;
+			}
+
+			addr = early_ioremap(drhd->address, VTD_PAGE_SIZE);
+			if (!addr ) {
+				printk("IOMMU: can't validate: %llx\n", drhd->address);
+				goto failed;
+			}
+			cap = dmar_readq(addr + DMAR_CAP_REG);
+			ecap = dmar_readq(addr + DMAR_ECAP_REG);
+			early_iounmap(addr, VTD_PAGE_SIZE);
+			if (cap == (uint64_t)-1 && ecap == (uint64_t)-1) {
+				/* Promote an attitude of violence to a BIOS engineer today */
+				WARN(1, "Your BIOS is broken; DMAR reported at address %llx returns all ones!\n"
+				     "BIOS vendor: %s; Ver: %s; Product Version: %s\n",
+				      drhd->address,
+				      dmi_get_system_info(DMI_BIOS_VENDOR),
+				      dmi_get_system_info(DMI_BIOS_VERSION),
+				      dmi_get_system_info(DMI_PRODUCT_VERSION));
+				bios_warned = 1;
+				goto failed;
 			}
-			break;
 		}
 
 		entry_header = ((void *)entry_header + entry_header->length);
 	}
 	return 1;
+
+failed:
+#ifdef CONFIG_DMAR
+	dmar_disabled = 1;
+#endif
+	return 0;
 }
 
 void __init detect_intel_iommu(void)
@@ -664,6 +692,18 @@
 	int agaw = 0;
 	int msagaw = 0;
 
+	if (!drhd->reg_base_addr) {
+		if (!bios_warned) {
+			WARN(1, "Your BIOS is broken; DMAR reported at address zero!\n"
+			     "BIOS vendor: %s; Ver: %s; Product Version: %s\n",
+			     dmi_get_system_info(DMI_BIOS_VENDOR),
+			     dmi_get_system_info(DMI_BIOS_VERSION),
+			     dmi_get_system_info(DMI_PRODUCT_VERSION));
+			bios_warned = 1;
+		}
+		return -EINVAL;
+	}
+
 	iommu = kzalloc(sizeof(*iommu), GFP_KERNEL);
 	if (!iommu)
 		return -ENOMEM;
@@ -680,13 +720,16 @@
 	iommu->ecap = dmar_readq(iommu->reg + DMAR_ECAP_REG);
 
 	if (iommu->cap == (uint64_t)-1 && iommu->ecap == (uint64_t)-1) {
-		/* Promote an attitude of violence to a BIOS engineer today */
-		WARN(1, "Your BIOS is broken; DMAR reported at address %llx returns all ones!\n"
-		     "BIOS vendor: %s; Ver: %s; Product Version: %s\n",
-		     drhd->reg_base_addr,
-		     dmi_get_system_info(DMI_BIOS_VENDOR),
-		     dmi_get_system_info(DMI_BIOS_VERSION),
-		     dmi_get_system_info(DMI_PRODUCT_VERSION));
+		if (!bios_warned) {
+			/* Promote an attitude of violence to a BIOS engineer today */
+			WARN(1, "Your BIOS is broken; DMAR reported at address %llx returns all ones!\n"
+			     "BIOS vendor: %s; Ver: %s; Product Version: %s\n",
+			     drhd->reg_base_addr,
+			     dmi_get_system_info(DMI_BIOS_VENDOR),
+			     dmi_get_system_info(DMI_BIOS_VERSION),
+			     dmi_get_system_info(DMI_PRODUCT_VERSION));
+			bios_warned = 1;
+		}
 		goto err_unmap;
 	}
 
diff -Nur linux-2.6.32-orig/drivers/pci/intel-iommu.c iDroid-Project-kernel_common-9e90fd2/drivers/pci/intel-iommu.c
--- linux-2.6.32-orig/drivers/pci/intel-iommu.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/pci/intel-iommu.c	2010-11-18 21:05:30.000000000 +0600
@@ -1523,12 +1523,15 @@
 
 		/* Skip top levels of page tables for
 		 * iommu which has less agaw than default.
+		 * Unnecessary for PT mode.
 		 */
-		for (agaw = domain->agaw; agaw != iommu->agaw; agaw--) {
-			pgd = phys_to_virt(dma_pte_addr(pgd));
-			if (!dma_pte_present(pgd)) {
-				spin_unlock_irqrestore(&iommu->lock, flags);
-				return -ENOMEM;
+		if (translation != CONTEXT_TT_PASS_THROUGH) {
+			for (agaw = domain->agaw; agaw != iommu->agaw; agaw--) {
+				pgd = phys_to_virt(dma_pte_addr(pgd));
+				if (!dma_pte_present(pgd)) {
+					spin_unlock_irqrestore(&iommu->lock, flags);
+					return -ENOMEM;
+				}
 			}
 		}
 	}
@@ -1991,6 +1994,16 @@
 	       "IOMMU: Setting identity map for device %s [0x%Lx - 0x%Lx]\n",
 	       pci_name(pdev), start, end);
 	
+	if (end < start) {
+		WARN(1, "Your BIOS is broken; RMRR ends before it starts!\n"
+			"BIOS vendor: %s; Ver: %s; Product Version: %s\n",
+			dmi_get_system_info(DMI_BIOS_VENDOR),
+			dmi_get_system_info(DMI_BIOS_VERSION),
+		     dmi_get_system_info(DMI_PRODUCT_VERSION));
+		ret = -EIO;
+		goto error;
+	}
+
 	if (end >> agaw_to_width(domain->agaw)) {
 		WARN(1, "Your BIOS is broken; RMRR exceeds permitted address width (%d bits)\n"
 		     "BIOS vendor: %s; Ver: %s; Product Version: %s\n",
@@ -3228,6 +3241,9 @@
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct dmar_domain *domain;
 
+	if (iommu_no_mapping(dev))
+		return 0;
+
 	domain = find_domain(pdev);
 	if (!domain)
 		return 0;
diff -Nur linux-2.6.32-orig/drivers/pci/pci.c iDroid-Project-kernel_common-9e90fd2/drivers/pci/pci.c
--- linux-2.6.32-orig/drivers/pci/pci.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/pci/pci.c	2010-11-18 21:05:30.000000000 +0600
@@ -2723,6 +2723,11 @@
 	return 1;
 }
 
+void __weak pci_fixup_cardbus(struct pci_bus *bus)
+{
+}
+EXPORT_SYMBOL(pci_fixup_cardbus);
+
 static int __init pci_setup(char *str)
 {
 	while (str) {
diff -Nur linux-2.6.32-orig/drivers/pci/pcie/aer/aer_inject.c iDroid-Project-kernel_common-9e90fd2/drivers/pci/pcie/aer/aer_inject.c
--- linux-2.6.32-orig/drivers/pci/pcie/aer/aer_inject.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/pci/pcie/aer/aer_inject.c	2010-11-18 21:05:30.000000000 +0600
@@ -392,8 +392,14 @@
 	if (ret)
 		goto out_put;
 
-	if (find_aer_device(rpdev, &edev))
+	if (find_aer_device(rpdev, &edev)) {
+		if (!get_service_data(edev)) {
+			printk(KERN_WARNING "AER service is not initialized\n");
+			ret = -EINVAL;
+			goto out_put;
+		}
 		aer_irq(-1, edev);
+	}
 	else
 		ret = -EINVAL;
 out_put:
diff -Nur linux-2.6.32-orig/drivers/pci/setup-bus.c iDroid-Project-kernel_common-9e90fd2/drivers/pci/setup-bus.c
--- linux-2.6.32-orig/drivers/pci/setup-bus.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/pci/setup-bus.c	2010-11-18 21:05:30.000000000 +0600
@@ -142,7 +142,6 @@
 	struct pci_dev *bridge = bus->self;
 	struct pci_bus_region region;
 	u32 l, bu, lu, io_upper16;
-	int pref_mem64;
 
 	if (pci_is_enabled(bridge))
 		return;
@@ -198,7 +197,6 @@
 	pci_write_config_dword(bridge, PCI_PREF_LIMIT_UPPER32, 0);
 
 	/* Set up PREF base/limit. */
-	pref_mem64 = 0;
 	bu = lu = 0;
 	pcibios_resource_to_bus(bridge, &region, bus->resource[2]);
 	if (bus->resource[2]->flags & IORESOURCE_PREFETCH) {
@@ -206,7 +204,6 @@
 		l = (region.start >> 16) & 0xfff0;
 		l |= region.end & 0xfff00000;
 		if (bus->resource[2]->flags & IORESOURCE_MEM_64) {
-			pref_mem64 = 1;
 			bu = upper_32_bits(region.start);
 			lu = upper_32_bits(region.end);
 			width = 16;
@@ -221,11 +218,9 @@
 	}
 	pci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE, l);
 
-	if (pref_mem64) {
-		/* Set the upper 32 bits of PREF base & limit. */
-		pci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32, bu);
-		pci_write_config_dword(bridge, PCI_PREF_LIMIT_UPPER32, lu);
-	}
+	/* Set the upper 32 bits of PREF base & limit. */
+	pci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32, bu);
+	pci_write_config_dword(bridge, PCI_PREF_LIMIT_UPPER32, lu);
 
 	pci_write_config_word(bridge, PCI_BRIDGE_CONTROL, bus->bridge_ctl);
 }
diff -Nur linux-2.6.32-orig/drivers/pcmcia/cardbus.c iDroid-Project-kernel_common-9e90fd2/drivers/pcmcia/cardbus.c
--- linux-2.6.32-orig/drivers/pcmcia/cardbus.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/pcmcia/cardbus.c	2010-11-18 21:05:30.000000000 +0600
@@ -214,7 +214,7 @@
 	unsigned int max, pass;
 
 	s->functions = pci_scan_slot(bus, PCI_DEVFN(0, 0));
-//	pcibios_fixup_bus(bus);
+	pci_fixup_cardbus(bus);
 
 	max = bus->secondary;
 	for (pass = 0; pass < 2; pass++)
diff -Nur linux-2.6.32-orig/drivers/platform/x86/acerhdf.c iDroid-Project-kernel_common-9e90fd2/drivers/platform/x86/acerhdf.c
--- linux-2.6.32-orig/drivers/platform/x86/acerhdf.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/platform/x86/acerhdf.c	2010-11-18 21:05:30.000000000 +0600
@@ -52,7 +52,7 @@
  */
 #undef START_IN_KERNEL_MODE
 
-#define DRV_VER "0.5.18"
+#define DRV_VER "0.5.20"
 
 /*
  * According to the Atom N270 datasheet,
@@ -112,12 +112,14 @@
 MODULE_PARM_DESC(force_product, "Force BIOS product and omit BIOS check");
 
 /*
- * cmd_off: to switch the fan completely off / to check if the fan is off
+ * cmd_off: to switch the fan completely off
+ * chk_off: to check if the fan is off
  *	cmd_auto: to set the BIOS in control of the fan. The BIOS regulates then
  *		the fan speed depending on the temperature
  */
 struct fancmd {
 	u8 cmd_off;
+	u8 chk_off;
 	u8 cmd_auto;
 };
 
@@ -134,32 +136,41 @@
 /* Register addresses and values for different BIOS versions */
 static const struct bios_settings_t bios_tbl[] = {
 	/* AOA110 */
-	{"Acer", "AOA110", "v0.3109", 0x55, 0x58, {0x1f, 0x00} },
-	{"Acer", "AOA110", "v0.3114", 0x55, 0x58, {0x1f, 0x00} },
-	{"Acer", "AOA110", "v0.3301", 0x55, 0x58, {0xaf, 0x00} },
-	{"Acer", "AOA110", "v0.3304", 0x55, 0x58, {0xaf, 0x00} },
-	{"Acer", "AOA110", "v0.3305", 0x55, 0x58, {0xaf, 0x00} },
-	{"Acer", "AOA110", "v0.3307", 0x55, 0x58, {0xaf, 0x00} },
-	{"Acer", "AOA110", "v0.3308", 0x55, 0x58, {0x21, 0x00} },
-	{"Acer", "AOA110", "v0.3309", 0x55, 0x58, {0x21, 0x00} },
-	{"Acer", "AOA110", "v0.3310", 0x55, 0x58, {0x21, 0x00} },
+	{"Acer", "AOA110", "v0.3109", 0x55, 0x58, {0x1f, 0x1f, 0x00} },
+	{"Acer", "AOA110", "v0.3114", 0x55, 0x58, {0x1f, 0x1f, 0x00} },
+	{"Acer", "AOA110", "v0.3301", 0x55, 0x58, {0xaf, 0xaf, 0x00} },
+	{"Acer", "AOA110", "v0.3304", 0x55, 0x58, {0xaf, 0xaf, 0x00} },
+	{"Acer", "AOA110", "v0.3305", 0x55, 0x58, {0xaf, 0xaf, 0x00} },
+	{"Acer", "AOA110", "v0.3307", 0x55, 0x58, {0xaf, 0xaf, 0x00} },
+	{"Acer", "AOA110", "v0.3308", 0x55, 0x58, {0x21, 0x21, 0x00} },
+	{"Acer", "AOA110", "v0.3309", 0x55, 0x58, {0x21, 0x21, 0x00} },
+	{"Acer", "AOA110", "v0.3310", 0x55, 0x58, {0x21, 0x21, 0x00} },
 	/* AOA150 */
-	{"Acer", "AOA150", "v0.3114", 0x55, 0x58, {0x20, 0x00} },
-	{"Acer", "AOA150", "v0.3301", 0x55, 0x58, {0x20, 0x00} },
-	{"Acer", "AOA150", "v0.3304", 0x55, 0x58, {0x20, 0x00} },
-	{"Acer", "AOA150", "v0.3305", 0x55, 0x58, {0x20, 0x00} },
-	{"Acer", "AOA150", "v0.3307", 0x55, 0x58, {0x20, 0x00} },
-	{"Acer", "AOA150", "v0.3308", 0x55, 0x58, {0x20, 0x00} },
-	{"Acer", "AOA150", "v0.3309", 0x55, 0x58, {0x20, 0x00} },
-	{"Acer", "AOA150", "v0.3310", 0x55, 0x58, {0x20, 0x00} },
+	{"Acer", "AOA150", "v0.3114", 0x55, 0x58, {0x20, 0x20, 0x00} },
+	{"Acer", "AOA150", "v0.3301", 0x55, 0x58, {0x20, 0x20, 0x00} },
+	{"Acer", "AOA150", "v0.3304", 0x55, 0x58, {0x20, 0x20, 0x00} },
+	{"Acer", "AOA150", "v0.3305", 0x55, 0x58, {0x20, 0x20, 0x00} },
+	{"Acer", "AOA150", "v0.3307", 0x55, 0x58, {0x20, 0x20, 0x00} },
+	{"Acer", "AOA150", "v0.3308", 0x55, 0x58, {0x20, 0x20, 0x00} },
+	{"Acer", "AOA150", "v0.3309", 0x55, 0x58, {0x20, 0x20, 0x00} },
+	{"Acer", "AOA150", "v0.3310", 0x55, 0x58, {0x20, 0x20, 0x00} },
+	/* Acer 1410 */
+	{"Acer", "Aspire 1410", "v0.3120", 0x55, 0x58, {0x9e, 0x9e, 0x00} },
 	/* special BIOS / other */
-	{"Gateway", "AOA110", "v0.3103", 0x55, 0x58, {0x21, 0x00} },
-	{"Gateway", "AOA150", "v0.3103", 0x55, 0x58, {0x20, 0x00} },
-	{"Packard Bell", "DOA150", "v0.3104", 0x55, 0x58, {0x21, 0x00} },
-	{"Packard Bell", "AOA110", "v0.3105", 0x55, 0x58, {0x21, 0x00} },
-	{"Packard Bell", "AOA150", "v0.3105", 0x55, 0x58, {0x20, 0x00} },
+	{"Gateway", "AOA110", "v0.3103", 0x55, 0x58, {0x21, 0x21, 0x00} },
+	{"Gateway", "AOA150", "v0.3103", 0x55, 0x58, {0x20, 0x20, 0x00} },
+	{"Gateway         ", "LT31            ", "v1.3103 ", 0x55, 0x58,
+		{0x10, 0x0f, 0x00} },
+	{"Gateway         ", "LT31            ", "v1.3201 ", 0x55, 0x58,
+		{0x10, 0x0f, 0x00} },
+	{"Gateway         ", "LT31            ", "v1.3302 ", 0x55, 0x58,
+		{0x10, 0x0f, 0x00} },
+	{"Packard Bell", "DOA150", "v0.3104", 0x55, 0x58, {0x21, 0x21, 0x00} },
+	{"Packard Bell", "DOA150", "v0.3105", 0x55, 0x58, {0x20, 0x20, 0x00} },
+	{"Packard Bell", "AOA110", "v0.3105", 0x55, 0x58, {0x21, 0x21, 0x00} },
+	{"Packard Bell", "AOA150", "v0.3105", 0x55, 0x58, {0x20, 0x20, 0x00} },
 	/* pewpew-terminator */
-	{"", "", "", 0, 0, {0, 0} }
+	{"", "", "", 0, 0, {0, 0, 0} }
 };
 
 static const struct bios_settings_t *bios_cfg __read_mostly;
@@ -183,7 +194,7 @@
 	if (ec_read(bios_cfg->fanreg, &fan))
 		return -EINVAL;
 
-	if (fan != bios_cfg->cmd.cmd_off)
+	if (fan != bios_cfg->cmd.chk_off)
 		*state = ACERHDF_FAN_AUTO;
 	else
 		*state = ACERHDF_FAN_OFF;
@@ -629,9 +640,10 @@
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Peter Feuerer");
 MODULE_DESCRIPTION("Aspire One temperature and fan driver");
-MODULE_ALIAS("dmi:*:*Acer*:*:");
-MODULE_ALIAS("dmi:*:*Gateway*:*:");
-MODULE_ALIAS("dmi:*:*Packard Bell*:*:");
+MODULE_ALIAS("dmi:*:*Acer*:pnAOA*:");
+MODULE_ALIAS("dmi:*:*Gateway*:pnAOA*:");
+MODULE_ALIAS("dmi:*:*Packard Bell*:pnAOA*:");
+MODULE_ALIAS("dmi:*:*Packard Bell*:pnDOA*:");
 
 module_init(acerhdf_init);
 module_exit(acerhdf_exit);
diff -Nur linux-2.6.32-orig/drivers/platform/x86/asus-laptop.c iDroid-Project-kernel_common-9e90fd2/drivers/platform/x86/asus-laptop.c
--- linux-2.6.32-orig/drivers/platform/x86/asus-laptop.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/platform/x86/asus-laptop.c	2010-11-18 21:05:30.000000000 +0600
@@ -221,6 +221,7 @@
  */
 static const struct acpi_device_id asus_device_ids[] = {
 	{"ATK0100", 0},
+	{"ATK0101", 0},
 	{"", 0},
 };
 MODULE_DEVICE_TABLE(acpi, asus_device_ids);
@@ -293,6 +294,11 @@
 enum { KE_KEY, KE_END };
 
 static struct key_entry asus_keymap[] = {
+	{KE_KEY, 0x02, KEY_SCREENLOCK},
+	{KE_KEY, 0x05, KEY_WLAN},
+	{KE_KEY, 0x08, BTN_TOUCH},
+	{KE_KEY, 0x17, KEY_ZOOM},
+	{KE_KEY, 0x1f, KEY_BATTERY},
 	{KE_KEY, 0x30, KEY_VOLUMEUP},
 	{KE_KEY, 0x31, KEY_VOLUMEDOWN},
 	{KE_KEY, 0x32, KEY_MUTE},
@@ -312,6 +318,8 @@
 	{KE_KEY, 0x5F, KEY_WLAN},
 	{KE_KEY, 0x60, KEY_SWITCHVIDEOMODE},
 	{KE_KEY, 0x61, KEY_SWITCHVIDEOMODE},
+	{KE_KEY, 0x62, KEY_SWITCHVIDEOMODE},
+	{KE_KEY, 0x63, KEY_SWITCHVIDEOMODE},
 	{KE_KEY, 0x6B, BTN_TOUCH}, /* Lock Mouse */
 	{KE_KEY, 0x82, KEY_CAMERA},
 	{KE_KEY, 0x8A, KEY_PROG1},
@@ -1283,8 +1291,8 @@
 	hotk->ledd_status = 0xFFF;
 
 	/* Set initial values of light sensor and level */
-	hotk->light_switch = 1;	/* Default to light sensor disabled */
-	hotk->light_level = 0;	/* level 5 for sensor sensitivity */
+	hotk->light_switch = 0;	/* Default to light sensor disabled */
+	hotk->light_level = 5;	/* level 5 for sensor sensitivity */
 
 	if (ls_switch_handle)
 		set_light_sens_switch(hotk->light_switch);
diff -Nur linux-2.6.32-orig/drivers/platform/x86/dell-wmi.c iDroid-Project-kernel_common-9e90fd2/drivers/platform/x86/dell-wmi.c
--- linux-2.6.32-orig/drivers/platform/x86/dell-wmi.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/platform/x86/dell-wmi.c	2010-11-18 21:05:30.000000000 +0600
@@ -158,8 +158,13 @@
 	struct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };
 	static struct key_entry *key;
 	union acpi_object *obj;
+	acpi_status status;
 
-	wmi_get_event_data(value, &response);
+	status = wmi_get_event_data(value, &response);
+	if (status != AE_OK) {
+		printk(KERN_INFO "dell-wmi: bad event status 0x%x\n", status);
+		return;
+	}
 
 	obj = (union acpi_object *)response.pointer;
 
@@ -180,6 +185,7 @@
 			printk(KERN_INFO "dell-wmi: Unknown key %x pressed\n",
 			       buffer[1] & 0xFFFF);
 	}
+	kfree(obj);
 }
 
 static int __init dell_wmi_input_setup(void)
diff -Nur linux-2.6.32-orig/drivers/platform/x86/hp-wmi.c iDroid-Project-kernel_common-9e90fd2/drivers/platform/x86/hp-wmi.c
--- linux-2.6.32-orig/drivers/platform/x86/hp-wmi.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/platform/x86/hp-wmi.c	2010-11-18 21:05:30.000000000 +0600
@@ -334,8 +334,13 @@
 	struct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };
 	static struct key_entry *key;
 	union acpi_object *obj;
+	acpi_status status;
 
-	wmi_get_event_data(value, &response);
+	status = wmi_get_event_data(value, &response);
+	if (status != AE_OK) {
+		printk(KERN_INFO "hp-wmi: bad event status 0x%x\n", status);
+		return;
+	}
 
 	obj = (union acpi_object *)response.pointer;
 
@@ -377,6 +382,8 @@
 			       eventcode);
 	} else
 		printk(KERN_INFO "HP WMI: Unknown response received\n");
+
+	kfree(obj);
 }
 
 static int __init hp_wmi_input_setup(void)
diff -Nur linux-2.6.32-orig/drivers/platform/x86/thinkpad_acpi.c iDroid-Project-kernel_common-9e90fd2/drivers/platform/x86/thinkpad_acpi.c
--- linux-2.6.32-orig/drivers/platform/x86/thinkpad_acpi.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/platform/x86/thinkpad_acpi.c	2010-11-18 21:05:30.000000000 +0600
@@ -3866,15 +3866,6 @@
 
 #define TPACPI_RFK_BLUETOOTH_SW_NAME	"tpacpi_bluetooth_sw"
 
-static void bluetooth_suspend(pm_message_t state)
-{
-	/* Try to make sure radio will resume powered off */
-	if (!acpi_evalf(NULL, NULL, "\\BLTH", "vd",
-		   TP_ACPI_BLTH_PWR_OFF_ON_RESUME))
-		vdbg_printk(TPACPI_DBG_RFKILL,
-			"bluetooth power down on resume request failed\n");
-}
-
 static int bluetooth_get_status(void)
 {
 	int status;
@@ -3908,10 +3899,9 @@
 #endif
 
 	/* We make sure to keep TP_ACPI_BLUETOOTH_RESUMECTRL off */
+	status = TP_ACPI_BLUETOOTH_RESUMECTRL;
 	if (state == TPACPI_RFK_RADIO_ON)
-		status = TP_ACPI_BLUETOOTH_RADIOSSW;
-	else
-		status = 0;
+		status |= TP_ACPI_BLUETOOTH_RADIOSSW;
 
 	if (!acpi_evalf(hkey_handle, NULL, "SBDC", "vd", status))
 		return -EIO;
@@ -4050,7 +4040,6 @@
 	.read = bluetooth_read,
 	.write = bluetooth_write,
 	.exit = bluetooth_exit,
-	.suspend = bluetooth_suspend,
 	.shutdown = bluetooth_shutdown,
 };
 
@@ -4068,15 +4057,6 @@
 
 #define TPACPI_RFK_WWAN_SW_NAME		"tpacpi_wwan_sw"
 
-static void wan_suspend(pm_message_t state)
-{
-	/* Try to make sure radio will resume powered off */
-	if (!acpi_evalf(NULL, NULL, "\\WGSV", "qvd",
-		   TP_ACPI_WGSV_PWR_OFF_ON_RESUME))
-		vdbg_printk(TPACPI_DBG_RFKILL,
-			"WWAN power down on resume request failed\n");
-}
-
 static int wan_get_status(void)
 {
 	int status;
@@ -4109,11 +4089,10 @@
 	}
 #endif
 
-	/* We make sure to keep TP_ACPI_WANCARD_RESUMECTRL off */
+	/* We make sure to set TP_ACPI_WANCARD_RESUMECTRL */
+	status = TP_ACPI_WANCARD_RESUMECTRL;
 	if (state == TPACPI_RFK_RADIO_ON)
-		status = TP_ACPI_WANCARD_RADIOSSW;
-	else
-		status = 0;
+		status |= TP_ACPI_WANCARD_RADIOSSW;
 
 	if (!acpi_evalf(hkey_handle, NULL, "SWAN", "vd", status))
 		return -EIO;
@@ -4251,7 +4230,6 @@
 	.read = wan_read,
 	.write = wan_write,
 	.exit = wan_exit,
-	.suspend = wan_suspend,
 	.shutdown = wan_shutdown,
 };
 
@@ -6123,8 +6101,8 @@
 
 	/* Models with Intel Extreme Graphics 2 */
 	TPACPI_Q_IBM('1', 'U', TPACPI_BRGHT_Q_NOEC),
-	TPACPI_Q_IBM('1', 'V', TPACPI_BRGHT_Q_ASK|TPACPI_BRGHT_Q_NOEC),
-	TPACPI_Q_IBM('1', 'W', TPACPI_BRGHT_Q_ASK|TPACPI_BRGHT_Q_NOEC),
+	TPACPI_Q_IBM('1', 'V', TPACPI_BRGHT_Q_ASK|TPACPI_BRGHT_Q_EC),
+	TPACPI_Q_IBM('1', 'W', TPACPI_BRGHT_Q_ASK|TPACPI_BRGHT_Q_EC),
 
 	/* Models with Intel GMA900 */
 	TPACPI_Q_IBM('7', '0', TPACPI_BRGHT_Q_NOEC),	/* T43, R52 */
diff -Nur linux-2.6.32-orig/drivers/platform/x86/wmi.c iDroid-Project-kernel_common-9e90fd2/drivers/platform/x86/wmi.c
--- linux-2.6.32-orig/drivers/platform/x86/wmi.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/platform/x86/wmi.c	2010-11-18 21:05:30.000000000 +0600
@@ -510,8 +510,8 @@
 /**
  * wmi_get_event_data - Get WMI data associated with an event
  *
- * @event - Event to find
- * &out - Buffer to hold event data
+ * @event: Event to find
+ * @out: Buffer to hold event data. out->pointer should be freed with kfree()
  *
  * Returns extra data associated with an event in WMI.
  */
diff -Nur linux-2.6.32-orig/drivers/power/power_supply_core.c iDroid-Project-kernel_common-9e90fd2/drivers/power/power_supply_core.c
--- linux-2.6.32-orig/drivers/power/power_supply_core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/power/power_supply_core.c	2010-11-18 21:05:30.000000000 +0600
@@ -38,23 +38,40 @@
 
 static void power_supply_changed_work(struct work_struct *work)
 {
+	unsigned long flags;
 	struct power_supply *psy = container_of(work, struct power_supply,
 						changed_work);
 
 	dev_dbg(psy->dev, "%s\n", __func__);
 
-	class_for_each_device(power_supply_class, NULL, psy,
-			      __power_supply_changed_work);
+	spin_lock_irqsave(&psy->changed_lock, flags);
+	if (psy->changed) {
+		psy->changed = false;
+		spin_unlock_irqrestore(&psy->changed_lock, flags);
 
-	power_supply_update_leds(psy);
+		class_for_each_device(power_supply_class, NULL, psy,
+				      __power_supply_changed_work);
 
-	kobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);
+		power_supply_update_leds(psy);
+
+		kobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);
+		spin_lock_irqsave(&psy->changed_lock, flags);
+	}
+	if (!psy->changed)
+		wake_unlock(&psy->work_wake_lock);
+	spin_unlock_irqrestore(&psy->changed_lock, flags);
 }
 
 void power_supply_changed(struct power_supply *psy)
 {
+	unsigned long flags;
+
 	dev_dbg(psy->dev, "%s\n", __func__);
 
+	spin_lock_irqsave(&psy->changed_lock, flags);
+	psy->changed = true;
+	wake_lock(&psy->work_wake_lock);
+	spin_unlock_irqrestore(&psy->changed_lock, flags);
 	schedule_work(&psy->changed_work);
 }
 EXPORT_SYMBOL_GPL(power_supply_changed);
@@ -156,6 +173,8 @@
 	}
 
 	INIT_WORK(&psy->changed_work, power_supply_changed_work);
+	spin_lock_init(&psy->changed_lock);
+	wake_lock_init(&psy->work_wake_lock, WAKE_LOCK_SUSPEND, "power-supply");
 
 	rc = power_supply_create_attrs(psy);
 	if (rc)
@@ -172,6 +191,7 @@
 create_triggers_failed:
 	power_supply_remove_attrs(psy);
 create_attrs_failed:
+	wake_lock_destroy(&psy->work_wake_lock);
 	device_unregister(psy->dev);
 dev_create_failed:
 success:
@@ -184,6 +204,7 @@
 	flush_scheduled_work();
 	power_supply_remove_triggers(psy);
 	power_supply_remove_attrs(psy);
+	wake_lock_destroy(&psy->work_wake_lock);
 	device_unregister(psy->dev);
 }
 EXPORT_SYMBOL_GPL(power_supply_unregister);
diff -Nur linux-2.6.32-orig/drivers/regulator/core.c iDroid-Project-kernel_common-9e90fd2/drivers/regulator/core.c
--- linux-2.6.32-orig/drivers/regulator/core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/regulator/core.c	2010-11-18 21:05:30.000000000 +0600
@@ -640,7 +640,7 @@
 static void print_constraints(struct regulator_dev *rdev)
 {
 	struct regulation_constraints *constraints = rdev->constraints;
-	char buf[80];
+	char buf[80] = "";
 	int count;
 
 	if (rdev->desc->type == REGULATOR_VOLTAGE) {
diff -Nur linux-2.6.32-orig/drivers/regulator/wm8350-regulator.c iDroid-Project-kernel_common-9e90fd2/drivers/regulator/wm8350-regulator.c
--- linux-2.6.32-orig/drivers/regulator/wm8350-regulator.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/regulator/wm8350-regulator.c	2010-11-18 21:05:30.000000000 +0600
@@ -1504,7 +1504,8 @@
 	led->isink_init.consumer_supplies = &led->isink_consumer;
 	led->isink_init.constraints.min_uA = 0;
 	led->isink_init.constraints.max_uA = pdata->max_uA;
-	led->isink_init.constraints.valid_ops_mask = REGULATOR_CHANGE_CURRENT;
+	led->isink_init.constraints.valid_ops_mask
+		= REGULATOR_CHANGE_CURRENT | REGULATOR_CHANGE_STATUS;
 	led->isink_init.constraints.valid_modes_mask = REGULATOR_MODE_NORMAL;
 	ret = wm8350_register_regulator(wm8350, isink, &led->isink_init);
 	if (ret != 0) {
@@ -1517,6 +1518,7 @@
 	led->dcdc_init.num_consumer_supplies = 1;
 	led->dcdc_init.consumer_supplies = &led->dcdc_consumer;
 	led->dcdc_init.constraints.valid_modes_mask = REGULATOR_MODE_NORMAL;
+	led->dcdc_init.constraints.valid_ops_mask =  REGULATOR_CHANGE_STATUS;
 	ret = wm8350_register_regulator(wm8350, dcdc, &led->dcdc_init);
 	if (ret != 0) {
 		platform_device_put(pdev);
diff -Nur linux-2.6.32-orig/drivers/rtc/alarm.c iDroid-Project-kernel_common-9e90fd2/drivers/rtc/alarm.c
--- linux-2.6.32-orig/drivers/rtc/alarm.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/rtc/alarm.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,586 @@
+/* drivers/rtc/alarm.c
+ *
+ * Copyright (C) 2007-2009 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/mach/time.h>
+#include <linux/android_alarm.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/sysdev.h>
+#include <linux/wakelock.h>
+
+#define ANDROID_ALARM_PRINT_ERROR (1U << 0)
+#define ANDROID_ALARM_PRINT_INIT_STATUS (1U << 1)
+#define ANDROID_ALARM_PRINT_TSET (1U << 2)
+#define ANDROID_ALARM_PRINT_CALL (1U << 3)
+#define ANDROID_ALARM_PRINT_SUSPEND (1U << 4)
+#define ANDROID_ALARM_PRINT_INT (1U << 5)
+#define ANDROID_ALARM_PRINT_FLOW (1U << 6)
+
+static int debug_mask = ANDROID_ALARM_PRINT_ERROR | \
+			ANDROID_ALARM_PRINT_INIT_STATUS;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+#define pr_alarm(debug_level_mask, args...) \
+	do { \
+		if (debug_mask & ANDROID_ALARM_PRINT_##debug_level_mask) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+#define ANDROID_ALARM_WAKEUP_MASK ( \
+	ANDROID_ALARM_RTC_WAKEUP_MASK | \
+	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK)
+
+/* support old usespace code */
+#define ANDROID_ALARM_SET_OLD               _IOW('a', 2, time_t) /* set alarm */
+#define ANDROID_ALARM_SET_AND_WAIT_OLD      _IOW('a', 3, time_t)
+
+struct alarm_queue {
+	struct rb_root alarms;
+	struct rb_node *first;
+	struct hrtimer timer;
+	ktime_t delta;
+	bool stopped;
+	ktime_t stopped_time;
+};
+
+static struct rtc_device *alarm_rtc_dev;
+static DEFINE_SPINLOCK(alarm_slock);
+static DEFINE_MUTEX(alarm_setrtc_mutex);
+static struct wake_lock alarm_rtc_wake_lock;
+static struct platform_device *alarm_platform_dev;
+struct alarm_queue alarms[ANDROID_ALARM_TYPE_COUNT];
+static bool suspended;
+
+static void update_timer_locked(struct alarm_queue *base, bool head_removed)
+{
+	struct alarm *alarm;
+	bool is_wakeup = base == &alarms[ANDROID_ALARM_RTC_WAKEUP] ||
+			base == &alarms[ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP];
+
+	if (base->stopped) {
+		pr_alarm(FLOW, "changed alarm while setting the wall time\n");
+		return;
+	}
+
+	if (is_wakeup && !suspended && head_removed)
+		wake_unlock(&alarm_rtc_wake_lock);
+
+	if (!base->first)
+		return;
+
+	alarm = container_of(base->first, struct alarm, node);
+
+	pr_alarm(FLOW, "selected alarm, type %d, func %pF at %lld\n",
+		alarm->type, alarm->function, ktime_to_ns(alarm->expires));
+
+	if (is_wakeup && suspended) {
+		pr_alarm(FLOW, "changed alarm while suspened\n");
+		wake_lock_timeout(&alarm_rtc_wake_lock, 1 * HZ);
+		return;
+	}
+
+	hrtimer_try_to_cancel(&base->timer);
+	base->timer._expires = ktime_add(base->delta, alarm->expires);
+	base->timer._softexpires = ktime_add(base->delta, alarm->softexpires);
+	hrtimer_start_expires(&base->timer, HRTIMER_MODE_ABS);
+}
+
+static void alarm_enqueue_locked(struct alarm *alarm)
+{
+	struct alarm_queue *base = &alarms[alarm->type];
+	struct rb_node **link = &base->alarms.rb_node;
+	struct rb_node *parent = NULL;
+	struct alarm *entry;
+	int leftmost = 1;
+
+	pr_alarm(FLOW, "added alarm, type %d, func %pF at %lld\n",
+		alarm->type, alarm->function, ktime_to_ns(alarm->expires));
+
+	if (base->first == &alarm->node)
+		base->first = rb_next(&alarm->node);
+	if (!RB_EMPTY_NODE(&alarm->node)) {
+		rb_erase(&alarm->node, &base->alarms);
+		RB_CLEAR_NODE(&alarm->node);
+	}
+
+	while (*link) {
+		parent = *link;
+		entry = rb_entry(parent, struct alarm, node);
+		/*
+		* We dont care about collisions. Nodes with
+		* the same expiry time stay together.
+		*/
+		if (alarm->expires.tv64 < entry->expires.tv64) {
+			link = &(*link)->rb_left;
+		} else {
+			link = &(*link)->rb_right;
+			leftmost = 0;
+		}
+	}
+	if (leftmost) {
+		base->first = &alarm->node;
+		update_timer_locked(base, false);
+	}
+
+	rb_link_node(&alarm->node, parent, link);
+	rb_insert_color(&alarm->node, &base->alarms);
+}
+
+/**
+ * alarm_init - initialize an alarm
+ * @alarm:	the alarm to be initialized
+ * @type:	the alarm type to be used
+ * @function:	alarm callback function
+ */
+void alarm_init(struct alarm *alarm,
+	enum android_alarm_type type, void (*function)(struct alarm *))
+{
+	RB_CLEAR_NODE(&alarm->node);
+	alarm->type = type;
+	alarm->function = function;
+
+	pr_alarm(FLOW, "created alarm, type %d, func %pF\n", type, function);
+}
+
+
+/**
+ * alarm_start_range - (re)start an alarm
+ * @alarm:	the alarm to be added
+ * @start:	earliest expiry time
+ * @end:	expiry time
+ */
+void alarm_start_range(struct alarm *alarm, ktime_t start, ktime_t end)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&alarm_slock, flags);
+	alarm->softexpires = start;
+	alarm->expires = end;
+	alarm_enqueue_locked(alarm);
+	spin_unlock_irqrestore(&alarm_slock, flags);
+}
+
+/**
+ * alarm_try_to_cancel - try to deactivate an alarm
+ * @alarm:	alarm to stop
+ *
+ * Returns:
+ *  0 when the alarm was not active
+ *  1 when the alarm was active
+ * -1 when the alarm may currently be excuting the callback function and
+ *    cannot be stopped (it may also be inactive)
+ */
+int alarm_try_to_cancel(struct alarm *alarm)
+{
+	struct alarm_queue *base = &alarms[alarm->type];
+	unsigned long flags;
+	bool first = false;
+	int ret = 0;
+
+	spin_lock_irqsave(&alarm_slock, flags);
+	if (!RB_EMPTY_NODE(&alarm->node)) {
+		pr_alarm(FLOW, "canceled alarm, type %d, func %pF at %lld\n",
+			alarm->type, alarm->function,
+			ktime_to_ns(alarm->expires));
+		ret = 1;
+		if (base->first == &alarm->node) {
+			base->first = rb_next(&alarm->node);
+			first = true;
+		}
+		rb_erase(&alarm->node, &base->alarms);
+		RB_CLEAR_NODE(&alarm->node);
+		if (first)
+			update_timer_locked(base, true);
+	} else
+		pr_alarm(FLOW, "tried to cancel alarm, type %d, func %pF\n",
+			alarm->type, alarm->function);
+	spin_unlock_irqrestore(&alarm_slock, flags);
+	if (!ret && hrtimer_callback_running(&base->timer))
+		ret = -1;
+	return ret;
+}
+
+/**
+ * alarm_cancel - cancel an alarm and wait for the handler to finish.
+ * @alarm:	the alarm to be cancelled
+ *
+ * Returns:
+ *  0 when the alarm was not active
+ *  1 when the alarm was active
+ */
+int alarm_cancel(struct alarm *alarm)
+{
+	for (;;) {
+		int ret = alarm_try_to_cancel(alarm);
+		if (ret >= 0)
+			return ret;
+		cpu_relax();
+	}
+}
+
+/**
+ * alarm_set_rtc - set the kernel and rtc walltime
+ * @new_time:	timespec value containing the new time
+ */
+int alarm_set_rtc(struct timespec new_time)
+{
+	int i;
+	int ret;
+	unsigned long flags;
+	struct rtc_time rtc_new_rtc_time;
+	struct timespec tmp_time;
+
+	rtc_time_to_tm(new_time.tv_sec, &rtc_new_rtc_time);
+
+	pr_alarm(TSET, "set rtc %ld %ld - rtc %02d:%02d:%02d %02d/%02d/%04d\n",
+		new_time.tv_sec, new_time.tv_nsec,
+		rtc_new_rtc_time.tm_hour, rtc_new_rtc_time.tm_min,
+		rtc_new_rtc_time.tm_sec, rtc_new_rtc_time.tm_mon + 1,
+		rtc_new_rtc_time.tm_mday,
+		rtc_new_rtc_time.tm_year + 1900);
+
+	mutex_lock(&alarm_setrtc_mutex);
+	spin_lock_irqsave(&alarm_slock, flags);
+	wake_lock(&alarm_rtc_wake_lock);
+	getnstimeofday(&tmp_time);
+	for (i = 0; i < ANDROID_ALARM_SYSTEMTIME; i++) {
+		hrtimer_try_to_cancel(&alarms[i].timer);
+		alarms[i].stopped = true;
+		alarms[i].stopped_time = timespec_to_ktime(tmp_time);
+	}
+	alarms[ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP].delta =
+		alarms[ANDROID_ALARM_ELAPSED_REALTIME].delta =
+		ktime_sub(alarms[ANDROID_ALARM_ELAPSED_REALTIME].delta,
+			timespec_to_ktime(timespec_sub(tmp_time, new_time)));
+	spin_unlock_irqrestore(&alarm_slock, flags);
+	ret = do_settimeofday(&new_time);
+	spin_lock_irqsave(&alarm_slock, flags);
+	for (i = 0; i < ANDROID_ALARM_SYSTEMTIME; i++) {
+		alarms[i].stopped = false;
+		update_timer_locked(&alarms[i], false);
+	}
+	spin_unlock_irqrestore(&alarm_slock, flags);
+	if (ret < 0) {
+		pr_alarm(ERROR, "alarm_set_rtc: Failed to set time\n");
+		goto err;
+	}
+	if (!alarm_rtc_dev) {
+		pr_alarm(ERROR,
+			"alarm_set_rtc: no RTC, time will be lost on reboot\n");
+		goto err;
+	}
+	ret = rtc_set_time(alarm_rtc_dev, &rtc_new_rtc_time);
+	if (ret < 0)
+		pr_alarm(ERROR, "alarm_set_rtc: "
+			"Failed to set RTC, time will be lost on reboot\n");
+err:
+	wake_unlock(&alarm_rtc_wake_lock);
+	mutex_unlock(&alarm_setrtc_mutex);
+	return ret;
+}
+
+/**
+ * alarm_get_elapsed_realtime - get the elapsed real time in ktime_t format
+ *
+ * returns the time in ktime_t format
+ */
+ktime_t alarm_get_elapsed_realtime(void)
+{
+	ktime_t now;
+	unsigned long flags;
+	struct alarm_queue *base = &alarms[ANDROID_ALARM_ELAPSED_REALTIME];
+
+	spin_lock_irqsave(&alarm_slock, flags);
+	now = base->stopped ? base->stopped_time : ktime_get_real();
+	now = ktime_sub(now, base->delta);
+	spin_unlock_irqrestore(&alarm_slock, flags);
+	return now;
+}
+
+static enum hrtimer_restart alarm_timer_triggered(struct hrtimer *timer)
+{
+	struct alarm_queue *base;
+	struct alarm *alarm;
+	unsigned long flags;
+	ktime_t now;
+
+	spin_lock_irqsave(&alarm_slock, flags);
+
+	base = container_of(timer, struct alarm_queue, timer);
+	now = base->stopped ? base->stopped_time : hrtimer_cb_get_time(timer);
+	now = ktime_sub(now, base->delta);
+
+	pr_alarm(INT, "alarm_timer_triggered type %d at %lld\n",
+		base - alarms, ktime_to_ns(now));
+
+	while (base->first) {
+		alarm = container_of(base->first, struct alarm, node);
+		if (alarm->softexpires.tv64 > now.tv64) {
+			pr_alarm(FLOW, "don't call alarm, %pF, %lld (s %lld)\n",
+				alarm->function, ktime_to_ns(alarm->expires),
+				ktime_to_ns(alarm->softexpires));
+			break;
+		}
+		base->first = rb_next(&alarm->node);
+		rb_erase(&alarm->node, &base->alarms);
+		RB_CLEAR_NODE(&alarm->node);
+		pr_alarm(CALL, "call alarm, type %d, func %pF, %lld (s %lld)\n",
+			alarm->type, alarm->function,
+			ktime_to_ns(alarm->expires),
+			ktime_to_ns(alarm->softexpires));
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		alarm->function(alarm);
+		spin_lock_irqsave(&alarm_slock, flags);
+	}
+	if (!base->first)
+		pr_alarm(FLOW, "no more alarms of type %d\n", base - alarms);
+	update_timer_locked(base, true);
+	spin_unlock_irqrestore(&alarm_slock, flags);
+	return HRTIMER_NORESTART;
+}
+
+static void alarm_triggered_func(void *p)
+{
+	struct rtc_device *rtc = alarm_rtc_dev;
+	if (!(rtc->irq_data & RTC_AF))
+		return;
+	pr_alarm(INT, "rtc alarm triggered\n");
+	wake_lock_timeout(&alarm_rtc_wake_lock, 1 * HZ);
+}
+
+static int alarm_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	int                 err = 0;
+	unsigned long       flags;
+	struct rtc_wkalrm   rtc_alarm;
+	struct rtc_time     rtc_current_rtc_time;
+	unsigned long       rtc_current_time;
+	unsigned long       rtc_alarm_time;
+	struct timespec     rtc_current_timespec;
+	struct timespec     rtc_delta;
+	struct alarm_queue *wakeup_queue = NULL;
+	struct alarm_queue *tmp_queue = NULL;
+
+	pr_alarm(SUSPEND, "alarm_suspend(%p, %d)\n", pdev, state.event);
+
+	spin_lock_irqsave(&alarm_slock, flags);
+	suspended = true;
+	spin_unlock_irqrestore(&alarm_slock, flags);
+
+	hrtimer_cancel(&alarms[ANDROID_ALARM_RTC_WAKEUP].timer);
+	hrtimer_cancel(&alarms[
+			ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK].timer);
+
+	tmp_queue = &alarms[ANDROID_ALARM_RTC_WAKEUP];
+	if (tmp_queue->first)
+		wakeup_queue = tmp_queue;
+	tmp_queue = &alarms[ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP];
+	if (tmp_queue->first && (!wakeup_queue ||
+				hrtimer_get_expires(&tmp_queue->timer).tv64 <
+				hrtimer_get_expires(&wakeup_queue->timer).tv64))
+		wakeup_queue = tmp_queue;
+	if (wakeup_queue) {
+		rtc_read_time(alarm_rtc_dev, &rtc_current_rtc_time);
+		rtc_current_timespec.tv_nsec = 0;
+		rtc_tm_to_time(&rtc_current_rtc_time,
+			       &rtc_current_timespec.tv_sec);
+		save_time_delta(&rtc_delta, &rtc_current_timespec);
+
+		rtc_alarm_time = timespec_sub(ktime_to_timespec(
+			hrtimer_get_expires(&wakeup_queue->timer)),
+			rtc_delta).tv_sec;
+
+		rtc_time_to_tm(rtc_alarm_time, &rtc_alarm.time);
+		rtc_alarm.enabled = 1;
+		rtc_set_alarm(alarm_rtc_dev, &rtc_alarm);
+		rtc_read_time(alarm_rtc_dev, &rtc_current_rtc_time);
+		rtc_tm_to_time(&rtc_current_rtc_time, &rtc_current_time);
+		pr_alarm(SUSPEND,
+			"rtc alarm set at %ld, now %ld, rtc delta %ld.%09ld\n",
+			rtc_alarm_time, rtc_current_time,
+			rtc_delta.tv_sec, rtc_delta.tv_nsec);
+		if (rtc_current_time + 1 >= rtc_alarm_time) {
+			pr_alarm(SUSPEND, "alarm about to go off\n");
+			memset(&rtc_alarm, 0, sizeof(rtc_alarm));
+			rtc_alarm.enabled = 0;
+			rtc_set_alarm(alarm_rtc_dev, &rtc_alarm);
+
+			spin_lock_irqsave(&alarm_slock, flags);
+			suspended = false;
+			wake_lock_timeout(&alarm_rtc_wake_lock, 2 * HZ);
+			update_timer_locked(&alarms[ANDROID_ALARM_RTC_WAKEUP],
+									false);
+			update_timer_locked(&alarms[
+				ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP], false);
+			err = -EBUSY;
+			spin_unlock_irqrestore(&alarm_slock, flags);
+		}
+	}
+	return err;
+}
+
+static int alarm_resume(struct platform_device *pdev)
+{
+	struct rtc_wkalrm alarm;
+	unsigned long       flags;
+
+	pr_alarm(SUSPEND, "alarm_resume(%p)\n", pdev);
+
+	memset(&alarm, 0, sizeof(alarm));
+	alarm.enabled = 0;
+	rtc_set_alarm(alarm_rtc_dev, &alarm);
+
+	spin_lock_irqsave(&alarm_slock, flags);
+	suspended = false;
+	update_timer_locked(&alarms[ANDROID_ALARM_RTC_WAKEUP], false);
+	update_timer_locked(&alarms[ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP],
+									false);
+	spin_unlock_irqrestore(&alarm_slock, flags);
+
+	return 0;
+}
+
+static struct rtc_task alarm_rtc_task = {
+	.func = alarm_triggered_func
+};
+
+static int rtc_alarm_add_device(struct device *dev,
+				struct class_interface *class_intf)
+{
+	int err;
+	struct rtc_device *rtc = to_rtc_device(dev);
+
+	mutex_lock(&alarm_setrtc_mutex);
+
+	if (alarm_rtc_dev) {
+		err = -EBUSY;
+		goto err1;
+	}
+
+	alarm_platform_dev =
+		platform_device_register_simple("alarm", -1, NULL, 0);
+	if (IS_ERR(alarm_platform_dev)) {
+		err = PTR_ERR(alarm_platform_dev);
+		goto err2;
+	}
+	err = rtc_irq_register(rtc, &alarm_rtc_task);
+	if (err)
+		goto err3;
+	alarm_rtc_dev = rtc;
+	pr_alarm(INIT_STATUS, "using rtc device, %s, for alarms", rtc->name);
+	mutex_unlock(&alarm_setrtc_mutex);
+
+	return 0;
+
+err3:
+	platform_device_unregister(alarm_platform_dev);
+err2:
+err1:
+	mutex_unlock(&alarm_setrtc_mutex);
+	return err;
+}
+
+static void rtc_alarm_remove_device(struct device *dev,
+				    struct class_interface *class_intf)
+{
+	if (dev == &alarm_rtc_dev->dev) {
+		pr_alarm(INIT_STATUS, "lost rtc device for alarms");
+		rtc_irq_unregister(alarm_rtc_dev, &alarm_rtc_task);
+		platform_device_unregister(alarm_platform_dev);
+		alarm_rtc_dev = NULL;
+	}
+}
+
+static struct class_interface rtc_alarm_interface = {
+	.add_dev = &rtc_alarm_add_device,
+	.remove_dev = &rtc_alarm_remove_device,
+};
+
+static struct platform_driver alarm_driver = {
+	.suspend = alarm_suspend,
+	.resume = alarm_resume,
+	.driver = {
+		.name = "alarm"
+	}
+};
+
+static int __init alarm_late_init(void)
+{
+	unsigned long   flags;
+	struct timespec tmp_time, system_time;
+
+	/* this needs to run after the rtc is read at boot */
+	spin_lock_irqsave(&alarm_slock, flags);
+	/* We read the current rtc and system time so we can later calulate
+	 * elasped realtime to be (boot_systemtime + rtc - boot_rtc) ==
+	 * (rtc - (boot_rtc - boot_systemtime))
+	 */
+	getnstimeofday(&tmp_time);
+	ktime_get_ts(&system_time);
+	alarms[ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP].delta =
+		alarms[ANDROID_ALARM_ELAPSED_REALTIME].delta =
+			timespec_to_ktime(timespec_sub(tmp_time, system_time));
+
+	spin_unlock_irqrestore(&alarm_slock, flags);
+	return 0;
+}
+
+static int __init alarm_driver_init(void)
+{
+	int err;
+	int i;
+
+	for (i = 0; i < ANDROID_ALARM_SYSTEMTIME; i++) {
+		hrtimer_init(&alarms[i].timer,
+				CLOCK_REALTIME, HRTIMER_MODE_ABS);
+		alarms[i].timer.function = alarm_timer_triggered;
+	}
+	hrtimer_init(&alarms[ANDROID_ALARM_SYSTEMTIME].timer,
+		     CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
+	alarms[ANDROID_ALARM_SYSTEMTIME].timer.function = alarm_timer_triggered;
+	err = platform_driver_register(&alarm_driver);
+	if (err < 0)
+		goto err1;
+	wake_lock_init(&alarm_rtc_wake_lock, WAKE_LOCK_SUSPEND, "alarm_rtc");
+	rtc_alarm_interface.class = rtc_class;
+	err = class_interface_register(&rtc_alarm_interface);
+	if (err < 0)
+		goto err2;
+
+	return 0;
+
+err2:
+	wake_lock_destroy(&alarm_rtc_wake_lock);
+	platform_driver_unregister(&alarm_driver);
+err1:
+	return err;
+}
+
+static void  __exit alarm_exit(void)
+{
+	class_interface_unregister(&rtc_alarm_interface);
+	wake_lock_destroy(&alarm_rtc_wake_lock);
+	platform_driver_unregister(&alarm_driver);
+}
+
+late_initcall(alarm_late_init);
+module_init(alarm_driver_init);
+module_exit(alarm_exit);
+
diff -Nur linux-2.6.32-orig/drivers/rtc/alarm-dev.c iDroid-Project-kernel_common-9e90fd2/drivers/rtc/alarm-dev.c
--- linux-2.6.32-orig/drivers/rtc/alarm-dev.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/rtc/alarm-dev.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,286 @@
+/* drivers/rtc/alarm-dev.c
+ *
+ * Copyright (C) 2007-2009 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/mach/time.h>
+#include <linux/android_alarm.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/sysdev.h>
+#include <linux/uaccess.h>
+#include <linux/wakelock.h>
+
+#define ANDROID_ALARM_PRINT_INFO (1U << 0)
+#define ANDROID_ALARM_PRINT_IO (1U << 1)
+#define ANDROID_ALARM_PRINT_INT (1U << 2)
+
+static int debug_mask = ANDROID_ALARM_PRINT_INFO;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+#define pr_alarm(debug_level_mask, args...) \
+	do { \
+		if (debug_mask & ANDROID_ALARM_PRINT_##debug_level_mask) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+#define ANDROID_ALARM_WAKEUP_MASK ( \
+	ANDROID_ALARM_RTC_WAKEUP_MASK | \
+	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK)
+
+/* support old usespace code */
+#define ANDROID_ALARM_SET_OLD               _IOW('a', 2, time_t) /* set alarm */
+#define ANDROID_ALARM_SET_AND_WAIT_OLD      _IOW('a', 3, time_t)
+
+static int alarm_opened;
+static DEFINE_SPINLOCK(alarm_slock);
+static struct wake_lock alarm_wake_lock;
+static DECLARE_WAIT_QUEUE_HEAD(alarm_wait_queue);
+static uint32_t alarm_pending;
+static uint32_t alarm_enabled;
+static uint32_t wait_pending;
+
+static struct alarm alarms[ANDROID_ALARM_TYPE_COUNT];
+
+static long alarm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int rv = 0;
+	unsigned long flags;
+	struct timespec new_alarm_time;
+	struct timespec new_rtc_time;
+	struct timespec tmp_time;
+	enum android_alarm_type alarm_type = ANDROID_ALARM_IOCTL_TO_TYPE(cmd);
+	uint32_t alarm_type_mask = 1U << alarm_type;
+
+	if (alarm_type >= ANDROID_ALARM_TYPE_COUNT)
+		return -EINVAL;
+
+	if (ANDROID_ALARM_BASE_CMD(cmd) != ANDROID_ALARM_GET_TIME(0)) {
+		if ((file->f_flags & O_ACCMODE) == O_RDONLY)
+			return -EPERM;
+		if (file->private_data == NULL &&
+		    cmd != ANDROID_ALARM_SET_RTC) {
+			spin_lock_irqsave(&alarm_slock, flags);
+			if (alarm_opened) {
+				spin_unlock_irqrestore(&alarm_slock, flags);
+				return -EBUSY;
+			}
+			alarm_opened = 1;
+			file->private_data = (void *)1;
+			spin_unlock_irqrestore(&alarm_slock, flags);
+		}
+	}
+
+	switch (ANDROID_ALARM_BASE_CMD(cmd)) {
+	case ANDROID_ALARM_CLEAR(0):
+		spin_lock_irqsave(&alarm_slock, flags);
+		pr_alarm(IO, "alarm %d clear\n", alarm_type);
+		alarm_try_to_cancel(&alarms[alarm_type]);
+		if (alarm_pending) {
+			alarm_pending &= ~alarm_type_mask;
+			if (!alarm_pending && !wait_pending)
+				wake_unlock(&alarm_wake_lock);
+		}
+		alarm_enabled &= ~alarm_type_mask;
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		break;
+
+	case ANDROID_ALARM_SET_OLD:
+	case ANDROID_ALARM_SET_AND_WAIT_OLD:
+		if (get_user(new_alarm_time.tv_sec, (int __user *)arg)) {
+			rv = -EFAULT;
+			goto err1;
+		}
+		new_alarm_time.tv_nsec = 0;
+		goto from_old_alarm_set;
+
+	case ANDROID_ALARM_SET_AND_WAIT(0):
+	case ANDROID_ALARM_SET(0):
+		if (copy_from_user(&new_alarm_time, (void __user *)arg,
+		    sizeof(new_alarm_time))) {
+			rv = -EFAULT;
+			goto err1;
+		}
+from_old_alarm_set:
+		spin_lock_irqsave(&alarm_slock, flags);
+		pr_alarm(IO, "alarm %d set %ld.%09ld\n", alarm_type,
+			new_alarm_time.tv_sec, new_alarm_time.tv_nsec);
+		alarm_enabled |= alarm_type_mask;
+		alarm_start_range(&alarms[alarm_type],
+			timespec_to_ktime(new_alarm_time),
+			timespec_to_ktime(new_alarm_time));
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		if (ANDROID_ALARM_BASE_CMD(cmd) != ANDROID_ALARM_SET_AND_WAIT(0)
+		    && cmd != ANDROID_ALARM_SET_AND_WAIT_OLD)
+			break;
+		/* fall though */
+	case ANDROID_ALARM_WAIT:
+		spin_lock_irqsave(&alarm_slock, flags);
+		pr_alarm(IO, "alarm wait\n");
+		if (!alarm_pending && wait_pending) {
+			wake_unlock(&alarm_wake_lock);
+			wait_pending = 0;
+		}
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		rv = wait_event_interruptible(alarm_wait_queue, alarm_pending);
+		if (rv)
+			goto err1;
+		spin_lock_irqsave(&alarm_slock, flags);
+		rv = alarm_pending;
+		wait_pending = 1;
+		alarm_pending = 0;
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		break;
+	case ANDROID_ALARM_SET_RTC:
+		if (copy_from_user(&new_rtc_time, (void __user *)arg,
+		    sizeof(new_rtc_time))) {
+			rv = -EFAULT;
+			goto err1;
+		}
+		rv = alarm_set_rtc(new_rtc_time);
+		spin_lock_irqsave(&alarm_slock, flags);
+		alarm_pending |= ANDROID_ALARM_TIME_CHANGE_MASK;
+		wake_up(&alarm_wait_queue);
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		if (rv < 0)
+			goto err1;
+		break;
+	case ANDROID_ALARM_GET_TIME(0):
+		switch (alarm_type) {
+		case ANDROID_ALARM_RTC_WAKEUP:
+		case ANDROID_ALARM_RTC:
+			getnstimeofday(&tmp_time);
+			break;
+		case ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP:
+		case ANDROID_ALARM_ELAPSED_REALTIME:
+			tmp_time =
+				ktime_to_timespec(alarm_get_elapsed_realtime());
+			break;
+		case ANDROID_ALARM_TYPE_COUNT:
+		case ANDROID_ALARM_SYSTEMTIME:
+			ktime_get_ts(&tmp_time);
+			break;
+		}
+		if (copy_to_user((void __user *)arg, &tmp_time,
+		    sizeof(tmp_time))) {
+			rv = -EFAULT;
+			goto err1;
+		}
+		break;
+
+	default:
+		rv = -EINVAL;
+		goto err1;
+	}
+err1:
+	return rv;
+}
+
+static int alarm_open(struct inode *inode, struct file *file)
+{
+	file->private_data = NULL;
+	return 0;
+}
+
+static int alarm_release(struct inode *inode, struct file *file)
+{
+	int i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&alarm_slock, flags);
+	if (file->private_data != 0) {
+		for (i = 0; i < ANDROID_ALARM_TYPE_COUNT; i++) {
+			uint32_t alarm_type_mask = 1U << i;
+			if (alarm_enabled & alarm_type_mask) {
+				pr_alarm(INFO, "alarm_release: clear alarm, "
+					"pending %d\n",
+					!!(alarm_pending & alarm_type_mask));
+				alarm_enabled &= ~alarm_type_mask;
+			}
+			spin_unlock_irqrestore(&alarm_slock, flags);
+			alarm_cancel(&alarms[i]);
+			spin_lock_irqsave(&alarm_slock, flags);
+		}
+		if (alarm_pending | wait_pending) {
+			if (alarm_pending)
+				pr_alarm(INFO, "alarm_release: clear "
+					"pending alarms %x\n", alarm_pending);
+			wake_unlock(&alarm_wake_lock);
+			wait_pending = 0;
+			alarm_pending = 0;
+		}
+		alarm_opened = 0;
+	}
+	spin_unlock_irqrestore(&alarm_slock, flags);
+	return 0;
+}
+
+static void alarm_triggered(struct alarm *alarm)
+{
+	unsigned long flags;
+	uint32_t alarm_type_mask = 1U << alarm->type;
+
+	pr_alarm(INT, "alarm_triggered type %d\n", alarm->type);
+	spin_lock_irqsave(&alarm_slock, flags);
+	if (alarm_enabled & alarm_type_mask) {
+		wake_lock_timeout(&alarm_wake_lock, 5 * HZ);
+		alarm_enabled &= ~alarm_type_mask;
+		alarm_pending |= alarm_type_mask;
+		wake_up(&alarm_wait_queue);
+	}
+	spin_unlock_irqrestore(&alarm_slock, flags);
+}
+
+static const struct file_operations alarm_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = alarm_ioctl,
+	.open = alarm_open,
+	.release = alarm_release,
+};
+
+static struct miscdevice alarm_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "alarm",
+	.fops = &alarm_fops,
+};
+
+static int __init alarm_dev_init(void)
+{
+	int err;
+	int i;
+
+	err = misc_register(&alarm_device);
+	if (err)
+		return err;
+
+	for (i = 0; i < ANDROID_ALARM_TYPE_COUNT; i++)
+		alarm_init(&alarms[i], i, alarm_triggered);
+	wake_lock_init(&alarm_wake_lock, WAKE_LOCK_SUSPEND, "alarm");
+
+	return 0;
+}
+
+static void  __exit alarm_dev_exit(void)
+{
+	misc_deregister(&alarm_device);
+	wake_lock_destroy(&alarm_wake_lock);
+}
+
+module_init(alarm_dev_init);
+module_exit(alarm_dev_exit);
+
diff -Nur linux-2.6.32-orig/drivers/rtc/class.c iDroid-Project-kernel_common-9e90fd2/drivers/rtc/class.c
--- linux-2.6.32-orig/drivers/rtc/class.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/rtc/class.c	2010-11-18 21:05:30.000000000 +0600
@@ -40,25 +40,32 @@
  */
 
 static struct timespec	delta;
+static struct timespec	delta_delta;
 static time_t		oldtime;
 
 static int rtc_suspend(struct device *dev, pm_message_t mesg)
 {
 	struct rtc_device	*rtc = to_rtc_device(dev);
 	struct rtc_time		tm;
-	struct timespec		ts = current_kernel_time();
+	struct timespec		ts;
+	struct timespec		new_delta;
 
 	if (strcmp(dev_name(&rtc->dev), CONFIG_RTC_HCTOSYS_DEVICE) != 0)
 		return 0;
 
+	getnstimeofday(&ts);
 	rtc_read_time(rtc, &tm);
 	rtc_tm_to_time(&tm, &oldtime);
 
 	/* RTC precision is 1 second; adjust delta for avg 1/2 sec err */
-	set_normalized_timespec(&delta,
+	set_normalized_timespec(&new_delta,
 				ts.tv_sec - oldtime,
 				ts.tv_nsec - (NSEC_PER_SEC >> 1));
 
+	/* prevent 1/2 sec errors from accumulating */
+	delta_delta = timespec_sub(new_delta, delta);
+	if (delta_delta.tv_sec < -2 || delta_delta.tv_sec >= 2)
+		delta = new_delta;
 	return 0;
 }
 
@@ -78,6 +85,8 @@
 		return 0;
 	}
 	rtc_tm_to_time(&tm, &newtime);
+	if (delta_delta.tv_sec < -1)
+		newtime++;
 	if (newtime <= oldtime) {
 		if (newtime < oldtime)
 			pr_debug("%s:  time travel!\n", dev_name(&rtc->dev));
diff -Nur linux-2.6.32-orig/drivers/rtc/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/rtc/Kconfig
--- linux-2.6.32-orig/drivers/rtc/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/rtc/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -109,6 +109,24 @@
 	  clock several times per second, please enable this option
 	  only if you know that you really need it.
 
+config RTC_INTF_ALARM
+	bool "Android alarm driver"
+	depends on RTC_CLASS
+	default y
+	help
+	  Provides non-wakeup and rtc backed wakeup alarms based on rtc or
+	  elapsed realtime, and a non-wakeup alarm on the monotonic clock.
+	  Also provides an interface to set the wall time which must be used
+	  for elapsed realtime to work.
+
+config RTC_INTF_ALARM_DEV
+	bool "Android alarm device"
+	depends on RTC_INTF_ALARM
+	default y
+	help
+	  Exports the alarm interface to user-space.
+
+
 config RTC_DRV_TEST
 	tristate "Test driver/device"
 	help
@@ -565,6 +583,13 @@
 	  If you say yes here you get support for the RTC subsystem of the
 	  NXP PCF50633 used in embedded systems.
 
+config RTC_DRV_PCF50633_OFFSET
+	depends on MFD_PCF50633
+	bool "Enable the offset register on PFC50633."
+	help
+		If you say yes here, the offset register will be used to calculate
+		the RTC time in addition to the time registers.
+
 config RTC_DRV_AB3100
 	tristate "ST-Ericsson AB3100 RTC"
 	depends on AB3100_CORE
diff -Nur linux-2.6.32-orig/drivers/rtc/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/rtc/Makefile
--- linux-2.6.32-orig/drivers/rtc/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/rtc/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -11,6 +11,8 @@
 obj-$(CONFIG_RTC_CLASS)		+= rtc-core.o
 rtc-core-y			:= class.o interface.o
 
+obj-$(CONFIG_RTC_INTF_ALARM) += alarm.o
+obj-$(CONFIG_RTC_INTF_ALARM_DEV) += alarm-dev.o
 rtc-core-$(CONFIG_RTC_INTF_DEV)	+= rtc-dev.o
 rtc-core-$(CONFIG_RTC_INTF_PROC) += rtc-proc.o
 rtc-core-$(CONFIG_RTC_INTF_SYSFS) += rtc-sysfs.o
diff -Nur linux-2.6.32-orig/drivers/rtc/rtc-cmos.c iDroid-Project-kernel_common-9e90fd2/drivers/rtc/rtc-cmos.c
--- linux-2.6.32-orig/drivers/rtc/rtc-cmos.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/rtc/rtc-cmos.c	2010-11-18 21:05:30.000000000 +0600
@@ -1099,9 +1099,9 @@
 #define	cmos_pnp_resume		NULL
 #endif
 
-static void cmos_pnp_shutdown(struct device *pdev)
+static void cmos_pnp_shutdown(struct pnp_dev *pnp)
 {
-	if (system_state == SYSTEM_POWER_OFF && !cmos_poweroff(pdev))
+	if (system_state == SYSTEM_POWER_OFF && !cmos_poweroff(&pnp->dev))
 		return;
 
 	cmos_do_shutdown();
@@ -1120,15 +1120,12 @@
 	.id_table	= rtc_ids,
 	.probe		= cmos_pnp_probe,
 	.remove		= __exit_p(cmos_pnp_remove),
+	.shutdown	= cmos_pnp_shutdown,
 
 	/* flag ensures resume() gets called, and stops syslog spam */
 	.flags		= PNP_DRIVER_RES_DO_NOT_CHANGE,
 	.suspend	= cmos_pnp_suspend,
 	.resume		= cmos_pnp_resume,
-	.driver		= {
-		.name	  = (char *)driver_name,
-		.shutdown = cmos_pnp_shutdown,
-	}
 };
 
 #endif	/* CONFIG_PNP */
diff -Nur linux-2.6.32-orig/drivers/rtc/rtc-fm3130.c iDroid-Project-kernel_common-9e90fd2/drivers/rtc/rtc-fm3130.c
--- linux-2.6.32-orig/drivers/rtc/rtc-fm3130.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/rtc/rtc-fm3130.c	2010-11-18 21:05:30.000000000 +0600
@@ -376,20 +376,22 @@
 	}
 
 	/* Disabling calibration mode */
-	if (fm3130->regs[FM3130_RTC_CONTROL] & FM3130_RTC_CONTROL_BIT_CAL)
+	if (fm3130->regs[FM3130_RTC_CONTROL] & FM3130_RTC_CONTROL_BIT_CAL) {
 		i2c_smbus_write_byte_data(client, FM3130_RTC_CONTROL,
 			fm3130->regs[FM3130_RTC_CONTROL] &
 				~(FM3130_RTC_CONTROL_BIT_CAL));
 		dev_warn(&client->dev, "Disabling calibration mode!\n");
+	}
 
 	/* Disabling read and write modes */
 	if (fm3130->regs[FM3130_RTC_CONTROL] & FM3130_RTC_CONTROL_BIT_WRITE ||
-	    fm3130->regs[FM3130_RTC_CONTROL] & FM3130_RTC_CONTROL_BIT_READ)
+	    fm3130->regs[FM3130_RTC_CONTROL] & FM3130_RTC_CONTROL_BIT_READ) {
 		i2c_smbus_write_byte_data(client, FM3130_RTC_CONTROL,
 			fm3130->regs[FM3130_RTC_CONTROL] &
 				~(FM3130_RTC_CONTROL_BIT_READ |
 					FM3130_RTC_CONTROL_BIT_WRITE));
 		dev_warn(&client->dev, "Disabling READ or WRITE mode!\n");
+	}
 
 	/* oscillator off?  turn it on, so clock can tick. */
 	if (fm3130->regs[FM3130_CAL_CONTROL] & FM3130_CAL_CONTROL_BIT_nOSCEN)
diff -Nur linux-2.6.32-orig/drivers/rtc/rtc-pcf50633.c iDroid-Project-kernel_common-9e90fd2/drivers/rtc/rtc-pcf50633.c
--- linux-2.6.32-orig/drivers/rtc/rtc-pcf50633.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/rtc/rtc-pcf50633.c	2010-11-18 21:05:30.000000000 +0600
@@ -2,6 +2,10 @@
  *
  * (C) 2006-2008 by Openmoko, Inc.
  * Author: Balaji Rao <balajirrao@openmoko.org>
+ *
+ * Portions (c) 2010 Ricky Taylor
+ * 	- Timer offset.
+ *
  * All rights reserved.
  *
  * Broken down from monstrous PCF50633 driver mainly by
@@ -39,6 +43,7 @@
 #define PCF50633_REG_RTCDTA	0x64 /* Alarm Day */
 #define PCF50633_REG_RTCMTA	0x65 /* Alarm Month */
 #define PCF50633_REG_RTCYRA	0x66 /* Alarm Year */
+#define PCF50633_REG_RTCOFF	0x6B /* Clock Offset */
 
 enum pcf50633_time_indexes {
 	PCF50633_TI_SEC,
@@ -61,10 +66,34 @@
 
 	struct pcf50633 *pcf;
 	struct rtc_device *rtc_dev;
+	struct platform_device *dev;
 };
 
-static void pcf2rtc_time(struct rtc_time *rtc, struct pcf50633_time *pcf)
+static void pcf2rtc_time(struct pcf50633_rtc *pcf_rtc, struct rtc_time *rtc, struct pcf50633_time *pcf)
 {
+#ifdef CONFIG_RTC_DRV_PCF50633_OFFSET
+	s32 offset;
+	int ret;
+
+	unsigned long time = mktime(
+		2000 + bcd2bin(bcd2bin(pcf->time[PCF50633_TI_YEAR])),	// Years
+		bcd2bin(pcf->time[PCF50633_TI_MONTH]),					// Months
+		bcd2bin(pcf->time[PCF50633_TI_DAY]),					// Days
+		bcd2bin(pcf->time[PCF50633_TI_HOUR]),					// Hours
+		bcd2bin(pcf->time[PCF50633_TI_MIN]),					// Minutes
+		bcd2bin(pcf->time[PCF50633_TI_SEC])						// Seconds
+		); 
+
+	ret = pcf50633_read_block(pcf_rtc->pcf, PCF50633_REG_RTCOFF,
+					    sizeof(offset),
+					    (u8*)&offset);
+	if (ret == sizeof(offset)) {
+		dev_dbg(&pcf_rtc->dev->dev, "OFFSET 0x%08x, %d\n", offset, offset);
+		time += offset;
+	}
+
+	rtc_time_to_tm(time, rtc);
+#else
 	rtc->tm_sec = bcd2bin(pcf->time[PCF50633_TI_SEC]);
 	rtc->tm_min = bcd2bin(pcf->time[PCF50633_TI_MIN]);
 	rtc->tm_hour = bcd2bin(pcf->time[PCF50633_TI_HOUR]);
@@ -72,10 +101,37 @@
 	rtc->tm_mday = bcd2bin(pcf->time[PCF50633_TI_DAY]);
 	rtc->tm_mon = bcd2bin(pcf->time[PCF50633_TI_MONTH]) - 1;
 	rtc->tm_year = bcd2bin(pcf->time[PCF50633_TI_YEAR]) + 100;
+#endif
 }
 
-static void rtc2pcf_time(struct pcf50633_time *pcf, struct rtc_time *rtc)
+static void rtc2pcf_time(struct pcf50633_rtc *pcf_rtc, struct pcf50633_time *pcf, struct rtc_time *rtc)
 {
+#ifdef CONFIG_RTC_DRV_PCF50633_OFFSET
+	unsigned long time;
+	s32 offset;
+	int ret;
+	struct rtc_time rtc_time;
+
+	if(rtc_tm_to_time(rtc, &time))
+		goto error;
+
+	ret = pcf50633_read_block(pcf_rtc->pcf, PCF50633_REG_RTCOFF,
+					    sizeof(offset),
+					    (u8*)&offset);
+	if (ret == sizeof(offset)) {
+		time -= offset;
+	}
+
+	rtc_time_to_tm(time, &rtc_time);
+
+	pcf->time[PCF50633_TI_SEC] = bin2bcd(rtc_time.tm_sec);
+	pcf->time[PCF50633_TI_MIN] = bin2bcd(rtc_time.tm_min);
+	pcf->time[PCF50633_TI_HOUR] = bin2bcd(rtc_time.tm_hour);
+	pcf->time[PCF50633_TI_WKDAY] = bin2bcd(rtc_time.tm_wday);
+	pcf->time[PCF50633_TI_DAY] = bin2bcd(rtc_time.tm_mday);
+	pcf->time[PCF50633_TI_MONTH] = bin2bcd(rtc_time.tm_mon + 1);
+	pcf->time[PCF50633_TI_YEAR] = bin2bcd(rtc_time.tm_year % 100);
+#else
 	pcf->time[PCF50633_TI_SEC] = bin2bcd(rtc->tm_sec);
 	pcf->time[PCF50633_TI_MIN] = bin2bcd(rtc->tm_min);
 	pcf->time[PCF50633_TI_HOUR] = bin2bcd(rtc->tm_hour);
@@ -83,6 +139,10 @@
 	pcf->time[PCF50633_TI_DAY] = bin2bcd(rtc->tm_mday);
 	pcf->time[PCF50633_TI_MONTH] = bin2bcd(rtc->tm_mon + 1);
 	pcf->time[PCF50633_TI_YEAR] = bin2bcd(rtc->tm_year % 100);
+#endif
+
+error:
+	return;
 }
 
 static int
@@ -147,7 +207,7 @@
 		pcf_tm.time[PCF50633_TI_MIN],
 		pcf_tm.time[PCF50633_TI_SEC]);
 
-	pcf2rtc_time(tm, &pcf_tm);
+	pcf2rtc_time(rtc, tm, &pcf_tm);
 
 	dev_dbg(dev, "RTC_TIME: %u.%u.%u %u:%u:%u\n",
 		tm->tm_mday, tm->tm_mon, tm->tm_year,
@@ -164,11 +224,12 @@
 
 	rtc = dev_get_drvdata(dev);
 
+#ifdef CONFIG_RTC_DRV_PCF50633_OFFSET
 	dev_dbg(dev, "RTC_TIME: %u.%u.%u %u:%u:%u\n",
 		tm->tm_mday, tm->tm_mon, tm->tm_year,
 		tm->tm_hour, tm->tm_min, tm->tm_sec);
 
-	rtc2pcf_time(&pcf_tm, tm);
+	rtc2pcf_time(rtc, &pcf_tm, tm);
 
 	dev_dbg(dev, "PCF_TIME: %02x.%02x.%02x %02x:%02x:%02x\n",
 		pcf_tm.time[PCF50633_TI_DAY],
@@ -197,6 +258,53 @@
 	if (!alarm_masked)
 		pcf50633_irq_unmask(rtc->pcf, PCF50633_IRQ_ALARM);
 
+#else
+	ret = pcf50633_read_block(rtc->pcf, PCF50633_REG_RTCSC,
+					    PCF50633_TI_EXTENT,
+					    &pcf_tm.time[0]);
+	if (ret != PCF50633_TI_EXTENT) {
+		dev_err(dev, "Failed to read time\n");
+		return -EIO;
+	}
+
+	dev_dbg(dev, "PCF_TIME: %02x.%02x.%02x %02x:%02x:%02x\n",
+		pcf_tm.time[PCF50633_TI_DAY],
+		pcf_tm.time[PCF50633_TI_MONTH],
+		pcf_tm.time[PCF50633_TI_YEAR],
+		pcf_tm.time[PCF50633_TI_HOUR],
+		pcf_tm.time[PCF50633_TI_MIN],
+		pcf_tm.time[PCF50633_TI_SEC]);
+
+	s32 time = mktime(
+		2000 + bcd2bin(bcd2bin(pcf_tm.time[PCF50633_TI_YEAR])),	// Years
+		bcd2bin(pcf_tm.time[PCF50633_TI_MONTH]),				// Months
+		bcd2bin(pcf_tm.time[PCF50633_TI_DAY]),					// Days
+		bcd2bin(pcf_tm.time[PCF50633_TI_HOUR]),					// Hours
+		bcd2bin(pcf_tm.time[PCF50633_TI_MIN]),					// Minutes
+		bcd2bin(pcf_tm.time[PCF50633_TI_SEC])					// Seconds
+		); 
+
+	s32 destTime = rtc_tm_to_time(tm);
+	s32 new_offset = destTime-time;
+
+	second_masked = pcf50633_irq_mask_get(rtc->pcf, PCF50633_IRQ_SECOND);
+	alarm_masked = pcf50633_irq_mask_get(rtc->pcf, PCF50633_IRQ_ALARM);
+
+	if (!second_masked)
+		pcf50633_irq_mask(rtc->pcf, PCF50633_IRQ_SECOND);
+	if (!alarm_masked)
+		pcf50633_irq_mask(rtc->pcf, PCF50633_IRQ_ALARM);
+
+	ret = pcf50633_write_block(rtc->pcf, PCF50633_REG_RTCOF,
+					     sizeof(new_offset),
+					     &new_offset);
+
+	if (!second_masked)
+		pcf50633_irq_unmask(rtc->pcf, PCF50633_IRQ_SECOND);
+	if (!alarm_masked)
+		pcf50633_irq_unmask(rtc->pcf, PCF50633_IRQ_ALARM);
+#endif
+
 	return ret;
 }
 
@@ -217,7 +325,7 @@
 		return -EIO;
 	}
 
-	pcf2rtc_time(&alrm->time, &pcf_tm);
+	pcf2rtc_time(rtc, &alrm->time, &pcf_tm);
 
 	return rtc_valid_tm(&alrm->time);
 }
@@ -230,7 +338,7 @@
 
 	rtc = dev_get_drvdata(dev);
 
-	rtc2pcf_time(&pcf_tm, &alrm->time);
+	rtc2pcf_time(rtc, &pcf_tm, &alrm->time);
 
 	/* do like mktime does and ignore tm_wday */
 	pcf_tm.time[PCF50633_TI_WKDAY] = 7;
@@ -280,13 +388,13 @@
 	struct pcf50633_subdev_pdata *pdata;
 	struct pcf50633_rtc *rtc;
 
-
 	rtc = kzalloc(sizeof(*rtc), GFP_KERNEL);
 	if (!rtc)
 		return -ENOMEM;
 
 	pdata = pdev->dev.platform_data;
 	rtc->pcf = pdata->pcf;
+	rtc->dev = pdev;
 	platform_set_drvdata(pdev, rtc);
 	rtc->rtc_dev = rtc_device_register("pcf50633-rtc", &pdev->dev,
 				&pcf50633_rtc_ops, THIS_MODULE);
diff -Nur linux-2.6.32-orig/drivers/s390/block/dasd.c iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd.c
--- linux-2.6.32-orig/drivers/s390/block/dasd.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd.c	2010-11-18 21:05:30.000000000 +0600
@@ -994,10 +994,9 @@
 		return;
 	cqr = (struct dasd_ccw_req *) intparm;
 	if (cqr->status != DASD_CQR_IN_IO) {
-		DBF_EVENT(DBF_DEBUG,
-			"invalid status in handle_killed_request: "
-			"bus_id %s, status %02x",
-			dev_name(&cdev->dev), cqr->status);
+		DBF_EVENT_DEVID(DBF_DEBUG, cdev,
+				"invalid status in handle_killed_request: "
+				"%02x", cqr->status);
 		return;
 	}
 
@@ -1005,8 +1004,8 @@
 	if (device == NULL ||
 	    device != dasd_device_from_cdev_locked(cdev) ||
 	    strncmp(device->discipline->ebcname, (char *) &cqr->magic, 4)) {
-		DBF_DEV_EVENT(DBF_DEBUG, device, "invalid device in request: "
-			      "bus_id %s", dev_name(&cdev->dev));
+		DBF_EVENT_DEVID(DBF_DEBUG, cdev, "%s",
+				"invalid device in request");
 		return;
 	}
 
@@ -1045,12 +1044,13 @@
 		case -EIO:
 			break;
 		case -ETIMEDOUT:
-			DBF_EVENT(DBF_WARNING, "%s(%s): request timed out\n",
-			       __func__, dev_name(&cdev->dev));
+			DBF_EVENT_DEVID(DBF_WARNING, cdev, "%s: "
+					"request timed out\n", __func__);
 			break;
 		default:
-			DBF_EVENT(DBF_WARNING, "%s(%s): unknown error %ld\n",
-			       __func__, dev_name(&cdev->dev), PTR_ERR(irb));
+			DBF_EVENT_DEVID(DBF_WARNING, cdev, "%s: "
+					"unknown error %ld\n", __func__,
+					PTR_ERR(irb));
 		}
 		dasd_handle_killed_request(cdev, intparm);
 		return;
@@ -1078,8 +1078,8 @@
 	device = (struct dasd_device *) cqr->startdev;
 	if (!device ||
 	    strncmp(device->discipline->ebcname, (char *) &cqr->magic, 4)) {
-		DBF_DEV_EVENT(DBF_DEBUG, device, "invalid device in request: "
-			      "bus_id %s", dev_name(&cdev->dev));
+		DBF_EVENT_DEVID(DBF_DEBUG, cdev, "%s",
+				"invalid device in request");
 		return;
 	}
 
@@ -2217,9 +2217,9 @@
 	}
 	ret = dasd_add_sysfs_files(cdev);
 	if (ret) {
-		DBF_EVENT(DBF_WARNING,
-		       "dasd_generic_probe: could not add sysfs entries "
-		       "for %s\n", dev_name(&cdev->dev));
+		DBF_EVENT_DEVID(DBF_WARNING, cdev, "%s",
+				"dasd_generic_probe: could not add "
+				"sysfs entries");
 		return ret;
 	}
 	cdev->handler = &dasd_int_handler;
diff -Nur linux-2.6.32-orig/drivers/s390/block/dasd_diag.c iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd_diag.c
--- linux-2.6.32-orig/drivers/s390/block/dasd_diag.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd_diag.c	2010-11-18 21:05:30.000000000 +0600
@@ -145,6 +145,15 @@
 
 	mdsk_term_io(device);
 	rc = mdsk_init_io(device, device->block->bp_block, 0, NULL);
+	if (rc == 4) {
+		if (!(device->features & DASD_FEATURE_READONLY)) {
+			dev_warn(&device->cdev->dev,
+				 "The access mode of a DIAG device changed"
+				 " to read-only");
+			device->features |= DASD_FEATURE_READONLY;
+		}
+		rc = 0;
+	}
 	if (rc)
 		dev_warn(&device->cdev->dev, "DIAG ERP failed with "
 			    "rc=%d\n", rc);
@@ -433,16 +442,20 @@
 	for (sb = 512; sb < bsize; sb = sb << 1)
 		block->s2b_shift++;
 	rc = mdsk_init_io(device, block->bp_block, 0, NULL);
-	if (rc) {
+	if (rc && (rc != 4)) {
 		dev_warn(&device->cdev->dev, "DIAG initialization "
 			"failed with rc=%d\n", rc);
 		rc = -EIO;
 	} else {
+		if (rc == 4)
+			device->features |= DASD_FEATURE_READONLY;
 		dev_info(&device->cdev->dev,
-			 "New DASD with %ld byte/block, total size %ld KB\n",
+			 "New DASD with %ld byte/block, total size %ld KB%s\n",
 			 (unsigned long) block->bp_block,
 			 (unsigned long) (block->blocks <<
-					  block->s2b_shift) >> 1);
+					  block->s2b_shift) >> 1,
+			 (rc == 4) ? ", read-only device" : "");
+		rc = 0;
 	}
 out_label:
 	free_page((long) label);
diff -Nur linux-2.6.32-orig/drivers/s390/block/dasd_eckd.c iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd_eckd.c
--- linux-2.6.32-orig/drivers/s390/block/dasd_eckd.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd_eckd.c	2010-11-18 21:05:30.000000000 +0600
@@ -88,9 +88,9 @@
 	/* set ECKD specific ccw-device options */
 	ret = ccw_device_set_options(cdev, CCWDEV_ALLOW_FORCE);
 	if (ret) {
-		DBF_EVENT(DBF_WARNING,
-		       "dasd_eckd_probe: could not set ccw-device options "
-		       "for %s\n", dev_name(&cdev->dev));
+		DBF_EVENT_DEVID(DBF_WARNING, cdev, "%s",
+				"dasd_eckd_probe: could not set "
+				"ccw-device options");
 		return ret;
 	}
 	ret = dasd_generic_probe(cdev, &dasd_eckd_discipline);
@@ -885,16 +885,15 @@
 			rc = dasd_eckd_read_conf_lpm(device, &conf_data,
 						     &conf_len, lpm);
 			if (rc && rc != -EOPNOTSUPP) {	/* -EOPNOTSUPP is ok */
-				DBF_EVENT(DBF_WARNING,
+				DBF_EVENT_DEVID(DBF_WARNING, device->cdev,
 					  "Read configuration data returned "
-					  "error %d for device: %s", rc,
-					  dev_name(&device->cdev->dev));
+					  "error %d", rc);
 				return rc;
 			}
 			if (conf_data == NULL) {
-				DBF_EVENT(DBF_WARNING, "No configuration "
-					  "data retrieved for device: %s",
-					  dev_name(&device->cdev->dev));
+				DBF_EVENT_DEVID(DBF_WARNING, device->cdev, "%s",
+						"No configuration data "
+						"retrieved");
 				continue;	/* no error */
 			}
 			/* save first valid configuration data */
@@ -941,9 +940,8 @@
 				    sizeof(struct dasd_rssd_features)),
 				   device);
 	if (IS_ERR(cqr)) {
-		DBF_EVENT(DBF_WARNING, "Could not allocate initialization "
-			  "request for device: %s",
-			  dev_name(&device->cdev->dev));
+		DBF_EVENT_DEVID(DBF_WARNING, device->cdev, "%s", "Could not "
+				"allocate initialization request");
 		return PTR_ERR(cqr);
 	}
 	cqr->startdev = device;
@@ -1071,10 +1069,8 @@
 	/* may be requested feature is not available on server,
 	 * therefore just report error and go ahead */
 	private = (struct dasd_eckd_private *) device->private;
-	DBF_EVENT(DBF_WARNING, "PSF-SSC on storage subsystem %s.%s.%04x "
-		  "returned rc=%d for device: %s",
-		  private->uid.vendor, private->uid.serial,
-		  private->uid.ssid, rc, dev_name(&device->cdev->dev));
+	DBF_EVENT_DEVID(DBF_WARNING, device->cdev, "PSF-SSC for SSID %04x "
+			"returned rc=%d", private->uid.ssid, rc);
 	/* RE-Read Configuration Data */
 	return dasd_eckd_read_conf(device);
 }
@@ -1123,9 +1119,9 @@
 	if (private->uid.type == UA_BASE_DEVICE) {
 		block = dasd_alloc_block();
 		if (IS_ERR(block)) {
-			DBF_EVENT(DBF_WARNING, "could not allocate dasd "
-				  "block structure for device: %s",
-				  dev_name(&device->cdev->dev));
+			DBF_EVENT_DEVID(DBF_WARNING, device->cdev, "%s",
+					"could not allocate dasd "
+					"block structure");
 			rc = PTR_ERR(block);
 			goto out_err1;
 		}
@@ -1153,9 +1149,8 @@
 	rc = dasd_generic_read_dev_chars(device, DASD_ECKD_MAGIC,
 					 &private->rdc_data, 64);
 	if (rc) {
-		DBF_EVENT(DBF_WARNING,
-			  "Read device characteristics failed, rc=%d for "
-			  "device: %s", rc, dev_name(&device->cdev->dev));
+		DBF_EVENT_DEVID(DBF_WARNING, device->cdev,
+				"Read device characteristic failed, rc=%d", rc);
 		goto out_err3;
 	}
 	/* find the vaild cylinder size */
@@ -2980,7 +2975,7 @@
 	len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 		       " in req: %p CS: 0x%02X DS: 0x%02X CC: 0x%02X RC: %d\n",
 		       req, scsw_cstat(&irb->scsw), scsw_dstat(&irb->scsw),
-		       scsw_cc(&irb->scsw), req->intrc);
+		       scsw_cc(&irb->scsw), req ? req->intrc : 0);
 	len += sprintf(page + len, KERN_ERR PRINTK_HEADER
 		       " device %s: Failing CCW: %p\n",
 		       dev_name(&device->cdev->dev),
@@ -3253,9 +3248,8 @@
 	rc = dasd_generic_read_dev_chars(device, DASD_ECKD_MAGIC,
 					 &temp_rdc_data, 64);
 	if (rc) {
-		DBF_EVENT(DBF_WARNING,
-			  "Read device characteristics failed, rc=%d for "
-			  "device: %s", rc, dev_name(&device->cdev->dev));
+		DBF_EVENT_DEVID(DBF_WARNING, device->cdev,
+				"Read device characteristic failed, rc=%d", rc);
 		goto out_err;
 	}
 	spin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);
diff -Nur linux-2.6.32-orig/drivers/s390/block/dasd_fba.c iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd_fba.c
--- linux-2.6.32-orig/drivers/s390/block/dasd_fba.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd_fba.c	2010-11-18 21:05:30.000000000 +0600
@@ -141,9 +141,8 @@
 	}
 	block = dasd_alloc_block();
 	if (IS_ERR(block)) {
-		DBF_EVENT(DBF_WARNING, "could not allocate dasd block "
-			  "structure for device: %s",
-			  dev_name(&device->cdev->dev));
+		DBF_EVENT_DEVID(DBF_WARNING, cdev, "%s", "could not allocate "
+				"dasd block structure");
 		device->private = NULL;
 		kfree(private);
 		return PTR_ERR(block);
@@ -155,9 +154,8 @@
 	rc = dasd_generic_read_dev_chars(device, DASD_FBA_MAGIC,
 					 &private->rdc_data, 32);
 	if (rc) {
-		DBF_EVENT(DBF_WARNING, "Read device characteristics returned "
-			  "error %d for device: %s",
-			  rc, dev_name(&device->cdev->dev));
+		DBF_EVENT_DEVID(DBF_WARNING, cdev, "Read device "
+				"characteristics returned error %d", rc);
 		device->block = NULL;
 		dasd_free_block(block);
 		device->private = NULL;
diff -Nur linux-2.6.32-orig/drivers/s390/block/dasd_int.h iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd_int.h
--- linux-2.6.32-orig/drivers/s390/block/dasd_int.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd_int.h	2010-11-18 21:05:30.000000000 +0600
@@ -108,6 +108,16 @@
 			    d_data); \
 } while(0)
 
+#define DBF_EVENT_DEVID(d_level, d_cdev, d_str, d_data...)	\
+do { \
+	struct ccw_dev_id __dev_id;			\
+	ccw_device_get_id(d_cdev, &__dev_id);		\
+	debug_sprintf_event(dasd_debug_area,		\
+			    d_level,					\
+			    "0.%x.%04x " d_str "\n",			\
+			    __dev_id.ssid, __dev_id.devno, d_data);	\
+} while (0)
+
 #define DBF_EXC(d_level, d_str, d_data...)\
 do { \
 	debug_sprintf_exception(dasd_debug_area, \
diff -Nur linux-2.6.32-orig/drivers/s390/block/dasd_ioctl.c iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd_ioctl.c
--- linux-2.6.32-orig/drivers/s390/block/dasd_ioctl.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd_ioctl.c	2010-11-18 21:05:30.000000000 +0600
@@ -260,7 +260,7 @@
 	struct ccw_dev_id dev_id;
 
 	base = block->base;
-	if (!base->discipline->fill_info)
+	if (!base->discipline || !base->discipline->fill_info)
 		return -EINVAL;
 
 	dasd_info = kzalloc(sizeof(struct dasd_information2_t), GFP_KERNEL);
@@ -303,10 +303,7 @@
 	dasd_info->features |=
 		((base->features & DASD_FEATURE_READONLY) != 0);
 
-	if (base->discipline)
-		memcpy(dasd_info->type, base->discipline->name, 4);
-	else
-		memcpy(dasd_info->type, "none", 4);
+	memcpy(dasd_info->type, base->discipline->name, 4);
 
 	if (block->request_queue->request_fn) {
 		struct list_head *l;
diff -Nur linux-2.6.32-orig/drivers/s390/block/dasd_proc.c iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd_proc.c
--- linux-2.6.32-orig/drivers/s390/block/dasd_proc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/s390/block/dasd_proc.c	2010-11-18 21:05:30.000000000 +0600
@@ -71,7 +71,7 @@
 	/* Print device number. */
 	seq_printf(m, "%s", dev_name(&device->cdev->dev));
 	/* Print discipline string. */
-	if (device != NULL && device->discipline != NULL)
+	if (device->discipline != NULL)
 		seq_printf(m, "(%s)", device->discipline->name);
 	else
 		seq_printf(m, "(none)");
@@ -91,10 +91,7 @@
 	substr = (device->features & DASD_FEATURE_READONLY) ? "(ro)" : " ";
 	seq_printf(m, "%4s: ", substr);
 	/* Print device status information. */
-	switch ((device != NULL) ? device->state : -1) {
-	case -1:
-		seq_printf(m, "unknown");
-		break;
+	switch (device->state) {
 	case DASD_STATE_NEW:
 		seq_printf(m, "new");
 		break;
diff -Nur linux-2.6.32-orig/drivers/s390/cio/device.c iDroid-Project-kernel_common-9e90fd2/drivers/s390/cio/device.c
--- linux-2.6.32-orig/drivers/s390/cio/device.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/s390/cio/device.c	2010-11-18 21:05:30.000000000 +0600
@@ -1292,7 +1292,7 @@
 	sch->private = kzalloc(sizeof(struct io_subchannel_private),
 			       GFP_KERNEL | GFP_DMA);
 	if (!sch->private)
-		goto out_err;
+		goto out_schedule;
 	/*
 	 * First check if a fitting device may be found amongst the
 	 * disconnected devices or in the orphanage.
@@ -1317,7 +1317,7 @@
 	}
 	cdev = io_subchannel_create_ccwdev(sch);
 	if (IS_ERR(cdev))
-		goto out_err;
+		goto out_schedule;
 	rc = io_subchannel_recog(cdev, sch);
 	if (rc) {
 		spin_lock_irqsave(sch->lock, flags);
@@ -1325,9 +1325,7 @@
 		spin_unlock_irqrestore(sch->lock, flags);
 	}
 	return 0;
-out_err:
-	kfree(sch->private);
-	sysfs_remove_group(&sch->dev.kobj, &io_subchannel_attr_group);
+
 out_schedule:
 	io_subchannel_schedule_removal(sch);
 	return 0;
@@ -1341,13 +1339,14 @@
 
 	cdev = sch_get_cdev(sch);
 	if (!cdev)
-		return 0;
+		goto out_free;
 	/* Set ccw device to not operational and drop reference. */
 	spin_lock_irqsave(cdev->ccwlock, flags);
 	sch_set_cdev(sch, NULL);
 	cdev->private->state = DEV_STATE_NOT_OPER;
 	spin_unlock_irqrestore(cdev->ccwlock, flags);
 	ccw_device_unregister(cdev);
+out_free:
 	kfree(sch->private);
 	sysfs_remove_group(&sch->dev.kobj, &io_subchannel_attr_group);
 	return 0;
diff -Nur linux-2.6.32-orig/drivers/s390/cio/device_fsm.c iDroid-Project-kernel_common-9e90fd2/drivers/s390/cio/device_fsm.c
--- linux-2.6.32-orig/drivers/s390/cio/device_fsm.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/s390/cio/device_fsm.c	2010-11-18 21:05:30.000000000 +0600
@@ -1080,14 +1080,14 @@
 		ccw_device_start_id(cdev, 0);
 }
 
-static void
-ccw_device_offline_irq(struct ccw_device *cdev, enum dev_event dev_event)
+static void ccw_device_disabled_irq(struct ccw_device *cdev,
+				    enum dev_event dev_event)
 {
 	struct subchannel *sch;
 
 	sch = to_subchannel(cdev->dev.parent);
 	/*
-	 * An interrupt in state offline means a previous disable was not
+	 * An interrupt in a disabled state means a previous disable was not
 	 * successful - should not happen, but we try to disable again.
 	 */
 	cio_disable_subchannel(sch);
@@ -1150,25 +1150,12 @@
 }
 
 /*
- * Bug operation action. 
- */
-static void
-ccw_device_bug(struct ccw_device *cdev, enum dev_event dev_event)
-{
-	CIO_MSG_EVENT(0, "Internal state [%i][%i] not handled for device "
-		      "0.%x.%04x\n", cdev->private->state, dev_event,
-		      cdev->private->dev_id.ssid,
-		      cdev->private->dev_id.devno);
-	BUG();
-}
-
-/*
  * device statemachine
  */
 fsm_func_t *dev_jumptable[NR_DEV_STATES][NR_DEV_EVENTS] = {
 	[DEV_STATE_NOT_OPER] = {
 		[DEV_EVENT_NOTOPER]	= ccw_device_nop,
-		[DEV_EVENT_INTERRUPT]	= ccw_device_bug,
+		[DEV_EVENT_INTERRUPT]	= ccw_device_disabled_irq,
 		[DEV_EVENT_TIMEOUT]	= ccw_device_nop,
 		[DEV_EVENT_VERIFY]	= ccw_device_nop,
 	},
@@ -1186,7 +1173,7 @@
 	},
 	[DEV_STATE_OFFLINE] = {
 		[DEV_EVENT_NOTOPER]	= ccw_device_generic_notoper,
-		[DEV_EVENT_INTERRUPT]	= ccw_device_offline_irq,
+		[DEV_EVENT_INTERRUPT]	= ccw_device_disabled_irq,
 		[DEV_EVENT_TIMEOUT]	= ccw_device_nop,
 		[DEV_EVENT_VERIFY]	= ccw_device_offline_verify,
 	},
@@ -1243,7 +1230,7 @@
 	[DEV_STATE_DISCONNECTED] = {
 		[DEV_EVENT_NOTOPER]	= ccw_device_nop,
 		[DEV_EVENT_INTERRUPT]	= ccw_device_start_id,
-		[DEV_EVENT_TIMEOUT]	= ccw_device_bug,
+		[DEV_EVENT_TIMEOUT]	= ccw_device_nop,
 		[DEV_EVENT_VERIFY]	= ccw_device_start_id,
 	},
 	[DEV_STATE_DISCONNECTED_SENSE_ID] = {
diff -Nur linux-2.6.32-orig/drivers/s390/crypto/zcrypt_pcicc.c iDroid-Project-kernel_common-9e90fd2/drivers/s390/crypto/zcrypt_pcicc.c
--- linux-2.6.32-orig/drivers/s390/crypto/zcrypt_pcicc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/s390/crypto/zcrypt_pcicc.c	2010-11-18 21:05:30.000000000 +0600
@@ -373,6 +373,8 @@
 			zdev->max_mod_size = PCICC_MAX_MOD_SIZE_OLD;
 			return -EAGAIN;
 		}
+		if (service_rc == 8 && service_rs == 72)
+			return -EINVAL;
 		zdev->online = 0;
 		return -EAGAIN;	/* repeat the request on a different device. */
 	}
diff -Nur linux-2.6.32-orig/drivers/s390/crypto/zcrypt_pcixcc.c iDroid-Project-kernel_common-9e90fd2/drivers/s390/crypto/zcrypt_pcixcc.c
--- linux-2.6.32-orig/drivers/s390/crypto/zcrypt_pcixcc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/s390/crypto/zcrypt_pcixcc.c	2010-11-18 21:05:30.000000000 +0600
@@ -462,6 +462,8 @@
 		}
 		if (service_rc == 12 && service_rs == 769)
 			return -EINVAL;
+		if (service_rc == 8 && service_rs == 72)
+			return -EINVAL;
 		zdev->online = 0;
 		return -EAGAIN;	/* repeat the request on a different device. */
 	}
diff -Nur linux-2.6.32-orig/drivers/s390/net/netiucv.c iDroid-Project-kernel_common-9e90fd2/drivers/s390/net/netiucv.c
--- linux-2.6.32-orig/drivers/s390/net/netiucv.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/s390/net/netiucv.c	2010-11-18 21:05:30.000000000 +0600
@@ -741,13 +741,13 @@
 	if (single_flag) {
 		if ((skb = skb_dequeue(&conn->commit_queue))) {
 			atomic_dec(&skb->users);
-			dev_kfree_skb_any(skb);
 			if (privptr) {
 				privptr->stats.tx_packets++;
 				privptr->stats.tx_bytes +=
 					(skb->len - NETIUCV_HDRLEN
-					 	  - NETIUCV_HDRLEN);
+						  - NETIUCV_HDRLEN);
 			}
+			dev_kfree_skb_any(skb);
 		}
 	}
 	conn->tx_buff->data = conn->tx_buff->head;
diff -Nur linux-2.6.32-orig/drivers/scsi/device_handler/scsi_dh.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/device_handler/scsi_dh.c
--- linux-2.6.32-orig/drivers/scsi/device_handler/scsi_dh.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/device_handler/scsi_dh.c	2010-11-18 21:05:30.000000000 +0600
@@ -304,18 +304,15 @@
 	sdev = to_scsi_device(dev);
 
 	if (action == BUS_NOTIFY_ADD_DEVICE) {
+		err = device_create_file(dev, &scsi_dh_state_attr);
+		/* don't care about err */
 		devinfo = device_handler_match(NULL, sdev);
-		if (!devinfo)
-			goto out;
-
-		err = scsi_dh_handler_attach(sdev, devinfo);
-		if (!err)
-			err = device_create_file(dev, &scsi_dh_state_attr);
+		if (devinfo)
+			err = scsi_dh_handler_attach(sdev, devinfo);
 	} else if (action == BUS_NOTIFY_DEL_DEVICE) {
 		device_remove_file(dev, &scsi_dh_state_attr);
 		scsi_dh_handler_detach(sdev, NULL);
 	}
-out:
 	return err;
 }
 
diff -Nur linux-2.6.32-orig/drivers/scsi/fcoe/fcoe.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/fcoe/fcoe.c
--- linux-2.6.32-orig/drivers/scsi/fcoe/fcoe.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/fcoe/fcoe.c	2010-11-18 21:05:30.000000000 +0600
@@ -137,7 +137,7 @@
 	.change_queue_depth = fc_change_queue_depth,
 	.change_queue_type = fc_change_queue_type,
 	.this_id = -1,
-	.cmd_per_lun = 32,
+	.cmd_per_lun = 3,
 	.can_queue = FCOE_MAX_OUTSTANDING_COMMANDS,
 	.use_clustering = ENABLE_CLUSTERING,
 	.sg_tablesize = SG_ALL,
@@ -160,6 +160,7 @@
 {
 	struct fcoe_ctlr *fip = &fcoe->ctlr;
 	struct netdev_hw_addr *ha;
+	struct net_device *real_dev;
 	u8 flogi_maddr[ETH_ALEN];
 
 	fcoe->netdev = netdev;
@@ -173,10 +174,12 @@
 
 	/* look for SAN MAC address, if multiple SAN MACs exist, only
 	 * use the first one for SPMA */
+	real_dev = (netdev->priv_flags & IFF_802_1Q_VLAN) ?
+		vlan_dev_real_dev(netdev) : netdev;
 	rcu_read_lock();
-	for_each_dev_addr(netdev, ha) {
+	for_each_dev_addr(real_dev, ha) {
 		if ((ha->type == NETDEV_HW_ADDR_T_SAN) &&
-		    (is_valid_ether_addr(fip->ctl_src_addr))) {
+		    (is_valid_ether_addr(ha->addr))) {
 			memcpy(fip->ctl_src_addr, ha->addr, ETH_ALEN);
 			fip->spma = 1;
 			break;
@@ -664,7 +667,7 @@
 {
 	struct net_device *n = fcoe_netdev(lp);
 
-	if (n->netdev_ops && n->netdev_ops->ndo_fcoe_ddp_setup)
+	if (n->netdev_ops->ndo_fcoe_ddp_setup)
 		return n->netdev_ops->ndo_fcoe_ddp_setup(n, xid, sgl, sgc);
 
 	return 0;
@@ -681,7 +684,7 @@
 {
 	struct net_device *n = fcoe_netdev(lp);
 
-	if (n->netdev_ops && n->netdev_ops->ndo_fcoe_ddp_done)
+	if (n->netdev_ops->ndo_fcoe_ddp_done)
 		return n->netdev_ops->ndo_fcoe_ddp_done(n, xid);
 	return 0;
 }
@@ -1631,7 +1634,7 @@
 {
 	struct fcoe_interface *fcoe;
 	struct net_device *netdev;
-	int rc;
+	int rc = 0;
 
 	mutex_lock(&fcoe_config_mutex);
 #ifdef CONFIG_FCOE_MODULE
diff -Nur linux-2.6.32-orig/drivers/scsi/hosts.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/hosts.c
--- linux-2.6.32-orig/drivers/scsi/hosts.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/hosts.c	2010-11-18 21:05:30.000000000 +0600
@@ -180,14 +180,20 @@
 EXPORT_SYMBOL(scsi_remove_host);
 
 /**
- * scsi_add_host - add a scsi host
+ * scsi_add_host_with_dma - add a scsi host with dma device
  * @shost:	scsi host pointer to add
  * @dev:	a struct device of type scsi class
+ * @dma_dev:	dma device for the host
+ *
+ * Note: You rarely need to worry about this unless you're in a
+ * virtualised host environments, so use the simpler scsi_add_host()
+ * function instead.
  *
  * Return value: 
  * 	0 on success / != 0 for error
  **/
-int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
+int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
+			   struct device *dma_dev)
 {
 	struct scsi_host_template *sht = shost->hostt;
 	int error = -EINVAL;
@@ -207,6 +213,7 @@
 
 	if (!shost->shost_gendev.parent)
 		shost->shost_gendev.parent = dev ? dev : &platform_bus;
+	shost->dma_dev = dma_dev;
 
 	error = device_add(&shost->shost_gendev);
 	if (error)
@@ -262,7 +269,7 @@
  fail:
 	return error;
 }
-EXPORT_SYMBOL(scsi_add_host);
+EXPORT_SYMBOL(scsi_add_host_with_dma);
 
 static void scsi_host_dev_release(struct device *dev)
 {
diff -Nur linux-2.6.32-orig/drivers/scsi/ipr.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/ipr.c
--- linux-2.6.32-orig/drivers/scsi/ipr.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/ipr.c	2010-11-18 21:05:30.000000000 +0600
@@ -6516,6 +6516,7 @@
 	int rc;
 
 	ENTER;
+	ioa_cfg->pdev->state_saved = true;
 	rc = pci_restore_state(ioa_cfg->pdev);
 
 	if (rc != PCIBIOS_SUCCESSFUL) {
diff -Nur linux-2.6.32-orig/drivers/scsi/libfc/fc_disc.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/libfc/fc_disc.c
--- linux-2.6.32-orig/drivers/scsi/libfc/fc_disc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/libfc/fc_disc.c	2010-11-18 21:05:30.000000000 +0600
@@ -371,7 +371,7 @@
 				 disc, lport->e_d_tov))
 		return;
 err:
-	fc_disc_error(disc, fp);
+	fc_disc_error(disc, NULL);
 }
 
 /**
diff -Nur linux-2.6.32-orig/drivers/scsi/libfc/fc_elsct.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/libfc/fc_elsct.c
--- linux-2.6.32-orig/drivers/scsi/libfc/fc_elsct.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/libfc/fc_elsct.c	2010-11-18 21:05:30.000000000 +0600
@@ -53,8 +53,10 @@
 		did = FC_FID_DIR_SERV;
 	}
 
-	if (rc)
+	if (rc) {
+		fc_frame_free(fp);
 		return NULL;
+	}
 
 	fc_fill_fc_hdr(fp, r_ctl, did, fc_host_port_id(lport->host), fh_type,
 		       FC_FC_FIRST_SEQ | FC_FC_END_SEQ | FC_FC_SEQ_INIT, 0);
diff -Nur linux-2.6.32-orig/drivers/scsi/libfc/fc_fcp.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/libfc/fc_fcp.c
--- linux-2.6.32-orig/drivers/scsi/libfc/fc_fcp.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/libfc/fc_fcp.c	2010-11-18 21:05:30.000000000 +0600
@@ -302,10 +302,13 @@
 	if (!fsp)
 		return;
 
+	if (fsp->xfer_ddp == FC_XID_UNKNOWN)
+		return;
+
 	lp = fsp->lp;
-	if (fsp->xfer_ddp && lp->tt.ddp_done) {
+	if (lp->tt.ddp_done) {
 		fsp->xfer_len = lp->tt.ddp_done(lp, fsp->xfer_ddp);
-		fsp->xfer_ddp = 0;
+		fsp->xfer_ddp = FC_XID_UNKNOWN;
 	}
 }
 
@@ -572,7 +575,8 @@
 		tlen -= sg_bytes;
 		remaining -= sg_bytes;
 
-		if (tlen)
+		if ((skb_shinfo(fp_skb(fp))->nr_frags < FC_FRAME_SG_LEN) &&
+		    (tlen))
 			continue;
 
 		/*
@@ -1048,7 +1052,6 @@
 
 	seq = lp->tt.exch_seq_send(lp, fp, resp, fc_fcp_pkt_destroy, fsp, 0);
 	if (!seq) {
-		fc_frame_free(fp);
 		rc = -1;
 		goto unlock;
 	}
@@ -1313,7 +1316,6 @@
 		fc_fcp_pkt_hold(fsp);		/* hold while REC outstanding */
 		return;
 	}
-	fc_frame_free(fp);
 retry:
 	if (fsp->recov_retry++ < FC_MAX_RECOV_RETRY)
 		fc_fcp_timer_set(fsp, FC_SCSI_REC_TOV);
@@ -1561,10 +1563,9 @@
 
 	seq = lp->tt.exch_seq_send(lp, fp, fc_fcp_srr_resp, NULL,
 				   fsp, jiffies_to_msecs(FC_SCSI_REC_TOV));
-	if (!seq) {
-		fc_frame_free(fp);
+	if (!seq)
 		goto retry;
-	}
+
 	fsp->recov_seq = seq;
 	fsp->xfer_len = offset;
 	fsp->xfer_contig_end = offset;
@@ -1708,6 +1709,7 @@
 	fsp->cmd = sc_cmd;	/* save the cmd */
 	fsp->lp = lp;		/* save the softc ptr */
 	fsp->rport = rport;	/* set the remote port ptr */
+	fsp->xfer_ddp = FC_XID_UNKNOWN;
 	sc_cmd->scsi_done = done;
 
 	/*
@@ -1846,7 +1848,8 @@
 			 * scsi status is good but transport level
 			 * underrun.
 			 */
-			sc_cmd->result = DID_OK << 16;
+			sc_cmd->result = (fsp->state & FC_SRB_RCV_STATUS ?
+					  DID_OK : DID_ERROR) << 16;
 		} else {
 			/*
 			 * scsi got underrun, this is an error
@@ -2046,18 +2049,16 @@
 int fc_slave_alloc(struct scsi_device *sdev)
 {
 	struct fc_rport *rport = starget_to_rport(scsi_target(sdev));
-	int queue_depth;
 
 	if (!rport || fc_remote_port_chkready(rport))
 		return -ENXIO;
 
-	if (sdev->tagged_supported) {
-		if (sdev->host->hostt->cmd_per_lun)
-			queue_depth = sdev->host->hostt->cmd_per_lun;
-		else
-			queue_depth = FC_FCP_DFLT_QUEUE_DEPTH;
-		scsi_activate_tcq(sdev, queue_depth);
-	}
+	if (sdev->tagged_supported)
+		scsi_activate_tcq(sdev, FC_FCP_DFLT_QUEUE_DEPTH);
+	else
+		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev),
+					FC_FCP_DFLT_QUEUE_DEPTH);
+
 	return 0;
 }
 EXPORT_SYMBOL(fc_slave_alloc);
diff -Nur linux-2.6.32-orig/drivers/scsi/libfc/fc_lport.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/libfc/fc_lport.c
--- linux-2.6.32-orig/drivers/scsi/libfc/fc_lport.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/libfc/fc_lport.c	2010-11-18 21:05:30.000000000 +0600
@@ -329,7 +329,7 @@
  * @sp: current sequence in the RLIR exchange
  * @fp: RLIR request frame
  *
- * Locking Note: The lport lock is exected to be held before calling
+ * Locking Note: The lport lock is expected to be held before calling
  * this function.
  */
 static void fc_lport_recv_rlir_req(struct fc_seq *sp, struct fc_frame *fp,
@@ -348,7 +348,7 @@
  * @sp: current sequence in the ECHO exchange
  * @fp: ECHO request frame
  *
- * Locking Note: The lport lock is exected to be held before calling
+ * Locking Note: The lport lock is expected to be held before calling
  * this function.
  */
 static void fc_lport_recv_echo_req(struct fc_seq *sp, struct fc_frame *in_fp,
@@ -361,7 +361,7 @@
 	void *dp;
 	u32 f_ctl;
 
-	FC_LPORT_DBG(lport, "Received RLIR request while in state %s\n",
+	FC_LPORT_DBG(lport, "Received ECHO request while in state %s\n",
 		     fc_lport_state(lport));
 
 	len = fr_len(in_fp) - sizeof(struct fc_frame_header);
@@ -374,7 +374,7 @@
 	if (fp) {
 		dp = fc_frame_payload_get(fp, len);
 		memcpy(dp, pp, len);
-		*((u32 *)dp) = htonl(ELS_LS_ACC << 24);
+		*((__be32 *)dp) = htonl(ELS_LS_ACC << 24);
 		sp = lport->tt.seq_start_next(sp);
 		f_ctl = FC_FC_EX_CTX | FC_FC_LAST_SEQ | FC_FC_END_SEQ;
 		fc_fill_fc_hdr(fp, FC_RCTL_ELS_REP, ep->did, ep->sid,
@@ -385,12 +385,12 @@
 }
 
 /**
- * fc_lport_recv_echo_req() - Handle received Request Node ID data request
- * @lport: Fibre Channel local port recieving the RNID
- * @sp: current sequence in the RNID exchange
- * @fp: RNID request frame
+ * fc_lport_recv_rnid_req() - Handle received Request Node ID data request
+ * @sp:	   The sequence in the RNID exchange
+ * @fp:	   The RNID request frame
+ * @lport: The local port recieving the RNID
  *
- * Locking Note: The lport lock is exected to be held before calling
+ * Locking Note: The lport lock is expected to be held before calling
  * this function.
  */
 static void fc_lport_recv_rnid_req(struct fc_seq *sp, struct fc_frame *in_fp,
@@ -667,7 +667,7 @@
  * Accept it with the common service parameters indicating our N port.
  * Set up to do a PLOGI if we have the higher-number WWPN.
  *
- * Locking Note: The lport lock is exected to be held before calling
+ * Locking Note: The lport lock is expected to be held before calling
  * this function.
  */
 static void fc_lport_recv_flogi_req(struct fc_seq *sp_in,
@@ -1115,7 +1115,7 @@
 
 	if (!lport->tt.elsct_send(lport, FC_FID_FCTRL, fp, ELS_SCR,
 				  fc_lport_scr_resp, lport, lport->e_d_tov))
-		fc_lport_error(lport, fp);
+		fc_lport_error(lport, NULL);
 }
 
 /**
@@ -1186,7 +1186,7 @@
 	if (!lport->tt.elsct_send(lport, FC_FID_DIR_SERV, fp, FC_NS_RPN_ID,
 				  fc_lport_rpn_id_resp,
 				  lport, lport->e_d_tov))
-		fc_lport_error(lport, fp);
+		fc_lport_error(lport, NULL);
 }
 
 static struct fc_rport_operations fc_lport_rport_ops = {
@@ -1237,10 +1237,13 @@
 
 	switch (lport->state) {
 	case LPORT_ST_DISABLED:
+		WARN_ON(1);
+		break;
 	case LPORT_ST_READY:
-	case LPORT_ST_RESET:
 		WARN_ON(1);
 		break;
+	case LPORT_ST_RESET:
+		break;
 	case LPORT_ST_FLOGI:
 		fc_lport_enter_flogi(lport);
 		break;
@@ -1337,7 +1340,7 @@
 
 	if (!lport->tt.elsct_send(lport, FC_FID_FLOGI, fp, ELS_LOGO,
 				  fc_lport_logo_resp, lport, lport->e_d_tov))
-		fc_lport_error(lport, fp);
+		fc_lport_error(lport, NULL);
 }
 
 /**
@@ -1453,7 +1456,7 @@
 
 	if (!lport->tt.elsct_send(lport, FC_FID_FLOGI, fp, ELS_FLOGI,
 				  fc_lport_flogi_resp, lport, lport->e_d_tov))
-		fc_lport_error(lport, fp);
+		fc_lport_error(lport, NULL);
 }
 
 /* Configure a fc_lport */
diff -Nur linux-2.6.32-orig/drivers/scsi/libfc/fc_rport.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/libfc/fc_rport.c
--- linux-2.6.32-orig/drivers/scsi/libfc/fc_rport.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/libfc/fc_rport.c	2010-11-18 21:05:30.000000000 +0600
@@ -86,6 +86,7 @@
 	[RPORT_ST_LOGO] = "LOGO",
 	[RPORT_ST_ADISC] = "ADISC",
 	[RPORT_ST_DELETE] = "Delete",
+	[RPORT_ST_RESTART] = "Restart",
 };
 
 /**
@@ -99,8 +100,7 @@
 	struct fc_rport_priv *rdata;
 
 	list_for_each_entry(rdata, &lport->disc.rports, peers)
-		if (rdata->ids.port_id == port_id &&
-		    rdata->rp_state != RPORT_ST_DELETE)
+		if (rdata->ids.port_id == port_id)
 			return rdata;
 	return NULL;
 }
@@ -235,6 +235,7 @@
 	struct fc_rport_operations *rport_ops;
 	struct fc_rport_identifiers ids;
 	struct fc_rport *rport;
+	int restart = 0;
 
 	mutex_lock(&rdata->rp_mutex);
 	event = rdata->event;
@@ -287,8 +288,20 @@
 		mutex_unlock(&rdata->rp_mutex);
 
 		if (port_id != FC_FID_DIR_SERV) {
+			/*
+			 * We must drop rp_mutex before taking disc_mutex.
+			 * Re-evaluate state to allow for restart.
+			 * A transition to RESTART state must only happen
+			 * while disc_mutex is held and rdata is on the list.
+			 */
 			mutex_lock(&lport->disc.disc_mutex);
-			list_del(&rdata->peers);
+			mutex_lock(&rdata->rp_mutex);
+			if (rdata->rp_state == RPORT_ST_RESTART)
+				restart = 1;
+			else
+				list_del(&rdata->peers);
+			rdata->event = RPORT_EV_NONE;
+			mutex_unlock(&rdata->rp_mutex);
 			mutex_unlock(&lport->disc.disc_mutex);
 		}
 
@@ -312,7 +325,13 @@
 			mutex_unlock(&rdata->rp_mutex);
 			fc_remote_port_delete(rport);
 		}
-		kref_put(&rdata->kref, lport->tt.rport_destroy);
+		if (restart) {
+			mutex_lock(&rdata->rp_mutex);
+			FC_RPORT_DBG(rdata, "work restart\n");
+			fc_rport_enter_plogi(rdata);
+			mutex_unlock(&rdata->rp_mutex);
+		} else
+			kref_put(&rdata->kref, lport->tt.rport_destroy);
 		break;
 
 	default:
@@ -342,6 +361,12 @@
 		FC_RPORT_DBG(rdata, "ADISC port\n");
 		fc_rport_enter_adisc(rdata);
 		break;
+	case RPORT_ST_RESTART:
+		break;
+	case RPORT_ST_DELETE:
+		FC_RPORT_DBG(rdata, "Restart deleted port\n");
+		fc_rport_state_enter(rdata, RPORT_ST_RESTART);
+		break;
 	default:
 		FC_RPORT_DBG(rdata, "Login to port\n");
 		fc_rport_enter_plogi(rdata);
@@ -397,20 +422,21 @@
 
 	if (rdata->rp_state == RPORT_ST_DELETE) {
 		FC_RPORT_DBG(rdata, "Port in Delete state, not removing\n");
-		mutex_unlock(&rdata->rp_mutex);
 		goto out;
 	}
 
-	fc_rport_enter_logo(rdata);
+	if (rdata->rp_state == RPORT_ST_RESTART)
+		FC_RPORT_DBG(rdata, "Port in Restart state, deleting\n");
+	else
+		fc_rport_enter_logo(rdata);
 
 	/*
 	 * Change the state to Delete so that we discard
 	 * the response.
 	 */
 	fc_rport_enter_delete(rdata, RPORT_EV_STOP);
-	mutex_unlock(&rdata->rp_mutex);
-
 out:
+	mutex_unlock(&rdata->rp_mutex);
 	return 0;
 }
 
@@ -466,6 +492,7 @@
 	case RPORT_ST_READY:
 	case RPORT_ST_INIT:
 	case RPORT_ST_DELETE:
+	case RPORT_ST_RESTART:
 		break;
 	}
 
@@ -499,6 +526,7 @@
 		fc_rport_enter_logo(rdata);
 		break;
 	case RPORT_ST_DELETE:
+	case RPORT_ST_RESTART:
 	case RPORT_ST_READY:
 	case RPORT_ST_INIT:
 		break;
@@ -632,7 +660,7 @@
 
 	if (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_PLOGI,
 				  fc_rport_plogi_resp, rdata, lport->e_d_tov))
-		fc_rport_error_retry(rdata, fp);
+		fc_rport_error_retry(rdata, NULL);
 	else
 		kref_get(&rdata->kref);
 }
@@ -793,7 +821,7 @@
 
 	if (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_PRLI,
 				  fc_rport_prli_resp, rdata, lport->e_d_tov))
-		fc_rport_error_retry(rdata, fp);
+		fc_rport_error_retry(rdata, NULL);
 	else
 		kref_get(&rdata->kref);
 }
@@ -889,7 +917,7 @@
 
 	if (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_RTV,
 				     fc_rport_rtv_resp, rdata, lport->e_d_tov))
-		fc_rport_error_retry(rdata, fp);
+		fc_rport_error_retry(rdata, NULL);
 	else
 		kref_get(&rdata->kref);
 }
@@ -919,7 +947,7 @@
 
 	if (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_LOGO,
 				  fc_rport_logo_resp, rdata, lport->e_d_tov))
-		fc_rport_error_retry(rdata, fp);
+		fc_rport_error_retry(rdata, NULL);
 	else
 		kref_get(&rdata->kref);
 }
@@ -1006,7 +1034,7 @@
 	}
 	if (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_ADISC,
 				  fc_rport_adisc_resp, rdata, lport->e_d_tov))
-		fc_rport_error_retry(rdata, fp);
+		fc_rport_error_retry(rdata, NULL);
 	else
 		kref_get(&rdata->kref);
 }
@@ -1248,6 +1276,7 @@
 		}
 		break;
 	case RPORT_ST_PRLI:
+	case RPORT_ST_RTV:
 	case RPORT_ST_READY:
 	case RPORT_ST_ADISC:
 		FC_RPORT_DBG(rdata, "Received PLOGI in logged-in state %d "
@@ -1255,11 +1284,14 @@
 		/* XXX TBD - should reset */
 		break;
 	case RPORT_ST_DELETE:
-	default:
-		FC_RPORT_DBG(rdata, "Received PLOGI in unexpected state %d\n",
-			     rdata->rp_state);
-		fc_frame_free(rx_fp);
-		goto out;
+	case RPORT_ST_LOGO:
+	case RPORT_ST_RESTART:
+		FC_RPORT_DBG(rdata, "Received PLOGI in state %s - send busy\n",
+			     fc_rport_state(rdata));
+		mutex_unlock(&rdata->rp_mutex);
+		rjt_data.reason = ELS_RJT_BUSY;
+		rjt_data.explan = ELS_EXPL_NONE;
+		goto reject;
 	}
 
 	/*
@@ -1402,7 +1434,7 @@
 				break;
 			case FC_TYPE_FCP:
 				fcp_parm = ntohl(rspp->spp_params);
-				if (fcp_parm * FCP_SPPF_RETRY)
+				if (fcp_parm & FCP_SPPF_RETRY)
 					rdata->flags |= FC_RP_FLAGS_RETRY;
 				rdata->supported_classes = FC_COS_CLASS3;
 				if (fcp_parm & FCP_SPPF_INIT_FCN)
@@ -1510,14 +1542,14 @@
 		FC_RPORT_DBG(rdata, "Received LOGO request while in state %s\n",
 			     fc_rport_state(rdata));
 
+		fc_rport_enter_delete(rdata, RPORT_EV_LOGO);
+
 		/*
-		 * If the remote port was created due to discovery,
-		 * log back in.  It may have seen a stale RSCN about us.
+		 * If the remote port was created due to discovery, set state
+		 * to log back in.  It may have seen a stale RSCN about us.
 		 */
-		if (rdata->rp_state != RPORT_ST_DELETE && rdata->disc_id)
-			fc_rport_enter_plogi(rdata);
-		else
-			fc_rport_enter_delete(rdata, RPORT_EV_LOGO);
+		if (rdata->disc_id)
+			fc_rport_state_enter(rdata, RPORT_ST_RESTART);
 		mutex_unlock(&rdata->rp_mutex);
 	} else
 		FC_RPORT_ID_DBG(lport, sid,
diff -Nur linux-2.6.32-orig/drivers/scsi/lpfc/lpfc_init.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/lpfc/lpfc_init.c
--- linux-2.6.32-orig/drivers/scsi/lpfc/lpfc_init.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/lpfc/lpfc_init.c	2010-11-18 21:05:30.000000000 +0600
@@ -2408,7 +2408,7 @@
 	vport->els_tmofunc.function = lpfc_els_timeout;
 	vport->els_tmofunc.data = (unsigned long)vport;
 
-	error = scsi_add_host(shost, dev);
+	error = scsi_add_host_with_dma(shost, dev, &phba->pcidev->dev);
 	if (error)
 		goto out_put_shost;
 
@@ -4384,9 +4384,13 @@
 		pdev = phba->pcidev;
 
 	/* Set the device DMA mask size */
-	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) != 0)
-		if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0)
+	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) != 0
+	 || pci_set_consistent_dma_mask(pdev,DMA_BIT_MASK(64)) != 0) {
+		if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0
+		 || pci_set_consistent_dma_mask(pdev,DMA_BIT_MASK(32)) != 0) {
 			return error;
+		}
+	}
 
 	/* Get the bus address of Bar0 and Bar2 and the number of bytes
 	 * required by each mapping.
@@ -5940,9 +5944,13 @@
 		pdev = phba->pcidev;
 
 	/* Set the device DMA mask size */
-	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) != 0)
-		if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0)
+	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) != 0
+	 || pci_set_consistent_dma_mask(pdev,DMA_BIT_MASK(64)) != 0) {
+		if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0
+		 || pci_set_consistent_dma_mask(pdev,DMA_BIT_MASK(32)) != 0) {
 			return error;
+		}
+	}
 
 	/* Get the bus address of SLI4 device Bar0, Bar1, and Bar2 and the
 	 * number of bytes required by each mapping. They are actually
diff -Nur linux-2.6.32-orig/drivers/scsi/megaraid/megaraid_sas.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/megaraid/megaraid_sas.c
--- linux-2.6.32-orig/drivers/scsi/megaraid/megaraid_sas.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/megaraid/megaraid_sas.c	2010-11-18 21:05:30.000000000 +0600
@@ -3032,7 +3032,7 @@
 	int error = 0, i;
 	void *sense = NULL;
 	dma_addr_t sense_handle;
-	u32 *sense_ptr;
+	unsigned long *sense_ptr;
 
 	memset(kbuff_arr, 0, sizeof(kbuff_arr));
 
@@ -3109,7 +3109,7 @@
 		}
 
 		sense_ptr =
-		    (u32 *) ((unsigned long)cmd->frame + ioc->sense_off);
+		(unsigned long *) ((unsigned long)cmd->frame + ioc->sense_off);
 		*sense_ptr = sense_handle;
 	}
 
@@ -3140,8 +3140,8 @@
 		 * sense_ptr points to the location that has the user
 		 * sense buffer address
 		 */
-		sense_ptr = (u32 *) ((unsigned long)ioc->frame.raw +
-				     ioc->sense_off);
+		sense_ptr = (unsigned long *) ((unsigned long)ioc->frame.raw +
+				ioc->sense_off);
 
 		if (copy_to_user((void __user *)((unsigned long)(*sense_ptr)),
 				 sense, ioc->sense_len)) {
@@ -3451,7 +3451,7 @@
 	return retval;
 }
 
-static DRIVER_ATTR(poll_mode_io, S_IRUGO|S_IWUGO,
+static DRIVER_ATTR(poll_mode_io, S_IRUGO|S_IWUSR,
 		megasas_sysfs_show_poll_mode_io,
 		megasas_sysfs_set_poll_mode_io);
 
diff -Nur linux-2.6.32-orig/drivers/scsi/mpt2sas/mpi/mpi2_cnfg.h iDroid-Project-kernel_common-9e90fd2/drivers/scsi/mpt2sas/mpi/mpi2_cnfg.h
--- linux-2.6.32-orig/drivers/scsi/mpt2sas/mpi/mpi2_cnfg.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/mpt2sas/mpi/mpi2_cnfg.h	2010-11-18 21:05:30.000000000 +0600
@@ -348,6 +348,14 @@
 #define MPI2_MFGPAGE_DEVID_SAS2108_3                (0x0077)
 #define MPI2_MFGPAGE_DEVID_SAS2116_1                (0x0064)
 #define MPI2_MFGPAGE_DEVID_SAS2116_2                (0x0065)
+#define MPI2_MFGPAGE_DEVID_SAS2208_1                (0x0080)
+#define MPI2_MFGPAGE_DEVID_SAS2208_2                (0x0081)
+#define MPI2_MFGPAGE_DEVID_SAS2208_3                (0x0082)
+#define MPI2_MFGPAGE_DEVID_SAS2208_4                (0x0083)
+#define MPI2_MFGPAGE_DEVID_SAS2208_5                (0x0084)
+#define MPI2_MFGPAGE_DEVID_SAS2208_6                (0x0085)
+#define MPI2_MFGPAGE_DEVID_SAS2208_7                (0x0086)
+#define MPI2_MFGPAGE_DEVID_SAS2208_8                (0x0087)
 
 
 /* Manufacturing Page 0 */
diff -Nur linux-2.6.32-orig/drivers/scsi/mpt2sas/mpt2sas_scsih.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/mpt2sas/mpt2sas_scsih.c
--- linux-2.6.32-orig/drivers/scsi/mpt2sas/mpt2sas_scsih.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/mpt2sas/mpt2sas_scsih.c	2010-11-18 21:05:30.000000000 +0600
@@ -196,10 +196,28 @@
 		PCI_ANY_ID, PCI_ANY_ID },
 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2108_3,
 		PCI_ANY_ID, PCI_ANY_ID },
+	/* Meteor ~ 2116 */
 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2116_1,
 		PCI_ANY_ID, PCI_ANY_ID },
 	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2116_2,
 		PCI_ANY_ID, PCI_ANY_ID },
+	/* Thunderbolt ~ 2208 */
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_1,
+		PCI_ANY_ID, PCI_ANY_ID },
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_2,
+		PCI_ANY_ID, PCI_ANY_ID },
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_3,
+		PCI_ANY_ID, PCI_ANY_ID },
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_4,
+		PCI_ANY_ID, PCI_ANY_ID },
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_5,
+		PCI_ANY_ID, PCI_ANY_ID },
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_6,
+		PCI_ANY_ID, PCI_ANY_ID },
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_7,
+		PCI_ANY_ID, PCI_ANY_ID },
+	{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_8,
+		PCI_ANY_ID, PCI_ANY_ID },
 	{0}	/* Terminating entry */
 };
 MODULE_DEVICE_TABLE(pci, scsih_pci_table);
diff -Nur linux-2.6.32-orig/drivers/scsi/qla2xxx/qla_attr.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/qla2xxx/qla_attr.c
--- linux-2.6.32-orig/drivers/scsi/qla2xxx/qla_attr.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/qla2xxx/qla_attr.c	2010-11-18 21:05:30.000000000 +0600
@@ -1654,7 +1654,8 @@
 			fc_vport_set_state(fc_vport, FC_VPORT_LINKDOWN);
 	}
 
-	if (scsi_add_host(vha->host, &fc_vport->dev)) {
+	if (scsi_add_host_with_dma(vha->host, &fc_vport->dev,
+				   &ha->pdev->dev)) {
 		DEBUG15(printk("scsi(%ld): scsi_add_host failure for VP[%d].\n",
 			vha->host_no, vha->vp_idx));
 		goto vport_create_failed_2;
diff -Nur linux-2.6.32-orig/drivers/scsi/qla2xxx/qla_os.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/qla2xxx/qla_os.c
--- linux-2.6.32-orig/drivers/scsi/qla2xxx/qla_os.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/qla2xxx/qla_os.c	2010-11-18 21:05:30.000000000 +0600
@@ -2016,13 +2016,13 @@
 	DEBUG2(printk("DEBUG: detect hba %ld at address = %p\n",
 	    base_vha->host_no, ha));
 
-	base_vha->flags.init_done = 1;
-	base_vha->flags.online = 1;
-
 	ret = scsi_add_host(host, &pdev->dev);
 	if (ret)
 		goto probe_failed;
 
+	base_vha->flags.init_done = 1;
+	base_vha->flags.online = 1;
+
 	ha->isp_ops->enable_intrs(ha);
 
 	scsi_scan_host(host);
diff -Nur linux-2.6.32-orig/drivers/scsi/scsi_devinfo.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/scsi_devinfo.c
--- linux-2.6.32-orig/drivers/scsi/scsi_devinfo.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/scsi_devinfo.c	2010-11-18 21:05:30.000000000 +0600
@@ -168,11 +168,10 @@
 	{"Generic", "USB SD Reader", "1.00", BLIST_FORCELUN | BLIST_INQUIRY_36},
 	{"Generic", "USB Storage-SMC", "0180", BLIST_FORCELUN | BLIST_INQUIRY_36},
 	{"Generic", "USB Storage-SMC", "0207", BLIST_FORCELUN | BLIST_INQUIRY_36},
-	{"HITACHI", "DF400", "*", BLIST_SPARSELUN},
-	{"HITACHI", "DF500", "*", BLIST_SPARSELUN},
-	{"HITACHI", "DF600", "*", BLIST_SPARSELUN},
-	{"HITACHI", "DISK-SUBSYSTEM", "*", BLIST_ATTACH_PQ3 | BLIST_SPARSELUN | BLIST_LARGELUN},
-	{"HITACHI", "OPEN-E", "*", BLIST_ATTACH_PQ3 | BLIST_SPARSELUN | BLIST_LARGELUN},
+	{"HITACHI", "DF400", "*", BLIST_REPORTLUN2},
+	{"HITACHI", "DF500", "*", BLIST_REPORTLUN2},
+	{"HITACHI", "DISK-SUBSYSTEM", "*", BLIST_REPORTLUN2},
+	{"HITACHI", "OPEN-", "*", BLIST_REPORTLUN2},
 	{"HITACHI", "OP-C-", "*", BLIST_SPARSELUN | BLIST_LARGELUN},
 	{"HITACHI", "3380-", "*", BLIST_SPARSELUN | BLIST_LARGELUN},
 	{"HITACHI", "3390-", "*", BLIST_SPARSELUN | BLIST_LARGELUN},
diff -Nur linux-2.6.32-orig/drivers/scsi/scsi_lib.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/scsi_lib.c
--- linux-2.6.32-orig/drivers/scsi/scsi_lib.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/scsi_lib.c	2010-11-18 21:05:30.000000000 +0600
@@ -749,9 +749,9 @@
 			 */
 			req->next_rq->resid_len = scsi_in(cmd)->resid;
 
+			scsi_release_buffers(cmd);
 			blk_end_request_all(req, 0);
 
-			scsi_release_buffers(cmd);
 			scsi_next_command(cmd);
 			return;
 		}
diff -Nur linux-2.6.32-orig/drivers/scsi/scsi_lib_dma.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/scsi_lib_dma.c
--- linux-2.6.32-orig/drivers/scsi/scsi_lib_dma.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/scsi_lib_dma.c	2010-11-18 21:05:30.000000000 +0600
@@ -23,7 +23,7 @@
 	int nseg = 0;
 
 	if (scsi_sg_count(cmd)) {
-		struct device *dev = cmd->device->host->shost_gendev.parent;
+		struct device *dev = cmd->device->host->dma_dev;
 
 		nseg = dma_map_sg(dev, scsi_sglist(cmd), scsi_sg_count(cmd),
 				  cmd->sc_data_direction);
@@ -41,7 +41,7 @@
 void scsi_dma_unmap(struct scsi_cmnd *cmd)
 {
 	if (scsi_sg_count(cmd)) {
-		struct device *dev = cmd->device->host->shost_gendev.parent;
+		struct device *dev = cmd->device->host->dma_dev;
 
 		dma_unmap_sg(dev, scsi_sglist(cmd), scsi_sg_count(cmd),
 			     cmd->sc_data_direction);
diff -Nur linux-2.6.32-orig/drivers/scsi/scsi_transport_fc.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/scsi_transport_fc.c
--- linux-2.6.32-orig/drivers/scsi/scsi_transport_fc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/scsi_transport_fc.c	2010-11-18 21:05:30.000000000 +0600
@@ -648,11 +648,22 @@
 		return error;
 	error = transport_class_register(&fc_vport_class);
 	if (error)
-		return error;
+		goto unreg_host_class;
 	error = transport_class_register(&fc_rport_class);
 	if (error)
-		return error;
-	return transport_class_register(&fc_transport_class);
+		goto unreg_vport_class;
+	error = transport_class_register(&fc_transport_class);
+	if (error)
+		goto unreg_rport_class;
+	return 0;
+
+unreg_rport_class:
+	transport_class_unregister(&fc_rport_class);
+unreg_vport_class:
+	transport_class_unregister(&fc_vport_class);
+unreg_host_class:
+	transport_class_unregister(&fc_host_class);
+	return error;
 }
 
 static void __exit fc_transport_exit(void)
@@ -2384,6 +2395,7 @@
 	struct Scsi_Host *shost = rport_to_shost(rport);
 	struct fc_internal *i = to_fc_internal(shost->transportt);
 	unsigned long flags;
+	int do_callback = 0;
 
 	/*
 	 * if a scan is pending, flush the SCSI Host work_q so that
@@ -2422,8 +2434,15 @@
 	 * Avoid this call if we already called it when we preserved the
 	 * rport for the binding.
 	 */
+	spin_lock_irqsave(shost->host_lock, flags);
 	if (!(rport->flags & FC_RPORT_DEVLOSS_CALLBK_DONE) &&
-	    (i->f->dev_loss_tmo_callbk))
+	    (i->f->dev_loss_tmo_callbk)) {
+		rport->flags |= FC_RPORT_DEVLOSS_CALLBK_DONE;
+		do_callback = 1;
+	}
+	spin_unlock_irqrestore(shost->host_lock, flags);
+
+	if (do_callback)
 		i->f->dev_loss_tmo_callbk(rport);
 
 	fc_bsg_remove(rport->rqst_q);
@@ -2970,6 +2989,7 @@
 	struct fc_internal *i = to_fc_internal(shost->transportt);
 	struct fc_host_attrs *fc_host = shost_to_fc_host(shost);
 	unsigned long flags;
+	int do_callback = 0;
 
 	spin_lock_irqsave(shost->host_lock, flags);
 
@@ -3035,7 +3055,6 @@
 	rport->roles = FC_PORT_ROLE_UNKNOWN;
 	rport->port_state = FC_PORTSTATE_NOTPRESENT;
 	rport->flags &= ~FC_RPORT_FAST_FAIL_TIMEDOUT;
-	rport->flags |= FC_RPORT_DEVLOSS_CALLBK_DONE;
 
 	/*
 	 * Pre-emptively kill I/O rather than waiting for the work queue
@@ -3045,32 +3064,40 @@
 	spin_unlock_irqrestore(shost->host_lock, flags);
 	fc_terminate_rport_io(rport);
 
-	BUG_ON(rport->port_state != FC_PORTSTATE_NOTPRESENT);
+	spin_lock_irqsave(shost->host_lock, flags);
 
-	/* remove the identifiers that aren't used in the consisting binding */
-	switch (fc_host->tgtid_bind_type) {
-	case FC_TGTID_BIND_BY_WWPN:
-		rport->node_name = -1;
-		rport->port_id = -1;
-		break;
-	case FC_TGTID_BIND_BY_WWNN:
-		rport->port_name = -1;
-		rport->port_id = -1;
-		break;
-	case FC_TGTID_BIND_BY_ID:
-		rport->node_name = -1;
-		rport->port_name = -1;
-		break;
-	case FC_TGTID_BIND_NONE:	/* to keep compiler happy */
-		break;
+	if (rport->port_state == FC_PORTSTATE_NOTPRESENT) {	/* still missing */
+
+		/* remove the identifiers that aren't used in the consisting binding */
+		switch (fc_host->tgtid_bind_type) {
+		case FC_TGTID_BIND_BY_WWPN:
+			rport->node_name = -1;
+			rport->port_id = -1;
+			break;
+		case FC_TGTID_BIND_BY_WWNN:
+			rport->port_name = -1;
+			rport->port_id = -1;
+			break;
+		case FC_TGTID_BIND_BY_ID:
+			rport->node_name = -1;
+			rport->port_name = -1;
+			break;
+		case FC_TGTID_BIND_NONE:	/* to keep compiler happy */
+			break;
+		}
+
+		/*
+		 * As this only occurs if the remote port (scsi target)
+		 * went away and didn't come back - we'll remove
+		 * all attached scsi devices.
+		 */
+		rport->flags |= FC_RPORT_DEVLOSS_CALLBK_DONE;
+		fc_queue_work(shost, &rport->stgt_delete_work);
+
+		do_callback = 1;
 	}
 
-	/*
-	 * As this only occurs if the remote port (scsi target)
-	 * went away and didn't come back - we'll remove
-	 * all attached scsi devices.
-	 */
-	fc_queue_work(shost, &rport->stgt_delete_work);
+	spin_unlock_irqrestore(shost->host_lock, flags);
 
 	/*
 	 * Notify the driver that the rport is now dead. The LLDD will
@@ -3078,7 +3105,7 @@
 	 *
 	 * Note: we set the CALLBK_DONE flag above to correspond
 	 */
-	if (i->f->dev_loss_tmo_callbk)
+	if (do_callback && i->f->dev_loss_tmo_callbk)
 		i->f->dev_loss_tmo_callbk(rport);
 }
 
diff -Nur linux-2.6.32-orig/drivers/scsi/scsi_transport_iscsi.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/scsi_transport_iscsi.c
--- linux-2.6.32-orig/drivers/scsi/scsi_transport_iscsi.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/scsi_transport_iscsi.c	2010-11-18 21:05:30.000000000 +0600
@@ -627,8 +627,10 @@
 	spin_unlock_irqrestore(&session->lock, flags);
 	scsi_target_block(&session->dev);
 	ISCSI_DBG_TRANS_SESSION(session, "Completed SCSI target blocking\n");
-	queue_delayed_work(iscsi_eh_timer_workq, &session->recovery_work,
-			   session->recovery_tmo * HZ);
+	if (session->recovery_tmo >= 0)
+		queue_delayed_work(iscsi_eh_timer_workq,
+				   &session->recovery_work,
+				   session->recovery_tmo * HZ);
 }
 
 void iscsi_block_session(struct iscsi_cls_session *session)
@@ -1348,8 +1350,7 @@
 	switch (ev->u.set_param.param) {
 	case ISCSI_PARAM_SESS_RECOVERY_TMO:
 		sscanf(data, "%d", &value);
-		if (value != 0)
-			session->recovery_tmo = value;
+		session->recovery_tmo = value;
 		break;
 	default:
 		err = transport->set_param(conn, ev->u.set_param.param,
diff -Nur linux-2.6.32-orig/drivers/scsi/st.c iDroid-Project-kernel_common-9e90fd2/drivers/scsi/st.c
--- linux-2.6.32-orig/drivers/scsi/st.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/st.c	2010-11-18 21:05:30.000000000 +0600
@@ -552,13 +552,15 @@
 	SRpnt->waiting = waiting;
 
 	if (STp->buffer->do_dio) {
+		mdata->page_order = 0;
 		mdata->nr_entries = STp->buffer->sg_segs;
 		mdata->pages = STp->buffer->mapped_pages;
 	} else {
+		mdata->page_order = STp->buffer->reserved_page_order;
 		mdata->nr_entries =
 			DIV_ROUND_UP(bytes, PAGE_SIZE << mdata->page_order);
-		STp->buffer->map_data.pages = STp->buffer->reserved_pages;
-		STp->buffer->map_data.offset = 0;
+		mdata->pages = STp->buffer->reserved_pages;
+		mdata->offset = 0;
 	}
 
 	memcpy(SRpnt->cmd, cmd, sizeof(SRpnt->cmd));
@@ -3718,7 +3720,7 @@
 		priority |= __GFP_ZERO;
 
 	if (STbuffer->frp_segs) {
-		order = STbuffer->map_data.page_order;
+		order = STbuffer->reserved_page_order;
 		b_size = PAGE_SIZE << order;
 	} else {
 		for (b_size = PAGE_SIZE, order = 0;
@@ -3751,7 +3753,7 @@
 		segs++;
 	}
 	STbuffer->b_data = page_address(STbuffer->reserved_pages[0]);
-	STbuffer->map_data.page_order = order;
+	STbuffer->reserved_page_order = order;
 
 	return 1;
 }
@@ -3764,7 +3766,7 @@
 
 	for (i=0; i < st_bp->frp_segs; i++)
 		memset(page_address(st_bp->reserved_pages[i]), 0,
-		       PAGE_SIZE << st_bp->map_data.page_order);
+		       PAGE_SIZE << st_bp->reserved_page_order);
 	st_bp->cleared = 1;
 }
 
@@ -3772,7 +3774,7 @@
 /* Release the extra buffer */
 static void normalize_buffer(struct st_buffer * STbuffer)
 {
-	int i, order = STbuffer->map_data.page_order;
+	int i, order = STbuffer->reserved_page_order;
 
 	for (i = 0; i < STbuffer->frp_segs; i++) {
 		__free_pages(STbuffer->reserved_pages[i], order);
@@ -3780,7 +3782,7 @@
 	}
 	STbuffer->frp_segs = 0;
 	STbuffer->sg_segs = 0;
-	STbuffer->map_data.page_order = 0;
+	STbuffer->reserved_page_order = 0;
 	STbuffer->map_data.offset = 0;
 }
 
@@ -3790,7 +3792,7 @@
 static int append_to_buffer(const char __user *ubp, struct st_buffer * st_bp, int do_count)
 {
 	int i, cnt, res, offset;
-	int length = PAGE_SIZE << st_bp->map_data.page_order;
+	int length = PAGE_SIZE << st_bp->reserved_page_order;
 
 	for (i = 0, offset = st_bp->buffer_bytes;
 	     i < st_bp->frp_segs && offset >= length; i++)
@@ -3822,7 +3824,7 @@
 static int from_buffer(struct st_buffer * st_bp, char __user *ubp, int do_count)
 {
 	int i, cnt, res, offset;
-	int length = PAGE_SIZE << st_bp->map_data.page_order;
+	int length = PAGE_SIZE << st_bp->reserved_page_order;
 
 	for (i = 0, offset = st_bp->read_pointer;
 	     i < st_bp->frp_segs && offset >= length; i++)
@@ -3855,7 +3857,7 @@
 {
 	int src_seg, dst_seg, src_offset = 0, dst_offset;
 	int count, total;
-	int length = PAGE_SIZE << st_bp->map_data.page_order;
+	int length = PAGE_SIZE << st_bp->reserved_page_order;
 
 	if (offset == 0)
 		return;
@@ -4577,7 +4579,6 @@
         }
 
 	mdata->offset = uaddr & ~PAGE_MASK;
-	mdata->page_order = 0;
 	STbp->mapped_pages = pages;
 
 	return nr_pages;
diff -Nur linux-2.6.32-orig/drivers/scsi/st.h iDroid-Project-kernel_common-9e90fd2/drivers/scsi/st.h
--- linux-2.6.32-orig/drivers/scsi/st.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/scsi/st.h	2010-11-18 21:05:30.000000000 +0600
@@ -46,6 +46,7 @@
 	struct st_request *last_SRpnt;
 	struct st_cmdstatus cmdstat;
 	struct page **reserved_pages;
+	int reserved_page_order;
 	struct page **mapped_pages;
 	struct rq_map_data map_data;
 	unsigned char *b_data;
diff -Nur linux-2.6.32-orig/drivers/serial/8250.c iDroid-Project-kernel_common-9e90fd2/drivers/serial/8250.c
--- linux-2.6.32-orig/drivers/serial/8250.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/serial/8250.c	2010-11-18 21:05:30.000000000 +0600
@@ -83,6 +83,9 @@
 
 #define PASS_LIMIT	256
 
+#define BOTH_EMPTY 	(UART_LSR_TEMT | UART_LSR_THRE)
+
+
 /*
  * We default to IRQ0 for the "no irq" hack.   Some
  * machine types want others as well - they're free
@@ -1339,14 +1342,12 @@
 		serial_out(up, UART_IER, up->ier);
 
 		if (up->bugs & UART_BUG_TXEN) {
-			unsigned char lsr, iir;
+			unsigned char lsr;
 			lsr = serial_in(up, UART_LSR);
 			up->lsr_saved_flags |= lsr & LSR_SAVE_FLAGS;
-			iir = serial_in(up, UART_IIR) & 0x0f;
 			if ((up->port.type == PORT_RM9000) ?
-				(lsr & UART_LSR_THRE &&
-				(iir == UART_IIR_NO_INT || iir == UART_IIR_THRI)) :
-				(lsr & UART_LSR_TEMT && iir & UART_IIR_NO_INT))
+				(lsr & UART_LSR_THRE) :
+				(lsr & UART_LSR_TEMT))
 				transmit_chars(up);
 		}
 	}
@@ -1794,7 +1795,7 @@
 	up->lsr_saved_flags |= lsr & LSR_SAVE_FLAGS;
 	spin_unlock_irqrestore(&up->port.lock, flags);
 
-	return lsr & UART_LSR_TEMT ? TIOCSER_TEMT : 0;
+	return (lsr & BOTH_EMPTY) == BOTH_EMPTY ? TIOCSER_TEMT : 0;
 }
 
 static unsigned int serial8250_get_mctrl(struct uart_port *port)
@@ -1852,8 +1853,6 @@
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
 
-#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
-
 /*
  *	Wait for transmitter & holding register to empty
  */
diff -Nur linux-2.6.32-orig/drivers/serial/8250_pnp.c iDroid-Project-kernel_common-9e90fd2/drivers/serial/8250_pnp.c
--- linux-2.6.32-orig/drivers/serial/8250_pnp.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/serial/8250_pnp.c	2010-11-18 21:05:30.000000000 +0600
@@ -328,15 +328,7 @@
 	/* U.S. Robotics 56K Voice INT PnP*/
 	{	"USR9190",		0	},
 	/* Wacom tablets */
-	{	"WACF004",		0	},
-	{	"WACF005",		0	},
-	{       "WACF006",              0       },
-	{       "WACF007",              0       },
-	{       "WACF008",              0       },
-	{       "WACF009",              0       },
-	{       "WACF00A",              0       },
-	{       "WACF00B",              0       },
-	{       "WACF00C",              0       },
+	{	"WACFXXX",		0	},
 	/* Compaq touchscreen */
 	{       "FPI2002",              0 },
 	/* Fujitsu Stylistic touchscreens */
@@ -354,6 +346,8 @@
 	{	"FUJ02E5",		0	},
 	/* Fujitsu P-series tablet PC device */
 	{	"FUJ02E6",		0	},
+	/* Fujitsu Wacom 2FGT Tablet PC device */
+	{	"FUJ02E7",		0	},
 	/*
 	 * LG C1 EXPRESS DUAL (C1-PB11A3) touch screen (actually a FUJ02E6 in
 	 * disguise)
diff -Nur linux-2.6.32-orig/drivers/serial/iphone-uart.c iDroid-Project-kernel_common-9e90fd2/drivers/serial/iphone-uart.c
--- linux-2.6.32-orig/drivers/serial/iphone-uart.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/serial/iphone-uart.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,917 @@
+/*
+ *  arch/arm/mach-apple_iphone/uart.c
+ *
+ *  Copyright (C) 2008 Yiduo Wang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/io.h>
+
+#include <linux/delay.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <mach/iphone-clock.h>
+#include <mach/hardware.h>
+
+// Devices
+#define UART IO_ADDRESS(0x3CC00000)
+
+// Registers
+#define UART0 0x0
+#define UART1 0x4000
+#define UART2 0x8000
+#define UART3 0xC000
+#define UART4 0x10000
+
+#define UART_ULCON 0x0
+#define UART_UCON 0x4
+#define UART_UFCON 0x8
+#define UART_UMCON 0xC
+#define UART_UTRSTAT 0x10
+#define UART_UERSTAT 0x14
+#define UART_UFSTAT 0x18
+#define UART_UMSTAT 0x1C
+#define UART_UTXH 0x20
+#define UART_URXH 0x24
+#define UART_UBAUD 0x28
+#define UART_UDIVSLOT 0x2C
+
+// Values
+#define NUM_UARTS 5
+#define UART_CLOCKGATE 0x29
+
+#define UART_CLOCK_SELECTION_MASK (0x3 << 10) // Bit 10-11
+#define UART_CLOCK_SELECTION_SHIFT 10 // Bit 10-11
+#define UART_UCON_UNKMASK 0x7000
+#define UART_UCON_LOOPBACKMODE (0x1 << 5)
+#define UART_UCON_RXMODE_SHIFT 0
+#define UART_UCON_RXMODE_MASK (0x3 << UART_UCON_RXMODE_SHIFT)
+#define UART_UCON_TXMODE_SHIFT 2
+#define UART_UCON_TXMODE_MASK (0x3 << UART_UCON_TXMODE_SHIFT)
+
+#define UART_FIFO_RESET_TX 0x4
+#define UART_FIFO_RESET_RX 0x2
+#define UART_FIFO_ENABLE 0x1
+
+#define UART_DIVVAL_MASK 0x0000FFFF
+#define UART_SAMPLERATE_MASK 0x00030000 // Bit 16-17
+#define UART_SAMPLERATE_SHIFT 16
+
+#define UART_UCON_MODE_DISABLE 0
+#define UART_UCON_MODE_IRQORPOLL 1
+#define UART_UCON_MODE_DMA0 2
+#define UART_UCON_MODE_DMA1 3
+
+#define UART_CLOCK_PCLK 0
+#define UART_CLOCK_EXT_UCLK0 1
+#define UART_CLOCK_EXT_UCLK1 3
+
+#define UART_SAMPLERATE_4 2
+#define UART_SAMPLERATE_8 1
+#define UART_SAMPLERATE_16 0
+
+#define UART_UMCON_AFC_BIT 0x10
+#define UART_UMCON_NRTS_BIT 0x1
+
+#define UART_UTRSTAT_TRANSMITTEREMPTY 0x4
+#define UART_UTRSTAT_RECEIVEDATAREADY 0x1
+
+#define UART_UMSTAT_CTS 0x1
+
+#define UART_UFSTAT_TXFIFO_FULL (0x1 << 9)
+#define UART_UFSTAT_RXFIFO_FULL (0x1 << 8)
+#define UART_UFSTAT_RXCOUNT_MASK 0xF
+
+#define UART_UERSTAT_OVERRUN	(1<<0)
+#define UART_UERSTAT_FRAME		(1<<2)
+#define UART_UERSTAT_BREAK		(1<<3)
+#define UART_UERSTAT_PARITY		(1<<1)
+
+#define UART_5BITS 0
+#define UART_6BITS 1
+#define UART_7BITS 2
+#define UART_8BITS 3
+
+#define UART_POLL_MODE 0
+
+struct UARTSettings {
+	u32 ureg;
+	u32 baud;
+	u32 sample_rate;
+	int flow_control;
+	u32 mode;
+	u32 clock;
+};
+
+struct UARTRegisters {
+	u32 ULCON;
+	u32 UCON;
+	u32 UFCON;
+	u32 UMCON;
+
+	u32 UTRSTAT;
+	u32 UERSTAT;
+	u32 UFSTAT;
+	u32 UMSTAT;
+
+	u32 UTXH;
+	u32 URXH;
+	u32 UBAUD;
+	u32 UDIVSLOT;
+};
+
+const struct UARTRegisters HWUarts[] = {
+	{UART + UART0 + UART_ULCON, UART + UART0 + UART_UCON, UART + UART0 + UART_UFCON, 0,
+		UART + UART0 + UART_UTRSTAT, UART + UART0 + UART_UERSTAT, UART + UART0 + UART_UFSTAT,
+		0, UART + UART0 + UART_UTXH, UART + UART0 + UART_URXH, UART + UART0 + UART_UBAUD,
+		UART + UART0 + UART_UDIVSLOT},
+	{UART + UART1 + UART_ULCON, UART + UART1 + UART_UCON, UART + UART1 + UART_UFCON, UART + UART1 + UART_UMCON,
+		UART + UART1 + UART_UTRSTAT, UART + UART1 + UART_UERSTAT, UART + UART1 + UART_UFSTAT,
+		UART + UART1 + UART_UMSTAT, UART + UART1 + UART_UTXH, UART + UART1 + UART_URXH, UART + UART1 + UART_UBAUD,
+		UART + UART1 + UART_UDIVSLOT},
+	{UART + UART2 + UART_ULCON, UART + UART2 + UART_UCON, UART + UART2 + UART_UFCON, UART + UART2 + UART_UMCON,
+		UART + UART2 + UART_UTRSTAT, UART + UART2 + UART_UERSTAT, UART + UART2 + UART_UFSTAT,
+		UART + UART2 + UART_UMSTAT, UART + UART2 + UART_UTXH, UART + UART2 + UART_URXH, UART + UART2 + UART_UBAUD,
+		UART + UART2 + UART_UDIVSLOT},
+	{UART + UART3 + UART_ULCON, UART + UART3 + UART_UCON, UART + UART3 + UART_UFCON, UART + UART3 + UART_UMCON,
+		UART + UART3 + UART_UTRSTAT, UART + UART3 + UART_UERSTAT, UART + UART3 + UART_UFSTAT,
+		UART + UART3 + UART_UMSTAT, UART + UART3 + UART_UTXH, UART + UART3 + UART_URXH, UART + UART3 + UART_UBAUD,
+		UART + UART3 + UART_UDIVSLOT},
+	{UART + UART4 + UART_ULCON, UART + UART4 + UART_UCON, UART + UART4 + UART_UFCON, UART + UART4 + UART_UMCON,
+		UART + UART4 + UART_UTRSTAT, UART + UART4 + UART_UERSTAT, UART + UART4 + UART_UFSTAT,
+		UART + UART4 + UART_UMSTAT, UART + UART4 + UART_UTXH, UART + UART4 + UART_URXH, UART + UART4 + UART_UBAUD,
+		UART + UART4 + UART_UDIVSLOT}};
+
+static struct UARTSettings UARTs[5];
+
+struct iphone_uart_info
+{
+	struct uart_port port;
+	int ureg;
+	int tx_enabled;
+	int rx_enabled;
+};
+
+static void iphone_uart_stop_tx(struct uart_port *port);
+
+static int iphone_uart_set_baud_rate(int ureg, u32 baud)
+{
+	u32 clockFrequency;
+	u32 div_val;
+
+	if(ureg > 4)
+		return -1; // Invalid ureg
+
+	if(UARTs[ureg].sample_rate == 0 || baud == 0)
+		return -1;
+
+	//u32 clockFrequency = (UARTs[ureg].clock == UART_CLOCK_PCLK) ? PeripheralFrequency : FixedFrequency;
+	// FIXME: Hardwired to fixed frequency
+	clockFrequency = FREQUENCY_FIXED;
+	div_val = clockFrequency / (baud * UARTs[ureg].sample_rate) - 1;
+
+	__raw_writel((__raw_readl(HWUarts[ureg].UBAUD) & (~UART_DIVVAL_MASK)) | div_val, HWUarts[ureg].UBAUD);
+
+	// vanilla iBoot also does a reverse calculation from div_val and solves for baud and reports
+	// the "actual" baud rate, or what is after loss during integer division
+
+	UARTs[ureg].baud = baud;
+
+	return 0;
+}
+
+static int iphone_uart_set_clk(int ureg, int clock) {
+	if(ureg > 4)
+		return -1; // Invalid ureg
+
+	if(clock != UART_CLOCK_PCLK && clock != UART_CLOCK_EXT_UCLK0 && clock != UART_CLOCK_EXT_UCLK1) {
+		return -1; // Invalid clock
+	}
+
+	__raw_writel((__raw_readl(HWUarts[ureg].UCON) & (~UART_CLOCK_SELECTION_MASK)) | (clock << UART_CLOCK_SELECTION_SHIFT), HWUarts[ureg].UCON);
+
+	UARTs[ureg].clock = clock;
+	iphone_uart_set_baud_rate(ureg, UARTs[ureg].baud);
+
+	return 0;
+}
+
+static int iphone_uart_set_sample_rate(int ureg, int rate) {
+	u32 newSampleRate;
+
+	if(ureg > 4)
+		return -1; // Invalid ureg
+
+	switch(rate) {
+		case 4:
+			newSampleRate = UART_SAMPLERATE_4;
+			break;
+		case 8:
+			newSampleRate = UART_SAMPLERATE_8;
+			break;
+		case 16:
+			newSampleRate = UART_SAMPLERATE_16;
+			break;
+		default:
+			return -1; // Invalid sample rate
+	}
+
+	__raw_writel((__raw_readl(HWUarts[ureg].UBAUD) & (~UART_SAMPLERATE_MASK)) | (newSampleRate << UART_SAMPLERATE_SHIFT), HWUarts[ureg].UBAUD);
+
+	UARTs[ureg].sample_rate = rate;
+	iphone_uart_set_baud_rate(ureg, UARTs[ureg].baud);
+
+	return 0;
+}
+
+static int iphone_uart_set_flow_control(int ureg, int flow_control) {
+	if(ureg > 4)
+		return -1; // Invalid ureg
+
+	if(flow_control == 1) {
+		if(ureg == 0)
+			return -1; // uart0 does not support flow control
+
+		__raw_writel(UART_UMCON_AFC_BIT, HWUarts[ureg].UMCON);
+	} else {
+		if(ureg != 0) {
+			__raw_writel(UART_UMCON_NRTS_BIT, HWUarts[ureg].UMCON);
+		}
+	}
+
+	UARTs[ureg].flow_control = flow_control;
+
+	return 0;
+}
+
+static int iphone_uart_set_mode(int ureg, u32 mode) {
+	if(ureg > 4)
+		return -1; // Invalid ureg
+
+	UARTs[ureg].mode = mode;
+
+	if(mode == UART_POLL_MODE) {
+		// Setup some defaults, like no loopback mode
+		__raw_writel(__raw_readl(HWUarts[ureg].UCON) & (~UART_UCON_UNKMASK) & (~UART_UCON_UNKMASK) & (~UART_UCON_LOOPBACKMODE), HWUarts[ureg].UCON);
+
+		// Use polling mode
+		__raw_writel((__raw_readl(HWUarts[ureg].UCON) & (~UART_UCON_RXMODE_MASK) & (~UART_UCON_TXMODE_MASK))
+			| (UART_UCON_MODE_IRQORPOLL << UART_UCON_RXMODE_SHIFT)
+			| (UART_UCON_MODE_IRQORPOLL << UART_UCON_TXMODE_SHIFT), HWUarts[ureg].UCON);
+	}
+
+	return 0;
+}
+
+static int iphone_uart_set_bits(int ureg, int bits) {
+	if(ureg > 4)
+		return -1; // Invalid ureg
+
+	switch(bits) {
+		case 8:
+			__raw_writel(UART_8BITS, HWUarts[ureg].ULCON);
+			break;
+		case 7:
+			__raw_writel(UART_7BITS, HWUarts[ureg].ULCON);
+			break;
+		case 6:
+			__raw_writel(UART_6BITS, HWUarts[ureg].ULCON);
+			break;
+		case 5:
+			__raw_writel(UART_5BITS, HWUarts[ureg].ULCON);
+			break;
+		default:
+			return -1;
+	}
+
+	return 0;
+}
+
+static int iphone_uart_setup(void) {
+	int i;
+
+	iphone_clock_gate_switch(UART_CLOCKGATE, 1);
+
+	for(i = 0; i < NUM_UARTS; i++) {
+		// set all uarts to transmit 8 bit frames, one stop bit per frame, no parity, no infrared mode
+		__raw_writel(UART_8BITS, HWUarts[i].ULCON);
+
+		// set all uarts to use polling for rx/tx, no breaks, no loopback, no error status interrupts,
+		// no timeouts, pulse interrupts for rx/tx, peripheral clock. Basically, the defaults.
+		__raw_writel((UART_UCON_MODE_IRQORPOLL << UART_UCON_RXMODE_SHIFT) | (UART_UCON_MODE_IRQORPOLL << UART_UCON_TXMODE_SHIFT), HWUarts[i].UCON);
+
+		// Initialize the settings array a bit so the helper functions can be used properly
+		UARTs[i].ureg = i;
+		UARTs[i].baud = 115200;
+
+		iphone_uart_set_clk(i, UART_CLOCK_EXT_UCLK0);
+		iphone_uart_set_sample_rate(i, 16);
+	}
+
+	// Set flow control
+	iphone_uart_set_flow_control(0, 0);
+	iphone_uart_set_flow_control(1, 1);
+	iphone_uart_set_flow_control(2, 1);
+	iphone_uart_set_flow_control(3, 1);
+	iphone_uart_set_flow_control(4, 0);
+
+	// Reset and enable fifo
+	for(i = 0; i < NUM_UARTS; i++) {
+		__raw_writel(UART_FIFO_RESET_TX | UART_FIFO_RESET_RX, HWUarts[i].UFCON);
+		__raw_writel(UART_FIFO_ENABLE, HWUarts[i].UFCON);
+	}
+
+	for(i = 0; i < NUM_UARTS; i++) {
+		iphone_uart_set_mode(i, UART_POLL_MODE);
+	}
+
+	return 0;
+}
+
+void iphone_uart_enable_tx_irq(struct iphone_uart_info* info)
+{
+	const struct UARTRegisters* uart = &HWUarts[info->ureg];
+	__raw_writel(__raw_readl(uart->UCON) | (1 << 13), uart->UCON);
+}
+
+void iphone_uart_enable_rx_irq(struct iphone_uart_info* info)
+{
+	const struct UARTRegisters* uart = &HWUarts[info->ureg];
+	__raw_writel(__raw_readl(uart->UCON) | (1 << 12) | (1 << 7) | (1 << 11), uart->UCON);
+}
+
+void iphone_uart_disable_tx_irq(struct iphone_uart_info* info)
+{
+	const struct UARTRegisters* uart = &HWUarts[info->ureg];
+	__raw_writel(__raw_readl(uart->UCON) & ~(1 << 13), uart->UCON);
+}
+
+void iphone_uart_disable_rx_irq(struct iphone_uart_info* info)
+{
+	const struct UARTRegisters* uart = &HWUarts[info->ureg];
+	__raw_writel(__raw_readl(uart->UCON) & ~((1 << 12) | (1 << 7) | (1 << 11)), uart->UCON);
+}
+
+static irqreturn_t iphone_uart_tx_chars(int irq, void* id)
+{
+	struct iphone_uart_info* info = id;
+	struct uart_port* port = &info->port;
+	struct circ_buf *xmit = &port->state->xmit;
+	const struct UARTRegisters* uart = &HWUarts[info->ureg];
+	int count = 256;
+
+	if((__raw_readl(uart->UFSTAT) & UART_UFSTAT_TXFIFO_FULL) != 0)
+		goto out;
+
+	if(port->x_char)
+	{
+		__raw_writel(port->x_char, uart->UTXH);
+		port->icount.tx++;
+		port->x_char = 0;
+		goto out;
+	}
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port))
+	{
+		iphone_uart_stop_tx(port);	/* no-op for us */
+		goto out;
+	}
+
+	while (!uart_circ_empty(xmit) && count-- > 0)
+	{
+		// if the tx fifo buffer is full
+		if((__raw_readl(uart->UFSTAT) & UART_UFSTAT_TXFIFO_FULL) != 0)
+			break;
+
+		__raw_writel(xmit->buf[xmit->tail], uart->UTXH);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		iphone_uart_stop_tx(port);	/* no-op for us */
+
+out:
+	return IRQ_HANDLED;
+
+}
+
+static irqreturn_t iphone_uart_rx_chars(int irq, void* id)
+{
+	struct iphone_uart_info* info = id;
+	struct uart_port* port = &info->port;
+	struct tty_struct *tty = port->state->port.tty;
+	const struct UARTRegisters* uart = &HWUarts[info->ureg];
+	int count = 64;
+
+	while (count-- > 0)
+	{
+		u32 ufcon = __raw_readl(uart->UFCON);
+		u32 ufstat = __raw_readl(uart->UFSTAT);
+		u32 uerstat;
+		u32 flag;
+		u8 ch;
+
+		if(((ufstat & UART_UFSTAT_RXFIFO_FULL) | (ufstat & UART_UFSTAT_RXCOUNT_MASK)) == 0)
+			break;
+
+		uerstat = __raw_readl(uart->UERSTAT);
+		ch = __raw_readl(uart->URXH);
+
+		if (port->flags & UPF_CONS_FLOW)
+		{
+			int txe = __raw_readl(uart->UTRSTAT) & UART_UTRSTAT_TRANSMITTEREMPTY;
+
+			if(info->rx_enabled)
+			{
+				if (!txe)
+				{
+					info->rx_enabled = 0;
+					continue;
+				}
+			} else
+			{
+				if (txe)
+				{
+					ufcon |= UART_FIFO_RESET_RX;
+					__raw_writel(ufcon, uart->UFCON);
+					info->rx_enabled = 1;
+					goto out;
+				}
+			}
+		}
+
+		/* insert the character into the buffer */
+
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+
+		if(unlikely(uerstat != 0))
+		{
+			/* check for break */
+			if (uerstat & UART_UERSTAT_BREAK)
+			{
+				port->icount.brk++;
+				if(uart_handle_break(port))
+				    goto ignore_char;
+			}
+
+			if (uerstat & UART_UERSTAT_FRAME)
+				port->icount.frame++;
+
+			if (uerstat & UART_UERSTAT_OVERRUN)
+				port->icount.overrun++;
+
+			uerstat &= port->read_status_mask;
+
+			if (uerstat & UART_UERSTAT_BREAK)
+				flag = TTY_BREAK;
+
+			else if (uerstat & UART_UERSTAT_PARITY)
+				flag = TTY_PARITY;
+
+			else if (uerstat & (UART_UERSTAT_FRAME |
+					    UART_UERSTAT_OVERRUN))
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(port, ch))
+			goto ignore_char;
+
+		uart_insert_char(port, uerstat, UART_UERSTAT_OVERRUN,
+				 ch, flag);
+
+ ignore_char:
+		continue;
+	}
+
+	tty_flip_buffer_push(tty);
+
+ out:
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t iphone_uart_handle_irq(int irq, void* id)
+{
+	struct iphone_uart_info* info = id;
+	const struct UARTRegisters* uart = &HWUarts[info->ureg];
+	u32 pending = __raw_readl(uart->UTRSTAT);
+	__raw_writel(pending, uart->UTRSTAT);
+
+	pr_debug("iphone_uart_handle_irq: %x %x\n", __raw_readl(uart->UCON), pending >> 4);
+
+	if((pending & (1 << 4)) || (pending & (1 << 3)))
+		iphone_uart_rx_chars(irq, info);
+
+	if(pending & (1 << 5))
+		iphone_uart_tx_chars(irq, info);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * iphone_uart_type - What type of console are we?
+ * @port: Port to operate with (we ignore since we only have one port)
+ *
+ */
+static const char *iphone_uart_type(struct uart_port *port)
+{
+	return ("iPhone Serial");
+}
+
+/**
+ * iphone_uart_tx_empty - Is the transmitter empty?  We pretend we're always empty
+ * @port: Port to operate on (we ignore since we only have one port)
+ *
+ */
+static unsigned int iphone_uart_tx_empty(struct uart_port *port)
+{
+	struct iphone_uart_info* info = (struct iphone_uart_info*) port;
+	const struct UARTRegisters* uart = &HWUarts[info->ureg];
+
+	if((__raw_readl(uart->UFSTAT) & UART_UFSTAT_TXFIFO_FULL) != 0)
+		return 0;
+	else
+		return 1;
+}
+
+/**
+ * iphone_uart_stop_tx - stop the transmitter - no-op for us
+ * @port: Port to operat eon - we ignore - no-op function
+ *
+ */
+static void iphone_uart_stop_tx(struct uart_port *port)
+{
+	struct iphone_uart_info* info = (struct iphone_uart_info*) port;
+
+	if(info->tx_enabled)
+	{
+		iphone_uart_disable_tx_irq(info);
+		info->tx_enabled = 0;
+		if(port->flags & UPF_CONS_FLOW)
+		{
+			const struct UARTRegisters* uart = &HWUarts[info->ureg];
+			unsigned long flags;
+			int count = 10000;
+
+			spin_lock_irqsave(&port->lock, flags);
+
+			while (--count && !(__raw_readl(uart->UTRSTAT) & UART_UTRSTAT_TRANSMITTEREMPTY))
+				udelay(100);
+
+			__raw_writel(__raw_readl(uart->UFCON) | UART_FIFO_RESET_RX, uart->UFCON);
+
+			__raw_writel((__raw_readl(uart->UCON) & (~UART_UCON_RXMODE_MASK))
+					| (UART_UCON_MODE_IRQORPOLL << UART_UCON_RXMODE_SHIFT), uart->UCON);
+
+			info->rx_enabled = 1;
+
+			spin_unlock_irqrestore(&port->lock, flags);
+		}
+	}
+}
+
+/**
+ * iphone_uart_release_port - Free i/o and resources for port - no-op for us
+ * @port: Port to operate on - we ignore - no-op function
+ *
+ */
+static void iphone_uart_release_port(struct uart_port *port)
+{
+}
+
+/**
+ * iphone_uart_enable_ms - Force modem status interrupts on - no-op for us
+ * @port: Port to operate on - we ignore - no-op function
+ *
+ */
+static void iphone_uart_enable_ms(struct uart_port *port)
+{
+}
+
+/**
+ * iphone_uart_shutdown - shut down the port - free irq and disable - no-op for us
+ * @port: Port to shut down - we ignore
+ *
+ */
+static void iphone_uart_shutdown(struct uart_port *port)
+{
+	struct iphone_uart_info* info = (struct iphone_uart_info*) port;
+	const struct UARTRegisters* uart = &HWUarts[info->ureg];
+
+	// mask all irqs
+	__raw_writel(__raw_readl(uart->UCON) & ~(0xF << 12), uart->UCON);
+
+	free_irq(0x18 + info->ureg, info);
+}
+
+/**
+ * iphone_uart_set_mctrl - set control lines (dtr, rts, etc) - no-op for our console
+ * @port: Port to operate on - we ignore
+ * @mctrl: Lines to set/unset - we ignore
+ *
+ */
+static void iphone_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+/**
+ * iphone_uart_get_mctrl - get control line info, we just return a static value
+ * @port: port to operate on - we only have one port so we ignore this
+ *
+ */
+static unsigned int iphone_uart_get_mctrl(struct uart_port *port)
+{
+	struct iphone_uart_info* info = (struct iphone_uart_info*) port;
+	const struct UARTRegisters* uart = &HWUarts[info->ureg];
+
+	if(__raw_readl(uart->UMSTAT) & UART_UMSTAT_CTS)
+		return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
+	else
+		return TIOCM_CAR | TIOCM_DSR;
+}
+
+/**
+ * iphone_uart_stop_rx - Stop the receiver - we ignor ethis
+ * @port: Port to operate on - we ignore
+ *
+ */
+static void iphone_uart_stop_rx(struct uart_port *port)
+{
+	struct iphone_uart_info* info = (struct iphone_uart_info*) port;
+
+	if(info->rx_enabled)
+	{
+		iphone_uart_disable_rx_irq(info);
+		info->rx_enabled = 0;
+	}
+}
+
+/**
+ * iphone_uart_start_tx - Start transmitter
+ * @port: Port to operate on
+ *
+ */
+static void iphone_uart_start_tx(struct uart_port *port)
+{
+	struct iphone_uart_info* info = (struct iphone_uart_info*) port;
+
+	if(!info->tx_enabled)
+	{
+		unsigned long flags;
+		if(port->flags & UPF_CONS_FLOW)
+		{
+			const struct UARTRegisters* uart = &HWUarts[info->ureg];
+			unsigned long flags;
+
+			spin_lock_irqsave(&port->lock, flags);
+
+			__raw_writel(__raw_readl(uart->UCON) & ~~UART_UCON_RXMODE_MASK, uart->UCON);
+
+			info->rx_enabled = 0;
+			spin_unlock_irqrestore(&port->lock, flags);
+		}
+
+		info->tx_enabled = 1;
+		local_irq_save(flags);
+		iphone_uart_enable_tx_irq(info);
+		iphone_uart_tx_chars(0, info);
+		local_irq_restore(flags);
+	}
+}
+
+/**
+ * iphone_uart_break_ctl - handle breaks - ignored by us
+ * @port: Port to operate on
+ * @break_state: Break state
+ *
+ */
+static void iphone_uart_break_ctl(struct uart_port *port, int break_state)
+{
+}
+
+/**
+ * iphone_uart_startup - Start up the serial port - always return 0 (We're always on)
+ * @port: Port to operate on
+ *
+ */
+static int iphone_uart_startup(struct uart_port *port)
+{
+	struct iphone_uart_info* info = (struct iphone_uart_info*) port;
+	const struct UARTRegisters* uart = &HWUarts[info->ureg];
+	int ret;
+
+	info->rx_enabled = 1;
+	info->tx_enabled = 0;
+
+	// mask all irqs
+	__raw_writel(__raw_readl(uart->UCON) & ~(0xF << 12), uart->UCON);
+
+	ret = request_irq(0x18 + info->ureg, iphone_uart_handle_irq, IRQF_DISABLED, "iphone_uart", info);
+	if(ret)
+	{
+		pr_debug(KERN_ERR "error getting irq for uart %d\n", info->ureg);
+		return ret;
+	}
+
+	iphone_uart_enable_rx_irq(info);
+
+	return 0;
+}
+
+/**
+ * iphone_uart_set_termios - set termios stuff - we ignore these
+ * @port: port to operate on
+ * @termios: New settings
+ * @termios: Old
+ *
+ */
+static void
+iphone_uart_set_termios(struct uart_port *port, struct ktermios *termios,
+		struct ktermios *old)
+{
+	struct iphone_uart_info* info = (struct iphone_uart_info*) port;
+	const struct UARTRegisters* uart = &HWUarts[info->ureg];
+	unsigned int baud;
+	unsigned long flags;
+
+	termios->c_cflag &= ~(HUPCL | CMSPAR);
+	termios->c_cflag |= CLOCAL;
+
+	baud = uart_get_baud_rate(port, termios, old, 0, 4000000 * 8);
+
+	// awful, awful hack because Linux doesn't support our baud rate
+	if(baud == 921600)
+		baud = 750000;
+
+	pr_debug("uart %d:\n", info->ureg);
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	iphone_uart_set_baud_rate(info->ureg, baud);
+	pr_debug("\t%d baud\n", baud);
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		pr_debug("\t5-bit\n");
+		iphone_uart_set_bits(info->ureg, 5);
+		break;
+	case CS6:
+		pr_debug("\t6-bit\n");
+		iphone_uart_set_bits(info->ureg, 6);
+		break;
+	case CS7:
+		pr_debug("\t7-bit\n");
+		iphone_uart_set_bits(info->ureg, 7);
+		break;
+	case CS8:
+	default:
+		pr_debug("\t8-bit\n");
+		iphone_uart_set_bits(info->ureg, 8);
+		break;
+	}
+
+	if(termios->c_cflag & CRTSCTS)
+	{
+		iphone_uart_set_flow_control(info->ureg, 1);
+		pr_debug("\tflow control\n");
+	} else
+	{
+		iphone_uart_set_flow_control(info->ureg, 0);
+		pr_debug("\tno flow control\n");
+	}
+
+	if (termios->c_cflag & PARENB) {
+		if (termios->c_cflag & PARODD)
+		{
+			__raw_writel(__raw_readl(uart->ULCON) | (4 << 3), uart->ULCON);
+			pr_debug("\todd parity\n");
+		} else
+		{
+			__raw_writel(__raw_readl(uart->ULCON) | (5 << 3), uart->ULCON);
+			pr_debug("\teven parity\n");
+		}
+	} else
+	{
+		pr_debug("\tno parity\n");
+	}
+
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	port->read_status_mask = UART_UERSTAT_OVERRUN;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= UART_UERSTAT_FRAME | UART_UERSTAT_PARITY;
+
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= UART_UERSTAT_OVERRUN;
+	if (termios->c_iflag & IGNBRK && termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= UART_UERSTAT_FRAME;
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+/**
+ * iphone_uart_request_port - allocate resources for port - ignored by us
+ * @port: port to operate on
+ *
+ */
+static int iphone_uart_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+/**
+ * iphone_uart_config_port - allocate resources, set up - we ignore,  we're always on
+ * @port: Port to operate on
+ * @flags: flags used for port setup
+ *
+ */
+static void iphone_uart_config_port(struct uart_port *port, int flags)
+{
+}
+
+static struct uart_ops iphone_uart_ops = {
+	.tx_empty     = iphone_uart_tx_empty,
+	.set_mctrl    = iphone_uart_set_mctrl,
+	.get_mctrl    = iphone_uart_get_mctrl,
+	.stop_tx      = iphone_uart_stop_tx,
+	.start_tx     = iphone_uart_start_tx,
+	.stop_rx      = iphone_uart_stop_rx,
+	.enable_ms    = iphone_uart_enable_ms,
+	.break_ctl    = iphone_uart_break_ctl,
+	.startup      = iphone_uart_startup,
+	.shutdown     = iphone_uart_shutdown,
+	.type         = iphone_uart_type,
+	.release_port = iphone_uart_release_port,
+	.request_port = iphone_uart_request_port,
+	.config_port  = iphone_uart_config_port,
+	.verify_port  = NULL,
+	.set_termios  = iphone_uart_set_termios,
+};
+
+struct uart_driver iphone_reg = {
+	.owner        = THIS_MODULE,
+	.driver_name  = "iphone_serial",
+	.dev_name     = "ttyS",
+	.major        = TTY_MAJOR,
+	.minor        = 64,
+	.nr           = NUM_UARTS,
+};
+
+static struct iphone_uart_info iphone_uart_port[NUM_UARTS];
+
+static int __init iphone_uart_moduleinit(void)
+{
+	int i;
+
+	uart_register_driver(&iphone_reg);
+
+	iphone_uart_setup();
+
+	for(i = 0; i < NUM_UARTS; i++)
+	{
+		struct uart_port* port = &iphone_uart_port[i].port;
+		const struct UARTRegisters* uart = &HWUarts[i];
+
+		spin_lock_init(&port->lock);
+
+		iphone_uart_port[i].ureg = i;
+		iphone_uart_port[i].rx_enabled = 0;
+		iphone_uart_port[i].tx_enabled = 0;
+
+		/* Setup the port struct with the minimum needed */
+		port->membase = (char*) uart->ULCON;	/* just needs to be non-zero */
+		port->type = PORT_S3C6400;
+		port->fifosize = 10;
+		port->ops = &iphone_uart_ops;
+		port->line = i;
+
+		uart_add_one_port(&iphone_reg, (struct uart_port*) &iphone_uart_port[i]);
+	}
+
+	return 0;
+}
+
+module_init(iphone_uart_moduleinit);
diff -Nur linux-2.6.32-orig/drivers/serial/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/serial/Kconfig
--- linux-2.6.32-orig/drivers/serial/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/serial/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -5,6 +5,11 @@
 menu "Serial drivers"
 	depends on HAS_IOMEM
 
+config SERIAL_APPLE_IPHONE
+	tristate "Apple iPhone serial support"
+	depends on MACH_APPLE_IPHONE
+	select SERIAL_CORE
+
 #
 # The new 8250/16550 serial drivers
 config SERIAL_8250
diff -Nur linux-2.6.32-orig/drivers/serial/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/serial/Makefile
--- linux-2.6.32-orig/drivers/serial/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/serial/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -14,6 +14,7 @@
 obj-$(CONFIG_SERIAL_SUNSU) += sunsu.o
 obj-$(CONFIG_SERIAL_SUNSAB) += sunsab.o
 
+obj-$(CONFIG_SERIAL_APPLE_IPHONE) += iphone-uart.o
 obj-$(CONFIG_SERIAL_8250) += 8250.o
 obj-$(CONFIG_SERIAL_8250_PNP) += 8250_pnp.o
 obj-$(CONFIG_SERIAL_8250_GSC) += 8250_gsc.o
diff -Nur linux-2.6.32-orig/drivers/serial/serial_core.c iDroid-Project-kernel_common-9e90fd2/drivers/serial/serial_core.c
--- linux-2.6.32-orig/drivers/serial/serial_core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/serial/serial_core.c	2010-11-18 21:05:30.000000000 +0600
@@ -94,6 +94,9 @@
 	struct uart_state *state = tty->driver_data;
 	struct uart_port *port = state->uart_port;
 
+	if (port->ops->wake_peer)
+		port->ops->wake_peer(port);
+
 	if (!uart_circ_empty(&state->xmit) && state->xmit.buf &&
 	    !tty->stopped && !tty->hw_stopped)
 		port->ops->start_tx(port);
diff -Nur linux-2.6.32-orig/drivers/serial/uartlite.c iDroid-Project-kernel_common-9e90fd2/drivers/serial/uartlite.c
--- linux-2.6.32-orig/drivers/serial/uartlite.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/serial/uartlite.c	2010-11-18 21:05:30.000000000 +0600
@@ -394,7 +394,7 @@
 		spin_unlock_irqrestore(&port->lock, flags);
 }
 
-static int __init ulite_console_setup(struct console *co, char *options)
+static int __devinit ulite_console_setup(struct console *co, char *options)
 {
 	struct uart_port *port;
 	int baud = 9600;
diff -Nur linux-2.6.32-orig/drivers/ssb/sprom.c iDroid-Project-kernel_common-9e90fd2/drivers/ssb/sprom.c
--- linux-2.6.32-orig/drivers/ssb/sprom.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/ssb/sprom.c	2010-11-18 21:05:30.000000000 +0600
@@ -13,6 +13,8 @@
 
 #include "ssb_private.h"
 
+#include <linux/ctype.h>
+
 
 static const struct ssb_sprom *fallback_sprom;
 
@@ -33,17 +35,27 @@
 static int hex2sprom(u16 *sprom, const char *dump, size_t len,
 		     size_t sprom_size_words)
 {
-	char tmp[5] = { 0 };
-	int cnt = 0;
+	char c, tmp[5] = { 0 };
+	int err, cnt = 0;
 	unsigned long parsed;
 
-	if (len < sprom_size_words * 2)
+	/* Strip whitespace at the end. */
+	while (len) {
+		c = dump[len - 1];
+		if (!isspace(c) && c != '\0')
+			break;
+		len--;
+	}
+	/* Length must match exactly. */
+	if (len != sprom_size_words * 4)
 		return -EINVAL;
 
 	while (cnt < sprom_size_words) {
 		memcpy(tmp, dump, 4);
 		dump += 4;
-		parsed = simple_strtoul(tmp, NULL, 16);
+		err = strict_strtoul(tmp, 16, &parsed);
+		if (err)
+			return err;
 		sprom[cnt++] = swab16((u16)parsed);
 	}
 
diff -Nur linux-2.6.32-orig/drivers/staging/android/binder.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/binder.c
--- linux-2.6.32-orig/drivers/staging/android/binder.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/binder.c	2010-11-18 21:05:30.000000000 +0600
@@ -46,6 +46,7 @@
 static struct binder_node *binder_context_mgr_node;
 static uid_t binder_context_mgr_uid = -1;
 static int binder_last_id;
+static struct workqueue_struct *binder_deferred_workqueue;
 
 static int binder_read_proc_proc(char *page, char **start, off_t off,
 				 int count, int *eof, void *data);
@@ -3025,11 +3026,14 @@
 		int i;
 		for (i = 0; i < proc->buffer_size / PAGE_SIZE; i++) {
 			if (proc->pages[i]) {
+				void *page_addr = proc->buffer + i * PAGE_SIZE;
 				binder_debug(BINDER_DEBUG_BUFFER_ALLOC,
 					     "binder_release: %d: "
 					     "page %d at %p not freed\n",
 					     proc->pid, i,
-					     proc->buffer + i * PAGE_SIZE);
+					     page_addr);
+				unmap_kernel_range((unsigned long)page_addr,
+					PAGE_SIZE);
 				__free_page(proc->pages[i]);
 				page_count++;
 			}
@@ -3099,7 +3103,7 @@
 	if (hlist_unhashed(&proc->deferred_work_node)) {
 		hlist_add_head(&proc->deferred_work_node,
 				&binder_deferred_list);
-		schedule_work(&binder_deferred_work);
+		queue_work(binder_deferred_workqueue, &binder_deferred_work);
 	}
 	mutex_unlock(&binder_deferred_lock);
 }
@@ -3727,6 +3731,10 @@
 {
 	int ret;
 
+	binder_deferred_workqueue = create_singlethread_workqueue("binder");
+	if (!binder_deferred_workqueue)
+		return -ENOMEM;
+
 	binder_proc_dir_entry_root = proc_mkdir("binder", NULL);
 	if (binder_proc_dir_entry_root)
 		binder_proc_dir_entry_proc = proc_mkdir("proc",
diff -Nur linux-2.6.32-orig/drivers/staging/android/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/Kconfig
--- linux-2.6.32-orig/drivers/staging/android/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -2,7 +2,6 @@
 
 config ANDROID
 	bool "Android Drivers"
-	depends on BROKEN
 	default N
 	---help---
 	  Enable support for various drivers needed on the Android platform
diff -Nur linux-2.6.32-orig/drivers/staging/android/logger.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/logger.c
--- linux-2.6.32-orig/drivers/staging/android/logger.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/logger.c	2010-11-18 21:05:30.000000000 +0600
@@ -17,6 +17,7 @@
  * GNU General Public License for more details.
  */
 
+#include <linux/sched.h>
 #include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/miscdevice.h>
@@ -556,6 +557,7 @@
 DEFINE_LOGGER_DEVICE(log_main, LOGGER_LOG_MAIN, 64*1024)
 DEFINE_LOGGER_DEVICE(log_events, LOGGER_LOG_EVENTS, 256*1024)
 DEFINE_LOGGER_DEVICE(log_radio, LOGGER_LOG_RADIO, 64*1024)
+DEFINE_LOGGER_DEVICE(log_system, LOGGER_LOG_SYSTEM, 64*1024)
 
 static struct logger_log *get_log_from_minor(int minor)
 {
@@ -565,6 +567,8 @@
 		return &log_events;
 	if (log_radio.misc.minor == minor)
 		return &log_radio;
+	if (log_system.misc.minor == minor)
+		return &log_system;
 	return NULL;
 }
 
@@ -601,6 +605,10 @@
 	if (unlikely(ret))
 		goto out;
 
+	ret = init_log(&log_system);
+	if (unlikely(ret))
+		goto out;
+
 out:
 	return ret;
 }
diff -Nur linux-2.6.32-orig/drivers/staging/android/logger.h iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/logger.h
--- linux-2.6.32-orig/drivers/staging/android/logger.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/logger.h	2010-11-18 21:05:30.000000000 +0600
@@ -32,6 +32,7 @@
 
 #define LOGGER_LOG_RADIO	"log_radio"	/* radio-related messages */
 #define LOGGER_LOG_EVENTS	"log_events"	/* system/hardware events */
+#define LOGGER_LOG_SYSTEM	"log_system"	/* system/framework messages */
 #define LOGGER_LOG_MAIN		"log_main"	/* everything else */
 
 #define LOGGER_ENTRY_MAX_LEN		(4*1024)
diff -Nur linux-2.6.32-orig/drivers/staging/android/lowmemorykiller.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/lowmemorykiller.c
--- linux-2.6.32-orig/drivers/staging/android/lowmemorykiller.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/lowmemorykiller.c	2010-11-18 21:05:30.000000000 +0600
@@ -34,6 +34,7 @@
 #include <linux/mm.h>
 #include <linux/oom.h>
 #include <linux/sched.h>
+#include <linux/notifier.h>
 
 static uint32_t lowmem_debug_level = 2;
 static int lowmem_adj[6] = {
@@ -51,12 +52,32 @@
 };
 static int lowmem_minfree_size = 4;
 
+static struct task_struct *lowmem_deathpending;
+
 #define lowmem_print(level, x...)			\
 	do {						\
 		if (lowmem_debug_level >= (level))	\
 			printk(x);			\
 	} while (0)
 
+static int
+task_notify_func(struct notifier_block *self, unsigned long val, void *data);
+
+static struct notifier_block task_nb = {
+	.notifier_call	= task_notify_func,
+};
+
+static int
+task_notify_func(struct notifier_block *self, unsigned long val, void *data)
+{
+	struct task_struct *task = data;
+	if (task == lowmem_deathpending) {
+		lowmem_deathpending = NULL;
+		task_free_unregister(&task_nb);
+	}
+	return NOTIFY_OK;
+}
+
 static int lowmem_shrink(int nr_to_scan, gfp_t gfp_mask)
 {
 	struct task_struct *p;
@@ -71,6 +92,16 @@
 	int other_free = global_page_state(NR_FREE_PAGES);
 	int other_file = global_page_state(NR_FILE_PAGES);
 
+	/*
+	 * If we already have a death outstanding, then
+	 * bail out right away; indicating to vmscan
+	 * that we have nothing further to offer on
+	 * this pass.
+	 *
+	 */
+	if (lowmem_deathpending)
+		return 0;
+
 	if (lowmem_adj_size < array_size)
 		array_size = lowmem_adj_size;
 	if (lowmem_minfree_size < array_size)
@@ -100,15 +131,17 @@
 	read_lock(&tasklist_lock);
 	for_each_process(p) {
 		struct mm_struct *mm;
+		struct signal_struct *sig;
 		int oom_adj;
 
 		task_lock(p);
 		mm = p->mm;
-		if (!mm) {
+		sig = p->signal;
+		if (!mm || !sig) {
 			task_unlock(p);
 			continue;
 		}
-		oom_adj = mm->oom_adj;
+		oom_adj = sig->oom_adj;
 		if (oom_adj < min_adj) {
 			task_unlock(p);
 			continue;
@@ -134,6 +167,8 @@
 		lowmem_print(1, "send sigkill to %d (%s), adj %d, size %d\n",
 			     selected->pid, selected->comm,
 			     selected_oom_adj, selected_tasksize);
+		lowmem_deathpending = selected;
+		task_free_register(&task_nb);
 		force_sig(SIGKILL, selected);
 		rem -= selected_tasksize;
 	}
diff -Nur linux-2.6.32-orig/drivers/staging/android/ram_console.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/ram_console.c
--- linux-2.6.32-orig/drivers/staging/android/ram_console.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/ram_console.c	2010-11-18 21:05:30.000000000 +0600
@@ -146,6 +146,14 @@
 	.index	= -1,
 };
 
+void ram_console_enable_console(int enabled)
+{
+	if (enabled)
+		ram_console.flags |= CON_ENABLED;
+	else
+		ram_console.flags &= ~CON_ENABLED;
+}
+
 static void __init
 ram_console_save_old(struct ram_console_buffer *buffer, char *dest)
 {
@@ -404,7 +412,7 @@
 #ifdef CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT
 console_initcall(ram_console_early_init);
 #else
-module_init(ram_console_module_init);
+postcore_initcall(ram_console_module_init);
 #endif
 late_initcall(ram_console_late_init);
 
diff -Nur linux-2.6.32-orig/drivers/staging/android/timed_gpio.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/timed_gpio.c
--- linux-2.6.32-orig/drivers/staging/android/timed_gpio.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/timed_gpio.c	2010-11-18 21:05:30.000000000 +0600
@@ -20,7 +20,7 @@
 #include <linux/err.h>
 #include <linux/gpio.h>
 
-#include "timed_output.h"
+#include <linux/timed_output.h>
 #include "timed_gpio.h"
 
 
@@ -106,10 +106,17 @@
 		gpio_dat->dev.name = cur_gpio->name;
 		gpio_dat->dev.get_time = gpio_get_time;
 		gpio_dat->dev.enable = gpio_enable;
-		ret = timed_output_dev_register(&gpio_dat->dev);
+		ret = gpio_request(cur_gpio->gpio, cur_gpio->name);
+		if (ret >= 0) {
+			ret = timed_output_dev_register(&gpio_dat->dev);
+			if (ret < 0)
+				gpio_free(cur_gpio->gpio);
+		}
 		if (ret < 0) {
-			for (j = 0; j < i; j++)
+			for (j = 0; j < i; j++) {
 				timed_output_dev_unregister(&gpio_data[i].dev);
+				gpio_free(gpio_data[i].gpio);
+			}
 			kfree(gpio_data);
 			return ret;
 		}
@@ -131,8 +138,10 @@
 	struct timed_gpio_data *gpio_data = platform_get_drvdata(pdev);
 	int i;
 
-	for (i = 0; i < pdata->num_gpios; i++)
+	for (i = 0; i < pdata->num_gpios; i++) {
 		timed_output_dev_unregister(&gpio_data[i].dev);
+		gpio_free(gpio_data[i].gpio);
+	}
 
 	kfree(gpio_data);
 
diff -Nur linux-2.6.32-orig/drivers/staging/android/timed_output.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/timed_output.c
--- linux-2.6.32-orig/drivers/staging/android/timed_output.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/timed_output.c	2010-11-18 21:05:30.000000000 +0600
@@ -20,7 +20,7 @@
 #include <linux/fs.h>
 #include <linux/err.h>
 
-#include "timed_output.h"
+#include <linux/timed_output.h>
 
 static struct class *timed_output_class;
 static atomic_t device_count;
@@ -41,7 +41,9 @@
 	struct timed_output_dev *tdev = dev_get_drvdata(dev);
 	int value;
 
-	sscanf(buf, "%d", &value);
+	if (sscanf(buf, "%d", &value) != 1)
+		return -EINVAL;
+
 	tdev->enable(tdev, value);
 
 	return size;
diff -Nur linux-2.6.32-orig/drivers/staging/android/timed_output.h iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/timed_output.h
--- linux-2.6.32-orig/drivers/staging/android/timed_output.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/android/timed_output.h	1970-01-01 07:00:00.000000000 +0700
@@ -1,37 +0,0 @@
-/* include/linux/timed_output.h
- *
- * Copyright (C) 2008 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
-*/
-
-#ifndef _LINUX_TIMED_OUTPUT_H
-#define _LINUX_TIMED_OUTPUT_H
-
-struct timed_output_dev {
-	const char	*name;
-
-	/* enable the output and set the timer */
-	void	(*enable)(struct timed_output_dev *sdev, int timeout);
-
-	/* returns the current number of milliseconds remaining on the timer */
-	int		(*get_time)(struct timed_output_dev *sdev);
-
-	/* private data */
-	struct device	*dev;
-	int		index;
-	int		state;
-};
-
-extern int timed_output_dev_register(struct timed_output_dev *dev);
-extern void timed_output_dev_unregister(struct timed_output_dev *dev);
-
-#endif
diff -Nur linux-2.6.32-orig/drivers/staging/asus_oled/asus_oled.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/asus_oled/asus_oled.c
--- linux-2.6.32-orig/drivers/staging/asus_oled/asus_oled.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/asus_oled/asus_oled.c	2010-11-18 21:05:30.000000000 +0600
@@ -194,9 +194,11 @@
 {
 	struct usb_interface *intf = to_usb_interface(dev);
 	struct asus_oled_dev *odev = usb_get_intfdata(intf);
-	int temp = strict_strtoul(buf, 10, NULL);
+	unsigned long value;
+	if (strict_strtoul(buf, 10, &value))
+		return -EINVAL;
 
-	enable_oled(odev, temp);
+	enable_oled(odev, value);
 
 	return count;
 }
@@ -207,10 +209,12 @@
 {
 	struct asus_oled_dev *odev =
 		(struct asus_oled_dev *) dev_get_drvdata(device);
+	unsigned long value;
 
-	int temp = strict_strtoul(buf, 10, NULL);
+	if (strict_strtoul(buf, 10, &value))
+		return -EINVAL;
 
-	enable_oled(odev, temp);
+	enable_oled(odev, value);
 
 	return count;
 }
diff -Nur linux-2.6.32-orig/drivers/staging/hv/Hv.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/hv/Hv.c
--- linux-2.6.32-orig/drivers/staging/hv/Hv.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/hv/Hv.c	2010-11-18 21:05:30.000000000 +0600
@@ -386,7 +386,7 @@
  * retrieve the initialized message and event pages.  Otherwise, we create and
  * initialize the message and event pages.
  */
-int HvSynicInit(u32 irqVector)
+void HvSynicInit(void *irqarg)
 {
 	u64 version;
 	union hv_synic_simp simp;
@@ -394,13 +394,14 @@
 	union hv_synic_sint sharedSint;
 	union hv_synic_scontrol sctrl;
 	u64 guestID;
-	int ret = 0;
+	u32 irqVector = *((u32 *)(irqarg));
+	int cpu = smp_processor_id();
 
 	DPRINT_ENTER(VMBUS);
 
 	if (!gHvContext.HypercallPage) {
 		DPRINT_EXIT(VMBUS);
-		return ret;
+		return;
 	}
 
 	/* Check the version */
@@ -425,27 +426,27 @@
 		 */
 		rdmsrl(HV_X64_MSR_GUEST_OS_ID, guestID);
 		if (guestID == HV_LINUX_GUEST_ID) {
-			gHvContext.synICMessagePage[0] =
+			gHvContext.synICMessagePage[cpu] =
 				phys_to_virt(simp.BaseSimpGpa << PAGE_SHIFT);
-			gHvContext.synICEventPage[0] =
+			gHvContext.synICEventPage[cpu] =
 				phys_to_virt(siefp.BaseSiefpGpa << PAGE_SHIFT);
 		} else {
 			DPRINT_ERR(VMBUS, "unknown guest id!!");
 			goto Cleanup;
 		}
 		DPRINT_DBG(VMBUS, "MAPPED: Simp: %p, Sifep: %p",
-			   gHvContext.synICMessagePage[0],
-			   gHvContext.synICEventPage[0]);
+			   gHvContext.synICMessagePage[cpu],
+			   gHvContext.synICEventPage[cpu]);
 	} else {
-		gHvContext.synICMessagePage[0] = osd_PageAlloc(1);
-		if (gHvContext.synICMessagePage[0] == NULL) {
+		gHvContext.synICMessagePage[cpu] = (void *)get_zeroed_page(GFP_ATOMIC);
+		if (gHvContext.synICMessagePage[cpu] == NULL) {
 			DPRINT_ERR(VMBUS,
 				   "unable to allocate SYNIC message page!!");
 			goto Cleanup;
 		}
 
-		gHvContext.synICEventPage[0] = osd_PageAlloc(1);
-		if (gHvContext.synICEventPage[0] == NULL) {
+		gHvContext.synICEventPage[cpu] = (void *)get_zeroed_page(GFP_ATOMIC);
+		if (gHvContext.synICEventPage[cpu] == NULL) {
 			DPRINT_ERR(VMBUS,
 				   "unable to allocate SYNIC event page!!");
 			goto Cleanup;
@@ -454,7 +455,7 @@
 		/* Setup the Synic's message page */
 		rdmsrl(HV_X64_MSR_SIMP, simp.AsUINT64);
 		simp.SimpEnabled = 1;
-		simp.BaseSimpGpa = virt_to_phys(gHvContext.synICMessagePage[0])
+		simp.BaseSimpGpa = virt_to_phys(gHvContext.synICMessagePage[cpu])
 					>> PAGE_SHIFT;
 
 		DPRINT_DBG(VMBUS, "HV_X64_MSR_SIMP msr set to: %llx",
@@ -465,7 +466,7 @@
 		/* Setup the Synic's event page */
 		rdmsrl(HV_X64_MSR_SIEFP, siefp.AsUINT64);
 		siefp.SiefpEnabled = 1;
-		siefp.BaseSiefpGpa = virt_to_phys(gHvContext.synICEventPage[0])
+		siefp.BaseSiefpGpa = virt_to_phys(gHvContext.synICEventPage[cpu])
 					>> PAGE_SHIFT;
 
 		DPRINT_DBG(VMBUS, "HV_X64_MSR_SIEFP msr set to: %llx",
@@ -501,32 +502,30 @@
 
 	DPRINT_EXIT(VMBUS);
 
-	return ret;
+	return;
 
 Cleanup:
-	ret = -1;
-
 	if (gHvContext.GuestId == HV_LINUX_GUEST_ID) {
-		if (gHvContext.synICEventPage[0])
-			osd_PageFree(gHvContext.synICEventPage[0], 1);
+		if (gHvContext.synICEventPage[cpu])
+			osd_PageFree(gHvContext.synICEventPage[cpu], 1);
 
-		if (gHvContext.synICMessagePage[0])
-			osd_PageFree(gHvContext.synICMessagePage[0], 1);
+		if (gHvContext.synICMessagePage[cpu])
+			osd_PageFree(gHvContext.synICMessagePage[cpu], 1);
 	}
 
 	DPRINT_EXIT(VMBUS);
-
-	return ret;
+	return;
 }
 
 /**
  * HvSynicCleanup - Cleanup routine for HvSynicInit().
  */
-void HvSynicCleanup(void)
+void HvSynicCleanup(void *arg)
 {
 	union hv_synic_sint sharedSint;
 	union hv_synic_simp simp;
 	union hv_synic_siefp siefp;
+	int cpu = smp_processor_id();
 
 	DPRINT_ENTER(VMBUS);
 
@@ -539,6 +538,7 @@
 
 	sharedSint.Masked = 1;
 
+	/* Need to correctly cleanup in the case of SMP!!! */
 	/* Disable the interrupt */
 	wrmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, sharedSint.AsUINT64);
 
@@ -560,8 +560,8 @@
 
 		wrmsrl(HV_X64_MSR_SIEFP, siefp.AsUINT64);
 
-		osd_PageFree(gHvContext.synICMessagePage[0], 1);
-		osd_PageFree(gHvContext.synICEventPage[0], 1);
+		osd_PageFree(gHvContext.synICMessagePage[cpu], 1);
+		osd_PageFree(gHvContext.synICEventPage[cpu], 1);
 	}
 
 	DPRINT_EXIT(VMBUS);
diff -Nur linux-2.6.32-orig/drivers/staging/hv/Hv.h iDroid-Project-kernel_common-9e90fd2/drivers/staging/hv/Hv.h
--- linux-2.6.32-orig/drivers/staging/hv/Hv.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/hv/Hv.h	2010-11-18 21:05:30.000000000 +0600
@@ -93,7 +93,7 @@
 	},
 };
 
-#define MAX_NUM_CPUS	1
+#define MAX_NUM_CPUS	32
 
 
 struct hv_input_signal_event_buffer {
@@ -137,8 +137,8 @@
 
 extern u16 HvSignalEvent(void);
 
-extern int HvSynicInit(u32 irqVector);
+extern void HvSynicInit(void *irqarg);
 
-extern void HvSynicCleanup(void);
+extern void HvSynicCleanup(void *arg);
 
 #endif /* __HV_H__ */
diff -Nur linux-2.6.32-orig/drivers/staging/hv/Vmbus.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/hv/Vmbus.c
--- linux-2.6.32-orig/drivers/staging/hv/Vmbus.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/hv/Vmbus.c	2010-11-18 21:05:30.000000000 +0600
@@ -129,7 +129,7 @@
 
 	/* strcpy(dev->name, "vmbus"); */
 	/* SynIC setup... */
-	ret = HvSynicInit(*irqvector);
+	on_each_cpu(HvSynicInit, (void *)irqvector, 1);
 
 	/* Connect to VMBus in the root partition */
 	ret = VmbusConnect();
@@ -150,7 +150,7 @@
 	DPRINT_ENTER(VMBUS);
 	VmbusChannelReleaseUnattachedChannels();
 	VmbusDisconnect();
-	HvSynicCleanup();
+	on_each_cpu(HvSynicCleanup, NULL, 1);
 	DPRINT_EXIT(VMBUS);
 
 	return ret;
@@ -173,7 +173,8 @@
  */
 static void VmbusOnMsgDPC(struct hv_driver *drv)
 {
-	void *page_addr = gHvContext.synICMessagePage[0];
+	int cpu = smp_processor_id();
+	void *page_addr = gHvContext.synICMessagePage[cpu];
 	struct hv_message *msg = (struct hv_message *)page_addr +
 				  VMBUS_MESSAGE_SINT;
 	struct hv_message *copied;
@@ -230,11 +231,12 @@
 static int VmbusOnISR(struct hv_driver *drv)
 {
 	int ret = 0;
+	int cpu = smp_processor_id();
 	void *page_addr;
 	struct hv_message *msg;
 	union hv_synic_event_flags *event;
 
-	page_addr = gHvContext.synICMessagePage[0];
+	page_addr = gHvContext.synICMessagePage[cpu];
 	msg = (struct hv_message *)page_addr + VMBUS_MESSAGE_SINT;
 
 	DPRINT_ENTER(VMBUS);
@@ -248,7 +250,7 @@
 	}
 
 	/* TODO: Check if there are events to be process */
-	page_addr = gHvContext.synICEventPage[0];
+	page_addr = gHvContext.synICEventPage[cpu];
 	event = (union hv_synic_event_flags *)page_addr + VMBUS_MESSAGE_SINT;
 
 	/* Since we are a child, we only need to check bit 0 */
diff -Nur linux-2.6.32-orig/drivers/staging/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/staging/Makefile
--- linux-2.6.32-orig/drivers/staging/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -26,7 +26,7 @@
 obj-$(CONFIG_INPUT_MIMIO)	+= mimio/
 obj-$(CONFIG_TRANZPORT)		+= frontier/
 obj-$(CONFIG_ANDROID)		+= android/
-obj-$(CONFIG_ANDROID)		+= dream/
+obj-$(CONFIG_STAGING_DREAM)	+= dream/
 obj-$(CONFIG_DST)		+= dst/
 obj-$(CONFIG_POHMELFS)		+= pohmelfs/
 obj-$(CONFIG_B3DFG)		+= b3dfg/
diff -Nur linux-2.6.32-orig/drivers/staging/rtl8187se/ieee80211/ieee80211.h iDroid-Project-kernel_common-9e90fd2/drivers/staging/rtl8187se/ieee80211/ieee80211.h
--- linux-2.6.32-orig/drivers/staging/rtl8187se/ieee80211/ieee80211.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/rtl8187se/ieee80211/ieee80211.h	2010-11-18 21:05:30.000000000 +0600
@@ -1318,13 +1318,13 @@
 	struct sk_buff *frag,
 	int hdr_len);
 
-extern int ieee80211_xmit(struct sk_buff *skb,
+extern int ieee80211_rtl_xmit(struct sk_buff *skb,
 			  struct net_device *dev);
 extern void ieee80211_txb_free(struct ieee80211_txb *);
 
 
 /* ieee80211_rx.c */
-extern int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
+extern int ieee80211_rtl_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
 			struct ieee80211_rx_stats *rx_stats);
 extern void ieee80211_rx_mgt(struct ieee80211_device *ieee,
 			     struct ieee80211_hdr_4addr *header,
@@ -1376,8 +1376,8 @@
 extern void ieee80211_softmac_start_protocol(struct ieee80211_device *ieee);
 extern void ieee80211_softmac_stop_protocol(struct ieee80211_device *ieee);
 extern void ieee80211_reset_queue(struct ieee80211_device *ieee);
-extern void ieee80211_wake_queue(struct ieee80211_device *ieee);
-extern void ieee80211_stop_queue(struct ieee80211_device *ieee);
+extern void ieee80211_rtl_wake_queue(struct ieee80211_device *ieee);
+extern void ieee80211_rtl_stop_queue(struct ieee80211_device *ieee);
 extern struct sk_buff *ieee80211_get_beacon(struct ieee80211_device *ieee);
 extern void ieee80211_start_send_beacons(struct ieee80211_device *ieee);
 extern void ieee80211_stop_send_beacons(struct ieee80211_device *ieee);
@@ -1385,7 +1385,7 @@
 extern void notify_wx_assoc_event(struct ieee80211_device *ieee);
 extern void ieee80211_ps_tx_ack(struct ieee80211_device *ieee, short success);
 extern void SendDisassociation(struct ieee80211_device *ieee,u8* asSta,u8 asRsn);
-extern void ieee80211_start_scan(struct ieee80211_device *ieee);
+extern void ieee80211_rtl_start_scan(struct ieee80211_device *ieee);
 
 //Add for RF power on power off by lizhaoming 080512
 extern void SendDisassociation(struct ieee80211_device *ieee,
diff -Nur linux-2.6.32-orig/drivers/staging/rtl8187se/ieee80211/ieee80211_rx.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/rtl8187se/ieee80211/ieee80211_rx.c
--- linux-2.6.32-orig/drivers/staging/rtl8187se/ieee80211/ieee80211_rx.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/rtl8187se/ieee80211/ieee80211_rx.c	2010-11-18 21:05:30.000000000 +0600
@@ -470,7 +470,7 @@
 /* All received frames are sent to this function. @skb contains the frame in
  * IEEE 802.11 format, i.e., in the format it was sent over air.
  * This function is called only as a tasklet (software IRQ). */
-int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
+int ieee80211_rtl_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
 		 struct ieee80211_rx_stats *rx_stats)
 {
 	struct net_device *dev = ieee->dev;
diff -Nur linux-2.6.32-orig/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c
--- linux-2.6.32-orig/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c	2010-11-18 21:05:30.000000000 +0600
@@ -689,7 +689,7 @@
 }
 
 /* called with ieee->lock held */
-void ieee80211_start_scan(struct ieee80211_device *ieee)
+void ieee80211_rtl_start_scan(struct ieee80211_device *ieee)
 {
 	if(IS_DOT11D_ENABLE(ieee) )
 	{
@@ -1196,7 +1196,7 @@
 	}
 }
 
-void ieee80211_auth_challenge(struct ieee80211_device *ieee, u8 *challenge, int chlen)
+void ieee80211_rtl_auth_challenge(struct ieee80211_device *ieee, u8 *challenge, int chlen)
 {
 	u8 *c;
 	struct sk_buff *skb;
@@ -1898,7 +1898,7 @@
 
 								ieee80211_associate_step2(ieee);
 							}else{
-								ieee80211_auth_challenge(ieee, challenge, chlen);
+								ieee80211_rtl_auth_challenge(ieee, challenge, chlen);
 							}
 						}else{
 							ieee->softmac_stats.rx_auth_rs_err++;
@@ -2047,7 +2047,7 @@
 
 }
 
-void ieee80211_wake_queue(struct ieee80211_device *ieee)
+void ieee80211_rtl_wake_queue(struct ieee80211_device *ieee)
 {
 
 	unsigned long flags;
@@ -2089,7 +2089,7 @@
 }
 
 
-void ieee80211_stop_queue(struct ieee80211_device *ieee)
+void ieee80211_rtl_stop_queue(struct ieee80211_device *ieee)
 {
 	//unsigned long flags;
 	//spin_lock_irqsave(&ieee->lock,flags);
@@ -2301,7 +2301,7 @@
 //#else
 	if (ieee->state == IEEE80211_NOLINK){
 		ieee->actscanning = true;
-		ieee80211_start_scan(ieee);
+		ieee80211_rtl_start_scan(ieee);
 	}
 //#endif
 	spin_unlock_irqrestore(&ieee->lock, flags);
@@ -2357,7 +2357,7 @@
 	if(ieee->state == IEEE80211_NOLINK){
 		ieee->beinretry = false;
 		ieee->actscanning = true;
-		ieee80211_start_scan(ieee);
+		ieee80211_rtl_start_scan(ieee);
 	}
 	//YJ,add,080828, notify os here
 	if(ieee->state == IEEE80211_NOLINK)
diff -Nur linux-2.6.32-orig/drivers/staging/rtl8187se/ieee80211/ieee80211_tx.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/rtl8187se/ieee80211/ieee80211_tx.c
--- linux-2.6.32-orig/drivers/staging/rtl8187se/ieee80211/ieee80211_tx.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/rtl8187se/ieee80211/ieee80211_tx.c	2010-11-18 21:05:30.000000000 +0600
@@ -305,7 +305,7 @@
 }
 
 /* SKBs are added to the ieee->tx_queue. */
-int ieee80211_xmit(struct sk_buff *skb,
+int ieee80211_rtl_xmit(struct sk_buff *skb,
 		   struct net_device *dev)
 {
 	struct ieee80211_device *ieee = netdev_priv(dev);
diff -Nur linux-2.6.32-orig/drivers/staging/rtl8187se/r8180_core.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/rtl8187se/r8180_core.c
--- linux-2.6.32-orig/drivers/staging/rtl8187se/r8180_core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/rtl8187se/r8180_core.c	2010-11-18 21:05:30.000000000 +0600
@@ -1830,7 +1830,7 @@
 			if(priv->rx_skb->len > 4)
 				skb_trim(priv->rx_skb,priv->rx_skb->len-4);
 #ifndef RX_DONT_PASS_UL
-			if(!ieee80211_rx(priv->ieee80211,
+			if(!ieee80211_rtl_rx(priv->ieee80211,
 					 priv->rx_skb, &stats)){
 #endif // RX_DONT_PASS_UL
 
@@ -1936,11 +1936,11 @@
 	if (!check_nic_enought_desc(dev, priority)){
 		DMESGW("Error: no descriptor left by previous TX (avail %d) ",
 			get_curr_tx_free_desc(dev, priority));
-		ieee80211_stop_queue(priv->ieee80211);
+		ieee80211_rtl_stop_queue(priv->ieee80211);
 	}
 	rtl8180_tx(dev, skb->data, skb->len, priority, morefrag,0,rate);
 	if (!check_nic_enought_desc(dev, priority))
-		ieee80211_stop_queue(priv->ieee80211);
+		ieee80211_rtl_stop_queue(priv->ieee80211);
 
 	spin_unlock_irqrestore(&priv->tx_lock,flags);
 }
@@ -3846,7 +3846,7 @@
 	.ndo_set_mac_address	= r8180_set_mac_adr,
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_change_mtu		= eth_change_mtu,
-	.ndo_start_xmit		= ieee80211_xmit,
+	.ndo_start_xmit		= ieee80211_rtl_xmit,
 };
 
 static int __devinit rtl8180_pci_probe(struct pci_dev *pdev,
@@ -4066,7 +4066,7 @@
 	spin_unlock_irqrestore(&priv->tx_lock,flags);
 
 	if(enough_desc)
-		ieee80211_wake_queue(priv->ieee80211);
+		ieee80211_rtl_wake_queue(priv->ieee80211);
 }
 
 void rtl8180_tx_isr(struct net_device *dev, int pri,short error)
diff -Nur linux-2.6.32-orig/drivers/staging/rtl8187se/r8180_wx.c iDroid-Project-kernel_common-9e90fd2/drivers/staging/rtl8187se/r8180_wx.c
--- linux-2.6.32-orig/drivers/staging/rtl8187se/r8180_wx.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/staging/rtl8187se/r8180_wx.c	2010-11-18 21:05:30.000000000 +0600
@@ -377,7 +377,7 @@
 	//	queue_work(priv->ieee80211->wq, &priv->ieee80211->wx_sync_scan_wq);
 		//printk("start scan============================>\n");
 		ieee80211_softmac_ips_scan_syncro(priv->ieee80211);
-//ieee80211_start_scan(priv->ieee80211);
+//ieee80211_rtl_start_scan(priv->ieee80211);
 		/* intentionally forget to up sem */
 //			up(&priv->ieee80211->wx_sem);
 			ret = 0;
diff -Nur linux-2.6.32-orig/drivers/switch/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/switch/Kconfig
--- linux-2.6.32-orig/drivers/switch/Kconfig	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/switch/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,15 @@
+menuconfig SWITCH
+	tristate "Switch class support"
+	help
+	  Say Y here to enable switch class support. This allows
+	  monitoring switches by userspace via sysfs and uevent.
+
+if SWITCH
+
+config SWITCH_GPIO
+	tristate "GPIO Swith support"
+	depends on GENERIC_GPIO
+	help
+	  Say Y here to enable GPIO based switch support.
+
+endif # SWITCH
diff -Nur linux-2.6.32-orig/drivers/switch/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/switch/Makefile
--- linux-2.6.32-orig/drivers/switch/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/switch/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,4 @@
+# Switch Class Driver
+obj-$(CONFIG_SWITCH)		+= switch_class.o
+obj-$(CONFIG_SWITCH_GPIO)	+= switch_gpio.o
+
diff -Nur linux-2.6.32-orig/drivers/switch/switch_class.c iDroid-Project-kernel_common-9e90fd2/drivers/switch/switch_class.c
--- linux-2.6.32-orig/drivers/switch/switch_class.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/switch/switch_class.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,174 @@
+/*
+ *  drivers/switch/switch_class.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/err.h>
+#include <linux/switch.h>
+
+struct class *switch_class;
+static atomic_t device_count;
+
+static ssize_t state_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct switch_dev *sdev = (struct switch_dev *)
+		dev_get_drvdata(dev);
+
+	if (sdev->print_state) {
+		int ret = sdev->print_state(sdev, buf);
+		if (ret >= 0)
+			return ret;
+	}
+	return sprintf(buf, "%d\n", sdev->state);
+}
+
+static ssize_t name_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct switch_dev *sdev = (struct switch_dev *)
+		dev_get_drvdata(dev);
+
+	if (sdev->print_name) {
+		int ret = sdev->print_name(sdev, buf);
+		if (ret >= 0)
+			return ret;
+	}
+	return sprintf(buf, "%s\n", sdev->name);
+}
+
+static DEVICE_ATTR(state, S_IRUGO | S_IWUSR, state_show, NULL);
+static DEVICE_ATTR(name, S_IRUGO | S_IWUSR, name_show, NULL);
+
+void switch_set_state(struct switch_dev *sdev, int state)
+{
+	char name_buf[120];
+	char state_buf[120];
+	char *prop_buf;
+	char *envp[3];
+	int env_offset = 0;
+	int length;
+
+	if (sdev->state != state) {
+		sdev->state = state;
+
+		prop_buf = (char *)get_zeroed_page(GFP_KERNEL);
+		if (prop_buf) {
+			length = name_show(sdev->dev, NULL, prop_buf);
+			if (length > 0) {
+				if (prop_buf[length - 1] == '\n')
+					prop_buf[length - 1] = 0;
+				snprintf(name_buf, sizeof(name_buf),
+					"SWITCH_NAME=%s", prop_buf);
+				envp[env_offset++] = name_buf;
+			}
+			length = state_show(sdev->dev, NULL, prop_buf);
+			if (length > 0) {
+				if (prop_buf[length - 1] == '\n')
+					prop_buf[length - 1] = 0;
+				snprintf(state_buf, sizeof(state_buf),
+					"SWITCH_STATE=%s", prop_buf);
+				envp[env_offset++] = state_buf;
+			}
+			envp[env_offset] = NULL;
+			kobject_uevent_env(&sdev->dev->kobj, KOBJ_CHANGE, envp);
+			free_page((unsigned long)prop_buf);
+		} else {
+			printk(KERN_ERR "out of memory in switch_set_state\n");
+			kobject_uevent(&sdev->dev->kobj, KOBJ_CHANGE);
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(switch_set_state);
+
+static int create_switch_class(void)
+{
+	if (!switch_class) {
+		switch_class = class_create(THIS_MODULE, "switch");
+		if (IS_ERR(switch_class))
+			return PTR_ERR(switch_class);
+		atomic_set(&device_count, 0);
+	}
+
+	return 0;
+}
+
+int switch_dev_register(struct switch_dev *sdev)
+{
+	int ret;
+
+	if (!switch_class) {
+		ret = create_switch_class();
+		if (ret < 0)
+			return ret;
+	}
+
+	sdev->index = atomic_inc_return(&device_count);
+	sdev->dev = device_create(switch_class, NULL,
+		MKDEV(0, sdev->index), NULL, sdev->name);
+	if (IS_ERR(sdev->dev))
+		return PTR_ERR(sdev->dev);
+
+	ret = device_create_file(sdev->dev, &dev_attr_state);
+	if (ret < 0)
+		goto err_create_file_1;
+	ret = device_create_file(sdev->dev, &dev_attr_name);
+	if (ret < 0)
+		goto err_create_file_2;
+
+	dev_set_drvdata(sdev->dev, sdev);
+	sdev->state = 0;
+	return 0;
+
+err_create_file_2:
+	device_remove_file(sdev->dev, &dev_attr_state);
+err_create_file_1:
+	device_destroy(switch_class, MKDEV(0, sdev->index));
+	printk(KERN_ERR "switch: Failed to register driver %s\n", sdev->name);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(switch_dev_register);
+
+void switch_dev_unregister(struct switch_dev *sdev)
+{
+	device_remove_file(sdev->dev, &dev_attr_name);
+	device_remove_file(sdev->dev, &dev_attr_state);
+	device_destroy(switch_class, MKDEV(0, sdev->index));
+	dev_set_drvdata(sdev->dev, NULL);
+}
+EXPORT_SYMBOL_GPL(switch_dev_unregister);
+
+static int __init switch_class_init(void)
+{
+	return create_switch_class();
+}
+
+static void __exit switch_class_exit(void)
+{
+	class_destroy(switch_class);
+}
+
+module_init(switch_class_init);
+module_exit(switch_class_exit);
+
+MODULE_AUTHOR("Mike Lockwood <lockwood@android.com>");
+MODULE_DESCRIPTION("Switch class driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/drivers/switch/switch_gpio.c iDroid-Project-kernel_common-9e90fd2/drivers/switch/switch_gpio.c
--- linux-2.6.32-orig/drivers/switch/switch_gpio.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/switch/switch_gpio.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,176 @@
+/*
+ *  drivers/switch/switch_gpio.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/switch.h>
+#include <linux/workqueue.h>
+#include <linux/gpio.h>
+
+struct gpio_switch_data {
+	struct switch_dev sdev;
+	unsigned gpio;
+	const char *name_on;
+	const char *name_off;
+	const char *state_on;
+	const char *state_off;
+	int irq;
+	struct work_struct work;
+};
+
+static void gpio_switch_work(struct work_struct *work)
+{
+	int state;
+	struct gpio_switch_data	*data =
+		container_of(work, struct gpio_switch_data, work);
+
+	state = gpio_get_value(data->gpio);
+	switch_set_state(&data->sdev, state);
+}
+
+static irqreturn_t gpio_irq_handler(int irq, void *dev_id)
+{
+	struct gpio_switch_data *switch_data =
+	    (struct gpio_switch_data *)dev_id;
+
+	schedule_work(&switch_data->work);
+	return IRQ_HANDLED;
+}
+
+static ssize_t switch_gpio_print_state(struct switch_dev *sdev, char *buf)
+{
+	struct gpio_switch_data	*switch_data =
+		container_of(sdev, struct gpio_switch_data, sdev);
+	const char *state;
+	if (switch_get_state(sdev))
+		state = switch_data->state_on;
+	else
+		state = switch_data->state_off;
+
+	if (state)
+		return sprintf(buf, "%s\n", state);
+	return -1;
+}
+
+static int gpio_switch_probe(struct platform_device *pdev)
+{
+	struct gpio_switch_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_switch_data *switch_data;
+	int irq_flags;
+	int ret = 0;
+
+	if (!pdata)
+		return -EBUSY;
+
+	switch_data = kzalloc(sizeof(struct gpio_switch_data), GFP_KERNEL);
+	if (!switch_data)
+		return -ENOMEM;
+
+	switch_data->sdev.name = pdata->name;
+	switch_data->gpio = pdata->gpio;
+	switch_data->name_on = pdata->name_on;
+	switch_data->name_off = pdata->name_off;
+	switch_data->state_on = pdata->state_on;
+	switch_data->state_off = pdata->state_off;
+	switch_data->sdev.print_state = switch_gpio_print_state;
+	irq_flags = pdata->irq_flags;
+
+	if(!irq_flags)
+		irq_flags = IRQF_TRIGGER_LOW;
+
+    ret = switch_dev_register(&switch_data->sdev);
+	if (ret < 0)
+		goto err_switch_dev_register;
+
+	ret = gpio_request(switch_data->gpio, pdev->name);
+	if (ret < 0)
+		goto err_request_gpio;
+
+	ret = gpio_direction_input(switch_data->gpio);
+	if (ret < 0)
+		goto err_set_gpio_input;
+
+	INIT_WORK(&switch_data->work, gpio_switch_work);
+
+	switch_data->irq = gpio_to_irq(switch_data->gpio);
+	if (switch_data->irq < 0) {
+		ret = switch_data->irq;
+		goto err_detect_irq_num_failed;
+	}
+
+	ret = request_irq(switch_data->irq, gpio_irq_handler,
+			  irq_flags, pdev->name, switch_data);
+	if (ret < 0)
+		goto err_request_irq;
+
+	/* Perform initial detection */
+	gpio_switch_work(&switch_data->work);
+
+	return 0;
+
+err_request_irq:
+err_detect_irq_num_failed:
+err_set_gpio_input:
+	gpio_free(switch_data->gpio);
+err_request_gpio:
+    switch_dev_unregister(&switch_data->sdev);
+err_switch_dev_register:
+	kfree(switch_data);
+
+	return ret;
+}
+
+static int __devexit gpio_switch_remove(struct platform_device *pdev)
+{
+	struct gpio_switch_data *switch_data = platform_get_drvdata(pdev);
+
+	cancel_work_sync(&switch_data->work);
+	gpio_free(switch_data->gpio);
+    switch_dev_unregister(&switch_data->sdev);
+	kfree(switch_data);
+
+	return 0;
+}
+
+static struct platform_driver gpio_switch_driver = {
+	.probe		= gpio_switch_probe,
+	.remove		= __devexit_p(gpio_switch_remove),
+	.driver		= {
+		.name	= "switch-gpio",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init gpio_switch_init(void)
+{
+	return platform_driver_register(&gpio_switch_driver);
+}
+
+static void __exit gpio_switch_exit(void)
+{
+	platform_driver_unregister(&gpio_switch_driver);
+}
+
+module_init(gpio_switch_init);
+module_exit(gpio_switch_exit);
+
+MODULE_AUTHOR("Mike Lockwood <lockwood@android.com>");
+MODULE_DESCRIPTION("GPIO Switch driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/drivers/usb/class/usbtmc.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/class/usbtmc.c
--- linux-2.6.32-orig/drivers/usb/class/usbtmc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/class/usbtmc.c	2010-11-18 21:05:30.000000000 +0600
@@ -562,10 +562,16 @@
 		n_bytes = roundup(12 + this_part, 4);
 		memset(buffer + 12 + this_part, 0, n_bytes - (12 + this_part));
 
-		retval = usb_bulk_msg(data->usb_dev,
-				      usb_sndbulkpipe(data->usb_dev,
-						      data->bulk_out),
-				      buffer, n_bytes, &actual, USBTMC_TIMEOUT);
+		do {
+			retval = usb_bulk_msg(data->usb_dev,
+					      usb_sndbulkpipe(data->usb_dev,
+							      data->bulk_out),
+					      buffer, n_bytes,
+					      &actual, USBTMC_TIMEOUT);
+			if (retval != 0)
+				break;
+			n_bytes -= actual;
+		} while (n_bytes);
 
 		data->bTag_last_write = data->bTag;
 		data->bTag++;
diff -Nur linux-2.6.32-orig/drivers/usb/core/devices.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/core/devices.c
--- linux-2.6.32-orig/drivers/usb/core/devices.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/core/devices.c	2010-11-18 21:05:30.000000000 +0600
@@ -494,7 +494,7 @@
 		return 0;
 	/* allocate 2^1 pages = 8K (on i386);
 	 * should be more than enough for one device */
-	pages_start = (char *)__get_free_pages(GFP_KERNEL, 1);
+	pages_start = (char *)__get_free_pages(GFP_NOIO, 1);
 	if (!pages_start)
 		return -ENOMEM;
 
diff -Nur linux-2.6.32-orig/drivers/usb/core/devio.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/core/devio.c
--- linux-2.6.32-orig/drivers/usb/core/devio.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/core/devio.c	2010-11-18 21:05:30.000000000 +0600
@@ -1312,9 +1312,9 @@
 	void __user *addr = as->userurb;
 	unsigned int i;
 
-	if (as->userbuffer)
+	if (as->userbuffer && urb->actual_length)
 		if (copy_to_user(as->userbuffer, urb->transfer_buffer,
-				 urb->transfer_buffer_length))
+				 urb->actual_length))
 			goto err_out;
 	if (put_user(as->status, &userurb->status))
 		goto err_out;
@@ -1334,14 +1334,11 @@
 		}
 	}
 
-	free_async(as);
-
 	if (put_user(addr, (void __user * __user *)arg))
 		return -EFAULT;
 	return 0;
 
 err_out:
-	free_async(as);
 	return -EFAULT;
 }
 
@@ -1371,8 +1368,11 @@
 static int proc_reapurb(struct dev_state *ps, void __user *arg)
 {
 	struct async *as = reap_as(ps);
-	if (as)
-		return processcompl(as, (void __user * __user *)arg);
+	if (as) {
+		int retval = processcompl(as, (void __user * __user *)arg);
+		free_async(as);
+		return retval;
+	}
 	if (signal_pending(current))
 		return -EINTR;
 	return -EIO;
@@ -1380,11 +1380,16 @@
 
 static int proc_reapurbnonblock(struct dev_state *ps, void __user *arg)
 {
+	int retval;
 	struct async *as;
 
-	if (!(as = async_getcompleted(ps)))
-		return -EAGAIN;
-	return processcompl(as, (void __user * __user *)arg);
+	as = async_getcompleted(ps);
+	retval = -EAGAIN;
+	if (as) {
+		retval = processcompl(as, (void __user * __user *)arg);
+		free_async(as);
+	}
+	return retval;
 }
 
 #ifdef CONFIG_COMPAT
@@ -1435,9 +1440,9 @@
 	void __user *addr = as->userurb;
 	unsigned int i;
 
-	if (as->userbuffer)
+	if (as->userbuffer && urb->actual_length)
 		if (copy_to_user(as->userbuffer, urb->transfer_buffer,
-				 urb->transfer_buffer_length))
+				 urb->actual_length))
 			return -EFAULT;
 	if (put_user(as->status, &userurb->status))
 		return -EFAULT;
@@ -1457,7 +1462,6 @@
 		}
 	}
 
-	free_async(as);
 	if (put_user(ptr_to_compat(addr), (u32 __user *)arg))
 		return -EFAULT;
 	return 0;
@@ -1466,8 +1470,11 @@
 static int proc_reapurb_compat(struct dev_state *ps, void __user *arg)
 {
 	struct async *as = reap_as(ps);
-	if (as)
-		return processcompl_compat(as, (void __user * __user *)arg);
+	if (as) {
+		int retval = processcompl_compat(as, (void __user * __user *)arg);
+		free_async(as);
+		return retval;
+	}
 	if (signal_pending(current))
 		return -EINTR;
 	return -EIO;
@@ -1475,11 +1482,16 @@
 
 static int proc_reapurbnonblock_compat(struct dev_state *ps, void __user *arg)
 {
+	int retval;
 	struct async *as;
 
-	if (!(as = async_getcompleted(ps)))
-		return -EAGAIN;
-	return processcompl_compat(as, (void __user * __user *)arg);
+	retval = -EAGAIN;
+	as = async_getcompleted(ps);
+	if (as) {
+		retval = processcompl_compat(as, (void __user * __user *)arg);
+		free_async(as);
+	}
+	return retval;
 }
 
 #endif
diff -Nur linux-2.6.32-orig/drivers/usb/core/hub.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/core/hub.c
--- linux-2.6.32-orig/drivers/usb/core/hub.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/core/hub.c	2010-11-18 21:05:30.000000000 +0600
@@ -1612,12 +1612,12 @@
 #endif
 
 /**
- * usb_configure_device_otg - FIXME (usbcore-internal)
+ * usb_enumerate_device_otg - FIXME (usbcore-internal)
  * @udev: newly addressed device (in ADDRESS state)
  *
- * Do configuration for On-The-Go devices
+ * Finish enumeration for On-The-Go devices
  */
-static int usb_configure_device_otg(struct usb_device *udev)
+static int usb_enumerate_device_otg(struct usb_device *udev)
 {
 	int err = 0;
 
@@ -1688,7 +1688,7 @@
 
 
 /**
- * usb_configure_device - Detect and probe device intfs/otg (usbcore-internal)
+ * usb_enumerate_device - Read device configs/intfs/otg (usbcore-internal)
  * @udev: newly addressed device (in ADDRESS state)
  *
  * This is only called by usb_new_device() and usb_authorize_device()
@@ -1699,7 +1699,7 @@
  * the string descriptors, as they will be errored out by the device
  * until it has been authorized.
  */
-static int usb_configure_device(struct usb_device *udev)
+static int usb_enumerate_device(struct usb_device *udev)
 {
 	int err;
 
@@ -1723,7 +1723,7 @@
 						      udev->descriptor.iManufacturer);
 		udev->serial = usb_cache_string(udev, udev->descriptor.iSerialNumber);
 	}
-	err = usb_configure_device_otg(udev);
+	err = usb_enumerate_device_otg(udev);
 fail:
 	return err;
 }
@@ -1733,8 +1733,8 @@
  * usb_new_device - perform initial device setup (usbcore-internal)
  * @udev: newly addressed device (in ADDRESS state)
  *
- * This is called with devices which have been enumerated, but not yet
- * configured.  The device descriptor is available, but not descriptors
+ * This is called with devices which have been detected but not fully
+ * enumerated.  The device descriptor is available, but not descriptors
  * for any device configuration.  The caller must have locked either
  * the parent hub (if udev is a normal device) or else the
  * usb_bus_list_lock (if udev is a root hub).  The parent's pointer to
@@ -1757,8 +1757,8 @@
 	if (udev->parent)
 		usb_autoresume_device(udev->parent);
 
-	usb_detect_quirks(udev);		/* Determine quirks */
-	err = usb_configure_device(udev);	/* detect & probe dev/intfs */
+	usb_detect_quirks(udev);
+	err = usb_enumerate_device(udev);	/* Read descriptors */
 	if (err < 0)
 		goto fail;
 	dev_dbg(&udev->dev, "udev %d, busnum %d, minor = %d\n",
@@ -1803,21 +1803,23 @@
  */
 int usb_deauthorize_device(struct usb_device *usb_dev)
 {
-	unsigned cnt;
 	usb_lock_device(usb_dev);
 	if (usb_dev->authorized == 0)
 		goto out_unauthorized;
+
 	usb_dev->authorized = 0;
 	usb_set_configuration(usb_dev, -1);
+
+	kfree(usb_dev->product);
 	usb_dev->product = kstrdup("n/a (unauthorized)", GFP_KERNEL);
+	kfree(usb_dev->manufacturer);
 	usb_dev->manufacturer = kstrdup("n/a (unauthorized)", GFP_KERNEL);
+	kfree(usb_dev->serial);
 	usb_dev->serial = kstrdup("n/a (unauthorized)", GFP_KERNEL);
-	kfree(usb_dev->config);
-	usb_dev->config = NULL;
-	for (cnt = 0; cnt < usb_dev->descriptor.bNumConfigurations; cnt++)
-		kfree(usb_dev->rawdescriptors[cnt]);
+
+	usb_destroy_configuration(usb_dev);
 	usb_dev->descriptor.bNumConfigurations = 0;
-	kfree(usb_dev->rawdescriptors);
+
 out_unauthorized:
 	usb_unlock_device(usb_dev);
 	return 0;
@@ -1827,15 +1829,11 @@
 int usb_authorize_device(struct usb_device *usb_dev)
 {
 	int result = 0, c;
+
 	usb_lock_device(usb_dev);
 	if (usb_dev->authorized == 1)
 		goto out_authorized;
-	kfree(usb_dev->product);
-	usb_dev->product = NULL;
-	kfree(usb_dev->manufacturer);
-	usb_dev->manufacturer = NULL;
-	kfree(usb_dev->serial);
-	usb_dev->serial = NULL;
+
 	result = usb_autoresume_device(usb_dev);
 	if (result < 0) {
 		dev_err(&usb_dev->dev,
@@ -1848,10 +1846,18 @@
 			"authorization: %d\n", result);
 		goto error_device_descriptor;
 	}
+
+	kfree(usb_dev->product);
+	usb_dev->product = NULL;
+	kfree(usb_dev->manufacturer);
+	usb_dev->manufacturer = NULL;
+	kfree(usb_dev->serial);
+	usb_dev->serial = NULL;
+
 	usb_dev->authorized = 1;
-	result = usb_configure_device(usb_dev);
+	result = usb_enumerate_device(usb_dev);
 	if (result < 0)
-		goto error_configure;
+		goto error_enumerate;
 	/* Choose and set the configuration.  This registers the interfaces
 	 * with the driver core and lets interface drivers bind to them.
 	 */
@@ -1866,8 +1872,10 @@
 		}
 	}
 	dev_info(&usb_dev->dev, "authorized to connect\n");
-error_configure:
+
+error_enumerate:
 error_device_descriptor:
+	usb_autosuspend_device(usb_dev);
 error_autoresume:
 out_authorized:
 	usb_unlock_device(usb_dev);	// complements locktree
@@ -3278,6 +3286,9 @@
 					USB_PORT_FEAT_C_SUSPEND);
 				udev = hdev->children[i-1];
 				if (udev) {
+					/* TRSMRCY = 10 msec */
+					msleep(10);
+
 					usb_lock_device(udev);
 					ret = remote_wakeup(hdev->
 							children[i-1]);
diff -Nur linux-2.6.32-orig/drivers/usb/core/message.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/core/message.c
--- linux-2.6.32-orig/drivers/usb/core/message.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/core/message.c	2010-11-18 21:05:30.000000000 +0600
@@ -911,11 +911,11 @@
 	if (index <= 0)
 		return NULL;
 
-	buf = kmalloc(MAX_USB_STRING_SIZE, GFP_KERNEL);
+	buf = kmalloc(MAX_USB_STRING_SIZE, GFP_NOIO);
 	if (buf) {
 		len = usb_string(udev, index, buf, MAX_USB_STRING_SIZE);
 		if (len > 0) {
-			smallbuf = kmalloc(++len, GFP_KERNEL);
+			smallbuf = kmalloc(++len, GFP_NOIO);
 			if (!smallbuf)
 				return buf;
 			memcpy(smallbuf, buf, len);
@@ -1682,7 +1682,7 @@
 	if (cp) {
 		nintf = cp->desc.bNumInterfaces;
 		new_interfaces = kmalloc(nintf * sizeof(*new_interfaces),
-				GFP_KERNEL);
+				GFP_NOIO);
 		if (!new_interfaces) {
 			dev_err(&dev->dev, "Out of memory\n");
 			return -ENOMEM;
@@ -1691,7 +1691,7 @@
 		for (; n < nintf; ++n) {
 			new_interfaces[n] = kzalloc(
 					sizeof(struct usb_interface),
-					GFP_KERNEL);
+					GFP_NOIO);
 			if (!new_interfaces[n]) {
 				dev_err(&dev->dev, "Out of memory\n");
 				ret = -ENOMEM;
diff -Nur linux-2.6.32-orig/drivers/usb/core/sysfs.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/core/sysfs.c
--- linux-2.6.32-orig/drivers/usb/core/sysfs.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/core/sysfs.c	2010-11-18 21:05:30.000000000 +0600
@@ -82,9 +82,13 @@
 		struct device_attribute *attr, char *buf)		\
 {									\
 	struct usb_device *udev;					\
+	int retval;							\
 									\
 	udev = to_usb_device(dev);					\
-	return sprintf(buf, "%s\n", udev->name);			\
+	usb_lock_device(udev);						\
+	retval = sprintf(buf, "%s\n", udev->name);			\
+	usb_unlock_device(udev);					\
+	return retval;							\
 }									\
 static DEVICE_ATTR(name, S_IRUGO, show_##name, NULL);
 
@@ -111,6 +115,12 @@
 	case USB_SPEED_HIGH:
 		speed = "480";
 		break;
+	case USB_SPEED_VARIABLE:
+		speed = "480";
+		break;
+	case USB_SPEED_SUPER:
+		speed = "5000";
+		break;
 	default:
 		speed = "unknown";
 	}
diff -Nur linux-2.6.32-orig/drivers/usb/core/usb.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/core/usb.c
--- linux-2.6.32-orig/drivers/usb/core/usb.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/core/usb.c	2010-11-18 21:05:30.000000000 +0600
@@ -132,7 +132,7 @@
 
 struct find_interface_arg {
 	int minor;
-	struct usb_interface *interface;
+	struct device_driver *drv;
 };
 
 static int __find_interface(struct device *dev, void *data)
@@ -143,12 +143,10 @@
 	if (!is_usb_interface(dev))
 		return 0;
 
+	if (dev->driver != arg->drv)
+		return 0;
 	intf = to_usb_interface(dev);
-	if (intf->minor != -1 && intf->minor == arg->minor) {
-		arg->interface = intf;
-		return 1;
-	}
-	return 0;
+	return intf->minor == arg->minor;
 }
 
 /**
@@ -156,21 +154,24 @@
  * @drv: the driver whose current configuration is considered
  * @minor: the minor number of the desired device
  *
- * This walks the driver device list and returns a pointer to the interface
- * with the matching minor.  Note, this only works for devices that share the
- * USB major number.
+ * This walks the bus device list and returns a pointer to the interface
+ * with the matching minor and driver.  Note, this only works for devices
+ * that share the USB major number.
  */
 struct usb_interface *usb_find_interface(struct usb_driver *drv, int minor)
 {
 	struct find_interface_arg argb;
-	int retval;
+	struct device *dev;
 
 	argb.minor = minor;
-	argb.interface = NULL;
-	/* eat the error, it will be in argb.interface */
-	retval = driver_for_each_device(&drv->drvwrap.driver, NULL, &argb,
-					__find_interface);
-	return argb.interface;
+	argb.drv = &drv->drvwrap.driver;
+
+	dev = bus_find_device(&usb_bus_type, NULL, &argb, __find_interface);
+
+	/* Drop reference count from bus_find_device */
+	put_device(dev);
+
+	return dev ? to_usb_interface(dev) : NULL;
 }
 EXPORT_SYMBOL_GPL(usb_find_interface);
 
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/android.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/android.c
--- linux-2.6.32-orig/drivers/usb/gadget/android.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/android.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,436 @@
+/*
+ * Gadget Driver for Android
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/utsname.h>
+#include <linux/platform_device.h>
+
+#include <linux/usb/android_composite.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/composite.h>
+#include <linux/usb/gadget.h>
+
+#include "gadget_chips.h"
+
+/*
+ * Kbuild is not very cooperative with respect to linking separately
+ * compiled library objects into one module.  So for now we won't use
+ * separate compilation ... ensuring init/exit sections work to shrink
+ * the runtime footprint, and giving us at least some parts of what
+ * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
+ */
+#include "usbstring.c"
+#include "config.c"
+#include "epautoconf.c"
+#include "composite.c"
+
+MODULE_AUTHOR("Mike Lockwood");
+MODULE_DESCRIPTION("Android Composite USB Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+static const char longname[] = "Gadget Android";
+
+/* Default vendor and product IDs, overridden by platform data */
+#define VENDOR_ID		0x18D1
+#define PRODUCT_ID		0x0001
+
+struct android_dev {
+	struct usb_composite_dev *cdev;
+	struct usb_configuration *config;
+	int num_products;
+	struct android_usb_product *products;
+	int num_functions;
+	char **functions;
+
+	int product_id;
+	int version;
+};
+
+static struct android_dev *_android_dev;
+
+/* string IDs are assigned dynamically */
+
+#define STRING_MANUFACTURER_IDX		0
+#define STRING_PRODUCT_IDX		1
+#define STRING_SERIAL_IDX		2
+
+/* String Table */
+static struct usb_string strings_dev[] = {
+	/* These dummy values should be overridden by platform data */
+	[STRING_MANUFACTURER_IDX].s = "Android",
+	[STRING_PRODUCT_IDX].s = "Android",
+	[STRING_SERIAL_IDX].s = "0123456789ABCDEF",
+	{  }			/* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language	= 0x0409,	/* en-us */
+	.strings	= strings_dev,
+};
+
+static struct usb_gadget_strings *dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+static struct usb_device_descriptor device_desc = {
+	.bLength              = sizeof(device_desc),
+	.bDescriptorType      = USB_DT_DEVICE,
+	.bcdUSB               = __constant_cpu_to_le16(0x0200),
+	.bDeviceClass         = USB_CLASS_PER_INTERFACE,
+	.idVendor             = __constant_cpu_to_le16(VENDOR_ID),
+	.idProduct            = __constant_cpu_to_le16(PRODUCT_ID),
+	.bcdDevice            = __constant_cpu_to_le16(0xffff),
+	.bNumConfigurations   = 1,
+};
+
+static struct list_head _functions = LIST_HEAD_INIT(_functions);
+static int _registered_function_count = 0;
+
+void android_usb_set_connected(int connected)
+{
+	if (_android_dev && _android_dev->cdev && _android_dev->cdev->gadget) {
+		if (connected)
+			usb_gadget_connect(_android_dev->cdev->gadget);
+		else
+			usb_gadget_disconnect(_android_dev->cdev->gadget);
+	}
+}
+
+static struct android_usb_function *get_function(const char *name)
+{
+	struct android_usb_function	*f;
+	list_for_each_entry(f, &_functions, list) {
+		if (!strcmp(name, f->name))
+			return f;
+	}
+	return 0;
+}
+
+static void bind_functions(struct android_dev *dev)
+{
+	struct android_usb_function	*f;
+	char **functions = dev->functions;
+	int i;
+
+	printk("android: binding USB functions...\n");
+
+	for (i = 0; i < dev->num_functions; i++) {
+		char *name = *functions++;
+		f = get_function(name);
+		if (f)
+			f->bind_config(dev->config);
+		else
+			printk(KERN_ERR "function %s not found in bind_functions\n", name);
+	}
+
+	printk("android: functions bound...\n");
+}
+
+static int __init android_bind_config(struct usb_configuration *c)
+{
+	struct android_dev *dev = _android_dev;
+
+	printk(KERN_DEBUG "android_bind_config\n");
+	dev->config = c;
+
+	/* bind our functions if they have all registered */
+	if (_registered_function_count == dev->num_functions)
+		bind_functions(dev);
+
+	return 0;
+}
+
+static int android_setup_config(struct usb_configuration *c,
+		const struct usb_ctrlrequest *ctrl);
+
+static struct usb_configuration android_config_driver = {
+	.label		= "android",
+	.bind		= android_bind_config,
+	.setup		= android_setup_config,
+	.bConfigurationValue = 1,
+	.bmAttributes	= USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
+	.bMaxPower	= 0xFA, /* 500ma */
+};
+
+static int android_setup_config(struct usb_configuration *c,
+		const struct usb_ctrlrequest *ctrl)
+{
+	int i;
+	int ret = -EOPNOTSUPP;
+
+	for (i = 0; i < android_config_driver.next_interface_id; i++) {
+		if (android_config_driver.interface[i]->setup) {
+			ret = android_config_driver.interface[i]->setup(
+				android_config_driver.interface[i], ctrl);
+			if (ret >= 0)
+				return ret;
+		}
+	}
+	return ret;
+}
+
+static int product_has_function(struct android_usb_product *p,
+		struct usb_function *f)
+{
+	char **functions = p->functions;
+	int count = p->num_functions;
+	const char *name = f->name;
+	int i;
+
+	for (i = 0; i < count; i++) {
+		if (!strcmp(name, *functions++))
+			return 1;
+	}
+	return 0;
+}
+
+static int product_matches_functions(struct android_usb_product *p)
+{
+	struct usb_function		*f;
+	list_for_each_entry(f, &android_config_driver.functions, list) {
+		if (product_has_function(p, f) == !!f->disabled)
+			return 0;
+	}
+	return 1;
+}
+
+static int get_product_id(struct android_dev *dev)
+{
+	struct android_usb_product *p = dev->products;
+	int count = dev->num_products;
+	int i;
+
+	if (p) {
+		for (i = 0; i < count; i++, p++) {
+			if (product_matches_functions(p))
+				return p->product_id;
+		}
+	}
+	/* use default product ID */
+	return dev->product_id;
+}
+
+static int __init android_bind(struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+	struct usb_gadget	*gadget = cdev->gadget;
+	int			gcnum, id, product_id, ret;
+
+	printk(KERN_INFO "android_bind\n");
+
+	/* Allocate string descriptor numbers ... note that string
+	 * contents can be overridden by the composite_dev glue.
+	 */
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_MANUFACTURER_IDX].id = id;
+	device_desc.iManufacturer = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_PRODUCT_IDX].id = id;
+	device_desc.iProduct = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_SERIAL_IDX].id = id;
+	device_desc.iSerialNumber = id;
+
+	if (gadget->ops->wakeup)
+		android_config_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+
+	/* register our configuration */
+	ret = usb_add_config(cdev, &android_config_driver);
+	if (ret) {
+		printk(KERN_ERR "usb_add_config failed\n");
+		return ret;
+	}
+
+	gcnum = usb_gadget_controller_number(gadget);
+	if (gcnum >= 0)
+		device_desc.bcdDevice = cpu_to_le16(0x0200 + gcnum);
+	else {
+		/* gadget zero is so simple (for now, no altsettings) that
+		 * it SHOULD NOT have problems with bulk-capable hardware.
+		 * so just warn about unrcognized controllers -- don't panic.
+		 *
+		 * things like configuration and altsetting numbering
+		 * can need hardware-specific attention though.
+		 */
+		pr_warning("%s: controller '%s' not recognized\n",
+			longname, gadget->name);
+		device_desc.bcdDevice = __constant_cpu_to_le16(0x9999);
+	}
+
+	usb_gadget_set_selfpowered(gadget);
+	dev->cdev = cdev;
+	product_id = get_product_id(dev);
+	device_desc.idProduct = __constant_cpu_to_le16(product_id);
+	cdev->desc.idProduct = device_desc.idProduct;
+
+	return 0;
+}
+
+static struct usb_composite_driver android_usb_driver = {
+	.name		= "android_usb",
+	.dev		= &device_desc,
+	.strings	= dev_strings,
+	.bind		= android_bind,
+	.enable_function = android_enable_function,
+};
+
+void android_register_function(struct android_usb_function *f)
+{
+	struct android_dev *dev = _android_dev;
+
+	printk(KERN_INFO "android_register_function %s\n", f->name);
+	list_add_tail(&f->list, &_functions);
+	_registered_function_count++;
+
+	printk("android: %d of %d USB functions loaded.", _registered_function_count, dev->num_functions);
+
+	/* bind our functions if they have all registered
+	 * and the main driver has bound.
+	 */
+	if (dev && dev->config && _registered_function_count == dev->num_functions)
+		bind_functions(dev);
+}
+
+void android_enable_function(struct usb_function *f, int enable)
+{
+	struct android_dev *dev = _android_dev;
+	int disable = !enable;
+	int product_id;
+
+	if (!!f->disabled != disable) {
+		usb_function_set_enabled(f, !disable);
+
+#ifdef CONFIG_USB_ANDROID_RNDIS
+		if (!strcmp(f->name, "rndis")) {
+			struct usb_function		*func;
+
+			/* We need to specify the COMM class in the device descriptor
+			 * if we are using RNDIS.
+			 */
+			if (enable)
+#ifdef CONFIG_USB_ANDROID_RNDIS_WCEIS
+				dev->cdev->desc.bDeviceClass = USB_CLASS_WIRELESS_CONTROLLER;
+#else
+				dev->cdev->desc.bDeviceClass = USB_CLASS_COMM;
+#endif
+			else
+				dev->cdev->desc.bDeviceClass = USB_CLASS_PER_INTERFACE;
+
+			/* Windows does not support other interfaces when RNDIS is enabled,
+			 * so we disable UMS when RNDIS is on.
+			 */
+			list_for_each_entry(func, &android_config_driver.functions, list) {
+				if (!strcmp(func->name, "usb_mass_storage")) {
+					usb_function_set_enabled(func, !enable);
+					break;
+				}
+			}
+		}
+#endif
+
+		product_id = get_product_id(dev);
+		device_desc.idProduct = __constant_cpu_to_le16(product_id);
+		if (dev->cdev)
+			dev->cdev->desc.idProduct = device_desc.idProduct;
+		usb_composite_force_reset(dev->cdev);
+	}
+}
+
+static int __init android_probe(struct platform_device *pdev)
+{
+	struct android_usb_platform_data *pdata = pdev->dev.platform_data;
+	struct android_dev *dev = _android_dev;
+
+	printk(KERN_INFO "android_probe pdata: %p\n", pdata);
+
+	if (pdata) {
+		dev->products = pdata->products;
+		dev->num_products = pdata->num_products;
+		dev->functions = pdata->functions;
+		dev->num_functions = pdata->num_functions;
+		if (pdata->vendor_id)
+			device_desc.idVendor =
+				__constant_cpu_to_le16(pdata->vendor_id);
+		if (pdata->product_id) {
+			dev->product_id = pdata->product_id;
+			device_desc.idProduct =
+				__constant_cpu_to_le16(pdata->product_id);
+		}
+		if (pdata->version)
+			dev->version = pdata->version;
+
+		if (pdata->product_name)
+			strings_dev[STRING_PRODUCT_IDX].s = pdata->product_name;
+		if (pdata->manufacturer_name)
+			strings_dev[STRING_MANUFACTURER_IDX].s =
+					pdata->manufacturer_name;
+		if (pdata->serial_number)
+			strings_dev[STRING_SERIAL_IDX].s = pdata->serial_number;
+	}
+
+	return usb_composite_register(&android_usb_driver);
+}
+
+static struct platform_driver android_platform_driver = {
+	.driver = { .name = "android_usb", },
+	.probe = android_probe,
+};
+
+static int __init init(void)
+{
+	struct android_dev *dev;
+
+	printk(KERN_INFO "android init\n");
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	/* set default values, which should be overridden by platform data */
+	dev->product_id = PRODUCT_ID;
+	_android_dev = dev;
+
+	return platform_driver_register(&android_platform_driver);
+}
+module_init(init);
+
+static void __exit cleanup(void)
+{
+	usb_composite_unregister(&android_usb_driver);
+	platform_driver_unregister(&android_platform_driver);
+	kfree(_android_dev);
+	_android_dev = NULL;
+}
+module_exit(cleanup);
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/composite.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/composite.c
--- linux-2.6.32-orig/drivers/usb/gadget/composite.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/composite.c	2010-11-18 21:05:30.000000000 +0600
@@ -24,6 +24,7 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/device.h>
+#include <linux/kdev_t.h>
 
 #include <linux/usb/composite.h>
 
@@ -71,6 +72,59 @@
 
 /*-------------------------------------------------------------------------*/
 
+static ssize_t enable_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct usb_function *f = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", !f->disabled);
+}
+
+static ssize_t enable_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct usb_function *f = dev_get_drvdata(dev);
+	struct usb_composite_driver	*driver = f->config->cdev->driver;
+	int value;
+
+	sscanf(buf, "%d", &value);
+	if (driver->enable_function)
+		driver->enable_function(f, value);
+	else
+		usb_function_set_enabled(f, value);
+
+	return size;
+}
+
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, enable_show, enable_store);
+
+void usb_function_set_enabled(struct usb_function *f, int enabled)
+{
+	f->disabled = !enabled;
+	kobject_uevent(&f->dev->kobj, KOBJ_CHANGE);
+}
+
+
+void usb_composite_force_reset(struct usb_composite_dev *cdev)
+{
+	unsigned long			flags;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	/* force reenumeration */
+	if (cdev && cdev->gadget &&
+			cdev->gadget->speed != USB_SPEED_UNKNOWN) {
+		/* avoid sending a disconnect switch event until after we disconnect */
+		cdev->mute_switch = 1;
+		spin_unlock_irqrestore(&cdev->lock, flags);
+
+		usb_gadget_disconnect(cdev->gadget);
+		msleep(10);
+		usb_gadget_connect(cdev->gadget);
+	} else {
+		spin_unlock_irqrestore(&cdev->lock, flags);
+	}
+}
+
 /**
  * usb_add_function() - add a function to a configuration
  * @config: the configuration
@@ -88,15 +142,30 @@
 int __init usb_add_function(struct usb_configuration *config,
 		struct usb_function *function)
 {
+	struct usb_composite_dev	*cdev = config->cdev;
 	int	value = -EINVAL;
+	int index;
 
-	DBG(config->cdev, "adding '%s'/%p to config '%s'/%p\n",
+	DBG(cdev, "adding '%s'/%p to config '%s'/%p\n",
 			function->name, function,
 			config->label, config);
 
 	if (!function->set_alt || !function->disable)
 		goto done;
 
+	index = atomic_inc_return(&cdev->driver->function_count);
+	function->dev = device_create(cdev->driver->class, NULL,
+		MKDEV(0, index), NULL, function->name);
+	if (IS_ERR(function->dev))
+		return PTR_ERR(function->dev);
+
+	value = device_create_file(function->dev, &dev_attr_enable);
+	if (value < 0) {
+		device_destroy(cdev->driver->class, MKDEV(0, index));
+		return value;
+	}
+	dev_set_drvdata(function->dev, function);
+
 	function->config = config;
 	list_add_tail(&function->list, &config->functions);
 
@@ -122,7 +191,7 @@
 
 done:
 	if (value)
-		DBG(config->cdev, "adding '%s'/%p --> %d\n",
+		DBG(cdev, "adding '%s'/%p --> %d\n",
 				function->name, function, value);
 	return value;
 }
@@ -232,17 +301,19 @@
 		enum usb_device_speed speed, void *buf, u8 type)
 {
 	struct usb_config_descriptor	*c = buf;
+	struct usb_interface_descriptor *intf;
 	void				*next = buf + USB_DT_CONFIG_SIZE;
 	int				len = USB_BUFSIZ - USB_DT_CONFIG_SIZE;
 	struct usb_function		*f;
 	int				status;
+	int				interfaceCount = 0;
+	u8 *dest;
 
 	/* write the config descriptor */
 	c = buf;
 	c->bLength = USB_DT_CONFIG_SIZE;
 	c->bDescriptorType = type;
-	/* wTotalLength is written later */
-	c->bNumInterfaces = config->next_interface_id;
+	/* wTotalLength and bNumInterfaces are written later */
 	c->bConfigurationValue = config->bConfigurationValue;
 	c->iConfiguration = config->iConfiguration;
 	c->bmAttributes = USB_CONFIG_ATT_ONE | config->bmAttributes;
@@ -261,23 +332,40 @@
 	/* add each function's descriptors */
 	list_for_each_entry(f, &config->functions, list) {
 		struct usb_descriptor_header **descriptors;
+		struct usb_descriptor_header *descriptor;
 
 		if (speed == USB_SPEED_HIGH)
 			descriptors = f->hs_descriptors;
 		else
 			descriptors = f->descriptors;
-		if (!descriptors)
+		if (f->disabled || !descriptors || descriptors[0] == NULL)
 			continue;
 		status = usb_descriptor_fillbuf(next, len,
 			(const struct usb_descriptor_header **) descriptors);
 		if (status < 0)
 			return status;
+
+		/* set interface numbers dynamically */
+		dest = next;
+		while ((descriptor = *descriptors++) != NULL) {
+			intf = (struct usb_interface_descriptor *)dest;
+			if (intf->bDescriptorType == USB_DT_INTERFACE) {
+				/* don't increment bInterfaceNumber for alternate settings */
+				if (intf->bAlternateSetting == 0)
+					intf->bInterfaceNumber = interfaceCount++;
+				else
+					intf->bInterfaceNumber = interfaceCount - 1;
+			}
+			dest += intf->bLength;
+		}
+
 		len -= status;
 		next += status;
 	}
 
 	len = next - buf;
 	c->wTotalLength = cpu_to_le16(len);
+	c->bNumInterfaces = interfaceCount;
 	return len;
 }
 
@@ -421,6 +509,8 @@
 
 		if (!f)
 			break;
+		if (f->disabled)
+			continue;
 
 		result = f->set_alt(f, tmp, 0);
 		if (result < 0) {
@@ -436,6 +526,8 @@
 	power = c->bMaxPower ? (2 * c->bMaxPower) : CONFIG_USB_GADGET_VBUS_DRAW;
 done:
 	usb_gadget_vbus_draw(gadget, power);
+
+	schedule_work(&cdev->switch_work);
 	return result;
 }
 
@@ -756,11 +848,11 @@
 	case USB_REQ_GET_CONFIGURATION:
 		if (ctrl->bRequestType != USB_DIR_IN)
 			goto unknown;
-		if (cdev->config)
+		if (cdev->config) {
 			*(u8 *)req->buf = cdev->config->bConfigurationValue;
-		else
+			value = min(w_length, (u16) 1);
+		} else
 			*(u8 *)req->buf = 0;
-		value = min(w_length, (u16) 1);
 		break;
 
 	/* function drivers must handle get/set altsetting; if there's
@@ -810,6 +902,9 @@
 		 */
 		if ((ctrl->bRequestType & USB_RECIP_MASK)
 				== USB_RECIP_INTERFACE) {
+			if (cdev->config == NULL)
+				return value;
+
 			f = cdev->config->interface[intf];
 			if (f && f->setup)
 				value = f->setup(f, ctrl);
@@ -824,6 +919,25 @@
 				value = c->setup(c, ctrl);
 		}
 
+		/* If the vendor request is not processed (value < 0),
+		 * call all device registered configure setup callbacks
+		 * to process it.
+		 * This is used to handle the following cases:
+		 * - vendor request is for the device and arrives before
+		 * setconfiguration.
+		 * - Some devices are required to handle vendor request before
+		 * setconfiguration such as MTP, USBNET.
+		 */
+
+		if (value < 0) {
+			struct usb_configuration        *cfg;
+
+			list_for_each_entry(cfg, &cdev->configs, list) {
+			if (cfg && cfg->setup)
+				value = cfg->setup(cfg, ctrl);
+			}
+		}
+
 		goto done;
 	}
 
@@ -855,6 +969,11 @@
 	spin_lock_irqsave(&cdev->lock, flags);
 	if (cdev->config)
 		reset_config(cdev);
+
+	if (cdev->mute_switch)
+		cdev->mute_switch = 0;
+	else
+		schedule_work(&cdev->switch_work);
 	spin_unlock_irqrestore(&cdev->lock, flags);
 }
 
@@ -904,6 +1023,8 @@
 		kfree(cdev->req->buf);
 		usb_ep_free_request(gadget->ep0, cdev->req);
 	}
+
+	switch_dev_unregister(&cdev->sdev);
 	kfree(cdev);
 	set_gadget_data(gadget, NULL);
 	composite = NULL;
@@ -931,6 +1052,19 @@
 	}
 }
 
+static void
+composite_switch_work(struct work_struct *data)
+{
+	struct usb_composite_dev	*cdev =
+		container_of(data, struct usb_composite_dev, switch_work);
+	struct usb_configuration *config = cdev->config;
+
+	if (config)
+		switch_set_state(&cdev->sdev, config->bConfigurationValue);
+	else
+		switch_set_state(&cdev->sdev, 0);
+}
+
 static int __init composite_bind(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev	*cdev;
@@ -974,6 +1108,12 @@
 	if (status < 0)
 		goto fail;
 
+	cdev->sdev.name = "usb_configuration";
+	status = switch_dev_register(&cdev->sdev);
+	if (status < 0)
+		goto fail;
+	INIT_WORK(&cdev->switch_work, composite_switch_work);
+
 	cdev->desc = *composite->dev;
 	cdev->desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
 
@@ -1048,6 +1188,23 @@
 	}
 }
 
+static int
+composite_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct usb_function *f = dev_get_drvdata(dev);
+
+	if (!f) {
+		/* this happens when the device is first created */
+		return 0;
+	}
+
+	if (add_uevent_var(env, "FUNCTION=%s", f->name))
+		return -ENOMEM;
+	if (add_uevent_var(env, "ENABLED=%d", !f->disabled))
+		return -ENOMEM;
+	return 0;
+}
+
 /*-------------------------------------------------------------------------*/
 
 static struct usb_gadget_driver composite_driver = {
@@ -1093,6 +1250,11 @@
 	composite_driver.driver.name = driver->name;
 	composite = driver;
 
+	driver->class = class_create(THIS_MODULE, "usb_composite");
+	if (IS_ERR(driver->class))
+		return PTR_ERR(driver->class);
+	driver->class->dev_uevent = composite_uevent;
+
 	return usb_gadget_register_driver(&composite_driver);
 }
 
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_core.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_core.c
--- linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_core.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_core.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,1024 @@
+/*
+ * dwc_otg_core.c - core functions for the DWC OTG chip
+ *
+ * Author: Ricky Taylor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "dwc_otg_core.h"
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+
+#include "dwc_otg_hw.h"
+
+/**
+ * dwc_otg_core_init_eps
+ *
+ * This is a helper function for dwc_otg_core_init that
+ * sets up the EP structures.
+ */
+int dwc_otg_core_init_eps(dwc_otg_core_t *_core)
+{
+	int i;
+
+	// Clear EP data structure (this sets them all as inactive).
+	memset(&_core->endpoints, sizeof(_core->endpoints), 0);
+
+	for(i = 0; i < MAX_EPS_CHANNELS; i++)
+	{
+		uint32_t ret = 0;
+
+		_core->in_ep_registers[i] = (dwc_otg_dev_in_ep_regs_t*)(((uint8_t*)_core->registers) + DWC_OTG_IN_EP_OFFSET + (DWC_OTG_IN_EP_SIZE * i));
+		_core->out_ep_registers[i] = (dwc_otg_dev_out_ep_regs_t*)(((uint8_t*)_core->registers) + DWC_OTG_OUT_EP_OFFSET + (DWC_OTG_OUT_EP_SIZE * i));
+
+		// Setup Endpoint
+		_core->endpoints[i].num = i;
+		_core->endpoints[i].speed = 0;
+		_core->endpoints[i].active = 0;
+		_core->endpoints[i].descriptor = NULL;
+		_core->endpoints[i].in_registers = _core->in_ep_registers[i];
+		_core->endpoints[i].out_registers = _core->out_ep_registers[i];
+		INIT_LIST_HEAD(&_core->endpoints[i].queue_pointer); // Technically not required, keeps debugging clean though.
+		INIT_LIST_HEAD(&_core->endpoints[i].transfer_queue);
+		spin_lock_init(&_core->endpoints[i].lock);
+
+		ret = snprintf(_core->endpoints[i].name, DWC_OTG_EP_MAX_NAME_SIZE, "ep%d", i);
+		if(ret > DWC_OTG_EP_MAX_NAME_SIZE)
+		{
+			DWC_WARNING("EP name buffer too small.\n");
+		}
+
+		/*
+		 * This is where we would check the direction,
+		 * but it seems that upon further inspection of the
+		 * documentation floating around on the internet,
+		 * hwcfg1 does in fact _not_ contain the EP
+		 * capabilities, but in fact the _current_ ep 
+		 * layout. -- Ricky26
+		 */
+		if(i < _core->num_eps)
+			_core->endpoints[i].exists = 1;
+
+		if(i == 0)
+			_core->endpoints[i].speed = DWC_OTG_FULL_SPEED;
+	}
+
+	return 0;
+}
+
+/**
+ * dwc_otg_core_init
+ *
+ * This function initialises the hardware and the
+ * structure specified by _core.
+ */
+int dwc_otg_core_init(dwc_otg_core_t *_core, int _irq, void *_regs, void *_phy)
+{
+	int i;
+	int ret = 0;
+	dctl_data_t dctl = { .d32 = 0 };
+	pcgcctl_data_t pcgcctl = { .d32 = 0 };
+
+	DWC_VERBOSE("%s(%p, %d, %p, %p)\n", __func__, _core, _irq, _regs, _phy);
+
+	if(!_core)
+	{
+		DWC_ERROR("%s called with null core pointer.\n", __func__);
+		return -EINVAL;
+	}
+
+	// Clear core structure.
+	// (This should have already been done by the driver interface,
+	//  but better safe than sorry.)
+	memset(_core, sizeof(dwc_otg_core_t), 0);
+
+	// Initialise internal variables
+	INIT_LIST_HEAD(&_core->ep_transfer_queue);
+	spin_lock_init(&_core->lock);
+
+	// Copy parameters into core.
+	_core->registers = (dwc_otg_core_global_regs_t*)_regs;
+	_core->phy_registers = (dwc_otg_phy_regs_t*)_phy;
+	_core->device_registers = (dwc_otg_device_global_regs_t*)(((uint8_t*)_regs) + DWC_OTG_DEVICE_OFFSET);
+	_core->pcgcctl = (uint32_t*)(((uint8_t*)_regs) + DWC_OTG_PCGCCTL_OFFSET);
+
+	// Initialise hardware.
+	dwc_otg_hw_power(_core, 0); // Make sure everything is reset, incase this
+								// hardware was used in the bootloader, for example.
+	dwc_otg_hw_power(_core, 1);
+
+	// Read Hardware Configuration Registers
+	_core->hwcfg1.d32 = dwc_otg_read_reg32(&_core->registers->ghwcfg1);
+	_core->hwcfg2.d32 = dwc_otg_read_reg32(&_core->registers->ghwcfg2);
+	_core->hwcfg3.d32 = dwc_otg_read_reg32(&_core->registers->ghwcfg3);
+	_core->hwcfg4.d32 = dwc_otg_read_reg32(&_core->registers->ghwcfg4);
+
+	_core->num_eps = _core->hwcfg2.b.num_dev_ep + 1;
+	DWC_DEBUG("%d endpoints detected.\n", _core->num_eps);
+
+	// Initialise EP structures
+	dwc_otg_core_init_eps(_core);
+	
+	// Send soft disconnect
+	dctl.b.sftdiscon = 1;
+	dwc_otg_modify_reg32(&_core->device_registers->dctl, 0, dctl.d32);
+	msleep(4);
+
+	// Power on core.
+	dwc_otg_write_reg32(_core->pcgcctl, pcgcctl.d32);
+	udelay(100);
+
+	if(_core->phy_registers)
+	{
+		phypwr_data_t phypwr = { .d32 = 0 };	
+		phyclk_data_t phyclk = { .d32 = 0 };
+		rstcon_data_t rstcon = { .d32 = 0 };
+
+		DWC_DEBUG("PHY Registers Detected.\n");
+
+		// Power on PHY, if we have one.
+		dwc_otg_write_reg32(&_core->phy_registers->phypwr, phypwr.d32);
+		udelay(10);
+
+		// Select 48Mhz
+		phyclk.b.clksel = DWC_OTG_PHYCLK_CLKSEL_48MHZ;
+		dwc_otg_modify_reg32(&_core->phy_registers->phyclk, DWC_OTG_PHYCLK_CLKSEL_MASK, phyclk.d32);
+
+		// Reset PHY
+		rstcon.b.physwrst = 1;
+		dwc_otg_modify_reg32(&_core->phy_registers->phyclk, 0, rstcon.d32);
+		udelay(20);
+		dwc_otg_modify_reg32(&_core->phy_registers->phyclk, rstcon.d32, 0);
+		msleep(1);
+	}
+
+	dwc_otg_core_soft_reset(_core);
+
+	// Clear soft disconnect
+	dwc_otg_modify_reg32(&_core->device_registers->dctl, dctl.d32, 0);
+	msleep(4);
+
+	// Clear interrupts
+	dwc_otg_write_reg32(&_core->in_ep_registers[_core->num_eps]->diepint, 0xffffffff); // No idea why this is here, reverse-engineered from iBoot.
+	dwc_otg_write_reg32(&_core->out_ep_registers[_core->num_eps]->doepint, 0xffffffff);
+
+	for(i = 0; i < _core->num_eps; i++)
+	{
+		dwc_otg_write_reg32(&_core->in_ep_registers[i]->diepint, 0xffffffff);
+		dwc_otg_write_reg32(&_core->out_ep_registers[i]->doepint, 0xffffffff);
+	}
+
+	dwc_otg_write_reg32(&_core->registers->gintmsk, 0);
+	dwc_otg_write_reg32(&_core->device_registers->diepmsk, 0);
+	dwc_otg_write_reg32(&_core->device_registers->doepmsk, 0);
+
+	// Register IRQ.
+	ret = request_irq(_irq, dwc_otg_core_irq, IRQF_SHARED, DWC_OTG_DRIVER_NAME, _core);
+	if(ret)
+	{
+		DWC_ERROR("Failed to register IRQ (%#x).\n", ret);
+		return ret;
+	}
+	else
+		_core->irq = _irq;
+
+	return 0;
+}
+
+/**
+ * dwc_otg_core_destroy
+ *
+ * This shuts down the hardware and releases any resources
+ * obtained whilst the driver was active.
+ *
+ * This function will not free _core.
+ */
+void dwc_otg_core_destroy(dwc_otg_core_t *_core)
+{
+	DWC_VERBOSE("%s(%p)\n", __func__, _core);
+
+	if(!_core)
+	{
+		DWC_ERROR("%s called with null core pointer.\n", __func__);
+		return;
+	}
+
+	// Shutdown hardware.
+	dwc_otg_hw_power(_core, 0);
+
+	// Release IRQ
+	if(_core->irq)
+		free_irq(_core->irq, _core);
+}
+
+/**
+ * Helper function for soft_reset, waits for a certain register
+ * to have a certain value.
+ */
+inline int helper_wait_for_reg(volatile uint32_t *_reg, uint32_t _mask, uint32_t _val)
+{
+	uint32_t count = 0;
+	uint32_t curr = dwc_otg_read_reg32(_reg);
+
+	if(_mask == 0)
+		return -EINVAL;
+
+	while((curr & _mask) != _val)
+	{
+		count++;
+		if(count > 1000)
+		{
+			DWC_ERROR("Waited 10 seconds in dwc_otg_core_soft_reset. Bailing.");
+			return -EIO;
+		}
+
+		msleep(10);
+		curr = dwc_otg_read_reg32(_reg);
+	}
+
+	return 0;
+}
+
+/**
+ * dwc_otg_core_soft_reset
+ *
+ * Soft Resets the core.
+ */
+int dwc_otg_core_soft_reset(dwc_otg_core_t *_core)
+{
+	grstctl_data_t grstctl = { .d32 = 0 };
+	int ret = 0;
+
+	DWC_VERBOSE("%s(%p)\n", __func__, _core);
+
+	if(!_core)
+	{
+		DWC_ERROR("%s called with null core pointer.\n", __func__);
+		return -EINVAL;
+	}
+
+	// Wait for AHBIDLE
+	grstctl.b.ahbidle = 1;
+	ret = helper_wait_for_reg(&_core->registers->grstctl, grstctl.d32, grstctl.d32);
+
+	if(ret)
+		return ret;
+
+	grstctl.b.ahbidle = 0;
+
+	// Set core reset flag
+	grstctl.b.csftrst = 1;
+	dwc_otg_modify_reg32(&_core->registers->grstctl, grstctl.d32, 0);
+	ret = helper_wait_for_reg(&_core->registers->grstctl, grstctl.d32, 0);
+	if(ret)
+		return ret;
+
+	grstctl.b.csftrst = 0;
+
+	// Wait for AHBIDLE
+	grstctl.b.ahbidle = 1;
+	ret = helper_wait_for_reg(&_core->registers->grstctl, ~grstctl.d32, 0);
+	if(ret)
+		return ret;
+
+	msleep(1);
+
+	return 0;
+}
+
+/**
+ * dwc_otg_core_start
+ *
+ * Start chip operation.
+ */
+int dwc_otg_core_start(dwc_otg_core_t *_core)
+{
+	int i = 0;
+	gahbcfg_data_t gahbcfg = { .d32 = 0 };
+	gusbcfg_data_t gusbcfg = { .d32 = 0 };
+	dcfg_data_t dcfg = { .d32 = 0 };
+	dctl_data_t dctl = { .d32 = 0 };
+	gotgctl_data_t gotgctl = { .d32 = 0 };
+	gintmsk_data_t gintmsk = { .d32 = 0 };
+
+	DWC_VERBOSE("%s(%p)\n", __func__, _core);
+
+	// Set some configuration
+	gahbcfg.b.glblintrmsk = 1; // Enable Interrupts
+	gahbcfg.b.dmaenable = DWC_GAHBCFG_DMAENABLE;
+	gahbcfg.b.hburstlen = DWC_GAHBCFG_INT_DMA_BURST_INCR8;
+	dwc_otg_write_reg32(&_core->registers->gahbcfg, gahbcfg.d32);
+
+	// Set USB Configuration
+	gusbcfg.b.phyif = 1;
+	gusbcfg.b.srpcap = 1;
+	gusbcfg.b.hnpcap = 1;
+	gusbcfg.b.usbtrdtim = 5;
+	dwc_otg_write_reg32(&_core->registers->gusbcfg, gusbcfg.d32);
+
+	// Set Device Configuration
+	dcfg.b.devspd = DWC_DCFG_HIGH_SPEED;
+	dcfg.b.perfrint = DWC_DCFG_FRAME_INTERVAL_80;
+	dwc_otg_write_reg32(&_core->device_registers->dcfg, dcfg.d32);
+
+	// Write FIFO sizes
+	dwc_otg_write_reg32(&_core->registers->grxfsiz, DWC_OTG_RX_FIFO_SIZE);
+	dwc_otg_write_reg32(&_core->registers->gnptxfsiz, (DWC_OTG_TX_FIFO_OFFSET << 16) | DWC_OTG_TX_FIFO_SIZE);
+
+	// Clear Interrupts
+	for(i = 0; i < _core->num_eps; i++)
+	{
+		dwc_otg_write_reg32(&_core->in_ep_registers[i]->diepint, 0xffffffff);
+		dwc_otg_write_reg32(&_core->out_ep_registers[i]->doepint, 0xffffffff);
+	}
+
+	// We're ready!
+	_core->ready = 1;
+
+	// Enable Interrupts
+	gintmsk.b.inepintr = 1;
+	gintmsk.b.outepintr = 1;
+	dwc_otg_write_reg32(&_core->registers->gintmsk, gintmsk.d32);
+	dwc_otg_write_reg32(&_core->device_registers->daintmsk, 0);
+
+	dctl.b.pwronprgdone = 1;
+	dctl.b.cgoutnak = 1;
+	dctl.b.cgnpinnak = 1;
+	dwc_otg_write_reg32(&_core->device_registers->dctl, dctl.d32);
+
+	gotgctl.b.sesreq = 1;
+	dwc_otg_modify_reg32(&_core->registers->gotgctl, 0, gotgctl.d32);
+
+	return 0;
+}
+
+/**
+ * dwc_otg_core_stop
+ *
+ * Stop chip operation.
+ */
+void dwc_otg_core_stop(dwc_otg_core_t *_core)
+{
+	DWC_VERBOSE("%s(%p)\n", __func__, _core);
+}
+
+/**
+ * dwc_otg_core_ep_reset
+ *
+ * Resets all of the endpoints, cancelling any
+ * current requests.
+ */
+void dwc_otg_core_ep_reset(dwc_otg_core_t *_core)
+{
+	int i;
+
+	DWC_VERBOSE("%s(%p)\n", __func__, _core);
+
+	// Cancel all current requests.
+	dwc_otg_core_cancel_all_requests(_core);
+
+	// Disable EPs.
+	for(i = 1; i < _core->num_eps; i++)
+	{
+		dwc_otg_core_ep_t *ep = &_core->endpoints[i];
+		dwc_otg_core_disable_ep(_core, ep);
+	}
+}
+
+/**
+ * dwc_otg_core_enable_interrupts
+ *
+ * Enables interrupts.
+ */
+int dwc_otg_core_enable_interrupts(dwc_otg_core_t *_core)
+{
+	gahbcfg_data_t gahbcfg = { .d32 = 0 };
+
+	DWC_VERBOSE("%s(%p)\n", __func__, _core);
+
+	gahbcfg.b.glblintrmsk = 1;
+	dwc_otg_modify_reg32(&_core->registers->gahbcfg, 0, gahbcfg.d32);
+
+	return 0;
+}
+
+/**
+ * dwc_otg_core_disable_interrupts
+ *
+ * Disables interrupts.
+ */
+int dwc_otg_core_disable_interrupts(dwc_otg_core_t *_core)
+{
+	gahbcfg_data_t gahbcfg = { .d32 = 0 };
+
+	DWC_VERBOSE("%s(%p)\n", __func__, _core);
+
+	gahbcfg.b.glblintrmsk = 1;
+	dwc_otg_modify_reg32(&_core->registers->gahbcfg, gahbcfg.d32, 0);
+
+	return 0;
+}
+
+/**
+ * The core USB IRQ handler.
+ */
+irqreturn_t dwc_otg_core_irq(int _irq, void *_dev)
+{
+	dwc_otg_core_t *core = (dwc_otg_core_t*)_dev;
+	gintsts_data_t gintsts = { .d32 = 0 };
+	gintsts_data_t gintclr = { .d32 = 0 };
+
+	gintsts.d32 = dwc_otg_read_reg32(&core->registers->gintsts) & dwc_otg_read_reg32(&core->registers->gintmsk);
+
+	DWC_VERBOSE("%s(%d, %p) gintsts=0x%08x\n", __func__, _irq, _dev, gintsts.d32);
+
+	// Clear the interrupts
+	gintsts.d32 &= ~gintclr.d32;
+	dwc_otg_write_reg32(&core->registers->gintsts, gintclr.d32);
+	return gintsts.d32 != 0 ? IRQ_NONE : IRQ_HANDLED;
+}
+
+/**
+ * Enable an endpoint.
+ */
+int dwc_otg_core_enable_ep(dwc_otg_core_t *_core, dwc_otg_core_ep_t *_ep, struct usb_endpoint_descriptor *_desc)
+{
+	daint_data_t daint = { .d32 = 0 };
+	depctl_data_t diepctl;
+	depctl_data_t doepctl;
+	unsigned long flags;
+	int mps;
+
+	DWC_VERBOSE("%s(%p, %p, %p)\n", __func__, _core, _ep, _desc);
+
+	if(_desc == NULL)
+	{
+		DWC_WARNING("%s: cannot enable with NULL descriptor!\n", _ep->name);
+		return 0;
+	}
+
+	if(_ep->descriptor && _ep->descriptor != _desc)
+	{
+		DWC_WARNING("%s: %s already enabled!\n", __func__, _ep->name);
+		return 0;
+	}
+
+	_ep->descriptor = _desc;
+	mps = dwc_otg_mps_from_speed(_ep->speed);
+	if(mps < _desc->wMaxPacketSize)
+	{
+		DWC_WARNING("%s: Tried to set maxpacket too high! (%d->%d)\n", _ep->name, mps, _desc->wMaxPacketSize);
+	}		
+	else if(_desc->wMaxPacketSize > 0)
+		mps = _desc->wMaxPacketSize;
+
+
+	if(_ep->num == 0)
+	{
+		_ep->direction = DWC_OTG_EP_BIDIR;
+	}
+	else
+	{
+		if((_desc->bEndpointAddress & USB_DIR_IN) != 0)
+			_ep->direction = DWC_OTG_EP_IN;
+		else
+			_ep->direction = DWC_OTG_EP_OUT;
+	}
+
+	spin_lock_irqsave(&_core->lock, flags);
+		
+	daint.d32 = dwc_otg_read_reg32(&_core->device_registers->daintmsk);
+	diepctl.d32 = dwc_otg_read_reg32(&_ep->in_registers->diepctl);
+	doepctl.d32 = dwc_otg_read_reg32(&_ep->out_registers->doepctl);
+
+	// Setup EP0 max packet size
+	if(_ep->num == 0)
+	{
+		dsts_data_t dsts;
+
+		dsts.d32 = dwc_otg_read_reg32(&_core->device_registers->dsts);
+
+		switch (dsts.b.enumspd)
+		{
+		case DWC_DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
+		case DWC_DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
+		case DWC_DSTS_ENUMSPD_FS_PHY_48MHZ:
+			diepctl.b.mps = DWC_DEP0CTL_MPS_64;
+			doepctl.b.mps = DWC_DEP0CTL_MPS_64;
+			break;
+
+		case DWC_DSTS_ENUMSPD_LS_PHY_6MHZ:
+			diepctl.b.mps = DWC_DEP0CTL_MPS_8;
+			doepctl.b.mps = DWC_DEP0CTL_MPS_8;
+			break;
+		}
+
+		daint.b.inep0 = 1;
+		daint.b.outep0 = 1;
+
+		diepctl.b.usbactep = 1;
+		doepctl.b.usbactep = 1;
+		
+		diepctl.b.snak = 1;
+		doepctl.b.snak = 1;
+
+		diepctl.b.stall = 0;
+		doepctl.b.stall = 0;
+
+		diepctl.b.nextep = 0; // Initialize ring when we enable EP0.
+	}
+	else
+	{
+		if(_ep->direction & DWC_OTG_EP_IN)
+		{
+			daint.ep.in |= 1 << _ep->num;
+
+			diepctl.b.usbactep = 1;
+			diepctl.b.snak = 1;
+			diepctl.b.mps = mps;
+			diepctl.b.eptype = (_desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK);
+			diepctl.b.nextep = 0; // We're the last EP now, so the next EP must be 0.
+			diepctl.b.stall = 0;
+			diepctl.b.setd0pid = 1;
+
+			// Set next EP in transfer loop.
+			{
+				int counter;
+				int prevEp = 0;
+				depctl_data_t pdepctl;
+
+				for(counter = 0; counter < _core->num_eps; counter++)
+				{
+					pdepctl.d32 = dwc_otg_read_reg32(&_core->in_ep_registers[prevEp]->diepctl);
+
+					if(pdepctl.b.nextep == 0 || pdepctl.b.nextep == _ep->num)
+						break;
+
+					prevEp = pdepctl.b.nextep;
+				}
+
+				if(counter == _core->num_eps)
+				{
+					DWC_ERROR("Transfer loop corrupt when trying to add %s!\n", _ep->name);
+				}
+				else if(pdepctl.b.nextep != _ep->num)
+				{
+					pdepctl.b.nextep = _ep->num;
+					dwc_otg_write_reg32(&_core->in_ep_registers[prevEp]->diepctl, pdepctl.d32);
+					
+					DWC_DEBUG("Adding %s to chain after %s.\n", _ep->name, _core->endpoints[prevEp].name);
+				}
+				else
+					DWC_DEBUG("%s already in EP TX queue!\n", _ep->name);
+			}
+		}
+
+		if(_ep->direction & DWC_OTG_EP_OUT)
+		{
+			daint.ep.out |= 1 << _ep->num;
+
+			doepctl.b.usbactep = 1;
+			doepctl.b.snak = 1;
+			doepctl.b.mps = mps;
+			doepctl.b.eptype = (_desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK); 
+			doepctl.b.stall = 0;
+			doepctl.b.setd0pid = 1;
+		}
+	}
+
+	dwc_otg_write_reg32(&_core->device_registers->daintmsk, daint.d32);
+	dwc_otg_write_reg32(&_ep->in_registers->diepctl, diepctl.d32);
+	dwc_otg_write_reg32(&_ep->out_registers->doepctl, doepctl.d32);
+
+	spin_unlock_irqrestore(&_core->lock, flags);
+
+	return 0;
+}
+
+/**
+ * Disable an endpoint.
+ */
+int dwc_otg_core_disable_ep(dwc_otg_core_t *_core, dwc_otg_core_ep_t *_ep)
+{
+	daint_data_t daint = { .d32 = 0 };
+	depctl_data_t diepctl;
+	depctl_data_t doepctl;
+	unsigned long flags;
+
+	DWC_VERBOSE("%s(%p, %p)\n", __func__, _core, _ep);
+
+	spin_lock_irqsave(&_core->lock, flags);
+		
+	daint.d32 = dwc_otg_read_reg32(&_core->device_registers->daintmsk);
+	diepctl.d32 = dwc_otg_read_reg32(&_ep->in_registers->diepctl);
+	doepctl.d32 = dwc_otg_read_reg32(&_ep->out_registers->doepctl);
+
+	if(_ep->descriptor != NULL)
+	{
+		if(_ep->num == 0)
+		{
+			// Do nothing, no sense in shutting down EP0.
+		}
+		else
+		{
+			if(_ep->direction & DWC_OTG_EP_IN)
+			{
+				int i;
+				daint.ep.in &= ~(1 << _ep->num);
+
+				diepctl.b.usbactep = 0;
+				diepctl.b.epena = 0;
+				diepctl.b.snak = 1;
+
+				// Remove from transfer loop.
+				for(i = 0; i < _core->num_eps; i++)
+				{
+					depctl_data_t pdepctl;
+					pdepctl.d32 = dwc_otg_read_reg32(&_core->in_ep_registers[i]->diepctl);
+					if(pdepctl.b.nextep == _ep->num)
+					{
+						pdepctl.b.nextep = diepctl.b.nextep;
+						diepctl.b.nextep = 0;
+						dwc_otg_write_reg32(&_core->in_ep_registers[i]->diepctl, pdepctl.d32);
+					}
+				}
+			}
+
+			if(_ep->direction & DWC_OTG_EP_OUT)
+			{
+				daint.ep.out &= ~(1 << _ep->num);
+
+				doepctl.b.usbactep = 0;
+				doepctl.b.epena = 0;
+				doepctl.b.snak = 1;
+			}
+		}
+	}
+
+	dwc_otg_write_reg32(&_core->device_registers->daintmsk, daint.d32);
+	dwc_otg_write_reg32(&_ep->in_registers->diepctl, diepctl.d32);
+	dwc_otg_write_reg32(&_ep->out_registers->doepctl, doepctl.d32);
+
+	_ep->descriptor = NULL;
+
+	spin_unlock_irqrestore(&_core->lock, flags);
+
+	return 0;
+}
+
+/**
+ * Stall an endpoint.
+ */
+int dwc_otg_core_stall_ep(dwc_otg_core_t *_core, dwc_otg_core_ep_t *_ep, int _stall)
+{
+	depctl_data_t depctl = { .d32 = 0 };
+	depctl.b.stall = (_stall > 0) ? 1 : 0;
+
+	DWC_VERBOSE("%s(%p, %p) ep=%s\n", __func__, _core, _ep, _ep->name);
+
+	if(_ep->direction == DWC_OTG_EP_OUT)
+	{
+		dwc_otg_modify_reg32(&_ep->out_registers->doepctl, 0, depctl.d32);
+	}
+	else
+		dwc_otg_modify_reg32(&_ep->in_registers->diepctl, 0, depctl.d32);
+
+	return 0;
+}
+
+/**
+ * dwc_otg_core_enqueue_request
+ *
+ * Queue an out request.
+ */
+int dwc_otg_core_enqueue_request(dwc_otg_core_t *_core, dwc_otg_core_ep_t *_ep, dwc_otg_core_request_t *_req)
+{
+	// If the list is empty, we will need to start the EP up.
+	// Store this now, as we're about to modify the list.
+	uint32_t startEP = list_empty(&_ep->transfer_queue);
+
+#ifdef VERBOSE
+	char *dir = "invalid";
+	if(_req->direction == DWC_OTG_REQUEST_IN)
+		dir = "in";
+	else if(_req->direction == DWC_OTG_REQUEST_OUT)
+		dir = "out";
+
+	DWC_DEBUG("%s(%p, %p, %p) ep=%s, dir=%s, len=%d\n", __func__, _core, _ep, _req, _ep->name, dir, _req->length);
+#endif
+
+	if(_req->queued == 1)
+	{
+		DWC_ERROR("Tried to queue a request twice!\n");
+		return -EINVAL;
+	}
+
+	if(_req->length && !_req->buffer)
+	{
+		DWC_ERROR("Tried to send a request with no buffer, yet a length.\n");
+		return -EINVAL;
+	}
+	else if(_req->length)
+	{
+		if(_req->dont_free && !_req->dma_buffer)
+		{
+			DWC_WARNING("Allocating a DMA buffer for a request that won't be freed.\n");
+		}
+
+		if(!_req->dont_free && _req->dma_buffer)
+		{
+			DWC_WARNING("Pre-allocated DMA buffer in a request that's going to be freed.\n");
+		}
+	}
+
+	if(_req->length && !_req->dma_buffer)
+	{
+		// Allocate DMA buffer
+		_req->dma_buffer = dma_alloc_coherent(NULL, _req->buffer_length, &_req->dma_address, GFP_KERNEL);
+		if(!_req->dma_buffer)
+		{
+			DWC_ERROR("Failed to allocate a buffer for DMA.\n");
+			return -EIO;
+		}
+
+		memcpy(_req->dma_buffer, _req->buffer, _req->length);
+	}
+
+	// TODO: Do a lock here?
+
+	INIT_LIST_HEAD(&_req->queue_pointer);
+	list_add_tail(&_req->queue_pointer, &_ep->transfer_queue);
+
+	_req->core = _core;
+	_req->ep = _ep;
+	_req->queued = 1;
+	_req->amount_done = 0;
+	_req->setup = 0;
+	_req->cancelled = 0;
+	
+	if(startEP)
+		dwc_otg_core_start_request(_core, _req);
+
+	// TODO: End lock
+	
+	return 0;
+}
+
+/**
+ * dwc_otg_core_start_request
+ */
+int dwc_otg_core_start_request(dwc_otg_core_t *_core, dwc_otg_core_request_t *_req)
+{
+	dwc_otg_core_ep_t *ep = _req->ep;
+	depctl_data_t depctl = { .d32 = 0 };
+	daint_data_t daint = { .d32 = 0 };
+	volatile uint32_t *depctl_ptr;
+	volatile uint32_t *depdma_ptr;
+	volatile uint32_t *deptsiz_ptr;
+	unsigned long flags;
+	int txAmt;
+
+#ifdef VERBOSE
+	char *dir = "invalid";
+	if(_req->direction == DWC_OTG_REQUEST_IN)
+		dir = "in";
+	else if(_req->direction == DWC_OTG_REQUEST_OUT)
+		dir = "out";
+
+	DWC_DEBUG("%s(%p, %p) type=%d, dma=%p, ep=%s, dir=%s, len=%d, done=%d\n", __func__,
+			_core, _req, _req->request_type, (void*)_req->dma_address, ep->name, dir, _req->length, _req->amount_done);
+#endif
+
+	// TODO: Does this need to be locked by the
+	// core or the EP?
+	spin_lock_irqsave(&_core->lock, flags);
+
+	// Reset Flags
+	_req->active = 1;
+
+	if(_req->direction == DWC_OTG_REQUEST_OUT)
+	{
+		daint.ep.out = 1 << ep->num;
+		depctl_ptr = &ep->out_registers->doepctl;
+		depdma_ptr = &ep->out_registers->doepdma;
+		deptsiz_ptr = &ep->out_registers->doeptsiz;
+	}
+	else
+	{
+		daint.ep.in = 1 << ep->num;
+		depctl_ptr = &ep->in_registers->diepctl;
+		depdma_ptr = &ep->in_registers->diepdma;
+		deptsiz_ptr = &ep->in_registers->dieptsiz;
+	}
+
+	// Enable interrupts on this EP!
+	dwc_otg_modify_reg32(&_core->device_registers->daintmsk, 0, daint.d32);
+
+	// Read initial control register value.
+	depctl.d32 = dwc_otg_read_reg32(depctl_ptr);
+
+	// Add ourselves to the EP queue.
+	INIT_LIST_HEAD(&ep->queue_pointer);
+	list_add_tail(&ep->queue_pointer, &_core->ep_transfer_queue);
+
+	depctl.b.epena = 1;
+	depctl.b.cnak = 1;
+	depctl.b.usbactep = 1;
+
+	// Set the DMA address of the data!
+	dwc_otg_write_reg32(depdma_ptr, _req->dma_address+_req->amount_done);
+
+	// Calculate packet size, number of packets,
+	// and set the max packet size in the control
+	// register.
+	txAmt = _req->length-_req->amount_done;
+
+	if(ep->num == 0)
+	{
+		deptsiz0_data_t deptsiz0;
+		deptsiz0.d32 = dwc_otg_read_reg32(deptsiz_ptr);
+
+		deptsiz0.b.pktcnt = 1;
+		//if(_req->zero)
+		//	deptsiz0.b.pktcnt++;
+
+		if(_req->direction == DWC_OTG_REQUEST_OUT)
+			deptsiz0.b.supcnt = 1;
+
+		if(txAmt &~ 0x7f)
+		{
+			DWC_WARNING("Packet too large for EP0 (0x%0x).\n", txAmt);
+			txAmt = 0x7f;
+		}
+		
+		deptsiz0.b.xfersize = txAmt;
+
+		DWC_DEBUG("XferSize: pkt=%d, xfersize=%d\n", deptsiz0.b.pktcnt, deptsiz0.b.xfersize);
+
+		dwc_otg_write_reg32(deptsiz_ptr, deptsiz0.d32);
+	}
+	else
+	{
+		deptsiz_data_t deptsiz = { .d32 = 0 };
+
+		int mps = dwc_otg_mps_from_speed(ep->speed);
+		if(ep->descriptor != NULL)
+			mps = ep->descriptor->wMaxPacketSize;
+
+		deptsiz.d32 = dwc_otg_read_reg32(deptsiz_ptr);
+
+		deptsiz.b.xfersize = txAmt;
+		deptsiz.b.pktcnt = (txAmt == 0) ? 1 : ((txAmt + mps - 1)/mps);
+		if(_req->zero && (txAmt % mps) == 0)
+			deptsiz.b.pktcnt++;
+
+		DWC_DEBUG("XferSize: pkt=%d, xfersize=%d\n", deptsiz.b.pktcnt, deptsiz.b.xfersize);
+
+		dwc_otg_write_reg32(deptsiz_ptr, deptsiz.d32);
+	}
+
+	_req->current_load = txAmt;
+
+	// Set the control register. (This starts the transfer!)
+	dwc_otg_write_reg32(depctl_ptr, depctl.d32);
+
+	spin_unlock_irqrestore(&_core->lock, flags);
+
+	return 0;
+}
+
+/**
+ * dwc_otg_core_complete_request
+ */
+int dwc_otg_core_complete_request(dwc_otg_core_t *_core, dwc_otg_core_request_t *_req)
+{
+	dwc_otg_core_ep_t *ep = _req->ep;
+	dwc_otg_core_request_t *req = list_first_entry(&ep->transfer_queue, dwc_otg_core_request_t, queue_pointer);
+	deptsiz_data_t deptsiz = { .d32 = 0 };
+	volatile uint32_t *depctl_ptr;
+	volatile uint32_t *deptsiz_ptr;
+	unsigned long flags;
+		
+	DWC_VERBOSE("%s(%p, %p)\n", __func__, _core, _req);
+
+	if(req != _req)
+	{
+		DWC_ERROR("Tried to complete request out of phase!\n");
+		return -EIO;
+	}
+
+	// Setup register pointers
+	if(_req->direction == DWC_OTG_REQUEST_OUT)
+	{
+		depctl_ptr = &ep->out_registers->doepctl;
+		deptsiz_ptr = &ep->out_registers->doeptsiz;
+	}
+	else
+	{
+		depctl_ptr = &ep->in_registers->diepctl;
+		deptsiz_ptr = &ep->in_registers->dieptsiz;
+	}
+	
+	// TODO: Does this need to be locked by the core
+	// or the EP?
+	spin_lock_irqsave(&_core->lock, flags);
+
+	// Remove us from the EP queue.
+	if(_req->active)
+		list_del(&ep->queue_pointer);
+
+	// Mark the request as inactive
+	_req->active = 0;
+
+	// Calculate how much was actually sent
+	deptsiz.d32 = dwc_otg_read_reg32(deptsiz_ptr);
+	_req->current_load -= deptsiz.b.xfersize;
+	_req->amount_done += _req->current_load;
+
+	if(_req->amount_done < 0)
+		DWC_ERROR("STRANGE THINGS (%d, %d)!\n", _req->amount_done, deptsiz.b.xfersize);
+	else
+		_req->length = _req->amount_done;
+
+	// Remove this request as it is now complete.
+	list_del(&_req->queue_pointer);
+	_req->queued = 0;
+
+	// If there are more requests to process on this EP...
+	if(!list_empty(&ep->transfer_queue) && _core->ready)
+	{
+		// Start the next one!
+		req = list_first_entry(&ep->transfer_queue, dwc_otg_core_request_t, queue_pointer);
+		dwc_otg_core_start_request(_core, req);
+	}
+	else
+		ep->active = 0;
+
+	spin_unlock_irqrestore(&_core->lock, flags);
+
+	// Call the handler
+	DWC_VERBOSE("%s: calling handler. cancel=%p, compl=%p\n", __func__, _req->cancelled_handler, req->completed_handler);
+	if(_req->cancelled && _req->cancelled_handler)
+		_req->cancelled_handler(_req);
+	else if(_req->completed_handler)
+		_req->completed_handler(_req);
+	
+	if(!_req->dont_free)
+	{
+		if(_req->dma_buffer)
+			dma_free_coherent(NULL, _req->buffer_length, _req->dma_buffer, _req->dma_address);
+
+		if(_req->dma_buffer != _req->buffer)
+			kfree(_req->buffer);
+
+		kfree(_req);
+		_req = NULL;
+	}
+
+	return 0;
+}
+
+/**
+ * Cancel all current requests.
+ */
+int dwc_otg_core_cancel_all_requests(dwc_otg_core_t *_core)
+{
+	uint32_t i;
+
+	DWC_VERBOSE("%s(%p)\n", __func__, _core);
+
+	_core->ready = 0;
+
+	for(i = 0; i < _core->num_eps; i++)
+	{
+		dwc_otg_core_ep_t *ep = &_core->endpoints[i];
+		depctl_data_t depctl = { .d32 = 0 };
+
+		// Set NAK on all out endpoints
+		depctl.b.snak = 1;
+		dwc_otg_modify_reg32(&_core->out_ep_registers[i]->doepctl, 0, depctl.d32);
+
+		DWC_VERBOSE("Deleting transfers from %s (%p).\n", ep->name, ep);
+
+ 		while(!list_empty(&ep->transfer_queue))
+		{
+			dwc_otg_core_request_t *req = list_first_entry(&ep->transfer_queue, dwc_otg_core_request_t, queue_pointer);
+
+			DWC_VERBOSE("Cancelling request %p, on %s (%p).\n", req, ep->name, ep);
+
+			// Cancel the request.
+			req->cancelled = 1;
+			dwc_otg_core_complete_request(_core, req);
+		}
+	}
+
+	_core->ready = 1;
+
+	return 0;
+}
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_core.h iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_core.h
--- linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_core.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_core.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,427 @@
+/*
+ * dwc_otg_core.h - header for core functions for the DWC OTG chip
+ *
+ * Author: Ricky Taylor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef  __DWC_OTG_CORE_H__
+#define  __DWC_OTG_CORE_H__
+
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/dmaengine.h>
+#include <linux/usb/ch9.h>
+#include <linux/spinlock.h>
+
+#include "dwc_otg.h"
+#include "dwc_otg_regs.h"
+
+/**
+ * @file dwc_otg_core.h
+ * This file contains the core components of operating the OTG hardware.
+ */
+
+/*
+ * Constants and configuration.
+ */
+#define DWC_OTG_DEVICE_OFFSET	0x800
+#define DWC_OTG_IN_EP_OFFSET	0x900
+#define DWC_OTG_IN_EP_SIZE		0x020
+#define DWC_OTG_OUT_EP_OFFSET	0xB00
+#define DWC_OTG_OUT_EP_SIZE		0x020
+#define DWC_OTG_PCGCCTL_OFFSET	0xE00
+
+#define DWC_OTG_RX_FIFO_SIZE	0x1c0
+#define DWC_OTG_TX_FIFO_SIZE	0x1c0
+#define DWC_OTG_TX_FIFO_OFFSET	0x200
+
+#define DWC_OTG_EP_MAX_NAME_SIZE 16
+
+#define DWC_OTG_HIGH_SPEED 0
+#define DWC_OTG_FULL_SPEED 1
+#define DWC_OTG_LOW_SPEED 2
+
+struct dwc_otg_core_struct;
+struct dwc_otg_core_ep_struct;
+struct dwc_otg_core_request_struct;
+typedef void (*request_handler_t)(struct dwc_otg_core_request_struct *);
+
+/**
+ * dwc_otg_core_request
+ *
+ * A USB request.
+ */
+typedef struct dwc_otg_core_request_struct
+{
+	/** Our previous and next links in the EP's queue. */
+	struct list_head queue_pointer;
+
+	/** The request type: Control, Interrupt, Isoc or Bulk. */
+	int request_type;
+
+	/** The request direction. */
+	int direction;
+#define DWC_OTG_REQUEST_OUT 0
+#define DWC_OTG_REQUEST_IN 1
+
+	/** The request buffer. */
+	void *buffer;
+
+	/** The buffer length. */
+	ssize_t buffer_length;
+
+	/** The amount being transferred. */
+	ssize_t current_load;
+
+	/** The amount transferred. */
+	ssize_t amount_done;
+
+	/** The request size. */
+	ssize_t length;
+
+	/** The DMA buffer. */
+	void *dma_buffer;
+
+	/** The DMA address. */
+	dma_addr_t dma_address;
+
+	/**
+	 * If the request is allocated by dwc_otg_core_enqueue, it
+	 * needs to be released.
+	 * */
+	unsigned dont_free : 1;
+
+	/**
+	 * This flag says that the request is currently queued or active.
+	 */
+	unsigned queued : 1;
+	
+	/**
+	 * If this flag is set, an extra empty packet is sent at the
+	 * end of the transfer.
+	 */
+	unsigned zero : 1;
+
+	/**
+	 * This flag says that the request is currently active.
+	 */
+	unsigned active : 1;
+
+	/**
+	 * This is set on out requests if the data was prepended
+	 * with a setup packet.
+	 */
+	unsigned setup : 1;
+
+	/**
+	 * This flag is set if the request failed.
+	 */
+	unsigned cancelled : 1;
+
+	/**
+	 * The core handling this request,
+	 * filled in when the request is queued.
+	 */
+	struct dwc_otg_core_struct *core;
+
+	/**
+	 * The ep structure of this request,
+	 * filled in when the request is queued.
+	 */
+	struct dwc_otg_core_ep_struct *ep;
+
+	/**
+	 * The request handler which is called when the request completed.
+	 */
+	request_handler_t completed_handler;
+
+	/**
+	 * The request handler which is called when the request was cancelled.
+	 *
+	 * If this isn't set, the completed_handler is called when the
+	 * request is cancelled.
+	 */
+	request_handler_t cancelled_handler;
+
+	/**
+	 * This variable is for use entirely by whoever creates
+	 * the request.
+	 */
+	void *data;
+
+} dwc_otg_core_request_t;
+
+/**
+ * dwc_otg_core_ep_struct
+ *
+ * This stores all the information about an endpoint.
+ * (If an endpoint is bi-directional, there will
+ *  actually be two of these structures.)
+ */
+typedef struct dwc_otg_core_ep_struct
+{
+	/** Our previous and next links in the EP's queue. */
+	struct list_head queue_pointer;
+
+	/** This is set to 1 if this EP exists. */
+	int exists;
+
+	/** The index of the EP. */
+	int num;
+
+	/** The name of the EP. */
+	char name[DWC_OTG_EP_MAX_NAME_SIZE];
+
+	/**
+	 * The in EP registers.
+	 */
+	dwc_otg_dev_in_ep_regs_t *in_registers;
+
+	/**
+	 * The out EP registers.
+	 */
+	dwc_otg_dev_out_ep_regs_t *out_registers;
+
+	/** The current transfer queue. */
+	struct list_head transfer_queue;
+
+	/** The current speed of the EP. */
+	int speed;
+
+	/**
+	 * Whether the EP is active
+	 * (essentially a copy of the .epena
+	 * register in the hardware, but stored
+	 * seperately so that hardware errors do
+	 * not cause the drivers to malfunction.)
+	 */
+	unsigned active : 1;
+
+	/** Which direction the EP is currently working in. */
+	unsigned direction : 2;
+#define DWC_OTG_EP_DISABLED 0
+#define DWC_OTG_EP_IN 1
+#define DWC_OTG_EP_OUT 2
+#define DWC_OTG_EP_BIDIR 3
+
+	/** The endpoint's spinlock. */
+	spinlock_t lock;
+
+	/** This is set by the usb_gadget API when the EP is enabled. */
+	struct usb_endpoint_descriptor *descriptor;
+
+} dwc_otg_core_ep_t;
+
+/**
+ * dwc_otg_core_struct
+ *
+ * This structure holds all the data required to operate
+ * the device.
+ */ 
+typedef struct dwc_otg_core_struct
+{
+	/**
+	 * This is the IRQ of the core.
+	 */
+	int irq;
+
+	/**
+	 * This is the memory address of the start of
+	 * the remapped registers.
+	 */
+	volatile dwc_otg_core_global_regs_t *registers;
+
+	/**
+	 * This is the memory address of the start of
+	 * the remapped PHY registers.
+	 *
+	 * This variable will be NULL if there is no
+	 * on-core PHY.
+	 */
+	volatile dwc_otg_phy_regs_t *phy_registers;
+
+	/**
+	 * This is the clock speed and gating register,
+	 * it's used to restart the PHY.
+	 */
+	volatile uint32_t *pcgcctl;
+
+	/**
+	 * This is the memory address of the start of the
+	 * device registers.
+	 */
+	volatile dwc_otg_device_global_regs_t *device_registers;
+
+	/**
+	 * The in EP registers.
+	 */
+	dwc_otg_dev_in_ep_regs_t *in_ep_registers[MAX_EPS_CHANNELS];
+
+	/**
+	 * The out EP registers.
+	 */
+	dwc_otg_dev_out_ep_regs_t *out_ep_registers[MAX_EPS_CHANNELS];
+
+	/**
+	 * The endpoints.
+	 */
+	int num_eps;
+	dwc_otg_core_ep_t endpoints[MAX_EPS_CHANNELS];
+
+	/**
+	 * These registers are read once and then modified
+	 * to disable unwanted features.
+	 */
+	hwcfg1_data_t hwcfg1;
+	hwcfg2_data_t hwcfg2;
+	hwcfg3_data_t hwcfg3;
+	hwcfg4_data_t hwcfg4;
+
+	/**
+	 * This is the current transfer queue.
+	 * The front of the queue is the EP currently
+	 * transferring data.
+	 * If the queue is empty nothing is happening, j0.
+	 */
+	struct list_head ep_transfer_queue;
+
+	/**
+	 * Determines whether the core is ready for
+	 * transfers. (EG, it isn't whilst we're
+	 * shutting down the core after we receive a
+	 * USB reset.)
+	 */
+	unsigned ready : 1;
+
+	/** The core spinlock, for protecting registers. */
+	spinlock_t lock;
+
+} dwc_otg_core_t;
+
+/**
+ * dwc_otg_core_init
+ *
+ * This function initialises the hardware and the
+ * structure specified by _core.
+ */
+int dwc_otg_core_init(dwc_otg_core_t *_core, int _irq, void *_regs, void *_phy);
+
+/**
+ * dwc_otg_core_destroy
+ *
+ * This shuts down the hardware and releases any resources
+ * obtained whilst the driver was active.
+ *
+ * This function will not free _core.
+ */
+void dwc_otg_core_destroy(dwc_otg_core_t *_core);
+
+/**
+ * dwc_otg_core_soft_reset
+ *
+ * Soft Resets the core.
+ */
+int dwc_otg_core_soft_reset(dwc_otg_core_t *_core);
+
+/**
+ * dwc_otg_core_start
+ *
+ * Start chip operation.
+ */
+int dwc_otg_core_start(dwc_otg_core_t *_core);
+
+/**
+ * dwc_otg_core_stop
+ *
+ * Stop chip operation.
+ */
+void dwc_otg_core_stop(dwc_otg_core_t *_core);
+
+/**
+ * dwc_otg_core_ep_reset
+ *
+ * Resets all of the endpoints, cancelling any
+ * current requests.
+ */
+void dwc_otg_core_ep_reset(dwc_otg_core_t *_core);
+
+/**
+ * dwc_otg_core_enable_interrupts
+ *
+ * Enables interrupts.
+ */
+int dwc_otg_core_enable_interrupts(dwc_otg_core_t *_core);
+
+/**
+ * dwc_otg_core_disable_interrupts
+ *
+ * Disables interrupts.
+ */
+int dwc_otg_core_disable_interrupts(dwc_otg_core_t *_core);
+
+/**
+ * The core USB IRQ handler.
+ */
+irqreturn_t dwc_otg_core_irq(int _irq, void *_dev);
+
+/**
+ * Enable an endpoint.
+ */
+int dwc_otg_core_enable_ep(dwc_otg_core_t *_core, dwc_otg_core_ep_t *_ep, struct usb_endpoint_descriptor *_desc);
+
+/**
+ * Disable an endpoint.
+ */
+int dwc_otg_core_disable_ep(dwc_otg_core_t *_core, dwc_otg_core_ep_t *_ep);
+
+/**
+ * Stall an endpoint.
+ */
+int dwc_otg_core_stall_ep(dwc_otg_core_t *_core, dwc_otg_core_ep_t *_ep, int _stall);
+
+/**
+ * dwc_otg_core_enqueue_request
+ *
+ * Queue a request.
+ */
+int dwc_otg_core_enqueue_request(dwc_otg_core_t *_core, dwc_otg_core_ep_t *_ep, dwc_otg_core_request_t *_req);
+
+/**
+ * dwc_otg_core_start_request
+ */
+int dwc_otg_core_start_request(dwc_otg_core_t *_core, dwc_otg_core_request_t *_req);
+
+/**
+ * dwc_otg_core_complete_request
+ */
+int dwc_otg_core_complete_request(dwc_otg_core_t *_core, dwc_otg_core_request_t *_req);
+
+/**
+ * Cancel all current requests.
+ */
+int dwc_otg_core_cancel_all_requests(dwc_otg_core_t *_core);
+
+/**
+ * dwc_otg_mps_from_speed
+ */
+static inline int dwc_otg_mps_from_speed(int _speed)
+{
+	if(_speed == DWC_OTG_HIGH_SPEED)
+		return 512;
+
+	if(_speed == DWC_OTG_FULL_SPEED)
+		return 64;
+
+	if(_speed == DWC_OTG_LOW_SPEED)
+		return 32;
+
+	DWC_WARNING("%s called with invalid speed, %d.\n", __func__, _speed);
+	return -1;
+}
+
+#endif //__DWC_OTG_CORE_H__
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_device.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_device.c
--- linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_device.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_device.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,764 @@
+/*
+ * dwc_otg_device.c - device-mode specific functions
+ *
+ * Author: Ricky Taylor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "dwc_otg_device.h"
+#include "dwc_otg_hw.h"
+#include "dwc_otg_gadget.h"
+
+/**
+ * dwc_otg_device_init
+ *
+ * Initialise the dwc_otg_device structure, and the hardware
+ * so that it can run in device mode.
+ */
+int dwc_otg_device_init(dwc_otg_device_t *_dev, dwc_otg_core_t *_core)
+{
+	int ret = 0;
+
+	if(!_dev)
+	{
+		DWC_ERROR("%s passed a null device structure pointer!\n", __func__);
+		return -EINVAL;
+	}
+
+	// Clear device structure.
+	// (This should have been by the driver,
+	//  but better safe than sorry.)
+	memset(_dev, sizeof(dwc_otg_device_t), 0);
+
+	// Initialise members
+	_dev->remote_wakeup = 1;
+
+	if(!_core)
+	{
+		DWC_ERROR("%s passed a null core structure pointer!\n", __func__);
+		return -EINVAL;
+	}
+	else
+		_dev->core = _core;
+
+	// Register IRQ.
+	ret = request_irq(_core->irq, dwc_otg_device_irq, IRQF_SHARED, DWC_OTG_DRIVER_NAME, _dev);
+	if(ret)
+	{
+		DWC_ERROR("Failed to register IRQ (%#x).\n", ret);
+		return ret;
+	}
+	else
+		_dev->irq = _core->irq;
+
+	
+	return 0;
+}
+
+/**
+ * dwc_otg_device_destroy
+ *
+ * Release all resources used by device mode, and return
+ * the hardware to its original state.
+ */
+void dwc_otg_device_destroy(dwc_otg_device_t *_dev)
+{
+	if(!_dev)
+	{
+		DWC_WARNING("%s passed a null device structure pointer!\n", __func__);
+		return;
+	}
+
+	if(_dev->irq)
+		free_irq(_dev->irq, _dev);
+}
+
+/**
+ * dwc_otg_device_start
+ *
+ * Start device mode on the chip.
+ */
+int dwc_otg_device_start(dwc_otg_device_t *_dev)
+{
+	int ret = 0;
+
+	if(!_dev)
+	{
+		DWC_ERROR("%s passed a null device structure pointer!\n", __func__);
+		return -EINVAL;
+	}
+
+	DWC_VERBOSE("%s(%p)\n", __func__, _dev);
+
+	// Enable Interrupts
+	if(dwc_otg_device_enable_interrupts(_dev))
+		DWC_WARNING("Failed to enable device interrupts.\n");
+	
+	// Reset the device.
+	dwc_otg_device_usb_reset(_dev);
+
+	// We're all set up, tell the usb_gadget framework
+	// that we exist.
+	ret = usb_gadget_register_controller(_dev);
+	if(ret)
+	{
+		DWC_ERROR("Failed to register controller.\n");
+		return ret;
+	}
+	
+
+	return 0;
+}
+
+/**
+ * dwc_otg_device_stop
+ *
+ * Stop device mode on the chip.
+ */
+void dwc_otg_device_stop(dwc_otg_device_t *_dev)
+{
+	if(!_dev)
+	{
+		DWC_WARNING("%s passed a null device structure pointer!\n", __func__);
+		return;
+	}
+
+	if(dwc_otg_device_disable_interrupts(_dev))
+		DWC_WARNING("Failed to disable device interrupts.\n");
+}
+
+/**
+ * dwc_otg_device_enable_interrupts
+ *
+ * enables interrupts.
+ */
+int dwc_otg_device_enable_interrupts(dwc_otg_device_t *_dev)
+{
+	gintmsk_data_t gintmsk = { .d32 = 0 };
+
+	DWC_VERBOSE("%s(%p)\n", __func__, _dev);
+
+	gintmsk.b.usbreset = 1;
+	gintmsk.b.usbsuspend = 1;
+	gintmsk.b.disconnect = 1;
+	gintmsk.b.inepintr = 1;
+	gintmsk.b.outepintr = 1;
+	gintmsk.b.enumdone = 1;
+	gintmsk.b.otgintr = 1;
+	dwc_otg_modify_reg32(&_dev->core->registers->gintmsk, 0, gintmsk.d32);
+
+	return 0;
+}
+
+/**
+ * dwc_otg_device_disable_interrupts
+ *
+ * disables interrupts.
+ */
+int dwc_otg_device_disable_interrupts(dwc_otg_device_t *_dev)
+{
+	gintmsk_data_t gintmsk = { .d32 = 0 };
+
+	DWC_VERBOSE("%s(%p)\n", __func__, _dev);
+
+	gintmsk.b.usbreset = 1;
+	gintmsk.b.inepintr = 1;
+	gintmsk.b.outepintr = 1;
+	gintmsk.b.enumdone = 1;
+	dwc_otg_modify_reg32(&_dev->core->registers->gintmsk, gintmsk.d32, 0);
+
+	return 0;
+}
+
+/**
+ * dwc_otg_device_reset_usb
+ *
+ * Resets the USB connection and re-enables EP0.
+ */
+int dwc_otg_device_usb_reset(dwc_otg_device_t *_dev)
+{
+	diepmsk_data_t diepmsk = { .d32 = 0 };
+	doepmsk_data_t doepmsk = { .d32 = 0 };
+	dcfg_data_t dcfg = { .d32 = 0 };
+	daint_data_t daint = { .d32 = 0 };
+
+	DWC_VERBOSE("%s(%p)\n", __func__, _dev);
+
+	// Clear Device Address
+	dcfg.b.devaddr = DWC_DCFG_DEVADDR_MASK;
+	dwc_otg_modify_reg32(&_dev->core->device_registers->dcfg, dcfg.d32, 0);
+
+	// Reset EPs
+	dwc_otg_core_ep_reset(_dev->core);
+
+	// Enable interrupts on EP0
+	daint.b.inep0 = 1;
+	daint.b.outep0 = 1;
+	dwc_otg_write_reg32(&_dev->core->device_registers->daintmsk, daint.d32);
+
+	// Clear EP0 interrupts
+	dwc_otg_write_reg32(&_dev->core->in_ep_registers[0]->diepint, 0xffffffff);
+	dwc_otg_write_reg32(&_dev->core->out_ep_registers[0]->doepint, 0xffffffff);
+
+	// Enable EP Interrupts
+	diepmsk.b.xfercompl = 1;
+	diepmsk.b.ahberr = 1;
+	diepmsk.b.timeout = 1;
+	dwc_otg_write_reg32(&_dev->core->device_registers->diepmsk, diepmsk.d32);
+
+	doepmsk.b.xfercompl = 1;
+	doepmsk.b.setup = 1;
+	doepmsk.b.back2backsetup = 1;
+	dwc_otg_write_reg32(&_dev->core->device_registers->doepmsk, doepmsk.d32);
+
+	return 0;
+}
+
+/** The EP0 USB descriptor! */
+static struct usb_endpoint_descriptor ep0_descriptor = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+
+	.bEndpointAddress = 0,
+	.bmAttributes = 0,
+};
+
+/**
+ * The device USB IRQ handler.
+ */
+irqreturn_t dwc_otg_device_irq(int _irq, void *_dev)
+{
+	dwc_otg_device_t *dev = (dwc_otg_device_t*)_dev;
+	dwc_otg_core_t *core = dev->core;
+	gintsts_data_t gintsts = { .d32 = 0 };
+	gintsts_data_t gintclr = { .d32 = 0 };
+
+	gintsts.d32 = dwc_otg_read_reg32(&core->registers->gintsts) & dwc_otg_read_reg32(&core->registers->gintmsk);
+	DWC_VERBOSE("%s(%d, %p) gintsts=0x%08x\n", __func__, _irq, _dev, gintsts.d32);
+
+	if(gintsts.b.otgintr)
+	{
+		gotgint_data_t gotgint;
+		
+		gotgint.d32 = dwc_otg_read_reg32(&core->registers->gotgint);
+		DWC_DEBUG("otgintr 0x%08x\n", gotgint.d32);
+
+		if(gotgint.b.sesenddet)
+		{
+			dcfg_data_t dcfg = { .d32 = 0 };
+
+			DWC_DEBUG("session end detected\n");
+
+			// Clear Device Address
+			dcfg.b.devaddr = DWC_DCFG_DEVADDR_MASK;
+			dwc_otg_modify_reg32(&dev->core->device_registers->dcfg, dcfg.d32, 0);
+
+			// Reset EPs
+			dwc_otg_core_ep_reset(dev->core);
+
+			// Notify gadget driver
+			if(dwc_otg_gadget_driver && dwc_otg_gadget_driver->disconnect)
+				dwc_otg_gadget_driver->disconnect(&dwc_otg_gadget);
+		}
+
+		// Clear OTG interrupts
+		dwc_otg_write_reg32(&core->registers->gotgint, 0xffffffff);
+
+		gintclr.b.otgintr = 1;
+	}
+
+	if(gintsts.b.enumdone)
+	{
+		int dwcSpeed;
+		int i;
+		dsts_data_t dsts;
+
+		DWC_DEBUG("enumdone\n");
+
+		// Enable EP0.
+		dwc_otg_core_enable_ep(core, &core->endpoints[0], &ep0_descriptor);
+		
+		// Listen for setup packets on EP0.
+		dwc_otg_device_receive_ep0(_dev);
+
+		// Tell gadget driver our top speed.
+		dsts.d32 = dwc_otg_read_reg32(&core->device_registers->dsts);
+		switch (dsts.b.enumspd)
+		{
+		case DWC_DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
+			dwc_otg_gadget.speed = USB_SPEED_HIGH;
+			dwcSpeed = DWC_OTG_HIGH_SPEED;
+			break;
+
+		case DWC_DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
+		case DWC_DSTS_ENUMSPD_FS_PHY_48MHZ:
+			dwc_otg_gadget.speed = USB_SPEED_FULL;
+			dwcSpeed = DWC_OTG_FULL_SPEED;
+			break;
+
+		case DWC_DSTS_ENUMSPD_LS_PHY_6MHZ:
+			dwc_otg_gadget.speed = USB_SPEED_LOW;
+			dwcSpeed = DWC_OTG_LOW_SPEED;
+			break;
+		}
+		
+		// Update the endpoint speeds.
+		for(i = 1; i < core->num_eps; i++)
+			core->endpoints[i].speed = dwcSpeed;
+
+		gintclr.b.enumdone = 1;
+	}
+
+	if(gintsts.b.usbreset)
+	{
+		DWC_DEBUG("usbreset\n");
+		
+		dwc_otg_device_usb_reset(dev);
+
+		// Notify gadget driver
+		if(dwc_otg_gadget_driver && dwc_otg_gadget_driver->resume)
+			dwc_otg_gadget_driver->resume(&dwc_otg_gadget);
+
+		gintclr.b.usbreset = 1;
+	}
+
+	if(gintsts.b.usbsuspend)
+	{
+		DWC_DEBUG("usbsuspend\n");
+
+		// Notify gadget driver
+		if(dwc_otg_gadget_driver && dwc_otg_gadget_driver->suspend)
+			dwc_otg_gadget_driver->suspend(&dwc_otg_gadget);
+
+		gintclr.b.usbsuspend = 1;
+	}
+
+	if(gintsts.b.disconnect)
+	{
+		dcfg_data_t dcfg = { .d32 = 0 };
+
+		DWC_DEBUG("disconnect\n");
+
+		// Clear Device Address
+		dcfg.b.devaddr = DWC_DCFG_DEVADDR_MASK;
+		dwc_otg_modify_reg32(&dev->core->device_registers->dcfg, dcfg.d32, 0);
+
+		// Reset EPs
+		dwc_otg_core_ep_reset(dev->core);
+
+		// Notify gadget driver
+		if(dwc_otg_gadget_driver && dwc_otg_gadget_driver->disconnect)
+			dwc_otg_gadget_driver->disconnect(&dwc_otg_gadget);
+
+		gintclr.b.disconnect = 1;
+	}
+
+	if(gintsts.b.inepintr || gintsts.b.outepintr)
+	{
+		daint_data_t daint = { .d32 = 0 };
+		int i;
+
+		DWC_DEBUG("epint\n");
+
+		daint.d32 = dwc_otg_read_reg32(&core->device_registers->daint) & dwc_otg_read_reg32(&core->device_registers->daintmsk);
+
+		for(i = 0; i < core->num_eps; i++)
+		{
+			if(daint.ep.in & 1)
+				dwc_otg_device_handle_in_interrupt(dev, i);
+
+			if(daint.ep.out & 1)
+				dwc_otg_device_handle_out_interrupt(dev, i);
+
+			daint.ep.out >>= 1;
+			daint.ep.in >>= 1;
+		}
+	}
+
+	// Clear the interrupts
+	gintsts.d32 &= ~gintclr.d32;
+	dwc_otg_write_reg32(&core->registers->gintsts, gintclr.d32);
+	return gintsts.d32 != 0 ? IRQ_NONE : IRQ_HANDLED;
+}
+
+/**
+ * The in endpoint interrupt handler.
+ */
+irqreturn_t dwc_otg_device_handle_in_interrupt(dwc_otg_device_t *_dev, int _ep)
+{
+	dwc_otg_core_ep_t *ep = &_dev->core->endpoints[_ep];
+	diepint_data_t depint = { .d32 = 0 };
+
+	DWC_VERBOSE("%s(%p, %d)\n", __func__, _dev, _ep);
+
+	depint.d32 = dwc_otg_read_reg32(&ep->in_registers->diepint) & dwc_otg_read_reg32(&_dev->core->device_registers->diepmsk);
+	dwc_otg_write_reg32(&ep->in_registers->diepint, depint.d32); // Clear them all, since nobody else is gonna care.
+
+	if(!ep->exists)
+	{
+		DWC_ERROR("%s called on non-existant in endpoint %d.\n", __func__, _ep);
+		return -ENXIO;
+	}
+
+	if(depint.b.inepnakeff)
+	{
+		DWC_DEBUG("in ep nak eff\n");
+
+		// Do nothing...
+	}
+
+	if(depint.b.intknepmis)
+	{
+		gintsts_data_t gintsts = { .d32 = 0 };
+
+		DWC_DEBUG("in tn mis\n");
+
+		gintsts.b.epmismatch = 1;
+		dwc_otg_modify_reg32(&_dev->core->registers->gintsts, gintsts.d32, 0);
+	}
+
+	if(depint.b.intktxfemp)
+	{
+		DWC_DEBUG("in tx f emp\n");
+
+		// Do nothing... ;_;
+	}
+
+	if(depint.b.timeout)
+	{
+		DWC_DEBUG("in timeout\n");
+
+		// Do something!?
+		// Cancel sending?!
+	}
+
+	if(depint.b.ahberr)
+	{
+		DWC_DEBUG("in ahberr\n");
+
+		// Do nothing again... :'(
+	}
+
+	if(depint.b.epdisabled)
+	{
+		DWC_DEBUG("in epdisabled\n");
+
+		// Do naught. :''(
+	}
+
+	if(depint.b.xfercompl)
+	{
+		DWC_DEBUG("in xfercompl\n");
+
+		if(list_empty(&ep->transfer_queue))
+		{
+			DWC_ERROR("XferCompl received when we weren't transferring anything!\n");
+		}
+		else
+			dwc_otg_core_complete_request(_dev->core, list_first_entry(&ep->transfer_queue, dwc_otg_core_request_t, queue_pointer));
+	}
+	
+	return 0;
+}
+
+/**
+ * The out endpoint interrupt handler.
+ */
+irqreturn_t dwc_otg_device_handle_out_interrupt(dwc_otg_device_t *_dev, int _ep)
+{
+	dwc_otg_core_ep_t *ep = &_dev->core->endpoints[_ep];
+	doepint_data_t depint = { .d32 = 0 };
+
+	DWC_VERBOSE("%s(%p, %d)\n", __func__, _dev, _ep);
+
+	depint.d32 = dwc_otg_read_reg32(&ep->out_registers->doepint) & dwc_otg_read_reg32(&_dev->core->device_registers->doepmsk);
+	dwc_otg_write_reg32(&ep->out_registers->doepint, depint.d32); // Clear them all, since nobody else is gonna care.
+
+	if(!ep->exists)
+	{
+		DWC_ERROR("%s called on non-existant in endpoint %d.\n", __func__, _ep);
+		return -ENXIO;
+	}
+
+	if(depint.b.setup)
+	{
+		dwc_otg_core_request_t *req;
+
+		// We received a setup packet, yaaay! 
+		DWC_VERBOSE("setup\n");
+
+		// If we had a setup packet, set the flag on the
+		// request that says it was prepended by a setup
+		// token.
+		req = list_first_entry(&ep->transfer_queue, dwc_otg_core_request_t, queue_pointer);
+		if(!list_empty(&ep->transfer_queue) && req->direction == DWC_OTG_REQUEST_OUT)
+		{
+			req->setup = 1;
+			dwc_otg_core_complete_request(_dev->core, req);
+		}
+		else
+			DWC_ERROR("Setup Packet Received without us initiating a transfer!\n");
+	}
+
+	if(depint.b.back2backsetup)
+	{
+		// Do nothing
+		DWC_DEBUG("back2backsetup\n");
+	}
+
+	if(depint.b.epdisabled)
+	{
+		// Do nothing... ;_;
+		DWC_DEBUG("out epdisabled\n");
+	}
+
+	if(depint.b.ahberr)
+	{
+		// Do nothing again... :'(
+		DWC_DEBUG("out ahberr\n");
+	}
+		
+	if(depint.b.outtknepdis)
+	{
+		// Nothing to do again! Wah... :''(
+		DWC_DEBUG("out tkn epdis\n");
+	}
+
+	if(depint.b.xfercompl)
+	{
+		DWC_DEBUG("out xfercompl\n");
+
+		// Yay! :D
+
+		if(list_empty(&ep->transfer_queue))
+		{
+			DWC_ERROR("XferCompl received when we weren't transferring anything!\n");
+		}
+		else
+			dwc_otg_core_complete_request(_dev->core, list_first_entry(&ep->transfer_queue, dwc_otg_core_request_t, queue_pointer));
+	}
+
+	return 0;
+}
+
+static dwc_otg_core_request_t ep0_out_request = {
+	.request_type = DWC_EP_TYPE_CONTROL,
+	.direction = DWC_OTG_REQUEST_OUT,
+	.completed_handler = &dwc_otg_device_complete_ep0,
+	.dont_free = 1,	
+	.buffer_length = 64,
+	.dma_buffer = NULL,
+};
+
+static dwc_otg_core_request_t ep0_in_request = {
+	.request_type = DWC_EP_TYPE_CONTROL,
+	.direction = DWC_OTG_REQUEST_IN,
+	.dont_free = 1,
+	.buffer_length = 64,
+	.dma_buffer = NULL,
+};
+
+/**
+ * dwc_otg_device_receive_ep0
+ */
+void dwc_otg_device_receive_ep0(dwc_otg_device_t *_dev)
+{
+	ep0_out_request.data = _dev;
+	ep0_out_request.length = 8; //ep0_out_request.buffer_length;
+
+	if(ep0_out_request.dma_buffer == NULL)
+	{
+		ep0_out_request.dma_buffer = dma_alloc_coherent(NULL, ep0_out_request.buffer_length, &ep0_out_request.dma_address, GFP_KERNEL);
+		if(!ep0_out_request.dma_buffer)
+		{
+			DWC_ERROR("Failed to allocate setup buffer for EP0!\n");
+			return;
+		}
+
+		// As we've allocated a DMA buffer, we don't
+		// need another. :D -- Ricky26
+		ep0_out_request.buffer = ep0_out_request.dma_buffer;
+
+		// Setup the in request, as we might need it as a response.
+		ep0_in_request.length = ep0_in_request.buffer_length;
+		ep0_in_request.dma_buffer = dma_alloc_coherent(NULL, ep0_in_request.buffer_length, &ep0_in_request.dma_address, GFP_KERNEL);
+		if(!ep0_in_request.dma_buffer)
+		{
+			DWC_ERROR("Failed to allocate in buffer for EP0!\n");
+			return;
+		}
+
+		ep0_in_request.buffer = ep0_in_request.dma_buffer;
+	}
+
+	DWC_VERBOSE("%s: enqueue (%p):%d\n", __func__, &ep0_out_request, ep0_out_request.length);
+	dwc_otg_core_enqueue_request(_dev->core, &_dev->core->endpoints[0], &ep0_out_request);
+}
+
+/**
+ * dwc_otg_device_send_ep0
+ */
+void dwc_otg_device_send_ep0(dwc_otg_device_t *_dev)
+{
+	ep0_in_request.data = _dev;
+	dwc_otg_core_enqueue_request(_dev->core, &_dev->core->endpoints[0], &ep0_in_request);
+}
+
+/**
+ * dwc_otg_device_complete_ep0
+ *
+ * This is called to complete an interrupt on EP0.
+ */
+void dwc_otg_device_complete_ep0(dwc_otg_core_request_t *_req)
+{
+	dwc_otg_core_t *core = _req->core;
+	dwc_otg_device_t *dev = (dwc_otg_device_t*)_req->data;
+	
+	if(_req->cancelled)
+	{
+		DWC_VERBOSE("Shutting down EP0 control channel.\n");
+		return;
+	}
+
+	if(_req->setup)
+	{
+		struct usb_ctrlrequest *packet = (struct usb_ctrlrequest*)_req->buffer;
+
+#if defined(VERBOSE)&&defined(DEBUG)
+		uint8_t *b = (uint8_t*)packet;
+		
+		DWC_PRINT("EP0 Sent us a setup packet! :3\n");
+		DWC_PRINT("%02x %02x %02x %02x %02x %02x %02x %02x\n", 
+				b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
+		DWC_PRINT("RT %d, R %d, w %d\n", packet->bRequestType & 0x7F, packet->bRequest, packet->wIndex);
+#endif
+
+		if((packet->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)
+		{
+			int set = 0;
+
+			switch(packet->bRequest)
+			{
+				case USB_REQ_GET_STATUS:
+					{
+						uint16_t *result = (uint16_t*)ep0_in_request.buffer;
+
+						switch (packet->bRequestType & USB_RECIP_MASK)
+						{
+						case USB_RECIP_DEVICE:
+							*result = 0x1 | (1 << dev->remote_wakeup); // Self powered, remote wakeup enabled.
+							break;
+
+						case USB_RECIP_INTERFACE:
+							*result = 0;
+							break;
+
+						case USB_RECIP_ENDPOINT:
+							{
+								// TODO: check this!
+								int epnum = packet->wIndex & 0xf;
+								if(epnum < core->num_eps &&
+										list_empty(&core->endpoints[epnum].transfer_queue))
+								{
+									*result = 0;
+									break;
+								}
+
+								*result = 1;
+							}
+							break;
+						}
+						
+						ep0_in_request.length = 2;
+						dwc_otg_device_send_ep0(dev);
+					}
+					goto send_zlp;
+
+				case USB_REQ_SET_FEATURE:
+					set = 1;
+					// fall through
+				case USB_REQ_CLEAR_FEATURE:
+
+					switch (packet->bRequestType & USB_RECIP_MASK)
+					{
+						case USB_RECIP_DEVICE:
+							switch(packet->wValue)
+							{
+								case USB_DEVICE_REMOTE_WAKEUP:
+									dev->remote_wakeup = set;
+									break;
+							}
+							break;
+
+						case USB_RECIP_ENDPOINT:
+							{
+								int ep = packet->wValue;
+								if(ep == 0 || ep > core->num_eps)
+									goto stall;
+
+								dwc_otg_core_stall_ep(core, &core->endpoints[ep], set);
+							}
+							break;
+
+					}
+					goto send_zlp;
+
+				case USB_REQ_SET_ADDRESS:
+					{
+						dcfg_data_t dcfg = { .d32 = 0 };
+
+						dcfg.d32 = dwc_otg_read_reg32(&core->device_registers->dcfg);
+						dcfg.b.devaddr = packet->wValue;
+						dwc_otg_write_reg32(&core->device_registers->dcfg, dcfg.d32);
+
+						DWC_VERBOSE("Received address %d.\n", dcfg.b.devaddr);
+					}
+					goto send_zlp;
+			}
+		}
+
+		// If we got here we don't know how to handle
+		// the setup packet, so let's ask the gadget driver to
+		// do it, and then blame it if it doesn't work...
+
+		DWC_VERBOSE("Passing setup packet to gadget driver.\n");
+		if(dwc_otg_gadget_driver == NULL)
+		{
+			DWC_WARNING("No gadget driver yet, stalling.\n");
+			goto stall;
+		}
+
+		if(dwc_otg_gadget_driver->setup(&dwc_otg_gadget, packet))
+		{
+			DWC_ERROR("Got a setup packet we don't handle properly yet.\n");
+			goto stall;
+		}
+
+		goto exit;
+	}
+	else if(ep0_out_request.length == 0)
+	{
+		DWC_VERBOSE("Received a ZLP from host.\n");
+	}
+	else
+	{
+		DWC_ERROR("EP0 sent us some shit we don't know how to handle.\n");
+	}
+
+	goto exit;
+
+stall:
+	dwc_otg_core_stall_ep(core, &core->endpoints[0], 1);
+	goto exit;
+
+send_zlp:
+	ep0_in_request.length = 0;
+	dwc_otg_device_send_ep0(dev);
+
+exit:
+	if(_req->direction == DWC_OTG_REQUEST_OUT)
+		dwc_otg_device_receive_ep0(dev);
+}
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_device.h iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_device.h
--- linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_device.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_device.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,122 @@
+/*
+ * dwc_otg_device.h - header for device-mode specific functions
+ *
+ * Author: Ricky Taylor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef  __DWC_OTG_DEVICE_H__
+#define  __DWC_OTG_DEVICE_H__
+
+#include "dwc_otg_core.h"
+
+/**
+ * @file dwc_otg_device.h
+ *
+ * This file pair contains all of the device-mode specific code.
+ */
+
+/**
+ * This structure defines the state and parameters
+ * of the device mode of the OTG chip.
+ */
+typedef struct dwc_otg_device_struct
+{
+	/** The representation of the core. */
+	dwc_otg_core_t *core;
+
+	/** The IRQ of the device. */
+	int irq;
+
+	/** Whether remote wakeup is enabled. */
+	unsigned remote_wakeup : 1;
+
+} dwc_otg_device_t;
+
+/**
+ * dwc_otg_device_init
+ *
+ * Initialise the dwc_otg_device structure, and the hardware
+ * so that it can run in device mode.
+ */
+int dwc_otg_device_init(dwc_otg_device_t *_dev, dwc_otg_core_t *_core);
+
+/**
+ * dwc_otg_device_destroy
+ *
+ * Release all resources used by device mode, and return
+ * the hardware to its original state.
+ */
+void dwc_otg_device_destroy(dwc_otg_device_t *_dev);
+
+/**
+ * dwc_otg_device_start
+ *
+ * Start device mode on the chip.
+ */
+int dwc_otg_device_start(dwc_otg_device_t *_dev);
+
+/**
+ * dwc_otg_device_stop
+ *
+ * Stop device mode on the chip.
+ */
+void dwc_otg_device_stop(dwc_otg_device_t *_dev);
+
+/**
+ * dwc_otg_device_enable_interrupts
+ *
+ * Enables interrupts.
+ */
+int dwc_otg_device_enable_interrupts(dwc_otg_device_t *_dev);
+
+/**
+ * dwc_otg_device_disable_interrupts
+ *
+ * Disables interrupts.
+ */
+int dwc_otg_device_disable_interrupts(dwc_otg_device_t *_dev);
+
+/**
+ * dwc_otg_device_reset_usb
+ *
+ * Resets the USB connection and re-enables EP0.
+ */
+int dwc_otg_device_usb_reset(dwc_otg_device_t *_dev);
+
+/**
+ * The device USB IRQ handler.
+ */
+irqreturn_t dwc_otg_device_irq(int _irq, void *_dev);
+
+/**
+ * The in endpoint interrupt handler.
+ */
+irqreturn_t dwc_otg_device_handle_in_interrupt(dwc_otg_device_t *_dev, int _ep);
+
+/**
+ * The out endpoint interrupt handler.
+ */
+irqreturn_t dwc_otg_device_handle_out_interrupt(dwc_otg_device_t *_dev, int _ep);
+
+/**
+ * dwc_otg_device_receive_ep0
+ */
+void dwc_otg_device_receive_ep0(dwc_otg_device_t *_dev);
+
+/**
+ * dwc_otg_device_send_ep0
+ */
+void dwc_otg_device_send_ep0(dwc_otg_device_t *_dev);
+
+/**
+ * dwc_otg_device_complete_ep0
+ *
+ * This is called to complete an interrupt on EP0.
+ */
+void dwc_otg_device_complete_ep0(dwc_otg_core_request_t *_req);
+
+#endif //__DWC_OTG_DEVICE_H__
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_driver.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_driver.c
--- linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_driver.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_driver.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,227 @@
+/*
+ * dwc_otg_driver.c - platform-device specific functions
+ *
+ * Author: Ricky Taylor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "dwc_otg_driver.h"
+
+#include <linux/irq.h>
+#include <asm/io.h>
+
+#include "dwc_otg_regs.h"
+
+int dwc_otg_ioremap(dwc_otg_iomapping_t *_map, struct resource *_rsrc)
+{
+	struct resource *mapping = NULL;
+
+	if(!_map)
+		return -EINVAL;
+
+	memset(_map, sizeof(dwc_otg_iomapping_t), 0);
+
+	if(!_rsrc)
+		return -EINVAL;
+
+	mapping = request_mem_region(_rsrc->start, resource_size(_rsrc), DWC_OTG_DRIVER_NAME);
+	if(!mapping)
+	{
+		DWC_ERROR("Failed to request memory region (address=0x%08x, length=0x%08x).\n",
+				_rsrc->start,
+				resource_size(_rsrc));
+		return -EIO;
+	}
+
+	_map->physical_address = _rsrc->start;
+	_map->length = resource_size(_rsrc);
+	_map->address = ioremap(_map->physical_address, _map->length);
+	if(!_map->address)
+	{
+		DWC_ERROR("ioremap failed for memory region (address=0x%08x, length=0x%08x).\n",
+			_rsrc->start,
+			resource_size(_rsrc));
+		return -EIO;
+	}
+
+	return 0;
+}
+
+void dwc_otg_iounmap(dwc_otg_iomapping_t *_map)
+{
+	if(!_map)
+		return;
+
+	if(_map->address)
+	{
+		iounmap(_map->address);
+		_map->address = NULL;
+	}
+
+	if(_map->physical_address)
+	{
+		release_mem_region(_map->physical_address, _map->length);
+		_map->physical_address = 0;
+		_map->length = 0;
+	}
+}
+
+static int dwc_otg_driver_probe(struct platform_device *_dev)
+{
+	dwc_otg_driver_t *driver = NULL;
+	struct resource *resource = NULL;
+	int ret = 0;
+
+	DWC_PRINT("DWC OTG Hardware Detected.\n");
+
+	// Allocate the driver structure.
+	driver = kmalloc(sizeof(dwc_otg_driver_t), GFP_KERNEL);
+	if(!driver)
+	{
+		DWC_ERROR("Failed to allocate driver structure.\n");
+		return -ENOMEM;
+	}
+
+	// Clear the driver structure!
+	memset(driver, sizeof(dwc_otg_driver_t), 0);
+
+	// Store the driver structure!
+	platform_set_drvdata(_dev, driver);
+
+	// Request IRQ.
+	driver->irq = platform_get_irq(_dev, 0);
+	if(!driver->irq)
+	{
+		DWC_ERROR("Failed to retrieve device IRQ.\n");
+		// TODO: Does _remove still get called if we return an error? -- Ricky26
+		return -ENXIO;
+	}
+
+	// Request register memory.
+	resource = platform_get_resource(_dev, IORESOURCE_MEM, 0);
+	if(!resource)
+	{
+		DWC_ERROR("Failed to get register memory resource.\n");
+		return -ENXIO;
+	}
+
+	// Claim register memory.
+	if(dwc_otg_ioremap(&driver->registers, resource))
+	{
+		DWC_ERROR("Failed to claim register memory.\n");
+		return -EIO;
+	}
+
+	// Request PHY memory.
+	resource = platform_get_resource(_dev, IORESOURCE_MEM, 1);
+	if(resource)
+	{
+		if(dwc_otg_ioremap(&driver->phy_registers, resource))
+		{
+			DWC_ERROR("Failed to claim PHY register memory.\n");
+			return -EIO;
+		}
+	}
+
+	// Initialise the core.
+	ret = dwc_otg_core_init(&driver->core, driver->irq, driver->registers.address, driver->phy_registers.address);
+	if(ret)
+	{
+		DWC_ERROR("Failed to initialise the core!\n");
+		return ret;
+	}
+
+	// Initialise device mode.
+	ret = dwc_otg_device_init(&driver->device, &driver->core);
+	if(ret)
+	{
+		DWC_ERROR("Failed to initialise device mode!\n");
+		return ret;
+	}
+
+	// Start core operation.
+	ret = dwc_otg_core_start(&driver->core);
+	if(ret)
+	{
+		DWC_ERROR("Failed to start core.\n");
+		return ret;
+	}
+
+	// Start device mode.
+	ret = dwc_otg_device_start(&driver->device);
+	if(ret)
+	{
+		DWC_ERROR("Failed to start device mode.\n");
+		return ret;
+	}
+
+	DWC_PRINT("DWC OTG Driver Installed.\n");
+
+	return 0;
+}
+
+static int dwc_otg_driver_remove(struct platform_device *_dev)
+{
+	dwc_otg_driver_t *driver = dwc_otg_driver_get(_dev);
+	if(driver)
+	{
+		dwc_otg_device_stop(&driver->device);
+		dwc_otg_core_stop(&driver->core);
+
+		dwc_otg_device_destroy(&driver->device);
+		dwc_otg_core_destroy(&driver->core);
+
+		dwc_otg_iounmap(&driver->registers);
+		dwc_otg_iounmap(&driver->phy_registers);
+
+		kfree(driver);
+		platform_set_drvdata(_dev, NULL);
+	}
+
+	DWC_PRINT("DWC OTG Driver Removed.\n");
+
+	return 0;
+}
+
+struct platform_driver dwc_otg_driver = {
+	.probe = dwc_otg_driver_probe,
+	.remove = dwc_otg_driver_remove,
+	.suspend = NULL, /* optional but recommended */
+	.resume = NULL,   /* optional but recommended */
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DWC_OTG_DRIVER_NAME,
+	},
+};
+
+static int dwc_otg_driver_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&dwc_otg_driver);
+	if(ret)
+	{
+		DWC_ERROR("Failed to register driver (0x%08x).\n", ret);
+		return ret;
+	}
+
+	DWC_PRINT("DWC OTG Driver Loaded.\n");
+
+	return ret;
+}
+module_init(dwc_otg_driver_init);
+
+static void dwc_otg_driver_exit(void)
+{
+	platform_driver_unregister(&dwc_otg_driver);
+
+	DWC_PRINT("DWC OTG Driver Unloaded.\n");
+}
+module_exit(dwc_otg_driver_exit);
+
+MODULE_DESCRIPTION("Synopsys On-the-Go USB DesignWare Core");
+MODULE_AUTHOR("Ricky Taylor <rickytaylor26@gmail.com>");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_driver.h iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_driver.h
--- linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_driver.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_driver.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,99 @@
+/*
+ * dwc_otg_driver.h - header for platform-device specific functions
+ *
+ * Author: Ricky Taylor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef  __DWC_OTG_DRIVER_H__
+#define  __DWC_OTG_DRIVER_H__
+
+#include <linux/platform_device.h>
+
+#include "dwc_otg.h"
+#include "dwc_otg_core.h"
+#include "dwc_otg_device.h"
+
+/**
+ * @file dwc_otg_driver.h
+ *
+ * This file contains the driver-framework specific parts of the driver.
+ *
+ * For instance, only this file and its sister code file need be altered
+ * to use this driver with standard device structures (instead of the 
+ * platform_device structures used here).
+ */
+
+/**
+ * DWC OTG IO Mapping Structure
+ *
+ * This structure is used to store current IO mappings,
+ * so that they can be released once they are finished with.
+ */
+typedef struct dwc_otg_iomapping
+{
+	/** The remapped address. Stored so it can be unmapped. */
+	void *address;
+
+	/** Physical memory address. Stored to allow memory to be released. */
+	resource_size_t physical_address; 
+
+	/** Length of memory mapping. Stored to allow memory to be released. */
+	resource_size_t length;
+
+} dwc_otg_iomapping_t;
+
+/**
+ * dwc_otg_ioremap
+ *
+ * Remaps a IORESOURCE_MEM resource into a dwc_otg_iomapping.
+ * Returns 0 on success.
+ */
+int dwc_otg_ioremap(dwc_otg_iomapping_t *_map, struct resource *_rsrc);
+
+/**
+ * dwc_otg_iounmap
+ *
+ * Releases a previously mapped dwc_otg_iomapping.
+ */
+void dwc_otg_iounmap(dwc_otg_iomapping_t *_map);
+
+/**
+ * DWC OTG Driver Structure
+ *
+ * This structure stores any information required for the
+ * platform driver.
+ */
+typedef struct dwc_otg_driver_struct
+{
+	/** The allocated IRQ. Stored here so that it can be deallocated. */
+	int irq;
+
+	/** The IO mapping for the main registers. */
+	dwc_otg_iomapping_t registers;
+
+	/** The IO mapping for the on-chip PHY's registers. */
+	dwc_otg_iomapping_t phy_registers;
+
+	/** The core state and parameters. */
+	dwc_otg_core_t core;
+
+	/** Device mode state and parameters. */
+	dwc_otg_device_t device;
+
+} dwc_otg_driver_t;
+
+/**
+ * dwc_otg_driver_get
+ *
+ * Returns the dwc_otg_driver_t for the specified platform_device.
+ */
+static inline dwc_otg_driver_t* dwc_otg_driver_get(struct platform_device *_dev)
+{
+	return (dwc_otg_driver_t*)platform_get_drvdata(_dev);
+}
+
+#endif //__DWC_OTG_DRIVER_H__
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_gadget.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_gadget.c
--- linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_gadget.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_gadget.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,423 @@
+/*
+ * dwc_otg_gadget.c - gadget API specific functions
+ *
+ * Author: Ricky Taylor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Description: MIPS USB IP core family device controller
+ *              Structures, registers and logging macros
+ */
+
+#include "dwc_otg_gadget.h"
+
+#include <linux/errno.h>
+
+/*
+ * We are forced to use static variables, O' cursed
+ * usb_gadget API!
+ */
+static dwc_otg_device_t *dwc_otg_gadget_device = NULL;
+struct usb_gadget_driver *dwc_otg_gadget_driver = NULL;
+
+/**
+ * This structure stores function pointers
+ * for all the operations the usb_gadget
+ * framework can perform on any EP we have
+ * exposed.
+ */
+static struct usb_ep_ops dwc_otg_ep_ops = {
+	.enable = &dwc_otg_gadget_enable_ep,
+	.disable = &dwc_otg_gadget_disable_ep,
+
+	.alloc_request = &dwc_otg_gadget_alloc_request,
+	.free_request = &dwc_otg_gadget_free_request,
+
+	.queue = &dwc_otg_gadget_queue_request,
+	.dequeue = &dwc_otg_gadget_dequeue_request,
+
+	.set_halt = &dwc_otg_gadget_set_halt,
+	.set_wedge = &dwc_otg_gadget_set_wedge,
+
+	.fifo_status = &dwc_otg_gadget_fifo_status,
+	.fifo_flush = &dwc_otg_gadget_fifo_flush,
+};
+
+/**
+ * This structure stores function pointers
+ * for all of the operations the usb_gadget
+ * framework can perform on the gadget 
+ * hardware.
+ */
+static struct usb_gadget_ops dwc_otg_gadget_ops = {
+	// TODO: Uh, fill this in? At least a little...? -- Ricky26
+};
+
+/**
+ * This structure stores the basic information
+ * about our gadget hardware, it also contains a pointer
+ * to @{link dwc_otg_gadget_ops}.
+ */
+struct usb_gadget dwc_otg_gadget = {
+	.ops = &dwc_otg_gadget_ops,
+	.name = DWC_OTG_DRIVER_NAME,
+
+	.is_dualspeed = 1,
+	.is_otg = 0, //1,
+	//.is_a_peripheral = 1,
+
+	//.a_hnp_support = 1,
+	//.b_hnp_enable = 1,
+	// TODO: Fill these in properly... >_>
+};
+
+/**
+ * usb_gadget_register_driver
+ *
+ * This function is called when the gadget driver is loaded
+ * to bind it to the controller.
+ */
+int usb_gadget_register_driver(struct usb_gadget_driver* _dri)
+{
+	int ret = 0;
+	int i;
+	dwc_otg_core_t *core;
+
+	if(dwc_otg_gadget_device == NULL)
+	{
+		DWC_ERROR("Tried to register gadget before driver loaded.\n");
+		return -EIO;
+	}
+
+	core = dwc_otg_gadget_device->core;
+
+	// Set up device
+	INIT_LIST_HEAD(&dwc_otg_gadget.ep_list);
+	dev_set_name(&dwc_otg_gadget.dev, "gadget");
+	dwc_otg_gadget.dev.driver = &_dri->driver;
+
+	// Set up gadget structure
+	for(i = 0; i < core->num_eps; i++)
+	{
+		dwc_otg_core_ep_t *ep = &core->endpoints[i];
+		dwc_otg_gadget_ep_t *g_ep = (dwc_otg_gadget_ep_t*)kmalloc(sizeof(dwc_otg_gadget_ep_t), GFP_KERNEL);
+		if(!g_ep)
+		{
+			DWC_ERROR("Failed to allocate usb_ep structure for endpoint %d.\n", i);
+			break;
+		}
+
+		// Clear structure
+		memset(g_ep, sizeof(dwc_otg_gadget_ep_t), 0);
+
+		INIT_LIST_HEAD(&g_ep->usb_ep.ep_list);
+		g_ep->usb_ep.driver_data = NULL;
+		g_ep->usb_ep.name = ep->name;
+		g_ep->usb_ep.ops = &dwc_otg_ep_ops;
+		g_ep->usb_ep.maxpacket =  dwc_otg_mps_from_speed(ep->speed);
+		g_ep->ep = ep;
+
+		if(i > 0)
+			list_add_tail(&g_ep->usb_ep.ep_list, &dwc_otg_gadget.ep_list);
+		else
+			dwc_otg_gadget.ep0 = &g_ep->usb_ep;
+	}
+	
+	// Register device
+	ret = device_register(&dwc_otg_gadget.dev);
+	if(ret)
+	{
+		DWC_ERROR("Failed to register gadget driver!\n");
+		return ret;
+	}
+
+	// Bind the gadget
+	ret = _dri->bind(&dwc_otg_gadget);
+	if(ret)
+	{
+		DWC_ERROR("Failed to bind gadget driver!\n");
+		return ret;
+	}
+	
+	dwc_otg_gadget_driver = _dri;
+	return ret;
+}
+EXPORT_SYMBOL(usb_gadget_register_driver);
+
+/**
+ * usb_gadget_unregister_driver
+ *
+ * This function is called when the gadget driver is being released.
+ */
+int usb_gadget_unregister_driver(struct usb_gadget_driver* _dri)
+{
+	dwc_otg_gadget_ep_t *ep0 = dwc_otg_gadget_get_ep(dwc_otg_gadget.ep0);
+	struct list_head *list_prev = &dwc_otg_gadget.ep_list;
+	struct list_head *list_ptr = list_prev->next;
+
+	dwc_otg_gadget_driver = NULL;
+
+	_dri->unbind(&dwc_otg_gadget);
+
+	while(list_ptr != &dwc_otg_gadget.ep_list)
+	{
+		struct usb_ep *usb_ep = list_entry(list_ptr, struct usb_ep, ep_list);
+		dwc_otg_gadget_ep_t *g_ep = container_of(usb_ep, dwc_otg_gadget_ep_t, usb_ep);
+
+		list_ptr = list_ptr->next;
+		list_prev->next = list_ptr;
+		list_ptr->prev = list_prev;
+		list_prev = list_prev->next;
+
+		kfree(g_ep);
+	}
+	kfree(ep0);
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+/**
+ * usb_gadget_register_controller
+ *
+ * This is called to store the current controller for use in the
+ * other usb_gadget* functions.
+ */
+int usb_gadget_register_controller(dwc_otg_device_t *_dev)
+{
+	dwc_otg_gadget_device = _dev;
+	return 0;
+}
+
+/**
+ * usb_gadget_unregister_controller
+ *
+ * This is called to release the controller.
+ */
+int usb_gadget_unregister_controller(dwc_otg_device_t *_dev)
+{
+	if(dwc_otg_gadget_device != _dev)
+		return -ENXIO;
+
+	return 0;
+}
+
+/**
+ * This function enables an EP with the parameters required
+ * for the supplied usb_endpoint_descriptor.
+ */
+int dwc_otg_gadget_enable_ep(struct usb_ep *_ep, const struct usb_endpoint_descriptor *_desc)
+{
+	dwc_otg_gadget_ep_t *ep = dwc_otg_gadget_get_ep(_ep);
+	dwc_otg_core_enable_ep(dwc_otg_gadget_device->core, ep->ep, (struct usb_endpoint_descriptor*)_desc);
+
+	DWC_VERBOSE("%s(%p, %p)\n", __func__, _ep, _desc);
+
+	return 0;
+}
+
+/**
+ * This function disables an EP.
+ */
+int dwc_otg_gadget_disable_ep(struct usb_ep *_ep)
+{
+	dwc_otg_gadget_ep_t *ep = dwc_otg_gadget_get_ep(_ep);
+	
+	DWC_VERBOSE("%s(%p)\n", __func__, _ep);
+
+	dwc_otg_core_disable_ep(dwc_otg_gadget_device->core, ep->ep);
+	return 0;
+}
+
+/**
+ * This function allocates a request, to be filled in by the caller
+ * which can then be queued to be sent to the host.
+ */
+struct usb_request *dwc_otg_gadget_alloc_request(struct usb_ep *_ep, gfp_t _gfp)
+{
+	dwc_otg_gadget_request_t *req = (dwc_otg_gadget_request_t*)kmalloc(sizeof(dwc_otg_gadget_request_t), _gfp);
+
+	DWC_VERBOSE("%s(%p, %d) sz=%d\n", __func__, _ep, _gfp, sizeof(dwc_otg_gadget_request_t));
+
+	// Clear the structure
+	memset(req, sizeof(dwc_otg_gadget_request_t), 0);
+
+	req->usb_ep = _ep;
+	req->usb_request.dma = 0;
+	req->usb_request.zero = 0;
+
+	return &req->usb_request;
+}
+
+/**
+ * This function frees a request previously allocated by
+ * dwc_otg_gadget_alloc_request.
+ */
+void dwc_otg_gadget_free_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	dwc_otg_gadget_request_t *req = dwc_otg_gadget_get_request(_req);
+
+	DWC_VERBOSE("%s(%p, %p)\n", __func__, _ep, _req);
+
+	//if(!req->dwc_request.active)
+	//{
+	//	if(req->free_dma)
+	//		dma_free_coherent(NULL, req->dwc_request.buffer_length, req->dwc_request.dma_buffer, req->dwc_request.dma_address);
+
+		kfree(req);
+	//}
+}
+
+/**
+ * This queues a request to be sent to the host.
+ */
+int dwc_otg_gadget_queue_request(struct usb_ep *_ep, struct usb_request *_req, gfp_t _gfp)
+{
+	dwc_otg_gadget_request_t *req = dwc_otg_gadget_get_request(_req);
+	dwc_otg_gadget_ep_t *ep = dwc_otg_gadget_get_ep(_ep);
+	dwc_otg_core_request_t *cReq = kzalloc(sizeof(dwc_otg_core_request_t), _gfp);
+
+	// TODO: Use internal request rather than creating a new one!
+	memset(cReq, sizeof(dwc_otg_core_request_t), 0); // Clear Structure
+
+	cReq->dont_free = 1;
+	cReq->request_type = DWC_EP_TYPE_CONTROL;
+	cReq->direction = DWC_OTG_REQUEST_IN;
+	cReq->buffer_length = _req->length;
+	cReq->length = _req->length;
+	cReq->buffer = _req->buf;
+	cReq->cancelled = 0;
+	cReq->cancelled_handler = NULL;
+	cReq->data = (void*)req;
+	cReq->zero = _req->zero;
+
+	if(ep->ep->num != 0)
+	{
+		if(ep->ep->descriptor != NULL)
+		{
+			cReq->request_type = ep->ep->descriptor->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK; // Our DWC_OTG_XXX line up with the USB_XXX equivalents.
+			cReq->direction = (ep->ep->direction == DWC_OTG_EP_OUT) ? DWC_OTG_REQUEST_OUT : DWC_OTG_REQUEST_IN;
+		}
+		else
+		{
+			DWC_ERROR("%s: tried to make a transfer but %s is disabled.\n", ep->ep->name, ep->ep->name);
+			return -1;
+		}
+	}
+
+#if defined(DEBUG)&&defined(VERBOSE)
+	{
+		char *dir = "Invalid";
+		if(cReq->direction == DWC_OTG_REQUEST_IN)
+			dir = "in";
+		else if(cReq->direction == DWC_OTG_REQUEST_OUT)
+			dir = "out";
+
+		DWC_PRINT("%s(%p, %p, %d) me=%p, ep=%s, dir=%s, req=%p, len=%d\n", __func__,
+				_ep, _req, _gfp, dwc_otg_gadget_device, ep->ep->name, dir, req, _req->length);
+	}
+#endif
+	
+	if(_req->dma != 0)
+	{
+		cReq->dma_buffer = _req->buf;
+		cReq->dma_address = _req->dma;
+		req->free_dma = 0;
+	}
+	else
+		req->free_dma = 1;
+
+	cReq->completed_handler = &dwc_otg_gadget_complete;
+	dwc_otg_core_enqueue_request(dwc_otg_gadget_device->core, ep->ep, cReq);
+	
+	return 0;
+}
+
+/**
+ * This function removes a request from the queue, providing it has not
+ * already been sent.
+ */
+int dwc_otg_gadget_dequeue_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	DWC_VERBOSE("%s(%p, %p)\n", __func__, _ep, _req);
+	// TODO: IMPL
+	return 0;
+}
+
+/**
+ * This sends a stall to the host if the value is 1,
+ * or clears a previously set halt if 0.
+ */
+int dwc_otg_gadget_set_halt(struct usb_ep *_ep, int _val)
+{
+	dwc_otg_gadget_ep_t *ep = dwc_otg_gadget_get_ep(_ep);
+
+	DWC_VERBOSE("%s(%p, %i) ep=%s\n", __func__, _ep, _val, ep->ep->name);
+
+	if(_val > 0)
+		dwc_otg_core_stall_ep(dwc_otg_gadget_device->core, ep->ep, _val);
+
+	return 0;
+}
+
+/**
+ * This stalls the endpoint and prevents it from being
+ * restarted by the host.
+ */
+int dwc_otg_gadget_set_wedge(struct usb_ep *_ep)
+{
+	DWC_VERBOSE("%s(%p)\n", __func__, _ep);
+
+	dwc_otg_gadget_set_halt(_ep, 2);
+	return 0;
+}
+
+/**
+ * This retrieves the fifo status of the EP.
+ */
+int dwc_otg_gadget_fifo_status(struct usb_ep *_ep)
+{
+	// TODO: IMPL
+	return 0;
+}
+
+/**
+ * This function flushes an EP's FIFO.
+ */
+void dwc_otg_gadget_fifo_flush(struct usb_ep *_ep)
+{
+	// TODO: IMPL
+}
+
+/**
+ * This is the callback used as a bridge to the
+ * usb_gadget callback.
+ */
+void dwc_otg_gadget_complete(dwc_otg_core_request_t *_req)
+{
+	dwc_otg_gadget_request_t *req = (dwc_otg_gadget_request_t*)_req->data; //container_of(_req, dwc_otg_gadget_request_t, dwc_request);
+
+	DWC_VERBOSE("%s(%p) len=%d, ep=%s, cancel=%d\n", __func__, _req, _req->length, _req->ep->name, _req->cancelled);
+
+	if(req->free_dma)
+	{
+		if(_req->dma_buffer && _req->buffer)
+		{
+			memcpy(_req->buffer, _req->dma_buffer, _req->length);
+		}
+
+		if(_req->dma_address)
+			dma_free_coherent(NULL, _req->buffer_length, _req->dma_buffer, _req->dma_address);
+	}
+
+	req->usb_request.actual = (_req->length > 0) ? _req->length : 0;
+	req->usb_request.status = (_req->cancelled == 0) ? 0 : -1;
+	if(req->usb_request.complete)
+		req->usb_request.complete(req->usb_ep, &req->usb_request);
+
+	if(req->free)
+		kfree(_req);
+}
+
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_gadget.h iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_gadget.h
--- linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_gadget.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_gadget.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,183 @@
+/*
+ * dwc_otg_gadget.h - header for gadget-specific API
+ *
+ * Author: Ricky Taylor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef  __DWC_OTG_GADGET_H__
+#define  __DWC_OTG_GADGET_H__
+
+#include <linux/usb.h>
+#include <linux/usb/gadget.h>
+
+#include "dwc_otg_device.h"
+
+/**
+ * @file dwc_otg_gadget.h
+ *
+ * This file pair implements the usb_gadget famework
+ * for the driver.
+ */
+
+/**
+ * This structure represents an EP of our device.
+ *
+ * usb_ep is used by the usb_gadget framework, so this
+ * structure was created to allow us to store additonal
+ * information. (You can retrieve a handle to the
+ * @ref dwc_otg_gadget_ep_t using container_of.)
+ */
+typedef struct dwc_otg_gadget_ep_struct
+{
+	/** The USB EP information used by the gadget driver. */
+	struct usb_ep usb_ep;
+
+	/** Our EP information for translating the gadget requests. */
+	dwc_otg_core_ep_t *ep;
+
+} dwc_otg_gadget_ep_t;
+
+#define dwc_otg_gadget_get_ep(a) (dwc_otg_gadget_ep_t*)container_of((a), dwc_otg_gadget_ep_t, usb_ep)
+
+/**
+ * This structure represents a request.
+ *
+ * 
+ */
+typedef struct dwc_otg_gadget_request_struct
+{
+	/** The request used by the usb_gadget framework. */
+	struct usb_request usb_request;
+
+	/** The endpoint used by the usb_gadget framework. */
+	struct usb_ep *usb_ep;
+
+	/** Our request. Used to actually queue the request. */
+	dwc_otg_core_request_t dwc_request;
+
+	/**
+	 * We have been told to free the request, but it's in use.
+	 * Instead of passing control to the usb gadget driver,
+	 * free the request when it completes.
+	 */
+	unsigned free : 1;
+
+	/**
+	 * Whether to free the DMA memory, this will be false if
+	 * they supplied it.
+	 */
+	unsigned free_dma : 1;
+} dwc_otg_gadget_request_t;
+
+#define dwc_otg_gadget_get_request(a) (dwc_otg_gadget_request_t*)container_of((a), dwc_otg_gadget_request_t, usb_request)
+
+/**
+ * We use this variable to store the current gadget driver,
+ * we can't really get around the global variable business
+ * unfortunately.
+ */
+extern struct usb_gadget_driver *dwc_otg_gadget_driver;
+
+/**
+ * Because the gadget stuff is hooked into 'the code', we must
+ * have this available. ;_;
+ */
+extern struct usb_gadget dwc_otg_gadget;
+
+/**
+ * usb_gadget_register_driver
+ *
+ * This function is called when the gadget driver is loaded
+ * to bind it to the controller.
+ */
+int usb_gadget_register_driver(struct usb_gadget_driver* _dri);
+
+/**
+ * usb_gadget_unregister_driver
+ *
+ * This function is called when the gadget driver is being released.
+ */
+int usb_gadget_unregister_driver(struct usb_gadget_driver* _dri);
+
+/**
+ * usb_gadget_register_controller
+ *
+ * This is called to store the current controller for use in the
+ * other usb_gadget* functions.
+ */
+int usb_gadget_register_controller(dwc_otg_device_t *_dev);
+
+/**
+ * usb_gadget_unregister_controller
+ *
+ * This is called to release the controller.
+ */
+int usb_gadget_unregister_controller(dwc_otg_device_t *_dev);
+
+/**
+ * This function enables an EP with the parameters required
+ * for the supplied usb_endpoint_descriptor.
+ */
+int dwc_otg_gadget_enable_ep(struct usb_ep *_ep, const struct usb_endpoint_descriptor *_desc);
+
+/**
+ * This function disables an EP.
+ */
+int dwc_otg_gadget_disable_ep(struct usb_ep *_ep);
+
+/**
+ * This function allocates a request, to be filled in by the caller
+ * which can then be queued to be sent to the host.
+ */
+struct usb_request *dwc_otg_gadget_alloc_request(struct usb_ep *_ep, gfp_t _gfp);
+
+/**
+ * This function frees a request previously allocated by
+ * dwc_otg_gadget_alloc_request.
+ */
+void dwc_otg_gadget_free_request(struct usb_ep *_ep, struct usb_request *_req);
+
+/**
+ * This queues a request to be sent to the host.
+ */
+int dwc_otg_gadget_queue_request(struct usb_ep *_ep, struct usb_request *_req, gfp_t _gfp);
+
+/**
+ * This function removes a request from the queue, providing it has not
+ * already been sent.
+ */
+int dwc_otg_gadget_dequeue_request(struct usb_ep *_ep, struct usb_request *_req);
+
+/**
+ * This sends a stall to the host if the value is 1,
+ * or clears a previously set halt if 0.
+ */
+int dwc_otg_gadget_set_halt(struct usb_ep *_ep, int _val);
+
+/**
+ * This stalls the endpoint and prevents it from being
+ * restarted by the host.
+ */
+int dwc_otg_gadget_set_wedge(struct usb_ep *_ep);
+
+/**
+ * This retrieves the fifo status of the EP.
+ */
+int dwc_otg_gadget_fifo_status(struct usb_ep *_ep);
+
+/**
+ * This function flushes an EP's FIFO.
+ */
+void dwc_otg_gadget_fifo_flush(struct usb_ep *_ep);
+
+/**
+ * This is the callback used as a bridge to the
+ * usb_gadget callback.
+ */
+void dwc_otg_gadget_complete(dwc_otg_core_request_t *_req);
+
+#endif //__DWC_OTG_GADGET_H__
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg.h iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg.h
--- linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,43 @@
+/*
+ * dwc_otg.h - root header for the DWC OTG driver
+ *
+ * Author: Ricky Taylor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef  __DWC_OTG_H__
+#define  __DWC_OTG_H__
+
+#define		DWC_OTG_DRIVER_NAME "dwc_otg"
+#define		DWC_OTG_TAG DWC_OTG_DRIVER_NAME ": "
+
+// Logging Macros -- Ricky26
+#define		DWC_PRINT(args...) printk(DWC_OTG_TAG args)
+
+// TODO: Tell the kernel this is actually an error? -- Ricky26
+#define		DWC_ERROR(args...) DWC_PRINT(args) 
+
+#ifdef DEBUG
+#	define	DWC_DEBUG(args...) DWC_PRINT(args)
+#else
+#	define	DWC_DEBUG(args...)
+#endif
+
+#if defined(DEBUG)&&defined(VERBOSE)
+#	define DWC_VERBOSE(args...) DWC_PRINT(args)
+#else
+#	define DWC_VERBOSE(args...)
+#endif
+
+// TODO: Use the kernel stuff to make this a real warning?
+//       Then remove the (DEBUG) if.
+#if defined(DEBUG)
+#	define DWC_WARNING(args...) DWC_PRINT(args)
+#else
+#   define DWC_WARNING(args...)
+#endif
+
+#endif //__DWC_OTG_H__
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_hw.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_hw.c
--- linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_hw.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_hw.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,41 @@
+/*
+ * dwc_otg_hw.c - hardware-specific code
+ *
+ * Author: Ricky Taylor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "dwc_otg_hw.h"
+
+#include <linux/delay.h>
+#include <mach/map.h>
+#include <mach/iphone-clock.h>
+
+/**
+ * This powers up/down the hardware.
+ */
+int dwc_otg_hw_power(dwc_otg_core_t *core, int _pwr)
+{
+	if(_pwr)
+	{
+		iphone_power_ctrl(IPHONE_USB_POWER, 1);
+		msleep(10);
+		iphone_clock_gate_switch(IPHONE_USB_CLOCK, 1);
+		iphone_clock_gate_switch(IPHONE_USBPHY_CLOCK, 1);
+		iphone_clock_gate_switch(IPHONE_EDRAM_CLOCK, 1);
+	}
+	else
+	{
+		iphone_clock_gate_switch(IPHONE_USB_CLOCK, 0);
+		iphone_clock_gate_switch(IPHONE_USBPHY_CLOCK, 0);
+		iphone_clock_gate_switch(IPHONE_EDRAM_CLOCK, 0);
+		iphone_power_ctrl(IPHONE_USB_POWER, 0);
+		msleep(10);
+	}
+
+	return 0;
+}
+
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_hw.h iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_hw.h
--- linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_hw.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_hw.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,53 @@
+/*
+ * dwc_otg_hw.h - header for hardware-specific code
+ *
+ * Author: Ricky Taylor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef  __DWC_OTG_HW_H__
+#define  __DWC_OTG_HW_H__
+
+#include <asm/io.h>
+
+#include "dwc_otg_core.h"
+
+/**
+ * This powers up/down the hardware.
+ */
+int dwc_otg_hw_power(dwc_otg_core_t *core, int _pwr);
+
+/*
+ *
+ * Helper functions for IO.
+ *
+ */
+
+/**
+ * Write a 32-bit register.
+ */
+static inline void dwc_otg_write_reg32(volatile uint32_t* _address, uint32_t _value)
+{
+	writel(_value, _address);
+}
+
+/**
+ * Read a 32-bit register.
+ */
+static inline uint32_t dwc_otg_read_reg32(volatile uint32_t* _address)
+{
+	return readl(_address);
+}
+
+/**
+ * Modify a 32-bit register.
+ */
+static inline void dwc_otg_modify_reg32(volatile uint32_t* _address, uint32_t _clear, uint32_t _set)
+{
+	writel((readl(_address) &~ _clear) | _set, _address);
+}
+
+#endif //__DWC_OTG_HW_H__
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_regs.h iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_regs.h
--- linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/dwc_otg_regs.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/dwc_otg_regs.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,2132 @@
+/* ==========================================================================
+ * $File: //dwh/usb_iip/dev/software/otg/linux/drivers/dwc_otg_regs.h $
+ * $Revision: 1.2 $
+ * $Date: 2008-11-21 05:39:15 $
+ * $Change: 1099526 $
+ *
+ * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ * 
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ * 
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ * ========================================================================== */
+
+#ifndef __DWC_OTG_REGS_H__
+#define __DWC_OTG_REGS_H__
+
+#include <linux/types.h>
+
+/**
+ * @file
+ *
+ * This file contains the data structures for accessing the DWC_otg core registers.
+ *
+ * The application interfaces with the HS OTG core by reading from and
+ * writing to the Control and Status Register (CSR) space through the
+ * AHB Slave interface. These registers are 32 bits wide, and the
+ * addresses are 32-bit-block aligned.
+ * CSRs are classified as follows:
+ * - Core Global Registers
+ * - Device Mode Registers
+ * - Device Global Registers
+ * - Device Endpoint Specific Registers
+ * - Host Mode Registers
+ * - Host Global Registers
+ * - Host Port CSRs
+ * - Host Channel Specific Registers
+ *
+ * Only the Core Global registers can be accessed in both Device and
+ * Host modes. When the HS OTG core is operating in one mode, either
+ * Device or Host, the application must not access registers from the
+ * other mode. When the core switches from one mode to another, the
+ * registers in the new mode of operation must be reprogrammed as they
+ * would be after a power-on reset.
+ */
+
+/** Maximum number of Periodic FIFOs */
+#define MAX_PERIO_FIFOS 15
+/** Maximum number of Transmit FIFOs */
+#define MAX_TX_FIFOS 15
+
+/** Maximum number of Endpoints/HostChannels */
+#define MAX_EPS_CHANNELS 16
+
+#define DWC_EP_TYPE_CONTROL 0
+#define DWC_EP_TYPE_ISOC 1
+#define DWC_EP_TYPE_BULK 2
+#define DWC_EP_TYPE_INTERRUPT 3
+
+/****************************************************************************/
+/** DWC_otg Core registers .  
+ * The dwc_otg_core_global_regs structure defines the size
+ * and relative field offsets for the Core Global registers.
+ */
+typedef struct dwc_otg_core_global_regs 
+{
+	/** OTG Control and Status Register.  <i>Offset: 000h</i> */
+	volatile uint32_t gotgctl; 
+	/** OTG Interrupt Register.	 <i>Offset: 004h</i> */
+	volatile uint32_t gotgint; 
+	/**Core AHB Configuration Register.	 <i>Offset: 008h</i> */
+	volatile uint32_t gahbcfg; 
+
+#define DWC_GLBINTRMASK		0x0001
+#define DWC_DMAENABLE		0x0020
+#define DWC_NPTXEMPTYLVL_EMPTY	0x0080
+#define DWC_NPTXEMPTYLVL_HALFEMPTY	0x0000
+#define DWC_PTXEMPTYLVL_EMPTY	0x0100
+#define DWC_PTXEMPTYLVL_HALFEMPTY	0x0000
+
+	/**Core USB Configuration Register.	 <i>Offset: 00Ch</i> */
+	volatile uint32_t gusbcfg; 
+	/**Core Reset Register.	 <i>Offset: 010h</i> */
+	volatile uint32_t grstctl; 
+	/**Core Interrupt Register.	 <i>Offset: 014h</i> */
+	volatile uint32_t gintsts; 
+	/**Core Interrupt Mask Register.  <i>Offset: 018h</i> */
+	volatile uint32_t gintmsk; 
+	/**Receive Status Queue Read Register (Read Only).	<i>Offset: 01Ch</i> */
+	volatile uint32_t grxstsr; 
+	/**Receive Status Queue Read & POP Register (Read Only).  <i>Offset: 020h</i>*/
+	volatile uint32_t grxstsp; 
+	/**Receive FIFO Size Register.	<i>Offset: 024h</i> */
+	volatile uint32_t grxfsiz; 
+	/**Non Periodic Transmit FIFO Size Register.  <i>Offset: 028h</i> */
+	volatile uint32_t gnptxfsiz; 
+	/**Non Periodic Transmit FIFO/Queue Status Register (Read
+	 * Only). <i>Offset: 02Ch</i> */
+	volatile uint32_t gnptxsts; 
+	/**I2C Access Register.	 <i>Offset: 030h</i> */
+	volatile uint32_t gi2cctl; 
+	/**PHY Vendor Control Register.	 <i>Offset: 034h</i> */
+	volatile uint32_t gpvndctl;
+	/**General Purpose Input/Output Register.  <i>Offset: 038h</i> */
+	volatile uint32_t ggpio; 
+	/**User ID Register.  <i>Offset: 03Ch</i> */
+	volatile uint32_t guid; 
+	/**Synopsys ID Register (Read Only).  <i>Offset: 040h</i> */
+	volatile uint32_t gsnpsid;
+	/**User HW Config1 Register (Read Only).  <i>Offset: 044h</i> */
+	volatile uint32_t ghwcfg1; 
+	/**User HW Config2 Register (Read Only).  <i>Offset: 048h</i> */
+	volatile uint32_t ghwcfg2;
+#define DWC_SLAVE_ONLY_ARCH 0
+#define DWC_EXT_DMA_ARCH 1
+#define DWC_INT_DMA_ARCH 2
+
+#define DWC_MODE_HNP_SRP_CAPABLE	0
+#define DWC_MODE_SRP_ONLY_CAPABLE	1
+#define DWC_MODE_NO_HNP_SRP_CAPABLE		2
+#define DWC_MODE_SRP_CAPABLE_DEVICE		3
+#define DWC_MODE_NO_SRP_CAPABLE_DEVICE	4
+#define DWC_MODE_SRP_CAPABLE_HOST	5
+#define DWC_MODE_NO_SRP_CAPABLE_HOST	6
+
+	/**User HW Config3 Register (Read Only).  <i>Offset: 04Ch</i> */
+	volatile uint32_t ghwcfg3;
+	/**User HW Config4 Register (Read Only).  <i>Offset: 050h</i>*/
+	volatile uint32_t ghwcfg4;
+	/** Reserved  <i>Offset: 054h-0FFh</i> */
+	volatile uint32_t reserved[43];
+	/** Host Periodic Transmit FIFO Size Register. <i>Offset: 100h</i> */
+	volatile uint32_t hptxfsiz;
+	/** Device Periodic Transmit FIFO#n Register if dedicated fifos are disabled, 
+		otherwise Device Transmit FIFO#n Register. 
+	 * <i>Offset: 104h + (FIFO_Number-1)*04h, 1 <= FIFO Number <= 15 (1<=n<=15).</i> */
+	volatile uint32_t dptxfsiz_dieptxf[15]; 
+} dwc_otg_core_global_regs_t;
+
+/**
+ * This union represents the bit fields of the Core OTG Control
+ * and Status Register (GOTGCTL).  Set the bits using the bit 
+ * fields then write the <i>d32</i> value to the register.
+ */
+typedef union gotgctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned sesreqscs : 1;
+		unsigned sesreq : 1;
+		unsigned reserved2_7 : 6;
+		unsigned hstnegscs : 1;
+		unsigned hnpreq : 1;
+		unsigned hstsethnpen : 1;
+		unsigned devhnpen : 1;
+		unsigned reserved12_15 : 4;
+		unsigned conidsts : 1;
+		unsigned reserved17 : 1;
+		unsigned asesvld : 1;
+		unsigned bsesvld : 1;
+		unsigned currmod : 1;
+		unsigned reserved21_31 : 11;
+	} b;
+} gotgctl_data_t;
+
+/**
+ * This union represents the bit fields of the Core OTG Interrupt Register
+ * (GOTGINT).  Set/clear the bits using the bit fields then write the <i>d32</i>
+ * value to the register.
+ */
+typedef union gotgint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/** Current Mode */
+		unsigned reserved0_1 : 2;
+
+		/** Session End Detected */
+		unsigned sesenddet : 1;
+		
+		unsigned reserved3_7 : 5;
+
+		/** Session Request Success Status Change */
+		unsigned sesreqsucstschng : 1;
+		/** Host Negotiation Success Status Change */
+		unsigned hstnegsucstschng : 1;
+
+		unsigned reserver10_16 : 7;
+
+		/** Host Negotiation Detected */
+		unsigned hstnegdet : 1;
+		/** A-Device Timeout Change */
+		unsigned adevtoutchng : 1;
+		/** Debounce Done */
+		unsigned debdone : 1;
+		
+		unsigned reserved31_20 : 12;
+
+	} b;
+} gotgint_data_t;
+
+
+/**
+ * This union represents the bit fields of the Core AHB Configuration
+ * Register (GAHBCFG).	Set/clear the bits using the bit fields then
+ * write the <i>d32</i> value to the register.
+ */
+typedef union gahbcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned glblintrmsk : 1;
+#define DWC_GAHBCFG_GLBINT_ENABLE		1
+
+		unsigned hburstlen : 4;
+#define DWC_GAHBCFG_INT_DMA_BURST_SINGLE	0
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR		1
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR4		3
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR8		5
+#define DWC_GAHBCFG_INT_DMA_BURST_INCR16	7
+
+		unsigned dmaenable : 1;
+#define DWC_GAHBCFG_DMAENABLE			1
+		unsigned reserved : 1;
+		unsigned nptxfemplvl_txfemplvl : 1;
+		unsigned ptxfemplvl : 1;
+#define DWC_GAHBCFG_TXFEMPTYLVL_EMPTY		1
+#define DWC_GAHBCFG_TXFEMPTYLVL_HALFEMPTY	0
+		unsigned reserved9_31 : 23;
+	} b;
+} gahbcfg_data_t;
+
+/**
+ * This union represents the bit fields of the Core USB Configuration
+ * Register (GUSBCFG).	Set the bits using the bit fields then write
+ * the <i>d32</i> value to the register.
+ */
+typedef union gusbcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned toutcal : 3;
+		unsigned phyif : 1;
+		unsigned ulpi_utmi_sel : 1;
+		unsigned fsintf : 1;
+		unsigned physel : 1;
+		unsigned ddrsel : 1;
+		unsigned srpcap : 1;
+		unsigned hnpcap : 1;
+		unsigned usbtrdtim : 4;
+		unsigned nptxfrwnden : 1;
+		unsigned phylpwrclksel : 1;
+		unsigned otgutmifssel : 1;
+		unsigned ulpi_fsls : 1;
+		unsigned ulpi_auto_res : 1;
+		unsigned ulpi_clk_sus_m : 1;
+		unsigned ulpi_ext_vbus_drv : 1;
+		unsigned ulpi_int_vbus_indicator : 1;
+		unsigned term_sel_dl_pulse : 1;
+		unsigned reserved23_27 : 5;
+		unsigned tx_end_delay : 1;
+		unsigned force_host_mode: 1;
+		unsigned force_device_mode: 1;
+		unsigned corrupt_tx_packet: 1;
+	} b;
+} gusbcfg_data_t;
+
+/**
+ * This union represents the bit fields of the Core Reset Register
+ * (GRSTCTL).  Set/clear the bits using the bit fields then write the
+ * <i>d32</i> value to the register.
+ */
+typedef union grstctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/** Core Soft Reset (CSftRst) (Device and Host)
+		 *
+		 * The application can flush the control logic in the
+		 * entire core using this bit. This bit resets the
+		 * pipelines in the AHB Clock domain as well as the
+		 * PHY Clock domain.
+		 *
+		 * The state machines are reset to an IDLE state, the
+		 * control bits in the CSRs are cleared, all the
+		 * transmit FIFOs and the receive FIFO are flushed.
+		 *
+		 * The status mask bits that control the generation of
+		 * the interrupt, are cleared, to clear the
+		 * interrupt. The interrupt status bits are not
+		 * cleared, so the application can get the status of
+		 * any events that occurred in the core after it has
+		 * set this bit.
+		 *
+		 * Any transactions on the AHB are terminated as soon
+		 * as possible following the protocol. Any
+		 * transactions on the USB are terminated immediately.
+		 *
+		 * The configuration settings in the CSRs are
+		 * unchanged, so the software doesn't have to
+		 * reprogram these registers (Device
+		 * Configuration/Host Configuration/Core System
+		 * Configuration/Core PHY Configuration).
+		 *
+		 * The application can write to this bit, any time it
+		 * wants to reset the core. This is a self clearing
+		 * bit and the core clears this bit after all the
+		 * necessary logic is reset in the core, which may
+		 * take several clocks, depending on the current state
+		 * of the core.
+		 */
+		unsigned csftrst : 1;
+		/** Hclk Soft Reset
+		 *
+		 * The application uses this bit to reset the control logic in
+		 * the AHB clock domain. Only AHB clock domain pipelines are
+		 * reset.
+		 */
+		unsigned hsftrst : 1;
+		/** Host Frame Counter Reset (Host Only)<br>
+		 * 
+		 * The application can reset the (micro)frame number
+		 * counter inside the core, using this bit. When the
+		 * (micro)frame counter is reset, the subsequent SOF
+		 * sent out by the core, will have a (micro)frame
+		 * number of 0.
+		 */
+		unsigned hstfrm : 1;
+		/** In Token Sequence Learning Queue Flush
+		 * (INTknQFlsh) (Device Only)
+		 */
+		unsigned intknqflsh : 1;
+		/** RxFIFO Flush (RxFFlsh) (Device and Host)
+		 *
+		 * The application can flush the entire Receive FIFO
+		 * using this bit.	<p>The application must first
+		 * ensure that the core is not in the middle of a
+		 * transaction.	 <p>The application should write into
+		 * this bit, only after making sure that neither the
+		 * DMA engine is reading from the RxFIFO nor the MAC
+		 * is writing the data in to the FIFO.	<p>The
+		 * application should wait until the bit is cleared
+		 * before performing any other operations. This bit
+		 * will takes 8 clocks (slowest of PHY or AHB clock)
+		 * to clear.
+		 */
+		unsigned rxfflsh : 1;
+		/** TxFIFO Flush (TxFFlsh) (Device and Host).  
+		 *
+		 * This bit is used to selectively flush a single or
+		 * all transmit FIFOs.	The application must first
+		 * ensure that the core is not in the middle of a
+		 * transaction.	 <p>The application should write into
+		 * this bit, only after making sure that neither the
+		 * DMA engine is writing into the TxFIFO nor the MAC
+		 * is reading the data out of the FIFO.	 <p>The
+		 * application should wait until the core clears this
+		 * bit, before performing any operations. This bit
+		 * will takes 8 clocks (slowest of PHY or AHB clock)
+		 * to clear.
+		 */
+		unsigned txfflsh : 1;
+		
+		/** TxFIFO Number (TxFNum) (Device and Host).
+		 * 
+		 * This is the FIFO number which needs to be flushed,
+		 * using the TxFIFO Flush bit. This field should not
+		 * be changed until the TxFIFO Flush bit is cleared by
+		 * the core.
+		 *	 - 0x0 : Non Periodic TxFIFO Flush
+		 *	 - 0x1 : Periodic TxFIFO #1 Flush in device mode
+		 *	   or Periodic TxFIFO in host mode
+		 *	 - 0x2 : Periodic TxFIFO #2 Flush in device mode.
+		 *	 - ...
+		 *	 - 0xF : Periodic TxFIFO #15 Flush in device mode
+		 *	 - 0x10: Flush all the Transmit NonPeriodic and
+		 *	   Transmit Periodic FIFOs in the core
+		 */
+		unsigned txfnum : 5;
+		/** Reserved */
+		unsigned reserved11_29 : 19;
+		/** DMA Request Signal.	 Indicated DMA request is in
+		 * probress.  Used for debug purpose. */
+		unsigned dmareq : 1;
+		/** AHB Master Idle.  Indicates the AHB Master State
+		 * Machine is in IDLE condition. */
+		unsigned ahbidle : 1;				 
+	} b;
+} grstctl_data_t;
+
+
+/**
+ * This union represents the bit fields of the Core Interrupt Mask
+ * Register (GINTMSK).	Set/clear the bits using the bit fields then
+ * write the <i>d32</i> value to the register.
+ */
+typedef union gintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned reserved0 : 1;
+		unsigned modemismatch : 1;
+		unsigned otgintr : 1;
+		unsigned sofintr : 1;
+		unsigned rxstsqlvl : 1;
+		unsigned nptxfempty : 1;
+		unsigned ginnakeff : 1;
+		unsigned goutnakeff : 1;
+		unsigned reserved8 : 1;
+		unsigned i2cintr : 1;
+		unsigned erlysuspend : 1;
+		unsigned usbsuspend : 1;
+		unsigned usbreset : 1;
+		unsigned enumdone : 1;
+		unsigned isooutdrop : 1;
+		unsigned eopframe : 1;
+		unsigned reserved16 : 1;
+		unsigned epmismatch : 1;
+		unsigned inepintr : 1;
+		unsigned outepintr : 1;
+		unsigned incomplisoin : 1;
+		unsigned incomplisoout : 1;
+		unsigned reserved22_23 : 2;
+		unsigned portintr : 1;
+		unsigned hcintr : 1;
+		unsigned ptxfempty : 1;
+		unsigned reserved27 : 1;
+		unsigned conidstschng : 1;
+		unsigned disconnect : 1;
+		unsigned sessreqintr : 1;
+		unsigned wkupintr : 1;
+	} b;
+} gintmsk_data_t;
+/**
+ * This union represents the bit fields of the Core Interrupt Register
+ * (GINTSTS).  Set/clear the bits using the bit fields then write the
+ * <i>d32</i> value to the register.
+ */
+typedef union gintsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+#define DWC_SOF_INTR_MASK 0x0008
+	/** register bits */
+	struct 
+	{
+#define DWC_HOST_MODE 1
+		unsigned curmode : 1;
+		unsigned modemismatch : 1;
+		unsigned otgintr : 1;
+		unsigned sofintr : 1;
+		unsigned rxstsqlvl : 1;
+		unsigned nptxfempty : 1;
+		unsigned ginnakeff : 1;
+		unsigned goutnakeff : 1;
+		unsigned reserved8 : 1;
+		unsigned i2cintr : 1;
+		unsigned erlysuspend : 1;
+		unsigned usbsuspend : 1;
+		unsigned usbreset : 1;
+		unsigned enumdone : 1;
+		unsigned isooutdrop : 1;
+		unsigned eopframe : 1;
+		unsigned intokenrx : 1;
+		unsigned epmismatch : 1;
+		unsigned inepintr: 1;
+		unsigned outepintr : 1;
+		unsigned incomplisoin : 1;
+		unsigned incomplisoout : 1;
+		unsigned reserved22_23 : 2;
+		unsigned portintr : 1;
+		unsigned hcintr : 1;
+		unsigned ptxfempty : 1;
+		unsigned reserved27 : 1;
+		unsigned conidstschng : 1;
+		unsigned disconnect : 1;
+		unsigned sessreqintr : 1;
+		unsigned wkupintr : 1;
+	} b;
+} gintsts_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device Receive Status Read and 
+ * Pop Registers (GRXSTSR, GRXSTSP) Read the register into the <i>d32</i> 
+ * element then read out the bits using the <i>b</i>it elements.
+ */
+typedef union device_grxsts_data 
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned epnum : 4;
+		unsigned bcnt : 11;
+		unsigned dpid : 2;
+		
+#define DWC_STS_DATA_UPDT		0x2				  // OUT Data Packet
+#define DWC_STS_XFER_COMP		0x3				  // OUT Data Transfer Complete
+
+#define DWC_DSTS_GOUT_NAK		0x1				  // Global OUT NAK
+#define DWC_DSTS_SETUP_COMP		0x4				  // Setup Phase Complete
+#define DWC_DSTS_SETUP_UPDT 0x6				  // SETUP Packet
+		unsigned pktsts : 4;
+		unsigned fn : 4;
+		unsigned reserved : 7;
+	} b;
+} device_grxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Host Receive Status Read and 
+ * Pop Registers (GRXSTSR, GRXSTSP) Read the register into the <i>d32</i> 
+ * element then read out the bits using the <i>b</i>it elements.
+ */
+typedef union host_grxsts_data 
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned chnum : 4;
+		unsigned bcnt : 11;
+		unsigned dpid : 2;
+		
+		unsigned pktsts : 4;
+#define DWC_GRXSTS_PKTSTS_IN			  0x2
+#define DWC_GRXSTS_PKTSTS_IN_XFER_COMP	  0x3
+#define DWC_GRXSTS_PKTSTS_DATA_TOGGLE_ERR 0x5
+#define DWC_GRXSTS_PKTSTS_CH_HALTED		  0x7
+		
+		unsigned reserved : 11;
+	} b;
+} host_grxsts_data_t;
+
+/**
+ * This union represents the bit fields in the FIFO Size Registers (HPTXFSIZ,
+ * GNPTXFSIZ, DPTXFSIZn, DIEPTXFn). Read the register into the <i>d32</i> element then
+ * read out the bits using the <i>b</i>it elements.
+ */
+typedef union fifosize_data 
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned startaddr : 16;
+		unsigned depth : 16;
+	} b;
+} fifosize_data_t;
+
+/**
+ * This union represents the bit fields in the Non-Periodic Transmit
+ * FIFO/Queue Status Register (GNPTXSTS). Read the register into the
+ * <i>d32</i> element then read out the bits using the <i>b</i>it
+ * elements.
+ */
+typedef union gnptxsts_data 
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned nptxfspcavail : 16;
+		unsigned nptxqspcavail : 8;
+		/** Top of the Non-Periodic Transmit Request Queue 
+		 *	- bit 24 - Terminate (Last entry for the selected
+		 *	  channel/EP)
+		 *	- bits 26:25 - Token Type 
+		 *	  - 2'b00 - IN/OUT
+		 *	  - 2'b01 - Zero Length OUT
+		 *	  - 2'b10 - PING/Complete Split
+		 *	  - 2'b11 - Channel Halt
+		 *	- bits 30:27 - Channel/EP Number
+		 */
+		unsigned nptxqtop_terminate : 1;
+		unsigned nptxqtop_token : 2;
+		unsigned nptxqtop_chnep : 4;
+		unsigned reserved : 1;
+	} b;
+} gnptxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Transmit
+ * FIFO Status Register (DTXFSTS). Read the register into the
+ * <i>d32</i> element then read out the bits using the <i>b</i>it
+ * elements.
+ */
+typedef union dtxfsts_data 
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned txfspcavail : 16;
+		unsigned reserved : 16;
+	} b;
+} dtxfsts_data_t;
+
+/**
+ * This union represents the bit fields in the I2C Control Register
+ * (I2CCTL). Read the register into the <i>d32</i> element then read out the
+ * bits using the <i>b</i>it elements.
+ */
+typedef union gi2cctl_data 
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned rwdata : 8;
+		unsigned regaddr : 8;
+		unsigned addr : 7;
+		unsigned i2cen : 1;
+		unsigned ack : 1;
+		unsigned i2csuspctl : 1;
+		unsigned i2cdevaddr : 2;
+		unsigned reserved : 2;
+		unsigned rw : 1;
+		unsigned bsydne : 1;
+	} b;
+} gi2cctl_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config1
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg1_data 
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned ep_dir0 : 2;
+		unsigned ep_dir1 : 2;
+		unsigned ep_dir2 : 2;
+		unsigned ep_dir3 : 2;
+		unsigned ep_dir4 : 2;
+		unsigned ep_dir5 : 2;
+		unsigned ep_dir6 : 2;
+		unsigned ep_dir7 : 2;
+		unsigned ep_dir8 : 2;
+		unsigned ep_dir9 : 2;
+		unsigned ep_dir10 : 2;
+		unsigned ep_dir11 : 2;
+		unsigned ep_dir12 : 2;
+		unsigned ep_dir13 : 2;
+		unsigned ep_dir14 : 2;
+		unsigned ep_dir15 : 2;
+	} b;
+} hwcfg1_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config2
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg2_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/* GHWCFG2 */
+		unsigned op_mode : 3;
+#define DWC_HWCFG2_OP_MODE_HNP_SRP_CAPABLE_OTG 0
+#define DWC_HWCFG2_OP_MODE_SRP_ONLY_CAPABLE_OTG 1
+#define DWC_HWCFG2_OP_MODE_NO_HNP_SRP_CAPABLE_OTG 2
+#define DWC_HWCFG2_OP_MODE_SRP_CAPABLE_DEVICE 3
+#define DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_DEVICE 4
+#define DWC_HWCFG2_OP_MODE_SRP_CAPABLE_HOST 5
+#define DWC_HWCFG2_OP_MODE_NO_SRP_CAPABLE_HOST 6
+
+		unsigned architecture : 2;
+		unsigned point2point : 1;
+		unsigned hs_phy_type : 2;
+#define DWC_HWCFG2_HS_PHY_TYPE_NOT_SUPPORTED 0
+#define DWC_HWCFG2_HS_PHY_TYPE_UTMI 1
+#define DWC_HWCFG2_HS_PHY_TYPE_ULPI 2
+#define DWC_HWCFG2_HS_PHY_TYPE_UTMI_ULPI 3
+
+		unsigned fs_phy_type : 2;
+		unsigned num_dev_ep : 4;
+		unsigned num_host_chan : 4;
+		unsigned perio_ep_supported : 1;
+		unsigned dynamic_fifo : 1;
+		unsigned multi_proc_int : 1;
+		unsigned reserved21 : 1;
+		//unsigned rx_status_q_depth : 2;
+		unsigned nonperio_tx_q_depth : 2;
+		unsigned host_perio_tx_q_depth : 2;
+		unsigned dev_token_q_depth : 5;
+		unsigned reserved31 : 1;
+	} b;
+} hwcfg2_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config3
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg3_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/* GHWCFG3 */
+		unsigned xfer_size_cntr_width : 4;
+		unsigned packet_size_cntr_width : 3;
+		unsigned otg_func : 1;
+		unsigned i2c : 1;
+		unsigned vendor_ctrl_if : 1;
+		unsigned optional_features : 1;
+		unsigned synch_reset_type : 1;
+		unsigned ahb_phy_clock_synch : 1;
+		unsigned reserved15_13 : 3;
+		unsigned dfifo_depth : 16;
+	} b;
+} hwcfg3_data_t;
+
+/**
+ * This union represents the bit fields in the User HW Config4
+ * Register.  Read the register into the <i>d32</i> element then read
+ * out the bits using the <i>b</i>it elements.
+ */
+typedef union hwcfg4_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned num_dev_perio_in_ep : 4;
+		unsigned power_optimiz : 1;
+		unsigned min_ahb_freq : 9;
+		unsigned utmi_phy_data_width : 2;
+		unsigned num_dev_mode_ctrl_ep : 4;
+		unsigned iddig_filt_en : 1;
+		unsigned vbus_valid_filt_en : 1;
+		unsigned a_valid_filt_en : 1;
+		unsigned b_valid_filt_en : 1;				 
+		unsigned session_end_filt_en : 1;				 
+		unsigned ded_fifo_en : 1;
+		unsigned num_in_eps : 4;
+		unsigned desc_dma : 1;
+		unsigned desc_dma_dyn : 1;
+	} b;
+} hwcfg4_data_t;
+
+////////////////////////////////////////////
+// Device Registers
+/**
+ * Device Global Registers. <i>Offsets 800h-BFFh</i>
+ *
+ * The following structures define the size and relative field offsets
+ * for the Device Mode Registers.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_global_regs 
+{
+	/** Device Configuration Register. <i>Offset 800h</i> */
+	volatile uint32_t dcfg; 
+	/** Device Control Register. <i>Offset: 804h</i> */
+	volatile uint32_t dctl; 
+	/** Device Status Register (Read Only). <i>Offset: 808h</i> */
+	volatile uint32_t dsts; 
+	/** Reserved. <i>Offset: 80Ch</i> */
+	uint32_t unused;		
+	/** Device IN Endpoint Common Interrupt Mask
+	 * Register. <i>Offset: 810h</i> */
+	volatile uint32_t diepmsk; 
+	/** Device OUT Endpoint Common Interrupt Mask
+	 * Register. <i>Offset: 814h</i> */
+	volatile uint32_t doepmsk;	
+	/** Device All Endpoints Interrupt Register.  <i>Offset: 818h</i> */
+	volatile uint32_t daint;	
+	/** Device All Endpoints Interrupt Mask Register.  <i>Offset:
+	 * 81Ch</i> */
+	volatile uint32_t daintmsk; 
+	/** Device IN Token Queue Read Register-1 (Read Only).
+	 * <i>Offset: 820h</i> */
+	volatile uint32_t dtknqr1;	
+	/** Device IN Token Queue Read Register-2 (Read Only).
+	 * <i>Offset: 824h</i> */ 
+	volatile uint32_t dtknqr2;	
+	/** Device VBUS	 discharge Register.  <i>Offset: 828h</i> */
+	volatile uint32_t dvbusdis;		
+	/** Device VBUS Pulse Register.	 <i>Offset: 82Ch</i> */
+	volatile uint32_t dvbuspulse;
+	/** Device IN Token Queue Read Register-3 (Read Only). /
+	 *	Device Thresholding control register (Read/Write)
+	 * <i>Offset: 830h</i> */ 
+	volatile uint32_t dtknqr3_dthrctl;	
+	/** Device IN Token Queue Read Register-4 (Read Only). /
+	 *	Device IN EPs empty Inr. Mask Register (Read/Write)
+	 * <i>Offset: 834h</i> */ 
+	volatile uint32_t dtknqr4_fifoemptymsk;		
+	/** Device Each Endpoint Interrupt Register (Read Only). /
+	 * <i>Offset: 838h</i> */ 
+	volatile uint32_t deachint;		
+	/** Device Each Endpoint Interrupt mask Register (Read/Write). /
+	 * <i>Offset: 83Ch</i> */ 
+	volatile uint32_t deachintmsk;		
+	/** Device Each In Endpoint Interrupt mask Register (Read/Write). /
+	 * <i>Offset: 840h</i> */ 
+	volatile uint32_t diepeachintmsk[MAX_EPS_CHANNELS];		
+	/** Device Each Out Endpoint Interrupt mask Register (Read/Write). /
+	 * <i>Offset: 880h</i> */ 
+	volatile uint32_t doepeachintmsk[MAX_EPS_CHANNELS];		
+} dwc_otg_device_global_regs_t; 
+
+/**
+ * This union represents the bit fields in the Device Configuration
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.  Write the
+ * <i>d32</i> member to the dcfg register.
+ */
+typedef union dcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/** Device Speed */
+		unsigned devspd : 2;
+#define DWC_DCFG_HIGH_SPEED 0
+
+		/** Non Zero Length Status OUT Handshake */
+		unsigned nzstsouthshk : 1;
+#define DWC_DCFG_SEND_STALL 1
+
+		unsigned reserved3 : 1;
+		/** Device Addresses */
+		unsigned devaddr : 7;
+#define DWC_DCFG_DEVADDR_MASK 0x7f
+		/** Periodic Frame Interval */
+		unsigned perfrint : 2;
+#define DWC_DCFG_FRAME_INTERVAL_80 0
+#define DWC_DCFG_FRAME_INTERVAL_85 1
+#define DWC_DCFG_FRAME_INTERVAL_90 2
+#define DWC_DCFG_FRAME_INTERVAL_95 3
+
+		unsigned reserved13_17 : 5;
+		/** In Endpoint Mis-match count */
+		unsigned epmscnt : 5;
+		/** Enable Descriptor DMA in Device mode */
+		unsigned descdma : 1;
+	} b;
+} dcfg_data_t;
+
+/**
+ * This union represents the bit fields in the Device Control
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union dctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/** Remote Wakeup */
+		unsigned rmtwkupsig : 1;
+		/** Soft Disconnect */
+		unsigned sftdiscon : 1;
+		/** Global Non-Periodic IN NAK Status */
+		unsigned gnpinnaksts : 1;
+		/** Global OUT NAK Status */
+		unsigned goutnaksts : 1;
+		/** Test Control */
+		unsigned tstctl : 3;
+		/** Set Global Non-Periodic IN NAK */
+		unsigned sgnpinnak : 1;
+		/** Clear Global Non-Periodic IN NAK */
+		unsigned cgnpinnak : 1;
+		/** Set Global OUT NAK */
+		unsigned sgoutnak : 1;
+		/** Clear Global OUT NAK */
+		unsigned cgoutnak : 1;
+
+		/** Power-On Programming Done */
+		unsigned pwronprgdone : 1;
+		/** Global Continue on BNA */
+		unsigned gcontbna : 1;
+		/** Global Multi Count */
+		unsigned gmc : 2;
+		/** Ignore Frame Number for ISOC EPs */
+		unsigned ifrmnum : 1;
+		/** NAK on Babble */
+		unsigned nakonbble : 1;
+
+		unsigned reserved16_31 : 16;
+	} b;
+} dctl_data_t;
+
+/**
+ * This union represents the bit fields in the Device Status
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union dsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/** Suspend Status */
+		unsigned suspsts : 1;
+		/** Enumerated Speed */
+		unsigned enumspd : 2;
+#define DWC_DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ 0
+#define DWC_DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ 1
+#define DWC_DSTS_ENUMSPD_LS_PHY_6MHZ		   2
+#define DWC_DSTS_ENUMSPD_FS_PHY_48MHZ		   3
+		/** Erratic Error */
+		unsigned errticerr : 1;
+		unsigned reserved4_7: 4;
+		/** Frame or Microframe Number of the received SOF */
+		unsigned soffn : 14;
+		unsigned reserved22_31 : 10;
+	} b;
+} dsts_data_t;
+
+
+/**
+ * This union represents the bit fields in the Device IN EP Interrupt
+ * Register and the Device IN EP Common Mask Register.
+ *
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union diepint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/** Transfer complete mask */
+		unsigned xfercompl : 1;
+		/** Endpoint disable mask */
+		unsigned epdisabled : 1;
+		/** AHB Error mask */
+		unsigned ahberr : 1;
+		/** TimeOUT Handshake mask (non-ISOC EPs) */
+		unsigned timeout : 1;
+		/** IN Token received with TxF Empty mask */
+		unsigned intktxfemp : 1;
+		/** IN Token Received with EP mismatch mask */
+		unsigned intknepmis : 1;
+		/** IN Endpoint HAK Effective mask */
+		unsigned inepnakeff : 1;
+		/** IN Endpoint HAK Effective mask */
+		unsigned emptyintr : 1;
+		
+		unsigned txfifoundrn : 1;
+
+		/** BNA Interrupt mask */
+		unsigned bna : 1;
+		
+		unsigned reserved10_12 : 3;
+		/** BNA Interrupt mask */
+		unsigned nak : 1;
+		
+		unsigned reserved14_31 : 18;
+		} b;
+} diepint_data_t;
+
+/**
+ * This union represents the bit fields in the Device IN EP 
+ * Common/Dedicated Interrupt Mask Register.
+ */
+typedef union diepint_data diepmsk_data_t;
+
+/**
+ * This union represents the bit fields in the Device OUT EP Interrupt
+ * Registerand Device OUT EP Common Interrupt Mask Register.
+ *
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union doepint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/** Transfer complete */
+		unsigned xfercompl : 1;
+		/** Endpoint disable  */
+		unsigned epdisabled : 1;
+		/** AHB Error */
+		unsigned ahberr : 1;
+		/** Setup Phase Done (contorl EPs) */
+		unsigned setup : 1;
+		/** OUT Token Received when Endpoint Disabled */
+		unsigned outtknepdis : 1;
+		
+		unsigned stsphsercvd : 1;
+		/** Back-to-Back SETUP Packets Received */ 
+		unsigned back2backsetup : 1;
+		
+		unsigned reserved7 : 1;
+		/** OUT packet Error */
+		unsigned outpkterr : 1;
+		/** BNA Interrupt */
+		unsigned bna : 1;
+	
+		unsigned reserved10 : 1;
+		/** Packet Drop Status */
+		unsigned pktdrpsts : 1;
+		/** Babble Interrupt */
+		unsigned babble : 1;
+		/** NAK Interrupt */
+		unsigned nak : 1;
+		/** NYET Interrupt */
+		unsigned nyet : 1;
+
+		unsigned reserved15_31 : 17;
+	} b;
+} doepint_data_t;
+
+/**
+ * This union represents the bit fields in the Device OUT EP 
+ * Common/Dedicated Interrupt Mask Register.
+ */
+typedef union doepint_data doepmsk_data_t;
+
+/**
+ * This union represents the bit fields in the Device All EP Interrupt
+ * and Mask Registers.
+ * - Read the register into the <i>d32</i> member then set/clear the
+ *	 bits using the <i>b</i>it elements.
+ */
+typedef union daint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/** IN Endpoint bits */
+		unsigned in : 16;
+		/** OUT Endpoint bits */
+		unsigned out : 16;
+	} ep;
+	struct 
+	{
+		/** IN Endpoint bits */
+		unsigned inep0	: 1;
+		unsigned inep1	: 1;
+		unsigned inep2	: 1;
+		unsigned inep3	: 1;
+		unsigned inep4	: 1;
+		unsigned inep5	: 1;
+		unsigned inep6	: 1;
+		unsigned inep7	: 1;
+		unsigned inep8	: 1;
+		unsigned inep9	: 1;
+		unsigned inep10 : 1;
+		unsigned inep11 : 1;
+		unsigned inep12 : 1;
+		unsigned inep13 : 1;
+		unsigned inep14 : 1;
+		unsigned inep15 : 1;
+		/** OUT Endpoint bits */
+		unsigned outep0	 : 1;
+		unsigned outep1	 : 1;
+		unsigned outep2	 : 1;
+		unsigned outep3	 : 1;
+		unsigned outep4	 : 1;
+		unsigned outep5	 : 1;
+		unsigned outep6	 : 1;
+		unsigned outep7	 : 1;
+		unsigned outep8	 : 1;
+		unsigned outep9	 : 1;
+		unsigned outep10 : 1;
+		unsigned outep11 : 1;
+		unsigned outep12 : 1;
+		unsigned outep13 : 1;
+		unsigned outep14 : 1;
+		unsigned outep15 : 1;
+	} b;
+} daint_data_t;
+
+/**
+ * This union represents the bit fields in the Device IN Token Queue
+ * Read Registers.
+ * - Read the register into the <i>d32</i> member.
+ * - READ-ONLY Register
+ */
+typedef union dtknq1_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/** In Token Queue Write Pointer */
+		unsigned intknwptr : 5;
+		/** Reserved */
+		unsigned reserved05_06 : 2;
+		/** write pointer has wrapped. */
+		unsigned wrap_bit : 1;
+		/** EP Numbers of IN Tokens 0 ... 4 */
+		unsigned epnums0_5 : 24;
+	}b;
+} dtknq1_data_t;
+
+/**
+ * This union represents Threshold control Register
+ * - Read and write the register into the <i>d32</i> member.
+ * - READ-WRITABLE Register
+ */
+typedef union dthrctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/** non ISO Tx Thr. Enable */
+		unsigned non_iso_thr_en : 1;
+		/** ISO Tx Thr. Enable */
+		unsigned iso_thr_en : 1;
+		/** Tx Thr. Length */
+		unsigned tx_thr_len : 9;
+		/** Reserved */
+		unsigned reserved11_15 : 5;
+		/** Rx Thr. Enable */
+		unsigned rx_thr_en : 1;
+		/** Rx Thr. Length */
+		unsigned rx_thr_len : 9;
+		/** Reserved */
+		unsigned reserved26_31 : 6;
+	}b;
+} dthrctl_data_t;
+
+
+/**
+ * Device Logical IN Endpoint-Specific Registers. <i>Offsets
+ * 900h-AFCh</i>
+ *
+ * There will be one set of endpoint registers per logical endpoint
+ * implemented.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_in_ep_regs 
+{
+	/** Device IN Endpoint Control Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 00h</i> */
+	volatile uint32_t diepctl;
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 04h</i> */
+	uint32_t reserved04;	
+	/** Device IN Endpoint Interrupt Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 08h</i> */
+	volatile uint32_t diepint; 
+	/** Reserved. <i>Offset:900h + (ep_num * 20h) + 0Ch</i> */
+	uint32_t reserved0C;	
+	/** Device IN Endpoint Transfer Size
+	 * Register. <i>Offset:900h + (ep_num * 20h) + 10h</i> */
+	volatile uint32_t dieptsiz; 
+	/** Device IN Endpoint DMA Address Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 14h</i> */
+	volatile uint32_t diepdma; 
+	/** Device IN Endpoint Transmit FIFO Status Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 18h</i> */
+	volatile uint32_t dtxfsts;
+	/** Device IN Endpoint DMA Buffer Register. <i>Offset:900h +
+	 * (ep_num * 20h) + 1Ch</i> */
+	volatile uint32_t diepdmab;
+} dwc_otg_dev_in_ep_regs_t;
+
+/**
+ * Device Logical OUT Endpoint-Specific Registers. <i>Offsets:
+ * B00h-CFCh</i>
+ *
+ * There will be one set of endpoint registers per logical endpoint
+ * implemented.
+ *
+ * <i>These registers are visible only in Device mode and must not be
+ * accessed in Host mode, as the results are unknown.</i>
+ */
+typedef struct dwc_otg_dev_out_ep_regs 
+{
+	/** Device OUT Endpoint Control Register. <i>Offset:B00h +
+	 * (ep_num * 20h) + 00h</i> */
+	volatile uint32_t doepctl; 
+	/** Device OUT Endpoint Frame number Register.	<i>Offset:
+	 * B00h + (ep_num * 20h) + 04h</i> */ 
+	volatile uint32_t doepfn; 
+	/** Device OUT Endpoint Interrupt Register. <i>Offset:B00h +
+	 * (ep_num * 20h) + 08h</i> */
+	volatile uint32_t doepint; 
+	/** Reserved. <i>Offset:B00h + (ep_num * 20h) + 0Ch</i> */
+	uint32_t reserved0C;	
+	/** Device OUT Endpoint Transfer Size Register. <i>Offset:
+	 * B00h + (ep_num * 20h) + 10h</i> */
+	volatile uint32_t doeptsiz; 
+	/** Device OUT Endpoint DMA Address Register. <i>Offset:B00h
+	 * + (ep_num * 20h) + 14h</i> */
+	volatile uint32_t doepdma; 
+	/** Reserved. <i>Offset:B00h + 	 * (ep_num * 20h) + 18h</i> */
+	uint32_t unused;		
+	/** Device OUT Endpoint DMA Buffer Register. <i>Offset:B00h
+	 * + (ep_num * 20h) + 1Ch</i> */
+	uint32_t doepdmab;		
+} dwc_otg_dev_out_ep_regs_t;
+
+/**
+ * This union represents the bit fields in the Device EP Control
+ * Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union depctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/** Maximum Packet Size 
+		 * IN/OUT EPn
+		 * IN/OUT EP0 - 2 bits
+		 *	 2'b00: 64 Bytes
+		 *	 2'b01: 32
+		 *	 2'b10: 16
+		 *	 2'b11: 8 */
+		unsigned mps : 11;
+#define DWC_DEP0CTL_MPS_64	 0
+#define DWC_DEP0CTL_MPS_32	 1
+#define DWC_DEP0CTL_MPS_16	 2
+#define DWC_DEP0CTL_MPS_8	 3
+
+		/** Next Endpoint 
+		 * IN EPn/IN EP0 
+		 * OUT EPn/OUT EP0 - reserved */
+		unsigned nextep : 4;
+
+		/** USB Active Endpoint */
+		unsigned usbactep : 1;
+
+		/** Endpoint DPID (INTR/Bulk IN and OUT endpoints)
+		 * This field contains the PID of the packet going to
+		 * be received or transmitted on this endpoint. The
+		 * application should program the PID of the first
+		 * packet going to be received or transmitted on this
+		 * endpoint , after the endpoint is
+		 * activated. Application use the SetD1PID and
+		 * SetD0PID fields of this register to program either
+		 * D0 or D1 PID.
+		 * 
+		 * The encoding for this field is
+		 *	 - 0: D0
+		 *	 - 1: D1
+		 */
+		unsigned dpid : 1;
+
+		/** NAK Status */
+		unsigned naksts : 1;
+
+		/** Endpoint Type 
+		 *	2'b00: Control
+		 *	2'b01: Isochronous
+		 *	2'b10: Bulk
+		 *	2'b11: Interrupt */
+		unsigned eptype : 2;
+
+		/** Snoop Mode 
+		 * OUT EPn/OUT EP0
+		 * IN EPn/IN EP0 - reserved */
+		unsigned snp : 1;
+
+		/** Stall Handshake */
+		unsigned stall : 1;
+
+		/** Tx Fifo Number 
+		 * IN EPn/IN EP0
+		 * OUT EPn/OUT EP0 - reserved */
+		unsigned txfnum : 4;
+
+		/** Clear NAK */
+		unsigned cnak : 1;
+		/** Set NAK */
+		unsigned snak : 1;
+		/** Set DATA0 PID (INTR/Bulk IN and OUT endpoints)
+		 * Writing to this field sets the Endpoint DPID (DPID)
+		 * field in this register to DATA0. Set Even
+		 * (micro)frame (SetEvenFr) (ISO IN and OUT Endpoints)
+		 * Writing to this field sets the Even/Odd
+		 * (micro)frame (EO_FrNum) field to even (micro)
+		 * frame.
+		 */
+		unsigned setd0pid : 1;
+		/** Set DATA1 PID (INTR/Bulk IN and OUT endpoints)
+		 * Writing to this field sets the Endpoint DPID (DPID)
+		 * field in this register to DATA1 Set Odd
+		 * (micro)frame (SetOddFr) (ISO IN and OUT Endpoints)
+		 * Writing to this field sets the Even/Odd
+		 * (micro)frame (EO_FrNum) field to odd (micro) frame.
+		 */
+		unsigned setd1pid : 1;
+		
+		/** Endpoint Disable */
+		unsigned epdis : 1;
+		/** Endpoint Enable */
+		unsigned epena : 1;
+		} b;
+} depctl_data_t;
+
+/**
+ * This union represents the bit fields in the Device EP Transfer
+ * Size Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union deptsiz_data
+{
+		/** raw register data */
+		uint32_t d32;
+		/** register bits */
+		struct {
+		/** Transfer size */
+		unsigned xfersize : 19;
+		/** Packet Count */
+		unsigned pktcnt : 10;
+		/** Multi Count - Periodic IN endpoints */
+		unsigned mc : 2;
+		unsigned reserved : 1;
+		} b;
+} deptsiz_data_t;
+
+/**
+ * This union represents the bit fields in the Device EP 0 Transfer
+ * Size Register.  Read the register into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it elements.
+ */
+typedef union deptsiz0_data
+{
+		/** raw register data */
+		uint32_t d32;
+		/** register bits */
+		struct {
+		/** Transfer size */
+		unsigned xfersize : 7;
+				/** Reserved */
+				unsigned reserved7_18 : 12;
+		/** Packet Count */
+		unsigned pktcnt : 2;
+				/** Reserved */
+		unsigned reserved21_28 : 9;
+				/**Setup Packet Count (DOEPTSIZ0 Only) */
+				unsigned supcnt : 2;
+				unsigned reserved31;
+		} b;
+} deptsiz0_data_t;
+
+
+/////////////////////////////////////////////////
+// DMA Descriptor Specific Structures
+//
+
+/** Buffer status definitions */
+
+#define BS_HOST_READY	0x0
+#define BS_DMA_BUSY		0x1
+#define BS_DMA_DONE		0x2
+#define BS_HOST_BUSY	0x3
+
+/** Receive/Transmit status definitions */
+
+#define RTS_SUCCESS		0x0
+#define RTS_BUFFLUSH	0x1
+#define RTS_RESERVED	0x2
+#define RTS_BUFERR		0x3
+
+
+/**
+ * This union represents the bit fields in the DMA Descriptor
+ * status quadlet. Read the quadlet into the <i>d32</i> member then
+ * set/clear the bits using the <i>b</i>it, <i>b_iso_out</i> and 
+ * <i>b_iso_in</i> elements.
+ */
+typedef union desc_sts_data
+{
+		/** raw register data */
+		uint32_t d32;
+		/** quadlet bits */
+		struct {
+		/** Received number of bytes */
+		unsigned bytes : 16;
+
+		unsigned reserved16_22 : 7;
+		/** Multiple Transfer - only for OUT EPs */
+		unsigned mtrf : 1;
+		/** Setup Packet received - only for OUT EPs */
+		unsigned sr : 1;
+		/** Interrupt On Complete */
+		unsigned ioc : 1;
+		/** Short Packet */
+		unsigned sp : 1;
+		/** Last */
+		unsigned l : 1;
+		/** Receive Status */
+		unsigned sts : 2;
+		/** Buffer Status */
+		unsigned bs : 2;
+		} b;
+} desc_sts_data_t;
+
+/** 
+ * DMA Descriptor structure 
+ *
+ * DMA Descriptor structure contains two quadlets:
+ * Status quadlet and Data buffer pointer.
+ */
+typedef struct dwc_otg_dma_desc
+{
+	/** DMA Descriptor status quadlet */
+	desc_sts_data_t	status;
+	/** DMA Descriptor data buffer pointer */
+ 	dma_addr_t	buf;
+} dwc_otg_dma_desc_t;
+
+/**
+ * The dwc_otg_dev_if structure contains information needed to manage
+ * the DWC_otg controller acting in device mode. It represents the
+ * programming view of the device-specific aspects of the controller.
+ */
+typedef struct dwc_otg_dev_if 
+{
+	/** Pointer to device Global registers.
+	 * Device Global Registers starting at offset 800h
+	 */
+	dwc_otg_device_global_regs_t *dev_global_regs; 
+#define DWC_DEV_GLOBAL_REG_OFFSET 0x800
+
+	/** 
+	 * Device Logical IN Endpoint-Specific Registers 900h-AFCh 
+	 */
+	dwc_otg_dev_in_ep_regs_t	 *in_ep_regs[MAX_EPS_CHANNELS];
+#define DWC_DEV_IN_EP_REG_OFFSET 0x900
+#define DWC_EP_REG_OFFSET 0x20
+
+	/** Device Logical OUT Endpoint-Specific Registers B00h-CFCh */
+	dwc_otg_dev_out_ep_regs_t	 *out_ep_regs[MAX_EPS_CHANNELS];
+#define DWC_DEV_OUT_EP_REG_OFFSET 0xB00
+
+	/* Device configuration information*/
+	uint8_t	 speed;				 /**< Device Speed	0: Unknown, 1: LS, 2:FS, 3: HS */
+	uint8_t	 num_in_eps;		 /**< Number # of Tx EP range: 0-15 exept ep0 */
+	uint8_t	 num_out_eps;		 /**< Number # of Rx EP range: 0-15 exept ep 0*/
+
+	/** Size of periodic FIFOs (Bytes) */
+	uint16_t perio_tx_fifo_size[MAX_PERIO_FIFOS];  
+
+	/** Size of Tx FIFOs (Bytes) */
+	uint16_t tx_fifo_size[MAX_TX_FIFOS];  
+
+	/** Thresholding enable flags and length varaiables **/
+	uint16_t rx_thr_en;
+	uint16_t iso_tx_thr_en;
+	uint16_t non_iso_tx_thr_en;
+
+	uint16_t rx_thr_length;
+	uint16_t tx_thr_length;
+
+	/**
+	 * Pointers to the DMA Descriptors for EP0 Control
+	 * transfers (virtual and physical)
+	 */
+		
+	/** 2 descriptors for SETUP packets */
+	uint32_t dma_setup_desc_addr[2];
+	dwc_otg_dma_desc_t* setup_desc_addr[2];
+
+	/** Pointer to Descriptor with latest SETUP packet */
+	dwc_otg_dma_desc_t* psetup;
+
+	/** Index of current SETUP handler descriptor */
+	uint32_t setup_desc_index;
+
+	/** Descriptor for Data In or Status In phases */
+	uint32_t dma_in_desc_addr;
+	dwc_otg_dma_desc_t* in_desc_addr;;
+	
+	/** Descriptor for Data Out or Status Out phases */
+	uint32_t dma_out_desc_addr;
+	dwc_otg_dma_desc_t* out_desc_addr;
+		
+} dwc_otg_dev_if_t;
+
+
+
+
+/////////////////////////////////////////////////
+// Host Mode Register Structures
+//
+/**
+ * The Host Global Registers structure defines the size and relative
+ * field offsets for the Host Mode Global Registers.  Host Global
+ * Registers offsets 400h-7FFh.
+*/
+typedef struct dwc_otg_host_global_regs 
+{
+	/** Host Configuration Register.   <i>Offset: 400h</i> */
+	volatile uint32_t hcfg;		  
+	/** Host Frame Interval Register.	<i>Offset: 404h</i> */
+	volatile uint32_t hfir;		  
+	/** Host Frame Number / Frame Remaining Register. <i>Offset: 408h</i> */
+	volatile uint32_t hfnum; 
+	/** Reserved.	<i>Offset: 40Ch</i> */
+	uint32_t reserved40C;
+	/** Host Periodic Transmit FIFO/ Queue Status Register. <i>Offset: 410h</i> */
+	volatile uint32_t hptxsts;	  
+	/** Host All Channels Interrupt Register. <i>Offset: 414h</i> */
+	volatile uint32_t haint;	  
+	/** Host All Channels Interrupt Mask Register. <i>Offset: 418h</i> */
+	volatile uint32_t haintmsk;	  
+} dwc_otg_host_global_regs_t;
+
+/**
+ * This union represents the bit fields in the Host Configuration Register.
+ * Read the register into the <i>d32</i> member then set/clear the bits using
+ * the <i>b</i>it elements. Write the <i>d32</i> member to the hcfg register.
+ */
+typedef union hcfg_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct 
+	{
+		/** FS/LS Phy Clock Select */
+		unsigned fslspclksel : 2;
+#define DWC_HCFG_30_60_MHZ 0
+#define DWC_HCFG_48_MHZ	   1
+#define DWC_HCFG_6_MHZ	   2
+
+		/** FS/LS Only Support */
+		unsigned fslssupp : 1;
+		} b;
+} hcfg_data_t;
+
+/**
+ * This union represents the bit fields in the Host Frame Remaing/Number
+ * Register.  
+ */
+typedef union hfir_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct 
+	{
+		unsigned frint : 16;
+		unsigned reserved : 16;
+	} b;
+} hfir_data_t;
+
+/**
+ * This union represents the bit fields in the Host Frame Remaing/Number
+ * Register.  
+ */
+typedef union hfnum_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct 
+	{
+		unsigned frnum : 16;
+#define DWC_HFNUM_MAX_FRNUM 0x3FFF
+		unsigned frrem : 16;
+	} b;
+} hfnum_data_t;
+
+typedef union hptxsts_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct 
+	{
+		unsigned ptxfspcavail : 16;
+		unsigned ptxqspcavail : 8;
+		/** Top of the Periodic Transmit Request Queue
+		 *	- bit 24 - Terminate (last entry for the selected channel)
+		 *	- bits 26:25 - Token Type
+		 *	  - 2'b00 - Zero length
+		 *	  - 2'b01 - Ping
+		 *	  - 2'b10 - Disable
+		 *	- bits 30:27 - Channel Number
+		 *	- bit 31 - Odd/even microframe
+		 */
+		unsigned ptxqtop_terminate : 1;
+		unsigned ptxqtop_token : 2;
+		unsigned ptxqtop_chnum : 4;
+		unsigned ptxqtop_odd : 1;
+	} b;
+} hptxsts_data_t;
+
+/**
+ * This union represents the bit fields in the Host Port Control and Status
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hprt0 register.
+ */
+typedef union hprt0_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned prtconnsts : 1;
+		unsigned prtconndet : 1;
+		unsigned prtena : 1;
+		unsigned prtenchng : 1;
+		unsigned prtovrcurract : 1;
+		unsigned prtovrcurrchng : 1;
+		unsigned prtres : 1;
+		unsigned prtsusp : 1;
+		unsigned prtrst : 1;
+		unsigned reserved9 : 1;
+		unsigned prtlnsts : 2;
+		unsigned prtpwr : 1;
+		unsigned prttstctl : 4;
+		unsigned prtspd : 2;
+#define DWC_HPRT0_PRTSPD_HIGH_SPEED 0
+#define DWC_HPRT0_PRTSPD_FULL_SPEED 1
+#define DWC_HPRT0_PRTSPD_LOW_SPEED	2
+		unsigned reserved19_31 : 13;
+	} b;
+} hprt0_data_t;
+
+/**
+ * This union represents the bit fields in the Host All Interrupt 
+ * Register.  
+ */
+typedef union haint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned ch0 : 1;
+		unsigned ch1 : 1;
+		unsigned ch2 : 1;
+		unsigned ch3 : 1;
+		unsigned ch4 : 1;
+		unsigned ch5 : 1;
+		unsigned ch6 : 1;
+		unsigned ch7 : 1;
+		unsigned ch8 : 1;
+		unsigned ch9 : 1;
+		unsigned ch10 : 1;
+		unsigned ch11 : 1;
+		unsigned ch12 : 1;
+		unsigned ch13 : 1;
+		unsigned ch14 : 1;
+		unsigned ch15 : 1;
+		unsigned reserved : 16;
+	} b;
+	
+	struct 
+	{
+		unsigned chint : 16;
+		unsigned reserved : 16;
+	} b2;
+} haint_data_t;
+
+/**
+ * This union represents the bit fields in the Host All Interrupt 
+ * Register.  
+ */
+typedef union haintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		unsigned ch0 : 1;
+		unsigned ch1 : 1;
+		unsigned ch2 : 1;
+		unsigned ch3 : 1;
+		unsigned ch4 : 1;
+		unsigned ch5 : 1;
+		unsigned ch6 : 1;
+		unsigned ch7 : 1;
+		unsigned ch8 : 1;
+		unsigned ch9 : 1;
+		unsigned ch10 : 1;
+		unsigned ch11 : 1;
+		unsigned ch12 : 1;
+		unsigned ch13 : 1;
+		unsigned ch14 : 1;
+		unsigned ch15 : 1;
+		unsigned reserved : 16;
+	} b;
+	
+	struct 
+	{
+		unsigned chint : 16;
+		unsigned reserved : 16;
+	} b2;
+} haintmsk_data_t;
+
+/** 
+ * Host Channel Specific Registers. <i>500h-5FCh</i>
+ */
+typedef struct dwc_otg_hc_regs 
+{
+	/** Host Channel 0 Characteristic Register. <i>Offset: 500h + (chan_num * 20h) + 00h</i> */
+	volatile uint32_t hcchar;	  
+	/** Host Channel 0 Split Control Register. <i>Offset: 500h + (chan_num * 20h) + 04h</i> */
+	volatile uint32_t hcsplt;	  
+	/** Host Channel 0 Interrupt Register. <i>Offset: 500h + (chan_num * 20h) + 08h</i> */
+	volatile uint32_t hcint;
+	/** Host Channel 0 Interrupt Mask Register. <i>Offset: 500h + (chan_num * 20h) + 0Ch</i> */
+	volatile uint32_t hcintmsk;
+	/** Host Channel 0 Transfer Size Register. <i>Offset: 500h + (chan_num * 20h) + 10h</i> */
+	volatile uint32_t hctsiz;
+	/** Host Channel 0 DMA Address Register. <i>Offset: 500h + (chan_num * 20h) + 14h</i> */
+	volatile uint32_t hcdma;
+	/** Reserved.  <i>Offset: 500h + (chan_num * 20h) + 18h - 500h + (chan_num * 20h) + 1Ch</i> */
+	uint32_t reserved[2];
+} dwc_otg_hc_regs_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Characteristics
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcchar register.
+ */
+typedef union hcchar_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct 
+	{
+		/** Maximum packet size in bytes */
+		unsigned mps : 11;
+
+		/** Endpoint number */
+		unsigned epnum : 4;
+
+		/** 0: OUT, 1: IN */
+		unsigned epdir : 1;
+
+		unsigned reserved : 1;
+
+		/** 0: Full/high speed device, 1: Low speed device */
+		unsigned lspddev : 1;
+
+		/** 0: Control, 1: Isoc, 2: Bulk, 3: Intr */
+		unsigned eptype : 2;
+
+		/** Packets per frame for periodic transfers. 0 is reserved. */
+		unsigned multicnt : 2;
+
+		/** Device address */
+		unsigned devaddr : 7;
+
+		/**
+		 * Frame to transmit periodic transaction.
+		 * 0: even, 1: odd
+		 */
+		unsigned oddfrm : 1;
+
+		/** Channel disable */
+		unsigned chdis : 1;
+
+		/** Channel enable */
+		unsigned chen : 1;
+	} b;
+} hcchar_data_t;
+
+typedef union hcsplt_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct 
+	{
+		/** Port Address */
+		unsigned prtaddr : 7;
+
+		/** Hub Address */
+		unsigned hubaddr : 7;
+
+		/** Transaction Position */
+		unsigned xactpos : 2;
+#define DWC_HCSPLIT_XACTPOS_MID 0
+#define DWC_HCSPLIT_XACTPOS_END 1
+#define DWC_HCSPLIT_XACTPOS_BEGIN 2
+#define DWC_HCSPLIT_XACTPOS_ALL 3
+
+		/** Do Complete Split */
+		unsigned compsplt : 1;
+
+		/** Reserved */
+		unsigned reserved : 14;
+
+		/** Split Enble */
+		unsigned spltena : 1;
+	} b;
+} hcsplt_data_t;
+
+
+/**
+ * This union represents the bit fields in the Host All Interrupt 
+ * Register.  
+ */
+typedef union hcint_data
+{
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct 
+	{
+		/** Transfer Complete */
+		unsigned xfercomp : 1;
+		/** Channel Halted */
+		unsigned chhltd : 1;
+		/** AHB Error */
+		unsigned ahberr : 1;
+		/** STALL Response Received */
+		unsigned stall : 1;
+		/** NAK Response Received */
+		unsigned nak : 1;
+		/** ACK Response Received */
+		unsigned ack : 1;
+		/** NYET Response Received */
+		unsigned nyet : 1;
+		/** Transaction Err */
+		unsigned xacterr : 1;
+		/** Babble Error */
+		unsigned bblerr : 1;
+		/** Frame Overrun */
+		unsigned frmovrun : 1;
+		/** Data Toggle Error */
+		unsigned datatglerr : 1;
+		/** Reserved */
+		unsigned reserved : 21;
+	} b;
+} hcint_data_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Transfer Size
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcchar register.
+ */
+typedef union hctsiz_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct 
+	{
+		/** Total transfer size in bytes */
+		unsigned xfersize : 19;
+
+		/** Data packets to transfer */
+		unsigned pktcnt : 10;
+
+		/**
+		 * Packet ID for next data packet
+		 * 0: DATA0
+		 * 1: DATA2
+		 * 2: DATA1
+		 * 3: MDATA (non-Control), SETUP (Control)
+		 */
+		unsigned pid : 2;
+#define DWC_HCTSIZ_DATA0 0
+#define DWC_HCTSIZ_DATA1 2
+#define DWC_HCTSIZ_DATA2 1
+#define DWC_HCTSIZ_MDATA 3
+#define DWC_HCTSIZ_SETUP 3		
+
+		/** Do PING protocol when 1 */
+		unsigned dopng : 1;
+	} b;
+} hctsiz_data_t;
+
+/**
+ * This union represents the bit fields in the Host Channel Interrupt Mask
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. Write the <i>d32</i> member to the
+ * hcintmsk register.
+ */
+typedef union hcintmsk_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct 
+	{
+		unsigned xfercompl : 1;
+		unsigned chhltd : 1;
+		unsigned ahberr : 1;
+		unsigned stall : 1;
+		unsigned nak : 1;
+		unsigned ack : 1;
+		unsigned nyet : 1;
+		unsigned xacterr : 1;
+		unsigned bblerr : 1;
+		unsigned frmovrun : 1;
+		unsigned datatglerr : 1;
+		unsigned reserved : 21;
+	} b;
+} hcintmsk_data_t;
+
+/** OTG Host Interface Structure.
+ *
+ * The OTG Host Interface Structure structure contains information
+ * needed to manage the DWC_otg controller acting in host mode. It
+ * represents the programming view of the host-specific aspects of the
+ * controller.
+ */
+typedef struct dwc_otg_host_if 
+{
+	/** Host Global Registers starting at offset 400h.*/
+	dwc_otg_host_global_regs_t *host_global_regs;
+#define DWC_OTG_HOST_GLOBAL_REG_OFFSET 0x400 
+
+	/** Host Port 0 Control and Status Register */
+	volatile uint32_t *hprt0;
+#define DWC_OTG_HOST_PORT_REGS_OFFSET 0x440
+		
+
+	/** Host Channel Specific Registers at offsets 500h-5FCh. */
+	dwc_otg_hc_regs_t *hc_regs[MAX_EPS_CHANNELS];
+#define DWC_OTG_HOST_CHAN_REGS_OFFSET 0x500
+#define DWC_OTG_CHAN_REGS_OFFSET 0x20
+
+
+	/* Host configuration information */
+	/** Number of Host Channels (range: 1-16) */
+	uint8_t	 num_host_channels;	   
+	/** Periodic EPs supported (0: no, 1: yes) */
+	uint8_t	 perio_eps_supported;
+	/** Periodic Tx FIFO Size (Only 1 host periodic Tx FIFO) */
+	uint16_t perio_tx_fifo_size;   
+  
+} dwc_otg_host_if_t;
+
+
+/**
+ * This union represents the bit fields in the Power and Clock Gating Control
+ * Register. Read the register into the <i>d32</i> member then set/clear the
+ * bits using the <i>b</i>it elements. 
+ */
+typedef union pcgcctl_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct 
+	{
+		/** Stop Pclk */
+		unsigned stoppclk : 1;
+		/** Gate Hclk */
+		unsigned gatehclk : 1;
+		/** Power Clamp */
+		unsigned pwrclmp : 1;
+		/** Reset Power Down Modules */
+		unsigned rstpdwnmodule : 1;
+		/** PHY Suspended */
+		unsigned physuspended : 1;
+		
+		unsigned reserved : 27;
+	} b;
+} pcgcctl_data_t;
+
+// Ricky26
+
+/**
+ * This union represents the inbuild PHY's power register.
+ */
+typedef union phypwr_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** Force Suspend */
+		unsigned forcesusp : 1;
+
+		/** Power Down PLL */
+		unsigned pllpwrdwn : 1;
+
+		/** Power Down XO */
+		unsigned xopwrdwn : 1;
+
+		/** Power Down Analogue */
+	    unsigned apwrdwn : 1;
+
+		/** Power Down Unknown */
+		unsigned pwrdwnunk : 1;
+
+		unsigned reserved : 27;	
+
+	} b;
+
+} phypwr_data_t;
+
+/**
+ * This union represents the inbuild PHY's clock register.
+ */
+typedef union phyclk_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		unsigned clksel : 3;
+#define DWC_OTG_PHYCLK_CLKSEL_MASK 0x3
+#define DWC_OTG_PHYCLK_CLKSEL_48MHZ 0x0
+#define DWC_OTG_PHYCLK_CLKSEL_12MHZ 0x2
+#define DWC_OTG_PHYCLK_CLKSEL_24MHZ 0x3
+
+		unsigned reserved : 29;	
+
+	} b;
+
+} phyclk_data_t;
+
+/**
+ * This union represents the inbuild PHY's reset control register.
+ */
+typedef union rstcon_data
+{
+	/** raw register data */
+	uint32_t d32;
+
+	/** register bits */
+	struct
+	{
+		/** PHY Software Reset */
+		unsigned physwrst : 1;
+
+		/** Link Software Reset */
+		unsigned lnkswrst : 1;
+
+		/** PHY & Link Software Reset */
+		unsigned phylnkswrst : 1;
+
+		unsigned reserved : 29;	
+	} b;
+
+} rstcon_data_t;
+
+typedef struct dwc_otg_phy_regs
+{
+	volatile uint32_t phypwr;
+	volatile uint32_t phyclk;
+	volatile uint32_t rstcon;
+} dwc_otg_phy_regs_t;
+
+#endif
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/Makefile
--- linux-2.6.32-orig/drivers/usb/gadget/dwc_otg/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/dwc_otg/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,16 @@
+#
+# Makefile for DWC OTG Highspeed USB controller driver
+#
+
+KBUILD_CPPFLAGS	+= -Dlinux
+#KBUILD_CPPFLAGS += -DDEBUG
+#KBUILD_CPPFLAGS += -DVERBOSE
+
+obj-$(CONFIG_USB_DWC_OTG) += dwc_otg.o
+
+dwc_otg-objs	:= dwc_otg_driver.o
+dwc_otg-objs	+= dwc_otg_hw.o
+dwc_otg-objs	+= dwc_otg_core.o
+dwc_otg-objs	+= dwc_otg_device.o
+dwc_otg-objs	+= dwc_otg_gadget.o
+
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/f_acm.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/f_acm.c
--- linux-2.6.32-orig/drivers/usb/gadget/f_acm.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/f_acm.c	2010-11-18 21:05:30.000000000 +0600
@@ -14,6 +14,7 @@
 
 #include <linux/kernel.h>
 #include <linux/device.h>
+#include <linux/usb/android_composite.h>
 
 #include "u_serial.h"
 #include "gadget_chips.h"
@@ -384,10 +385,10 @@
 			usb_ep_disable(acm->notify);
 		} else {
 			VDBG(cdev, "init acm ctrl interface %d\n", intf);
-			acm->notify_desc = ep_choose(cdev->gadget,
-					acm->hs.notify,
-					acm->fs.notify);
 		}
+		acm->notify_desc = ep_choose(cdev->gadget,
+				acm->hs.notify,
+				acm->fs.notify);
 		usb_ep_enable(acm->notify, acm->notify_desc);
 		acm->notify->driver_data = acm;
 
@@ -397,11 +398,11 @@
 			gserial_disconnect(&acm->port);
 		} else {
 			DBG(cdev, "activate acm ttyGS%d\n", acm->port_num);
-			acm->port.in_desc = ep_choose(cdev->gadget,
-					acm->hs.in, acm->fs.in);
-			acm->port.out_desc = ep_choose(cdev->gadget,
-					acm->hs.out, acm->fs.out);
 		}
+		acm->port.in_desc = ep_choose(cdev->gadget,
+				acm->hs.in, acm->fs.in);
+		acm->port.out_desc = ep_choose(cdev->gadget,
+				acm->hs.out, acm->fs.out);
 		gserial_connect(&acm->port, acm->port_num);
 
 	} else
@@ -761,3 +762,28 @@
 		kfree(acm);
 	return status;
 }
+
+#ifdef CONFIG_USB_ANDROID_ACM
+
+int acm_function_bind_config(struct usb_configuration *c)
+{
+	int ret = acm_bind_config(c, 0);
+	if (ret == 0)
+		gserial_setup(c->cdev->gadget, 1);
+	return ret;
+}
+
+static struct android_usb_function acm_function = {
+	.name = "acm",
+	.bind_config = acm_function_bind_config,
+};
+
+static int __init init(void)
+{
+	printk(KERN_INFO "f_acm init\n");
+	android_register_function(&acm_function);
+	return 0;
+}
+module_init(init);
+
+#endif /* CONFIG_USB_ANDROID_ACM */
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/f_adb.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/f_adb.c
--- linux-2.6.32-orig/drivers/usb/gadget/f_adb.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/f_adb.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,656 @@
+/*
+ * Gadget Driver for Android ADB
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+
+#include <linux/usb/android_composite.h>
+
+#define BULK_BUFFER_SIZE           4096
+
+/* number of tx requests to allocate */
+#define TX_REQ_MAX 4
+
+static const char shortname[] = "android_adb";
+
+struct adb_dev {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+	spinlock_t lock;
+
+	struct usb_ep *ep_in;
+	struct usb_ep *ep_out;
+
+	int online;
+	int error;
+
+	atomic_t read_excl;
+	atomic_t write_excl;
+	atomic_t open_excl;
+
+	struct list_head tx_idle;
+
+	wait_queue_head_t read_wq;
+	wait_queue_head_t write_wq;
+	struct usb_request *rx_req;
+	int rx_done;
+};
+
+static struct usb_interface_descriptor adb_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bInterfaceNumber       = 0,
+	.bNumEndpoints          = 2,
+	.bInterfaceClass        = 0xFF,
+	.bInterfaceSubClass     = 0x42,
+	.bInterfaceProtocol     = 1,
+};
+
+static struct usb_endpoint_descriptor adb_highspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor adb_highspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor adb_fullspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor adb_fullspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_descriptor_header *fs_adb_descs[] = {
+	(struct usb_descriptor_header *) &adb_interface_desc,
+	(struct usb_descriptor_header *) &adb_fullspeed_in_desc,
+	(struct usb_descriptor_header *) &adb_fullspeed_out_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *hs_adb_descs[] = {
+	(struct usb_descriptor_header *) &adb_interface_desc,
+	(struct usb_descriptor_header *) &adb_highspeed_in_desc,
+	(struct usb_descriptor_header *) &adb_highspeed_out_desc,
+	NULL,
+};
+
+
+/* temporary variable used between adb_open() and adb_gadget_bind() */
+static struct adb_dev *_adb_dev;
+
+static atomic_t adb_enable_excl;
+
+static inline struct adb_dev *func_to_dev(struct usb_function *f)
+{
+	return container_of(f, struct adb_dev, function);
+}
+
+
+static struct usb_request *adb_request_new(struct usb_ep *ep, int buffer_size)
+{
+	struct usb_request *req = usb_ep_alloc_request(ep, GFP_KERNEL);
+	if (!req)
+		return NULL;
+
+	/* now allocate buffers for the requests */
+	req->buf = kmalloc(buffer_size, GFP_KERNEL);
+	if (!req->buf) {
+		usb_ep_free_request(ep, req);
+		return NULL;
+	}
+
+	return req;
+}
+
+static void adb_request_free(struct usb_request *req, struct usb_ep *ep)
+{
+	if (req) {
+		kfree(req->buf);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+static inline int _lock(atomic_t *excl)
+{
+	if (atomic_inc_return(excl) == 1) {
+		return 0;
+	} else {
+		atomic_dec(excl);
+		return -1;
+	}
+}
+
+static inline void _unlock(atomic_t *excl)
+{
+	atomic_dec(excl);
+}
+
+/* add a request to the tail of a list */
+void req_put(struct adb_dev *dev, struct list_head *head,
+		struct usb_request *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	list_add_tail(&req->list, head);
+	spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+/* remove a request from the head of a list */
+struct usb_request *req_get(struct adb_dev *dev, struct list_head *head)
+{
+	unsigned long flags;
+	struct usb_request *req;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (list_empty(head)) {
+		req = 0;
+	} else {
+		req = list_first_entry(head, struct usb_request, list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return req;
+}
+
+static void adb_complete_in(struct usb_ep *ep, struct usb_request *req)
+{
+	struct adb_dev *dev = _adb_dev;
+
+	if (req->status != 0)
+		dev->error = 1;
+
+	req_put(dev, &dev->tx_idle, req);
+
+	wake_up(&dev->write_wq);
+}
+
+static void adb_complete_out(struct usb_ep *ep, struct usb_request *req)
+{
+	struct adb_dev *dev = _adb_dev;
+
+	dev->rx_done = 1;
+	if (req->status != 0)
+		dev->error = 1;
+
+	wake_up(&dev->read_wq);
+}
+
+static int __init create_bulk_endpoints(struct adb_dev *dev,
+				struct usb_endpoint_descriptor *in_desc,
+				struct usb_endpoint_descriptor *out_desc)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req;
+	struct usb_ep *ep;
+	int i;
+
+	DBG(cdev, "create_bulk_endpoints dev: %p\n", dev);
+
+	ep = usb_ep_autoconfig(cdev->gadget, in_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_in failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for ep_in got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_in = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, out_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_out failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for adb ep_out got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_out = ep;
+
+	/* now allocate requests for our endpoints */
+	req = adb_request_new(dev->ep_out, BULK_BUFFER_SIZE);
+	if (!req)
+		goto fail;
+	req->complete = adb_complete_out;
+	dev->rx_req = req;
+
+	for (i = 0; i < TX_REQ_MAX; i++) {
+		req = adb_request_new(dev->ep_in, BULK_BUFFER_SIZE);
+		if (!req)
+			goto fail;
+		req->complete = adb_complete_in;
+		req_put(dev, &dev->tx_idle, req);
+	}
+
+	return 0;
+
+fail:
+	printk(KERN_ERR "adb_bind() could not allocate requests\n");
+	return -1;
+}
+
+static ssize_t adb_read(struct file *fp, char __user *buf,
+				size_t count, loff_t *pos)
+{
+	struct adb_dev *dev = fp->private_data;
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req;
+	int r = count, xfer;
+	int ret;
+
+	DBG(cdev, "adb_read(%d)\n", count);
+
+	if (count > BULK_BUFFER_SIZE)
+		return -EINVAL;
+
+	if (_lock(&dev->read_excl))
+		return -EBUSY;
+
+	/* we will block until we're online */
+	while (!(dev->online || dev->error)) {
+		DBG(cdev, "adb_read: waiting for online state\n");
+		ret = wait_event_interruptible(dev->read_wq,
+				(dev->online || dev->error));
+		if (ret < 0) {
+			_unlock(&dev->read_excl);
+			return ret;
+		}
+	}
+	if (dev->error) {
+		r = -EIO;
+		goto done;
+	}
+
+requeue_req:
+	/* queue a request */
+	req = dev->rx_req;
+	req->length = count;
+	dev->rx_done = 0;
+	ret = usb_ep_queue(dev->ep_out, req, GFP_ATOMIC);
+	if (ret < 0) {
+		DBG(cdev, "adb_read: failed to queue req %p (%d)\n", req, ret);
+		r = -EIO;
+		dev->error = 1;
+		goto done;
+	} else {
+		DBG(cdev, "rx %p queue\n", req);
+	}
+
+	/* wait for a request to complete */
+	ret = wait_event_interruptible(dev->read_wq, dev->rx_done);
+	if (ret < 0) {
+		dev->error = 1;
+		r = ret;
+		goto done;
+	}
+	if (!dev->error) {
+		/* If we got a 0-len packet, throw it back and try again. */
+		if (req->actual == 0)
+			goto requeue_req;
+
+		DBG(cdev, "rx %p %d\n", req, req->actual);
+		xfer = (req->actual < count) ? req->actual : count;
+		r = xfer; // Isn't this supposed to be done? -- Ricky26
+		if (copy_to_user(buf, req->buf, xfer))
+			r = -EFAULT;
+	} else
+		r = -EIO;
+
+done:
+	_unlock(&dev->read_excl);
+	DBG(cdev, "adb_read returning %d\n", r);
+	return r;
+}
+
+static ssize_t adb_write(struct file *fp, const char __user *buf,
+				 size_t count, loff_t *pos)
+{
+	struct adb_dev *dev = fp->private_data;
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req = 0;
+	int r = count, xfer;
+	int ret;
+
+	DBG(cdev, "adb_write(%d)\n", count);
+
+	if (_lock(&dev->write_excl))
+		return -EBUSY;
+
+	while (count > 0) {
+		if (dev->error) {
+			DBG(cdev, "adb_write dev->error\n");
+			r = -EIO;
+			break;
+		}
+
+		/* get an idle tx request to use */
+		req = 0;
+		ret = wait_event_interruptible(dev->write_wq,
+			((req = req_get(dev, &dev->tx_idle)) || dev->error));
+
+		if (ret < 0) {
+			r = ret;
+			break;
+		}
+
+		if (req != 0) {
+			if (count > BULK_BUFFER_SIZE)
+				xfer = BULK_BUFFER_SIZE;
+			else
+				xfer = count;
+			if (copy_from_user(req->buf, buf, xfer)) {
+				r = -EFAULT;
+				break;
+			}
+
+			req->length = xfer;
+			ret = usb_ep_queue(dev->ep_in, req, GFP_ATOMIC);
+			if (ret < 0) {
+				DBG(cdev, "adb_write: xfer error %d\n", ret);
+				dev->error = 1;
+				r = -EIO;
+				break;
+			}
+
+			buf += xfer;
+			count -= xfer;
+
+			/* zero this so we don't try to free it on error exit */
+			req = 0;
+		}
+	}
+
+	if (req)
+		req_put(dev, &dev->tx_idle, req);
+
+	_unlock(&dev->write_excl);
+	DBG(cdev, "adb_write returning %d\n", r);
+	return r;
+}
+
+static int adb_open(struct inode *ip, struct file *fp)
+{
+	printk(KERN_INFO "adb_open\n");
+	if (_lock(&_adb_dev->open_excl))
+		return -EBUSY;
+
+	fp->private_data = _adb_dev;
+
+	/* clear the error latch */
+	_adb_dev->error = 0;
+
+	return 0;
+}
+
+static int adb_release(struct inode *ip, struct file *fp)
+{
+	printk(KERN_INFO "adb_release\n");
+	_unlock(&_adb_dev->open_excl);
+	return 0;
+}
+
+/* file operations for ADB device /dev/android_adb */
+static struct file_operations adb_fops = {
+	.owner = THIS_MODULE,
+	.read = adb_read,
+	.write = adb_write,
+	.open = adb_open,
+	.release = adb_release,
+};
+
+static struct miscdevice adb_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = shortname,
+	.fops = &adb_fops,
+};
+
+static int adb_enable_open(struct inode *ip, struct file *fp)
+{
+	if (atomic_inc_return(&adb_enable_excl) != 1) {
+		atomic_dec(&adb_enable_excl);
+		return -EBUSY;
+	}
+
+	printk(KERN_INFO "enabling adb\n");
+	android_enable_function(&_adb_dev->function, 1);
+
+	return 0;
+}
+
+static int adb_enable_release(struct inode *ip, struct file *fp)
+{
+	printk(KERN_INFO "disabling adb\n");
+	android_enable_function(&_adb_dev->function, 0);
+	atomic_dec(&adb_enable_excl);
+	return 0;
+}
+
+static const struct file_operations adb_enable_fops = {
+	.owner =   THIS_MODULE,
+	.open =    adb_enable_open,
+	.release = adb_enable_release,
+};
+
+static struct miscdevice adb_enable_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "android_adb_enable",
+	.fops = &adb_enable_fops,
+};
+
+static int
+adb_function_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct adb_dev	*dev = func_to_dev(f);
+	int			id;
+	int			ret;
+
+	dev->cdev = cdev;
+	DBG(cdev, "adb_function_bind dev: %p\n", dev);
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	adb_interface_desc.bInterfaceNumber = id;
+
+	/* allocate endpoints */
+	ret = create_bulk_endpoints(dev, &adb_fullspeed_in_desc,
+			&adb_fullspeed_out_desc);
+	if (ret)
+		return ret;
+
+	/* support high speed hardware */
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		adb_highspeed_in_desc.bEndpointAddress =
+			adb_fullspeed_in_desc.bEndpointAddress;
+		adb_highspeed_out_desc.bEndpointAddress =
+			adb_fullspeed_out_desc.bEndpointAddress;
+	}
+
+	DBG(cdev, "%s speed %s: IN/%s, OUT/%s\n",
+			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+			f->name, dev->ep_in->name, dev->ep_out->name);
+	return 0;
+}
+
+static void
+adb_function_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct adb_dev	*dev = func_to_dev(f);
+	struct usb_request *req;
+
+	spin_lock_irq(&dev->lock);
+
+	adb_request_free(dev->rx_req, dev->ep_out);
+	while ((req = req_get(dev, &dev->tx_idle)))
+		adb_request_free(req, dev->ep_in);
+
+	dev->online = 0;
+	dev->error = 1;
+	spin_unlock_irq(&dev->lock);
+
+	misc_deregister(&adb_device);
+	misc_deregister(&adb_enable_device);
+	kfree(_adb_dev);
+	_adb_dev = NULL;
+}
+
+static int adb_function_set_alt(struct usb_function *f,
+		unsigned intf, unsigned alt)
+{
+	struct adb_dev	*dev = func_to_dev(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int ret;
+
+	DBG(cdev, "adb_function_set_alt intf: %d alt: %d\n", intf, alt);
+	ret = usb_ep_enable(dev->ep_in,
+			ep_choose(cdev->gadget,
+				&adb_highspeed_in_desc,
+				&adb_fullspeed_in_desc));
+	if (ret)
+		return ret;
+	ret = usb_ep_enable(dev->ep_out,
+			ep_choose(cdev->gadget,
+				&adb_highspeed_out_desc,
+				&adb_fullspeed_out_desc));
+	if (ret) {
+		usb_ep_disable(dev->ep_in);
+		return ret;
+	}
+	dev->online = 1;
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+	return 0;
+}
+
+static void adb_function_disable(struct usb_function *f)
+{
+	struct adb_dev	*dev = func_to_dev(f);
+	struct usb_composite_dev	*cdev = dev->cdev;
+
+	DBG(cdev, "adb_function_disable\n");
+	dev->online = 0;
+	dev->error = 1;
+	usb_ep_disable(dev->ep_in);
+	usb_ep_disable(dev->ep_out);
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+
+	VDBG(cdev, "%s disabled\n", dev->function.name);
+}
+
+static int adb_bind_config(struct usb_configuration *c)
+{
+	struct adb_dev *dev;
+	int ret;
+
+	printk(KERN_INFO "adb_bind_config\n");
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	spin_lock_init(&dev->lock);
+
+	init_waitqueue_head(&dev->read_wq);
+	init_waitqueue_head(&dev->write_wq);
+
+	atomic_set(&dev->open_excl, 0);
+	atomic_set(&dev->read_excl, 0);
+	atomic_set(&dev->write_excl, 0);
+
+	INIT_LIST_HEAD(&dev->tx_idle);
+
+	dev->cdev = c->cdev;
+	dev->function.name = "adb";
+	dev->function.descriptors = fs_adb_descs;
+	dev->function.hs_descriptors = hs_adb_descs;
+	dev->function.bind = adb_function_bind;
+	dev->function.unbind = adb_function_unbind;
+	dev->function.set_alt = adb_function_set_alt;
+	dev->function.disable = adb_function_disable;
+
+	/* start disabled */
+	dev->function.disabled = 1;
+
+	/* _adb_dev must be set before calling usb_gadget_register_driver */
+	_adb_dev = dev;
+
+	ret = misc_register(&adb_device);
+	if (ret)
+		goto err1;
+	ret = misc_register(&adb_enable_device);
+	if (ret)
+		goto err2;
+
+	ret = usb_add_function(c, &dev->function);
+	if (ret)
+		goto err3;
+
+	return 0;
+
+err3:
+	misc_deregister(&adb_enable_device);
+err2:
+	misc_deregister(&adb_device);
+err1:
+	kfree(dev);
+	printk(KERN_ERR "adb gadget driver failed to initialize\n");
+	return ret;
+}
+
+static struct android_usb_function adb_function = {
+	.name = "adb",
+	.bind_config = adb_bind_config,
+};
+
+static int __init init(void)
+{
+	printk(KERN_INFO "f_adb init\n");
+	android_register_function(&adb_function);
+	return 0;
+}
+module_init(init);
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/f_mass_storage.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/f_mass_storage.c
--- linux-2.6.32-orig/drivers/usb/gadget/f_mass_storage.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/f_mass_storage.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,3019 @@
+/*
+ * drivers/usb/gadget/f_mass_storage.c
+ *
+ * Function Driver for USB Mass Storage
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * Based heavily on the file_storage gadget driver in
+ * drivers/usb/gadget/file_storage.c and licensed under the same terms:
+ *
+ * Copyright (C) 2003-2007 Alan Stern
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The names of the above-listed copyright holders may not be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+/* #define DUMP_MSGS */
+
+
+#include <linux/blkdev.h>
+#include <linux/completion.h>
+#include <linux/dcache.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fcntl.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/kref.h>
+#include <linux/kthread.h>
+#include <linux/limits.h>
+#include <linux/rwsem.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/switch.h>
+#include <linux/freezer.h>
+#include <linux/utsname.h>
+#include <linux/wakelock.h>
+#include <linux/platform_device.h>
+
+#include <linux/usb.h>
+#include <linux/usb_usual.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/android_composite.h>
+
+#include "gadget_chips.h"
+
+
+#define BULK_BUFFER_SIZE           4096
+
+/* flush after every 4 meg of writes to avoid excessive block level caching */
+#define MAX_UNFLUSHED_BYTES (4 * 1024 * 1024)
+
+/*-------------------------------------------------------------------------*/
+
+#define DRIVER_NAME		"usb_mass_storage"
+#define MAX_LUNS		8
+
+static const char shortname[] = DRIVER_NAME;
+
+#ifdef DEBUG
+#define LDBG(lun, fmt, args...) \
+	dev_dbg(&(lun)->dev , fmt , ## args)
+#define MDBG(fmt,args...) \
+	printk(KERN_DEBUG DRIVER_NAME ": " fmt , ## args)
+#else
+#define LDBG(lun, fmt, args...) \
+	do { } while (0)
+#define MDBG(fmt,args...) \
+	do { } while (0)
+#undef VERBOSE_DEBUG
+#undef DUMP_MSGS
+#endif /* DEBUG */
+
+#ifdef VERBOSE_DEBUG
+#define VLDBG	LDBG
+#else
+#define VLDBG(lun, fmt, args...) \
+	do { } while (0)
+#endif /* VERBOSE_DEBUG */
+
+#define LERROR(lun, fmt, args...) \
+	dev_err(&(lun)->dev , fmt , ## args)
+#define LWARN(lun, fmt, args...) \
+	dev_warn(&(lun)->dev , fmt , ## args)
+#define LINFO(lun, fmt, args...) \
+	dev_info(&(lun)->dev , fmt , ## args)
+
+#define MINFO(fmt,args...) \
+	printk(KERN_INFO DRIVER_NAME ": " fmt , ## args)
+
+#undef DBG
+#undef VDBG
+#undef ERROR
+#undef WARNING
+#undef INFO
+#define DBG(d, fmt, args...) \
+	dev_dbg(&(d)->cdev->gadget->dev , fmt , ## args)
+#define VDBG(d, fmt, args...) \
+	dev_vdbg(&(d)->cdev->gadget->dev , fmt , ## args)
+#define ERROR(d, fmt, args...) \
+	dev_err(&(d)->cdev->gadget->dev , fmt , ## args)
+#define WARNING(d, fmt, args...) \
+	dev_warn(&(d)->cdev->gadget->dev , fmt , ## args)
+#define INFO(d, fmt, args...) \
+	dev_info(&(d)->cdev->gadget->dev , fmt , ## args)
+
+
+/*-------------------------------------------------------------------------*/
+
+/* Bulk-only data structures */
+
+/* Command Block Wrapper */
+struct bulk_cb_wrap {
+	__le32	Signature;		/* Contains 'USBC' */
+	u32	Tag;			/* Unique per command id */
+	__le32	DataTransferLength;	/* Size of the data */
+	u8	Flags;			/* Direction in bit 7 */
+	u8	Lun;			/* LUN (normally 0) */
+	u8	Length;			/* Of the CDB, <= MAX_COMMAND_SIZE */
+	u8	CDB[16];		/* Command Data Block */
+};
+
+#define USB_BULK_CB_WRAP_LEN	31
+#define USB_BULK_CB_SIG		0x43425355	/* Spells out USBC */
+#define USB_BULK_IN_FLAG	0x80
+
+/* Command Status Wrapper */
+struct bulk_cs_wrap {
+	__le32	Signature;		/* Should = 'USBS' */
+	u32	Tag;			/* Same as original command */
+	__le32	Residue;		/* Amount not transferred */
+	u8	Status;			/* See below */
+};
+
+#define USB_BULK_CS_WRAP_LEN	13
+#define USB_BULK_CS_SIG		0x53425355	/* Spells out 'USBS' */
+#define USB_STATUS_PASS		0
+#define USB_STATUS_FAIL		1
+#define USB_STATUS_PHASE_ERROR	2
+
+/* Bulk-only class specific requests */
+#define USB_BULK_RESET_REQUEST		0xff
+#define USB_BULK_GET_MAX_LUN_REQUEST	0xfe
+
+/* Length of a SCSI Command Data Block */
+#define MAX_COMMAND_SIZE	16
+
+/* SCSI commands that we recognize */
+#define SC_FORMAT_UNIT			0x04
+#define SC_INQUIRY			0x12
+#define SC_MODE_SELECT_6		0x15
+#define SC_MODE_SELECT_10		0x55
+#define SC_MODE_SENSE_6			0x1a
+#define SC_MODE_SENSE_10		0x5a
+#define SC_PREVENT_ALLOW_MEDIUM_REMOVAL	0x1e
+#define SC_READ_6			0x08
+#define SC_READ_10			0x28
+#define SC_READ_12			0xa8
+#define SC_READ_CAPACITY		0x25
+#define SC_READ_FORMAT_CAPACITIES	0x23
+#define SC_RELEASE			0x17
+#define SC_REQUEST_SENSE		0x03
+#define SC_RESERVE			0x16
+#define SC_SEND_DIAGNOSTIC		0x1d
+#define SC_START_STOP_UNIT		0x1b
+#define SC_SYNCHRONIZE_CACHE		0x35
+#define SC_TEST_UNIT_READY		0x00
+#define SC_VERIFY			0x2f
+#define SC_WRITE_6			0x0a
+#define SC_WRITE_10			0x2a
+#define SC_WRITE_12			0xaa
+
+/* SCSI Sense Key/Additional Sense Code/ASC Qualifier values */
+#define SS_NO_SENSE				0
+#define SS_COMMUNICATION_FAILURE		0x040800
+#define SS_INVALID_COMMAND			0x052000
+#define SS_INVALID_FIELD_IN_CDB			0x052400
+#define SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE	0x052100
+#define SS_LOGICAL_UNIT_NOT_SUPPORTED		0x052500
+#define SS_MEDIUM_NOT_PRESENT			0x023a00
+#define SS_MEDIUM_REMOVAL_PREVENTED		0x055302
+#define SS_NOT_READY_TO_READY_TRANSITION	0x062800
+#define SS_RESET_OCCURRED			0x062900
+#define SS_SAVING_PARAMETERS_NOT_SUPPORTED	0x053900
+#define SS_UNRECOVERED_READ_ERROR		0x031100
+#define SS_WRITE_ERROR				0x030c02
+#define SS_WRITE_PROTECTED			0x072700
+
+#define SK(x)		((u8) ((x) >> 16))	/* Sense Key byte, etc. */
+#define ASC(x)		((u8) ((x) >> 8))
+#define ASCQ(x)		((u8) (x))
+
+
+/*-------------------------------------------------------------------------*/
+
+struct lun {
+	struct file	*filp;
+	loff_t		file_length;
+	loff_t		num_sectors;
+	unsigned int unflushed_bytes;
+
+	unsigned int	ro : 1;
+	unsigned int	prevent_medium_removal : 1;
+	unsigned int	registered : 1;
+	unsigned int	info_valid : 1;
+
+	u32		sense_data;
+	u32		sense_data_info;
+	u32		unit_attention_data;
+
+	struct device	dev;
+};
+
+#define backing_file_is_open(curlun)	((curlun)->filp != NULL)
+
+
+static struct lun *dev_to_lun(struct device *dev)
+{
+	return container_of(dev, struct lun, dev);
+}
+
+/* Big enough to hold our biggest descriptor */
+#define EP0_BUFSIZE	256
+
+/* Number of buffers we will use.  2 is enough for double-buffering */
+#define NUM_BUFFERS	2
+
+enum fsg_buffer_state {
+	BUF_STATE_EMPTY = 0,
+	BUF_STATE_FULL,
+	BUF_STATE_BUSY
+};
+
+struct fsg_buffhd {
+	void				*buf;
+	enum fsg_buffer_state		state;
+	struct fsg_buffhd		*next;
+
+	/* The NetChip 2280 is faster, and handles some protocol faults
+	 * better, if we don't submit any short bulk-out read requests.
+	 * So we will record the intended request length here. */
+	unsigned int			bulk_out_intended_length;
+
+	struct usb_request		*inreq;
+	int				inreq_busy;
+	struct usb_request		*outreq;
+	int				outreq_busy;
+};
+
+enum fsg_state {
+	/* This one isn't used anywhere */
+	FSG_STATE_COMMAND_PHASE = -10,
+
+	FSG_STATE_DATA_PHASE,
+	FSG_STATE_STATUS_PHASE,
+
+	FSG_STATE_IDLE = 0,
+	FSG_STATE_ABORT_BULK_OUT,
+	FSG_STATE_RESET,
+	FSG_STATE_CONFIG_CHANGE,
+	FSG_STATE_EXIT,
+	FSG_STATE_TERMINATED
+};
+
+enum data_direction {
+	DATA_DIR_UNKNOWN = 0,
+	DATA_DIR_FROM_HOST,
+	DATA_DIR_TO_HOST,
+	DATA_DIR_NONE
+};
+
+struct fsg_dev {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+
+	/* optional "usb_mass_storage" platform device */
+	struct platform_device *pdev;
+
+	/* lock protects: state and all the req_busy's */
+	spinlock_t		lock;
+
+	/* filesem protects: backing files in use */
+	struct rw_semaphore	filesem;
+
+	/* reference counting: wait until all LUNs are released */
+	struct kref		ref;
+
+	unsigned int		bulk_out_maxpacket;
+	enum fsg_state		state;		/* For exception handling */
+
+	u8			config, new_config;
+
+	unsigned int		running : 1;
+	unsigned int		bulk_in_enabled : 1;
+	unsigned int		bulk_out_enabled : 1;
+	unsigned int		phase_error : 1;
+	unsigned int		short_packet_received : 1;
+	unsigned int		bad_lun_okay : 1;
+
+	unsigned long		atomic_bitflags;
+#define REGISTERED		0
+#define CLEAR_BULK_HALTS	1
+#define SUSPENDED		2
+
+	struct usb_ep		*bulk_in;
+	struct usb_ep		*bulk_out;
+
+	struct fsg_buffhd	*next_buffhd_to_fill;
+	struct fsg_buffhd	*next_buffhd_to_drain;
+	struct fsg_buffhd	buffhds[NUM_BUFFERS];
+
+	int			thread_wakeup_needed;
+	struct completion	thread_notifier;
+	struct task_struct	*thread_task;
+
+	int			cmnd_size;
+	u8			cmnd[MAX_COMMAND_SIZE];
+	enum data_direction	data_dir;
+	u32			data_size;
+	u32			data_size_from_cmnd;
+	u32			tag;
+	unsigned int		lun;
+	u32			residue;
+	u32			usb_amount_left;
+
+	unsigned int		nluns;
+	struct lun		*luns;
+	struct lun		*curlun;
+
+	u32				buf_size;
+	const char		*vendor;
+	const char		*product;
+	int				release;
+
+	struct switch_dev sdev;
+
+	struct wake_lock wake_lock;
+};
+
+static inline struct fsg_dev *func_to_dev(struct usb_function *f)
+{
+	return container_of(f, struct fsg_dev, function);
+}
+
+static int exception_in_progress(struct fsg_dev *fsg)
+{
+	return (fsg->state > FSG_STATE_IDLE);
+}
+
+/* Make bulk-out requests be divisible by the maxpacket size */
+static void set_bulk_out_req_length(struct fsg_dev *fsg,
+		struct fsg_buffhd *bh, unsigned int length)
+{
+	unsigned int	rem;
+
+	bh->bulk_out_intended_length = length;
+	rem = length % fsg->bulk_out_maxpacket;
+	if (rem > 0)
+		length += fsg->bulk_out_maxpacket - rem;
+	bh->outreq->length = length;
+}
+
+static struct fsg_dev			*the_fsg;
+
+static void	close_backing_file(struct fsg_dev *fsg, struct lun *curlun);
+static void	close_all_backing_files(struct fsg_dev *fsg);
+static int fsync_sub(struct lun *curlun);
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef DUMP_MSGS
+
+static void dump_msg(struct fsg_dev *fsg, const char *label,
+		const u8 *buf, unsigned int length)
+{
+	if (length < 512) {
+		DBG(fsg, "%s, length %u:\n", label, length);
+		print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET,
+				16, 1, buf, length, 0);
+	}
+}
+
+static void dump_cdb(struct fsg_dev *fsg)
+{}
+
+#else
+
+static void dump_msg(struct fsg_dev *fsg, const char *label,
+		const u8 *buf, unsigned int length)
+{}
+
+#ifdef VERBOSE_DEBUG
+
+static void dump_cdb(struct fsg_dev *fsg)
+{
+	print_hex_dump(KERN_DEBUG, "SCSI CDB: ", DUMP_PREFIX_NONE,
+			16, 1, fsg->cmnd, fsg->cmnd_size, 0);
+}
+
+#else
+
+static void dump_cdb(struct fsg_dev *fsg)
+{}
+
+#endif /* VERBOSE_DEBUG */
+#endif /* DUMP_MSGS */
+
+
+/*-------------------------------------------------------------------------*/
+
+/* Routines for unaligned data access */
+
+static u16 get_be16(u8 *buf)
+{
+	return ((u16) buf[0] << 8) | ((u16) buf[1]);
+}
+
+static u32 get_be32(u8 *buf)
+{
+	return ((u32) buf[0] << 24) | ((u32) buf[1] << 16) |
+			((u32) buf[2] << 8) | ((u32) buf[3]);
+}
+
+static void put_be16(u8 *buf, u16 val)
+{
+	buf[0] = val >> 8;
+	buf[1] = val;
+}
+
+static void put_be32(u8 *buf, u32 val)
+{
+	buf[0] = val >> 24;
+	buf[1] = val >> 16;
+	buf[2] = val >> 8;
+	buf[3] = val & 0xff;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * DESCRIPTORS ... most are static, but strings and (full) configuration
+ * descriptors are built on demand.  Also the (static) config and interface
+ * descriptors are adjusted during fsg_bind().
+ */
+
+/* There is only one interface. */
+
+static struct usb_interface_descriptor
+intf_desc = {
+	.bLength =		sizeof intf_desc,
+	.bDescriptorType =	USB_DT_INTERFACE,
+
+	.bNumEndpoints =	2,		/* Adjusted during fsg_bind() */
+	.bInterfaceClass =	USB_CLASS_MASS_STORAGE,
+	.bInterfaceSubClass =	US_SC_SCSI,
+	.bInterfaceProtocol =	US_PR_BULK,
+};
+
+/* Three full-speed endpoint descriptors: bulk-in, bulk-out,
+ * and interrupt-in. */
+
+static struct usb_endpoint_descriptor
+fs_bulk_in_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+
+	.bEndpointAddress =	USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	/* wMaxPacketSize set by autoconfiguration */
+};
+
+static struct usb_endpoint_descriptor
+fs_bulk_out_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+
+	.bEndpointAddress =	USB_DIR_OUT,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	/* wMaxPacketSize set by autoconfiguration */
+};
+
+static struct usb_descriptor_header *fs_function[] = {
+	(struct usb_descriptor_header *) &intf_desc,
+	(struct usb_descriptor_header *) &fs_bulk_in_desc,
+	(struct usb_descriptor_header *) &fs_bulk_out_desc,
+	NULL,
+};
+#define FS_FUNCTION_PRE_EP_ENTRIES	2
+
+
+static struct usb_endpoint_descriptor
+hs_bulk_in_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+
+	/* bEndpointAddress copied from fs_bulk_in_desc during fsg_bind() */
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor
+hs_bulk_out_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+
+	/* bEndpointAddress copied from fs_bulk_out_desc during fsg_bind() */
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16(512),
+	.bInterval =		1,	/* NAK every 1 uframe */
+};
+
+
+static struct usb_descriptor_header *hs_function[] = {
+	(struct usb_descriptor_header *) &intf_desc,
+	(struct usb_descriptor_header *) &hs_bulk_in_desc,
+	(struct usb_descriptor_header *) &hs_bulk_out_desc,
+	NULL,
+};
+
+/* Maxpacket and other transfer characteristics vary by speed. */
+static struct usb_endpoint_descriptor *
+ep_desc(struct usb_gadget *g, struct usb_endpoint_descriptor *fs,
+		struct usb_endpoint_descriptor *hs)
+{
+	if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
+		return hs;
+	return fs;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* These routines may be called in process context or in_irq */
+
+/* Caller must hold fsg->lock */
+static void wakeup_thread(struct fsg_dev *fsg)
+{
+	/* Tell the main thread that something has happened */
+	fsg->thread_wakeup_needed = 1;
+	if (fsg->thread_task)
+		wake_up_process(fsg->thread_task);
+}
+
+
+static void raise_exception(struct fsg_dev *fsg, enum fsg_state new_state)
+{
+	unsigned long		flags;
+
+	DBG(fsg, "raise_exception %d\n", (int)new_state);
+	/* Do nothing if a higher-priority exception is already in progress.
+	 * If a lower-or-equal priority exception is in progress, preempt it
+	 * and notify the main thread by sending it a signal. */
+	spin_lock_irqsave(&fsg->lock, flags);
+	if (fsg->state <= new_state) {
+		fsg->state = new_state;
+		if (fsg->thread_task)
+			send_sig_info(SIGUSR1, SEND_SIG_FORCED,
+					fsg->thread_task);
+	}
+	spin_unlock_irqrestore(&fsg->lock, flags);
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* Bulk and interrupt endpoint completion handlers.
+ * These always run in_irq. */
+
+static void bulk_in_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct fsg_dev		*fsg = ep->driver_data;
+	struct fsg_buffhd	*bh = req->context;
+	unsigned long		flags;
+
+	if (req->status || req->actual != req->length)
+		DBG(fsg, "%s --> %d, %u/%u\n", __func__,
+				req->status, req->actual, req->length);
+
+	/* Hold the lock while we update the request and buffer states */
+	smp_wmb();
+	spin_lock_irqsave(&fsg->lock, flags);
+	bh->inreq_busy = 0;
+	bh->state = BUF_STATE_EMPTY;
+	wakeup_thread(fsg);
+	spin_unlock_irqrestore(&fsg->lock, flags);
+}
+
+static void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct fsg_dev		*fsg = ep->driver_data;
+	struct fsg_buffhd	*bh = req->context;
+	unsigned long		flags;
+
+	dump_msg(fsg, "bulk-out", req->buf, req->actual);
+	if (req->status || req->actual != bh->bulk_out_intended_length)
+		DBG(fsg, "%s --> %d, %u/%u\n", __func__,
+				req->status, req->actual,
+				bh->bulk_out_intended_length);
+
+	/* Hold the lock while we update the request and buffer states */
+	smp_wmb();
+	spin_lock_irqsave(&fsg->lock, flags);
+	bh->outreq_busy = 0;
+	bh->state = BUF_STATE_FULL;
+	wakeup_thread(fsg);
+	spin_unlock_irqrestore(&fsg->lock, flags);
+}
+
+static int fsg_function_setup(struct usb_function *f,
+					const struct usb_ctrlrequest *ctrl)
+{
+	struct fsg_dev	*fsg = func_to_dev(f);
+	struct usb_composite_dev *cdev = fsg->cdev;
+	int			value = -EOPNOTSUPP;
+	u16			w_index = le16_to_cpu(ctrl->wIndex);
+	u16			w_value = le16_to_cpu(ctrl->wValue);
+	u16			w_length = le16_to_cpu(ctrl->wLength);
+
+	DBG(fsg, "fsg_function_setup\n");
+	/* Handle Bulk-only class-specific requests */
+	if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS) {
+	DBG(fsg, "USB_TYPE_CLASS\n");
+		switch (ctrl->bRequest) {
+		case USB_BULK_RESET_REQUEST:
+			if (ctrl->bRequestType != (USB_DIR_OUT |
+					USB_TYPE_CLASS | USB_RECIP_INTERFACE))
+				break;
+			if (w_index != 0 || w_value != 0) {
+				value = -EDOM;
+				break;
+			}
+
+			/* Raise an exception to stop the current operation
+			 * and reinitialize our state. */
+			DBG(fsg, "bulk reset request\n");
+			raise_exception(fsg, FSG_STATE_RESET);
+			value = 0;
+			break;
+
+		case USB_BULK_GET_MAX_LUN_REQUEST:
+			if (ctrl->bRequestType != (USB_DIR_IN |
+					USB_TYPE_CLASS | USB_RECIP_INTERFACE))
+				break;
+			if (w_index != 0 || w_value != 0) {
+				value = -EDOM;
+				break;
+			}
+			VDBG(fsg, "get max LUN\n");
+			*(u8 *)cdev->req->buf = fsg->nluns - 1;
+			value = 1;
+			break;
+		}
+	}
+
+		/* respond with data transfer or status phase? */
+		if (value >= 0) {
+			int rc;
+			cdev->req->zero = value < w_length;
+			cdev->req->length = value;
+			rc = usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);
+			if (rc < 0)
+				printk("%s setup response queue error\n", __func__);
+		}
+
+	if (value == -EOPNOTSUPP)
+		VDBG(fsg,
+			"unknown class-specific control req "
+			"%02x.%02x v%04x i%04x l%u\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			le16_to_cpu(ctrl->wValue), w_index, w_length);
+	return value;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* All the following routines run in process context */
+
+
+/* Use this for bulk or interrupt transfers, not ep0 */
+static void start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,
+		struct usb_request *req, int *pbusy,
+		enum fsg_buffer_state *state)
+{
+	int	rc;
+	unsigned long		flags;
+
+	DBG(fsg, "start_transfer req: %p, req->buf: %p\n", req, req->buf);
+	if (ep == fsg->bulk_in)
+		dump_msg(fsg, "bulk-in", req->buf, req->length);
+
+	spin_lock_irqsave(&fsg->lock, flags);
+	*pbusy = 1;
+	*state = BUF_STATE_BUSY;
+	spin_unlock_irqrestore(&fsg->lock, flags);
+	rc = usb_ep_queue(ep, req, GFP_KERNEL);
+	if (rc != 0) {
+		*pbusy = 0;
+		*state = BUF_STATE_EMPTY;
+
+		/* We can't do much more than wait for a reset */
+
+		/* Note: currently the net2280 driver fails zero-length
+		 * submissions if DMA is enabled. */
+		if (rc != -ESHUTDOWN && !(rc == -EOPNOTSUPP &&
+						req->length == 0))
+			WARN(fsg, "error in submission: %s --> %d\n",
+				(ep == fsg->bulk_in ? "bulk-in" : "bulk-out"),
+				rc);
+	}
+}
+
+
+static int sleep_thread(struct fsg_dev *fsg)
+{
+	int	rc = 0;
+
+	/* Wait until a signal arrives or we are woken up */
+	for (;;) {
+		try_to_freeze();
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (signal_pending(current)) {
+			rc = -EINTR;
+			break;
+		}
+		if (fsg->thread_wakeup_needed)
+			break;
+		schedule();
+	}
+	__set_current_state(TASK_RUNNING);
+	fsg->thread_wakeup_needed = 0;
+	return rc;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int do_read(struct fsg_dev *fsg)
+{
+	struct lun		*curlun = fsg->curlun;
+	u32			lba;
+	struct fsg_buffhd	*bh;
+	int			rc;
+	u32			amount_left;
+	loff_t			file_offset, file_offset_tmp;
+	unsigned int		amount;
+	unsigned int		partial_page;
+	ssize_t			nread;
+
+	/* Get the starting Logical Block Address and check that it's
+	 * not too big */
+	if (fsg->cmnd[0] == SC_READ_6)
+		lba = (fsg->cmnd[1] << 16) | get_be16(&fsg->cmnd[2]);
+	else {
+		lba = get_be32(&fsg->cmnd[2]);
+
+		/* We allow DPO (Disable Page Out = don't save data in the
+		 * cache) and FUA (Force Unit Access = don't read from the
+		 * cache), but we don't implement them. */
+		if ((fsg->cmnd[1] & ~0x18) != 0) {
+			curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+			return -EINVAL;
+		}
+	}
+	if (lba >= curlun->num_sectors) {
+		curlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+		return -EINVAL;
+	}
+	file_offset = ((loff_t) lba) << 9;
+
+	/* Carry out the file reads */
+	amount_left = fsg->data_size_from_cmnd;
+	if (unlikely(amount_left == 0))
+		return -EIO;		/* No default reply */
+
+	for (;;) {
+
+		/* Figure out how much we need to read:
+		 * Try to read the remaining amount.
+		 * But don't read more than the buffer size.
+		 * And don't try to read past the end of the file.
+		 * Finally, if we're not at a page boundary, don't read past
+		 *	the next page.
+		 * If this means reading 0 then we were asked to read past
+		 *	the end of file. */
+		amount = min((unsigned int) amount_left,
+				(unsigned int)fsg->buf_size);
+		amount = min((loff_t) amount,
+				curlun->file_length - file_offset);
+		partial_page = file_offset & (PAGE_CACHE_SIZE - 1);
+		if (partial_page > 0)
+			amount = min(amount, (unsigned int) PAGE_CACHE_SIZE -
+					partial_page);
+
+		/* Wait for the next buffer to become available */
+		bh = fsg->next_buffhd_to_fill;
+		while (bh->state != BUF_STATE_EMPTY) {
+			rc = sleep_thread(fsg);
+			if (rc)
+				return rc;
+		}
+
+		/* If we were asked to read past the end of file,
+		 * end with an empty buffer. */
+		if (amount == 0) {
+			curlun->sense_data =
+					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+			curlun->sense_data_info = file_offset >> 9;
+			curlun->info_valid = 1;
+			bh->inreq->length = 0;
+			bh->state = BUF_STATE_FULL;
+			break;
+		}
+
+		/* Perform the read */
+		file_offset_tmp = file_offset;
+		nread = vfs_read(curlun->filp,
+				(char __user *) bh->buf,
+				amount, &file_offset_tmp);
+		VLDBG(curlun, "file read %u @ %llu -> %d\n", amount,
+				(unsigned long long) file_offset,
+				(int) nread);
+		if (signal_pending(current))
+			return -EINTR;
+
+		if (nread < 0) {
+			LDBG(curlun, "error in file read: %d\n",
+					(int) nread);
+			nread = 0;
+		} else if (nread < amount) {
+			LDBG(curlun, "partial file read: %d/%u\n",
+					(int) nread, amount);
+			nread -= (nread & 511);	/* Round down to a block */
+		}
+		file_offset  += nread;
+		amount_left  -= nread;
+		fsg->residue -= nread;
+		bh->inreq->length = nread;
+		bh->state = BUF_STATE_FULL;
+
+		/* If an error occurred, report it and its position */
+		if (nread < amount) {
+			curlun->sense_data = SS_UNRECOVERED_READ_ERROR;
+			curlun->sense_data_info = file_offset >> 9;
+			curlun->info_valid = 1;
+			break;
+		}
+
+		if (amount_left == 0)
+			break;		/* No more left to read */
+
+		/* Send this buffer and go read some more */
+		start_transfer(fsg, fsg->bulk_in, bh->inreq,
+				&bh->inreq_busy, &bh->state);
+		fsg->next_buffhd_to_fill = bh->next;
+	}
+
+	return -EIO;		/* No default reply */
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int do_write(struct fsg_dev *fsg)
+{
+	struct lun		*curlun = fsg->curlun;
+	u32			lba;
+	struct fsg_buffhd	*bh;
+	int			get_some_more;
+	u32			amount_left_to_req, amount_left_to_write;
+	loff_t			usb_offset, file_offset, file_offset_tmp;
+	unsigned int		amount;
+	unsigned int		partial_page;
+	ssize_t			nwritten;
+	int			rc;
+
+	if (curlun->ro) {
+		curlun->sense_data = SS_WRITE_PROTECTED;
+		return -EINVAL;
+	}
+	curlun->filp->f_flags &= ~O_SYNC;	/* Default is not to wait */
+
+	/* Get the starting Logical Block Address and check that it's
+	 * not too big */
+	if (fsg->cmnd[0] == SC_WRITE_6)
+		lba = (fsg->cmnd[1] << 16) | get_be16(&fsg->cmnd[2]);
+	else {
+		lba = get_be32(&fsg->cmnd[2]);
+
+		/* We allow DPO (Disable Page Out = don't save data in the
+		 * cache) and FUA (Force Unit Access = write directly to the
+		 * medium).  We don't implement DPO; we implement FUA by
+		 * performing synchronous output. */
+		if ((fsg->cmnd[1] & ~0x18) != 0) {
+			curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+			return -EINVAL;
+		}
+		if (fsg->cmnd[1] & 0x08)	/* FUA */
+			curlun->filp->f_flags |= O_SYNC;
+	}
+	if (lba >= curlun->num_sectors) {
+		curlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+		return -EINVAL;
+	}
+
+	/* Carry out the file writes */
+	get_some_more = 1;
+	file_offset = usb_offset = ((loff_t) lba) << 9;
+	amount_left_to_req = amount_left_to_write = fsg->data_size_from_cmnd;
+
+	while (amount_left_to_write > 0) {
+
+		/* Queue a request for more data from the host */
+		bh = fsg->next_buffhd_to_fill;
+		if (bh->state == BUF_STATE_EMPTY && get_some_more) {
+
+			/* Figure out how much we want to get:
+			 * Try to get the remaining amount.
+			 * But don't get more than the buffer size.
+			 * And don't try to go past the end of the file.
+			 * If we're not at a page boundary,
+			 *	don't go past the next page.
+			 * If this means getting 0, then we were asked
+			 *	to write past the end of file.
+			 * Finally, round down to a block boundary. */
+			amount = min(amount_left_to_req, (u32)fsg->buf_size);
+			amount = min((loff_t) amount, curlun->file_length -
+					usb_offset);
+			partial_page = usb_offset & (PAGE_CACHE_SIZE - 1);
+			if (partial_page > 0)
+				amount = min(amount,
+	(unsigned int) PAGE_CACHE_SIZE - partial_page);
+
+			if (amount == 0) {
+				get_some_more = 0;
+				curlun->sense_data =
+					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+				curlun->sense_data_info = usb_offset >> 9;
+				curlun->info_valid = 1;
+				continue;
+			}
+			amount -= (amount & 511);
+			if (amount == 0) {
+
+				/* Why were we were asked to transfer a
+				 * partial block? */
+				get_some_more = 0;
+				continue;
+			}
+
+			/* Get the next buffer */
+			usb_offset += amount;
+			fsg->usb_amount_left -= amount;
+			amount_left_to_req -= amount;
+			if (amount_left_to_req == 0)
+				get_some_more = 0;
+
+			/* amount is always divisible by 512, hence by
+			 * the bulk-out maxpacket size */
+			bh->outreq->length = bh->bulk_out_intended_length =
+					amount;
+			start_transfer(fsg, fsg->bulk_out, bh->outreq,
+					&bh->outreq_busy, &bh->state);
+			fsg->next_buffhd_to_fill = bh->next;
+			continue;
+		}
+
+		/* Write the received data to the backing file */
+		bh = fsg->next_buffhd_to_drain;
+		if (bh->state == BUF_STATE_EMPTY && !get_some_more)
+			break;			/* We stopped early */
+		if (bh->state == BUF_STATE_FULL) {
+			smp_rmb();
+			fsg->next_buffhd_to_drain = bh->next;
+			bh->state = BUF_STATE_EMPTY;
+
+			/* Did something go wrong with the transfer? */
+			if (bh->outreq->status != 0) {
+				curlun->sense_data = SS_COMMUNICATION_FAILURE;
+				curlun->sense_data_info = file_offset >> 9;
+				curlun->info_valid = 1;
+				break;
+			}
+
+			amount = bh->outreq->actual;
+			if (curlun->file_length - file_offset < amount) {
+				LERROR(curlun,
+	"write %u @ %llu beyond end %llu\n",
+	amount, (unsigned long long) file_offset,
+	(unsigned long long) curlun->file_length);
+				amount = curlun->file_length - file_offset;
+			}
+
+			/* Perform the write */
+			file_offset_tmp = file_offset;
+			nwritten = vfs_write(curlun->filp,
+					(char __user *) bh->buf,
+					amount, &file_offset_tmp);
+			VLDBG(curlun, "file write %u @ %llu -> %d\n", amount,
+					(unsigned long long) file_offset,
+					(int) nwritten);
+			if (signal_pending(current))
+				return -EINTR;		/* Interrupted! */
+
+			if (nwritten < 0) {
+				LDBG(curlun, "error in file write: %d\n",
+						(int) nwritten);
+				nwritten = 0;
+			} else if (nwritten < amount) {
+				LDBG(curlun, "partial file write: %d/%u\n",
+						(int) nwritten, amount);
+				nwritten -= (nwritten & 511);
+						/* Round down to a block */
+			}
+			file_offset += nwritten;
+			amount_left_to_write -= nwritten;
+			fsg->residue -= nwritten;
+
+#ifdef MAX_UNFLUSHED_BYTES
+			curlun->unflushed_bytes += nwritten;
+			if (curlun->unflushed_bytes >= MAX_UNFLUSHED_BYTES) {
+				fsync_sub(curlun);
+				curlun->unflushed_bytes = 0;
+			}
+#endif
+			/* If an error occurred, report it and its position */
+			if (nwritten < amount) {
+				curlun->sense_data = SS_WRITE_ERROR;
+				curlun->sense_data_info = file_offset >> 9;
+				curlun->info_valid = 1;
+				break;
+			}
+
+			/* Did the host decide to stop early? */
+			if (bh->outreq->actual != bh->outreq->length) {
+				fsg->short_packet_received = 1;
+				break;
+			}
+			continue;
+		}
+
+		/* Wait for something to happen */
+		rc = sleep_thread(fsg);
+		if (rc)
+			return rc;
+	}
+
+	return -EIO;		/* No default reply */
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* Sync the file data, don't bother with the metadata.
+ * The caller must own fsg->filesem.
+ * This code was copied from fs/buffer.c:sys_fdatasync(). */
+static int fsync_sub(struct lun *curlun)
+{
+	struct file	*filp = curlun->filp;
+	struct inode	*inode;
+	int		rc, err;
+
+	if (curlun->ro || !filp)
+		return 0;
+	if (!filp->f_op->fsync)
+		return -EINVAL;
+
+	inode = filp->f_path.dentry->d_inode;
+	mutex_lock(&inode->i_mutex);
+	rc = filemap_fdatawrite(inode->i_mapping);
+	err = filp->f_op->fsync(filp, filp->f_path.dentry, 1);
+	if (!rc)
+		rc = err;
+	err = filemap_fdatawait(inode->i_mapping);
+	if (!rc)
+		rc = err;
+	mutex_unlock(&inode->i_mutex);
+	VLDBG(curlun, "fdatasync -> %d\n", rc);
+	return rc;
+}
+
+static void fsync_all(struct fsg_dev *fsg)
+{
+	int	i;
+
+	for (i = 0; i < fsg->nluns; ++i)
+		fsync_sub(&fsg->luns[i]);
+}
+
+static int do_synchronize_cache(struct fsg_dev *fsg)
+{
+	struct lun	*curlun = fsg->curlun;
+	int		rc;
+
+	/* We ignore the requested LBA and write out all file's
+	 * dirty data buffers. */
+	rc = fsync_sub(curlun);
+	if (rc)
+		curlun->sense_data = SS_WRITE_ERROR;
+	return 0;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static void invalidate_sub(struct lun *curlun)
+{
+	struct file	*filp = curlun->filp;
+	struct inode	*inode = filp->f_path.dentry->d_inode;
+	unsigned long	rc;
+
+	rc = invalidate_mapping_pages(inode->i_mapping, 0, -1);
+	VLDBG(curlun, "invalidate_inode_pages -> %ld\n", rc);
+}
+
+static int do_verify(struct fsg_dev *fsg)
+{
+	struct lun		*curlun = fsg->curlun;
+	u32			lba;
+	u32			verification_length;
+	struct fsg_buffhd	*bh = fsg->next_buffhd_to_fill;
+	loff_t			file_offset, file_offset_tmp;
+	u32			amount_left;
+	unsigned int		amount;
+	ssize_t			nread;
+
+	/* Get the starting Logical Block Address and check that it's
+	 * not too big */
+	lba = get_be32(&fsg->cmnd[2]);
+	if (lba >= curlun->num_sectors) {
+		curlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+		return -EINVAL;
+	}
+
+	/* We allow DPO (Disable Page Out = don't save data in the
+	 * cache) but we don't implement it. */
+	if ((fsg->cmnd[1] & ~0x10) != 0) {
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+
+	verification_length = get_be16(&fsg->cmnd[7]);
+	if (unlikely(verification_length == 0))
+		return -EIO;		/* No default reply */
+
+	/* Prepare to carry out the file verify */
+	amount_left = verification_length << 9;
+	file_offset = ((loff_t) lba) << 9;
+
+	/* Write out all the dirty buffers before invalidating them */
+	fsync_sub(curlun);
+	if (signal_pending(current))
+		return -EINTR;
+
+	invalidate_sub(curlun);
+	if (signal_pending(current))
+		return -EINTR;
+
+	/* Just try to read the requested blocks */
+	while (amount_left > 0) {
+
+		/* Figure out how much we need to read:
+		 * Try to read the remaining amount, but not more than
+		 * the buffer size.
+		 * And don't try to read past the end of the file.
+		 * If this means reading 0 then we were asked to read
+		 * past the end of file. */
+		amount = min((unsigned int) amount_left,
+				(unsigned int)fsg->buf_size);
+		amount = min((loff_t) amount,
+				curlun->file_length - file_offset);
+		if (amount == 0) {
+			curlun->sense_data =
+					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+			curlun->sense_data_info = file_offset >> 9;
+			curlun->info_valid = 1;
+			break;
+		}
+
+		/* Perform the read */
+		file_offset_tmp = file_offset;
+		nread = vfs_read(curlun->filp,
+				(char __user *) bh->buf,
+				amount, &file_offset_tmp);
+		VLDBG(curlun, "file read %u @ %llu -> %d\n", amount,
+				(unsigned long long) file_offset,
+				(int) nread);
+		if (signal_pending(current))
+			return -EINTR;
+
+		if (nread < 0) {
+			LDBG(curlun, "error in file verify: %d\n",
+					(int) nread);
+			nread = 0;
+		} else if (nread < amount) {
+			LDBG(curlun, "partial file verify: %d/%u\n",
+					(int) nread, amount);
+			nread -= (nread & 511);	/* Round down to a sector */
+		}
+		if (nread == 0) {
+			curlun->sense_data = SS_UNRECOVERED_READ_ERROR;
+			curlun->sense_data_info = file_offset >> 9;
+			curlun->info_valid = 1;
+			break;
+		}
+		file_offset += nread;
+		amount_left -= nread;
+	}
+	return 0;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int do_inquiry(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	u8	*buf = (u8 *) bh->buf;
+
+	if (!fsg->curlun) {		/* Unsupported LUNs are okay */
+		fsg->bad_lun_okay = 1;
+		memset(buf, 0, 36);
+		buf[0] = 0x7f;		/* Unsupported, no device-type */
+		return 36;
+	}
+
+	memset(buf, 0, 8);	/* Non-removable, direct-access device */
+
+	buf[1] = 0x80;	/* set removable bit */
+	buf[2] = 2;		/* ANSI SCSI level 2 */
+	buf[3] = 2;		/* SCSI-2 INQUIRY data format */
+	buf[4] = 31;		/* Additional length */
+				/* No special options */
+	sprintf(buf + 8, "%-8s%-16s%04x", fsg->vendor,
+			fsg->product, fsg->release);
+	return 36;
+}
+
+
+static int do_request_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun	*curlun = fsg->curlun;
+	u8		*buf = (u8 *) bh->buf;
+	u32		sd, sdinfo;
+	int		valid;
+
+	/*
+	 * From the SCSI-2 spec., section 7.9 (Unit attention condition):
+	 *
+	 * If a REQUEST SENSE command is received from an initiator
+	 * with a pending unit attention condition (before the target
+	 * generates the contingent allegiance condition), then the
+	 * target shall either:
+	 *   a) report any pending sense data and preserve the unit
+	 *	attention condition on the logical unit, or,
+	 *   b) report the unit attention condition, may discard any
+	 *	pending sense data, and clear the unit attention
+	 *	condition on the logical unit for that initiator.
+	 *
+	 * FSG normally uses option a); enable this code to use option b).
+	 */
+#if 0
+	if (curlun && curlun->unit_attention_data != SS_NO_SENSE) {
+		curlun->sense_data = curlun->unit_attention_data;
+		curlun->unit_attention_data = SS_NO_SENSE;
+	}
+#endif
+
+	if (!curlun) {		/* Unsupported LUNs are okay */
+		fsg->bad_lun_okay = 1;
+		sd = SS_LOGICAL_UNIT_NOT_SUPPORTED;
+		sdinfo = 0;
+		valid = 0;
+	} else {
+		sd = curlun->sense_data;
+		sdinfo = curlun->sense_data_info;
+		valid = curlun->info_valid << 7;
+		curlun->sense_data = SS_NO_SENSE;
+		curlun->sense_data_info = 0;
+		curlun->info_valid = 0;
+	}
+
+	memset(buf, 0, 18);
+	buf[0] = valid | 0x70;			/* Valid, current error */
+	buf[2] = SK(sd);
+	put_be32(&buf[3], sdinfo);		/* Sense information */
+	buf[7] = 18 - 8;			/* Additional sense length */
+	buf[12] = ASC(sd);
+	buf[13] = ASCQ(sd);
+	return 18;
+}
+
+
+static int do_read_capacity(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun	*curlun = fsg->curlun;
+	u32		lba = get_be32(&fsg->cmnd[2]);
+	int		pmi = fsg->cmnd[8];
+	u8		*buf = (u8 *) bh->buf;
+
+	/* Check the PMI and LBA fields */
+	if (pmi > 1 || (pmi == 0 && lba != 0)) {
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+
+	put_be32(&buf[0], curlun->num_sectors - 1);	/* Max logical block */
+	put_be32(&buf[4], 512);				/* Block length */
+	return 8;
+}
+
+
+static int do_mode_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun	*curlun = fsg->curlun;
+	int		mscmnd = fsg->cmnd[0];
+	u8		*buf = (u8 *) bh->buf;
+	u8		*buf0 = buf;
+	int		pc, page_code;
+	int		changeable_values, all_pages;
+	int		valid_page = 0;
+	int		len, limit;
+
+	if ((fsg->cmnd[1] & ~0x08) != 0) {		/* Mask away DBD */
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+	pc = fsg->cmnd[2] >> 6;
+	page_code = fsg->cmnd[2] & 0x3f;
+	if (pc == 3) {
+		curlun->sense_data = SS_SAVING_PARAMETERS_NOT_SUPPORTED;
+		return -EINVAL;
+	}
+	changeable_values = (pc == 1);
+	all_pages = (page_code == 0x3f);
+
+	/* Write the mode parameter header.  Fixed values are: default
+	 * medium type, no cache control (DPOFUA), and no block descriptors.
+	 * The only variable value is the WriteProtect bit.  We will fill in
+	 * the mode data length later. */
+	memset(buf, 0, 8);
+	if (mscmnd == SC_MODE_SENSE_6) {
+		buf[2] = (curlun->ro ? 0x80 : 0x00);		/* WP, DPOFUA */
+		buf += 4;
+		limit = 255;
+	} else {			/* SC_MODE_SENSE_10 */
+		buf[3] = (curlun->ro ? 0x80 : 0x00);		/* WP, DPOFUA */
+		buf += 8;
+		limit = 65535;
+	}
+
+	/* No block descriptors */
+
+	/* Disabled to workaround USB reset problems with a Vista host.
+	 */
+#if 0
+	/* The mode pages, in numerical order.  The only page we support
+	 * is the Caching page. */
+	if (page_code == 0x08 || all_pages) {
+		valid_page = 1;
+		buf[0] = 0x08;		/* Page code */
+		buf[1] = 10;		/* Page length */
+		memset(buf+2, 0, 10);	/* None of the fields are changeable */
+
+		if (!changeable_values) {
+			buf[2] = 0x04;	/* Write cache enable, */
+					/* Read cache not disabled */
+					/* No cache retention priorities */
+			put_be16(&buf[4], 0xffff);  /* Don't disable prefetch */
+					/* Minimum prefetch = 0 */
+			put_be16(&buf[8], 0xffff);  /* Maximum prefetch */
+			/* Maximum prefetch ceiling */
+			put_be16(&buf[10], 0xffff);
+		}
+		buf += 12;
+	}
+#else
+	valid_page = 1;
+#endif
+
+	/* Check that a valid page was requested and the mode data length
+	 * isn't too long. */
+	len = buf - buf0;
+	if (!valid_page || len > limit) {
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+
+	/*  Store the mode data length */
+	if (mscmnd == SC_MODE_SENSE_6)
+		buf0[0] = len - 1;
+	else
+		put_be16(buf0, len - 2);
+	return len;
+}
+
+static int do_start_stop(struct fsg_dev *fsg)
+{
+	struct lun	*curlun = fsg->curlun;
+	int		loej, start;
+
+	/* int immed = fsg->cmnd[1] & 0x01; */
+	loej = fsg->cmnd[4] & 0x02;
+	start = fsg->cmnd[4] & 0x01;
+
+	if (loej) {
+		/* eject request from the host */
+		if (backing_file_is_open(curlun)) {
+			close_backing_file(fsg, curlun);
+			curlun->unit_attention_data = SS_MEDIUM_NOT_PRESENT;
+		}
+	}
+
+	return 0;
+}
+
+static int do_prevent_allow(struct fsg_dev *fsg)
+{
+	struct lun	*curlun = fsg->curlun;
+	int		prevent;
+
+	prevent = fsg->cmnd[4] & 0x01;
+	if ((fsg->cmnd[4] & ~0x01) != 0) {		/* Mask away Prevent */
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+
+	if (curlun->prevent_medium_removal && !prevent)
+		fsync_sub(curlun);
+	curlun->prevent_medium_removal = prevent;
+	return 0;
+}
+
+
+static int do_read_format_capacities(struct fsg_dev *fsg,
+			struct fsg_buffhd *bh)
+{
+	struct lun	*curlun = fsg->curlun;
+	u8		*buf = (u8 *) bh->buf;
+
+	buf[0] = buf[1] = buf[2] = 0;
+	buf[3] = 8;	/* Only the Current/Maximum Capacity Descriptor */
+	buf += 4;
+
+	put_be32(&buf[0], curlun->num_sectors);	/* Number of blocks */
+	put_be32(&buf[4], 512);				/* Block length */
+	buf[4] = 0x02;					/* Current capacity */
+	return 12;
+}
+
+
+static int do_mode_select(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun	*curlun = fsg->curlun;
+
+	/* We don't support MODE SELECT */
+	curlun->sense_data = SS_INVALID_COMMAND;
+	return -EINVAL;
+}
+
+
+/*-------------------------------------------------------------------------*/
+#if 0
+static int write_zero(struct fsg_dev *fsg)
+{
+	struct fsg_buffhd	*bh;
+	int			rc;
+
+	DBG(fsg, "write_zero\n");
+	/* Wait for the next buffer to become available */
+	bh = fsg->next_buffhd_to_fill;
+	while (bh->state != BUF_STATE_EMPTY) {
+		rc = sleep_thread(fsg);
+		if (rc)
+			return rc;
+	}
+
+	bh->inreq->length = 0;
+	start_transfer(fsg, fsg->bulk_in, bh->inreq,
+			&bh->inreq_busy, &bh->state);
+
+	fsg->next_buffhd_to_fill = bh->next;
+	return 0;
+}
+#endif
+
+static int throw_away_data(struct fsg_dev *fsg)
+{
+	struct fsg_buffhd	*bh;
+	u32			amount;
+	int			rc;
+
+	DBG(fsg, "throw_away_data\n");
+	while ((bh = fsg->next_buffhd_to_drain)->state != BUF_STATE_EMPTY ||
+			fsg->usb_amount_left > 0) {
+
+		/* Throw away the data in a filled buffer */
+		if (bh->state == BUF_STATE_FULL) {
+			smp_rmb();
+			bh->state = BUF_STATE_EMPTY;
+			fsg->next_buffhd_to_drain = bh->next;
+
+			/* A short packet or an error ends everything */
+			if (bh->outreq->actual != bh->outreq->length ||
+					bh->outreq->status != 0) {
+				raise_exception(fsg, FSG_STATE_ABORT_BULK_OUT);
+				return -EINTR;
+			}
+			continue;
+		}
+
+		/* Try to submit another request if we need one */
+		bh = fsg->next_buffhd_to_fill;
+		if (bh->state == BUF_STATE_EMPTY && fsg->usb_amount_left > 0) {
+			amount = min(fsg->usb_amount_left, (u32) fsg->buf_size);
+
+			/* amount is always divisible by 512, hence by
+			 * the bulk-out maxpacket size */
+			bh->outreq->length = bh->bulk_out_intended_length =
+					amount;
+			start_transfer(fsg, fsg->bulk_out, bh->outreq,
+					&bh->outreq_busy, &bh->state);
+			fsg->next_buffhd_to_fill = bh->next;
+			fsg->usb_amount_left -= amount;
+			continue;
+		}
+
+		/* Otherwise wait for something to happen */
+		rc = sleep_thread(fsg);
+		if (rc)
+			return rc;
+	}
+	return 0;
+}
+
+
+static int finish_reply(struct fsg_dev *fsg)
+{
+	struct fsg_buffhd	*bh = fsg->next_buffhd_to_fill;
+	int			rc = 0;
+
+	switch (fsg->data_dir) {
+	case DATA_DIR_NONE:
+		break;			/* Nothing to send */
+
+	case DATA_DIR_UNKNOWN:
+		rc = -EINVAL;
+		break;
+
+	/* All but the last buffer of data must have already been sent */
+	case DATA_DIR_TO_HOST:
+		if (fsg->data_size == 0)
+			;		/* Nothing to send */
+
+		/* If there's no residue, simply send the last buffer */
+		else if (fsg->residue == 0) {
+			start_transfer(fsg, fsg->bulk_in, bh->inreq,
+					&bh->inreq_busy, &bh->state);
+			fsg->next_buffhd_to_fill = bh->next;
+		} else {
+			start_transfer(fsg, fsg->bulk_in, bh->inreq,
+					&bh->inreq_busy, &bh->state);
+			fsg->next_buffhd_to_fill = bh->next;
+#if 0
+			/* this is unnecessary, and was causing problems with MacOS */
+			if (bh->inreq->length > 0)
+				write_zero(fsg);
+#endif
+		}
+		break;
+
+	/* We have processed all we want from the data the host has sent.
+	 * There may still be outstanding bulk-out requests. */
+	case DATA_DIR_FROM_HOST:
+		if (fsg->residue == 0)
+			;		/* Nothing to receive */
+
+		/* Did the host stop sending unexpectedly early? */
+		else if (fsg->short_packet_received) {
+			raise_exception(fsg, FSG_STATE_ABORT_BULK_OUT);
+			rc = -EINTR;
+		}
+
+		/* We haven't processed all the incoming data.  Even though
+		 * we may be allowed to stall, doing so would cause a race.
+		 * The controller may already have ACK'ed all the remaining
+		 * bulk-out packets, in which case the host wouldn't see a
+		 * STALL.  Not realizing the endpoint was halted, it wouldn't
+		 * clear the halt -- leading to problems later on. */
+#if 0
+		fsg_set_halt(fsg, fsg->bulk_out);
+		raise_exception(fsg, FSG_STATE_ABORT_BULK_OUT);
+		rc = -EINTR;
+#endif
+
+		/* We can't stall.  Read in the excess data and throw it
+		 * all away. */
+		else
+			rc = throw_away_data(fsg);
+		break;
+	}
+	return rc;
+}
+
+
+static int send_status(struct fsg_dev *fsg)
+{
+	struct lun		*curlun = fsg->curlun;
+	struct fsg_buffhd	*bh;
+	int			rc;
+	u8			status = USB_STATUS_PASS;
+	u32			sd, sdinfo = 0;
+	struct bulk_cs_wrap	*csw;
+
+	DBG(fsg, "send_status\n");
+	/* Wait for the next buffer to become available */
+	bh = fsg->next_buffhd_to_fill;
+	while (bh->state != BUF_STATE_EMPTY) {
+		rc = sleep_thread(fsg);
+		if (rc)
+			return rc;
+	}
+
+	if (curlun) {
+		sd = curlun->sense_data;
+		sdinfo = curlun->sense_data_info;
+	} else if (fsg->bad_lun_okay)
+		sd = SS_NO_SENSE;
+	else
+		sd = SS_LOGICAL_UNIT_NOT_SUPPORTED;
+
+	if (fsg->phase_error) {
+		DBG(fsg, "sending phase-error status\n");
+		status = USB_STATUS_PHASE_ERROR;
+		sd = SS_INVALID_COMMAND;
+	} else if (sd != SS_NO_SENSE) {
+		DBG(fsg, "sending command-failure status\n");
+		status = USB_STATUS_FAIL;
+		VDBG(fsg, "  sense data: SK x%02x, ASC x%02x, ASCQ x%02x;"
+				"  info x%x\n",
+				SK(sd), ASC(sd), ASCQ(sd), sdinfo);
+	}
+
+	csw = bh->buf;
+
+	/* Store and send the Bulk-only CSW */
+	csw->Signature = __constant_cpu_to_le32(USB_BULK_CS_SIG);
+	csw->Tag = fsg->tag;
+	csw->Residue = cpu_to_le32(fsg->residue);
+	csw->Status = status;
+
+	bh->inreq->length = USB_BULK_CS_WRAP_LEN;
+	start_transfer(fsg, fsg->bulk_in, bh->inreq,
+			&bh->inreq_busy, &bh->state);
+
+	fsg->next_buffhd_to_fill = bh->next;
+	return 0;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* Check whether the command is properly formed and whether its data size
+ * and direction agree with the values we already have. */
+static int check_command(struct fsg_dev *fsg, int cmnd_size,
+		enum data_direction data_dir, unsigned int mask,
+		int needs_medium, const char *name)
+{
+	int			i;
+	int			lun = fsg->cmnd[1] >> 5;
+	static const char	dirletter[4] = {'u', 'o', 'i', 'n'};
+	char			hdlen[20];
+	struct lun		*curlun;
+
+	hdlen[0] = 0;
+	if (fsg->data_dir != DATA_DIR_UNKNOWN)
+		sprintf(hdlen, ", H%c=%u", dirletter[(int) fsg->data_dir],
+				fsg->data_size);
+	VDBG(fsg, "SCSI command: %s;  Dc=%d, D%c=%u;  Hc=%d%s\n",
+			name, cmnd_size, dirletter[(int) data_dir],
+			fsg->data_size_from_cmnd, fsg->cmnd_size, hdlen);
+
+	/* We can't reply at all until we know the correct data direction
+	 * and size. */
+	if (fsg->data_size_from_cmnd == 0)
+		data_dir = DATA_DIR_NONE;
+	if (fsg->data_dir == DATA_DIR_UNKNOWN) {	/* CB or CBI */
+		fsg->data_dir = data_dir;
+		fsg->data_size = fsg->data_size_from_cmnd;
+
+	} else {					/* Bulk-only */
+		if (fsg->data_size < fsg->data_size_from_cmnd) {
+
+			/* Host data size < Device data size is a phase error.
+			 * Carry out the command, but only transfer as much
+			 * as we are allowed. */
+			DBG(fsg, "phase error 1\n");
+			fsg->data_size_from_cmnd = fsg->data_size;
+			fsg->phase_error = 1;
+		}
+	}
+	fsg->residue = fsg->usb_amount_left = fsg->data_size;
+
+	/* Conflicting data directions is a phase error */
+	if (fsg->data_dir != data_dir && fsg->data_size_from_cmnd > 0) {
+		fsg->phase_error = 1;
+		DBG(fsg, "phase error 2\n");
+		return -EINVAL;
+	}
+
+	/* Verify the length of the command itself */
+	if (cmnd_size != fsg->cmnd_size) {
+
+		/* Special case workaround: MS-Windows issues REQUEST_SENSE
+		 * and INQUIRY commands with cbw->Length == 12 (it should be 6). */
+		if ((fsg->cmnd[0] == SC_REQUEST_SENSE && fsg->cmnd_size == 12)
+		 || (fsg->cmnd[0] == SC_INQUIRY && fsg->cmnd_size == 12))
+			cmnd_size = fsg->cmnd_size;
+		else {
+			fsg->phase_error = 1;
+			return -EINVAL;
+		}
+	}
+
+	/* Check that the LUN values are consistent */
+	if (fsg->lun != lun)
+		DBG(fsg, "using LUN %d from CBW, "
+				"not LUN %d from CDB\n",
+				fsg->lun, lun);
+
+	/* Check the LUN */
+	if (fsg->lun >= 0 && fsg->lun < fsg->nluns) {
+		fsg->curlun = curlun = &fsg->luns[fsg->lun];
+		if (fsg->cmnd[0] != SC_REQUEST_SENSE) {
+			curlun->sense_data = SS_NO_SENSE;
+			curlun->sense_data_info = 0;
+			curlun->info_valid = 0;
+		}
+	} else {
+		fsg->curlun = curlun = NULL;
+		fsg->bad_lun_okay = 0;
+
+		/* INQUIRY and REQUEST SENSE commands are explicitly allowed
+		 * to use unsupported LUNs; all others may not. */
+		if (fsg->cmnd[0] != SC_INQUIRY &&
+				fsg->cmnd[0] != SC_REQUEST_SENSE) {
+			DBG(fsg, "unsupported LUN %d\n", fsg->lun);
+			return -EINVAL;
+		}
+	}
+
+	/* If a unit attention condition exists, only INQUIRY and
+	 * REQUEST SENSE commands are allowed; anything else must fail. */
+	if (curlun && curlun->unit_attention_data != SS_NO_SENSE &&
+			fsg->cmnd[0] != SC_INQUIRY &&
+			fsg->cmnd[0] != SC_REQUEST_SENSE) {
+		curlun->sense_data = curlun->unit_attention_data;
+		curlun->unit_attention_data = SS_NO_SENSE;
+		return -EINVAL;
+	}
+
+	/* Check that only command bytes listed in the mask are non-zero */
+	fsg->cmnd[1] &= 0x1f;			/* Mask away the LUN */
+	for (i = 1; i < cmnd_size; ++i) {
+		if (fsg->cmnd[i] && !(mask & (1 << i))) {
+			if (curlun)
+				curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+			DBG(fsg, "SS_INVALID_FIELD_IN_CDB\n");
+			return -EINVAL;
+		}
+	}
+
+	/* If the medium isn't mounted and the command needs to access
+	 * it, return an error. */
+	if (curlun && !backing_file_is_open(curlun) && needs_medium) {
+		curlun->sense_data = SS_MEDIUM_NOT_PRESENT;
+		DBG(fsg, "SS_MEDIUM_NOT_PRESENT\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int do_scsi_command(struct fsg_dev *fsg)
+{
+	struct fsg_buffhd	*bh;
+	int			rc;
+	int			reply = -EINVAL;
+	int			i;
+	static char		unknown[16];
+
+	dump_cdb(fsg);
+
+	/* Wait for the next buffer to become available for data or status */
+	bh = fsg->next_buffhd_to_drain = fsg->next_buffhd_to_fill;
+	while (bh->state != BUF_STATE_EMPTY) {
+		rc = sleep_thread(fsg);
+		if (rc)
+			return rc;
+	}
+	fsg->phase_error = 0;
+	fsg->short_packet_received = 0;
+
+	down_read(&fsg->filesem);	/* We're using the backing file */
+	switch (fsg->cmnd[0]) {
+
+	case SC_INQUIRY:
+		fsg->data_size_from_cmnd = fsg->cmnd[4];
+		if ((reply = check_command(fsg, 6, DATA_DIR_TO_HOST,
+				(1<<4), 0,
+				"INQUIRY")) == 0)
+			reply = do_inquiry(fsg, bh);
+		break;
+
+	case SC_MODE_SELECT_6:
+		fsg->data_size_from_cmnd = fsg->cmnd[4];
+		if ((reply = check_command(fsg, 6, DATA_DIR_FROM_HOST,
+				(1<<1) | (1<<4), 0,
+				"MODE SELECT(6)")) == 0)
+			reply = do_mode_select(fsg, bh);
+		break;
+
+	case SC_MODE_SELECT_10:
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
+		if ((reply = check_command(fsg, 10, DATA_DIR_FROM_HOST,
+				(1<<1) | (3<<7), 0,
+				"MODE SELECT(10)")) == 0)
+			reply = do_mode_select(fsg, bh);
+		break;
+
+	case SC_MODE_SENSE_6:
+		fsg->data_size_from_cmnd = fsg->cmnd[4];
+		if ((reply = check_command(fsg, 6, DATA_DIR_TO_HOST,
+				(1<<1) | (1<<2) | (1<<4), 0,
+				"MODE SENSE(6)")) == 0)
+			reply = do_mode_sense(fsg, bh);
+		break;
+
+	case SC_MODE_SENSE_10:
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
+		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
+				(1<<1) | (1<<2) | (3<<7), 0,
+				"MODE SENSE(10)")) == 0)
+			reply = do_mode_sense(fsg, bh);
+		break;
+
+	case SC_PREVENT_ALLOW_MEDIUM_REMOVAL:
+		fsg->data_size_from_cmnd = 0;
+		if ((reply = check_command(fsg, 6, DATA_DIR_NONE,
+				(1<<4), 0,
+				"PREVENT-ALLOW MEDIUM REMOVAL")) == 0)
+			reply = do_prevent_allow(fsg);
+		break;
+
+	case SC_READ_6:
+		i = fsg->cmnd[4];
+		fsg->data_size_from_cmnd = (i == 0 ? 256 : i) << 9;
+		if ((reply = check_command(fsg, 6, DATA_DIR_TO_HOST,
+				(7<<1) | (1<<4), 1,
+				"READ(6)")) == 0)
+			reply = do_read(fsg);
+		break;
+
+	case SC_READ_10:
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]) << 9;
+		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
+				(1<<1) | (0xf<<2) | (3<<7), 1,
+				"READ(10)")) == 0)
+			reply = do_read(fsg);
+		break;
+
+	case SC_READ_12:
+		fsg->data_size_from_cmnd = get_be32(&fsg->cmnd[6]) << 9;
+		if ((reply = check_command(fsg, 12, DATA_DIR_TO_HOST,
+				(1<<1) | (0xf<<2) | (0xf<<6), 1,
+				"READ(12)")) == 0)
+			reply = do_read(fsg);
+		break;
+
+	case SC_READ_CAPACITY:
+		fsg->data_size_from_cmnd = 8;
+		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
+				(0xf<<2) | (1<<8), 1,
+				"READ CAPACITY")) == 0)
+			reply = do_read_capacity(fsg, bh);
+		break;
+
+	case SC_READ_FORMAT_CAPACITIES:
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
+		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
+				(3<<7), 1,
+				"READ FORMAT CAPACITIES")) == 0)
+			reply = do_read_format_capacities(fsg, bh);
+		break;
+
+	case SC_REQUEST_SENSE:
+		fsg->data_size_from_cmnd = fsg->cmnd[4];
+		if ((reply = check_command(fsg, 6, DATA_DIR_TO_HOST,
+				(1<<4), 0,
+				"REQUEST SENSE")) == 0)
+			reply = do_request_sense(fsg, bh);
+		break;
+
+	case SC_START_STOP_UNIT:
+		fsg->data_size_from_cmnd = 0;
+		if ((reply = check_command(fsg, 6, DATA_DIR_NONE,
+				(1<<1) | (1<<4), 0,
+				"START-STOP UNIT")) == 0)
+			reply = do_start_stop(fsg);
+		break;
+
+	case SC_SYNCHRONIZE_CACHE:
+		fsg->data_size_from_cmnd = 0;
+		if ((reply = check_command(fsg, 10, DATA_DIR_NONE,
+				(0xf<<2) | (3<<7), 1,
+				"SYNCHRONIZE CACHE")) == 0)
+			reply = do_synchronize_cache(fsg);
+		break;
+
+	case SC_TEST_UNIT_READY:
+		fsg->data_size_from_cmnd = 0;
+		reply = check_command(fsg, 6, DATA_DIR_NONE,
+				0, 1,
+				"TEST UNIT READY");
+		break;
+
+	/* Although optional, this command is used by MS-Windows.  We
+	 * support a minimal version: BytChk must be 0. */
+	case SC_VERIFY:
+		fsg->data_size_from_cmnd = 0;
+		if ((reply = check_command(fsg, 10, DATA_DIR_NONE,
+				(1<<1) | (0xf<<2) | (3<<7), 1,
+				"VERIFY")) == 0)
+			reply = do_verify(fsg);
+		break;
+
+	case SC_WRITE_6:
+		i = fsg->cmnd[4];
+		fsg->data_size_from_cmnd = (i == 0 ? 256 : i) << 9;
+		if ((reply = check_command(fsg, 6, DATA_DIR_FROM_HOST,
+				(7<<1) | (1<<4), 1,
+				"WRITE(6)")) == 0)
+			reply = do_write(fsg);
+		break;
+
+	case SC_WRITE_10:
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]) << 9;
+		if ((reply = check_command(fsg, 10, DATA_DIR_FROM_HOST,
+				(1<<1) | (0xf<<2) | (3<<7), 1,
+				"WRITE(10)")) == 0)
+			reply = do_write(fsg);
+		break;
+
+	case SC_WRITE_12:
+		fsg->data_size_from_cmnd = get_be32(&fsg->cmnd[6]) << 9;
+		if ((reply = check_command(fsg, 12, DATA_DIR_FROM_HOST,
+				(1<<1) | (0xf<<2) | (0xf<<6), 1,
+				"WRITE(12)")) == 0)
+			reply = do_write(fsg);
+		break;
+
+	/* Some mandatory commands that we recognize but don't implement.
+	 * They don't mean much in this setting.  It's left as an exercise
+	 * for anyone interested to implement RESERVE and RELEASE in terms
+	 * of Posix locks. */
+	case SC_FORMAT_UNIT:
+	case SC_RELEASE:
+	case SC_RESERVE:
+	case SC_SEND_DIAGNOSTIC:
+		/* Fall through */
+
+	default:
+		fsg->data_size_from_cmnd = 0;
+		sprintf(unknown, "Unknown x%02x", fsg->cmnd[0]);
+		if ((reply = check_command(fsg, fsg->cmnd_size,
+				DATA_DIR_UNKNOWN, 0xff, 0, unknown)) == 0) {
+			fsg->curlun->sense_data = SS_INVALID_COMMAND;
+			reply = -EINVAL;
+		}
+		break;
+	}
+	up_read(&fsg->filesem);
+
+	VDBG(fsg, "reply: %d, fsg->data_size_from_cmnd: %d\n",
+			reply, fsg->data_size_from_cmnd);
+	if (reply == -EINTR || signal_pending(current))
+		return -EINTR;
+
+	/* Set up the single reply buffer for finish_reply() */
+	if (reply == -EINVAL)
+		reply = 0;		/* Error reply length */
+	if (reply >= 0 && fsg->data_dir == DATA_DIR_TO_HOST) {
+		reply = min((u32) reply, fsg->data_size_from_cmnd);
+		bh->inreq->length = reply;
+		bh->state = BUF_STATE_FULL;
+		fsg->residue -= reply;
+	}				/* Otherwise it's already set */
+
+	return 0;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct usb_request	*req = bh->outreq;
+	struct bulk_cb_wrap	*cbw = req->buf;
+
+	/* Was this a real packet? */
+	if (req->status)
+		return -EINVAL;
+
+	/* Is the CBW valid? */
+	if (req->actual != USB_BULK_CB_WRAP_LEN ||
+			cbw->Signature != __constant_cpu_to_le32(
+				USB_BULK_CB_SIG)) {
+		DBG(fsg, "invalid CBW: len %u sig 0x%x\n",
+				req->actual,
+				le32_to_cpu(cbw->Signature));
+		return -EINVAL;
+	}
+
+	/* Is the CBW meaningful? */
+	if (cbw->Lun >= MAX_LUNS || cbw->Flags & ~USB_BULK_IN_FLAG ||
+			cbw->Length <= 0 || cbw->Length > MAX_COMMAND_SIZE) {
+		DBG(fsg, "non-meaningful CBW: lun = %u, flags = 0x%x, "
+				"cmdlen %u\n",
+				cbw->Lun, cbw->Flags, cbw->Length);
+		return -EINVAL;
+	}
+
+	/* Save the command for later */
+	fsg->cmnd_size = cbw->Length;
+	memcpy(fsg->cmnd, cbw->CDB, fsg->cmnd_size);
+	if (cbw->Flags & USB_BULK_IN_FLAG)
+		fsg->data_dir = DATA_DIR_TO_HOST;
+	else
+		fsg->data_dir = DATA_DIR_FROM_HOST;
+	fsg->data_size = le32_to_cpu(cbw->DataTransferLength);
+	if (fsg->data_size == 0)
+		fsg->data_dir = DATA_DIR_NONE;
+	fsg->lun = cbw->Lun;
+	fsg->tag = cbw->Tag;
+	return 0;
+}
+
+
+static int get_next_command(struct fsg_dev *fsg)
+{
+	struct fsg_buffhd	*bh;
+	int			rc = 0;
+
+	/* Wait for the next buffer to become available */
+	bh = fsg->next_buffhd_to_fill;
+	while (bh->state != BUF_STATE_EMPTY) {
+		rc = sleep_thread(fsg);
+		if (rc) {
+			usb_ep_dequeue(fsg->bulk_out, bh->outreq);
+			bh->outreq_busy = 0;
+			bh->state = BUF_STATE_EMPTY;
+			return rc;
+		}
+	}
+
+	/* Queue a request to read a Bulk-only CBW */
+	set_bulk_out_req_length(fsg, bh, USB_BULK_CB_WRAP_LEN);
+	start_transfer(fsg, fsg->bulk_out, bh->outreq,
+			&bh->outreq_busy, &bh->state);
+
+	/* We will drain the buffer in software, which means we
+	 * can reuse it for the next filling.  No need to advance
+	 * next_buffhd_to_fill. */
+
+	/* Wait for the CBW to arrive */
+	while (bh->state != BUF_STATE_FULL) {
+		rc = sleep_thread(fsg);
+		if (rc) {
+			usb_ep_dequeue(fsg->bulk_out, bh->outreq);
+			bh->outreq_busy = 0;
+			bh->state = BUF_STATE_EMPTY;
+			return rc;
+		}
+	}
+	smp_rmb();
+	rc = received_cbw(fsg, bh);
+	bh->state = BUF_STATE_EMPTY;
+
+	return rc;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int enable_endpoint(struct fsg_dev *fsg, struct usb_ep *ep,
+		const struct usb_endpoint_descriptor *d)
+{
+	int	rc;
+
+	DBG(fsg, "usb_ep_enable %s\n", ep->name);
+	ep->driver_data = fsg;
+	rc = usb_ep_enable(ep, d);
+	if (rc)
+		ERROR(fsg, "can't enable %s, result %d\n", ep->name, rc);
+	return rc;
+}
+
+static int alloc_request(struct fsg_dev *fsg, struct usb_ep *ep,
+		struct usb_request **preq)
+{
+	*preq = usb_ep_alloc_request(ep, GFP_ATOMIC);
+	if (*preq)
+		return 0;
+	ERROR(fsg, "can't allocate request for %s\n", ep->name);
+	return -ENOMEM;
+}
+
+/*
+ * Reset interface setting and re-init endpoint state (toggle etc).
+ * Call with altsetting < 0 to disable the interface.  The only other
+ * available altsetting is 0, which enables the interface.
+ */
+static int do_set_interface(struct fsg_dev *fsg, int altsetting)
+{
+	struct usb_composite_dev *cdev = fsg->cdev;
+	int	rc = 0;
+	int	i;
+	const struct usb_endpoint_descriptor	*d;
+
+	if (fsg->running)
+		DBG(fsg, "reset interface\n");
+reset:
+	 /* Disable the endpoints */
+	if (fsg->bulk_in_enabled) {
+		DBG(fsg, "usb_ep_disable %s\n", fsg->bulk_in->name);
+		usb_ep_disable(fsg->bulk_in);
+		fsg->bulk_in_enabled = 0;
+	}
+	if (fsg->bulk_out_enabled) {
+		DBG(fsg, "usb_ep_disable %s\n", fsg->bulk_out->name);
+		usb_ep_disable(fsg->bulk_out);
+		fsg->bulk_out_enabled = 0;
+	}
+
+	/* Deallocate the requests */
+	for (i = 0; i < NUM_BUFFERS; ++i) {
+		struct fsg_buffhd *bh = &fsg->buffhds[i];
+		if (bh->inreq) {
+			usb_ep_free_request(fsg->bulk_in, bh->inreq);
+			bh->inreq = NULL;
+		}
+		if (bh->outreq) {
+			usb_ep_free_request(fsg->bulk_out, bh->outreq);
+			bh->outreq = NULL;
+		}
+	}
+
+
+	fsg->running = 0;
+	if (altsetting < 0 || rc != 0)
+		return rc;
+
+	DBG(fsg, "set interface %d\n", altsetting);
+
+	/* Enable the endpoints */
+	d = ep_desc(cdev->gadget, &fs_bulk_in_desc, &hs_bulk_in_desc);
+	if ((rc = enable_endpoint(fsg, fsg->bulk_in, d)) != 0)
+		goto reset;
+	fsg->bulk_in_enabled = 1;
+
+	d = ep_desc(cdev->gadget, &fs_bulk_out_desc, &hs_bulk_out_desc);
+	if ((rc = enable_endpoint(fsg, fsg->bulk_out, d)) != 0)
+		goto reset;
+	fsg->bulk_out_enabled = 1;
+	fsg->bulk_out_maxpacket = le16_to_cpu(d->wMaxPacketSize);
+
+	/* Allocate the requests */
+	for (i = 0; i < NUM_BUFFERS; ++i) {
+		struct fsg_buffhd	*bh = &fsg->buffhds[i];
+
+		rc = alloc_request(fsg, fsg->bulk_in, &bh->inreq);
+		if (rc != 0)
+			goto reset;
+		rc = alloc_request(fsg, fsg->bulk_out, &bh->outreq);
+		if (rc != 0)
+			goto reset;
+		bh->inreq->buf = bh->outreq->buf = bh->buf;
+		bh->inreq->context = bh->outreq->context = bh;
+		bh->inreq->complete = bulk_in_complete;
+		bh->outreq->complete = bulk_out_complete;
+	}
+
+	fsg->running = 1;
+	for (i = 0; i < fsg->nluns; ++i)
+		fsg->luns[i].unit_attention_data = SS_RESET_OCCURRED;
+
+	return rc;
+}
+
+static void adjust_wake_lock(struct fsg_dev *fsg)
+{
+	int ums_active = 0;
+	int i;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&fsg->lock, flags);
+
+	if (fsg->config) {
+		for (i = 0; i < fsg->nluns; ++i) {
+			if (backing_file_is_open(&fsg->luns[i]))
+				ums_active = 1;
+		}
+	}
+
+	if (ums_active)
+		wake_lock(&fsg->wake_lock);
+	else
+		wake_unlock(&fsg->wake_lock);
+
+	spin_unlock_irqrestore(&fsg->lock, flags);
+}
+
+/*
+ * Change our operational configuration.  This code must agree with the code
+ * that returns config descriptors, and with interface altsetting code.
+ *
+ * It's also responsible for power management interactions.  Some
+ * configurations might not work with our current power sources.
+ * For now we just assume the gadget is always self-powered.
+ */
+static int do_set_config(struct fsg_dev *fsg, u8 new_config)
+{
+	int	rc = 0;
+
+	/* Disable the single interface */
+	if (fsg->config != 0) {
+		DBG(fsg, "reset config\n");
+		fsg->config = 0;
+		rc = do_set_interface(fsg, -1);
+	}
+
+	/* Enable the interface */
+	if (new_config != 0) {
+		fsg->config = new_config;
+		if ((rc = do_set_interface(fsg, 0)) != 0)
+			fsg->config = 0;	// Reset on errors
+	}
+
+	switch_set_state(&fsg->sdev, new_config);
+	adjust_wake_lock(fsg);
+	return rc;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static void handle_exception(struct fsg_dev *fsg)
+{
+	siginfo_t		info;
+	int			sig;
+	int			i;
+	int			num_active;
+	struct fsg_buffhd	*bh;
+	enum fsg_state		old_state;
+	u8			new_config;
+	struct lun		*curlun;
+	int			rc;
+	unsigned long		flags;
+
+	DBG(fsg, "handle_exception state: %d\n", (int)fsg->state);
+	/* Clear the existing signals.  Anything but SIGUSR1 is converted
+	 * into a high-priority EXIT exception. */
+	for (;;) {
+		sig = dequeue_signal_lock(current, &current->blocked, &info);
+		if (!sig)
+			break;
+		if (sig != SIGUSR1) {
+			if (fsg->state < FSG_STATE_EXIT)
+				DBG(fsg, "Main thread exiting on signal\n");
+			raise_exception(fsg, FSG_STATE_EXIT);
+		}
+	}
+
+	/* Cancel all the pending transfers */
+	for (i = 0; i < NUM_BUFFERS; ++i) {
+		bh = &fsg->buffhds[i];
+		if (bh->inreq_busy)
+			usb_ep_dequeue(fsg->bulk_in, bh->inreq);
+		if (bh->outreq_busy)
+			usb_ep_dequeue(fsg->bulk_out, bh->outreq);
+	}
+
+	/* Wait until everything is idle */
+	for (;;) {
+		num_active = 0;
+		for (i = 0; i < NUM_BUFFERS; ++i) {
+			bh = &fsg->buffhds[i];
+			num_active += bh->outreq_busy;
+		}
+		if (num_active == 0)
+			break;
+		if (sleep_thread(fsg))
+			return;
+	}
+
+	/*
+	* Do NOT flush the fifo after set_interface()
+	* Otherwise, it results in some data being lost
+	*/
+	if ((fsg->state != FSG_STATE_CONFIG_CHANGE) ||
+		(fsg->new_config != 1))   {
+		/* Clear out the controller's fifos */
+		if (fsg->bulk_in_enabled)
+			usb_ep_fifo_flush(fsg->bulk_in);
+		if (fsg->bulk_out_enabled)
+			usb_ep_fifo_flush(fsg->bulk_out);
+	}
+	/* Reset the I/O buffer states and pointers, the SCSI
+	 * state, and the exception.  Then invoke the handler. */
+	spin_lock_irqsave(&fsg->lock, flags);
+
+	for (i = 0; i < NUM_BUFFERS; ++i) {
+		bh = &fsg->buffhds[i];
+		bh->state = BUF_STATE_EMPTY;
+	}
+	fsg->next_buffhd_to_fill = fsg->next_buffhd_to_drain =
+			&fsg->buffhds[0];
+
+	new_config = fsg->new_config;
+	old_state = fsg->state;
+
+	if (old_state == FSG_STATE_ABORT_BULK_OUT)
+		fsg->state = FSG_STATE_STATUS_PHASE;
+	else {
+		for (i = 0; i < fsg->nluns; ++i) {
+			curlun = &fsg->luns[i];
+			curlun->prevent_medium_removal = 0;
+			curlun->sense_data = curlun->unit_attention_data =
+					SS_NO_SENSE;
+			curlun->sense_data_info = 0;
+			curlun->info_valid = 0;
+		}
+		fsg->state = FSG_STATE_IDLE;
+	}
+	spin_unlock_irqrestore(&fsg->lock, flags);
+
+	/* Carry out any extra actions required for the exception */
+	switch (old_state) {
+	default:
+		break;
+
+	case FSG_STATE_ABORT_BULK_OUT:
+		DBG(fsg, "FSG_STATE_ABORT_BULK_OUT\n");
+		spin_lock_irqsave(&fsg->lock, flags);
+		if (fsg->state == FSG_STATE_STATUS_PHASE)
+			fsg->state = FSG_STATE_IDLE;
+		spin_unlock_irqrestore(&fsg->lock, flags);
+		break;
+
+	case FSG_STATE_RESET:
+		/* really not much to do here */
+		break;
+
+	case FSG_STATE_CONFIG_CHANGE:
+		rc = do_set_config(fsg, new_config);
+		if (new_config == 0) {
+			/* We're using the backing file */
+			down_read(&fsg->filesem);
+			fsync_all(fsg);
+			up_read(&fsg->filesem);
+		}
+		break;
+
+	case FSG_STATE_EXIT:
+	case FSG_STATE_TERMINATED:
+		do_set_config(fsg, 0);			/* Free resources */
+		spin_lock_irqsave(&fsg->lock, flags);
+		fsg->state = FSG_STATE_TERMINATED;	/* Stop the thread */
+		spin_unlock_irqrestore(&fsg->lock, flags);
+		break;
+	}
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int fsg_main_thread(void *fsg_)
+{
+	struct fsg_dev		*fsg = fsg_;
+	unsigned long		flags;
+
+	/* Allow the thread to be killed by a signal, but set the signal mask
+	 * to block everything but INT, TERM, KILL, and USR1. */
+	allow_signal(SIGINT);
+	allow_signal(SIGTERM);
+	allow_signal(SIGKILL);
+	allow_signal(SIGUSR1);
+
+	/* Allow the thread to be frozen */
+	set_freezable();
+
+	/* Arrange for userspace references to be interpreted as kernel
+	 * pointers.  That way we can pass a kernel pointer to a routine
+	 * that expects a __user pointer and it will work okay. */
+	set_fs(get_ds());
+
+	/* The main loop */
+	while (fsg->state != FSG_STATE_TERMINATED) {
+		if (exception_in_progress(fsg) || signal_pending(current)) {
+			handle_exception(fsg);
+			continue;
+		}
+
+		if (!fsg->running) {
+			sleep_thread(fsg);
+			continue;
+		}
+
+		if (get_next_command(fsg))
+			continue;
+
+		spin_lock_irqsave(&fsg->lock, flags);
+		if (!exception_in_progress(fsg))
+			fsg->state = FSG_STATE_DATA_PHASE;
+		spin_unlock_irqrestore(&fsg->lock, flags);
+
+		if (do_scsi_command(fsg) || finish_reply(fsg))
+			continue;
+
+		spin_lock_irqsave(&fsg->lock, flags);
+		if (!exception_in_progress(fsg))
+			fsg->state = FSG_STATE_STATUS_PHASE;
+		spin_unlock_irqrestore(&fsg->lock, flags);
+
+		if (send_status(fsg))
+			continue;
+
+		spin_lock_irqsave(&fsg->lock, flags);
+		if (!exception_in_progress(fsg))
+			fsg->state = FSG_STATE_IDLE;
+		spin_unlock_irqrestore(&fsg->lock, flags);
+	}
+
+	spin_lock_irqsave(&fsg->lock, flags);
+	fsg->thread_task = NULL;
+	spin_unlock_irqrestore(&fsg->lock, flags);
+
+	/* In case we are exiting because of a signal, unregister the
+	 * gadget driver and close the backing file. */
+	if (test_and_clear_bit(REGISTERED, &fsg->atomic_bitflags))
+		close_all_backing_files(fsg);
+
+	/* Let the unbind and cleanup routines know the thread has exited */
+	complete_and_exit(&fsg->thread_notifier, 0);
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* If the next two routines are called while the gadget is registered,
+ * the caller must own fsg->filesem for writing. */
+
+static int open_backing_file(struct fsg_dev *fsg, struct lun *curlun,
+	const char *filename)
+{
+	int				ro;
+	struct file			*filp = NULL;
+	int				rc = -EINVAL;
+	struct inode			*inode = NULL;
+	loff_t				size;
+	loff_t				num_sectors;
+
+	/* R/W if we can, R/O if we must */
+	ro = curlun->ro;
+	if (!ro) {
+		filp = filp_open(filename, O_RDWR | O_LARGEFILE, 0);
+		if (-EROFS == PTR_ERR(filp))
+			ro = 1;
+	}
+	if (ro)
+		filp = filp_open(filename, O_RDONLY | O_LARGEFILE, 0);
+	if (IS_ERR(filp)) {
+		LINFO(curlun, "unable to open backing file: %s\n", filename);
+		return PTR_ERR(filp);
+	}
+
+	if (!(filp->f_mode & FMODE_WRITE))
+		ro = 1;
+
+	if (filp->f_path.dentry)
+		inode = filp->f_path.dentry->d_inode;
+	if (inode && S_ISBLK(inode->i_mode)) {
+		if (bdev_read_only(inode->i_bdev))
+			ro = 1;
+	} else if (!inode || !S_ISREG(inode->i_mode)) {
+		LINFO(curlun, "invalid file type: %s\n", filename);
+		goto out;
+	}
+
+	/* If we can't read the file, it's no good.
+	 * If we can't write the file, use it read-only. */
+	if (!filp->f_op || !(filp->f_op->read || filp->f_op->aio_read)) {
+		LINFO(curlun, "file not readable: %s\n", filename);
+		goto out;
+	}
+	if (!(filp->f_op->write || filp->f_op->aio_write))
+		ro = 1;
+
+	size = i_size_read(inode->i_mapping->host);
+	if (size < 0) {
+		LINFO(curlun, "unable to find file size: %s\n", filename);
+		rc = (int) size;
+		goto out;
+	}
+	num_sectors = size >> 9;	/* File size in 512-byte sectors */
+	if (num_sectors == 0) {
+		LINFO(curlun, "file too small: %s\n", filename);
+		rc = -ETOOSMALL;
+		goto out;
+	}
+
+	get_file(filp);
+	curlun->ro = ro;
+	curlun->filp = filp;
+	curlun->file_length = size;
+	curlun->unflushed_bytes = 0;
+	curlun->num_sectors = num_sectors;
+	LDBG(curlun, "open backing file: %s size: %lld num_sectors: %lld\n",
+			filename, size, num_sectors);
+	rc = 0;
+	adjust_wake_lock(fsg);
+
+out:
+	filp_close(filp, current->files);
+	return rc;
+}
+
+
+static void close_backing_file(struct fsg_dev *fsg, struct lun *curlun)
+{
+	if (curlun->filp) {
+		int rc;
+
+		/*
+		 * XXX: San: Ugly hack here added to ensure that
+		 * our pages get synced to disk.
+		 * Also drop caches here just to be extra-safe
+		 */
+		rc = vfs_fsync(curlun->filp, curlun->filp->f_path.dentry, 1);
+		if (rc < 0)
+			printk(KERN_ERR "ums: Error syncing data (%d)\n", rc);
+		/* drop_pagecache and drop_slab are no longer available */
+		/* drop_pagecache(); */
+		/* drop_slab(); */
+
+		LDBG(curlun, "close backing file\n");
+		fput(curlun->filp);
+		curlun->filp = NULL;
+		adjust_wake_lock(fsg);
+	}
+}
+
+static void close_all_backing_files(struct fsg_dev *fsg)
+{
+	int	i;
+
+	for (i = 0; i < fsg->nluns; ++i)
+		close_backing_file(fsg, &fsg->luns[i]);
+}
+
+static ssize_t show_file(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct lun	*curlun = dev_to_lun(dev);
+	struct fsg_dev	*fsg = dev_get_drvdata(dev);
+	char		*p;
+	ssize_t		rc;
+
+	down_read(&fsg->filesem);
+	if (backing_file_is_open(curlun)) {	/* Get the complete pathname */
+		p = d_path(&curlun->filp->f_path, buf, PAGE_SIZE - 1);
+		if (IS_ERR(p))
+			rc = PTR_ERR(p);
+		else {
+			rc = strlen(p);
+			memmove(buf, p, rc);
+			buf[rc] = '\n';		/* Add a newline */
+			buf[++rc] = 0;
+		}
+	} else {				/* No file, return 0 bytes */
+		*buf = 0;
+		rc = 0;
+	}
+	up_read(&fsg->filesem);
+	return rc;
+}
+
+static ssize_t store_file(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct lun	*curlun = dev_to_lun(dev);
+	struct fsg_dev	*fsg = dev_get_drvdata(dev);
+	int		rc = 0;
+
+	DBG(fsg, "store_file: \"%s\"\n", buf);
+#if 0
+	/* disabled because we need to allow closing the backing file if the media was removed */
+	if (curlun->prevent_medium_removal && backing_file_is_open(curlun)) {
+		LDBG(curlun, "eject attempt prevented\n");
+		return -EBUSY;				/* "Door is locked" */
+	}
+#endif
+
+	/* Remove a trailing newline */
+	if (count > 0 && buf[count-1] == '\n')
+		((char *) buf)[count-1] = 0;
+
+	/* Eject current medium */
+	down_write(&fsg->filesem);
+	if (backing_file_is_open(curlun)) {
+		close_backing_file(fsg, curlun);
+		curlun->unit_attention_data = SS_MEDIUM_NOT_PRESENT;
+	}
+
+	/* Load new medium */
+	if (count > 0 && buf[0]) {
+		rc = open_backing_file(fsg, curlun, buf);
+		if (rc == 0)
+			curlun->unit_attention_data =
+					SS_NOT_READY_TO_READY_TRANSITION;
+	}
+	up_write(&fsg->filesem);
+	return (rc < 0 ? rc : count);
+}
+
+
+static DEVICE_ATTR(file, 0444, show_file, store_file);
+
+/*-------------------------------------------------------------------------*/
+
+static void fsg_release(struct kref *ref)
+{
+	struct fsg_dev	*fsg = container_of(ref, struct fsg_dev, ref);
+
+	kfree(fsg->luns);
+	kfree(fsg);
+}
+
+static void lun_release(struct device *dev)
+{
+	struct fsg_dev	*fsg = dev_get_drvdata(dev);
+
+	kref_put(&fsg->ref, fsg_release);
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int __init fsg_alloc(void)
+{
+	struct fsg_dev		*fsg;
+
+	fsg = kzalloc(sizeof *fsg, GFP_KERNEL);
+	if (!fsg)
+		return -ENOMEM;
+	spin_lock_init(&fsg->lock);
+	init_rwsem(&fsg->filesem);
+	kref_init(&fsg->ref);
+	init_completion(&fsg->thread_notifier);
+
+	the_fsg = fsg;
+	return 0;
+}
+
+static ssize_t print_switch_name(struct switch_dev *sdev, char *buf)
+{
+	return sprintf(buf, "%s\n", DRIVER_NAME);
+}
+
+static ssize_t print_switch_state(struct switch_dev *sdev, char *buf)
+{
+	struct fsg_dev	*fsg = container_of(sdev, struct fsg_dev, sdev);
+	return sprintf(buf, "%s\n", (fsg->config ? "online" : "offline"));
+}
+
+static void
+fsg_function_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct fsg_dev	*fsg = func_to_dev(f);
+	int			i;
+	struct lun		*curlun;
+
+	DBG(fsg, "fsg_function_unbind\n");
+	clear_bit(REGISTERED, &fsg->atomic_bitflags);
+
+	/* Unregister the sysfs attribute files and the LUNs */
+	for (i = 0; i < fsg->nluns; ++i) {
+		curlun = &fsg->luns[i];
+		if (curlun->registered) {
+			device_remove_file(&curlun->dev, &dev_attr_file);
+			device_unregister(&curlun->dev);
+			curlun->registered = 0;
+		}
+	}
+
+	/* If the thread isn't already dead, tell it to exit now */
+	if (fsg->state != FSG_STATE_TERMINATED) {
+		raise_exception(fsg, FSG_STATE_EXIT);
+		wait_for_completion(&fsg->thread_notifier);
+
+		/* The cleanup routine waits for this completion also */
+		complete(&fsg->thread_notifier);
+	}
+
+	/* Free the data buffers */
+	for (i = 0; i < NUM_BUFFERS; ++i)
+		kfree(fsg->buffhds[i].buf);
+	switch_dev_unregister(&fsg->sdev);
+}
+
+static int
+fsg_function_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct fsg_dev	*fsg = func_to_dev(f);
+	int			rc;
+	int			i;
+	int			id;
+	struct lun		*curlun;
+	struct usb_ep		*ep;
+	char			*pathbuf, *p;
+
+	fsg->cdev = cdev;
+	DBG(fsg, "fsg_function_bind\n");
+
+	dev_attr_file.attr.mode = 0644;
+
+	/* Find out how many LUNs there should be */
+	i = fsg->nluns;
+	if (i == 0)
+		i = 1;
+	if (i > MAX_LUNS) {
+		ERROR(fsg, "invalid number of LUNs: %d\n", i);
+		rc = -EINVAL;
+		goto out;
+	}
+
+	/* Create the LUNs, open their backing files, and register the
+	 * LUN devices in sysfs. */
+	fsg->luns = kzalloc(i * sizeof(struct lun), GFP_KERNEL);
+	if (!fsg->luns) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	fsg->nluns = i;
+
+	for (i = 0; i < fsg->nluns; ++i) {
+		curlun = &fsg->luns[i];
+		curlun->ro = 0;
+		curlun->dev.release = lun_release;
+		/* use "usb_mass_storage" platform device as parent if available */
+		if (fsg->pdev)
+			curlun->dev.parent = &fsg->pdev->dev;
+		else
+			curlun->dev.parent = &cdev->gadget->dev;
+		dev_set_drvdata(&curlun->dev, fsg);
+		dev_set_name(&curlun->dev,"lun%d", i);
+
+		rc = device_register(&curlun->dev);
+		if (rc != 0) {
+			INFO(fsg, "failed to register LUN%d: %d\n", i, rc);
+			goto out;
+		}
+		rc = device_create_file(&curlun->dev, &dev_attr_file);
+		if (rc != 0) {
+			ERROR(fsg, "device_create_file failed: %d\n", rc);
+			device_unregister(&curlun->dev);
+			goto out;
+		}
+		curlun->registered = 1;
+		kref_get(&fsg->ref);
+	}
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	intf_desc.bInterfaceNumber = id;
+
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_bulk_in_desc);
+	if (!ep)
+		goto autoconf_fail;
+	ep->driver_data = fsg;		/* claim the endpoint */
+	fsg->bulk_in = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_bulk_out_desc);
+	if (!ep)
+		goto autoconf_fail;
+	ep->driver_data = fsg;		/* claim the endpoint */
+	fsg->bulk_out = ep;
+
+	rc = -ENOMEM;
+
+	if (gadget_is_dualspeed(cdev->gadget)) {
+		/* Assume endpoint addresses are the same for both speeds */
+		hs_bulk_in_desc.bEndpointAddress =
+				fs_bulk_in_desc.bEndpointAddress;
+		hs_bulk_out_desc.bEndpointAddress =
+				fs_bulk_out_desc.bEndpointAddress;
+
+		f->hs_descriptors = hs_function;
+	}
+
+	/* Allocate the data buffers */
+	for (i = 0; i < NUM_BUFFERS; ++i) {
+		struct fsg_buffhd	*bh = &fsg->buffhds[i];
+
+		/* Allocate for the bulk-in endpoint.  We assume that
+		 * the buffer will also work with the bulk-out (and
+		 * interrupt-in) endpoint. */
+		bh->buf = kmalloc(fsg->buf_size, GFP_KERNEL);
+		if (!bh->buf)
+			goto out;
+		bh->next = bh + 1;
+	}
+	fsg->buffhds[NUM_BUFFERS - 1].next = &fsg->buffhds[0];
+
+	fsg->thread_task = kthread_create(fsg_main_thread, fsg,
+			shortname);
+	if (IS_ERR(fsg->thread_task)) {
+		rc = PTR_ERR(fsg->thread_task);
+		ERROR(fsg, "kthread_create failed: %d\n", rc);
+		goto out;
+	}
+
+	INFO(fsg, "Number of LUNs=%d\n", fsg->nluns);
+
+	pathbuf = kmalloc(PATH_MAX, GFP_KERNEL);
+	for (i = 0; i < fsg->nluns; ++i) {
+		curlun = &fsg->luns[i];
+		if (backing_file_is_open(curlun)) {
+			p = NULL;
+			if (pathbuf) {
+				p = d_path(&curlun->filp->f_path,
+					   pathbuf, PATH_MAX);
+				if (IS_ERR(p))
+					p = NULL;
+			}
+			LINFO(curlun, "ro=%d, file: %s\n",
+					curlun->ro, (p ? p : "(error)"));
+		}
+	}
+	kfree(pathbuf);
+
+	set_bit(REGISTERED, &fsg->atomic_bitflags);
+
+	/* Tell the thread to start working */
+	wake_up_process(fsg->thread_task);
+	return 0;
+
+autoconf_fail:
+	ERROR(fsg, "unable to autoconfigure all endpoints\n");
+	rc = -ENOTSUPP;
+
+out:
+	DBG(fsg, "fsg_function_bind failed: %d\n", rc);
+	fsg->state = FSG_STATE_TERMINATED;	/* The thread is dead */
+	fsg_function_unbind(c, f);
+	close_all_backing_files(fsg);
+	return rc;
+}
+
+static int fsg_function_set_alt(struct usb_function *f,
+		unsigned intf, unsigned alt)
+{
+	struct fsg_dev	*fsg = func_to_dev(f);
+	DBG(fsg, "fsg_function_set_alt intf: %d alt: %d\n", intf, alt);
+	fsg->new_config = 1;
+	raise_exception(fsg, FSG_STATE_CONFIG_CHANGE);
+	return 0;
+}
+
+static void fsg_function_disable(struct usb_function *f)
+{
+	struct fsg_dev	*fsg = func_to_dev(f);
+	DBG(fsg, "fsg_function_disable\n");
+	fsg->new_config = 0;
+	raise_exception(fsg, FSG_STATE_CONFIG_CHANGE);
+}
+
+static int __init fsg_probe(struct platform_device *pdev)
+{
+	struct usb_mass_storage_platform_data *pdata = pdev->dev.platform_data;
+	struct fsg_dev *fsg = the_fsg;
+
+	fsg->pdev = pdev;
+	printk(KERN_INFO "fsg_probe pdata: %p\n", pdata);
+
+	if (pdata) {
+		if (pdata->vendor)
+			fsg->vendor = pdata->vendor;
+
+		if (pdata->product)
+			fsg->product = pdata->product;
+
+		if (pdata->release)
+			fsg->release = pdata->release;
+		fsg->nluns = pdata->nluns;
+	}
+
+	return 0;
+}
+
+static struct platform_driver fsg_platform_driver = {
+	.driver = { .name = "usb_mass_storage", },
+	.probe = fsg_probe,
+};
+
+int mass_storage_bind_config(struct usb_configuration *c)
+{
+	int		rc;
+	struct fsg_dev	*fsg;
+
+	printk(KERN_INFO "mass_storage_bind_config\n");
+	rc = fsg_alloc();
+	if (rc)
+		return rc;
+	fsg = the_fsg;
+
+	spin_lock_init(&fsg->lock);
+	init_rwsem(&fsg->filesem);
+	kref_init(&fsg->ref);
+	init_completion(&fsg->thread_notifier);
+
+	the_fsg->buf_size = BULK_BUFFER_SIZE;
+	the_fsg->sdev.name = DRIVER_NAME;
+	the_fsg->sdev.print_name = print_switch_name;
+	the_fsg->sdev.print_state = print_switch_state;
+	rc = switch_dev_register(&the_fsg->sdev);
+	if (rc < 0)
+		goto err_switch_dev_register;
+
+	rc = platform_driver_register(&fsg_platform_driver);
+	if (rc != 0)
+		goto err_platform_driver_register;
+
+	wake_lock_init(&the_fsg->wake_lock, WAKE_LOCK_SUSPEND,
+			   "usb_mass_storage");
+
+	fsg->cdev = c->cdev;
+	fsg->function.name = shortname;
+	fsg->function.descriptors = fs_function;
+	fsg->function.bind = fsg_function_bind;
+	fsg->function.unbind = fsg_function_unbind;
+	fsg->function.setup = fsg_function_setup;
+	fsg->function.set_alt = fsg_function_set_alt;
+	fsg->function.disable = fsg_function_disable;
+
+	rc = usb_add_function(c, &fsg->function);
+	if (rc != 0)
+		goto err_usb_add_function;
+
+
+	return 0;
+
+err_usb_add_function:
+	wake_lock_destroy(&the_fsg->wake_lock);
+	platform_driver_unregister(&fsg_platform_driver);
+err_platform_driver_register:
+	switch_dev_unregister(&the_fsg->sdev);
+err_switch_dev_register:
+	kref_put(&the_fsg->ref, fsg_release);
+
+	return rc;
+}
+
+static struct android_usb_function mass_storage_function = {
+	.name = "usb_mass_storage",
+	.bind_config = mass_storage_bind_config,
+};
+
+static int __init init(void)
+{
+	printk(KERN_INFO "f_mass_storage init\n");
+	android_register_function(&mass_storage_function);
+	return 0;
+}
+module_init(init);
+
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/f_rndis.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/f_rndis.c
--- linux-2.6.32-orig/drivers/usb/gadget/f_rndis.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/f_rndis.c	2010-11-18 21:05:30.000000000 +0600
@@ -23,8 +23,9 @@
 /* #define VERBOSE_DEBUG */
 
 #include <linux/kernel.h>
-#include <linux/device.h>
+#include <linux/platform_device.h>
 #include <linux/etherdevice.h>
+#include <linux/usb/android_composite.h>
 
 #include <asm/atomic.h>
 
@@ -126,9 +127,16 @@
 	/* .bInterfaceNumber = DYNAMIC */
 	/* status endpoint is optional; this could be patched later */
 	.bNumEndpoints =	1,
+#ifdef CONFIG_USB_ANDROID_RNDIS_WCEIS
+	/* "Wireless" RNDIS; auto-detected by Windows */
+	.bInterfaceClass =	USB_CLASS_WIRELESS_CONTROLLER,
+	.bInterfaceSubClass = 1,
+	.bInterfaceProtocol =	3,
+#else
 	.bInterfaceClass =	USB_CLASS_COMM,
 	.bInterfaceSubClass =   USB_CDC_SUBCLASS_ACM,
 	.bInterfaceProtocol =   USB_CDC_ACM_PROTO_VENDOR,
+#endif
 	/* .iInterface = DYNAMIC */
 };
 
@@ -284,6 +292,10 @@
 	NULL,
 };
 
+#ifdef CONFIG_USB_ANDROID_RNDIS
+static struct usb_ether_platform_data *rndis_pdata;
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 static struct sk_buff *rndis_add_header(struct gether *port,
@@ -467,10 +479,10 @@
 			usb_ep_disable(rndis->notify);
 		} else {
 			VDBG(cdev, "init rndis ctrl %d\n", intf);
-			rndis->notify_desc = ep_choose(cdev->gadget,
-					rndis->hs.notify,
-					rndis->fs.notify);
 		}
+		rndis->notify_desc = ep_choose(cdev->gadget,
+				rndis->hs.notify,
+				rndis->fs.notify);
 		usb_ep_enable(rndis->notify, rndis->notify_desc);
 		rndis->notify->driver_data = rndis;
 
@@ -484,11 +496,11 @@
 
 		if (!rndis->port.in) {
 			DBG(cdev, "init rndis\n");
-			rndis->port.in = ep_choose(cdev->gadget,
-					rndis->hs.in, rndis->fs.in);
-			rndis->port.out = ep_choose(cdev->gadget,
-					rndis->hs.out, rndis->fs.out);
 		}
+		rndis->port.in = ep_choose(cdev->gadget,
+				rndis->hs.in, rndis->fs.in);
+		rndis->port.out = ep_choose(cdev->gadget,
+				rndis->hs.out, rndis->fs.out);
 
 		/* Avoid ZLPs; they can be troublesome. */
 		rndis->port.is_zlp_ok = false;
@@ -686,11 +698,12 @@
 	rndis_set_param_medium(rndis->config, NDIS_MEDIUM_802_3, 0);
 	rndis_set_host_mac(rndis->config, rndis->ethaddr);
 
-#if 0
-// FIXME
-	if (rndis_set_param_vendor(rndis->config, vendorID,
-				manufacturer))
-		goto fail0;
+#ifdef CONFIG_USB_ANDROID_RNDIS
+	if (rndis_pdata) {
+		if (rndis_set_param_vendor(rndis->config, rndis_pdata->vendorID,
+					rndis_pdata->vendorDescr))
+			goto fail;
+	}
 #endif
 
 	/* NOTE:  all that is done without knowing or caring about
@@ -825,6 +838,11 @@
 	rndis->port.func.setup = rndis_setup;
 	rndis->port.func.disable = rndis_disable;
 
+#ifdef CONFIG_USB_ANDROID_RNDIS
+	/* start disabled */
+	rndis->port.func.disabled = 1;
+#endif
+
 	status = usb_add_function(c, &rndis->port.func);
 	if (status) {
 		kfree(rndis);
@@ -833,3 +851,54 @@
 	}
 	return status;
 }
+
+#ifdef CONFIG_USB_ANDROID_RNDIS
+#include "rndis.c"
+
+static int __init rndis_probe(struct platform_device *pdev)
+{
+	rndis_pdata = pdev->dev.platform_data;
+	return 0;
+}
+
+static struct platform_driver rndis_platform_driver = {
+	.driver = { .name = "rndis", },
+	.probe = rndis_probe,
+};
+
+int rndis_function_bind_config(struct usb_configuration *c)
+{
+	int ret;
+
+	if (!rndis_pdata) {
+		printk(KERN_ERR "rndis_pdata null in rndis_function_bind_config\n");
+		return -1;
+	}
+
+	printk(KERN_INFO
+		"rndis_function_bind_config MAC: %02X:%02X:%02X:%02X:%02X:%02X\n",
+		rndis_pdata->ethaddr[0], rndis_pdata->ethaddr[1],
+		rndis_pdata->ethaddr[2], rndis_pdata->ethaddr[3],
+		rndis_pdata->ethaddr[4], rndis_pdata->ethaddr[5]);
+
+	ret = gether_setup(c->cdev->gadget, rndis_pdata->ethaddr);
+	if (ret == 0)
+		ret = rndis_bind_config(c, rndis_pdata->ethaddr);
+	return ret;
+}
+
+static struct android_usb_function rndis_function = {
+	.name = "rndis",
+	.bind_config = rndis_function_bind_config,
+};
+
+static int __init init(void)
+{
+	printk(KERN_INFO "f_rndis init\n");
+	platform_driver_register(&rndis_platform_driver);
+	android_register_function(&rndis_function);
+	return 0;
+}
+module_init(init);
+
+#endif /* CONFIG_USB_ANDROID_RNDIS */
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/Kconfig
--- linux-2.6.32-orig/drivers/usb/gadget/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -295,6 +295,7 @@
 	boolean "S3C HS/OtG USB Device controller"
 	depends on S3C_DEV_USB_HSOTG
 	select USB_GADGET_S3C_HSOTG_PIO
+	select USB_GADGET_DUALSPEED
 	help
 	  The Samsung S3C64XX USB2.0 high-speed gadget controller
 	  integrated into the S3C64XX series SoC.
@@ -505,6 +506,37 @@
 	select USB_GADGET_SELECTED
 
 
+config USB_GADGET_DWC_OTG
+	boolean "Synopsys DWC OTG Controller"
+	select USB_GADGET_DUALSPEED
+	help
+	   This driver provides USB Device Controller support for the
+	   Synopsys DesignWare USB OTG Core used on the AMCC 405EZ/405EX/
+	   460EX.
+
+	   Note that on the 405EZ, this Core provides USB Device Controller
+	   function only.  It does not act as a true OTG device, and the
+	   'OTG' is slightly misleading.
+
+config USB_DWC_OTG
+	tristate
+	depends on USB_GADGET_DWC_OTG
+	default USB_GADGET
+	select USB_GADGET_SELECTED
+
+config USB_DWC_OTG_INTERNAL_DMA
+	boolean "Synopsys DWC OTG internal DMA Mode"
+	depends on USB_GADGET_DWC_OTG
+	default USB_GADGET
+	help
+	   Enable this DWC internal DMA mode for USB host mode operation.
+
+	   Currently we are still seeing problems with this internal DMA
+	   mode and some USB gadget device drivers in USB device mode.
+	   These gadgets are: ethernet gadget and zero gadget. For those
+	   gagdets, please disable the internal DMA mode (use slave mode)
+	   for now.
+
 #
 # LAST -- dummy/emulated controller
 #
@@ -780,6 +812,48 @@
 	  For more information, see Documentation/usb/gadget_printer.txt
 	  which includes sample code for accessing the device file.
 
+config USB_ANDROID
+	boolean "Android Gadget"
+	depends on SWITCH
+	help
+	  The Android gadget driver supports multiple USB functions.
+	  The functions can be configured via a board file and may be
+	  enabled and disabled dynamically.
+
+config USB_ANDROID_ACM
+	boolean "Android gadget ACM serial function"
+	depends on USB_ANDROID
+	help
+	  Provides ACM serial function for android gadget driver.
+
+config USB_ANDROID_ADB
+	boolean "Android gadget adb function"
+	depends on USB_ANDROID
+	help
+	  Provides adb function for android gadget driver.
+
+config USB_ANDROID_MASS_STORAGE
+	boolean "Android gadget mass storage function"
+	depends on USB_ANDROID && SWITCH
+	help
+	  Provides USB mass storage function for android gadget driver.
+
+config USB_ANDROID_RNDIS
+	boolean "Android gadget RNDIS ethernet function"
+	depends on USB_ANDROID
+	help
+	  Provides RNDIS ethernet function for android gadget driver.
+
+config USB_ANDROID_RNDIS_WCEIS
+        boolean "Use Windows Internet Sharing Class/SubClass/Protocol"
+        depends on USB_ANDROID_RNDIS
+        help
+         Causes the driver to look like a Windows-compatible Internet
+         Sharing device, so Windows auto-detects it.
+
+         If you enable this option, the device is no longer CDC ethernet
+         compatible.
+
 config USB_CDC_COMPOSITE
 	tristate "CDC Composite Device (Ethernet and ACM)"
 	depends on NET
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/Makefile
--- linux-2.6.32-orig/drivers/usb/gadget/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -26,6 +26,7 @@
 obj-$(CONFIG_USB_R8A66597)	+= r8a66597-udc.o
 obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
 obj-$(CONFIG_USB_CI13XXX)	+= ci13xxx_udc.o
+obj-$(CONFIG_USB_DWC_OTG)	+= dwc_otg/
 obj-$(CONFIG_USB_S3C_HSOTG)	+= s3c-hsotg.o
 obj-$(CONFIG_USB_LANGWELL)	+= langwell_udc.o
 
@@ -51,4 +52,9 @@
 obj-$(CONFIG_USB_G_PRINTER)	+= g_printer.o
 obj-$(CONFIG_USB_MIDI_GADGET)	+= g_midi.o
 obj-$(CONFIG_USB_CDC_COMPOSITE) += g_cdc.o
+obj-$(CONFIG_USB_ANDROID)	+= android.o
+obj-$(CONFIG_USB_ANDROID_ACM)	+= f_acm.o u_serial.o
+obj-$(CONFIG_USB_ANDROID_ADB)	+= f_adb.o
+obj-$(CONFIG_USB_ANDROID_MASS_STORAGE)	+= f_mass_storage.o
+obj-$(CONFIG_USB_ANDROID_RNDIS)	+= f_rndis.o u_ether.o
 
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/s3c-hsotg.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/s3c-hsotg.c
--- linux-2.6.32-orig/drivers/usb/gadget/s3c-hsotg.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/s3c-hsotg.c	2010-11-18 21:05:30.000000000 +0600
@@ -33,6 +33,8 @@
 #include <plat/regs-sys.h>
 #include <plat/udc-hs.h>
 
+#include <mach/iphone-clock.h>
+
 #define DMA_ADDR_INVALID (~((dma_addr_t)0))
 
 /* EP0_MPS_LIMIT
@@ -117,7 +119,8 @@
 	char			name[10];
 };
 
-#define S3C_HSOTG_EPS	(8+1)	/* limit to 9 for the moment */
+//#define S3C_HSOTG_EPS	(8+1)	/* limit to 9 for the moment */
+#define S3C_HSOTG_EPS	(6)
 
 /**
  * struct s3c_hsotg - driver state.
@@ -296,19 +299,18 @@
  */
 static void s3c_hsotg_init_fifo(struct s3c_hsotg *hsotg)
 {
-	/* the ryu 2.6.24 release ahs
+	// the ryu 2.6.24 release ahs
 	   writel(0x1C0, hsotg->regs + S3C_GRXFSIZ);
 	   writel(S3C_GNPTXFSIZ_NPTxFStAddr(0x200) |
 		S3C_GNPTXFSIZ_NPTxFDep(0x1C0),
 		hsotg->regs + S3C_GNPTXFSIZ);
-	*/
 
 	/* set FIFO sizes to 2048/0x1C0 */
 
-	writel(2048, hsotg->regs + S3C_GRXFSIZ);
+/*	writel(2048, hsotg->regs + S3C_GRXFSIZ);
 	writel(S3C_GNPTXFSIZ_NPTxFStAddr(2048) |
 	       S3C_GNPTXFSIZ_NPTxFDep(0x1C0),
-	       hsotg->regs + S3C_GNPTXFSIZ);
+	       hsotg->regs + S3C_GNPTXFSIZ);*/
 }
 
 /**
@@ -470,17 +472,6 @@
 		to_write = can_write;
 		pkt_round = to_write % hs_ep->ep.maxpacket;
 
-		/* Not sure, but we probably shouldn't be writing partial
-		 * packets into the FIFO, so round the write down to an
-		 * exact number of packets.
-		 *
-		 * Note, we do not currently check to see if we can ever
-		 * write a full packet or not to the FIFO.
-		 */
-
-		if (pkt_round)
-			to_write -= pkt_round;
-
 		/* enable correct FIFO interrupt to alert us when there
 		 * is more room left. */
 
@@ -999,6 +990,8 @@
 	return 1;
 }
 
+static void s3c_hsotg_enqueue_setup(struct s3c_hsotg *hsotg);
+
 /**
  * s3c_hsotg_process_control - process a control request
  * @hsotg: The device state
@@ -1097,11 +1090,10 @@
 
 		/* don't belive we need to anything more to get the EP
 		 * to reply with a STALL packet */
+		s3c_hsotg_enqueue_setup(hsotg);
 	}
 }
 
-static void s3c_hsotg_enqueue_setup(struct s3c_hsotg *hsotg);
-
 /**
  * s3c_hsotg_complete_setup - completion of a setup transfer
  * @ep: The endpoint the request was on.
@@ -1687,9 +1679,9 @@
 	u32 epctl_reg = dir_in ? S3C_DIEPCTL(idx) : S3C_DOEPCTL(idx);
 	u32 epsiz_reg = dir_in ? S3C_DIEPTSIZ(idx) : S3C_DOEPTSIZ(idx);
 	u32 ints;
-	u32 clear = 0;
 
 	ints = readl(hsotg->regs + epint_reg);
+	writel(ints, hsotg->regs + epint_reg);
 
 	dev_dbg(hsotg->dev, "%s: ep%d(%s) DxEPINT=0x%08x\n",
 		__func__, idx, dir_in ? "in" : "out", ints);
@@ -1713,18 +1705,14 @@
 
 			s3c_hsotg_handle_outdone(hsotg, idx, false);
 		}
-
-		clear |= S3C_DxEPINT_XferCompl;
 	}
 
 	if (ints & S3C_DxEPINT_EPDisbld) {
 		dev_dbg(hsotg->dev, "%s: EPDisbld\n", __func__);
-		clear |= S3C_DxEPINT_EPDisbld;
 	}
 
 	if (ints & S3C_DxEPINT_AHBErr) {
 		dev_dbg(hsotg->dev, "%s: AHBErr\n", __func__);
-		clear |= S3C_DxEPINT_AHBErr;
 	}
 
 	if (ints & S3C_DxEPINT_Setup) {  /* Setup or Timeout */
@@ -1741,13 +1729,10 @@
 			else
 				s3c_hsotg_handle_outdone(hsotg, 0, true);
 		}
-
-		clear |= S3C_DxEPINT_Setup;
 	}
 
 	if (ints & S3C_DxEPINT_Back2BackSetup) {
 		dev_dbg(hsotg->dev, "%s: B2BSetup/INEPNakEff\n", __func__);
-		clear |= S3C_DxEPINT_Back2BackSetup;
 	}
 
 	if (dir_in) {
@@ -1756,18 +1741,14 @@
 		if (ints & S3C_DIEPMSK_INTknTXFEmpMsk) {
 			dev_dbg(hsotg->dev, "%s: ep%d: INTknTXFEmpMsk\n",
 				__func__, idx);
-			clear |= S3C_DIEPMSK_INTknTXFEmpMsk;
 		}
 
 		/* this probably means something bad is happening */
 		if (ints & S3C_DIEPMSK_INTknEPMisMsk) {
 			dev_warn(hsotg->dev, "%s: ep%d: INTknEP\n",
 				 __func__, idx);
-			clear |= S3C_DIEPMSK_INTknEPMisMsk;
 		}
 	}
-
-	writel(clear, hsotg->regs + epint_reg);
 }
 
 /**
@@ -2119,7 +2100,10 @@
 	/* if we've had fifo events, we should try and go around the
 	 * loop again to see if there's any point in returning yet. */
 
-	if (gintsts & IRQ_RETRY_MASK && --retry_count > 0)
+	gintsts = readl(hsotg->regs + S3C_GINTSTS);
+	gintmsk = readl(hsotg->regs + S3C_GINTMSK);
+
+	if (gintsts & gintmsk && --retry_count > 0)
 			goto irq_retry;
 
 	return IRQ_HANDLED;
@@ -2748,6 +2732,7 @@
 
 static void s3c_hsotg_dump(struct s3c_hsotg *hsotg)
 {
+#ifdef IPHONE_DEBUG
 	struct device *dev = hsotg->dev;
 	void __iomem *regs = hsotg->regs;
 	u32 val;
@@ -2790,6 +2775,7 @@
 
 	dev_info(dev, "DVBUSDIS=0x%08x, DVBUSPULSE=%08x\n",
 		 readl(regs + S3C_DVBUSDIS), readl(regs + S3C_DVBUSPULSE));
+#endif
 }
 
 
@@ -3078,7 +3064,19 @@
  */
 static void s3c_hsotg_gate(struct platform_device *pdev, bool on)
 {
-	unsigned long flags;
+	if(on)
+	{
+		iphone_power_ctrl(IPHONE_USB_POWER, on);
+		mdelay(10);
+		iphone_clock_gate_switch(IPHONE_USB_CLOCK, on);
+		iphone_clock_gate_switch(IPHONE_USBPHY_CLOCK, on);
+	} else
+	{
+		iphone_clock_gate_switch(IPHONE_USB_CLOCK, on);
+		iphone_clock_gate_switch(IPHONE_USBPHY_CLOCK, on);
+		iphone_power_ctrl(IPHONE_USB_POWER, on);
+	}
+/*	unsigned long flags;
 	u32 others;
 
 	local_irq_save(flags);
@@ -3090,7 +3088,7 @@
 		others &= ~S3C64XX_OTHERS_USBMASK;
 	__raw_writel(others, S3C64XX_OTHERS);
 
-	local_irq_restore(flags);
+	local_irq_restore(flags);*/
 }
 
 struct s3c_hsotg_plat s3c_hsotg_default_pdata;
@@ -3150,12 +3148,6 @@
 
 	hsotg->irq = ret;
 
-	ret = request_irq(ret, s3c_hsotg_irq, 0, dev_name(dev), hsotg);
-	if (ret < 0) {
-		dev_err(dev, "cannot claim IRQ\n");
-		goto err_regs;
-	}
-
 	dev_info(dev, "regs %p, irq %d\n", hsotg->regs, hsotg->irq);
 
 	device_initialize(&hsotg->gadget.dev);
@@ -3199,6 +3191,12 @@
 
 	s3c_hsotg_dump(hsotg);
 
+	ret = request_irq(ret, s3c_hsotg_irq, 0, dev_name(dev), hsotg);
+	if (ret < 0) {
+		dev_err(dev, "cannot claim IRQ\n");
+		goto err_regs;
+	}
+
 	our_hsotg = hsotg;
 	return 0;
 
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/serial.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/serial.c
--- linux-2.6.32-orig/drivers/usb/gadget/serial.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/serial.c	2010-11-18 21:05:30.000000000 +0600
@@ -123,7 +123,7 @@
 MODULE_AUTHOR("David Brownell");
 MODULE_LICENSE("GPL");
 
-static int use_acm = true;
+static int use_acm = false;
 module_param(use_acm, bool, 0);
 MODULE_PARM_DESC(use_acm, "Use CDC ACM, default=yes");
 
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/u_ether.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/u_ether.c
--- linux-2.6.32-orig/drivers/usb/gadget/u_ether.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/u_ether.c	2010-11-18 21:05:30.000000000 +0600
@@ -941,7 +941,6 @@
 	struct eth_dev		*dev = link->ioport;
 	struct usb_request	*req;
 
-	WARN_ON(!dev);
 	if (!dev)
 		return;
 
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/u_ether.h iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/u_ether.h
--- linux-2.6.32-orig/drivers/usb/gadget/u_ether.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/u_ether.h	2010-11-18 21:05:30.000000000 +0600
@@ -112,7 +112,7 @@
 int ecm_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN]);
 int eem_bind_config(struct usb_configuration *c);
 
-#ifdef CONFIG_USB_ETH_RNDIS
+#if defined(CONFIG_USB_ETH_RNDIS) || defined(CONFIG_USB_ANDROID_RNDIS)
 
 int rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN]);
 
diff -Nur linux-2.6.32-orig/drivers/usb/gadget/u_serial.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/u_serial.c
--- linux-2.6.32-orig/drivers/usb/gadget/u_serial.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/gadget/u_serial.c	2010-11-18 21:05:30.000000000 +0600
@@ -23,6 +23,7 @@
 #include <linux/delay.h>
 #include <linux/tty.h>
 #include <linux/tty_flip.h>
+#include <linux/sched.h>
 
 #include "u_serial.h"
 
diff -Nur linux-2.6.32-orig/drivers/usb/host/ehci-hcd.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/host/ehci-hcd.c
--- linux-2.6.32-orig/drivers/usb/host/ehci-hcd.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/host/ehci-hcd.c	2010-11-18 21:05:30.000000000 +0600
@@ -785,9 +785,10 @@
 
 			/* start 20 msec resume signaling from this port,
 			 * and make khubd collect PORT_STAT_C_SUSPEND to
-			 * stop that signaling.
+			 * stop that signaling.  Use 5 ms extra for safety,
+			 * like usb_port_resume() does.
 			 */
-			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
+			ehci->reset_done[i] = jiffies + msecs_to_jiffies(25);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
 			mod_timer(&hcd->rh_timer, ehci->reset_done[i]);
 		}
diff -Nur linux-2.6.32-orig/drivers/usb/host/ehci-hub.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/host/ehci-hub.c
--- linux-2.6.32-orig/drivers/usb/host/ehci-hub.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/host/ehci-hub.c	2010-11-18 21:05:30.000000000 +0600
@@ -120,9 +120,26 @@
 	del_timer_sync(&ehci->watchdog);
 	del_timer_sync(&ehci->iaa_watchdog);
 
-	port = HCS_N_PORTS (ehci->hcs_params);
 	spin_lock_irq (&ehci->lock);
 
+	/* Once the controller is stopped, port resumes that are already
+	 * in progress won't complete.  Hence if remote wakeup is enabled
+	 * for the root hub and any ports are in the middle of a resume or
+	 * remote wakeup, we must fail the suspend.
+	 */
+	if (hcd->self.root_hub->do_remote_wakeup) {
+		port = HCS_N_PORTS(ehci->hcs_params);
+		while (port--) {
+			if (ehci->reset_done[port] != 0) {
+				spin_unlock_irq(&ehci->lock);
+				ehci_dbg(ehci, "suspend failed because "
+						"port %d is resuming\n",
+						port + 1);
+				return -EBUSY;
+			}
+		}
+	}
+
 	/* stop schedules, clean any completed work */
 	if (HC_IS_RUNNING(hcd->state)) {
 		ehci_quiesce (ehci);
@@ -138,6 +155,7 @@
 	 */
 	ehci->bus_suspended = 0;
 	ehci->owned_ports = 0;
+	port = HCS_N_PORTS(ehci->hcs_params);
 	while (port--) {
 		u32 __iomem	*reg = &ehci->regs->port_status [port];
 		u32		t1 = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;
diff -Nur linux-2.6.32-orig/drivers/usb/host/ehci-q.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/host/ehci-q.c
--- linux-2.6.32-orig/drivers/usb/host/ehci-q.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/host/ehci-q.c	2010-11-18 21:05:30.000000000 +0600
@@ -827,9 +827,10 @@
 				 * But interval 1 scheduling is simpler, and
 				 * includes high bandwidth.
 				 */
-				dbg ("intr period %d uframes, NYET!",
-						urb->interval);
-				goto done;
+				urb->interval = 1;
+			} else if (qh->period > ehci->periodic_size) {
+				qh->period = ehci->periodic_size;
+				urb->interval = qh->period << 3;
 			}
 		} else {
 			int		think_time;
@@ -852,6 +853,10 @@
 					usb_calc_bus_time (urb->dev->speed,
 					is_input, 0, max_packet (maxp)));
 			qh->period = urb->interval;
+			if (qh->period > ehci->periodic_size) {
+				qh->period = ehci->periodic_size;
+				urb->interval = qh->period;
+			}
 		}
 	}
 
diff -Nur linux-2.6.32-orig/drivers/usb/host/r8a66597-hcd.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/host/r8a66597-hcd.c
--- linux-2.6.32-orig/drivers/usb/host/r8a66597-hcd.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/host/r8a66597-hcd.c	2010-11-18 21:05:30.000000000 +0600
@@ -35,7 +35,9 @@
 #include <linux/usb.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
+#include <linux/mm.h>
 #include <linux/irq.h>
+#include <asm/cacheflush.h>
 
 #include "../core/hcd.h"
 #include "r8a66597.h"
@@ -216,8 +218,17 @@
 {
 	int port;
 
+	/* disable interrupts */
 	r8a66597_write(r8a66597, 0, INTENB0);
-	r8a66597_write(r8a66597, 0, INTSTS0);
+	r8a66597_write(r8a66597, 0, INTENB1);
+	r8a66597_write(r8a66597, 0, BRDYENB);
+	r8a66597_write(r8a66597, 0, BEMPENB);
+	r8a66597_write(r8a66597, 0, NRDYENB);
+
+	/* clear status */
+	r8a66597_write(r8a66597, 0, BRDYSTS);
+	r8a66597_write(r8a66597, 0, NRDYSTS);
+	r8a66597_write(r8a66597, 0, BEMPSTS);
 
 	for (port = 0; port < r8a66597->max_root_hub; port++)
 		r8a66597_disable_port(r8a66597, port);
@@ -811,6 +822,26 @@
 	enable_r8a66597_pipe_dma(r8a66597, dev, pipe, urb);
 }
 
+static void r8a66597_urb_done(struct r8a66597 *r8a66597, struct urb *urb,
+			      int status)
+__releases(r8a66597->lock)
+__acquires(r8a66597->lock)
+{
+	if (usb_pipein(urb->pipe) && usb_pipetype(urb->pipe) != PIPE_CONTROL) {
+		void *ptr;
+
+		for (ptr = urb->transfer_buffer;
+		     ptr < urb->transfer_buffer + urb->transfer_buffer_length;
+		     ptr += PAGE_SIZE)
+			flush_dcache_page(virt_to_page(ptr));
+	}
+
+	usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);
+	spin_unlock(&r8a66597->lock);
+	usb_hcd_giveback_urb(r8a66597_to_hcd(r8a66597), urb, status);
+	spin_lock(&r8a66597->lock);
+}
+
 /* this function must be called with interrupt disabled */
 static void force_dequeue(struct r8a66597 *r8a66597, u16 pipenum, u16 address)
 {
@@ -831,15 +862,9 @@
 		list_del(&td->queue);
 		kfree(td);
 
-		if (urb) {
-			usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597),
-					urb);
-
-			spin_unlock(&r8a66597->lock);
-			usb_hcd_giveback_urb(r8a66597_to_hcd(r8a66597), urb,
-					-ENODEV);
-			spin_lock(&r8a66597->lock);
-		}
+		if (urb)
+			r8a66597_urb_done(r8a66597, urb, -ENODEV);
+
 		break;
 	}
 }
@@ -1276,10 +1301,7 @@
 		if (usb_pipeisoc(urb->pipe))
 			urb->start_frame = r8a66597_get_frame(hcd);
 
-		usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);
-		spin_unlock(&r8a66597->lock);
-		usb_hcd_giveback_urb(hcd, urb, status);
-		spin_lock(&r8a66597->lock);
+		r8a66597_urb_done(r8a66597, urb, status);
 	}
 
 	if (restart) {
@@ -2470,6 +2492,12 @@
 	r8a66597->rh_timer.data = (unsigned long)r8a66597;
 	r8a66597->reg = (unsigned long)reg;
 
+	/* make sure no interrupts are pending */
+	ret = r8a66597_clock_enable(r8a66597);
+	if (ret < 0)
+		goto clean_up3;
+	disable_controller(r8a66597);
+
 	for (i = 0; i < R8A66597_MAX_NUM_PIPE; i++) {
 		INIT_LIST_HEAD(&r8a66597->pipe_queue[i]);
 		init_timer(&r8a66597->td_timer[i]);
diff -Nur linux-2.6.32-orig/drivers/usb/host/uhci-hcd.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/host/uhci-hcd.c
--- linux-2.6.32-orig/drivers/usb/host/uhci-hcd.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/host/uhci-hcd.c	2010-11-18 21:05:30.000000000 +0600
@@ -749,7 +749,20 @@
 	spin_lock_irq(&uhci->lock);
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags))
 		rc = -ESHUTDOWN;
-	else if (!uhci->dead)
+	else if (uhci->dead)
+		;		/* Dead controllers tell no tales */
+
+	/* Once the controller is stopped, port resumes that are already
+	 * in progress won't complete.  Hence if remote wakeup is enabled
+	 * for the root hub and any ports are in the middle of a resume or
+	 * remote wakeup, we must fail the suspend.
+	 */
+	else if (hcd->self.root_hub->do_remote_wakeup &&
+			uhci->resuming_ports) {
+		dev_dbg(uhci_dev(uhci), "suspend failed because a port "
+				"is resuming\n");
+		rc = -EBUSY;
+	} else
 		suspend_rh(uhci, UHCI_RH_SUSPENDED);
 	spin_unlock_irq(&uhci->lock);
 	return rc;
diff -Nur linux-2.6.32-orig/drivers/usb/host/uhci-hub.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/host/uhci-hub.c
--- linux-2.6.32-orig/drivers/usb/host/uhci-hub.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/host/uhci-hub.c	2010-11-18 21:05:30.000000000 +0600
@@ -167,7 +167,7 @@
 				/* Port received a wakeup request */
 				set_bit(port, &uhci->resuming_ports);
 				uhci->ports_timeout = jiffies +
-						msecs_to_jiffies(20);
+						msecs_to_jiffies(25);
 
 				/* Make sure we see the port again
 				 * after the resuming period is over. */
diff -Nur linux-2.6.32-orig/drivers/usb/misc/appledisplay.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/misc/appledisplay.c
--- linux-2.6.32-orig/drivers/usb/misc/appledisplay.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/misc/appledisplay.c	2010-11-18 21:05:30.000000000 +0600
@@ -72,8 +72,8 @@
 	struct usb_device *udev;	/* usb device */
 	struct urb *urb;		/* usb request block */
 	struct backlight_device *bd;	/* backlight device */
-	char *urbdata;			/* interrupt URB data buffer */
-	char *msgdata;			/* control message data buffer */
+	u8 *urbdata;			/* interrupt URB data buffer */
+	u8 *msgdata;			/* control message data buffer */
 
 	struct delayed_work work;
 	int button_pressed;
diff -Nur linux-2.6.32-orig/drivers/usb/misc/emi62.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/misc/emi62.c
--- linux-2.6.32-orig/drivers/usb/misc/emi62.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/misc/emi62.c	2010-11-18 21:05:30.000000000 +0600
@@ -167,7 +167,7 @@
 			err("%s - error loading firmware: error = %d", __func__, err);
 			goto wraperr;
 		}
-	} while (i > 0);
+	} while (rec);
 
 	/* Assert reset (stop the CPU in the EMI) */
 	err = emi62_set_reset(dev,1);
diff -Nur linux-2.6.32-orig/drivers/usb/musb/musb_gadget_ep0.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/musb/musb_gadget_ep0.c
--- linux-2.6.32-orig/drivers/usb/musb/musb_gadget_ep0.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/musb/musb_gadget_ep0.c	2010-11-18 21:05:30.000000000 +0600
@@ -199,7 +199,6 @@
 static void musb_g_ep0_giveback(struct musb *musb, struct usb_request *req)
 {
 	musb_g_giveback(&musb->endpoints[0].ep_in, req, 0);
-	musb->ep0_state = MUSB_EP0_STAGE_SETUP;
 }
 
 /*
@@ -648,7 +647,7 @@
 			musb->ep0_state = MUSB_EP0_STAGE_STATUSIN;
 			break;
 		default:
-			ERR("SetupEnd came in a wrong ep0stage %s",
+			ERR("SetupEnd came in a wrong ep0stage %s\n",
 			    decode_ep0stage(musb->ep0_state));
 		}
 		csr = musb_readw(regs, MUSB_CSR0);
@@ -771,12 +770,18 @@
 				handled = service_zero_data_request(
 						musb, &setup);
 
+				/*
+				 * We're expecting no data in any case, so
+				 * always set the DATAEND bit -- doing this
+				 * here helps avoid SetupEnd interrupt coming
+				 * in the idle stage when we're stalling...
+				 */
+				musb->ackpend |= MUSB_CSR0_P_DATAEND;
+
 				/* status stage might be immediate */
-				if (handled > 0) {
-					musb->ackpend |= MUSB_CSR0_P_DATAEND;
+				if (handled > 0)
 					musb->ep0_state =
 						MUSB_EP0_STAGE_STATUSIN;
-				}
 				break;
 
 			/* sequence #1 (IN to host), includes GET_STATUS
diff -Nur linux-2.6.32-orig/drivers/usb/serial/ftdi_sio.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/serial/ftdi_sio.c
--- linux-2.6.32-orig/drivers/usb/serial/ftdi_sio.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/serial/ftdi_sio.c	2010-11-18 21:05:30.000000000 +0600
@@ -598,6 +598,20 @@
 	{ USB_DEVICE(BANDB_VID, BANDB_USOTL4_PID) },
 	{ USB_DEVICE(BANDB_VID, BANDB_USTL4_PID) },
 	{ USB_DEVICE(BANDB_VID, BANDB_USO9ML2_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_USOPTL4_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_USPTL4_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_USO9ML2DR_2_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_USO9ML2DR_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_USOPTL4DR2_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_USOPTL4DR_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_485USB9F_2W_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_485USB9F_4W_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_232USB9M_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_485USBTB_2W_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_485USBTB_4W_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_TTL5USB9M_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_TTL3USB9M_PID) },
+	{ USB_DEVICE(BANDB_VID, BANDB_ZZ_PROG1_USB_PID) },
 	{ USB_DEVICE(FTDI_VID, EVER_ECO_PRO_CDS) },
 	{ USB_DEVICE(FTDI_VID, FTDI_4N_GALAXY_DE_1_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_4N_GALAXY_DE_2_PID) },
diff -Nur linux-2.6.32-orig/drivers/usb/serial/ftdi_sio.h iDroid-Project-kernel_common-9e90fd2/drivers/usb/serial/ftdi_sio.h
--- linux-2.6.32-orig/drivers/usb/serial/ftdi_sio.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/serial/ftdi_sio.h	2010-11-18 21:05:30.000000000 +0600
@@ -662,6 +662,20 @@
 #define BANDB_USOTL4_PID	0xAC01	/* USOTL4 Isolated RS-485 Converter */
 #define BANDB_USTL4_PID		0xAC02	/* USTL4 RS-485 Converter */
 #define BANDB_USO9ML2_PID	0xAC03	/* USO9ML2 Isolated RS-232 Converter */
+#define BANDB_USOPTL4_PID	0xAC11
+#define BANDB_USPTL4_PID	0xAC12
+#define BANDB_USO9ML2DR_2_PID	0xAC16
+#define BANDB_USO9ML2DR_PID	0xAC17
+#define BANDB_USOPTL4DR2_PID	0xAC18	/* USOPTL4R-2 2-port Isolated RS-232 Converter */
+#define BANDB_USOPTL4DR_PID	0xAC19
+#define BANDB_485USB9F_2W_PID	0xAC25
+#define BANDB_485USB9F_4W_PID	0xAC26
+#define BANDB_232USB9M_PID	0xAC27
+#define BANDB_485USBTB_2W_PID	0xAC33
+#define BANDB_485USBTB_4W_PID	0xAC34
+#define BANDB_TTL5USB9M_PID	0xAC49
+#define BANDB_TTL3USB9M_PID	0xAC50
+#define BANDB_ZZ_PROG1_USB_PID	0xBA02
 
 /*
  * RM Michaelides CANview USB (http://www.rmcan.com)
diff -Nur linux-2.6.32-orig/drivers/usb/serial/generic.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/serial/generic.c
--- linux-2.6.32-orig/drivers/usb/serial/generic.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/serial/generic.c	2010-11-18 21:05:30.000000000 +0600
@@ -489,6 +489,8 @@
 	dbg("%s - port %d", __func__, port->number);
 
 	if (port->serial->type->max_in_flight_urbs) {
+		kfree(urb->transfer_buffer);
+
 		spin_lock_irqsave(&port->lock, flags);
 		--port->urbs_in_flight;
 		port->tx_bytes_flight -= urb->transfer_buffer_length;
diff -Nur linux-2.6.32-orig/drivers/usb/serial/mos7840.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/serial/mos7840.c
--- linux-2.6.32-orig/drivers/usb/serial/mos7840.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/serial/mos7840.c	2010-11-18 21:05:30.000000000 +0600
@@ -121,8 +121,14 @@
  * moschip_id_table_combined
  */
 #define USB_VENDOR_ID_BANDB             0x0856
-#define BANDB_DEVICE_ID_USOPTL4_4       0xAC44
+#define BANDB_DEVICE_ID_USO9ML2_2	0xAC22
+#define BANDB_DEVICE_ID_USO9ML2_4	0xAC24
+#define BANDB_DEVICE_ID_US9ML2_2	0xAC29
+#define BANDB_DEVICE_ID_US9ML2_4	0xAC30
+#define BANDB_DEVICE_ID_USPTL4_2	0xAC31
+#define BANDB_DEVICE_ID_USPTL4_4	0xAC32
 #define BANDB_DEVICE_ID_USOPTL4_2       0xAC42
+#define BANDB_DEVICE_ID_USOPTL4_4       0xAC44
 
 /* This driver also supports
  * ATEN UC2324 device using Moschip MCS7840
@@ -177,8 +183,14 @@
 static struct usb_device_id moschip_port_id_table[] = {
 	{USB_DEVICE(USB_VENDOR_ID_MOSCHIP, MOSCHIP_DEVICE_ID_7840)},
 	{USB_DEVICE(USB_VENDOR_ID_MOSCHIP, MOSCHIP_DEVICE_ID_7820)},
-	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USOPTL4_4)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USO9ML2_2)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USO9ML2_4)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_US9ML2_2)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_US9ML2_4)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USPTL4_2)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USPTL4_4)},
 	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USOPTL4_2)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USOPTL4_4)},
 	{USB_DEVICE(USB_VENDOR_ID_ATENINTL, ATENINTL_DEVICE_ID_UC2324)},
 	{USB_DEVICE(USB_VENDOR_ID_ATENINTL, ATENINTL_DEVICE_ID_UC2322)},
 	{}			/* terminating entry */
@@ -187,8 +199,14 @@
 static __devinitdata struct usb_device_id moschip_id_table_combined[] = {
 	{USB_DEVICE(USB_VENDOR_ID_MOSCHIP, MOSCHIP_DEVICE_ID_7840)},
 	{USB_DEVICE(USB_VENDOR_ID_MOSCHIP, MOSCHIP_DEVICE_ID_7820)},
-	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USOPTL4_4)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USO9ML2_2)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USO9ML2_4)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_US9ML2_2)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_US9ML2_4)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USPTL4_2)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USPTL4_4)},
 	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USOPTL4_2)},
+	{USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USOPTL4_4)},
 	{USB_DEVICE(USB_VENDOR_ID_ATENINTL, ATENINTL_DEVICE_ID_UC2324)},
 	{USB_DEVICE(USB_VENDOR_ID_ATENINTL, ATENINTL_DEVICE_ID_UC2322)},
 	{}			/* terminating entry */
diff -Nur linux-2.6.32-orig/drivers/usb/serial/option.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/serial/option.c
--- linux-2.6.32-orig/drivers/usb/serial/option.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/serial/option.c	2010-11-18 21:05:30.000000000 +0600
@@ -340,6 +340,10 @@
 #define FOUR_G_SYSTEMS_VENDOR_ID		0x1c9e
 #define FOUR_G_SYSTEMS_PRODUCT_W14		0x9603
 
+/* Haier products */
+#define HAIER_VENDOR_ID				0x201e
+#define HAIER_PRODUCT_CE100			0x2009
+
 static struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
@@ -580,12 +584,48 @@
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0086, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0104, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0106, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0108, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0113, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0117, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0122, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0128, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0142, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0143, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0144, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0145, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0146, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0147, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0148, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0149, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0150, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0151, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0152, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0153, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0154, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0155, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0156, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0159, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0160, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0161, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0162, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0014, 0xff, 0xff, 0xff) }, /* ZTE CDMA products */
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0027, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0059, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0060, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0070, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_CDMA_TECH, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_AC8710, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_AC2726, 0xff, 0xff, 0xff) },
@@ -599,11 +639,13 @@
 	{ USB_DEVICE(TOSHIBA_VENDOR_ID, TOSHIBA_PRODUCT_G450) },
 	{ USB_DEVICE(TOSHIBA_VENDOR_ID, TOSHIBA_PRODUCT_HSDPA_MINICARD ) }, /* Toshiba 3G HSDPA == Novatel Expedite EU870D MiniCard */
 	{ USB_DEVICE(ALINK_VENDOR_ID, 0x9000) },
+	{ USB_DEVICE(ALINK_VENDOR_ID, 0xce16) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ALINK_VENDOR_ID, ALINK_PRODUCT_3GU, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_X060S) },
 	{ USB_DEVICE(AIRPLUS_VENDOR_ID, AIRPLUS_PRODUCT_MCD650) },
 	{ USB_DEVICE(TLAYTECH_VENDOR_ID, TLAYTECH_PRODUCT_TEU800) },
 	{ USB_DEVICE(FOUR_G_SYSTEMS_VENDOR_ID, FOUR_G_SYSTEMS_PRODUCT_W14) },
+	{ USB_DEVICE(HAIER_VENDOR_ID, HAIER_PRODUCT_CE100) },
 	{ } /* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, option_ids);
diff -Nur linux-2.6.32-orig/drivers/usb/storage/transport.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/storage/transport.c
--- linux-2.6.32-orig/drivers/usb/storage/transport.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/storage/transport.c	2010-11-18 21:05:30.000000000 +0600
@@ -666,10 +666,11 @@
 	 * to wait for at least one CHECK_CONDITION to determine
 	 * SANE_SENSE support
 	 */
-	if ((srb->cmnd[0] == ATA_16 || srb->cmnd[0] == ATA_12) &&
+	if (unlikely((srb->cmnd[0] == ATA_16 || srb->cmnd[0] == ATA_12) &&
 	    result == USB_STOR_TRANSPORT_GOOD &&
 	    !(us->fflags & US_FL_SANE_SENSE) &&
-	    !(srb->cmnd[2] & 0x20)) {
+	    !(us->fflags & US_FL_BAD_SENSE) &&
+	    !(srb->cmnd[2] & 0x20))) {
 		US_DEBUGP("-- SAT supported, increasing auto-sense\n");
 		us->fflags |= US_FL_SANE_SENSE;
 	}
@@ -718,6 +719,12 @@
 		if (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) {
 			US_DEBUGP("-- auto-sense aborted\n");
 			srb->result = DID_ABORT << 16;
+
+			/* If SANE_SENSE caused this problem, disable it */
+			if (sense_size != US_SENSE_SIZE) {
+				us->fflags &= ~US_FL_SANE_SENSE;
+				us->fflags |= US_FL_BAD_SENSE;
+			}
 			goto Handle_Errors;
 		}
 
@@ -727,10 +734,11 @@
 		 * (small) sense request. This fixes some USB GSM modems
 		 */
 		if (temp_result == USB_STOR_TRANSPORT_FAILED &&
-		    (us->fflags & US_FL_SANE_SENSE) &&
-		    sense_size != US_SENSE_SIZE) {
+				sense_size != US_SENSE_SIZE) {
 			US_DEBUGP("-- auto-sense failure, retry small sense\n");
 			sense_size = US_SENSE_SIZE;
+			us->fflags &= ~US_FL_SANE_SENSE;
+			us->fflags |= US_FL_BAD_SENSE;
 			goto Retry_Sense;
 		}
 
@@ -754,6 +762,7 @@
 		 */
 		if (srb->sense_buffer[7] > (US_SENSE_SIZE - 8) &&
 		    !(us->fflags & US_FL_SANE_SENSE) &&
+		    !(us->fflags & US_FL_BAD_SENSE) &&
 		    (srb->sense_buffer[0] & 0x7C) == 0x70) {
 			US_DEBUGP("-- SANE_SENSE support enabled\n");
 			us->fflags |= US_FL_SANE_SENSE;
diff -Nur linux-2.6.32-orig/drivers/usb/storage/unusual_devs.h iDroid-Project-kernel_common-9e90fd2/drivers/usb/storage/unusual_devs.h
--- linux-2.6.32-orig/drivers/usb/storage/unusual_devs.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/storage/unusual_devs.h	2010-11-18 21:05:30.000000000 +0600
@@ -818,6 +818,13 @@
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_FIX_CAPACITY ),
 
+/* Reported by Daniel Kukula <daniel.kuku@gmail.com> */
+UNUSUAL_DEV( 0x067b, 0x1063, 0x0100, 0x0100,
+		"Prolific Technology, Inc.",
+		"Prolific Storage Gadget",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_BAD_SENSE ),
+
 /* Reported by Rogerio Brito <rbrito@ime.usp.br> */
 UNUSUAL_DEV( 0x067b, 0x2317, 0x0001, 0x001,
 		"Prolific Technology, Inc.",
@@ -1800,13 +1807,6 @@
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_GO_SLOW ),
 
-/* Reported by Rohan Hart <rohan.hart17@gmail.com> */
-UNUSUAL_DEV(  0x2770, 0x915d, 0x0010, 0x0010,
-		"INTOVA",
-		"Pixtreme",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY ),
-
 /* Reported by Frederic Marchal <frederic.marchal@wowcompany.com>
  * Mio Moov 330
  */
diff -Nur linux-2.6.32-orig/drivers/usb/storage/usb.c iDroid-Project-kernel_common-9e90fd2/drivers/usb/storage/usb.c
--- linux-2.6.32-orig/drivers/usb/storage/usb.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/usb/storage/usb.c	2010-11-18 21:05:30.000000000 +0600
@@ -228,6 +228,7 @@
 	if (data_len<36) // You lose.
 		return;
 
+	memset(data+8, ' ', 28);
 	if(data[0]&0x20) { /* USB device currently not connected. Return
 			      peripheral qualifier 001b ("...however, the
 			      physical device is not currently connected
@@ -237,15 +238,15 @@
 			      device, it may return zeros or ASCII spaces 
 			      (20h) in those fields until the data is
 			      available from the device."). */
-		memset(data+8,0,28);
 	} else {
 		u16 bcdDevice = le16_to_cpu(us->pusb_dev->descriptor.bcdDevice);
-		memcpy(data+8, us->unusual_dev->vendorName, 
-			strlen(us->unusual_dev->vendorName) > 8 ? 8 :
-			strlen(us->unusual_dev->vendorName));
-		memcpy(data+16, us->unusual_dev->productName, 
-			strlen(us->unusual_dev->productName) > 16 ? 16 :
-			strlen(us->unusual_dev->productName));
+		int n;
+
+		n = strlen(us->unusual_dev->vendorName);
+		memcpy(data+8, us->unusual_dev->vendorName, min(8, n));
+		n = strlen(us->unusual_dev->productName);
+		memcpy(data+16, us->unusual_dev->productName, min(16, n));
+
 		data[32] = 0x30 + ((bcdDevice>>12) & 0x0F);
 		data[33] = 0x30 + ((bcdDevice>>8) & 0x0F);
 		data[34] = 0x30 + ((bcdDevice>>4) & 0x0F);
@@ -429,7 +430,8 @@
 	u16 vid = le16_to_cpu(us->pusb_dev->descriptor.idVendor);
 	u16 pid = le16_to_cpu(us->pusb_dev->descriptor.idProduct);
 	unsigned f = 0;
-	unsigned int mask = (US_FL_SANE_SENSE | US_FL_FIX_CAPACITY |
+	unsigned int mask = (US_FL_SANE_SENSE | US_FL_BAD_SENSE |
+			US_FL_FIX_CAPACITY |
 			US_FL_CAPACITY_HEURISTICS | US_FL_IGNORE_DEVICE |
 			US_FL_NOT_LOCKABLE | US_FL_MAX_SECTORS_64 |
 			US_FL_CAPACITY_OK | US_FL_IGNORE_RESIDUE |
@@ -459,6 +461,9 @@
 		case 'a':
 			f |= US_FL_SANE_SENSE;
 			break;
+		case 'b':
+			f |= US_FL_BAD_SENSE;
+			break;
 		case 'c':
 			f |= US_FL_FIX_CAPACITY;
 			break;
diff -Nur linux-2.6.32-orig/drivers/video/backlight/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/video/backlight/Kconfig
--- linux-2.6.32-orig/drivers/video/backlight/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/backlight/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -148,6 +148,13 @@
 	  known as the Corgi backlight driver. If you have a Sharp Zaurus
 	  SL-C7xx, SL-Cxx00 or SL-6000x say y.
 
+config BACKLIGHT_PCF50633
+	tristate "PCF50633 Backlight support (used in iPhone 2G/3G)."
+	depends on BACKLIGHT_CLASS_DEVICE && MFD_PCF50633
+	default n
+	help
+	   Say y to enable the iPhone/iPod backlight support.
+
 config BACKLIGHT_LOCOMO
 	tristate "Sharp LOCOMO LCD/Backlight Driver"
 	depends on BACKLIGHT_CLASS_DEVICE && SHARP_LOCOMO
diff -Nur linux-2.6.32-orig/drivers/video/backlight/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/video/backlight/Makefile
--- linux-2.6.32-orig/drivers/video/backlight/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/backlight/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -28,4 +28,5 @@
 obj-$(CONFIG_BACKLIGHT_WM831X)	+= wm831x_bl.o
 obj-$(CONFIG_BACKLIGHT_ADX)    += adx_bl.o
 obj-$(CONFIG_BACKLIGHT_ADP5520)	+= adp5520_bl.o
+obj-$(CONFIG_BACKLIGHT_PCF50633)	+= pcf50633_bl.o
 
diff -Nur linux-2.6.32-orig/drivers/video/backlight/pcf50633_bl.c iDroid-Project-kernel_common-9e90fd2/drivers/video/backlight/pcf50633_bl.c
--- linux-2.6.32-orig/drivers/video/backlight/pcf50633_bl.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/backlight/pcf50633_bl.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,131 @@
+/*
+ *  Backlight Driver for the PCF50633 PMU
+ *
+ *  Copyright (c) 2010 Ricky Taylor
+ *  Portions (c) Patrick Wildt, Claudio Nieder.
+ *
+ *  Based on iphone_bl.c by Patrick Wildt
+ *  Based on kb6886_bl.c by Claudio Nieder
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+
+#include <linux/mfd/pcf50633/core.h>
+
+#include <mach/pmu.h>
+
+#define LCD_MAX_BACKLIGHT 45
+#define LCD_DEFAULT_BACKLIGHT 25
+#define LCD_BACKLIGHT_REGMASK 0x3F
+
+static struct pcf50633 *pcf50633;
+static int pcf50633_bl_intensity;
+static struct backlight_device *pcf50633_bl_device;
+
+static int pcf50633_bl_send_intensity(struct backlight_device *bd)
+{
+	int intensity = bd->props.brightness;
+
+	if (bd->props.power != FB_BLANK_UNBLANK)
+		intensity = 0;
+
+	if (bd->props.fb_blank != FB_BLANK_UNBLANK)
+		intensity = 0;
+
+	if(intensity <= 0)
+	{
+		pcf50633_reg_write(pcf50633, PCF50633_REG_LEDENA, 0);
+		pcf50633_reg_write(pcf50633, PCF50633_REG_LEDCTL, 0);
+	}
+	else
+	{
+		pcf50633_reg_write(pcf50633, PCF50633_REG_LEDENA, 1);
+		pcf50633_reg_write(pcf50633, PCF50633_REG_LEDOUT, intensity & LCD_BACKLIGHT_REGMASK);
+		pcf50633_reg_write(pcf50633, PCF50633_REG_LEDCTL, 6);
+	}
+
+	pcf50633_bl_intensity = intensity;
+	return 0;
+}
+
+static int pcf50633_bl_get_intensity(struct backlight_device *bd)
+{
+	return pcf50633_bl_intensity;
+}
+
+static struct backlight_ops pcf50633_bl_ops = {
+	.get_brightness = pcf50633_bl_get_intensity,
+	.update_status  = pcf50633_bl_send_intensity,
+};
+
+static int pcf50633_bl_probe(struct platform_device *pdev)
+{
+	pcf50633 = pdev->dev.platform_data;
+
+	//pcf50633_bl_device = backlight_device_register("pcf50633-backlight",
+	pcf50633_bl_device = backlight_device_register("iphone-bl",
+		&pdev->dev, NULL, &pcf50633_bl_ops);
+	if (IS_ERR(pcf50633_bl_device))
+		return PTR_ERR(pcf50633_bl_device);
+
+	platform_set_drvdata(pdev, pcf50633_bl_device);
+
+	pcf50633_bl_device->props.max_brightness = LCD_MAX_BACKLIGHT;
+	pcf50633_bl_device->props.power = FB_BLANK_UNBLANK;
+	pcf50633_bl_device->props.brightness = LCD_DEFAULT_BACKLIGHT;
+	backlight_update_status(pcf50633_bl_device);
+
+	pcf50633_reg_write(pcf50633, PCF50633_REG_LEDENA, 1);
+	pcf50633_reg_write(pcf50633, PCF50633_REG_LEDOUT, LCD_DEFAULT_BACKLIGHT);
+	pcf50633_reg_write(pcf50633, PCF50633_REG_LEDCTL, 6);
+	pcf50633_reg_write(pcf50633, PCF50633_REG_LEDDIM, 0x20); // Dimming curve
+
+	dev_info(&pdev->dev, "loaded backlight driver.\n");
+
+	return 0;
+}
+
+static int pcf50633_bl_remove(struct platform_device *pdev)
+{
+	struct backlight_device *bd = platform_get_drvdata(pdev);
+
+	backlight_device_unregister(bd);
+
+	return 0;
+}
+
+static struct platform_driver pcf50633_bl_driver = {
+	.probe		= pcf50633_bl_probe,
+	.remove		= pcf50633_bl_remove,
+	.driver		= {
+		.name	= "pcf50633-backlight",
+	},
+};
+
+static int __init mod_init(void)
+{
+	return platform_driver_register(&pcf50633_bl_driver);
+}
+
+static void __exit mod_exit(void)
+{
+	platform_driver_unregister(&pcf50633_bl_driver);
+}
+
+module_init(mod_init);
+module_exit(mod_exit);
+
+MODULE_AUTHOR("Ricky Taylor <rickytaylor26@gmail.com>");
+MODULE_DESCRIPTION("PCF50633 Backlight Driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/drivers/video/imxfb.c iDroid-Project-kernel_common-9e90fd2/drivers/video/imxfb.c
--- linux-2.6.32-orig/drivers/video/imxfb.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/imxfb.c	2010-11-18 21:05:30.000000000 +0600
@@ -593,7 +593,8 @@
  */
 static int imxfb_suspend(struct platform_device *dev, pm_message_t state)
 {
-	struct imxfb_info *fbi = platform_get_drvdata(dev);
+	struct fb_info *info = platform_get_drvdata(dev);
+	struct imxfb_info *fbi = info->par;
 
 	pr_debug("%s\n", __func__);
 
@@ -603,7 +604,8 @@
 
 static int imxfb_resume(struct platform_device *dev)
 {
-	struct imxfb_info *fbi = platform_get_drvdata(dev);
+	struct fb_info *info = platform_get_drvdata(dev);
+	struct imxfb_info *fbi = info->par;
 
 	pr_debug("%s\n", __func__);
 
diff -Nur linux-2.6.32-orig/drivers/video/iphone-fb.c iDroid-Project-kernel_common-9e90fd2/drivers/video/iphone-fb.c
--- linux-2.6.32-orig/drivers/video/iphone-fb.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/iphone-fb.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,610 @@
+/*
+ * iphone-fb.c - A framebuffer driver for the iPhone LCD screen.
+ *
+ * Copyright 2010 Ricky Taylor
+ * 	- Added sleep support.
+ *
+ * Copyright 2008 Yidou Wang
+ *
+ * This file is part of iDroid. An android distribution for Apple products.
+ * For more information, please visit http://www.idroidproject.org/.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/completion.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#include <mach/map.h>
+#include <mach/hardware.h>
+#include <mach/iphone-clock.h>
+#include <mach/gpio.h>
+
+#define DEFAULT_WINDOW_NUM 	2
+#define LCD					IO_ADDRESS(0x38900000)
+#define LCD_INTERRUPT 		0xD
+#define LCD_POWER			0x100
+#define LCD_CLOCKGATE1		0x07
+#define LCD_CLOCKGATE2		0x1D
+#define VIDINTCON0			0x14
+#define VIDINTCON1			0x18
+#define BYTES_PER_PIXEL		2
+#define NUMBER_OF_BUFFERS	2
+
+DECLARE_COMPLETION(vsync_completion);
+
+static void iphone_set_fb_address(int window, dma_addr_t address) {
+	u32 windowBase;
+	switch(window) {
+		case 1:
+			windowBase = LCD + 0x58;
+			break;
+		case 2:
+			windowBase = LCD + 0x70;
+			break;
+		case 3:
+			windowBase = LCD + 0x88;
+			break;
+		case 4:
+			windowBase = LCD + 0xA0;
+			break;
+		case 5:
+			windowBase = LCD + 0xB8;
+			break;
+		default:
+			return;
+	}
+
+	__raw_writel(address, windowBase + 8);
+}
+
+/*
+ *  This is just simple sample code.
+ *
+ *  No warranty that it actually compiles.
+ *  Even less warranty that it actually works :-)
+ */
+
+/*
+ * Driver data
+ */
+static void* framebuffer_virtual_memory __devinitdata;
+
+static struct fb_var_screeninfo iphonefb_var __devinitdata = {
+	.xres = 320,
+	.yres = 480,
+	.xres_virtual = 320,
+	.yres_virtual = 480 * NUMBER_OF_BUFFERS,
+	.xoffset = 0,
+	.yoffset = 0,
+	.bits_per_pixel = (BYTES_PER_PIXEL * 8),
+	.grayscale = 0,
+#if (BYTES_PER_PIXEL == 2)
+	.red = {
+		.offset = 11,
+		.length = 5,
+		.msb_right = 0
+	},
+	.blue = {
+		.offset = 0,
+		.length = 5,
+		.msb_right = 0
+	},
+	.green = {
+		.offset = 5,
+		.length = 6,
+		.msb_right = 0
+	},
+#endif
+#if (BYTES_PER_PIXEL == 4)
+	.red = {
+		.offset = 16,
+		.length = 8,
+		.msb_right = 0
+	},
+	.blue = {
+		.offset = 0,
+		.length = 8,
+		.msb_right = 0
+	},
+	.green = {
+		.offset = 8,
+		.length = 8,
+		.msb_right = 0
+	},
+#endif
+	.width = 50,
+	.height = 75,
+	.activate = FB_ACTIVATE_NOW
+};
+
+// TODO: Make this thread-safe!
+static void iphonefb_wait_for_vsync(void)
+{
+	INIT_COMPLETION(vsync_completion);
+
+	/* Clear any already pending interrupts */
+	writel(1, LCD + VIDINTCON1);
+	
+	/* Enable frame interrupts */
+	writel(0x7F01, LCD + VIDINTCON0);
+
+	wait_for_completion(&vsync_completion);
+}
+
+/*
+ *  If your driver supports multiple boards, you should make the
+ *  below data types arrays, or allocate them dynamically (using kmalloc()).
+ */
+
+/*
+ * This structure defines the hardware state of the graphics card. Normally
+ * you place this in a header file in linux/include/video. This file usually
+ * also includes register information. That allows other driver subsystems
+ * and userland applications the ability to use the same header file to
+ * avoid duplicate work and easy porting of software.
+ */
+struct iphonefb_par {
+	u32 palette[16];
+};
+
+/*
+ * Here we define the default structs fb_fix_screeninfo and fb_var_screeninfo
+ * if we don't use modedb. If we do use modedb see iphonefb_init how to use it
+ * to get a fb_var_screeninfo. Otherwise define a default var as well.
+ */
+static struct fb_fix_screeninfo iphonefb_fix __devinitdata = {
+	.id =		"iphonefb",
+	.type =		FB_TYPE_PACKED_PIXELS,
+	.visual =	FB_VISUAL_TRUECOLOR,
+	.ypanstep =	1,
+	.ywrapstep =	0,
+	.line_length =	320 * BYTES_PER_PIXEL,
+	.accel =	FB_ACCEL_NONE,
+};
+
+/*
+ * 	Modern graphical hardware not only supports pipelines but some
+ *  also support multiple monitors where each display can have its
+ *  its own unique data. In this case each display could be
+ *  represented by a separate framebuffer device thus a separate
+ *  struct fb_info. Now the struct iphonefb_par represents the graphics
+ *  hardware state thus only one exist per card. In this case the
+ *  struct iphonefb_par for each graphics card would be shared between
+ *  every struct fb_info that represents a framebuffer on that card.
+ *  This allows when one display changes it video resolution (info->var)
+ *  the other displays know instantly. Each display can always be
+ *  aware of the entire hardware state that affects it because they share
+ *  the same iphonefb_par struct. The other side of the coin is multiple
+ *  graphics cards that pass data around until it is finally displayed
+ *  on one monitor. Such examples are the voodoo 1 cards and high end
+ *  NUMA graphics servers. For this case we have a bunch of pars, each
+ *  one that represents a graphics state, that belong to one struct
+ *  fb_info. Their you would want to have *par point to a array of device
+ *  states and have each struct fb_ops function deal with all those
+ *  states. I hope this covers every possible hardware design. If not
+ *  feel free to send your ideas at jsimmons@users.sf.net
+ */
+
+/*
+ *  If your driver supports multiple boards or it supports multiple
+ *  framebuffers, you should make these arrays, or allocate them
+ *  dynamically using framebuffer_alloc() and free them with
+ *  framebuffer_release().
+ */
+
+/*
+ * Each one represents the state of the hardware. Most hardware have
+ * just one hardware state. These here represent the default state(s).
+ */
+
+int iphonefb_init(void);
+
+static inline u32 convert_bitfield(int val, struct fb_bitfield *bf)
+{
+	unsigned int mask = (1 << bf->length) - 1;
+
+	return (val >> (16 - bf->length) & mask) << bf->offset;
+}
+
+static int iphonefb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info) {
+	if (regno < 16) {
+		u32* pal = (u32*) info->pseudo_palette;
+		pal[regno] = convert_bitfield(blue, &info->var.blue) |
+			convert_bitfield(green, &info->var.green) |
+			convert_bitfield(red, &info->var.red);
+		return 0;
+	}
+	else {
+		return 1;
+	}
+
+}
+
+static int iphonefb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	if((var->rotate & 1) != (info->var.rotate & 1)) {
+		if((var->xres != info->var.yres) ||
+				(var->yres != info->var.xres) ||
+				(var->xres_virtual != info->var.yres) ||
+				(var->yres_virtual >
+				 info->var.xres * NUMBER_OF_BUFFERS) ||
+				(var->yres_virtual < info->var.xres )) {
+			return -EINVAL;
+		}
+	}
+	else {
+		if((var->xres != info->var.xres) ||
+				(var->yres != info->var.yres) ||
+				(var->xres_virtual != info->var.xres) ||
+				(var->yres_virtual >
+				 info->var.yres * NUMBER_OF_BUFFERS) ||
+				(var->yres_virtual < info->var.yres )) {
+			return -EINVAL;
+		}
+	}
+	if((var->xoffset != info->var.xoffset) ||
+			(var->bits_per_pixel != info->var.bits_per_pixel) ||
+			(var->grayscale != info->var.grayscale)) {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int iphonefb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	iphone_set_fb_address(DEFAULT_WINDOW_NUM, info->fix.smem_start + (info->var.xres * BYTES_PER_PIXEL * var->yoffset));
+
+	iphonefb_wait_for_vsync();
+	return 0;
+}
+
+/*
+ *  Frame buffer operations
+ */
+
+static struct fb_ops iphonefb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var   = iphonefb_check_var,
+	.fb_setcolreg   = iphonefb_setcolreg,
+	.fb_pan_display = iphonefb_pan_display,
+	.fb_fillrect	= cfb_fillrect, 	/* Needed !!! */
+	.fb_copyarea	= cfb_copyarea,	/* Needed !!! */
+	.fb_imageblit	= cfb_imageblit,	/* Needed !!! */
+};
+
+
+static irqreturn_t lcd_frame_irq(int irq, void* pToken)
+{
+	/* Clear pending interrupt */
+	writel(1, LCD + VIDINTCON1);
+
+	/* Disable frame interrupt */
+	writel(0x7F00, LCD + VIDINTCON0);
+	
+	/* Notify pan operation */
+	complete_all(&vsync_completion);
+	
+	return IRQ_HANDLED;
+}
+
+/*
+ * Power Management
+ */
+
+
+/**
+ * This function changes the LCD's power state,
+ * never call it. Not ever.
+ *
+ * There is a good reason for this:
+ * We don't have the code for re-initializing the
+ * LCD display, and like hell am I going to port it
+ * from OpeniBoot. -- Ricky26
+ */
+static int iphonefb_power(int _pwr)
+{
+	if(_pwr > 0)
+		iphone_power_ctrl(LCD_POWER, 1);
+
+	iphone_clock_gate_switch(LCD_CLOCKGATE1, _pwr);
+	iphone_clock_gate_switch(LCD_CLOCKGATE2, _pwr);
+
+	if(_pwr <= 0)
+		iphone_power_ctrl(LCD_POWER, 0);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+#ifdef CONFIG_HAS_EARLYSUSPEND
+
+// Guh, DAMN YOU EARLY SUSPEND!
+static struct fb_info *iphone_suspend_info = NULL;
+
+static void iphonefb_early_suspend(struct early_suspend *_susp)
+{
+	if(iphone_suspend_info)
+	{
+		memset(iphone_suspend_info->screen_base, 0xFFFFFFFF, 320*480*4);
+
+		iphonefb_wait_for_vsync();
+		iphonefb_wait_for_vsync();
+	}
+
+	iphone_gpio_pin_output(0x3, 0);
+}
+
+static void iphonefb_late_resume(struct early_suspend *_susp)
+{
+	if(iphone_suspend_info != NULL)
+		memset(iphone_suspend_info->screen_base, 0x00000000, 320*480*4);
+
+	iphone_gpio_custom_io(0x3, 0x2);
+}
+
+struct early_suspend iphone_early_suspend = {
+	.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1,
+	.suspend = &iphonefb_early_suspend,
+	.resume = &iphonefb_late_resume,
+};
+
+#define iphonefb_suspend NULL
+#define iphonefb_resume NULL
+#else
+
+static int iphonefb_suspend(struct platform_device *_pdev, pm_message_t _state)
+{
+	struct fb_info *info = (struct fb_info*)platform_device_get_drvdata(_pdev);
+	if(info != NULL)
+	{
+		memset(info->screen_base, 0xFFFFFFFF, 320*480*4);
+
+		iphonefb_wait_for_vsync();
+		iphonefb_wait_for_vsync();
+	}
+
+	iphone_gpio_pin_output(0x3, 0);
+	return 0;
+}
+
+static int iphonefb_resume(struct platform_device *_pdev)
+{
+	struct fb_info *info = (struct fb_info*)platform_device_get_drvdata(_pdev);
+	if(info != NULL)
+		memset(info->screen_base, 0x00000000, 320*480*4);
+
+	iphone_gpio_custom_io(0x3, 0x2);
+	
+	return 0;
+}
+
+#endif
+#endif
+
+
+/* ------------------------------------------------------------------------- */
+
+/*
+ *  Initialization
+ */
+
+/* static int __init xxfb_probe (struct platform_device *pdev) -- for platform devs */
+static int __init iphonefb_probe(struct platform_device *pdev)
+{
+    struct fb_info *info;
+    struct iphonefb_par *par;
+    struct device *device = &pdev->dev; /* or &pdev->dev */
+    dma_addr_t dma_map;
+    u32 framesize;
+    int ret;
+	
+	iphonefb_power(1);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	register_early_suspend(&iphone_early_suspend);
+#endif
+
+    /* Disable frame interrupts */
+    writel(0x7F00, LCD + 0x14);
+
+    ret = request_irq(LCD_INTERRUPT, lcd_frame_irq, IRQF_DISABLED, "iphonefb", (void*) 0);
+    if(ret)
+	    return ret;
+
+    /*
+     * Dynamically allocate info and par
+     */
+    info = framebuffer_alloc(sizeof(struct iphonefb_par), device);
+    framesize = iphonefb_var.xres_virtual * iphonefb_var.yres_virtual * BYTES_PER_PIXEL;
+    framebuffer_virtual_memory = dma_alloc_writecombine(device, PAGE_ALIGN(framesize), &dma_map, GFP_KERNEL);
+    iphone_set_fb_address(DEFAULT_WINDOW_NUM, dma_map);
+
+    if (!info) {
+	    /* goto error path */
+    }
+
+    par = info->par;
+
+    /*
+     * Here we set the screen_base to the virtual memory address
+     * for the framebuffer. Usually we obtain the resource address
+     * from the bus layer and then translate it to virtual memory
+     * space via ioremap. Consult ioport.h.
+     */
+    info->screen_base = framebuffer_virtual_memory;
+    info->fbops = &iphonefb_ops;
+    info->fix = iphonefb_fix; /* this will be the only time iphonefb_fix will be
+			    * used, so mark it as __devinitdata
+			    */
+
+    info->fix.smem_start = dma_map;
+    info->fix.smem_len = framesize;
+
+    /*
+     * Set up flags to indicate what sort of acceleration your
+     * driver can provide (pan/wrap/copyarea/etc.) and whether it
+     * is a module -- see FBINFO_* in include/linux/fb.h
+     *
+     * If your hardware can support any of the hardware accelerated functions
+     * fbcon performance will improve if info->flags is set properly.
+     *
+     * FBINFO_HWACCEL_COPYAREA - hardware moves
+     * FBINFO_HWACCEL_FILLRECT - hardware fills
+     * FBINFO_HWACCEL_IMAGEBLIT - hardware mono->color expansion
+     * FBINFO_HWACCEL_YPAN - hardware can pan display in y-axis
+     * FBINFO_HWACCEL_YWRAP - hardware can wrap display in y-axis
+     * FBINFO_HWACCEL_DISABLED - supports hardware accels, but disabled
+     * FBINFO_READS_FAST - if set, prefer moves over mono->color expansion
+     * FBINFO_MISC_TILEBLITTING - hardware can do tile blits
+     *
+     * NOTE: These are for fbcon use only.
+     */
+    info->flags = FBINFO_FLAG_DEFAULT;
+
+    /* This has to been done !!! */
+    fb_alloc_cmap(&info->cmap, 256, 0);
+    info->pseudo_palette = ((struct iphonefb_par*) info->par)->palette;
+    /*
+     * The following is done in the case of having hardware with a static
+     * mode. If we are setting the mode ourselves we don't call this.
+     */
+    info->var = iphonefb_var;
+
+    /*
+     * Does a call to fb_set_par() before register_framebuffer needed?  This
+     * will depend on you and the hardware.  If you are sure that your driver
+     * is the only device in the system, a call to fb_set_par() is safe.
+     *
+     * Hardware in x86 systems has a VGA core.  Calling set_par() at this
+     * point will corrupt the VGA console, so it might be safer to skip a
+     * call to set_par here and just allow fbcon to do it for you.
+     */
+    /* iphonefb_set_par(info); */
+
+    if (register_framebuffer(info) < 0)
+	return -EINVAL;
+    printk(KERN_INFO "fb%d: %s frame buffer device\n", info->node,
+	   info->fix.id);
+    platform_set_drvdata(pdev, info);
+
+#ifdef CONFIG_PM
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	// ALERT: DIRTY HACK! -- Ricky26
+	iphone_suspend_info = info;
+#endif
+#endif
+
+    return 0;
+}
+
+    /*
+     *  Cleanup
+     */
+static int __init iphonefb_remove(struct platform_device *pdev)
+{
+	struct fb_info *info = platform_get_drvdata(pdev);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&iphone_early_suspend);
+#endif
+
+	if (info) {
+		unregister_framebuffer(info);
+		fb_dealloc_cmap(&info->cmap);
+		/* ... */
+		kfree(framebuffer_virtual_memory);
+		framebuffer_release(info);
+	}
+	return 0;
+}
+
+/* for platform devices */
+
+static struct platform_driver iphonefb_driver = {
+	.probe = iphonefb_probe,
+	.remove = iphonefb_remove,
+	.suspend = iphonefb_suspend, /* optional but recommended */
+	.resume = iphonefb_resume,   /* optional but recommended */
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "iphonefb",
+	},
+};
+
+static u64 iphonefb_dmamask = ~(u32)0;
+
+static struct platform_device iphonefb_device = {
+	.name = "iphonefb",
+	.id = -1,
+	.dev = {
+		.dma_mask		= &iphonefb_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	}
+};
+
+    /*
+     *  Setup
+     */
+
+int __init iphonefb_init(void)
+{
+	int ret;
+	/*
+	 *  For kernel boot options (in 'video=iphonefb:<options>' format)
+	 */
+	char *option = NULL;
+
+	if (fb_get_options("iphonefb", &option))
+		return -ENODEV;
+
+	ret = platform_driver_register(&iphonefb_driver);
+
+	if (!ret) {
+		ret = platform_device_register(&iphonefb_device);
+
+		if (ret != 0) {
+			platform_driver_unregister(&iphonefb_driver);
+		}
+	}
+
+	return ret;
+}
+
+static void __exit iphonefb_exit(void)
+{
+	platform_device_unregister(&iphonefb_device);
+	platform_driver_unregister(&iphonefb_driver);
+}
+
+module_init(iphonefb_init);
+module_exit(iphonefb_exit);
+
+MODULE_LICENSE("GPL")
diff -Nur linux-2.6.32-orig/drivers/video/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/video/Kconfig
--- linux-2.6.32-orig/drivers/video/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -1880,6 +1880,13 @@
 	depends on FB_TMIO
 	default y
 
+config FB_APPLE_IPHONE
+	tristate "iPhone framebuffer support"
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	select FB_SYS_FOPS
+
 config FB_S3C
 	tristate "Samsung S3C framebuffer support"
 	depends on FB && ARCH_S3C64XX
diff -Nur linux-2.6.32-orig/drivers/video/logo/Kconfig iDroid-Project-kernel_common-9e90fd2/drivers/video/logo/Kconfig
--- linux-2.6.32-orig/drivers/video/logo/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/logo/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -27,6 +27,10 @@
 	bool "Standard 224-color Linux logo"
 	default y
 
+config LOGO_ANDROID_CLUT224
+	bool "Standard 224-color Android logo"
+	default y
+
 config LOGO_BLACKFIN_VGA16
 	bool "16-colour Blackfin Processor Linux logo"
 	depends on BLACKFIN
diff -Nur linux-2.6.32-orig/drivers/video/logo/logo_android_clut224.ppm iDroid-Project-kernel_common-9e90fd2/drivers/video/logo/logo_android_clut224.ppm
--- linux-2.6.32-orig/drivers/video/logo/logo_android_clut224.ppm	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/logo/logo_android_clut224.ppm	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,1123 @@
+P3
+80 80
+255
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  4 5 1  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  3 4 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  45 55 15  22 27 7  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  7 9 2  53 64 18  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  45 55 15  107 131 37  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  81 100 27  74 91 25  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  104 127 35  44 53 15  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  18 22 6  118 144 40  4 5 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  22 27 7  117 143 40  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  98 120 33  48 59 16  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  77 94 26  71 87 24
+0 0 0  0 0 0  0 0 0  0 0 0  10 12 3  37 45 12
+58 71 20  70 85 23  81 99 27  81 100 27  82 100 28  73 90 25
+60 74 21  41 51 14  18 22 6  0 0 0  0 0 0  0 0 0
+0 0 0  38 47 13  99 122 34  7 9 2  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  18 22 6  110 135 37
+9 11 3  8 10 2  59 72 20  99 122 34  123 151 42  138 169 47
+149 182 50  156 191 53  162 199 55  164 201 56  164 201 56  158 194 54
+151 185 51  141 172 48  128 156 44  107 131 36  71 87 24  20 24 6
+0 0 0  100 123 34  37 45 12  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  90 110 31
+139 171 48  131 160 44  150 184 51  164 201 56  165 202 57  164 201 56
+164 201 56  165 202 57  165 202 57  164 201 56  165 202 57  164 201 56
+164 201 56  165 202 57  165 202 57  165 202 57  155 190 53  136 167 47
+131 160 44  126 153 43  9 11 3  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  78 96 26  151 186 51
+165 202 57  165 202 57  165 202 57  165 202 57  163 200 55  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  164 201 56  165 202 57  165 202 57  164 201 56
+164 202 56  163 200 56  97 118 33  8 10 2  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  22 27 7  128 157 44  159 195 54  165 202 57
+163 200 55  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+164 200 56  164 201 56  160 198 54  144 177 50  40 49 13  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  49 60 17  154 188 53  163 200 55  165 202 57  164 201 56
+164 201 56  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  164 201 56  164 201 56  165 202 57  163 199 56  75 93 25
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+59 72 20  159 195 54  164 201 56  163 200 55  165 202 57  164 201 56
+164 201 56  165 202 57  163 200 55  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  164 201 56  165 202 57
+165 202 57  164 201 56  165 202 57  164 201 56  164 201 56  165 202 57
+85 104 29  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  58 72 20
+158 194 54  165 202 57  164 201 56  165 202 57  163 200 55  159 195 54
+158 194 54  162 198 55  165 202 57  164 201 56  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  163 200 55  165 202 57  162 199 55
+160 196 55  158 194 54  162 199 55  163 200 55  164 201 56  165 202 57
+163 200 55  84 103 28  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  36 45 12  148 182 51
+165 202 57  164 201 56  165 202 57  163 200 55  144 177 49  62 76 21
+55 68 19  117 143 39  165 202 57  164 201 56  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  164 201 56  164 201 56  135 165 46
+68 83 23  55 68 19  126 154 43  163 199 56  164 201 56  164 201 56
+165 202 57  158 194 54  62 76 21  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  13 16 4  129 158 44  165 202 57
+165 202 57  163 200 55  165 202 57  161 197 55  58 71 20  0 0 0
+0 0 0  28 34 9  140 171 47  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  164 201 56  159 195 54  52 64 18
+0 0 0  0 0 0  24 29 8  152 186 52  164 201 56  165 202 57
+163 200 55  165 202 57  148 182 51  31 38 10  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  88 108 30  160 197 54  164 201 56
+164 201 56  165 202 57  165 202 57  160 196 55  36 44 12  0 0 0
+0 0 0  23 28 7  127 156 44  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  164 201 56  154 189 53  49 60 16
+0 0 0  0 0 0  10 12 3  150 184 51  165 202 57  165 202 57
+163 200 55  165 202 57  165 202 57  116 142 40  1 2 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  36 44 12  140 171 48  165 202 57  163 200 55
+165 202 57  165 202 57  165 202 57  163 199 56  104 128 35  25 30 8
+25 31 8  72 89 24  156 192 53  164 201 56  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  95 116 32
+25 31 8  21 26 7  79 96 27  158 194 54  165 202 57  165 202 57
+165 202 57  164 201 56  165 202 57  152 186 52  61 75 21  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  89 110 31  165 202 57  164 201 56  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  164 201 56  131 160 45
+128 157 44  154 189 53  164 201 56  163 200 55  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  163 200 55  164 201 56  160 197 54
+129 158 44  122 150 41  161 197 55  165 202 57  163 200 55  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  114 140 39  7 8 2
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  26 32 9  127 156 44  164 201 56  164 201 56  165 202 57
+165 202 57  165 202 57  165 202 57  163 200 55  165 202 57  164 201 56
+165 202 57  164 201 56  163 200 55  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  164 201 56  164 201 56
+165 202 57  165 202 57  164 201 56  164 201 56  163 200 55  165 202 57
+165 202 57  165 202 57  163 200 55  164 201 56  145 178 49  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  58 71 20  159 194 54  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  164 201 56  86 105 29
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  86 105 29  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  164 201 56  165 202 57  111 136 37
+10 13 3  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+14 18 5  108 132 36  164 201 56  163 200 55  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  131 160 45
+31 38 10  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+25 30 8  124 152 43  164 201 56  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  144 177 50
+45 55 15  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+33 41 11  138 170 47  165 202 57  164 201 56  164 201 56  164 201 56
+164 201 56  164 201 56  164 201 56  164 201 56  164 201 56  164 201 56
+164 201 56  164 201 56  164 201 56  164 201 56  164 201 56  164 201 56
+164 201 56  164 201 56  164 201 56  164 201 56  164 201 56  164 201 56
+164 201 56  164 201 56  164 201 56  164 201 56  164 201 56  164 201 56
+164 201 56  164 201 56  164 201 56  164 201 56  164 201 56  164 201 56
+164 201 56  164 201 56  164 201 56  164 201 56  165 202 57  154 189 52
+53 65 18  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+4 5 1  29 35 10  43 52 14  41 51 14  41 51 14  41 51 14
+41 51 14  41 51 14  41 51 14  41 51 14  41 51 14  41 51 14
+41 51 14  41 51 14  41 51 14  41 51 14  41 51 14  41 51 14
+41 51 14  41 51 14  41 51 14  41 51 14  41 51 14  41 51 14
+41 51 14  41 51 14  41 51 14  41 51 14  41 51 14  41 51 14
+41 51 14  41 51 14  41 51 14  41 51 14  41 51 14  41 51 14
+41 51 14  41 51 14  41 51 14  41 51 14  43 53 14  33 41 11
+8 10 2  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  14 17 4  66 81 22
+88 107 30  66 81 22  12 15 4  0 0 0  0 0 0  0 0 0
+0 0 0  1 2 0  2 3 0  1 2 0  1 2 0  1 2 0
+1 2 0  1 2 0  1 2 0  1 2 0  1 2 0  1 2 0
+1 2 0  1 2 0  1 2 0  1 2 0  1 2 0  1 2 0
+1 2 0  1 2 0  1 2 0  1 2 0  1 2 0  1 2 0
+1 2 0  1 2 0  1 2 0  1 2 0  1 2 0  1 2 0
+1 2 0  1 2 0  1 2 0  1 2 0  1 2 0  1 2 0
+1 2 0  1 2 0  1 2 0  1 2 0  2 3 0  1 2 0
+0 0 0  0 0 0  0 0 0  0 0 0  6 7 2  53 65 18
+86 106 29  75 92 26  21 26 7  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  52 64 18  151 185 52  164 201 56
+164 201 56  165 202 57  157 192 54  51 63 17  0 0 0  0 0 0
+18 22 6  88 107 30  117 144 40  113 139 38  113 139 38  113 139 38
+113 139 38  113 139 38  113 139 38  113 139 38  113 139 38  113 139 38
+113 139 38  113 139 38  113 139 38  113 139 38  113 139 38  113 139 38
+113 139 38  113 139 38  113 139 38  113 139 38  113 139 38  113 139 38
+113 139 38  113 139 38  113 139 38  113 139 38  113 139 38  113 139 38
+113 139 38  113 139 38  113 139 38  113 139 38  113 139 38  113 139 38
+113 139 38  113 139 38  113 139 38  113 139 38  115 141 39  99 122 34
+30 37 10  0 0 0  0 0 0  33 40 11  140 171 48  164 201 56
+164 201 56  164 201 56  163 200 56  77 94 26  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  44 54 15  151 185 52  164 201 56  163 200 55
+164 201 56  164 201 56  165 202 57  157 193 54  39 48 13  0 0 0
+35 43 12  140 172 48  164 201 56  164 201 56  164 201 56  164 201 56
+164 201 56  164 201 56  164 201 56  164 201 56  164 201 56  164 201 56
+164 201 56  164 201 56  164 201 56  164 201 56  164 201 56  164 201 56
+164 201 56  164 201 56  164 201 56  164 201 56  164 201 56  164 201 56
+164 201 56  164 201 56  164 201 56  164 201 56  164 201 56  164 201 56
+164 201 56  164 201 56  164 201 56  164 201 56  164 201 56  164 201 56
+164 201 56  164 201 56  164 201 56  164 201 56  165 202 57  157 193 54
+55 67 18  0 0 0  16 19 5  141 173 48  165 202 57  165 202 57
+163 200 55  164 201 56  164 201 56  161 197 55  73 90 25  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  110 135 38  164 201 56  164 201 56  165 202 57
+165 202 57  164 201 56  164 201 56  164 201 56  118 145 40  0 0 0
+33 40 11  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+53 65 18  0 0 0  90 110 31  160 196 54  165 202 57  164 201 56
+165 202 57  165 202 57  164 201 56  164 201 56  135 165 46  10 12 3
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  20 24 6  128 157 43  165 202 57  163 200 55  165 202 57
+165 202 57  165 202 57  163 200 55  164 201 56  140 172 48  8 10 2
+31 38 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+53 64 18  0 0 0  119 146 41  164 201 56  164 201 56  165 202 57
+165 202 57  165 202 57  163 200 55  165 202 57  145 178 50  43 53 14
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  29 35 10  133 163 46  164 201 56  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  18 22 6
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  124 152 42  165 202 57  163 200 55  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 17
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  126 154 43  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 34 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  142 174 49  17 21 5
+30 37 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  125 153 42  164 201 56  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  146 179 50  49 60 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  28 35 9  132 162 45  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  164 201 56  142 174 49  17 21 6
+31 38 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+52 63 17  0 0 0  126 154 43  164 201 56  164 201 56  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  145 178 49  48 59 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  22 26 7  128 157 43  165 202 57  164 201 56  165 202 57
+165 202 57  165 202 57  164 201 56  165 202 57  140 171 47  10 13 3
+31 38 10  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+53 65 18  0 0 0  118 145 40  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  164 201 56  145 178 49  46 57 16
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  115 141 39  164 201 56  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  164 201 56  124 152 42  0 0 0
+33 41 11  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+53 65 18  0 0 0  91 111 31  160 196 54  165 202 57  165 202 57
+165 202 57  165 202 57  164 201 56  164 201 56  135 165 46  16 19 5
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  58 71 20  149 182 50  165 202 57  165 202 57
+164 201 56  164 201 56  165 202 57  154 189 53  53 65 18  0 0 0
+34 41 11  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+53 65 18  0 0 0  23 29 8  142 174 49  164 201 56  165 202 57
+165 202 57  165 202 57  164 201 56  158 193 54  86 106 29  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  72 89 24  150 184 51  162 198 56
+162 199 55  161 197 55  154 189 52  79 96 27  0 0 0  0 0 0
+34 41 11  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+53 65 18  0 0 0  0 0 0  45 56 15  144 176 49  161 198 55
+162 199 55  161 197 55  156 191 53  104 127 35  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  33 40 11  93 114 31
+123 151 42  93 115 32  32 39 10  0 0 0  0 0 0  0 0 0
+34 41 11  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+53 65 18  0 0 0  0 0 0  0 0 0  12 15 4  85 104 29
+120 148 41  101 124 34  47 58 16  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+34 41 11  137 168 47  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  152 186 52
+53 65 18  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+34 41 11  136 167 46  164 201 56  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  164 201 56  154 188 53
+53 65 18  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+30 37 10  132 162 45  164 201 56  163 200 55  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  164 201 56  150 184 52
+50 62 17  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+12 14 4  106 130 36  164 201 56  164 201 56  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  163 200 55  165 202 57  132 162 45
+30 37 10  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  58 71 20  156 191 53  165 202 57  163 200 55  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  163 200 55  165 202 57  164 201 56  86 106 29
+1 1 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  5 7 2  76 93 26  158 194 54  165 202 57  164 201 56
+165 202 57  165 202 57  165 202 57  165 202 57  163 200 55  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  164 201 56
+164 201 56  165 202 57  164 201 56  165 202 57  164 201 56  164 201 56
+164 201 56  164 201 56  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  164 201 56  165 202 57  165 202 57  164 201 56
+165 202 57  165 202 57  164 201 56  165 202 57  106 130 36  16 20 5
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  6 7 2  49 60 17  104 127 35  139 171 48
+143 175 48  144 176 49  143 175 48  163 199 56  164 201 56  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  164 201 56
+154 189 52  144 176 49  143 175 48  144 176 49  144 176 49  144 176 49
+149 183 51  165 202 57  164 201 56  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  163 200 55  165 202 57  145 178 49  143 175 48
+144 176 49  141 173 48  117 143 39  67 82 23  14 17 4  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  11 14 4  21 26 7
+22 27 7  22 27 7  21 26 7  102 125 35  164 201 56  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+56 69 19  21 26 7  22 27 7  22 27 7  22 27 7  22 26 7
+40 49 13  161 197 55  164 201 56  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  164 201 56  141 173 48  27 33 9  22 27 7
+22 27 7  21 26 7  15 19 5  3 3 1  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  86 106 29  164 201 56  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  165 202 57
+34 41 11  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+18 22 6  158 193 54  164 201 56  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  133 163 45  2 3 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  87 107 29  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  164 201 56
+35 43 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+19 23 6  158 193 54  164 201 56  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  133 163 45  3 4 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  88 107 30  164 201 56  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  164 201 56
+35 43 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+19 23 6  159 194 54  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  133 163 45  3 4 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  88 107 30  164 201 56  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  164 201 56
+35 43 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+19 23 6  159 194 54  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  133 163 45  3 4 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  88 107 30  164 201 56  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  164 201 56
+35 43 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+19 23 6  159 194 54  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  133 163 45  3 4 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  88 107 30  164 201 56  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  164 201 56
+35 43 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+19 23 6  159 194 54  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  133 163 45  3 4 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  88 107 30  164 201 56  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  164 201 56
+35 43 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+19 23 6  159 194 54  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  133 163 45  3 4 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  88 107 30  164 201 56  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  164 201 56
+35 43 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+19 23 6  159 194 54  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  133 163 45  3 4 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  88 107 30  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  164 201 56  164 201 56
+35 43 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+20 24 6  159 195 55  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  164 201 56  135 165 46  4 5 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  87 106 30  165 202 57  165 202 57
+165 202 57  165 202 57  165 202 57  165 202 57  165 202 57  164 201 56
+34 42 11  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+18 22 6  155 190 53  165 202 57  165 202 57  165 202 57  165 202 57
+165 202 57  165 202 57  164 201 56  124 152 42  3 4 1  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  50 61 17  165 202 57  164 201 56
+165 202 57  165 202 57  165 202 57  163 200 55  164 201 56  154 188 53
+28 34 9  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+12 15 4  122 150 42  165 202 57  164 201 56  165 202 57  165 202 57
+165 202 57  163 200 55  164 201 56  82 101 28  1 2 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  9 11 3  133 163 45  164 201 56
+164 201 56  165 202 57  164 201 56  164 201 56  165 202 57  88 107 30
+7 9 2  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 2 0  57 70 19  164 201 56  165 202 57  164 201 56  165 202 57
+164 201 56  164 201 56  155 190 53  25 30 8  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  30 37 10  137 168 47
+164 201 56  165 202 57  164 201 56  165 202 57  107 131 37  18 22 6
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  8 10 2  84 103 29  164 201 56  164 201 56  164 201 56
+165 202 57  155 190 53  50 61 17  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  18 22 6
+62 76 21  106 129 36  102 125 35  52 64 18  9 11 3  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  5 7 1  39 48 13  91 111 31  111 136 37
+80 99 27  27 33 9  1 1 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+1 2 0  5 7 1  5 7 2  1 1 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  4 5 1  6 7 2
+3 4 1  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
+0 0 0  0 0 0
diff -Nur linux-2.6.32-orig/drivers/video/logo/logo.c iDroid-Project-kernel_common-9e90fd2/drivers/video/logo/logo.c
--- linux-2.6.32-orig/drivers/video/logo/logo.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/logo/logo.c	2010-11-18 21:05:30.000000000 +0600
@@ -67,6 +67,10 @@
 		/* Generic Linux logo */
 		logo = &logo_linux_clut224;
 #endif
+#ifdef CONFIG_LOGO_ANDROID_CLUT224
+		/* Android 'droid' */
+		logo = &logo_android_clut224;
+#endif
 #ifdef CONFIG_LOGO_BLACKFIN_CLUT224
 		/* Blackfin Linux logo */
 		logo = &logo_blackfin_clut224;
diff -Nur linux-2.6.32-orig/drivers/video/logo/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/video/logo/Makefile
--- linux-2.6.32-orig/drivers/video/logo/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/logo/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -4,6 +4,7 @@
 obj-$(CONFIG_LOGO_LINUX_MONO)		+= logo_linux_mono.o
 obj-$(CONFIG_LOGO_LINUX_VGA16)		+= logo_linux_vga16.o
 obj-$(CONFIG_LOGO_LINUX_CLUT224)	+= logo_linux_clut224.o
+obj-$(CONFIG_LOGO_ANDROID_CLUT224)	+= logo_android_clut224.o
 obj-$(CONFIG_LOGO_BLACKFIN_CLUT224)	+= logo_blackfin_clut224.o
 obj-$(CONFIG_LOGO_BLACKFIN_VGA16)	+= logo_blackfin_vga16.o
 obj-$(CONFIG_LOGO_DEC_CLUT224)		+= logo_dec_clut224.o
diff -Nur linux-2.6.32-orig/drivers/video/Makefile iDroid-Project-kernel_common-9e90fd2/drivers/video/Makefile
--- linux-2.6.32-orig/drivers/video/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -28,6 +28,7 @@
 obj-$(CONFIG_FB_DEFERRED_IO)   += fb_defio.o
 
 # Hardware specific drivers go first
+obj-$(CONFIG_FB_APPLE_IPHONE)     += iphone-fb.o
 obj-$(CONFIG_FB_AMIGA)            += amifb.o c2p_planar.o
 obj-$(CONFIG_FB_ARC)              += arcfb.o
 obj-$(CONFIG_FB_CLPS711X)         += clps711xfb.o
diff -Nur linux-2.6.32-orig/drivers/video/matrox/g450_pll.c iDroid-Project-kernel_common-9e90fd2/drivers/video/matrox/g450_pll.c
--- linux-2.6.32-orig/drivers/video/matrox/g450_pll.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/matrox/g450_pll.c	2010-11-18 21:05:30.000000000 +0600
@@ -368,7 +368,8 @@
 					M1064_XDVICLKCTRL_C1DVICLKEN |
 					M1064_XDVICLKCTRL_DVILOOPCTL |
 					M1064_XDVICLKCTRL_P1LOOPBWDTCTL;
-				matroxfb_DAC_out(minfo, M1064_XDVICLKCTRL, tmp);
+                                /* Setting this breaks PC systems so don't do it */
+				/* matroxfb_DAC_out(minfo, M1064_XDVICLKCTRL, tmp); */
 				matroxfb_DAC_out(minfo, M1064_XPWRCTRL,
 						 xpwrctrl);
 
diff -Nur linux-2.6.32-orig/drivers/video/mx3fb.c iDroid-Project-kernel_common-9e90fd2/drivers/video/mx3fb.c
--- linux-2.6.32-orig/drivers/video/mx3fb.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/mx3fb.c	2010-11-18 21:05:30.000000000 +0600
@@ -324,8 +324,11 @@
 	unsigned long flags;
 	dma_cookie_t cookie;
 
-	dev_dbg(mx3fb->dev, "mx3fbi %p, desc %p, sg %p\n", mx3_fbi,
-		to_tx_desc(mx3_fbi->txd), to_tx_desc(mx3_fbi->txd)->sg);
+	if (mx3_fbi->txd)
+		dev_dbg(mx3fb->dev, "mx3fbi %p, desc %p, sg %p\n", mx3_fbi,
+			to_tx_desc(mx3_fbi->txd), to_tx_desc(mx3_fbi->txd)->sg);
+	else
+		dev_dbg(mx3fb->dev, "mx3fbi %p, txd = NULL\n", mx3_fbi);
 
 	/* This enables the channel */
 	if (mx3_fbi->cookie < 0) {
@@ -646,6 +649,7 @@
 
 static void sdc_set_brightness(struct mx3fb_data *mx3fb, uint8_t value)
 {
+	dev_dbg(mx3fb->dev, "%s: value = %d\n", __func__, value);
 	/* This might be board-specific */
 	mx3fb_write_reg(mx3fb, 0x03000000UL | value << 16, SDC_PWM_CTRL);
 	return;
@@ -1486,12 +1490,12 @@
 		goto ersdc0;
 	}
 
+	mx3fb->backlight_level = 255;
+
 	ret = init_fb_chan(mx3fb, to_idmac_chan(chan));
 	if (ret < 0)
 		goto eisdc0;
 
-	mx3fb->backlight_level = 255;
-
 	return 0;
 
 eisdc0:
diff -Nur linux-2.6.32-orig/drivers/video/s3c-fb.c iDroid-Project-kernel_common-9e90fd2/drivers/video/s3c-fb.c
--- linux-2.6.32-orig/drivers/video/s3c-fb.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/video/s3c-fb.c	2010-11-18 21:05:30.000000000 +0600
@@ -211,21 +211,23 @@
 
 /**
  * s3c_fb_calc_pixclk() - calculate the divider to create the pixel clock.
- * @id: window id.
  * @sfb: The hardware state.
  * @pixclock: The pixel clock wanted, in picoseconds.
  *
  * Given the specified pixel clock, work out the necessary divider to get
  * close to the output frequency.
  */
-static int s3c_fb_calc_pixclk(unsigned char id, struct s3c_fb *sfb, unsigned int pixclk)
+static int s3c_fb_calc_pixclk(struct s3c_fb *sfb, unsigned int pixclk)
 {
-	struct s3c_fb_pd_win *win = sfb->pdata->win[id];
 	unsigned long clk = clk_get_rate(sfb->bus_clk);
+	unsigned long long tmp;
 	unsigned int result;
 
-	pixclk *= win->win_mode.refresh;
-	result = clk / pixclk;
+	tmp = (unsigned long long)clk;
+	tmp *= pixclk;
+
+	do_div(tmp, 1000000000UL);
+	result = (unsigned int)tmp / 1000;
 
 	dev_dbg(sfb->dev, "pixclk=%u, clk=%lu, div=%d (%lu)\n",
 		pixclk, clk, result, clk / result);
@@ -301,7 +303,7 @@
 	/* use window 0 as the basis for the lcd output timings */
 
 	if (win_no == 0) {
-		clkdiv = s3c_fb_calc_pixclk(win_no, sfb, var->pixclock);
+		clkdiv = s3c_fb_calc_pixclk(sfb, var->pixclock);
 
 		data = sfb->pdata->vidcon0;
 		data &= ~(VIDCON0_CLKVAL_F_MASK | VIDCON0_CLKDIR);
diff -Nur linux-2.6.32-orig/drivers/w1/w1.c iDroid-Project-kernel_common-9e90fd2/drivers/w1/w1.c
--- linux-2.6.32-orig/drivers/w1/w1.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/w1/w1.c	2010-11-18 21:05:30.000000000 +0600
@@ -517,10 +517,10 @@
 static W1_MASTER_ATTR_RO(attempts, S_IRUGO);
 static W1_MASTER_ATTR_RO(timeout, S_IRUGO);
 static W1_MASTER_ATTR_RO(pointer, S_IRUGO);
-static W1_MASTER_ATTR_RW(search, S_IRUGO | S_IWUGO);
-static W1_MASTER_ATTR_RW(pullup, S_IRUGO | S_IWUGO);
-static W1_MASTER_ATTR_RW(add, S_IRUGO | S_IWUGO);
-static W1_MASTER_ATTR_RW(remove, S_IRUGO | S_IWUGO);
+static W1_MASTER_ATTR_RW(search, S_IRUGO | S_IWUSR | S_IWGRP);
+static W1_MASTER_ATTR_RW(pullup, S_IRUGO | S_IWUSR | S_IWGRP);
+static W1_MASTER_ATTR_RW(add, S_IRUGO | S_IWUSR | S_IWGRP);
+static W1_MASTER_ATTR_RW(remove, S_IRUGO | S_IWUSR | S_IWGRP);
 
 static struct attribute *w1_master_default_attrs[] = {
 	&w1_master_attribute_name.attr,
diff -Nur linux-2.6.32-orig/drivers/watchdog/iTCO_wdt.c iDroid-Project-kernel_common-9e90fd2/drivers/watchdog/iTCO_wdt.c
--- linux-2.6.32-orig/drivers/watchdog/iTCO_wdt.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/watchdog/iTCO_wdt.c	2010-11-18 21:05:30.000000000 +0600
@@ -1,5 +1,5 @@
 /*
- *	intel TCO Watchdog Driver (Used in i82801 and i63xxESB chipsets)
+ *	intel TCO Watchdog Driver
  *
  *	(c) Copyright 2006-2009 Wim Van Sebroeck <wim@iguana.be>.
  *
@@ -14,47 +14,24 @@
  *
  *	The TCO watchdog is implemented in the following I/O controller hubs:
  *	(See the intel documentation on http://developer.intel.com.)
- *	82801AA  (ICH)       : document number 290655-003, 290677-014,
- *	82801AB  (ICHO)      : document number 290655-003, 290677-014,
- *	82801BA  (ICH2)      : document number 290687-002, 298242-027,
- *	82801BAM (ICH2-M)    : document number 290687-002, 298242-027,
- *	82801CA  (ICH3-S)    : document number 290733-003, 290739-013,
- *	82801CAM (ICH3-M)    : document number 290716-001, 290718-007,
- *	82801DB  (ICH4)      : document number 290744-001, 290745-025,
- *	82801DBM (ICH4-M)    : document number 252337-001, 252663-008,
- *	82801E   (C-ICH)     : document number 273599-001, 273645-002,
- *	82801EB  (ICH5)      : document number 252516-001, 252517-028,
- *	82801ER  (ICH5R)     : document number 252516-001, 252517-028,
- *	6300ESB  (6300ESB)   : document number 300641-004, 300884-013,
- *	82801FB  (ICH6)      : document number 301473-002, 301474-026,
- *	82801FR  (ICH6R)     : document number 301473-002, 301474-026,
- *	82801FBM (ICH6-M)    : document number 301473-002, 301474-026,
- *	82801FW  (ICH6W)     : document number 301473-001, 301474-026,
- *	82801FRW (ICH6RW)    : document number 301473-001, 301474-026,
- *	631xESB  (631xESB)   : document number 313082-001, 313075-006,
- *	632xESB  (632xESB)   : document number 313082-001, 313075-006,
- *	82801GB  (ICH7)      : document number 307013-003, 307014-024,
- *	82801GR  (ICH7R)     : document number 307013-003, 307014-024,
- *	82801GDH (ICH7DH)    : document number 307013-003, 307014-024,
- *	82801GBM (ICH7-M)    : document number 307013-003, 307014-024,
- *	82801GHM (ICH7-M DH) : document number 307013-003, 307014-024,
- *	82801GU  (ICH7-U)    : document number 307013-003, 307014-024,
- *	82801HB  (ICH8)      : document number 313056-003, 313057-017,
- *	82801HR  (ICH8R)     : document number 313056-003, 313057-017,
- *	82801HBM (ICH8M)     : document number 313056-003, 313057-017,
- *	82801HH  (ICH8DH)    : document number 313056-003, 313057-017,
- *	82801HO  (ICH8DO)    : document number 313056-003, 313057-017,
- *	82801HEM (ICH8M-E)   : document number 313056-003, 313057-017,
- *	82801IB  (ICH9)      : document number 316972-004, 316973-012,
- *	82801IR  (ICH9R)     : document number 316972-004, 316973-012,
- *	82801IH  (ICH9DH)    : document number 316972-004, 316973-012,
- *	82801IO  (ICH9DO)    : document number 316972-004, 316973-012,
- *	82801IBM (ICH9M)     : document number 316972-004, 316973-012,
- *	82801IEM (ICH9M-E)   : document number 316972-004, 316973-012,
- *	82801JIB (ICH10)     : document number 319973-002, 319974-002,
- *	82801JIR (ICH10R)    : document number 319973-002, 319974-002,
- *	82801JD  (ICH10D)    : document number 319973-002, 319974-002,
- *	82801JDO (ICH10DO)   : document number 319973-002, 319974-002
+ *	document number 290655-003, 290677-014: 82801AA (ICH), 82801AB (ICHO)
+ *	document number 290687-002, 298242-027: 82801BA (ICH2)
+ *	document number 290733-003, 290739-013: 82801CA (ICH3-S)
+ *	document number 290716-001, 290718-007: 82801CAM (ICH3-M)
+ *	document number 290744-001, 290745-025: 82801DB (ICH4)
+ *	document number 252337-001, 252663-008: 82801DBM (ICH4-M)
+ *	document number 273599-001, 273645-002: 82801E (C-ICH)
+ *	document number 252516-001, 252517-028: 82801EB (ICH5), 82801ER (ICH5R)
+ *	document number 300641-004, 300884-013: 6300ESB
+ *	document number 301473-002, 301474-026: 82801F (ICH6)
+ *	document number 313082-001, 313075-006: 631xESB, 632xESB
+ *	document number 307013-003, 307014-024: 82801G (ICH7)
+ *	document number 313056-003, 313057-017: 82801H (ICH8)
+ *	document number 316972-004, 316973-012: 82801I (ICH9)
+ *	document number 319973-002, 319974-002: 82801J (ICH10)
+ *	document number 322169-001, 322170-003: 5 Series, 3400 Series (PCH)
+ *	document number 320066-003, 320257-008: EP80597 (IICH)
+ *	document number TBD                   : Cougar Point (CPT)
  */
 
 /*
@@ -122,6 +99,24 @@
 	TCO_ICH10R,	/* ICH10R */
 	TCO_ICH10D,	/* ICH10D */
 	TCO_ICH10DO,	/* ICH10DO */
+	TCO_PCH,	/* PCH Desktop Full Featured */
+	TCO_PCHM,	/* PCH Mobile Full Featured */
+	TCO_P55,	/* P55 */
+	TCO_PM55,	/* PM55 */
+	TCO_H55,	/* H55 */
+	TCO_QM57,	/* QM57 */
+	TCO_H57,	/* H57 */
+	TCO_HM55,	/* HM55 */
+	TCO_Q57,	/* Q57 */
+	TCO_HM57,	/* HM57 */
+	TCO_PCHMSFF,	/* PCH Mobile SFF Full Featured */
+	TCO_QS57,	/* QS57 */
+	TCO_3400,	/* 3400 */
+	TCO_3420,	/* 3420 */
+	TCO_3450,	/* 3450 */
+	TCO_EP80579,	/* EP80579 */
+	TCO_CPTD,	/* CPT Desktop */
+	TCO_CPTM,	/* CPT Mobile */
 };
 
 static struct {
@@ -162,6 +157,24 @@
 	{"ICH10R", 2},
 	{"ICH10D", 2},
 	{"ICH10DO", 2},
+	{"PCH Desktop Full Featured", 2},
+	{"PCH Mobile Full Featured", 2},
+	{"P55", 2},
+	{"PM55", 2},
+	{"H55", 2},
+	{"QM57", 2},
+	{"H57", 2},
+	{"HM55", 2},
+	{"Q57", 2},
+	{"HM57", 2},
+	{"PCH Mobile SFF Full Featured", 2},
+	{"QS57", 2},
+	{"3400", 2},
+	{"3420", 2},
+	{"3450", 2},
+	{"EP80579", 2},
+	{"CPT Desktop", 2},
+	{"CPT Mobile", 2},
 	{NULL, 0}
 };
 
@@ -230,6 +243,24 @@
 	{ ITCO_PCI_DEVICE(0x3a16,				TCO_ICH10R)},
 	{ ITCO_PCI_DEVICE(0x3a1a,				TCO_ICH10D)},
 	{ ITCO_PCI_DEVICE(0x3a14,				TCO_ICH10DO)},
+	{ ITCO_PCI_DEVICE(0x3b00,				TCO_PCH)},
+	{ ITCO_PCI_DEVICE(0x3b01,				TCO_PCHM)},
+	{ ITCO_PCI_DEVICE(0x3b02,				TCO_P55)},
+	{ ITCO_PCI_DEVICE(0x3b03,				TCO_PM55)},
+	{ ITCO_PCI_DEVICE(0x3b06,				TCO_H55)},
+	{ ITCO_PCI_DEVICE(0x3b07,				TCO_QM57)},
+	{ ITCO_PCI_DEVICE(0x3b08,				TCO_H57)},
+	{ ITCO_PCI_DEVICE(0x3b09,				TCO_HM55)},
+	{ ITCO_PCI_DEVICE(0x3b0a,				TCO_Q57)},
+	{ ITCO_PCI_DEVICE(0x3b0b,				TCO_HM57)},
+	{ ITCO_PCI_DEVICE(0x3b0d,				TCO_PCHMSFF)},
+	{ ITCO_PCI_DEVICE(0x3b0f,				TCO_QS57)},
+	{ ITCO_PCI_DEVICE(0x3b12,				TCO_3400)},
+	{ ITCO_PCI_DEVICE(0x3b14,				TCO_3420)},
+	{ ITCO_PCI_DEVICE(0x3b16,				TCO_3450)},
+	{ ITCO_PCI_DEVICE(0x5031,				TCO_EP80579)},
+	{ ITCO_PCI_DEVICE(0x1c42,				TCO_CPTD)},
+	{ ITCO_PCI_DEVICE(0x1c43,				TCO_CPTM)},
 	{ 0, },			/* End of list */
 };
 MODULE_DEVICE_TABLE(pci, iTCO_wdt_pci_tbl);
diff -Nur linux-2.6.32-orig/drivers/xen/balloon.c iDroid-Project-kernel_common-9e90fd2/drivers/xen/balloon.c
--- linux-2.6.32-orig/drivers/xen/balloon.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/xen/balloon.c	2010-11-18 21:05:30.000000000 +0600
@@ -66,8 +66,6 @@
 	/* We aim for 'current allocation' == 'target allocation'. */
 	unsigned long current_pages;
 	unsigned long target_pages;
-	/* We may hit the hard limit in Xen. If we do then we remember it. */
-	unsigned long hard_limit;
 	/*
 	 * Drivers may alter the memory reservation independently, but they
 	 * must inform the balloon driver so we avoid hitting the hard limit.
@@ -136,6 +134,8 @@
 		list_add(&page->lru, &ballooned_pages);
 		balloon_stats.balloon_low++;
 	}
+
+	totalram_pages--;
 }
 
 /* balloon_retrieve: rescue a page from the balloon, if it is not empty. */
@@ -156,6 +156,8 @@
 	else
 		balloon_stats.balloon_low--;
 
+	totalram_pages++;
+
 	return page;
 }
 
@@ -181,7 +183,7 @@
 
 static unsigned long current_target(void)
 {
-	unsigned long target = min(balloon_stats.target_pages, balloon_stats.hard_limit);
+	unsigned long target = balloon_stats.target_pages;
 
 	target = min(target,
 		     balloon_stats.current_pages +
@@ -217,23 +219,10 @@
 	set_xen_guest_handle(reservation.extent_start, frame_list);
 	reservation.nr_extents = nr_pages;
 	rc = HYPERVISOR_memory_op(XENMEM_populate_physmap, &reservation);
-	if (rc < nr_pages) {
-		if (rc > 0) {
-			int ret;
-
-			/* We hit the Xen hard limit: reprobe. */
-			reservation.nr_extents = rc;
-			ret = HYPERVISOR_memory_op(XENMEM_decrease_reservation,
-						   &reservation);
-			BUG_ON(ret != rc);
-		}
-		if (rc >= 0)
-			balloon_stats.hard_limit = (balloon_stats.current_pages + rc -
-						    balloon_stats.driver_pages);
+	if (rc < 0)
 		goto out;
-	}
 
-	for (i = 0; i < nr_pages; i++) {
+	for (i = 0; i < rc; i++) {
 		page = balloon_retrieve();
 		BUG_ON(page == NULL);
 
@@ -259,13 +248,12 @@
 		__free_page(page);
 	}
 
-	balloon_stats.current_pages += nr_pages;
-	totalram_pages = balloon_stats.current_pages;
+	balloon_stats.current_pages += rc;
 
  out:
 	spin_unlock_irqrestore(&balloon_lock, flags);
 
-	return 0;
+	return rc < 0 ? rc : rc != nr_pages;
 }
 
 static int decrease_reservation(unsigned long nr_pages)
@@ -323,7 +311,6 @@
 	BUG_ON(ret != nr_pages);
 
 	balloon_stats.current_pages -= nr_pages;
-	totalram_pages = balloon_stats.current_pages;
 
 	spin_unlock_irqrestore(&balloon_lock, flags);
 
@@ -367,7 +354,6 @@
 static void balloon_set_new_target(unsigned long target)
 {
 	/* No need for lock. Not read-modify-write updates. */
-	balloon_stats.hard_limit   = ~0UL;
 	balloon_stats.target_pages = target;
 	schedule_work(&balloon_worker);
 }
@@ -422,12 +408,10 @@
 	pr_info("xen_balloon: Initialising balloon driver.\n");
 
 	balloon_stats.current_pages = min(xen_start_info->nr_pages, max_pfn);
-	totalram_pages   = balloon_stats.current_pages;
 	balloon_stats.target_pages  = balloon_stats.current_pages;
 	balloon_stats.balloon_low   = 0;
 	balloon_stats.balloon_high  = 0;
 	balloon_stats.driver_pages  = 0UL;
-	balloon_stats.hard_limit    = ~0UL;
 
 	init_timer(&balloon_timer);
 	balloon_timer.data = 0;
@@ -472,9 +456,6 @@
 BALLOON_SHOW(current_kb, "%lu\n", PAGES2KB(balloon_stats.current_pages));
 BALLOON_SHOW(low_kb, "%lu\n", PAGES2KB(balloon_stats.balloon_low));
 BALLOON_SHOW(high_kb, "%lu\n", PAGES2KB(balloon_stats.balloon_high));
-BALLOON_SHOW(hard_limit_kb,
-	     (balloon_stats.hard_limit!=~0UL) ? "%lu\n" : "???\n",
-	     (balloon_stats.hard_limit!=~0UL) ? PAGES2KB(balloon_stats.hard_limit) : 0);
 BALLOON_SHOW(driver_kb, "%lu\n", PAGES2KB(balloon_stats.driver_pages));
 
 static ssize_t show_target_kb(struct sys_device *dev, struct sysdev_attribute *attr,
@@ -544,7 +525,6 @@
 	&attr_current_kb.attr,
 	&attr_low_kb.attr,
 	&attr_high_kb.attr,
-	&attr_hard_limit_kb.attr,
 	&attr_driver_kb.attr,
 	NULL
 };
diff -Nur linux-2.6.32-orig/drivers/xen/events.c iDroid-Project-kernel_common-9e90fd2/drivers/xen/events.c
--- linux-2.6.32-orig/drivers/xen/events.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/xen/events.c	2010-11-18 21:05:30.000000000 +0600
@@ -474,6 +474,9 @@
 		bind_evtchn_to_cpu(evtchn, 0);
 
 		evtchn_to_irq[evtchn] = -1;
+	}
+
+	if (irq_info[irq].type != IRQT_UNBOUND) {
 		irq_info[irq] = mk_unbound_info();
 
 		dynamic_irq_cleanup(irq);
diff -Nur linux-2.6.32-orig/drivers/xen/manage.c iDroid-Project-kernel_common-9e90fd2/drivers/xen/manage.c
--- linux-2.6.32-orig/drivers/xen/manage.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/xen/manage.c	2010-11-18 21:05:30.000000000 +0600
@@ -43,7 +43,6 @@
 	if (err) {
 		printk(KERN_ERR "xen_suspend: sysdev_suspend failed: %d\n",
 			err);
-		dpm_resume_noirq(PMSG_RESUME);
 		return err;
 	}
 
@@ -69,7 +68,6 @@
 	}
 
 	sysdev_resume();
-	dpm_resume_noirq(PMSG_RESUME);
 
 	return 0;
 }
@@ -81,6 +79,12 @@
 
 	shutting_down = SHUTDOWN_SUSPEND;
 
+	err = stop_machine_create();
+	if (err) {
+		printk(KERN_ERR "xen suspend: failed to setup stop_machine %d\n", err);
+		goto out;
+	}
+
 #ifdef CONFIG_PREEMPT
 	/* If the kernel is preemptible, we need to freeze all the processes
 	   to prevent them from being in the middle of a pagetable update
@@ -88,14 +92,14 @@
 	err = freeze_processes();
 	if (err) {
 		printk(KERN_ERR "xen suspend: freeze failed %d\n", err);
-		return;
+		goto out_destroy_sm;
 	}
 #endif
 
 	err = dpm_suspend_start(PMSG_SUSPEND);
 	if (err) {
 		printk(KERN_ERR "xen suspend: dpm_suspend_start %d\n", err);
-		goto out;
+		goto out_thaw;
 	}
 
 	printk(KERN_DEBUG "suspending xenstore...\n");
@@ -104,32 +108,39 @@
 	err = dpm_suspend_noirq(PMSG_SUSPEND);
 	if (err) {
 		printk(KERN_ERR "dpm_suspend_noirq failed: %d\n", err);
-		goto resume_devices;
+		goto out_resume;
 	}
 
 	err = stop_machine(xen_suspend, &cancelled, cpumask_of(0));
+
+	dpm_resume_noirq(PMSG_RESUME);
+
 	if (err) {
 		printk(KERN_ERR "failed to start xen_suspend: %d\n", err);
-		goto out;
+		cancelled = 1;
 	}
 
+out_resume:
 	if (!cancelled) {
 		xen_arch_resume();
 		xs_resume();
 	} else
 		xs_suspend_cancel();
 
-	dpm_resume_noirq(PMSG_RESUME);
-
-resume_devices:
 	dpm_resume_end(PMSG_RESUME);
 
 	/* Make sure timer events get retriggered on all CPUs */
 	clock_was_set();
-out:
+
+out_thaw:
 #ifdef CONFIG_PREEMPT
 	thaw_processes();
+
+out_destroy_sm:
 #endif
+	stop_machine_destroy();
+
+out:
 	shutting_down = SHUTDOWN_INVALID;
 }
 #endif	/* CONFIG_PM_SLEEP */
diff -Nur linux-2.6.32-orig/drivers/xen/xenbus/xenbus_probe.c iDroid-Project-kernel_common-9e90fd2/drivers/xen/xenbus/xenbus_probe.c
--- linux-2.6.32-orig/drivers/xen/xenbus/xenbus_probe.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/drivers/xen/xenbus/xenbus_probe.c	2010-11-18 21:05:30.000000000 +0600
@@ -454,21 +454,21 @@
 {
 	return sprintf(buf, "%s\n", to_xenbus_device(dev)->nodename);
 }
-DEVICE_ATTR(nodename, S_IRUSR | S_IRGRP | S_IROTH, xendev_show_nodename, NULL);
+static DEVICE_ATTR(nodename, S_IRUSR | S_IRGRP | S_IROTH, xendev_show_nodename, NULL);
 
 static ssize_t xendev_show_devtype(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
 	return sprintf(buf, "%s\n", to_xenbus_device(dev)->devicetype);
 }
-DEVICE_ATTR(devtype, S_IRUSR | S_IRGRP | S_IROTH, xendev_show_devtype, NULL);
+static DEVICE_ATTR(devtype, S_IRUSR | S_IRGRP | S_IROTH, xendev_show_devtype, NULL);
 
 static ssize_t xendev_show_modalias(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
 	return sprintf(buf, "xen:%s\n", to_xenbus_device(dev)->devicetype);
 }
-DEVICE_ATTR(modalias, S_IRUSR | S_IRGRP | S_IROTH, xendev_show_modalias, NULL);
+static DEVICE_ATTR(modalias, S_IRUSR | S_IRGRP | S_IROTH, xendev_show_modalias, NULL);
 
 int xenbus_probe_node(struct xen_bus_type *bus,
 		      const char *type,
@@ -843,7 +843,7 @@
 
 MODULE_LICENSE("GPL");
 
-static int is_disconnected_device(struct device *dev, void *data)
+static int is_device_connecting(struct device *dev, void *data)
 {
 	struct xenbus_device *xendev = to_xenbus_device(dev);
 	struct device_driver *drv = data;
@@ -861,14 +861,15 @@
 		return 0;
 
 	xendrv = to_xenbus_driver(dev->driver);
-	return (xendev->state != XenbusStateConnected ||
-		(xendrv->is_ready && !xendrv->is_ready(xendev)));
+	return (xendev->state < XenbusStateConnected ||
+		(xendev->state == XenbusStateConnected &&
+		 xendrv->is_ready && !xendrv->is_ready(xendev)));
 }
 
-static int exists_disconnected_device(struct device_driver *drv)
+static int exists_connecting_device(struct device_driver *drv)
 {
 	return bus_for_each_dev(&xenbus_frontend.bus, NULL, drv,
-				is_disconnected_device);
+				is_device_connecting);
 }
 
 static int print_device_status(struct device *dev, void *data)
@@ -884,10 +885,13 @@
 		/* Information only: is this too noisy? */
 		printk(KERN_INFO "XENBUS: Device with no driver: %s\n",
 		       xendev->nodename);
-	} else if (xendev->state != XenbusStateConnected) {
+	} else if (xendev->state < XenbusStateConnected) {
+		enum xenbus_state rstate = XenbusStateUnknown;
+		if (xendev->otherend)
+			rstate = xenbus_read_driver_state(xendev->otherend);
 		printk(KERN_WARNING "XENBUS: Timeout connecting "
-		       "to device: %s (state %d)\n",
-		       xendev->nodename, xendev->state);
+		       "to device: %s (local state %d, remote state %d)\n",
+		       xendev->nodename, xendev->state, rstate);
 	}
 
 	return 0;
@@ -897,7 +901,7 @@
 static int ready_to_wait_for_devices;
 
 /*
- * On a 10 second timeout, wait for all devices currently configured.  We need
+ * On a 5-minute timeout, wait for all devices currently configured.  We need
  * to do this to guarantee that the filesystems and / or network devices
  * needed for boot are available, before we can allow the boot to proceed.
  *
@@ -912,18 +916,30 @@
  */
 static void wait_for_devices(struct xenbus_driver *xendrv)
 {
-	unsigned long timeout = jiffies + 10*HZ;
+	unsigned long start = jiffies;
 	struct device_driver *drv = xendrv ? &xendrv->driver : NULL;
+	unsigned int seconds_waited = 0;
 
 	if (!ready_to_wait_for_devices || !xen_domain())
 		return;
 
-	while (exists_disconnected_device(drv)) {
-		if (time_after(jiffies, timeout))
-			break;
+	while (exists_connecting_device(drv)) {
+		if (time_after(jiffies, start + (seconds_waited+5)*HZ)) {
+			if (!seconds_waited)
+				printk(KERN_WARNING "XENBUS: Waiting for "
+				       "devices to initialise: ");
+			seconds_waited += 5;
+			printk("%us...", 300 - seconds_waited);
+			if (seconds_waited == 300)
+				break;
+		}
+
 		schedule_timeout_interruptible(HZ/10);
 	}
 
+	if (seconds_waited)
+		printk("\n");
+
 	bus_for_each_dev(&xenbus_frontend.bus, NULL, drv,
 			 print_device_status);
 }
diff -Nur linux-2.6.32-orig/fs/9p/vfs_super.c iDroid-Project-kernel_common-9e90fd2/fs/9p/vfs_super.c
--- linux-2.6.32-orig/fs/9p/vfs_super.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/9p/vfs_super.c	2010-11-18 21:05:30.000000000 +0600
@@ -188,7 +188,8 @@
 
 	P9_DPRINTK(P9_DEBUG_VFS, " %p\n", s);
 
-	v9fs_dentry_release(s->s_root);	/* clunk root */
+	if (s->s_root)
+		v9fs_dentry_release(s->s_root);	/* clunk root */
 
 	kill_anon_super(s);
 
diff -Nur linux-2.6.32-orig/fs/affs/affs.h iDroid-Project-kernel_common-9e90fd2/fs/affs/affs.h
--- linux-2.6.32-orig/fs/affs/affs.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/affs/affs.h	2010-11-18 21:05:30.000000000 +0600
@@ -106,8 +106,8 @@
 	u32 s_last_bmap;
 	struct buffer_head *s_bmap_bh;
 	char *s_prefix;			/* Prefix for volumes and assigns. */
-	int s_prefix_len;		/* Length of prefix. */
 	char s_volume[32];		/* Volume prefix for absolute symlinks. */
+	spinlock_t symlink_lock;	/* protects the previous two */
 };
 
 #define SF_INTL		0x0001		/* International filesystem. */
diff -Nur linux-2.6.32-orig/fs/affs/namei.c iDroid-Project-kernel_common-9e90fd2/fs/affs/namei.c
--- linux-2.6.32-orig/fs/affs/namei.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/affs/namei.c	2010-11-18 21:05:30.000000000 +0600
@@ -341,10 +341,13 @@
 	p  = (char *)AFFS_HEAD(bh)->table;
 	lc = '/';
 	if (*symname == '/') {
+		struct affs_sb_info *sbi = AFFS_SB(sb);
 		while (*symname == '/')
 			symname++;
-		while (AFFS_SB(sb)->s_volume[i])	/* Cannot overflow */
-			*p++ = AFFS_SB(sb)->s_volume[i++];
+		spin_lock(&sbi->symlink_lock);
+		while (sbi->s_volume[i])	/* Cannot overflow */
+			*p++ = sbi->s_volume[i++];
+		spin_unlock(&sbi->symlink_lock);
 	}
 	while (i < maxlen && (c = *symname++)) {
 		if (c == '.' && lc == '/' && *symname == '.' && symname[1] == '/') {
diff -Nur linux-2.6.32-orig/fs/affs/super.c iDroid-Project-kernel_common-9e90fd2/fs/affs/super.c
--- linux-2.6.32-orig/fs/affs/super.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/affs/super.c	2010-11-18 21:05:30.000000000 +0600
@@ -203,7 +203,7 @@
 		switch (token) {
 		case Opt_bs:
 			if (match_int(&args[0], &n))
-				return -EINVAL;
+				return 0;
 			if (n != 512 && n != 1024 && n != 2048
 			    && n != 4096) {
 				printk ("AFFS: Invalid blocksize (512, 1024, 2048, 4096 allowed)\n");
@@ -213,7 +213,7 @@
 			break;
 		case Opt_mode:
 			if (match_octal(&args[0], &option))
-				return 1;
+				return 0;
 			*mode = option & 0777;
 			*mount_opts |= SF_SETMODE;
 			break;
@@ -221,8 +221,6 @@
 			*mount_opts |= SF_MUFS;
 			break;
 		case Opt_prefix:
-			/* Free any previous prefix */
-			kfree(*prefix);
 			*prefix = match_strdup(&args[0]);
 			if (!*prefix)
 				return 0;
@@ -233,21 +231,21 @@
 			break;
 		case Opt_reserved:
 			if (match_int(&args[0], reserved))
-				return 1;
+				return 0;
 			break;
 		case Opt_root:
 			if (match_int(&args[0], root))
-				return 1;
+				return 0;
 			break;
 		case Opt_setgid:
 			if (match_int(&args[0], &option))
-				return 1;
+				return 0;
 			*gid = option;
 			*mount_opts |= SF_SETGID;
 			break;
 		case Opt_setuid:
 			if (match_int(&args[0], &option))
-				return -EINVAL;
+				return 0;
 			*uid = option;
 			*mount_opts |= SF_SETUID;
 			break;
@@ -311,11 +309,14 @@
 		return -ENOMEM;
 	sb->s_fs_info = sbi;
 	mutex_init(&sbi->s_bmlock);
+	spin_lock_init(&sbi->symlink_lock);
 
 	if (!parse_options(data,&uid,&gid,&i,&reserved,&root_block,
 				&blocksize,&sbi->s_prefix,
 				sbi->s_volume, &mount_flags)) {
 		printk(KERN_ERR "AFFS: Error parsing options\n");
+		kfree(sbi->s_prefix);
+		kfree(sbi);
 		return -EINVAL;
 	}
 	/* N.B. after this point s_prefix must be released */
@@ -516,14 +517,18 @@
 	unsigned long		 mount_flags;
 	int			 res = 0;
 	char			*new_opts = kstrdup(data, GFP_KERNEL);
+	char			 volume[32];
+	char			*prefix = NULL;
 
 	pr_debug("AFFS: remount(flags=0x%x,opts=\"%s\")\n",*flags,data);
 
 	*flags |= MS_NODIRATIME;
 
+	memcpy(volume, sbi->s_volume, 32);
 	if (!parse_options(data, &uid, &gid, &mode, &reserved, &root_block,
-			   &blocksize, &sbi->s_prefix, sbi->s_volume,
+			   &blocksize, &prefix, volume,
 			   &mount_flags)) {
+		kfree(prefix);
 		kfree(new_opts);
 		return -EINVAL;
 	}
@@ -534,6 +539,14 @@
 	sbi->s_mode  = mode;
 	sbi->s_uid   = uid;
 	sbi->s_gid   = gid;
+	/* protect against readers */
+	spin_lock(&sbi->symlink_lock);
+	if (prefix) {
+		kfree(sbi->s_prefix);
+		sbi->s_prefix = prefix;
+	}
+	memcpy(sbi->s_volume, volume, 32);
+	spin_unlock(&sbi->symlink_lock);
 
 	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY)) {
 		unlock_kernel();
diff -Nur linux-2.6.32-orig/fs/affs/symlink.c iDroid-Project-kernel_common-9e90fd2/fs/affs/symlink.c
--- linux-2.6.32-orig/fs/affs/symlink.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/affs/symlink.c	2010-11-18 21:05:30.000000000 +0600
@@ -20,7 +20,6 @@
 	int			 i, j;
 	char			 c;
 	char			 lc;
-	char			*pf;
 
 	pr_debug("AFFS: follow_link(ino=%lu)\n",inode->i_ino);
 
@@ -32,11 +31,15 @@
 	j  = 0;
 	lf = (struct slink_front *)bh->b_data;
 	lc = 0;
-	pf = AFFS_SB(inode->i_sb)->s_prefix ? AFFS_SB(inode->i_sb)->s_prefix : "/";
 
 	if (strchr(lf->symname,':')) {	/* Handle assign or volume name */
+		struct affs_sb_info *sbi = AFFS_SB(inode->i_sb);
+		char *pf;
+		spin_lock(&sbi->symlink_lock);
+		pf = sbi->s_prefix ? sbi->s_prefix : "/";
 		while (i < 1023 && (c = pf[i]))
 			link[i++] = c;
+		spin_unlock(&sbi->symlink_lock);
 		while (i < 1023 && lf->symname[j] != ':')
 			link[i++] = lf->symname[j++];
 		if (i < 1023)
diff -Nur linux-2.6.32-orig/fs/befs/linuxvfs.c iDroid-Project-kernel_common-9e90fd2/fs/befs/linuxvfs.c
--- linux-2.6.32-orig/fs/befs/linuxvfs.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/befs/linuxvfs.c	2010-11-18 21:05:30.000000000 +0600
@@ -873,6 +873,7 @@
 	brelse(bh);
 
       unacquire_priv_sbp:
+	kfree(befs_sb->mount_opts.iocharset);
 	kfree(sb->s_fs_info);
 
       unacquire_none:
diff -Nur linux-2.6.32-orig/fs/bfs/inode.c iDroid-Project-kernel_common-9e90fd2/fs/bfs/inode.c
--- linux-2.6.32-orig/fs/bfs/inode.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/bfs/inode.c	2010-11-18 21:05:30.000000000 +0600
@@ -353,35 +353,35 @@
 	struct inode *inode;
 	unsigned i, imap_len;
 	struct bfs_sb_info *info;
-	long ret = -EINVAL;
+	int ret = -EINVAL;
 	unsigned long i_sblock, i_eblock, i_eoff, s_size;
 
 	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (!info)
 		return -ENOMEM;
+	mutex_init(&info->bfs_lock);
 	s->s_fs_info = info;
 
 	sb_set_blocksize(s, BFS_BSIZE);
 
-	bh = sb_bread(s, 0);
-	if(!bh)
+	info->si_sbh = sb_bread(s, 0);
+	if (!info->si_sbh)
 		goto out;
-	bfs_sb = (struct bfs_super_block *)bh->b_data;
+	bfs_sb = (struct bfs_super_block *)info->si_sbh->b_data;
 	if (le32_to_cpu(bfs_sb->s_magic) != BFS_MAGIC) {
 		if (!silent)
 			printf("No BFS filesystem on %s (magic=%08x)\n", 
 				s->s_id,  le32_to_cpu(bfs_sb->s_magic));
-		goto out;
+		goto out1;
 	}
 	if (BFS_UNCLEAN(bfs_sb, s) && !silent)
 		printf("%s is unclean, continuing\n", s->s_id);
 
 	s->s_magic = BFS_MAGIC;
-	info->si_sbh = bh;
 
 	if (le32_to_cpu(bfs_sb->s_start) > le32_to_cpu(bfs_sb->s_end)) {
 		printf("Superblock is corrupted\n");
-		goto out;
+		goto out1;
 	}
 
 	info->si_lasti = (le32_to_cpu(bfs_sb->s_start) - BFS_BSIZE) /
@@ -390,7 +390,7 @@
 	imap_len = (info->si_lasti / 8) + 1;
 	info->si_imap = kzalloc(imap_len, GFP_KERNEL);
 	if (!info->si_imap)
-		goto out;
+		goto out1;
 	for (i = 0; i < BFS_ROOT_INO; i++)
 		set_bit(i, info->si_imap);
 
@@ -398,15 +398,13 @@
 	inode = bfs_iget(s, BFS_ROOT_INO);
 	if (IS_ERR(inode)) {
 		ret = PTR_ERR(inode);
-		kfree(info->si_imap);
-		goto out;
+		goto out2;
 	}
 	s->s_root = d_alloc_root(inode);
 	if (!s->s_root) {
 		iput(inode);
 		ret = -ENOMEM;
-		kfree(info->si_imap);
-		goto out;
+		goto out2;
 	}
 
 	info->si_blocks = (le32_to_cpu(bfs_sb->s_end) + 1) >> BFS_BSIZE_BITS;
@@ -419,10 +417,8 @@
 	bh = sb_bread(s, info->si_blocks - 1);
 	if (!bh) {
 		printf("Last block not available: %lu\n", info->si_blocks - 1);
-		iput(inode);
 		ret = -EIO;
-		kfree(info->si_imap);
-		goto out;
+		goto out3;
 	}
 	brelse(bh);
 
@@ -459,11 +455,8 @@
 			printf("Inode 0x%08x corrupted\n", i);
 
 			brelse(bh);
-			s->s_root = NULL;
-			kfree(info->si_imap);
-			kfree(info);
-			s->s_fs_info = NULL;
-			return -EIO;
+			ret = -EIO;
+			goto out3;
 		}
 
 		if (!di->i_ino) {
@@ -483,11 +476,17 @@
 		s->s_dirt = 1;
 	} 
 	dump_imap("read_super", s);
-	mutex_init(&info->bfs_lock);
 	return 0;
 
+out3:
+	dput(s->s_root);
+	s->s_root = NULL;
+out2:
+	kfree(info->si_imap);
+out1:
+	brelse(info->si_sbh);
 out:
-	brelse(bh);
+	mutex_destroy(&info->bfs_lock);
 	kfree(info);
 	s->s_fs_info = NULL;
 	return ret;
diff -Nur linux-2.6.32-orig/fs/binfmt_aout.c iDroid-Project-kernel_common-9e90fd2/fs/binfmt_aout.c
--- linux-2.6.32-orig/fs/binfmt_aout.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/binfmt_aout.c	2010-11-18 21:05:30.000000000 +0600
@@ -263,6 +263,7 @@
 #else
 	set_personality(PER_LINUX);
 #endif
+	setup_new_exec(bprm);
 
 	current->mm->end_code = ex.a_text +
 		(current->mm->start_code = N_TXTADDR(ex));
diff -Nur linux-2.6.32-orig/fs/binfmt_elf.c iDroid-Project-kernel_common-9e90fd2/fs/binfmt_elf.c
--- linux-2.6.32-orig/fs/binfmt_elf.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/binfmt_elf.c	2010-11-18 21:05:30.000000000 +0600
@@ -662,27 +662,6 @@
 			if (elf_interpreter[elf_ppnt->p_filesz - 1] != '\0')
 				goto out_free_interp;
 
-			/*
-			 * The early SET_PERSONALITY here is so that the lookup
-			 * for the interpreter happens in the namespace of the 
-			 * to-be-execed image.  SET_PERSONALITY can select an
-			 * alternate root.
-			 *
-			 * However, SET_PERSONALITY is NOT allowed to switch
-			 * this task into the new images's memory mapping
-			 * policy - that is, TASK_SIZE must still evaluate to
-			 * that which is appropriate to the execing application.
-			 * This is because exit_mmap() needs to have TASK_SIZE
-			 * evaluate to the size of the old image.
-			 *
-			 * So if (say) a 64-bit application is execing a 32-bit
-			 * application it is the architecture's responsibility
-			 * to defer changing the value of TASK_SIZE until the
-			 * switch really is going to happen - do this in
-			 * flush_thread().	- akpm
-			 */
-			SET_PERSONALITY(loc->elf_ex);
-
 			interpreter = open_exec(elf_interpreter);
 			retval = PTR_ERR(interpreter);
 			if (IS_ERR(interpreter))
@@ -730,9 +709,6 @@
 		/* Verify the interpreter has a valid arch */
 		if (!elf_check_arch(&loc->interp_elf_ex))
 			goto out_free_dentry;
-	} else {
-		/* Executables without an interpreter also need a personality  */
-		SET_PERSONALITY(loc->elf_ex);
 	}
 
 	/* Flush all traces of the currently running executable */
@@ -752,7 +728,8 @@
 
 	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
 		current->flags |= PF_RANDOMIZE;
-	arch_pick_mmap_layout(current->mm);
+
+	setup_new_exec(bprm);
 
 	/* Do this so that we can load the interpreter, if need be.  We will
 	   change some of these later */
diff -Nur linux-2.6.32-orig/fs/binfmt_elf_fdpic.c iDroid-Project-kernel_common-9e90fd2/fs/binfmt_elf_fdpic.c
--- linux-2.6.32-orig/fs/binfmt_elf_fdpic.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/binfmt_elf_fdpic.c	2010-11-18 21:05:30.000000000 +0600
@@ -171,6 +171,9 @@
 #ifdef ELF_FDPIC_PLAT_INIT
 	unsigned long dynaddr;
 #endif
+#ifndef CONFIG_MMU
+	unsigned long stack_prot;
+#endif
 	struct file *interpreter = NULL; /* to shut gcc up */
 	char *interpreter_name = NULL;
 	int executable_stack;
@@ -316,6 +319,11 @@
 	 * defunct, deceased, etc. after this point we have to exit via
 	 * error_kill */
 	set_personality(PER_LINUX_FDPIC);
+	if (elf_read_implies_exec(&exec_params.hdr, executable_stack))
+		current->personality |= READ_IMPLIES_EXEC;
+
+	setup_new_exec(bprm);
+
 	set_binfmt(&elf_fdpic_format);
 
 	current->mm->start_code = 0;
@@ -377,9 +385,13 @@
 	if (stack_size < PAGE_SIZE * 2)
 		stack_size = PAGE_SIZE * 2;
 
+	stack_prot = PROT_READ | PROT_WRITE;
+	if (executable_stack == EXSTACK_ENABLE_X ||
+	    (executable_stack == EXSTACK_DEFAULT && VM_STACK_FLAGS & VM_EXEC))
+		stack_prot |= PROT_EXEC;
+
 	down_write(&current->mm->mmap_sem);
-	current->mm->start_brk = do_mmap(NULL, 0, stack_size,
-					 PROT_READ | PROT_WRITE | PROT_EXEC,
+	current->mm->start_brk = do_mmap(NULL, 0, stack_size, stack_prot,
 					 MAP_PRIVATE | MAP_ANONYMOUS | MAP_GROWSDOWN,
 					 0);
 
diff -Nur linux-2.6.32-orig/fs/binfmt_flat.c iDroid-Project-kernel_common-9e90fd2/fs/binfmt_flat.c
--- linux-2.6.32-orig/fs/binfmt_flat.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/binfmt_flat.c	2010-11-18 21:05:30.000000000 +0600
@@ -519,6 +519,7 @@
 
 		/* OK, This is the point of no return */
 		set_personality(PER_LINUX_32BIT);
+		setup_new_exec(bprm);
 	}
 
 	/*
diff -Nur linux-2.6.32-orig/fs/binfmt_som.c iDroid-Project-kernel_common-9e90fd2/fs/binfmt_som.c
--- linux-2.6.32-orig/fs/binfmt_som.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/binfmt_som.c	2010-11-18 21:05:30.000000000 +0600
@@ -227,6 +227,7 @@
 	/* OK, This is the point of no return */
 	current->flags &= ~PF_FORKNOEXEC;
 	current->personality = PER_HPUX;
+	setup_new_exec(bprm);
 
 	/* Set the task size for HP-UX processes such that
 	 * the gateway page is outside the address space.
diff -Nur linux-2.6.32-orig/fs/bio.c iDroid-Project-kernel_common-9e90fd2/fs/bio.c
--- linux-2.6.32-orig/fs/bio.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/bio.c	2010-11-18 21:05:30.000000000 +0600
@@ -542,13 +542,18 @@
 
 		if (page == prev->bv_page &&
 		    offset == prev->bv_offset + prev->bv_len) {
+			unsigned int prev_bv_len = prev->bv_len;
 			prev->bv_len += len;
 
 			if (q->merge_bvec_fn) {
 				struct bvec_merge_data bvm = {
+					/* prev_bvec is already charged in
+					   bi_size, discharge it in order to
+					   simulate merging updated prev_bvec
+					   as new bvec. */
 					.bi_bdev = bio->bi_bdev,
 					.bi_sector = bio->bi_sector,
-					.bi_size = bio->bi_size,
+					.bi_size = bio->bi_size - prev_bv_len,
 					.bi_rw = bio->bi_rw,
 				};
 
diff -Nur linux-2.6.32-orig/fs/bio-integrity.c iDroid-Project-kernel_common-9e90fd2/fs/bio-integrity.c
--- linux-2.6.32-orig/fs/bio-integrity.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/bio-integrity.c	2010-11-18 21:05:30.000000000 +0600
@@ -61,7 +61,7 @@
 
 static inline int use_bip_pool(unsigned int idx)
 {
-	if (idx == BIOVEC_NR_POOLS)
+	if (idx == BIOVEC_MAX_IDX)
 		return 1;
 
 	return 0;
@@ -95,6 +95,7 @@
 
 	/* Use mempool if lower order alloc failed or max vecs were requested */
 	if (bip == NULL) {
+		idx = BIOVEC_MAX_IDX;  /* so we free the payload properly later */
 		bip = mempool_alloc(bs->bio_integrity_pool, gfp_mask);
 
 		if (unlikely(bip == NULL)) {
diff -Nur linux-2.6.32-orig/fs/block_dev.c iDroid-Project-kernel_common-9e90fd2/fs/block_dev.c
--- linux-2.6.32-orig/fs/block_dev.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/block_dev.c	2010-11-18 21:05:30.000000000 +0600
@@ -246,7 +246,8 @@
 	if (!sb)
 		goto out;
 	if (sb->s_flags & MS_RDONLY) {
-		deactivate_locked_super(sb);
+		sb->s_frozen = SB_FREEZE_TRANS;
+		up_write(&sb->s_umount);
 		mutex_unlock(&bdev->bd_fsfreeze_mutex);
 		return sb;
 	}
@@ -307,7 +308,7 @@
 	BUG_ON(sb->s_bdev != bdev);
 	down_write(&sb->s_umount);
 	if (sb->s_flags & MS_RDONLY)
-		goto out_deactivate;
+		goto out_unfrozen;
 
 	if (sb->s_op->unfreeze_fs) {
 		error = sb->s_op->unfreeze_fs(sb);
@@ -321,11 +322,11 @@
 		}
 	}
 
+out_unfrozen:
 	sb->s_frozen = SB_UNFROZEN;
 	smp_wmb();
 	wake_up(&sb->s_wait_unfrozen);
 
-out_deactivate:
 	if (sb)
 		deactivate_locked_super(sb);
 out_unlock:
diff -Nur linux-2.6.32-orig/fs/cifs/connect.c iDroid-Project-kernel_common-9e90fd2/fs/cifs/connect.c
--- linux-2.6.32-orig/fs/cifs/connect.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/cifs/connect.c	2010-11-18 21:05:30.000000000 +0600
@@ -2287,12 +2287,12 @@
 cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,
 		char *mount_data_global, const char *devname)
 {
-	int rc = 0;
+	int rc;
 	int xid;
 	struct smb_vol *volume_info;
-	struct cifsSesInfo *pSesInfo = NULL;
-	struct cifsTconInfo *tcon = NULL;
-	struct TCP_Server_Info *srvTcp = NULL;
+	struct cifsSesInfo *pSesInfo;
+	struct cifsTconInfo *tcon;
+	struct TCP_Server_Info *srvTcp;
 	char   *full_path;
 	char *mount_data = mount_data_global;
 #ifdef CONFIG_CIFS_DFS_UPCALL
@@ -2301,6 +2301,10 @@
 	int referral_walks_count = 0;
 try_mount_again:
 #endif
+	rc = 0;
+	tcon = NULL;
+	pSesInfo = NULL;
+	srvTcp = NULL;
 	full_path = NULL;
 
 	xid = GetXid();
@@ -2597,6 +2601,7 @@
 
 			cleanup_volume_info(&volume_info);
 			referral_walks_count++;
+			FreeXid(xid);
 			goto try_mount_again;
 		}
 #else /* No DFS support, return error on mount */
diff -Nur linux-2.6.32-orig/fs/cifs/readdir.c iDroid-Project-kernel_common-9e90fd2/fs/cifs/readdir.c
--- linux-2.6.32-orig/fs/cifs/readdir.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/cifs/readdir.c	2010-11-18 21:05:30.000000000 +0600
@@ -666,6 +666,7 @@
 					   min(len, max_len), nlt,
 					   cifs_sb->mnt_cifs_flags &
 						CIFS_MOUNT_MAP_SPECIAL_CHR);
+		pqst->len -= nls_nullsize(nlt);
 	} else {
 		pqst->name = filename;
 		pqst->len = len;
diff -Nur linux-2.6.32-orig/fs/debugfs/inode.c iDroid-Project-kernel_common-9e90fd2/fs/debugfs/inode.c
--- linux-2.6.32-orig/fs/debugfs/inode.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/debugfs/inode.c	2010-11-18 21:05:30.000000000 +0600
@@ -32,7 +32,9 @@
 static int debugfs_mount_count;
 static bool debugfs_registered;
 
-static struct inode *debugfs_get_inode(struct super_block *sb, int mode, dev_t dev)
+static struct inode *debugfs_get_inode(struct super_block *sb, int mode, dev_t dev,
+				       void *data, const struct file_operations *fops)
+
 {
 	struct inode *inode = new_inode(sb);
 
@@ -44,14 +46,18 @@
 			init_special_inode(inode, mode, dev);
 			break;
 		case S_IFREG:
-			inode->i_fop = &debugfs_file_operations;
+			inode->i_fop = fops ? fops : &debugfs_file_operations;
+			inode->i_private = data;
 			break;
 		case S_IFLNK:
 			inode->i_op = &debugfs_link_operations;
+			inode->i_fop = fops;
+			inode->i_private = data;
 			break;
 		case S_IFDIR:
 			inode->i_op = &simple_dir_inode_operations;
-			inode->i_fop = &simple_dir_operations;
+			inode->i_fop = fops ? fops : &simple_dir_operations;
+			inode->i_private = data;
 
 			/* directory inodes start off with i_nlink == 2
 			 * (for "." entry) */
@@ -64,7 +70,8 @@
 
 /* SMP-safe */
 static int debugfs_mknod(struct inode *dir, struct dentry *dentry,
-			 int mode, dev_t dev)
+			 int mode, dev_t dev, void *data,
+			 const struct file_operations *fops)
 {
 	struct inode *inode;
 	int error = -EPERM;
@@ -72,7 +79,7 @@
 	if (dentry->d_inode)
 		return -EEXIST;
 
-	inode = debugfs_get_inode(dir->i_sb, mode, dev);
+	inode = debugfs_get_inode(dir->i_sb, mode, dev, data, fops);
 	if (inode) {
 		d_instantiate(dentry, inode);
 		dget(dentry);
@@ -81,12 +88,13 @@
 	return error;
 }
 
-static int debugfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+static int debugfs_mkdir(struct inode *dir, struct dentry *dentry, int mode,
+			 void *data, const struct file_operations *fops)
 {
 	int res;
 
 	mode = (mode & (S_IRWXUGO | S_ISVTX)) | S_IFDIR;
-	res = debugfs_mknod(dir, dentry, mode, 0);
+	res = debugfs_mknod(dir, dentry, mode, 0, data, fops);
 	if (!res) {
 		inc_nlink(dir);
 		fsnotify_mkdir(dir, dentry);
@@ -94,18 +102,20 @@
 	return res;
 }
 
-static int debugfs_link(struct inode *dir, struct dentry *dentry, int mode)
+static int debugfs_link(struct inode *dir, struct dentry *dentry, int mode,
+			void *data, const struct file_operations *fops)
 {
 	mode = (mode & S_IALLUGO) | S_IFLNK;
-	return debugfs_mknod(dir, dentry, mode, 0);
+	return debugfs_mknod(dir, dentry, mode, 0, data, fops);
 }
 
-static int debugfs_create(struct inode *dir, struct dentry *dentry, int mode)
+static int debugfs_create(struct inode *dir, struct dentry *dentry, int mode,
+			  void *data, const struct file_operations *fops)
 {
 	int res;
 
 	mode = (mode & S_IALLUGO) | S_IFREG;
-	res = debugfs_mknod(dir, dentry, mode, 0);
+	res = debugfs_mknod(dir, dentry, mode, 0, data, fops);
 	if (!res)
 		fsnotify_create(dir, dentry);
 	return res;
@@ -139,7 +149,9 @@
 
 static int debugfs_create_by_name(const char *name, mode_t mode,
 				  struct dentry *parent,
-				  struct dentry **dentry)
+				  struct dentry **dentry,
+				  void *data,
+				  const struct file_operations *fops)
 {
 	int error = 0;
 
@@ -164,13 +176,16 @@
 	if (!IS_ERR(*dentry)) {
 		switch (mode & S_IFMT) {
 		case S_IFDIR:
-			error = debugfs_mkdir(parent->d_inode, *dentry, mode);
+			error = debugfs_mkdir(parent->d_inode, *dentry, mode,
+					      data, fops);
 			break;
 		case S_IFLNK:
-			error = debugfs_link(parent->d_inode, *dentry, mode);
+			error = debugfs_link(parent->d_inode, *dentry, mode,
+					     data, fops);
 			break;
 		default:
-			error = debugfs_create(parent->d_inode, *dentry, mode);
+			error = debugfs_create(parent->d_inode, *dentry, mode,
+					       data, fops);
 			break;
 		}
 		dput(*dentry);
@@ -221,19 +236,13 @@
 	if (error)
 		goto exit;
 
-	error = debugfs_create_by_name(name, mode, parent, &dentry);
+	error = debugfs_create_by_name(name, mode, parent, &dentry,
+				       data, fops);
 	if (error) {
 		dentry = NULL;
 		simple_release_fs(&debugfs_mount, &debugfs_mount_count);
 		goto exit;
 	}
-
-	if (dentry->d_inode) {
-		if (data)
-			dentry->d_inode->i_private = data;
-		if (fops)
-			dentry->d_inode->i_fop = fops;
-	}
 exit:
 	return dentry;
 }
diff -Nur linux-2.6.32-orig/fs/devpts/inode.c iDroid-Project-kernel_common-9e90fd2/fs/devpts/inode.c
--- linux-2.6.32-orig/fs/devpts/inode.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/devpts/inode.c	2010-11-18 21:05:30.000000000 +0600
@@ -517,11 +517,23 @@
 
 struct tty_struct *devpts_get_tty(struct inode *pts_inode, int number)
 {
+	struct dentry *dentry;
+	struct tty_struct *tty;
+
 	BUG_ON(pts_inode->i_rdev == MKDEV(TTYAUX_MAJOR, PTMX_MINOR));
 
+	/* Ensure dentry has not been deleted by devpts_pty_kill() */
+	dentry = d_find_alias(pts_inode);
+	if (!dentry)
+		return NULL;
+
+	tty = NULL;
 	if (pts_inode->i_sb->s_magic == DEVPTS_SUPER_MAGIC)
-		return (struct tty_struct *)pts_inode->i_private;
-	return NULL;
+		tty = (struct tty_struct *)pts_inode->i_private;
+
+	dput(dentry);
+
+	return tty;
 }
 
 void devpts_pty_kill(struct tty_struct *tty)
diff -Nur linux-2.6.32-orig/fs/ecryptfs/crypto.c iDroid-Project-kernel_common-9e90fd2/fs/ecryptfs/crypto.c
--- linux-2.6.32-orig/fs/ecryptfs/crypto.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ecryptfs/crypto.c	2010-11-18 21:05:30.000000000 +0600
@@ -1748,7 +1748,7 @@
 			    char *cipher_name, size_t *key_size)
 {
 	char dummy_key[ECRYPTFS_MAX_KEY_BYTES];
-	char *full_alg_name;
+	char *full_alg_name = NULL;
 	int rc;
 
 	*key_tfm = NULL;
@@ -1763,7 +1763,6 @@
 	if (rc)
 		goto out;
 	*key_tfm = crypto_alloc_blkcipher(full_alg_name, 0, CRYPTO_ALG_ASYNC);
-	kfree(full_alg_name);
 	if (IS_ERR(*key_tfm)) {
 		rc = PTR_ERR(*key_tfm);
 		printk(KERN_ERR "Unable to allocate crypto cipher with name "
@@ -1786,6 +1785,7 @@
 		goto out;
 	}
 out:
+	kfree(full_alg_name);
 	return rc;
 }
 
diff -Nur linux-2.6.32-orig/fs/ecryptfs/file.c iDroid-Project-kernel_common-9e90fd2/fs/ecryptfs/file.c
--- linux-2.6.32-orig/fs/ecryptfs/file.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ecryptfs/file.c	2010-11-18 21:05:30.000000000 +0600
@@ -191,13 +191,6 @@
 				      | ECRYPTFS_ENCRYPTED);
 	}
 	mutex_unlock(&crypt_stat->cs_mutex);
-	if ((ecryptfs_inode_to_private(inode)->lower_file->f_flags & O_RDONLY)
-	    && !(file->f_flags & O_RDONLY)) {
-		rc = -EPERM;
-		printk(KERN_WARNING "%s: Lower persistent file is RO; eCryptfs "
-		       "file must hence be opened RO\n", __func__);
-		goto out;
-	}
 	if (!ecryptfs_inode_to_private(inode)->lower_file) {
 		rc = ecryptfs_init_persistent_file(ecryptfs_dentry);
 		if (rc) {
@@ -208,6 +201,13 @@
 			goto out;
 		}
 	}
+	if ((ecryptfs_inode_to_private(inode)->lower_file->f_flags & O_RDONLY)
+	    && !(file->f_flags & O_RDONLY)) {
+		rc = -EPERM;
+		printk(KERN_WARNING "%s: Lower persistent file is RO; eCryptfs "
+		       "file must hence be opened RO\n", __func__);
+		goto out;
+	}
 	ecryptfs_set_file_lower(
 		file, ecryptfs_inode_to_private(inode)->lower_file);
 	if (S_ISDIR(ecryptfs_dentry->d_inode->i_mode)) {
diff -Nur linux-2.6.32-orig/fs/ecryptfs/inode.c iDroid-Project-kernel_common-9e90fd2/fs/ecryptfs/inode.c
--- linux-2.6.32-orig/fs/ecryptfs/inode.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ecryptfs/inode.c	2010-11-18 21:05:30.000000000 +0600
@@ -971,6 +971,21 @@
 	return rc;
 }
 
+int ecryptfs_getattr(struct vfsmount *mnt, struct dentry *dentry,
+		     struct kstat *stat)
+{
+	struct kstat lower_stat;
+	int rc;
+
+	rc = vfs_getattr(ecryptfs_dentry_to_lower_mnt(dentry),
+			 ecryptfs_dentry_to_lower(dentry), &lower_stat);
+	if (!rc) {
+		generic_fillattr(dentry->d_inode, stat);
+		stat->blocks = lower_stat.blocks;
+	}
+	return rc;
+}
+
 int
 ecryptfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 		  size_t size, int flags)
@@ -1100,6 +1115,7 @@
 const struct inode_operations ecryptfs_main_iops = {
 	.permission = ecryptfs_permission,
 	.setattr = ecryptfs_setattr,
+	.getattr = ecryptfs_getattr,
 	.setxattr = ecryptfs_setxattr,
 	.getxattr = ecryptfs_getxattr,
 	.listxattr = ecryptfs_listxattr,
diff -Nur linux-2.6.32-orig/fs/exec.c iDroid-Project-kernel_common-9e90fd2/fs/exec.c
--- linux-2.6.32-orig/fs/exec.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/exec.c	2010-11-18 21:05:30.000000000 +0600
@@ -572,6 +572,9 @@
 	struct vm_area_struct *prev = NULL;
 	unsigned long vm_flags;
 	unsigned long stack_base;
+	unsigned long stack_size;
+	unsigned long stack_expand;
+	unsigned long rlim_stack;
 
 #ifdef CONFIG_STACK_GROWSUP
 	/* Limit stack size to 1GB */
@@ -628,10 +631,24 @@
 			goto out_unlock;
 	}
 
+	stack_expand = EXTRA_STACK_VM_PAGES * PAGE_SIZE;
+	stack_size = vma->vm_end - vma->vm_start;
+	/*
+	 * Align this down to a page boundary as expand_stack
+	 * will align it up.
+	 */
+	rlim_stack = rlimit(RLIMIT_STACK) & PAGE_MASK;
+	rlim_stack = min(rlim_stack, stack_size);
 #ifdef CONFIG_STACK_GROWSUP
-	stack_base = vma->vm_end + EXTRA_STACK_VM_PAGES * PAGE_SIZE;
+	if (stack_size + stack_expand > rlim_stack)
+		stack_base = vma->vm_start + rlim_stack;
+	else
+		stack_base = vma->vm_end + stack_expand;
 #else
-	stack_base = vma->vm_start - EXTRA_STACK_VM_PAGES * PAGE_SIZE;
+	if (stack_size + stack_expand > rlim_stack)
+		stack_base = vma->vm_end - rlim_stack;
+	else
+		stack_base = vma->vm_start - stack_expand;
 #endif
 	ret = expand_stack(vma, stack_base);
 	if (ret)
@@ -931,9 +948,7 @@
 
 int flush_old_exec(struct linux_binprm * bprm)
 {
-	char * name;
-	int i, ch, retval;
-	char tcomm[sizeof(current->comm)];
+	int retval;
 
 	/*
 	 * Make sure we have a private signal table and that
@@ -954,6 +969,25 @@
 
 	bprm->mm = NULL;		/* We're using it now */
 
+	current->flags &= ~PF_RANDOMIZE;
+	flush_thread();
+	current->personality &= ~bprm->per_clear;
+
+	return 0;
+
+out:
+	return retval;
+}
+EXPORT_SYMBOL(flush_old_exec);
+
+void setup_new_exec(struct linux_binprm * bprm)
+{
+	int i, ch;
+	char * name;
+	char tcomm[sizeof(current->comm)];
+
+	arch_pick_mmap_layout(current->mm);
+
 	/* This is the point of no return */
 	current->sas_ss_sp = current->sas_ss_size = 0;
 
@@ -975,9 +1009,6 @@
 	tcomm[i] = '\0';
 	set_task_comm(current, tcomm);
 
-	current->flags &= ~PF_RANDOMIZE;
-	flush_thread();
-
 	/* Set the new mm task size. We have to do that late because it may
 	 * depend on TIF_32BIT which is only updated in flush_thread() on
 	 * some architectures like powerpc
@@ -993,8 +1024,6 @@
 		set_dumpable(current->mm, suid_dumpable);
 	}
 
-	current->personality &= ~bprm->per_clear;
-
 	/*
 	 * Flush performance counters when crossing a
 	 * security domain:
@@ -1009,14 +1038,8 @@
 			
 	flush_signal_handlers(current, 0);
 	flush_old_files(current->files);
-
-	return 0;
-
-out:
-	return retval;
 }
-
-EXPORT_SYMBOL(flush_old_exec);
+EXPORT_SYMBOL(setup_new_exec);
 
 /*
  * Prepare credentials and lock ->cred_guard_mutex.
diff -Nur linux-2.6.32-orig/fs/exofs/inode.c iDroid-Project-kernel_common-9e90fd2/fs/exofs/inode.c
--- linux-2.6.32-orig/fs/exofs/inode.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/exofs/inode.c	2010-11-18 21:05:30.000000000 +0600
@@ -731,13 +731,28 @@
 					fsdata);
 }
 
+static int exofs_write_end(struct file *file, struct address_space *mapping,
+			loff_t pos, unsigned len, unsigned copied,
+			struct page *page, void *fsdata)
+{
+	struct inode *inode = mapping->host;
+	/* According to comment in simple_write_end i_mutex is held */
+	loff_t i_size = inode->i_size;
+	int ret;
+
+	ret = simple_write_end(file, mapping,pos, len, copied, page, fsdata);
+	if (i_size != inode->i_size)
+		mark_inode_dirty(inode);
+	return ret;
+}
+
 const struct address_space_operations exofs_aops = {
 	.readpage	= exofs_readpage,
 	.readpages	= exofs_readpages,
 	.writepage	= exofs_writepage,
 	.writepages	= exofs_writepages,
 	.write_begin	= exofs_write_begin_export,
-	.write_end	= simple_write_end,
+	.write_end	= exofs_write_end,
 };
 
 /******************************************************************************
diff -Nur linux-2.6.32-orig/fs/ext3/inode.c iDroid-Project-kernel_common-9e90fd2/fs/ext3/inode.c
--- linux-2.6.32-orig/fs/ext3/inode.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext3/inode.c	2010-11-18 21:05:30.000000000 +0600
@@ -1151,6 +1151,16 @@
 	return ext3_journal_get_write_access(handle, bh);
 }
 
+/*
+ * Truncate blocks that were not used by write. We have to truncate the
+ * pagecache as well so that corresponding buffers get properly unmapped.
+ */
+static void ext3_truncate_failed_write(struct inode *inode)
+{
+	truncate_inode_pages(inode->i_mapping, inode->i_size);
+	ext3_truncate(inode);
+}
+
 static int ext3_write_begin(struct file *file, struct address_space *mapping,
 				loff_t pos, unsigned len, unsigned flags,
 				struct page **pagep, void **fsdata)
@@ -1209,7 +1219,7 @@
 		unlock_page(page);
 		page_cache_release(page);
 		if (pos + len > inode->i_size)
-			ext3_truncate(inode);
+			ext3_truncate_failed_write(inode);
 	}
 	if (ret == -ENOSPC && ext3_should_retry_alloc(inode->i_sb, &retries))
 		goto retry;
@@ -1304,7 +1314,7 @@
 	page_cache_release(page);
 
 	if (pos + len > inode->i_size)
-		ext3_truncate(inode);
+		ext3_truncate_failed_write(inode);
 	return ret ? ret : copied;
 }
 
@@ -1330,7 +1340,7 @@
 	page_cache_release(page);
 
 	if (pos + len > inode->i_size)
-		ext3_truncate(inode);
+		ext3_truncate_failed_write(inode);
 	return ret ? ret : copied;
 }
 
@@ -1383,7 +1393,7 @@
 	page_cache_release(page);
 
 	if (pos + len > inode->i_size)
-		ext3_truncate(inode);
+		ext3_truncate_failed_write(inode);
 	return ret ? ret : copied;
 }
 
diff -Nur linux-2.6.32-orig/fs/ext4/balloc.c iDroid-Project-kernel_common-9e90fd2/fs/ext4/balloc.c
--- linux-2.6.32-orig/fs/ext4/balloc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/balloc.c	2010-11-18 21:05:30.000000000 +0600
@@ -761,7 +761,13 @@
 static unsigned long ext4_bg_num_gdb_nometa(struct super_block *sb,
 					ext4_group_t group)
 {
-	return ext4_bg_has_super(sb, group) ? EXT4_SB(sb)->s_gdb_count : 0;
+	if (!ext4_bg_has_super(sb, group))
+		return 0;
+
+	if (EXT4_HAS_INCOMPAT_FEATURE(sb,EXT4_FEATURE_INCOMPAT_META_BG))
+		return le32_to_cpu(EXT4_SB(sb)->s_es->s_first_meta_bg);
+	else
+		return EXT4_SB(sb)->s_gdb_count;
 }
 
 /**
diff -Nur linux-2.6.32-orig/fs/ext4/block_validity.c iDroid-Project-kernel_common-9e90fd2/fs/ext4/block_validity.c
--- linux-2.6.32-orig/fs/ext4/block_validity.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/block_validity.c	2010-11-18 21:05:30.000000000 +0600
@@ -160,7 +160,7 @@
 		if (ext4_bg_has_super(sb, i) &&
 		    ((i < 5) || ((i % flex_size) == 0)))
 			add_system_zone(sbi, ext4_group_first_block_no(sb, i),
-					sbi->s_gdb_count + 1);
+					ext4_bg_num_gdb(sb, i) + 1);
 		gdp = ext4_get_group_desc(sb, i, NULL);
 		ret = add_system_zone(sbi, ext4_block_bitmap(sb, gdp), 1);
 		if (ret)
diff -Nur linux-2.6.32-orig/fs/ext4/ext4.h iDroid-Project-kernel_common-9e90fd2/fs/ext4/ext4.h
--- linux-2.6.32-orig/fs/ext4/ext4.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/ext4.h	2010-11-18 21:05:30.000000000 +0600
@@ -698,11 +698,22 @@
 	__u16 i_extra_isize;
 
 	spinlock_t i_block_reservation_lock;
+#ifdef CONFIG_QUOTA
+	/* quota space reservation, managed internally by quota code */
+	qsize_t i_reserved_quota;
+#endif
 
 	/* completed async DIOs that might need unwritten extents handling */
 	struct list_head i_aio_dio_complete_list;
 	/* current io_end structure for async DIO write*/
 	ext4_io_end_t *cur_aio_dio;
+
+	/*
+	 * Transactions that contain inode's metadata needed to complete
+	 * fsync and fdatasync, respectively.
+	 */
+	tid_t i_sync_tid;
+	tid_t i_datasync_tid;
 };
 
 /*
@@ -750,6 +761,7 @@
 #define EXT4_MOUNT_DELALLOC		0x8000000 /* Delalloc support */
 #define EXT4_MOUNT_DATA_ERR_ABORT	0x10000000 /* Abort on file data write */
 #define EXT4_MOUNT_BLOCK_VALIDITY	0x20000000 /* Block validity checking */
+#define EXT4_MOUNT_DISCARD		0x40000000 /* Issue DISCARD requests */
 
 #define clear_opt(o, opt)		o &= ~EXT4_MOUNT_##opt
 #define set_opt(o, opt)			o |= EXT4_MOUNT_##opt
@@ -1424,7 +1436,7 @@
 extern int ext4_block_truncate_page(handle_t *handle,
 		struct address_space *mapping, loff_t from);
 extern int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf);
-extern qsize_t ext4_get_reserved_space(struct inode *inode);
+extern qsize_t *ext4_get_reserved_space(struct inode *inode);
 extern int flush_aio_dio_completed_IO(struct inode *inode);
 /* ioctl.c */
 extern long ext4_ioctl(struct file *, unsigned int, unsigned long);
diff -Nur linux-2.6.32-orig/fs/ext4/ext4_jbd2.h iDroid-Project-kernel_common-9e90fd2/fs/ext4/ext4_jbd2.h
--- linux-2.6.32-orig/fs/ext4/ext4_jbd2.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/ext4_jbd2.h	2010-11-18 21:05:30.000000000 +0600
@@ -49,7 +49,7 @@
 
 #define EXT4_DATA_TRANS_BLOCKS(sb)	(EXT4_SINGLEDATA_TRANS_BLOCKS(sb) + \
 					 EXT4_XATTR_TRANS_BLOCKS - 2 + \
-					 2*EXT4_QUOTA_TRANS_BLOCKS(sb))
+					 EXT4_MAXQUOTAS_TRANS_BLOCKS(sb))
 
 /*
  * Define the number of metadata blocks we need to account to modify data.
@@ -57,7 +57,7 @@
  * This include super block, inode block, quota blocks and xattr blocks
  */
 #define EXT4_META_TRANS_BLOCKS(sb)	(EXT4_XATTR_TRANS_BLOCKS + \
-					2*EXT4_QUOTA_TRANS_BLOCKS(sb))
+					EXT4_MAXQUOTAS_TRANS_BLOCKS(sb))
 
 /* Delete operations potentially hit one directory's namespace plus an
  * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be
@@ -92,6 +92,7 @@
  * but inode, sb and group updates are done only once */
 #define EXT4_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\
 		(EXT4_SINGLEDATA_TRANS_BLOCKS(sb)-3)+3+DQUOT_INIT_REWRITE) : 0)
+
 #define EXT4_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\
 		(EXT4_SINGLEDATA_TRANS_BLOCKS(sb)-3)+3+DQUOT_DEL_REWRITE) : 0)
 #else
@@ -99,6 +100,9 @@
 #define EXT4_QUOTA_INIT_BLOCKS(sb) 0
 #define EXT4_QUOTA_DEL_BLOCKS(sb) 0
 #endif
+#define EXT4_MAXQUOTAS_TRANS_BLOCKS(sb) (MAXQUOTAS*EXT4_QUOTA_TRANS_BLOCKS(sb))
+#define EXT4_MAXQUOTAS_INIT_BLOCKS(sb) (MAXQUOTAS*EXT4_QUOTA_INIT_BLOCKS(sb))
+#define EXT4_MAXQUOTAS_DEL_BLOCKS(sb) (MAXQUOTAS*EXT4_QUOTA_DEL_BLOCKS(sb))
 
 int
 ext4_mark_iloc_dirty(handle_t *handle,
@@ -254,6 +258,19 @@
 	return 0;
 }
 
+static inline void ext4_update_inode_fsync_trans(handle_t *handle,
+						 struct inode *inode,
+						 int datasync)
+{
+	struct ext4_inode_info *ei = EXT4_I(inode);
+
+	if (ext4_handle_valid(handle)) {
+		ei->i_sync_tid = handle->h_transaction->t_tid;
+		if (datasync)
+			ei->i_datasync_tid = handle->h_transaction->t_tid;
+	}
+}
+
 /* super.c */
 int ext4_force_commit(struct super_block *sb);
 
diff -Nur linux-2.6.32-orig/fs/ext4/extents.c iDroid-Project-kernel_common-9e90fd2/fs/ext4/extents.c
--- linux-2.6.32-orig/fs/ext4/extents.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/extents.c	2010-11-18 21:05:30.000000000 +0600
@@ -1761,7 +1761,9 @@
 	while (block < last && block != EXT_MAX_BLOCK) {
 		num = last - block;
 		/* find extent for this block */
+		down_read(&EXT4_I(inode)->i_data_sem);
 		path = ext4_ext_find_extent(inode, block, path);
+		up_read(&EXT4_I(inode)->i_data_sem);
 		if (IS_ERR(path)) {
 			err = PTR_ERR(path);
 			path = NULL;
@@ -2074,7 +2076,7 @@
 		ext_debug("free last %u blocks starting %llu\n", num, start);
 		for (i = 0; i < num; i++) {
 			bh = sb_find_get_block(inode->i_sb, start + i);
-			ext4_forget(handle, 0, inode, bh, start + i);
+			ext4_forget(handle, metadata, inode, bh, start + i);
 		}
 		ext4_free_blocks(handle, inode, start, num, metadata);
 	} else if (from == le32_to_cpu(ex->ee_block)
@@ -2167,7 +2169,7 @@
 			correct_index = 1;
 			credits += (ext_depth(inode)) + 1;
 		}
-		credits += 2 * EXT4_QUOTA_TRANS_BLOCKS(inode->i_sb);
+		credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);
 
 		err = ext4_ext_truncate_extend_restart(handle, inode, credits);
 		if (err)
@@ -3064,6 +3066,8 @@
 	if (flags == EXT4_GET_BLOCKS_DIO_CONVERT_EXT) {
 		ret = ext4_convert_unwritten_extents_dio(handle, inode,
 							path);
+		if (ret >= 0)
+			ext4_update_inode_fsync_trans(handle, inode, 1);
 		goto out2;
 	}
 	/* buffered IO case */
@@ -3091,6 +3095,8 @@
 	ret = ext4_ext_convert_to_initialized(handle, inode,
 						path, iblock,
 						max_blocks);
+	if (ret >= 0)
+		ext4_update_inode_fsync_trans(handle, inode, 1);
 out:
 	if (ret <= 0) {
 		err = ret;
@@ -3329,10 +3335,16 @@
 	allocated = ext4_ext_get_actual_len(&newex);
 	set_buffer_new(bh_result);
 
-	/* Cache only when it is _not_ an uninitialized extent */
-	if ((flags & EXT4_GET_BLOCKS_UNINIT_EXT) == 0)
+	/*
+	 * Cache the extent and update transaction to commit on fdatasync only
+	 * when it is _not_ an uninitialized extent.
+	 */
+	if ((flags & EXT4_GET_BLOCKS_UNINIT_EXT) == 0) {
 		ext4_ext_put_in_cache(inode, iblock, allocated, newblock,
 						EXT4_EXT_CACHE_EXTENT);
+		ext4_update_inode_fsync_trans(handle, inode, 1);
+	} else
+		ext4_update_inode_fsync_trans(handle, inode, 0);
 out:
 	if (allocated > max_blocks)
 		allocated = max_blocks;
@@ -3720,10 +3732,8 @@
 		 * Walk the extent tree gathering extent information.
 		 * ext4_ext_fiemap_cb will push extents back to user.
 		 */
-		down_read(&EXT4_I(inode)->i_data_sem);
 		error = ext4_ext_walk_space(inode, start_blk, len_blks,
 					  ext4_ext_fiemap_cb, fieinfo);
-		up_read(&EXT4_I(inode)->i_data_sem);
 	}
 
 	return error;
diff -Nur linux-2.6.32-orig/fs/ext4/fsync.c iDroid-Project-kernel_common-9e90fd2/fs/ext4/fsync.c
--- linux-2.6.32-orig/fs/ext4/fsync.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/fsync.c	2010-11-18 21:05:30.000000000 +0600
@@ -51,25 +51,30 @@
 int ext4_sync_file(struct file *file, struct dentry *dentry, int datasync)
 {
 	struct inode *inode = dentry->d_inode;
+	struct ext4_inode_info *ei = EXT4_I(inode);
 	journal_t *journal = EXT4_SB(inode->i_sb)->s_journal;
-	int err, ret = 0;
+	int ret;
+	tid_t commit_tid;
 
 	J_ASSERT(ext4_journal_current_handle() == NULL);
 
 	trace_ext4_sync_file(file, dentry, datasync);
 
+	if (inode->i_sb->s_flags & MS_RDONLY)
+		return 0;
+
 	ret = flush_aio_dio_completed_IO(inode);
 	if (ret < 0)
-		goto out;
+		return ret;
+
+	if (!journal)
+		return simple_fsync(file, dentry, datasync);
+
 	/*
-	 * data=writeback:
+	 * data=writeback,ordered:
 	 *  The caller's filemap_fdatawrite()/wait will sync the data.
-	 *  sync_inode() will sync the metadata
-	 *
-	 * data=ordered:
-	 *  The caller's filemap_fdatawrite() will write the data and
-	 *  sync_inode() will write the inode if it is dirty.  Then the caller's
-	 *  filemap_fdatawait() will wait on the pages.
+	 *  Metadata is in the journal, we wait for proper transaction to
+	 *  commit here.
 	 *
 	 * data=journal:
 	 *  filemap_fdatawrite won't do anything (the buffers are clean).
@@ -79,32 +84,13 @@
 	 *  (they were dirtied by commit).  But that's OK - the blocks are
 	 *  safe in-journal, which is all fsync() needs to ensure.
 	 */
-	if (ext4_should_journal_data(inode)) {
-		ret = ext4_force_commit(inode->i_sb);
-		goto out;
-	}
+	if (ext4_should_journal_data(inode))
+		return ext4_force_commit(inode->i_sb);
 
-	if (!journal)
-		ret = sync_mapping_buffers(inode->i_mapping);
-
-	if (datasync && !(inode->i_state & I_DIRTY_DATASYNC))
-		goto out;
-
-	/*
-	 * The VFS has written the file data.  If the inode is unaltered
-	 * then we need not start a commit.
-	 */
-	if (inode->i_state & (I_DIRTY_SYNC|I_DIRTY_DATASYNC)) {
-		struct writeback_control wbc = {
-			.sync_mode = WB_SYNC_ALL,
-			.nr_to_write = 0, /* sys_fsync did this */
-		};
-		err = sync_inode(inode, &wbc);
-		if (ret == 0)
-			ret = err;
-	}
-out:
-	if (journal && (journal->j_flags & JBD2_BARRIER))
+	commit_tid = datasync ? ei->i_datasync_tid : ei->i_sync_tid;
+	if (jbd2_log_start_commit(journal, commit_tid))
+		jbd2_log_wait_commit(journal, commit_tid);
+	else if (journal->j_flags & JBD2_BARRIER)
 		blkdev_issue_flush(inode->i_sb->s_bdev, NULL);
 	return ret;
 }
diff -Nur linux-2.6.32-orig/fs/ext4/inode.c iDroid-Project-kernel_common-9e90fd2/fs/ext4/inode.c
--- linux-2.6.32-orig/fs/ext4/inode.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/inode.c	2010-11-18 21:05:30.000000000 +0600
@@ -1021,10 +1021,12 @@
 	if (!err)
 		err = ext4_splice_branch(handle, inode, iblock,
 					 partial, indirect_blks, count);
-	else
+	if (err)
 		goto cleanup;
 
 	set_buffer_new(bh_result);
+
+	ext4_update_inode_fsync_trans(handle, inode, 1);
 got_it:
 	map_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));
 	if (count > blocks_to_boundary)
@@ -1043,17 +1045,12 @@
 	return err;
 }
 
-qsize_t ext4_get_reserved_space(struct inode *inode)
+#ifdef CONFIG_QUOTA
+qsize_t *ext4_get_reserved_space(struct inode *inode)
 {
-	unsigned long long total;
-
-	spin_lock(&EXT4_I(inode)->i_block_reservation_lock);
-	total = EXT4_I(inode)->i_reserved_data_blocks +
-		EXT4_I(inode)->i_reserved_meta_blocks;
-	spin_unlock(&EXT4_I(inode)->i_block_reservation_lock);
-
-	return total;
+	return &EXT4_I(inode)->i_reserved_quota;
 }
+#endif
 /*
  * Calculate the number of metadata blocks need to reserve
  * to allocate @blocks for non extent file based file
@@ -1534,6 +1531,16 @@
 	return ext4_journal_get_write_access(handle, bh);
 }
 
+/*
+ * Truncate blocks that were not used by write. We have to truncate the
+ * pagecache as well so that corresponding buffers get properly unmapped.
+ */
+static void ext4_truncate_failed_write(struct inode *inode)
+{
+	truncate_inode_pages(inode->i_mapping, inode->i_size);
+	ext4_truncate(inode);
+}
+
 static int ext4_write_begin(struct file *file, struct address_space *mapping,
 			    loff_t pos, unsigned len, unsigned flags,
 			    struct page **pagep, void **fsdata)
@@ -1599,7 +1606,7 @@
 
 		ext4_journal_stop(handle);
 		if (pos + len > inode->i_size) {
-			ext4_truncate(inode);
+			ext4_truncate_failed_write(inode);
 			/*
 			 * If truncate failed early the inode might
 			 * still be on the orphan list; we need to
@@ -1709,7 +1716,7 @@
 		ret = ret2;
 
 	if (pos + len > inode->i_size) {
-		ext4_truncate(inode);
+		ext4_truncate_failed_write(inode);
 		/*
 		 * If truncate failed early the inode might still be
 		 * on the orphan list; we need to make sure the inode
@@ -1751,7 +1758,7 @@
 		ret = ret2;
 
 	if (pos + len > inode->i_size) {
-		ext4_truncate(inode);
+		ext4_truncate_failed_write(inode);
 		/*
 		 * If truncate failed early the inode might still be
 		 * on the orphan list; we need to make sure the inode
@@ -1814,7 +1821,7 @@
 	if (!ret)
 		ret = ret2;
 	if (pos + len > inode->i_size) {
-		ext4_truncate(inode);
+		ext4_truncate_failed_write(inode);
 		/*
 		 * If truncate failed early the inode might still be
 		 * on the orphan list; we need to make sure the inode
@@ -1846,19 +1853,17 @@
 
 	md_needed = mdblocks - EXT4_I(inode)->i_reserved_meta_blocks;
 	total = md_needed + nrblocks;
+	spin_unlock(&EXT4_I(inode)->i_block_reservation_lock);
 
 	/*
 	 * Make quota reservation here to prevent quota overflow
 	 * later. Real quota accounting is done at pages writeout
 	 * time.
 	 */
-	if (vfs_dq_reserve_block(inode, total)) {
-		spin_unlock(&EXT4_I(inode)->i_block_reservation_lock);
+	if (vfs_dq_reserve_block(inode, total))
 		return -EDQUOT;
-	}
 
 	if (ext4_claim_free_blocks(sbi, total)) {
-		spin_unlock(&EXT4_I(inode)->i_block_reservation_lock);
 		vfs_dq_release_reservation_block(inode, total);
 		if (ext4_should_retry_alloc(inode->i_sb, &retries)) {
 			yield();
@@ -1866,10 +1871,11 @@
 		}
 		return -ENOSPC;
 	}
+	spin_lock(&EXT4_I(inode)->i_block_reservation_lock);
 	EXT4_I(inode)->i_reserved_data_blocks += nrblocks;
-	EXT4_I(inode)->i_reserved_meta_blocks = mdblocks;
-
+	EXT4_I(inode)->i_reserved_meta_blocks += md_needed;
 	spin_unlock(&EXT4_I(inode)->i_block_reservation_lock);
+
 	return 0;       /* success */
 }
 
@@ -2788,7 +2794,7 @@
 	 * number of contiguous block. So we will limit
 	 * number of contiguous block to a sane value
 	 */
-	if (!(inode->i_flags & EXT4_EXTENTS_FL) &&
+	if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL) &&
 	    (max_blocks > EXT4_MAX_TRANS_DATA))
 		max_blocks = EXT4_MAX_TRANS_DATA;
 
@@ -3091,7 +3097,7 @@
 		 * i_size_read because we hold i_mutex.
 		 */
 		if (pos + len > inode->i_size)
-			ext4_truncate(inode);
+			ext4_truncate_failed_write(inode);
 	}
 
 	if (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))
@@ -4120,6 +4126,8 @@
 			      __le32 *last)
 {
 	__le32 *p;
+	int	is_metadata = S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode);
+
 	if (try_to_extend_transaction(handle, inode)) {
 		if (bh) {
 			BUFFER_TRACE(bh, "call ext4_handle_dirty_metadata");
@@ -4150,11 +4158,11 @@
 
 			*p = 0;
 			tbh = sb_find_get_block(inode->i_sb, nr);
-			ext4_forget(handle, 0, inode, tbh, nr);
+			ext4_forget(handle, is_metadata, inode, tbh, nr);
 		}
 	}
 
-	ext4_free_blocks(handle, inode, block_to_free, count, 0);
+	ext4_free_blocks(handle, inode, block_to_free, count, is_metadata);
 }
 
 /**
@@ -4781,8 +4789,8 @@
 	struct ext4_iloc iloc;
 	struct ext4_inode *raw_inode;
 	struct ext4_inode_info *ei;
-	struct buffer_head *bh;
 	struct inode *inode;
+	journal_t *journal = EXT4_SB(sb)->s_journal;
 	long ret;
 	int block;
 
@@ -4793,11 +4801,11 @@
 		return inode;
 
 	ei = EXT4_I(inode);
+	iloc.bh = 0;
 
 	ret = __ext4_get_inode_loc(inode, &iloc, 0);
 	if (ret < 0)
 		goto bad_inode;
-	bh = iloc.bh;
 	raw_inode = ext4_raw_inode(&iloc);
 	inode->i_mode = le16_to_cpu(raw_inode->i_mode);
 	inode->i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);
@@ -4820,7 +4828,6 @@
 		if (inode->i_mode == 0 ||
 		    !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS)) {
 			/* this inode is deleted */
-			brelse(bh);
 			ret = -ESTALE;
 			goto bad_inode;
 		}
@@ -4837,6 +4844,9 @@
 			((__u64)le16_to_cpu(raw_inode->i_file_acl_high)) << 32;
 	inode->i_size = ext4_isize(raw_inode);
 	ei->i_disksize = inode->i_size;
+#ifdef CONFIG_QUOTA
+	ei->i_reserved_quota = 0;
+#endif
 	inode->i_generation = le32_to_cpu(raw_inode->i_generation);
 	ei->i_block_group = iloc.block_group;
 	ei->i_last_alloc_group = ~0;
@@ -4848,11 +4858,35 @@
 		ei->i_data[block] = raw_inode->i_block[block];
 	INIT_LIST_HEAD(&ei->i_orphan);
 
+	/*
+	 * Set transaction id's of transactions that have to be committed
+	 * to finish f[data]sync. We set them to currently running transaction
+	 * as we cannot be sure that the inode or some of its metadata isn't
+	 * part of the transaction - the inode could have been reclaimed and
+	 * now it is reread from disk.
+	 */
+	if (journal) {
+		transaction_t *transaction;
+		tid_t tid;
+
+		spin_lock(&journal->j_state_lock);
+		if (journal->j_running_transaction)
+			transaction = journal->j_running_transaction;
+		else
+			transaction = journal->j_committing_transaction;
+		if (transaction)
+			tid = transaction->t_tid;
+		else
+			tid = journal->j_commit_sequence;
+		spin_unlock(&journal->j_state_lock);
+		ei->i_sync_tid = tid;
+		ei->i_datasync_tid = tid;
+	}
+
 	if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {
 		ei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);
 		if (EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >
 		    EXT4_INODE_SIZE(inode->i_sb)) {
-			brelse(bh);
 			ret = -EIO;
 			goto bad_inode;
 		}
@@ -4884,10 +4918,7 @@
 
 	ret = 0;
 	if (ei->i_file_acl &&
-	    ((ei->i_file_acl <
-	      (le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block) +
-	       EXT4_SB(sb)->s_gdb_count)) ||
-	     (ei->i_file_acl >= ext4_blocks_count(EXT4_SB(sb)->s_es)))) {
+	    !ext4_data_block_valid(EXT4_SB(sb), ei->i_file_acl, 1)) {
 		ext4_error(sb, __func__,
 			   "bad extended attribute block %llu in inode #%lu",
 			   ei->i_file_acl, inode->i_ino);
@@ -4905,10 +4936,8 @@
 		/* Validate block references which are part of inode */
 		ret = ext4_check_inode_blockref(inode);
 	}
-	if (ret) {
-		brelse(bh);
+	if (ret)
 		goto bad_inode;
-	}
 
 	if (S_ISREG(inode->i_mode)) {
 		inode->i_op = &ext4_file_inode_operations;
@@ -4936,7 +4965,6 @@
 			init_special_inode(inode, inode->i_mode,
 			   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));
 	} else {
-		brelse(bh);
 		ret = -EIO;
 		ext4_error(inode->i_sb, __func__,
 			   "bogus i_mode (%o) for inode=%lu",
@@ -4949,6 +4977,7 @@
 	return inode;
 
 bad_inode:
+	brelse(iloc.bh);
 	iget_failed(inode);
 	return ERR_PTR(ret);
 }
@@ -5108,6 +5137,7 @@
 		err = rc;
 	ei->i_state &= ~EXT4_STATE_NEW;
 
+	ext4_update_inode_fsync_trans(handle, inode, 0);
 out_brelse:
 	brelse(bh);
 	ext4_std_error(inode->i_sb, err);
@@ -5227,8 +5257,8 @@
 
 		/* (user+group)*(old+new) structure, inode write (sb,
 		 * inode block, ? - but truncate inode update has it) */
-		handle = ext4_journal_start(inode, 2*(EXT4_QUOTA_INIT_BLOCKS(inode->i_sb)+
-					EXT4_QUOTA_DEL_BLOCKS(inode->i_sb))+3);
+		handle = ext4_journal_start(inode, (EXT4_MAXQUOTAS_INIT_BLOCKS(inode->i_sb)+
+					EXT4_MAXQUOTAS_DEL_BLOCKS(inode->i_sb))+3);
 		if (IS_ERR(handle)) {
 			error = PTR_ERR(handle);
 			goto err_out;
diff -Nur linux-2.6.32-orig/fs/ext4/ioctl.c iDroid-Project-kernel_common-9e90fd2/fs/ext4/ioctl.c
--- linux-2.6.32-orig/fs/ext4/ioctl.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/ioctl.c	2010-11-18 21:05:30.000000000 +0600
@@ -221,31 +221,38 @@
 		struct file *donor_filp;
 		int err;
 
+		if (!(filp->f_mode & FMODE_READ) ||
+		    !(filp->f_mode & FMODE_WRITE))
+			return -EBADF;
+
 		if (copy_from_user(&me,
 			(struct move_extent __user *)arg, sizeof(me)))
 			return -EFAULT;
+		me.moved_len = 0;
 
 		donor_filp = fget(me.donor_fd);
 		if (!donor_filp)
 			return -EBADF;
 
-		if (!capable(CAP_DAC_OVERRIDE)) {
-			if ((current->real_cred->fsuid != inode->i_uid) ||
-				!(inode->i_mode & S_IRUSR) ||
-				!(donor_filp->f_dentry->d_inode->i_mode &
-				S_IRUSR)) {
-				fput(donor_filp);
-				return -EACCES;
-			}
+		if (!(donor_filp->f_mode & FMODE_WRITE)) {
+			err = -EBADF;
+			goto mext_out;
 		}
 
+		err = mnt_want_write(filp->f_path.mnt);
+		if (err)
+			goto mext_out;
+
 		err = ext4_move_extents(filp, donor_filp, me.orig_start,
 					me.donor_start, me.len, &me.moved_len);
-		fput(donor_filp);
+		mnt_drop_write(filp->f_path.mnt);
+		if (me.moved_len > 0)
+			file_remove_suid(donor_filp);
 
 		if (copy_to_user((struct move_extent *)arg, &me, sizeof(me)))
-			return -EFAULT;
-
+			err = -EFAULT;
+mext_out:
+		fput(donor_filp);
 		return err;
 	}
 
diff -Nur linux-2.6.32-orig/fs/ext4/mballoc.c iDroid-Project-kernel_common-9e90fd2/fs/ext4/mballoc.c
--- linux-2.6.32-orig/fs/ext4/mballoc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/mballoc.c	2010-11-18 21:05:30.000000000 +0600
@@ -2529,7 +2529,6 @@
 	struct ext4_group_info *db;
 	int err, count = 0, count2 = 0;
 	struct ext4_free_data *entry;
-	ext4_fsblk_t discard_block;
 	struct list_head *l, *ltmp;
 
 	list_for_each_safe(l, ltmp, &txn->t_private_list) {
@@ -2559,13 +2558,19 @@
 			page_cache_release(e4b.bd_bitmap_page);
 		}
 		ext4_unlock_group(sb, entry->group);
-		discard_block = (ext4_fsblk_t) entry->group * EXT4_BLOCKS_PER_GROUP(sb)
-			+ entry->start_blk
-			+ le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);
-		trace_ext4_discard_blocks(sb, (unsigned long long)discard_block,
-					  entry->count);
-		sb_issue_discard(sb, discard_block, entry->count);
-
+		if (test_opt(sb, DISCARD)) {
+			ext4_fsblk_t discard_block;
+			struct ext4_super_block *es = EXT4_SB(sb)->s_es;
+
+			discard_block = (ext4_fsblk_t)entry->group *
+						EXT4_BLOCKS_PER_GROUP(sb)
+					+ entry->start_blk
+					+ le32_to_cpu(es->s_first_data_block);
+			trace_ext4_discard_blocks(sb,
+					(unsigned long long)discard_block,
+					entry->count);
+			sb_issue_discard(sb, discard_block, entry->count);
+		}
 		kmem_cache_free(ext4_free_ext_cachep, entry);
 		ext4_mb_release_desc(&e4b);
 	}
@@ -3006,6 +3011,24 @@
 }
 
 /*
+ * Called on failure; free up any blocks from the inode PA for this
+ * context.  We don't need this for MB_GROUP_PA because we only change
+ * pa_free in ext4_mb_release_context(), but on failure, we've already
+ * zeroed out ac->ac_b_ex.fe_len, so group_pa->pa_free is not changed.
+ */
+static void ext4_discard_allocated_blocks(struct ext4_allocation_context *ac)
+{
+	struct ext4_prealloc_space *pa = ac->ac_pa;
+	int len;
+
+	if (pa && pa->pa_type == MB_INODE_PA) {
+		len = ac->ac_b_ex.fe_len;
+		pa->pa_free += len;
+	}
+
+}
+
+/*
  * use blocks preallocated to inode
  */
 static void ext4_mb_use_inode_pa(struct ext4_allocation_context *ac,
@@ -4290,6 +4313,7 @@
 			ac->ac_status = AC_STATUS_CONTINUE;
 			goto repeat;
 		} else if (*errp) {
+			ext4_discard_allocated_blocks(ac);
 			ac->ac_b_ex.fe_len = 0;
 			ar->len = 0;
 			ext4_mb_show_ac(ac);
diff -Nur linux-2.6.32-orig/fs/ext4/migrate.c iDroid-Project-kernel_common-9e90fd2/fs/ext4/migrate.c
--- linux-2.6.32-orig/fs/ext4/migrate.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/migrate.c	2010-11-18 21:05:30.000000000 +0600
@@ -238,7 +238,7 @@
 	 * So allocate a credit of 3. We may update
 	 * quota (user and group).
 	 */
-	needed = 3 + 2*EXT4_QUOTA_TRANS_BLOCKS(inode->i_sb);
+	needed = 3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);
 
 	if (ext4_journal_extend(handle, needed) != 0)
 		retval = ext4_journal_restart(handle, needed);
@@ -477,7 +477,7 @@
 	handle = ext4_journal_start(inode,
 					EXT4_DATA_TRANS_BLOCKS(inode->i_sb) +
 					EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3 +
-					2 * EXT4_QUOTA_INIT_BLOCKS(inode->i_sb)
+					EXT4_MAXQUOTAS_INIT_BLOCKS(inode->i_sb)
 					+ 1);
 	if (IS_ERR(handle)) {
 		retval = PTR_ERR(handle);
diff -Nur linux-2.6.32-orig/fs/ext4/move_extent.c iDroid-Project-kernel_common-9e90fd2/fs/ext4/move_extent.c
--- linux-2.6.32-orig/fs/ext4/move_extent.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/move_extent.c	2010-11-18 21:05:30.000000000 +0600
@@ -77,12 +77,14 @@
 mext_next_extent(struct inode *inode, struct ext4_ext_path *path,
 		      struct ext4_extent **extent)
 {
+	struct ext4_extent_header *eh;
 	int ppos, leaf_ppos = path->p_depth;
 
 	ppos = leaf_ppos;
 	if (EXT_LAST_EXTENT(path[ppos].p_hdr) > path[ppos].p_ext) {
 		/* leaf block */
 		*extent = ++path[ppos].p_ext;
+		path[ppos].p_block = ext_pblock(path[ppos].p_ext);
 		return 0;
 	}
 
@@ -119,9 +121,18 @@
 					ext_block_hdr(path[cur_ppos+1].p_bh);
 			}
 
+			path[leaf_ppos].p_ext = *extent = NULL;
+
+			eh = path[leaf_ppos].p_hdr;
+			if (le16_to_cpu(eh->eh_entries) == 0)
+				/* empty leaf is found */
+				return -ENODATA;
+
 			/* leaf block */
 			path[leaf_ppos].p_ext = *extent =
 				EXT_FIRST_EXTENT(path[leaf_ppos].p_hdr);
+			path[leaf_ppos].p_block =
+					ext_pblock(path[leaf_ppos].p_ext);
 			return 0;
 		}
 	}
@@ -155,40 +166,15 @@
 }
 
 /**
- * mext_double_down_read - Acquire two inodes' read semaphore
- *
- * @orig_inode:		original inode structure
- * @donor_inode:	donor inode structure
- * Acquire read semaphore of the two inodes (orig and donor) by i_ino order.
- */
-static void
-mext_double_down_read(struct inode *orig_inode, struct inode *donor_inode)
-{
-	struct inode *first = orig_inode, *second = donor_inode;
-
-	/*
-	 * Use the inode number to provide the stable locking order instead
-	 * of its address, because the C language doesn't guarantee you can
-	 * compare pointers that don't come from the same array.
-	 */
-	if (donor_inode->i_ino < orig_inode->i_ino) {
-		first = donor_inode;
-		second = orig_inode;
-	}
-
-	down_read(&EXT4_I(first)->i_data_sem);
-	down_read(&EXT4_I(second)->i_data_sem);
-}
-
-/**
- * mext_double_down_write - Acquire two inodes' write semaphore
+ * double_down_write_data_sem - Acquire two inodes' write lock of i_data_sem
  *
  * @orig_inode:		original inode structure
  * @donor_inode:	donor inode structure
- * Acquire write semaphore of the two inodes (orig and donor) by i_ino order.
+ * Acquire write lock of i_data_sem of the two inodes (orig and donor) by
+ * i_ino order.
  */
 static void
-mext_double_down_write(struct inode *orig_inode, struct inode *donor_inode)
+double_down_write_data_sem(struct inode *orig_inode, struct inode *donor_inode)
 {
 	struct inode *first = orig_inode, *second = donor_inode;
 
@@ -203,32 +189,18 @@
 	}
 
 	down_write(&EXT4_I(first)->i_data_sem);
-	down_write(&EXT4_I(second)->i_data_sem);
+	down_write_nested(&EXT4_I(second)->i_data_sem, SINGLE_DEPTH_NESTING);
 }
 
 /**
- * mext_double_up_read - Release two inodes' read semaphore
+ * double_up_write_data_sem - Release two inodes' write lock of i_data_sem
  *
  * @orig_inode:		original inode structure to be released its lock first
  * @donor_inode:	donor inode structure to be released its lock second
- * Release read semaphore of two inodes (orig and donor).
+ * Release write lock of i_data_sem of two inodes (orig and donor).
  */
 static void
-mext_double_up_read(struct inode *orig_inode, struct inode *donor_inode)
-{
-	up_read(&EXT4_I(orig_inode)->i_data_sem);
-	up_read(&EXT4_I(donor_inode)->i_data_sem);
-}
-
-/**
- * mext_double_up_write - Release two inodes' write semaphore
- *
- * @orig_inode:		original inode structure to be released its lock first
- * @donor_inode:	donor inode structure to be released its lock second
- * Release write semaphore of two inodes (orig and donor).
- */
-static void
-mext_double_up_write(struct inode *orig_inode, struct inode *donor_inode)
+double_up_write_data_sem(struct inode *orig_inode, struct inode *donor_inode)
 {
 	up_write(&EXT4_I(orig_inode)->i_data_sem);
 	up_write(&EXT4_I(donor_inode)->i_data_sem);
@@ -661,6 +633,7 @@
  * @donor_inode:	donor inode
  * @from:		block offset of orig_inode
  * @count:		block count to be replaced
+ * @err:		pointer to save return value
  *
  * Replace original inode extents and donor inode extents page by page.
  * We implement this replacement in the following three steps:
@@ -671,33 +644,33 @@
  * 3. Change the block information of donor inode to point at the saved
  *    original inode blocks in the dummy extents.
  *
- * Return 0 on success, or a negative error value on failure.
+ * Return replaced block count.
  */
 static int
 mext_replace_branches(handle_t *handle, struct inode *orig_inode,
 			   struct inode *donor_inode, ext4_lblk_t from,
-			   ext4_lblk_t count)
+			   ext4_lblk_t count, int *err)
 {
 	struct ext4_ext_path *orig_path = NULL;
 	struct ext4_ext_path *donor_path = NULL;
 	struct ext4_extent *oext, *dext;
 	struct ext4_extent tmp_dext, tmp_oext;
 	ext4_lblk_t orig_off = from, donor_off = from;
-	int err = 0;
 	int depth;
 	int replaced_count = 0;
 	int dext_alen;
 
-	mext_double_down_write(orig_inode, donor_inode);
+	/* Protect extent trees against block allocations via delalloc */
+	double_down_write_data_sem(orig_inode, donor_inode);
 
 	/* Get the original extent for the block "orig_off" */
-	err = get_ext_path(orig_inode, orig_off, &orig_path);
-	if (err)
+	*err = get_ext_path(orig_inode, orig_off, &orig_path);
+	if (*err)
 		goto out;
 
 	/* Get the donor extent for the head */
-	err = get_ext_path(donor_inode, donor_off, &donor_path);
-	if (err)
+	*err = get_ext_path(donor_inode, donor_off, &donor_path);
+	if (*err)
 		goto out;
 	depth = ext_depth(orig_inode);
 	oext = orig_path[depth].p_ext;
@@ -707,9 +680,9 @@
 	dext = donor_path[depth].p_ext;
 	tmp_dext = *dext;
 
-	err = mext_calc_swap_extents(&tmp_dext, &tmp_oext, orig_off,
+	*err = mext_calc_swap_extents(&tmp_dext, &tmp_oext, orig_off,
 				      donor_off, count);
-	if (err)
+	if (*err)
 		goto out;
 
 	/* Loop for the donor extents */
@@ -718,7 +691,7 @@
 		if (!dext) {
 			ext4_error(donor_inode->i_sb, __func__,
 				   "The extent for donor must be found");
-			err = -EIO;
+			*err = -EIO;
 			goto out;
 		} else if (donor_off != le32_to_cpu(tmp_dext.ee_block)) {
 			ext4_error(donor_inode->i_sb, __func__,
@@ -726,20 +699,20 @@
 				"extent(%u) should be equal",
 				donor_off,
 				le32_to_cpu(tmp_dext.ee_block));
-			err = -EIO;
+			*err = -EIO;
 			goto out;
 		}
 
 		/* Set donor extent to orig extent */
-		err = mext_leaf_block(handle, orig_inode,
+		*err = mext_leaf_block(handle, orig_inode,
 					   orig_path, &tmp_dext, &orig_off);
-		if (err < 0)
+		if (*err)
 			goto out;
 
 		/* Set orig extent to donor extent */
-		err = mext_leaf_block(handle, donor_inode,
+		*err = mext_leaf_block(handle, donor_inode,
 					   donor_path, &tmp_oext, &donor_off);
-		if (err < 0)
+		if (*err)
 			goto out;
 
 		dext_alen = ext4_ext_get_actual_len(&tmp_dext);
@@ -753,35 +726,25 @@
 
 		if (orig_path)
 			ext4_ext_drop_refs(orig_path);
-		err = get_ext_path(orig_inode, orig_off, &orig_path);
-		if (err)
+		*err = get_ext_path(orig_inode, orig_off, &orig_path);
+		if (*err)
 			goto out;
 		depth = ext_depth(orig_inode);
 		oext = orig_path[depth].p_ext;
-		if (le32_to_cpu(oext->ee_block) +
-				ext4_ext_get_actual_len(oext) <= orig_off) {
-			err = 0;
-			goto out;
-		}
 		tmp_oext = *oext;
 
 		if (donor_path)
 			ext4_ext_drop_refs(donor_path);
-		err = get_ext_path(donor_inode, donor_off, &donor_path);
-		if (err)
+		*err = get_ext_path(donor_inode, donor_off, &donor_path);
+		if (*err)
 			goto out;
 		depth = ext_depth(donor_inode);
 		dext = donor_path[depth].p_ext;
-		if (le32_to_cpu(dext->ee_block) +
-				ext4_ext_get_actual_len(dext) <= donor_off) {
-			err = 0;
-			goto out;
-		}
 		tmp_dext = *dext;
 
-		err = mext_calc_swap_extents(&tmp_dext, &tmp_oext, orig_off,
+		*err = mext_calc_swap_extents(&tmp_dext, &tmp_oext, orig_off,
 					   donor_off, count - replaced_count);
-		if (err)
+		if (*err)
 			goto out;
 	}
 
@@ -795,8 +758,12 @@
 		kfree(donor_path);
 	}
 
-	mext_double_up_write(orig_inode, donor_inode);
-	return err;
+	ext4_ext_invalidate_cache(orig_inode);
+	ext4_ext_invalidate_cache(donor_inode);
+
+	double_up_write_data_sem(orig_inode, donor_inode);
+
+	return replaced_count;
 }
 
 /**
@@ -808,16 +775,17 @@
  * @data_offset_in_page:	block index where data swapping starts
  * @block_len_in_page:		the number of blocks to be swapped
  * @uninit:			orig extent is uninitialized or not
+ * @err:			pointer to save return value
  *
  * Save the data in original inode blocks and replace original inode extents
  * with donor inode extents by calling mext_replace_branches().
- * Finally, write out the saved data in new original inode blocks. Return 0
- * on success, or a negative error value on failure.
+ * Finally, write out the saved data in new original inode blocks. Return
+ * replaced block count.
  */
 static int
 move_extent_per_page(struct file *o_filp, struct inode *donor_inode,
 		  pgoff_t orig_page_offset, int data_offset_in_page,
-		  int block_len_in_page, int uninit)
+		  int block_len_in_page, int uninit, int *err)
 {
 	struct inode *orig_inode = o_filp->f_dentry->d_inode;
 	struct address_space *mapping = orig_inode->i_mapping;
@@ -829,9 +797,11 @@
 	long long offs = orig_page_offset << PAGE_CACHE_SHIFT;
 	unsigned long blocksize = orig_inode->i_sb->s_blocksize;
 	unsigned int w_flags = 0;
-	unsigned int tmp_data_len, data_len;
+	unsigned int tmp_data_size, data_size, replaced_size;
 	void *fsdata;
-	int ret, i, jblocks;
+	int i, jblocks;
+	int err2 = 0;
+	int replaced_count = 0;
 	int blocks_per_page = PAGE_CACHE_SIZE >> orig_inode->i_blkbits;
 
 	/*
@@ -841,8 +811,8 @@
 	jblocks = ext4_writepage_trans_blocks(orig_inode) * 2;
 	handle = ext4_journal_start(orig_inode, jblocks);
 	if (IS_ERR(handle)) {
-		ret = PTR_ERR(handle);
-		return ret;
+		*err = PTR_ERR(handle);
+		return 0;
 	}
 
 	if (segment_eq(get_fs(), KERNEL_DS))
@@ -858,39 +828,36 @@
 	 * Just swap data blocks between orig and donor.
 	 */
 	if (uninit) {
-		ret = mext_replace_branches(handle, orig_inode,
-						 donor_inode, orig_blk_offset,
-						 block_len_in_page);
-
-		/* Clear the inode cache not to refer to the old data */
-		ext4_ext_invalidate_cache(orig_inode);
-		ext4_ext_invalidate_cache(donor_inode);
+		replaced_count = mext_replace_branches(handle, orig_inode,
+						donor_inode, orig_blk_offset,
+						block_len_in_page, err);
 		goto out2;
 	}
 
 	offs = (long long)orig_blk_offset << orig_inode->i_blkbits;
 
-	/* Calculate data_len */
+	/* Calculate data_size */
 	if ((orig_blk_offset + block_len_in_page - 1) ==
 	    ((orig_inode->i_size - 1) >> orig_inode->i_blkbits)) {
 		/* Replace the last block */
-		tmp_data_len = orig_inode->i_size & (blocksize - 1);
+		tmp_data_size = orig_inode->i_size & (blocksize - 1);
 		/*
-		 * If data_len equal zero, it shows data_len is multiples of
+		 * If data_size equal zero, it shows data_size is multiples of
 		 * blocksize. So we set appropriate value.
 		 */
-		if (tmp_data_len == 0)
-			tmp_data_len = blocksize;
+		if (tmp_data_size == 0)
+			tmp_data_size = blocksize;
 
-		data_len = tmp_data_len +
+		data_size = tmp_data_size +
 			((block_len_in_page - 1) << orig_inode->i_blkbits);
-	} else {
-		data_len = block_len_in_page << orig_inode->i_blkbits;
-	}
+	} else
+		data_size = block_len_in_page << orig_inode->i_blkbits;
+
+	replaced_size = data_size;
 
-	ret = a_ops->write_begin(o_filp, mapping, offs, data_len, w_flags,
+	*err = a_ops->write_begin(o_filp, mapping, offs, data_size, w_flags,
 				 &page, &fsdata);
-	if (unlikely(ret < 0))
+	if (unlikely(*err < 0))
 		goto out;
 
 	if (!PageUptodate(page)) {
@@ -911,14 +878,17 @@
 	/* Release old bh and drop refs */
 	try_to_release_page(page, 0);
 
-	ret = mext_replace_branches(handle, orig_inode, donor_inode,
-					 orig_blk_offset, block_len_in_page);
-	if (ret < 0)
-		goto out;
-
-	/* Clear the inode cache not to refer to the old data */
-	ext4_ext_invalidate_cache(orig_inode);
-	ext4_ext_invalidate_cache(donor_inode);
+	replaced_count = mext_replace_branches(handle, orig_inode, donor_inode,
+					orig_blk_offset, block_len_in_page,
+					&err2);
+	if (err2) {
+		if (replaced_count) {
+			block_len_in_page = replaced_count;
+			replaced_size =
+				block_len_in_page << orig_inode->i_blkbits;
+		} else
+			goto out;
+	}
 
 	if (!page_has_buffers(page))
 		create_empty_buffers(page, 1 << orig_inode->i_blkbits, 0);
@@ -928,16 +898,16 @@
 		bh = bh->b_this_page;
 
 	for (i = 0; i < block_len_in_page; i++) {
-		ret = ext4_get_block(orig_inode,
+		*err = ext4_get_block(orig_inode,
 				(sector_t)(orig_blk_offset + i), bh, 0);
-		if (ret < 0)
+		if (*err < 0)
 			goto out;
 
 		if (bh->b_this_page != NULL)
 			bh = bh->b_this_page;
 	}
 
-	ret = a_ops->write_end(o_filp, mapping, offs, data_len, data_len,
+	*err = a_ops->write_end(o_filp, mapping, offs, data_size, replaced_size,
 			       page, fsdata);
 	page = NULL;
 
@@ -951,7 +921,10 @@
 out2:
 	ext4_journal_stop(handle);
 
-	return ret < 0 ? ret : 0;
+	if (err2)
+		*err = err2;
+
+	return replaced_count;
 }
 
 /**
@@ -962,7 +935,6 @@
  * @orig_start:		logical start offset in block for orig
  * @donor_start:	logical start offset in block for donor
  * @len:		the number of blocks to be moved
- * @moved_len:		moved block length
  *
  * Check the arguments of ext4_move_extents() whether the files can be
  * exchanged with each other.
@@ -970,8 +942,8 @@
  */
 static int
 mext_check_arguments(struct inode *orig_inode,
-			  struct inode *donor_inode, __u64 orig_start,
-			  __u64 donor_start, __u64 *len, __u64 moved_len)
+		     struct inode *donor_inode, __u64 orig_start,
+		     __u64 donor_start, __u64 *len)
 {
 	ext4_lblk_t orig_blocks, donor_blocks;
 	unsigned int blkbits = orig_inode->i_blkbits;
@@ -985,6 +957,13 @@
 		return -EINVAL;
 	}
 
+	if (donor_inode->i_mode & (S_ISUID|S_ISGID)) {
+		ext4_debug("ext4 move extent: suid or sgid is set"
+			   " to donor file [ino:orig %lu, donor %lu]\n",
+			   orig_inode->i_ino, donor_inode->i_ino);
+		return -EINVAL;
+	}
+
 	/* Ext4 move extent does not support swapfile */
 	if (IS_SWAPFILE(orig_inode) || IS_SWAPFILE(donor_inode)) {
 		ext4_debug("ext4 move extent: The argument files should "
@@ -1025,13 +1004,6 @@
 		return -EINVAL;
 	}
 
-	if (moved_len) {
-		ext4_debug("ext4 move extent: moved_len should be 0 "
-			"[ino:orig %lu, donor %lu]\n", orig_inode->i_ino,
-			donor_inode->i_ino);
-		return -EINVAL;
-	}
-
 	if ((orig_start > EXT_MAX_BLOCK) ||
 	    (donor_start > EXT_MAX_BLOCK) ||
 	    (*len > EXT_MAX_BLOCK) ||
@@ -1232,16 +1204,16 @@
 		return -EINVAL;
 	}
 
-	/* protect orig and donor against a truncate */
+	/* Protect orig and donor inodes against a truncate */
 	ret1 = mext_inode_double_lock(orig_inode, donor_inode);
 	if (ret1 < 0)
 		return ret1;
 
-	mext_double_down_read(orig_inode, donor_inode);
+	/* Protect extent tree against block allocations via delalloc */
+	double_down_write_data_sem(orig_inode, donor_inode);
 	/* Check the filesystem environment whether move_extent can be done */
 	ret1 = mext_check_arguments(orig_inode, donor_inode, orig_start,
-					donor_start, &len, *moved_len);
-	mext_double_up_read(orig_inode, donor_inode);
+				    donor_start, &len);
 	if (ret1)
 		goto out;
 
@@ -1355,36 +1327,39 @@
 		seq_start = le32_to_cpu(ext_cur->ee_block);
 		rest_blocks = seq_blocks;
 
-		/* Discard preallocations of two inodes */
-		down_write(&EXT4_I(orig_inode)->i_data_sem);
-		ext4_discard_preallocations(orig_inode);
-		up_write(&EXT4_I(orig_inode)->i_data_sem);
-
-		down_write(&EXT4_I(donor_inode)->i_data_sem);
-		ext4_discard_preallocations(donor_inode);
-		up_write(&EXT4_I(donor_inode)->i_data_sem);
+		/*
+		 * Up semaphore to avoid following problems:
+		 * a. transaction deadlock among ext4_journal_start,
+		 *    ->write_begin via pagefault, and jbd2_journal_commit
+		 * b. racing with ->readpage, ->write_begin, and ext4_get_block
+		 *    in move_extent_per_page
+		 */
+		double_up_write_data_sem(orig_inode, donor_inode);
 
 		while (orig_page_offset <= seq_end_page) {
 
 			/* Swap original branches with new branches */
-			ret1 = move_extent_per_page(o_filp, donor_inode,
+			block_len_in_page = move_extent_per_page(
+						o_filp, donor_inode,
 						orig_page_offset,
 						data_offset_in_page,
-						block_len_in_page, uninit);
-			if (ret1 < 0)
-				goto out;
-			orig_page_offset++;
+						block_len_in_page, uninit,
+						&ret1);
+
 			/* Count how many blocks we have exchanged */
 			*moved_len += block_len_in_page;
+			if (ret1 < 0)
+				break;
 			if (*moved_len > len) {
 				ext4_error(orig_inode->i_sb, __func__,
 					"We replaced blocks too much! "
 					"sum of replaced: %llu requested: %llu",
 					*moved_len, len);
 				ret1 = -EIO;
-				goto out;
+				break;
 			}
 
+			orig_page_offset++;
 			data_offset_in_page = 0;
 			rest_blocks -= block_len_in_page;
 			if (rest_blocks > blocks_per_page)
@@ -1393,6 +1368,10 @@
 				block_len_in_page = rest_blocks;
 		}
 
+		double_down_write_data_sem(orig_inode, donor_inode);
+		if (ret1 < 0)
+			break;
+
 		/* Decrease buffer counter */
 		if (holecheck_path)
 			ext4_ext_drop_refs(holecheck_path);
@@ -1414,6 +1393,11 @@
 
 	}
 out:
+	if (*moved_len) {
+		ext4_discard_preallocations(orig_inode);
+		ext4_discard_preallocations(donor_inode);
+	}
+
 	if (orig_path) {
 		ext4_ext_drop_refs(orig_path);
 		kfree(orig_path);
@@ -1422,7 +1406,7 @@
 		ext4_ext_drop_refs(holecheck_path);
 		kfree(holecheck_path);
 	}
-
+	double_up_write_data_sem(orig_inode, donor_inode);
 	ret2 = mext_inode_double_unlock(orig_inode, donor_inode);
 
 	if (ret1)
diff -Nur linux-2.6.32-orig/fs/ext4/namei.c iDroid-Project-kernel_common-9e90fd2/fs/ext4/namei.c
--- linux-2.6.32-orig/fs/ext4/namei.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/namei.c	2010-11-18 21:05:30.000000000 +0600
@@ -1292,9 +1292,6 @@
  * add_dirent_to_buf will attempt search the directory block for
  * space.  It will return -ENOSPC if no space is available, and -EIO
  * and -EEXIST if directory entry already exists.
- *
- * NOTE!  bh is NOT released in the case where ENOSPC is returned.  In
- * all other cases bh is released.
  */
 static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,
 			     struct inode *inode, struct ext4_dir_entry_2 *de,
@@ -1315,14 +1312,10 @@
 		top = bh->b_data + blocksize - reclen;
 		while ((char *) de <= top) {
 			if (!ext4_check_dir_entry("ext4_add_entry", dir, de,
-						  bh, offset)) {
-				brelse(bh);
+						  bh, offset))
 				return -EIO;
-			}
-			if (ext4_match(namelen, name, de)) {
-				brelse(bh);
+			if (ext4_match(namelen, name, de))
 				return -EEXIST;
-			}
 			nlen = EXT4_DIR_REC_LEN(de->name_len);
 			rlen = ext4_rec_len_from_disk(de->rec_len, blocksize);
 			if ((de->inode? rlen - nlen: rlen) >= reclen)
@@ -1337,7 +1330,6 @@
 	err = ext4_journal_get_write_access(handle, bh);
 	if (err) {
 		ext4_std_error(dir->i_sb, err);
-		brelse(bh);
 		return err;
 	}
 
@@ -1377,7 +1369,6 @@
 	err = ext4_handle_dirty_metadata(handle, dir, bh);
 	if (err)
 		ext4_std_error(dir->i_sb, err);
-	brelse(bh);
 	return 0;
 }
 
@@ -1471,7 +1462,9 @@
 	if (!(de))
 		return retval;
 
-	return add_dirent_to_buf(handle, dentry, inode, de, bh);
+	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
+	brelse(bh);
+	return retval;
 }
 
 /*
@@ -1514,8 +1507,10 @@
 		if(!bh)
 			return retval;
 		retval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
-		if (retval != -ENOSPC)
+		if (retval != -ENOSPC) {
+			brelse(bh);
 			return retval;
+		}
 
 		if (blocks == 1 && !dx_fallback &&
 		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))
@@ -1528,7 +1523,9 @@
 	de = (struct ext4_dir_entry_2 *) bh->b_data;
 	de->inode = 0;
 	de->rec_len = ext4_rec_len_to_disk(blocksize, blocksize);
-	return add_dirent_to_buf(handle, dentry, inode, de, bh);
+	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
+	brelse(bh);
+	return retval;
 }
 
 /*
@@ -1561,10 +1558,8 @@
 		goto journal_error;
 
 	err = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
-	if (err != -ENOSPC) {
-		bh = NULL;
+	if (err != -ENOSPC)
 		goto cleanup;
-	}
 
 	/* Block full, should compress but for now just split */
 	dxtrace(printk(KERN_DEBUG "using %u of %u node entries\n",
@@ -1657,7 +1652,6 @@
 	if (!de)
 		goto cleanup;
 	err = add_dirent_to_buf(handle, dentry, inode, de, bh);
-	bh = NULL;
 	goto cleanup;
 
 journal_error:
@@ -1775,7 +1769,7 @@
 retry:
 	handle = ext4_journal_start(dir, EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +
 					EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3 +
-					2*EXT4_QUOTA_INIT_BLOCKS(dir->i_sb));
+					EXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb));
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 
@@ -1809,7 +1803,7 @@
 retry:
 	handle = ext4_journal_start(dir, EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +
 					EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3 +
-					2*EXT4_QUOTA_INIT_BLOCKS(dir->i_sb));
+					EXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb));
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 
@@ -1846,7 +1840,7 @@
 retry:
 	handle = ext4_journal_start(dir, EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +
 					EXT4_INDEX_EXTRA_TRANS_BLOCKS + 3 +
-					2*EXT4_QUOTA_INIT_BLOCKS(dir->i_sb));
+					EXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb));
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 
@@ -2259,7 +2253,7 @@
 retry:
 	handle = ext4_journal_start(dir, EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +
 					EXT4_INDEX_EXTRA_TRANS_BLOCKS + 5 +
-					2*EXT4_QUOTA_INIT_BLOCKS(dir->i_sb));
+					EXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb));
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 
diff -Nur linux-2.6.32-orig/fs/ext4/resize.c iDroid-Project-kernel_common-9e90fd2/fs/ext4/resize.c
--- linux-2.6.32-orig/fs/ext4/resize.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/resize.c	2010-11-18 21:05:30.000000000 +0600
@@ -247,7 +247,7 @@
 			goto exit_bh;
 
 		if (IS_ERR(gdb = bclean(handle, sb, block))) {
-			err = PTR_ERR(bh);
+			err = PTR_ERR(gdb);
 			goto exit_bh;
 		}
 		ext4_handle_dirty_metadata(handle, NULL, gdb);
diff -Nur linux-2.6.32-orig/fs/ext4/super.c iDroid-Project-kernel_common-9e90fd2/fs/ext4/super.c
--- linux-2.6.32-orig/fs/ext4/super.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/super.c	2010-11-18 21:05:30.000000000 +0600
@@ -603,10 +603,6 @@
 	if (sb->s_dirt)
 		ext4_commit_super(sb, 1);
 
-	ext4_release_system_zone(sb);
-	ext4_mb_release(sb);
-	ext4_ext_release(sb);
-	ext4_xattr_put_super(sb);
 	if (sbi->s_journal) {
 		err = jbd2_journal_destroy(sbi->s_journal);
 		sbi->s_journal = NULL;
@@ -614,6 +610,12 @@
 			ext4_abort(sb, __func__,
 				   "Couldn't clean up the journal");
 	}
+
+	ext4_release_system_zone(sb);
+	ext4_mb_release(sb);
+	ext4_ext_release(sb);
+	ext4_xattr_put_super(sb);
+
 	if (!(sb->s_flags & MS_RDONLY)) {
 		EXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);
 		es->s_state = cpu_to_le16(sbi->s_mount_state);
@@ -702,8 +704,13 @@
 	ei->i_allocated_meta_blocks = 0;
 	ei->i_delalloc_reserved_flag = 0;
 	spin_lock_init(&(ei->i_block_reservation_lock));
+#ifdef CONFIG_QUOTA
+	ei->i_reserved_quota = 0;
+#endif
 	INIT_LIST_HEAD(&ei->i_aio_dio_complete_list);
 	ei->cur_aio_dio = NULL;
+	ei->i_sync_tid = 0;
+	ei->i_datasync_tid = 0;
 
 	return &ei->vfs_inode;
 }
@@ -899,6 +906,12 @@
 	if (test_opt(sb, NO_AUTO_DA_ALLOC))
 		seq_puts(seq, ",noauto_da_alloc");
 
+	if (test_opt(sb, DISCARD))
+		seq_puts(seq, ",discard");
+
+	if (test_opt(sb, NOLOAD))
+		seq_puts(seq, ",norecovery");
+
 	ext4_show_quota_options(seq, sb);
 
 	return 0;
@@ -991,7 +1004,9 @@
 	.reserve_space	= dquot_reserve_space,
 	.claim_space	= dquot_claim_space,
 	.release_rsv	= dquot_release_reserved_space,
+#ifdef CONFIG_QUOTA
 	.get_reserved_space = ext4_get_reserved_space,
+#endif
 	.alloc_inode	= dquot_alloc_inode,
 	.free_space	= dquot_free_space,
 	.free_inode	= dquot_free_inode,
@@ -1079,7 +1094,8 @@
 	Opt_usrquota, Opt_grpquota, Opt_i_version,
 	Opt_stripe, Opt_delalloc, Opt_nodelalloc,
 	Opt_block_validity, Opt_noblock_validity,
-	Opt_inode_readahead_blks, Opt_journal_ioprio
+	Opt_inode_readahead_blks, Opt_journal_ioprio,
+	Opt_discard, Opt_nodiscard,
 };
 
 static const match_table_t tokens = {
@@ -1104,6 +1120,7 @@
 	{Opt_acl, "acl"},
 	{Opt_noacl, "noacl"},
 	{Opt_noload, "noload"},
+	{Opt_noload, "norecovery"},
 	{Opt_nobh, "nobh"},
 	{Opt_bh, "bh"},
 	{Opt_commit, "commit=%u"},
@@ -1144,6 +1161,8 @@
 	{Opt_auto_da_alloc, "auto_da_alloc=%u"},
 	{Opt_auto_da_alloc, "auto_da_alloc"},
 	{Opt_noauto_da_alloc, "noauto_da_alloc"},
+	{Opt_discard, "discard"},
+	{Opt_nodiscard, "nodiscard"},
 	{Opt_err, NULL},
 };
 
@@ -1565,6 +1584,12 @@
 			else
 				set_opt(sbi->s_mount_opt,NO_AUTO_DA_ALLOC);
 			break;
+		case Opt_discard:
+			set_opt(sbi->s_mount_opt, DISCARD);
+			break;
+		case Opt_nodiscard:
+			clear_opt(sbi->s_mount_opt, DISCARD);
+			break;
 		default:
 			ext4_msg(sb, KERN_ERR,
 			       "Unrecognized mount option \"%s\" "
@@ -1673,14 +1698,14 @@
 	size_t size;
 	int i;
 
-	if (!sbi->s_es->s_log_groups_per_flex) {
+	sbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;
+	groups_per_flex = 1 << sbi->s_log_groups_per_flex;
+
+	if (groups_per_flex < 2) {
 		sbi->s_log_groups_per_flex = 0;
 		return 1;
 	}
 
-	sbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;
-	groups_per_flex = 1 << sbi->s_log_groups_per_flex;
-
 	/* We allocate both existing and potentially added groups */
 	flex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +
 			((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<
@@ -3668,13 +3693,11 @@
 	buf->f_blocks = ext4_blocks_count(es) - sbi->s_overhead_last;
 	buf->f_bfree = percpu_counter_sum_positive(&sbi->s_freeblocks_counter) -
 		       percpu_counter_sum_positive(&sbi->s_dirtyblocks_counter);
-	ext4_free_blocks_count_set(es, buf->f_bfree);
 	buf->f_bavail = buf->f_bfree - ext4_r_blocks_count(es);
 	if (buf->f_bfree < ext4_r_blocks_count(es))
 		buf->f_bavail = 0;
 	buf->f_files = le32_to_cpu(es->s_inodes_count);
 	buf->f_ffree = percpu_counter_sum_positive(&sbi->s_freeinodes_counter);
-	es->s_free_inodes_count = cpu_to_le32(buf->f_ffree);
 	buf->f_namelen = EXT4_NAME_LEN;
 	fsid = le64_to_cpup((void *)es->s_uuid) ^
 	       le64_to_cpup((void *)es->s_uuid + sizeof(u64));
diff -Nur linux-2.6.32-orig/fs/ext4/xattr.c iDroid-Project-kernel_common-9e90fd2/fs/ext4/xattr.c
--- linux-2.6.32-orig/fs/ext4/xattr.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/ext4/xattr.c	2010-11-18 21:05:30.000000000 +0600
@@ -988,6 +988,10 @@
 	if (error)
 		goto cleanup;
 
+	error = ext4_journal_get_write_access(handle, is.iloc.bh);
+	if (error)
+		goto cleanup;
+
 	if (EXT4_I(inode)->i_state & EXT4_STATE_NEW) {
 		struct ext4_inode *raw_inode = ext4_raw_inode(&is.iloc);
 		memset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);
@@ -1013,9 +1017,6 @@
 		if (flags & XATTR_CREATE)
 			goto cleanup;
 	}
-	error = ext4_journal_get_write_access(handle, is.iloc.bh);
-	if (error)
-		goto cleanup;
 	if (!value) {
 		if (!is.s.not_found)
 			error = ext4_xattr_ibody_set(handle, inode, &i, &is);
diff -Nur linux-2.6.32-orig/fs/fat/dir.c iDroid-Project-kernel_common-9e90fd2/fs/fat/dir.c
--- linux-2.6.32-orig/fs/fat/dir.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/fat/dir.c	2010-11-18 21:05:30.000000000 +0600
@@ -758,6 +758,13 @@
 	return ret;
 }
 
+static int fat_ioctl_volume_id(struct inode *dir)
+{
+	struct super_block *sb = dir->i_sb;
+	struct msdos_sb_info *sbi = MSDOS_SB(sb);
+	return sbi->vol_id;
+}
+
 static int fat_dir_ioctl(struct inode *inode, struct file *filp,
 			 unsigned int cmd, unsigned long arg)
 {
@@ -773,6 +780,8 @@
 		short_only = 0;
 		both = 1;
 		break;
+	case VFAT_IOCTL_GET_VOLUME_ID:
+		return fat_ioctl_volume_id(inode);
 	default:
 		return fat_generic_ioctl(inode, filp, cmd, arg);
 	}
diff -Nur linux-2.6.32-orig/fs/fat/fat.h iDroid-Project-kernel_common-9e90fd2/fs/fat/fat.h
--- linux-2.6.32-orig/fs/fat/fat.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/fat/fat.h	2010-11-18 21:05:30.000000000 +0600
@@ -76,6 +76,7 @@
 	const void *dir_ops;		     /* Opaque; default directory operations */
 	int dir_per_block;	     /* dir entries per block */
 	int dir_per_block_bits;	     /* log2(dir_per_block) */
+	unsigned long vol_id;        /* volume ID */
 
 	int fatent_shift;
 	struct fatent_operations *fatent_ops;
diff -Nur linux-2.6.32-orig/fs/fat/inode.c iDroid-Project-kernel_common-9e90fd2/fs/fat/inode.c
--- linux-2.6.32-orig/fs/fat/inode.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/fat/inode.c	2010-11-18 21:05:30.000000000 +0600
@@ -1215,6 +1215,7 @@
 	struct inode *root_inode = NULL, *fat_inode = NULL;
 	struct buffer_head *bh;
 	struct fat_boot_sector *b;
+	struct fat_boot_bsx *bsx;
 	struct msdos_sb_info *sbi;
 	u16 logical_sector_size;
 	u32 total_sectors, total_clusters, fat_clusters, rootdir_sectors;
@@ -1357,6 +1358,8 @@
 			goto out_fail;
 		}
 
+		bsx = (struct fat_boot_bsx *)(bh->b_data + FAT32_BSX_OFFSET);
+
 		fsinfo = (struct fat_boot_fsinfo *)fsinfo_bh->b_data;
 		if (!IS_FSINFO(fsinfo)) {
 			printk(KERN_WARNING "FAT: Invalid FSINFO signature: "
@@ -1372,8 +1375,14 @@
 		}
 
 		brelse(fsinfo_bh);
+	} else {
+		bsx = (struct fat_boot_bsx *)(bh->b_data + FAT16_BSX_OFFSET);
 	}
 
+	/* interpret volume ID as a little endian 32 bit integer */
+	sbi->vol_id = (((u32)bsx->vol_id[0]) | ((u32)bsx->vol_id[1] << 8) |
+		((u32)bsx->vol_id[2] << 16) | ((u32)bsx->vol_id[3] << 24));
+
 	sbi->dir_per_block = sb->s_blocksize / sizeof(struct msdos_dir_entry);
 	sbi->dir_per_block_bits = ffs(sbi->dir_per_block) - 1;
 
diff -Nur linux-2.6.32-orig/fs/fcntl.c iDroid-Project-kernel_common-9e90fd2/fs/fcntl.c
--- linux-2.6.32-orig/fs/fcntl.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/fcntl.c	2010-11-18 21:05:30.000000000 +0600
@@ -618,60 +618,90 @@
 static struct kmem_cache *fasync_cache __read_mostly;
 
 /*
- * fasync_helper() is used by almost all character device drivers
- * to set up the fasync queue. It returns negative on error, 0 if it did
- * no changes and positive if it added/deleted the entry.
+ * Remove a fasync entry. If successfully removed, return
+ * positive and clear the FASYNC flag. If no entry exists,
+ * do nothing and return 0.
+ *
+ * NOTE! It is very important that the FASYNC flag always
+ * match the state "is the filp on a fasync list".
+ *
+ * We always take the 'filp->f_lock', in since fasync_lock
+ * needs to be irq-safe.
  */
-int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)
+static int fasync_remove_entry(struct file *filp, struct fasync_struct **fapp)
 {
 	struct fasync_struct *fa, **fp;
-	struct fasync_struct *new = NULL;
 	int result = 0;
 
-	if (on) {
-		new = kmem_cache_alloc(fasync_cache, GFP_KERNEL);
-		if (!new)
-			return -ENOMEM;
+	spin_lock(&filp->f_lock);
+	write_lock_irq(&fasync_lock);
+	for (fp = fapp; (fa = *fp) != NULL; fp = &fa->fa_next) {
+		if (fa->fa_file != filp)
+			continue;
+		*fp = fa->fa_next;
+		kmem_cache_free(fasync_cache, fa);
+		filp->f_flags &= ~FASYNC;
+		result = 1;
+		break;
 	}
+	write_unlock_irq(&fasync_lock);
+	spin_unlock(&filp->f_lock);
+	return result;
+}
+
+/*
+ * Add a fasync entry. Return negative on error, positive if
+ * added, and zero if did nothing but change an existing one.
+ *
+ * NOTE! It is very important that the FASYNC flag always
+ * match the state "is the filp on a fasync list".
+ */
+static int fasync_add_entry(int fd, struct file *filp, struct fasync_struct **fapp)
+{
+	struct fasync_struct *new, *fa, **fp;
+	int result = 0;
+
+	new = kmem_cache_alloc(fasync_cache, GFP_KERNEL);
+	if (!new)
+		return -ENOMEM;
 
-	/*
-	 * We need to take f_lock first since it's not an IRQ-safe
-	 * lock.
-	 */
 	spin_lock(&filp->f_lock);
 	write_lock_irq(&fasync_lock);
 	for (fp = fapp; (fa = *fp) != NULL; fp = &fa->fa_next) {
-		if (fa->fa_file == filp) {
-			if(on) {
-				fa->fa_fd = fd;
-				kmem_cache_free(fasync_cache, new);
-			} else {
-				*fp = fa->fa_next;
-				kmem_cache_free(fasync_cache, fa);
-				result = 1;
-			}
-			goto out;
-		}
+		if (fa->fa_file != filp)
+			continue;
+		fa->fa_fd = fd;
+		kmem_cache_free(fasync_cache, new);
+		goto out;
 	}
 
-	if (on) {
-		new->magic = FASYNC_MAGIC;
-		new->fa_file = filp;
-		new->fa_fd = fd;
-		new->fa_next = *fapp;
-		*fapp = new;
-		result = 1;
-	}
+	new->magic = FASYNC_MAGIC;
+	new->fa_file = filp;
+	new->fa_fd = fd;
+	new->fa_next = *fapp;
+	*fapp = new;
+	result = 1;
+	filp->f_flags |= FASYNC;
+
 out:
-	if (on)
-		filp->f_flags |= FASYNC;
-	else
-		filp->f_flags &= ~FASYNC;
 	write_unlock_irq(&fasync_lock);
 	spin_unlock(&filp->f_lock);
 	return result;
 }
 
+/*
+ * fasync_helper() is used by almost all character device drivers
+ * to set up the fasync queue, and for regular files by the file
+ * lease code. It returns negative on error, 0 if it did no changes
+ * and positive if it added/deleted the entry.
+ */
+int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)
+{
+	if (!on)
+		return fasync_remove_entry(filp, fapp);
+	return fasync_add_entry(fd, filp, fapp);
+}
+
 EXPORT_SYMBOL(fasync_helper);
 
 void __kill_fasync(struct fasync_struct *fa, int sig, int band)
diff -Nur linux-2.6.32-orig/fs/fs-writeback.c iDroid-Project-kernel_common-9e90fd2/fs/fs-writeback.c
--- linux-2.6.32-orig/fs/fs-writeback.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/fs-writeback.c	2010-11-18 21:05:30.000000000 +0600
@@ -1071,7 +1071,7 @@
 	if ((inode->i_state & flags) == flags)
 		return;
 
-	if (unlikely(block_dump))
+	if (unlikely(block_dump > 1))
 		block_dump___mark_inode_dirty(inode);
 
 	spin_lock(&inode_lock);
diff -Nur linux-2.6.32-orig/fs/fuse/file.c iDroid-Project-kernel_common-9e90fd2/fs/fuse/file.c
--- linux-2.6.32-orig/fs/fuse/file.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/fuse/file.c	2010-11-18 21:05:30.000000000 +0600
@@ -828,6 +828,9 @@
 		if (!page)
 			break;
 
+		if (mapping_writably_mapped(mapping))
+			flush_dcache_page(page);
+
 		pagefault_disable();
 		tmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);
 		pagefault_enable();
diff -Nur linux-2.6.32-orig/fs/hfs/catalog.c iDroid-Project-kernel_common-9e90fd2/fs/hfs/catalog.c
--- linux-2.6.32-orig/fs/hfs/catalog.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/hfs/catalog.c	2010-11-18 21:05:30.000000000 +0600
@@ -289,6 +289,10 @@
 	err = hfs_brec_find(&src_fd);
 	if (err)
 		goto out;
+	if (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {
+		err = -EIO;
+		goto out;
+	}
 
 	hfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,
 			    src_fd.entrylength);
diff -Nur linux-2.6.32-orig/fs/hfs/dir.c iDroid-Project-kernel_common-9e90fd2/fs/hfs/dir.c
--- linux-2.6.32-orig/fs/hfs/dir.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/hfs/dir.c	2010-11-18 21:05:30.000000000 +0600
@@ -79,6 +79,11 @@
 		filp->f_pos++;
 		/* fall through */
 	case 1:
+		if (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {
+			err = -EIO;
+			goto out;
+		}
+
 		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);
 		if (entry.type != HFS_CDR_THD) {
 			printk(KERN_ERR "hfs: bad catalog folder thread\n");
@@ -109,6 +114,12 @@
 			err = -EIO;
 			goto out;
 		}
+
+		if (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {
+			err = -EIO;
+			goto out;
+		}
+
 		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);
 		type = entry.type;
 		len = hfs_mac2asc(sb, strbuf, &fd.key->cat.CName);
diff -Nur linux-2.6.32-orig/fs/hfs/super.c iDroid-Project-kernel_common-9e90fd2/fs/hfs/super.c
--- linux-2.6.32-orig/fs/hfs/super.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/hfs/super.c	2010-11-18 21:05:30.000000000 +0600
@@ -409,8 +409,13 @@
 	/* try to get the root inode */
 	hfs_find_init(HFS_SB(sb)->cat_tree, &fd);
 	res = hfs_cat_find_brec(sb, HFS_ROOT_CNID, &fd);
-	if (!res)
+	if (!res) {
+		if (fd.entrylength > sizeof(rec) || fd.entrylength < 0) {
+			res =  -EIO;
+			goto bail;
+		}
 		hfs_bnode_read(fd.bnode, &rec, fd.entryoffset, fd.entrylength);
+	}
 	if (res) {
 		hfs_find_exit(&fd);
 		goto bail_no_root;
diff -Nur linux-2.6.32-orig/fs/hfsplus/super.c iDroid-Project-kernel_common-9e90fd2/fs/hfsplus/super.c
--- linux-2.6.32-orig/fs/hfsplus/super.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/hfsplus/super.c	2010-11-18 21:05:30.000000000 +0600
@@ -284,6 +284,18 @@
 			sb->s_flags |= MS_RDONLY;
 			*flags |= MS_RDONLY;
 		}
+	} else {
+		sync_filesystem(sb);
+		hfsplus_sync_fs(sb, 1);
+		if (!(sb->s_flags & MS_RDONLY) && HFSPLUS_SB(sb).s_vhdr) {
+			struct hfsplus_vh *vhdr = HFSPLUS_SB(sb).s_vhdr;
+
+			vhdr->modify_date = hfsp_now2mt();
+			vhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_UNMNT);
+			vhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_INCNSTNT);
+			mark_buffer_dirty(HFSPLUS_SB(sb).s_vhbh);
+			sync_dirty_buffer(HFSPLUS_SB(sb).s_vhbh);
+		}
 	}
 	return 0;
 }
diff -Nur linux-2.6.32-orig/fs/jbd2/commit.c iDroid-Project-kernel_common-9e90fd2/fs/jbd2/commit.c
--- linux-2.6.32-orig/fs/jbd2/commit.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/jbd2/commit.c	2010-11-18 21:05:30.000000000 +0600
@@ -636,6 +636,10 @@
 		JBUFFER_TRACE(jh, "ph3: write metadata");
 		flags = jbd2_journal_write_metadata_buffer(commit_transaction,
 						      jh, &new_jh, blocknr);
+		if (flags < 0) {
+			jbd2_journal_abort(journal, flags);
+			continue;
+		}
 		set_bit(BH_JWrite, &jh2bh(new_jh)->b_state);
 		wbuf[bufs++] = jh2bh(new_jh);
 
diff -Nur linux-2.6.32-orig/fs/jbd2/journal.c iDroid-Project-kernel_common-9e90fd2/fs/jbd2/journal.c
--- linux-2.6.32-orig/fs/jbd2/journal.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/jbd2/journal.c	2010-11-18 21:05:30.000000000 +0600
@@ -78,6 +78,7 @@
 EXPORT_SYMBOL(jbd2_journal_ack_err);
 EXPORT_SYMBOL(jbd2_journal_clear_err);
 EXPORT_SYMBOL(jbd2_log_wait_commit);
+EXPORT_SYMBOL(jbd2_log_start_commit);
 EXPORT_SYMBOL(jbd2_journal_start_commit);
 EXPORT_SYMBOL(jbd2_journal_force_commit_nested);
 EXPORT_SYMBOL(jbd2_journal_wipe);
@@ -358,6 +359,10 @@
 
 		jbd_unlock_bh_state(bh_in);
 		tmp = jbd2_alloc(bh_in->b_size, GFP_NOFS);
+		if (!tmp) {
+			jbd2_journal_put_journal_head(new_jh);
+			return -ENOMEM;
+		}
 		jbd_lock_bh_state(bh_in);
 		if (jh_in->b_frozen_data) {
 			jbd2_free(tmp, bh_in->b_size);
@@ -1248,6 +1253,13 @@
 	if (jbd2_journal_recover(journal))
 		goto recovery_error;
 
+	if (journal->j_failed_commit) {
+		printk(KERN_ERR "JBD2: journal transaction %u on %s "
+		       "is corrupt.\n", journal->j_failed_commit,
+		       journal->j_devname);
+		return -EIO;
+	}
+
 	/* OK, we've finished with the dynamic journal bits:
 	 * reinitialise the dynamic contents of the superblock in memory
 	 * and reset them on disk. */
diff -Nur linux-2.6.32-orig/fs/jffs2/gc.c iDroid-Project-kernel_common-9e90fd2/fs/jffs2/gc.c
--- linux-2.6.32-orig/fs/jffs2/gc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/jffs2/gc.c	2010-11-18 21:05:30.000000000 +0600
@@ -700,7 +700,8 @@
 	struct jffs2_raw_inode ri;
 	struct jffs2_node_frag *last_frag;
 	union jffs2_device_node dev;
-	char *mdata = NULL, mdatalen = 0;
+	char *mdata = NULL;
+	int mdatalen = 0;
 	uint32_t alloclen, ilen;
 	int ret;
 
diff -Nur linux-2.6.32-orig/fs/Kconfig iDroid-Project-kernel_common-9e90fd2/fs/Kconfig
--- linux-2.6.32-orig/fs/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -174,6 +174,10 @@
 source "fs/befs/Kconfig"
 source "fs/bfs/Kconfig"
 source "fs/efs/Kconfig"
+
+# Patched by YAFFS
+source "fs/yaffs2/Kconfig"
+
 source "fs/jffs2/Kconfig"
 # UBIFS File system configuration
 source "fs/ubifs/Kconfig"
diff -Nur linux-2.6.32-orig/fs/Makefile iDroid-Project-kernel_common-9e90fd2/fs/Makefile
--- linux-2.6.32-orig/fs/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -124,3 +124,6 @@
 obj-$(CONFIG_BTRFS_FS)		+= btrfs/
 obj-$(CONFIG_GFS2_FS)           += gfs2/
 obj-$(CONFIG_EXOFS_FS)          += exofs/
+
+# Patched by YAFFS
+obj-$(CONFIG_YAFFS_FS)		+= yaffs2/
diff -Nur linux-2.6.32-orig/fs/namei.c iDroid-Project-kernel_common-9e90fd2/fs/namei.c
--- linux-2.6.32-orig/fs/namei.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/namei.c	2010-11-18 21:05:30.000000000 +0600
@@ -234,6 +234,7 @@
 	/*
 	 * Searching includes executable on directories, else just read.
 	 */
+	mask &= MAY_READ | MAY_WRITE | MAY_EXEC;
 	if (mask == MAY_READ || (S_ISDIR(inode->i_mode) && !(mask & MAY_WRITE)))
 		if (capable(CAP_DAC_READ_SEARCH))
 			return 0;
diff -Nur linux-2.6.32-orig/fs/nfs/direct.c iDroid-Project-kernel_common-9e90fd2/fs/nfs/direct.c
--- linux-2.6.32-orig/fs/nfs/direct.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/nfs/direct.c	2010-11-18 21:05:30.000000000 +0600
@@ -342,6 +342,7 @@
 		data->res.fattr = &data->fattr;
 		data->res.eof = 0;
 		data->res.count = bytes;
+		nfs_fattr_init(&data->fattr);
 		msg.rpc_argp = &data->args;
 		msg.rpc_resp = &data->res;
 
@@ -575,6 +576,7 @@
 	data->res.count = 0;
 	data->res.fattr = &data->fattr;
 	data->res.verf = &data->verf;
+	nfs_fattr_init(&data->fattr);
 
 	NFS_PROTO(data->inode)->commit_setup(data, &msg);
 
@@ -766,6 +768,7 @@
 		data->res.fattr = &data->fattr;
 		data->res.count = bytes;
 		data->res.verf = &data->verf;
+		nfs_fattr_init(&data->fattr);
 
 		task_setup_data.task = &data->task;
 		task_setup_data.callback_data = data;
diff -Nur linux-2.6.32-orig/fs/nfs/file.c iDroid-Project-kernel_common-9e90fd2/fs/nfs/file.c
--- linux-2.6.32-orig/fs/nfs/file.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/nfs/file.c	2010-11-18 21:05:30.000000000 +0600
@@ -486,6 +486,8 @@
 {
 	dfprintk(PAGECACHE, "NFS: release_page(%p)\n", page);
 
+	if (gfp & __GFP_WAIT)
+		nfs_wb_page(page->mapping->host, page);
 	/* If PagePrivate() is set, then the page is not freeable */
 	if (PagePrivate(page))
 		return 0;
diff -Nur linux-2.6.32-orig/fs/nfs/fscache.c iDroid-Project-kernel_common-9e90fd2/fs/nfs/fscache.c
--- linux-2.6.32-orig/fs/nfs/fscache.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/nfs/fscache.c	2010-11-18 21:05:30.000000000 +0600
@@ -354,12 +354,11 @@
  */
 int nfs_fscache_release_page(struct page *page, gfp_t gfp)
 {
-	struct nfs_inode *nfsi = NFS_I(page->mapping->host);
-	struct fscache_cookie *cookie = nfsi->fscache;
-
-	BUG_ON(!cookie);
-
 	if (PageFsCache(page)) {
+		struct nfs_inode *nfsi = NFS_I(page->mapping->host);
+		struct fscache_cookie *cookie = nfsi->fscache;
+
+		BUG_ON(!cookie);
 		dfprintk(FSCACHE, "NFS: fscache releasepage (0x%p/0x%p/0x%p)\n",
 			 cookie, page, nfsi);
 
diff -Nur linux-2.6.32-orig/fs/nfs/mount_clnt.c iDroid-Project-kernel_common-9e90fd2/fs/nfs/mount_clnt.c
--- linux-2.6.32-orig/fs/nfs/mount_clnt.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/nfs/mount_clnt.c	2010-11-18 21:05:30.000000000 +0600
@@ -120,7 +120,7 @@
 	{ .status = MNT3ERR_INVAL,		.errno = -EINVAL,	},
 	{ .status = MNT3ERR_NAMETOOLONG,	.errno = -ENAMETOOLONG,	},
 	{ .status = MNT3ERR_NOTSUPP,		.errno = -ENOTSUPP,	},
-	{ .status = MNT3ERR_SERVERFAULT,	.errno = -ESERVERFAULT,	},
+	{ .status = MNT3ERR_SERVERFAULT,	.errno = -EREMOTEIO,	},
 };
 
 struct mountres {
diff -Nur linux-2.6.32-orig/fs/nfs/nfs2xdr.c iDroid-Project-kernel_common-9e90fd2/fs/nfs/nfs2xdr.c
--- linux-2.6.32-orig/fs/nfs/nfs2xdr.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/nfs/nfs2xdr.c	2010-11-18 21:05:30.000000000 +0600
@@ -699,7 +699,7 @@
 	{ NFSERR_BAD_COOKIE,	-EBADCOOKIE	},
 	{ NFSERR_NOTSUPP,	-ENOTSUPP	},
 	{ NFSERR_TOOSMALL,	-ETOOSMALL	},
-	{ NFSERR_SERVERFAULT,	-ESERVERFAULT	},
+	{ NFSERR_SERVERFAULT,	-EREMOTEIO	},
 	{ NFSERR_BADTYPE,	-EBADTYPE	},
 	{ NFSERR_JUKEBOX,	-EJUKEBOX	},
 	{ -1,			-EIO		}
diff -Nur linux-2.6.32-orig/fs/nfs/nfs4_fs.h iDroid-Project-kernel_common-9e90fd2/fs/nfs/nfs4_fs.h
--- linux-2.6.32-orig/fs/nfs/nfs4_fs.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/nfs/nfs4_fs.h	2010-11-18 21:05:30.000000000 +0600
@@ -141,6 +141,7 @@
 	NFS_O_RDWR_STATE,		/* OPEN stateid has read/write state */
 	NFS_STATE_RECLAIM_REBOOT,	/* OPEN stateid server rebooted */
 	NFS_STATE_RECLAIM_NOGRACE,	/* OPEN stateid needs to recover state */
+	NFS_STATE_POSIX_LOCKS,		/* Posix locks are supported */
 };
 
 struct nfs4_state {
diff -Nur linux-2.6.32-orig/fs/nfs/nfs4proc.c iDroid-Project-kernel_common-9e90fd2/fs/nfs/nfs4proc.c
--- linux-2.6.32-orig/fs/nfs/nfs4proc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/nfs/nfs4proc.c	2010-11-18 21:05:30.000000000 +0600
@@ -1573,6 +1573,8 @@
 	status = PTR_ERR(state);
 	if (IS_ERR(state))
 		goto err_opendata_put;
+	if ((opendata->o_res.rflags & NFS4_OPEN_RESULT_LOCKTYPE_POSIX) != 0)
+		set_bit(NFS_STATE_POSIX_LOCKS, &state->flags);
 	nfs4_opendata_put(opendata);
 	nfs4_put_state_owner(sp);
 	*res = state;
@@ -3976,6 +3978,22 @@
 	.rpc_release = nfs4_lock_release,
 };
 
+static void nfs4_handle_setlk_error(struct nfs_server *server, struct nfs4_lock_state *lsp, int new_lock_owner, int error)
+{
+	struct nfs_client *clp = server->nfs_client;
+	struct nfs4_state *state = lsp->ls_state;
+
+	switch (error) {
+	case -NFS4ERR_ADMIN_REVOKED:
+	case -NFS4ERR_BAD_STATEID:
+	case -NFS4ERR_EXPIRED:
+		if (new_lock_owner != 0 ||
+		   (lsp->ls_flags & NFS_LOCK_INITIALIZED) != 0)
+			nfs4_state_mark_reclaim_nograce(clp, state);
+		lsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;
+	};
+}
+
 static int _nfs4_do_setlk(struct nfs4_state *state, int cmd, struct file_lock *fl, int reclaim)
 {
 	struct nfs4_lockdata *data;
@@ -4011,6 +4029,9 @@
 	ret = nfs4_wait_for_completion_rpc_task(task);
 	if (ret == 0) {
 		ret = data->rpc_status;
+		if (ret)
+			nfs4_handle_setlk_error(data->server, data->lsp,
+					data->arg.new_lock_owner, ret);
 	} else
 		data->cancelled = 1;
 	rpc_put_task(task);
@@ -4060,8 +4081,11 @@
 {
 	struct nfs_inode *nfsi = NFS_I(state->inode);
 	unsigned char fl_flags = request->fl_flags;
-	int status;
+	int status = -ENOLCK;
 
+	if ((fl_flags & FL_POSIX) &&
+			!test_bit(NFS_STATE_POSIX_LOCKS, &state->flags))
+		goto out;
 	/* Is this a delegated open? */
 	status = nfs4_set_lock_state(state, request);
 	if (status != 0)
diff -Nur linux-2.6.32-orig/fs/nfs/nfs4xdr.c iDroid-Project-kernel_common-9e90fd2/fs/nfs/nfs4xdr.c
--- linux-2.6.32-orig/fs/nfs/nfs4xdr.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/nfs/nfs4xdr.c	2010-11-18 21:05:30.000000000 +0600
@@ -4554,7 +4554,7 @@
 	 * If the server returns different values for sessionID, slotID or
 	 * sequence number, the server is looney tunes.
 	 */
-	status = -ESERVERFAULT;
+	status = -EREMOTEIO;
 
 	if (memcmp(id.data, res->sr_session->sess_id.data,
 		   NFS4_MAX_SESSIONID_LEN)) {
@@ -5678,7 +5678,7 @@
 	{ NFS4ERR_BAD_COOKIE,	-EBADCOOKIE	},
 	{ NFS4ERR_NOTSUPP,	-ENOTSUPP	},
 	{ NFS4ERR_TOOSMALL,	-ETOOSMALL	},
-	{ NFS4ERR_SERVERFAULT,	-ESERVERFAULT	},
+	{ NFS4ERR_SERVERFAULT,	-EREMOTEIO	},
 	{ NFS4ERR_BADTYPE,	-EBADTYPE	},
 	{ NFS4ERR_LOCKED,	-EAGAIN		},
 	{ NFS4ERR_SYMLINK,	-ELOOP		},
@@ -5705,7 +5705,7 @@
 	}
 	if (stat <= 10000 || stat > 10100) {
 		/* The server is looney tunes. */
-		return -ESERVERFAULT;
+		return -EREMOTEIO;
 	}
 	/* If we cannot translate the error, the recovery routines should
 	 * handle it.
diff -Nur linux-2.6.32-orig/fs/nfs/pagelist.c iDroid-Project-kernel_common-9e90fd2/fs/nfs/pagelist.c
--- linux-2.6.32-orig/fs/nfs/pagelist.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/nfs/pagelist.c	2010-11-18 21:05:30.000000000 +0600
@@ -176,6 +176,12 @@
 	kref_put(&req->wb_kref, nfs_free_request);
 }
 
+static int nfs_wait_bit_uninterruptible(void *word)
+{
+	io_schedule();
+	return 0;
+}
+
 /**
  * nfs_wait_on_request - Wait for a request to complete.
  * @req: request to wait upon.
@@ -186,14 +192,9 @@
 int
 nfs_wait_on_request(struct nfs_page *req)
 {
-	int ret = 0;
-
-	if (!test_bit(PG_BUSY, &req->wb_flags))
-		goto out;
-	ret = out_of_line_wait_on_bit(&req->wb_flags, PG_BUSY,
-			nfs_wait_bit_killable, TASK_KILLABLE);
-out:
-	return ret;
+	return wait_on_bit(&req->wb_flags, PG_BUSY,
+			nfs_wait_bit_uninterruptible,
+			TASK_UNINTERRUPTIBLE);
 }
 
 /**
diff -Nur linux-2.6.32-orig/fs/nfs/super.c iDroid-Project-kernel_common-9e90fd2/fs/nfs/super.c
--- linux-2.6.32-orig/fs/nfs/super.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/nfs/super.c	2010-11-18 21:05:30.000000000 +0600
@@ -241,6 +241,7 @@
 static int nfs_get_sb(struct file_system_type *, int, const char *, void *, struct vfsmount *);
 static int nfs_xdev_get_sb(struct file_system_type *fs_type,
 		int flags, const char *dev_name, void *raw_data, struct vfsmount *mnt);
+static void nfs_put_super(struct super_block *);
 static void nfs_kill_super(struct super_block *);
 static int nfs_remount(struct super_block *sb, int *flags, char *raw_data);
 
@@ -264,6 +265,7 @@
 	.alloc_inode	= nfs_alloc_inode,
 	.destroy_inode	= nfs_destroy_inode,
 	.write_inode	= nfs_write_inode,
+	.put_super	= nfs_put_super,
 	.statfs		= nfs_statfs,
 	.clear_inode	= nfs_clear_inode,
 	.umount_begin	= nfs_umount_begin,
@@ -333,6 +335,7 @@
 	.alloc_inode	= nfs_alloc_inode,
 	.destroy_inode	= nfs_destroy_inode,
 	.write_inode	= nfs_write_inode,
+	.put_super	= nfs_put_super,
 	.statfs		= nfs_statfs,
 	.clear_inode	= nfs4_clear_inode,
 	.umount_begin	= nfs_umount_begin,
@@ -734,8 +737,6 @@
 
 	data = kzalloc(sizeof(*data), GFP_KERNEL);
 	if (data) {
-		data->rsize		= NFS_MAX_FILE_IO_SIZE;
-		data->wsize		= NFS_MAX_FILE_IO_SIZE;
 		data->acregmin		= NFS_DEF_ACREGMIN;
 		data->acregmax		= NFS_DEF_ACREGMAX;
 		data->acdirmin		= NFS_DEF_ACDIRMIN;
@@ -2198,6 +2199,17 @@
 }
 
 /*
+ * Ensure that we unregister the bdi before kill_anon_super
+ * releases the device name
+ */
+static void nfs_put_super(struct super_block *s)
+{
+	struct nfs_server *server = NFS_SB(s);
+
+	bdi_unregister(&server->backing_dev_info);
+}
+
+/*
  * Destroy an NFS2/3 superblock
  */
 static void nfs_kill_super(struct super_block *s)
@@ -2205,7 +2217,6 @@
 	struct nfs_server *server = NFS_SB(s);
 
 	kill_anon_super(s);
-	bdi_unregister(&server->backing_dev_info);
 	nfs_fscache_release_super_cookie(s);
 	nfs_free_server(server);
 }
diff -Nur linux-2.6.32-orig/fs/nfs/write.c iDroid-Project-kernel_common-9e90fd2/fs/nfs/write.c
--- linux-2.6.32-orig/fs/nfs/write.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/nfs/write.c	2010-11-18 21:05:30.000000000 +0600
@@ -1542,6 +1542,7 @@
 			break;
 		}
 		ret = nfs_wait_on_request(req);
+		nfs_release_request(req);
 		if (ret < 0)
 			goto out;
 	}
@@ -1612,15 +1613,16 @@
 	if (ret)
 		goto out_unlock;
 	page_cache_get(newpage);
+	spin_lock(&mapping->host->i_lock);
 	req->wb_page = newpage;
 	SetPagePrivate(newpage);
-	set_page_private(newpage, page_private(page));
+	set_page_private(newpage, (unsigned long)req);
 	ClearPagePrivate(page);
 	set_page_private(page, 0);
+	spin_unlock(&mapping->host->i_lock);
 	page_cache_release(page);
 out_unlock:
 	nfs_clear_page_tag_locked(req);
-	nfs_release_request(req);
 out:
 	return ret;
 }
diff -Nur linux-2.6.32-orig/fs/nfsd/nfs4acl.c iDroid-Project-kernel_common-9e90fd2/fs/nfsd/nfs4acl.c
--- linux-2.6.32-orig/fs/nfsd/nfs4acl.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/nfsd/nfs4acl.c	2010-11-18 21:05:30.000000000 +0600
@@ -389,7 +389,7 @@
 	sort_pacl_range(pacl, 1, i-1);
 
 	BUG_ON(pacl->a_entries[i].e_tag != ACL_GROUP_OBJ);
-	j = i++;
+	j = ++i;
 	while (pacl->a_entries[j].e_tag == ACL_GROUP)
 		j++;
 	sort_pacl_range(pacl, i, j-1);
diff -Nur linux-2.6.32-orig/fs/nfsd/vfs.c iDroid-Project-kernel_common-9e90fd2/fs/nfsd/vfs.c
--- linux-2.6.32-orig/fs/nfsd/vfs.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/nfsd/vfs.c	2010-11-18 21:05:30.000000000 +0600
@@ -774,12 +774,9 @@
 	int (*fsync) (struct file *, struct dentry *, int);
 	int err;
 
-	err = filemap_fdatawrite(inode->i_mapping);
+	err = filemap_write_and_wait(inode->i_mapping);
 	if (err == 0 && fop && (fsync = fop->fsync))
 		err = fsync(filp, dp, 0);
-	if (err == 0)
-		err = filemap_fdatawait(inode->i_mapping);
-
 	return err;
 }
 
diff -Nur linux-2.6.32-orig/fs/notify/inotify/inotify_fsnotify.c iDroid-Project-kernel_common-9e90fd2/fs/notify/inotify/inotify_fsnotify.c
--- linux-2.6.32-orig/fs/notify/inotify/inotify_fsnotify.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/notify/inotify/inotify_fsnotify.c	2010-11-18 21:05:30.000000000 +0600
@@ -121,7 +121,7 @@
 	if (warned)
 		return 0;
 
-	warned = false;
+	warned = true;
 	entry = p;
 	ientry = container_of(entry, struct inotify_inode_mark_entry, fsn_entry);
 
diff -Nur linux-2.6.32-orig/fs/notify/inotify/inotify_user.c iDroid-Project-kernel_common-9e90fd2/fs/notify/inotify/inotify_user.c
--- linux-2.6.32-orig/fs/notify/inotify/inotify_user.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/notify/inotify/inotify_user.c	2010-11-18 21:05:30.000000000 +0600
@@ -558,7 +558,7 @@
 
 	spin_lock(&group->inotify_data.idr_lock);
 	ret = idr_get_new_above(&group->inotify_data.idr, &tmp_ientry->fsn_entry,
-				group->inotify_data.last_wd,
+				group->inotify_data.last_wd+1,
 				&tmp_ientry->wd);
 	spin_unlock(&group->inotify_data.idr_lock);
 	if (ret) {
@@ -638,7 +638,7 @@
 
 	spin_lock_init(&group->inotify_data.idr_lock);
 	idr_init(&group->inotify_data.idr);
-	group->inotify_data.last_wd = 1;
+	group->inotify_data.last_wd = 0;
 	group->inotify_data.user = user;
 	group->inotify_data.fa = NULL;
 
diff -Nur linux-2.6.32-orig/fs/partitions/check.c iDroid-Project-kernel_common-9e90fd2/fs/partitions/check.c
--- linux-2.6.32-orig/fs/partitions/check.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/partitions/check.c	2010-11-18 21:05:30.000000000 +0600
@@ -327,10 +327,19 @@
 	kfree(p);
 }
 
+static int part_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct hd_struct *part = dev_to_part(dev);
+
+	add_uevent_var(env, "PARTN=%u", part->partno);
+	return 0;
+}
+
 struct device_type part_type = {
 	.name		= "partition",
 	.groups		= part_attr_groups,
 	.release	= part_release,
+	.uevent		= part_uevent,
 };
 
 static void delete_partition_rcu_cb(struct rcu_head *head)
diff -Nur linux-2.6.32-orig/fs/partitions/efi.c iDroid-Project-kernel_common-9e90fd2/fs/partitions/efi.c
--- linux-2.6.32-orig/fs/partitions/efi.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/partitions/efi.c	2010-11-18 21:05:30.000000000 +0600
@@ -1,7 +1,9 @@
 /************************************************************
  * EFI GUID Partition Table handling
- * Per Intel EFI Specification v1.02
- * http://developer.intel.com/technology/efi/efi.htm
+ *
+ * http://www.uefi.org/specs/
+ * http://www.intel.com/technology/efi/
+ *
  * efi.[ch] by Matt Domsch <Matt_Domsch@dell.com>
  *   Copyright 2000,2001,2002,2004 Dell Inc.
  *
@@ -92,6 +94,7 @@
  *
  ************************************************************/
 #include <linux/crc32.h>
+#include <linux/math64.h>
 #include "check.h"
 #include "efi.h"
 
@@ -141,7 +144,8 @@
 {
 	if (!bdev || !bdev->bd_inode)
 		return 0;
-	return (bdev->bd_inode->i_size >> 9) - 1ULL;
+	return div_u64(bdev->bd_inode->i_size,
+		       bdev_logical_block_size(bdev)) - 1ULL;
 }
 
 static inline int
@@ -188,6 +192,7 @@
 read_lba(struct block_device *bdev, u64 lba, u8 * buffer, size_t count)
 {
 	size_t totalreadcount = 0;
+	sector_t n = lba * (bdev_logical_block_size(bdev) / 512);
 
 	if (!bdev || !buffer || lba > last_lba(bdev))
                 return 0;
@@ -195,7 +200,7 @@
 	while (count) {
 		int copied = 512;
 		Sector sect;
-		unsigned char *data = read_dev_sector(bdev, lba++, &sect);
+		unsigned char *data = read_dev_sector(bdev, n++, &sect);
 		if (!data)
 			break;
 		if (copied > count)
@@ -257,15 +262,16 @@
 alloc_read_gpt_header(struct block_device *bdev, u64 lba)
 {
 	gpt_header *gpt;
+	unsigned ssz = bdev_logical_block_size(bdev);
+
 	if (!bdev)
 		return NULL;
 
-	gpt = kzalloc(sizeof (gpt_header), GFP_KERNEL);
+	gpt = kzalloc(ssz, GFP_KERNEL);
 	if (!gpt)
 		return NULL;
 
-	if (read_lba(bdev, lba, (u8 *) gpt,
-		     sizeof (gpt_header)) < sizeof (gpt_header)) {
+	if (read_lba(bdev, lba, (u8 *) gpt, ssz) < ssz) {
 		kfree(gpt);
                 gpt=NULL;
 		return NULL;
@@ -601,6 +607,7 @@
 	gpt_header *gpt = NULL;
 	gpt_entry *ptes = NULL;
 	u32 i;
+	unsigned ssz = bdev_logical_block_size(bdev) / 512;
 
 	if (!find_valid_gpt(bdev, &gpt, &ptes) || !gpt || !ptes) {
 		kfree(gpt);
@@ -611,13 +618,14 @@
 	pr_debug("GUID Partition Table is valid!  Yea!\n");
 
 	for (i = 0; i < le32_to_cpu(gpt->num_partition_entries) && i < state->limit-1; i++) {
+		u64 start = le64_to_cpu(ptes[i].starting_lba);
+		u64 size = le64_to_cpu(ptes[i].ending_lba) -
+			   le64_to_cpu(ptes[i].starting_lba) + 1ULL;
+
 		if (!is_pte_valid(&ptes[i], last_lba(bdev)))
 			continue;
 
-		put_partition(state, i+1, le64_to_cpu(ptes[i].starting_lba),
-				 (le64_to_cpu(ptes[i].ending_lba) -
-                                  le64_to_cpu(ptes[i].starting_lba) +
-				  1ULL));
+		put_partition(state, i+1, start * ssz, size * ssz);
 
 		/* If this is a RAID volume, tell md */
 		if (!efi_guidcmp(ptes[i].partition_type_guid,
diff -Nur linux-2.6.32-orig/fs/partitions/efi.h iDroid-Project-kernel_common-9e90fd2/fs/partitions/efi.h
--- linux-2.6.32-orig/fs/partitions/efi.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/partitions/efi.h	2010-11-18 21:05:30.000000000 +0600
@@ -37,7 +37,6 @@
 #define EFI_PMBR_OSTYPE_EFI 0xEF
 #define EFI_PMBR_OSTYPE_EFI_GPT 0xEE
 
-#define GPT_BLOCK_SIZE 512
 #define GPT_HEADER_SIGNATURE 0x5452415020494645ULL
 #define GPT_HEADER_REVISION_V1 0x00010000
 #define GPT_PRIMARY_PARTITION_TABLE_LBA 1
@@ -79,7 +78,12 @@
 	__le32 num_partition_entries;
 	__le32 sizeof_partition_entry;
 	__le32 partition_entry_array_crc32;
-	u8 reserved2[GPT_BLOCK_SIZE - 92];
+
+	/* The rest of the logical block is reserved by UEFI and must be zero.
+	 * EFI standard handles this by:
+	 *
+	 * uint8_t		reserved2[ BlockSize - 92 ];
+	 */
 } __attribute__ ((packed)) gpt_header;
 
 typedef struct _gpt_entry_attributes {
diff -Nur linux-2.6.32-orig/fs/proc/base.c iDroid-Project-kernel_common-9e90fd2/fs/proc/base.c
--- linux-2.6.32-orig/fs/proc/base.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/proc/base.c	2010-11-18 21:05:30.000000000 +0600
@@ -128,6 +128,12 @@
 		NULL, &proc_single_file_operations,	\
 		{ .proc_show = show } )
 
+/* ANDROID is for special files in /proc. */
+#define ANDROID(NAME, MODE, OTYPE)			\
+	NOD(NAME, (S_IFREG|(MODE)),			\
+		&proc_##OTYPE##_inode_operations,	\
+		&proc_##OTYPE##_operations, {})
+
 /*
  * Count the number of hardlinks for the pid_entry table, excluding the .
  * and .. links.
@@ -241,7 +247,8 @@
 
 	mm = get_task_mm(task);
 	if (mm && mm != current->mm &&
-			!ptrace_may_access(task, PTRACE_MODE_READ)) {
+			!ptrace_may_access(task, PTRACE_MODE_READ) &&
+			!capable(CAP_SYS_RESOURCE)) {
 		mmput(mm);
 		mm = NULL;
 	}
@@ -1061,6 +1068,33 @@
 	return count;
 }
 
+static int oom_adjust_permission(struct inode *inode, int mask)
+{
+	uid_t uid;
+	struct task_struct *p = get_proc_task(inode);
+	if(p) {
+		uid = task_uid(p);
+		put_task_struct(p);
+	}
+
+	/*
+	 * System Server (uid == 1000) is granted access to oom_adj of all 
+	 * android applications (uid > 10000) as and services (uid >= 1000)
+	 */
+	if (p && (current_fsuid() == 1000) && (uid >= 1000)) {
+		if (inode->i_mode >> 6 & mask) {
+			return 0;
+		}
+	}
+
+	/* Fall back to default. */
+	return generic_permission(inode, mask, NULL);
+}
+
+static const struct inode_operations proc_oom_adjust_inode_operations = {
+	.permission	= oom_adjust_permission,
+};
+
 static const struct file_operations proc_oom_adjust_operations = {
 	.read		= oom_adjust_read,
 	.write		= oom_adjust_write,
@@ -2548,7 +2582,7 @@
 	REG("cgroup",  S_IRUGO, proc_cgroup_operations),
 #endif
 	INF("oom_score",  S_IRUGO, proc_oom_score),
-	REG("oom_adj",    S_IRUGO|S_IWUSR, proc_oom_adjust_operations),
+	ANDROID("oom_adj",S_IRUGO|S_IWUSR, oom_adjust),
 #ifdef CONFIG_AUDITSYSCALL
 	REG("loginuid",   S_IWUSR|S_IRUGO, proc_loginuid_operations),
 	REG("sessionid",  S_IRUGO, proc_sessionid_operations),
diff -Nur linux-2.6.32-orig/fs/proc/task_mmu.c iDroid-Project-kernel_common-9e90fd2/fs/proc/task_mmu.c
--- linux-2.6.32-orig/fs/proc/task_mmu.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/proc/task_mmu.c	2010-11-18 21:05:30.000000000 +0600
@@ -404,6 +404,7 @@
 
 	memset(&mss, 0, sizeof mss);
 	mss.vma = vma;
+	/* mmap_sem is held in m_start */
 	if (vma->vm_mm && !is_vm_hugetlb_page(vma))
 		walk_page_range(vma->vm_start, vma->vm_end, &smaps_walk);
 
@@ -550,7 +551,8 @@
 };
 
 struct pagemapread {
-	u64 __user *out, *end;
+	int pos, len;
+	u64 *buffer;
 };
 
 #define PM_ENTRY_BYTES      sizeof(u64)
@@ -573,10 +575,8 @@
 static int add_to_pagemap(unsigned long addr, u64 pfn,
 			  struct pagemapread *pm)
 {
-	if (put_user(pfn, pm->out))
-		return -EFAULT;
-	pm->out++;
-	if (pm->out >= pm->end)
+	pm->buffer[pm->pos++] = pfn;
+	if (pm->pos >= pm->len)
 		return PM_END_OF_BUFFER;
 	return 0;
 }
@@ -674,21 +674,20 @@
  * determine which areas of memory are actually mapped and llseek to
  * skip over unmapped regions.
  */
+#define PAGEMAP_WALK_SIZE	(PMD_SIZE)
 static ssize_t pagemap_read(struct file *file, char __user *buf,
 			    size_t count, loff_t *ppos)
 {
 	struct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);
-	struct page **pages, *page;
-	unsigned long uaddr, uend;
 	struct mm_struct *mm;
 	struct pagemapread pm;
-	int pagecount;
 	int ret = -ESRCH;
 	struct mm_walk pagemap_walk = {};
 	unsigned long src;
 	unsigned long svpfn;
 	unsigned long start_vaddr;
 	unsigned long end_vaddr;
+	int copied = 0;
 
 	if (!task)
 		goto out;
@@ -711,35 +710,12 @@
 	if (!mm)
 		goto out_task;
 
-
-	uaddr = (unsigned long)buf & PAGE_MASK;
-	uend = (unsigned long)(buf + count);
-	pagecount = (PAGE_ALIGN(uend) - uaddr) / PAGE_SIZE;
-	ret = 0;
-	if (pagecount == 0)
-		goto out_mm;
-	pages = kcalloc(pagecount, sizeof(struct page *), GFP_KERNEL);
+	pm.len = PM_ENTRY_BYTES * (PAGEMAP_WALK_SIZE >> PAGE_SHIFT);
+	pm.buffer = kmalloc(pm.len, GFP_TEMPORARY);
 	ret = -ENOMEM;
-	if (!pages)
+	if (!pm.buffer)
 		goto out_mm;
 
-	down_read(&current->mm->mmap_sem);
-	ret = get_user_pages(current, current->mm, uaddr, pagecount,
-			     1, 0, pages, NULL);
-	up_read(&current->mm->mmap_sem);
-
-	if (ret < 0)
-		goto out_free;
-
-	if (ret != pagecount) {
-		pagecount = ret;
-		ret = -EFAULT;
-		goto out_pages;
-	}
-
-	pm.out = (u64 __user *)buf;
-	pm.end = (u64 __user *)(buf + count);
-
 	pagemap_walk.pmd_entry = pagemap_pte_range;
 	pagemap_walk.pte_hole = pagemap_pte_hole;
 	pagemap_walk.mm = mm;
@@ -760,23 +736,36 @@
 	 * user buffer is tracked in "pm", and the walk
 	 * will stop when we hit the end of the buffer.
 	 */
-	ret = walk_page_range(start_vaddr, end_vaddr, &pagemap_walk);
-	if (ret == PM_END_OF_BUFFER)
-		ret = 0;
-	/* don't need mmap_sem for these, but this looks cleaner */
-	*ppos += (char __user *)pm.out - buf;
-	if (!ret)
-		ret = (char __user *)pm.out - buf;
-
-out_pages:
-	for (; pagecount; pagecount--) {
-		page = pages[pagecount-1];
-		if (!PageReserved(page))
-			SetPageDirty(page);
-		page_cache_release(page);
+	ret = 0;
+	while (count && (start_vaddr < end_vaddr)) {
+		int len;
+		unsigned long end;
+
+		pm.pos = 0;
+		end = start_vaddr + PAGEMAP_WALK_SIZE;
+		/* overflow ? */
+		if (end < start_vaddr || end > end_vaddr)
+			end = end_vaddr;
+		down_read(&mm->mmap_sem);
+		ret = walk_page_range(start_vaddr, end, &pagemap_walk);
+		up_read(&mm->mmap_sem);
+		start_vaddr = end;
+
+		len = min(count, PM_ENTRY_BYTES * pm.pos);
+		if (copy_to_user(buf, pm.buffer, len) < 0) {
+			ret = -EFAULT;
+			goto out_free;
+		}
+		copied += len;
+		buf += len;
+		count -= len;
 	}
+	*ppos += copied;
+	if (!ret || ret == PM_END_OF_BUFFER)
+		ret = copied;
+
 out_free:
-	kfree(pages);
+	kfree(pm.buffer);
 out_mm:
 	mmput(mm);
 out_task:
diff -Nur linux-2.6.32-orig/fs/quota/dquot.c iDroid-Project-kernel_common-9e90fd2/fs/quota/dquot.c
--- linux-2.6.32-orig/fs/quota/dquot.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/quota/dquot.c	2010-11-18 21:05:30.000000000 +0600
@@ -1388,6 +1388,70 @@
 EXPORT_SYMBOL(vfs_dq_drop);
 
 /*
+ * inode_reserved_space is managed internally by quota, and protected by
+ * i_lock similar to i_blocks+i_bytes.
+ */
+static qsize_t *inode_reserved_space(struct inode * inode)
+{
+	/* Filesystem must explicitly define it's own method in order to use
+	 * quota reservation interface */
+	BUG_ON(!inode->i_sb->dq_op->get_reserved_space);
+	return inode->i_sb->dq_op->get_reserved_space(inode);
+}
+
+static void inode_add_rsv_space(struct inode *inode, qsize_t number)
+{
+	spin_lock(&inode->i_lock);
+	*inode_reserved_space(inode) += number;
+	spin_unlock(&inode->i_lock);
+}
+
+
+static void inode_claim_rsv_space(struct inode *inode, qsize_t number)
+{
+	spin_lock(&inode->i_lock);
+	*inode_reserved_space(inode) -= number;
+	__inode_add_bytes(inode, number);
+	spin_unlock(&inode->i_lock);
+}
+
+static void inode_sub_rsv_space(struct inode *inode, qsize_t number)
+{
+	spin_lock(&inode->i_lock);
+	*inode_reserved_space(inode) -= number;
+	spin_unlock(&inode->i_lock);
+}
+
+static qsize_t inode_get_rsv_space(struct inode *inode)
+{
+	qsize_t ret;
+
+	if (!inode->i_sb->dq_op->get_reserved_space)
+		return 0;
+	spin_lock(&inode->i_lock);
+	ret = *inode_reserved_space(inode);
+	spin_unlock(&inode->i_lock);
+	return ret;
+}
+
+static void inode_incr_space(struct inode *inode, qsize_t number,
+				int reserve)
+{
+	if (reserve)
+		inode_add_rsv_space(inode, number);
+	else
+		inode_add_bytes(inode, number);
+}
+
+static void inode_decr_space(struct inode *inode, qsize_t number, int reserve)
+{
+	if (reserve)
+		inode_sub_rsv_space(inode, number);
+	else
+		inode_sub_bytes(inode, number);
+}
+
+/*
  * Following four functions update i_blocks+i_bytes fields and
  * quota information (together with appropriate checks)
  * NOTE: We absolutely rely on the fact that caller dirties
@@ -1405,6 +1469,21 @@
 	int cnt, ret = QUOTA_OK;
 	char warntype[MAXQUOTAS];
 
+	/*
+	 * First test before acquiring mutex - solves deadlocks when we
+	 * re-enter the quota code and are already holding the mutex
+	 */
+	if (IS_NOQUOTA(inode)) {
+		inode_incr_space(inode, number, reserve);
+		goto out;
+	}
+
+	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
+	if (IS_NOQUOTA(inode)) {
+		inode_incr_space(inode, number, reserve);
+		goto out_unlock;
+	}
+
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++)
 		warntype[cnt] = QUOTA_NL_NOWARN;
 
@@ -1415,7 +1494,8 @@
 		if (check_bdq(inode->i_dquot[cnt], number, warn, warntype+cnt)
 		    == NO_QUOTA) {
 			ret = NO_QUOTA;
-			goto out_unlock;
+			spin_unlock(&dq_data_lock);
+			goto out_flush_warn;
 		}
 	}
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
@@ -1426,64 +1506,32 @@
 		else
 			dquot_incr_space(inode->i_dquot[cnt], number);
 	}
-	if (!reserve)
-		inode_add_bytes(inode, number);
-out_unlock:
+	inode_incr_space(inode, number, reserve);
 	spin_unlock(&dq_data_lock);
-	flush_warnings(inode->i_dquot, warntype);
-	return ret;
-}
-
-int dquot_alloc_space(struct inode *inode, qsize_t number, int warn)
-{
-	int cnt, ret = QUOTA_OK;
-
-	/*
-	 * First test before acquiring mutex - solves deadlocks when we
-	 * re-enter the quota code and are already holding the mutex
-	 */
-	if (IS_NOQUOTA(inode)) {
-		inode_add_bytes(inode, number);
-		goto out;
-	}
-
-	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
-	if (IS_NOQUOTA(inode)) {
-		inode_add_bytes(inode, number);
-		goto out_unlock;
-	}
-
-	ret = __dquot_alloc_space(inode, number, warn, 0);
-	if (ret == NO_QUOTA)
-		goto out_unlock;
 
+	if (reserve)
+		goto out_flush_warn;
 	/* Dirtify all the dquots - this can block when journalling */
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++)
 		if (inode->i_dquot[cnt])
 			mark_dquot_dirty(inode->i_dquot[cnt]);
+out_flush_warn:
+	flush_warnings(inode->i_dquot, warntype);
 out_unlock:
 	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
 out:
 	return ret;
 }
+
+int dquot_alloc_space(struct inode *inode, qsize_t number, int warn)
+{
+	return __dquot_alloc_space(inode, number, warn, 0);
+}
 EXPORT_SYMBOL(dquot_alloc_space);
 
 int dquot_reserve_space(struct inode *inode, qsize_t number, int warn)
 {
-	int ret = QUOTA_OK;
-
-	if (IS_NOQUOTA(inode))
-		goto out;
-
-	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
-	if (IS_NOQUOTA(inode))
-		goto out_unlock;
-
-	ret = __dquot_alloc_space(inode, number, warn, 1);
-out_unlock:
-	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
-out:
-	return ret;
+	return __dquot_alloc_space(inode, number, warn, 1);
 }
 EXPORT_SYMBOL(dquot_reserve_space);
 
@@ -1540,14 +1588,14 @@
 	int ret = QUOTA_OK;
 
 	if (IS_NOQUOTA(inode)) {
-		inode_add_bytes(inode, number);
+		inode_claim_rsv_space(inode, number);
 		goto out;
 	}
 
 	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
 	if (IS_NOQUOTA(inode))	{
 		up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
-		inode_add_bytes(inode, number);
+		inode_claim_rsv_space(inode, number);
 		goto out;
 	}
 
@@ -1559,7 +1607,7 @@
 							number);
 	}
 	/* Update inode bytes */
-	inode_add_bytes(inode, number);
+	inode_claim_rsv_space(inode, number);
 	spin_unlock(&dq_data_lock);
 	/* Dirtify all the dquots - this can block when journalling */
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++)
@@ -1572,38 +1620,9 @@
 EXPORT_SYMBOL(dquot_claim_space);
 
 /*
- * Release reserved quota space
- */
-void dquot_release_reserved_space(struct inode *inode, qsize_t number)
-{
-	int cnt;
-
-	if (IS_NOQUOTA(inode))
-		goto out;
-
-	down_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
-	if (IS_NOQUOTA(inode))
-		goto out_unlock;
-
-	spin_lock(&dq_data_lock);
-	/* Release reserved dquots */
-	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
-		if (inode->i_dquot[cnt])
-			dquot_free_reserved_space(inode->i_dquot[cnt], number);
-	}
-	spin_unlock(&dq_data_lock);
-
-out_unlock:
-	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
-out:
-	return;
-}
-EXPORT_SYMBOL(dquot_release_reserved_space);
-
-/*
  * This operation can block, but only after everything is updated
  */
-int dquot_free_space(struct inode *inode, qsize_t number)
+int __dquot_free_space(struct inode *inode, qsize_t number, int reserve)
 {
 	unsigned int cnt;
 	char warntype[MAXQUOTAS];
@@ -1612,7 +1631,7 @@
          * re-enter the quota code and are already holding the mutex */
 	if (IS_NOQUOTA(inode)) {
 out_sub:
-		inode_sub_bytes(inode, number);
+		inode_decr_space(inode, number, reserve);
 		return QUOTA_OK;
 	}
 
@@ -1627,21 +1646,43 @@
 		if (!inode->i_dquot[cnt])
 			continue;
 		warntype[cnt] = info_bdq_free(inode->i_dquot[cnt], number);
-		dquot_decr_space(inode->i_dquot[cnt], number);
+		if (reserve)
+			dquot_free_reserved_space(inode->i_dquot[cnt], number);
+		else
+			dquot_decr_space(inode->i_dquot[cnt], number);
 	}
-	inode_sub_bytes(inode, number);
+	inode_decr_space(inode, number, reserve);
 	spin_unlock(&dq_data_lock);
+
+	if (reserve)
+		goto out_unlock;
 	/* Dirtify all the dquots - this can block when journalling */
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++)
 		if (inode->i_dquot[cnt])
 			mark_dquot_dirty(inode->i_dquot[cnt]);
+out_unlock:
 	flush_warnings(inode->i_dquot, warntype);
 	up_read(&sb_dqopt(inode->i_sb)->dqptr_sem);
 	return QUOTA_OK;
 }
+
+int dquot_free_space(struct inode *inode, qsize_t number)
+{
+	return  __dquot_free_space(inode, number, 0);
+}
 EXPORT_SYMBOL(dquot_free_space);
 
 /*
+ * Release reserved quota space
+ */
+void dquot_release_reserved_space(struct inode *inode, qsize_t number)
+{
+	__dquot_free_space(inode, number, 1);
+
+}
+EXPORT_SYMBOL(dquot_release_reserved_space);
+
+/*
  * This operation can block, but only after everything is updated
  */
 int dquot_free_inode(const struct inode *inode, qsize_t number)
@@ -1679,19 +1720,6 @@
 EXPORT_SYMBOL(dquot_free_inode);
 
 /*
- * call back function, get reserved quota space from underlying fs
- */
-qsize_t dquot_get_reserved_space(struct inode *inode)
-{
-	qsize_t reserved_space = 0;
-
-	if (sb_any_quota_active(inode->i_sb) &&
-	    inode->i_sb->dq_op->get_reserved_space)
-		reserved_space = inode->i_sb->dq_op->get_reserved_space(inode);
-	return reserved_space;
-}
-
-/*
  * Transfer the number of inode and blocks from one diskquota to an other.
  *
  * This operation can block, but only after everything is updated
@@ -1734,7 +1762,7 @@
 	}
 	spin_lock(&dq_data_lock);
 	cur_space = inode_get_bytes(inode);
-	rsv_space = dquot_get_reserved_space(inode);
+	rsv_space = inode_get_rsv_space(inode);
 	space = cur_space + rsv_space;
 	/* Build the transfer_from list and check the limits */
 	for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
diff -Nur linux-2.6.32-orig/fs/reiserfs/inode.c iDroid-Project-kernel_common-9e90fd2/fs/reiserfs/inode.c
--- linux-2.6.32-orig/fs/reiserfs/inode.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/reiserfs/inode.c	2010-11-18 21:05:30.000000000 +0600
@@ -2531,6 +2531,12 @@
 	return reiserfs_write_full_page(page, wbc);
 }
 
+static void reiserfs_truncate_failed_write(struct inode *inode)
+{
+	truncate_inode_pages(inode->i_mapping, inode->i_size);
+	reiserfs_truncate_file(inode, 0);
+}
+
 static int reiserfs_write_begin(struct file *file,
 				struct address_space *mapping,
 				loff_t pos, unsigned len, unsigned flags,
@@ -2597,6 +2603,8 @@
 	if (ret) {
 		unlock_page(page);
 		page_cache_release(page);
+		/* Truncate allocated blocks */
+		reiserfs_truncate_failed_write(inode);
 	}
 	return ret;
 }
@@ -2689,8 +2697,7 @@
 	 ** transaction tracking stuff when the size changes.  So, we have
 	 ** to do the i_size updates here.
 	 */
-	pos += copied;
-	if (pos > inode->i_size) {
+	if (pos + copied > inode->i_size) {
 		struct reiserfs_transaction_handle myth;
 		reiserfs_write_lock(inode->i_sb);
 		/* If the file have grown beyond the border where it
@@ -2708,7 +2715,7 @@
 			goto journal_error;
 		}
 		reiserfs_update_inode_transaction(inode);
-		inode->i_size = pos;
+		inode->i_size = pos + copied;
 		/*
 		 * this will just nest into our transaction.  It's important
 		 * to use mark_inode_dirty so the inode gets pushed around on the
@@ -2735,6 +2742,10 @@
       out:
 	unlock_page(page);
 	page_cache_release(page);
+
+	if (pos + len > inode->i_size)
+		reiserfs_truncate_failed_write(inode);
+
 	return ret == 0 ? copied : ret;
 
       journal_error:
diff -Nur linux-2.6.32-orig/fs/romfs/super.c iDroid-Project-kernel_common-9e90fd2/fs/romfs/super.c
--- linux-2.6.32-orig/fs/romfs/super.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/romfs/super.c	2010-11-18 21:05:30.000000000 +0600
@@ -544,6 +544,7 @@
 error_rsb_inval:
 	ret = -EINVAL;
 error_rsb:
+	kfree(rsb);
 	return ret;
 }
 
diff -Nur linux-2.6.32-orig/fs/stat.c iDroid-Project-kernel_common-9e90fd2/fs/stat.c
--- linux-2.6.32-orig/fs/stat.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/stat.c	2010-11-18 21:05:30.000000000 +0600
@@ -401,9 +401,9 @@
 }
 #endif /* __ARCH_WANT_STAT64 */
 
-void inode_add_bytes(struct inode *inode, loff_t bytes)
+/* Caller is here responsible for sufficient locking (ie. inode->i_lock) */
+void __inode_add_bytes(struct inode *inode, loff_t bytes)
 {
-	spin_lock(&inode->i_lock);
 	inode->i_blocks += bytes >> 9;
 	bytes &= 511;
 	inode->i_bytes += bytes;
@@ -411,6 +411,12 @@
 		inode->i_blocks++;
 		inode->i_bytes -= 512;
 	}
+}
+
+void inode_add_bytes(struct inode *inode, loff_t bytes)
+{
+	spin_lock(&inode->i_lock);
+	__inode_add_bytes(inode, bytes);
 	spin_unlock(&inode->i_lock);
 }
 
diff -Nur linux-2.6.32-orig/fs/super.c iDroid-Project-kernel_common-9e90fd2/fs/super.c
--- linux-2.6.32-orig/fs/super.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/super.c	2010-11-18 21:05:30.000000000 +0600
@@ -901,8 +901,9 @@
 			return error;
 		}
 		s->s_flags |= MS_ACTIVE;
+	} else {
+		do_remount_sb(s, flags, data, 0);
 	}
-	do_remount_sb(s, flags, data, 0);
 	simple_set_mnt(mnt, s);
 	return 0;
 }
diff -Nur linux-2.6.32-orig/fs/sysfs/inode.c iDroid-Project-kernel_common-9e90fd2/fs/sysfs/inode.c
--- linux-2.6.32-orig/fs/sysfs/inode.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/sysfs/inode.c	2010-11-18 21:05:30.000000000 +0600
@@ -94,30 +94,29 @@
 		if (!sd_attrs)
 			return -ENOMEM;
 		sd->s_iattr = sd_attrs;
-	} else {
-		/* attributes were changed at least once in past */
-		iattrs = &sd_attrs->ia_iattr;
-
-		if (ia_valid & ATTR_UID)
-			iattrs->ia_uid = iattr->ia_uid;
-		if (ia_valid & ATTR_GID)
-			iattrs->ia_gid = iattr->ia_gid;
-		if (ia_valid & ATTR_ATIME)
-			iattrs->ia_atime = timespec_trunc(iattr->ia_atime,
-					inode->i_sb->s_time_gran);
-		if (ia_valid & ATTR_MTIME)
-			iattrs->ia_mtime = timespec_trunc(iattr->ia_mtime,
-					inode->i_sb->s_time_gran);
-		if (ia_valid & ATTR_CTIME)
-			iattrs->ia_ctime = timespec_trunc(iattr->ia_ctime,
-					inode->i_sb->s_time_gran);
-		if (ia_valid & ATTR_MODE) {
-			umode_t mode = iattr->ia_mode;
-
-			if (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))
-				mode &= ~S_ISGID;
-			iattrs->ia_mode = sd->s_mode = mode;
-		}
+	}
+	/* attributes were changed at least once in past */
+	iattrs = &sd_attrs->ia_iattr;
+
+	if (ia_valid & ATTR_UID)
+		iattrs->ia_uid = iattr->ia_uid;
+	if (ia_valid & ATTR_GID)
+		iattrs->ia_gid = iattr->ia_gid;
+	if (ia_valid & ATTR_ATIME)
+		iattrs->ia_atime = timespec_trunc(iattr->ia_atime,
+			inode->i_sb->s_time_gran);
+	if (ia_valid & ATTR_MTIME)
+		iattrs->ia_mtime = timespec_trunc(iattr->ia_mtime,
+			inode->i_sb->s_time_gran);
+	if (ia_valid & ATTR_CTIME)
+		iattrs->ia_ctime = timespec_trunc(iattr->ia_ctime,
+			inode->i_sb->s_time_gran);
+	if (ia_valid & ATTR_MODE) {
+		umode_t mode = iattr->ia_mode;
+
+		if (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))
+			mode &= ~S_ISGID;
+		iattrs->ia_mode = sd->s_mode = mode;
 	}
 	return error;
 }
diff -Nur linux-2.6.32-orig/fs/udf/super.c iDroid-Project-kernel_common-9e90fd2/fs/udf/super.c
--- linux-2.6.32-orig/fs/udf/super.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/fs/udf/super.c	2010-11-18 21:05:30.000000000 +0600
@@ -1078,21 +1078,39 @@
 	return 0;
 }
 
-static int udf_load_vat(struct super_block *sb, int p_index, int type1_index)
+static void udf_find_vat_block(struct super_block *sb, int p_index,
+			       int type1_index, sector_t start_block)
 {
 	struct udf_sb_info *sbi = UDF_SB(sb);
 	struct udf_part_map *map = &sbi->s_partmaps[p_index];
+	sector_t vat_block;
 	struct kernel_lb_addr ino;
+
+	/*
+	 * VAT file entry is in the last recorded block. Some broken disks have
+	 * it a few blocks before so try a bit harder...
+	 */
+	ino.partitionReferenceNum = type1_index;
+	for (vat_block = start_block;
+	     vat_block >= map->s_partition_root &&
+	     vat_block >= start_block - 3 &&
+	     !sbi->s_vat_inode; vat_block--) {
+		ino.logicalBlockNum = vat_block - map->s_partition_root;
+		sbi->s_vat_inode = udf_iget(sb, &ino);
+	}
+}
+
+static int udf_load_vat(struct super_block *sb, int p_index, int type1_index)
+{
+	struct udf_sb_info *sbi = UDF_SB(sb);
+	struct udf_part_map *map = &sbi->s_partmaps[p_index];
 	struct buffer_head *bh = NULL;
 	struct udf_inode_info *vati;
 	uint32_t pos;
 	struct virtualAllocationTable20 *vat20;
 	sector_t blocks = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;
 
-	/* VAT file entry is in the last recorded block */
-	ino.partitionReferenceNum = type1_index;
-	ino.logicalBlockNum = sbi->s_last_block - map->s_partition_root;
-	sbi->s_vat_inode = udf_iget(sb, &ino);
+	udf_find_vat_block(sb, p_index, type1_index, sbi->s_last_block);
 	if (!sbi->s_vat_inode &&
 	    sbi->s_last_block != blocks - 1) {
 		printk(KERN_NOTICE "UDF-fs: Failed to read VAT inode from the"
@@ -1100,9 +1118,7 @@
 		       "block of the device (%lu).\n",
 		       (unsigned long)sbi->s_last_block,
 		       (unsigned long)blocks - 1);
-		ino.partitionReferenceNum = type1_index;
-		ino.logicalBlockNum = blocks - 1 - map->s_partition_root;
-		sbi->s_vat_inode = udf_iget(sb, &ino);
+		udf_find_vat_block(sb, p_index, type1_index, blocks - 1);
 	}
 	if (!sbi->s_vat_inode)
 		return 1;
diff -Nur linux-2.6.32-orig/fs/yaffs2/devextras.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/devextras.h
--- linux-2.6.32-orig/fs/yaffs2/devextras.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/devextras.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,196 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * This file is just holds extra declarations of macros that would normally
+ * be providesd in the Linux kernel. These macros have been written from
+ * scratch but are functionally equivalent to the Linux ones.
+ *
+ */
+
+#ifndef __EXTRAS_H__
+#define __EXTRAS_H__
+
+
+#if !(defined __KERNEL__)
+
+/* Definition of types */
+typedef unsigned char __u8;
+typedef unsigned short __u16;
+typedef unsigned __u32;
+
+#endif
+
+/*
+ * This is a simple doubly linked list implementation that matches the
+ * way the Linux kernel doubly linked list implementation works.
+ */
+
+struct ylist_head {
+	struct ylist_head *next; /* next in chain */
+	struct ylist_head *prev; /* previous in chain */
+};
+
+
+/* Initialise a static list */
+#define YLIST_HEAD(name) \
+struct ylist_head name = { &(name), &(name)}
+
+
+
+/* Initialise a list head to an empty list */
+#define YINIT_LIST_HEAD(p) \
+do { \
+	(p)->next = (p);\
+	(p)->prev = (p); \
+} while (0)
+
+
+/* Add an element to a list */
+static __inline__ void ylist_add(struct ylist_head *newEntry,
+				struct ylist_head *list)
+{
+	struct ylist_head *listNext = list->next;
+
+	list->next = newEntry;
+	newEntry->prev = list;
+	newEntry->next = listNext;
+	listNext->prev = newEntry;
+
+}
+
+static __inline__ void ylist_add_tail(struct ylist_head *newEntry,
+				 struct ylist_head *list)
+{
+	struct ylist_head *listPrev = list->prev;
+
+	list->prev = newEntry;
+	newEntry->next = list;
+	newEntry->prev = listPrev;
+	listPrev->next = newEntry;
+
+}
+
+
+/* Take an element out of its current list, with or without
+ * reinitialising the links.of the entry*/
+static __inline__ void ylist_del(struct ylist_head *entry)
+{
+	struct ylist_head *listNext = entry->next;
+	struct ylist_head *listPrev = entry->prev;
+
+	listNext->prev = listPrev;
+	listPrev->next = listNext;
+
+}
+
+static __inline__ void ylist_del_init(struct ylist_head *entry)
+{
+	ylist_del(entry);
+	entry->next = entry->prev = entry;
+}
+
+
+/* Test if the list is empty */
+static __inline__ int ylist_empty(struct ylist_head *entry)
+{
+	return (entry->next == entry);
+}
+
+
+/* ylist_entry takes a pointer to a list entry and offsets it to that
+ * we can find a pointer to the object it is embedded in.
+ */
+
+
+#define ylist_entry(entry, type, member) \
+	((type *)((char *)(entry)-(unsigned long)(&((type *)NULL)->member)))
+
+
+/* ylist_for_each and list_for_each_safe  iterate over lists.
+ * ylist_for_each_safe uses temporary storage to make the list delete safe
+ */
+
+#define ylist_for_each(itervar, list) \
+	for (itervar = (list)->next; itervar != (list); itervar = itervar->next)
+
+#define ylist_for_each_safe(itervar, saveVar, list) \
+	for (itervar = (list)->next, saveVar = (list)->next->next; \
+		itervar != (list); itervar = saveVar, saveVar = saveVar->next)
+
+
+#if !(defined __KERNEL__)
+
+
+#ifndef WIN32
+#include <sys/stat.h>
+#endif
+
+
+#ifdef CONFIG_YAFFS_PROVIDE_DEFS
+/* File types */
+
+
+#define DT_UNKNOWN	0
+#define DT_FIFO		1
+#define DT_CHR		2
+#define DT_DIR		4
+#define DT_BLK		6
+#define DT_REG		8
+#define DT_LNK		10
+#define DT_SOCK		12
+#define DT_WHT		14
+
+
+#ifndef WIN32
+#include <sys/stat.h>
+#endif
+
+/*
+ * Attribute flags.  These should be or-ed together to figure out what
+ * has been changed!
+ */
+#define ATTR_MODE	1
+#define ATTR_UID	2
+#define ATTR_GID	4
+#define ATTR_SIZE	8
+#define ATTR_ATIME	16
+#define ATTR_MTIME	32
+#define ATTR_CTIME	64
+
+struct iattr {
+	unsigned int ia_valid;
+	unsigned ia_mode;
+	unsigned ia_uid;
+	unsigned ia_gid;
+	unsigned ia_size;
+	unsigned ia_atime;
+	unsigned ia_mtime;
+	unsigned ia_ctime;
+	unsigned int ia_attr_flags;
+};
+
+#endif
+
+#else
+
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+
+#endif
+
+
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/Kconfig iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/Kconfig
--- linux-2.6.32-orig/fs/yaffs2/Kconfig	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,164 @@
+#
+# YAFFS file system configurations
+#
+
+config YAFFS_FS
+	tristate "YAFFS2 file system support"
+	default n
+	depends on MTD_BLOCK
+	select YAFFS_YAFFS1
+	select YAFFS_YAFFS2
+	help
+	  YAFFS2, or Yet Another Flash Filing System, is a filing system
+	  optimised for NAND Flash chips.
+
+	  To compile the YAFFS2 file system support as a module, choose M
+	  here: the module will be called yaffs2.
+
+	  If unsure, say N.
+
+	  Further information on YAFFS2 is available at
+	  <http://www.aleph1.co.uk/yaffs/>.
+
+config YAFFS_YAFFS1
+	bool "512 byte / page devices"
+	depends on YAFFS_FS
+	default y
+	help
+	  Enable YAFFS1 support -- yaffs for 512 byte / page devices
+
+	  Not needed for 2K-page devices.
+
+	  If unsure, say Y.
+
+config YAFFS_9BYTE_TAGS
+	bool "Use older-style on-NAND data format with pageStatus byte"
+	depends on YAFFS_YAFFS1
+	default n
+	help
+
+	  Older-style on-NAND data format has a "pageStatus" byte to record
+	  chunk/page state.  This byte is zero when the page is discarded.
+	  Choose this option if you have existing on-NAND data using this
+	  format that you need to continue to support.  New data written
+	  also uses the older-style format.  Note: Use of this option
+	  generally requires that MTD's oob layout be adjusted to use the
+	  older-style format.  See notes on tags formats and MTD versions
+	  in yaffs_mtdif1.c.
+
+	  If unsure, say N.
+
+config YAFFS_DOES_ECC
+	bool "Lets Yaffs do its own ECC"
+	depends on YAFFS_FS && YAFFS_YAFFS1 && !YAFFS_9BYTE_TAGS
+	default n
+	help
+	  This enables Yaffs to use its own ECC functions instead of using
+	  the ones from the generic MTD-NAND driver.
+
+	  If unsure, say N.
+
+config YAFFS_ECC_WRONG_ORDER
+	bool "Use the same ecc byte order as Steven Hill's nand_ecc.c"
+	depends on YAFFS_FS && YAFFS_DOES_ECC && !YAFFS_9BYTE_TAGS
+	default n
+	help
+	  This makes yaffs_ecc.c use the same ecc byte order as Steven
+	  Hill's nand_ecc.c. If not set, then you get the same ecc byte
+	  order as SmartMedia.
+
+	  If unsure, say N.
+
+config YAFFS_YAFFS2
+	bool "2048 byte (or larger) / page devices"
+	depends on YAFFS_FS
+	default y
+	help
+	  Enable YAFFS2 support -- yaffs for >= 2K bytes per page devices
+
+	  If unsure, say Y.
+
+config YAFFS_AUTO_YAFFS2
+	bool "Autoselect yaffs2 format"
+	depends on YAFFS_YAFFS2
+	default y
+	help
+	  Without this, you need to explicitely use yaffs2 as the file
+	  system type. With this, you can say "yaffs" and yaffs or yaffs2
+	  will be used depending on the device page size (yaffs on
+	  512-byte page devices, yaffs2 on 2K page devices).
+
+	  If unsure, say Y.
+
+config YAFFS_DISABLE_LAZY_LOAD
+	bool "Disable lazy loading"
+	depends on YAFFS_YAFFS2
+	default n
+	help
+	  "Lazy loading" defers loading file details until they are
+	  required. This saves mount time, but makes the first look-up
+	  a bit longer.
+
+	  Lazy loading will only happen if enabled by this option being 'n'
+	  and if the appropriate tags are available, else yaffs2 will
+	  automatically fall back to immediate loading and do the right
+	  thing.
+
+	  Lazy laoding will be required by checkpointing.
+
+	  Setting this to 'y' will disable lazy loading.
+
+	  If unsure, say N.
+
+
+config YAFFS_DISABLE_WIDE_TNODES
+	bool "Turn off wide tnodes"
+	depends on YAFFS_FS
+	default n
+	help
+	  Wide tnodes are only used for NAND arrays >=32MB for 512-byte
+	  page devices and >=128MB for 2k page devices. They use slightly
+	  more RAM but are faster since they eliminate chunk group
+	  searching.
+
+	  Setting this to 'y' will force tnode width to 16 bits and save
+	  memory but make large arrays slower.
+
+	  If unsure, say N.
+
+config YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+	bool "Force chunk erase check"
+	depends on YAFFS_FS
+	default n
+	help
+          Normally YAFFS only checks chunks before writing until an erased
+	  chunk is found. This helps to detect any partially written
+	  chunks that might have happened due to power loss.
+
+	  Enabling this forces on the test that chunks are erased in flash
+	  before writing to them. This takes more time but is potentially
+	  a bit more secure.
+
+	  Suggest setting Y during development and ironing out driver
+	  issues etc. Suggest setting to N if you want faster writing.
+
+	  If unsure, say Y.
+
+config YAFFS_SHORT_NAMES_IN_RAM
+	bool "Cache short names in RAM"
+	depends on YAFFS_FS
+	default y
+	help
+	  If this config is set, then short names are stored with the
+	  yaffs_Object.  This costs an extra 16 bytes of RAM per object,
+	  but makes look-ups faster.
+
+	  If unsure, say Y.
+
+config YAFFS_EMPTY_LOST_AND_FOUND
+	bool "Empty lost and found on mount"
+	depends on YAFFS_FS
+	default n
+	help
+	  If this is enabled then the contents of lost and found is
+	  automatically dumped at mount.
diff -Nur linux-2.6.32-orig/fs/yaffs2/Makefile iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/Makefile
--- linux-2.6.32-orig/fs/yaffs2/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,10 @@
+#
+# Makefile for the linux YAFFS filesystem routines.
+#
+
+obj-$(CONFIG_YAFFS_FS) += yaffs.o
+
+yaffs-y := yaffs_ecc.o yaffs_fs.o yaffs_guts.o yaffs_checkptrw.o
+yaffs-y += yaffs_packedtags1.o yaffs_packedtags2.o yaffs_nand.o yaffs_qsort.o
+yaffs-y += yaffs_tagscompat.o yaffs_tagsvalidity.o
+yaffs-y += yaffs_mtdif.o yaffs_mtdif1.o yaffs_mtdif2.o
diff -Nur linux-2.6.32-orig/fs/yaffs2/moduleconfig.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/moduleconfig.h
--- linux-2.6.32-orig/fs/yaffs2/moduleconfig.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/moduleconfig.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,65 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Martin Fouts <Martin.Fouts@palmsource.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_CONFIG_H__
+#define __YAFFS_CONFIG_H__
+
+#ifdef YAFFS_OUT_OF_TREE
+
+/* DO NOT UNSET THESE THREE. YAFFS2 will not compile if you do. */
+#define CONFIG_YAFFS_FS
+#define CONFIG_YAFFS_YAFFS1
+#define CONFIG_YAFFS_YAFFS2
+
+/* These options are independent of each other.  Select those that matter. */
+
+/* Default: Not selected */
+/* Meaning: Yaffs does its own ECC, rather than using MTD ECC */
+/* #define CONFIG_YAFFS_DOES_ECC */
+
+/* Default: Not selected */
+/* Meaning: ECC byte order is 'wrong'.  Only meaningful if */
+/*          CONFIG_YAFFS_DOES_ECC is set */
+/* #define CONFIG_YAFFS_ECC_WRONG_ORDER */
+
+/* Default: Selected */
+/* Meaning: Disables testing whether chunks are erased before writing to them*/
+#define CONFIG_YAFFS_DISABLE_CHUNK_ERASED_CHECK
+
+/* Default: Selected */
+/* Meaning: Cache short names, taking more RAM, but faster look-ups */
+#define CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+
+/* Default: 10 */
+/* Meaning: set the count of blocks to reserve for checkpointing */
+#define CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS 10
+
+/*
+Older-style on-NAND data format has a "pageStatus" byte to record
+chunk/page state.  This byte is zeroed when the page is discarded.
+Choose this option if you have existing on-NAND data in this format
+that you need to continue to support.  New data written also uses the
+older-style format.
+Note: Use of this option generally requires that MTD's oob layout be
+adjusted to use the older-style format.  See notes on tags formats and
+MTD versions in yaffs_mtdif1.c.
+*/
+/* Default: Not selected */
+/* Meaning: Use older-style on-NAND data format with pageStatus byte */
+/* #define CONFIG_YAFFS_9BYTE_TAGS */
+
+#endif /* YAFFS_OUT_OF_TREE */
+
+#endif /* __YAFFS_CONFIG_H__ */
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_checkptrw.c iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_checkptrw.c
--- linux-2.6.32-orig/fs/yaffs2/yaffs_checkptrw.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_checkptrw.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,402 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+const char *yaffs_checkptrw_c_version =
+	"$Id$";
+
+
+#include "yaffs_checkptrw.h"
+#include "yaffs_getblockinfo.h"
+
+static int yaffs_CheckpointSpaceOk(yaffs_Device *dev)
+{
+	int blocksAvailable = dev->nErasedBlocks - dev->nReservedBlocks;
+
+	T(YAFFS_TRACE_CHECKPOINT,
+		(TSTR("checkpt blocks available = %d" TENDSTR),
+		blocksAvailable));
+
+	return (blocksAvailable <= 0) ? 0 : 1;
+}
+
+
+static int yaffs_CheckpointErase(yaffs_Device *dev)
+{
+	int i;
+
+	if (!dev->eraseBlockInNAND)
+		return 0;
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checking blocks %d to %d"TENDSTR),
+		dev->internalStartBlock, dev->internalEndBlock));
+
+	for (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {
+		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, i);
+		if (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT) {
+			T(YAFFS_TRACE_CHECKPOINT, (TSTR("erasing checkpt block %d"TENDSTR), i));
+
+			dev->nBlockErasures++;
+
+			if (dev->eraseBlockInNAND(dev, i - dev->blockOffset /* realign */)) {
+				bi->blockState = YAFFS_BLOCK_STATE_EMPTY;
+				dev->nErasedBlocks++;
+				dev->nFreeChunks += dev->nChunksPerBlock;
+			} else {
+				dev->markNANDBlockBad(dev, i);
+				bi->blockState = YAFFS_BLOCK_STATE_DEAD;
+			}
+		}
+	}
+
+	dev->blocksInCheckpoint = 0;
+
+	return 1;
+}
+
+
+static void yaffs_CheckpointFindNextErasedBlock(yaffs_Device *dev)
+{
+	int  i;
+	int blocksAvailable = dev->nErasedBlocks - dev->nReservedBlocks;
+	T(YAFFS_TRACE_CHECKPOINT,
+		(TSTR("allocating checkpt block: erased %d reserved %d avail %d next %d "TENDSTR),
+		dev->nErasedBlocks, dev->nReservedBlocks, blocksAvailable, dev->checkpointNextBlock));
+
+	if (dev->checkpointNextBlock >= 0 &&
+			dev->checkpointNextBlock <= dev->internalEndBlock &&
+			blocksAvailable > 0) {
+
+		for (i = dev->checkpointNextBlock; i <= dev->internalEndBlock; i++) {
+			yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, i);
+			if (bi->blockState == YAFFS_BLOCK_STATE_EMPTY) {
+				dev->checkpointNextBlock = i + 1;
+				dev->checkpointCurrentBlock = i;
+				T(YAFFS_TRACE_CHECKPOINT, (TSTR("allocating checkpt block %d"TENDSTR), i));
+				return;
+			}
+		}
+	}
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("out of checkpt blocks"TENDSTR)));
+
+	dev->checkpointNextBlock = -1;
+	dev->checkpointCurrentBlock = -1;
+}
+
+static void yaffs_CheckpointFindNextCheckpointBlock(yaffs_Device *dev)
+{
+	int  i;
+	yaffs_ExtendedTags tags;
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("find next checkpt block: start:  blocks %d next %d" TENDSTR),
+		dev->blocksInCheckpoint, dev->checkpointNextBlock));
+
+	if (dev->blocksInCheckpoint < dev->checkpointMaxBlocks)
+		for (i = dev->checkpointNextBlock; i <= dev->internalEndBlock; i++) {
+			int chunk = i * dev->nChunksPerBlock;
+			int realignedChunk = chunk - dev->chunkOffset;
+
+			dev->readChunkWithTagsFromNAND(dev, realignedChunk,
+					NULL, &tags);
+			T(YAFFS_TRACE_CHECKPOINT, (TSTR("find next checkpt block: search: block %d oid %d seq %d eccr %d" TENDSTR),
+				i, tags.objectId, tags.sequenceNumber, tags.eccResult));
+
+			if (tags.sequenceNumber == YAFFS_SEQUENCE_CHECKPOINT_DATA) {
+				/* Right kind of block */
+				dev->checkpointNextBlock = tags.objectId;
+				dev->checkpointCurrentBlock = i;
+				dev->checkpointBlockList[dev->blocksInCheckpoint] = i;
+				dev->blocksInCheckpoint++;
+				T(YAFFS_TRACE_CHECKPOINT, (TSTR("found checkpt block %d"TENDSTR), i));
+				return;
+			}
+		}
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("found no more checkpt blocks"TENDSTR)));
+
+	dev->checkpointNextBlock = -1;
+	dev->checkpointCurrentBlock = -1;
+}
+
+
+int yaffs_CheckpointOpen(yaffs_Device *dev, int forWriting)
+{
+
+
+	dev->checkpointOpenForWrite = forWriting;
+
+	/* Got the functions we need? */
+	if (!dev->writeChunkWithTagsToNAND ||
+			!dev->readChunkWithTagsFromNAND ||
+			!dev->eraseBlockInNAND ||
+			!dev->markNANDBlockBad)
+		return 0;
+
+	if (forWriting && !yaffs_CheckpointSpaceOk(dev))
+		return 0;
+
+	if (!dev->checkpointBuffer)
+		dev->checkpointBuffer = YMALLOC_DMA(dev->totalBytesPerChunk);
+	if (!dev->checkpointBuffer)
+		return 0;
+
+
+	dev->checkpointPageSequence = 0;
+	dev->checkpointByteCount = 0;
+	dev->checkpointSum = 0;
+	dev->checkpointXor = 0;
+	dev->checkpointCurrentBlock = -1;
+	dev->checkpointCurrentChunk = -1;
+	dev->checkpointNextBlock = dev->internalStartBlock;
+
+	/* Erase all the blocks in the checkpoint area */
+	if (forWriting) {
+		memset(dev->checkpointBuffer, 0, dev->nDataBytesPerChunk);
+		dev->checkpointByteOffset = 0;
+		return yaffs_CheckpointErase(dev);
+	} else {
+		int i;
+		/* Set to a value that will kick off a read */
+		dev->checkpointByteOffset = dev->nDataBytesPerChunk;
+		/* A checkpoint block list of 1 checkpoint block per 16 block is (hopefully)
+		 * going to be way more than we need */
+		dev->blocksInCheckpoint = 0;
+		dev->checkpointMaxBlocks = (dev->internalEndBlock - dev->internalStartBlock)/16 + 2;
+		dev->checkpointBlockList = YMALLOC(sizeof(int) * dev->checkpointMaxBlocks);
+		if(!dev->checkpointBlockList)
+			return 0;
+
+		for (i = 0; i < dev->checkpointMaxBlocks; i++)
+			dev->checkpointBlockList[i] = -1;
+	}
+
+	return 1;
+}
+
+int yaffs_GetCheckpointSum(yaffs_Device *dev, __u32 *sum)
+{
+	__u32 compositeSum;
+	compositeSum =  (dev->checkpointSum << 8) | (dev->checkpointXor & 0xFF);
+	*sum = compositeSum;
+	return 1;
+}
+
+static int yaffs_CheckpointFlushBuffer(yaffs_Device *dev)
+{
+	int chunk;
+	int realignedChunk;
+
+	yaffs_ExtendedTags tags;
+
+	if (dev->checkpointCurrentBlock < 0) {
+		yaffs_CheckpointFindNextErasedBlock(dev);
+		dev->checkpointCurrentChunk = 0;
+	}
+
+	if (dev->checkpointCurrentBlock < 0)
+		return 0;
+
+	tags.chunkDeleted = 0;
+	tags.objectId = dev->checkpointNextBlock; /* Hint to next place to look */
+	tags.chunkId = dev->checkpointPageSequence + 1;
+	tags.sequenceNumber =  YAFFS_SEQUENCE_CHECKPOINT_DATA;
+	tags.byteCount = dev->nDataBytesPerChunk;
+	if (dev->checkpointCurrentChunk == 0) {
+		/* First chunk we write for the block? Set block state to
+		   checkpoint */
+		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, dev->checkpointCurrentBlock);
+		bi->blockState = YAFFS_BLOCK_STATE_CHECKPOINT;
+		dev->blocksInCheckpoint++;
+	}
+
+	chunk = dev->checkpointCurrentBlock * dev->nChunksPerBlock + dev->checkpointCurrentChunk;
+
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checkpoint wite buffer nand %d(%d:%d) objid %d chId %d" TENDSTR),
+		chunk, dev->checkpointCurrentBlock, dev->checkpointCurrentChunk, tags.objectId, tags.chunkId));
+
+	realignedChunk = chunk - dev->chunkOffset;
+
+	dev->nPageWrites++;
+
+	dev->writeChunkWithTagsToNAND(dev, realignedChunk,
+			dev->checkpointBuffer, &tags);
+	dev->checkpointByteOffset = 0;
+	dev->checkpointPageSequence++;
+	dev->checkpointCurrentChunk++;
+	if (dev->checkpointCurrentChunk >= dev->nChunksPerBlock) {
+		dev->checkpointCurrentChunk = 0;
+		dev->checkpointCurrentBlock = -1;
+	}
+	memset(dev->checkpointBuffer, 0, dev->nDataBytesPerChunk);
+
+	return 1;
+}
+
+
+int yaffs_CheckpointWrite(yaffs_Device *dev, const void *data, int nBytes)
+{
+	int i = 0;
+	int ok = 1;
+
+
+	__u8 * dataBytes = (__u8 *)data;
+
+
+
+	if (!dev->checkpointBuffer)
+		return 0;
+
+	if (!dev->checkpointOpenForWrite)
+		return -1;
+
+	while (i < nBytes && ok) {
+		dev->checkpointBuffer[dev->checkpointByteOffset] = *dataBytes;
+		dev->checkpointSum += *dataBytes;
+		dev->checkpointXor ^= *dataBytes;
+
+		dev->checkpointByteOffset++;
+		i++;
+		dataBytes++;
+		dev->checkpointByteCount++;
+
+
+		if (dev->checkpointByteOffset < 0 ||
+		   dev->checkpointByteOffset >= dev->nDataBytesPerChunk)
+			ok = yaffs_CheckpointFlushBuffer(dev);
+	}
+
+	return i;
+}
+
+int yaffs_CheckpointRead(yaffs_Device *dev, void *data, int nBytes)
+{
+	int i = 0;
+	int ok = 1;
+	yaffs_ExtendedTags tags;
+
+
+	int chunk;
+	int realignedChunk;
+
+	__u8 *dataBytes = (__u8 *)data;
+
+	if (!dev->checkpointBuffer)
+		return 0;
+
+	if (dev->checkpointOpenForWrite)
+		return -1;
+
+	while (i < nBytes && ok) {
+
+
+		if (dev->checkpointByteOffset < 0 ||
+			dev->checkpointByteOffset >= dev->nDataBytesPerChunk) {
+
+			if (dev->checkpointCurrentBlock < 0) {
+				yaffs_CheckpointFindNextCheckpointBlock(dev);
+				dev->checkpointCurrentChunk = 0;
+			}
+
+			if (dev->checkpointCurrentBlock < 0)
+				ok = 0;
+			else {
+				chunk = dev->checkpointCurrentBlock *
+					dev->nChunksPerBlock +
+					dev->checkpointCurrentChunk;
+
+				realignedChunk = chunk - dev->chunkOffset;
+				
+				dev->nPageReads++;
+
+				/* read in the next chunk */
+				/* printf("read checkpoint page %d\n",dev->checkpointPage); */
+				dev->readChunkWithTagsFromNAND(dev,
+						realignedChunk,
+						dev->checkpointBuffer,
+						&tags);
+
+				if (tags.chunkId != (dev->checkpointPageSequence + 1) ||
+					tags.eccResult > YAFFS_ECC_RESULT_FIXED ||
+					tags.sequenceNumber != YAFFS_SEQUENCE_CHECKPOINT_DATA)
+					ok = 0;
+
+				dev->checkpointByteOffset = 0;
+				dev->checkpointPageSequence++;
+				dev->checkpointCurrentChunk++;
+
+				if (dev->checkpointCurrentChunk >= dev->nChunksPerBlock)
+					dev->checkpointCurrentBlock = -1;
+			}
+		}
+
+		if (ok) {
+			*dataBytes = dev->checkpointBuffer[dev->checkpointByteOffset];
+			dev->checkpointSum += *dataBytes;
+			dev->checkpointXor ^= *dataBytes;
+			dev->checkpointByteOffset++;
+			i++;
+			dataBytes++;
+			dev->checkpointByteCount++;
+		}
+	}
+
+	return 	i;
+}
+
+int yaffs_CheckpointClose(yaffs_Device *dev)
+{
+
+	if (dev->checkpointOpenForWrite) {
+		if (dev->checkpointByteOffset != 0)
+			yaffs_CheckpointFlushBuffer(dev);
+	} else if(dev->checkpointBlockList){
+		int i;
+		for (i = 0; i < dev->blocksInCheckpoint && dev->checkpointBlockList[i] >= 0; i++) {
+			int blk = dev->checkpointBlockList[i];
+			yaffs_BlockInfo *bi = NULL;
+			if( dev->internalStartBlock <= blk && blk <= dev->internalEndBlock)
+				bi = yaffs_GetBlockInfo(dev, blk);
+			if (bi && bi->blockState == YAFFS_BLOCK_STATE_EMPTY)
+				bi->blockState = YAFFS_BLOCK_STATE_CHECKPOINT;
+			else {
+				/* Todo this looks odd... */
+			}
+		}
+		YFREE(dev->checkpointBlockList);
+		dev->checkpointBlockList = NULL;
+	}
+
+	dev->nFreeChunks -= dev->blocksInCheckpoint * dev->nChunksPerBlock;
+	dev->nErasedBlocks -= dev->blocksInCheckpoint;
+
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checkpoint byte count %d" TENDSTR),
+			dev->checkpointByteCount));
+
+	if (dev->checkpointBuffer) {
+		/* free the buffer */
+		YFREE(dev->checkpointBuffer);
+		dev->checkpointBuffer = NULL;
+		return 1;
+	} else
+		return 0;
+}
+
+int yaffs_CheckpointInvalidateStream(yaffs_Device *dev)
+{
+	/* Erase the checkpoint data */
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checkpoint invalidate of %d blocks"TENDSTR),
+		dev->blocksInCheckpoint));
+
+	return yaffs_CheckpointErase(dev);
+}
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_checkptrw.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_checkptrw.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_checkptrw.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_checkptrw.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,35 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_CHECKPTRW_H__
+#define __YAFFS_CHECKPTRW_H__
+
+#include "yaffs_guts.h"
+
+int yaffs_CheckpointOpen(yaffs_Device *dev, int forWriting);
+
+int yaffs_CheckpointWrite(yaffs_Device *dev, const void *data, int nBytes);
+
+int yaffs_CheckpointRead(yaffs_Device *dev, void *data, int nBytes);
+
+int yaffs_GetCheckpointSum(yaffs_Device *dev, __u32 *sum);
+
+int yaffs_CheckpointClose(yaffs_Device *dev);
+
+int yaffs_CheckpointInvalidateStream(yaffs_Device *dev);
+
+
+#endif
+
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_ecc.c iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_ecc.c
--- linux-2.6.32-orig/fs/yaffs2/yaffs_ecc.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_ecc.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,326 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This code implements the ECC algorithm used in SmartMedia.
+ *
+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+ * The two unused bit are set to 1.
+ * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC
+ * blocks are used on a 512-byte NAND page.
+ *
+ */
+
+/* Table generated by gen-ecc.c
+ * Using a table means we do not have to calculate p1..p4 and p1'..p4'
+ * for each byte of data. These are instead provided in a table in bits7..2.
+ * Bit 0 of each entry indicates whether the entry has an odd or even parity, and therefore
+ * this bytes influence on the line parity.
+ */
+
+const char *yaffs_ecc_c_version =
+	"$Id$";
+
+#include "yportenv.h"
+
+#include "yaffs_ecc.h"
+
+static const unsigned char column_parity_table[] = {
+	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+};
+
+/* Count the bits in an unsigned char or a U32 */
+
+static int yaffs_CountBits(unsigned char x)
+{
+	int r = 0;
+	while (x) {
+		if (x & 1)
+			r++;
+		x >>= 1;
+	}
+	return r;
+}
+
+static int yaffs_CountBits32(unsigned x)
+{
+	int r = 0;
+	while (x) {
+		if (x & 1)
+			r++;
+		x >>= 1;
+	}
+	return r;
+}
+
+/* Calculate the ECC for a 256-byte block of data */
+void yaffs_ECCCalculate(const unsigned char *data, unsigned char *ecc)
+{
+	unsigned int i;
+
+	unsigned char col_parity = 0;
+	unsigned char line_parity = 0;
+	unsigned char line_parity_prime = 0;
+	unsigned char t;
+	unsigned char b;
+
+	for (i = 0; i < 256; i++) {
+		b = column_parity_table[*data++];
+		col_parity ^= b;
+
+		if (b & 0x01) {		/* odd number of bits in the byte */
+			line_parity ^= i;
+			line_parity_prime ^= ~i;
+		}
+	}
+
+	ecc[2] = (~col_parity) | 0x03;
+
+	t = 0;
+	if (line_parity & 0x80)
+		t |= 0x80;
+	if (line_parity_prime & 0x80)
+		t |= 0x40;
+	if (line_parity & 0x40)
+		t |= 0x20;
+	if (line_parity_prime & 0x40)
+		t |= 0x10;
+	if (line_parity & 0x20)
+		t |= 0x08;
+	if (line_parity_prime & 0x20)
+		t |= 0x04;
+	if (line_parity & 0x10)
+		t |= 0x02;
+	if (line_parity_prime & 0x10)
+		t |= 0x01;
+	ecc[1] = ~t;
+
+	t = 0;
+	if (line_parity & 0x08)
+		t |= 0x80;
+	if (line_parity_prime & 0x08)
+		t |= 0x40;
+	if (line_parity & 0x04)
+		t |= 0x20;
+	if (line_parity_prime & 0x04)
+		t |= 0x10;
+	if (line_parity & 0x02)
+		t |= 0x08;
+	if (line_parity_prime & 0x02)
+		t |= 0x04;
+	if (line_parity & 0x01)
+		t |= 0x02;
+	if (line_parity_prime & 0x01)
+		t |= 0x01;
+	ecc[0] = ~t;
+
+#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER
+	/* Swap the bytes into the wrong order */
+	t = ecc[0];
+	ecc[0] = ecc[1];
+	ecc[1] = t;
+#endif
+}
+
+
+/* Correct the ECC on a 256 byte block of data */
+
+int yaffs_ECCCorrect(unsigned char *data, unsigned char *read_ecc,
+		     const unsigned char *test_ecc)
+{
+	unsigned char d0, d1, d2;	/* deltas */
+
+	d0 = read_ecc[0] ^ test_ecc[0];
+	d1 = read_ecc[1] ^ test_ecc[1];
+	d2 = read_ecc[2] ^ test_ecc[2];
+
+	if ((d0 | d1 | d2) == 0)
+		return 0; /* no error */
+
+	if (((d0 ^ (d0 >> 1)) & 0x55) == 0x55 &&
+	    ((d1 ^ (d1 >> 1)) & 0x55) == 0x55 &&
+	    ((d2 ^ (d2 >> 1)) & 0x54) == 0x54) {
+		/* Single bit (recoverable) error in data */
+
+		unsigned byte;
+		unsigned bit;
+
+#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER
+		/* swap the bytes to correct for the wrong order */
+		unsigned char t;
+
+		t = d0;
+		d0 = d1;
+		d1 = t;
+#endif
+
+		bit = byte = 0;
+
+		if (d1 & 0x80)
+			byte |= 0x80;
+		if (d1 & 0x20)
+			byte |= 0x40;
+		if (d1 & 0x08)
+			byte |= 0x20;
+		if (d1 & 0x02)
+			byte |= 0x10;
+		if (d0 & 0x80)
+			byte |= 0x08;
+		if (d0 & 0x20)
+			byte |= 0x04;
+		if (d0 & 0x08)
+			byte |= 0x02;
+		if (d0 & 0x02)
+			byte |= 0x01;
+
+		if (d2 & 0x80)
+			bit |= 0x04;
+		if (d2 & 0x20)
+			bit |= 0x02;
+		if (d2 & 0x08)
+			bit |= 0x01;
+
+		data[byte] ^= (1 << bit);
+
+		return 1; /* Corrected the error */
+	}
+
+	if ((yaffs_CountBits(d0) +
+	     yaffs_CountBits(d1) +
+	     yaffs_CountBits(d2)) ==  1) {
+		/* Reccoverable error in ecc */
+
+		read_ecc[0] = test_ecc[0];
+		read_ecc[1] = test_ecc[1];
+		read_ecc[2] = test_ecc[2];
+
+		return 1; /* Corrected the error */
+	}
+
+	/* Unrecoverable error */
+
+	return -1;
+
+}
+
+
+/*
+ * ECCxxxOther does ECC calcs on arbitrary n bytes of data
+ */
+void yaffs_ECCCalculateOther(const unsigned char *data, unsigned nBytes,
+				yaffs_ECCOther *eccOther)
+{
+	unsigned int i;
+
+	unsigned char col_parity = 0;
+	unsigned line_parity = 0;
+	unsigned line_parity_prime = 0;
+	unsigned char b;
+
+	for (i = 0; i < nBytes; i++) {
+		b = column_parity_table[*data++];
+		col_parity ^= b;
+
+		if (b & 0x01)	 {
+			/* odd number of bits in the byte */
+			line_parity ^= i;
+			line_parity_prime ^= ~i;
+		}
+
+	}
+
+	eccOther->colParity = (col_parity >> 2) & 0x3f;
+	eccOther->lineParity = line_parity;
+	eccOther->lineParityPrime = line_parity_prime;
+}
+
+int yaffs_ECCCorrectOther(unsigned char *data, unsigned nBytes,
+			yaffs_ECCOther *read_ecc,
+			const yaffs_ECCOther *test_ecc)
+{
+	unsigned char cDelta;	/* column parity delta */
+	unsigned lDelta;	/* line parity delta */
+	unsigned lDeltaPrime;	/* line parity delta */
+	unsigned bit;
+
+	cDelta = read_ecc->colParity ^ test_ecc->colParity;
+	lDelta = read_ecc->lineParity ^ test_ecc->lineParity;
+	lDeltaPrime = read_ecc->lineParityPrime ^ test_ecc->lineParityPrime;
+
+	if ((cDelta | lDelta | lDeltaPrime) == 0)
+		return 0; /* no error */
+
+	if (lDelta == ~lDeltaPrime &&
+	    (((cDelta ^ (cDelta >> 1)) & 0x15) == 0x15)) {
+		/* Single bit (recoverable) error in data */
+
+		bit = 0;
+
+		if (cDelta & 0x20)
+			bit |= 0x04;
+		if (cDelta & 0x08)
+			bit |= 0x02;
+		if (cDelta & 0x02)
+			bit |= 0x01;
+
+		if (lDelta >= nBytes)
+			return -1;
+
+		data[lDelta] ^= (1 << bit);
+
+		return 1; /* corrected */
+	}
+
+	if ((yaffs_CountBits32(lDelta) + yaffs_CountBits32(lDeltaPrime) +
+			yaffs_CountBits(cDelta)) == 1) {
+		/* Reccoverable error in ecc */
+
+		*read_ecc = *test_ecc;
+		return 1; /* corrected */
+	}
+
+	/* Unrecoverable error */
+
+	return -1;
+}
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_ecc.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_ecc.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_ecc.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_ecc.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,44 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * This code implements the ECC algorithm used in SmartMedia.
+ *
+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+ * The two unused bit are set to 1.
+ * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC
+ * blocks are used on a 512-byte NAND page.
+ *
+ */
+
+#ifndef __YAFFS_ECC_H__
+#define __YAFFS_ECC_H__
+
+typedef struct {
+	unsigned char colParity;
+	unsigned lineParity;
+	unsigned lineParityPrime;
+} yaffs_ECCOther;
+
+void yaffs_ECCCalculate(const unsigned char *data, unsigned char *ecc);
+int yaffs_ECCCorrect(unsigned char *data, unsigned char *read_ecc,
+		const unsigned char *test_ecc);
+
+void yaffs_ECCCalculateOther(const unsigned char *data, unsigned nBytes,
+			yaffs_ECCOther *ecc);
+int yaffs_ECCCorrectOther(unsigned char *data, unsigned nBytes,
+			yaffs_ECCOther *read_ecc,
+			const yaffs_ECCOther *test_ecc);
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_fs.c iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_fs.c
--- linux-2.6.32-orig/fs/yaffs2/yaffs_fs.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_fs.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,2699 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2009 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ * Acknowledgements:
+ * Luc van OostenRyck for numerous patches.
+ * Nick Bane for numerous patches.
+ * Nick Bane for 2.5/2.6 integration.
+ * Andras Toth for mknod rdev issue.
+ * Michael Fischer for finding the problem with inode inconsistency.
+ * Some code bodily lifted from JFFS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ *
+ * This is the file system front-end to YAFFS that hooks it up to
+ * the VFS.
+ *
+ * Special notes:
+ * >> 2.4: sb->u.generic_sbp points to the yaffs_Device associated with
+ *         this superblock
+ * >> 2.6: sb->s_fs_info  points to the yaffs_Device associated with this
+ *         superblock
+ * >> inode->u.generic_ip points to the associated yaffs_Object.
+ */
+
+const char *yaffs_fs_c_version =
+    "$Id$";
+extern const char *yaffs_guts_c_version;
+
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/pagemap.h>
+#include <linux/mtd/mtd.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+
+#include "asm/div64.h"
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+#include <linux/statfs.h>	/* Added NCB 15-8-2003 */
+#include <linux/statfs.h>
+#define UnlockPage(p) unlock_page(p)
+#define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
+
+/* FIXME: use sb->s_id instead ? */
+#define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
+
+#else
+
+#include <linux/locks.h>
+#define	BDEVNAME_SIZE		0
+#define	yaffs_devname(sb, buf)	kdevname(sb->s_dev)
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0))
+/* added NCB 26/5/2006 for 2.4.25-vrs2-tcl1 kernel */
+#define __user
+#endif
+
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define YPROC_ROOT  (&proc_root)
+#else
+#define YPROC_ROOT  NULL
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+#define WRITE_SIZE_STR "writesize"
+#define WRITE_SIZE(mtd) ((mtd)->writesize)
+#else
+#define WRITE_SIZE_STR "oobblock"
+#define WRITE_SIZE(mtd) ((mtd)->oobblock)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+#define YAFFS_USE_WRITE_BEGIN_END 1
+#else
+#define YAFFS_USE_WRITE_BEGIN_END 0
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 28))
+static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+{
+	uint64_t result = partition_size;
+	do_div(result, block_size);
+	return (uint32_t)result;
+}
+#else
+#define YCALCBLOCKS(s, b) ((s)/(b))
+#endif
+
+#include <linux/uaccess.h>
+
+#include "yportenv.h"
+#include "yaffs_guts.h"
+
+#include <linux/mtd/mtd.h>
+#include "yaffs_mtdif.h"
+#include "yaffs_mtdif1.h"
+#include "yaffs_mtdif2.h"
+
+unsigned int yaffs_traceMask = YAFFS_TRACE_BAD_BLOCKS;
+unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;
+unsigned int yaffs_auto_checkpoint = 1;
+
+/* Module Parameters */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+module_param(yaffs_traceMask, uint, 0644);
+module_param(yaffs_wr_attempts, uint, 0644);
+module_param(yaffs_auto_checkpoint, uint, 0644);
+#else
+MODULE_PARM(yaffs_traceMask, "i");
+MODULE_PARM(yaffs_wr_attempts, "i");
+MODULE_PARM(yaffs_auto_checkpoint, "i");
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+/* use iget and read_inode */
+#define Y_IGET(sb, inum) iget((sb), (inum))
+static void yaffs_read_inode(struct inode *inode);
+
+#else
+/* Call local equivalent */
+#define YAFFS_USE_OWN_IGET
+#define Y_IGET(sb, inum) yaffs_iget((sb), (inum))
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino);
+#endif
+
+/*#define T(x) printk x */
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+#define yaffs_InodeToObjectLV(iptr) ((iptr)->i_private)
+#else
+#define yaffs_InodeToObjectLV(iptr) ((iptr)->u.generic_ip)
+#endif
+
+#define yaffs_InodeToObject(iptr) ((yaffs_Object *)(yaffs_InodeToObjectLV(iptr)))
+#define yaffs_DentryToObject(dptr) yaffs_InodeToObject((dptr)->d_inode)
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define yaffs_SuperToDevice(sb)	((yaffs_Device *)sb->s_fs_info)
+#else
+#define yaffs_SuperToDevice(sb)	((yaffs_Device *)sb->u.generic_sbp)
+#endif
+
+
+#define update_dir_time(dir) do {\
+			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
+		} while(0)
+		
+static void yaffs_put_super(struct super_block *sb);
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t *pos);
+static ssize_t yaffs_hold_space(struct file *f);
+static void yaffs_release_space(struct file *f);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id);
+#else
+static int yaffs_file_flush(struct file *file);
+#endif
+
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+				int datasync);
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+					struct nameidata *n);
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry);
+#endif
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+			struct dentry *dentry);
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry);
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			const char *symname);
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			dev_t dev);
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			int dev);
+#endif
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry);
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait);
+static void yaffs_write_super(struct super_block *sb);
+#else
+static int yaffs_sync_fs(struct super_block *sb);
+static int yaffs_write_super(struct super_block *sb);
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf);
+#endif
+
+#ifdef YAFFS_HAS_PUT_INODE
+static void yaffs_put_inode(struct inode *inode);
+#endif
+
+static void yaffs_delete_inode(struct inode *);
+static void yaffs_clear_inode(struct inode *);
+
+static int yaffs_readpage(struct file *file, struct page *page);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc);
+#else
+static int yaffs_writepage(struct page *page);
+#endif
+
+
+#if (YAFFS_USE_WRITE_BEGIN_END != 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned flags,
+				struct page **pagep, void **fsdata);
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned copied,
+				struct page *pg, void *fsdadata);
+#else
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+				unsigned offset, unsigned to);
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+				unsigned to);
+
+#endif
+
+static int yaffs_readlink(struct dentry *dentry, char __user *buffer,
+				int buflen);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#endif
+
+static struct address_space_operations yaffs_file_address_operations = {
+	.readpage = yaffs_readpage,
+	.writepage = yaffs_writepage,
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+#else
+	.prepare_write = yaffs_prepare_write,
+	.commit_write = yaffs_commit_write,
+#endif
+};
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.splice_read = generic_file_splice_read,
+	.splice_write = generic_file_splice_write,
+	.llseek = generic_file_llseek,
+};
+
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.sendfile = generic_file_sendfile,
+};
+
+#else
+
+static const struct file_operations yaffs_file_operations = {
+	.read = generic_file_read,
+	.write = generic_file_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	.sendfile = generic_file_sendfile,
+#endif
+};
+#endif
+
+static const struct inode_operations yaffs_file_inode_operations = {
+	.setattr = yaffs_setattr,
+};
+
+static const struct inode_operations yaffs_symlink_inode_operations = {
+	.readlink = yaffs_readlink,
+	.follow_link = yaffs_follow_link,
+	.setattr = yaffs_setattr,
+};
+
+static const struct inode_operations yaffs_dir_inode_operations = {
+	.create = yaffs_create,
+	.lookup = yaffs_lookup,
+	.link = yaffs_link,
+	.unlink = yaffs_unlink,
+	.symlink = yaffs_symlink,
+	.mkdir = yaffs_mkdir,
+	.rmdir = yaffs_unlink,
+	.mknod = yaffs_mknod,
+	.rename = yaffs_rename,
+	.setattr = yaffs_setattr,
+};
+
+static const struct file_operations yaffs_dir_operations = {
+	.read = generic_read_dir,
+	.readdir = yaffs_readdir,
+	.fsync = yaffs_sync_object,
+};
+
+static const struct super_operations yaffs_super_ops = {
+	.statfs = yaffs_statfs,
+
+#ifndef YAFFS_USE_OWN_IGET
+	.read_inode = yaffs_read_inode,
+#endif
+#ifdef YAFFS_HAS_PUT_INODE
+	.put_inode = yaffs_put_inode,
+#endif
+	.put_super = yaffs_put_super,
+	.delete_inode = yaffs_delete_inode,
+	.clear_inode = yaffs_clear_inode,
+	.sync_fs = yaffs_sync_fs,
+	.write_super = yaffs_write_super,
+};
+
+static void yaffs_GrossLock(yaffs_Device *dev)
+{
+	T(YAFFS_TRACE_OS, ("yaffs locking %p\n", current));
+	down(&dev->grossLock);
+	T(YAFFS_TRACE_OS, ("yaffs locked %p\n", current));
+}
+
+static void yaffs_GrossUnlock(yaffs_Device *dev)
+{
+	T(YAFFS_TRACE_OS, ("yaffs unlocking %p\n", current));
+	up(&dev->grossLock);
+}
+
+
+/*-----------------------------------------------------------------*/
+/* Directory search context allows us to unlock access to yaffs during
+ * filldir without causing problems with the directory being modified.
+ * This is similar to the tried and tested mechanism used in yaffs direct.
+ *
+ * A search context iterates along a doubly linked list of siblings in the
+ * directory. If the iterating object is deleted then this would corrupt
+ * the list iteration, likely causing a crash. The search context avoids
+ * this by using the removeObjectCallback to move the search context to the
+ * next object before the object is deleted.
+ *
+ * Many readdirs (and thus seach conexts) may be alive simulateously so
+ * each yaffs_Device has a list of these.
+ *
+ * A seach context lives for the duration of a readdir.
+ *
+ * All these functions must be called while yaffs is locked.
+ */
+
+struct yaffs_SearchContext {
+	yaffs_Device *dev;
+	yaffs_Object *dirObj;
+	yaffs_Object *nextReturn;
+	struct ylist_head others;
+};
+
+/*
+ * yaffs_NewSearch() creates a new search context, initialises it and
+ * adds it to the device's search context list.
+ *
+ * Called at start of readdir.
+ */
+static struct yaffs_SearchContext * yaffs_NewSearch(yaffs_Object *dir)
+{
+	yaffs_Device *dev = dir->myDev;
+	struct yaffs_SearchContext *sc = YMALLOC(sizeof(struct yaffs_SearchContext));
+	if(sc){
+		sc->dirObj = dir;
+		sc->dev = dev;
+		if( ylist_empty(&sc->dirObj->variant.directoryVariant.children))
+			sc->nextReturn = NULL;
+		else
+			sc->nextReturn = ylist_entry(
+                                dir->variant.directoryVariant.children.next,
+				yaffs_Object,siblings);
+		YINIT_LIST_HEAD(&sc->others);
+		ylist_add(&sc->others,&dev->searchContexts);
+	}
+	return sc;
+}
+
+/*
+ * yaffs_EndSearch() disposes of a search context and cleans up.
+ */
+static void yaffs_EndSearch(struct yaffs_SearchContext * sc)
+{
+	if(sc){
+		ylist_del(&sc->others);
+		YFREE(sc);
+	}
+}
+
+/*
+ * yaffs_SearchAdvance() moves a search context to the next object.
+ * Called when the search iterates or when an object removal causes
+ * the search context to be moved to the next object.
+ */
+static void yaffs_SearchAdvance(struct yaffs_SearchContext *sc)
+{
+        if(!sc)
+                return;
+
+        if( sc->nextReturn == NULL ||
+                ylist_empty(&sc->dirObj->variant.directoryVariant.children))
+                sc->nextReturn = NULL;
+        else {
+                struct ylist_head *next = sc->nextReturn->siblings.next;
+
+                if( next == &sc->dirObj->variant.directoryVariant.children)
+                        sc->nextReturn = NULL; /* end of list */
+                else
+                        sc->nextReturn = ylist_entry(next,yaffs_Object,siblings);
+        }
+}
+
+/*
+ * yaffs_RemoveObjectCallback() is called when an object is unlinked.
+ * We check open search contexts and advance any which are currently
+ * on the object being iterated.
+ */
+static void yaffs_RemoveObjectCallback(yaffs_Object *obj)
+{
+
+        struct ylist_head *i;
+        struct yaffs_SearchContext *sc;
+        struct ylist_head *search_contexts = &obj->myDev->searchContexts;
+
+
+        /* Iterate through the directory search contexts.
+         * If any are currently on the object being removed, then advance
+         * the search context to the next object to prevent a hanging pointer.
+         */
+         ylist_for_each(i, search_contexts) {
+                if (i) {
+                        sc = ylist_entry(i, struct yaffs_SearchContext,others);
+                        if(sc->nextReturn == obj)
+                                yaffs_SearchAdvance(sc);
+                }
+	}
+
+}
+
+
+/*-----------------------------------------------------------------*/
+
+static int yaffs_readlink(struct dentry *dentry, char __user *buffer,
+			int buflen)
+{
+	unsigned char *alias;
+	int ret;
+
+	yaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;
+
+	yaffs_GrossLock(dev);
+
+	alias = yaffs_GetSymlinkAlias(yaffs_DentryToObject(dentry));
+
+	yaffs_GrossUnlock(dev);
+
+	if (!alias)
+		return -ENOMEM;
+
+	ret = vfs_readlink(dentry, buffer, buflen, alias);
+	kfree(alias);
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+#endif
+{
+	unsigned char *alias;
+	int ret;
+	yaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;
+
+	yaffs_GrossLock(dev);
+
+	alias = yaffs_GetSymlinkAlias(yaffs_DentryToObject(dentry));
+
+	yaffs_GrossUnlock(dev);
+
+	if (!alias) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = vfs_follow_link(nd, alias);
+	kfree(alias);
+out:
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+	return ERR_PTR(ret);
+#else
+	return ret;
+#endif
+}
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+				yaffs_Object *obj);
+
+/*
+ * Lookup is used to find objects in the fs
+ */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				struct nameidata *n)
+#else
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
+#endif
+{
+	yaffs_Object *obj;
+	struct inode *inode = NULL;	/* NCB 2.5/2.6 needs NULL here */
+
+	yaffs_Device *dev = yaffs_InodeToObject(dir)->myDev;
+
+	yaffs_GrossLock(dev);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_lookup for %d:%s\n",
+		yaffs_InodeToObject(dir)->objectId, dentry->d_name.name));
+
+	obj = yaffs_FindObjectByName(yaffs_InodeToObject(dir),
+					dentry->d_name.name);
+
+	obj = yaffs_GetEquivalentObject(obj);	/* in case it was a hardlink */
+
+	/* Can't hold gross lock when calling yaffs_get_inode() */
+	yaffs_GrossUnlock(dev);
+
+	if (obj) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_lookup found %d\n", obj->objectId));
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+
+		if (inode) {
+			T(YAFFS_TRACE_OS,
+				("yaffs_loookup dentry \n"));
+/* #if 0 asserted by NCB for 2.5/6 compatability - falls through to
+ * d_add even if NULL inode */
+#if 0
+			/*dget(dentry); // try to solve directory bug */
+			d_add(dentry, inode);
+
+			/* return dentry; */
+			return NULL;
+#endif
+		}
+
+	} else {
+		T(YAFFS_TRACE_OS, ("yaffs_lookup not found\n"));
+
+	}
+
+/* added NCB for 2.5/6 compatability - forces add even if inode is
+ * NULL which creates dentry hash */
+	d_add(dentry, inode);
+
+	return NULL;
+}
+
+
+#ifdef YAFFS_HAS_PUT_INODE
+
+/* For now put inode is just for debugging
+ * Put inode is called when the inode **structure** is put.
+ */
+static void yaffs_put_inode(struct inode *inode)
+{
+	T(YAFFS_TRACE_OS,
+		("yaffs_put_inode: ino %d, count %d\n", (int)inode->i_ino,
+		atomic_read(&inode->i_count)));
+
+}
+#endif
+
+/* clear is called to tell the fs to release any per-inode data it holds */
+static void yaffs_clear_inode(struct inode *inode)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+
+	obj = yaffs_InodeToObject(inode);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_clear_inode: ino %d, count %d %s\n", (int)inode->i_ino,
+		atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object"));
+
+	if (obj) {
+		dev = obj->myDev;
+		yaffs_GrossLock(dev);
+
+		/* Clear the association between the inode and
+		 * the yaffs_Object.
+		 */
+		obj->myInode = NULL;
+		yaffs_InodeToObjectLV(inode) = NULL;
+
+		/* If the object freeing was deferred, then the real
+		 * free happens now.
+		 * This should fix the inode inconsistency problem.
+		 */
+
+		yaffs_HandleDeferedFree(obj);
+
+		yaffs_GrossUnlock(dev);
+	}
+
+}
+
+/* delete is called when the link count is zero and the inode
+ * is put (ie. nobody wants to know about it anymore, time to
+ * delete the file).
+ * NB Must call clear_inode()
+ */
+static void yaffs_delete_inode(struct inode *inode)
+{
+	yaffs_Object *obj = yaffs_InodeToObject(inode);
+	yaffs_Device *dev;
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_delete_inode: ino %d, count %d %s\n", (int)inode->i_ino,
+		atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object"));
+
+	if (obj) {
+		dev = obj->myDev;
+		yaffs_GrossLock(dev);
+		yaffs_DeleteObject(obj);
+		yaffs_GrossUnlock(dev);
+	}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+	truncate_inode_pages(&inode->i_data, 0);
+#endif
+	clear_inode(inode);
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id)
+#else
+static int yaffs_file_flush(struct file *file)
+#endif
+{
+	yaffs_Object *obj = yaffs_DentryToObject(file->f_dentry);
+
+	yaffs_Device *dev = obj->myDev;
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_file_flush object %d (%s)\n", obj->objectId,
+		obj->dirty ? "dirty" : "clean"));
+
+	yaffs_GrossLock(dev);
+
+	yaffs_FlushFile(obj, 1);
+
+	yaffs_GrossUnlock(dev);
+
+	return 0;
+}
+
+static int yaffs_readpage_nolock(struct file *f, struct page *pg)
+{
+	/* Lifted from jffs2 */
+
+	yaffs_Object *obj;
+	unsigned char *pg_buf;
+	int ret;
+
+	yaffs_Device *dev;
+
+	T(YAFFS_TRACE_OS, ("yaffs_readpage at %08x, size %08x\n",
+			(unsigned)(pg->index << PAGE_CACHE_SHIFT),
+			(unsigned)PAGE_CACHE_SIZE));
+
+	obj = yaffs_DentryToObject(f->f_dentry);
+
+	dev = obj->myDev;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	BUG_ON(!PageLocked(pg));
+#else
+	if (!PageLocked(pg))
+		PAGE_BUG(pg);
+#endif
+
+	pg_buf = kmap(pg);
+	/* FIXME: Can kmap fail? */
+
+	yaffs_GrossLock(dev);
+
+	ret = yaffs_ReadDataFromFile(obj, pg_buf,
+				pg->index << PAGE_CACHE_SHIFT,
+				PAGE_CACHE_SIZE);
+
+	yaffs_GrossUnlock(dev);
+
+	if (ret >= 0)
+		ret = 0;
+
+	if (ret) {
+		ClearPageUptodate(pg);
+		SetPageError(pg);
+	} else {
+		SetPageUptodate(pg);
+		ClearPageError(pg);
+	}
+
+	flush_dcache_page(pg);
+	kunmap(pg);
+
+	T(YAFFS_TRACE_OS, ("yaffs_readpage done\n"));
+	return ret;
+}
+
+static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+{
+	int ret = yaffs_readpage_nolock(f, pg);
+	UnlockPage(pg);
+	return ret;
+}
+
+static int yaffs_readpage(struct file *f, struct page *pg)
+{
+	return yaffs_readpage_unlock(f, pg);
+}
+
+/* writepage inspired by/stolen from smbfs */
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+#else
+static int yaffs_writepage(struct page *page)
+#endif
+{
+	struct address_space *mapping = page->mapping;
+	loff_t offset = (loff_t) page->index << PAGE_CACHE_SHIFT;
+	struct inode *inode;
+	unsigned long end_index;
+	char *buffer;
+	yaffs_Object *obj;
+	int nWritten = 0;
+	unsigned nBytes;
+
+	if (!mapping)
+		BUG();
+	inode = mapping->host;
+	if (!inode)
+		BUG();
+
+	if (offset > inode->i_size) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_writepage at %08x, inode size = %08x!!!\n",
+			(unsigned)(page->index << PAGE_CACHE_SHIFT),
+			(unsigned)inode->i_size));
+		T(YAFFS_TRACE_OS,
+			("                -> don't care!!\n"));
+		unlock_page(page);
+		return 0;
+	}
+
+	end_index = inode->i_size >> PAGE_CACHE_SHIFT;
+
+	/* easy case */
+	if (page->index < end_index)
+		nBytes = PAGE_CACHE_SIZE;
+	else
+		nBytes = inode->i_size & (PAGE_CACHE_SIZE - 1);
+
+	get_page(page);
+
+	buffer = kmap(page);
+
+	obj = yaffs_InodeToObject(inode);
+	yaffs_GrossLock(obj->myDev);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_writepage at %08x, size %08x\n",
+		(unsigned)(page->index << PAGE_CACHE_SHIFT), nBytes));
+	T(YAFFS_TRACE_OS,
+		("writepag0: obj = %05x, ino = %05x\n",
+		(int)obj->variant.fileVariant.fileSize, (int)inode->i_size));
+
+	nWritten = yaffs_WriteDataToFile(obj, buffer,
+			page->index << PAGE_CACHE_SHIFT, nBytes, 0);
+
+	T(YAFFS_TRACE_OS,
+		("writepag1: obj = %05x, ino = %05x\n",
+		(int)obj->variant.fileVariant.fileSize, (int)inode->i_size));
+
+	yaffs_GrossUnlock(obj->myDev);
+
+	kunmap(page);
+	SetPageUptodate(page);
+	UnlockPage(page);
+	put_page(page);
+
+	return (nWritten == nBytes) ? 0 : -ENOSPC;
+}
+
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned flags,
+				struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+	uint32_t offset = pos & (PAGE_CACHE_SIZE - 1);
+	uint32_t to = offset + len;
+
+	int ret = 0;
+	int space_held = 0;
+
+	T(YAFFS_TRACE_OS, ("start yaffs_write_begin\n"));
+	/* Get a page */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 28)
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+#else
+	pg = __grab_cache_page(mapping, index);
+#endif
+
+	*pagep = pg;
+	if (!pg) {
+		ret =  -ENOMEM;
+		goto out;
+	}
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
+
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
+	}
+
+	/* Update page if required */
+
+	if (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))
+		ret = yaffs_readpage_nolock(filp, pg);
+
+	if (ret)
+		goto out;
+
+	/* Happy path return */
+	T(YAFFS_TRACE_OS, ("end yaffs_write_begin - ok\n"));
+
+	return 0;
+
+out:
+	T(YAFFS_TRACE_OS, ("end yaffs_write_begin fail returning %d\n", ret));
+	if (space_held)
+		yaffs_release_space(filp);
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+#else
+
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+				unsigned offset, unsigned to)
+{
+	T(YAFFS_TRACE_OS, ("yaffs_prepair_write\n"));
+
+	if (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))
+		return yaffs_readpage_nolock(f, pg);
+	return 0;
+}
+#endif
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned copied,
+				struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_write_end addr %x pos %x nBytes %d\n",
+		(unsigned) addr,
+		(int)pos, copied));
+
+	ret = yaffs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_write_end not same size ret %d  copied %d\n",
+			ret, copied));
+		SetPageError(pg);
+		ClearPageUptodate(pg);
+	} else {
+		SetPageUptodate(pg);
+	}
+
+	kunmap(pg);
+
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
+
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+				unsigned to)
+{
+	void *addr, *kva;
+
+	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
+	int nBytes = to - offset;
+	int nWritten;
+
+	unsigned spos = pos;
+	unsigned saddr;
+
+	kva = kmap(pg);
+	addr = kva + offset;
+
+	saddr = (unsigned) addr;
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_commit_write addr %x pos %x nBytes %d\n",
+		saddr, spos, nBytes));
+
+	nWritten = yaffs_file_write(f, addr, nBytes, &pos);
+
+	if (nWritten != nBytes) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_commit_write not same size nWritten %d  nBytes %d\n",
+			nWritten, nBytes));
+		SetPageError(pg);
+		ClearPageUptodate(pg);
+	} else {
+		SetPageUptodate(pg);
+	}
+
+	kunmap(pg);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_commit_write returning %d\n",
+		nWritten == nBytes ? 0 : nWritten));
+
+	return nWritten == nBytes ? 0 : nWritten;
+}
+#endif
+
+
+static void yaffs_FillInodeFromObject(struct inode *inode, yaffs_Object *obj)
+{
+	if (inode && obj) {
+
+
+		/* Check mode against the variant type and attempt to repair if broken. */
+		__u32 mode = obj->yst_mode;
+		switch (obj->variantType) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			if (!S_ISREG(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFREG;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			if (!S_ISLNK(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFLNK;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			if (!S_ISDIR(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFDIR;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+		default:
+			/* TODO? */
+			break;
+		}
+
+		inode->i_flags |= S_NOATIME;
+
+		inode->i_ino = obj->objectId;
+		inode->i_mode = obj->yst_mode;
+		inode->i_uid = obj->yst_uid;
+		inode->i_gid = obj->yst_gid;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+		inode->i_blksize = inode->i_sb->s_blocksize;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+		inode->i_rdev = old_decode_dev(obj->yst_rdev);
+		inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
+		inode->i_atime.tv_nsec = 0;
+		inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
+		inode->i_mtime.tv_nsec = 0;
+		inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
+		inode->i_ctime.tv_nsec = 0;
+#else
+		inode->i_rdev = obj->yst_rdev;
+		inode->i_atime = obj->yst_atime;
+		inode->i_mtime = obj->yst_mtime;
+		inode->i_ctime = obj->yst_ctime;
+#endif
+		inode->i_size = yaffs_GetObjectFileLength(obj);
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+
+		inode->i_nlink = yaffs_GetObjectLinkCount(obj);
+
+		T(YAFFS_TRACE_OS,
+			("yaffs_FillInode mode %x uid %d gid %d size %d count %d\n",
+			inode->i_mode, inode->i_uid, inode->i_gid,
+			(int)inode->i_size, atomic_read(&inode->i_count)));
+
+		switch (obj->yst_mode & S_IFMT) {
+		default:	/* fifo, device or socket */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+			init_special_inode(inode, obj->yst_mode,
+					old_decode_dev(obj->yst_rdev));
+#else
+			init_special_inode(inode, obj->yst_mode,
+					(dev_t) (obj->yst_rdev));
+#endif
+			break;
+		case S_IFREG:	/* file */
+			inode->i_op = &yaffs_file_inode_operations;
+			inode->i_fop = &yaffs_file_operations;
+			inode->i_mapping->a_ops =
+				&yaffs_file_address_operations;
+			break;
+		case S_IFDIR:	/* directory */
+			inode->i_op = &yaffs_dir_inode_operations;
+			inode->i_fop = &yaffs_dir_operations;
+			break;
+		case S_IFLNK:	/* symlink */
+			inode->i_op = &yaffs_symlink_inode_operations;
+			break;
+		}
+
+		yaffs_InodeToObjectLV(inode) = obj;
+
+		obj->myInode = inode;
+
+	} else {
+		T(YAFFS_TRACE_OS,
+			("yaffs_FileInode invalid parameters\n"));
+	}
+
+}
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+				yaffs_Object *obj)
+{
+	struct inode *inode;
+
+	if (!sb) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_get_inode for NULL super_block!!\n"));
+		return NULL;
+
+	}
+
+	if (!obj) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_get_inode for NULL object!!\n"));
+		return NULL;
+
+	}
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_get_inode for object %d\n", obj->objectId));
+
+	inode = Y_IGET(sb, obj->objectId);
+	if (IS_ERR(inode))
+		return NULL;
+
+	/* NB Side effect: iget calls back to yaffs_read_inode(). */
+	/* iget also increments the inode's i_count */
+	/* NB You can't be holding grossLock or deadlock will happen! */
+
+	return inode;
+}
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t *pos)
+{
+	yaffs_Object *obj;
+	int nWritten, ipos;
+	struct inode *inode;
+	yaffs_Device *dev;
+
+	obj = yaffs_DentryToObject(f->f_dentry);
+
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+	inode = f->f_dentry->d_inode;
+
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
+
+	if (!obj)
+		T(YAFFS_TRACE_OS,
+			("yaffs_file_write: hey obj is null!\n"));
+	else
+		T(YAFFS_TRACE_OS,
+			("yaffs_file_write about to write writing %zu bytes"
+			"to object %d at %d\n",
+			n, obj->objectId, ipos));
+
+	nWritten = yaffs_WriteDataToFile(obj, buf, ipos, n, 0);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_file_write writing %zu bytes, %d written at %d\n",
+		n, nWritten, ipos));
+
+	if (nWritten > 0) {
+		ipos += nWritten;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
+
+			T(YAFFS_TRACE_OS,
+				("yaffs_file_write size updated to %d bytes, "
+				"%d blocks\n",
+				ipos, (int)(inode->i_blocks)));
+		}
+
+	}
+	yaffs_GrossUnlock(dev);
+	return (nWritten == 0) && (n > 0) ? -ENOSPC : nWritten;
+}
+
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+static ssize_t yaffs_hold_space(struct file *f)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+
+	int nFreeChunks;
+
+
+	obj = yaffs_DentryToObject(f->f_dentry);
+
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+	nFreeChunks = yaffs_GetNumberOfFreeChunks(dev);
+
+	yaffs_GrossUnlock(dev);
+
+	return (nFreeChunks > 20) ? 1 : 0;
+}
+
+static void yaffs_release_space(struct file *f)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+
+
+	obj = yaffs_DentryToObject(f->f_dentry);
+
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+
+	yaffs_GrossUnlock(dev);
+}
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+        struct yaffs_SearchContext *sc;
+	struct inode *inode = f->f_dentry->d_inode;
+	unsigned long offset, curoffs;
+	yaffs_Object *l;
+        int retVal = 0;
+
+	char name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	obj = yaffs_DentryToObject(f->f_dentry);
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+	offset = f->f_pos;
+
+        sc = yaffs_NewSearch(obj);
+        if(!sc){
+                retVal = -ENOMEM;
+                goto unlock_out;
+        }
+
+	T(YAFFS_TRACE_OS, ("yaffs_readdir: starting at %d\n", (int)offset));
+
+	if (offset == 0) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_readdir: entry . ino %d \n",
+			(int)inode->i_ino));
+		yaffs_GrossUnlock(dev);
+		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR) < 0)
+			goto out;
+		yaffs_GrossLock(dev);
+		offset++;
+		f->f_pos++;
+	}
+	if (offset == 1) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_readdir: entry .. ino %d \n",
+			(int)f->f_dentry->d_parent->d_inode->i_ino));
+		yaffs_GrossUnlock(dev);
+		if (filldir(dirent, "..", 2, offset,
+			f->f_dentry->d_parent->d_inode->i_ino, DT_DIR) < 0)
+			goto out;
+		yaffs_GrossLock(dev);
+		offset++;
+		f->f_pos++;
+	}
+
+	curoffs = 1;
+
+	/* If the directory has changed since the open or last call to
+	   readdir, rewind to after the 2 canned entries. */
+
+	if (f->f_version != inode->i_version) {
+		offset = 2;
+		f->f_pos = offset;
+		f->f_version = inode->i_version;
+	}
+
+	while(sc->nextReturn){
+		curoffs++;
+                l = sc->nextReturn;
+		if (curoffs >= offset) {
+                        int this_inode = yaffs_GetObjectInode(l);
+                        int this_type = yaffs_GetObjectType(l);
+
+			yaffs_GetObjectName(l, name,
+					    YAFFS_MAX_NAME_LENGTH + 1);
+			T(YAFFS_TRACE_OS,
+			  ("yaffs_readdir: %s inode %d\n", name,
+			   yaffs_GetObjectInode(l)));
+
+                        yaffs_GrossUnlock(dev);
+
+			if (filldir(dirent,
+					name,
+					strlen(name),
+					offset,
+					this_inode,
+					this_type) < 0)
+				goto out;
+
+                        yaffs_GrossLock(dev);
+
+			offset++;
+			f->f_pos++;
+		}
+                yaffs_SearchAdvance(sc);
+	}
+
+unlock_out:
+	yaffs_GrossUnlock(dev);
+out:
+        yaffs_EndSearch(sc);
+
+	return retVal;
+}
+
+/*
+ * File creation. Allocate an inode, and we're done..
+ */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+#define YCRED(x) x
+#else
+#define YCRED(x) (x->cred)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			dev_t rdev)
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			int rdev)
+#endif
+{
+	struct inode *inode;
+
+	yaffs_Object *obj = NULL;
+	yaffs_Device *dev;
+
+	yaffs_Object *parent = yaffs_InodeToObject(dir);
+
+	int error = -ENOSPC;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+		mode |= S_ISGID;
+
+	if (parent) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_mknod: parent object %d type %d\n",
+			parent->objectId, parent->variantType));
+	} else {
+		T(YAFFS_TRACE_OS,
+			("yaffs_mknod: could not get parent object\n"));
+		return -EPERM;
+	}
+
+	T(YAFFS_TRACE_OS, ("yaffs_mknod: making oject for %s, "
+			"mode %x dev %x\n",
+			dentry->d_name.name, mode, rdev));
+
+	dev = parent->myDev;
+
+	yaffs_GrossLock(dev);
+
+	switch (mode & S_IFMT) {
+	default:
+		/* Special (socket, fifo, device...) */
+		T(YAFFS_TRACE_OS, ("yaffs_mknod: making special\n"));
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+		obj = yaffs_MknodSpecial(parent, dentry->d_name.name, mode, uid,
+				gid, old_encode_dev(rdev));
+#else
+		obj = yaffs_MknodSpecial(parent, dentry->d_name.name, mode, uid,
+				gid, rdev);
+#endif
+		break;
+	case S_IFREG:		/* file          */
+		T(YAFFS_TRACE_OS, ("yaffs_mknod: making file\n"));
+		obj = yaffs_MknodFile(parent, dentry->d_name.name, mode, uid,
+				gid);
+		break;
+	case S_IFDIR:		/* directory */
+		T(YAFFS_TRACE_OS,
+			("yaffs_mknod: making directory\n"));
+		obj = yaffs_MknodDirectory(parent, dentry->d_name.name, mode,
+					uid, gid);
+		break;
+	case S_IFLNK:		/* symlink */
+		T(YAFFS_TRACE_OS, ("yaffs_mknod: making symlink\n"));
+		obj = NULL;	/* Do we ever get here? */
+		break;
+	}
+
+	/* Can not call yaffs_get_inode() with gross lock held */
+	yaffs_GrossUnlock(dev);
+
+	if (obj) {
+		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		T(YAFFS_TRACE_OS,
+			("yaffs_mknod created object %d count = %d\n",
+			obj->objectId, atomic_read(&inode->i_count)));
+		error = 0;
+	} else {
+		T(YAFFS_TRACE_OS,
+			("yaffs_mknod failed making object\n"));
+		error = -ENOMEM;
+	}
+
+	return error;
+}
+
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int retVal;
+	T(YAFFS_TRACE_OS, ("yaffs_mkdir\n"));
+	retVal = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	return retVal;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n)
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	T(YAFFS_TRACE_OS, ("yaffs_create\n"));
+	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+}
+
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int retVal;
+
+	yaffs_Device *dev;
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_unlink %d:%s\n", (int)(dir->i_ino),
+		dentry->d_name.name));
+
+	dev = yaffs_InodeToObject(dir)->myDev;
+
+	yaffs_GrossLock(dev);
+
+	retVal = yaffs_Unlink(yaffs_InodeToObject(dir), dentry->d_name.name);
+
+	if (retVal == YAFFS_OK) {
+		dentry->d_inode->i_nlink--;
+		dir->i_version++;
+		yaffs_GrossUnlock(dev);
+		mark_inode_dirty(dentry->d_inode);
+		update_dir_time(dir);
+		return 0;
+	}
+	yaffs_GrossUnlock(dev);
+	return -ENOTEMPTY;
+}
+
+/*
+ * Create a link...
+ */
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+			struct dentry *dentry)
+{
+	struct inode *inode = old_dentry->d_inode;
+	yaffs_Object *obj = NULL;
+	yaffs_Object *link = NULL;
+	yaffs_Device *dev;
+
+	T(YAFFS_TRACE_OS, ("yaffs_link\n"));
+
+	obj = yaffs_InodeToObject(inode);
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+	if (!S_ISDIR(inode->i_mode))		/* Don't link directories */
+		link = yaffs_Link(yaffs_InodeToObject(dir), dentry->d_name.name,
+			obj);
+
+	if (link) {
+		old_dentry->d_inode->i_nlink = yaffs_GetObjectLinkCount(obj);
+		d_instantiate(dentry, old_dentry->d_inode);
+		atomic_inc(&old_dentry->d_inode->i_count);
+		T(YAFFS_TRACE_OS,
+			("yaffs_link link count %d i_count %d\n",
+			old_dentry->d_inode->i_nlink,
+			atomic_read(&old_dentry->d_inode->i_count)));
+	}
+
+	yaffs_GrossUnlock(dev);
+
+	if (link){
+		update_dir_time(dir);
+		return 0;
+	}
+
+	return -EPERM;
+}
+
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+				const char *symname)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	T(YAFFS_TRACE_OS, ("yaffs_symlink\n"));
+
+	dev = yaffs_InodeToObject(dir)->myDev;
+	yaffs_GrossLock(dev);
+	obj = yaffs_MknodSymLink(yaffs_InodeToObject(dir), dentry->d_name.name,
+				S_IFLNK | S_IRWXUGO, uid, gid, symname);
+	yaffs_GrossUnlock(dev);
+
+	if (obj) {
+		struct inode *inode;
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		T(YAFFS_TRACE_OS, ("symlink created OK\n"));
+		return 0;
+	} else {
+		T(YAFFS_TRACE_OS, ("symlink not created\n"));
+	}
+
+	return -ENOMEM;
+}
+
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+				int datasync)
+{
+
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+
+	obj = yaffs_DentryToObject(dentry);
+
+	dev = obj->myDev;
+
+	T(YAFFS_TRACE_OS, ("yaffs_sync_object\n"));
+	yaffs_GrossLock(dev);
+	yaffs_FlushFile(obj, 1);
+	yaffs_GrossUnlock(dev);
+	return 0;
+}
+
+/*
+ * The VFS layer already does all the dentry stuff for rename.
+ *
+ * NB: POSIX says you can rename an object over an old object of the same name
+ */
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry)
+{
+	yaffs_Device *dev;
+	int retVal = YAFFS_FAIL;
+	yaffs_Object *target;
+
+	T(YAFFS_TRACE_OS, ("yaffs_rename\n"));
+	dev = yaffs_InodeToObject(old_dir)->myDev;
+
+	yaffs_GrossLock(dev);
+
+	/* Check if the target is an existing directory that is not empty. */
+	target = yaffs_FindObjectByName(yaffs_InodeToObject(new_dir),
+				new_dentry->d_name.name);
+
+
+
+	if (target && target->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&
+		!ylist_empty(&target->variant.directoryVariant.children)) {
+
+		T(YAFFS_TRACE_OS, ("target is non-empty dir\n"));
+
+		retVal = YAFFS_FAIL;
+	} else {
+		/* Now does unlinking internally using shadowing mechanism */
+		T(YAFFS_TRACE_OS, ("calling yaffs_RenameObject\n"));
+
+		retVal = yaffs_RenameObject(yaffs_InodeToObject(old_dir),
+				old_dentry->d_name.name,
+				yaffs_InodeToObject(new_dir),
+				new_dentry->d_name.name);
+	}
+	yaffs_GrossUnlock(dev);
+
+	if (retVal == YAFFS_OK) {
+		if (target) {
+			new_dentry->d_inode->i_nlink--;
+			mark_inode_dirty(new_dentry->d_inode);
+		}
+		
+		update_dir_time(old_dir);
+		if(old_dir != new_dir)
+			update_dir_time(new_dir);
+		return 0;
+	} else {
+		return -ENOTEMPTY;
+	}
+}
+
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	int error;
+	yaffs_Device *dev;
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_setattr of object %d\n",
+		yaffs_InodeToObject(inode)->objectId));
+
+	error = inode_change_ok(inode, attr);
+	if (error == 0) {
+		dev = yaffs_InodeToObject(inode)->myDev;
+		yaffs_GrossLock(dev);
+		if (yaffs_SetAttributes(yaffs_InodeToObject(inode), attr) ==
+				YAFFS_OK) {
+			error = 0;
+		} else {
+			error = -EPERM;
+		}
+		yaffs_GrossUnlock(dev);
+		if (!error)
+			error = inode_setattr(inode, attr);
+	}
+	return error;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	yaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;
+	struct super_block *sb = dentry->d_sb;
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf)
+{
+	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf)
+{
+	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+#endif
+
+	T(YAFFS_TRACE_OS, ("yaffs_statfs\n"));
+
+	yaffs_GrossLock(dev);
+
+	buf->f_type = YAFFS_MAGIC;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_namelen = 255;
+
+	if (dev->nDataBytesPerChunk & (dev->nDataBytesPerChunk - 1)) {
+		/* Do this if chunk size is not a power of 2 */
+
+		uint64_t bytesInDev;
+		uint64_t bytesFree;
+
+		bytesInDev = ((uint64_t)((dev->endBlock - dev->startBlock + 1))) *
+			((uint64_t)(dev->nChunksPerBlock * dev->nDataBytesPerChunk));
+
+		do_div(bytesInDev, sb->s_blocksize); /* bytesInDev becomes the number of blocks */
+		buf->f_blocks = bytesInDev;
+
+		bytesFree  = ((uint64_t)(yaffs_GetNumberOfFreeChunks(dev))) *
+			((uint64_t)(dev->nDataBytesPerChunk));
+
+		do_div(bytesFree, sb->s_blocksize);
+
+		buf->f_bfree = bytesFree;
+
+	} else if (sb->s_blocksize > dev->nDataBytesPerChunk) {
+
+		buf->f_blocks =
+			(dev->endBlock - dev->startBlock + 1) *
+			dev->nChunksPerBlock /
+			(sb->s_blocksize / dev->nDataBytesPerChunk);
+		buf->f_bfree =
+			yaffs_GetNumberOfFreeChunks(dev) /
+			(sb->s_blocksize / dev->nDataBytesPerChunk);
+	} else {
+		buf->f_blocks =
+			(dev->endBlock - dev->startBlock + 1) *
+			dev->nChunksPerBlock *
+			(dev->nDataBytesPerChunk / sb->s_blocksize);
+
+		buf->f_bfree =
+			yaffs_GetNumberOfFreeChunks(dev) *
+			(dev->nDataBytesPerChunk / sb->s_blocksize);
+	}
+
+	buf->f_files = 0;
+	buf->f_ffree = 0;
+	buf->f_bavail = buf->f_bfree;
+
+	yaffs_GrossUnlock(dev);
+	return 0;
+}
+
+
+static int yaffs_do_sync_fs(struct super_block *sb)
+{
+
+	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+	T(YAFFS_TRACE_OS, ("yaffs_do_sync_fs\n"));
+
+	if (sb->s_dirt) {
+		yaffs_GrossLock(dev);
+
+		if (dev) {
+			yaffs_FlushEntireDeviceCache(dev);
+			yaffs_CheckpointSave(dev);
+		}
+
+		yaffs_GrossUnlock(dev);
+
+		sb->s_dirt = 0;
+	}
+	return 0;
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static void yaffs_write_super(struct super_block *sb)
+#else
+static int yaffs_write_super(struct super_block *sb)
+#endif
+{
+
+	T(YAFFS_TRACE_OS, ("yaffs_write_super\n"));
+	if (yaffs_auto_checkpoint >= 2)
+		yaffs_do_sync_fs(sb);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+	return 0;
+#endif
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait)
+#else
+static int yaffs_sync_fs(struct super_block *sb)
+#endif
+{
+	T(YAFFS_TRACE_OS, ("yaffs_sync_fs\n"));
+
+	if (yaffs_auto_checkpoint >= 1)
+		yaffs_do_sync_fs(sb);
+
+	return 0;
+}
+
+#ifdef YAFFS_USE_OWN_IGET
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+	yaffs_Object *obj;
+	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_iget for %lu\n", ino));
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_GrossLock(dev);
+
+	obj = yaffs_FindObjectByNumber(dev, inode->i_ino);
+
+	yaffs_FillInodeFromObject(inode, obj);
+
+	yaffs_GrossUnlock(dev);
+
+	unlock_new_inode(inode);
+	return inode;
+}
+
+#else
+
+static void yaffs_read_inode(struct inode *inode)
+{
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_Object *obj;
+	yaffs_Device *dev = yaffs_SuperToDevice(inode->i_sb);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_read_inode for %d\n", (int)inode->i_ino));
+
+	yaffs_GrossLock(dev);
+
+	obj = yaffs_FindObjectByNumber(dev, inode->i_ino);
+
+	yaffs_FillInodeFromObject(inode, obj);
+
+	yaffs_GrossUnlock(dev);
+}
+
+#endif
+
+static YLIST_HEAD(yaffs_dev_list);
+
+#if 0 /* not used */
+static int yaffs_remount_fs(struct super_block *sb, int *flags, char *data)
+{
+	yaffs_Device    *dev = yaffs_SuperToDevice(sb);
+
+	if (*flags & MS_RDONLY) {
+		struct mtd_info *mtd = yaffs_SuperToDevice(sb)->genericDevice;
+
+		T(YAFFS_TRACE_OS,
+			("yaffs_remount_fs: %s: RO\n", dev->name));
+
+		yaffs_GrossLock(dev);
+
+		yaffs_FlushEntireDeviceCache(dev);
+
+		yaffs_CheckpointSave(dev);
+
+		if (mtd->sync)
+			mtd->sync(mtd);
+
+		yaffs_GrossUnlock(dev);
+	} else {
+		T(YAFFS_TRACE_OS,
+			("yaffs_remount_fs: %s: RW\n", dev->name));
+	}
+
+	return 0;
+}
+#endif
+
+static void yaffs_put_super(struct super_block *sb)
+{
+	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+
+	T(YAFFS_TRACE_OS, ("yaffs_put_super\n"));
+
+	yaffs_GrossLock(dev);
+
+	yaffs_FlushEntireDeviceCache(dev);
+
+	yaffs_CheckpointSave(dev);
+
+	if (dev->putSuperFunc)
+		dev->putSuperFunc(sb);
+
+	yaffs_Deinitialise(dev);
+
+	yaffs_GrossUnlock(dev);
+
+	/* we assume this is protected by lock_kernel() in mount/umount */
+	ylist_del(&dev->devList);
+
+	if (dev->spareBuffer) {
+		YFREE(dev->spareBuffer);
+		dev->spareBuffer = NULL;
+	}
+
+	kfree(dev);
+}
+
+
+static void yaffs_MTDPutSuper(struct super_block *sb)
+{
+	struct mtd_info *mtd = yaffs_SuperToDevice(sb)->genericDevice;
+
+	if (mtd->sync)
+		mtd->sync(mtd);
+
+	put_mtd_device(mtd);
+}
+
+
+static void yaffs_MarkSuperBlockDirty(void *vsb)
+{
+	struct super_block *sb = (struct super_block *)vsb;
+
+	T(YAFFS_TRACE_OS, ("yaffs_MarkSuperBlockDirty() sb = %p\n", sb));
+	if (sb)
+		sb->s_dirt = 1;
+}
+
+typedef struct {
+	int inband_tags;
+	int skip_checkpoint_read;
+	int skip_checkpoint_write;
+	int no_cache;
+	int empty_lost_and_found_overridden;
+	int empty_lost_and_found;
+} yaffs_options;
+
+#define MAX_OPT_LEN 20
+static int yaffs_parse_options(yaffs_options *options, const char *options_str)
+{
+	char cur_opt[MAX_OPT_LEN + 1];
+	int p;
+	int error = 0;
+
+	/* Parse through the options which is a comma seperated list */
+
+	while (options_str && *options_str && !error) {
+		memset(cur_opt, 0, MAX_OPT_LEN + 1);
+		p = 0;
+
+		while (*options_str == ',')
+			options_str++;
+
+		while (*options_str && *options_str != ',') {
+			if (p < MAX_OPT_LEN) {
+				cur_opt[p] = *options_str;
+				p++;
+			}
+			options_str++;
+		}
+
+		if (!strcmp(cur_opt, "inband-tags"))
+			options->inband_tags = 1;
+		else if (!strcmp(cur_opt, "no-cache"))
+			options->no_cache = 1;
+		else if (!strcmp(cur_opt, "no-checkpoint-read"))
+			options->skip_checkpoint_read = 1;
+		else if (!strcmp(cur_opt, "no-checkpoint-write"))
+			options->skip_checkpoint_write = 1;
+		else if (!strcmp(cur_opt, "no-checkpoint")) {
+			options->skip_checkpoint_read = 1;
+			options->skip_checkpoint_write = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-disable")) {
+			options->empty_lost_and_found = 0;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-enable")) {
+			options->empty_lost_and_found = 1;
+			options->empty_lost_and_found_overridden = 1;
+		} else {
+			printk(KERN_INFO "yaffs: Bad mount option \"%s\"\n",
+					cur_opt);
+			error = 1;
+		}
+	}
+
+	return error;
+}
+
+static struct super_block *yaffs_internal_read_super(int yaffsVersion,
+						struct super_block *sb,
+						void *data, int silent)
+{
+	int nBlocks;
+	struct inode *inode = NULL;
+	struct dentry *root;
+	yaffs_Device *dev = 0;
+	char devname_buf[BDEVNAME_SIZE + 1];
+	struct mtd_info *mtd;
+	int err;
+	char *data_str = (char *)data;
+
+	yaffs_options options;
+
+	sb->s_magic = YAFFS_MAGIC;
+	sb->s_op = &yaffs_super_ops;
+	sb->s_flags |= MS_NOATIME;
+
+	if (!sb)
+		printk(KERN_INFO "yaffs: sb is NULL\n");
+	else if (!sb->s_dev)
+		printk(KERN_INFO "yaffs: sb->s_dev is NULL\n");
+	else if (!yaffs_devname(sb, devname_buf))
+		printk(KERN_INFO "yaffs: devname is NULL\n");
+	else
+		printk(KERN_INFO "yaffs: dev is %d name is \"%s\"\n",
+		       sb->s_dev,
+		       yaffs_devname(sb, devname_buf));
+
+	if (!data_str)
+		data_str = "";
+
+	printk(KERN_INFO "yaffs: passed flags \"%s\"\n", data_str);
+
+	memset(&options, 0, sizeof(options));
+
+	if (yaffs_parse_options(&options, data_str)) {
+		/* Option parsing failed */
+		return NULL;
+	}
+
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	T(YAFFS_TRACE_OS, ("yaffs_read_super: Using yaffs%d\n", yaffsVersion));
+	T(YAFFS_TRACE_OS,
+	  ("yaffs_read_super: block size %d\n", (int)(sb->s_blocksize)));
+
+#ifdef CONFIG_YAFFS_DISABLE_WRITE_VERIFY
+	T(YAFFS_TRACE_OS,
+	  ("yaffs: Write verification disabled. All guarantees "
+	   "null and void\n"));
+#endif
+
+	T(YAFFS_TRACE_ALWAYS, ("yaffs: Attempting MTD mount on %u.%u, "
+			       "\"%s\"\n",
+			       MAJOR(sb->s_dev), MINOR(sb->s_dev),
+			       yaffs_devname(sb, devname_buf)));
+
+	/* Check it's an mtd device..... */
+	if (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR)
+		return NULL;	/* This isn't an mtd device */
+
+	/* Get the device */
+	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	if (!mtd) {
+		T(YAFFS_TRACE_ALWAYS,
+		  ("yaffs: MTD device #%u doesn't appear to exist\n",
+		   MINOR(sb->s_dev)));
+		return NULL;
+	}
+	/* Check it's NAND */
+	if (mtd->type != MTD_NANDFLASH) {
+		T(YAFFS_TRACE_ALWAYS,
+		  ("yaffs: MTD device is not NAND it's type %d\n", mtd->type));
+		return NULL;
+	}
+
+	T(YAFFS_TRACE_OS, (" erase %p\n", mtd->erase));
+	T(YAFFS_TRACE_OS, (" read %p\n", mtd->read));
+	T(YAFFS_TRACE_OS, (" write %p\n", mtd->write));
+	T(YAFFS_TRACE_OS, (" readoob %p\n", mtd->read_oob));
+	T(YAFFS_TRACE_OS, (" writeoob %p\n", mtd->write_oob));
+	T(YAFFS_TRACE_OS, (" block_isbad %p\n", mtd->block_isbad));
+	T(YAFFS_TRACE_OS, (" block_markbad %p\n", mtd->block_markbad));
+	T(YAFFS_TRACE_OS, (" %s %d\n", WRITE_SIZE_STR, WRITE_SIZE(mtd)));
+	T(YAFFS_TRACE_OS, (" oobsize %d\n", mtd->oobsize));
+	T(YAFFS_TRACE_OS, (" erasesize %d\n", mtd->erasesize));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+	T(YAFFS_TRACE_OS, (" size %u\n", mtd->size));
+#else
+	T(YAFFS_TRACE_OS, (" size %lld\n", mtd->size));
+#endif
+
+
+#ifdef CONFIG_YAFFS_EMPTY_LOST_AND_FOUND
+	dev->emptyLostAndFound = 1;
+#endif
+	if(options.empty_lost_and_found_overridden)
+		dev->emptyLostAndFound = options.empty_lost_and_found;
+
+#ifdef CONFIG_YAFFS_AUTO_YAFFS2
+
+	if (yaffsVersion == 1 && WRITE_SIZE(mtd) >= 2048) {
+		T(YAFFS_TRACE_ALWAYS, ("yaffs: auto selecting yaffs2\n"));
+		yaffsVersion = 2;
+	}
+
+	/* Added NCB 26/5/2006 for completeness */
+	if (yaffsVersion == 2 && !options.inband_tags && WRITE_SIZE(mtd) == 512) {
+		T(YAFFS_TRACE_ALWAYS, ("yaffs: auto selecting yaffs1\n"));
+		yaffsVersion = 1;
+	}
+
+#endif
+
+	if (yaffsVersion == 2) {
+		/* Check for version 2 style functions */
+		if (!mtd->erase ||
+		    !mtd->block_isbad ||
+		    !mtd->block_markbad ||
+		    !mtd->read ||
+		    !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
+			T(YAFFS_TRACE_ALWAYS,
+			  ("yaffs: MTD device does not support required "
+			   "functions\n"));;
+			return NULL;
+		}
+
+		if ((WRITE_SIZE(mtd) < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
+		    mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
+		    !options.inband_tags) {
+			T(YAFFS_TRACE_ALWAYS,
+			  ("yaffs: MTD device does not have the "
+			   "right page sizes\n"));
+			return NULL;
+		}
+	} else {
+		/* Check for V1 style functions */
+		if (!mtd->erase ||
+		    !mtd->read ||
+		    !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
+			T(YAFFS_TRACE_ALWAYS,
+			  ("yaffs: MTD device does not support required "
+			   "functions\n"));;
+			return NULL;
+		}
+
+		if (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||
+		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
+			T(YAFFS_TRACE_ALWAYS,
+			  ("yaffs: MTD device does not support have the "
+			   "right page sizes\n"));
+			return NULL;
+		}
+	}
+
+	/* OK, so if we got here, we have an MTD that's NAND and looks
+	 * like it has the right capabilities
+	 * Set the yaffs_Device up for mtd
+	 */
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	sb->s_fs_info = dev = kmalloc(sizeof(yaffs_Device), GFP_KERNEL);
+#else
+	sb->u.generic_sbp = dev = kmalloc(sizeof(yaffs_Device), GFP_KERNEL);
+#endif
+	if (!dev) {
+		/* Deep shit could not allocate device structure */
+		T(YAFFS_TRACE_ALWAYS,
+		  ("yaffs_read_super: Failed trying to allocate "
+		   "yaffs_Device. \n"));
+		return NULL;
+	}
+
+	memset(dev, 0, sizeof(yaffs_Device));
+	dev->genericDevice = mtd;
+	dev->name = mtd->name;
+
+	/* Set up the memory size parameters.... */
+
+	nBlocks = YCALCBLOCKS(mtd->size, (YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK));
+
+	dev->startBlock = 0;
+	dev->endBlock = nBlocks - 1;
+	dev->nChunksPerBlock = YAFFS_CHUNKS_PER_BLOCK;
+	dev->totalBytesPerChunk = YAFFS_BYTES_PER_CHUNK;
+	dev->nReservedBlocks = 5;
+	dev->nShortOpCaches = (options.no_cache) ? 0 : 10;
+	dev->inbandTags = options.inband_tags;
+
+	/* ... and the functions. */
+	if (yaffsVersion == 2) {
+		dev->writeChunkWithTagsToNAND =
+		    nandmtd2_WriteChunkWithTagsToNAND;
+		dev->readChunkWithTagsFromNAND =
+		    nandmtd2_ReadChunkWithTagsFromNAND;
+		dev->markNANDBlockBad = nandmtd2_MarkNANDBlockBad;
+		dev->queryNANDBlock = nandmtd2_QueryNANDBlock;
+		dev->spareBuffer = YMALLOC(mtd->oobsize);
+		dev->isYaffs2 = 1;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		dev->totalBytesPerChunk = mtd->writesize;
+		dev->nChunksPerBlock = mtd->erasesize / mtd->writesize;
+#else
+		dev->totalBytesPerChunk = mtd->oobblock;
+		dev->nChunksPerBlock = mtd->erasesize / mtd->oobblock;
+#endif
+		nBlocks = YCALCBLOCKS(mtd->size, mtd->erasesize);
+
+		dev->startBlock = 0;
+		dev->endBlock = nBlocks - 1;
+	} else {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		/* use the MTD interface in yaffs_mtdif1.c */
+		dev->writeChunkWithTagsToNAND =
+			nandmtd1_WriteChunkWithTagsToNAND;
+		dev->readChunkWithTagsFromNAND =
+			nandmtd1_ReadChunkWithTagsFromNAND;
+		dev->markNANDBlockBad = nandmtd1_MarkNANDBlockBad;
+		dev->queryNANDBlock = nandmtd1_QueryNANDBlock;
+#else
+		dev->writeChunkToNAND = nandmtd_WriteChunkToNAND;
+		dev->readChunkFromNAND = nandmtd_ReadChunkFromNAND;
+#endif
+		dev->isYaffs2 = 0;
+	}
+	/* ... and common functions */
+	dev->eraseBlockInNAND = nandmtd_EraseBlockInNAND;
+	dev->initialiseNAND = nandmtd_InitialiseNAND;
+
+	dev->putSuperFunc = yaffs_MTDPutSuper;
+
+	dev->superBlock = (void *)sb;
+	dev->markSuperBlockDirty = yaffs_MarkSuperBlockDirty;
+
+
+#ifndef CONFIG_YAFFS_DOES_ECC
+	dev->useNANDECC = 1;
+#endif
+
+#ifdef CONFIG_YAFFS_DISABLE_WIDE_TNODES
+	dev->wideTnodesDisabled = 1;
+#endif
+
+	dev->skipCheckpointRead = options.skip_checkpoint_read;
+	dev->skipCheckpointWrite = options.skip_checkpoint_write;
+
+	/* we assume this is protected by lock_kernel() in mount/umount */
+	ylist_add_tail(&dev->devList, &yaffs_dev_list);
+
+        /* Directory search handling...*/
+        YINIT_LIST_HEAD(&dev->searchContexts);
+        dev->removeObjectCallback = yaffs_RemoveObjectCallback;
+
+	init_MUTEX(&dev->grossLock);
+
+	yaffs_GrossLock(dev);
+
+	err = yaffs_GutsInitialise(dev);
+
+	T(YAFFS_TRACE_OS,
+	  ("yaffs_read_super: guts initialised %s\n",
+	   (err == YAFFS_OK) ? "OK" : "FAILED"));
+
+	/* Release lock before yaffs_get_inode() */
+	yaffs_GrossUnlock(dev);
+
+	/* Create root inode */
+	if (err == YAFFS_OK)
+		inode = yaffs_get_inode(sb, S_IFDIR | 0755, 0,
+					yaffs_Root(dev));
+
+	if (!inode)
+		return NULL;
+
+	inode->i_op = &yaffs_dir_inode_operations;
+	inode->i_fop = &yaffs_dir_operations;
+
+	T(YAFFS_TRACE_OS, ("yaffs_read_super: got root inode\n"));
+
+	root = d_alloc_root(inode);
+
+	T(YAFFS_TRACE_OS, ("yaffs_read_super: d_alloc_root done\n"));
+
+	if (!root) {
+		iput(inode);
+		return NULL;
+	}
+	sb->s_root = root;
+	sb->s_dirt = !dev->isCheckpointed;
+	T(YAFFS_TRACE_ALWAYS,
+	  ("yaffs_read_super: isCheckpointed %d\n", dev->isCheckpointed));
+
+	T(YAFFS_TRACE_OS, ("yaffs_read_super: done\n"));
+	return sb;
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,
+					 int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_read_super(struct file_system_type *fs,
+			    int flags, const char *dev_name,
+			    void *data, struct vfsmount *mnt)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs_read_super(struct file_system_type *fs,
+					    int flags, const char *dev_name,
+					    void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs",
+	.get_sb = yaffs_read_super,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs_read_super(struct super_block *sb, void *data,
+					    int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs_fs_type, "yaffs", yaffs_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+
+#ifdef CONFIG_YAFFS_YAFFS2
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,
+					  int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs2_read_super(struct file_system_type *fs,
+			int flags, const char *dev_name, void *data,
+			struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs, flags, dev_name, data,
+			yaffs2_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs2_read_super(struct file_system_type *fs,
+					     int flags, const char *dev_name,
+					     void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs2_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs2",
+	.get_sb = yaffs2_read_super,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs2_read_super(struct super_block *sb,
+					     void *data, int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs2_fs_type, "yaffs2", yaffs2_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+#endif				/* CONFIG_YAFFS_YAFFS2 */
+
+static struct proc_dir_entry *my_proc_entry;
+
+static char *yaffs_dump_dev(char *buf, yaffs_Device * dev)
+{
+	buf += sprintf(buf, "startBlock......... %d\n", dev->startBlock);
+	buf += sprintf(buf, "endBlock........... %d\n", dev->endBlock);
+	buf += sprintf(buf, "totalBytesPerChunk. %d\n", dev->totalBytesPerChunk);
+	buf += sprintf(buf, "nDataBytesPerChunk. %d\n", dev->nDataBytesPerChunk);
+	buf += sprintf(buf, "chunkGroupBits..... %d\n", dev->chunkGroupBits);
+	buf += sprintf(buf, "chunkGroupSize..... %d\n", dev->chunkGroupSize);
+	buf += sprintf(buf, "nErasedBlocks...... %d\n", dev->nErasedBlocks);
+	buf += sprintf(buf, "nReservedBlocks.... %d\n", dev->nReservedBlocks);
+	buf += sprintf(buf, "blocksInCheckpoint. %d\n", dev->blocksInCheckpoint);
+	buf += sprintf(buf, "nTnodesCreated..... %d\n", dev->nTnodesCreated);
+	buf += sprintf(buf, "nFreeTnodes........ %d\n", dev->nFreeTnodes);
+	buf += sprintf(buf, "nObjectsCreated.... %d\n", dev->nObjectsCreated);
+	buf += sprintf(buf, "nFreeObjects....... %d\n", dev->nFreeObjects);
+	buf += sprintf(buf, "nFreeChunks........ %d\n", dev->nFreeChunks);
+	buf += sprintf(buf, "nPageWrites........ %d\n", dev->nPageWrites);
+	buf += sprintf(buf, "nPageReads......... %d\n", dev->nPageReads);
+	buf += sprintf(buf, "nBlockErasures..... %d\n", dev->nBlockErasures);
+	buf += sprintf(buf, "nGCCopies.......... %d\n", dev->nGCCopies);
+	buf += sprintf(buf, "garbageCollections. %d\n", dev->garbageCollections);
+	buf += sprintf(buf, "passiveGCs......... %d\n",
+		    dev->passiveGarbageCollections);
+	buf += sprintf(buf, "nRetriedWrites..... %d\n", dev->nRetriedWrites);
+	buf += sprintf(buf, "nShortOpCaches..... %d\n", dev->nShortOpCaches);
+	buf += sprintf(buf, "nRetireBlocks...... %d\n", dev->nRetiredBlocks);
+	buf += sprintf(buf, "eccFixed........... %d\n", dev->eccFixed);
+	buf += sprintf(buf, "eccUnfixed......... %d\n", dev->eccUnfixed);
+	buf += sprintf(buf, "tagsEccFixed....... %d\n", dev->tagsEccFixed);
+	buf += sprintf(buf, "tagsEccUnfixed..... %d\n", dev->tagsEccUnfixed);
+	buf += sprintf(buf, "cacheHits.......... %d\n", dev->cacheHits);
+	buf += sprintf(buf, "nDeletedFiles...... %d\n", dev->nDeletedFiles);
+	buf += sprintf(buf, "nUnlinkedFiles..... %d\n", dev->nUnlinkedFiles);
+	buf +=
+	    sprintf(buf, "nBackgroudDeletions %d\n", dev->nBackgroundDeletions);
+	buf += sprintf(buf, "useNANDECC......... %d\n", dev->useNANDECC);
+	buf += sprintf(buf, "isYaffs2........... %d\n", dev->isYaffs2);
+	buf += sprintf(buf, "inbandTags......... %d\n", dev->inbandTags);
+
+	return buf;
+}
+
+static int yaffs_proc_read(char *page,
+			   char **start,
+			   off_t offset, int count, int *eof, void *data)
+{
+	struct ylist_head *item;
+	char *buf = page;
+	int step = offset;
+	int n = 0;
+
+	/* Get proc_file_read() to step 'offset' by one on each sucessive call.
+	 * We use 'offset' (*ppos) to indicate where we are in devList.
+	 * This also assumes the user has posted a read buffer large
+	 * enough to hold the complete output; but that's life in /proc.
+	 */
+
+	*(int *)start = 1;
+
+	/* Print header first */
+	if (step == 0) {
+		buf += sprintf(buf, "YAFFS built:" __DATE__ " " __TIME__
+			       "\n%s\n%s\n", yaffs_fs_c_version,
+			       yaffs_guts_c_version);
+	}
+
+	/* hold lock_kernel while traversing yaffs_dev_list */
+	lock_kernel();
+
+	/* Locate and print the Nth entry.  Order N-squared but N is small. */
+	ylist_for_each(item, &yaffs_dev_list) {
+		yaffs_Device *dev = ylist_entry(item, yaffs_Device, devList);
+		if (n < step) {
+			n++;
+			continue;
+		}
+		buf += sprintf(buf, "\nDevice %d \"%s\"\n", n, dev->name);
+		buf = yaffs_dump_dev(buf, dev);
+		break;
+	}
+	unlock_kernel();
+
+	return buf - page < count ? buf - page : count;
+}
+
+/**
+ * Set the verbosity of the warnings and error messages.
+ *
+ * Note that the names can only be a..z or _ with the current code.
+ */
+
+static struct {
+	char *mask_name;
+	unsigned mask_bitfield;
+} mask_flags[] = {
+	{"allocate", YAFFS_TRACE_ALLOCATE},
+	{"always", YAFFS_TRACE_ALWAYS},
+	{"bad_blocks", YAFFS_TRACE_BAD_BLOCKS},
+	{"buffers", YAFFS_TRACE_BUFFERS},
+	{"bug", YAFFS_TRACE_BUG},
+	{"checkpt", YAFFS_TRACE_CHECKPOINT},
+	{"deletion", YAFFS_TRACE_DELETION},
+	{"erase", YAFFS_TRACE_ERASE},
+	{"error", YAFFS_TRACE_ERROR},
+	{"gc_detail", YAFFS_TRACE_GC_DETAIL},
+	{"gc", YAFFS_TRACE_GC},
+	{"mtd", YAFFS_TRACE_MTD},
+	{"nandaccess", YAFFS_TRACE_NANDACCESS},
+	{"os", YAFFS_TRACE_OS},
+	{"scan_debug", YAFFS_TRACE_SCAN_DEBUG},
+	{"scan", YAFFS_TRACE_SCAN},
+	{"tracing", YAFFS_TRACE_TRACING},
+
+	{"verify", YAFFS_TRACE_VERIFY},
+	{"verify_nand", YAFFS_TRACE_VERIFY_NAND},
+	{"verify_full", YAFFS_TRACE_VERIFY_FULL},
+	{"verify_all", YAFFS_TRACE_VERIFY_ALL},
+
+	{"write", YAFFS_TRACE_WRITE},
+	{"all", 0xffffffff},
+	{"none", 0},
+	{NULL, 0},
+};
+
+#define MAX_MASK_NAME_LENGTH 40
+static int yaffs_proc_write(struct file *file, const char *buf,
+					 unsigned long count, void *data)
+{
+	unsigned rg = 0, mask_bitfield;
+	char *end;
+	char *mask_name;
+	const char *x;
+	char substring[MAX_MASK_NAME_LENGTH + 1];
+	int i;
+	int done = 0;
+	int add, len = 0;
+	int pos = 0;
+
+	rg = yaffs_traceMask;
+
+	while (!done && (pos < count)) {
+		done = 1;
+		while ((pos < count) && isspace(buf[pos]))
+			pos++;
+
+		switch (buf[pos]) {
+		case '+':
+		case '-':
+		case '=':
+			add = buf[pos];
+			pos++;
+			break;
+
+		default:
+			add = ' ';
+			break;
+		}
+		mask_name = NULL;
+
+		mask_bitfield = simple_strtoul(buf + pos, &end, 0);
+
+		if (end > buf + pos) {
+			mask_name = "numeral";
+			len = end - (buf + pos);
+			pos += len;
+			done = 0;
+		} else {
+			for (x = buf + pos, i = 0;
+			    (*x == '_' || (*x >= 'a' && *x <= 'z')) &&
+			    i < MAX_MASK_NAME_LENGTH; x++, i++, pos++)
+				substring[i] = *x;
+			substring[i] = '\0';
+
+			for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+				if (strcmp(substring, mask_flags[i].mask_name) == 0) {
+					mask_name = mask_flags[i].mask_name;
+					mask_bitfield = mask_flags[i].mask_bitfield;
+					done = 0;
+					break;
+				}
+			}
+		}
+
+		if (mask_name != NULL) {
+			done = 0;
+			switch (add) {
+			case '-':
+				rg &= ~mask_bitfield;
+				break;
+			case '+':
+				rg |= mask_bitfield;
+				break;
+			case '=':
+				rg = mask_bitfield;
+				break;
+			default:
+				rg |= mask_bitfield;
+				break;
+			}
+		}
+	}
+
+	yaffs_traceMask = rg | YAFFS_TRACE_ALWAYS;
+
+	printk(KERN_DEBUG "new trace = 0x%08X\n", yaffs_traceMask);
+
+	if (rg & YAFFS_TRACE_ALWAYS) {
+		for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+			char flag;
+			flag = ((rg & mask_flags[i].mask_bitfield) == mask_flags[i].mask_bitfield) ? '+' : '-';
+			printk(KERN_DEBUG "%c%s\n", flag, mask_flags[i].mask_name);
+		}
+	}
+
+	return count;
+}
+
+/* Stuff to handle installation of file systems */
+struct file_system_to_install {
+	struct file_system_type *fst;
+	int installed;
+};
+
+static struct file_system_to_install fs_to_install[] = {
+	{&yaffs_fs_type, 0},
+	{&yaffs2_fs_type, 0},
+	{NULL, 0}
+};
+
+static int __init init_yaffs_fs(void)
+{
+	int error = 0;
+	struct file_system_to_install *fsinst;
+
+	T(YAFFS_TRACE_ALWAYS,
+	  ("yaffs " __DATE__ " " __TIME__ " Installing. \n"));
+
+	/* Install the proc_fs entry */
+	my_proc_entry = create_proc_entry("yaffs",
+					       S_IRUGO | S_IFREG,
+					       YPROC_ROOT);
+
+	if (my_proc_entry) {
+		my_proc_entry->write_proc = yaffs_proc_write;
+		my_proc_entry->read_proc = yaffs_proc_read;
+		my_proc_entry->data = NULL;
+	} else
+		return -ENOMEM;
+
+	/* Now add the file system entries */
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst && !error) {
+		error = register_filesystem(fsinst->fst);
+		if (!error)
+			fsinst->installed = 1;
+		fsinst++;
+	}
+
+	/* Any errors? uninstall  */
+	if (error) {
+		fsinst = fs_to_install;
+
+		while (fsinst->fst) {
+			if (fsinst->installed) {
+				unregister_filesystem(fsinst->fst);
+				fsinst->installed = 0;
+			}
+			fsinst++;
+		}
+	}
+
+	return error;
+}
+
+static void __exit exit_yaffs_fs(void)
+{
+
+	struct file_system_to_install *fsinst;
+
+	T(YAFFS_TRACE_ALWAYS, ("yaffs " __DATE__ " " __TIME__
+			       " removing. \n"));
+
+	remove_proc_entry("yaffs", YPROC_ROOT);
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst) {
+		if (fsinst->installed) {
+			unregister_filesystem(fsinst->fst);
+			fsinst->installed = 0;
+		}
+		fsinst++;
+	}
+}
+
+module_init(init_yaffs_fs)
+module_exit(exit_yaffs_fs)
+
+MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
+MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2006");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_getblockinfo.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_getblockinfo.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_getblockinfo.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_getblockinfo.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,34 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_GETBLOCKINFO_H__
+#define __YAFFS_GETBLOCKINFO_H__
+
+#include "yaffs_guts.h"
+
+/* Function to manipulate block info */
+static Y_INLINE yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blk)
+{
+	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {
+		T(YAFFS_TRACE_ERROR,
+		  (TSTR
+		   ("**>> yaffs: getBlockInfo block %d is not valid" TENDSTR),
+		   blk));
+		YBUG();
+	}
+	return &dev->blockInfo[blk - dev->internalStartBlock];
+}
+
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_guts.c iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_guts.c
--- linux-2.6.32-orig/fs/yaffs2/yaffs_guts.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_guts.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,7739 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+const char *yaffs_guts_c_version =
+    "$Id$";
+
+#include "yportenv.h"
+
+#include "yaffsinterface.h"
+#include "yaffs_guts.h"
+#include "yaffs_tagsvalidity.h"
+#include "yaffs_getblockinfo.h"
+
+#include "yaffs_tagscompat.h"
+#ifndef CONFIG_YAFFS_USE_OWN_SORT
+#include "yaffs_qsort.h"
+#endif
+#include "yaffs_nand.h"
+
+#include "yaffs_checkptrw.h"
+
+#include "yaffs_nand.h"
+#include "yaffs_packedtags2.h"
+
+
+#define YAFFS_PASSIVE_GC_CHUNKS 2
+
+#include "yaffs_ecc.h"
+
+
+/* Robustification (if it ever comes about...) */
+static void yaffs_RetireBlock(yaffs_Device *dev, int blockInNAND);
+static void yaffs_HandleWriteChunkError(yaffs_Device *dev, int chunkInNAND,
+		int erasedOk);
+static void yaffs_HandleWriteChunkOk(yaffs_Device *dev, int chunkInNAND,
+				const __u8 *data,
+				const yaffs_ExtendedTags *tags);
+static void yaffs_HandleUpdateChunk(yaffs_Device *dev, int chunkInNAND,
+				const yaffs_ExtendedTags *tags);
+
+/* Other local prototypes */
+static void yaffs_UpdateParent(yaffs_Object *obj);
+static int yaffs_UnlinkObject(yaffs_Object *obj);
+static int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj);
+
+static void yaffs_HardlinkFixup(yaffs_Device *dev, yaffs_Object *hardList);
+
+static int yaffs_WriteNewChunkWithTagsToNAND(yaffs_Device *dev,
+					const __u8 *buffer,
+					yaffs_ExtendedTags *tags,
+					int useReserve);
+static int yaffs_PutChunkIntoFile(yaffs_Object *in, int chunkInInode,
+				int chunkInNAND, int inScan);
+
+static yaffs_Object *yaffs_CreateNewObject(yaffs_Device *dev, int number,
+					yaffs_ObjectType type);
+static void yaffs_AddObjectToDirectory(yaffs_Object *directory,
+				yaffs_Object *obj);
+static int yaffs_UpdateObjectHeader(yaffs_Object *in, const YCHAR *name,
+				int force, int isShrink, int shadows);
+static void yaffs_RemoveObjectFromDirectory(yaffs_Object *obj);
+static int yaffs_CheckStructures(void);
+static int yaffs_DeleteWorker(yaffs_Object *in, yaffs_Tnode *tn, __u32 level,
+			int chunkOffset, int *limit);
+static int yaffs_DoGenericObjectDeletion(yaffs_Object *in);
+
+static yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device *dev, int blockNo);
+
+
+static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,
+				int chunkInNAND);
+
+static int yaffs_UnlinkWorker(yaffs_Object *obj);
+
+static int yaffs_TagsMatch(const yaffs_ExtendedTags *tags, int objectId,
+			int chunkInObject);
+
+static int yaffs_AllocateChunk(yaffs_Device *dev, int useReserve,
+				yaffs_BlockInfo **blockUsedPtr);
+
+static void yaffs_VerifyFreeChunks(yaffs_Device *dev);
+
+static void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in);
+
+static void yaffs_VerifyDirectory(yaffs_Object *directory);
+#ifdef YAFFS_PARANOID
+static int yaffs_CheckFileSanity(yaffs_Object *in);
+#else
+#define yaffs_CheckFileSanity(in)
+#endif
+
+static void yaffs_InvalidateWholeChunkCache(yaffs_Object *in);
+static void yaffs_InvalidateChunkCache(yaffs_Object *object, int chunkId);
+
+static void yaffs_InvalidateCheckpoint(yaffs_Device *dev);
+
+static int yaffs_FindChunkInFile(yaffs_Object *in, int chunkInInode,
+				yaffs_ExtendedTags *tags);
+
+static __u32 yaffs_GetChunkGroupBase(yaffs_Device *dev, yaffs_Tnode *tn,
+		unsigned pos);
+static yaffs_Tnode *yaffs_FindLevel0Tnode(yaffs_Device *dev,
+					yaffs_FileStructure *fStruct,
+					__u32 chunkId);
+
+/* Function to calculate chunk and offset */
+
+static void yaffs_AddrToChunk(yaffs_Device *dev, loff_t addr, int *chunkOut,
+		__u32 *offsetOut)
+{
+	int chunk;
+	__u32 offset;
+
+	chunk  = (__u32)(addr >> dev->chunkShift);
+
+	if (dev->chunkDiv == 1) {
+		/* easy power of 2 case */
+		offset = (__u32)(addr & dev->chunkMask);
+	} else {
+		/* Non power-of-2 case */
+
+		loff_t chunkBase;
+
+		chunk /= dev->chunkDiv;
+
+		chunkBase = ((loff_t)chunk) * dev->nDataBytesPerChunk;
+		offset = (__u32)(addr - chunkBase);
+	}
+
+	*chunkOut = chunk;
+	*offsetOut = offset;
+}
+
+/* Function to return the number of shifts for a power of 2 greater than or
+ * equal to the given number
+ * Note we don't try to cater for all possible numbers and this does not have to
+ * be hellishly efficient.
+ */
+
+static __u32 ShiftsGE(__u32 x)
+{
+	int extraBits;
+	int nShifts;
+
+	nShifts = extraBits = 0;
+
+	while (x > 1) {
+		if (x & 1)
+			extraBits++;
+		x >>= 1;
+		nShifts++;
+	}
+
+	if (extraBits)
+		nShifts++;
+
+	return nShifts;
+}
+
+/* Function to return the number of shifts to get a 1 in bit 0
+ */
+
+static __u32 Shifts(__u32 x)
+{
+	int nShifts;
+
+	nShifts =  0;
+
+	if (!x)
+		return 0;
+
+	while (!(x&1)) {
+		x >>= 1;
+		nShifts++;
+	}
+
+	return nShifts;
+}
+
+
+
+/*
+ * Temporary buffer manipulations.
+ */
+
+static int yaffs_InitialiseTempBuffers(yaffs_Device *dev)
+{
+	int i;
+	__u8 *buf = (__u8 *)1;
+
+	memset(dev->tempBuffer, 0, sizeof(dev->tempBuffer));
+
+	for (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {
+		dev->tempBuffer[i].line = 0;	/* not in use */
+		dev->tempBuffer[i].buffer = buf =
+		    YMALLOC_DMA(dev->totalBytesPerChunk);
+	}
+
+	return buf ? YAFFS_OK : YAFFS_FAIL;
+}
+
+__u8 *yaffs_GetTempBuffer(yaffs_Device *dev, int lineNo)
+{
+	int i, j;
+
+	dev->tempInUse++;
+	if (dev->tempInUse > dev->maxTemp)
+		dev->maxTemp = dev->tempInUse;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->tempBuffer[i].line == 0) {
+			dev->tempBuffer[i].line = lineNo;
+			if ((i + 1) > dev->maxTemp) {
+				dev->maxTemp = i + 1;
+				for (j = 0; j <= i; j++)
+					dev->tempBuffer[j].maxLine =
+					    dev->tempBuffer[j].line;
+			}
+
+			return dev->tempBuffer[i].buffer;
+		}
+	}
+
+	T(YAFFS_TRACE_BUFFERS,
+	  (TSTR("Out of temp buffers at line %d, other held by lines:"),
+	   lineNo));
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++)
+		T(YAFFS_TRACE_BUFFERS, (TSTR(" %d "), dev->tempBuffer[i].line));
+
+	T(YAFFS_TRACE_BUFFERS, (TSTR(" " TENDSTR)));
+
+	/*
+	 * If we got here then we have to allocate an unmanaged one
+	 * This is not good.
+	 */
+
+	dev->unmanagedTempAllocations++;
+	return YMALLOC(dev->nDataBytesPerChunk);
+
+}
+
+void yaffs_ReleaseTempBuffer(yaffs_Device *dev, __u8 *buffer,
+				    int lineNo)
+{
+	int i;
+
+	dev->tempInUse--;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->tempBuffer[i].buffer == buffer) {
+			dev->tempBuffer[i].line = 0;
+			return;
+		}
+	}
+
+	if (buffer) {
+		/* assume it is an unmanaged one. */
+		T(YAFFS_TRACE_BUFFERS,
+		  (TSTR("Releasing unmanaged temp buffer in line %d" TENDSTR),
+		   lineNo));
+		YFREE(buffer);
+		dev->unmanagedTempDeallocations++;
+	}
+
+}
+
+/*
+ * Determine if we have a managed buffer.
+ */
+int yaffs_IsManagedTempBuffer(yaffs_Device *dev, const __u8 *buffer)
+{
+	int i;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->tempBuffer[i].buffer == buffer)
+			return 1;
+	}
+
+	for (i = 0; i < dev->nShortOpCaches; i++) {
+		if (dev->srCache[i].data == buffer)
+			return 1;
+	}
+
+	if (buffer == dev->checkpointBuffer)
+		return 1;
+
+	T(YAFFS_TRACE_ALWAYS,
+		(TSTR("yaffs: unmaged buffer detected.\n" TENDSTR)));
+	return 0;
+}
+
+
+
+/*
+ * Chunk bitmap manipulations
+ */
+
+static Y_INLINE __u8 *yaffs_BlockBits(yaffs_Device *dev, int blk)
+{
+	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {
+		T(YAFFS_TRACE_ERROR,
+			(TSTR("**>> yaffs: BlockBits block %d is not valid" TENDSTR),
+			blk));
+		YBUG();
+	}
+	return dev->chunkBits +
+		(dev->chunkBitmapStride * (blk - dev->internalStartBlock));
+}
+
+static Y_INLINE void yaffs_VerifyChunkBitId(yaffs_Device *dev, int blk, int chunk)
+{
+	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock ||
+			chunk < 0 || chunk >= dev->nChunksPerBlock) {
+		T(YAFFS_TRACE_ERROR,
+		(TSTR("**>> yaffs: Chunk Id (%d:%d) invalid"TENDSTR),
+			blk, chunk));
+		YBUG();
+	}
+}
+
+static Y_INLINE void yaffs_ClearChunkBits(yaffs_Device *dev, int blk)
+{
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+
+	memset(blkBits, 0, dev->chunkBitmapStride);
+}
+
+static Y_INLINE void yaffs_ClearChunkBit(yaffs_Device *dev, int blk, int chunk)
+{
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+
+	yaffs_VerifyChunkBitId(dev, blk, chunk);
+
+	blkBits[chunk / 8] &= ~(1 << (chunk & 7));
+}
+
+static Y_INLINE void yaffs_SetChunkBit(yaffs_Device *dev, int blk, int chunk)
+{
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+
+	yaffs_VerifyChunkBitId(dev, blk, chunk);
+
+	blkBits[chunk / 8] |= (1 << (chunk & 7));
+}
+
+static Y_INLINE int yaffs_CheckChunkBit(yaffs_Device *dev, int blk, int chunk)
+{
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+	yaffs_VerifyChunkBitId(dev, blk, chunk);
+
+	return (blkBits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;
+}
+
+static Y_INLINE int yaffs_StillSomeChunkBits(yaffs_Device *dev, int blk)
+{
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+	int i;
+	for (i = 0; i < dev->chunkBitmapStride; i++) {
+		if (*blkBits)
+			return 1;
+		blkBits++;
+	}
+	return 0;
+}
+
+static int yaffs_CountChunkBits(yaffs_Device *dev, int blk)
+{
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+	int i;
+	int n = 0;
+	for (i = 0; i < dev->chunkBitmapStride; i++) {
+		__u8 x = *blkBits;
+		while (x) {
+			if (x & 1)
+				n++;
+			x >>= 1;
+		}
+
+		blkBits++;
+	}
+	return n;
+}
+
+/*
+ * Verification code
+ */
+
+static int yaffs_SkipVerification(yaffs_Device *dev)
+{
+	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
+}
+
+static int yaffs_SkipFullVerification(yaffs_Device *dev)
+{
+	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_FULL));
+}
+
+static int yaffs_SkipNANDVerification(yaffs_Device *dev)
+{
+	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_NAND));
+}
+
+static const char *blockStateName[] = {
+"Unknown",
+"Needs scanning",
+"Scanning",
+"Empty",
+"Allocating",
+"Full",
+"Dirty",
+"Checkpoint",
+"Collecting",
+"Dead"
+};
+
+static void yaffs_VerifyBlock(yaffs_Device *dev, yaffs_BlockInfo *bi, int n)
+{
+	int actuallyUsed;
+	int inUse;
+
+	if (yaffs_SkipVerification(dev))
+		return;
+
+	/* Report illegal runtime states */
+	if (bi->blockState >= YAFFS_NUMBER_OF_BLOCK_STATES)
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has undefined state %d"TENDSTR), n, bi->blockState));
+
+	switch (bi->blockState) {
+	case YAFFS_BLOCK_STATE_UNKNOWN:
+	case YAFFS_BLOCK_STATE_SCANNING:
+	case YAFFS_BLOCK_STATE_NEEDS_SCANNING:
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has bad run-state %s"TENDSTR),
+		n, blockStateName[bi->blockState]));
+	}
+
+	/* Check pages in use and soft deletions are legal */
+
+	actuallyUsed = bi->pagesInUse - bi->softDeletions;
+
+	if (bi->pagesInUse < 0 || bi->pagesInUse > dev->nChunksPerBlock ||
+	   bi->softDeletions < 0 || bi->softDeletions > dev->nChunksPerBlock ||
+	   actuallyUsed < 0 || actuallyUsed > dev->nChunksPerBlock)
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has illegal values pagesInUsed %d softDeletions %d"TENDSTR),
+		n, bi->pagesInUse, bi->softDeletions));
+
+
+	/* Check chunk bitmap legal */
+	inUse = yaffs_CountChunkBits(dev, n);
+	if (inUse != bi->pagesInUse)
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has inconsistent values pagesInUse %d counted chunk bits %d"TENDSTR),
+			n, bi->pagesInUse, inUse));
+
+	/* Check that the sequence number is valid.
+	 * Ten million is legal, but is very unlikely
+	 */
+	if (dev->isYaffs2 &&
+	   (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING || bi->blockState == YAFFS_BLOCK_STATE_FULL) &&
+	   (bi->sequenceNumber < YAFFS_LOWEST_SEQUENCE_NUMBER || bi->sequenceNumber > 10000000))
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has suspect sequence number of %d"TENDSTR),
+		n, bi->sequenceNumber));
+}
+
+static void yaffs_VerifyCollectedBlock(yaffs_Device *dev, yaffs_BlockInfo *bi,
+		int n)
+{
+	yaffs_VerifyBlock(dev, bi, n);
+
+	/* After collection the block should be in the erased state */
+	/* This will need to change if we do partial gc */
+
+	if (bi->blockState != YAFFS_BLOCK_STATE_COLLECTING &&
+			bi->blockState != YAFFS_BLOCK_STATE_EMPTY) {
+		T(YAFFS_TRACE_ERROR, (TSTR("Block %d is in state %d after gc, should be erased"TENDSTR),
+			n, bi->blockState));
+	}
+}
+
+static void yaffs_VerifyBlocks(yaffs_Device *dev)
+{
+	int i;
+	int nBlocksPerState[YAFFS_NUMBER_OF_BLOCK_STATES];
+	int nIllegalBlockStates = 0;
+
+	if (yaffs_SkipVerification(dev))
+		return;
+
+	memset(nBlocksPerState, 0, sizeof(nBlocksPerState));
+
+	for (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {
+		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, i);
+		yaffs_VerifyBlock(dev, bi, i);
+
+		if (bi->blockState < YAFFS_NUMBER_OF_BLOCK_STATES)
+			nBlocksPerState[bi->blockState]++;
+		else
+			nIllegalBlockStates++;
+	}
+
+	T(YAFFS_TRACE_VERIFY, (TSTR(""TENDSTR)));
+	T(YAFFS_TRACE_VERIFY, (TSTR("Block summary"TENDSTR)));
+
+	T(YAFFS_TRACE_VERIFY, (TSTR("%d blocks have illegal states"TENDSTR), nIllegalBlockStates));
+	if (nBlocksPerState[YAFFS_BLOCK_STATE_ALLOCATING] > 1)
+		T(YAFFS_TRACE_VERIFY, (TSTR("Too many allocating blocks"TENDSTR)));
+
+	for (i = 0; i < YAFFS_NUMBER_OF_BLOCK_STATES; i++)
+		T(YAFFS_TRACE_VERIFY,
+		  (TSTR("%s %d blocks"TENDSTR),
+		  blockStateName[i], nBlocksPerState[i]));
+
+	if (dev->blocksInCheckpoint != nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT])
+		T(YAFFS_TRACE_VERIFY,
+		 (TSTR("Checkpoint block count wrong dev %d count %d"TENDSTR),
+		 dev->blocksInCheckpoint, nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT]));
+
+	if (dev->nErasedBlocks != nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY])
+		T(YAFFS_TRACE_VERIFY,
+		 (TSTR("Erased block count wrong dev %d count %d"TENDSTR),
+		 dev->nErasedBlocks, nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY]));
+
+	if (nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING] > 1)
+		T(YAFFS_TRACE_VERIFY,
+		 (TSTR("Too many collecting blocks %d (max is 1)"TENDSTR),
+		 nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING]));
+
+	T(YAFFS_TRACE_VERIFY, (TSTR(""TENDSTR)));
+
+}
+
+/*
+ * Verify the object header. oh must be valid, but obj and tags may be NULL in which
+ * case those tests will not be performed.
+ */
+static void yaffs_VerifyObjectHeader(yaffs_Object *obj, yaffs_ObjectHeader *oh, yaffs_ExtendedTags *tags, int parentCheck)
+{
+	if (obj && yaffs_SkipVerification(obj->myDev))
+		return;
+
+	if (!(tags && obj && oh)) {
+		T(YAFFS_TRACE_VERIFY,
+				(TSTR("Verifying object header tags %x obj %x oh %x"TENDSTR),
+				(__u32)tags, (__u32)obj, (__u32)oh));
+		return;
+	}
+
+	if (oh->type <= YAFFS_OBJECT_TYPE_UNKNOWN ||
+			oh->type > YAFFS_OBJECT_TYPE_MAX)
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header type is illegal value 0x%x"TENDSTR),
+			tags->objectId, oh->type));
+
+	if (tags->objectId != obj->objectId)
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header mismatch objectId %d"TENDSTR),
+			tags->objectId, obj->objectId));
+
+
+	/*
+	 * Check that the object's parent ids match if parentCheck requested.
+	 *
+	 * Tests do not apply to the root object.
+	 */
+
+	if (parentCheck && tags->objectId > 1 && !obj->parent)
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header mismatch parentId %d obj->parent is NULL"TENDSTR),
+			tags->objectId, oh->parentObjectId));
+
+	if (parentCheck && obj->parent &&
+			oh->parentObjectId != obj->parent->objectId &&
+			(oh->parentObjectId != YAFFS_OBJECTID_UNLINKED ||
+			obj->parent->objectId != YAFFS_OBJECTID_DELETED))
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header mismatch parentId %d parentObjectId %d"TENDSTR),
+			tags->objectId, oh->parentObjectId, obj->parent->objectId));
+
+	if (tags->objectId > 1 && oh->name[0] == 0) /* Null name */
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header name is NULL"TENDSTR),
+			obj->objectId));
+
+	if (tags->objectId > 1 && ((__u8)(oh->name[0])) == 0xff) /* Trashed name */
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header name is 0xFF"TENDSTR),
+			obj->objectId));
+}
+
+
+
+static int yaffs_VerifyTnodeWorker(yaffs_Object *obj, yaffs_Tnode *tn,
+					__u32 level, int chunkOffset)
+{
+	int i;
+	yaffs_Device *dev = obj->myDev;
+	int ok = 1;
+
+	if (tn) {
+		if (level > 0) {
+
+			for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
+				if (tn->internal[i]) {
+					ok = yaffs_VerifyTnodeWorker(obj,
+							tn->internal[i],
+							level - 1,
+							(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);
+				}
+			}
+		} else if (level == 0) {
+			yaffs_ExtendedTags tags;
+			__u32 objectId = obj->objectId;
+
+			chunkOffset <<=  YAFFS_TNODES_LEVEL0_BITS;
+
+			for (i = 0; i < YAFFS_NTNODES_LEVEL0; i++) {
+				__u32 theChunk = yaffs_GetChunkGroupBase(dev, tn, i);
+
+				if (theChunk > 0) {
+					/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),tags.objectId,tags.chunkId,theChunk)); */
+					yaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL, &tags);
+					if (tags.objectId != objectId || tags.chunkId != chunkOffset) {
+						T(~0, (TSTR("Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),
+							objectId, chunkOffset, theChunk,
+							tags.objectId, tags.chunkId));
+					}
+				}
+				chunkOffset++;
+			}
+		}
+	}
+
+	return ok;
+
+}
+
+
+static void yaffs_VerifyFile(yaffs_Object *obj)
+{
+	int requiredTallness;
+	int actualTallness;
+	__u32 lastChunk;
+	__u32 x;
+	__u32 i;
+	yaffs_Device *dev;
+	yaffs_ExtendedTags tags;
+	yaffs_Tnode *tn;
+	__u32 objectId;
+
+	if (!obj)
+		return;
+
+	if (yaffs_SkipVerification(obj->myDev))
+		return;
+
+	dev = obj->myDev;
+	objectId = obj->objectId;
+
+	/* Check file size is consistent with tnode depth */
+	lastChunk =  obj->variant.fileVariant.fileSize / dev->nDataBytesPerChunk + 1;
+	x = lastChunk >> YAFFS_TNODES_LEVEL0_BITS;
+	requiredTallness = 0;
+	while (x > 0) {
+		x >>= YAFFS_TNODES_INTERNAL_BITS;
+		requiredTallness++;
+	}
+
+	actualTallness = obj->variant.fileVariant.topLevel;
+
+	if (requiredTallness > actualTallness)
+		T(YAFFS_TRACE_VERIFY,
+		(TSTR("Obj %d had tnode tallness %d, needs to be %d"TENDSTR),
+		 obj->objectId, actualTallness, requiredTallness));
+
+
+	/* Check that the chunks in the tnode tree are all correct.
+	 * We do this by scanning through the tnode tree and
+	 * checking the tags for every chunk match.
+	 */
+
+	if (yaffs_SkipNANDVerification(dev))
+		return;
+
+	for (i = 1; i <= lastChunk; i++) {
+		tn = yaffs_FindLevel0Tnode(dev, &obj->variant.fileVariant, i);
+
+		if (tn) {
+			__u32 theChunk = yaffs_GetChunkGroupBase(dev, tn, i);
+			if (theChunk > 0) {
+				/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),objectId,i,theChunk)); */
+				yaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL, &tags);
+				if (tags.objectId != objectId || tags.chunkId != i) {
+					T(~0, (TSTR("Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),
+						objectId, i, theChunk,
+						tags.objectId, tags.chunkId));
+				}
+			}
+		}
+	}
+}
+
+
+static void yaffs_VerifyHardLink(yaffs_Object *obj)
+{
+	if (obj && yaffs_SkipVerification(obj->myDev))
+		return;
+
+	/* Verify sane equivalent object */
+}
+
+static void yaffs_VerifySymlink(yaffs_Object *obj)
+{
+	if (obj && yaffs_SkipVerification(obj->myDev))
+		return;
+
+	/* Verify symlink string */
+}
+
+static void yaffs_VerifySpecial(yaffs_Object *obj)
+{
+	if (obj && yaffs_SkipVerification(obj->myDev))
+		return;
+}
+
+static void yaffs_VerifyObject(yaffs_Object *obj)
+{
+	yaffs_Device *dev;
+
+	__u32 chunkMin;
+	__u32 chunkMax;
+
+	__u32 chunkIdOk;
+	__u32 chunkInRange;
+	__u32 chunkShouldNotBeDeleted;
+	__u32 chunkValid;
+
+	if (!obj)
+		return;
+
+	if (obj->beingCreated)
+		return;
+
+	dev = obj->myDev;
+
+	if (yaffs_SkipVerification(dev))
+		return;
+
+	/* Check sane object header chunk */
+
+	chunkMin = dev->internalStartBlock * dev->nChunksPerBlock;
+	chunkMax = (dev->internalEndBlock+1) * dev->nChunksPerBlock - 1;
+
+	chunkInRange = (((unsigned)(obj->hdrChunk)) >= chunkMin && ((unsigned)(obj->hdrChunk)) <= chunkMax);
+	chunkIdOk = chunkInRange || (obj->hdrChunk == 0);
+	chunkValid = chunkInRange &&
+			yaffs_CheckChunkBit(dev,
+					obj->hdrChunk / dev->nChunksPerBlock,
+					obj->hdrChunk % dev->nChunksPerBlock);
+	chunkShouldNotBeDeleted = chunkInRange && !chunkValid;
+
+	if (!obj->fake &&
+			(!chunkIdOk || chunkShouldNotBeDeleted)) {
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d has chunkId %d %s %s"TENDSTR),
+			obj->objectId, obj->hdrChunk,
+			chunkIdOk ? "" : ",out of range",
+			chunkShouldNotBeDeleted ? ",marked as deleted" : ""));
+	}
+
+	if (chunkValid && !yaffs_SkipNANDVerification(dev)) {
+		yaffs_ExtendedTags tags;
+		yaffs_ObjectHeader *oh;
+		__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);
+
+		oh = (yaffs_ObjectHeader *)buffer;
+
+		yaffs_ReadChunkWithTagsFromNAND(dev, obj->hdrChunk, buffer,
+				&tags);
+
+		yaffs_VerifyObjectHeader(obj, oh, &tags, 1);
+
+		yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
+	}
+
+	/* Verify it has a parent */
+	if (obj && !obj->fake &&
+			(!obj->parent || obj->parent->myDev != dev)) {
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d has parent pointer %p which does not look like an object"TENDSTR),
+			obj->objectId, obj->parent));
+	}
+
+	/* Verify parent is a directory */
+	if (obj->parent && obj->parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d's parent is not a directory (type %d)"TENDSTR),
+			obj->objectId, obj->parent->variantType));
+	}
+
+	switch (obj->variantType) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		yaffs_VerifyFile(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		yaffs_VerifySymlink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		yaffs_VerifyDirectory(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		yaffs_VerifyHardLink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		yaffs_VerifySpecial(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+	default:
+		T(YAFFS_TRACE_VERIFY,
+		(TSTR("Obj %d has illegaltype %d"TENDSTR),
+		obj->objectId, obj->variantType));
+		break;
+	}
+}
+
+static void yaffs_VerifyObjects(yaffs_Device *dev)
+{
+	yaffs_Object *obj;
+	int i;
+	struct ylist_head *lh;
+
+	if (yaffs_SkipVerification(dev))
+		return;
+
+	/* Iterate through the objects in each hash entry */
+
+	for (i = 0; i <  YAFFS_NOBJECT_BUCKETS; i++) {
+		ylist_for_each(lh, &dev->objectBucket[i].list) {
+			if (lh) {
+				obj = ylist_entry(lh, yaffs_Object, hashLink);
+				yaffs_VerifyObject(obj);
+			}
+		}
+	}
+}
+
+
+/*
+ *  Simple hash function. Needs to have a reasonable spread
+ */
+
+static Y_INLINE int yaffs_HashFunction(int n)
+{
+	n = abs(n);
+	return n % YAFFS_NOBJECT_BUCKETS;
+}
+
+/*
+ * Access functions to useful fake objects.
+ * Note that root might have a presence in NAND if permissions are set.
+ */
+
+yaffs_Object *yaffs_Root(yaffs_Device *dev)
+{
+	return dev->rootDir;
+}
+
+yaffs_Object *yaffs_LostNFound(yaffs_Device *dev)
+{
+	return dev->lostNFoundDir;
+}
+
+
+/*
+ *  Erased NAND checking functions
+ */
+
+int yaffs_CheckFF(__u8 *buffer, int nBytes)
+{
+	/* Horrible, slow implementation */
+	while (nBytes--) {
+		if (*buffer != 0xFF)
+			return 0;
+		buffer++;
+	}
+	return 1;
+}
+
+static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,
+				int chunkInNAND)
+{
+	int retval = YAFFS_OK;
+	__u8 *data = yaffs_GetTempBuffer(dev, __LINE__);
+	yaffs_ExtendedTags tags;
+	int result;
+
+	result = yaffs_ReadChunkWithTagsFromNAND(dev, chunkInNAND, data, &tags);
+
+	if (tags.eccResult > YAFFS_ECC_RESULT_NO_ERROR)
+		retval = YAFFS_FAIL;
+
+	if (!yaffs_CheckFF(data, dev->nDataBytesPerChunk) || tags.chunkUsed) {
+		T(YAFFS_TRACE_NANDACCESS,
+		  (TSTR("Chunk %d not erased" TENDSTR), chunkInNAND));
+		retval = YAFFS_FAIL;
+	}
+
+	yaffs_ReleaseTempBuffer(dev, data, __LINE__);
+
+	return retval;
+
+}
+
+static int yaffs_WriteNewChunkWithTagsToNAND(struct yaffs_DeviceStruct *dev,
+					const __u8 *data,
+					yaffs_ExtendedTags *tags,
+					int useReserve)
+{
+	int attempts = 0;
+	int writeOk = 0;
+	int chunk;
+
+	yaffs_InvalidateCheckpoint(dev);
+
+	do {
+		yaffs_BlockInfo *bi = 0;
+		int erasedOk = 0;
+
+		chunk = yaffs_AllocateChunk(dev, useReserve, &bi);
+		if (chunk < 0) {
+			/* no space */
+			break;
+		}
+
+		/* First check this chunk is erased, if it needs
+		 * checking.  The checking policy (unless forced
+		 * always on) is as follows:
+		 *
+		 * Check the first page we try to write in a block.
+		 * If the check passes then we don't need to check any
+		 * more.	If the check fails, we check again...
+		 * If the block has been erased, we don't need to check.
+		 *
+		 * However, if the block has been prioritised for gc,
+		 * then we think there might be something odd about
+		 * this block and stop using it.
+		 *
+		 * Rationale: We should only ever see chunks that have
+		 * not been erased if there was a partially written
+		 * chunk due to power loss.  This checking policy should
+		 * catch that case with very few checks and thus save a
+		 * lot of checks that are most likely not needed.
+		 */
+		if (bi->gcPrioritise) {
+			yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
+			/* try another chunk */
+			continue;
+		}
+
+		/* let's give it a try */
+		attempts++;
+
+#ifdef CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+		bi->skipErasedCheck = 0;
+#endif
+		if (!bi->skipErasedCheck) {
+			erasedOk = yaffs_CheckChunkErased(dev, chunk);
+			if (erasedOk != YAFFS_OK) {
+				T(YAFFS_TRACE_ERROR,
+				(TSTR("**>> yaffs chunk %d was not erased"
+				TENDSTR), chunk));
+
+				/* try another chunk */
+				continue;
+			}
+			bi->skipErasedCheck = 1;
+		}
+
+		writeOk = yaffs_WriteChunkWithTagsToNAND(dev, chunk,
+				data, tags);
+		if (writeOk != YAFFS_OK) {
+			yaffs_HandleWriteChunkError(dev, chunk, erasedOk);
+			/* try another chunk */
+			continue;
+		}
+
+		/* Copy the data into the robustification buffer */
+		yaffs_HandleWriteChunkOk(dev, chunk, data, tags);
+
+	} while (writeOk != YAFFS_OK &&
+		(yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));
+
+	if (!writeOk)
+		chunk = -1;
+
+	if (attempts > 1) {
+		T(YAFFS_TRACE_ERROR,
+			(TSTR("**>> yaffs write required %d attempts" TENDSTR),
+			attempts));
+
+		dev->nRetriedWrites += (attempts - 1);
+	}
+
+	return chunk;
+}
+
+/*
+ * Block retiring for handling a broken block.
+ */
+
+static void yaffs_RetireBlock(yaffs_Device *dev, int blockInNAND)
+{
+	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);
+
+	yaffs_InvalidateCheckpoint(dev);
+
+	if (yaffs_MarkBlockBad(dev, blockInNAND) != YAFFS_OK) {
+		if (yaffs_EraseBlockInNAND(dev, blockInNAND) != YAFFS_OK) {
+			T(YAFFS_TRACE_ALWAYS, (TSTR(
+				"yaffs: Failed to mark bad and erase block %d"
+				TENDSTR), blockInNAND));
+		} else {
+			yaffs_ExtendedTags tags;
+			int chunkId = blockInNAND * dev->nChunksPerBlock;
+
+			__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);
+
+			memset(buffer, 0xff, dev->nDataBytesPerChunk);
+			yaffs_InitialiseTags(&tags);
+			tags.sequenceNumber = YAFFS_SEQUENCE_BAD_BLOCK;
+			if (dev->writeChunkWithTagsToNAND(dev, chunkId -
+				dev->chunkOffset, buffer, &tags) != YAFFS_OK)
+				T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Failed to "
+					TCONT("write bad block marker to block %d")
+					TENDSTR), blockInNAND));
+
+			yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
+		}
+	}
+
+	bi->blockState = YAFFS_BLOCK_STATE_DEAD;
+	bi->gcPrioritise = 0;
+	bi->needsRetiring = 0;
+
+	dev->nRetiredBlocks++;
+}
+
+/*
+ * Functions for robustisizing TODO
+ *
+ */
+
+static void yaffs_HandleWriteChunkOk(yaffs_Device *dev, int chunkInNAND,
+				const __u8 *data,
+				const yaffs_ExtendedTags *tags)
+{
+}
+
+static void yaffs_HandleUpdateChunk(yaffs_Device *dev, int chunkInNAND,
+				const yaffs_ExtendedTags *tags)
+{
+}
+
+void yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi)
+{
+	if (!bi->gcPrioritise) {
+		bi->gcPrioritise = 1;
+		dev->hasPendingPrioritisedGCs = 1;
+		bi->chunkErrorStrikes++;
+
+		if (bi->chunkErrorStrikes > 3) {
+			bi->needsRetiring = 1; /* Too many stikes, so retire this */
+			T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Block struck out" TENDSTR)));
+
+		}
+	}
+}
+
+static void yaffs_HandleWriteChunkError(yaffs_Device *dev, int chunkInNAND,
+		int erasedOk)
+{
+	int blockInNAND = chunkInNAND / dev->nChunksPerBlock;
+	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);
+
+	yaffs_HandleChunkError(dev, bi);
+
+	if (erasedOk) {
+		/* Was an actual write failure, so mark the block for retirement  */
+		bi->needsRetiring = 1;
+		T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		  (TSTR("**>> Block %d needs retiring" TENDSTR), blockInNAND));
+	}
+
+	/* Delete the chunk */
+	yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
+}
+
+
+/*---------------- Name handling functions ------------*/
+
+static __u16 yaffs_CalcNameSum(const YCHAR *name)
+{
+	__u16 sum = 0;
+	__u16 i = 1;
+
+	const YUCHAR *bname = (const YUCHAR *) name;
+	if (bname) {
+		while ((*bname) && (i < (YAFFS_MAX_NAME_LENGTH/2))) {
+
+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE
+			sum += yaffs_toupper(*bname) * i;
+#else
+			sum += (*bname) * i;
+#endif
+			i++;
+			bname++;
+		}
+	}
+	return sum;
+}
+
+static void yaffs_SetObjectName(yaffs_Object *obj, const YCHAR *name)
+{
+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+	memset(obj->shortName, 0, sizeof(YCHAR) * (YAFFS_SHORT_NAME_LENGTH+1));
+	if (name && yaffs_strlen(name) <= YAFFS_SHORT_NAME_LENGTH)
+		yaffs_strcpy(obj->shortName, name);
+	else
+		obj->shortName[0] = _Y('\0');
+#endif
+	obj->sum = yaffs_CalcNameSum(name);
+}
+
+/*-------------------- TNODES -------------------
+
+ * List of spare tnodes
+ * The list is hooked together using the first pointer
+ * in the tnode.
+ */
+
+/* yaffs_CreateTnodes creates a bunch more tnodes and
+ * adds them to the tnode free list.
+ * Don't use this function directly
+ */
+
+static int yaffs_CreateTnodes(yaffs_Device *dev, int nTnodes)
+{
+	int i;
+	int tnodeSize;
+	yaffs_Tnode *newTnodes;
+	__u8 *mem;
+	yaffs_Tnode *curr;
+	yaffs_Tnode *next;
+	yaffs_TnodeList *tnl;
+
+	if (nTnodes < 1)
+		return YAFFS_OK;
+
+	/* Calculate the tnode size in bytes for variable width tnode support.
+	 * Must be a multiple of 32-bits  */
+	tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
+
+	if (tnodeSize < sizeof(yaffs_Tnode))
+		tnodeSize = sizeof(yaffs_Tnode);
+
+	/* make these things */
+
+	newTnodes = YMALLOC(nTnodes * tnodeSize);
+	mem = (__u8 *)newTnodes;
+
+	if (!newTnodes) {
+		T(YAFFS_TRACE_ERROR,
+			(TSTR("yaffs: Could not allocate Tnodes" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	/* Hook them into the free list */
+#if 0
+	for (i = 0; i < nTnodes - 1; i++) {
+		newTnodes[i].internal[0] = &newTnodes[i + 1];
+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+		newTnodes[i].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
+#endif
+	}
+
+	newTnodes[nTnodes - 1].internal[0] = dev->freeTnodes;
+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+	newTnodes[nTnodes - 1].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
+#endif
+	dev->freeTnodes = newTnodes;
+#else
+	/* New hookup for wide tnodes */
+	for (i = 0; i < nTnodes - 1; i++) {
+		curr = (yaffs_Tnode *) &mem[i * tnodeSize];
+		next = (yaffs_Tnode *) &mem[(i+1) * tnodeSize];
+		curr->internal[0] = next;
+	}
+
+	curr = (yaffs_Tnode *) &mem[(nTnodes - 1) * tnodeSize];
+	curr->internal[0] = dev->freeTnodes;
+	dev->freeTnodes = (yaffs_Tnode *)mem;
+
+#endif
+
+
+	dev->nFreeTnodes += nTnodes;
+	dev->nTnodesCreated += nTnodes;
+
+	/* Now add this bunch of tnodes to a list for freeing up.
+	 * NB If we can't add this to the management list it isn't fatal
+	 * but it just means we can't free this bunch of tnodes later.
+	 */
+
+	tnl = YMALLOC(sizeof(yaffs_TnodeList));
+	if (!tnl) {
+		T(YAFFS_TRACE_ERROR,
+		  (TSTR
+		   ("yaffs: Could not add tnodes to management list" TENDSTR)));
+		   return YAFFS_FAIL;
+	} else {
+		tnl->tnodes = newTnodes;
+		tnl->next = dev->allocatedTnodeList;
+		dev->allocatedTnodeList = tnl;
+	}
+
+	T(YAFFS_TRACE_ALLOCATE, (TSTR("yaffs: Tnodes added" TENDSTR)));
+
+	return YAFFS_OK;
+}
+
+/* GetTnode gets us a clean tnode. Tries to make allocate more if we run out */
+
+static yaffs_Tnode *yaffs_GetTnodeRaw(yaffs_Device *dev)
+{
+	yaffs_Tnode *tn = NULL;
+
+	/* If there are none left make more */
+	if (!dev->freeTnodes)
+		yaffs_CreateTnodes(dev, YAFFS_ALLOCATION_NTNODES);
+
+	if (dev->freeTnodes) {
+		tn = dev->freeTnodes;
+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+		if (tn->internal[YAFFS_NTNODES_INTERNAL] != (void *)1) {
+			/* Hoosterman, this thing looks like it isn't in the list */
+			T(YAFFS_TRACE_ALWAYS,
+			  (TSTR("yaffs: Tnode list bug 1" TENDSTR)));
+		}
+#endif
+		dev->freeTnodes = dev->freeTnodes->internal[0];
+		dev->nFreeTnodes--;
+	}
+
+	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
+
+	return tn;
+}
+
+static yaffs_Tnode *yaffs_GetTnode(yaffs_Device *dev)
+{
+	yaffs_Tnode *tn = yaffs_GetTnodeRaw(dev);
+	int tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
+
+	if (tnodeSize < sizeof(yaffs_Tnode))
+		tnodeSize = sizeof(yaffs_Tnode);
+
+	if (tn)
+		memset(tn, 0, tnodeSize);
+
+	return tn;
+}
+
+/* FreeTnode frees up a tnode and puts it back on the free list */
+static void yaffs_FreeTnode(yaffs_Device *dev, yaffs_Tnode *tn)
+{
+	if (tn) {
+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+		if (tn->internal[YAFFS_NTNODES_INTERNAL] != 0) {
+			/* Hoosterman, this thing looks like it is already in the list */
+			T(YAFFS_TRACE_ALWAYS,
+			  (TSTR("yaffs: Tnode list bug 2" TENDSTR)));
+		}
+		tn->internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
+#endif
+		tn->internal[0] = dev->freeTnodes;
+		dev->freeTnodes = tn;
+		dev->nFreeTnodes++;
+	}
+	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
+}
+
+static void yaffs_DeinitialiseTnodes(yaffs_Device *dev)
+{
+	/* Free the list of allocated tnodes */
+	yaffs_TnodeList *tmp;
+
+	while (dev->allocatedTnodeList) {
+		tmp = dev->allocatedTnodeList->next;
+
+		YFREE(dev->allocatedTnodeList->tnodes);
+		YFREE(dev->allocatedTnodeList);
+		dev->allocatedTnodeList = tmp;
+
+	}
+
+	dev->freeTnodes = NULL;
+	dev->nFreeTnodes = 0;
+}
+
+static void yaffs_InitialiseTnodes(yaffs_Device *dev)
+{
+	dev->allocatedTnodeList = NULL;
+	dev->freeTnodes = NULL;
+	dev->nFreeTnodes = 0;
+	dev->nTnodesCreated = 0;
+}
+
+
+void yaffs_PutLevel0Tnode(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos,
+		unsigned val)
+{
+	__u32 *map = (__u32 *)tn;
+	__u32 bitInMap;
+	__u32 bitInWord;
+	__u32 wordInMap;
+	__u32 mask;
+
+	pos &= YAFFS_TNODES_LEVEL0_MASK;
+	val >>= dev->chunkGroupBits;
+
+	bitInMap = pos * dev->tnodeWidth;
+	wordInMap = bitInMap / 32;
+	bitInWord = bitInMap & (32 - 1);
+
+	mask = dev->tnodeMask << bitInWord;
+
+	map[wordInMap] &= ~mask;
+	map[wordInMap] |= (mask & (val << bitInWord));
+
+	if (dev->tnodeWidth > (32 - bitInWord)) {
+		bitInWord = (32 - bitInWord);
+		wordInMap++;;
+		mask = dev->tnodeMask >> (/*dev->tnodeWidth -*/ bitInWord);
+		map[wordInMap] &= ~mask;
+		map[wordInMap] |= (mask & (val >> bitInWord));
+	}
+}
+
+static __u32 yaffs_GetChunkGroupBase(yaffs_Device *dev, yaffs_Tnode *tn,
+		unsigned pos)
+{
+	__u32 *map = (__u32 *)tn;
+	__u32 bitInMap;
+	__u32 bitInWord;
+	__u32 wordInMap;
+	__u32 val;
+
+	pos &= YAFFS_TNODES_LEVEL0_MASK;
+
+	bitInMap = pos * dev->tnodeWidth;
+	wordInMap = bitInMap / 32;
+	bitInWord = bitInMap & (32 - 1);
+
+	val = map[wordInMap] >> bitInWord;
+
+	if	(dev->tnodeWidth > (32 - bitInWord)) {
+		bitInWord = (32 - bitInWord);
+		wordInMap++;;
+		val |= (map[wordInMap] << bitInWord);
+	}
+
+	val &= dev->tnodeMask;
+	val <<= dev->chunkGroupBits;
+
+	return val;
+}
+
+/* ------------------- End of individual tnode manipulation -----------------*/
+
+/* ---------Functions to manipulate the look-up tree (made up of tnodes) ------
+ * The look up tree is represented by the top tnode and the number of topLevel
+ * in the tree. 0 means only the level 0 tnode is in the tree.
+ */
+
+/* FindLevel0Tnode finds the level 0 tnode, if one exists. */
+static yaffs_Tnode *yaffs_FindLevel0Tnode(yaffs_Device *dev,
+					yaffs_FileStructure *fStruct,
+					__u32 chunkId)
+{
+	yaffs_Tnode *tn = fStruct->top;
+	__u32 i;
+	int requiredTallness;
+	int level = fStruct->topLevel;
+
+	/* Check sane level and chunk Id */
+	if (level < 0 || level > YAFFS_TNODES_MAX_LEVEL)
+		return NULL;
+
+	if (chunkId > YAFFS_MAX_CHUNK_ID)
+		return NULL;
+
+	/* First check we're tall enough (ie enough topLevel) */
+
+	i = chunkId >> YAFFS_TNODES_LEVEL0_BITS;
+	requiredTallness = 0;
+	while (i) {
+		i >>= YAFFS_TNODES_INTERNAL_BITS;
+		requiredTallness++;
+	}
+
+	if (requiredTallness > fStruct->topLevel)
+		return NULL; /* Not tall enough, so we can't find it */
+
+	/* Traverse down to level 0 */
+	while (level > 0 && tn) {
+		tn = tn->internal[(chunkId >>
+			(YAFFS_TNODES_LEVEL0_BITS +
+				(level - 1) *
+				YAFFS_TNODES_INTERNAL_BITS)) &
+			YAFFS_TNODES_INTERNAL_MASK];
+		level--;
+	}
+
+	return tn;
+}
+
+/* AddOrFindLevel0Tnode finds the level 0 tnode if it exists, otherwise first expands the tree.
+ * This happens in two steps:
+ *  1. If the tree isn't tall enough, then make it taller.
+ *  2. Scan down the tree towards the level 0 tnode adding tnodes if required.
+ *
+ * Used when modifying the tree.
+ *
+ *  If the tn argument is NULL, then a fresh tnode will be added otherwise the specified tn will
+ *  be plugged into the ttree.
+ */
+
+static yaffs_Tnode *yaffs_AddOrFindLevel0Tnode(yaffs_Device *dev,
+					yaffs_FileStructure *fStruct,
+					__u32 chunkId,
+					yaffs_Tnode *passedTn)
+{
+	int requiredTallness;
+	int i;
+	int l;
+	yaffs_Tnode *tn;
+
+	__u32 x;
+
+
+	/* Check sane level and page Id */
+	if (fStruct->topLevel < 0 || fStruct->topLevel > YAFFS_TNODES_MAX_LEVEL)
+		return NULL;
+
+	if (chunkId > YAFFS_MAX_CHUNK_ID)
+		return NULL;
+
+	/* First check we're tall enough (ie enough topLevel) */
+
+	x = chunkId >> YAFFS_TNODES_LEVEL0_BITS;
+	requiredTallness = 0;
+	while (x) {
+		x >>= YAFFS_TNODES_INTERNAL_BITS;
+		requiredTallness++;
+	}
+
+
+	if (requiredTallness > fStruct->topLevel) {
+		/* Not tall enough, gotta make the tree taller */
+		for (i = fStruct->topLevel; i < requiredTallness; i++) {
+
+			tn = yaffs_GetTnode(dev);
+
+			if (tn) {
+				tn->internal[0] = fStruct->top;
+				fStruct->top = tn;
+			} else {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR("yaffs: no more tnodes" TENDSTR)));
+			}
+		}
+
+		fStruct->topLevel = requiredTallness;
+	}
+
+	/* Traverse down to level 0, adding anything we need */
+
+	l = fStruct->topLevel;
+	tn = fStruct->top;
+
+	if (l > 0) {
+		while (l > 0 && tn) {
+			x = (chunkId >>
+			     (YAFFS_TNODES_LEVEL0_BITS +
+			      (l - 1) * YAFFS_TNODES_INTERNAL_BITS)) &
+			    YAFFS_TNODES_INTERNAL_MASK;
+
+
+			if ((l > 1) && !tn->internal[x]) {
+				/* Add missing non-level-zero tnode */
+				tn->internal[x] = yaffs_GetTnode(dev);
+
+			} else if (l == 1) {
+				/* Looking from level 1 at level 0 */
+				if (passedTn) {
+					/* If we already have one, then release it.*/
+					if (tn->internal[x])
+						yaffs_FreeTnode(dev, tn->internal[x]);
+					tn->internal[x] = passedTn;
+
+				} else if (!tn->internal[x]) {
+					/* Don't have one, none passed in */
+					tn->internal[x] = yaffs_GetTnode(dev);
+				}
+			}
+
+			tn = tn->internal[x];
+			l--;
+		}
+	} else {
+		/* top is level 0 */
+		if (passedTn) {
+			memcpy(tn, passedTn, (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8);
+			yaffs_FreeTnode(dev, passedTn);
+		}
+	}
+
+	return tn;
+}
+
+static int yaffs_FindChunkInGroup(yaffs_Device *dev, int theChunk,
+				yaffs_ExtendedTags *tags, int objectId,
+				int chunkInInode)
+{
+	int j;
+
+	for (j = 0; theChunk && j < dev->chunkGroupSize; j++) {
+		if (yaffs_CheckChunkBit(dev, theChunk / dev->nChunksPerBlock,
+				theChunk % dev->nChunksPerBlock)) {
+			
+			if(dev->chunkGroupSize == 1)
+				return theChunk;
+			else {
+				yaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL,
+								tags);
+				if (yaffs_TagsMatch(tags, objectId, chunkInInode)) {
+					/* found it; */
+					return theChunk;
+				}
+			}
+		}
+		theChunk++;
+	}
+	return -1;
+}
+
+
+/* DeleteWorker scans backwards through the tnode tree and deletes all the
+ * chunks and tnodes in the file
+ * Returns 1 if the tree was deleted.
+ * Returns 0 if it stopped early due to hitting the limit and the delete is incomplete.
+ */
+
+static int yaffs_DeleteWorker(yaffs_Object *in, yaffs_Tnode *tn, __u32 level,
+			      int chunkOffset, int *limit)
+{
+	int i;
+	int chunkInInode;
+	int theChunk;
+	yaffs_ExtendedTags tags;
+	int foundChunk;
+	yaffs_Device *dev = in->myDev;
+
+	int allDone = 1;
+
+	if (tn) {
+		if (level > 0) {
+			for (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;
+			     i--) {
+				if (tn->internal[i]) {
+					if (limit && (*limit) < 0) {
+						allDone = 0;
+					} else {
+						allDone =
+							yaffs_DeleteWorker(in,
+								tn->
+								internal
+								[i],
+								level -
+								1,
+								(chunkOffset
+									<<
+									YAFFS_TNODES_INTERNAL_BITS)
+								+ i,
+								limit);
+					}
+					if (allDone) {
+						yaffs_FreeTnode(dev,
+								tn->
+								internal[i]);
+						tn->internal[i] = NULL;
+					}
+				}
+			}
+			return (allDone) ? 1 : 0;
+		} else if (level == 0) {
+			int hitLimit = 0;
+
+			for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0 && !hitLimit;
+					i--) {
+				theChunk = yaffs_GetChunkGroupBase(dev, tn, i);
+				if (theChunk) {
+
+					chunkInInode = (chunkOffset <<
+						YAFFS_TNODES_LEVEL0_BITS) + i;
+
+					foundChunk =
+						yaffs_FindChunkInGroup(dev,
+								theChunk,
+								&tags,
+								in->objectId,
+								chunkInInode);
+
+					if (foundChunk > 0) {
+						yaffs_DeleteChunk(dev,
+								  foundChunk, 1,
+								  __LINE__);
+						in->nDataChunks--;
+						if (limit) {
+							*limit = *limit - 1;
+							if (*limit <= 0)
+								hitLimit = 1;
+						}
+
+					}
+
+					yaffs_PutLevel0Tnode(dev, tn, i, 0);
+				}
+
+			}
+			return (i < 0) ? 1 : 0;
+
+		}
+
+	}
+
+	return 1;
+
+}
+
+static void yaffs_SoftDeleteChunk(yaffs_Device *dev, int chunk)
+{
+	yaffs_BlockInfo *theBlock;
+
+	T(YAFFS_TRACE_DELETION, (TSTR("soft delete chunk %d" TENDSTR), chunk));
+
+	theBlock = yaffs_GetBlockInfo(dev, chunk / dev->nChunksPerBlock);
+	if (theBlock) {
+		theBlock->softDeletions++;
+		dev->nFreeChunks++;
+	}
+}
+
+/* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all the chunks in the file.
+ * All soft deleting does is increment the block's softdelete count and pulls the chunk out
+ * of the tnode.
+ * Thus, essentially this is the same as DeleteWorker except that the chunks are soft deleted.
+ */
+
+static int yaffs_SoftDeleteWorker(yaffs_Object *in, yaffs_Tnode *tn,
+				  __u32 level, int chunkOffset)
+{
+	int i;
+	int theChunk;
+	int allDone = 1;
+	yaffs_Device *dev = in->myDev;
+
+	if (tn) {
+		if (level > 0) {
+
+			for (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;
+			     i--) {
+				if (tn->internal[i]) {
+					allDone =
+					    yaffs_SoftDeleteWorker(in,
+								   tn->
+								   internal[i],
+								   level - 1,
+								   (chunkOffset
+								    <<
+								    YAFFS_TNODES_INTERNAL_BITS)
+								   + i);
+					if (allDone) {
+						yaffs_FreeTnode(dev,
+								tn->
+								internal[i]);
+						tn->internal[i] = NULL;
+					} else {
+						/* Hoosterman... how could this happen? */
+					}
+				}
+			}
+			return (allDone) ? 1 : 0;
+		} else if (level == 0) {
+
+			for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {
+				theChunk = yaffs_GetChunkGroupBase(dev, tn, i);
+				if (theChunk) {
+					/* Note this does not find the real chunk, only the chunk group.
+					 * We make an assumption that a chunk group is not larger than
+					 * a block.
+					 */
+					yaffs_SoftDeleteChunk(dev, theChunk);
+					yaffs_PutLevel0Tnode(dev, tn, i, 0);
+				}
+
+			}
+			return 1;
+
+		}
+
+	}
+
+	return 1;
+
+}
+
+static void yaffs_SoftDeleteFile(yaffs_Object *obj)
+{
+	if (obj->deleted &&
+	    obj->variantType == YAFFS_OBJECT_TYPE_FILE && !obj->softDeleted) {
+		if (obj->nDataChunks <= 0) {
+			/* Empty file with no duplicate object headers, just delete it immediately */
+			yaffs_FreeTnode(obj->myDev,
+					obj->variant.fileVariant.top);
+			obj->variant.fileVariant.top = NULL;
+			T(YAFFS_TRACE_TRACING,
+			  (TSTR("yaffs: Deleting empty file %d" TENDSTR),
+			   obj->objectId));
+			yaffs_DoGenericObjectDeletion(obj);
+		} else {
+			yaffs_SoftDeleteWorker(obj,
+					       obj->variant.fileVariant.top,
+					       obj->variant.fileVariant.
+					       topLevel, 0);
+			obj->softDeleted = 1;
+		}
+	}
+}
+
+/* Pruning removes any part of the file structure tree that is beyond the
+ * bounds of the file (ie that does not point to chunks).
+ *
+ * A file should only get pruned when its size is reduced.
+ *
+ * Before pruning, the chunks must be pulled from the tree and the
+ * level 0 tnode entries must be zeroed out.
+ * Could also use this for file deletion, but that's probably better handled
+ * by a special case.
+ */
+
+static yaffs_Tnode *yaffs_PruneWorker(yaffs_Device *dev, yaffs_Tnode *tn,
+				__u32 level, int del0)
+{
+	int i;
+	int hasData;
+
+	if (tn) {
+		hasData = 0;
+
+		for (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {
+			if (tn->internal[i] && level > 0) {
+				tn->internal[i] =
+				    yaffs_PruneWorker(dev, tn->internal[i],
+						      level - 1,
+						      (i == 0) ? del0 : 1);
+			}
+
+			if (tn->internal[i])
+				hasData++;
+		}
+
+		if (hasData == 0 && del0) {
+			/* Free and return NULL */
+
+			yaffs_FreeTnode(dev, tn);
+			tn = NULL;
+		}
+
+	}
+
+	return tn;
+
+}
+
+static int yaffs_PruneFileStructure(yaffs_Device *dev,
+				yaffs_FileStructure *fStruct)
+{
+	int i;
+	int hasData;
+	int done = 0;
+	yaffs_Tnode *tn;
+
+	if (fStruct->topLevel > 0) {
+		fStruct->top =
+		    yaffs_PruneWorker(dev, fStruct->top, fStruct->topLevel, 0);
+
+		/* Now we have a tree with all the non-zero branches NULL but the height
+		 * is the same as it was.
+		 * Let's see if we can trim internal tnodes to shorten the tree.
+		 * We can do this if only the 0th element in the tnode is in use
+		 * (ie all the non-zero are NULL)
+		 */
+
+		while (fStruct->topLevel && !done) {
+			tn = fStruct->top;
+
+			hasData = 0;
+			for (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {
+				if (tn->internal[i])
+					hasData++;
+			}
+
+			if (!hasData) {
+				fStruct->top = tn->internal[0];
+				fStruct->topLevel--;
+				yaffs_FreeTnode(dev, tn);
+			} else {
+				done = 1;
+			}
+		}
+	}
+
+	return YAFFS_OK;
+}
+
+/*-------------------- End of File Structure functions.-------------------*/
+
+/* yaffs_CreateFreeObjects creates a bunch more objects and
+ * adds them to the object free list.
+ */
+static int yaffs_CreateFreeObjects(yaffs_Device *dev, int nObjects)
+{
+	int i;
+	yaffs_Object *newObjects;
+	yaffs_ObjectList *list;
+
+	if (nObjects < 1)
+		return YAFFS_OK;
+
+	/* make these things */
+	newObjects = YMALLOC(nObjects * sizeof(yaffs_Object));
+	list = YMALLOC(sizeof(yaffs_ObjectList));
+
+	if (!newObjects || !list) {
+		if (newObjects)
+			YFREE(newObjects);
+		if (list)
+			YFREE(list);
+		T(YAFFS_TRACE_ALLOCATE,
+		  (TSTR("yaffs: Could not allocate more objects" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	/* Hook them into the free list */
+	for (i = 0; i < nObjects - 1; i++) {
+		newObjects[i].siblings.next =
+				(struct ylist_head *)(&newObjects[i + 1]);
+	}
+
+	newObjects[nObjects - 1].siblings.next = (void *)dev->freeObjects;
+	dev->freeObjects = newObjects;
+	dev->nFreeObjects += nObjects;
+	dev->nObjectsCreated += nObjects;
+
+	/* Now add this bunch of Objects to a list for freeing up. */
+
+	list->objects = newObjects;
+	list->next = dev->allocatedObjectList;
+	dev->allocatedObjectList = list;
+
+	return YAFFS_OK;
+}
+
+
+/* AllocateEmptyObject gets us a clean Object. Tries to make allocate more if we run out */
+static yaffs_Object *yaffs_AllocateEmptyObject(yaffs_Device *dev)
+{
+	yaffs_Object *tn = NULL;
+
+#ifdef VALGRIND_TEST
+	tn = YMALLOC(sizeof(yaffs_Object));
+#else
+	/* If there are none left make more */
+	if (!dev->freeObjects)
+		yaffs_CreateFreeObjects(dev, YAFFS_ALLOCATION_NOBJECTS);
+
+	if (dev->freeObjects) {
+		tn = dev->freeObjects;
+		dev->freeObjects =
+			(yaffs_Object *) (dev->freeObjects->siblings.next);
+		dev->nFreeObjects--;
+	}
+#endif
+	if (tn) {
+		/* Now sweeten it up... */
+
+		memset(tn, 0, sizeof(yaffs_Object));
+		tn->beingCreated = 1;
+
+		tn->myDev = dev;
+		tn->hdrChunk = 0;
+		tn->variantType = YAFFS_OBJECT_TYPE_UNKNOWN;
+		YINIT_LIST_HEAD(&(tn->hardLinks));
+		YINIT_LIST_HEAD(&(tn->hashLink));
+		YINIT_LIST_HEAD(&tn->siblings);
+
+
+		/* Now make the directory sane */
+		if (dev->rootDir) {
+			tn->parent = dev->rootDir;
+			ylist_add(&(tn->siblings), &dev->rootDir->variant.directoryVariant.children);
+		}
+
+		/* Add it to the lost and found directory.
+		 * NB Can't put root or lostNFound in lostNFound so
+		 * check if lostNFound exists first
+		 */
+		if (dev->lostNFoundDir)
+			yaffs_AddObjectToDirectory(dev->lostNFoundDir, tn);
+
+		tn->beingCreated = 0;
+	}
+
+	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
+
+	return tn;
+}
+
+static yaffs_Object *yaffs_CreateFakeDirectory(yaffs_Device *dev, int number,
+					       __u32 mode)
+{
+
+	yaffs_Object *obj =
+	    yaffs_CreateNewObject(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);
+	if (obj) {
+		obj->fake = 1;		/* it is fake so it might have no NAND presence... */
+		obj->renameAllowed = 0;	/* ... and we're not allowed to rename it... */
+		obj->unlinkAllowed = 0;	/* ... or unlink it */
+		obj->deleted = 0;
+		obj->unlinked = 0;
+		obj->yst_mode = mode;
+		obj->myDev = dev;
+		obj->hdrChunk = 0;	/* Not a valid chunk. */
+	}
+
+	return obj;
+
+}
+
+static void yaffs_UnhashObject(yaffs_Object *tn)
+{
+	int bucket;
+	yaffs_Device *dev = tn->myDev;
+
+	/* If it is still linked into the bucket list, free from the list */
+	if (!ylist_empty(&tn->hashLink)) {
+		ylist_del_init(&tn->hashLink);
+		bucket = yaffs_HashFunction(tn->objectId);
+		dev->objectBucket[bucket].count--;
+	}
+}
+
+/*  FreeObject frees up a Object and puts it back on the free list */
+static void yaffs_FreeObject(yaffs_Object *tn)
+{
+	yaffs_Device *dev = tn->myDev;
+
+#ifdef __KERNEL__
+	T(YAFFS_TRACE_OS, (TSTR("FreeObject %p inode %p"TENDSTR), tn, tn->myInode));
+#endif
+
+	if (tn->parent)
+		YBUG();
+	if (!ylist_empty(&tn->siblings))
+		YBUG();
+
+
+#ifdef __KERNEL__
+	if (tn->myInode) {
+		/* We're still hooked up to a cached inode.
+		 * Don't delete now, but mark for later deletion
+		 */
+		tn->deferedFree = 1;
+		return;
+	}
+#endif
+
+	yaffs_UnhashObject(tn);
+
+#ifdef VALGRIND_TEST
+	YFREE(tn);
+#else
+	/* Link into the free list. */
+	tn->siblings.next = (struct ylist_head *)(dev->freeObjects);
+	dev->freeObjects = tn;
+	dev->nFreeObjects++;
+#endif
+	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
+}
+
+#ifdef __KERNEL__
+
+void yaffs_HandleDeferedFree(yaffs_Object *obj)
+{
+	if (obj->deferedFree)
+		yaffs_FreeObject(obj);
+}
+
+#endif
+
+static void yaffs_DeinitialiseObjects(yaffs_Device *dev)
+{
+	/* Free the list of allocated Objects */
+
+	yaffs_ObjectList *tmp;
+
+	while (dev->allocatedObjectList) {
+		tmp = dev->allocatedObjectList->next;
+		YFREE(dev->allocatedObjectList->objects);
+		YFREE(dev->allocatedObjectList);
+
+		dev->allocatedObjectList = tmp;
+	}
+
+	dev->freeObjects = NULL;
+	dev->nFreeObjects = 0;
+}
+
+static void yaffs_InitialiseObjects(yaffs_Device *dev)
+{
+	int i;
+
+	dev->allocatedObjectList = NULL;
+	dev->freeObjects = NULL;
+	dev->nFreeObjects = 0;
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		YINIT_LIST_HEAD(&dev->objectBucket[i].list);
+		dev->objectBucket[i].count = 0;
+	}
+}
+
+static int yaffs_FindNiceObjectBucket(yaffs_Device *dev)
+{
+	static int x;
+	int i;
+	int l = 999;
+	int lowest = 999999;
+
+	/* First let's see if we can find one that's empty. */
+
+	for (i = 0; i < 10 && lowest > 0; i++) {
+		x++;
+		x %= YAFFS_NOBJECT_BUCKETS;
+		if (dev->objectBucket[x].count < lowest) {
+			lowest = dev->objectBucket[x].count;
+			l = x;
+		}
+
+	}
+
+	/* If we didn't find an empty list, then try
+	 * looking a bit further for a short one
+	 */
+
+	for (i = 0; i < 10 && lowest > 3; i++) {
+		x++;
+		x %= YAFFS_NOBJECT_BUCKETS;
+		if (dev->objectBucket[x].count < lowest) {
+			lowest = dev->objectBucket[x].count;
+			l = x;
+		}
+
+	}
+
+	return l;
+}
+
+static int yaffs_CreateNewObjectNumber(yaffs_Device *dev)
+{
+	int bucket = yaffs_FindNiceObjectBucket(dev);
+
+	/* Now find an object value that has not already been taken
+	 * by scanning the list.
+	 */
+
+	int found = 0;
+	struct ylist_head *i;
+
+	__u32 n = (__u32) bucket;
+
+	/* yaffs_CheckObjectHashSanity();  */
+
+	while (!found) {
+		found = 1;
+		n += YAFFS_NOBJECT_BUCKETS;
+		if (1 || dev->objectBucket[bucket].count > 0) {
+			ylist_for_each(i, &dev->objectBucket[bucket].list) {
+				/* If there is already one in the list */
+				if (i && ylist_entry(i, yaffs_Object,
+						hashLink)->objectId == n) {
+					found = 0;
+				}
+			}
+		}
+	}
+
+	return n;
+}
+
+static void yaffs_HashObject(yaffs_Object *in)
+{
+	int bucket = yaffs_HashFunction(in->objectId);
+	yaffs_Device *dev = in->myDev;
+
+	ylist_add(&in->hashLink, &dev->objectBucket[bucket].list);
+	dev->objectBucket[bucket].count++;
+}
+
+yaffs_Object *yaffs_FindObjectByNumber(yaffs_Device *dev, __u32 number)
+{
+	int bucket = yaffs_HashFunction(number);
+	struct ylist_head *i;
+	yaffs_Object *in;
+
+	ylist_for_each(i, &dev->objectBucket[bucket].list) {
+		/* Look if it is in the list */
+		if (i) {
+			in = ylist_entry(i, yaffs_Object, hashLink);
+			if (in->objectId == number) {
+#ifdef __KERNEL__
+				/* Don't tell the VFS about this one if it is defered free */
+				if (in->deferedFree)
+					return NULL;
+#endif
+
+				return in;
+			}
+		}
+	}
+
+	return NULL;
+}
+
+yaffs_Object *yaffs_CreateNewObject(yaffs_Device *dev, int number,
+				    yaffs_ObjectType type)
+{
+	yaffs_Object *theObject;
+	yaffs_Tnode *tn = NULL;
+
+	if (number < 0)
+		number = yaffs_CreateNewObjectNumber(dev);
+
+	theObject = yaffs_AllocateEmptyObject(dev);
+	if (!theObject)
+		return NULL;
+
+	if (type == YAFFS_OBJECT_TYPE_FILE) {
+		tn = yaffs_GetTnode(dev);
+		if (!tn) {
+			yaffs_FreeObject(theObject);
+			return NULL;
+		}
+	}
+
+	if (theObject) {
+		theObject->fake = 0;
+		theObject->renameAllowed = 1;
+		theObject->unlinkAllowed = 1;
+		theObject->objectId = number;
+		yaffs_HashObject(theObject);
+		theObject->variantType = type;
+#ifdef CONFIG_YAFFS_WINCE
+		yfsd_WinFileTimeNow(theObject->win_atime);
+		theObject->win_ctime[0] = theObject->win_mtime[0] =
+		    theObject->win_atime[0];
+		theObject->win_ctime[1] = theObject->win_mtime[1] =
+		    theObject->win_atime[1];
+
+#else
+
+		theObject->yst_atime = theObject->yst_mtime =
+		    theObject->yst_ctime = Y_CURRENT_TIME;
+#endif
+		switch (type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			theObject->variant.fileVariant.fileSize = 0;
+			theObject->variant.fileVariant.scannedFileSize = 0;
+			theObject->variant.fileVariant.shrinkSize = 0xFFFFFFFF;	/* max __u32 */
+			theObject->variant.fileVariant.topLevel = 0;
+			theObject->variant.fileVariant.top = tn;
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			YINIT_LIST_HEAD(&theObject->variant.directoryVariant.
+					children);
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+			/* No action required */
+			break;
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+			/* todo this should not happen */
+			break;
+		}
+	}
+
+	return theObject;
+}
+
+static yaffs_Object *yaffs_FindOrCreateObjectByNumber(yaffs_Device *dev,
+						      int number,
+						      yaffs_ObjectType type)
+{
+	yaffs_Object *theObject = NULL;
+
+	if (number > 0)
+		theObject = yaffs_FindObjectByNumber(dev, number);
+
+	if (!theObject)
+		theObject = yaffs_CreateNewObject(dev, number, type);
+
+	return theObject;
+
+}
+
+
+static YCHAR *yaffs_CloneString(const YCHAR *str)
+{
+	YCHAR *newStr = NULL;
+
+	if (str && *str) {
+		newStr = YMALLOC((yaffs_strlen(str) + 1) * sizeof(YCHAR));
+		if (newStr)
+			yaffs_strcpy(newStr, str);
+	}
+
+	return newStr;
+
+}
+
+/*
+ * Mknod (create) a new object.
+ * equivalentObject only has meaning for a hard link;
+ * aliasString only has meaning for a sumlink.
+ * rdev only has meaning for devices (a subset of special objects)
+ */
+
+static yaffs_Object *yaffs_MknodObject(yaffs_ObjectType type,
+				       yaffs_Object *parent,
+				       const YCHAR *name,
+				       __u32 mode,
+				       __u32 uid,
+				       __u32 gid,
+				       yaffs_Object *equivalentObject,
+				       const YCHAR *aliasString, __u32 rdev)
+{
+	yaffs_Object *in;
+	YCHAR *str = NULL;
+
+	yaffs_Device *dev = parent->myDev;
+
+	/* Check if the entry exists. If it does then fail the call since we don't want a dup.*/
+	if (yaffs_FindObjectByName(parent, name))
+		return NULL;
+
+	in = yaffs_CreateNewObject(dev, -1, type);
+
+	if (!in)
+		return YAFFS_FAIL;
+
+	if (type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		str = yaffs_CloneString(aliasString);
+		if (!str) {
+			yaffs_FreeObject(in);
+			return NULL;
+		}
+	}
+
+
+
+	if (in) {
+		in->hdrChunk = 0;
+		in->valid = 1;
+		in->variantType = type;
+
+		in->yst_mode = mode;
+
+#ifdef CONFIG_YAFFS_WINCE
+		yfsd_WinFileTimeNow(in->win_atime);
+		in->win_ctime[0] = in->win_mtime[0] = in->win_atime[0];
+		in->win_ctime[1] = in->win_mtime[1] = in->win_atime[1];
+
+#else
+		in->yst_atime = in->yst_mtime = in->yst_ctime = Y_CURRENT_TIME;
+
+		in->yst_rdev = rdev;
+		in->yst_uid = uid;
+		in->yst_gid = gid;
+#endif
+		in->nDataChunks = 0;
+
+		yaffs_SetObjectName(in, name);
+		in->dirty = 1;
+
+		yaffs_AddObjectToDirectory(parent, in);
+
+		in->myDev = parent->myDev;
+
+		switch (type) {
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			in->variant.symLinkVariant.alias = str;
+			break;
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+			in->variant.hardLinkVariant.equivalentObject =
+				equivalentObject;
+			in->variant.hardLinkVariant.equivalentObjectId =
+				equivalentObject->objectId;
+			ylist_add(&in->hardLinks, &equivalentObject->hardLinks);
+			break;
+		case YAFFS_OBJECT_TYPE_FILE:
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+			/* do nothing */
+			break;
+		}
+
+		if (yaffs_UpdateObjectHeader(in, name, 0, 0, 0) < 0) {
+			/* Could not create the object header, fail the creation */
+			yaffs_DeleteObject(in);
+			in = NULL;
+		}
+
+		yaffs_UpdateParent(parent);
+	}
+
+	return in;
+}
+
+yaffs_Object *yaffs_MknodFile(yaffs_Object *parent, const YCHAR *name,
+			__u32 mode, __u32 uid, __u32 gid)
+{
+	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,
+				uid, gid, NULL, NULL, 0);
+}
+
+yaffs_Object *yaffs_MknodDirectory(yaffs_Object *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid)
+{
+	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,
+				 mode, uid, gid, NULL, NULL, 0);
+}
+
+yaffs_Object *yaffs_MknodSpecial(yaffs_Object *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid, __u32 rdev)
+{
+	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,
+				 uid, gid, NULL, NULL, rdev);
+}
+
+yaffs_Object *yaffs_MknodSymLink(yaffs_Object *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid,
+				const YCHAR *alias)
+{
+	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,
+				uid, gid, NULL, alias, 0);
+}
+
+/* yaffs_Link returns the object id of the equivalent object.*/
+yaffs_Object *yaffs_Link(yaffs_Object *parent, const YCHAR *name,
+			yaffs_Object *equivalentObject)
+{
+	/* Get the real object in case we were fed a hard link as an equivalent object */
+	equivalentObject = yaffs_GetEquivalentObject(equivalentObject);
+
+	if (yaffs_MknodObject
+	    (YAFFS_OBJECT_TYPE_HARDLINK, parent, name, 0, 0, 0,
+	     equivalentObject, NULL, 0)) {
+		return equivalentObject;
+	} else {
+		return NULL;
+	}
+
+}
+
+static int yaffs_ChangeObjectName(yaffs_Object *obj, yaffs_Object *newDir,
+				const YCHAR *newName, int force, int shadows)
+{
+	int unlinkOp;
+	int deleteOp;
+
+	yaffs_Object *existingTarget;
+
+	if (newDir == NULL)
+		newDir = obj->parent;	/* use the old directory */
+
+	if (newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_ChangeObjectName: newDir is not a directory"
+		    TENDSTR)));
+		YBUG();
+	}
+
+	/* TODO: Do we need this different handling for YAFFS2 and YAFFS1?? */
+	if (obj->myDev->isYaffs2)
+		unlinkOp = (newDir == obj->myDev->unlinkedDir);
+	else
+		unlinkOp = (newDir == obj->myDev->unlinkedDir
+			    && obj->variantType == YAFFS_OBJECT_TYPE_FILE);
+
+	deleteOp = (newDir == obj->myDev->deletedDir);
+
+	existingTarget = yaffs_FindObjectByName(newDir, newName);
+
+	/* If the object is a file going into the unlinked directory,
+	 *   then it is OK to just stuff it in since duplicate names are allowed.
+	 *   else only proceed if the new name does not exist and if we're putting
+	 *   it into a directory.
+	 */
+	if ((unlinkOp ||
+	     deleteOp ||
+	     force ||
+	     (shadows > 0) ||
+	     !existingTarget) &&
+	    newDir->variantType == YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_SetObjectName(obj, newName);
+		obj->dirty = 1;
+
+		yaffs_AddObjectToDirectory(newDir, obj);
+
+		if (unlinkOp)
+			obj->unlinked = 1;
+
+		/* If it is a deletion then we mark it as a shrink for gc purposes. */
+		if (yaffs_UpdateObjectHeader(obj, newName, 0, deleteOp, shadows) >= 0)
+			return YAFFS_OK;
+	}
+
+	return YAFFS_FAIL;
+}
+
+int yaffs_RenameObject(yaffs_Object *oldDir, const YCHAR *oldName,
+		yaffs_Object *newDir, const YCHAR *newName)
+{
+	yaffs_Object *obj = NULL;
+	yaffs_Object *existingTarget = NULL;
+	int force = 0;
+	int result;
+	yaffs_Device *dev;
+
+
+	if (!oldDir || oldDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+		YBUG();
+	if (!newDir || newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+		YBUG();
+
+	dev = oldDir->myDev;
+
+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE
+	/* Special case for case insemsitive systems (eg. WinCE).
+	 * While look-up is case insensitive, the name isn't.
+	 * Therefore we might want to change x.txt to X.txt
+	*/
+	if (oldDir == newDir && yaffs_strcmp(oldName, newName) == 0)
+		force = 1;
+#endif
+
+	if(yaffs_strlen(newName) > YAFFS_MAX_NAME_LENGTH)
+		/* ENAMETOOLONG */
+		return YAFFS_FAIL;
+
+	obj = yaffs_FindObjectByName(oldDir, oldName);
+
+	if (obj && obj->renameAllowed) {
+
+		/* Now do the handling for an existing target, if there is one */
+
+		existingTarget = yaffs_FindObjectByName(newDir, newName);
+		if (existingTarget &&
+			existingTarget->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&
+			!ylist_empty(&existingTarget->variant.directoryVariant.children)) {
+			/* There is a target that is a non-empty directory, so we fail */
+			return YAFFS_FAIL;	/* EEXIST or ENOTEMPTY */
+		} else if (existingTarget && existingTarget != obj) {
+			/* Nuke the target first, using shadowing,
+			 * but only if it isn't the same object.
+			 *
+			 * Note we must disable gc otherwise it can mess up the shadowing.
+			 *
+			 */
+			dev->isDoingGC=1;
+			yaffs_ChangeObjectName(obj, newDir, newName, force,
+						existingTarget->objectId);
+			existingTarget->isShadowed = 1;
+			yaffs_UnlinkObject(existingTarget);
+			dev->isDoingGC=0;
+		}
+
+		result = yaffs_ChangeObjectName(obj, newDir, newName, 1, 0);
+
+		yaffs_UpdateParent(oldDir);
+		if(newDir != oldDir)
+			yaffs_UpdateParent(newDir);
+
+		return result;
+	}
+	return YAFFS_FAIL;
+}
+
+/*------------------------- Block Management and Page Allocation ----------------*/
+
+static int yaffs_InitialiseBlocks(yaffs_Device *dev)
+{
+	int nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;
+
+	dev->blockInfo = NULL;
+	dev->chunkBits = NULL;
+
+	dev->allocationBlock = -1;	/* force it to get a new one */
+
+	/* If the first allocation strategy fails, thry the alternate one */
+	dev->blockInfo = YMALLOC(nBlocks * sizeof(yaffs_BlockInfo));
+	if (!dev->blockInfo) {
+		dev->blockInfo = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockInfo));
+		dev->blockInfoAlt = 1;
+	} else
+		dev->blockInfoAlt = 0;
+
+	if (dev->blockInfo) {
+		/* Set up dynamic blockinfo stuff. */
+		dev->chunkBitmapStride = (dev->nChunksPerBlock + 7) / 8; /* round up bytes */
+		dev->chunkBits = YMALLOC(dev->chunkBitmapStride * nBlocks);
+		if (!dev->chunkBits) {
+			dev->chunkBits = YMALLOC_ALT(dev->chunkBitmapStride * nBlocks);
+			dev->chunkBitsAlt = 1;
+		} else
+			dev->chunkBitsAlt = 0;
+	}
+
+	if (dev->blockInfo && dev->chunkBits) {
+		memset(dev->blockInfo, 0, nBlocks * sizeof(yaffs_BlockInfo));
+		memset(dev->chunkBits, 0, dev->chunkBitmapStride * nBlocks);
+		return YAFFS_OK;
+	}
+
+	return YAFFS_FAIL;
+}
+
+static void yaffs_DeinitialiseBlocks(yaffs_Device *dev)
+{
+	if (dev->blockInfoAlt && dev->blockInfo)
+		YFREE_ALT(dev->blockInfo);
+	else if (dev->blockInfo)
+		YFREE(dev->blockInfo);
+
+	dev->blockInfoAlt = 0;
+
+	dev->blockInfo = NULL;
+
+	if (dev->chunkBitsAlt && dev->chunkBits)
+		YFREE_ALT(dev->chunkBits);
+	else if (dev->chunkBits)
+		YFREE(dev->chunkBits);
+	dev->chunkBitsAlt = 0;
+	dev->chunkBits = NULL;
+}
+
+static int yaffs_BlockNotDisqualifiedFromGC(yaffs_Device *dev,
+					yaffs_BlockInfo *bi)
+{
+	int i;
+	__u32 seq;
+	yaffs_BlockInfo *b;
+
+	if (!dev->isYaffs2)
+		return 1;	/* disqualification only applies to yaffs2. */
+
+	if (!bi->hasShrinkHeader)
+		return 1;	/* can gc */
+
+	/* Find the oldest dirty sequence number if we don't know it and save it
+	 * so we don't have to keep recomputing it.
+	 */
+	if (!dev->oldestDirtySequence) {
+		seq = dev->sequenceNumber;
+
+		for (i = dev->internalStartBlock; i <= dev->internalEndBlock;
+				i++) {
+			b = yaffs_GetBlockInfo(dev, i);
+			if (b->blockState == YAFFS_BLOCK_STATE_FULL &&
+			    (b->pagesInUse - b->softDeletions) <
+			    dev->nChunksPerBlock && b->sequenceNumber < seq) {
+				seq = b->sequenceNumber;
+			}
+		}
+		dev->oldestDirtySequence = seq;
+	}
+
+	/* Can't do gc of this block if there are any blocks older than this one that have
+	 * discarded pages.
+	 */
+	return (bi->sequenceNumber <= dev->oldestDirtySequence);
+}
+
+/* FindDiretiestBlock is used to select the dirtiest block (or close enough)
+ * for garbage collection.
+ */
+
+static int yaffs_FindBlockForGarbageCollection(yaffs_Device *dev,
+					int aggressive)
+{
+	int b = dev->currentDirtyChecker;
+
+	int i;
+	int iterations;
+	int dirtiest = -1;
+	int pagesInUse = 0;
+	int prioritised = 0;
+	yaffs_BlockInfo *bi;
+	int pendingPrioritisedExist = 0;
+
+	/* First let's see if we need to grab a prioritised block */
+	if (dev->hasPendingPrioritisedGCs) {
+		for (i = dev->internalStartBlock; i < dev->internalEndBlock && !prioritised; i++) {
+
+			bi = yaffs_GetBlockInfo(dev, i);
+			/* yaffs_VerifyBlock(dev,bi,i); */
+
+			if (bi->gcPrioritise) {
+				pendingPrioritisedExist = 1;
+				if (bi->blockState == YAFFS_BLOCK_STATE_FULL &&
+				   yaffs_BlockNotDisqualifiedFromGC(dev, bi)) {
+					pagesInUse = (bi->pagesInUse - bi->softDeletions);
+					dirtiest = i;
+					prioritised = 1;
+					aggressive = 1; /* Fool the non-aggressive skip logiv below */
+				}
+			}
+		}
+
+		if (!pendingPrioritisedExist) /* None found, so we can clear this */
+			dev->hasPendingPrioritisedGCs = 0;
+	}
+
+	/* If we're doing aggressive GC then we are happy to take a less-dirty block, and
+	 * search harder.
+	 * else (we're doing a leasurely gc), then we only bother to do this if the
+	 * block has only a few pages in use.
+	 */
+
+	dev->nonAggressiveSkip--;
+
+	if (!aggressive && (dev->nonAggressiveSkip > 0))
+		return -1;
+
+	if (!prioritised)
+		pagesInUse =
+			(aggressive) ? dev->nChunksPerBlock : YAFFS_PASSIVE_GC_CHUNKS + 1;
+
+	if (aggressive)
+		iterations =
+		    dev->internalEndBlock - dev->internalStartBlock + 1;
+	else {
+		iterations =
+		    dev->internalEndBlock - dev->internalStartBlock + 1;
+		iterations = iterations / 16;
+		if (iterations > 200)
+			iterations = 200;
+	}
+
+	for (i = 0; i <= iterations && pagesInUse > 0 && !prioritised; i++) {
+		b++;
+		if (b < dev->internalStartBlock || b > dev->internalEndBlock)
+			b = dev->internalStartBlock;
+
+		if (b < dev->internalStartBlock || b > dev->internalEndBlock) {
+			T(YAFFS_TRACE_ERROR,
+			  (TSTR("**>> Block %d is not valid" TENDSTR), b));
+			YBUG();
+		}
+
+		bi = yaffs_GetBlockInfo(dev, b);
+
+		if (bi->blockState == YAFFS_BLOCK_STATE_FULL &&
+			(bi->pagesInUse - bi->softDeletions) < pagesInUse &&
+				yaffs_BlockNotDisqualifiedFromGC(dev, bi)) {
+			dirtiest = b;
+			pagesInUse = (bi->pagesInUse - bi->softDeletions);
+		}
+	}
+
+	dev->currentDirtyChecker = b;
+
+	if (dirtiest > 0) {
+		T(YAFFS_TRACE_GC,
+		  (TSTR("GC Selected block %d with %d free, prioritised:%d" TENDSTR), dirtiest,
+		   dev->nChunksPerBlock - pagesInUse, prioritised));
+	}
+
+	dev->oldestDirtySequence = 0;
+
+	if (dirtiest > 0)
+		dev->nonAggressiveSkip = 4;
+
+	return dirtiest;
+}
+
+static void yaffs_BlockBecameDirty(yaffs_Device *dev, int blockNo)
+{
+	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockNo);
+
+	int erasedOk = 0;
+
+	/* If the block is still healthy erase it and mark as clean.
+	 * If the block has had a data failure, then retire it.
+	 */
+
+	T(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,
+		(TSTR("yaffs_BlockBecameDirty block %d state %d %s"TENDSTR),
+		blockNo, bi->blockState, (bi->needsRetiring) ? "needs retiring" : ""));
+
+	bi->blockState = YAFFS_BLOCK_STATE_DIRTY;
+
+	if (!bi->needsRetiring) {
+		yaffs_InvalidateCheckpoint(dev);
+		erasedOk = yaffs_EraseBlockInNAND(dev, blockNo);
+		if (!erasedOk) {
+			dev->nErasureFailures++;
+			T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+			  (TSTR("**>> Erasure failed %d" TENDSTR), blockNo));
+		}
+	}
+
+	if (erasedOk &&
+	    ((yaffs_traceMask & YAFFS_TRACE_ERASE) || !yaffs_SkipVerification(dev))) {
+		int i;
+		for (i = 0; i < dev->nChunksPerBlock; i++) {
+			if (!yaffs_CheckChunkErased
+			    (dev, blockNo * dev->nChunksPerBlock + i)) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   (">>Block %d erasure supposedly OK, but chunk %d not erased"
+				    TENDSTR), blockNo, i));
+			}
+		}
+	}
+
+	if (erasedOk) {
+		/* Clean it up... */
+		bi->blockState = YAFFS_BLOCK_STATE_EMPTY;
+		dev->nErasedBlocks++;
+		bi->pagesInUse = 0;
+		bi->softDeletions = 0;
+		bi->hasShrinkHeader = 0;
+		bi->skipErasedCheck = 1;  /* This is clean, so no need to check */
+		bi->gcPrioritise = 0;
+		yaffs_ClearChunkBits(dev, blockNo);
+
+		T(YAFFS_TRACE_ERASE,
+		  (TSTR("Erased block %d" TENDSTR), blockNo));
+	} else {
+		dev->nFreeChunks -= dev->nChunksPerBlock;	/* We lost a block of free space */
+
+		yaffs_RetireBlock(dev, blockNo);
+		T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		  (TSTR("**>> Block %d retired" TENDSTR), blockNo));
+	}
+}
+
+static int yaffs_FindBlockForAllocation(yaffs_Device *dev)
+{
+	int i;
+
+	yaffs_BlockInfo *bi;
+
+	if (dev->nErasedBlocks < 1) {
+		/* Hoosterman we've got a problem.
+		 * Can't get space to gc
+		 */
+		T(YAFFS_TRACE_ERROR,
+		  (TSTR("yaffs tragedy: no more erased blocks" TENDSTR)));
+
+		return -1;
+	}
+
+	/* Find an empty block. */
+
+	for (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {
+		dev->allocationBlockFinder++;
+		if (dev->allocationBlockFinder < dev->internalStartBlock
+		    || dev->allocationBlockFinder > dev->internalEndBlock) {
+			dev->allocationBlockFinder = dev->internalStartBlock;
+		}
+
+		bi = yaffs_GetBlockInfo(dev, dev->allocationBlockFinder);
+
+		if (bi->blockState == YAFFS_BLOCK_STATE_EMPTY) {
+			bi->blockState = YAFFS_BLOCK_STATE_ALLOCATING;
+			dev->sequenceNumber++;
+			bi->sequenceNumber = dev->sequenceNumber;
+			dev->nErasedBlocks--;
+			T(YAFFS_TRACE_ALLOCATE,
+			  (TSTR("Allocated block %d, seq  %d, %d left" TENDSTR),
+			   dev->allocationBlockFinder, dev->sequenceNumber,
+			   dev->nErasedBlocks));
+			return dev->allocationBlockFinder;
+		}
+	}
+
+	T(YAFFS_TRACE_ALWAYS,
+	  (TSTR
+	   ("yaffs tragedy: no more erased blocks, but there should have been %d"
+	    TENDSTR), dev->nErasedBlocks));
+
+	return -1;
+}
+
+
+
+static int yaffs_CalcCheckpointBlocksRequired(yaffs_Device *dev)
+{
+	if (!dev->nCheckpointBlocksRequired &&
+	   dev->isYaffs2) {
+		/* Not a valid value so recalculate */
+		int nBytes = 0;
+		int nBlocks;
+		int devBlocks = (dev->endBlock - dev->startBlock + 1);
+		int tnodeSize;
+
+		tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
+
+		if (tnodeSize < sizeof(yaffs_Tnode))
+			tnodeSize = sizeof(yaffs_Tnode);
+
+		nBytes += sizeof(yaffs_CheckpointValidity);
+		nBytes += sizeof(yaffs_CheckpointDevice);
+		nBytes += devBlocks * sizeof(yaffs_BlockInfo);
+		nBytes += devBlocks * dev->chunkBitmapStride;
+		nBytes += (sizeof(yaffs_CheckpointObject) + sizeof(__u32)) * (dev->nObjectsCreated - dev->nFreeObjects);
+		nBytes += (tnodeSize + sizeof(__u32)) * (dev->nTnodesCreated - dev->nFreeTnodes);
+		nBytes += sizeof(yaffs_CheckpointValidity);
+		nBytes += sizeof(__u32); /* checksum*/
+
+		/* Round up and add 2 blocks to allow for some bad blocks, so add 3 */
+
+		nBlocks = (nBytes/(dev->nDataBytesPerChunk * dev->nChunksPerBlock)) + 3;
+
+		dev->nCheckpointBlocksRequired = nBlocks;
+	}
+
+	return dev->nCheckpointBlocksRequired;
+}
+
+/*
+ * Check if there's space to allocate...
+ * Thinks.... do we need top make this ths same as yaffs_GetFreeChunks()?
+ */
+static int yaffs_CheckSpaceForAllocation(yaffs_Device *dev)
+{
+	int reservedChunks;
+	int reservedBlocks = dev->nReservedBlocks;
+	int checkpointBlocks;
+
+	if (dev->isYaffs2) {
+		checkpointBlocks =  yaffs_CalcCheckpointBlocksRequired(dev) -
+				    dev->blocksInCheckpoint;
+		if (checkpointBlocks < 0)
+			checkpointBlocks = 0;
+	} else {
+		checkpointBlocks = 0;
+	}
+
+	reservedChunks = ((reservedBlocks + checkpointBlocks) * dev->nChunksPerBlock);
+
+	return (dev->nFreeChunks > reservedChunks);
+}
+
+static int yaffs_AllocateChunk(yaffs_Device *dev, int useReserve,
+		yaffs_BlockInfo **blockUsedPtr)
+{
+	int retVal;
+	yaffs_BlockInfo *bi;
+
+	if (dev->allocationBlock < 0) {
+		/* Get next block to allocate off */
+		dev->allocationBlock = yaffs_FindBlockForAllocation(dev);
+		dev->allocationPage = 0;
+	}
+
+	if (!useReserve && !yaffs_CheckSpaceForAllocation(dev)) {
+		/* Not enough space to allocate unless we're allowed to use the reserve. */
+		return -1;
+	}
+
+	if (dev->nErasedBlocks < dev->nReservedBlocks
+			&& dev->allocationPage == 0) {
+		T(YAFFS_TRACE_ALLOCATE, (TSTR("Allocating reserve" TENDSTR)));
+	}
+
+	/* Next page please.... */
+	if (dev->allocationBlock >= 0) {
+		bi = yaffs_GetBlockInfo(dev, dev->allocationBlock);
+
+		retVal = (dev->allocationBlock * dev->nChunksPerBlock) +
+			dev->allocationPage;
+		bi->pagesInUse++;
+		yaffs_SetChunkBit(dev, dev->allocationBlock,
+				dev->allocationPage);
+
+		dev->allocationPage++;
+
+		dev->nFreeChunks--;
+
+		/* If the block is full set the state to full */
+		if (dev->allocationPage >= dev->nChunksPerBlock) {
+			bi->blockState = YAFFS_BLOCK_STATE_FULL;
+			dev->allocationBlock = -1;
+		}
+
+		if (blockUsedPtr)
+			*blockUsedPtr = bi;
+
+		return retVal;
+	}
+
+	T(YAFFS_TRACE_ERROR,
+			(TSTR("!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!" TENDSTR)));
+
+	return -1;
+}
+
+static int yaffs_GetErasedChunks(yaffs_Device *dev)
+{
+	int n;
+
+	n = dev->nErasedBlocks * dev->nChunksPerBlock;
+
+	if (dev->allocationBlock > 0)
+		n += (dev->nChunksPerBlock - dev->allocationPage);
+
+	return n;
+
+}
+
+static int yaffs_GarbageCollectBlock(yaffs_Device *dev, int block,
+		int wholeBlock)
+{
+	int oldChunk;
+	int newChunk;
+	int markNAND;
+	int retVal = YAFFS_OK;
+	int cleanups = 0;
+	int i;
+	int isCheckpointBlock;
+	int matchingChunk;
+	int maxCopies;
+
+	int chunksBefore = yaffs_GetErasedChunks(dev);
+	int chunksAfter;
+
+	yaffs_ExtendedTags tags;
+
+	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, block);
+
+	yaffs_Object *object;
+
+	isCheckpointBlock = (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT);
+
+
+	T(YAFFS_TRACE_TRACING,
+			(TSTR("Collecting block %d, in use %d, shrink %d, wholeBlock %d" TENDSTR),
+			 block,
+			 bi->pagesInUse,
+			 bi->hasShrinkHeader,
+			 wholeBlock));
+
+	/*yaffs_VerifyFreeChunks(dev); */
+
+	if(bi->blockState == YAFFS_BLOCK_STATE_FULL)
+		bi->blockState = YAFFS_BLOCK_STATE_COLLECTING;
+	
+	bi->hasShrinkHeader = 0;	/* clear the flag so that the block can erase */
+
+	/* Take off the number of soft deleted entries because
+	 * they're going to get really deleted during GC.
+	 */
+	if(dev->gcChunk == 0) /* first time through for this block */
+		dev->nFreeChunks -= bi->softDeletions;
+
+	dev->isDoingGC = 1;
+
+	if (isCheckpointBlock ||
+			!yaffs_StillSomeChunkBits(dev, block)) {
+		T(YAFFS_TRACE_TRACING,
+				(TSTR
+				 ("Collecting block %d that has no chunks in use" TENDSTR),
+				 block));
+		yaffs_BlockBecameDirty(dev, block);
+	} else {
+
+		__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);
+
+		yaffs_VerifyBlock(dev, bi, block);
+
+		maxCopies = (wholeBlock) ? dev->nChunksPerBlock : 10;
+		oldChunk = block * dev->nChunksPerBlock + dev->gcChunk;
+
+		for (/* init already done */;
+		     retVal == YAFFS_OK &&
+		     dev->gcChunk < dev->nChunksPerBlock &&
+		     (bi->blockState == YAFFS_BLOCK_STATE_COLLECTING) &&
+		     maxCopies > 0;
+		     dev->gcChunk++, oldChunk++) {
+			if (yaffs_CheckChunkBit(dev, block, dev->gcChunk)) {
+
+				/* This page is in use and might need to be copied off */
+
+				maxCopies--;
+
+				markNAND = 1;
+
+				yaffs_InitialiseTags(&tags);
+
+				yaffs_ReadChunkWithTagsFromNAND(dev, oldChunk,
+								buffer, &tags);
+
+				object =
+				    yaffs_FindObjectByNumber(dev,
+							     tags.objectId);
+
+				T(YAFFS_TRACE_GC_DETAIL,
+				  (TSTR
+				   ("Collecting chunk in block %d, %d %d %d " TENDSTR),
+				   dev->gcChunk, tags.objectId, tags.chunkId,
+				   tags.byteCount));
+
+				if (object && !yaffs_SkipVerification(dev)) {
+					if (tags.chunkId == 0)
+						matchingChunk = object->hdrChunk;
+					else if (object->softDeleted)
+						matchingChunk = oldChunk; /* Defeat the test */
+					else
+						matchingChunk = yaffs_FindChunkInFile(object, tags.chunkId, NULL);
+
+					if (oldChunk != matchingChunk)
+						T(YAFFS_TRACE_ERROR,
+						  (TSTR("gc: page in gc mismatch: %d %d %d %d"TENDSTR),
+						  oldChunk, matchingChunk, tags.objectId, tags.chunkId));
+
+				}
+
+				if (!object) {
+					T(YAFFS_TRACE_ERROR,
+					  (TSTR
+					   ("page %d in gc has no object: %d %d %d "
+					    TENDSTR), oldChunk,
+					    tags.objectId, tags.chunkId, tags.byteCount));
+				}
+
+				if (object &&
+				    object->deleted &&
+				    object->softDeleted &&
+				    tags.chunkId != 0) {
+					/* Data chunk in a soft deleted file, throw it away
+					 * It's a soft deleted data chunk,
+					 * No need to copy this, just forget about it and
+					 * fix up the object.
+					 */
+
+					object->nDataChunks--;
+
+					if (object->nDataChunks <= 0) {
+						/* remeber to clean up the object */
+						dev->gcCleanupList[cleanups] =
+						    tags.objectId;
+						cleanups++;
+					}
+					markNAND = 0;
+				} else if (0) {
+					/* Todo object && object->deleted && object->nDataChunks == 0 */
+					/* Deleted object header with no data chunks.
+					 * Can be discarded and the file deleted.
+					 */
+					object->hdrChunk = 0;
+					yaffs_FreeTnode(object->myDev,
+							object->variant.
+							fileVariant.top);
+					object->variant.fileVariant.top = NULL;
+					yaffs_DoGenericObjectDeletion(object);
+
+				} else if (object) {
+					/* It's either a data chunk in a live file or
+					 * an ObjectHeader, so we're interested in it.
+					 * NB Need to keep the ObjectHeaders of deleted files
+					 * until the whole file has been deleted off
+					 */
+					tags.serialNumber++;
+
+					dev->nGCCopies++;
+
+					if (tags.chunkId == 0) {
+						/* It is an object Id,
+						 * We need to nuke the shrinkheader flags first
+						 * Also need to clean up shadowing.
+						 * We no longer want the shrinkHeader flag since its work is done
+						 * and if it is left in place it will mess up scanning.
+						 */
+
+						yaffs_ObjectHeader *oh;
+						oh = (yaffs_ObjectHeader *)buffer;
+						oh->isShrink = 0;
+						tags.extraIsShrinkHeader = 0;
+						oh->shadowsObject = 0;
+						oh->inbandShadowsObject = 0;
+						tags.extraShadows = 0;
+
+						yaffs_VerifyObjectHeader(object, oh, &tags, 1);
+					}
+
+					newChunk =
+					    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &tags, 1);
+
+					if (newChunk < 0) {
+						retVal = YAFFS_FAIL;
+					} else {
+
+						/* Ok, now fix up the Tnodes etc. */
+
+						if (tags.chunkId == 0) {
+							/* It's a header */
+							object->hdrChunk =  newChunk;
+							object->serial =   tags.serialNumber;
+						} else {
+							/* It's a data chunk */
+							yaffs_PutChunkIntoFile
+							    (object,
+							     tags.chunkId,
+							     newChunk, 0);
+						}
+					}
+				}
+
+				if (retVal == YAFFS_OK)
+					yaffs_DeleteChunk(dev, oldChunk, markNAND, __LINE__);
+
+			}
+		}
+
+		yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
+
+
+		/* Do any required cleanups */
+		for (i = 0; i < cleanups; i++) {
+			/* Time to delete the file too */
+			object =
+			    yaffs_FindObjectByNumber(dev,
+						     dev->gcCleanupList[i]);
+			if (object) {
+				yaffs_FreeTnode(dev,
+						object->variant.fileVariant.
+						top);
+				object->variant.fileVariant.top = NULL;
+				T(YAFFS_TRACE_GC,
+				  (TSTR
+				   ("yaffs: About to finally delete object %d"
+				    TENDSTR), object->objectId));
+				yaffs_DoGenericObjectDeletion(object);
+				object->myDev->nDeletedFiles--;
+			}
+
+		}
+
+	}
+
+	yaffs_VerifyCollectedBlock(dev, bi, block);
+
+	chunksAfter = yaffs_GetErasedChunks(dev);
+	if (chunksBefore >= chunksAfter) {
+		T(YAFFS_TRACE_GC,
+		  (TSTR
+		   ("gc did not increase free chunks before %d after %d"
+		    TENDSTR), chunksBefore, chunksAfter));
+	}
+
+	/* If the gc completed then clear the current gcBlock so that we find another. */
+	if (bi->blockState != YAFFS_BLOCK_STATE_COLLECTING) {
+		dev->gcBlock = -1;
+		dev->gcChunk = 0;
+	}
+
+	dev->isDoingGC = 0;
+
+	return retVal;
+}
+
+/* New garbage collector
+ * If we're very low on erased blocks then we do aggressive garbage collection
+ * otherwise we do "leasurely" garbage collection.
+ * Aggressive gc looks further (whole array) and will accept less dirty blocks.
+ * Passive gc only inspects smaller areas and will only accept more dirty blocks.
+ *
+ * The idea is to help clear out space in a more spread-out manner.
+ * Dunno if it really does anything useful.
+ */
+static int yaffs_CheckGarbageCollection(yaffs_Device *dev)
+{
+	int block;
+	int aggressive;
+	int gcOk = YAFFS_OK;
+	int maxTries = 0;
+
+	int checkpointBlockAdjust;
+
+	if (dev->isDoingGC) {
+		/* Bail out so we don't get recursive gc */
+		return YAFFS_OK;
+	}
+
+	/* This loop should pass the first time.
+	 * We'll only see looping here if the erase of the collected block fails.
+	 */
+
+	do {
+		maxTries++;
+
+		checkpointBlockAdjust = yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;
+		if (checkpointBlockAdjust < 0)
+			checkpointBlockAdjust = 0;
+
+		if (dev->nErasedBlocks < (dev->nReservedBlocks + checkpointBlockAdjust + 2)) {
+			/* We need a block soon...*/
+			aggressive = 1;
+		} else {
+			/* We're in no hurry */
+			aggressive = 0;
+		}
+
+		if (dev->gcBlock <= 0) {
+			dev->gcBlock = yaffs_FindBlockForGarbageCollection(dev, aggressive);
+			dev->gcChunk = 0;
+		}
+
+		block = dev->gcBlock;
+
+		if (block > 0) {
+			dev->garbageCollections++;
+			if (!aggressive)
+				dev->passiveGarbageCollections++;
+
+			T(YAFFS_TRACE_GC,
+			  (TSTR
+			   ("yaffs: GC erasedBlocks %d aggressive %d" TENDSTR),
+			   dev->nErasedBlocks, aggressive));
+
+			gcOk = yaffs_GarbageCollectBlock(dev, block, aggressive);
+		}
+
+		if (dev->nErasedBlocks < (dev->nReservedBlocks) && block > 0) {
+			T(YAFFS_TRACE_GC,
+			  (TSTR
+			   ("yaffs: GC !!!no reclaim!!! erasedBlocks %d after try %d block %d"
+			    TENDSTR), dev->nErasedBlocks, maxTries, block));
+		}
+	} while ((dev->nErasedBlocks < dev->nReservedBlocks) &&
+		 (block > 0) &&
+		 (maxTries < 2));
+
+	return aggressive ? gcOk : YAFFS_OK;
+}
+
+/*-------------------------  TAGS --------------------------------*/
+
+static int yaffs_TagsMatch(const yaffs_ExtendedTags *tags, int objectId,
+			   int chunkInObject)
+{
+	return (tags->chunkId == chunkInObject &&
+		tags->objectId == objectId && !tags->chunkDeleted) ? 1 : 0;
+
+}
+
+
+/*-------------------- Data file manipulation -----------------*/
+
+static int yaffs_FindChunkInFile(yaffs_Object *in, int chunkInInode,
+				 yaffs_ExtendedTags *tags)
+{
+	/*Get the Tnode, then get the level 0 offset chunk offset */
+	yaffs_Tnode *tn;
+	int theChunk = -1;
+	yaffs_ExtendedTags localTags;
+	int retVal = -1;
+
+	yaffs_Device *dev = in->myDev;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &localTags;
+	}
+
+	tn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);
+
+	if (tn) {
+		theChunk = yaffs_GetChunkGroupBase(dev, tn, chunkInInode);
+
+		retVal =
+		    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,
+					   chunkInInode);
+	}
+	return retVal;
+}
+
+static int yaffs_FindAndDeleteChunkInFile(yaffs_Object *in, int chunkInInode,
+					  yaffs_ExtendedTags *tags)
+{
+	/* Get the Tnode, then get the level 0 offset chunk offset */
+	yaffs_Tnode *tn;
+	int theChunk = -1;
+	yaffs_ExtendedTags localTags;
+
+	yaffs_Device *dev = in->myDev;
+	int retVal = -1;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &localTags;
+	}
+
+	tn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);
+
+	if (tn) {
+
+		theChunk = yaffs_GetChunkGroupBase(dev, tn, chunkInInode);
+
+		retVal =
+		    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,
+					   chunkInInode);
+
+		/* Delete the entry in the filestructure (if found) */
+		if (retVal != -1)
+			yaffs_PutLevel0Tnode(dev, tn, chunkInInode, 0);
+	}
+
+	return retVal;
+}
+
+#ifdef YAFFS_PARANOID
+
+static int yaffs_CheckFileSanity(yaffs_Object *in)
+{
+	int chunk;
+	int nChunks;
+	int fSize;
+	int failed = 0;
+	int objId;
+	yaffs_Tnode *tn;
+	yaffs_Tags localTags;
+	yaffs_Tags *tags = &localTags;
+	int theChunk;
+	int chunkDeleted;
+
+	if (in->variantType != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	objId = in->objectId;
+	fSize = in->variant.fileVariant.fileSize;
+	nChunks =
+	    (fSize + in->myDev->nDataBytesPerChunk - 1) / in->myDev->nDataBytesPerChunk;
+
+	for (chunk = 1; chunk <= nChunks; chunk++) {
+		tn = yaffs_FindLevel0Tnode(in->myDev, &in->variant.fileVariant,
+					   chunk);
+
+		if (tn) {
+
+			theChunk = yaffs_GetChunkGroupBase(dev, tn, chunk);
+
+			if (yaffs_CheckChunkBits
+			    (dev, theChunk / dev->nChunksPerBlock,
+			     theChunk % dev->nChunksPerBlock)) {
+
+				yaffs_ReadChunkTagsFromNAND(in->myDev, theChunk,
+							    tags,
+							    &chunkDeleted);
+				if (yaffs_TagsMatch
+				    (tags, in->objectId, chunk, chunkDeleted)) {
+					/* found it; */
+
+				}
+			} else {
+
+				failed = 1;
+			}
+
+		} else {
+			/* T(("No level 0 found for %d\n", chunk)); */
+		}
+	}
+
+	return failed ? YAFFS_FAIL : YAFFS_OK;
+}
+
+#endif
+
+static int yaffs_PutChunkIntoFile(yaffs_Object *in, int chunkInInode,
+				  int chunkInNAND, int inScan)
+{
+	/* NB inScan is zero unless scanning.
+	 * For forward scanning, inScan is > 0;
+	 * for backward scanning inScan is < 0
+	 */
+
+	yaffs_Tnode *tn;
+	yaffs_Device *dev = in->myDev;
+	int existingChunk;
+	yaffs_ExtendedTags existingTags;
+	yaffs_ExtendedTags newTags;
+	unsigned existingSerial, newSerial;
+
+	if (in->variantType != YAFFS_OBJECT_TYPE_FILE) {
+		/* Just ignore an attempt at putting a chunk into a non-file during scanning
+		 * If it is not during Scanning then something went wrong!
+		 */
+		if (!inScan) {
+			T(YAFFS_TRACE_ERROR,
+			  (TSTR
+			   ("yaffs tragedy:attempt to put data chunk into a non-file"
+			    TENDSTR)));
+			YBUG();
+		}
+
+		yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
+		return YAFFS_OK;
+	}
+
+	tn = yaffs_AddOrFindLevel0Tnode(dev,
+					&in->variant.fileVariant,
+					chunkInInode,
+					NULL);
+	if (!tn)
+		return YAFFS_FAIL;
+
+	existingChunk = yaffs_GetChunkGroupBase(dev, tn, chunkInInode);
+
+	if (inScan != 0) {
+		/* If we're scanning then we need to test for duplicates
+		 * NB This does not need to be efficient since it should only ever
+		 * happen when the power fails during a write, then only one
+		 * chunk should ever be affected.
+		 *
+		 * Correction for YAFFS2: This could happen quite a lot and we need to think about efficiency! TODO
+		 * Update: For backward scanning we don't need to re-read tags so this is quite cheap.
+		 */
+
+		if (existingChunk > 0) {
+			/* NB Right now existing chunk will not be real chunkId if the device >= 32MB
+			 *    thus we have to do a FindChunkInFile to get the real chunk id.
+			 *
+			 * We have a duplicate now we need to decide which one to use:
+			 *
+			 * Backwards scanning YAFFS2: The old one is what we use, dump the new one.
+			 * Forward scanning YAFFS2: The new one is what we use, dump the old one.
+			 * YAFFS1: Get both sets of tags and compare serial numbers.
+			 */
+
+			if (inScan > 0) {
+				/* Only do this for forward scanning */
+				yaffs_ReadChunkWithTagsFromNAND(dev,
+								chunkInNAND,
+								NULL, &newTags);
+
+				/* Do a proper find */
+				existingChunk =
+				    yaffs_FindChunkInFile(in, chunkInInode,
+							  &existingTags);
+			}
+
+			if (existingChunk <= 0) {
+				/*Hoosterman - how did this happen? */
+
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("yaffs tragedy: existing chunk < 0 in scan"
+				    TENDSTR)));
+
+			}
+
+			/* NB The deleted flags should be false, otherwise the chunks will
+			 * not be loaded during a scan
+			 */
+
+			if (inScan > 0) {
+				newSerial = newTags.serialNumber;
+				existingSerial = existingTags.serialNumber;
+			}
+
+			if ((inScan > 0) &&
+			    (in->myDev->isYaffs2 ||
+			     existingChunk <= 0 ||
+			     ((existingSerial + 1) & 3) == newSerial)) {
+				/* Forward scanning.
+				 * Use new
+				 * Delete the old one and drop through to update the tnode
+				 */
+				yaffs_DeleteChunk(dev, existingChunk, 1,
+						  __LINE__);
+			} else {
+				/* Backward scanning or we want to use the existing one
+				 * Use existing.
+				 * Delete the new one and return early so that the tnode isn't changed
+				 */
+				yaffs_DeleteChunk(dev, chunkInNAND, 1,
+						  __LINE__);
+				return YAFFS_OK;
+			}
+		}
+
+	}
+
+	if (existingChunk == 0)
+		in->nDataChunks++;
+
+	yaffs_PutLevel0Tnode(dev, tn, chunkInInode, chunkInNAND);
+
+	return YAFFS_OK;
+}
+
+static int yaffs_ReadChunkDataFromObject(yaffs_Object *in, int chunkInInode,
+					__u8 *buffer)
+{
+	int chunkInNAND = yaffs_FindChunkInFile(in, chunkInInode, NULL);
+
+	if (chunkInNAND >= 0)
+		return yaffs_ReadChunkWithTagsFromNAND(in->myDev, chunkInNAND,
+						buffer, NULL);
+	else {
+		T(YAFFS_TRACE_NANDACCESS,
+		  (TSTR("Chunk %d not found zero instead" TENDSTR),
+		   chunkInNAND));
+		/* get sane (zero) data if you read a hole */
+		memset(buffer, 0, in->myDev->nDataBytesPerChunk);
+		return 0;
+	}
+
+}
+
+void yaffs_DeleteChunk(yaffs_Device *dev, int chunkId, int markNAND, int lyn)
+{
+	int block;
+	int page;
+	yaffs_ExtendedTags tags;
+	yaffs_BlockInfo *bi;
+
+	if (chunkId <= 0)
+		return;
+
+	dev->nDeletions++;
+	block = chunkId / dev->nChunksPerBlock;
+	page = chunkId % dev->nChunksPerBlock;
+
+
+	if (!yaffs_CheckChunkBit(dev, block, page))
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Deleting invalid chunk %d"TENDSTR),
+			 chunkId));
+
+	bi = yaffs_GetBlockInfo(dev, block);
+
+	T(YAFFS_TRACE_DELETION,
+	  (TSTR("line %d delete of chunk %d" TENDSTR), lyn, chunkId));
+
+	if (markNAND &&
+	    bi->blockState != YAFFS_BLOCK_STATE_COLLECTING && !dev->isYaffs2) {
+
+		yaffs_InitialiseTags(&tags);
+
+		tags.chunkDeleted = 1;
+
+		yaffs_WriteChunkWithTagsToNAND(dev, chunkId, NULL, &tags);
+		yaffs_HandleUpdateChunk(dev, chunkId, &tags);
+	} else {
+		dev->nUnmarkedDeletions++;
+	}
+
+	/* Pull out of the management area.
+	 * If the whole block became dirty, this will kick off an erasure.
+	 */
+	if (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING ||
+	    bi->blockState == YAFFS_BLOCK_STATE_FULL ||
+	    bi->blockState == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
+	    bi->blockState == YAFFS_BLOCK_STATE_COLLECTING) {
+		dev->nFreeChunks++;
+
+		yaffs_ClearChunkBit(dev, block, page);
+
+		bi->pagesInUse--;
+
+		if (bi->pagesInUse == 0 &&
+		    !bi->hasShrinkHeader &&
+		    bi->blockState != YAFFS_BLOCK_STATE_ALLOCATING &&
+		    bi->blockState != YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+			yaffs_BlockBecameDirty(dev, block);
+		}
+
+	}
+
+}
+
+static int yaffs_WriteChunkDataToObject(yaffs_Object *in, int chunkInInode,
+					const __u8 *buffer, int nBytes,
+					int useReserve)
+{
+	/* Find old chunk Need to do this to get serial number
+	 * Write new one and patch into tree.
+	 * Invalidate old tags.
+	 */
+
+	int prevChunkId;
+	yaffs_ExtendedTags prevTags;
+
+	int newChunkId;
+	yaffs_ExtendedTags newTags;
+
+	yaffs_Device *dev = in->myDev;
+
+	yaffs_CheckGarbageCollection(dev);
+
+	/* Get the previous chunk at this location in the file if it exists */
+	prevChunkId = yaffs_FindChunkInFile(in, chunkInInode, &prevTags);
+
+	/* Set up new tags */
+	yaffs_InitialiseTags(&newTags);
+
+	newTags.chunkId = chunkInInode;
+	newTags.objectId = in->objectId;
+	newTags.serialNumber =
+	    (prevChunkId > 0) ? prevTags.serialNumber + 1 : 1;
+	newTags.byteCount = nBytes;
+
+	if (nBytes < 1 || nBytes > dev->totalBytesPerChunk) {
+		T(YAFFS_TRACE_ERROR,
+		(TSTR("Writing %d bytes to chunk!!!!!!!!!" TENDSTR), nBytes));
+		YBUG();
+	}
+
+	newChunkId =
+	    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,
+					      useReserve);
+
+	if (newChunkId >= 0) {
+		yaffs_PutChunkIntoFile(in, chunkInInode, newChunkId, 0);
+
+		if (prevChunkId > 0)
+			yaffs_DeleteChunk(dev, prevChunkId, 1, __LINE__);
+
+		yaffs_CheckFileSanity(in);
+	}
+	return newChunkId;
+
+}
+
+/* UpdateObjectHeader updates the header on NAND for an object.
+ * If name is not NULL, then that new name is used.
+ */
+int yaffs_UpdateObjectHeader(yaffs_Object *in, const YCHAR *name, int force,
+			     int isShrink, int shadows)
+{
+
+	yaffs_BlockInfo *bi;
+
+	yaffs_Device *dev = in->myDev;
+
+	int prevChunkId;
+	int retVal = 0;
+	int result = 0;
+
+	int newChunkId;
+	yaffs_ExtendedTags newTags;
+	yaffs_ExtendedTags oldTags;
+
+	__u8 *buffer = NULL;
+	YCHAR oldName[YAFFS_MAX_NAME_LENGTH + 1];
+
+	yaffs_ObjectHeader *oh = NULL;
+
+	yaffs_strcpy(oldName, _Y("silly old name"));
+
+
+	if (!in->fake ||
+		in == dev->rootDir || /* The rootDir should also be saved */
+		force) {
+
+		yaffs_CheckGarbageCollection(dev);
+		yaffs_CheckObjectDetailsLoaded(in);
+
+		buffer = yaffs_GetTempBuffer(in->myDev, __LINE__);
+		oh = (yaffs_ObjectHeader *) buffer;
+
+		prevChunkId = in->hdrChunk;
+
+		if (prevChunkId > 0) {
+			result = yaffs_ReadChunkWithTagsFromNAND(dev, prevChunkId,
+							buffer, &oldTags);
+
+			yaffs_VerifyObjectHeader(in, oh, &oldTags, 0);
+
+			memcpy(oldName, oh->name, sizeof(oh->name));
+		}
+
+		memset(buffer, 0xFF, dev->nDataBytesPerChunk);
+
+		oh->type = in->variantType;
+		oh->yst_mode = in->yst_mode;
+		oh->shadowsObject = oh->inbandShadowsObject = shadows;
+
+#ifdef CONFIG_YAFFS_WINCE
+		oh->win_atime[0] = in->win_atime[0];
+		oh->win_ctime[0] = in->win_ctime[0];
+		oh->win_mtime[0] = in->win_mtime[0];
+		oh->win_atime[1] = in->win_atime[1];
+		oh->win_ctime[1] = in->win_ctime[1];
+		oh->win_mtime[1] = in->win_mtime[1];
+#else
+		oh->yst_uid = in->yst_uid;
+		oh->yst_gid = in->yst_gid;
+		oh->yst_atime = in->yst_atime;
+		oh->yst_mtime = in->yst_mtime;
+		oh->yst_ctime = in->yst_ctime;
+		oh->yst_rdev = in->yst_rdev;
+#endif
+		if (in->parent)
+			oh->parentObjectId = in->parent->objectId;
+		else
+			oh->parentObjectId = 0;
+
+		if (name && *name) {
+			memset(oh->name, 0, sizeof(oh->name));
+			yaffs_strncpy(oh->name, name, YAFFS_MAX_NAME_LENGTH);
+		} else if (prevChunkId > 0)
+			memcpy(oh->name, oldName, sizeof(oh->name));
+		else
+			memset(oh->name, 0, sizeof(oh->name));
+
+		oh->isShrink = isShrink;
+
+		switch (in->variantType) {
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+			/* Should not happen */
+			break;
+		case YAFFS_OBJECT_TYPE_FILE:
+			oh->fileSize =
+			    (oh->parentObjectId == YAFFS_OBJECTID_DELETED
+			     || oh->parentObjectId ==
+			     YAFFS_OBJECTID_UNLINKED) ? 0 : in->variant.
+			    fileVariant.fileSize;
+			break;
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+			oh->equivalentObjectId =
+			    in->variant.hardLinkVariant.equivalentObjectId;
+			break;
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+			/* Do nothing */
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			/* Do nothing */
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			yaffs_strncpy(oh->alias,
+				      in->variant.symLinkVariant.alias,
+				      YAFFS_MAX_ALIAS_LENGTH);
+			oh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;
+			break;
+		}
+
+		/* Tags */
+		yaffs_InitialiseTags(&newTags);
+		in->serial++;
+		newTags.chunkId = 0;
+		newTags.objectId = in->objectId;
+		newTags.serialNumber = in->serial;
+
+		/* Add extra info for file header */
+
+		newTags.extraHeaderInfoAvailable = 1;
+		newTags.extraParentObjectId = oh->parentObjectId;
+		newTags.extraFileLength = oh->fileSize;
+		newTags.extraIsShrinkHeader = oh->isShrink;
+		newTags.extraEquivalentObjectId = oh->equivalentObjectId;
+		newTags.extraShadows = (oh->shadowsObject > 0) ? 1 : 0;
+		newTags.extraObjectType = in->variantType;
+
+		yaffs_VerifyObjectHeader(in, oh, &newTags, 1);
+
+		/* Create new chunk in NAND */
+		newChunkId =
+		    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,
+						      (prevChunkId > 0) ? 1 : 0);
+
+		if (newChunkId >= 0) {
+
+			in->hdrChunk = newChunkId;
+
+			if (prevChunkId > 0) {
+				yaffs_DeleteChunk(dev, prevChunkId, 1,
+						  __LINE__);
+			}
+
+			if (!yaffs_ObjectHasCachedWriteData(in))
+				in->dirty = 0;
+
+			/* If this was a shrink, then mark the block that the chunk lives on */
+			if (isShrink) {
+				bi = yaffs_GetBlockInfo(in->myDev,
+					newChunkId / in->myDev->nChunksPerBlock);
+				bi->hasShrinkHeader = 1;
+			}
+
+		}
+
+		retVal = newChunkId;
+
+	}
+
+	if (buffer)
+		yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
+
+	return retVal;
+}
+
+/*------------------------ Short Operations Cache ----------------------------------------
+ *   In many situations where there is no high level buffering (eg WinCE) a lot of
+ *   reads might be short sequential reads, and a lot of writes may be short
+ *   sequential writes. eg. scanning/writing a jpeg file.
+ *   In these cases, a short read/write cache can provide a huge perfomance benefit
+ *   with dumb-as-a-rock code.
+ *   In Linux, the page cache provides read buffering aand the short op cache provides write
+ *   buffering.
+ *
+ *   There are a limited number (~10) of cache chunks per device so that we don't
+ *   need a very intelligent search.
+ */
+
+static int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj)
+{
+	yaffs_Device *dev = obj->myDev;
+	int i;
+	yaffs_ChunkCache *cache;
+	int nCaches = obj->myDev->nShortOpCaches;
+
+	for (i = 0; i < nCaches; i++) {
+		cache = &dev->srCache[i];
+		if (cache->object == obj &&
+		    cache->dirty)
+			return 1;
+	}
+
+	return 0;
+}
+
+
+static void yaffs_FlushFilesChunkCache(yaffs_Object *obj)
+{
+	yaffs_Device *dev = obj->myDev;
+	int lowest = -99;	/* Stop compiler whining. */
+	int i;
+	yaffs_ChunkCache *cache;
+	int chunkWritten = 0;
+	int nCaches = obj->myDev->nShortOpCaches;
+
+	if (nCaches > 0) {
+		do {
+			cache = NULL;
+
+			/* Find the dirty cache for this object with the lowest chunk id. */
+			for (i = 0; i < nCaches; i++) {
+				if (dev->srCache[i].object == obj &&
+				    dev->srCache[i].dirty) {
+					if (!cache
+					    || dev->srCache[i].chunkId <
+					    lowest) {
+						cache = &dev->srCache[i];
+						lowest = cache->chunkId;
+					}
+				}
+			}
+
+			if (cache && !cache->locked) {
+				/* Write it out and free it up */
+
+				chunkWritten =
+				    yaffs_WriteChunkDataToObject(cache->object,
+								 cache->chunkId,
+								 cache->data,
+								 cache->nBytes,
+								 1);
+				cache->dirty = 0;
+				cache->object = NULL;
+			}
+
+		} while (cache && chunkWritten > 0);
+
+		if (cache) {
+			/* Hoosterman, disk full while writing cache out. */
+			T(YAFFS_TRACE_ERROR,
+			  (TSTR("yaffs tragedy: no space during cache write" TENDSTR)));
+
+		}
+	}
+
+}
+
+/*yaffs_FlushEntireDeviceCache(dev)
+ *
+ *
+ */
+
+void yaffs_FlushEntireDeviceCache(yaffs_Device *dev)
+{
+	yaffs_Object *obj;
+	int nCaches = dev->nShortOpCaches;
+	int i;
+
+	/* Find a dirty object in the cache and flush it...
+	 * until there are no further dirty objects.
+	 */
+	do {
+		obj = NULL;
+		for (i = 0; i < nCaches && !obj; i++) {
+			if (dev->srCache[i].object &&
+			    dev->srCache[i].dirty)
+				obj = dev->srCache[i].object;
+
+		}
+		if (obj)
+			yaffs_FlushFilesChunkCache(obj);
+
+	} while (obj);
+
+}
+
+
+/* Grab us a cache chunk for use.
+ * First look for an empty one.
+ * Then look for the least recently used non-dirty one.
+ * Then look for the least recently used dirty one...., flush and look again.
+ */
+static yaffs_ChunkCache *yaffs_GrabChunkCacheWorker(yaffs_Device *dev)
+{
+	int i;
+
+	if (dev->nShortOpCaches > 0) {
+		for (i = 0; i < dev->nShortOpCaches; i++) {
+			if (!dev->srCache[i].object)
+				return &dev->srCache[i];
+		}
+	}
+
+	return NULL;
+}
+
+static yaffs_ChunkCache *yaffs_GrabChunkCache(yaffs_Device *dev)
+{
+	yaffs_ChunkCache *cache;
+	yaffs_Object *theObj;
+	int usage;
+	int i;
+	int pushout;
+
+	if (dev->nShortOpCaches > 0) {
+		/* Try find a non-dirty one... */
+
+		cache = yaffs_GrabChunkCacheWorker(dev);
+
+		if (!cache) {
+			/* They were all dirty, find the last recently used object and flush
+			 * its cache, then  find again.
+			 * NB what's here is not very accurate, we actually flush the object
+			 * the last recently used page.
+			 */
+
+			/* With locking we can't assume we can use entry zero */
+
+			theObj = NULL;
+			usage = -1;
+			cache = NULL;
+			pushout = -1;
+
+			for (i = 0; i < dev->nShortOpCaches; i++) {
+				if (dev->srCache[i].object &&
+				    !dev->srCache[i].locked &&
+				    (dev->srCache[i].lastUse < usage || !cache)) {
+					usage = dev->srCache[i].lastUse;
+					theObj = dev->srCache[i].object;
+					cache = &dev->srCache[i];
+					pushout = i;
+				}
+			}
+
+			if (!cache || cache->dirty) {
+				/* Flush and try again */
+				yaffs_FlushFilesChunkCache(theObj);
+				cache = yaffs_GrabChunkCacheWorker(dev);
+			}
+
+		}
+		return cache;
+	} else
+		return NULL;
+
+}
+
+/* Find a cached chunk */
+static yaffs_ChunkCache *yaffs_FindChunkCache(const yaffs_Object *obj,
+					      int chunkId)
+{
+	yaffs_Device *dev = obj->myDev;
+	int i;
+	if (dev->nShortOpCaches > 0) {
+		for (i = 0; i < dev->nShortOpCaches; i++) {
+			if (dev->srCache[i].object == obj &&
+			    dev->srCache[i].chunkId == chunkId) {
+				dev->cacheHits++;
+
+				return &dev->srCache[i];
+			}
+		}
+	}
+	return NULL;
+}
+
+/* Mark the chunk for the least recently used algorithym */
+static void yaffs_UseChunkCache(yaffs_Device *dev, yaffs_ChunkCache *cache,
+				int isAWrite)
+{
+
+	if (dev->nShortOpCaches > 0) {
+		if (dev->srLastUse < 0 || dev->srLastUse > 100000000) {
+			/* Reset the cache usages */
+			int i;
+			for (i = 1; i < dev->nShortOpCaches; i++)
+				dev->srCache[i].lastUse = 0;
+
+			dev->srLastUse = 0;
+		}
+
+		dev->srLastUse++;
+
+		cache->lastUse = dev->srLastUse;
+
+		if (isAWrite)
+			cache->dirty = 1;
+	}
+}
+
+/* Invalidate a single cache page.
+ * Do this when a whole page gets written,
+ * ie the short cache for this page is no longer valid.
+ */
+static void yaffs_InvalidateChunkCache(yaffs_Object *object, int chunkId)
+{
+	if (object->myDev->nShortOpCaches > 0) {
+		yaffs_ChunkCache *cache = yaffs_FindChunkCache(object, chunkId);
+
+		if (cache)
+			cache->object = NULL;
+	}
+}
+
+/* Invalidate all the cache pages associated with this object
+ * Do this whenever ther file is deleted or resized.
+ */
+static void yaffs_InvalidateWholeChunkCache(yaffs_Object *in)
+{
+	int i;
+	yaffs_Device *dev = in->myDev;
+
+	if (dev->nShortOpCaches > 0) {
+		/* Invalidate it. */
+		for (i = 0; i < dev->nShortOpCaches; i++) {
+			if (dev->srCache[i].object == in)
+				dev->srCache[i].object = NULL;
+		}
+	}
+}
+
+/*--------------------- Checkpointing --------------------*/
+
+
+static int yaffs_WriteCheckpointValidityMarker(yaffs_Device *dev, int head)
+{
+	yaffs_CheckpointValidity cp;
+
+	memset(&cp, 0, sizeof(cp));
+
+	cp.structType = sizeof(cp);
+	cp.magic = YAFFS_MAGIC;
+	cp.version = YAFFS_CHECKPOINT_VERSION;
+	cp.head = (head) ? 1 : 0;
+
+	return (yaffs_CheckpointWrite(dev, &cp, sizeof(cp)) == sizeof(cp)) ?
+		1 : 0;
+}
+
+static int yaffs_ReadCheckpointValidityMarker(yaffs_Device *dev, int head)
+{
+	yaffs_CheckpointValidity cp;
+	int ok;
+
+	ok = (yaffs_CheckpointRead(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	if (ok)
+		ok = (cp.structType == sizeof(cp)) &&
+		     (cp.magic == YAFFS_MAGIC) &&
+		     (cp.version == YAFFS_CHECKPOINT_VERSION) &&
+		     (cp.head == ((head) ? 1 : 0));
+	return ok ? 1 : 0;
+}
+
+static void yaffs_DeviceToCheckpointDevice(yaffs_CheckpointDevice *cp,
+					   yaffs_Device *dev)
+{
+	cp->nErasedBlocks = dev->nErasedBlocks;
+	cp->allocationBlock = dev->allocationBlock;
+	cp->allocationPage = dev->allocationPage;
+	cp->nFreeChunks = dev->nFreeChunks;
+
+	cp->nDeletedFiles = dev->nDeletedFiles;
+	cp->nUnlinkedFiles = dev->nUnlinkedFiles;
+	cp->nBackgroundDeletions = dev->nBackgroundDeletions;
+	cp->sequenceNumber = dev->sequenceNumber;
+	cp->oldestDirtySequence = dev->oldestDirtySequence;
+
+}
+
+static void yaffs_CheckpointDeviceToDevice(yaffs_Device *dev,
+					   yaffs_CheckpointDevice *cp)
+{
+	dev->nErasedBlocks = cp->nErasedBlocks;
+	dev->allocationBlock = cp->allocationBlock;
+	dev->allocationPage = cp->allocationPage;
+	dev->nFreeChunks = cp->nFreeChunks;
+
+	dev->nDeletedFiles = cp->nDeletedFiles;
+	dev->nUnlinkedFiles = cp->nUnlinkedFiles;
+	dev->nBackgroundDeletions = cp->nBackgroundDeletions;
+	dev->sequenceNumber = cp->sequenceNumber;
+	dev->oldestDirtySequence = cp->oldestDirtySequence;
+}
+
+
+static int yaffs_WriteCheckpointDevice(yaffs_Device *dev)
+{
+	yaffs_CheckpointDevice cp;
+	__u32 nBytes;
+	__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);
+
+	int ok;
+
+	/* Write device runtime values*/
+	yaffs_DeviceToCheckpointDevice(&cp, dev);
+	cp.structType = sizeof(cp);
+
+	ok = (yaffs_CheckpointWrite(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	/* Write block info */
+	if (ok) {
+		nBytes = nBlocks * sizeof(yaffs_BlockInfo);
+		ok = (yaffs_CheckpointWrite(dev, dev->blockInfo, nBytes) == nBytes);
+	}
+
+	/* Write chunk bits */
+	if (ok) {
+		nBytes = nBlocks * dev->chunkBitmapStride;
+		ok = (yaffs_CheckpointWrite(dev, dev->chunkBits, nBytes) == nBytes);
+	}
+	return	 ok ? 1 : 0;
+
+}
+
+static int yaffs_ReadCheckpointDevice(yaffs_Device *dev)
+{
+	yaffs_CheckpointDevice cp;
+	__u32 nBytes;
+	__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);
+
+	int ok;
+
+	ok = (yaffs_CheckpointRead(dev, &cp, sizeof(cp)) == sizeof(cp));
+	if (!ok)
+		return 0;
+
+	if (cp.structType != sizeof(cp))
+		return 0;
+
+
+	yaffs_CheckpointDeviceToDevice(dev, &cp);
+
+	nBytes = nBlocks * sizeof(yaffs_BlockInfo);
+
+	ok = (yaffs_CheckpointRead(dev, dev->blockInfo, nBytes) == nBytes);
+
+	if (!ok)
+		return 0;
+	nBytes = nBlocks * dev->chunkBitmapStride;
+
+	ok = (yaffs_CheckpointRead(dev, dev->chunkBits, nBytes) == nBytes);
+
+	return ok ? 1 : 0;
+}
+
+static void yaffs_ObjectToCheckpointObject(yaffs_CheckpointObject *cp,
+					   yaffs_Object *obj)
+{
+
+	cp->objectId = obj->objectId;
+	cp->parentId = (obj->parent) ? obj->parent->objectId : 0;
+	cp->hdrChunk = obj->hdrChunk;
+	cp->variantType = obj->variantType;
+	cp->deleted = obj->deleted;
+	cp->softDeleted = obj->softDeleted;
+	cp->unlinked = obj->unlinked;
+	cp->fake = obj->fake;
+	cp->renameAllowed = obj->renameAllowed;
+	cp->unlinkAllowed = obj->unlinkAllowed;
+	cp->serial = obj->serial;
+	cp->nDataChunks = obj->nDataChunks;
+
+	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE)
+		cp->fileSizeOrEquivalentObjectId = obj->variant.fileVariant.fileSize;
+	else if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)
+		cp->fileSizeOrEquivalentObjectId = obj->variant.hardLinkVariant.equivalentObjectId;
+}
+
+static int yaffs_CheckpointObjectToObject(yaffs_Object *obj, yaffs_CheckpointObject *cp)
+{
+
+	yaffs_Object *parent;
+
+	if (obj->variantType != cp->variantType) {
+		T(YAFFS_TRACE_ERROR, (TSTR("Checkpoint read object %d type %d "
+			TCONT("chunk %d does not match existing object type %d")
+			TENDSTR), cp->objectId, cp->variantType, cp->hdrChunk,
+			obj->variantType));
+		return 0;
+	}
+
+	obj->objectId = cp->objectId;
+
+	if (cp->parentId)
+		parent = yaffs_FindOrCreateObjectByNumber(
+					obj->myDev,
+					cp->parentId,
+					YAFFS_OBJECT_TYPE_DIRECTORY);
+	else
+		parent = NULL;
+
+	if (parent) {
+		if (parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+			T(YAFFS_TRACE_ALWAYS, (TSTR("Checkpoint read object %d parent %d type %d"
+				TCONT(" chunk %d Parent type, %d, not directory")
+				TENDSTR),
+				cp->objectId, cp->parentId, cp->variantType,
+				cp->hdrChunk, parent->variantType));
+			return 0;
+		}
+		yaffs_AddObjectToDirectory(parent, obj);
+	}
+
+	obj->hdrChunk = cp->hdrChunk;
+	obj->variantType = cp->variantType;
+	obj->deleted = cp->deleted;
+	obj->softDeleted = cp->softDeleted;
+	obj->unlinked = cp->unlinked;
+	obj->fake = cp->fake;
+	obj->renameAllowed = cp->renameAllowed;
+	obj->unlinkAllowed = cp->unlinkAllowed;
+	obj->serial = cp->serial;
+	obj->nDataChunks = cp->nDataChunks;
+
+	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE)
+		obj->variant.fileVariant.fileSize = cp->fileSizeOrEquivalentObjectId;
+	else if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)
+		obj->variant.hardLinkVariant.equivalentObjectId = cp->fileSizeOrEquivalentObjectId;
+
+	if (obj->hdrChunk > 0)
+		obj->lazyLoaded = 1;
+	return 1;
+}
+
+
+
+static int yaffs_CheckpointTnodeWorker(yaffs_Object *in, yaffs_Tnode *tn,
+					__u32 level, int chunkOffset)
+{
+	int i;
+	yaffs_Device *dev = in->myDev;
+	int ok = 1;
+	int tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
+
+	if (tnodeSize < sizeof(yaffs_Tnode))
+		tnodeSize = sizeof(yaffs_Tnode);
+
+
+	if (tn) {
+		if (level > 0) {
+
+			for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
+				if (tn->internal[i]) {
+					ok = yaffs_CheckpointTnodeWorker(in,
+							tn->internal[i],
+							level - 1,
+							(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);
+				}
+			}
+		} else if (level == 0) {
+			__u32 baseOffset = chunkOffset <<  YAFFS_TNODES_LEVEL0_BITS;
+			ok = (yaffs_CheckpointWrite(dev, &baseOffset, sizeof(baseOffset)) == sizeof(baseOffset));
+			if (ok)
+				ok = (yaffs_CheckpointWrite(dev, tn, tnodeSize) == tnodeSize);
+		}
+	}
+
+	return ok;
+
+}
+
+static int yaffs_WriteCheckpointTnodes(yaffs_Object *obj)
+{
+	__u32 endMarker = ~0;
+	int ok = 1;
+
+	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE) {
+		ok = yaffs_CheckpointTnodeWorker(obj,
+					    obj->variant.fileVariant.top,
+					    obj->variant.fileVariant.topLevel,
+					    0);
+		if (ok)
+			ok = (yaffs_CheckpointWrite(obj->myDev, &endMarker, sizeof(endMarker)) ==
+				sizeof(endMarker));
+	}
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs_ReadCheckpointTnodes(yaffs_Object *obj)
+{
+	__u32 baseChunk;
+	int ok = 1;
+	yaffs_Device *dev = obj->myDev;
+	yaffs_FileStructure *fileStructPtr = &obj->variant.fileVariant;
+	yaffs_Tnode *tn;
+	int nread = 0;
+	int tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
+
+	if (tnodeSize < sizeof(yaffs_Tnode))
+		tnodeSize = sizeof(yaffs_Tnode);
+
+	ok = (yaffs_CheckpointRead(dev, &baseChunk, sizeof(baseChunk)) == sizeof(baseChunk));
+
+	while (ok && (~baseChunk)) {
+		nread++;
+		/* Read level 0 tnode */
+
+
+		tn = yaffs_GetTnodeRaw(dev);
+		if (tn)
+			ok = (yaffs_CheckpointRead(dev, tn, tnodeSize) == tnodeSize);
+		else
+			ok = 0;
+
+		if (tn && ok)
+			ok = yaffs_AddOrFindLevel0Tnode(dev,
+							fileStructPtr,
+							baseChunk,
+							tn) ? 1 : 0;
+
+		if (ok)
+			ok = (yaffs_CheckpointRead(dev, &baseChunk, sizeof(baseChunk)) == sizeof(baseChunk));
+
+	}
+
+	T(YAFFS_TRACE_CHECKPOINT, (
+		TSTR("Checkpoint read tnodes %d records, last %d. ok %d" TENDSTR),
+		nread, baseChunk, ok));
+
+	return ok ? 1 : 0;
+}
+
+
+static int yaffs_WriteCheckpointObjects(yaffs_Device *dev)
+{
+	yaffs_Object *obj;
+	yaffs_CheckpointObject cp;
+	int i;
+	int ok = 1;
+	struct ylist_head *lh;
+
+
+	/* Iterate through the objects in each hash entry,
+	 * dumping them to the checkpointing stream.
+	 */
+
+	for (i = 0; ok &&  i <  YAFFS_NOBJECT_BUCKETS; i++) {
+		ylist_for_each(lh, &dev->objectBucket[i].list) {
+			if (lh) {
+				obj = ylist_entry(lh, yaffs_Object, hashLink);
+				if (!obj->deferedFree) {
+					yaffs_ObjectToCheckpointObject(&cp, obj);
+					cp.structType = sizeof(cp);
+
+					T(YAFFS_TRACE_CHECKPOINT, (
+						TSTR("Checkpoint write object %d parent %d type %d chunk %d obj addr %x" TENDSTR),
+						cp.objectId, cp.parentId, cp.variantType, cp.hdrChunk, (unsigned) obj));
+
+					ok = (yaffs_CheckpointWrite(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+					if (ok && obj->variantType == YAFFS_OBJECT_TYPE_FILE)
+						ok = yaffs_WriteCheckpointTnodes(obj);
+				}
+			}
+		}
+	}
+
+	/* Dump end of list */
+	memset(&cp, 0xFF, sizeof(yaffs_CheckpointObject));
+	cp.structType = sizeof(cp);
+
+	if (ok)
+		ok = (yaffs_CheckpointWrite(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs_ReadCheckpointObjects(yaffs_Device *dev)
+{
+	yaffs_Object *obj;
+	yaffs_CheckpointObject cp;
+	int ok = 1;
+	int done = 0;
+	yaffs_Object *hardList = NULL;
+
+	while (ok && !done) {
+		ok = (yaffs_CheckpointRead(dev, &cp, sizeof(cp)) == sizeof(cp));
+		if (cp.structType != sizeof(cp)) {
+			T(YAFFS_TRACE_CHECKPOINT, (TSTR("struct size %d instead of %d ok %d"TENDSTR),
+				cp.structType, sizeof(cp), ok));
+			ok = 0;
+		}
+
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("Checkpoint read object %d parent %d type %d chunk %d " TENDSTR),
+			cp.objectId, cp.parentId, cp.variantType, cp.hdrChunk));
+
+		if (ok && cp.objectId == ~0)
+			done = 1;
+		else if (ok) {
+			obj = yaffs_FindOrCreateObjectByNumber(dev, cp.objectId, cp.variantType);
+			if (obj) {
+				ok = yaffs_CheckpointObjectToObject(obj, &cp);
+				if (!ok)
+					break;
+				if (obj->variantType == YAFFS_OBJECT_TYPE_FILE) {
+					ok = yaffs_ReadCheckpointTnodes(obj);
+				} else if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
+					obj->hardLinks.next =
+						(struct ylist_head *) hardList;
+					hardList = obj;
+				}
+			} else
+				ok = 0;
+		}
+	}
+
+	if (ok)
+		yaffs_HardlinkFixup(dev, hardList);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs_WriteCheckpointSum(yaffs_Device *dev)
+{
+	__u32 checkpointSum;
+	int ok;
+
+	yaffs_GetCheckpointSum(dev, &checkpointSum);
+
+	ok = (yaffs_CheckpointWrite(dev, &checkpointSum, sizeof(checkpointSum)) == sizeof(checkpointSum));
+
+	if (!ok)
+		return 0;
+
+	return 1;
+}
+
+static int yaffs_ReadCheckpointSum(yaffs_Device *dev)
+{
+	__u32 checkpointSum0;
+	__u32 checkpointSum1;
+	int ok;
+
+	yaffs_GetCheckpointSum(dev, &checkpointSum0);
+
+	ok = (yaffs_CheckpointRead(dev, &checkpointSum1, sizeof(checkpointSum1)) == sizeof(checkpointSum1));
+
+	if (!ok)
+		return 0;
+
+	if (checkpointSum0 != checkpointSum1)
+		return 0;
+
+	return 1;
+}
+
+
+static int yaffs_WriteCheckpointData(yaffs_Device *dev)
+{
+	int ok = 1;
+
+	if (dev->skipCheckpointWrite || !dev->isYaffs2) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("skipping checkpoint write" TENDSTR)));
+		ok = 0;
+	}
+
+	if (ok)
+		ok = yaffs_CheckpointOpen(dev, 1);
+
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint validity" TENDSTR)));
+		ok = yaffs_WriteCheckpointValidityMarker(dev, 1);
+	}
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint device" TENDSTR)));
+		ok = yaffs_WriteCheckpointDevice(dev);
+	}
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint objects" TENDSTR)));
+		ok = yaffs_WriteCheckpointObjects(dev);
+	}
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint validity" TENDSTR)));
+		ok = yaffs_WriteCheckpointValidityMarker(dev, 0);
+	}
+
+	if (ok)
+		ok = yaffs_WriteCheckpointSum(dev);
+
+	if (!yaffs_CheckpointClose(dev))
+		ok = 0;
+
+	if (ok)
+		dev->isCheckpointed = 1;
+	else
+		dev->isCheckpointed = 0;
+
+	return dev->isCheckpointed;
+}
+
+static int yaffs_ReadCheckpointData(yaffs_Device *dev)
+{
+	int ok = 1;
+
+	if (dev->skipCheckpointRead || !dev->isYaffs2) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("skipping checkpoint read" TENDSTR)));
+		ok = 0;
+	}
+
+	if (ok)
+		ok = yaffs_CheckpointOpen(dev, 0); /* open for read */
+
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint validity" TENDSTR)));
+		ok = yaffs_ReadCheckpointValidityMarker(dev, 1);
+	}
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint device" TENDSTR)));
+		ok = yaffs_ReadCheckpointDevice(dev);
+	}
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint objects" TENDSTR)));
+		ok = yaffs_ReadCheckpointObjects(dev);
+	}
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint validity" TENDSTR)));
+		ok = yaffs_ReadCheckpointValidityMarker(dev, 0);
+	}
+
+	if (ok) {
+		ok = yaffs_ReadCheckpointSum(dev);
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint checksum %d" TENDSTR), ok));
+	}
+
+	if (!yaffs_CheckpointClose(dev))
+		ok = 0;
+
+	if (ok)
+		dev->isCheckpointed = 1;
+	else
+		dev->isCheckpointed = 0;
+
+	return ok ? 1 : 0;
+
+}
+
+static void yaffs_InvalidateCheckpoint(yaffs_Device *dev)
+{
+	if (dev->isCheckpointed ||
+			dev->blocksInCheckpoint > 0) {
+		dev->isCheckpointed = 0;
+		yaffs_CheckpointInvalidateStream(dev);
+		if (dev->superBlock && dev->markSuperBlockDirty)
+			dev->markSuperBlockDirty(dev->superBlock);
+	}
+}
+
+
+int yaffs_CheckpointSave(yaffs_Device *dev)
+{
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("save entry: isCheckpointed %d"TENDSTR), dev->isCheckpointed));
+
+	yaffs_VerifyObjects(dev);
+	yaffs_VerifyBlocks(dev);
+	yaffs_VerifyFreeChunks(dev);
+
+	if (!dev->isCheckpointed) {
+		yaffs_InvalidateCheckpoint(dev);
+		yaffs_WriteCheckpointData(dev);
+	}
+
+	T(YAFFS_TRACE_ALWAYS, (TSTR("save exit: isCheckpointed %d"TENDSTR), dev->isCheckpointed));
+
+	return dev->isCheckpointed;
+}
+
+int yaffs_CheckpointRestore(yaffs_Device *dev)
+{
+	int retval;
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("restore entry: isCheckpointed %d"TENDSTR), dev->isCheckpointed));
+
+	retval = yaffs_ReadCheckpointData(dev);
+
+	if (dev->isCheckpointed) {
+		yaffs_VerifyObjects(dev);
+		yaffs_VerifyBlocks(dev);
+		yaffs_VerifyFreeChunks(dev);
+	}
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("restore exit: isCheckpointed %d"TENDSTR), dev->isCheckpointed));
+
+	return retval;
+}
+
+/*--------------------- File read/write ------------------------
+ * Read and write have very similar structures.
+ * In general the read/write has three parts to it
+ * An incomplete chunk to start with (if the read/write is not chunk-aligned)
+ * Some complete chunks
+ * An incomplete chunk to end off with
+ *
+ * Curve-balls: the first chunk might also be the last chunk.
+ */
+
+int yaffs_ReadDataFromFile(yaffs_Object *in, __u8 *buffer, loff_t offset,
+			int nBytes)
+{
+
+	int chunk;
+	__u32 start;
+	int nToCopy;
+	int n = nBytes;
+	int nDone = 0;
+	yaffs_ChunkCache *cache;
+
+	yaffs_Device *dev;
+
+	dev = in->myDev;
+
+	while (n > 0) {
+		/* chunk = offset / dev->nDataBytesPerChunk + 1; */
+		/* start = offset % dev->nDataBytesPerChunk; */
+		yaffs_AddrToChunk(dev, offset, &chunk, &start);
+		chunk++;
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+		if ((start + n) < dev->nDataBytesPerChunk)
+			nToCopy = n;
+		else
+			nToCopy = dev->nDataBytesPerChunk - start;
+
+		cache = yaffs_FindChunkCache(in, chunk);
+
+		/* If the chunk is already in the cache or it is less than a whole chunk
+		 * or we're using inband tags then use the cache (if there is caching)
+		 * else bypass the cache.
+		 */
+		if (cache || nToCopy != dev->nDataBytesPerChunk || dev->inbandTags) {
+			if (dev->nShortOpCaches > 0) {
+
+				/* If we can't find the data in the cache, then load it up. */
+
+				if (!cache) {
+					cache = yaffs_GrabChunkCache(in->myDev);
+					cache->object = in;
+					cache->chunkId = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_ReadChunkDataFromObject(in, chunk,
+								      cache->
+								      data);
+					cache->nBytes = 0;
+				}
+
+				yaffs_UseChunkCache(dev, cache, 0);
+
+				cache->locked = 1;
+
+
+				memcpy(buffer, &cache->data[start], nToCopy);
+
+				cache->locked = 0;
+			} else {
+				/* Read into the local buffer then copy..*/
+
+				__u8 *localBuffer =
+				    yaffs_GetTempBuffer(dev, __LINE__);
+				yaffs_ReadChunkDataFromObject(in, chunk,
+							      localBuffer);
+
+				memcpy(buffer, &localBuffer[start], nToCopy);
+
+
+				yaffs_ReleaseTempBuffer(dev, localBuffer,
+							__LINE__);
+			}
+
+		} else {
+
+			/* A full chunk. Read directly into the supplied buffer. */
+			yaffs_ReadChunkDataFromObject(in, chunk, buffer);
+
+		}
+
+		n -= nToCopy;
+		offset += nToCopy;
+		buffer += nToCopy;
+		nDone += nToCopy;
+
+	}
+
+	return nDone;
+}
+
+int yaffs_WriteDataToFile(yaffs_Object *in, const __u8 *buffer, loff_t offset,
+			int nBytes, int writeThrough)
+{
+
+	int chunk;
+	__u32 start;
+	int nToCopy;
+	int n = nBytes;
+	int nDone = 0;
+	int nToWriteBack;
+	int startOfWrite = offset;
+	int chunkWritten = 0;
+	__u32 nBytesRead;
+	__u32 chunkStart;
+
+	yaffs_Device *dev;
+
+	dev = in->myDev;
+
+	while (n > 0 && chunkWritten >= 0) {
+		/* chunk = offset / dev->nDataBytesPerChunk + 1; */
+		/* start = offset % dev->nDataBytesPerChunk; */
+		yaffs_AddrToChunk(dev, offset, &chunk, &start);
+
+		if (chunk * dev->nDataBytesPerChunk + start != offset ||
+				start >= dev->nDataBytesPerChunk) {
+			T(YAFFS_TRACE_ERROR, (
+			   TSTR("AddrToChunk of offset %d gives chunk %d start %d"
+			   TENDSTR),
+			   (int)offset, chunk, start));
+		}
+		chunk++;
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+
+		if ((start + n) < dev->nDataBytesPerChunk) {
+			nToCopy = n;
+
+			/* Now folks, to calculate how many bytes to write back....
+			 * If we're overwriting and not writing to then end of file then
+			 * we need to write back as much as was there before.
+			 */
+
+			chunkStart = ((chunk - 1) * dev->nDataBytesPerChunk);
+
+			if (chunkStart > in->variant.fileVariant.fileSize)
+				nBytesRead = 0; /* Past end of file */
+			else
+				nBytesRead = in->variant.fileVariant.fileSize - chunkStart;
+
+			if (nBytesRead > dev->nDataBytesPerChunk)
+				nBytesRead = dev->nDataBytesPerChunk;
+
+			nToWriteBack =
+			    (nBytesRead >
+			     (start + n)) ? nBytesRead : (start + n);
+
+			if (nToWriteBack < 0 || nToWriteBack > dev->nDataBytesPerChunk)
+				YBUG();
+
+		} else {
+			nToCopy = dev->nDataBytesPerChunk - start;
+			nToWriteBack = dev->nDataBytesPerChunk;
+		}
+
+		if (nToCopy != dev->nDataBytesPerChunk || dev->inbandTags) {
+			/* An incomplete start or end chunk (or maybe both start and end chunk),
+			 * or we're using inband tags, so we want to use the cache buffers.
+			 */
+			if (dev->nShortOpCaches > 0) {
+				yaffs_ChunkCache *cache;
+				/* If we can't find the data in the cache, then load the cache */
+				cache = yaffs_FindChunkCache(in, chunk);
+
+				if (!cache
+				    && yaffs_CheckSpaceForAllocation(in->
+								     myDev)) {
+					cache = yaffs_GrabChunkCache(in->myDev);
+					cache->object = in;
+					cache->chunkId = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_ReadChunkDataFromObject(in, chunk,
+								      cache->
+								      data);
+				} else if (cache &&
+					!cache->dirty &&
+					!yaffs_CheckSpaceForAllocation(in->myDev)) {
+					/* Drop the cache if it was a read cache item and
+					 * no space check has been made for it.
+					 */
+					 cache = NULL;
+				}
+
+				if (cache) {
+					yaffs_UseChunkCache(dev, cache, 1);
+					cache->locked = 1;
+
+
+					memcpy(&cache->data[start], buffer,
+					       nToCopy);
+
+
+					cache->locked = 0;
+					cache->nBytes = nToWriteBack;
+
+					if (writeThrough) {
+						chunkWritten =
+						    yaffs_WriteChunkDataToObject
+						    (cache->object,
+						     cache->chunkId,
+						     cache->data, cache->nBytes,
+						     1);
+						cache->dirty = 0;
+					}
+
+				} else {
+					chunkWritten = -1;	/* fail the write */
+				}
+			} else {
+				/* An incomplete start or end chunk (or maybe both start and end chunk)
+				 * Read into the local buffer then copy, then copy over and write back.
+				 */
+
+				__u8 *localBuffer =
+				    yaffs_GetTempBuffer(dev, __LINE__);
+
+				yaffs_ReadChunkDataFromObject(in, chunk,
+							      localBuffer);
+
+
+
+				memcpy(&localBuffer[start], buffer, nToCopy);
+
+				chunkWritten =
+				    yaffs_WriteChunkDataToObject(in, chunk,
+								 localBuffer,
+								 nToWriteBack,
+								 0);
+
+				yaffs_ReleaseTempBuffer(dev, localBuffer,
+							__LINE__);
+
+			}
+
+		} else {
+			/* A full chunk. Write directly from the supplied buffer. */
+
+
+
+			chunkWritten =
+			    yaffs_WriteChunkDataToObject(in, chunk, buffer,
+							 dev->nDataBytesPerChunk,
+							 0);
+
+			/* Since we've overwritten the cached data, we better invalidate it. */
+			yaffs_InvalidateChunkCache(in, chunk);
+		}
+
+		if (chunkWritten >= 0) {
+			n -= nToCopy;
+			offset += nToCopy;
+			buffer += nToCopy;
+			nDone += nToCopy;
+		}
+
+	}
+
+	/* Update file object */
+
+	if ((startOfWrite + nDone) > in->variant.fileVariant.fileSize)
+		in->variant.fileVariant.fileSize = (startOfWrite + nDone);
+
+	in->dirty = 1;
+
+	return nDone;
+}
+
+
+/* ---------------------- File resizing stuff ------------------ */
+
+static void yaffs_PruneResizedChunks(yaffs_Object *in, int newSize)
+{
+
+	yaffs_Device *dev = in->myDev;
+	int oldFileSize = in->variant.fileVariant.fileSize;
+
+	int lastDel = 1 + (oldFileSize - 1) / dev->nDataBytesPerChunk;
+
+	int startDel = 1 + (newSize + dev->nDataBytesPerChunk - 1) /
+	    dev->nDataBytesPerChunk;
+	int i;
+	int chunkId;
+
+	/* Delete backwards so that we don't end up with holes if
+	 * power is lost part-way through the operation.
+	 */
+	for (i = lastDel; i >= startDel; i--) {
+		/* NB this could be optimised somewhat,
+		 * eg. could retrieve the tags and write them without
+		 * using yaffs_DeleteChunk
+		 */
+
+		chunkId = yaffs_FindAndDeleteChunkInFile(in, i, NULL);
+		if (chunkId > 0) {
+			if (chunkId <
+			    (dev->internalStartBlock * dev->nChunksPerBlock)
+			    || chunkId >=
+			    ((dev->internalEndBlock +
+			      1) * dev->nChunksPerBlock)) {
+				T(YAFFS_TRACE_ALWAYS,
+				  (TSTR("Found daft chunkId %d for %d" TENDSTR),
+				   chunkId, i));
+			} else {
+				in->nDataChunks--;
+				yaffs_DeleteChunk(dev, chunkId, 1, __LINE__);
+			}
+		}
+	}
+
+}
+
+int yaffs_ResizeFile(yaffs_Object *in, loff_t newSize)
+{
+
+	int oldFileSize = in->variant.fileVariant.fileSize;
+	__u32 newSizeOfPartialChunk;
+	int newFullChunks;
+
+	yaffs_Device *dev = in->myDev;
+
+	yaffs_AddrToChunk(dev, newSize, &newFullChunks, &newSizeOfPartialChunk);
+
+	yaffs_FlushFilesChunkCache(in);
+	yaffs_InvalidateWholeChunkCache(in);
+
+	yaffs_CheckGarbageCollection(dev);
+
+	if (in->variantType != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	if (newSize == oldFileSize)
+		return YAFFS_OK;
+
+	if (newSize < oldFileSize) {
+
+		yaffs_PruneResizedChunks(in, newSize);
+
+		if (newSizeOfPartialChunk != 0) {
+			int lastChunk = 1 + newFullChunks;
+
+			__u8 *localBuffer = yaffs_GetTempBuffer(dev, __LINE__);
+
+			/* Got to read and rewrite the last chunk with its new size and zero pad */
+			yaffs_ReadChunkDataFromObject(in, lastChunk,
+						      localBuffer);
+
+			memset(localBuffer + newSizeOfPartialChunk, 0,
+			       dev->nDataBytesPerChunk - newSizeOfPartialChunk);
+
+			yaffs_WriteChunkDataToObject(in, lastChunk, localBuffer,
+						     newSizeOfPartialChunk, 1);
+
+			yaffs_ReleaseTempBuffer(dev, localBuffer, __LINE__);
+		}
+
+		in->variant.fileVariant.fileSize = newSize;
+
+		yaffs_PruneFileStructure(dev, &in->variant.fileVariant);
+	} else {
+		/* newsSize > oldFileSize */
+		in->variant.fileVariant.fileSize = newSize;
+	}
+
+
+	/* Write a new object header to reflect the resize.
+	 * show we've shrunk the file, if need be
+	 * Do this only if the file is not in the deleted directories
+	 * and is not shadowed.
+	 */
+	if (in->parent &&
+	    !in->isShadowed &&
+	    in->parent->objectId != YAFFS_OBJECTID_UNLINKED &&
+	    in->parent->objectId != YAFFS_OBJECTID_DELETED)
+		yaffs_UpdateObjectHeader(in, NULL, 0,
+					 (newSize < oldFileSize) ? 1 : 0, 0);
+
+	return YAFFS_OK;
+}
+
+loff_t yaffs_GetFileSize(yaffs_Object *obj)
+{
+	obj = yaffs_GetEquivalentObject(obj);
+
+	switch (obj->variantType) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		return obj->variant.fileVariant.fileSize;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		return yaffs_strlen(obj->variant.symLinkVariant.alias);
+	default:
+		return 0;
+	}
+}
+
+
+
+int yaffs_FlushFile(yaffs_Object *in, int updateTime)
+{
+	int retVal;
+	if (in->dirty) {
+		yaffs_FlushFilesChunkCache(in);
+		if (updateTime) {
+#ifdef CONFIG_YAFFS_WINCE
+			yfsd_WinFileTimeNow(in->win_mtime);
+#else
+
+			in->yst_mtime = Y_CURRENT_TIME;
+
+#endif
+		}
+
+		retVal = (yaffs_UpdateObjectHeader(in, NULL, 0, 0, 0) >=
+			0) ? YAFFS_OK : YAFFS_FAIL;
+	} else {
+		retVal = YAFFS_OK;
+	}
+
+	return retVal;
+
+}
+
+static int yaffs_DoGenericObjectDeletion(yaffs_Object *in)
+{
+
+	/* First off, invalidate the file's data in the cache, without flushing. */
+	yaffs_InvalidateWholeChunkCache(in);
+
+	if (in->myDev->isYaffs2 && (in->parent != in->myDev->deletedDir)) {
+		/* Move to the unlinked directory so we have a record that it was deleted. */
+		yaffs_ChangeObjectName(in, in->myDev->deletedDir, _Y("deleted"), 0, 0);
+
+	}
+
+	yaffs_RemoveObjectFromDirectory(in);
+	yaffs_DeleteChunk(in->myDev, in->hdrChunk, 1, __LINE__);
+	in->hdrChunk = 0;
+
+	yaffs_FreeObject(in);
+	return YAFFS_OK;
+
+}
+
+/* yaffs_DeleteFile deletes the whole file data
+ * and the inode associated with the file.
+ * It does not delete the links associated with the file.
+ */
+static int yaffs_UnlinkFileIfNeeded(yaffs_Object *in)
+{
+
+	int retVal;
+	int immediateDeletion = 0;
+
+#ifdef __KERNEL__
+	if (!in->myInode)
+		immediateDeletion = 1;
+#else
+	if (in->inUse <= 0)
+		immediateDeletion = 1;
+#endif
+
+	if (immediateDeletion) {
+		retVal =
+		    yaffs_ChangeObjectName(in, in->myDev->deletedDir,
+					   _Y("deleted"), 0, 0);
+		T(YAFFS_TRACE_TRACING,
+		  (TSTR("yaffs: immediate deletion of file %d" TENDSTR),
+		   in->objectId));
+		in->deleted = 1;
+		in->myDev->nDeletedFiles++;
+		if (1 || in->myDev->isYaffs2)
+			yaffs_ResizeFile(in, 0);
+		yaffs_SoftDeleteFile(in);
+	} else {
+		retVal =
+		    yaffs_ChangeObjectName(in, in->myDev->unlinkedDir,
+					   _Y("unlinked"), 0, 0);
+	}
+
+
+	return retVal;
+}
+
+int yaffs_DeleteFile(yaffs_Object *in)
+{
+	int retVal = YAFFS_OK;
+	int deleted = in->deleted;
+
+	yaffs_ResizeFile(in, 0);
+
+	if (in->nDataChunks > 0) {
+		/* Use soft deletion if there is data in the file.
+		 * That won't be the case if it has been resized to zero.
+		 */
+		if (!in->unlinked)
+			retVal = yaffs_UnlinkFileIfNeeded(in);
+
+		if (retVal == YAFFS_OK && in->unlinked && !in->deleted) {
+			in->deleted = 1;
+			deleted = 1;
+			in->myDev->nDeletedFiles++;
+			yaffs_SoftDeleteFile(in);
+		}
+		return deleted ? YAFFS_OK : YAFFS_FAIL;
+	} else {
+		/* The file has no data chunks so we toss it immediately */
+		yaffs_FreeTnode(in->myDev, in->variant.fileVariant.top);
+		in->variant.fileVariant.top = NULL;
+		yaffs_DoGenericObjectDeletion(in);
+
+		return YAFFS_OK;
+	}
+}
+
+static int yaffs_IsNonEmptyDirectory(yaffs_Object *obj)
+{
+	return (obj->variantType == YAFFS_OBJECT_TYPE_DIRECTORY) &&
+		!(ylist_empty(&obj->variant.directoryVariant.children));
+}
+
+static int yaffs_DeleteDirectory(yaffs_Object *obj)
+{
+	/* First check that the directory is empty. */
+	if (yaffs_IsNonEmptyDirectory(obj))
+		return YAFFS_FAIL;
+
+	return yaffs_DoGenericObjectDeletion(obj);
+}
+
+static int yaffs_DeleteSymLink(yaffs_Object *in)
+{
+	YFREE(in->variant.symLinkVariant.alias);
+
+	return yaffs_DoGenericObjectDeletion(in);
+}
+
+static int yaffs_DeleteHardLink(yaffs_Object *in)
+{
+	/* remove this hardlink from the list assocaited with the equivalent
+	 * object
+	 */
+	ylist_del_init(&in->hardLinks);
+	return yaffs_DoGenericObjectDeletion(in);
+}
+
+int yaffs_DeleteObject(yaffs_Object *obj)
+{
+int retVal = -1;
+	switch (obj->variantType) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		retVal = yaffs_DeleteFile(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		return yaffs_DeleteDirectory(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		retVal = yaffs_DeleteSymLink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		retVal = yaffs_DeleteHardLink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		retVal = yaffs_DoGenericObjectDeletion(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		retVal = 0;
+		break;		/* should not happen. */
+	}
+
+	return retVal;
+}
+
+static int yaffs_UnlinkWorker(yaffs_Object *obj)
+{
+
+	int immediateDeletion = 0;
+
+#ifdef __KERNEL__
+	if (!obj->myInode)
+		immediateDeletion = 1;
+#else
+	if (obj->inUse <= 0)
+		immediateDeletion = 1;
+#endif
+
+	if(obj)
+		yaffs_UpdateParent(obj->parent);
+
+	if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
+		return yaffs_DeleteHardLink(obj);
+	} else if (!ylist_empty(&obj->hardLinks)) {
+		/* Curve ball: We're unlinking an object that has a hardlink.
+		 *
+		 * This problem arises because we are not strictly following
+		 * The Linux link/inode model.
+		 *
+		 * We can't really delete the object.
+		 * Instead, we do the following:
+		 * - Select a hardlink.
+		 * - Unhook it from the hard links
+		 * - Unhook it from its parent directory (so that the rename can work)
+		 * - Rename the object to the hardlink's name.
+		 * - Delete the hardlink
+		 */
+
+		yaffs_Object *hl;
+		int retVal;
+		YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+
+		hl = ylist_entry(obj->hardLinks.next, yaffs_Object, hardLinks);
+
+		ylist_del_init(&hl->hardLinks);
+		ylist_del_init(&hl->siblings);
+
+		yaffs_GetObjectName(hl, name, YAFFS_MAX_NAME_LENGTH + 1);
+
+		retVal = yaffs_ChangeObjectName(obj, hl->parent, name, 0, 0);
+
+		if (retVal == YAFFS_OK)
+			retVal = yaffs_DoGenericObjectDeletion(hl);
+
+		return retVal;
+
+	} else if (immediateDeletion) {
+		switch (obj->variantType) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			return yaffs_DeleteFile(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			return yaffs_DeleteDirectory(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			return yaffs_DeleteSymLink(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+			return yaffs_DoGenericObjectDeletion(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		default:
+			return YAFFS_FAIL;
+		}
+	} else if(yaffs_IsNonEmptyDirectory(obj))
+		return YAFFS_FAIL;
+	else
+		return yaffs_ChangeObjectName(obj, obj->myDev->unlinkedDir,
+					   _Y("unlinked"), 0, 0);
+}
+
+
+static int yaffs_UnlinkObject(yaffs_Object *obj)
+{
+
+	if (obj && obj->unlinkAllowed)
+		return yaffs_UnlinkWorker(obj);
+
+	return YAFFS_FAIL;
+
+}
+int yaffs_Unlink(yaffs_Object *dir, const YCHAR *name)
+{
+	yaffs_Object *obj;
+
+	obj = yaffs_FindObjectByName(dir, name);
+	return yaffs_UnlinkObject(obj);
+}
+
+/*----------------------- Initialisation Scanning ---------------------- */
+
+static void yaffs_HandleShadowedObject(yaffs_Device *dev, int objId,
+				int backwardScanning)
+{
+	yaffs_Object *obj;
+
+	if (!backwardScanning) {
+		/* Handle YAFFS1 forward scanning case
+		 * For YAFFS1 we always do the deletion
+		 */
+
+	} else {
+		/* Handle YAFFS2 case (backward scanning)
+		 * If the shadowed object exists then ignore.
+		 */
+		obj = yaffs_FindObjectByNumber(dev, objId);
+		if(obj)
+			return;
+	}
+
+	/* Let's create it (if it does not exist) assuming it is a file so that it can do shrinking etc.
+	 * We put it in unlinked dir to be cleaned up after the scanning
+	 */
+	obj =
+	    yaffs_FindOrCreateObjectByNumber(dev, objId,
+					     YAFFS_OBJECT_TYPE_FILE);
+	if (!obj)
+		return;
+	obj->isShadowed = 1;
+	yaffs_AddObjectToDirectory(dev->unlinkedDir, obj);
+	obj->variant.fileVariant.shrinkSize = 0;
+	obj->valid = 1;		/* So that we don't read any other info for this file */
+
+}
+
+typedef struct {
+	int seq;
+	int block;
+} yaffs_BlockIndex;
+
+
+static void yaffs_HardlinkFixup(yaffs_Device *dev, yaffs_Object *hardList)
+{
+	yaffs_Object *hl;
+	yaffs_Object *in;
+
+	while (hardList) {
+		hl = hardList;
+		hardList = (yaffs_Object *) (hardList->hardLinks.next);
+
+		in = yaffs_FindObjectByNumber(dev,
+					      hl->variant.hardLinkVariant.
+					      equivalentObjectId);
+
+		if (in) {
+			/* Add the hardlink pointers */
+			hl->variant.hardLinkVariant.equivalentObject = in;
+			ylist_add(&hl->hardLinks, &in->hardLinks);
+		} else {
+			/* Todo Need to report/handle this better.
+			 * Got a problem... hardlink to a non-existant object
+			 */
+			hl->variant.hardLinkVariant.equivalentObject = NULL;
+			YINIT_LIST_HEAD(&hl->hardLinks);
+
+		}
+	}
+}
+
+
+
+
+
+static int ybicmp(const void *a, const void *b)
+{
+	register int aseq = ((yaffs_BlockIndex *)a)->seq;
+	register int bseq = ((yaffs_BlockIndex *)b)->seq;
+	register int ablock = ((yaffs_BlockIndex *)a)->block;
+	register int bblock = ((yaffs_BlockIndex *)b)->block;
+	if (aseq == bseq)
+		return ablock - bblock;
+	else
+		return aseq - bseq;
+}
+
+
+struct yaffs_ShadowFixerStruct {
+	int objectId;
+	int shadowedId;
+	struct yaffs_ShadowFixerStruct *next;
+};
+
+
+static void yaffs_StripDeletedObjects(yaffs_Device *dev)
+{
+	/*
+	*  Sort out state of unlinked and deleted objects after scanning.
+	*/
+	struct ylist_head *i;
+	struct ylist_head *n;
+	yaffs_Object *l;
+
+	/* Soft delete all the unlinked files */
+	ylist_for_each_safe(i, n,
+		&dev->unlinkedDir->variant.directoryVariant.children) {
+		if (i) {
+			l = ylist_entry(i, yaffs_Object, siblings);
+			yaffs_DeleteObject(l);
+		}
+	}
+
+	ylist_for_each_safe(i, n,
+		&dev->deletedDir->variant.directoryVariant.children) {
+		if (i) {
+			l = ylist_entry(i, yaffs_Object, siblings);
+			yaffs_DeleteObject(l);
+		}
+	}
+
+}
+
+/*
+ * This code iterates through all the objects making sure that they are rooted.
+ * Any unrooted objects are re-rooted in lost+found.
+ * An object needs to be in one of:
+ * - Directly under deleted, unlinked
+ * - Directly or indirectly under root.
+ *
+ * Note:
+ *  This code assumes that we don't ever change the current relationships between
+ *  directories:
+ *   rootDir->parent == unlinkedDir->parent == deletedDir->parent == NULL
+ *   lostNfound->parent == rootDir
+ *
+ * This fixes the problem where directories might have inadvertently been deleted
+ * leaving the object "hanging" without being rooted in the directory tree.
+ */
+
+static int yaffs_HasNULLParent(yaffs_Device *dev, yaffs_Object *obj)
+{
+	return (obj == dev->deletedDir ||
+		obj == dev->unlinkedDir||
+		obj == dev->rootDir);
+}
+
+static void yaffs_FixHangingObjects(yaffs_Device *dev)
+{
+	yaffs_Object *obj;
+	yaffs_Object *parent;
+	int i;
+	struct ylist_head *lh;
+	struct ylist_head *n;
+	int depthLimit;
+	int hanging;
+
+
+	/* Iterate through the objects in each hash entry,
+	 * looking at each object.
+	 * Make sure it is rooted.
+	 */
+
+	for (i = 0; i <  YAFFS_NOBJECT_BUCKETS; i++) {
+		ylist_for_each_safe(lh, n, &dev->objectBucket[i].list) {
+			if (lh) {
+				obj = ylist_entry(lh, yaffs_Object, hashLink);
+				parent= obj->parent;
+
+				if(yaffs_HasNULLParent(dev,obj)){
+					/* These directories are not hanging */
+					hanging = 0;
+				}
+				else if(!parent || parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+					hanging = 1;
+				else if(yaffs_HasNULLParent(dev,parent))
+					hanging = 0;
+				else {
+					/*
+					 * Need to follow the parent chain to see if it is hanging.
+					 */
+					hanging = 0;
+					depthLimit=100;
+
+					while(parent != dev->rootDir &&
+						parent->parent &&
+						parent->parent->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&
+						depthLimit > 0){
+						parent = parent->parent;
+						depthLimit--;
+					}
+					if(parent != dev->rootDir)
+						hanging = 1;
+				}
+				if(hanging){
+					T(YAFFS_TRACE_SCAN,
+					(TSTR("Hanging object %d moved to lost and found" TENDSTR),
+					obj->objectId));
+					yaffs_AddObjectToDirectory(dev->lostNFoundDir,obj);
+				}
+			}
+		}
+	}
+}
+
+
+/*
+ * Delete directory contents for cleaning up lost and found.
+ */
+static void yaffs_DeleteDirectoryContents(yaffs_Object *dir)
+{
+	yaffs_Object *obj;
+	struct ylist_head *lh;
+	struct ylist_head *n;
+
+	if(dir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+		YBUG();
+
+	ylist_for_each_safe(lh, n, &dir->variant.directoryVariant.children) {
+		if (lh) {
+			obj = ylist_entry(lh, yaffs_Object, siblings);
+			if(obj->variantType == YAFFS_OBJECT_TYPE_DIRECTORY)
+				yaffs_DeleteDirectoryContents(obj);
+
+			T(YAFFS_TRACE_SCAN,
+				(TSTR("Deleting lost_found object %d" TENDSTR),
+				obj->objectId));
+
+			/* Need to use UnlinkObject since Delete would not handle
+			 * hardlinked objects correctly.
+			 */
+			yaffs_UnlinkObject(obj);
+		}
+	}
+
+}
+
+static void yaffs_EmptyLostAndFound(yaffs_Device *dev)
+{
+	yaffs_DeleteDirectoryContents(dev->lostNFoundDir);
+}
+
+static int yaffs_Scan(yaffs_Device *dev)
+{
+	yaffs_ExtendedTags tags;
+	int blk;
+	int blockIterator;
+	int startIterator;
+	int endIterator;
+	int result;
+
+	int chunk;
+	int c;
+	int deleted;
+	yaffs_BlockState state;
+	yaffs_Object *hardList = NULL;
+	yaffs_BlockInfo *bi;
+	__u32 sequenceNumber;
+	yaffs_ObjectHeader *oh;
+	yaffs_Object *in;
+	yaffs_Object *parent;
+
+	int alloc_failed = 0;
+
+	struct yaffs_ShadowFixerStruct *shadowFixerList = NULL;
+
+
+	__u8 *chunkData;
+
+
+
+	T(YAFFS_TRACE_SCAN,
+	  (TSTR("yaffs_Scan starts  intstartblk %d intendblk %d..." TENDSTR),
+	   dev->internalStartBlock, dev->internalEndBlock));
+
+	chunkData = yaffs_GetTempBuffer(dev, __LINE__);
+
+	dev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;
+
+	/* Scan all the blocks to determine their state */
+	for (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {
+		bi = yaffs_GetBlockInfo(dev, blk);
+		yaffs_ClearChunkBits(dev, blk);
+		bi->pagesInUse = 0;
+		bi->softDeletions = 0;
+
+		yaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);
+
+		bi->blockState = state;
+		bi->sequenceNumber = sequenceNumber;
+
+		if (bi->sequenceNumber == YAFFS_SEQUENCE_BAD_BLOCK)
+			bi->blockState = state = YAFFS_BLOCK_STATE_DEAD;
+
+		T(YAFFS_TRACE_SCAN_DEBUG,
+		  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,
+		   state, sequenceNumber));
+
+		if (state == YAFFS_BLOCK_STATE_DEAD) {
+			T(YAFFS_TRACE_BAD_BLOCKS,
+			  (TSTR("block %d is bad" TENDSTR), blk));
+		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
+			T(YAFFS_TRACE_SCAN_DEBUG,
+			  (TSTR("Block empty " TENDSTR)));
+			dev->nErasedBlocks++;
+			dev->nFreeChunks += dev->nChunksPerBlock;
+		}
+	}
+
+	startIterator = dev->internalStartBlock;
+	endIterator = dev->internalEndBlock;
+
+	/* For each block.... */
+	for (blockIterator = startIterator; !alloc_failed && blockIterator <= endIterator;
+	     blockIterator++) {
+
+		YYIELD();
+
+		YYIELD();
+
+		blk = blockIterator;
+
+		bi = yaffs_GetBlockInfo(dev, blk);
+		state = bi->blockState;
+
+		deleted = 0;
+
+		/* For each chunk in each block that needs scanning....*/
+		for (c = 0; !alloc_failed && c < dev->nChunksPerBlock &&
+		     state == YAFFS_BLOCK_STATE_NEEDS_SCANNING; c++) {
+			/* Read the tags and decide what to do */
+			chunk = blk * dev->nChunksPerBlock + c;
+
+			result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,
+							&tags);
+
+			/* Let's have a good look at this chunk... */
+
+			if (tags.eccResult == YAFFS_ECC_RESULT_UNFIXED || tags.chunkDeleted) {
+				/* YAFFS1 only...
+				 * A deleted chunk
+				 */
+				deleted++;
+				dev->nFreeChunks++;
+				/*T((" %d %d deleted\n",blk,c)); */
+			} else if (!tags.chunkUsed) {
+				/* An unassigned chunk in the block
+				 * This means that either the block is empty or
+				 * this is the one being allocated from
+				 */
+
+				if (c == 0) {
+					/* We're looking at the first chunk in the block so the block is unused */
+					state = YAFFS_BLOCK_STATE_EMPTY;
+					dev->nErasedBlocks++;
+				} else {
+					/* this is the block being allocated from */
+					T(YAFFS_TRACE_SCAN,
+					  (TSTR
+					   (" Allocating from %d %d" TENDSTR),
+					   blk, c));
+					state = YAFFS_BLOCK_STATE_ALLOCATING;
+					dev->allocationBlock = blk;
+					dev->allocationPage = c;
+					dev->allocationBlockFinder = blk;
+					/* Set it to here to encourage the allocator to go forth from here. */
+
+				}
+
+				dev->nFreeChunks += (dev->nChunksPerBlock - c);
+			} else if (tags.chunkId > 0) {
+				/* chunkId > 0 so it is a data chunk... */
+				unsigned int endpos;
+
+				yaffs_SetChunkBit(dev, blk, c);
+				bi->pagesInUse++;
+
+				in = yaffs_FindOrCreateObjectByNumber(dev,
+								      tags.
+								      objectId,
+								      YAFFS_OBJECT_TYPE_FILE);
+				/* PutChunkIntoFile checks for a clash (two data chunks with
+				 * the same chunkId).
+				 */
+
+				if (!in)
+					alloc_failed = 1;
+
+				if (in) {
+					if (!yaffs_PutChunkIntoFile(in, tags.chunkId, chunk, 1))
+						alloc_failed = 1;
+				}
+
+				endpos =
+				    (tags.chunkId - 1) * dev->nDataBytesPerChunk +
+				    tags.byteCount;
+				if (in &&
+				    in->variantType == YAFFS_OBJECT_TYPE_FILE
+				    && in->variant.fileVariant.scannedFileSize <
+				    endpos) {
+					in->variant.fileVariant.
+					    scannedFileSize = endpos;
+					if (!dev->useHeaderFileSize) {
+						in->variant.fileVariant.
+						    fileSize =
+						    in->variant.fileVariant.
+						    scannedFileSize;
+					}
+
+				}
+				/* T((" %d %d data %d %d\n",blk,c,tags.objectId,tags.chunkId));   */
+			} else {
+				/* chunkId == 0, so it is an ObjectHeader.
+				 * Thus, we read in the object header and make the object
+				 */
+				yaffs_SetChunkBit(dev, blk, c);
+				bi->pagesInUse++;
+
+				result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk,
+								chunkData,
+								NULL);
+
+				oh = (yaffs_ObjectHeader *) chunkData;
+
+				in = yaffs_FindObjectByNumber(dev,
+							      tags.objectId);
+				if (in && in->variantType != oh->type) {
+					/* This should not happen, but somehow
+					 * Wev'e ended up with an objectId that has been reused but not yet
+					 * deleted, and worse still it has changed type. Delete the old object.
+					 */
+
+					yaffs_DeleteObject(in);
+
+					in = 0;
+				}
+
+				in = yaffs_FindOrCreateObjectByNumber(dev,
+								      tags.
+								      objectId,
+								      oh->type);
+
+				if (!in)
+					alloc_failed = 1;
+
+				if (in && oh->shadowsObject > 0) {
+
+					struct yaffs_ShadowFixerStruct *fixer;
+					fixer = YMALLOC(sizeof(struct yaffs_ShadowFixerStruct));
+					if (fixer) {
+						fixer->next = shadowFixerList;
+						shadowFixerList = fixer;
+						fixer->objectId = tags.objectId;
+						fixer->shadowedId = oh->shadowsObject;
+					}
+
+				}
+
+				if (in && in->valid) {
+					/* We have already filled this one. We have a duplicate and need to resolve it. */
+
+					unsigned existingSerial = in->serial;
+					unsigned newSerial = tags.serialNumber;
+
+					if (((existingSerial + 1) & 3) == newSerial) {
+						/* Use new one - destroy the exisiting one */
+						yaffs_DeleteChunk(dev,
+								  in->hdrChunk,
+								  1, __LINE__);
+						in->valid = 0;
+					} else {
+						/* Use existing - destroy this one. */
+						yaffs_DeleteChunk(dev, chunk, 1,
+								  __LINE__);
+					}
+				}
+
+				if (in && !in->valid &&
+				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
+				     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND)) {
+					/* We only load some info, don't fiddle with directory structure */
+					in->valid = 1;
+					in->variantType = oh->type;
+
+					in->yst_mode = oh->yst_mode;
+#ifdef CONFIG_YAFFS_WINCE
+					in->win_atime[0] = oh->win_atime[0];
+					in->win_ctime[0] = oh->win_ctime[0];
+					in->win_mtime[0] = oh->win_mtime[0];
+					in->win_atime[1] = oh->win_atime[1];
+					in->win_ctime[1] = oh->win_ctime[1];
+					in->win_mtime[1] = oh->win_mtime[1];
+#else
+					in->yst_uid = oh->yst_uid;
+					in->yst_gid = oh->yst_gid;
+					in->yst_atime = oh->yst_atime;
+					in->yst_mtime = oh->yst_mtime;
+					in->yst_ctime = oh->yst_ctime;
+					in->yst_rdev = oh->yst_rdev;
+#endif
+					in->hdrChunk = chunk;
+					in->serial = tags.serialNumber;
+
+				} else if (in && !in->valid) {
+					/* we need to load this info */
+
+					in->valid = 1;
+					in->variantType = oh->type;
+
+					in->yst_mode = oh->yst_mode;
+#ifdef CONFIG_YAFFS_WINCE
+					in->win_atime[0] = oh->win_atime[0];
+					in->win_ctime[0] = oh->win_ctime[0];
+					in->win_mtime[0] = oh->win_mtime[0];
+					in->win_atime[1] = oh->win_atime[1];
+					in->win_ctime[1] = oh->win_ctime[1];
+					in->win_mtime[1] = oh->win_mtime[1];
+#else
+					in->yst_uid = oh->yst_uid;
+					in->yst_gid = oh->yst_gid;
+					in->yst_atime = oh->yst_atime;
+					in->yst_mtime = oh->yst_mtime;
+					in->yst_ctime = oh->yst_ctime;
+					in->yst_rdev = oh->yst_rdev;
+#endif
+					in->hdrChunk = chunk;
+					in->serial = tags.serialNumber;
+
+					yaffs_SetObjectName(in, oh->name);
+					in->dirty = 0;
+
+					/* directory stuff...
+					 * hook up to parent
+					 */
+
+					parent =
+					    yaffs_FindOrCreateObjectByNumber
+					    (dev, oh->parentObjectId,
+					     YAFFS_OBJECT_TYPE_DIRECTORY);
+					if (!parent)
+						alloc_failed = 1;
+					if (parent && parent->variantType ==
+					    YAFFS_OBJECT_TYPE_UNKNOWN) {
+						/* Set up as a directory */
+						parent->variantType =
+							YAFFS_OBJECT_TYPE_DIRECTORY;
+						YINIT_LIST_HEAD(&parent->variant.
+								directoryVariant.
+								children);
+					} else if (!parent || parent->variantType !=
+						   YAFFS_OBJECT_TYPE_DIRECTORY) {
+						/* Hoosterman, another problem....
+						 * We're trying to use a non-directory as a directory
+						 */
+
+						T(YAFFS_TRACE_ERROR,
+						  (TSTR
+						   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+						    TENDSTR)));
+						parent = dev->lostNFoundDir;
+					}
+
+					yaffs_AddObjectToDirectory(parent, in);
+
+					if (0 && (parent == dev->deletedDir ||
+						  parent == dev->unlinkedDir)) {
+						in->deleted = 1;	/* If it is unlinked at start up then it wants deleting */
+						dev->nDeletedFiles++;
+					}
+					/* Note re hardlinks.
+					 * Since we might scan a hardlink before its equivalent object is scanned
+					 * we put them all in a list.
+					 * After scanning is complete, we should have all the objects, so we run through this
+					 * list and fix up all the chains.
+					 */
+
+					switch (in->variantType) {
+					case YAFFS_OBJECT_TYPE_UNKNOWN:
+						/* Todo got a problem */
+						break;
+					case YAFFS_OBJECT_TYPE_FILE:
+						if (dev->useHeaderFileSize)
+
+							in->variant.fileVariant.
+							    fileSize =
+							    oh->fileSize;
+
+						break;
+					case YAFFS_OBJECT_TYPE_HARDLINK:
+						in->variant.hardLinkVariant.
+							equivalentObjectId =
+							oh->equivalentObjectId;
+						in->hardLinks.next =
+							(struct ylist_head *)
+							hardList;
+						hardList = in;
+						break;
+					case YAFFS_OBJECT_TYPE_DIRECTORY:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SPECIAL:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SYMLINK:
+						in->variant.symLinkVariant.alias =
+						    yaffs_CloneString(oh->alias);
+						if (!in->variant.symLinkVariant.alias)
+							alloc_failed = 1;
+						break;
+					}
+
+/*
+					if (parent == dev->deletedDir) {
+						yaffs_DestroyObject(in);
+						bi->hasShrinkHeader = 1;
+					}
+*/
+				}
+			}
+		}
+
+		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+			/* If we got this far while scanning, then the block is fully allocated.*/
+			state = YAFFS_BLOCK_STATE_FULL;
+		}
+
+		bi->blockState = state;
+
+		/* Now let's see if it was dirty */
+		if (bi->pagesInUse == 0 &&
+		    !bi->hasShrinkHeader &&
+		    bi->blockState == YAFFS_BLOCK_STATE_FULL) {
+			yaffs_BlockBecameDirty(dev, blk);
+		}
+
+	}
+
+
+	/* Ok, we've done all the scanning.
+	 * Fix up the hard link chains.
+	 * We should now have scanned all the objects, now it's time to add these
+	 * hardlinks.
+	 */
+
+	yaffs_HardlinkFixup(dev, hardList);
+
+	/* Fix up any shadowed objects */
+	{
+		struct yaffs_ShadowFixerStruct *fixer;
+		yaffs_Object *obj;
+
+		while (shadowFixerList) {
+			fixer = shadowFixerList;
+			shadowFixerList = fixer->next;
+			/* Complete the rename transaction by deleting the shadowed object
+			 * then setting the object header to unshadowed.
+			 */
+			obj = yaffs_FindObjectByNumber(dev, fixer->shadowedId);
+			if (obj)
+				yaffs_DeleteObject(obj);
+
+			obj = yaffs_FindObjectByNumber(dev, fixer->objectId);
+
+			if (obj)
+				yaffs_UpdateObjectHeader(obj, NULL, 1, 0, 0);
+
+			YFREE(fixer);
+		}
+	}
+
+	yaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);
+
+	if (alloc_failed)
+		return YAFFS_FAIL;
+
+	T(YAFFS_TRACE_SCAN, (TSTR("yaffs_Scan ends" TENDSTR)));
+
+
+	return YAFFS_OK;
+}
+
+static void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in)
+{
+	__u8 *chunkData;
+	yaffs_ObjectHeader *oh;
+	yaffs_Device *dev;
+	yaffs_ExtendedTags tags;
+	int result;
+	int alloc_failed = 0;
+
+	if (!in)
+		return;
+
+	dev = in->myDev;
+
+#if 0
+	T(YAFFS_TRACE_SCAN, (TSTR("details for object %d %s loaded" TENDSTR),
+		in->objectId,
+		in->lazyLoaded ? "not yet" : "already"));
+#endif
+
+	if (in->lazyLoaded && in->hdrChunk > 0) {
+		in->lazyLoaded = 0;
+		chunkData = yaffs_GetTempBuffer(dev, __LINE__);
+
+		result = yaffs_ReadChunkWithTagsFromNAND(dev, in->hdrChunk, chunkData, &tags);
+		oh = (yaffs_ObjectHeader *) chunkData;
+
+		in->yst_mode = oh->yst_mode;
+#ifdef CONFIG_YAFFS_WINCE
+		in->win_atime[0] = oh->win_atime[0];
+		in->win_ctime[0] = oh->win_ctime[0];
+		in->win_mtime[0] = oh->win_mtime[0];
+		in->win_atime[1] = oh->win_atime[1];
+		in->win_ctime[1] = oh->win_ctime[1];
+		in->win_mtime[1] = oh->win_mtime[1];
+#else
+		in->yst_uid = oh->yst_uid;
+		in->yst_gid = oh->yst_gid;
+		in->yst_atime = oh->yst_atime;
+		in->yst_mtime = oh->yst_mtime;
+		in->yst_ctime = oh->yst_ctime;
+		in->yst_rdev = oh->yst_rdev;
+
+#endif
+		yaffs_SetObjectName(in, oh->name);
+
+		if (in->variantType == YAFFS_OBJECT_TYPE_SYMLINK) {
+			in->variant.symLinkVariant.alias =
+						    yaffs_CloneString(oh->alias);
+			if (!in->variant.symLinkVariant.alias)
+				alloc_failed = 1; /* Not returned to caller */
+		}
+
+		yaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);
+	}
+}
+
+static int yaffs_ScanBackwards(yaffs_Device *dev)
+{
+	yaffs_ExtendedTags tags;
+	int blk;
+	int blockIterator;
+	int startIterator;
+	int endIterator;
+	int nBlocksToScan = 0;
+
+	int chunk;
+	int result;
+	int c;
+	int deleted;
+	yaffs_BlockState state;
+	yaffs_Object *hardList = NULL;
+	yaffs_BlockInfo *bi;
+	__u32 sequenceNumber;
+	yaffs_ObjectHeader *oh;
+	yaffs_Object *in;
+	yaffs_Object *parent;
+	int nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;
+	int itsUnlinked;
+	__u8 *chunkData;
+
+	int fileSize;
+	int isShrink;
+	int foundChunksInBlock;
+	int equivalentObjectId;
+	int alloc_failed = 0;
+
+
+	yaffs_BlockIndex *blockIndex = NULL;
+	int altBlockIndex = 0;
+
+	if (!dev->isYaffs2) {
+		T(YAFFS_TRACE_SCAN,
+		  (TSTR("yaffs_ScanBackwards is only for YAFFS2!" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	T(YAFFS_TRACE_SCAN,
+	  (TSTR
+	   ("yaffs_ScanBackwards starts  intstartblk %d intendblk %d..."
+	    TENDSTR), dev->internalStartBlock, dev->internalEndBlock));
+
+
+	dev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;
+
+	blockIndex = YMALLOC(nBlocks * sizeof(yaffs_BlockIndex));
+
+	if (!blockIndex) {
+		blockIndex = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockIndex));
+		altBlockIndex = 1;
+	}
+
+	if (!blockIndex) {
+		T(YAFFS_TRACE_SCAN,
+		  (TSTR("yaffs_Scan() could not allocate block index!" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	dev->blocksInCheckpoint = 0;
+
+	chunkData = yaffs_GetTempBuffer(dev, __LINE__);
+
+	/* Scan all the blocks to determine their state */
+	for (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {
+		bi = yaffs_GetBlockInfo(dev, blk);
+		yaffs_ClearChunkBits(dev, blk);
+		bi->pagesInUse = 0;
+		bi->softDeletions = 0;
+
+		yaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);
+
+		bi->blockState = state;
+		bi->sequenceNumber = sequenceNumber;
+
+		if (bi->sequenceNumber == YAFFS_SEQUENCE_CHECKPOINT_DATA)
+			bi->blockState = state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		if (bi->sequenceNumber == YAFFS_SEQUENCE_BAD_BLOCK)
+			bi->blockState = state = YAFFS_BLOCK_STATE_DEAD;
+
+		T(YAFFS_TRACE_SCAN_DEBUG,
+		  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,
+		   state, sequenceNumber));
+
+
+		if (state == YAFFS_BLOCK_STATE_CHECKPOINT) {
+			dev->blocksInCheckpoint++;
+
+		} else if (state == YAFFS_BLOCK_STATE_DEAD) {
+			T(YAFFS_TRACE_BAD_BLOCKS,
+			  (TSTR("block %d is bad" TENDSTR), blk));
+		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
+			T(YAFFS_TRACE_SCAN_DEBUG,
+			  (TSTR("Block empty " TENDSTR)));
+			dev->nErasedBlocks++;
+			dev->nFreeChunks += dev->nChunksPerBlock;
+		} else if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+
+			/* Determine the highest sequence number */
+			if (sequenceNumber >= YAFFS_LOWEST_SEQUENCE_NUMBER &&
+			    sequenceNumber < YAFFS_HIGHEST_SEQUENCE_NUMBER) {
+
+				blockIndex[nBlocksToScan].seq = sequenceNumber;
+				blockIndex[nBlocksToScan].block = blk;
+
+				nBlocksToScan++;
+
+				if (sequenceNumber >= dev->sequenceNumber)
+					dev->sequenceNumber = sequenceNumber;
+			} else {
+				/* TODO: Nasty sequence number! */
+				T(YAFFS_TRACE_SCAN,
+				  (TSTR
+				   ("Block scanning block %d has bad sequence number %d"
+				    TENDSTR), blk, sequenceNumber));
+
+			}
+		}
+	}
+
+	T(YAFFS_TRACE_SCAN,
+	(TSTR("%d blocks to be sorted..." TENDSTR), nBlocksToScan));
+
+
+
+	YYIELD();
+
+	/* Sort the blocks */
+#ifndef CONFIG_YAFFS_USE_OWN_SORT
+	{
+		/* Use qsort now. */
+		yaffs_qsort(blockIndex, nBlocksToScan, sizeof(yaffs_BlockIndex), ybicmp);
+	}
+#else
+	{
+		/* Dungy old bubble sort... */
+
+		yaffs_BlockIndex temp;
+		int i;
+		int j;
+
+		for (i = 0; i < nBlocksToScan; i++)
+			for (j = i + 1; j < nBlocksToScan; j++)
+				if (blockIndex[i].seq > blockIndex[j].seq) {
+					temp = blockIndex[j];
+					blockIndex[j] = blockIndex[i];
+					blockIndex[i] = temp;
+				}
+	}
+#endif
+
+	YYIELD();
+
+	T(YAFFS_TRACE_SCAN, (TSTR("...done" TENDSTR)));
+
+	/* Now scan the blocks looking at the data. */
+	startIterator = 0;
+	endIterator = nBlocksToScan - 1;
+	T(YAFFS_TRACE_SCAN_DEBUG,
+	  (TSTR("%d blocks to be scanned" TENDSTR), nBlocksToScan));
+
+	/* For each block.... backwards */
+	for (blockIterator = endIterator; !alloc_failed && blockIterator >= startIterator;
+			blockIterator--) {
+		/* Cooperative multitasking! This loop can run for so
+		   long that watchdog timers expire. */
+		YYIELD();
+
+		/* get the block to scan in the correct order */
+		blk = blockIndex[blockIterator].block;
+
+		bi = yaffs_GetBlockInfo(dev, blk);
+
+
+		state = bi->blockState;
+
+		deleted = 0;
+
+		/* For each chunk in each block that needs scanning.... */
+		foundChunksInBlock = 0;
+		for (c = dev->nChunksPerBlock - 1;
+		     !alloc_failed && c >= 0 &&
+		     (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
+		      state == YAFFS_BLOCK_STATE_ALLOCATING); c--) {
+			/* Scan backwards...
+			 * Read the tags and decide what to do
+			 */
+
+			chunk = blk * dev->nChunksPerBlock + c;
+
+			result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,
+							&tags);
+
+			/* Let's have a good look at this chunk... */
+
+			if (!tags.chunkUsed) {
+				/* An unassigned chunk in the block.
+				 * If there are used chunks after this one, then
+				 * it is a chunk that was skipped due to failing the erased
+				 * check. Just skip it so that it can be deleted.
+				 * But, more typically, We get here when this is an unallocated
+				 * chunk and his means that either the block is empty or
+				 * this is the one being allocated from
+				 */
+
+				if (foundChunksInBlock) {
+					/* This is a chunk that was skipped due to failing the erased check */
+				} else if (c == 0) {
+					/* We're looking at the first chunk in the block so the block is unused */
+					state = YAFFS_BLOCK_STATE_EMPTY;
+					dev->nErasedBlocks++;
+				} else {
+					if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
+					    state == YAFFS_BLOCK_STATE_ALLOCATING) {
+						if (dev->sequenceNumber == bi->sequenceNumber) {
+							/* this is the block being allocated from */
+
+							T(YAFFS_TRACE_SCAN,
+							  (TSTR
+							   (" Allocating from %d %d"
+							    TENDSTR), blk, c));
+
+							state = YAFFS_BLOCK_STATE_ALLOCATING;
+							dev->allocationBlock = blk;
+							dev->allocationPage = c;
+							dev->allocationBlockFinder = blk;
+						} else {
+							/* This is a partially written block that is not
+							 * the current allocation block. This block must have
+							 * had a write failure, so set up for retirement.
+							 */
+
+							 /* bi->needsRetiring = 1; ??? TODO */
+							 bi->gcPrioritise = 1;
+
+							 T(YAFFS_TRACE_ALWAYS,
+							 (TSTR("Partially written block %d detected" TENDSTR),
+							 blk));
+						}
+					}
+				}
+
+				dev->nFreeChunks++;
+
+			} else if (tags.eccResult == YAFFS_ECC_RESULT_UNFIXED) {
+				T(YAFFS_TRACE_SCAN,
+				  (TSTR(" Unfixed ECC in chunk(%d:%d), chunk ignored"TENDSTR),
+				  blk, c));
+
+				  dev->nFreeChunks++;
+
+			} else if (tags.chunkId > 0) {
+				/* chunkId > 0 so it is a data chunk... */
+				unsigned int endpos;
+				__u32 chunkBase =
+				    (tags.chunkId - 1) * dev->nDataBytesPerChunk;
+
+				foundChunksInBlock = 1;
+
+
+				yaffs_SetChunkBit(dev, blk, c);
+				bi->pagesInUse++;
+
+				in = yaffs_FindOrCreateObjectByNumber(dev,
+								      tags.
+								      objectId,
+								      YAFFS_OBJECT_TYPE_FILE);
+				if (!in) {
+					/* Out of memory */
+					alloc_failed = 1;
+				}
+
+				if (in &&
+				    in->variantType == YAFFS_OBJECT_TYPE_FILE
+				    && chunkBase <
+				    in->variant.fileVariant.shrinkSize) {
+					/* This has not been invalidated by a resize */
+					if (!yaffs_PutChunkIntoFile(in, tags.chunkId,
+							       chunk, -1)) {
+						alloc_failed = 1;
+					}
+
+					/* File size is calculated by looking at the data chunks if we have not
+					 * seen an object header yet. Stop this practice once we find an object header.
+					 */
+					endpos =
+					    (tags.chunkId -
+					     1) * dev->nDataBytesPerChunk +
+					    tags.byteCount;
+
+					if (!in->valid &&	/* have not got an object header yet */
+					    in->variant.fileVariant.
+					    scannedFileSize < endpos) {
+						in->variant.fileVariant.
+						    scannedFileSize = endpos;
+						in->variant.fileVariant.
+						    fileSize =
+						    in->variant.fileVariant.
+						    scannedFileSize;
+					}
+
+				} else if (in) {
+					/* This chunk has been invalidated by a resize, so delete */
+					yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
+
+				}
+			} else {
+				/* chunkId == 0, so it is an ObjectHeader.
+				 * Thus, we read in the object header and make the object
+				 */
+				foundChunksInBlock = 1;
+
+				yaffs_SetChunkBit(dev, blk, c);
+				bi->pagesInUse++;
+
+				oh = NULL;
+				in = NULL;
+
+				if (tags.extraHeaderInfoAvailable) {
+					in = yaffs_FindOrCreateObjectByNumber
+					    (dev, tags.objectId,
+					     tags.extraObjectType);
+					if (!in)
+						alloc_failed = 1;
+				}
+
+				if (!in ||
+#ifdef CONFIG_YAFFS_DISABLE_LAZY_LOAD
+				    !in->valid ||
+#endif
+				    tags.extraShadows ||
+				    (!in->valid &&
+				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
+				     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND))) {
+
+					/* If we don't have  valid info then we need to read the chunk
+					 * TODO In future we can probably defer reading the chunk and
+					 * living with invalid data until needed.
+					 */
+
+					result = yaffs_ReadChunkWithTagsFromNAND(dev,
+									chunk,
+									chunkData,
+									NULL);
+
+					oh = (yaffs_ObjectHeader *) chunkData;
+
+					if (dev->inbandTags) {
+						/* Fix up the header if they got corrupted by inband tags */
+						oh->shadowsObject = oh->inbandShadowsObject;
+						oh->isShrink = oh->inbandIsShrink;
+					}
+
+					if (!in) {
+						in = yaffs_FindOrCreateObjectByNumber(dev, tags.objectId, oh->type);
+						if (!in)
+							alloc_failed = 1;
+					}
+
+				}
+
+				if (!in) {
+					/* TODO Hoosterman we have a problem! */
+					T(YAFFS_TRACE_ERROR,
+					  (TSTR
+					   ("yaffs tragedy: Could not make object for object  %d at chunk %d during scan"
+					    TENDSTR), tags.objectId, chunk));
+					continue;
+				}
+
+				if (in->valid) {
+					/* We have already filled this one.
+					 * We have a duplicate that will be discarded, but
+					 * we first have to suck out resize info if it is a file.
+					 */
+
+					if ((in->variantType == YAFFS_OBJECT_TYPE_FILE) &&
+					     ((oh &&
+					       oh->type == YAFFS_OBJECT_TYPE_FILE) ||
+					      (tags.extraHeaderInfoAvailable  &&
+					       tags.extraObjectType == YAFFS_OBJECT_TYPE_FILE))) {
+						__u32 thisSize =
+						    (oh) ? oh->fileSize : tags.
+						    extraFileLength;
+						__u32 parentObjectId =
+						    (oh) ? oh->
+						    parentObjectId : tags.
+						    extraParentObjectId;
+
+
+						isShrink =
+						    (oh) ? oh->isShrink : tags.
+						    extraIsShrinkHeader;
+
+						/* If it is deleted (unlinked at start also means deleted)
+						 * we treat the file size as being zeroed at this point.
+						 */
+						if (parentObjectId ==
+						    YAFFS_OBJECTID_DELETED
+						    || parentObjectId ==
+						    YAFFS_OBJECTID_UNLINKED) {
+							thisSize = 0;
+							isShrink = 1;
+						}
+
+						if (isShrink &&
+						    in->variant.fileVariant.
+						    shrinkSize > thisSize) {
+							in->variant.fileVariant.
+							    shrinkSize =
+							    thisSize;
+						}
+
+						if (isShrink)
+							bi->hasShrinkHeader = 1;
+
+					}
+					/* Use existing - destroy this one. */
+					yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
+
+				}
+
+				if (!in->valid && in->variantType !=
+				    (oh ? oh->type : tags.extraObjectType))
+					T(YAFFS_TRACE_ERROR, (
+						TSTR("yaffs tragedy: Bad object type, "
+					    TCONT("%d != %d, for object %d at chunk ")
+					    TCONT("%d during scan")
+						TENDSTR), oh ?
+					    oh->type : tags.extraObjectType,
+					    in->variantType, tags.objectId,
+					    chunk));
+
+				if (!in->valid &&
+				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
+				     tags.objectId ==
+				     YAFFS_OBJECTID_LOSTNFOUND)) {
+					/* We only load some info, don't fiddle with directory structure */
+					in->valid = 1;
+
+					if (oh) {
+						in->variantType = oh->type;
+
+						in->yst_mode = oh->yst_mode;
+#ifdef CONFIG_YAFFS_WINCE
+						in->win_atime[0] = oh->win_atime[0];
+						in->win_ctime[0] = oh->win_ctime[0];
+						in->win_mtime[0] = oh->win_mtime[0];
+						in->win_atime[1] = oh->win_atime[1];
+						in->win_ctime[1] = oh->win_ctime[1];
+						in->win_mtime[1] = oh->win_mtime[1];
+#else
+						in->yst_uid = oh->yst_uid;
+						in->yst_gid = oh->yst_gid;
+						in->yst_atime = oh->yst_atime;
+						in->yst_mtime = oh->yst_mtime;
+						in->yst_ctime = oh->yst_ctime;
+						in->yst_rdev = oh->yst_rdev;
+
+#endif
+					} else {
+						in->variantType = tags.extraObjectType;
+						in->lazyLoaded = 1;
+					}
+
+					in->hdrChunk = chunk;
+
+				} else if (!in->valid) {
+					/* we need to load this info */
+
+					in->valid = 1;
+					in->hdrChunk = chunk;
+
+					if (oh) {
+						in->variantType = oh->type;
+
+						in->yst_mode = oh->yst_mode;
+#ifdef CONFIG_YAFFS_WINCE
+						in->win_atime[0] = oh->win_atime[0];
+						in->win_ctime[0] = oh->win_ctime[0];
+						in->win_mtime[0] = oh->win_mtime[0];
+						in->win_atime[1] = oh->win_atime[1];
+						in->win_ctime[1] = oh->win_ctime[1];
+						in->win_mtime[1] = oh->win_mtime[1];
+#else
+						in->yst_uid = oh->yst_uid;
+						in->yst_gid = oh->yst_gid;
+						in->yst_atime = oh->yst_atime;
+						in->yst_mtime = oh->yst_mtime;
+						in->yst_ctime = oh->yst_ctime;
+						in->yst_rdev = oh->yst_rdev;
+#endif
+
+						if (oh->shadowsObject > 0)
+							yaffs_HandleShadowedObject(dev,
+									   oh->
+									   shadowsObject,
+									   1);
+
+
+						yaffs_SetObjectName(in, oh->name);
+						parent =
+						    yaffs_FindOrCreateObjectByNumber
+							(dev, oh->parentObjectId,
+							 YAFFS_OBJECT_TYPE_DIRECTORY);
+
+						 fileSize = oh->fileSize;
+						 isShrink = oh->isShrink;
+						 equivalentObjectId = oh->equivalentObjectId;
+
+					} else {
+						in->variantType = tags.extraObjectType;
+						parent =
+						    yaffs_FindOrCreateObjectByNumber
+							(dev, tags.extraParentObjectId,
+							 YAFFS_OBJECT_TYPE_DIRECTORY);
+						 fileSize = tags.extraFileLength;
+						 isShrink = tags.extraIsShrinkHeader;
+						 equivalentObjectId = tags.extraEquivalentObjectId;
+						in->lazyLoaded = 1;
+
+					}
+					in->dirty = 0;
+
+					if (!parent)
+						alloc_failed = 1;
+
+					/* directory stuff...
+					 * hook up to parent
+					 */
+
+					if (parent && parent->variantType ==
+					    YAFFS_OBJECT_TYPE_UNKNOWN) {
+						/* Set up as a directory */
+						parent->variantType =
+							YAFFS_OBJECT_TYPE_DIRECTORY;
+						YINIT_LIST_HEAD(&parent->variant.
+							directoryVariant.
+							children);
+					} else if (!parent || parent->variantType !=
+						   YAFFS_OBJECT_TYPE_DIRECTORY) {
+						/* Hoosterman, another problem....
+						 * We're trying to use a non-directory as a directory
+						 */
+
+						T(YAFFS_TRACE_ERROR,
+						  (TSTR
+						   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+						    TENDSTR)));
+						parent = dev->lostNFoundDir;
+					}
+
+					yaffs_AddObjectToDirectory(parent, in);
+
+					itsUnlinked = (parent == dev->deletedDir) ||
+						      (parent == dev->unlinkedDir);
+
+					if (isShrink) {
+						/* Mark the block as having a shrinkHeader */
+						bi->hasShrinkHeader = 1;
+					}
+
+					/* Note re hardlinks.
+					 * Since we might scan a hardlink before its equivalent object is scanned
+					 * we put them all in a list.
+					 * After scanning is complete, we should have all the objects, so we run
+					 * through this list and fix up all the chains.
+					 */
+
+					switch (in->variantType) {
+					case YAFFS_OBJECT_TYPE_UNKNOWN:
+						/* Todo got a problem */
+						break;
+					case YAFFS_OBJECT_TYPE_FILE:
+
+						if (in->variant.fileVariant.
+						    scannedFileSize < fileSize) {
+							/* This covers the case where the file size is greater
+							 * than where the data is
+							 * This will happen if the file is resized to be larger
+							 * than its current data extents.
+							 */
+							in->variant.fileVariant.fileSize = fileSize;
+							in->variant.fileVariant.scannedFileSize =
+							    in->variant.fileVariant.fileSize;
+						}
+
+						if (isShrink &&
+						    in->variant.fileVariant.shrinkSize > fileSize) {
+							in->variant.fileVariant.shrinkSize = fileSize;
+						}
+
+						break;
+					case YAFFS_OBJECT_TYPE_HARDLINK:
+						if (!itsUnlinked) {
+							in->variant.hardLinkVariant.equivalentObjectId =
+								equivalentObjectId;
+							in->hardLinks.next =
+								(struct ylist_head *) hardList;
+							hardList = in;
+						}
+						break;
+					case YAFFS_OBJECT_TYPE_DIRECTORY:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SPECIAL:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SYMLINK:
+						if (oh) {
+							in->variant.symLinkVariant.alias =
+								yaffs_CloneString(oh->alias);
+							if (!in->variant.symLinkVariant.alias)
+								alloc_failed = 1;
+						}
+						break;
+					}
+
+				}
+
+			}
+
+		} /* End of scanning for each chunk */
+
+		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+			/* If we got this far while scanning, then the block is fully allocated. */
+			state = YAFFS_BLOCK_STATE_FULL;
+		}
+
+		bi->blockState = state;
+
+		/* Now let's see if it was dirty */
+		if (bi->pagesInUse == 0 &&
+		    !bi->hasShrinkHeader &&
+		    bi->blockState == YAFFS_BLOCK_STATE_FULL) {
+			yaffs_BlockBecameDirty(dev, blk);
+		}
+
+	}
+
+	if (altBlockIndex)
+		YFREE_ALT(blockIndex);
+	else
+		YFREE(blockIndex);
+
+	/* Ok, we've done all the scanning.
+	 * Fix up the hard link chains.
+	 * We should now have scanned all the objects, now it's time to add these
+	 * hardlinks.
+	 */
+	yaffs_HardlinkFixup(dev, hardList);
+
+
+	yaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);
+
+	if (alloc_failed)
+		return YAFFS_FAIL;
+
+	T(YAFFS_TRACE_SCAN, (TSTR("yaffs_ScanBackwards ends" TENDSTR)));
+
+	return YAFFS_OK;
+}
+
+/*------------------------------  Directory Functions ----------------------------- */
+
+static void yaffs_VerifyObjectInDirectory(yaffs_Object *obj)
+{
+	struct ylist_head *lh;
+	yaffs_Object *listObj;
+
+	int count = 0;
+
+	if (!obj) {
+		T(YAFFS_TRACE_ALWAYS, (TSTR("No object to verify" TENDSTR)));
+		YBUG();
+		return;
+	}
+
+	if (yaffs_SkipVerification(obj->myDev))
+		return;
+
+	if (!obj->parent) {
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Object does not have parent" TENDSTR)));
+		YBUG();
+		return;
+	}
+
+	if (obj->parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Parent is not directory" TENDSTR)));
+		YBUG();
+	}
+
+	/* Iterate through the objects in each hash entry */
+
+	ylist_for_each(lh, &obj->parent->variant.directoryVariant.children) {
+		if (lh) {
+			listObj = ylist_entry(lh, yaffs_Object, siblings);
+			yaffs_VerifyObject(listObj);
+			if (obj == listObj)
+				count++;
+		}
+	 }
+
+	if (count != 1) {
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory %d times" TENDSTR), count));
+		YBUG();
+	}
+}
+
+static void yaffs_VerifyDirectory(yaffs_Object *directory)
+{
+	struct ylist_head *lh;
+	yaffs_Object *listObj;
+
+	if (!directory) {
+		YBUG();
+		return;
+	}
+
+	if (yaffs_SkipFullVerification(directory->myDev))
+		return;
+
+	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Directory has wrong type: %d" TENDSTR), directory->variantType));
+		YBUG();
+	}
+
+	/* Iterate through the objects in each hash entry */
+
+	ylist_for_each(lh, &directory->variant.directoryVariant.children) {
+		if (lh) {
+			listObj = ylist_entry(lh, yaffs_Object, siblings);
+			if (listObj->parent != directory) {
+				T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory list has wrong parent %p" TENDSTR), listObj->parent));
+				YBUG();
+			}
+			yaffs_VerifyObjectInDirectory(listObj);
+		}
+	}
+}
+
+/*
+ *yaffs_UpdateParent() handles fixing a directories mtime and ctime when a new
+ * link (ie. name) is created or deleted in the directory.
+ *
+ * ie.
+ *   create dir/a : update dir's mtime/ctime
+ *   rm dir/a:   update dir's mtime/ctime
+ *   modify dir/a: don't update dir's mtimme/ctime
+ */
+ 
+static void yaffs_UpdateParent(yaffs_Object *obj)
+{
+	if(!obj)
+		return;
+
+	obj->dirty = 1;
+	obj->yst_mtime = obj->yst_ctime = Y_CURRENT_TIME;
+
+	yaffs_UpdateObjectHeader(obj,NULL,0,0,0);
+}
+
+static void yaffs_RemoveObjectFromDirectory(yaffs_Object *obj)
+{
+	yaffs_Device *dev = obj->myDev;
+	yaffs_Object *parent;
+
+	yaffs_VerifyObjectInDirectory(obj);
+	parent = obj->parent;
+
+	yaffs_VerifyDirectory(parent);
+
+	if (dev && dev->removeObjectCallback)
+		dev->removeObjectCallback(obj);
+
+
+	ylist_del_init(&obj->siblings);
+	obj->parent = NULL;
+	
+	yaffs_VerifyDirectory(parent);
+}
+
+static void yaffs_AddObjectToDirectory(yaffs_Object *directory,
+					yaffs_Object *obj)
+{
+	if (!directory) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: Trying to add an object to a null pointer directory"
+		    TENDSTR)));
+		YBUG();
+		return;
+	}
+	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: Trying to add an object to a non-directory"
+		    TENDSTR)));
+		YBUG();
+	}
+
+	if (obj->siblings.prev == NULL) {
+		/* Not initialised */
+		YBUG();
+	}
+
+
+	yaffs_VerifyDirectory(directory);
+
+	yaffs_RemoveObjectFromDirectory(obj);
+
+
+	/* Now add it */
+	ylist_add(&obj->siblings, &directory->variant.directoryVariant.children);
+	obj->parent = directory;
+
+	if (directory == obj->myDev->unlinkedDir
+			|| directory == obj->myDev->deletedDir) {
+		obj->unlinked = 1;
+		obj->myDev->nUnlinkedFiles++;
+		obj->renameAllowed = 0;
+	}
+
+	yaffs_VerifyDirectory(directory);
+	yaffs_VerifyObjectInDirectory(obj);
+}
+
+yaffs_Object *yaffs_FindObjectByName(yaffs_Object *directory,
+				     const YCHAR *name)
+{
+	int sum;
+
+	struct ylist_head *i;
+	YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];
+
+	yaffs_Object *l;
+
+	if (!name)
+		return NULL;
+
+	if (!directory) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_FindObjectByName: null pointer directory"
+		    TENDSTR)));
+		YBUG();
+		return NULL;
+	}
+	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_FindObjectByName: non-directory" TENDSTR)));
+		YBUG();
+	}
+
+	sum = yaffs_CalcNameSum(name);
+
+	ylist_for_each(i, &directory->variant.directoryVariant.children) {
+		if (i) {
+			l = ylist_entry(i, yaffs_Object, siblings);
+
+			if (l->parent != directory)
+				YBUG();
+
+			yaffs_CheckObjectDetailsLoaded(l);
+
+			/* Special case for lost-n-found */
+			if (l->objectId == YAFFS_OBJECTID_LOSTNFOUND) {
+				if (yaffs_strcmp(name, YAFFS_LOSTNFOUND_NAME) == 0)
+					return l;
+			} else if (yaffs_SumCompare(l->sum, sum) || l->hdrChunk <= 0) {
+				/* LostnFound chunk called Objxxx
+				 * Do a real check
+				 */
+				yaffs_GetObjectName(l, buffer,
+						    YAFFS_MAX_NAME_LENGTH + 1);
+				if (yaffs_strncmp(name, buffer, YAFFS_MAX_NAME_LENGTH) == 0)
+					return l;
+			}
+		}
+	}
+
+	return NULL;
+}
+
+
+#if 0
+int yaffs_ApplyToDirectoryChildren(yaffs_Object *theDir,
+					int (*fn) (yaffs_Object *))
+{
+	struct ylist_head *i;
+	yaffs_Object *l;
+
+	if (!theDir) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_FindObjectByName: null pointer directory"
+		    TENDSTR)));
+		YBUG();
+		return YAFFS_FAIL;
+	}
+	if (theDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_FindObjectByName: non-directory" TENDSTR)));
+		YBUG();
+		return YAFFS_FAIL;
+	}
+
+	ylist_for_each(i, &theDir->variant.directoryVariant.children) {
+		if (i) {
+			l = ylist_entry(i, yaffs_Object, siblings);
+			if (l && !fn(l))
+				return YAFFS_FAIL;
+		}
+	}
+
+	return YAFFS_OK;
+
+}
+#endif
+
+/* GetEquivalentObject dereferences any hard links to get to the
+ * actual object.
+ */
+
+yaffs_Object *yaffs_GetEquivalentObject(yaffs_Object *obj)
+{
+	if (obj && obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
+		/* We want the object id of the equivalent object, not this one */
+		obj = obj->variant.hardLinkVariant.equivalentObject;
+		yaffs_CheckObjectDetailsLoaded(obj);
+	}
+	return obj;
+}
+
+int yaffs_GetObjectName(yaffs_Object *obj, YCHAR *name, int buffSize)
+{
+	memset(name, 0, buffSize * sizeof(YCHAR));
+
+	yaffs_CheckObjectDetailsLoaded(obj);
+
+	if (obj->objectId == YAFFS_OBJECTID_LOSTNFOUND) {
+		yaffs_strncpy(name, YAFFS_LOSTNFOUND_NAME, buffSize - 1);
+	} else if (obj->hdrChunk <= 0) {
+		YCHAR locName[20];
+		YCHAR numString[20];
+		YCHAR *x = &numString[19];
+		unsigned v = obj->objectId;
+		numString[19] = 0;
+		while (v > 0) {
+			x--;
+			*x = '0' + (v % 10);
+			v /= 10;
+		}
+		/* make up a name */
+		yaffs_strcpy(locName, YAFFS_LOSTNFOUND_PREFIX);
+		yaffs_strcat(locName, x);
+		yaffs_strncpy(name, locName, buffSize - 1);
+
+	}
+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+	else if (obj->shortName[0])
+		yaffs_strcpy(name, obj->shortName);
+#endif
+	else {
+		int result;
+		__u8 *buffer = yaffs_GetTempBuffer(obj->myDev, __LINE__);
+
+		yaffs_ObjectHeader *oh = (yaffs_ObjectHeader *) buffer;
+
+		memset(buffer, 0, obj->myDev->nDataBytesPerChunk);
+
+		if (obj->hdrChunk > 0) {
+			result = yaffs_ReadChunkWithTagsFromNAND(obj->myDev,
+							obj->hdrChunk, buffer,
+							NULL);
+		}
+		yaffs_strncpy(name, oh->name, buffSize - 1);
+
+		yaffs_ReleaseTempBuffer(obj->myDev, buffer, __LINE__);
+	}
+
+	return yaffs_strlen(name);
+}
+
+int yaffs_GetObjectFileLength(yaffs_Object *obj)
+{
+	/* Dereference any hard linking */
+	obj = yaffs_GetEquivalentObject(obj);
+
+	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE)
+		return obj->variant.fileVariant.fileSize;
+	if (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK)
+		return yaffs_strlen(obj->variant.symLinkVariant.alias);
+	else {
+		/* Only a directory should drop through to here */
+		return obj->myDev->nDataBytesPerChunk;
+	}
+}
+
+int yaffs_GetObjectLinkCount(yaffs_Object *obj)
+{
+	int count = 0;
+	struct ylist_head *i;
+
+	if (!obj->unlinked)
+		count++;		/* the object itself */
+
+	ylist_for_each(i, &obj->hardLinks)
+		count++;		/* add the hard links; */
+
+	return count;
+}
+
+int yaffs_GetObjectInode(yaffs_Object *obj)
+{
+	obj = yaffs_GetEquivalentObject(obj);
+
+	return obj->objectId;
+}
+
+unsigned yaffs_GetObjectType(yaffs_Object *obj)
+{
+	obj = yaffs_GetEquivalentObject(obj);
+
+	switch (obj->variantType) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		return DT_REG;
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		return DT_DIR;
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		return DT_LNK;
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		return DT_REG;
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		if (S_ISFIFO(obj->yst_mode))
+			return DT_FIFO;
+		if (S_ISCHR(obj->yst_mode))
+			return DT_CHR;
+		if (S_ISBLK(obj->yst_mode))
+			return DT_BLK;
+		if (S_ISSOCK(obj->yst_mode))
+			return DT_SOCK;
+	default:
+		return DT_REG;
+		break;
+	}
+}
+
+YCHAR *yaffs_GetSymlinkAlias(yaffs_Object *obj)
+{
+	obj = yaffs_GetEquivalentObject(obj);
+	if (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK)
+		return yaffs_CloneString(obj->variant.symLinkVariant.alias);
+	else
+		return yaffs_CloneString(_Y(""));
+}
+
+#ifndef CONFIG_YAFFS_WINCE
+
+int yaffs_SetAttributes(yaffs_Object *obj, struct iattr *attr)
+{
+	unsigned int valid = attr->ia_valid;
+
+	if (valid & ATTR_MODE)
+		obj->yst_mode = attr->ia_mode;
+	if (valid & ATTR_UID)
+		obj->yst_uid = attr->ia_uid;
+	if (valid & ATTR_GID)
+		obj->yst_gid = attr->ia_gid;
+
+	if (valid & ATTR_ATIME)
+		obj->yst_atime = Y_TIME_CONVERT(attr->ia_atime);
+	if (valid & ATTR_CTIME)
+		obj->yst_ctime = Y_TIME_CONVERT(attr->ia_ctime);
+	if (valid & ATTR_MTIME)
+		obj->yst_mtime = Y_TIME_CONVERT(attr->ia_mtime);
+
+	if (valid & ATTR_SIZE)
+		yaffs_ResizeFile(obj, attr->ia_size);
+
+	yaffs_UpdateObjectHeader(obj, NULL, 1, 0, 0);
+
+	return YAFFS_OK;
+
+}
+int yaffs_GetAttributes(yaffs_Object *obj, struct iattr *attr)
+{
+	unsigned int valid = 0;
+
+	attr->ia_mode = obj->yst_mode;
+	valid |= ATTR_MODE;
+	attr->ia_uid = obj->yst_uid;
+	valid |= ATTR_UID;
+	attr->ia_gid = obj->yst_gid;
+	valid |= ATTR_GID;
+
+	Y_TIME_CONVERT(attr->ia_atime) = obj->yst_atime;
+	valid |= ATTR_ATIME;
+	Y_TIME_CONVERT(attr->ia_ctime) = obj->yst_ctime;
+	valid |= ATTR_CTIME;
+	Y_TIME_CONVERT(attr->ia_mtime) = obj->yst_mtime;
+	valid |= ATTR_MTIME;
+
+	attr->ia_size = yaffs_GetFileSize(obj);
+	valid |= ATTR_SIZE;
+
+	attr->ia_valid = valid;
+
+	return YAFFS_OK;
+}
+
+#endif
+
+#if 0
+int yaffs_DumpObject(yaffs_Object *obj)
+{
+	YCHAR name[257];
+
+	yaffs_GetObjectName(obj, name, YAFFS_MAX_NAME_LENGTH + 1);
+
+	T(YAFFS_TRACE_ALWAYS,
+	  (TSTR
+	   ("Object %d, inode %d \"%s\"\n dirty %d valid %d serial %d sum %d"
+	    " chunk %d type %d size %d\n"
+	    TENDSTR), obj->objectId, yaffs_GetObjectInode(obj), name,
+	   obj->dirty, obj->valid, obj->serial, obj->sum, obj->hdrChunk,
+	   yaffs_GetObjectType(obj), yaffs_GetObjectFileLength(obj)));
+
+	return YAFFS_OK;
+}
+#endif
+
+/*---------------------------- Initialisation code -------------------------------------- */
+
+static int yaffs_CheckDevFunctions(const yaffs_Device *dev)
+{
+
+	/* Common functions, gotta have */
+	if (!dev->eraseBlockInNAND || !dev->initialiseNAND)
+		return 0;
+
+#ifdef CONFIG_YAFFS_YAFFS2
+
+	/* Can use the "with tags" style interface for yaffs1 or yaffs2 */
+	if (dev->writeChunkWithTagsToNAND &&
+	    dev->readChunkWithTagsFromNAND &&
+	    !dev->writeChunkToNAND &&
+	    !dev->readChunkFromNAND &&
+	    dev->markNANDBlockBad && dev->queryNANDBlock)
+		return 1;
+#endif
+
+	/* Can use the "spare" style interface for yaffs1 */
+	if (!dev->isYaffs2 &&
+	    !dev->writeChunkWithTagsToNAND &&
+	    !dev->readChunkWithTagsFromNAND &&
+	    dev->writeChunkToNAND &&
+	    dev->readChunkFromNAND &&
+	    !dev->markNANDBlockBad && !dev->queryNANDBlock)
+		return 1;
+
+	return 0;		/* bad */
+}
+
+
+static int yaffs_CreateInitialDirectories(yaffs_Device *dev)
+{
+	/* Initialise the unlinked, deleted, root and lost and found directories */
+
+	dev->lostNFoundDir = dev->rootDir =  NULL;
+	dev->unlinkedDir = dev->deletedDir = NULL;
+
+	dev->unlinkedDir =
+	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);
+
+	dev->deletedDir =
+	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);
+
+	dev->rootDir =
+	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_ROOT,
+				      YAFFS_ROOT_MODE | S_IFDIR);
+	dev->lostNFoundDir =
+	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_LOSTNFOUND,
+				      YAFFS_LOSTNFOUND_MODE | S_IFDIR);
+
+	if (dev->lostNFoundDir && dev->rootDir && dev->unlinkedDir && dev->deletedDir) {
+		yaffs_AddObjectToDirectory(dev->rootDir, dev->lostNFoundDir);
+		return YAFFS_OK;
+	}
+
+	return YAFFS_FAIL;
+}
+
+int yaffs_GutsInitialise(yaffs_Device *dev)
+{
+	int init_failed = 0;
+	unsigned x;
+	int bits;
+
+	T(YAFFS_TRACE_TRACING, (TSTR("yaffs: yaffs_GutsInitialise()" TENDSTR)));
+
+	/* Check stuff that must be set */
+
+	if (!dev) {
+		T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Need a device" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	dev->internalStartBlock = dev->startBlock;
+	dev->internalEndBlock = dev->endBlock;
+	dev->blockOffset = 0;
+	dev->chunkOffset = 0;
+	dev->nFreeChunks = 0;
+
+	dev->gcBlock = -1;
+
+	if (dev->startBlock == 0) {
+		dev->internalStartBlock = dev->startBlock + 1;
+		dev->internalEndBlock = dev->endBlock + 1;
+		dev->blockOffset = 1;
+		dev->chunkOffset = dev->nChunksPerBlock;
+	}
+
+	/* Check geometry parameters. */
+
+	if ((!dev->inbandTags && dev->isYaffs2 && dev->totalBytesPerChunk < 1024) ||
+	    (!dev->isYaffs2 && dev->totalBytesPerChunk < 512) ||
+	    (dev->inbandTags && !dev->isYaffs2) ||
+	     dev->nChunksPerBlock < 2 ||
+	     dev->nReservedBlocks < 2 ||
+	     dev->internalStartBlock <= 0 ||
+	     dev->internalEndBlock <= 0 ||
+	     dev->internalEndBlock <= (dev->internalStartBlock + dev->nReservedBlocks + 2)) {	/* otherwise it is too small */
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("yaffs: NAND geometry problems: chunk size %d, type is yaffs%s, inbandTags %d "
+		    TENDSTR), dev->totalBytesPerChunk, dev->isYaffs2 ? "2" : "", dev->inbandTags));
+		return YAFFS_FAIL;
+	}
+
+	if (yaffs_InitialiseNAND(dev) != YAFFS_OK) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("yaffs: InitialiseNAND failed" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	/* Sort out space for inband tags, if required */
+	if (dev->inbandTags)
+		dev->nDataBytesPerChunk = dev->totalBytesPerChunk - sizeof(yaffs_PackedTags2TagsPart);
+	else
+		dev->nDataBytesPerChunk = dev->totalBytesPerChunk;
+
+	/* Got the right mix of functions? */
+	if (!yaffs_CheckDevFunctions(dev)) {
+		/* Function missing */
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("yaffs: device function(s) missing or wrong\n" TENDSTR)));
+
+		return YAFFS_FAIL;
+	}
+
+	/* This is really a compilation check. */
+	if (!yaffs_CheckStructures()) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("yaffs_CheckStructures failed\n" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	if (dev->isMounted) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("yaffs: device already mounted\n" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	/* Finished with most checks. One or two more checks happen later on too. */
+
+	dev->isMounted = 1;
+
+	/* OK now calculate a few things for the device */
+
+	/*
+	 *  Calculate all the chunk size manipulation numbers:
+	 */
+	x = dev->nDataBytesPerChunk;
+	/* We always use dev->chunkShift and dev->chunkDiv */
+	dev->chunkShift = Shifts(x);
+	x >>= dev->chunkShift;
+	dev->chunkDiv = x;
+	/* We only use chunk mask if chunkDiv is 1 */
+	dev->chunkMask = (1<<dev->chunkShift) - 1;
+
+	/*
+	 * Calculate chunkGroupBits.
+	 * We need to find the next power of 2 > than internalEndBlock
+	 */
+
+	x = dev->nChunksPerBlock * (dev->internalEndBlock + 1);
+
+	bits = ShiftsGE(x);
+
+	/* Set up tnode width if wide tnodes are enabled. */
+	if (!dev->wideTnodesDisabled) {
+		/* bits must be even so that we end up with 32-bit words */
+		if (bits & 1)
+			bits++;
+		if (bits < 16)
+			dev->tnodeWidth = 16;
+		else
+			dev->tnodeWidth = bits;
+	} else
+		dev->tnodeWidth = 16;
+
+	dev->tnodeMask = (1<<dev->tnodeWidth)-1;
+
+	/* Level0 Tnodes are 16 bits or wider (if wide tnodes are enabled),
+	 * so if the bitwidth of the
+	 * chunk range we're using is greater than 16 we need
+	 * to figure out chunk shift and chunkGroupSize
+	 */
+
+	if (bits <= dev->tnodeWidth)
+		dev->chunkGroupBits = 0;
+	else
+		dev->chunkGroupBits = bits - dev->tnodeWidth;
+
+
+	dev->chunkGroupSize = 1 << dev->chunkGroupBits;
+
+	if (dev->nChunksPerBlock < dev->chunkGroupSize) {
+		/* We have a problem because the soft delete won't work if
+		 * the chunk group size > chunks per block.
+		 * This can be remedied by using larger "virtual blocks".
+		 */
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("yaffs: chunk group too large\n" TENDSTR)));
+
+		return YAFFS_FAIL;
+	}
+
+	/* OK, we've finished verifying the device, lets continue with initialisation */
+
+	/* More device initialisation */
+	dev->garbageCollections = 0;
+	dev->passiveGarbageCollections = 0;
+	dev->currentDirtyChecker = 0;
+	dev->bufferedBlock = -1;
+	dev->doingBufferedBlockRewrite = 0;
+	dev->nDeletedFiles = 0;
+	dev->nBackgroundDeletions = 0;
+	dev->nUnlinkedFiles = 0;
+	dev->eccFixed = 0;
+	dev->eccUnfixed = 0;
+	dev->tagsEccFixed = 0;
+	dev->tagsEccUnfixed = 0;
+	dev->nErasureFailures = 0;
+	dev->nErasedBlocks = 0;
+	dev->isDoingGC = 0;
+	dev->hasPendingPrioritisedGCs = 1; /* Assume the worst for now, will get fixed on first GC */
+
+	/* Initialise temporary buffers and caches. */
+	if (!yaffs_InitialiseTempBuffers(dev))
+		init_failed = 1;
+
+	dev->srCache = NULL;
+	dev->gcCleanupList = NULL;
+
+
+	if (!init_failed &&
+	    dev->nShortOpCaches > 0) {
+		int i;
+		void *buf;
+		int srCacheBytes = dev->nShortOpCaches * sizeof(yaffs_ChunkCache);
+
+		if (dev->nShortOpCaches > YAFFS_MAX_SHORT_OP_CACHES)
+			dev->nShortOpCaches = YAFFS_MAX_SHORT_OP_CACHES;
+
+		dev->srCache =  YMALLOC(srCacheBytes);
+
+		buf = (__u8 *) dev->srCache;
+
+		if (dev->srCache)
+			memset(dev->srCache, 0, srCacheBytes);
+
+		for (i = 0; i < dev->nShortOpCaches && buf; i++) {
+			dev->srCache[i].object = NULL;
+			dev->srCache[i].lastUse = 0;
+			dev->srCache[i].dirty = 0;
+			dev->srCache[i].data = buf = YMALLOC_DMA(dev->totalBytesPerChunk);
+		}
+		if (!buf)
+			init_failed = 1;
+
+		dev->srLastUse = 0;
+	}
+
+	dev->cacheHits = 0;
+
+	if (!init_failed) {
+		dev->gcCleanupList = YMALLOC(dev->nChunksPerBlock * sizeof(__u32));
+		if (!dev->gcCleanupList)
+			init_failed = 1;
+	}
+
+	if (dev->isYaffs2)
+		dev->useHeaderFileSize = 1;
+
+	if (!init_failed && !yaffs_InitialiseBlocks(dev))
+		init_failed = 1;
+
+	yaffs_InitialiseTnodes(dev);
+	yaffs_InitialiseObjects(dev);
+
+	if (!init_failed && !yaffs_CreateInitialDirectories(dev))
+		init_failed = 1;
+
+
+	if (!init_failed) {
+		/* Now scan the flash. */
+		if (dev->isYaffs2) {
+			if (yaffs_CheckpointRestore(dev)) {
+				yaffs_CheckObjectDetailsLoaded(dev->rootDir);
+				T(YAFFS_TRACE_ALWAYS,
+				  (TSTR("yaffs: restored from checkpoint" TENDSTR)));
+			} else {
+
+				/* Clean up the mess caused by an aborted checkpoint load
+				 * and scan backwards.
+				 */
+				yaffs_DeinitialiseBlocks(dev);
+				yaffs_DeinitialiseTnodes(dev);
+				yaffs_DeinitialiseObjects(dev);
+
+
+				dev->nErasedBlocks = 0;
+				dev->nFreeChunks = 0;
+				dev->allocationBlock = -1;
+				dev->allocationPage = -1;
+				dev->nDeletedFiles = 0;
+				dev->nUnlinkedFiles = 0;
+				dev->nBackgroundDeletions = 0;
+				dev->oldestDirtySequence = 0;
+
+				if (!init_failed && !yaffs_InitialiseBlocks(dev))
+					init_failed = 1;
+
+				yaffs_InitialiseTnodes(dev);
+				yaffs_InitialiseObjects(dev);
+
+				if (!init_failed && !yaffs_CreateInitialDirectories(dev))
+					init_failed = 1;
+
+				if (!init_failed && !yaffs_ScanBackwards(dev))
+					init_failed = 1;
+			}
+		} else if (!yaffs_Scan(dev))
+				init_failed = 1;
+
+		yaffs_StripDeletedObjects(dev);
+		yaffs_FixHangingObjects(dev);
+		if(dev->emptyLostAndFound)
+			yaffs_EmptyLostAndFound(dev);
+	}
+
+	if (init_failed) {
+		/* Clean up the mess */
+		T(YAFFS_TRACE_TRACING,
+		  (TSTR("yaffs: yaffs_GutsInitialise() aborted.\n" TENDSTR)));
+
+		yaffs_Deinitialise(dev);
+		return YAFFS_FAIL;
+	}
+
+	/* Zero out stats */
+	dev->nPageReads = 0;
+	dev->nPageWrites = 0;
+	dev->nBlockErasures = 0;
+	dev->nGCCopies = 0;
+	dev->nRetriedWrites = 0;
+
+	dev->nRetiredBlocks = 0;
+
+	yaffs_VerifyFreeChunks(dev);
+	yaffs_VerifyBlocks(dev);
+
+	/* Clean up any aborted checkpoint data */
+	if (!dev->isCheckpointed && dev->blocksInCheckpoint > 0)
+		yaffs_InvalidateCheckpoint(dev);
+
+	T(YAFFS_TRACE_TRACING,
+	  (TSTR("yaffs: yaffs_GutsInitialise() done.\n" TENDSTR)));
+	return YAFFS_OK;
+
+}
+
+void yaffs_Deinitialise(yaffs_Device *dev)
+{
+	if (dev->isMounted) {
+		int i;
+
+		yaffs_DeinitialiseBlocks(dev);
+		yaffs_DeinitialiseTnodes(dev);
+		yaffs_DeinitialiseObjects(dev);
+		if (dev->nShortOpCaches > 0 &&
+		    dev->srCache) {
+
+			for (i = 0; i < dev->nShortOpCaches; i++) {
+				if (dev->srCache[i].data)
+					YFREE(dev->srCache[i].data);
+				dev->srCache[i].data = NULL;
+			}
+
+			YFREE(dev->srCache);
+			dev->srCache = NULL;
+		}
+
+		YFREE(dev->gcCleanupList);
+
+		for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++)
+			YFREE(dev->tempBuffer[i].buffer);
+
+		dev->isMounted = 0;
+
+		if (dev->deinitialiseNAND)
+			dev->deinitialiseNAND(dev);
+	}
+}
+
+static int yaffs_CountFreeChunks(yaffs_Device *dev)
+{
+	int nFree;
+	int b;
+
+	yaffs_BlockInfo *blk;
+
+	for (nFree = 0, b = dev->internalStartBlock; b <= dev->internalEndBlock;
+			b++) {
+		blk = yaffs_GetBlockInfo(dev, b);
+
+		switch (blk->blockState) {
+		case YAFFS_BLOCK_STATE_EMPTY:
+		case YAFFS_BLOCK_STATE_ALLOCATING:
+		case YAFFS_BLOCK_STATE_COLLECTING:
+		case YAFFS_BLOCK_STATE_FULL:
+			nFree +=
+			    (dev->nChunksPerBlock - blk->pagesInUse +
+			     blk->softDeletions);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return nFree;
+}
+
+int yaffs_GetNumberOfFreeChunks(yaffs_Device *dev)
+{
+	/* This is what we report to the outside world */
+
+	int nFree;
+	int nDirtyCacheChunks;
+	int blocksForCheckpoint;
+	int i;
+
+#if 1
+	nFree = dev->nFreeChunks;
+#else
+	nFree = yaffs_CountFreeChunks(dev);
+#endif
+
+	nFree += dev->nDeletedFiles;
+
+	/* Now count the number of dirty chunks in the cache and subtract those */
+
+	for (nDirtyCacheChunks = 0, i = 0; i < dev->nShortOpCaches; i++) {
+		if (dev->srCache[i].dirty)
+			nDirtyCacheChunks++;
+	}
+
+	nFree -= nDirtyCacheChunks;
+
+	nFree -= ((dev->nReservedBlocks + 1) * dev->nChunksPerBlock);
+
+	/* Now we figure out how much to reserve for the checkpoint and report that... */
+	blocksForCheckpoint = yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;
+	if (blocksForCheckpoint < 0)
+		blocksForCheckpoint = 0;
+
+	nFree -= (blocksForCheckpoint * dev->nChunksPerBlock);
+
+	if (nFree < 0)
+		nFree = 0;
+
+	return nFree;
+
+}
+
+static int yaffs_freeVerificationFailures;
+
+static void yaffs_VerifyFreeChunks(yaffs_Device *dev)
+{
+	int counted;
+	int difference;
+
+	if (yaffs_SkipVerification(dev))
+		return;
+
+	counted = yaffs_CountFreeChunks(dev);
+
+	difference = dev->nFreeChunks - counted;
+
+	if (difference) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("Freechunks verification failure %d %d %d" TENDSTR),
+		   dev->nFreeChunks, counted, difference));
+		yaffs_freeVerificationFailures++;
+	}
+}
+
+/*---------------------------------------- YAFFS test code ----------------------*/
+
+#define yaffs_CheckStruct(structure, syze, name) \
+	do { \
+		if (sizeof(structure) != syze) { \
+			T(YAFFS_TRACE_ALWAYS, (TSTR("%s should be %d but is %d\n" TENDSTR),\
+				name, syze, sizeof(structure))); \
+			return YAFFS_FAIL; \
+		} \
+	} while (0)
+
+static int yaffs_CheckStructures(void)
+{
+/*      yaffs_CheckStruct(yaffs_Tags,8,"yaffs_Tags"); */
+/*      yaffs_CheckStruct(yaffs_TagsUnion,8,"yaffs_TagsUnion"); */
+/*      yaffs_CheckStruct(yaffs_Spare,16,"yaffs_Spare"); */
+#ifndef CONFIG_YAFFS_TNODE_LIST_DEBUG
+	yaffs_CheckStruct(yaffs_Tnode, 2 * YAFFS_NTNODES_LEVEL0, "yaffs_Tnode");
+#endif
+#ifndef CONFIG_YAFFS_WINCE
+	yaffs_CheckStruct(yaffs_ObjectHeader, 512, "yaffs_ObjectHeader");
+#endif
+	return YAFFS_OK;
+}
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_guts.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_guts.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_guts.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_guts.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,912 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_GUTS_H__
+#define __YAFFS_GUTS_H__
+
+#include "devextras.h"
+#include "yportenv.h"
+
+#define YAFFS_OK	1
+#define YAFFS_FAIL  0
+
+/* Give us a  Y=0x59,
+ * Give us an A=0x41,
+ * Give us an FF=0xFF
+ * Give us an S=0x53
+ * And what have we got...
+ */
+#define YAFFS_MAGIC			0x5941FF53
+
+#define YAFFS_NTNODES_LEVEL0	  	16
+#define YAFFS_TNODES_LEVEL0_BITS	4
+#define YAFFS_TNODES_LEVEL0_MASK	0xf
+
+#define YAFFS_NTNODES_INTERNAL 		(YAFFS_NTNODES_LEVEL0 / 2)
+#define YAFFS_TNODES_INTERNAL_BITS 	(YAFFS_TNODES_LEVEL0_BITS - 1)
+#define YAFFS_TNODES_INTERNAL_MASK	0x7
+#define YAFFS_TNODES_MAX_LEVEL		6
+
+#ifndef CONFIG_YAFFS_NO_YAFFS1
+#define YAFFS_BYTES_PER_SPARE		16
+#define YAFFS_BYTES_PER_CHUNK		512
+#define YAFFS_CHUNK_SIZE_SHIFT		9
+#define YAFFS_CHUNKS_PER_BLOCK		32
+#define YAFFS_BYTES_PER_BLOCK		(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)
+#endif
+
+#define YAFFS_MIN_YAFFS2_CHUNK_SIZE 	1024
+#define YAFFS_MIN_YAFFS2_SPARE_SIZE	32
+
+#define YAFFS_MAX_CHUNK_ID		0x000FFFFF
+
+#define YAFFS_UNUSED_OBJECT_ID		0x0003FFFF
+
+#define YAFFS_ALLOCATION_NOBJECTS	100
+#define YAFFS_ALLOCATION_NTNODES	100
+#define YAFFS_ALLOCATION_NLINKS		100
+
+#define YAFFS_NOBJECT_BUCKETS		256
+
+
+#define YAFFS_OBJECT_SPACE		0x40000
+
+#define YAFFS_CHECKPOINT_VERSION 	3
+
+#ifdef CONFIG_YAFFS_UNICODE
+#define YAFFS_MAX_NAME_LENGTH		127
+#define YAFFS_MAX_ALIAS_LENGTH		79
+#else
+#define YAFFS_MAX_NAME_LENGTH		255
+#define YAFFS_MAX_ALIAS_LENGTH		159
+#endif
+
+#define YAFFS_SHORT_NAME_LENGTH		15
+
+/* Some special object ids for pseudo objects */
+#define YAFFS_OBJECTID_ROOT		1
+#define YAFFS_OBJECTID_LOSTNFOUND	2
+#define YAFFS_OBJECTID_UNLINKED		3
+#define YAFFS_OBJECTID_DELETED		4
+
+/* Sseudo object ids for checkpointing */
+#define YAFFS_OBJECTID_SB_HEADER	0x10
+#define YAFFS_OBJECTID_CHECKPOINT_DATA	0x20
+#define YAFFS_SEQUENCE_CHECKPOINT_DATA  0x21
+
+/* */
+
+#define YAFFS_MAX_SHORT_OP_CACHES	20
+
+#define YAFFS_N_TEMP_BUFFERS		6
+
+/* We limit the number attempts at sucessfully saving a chunk of data.
+ * Small-page devices have 32 pages per block; large-page devices have 64.
+ * Default to something in the order of 5 to 10 blocks worth of chunks.
+ */
+#define YAFFS_WR_ATTEMPTS		(5*64)
+
+/* Sequence numbers are used in YAFFS2 to determine block allocation order.
+ * The range is limited slightly to help distinguish bad numbers from good.
+ * This also allows us to perhaps in the future use special numbers for
+ * special purposes.
+ * EFFFFF00 allows the allocation of 8 blocks per second (~1Mbytes) for 15 years,
+ * and is a larger number than the lifetime of a 2GB device.
+ */
+#define YAFFS_LOWEST_SEQUENCE_NUMBER	0x00001000
+#define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xEFFFFF00
+
+/* Special sequence number for bad block that failed to be marked bad */
+#define YAFFS_SEQUENCE_BAD_BLOCK	0xFFFF0000
+
+/* ChunkCache is used for short read/write operations.*/
+typedef struct {
+	struct yaffs_ObjectStruct *object;
+	int chunkId;
+	int lastUse;
+	int dirty;
+	int nBytes;		/* Only valid if the cache is dirty */
+	int locked;		/* Can't push out or flush while locked. */
+#ifdef CONFIG_YAFFS_YAFFS2
+	__u8 *data;
+#else
+	__u8 data[YAFFS_BYTES_PER_CHUNK];
+#endif
+} yaffs_ChunkCache;
+
+
+
+/* Tags structures in RAM
+ * NB This uses bitfield. Bitfields should not straddle a u32 boundary otherwise
+ * the structure size will get blown out.
+ */
+
+#ifndef CONFIG_YAFFS_NO_YAFFS1
+typedef struct {
+	unsigned chunkId:20;
+	unsigned serialNumber:2;
+	unsigned byteCountLSB:10;
+	unsigned objectId:18;
+	unsigned ecc:12;
+	unsigned byteCountMSB:2;
+} yaffs_Tags;
+
+typedef union {
+	yaffs_Tags asTags;
+	__u8 asBytes[8];
+} yaffs_TagsUnion;
+
+#endif
+
+/* Stuff used for extended tags in YAFFS2 */
+
+typedef enum {
+	YAFFS_ECC_RESULT_UNKNOWN,
+	YAFFS_ECC_RESULT_NO_ERROR,
+	YAFFS_ECC_RESULT_FIXED,
+	YAFFS_ECC_RESULT_UNFIXED
+} yaffs_ECCResult;
+
+typedef enum {
+	YAFFS_OBJECT_TYPE_UNKNOWN,
+	YAFFS_OBJECT_TYPE_FILE,
+	YAFFS_OBJECT_TYPE_SYMLINK,
+	YAFFS_OBJECT_TYPE_DIRECTORY,
+	YAFFS_OBJECT_TYPE_HARDLINK,
+	YAFFS_OBJECT_TYPE_SPECIAL
+} yaffs_ObjectType;
+
+#define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL
+
+typedef struct {
+
+	unsigned validMarker0;
+	unsigned chunkUsed;	/*  Status of the chunk: used or unused */
+	unsigned objectId;	/* If 0 then this is not part of an object (unused) */
+	unsigned chunkId;	/* If 0 then this is a header, else a data chunk */
+	unsigned byteCount;	/* Only valid for data chunks */
+
+	/* The following stuff only has meaning when we read */
+	yaffs_ECCResult eccResult;
+	unsigned blockBad;
+
+	/* YAFFS 1 stuff */
+	unsigned chunkDeleted;	/* The chunk is marked deleted */
+	unsigned serialNumber;	/* Yaffs1 2-bit serial number */
+
+	/* YAFFS2 stuff */
+	unsigned sequenceNumber;	/* The sequence number of this block */
+
+	/* Extra info if this is an object header (YAFFS2 only) */
+
+	unsigned extraHeaderInfoAvailable;	/* There is extra info available if this is not zero */
+	unsigned extraParentObjectId;	/* The parent object */
+	unsigned extraIsShrinkHeader;	/* Is it a shrink header? */
+	unsigned extraShadows;		/* Does this shadow another object? */
+
+	yaffs_ObjectType extraObjectType;	/* What object type? */
+
+	unsigned extraFileLength;		/* Length if it is a file */
+	unsigned extraEquivalentObjectId;	/* Equivalent object Id if it is a hard link */
+
+	unsigned validMarker1;
+
+} yaffs_ExtendedTags;
+
+/* Spare structure for YAFFS1 */
+typedef struct {
+	__u8 tagByte0;
+	__u8 tagByte1;
+	__u8 tagByte2;
+	__u8 tagByte3;
+	__u8 pageStatus;	/* set to 0 to delete the chunk */
+	__u8 blockStatus;
+	__u8 tagByte4;
+	__u8 tagByte5;
+	__u8 ecc1[3];
+	__u8 tagByte6;
+	__u8 tagByte7;
+	__u8 ecc2[3];
+} yaffs_Spare;
+
+/*Special structure for passing through to mtd */
+struct yaffs_NANDSpare {
+	yaffs_Spare spare;
+	int eccres1;
+	int eccres2;
+};
+
+/* Block data in RAM */
+
+typedef enum {
+	YAFFS_BLOCK_STATE_UNKNOWN = 0,
+
+	YAFFS_BLOCK_STATE_SCANNING,
+	YAFFS_BLOCK_STATE_NEEDS_SCANNING,
+	/* The block might have something on it (ie it is allocating or full, perhaps empty)
+	 * but it needs to be scanned to determine its true state.
+	 * This state is only valid during yaffs_Scan.
+	 * NB We tolerate empty because the pre-scanner might be incapable of deciding
+	 * However, if this state is returned on a YAFFS2 device, then we expect a sequence number
+	 */
+
+	YAFFS_BLOCK_STATE_EMPTY,
+	/* This block is empty */
+
+	YAFFS_BLOCK_STATE_ALLOCATING,
+	/* This block is partially allocated.
+	 * At least one page holds valid data.
+	 * This is the one currently being used for page
+	 * allocation. Should never be more than one of these
+	 */
+
+	YAFFS_BLOCK_STATE_FULL,
+	/* All the pages in this block have been allocated.
+	 */
+
+	YAFFS_BLOCK_STATE_DIRTY,
+	/* All pages have been allocated and deleted.
+	 * Erase me, reuse me.
+	 */
+
+	YAFFS_BLOCK_STATE_CHECKPOINT,
+	/* This block is assigned to holding checkpoint data.
+	 */
+
+	YAFFS_BLOCK_STATE_COLLECTING,
+	/* This block is being garbage collected */
+
+	YAFFS_BLOCK_STATE_DEAD
+	/* This block has failed and is not in use */
+} yaffs_BlockState;
+
+#define	YAFFS_NUMBER_OF_BLOCK_STATES (YAFFS_BLOCK_STATE_DEAD + 1)
+
+
+typedef struct {
+
+	int softDeletions:10;	/* number of soft deleted pages */
+	int pagesInUse:10;	/* number of pages in use */
+	unsigned blockState:4;	/* One of the above block states. NB use unsigned because enum is sometimes an int */
+	__u32 needsRetiring:1;	/* Data has failed on this block, need to get valid data off */
+				/* and retire the block. */
+	__u32 skipErasedCheck:1; /* If this is set we can skip the erased check on this block */
+	__u32 gcPrioritise:1; 	/* An ECC check or blank check has failed on this block.
+				   It should be prioritised for GC */
+	__u32 chunkErrorStrikes:3; /* How many times we've had ecc etc failures on this block and tried to reuse it */
+
+#ifdef CONFIG_YAFFS_YAFFS2
+	__u32 hasShrinkHeader:1; /* This block has at least one shrink object header */
+	__u32 sequenceNumber;	 /* block sequence number for yaffs2 */
+#endif
+
+} yaffs_BlockInfo;
+
+/* -------------------------- Object structure -------------------------------*/
+/* This is the object structure as stored on NAND */
+
+typedef struct {
+	yaffs_ObjectType type;
+
+	/* Apply to everything  */
+	int parentObjectId;
+	__u16 sum__NoLongerUsed;        /* checksum of name. No longer used */
+	YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	/* The following apply to directories, files, symlinks - not hard links */
+	__u32 yst_mode;         /* protection */
+
+#ifdef CONFIG_YAFFS_WINCE
+	__u32 notForWinCE[5];
+#else
+	__u32 yst_uid;
+	__u32 yst_gid;
+	__u32 yst_atime;
+	__u32 yst_mtime;
+	__u32 yst_ctime;
+#endif
+
+	/* File size  applies to files only */
+	int fileSize;
+
+	/* Equivalent object id applies to hard links only. */
+	int equivalentObjectId;
+
+	/* Alias is for symlinks only. */
+	YCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];
+
+	__u32 yst_rdev;		/* device stuff for block and char devices (major/min) */
+
+#ifdef CONFIG_YAFFS_WINCE
+	__u32 win_ctime[2];
+	__u32 win_atime[2];
+	__u32 win_mtime[2];
+#else
+	__u32 roomToGrow[6];
+
+#endif
+	__u32 inbandShadowsObject;
+	__u32 inbandIsShrink;
+
+	__u32 reservedSpace[2];
+	int shadowsObject;	/* This object header shadows the specified object if > 0 */
+
+	/* isShrink applies to object headers written when we shrink the file (ie resize) */
+	__u32 isShrink;
+
+} yaffs_ObjectHeader;
+
+/*--------------------------- Tnode -------------------------- */
+
+union yaffs_Tnode_union {
+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+	union yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL + 1];
+#else
+	union yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL];
+#endif
+/*	__u16 level0[YAFFS_NTNODES_LEVEL0]; */
+
+};
+
+typedef union yaffs_Tnode_union yaffs_Tnode;
+
+struct yaffs_TnodeList_struct {
+	struct yaffs_TnodeList_struct *next;
+	yaffs_Tnode *tnodes;
+};
+
+typedef struct yaffs_TnodeList_struct yaffs_TnodeList;
+
+/*------------------------  Object -----------------------------*/
+/* An object can be one of:
+ * - a directory (no data, has children links
+ * - a regular file (data.... not prunes :->).
+ * - a symlink [symbolic link] (the alias).
+ * - a hard link
+ */
+
+typedef struct {
+	__u32 fileSize;
+	__u32 scannedFileSize;
+	__u32 shrinkSize;
+	int topLevel;
+	yaffs_Tnode *top;
+} yaffs_FileStructure;
+
+typedef struct {
+	struct ylist_head children;     /* list of child links */
+} yaffs_DirectoryStructure;
+
+typedef struct {
+	YCHAR *alias;
+} yaffs_SymLinkStructure;
+
+typedef struct {
+	struct yaffs_ObjectStruct *equivalentObject;
+	__u32 equivalentObjectId;
+} yaffs_HardLinkStructure;
+
+typedef union {
+	yaffs_FileStructure fileVariant;
+	yaffs_DirectoryStructure directoryVariant;
+	yaffs_SymLinkStructure symLinkVariant;
+	yaffs_HardLinkStructure hardLinkVariant;
+} yaffs_ObjectVariant;
+
+struct yaffs_ObjectStruct {
+	__u8 deleted:1;		/* This should only apply to unlinked files. */
+	__u8 softDeleted:1;	/* it has also been soft deleted */
+	__u8 unlinked:1;	/* An unlinked file. The file should be in the unlinked directory.*/
+	__u8 fake:1;		/* A fake object has no presence on NAND. */
+	__u8 renameAllowed:1;	/* Some objects are not allowed to be renamed. */
+	__u8 unlinkAllowed:1;
+	__u8 dirty:1;		/* the object needs to be written to flash */
+	__u8 valid:1;		/* When the file system is being loaded up, this
+				 * object might be created before the data
+				 * is available (ie. file data records appear before the header).
+				 */
+	__u8 lazyLoaded:1;	/* This object has been lazy loaded and is missing some detail */
+
+	__u8 deferedFree:1;	/* For Linux kernel. Object is removed from NAND, but is
+				 * still in the inode cache. Free of object is defered.
+				 * until the inode is released.
+				 */
+	__u8 beingCreated:1;	/* This object is still being created so skip some checks. */
+	__u8 isShadowed:1;      /* This object is shadowed on the way to being renamed. */
+
+	__u8 serial;		/* serial number of chunk in NAND. Cached here */
+	__u16 sum;		/* sum of the name to speed searching */
+
+	struct yaffs_DeviceStruct *myDev;       /* The device I'm on */
+
+	struct ylist_head hashLink;     /* list of objects in this hash bucket */
+
+	struct ylist_head hardLinks;    /* all the equivalent hard linked objects */
+
+	/* directory structure stuff */
+	/* also used for linking up the free list */
+	struct yaffs_ObjectStruct *parent;
+	struct ylist_head siblings;
+
+	/* Where's my object header in NAND? */
+	int hdrChunk;
+
+	int nDataChunks;	/* Number of data chunks attached to the file. */
+
+	__u32 objectId;		/* the object id value */
+
+	__u32 yst_mode;
+
+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+	YCHAR shortName[YAFFS_SHORT_NAME_LENGTH + 1];
+#endif
+
+#ifndef __KERNEL__
+	__u32 inUse;
+#endif
+
+#ifdef CONFIG_YAFFS_WINCE
+	__u32 win_ctime[2];
+	__u32 win_mtime[2];
+	__u32 win_atime[2];
+#else
+	__u32 yst_uid;
+	__u32 yst_gid;
+	__u32 yst_atime;
+	__u32 yst_mtime;
+	__u32 yst_ctime;
+#endif
+
+	__u32 yst_rdev;
+
+#ifdef __KERNEL__
+	struct inode *myInode;
+
+#endif
+
+	yaffs_ObjectType variantType;
+
+	yaffs_ObjectVariant variant;
+
+};
+
+typedef struct yaffs_ObjectStruct yaffs_Object;
+
+struct yaffs_ObjectList_struct {
+	yaffs_Object *objects;
+	struct yaffs_ObjectList_struct *next;
+};
+
+typedef struct yaffs_ObjectList_struct yaffs_ObjectList;
+
+typedef struct {
+	struct ylist_head list;
+	int count;
+} yaffs_ObjectBucket;
+
+
+/* yaffs_CheckpointObject holds the definition of an object as dumped
+ * by checkpointing.
+ */
+
+typedef struct {
+	int structType;
+	__u32 objectId;
+	__u32 parentId;
+	int hdrChunk;
+	yaffs_ObjectType variantType:3;
+	__u8 deleted:1;
+	__u8 softDeleted:1;
+	__u8 unlinked:1;
+	__u8 fake:1;
+	__u8 renameAllowed:1;
+	__u8 unlinkAllowed:1;
+	__u8 serial;
+
+	int nDataChunks;
+	__u32 fileSizeOrEquivalentObjectId;
+} yaffs_CheckpointObject;
+
+/*--------------------- Temporary buffers ----------------
+ *
+ * These are chunk-sized working buffers. Each device has a few
+ */
+
+typedef struct {
+	__u8 *buffer;
+	int line;	/* track from whence this buffer was allocated */
+	int maxLine;
+} yaffs_TempBuffer;
+
+/*----------------- Device ---------------------------------*/
+
+struct yaffs_DeviceStruct {
+	struct ylist_head devList;
+	const char *name;
+
+	/* Entry parameters set up way early. Yaffs sets up the rest.*/
+	int nDataBytesPerChunk;	/* Should be a power of 2 >= 512 */
+	int nChunksPerBlock;	/* does not need to be a power of 2 */
+	int spareBytesPerChunk;	/* spare area size */
+	int startBlock;		/* Start block we're allowed to use */
+	int endBlock;		/* End block we're allowed to use */
+	int nReservedBlocks;	/* We want this tuneable so that we can reduce */
+				/* reserved blocks on NOR and RAM. */
+
+
+	/* Stuff used by the shared space checkpointing mechanism */
+	/* If this value is zero, then this mechanism is disabled */
+
+/*	int nCheckpointReservedBlocks; */ /* Blocks to reserve for checkpoint data */
+
+
+	int nShortOpCaches;	/* If <= 0, then short op caching is disabled, else
+				 * the number of short op caches (don't use too many)
+				 */
+
+	int useHeaderFileSize;	/* Flag to determine if we should use file sizes from the header */
+
+	int emptyLostAndFound;  /* Flasg to determine if lst+found should be emptied on init */
+
+	int useNANDECC;		/* Flag to decide whether or not to use NANDECC */
+
+	void *genericDevice;	/* Pointer to device context
+				 * On an mtd this holds the mtd pointer.
+				 */
+	void *superBlock;
+
+	/* NAND access functions (Must be set before calling YAFFS)*/
+
+	int (*writeChunkToNAND) (struct yaffs_DeviceStruct *dev,
+					int chunkInNAND, const __u8 *data,
+					const yaffs_Spare *spare);
+	int (*readChunkFromNAND) (struct yaffs_DeviceStruct *dev,
+					int chunkInNAND, __u8 *data,
+					yaffs_Spare *spare);
+	int (*eraseBlockInNAND) (struct yaffs_DeviceStruct *dev,
+					int blockInNAND);
+	int (*initialiseNAND) (struct yaffs_DeviceStruct *dev);
+	int (*deinitialiseNAND) (struct yaffs_DeviceStruct *dev);
+
+#ifdef CONFIG_YAFFS_YAFFS2
+	int (*writeChunkWithTagsToNAND) (struct yaffs_DeviceStruct *dev,
+					 int chunkInNAND, const __u8 *data,
+					 const yaffs_ExtendedTags *tags);
+	int (*readChunkWithTagsFromNAND) (struct yaffs_DeviceStruct *dev,
+					  int chunkInNAND, __u8 *data,
+					  yaffs_ExtendedTags *tags);
+	int (*markNANDBlockBad) (struct yaffs_DeviceStruct *dev, int blockNo);
+	int (*queryNANDBlock) (struct yaffs_DeviceStruct *dev, int blockNo,
+			       yaffs_BlockState *state, __u32 *sequenceNumber);
+#endif
+
+	int isYaffs2;
+
+	/* The removeObjectCallback function must be supplied by OS flavours that
+	 * need it.
+         * yaffs direct uses it to implement the faster readdir.
+         * Linux uses it to protect the directory during unlocking.
+	 */
+	void (*removeObjectCallback)(struct yaffs_ObjectStruct *obj);
+
+	/* Callback to mark the superblock dirsty */
+	void (*markSuperBlockDirty)(void *superblock);
+
+	int wideTnodesDisabled; /* Set to disable wide tnodes */
+
+	YCHAR *pathDividers;	/* String of legal path dividers */
+
+
+	/* End of stuff that must be set before initialisation. */
+
+	/* Checkpoint control. Can be set before or after initialisation */
+	__u8 skipCheckpointRead;
+	__u8 skipCheckpointWrite;
+
+	/* Runtime parameters. Set up by YAFFS. */
+
+	__u16 chunkGroupBits;	/* 0 for devices <= 32MB. else log2(nchunks) - 16 */
+	__u16 chunkGroupSize;	/* == 2^^chunkGroupBits */
+
+	/* Stuff to support wide tnodes */
+	__u32 tnodeWidth;
+	__u32 tnodeMask;
+
+	/* Stuff for figuring out file offset to chunk conversions */
+	__u32 chunkShift; /* Shift value */
+	__u32 chunkDiv;   /* Divisor after shifting: 1 for power-of-2 sizes */
+	__u32 chunkMask;  /* Mask to use for power-of-2 case */
+
+	/* Stuff to handle inband tags */
+	int inbandTags;
+	__u32 totalBytesPerChunk;
+
+#ifdef __KERNEL__
+
+	struct semaphore sem;	/* Semaphore for waiting on erasure.*/
+	struct semaphore grossLock;	/* Gross locking semaphore */
+	struct rw_semaphore dirLock; /* Lock the directory structure */
+	__u8 *spareBuffer;	/* For mtdif2 use. Don't know the size of the buffer
+				 * at compile time so we have to allocate it.
+
+				 */
+	void (*putSuperFunc) (struct super_block *sb);
+        struct ylist_head searchContexts;
+
+#endif
+
+	int isMounted;
+
+	int isCheckpointed;
+
+
+	/* Stuff to support block offsetting to support start block zero */
+	int internalStartBlock;
+	int internalEndBlock;
+	int blockOffset;
+	int chunkOffset;
+
+
+	/* Runtime checkpointing stuff */
+	int checkpointPageSequence;   /* running sequence number of checkpoint pages */
+	int checkpointByteCount;
+	int checkpointByteOffset;
+	__u8 *checkpointBuffer;
+	int checkpointOpenForWrite;
+	int blocksInCheckpoint;
+	int checkpointCurrentChunk;
+	int checkpointCurrentBlock;
+	int checkpointNextBlock;
+	int *checkpointBlockList;
+	int checkpointMaxBlocks;
+	__u32 checkpointSum;
+	__u32 checkpointXor;
+
+	int nCheckpointBlocksRequired; /* Number of blocks needed to store current checkpoint set */
+
+	/* Block Info */
+	yaffs_BlockInfo *blockInfo;
+	__u8 *chunkBits;	/* bitmap of chunks in use */
+	unsigned blockInfoAlt:1;	/* was allocated using alternative strategy */
+	unsigned chunkBitsAlt:1;	/* was allocated using alternative strategy */
+	int chunkBitmapStride;	/* Number of bytes of chunkBits per block.
+				 * Must be consistent with nChunksPerBlock.
+				 */
+
+	int nErasedBlocks;
+	int allocationBlock;	/* Current block being allocated off */
+	__u32 allocationPage;
+	int allocationBlockFinder;	/* Used to search for next allocation block */
+
+	/* Runtime state */
+	int nTnodesCreated;
+	yaffs_Tnode *freeTnodes;
+	int nFreeTnodes;
+	yaffs_TnodeList *allocatedTnodeList;
+
+	int isDoingGC;
+	int gcBlock;
+	int gcChunk;
+
+	int nObjectsCreated;
+	yaffs_Object *freeObjects;
+	int nFreeObjects;
+
+	int nHardLinks;
+
+	yaffs_ObjectList *allocatedObjectList;
+
+	yaffs_ObjectBucket objectBucket[YAFFS_NOBJECT_BUCKETS];
+
+	int nFreeChunks;
+
+	int currentDirtyChecker;	/* Used to find current dirtiest block */
+
+	__u32 *gcCleanupList;	/* objects to delete at the end of a GC. */
+	int nonAggressiveSkip;	/* GC state/mode */
+
+	/* Statistcs */
+	int nPageWrites;
+	int nPageReads;
+	int nBlockErasures;
+	int nErasureFailures;
+	int nGCCopies;
+	int garbageCollections;
+	int passiveGarbageCollections;
+	int nRetriedWrites;
+	int nRetiredBlocks;
+	int eccFixed;
+	int eccUnfixed;
+	int tagsEccFixed;
+	int tagsEccUnfixed;
+	int nDeletions;
+	int nUnmarkedDeletions;
+
+	int hasPendingPrioritisedGCs; /* We think this device might have pending prioritised gcs */
+
+	/* Special directories */
+	yaffs_Object *rootDir;
+	yaffs_Object *lostNFoundDir;
+
+	/* Buffer areas for storing data to recover from write failures TODO
+	 *      __u8            bufferedData[YAFFS_CHUNKS_PER_BLOCK][YAFFS_BYTES_PER_CHUNK];
+	 *      yaffs_Spare bufferedSpare[YAFFS_CHUNKS_PER_BLOCK];
+	 */
+
+	int bufferedBlock;	/* Which block is buffered here? */
+	int doingBufferedBlockRewrite;
+
+	yaffs_ChunkCache *srCache;
+	int srLastUse;
+
+	int cacheHits;
+
+	/* Stuff for background deletion and unlinked files.*/
+	yaffs_Object *unlinkedDir;	/* Directory where unlinked and deleted files live. */
+	yaffs_Object *deletedDir;	/* Directory where deleted objects are sent to disappear. */
+	yaffs_Object *unlinkedDeletion;	/* Current file being background deleted.*/
+	int nDeletedFiles;		/* Count of files awaiting deletion;*/
+	int nUnlinkedFiles;		/* Count of unlinked files. */
+	int nBackgroundDeletions;	/* Count of background deletions. */
+
+
+	/* Temporary buffer management */
+	yaffs_TempBuffer tempBuffer[YAFFS_N_TEMP_BUFFERS];
+	int maxTemp;
+	int tempInUse;
+	int unmanagedTempAllocations;
+	int unmanagedTempDeallocations;
+
+	/* yaffs2 runtime stuff */
+	unsigned sequenceNumber;	/* Sequence number of currently allocating block */
+	unsigned oldestDirtySequence;
+
+};
+
+typedef struct yaffs_DeviceStruct yaffs_Device;
+
+/* The static layout of block usage etc is stored in the super block header */
+typedef struct {
+	int StructType;
+	int version;
+	int checkpointStartBlock;
+	int checkpointEndBlock;
+	int startBlock;
+	int endBlock;
+	int rfu[100];
+} yaffs_SuperBlockHeader;
+
+/* The CheckpointDevice structure holds the device information that changes at runtime and
+ * must be preserved over unmount/mount cycles.
+ */
+typedef struct {
+	int structType;
+	int nErasedBlocks;
+	int allocationBlock;	/* Current block being allocated off */
+	__u32 allocationPage;
+	int nFreeChunks;
+
+	int nDeletedFiles;		/* Count of files awaiting deletion;*/
+	int nUnlinkedFiles;		/* Count of unlinked files. */
+	int nBackgroundDeletions;	/* Count of background deletions. */
+
+	/* yaffs2 runtime stuff */
+	unsigned sequenceNumber;	/* Sequence number of currently allocating block */
+	unsigned oldestDirtySequence;
+
+} yaffs_CheckpointDevice;
+
+
+typedef struct {
+	int structType;
+	__u32 magic;
+	__u32 version;
+	__u32 head;
+} yaffs_CheckpointValidity;
+
+
+/*----------------------- YAFFS Functions -----------------------*/
+
+int yaffs_GutsInitialise(yaffs_Device *dev);
+void yaffs_Deinitialise(yaffs_Device *dev);
+
+int yaffs_GetNumberOfFreeChunks(yaffs_Device *dev);
+
+int yaffs_RenameObject(yaffs_Object *oldDir, const YCHAR *oldName,
+		       yaffs_Object *newDir, const YCHAR *newName);
+
+int yaffs_Unlink(yaffs_Object *dir, const YCHAR *name);
+int yaffs_DeleteObject(yaffs_Object *obj);
+
+int yaffs_GetObjectName(yaffs_Object *obj, YCHAR *name, int buffSize);
+int yaffs_GetObjectFileLength(yaffs_Object *obj);
+int yaffs_GetObjectInode(yaffs_Object *obj);
+unsigned yaffs_GetObjectType(yaffs_Object *obj);
+int yaffs_GetObjectLinkCount(yaffs_Object *obj);
+
+int yaffs_SetAttributes(yaffs_Object *obj, struct iattr *attr);
+int yaffs_GetAttributes(yaffs_Object *obj, struct iattr *attr);
+
+/* File operations */
+int yaffs_ReadDataFromFile(yaffs_Object *obj, __u8 *buffer, loff_t offset,
+				int nBytes);
+int yaffs_WriteDataToFile(yaffs_Object *obj, const __u8 *buffer, loff_t offset,
+				int nBytes, int writeThrough);
+int yaffs_ResizeFile(yaffs_Object *obj, loff_t newSize);
+
+yaffs_Object *yaffs_MknodFile(yaffs_Object *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid);
+int yaffs_FlushFile(yaffs_Object *obj, int updateTime);
+
+/* Flushing and checkpointing */
+void yaffs_FlushEntireDeviceCache(yaffs_Device *dev);
+
+int yaffs_CheckpointSave(yaffs_Device *dev);
+int yaffs_CheckpointRestore(yaffs_Device *dev);
+
+/* Directory operations */
+yaffs_Object *yaffs_MknodDirectory(yaffs_Object *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid);
+yaffs_Object *yaffs_FindObjectByName(yaffs_Object *theDir, const YCHAR *name);
+int yaffs_ApplyToDirectoryChildren(yaffs_Object *theDir,
+				   int (*fn) (yaffs_Object *));
+
+yaffs_Object *yaffs_FindObjectByNumber(yaffs_Device *dev, __u32 number);
+
+/* Link operations */
+yaffs_Object *yaffs_Link(yaffs_Object *parent, const YCHAR *name,
+			 yaffs_Object *equivalentObject);
+
+yaffs_Object *yaffs_GetEquivalentObject(yaffs_Object *obj);
+
+/* Symlink operations */
+yaffs_Object *yaffs_MknodSymLink(yaffs_Object *parent, const YCHAR *name,
+				 __u32 mode, __u32 uid, __u32 gid,
+				 const YCHAR *alias);
+YCHAR *yaffs_GetSymlinkAlias(yaffs_Object *obj);
+
+/* Special inodes (fifos, sockets and devices) */
+yaffs_Object *yaffs_MknodSpecial(yaffs_Object *parent, const YCHAR *name,
+				 __u32 mode, __u32 uid, __u32 gid, __u32 rdev);
+
+/* Special directories */
+yaffs_Object *yaffs_Root(yaffs_Device *dev);
+yaffs_Object *yaffs_LostNFound(yaffs_Device *dev);
+
+#ifdef CONFIG_YAFFS_WINCE
+/* CONFIG_YAFFS_WINCE special stuff */
+void yfsd_WinFileTimeNow(__u32 target[2]);
+#endif
+
+#ifdef __KERNEL__
+
+void yaffs_HandleDeferedFree(yaffs_Object *obj);
+#endif
+
+/* Debug dump  */
+int yaffs_DumpObject(yaffs_Object *obj);
+
+void yaffs_GutsTest(yaffs_Device *dev);
+
+/* A few useful functions */
+void yaffs_InitialiseTags(yaffs_ExtendedTags *tags);
+void yaffs_DeleteChunk(yaffs_Device *dev, int chunkId, int markNAND, int lyn);
+int yaffs_CheckFF(__u8 *buffer, int nBytes);
+void yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi);
+
+__u8 *yaffs_GetTempBuffer(yaffs_Device *dev, int lineNo);
+void yaffs_ReleaseTempBuffer(yaffs_Device *dev, __u8 *buffer, int lineNo);
+
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffsinterface.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffsinterface.h
--- linux-2.6.32-orig/fs/yaffs2/yaffsinterface.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffsinterface.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,21 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFSINTERFACE_H__
+#define __YAFFSINTERFACE_H__
+
+int yaffs_Initialise(unsigned nBlocks);
+
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_mtdif1.c iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_mtdif1.c
--- linux-2.6.32-orig/fs/yaffs2/yaffs_mtdif1.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_mtdif1.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,361 @@
+/*
+ * YAFFS: Yet another FFS. A NAND-flash specific file system.
+ * yaffs_mtdif1.c  NAND mtd interface functions for small-page NAND.
+ *
+ * Copyright (C) 2002 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This module provides the interface between yaffs_nand.c and the
+ * MTD API.  This version is used when the MTD interface supports the
+ * 'mtd_oob_ops' style calls to read_oob and write_oob, circa 2.6.17,
+ * and we have small-page NAND device.
+ *
+ * These functions are invoked via function pointers in yaffs_nand.c.
+ * This replaces functionality provided by functions in yaffs_mtdif.c
+ * and the yaffs_TagsCompatability functions in yaffs_tagscompat.c that are
+ * called in yaffs_mtdif.c when the function pointers are NULL.
+ * We assume the MTD layer is performing ECC (useNANDECC is true).
+ */
+
+#include "yportenv.h"
+#include "yaffs_guts.h"
+#include "yaffs_packedtags1.h"
+#include "yaffs_tagscompat.h"	/* for yaffs_CalcTagsECC */
+
+#include "linux/kernel.h"
+#include "linux/version.h"
+#include "linux/types.h"
+#include "linux/mtd/mtd.h"
+
+/* Don't compile this module if we don't have MTD's mtd_oob_ops interface */
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+
+const char *yaffs_mtdif1_c_version = "$Id$";
+
+#ifndef CONFIG_YAFFS_9BYTE_TAGS
+# define YTAG1_SIZE 8
+#else
+# define YTAG1_SIZE 9
+#endif
+
+#if 0
+/* Use the following nand_ecclayout with MTD when using
+ * CONFIG_YAFFS_9BYTE_TAGS and the older on-NAND tags layout.
+ * If you have existing Yaffs images and the byte order differs from this,
+ * adjust 'oobfree' to match your existing Yaffs data.
+ *
+ * This nand_ecclayout scatters/gathers to/from the old-yaffs layout with the
+ * pageStatus byte (at NAND spare offset 4) scattered/gathered from/to
+ * the 9th byte.
+ *
+ * Old-style on-NAND format: T0,T1,T2,T3,P,B,T4,T5,E0,E1,E2,T6,T7,E3,E4,E5
+ * We have/need PackedTags1 plus pageStatus: T0,T1,T2,T3,T4,T5,T6,T7,P
+ * where Tn are the tag bytes, En are MTD's ECC bytes, P is the pageStatus
+ * byte and B is the small-page bad-block indicator byte.
+ */
+static struct nand_ecclayout nand_oob_16 = {
+	.eccbytes = 6,
+	.eccpos = { 8, 9, 10, 13, 14, 15 },
+	.oobavail = 9,
+	.oobfree = { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+#endif
+
+/* Write a chunk (page) of data to NAND.
+ *
+ * Caller always provides ExtendedTags data which are converted to a more
+ * compact (packed) form for storage in NAND.  A mini-ECC runs over the
+ * contents of the tags meta-data; used to valid the tags when read.
+ *
+ *  - Pack ExtendedTags to PackedTags1 form
+ *  - Compute mini-ECC for PackedTags1
+ *  - Write data and packed tags to NAND.
+ *
+ * Note: Due to the use of the PackedTags1 meta-data which does not include
+ * a full sequence number (as found in the larger PackedTags2 form) it is
+ * necessary for Yaffs to re-write a chunk/page (just once) to mark it as
+ * discarded and dirty.  This is not ideal: newer NAND parts are supposed
+ * to be written just once.  When Yaffs performs this operation, this
+ * function is called with a NULL data pointer -- calling MTD write_oob
+ * without data is valid usage (2.6.17).
+ *
+ * Any underlying MTD error results in YAFFS_FAIL.
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_WriteChunkWithTagsToNAND(yaffs_Device *dev,
+	int chunkInNAND, const __u8 *data, const yaffs_ExtendedTags *etags)
+{
+	struct mtd_info *mtd = dev->genericDevice;
+	int chunkBytes = dev->nDataBytesPerChunk;
+	loff_t addr = ((loff_t)chunkInNAND) * chunkBytes;
+	struct mtd_oob_ops ops;
+	yaffs_PackedTags1 pt1;
+	int retval;
+
+	/* we assume that PackedTags1 and yaffs_Tags are compatible */
+	compile_time_assertion(sizeof(yaffs_PackedTags1) == 12);
+	compile_time_assertion(sizeof(yaffs_Tags) == 8);
+
+	yaffs_PackTags1(&pt1, etags);
+	yaffs_CalcTagsECC((yaffs_Tags *)&pt1);
+
+	/* When deleting a chunk, the upper layer provides only skeletal
+	 * etags, one with chunkDeleted set.  However, we need to update the
+	 * tags, not erase them completely.  So we use the NAND write property
+	 * that only zeroed-bits stick and set tag bytes to all-ones and
+	 * zero just the (not) deleted bit.
+	 */
+#ifndef CONFIG_YAFFS_9BYTE_TAGS
+	if (etags->chunkDeleted) {
+		memset(&pt1, 0xff, 8);
+		/* clear delete status bit to indicate deleted */
+		pt1.deleted = 0;
+	}
+#else
+	((__u8 *)&pt1)[8] = 0xff;
+	if (etags->chunkDeleted) {
+		memset(&pt1, 0xff, 8);
+		/* zero pageStatus byte to indicate deleted */
+		((__u8 *)&pt1)[8] = 0;
+	}
+#endif
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OOB_AUTO;
+	ops.len = (data) ? chunkBytes : 0;
+	ops.ooblen = YTAG1_SIZE;
+	ops.datbuf = (__u8 *)data;
+	ops.oobbuf = (__u8 *)&pt1;
+
+	retval = mtd->write_oob(mtd, addr, &ops);
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"write_oob failed, chunk %d, mtd error %d\n",
+			chunkInNAND, retval);
+	}
+	return retval ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Return with empty ExtendedTags but add eccResult.
+ */
+static int rettags(yaffs_ExtendedTags *etags, int eccResult, int retval)
+{
+	if (etags) {
+		memset(etags, 0, sizeof(*etags));
+		etags->eccResult = eccResult;
+	}
+	return retval;
+}
+
+/* Read a chunk (page) from NAND.
+ *
+ * Caller expects ExtendedTags data to be usable even on error; that is,
+ * all members except eccResult and blockBad are zeroed.
+ *
+ *  - Check ECC results for data (if applicable)
+ *  - Check for blank/erased block (return empty ExtendedTags if blank)
+ *  - Check the PackedTags1 mini-ECC (correct if necessary/possible)
+ *  - Convert PackedTags1 to ExtendedTags
+ *  - Update eccResult and blockBad members to refect state.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_ReadChunkWithTagsFromNAND(yaffs_Device *dev,
+	int chunkInNAND, __u8 *data, yaffs_ExtendedTags *etags)
+{
+	struct mtd_info *mtd = dev->genericDevice;
+	int chunkBytes = dev->nDataBytesPerChunk;
+	loff_t addr = ((loff_t)chunkInNAND) * chunkBytes;
+	int eccres = YAFFS_ECC_RESULT_NO_ERROR;
+	struct mtd_oob_ops ops;
+	yaffs_PackedTags1 pt1;
+	int retval;
+	int deleted;
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OOB_AUTO;
+	ops.len = (data) ? chunkBytes : 0;
+	ops.ooblen = YTAG1_SIZE;
+	ops.datbuf = data;
+	ops.oobbuf = (__u8 *)&pt1;
+
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 20))
+	/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;
+	 * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.
+	 */
+	ops.len = (ops.datbuf) ? ops.len : ops.ooblen;
+#endif
+	/* Read page and oob using MTD.
+	 * Check status and determine ECC result.
+	 */
+	retval = mtd->read_oob(mtd, addr, &ops);
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"read_oob failed, chunk %d, mtd error %d\n",
+			chunkInNAND, retval);
+	}
+
+	switch (retval) {
+	case 0:
+		/* no error */
+		break;
+
+	case -EUCLEAN:
+		/* MTD's ECC fixed the data */
+		eccres = YAFFS_ECC_RESULT_FIXED;
+		dev->eccFixed++;
+		break;
+
+	case -EBADMSG:
+		/* MTD's ECC could not fix the data */
+		dev->eccUnfixed++;
+		/* fall into... */
+	default:
+		rettags(etags, YAFFS_ECC_RESULT_UNFIXED, 0);
+		etags->blockBad = (mtd->block_isbad)(mtd, addr);
+		return YAFFS_FAIL;
+	}
+
+	/* Check for a blank/erased chunk.
+	 */
+	if (yaffs_CheckFF((__u8 *)&pt1, 8)) {
+		/* when blank, upper layers want eccResult to be <= NO_ERROR */
+		return rettags(etags, YAFFS_ECC_RESULT_NO_ERROR, YAFFS_OK);
+	}
+
+#ifndef CONFIG_YAFFS_9BYTE_TAGS
+	/* Read deleted status (bit) then return it to it's non-deleted
+	 * state before performing tags mini-ECC check. pt1.deleted is
+	 * inverted.
+	 */
+	deleted = !pt1.deleted;
+	pt1.deleted = 1;
+#else
+	deleted = (yaffs_CountBits(((__u8 *)&pt1)[8]) < 7);
+#endif
+
+	/* Check the packed tags mini-ECC and correct if necessary/possible.
+	 */
+	retval = yaffs_CheckECCOnTags((yaffs_Tags *)&pt1);
+	switch (retval) {
+	case 0:
+		/* no tags error, use MTD result */
+		break;
+	case 1:
+		/* recovered tags-ECC error */
+		dev->tagsEccFixed++;
+		if (eccres == YAFFS_ECC_RESULT_NO_ERROR)
+			eccres = YAFFS_ECC_RESULT_FIXED;
+		break;
+	default:
+		/* unrecovered tags-ECC error */
+		dev->tagsEccUnfixed++;
+		return rettags(etags, YAFFS_ECC_RESULT_UNFIXED, YAFFS_FAIL);
+	}
+
+	/* Unpack the tags to extended form and set ECC result.
+	 * [set shouldBeFF just to keep yaffs_UnpackTags1 happy]
+	 */
+	pt1.shouldBeFF = 0xFFFFFFFF;
+	yaffs_UnpackTags1(etags, &pt1);
+	etags->eccResult = eccres;
+
+	/* Set deleted state */
+	etags->chunkDeleted = deleted;
+	return YAFFS_OK;
+}
+
+/* Mark a block bad.
+ *
+ * This is a persistant state.
+ * Use of this function should be rare.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo)
+{
+	struct mtd_info *mtd = dev->genericDevice;
+	int blocksize = dev->nChunksPerBlock * dev->nDataBytesPerChunk;
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "marking block %d bad\n", blockNo);
+
+	retval = mtd->block_markbad(mtd, (loff_t)blocksize * blockNo);
+	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Check any MTD prerequists.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+static int nandmtd1_TestPrerequists(struct mtd_info *mtd)
+{
+	/* 2.6.18 has mtd->ecclayout->oobavail */
+	/* 2.6.21 has mtd->ecclayout->oobavail and mtd->oobavail */
+	int oobavail = mtd->ecclayout->oobavail;
+
+	if (oobavail < YTAG1_SIZE) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"mtd device has only %d bytes for tags, need %d\n",
+			oobavail, YTAG1_SIZE);
+		return YAFFS_FAIL;
+	}
+	return YAFFS_OK;
+}
+
+/* Query for the current state of a specific block.
+ *
+ * Examine the tags of the first chunk of the block and return the state:
+ *  - YAFFS_BLOCK_STATE_DEAD, the block is marked bad
+ *  - YAFFS_BLOCK_STATE_NEEDS_SCANNING, the block is in use
+ *  - YAFFS_BLOCK_STATE_EMPTY, the block is clean
+ *
+ * Always returns YAFFS_OK.
+ */
+int nandmtd1_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+	yaffs_BlockState *pState, __u32 *pSequenceNumber)
+{
+	struct mtd_info *mtd = dev->genericDevice;
+	int chunkNo = blockNo * dev->nChunksPerBlock;
+	loff_t addr = (loff_t)chunkNo * dev->nDataBytesPerChunk;
+	yaffs_ExtendedTags etags;
+	int state = YAFFS_BLOCK_STATE_DEAD;
+	int seqnum = 0;
+	int retval;
+
+	/* We don't yet have a good place to test for MTD config prerequists.
+	 * Do it here as we are called during the initial scan.
+	 */
+	if (nandmtd1_TestPrerequists(mtd) != YAFFS_OK)
+		return YAFFS_FAIL;
+
+	retval = nandmtd1_ReadChunkWithTagsFromNAND(dev, chunkNo, NULL, &etags);
+	etags.blockBad = (mtd->block_isbad)(mtd, addr);
+	if (etags.blockBad) {
+		yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+			"block %d is marked bad\n", blockNo);
+		state = YAFFS_BLOCK_STATE_DEAD;
+	} else if (etags.eccResult != YAFFS_ECC_RESULT_NO_ERROR) {
+		/* bad tags, need to look more closely */
+		state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+	} else if (etags.chunkUsed) {
+		state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+		seqnum = etags.sequenceNumber;
+	} else {
+		state = YAFFS_BLOCK_STATE_EMPTY;
+	}
+
+	*pState = state;
+	*pSequenceNumber = seqnum;
+
+	/* query always succeeds */
+	return YAFFS_OK;
+}
+
+#endif /*MTD_VERSION*/
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_mtdif1.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_mtdif1.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_mtdif1.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_mtdif1.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF1_H__
+#define __YAFFS_MTDIF1_H__
+
+int nandmtd1_WriteChunkWithTagsToNAND(yaffs_Device *dev, int chunkInNAND,
+	const __u8 *data, const yaffs_ExtendedTags *tags);
+
+int nandmtd1_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+	__u8 *data, yaffs_ExtendedTags *tags);
+
+int nandmtd1_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);
+
+int nandmtd1_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+	yaffs_BlockState *state, __u32 *sequenceNumber);
+
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_mtdif2.c iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_mtdif2.c
--- linux-2.6.32-orig/fs/yaffs2/yaffs_mtdif2.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_mtdif2.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,251 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* mtd interface for YAFFS2 */
+
+const char *yaffs_mtdif2_c_version =
+	"$Id$";
+
+#include "yportenv.h"
+
+
+#include "yaffs_mtdif2.h"
+
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+
+#include "yaffs_packedtags2.h"
+
+/* NB For use with inband tags....
+ * We assume that the data buffer is of size totalBytersPerChunk so that we can also
+ * use it to load the tags.
+ */
+int nandmtd2_WriteChunkWithTagsToNAND(yaffs_Device *dev, int chunkInNAND,
+				      const __u8 *data,
+				      const yaffs_ExtendedTags *tags)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#else
+	size_t dummy;
+#endif
+	int retval = 0;
+
+	loff_t addr;
+
+	yaffs_PackedTags2 pt;
+
+	T(YAFFS_TRACE_MTD,
+	  (TSTR
+	   ("nandmtd2_WriteChunkWithTagsToNAND chunk %d data %p tags %p"
+	    TENDSTR), chunkInNAND, data, tags));
+
+	addr  = ((loff_t) chunkInNAND) * dev->totalBytesPerChunk;
+
+	/* For yaffs2 writing there must be both data and tags.
+	 * If we're using inband tags, then the tags are stuffed into
+	 * the end of the data buffer.
+	 */
+	if (!data || !tags)
+		BUG();
+	else if (dev->inbandTags) {
+		yaffs_PackedTags2TagsPart *pt2tp;
+		pt2tp = (yaffs_PackedTags2TagsPart *)(data + dev->nDataBytesPerChunk);
+		yaffs_PackTags2TagsPart(pt2tp, tags);
+	} else
+		yaffs_PackTags2(&pt, tags);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+	ops.mode = MTD_OOB_AUTO;
+	ops.ooblen = (dev->inbandTags) ? 0 : sizeof(pt);
+	ops.len = dev->totalBytesPerChunk;
+	ops.ooboffs = 0;
+	ops.datbuf = (__u8 *)data;
+	ops.oobbuf = (dev->inbandTags) ? NULL : (void *)&pt;
+	retval = mtd->write_oob(mtd, addr, &ops);
+
+#else
+	if (!dev->inbandTags) {
+		retval =
+		    mtd->write_ecc(mtd, addr, dev->nDataBytesPerChunk,
+				   &dummy, data, (__u8 *) &pt, NULL);
+	} else {
+		retval =
+		    mtd->write(mtd, addr, dev->totalBytesPerChunk, &dummy,
+			       data);
+	}
+#endif
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd2_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+				       __u8 *data, yaffs_ExtendedTags *tags)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#endif
+	size_t dummy;
+	int retval = 0;
+	int localData = 0;
+
+	loff_t addr = ((loff_t) chunkInNAND) * dev->totalBytesPerChunk;
+
+	yaffs_PackedTags2 pt;
+
+	T(YAFFS_TRACE_MTD,
+	  (TSTR
+	   ("nandmtd2_ReadChunkWithTagsFromNAND chunk %d data %p tags %p"
+	    TENDSTR), chunkInNAND, data, tags));
+
+	if (dev->inbandTags) {
+
+		if (!data) {
+			localData = 1;
+			data = yaffs_GetTempBuffer(dev, __LINE__);
+		}
+
+
+	}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+	if (dev->inbandTags || (data && !tags))
+		retval = mtd->read(mtd, addr, dev->totalBytesPerChunk,
+				&dummy, data);
+	else if (tags) {
+		ops.mode = MTD_OOB_AUTO;
+		ops.ooblen = sizeof(pt);
+		ops.len = data ? dev->nDataBytesPerChunk : sizeof(pt);
+		ops.ooboffs = 0;
+		ops.datbuf = data;
+		ops.oobbuf = dev->spareBuffer;
+		retval = mtd->read_oob(mtd, addr, &ops);
+	}
+#else
+	if (!dev->inbandTags && data && tags) {
+
+		retval = mtd->read_ecc(mtd, addr, dev->nDataBytesPerChunk,
+					  &dummy, data, dev->spareBuffer,
+					  NULL);
+	} else {
+		if (data)
+			retval =
+			    mtd->read(mtd, addr, dev->nDataBytesPerChunk, &dummy,
+				      data);
+		if (!dev->inbandTags && tags)
+			retval =
+			    mtd->read_oob(mtd, addr, mtd->oobsize, &dummy,
+					  dev->spareBuffer);
+	}
+#endif
+
+
+	if (dev->inbandTags) {
+		if (tags) {
+			yaffs_PackedTags2TagsPart *pt2tp;
+			pt2tp = (yaffs_PackedTags2TagsPart *)&data[dev->nDataBytesPerChunk];
+			yaffs_UnpackTags2TagsPart(tags, pt2tp);
+		}
+	} else {
+		if (tags) {
+			memcpy(&pt, dev->spareBuffer, sizeof(pt));
+			yaffs_UnpackTags2(tags, &pt);
+		}
+	}
+
+	if (localData)
+		yaffs_ReleaseTempBuffer(dev, data, __LINE__);
+
+	if (tags && retval == -EBADMSG && tags->eccResult == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->eccResult = YAFFS_ECC_RESULT_UNFIXED;
+		dev->eccUnfixed++;
+	}
+	if (tags && retval == -EUCLEAN && tags->eccResult == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->eccResult = YAFFS_ECC_RESULT_FIXED;
+		dev->eccFixed++;
+	}
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd2_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+	int retval;
+	T(YAFFS_TRACE_MTD,
+	  (TSTR("nandmtd2_MarkNANDBlockBad %d" TENDSTR), blockNo));
+
+	retval =
+	    mtd->block_markbad(mtd,
+			       blockNo * dev->nChunksPerBlock *
+			       dev->totalBytesPerChunk);
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+
+}
+
+int nandmtd2_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+			    yaffs_BlockState *state, __u32 *sequenceNumber)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+	int retval;
+
+	T(YAFFS_TRACE_MTD,
+	  (TSTR("nandmtd2_QueryNANDBlock %d" TENDSTR), blockNo));
+	retval =
+	    mtd->block_isbad(mtd,
+			     blockNo * dev->nChunksPerBlock *
+			     dev->totalBytesPerChunk);
+
+	if (retval) {
+		T(YAFFS_TRACE_MTD, (TSTR("block is bad" TENDSTR)));
+
+		*state = YAFFS_BLOCK_STATE_DEAD;
+		*sequenceNumber = 0;
+	} else {
+		yaffs_ExtendedTags t;
+		nandmtd2_ReadChunkWithTagsFromNAND(dev,
+						   blockNo *
+						   dev->nChunksPerBlock, NULL,
+						   &t);
+
+		if (t.chunkUsed) {
+			*sequenceNumber = t.sequenceNumber;
+			*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+		} else {
+			*sequenceNumber = 0;
+			*state = YAFFS_BLOCK_STATE_EMPTY;
+		}
+	}
+	T(YAFFS_TRACE_MTD,
+	  (TSTR("block is bad seq %d state %d" TENDSTR), *sequenceNumber,
+	   *state));
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_mtdif2.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_mtdif2.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_mtdif2.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_mtdif2.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,29 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF2_H__
+#define __YAFFS_MTDIF2_H__
+
+#include "yaffs_guts.h"
+int nandmtd2_WriteChunkWithTagsToNAND(yaffs_Device *dev, int chunkInNAND,
+				const __u8 *data,
+				const yaffs_ExtendedTags *tags);
+int nandmtd2_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+				__u8 *data, yaffs_ExtendedTags *tags);
+int nandmtd2_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);
+int nandmtd2_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+			yaffs_BlockState *state, __u32 *sequenceNumber);
+
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_mtdif.c iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_mtdif.c
--- linux-2.6.32-orig/fs/yaffs2/yaffs_mtdif.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_mtdif.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,241 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+const char *yaffs_mtdif_c_version =
+	"$Id$";
+
+#include "yportenv.h"
+
+
+#include "yaffs_mtdif.h"
+
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+#include "linux/mtd/nand.h"
+
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 18))
+static struct nand_oobinfo yaffs_oobinfo = {
+	.useecc = 1,
+	.eccbytes = 6,
+	.eccpos = {8, 9, 10, 13, 14, 15}
+};
+
+static struct nand_oobinfo yaffs_noeccinfo = {
+	.useecc = 0,
+};
+#endif
+
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+static inline void translate_spare2oob(const yaffs_Spare *spare, __u8 *oob)
+{
+	oob[0] = spare->tagByte0;
+	oob[1] = spare->tagByte1;
+	oob[2] = spare->tagByte2;
+	oob[3] = spare->tagByte3;
+	oob[4] = spare->tagByte4;
+	oob[5] = spare->tagByte5 & 0x3f;
+	oob[5] |= spare->blockStatus == 'Y' ? 0 : 0x80;
+	oob[5] |= spare->pageStatus == 0 ? 0 : 0x40;
+	oob[6] = spare->tagByte6;
+	oob[7] = spare->tagByte7;
+}
+
+static inline void translate_oob2spare(yaffs_Spare *spare, __u8 *oob)
+{
+	struct yaffs_NANDSpare *nspare = (struct yaffs_NANDSpare *)spare;
+	spare->tagByte0 = oob[0];
+	spare->tagByte1 = oob[1];
+	spare->tagByte2 = oob[2];
+	spare->tagByte3 = oob[3];
+	spare->tagByte4 = oob[4];
+	spare->tagByte5 = oob[5] == 0xff ? 0xff : oob[5] & 0x3f;
+	spare->blockStatus = oob[5] & 0x80 ? 0xff : 'Y';
+	spare->pageStatus = oob[5] & 0x40 ? 0xff : 0;
+	spare->ecc1[0] = spare->ecc1[1] = spare->ecc1[2] = 0xff;
+	spare->tagByte6 = oob[6];
+	spare->tagByte7 = oob[7];
+	spare->ecc2[0] = spare->ecc2[1] = spare->ecc2[2] = 0xff;
+
+	nspare->eccres1 = nspare->eccres2 = 0; /* FIXME */
+}
+#endif
+
+int nandmtd_WriteChunkToNAND(yaffs_Device *dev, int chunkInNAND,
+			     const __u8 *data, const yaffs_Spare *spare)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#endif
+	size_t dummy;
+	int retval = 0;
+
+	loff_t addr = ((loff_t) chunkInNAND) * dev->nDataBytesPerChunk;
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	__u8 spareAsBytes[8]; /* OOB */
+
+	if (data && !spare)
+		retval = mtd->write(mtd, addr, dev->nDataBytesPerChunk,
+				&dummy, data);
+	else if (spare) {
+		if (dev->useNANDECC) {
+			translate_spare2oob(spare, spareAsBytes);
+			ops.mode = MTD_OOB_AUTO;
+			ops.ooblen = 8; /* temp hack */
+		} else {
+			ops.mode = MTD_OOB_RAW;
+			ops.ooblen = YAFFS_BYTES_PER_SPARE;
+		}
+		ops.len = data ? dev->nDataBytesPerChunk : ops.ooblen;
+		ops.datbuf = (u8 *)data;
+		ops.ooboffs = 0;
+		ops.oobbuf = spareAsBytes;
+		retval = mtd->write_oob(mtd, addr, &ops);
+	}
+#else
+	__u8 *spareAsBytes = (__u8 *) spare;
+
+	if (data && spare) {
+		if (dev->useNANDECC)
+			retval =
+			    mtd->write_ecc(mtd, addr, dev->nDataBytesPerChunk,
+					   &dummy, data, spareAsBytes,
+					   &yaffs_oobinfo);
+		else
+			retval =
+			    mtd->write_ecc(mtd, addr, dev->nDataBytesPerChunk,
+					   &dummy, data, spareAsBytes,
+					   &yaffs_noeccinfo);
+	} else {
+		if (data)
+			retval =
+			    mtd->write(mtd, addr, dev->nDataBytesPerChunk, &dummy,
+				       data);
+		if (spare)
+			retval =
+			    mtd->write_oob(mtd, addr, YAFFS_BYTES_PER_SPARE,
+					   &dummy, spareAsBytes);
+	}
+#endif
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd_ReadChunkFromNAND(yaffs_Device *dev, int chunkInNAND, __u8 *data,
+			      yaffs_Spare *spare)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#endif
+	size_t dummy;
+	int retval = 0;
+
+	loff_t addr = ((loff_t) chunkInNAND) * dev->nDataBytesPerChunk;
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	__u8 spareAsBytes[8]; /* OOB */
+
+	if (data && !spare)
+		retval = mtd->read(mtd, addr, dev->nDataBytesPerChunk,
+				&dummy, data);
+	else if (spare) {
+		if (dev->useNANDECC) {
+			ops.mode = MTD_OOB_AUTO;
+			ops.ooblen = 8; /* temp hack */
+		} else {
+			ops.mode = MTD_OOB_RAW;
+			ops.ooblen = YAFFS_BYTES_PER_SPARE;
+		}
+		ops.len = data ? dev->nDataBytesPerChunk : ops.ooblen;
+		ops.datbuf = data;
+		ops.ooboffs = 0;
+		ops.oobbuf = spareAsBytes;
+		retval = mtd->read_oob(mtd, addr, &ops);
+		if (dev->useNANDECC)
+			translate_oob2spare(spare, spareAsBytes);
+	}
+#else
+	__u8 *spareAsBytes = (__u8 *) spare;
+
+	if (data && spare) {
+		if (dev->useNANDECC) {
+			/* Careful, this call adds 2 ints */
+			/* to the end of the spare data.  Calling function */
+			/* should allocate enough memory for spare, */
+			/* i.e. [YAFFS_BYTES_PER_SPARE+2*sizeof(int)]. */
+			retval =
+			    mtd->read_ecc(mtd, addr, dev->nDataBytesPerChunk,
+					  &dummy, data, spareAsBytes,
+					  &yaffs_oobinfo);
+		} else {
+			retval =
+			    mtd->read_ecc(mtd, addr, dev->nDataBytesPerChunk,
+					  &dummy, data, spareAsBytes,
+					  &yaffs_noeccinfo);
+		}
+	} else {
+		if (data)
+			retval =
+			    mtd->read(mtd, addr, dev->nDataBytesPerChunk, &dummy,
+				      data);
+		if (spare)
+			retval =
+			    mtd->read_oob(mtd, addr, YAFFS_BYTES_PER_SPARE,
+					  &dummy, spareAsBytes);
+	}
+#endif
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd_EraseBlockInNAND(yaffs_Device *dev, int blockNumber)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+	__u32 addr =
+	    ((loff_t) blockNumber) * dev->nDataBytesPerChunk
+		* dev->nChunksPerBlock;
+	struct erase_info ei;
+	int retval = 0;
+
+	ei.mtd = mtd;
+	ei.addr = addr;
+	ei.len = dev->nDataBytesPerChunk * dev->nChunksPerBlock;
+	ei.time = 1000;
+	ei.retries = 2;
+	ei.callback = NULL;
+	ei.priv = (u_long) dev;
+
+	/* Todo finish off the ei if required */
+
+	sema_init(&dev->sem, 0);
+
+	retval = mtd->erase(mtd, &ei);
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd_InitialiseNAND(yaffs_Device *dev)
+{
+	return YAFFS_OK;
+}
+
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_mtdif.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_mtdif.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_mtdif.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_mtdif.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,32 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF_H__
+#define __YAFFS_MTDIF_H__
+
+#include "yaffs_guts.h"
+
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 18))
+extern struct nand_oobinfo yaffs_oobinfo;
+extern struct nand_oobinfo yaffs_noeccinfo;
+#endif
+
+int nandmtd_WriteChunkToNAND(yaffs_Device *dev, int chunkInNAND,
+			const __u8 *data, const yaffs_Spare *spare);
+int nandmtd_ReadChunkFromNAND(yaffs_Device *dev, int chunkInNAND, __u8 *data,
+			yaffs_Spare *spare);
+int nandmtd_EraseBlockInNAND(yaffs_Device *dev, int blockNumber);
+int nandmtd_InitialiseNAND(yaffs_Device *dev);
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_nand.c iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_nand.c
--- linux-2.6.32-orig/fs/yaffs2/yaffs_nand.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_nand.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,140 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+const char *yaffs_nand_c_version =
+	"$Id$";
+
+#include "yaffs_nand.h"
+#include "yaffs_tagscompat.h"
+#include "yaffs_tagsvalidity.h"
+
+#include "yaffs_getblockinfo.h"
+
+int yaffs_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+					   __u8 *buffer,
+					   yaffs_ExtendedTags *tags)
+{
+	int result;
+	yaffs_ExtendedTags localTags;
+
+	int realignedChunkInNAND = chunkInNAND - dev->chunkOffset;
+
+	dev->nPageReads++;
+
+	/* If there are no tags provided, use local tags to get prioritised gc working */
+	if (!tags)
+		tags = &localTags;
+
+	if (dev->readChunkWithTagsFromNAND)
+		result = dev->readChunkWithTagsFromNAND(dev, realignedChunkInNAND, buffer,
+						      tags);
+	else
+		result = yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(dev,
+									realignedChunkInNAND,
+									buffer,
+									tags);
+	if (tags &&
+	   tags->eccResult > YAFFS_ECC_RESULT_NO_ERROR) {
+
+		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, chunkInNAND/dev->nChunksPerBlock);
+		yaffs_HandleChunkError(dev, bi);
+	}
+
+	return result;
+}
+
+int yaffs_WriteChunkWithTagsToNAND(yaffs_Device *dev,
+						   int chunkInNAND,
+						   const __u8 *buffer,
+						   yaffs_ExtendedTags *tags)
+{
+
+	dev->nPageWrites++;
+
+	chunkInNAND -= dev->chunkOffset;
+
+
+	if (tags) {
+		tags->sequenceNumber = dev->sequenceNumber;
+		tags->chunkUsed = 1;
+		if (!yaffs_ValidateTags(tags)) {
+			T(YAFFS_TRACE_ERROR,
+			  (TSTR("Writing uninitialised tags" TENDSTR)));
+			YBUG();
+		}
+		T(YAFFS_TRACE_WRITE,
+		  (TSTR("Writing chunk %d tags %d %d" TENDSTR), chunkInNAND,
+		   tags->objectId, tags->chunkId));
+	} else {
+		T(YAFFS_TRACE_ERROR, (TSTR("Writing with no tags" TENDSTR)));
+		YBUG();
+	}
+
+	if (dev->writeChunkWithTagsToNAND)
+		return dev->writeChunkWithTagsToNAND(dev, chunkInNAND, buffer,
+						     tags);
+	else
+		return yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(dev,
+								       chunkInNAND,
+								       buffer,
+								       tags);
+}
+
+int yaffs_MarkBlockBad(yaffs_Device *dev, int blockNo)
+{
+	blockNo -= dev->blockOffset;
+
+
+	if (dev->markNANDBlockBad)
+		return dev->markNANDBlockBad(dev, blockNo);
+	else
+		return yaffs_TagsCompatabilityMarkNANDBlockBad(dev, blockNo);
+}
+
+int yaffs_QueryInitialBlockState(yaffs_Device *dev,
+						 int blockNo,
+						 yaffs_BlockState *state,
+						 __u32 *sequenceNumber)
+{
+	blockNo -= dev->blockOffset;
+
+	if (dev->queryNANDBlock)
+		return dev->queryNANDBlock(dev, blockNo, state, sequenceNumber);
+	else
+		return yaffs_TagsCompatabilityQueryNANDBlock(dev, blockNo,
+							     state,
+							     sequenceNumber);
+}
+
+
+int yaffs_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,
+				  int blockInNAND)
+{
+	int result;
+
+	blockInNAND -= dev->blockOffset;
+
+	dev->nBlockErasures++;
+
+	result = dev->eraseBlockInNAND(dev, blockInNAND);
+
+	return result;
+}
+
+int yaffs_InitialiseNAND(struct yaffs_DeviceStruct *dev)
+{
+	return dev->initialiseNAND(dev);
+}
+
+
+
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_nandemul2k.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_nandemul2k.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_nandemul2k.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_nandemul2k.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* Interface to emulated NAND functions (2k page size) */
+
+#ifndef __YAFFS_NANDEMUL2K_H__
+#define __YAFFS_NANDEMUL2K_H__
+
+#include "yaffs_guts.h"
+
+int nandemul2k_WriteChunkWithTagsToNAND(struct yaffs_DeviceStruct *dev,
+					int chunkInNAND, const __u8 *data,
+					const yaffs_ExtendedTags *tags);
+int nandemul2k_ReadChunkWithTagsFromNAND(struct yaffs_DeviceStruct *dev,
+					 int chunkInNAND, __u8 *data,
+					 yaffs_ExtendedTags *tags);
+int nandemul2k_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);
+int nandemul2k_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+			      yaffs_BlockState *state, __u32 *sequenceNumber);
+int nandemul2k_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,
+				int blockInNAND);
+int nandemul2k_InitialiseNAND(struct yaffs_DeviceStruct *dev);
+int nandemul2k_GetBytesPerChunk(void);
+int nandemul2k_GetChunksPerBlock(void);
+int nandemul2k_GetNumberOfBlocks(void);
+
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_nand.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_nand.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_nand.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_nand.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,44 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_NAND_H__
+#define __YAFFS_NAND_H__
+#include "yaffs_guts.h"
+
+
+
+int yaffs_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+					__u8 *buffer,
+					yaffs_ExtendedTags *tags);
+
+int yaffs_WriteChunkWithTagsToNAND(yaffs_Device *dev,
+						int chunkInNAND,
+						const __u8 *buffer,
+						yaffs_ExtendedTags *tags);
+
+int yaffs_MarkBlockBad(yaffs_Device *dev, int blockNo);
+
+int yaffs_QueryInitialBlockState(yaffs_Device *dev,
+						int blockNo,
+						yaffs_BlockState *state,
+						unsigned *sequenceNumber);
+
+int yaffs_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,
+				  int blockInNAND);
+
+int yaffs_InitialiseNAND(struct yaffs_DeviceStruct *dev);
+
+#endif
+
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_packedtags1.c iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_packedtags1.c
--- linux-2.6.32-orig/fs/yaffs2/yaffs_packedtags1.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_packedtags1.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,50 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_packedtags1.h"
+#include "yportenv.h"
+
+void yaffs_PackTags1(yaffs_PackedTags1 *pt, const yaffs_ExtendedTags *t)
+{
+	pt->chunkId = t->chunkId;
+	pt->serialNumber = t->serialNumber;
+	pt->byteCount = t->byteCount;
+	pt->objectId = t->objectId;
+	pt->ecc = 0;
+	pt->deleted = (t->chunkDeleted) ? 0 : 1;
+	pt->unusedStuff = 0;
+	pt->shouldBeFF = 0xFFFFFFFF;
+
+}
+
+void yaffs_UnpackTags1(yaffs_ExtendedTags *t, const yaffs_PackedTags1 *pt)
+{
+	static const __u8 allFF[] =
+	    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff };
+
+	if (memcmp(allFF, pt, sizeof(yaffs_PackedTags1))) {
+		t->blockBad = 0;
+		if (pt->shouldBeFF != 0xFFFFFFFF)
+			t->blockBad = 1;
+		t->chunkUsed = 1;
+		t->objectId = pt->objectId;
+		t->chunkId = pt->chunkId;
+		t->byteCount = pt->byteCount;
+		t->eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+		t->chunkDeleted = (pt->deleted) ? 0 : 1;
+		t->serialNumber = pt->serialNumber;
+	} else {
+		memset(t, 0, sizeof(yaffs_ExtendedTags));
+	}
+}
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_packedtags1.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_packedtags1.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_packedtags1.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_packedtags1.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,37 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* This is used to pack YAFFS1 tags, not YAFFS2 tags. */
+
+#ifndef __YAFFS_PACKEDTAGS1_H__
+#define __YAFFS_PACKEDTAGS1_H__
+
+#include "yaffs_guts.h"
+
+typedef struct {
+	unsigned chunkId:20;
+	unsigned serialNumber:2;
+	unsigned byteCount:10;
+	unsigned objectId:18;
+	unsigned ecc:12;
+	unsigned deleted:1;
+	unsigned unusedStuff:1;
+	unsigned shouldBeFF;
+
+} yaffs_PackedTags1;
+
+void yaffs_PackTags1(yaffs_PackedTags1 *pt, const yaffs_ExtendedTags *t);
+void yaffs_UnpackTags1(yaffs_ExtendedTags *t, const yaffs_PackedTags1 *pt);
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_packedtags2.c iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_packedtags2.c
--- linux-2.6.32-orig/fs/yaffs2/yaffs_packedtags2.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_packedtags2.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,209 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_packedtags2.h"
+#include "yportenv.h"
+#include "yaffs_tagsvalidity.h"
+
+/* This code packs a set of extended tags into a binary structure for
+ * NAND storage
+ */
+
+/* Some of the information is "extra" struff which can be packed in to
+ * speed scanning
+ * This is defined by having the EXTRA_HEADER_INFO_FLAG set.
+ */
+
+/* Extra flags applied to chunkId */
+
+#define EXTRA_HEADER_INFO_FLAG	0x80000000
+#define EXTRA_SHRINK_FLAG	0x40000000
+#define EXTRA_SHADOWS_FLAG	0x20000000
+#define EXTRA_SPARE_FLAGS	0x10000000
+
+#define ALL_EXTRA_FLAGS		0xF0000000
+
+/* Also, the top 4 bits of the object Id are set to the object type. */
+#define EXTRA_OBJECT_TYPE_SHIFT (28)
+#define EXTRA_OBJECT_TYPE_MASK  ((0x0F) << EXTRA_OBJECT_TYPE_SHIFT)
+
+#ifndef CONFIG_YAFFS_DOES_ECC
+#define YAFFS_IGNORE_TAGS_ECC 1
+#endif
+
+static void yaffs_DumpPackedTags2TagsPart(const yaffs_PackedTags2TagsPart *ptt)
+{
+	T(YAFFS_TRACE_MTD,
+	  (TSTR("packed tags obj %d chunk %d byte %d seq %d" TENDSTR),
+	   ptt->objectId, ptt->chunkId, ptt->byteCount,
+	   ptt->sequenceNumber));
+}
+static void yaffs_DumpPackedTags2(const yaffs_PackedTags2 *pt)
+{
+	yaffs_DumpPackedTags2TagsPart(&pt->t);
+}
+
+static void yaffs_DumpTags2(const yaffs_ExtendedTags *t)
+{
+	T(YAFFS_TRACE_MTD,
+	  (TSTR
+	   ("ext.tags eccres %d blkbad %d chused %d obj %d chunk%d byte %d del %d ser %d seq %d"
+	    TENDSTR), t->eccResult, t->blockBad, t->chunkUsed, t->objectId,
+	   t->chunkId, t->byteCount, t->chunkDeleted, t->serialNumber,
+	   t->sequenceNumber));
+
+}
+
+void yaffs_PackTags2TagsPart(yaffs_PackedTags2TagsPart *ptt,
+		const yaffs_ExtendedTags *t)
+{
+	ptt->chunkId = t->chunkId;
+	ptt->sequenceNumber = t->sequenceNumber;
+	ptt->byteCount = t->byteCount;
+	ptt->objectId = t->objectId;
+
+	if (t->chunkId == 0 && t->extraHeaderInfoAvailable) {
+		/* Store the extra header info instead */
+		/* We save the parent object in the chunkId */
+		ptt->chunkId = EXTRA_HEADER_INFO_FLAG
+			| t->extraParentObjectId;
+		if (t->extraIsShrinkHeader)
+			ptt->chunkId |= EXTRA_SHRINK_FLAG;
+		if (t->extraShadows)
+			ptt->chunkId |= EXTRA_SHADOWS_FLAG;
+
+		ptt->objectId &= ~EXTRA_OBJECT_TYPE_MASK;
+		ptt->objectId |=
+		    (t->extraObjectType << EXTRA_OBJECT_TYPE_SHIFT);
+
+		if (t->extraObjectType == YAFFS_OBJECT_TYPE_HARDLINK)
+			ptt->byteCount = t->extraEquivalentObjectId;
+		else if (t->extraObjectType == YAFFS_OBJECT_TYPE_FILE)
+			ptt->byteCount = t->extraFileLength;
+		else
+			ptt->byteCount = 0;
+	}
+
+	yaffs_DumpPackedTags2TagsPart(ptt);
+	yaffs_DumpTags2(t);
+}
+
+
+void yaffs_PackTags2(yaffs_PackedTags2 *pt, const yaffs_ExtendedTags *t)
+{
+	yaffs_PackTags2TagsPart(&pt->t, t);
+
+#ifndef YAFFS_IGNORE_TAGS_ECC
+	{
+		yaffs_ECCCalculateOther((unsigned char *)&pt->t,
+					sizeof(yaffs_PackedTags2TagsPart),
+					&pt->ecc);
+	}
+#endif
+}
+
+
+void yaffs_UnpackTags2TagsPart(yaffs_ExtendedTags *t,
+		yaffs_PackedTags2TagsPart *ptt)
+{
+
+	memset(t, 0, sizeof(yaffs_ExtendedTags));
+
+	yaffs_InitialiseTags(t);
+
+	if (ptt->sequenceNumber != 0xFFFFFFFF) {
+		t->blockBad = 0;
+		t->chunkUsed = 1;
+		t->objectId = ptt->objectId;
+		t->chunkId = ptt->chunkId;
+		t->byteCount = ptt->byteCount;
+		t->chunkDeleted = 0;
+		t->serialNumber = 0;
+		t->sequenceNumber = ptt->sequenceNumber;
+
+		/* Do extra header info stuff */
+
+		if (ptt->chunkId & EXTRA_HEADER_INFO_FLAG) {
+			t->chunkId = 0;
+			t->byteCount = 0;
+
+			t->extraHeaderInfoAvailable = 1;
+			t->extraParentObjectId =
+			    ptt->chunkId & (~(ALL_EXTRA_FLAGS));
+			t->extraIsShrinkHeader =
+			    (ptt->chunkId & EXTRA_SHRINK_FLAG) ? 1 : 0;
+			t->extraShadows =
+			    (ptt->chunkId & EXTRA_SHADOWS_FLAG) ? 1 : 0;
+			t->extraObjectType =
+			    ptt->objectId >> EXTRA_OBJECT_TYPE_SHIFT;
+			t->objectId &= ~EXTRA_OBJECT_TYPE_MASK;
+
+			if (t->extraObjectType == YAFFS_OBJECT_TYPE_HARDLINK)
+				t->extraEquivalentObjectId = ptt->byteCount;
+			else
+				t->extraFileLength = ptt->byteCount;
+		}
+	}
+
+	yaffs_DumpPackedTags2TagsPart(ptt);
+	yaffs_DumpTags2(t);
+
+}
+
+
+void yaffs_UnpackTags2(yaffs_ExtendedTags *t, yaffs_PackedTags2 *pt)
+{
+
+	yaffs_ECCResult eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+
+	if (pt->t.sequenceNumber != 0xFFFFFFFF) {
+		/* Page is in use */
+#ifndef YAFFS_IGNORE_TAGS_ECC
+		{
+			yaffs_ECCOther ecc;
+			int result;
+			yaffs_ECCCalculateOther((unsigned char *)&pt->t,
+						sizeof
+						(yaffs_PackedTags2TagsPart),
+						&ecc);
+			result =
+			    yaffs_ECCCorrectOther((unsigned char *)&pt->t,
+						  sizeof
+						  (yaffs_PackedTags2TagsPart),
+						  &pt->ecc, &ecc);
+			switch (result) {
+			case 0:
+				eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+				break;
+			case 1:
+				eccResult = YAFFS_ECC_RESULT_FIXED;
+				break;
+			case -1:
+				eccResult = YAFFS_ECC_RESULT_UNFIXED;
+				break;
+			default:
+				eccResult = YAFFS_ECC_RESULT_UNKNOWN;
+			}
+		}
+#endif
+	}
+
+	yaffs_UnpackTags2TagsPart(t, &pt->t);
+
+	t->eccResult = eccResult;
+
+	yaffs_DumpPackedTags2(pt);
+	yaffs_DumpTags2(t);
+
+}
+
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_packedtags2.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_packedtags2.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_packedtags2.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_packedtags2.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,43 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* This is used to pack YAFFS2 tags, not YAFFS1tags. */
+
+#ifndef __YAFFS_PACKEDTAGS2_H__
+#define __YAFFS_PACKEDTAGS2_H__
+
+#include "yaffs_guts.h"
+#include "yaffs_ecc.h"
+
+typedef struct {
+	unsigned sequenceNumber;
+	unsigned objectId;
+	unsigned chunkId;
+	unsigned byteCount;
+} yaffs_PackedTags2TagsPart;
+
+typedef struct {
+	yaffs_PackedTags2TagsPart t;
+	yaffs_ECCOther ecc;
+} yaffs_PackedTags2;
+
+/* Full packed tags with ECC, used for oob tags */
+void yaffs_PackTags2(yaffs_PackedTags2 *pt, const yaffs_ExtendedTags *t);
+void yaffs_UnpackTags2(yaffs_ExtendedTags *t, yaffs_PackedTags2 *pt);
+
+/* Only the tags part (no ECC for use with inband tags */
+void yaffs_PackTags2TagsPart(yaffs_PackedTags2TagsPart *pt, const yaffs_ExtendedTags *t);
+void yaffs_UnpackTags2TagsPart(yaffs_ExtendedTags *t, yaffs_PackedTags2TagsPart *pt);
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_qsort.c iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_qsort.c
--- linux-2.6.32-orig/fs/yaffs2/yaffs_qsort.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_qsort.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,163 @@
+/*
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "yportenv.h"
+/* #include <linux/string.h> */
+
+/*
+ * Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".
+ */
+#define swapcode(TYPE, parmi, parmj, n) do { 		\
+	long i = (n) / sizeof (TYPE); 			\
+	register TYPE *pi = (TYPE *) (parmi); 		\
+	register TYPE *pj = (TYPE *) (parmj); 		\
+	do { 						\
+		register TYPE	t = *pi;		\
+		*pi++ = *pj;				\
+		*pj++ = t;				\
+	} while (--i > 0);				\
+} while (0)
+
+#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
+	es % sizeof(long) ? 2 : es == sizeof(long) ? 0 : 1;
+
+static __inline void
+swapfunc(char *a, char *b, int n, int swaptype)
+{
+	if (swaptype <= 1)
+		swapcode(long, a, b, n);
+	else
+		swapcode(char, a, b, n);
+}
+
+#define yswap(a, b) do {					\
+	if (swaptype == 0) {				\
+		long t = *(long *)(a);			\
+		*(long *)(a) = *(long *)(b);		\
+		*(long *)(b) = t;			\
+	} else						\
+		swapfunc(a, b, es, swaptype);		\
+} while (0)
+
+#define vecswap(a, b, n) 	if ((n) > 0) swapfunc(a, b, n, swaptype)
+
+static __inline char *
+med3(char *a, char *b, char *c, int (*cmp)(const void *, const void *))
+{
+	return cmp(a, b) < 0 ?
+		(cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a))
+		: (cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c));
+}
+
+#ifndef min
+#define min(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+
+void
+yaffs_qsort(void *aa, size_t n, size_t es,
+	int (*cmp)(const void *, const void *))
+{
+	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
+	int d, r, swaptype, swap_cnt;
+	register char *a = aa;
+
+loop:	SWAPINIT(a, es);
+	swap_cnt = 0;
+	if (n < 7) {
+		for (pm = (char *)a + es; pm < (char *) a + n * es; pm += es)
+			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
+			     pl -= es)
+				yswap(pl, pl - es);
+		return;
+	}
+	pm = (char *)a + (n / 2) * es;
+	if (n > 7) {
+		pl = (char *)a;
+		pn = (char *)a + (n - 1) * es;
+		if (n > 40) {
+			d = (n / 8) * es;
+			pl = med3(pl, pl + d, pl + 2 * d, cmp);
+			pm = med3(pm - d, pm, pm + d, cmp);
+			pn = med3(pn - 2 * d, pn - d, pn, cmp);
+		}
+		pm = med3(pl, pm, pn, cmp);
+	}
+	yswap(a, pm);
+	pa = pb = (char *)a + es;
+
+	pc = pd = (char *)a + (n - 1) * es;
+	for (;;) {
+		while (pb <= pc && (r = cmp(pb, a)) <= 0) {
+			if (r == 0) {
+				swap_cnt = 1;
+				yswap(pa, pb);
+				pa += es;
+			}
+			pb += es;
+		}
+		while (pb <= pc && (r = cmp(pc, a)) >= 0) {
+			if (r == 0) {
+				swap_cnt = 1;
+				yswap(pc, pd);
+				pd -= es;
+			}
+			pc -= es;
+		}
+		if (pb > pc)
+			break;
+		yswap(pb, pc);
+		swap_cnt = 1;
+		pb += es;
+		pc -= es;
+	}
+	if (swap_cnt == 0) {  /* Switch to insertion sort */
+		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
+			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
+			     pl -= es)
+				yswap(pl, pl - es);
+		return;
+	}
+
+	pn = (char *)a + n * es;
+	r = min(pa - (char *)a, pb - pa);
+	vecswap(a, pb - r, r);
+	r = min((long)(pd - pc), (long)(pn - pd - es));
+	vecswap(pb, pn - r, r);
+	r = pb - pa;
+	if (r > es)
+		yaffs_qsort(a, r / es, es, cmp);
+	r = pd - pc;
+	if (r > es) {
+		/* Iterate rather than recurse to save stack space */
+		a = pn - r;
+		n = r / es;
+		goto loop;
+	}
+/*		yaffs_qsort(pn - r, r / es, es, cmp);*/
+}
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_qsort.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_qsort.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_qsort.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_qsort.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,23 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+
+#ifndef __YAFFS_QSORT_H__
+#define __YAFFS_QSORT_H__
+
+extern void yaffs_qsort(void *const base, size_t total_elems, size_t size,
+			int (*cmp)(const void *, const void *));
+
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_tagscompat.c iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_tagscompat.c
--- linux-2.6.32-orig/fs/yaffs2/yaffs_tagscompat.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_tagscompat.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,538 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_tagscompat.h"
+#include "yaffs_ecc.h"
+#include "yaffs_getblockinfo.h"
+
+static void yaffs_HandleReadDataError(yaffs_Device *dev, int chunkInNAND);
+#ifdef NOTYET
+static void yaffs_CheckWrittenBlock(yaffs_Device *dev, int chunkInNAND);
+static void yaffs_HandleWriteChunkOk(yaffs_Device *dev, int chunkInNAND,
+				     const __u8 *data,
+				     const yaffs_Spare *spare);
+static void yaffs_HandleUpdateChunk(yaffs_Device *dev, int chunkInNAND,
+				    const yaffs_Spare *spare);
+static void yaffs_HandleWriteChunkError(yaffs_Device *dev, int chunkInNAND);
+#endif
+
+static const char yaffs_countBitsTable[256] = {
+	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
+	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
+};
+
+int yaffs_CountBits(__u8 x)
+{
+	int retVal;
+	retVal = yaffs_countBitsTable[x];
+	return retVal;
+}
+
+/********** Tags ECC calculations  *********/
+
+void yaffs_CalcECC(const __u8 *data, yaffs_Spare *spare)
+{
+	yaffs_ECCCalculate(data, spare->ecc1);
+	yaffs_ECCCalculate(&data[256], spare->ecc2);
+}
+
+void yaffs_CalcTagsECC(yaffs_Tags *tags)
+{
+	/* Calculate an ecc */
+
+	unsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;
+	unsigned i, j;
+	unsigned ecc = 0;
+	unsigned bit = 0;
+
+	tags->ecc = 0;
+
+	for (i = 0; i < 8; i++) {
+		for (j = 1; j & 0xff; j <<= 1) {
+			bit++;
+			if (b[i] & j)
+				ecc ^= bit;
+		}
+	}
+
+	tags->ecc = ecc;
+
+}
+
+int yaffs_CheckECCOnTags(yaffs_Tags *tags)
+{
+	unsigned ecc = tags->ecc;
+
+	yaffs_CalcTagsECC(tags);
+
+	ecc ^= tags->ecc;
+
+	if (ecc && ecc <= 64) {
+		/* TODO: Handle the failure better. Retire? */
+		unsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;
+
+		ecc--;
+
+		b[ecc / 8] ^= (1 << (ecc & 7));
+
+		/* Now recvalc the ecc */
+		yaffs_CalcTagsECC(tags);
+
+		return 1;	/* recovered error */
+	} else if (ecc) {
+		/* Wierd ecc failure value */
+		/* TODO Need to do somethiong here */
+		return -1;	/* unrecovered error */
+	}
+
+	return 0;
+}
+
+/********** Tags **********/
+
+static void yaffs_LoadTagsIntoSpare(yaffs_Spare *sparePtr,
+				yaffs_Tags *tagsPtr)
+{
+	yaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;
+
+	yaffs_CalcTagsECC(tagsPtr);
+
+	sparePtr->tagByte0 = tu->asBytes[0];
+	sparePtr->tagByte1 = tu->asBytes[1];
+	sparePtr->tagByte2 = tu->asBytes[2];
+	sparePtr->tagByte3 = tu->asBytes[3];
+	sparePtr->tagByte4 = tu->asBytes[4];
+	sparePtr->tagByte5 = tu->asBytes[5];
+	sparePtr->tagByte6 = tu->asBytes[6];
+	sparePtr->tagByte7 = tu->asBytes[7];
+}
+
+static void yaffs_GetTagsFromSpare(yaffs_Device *dev, yaffs_Spare *sparePtr,
+				yaffs_Tags *tagsPtr)
+{
+	yaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;
+	int result;
+
+	tu->asBytes[0] = sparePtr->tagByte0;
+	tu->asBytes[1] = sparePtr->tagByte1;
+	tu->asBytes[2] = sparePtr->tagByte2;
+	tu->asBytes[3] = sparePtr->tagByte3;
+	tu->asBytes[4] = sparePtr->tagByte4;
+	tu->asBytes[5] = sparePtr->tagByte5;
+	tu->asBytes[6] = sparePtr->tagByte6;
+	tu->asBytes[7] = sparePtr->tagByte7;
+
+	result = yaffs_CheckECCOnTags(tagsPtr);
+	if (result > 0)
+		dev->tagsEccFixed++;
+	else if (result < 0)
+		dev->tagsEccUnfixed++;
+}
+
+static void yaffs_SpareInitialise(yaffs_Spare *spare)
+{
+	memset(spare, 0xFF, sizeof(yaffs_Spare));
+}
+
+static int yaffs_WriteChunkToNAND(struct yaffs_DeviceStruct *dev,
+				int chunkInNAND, const __u8 *data,
+				yaffs_Spare *spare)
+{
+	if (chunkInNAND < dev->startBlock * dev->nChunksPerBlock) {
+		T(YAFFS_TRACE_ERROR,
+		  (TSTR("**>> yaffs chunk %d is not valid" TENDSTR),
+		   chunkInNAND));
+		return YAFFS_FAIL;
+	}
+
+	return dev->writeChunkToNAND(dev, chunkInNAND, data, spare);
+}
+
+static int yaffs_ReadChunkFromNAND(struct yaffs_DeviceStruct *dev,
+				   int chunkInNAND,
+				   __u8 *data,
+				   yaffs_Spare *spare,
+				   yaffs_ECCResult *eccResult,
+				   int doErrorCorrection)
+{
+	int retVal;
+	yaffs_Spare localSpare;
+
+	if (!spare && data) {
+		/* If we don't have a real spare, then we use a local one. */
+		/* Need this for the calculation of the ecc */
+		spare = &localSpare;
+	}
+
+	if (!dev->useNANDECC) {
+		retVal = dev->readChunkFromNAND(dev, chunkInNAND, data, spare);
+		if (data && doErrorCorrection) {
+			/* Do ECC correction */
+			/* Todo handle any errors */
+			int eccResult1, eccResult2;
+			__u8 calcEcc[3];
+
+			yaffs_ECCCalculate(data, calcEcc);
+			eccResult1 =
+			    yaffs_ECCCorrect(data, spare->ecc1, calcEcc);
+			yaffs_ECCCalculate(&data[256], calcEcc);
+			eccResult2 =
+			    yaffs_ECCCorrect(&data[256], spare->ecc2, calcEcc);
+
+			if (eccResult1 > 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>yaffs ecc error fix performed on chunk %d:0"
+				    TENDSTR), chunkInNAND));
+				dev->eccFixed++;
+			} else if (eccResult1 < 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>yaffs ecc error unfixed on chunk %d:0"
+				    TENDSTR), chunkInNAND));
+				dev->eccUnfixed++;
+			}
+
+			if (eccResult2 > 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>yaffs ecc error fix performed on chunk %d:1"
+				    TENDSTR), chunkInNAND));
+				dev->eccFixed++;
+			} else if (eccResult2 < 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>yaffs ecc error unfixed on chunk %d:1"
+				    TENDSTR), chunkInNAND));
+				dev->eccUnfixed++;
+			}
+
+			if (eccResult1 || eccResult2) {
+				/* We had a data problem on this page */
+				yaffs_HandleReadDataError(dev, chunkInNAND);
+			}
+
+			if (eccResult1 < 0 || eccResult2 < 0)
+				*eccResult = YAFFS_ECC_RESULT_UNFIXED;
+			else if (eccResult1 > 0 || eccResult2 > 0)
+				*eccResult = YAFFS_ECC_RESULT_FIXED;
+			else
+				*eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+		}
+	} else {
+		/* Must allocate enough memory for spare+2*sizeof(int) */
+		/* for ecc results from device. */
+		struct yaffs_NANDSpare nspare;
+
+		memset(&nspare, 0, sizeof(nspare));
+
+		retVal = dev->readChunkFromNAND(dev, chunkInNAND, data,
+					(yaffs_Spare *) &nspare);
+		memcpy(spare, &nspare, sizeof(yaffs_Spare));
+		if (data && doErrorCorrection) {
+			if (nspare.eccres1 > 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>mtd ecc error fix performed on chunk %d:0"
+				    TENDSTR), chunkInNAND));
+			} else if (nspare.eccres1 < 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>mtd ecc error unfixed on chunk %d:0"
+				    TENDSTR), chunkInNAND));
+			}
+
+			if (nspare.eccres2 > 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>mtd ecc error fix performed on chunk %d:1"
+				    TENDSTR), chunkInNAND));
+			} else if (nspare.eccres2 < 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>mtd ecc error unfixed on chunk %d:1"
+				    TENDSTR), chunkInNAND));
+			}
+
+			if (nspare.eccres1 || nspare.eccres2) {
+				/* We had a data problem on this page */
+				yaffs_HandleReadDataError(dev, chunkInNAND);
+			}
+
+			if (nspare.eccres1 < 0 || nspare.eccres2 < 0)
+				*eccResult = YAFFS_ECC_RESULT_UNFIXED;
+			else if (nspare.eccres1 > 0 || nspare.eccres2 > 0)
+				*eccResult = YAFFS_ECC_RESULT_FIXED;
+			else
+				*eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+
+		}
+	}
+	return retVal;
+}
+
+#ifdef NOTYET
+static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,
+				  int chunkInNAND)
+{
+	static int init;
+	static __u8 cmpbuf[YAFFS_BYTES_PER_CHUNK];
+	static __u8 data[YAFFS_BYTES_PER_CHUNK];
+	/* Might as well always allocate the larger size for */
+	/* dev->useNANDECC == true; */
+	static __u8 spare[sizeof(struct yaffs_NANDSpare)];
+
+	dev->readChunkFromNAND(dev, chunkInNAND, data, (yaffs_Spare *) spare);
+
+	if (!init) {
+		memset(cmpbuf, 0xff, YAFFS_BYTES_PER_CHUNK);
+		init = 1;
+	}
+
+	if (memcmp(cmpbuf, data, YAFFS_BYTES_PER_CHUNK))
+		return YAFFS_FAIL;
+	if (memcmp(cmpbuf, spare, 16))
+		return YAFFS_FAIL;
+
+	return YAFFS_OK;
+
+}
+#endif
+
+/*
+ * Functions for robustisizing
+ */
+
+static void yaffs_HandleReadDataError(yaffs_Device *dev, int chunkInNAND)
+{
+	int blockInNAND = chunkInNAND / dev->nChunksPerBlock;
+
+	/* Mark the block for retirement */
+	yaffs_GetBlockInfo(dev, blockInNAND + dev->blockOffset)->needsRetiring = 1;
+	T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+	  (TSTR("**>>Block %d marked for retirement" TENDSTR), blockInNAND));
+
+	/* TODO:
+	 * Just do a garbage collection on the affected block
+	 * then retire the block
+	 * NB recursion
+	 */
+}
+
+#ifdef NOTYET
+static void yaffs_CheckWrittenBlock(yaffs_Device *dev, int chunkInNAND)
+{
+}
+
+static void yaffs_HandleWriteChunkOk(yaffs_Device *dev, int chunkInNAND,
+				     const __u8 *data,
+				     const yaffs_Spare *spare)
+{
+}
+
+static void yaffs_HandleUpdateChunk(yaffs_Device *dev, int chunkInNAND,
+				    const yaffs_Spare *spare)
+{
+}
+
+static void yaffs_HandleWriteChunkError(yaffs_Device *dev, int chunkInNAND)
+{
+	int blockInNAND = chunkInNAND / dev->nChunksPerBlock;
+
+	/* Mark the block for retirement */
+	yaffs_GetBlockInfo(dev, blockInNAND)->needsRetiring = 1;
+	/* Delete the chunk */
+	yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
+}
+
+static int yaffs_VerifyCompare(const __u8 *d0, const __u8 *d1,
+			       const yaffs_Spare *s0, const yaffs_Spare *s1)
+{
+
+	if (memcmp(d0, d1, YAFFS_BYTES_PER_CHUNK) != 0 ||
+	    s0->tagByte0 != s1->tagByte0 ||
+	    s0->tagByte1 != s1->tagByte1 ||
+	    s0->tagByte2 != s1->tagByte2 ||
+	    s0->tagByte3 != s1->tagByte3 ||
+	    s0->tagByte4 != s1->tagByte4 ||
+	    s0->tagByte5 != s1->tagByte5 ||
+	    s0->tagByte6 != s1->tagByte6 ||
+	    s0->tagByte7 != s1->tagByte7 ||
+	    s0->ecc1[0] != s1->ecc1[0] ||
+	    s0->ecc1[1] != s1->ecc1[1] ||
+	    s0->ecc1[2] != s1->ecc1[2] ||
+	    s0->ecc2[0] != s1->ecc2[0] ||
+	    s0->ecc2[1] != s1->ecc2[1] || s0->ecc2[2] != s1->ecc2[2]) {
+		return 0;
+	}
+
+	return 1;
+}
+#endif				/* NOTYET */
+
+int yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device *dev,
+						int chunkInNAND,
+						const __u8 *data,
+						const yaffs_ExtendedTags *eTags)
+{
+	yaffs_Spare spare;
+	yaffs_Tags tags;
+
+	yaffs_SpareInitialise(&spare);
+
+	if (eTags->chunkDeleted)
+		spare.pageStatus = 0;
+	else {
+		tags.objectId = eTags->objectId;
+		tags.chunkId = eTags->chunkId;
+
+		tags.byteCountLSB = eTags->byteCount & 0x3ff;
+
+		if (dev->nDataBytesPerChunk >= 1024)
+			tags.byteCountMSB = (eTags->byteCount >> 10) & 3;
+		else
+			tags.byteCountMSB = 3;
+
+
+		tags.serialNumber = eTags->serialNumber;
+
+		if (!dev->useNANDECC && data)
+			yaffs_CalcECC(data, &spare);
+
+		yaffs_LoadTagsIntoSpare(&spare, &tags);
+
+	}
+
+	return yaffs_WriteChunkToNAND(dev, chunkInNAND, data, &spare);
+}
+
+int yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device *dev,
+						     int chunkInNAND,
+						     __u8 *data,
+						     yaffs_ExtendedTags *eTags)
+{
+
+	yaffs_Spare spare;
+	yaffs_Tags tags;
+	yaffs_ECCResult eccResult = YAFFS_ECC_RESULT_UNKNOWN;
+
+	static yaffs_Spare spareFF;
+	static int init;
+
+	if (!init) {
+		memset(&spareFF, 0xFF, sizeof(spareFF));
+		init = 1;
+	}
+
+	if (yaffs_ReadChunkFromNAND
+	    (dev, chunkInNAND, data, &spare, &eccResult, 1)) {
+		/* eTags may be NULL */
+		if (eTags) {
+
+			int deleted =
+			    (yaffs_CountBits(spare.pageStatus) < 7) ? 1 : 0;
+
+			eTags->chunkDeleted = deleted;
+			eTags->eccResult = eccResult;
+			eTags->blockBad = 0;	/* We're reading it */
+			/* therefore it is not a bad block */
+			eTags->chunkUsed =
+			    (memcmp(&spareFF, &spare, sizeof(spareFF)) !=
+			     0) ? 1 : 0;
+
+			if (eTags->chunkUsed) {
+				yaffs_GetTagsFromSpare(dev, &spare, &tags);
+
+				eTags->objectId = tags.objectId;
+				eTags->chunkId = tags.chunkId;
+				eTags->byteCount = tags.byteCountLSB;
+
+				if (dev->nDataBytesPerChunk >= 1024)
+					eTags->byteCount |= (((unsigned) tags.byteCountMSB) << 10);
+
+				eTags->serialNumber = tags.serialNumber;
+			}
+		}
+
+		return YAFFS_OK;
+	} else {
+		return YAFFS_FAIL;
+	}
+}
+
+int yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,
+					    int blockInNAND)
+{
+
+	yaffs_Spare spare;
+
+	memset(&spare, 0xff, sizeof(yaffs_Spare));
+
+	spare.blockStatus = 'Y';
+
+	yaffs_WriteChunkToNAND(dev, blockInNAND * dev->nChunksPerBlock, NULL,
+			       &spare);
+	yaffs_WriteChunkToNAND(dev, blockInNAND * dev->nChunksPerBlock + 1,
+			       NULL, &spare);
+
+	return YAFFS_OK;
+
+}
+
+int yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,
+					  int blockNo,
+					  yaffs_BlockState *state,
+					  __u32 *sequenceNumber)
+{
+
+	yaffs_Spare spare0, spare1;
+	static yaffs_Spare spareFF;
+	static int init;
+	yaffs_ECCResult dummy;
+
+	if (!init) {
+		memset(&spareFF, 0xFF, sizeof(spareFF));
+		init = 1;
+	}
+
+	*sequenceNumber = 0;
+
+	yaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock, NULL,
+				&spare0, &dummy, 1);
+	yaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock + 1, NULL,
+				&spare1, &dummy, 1);
+
+	if (yaffs_CountBits(spare0.blockStatus & spare1.blockStatus) < 7)
+		*state = YAFFS_BLOCK_STATE_DEAD;
+	else if (memcmp(&spareFF, &spare0, sizeof(spareFF)) == 0)
+		*state = YAFFS_BLOCK_STATE_EMPTY;
+	else
+		*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+
+	return YAFFS_OK;
+}
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_tagscompat.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_tagscompat.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_tagscompat.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_tagscompat.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_TAGSCOMPAT_H__
+#define __YAFFS_TAGSCOMPAT_H__
+
+#include "yaffs_guts.h"
+int yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device *dev,
+						int chunkInNAND,
+						const __u8 *data,
+						const yaffs_ExtendedTags *tags);
+int yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device *dev,
+						int chunkInNAND,
+						__u8 *data,
+						yaffs_ExtendedTags *tags);
+int yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,
+					    int blockNo);
+int yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,
+					  int blockNo,
+					  yaffs_BlockState *state,
+					  __u32 *sequenceNumber);
+
+void yaffs_CalcTagsECC(yaffs_Tags *tags);
+int yaffs_CheckECCOnTags(yaffs_Tags *tags);
+int yaffs_CountBits(__u8 byte);
+
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_tagsvalidity.c iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_tagsvalidity.c
--- linux-2.6.32-orig/fs/yaffs2/yaffs_tagsvalidity.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_tagsvalidity.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_tagsvalidity.h"
+
+void yaffs_InitialiseTags(yaffs_ExtendedTags *tags)
+{
+	memset(tags, 0, sizeof(yaffs_ExtendedTags));
+	tags->validMarker0 = 0xAAAAAAAA;
+	tags->validMarker1 = 0x55555555;
+}
+
+int yaffs_ValidateTags(yaffs_ExtendedTags *tags)
+{
+	return (tags->validMarker0 == 0xAAAAAAAA &&
+		tags->validMarker1 == 0x55555555);
+
+}
diff -Nur linux-2.6.32-orig/fs/yaffs2/yaffs_tagsvalidity.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_tagsvalidity.h
--- linux-2.6.32-orig/fs/yaffs2/yaffs_tagsvalidity.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yaffs_tagsvalidity.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,24 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+
+#ifndef __YAFFS_TAGS_VALIDITY_H__
+#define __YAFFS_TAGS_VALIDITY_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_InitialiseTags(yaffs_ExtendedTags *tags);
+int yaffs_ValidateTags(yaffs_ExtendedTags *tags);
+#endif
diff -Nur linux-2.6.32-orig/fs/yaffs2/yportenv.h iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yportenv.h
--- linux-2.6.32-orig/fs/yaffs2/yportenv.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/fs/yaffs2/yportenv.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,203 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+
+#ifndef __YPORTENV_H__
+#define __YPORTENV_H__
+
+/*
+ * Define the MTD version in terms of Linux Kernel versions
+ * This allows yaffs to be used independantly of the kernel
+ * as well as with it.
+ */
+
+#define MTD_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + (c))
+
+#if defined CONFIG_YAFFS_WINCE
+
+#include "ywinceenv.h"
+
+#elif defined __KERNEL__
+
+#include "moduleconfig.h"
+
+/* Linux kernel */
+
+#include <linux/version.h>
+#define MTD_VERSION_CODE LINUX_VERSION_CODE
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#define YCHAR char
+#define YUCHAR unsigned char
+#define _Y(x)     x
+#define yaffs_strcat(a, b)     strcat(a, b)
+#define yaffs_strcpy(a, b)     strcpy(a, b)
+#define yaffs_strncpy(a, b, c) strncpy(a, b, c)
+#define yaffs_strncmp(a, b, c) strncmp(a, b, c)
+#define yaffs_strlen(s)	       strlen(s)
+#define yaffs_sprintf	       sprintf
+#define yaffs_toupper(a)       toupper(a)
+
+#define Y_INLINE inline
+
+#define YAFFS_LOSTNFOUND_NAME		"lost+found"
+#define YAFFS_LOSTNFOUND_PREFIX		"obj"
+
+/* #define YPRINTF(x) printk x */
+#define YMALLOC(x) kmalloc(x, GFP_NOFS)
+#define YFREE(x)   kfree(x)
+#define YMALLOC_ALT(x) vmalloc(x)
+#define YFREE_ALT(x)   vfree(x)
+#define YMALLOC_DMA(x) YMALLOC(x)
+
+/* KR - added for use in scan so processes aren't blocked indefinitely. */
+#define YYIELD() schedule()
+
+#define YAFFS_ROOT_MODE			0666
+#define YAFFS_LOSTNFOUND_MODE		0666
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
+#define Y_TIME_CONVERT(x) (x).tv_sec
+#else
+#define Y_CURRENT_TIME CURRENT_TIME
+#define Y_TIME_CONVERT(x) (x)
+#endif
+
+#define yaffs_SumCompare(x, y) ((x) == (y))
+#define yaffs_strcmp(a, b) strcmp(a, b)
+
+#define TENDSTR "\n"
+#define TSTR(x) KERN_WARNING x
+#define TCONT(x) x
+#define TOUT(p) printk p
+
+#define yaffs_trace(mask, fmt, args...) \
+	do { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) \
+		printk(KERN_WARNING "yaffs: " fmt, ## args); \
+	} while (0)
+
+#define compile_time_assertion(assertion) \
+	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
+
+#elif defined CONFIG_YAFFS_DIRECT
+
+#define MTD_VERSION_CODE MTD_VERSION(2, 6, 22)
+
+/* Direct interface */
+#include "ydirectenv.h"
+
+#elif defined CONFIG_YAFFS_UTIL
+
+/* Stuff for YAFFS utilities */
+
+#include "stdlib.h"
+#include "stdio.h"
+#include "string.h"
+
+#include "devextras.h"
+
+#define YMALLOC(x) malloc(x)
+#define YFREE(x)   free(x)
+#define YMALLOC_ALT(x) malloc(x)
+#define YFREE_ALT(x) free(x)
+
+#define YCHAR char
+#define YUCHAR unsigned char
+#define _Y(x)     x
+#define yaffs_strcat(a, b)     strcat(a, b)
+#define yaffs_strcpy(a, b)     strcpy(a, b)
+#define yaffs_strncpy(a, b, c) strncpy(a, b, c)
+#define yaffs_strlen(s)	       strlen(s)
+#define yaffs_sprintf	       sprintf
+#define yaffs_toupper(a)       toupper(a)
+
+#define Y_INLINE inline
+
+/* #define YINFO(s) YPRINTF(( __FILE__ " %d %s\n",__LINE__,s)) */
+/* #define YALERT(s) YINFO(s) */
+
+#define TENDSTR "\n"
+#define TSTR(x) x
+#define TOUT(p) printf p
+
+#define YAFFS_LOSTNFOUND_NAME		"lost+found"
+#define YAFFS_LOSTNFOUND_PREFIX		"obj"
+/* #define YPRINTF(x) printf x */
+
+#define YAFFS_ROOT_MODE				0666
+#define YAFFS_LOSTNFOUND_MODE		0666
+
+#define yaffs_SumCompare(x, y) ((x) == (y))
+#define yaffs_strcmp(a, b) strcmp(a, b)
+
+#else
+/* Should have specified a configuration type */
+#error Unknown configuration
+
+#endif
+
+/* see yaffs_fs.c */
+extern unsigned int yaffs_traceMask;
+extern unsigned int yaffs_wr_attempts;
+
+/*
+ * Tracing flags.
+ * The flags masked in YAFFS_TRACE_ALWAYS are always traced.
+ */
+
+#define YAFFS_TRACE_OS			0x00000002
+#define YAFFS_TRACE_ALLOCATE		0x00000004
+#define YAFFS_TRACE_SCAN		0x00000008
+#define YAFFS_TRACE_BAD_BLOCKS		0x00000010
+#define YAFFS_TRACE_ERASE		0x00000020
+#define YAFFS_TRACE_GC			0x00000040
+#define YAFFS_TRACE_WRITE		0x00000080
+#define YAFFS_TRACE_TRACING		0x00000100
+#define YAFFS_TRACE_DELETION		0x00000200
+#define YAFFS_TRACE_BUFFERS		0x00000400
+#define YAFFS_TRACE_NANDACCESS		0x00000800
+#define YAFFS_TRACE_GC_DETAIL		0x00001000
+#define YAFFS_TRACE_SCAN_DEBUG		0x00002000
+#define YAFFS_TRACE_MTD			0x00004000
+#define YAFFS_TRACE_CHECKPOINT		0x00008000
+
+#define YAFFS_TRACE_VERIFY		0x00010000
+#define YAFFS_TRACE_VERIFY_NAND		0x00020000
+#define YAFFS_TRACE_VERIFY_FULL		0x00040000
+#define YAFFS_TRACE_VERIFY_ALL		0x000F0000
+
+
+#define YAFFS_TRACE_ERROR		0x40000000
+#define YAFFS_TRACE_BUG			0x80000000
+#define YAFFS_TRACE_ALWAYS		0xF0000000
+
+
+#define T(mask, p) do { if ((mask) & (yaffs_traceMask | YAFFS_TRACE_ALWAYS)) TOUT(p); } while (0)
+
+#ifndef YBUG
+#define YBUG() do {T(YAFFS_TRACE_BUG, (TSTR("==>> yaffs bug: " __FILE__ " %d" TENDSTR), __LINE__)); } while (0)
+#endif
+
+#endif
diff -Nur linux-2.6.32-orig/include/acpi/platform/aclinux.h iDroid-Project-kernel_common-9e90fd2/include/acpi/platform/aclinux.h
--- linux-2.6.32-orig/include/acpi/platform/aclinux.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/acpi/platform/aclinux.h	2010-11-18 21:05:30.000000000 +0600
@@ -152,7 +152,7 @@
 #include <linux/hardirq.h>
 #define ACPI_PREEMPTION_POINT() \
 	do { \
-		if (!in_atomic_preempt_off()) \
+		if (!in_atomic_preempt_off() && !irqs_disabled()) \
 			cond_resched(); \
 	} while (0)
 
diff -Nur linux-2.6.32-orig/include/drm/drm_os_linux.h iDroid-Project-kernel_common-9e90fd2/include/drm/drm_os_linux.h
--- linux-2.6.32-orig/include/drm/drm_os_linux.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/drm/drm_os_linux.h	2010-11-18 21:05:30.000000000 +0600
@@ -123,5 +123,5 @@
 	remove_wait_queue(&(queue), &entry);			\
 } while (0)
 
-#define DRM_WAKEUP( queue ) wake_up_interruptible( queue )
+#define DRM_WAKEUP( queue ) wake_up( queue )
 #define DRM_INIT_WAITQUEUE( queue ) init_waitqueue_head( queue )
diff -Nur linux-2.6.32-orig/include/drm/drmP.h iDroid-Project-kernel_common-9e90fd2/include/drm/drmP.h
--- linux-2.6.32-orig/include/drm/drmP.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/drm/drmP.h	2010-11-18 21:05:30.000000000 +0600
@@ -1295,6 +1295,7 @@
 extern void drm_handle_vblank(struct drm_device *dev, int crtc);
 extern int drm_vblank_get(struct drm_device *dev, int crtc);
 extern void drm_vblank_put(struct drm_device *dev, int crtc);
+extern void drm_vblank_off(struct drm_device *dev, int crtc);
 extern void drm_vblank_cleanup(struct drm_device *dev);
 /* Modesetting support */
 extern void drm_vblank_pre_modeset(struct drm_device *dev, int crtc);
@@ -1401,7 +1402,7 @@
 				   struct drm_ati_pcigart_info * gart_info);
 
 extern drm_dma_handle_t *drm_pci_alloc(struct drm_device *dev, size_t size,
-				       size_t align, dma_addr_t maxaddr);
+				       size_t align);
 extern void __drm_pci_free(struct drm_device *dev, drm_dma_handle_t * dmah);
 extern void drm_pci_free(struct drm_device *dev, drm_dma_handle_t * dmah);
 
diff -Nur linux-2.6.32-orig/include/drm/ttm/ttm_memory.h iDroid-Project-kernel_common-9e90fd2/include/drm/ttm/ttm_memory.h
--- linux-2.6.32-orig/include/drm/ttm/ttm_memory.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/drm/ttm/ttm_memory.h	2010-11-18 21:05:30.000000000 +0600
@@ -33,6 +33,7 @@
 #include <linux/wait.h>
 #include <linux/errno.h>
 #include <linux/kobject.h>
+#include <linux/mm.h>
 
 /**
  * struct ttm_mem_shrink - callback to shrink TTM memory usage.
diff -Nur linux-2.6.32-orig/include/linux/acpi.h iDroid-Project-kernel_common-9e90fd2/include/linux/acpi.h
--- linux-2.6.32-orig/include/linux/acpi.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/acpi.h	2010-11-18 21:05:30.000000000 +0600
@@ -253,6 +253,13 @@
 void __init acpi_s4_no_nvs(void);
 #endif /* CONFIG_PM_SLEEP */
 
+struct acpi_osc_context {
+	char *uuid_str; /* uuid string */
+	int rev;
+	struct acpi_buffer cap; /* arg2/arg3 */
+	struct acpi_buffer ret; /* free by caller if success */
+};
+
 #define OSC_QUERY_TYPE			0
 #define OSC_SUPPORT_TYPE 		1
 #define OSC_CONTROL_TYPE		2
@@ -265,6 +272,15 @@
 #define OSC_INVALID_REVISION_ERROR	8
 #define OSC_CAPABILITIES_MASK_ERROR	16
 
+acpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context);
+
+/* platform-wide _OSC bits */
+#define OSC_SB_PAD_SUPPORT		1
+#define OSC_SB_PPC_OST_SUPPORT		2
+#define OSC_SB_PR3_SUPPORT		4
+#define OSC_SB_CPUHP_OST_SUPPORT	8
+#define OSC_SB_APEI_SUPPORT		16
+
 /* _OSC DW1 Definition (OS Support Fields) */
 #define OSC_EXT_PCI_CONFIG_SUPPORT		1
 #define OSC_ACTIVE_STATE_PWR_SUPPORT 		2
diff -Nur linux-2.6.32-orig/include/linux/amba/mmci.h iDroid-Project-kernel_common-9e90fd2/include/linux/amba/mmci.h
--- linux-2.6.32-orig/include/linux/amba/mmci.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/amba/mmci.h	2010-11-18 21:05:30.000000000 +0600
@@ -5,6 +5,15 @@
 #define AMBA_MMCI_H
 
 #include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
+
+struct embedded_sdio_data {
+        struct sdio_cis cis;
+        struct sdio_cccr cccr;
+        struct sdio_embedded_func *funcs;
+        int num_funcs;
+};
 
 struct mmci_platform_data {
 	unsigned int ocr_mask;			/* available voltages */
@@ -13,6 +22,9 @@
 	int	gpio_wp;
 	int	gpio_cd;
 	unsigned long capabilities;
+	unsigned int status_irq;
+	struct embedded_sdio_data *embedded_sdio;
+	int (*register_status_notify)(void (*callback)(int card_present, void *dev_id), void *dev_id);
 };
 
 #endif
diff -Nur linux-2.6.32-orig/include/linux/android_aid.h iDroid-Project-kernel_common-9e90fd2/include/linux/android_aid.h
--- linux-2.6.32-orig/include/linux/android_aid.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/android_aid.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,26 @@
+/* include/linux/android_aid.h
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_ANDROID_AID_H
+#define _LINUX_ANDROID_AID_H
+
+/* AIDs that the kernel treats differently */
+#define AID_NET_BT_ADMIN 3001
+#define AID_NET_BT       3002
+#define AID_INET         3003
+#define AID_NET_RAW      3004
+#define AID_NET_ADMIN    3005
+
+#endif
diff -Nur linux-2.6.32-orig/include/linux/android_alarm.h iDroid-Project-kernel_common-9e90fd2/include/linux/android_alarm.h
--- linux-2.6.32-orig/include/linux/android_alarm.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/android_alarm.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,106 @@
+/* include/linux/android_alarm.h
+ *
+ * Copyright (C) 2006-2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_ANDROID_ALARM_H
+#define _LINUX_ANDROID_ALARM_H
+
+#include <linux/ioctl.h>
+#include <linux/time.h>
+
+enum android_alarm_type {
+	/* return code bit numbers or set alarm arg */
+	ANDROID_ALARM_RTC_WAKEUP,
+	ANDROID_ALARM_RTC,
+	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
+	ANDROID_ALARM_ELAPSED_REALTIME,
+	ANDROID_ALARM_SYSTEMTIME,
+
+	ANDROID_ALARM_TYPE_COUNT,
+
+	/* return code bit numbers */
+	/* ANDROID_ALARM_TIME_CHANGE = 16 */
+};
+
+#ifdef __KERNEL__
+
+#include <linux/ktime.h>
+#include <linux/rbtree.h>
+
+/*
+ * The alarm interface is similar to the hrtimer interface but adds support
+ * for wakeup from suspend. It also adds an elapsed realtime clock that can
+ * be used for periodic timers that need to keep runing while the system is
+ * suspended and not be disrupted when the wall time is set.
+ */
+
+/**
+ * struct alarm - the basic alarm structure
+ * @node:	red black tree node for time ordered insertion
+ * @type:	alarm type. rtc/elapsed-realtime/systemtime, wakeup/non-wakeup.
+ * @softexpires: the absolute earliest expiry time of the alarm.
+ * @expires:	the absolute expiry time.
+ * @function:	alarm expiry callback function
+ *
+ * The alarm structure must be initialized by alarm_init()
+ *
+ */
+
+struct alarm {
+	struct rb_node 		node;
+	enum android_alarm_type type;
+	ktime_t			softexpires;
+	ktime_t			expires;
+	void			(*function)(struct alarm *);
+};
+
+void alarm_init(struct alarm *alarm,
+	enum android_alarm_type type, void (*function)(struct alarm *));
+void alarm_start_range(struct alarm *alarm, ktime_t start, ktime_t end);
+int alarm_try_to_cancel(struct alarm *alarm);
+int alarm_cancel(struct alarm *alarm);
+ktime_t alarm_get_elapsed_realtime(void);
+
+/* set rtc while preserving elapsed realtime */
+int alarm_set_rtc(const struct timespec ts);
+
+#endif
+
+enum android_alarm_return_flags {
+	ANDROID_ALARM_RTC_WAKEUP_MASK = 1U << ANDROID_ALARM_RTC_WAKEUP,
+	ANDROID_ALARM_RTC_MASK = 1U << ANDROID_ALARM_RTC,
+	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK =
+				1U << ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
+	ANDROID_ALARM_ELAPSED_REALTIME_MASK =
+				1U << ANDROID_ALARM_ELAPSED_REALTIME,
+	ANDROID_ALARM_SYSTEMTIME_MASK = 1U << ANDROID_ALARM_SYSTEMTIME,
+	ANDROID_ALARM_TIME_CHANGE_MASK = 1U << 16
+};
+
+/* Disable alarm */
+#define ANDROID_ALARM_CLEAR(type)           _IO('a', 0 | ((type) << 4))
+
+/* Ack last alarm and wait for next */
+#define ANDROID_ALARM_WAIT                  _IO('a', 1)
+
+#define ALARM_IOW(c, type, size)            _IOW('a', (c) | ((type) << 4), size)
+/* Set alarm */
+#define ANDROID_ALARM_SET(type)             ALARM_IOW(2, type, struct timespec)
+#define ANDROID_ALARM_SET_AND_WAIT(type)    ALARM_IOW(3, type, struct timespec)
+#define ANDROID_ALARM_GET_TIME(type)        ALARM_IOW(4, type, struct timespec)
+#define ANDROID_ALARM_SET_RTC               _IOW('a', 5, struct timespec)
+#define ANDROID_ALARM_BASE_CMD(cmd)         (cmd & ~(_IOC(0, 0, 0xf0, 0)))
+#define ANDROID_ALARM_IOCTL_TO_TYPE(cmd)    (_IOC_NR(cmd) >> 4)
+
+#endif
diff -Nur linux-2.6.32-orig/include/linux/android_pmem.h iDroid-Project-kernel_common-9e90fd2/include/linux/android_pmem.h
--- linux-2.6.32-orig/include/linux/android_pmem.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/android_pmem.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,93 @@
+/* include/linux/android_pmem.h
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _ANDROID_PMEM_H_
+#define _ANDROID_PMEM_H_
+
+#define PMEM_IOCTL_MAGIC 'p'
+#define PMEM_GET_PHYS		_IOW(PMEM_IOCTL_MAGIC, 1, unsigned int)
+#define PMEM_MAP		_IOW(PMEM_IOCTL_MAGIC, 2, unsigned int)
+#define PMEM_GET_SIZE		_IOW(PMEM_IOCTL_MAGIC, 3, unsigned int)
+#define PMEM_UNMAP		_IOW(PMEM_IOCTL_MAGIC, 4, unsigned int)
+/* This ioctl will allocate pmem space, backing the file, it will fail
+ * if the file already has an allocation, pass it the len as the argument
+ * to the ioctl */
+#define PMEM_ALLOCATE		_IOW(PMEM_IOCTL_MAGIC, 5, unsigned int)
+/* This will connect a one pmem file to another, pass the file that is already
+ * backed in memory as the argument to the ioctl
+ */
+#define PMEM_CONNECT		_IOW(PMEM_IOCTL_MAGIC, 6, unsigned int)
+/* Returns the total size of the pmem region it is sent to as a pmem_region
+ * struct (with offset set to 0). 
+ */
+#define PMEM_GET_TOTAL_SIZE	_IOW(PMEM_IOCTL_MAGIC, 7, unsigned int)
+#define PMEM_CACHE_FLUSH	_IOW(PMEM_IOCTL_MAGIC, 8, unsigned int)
+
+struct android_pmem_platform_data
+{
+	const char* name;
+	/* starting physical address of memory region */
+	unsigned long start;
+	/* size of memory region */
+	unsigned long size;
+	/* set to indicate the region should not be managed with an allocator */
+	unsigned no_allocator;
+	/* set to indicate maps of this region should be cached, if a mix of
+	 * cached and uncached is desired, set this and open the device with
+	 * O_SYNC to get an uncached region */
+	unsigned cached;
+	/* The MSM7k has bits to enable a write buffer in the bus controller*/
+	unsigned buffered;
+};
+
+struct pmem_region {
+	unsigned long offset;
+	unsigned long len;
+};
+
+#ifdef CONFIG_ANDROID_PMEM
+int is_pmem_file(struct file *file);
+int get_pmem_file(int fd, unsigned long *start, unsigned long *vstart,
+		  unsigned long *end, struct file **filp);
+int get_pmem_user_addr(struct file *file, unsigned long *start,
+		       unsigned long *end);
+void put_pmem_file(struct file* file);
+void flush_pmem_file(struct file *file, unsigned long start, unsigned long len);
+int pmem_setup(struct android_pmem_platform_data *pdata,
+	       long (*ioctl)(struct file *, unsigned int, unsigned long),
+	       int (*release)(struct inode *, struct file *));
+int pmem_remap(struct pmem_region *region, struct file *file,
+	       unsigned operation);
+
+#else
+static inline int is_pmem_file(struct file *file) { return 0; }
+static inline int get_pmem_file(int fd, unsigned long *start,
+				unsigned long *vstart, unsigned long *end,
+				struct file **filp) { return -ENOSYS; }
+static inline int get_pmem_user_addr(struct file *file, unsigned long *start,
+				     unsigned long *end) { return -ENOSYS; }
+static inline void put_pmem_file(struct file* file) { return; }
+static inline void flush_pmem_file(struct file *file, unsigned long start,
+				   unsigned long len) { return; }
+static inline int pmem_setup(struct android_pmem_platform_data *pdata,
+	      long (*ioctl)(struct file *, unsigned int, unsigned long),
+	      int (*release)(struct inode *, struct file *)) { return -ENOSYS; }
+
+static inline int pmem_remap(struct pmem_region *region, struct file *file,
+			     unsigned operation) { return -ENOSYS; }
+#endif
+
+#endif //_ANDROID_PPP_H_
+
diff -Nur linux-2.6.32-orig/include/linux/ashmem.h iDroid-Project-kernel_common-9e90fd2/include/linux/ashmem.h
--- linux-2.6.32-orig/include/linux/ashmem.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/ashmem.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,48 @@
+/*
+ * include/linux/ashmem.h
+ *
+ * Copyright 2008 Google Inc.
+ * Author: Robert Love
+ *
+ * This file is dual licensed.  It may be redistributed and/or modified
+ * under the terms of the Apache 2.0 License OR version 2 of the GNU
+ * General Public License.
+ */
+
+#ifndef _LINUX_ASHMEM_H
+#define _LINUX_ASHMEM_H
+
+#include <linux/limits.h>
+#include <linux/ioctl.h>
+
+#define ASHMEM_NAME_LEN		256
+
+#define ASHMEM_NAME_DEF		"dev/ashmem"
+
+/* Return values from ASHMEM_PIN: Was the mapping purged while unpinned? */
+#define ASHMEM_NOT_PURGED	0
+#define ASHMEM_WAS_PURGED	1
+
+/* Return values from ASHMEM_GET_PIN_STATUS: Is the mapping pinned? */
+#define ASHMEM_IS_UNPINNED	0
+#define ASHMEM_IS_PINNED	1
+
+struct ashmem_pin {
+	__u32 offset;	/* offset into region, in bytes, page-aligned */
+	__u32 len;	/* length forward from offset, in bytes, page-aligned */
+};
+
+#define __ASHMEMIOC		0x77
+
+#define ASHMEM_SET_NAME		_IOW(__ASHMEMIOC, 1, char[ASHMEM_NAME_LEN])
+#define ASHMEM_GET_NAME		_IOR(__ASHMEMIOC, 2, char[ASHMEM_NAME_LEN])
+#define ASHMEM_SET_SIZE		_IOW(__ASHMEMIOC, 3, size_t)
+#define ASHMEM_GET_SIZE		_IO(__ASHMEMIOC, 4)
+#define ASHMEM_SET_PROT_MASK	_IOW(__ASHMEMIOC, 5, unsigned long)
+#define ASHMEM_GET_PROT_MASK	_IO(__ASHMEMIOC, 6)
+#define ASHMEM_PIN		_IOW(__ASHMEMIOC, 7, struct ashmem_pin)
+#define ASHMEM_UNPIN		_IOW(__ASHMEMIOC, 8, struct ashmem_pin)
+#define ASHMEM_GET_PIN_STATUS	_IO(__ASHMEMIOC, 9)
+#define ASHMEM_PURGE_ALL_CACHES	_IO(__ASHMEMIOC, 10)
+
+#endif	/* _LINUX_ASHMEM_H */
diff -Nur linux-2.6.32-orig/include/linux/binfmts.h iDroid-Project-kernel_common-9e90fd2/include/linux/binfmts.h
--- linux-2.6.32-orig/include/linux/binfmts.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/binfmts.h	2010-11-18 21:05:30.000000000 +0600
@@ -101,6 +101,7 @@
 extern int __must_check remove_arg_zero(struct linux_binprm *);
 extern int search_binary_handler(struct linux_binprm *,struct pt_regs *);
 extern int flush_old_exec(struct linux_binprm * bprm);
+extern void setup_new_exec(struct linux_binprm * bprm);
 
 extern int suid_dumpable;
 #define SUID_DUMP_DISABLE	0	/* No setuid dumping */
diff -Nur linux-2.6.32-orig/include/linux/blkdev.h iDroid-Project-kernel_common-9e90fd2/include/linux/blkdev.h
--- linux-2.6.32-orig/include/linux/blkdev.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/blkdev.h	2010-11-18 21:05:30.000000000 +0600
@@ -942,6 +942,8 @@
 extern void blk_set_default_limits(struct queue_limits *lim);
 extern int blk_stack_limits(struct queue_limits *t, struct queue_limits *b,
 			    sector_t offset);
+extern int bdev_stack_limits(struct queue_limits *t, struct block_device *bdev,
+			    sector_t offset);
 extern void disk_stack_limits(struct gendisk *disk, struct block_device *bdev,
 			      sector_t offset);
 extern void blk_queue_stack_limits(struct request_queue *t, struct request_queue *b);
@@ -1114,11 +1116,18 @@
 	return q->limits.alignment_offset;
 }
 
+static inline int queue_limit_alignment_offset(struct queue_limits *lim, sector_t offset)
+{
+	unsigned int granularity = max(lim->physical_block_size, lim->io_min);
+
+	offset &= granularity - 1;
+	return (granularity + lim->alignment_offset - offset) & (granularity - 1);
+}
+
 static inline int queue_sector_alignment_offset(struct request_queue *q,
 						sector_t sector)
 {
-	return ((sector << 9) - q->limits.alignment_offset)
-		& (q->limits.io_min - 1);
+	return queue_limit_alignment_offset(&q->limits, sector << 9);
 }
 
 static inline int bdev_alignment_offset(struct block_device *bdev)
diff -Nur linux-2.6.32-orig/include/linux/clockchips.h iDroid-Project-kernel_common-9e90fd2/include/linux/clockchips.h
--- linux-2.6.32-orig/include/linux/clockchips.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/clockchips.h	2010-11-18 21:05:30.000000000 +0600
@@ -79,7 +79,7 @@
 	unsigned int		features;
 	unsigned long		max_delta_ns;
 	unsigned long		min_delta_ns;
-	unsigned long		mult;
+	u32			mult;
 	int			shift;
 	int			rating;
 	int			irq;
@@ -130,6 +130,16 @@
 
 extern void clockevents_handle_noop(struct clock_event_device *dev);
 
+extern void
+clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 minsec);
+
+static inline void
+clockevents_calc_mult_shift(struct clock_event_device *ce, u32 freq, u32 minsec)
+{
+	return clocks_calc_mult_shift(&ce->mult, &ce->shift, NSEC_PER_SEC,
+			freq, minsec);
+}
+
 #ifdef CONFIG_GENERIC_CLOCKEVENTS
 extern void clockevents_notify(unsigned long reason, void *arg);
 #else
diff -Nur linux-2.6.32-orig/include/linux/clocksource.h iDroid-Project-kernel_common-9e90fd2/include/linux/clocksource.h
--- linux-2.6.32-orig/include/linux/clocksource.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/clocksource.h	2010-11-18 21:05:30.000000000 +0600
@@ -151,6 +151,7 @@
  *			subtraction of non 64 bit counters
  * @mult:		cycle to nanosecond multiplier
  * @shift:		cycle to nanosecond divisor (power of two)
+ * @max_idle_ns:	max idle time permitted by the clocksource (nsecs)
  * @flags:		flags describing special properties
  * @vread:		vsyscall based read
  * @resume:		resume function for the clocksource, if necessary
@@ -168,6 +169,7 @@
 	cycle_t mask;
 	u32 mult;
 	u32 shift;
+	u64 max_idle_ns;
 	unsigned long flags;
 	cycle_t (*vread)(void);
 	void (*resume)(void);
diff -Nur linux-2.6.32-orig/include/linux/connector.h iDroid-Project-kernel_common-9e90fd2/include/linux/connector.h
--- linux-2.6.32-orig/include/linux/connector.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/connector.h	2010-11-18 21:05:30.000000000 +0600
@@ -24,9 +24,6 @@
 
 #include <linux/types.h>
 
-#define CN_IDX_CONNECTOR		0xffffffff
-#define CN_VAL_CONNECTOR		0xffffffff
-
 /*
  * Process Events connector unique ids -- used for message routing
  */
@@ -73,30 +70,6 @@
 	__u8 data[0];
 };
 
-/*
- * Notify structure - requests notification about
- * registering/unregistering idx/val in range [first, first+range].
- */
-struct cn_notify_req {
-	__u32 first;
-	__u32 range;
-};
-
-/*
- * Main notification control message
- * *_notify_num 	- number of appropriate cn_notify_req structures after 
- *				this struct.
- * group 		- notification receiver's idx.
- * len 			- total length of the attached data.
- */
-struct cn_ctl_msg {
-	__u32 idx_notify_num;
-	__u32 val_notify_num;
-	__u32 group;
-	__u32 len;
-	__u8 data[0];
-};
-
 #ifdef __KERNEL__
 
 #include <asm/atomic.h>
@@ -149,11 +122,6 @@
 	u32 seq, group;
 };
 
-struct cn_ctl_entry {
-	struct list_head notify_entry;
-	struct cn_ctl_msg *msg;
-};
-
 struct cn_dev {
 	struct cb_id id;
 
diff -Nur linux-2.6.32-orig/include/linux/cpumask.h iDroid-Project-kernel_common-9e90fd2/include/linux/cpumask.h
--- linux-2.6.32-orig/include/linux/cpumask.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/cpumask.h	2010-11-18 21:05:30.000000000 +0600
@@ -84,6 +84,7 @@
 #define num_online_cpus()	cpumask_weight(cpu_online_mask)
 #define num_possible_cpus()	cpumask_weight(cpu_possible_mask)
 #define num_present_cpus()	cpumask_weight(cpu_present_mask)
+#define num_active_cpus()	cpumask_weight(cpu_active_mask)
 #define cpu_online(cpu)		cpumask_test_cpu((cpu), cpu_online_mask)
 #define cpu_possible(cpu)	cpumask_test_cpu((cpu), cpu_possible_mask)
 #define cpu_present(cpu)	cpumask_test_cpu((cpu), cpu_present_mask)
@@ -92,6 +93,7 @@
 #define num_online_cpus()	1
 #define num_possible_cpus()	1
 #define num_present_cpus()	1
+#define num_active_cpus()	1
 #define cpu_online(cpu)		((cpu) == 0)
 #define cpu_possible(cpu)	((cpu) == 0)
 #define cpu_present(cpu)	((cpu) == 0)
diff -Nur linux-2.6.32-orig/include/linux/earlysuspend.h iDroid-Project-kernel_common-9e90fd2/include/linux/earlysuspend.h
--- linux-2.6.32-orig/include/linux/earlysuspend.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/earlysuspend.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,56 @@
+/* include/linux/earlysuspend.h
+ *
+ * Copyright (C) 2007-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_EARLYSUSPEND_H
+#define _LINUX_EARLYSUSPEND_H
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/list.h>
+#endif
+
+/* The early_suspend structure defines suspend and resume hooks to be called
+ * when the user visible sleep state of the system changes, and a level to
+ * control the order. They can be used to turn off the screen and input
+ * devices that are not used for wakeup.
+ * Suspend handlers are called in low to high level order, resume handlers are
+ * called in the opposite order. If, when calling register_early_suspend,
+ * the suspend handlers have already been called without a matching call to the
+ * resume handlers, the suspend handler will be called directly from
+ * register_early_suspend. This direct call can violate the normal level order.
+ */
+enum {
+	EARLY_SUSPEND_LEVEL_BLANK_SCREEN = 50,
+	EARLY_SUSPEND_LEVEL_STOP_DRAWING = 100,
+	EARLY_SUSPEND_LEVEL_DISABLE_FB = 150,
+};
+struct early_suspend {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct list_head link;
+	int level;
+	void (*suspend)(struct early_suspend *h);
+	void (*resume)(struct early_suspend *h);
+#endif
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void register_early_suspend(struct early_suspend *handler);
+void unregister_early_suspend(struct early_suspend *handler);
+#else
+#define register_early_suspend(handler) do { } while (0)
+#define unregister_early_suspend(handler) do { } while (0)
+#endif
+
+#endif
+
diff -Nur linux-2.6.32-orig/include/linux/enclosure.h iDroid-Project-kernel_common-9e90fd2/include/linux/enclosure.h
--- linux-2.6.32-orig/include/linux/enclosure.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/enclosure.h	2010-11-18 21:05:30.000000000 +0600
@@ -42,6 +42,8 @@
 	ENCLOSURE_STATUS_NOT_INSTALLED,
 	ENCLOSURE_STATUS_UNKNOWN,
 	ENCLOSURE_STATUS_UNAVAILABLE,
+	/* last element for counting purposes */
+	ENCLOSURE_STATUS_MAX
 };
 
 /* SFF-8485 activity light settings */
diff -Nur linux-2.6.32-orig/include/linux/fs.h iDroid-Project-kernel_common-9e90fd2/include/linux/fs.h
--- linux-2.6.32-orig/include/linux/fs.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/fs.h	2010-11-18 21:05:30.000000000 +0600
@@ -2314,6 +2314,7 @@
 extern int generic_readlink(struct dentry *, char __user *, int);
 extern void generic_fillattr(struct inode *, struct kstat *);
 extern int vfs_getattr(struct vfsmount *, struct dentry *, struct kstat *);
+void __inode_add_bytes(struct inode *inode, loff_t bytes);
 void inode_add_bytes(struct inode *inode, loff_t bytes);
 void inode_sub_bytes(struct inode *inode, loff_t bytes);
 loff_t inode_get_bytes(struct inode *inode);
diff -Nur linux-2.6.32-orig/include/linux/gpio_event.h iDroid-Project-kernel_common-9e90fd2/include/linux/gpio_event.h
--- linux-2.6.32-orig/include/linux/gpio_event.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/gpio_event.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,169 @@
+/* include/linux/gpio_event.h
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_GPIO_EVENT_H
+#define _LINUX_GPIO_EVENT_H
+
+#include <linux/input.h>
+
+struct gpio_event_input_devs {
+	int count;
+	struct input_dev *dev[];
+};
+enum {
+	GPIO_EVENT_FUNC_UNINIT  = 0x0,
+	GPIO_EVENT_FUNC_INIT    = 0x1,
+	GPIO_EVENT_FUNC_SUSPEND = 0x2,
+	GPIO_EVENT_FUNC_RESUME  = 0x3,
+};
+struct gpio_event_info {
+	int (*func)(struct gpio_event_input_devs *input_devs,
+		    struct gpio_event_info *info,
+		    void **data, int func);
+	int (*event)(struct gpio_event_input_devs *input_devs,
+		     struct gpio_event_info *info,
+		     void **data, unsigned int dev, unsigned int type,
+		     unsigned int code, int value); /* out events */
+	bool no_suspend;
+};
+
+struct gpio_event_platform_data {
+	const char *name;
+	struct gpio_event_info **info;
+	size_t info_count;
+	int (*power)(const struct gpio_event_platform_data *pdata, bool on);
+	const char *names[]; /* If name is NULL, names contain a NULL */
+			     /* terminated list of input devices to create */
+};
+
+#define GPIO_EVENT_DEV_NAME "gpio-event"
+
+/* Key matrix */
+
+enum gpio_event_matrix_flags {
+	/* unset: drive active output low, set: drive active output high */
+	GPIOKPF_ACTIVE_HIGH              = 1U << 0,
+	GPIOKPF_DEBOUNCE                 = 1U << 1,
+	GPIOKPF_REMOVE_SOME_PHANTOM_KEYS = 1U << 2,
+	GPIOKPF_REMOVE_PHANTOM_KEYS      = GPIOKPF_REMOVE_SOME_PHANTOM_KEYS |
+					   GPIOKPF_DEBOUNCE,
+	GPIOKPF_DRIVE_INACTIVE           = 1U << 3,
+	GPIOKPF_LEVEL_TRIGGERED_IRQ      = 1U << 4,
+	GPIOKPF_PRINT_UNMAPPED_KEYS      = 1U << 16,
+	GPIOKPF_PRINT_MAPPED_KEYS        = 1U << 17,
+	GPIOKPF_PRINT_PHANTOM_KEYS       = 1U << 18,
+};
+
+#define MATRIX_CODE_BITS (10)
+#define MATRIX_KEY_MASK ((1U << MATRIX_CODE_BITS) - 1)
+#define MATRIX_KEY(dev, code) \
+	(((dev) << MATRIX_CODE_BITS) | (code & MATRIX_KEY_MASK))
+
+extern int gpio_event_matrix_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+struct gpio_event_matrix_info {
+	/* initialize to gpio_event_matrix_func */
+	struct gpio_event_info info;
+	/* size must be ninputs * noutputs */
+	const unsigned short *keymap;
+	unsigned int *input_gpios;
+	unsigned int *output_gpios;
+	unsigned int ninputs;
+	unsigned int noutputs;
+	/* time to wait before reading inputs after driving each output */
+	ktime_t settle_time;
+	/* time to wait before scanning the keypad a second time */
+	ktime_t debounce_delay;
+	ktime_t poll_time;
+	unsigned flags;
+};
+
+/* Directly connected inputs and outputs */
+
+enum gpio_event_direct_flags {
+	GPIOEDF_ACTIVE_HIGH         = 1U << 0,
+/*	GPIOEDF_USE_DOWN_IRQ        = 1U << 1, */
+/*	GPIOEDF_USE_IRQ             = (1U << 2) | GPIOIDF_USE_DOWN_IRQ, */
+	GPIOEDF_PRINT_KEYS          = 1U << 8,
+	GPIOEDF_PRINT_KEY_DEBOUNCE  = 1U << 9,
+};
+
+struct gpio_event_direct_entry {
+	uint32_t gpio:16;
+	uint32_t code:10;
+	uint32_t dev:6;
+};
+
+/* inputs */
+extern int gpio_event_input_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+struct gpio_event_input_info {
+	/* initialize to gpio_event_input_func */
+	struct gpio_event_info info;
+	ktime_t debounce_time;
+	ktime_t poll_time;
+	uint16_t flags;
+	uint16_t type;
+	const struct gpio_event_direct_entry *keymap;
+	size_t keymap_size;
+};
+
+/* outputs */
+extern int gpio_event_output_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+extern int gpio_event_output_event(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data,
+			unsigned int dev, unsigned int type,
+			unsigned int code, int value);
+struct gpio_event_output_info {
+	/* initialize to gpio_event_output_func and gpio_event_output_event */
+	struct gpio_event_info info;
+	uint16_t flags;
+	uint16_t type;
+	const struct gpio_event_direct_entry *keymap;
+	size_t keymap_size;
+};
+
+
+/* axes */
+
+enum gpio_event_axis_flags {
+	GPIOEAF_PRINT_UNKNOWN_DIRECTION  = 1U << 16,
+	GPIOEAF_PRINT_RAW                = 1U << 17,
+	GPIOEAF_PRINT_EVENT              = 1U << 18,
+};
+
+extern int gpio_event_axis_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+struct gpio_event_axis_info {
+	/* initialize to gpio_event_axis_func */
+	struct gpio_event_info info;
+	uint8_t  count; /* number of gpios for this axis */
+	uint8_t  dev; /* device index when using multiple input devices */
+	uint8_t  type; /* EV_REL or EV_ABS */
+	uint16_t code;
+	uint16_t decoded_size;
+	uint16_t (*map)(struct gpio_event_axis_info *info, uint16_t in);
+	uint32_t *gpio;
+	uint32_t flags;
+};
+#define gpio_axis_2bit_gray_map gpio_axis_4bit_gray_map
+#define gpio_axis_3bit_gray_map gpio_axis_4bit_gray_map
+uint16_t gpio_axis_4bit_gray_map(
+			struct gpio_event_axis_info *info, uint16_t in);
+uint16_t gpio_axis_5bit_singletrack_map(
+			struct gpio_event_axis_info *info, uint16_t in);
+
+#endif
diff -Nur linux-2.6.32-orig/include/linux/hid.h iDroid-Project-kernel_common-9e90fd2/include/linux/hid.h
--- linux-2.6.32-orig/include/linux/hid.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/hid.h	2010-11-18 21:05:30.000000000 +0600
@@ -312,6 +312,7 @@
 #define HID_QUIRK_MULTI_INPUT			0x00000040
 #define HID_QUIRK_SKIP_OUTPUT_REPORTS		0x00010000
 #define HID_QUIRK_FULLSPEED_INTERVAL		0x10000000
+#define HID_QUIRK_NO_INIT_REPORTS		0x20000000
 
 /*
  * This is the global environment of the parser. This information is
diff -Nur linux-2.6.32-orig/include/linux/hrtimer.h iDroid-Project-kernel_common-9e90fd2/include/linux/hrtimer.h
--- linux-2.6.32-orig/include/linux/hrtimer.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/hrtimer.h	2010-11-18 21:05:30.000000000 +0600
@@ -446,7 +446,7 @@
 
 static inline void timer_stats_account_hrtimer(struct hrtimer *timer)
 {
-	if (likely(!timer->start_site))
+	if (likely(!timer_stats_active))
 		return;
 	timer_stats_update_stats(timer, timer->start_pid, timer->start_site,
 				 timer->function, timer->start_comm, 0);
@@ -457,8 +457,6 @@
 
 static inline void timer_stats_hrtimer_set_start_info(struct hrtimer *timer)
 {
-	if (likely(!timer_stats_active))
-		return;
 	__timer_stats_hrtimer_set_start_info(timer, __builtin_return_address(0));
 }
 
diff -Nur linux-2.6.32-orig/include/linux/if_pppolac.h iDroid-Project-kernel_common-9e90fd2/include/linux/if_pppolac.h
--- linux-2.6.32-orig/include/linux/if_pppolac.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/if_pppolac.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,35 @@
+/* include/linux/if_pppolac.h
+ *
+ * Header for PPP on L2TP Access Concentrator / PPPoLAC Socket (RFC 2661)
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Author: Chia-chi Yeh <chiachi@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_IF_PPPOLAC_H
+#define __LINUX_IF_PPPOLAC_H
+
+#include <linux/socket.h>
+#include <linux/types.h>
+
+#define PX_PROTO_OLAC	2
+
+struct sockaddr_pppolac {
+	sa_family_t	sa_family;	/* AF_PPPOX */
+	unsigned int	sa_protocol;	/* PX_PROTO_OLAC */
+	int		udp_socket;
+	struct __attribute__((packed)) {
+		__u16	tunnel, session;
+	} local, remote;
+} __attribute__((packed));
+
+#endif /* __LINUX_IF_PPPOLAC_H */
diff -Nur linux-2.6.32-orig/include/linux/if_pppopns.h iDroid-Project-kernel_common-9e90fd2/include/linux/if_pppopns.h
--- linux-2.6.32-orig/include/linux/if_pppopns.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/if_pppopns.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,34 @@
+/* include/linux/if_pppopns.h
+ *
+ * Header for PPP on PPTP Network Server / PPPoPNS Socket (RFC 2637)
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Author: Chia-chi Yeh <chiachi@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_IF_PPPOPNS_H
+#define __LINUX_IF_PPPOPNS_H
+
+#include <linux/socket.h>
+#include <linux/types.h>
+
+#define PX_PROTO_OPNS	3
+
+struct sockaddr_pppopns {
+	sa_family_t	sa_family;	/* AF_PPPOX */
+	unsigned int	sa_protocol;	/* PX_PROTO_OPNS */
+	int		tcp_socket;
+	__u16		local;
+	__u16		remote;
+} __attribute__((packed));
+
+#endif /* __LINUX_IF_PPPOPNS_H */
diff -Nur linux-2.6.32-orig/include/linux/if_pppox.h iDroid-Project-kernel_common-9e90fd2/include/linux/if_pppox.h
--- linux-2.6.32-orig/include/linux/if_pppox.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/if_pppox.h	2010-11-18 21:05:30.000000000 +0600
@@ -27,6 +27,8 @@
 #include <linux/ppp_channel.h>
 #endif /* __KERNEL__ */
 #include <linux/if_pppol2tp.h>
+#include <linux/if_pppolac.h>
+#include <linux/if_pppopns.h>
 
 /* For user-space programs to pick up these definitions
  * which they wouldn't get otherwise without defining __KERNEL__
@@ -51,7 +53,9 @@
  */ 
 #define PX_PROTO_OE    0 /* Currently just PPPoE */
 #define PX_PROTO_OL2TP 1 /* Now L2TP also */
-#define PX_MAX_PROTO   2
+#define PX_PROTO_OLAC  2
+#define PX_PROTO_OPNS  3
+#define PX_MAX_PROTO   4
 
 struct sockaddr_pppox { 
        sa_family_t     sa_family;            /* address family, AF_PPPOX */ 
@@ -141,6 +145,22 @@
 					     relayed to (PPPoE relaying) */
 };
 
+struct pppolac_opt {
+	__u32	local;
+	__u32	remote;
+	__u16	sequence;
+	__u8	sequencing;
+	int	(*backlog_rcv)(struct sock *sk_udp, struct sk_buff *skb);
+};
+
+struct pppopns_opt {
+	__u16	local;
+	__u16	remote;
+	__u32	sequence;
+	void	(*data_ready)(struct sock *sk_raw, int length);
+	int	(*backlog_rcv)(struct sock *sk_raw, struct sk_buff *skb);
+};
+
 #include <net/sock.h>
 
 struct pppox_sock {
@@ -150,6 +170,8 @@
 	struct pppox_sock	*next;	  /* for hash table */
 	union {
 		struct pppoe_opt pppoe;
+		struct pppolac_opt lac;
+		struct pppopns_opt pns;
 	} proto;
 	__be16			num;
 };
diff -Nur linux-2.6.32-orig/include/linux/inetdevice.h iDroid-Project-kernel_common-9e90fd2/include/linux/inetdevice.h
--- linux-2.6.32-orig/include/linux/inetdevice.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/inetdevice.h	2010-11-18 21:05:30.000000000 +0600
@@ -83,6 +83,7 @@
 #define IN_DEV_FORWARD(in_dev)		IN_DEV_CONF_GET((in_dev), FORWARDING)
 #define IN_DEV_MFORWARD(in_dev)		IN_DEV_ANDCONF((in_dev), MC_FORWARDING)
 #define IN_DEV_RPFILTER(in_dev)		IN_DEV_MAXCONF((in_dev), RP_FILTER)
+#define IN_DEV_SRC_VMARK(in_dev)    	IN_DEV_ORCONF((in_dev), SRC_VMARK)
 #define IN_DEV_SOURCE_ROUTE(in_dev)	IN_DEV_ANDCONF((in_dev), \
 						       ACCEPT_SOURCE_ROUTE)
 #define IN_DEV_BOOTP_RELAY(in_dev)	IN_DEV_ANDCONF((in_dev), BOOTP_RELAY)
diff -Nur linux-2.6.32-orig/include/linux/kernel_debugger.h iDroid-Project-kernel_common-9e90fd2/include/linux/kernel_debugger.h
--- linux-2.6.32-orig/include/linux/kernel_debugger.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/kernel_debugger.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,41 @@
+/*
+ * include/linux/kernel_debugger.h
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _LINUX_KERNEL_DEBUGGER_H_
+#define _LINUX_KERNEL_DEBUGGER_H_
+
+struct kdbg_ctxt {
+	int (*printf)(void *cookie, const char *fmt, ...);
+	void *cookie;
+};
+
+/* kernel_debugger() is called from IRQ context and should
+ * use the kdbg_ctxt.printf to write output (do NOT call
+ * printk, do operations not safe from IRQ context, etc).
+ *
+ * kdbg_ctxt.printf will return -1 if there is not enough
+ * buffer space or if you are being aborted.  In this case
+ * you must return as soon as possible.
+ *
+ * Return non-zero if more data is available -- if buffer
+ * space ran and you had to stop, but could print more,
+ * for example.
+ *
+ * Additional calls where cmd is "more" will be made if
+ * the additional data is desired.
+ */
+int kernel_debugger(struct kdbg_ctxt *ctxt, char *cmd);
+
+#endif
diff -Nur linux-2.6.32-orig/include/linux/keychord.h iDroid-Project-kernel_common-9e90fd2/include/linux/keychord.h
--- linux-2.6.32-orig/include/linux/keychord.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/keychord.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,52 @@
+/*
+ *  Key chord input driver
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#ifndef __LINUX_KEYCHORD_H_
+#define __LINUX_KEYCHORD_H_
+
+#include <linux/input.h>
+
+#define KEYCHORD_VERSION		1
+
+/*
+ * One or more input_keychord structs are written to /dev/keychord
+ * at once to specify the list of keychords to monitor.
+ * Reading /dev/keychord returns the id of a keychord when the
+ * keychord combination is pressed.  A keychord is signalled when
+ * all of the keys in the keycode list are in the pressed state.
+ * The order in which the keys are pressed does not matter.
+ * The keychord will not be signalled if keys not in the keycode
+ * list are pressed.
+ * Keychords will not be signalled on key release events.
+ */
+struct input_keychord {
+	/* should be KEYCHORD_VERSION */
+	__u16 version;
+	/*
+	 * client specified ID, returned from read()
+	 * when this keychord is pressed.
+	 */
+	__u16 id;
+
+	/* number of keycodes in this keychord */
+	__u16 count;
+
+	/* variable length array of keycodes */
+	__u16 keycodes[];
+};
+
+#endif	/* __LINUX_KEYCHORD_H_ */
diff -Nur linux-2.6.32-orig/include/linux/keyreset.h iDroid-Project-kernel_common-9e90fd2/include/linux/keyreset.h
--- linux-2.6.32-orig/include/linux/keyreset.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/keyreset.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,27 @@
+/*
+ * include/linux/keyreset.h - platform data structure for resetkeys driver
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_KEYRESET_H
+#define _LINUX_KEYRESET_H
+
+#define KEYRESET_NAME "keyreset"
+
+struct keyreset_platform_data {
+	int *keys_up;
+	int keys_down[]; /* 0 terminated */
+};
+
+#endif /* _LINUX_KEYRESET_H */
diff -Nur linux-2.6.32-orig/include/linux/kvm.h iDroid-Project-kernel_common-9e90fd2/include/linux/kvm.h
--- linux-2.6.32-orig/include/linux/kvm.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/kvm.h	2010-11-18 21:05:30.000000000 +0600
@@ -116,6 +116,11 @@
 	__u64 cr8;
 	__u64 apic_base;
 
+#ifdef __KVM_S390
+	/* the processor status word for s390 */
+	__u64 psw_mask; /* psw upper half */
+	__u64 psw_addr; /* psw lower half */
+#endif
 	union {
 		/* KVM_EXIT_UNKNOWN */
 		struct {
@@ -167,8 +172,6 @@
 		/* KVM_EXIT_S390_SIEIC */
 		struct {
 			__u8 icptcode;
-			__u64 mask; /* psw upper half */
-			__u64 addr; /* psw lower half */
 			__u16 ipa;
 			__u32 ipb;
 		} s390_sieic;
@@ -436,6 +439,7 @@
 #endif
 #define KVM_CAP_IOEVENTFD 36
 #define KVM_CAP_SET_IDENTITY_MAP_ADDR 37
+#define KVM_CAP_ADJUST_CLOCK 39
 
 #ifdef KVM_CAP_IRQ_ROUTING
 
@@ -474,6 +478,7 @@
 };
 
 #endif
+#define KVM_CAP_S390_PSW 42
 
 #ifdef KVM_CAP_MCE
 /* x86 MCE */
@@ -497,6 +502,12 @@
 	__u8  pad[20];
 };
 
+struct kvm_clock_data {
+	__u64 clock;
+	__u32 flags;
+	__u32 pad[9];
+};
+
 /*
  * ioctls for VM fds
  */
@@ -546,6 +557,8 @@
 #define KVM_CREATE_PIT2		   _IOW(KVMIO, 0x77, struct kvm_pit_config)
 #define KVM_SET_BOOT_CPU_ID        _IO(KVMIO, 0x78)
 #define KVM_IOEVENTFD             _IOW(KVMIO, 0x79, struct kvm_ioeventfd)
+#define KVM_SET_CLOCK             _IOW(KVMIO, 0x7b, struct kvm_clock_data)
+#define KVM_GET_CLOCK             _IOR(KVMIO, 0x7c, struct kvm_clock_data)
 
 /*
  * ioctls for vcpu fds
diff -Nur linux-2.6.32-orig/include/linux/libata.h iDroid-Project-kernel_common-9e90fd2/include/linux/libata.h
--- linux-2.6.32-orig/include/linux/libata.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/libata.h	2010-11-18 21:05:30.000000000 +0600
@@ -354,6 +354,9 @@
 	/* max tries if error condition is still set after ->error_handler */
 	ATA_EH_MAX_TRIES	= 5,
 
+	/* sometimes resuming a link requires several retries */
+	ATA_LINK_RESUME_TRIES	= 5,
+
 	/* how hard are we gonna try to probe/recover devices */
 	ATA_PROBE_MAX_TRIES	= 3,
 	ATA_EH_DEV_TRIES	= 3,
diff -Nur linux-2.6.32-orig/include/linux/linux_logo.h iDroid-Project-kernel_common-9e90fd2/include/linux/linux_logo.h
--- linux-2.6.32-orig/include/linux/linux_logo.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/linux_logo.h	2010-11-18 21:05:30.000000000 +0600
@@ -35,6 +35,7 @@
 extern const struct linux_logo logo_linux_mono;
 extern const struct linux_logo logo_linux_vga16;
 extern const struct linux_logo logo_linux_clut224;
+extern const struct linux_logo logo_android_clut224;
 extern const struct linux_logo logo_blackfin_vga16;
 extern const struct linux_logo logo_blackfin_clut224;
 extern const struct linux_logo logo_dec_clut224;
diff -Nur linux-2.6.32-orig/include/linux/mfd/wm8350/pmic.h iDroid-Project-kernel_common-9e90fd2/include/linux/mfd/wm8350/pmic.h
--- linux-2.6.32-orig/include/linux/mfd/wm8350/pmic.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/mfd/wm8350/pmic.h	2010-11-18 21:05:30.000000000 +0600
@@ -666,20 +666,20 @@
 #define WM8350_ISINK_FLASH_DUR_64MS		(1 << 8)
 #define WM8350_ISINK_FLASH_DUR_96MS		(2 << 8)
 #define WM8350_ISINK_FLASH_DUR_1024MS		(3 << 8)
-#define WM8350_ISINK_FLASH_ON_INSTANT		(0 << 4)
-#define WM8350_ISINK_FLASH_ON_0_25S		(1 << 4)
-#define WM8350_ISINK_FLASH_ON_0_50S		(2 << 4)
-#define WM8350_ISINK_FLASH_ON_1_00S		(3 << 4)
-#define WM8350_ISINK_FLASH_ON_1_95S		(1 << 4)
-#define WM8350_ISINK_FLASH_ON_3_91S		(2 << 4)
-#define WM8350_ISINK_FLASH_ON_7_80S		(3 << 4)
-#define WM8350_ISINK_FLASH_OFF_INSTANT		(0 << 0)
-#define WM8350_ISINK_FLASH_OFF_0_25S		(1 << 0)
-#define WM8350_ISINK_FLASH_OFF_0_50S		(2 << 0)
-#define WM8350_ISINK_FLASH_OFF_1_00S		(3 << 0)
-#define WM8350_ISINK_FLASH_OFF_1_95S		(1 << 0)
-#define WM8350_ISINK_FLASH_OFF_3_91S		(2 << 0)
-#define WM8350_ISINK_FLASH_OFF_7_80S		(3 << 0)
+#define WM8350_ISINK_FLASH_ON_INSTANT		(0 << 0)
+#define WM8350_ISINK_FLASH_ON_0_25S		(1 << 0)
+#define WM8350_ISINK_FLASH_ON_0_50S		(2 << 0)
+#define WM8350_ISINK_FLASH_ON_1_00S		(3 << 0)
+#define WM8350_ISINK_FLASH_ON_1_95S		(1 << 0)
+#define WM8350_ISINK_FLASH_ON_3_91S		(2 << 0)
+#define WM8350_ISINK_FLASH_ON_7_80S		(3 << 0)
+#define WM8350_ISINK_FLASH_OFF_INSTANT		(0 << 4)
+#define WM8350_ISINK_FLASH_OFF_0_25S		(1 << 4)
+#define WM8350_ISINK_FLASH_OFF_0_50S		(2 << 4)
+#define WM8350_ISINK_FLASH_OFF_1_00S		(3 << 4)
+#define WM8350_ISINK_FLASH_OFF_1_95S		(1 << 4)
+#define WM8350_ISINK_FLASH_OFF_3_91S		(2 << 4)
+#define WM8350_ISINK_FLASH_OFF_7_80S		(3 << 4)
 
 /*
  * Regulator Interrupts.
diff -Nur linux-2.6.32-orig/include/linux/mmc/host.h iDroid-Project-kernel_common-9e90fd2/include/linux/mmc/host.h
--- linux-2.6.32-orig/include/linux/mmc/host.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/mmc/host.h	2010-11-18 21:05:30.000000000 +0600
@@ -193,6 +193,10 @@
 	const struct mmc_bus_ops *bus_ops;	/* current bus driver */
 	unsigned int		bus_refs;	/* reference counter */
 
+	unsigned int		bus_resume_flags;
+#define MMC_BUSRESUME_MANUAL_RESUME	(1 << 0)
+#define MMC_BUSRESUME_NEEDS_RESUME	(1 << 1)
+
 	unsigned int		sdio_irqs;
 	struct task_struct	*sdio_irq_thread;
 	atomic_t		sdio_irq_thread_abort;
@@ -203,6 +207,15 @@
 
 	struct dentry		*debugfs_root;
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	struct {
+		struct sdio_cis			*cis;
+		struct sdio_cccr		*cccr;
+		struct sdio_embedded_func	*funcs;
+		int				num_funcs;
+	} embedded_sdio_data;
+#endif
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 
@@ -211,6 +224,14 @@
 extern void mmc_remove_host(struct mmc_host *);
 extern void mmc_free_host(struct mmc_host *);
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+extern void mmc_set_embedded_sdio_data(struct mmc_host *host,
+				       struct sdio_cis *cis,
+				       struct sdio_cccr *cccr,
+				       struct sdio_embedded_func *funcs,
+				       int num_funcs);
+#endif
+
 static inline void *mmc_priv(struct mmc_host *host)
 {
 	return (void *)host->private;
@@ -221,6 +242,17 @@
 #define mmc_dev(x)	((x)->parent)
 #define mmc_classdev(x)	(&(x)->class_dev)
 #define mmc_hostname(x)	(dev_name(&(x)->class_dev))
+#define mmc_bus_needs_resume(host) ((host)->bus_resume_flags & MMC_BUSRESUME_NEEDS_RESUME)
+
+static inline void mmc_set_bus_resume_policy(struct mmc_host *host, int manual)
+{
+	if (manual)
+		host->bus_resume_flags |= MMC_BUSRESUME_MANUAL_RESUME;
+	else
+		host->bus_resume_flags &= ~MMC_BUSRESUME_MANUAL_RESUME;
+}
+
+extern int mmc_resume_bus(struct mmc_host *host);
 
 extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
 extern int mmc_resume_host(struct mmc_host *);
diff -Nur linux-2.6.32-orig/include/linux/mmc/sdio_func.h iDroid-Project-kernel_common-9e90fd2/include/linux/mmc/sdio_func.h
--- linux-2.6.32-orig/include/linux/mmc/sdio_func.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/mmc/sdio_func.h	2010-11-18 21:05:30.000000000 +0600
@@ -21,6 +21,14 @@
 typedef void (sdio_irq_handler_t)(struct sdio_func *);
 
 /*
+ * Structure used to hold embedded SDIO device data from platform layer
+ */
+struct sdio_embedded_func {
+	uint8_t f_class;
+	uint32_t f_maxblksize;
+};
+
+/*
  * SDIO function CIS tuple (unknown to the core)
  */
 struct sdio_func_tuple {
@@ -128,6 +136,8 @@
 extern unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz);
 
 extern u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret);
+extern u8 sdio_readb_ext(struct sdio_func *func, unsigned int addr, int *err_ret,
+	unsigned in);
 extern u16 sdio_readw(struct sdio_func *func, unsigned int addr, int *err_ret);
 extern u32 sdio_readl(struct sdio_func *func, unsigned int addr, int *err_ret);
 
diff -Nur linux-2.6.32-orig/include/linux/mm.h iDroid-Project-kernel_common-9e90fd2/include/linux/mm.h
--- linux-2.6.32-orig/include/linux/mm.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/mm.h	2010-11-18 21:05:30.000000000 +0600
@@ -713,6 +713,7 @@
 
 int shmem_lock(struct file *file, int lock, struct user_struct *user);
 struct file *shmem_file_setup(const char *name, loff_t size, unsigned long flags);
+void shmem_set_file(struct vm_area_struct *vma, struct file *file);
 int shmem_zero_setup(struct vm_area_struct *);
 
 #ifndef CONFIG_MMU
diff -Nur linux-2.6.32-orig/include/linux/msdos_fs.h iDroid-Project-kernel_common-9e90fd2/include/linux/msdos_fs.h
--- linux-2.6.32-orig/include/linux/msdos_fs.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/msdos_fs.h	2010-11-18 21:05:30.000000000 +0600
@@ -100,6 +100,7 @@
 /* <linux/videotext.h> has used 0x72 ('r') in collision, so skip a few */
 #define FAT_IOCTL_GET_ATTRIBUTES	_IOR('r', 0x10, __u32)
 #define FAT_IOCTL_SET_ATTRIBUTES	_IOW('r', 0x11, __u32)
+#define VFAT_IOCTL_GET_VOLUME_ID	_IOR('r', 0x12, __u32)
 
 struct fat_boot_sector {
 	__u8	ignored[3];	/* Boot strap short or near jump */
@@ -137,6 +138,17 @@
 	__le32   reserved2[4];
 };
 
+struct fat_boot_bsx {
+	__u8     drive;		    /* drive number */
+	__u8     reserved1;
+	__u8     signature;	    /* extended boot signature */
+	__u8     vol_id[4];     /* volume ID */
+	__u8     vol_label[11]; /* volume label */
+	__u8     type[8];       /* file system type */
+};
+#define FAT16_BSX_OFFSET	36 /* offset of fat_boot_bsx in FAT12 and FAT16 */
+#define FAT32_BSX_OFFSET	64 /* offset of fat_boot_bsx in FAT32 */
+
 struct msdos_dir_entry {
 	__u8	name[MSDOS_NAME];/* name and extension */
 	__u8	attr;		/* attribute bits */
diff -Nur linux-2.6.32-orig/include/linux/netfilter/xt_CONNMARK.h iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter/xt_CONNMARK.h
--- linux-2.6.32-orig/include/linux/netfilter/xt_CONNMARK.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter/xt_CONNMARK.h	2010-11-18 21:05:30.000000000 +0600
@@ -1,5 +1,5 @@
-#ifndef _XT_CONNMARK_H_target
-#define _XT_CONNMARK_H_target
+#ifndef _XT_CONNMARK_H
+#define _XT_CONNMARK_H
 
 #include <linux/types.h>
 
@@ -12,15 +12,9 @@
  * (at your option) any later version.
  */
 
-enum {
-	XT_CONNMARK_SET = 0,
-	XT_CONNMARK_SAVE,
-	XT_CONNMARK_RESTORE
+struct xt_connmark_mtinfo1 {
+	__u32 mark, mask;
+	__u8 invert;
 };
 
-struct xt_connmark_tginfo1 {
-	__u32 ctmark, ctmask, nfmask;
-	__u8 mode;
-};
-
-#endif /*_XT_CONNMARK_H_target*/
+#endif /*_XT_CONNMARK_H*/
diff -Nur linux-2.6.32-orig/include/linux/netfilter/xt_DSCP.h iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter/xt_DSCP.h
--- linux-2.6.32-orig/include/linux/netfilter/xt_DSCP.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter/xt_DSCP.h	2010-11-18 21:05:30.000000000 +0600
@@ -1,26 +1,31 @@
-/* x_tables module for setting the IPv4/IPv6 DSCP field
+/* x_tables module for matching the IPv4/IPv6 DSCP field
  *
  * (C) 2002 Harald Welte <laforge@gnumonks.org>
- * based on ipt_FTOS.c (C) 2000 by Matthew G. Marsh <mgm@paktronix.com>
  * This software is distributed under GNU GPL v2, 1991
  *
  * See RFC2474 for a description of the DSCP field within the IP Header.
  *
- * xt_DSCP.h,v 1.7 2002/03/14 12:03:13 laforge Exp
+ * xt_dscp.h,v 1.3 2002/08/05 19:00:21 laforge Exp
 */
-#ifndef _XT_DSCP_TARGET_H
-#define _XT_DSCP_TARGET_H
-#include <linux/netfilter/xt_dscp.h>
+#ifndef _XT_DSCP_H
+#define _XT_DSCP_H
+
 #include <linux/types.h>
 
-/* target info */
-struct xt_DSCP_info {
+#define XT_DSCP_MASK	0xfc	/* 11111100 */
+#define XT_DSCP_SHIFT	2
+#define XT_DSCP_MAX	0x3f	/* 00111111 */
+
+/* match info */
+struct xt_dscp_info {
 	__u8 dscp;
+	__u8 invert;
 };
 
-struct xt_tos_target_info {
-	__u8 tos_value;
+struct xt_tos_match_info {
 	__u8 tos_mask;
+	__u8 tos_value;
+	__u8 invert;
 };
 
-#endif /* _XT_DSCP_TARGET_H */
+#endif /* _XT_DSCP_H */
diff -Nur linux-2.6.32-orig/include/linux/netfilter/xt_MARK.h iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter/xt_MARK.h
--- linux-2.6.32-orig/include/linux/netfilter/xt_MARK.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter/xt_MARK.h	2010-11-18 21:05:30.000000000 +0600
@@ -1,10 +1,11 @@
-#ifndef _XT_MARK_H_target
-#define _XT_MARK_H_target
+#ifndef _XT_MARK_H
+#define _XT_MARK_H
 
 #include <linux/types.h>
 
-struct xt_mark_tginfo2 {
+struct xt_mark_mtinfo1 {
 	__u32 mark, mask;
+	__u8 invert;
 };
 
-#endif /*_XT_MARK_H_target */
+#endif /*_XT_MARK_H*/
diff -Nur linux-2.6.32-orig/include/linux/netfilter/xt_RATEEST.h iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter/xt_RATEEST.h
--- linux-2.6.32-orig/include/linux/netfilter/xt_RATEEST.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter/xt_RATEEST.h	2010-11-18 21:05:30.000000000 +0600
@@ -1,15 +1,37 @@
-#ifndef _XT_RATEEST_TARGET_H
-#define _XT_RATEEST_TARGET_H
+#ifndef _XT_RATEEST_MATCH_H
+#define _XT_RATEEST_MATCH_H
 
 #include <linux/types.h>
 
-struct xt_rateest_target_info {
-	char			name[IFNAMSIZ];
-	__s8			interval;
-	__u8		ewma_log;
+enum xt_rateest_match_flags {
+	XT_RATEEST_MATCH_INVERT	= 1<<0,
+	XT_RATEEST_MATCH_ABS	= 1<<1,
+	XT_RATEEST_MATCH_REL	= 1<<2,
+	XT_RATEEST_MATCH_DELTA	= 1<<3,
+	XT_RATEEST_MATCH_BPS	= 1<<4,
+	XT_RATEEST_MATCH_PPS	= 1<<5,
+};
+
+enum xt_rateest_match_mode {
+	XT_RATEEST_MATCH_NONE,
+	XT_RATEEST_MATCH_EQ,
+	XT_RATEEST_MATCH_LT,
+	XT_RATEEST_MATCH_GT,
+};
+
+struct xt_rateest_match_info {
+	char			name1[IFNAMSIZ];
+	char			name2[IFNAMSIZ];
+	__u16		flags;
+	__u16		mode;
+	__u32		bps1;
+	__u32		pps1;
+	__u32		bps2;
+	__u32		pps2;
 
 	/* Used internally by the kernel */
-	struct xt_rateest	*est __attribute__((aligned(8)));
+	struct xt_rateest	*est1 __attribute__((aligned(8)));
+	struct xt_rateest	*est2 __attribute__((aligned(8)));
 };
 
-#endif /* _XT_RATEEST_TARGET_H */
+#endif /* _XT_RATEEST_MATCH_H */
diff -Nur linux-2.6.32-orig/include/linux/netfilter/xt_TCPMSS.h iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter/xt_TCPMSS.h
--- linux-2.6.32-orig/include/linux/netfilter/xt_TCPMSS.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter/xt_TCPMSS.h	2010-11-18 21:05:30.000000000 +0600
@@ -1,12 +1,11 @@
-#ifndef _XT_TCPMSS_H
-#define _XT_TCPMSS_H
+#ifndef _XT_TCPMSS_MATCH_H
+#define _XT_TCPMSS_MATCH_H
 
 #include <linux/types.h>
 
-struct xt_tcpmss_info {
-	__u16 mss;
+struct xt_tcpmss_match_info {
+    __u16 mss_min, mss_max;
+    __u8 invert;
 };
 
-#define XT_TCPMSS_CLAMP_PMTU 0xffff
-
-#endif /* _XT_TCPMSS_H */
+#endif /*_XT_TCPMSS_MATCH_H*/
diff -Nur linux-2.6.32-orig/include/linux/netfilter_ipv4/ipt_ECN.h iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter_ipv4/ipt_ECN.h
--- linux-2.6.32-orig/include/linux/netfilter_ipv4/ipt_ECN.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter_ipv4/ipt_ECN.h	2010-11-18 21:05:30.000000000 +0600
@@ -1,31 +1,33 @@
-/* Header file for iptables ipt_ECN target
+/* iptables module for matching the ECN header in IPv4 and TCP header
  *
- * (C) 2002 by Harald Welte <laforge@gnumonks.org>
+ * (C) 2002 Harald Welte <laforge@gnumonks.org>
  *
  * This software is distributed under GNU GPL v2, 1991
  * 
- * ipt_ECN.h,v 1.3 2002/05/29 12:17:40 laforge Exp
+ * ipt_ecn.h,v 1.4 2002/08/05 19:39:00 laforge Exp
 */
-#ifndef _IPT_ECN_TARGET_H
-#define _IPT_ECN_TARGET_H
-#include <linux/netfilter/xt_DSCP.h>
+#ifndef _IPT_ECN_H
+#define _IPT_ECN_H
+#include <linux/netfilter/xt_dscp.h>
 
 #define IPT_ECN_IP_MASK	(~XT_DSCP_MASK)
 
-#define IPT_ECN_OP_SET_IP	0x01	/* set ECN bits of IPv4 header */
-#define IPT_ECN_OP_SET_ECE	0x10	/* set ECE bit of TCP header */
-#define IPT_ECN_OP_SET_CWR	0x20	/* set CWR bit of TCP header */
+#define IPT_ECN_OP_MATCH_IP	0x01
+#define IPT_ECN_OP_MATCH_ECE	0x10
+#define IPT_ECN_OP_MATCH_CWR	0x20
 
-#define IPT_ECN_OP_MASK		0xce
+#define IPT_ECN_OP_MATCH_MASK	0xce
 
-struct ipt_ECN_info {
-	u_int8_t operation;	/* bitset of operations */
-	u_int8_t ip_ect;	/* ECT codepoint of IPv4 header, pre-shifted */
+/* match info */
+struct ipt_ecn_info {
+	u_int8_t operation;
+	u_int8_t invert;
+	u_int8_t ip_ect;
 	union {
 		struct {
-			u_int8_t ece:1, cwr:1; /* TCP ECT bits */
+			u_int8_t ect;
 		} tcp;
 	} proto;
 };
 
-#endif /* _IPT_ECN_TARGET_H */
+#endif /* _IPT_ECN_H */
diff -Nur linux-2.6.32-orig/include/linux/netfilter_ipv4/ipt_TTL.h iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter_ipv4/ipt_TTL.h
--- linux-2.6.32-orig/include/linux/netfilter_ipv4/ipt_TTL.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter_ipv4/ipt_TTL.h	2010-11-18 21:05:30.000000000 +0600
@@ -1,18 +1,18 @@
-/* TTL modification module for IP tables
- * (C) 2000 by Harald Welte <laforge@netfilter.org> */
+/* IP tables module for matching the value of the TTL
+ * (C) 2000 by Harald Welte <laforge@gnumonks.org> */
 
 #ifndef _IPT_TTL_H
 #define _IPT_TTL_H
 
 enum {
-	IPT_TTL_SET = 0,
-	IPT_TTL_INC,
-	IPT_TTL_DEC
+	IPT_TTL_EQ = 0,		/* equals */
+	IPT_TTL_NE,		/* not equals */
+	IPT_TTL_LT,		/* less than */
+	IPT_TTL_GT,		/* greater than */
 };
 
-#define IPT_TTL_MAXMODE	IPT_TTL_DEC
 
-struct ipt_TTL_info {
+struct ipt_ttl_info {
 	u_int8_t	mode;
 	u_int8_t	ttl;
 };
diff -Nur linux-2.6.32-orig/include/linux/netfilter_ipv6/ip6t_HL.h iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter_ipv6/ip6t_HL.h
--- linux-2.6.32-orig/include/linux/netfilter_ipv6/ip6t_HL.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/netfilter_ipv6/ip6t_HL.h	2010-11-18 21:05:30.000000000 +0600
@@ -1,19 +1,19 @@
-/* Hop Limit modification module for ip6tables
+/* ip6tables module for matching the Hop Limit value
  * Maciej Soltysiak <solt@dns.toxicfilms.tv>
- * Based on HW's TTL module */
+ * Based on HW's ttl module */
 
 #ifndef _IP6T_HL_H
 #define _IP6T_HL_H
 
 enum {
-	IP6T_HL_SET = 0,
-	IP6T_HL_INC,
-	IP6T_HL_DEC
+	IP6T_HL_EQ = 0,		/* equals */
+	IP6T_HL_NE,		/* not equals */
+	IP6T_HL_LT,		/* less than */
+	IP6T_HL_GT,		/* greater than */
 };
 
-#define IP6T_HL_MAXMODE	IP6T_HL_DEC
 
-struct ip6t_HL_info {
+struct ip6t_hl_info {
 	u_int8_t	mode;
 	u_int8_t	hop_limit;
 };
diff -Nur linux-2.6.32-orig/include/linux/pagemap.h iDroid-Project-kernel_common-9e90fd2/include/linux/pagemap.h
--- linux-2.6.32-orig/include/linux/pagemap.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/pagemap.h	2010-11-18 21:05:30.000000000 +0600
@@ -253,6 +253,8 @@
 extern struct page * read_cache_page(struct address_space *mapping,
 				pgoff_t index, filler_t *filler,
 				void *data);
+extern struct page * read_cache_page_gfp(struct address_space *mapping,
+				pgoff_t index, gfp_t gfp_mask);
 extern int read_cache_pages(struct address_space *mapping,
 		struct list_head *pages, filler_t *filler, void *data);
 
diff -Nur linux-2.6.32-orig/include/linux/pci.h iDroid-Project-kernel_common-9e90fd2/include/linux/pci.h
--- linux-2.6.32-orig/include/linux/pci.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/pci.h	2010-11-18 21:05:30.000000000 +0600
@@ -564,6 +564,9 @@
 				resource_size_t);
 void pcibios_update_irq(struct pci_dev *, int irq);
 
+/* Weak but can be overriden by arch */
+void pci_fixup_cardbus(struct pci_bus *);
+
 /* Generic PCI functions used internally */
 
 extern struct pci_bus *pci_find_bus(int domain, int busnr);
diff -Nur linux-2.6.32-orig/include/linux/pci_ids.h iDroid-Project-kernel_common-9e90fd2/include/linux/pci_ids.h
--- linux-2.6.32-orig/include/linux/pci_ids.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/pci_ids.h	2010-11-18 21:05:30.000000000 +0600
@@ -2290,6 +2290,20 @@
 #define PCI_DEVICE_ID_MPC8536		0x0051
 #define PCI_DEVICE_ID_P2020E		0x0070
 #define PCI_DEVICE_ID_P2020		0x0071
+#define PCI_DEVICE_ID_P2010E		0x0078
+#define PCI_DEVICE_ID_P2010		0x0079
+#define PCI_DEVICE_ID_P1020E		0x0100
+#define PCI_DEVICE_ID_P1020		0x0101
+#define PCI_DEVICE_ID_P1011E		0x0108
+#define PCI_DEVICE_ID_P1011		0x0109
+#define PCI_DEVICE_ID_P1022E		0x0110
+#define PCI_DEVICE_ID_P1022		0x0111
+#define PCI_DEVICE_ID_P1013E		0x0118
+#define PCI_DEVICE_ID_P1013		0x0119
+#define PCI_DEVICE_ID_P4080E		0x0400
+#define PCI_DEVICE_ID_P4080		0x0401
+#define PCI_DEVICE_ID_P4040E		0x0408
+#define PCI_DEVICE_ID_P4040		0x0409
 #define PCI_DEVICE_ID_MPC8641		0x7010
 #define PCI_DEVICE_ID_MPC8641D		0x7011
 #define PCI_DEVICE_ID_MPC8610		0x7018
diff -Nur linux-2.6.32-orig/include/linux/perf_event.h iDroid-Project-kernel_common-9e90fd2/include/linux/perf_event.h
--- linux-2.6.32-orig/include/linux/perf_event.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/perf_event.h	2010-11-18 21:05:30.000000000 +0600
@@ -219,7 +219,7 @@
 #define PERF_EVENT_IOC_DISABLE		_IO ('$', 1)
 #define PERF_EVENT_IOC_REFRESH		_IO ('$', 2)
 #define PERF_EVENT_IOC_RESET		_IO ('$', 3)
-#define PERF_EVENT_IOC_PERIOD		_IOW('$', 4, u64)
+#define PERF_EVENT_IOC_PERIOD		_IOW('$', 4, __u64)
 #define PERF_EVENT_IOC_SET_OUTPUT	_IO ('$', 5)
 
 enum perf_event_ioc_flags {
diff -Nur linux-2.6.32-orig/include/linux/power_supply.h iDroid-Project-kernel_common-9e90fd2/include/linux/power_supply.h
--- linux-2.6.32-orig/include/linux/power_supply.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/power_supply.h	2010-11-18 21:05:30.000000000 +0600
@@ -14,6 +14,7 @@
 #define __LINUX_POWER_SUPPLY_H__
 
 #include <linux/device.h>
+#include <linux/wakelock.h>
 #include <linux/workqueue.h>
 #include <linux/leds.h>
 
@@ -152,6 +153,9 @@
 	/* private */
 	struct device *dev;
 	struct work_struct changed_work;
+	spinlock_t changed_lock;
+	bool changed;
+	struct wake_lock work_wake_lock;
 
 #ifdef CONFIG_LEDS_TRIGGERS
 	struct led_trigger *charging_full_trig;
diff -Nur linux-2.6.32-orig/include/linux/quota.h iDroid-Project-kernel_common-9e90fd2/include/linux/quota.h
--- linux-2.6.32-orig/include/linux/quota.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/quota.h	2010-11-18 21:05:30.000000000 +0600
@@ -313,8 +313,9 @@
 	int (*claim_space) (struct inode *, qsize_t);
 	/* release rsved quota for delayed alloc */
 	void (*release_rsv) (struct inode *, qsize_t);
-	/* get reserved quota for delayed alloc */
-	qsize_t (*get_reserved_space) (struct inode *);
+	/* get reserved quota for delayed alloc, value returned is managed by
+	 * quota code only */
+	qsize_t *(*get_reserved_space) (struct inode *);
 };
 
 /* Operations handling requests from userspace */
diff -Nur linux-2.6.32-orig/include/linux/sched.h iDroid-Project-kernel_common-9e90fd2/include/linux/sched.h
--- linux-2.6.32-orig/include/linux/sched.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/sched.h	2010-11-18 21:05:30.000000000 +0600
@@ -1354,7 +1354,7 @@
 	char comm[TASK_COMM_LEN]; /* executable name excluding path
 				     - access with [gs]et_task_comm (which lock
 				       it with task_lock())
-				     - initialized normally by flush_old_exec */
+				     - initialized normally by setup_new_exec */
 /* file system info */
 	int link_count, total_link_count;
 #ifdef CONFIG_SYSVIPC
@@ -1724,6 +1724,9 @@
 extern cputime_t task_stime(struct task_struct *p);
 extern cputime_t task_gtime(struct task_struct *p);
 
+extern int task_free_register(struct notifier_block *n);
+extern int task_free_unregister(struct notifier_block *n);
+
 /*
  * Per process flags
  */
@@ -2086,11 +2089,18 @@
 	return info <= SEND_SIG_FORCED;
 }
 
-/* True if we are on the alternate signal stack.  */
-
+/*
+ * True if we are on the alternate signal stack.
+ */
 static inline int on_sig_stack(unsigned long sp)
 {
-	return (sp - current->sas_ss_sp < current->sas_ss_size);
+#ifdef CONFIG_STACK_GROWSUP
+	return sp >= current->sas_ss_sp &&
+		sp - current->sas_ss_sp < current->sas_ss_size;
+#else
+	return sp > current->sas_ss_sp &&
+		sp - current->sas_ss_sp <= current->sas_ss_size;
+#endif
 }
 
 static inline int sas_ss_flags(unsigned long sp)
@@ -2576,6 +2586,28 @@
 
 #define TASK_STATE_TO_CHAR_STR "RSDTtZX"
 
+static inline unsigned long task_rlimit(const struct task_struct *tsk,
+		unsigned int limit)
+{
+	return ACCESS_ONCE(tsk->signal->rlim[limit].rlim_cur);
+}
+
+static inline unsigned long task_rlimit_max(const struct task_struct *tsk,
+		unsigned int limit)
+{
+	return ACCESS_ONCE(tsk->signal->rlim[limit].rlim_max);
+}
+
+static inline unsigned long rlimit(unsigned int limit)
+{
+	return task_rlimit(current, limit);
+}
+
+static inline unsigned long rlimit_max(unsigned int limit)
+{
+	return task_rlimit_max(current, limit);
+}
+
 #endif /* __KERNEL__ */
 
 #endif
diff -Nur linux-2.6.32-orig/include/linux/security.h iDroid-Project-kernel_common-9e90fd2/include/linux/security.h
--- linux-2.6.32-orig/include/linux/security.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/security.h	2010-11-18 21:05:30.000000000 +0600
@@ -95,8 +95,13 @@
 extern int cap_netlink_send(struct sock *sk, struct sk_buff *skb);
 extern int cap_netlink_recv(struct sk_buff *skb, int cap);
 
+#ifdef CONFIG_MMU
 extern unsigned long mmap_min_addr;
 extern unsigned long dac_mmap_min_addr;
+#else
+#define dac_mmap_min_addr	0UL
+#endif
+
 /*
  * Values used in the task_security_ops calls
  */
@@ -121,6 +126,7 @@
 #define LSM_UNSAFE_PTRACE	2
 #define LSM_UNSAFE_PTRACE_CAP	4
 
+#ifdef CONFIG_MMU
 /*
  * If a hint addr is less than mmap_min_addr change hint to be as
  * low as possible but still greater than mmap_min_addr
@@ -135,6 +141,7 @@
 }
 extern int mmap_min_addr_handler(struct ctl_table *table, int write,
 				 void __user *buffer, size_t *lenp, loff_t *ppos);
+#endif
 
 #ifdef CONFIG_SECURITY
 
diff -Nur linux-2.6.32-orig/include/linux/serial_core.h iDroid-Project-kernel_common-9e90fd2/include/linux/serial_core.h
--- linux-2.6.32-orig/include/linux/serial_core.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/serial_core.h	2010-11-18 21:05:30.000000000 +0600
@@ -217,6 +217,7 @@
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
 	int		(*set_wake)(struct uart_port *, unsigned int state);
+	void		(*wake_peer)(struct uart_port *);
 
 	/*
 	 * Return a string describing the type of the port
diff -Nur linux-2.6.32-orig/include/linux/sockios.h iDroid-Project-kernel_common-9e90fd2/include/linux/sockios.h
--- linux-2.6.32-orig/include/linux/sockios.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/sockios.h	2010-11-18 21:05:30.000000000 +0600
@@ -65,6 +65,7 @@
 #define SIOCDIFADDR	0x8936		/* delete PA address		*/
 #define	SIOCSIFHWBROADCAST	0x8937	/* set hardware broadcast addr	*/
 #define SIOCGIFCOUNT	0x8938		/* get number of devices */
+#define SIOCKILLADDR	0x8939		/* kill sockets with this local addr */
 
 #define SIOCGIFBR	0x8940		/* Bridging support		*/
 #define SIOCSIFBR	0x8941		/* Set bridging options 	*/
diff -Nur linux-2.6.32-orig/include/linux/switch.h iDroid-Project-kernel_common-9e90fd2/include/linux/switch.h
--- linux-2.6.32-orig/include/linux/switch.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/switch.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,56 @@
+/*
+ *  Switch class driver
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#ifndef __LINUX_SWITCH_H__
+#define __LINUX_SWITCH_H__
+
+struct switch_dev {
+	const char	*name;
+	struct device	*dev;
+	int		index;
+	int		state;
+
+	ssize_t	(*print_name)(struct switch_dev *sdev, char *buf);
+	ssize_t	(*print_state)(struct switch_dev *sdev, char *buf);
+};
+
+struct gpio_switch_platform_data {
+	const char *name;
+	unsigned 	gpio;
+
+	/* if NULL, switch_dev.name will be printed */
+	const char *name_on;
+	const char *name_off;
+	/* if NULL, "0" or "1" will be printed */
+	const char *state_on;
+	const char *state_off;
+
+	/* if 0, IRQF_TRIGGER_LOW will be used */ 
+	int irq_flags;
+};
+
+extern int switch_dev_register(struct switch_dev *sdev);
+extern void switch_dev_unregister(struct switch_dev *sdev);
+
+static inline int switch_get_state(struct switch_dev *sdev)
+{
+	return sdev->state;
+}
+
+extern void switch_set_state(struct switch_dev *sdev, int state);
+
+#endif /* __LINUX_SWITCH_H__ */
diff -Nur linux-2.6.32-orig/include/linux/synaptics_i2c_rmi.h iDroid-Project-kernel_common-9e90fd2/include/linux/synaptics_i2c_rmi.h
--- linux-2.6.32-orig/include/linux/synaptics_i2c_rmi.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/synaptics_i2c_rmi.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,55 @@
+/*
+ * include/linux/synaptics_i2c_rmi.h - platform data structure for f75375s sensor
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_SYNAPTICS_I2C_RMI_H
+#define _LINUX_SYNAPTICS_I2C_RMI_H
+
+#define SYNAPTICS_I2C_RMI_NAME "synaptics-rmi-ts"
+
+enum {
+	SYNAPTICS_FLIP_X = 1UL << 0,
+	SYNAPTICS_FLIP_Y = 1UL << 1,
+	SYNAPTICS_SWAP_XY = 1UL << 2,
+	SYNAPTICS_SNAP_TO_INACTIVE_EDGE = 1UL << 3,
+};
+
+struct synaptics_i2c_rmi_platform_data {
+	uint32_t version;	/* Use this entry for panels with */
+				/* (major << 8 | minor) version or above. */
+				/* If non-zero another array entry follows */
+	int (*power)(int on);	/* Only valid in first array entry */
+	uint32_t flags;
+	unsigned long irqflags;
+	uint32_t inactive_left; /* 0x10000 = screen width */
+	uint32_t inactive_right; /* 0x10000 = screen width */
+	uint32_t inactive_top; /* 0x10000 = screen height */
+	uint32_t inactive_bottom; /* 0x10000 = screen height */
+	uint32_t snap_left_on; /* 0x10000 = screen width */
+	uint32_t snap_left_off; /* 0x10000 = screen width */
+	uint32_t snap_right_on; /* 0x10000 = screen width */
+	uint32_t snap_right_off; /* 0x10000 = screen width */
+	uint32_t snap_top_on; /* 0x10000 = screen height */
+	uint32_t snap_top_off; /* 0x10000 = screen height */
+	uint32_t snap_bottom_on; /* 0x10000 = screen height */
+	uint32_t snap_bottom_off; /* 0x10000 = screen height */
+	uint32_t fuzz_x; /* 0x10000 = screen width */
+	uint32_t fuzz_y; /* 0x10000 = screen height */
+	int fuzz_p;
+	int fuzz_w;
+	int8_t sensitivity_adjust;
+};
+
+#endif /* _LINUX_SYNAPTICS_I2C_RMI_H */
diff -Nur linux-2.6.32-orig/include/linux/syscalls.h iDroid-Project-kernel_common-9e90fd2/include/linux/syscalls.h
--- linux-2.6.32-orig/include/linux/syscalls.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/syscalls.h	2010-11-18 21:05:30.000000000 +0600
@@ -879,4 +879,8 @@
 asmlinkage long sys_perf_event_open(
 		struct perf_event_attr __user *attr_uptr,
 		pid_t pid, int cpu, int group_fd, unsigned long flags);
+
+asmlinkage long sys_mmap_pgoff(unsigned long addr, unsigned long len,
+			unsigned long prot, unsigned long flags,
+			unsigned long fd, unsigned long pgoff);
 #endif
diff -Nur linux-2.6.32-orig/include/linux/sysctl.h iDroid-Project-kernel_common-9e90fd2/include/linux/sysctl.h
--- linux-2.6.32-orig/include/linux/sysctl.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/sysctl.h	2010-11-18 21:05:30.000000000 +0600
@@ -490,6 +490,7 @@
 	NET_IPV4_CONF_PROMOTE_SECONDARIES=20,
 	NET_IPV4_CONF_ARP_ACCEPT=21,
 	NET_IPV4_CONF_ARP_NOTIFY=22,
+	NET_IPV4_CONF_SRC_VMARK=24,
 	__NET_IPV4_CONF_MAX
 };
 
diff -Nur linux-2.6.32-orig/include/linux/timed_output.h iDroid-Project-kernel_common-9e90fd2/include/linux/timed_output.h
--- linux-2.6.32-orig/include/linux/timed_output.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/timed_output.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,37 @@
+/* include/linux/timed_output.h
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#ifndef _LINUX_TIMED_OUTPUT_H
+#define _LINUX_TIMED_OUTPUT_H
+
+struct timed_output_dev {
+	const char	*name;
+
+	/* enable the output and set the timer */
+	void	(*enable)(struct timed_output_dev *sdev, int timeout);
+
+	/* returns the current number of milliseconds remaining on the timer */
+	int		(*get_time)(struct timed_output_dev *sdev);
+
+	/* private data */
+	struct device	*dev;
+	int		index;
+	int		state;
+};
+
+extern int timed_output_dev_register(struct timed_output_dev *dev);
+extern void timed_output_dev_unregister(struct timed_output_dev *dev);
+
+#endif
diff -Nur linux-2.6.32-orig/include/linux/time.h iDroid-Project-kernel_common-9e90fd2/include/linux/time.h
--- linux-2.6.32-orig/include/linux/time.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/time.h	2010-11-18 21:05:30.000000000 +0600
@@ -148,6 +148,7 @@
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_valid_for_hres(void);
+extern u64 timekeeping_max_deferment(void);
 extern void update_wall_time(void);
 extern void update_xtime_cache(u64 nsec);
 extern void timekeeping_leap_insert(int leapsecond);
diff -Nur linux-2.6.32-orig/include/linux/uid_stat.h iDroid-Project-kernel_common-9e90fd2/include/linux/uid_stat.h
--- linux-2.6.32-orig/include/linux/uid_stat.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/uid_stat.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,24 @@
+/* include/linux/uid_stat.h
+ *
+ * Copyright (C) 2008-2009 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __uid_stat_h
+#define __uid_stat_h
+
+/* Contains definitions for resource tracking per uid. */
+
+extern int update_tcp_snd(uid_t uid, int size);
+extern int update_tcp_rcv(uid_t uid, int size);
+
+#endif /* _LINUX_UID_STAT_H */
diff -Nur linux-2.6.32-orig/include/linux/usb/android_composite.h iDroid-Project-kernel_common-9e90fd2/include/linux/usb/android_composite.h
--- linux-2.6.32-orig/include/linux/usb/android_composite.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/usb/android_composite.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,98 @@
+/*
+ * Platform data for Android USB
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef	__LINUX_USB_ANDROID_H
+#define	__LINUX_USB_ANDROID_H
+
+#include <linux/usb/composite.h>
+#include <linux/if_ether.h>
+
+struct android_usb_function {
+	struct list_head	list;
+	char			*name;
+	int 			(*bind_config)(struct usb_configuration *c);
+};
+
+struct android_usb_product {
+	/* Default product ID. */
+	__u16 product_id;
+
+	/* List of function names associated with this product.
+	 * This is used to compute the USB product ID dynamically
+	 * based on which functions are enabled.
+	 */
+	int num_functions;
+	char **functions;
+};
+
+struct android_usb_platform_data {
+	/* USB device descriptor fields */
+	__u16 vendor_id;
+
+	/* Default product ID. */
+	__u16 product_id;
+
+	__u16 version;
+
+	char *product_name;
+	char *manufacturer_name;
+	char *serial_number;
+
+	/* List of available USB products.
+	 * This is used to compute the USB product ID dynamically
+	 * based on which functions are enabled.
+	 * if num_products is zero or no match can be found,
+	 * we use the default product ID
+	 */
+	int num_products;
+	struct android_usb_product *products;
+
+	/* List of all supported USB functions.
+	 * This list is used to define the order in which
+	 * the functions appear in the configuration's list of USB interfaces.
+	 * This is necessary to avoid depending upon the order in which
+	 * the individual function drivers are initialized.
+	 */
+	int num_functions;
+	char **functions;
+};
+
+/* Platform data for "usb_mass_storage" driver. */
+struct usb_mass_storage_platform_data {
+	/* Contains values for the SC_INQUIRY SCSI command. */
+	char *vendor;
+	char *product;
+	int release;
+
+	/* number of LUNS */
+	int nluns;
+};
+
+/* Platform data for USB ethernet driver. */
+struct usb_ether_platform_data {
+	u8	ethaddr[ETH_ALEN];
+	u32	vendorID;
+	const char *vendorDescr;
+};
+
+extern void android_usb_set_connected(int on);
+
+extern void android_register_function(struct android_usb_function *f);
+
+extern void android_enable_function(struct usb_function *f, int enable);
+
+
+#endif	/* __LINUX_USB_ANDROID_H */
diff -Nur linux-2.6.32-orig/include/linux/usb/composite.h iDroid-Project-kernel_common-9e90fd2/include/linux/usb/composite.h
--- linux-2.6.32-orig/include/linux/usb/composite.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/usb/composite.h	2010-11-18 21:05:30.000000000 +0600
@@ -36,8 +36,10 @@
 
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
+#include <linux/switch.h>
 
 
+struct usb_composite_dev;
 struct usb_configuration;
 
 /**
@@ -101,6 +103,9 @@
 
 	struct usb_configuration	*config;
 
+	/* disabled is zero if the function is enabled */
+	int				disabled;
+
 	/* REVISIT:  bind() functions can be marked __init, which
 	 * makes trouble for section mismatch analysis.  See if
 	 * we can't restructure things to avoid mismatching.
@@ -127,6 +132,7 @@
 	/* private: */
 	/* internals */
 	struct list_head		list;
+	struct device			*dev;
 };
 
 int usb_add_function(struct usb_configuration *, struct usb_function *);
@@ -136,6 +142,9 @@
 
 int usb_interface_id(struct usb_configuration *, struct usb_function *);
 
+void usb_function_set_enabled(struct usb_function *, int);
+void usb_composite_force_reset(struct usb_composite_dev *);
+
 /**
  * ep_choose - select descriptor endpoint at current device speed
  * @g: gadget, connected and running at some speed
@@ -267,6 +276,9 @@
 	const struct usb_device_descriptor	*dev;
 	struct usb_gadget_strings		**strings;
 
+	struct class		*class;
+	atomic_t		function_count;
+
 	/* REVISIT:  bind() functions can be marked __init, which
 	 * makes trouble for section mismatch analysis.  See if
 	 * we can't restructure things to avoid mismatching...
@@ -278,6 +290,8 @@
 	/* global suspend hooks */
 	void			(*suspend)(struct usb_composite_dev *);
 	void			(*resume)(struct usb_composite_dev *);
+
+	void			(*enable_function)(struct usb_function *f, int enable);
 };
 
 extern int usb_composite_register(struct usb_composite_driver *);
@@ -337,6 +351,11 @@
 
 	/* protects at least deactivation count */
 	spinlock_t			lock;
+
+	struct switch_dev sdev;
+	/* used by usb_composite_force_reset to avoid signalling switch changes */
+	bool				mute_switch;
+	struct work_struct switch_work;
 };
 
 extern int usb_string_id(struct usb_composite_dev *c);
diff -Nur linux-2.6.32-orig/include/linux/usb_usual.h iDroid-Project-kernel_common-9e90fd2/include/linux/usb_usual.h
--- linux-2.6.32-orig/include/linux/usb_usual.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/usb_usual.h	2010-11-18 21:05:30.000000000 +0600
@@ -56,7 +56,9 @@
 	US_FLAG(SANE_SENSE,     0x00008000)			\
 		/* Sane Sense (> 18 bytes) */			\
 	US_FLAG(CAPACITY_OK,	0x00010000)			\
-		/* READ CAPACITY response is correct */
+		/* READ CAPACITY response is correct */		\
+	US_FLAG(BAD_SENSE,	0x00020000)			\
+		/* Bad Sense (never more than 18 bytes) */
 
 #define US_FLAG(name, value)	US_FL_##name = value ,
 enum { US_DO_ALL_FLAGS };
diff -Nur linux-2.6.32-orig/include/linux/vmalloc.h iDroid-Project-kernel_common-9e90fd2/include/linux/vmalloc.h
--- linux-2.6.32-orig/include/linux/vmalloc.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/vmalloc.h	2010-11-18 21:05:30.000000000 +0600
@@ -115,9 +115,11 @@
 extern struct vm_struct *vmlist;
 extern __init void vm_area_register_early(struct vm_struct *vm, size_t align);
 
+#ifndef CONFIG_HAVE_LEGACY_PER_CPU_AREA
 struct vm_struct **pcpu_get_vm_areas(const unsigned long *offsets,
 				     const size_t *sizes, int nr_vms,
 				     size_t align, gfp_t gfp_mask);
+#endif
 
 void pcpu_free_vm_areas(struct vm_struct **vms, int nr_vms);
 
diff -Nur linux-2.6.32-orig/include/linux/wakelock.h iDroid-Project-kernel_common-9e90fd2/include/linux/wakelock.h
--- linux-2.6.32-orig/include/linux/wakelock.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/wakelock.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,91 @@
+/* include/linux/wakelock.h
+ *
+ * Copyright (C) 2007-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_WAKELOCK_H
+#define _LINUX_WAKELOCK_H
+
+#include <linux/list.h>
+#include <linux/ktime.h>
+
+/* A wake_lock prevents the system from entering suspend or other low power
+ * states when active. If the type is set to WAKE_LOCK_SUSPEND, the wake_lock
+ * prevents a full system suspend. If the type is WAKE_LOCK_IDLE, low power
+ * states that cause large interrupt latencies or that disable a set of
+ * interrupts will not entered from idle until the wake_locks are released.
+ */
+
+enum {
+	WAKE_LOCK_SUSPEND, /* Prevent suspend */
+	WAKE_LOCK_IDLE,    /* Prevent low power idle */
+	WAKE_LOCK_TYPE_COUNT
+};
+
+struct wake_lock {
+#ifdef CONFIG_HAS_WAKELOCK
+	struct list_head    link;
+	int                 flags;
+	const char         *name;
+	unsigned long       expires;
+#ifdef CONFIG_WAKELOCK_STAT
+	struct {
+		int             count;
+		int             expire_count;
+		int             wakeup_count;
+		ktime_t         total_time;
+		ktime_t         prevent_suspend_time;
+		ktime_t         max_time;
+		ktime_t         last_time;
+	} stat;
+#endif
+#endif
+};
+
+#ifdef CONFIG_HAS_WAKELOCK
+
+void wake_lock_init(struct wake_lock *lock, int type, const char *name);
+void wake_lock_destroy(struct wake_lock *lock);
+void wake_lock(struct wake_lock *lock);
+void wake_lock_timeout(struct wake_lock *lock, long timeout);
+void wake_unlock(struct wake_lock *lock);
+
+/* wake_lock_active returns a non-zero value if the wake_lock is currently
+ * locked. If the wake_lock has a timeout, it does not check the timeout
+ * but if the timeout had aready been checked it will return 0.
+ */
+int wake_lock_active(struct wake_lock *lock);
+
+/* has_wake_lock returns 0 if no wake locks of the specified type are active,
+ * and non-zero if one or more wake locks are held. Specifically it returns
+ * -1 if one or more wake locks with no timeout are active or the
+ * number of jiffies until all active wake locks time out.
+ */
+long has_wake_lock(int type);
+
+#else
+
+static inline void wake_lock_init(struct wake_lock *lock, int type,
+					const char *name) {}
+static inline void wake_lock_destroy(struct wake_lock *lock) {}
+static inline void wake_lock(struct wake_lock *lock) {}
+static inline void wake_lock_timeout(struct wake_lock *lock, long timeout) {}
+static inline void wake_unlock(struct wake_lock *lock) {}
+
+static inline int wake_lock_active(struct wake_lock *lock) { return 0; }
+static inline long has_wake_lock(int type) { return 0; }
+
+#endif
+
+#endif
+
diff -Nur linux-2.6.32-orig/include/linux/wifi_tiwlan.h iDroid-Project-kernel_common-9e90fd2/include/linux/wifi_tiwlan.h
--- linux-2.6.32-orig/include/linux/wifi_tiwlan.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/wifi_tiwlan.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,27 @@
+/* include/linux/wifi_tiwlan.h
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _LINUX_WIFI_TIWLAN_H_
+#define _LINUX_WIFI_TIWLAN_H_
+
+#include <linux/wlan_plat.h>
+
+#define WMPA_NUMBER_OF_SECTIONS	3
+#define WMPA_NUMBER_OF_BUFFERS	160
+#define WMPA_SECTION_HEADER	24
+#define WMPA_SECTION_SIZE_0	(WMPA_NUMBER_OF_BUFFERS * 64)
+#define WMPA_SECTION_SIZE_1	(WMPA_NUMBER_OF_BUFFERS * 256)
+#define WMPA_SECTION_SIZE_2	(WMPA_NUMBER_OF_BUFFERS * 2048)
+
+#endif
diff -Nur linux-2.6.32-orig/include/linux/wl127x-rfkill.h iDroid-Project-kernel_common-9e90fd2/include/linux/wl127x-rfkill.h
--- linux-2.6.32-orig/include/linux/wl127x-rfkill.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/wl127x-rfkill.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,35 @@
+/*
+ * Bluetooth TI wl127x rfkill power control via GPIO
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ * Copyright (C) 2008 Texas Instruments
+ * Initial code: Pavan Savoy <pavan.savoy@gmail.com> (wl127x_power.c)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _LINUX_WL127X_RFKILL_H
+#define _LINUX_WL127X_RFKILL_H
+
+#include <linux/rfkill.h>
+
+struct wl127x_rfkill_platform_data {
+	int nshutdown_gpio;
+
+	struct rfkill *rfkill;  /* for driver only */
+};
+
+#endif
diff -Nur linux-2.6.32-orig/include/linux/wlan_plat.h iDroid-Project-kernel_common-9e90fd2/include/linux/wlan_plat.h
--- linux-2.6.32-orig/include/linux/wlan_plat.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/include/linux/wlan_plat.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,25 @@
+/* include/linux/wlan_plat.h
+ *
+ * Copyright (C) 2010 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _LINUX_WLAN_PLAT_H_
+#define _LINUX_WLAN_PLAT_H_
+
+struct wifi_platform_data {
+	int (*set_power)(int val);
+	int (*set_reset)(int val);
+	int (*set_carddetect)(int val);
+	void *(*mem_prealloc)(int section, unsigned long size);
+};
+
+#endif
diff -Nur linux-2.6.32-orig/include/net/bluetooth/hci_core.h iDroid-Project-kernel_common-9e90fd2/include/net/bluetooth/hci_core.h
--- linux-2.6.32-orig/include/net/bluetooth/hci_core.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/net/bluetooth/hci_core.h	2010-11-18 21:05:30.000000000 +0600
@@ -326,12 +326,15 @@
 void hci_add_sco(struct hci_conn *conn, __u16 handle);
 void hci_setup_sync(struct hci_conn *conn, __u16 handle);
 
-struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
+					__u16 pkt_type, bdaddr_t *dst);
 int hci_conn_del(struct hci_conn *conn);
 void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
 
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type);
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
+					__u16 pkt_type, bdaddr_t *dst,
+					__u8 sec_level, __u8 auth_type);
 int hci_conn_check_link_mode(struct hci_conn *conn);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
 int hci_conn_change_link_key(struct hci_conn *conn);
@@ -358,7 +361,7 @@
 			if (conn->state == BT_CONNECTED) {
 				timeo = msecs_to_jiffies(conn->disc_timeout);
 				if (!conn->out)
-					timeo *= 2;
+					timeo *= 20;
 			} else
 				timeo = msecs_to_jiffies(10);
 		} else
@@ -476,6 +479,7 @@
 #define lmp_sniffsubr_capable(dev) ((dev)->features[5] & LMP_SNIFF_SUBR)
 #define lmp_esco_capable(dev)      ((dev)->features[3] & LMP_ESCO)
 #define lmp_ssp_capable(dev)       ((dev)->features[6] & LMP_SIMPLE_PAIR)
+#define lmp_no_flush_capable(dev)  ((dev)->features[6] & LMP_NO_FLUSH)
 
 /* ----- HCI protocols ----- */
 struct hci_proto {
diff -Nur linux-2.6.32-orig/include/net/bluetooth/hci.h iDroid-Project-kernel_common-9e90fd2/include/net/bluetooth/hci.h
--- linux-2.6.32-orig/include/net/bluetooth/hci.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/net/bluetooth/hci.h	2010-11-18 21:05:30.000000000 +0600
@@ -139,15 +139,20 @@
 #define ESCO_2EV5	0x0100
 #define ESCO_3EV5	0x0200
 
-#define SCO_ESCO_MASK  (ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
-#define EDR_ESCO_MASK  (ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
+#define SCO_ESCO_MASK	(ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
+#define EDR_ESCO_MASK	(ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
+#define ALL_ESCO_MASK	(SCO_ESCO_MASK | ESCO_EV3 | ESCO_EV4 | ESCO_EV5 | \
+			EDR_ESCO_MASK)
 
 /* ACL flags */
+#define ACL_START_NO_FLUSH	0x00
 #define ACL_CONT		0x01
 #define ACL_START		0x02
 #define ACL_ACTIVE_BCAST	0x04
 #define ACL_PICO_BCAST		0x08
 
+#define ACL_PB_MASK	(ACL_CONT | ACL_START)
+
 /* Baseband links */
 #define SCO_LINK	0x00
 #define ACL_LINK	0x01
@@ -186,6 +191,7 @@
 #define LMP_EDR_ESCO_3M	0x40
 #define LMP_EDR_3S_ESCO	0x80
 
+#define LMP_NO_FLUSH	0x01
 #define LMP_SIMPLE_PAIR	0x08
 
 /* Connection modes */
@@ -991,6 +997,9 @@
 	__u8     out;
 	__u16    state;
 	__u32    link_mode;
+	__u32    mtu;
+	__u32    cnt;
+	__u32    pkts;
 };
 
 struct hci_dev_req {
diff -Nur linux-2.6.32-orig/include/net/bluetooth/l2cap.h iDroid-Project-kernel_common-9e90fd2/include/net/bluetooth/l2cap.h
--- linux-2.6.32-orig/include/net/bluetooth/l2cap.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/net/bluetooth/l2cap.h	2010-11-18 21:05:30.000000000 +0600
@@ -70,6 +70,7 @@
 #define L2CAP_LM_TRUSTED	0x0008
 #define L2CAP_LM_RELIABLE	0x0010
 #define L2CAP_LM_SECURE		0x0020
+#define L2CAP_LM_FLUSHABLE	0x0040
 
 /* L2CAP command codes */
 #define L2CAP_COMMAND_REJ	0x01
@@ -316,6 +317,7 @@
 	__u8		sec_level;
 	__u8		role_switch;
 	__u8		force_reliable;
+	__u8		flushable;
 
 	__u8		conf_req[64];
 	__u8		conf_len;
diff -Nur linux-2.6.32-orig/include/net/bluetooth/rfcomm.h iDroid-Project-kernel_common-9e90fd2/include/net/bluetooth/rfcomm.h
--- linux-2.6.32-orig/include/net/bluetooth/rfcomm.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/net/bluetooth/rfcomm.h	2010-11-18 21:05:30.000000000 +0600
@@ -29,7 +29,6 @@
 #define RFCOMM_CONN_TIMEOUT (HZ * 30)
 #define RFCOMM_DISC_TIMEOUT (HZ * 20)
 #define RFCOMM_AUTH_TIMEOUT (HZ * 25)
-#define RFCOMM_IDLE_TIMEOUT (HZ * 2)
 
 #define RFCOMM_DEFAULT_MTU	127
 #define RFCOMM_DEFAULT_CREDITS	7
@@ -155,7 +154,6 @@
 struct rfcomm_session {
 	struct list_head list;
 	struct socket   *sock;
-	struct timer_list timer;
 	unsigned long    state;
 	unsigned long    flags;
 	atomic_t         refcnt;
diff -Nur linux-2.6.32-orig/include/net/bluetooth/sco.h iDroid-Project-kernel_common-9e90fd2/include/net/bluetooth/sco.h
--- linux-2.6.32-orig/include/net/bluetooth/sco.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/net/bluetooth/sco.h	2010-11-18 21:05:30.000000000 +0600
@@ -37,6 +37,7 @@
 struct sockaddr_sco {
 	sa_family_t	sco_family;
 	bdaddr_t	sco_bdaddr;
+	__u16		sco_pkt_type;
 };
 
 /* SCO socket options */
@@ -72,7 +73,8 @@
 
 struct sco_pinfo {
 	struct bt_sock	bt;
-	__u32		flags;
+	__u16		pkt_type;
+
 	struct sco_conn	*conn;
 };
 
diff -Nur linux-2.6.32-orig/include/net/ip.h iDroid-Project-kernel_common-9e90fd2/include/net/ip.h
--- linux-2.6.32-orig/include/net/ip.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/net/ip.h	2010-11-18 21:05:30.000000000 +0600
@@ -342,6 +342,7 @@
 	IP_DEFRAG_CALL_RA_CHAIN,
 	IP_DEFRAG_CONNTRACK_IN,
 	IP_DEFRAG_CONNTRACK_OUT,
+	IP_DEFRAG_CONNTRACK_BRIDGE_IN,
 	IP_DEFRAG_VS_IN,
 	IP_DEFRAG_VS_OUT,
 	IP_DEFRAG_VS_FWD
diff -Nur linux-2.6.32-orig/include/net/ipv6.h iDroid-Project-kernel_common-9e90fd2/include/net/ipv6.h
--- linux-2.6.32-orig/include/net/ipv6.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/net/ipv6.h	2010-11-18 21:05:30.000000000 +0600
@@ -354,8 +354,16 @@
 
 struct inet_frag_queue;
 
+enum ip6_defrag_users {
+	IP6_DEFRAG_LOCAL_DELIVER,
+	IP6_DEFRAG_CONNTRACK_IN,
+	IP6_DEFRAG_CONNTRACK_OUT,
+	IP6_DEFRAG_CONNTRACK_BRIDGE_IN,
+};
+
 struct ip6_create_arg {
 	__be32 id;
+	u32 user;
 	struct in6_addr *src;
 	struct in6_addr *dst;
 };
diff -Nur linux-2.6.32-orig/include/net/netfilter/ipv6/nf_conntrack_ipv6.h iDroid-Project-kernel_common-9e90fd2/include/net/netfilter/ipv6/nf_conntrack_ipv6.h
--- linux-2.6.32-orig/include/net/netfilter/ipv6/nf_conntrack_ipv6.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/net/netfilter/ipv6/nf_conntrack_ipv6.h	2010-11-18 21:05:30.000000000 +0600
@@ -9,7 +9,7 @@
 
 extern int nf_ct_frag6_init(void);
 extern void nf_ct_frag6_cleanup(void);
-extern struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb);
+extern struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user);
 extern void nf_ct_frag6_output(unsigned int hooknum, struct sk_buff *skb,
 			       struct net_device *in,
 			       struct net_device *out,
diff -Nur linux-2.6.32-orig/include/net/netns/conntrack.h iDroid-Project-kernel_common-9e90fd2/include/net/netns/conntrack.h
--- linux-2.6.32-orig/include/net/netns/conntrack.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/net/netns/conntrack.h	2010-11-18 21:05:30.000000000 +0600
@@ -11,6 +11,8 @@
 struct netns_ct {
 	atomic_t		count;
 	unsigned int		expect_count;
+	unsigned int		htable_size;
+	struct kmem_cache	*nf_conntrack_cachep;
 	struct hlist_nulls_head	*hash;
 	struct hlist_head	*expect_hash;
 	struct hlist_nulls_head	unconfirmed;
@@ -28,5 +30,6 @@
 #endif
 	int			hash_vmalloc;
 	int			expect_vmalloc;
+	char			*slabname;
 };
 #endif
diff -Nur linux-2.6.32-orig/include/net/netns/ipv4.h iDroid-Project-kernel_common-9e90fd2/include/net/netns/ipv4.h
--- linux-2.6.32-orig/include/net/netns/ipv4.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/net/netns/ipv4.h	2010-11-18 21:05:30.000000000 +0600
@@ -40,6 +40,7 @@
 	struct xt_table		*iptable_security;
 	struct xt_table		*nat_table;
 	struct hlist_head	*nat_bysource;
+	unsigned int		nat_htable_size;
 	int			nat_vmalloced;
 #endif
 
diff -Nur linux-2.6.32-orig/include/net/netrom.h iDroid-Project-kernel_common-9e90fd2/include/net/netrom.h
--- linux-2.6.32-orig/include/net/netrom.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/net/netrom.h	2010-11-18 21:05:30.000000000 +0600
@@ -132,6 +132,8 @@
 static __inline__ void nr_neigh_put(struct nr_neigh *nr_neigh)
 {
 	if (atomic_dec_and_test(&nr_neigh->refcount)) {
+		if (nr_neigh->ax25)
+			ax25_cb_put(nr_neigh->ax25);
 		kfree(nr_neigh->digipeat);
 		kfree(nr_neigh);
 	}
diff -Nur linux-2.6.32-orig/include/net/tcp.h iDroid-Project-kernel_common-9e90fd2/include/net/tcp.h
--- linux-2.6.32-orig/include/net/tcp.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/net/tcp.h	2010-11-18 21:05:30.000000000 +0600
@@ -1263,14 +1263,20 @@
  * TCP connection after "boundary" unsucessful, exponentially backed-off
  * retransmissions with an initial RTO of TCP_RTO_MIN.
  */
-static inline bool retransmits_timed_out(const struct sock *sk,
+static inline bool retransmits_timed_out(struct sock *sk,
 					 unsigned int boundary)
 {
 	unsigned int timeout, linear_backoff_thresh;
+	unsigned int start_ts;
 
 	if (!inet_csk(sk)->icsk_retransmits)
 		return false;
 
+	if (unlikely(!tcp_sk(sk)->retrans_stamp))
+		start_ts = TCP_SKB_CB(tcp_write_queue_head(sk))->when;
+	else
+		start_ts = tcp_sk(sk)->retrans_stamp;
+
 	linear_backoff_thresh = ilog2(TCP_RTO_MAX/TCP_RTO_MIN);
 
 	if (boundary <= linear_backoff_thresh)
@@ -1279,7 +1285,7 @@
 		timeout = ((2 << linear_backoff_thresh) - 1) * TCP_RTO_MIN +
 			  (boundary - linear_backoff_thresh) * TCP_RTO_MAX;
 
-	return (tcp_time_stamp - tcp_sk(sk)->retrans_stamp) >= timeout;
+	return (tcp_time_stamp - start_ts) >= timeout;
 }
 
 static inline struct sk_buff *tcp_send_head(struct sock *sk)
@@ -1443,6 +1449,8 @@
 extern int tcp_gro_complete(struct sk_buff *skb);
 extern int tcp4_gro_complete(struct sk_buff *skb);
 
+extern void tcp_v4_nuke_addr(__u32 saddr);
+
 #ifdef CONFIG_PROC_FS
 extern int  tcp4_proc_init(void);
 extern void tcp4_proc_exit(void);
diff -Nur linux-2.6.32-orig/include/scsi/fc_frame.h iDroid-Project-kernel_common-9e90fd2/include/scsi/fc_frame.h
--- linux-2.6.32-orig/include/scsi/fc_frame.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/scsi/fc_frame.h	2010-11-18 21:05:30.000000000 +0600
@@ -37,6 +37,9 @@
 #define	FC_FRAME_HEADROOM	32	/* headroom for VLAN + FCoE headers */
 #define	FC_FRAME_TAILROOM	8	/* trailer space for FCoE */
 
+/* Max number of skb frags allowed, reserving one for fcoe_crc_eof page */
+#define FC_FRAME_SG_LEN		(MAX_SKB_FRAGS - 1)
+
 #define fp_skb(fp)	(&((fp)->skb))
 #define fr_hdr(fp)	((fp)->skb.data)
 #define fr_len(fp)	((fp)->skb.len)
diff -Nur linux-2.6.32-orig/include/scsi/libfc.h iDroid-Project-kernel_common-9e90fd2/include/scsi/libfc.h
--- linux-2.6.32-orig/include/scsi/libfc.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/scsi/libfc.h	2010-11-18 21:05:30.000000000 +0600
@@ -145,6 +145,7 @@
 	RPORT_ST_LOGO,		/* port logout sent */
 	RPORT_ST_ADISC,		/* Discover Address sent */
 	RPORT_ST_DELETE,	/* port being deleted */
+	RPORT_ST_RESTART,       /* remote port being deleted and will restart */
 };
 
 /**
diff -Nur linux-2.6.32-orig/include/scsi/osd_protocol.h iDroid-Project-kernel_common-9e90fd2/include/scsi/osd_protocol.h
--- linux-2.6.32-orig/include/scsi/osd_protocol.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/scsi/osd_protocol.h	2010-11-18 21:05:30.000000000 +0600
@@ -17,6 +17,7 @@
 #define __OSD_PROTOCOL_H__
 
 #include <linux/types.h>
+#include <linux/kernel.h>
 #include <asm/unaligned.h>
 #include <scsi/scsi.h>
 
diff -Nur linux-2.6.32-orig/include/scsi/scsi_host.h iDroid-Project-kernel_common-9e90fd2/include/scsi/scsi_host.h
--- linux-2.6.32-orig/include/scsi/scsi_host.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/scsi/scsi_host.h	2010-11-18 21:05:30.000000000 +0600
@@ -677,6 +677,12 @@
 	void *shost_data;
 
 	/*
+	 * Points to the physical bus device we'd use to do DMA
+	 * Needed just in case we have virtual hosts.
+	 */
+	struct device *dma_dev;
+
+	/*
 	 * We should ensure that this is aligned, both for better performance
 	 * and also because some compilers (m68k) don't automatically force
 	 * alignment to a long boundary.
@@ -720,7 +726,9 @@
 extern void scsi_flush_work(struct Scsi_Host *);
 
 extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *, int);
-extern int __must_check scsi_add_host(struct Scsi_Host *, struct device *);
+extern int __must_check scsi_add_host_with_dma(struct Scsi_Host *,
+					       struct device *,
+					       struct device *);
 extern void scsi_scan_host(struct Scsi_Host *);
 extern void scsi_rescan_device(struct device *);
 extern void scsi_remove_host(struct Scsi_Host *);
@@ -731,6 +739,12 @@
 
 extern u64 scsi_calculate_bounce_limit(struct Scsi_Host *);
 
+static inline int __must_check scsi_add_host(struct Scsi_Host *host,
+					     struct device *dev)
+{
+	return scsi_add_host_with_dma(host, dev, dev);
+}
+
 static inline struct device *scsi_get_device(struct Scsi_Host *shost)
 {
         return shost->shost_gendev.parent;
diff -Nur linux-2.6.32-orig/include/sound/soc-dapm.h iDroid-Project-kernel_common-9e90fd2/include/sound/soc-dapm.h
--- linux-2.6.32-orig/include/sound/soc-dapm.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/sound/soc-dapm.h	2010-11-18 21:05:30.000000000 +0600
@@ -95,6 +95,21 @@
 	.shift = wshift, .invert = winvert, .kcontrols = wcontrols, \
 	.num_kcontrols = 1}
 
+/* Simplified versions of above macros, assuming wncontrols = ARRAY_SIZE(wcontrols) */
+#define SOC_PGA_ARRAY(wname, wreg, wshift, winvert,\
+	 wcontrols) \
+{	.id = snd_soc_dapm_pga, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = ARRAY_SIZE(wcontrols)}
+#define SOC_MIXER_ARRAY(wname, wreg, wshift, winvert, \
+	 wcontrols)\
+{	.id = snd_soc_dapm_mixer, .name = wname, .reg = wreg, .shift = wshift, \
+	.invert = winvert, .kcontrols = wcontrols, .num_kcontrols = ARRAY_SIZE(wcontrols)}
+#define SOC_MIXER_NAMED_CTL_ARRAY(wname, wreg, wshift, winvert, \
+	 wcontrols)\
+{       .id = snd_soc_dapm_mixer_named_ctl, .name = wname, .reg = wreg, \
+	.shift = wshift, .invert = winvert, .kcontrols = wcontrols, \
+	.num_kcontrols = ARRAY_SIZE(wcontrols)}
+
 /* path domain with event - event handler must return 0 for success */
 #define SND_SOC_DAPM_PGA_E(wname, wreg, wshift, winvert, wcontrols, \
 	wncontrols, wevent, wflags) \
diff -Nur linux-2.6.32-orig/include/sound/soc.h iDroid-Project-kernel_common-9e90fd2/include/sound/soc.h
--- linux-2.6.32-orig/include/sound/soc.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/sound/soc.h	2010-11-18 21:05:30.000000000 +0600
@@ -168,6 +168,24 @@
 	.get = xhandler_get, .put = xhandler_put, \
 	.private_value = (unsigned long)&xenum }
 
+
+/*
+ * Simplified versions of above macros, declaring a struct and calculating
+ * ARRAY_SIZE internally
+ */
+#define SOC_ENUM_DOUBLE_DECL(name, xreg, xshift_l, xshift_r, xtexts) \
+	struct soc_enum name = SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, \
+						ARRAY_SIZE(xtexts), xtexts)
+#define SOC_ENUM_SINGLE_DECL(name, xreg, xshift, xtexts) \
+	SOC_ENUM_DOUBLE_DECL(name, xreg, xshift, xshift, xtexts)
+#define SOC_ENUM_SINGLE_EXT_DECL(name, xtexts) \
+	struct soc_enum name = SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(xtexts), xtexts)
+#define SOC_VALUE_ENUM_DOUBLE_DECL(name, xreg, xshift_l, xshift_r, xmask, xtexts, xvalues) \
+	struct soc_enum name = SOC_VALUE_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, \
+							ARRAY_SIZE(xtexts), xtexts, xvalues)
+#define SOC_VALUE_ENUM_SINGLE_DECL(name, xreg, xshift, xmask, xtexts, xvalues) \
+	SOC_VALUE_ENUM_DOUBLE_DECL(name, xreg, xshift, xshift, xmask, xtexts, xvalues)
+
 /*
  * Bias levels
  *
diff -Nur linux-2.6.32-orig/include/trace/ftrace.h iDroid-Project-kernel_common-9e90fd2/include/trace/ftrace.h
--- linux-2.6.32-orig/include/trace/ftrace.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/include/trace/ftrace.h	2010-11-18 21:05:30.000000000 +0600
@@ -159,7 +159,7 @@
 #undef __get_str
 
 #undef TP_printk
-#define TP_printk(fmt, args...) "%s, %s\n", #fmt, __stringify(args)
+#define TP_printk(fmt, args...) "\"%s\", %s\n", fmt, __stringify(args)
 
 #undef TP_fast_assign
 #define TP_fast_assign(args...) args
diff -Nur linux-2.6.32-orig/init/calibrate.c iDroid-Project-kernel_common-9e90fd2/init/calibrate.c
--- linux-2.6.32-orig/init/calibrate.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/init/calibrate.c	2010-11-18 21:05:30.000000000 +0600
@@ -123,23 +123,26 @@
 {
 	unsigned long ticks, loopbit;
 	int lps_precision = LPS_PREC;
+	static bool printed;
 
 	if (preset_lpj) {
 		loops_per_jiffy = preset_lpj;
-		printk(KERN_INFO
-			"Calibrating delay loop (skipped) preset value.. ");
-	} else if ((smp_processor_id() == 0) && lpj_fine) {
+		if (!printed)
+			pr_info("Calibrating delay loop (skipped) "
+				"preset value.. ");
+	} else if ((!printed) && lpj_fine) {
 		loops_per_jiffy = lpj_fine;
-		printk(KERN_INFO
-			"Calibrating delay loop (skipped), "
+		pr_info("Calibrating delay loop (skipped), "
 			"value calculated using timer frequency.. ");
 	} else if ((loops_per_jiffy = calibrate_delay_direct()) != 0) {
-		printk(KERN_INFO
-			"Calibrating delay using timer specific routine.. ");
+		if (!printed)
+			pr_info("Calibrating delay using timer "
+				"specific routine.. ");
 	} else {
 		loops_per_jiffy = (1<<12);
 
-		printk(KERN_INFO "Calibrating delay loop... ");
+		if (!printed)
+			pr_info("Calibrating delay loop... ");
 		while ((loops_per_jiffy <<= 1) != 0) {
 			/* wait for "start of" clock tick */
 			ticks = jiffies;
@@ -170,7 +173,10 @@
 				loops_per_jiffy &= ~loopbit;
 		}
 	}
-	printk(KERN_CONT "%lu.%02lu BogoMIPS (lpj=%lu)\n",
+	if (!printed)
+		pr_cont("%lu.%02lu BogoMIPS (lpj=%lu)\n",
 			loops_per_jiffy/(500000/HZ),
 			(loops_per_jiffy/(5000/HZ)) % 100, loops_per_jiffy);
+
+	printed = true;
 }
diff -Nur linux-2.6.32-orig/init/Kconfig iDroid-Project-kernel_common-9e90fd2/init/Kconfig
--- linux-2.6.32-orig/init/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/init/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -737,6 +737,12 @@
 config ANON_INODES
 	bool
 
+config PANIC_TIMEOUT
+	int "Default panic timeout"
+	default 0
+	help
+	  Set default panic timeout.
+
 menuconfig EMBEDDED
 	bool "Configure standard kernel features (for small systems)"
 	help
@@ -908,6 +914,15 @@
 	  option replaces shmem and tmpfs with the much simpler ramfs code,
 	  which may be appropriate on small systems without swap.
 
+config ASHMEM
+	bool "Enable the Anonymous Shared Memory Subsystem"
+	default n
+	depends on SHMEM || TINY_SHMEM
+	help
+	  The ashmem subsystem is a new shared memory allocator, similar to
+	  POSIX SHM but with different behavior and sporting a simpler
+	  file-based API.
+
 config AIO
 	bool "Enable AIO support" if EMBEDDED
 	default y
diff -Nur linux-2.6.32-orig/ipc/msg.c iDroid-Project-kernel_common-9e90fd2/ipc/msg.c
--- linux-2.6.32-orig/ipc/msg.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/ipc/msg.c	2010-11-18 21:05:30.000000000 +0600
@@ -125,6 +125,7 @@
 void msg_exit_ns(struct ipc_namespace *ns)
 {
 	free_ipcs(ns, &msg_ids(ns), freeque);
+	idr_destroy(&ns->ids[IPC_MSG_IDS].ipcs_idr);
 }
 #endif
 
diff -Nur linux-2.6.32-orig/ipc/sem.c iDroid-Project-kernel_common-9e90fd2/ipc/sem.c
--- linux-2.6.32-orig/ipc/sem.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/ipc/sem.c	2010-11-18 21:05:30.000000000 +0600
@@ -129,6 +129,7 @@
 void sem_exit_ns(struct ipc_namespace *ns)
 {
 	free_ipcs(ns, &sem_ids(ns), freeary);
+	idr_destroy(&ns->ids[IPC_SEM_IDS].ipcs_idr);
 }
 #endif
 
diff -Nur linux-2.6.32-orig/ipc/shm.c iDroid-Project-kernel_common-9e90fd2/ipc/shm.c
--- linux-2.6.32-orig/ipc/shm.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/ipc/shm.c	2010-11-18 21:05:30.000000000 +0600
@@ -101,6 +101,7 @@
 void shm_exit_ns(struct ipc_namespace *ns)
 {
 	free_ipcs(ns, &shm_ids(ns), do_shm_rmid);
+	idr_destroy(&ns->ids[IPC_SHM_IDS].ipcs_idr);
 }
 #endif
 
@@ -290,28 +291,28 @@
 	unsigned long flags)
 {
 	struct shm_file_data *sfd = shm_file_data(file);
-	return get_unmapped_area(sfd->file, addr, len, pgoff, flags);
-}
-
-int is_file_shm_hugepages(struct file *file)
-{
-	int ret = 0;
-
-	if (file->f_op == &shm_file_operations) {
-		struct shm_file_data *sfd;
-		sfd = shm_file_data(file);
-		ret = is_file_hugepages(sfd->file);
-	}
-	return ret;
+	return sfd->file->f_op->get_unmapped_area(sfd->file, addr, len,
+						pgoff, flags);
 }
 
 static const struct file_operations shm_file_operations = {
 	.mmap		= shm_mmap,
 	.fsync		= shm_fsync,
 	.release	= shm_release,
+};
+
+static const struct file_operations shm_file_operations_huge = {
+	.mmap		= shm_mmap,
+	.fsync		= shm_fsync,
+	.release	= shm_release,
 	.get_unmapped_area	= shm_get_unmapped_area,
 };
 
+int is_file_shm_hugepages(struct file *file)
+{
+	return file->f_op == &shm_file_operations_huge;
+}
+
 static const struct vm_operations_struct shm_vm_ops = {
 	.open	= shm_open,	/* callback for a new vm-area open */
 	.close	= shm_close,	/* callback for when the vm-area is released */
@@ -889,7 +890,10 @@
 	if (!sfd)
 		goto out_put_dentry;
 
-	file = alloc_file(path.mnt, path.dentry, f_mode, &shm_file_operations);
+	file = alloc_file(path.mnt, path.dentry, f_mode,
+			is_file_hugepages(shp->shm_file) ?
+				&shm_file_operations_huge :
+				&shm_file_operations);
 	if (!file)
 		goto out_free;
 	ima_counts_get(file);
diff -Nur linux-2.6.32-orig/kernel/acct.c iDroid-Project-kernel_common-9e90fd2/kernel/acct.c
--- linux-2.6.32-orig/kernel/acct.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/acct.c	2010-11-18 21:05:30.000000000 +0600
@@ -536,7 +536,8 @@
 	do_div(elapsed, AHZ);
 	ac.ac_btime = get_seconds() - elapsed;
 	/* we really need to bite the bullet and change layout */
-	current_uid_gid(&ac.ac_uid, &ac.ac_gid);
+	ac.ac_uid = orig_cred->uid;
+	ac.ac_gid = orig_cred->gid;
 #if ACCT_VERSION==2
 	ac.ac_ahz = AHZ;
 #endif
diff -Nur linux-2.6.32-orig/kernel/audit_tree.c iDroid-Project-kernel_common-9e90fd2/kernel/audit_tree.c
--- linux-2.6.32-orig/kernel/audit_tree.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/audit_tree.c	2010-11-18 21:05:30.000000000 +0600
@@ -277,7 +277,7 @@
 		owner->root = NULL;
 	}
 
-	for (i = j = 0; i < size; i++, j++) {
+	for (i = j = 0; j <= size; i++, j++) {
 		struct audit_tree *s;
 		if (&chunk->owners[j] == p) {
 			list_del_init(&p->list);
@@ -290,7 +290,7 @@
 		if (!s) /* result of earlier fallback */
 			continue;
 		get_tree(s);
-		list_replace_init(&chunk->owners[i].list, &new->owners[j].list);
+		list_replace_init(&chunk->owners[j].list, &new->owners[i].list);
 	}
 
 	list_replace_rcu(&chunk->hash, &new->hash);
@@ -373,15 +373,17 @@
 	for (n = 0; n < old->count; n++) {
 		if (old->owners[n].owner == tree) {
 			spin_unlock(&hash_lock);
-			put_inotify_watch(watch);
+			put_inotify_watch(&old->watch);
 			return 0;
 		}
 	}
 	spin_unlock(&hash_lock);
 
 	chunk = alloc_chunk(old->count + 1);
-	if (!chunk)
+	if (!chunk) {
+		put_inotify_watch(&old->watch);
 		return -ENOMEM;
+	}
 
 	mutex_lock(&inode->inotify_mutex);
 	if (inotify_clone_watch(&old->watch, &chunk->watch) < 0) {
@@ -425,7 +427,8 @@
 	spin_unlock(&hash_lock);
 	inotify_evict_watch(&old->watch);
 	mutex_unlock(&inode->inotify_mutex);
-	put_inotify_watch(&old->watch);
+	put_inotify_watch(&old->watch); /* pair to inotify_find_watch */
+	put_inotify_watch(&old->watch); /* and kill it */
 	return 0;
 }
 
diff -Nur linux-2.6.32-orig/kernel/cgroup.c iDroid-Project-kernel_common-9e90fd2/kernel/cgroup.c
--- linux-2.6.32-orig/kernel/cgroup.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/cgroup.c	2010-11-18 21:05:30.000000000 +0600
@@ -51,6 +51,7 @@
 #include <linux/pid_namespace.h>
 #include <linux/idr.h>
 #include <linux/vmalloc.h> /* TODO: replace with more sophisticated array */
+#include <linux/capability.h>
 
 #include <asm/atomic.h>
 
@@ -1555,6 +1556,15 @@
 			retval = ss->can_attach(ss, cgrp, tsk, false);
 			if (retval)
 				return retval;
+		} else if (!capable(CAP_SYS_ADMIN)) {
+			const struct cred *cred = current_cred(), *tcred;
+
+			/* No can_attach() - check perms generically */
+			tcred = __task_cred(tsk);
+			if (cred->euid != tcred->uid &&
+			    cred->euid != tcred->suid) {
+				return -EACCES;
+			}
 		}
 	}
 
@@ -1611,7 +1621,6 @@
 static int attach_task_by_pid(struct cgroup *cgrp, u64 pid)
 {
 	struct task_struct *tsk;
-	const struct cred *cred = current_cred(), *tcred;
 	int ret;
 
 	if (pid) {
@@ -1621,14 +1630,6 @@
 			rcu_read_unlock();
 			return -ESRCH;
 		}
-
-		tcred = __task_cred(tsk);
-		if (cred->euid &&
-		    cred->euid != tcred->uid &&
-		    cred->euid != tcred->suid) {
-			rcu_read_unlock();
-			return -EACCES;
-		}
 		get_task_struct(tsk);
 		rcu_read_unlock();
 	} else {
@@ -2468,7 +2469,6 @@
 			/* make sure l doesn't vanish out from under us */
 			down_write(&l->mutex);
 			mutex_unlock(&cgrp->pidlist_mutex);
-			l->use_count++;
 			return l;
 		}
 	}
diff -Nur linux-2.6.32-orig/kernel/cgroup_freezer.c iDroid-Project-kernel_common-9e90fd2/kernel/cgroup_freezer.c
--- linux-2.6.32-orig/kernel/cgroup_freezer.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/cgroup_freezer.c	2010-11-18 21:05:30.000000000 +0600
@@ -163,6 +163,14 @@
 {
 	struct freezer *freezer;
 
+	if ((current != task) && (!capable(CAP_SYS_ADMIN))) {
+		const struct cred *cred = current_cred(), *tcred;
+
+		tcred = __task_cred(task);
+		if (cred->euid != tcred->uid && cred->euid != tcred->suid)
+			return -EPERM;
+	}
+
 	/*
 	 * Anything frozen can't move or be moved to/from.
 	 *
diff -Nur linux-2.6.32-orig/kernel/cpu.c iDroid-Project-kernel_common-9e90fd2/kernel/cpu.c
--- linux-2.6.32-orig/kernel/cpu.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/cpu.c	2010-11-18 21:05:30.000000000 +0600
@@ -212,6 +212,8 @@
 	err = __raw_notifier_call_chain(&cpu_chain, CPU_DOWN_PREPARE | mod,
 					hcpu, -1, &nr_calls);
 	if (err == NOTIFY_BAD) {
+		set_cpu_active(cpu, true);
+
 		nr_calls--;
 		__raw_notifier_call_chain(&cpu_chain, CPU_DOWN_FAILED | mod,
 					  hcpu, nr_calls, NULL);
@@ -223,11 +225,11 @@
 
 	/* Ensure that we are not runnable on dying cpu */
 	cpumask_copy(old_allowed, &current->cpus_allowed);
-	set_cpus_allowed_ptr(current,
-			     cpumask_of(cpumask_any_but(cpu_online_mask, cpu)));
+	set_cpus_allowed_ptr(current, cpu_active_mask);
 
 	err = __stop_machine(take_cpu_down, &tcd_param, cpumask_of(cpu));
 	if (err) {
+		set_cpu_active(cpu, true);
 		/* CPU didn't die: tell everyone.  Can't complain. */
 		if (raw_notifier_call_chain(&cpu_chain, CPU_DOWN_FAILED | mod,
 					    hcpu) == NOTIFY_BAD)
@@ -292,9 +294,6 @@
 
 	err = _cpu_down(cpu, 0);
 
-	if (cpu_online(cpu))
-		set_cpu_active(cpu, true);
-
 out:
 	cpu_maps_update_done();
 	stop_machine_destroy();
@@ -387,15 +386,23 @@
 	 * with the userspace trying to use the CPU hotplug at the same time
 	 */
 	cpumask_clear(frozen_cpus);
+
+	for_each_online_cpu(cpu) {
+		if (cpu == first_cpu)
+			continue;
+		set_cpu_active(cpu, false);
+	}
+
+	synchronize_sched();
+
 	printk("Disabling non-boot CPUs ...\n");
 	for_each_online_cpu(cpu) {
 		if (cpu == first_cpu)
 			continue;
 		error = _cpu_down(cpu, 1);
-		if (!error) {
+		if (!error)
 			cpumask_set_cpu(cpu, frozen_cpus);
-			printk("CPU%d is down\n", cpu);
-		} else {
+		else {
 			printk(KERN_ERR "Error taking CPU%d down: %d\n",
 				cpu, error);
 			break;
diff -Nur linux-2.6.32-orig/kernel/cpuset.c iDroid-Project-kernel_common-9e90fd2/kernel/cpuset.c
--- linux-2.6.32-orig/kernel/cpuset.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/cpuset.c	2010-11-18 21:05:30.000000000 +0600
@@ -873,7 +873,7 @@
 		if (retval < 0)
 			return retval;
 
-		if (!cpumask_subset(trialcs->cpus_allowed, cpu_online_mask))
+		if (!cpumask_subset(trialcs->cpus_allowed, cpu_active_mask))
 			return -EINVAL;
 	}
 	retval = validate_change(cs, trialcs);
@@ -1330,6 +1330,13 @@
 	int ret;
 	struct cpuset *cs = cgroup_cs(cont);
 
+	if ((current != task) && (!capable(CAP_SYS_ADMIN))) {
+		const struct cred *cred = current_cred(), *tcred;
+
+		if (cred->euid != tcred->uid && cred->euid != tcred->suid)
+			return -EPERM;
+	}
+ 
 	if (cpumask_empty(cs->cpus_allowed) || nodes_empty(cs->mems_allowed))
 		return -ENOSPC;
 
@@ -2011,7 +2018,7 @@
 		}
 
 		/* Continue past cpusets with all cpus, mems online */
-		if (cpumask_subset(cp->cpus_allowed, cpu_online_mask) &&
+		if (cpumask_subset(cp->cpus_allowed, cpu_active_mask) &&
 		    nodes_subset(cp->mems_allowed, node_states[N_HIGH_MEMORY]))
 			continue;
 
@@ -2020,7 +2027,7 @@
 		/* Remove offline cpus and mems from this cpuset. */
 		mutex_lock(&callback_mutex);
 		cpumask_and(cp->cpus_allowed, cp->cpus_allowed,
-			    cpu_online_mask);
+			    cpu_active_mask);
 		nodes_and(cp->mems_allowed, cp->mems_allowed,
 						node_states[N_HIGH_MEMORY]);
 		mutex_unlock(&callback_mutex);
@@ -2058,8 +2065,10 @@
 	switch (phase) {
 	case CPU_ONLINE:
 	case CPU_ONLINE_FROZEN:
-	case CPU_DEAD:
-	case CPU_DEAD_FROZEN:
+	case CPU_DOWN_PREPARE:
+	case CPU_DOWN_PREPARE_FROZEN:
+	case CPU_DOWN_FAILED:
+	case CPU_DOWN_FAILED_FROZEN:
 		break;
 
 	default:
@@ -2068,7 +2077,7 @@
 
 	cgroup_lock();
 	mutex_lock(&callback_mutex);
-	cpumask_copy(top_cpuset.cpus_allowed, cpu_online_mask);
+	cpumask_copy(top_cpuset.cpus_allowed, cpu_active_mask);
 	mutex_unlock(&callback_mutex);
 	scan_for_empty_cpusets(&top_cpuset);
 	ndoms = generate_sched_domains(&doms, &attr);
@@ -2115,7 +2124,7 @@
 
 void __init cpuset_init_smp(void)
 {
-	cpumask_copy(top_cpuset.cpus_allowed, cpu_online_mask);
+	cpumask_copy(top_cpuset.cpus_allowed, cpu_active_mask);
 	top_cpuset.mems_allowed = node_states[N_HIGH_MEMORY];
 
 	hotcpu_notifier(cpuset_track_online_cpus, 0);
diff -Nur linux-2.6.32-orig/kernel/cred.c iDroid-Project-kernel_common-9e90fd2/kernel/cred.c
--- linux-2.6.32-orig/kernel/cred.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/cred.c	2010-11-18 21:05:30.000000000 +0600
@@ -224,7 +224,7 @@
 #ifdef CONFIG_KEYS
 	new->tgcred = kzalloc(sizeof(*new->tgcred), GFP_KERNEL);
 	if (!new->tgcred) {
-		kfree(new);
+		kmem_cache_free(cred_jar, new);
 		return NULL;
 	}
 	atomic_set(&new->tgcred->usage, 1);
diff -Nur linux-2.6.32-orig/kernel/fork.c iDroid-Project-kernel_common-9e90fd2/kernel/fork.c
--- linux-2.6.32-orig/kernel/fork.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/fork.c	2010-11-18 21:05:30.000000000 +0600
@@ -138,6 +138,9 @@
 /* SLAB cache for mm_struct structures (tsk->mm) */
 static struct kmem_cache *mm_cachep;
 
+/* Notifier list called when a task struct is freed */
+static ATOMIC_NOTIFIER_HEAD(task_free_notifier);
+
 static void account_kernel_stack(struct thread_info *ti, int account)
 {
 	struct zone *zone = page_zone(virt_to_page(ti));
@@ -156,6 +159,18 @@
 }
 EXPORT_SYMBOL(free_task);
 
+int task_free_register(struct notifier_block *n)
+{
+	return atomic_notifier_chain_register(&task_free_notifier, n);
+}
+EXPORT_SYMBOL(task_free_register);
+
+int task_free_unregister(struct notifier_block *n)
+{
+	return atomic_notifier_chain_unregister(&task_free_notifier, n);
+}
+EXPORT_SYMBOL(task_free_unregister);
+
 void __put_task_struct(struct task_struct *tsk)
 {
 	WARN_ON(!tsk->exit_state);
@@ -165,6 +180,7 @@
 	exit_creds(tsk);
 	delayacct_tsk_free(tsk);
 
+	atomic_notifier_call_chain(&task_free_notifier, 0, tsk);
 	if (!profile_handoff_task(tsk))
 		free_task(tsk);
 }
diff -Nur linux-2.6.32-orig/kernel/futex.c iDroid-Project-kernel_common-9e90fd2/kernel/futex.c
--- linux-2.6.32-orig/kernel/futex.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/futex.c	2010-11-18 21:05:30.000000000 +0600
@@ -203,8 +203,6 @@
  * @uaddr:	virtual address of the futex
  * @fshared:	0 for a PROCESS_PRIVATE futex, 1 for PROCESS_SHARED
  * @key:	address where result is stored.
- * @rw:		mapping needs to be read/write (values: VERIFY_READ,
- * 		VERIFY_WRITE)
  *
  * Returns a negative error code or 0
  * The key words are stored in *key on success.
@@ -216,12 +214,13 @@
  * lock_page() might sleep, the caller should not hold a spinlock.
  */
 static int
-get_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)
+get_futex_key(u32 __user *uaddr, int fshared, union futex_key *key)
 {
 	unsigned long address = (unsigned long)uaddr;
 	struct mm_struct *mm = current->mm;
 	struct page *page;
 	int err;
+	struct vm_area_struct *vma;
 
 	/*
 	 * The futex address must be "naturally" aligned.
@@ -239,7 +238,7 @@
 	 *        but access_ok() should be faster than find_vma()
 	 */
 	if (!fshared) {
-		if (unlikely(!access_ok(rw, uaddr, sizeof(u32))))
+		if (unlikely(!access_ok(VERIFY_WRITE, uaddr, sizeof(u32))))
 			return -EFAULT;
 		key->private.mm = mm;
 		key->private.address = address;
@@ -247,8 +246,39 @@
 		return 0;
 	}
 
+	/*
+	 * The futex is hashed differently depending on whether
+	 * it's in a shared or private mapping.  So check vma first.
+	 */
+	vma = find_extend_vma(mm, address);
+	if (unlikely(!vma))
+		return -EFAULT;
+
+	/*
+	 * Permissions.
+	 */
+	if (unlikely((vma->vm_flags & (VM_IO|VM_READ)) != VM_READ))
+		return (vma->vm_flags & VM_IO) ? -EPERM : -EACCES;
+
+	/*
+	 * Private mappings are handled in a simple way.
+	 *
+	 * NOTE: When userspace waits on a MAP_SHARED mapping, even if
+	 * it's a read-only handle, it's expected that futexes attach to
+	 * the object not the particular process.  Therefore we use
+	 * VM_MAYSHARE here, not VM_SHARED which is restricted to shared
+	 * mappings of _writable_ handles.
+	 */
+	if (likely(!(vma->vm_flags & VM_MAYSHARE))) {
+		key->both.offset |= FUT_OFF_MMSHARED; /* reference taken on mm */
+		key->private.mm = mm;
+		key->private.address = address;
+		get_futex_key_refs(key);
+		return 0;
+	}
+
 again:
-	err = get_user_pages_fast(address, 1, rw == VERIFY_WRITE, &page);
+	err = get_user_pages_fast(address, 1, 1, &page);
 	if (err < 0)
 		return err;
 
@@ -304,8 +334,14 @@
  */
 static int fault_in_user_writeable(u32 __user *uaddr)
 {
-	int ret = get_user_pages(current, current->mm, (unsigned long)uaddr,
-				 1, 1, 0, NULL, NULL);
+	struct mm_struct *mm = current->mm;
+	int ret;
+
+	down_read(&mm->mmap_sem);
+	ret = get_user_pages(current, mm, (unsigned long)uaddr,
+			     1, 1, 0, NULL, NULL);
+	up_read(&mm->mmap_sem);
+
 	return ret < 0 ? ret : 0;
 }
 
@@ -526,8 +562,25 @@
 				return -EINVAL;
 
 			WARN_ON(!atomic_read(&pi_state->refcount));
-			WARN_ON(pid && pi_state->owner &&
-				pi_state->owner->pid != pid);
+
+			/*
+			 * When pi_state->owner is NULL then the owner died
+			 * and another waiter is on the fly. pi_state->owner
+			 * is fixed up by the task which acquires
+			 * pi_state->rt_mutex.
+			 *
+			 * We do not check for pid == 0 which can happen when
+			 * the owner died and robust_list_exit() cleared the
+			 * TID.
+			 */
+			if (pid && pi_state->owner) {
+				/*
+				 * Bail out if user space manipulated the
+				 * futex value.
+				 */
+				if (pid != task_pid_vnr(pi_state->owner))
+					return -EINVAL;
+			}
 
 			atomic_inc(&pi_state->refcount);
 			*ps = pi_state;
@@ -754,6 +807,13 @@
 	if (!pi_state)
 		return -EINVAL;
 
+	/*
+	 * If current does not own the pi_state then the futex is
+	 * inconsistent and user space fiddled with the futex value.
+	 */
+	if (pi_state->owner != current)
+		return -EINVAL;
+
 	spin_lock(&pi_state->pi_mutex.wait_lock);
 	new_owner = rt_mutex_next_owner(&pi_state->pi_mutex);
 
@@ -861,7 +921,7 @@
 	if (!bitset)
 		return -EINVAL;
 
-	ret = get_futex_key(uaddr, fshared, &key, VERIFY_READ);
+	ret = get_futex_key(uaddr, fshared, &key);
 	if (unlikely(ret != 0))
 		goto out;
 
@@ -907,10 +967,10 @@
 	int ret, op_ret;
 
 retry:
-	ret = get_futex_key(uaddr1, fshared, &key1, VERIFY_READ);
+	ret = get_futex_key(uaddr1, fshared, &key1);
 	if (unlikely(ret != 0))
 		goto out;
-	ret = get_futex_key(uaddr2, fshared, &key2, VERIFY_WRITE);
+	ret = get_futex_key(uaddr2, fshared, &key2);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
@@ -1169,11 +1229,10 @@
 		pi_state = NULL;
 	}
 
-	ret = get_futex_key(uaddr1, fshared, &key1, VERIFY_READ);
+	ret = get_futex_key(uaddr1, fshared, &key1);
 	if (unlikely(ret != 0))
 		goto out;
-	ret = get_futex_key(uaddr2, fshared, &key2,
-			    requeue_pi ? VERIFY_WRITE : VERIFY_READ);
+	ret = get_futex_key(uaddr2, fshared, &key2);
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
@@ -1732,7 +1791,7 @@
 	 */
 retry:
 	q->key = FUTEX_KEY_INIT;
-	ret = get_futex_key(uaddr, fshared, &q->key, VERIFY_READ);
+	ret = get_futex_key(uaddr, fshared, &q->key);
 	if (unlikely(ret != 0))
 		return ret;
 
@@ -1898,7 +1957,7 @@
 	q.requeue_pi_key = NULL;
 retry:
 	q.key = FUTEX_KEY_INIT;
-	ret = get_futex_key(uaddr, fshared, &q.key, VERIFY_WRITE);
+	ret = get_futex_key(uaddr, fshared, &q.key);
 	if (unlikely(ret != 0))
 		goto out;
 
@@ -1968,7 +2027,7 @@
 	/* Unqueue and drop the lock */
 	unqueue_me_pi(&q);
 
-	goto out;
+	goto out_put_key;
 
 out_unlock_put_key:
 	queue_unlock(&q, hb);
@@ -2017,7 +2076,7 @@
 	if ((uval & FUTEX_TID_MASK) != task_pid_vnr(current))
 		return -EPERM;
 
-	ret = get_futex_key(uaddr, fshared, &key, VERIFY_WRITE);
+	ret = get_futex_key(uaddr, fshared, &key);
 	if (unlikely(ret != 0))
 		goto out;
 
@@ -2209,7 +2268,7 @@
 	rt_waiter.task = NULL;
 
 	key2 = FUTEX_KEY_INIT;
-	ret = get_futex_key(uaddr2, fshared, &key2, VERIFY_WRITE);
+	ret = get_futex_key(uaddr2, fshared, &key2);
 	if (unlikely(ret != 0))
 		goto out;
 
diff -Nur linux-2.6.32-orig/kernel/module.c iDroid-Project-kernel_common-9e90fd2/kernel/module.c
--- linux-2.6.32-orig/kernel/module.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/module.c	2010-11-18 21:05:30.000000000 +0600
@@ -1030,11 +1030,23 @@
 }
 
 #ifdef CONFIG_MODVERSIONS
+/* If the arch applies (non-zero) relocations to kernel kcrctab, unapply it. */
+static unsigned long maybe_relocated(unsigned long crc,
+				     const struct module *crc_owner)
+{
+#ifdef ARCH_RELOCATES_KCRCTAB
+	if (crc_owner == NULL)
+		return crc - (unsigned long)reloc_start;
+#endif
+	return crc;
+}
+
 static int check_version(Elf_Shdr *sechdrs,
 			 unsigned int versindex,
 			 const char *symname,
 			 struct module *mod, 
-			 const unsigned long *crc)
+			 const unsigned long *crc,
+			 const struct module *crc_owner)
 {
 	unsigned int i, num_versions;
 	struct modversion_info *versions;
@@ -1055,10 +1067,10 @@
 		if (strcmp(versions[i].name, symname) != 0)
 			continue;
 
-		if (versions[i].crc == *crc)
+		if (versions[i].crc == maybe_relocated(*crc, crc_owner))
 			return 1;
 		DEBUGP("Found checksum %lX vs module %lX\n",
-		       *crc, versions[i].crc);
+		       maybe_relocated(*crc, crc_owner), versions[i].crc);
 		goto bad_version;
 	}
 
@@ -1081,7 +1093,8 @@
 	if (!find_symbol(MODULE_SYMBOL_PREFIX "module_layout", NULL,
 			 &crc, true, false))
 		BUG();
-	return check_version(sechdrs, versindex, "module_layout", mod, crc);
+	return check_version(sechdrs, versindex, "module_layout", mod, crc,
+			     NULL);
 }
 
 /* First part is kernel version, which we ignore if module has crcs. */
@@ -1099,7 +1112,8 @@
 				unsigned int versindex,
 				const char *symname,
 				struct module *mod, 
-				const unsigned long *crc)
+				const unsigned long *crc,
+				const struct module *crc_owner)
 {
 	return 1;
 }
@@ -1134,8 +1148,8 @@
 	/* use_module can fail due to OOM,
 	   or module initialization or unloading */
 	if (sym) {
-		if (!check_version(sechdrs, versindex, name, mod, crc) ||
-		    !use_module(mod, owner))
+		if (!check_version(sechdrs, versindex, name, mod, crc, owner)
+		    || !use_module(mod, owner))
 			sym = NULL;
 	}
 	return sym;
@@ -1146,6 +1160,12 @@
  * J. Corbet <corbet@lwn.net>
  */
 #if defined(CONFIG_KALLSYMS) && defined(CONFIG_SYSFS)
+
+static inline bool sect_empty(const Elf_Shdr *sect)
+{
+	return !(sect->sh_flags & SHF_ALLOC) || sect->sh_size == 0;
+}
+
 struct module_sect_attr
 {
 	struct module_attribute mattr;
@@ -1187,8 +1207,7 @@
 
 	/* Count loaded sections and allocate structures */
 	for (i = 0; i < nsect; i++)
-		if (sechdrs[i].sh_flags & SHF_ALLOC
-		    && sechdrs[i].sh_size)
+		if (!sect_empty(&sechdrs[i]))
 			nloaded++;
 	size[0] = ALIGN(sizeof(*sect_attrs)
 			+ nloaded * sizeof(sect_attrs->attrs[0]),
@@ -1206,9 +1225,7 @@
 	sattr = &sect_attrs->attrs[0];
 	gattr = &sect_attrs->grp.attrs[0];
 	for (i = 0; i < nsect; i++) {
-		if (! (sechdrs[i].sh_flags & SHF_ALLOC))
-			continue;
-		if (!sechdrs[i].sh_size)
+		if (sect_empty(&sechdrs[i]))
 			continue;
 		sattr->address = sechdrs[i].sh_addr;
 		sattr->name = kstrdup(secstrings + sechdrs[i].sh_name,
@@ -1292,7 +1309,7 @@
 	/* Count notes sections and allocate structures.  */
 	notes = 0;
 	for (i = 0; i < nsect; i++)
-		if ((sechdrs[i].sh_flags & SHF_ALLOC) &&
+		if (!sect_empty(&sechdrs[i]) &&
 		    (sechdrs[i].sh_type == SHT_NOTE))
 			++notes;
 
@@ -1308,7 +1325,7 @@
 	notes_attrs->notes = notes;
 	nattr = &notes_attrs->attrs[0];
 	for (loaded = i = 0; i < nsect; ++i) {
-		if (!(sechdrs[i].sh_flags & SHF_ALLOC))
+		if (sect_empty(&sechdrs[i]))
 			continue;
 		if (sechdrs[i].sh_type == SHT_NOTE) {
 			nattr->attr.name = mod->sect_attrs->attrs[loaded].name;
diff -Nur linux-2.6.32-orig/kernel/panic.c iDroid-Project-kernel_common-9e90fd2/kernel/panic.c
--- linux-2.6.32-orig/kernel/panic.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/panic.c	2010-11-18 21:05:30.000000000 +0600
@@ -29,7 +29,10 @@
 static int pause_on_oops_flag;
 static DEFINE_SPINLOCK(pause_on_oops_lock);
 
-int panic_timeout;
+#ifndef CONFIG_PANIC_TIMEOUT
+#define CONFIG_PANIC_TIMEOUT 0
+#endif
+int panic_timeout = CONFIG_PANIC_TIMEOUT;
 
 ATOMIC_NOTIFIER_HEAD(panic_notifier_list);
 
diff -Nur linux-2.6.32-orig/kernel/perf_event.c iDroid-Project-kernel_common-9e90fd2/kernel/perf_event.c
--- linux-2.6.32-orig/kernel/perf_event.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/perf_event.c	2010-11-18 21:05:30.000000000 +0600
@@ -1359,6 +1359,9 @@
 		if (event->state != PERF_EVENT_STATE_ACTIVE)
 			continue;
 
+		if (event->cpu != -1 && event->cpu != smp_processor_id())
+			continue;
+
 		hwc = &event->hw;
 
 		interrupts = hwc->interrupts;
@@ -1583,7 +1586,7 @@
 		if (perf_paranoid_cpu() && !capable(CAP_SYS_ADMIN))
 			return ERR_PTR(-EACCES);
 
-		if (cpu < 0 || cpu > num_possible_cpus())
+		if (cpu < 0 || cpu >= nr_cpumask_bits)
 			return ERR_PTR(-EINVAL);
 
 		/*
@@ -2174,6 +2177,7 @@
 	perf_mmap_free_page((unsigned long)data->user_page);
 	for (i = 0; i < data->nr_pages; i++)
 		perf_mmap_free_page((unsigned long)data->data_pages[i]);
+	kfree(data);
 }
 
 #else
@@ -2214,6 +2218,7 @@
 		perf_mmap_unmark_page(base + (i * PAGE_SIZE));
 
 	vfree(base);
+	kfree(data);
 }
 
 static void perf_mmap_data_free(struct perf_mmap_data *data)
@@ -2319,7 +2324,6 @@
 
 	data = container_of(rcu_head, struct perf_mmap_data, rcu_head);
 	perf_mmap_data_free(data);
-	kfree(data);
 }
 
 static void perf_mmap_data_release(struct perf_event *event)
@@ -3225,6 +3229,12 @@
 
 static int perf_event_task_match(struct perf_event *event)
 {
+	if (event->state != PERF_EVENT_STATE_ACTIVE)
+		return 0;
+
+	if (event->cpu != -1 && event->cpu != smp_processor_id())
+		return 0;
+
 	if (event->attr.comm || event->attr.mmap || event->attr.task)
 		return 1;
 
@@ -3254,13 +3264,13 @@
 
 	cpuctx = &get_cpu_var(perf_cpu_context);
 	perf_event_task_ctx(&cpuctx->ctx, task_event);
-	put_cpu_var(perf_cpu_context);
 
 	rcu_read_lock();
 	if (!ctx)
 		ctx = rcu_dereference(task_event->task->perf_event_ctxp);
 	if (ctx)
 		perf_event_task_ctx(ctx, task_event);
+	put_cpu_var(perf_cpu_context);
 	rcu_read_unlock();
 }
 
@@ -3337,6 +3347,12 @@
 
 static int perf_event_comm_match(struct perf_event *event)
 {
+	if (event->state != PERF_EVENT_STATE_ACTIVE)
+		return 0;
+
+	if (event->cpu != -1 && event->cpu != smp_processor_id())
+		return 0;
+
 	if (event->attr.comm)
 		return 1;
 
@@ -3377,7 +3393,6 @@
 
 	cpuctx = &get_cpu_var(perf_cpu_context);
 	perf_event_comm_ctx(&cpuctx->ctx, comm_event);
-	put_cpu_var(perf_cpu_context);
 
 	rcu_read_lock();
 	/*
@@ -3387,6 +3402,7 @@
 	ctx = rcu_dereference(current->perf_event_ctxp);
 	if (ctx)
 		perf_event_comm_ctx(ctx, comm_event);
+	put_cpu_var(perf_cpu_context);
 	rcu_read_unlock();
 }
 
@@ -3461,6 +3477,12 @@
 static int perf_event_mmap_match(struct perf_event *event,
 				   struct perf_mmap_event *mmap_event)
 {
+	if (event->state != PERF_EVENT_STATE_ACTIVE)
+		return 0;
+
+	if (event->cpu != -1 && event->cpu != smp_processor_id())
+		return 0;
+
 	if (event->attr.mmap)
 		return 1;
 
@@ -3538,7 +3560,6 @@
 
 	cpuctx = &get_cpu_var(perf_cpu_context);
 	perf_event_mmap_ctx(&cpuctx->ctx, mmap_event);
-	put_cpu_var(perf_cpu_context);
 
 	rcu_read_lock();
 	/*
@@ -3548,6 +3569,7 @@
 	ctx = rcu_dereference(current->perf_event_ctxp);
 	if (ctx)
 		perf_event_mmap_ctx(ctx, mmap_event);
+	put_cpu_var(perf_cpu_context);
 	rcu_read_unlock();
 
 	kfree(buf);
@@ -3810,6 +3832,9 @@
 				enum perf_type_id type,
 				u32 event_id, struct pt_regs *regs)
 {
+	if (event->cpu != -1 && event->cpu != smp_processor_id())
+		return 0;
+
 	if (!perf_swevent_is_counting(event))
 		return 0;
 
@@ -3949,6 +3974,7 @@
 	event->pmu->read(event);
 
 	data.addr = 0;
+	data.period = event->hw.last_period;
 	regs = get_irq_regs();
 	/*
 	 * In case we exclude kernel IPs or are somehow not in interrupt
diff -Nur linux-2.6.32-orig/kernel/power/consoleearlysuspend.c iDroid-Project-kernel_common-9e90fd2/kernel/power/consoleearlysuspend.c
--- linux-2.6.32-orig/kernel/power/consoleearlysuspend.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/kernel/power/consoleearlysuspend.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,78 @@
+/* kernel/power/consoleearlysuspend.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/console.h>
+#include <linux/earlysuspend.h>
+#include <linux/kbd_kern.h>
+#include <linux/module.h>
+#include <linux/vt_kern.h>
+#include <linux/wait.h>
+
+#define EARLY_SUSPEND_CONSOLE	(MAX_NR_CONSOLES-1)
+
+static int orig_fgconsole;
+static void console_early_suspend(struct early_suspend *h)
+{
+	acquire_console_sem();
+	orig_fgconsole = fg_console;
+	if (vc_allocate(EARLY_SUSPEND_CONSOLE))
+		goto err;
+	if (set_console(EARLY_SUSPEND_CONSOLE))
+		goto err;
+	release_console_sem();
+
+	if (vt_waitactive(EARLY_SUSPEND_CONSOLE + 1))
+		pr_warning("console_early_suspend: Can't switch VCs.\n");
+	return;
+err:
+	pr_warning("console_early_suspend: Can't set console\n");
+	release_console_sem();
+}
+
+static void console_late_resume(struct early_suspend *h)
+{
+	int ret;
+	acquire_console_sem();
+	ret = set_console(orig_fgconsole);
+	release_console_sem();
+	if (ret) {
+		pr_warning("console_late_resume: Can't set console.\n");
+		return;
+	}
+
+	if (vt_waitactive(orig_fgconsole + 1))
+		pr_warning("console_late_resume: Can't switch VCs.\n");
+}
+
+static struct early_suspend console_early_suspend_desc = {
+	.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING,
+	.suspend = console_early_suspend,
+	.resume = console_late_resume,
+};
+
+static int __init console_early_suspend_init(void)
+{
+	register_early_suspend(&console_early_suspend_desc);
+	return 0;
+}
+
+static void  __exit console_early_suspend_exit(void)
+{
+	unregister_early_suspend(&console_early_suspend_desc);
+}
+
+module_init(console_early_suspend_init);
+module_exit(console_early_suspend_exit);
+
diff -Nur linux-2.6.32-orig/kernel/power/earlysuspend.c iDroid-Project-kernel_common-9e90fd2/kernel/power/earlysuspend.c
--- linux-2.6.32-orig/kernel/power/earlysuspend.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/kernel/power/earlysuspend.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,178 @@
+/* kernel/power/earlysuspend.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/earlysuspend.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/rtc.h>
+#include <linux/syscalls.h> /* sys_sync */
+#include <linux/wakelock.h>
+#include <linux/workqueue.h>
+
+#include "power.h"
+
+enum {
+	DEBUG_USER_STATE = 1U << 0,
+	DEBUG_SUSPEND = 1U << 2,
+};
+static int debug_mask = DEBUG_USER_STATE;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+static DEFINE_MUTEX(early_suspend_lock);
+static LIST_HEAD(early_suspend_handlers);
+static void early_suspend(struct work_struct *work);
+static void late_resume(struct work_struct *work);
+static DECLARE_WORK(early_suspend_work, early_suspend);
+static DECLARE_WORK(late_resume_work, late_resume);
+static DEFINE_SPINLOCK(state_lock);
+enum {
+	SUSPEND_REQUESTED = 0x1,
+	SUSPENDED = 0x2,
+	SUSPEND_REQUESTED_AND_SUSPENDED = SUSPEND_REQUESTED | SUSPENDED,
+};
+static int state;
+
+void register_early_suspend(struct early_suspend *handler)
+{
+	struct list_head *pos;
+
+	mutex_lock(&early_suspend_lock);
+	list_for_each(pos, &early_suspend_handlers) {
+		struct early_suspend *e;
+		e = list_entry(pos, struct early_suspend, link);
+		if (e->level > handler->level)
+			break;
+	}
+	list_add_tail(&handler->link, pos);
+	if ((state & SUSPENDED) && handler->suspend)
+		handler->suspend(handler);
+	mutex_unlock(&early_suspend_lock);
+}
+EXPORT_SYMBOL(register_early_suspend);
+
+void unregister_early_suspend(struct early_suspend *handler)
+{
+	mutex_lock(&early_suspend_lock);
+	list_del(&handler->link);
+	mutex_unlock(&early_suspend_lock);
+}
+EXPORT_SYMBOL(unregister_early_suspend);
+
+static void early_suspend(struct work_struct *work)
+{
+	struct early_suspend *pos;
+	unsigned long irqflags;
+	int abort = 0;
+
+	mutex_lock(&early_suspend_lock);
+	spin_lock_irqsave(&state_lock, irqflags);
+	if (state == SUSPEND_REQUESTED)
+		state |= SUSPENDED;
+	else
+		abort = 1;
+	spin_unlock_irqrestore(&state_lock, irqflags);
+
+	if (abort) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("early_suspend: abort, state %d\n", state);
+		mutex_unlock(&early_suspend_lock);
+		goto abort;
+	}
+
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("early_suspend: call handlers\n");
+	list_for_each_entry(pos, &early_suspend_handlers, link) {
+		if (pos->suspend != NULL)
+			pos->suspend(pos);
+	}
+	mutex_unlock(&early_suspend_lock);
+
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("early_suspend: sync\n");
+
+	sys_sync();
+abort:
+	spin_lock_irqsave(&state_lock, irqflags);
+	if (state == SUSPEND_REQUESTED_AND_SUSPENDED)
+		wake_unlock(&main_wake_lock);
+	spin_unlock_irqrestore(&state_lock, irqflags);
+}
+
+static void late_resume(struct work_struct *work)
+{
+	struct early_suspend *pos;
+	unsigned long irqflags;
+	int abort = 0;
+
+	mutex_lock(&early_suspend_lock);
+	spin_lock_irqsave(&state_lock, irqflags);
+	if (state == SUSPENDED)
+		state &= ~SUSPENDED;
+	else
+		abort = 1;
+	spin_unlock_irqrestore(&state_lock, irqflags);
+
+	if (abort) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("late_resume: abort, state %d\n", state);
+		goto abort;
+	}
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("late_resume: call handlers\n");
+	list_for_each_entry_reverse(pos, &early_suspend_handlers, link)
+		if (pos->resume != NULL)
+			pos->resume(pos);
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("late_resume: done\n");
+abort:
+	mutex_unlock(&early_suspend_lock);
+}
+
+void request_suspend_state(suspend_state_t new_state)
+{
+	unsigned long irqflags;
+	int old_sleep;
+
+	spin_lock_irqsave(&state_lock, irqflags);
+	old_sleep = state & SUSPEND_REQUESTED;
+	if (debug_mask & DEBUG_USER_STATE) {
+		struct timespec ts;
+		struct rtc_time tm;
+		getnstimeofday(&ts);
+		rtc_time_to_tm(ts.tv_sec, &tm);
+		pr_info("request_suspend_state: %s (%d->%d) at %lld "
+			"(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n",
+			new_state != PM_SUSPEND_ON ? "sleep" : "wakeup",
+			requested_suspend_state, new_state,
+			ktime_to_ns(ktime_get()),
+			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
+	}
+	if (!old_sleep && new_state != PM_SUSPEND_ON) {
+		state |= SUSPEND_REQUESTED;
+		queue_work(suspend_work_queue, &early_suspend_work);
+	} else if (old_sleep && new_state == PM_SUSPEND_ON) {
+		state &= ~SUSPEND_REQUESTED;
+		wake_lock(&main_wake_lock);
+		queue_work(suspend_work_queue, &late_resume_work);
+	}
+	requested_suspend_state = new_state;
+	spin_unlock_irqrestore(&state_lock, irqflags);
+}
+
+suspend_state_t get_suspend_state(void)
+{
+	return requested_suspend_state;
+}
diff -Nur linux-2.6.32-orig/kernel/power/fbearlysuspend.c iDroid-Project-kernel_common-9e90fd2/kernel/power/fbearlysuspend.c
--- linux-2.6.32-orig/kernel/power/fbearlysuspend.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/kernel/power/fbearlysuspend.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,153 @@
+/* kernel/power/fbearlysuspend.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/earlysuspend.h>
+#include <linux/module.h>
+#include <linux/wait.h>
+
+#include "power.h"
+
+static wait_queue_head_t fb_state_wq;
+static DEFINE_SPINLOCK(fb_state_lock);
+static enum {
+	FB_STATE_STOPPED_DRAWING,
+	FB_STATE_REQUEST_STOP_DRAWING,
+	FB_STATE_DRAWING_OK,
+} fb_state;
+
+/* tell userspace to stop drawing, wait for it to stop */
+static void stop_drawing_early_suspend(struct early_suspend *h)
+{
+	int ret;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&fb_state_lock, irq_flags);
+	fb_state = FB_STATE_REQUEST_STOP_DRAWING;
+	spin_unlock_irqrestore(&fb_state_lock, irq_flags);
+
+	wake_up_all(&fb_state_wq);
+	ret = wait_event_timeout(fb_state_wq,
+				 fb_state == FB_STATE_STOPPED_DRAWING,
+				 HZ);
+	if (unlikely(fb_state != FB_STATE_STOPPED_DRAWING))
+		pr_warning("stop_drawing_early_suspend: timeout waiting for "
+			   "userspace to stop drawing\n");
+}
+
+/* tell userspace to start drawing */
+static void start_drawing_late_resume(struct early_suspend *h)
+{
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&fb_state_lock, irq_flags);
+	fb_state = FB_STATE_DRAWING_OK;
+	spin_unlock_irqrestore(&fb_state_lock, irq_flags);
+	wake_up(&fb_state_wq);
+}
+
+static struct early_suspend stop_drawing_early_suspend_desc = {
+	.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING,
+	.suspend = stop_drawing_early_suspend,
+	.resume = start_drawing_late_resume,
+};
+
+static ssize_t wait_for_fb_sleep_show(struct kobject *kobj,
+				      struct kobj_attribute *attr, char *buf)
+{
+	char *s = buf;
+	int ret;
+
+	ret = wait_event_interruptible(fb_state_wq,
+				       fb_state != FB_STATE_DRAWING_OK);
+	if (ret && fb_state == FB_STATE_DRAWING_OK)
+		return ret;
+	else
+		s += sprintf(buf, "sleeping");
+	return s - buf;
+}
+
+static ssize_t wait_for_fb_wake_show(struct kobject *kobj,
+				     struct kobj_attribute *attr, char *buf)
+{
+	char *s = buf;
+	int ret;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&fb_state_lock, irq_flags);
+	if (fb_state == FB_STATE_REQUEST_STOP_DRAWING) {
+		fb_state = FB_STATE_STOPPED_DRAWING;
+		wake_up(&fb_state_wq);
+	}
+	spin_unlock_irqrestore(&fb_state_lock, irq_flags);
+
+	ret = wait_event_interruptible(fb_state_wq,
+				       fb_state == FB_STATE_DRAWING_OK);
+	if (ret && fb_state != FB_STATE_DRAWING_OK)
+		return ret;
+	else
+		s += sprintf(buf, "awake");
+
+	return s - buf;
+}
+
+#define power_ro_attr(_name) \
+static struct kobj_attribute _name##_attr = {	\
+	.attr	= {				\
+		.name = __stringify(_name),	\
+		.mode = 0444,			\
+	},					\
+	.show	= _name##_show,			\
+	.store	= NULL,		\
+}
+
+power_ro_attr(wait_for_fb_sleep);
+power_ro_attr(wait_for_fb_wake);
+
+static struct attribute *g[] = {
+	&wait_for_fb_sleep_attr.attr,
+	&wait_for_fb_wake_attr.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = g,
+};
+
+static int __init android_power_init(void)
+{
+	int ret;
+
+	init_waitqueue_head(&fb_state_wq);
+	fb_state = FB_STATE_DRAWING_OK;
+
+	ret = sysfs_create_group(power_kobj, &attr_group);
+	if (ret) {
+		pr_err("android_power_init: sysfs_create_group failed\n");
+		return ret;
+	}
+
+	register_early_suspend(&stop_drawing_early_suspend_desc);
+	return 0;
+}
+
+static void  __exit android_power_exit(void)
+{
+	unregister_early_suspend(&stop_drawing_early_suspend_desc);
+	sysfs_remove_group(power_kobj, &attr_group);
+}
+
+module_init(android_power_init);
+module_exit(android_power_exit);
+
diff -Nur linux-2.6.32-orig/kernel/power/Kconfig iDroid-Project-kernel_common-9e90fd2/kernel/power/Kconfig
--- linux-2.6.32-orig/kernel/power/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/power/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -119,6 +119,73 @@
 config HIBERNATION_NVS
 	bool
 
+config HAS_WAKELOCK
+	bool
+
+config HAS_EARLYSUSPEND
+	bool
+
+config WAKELOCK
+	bool "Wake lock"
+	depends on PM && RTC_CLASS
+	default n
+	select HAS_WAKELOCK
+	---help---
+	  Enable wakelocks. When user space request a sleep state the
+	  sleep request will be delayed until no wake locks are held.
+
+config WAKELOCK_STAT
+	bool "Wake lock stats"
+	depends on WAKELOCK
+	default y
+	---help---
+	  Report wake lock stats in /proc/wakelocks
+
+config USER_WAKELOCK
+	bool "Userspace wake locks"
+	depends on WAKELOCK
+	default y
+	---help---
+	  User-space wake lock api. Write "lockname" or "lockname timeout"
+	  to /sys/power/wake_lock lock and if needed create a wake lock.
+	  Write "lockname" to /sys/power/wake_unlock to unlock a user wake
+	  lock.
+
+config EARLYSUSPEND
+	bool "Early suspend"
+	depends on WAKELOCK
+	default y
+	select HAS_EARLYSUSPEND
+	---help---
+	  Call early suspend handlers when the user requested sleep state
+	  changes.
+
+choice
+	prompt "User-space screen access"
+	default FB_EARLYSUSPEND if !FRAMEBUFFER_CONSOLE
+	default CONSOLE_EARLYSUSPEND
+	depends on HAS_EARLYSUSPEND
+
+	config NO_USER_SPACE_SCREEN_ACCESS_CONTROL
+		bool "None"
+
+	config CONSOLE_EARLYSUSPEND
+		bool "Console switch on early-suspend"
+		depends on HAS_EARLYSUSPEND && VT
+		---help---
+		  Register early suspend handler to perform a console switch to
+		  when user-space should stop drawing to the screen and a switch
+		  back when it should resume.
+
+	config FB_EARLYSUSPEND
+		bool "Sysfs interface"
+		depends on HAS_EARLYSUSPEND
+		---help---
+		  Register early suspend handler that notifies and waits for
+		  user-space through sysfs when user-space should stop drawing
+		  to the screen and notifies user-space when it should resume.
+endchoice
+
 config HIBERNATION
 	bool "Hibernation (aka 'suspend to disk')"
 	depends on PM && SWAP && ARCH_HIBERNATION_POSSIBLE
diff -Nur linux-2.6.32-orig/kernel/power/main.c iDroid-Project-kernel_common-9e90fd2/kernel/power/main.c
--- linux-2.6.32-orig/kernel/power/main.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/power/main.c	2010-11-18 21:05:30.000000000 +0600
@@ -147,7 +147,11 @@
 			   const char *buf, size_t n)
 {
 #ifdef CONFIG_SUSPEND
+#ifdef CONFIG_EARLYSUSPEND
+	suspend_state_t state = PM_SUSPEND_ON;
+#else
 	suspend_state_t state = PM_SUSPEND_STANDBY;
+#endif
 	const char * const *s;
 #endif
 	char *p;
@@ -169,8 +173,15 @@
 			break;
 	}
 	if (state < PM_SUSPEND_MAX && *s)
+#ifdef CONFIG_EARLYSUSPEND
+		if (state == PM_SUSPEND_ON || valid_state(state)) {
+			error = 0;
+			request_suspend_state(state);
+		}
+#else
 		error = enter_state(state);
 #endif
+#endif
 
  Exit:
 	return error ? error : n;
@@ -203,6 +214,11 @@
 power_attr(pm_trace);
 #endif /* CONFIG_PM_TRACE */
 
+#ifdef CONFIG_USER_WAKELOCK
+power_attr(wake_lock);
+power_attr(wake_unlock);
+#endif
+
 static struct attribute * g[] = {
 	&state_attr.attr,
 #ifdef CONFIG_PM_TRACE
@@ -211,6 +227,10 @@
 #if defined(CONFIG_PM_SLEEP) && defined(CONFIG_PM_DEBUG)
 	&pm_test_attr.attr,
 #endif
+#ifdef CONFIG_USER_WAKELOCK
+	&wake_lock_attr.attr,
+	&wake_unlock_attr.attr,
+#endif
 	NULL,
 };
 
diff -Nur linux-2.6.32-orig/kernel/power/Makefile iDroid-Project-kernel_common-9e90fd2/kernel/power/Makefile
--- linux-2.6.32-orig/kernel/power/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/power/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -10,5 +10,10 @@
 obj-$(CONFIG_PM_TEST_SUSPEND)	+= suspend_test.o
 obj-$(CONFIG_HIBERNATION)	+= swsusp.o hibernate.o snapshot.o swap.o user.o
 obj-$(CONFIG_HIBERNATION_NVS)	+= hibernate_nvs.o
+obj-$(CONFIG_WAKELOCK)		+= wakelock.o
+obj-$(CONFIG_USER_WAKELOCK)	+= userwakelock.o
+obj-$(CONFIG_EARLYSUSPEND)	+= earlysuspend.o
+obj-$(CONFIG_CONSOLE_EARLYSUSPEND)	+= consoleearlysuspend.o
+obj-$(CONFIG_FB_EARLYSUSPEND)	+= fbearlysuspend.o
 
 obj-$(CONFIG_MAGIC_SYSRQ)	+= poweroff.o
diff -Nur linux-2.6.32-orig/kernel/power/power.h iDroid-Project-kernel_common-9e90fd2/kernel/power/power.h
--- linux-2.6.32-orig/kernel/power/power.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/power/power.h	2010-11-18 21:05:30.000000000 +0600
@@ -236,3 +236,27 @@
 {
 }
 #endif
+
+#ifdef CONFIG_WAKELOCK
+/* kernel/power/wakelock.c */
+extern struct workqueue_struct *suspend_work_queue;
+extern struct wake_lock main_wake_lock;
+extern suspend_state_t requested_suspend_state;
+#endif
+
+#ifdef CONFIG_USER_WAKELOCK
+ssize_t wake_lock_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf);
+ssize_t wake_lock_store(struct kobject *kobj, struct kobj_attribute *attr,
+			const char *buf, size_t n);
+ssize_t wake_unlock_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf);
+ssize_t  wake_unlock_store(struct kobject *kobj, struct kobj_attribute *attr,
+			const char *buf, size_t n);
+#endif
+
+#ifdef CONFIG_EARLYSUSPEND
+/* kernel/power/earlysuspend.c */
+void request_suspend_state(suspend_state_t state);
+suspend_state_t get_suspend_state(void);
+#endif
diff -Nur linux-2.6.32-orig/kernel/power/process.c iDroid-Project-kernel_common-9e90fd2/kernel/power/process.c
--- linux-2.6.32-orig/kernel/power/process.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/power/process.c	2010-11-18 21:05:30.000000000 +0600
@@ -14,6 +14,7 @@
 #include <linux/module.h>
 #include <linux/syscalls.h>
 #include <linux/freezer.h>
+#include <linux/wakelock.h>
 
 /* 
  * Timeout for stopping processes
@@ -37,6 +38,7 @@
 	struct timeval start, end;
 	u64 elapsed_csecs64;
 	unsigned int elapsed_csecs;
+	unsigned int wakeup = 0;
 
 	do_gettimeofday(&start);
 
@@ -63,6 +65,10 @@
 		} while_each_thread(g, p);
 		read_unlock(&tasklist_lock);
 		yield();			/* Yield is okay here */
+		if (todo && has_wake_lock(WAKE_LOCK_SUSPEND)) {
+			wakeup = 1;
+			break;
+		}
 		if (time_after(jiffies, end_time))
 			break;
 	} while (todo);
@@ -79,14 +85,17 @@
 		 * but it cleans up leftover PF_FREEZE requests.
 		 */
 		printk("\n");
-		printk(KERN_ERR "Freezing of tasks failed after %d.%02d seconds "
+		printk(KERN_ERR "Freezing of tasks %s after %d.%02d seconds "
 				"(%d tasks refusing to freeze):\n",
+				wakeup ? "aborted" : "failed",
 				elapsed_csecs / 100, elapsed_csecs % 100, todo);
-		show_state();
+		if(!wakeup)
+			show_state();
 		read_lock(&tasklist_lock);
 		do_each_thread(g, p) {
 			task_lock(p);
-			if (freezing(p) && !freezer_should_skip(p))
+			if (freezing(p) && !freezer_should_skip(p) &&
+							elapsed_csecs > 100)
 				printk(KERN_ERR " %s\n", p->comm);
 			cancel_freezing(p);
 			task_unlock(p);
diff -Nur linux-2.6.32-orig/kernel/power/suspend.c iDroid-Project-kernel_common-9e90fd2/kernel/power/suspend.c
--- linux-2.6.32-orig/kernel/power/suspend.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/power/suspend.c	2010-11-18 21:05:30.000000000 +0600
@@ -19,6 +19,9 @@
 #include "power.h"
 
 const char *const pm_states[PM_SUSPEND_MAX] = {
+#ifdef CONFIG_EARLYSUSPEND
+	[PM_SUSPEND_ON]		= "on",
+#endif
 	[PM_SUSPEND_STANDBY]	= "standby",
 	[PM_SUSPEND_MEM]	= "mem",
 };
diff -Nur linux-2.6.32-orig/kernel/power/userwakelock.c iDroid-Project-kernel_common-9e90fd2/kernel/power/userwakelock.c
--- linux-2.6.32-orig/kernel/power/userwakelock.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/kernel/power/userwakelock.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,218 @@
+/* kernel/power/userwakelock.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/ctype.h>
+#include <linux/module.h>
+#include <linux/wakelock.h>
+
+#include "power.h"
+
+enum {
+	DEBUG_FAILURE	= BIT(0),
+	DEBUG_ERROR	= BIT(1),
+	DEBUG_NEW	= BIT(2),
+	DEBUG_ACCESS	= BIT(3),
+	DEBUG_LOOKUP	= BIT(4),
+};
+static int debug_mask = DEBUG_FAILURE;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+static DEFINE_MUTEX(tree_lock);
+
+struct user_wake_lock {
+	struct rb_node		node;
+	struct wake_lock	wake_lock;
+	char			name[0];
+};
+struct rb_root user_wake_locks;
+
+static struct user_wake_lock *lookup_wake_lock_name(
+	const char *buf, int allocate, long *timeoutptr)
+{
+	struct rb_node **p = &user_wake_locks.rb_node;
+	struct rb_node *parent = NULL;
+	struct user_wake_lock *l;
+	int diff;
+	u64 timeout;
+	int name_len;
+	const char *arg;
+
+	/* Find length of lock name and start of optional timeout string */
+	arg = buf;
+	while (*arg && !isspace(*arg))
+		arg++;
+	name_len = arg - buf;
+	if (!name_len)
+		goto bad_arg;
+	while (isspace(*arg))
+		arg++;
+
+	/* Process timeout string */
+	if (timeoutptr && *arg) {
+		timeout = simple_strtoull(arg, (char **)&arg, 0);
+		while (isspace(*arg))
+			arg++;
+		if (*arg)
+			goto bad_arg;
+		/* convert timeout from nanoseconds to jiffies > 0 */
+		timeout += (NSEC_PER_SEC / HZ) - 1;
+		do_div(timeout, (NSEC_PER_SEC / HZ));
+		if (timeout <= 0)
+			timeout = 1;
+		*timeoutptr = timeout;
+	} else if (*arg)
+		goto bad_arg;
+	else if (timeoutptr)
+		*timeoutptr = 0;
+
+	/* Lookup wake lock in rbtree */
+	while (*p) {
+		parent = *p;
+		l = rb_entry(parent, struct user_wake_lock, node);
+		diff = strncmp(buf, l->name, name_len);
+		if (!diff && l->name[name_len])
+			diff = -1;
+		if (debug_mask & DEBUG_ERROR)
+			pr_info("lookup_wake_lock_name: compare %.*s %s %d\n",
+				name_len, buf, l->name, diff);
+
+		if (diff < 0)
+			p = &(*p)->rb_left;
+		else if (diff > 0)
+			p = &(*p)->rb_right;
+		else
+			return l;
+	}
+
+	/* Allocate and add new wakelock to rbtree */
+	if (!allocate) {
+		if (debug_mask & DEBUG_ERROR)
+			pr_info("lookup_wake_lock_name: %.*s not found\n",
+				name_len, buf);
+		return ERR_PTR(-EINVAL);
+	}
+	l = kzalloc(sizeof(*l) + name_len + 1, GFP_KERNEL);
+	if (l == NULL) {
+		if (debug_mask & DEBUG_FAILURE)
+			pr_err("lookup_wake_lock_name: failed to allocate "
+				"memory for %.*s\n", name_len, buf);
+		return ERR_PTR(-ENOMEM);
+	}
+	memcpy(l->name, buf, name_len);
+	if (debug_mask & DEBUG_NEW)
+		pr_info("lookup_wake_lock_name: new wake lock %s\n", l->name);
+	wake_lock_init(&l->wake_lock, WAKE_LOCK_SUSPEND, l->name);
+	rb_link_node(&l->node, parent, p);
+	rb_insert_color(&l->node, &user_wake_locks);
+	return l;
+
+bad_arg:
+	if (debug_mask & DEBUG_ERROR)
+		pr_info("lookup_wake_lock_name: wake lock, %.*s, bad arg, %s\n",
+			name_len, buf, arg);
+	return ERR_PTR(-EINVAL);
+}
+
+ssize_t wake_lock_show(
+	struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	char *s = buf;
+	char *end = buf + PAGE_SIZE;
+	struct rb_node *n;
+	struct user_wake_lock *l;
+
+	mutex_lock(&tree_lock);
+
+	for (n = rb_first(&user_wake_locks); n != NULL; n = rb_next(n)) {
+		l = rb_entry(n, struct user_wake_lock, node);
+		if (wake_lock_active(&l->wake_lock))
+			s += scnprintf(s, end - s, "%s ", l->name);
+	}
+	s += scnprintf(s, end - s, "\n");
+
+	mutex_unlock(&tree_lock);
+	return (s - buf);
+}
+
+ssize_t wake_lock_store(
+	struct kobject *kobj, struct kobj_attribute *attr,
+	const char *buf, size_t n)
+{
+	long timeout;
+	struct user_wake_lock *l;
+
+	mutex_lock(&tree_lock);
+	l = lookup_wake_lock_name(buf, 1, &timeout);
+	if (IS_ERR(l)) {
+		n = PTR_ERR(l);
+		goto bad_name;
+	}
+
+	if (debug_mask & DEBUG_ACCESS)
+		pr_info("wake_lock_store: %s, timeout %ld\n", l->name, timeout);
+
+	if (timeout)
+		wake_lock_timeout(&l->wake_lock, timeout);
+	else
+		wake_lock(&l->wake_lock);
+bad_name:
+	mutex_unlock(&tree_lock);
+	return n;
+}
+
+
+ssize_t wake_unlock_show(
+	struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	char *s = buf;
+	char *end = buf + PAGE_SIZE;
+	struct rb_node *n;
+	struct user_wake_lock *l;
+
+	mutex_lock(&tree_lock);
+
+	for (n = rb_first(&user_wake_locks); n != NULL; n = rb_next(n)) {
+		l = rb_entry(n, struct user_wake_lock, node);
+		if (!wake_lock_active(&l->wake_lock))
+			s += scnprintf(s, end - s, "%s ", l->name);
+	}
+	s += scnprintf(s, end - s, "\n");
+
+	mutex_unlock(&tree_lock);
+	return (s - buf);
+}
+
+ssize_t wake_unlock_store(
+	struct kobject *kobj, struct kobj_attribute *attr,
+	const char *buf, size_t n)
+{
+	struct user_wake_lock *l;
+
+	mutex_lock(&tree_lock);
+	l = lookup_wake_lock_name(buf, 0, NULL);
+	if (IS_ERR(l)) {
+		n = PTR_ERR(l);
+		goto not_found;
+	}
+
+	if (debug_mask & DEBUG_ACCESS)
+		pr_info("wake_unlock_store: %s\n", l->name);
+
+	wake_unlock(&l->wake_lock);
+not_found:
+	mutex_unlock(&tree_lock);
+	return n;
+}
+
diff -Nur linux-2.6.32-orig/kernel/power/wakelock.c iDroid-Project-kernel_common-9e90fd2/kernel/power/wakelock.c
--- linux-2.6.32-orig/kernel/power/wakelock.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/kernel/power/wakelock.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,607 @@
+/* kernel/power/wakelock.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+#include <linux/suspend.h>
+#include <linux/syscalls.h> /* sys_sync */
+#include <linux/wakelock.h>
+#ifdef CONFIG_WAKELOCK_STAT
+#include <linux/proc_fs.h>
+#endif
+#include "power.h"
+
+enum {
+	DEBUG_EXIT_SUSPEND = 1U << 0,
+	DEBUG_WAKEUP = 1U << 1,
+	DEBUG_SUSPEND = 1U << 2,
+	DEBUG_EXPIRE = 1U << 3,
+	DEBUG_WAKE_LOCK = 1U << 4,
+};
+static int debug_mask = DEBUG_EXIT_SUSPEND | DEBUG_WAKEUP;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+#define WAKE_LOCK_TYPE_MASK              (0x0f)
+#define WAKE_LOCK_INITIALIZED            (1U << 8)
+#define WAKE_LOCK_ACTIVE                 (1U << 9)
+#define WAKE_LOCK_AUTO_EXPIRE            (1U << 10)
+#define WAKE_LOCK_PREVENTING_SUSPEND     (1U << 11)
+
+static DEFINE_SPINLOCK(list_lock);
+static LIST_HEAD(inactive_locks);
+static struct list_head active_wake_locks[WAKE_LOCK_TYPE_COUNT];
+static int current_event_num;
+struct workqueue_struct *suspend_work_queue;
+struct wake_lock main_wake_lock;
+suspend_state_t requested_suspend_state = PM_SUSPEND_MEM;
+static struct wake_lock unknown_wakeup;
+
+#ifdef CONFIG_WAKELOCK_STAT
+static struct wake_lock deleted_wake_locks;
+static ktime_t last_sleep_time_update;
+static int wait_for_wakeup;
+
+int get_expired_time(struct wake_lock *lock, ktime_t *expire_time)
+{
+	struct timespec ts;
+	struct timespec kt;
+	struct timespec tomono;
+	struct timespec delta;
+	unsigned long seq;
+	long timeout;
+
+	if (!(lock->flags & WAKE_LOCK_AUTO_EXPIRE))
+		return 0;
+	do {
+		seq = read_seqbegin(&xtime_lock);
+		timeout = lock->expires - jiffies;
+		if (timeout > 0)
+			return 0;
+		kt = current_kernel_time();
+		tomono = wall_to_monotonic;
+	} while (read_seqretry(&xtime_lock, seq));
+	jiffies_to_timespec(-timeout, &delta);
+	set_normalized_timespec(&ts, kt.tv_sec + tomono.tv_sec - delta.tv_sec,
+				kt.tv_nsec + tomono.tv_nsec - delta.tv_nsec);
+	*expire_time = timespec_to_ktime(ts);
+	return 1;
+}
+
+
+static int print_lock_stat(struct seq_file *m, struct wake_lock *lock)
+{
+	int lock_count = lock->stat.count;
+	int expire_count = lock->stat.expire_count;
+	ktime_t active_time = ktime_set(0, 0);
+	ktime_t total_time = lock->stat.total_time;
+	ktime_t max_time = lock->stat.max_time;
+
+	ktime_t prevent_suspend_time = lock->stat.prevent_suspend_time;
+	if (lock->flags & WAKE_LOCK_ACTIVE) {
+		ktime_t now, add_time;
+		int expired = get_expired_time(lock, &now);
+		if (!expired)
+			now = ktime_get();
+		add_time = ktime_sub(now, lock->stat.last_time);
+		lock_count++;
+		if (!expired)
+			active_time = add_time;
+		else
+			expire_count++;
+		total_time = ktime_add(total_time, add_time);
+		if (lock->flags & WAKE_LOCK_PREVENTING_SUSPEND)
+			prevent_suspend_time = ktime_add(prevent_suspend_time,
+					ktime_sub(now, last_sleep_time_update));
+		if (add_time.tv64 > max_time.tv64)
+			max_time = add_time;
+	}
+
+	return seq_printf(m,
+		     "\"%s\"\t%d\t%d\t%d\t%lld\t%lld\t%lld\t%lld\t%lld\n",
+		     lock->name, lock_count, expire_count,
+		     lock->stat.wakeup_count, ktime_to_ns(active_time),
+		     ktime_to_ns(total_time),
+		     ktime_to_ns(prevent_suspend_time), ktime_to_ns(max_time),
+		     ktime_to_ns(lock->stat.last_time));
+}
+
+static int wakelock_stats_show(struct seq_file *m, void *unused)
+{
+	unsigned long irqflags;
+	struct wake_lock *lock;
+	int ret;
+	int type;
+
+	spin_lock_irqsave(&list_lock, irqflags);
+
+	ret = seq_puts(m, "name\tcount\texpire_count\twake_count\tactive_since"
+			"\ttotal_time\tsleep_time\tmax_time\tlast_change\n");
+	list_for_each_entry(lock, &inactive_locks, link)
+		ret = print_lock_stat(m, lock);
+	for (type = 0; type < WAKE_LOCK_TYPE_COUNT; type++) {
+		list_for_each_entry(lock, &active_wake_locks[type], link)
+			ret = print_lock_stat(m, lock);
+	}
+	spin_unlock_irqrestore(&list_lock, irqflags);
+	return 0;
+}
+
+static void wake_unlock_stat_locked(struct wake_lock *lock, int expired)
+{
+	ktime_t duration;
+	ktime_t now;
+	if (!(lock->flags & WAKE_LOCK_ACTIVE))
+		return;
+	if (get_expired_time(lock, &now))
+		expired = 1;
+	else
+		now = ktime_get();
+	lock->stat.count++;
+	if (expired)
+		lock->stat.expire_count++;
+	duration = ktime_sub(now, lock->stat.last_time);
+	lock->stat.total_time = ktime_add(lock->stat.total_time, duration);
+	if (ktime_to_ns(duration) > ktime_to_ns(lock->stat.max_time))
+		lock->stat.max_time = duration;
+	lock->stat.last_time = ktime_get();
+	if (lock->flags & WAKE_LOCK_PREVENTING_SUSPEND) {
+		duration = ktime_sub(now, last_sleep_time_update);
+		lock->stat.prevent_suspend_time = ktime_add(
+			lock->stat.prevent_suspend_time, duration);
+		lock->flags &= ~WAKE_LOCK_PREVENTING_SUSPEND;
+	}
+}
+
+static void update_sleep_wait_stats_locked(int done)
+{
+	struct wake_lock *lock;
+	ktime_t now, etime, elapsed, add;
+	int expired;
+
+	now = ktime_get();
+	elapsed = ktime_sub(now, last_sleep_time_update);
+	list_for_each_entry(lock, &active_wake_locks[WAKE_LOCK_SUSPEND], link) {
+		expired = get_expired_time(lock, &etime);
+		if (lock->flags & WAKE_LOCK_PREVENTING_SUSPEND) {
+			if (expired)
+				add = ktime_sub(etime, last_sleep_time_update);
+			else
+				add = elapsed;
+			lock->stat.prevent_suspend_time = ktime_add(
+				lock->stat.prevent_suspend_time, add);
+		}
+		if (done || expired)
+			lock->flags &= ~WAKE_LOCK_PREVENTING_SUSPEND;
+		else
+			lock->flags |= WAKE_LOCK_PREVENTING_SUSPEND;
+	}
+	last_sleep_time_update = now;
+}
+#endif
+
+
+static void expire_wake_lock(struct wake_lock *lock)
+{
+#ifdef CONFIG_WAKELOCK_STAT
+	wake_unlock_stat_locked(lock, 1);
+#endif
+	lock->flags &= ~(WAKE_LOCK_ACTIVE | WAKE_LOCK_AUTO_EXPIRE);
+	list_del(&lock->link);
+	list_add(&lock->link, &inactive_locks);
+	if (debug_mask & (DEBUG_WAKE_LOCK | DEBUG_EXPIRE))
+		pr_info("expired wake lock %s\n", lock->name);
+}
+
+/* Caller must acquire the list_lock spinlock */
+static void print_active_locks(int type)
+{
+	struct wake_lock *lock;
+	bool print_expired = true;
+
+	BUG_ON(type >= WAKE_LOCK_TYPE_COUNT);
+	list_for_each_entry(lock, &active_wake_locks[type], link) {
+		if (lock->flags & WAKE_LOCK_AUTO_EXPIRE) {
+			long timeout = lock->expires - jiffies;
+			if (timeout > 0)
+				pr_info("active wake lock %s, time left %ld\n",
+					lock->name, timeout);
+			else if (print_expired)
+				pr_info("wake lock %s, expired\n", lock->name);
+		} else {
+			pr_info("active wake lock %s\n", lock->name);
+			if (!debug_mask & DEBUG_EXPIRE)
+				print_expired = false;
+		}
+	}
+}
+
+static long has_wake_lock_locked(int type)
+{
+	struct wake_lock *lock, *n;
+	long max_timeout = 0;
+
+	BUG_ON(type >= WAKE_LOCK_TYPE_COUNT);
+	list_for_each_entry_safe(lock, n, &active_wake_locks[type], link) {
+		if (lock->flags & WAKE_LOCK_AUTO_EXPIRE) {
+			long timeout = lock->expires - jiffies;
+			if (timeout <= 0)
+				expire_wake_lock(lock);
+			else if (timeout > max_timeout)
+				max_timeout = timeout;
+		} else
+			return -1;
+	}
+	return max_timeout;
+}
+
+long has_wake_lock(int type)
+{
+	long ret;
+	unsigned long irqflags;
+	spin_lock_irqsave(&list_lock, irqflags);
+	ret = has_wake_lock_locked(type);
+	if (ret && (debug_mask & DEBUG_SUSPEND) && type == WAKE_LOCK_SUSPEND)
+		print_active_locks(type);
+	spin_unlock_irqrestore(&list_lock, irqflags);
+	return ret;
+}
+
+static void suspend(struct work_struct *work)
+{
+	int ret;
+	int entry_event_num;
+
+	if (has_wake_lock(WAKE_LOCK_SUSPEND)) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("suspend: abort suspend\n");
+		return;
+	}
+
+	entry_event_num = current_event_num;
+	sys_sync();
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("suspend: enter suspend\n");
+	ret = pm_suspend(requested_suspend_state);
+	if (debug_mask & DEBUG_EXIT_SUSPEND) {
+		struct timespec ts;
+		struct rtc_time tm;
+		getnstimeofday(&ts);
+		rtc_time_to_tm(ts.tv_sec, &tm);
+		pr_info("suspend: exit suspend, ret = %d "
+			"(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n", ret,
+			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
+	}
+	if (current_event_num == entry_event_num) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("suspend: pm_suspend returned with no event\n");
+		wake_lock_timeout(&unknown_wakeup, HZ / 2);
+	}
+}
+static DECLARE_WORK(suspend_work, suspend);
+
+static void expire_wake_locks(unsigned long data)
+{
+	long has_lock;
+	unsigned long irqflags;
+	if (debug_mask & DEBUG_EXPIRE)
+		pr_info("expire_wake_locks: start\n");
+	spin_lock_irqsave(&list_lock, irqflags);
+	if (debug_mask & DEBUG_SUSPEND)
+		print_active_locks(WAKE_LOCK_SUSPEND);
+	has_lock = has_wake_lock_locked(WAKE_LOCK_SUSPEND);
+	if (debug_mask & DEBUG_EXPIRE)
+		pr_info("expire_wake_locks: done, has_lock %ld\n", has_lock);
+	if (has_lock == 0)
+		queue_work(suspend_work_queue, &suspend_work);
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+static DEFINE_TIMER(expire_timer, expire_wake_locks, 0, 0);
+
+static int power_suspend_late(struct device *dev)
+{
+	int ret = has_wake_lock(WAKE_LOCK_SUSPEND) ? -EAGAIN : 0;
+#ifdef CONFIG_WAKELOCK_STAT
+	wait_for_wakeup = 1;
+#endif
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("power_suspend_late return %d\n", ret);
+	return ret;
+}
+
+static struct dev_pm_ops power_driver_pm_ops = {
+	.suspend_noirq = power_suspend_late,
+};
+
+static struct platform_driver power_driver = {
+	.driver.name = "power",
+	.driver.pm = &power_driver_pm_ops,
+};
+static struct platform_device power_device = {
+	.name = "power",
+};
+
+void wake_lock_init(struct wake_lock *lock, int type, const char *name)
+{
+	unsigned long irqflags = 0;
+
+	if (name)
+		lock->name = name;
+	BUG_ON(!lock->name);
+
+	if (debug_mask & DEBUG_WAKE_LOCK)
+		pr_info("wake_lock_init name=%s\n", lock->name);
+#ifdef CONFIG_WAKELOCK_STAT
+	lock->stat.count = 0;
+	lock->stat.expire_count = 0;
+	lock->stat.wakeup_count = 0;
+	lock->stat.total_time = ktime_set(0, 0);
+	lock->stat.prevent_suspend_time = ktime_set(0, 0);
+	lock->stat.max_time = ktime_set(0, 0);
+	lock->stat.last_time = ktime_set(0, 0);
+#endif
+	lock->flags = (type & WAKE_LOCK_TYPE_MASK) | WAKE_LOCK_INITIALIZED;
+
+	INIT_LIST_HEAD(&lock->link);
+	spin_lock_irqsave(&list_lock, irqflags);
+	list_add(&lock->link, &inactive_locks);
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+EXPORT_SYMBOL(wake_lock_init);
+
+void wake_lock_destroy(struct wake_lock *lock)
+{
+	unsigned long irqflags;
+	if (debug_mask & DEBUG_WAKE_LOCK)
+		pr_info("wake_lock_destroy name=%s\n", lock->name);
+	spin_lock_irqsave(&list_lock, irqflags);
+	lock->flags &= ~WAKE_LOCK_INITIALIZED;
+#ifdef CONFIG_WAKELOCK_STAT
+	if (lock->stat.count) {
+		deleted_wake_locks.stat.count += lock->stat.count;
+		deleted_wake_locks.stat.expire_count += lock->stat.expire_count;
+		deleted_wake_locks.stat.total_time =
+			ktime_add(deleted_wake_locks.stat.total_time,
+				  lock->stat.total_time);
+		deleted_wake_locks.stat.prevent_suspend_time =
+			ktime_add(deleted_wake_locks.stat.prevent_suspend_time,
+				  lock->stat.prevent_suspend_time);
+		deleted_wake_locks.stat.max_time =
+			ktime_add(deleted_wake_locks.stat.max_time,
+				  lock->stat.max_time);
+	}
+#endif
+	list_del(&lock->link);
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+EXPORT_SYMBOL(wake_lock_destroy);
+
+static void wake_lock_internal(
+	struct wake_lock *lock, long timeout, int has_timeout)
+{
+	int type;
+	unsigned long irqflags;
+	long expire_in;
+
+	spin_lock_irqsave(&list_lock, irqflags);
+	type = lock->flags & WAKE_LOCK_TYPE_MASK;
+	BUG_ON(type >= WAKE_LOCK_TYPE_COUNT);
+	BUG_ON(!(lock->flags & WAKE_LOCK_INITIALIZED));
+#ifdef CONFIG_WAKELOCK_STAT
+	if (type == WAKE_LOCK_SUSPEND && wait_for_wakeup) {
+		if (debug_mask & DEBUG_WAKEUP)
+			pr_info("wakeup wake lock: %s\n", lock->name);
+		wait_for_wakeup = 0;
+		lock->stat.wakeup_count++;
+	}
+	if ((lock->flags & WAKE_LOCK_AUTO_EXPIRE) &&
+	    (long)(lock->expires - jiffies) <= 0) {
+		wake_unlock_stat_locked(lock, 0);
+		lock->stat.last_time = ktime_get();
+	}
+#endif
+	if (!(lock->flags & WAKE_LOCK_ACTIVE)) {
+		lock->flags |= WAKE_LOCK_ACTIVE;
+#ifdef CONFIG_WAKELOCK_STAT
+		lock->stat.last_time = ktime_get();
+#endif
+	}
+	list_del(&lock->link);
+	if (has_timeout) {
+		if (debug_mask & DEBUG_WAKE_LOCK)
+			pr_info("wake_lock: %s, type %d, timeout %ld.%03lu\n",
+				lock->name, type, timeout / HZ,
+				(timeout % HZ) * MSEC_PER_SEC / HZ);
+		lock->expires = jiffies + timeout;
+		lock->flags |= WAKE_LOCK_AUTO_EXPIRE;
+		list_add_tail(&lock->link, &active_wake_locks[type]);
+	} else {
+		if (debug_mask & DEBUG_WAKE_LOCK)
+			pr_info("wake_lock: %s, type %d\n", lock->name, type);
+		lock->expires = LONG_MAX;
+		lock->flags &= ~WAKE_LOCK_AUTO_EXPIRE;
+		list_add(&lock->link, &active_wake_locks[type]);
+	}
+	if (type == WAKE_LOCK_SUSPEND) {
+		current_event_num++;
+#ifdef CONFIG_WAKELOCK_STAT
+		if (lock == &main_wake_lock)
+			update_sleep_wait_stats_locked(1);
+		else if (!wake_lock_active(&main_wake_lock))
+			update_sleep_wait_stats_locked(0);
+#endif
+		if (has_timeout)
+			expire_in = has_wake_lock_locked(type);
+		else
+			expire_in = -1;
+		if (expire_in > 0) {
+			if (debug_mask & DEBUG_EXPIRE)
+				pr_info("wake_lock: %s, start expire timer, "
+					"%ld\n", lock->name, expire_in);
+			mod_timer(&expire_timer, jiffies + expire_in);
+		} else {
+			if (del_timer(&expire_timer))
+				if (debug_mask & DEBUG_EXPIRE)
+					pr_info("wake_lock: %s, stop expire timer\n",
+						lock->name);
+			if (expire_in == 0)
+				queue_work(suspend_work_queue, &suspend_work);
+		}
+	}
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+
+void wake_lock(struct wake_lock *lock)
+{
+	wake_lock_internal(lock, 0, 0);
+}
+EXPORT_SYMBOL(wake_lock);
+
+void wake_lock_timeout(struct wake_lock *lock, long timeout)
+{
+	wake_lock_internal(lock, timeout, 1);
+}
+EXPORT_SYMBOL(wake_lock_timeout);
+
+void wake_unlock(struct wake_lock *lock)
+{
+	int type;
+	unsigned long irqflags;
+	spin_lock_irqsave(&list_lock, irqflags);
+	type = lock->flags & WAKE_LOCK_TYPE_MASK;
+#ifdef CONFIG_WAKELOCK_STAT
+	wake_unlock_stat_locked(lock, 0);
+#endif
+	if (debug_mask & DEBUG_WAKE_LOCK)
+		pr_info("wake_unlock: %s\n", lock->name);
+	lock->flags &= ~(WAKE_LOCK_ACTIVE | WAKE_LOCK_AUTO_EXPIRE);
+	list_del(&lock->link);
+	list_add(&lock->link, &inactive_locks);
+	if (type == WAKE_LOCK_SUSPEND) {
+		long has_lock = has_wake_lock_locked(type);
+		if (has_lock > 0) {
+			if (debug_mask & DEBUG_EXPIRE)
+				pr_info("wake_unlock: %s, start expire timer, "
+					"%ld\n", lock->name, has_lock);
+			mod_timer(&expire_timer, jiffies + has_lock);
+		} else {
+			if (del_timer(&expire_timer))
+				if (debug_mask & DEBUG_EXPIRE)
+					pr_info("wake_unlock: %s, stop expire "
+						"timer\n", lock->name);
+			if (has_lock == 0)
+				queue_work(suspend_work_queue, &suspend_work);
+		}
+		if (lock == &main_wake_lock) {
+			if (debug_mask & DEBUG_SUSPEND)
+				print_active_locks(WAKE_LOCK_SUSPEND);
+#ifdef CONFIG_WAKELOCK_STAT
+			update_sleep_wait_stats_locked(0);
+#endif
+		}
+	}
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+EXPORT_SYMBOL(wake_unlock);
+
+int wake_lock_active(struct wake_lock *lock)
+{
+	return !!(lock->flags & WAKE_LOCK_ACTIVE);
+}
+EXPORT_SYMBOL(wake_lock_active);
+
+static int wakelock_stats_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, wakelock_stats_show, NULL);
+}
+
+static const struct file_operations wakelock_stats_fops = {
+	.owner = THIS_MODULE,
+	.open = wakelock_stats_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int __init wakelocks_init(void)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(active_wake_locks); i++)
+		INIT_LIST_HEAD(&active_wake_locks[i]);
+
+#ifdef CONFIG_WAKELOCK_STAT
+	wake_lock_init(&deleted_wake_locks, WAKE_LOCK_SUSPEND,
+			"deleted_wake_locks");
+#endif
+	wake_lock_init(&main_wake_lock, WAKE_LOCK_SUSPEND, "main");
+	wake_lock(&main_wake_lock);
+	wake_lock_init(&unknown_wakeup, WAKE_LOCK_SUSPEND, "unknown_wakeups");
+
+	ret = platform_device_register(&power_device);
+	if (ret) {
+		pr_err("wakelocks_init: platform_device_register failed\n");
+		goto err_platform_device_register;
+	}
+	ret = platform_driver_register(&power_driver);
+	if (ret) {
+		pr_err("wakelocks_init: platform_driver_register failed\n");
+		goto err_platform_driver_register;
+	}
+
+	suspend_work_queue = create_singlethread_workqueue("suspend");
+	if (suspend_work_queue == NULL) {
+		ret = -ENOMEM;
+		goto err_suspend_work_queue;
+	}
+
+#ifdef CONFIG_WAKELOCK_STAT
+	proc_create("wakelocks", S_IRUGO, NULL, &wakelock_stats_fops);
+#endif
+
+	return 0;
+
+err_suspend_work_queue:
+	platform_driver_unregister(&power_driver);
+err_platform_driver_register:
+	platform_device_unregister(&power_device);
+err_platform_device_register:
+	wake_lock_destroy(&unknown_wakeup);
+	wake_lock_destroy(&main_wake_lock);
+#ifdef CONFIG_WAKELOCK_STAT
+	wake_lock_destroy(&deleted_wake_locks);
+#endif
+	return ret;
+}
+
+static void  __exit wakelocks_exit(void)
+{
+#ifdef CONFIG_WAKELOCK_STAT
+	remove_proc_entry("wakelocks", NULL);
+#endif
+	destroy_workqueue(suspend_work_queue);
+	platform_driver_unregister(&power_driver);
+	platform_device_unregister(&power_device);
+	wake_lock_destroy(&unknown_wakeup);
+	wake_lock_destroy(&main_wake_lock);
+#ifdef CONFIG_WAKELOCK_STAT
+	wake_lock_destroy(&deleted_wake_locks);
+#endif
+}
+
+core_initcall(wakelocks_init);
+module_exit(wakelocks_exit);
diff -Nur linux-2.6.32-orig/kernel/printk.c iDroid-Project-kernel_common-9e90fd2/kernel/printk.c
--- linux-2.6.32-orig/kernel/printk.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/printk.c	2010-11-18 21:05:30.000000000 +0600
@@ -51,6 +51,10 @@
 
 #define __LOG_BUF_LEN	(1 << CONFIG_LOG_BUF_SHIFT)
 
+#ifdef        CONFIG_DEBUG_LL
+extern void printascii(char *);
+#endif
+
 /* printk's without a loglevel use this.. */
 #define DEFAULT_MESSAGE_LOGLEVEL 4 /* KERN_WARNING */
 
@@ -257,6 +261,53 @@
 #endif
 
 /*
+ * Return the number of unread characters in the log buffer.
+ */
+static int log_buf_get_len(void)
+{
+	return logged_chars;
+}
+
+/*
+ * Clears the ring-buffer
+ */
+void log_buf_clear(void)
+{
+	logged_chars = 0;
+}
+
+/*
+ * Copy a range of characters from the log buffer.
+ */
+int log_buf_copy(char *dest, int idx, int len)
+{
+	int ret, max;
+	bool took_lock = false;
+
+	if (!oops_in_progress) {
+		spin_lock_irq(&logbuf_lock);
+		took_lock = true;
+	}
+
+	max = log_buf_get_len();
+	if (idx < 0 || idx >= max) {
+		ret = -1;
+	} else {
+		if (len > max - idx)
+			len = max - idx;
+		ret = len;
+		idx += (log_end - max);
+		while (len-- > 0)
+			dest[len] = LOG_BUF(idx + len);
+	}
+
+	if (took_lock)
+		spin_unlock_irq(&logbuf_lock);
+
+	return ret;
+}
+
+/*
  * Commands to do_syslog:
  *
  * 	0 -- Close the log.  Currently a NOP.
@@ -714,6 +765,9 @@
 	printed_len += vscnprintf(printk_buf + printed_len,
 				  sizeof(printk_buf) - printed_len, fmt, args);
 
+#ifdef	CONFIG_DEBUG_LL
+	printascii(printk_buf);
+#endif
 
 	p = printk_buf;
 
diff -Nur linux-2.6.32-orig/kernel/rcutree.c iDroid-Project-kernel_common-9e90fd2/kernel/rcutree.c
--- linux-2.6.32-orig/kernel/rcutree.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/rcutree.c	2010-11-18 21:05:30.000000000 +0600
@@ -176,9 +176,29 @@
 	return &rsp->node[0];
 }
 
+/*
+ * Record the specified "completed" value, which is later used to validate
+ * dynticks counter manipulations and CPU-offline checks.  Specify
+ * "rsp->completed - 1" to unconditionally invalidate any future dynticks
+ * manipulations and CPU-offline checks.  Such invalidation is useful at
+ * the beginning of a grace period.
+ */
+static void dyntick_record_completed(struct rcu_state *rsp, long comp)
+{
+	rsp->dynticks_completed = comp;
+}
+
 #ifdef CONFIG_SMP
 
 /*
+ * Recall the previously recorded value of the completion for dynticks.
+ */
+static long dyntick_recall_completed(struct rcu_state *rsp)
+{
+	return rsp->dynticks_completed;
+}
+
+/*
  * If the specified CPU is offline, tell the caller that it is in
  * a quiescent state.  Otherwise, whack it with a reschedule IPI.
  * Grace periods can end up waiting on an offline CPU when that
@@ -335,28 +355,9 @@
 		set_need_resched();
 }
 
-/*
- * Record the specified "completed" value, which is later used to validate
- * dynticks counter manipulations.  Specify "rsp->completed - 1" to
- * unconditionally invalidate any future dynticks manipulations (which is
- * useful at the beginning of a grace period).
- */
-static void dyntick_record_completed(struct rcu_state *rsp, long comp)
-{
-	rsp->dynticks_completed = comp;
-}
-
 #ifdef CONFIG_SMP
 
 /*
- * Recall the previously recorded value of the completion for dynticks.
- */
-static long dyntick_recall_completed(struct rcu_state *rsp)
-{
-	return rsp->dynticks_completed;
-}
-
-/*
  * Snapshot the specified CPU's dynticks counter so that we can later
  * credit them with an implicit quiescent state.  Return 1 if this CPU
  * is in dynticks idle mode, which is an extended quiescent state.
@@ -419,24 +420,8 @@
 
 #else /* #ifdef CONFIG_NO_HZ */
 
-static void dyntick_record_completed(struct rcu_state *rsp, long comp)
-{
-}
-
 #ifdef CONFIG_SMP
 
-/*
- * If there are no dynticks, then the only way that a CPU can passively
- * be in a quiescent state is to be offline.  Unlike dynticks idle, which
- * is a point in time during the prior (already finished) grace period,
- * an offline CPU is always in a quiescent state, and thus can be
- * unconditionally applied.  So just return the current value of completed.
- */
-static long dyntick_recall_completed(struct rcu_state *rsp)
-{
-	return rsp->completed;
-}
-
 static int dyntick_save_progress_counter(struct rcu_data *rdp)
 {
 	return 0;
@@ -553,13 +538,33 @@
 /*
  * Update CPU-local rcu_data state to record the newly noticed grace period.
  * This is used both when we started the grace period and when we notice
- * that someone else started the grace period.
- */
+ * that someone else started the grace period.  The caller must hold the
+ * ->lock of the leaf rcu_node structure corresponding to the current CPU,
+ *  and must have irqs disabled.
+ */
+static void __note_new_gpnum(struct rcu_state *rsp, struct rcu_node *rnp, struct rcu_data *rdp)
+{
+	if (rdp->gpnum != rnp->gpnum) {
+		rdp->qs_pending = 1;
+		rdp->passed_quiesc = 0;
+		rdp->gpnum = rnp->gpnum;
+	}
+}
+
 static void note_new_gpnum(struct rcu_state *rsp, struct rcu_data *rdp)
 {
-	rdp->qs_pending = 1;
-	rdp->passed_quiesc = 0;
-	rdp->gpnum = rsp->gpnum;
+	unsigned long flags;
+	struct rcu_node *rnp;
+
+	local_irq_save(flags);
+	rnp = rdp->mynode;
+	if (rdp->gpnum == ACCESS_ONCE(rnp->gpnum) || /* outside lock. */
+	    !spin_trylock(&rnp->lock)) { /* irqs already off, retry later. */
+		local_irq_restore(flags);
+		return;
+	}
+	__note_new_gpnum(rsp, rnp, rdp);
+	spin_unlock_irqrestore(&rnp->lock, flags);
 }
 
 /*
@@ -583,6 +588,79 @@
 }
 
 /*
+ * Advance this CPU's callbacks, but only if the current grace period
+ * has ended.  This may be called only from the CPU to whom the rdp
+ * belongs.  In addition, the corresponding leaf rcu_node structure's
+ * ->lock must be held by the caller, with irqs disabled.
+ */
+static void
+__rcu_process_gp_end(struct rcu_state *rsp, struct rcu_node *rnp, struct rcu_data *rdp)
+{
+	/* Did another grace period end? */
+	if (rdp->completed != rnp->completed) {
+
+		/* Advance callbacks.  No harm if list empty. */
+		rdp->nxttail[RCU_DONE_TAIL] = rdp->nxttail[RCU_WAIT_TAIL];
+		rdp->nxttail[RCU_WAIT_TAIL] = rdp->nxttail[RCU_NEXT_READY_TAIL];
+		rdp->nxttail[RCU_NEXT_READY_TAIL] = rdp->nxttail[RCU_NEXT_TAIL];
+
+		/* Remember that we saw this grace-period completion. */
+		rdp->completed = rnp->completed;
+	}
+}
+
+/*
+ * Advance this CPU's callbacks, but only if the current grace period
+ * has ended.  This may be called only from the CPU to whom the rdp
+ * belongs.
+ */
+static void
+rcu_process_gp_end(struct rcu_state *rsp, struct rcu_data *rdp)
+{
+	unsigned long flags;
+	struct rcu_node *rnp;
+
+	local_irq_save(flags);
+	rnp = rdp->mynode;
+	if (rdp->completed == ACCESS_ONCE(rnp->completed) || /* outside lock. */
+	    !spin_trylock(&rnp->lock)) { /* irqs already off, retry later. */
+		local_irq_restore(flags);
+		return;
+	}
+	__rcu_process_gp_end(rsp, rnp, rdp);
+	spin_unlock_irqrestore(&rnp->lock, flags);
+}
+
+/*
+ * Do per-CPU grace-period initialization for running CPU.  The caller
+ * must hold the lock of the leaf rcu_node structure corresponding to
+ * this CPU.
+ */
+static void
+rcu_start_gp_per_cpu(struct rcu_state *rsp, struct rcu_node *rnp, struct rcu_data *rdp)
+{
+	/* Prior grace period ended, so advance callbacks for current CPU. */
+	__rcu_process_gp_end(rsp, rnp, rdp);
+
+	/*
+	 * Because this CPU just now started the new grace period, we know
+	 * that all of its callbacks will be covered by this upcoming grace
+	 * period, even the ones that were registered arbitrarily recently.
+	 * Therefore, advance all outstanding callbacks to RCU_WAIT_TAIL.
+	 *
+	 * Other CPUs cannot be sure exactly when the grace period started.
+	 * Therefore, their recently registered callbacks must pass through
+	 * an additional RCU_NEXT_READY stage, so that they will be handled
+	 * by the next RCU grace period.
+	 */
+	rdp->nxttail[RCU_NEXT_READY_TAIL] = rdp->nxttail[RCU_NEXT_TAIL];
+	rdp->nxttail[RCU_WAIT_TAIL] = rdp->nxttail[RCU_NEXT_TAIL];
+
+	/* Set state so that this CPU will detect the next quiescent state. */
+	__note_new_gpnum(rsp, rnp, rdp);
+}
+
+/*
  * Start a new RCU grace period if warranted, re-initializing the hierarchy
  * in preparation for detecting the next grace period.  The caller must hold
  * the root node's ->lock, which is released before return.  Hard irqs must
@@ -607,28 +685,15 @@
 	rsp->jiffies_force_qs = jiffies + RCU_JIFFIES_TILL_FORCE_QS;
 	record_gp_stall_check_time(rsp);
 	dyntick_record_completed(rsp, rsp->completed - 1);
-	note_new_gpnum(rsp, rdp);
-
-	/*
-	 * Because this CPU just now started the new grace period, we know
-	 * that all of its callbacks will be covered by this upcoming grace
-	 * period, even the ones that were registered arbitrarily recently.
-	 * Therefore, advance all outstanding callbacks to RCU_WAIT_TAIL.
-	 *
-	 * Other CPUs cannot be sure exactly when the grace period started.
-	 * Therefore, their recently registered callbacks must pass through
-	 * an additional RCU_NEXT_READY stage, so that they will be handled
-	 * by the next RCU grace period.
-	 */
-	rdp->nxttail[RCU_NEXT_READY_TAIL] = rdp->nxttail[RCU_NEXT_TAIL];
-	rdp->nxttail[RCU_WAIT_TAIL] = rdp->nxttail[RCU_NEXT_TAIL];
 
 	/* Special-case the common single-level case. */
 	if (NUM_RCU_NODES == 1) {
 		rcu_preempt_check_blocked_tasks(rnp);
 		rnp->qsmask = rnp->qsmaskinit;
 		rnp->gpnum = rsp->gpnum;
+		rnp->completed = rsp->completed;
 		rsp->signaled = RCU_SIGNAL_INIT; /* force_quiescent_state OK. */
+		rcu_start_gp_per_cpu(rsp, rnp, rdp);
 		spin_unlock_irqrestore(&rnp->lock, flags);
 		return;
 	}
@@ -661,6 +726,9 @@
 		rcu_preempt_check_blocked_tasks(rnp);
 		rnp->qsmask = rnp->qsmaskinit;
 		rnp->gpnum = rsp->gpnum;
+		rnp->completed = rsp->completed;
+		if (rnp == rdp->mynode)
+			rcu_start_gp_per_cpu(rsp, rnp, rdp);
 		spin_unlock(&rnp->lock);	/* irqs remain disabled. */
 	}
 
@@ -672,34 +740,6 @@
 }
 
 /*
- * Advance this CPU's callbacks, but only if the current grace period
- * has ended.  This may be called only from the CPU to whom the rdp
- * belongs.
- */
-static void
-rcu_process_gp_end(struct rcu_state *rsp, struct rcu_data *rdp)
-{
-	long completed_snap;
-	unsigned long flags;
-
-	local_irq_save(flags);
-	completed_snap = ACCESS_ONCE(rsp->completed);  /* outside of lock. */
-
-	/* Did another grace period end? */
-	if (rdp->completed != completed_snap) {
-
-		/* Advance callbacks.  No harm if list empty. */
-		rdp->nxttail[RCU_DONE_TAIL] = rdp->nxttail[RCU_WAIT_TAIL];
-		rdp->nxttail[RCU_WAIT_TAIL] = rdp->nxttail[RCU_NEXT_READY_TAIL];
-		rdp->nxttail[RCU_NEXT_READY_TAIL] = rdp->nxttail[RCU_NEXT_TAIL];
-
-		/* Remember that we saw this grace-period completion. */
-		rdp->completed = completed_snap;
-	}
-	local_irq_restore(flags);
-}
-
-/*
  * Clean up after the prior grace period and let rcu_start_gp() start up
  * the next grace period if one is needed.  Note that the caller must
  * hold rnp->lock, as required by rcu_start_gp(), which will release it.
@@ -710,7 +750,6 @@
 	WARN_ON_ONCE(!rcu_gp_in_progress(rsp));
 	rsp->completed = rsp->gpnum;
 	rsp->signaled = RCU_GP_IDLE;
-	rcu_process_gp_end(rsp, rsp->rda[smp_processor_id()]);
 	rcu_start_gp(rsp, flags);  /* releases root node's rnp->lock. */
 }
 
@@ -1144,6 +1183,7 @@
 	long lastcomp;
 	struct rcu_node *rnp = rcu_get_root(rsp);
 	u8 signaled;
+	u8 forcenow;
 
 	if (!rcu_gp_in_progress(rsp))
 		return;  /* No grace period in progress, nothing to force. */
@@ -1180,16 +1220,23 @@
 		if (rcu_process_dyntick(rsp, lastcomp,
 					dyntick_save_progress_counter))
 			goto unlock_ret;
+		/* fall into next case. */
+
+	case RCU_SAVE_COMPLETED:
 
 		/* Update state, record completion counter. */
+		forcenow = 0;
 		spin_lock(&rnp->lock);
 		if (lastcomp == rsp->completed &&
-		    rsp->signaled == RCU_SAVE_DYNTICK) {
+		    rsp->signaled == signaled) {
 			rsp->signaled = RCU_FORCE_QS;
 			dyntick_record_completed(rsp, lastcomp);
+			forcenow = signaled == RCU_SAVE_COMPLETED;
 		}
 		spin_unlock(&rnp->lock);
-		break;
+		if (!forcenow)
+			break;
+		/* fall into next case. */
 
 	case RCU_FORCE_QS:
 
@@ -1544,21 +1591,16 @@
 rcu_init_percpu_data(int cpu, struct rcu_state *rsp, int preemptable)
 {
 	unsigned long flags;
-	long lastcomp;
 	unsigned long mask;
 	struct rcu_data *rdp = rsp->rda[cpu];
 	struct rcu_node *rnp = rcu_get_root(rsp);
 
 	/* Set up local state, ensuring consistent view of global state. */
 	spin_lock_irqsave(&rnp->lock, flags);
-	lastcomp = rsp->completed;
-	rdp->completed = lastcomp;
-	rdp->gpnum = lastcomp;
 	rdp->passed_quiesc = 0;  /* We could be racing with new GP, */
 	rdp->qs_pending = 1;	 /*  so set up to respond to current GP. */
 	rdp->beenonline = 1;	 /* We have now been online. */
 	rdp->preemptable = preemptable;
-	rdp->passed_quiesc_completed = lastcomp - 1;
 	rdp->qlen_last_fqs_check = 0;
 	rdp->n_force_qs_snap = rsp->n_force_qs;
 	rdp->blimit = blimit;
@@ -1580,6 +1622,11 @@
 		spin_lock(&rnp->lock);	/* irqs already disabled. */
 		rnp->qsmaskinit |= mask;
 		mask = rnp->grpmask;
+		if (rnp == rdp->mynode) {
+			rdp->gpnum = rnp->completed; /* if GP in progress... */
+			rdp->completed = rnp->completed;
+			rdp->passed_quiesc_completed = rnp->completed - 1;
+		}
 		spin_unlock(&rnp->lock); /* irqs already disabled. */
 		rnp = rnp->parent;
 	} while (rnp != NULL && !(rnp->qsmaskinit & mask));
diff -Nur linux-2.6.32-orig/kernel/rcutree.h iDroid-Project-kernel_common-9e90fd2/kernel/rcutree.h
--- linux-2.6.32-orig/kernel/rcutree.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/rcutree.h	2010-11-18 21:05:30.000000000 +0600
@@ -84,6 +84,9 @@
 	long	gpnum;		/* Current grace period for this node. */
 				/*  This will either be equal to or one */
 				/*  behind the root rcu_node's gpnum. */
+	long	completed;	/* Last grace period completed for this node. */
+				/*  This will either be equal to or one */
+				/*  behind the root rcu_node's gpnum. */
 	unsigned long qsmask;	/* CPUs or groups that need to switch in */
 				/*  order for current grace period to proceed.*/
 				/*  In leaf rcu_node, each bit corresponds to */
@@ -204,11 +207,12 @@
 #define RCU_GP_IDLE		0	/* No grace period in progress. */
 #define RCU_GP_INIT		1	/* Grace period being initialized. */
 #define RCU_SAVE_DYNTICK	2	/* Need to scan dyntick state. */
-#define RCU_FORCE_QS		3	/* Need to force quiescent state. */
+#define RCU_SAVE_COMPLETED	3	/* Need to save rsp->completed. */
+#define RCU_FORCE_QS		4	/* Need to force quiescent state. */
 #ifdef CONFIG_NO_HZ
 #define RCU_SIGNAL_INIT		RCU_SAVE_DYNTICK
 #else /* #ifdef CONFIG_NO_HZ */
-#define RCU_SIGNAL_INIT		RCU_FORCE_QS
+#define RCU_SIGNAL_INIT		RCU_SAVE_COMPLETED
 #endif /* #else #ifdef CONFIG_NO_HZ */
 
 #define RCU_JIFFIES_TILL_FORCE_QS	 3	/* for rsp->jiffies_force_qs */
@@ -274,9 +278,8 @@
 	unsigned long jiffies_stall;		/* Time at which to check */
 						/*  for CPU stalls. */
 #endif /* #ifdef CONFIG_RCU_CPU_STALL_DETECTOR */
-#ifdef CONFIG_NO_HZ
 	long dynticks_completed;		/* Value of completed @ snap. */
-#endif /* #ifdef CONFIG_NO_HZ */
+						/*  Protected by fqslock. */
 };
 
 #ifdef RCU_TREE_NONCORE
@@ -298,7 +301,7 @@
 #else /* #ifdef RCU_TREE_NONCORE */
 
 /* Forward declarations for rcutree_plugin.h */
-static inline void rcu_bootup_announce(void);
+static void rcu_bootup_announce(void);
 long rcu_batches_completed(void);
 static void rcu_preempt_note_context_switch(int cpu);
 static int rcu_preempted_readers(struct rcu_node *rnp);
diff -Nur linux-2.6.32-orig/kernel/rcutree_plugin.h iDroid-Project-kernel_common-9e90fd2/kernel/rcutree_plugin.h
--- linux-2.6.32-orig/kernel/rcutree_plugin.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/rcutree_plugin.h	2010-11-18 21:05:30.000000000 +0600
@@ -33,7 +33,7 @@
 /*
  * Tell them what RCU they are running.
  */
-static inline void rcu_bootup_announce(void)
+static void rcu_bootup_announce(void)
 {
 	printk(KERN_INFO
 	       "Experimental preemptable hierarchical RCU implementation.\n");
@@ -481,7 +481,7 @@
 /*
  * Tell them what RCU they are running.
  */
-static inline void rcu_bootup_announce(void)
+static void rcu_bootup_announce(void)
 {
 	printk(KERN_INFO "Hierarchical RCU implementation.\n");
 }
diff -Nur linux-2.6.32-orig/kernel/sched.c iDroid-Project-kernel_common-9e90fd2/kernel/sched.c
--- linux-2.6.32-orig/kernel/sched.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/sched.c	2010-11-18 21:05:30.000000000 +0600
@@ -591,6 +591,8 @@
 
 	u64 rt_avg;
 	u64 age_stamp;
+	u64 idle_stamp;
+	u64 avg_idle;
 #endif
 
 	/* calc_load related fields */
@@ -814,6 +816,7 @@
  * default: 0.25ms
  */
 unsigned int sysctl_sched_shares_ratelimit = 250000;
+unsigned int normalized_sysctl_sched_shares_ratelimit = 250000;
 
 /*
  * Inject some fuzzyness into changing the per-cpu group shares
@@ -1810,6 +1813,7 @@
 #endif
 
 static void calc_load_account_active(struct rq *this_rq);
+static void update_sysctl(void);
 
 #include "sched_stats.h"
 #include "sched_idletask.c"
@@ -2034,6 +2038,9 @@
 {
 	s64 delta;
 
+	if (p->sched_class != &fair_sched_class)
+		return 0;
+
 	/*
 	 * Buddy candidates are cache hot:
 	 */
@@ -2042,9 +2049,6 @@
 			 &p->se == cfs_rq_of(&p->se)->last))
 		return 1;
 
-	if (p->sched_class != &fair_sched_class)
-		return 0;
-
 	if (sysctl_sched_migration_cost == -1)
 		return 1;
 	if (sysctl_sched_migration_cost == 0)
@@ -2440,6 +2444,17 @@
 #ifdef CONFIG_SMP
 	if (p->sched_class->task_wake_up)
 		p->sched_class->task_wake_up(rq, p);
+
+	if (unlikely(rq->idle_stamp)) {
+		u64 delta = rq->clock - rq->idle_stamp;
+		u64 max = 2*sysctl_sched_migration_cost;
+
+		if (delta > max)
+			rq->avg_idle = max;
+		else
+			update_avg(&rq->avg_idle, delta);
+		rq->idle_stamp = 0;
+	}
 #endif
 out:
 	task_rq_unlock(rq, &flags);
@@ -3164,10 +3179,6 @@
 	deactivate_task(src_rq, p, 0);
 	set_task_cpu(p, this_cpu);
 	activate_task(this_rq, p, 0);
-	/*
-	 * Note that idle threads have a prio of MAX_PRIO, for this test
-	 * to be always true for them.
-	 */
 	check_preempt_curr(this_rq, p, 0);
 }
 
@@ -4126,7 +4137,7 @@
 	unsigned long flags;
 	struct cpumask *cpus = __get_cpu_var(load_balance_tmpmask);
 
-	cpumask_setall(cpus);
+	cpumask_copy(cpus, cpu_active_mask);
 
 	/*
 	 * When power savings policy is enabled for the parent domain, idle
@@ -4289,7 +4300,7 @@
 	int all_pinned = 0;
 	struct cpumask *cpus = __get_cpu_var(load_balance_tmpmask);
 
-	cpumask_setall(cpus);
+	cpumask_copy(cpus, cpu_active_mask);
 
 	/*
 	 * When power savings policy is enabled for the parent domain, idle
@@ -4429,6 +4440,11 @@
 	int pulled_task = 0;
 	unsigned long next_balance = jiffies + HZ;
 
+	this_rq->idle_stamp = this_rq->clock;
+
+	if (this_rq->avg_idle < sysctl_sched_migration_cost)
+		return;
+
 	for_each_domain(this_cpu, sd) {
 		unsigned long interval;
 
@@ -4443,8 +4459,10 @@
 		interval = msecs_to_jiffies(sd->balance_interval);
 		if (time_after(next_balance, sd->last_balance + interval))
 			next_balance = sd->last_balance + interval;
-		if (pulled_task)
+		if (pulled_task) {
+			this_rq->idle_stamp = 0;
 			break;
+		}
 	}
 	if (pulled_task || time_after(jiffies, this_rq->next_balance)) {
 		/*
@@ -4679,7 +4697,7 @@
 		cpumask_set_cpu(cpu, nohz.cpu_mask);
 
 		/* time for ilb owner also to sleep */
-		if (cpumask_weight(nohz.cpu_mask) == num_online_cpus()) {
+		if (cpumask_weight(nohz.cpu_mask) == num_active_cpus()) {
 			if (atomic_read(&nohz.load_balancer) == cpu)
 				atomic_set(&nohz.load_balancer, -1);
 			return 0;
@@ -6881,7 +6899,7 @@
 	unsigned state;
 
 	state = p->state ? __ffs(p->state) + 1 : 0;
-	printk(KERN_INFO "%-13.13s %c", p->comm,
+	printk(KERN_INFO "%-15.15s %c", p->comm,
 		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?');
 #if BITS_PER_LONG == 32
 	if (state == TASK_RUNNING)
@@ -6962,7 +6980,6 @@
 	__sched_fork(idle);
 	idle->se.exec_start = sched_clock();
 
-	idle->prio = idle->normal_prio = MAX_PRIO;
 	cpumask_copy(&idle->cpus_allowed, cpumask_of(cpu));
 	__set_task_cpu(idle, cpu);
 
@@ -7003,22 +7020,23 @@
  *
  * This idea comes from the SD scheduler of Con Kolivas:
  */
-static inline void sched_init_granularity(void)
+static void update_sysctl(void)
 {
-	unsigned int factor = 1 + ilog2(num_online_cpus());
-	const unsigned long limit = 200000000;
-
-	sysctl_sched_min_granularity *= factor;
-	if (sysctl_sched_min_granularity > limit)
-		sysctl_sched_min_granularity = limit;
-
-	sysctl_sched_latency *= factor;
-	if (sysctl_sched_latency > limit)
-		sysctl_sched_latency = limit;
+	unsigned int cpus = min_t(int, num_online_cpus(), 8U);
+	unsigned int factor = 1 + ilog2(cpus);
 
-	sysctl_sched_wakeup_granularity *= factor;
+#define SET_SYSCTL(name) \
+	(sysctl_##name = (factor) * normalized_sysctl_##name)
+	SET_SYSCTL(sched_min_granularity);
+	SET_SYSCTL(sched_latency);
+	SET_SYSCTL(sched_wakeup_granularity);
+	SET_SYSCTL(sched_shares_ratelimit);
+#undef SET_SYSCTL
+}
 
-	sysctl_sched_shares_ratelimit *= factor;
+static inline void sched_init_granularity(void)
+{
+	update_sysctl();
 }
 
 #ifdef CONFIG_SMP
@@ -7055,7 +7073,7 @@
 	int ret = 0;
 
 	rq = task_rq_lock(p, &flags);
-	if (!cpumask_intersects(new_mask, cpu_online_mask)) {
+	if (!cpumask_intersects(new_mask, cpu_active_mask)) {
 		ret = -EINVAL;
 		goto out;
 	}
@@ -7077,7 +7095,7 @@
 	if (cpumask_test_cpu(task_cpu(p), new_mask))
 		goto out;
 
-	if (migrate_task(p, cpumask_any_and(cpu_online_mask, new_mask), &req)) {
+	if (migrate_task(p, cpumask_any_and(cpu_active_mask, new_mask), &req)) {
 		/* Need help from migration thread: drop lock and wait. */
 		struct task_struct *mt = rq->migration_thread;
 
@@ -7231,19 +7249,19 @@
 
 again:
 	/* Look for allowed, online CPU in same node. */
-	for_each_cpu_and(dest_cpu, nodemask, cpu_online_mask)
+	for_each_cpu_and(dest_cpu, nodemask, cpu_active_mask)
 		if (cpumask_test_cpu(dest_cpu, &p->cpus_allowed))
 			goto move;
 
 	/* Any allowed, online CPU? */
-	dest_cpu = cpumask_any_and(&p->cpus_allowed, cpu_online_mask);
+	dest_cpu = cpumask_any_and(&p->cpus_allowed, cpu_active_mask);
 	if (dest_cpu < nr_cpu_ids)
 		goto move;
 
 	/* No more Mr. Nice Guy. */
 	if (dest_cpu >= nr_cpu_ids) {
 		cpuset_cpus_allowed_locked(p, &p->cpus_allowed);
-		dest_cpu = cpumask_any_and(cpu_online_mask, &p->cpus_allowed);
+		dest_cpu = cpumask_any_and(cpu_active_mask, &p->cpus_allowed);
 
 		/*
 		 * Don't tell them about moving exiting tasks or
@@ -7272,7 +7290,7 @@
  */
 static void migrate_nr_uninterruptible(struct rq *rq_src)
 {
-	struct rq *rq_dest = cpu_rq(cpumask_any(cpu_online_mask));
+	struct rq *rq_dest = cpu_rq(cpumask_any(cpu_active_mask));
 	unsigned long flags;
 
 	local_irq_save(flags);
@@ -7526,7 +7544,7 @@
 static struct ctl_table_header *sd_sysctl_header;
 static void register_sched_domain_sysctl(void)
 {
-	int i, cpu_num = num_online_cpus();
+	int i, cpu_num = num_possible_cpus();
 	struct ctl_table *entry = sd_alloc_ctl_entry(cpu_num + 1);
 	char buf[32];
 
@@ -7536,7 +7554,7 @@
 	if (entry == NULL)
 		return;
 
-	for_each_online_cpu(i) {
+	for_each_possible_cpu(i) {
 		snprintf(buf, 32, "cpu%d", i);
 		entry->procname = kstrdup(buf, GFP_KERNEL);
 		entry->mode = 0555;
@@ -7666,7 +7684,6 @@
 		spin_lock_irq(&rq->lock);
 		update_rq_clock(rq);
 		deactivate_task(rq, rq->idle, 0);
-		rq->idle->static_prio = MAX_PRIO;
 		__setscheduler(rq, rq->idle, SCHED_NORMAL, 0);
 		rq->idle->sched_class = &idle_sched_class;
 		migrate_dead_tasks(cpu);
@@ -7905,6 +7922,8 @@
 
 static void free_rootdomain(struct root_domain *rd)
 {
+	synchronize_sched();
+
 	cpupri_cleanup(&rd->cpupri);
 
 	free_cpumask_var(rd->rto_mask);
@@ -8045,6 +8064,7 @@
 /* Setup the mask of cpus configured for isolated domains */
 static int __init isolated_cpu_setup(char *str)
 {
+	alloc_bootmem_cpumask_var(&cpu_isolated_map);
 	cpulist_parse(str, cpu_isolated_map);
 	return 1;
 }
@@ -9022,7 +9042,7 @@
 	if (doms_new == NULL) {
 		ndoms_cur = 0;
 		doms_new = fallback_doms;
-		cpumask_andnot(&doms_new[0], cpu_online_mask, cpu_isolated_map);
+		cpumask_andnot(&doms_new[0], cpu_active_mask, cpu_isolated_map);
 		WARN_ON_ONCE(dattr_new);
 	}
 
@@ -9153,8 +9173,10 @@
 	switch (action) {
 	case CPU_ONLINE:
 	case CPU_ONLINE_FROZEN:
-	case CPU_DEAD:
-	case CPU_DEAD_FROZEN:
+	case CPU_DOWN_PREPARE:
+	case CPU_DOWN_PREPARE_FROZEN:
+	case CPU_DOWN_FAILED:
+	case CPU_DOWN_FAILED_FROZEN:
 		partition_sched_domains(1, NULL, NULL);
 		return NOTIFY_OK;
 
@@ -9201,7 +9223,7 @@
 #endif
 	get_online_cpus();
 	mutex_lock(&sched_domains_mutex);
-	arch_init_sched_domains(cpu_online_mask);
+	arch_init_sched_domains(cpu_active_mask);
 	cpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map);
 	if (cpumask_empty(non_isolated_cpus))
 		cpumask_set_cpu(smp_processor_id(), non_isolated_cpus);
@@ -9522,6 +9544,8 @@
 		rq->cpu = i;
 		rq->online = 0;
 		rq->migration_thread = NULL;
+		rq->idle_stamp = 0;
+		rq->avg_idle = 2*sysctl_sched_migration_cost;
 		INIT_LIST_HEAD(&rq->migration_queue);
 		rq_attach_root(rq, &def_root_domain);
 #endif
@@ -9571,7 +9595,9 @@
 	zalloc_cpumask_var(&nohz.cpu_mask, GFP_NOWAIT);
 	alloc_cpumask_var(&nohz.ilb_grp_nohz_mask, GFP_NOWAIT);
 #endif
-	zalloc_cpumask_var(&cpu_isolated_map, GFP_NOWAIT);
+	/* May be allocated at isolcpus cmdline parse time */
+	if (cpu_isolated_map == NULL)
+		zalloc_cpumask_var(&cpu_isolated_map, GFP_NOWAIT);
 #endif /* SMP */
 
 	perf_event_init();
@@ -9587,13 +9613,24 @@
 	return (nested == PREEMPT_INATOMIC_BASE + preempt_offset);
 }
 
+static int __might_sleep_init_called;
+int __init __might_sleep_init(void)
+{
+	__might_sleep_init_called = 1;
+	return 0;
+}
+early_initcall(__might_sleep_init);
+
 void __might_sleep(char *file, int line, int preempt_offset)
 {
 #ifdef in_atomic
 	static unsigned long prev_jiffy;	/* ratelimiting */
 
 	if ((preempt_count_equals(preempt_offset) && !irqs_disabled()) ||
-	    system_state != SYSTEM_RUNNING || oops_in_progress)
+	    oops_in_progress)
+		return;
+	if (system_state != SYSTEM_RUNNING &&
+	    (!__might_sleep_init_called || system_state != SYSTEM_BOOTING))
 		return;
 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)
 		return;
@@ -10413,6 +10450,15 @@
 static int
 cpu_cgroup_can_attach_task(struct cgroup *cgrp, struct task_struct *tsk)
 {
+	if ((current != tsk) && (!capable(CAP_SYS_NICE))) {
+		const struct cred *cred = current_cred(), *tcred;
+
+		tcred = __task_cred(tsk);
+
+		if (cred->euid != tcred->uid && cred->euid != tcred->suid)
+			return -EPERM;
+	}
+
 #ifdef CONFIG_RT_GROUP_SCHED
 	if (!sched_rt_can_attach(cgroup_tg(cgrp), tsk))
 		return -EINVAL;
diff -Nur linux-2.6.32-orig/kernel/sched_clock.c iDroid-Project-kernel_common-9e90fd2/kernel/sched_clock.c
--- linux-2.6.32-orig/kernel/sched_clock.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/sched_clock.c	2010-11-18 21:05:30.000000000 +0600
@@ -236,6 +236,18 @@
 }
 EXPORT_SYMBOL_GPL(sched_clock_idle_wakeup_event);
 
+unsigned long long cpu_clock(int cpu)
+{
+	unsigned long long clock;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	clock = sched_clock_cpu(cpu);
+	local_irq_restore(flags);
+
+	return clock;
+}
+
 #else /* CONFIG_HAVE_UNSTABLE_SCHED_CLOCK */
 
 void sched_clock_init(void)
@@ -251,17 +263,12 @@
 	return sched_clock();
 }
 
-#endif /* CONFIG_HAVE_UNSTABLE_SCHED_CLOCK */
 
 unsigned long long cpu_clock(int cpu)
 {
-	unsigned long long clock;
-	unsigned long flags;
+	return sched_clock_cpu(cpu);
+}
 
-	local_irq_save(flags);
-	clock = sched_clock_cpu(cpu);
-	local_irq_restore(flags);
+#endif /* CONFIG_HAVE_UNSTABLE_SCHED_CLOCK */
 
-	return clock;
-}
 EXPORT_SYMBOL_GPL(cpu_clock);
diff -Nur linux-2.6.32-orig/kernel/sched_debug.c iDroid-Project-kernel_common-9e90fd2/kernel/sched_debug.c
--- linux-2.6.32-orig/kernel/sched_debug.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/sched_debug.c	2010-11-18 21:05:30.000000000 +0600
@@ -285,12 +285,16 @@
 
 #ifdef CONFIG_SCHEDSTATS
 #define P(n) SEQ_printf(m, "  .%-30s: %d\n", #n, rq->n);
+#define P64(n) SEQ_printf(m, "  .%-30s: %Ld\n", #n, rq->n);
 
 	P(yld_count);
 
 	P(sched_switch);
 	P(sched_count);
 	P(sched_goidle);
+#ifdef CONFIG_SMP
+	P64(avg_idle);
+#endif
 
 	P(ttwu_count);
 	P(ttwu_local);
diff -Nur linux-2.6.32-orig/kernel/sched_fair.c iDroid-Project-kernel_common-9e90fd2/kernel/sched_fair.c
--- linux-2.6.32-orig/kernel/sched_fair.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/sched_fair.c	2010-11-18 21:05:30.000000000 +0600
@@ -35,12 +35,14 @@
  *  run vmstat and monitor the context-switches (cs) field)
  */
 unsigned int sysctl_sched_latency = 5000000ULL;
+unsigned int normalized_sysctl_sched_latency = 5000000ULL;
 
 /*
  * Minimal preemption granularity for CPU-bound tasks:
  * (default: 1 msec * (1 + ilog(ncpus)), units: nanoseconds)
  */
 unsigned int sysctl_sched_min_granularity = 1000000ULL;
+unsigned int normalized_sysctl_sched_min_granularity = 1000000ULL;
 
 /*
  * is kept at sysctl_sched_latency / sysctl_sched_min_granularity
@@ -70,6 +72,7 @@
  * have immediate wakeup/sleep latencies.
  */
 unsigned int sysctl_sched_wakeup_granularity = 1000000UL;
+unsigned int normalized_sysctl_sched_wakeup_granularity = 1000000UL;
 
 const_debug unsigned int sysctl_sched_migration_cost = 500000UL;
 
@@ -1374,6 +1377,9 @@
 
 	rcu_read_lock();
 	for_each_domain(cpu, tmp) {
+		if (!(tmp->flags & SD_LOAD_BALANCE))
+			continue;
+
 		/*
 		 * If power savings logic is enabled for a domain, see if we
 		 * are not overloaded, if so, don't balance wider.
@@ -1398,11 +1404,38 @@
 				want_sd = 0;
 		}
 
-		if (want_affine && (tmp->flags & SD_WAKE_AFFINE) &&
-		    cpumask_test_cpu(prev_cpu, sched_domain_span(tmp))) {
+		if (want_affine && (tmp->flags & SD_WAKE_AFFINE)) {
+			int candidate = -1, i;
+
+			if (cpumask_test_cpu(prev_cpu, sched_domain_span(tmp)))
+				candidate = cpu;
+
+			/*
+			 * Check for an idle shared cache.
+			 */
+			if (tmp->flags & SD_PREFER_SIBLING) {
+				if (candidate == cpu) {
+					if (!cpu_rq(prev_cpu)->cfs.nr_running)
+						candidate = prev_cpu;
+				}
+
+				if (candidate == -1 || candidate == cpu) {
+					for_each_cpu(i, sched_domain_span(tmp)) {
+						if (!cpumask_test_cpu(i, &p->cpus_allowed))
+							continue;
+						if (!cpu_rq(i)->cfs.nr_running) {
+							candidate = i;
+							break;
+						}
+					}
+				}
+			}
 
-			affine_sd = tmp;
-			want_affine = 0;
+			if (candidate >= 0) {
+				affine_sd = tmp;
+				want_affine = 0;
+				cpu = candidate;
+			}
 		}
 
 		if (!want_sd && !want_affine)
@@ -1850,6 +1883,17 @@
 
 	return 0;
 }
+
+static void rq_online_fair(struct rq *rq)
+{
+	update_sysctl();
+}
+
+static void rq_offline_fair(struct rq *rq)
+{
+	update_sysctl();
+}
+
 #endif /* CONFIG_SMP */
 
 /*
@@ -1997,6 +2041,8 @@
 
 	.load_balance		= load_balance_fair,
 	.move_one_task		= move_one_task_fair,
+	.rq_online		= rq_online_fair,
+	.rq_offline		= rq_offline_fair,
 #endif
 
 	.set_curr_task          = set_curr_task_fair,
diff -Nur linux-2.6.32-orig/kernel/signal.c iDroid-Project-kernel_common-9e90fd2/kernel/signal.c
--- linux-2.6.32-orig/kernel/signal.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/signal.c	2010-11-18 21:05:30.000000000 +0600
@@ -939,7 +939,8 @@
 		for (i = 0; i < 16; i++) {
 			unsigned char insn;
 
-			__get_user(insn, (unsigned char *)(regs->ip + i));
+			if (get_user(insn, (unsigned char *)(regs->ip + i)))
+				break;
 			printk("%02x ", insn);
 		}
 	}
diff -Nur linux-2.6.32-orig/kernel/sysctl.c iDroid-Project-kernel_common-9e90fd2/kernel/sysctl.c
--- linux-2.6.32-orig/kernel/sysctl.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/sysctl.c	2010-11-18 21:05:30.000000000 +0600
@@ -79,6 +79,7 @@
 extern unsigned int core_pipe_limit;
 extern int pid_max;
 extern int min_free_kbytes;
+extern int min_free_order_shift;
 extern int pid_max_min, pid_max_max;
 extern int sysctl_drop_caches;
 extern int percpu_pagelist_fraction;
@@ -1229,6 +1230,14 @@
 		.extra1		= &zero,
 	},
 	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "min_free_order_shift",
+		.data		= &min_free_order_shift,
+		.maxlen		= sizeof(min_free_order_shift),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
 		.ctl_name	= VM_PERCPU_PAGELIST_FRACTION,
 		.procname	= "percpu_pagelist_fraction",
 		.data		= &percpu_pagelist_fraction,
@@ -1345,6 +1354,7 @@
 		.strategy	= &sysctl_jiffies,
 	},
 #endif
+#ifdef CONFIG_MMU
 	{
 		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "mmap_min_addr",
@@ -1353,6 +1363,7 @@
 		.mode		= 0644,
 		.proc_handler	= &mmap_min_addr_handler,
 	},
+#endif
 #ifdef CONFIG_NUMA
 	{
 		.ctl_name	= CTL_UNNUMBERED,
@@ -1605,7 +1616,8 @@
 		.data		= &show_unhandled_signals,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
-		.proc_handler	= proc_dointvec
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &zero,
 	},
 #endif
 	{ .ctl_name = 0 }
diff -Nur linux-2.6.32-orig/kernel/sysctl_check.c iDroid-Project-kernel_common-9e90fd2/kernel/sysctl_check.c
--- linux-2.6.32-orig/kernel/sysctl_check.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/sysctl_check.c	2010-11-18 21:05:30.000000000 +0600
@@ -220,6 +220,7 @@
 	{ NET_IPV4_CONF_PROMOTE_SECONDARIES,	"promote_secondaries" },
 	{ NET_IPV4_CONF_ARP_ACCEPT,		"arp_accept" },
 	{ NET_IPV4_CONF_ARP_NOTIFY,		"arp_notify" },
+	{ NET_IPV4_CONF_SRC_VMARK,		"src_valid_mark" },
 	{}
 };
 
diff -Nur linux-2.6.32-orig/kernel/time/clockevents.c iDroid-Project-kernel_common-9e90fd2/kernel/time/clockevents.c
--- linux-2.6.32-orig/kernel/time/clockevents.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/time/clockevents.c	2010-11-18 21:05:30.000000000 +0600
@@ -20,6 +20,8 @@
 #include <linux/sysdev.h>
 #include <linux/tick.h>
 
+#include "tick-internal.h"
+
 /* The registered clock event devices */
 static LIST_HEAD(clockevent_devices);
 static LIST_HEAD(clockevents_released);
@@ -237,8 +239,9 @@
  */
 void clockevents_notify(unsigned long reason, void *arg)
 {
-	struct list_head *node, *tmp;
+	struct clock_event_device *dev, *tmp;
 	unsigned long flags;
+	int cpu;
 
 	spin_lock_irqsave(&clockevents_lock, flags);
 	clockevents_do_notify(reason, arg);
@@ -249,8 +252,20 @@
 		 * Unregister the clock event devices which were
 		 * released from the users in the notify chain.
 		 */
-		list_for_each_safe(node, tmp, &clockevents_released)
-			list_del(node);
+		list_for_each_entry_safe(dev, tmp, &clockevents_released, list)
+			list_del(&dev->list);
+		/*
+		 * Now check whether the CPU has left unused per cpu devices
+		 */
+		cpu = *((int *)arg);
+		list_for_each_entry_safe(dev, tmp, &clockevent_devices, list) {
+			if (cpumask_test_cpu(cpu, dev->cpumask) &&
+			    cpumask_weight(dev->cpumask) == 1 &&
+			    !tick_is_broadcast_device(dev)) {
+				BUG_ON(dev->mode != CLOCK_EVT_MODE_UNUSED);
+				list_del(&dev->list);
+			}
+		}
 		break;
 	default:
 		break;
diff -Nur linux-2.6.32-orig/kernel/time/clocksource.c iDroid-Project-kernel_common-9e90fd2/kernel/time/clocksource.c
--- linux-2.6.32-orig/kernel/time/clocksource.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/time/clocksource.c	2010-11-18 21:05:30.000000000 +0600
@@ -107,6 +107,59 @@
 }
 EXPORT_SYMBOL(timecounter_cyc2time);
 
+/**
+ * clocks_calc_mult_shift - calculate mult/shift factors for scaled math of clocks
+ * @mult:       pointer to mult variable
+ * @shift:      pointer to shift variable
+ * @from:       frequency to convert from
+ * @to:         frequency to convert to
+ * @minsec:     guaranteed runtime conversion range in seconds
+ *
+ * The function evaluates the shift/mult pair for the scaled math
+ * operations of clocksources and clockevents.
+ *
+ * @to and @from are frequency values in HZ. For clock sources @to is
+ * NSEC_PER_SEC == 1GHz and @from is the counter frequency. For clock
+ * event @to is the counter frequency and @from is NSEC_PER_SEC.
+ *
+ * The @minsec conversion range argument controls the time frame in
+ * seconds which must be covered by the runtime conversion with the
+ * calculated mult and shift factors. This guarantees that no 64bit
+ * overflow happens when the input value of the conversion is
+ * multiplied with the calculated mult factor. Larger ranges may
+ * reduce the conversion accuracy by chosing smaller mult and shift
+ * factors.
+ */
+	void
+clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 minsec)
+{
+	u64 tmp;
+	u32 sft, sftacc= 32;
+
+	/*
+	 * Calculate the shift factor which is limiting the conversion
+	 * range:
+	 */
+	tmp = ((u64)minsec * from) >> 32;
+	while (tmp) {
+		tmp >>=1;
+		sftacc--;
+	}
+
+	/*
+	 * Find the conversion shift/mult pair which has the best
+	 * accuracy and fits the maxsec conversion range:
+	 */
+	for (sft = 32; sft > 0; sft--) {
+		tmp = (u64) to << sft;
+		do_div(tmp, from);
+		if ((tmp >> sftacc) == 0)
+			break;
+	}
+	*mult = tmp;
+	*shift = sft;
+}
+
 /*[Clocksource internal variables]---------
  * curr_clocksource:
  *	currently selected clocksource.
@@ -413,6 +466,47 @@
 	clocksource_resume_watchdog();
 }
 
+/**
+ * clocksource_max_deferment - Returns max time the clocksource can be deferred
+ * @cs:         Pointer to clocksource
+ *
+ */
+static u64 clocksource_max_deferment(struct clocksource *cs)
+{
+	u64 max_nsecs, max_cycles;
+
+	/*
+	 * Calculate the maximum number of cycles that we can pass to the
+	 * cyc2ns function without overflowing a 64-bit signed result. The
+	 * maximum number of cycles is equal to ULLONG_MAX/cs->mult which
+	 * is equivalent to the below.
+	 * max_cycles < (2^63)/cs->mult
+	 * max_cycles < 2^(log2((2^63)/cs->mult))
+	 * max_cycles < 2^(log2(2^63) - log2(cs->mult))
+	 * max_cycles < 2^(63 - log2(cs->mult))
+	 * max_cycles < 1 << (63 - log2(cs->mult))
+	 * Please note that we add 1 to the result of the log2 to account for
+	 * any rounding errors, ensure the above inequality is satisfied and
+	 * no overflow will occur.
+	 */
+	max_cycles = 1ULL << (63 - (ilog2(cs->mult) + 1));
+
+	/*
+	 * The actual maximum number of cycles we can defer the clocksource is
+	 * determined by the minimum of max_cycles and cs->mask.
+	 */
+	max_cycles = min_t(u64, max_cycles, (u64) cs->mask);
+	max_nsecs = clocksource_cyc2ns(max_cycles, cs->mult, cs->shift);
+
+	/*
+	 * To ensure that the clocksource does not wrap whilst we are idle,
+	 * limit the time the clocksource can be deferred by 12.5%. Please
+	 * note a margin of 12.5% is used because this can be computed with
+	 * a shift, versus say 10% which would require division.
+	 */
+	return max_nsecs - (max_nsecs >> 5);
+}
+
 #ifdef CONFIG_GENERIC_TIME
 
 /**
@@ -511,6 +605,9 @@
  */
 int clocksource_register(struct clocksource *cs)
 {
+	/* calculate max idle time permitted for this clocksource */
+	cs->max_idle_ns = clocksource_max_deferment(cs);
+
 	mutex_lock(&clocksource_mutex);
 	clocksource_enqueue(cs);
 	clocksource_select();
diff -Nur linux-2.6.32-orig/kernel/time/tick-sched.c iDroid-Project-kernel_common-9e90fd2/kernel/time/tick-sched.c
--- linux-2.6.32-orig/kernel/time/tick-sched.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/time/tick-sched.c	2010-11-18 21:05:30.000000000 +0600
@@ -216,6 +216,7 @@
 	struct tick_sched *ts;
 	ktime_t last_update, expires, now;
 	struct clock_event_device *dev = __get_cpu_var(tick_cpu_device).evtdev;
+	u64 time_delta;
 	int cpu;
 
 	local_irq_save(flags);
@@ -275,6 +276,17 @@
 		seq = read_seqbegin(&xtime_lock);
 		last_update = last_jiffies_update;
 		last_jiffies = jiffies;
+
+		/*
+		 * On SMP we really should only care for the CPU which
+		 * has the do_timer duty assigned. All other CPUs can
+		 * sleep as long as they want.
+		 */
+		if (cpu == tick_do_timer_cpu ||
+		    tick_do_timer_cpu == TICK_DO_TIMER_NONE)
+			time_delta = timekeeping_max_deferment();
+		else
+			time_delta = KTIME_MAX;
 	} while (read_seqretry(&xtime_lock, seq));
 
 	/* Get the next timer wheel timer */
@@ -294,11 +306,26 @@
 	if ((long)delta_jiffies >= 1) {
 
 		/*
-		* calculate the expiry time for the next timer wheel
-		* timer
-		*/
-		expires = ktime_add_ns(last_update, tick_period.tv64 *
-				   delta_jiffies);
+		 * calculate the expiry time for the next timer wheel
+		 * timer. delta_jiffies >= NEXT_TIMER_MAX_DELTA signals
+		 * that there is no timer pending or at least extremely
+		 * far into the future (12 days for HZ=1000). In this
+		 * case we set the expiry to the end of time.
+		 */
+		if (likely(delta_jiffies < NEXT_TIMER_MAX_DELTA)) {
+			/*
+			 * Calculate the time delta for the next timer event.
+			 * If the time delta exceeds the maximum time delta
+			 * permitted by the current clocksource then adjust
+			 * the time delta accordingly to ensure the
+			 * clocksource does not wrap.
+			 */
+			time_delta = min_t(u64, time_delta,
+					   tick_period.tv64 * delta_jiffies);
+			expires = ktime_add_ns(last_update, time_delta);
+		} else {
+			expires.tv64 = KTIME_MAX;
+		}
 
 		/*
 		 * If this cpu is the one which updates jiffies, then
@@ -342,22 +369,19 @@
 
 		ts->idle_sleeps++;
 
+		/* Mark expires */
+		ts->idle_expires = expires;
+
 		/*
-		 * delta_jiffies >= NEXT_TIMER_MAX_DELTA signals that
-		 * there is no timer pending or at least extremly far
-		 * into the future (12 days for HZ=1000). In this case
-		 * we simply stop the tick timer:
+		 * If the expiration time == KTIME_MAX, then
+		 * in this case we simply stop the tick timer.
 		 */
-		if (unlikely(delta_jiffies >= NEXT_TIMER_MAX_DELTA)) {
-			ts->idle_expires.tv64 = KTIME_MAX;
+		 if (unlikely(expires.tv64 == KTIME_MAX)) {
 			if (ts->nohz_mode == NOHZ_MODE_HIGHRES)
 				hrtimer_cancel(&ts->sched_timer);
 			goto out;
 		}
 
-		/* Mark expiries */
-		ts->idle_expires = expires;
-
 		if (ts->nohz_mode == NOHZ_MODE_HIGHRES) {
 			hrtimer_start(&ts->sched_timer, expires,
 				      HRTIMER_MODE_ABS_PINNED);
diff -Nur linux-2.6.32-orig/kernel/time/timekeeping.c iDroid-Project-kernel_common-9e90fd2/kernel/time/timekeeping.c
--- linux-2.6.32-orig/kernel/time/timekeeping.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/kernel/time/timekeeping.c	2010-11-18 21:05:30.000000000 +0600
@@ -488,6 +488,17 @@
 }
 
 /**
+ * timekeeping_max_deferment - Returns max time the clocksource can be deferred
+ *
+ * Caller must observe xtime_lock via read_seqbegin/read_seqretry to
+ * ensure that the clocksource does not change!
+ */
+u64 timekeeping_max_deferment(void)
+{
+	return timekeeper.clock->max_idle_ns;
+}
+
+/**
  * read_persistent_clock -  Return time from the persistent clock.
  *
  * Weak dummy function for arches that do not yet support it.
@@ -834,6 +845,7 @@
 
 	set_normalized_timespec(ts, -boottime.tv_sec, -boottime.tv_nsec);
 }
+EXPORT_SYMBOL_GPL(getboottime);
 
 /**
  * monotonic_to_bootbased - Convert the monotonic time to boot based.
@@ -843,6 +855,7 @@
 {
 	*ts = timespec_add_safe(*ts, total_sleep_time);
 }
+EXPORT_SYMBOL_GPL(monotonic_to_bootbased);
 
 unsigned long get_seconds(void)
 {
diff -Nur linux-2.6.32-orig/lib/dma-debug.c iDroid-Project-kernel_common-9e90fd2/lib/dma-debug.c
--- linux-2.6.32-orig/lib/dma-debug.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/lib/dma-debug.c	2010-11-18 21:05:30.000000000 +0600
@@ -670,12 +670,13 @@
 	return count;
 }
 
-static int dma_debug_device_change(struct notifier_block *nb,
-				    unsigned long action, void *data)
+static int dma_debug_device_change(struct notifier_block *nb, unsigned long action, void *data)
 {
 	struct device *dev = data;
 	int count;
 
+	if (global_disable)
+		return 0;
 
 	switch (action) {
 	case BUS_NOTIFY_UNBOUND_DRIVER:
@@ -697,6 +698,9 @@
 {
 	struct notifier_block *nb;
 
+	if (global_disable)
+		return;
+
 	nb = kzalloc(sizeof(struct notifier_block), GFP_KERNEL);
 	if (nb == NULL) {
 		pr_err("dma_debug_add_bus: out of memory\n");
@@ -909,6 +913,9 @@
 				ref->size);
 	}
 
+	if (entry->direction == DMA_BIDIRECTIONAL)
+		goto out;
+
 	if (ref->direction != entry->direction) {
 		err_printk(dev, entry, "DMA-API: device driver syncs "
 				"DMA memory with different direction "
@@ -919,9 +926,6 @@
 				dir2name[ref->direction]);
 	}
 
-	if (entry->direction == DMA_BIDIRECTIONAL)
-		goto out;
-
 	if (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&
 		      !(ref->direction == DMA_TO_DEVICE))
 		err_printk(dev, entry, "DMA-API: device driver syncs "
@@ -944,7 +948,6 @@
 
 out:
 	put_hash_bucket(bucket, &flags);
-
 }
 
 void debug_dma_map_page(struct device *dev, struct page *page, size_t offset,
diff -Nur linux-2.6.32-orig/lib/rational.c iDroid-Project-kernel_common-9e90fd2/lib/rational.c
--- linux-2.6.32-orig/lib/rational.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/lib/rational.c	2010-11-18 21:05:30.000000000 +0600
@@ -7,6 +7,7 @@
  */
 
 #include <linux/rational.h>
+#include <linux/module.h>
 
 /*
  * calculate best rational approximation for a given fraction
diff -Nur linux-2.6.32-orig/MAINTAINERS iDroid-Project-kernel_common-9e90fd2/MAINTAINERS
--- linux-2.6.32-orig/MAINTAINERS	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/MAINTAINERS	2010-11-18 21:05:30.000000000 +0600
@@ -5594,9 +5594,11 @@
 F:	drivers/net/wireless/rndis_wlan.c
 
 USB XHCI DRIVER
-M:	Sarah Sharp <sarah.a.sharp@intel.com>
+M:	Sarah Sharp <sarah.a.sharp@linux.intel.com>
 L:	linux-usb@vger.kernel.org
 S:	Supported
+F:	drivers/usb/host/xhci*
+F:	drivers/usb/host/pci-quirks*
 
 USB ZC0301 DRIVER
 M:	Luca Risolia <luca.risolia@studio.unibo.it>
diff -Nur linux-2.6.32-orig/Makefile iDroid-Project-kernel_common-9e90fd2/Makefile
--- linux-2.6.32-orig/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 32
-EXTRAVERSION =
+EXTRAVERSION = .9
 NAME = Man-Eating Seals of Antiquity
 
 # *DOCUMENTATION*
@@ -85,6 +85,7 @@
 # The O= assignment takes precedence over the KBUILD_OUTPUT environment
 # variable.
 
+O=/home/fredrik/kernel-build
 
 # KBUILD_SRC is set on invocation of make in OBJ directory
 # KBUILD_SRC is not intended to be used by the regular user (for now)
@@ -180,8 +181,8 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH		?= arm
+CROSS_COMPILE	?= /home/fredrik/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
diff -Nur linux-2.6.32-orig/mm/ashmem.c iDroid-Project-kernel_common-9e90fd2/mm/ashmem.c
--- linux-2.6.32-orig/mm/ashmem.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/mm/ashmem.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,706 @@
+/* mm/ashmem.c
+**
+** Anonymous Shared Memory Subsystem, ashmem
+**
+** Copyright (C) 2008 Google, Inc.
+**
+** Robert Love <rlove@google.com>
+**
+** This software is licensed under the terms of the GNU General Public
+** License version 2, as published by the Free Software Foundation, and
+** may be copied, distributed, and modified under those terms.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+*/
+
+#include <linux/module.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/security.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/uaccess.h>
+#include <linux/personality.h>
+#include <linux/bitops.h>
+#include <linux/mutex.h>
+#include <linux/shmem_fs.h>
+#include <linux/ashmem.h>
+
+#define ASHMEM_NAME_PREFIX "dev/ashmem/"
+#define ASHMEM_NAME_PREFIX_LEN (sizeof(ASHMEM_NAME_PREFIX) - 1)
+#define ASHMEM_FULL_NAME_LEN (ASHMEM_NAME_LEN + ASHMEM_NAME_PREFIX_LEN)
+
+/*
+ * ashmem_area - anonymous shared memory area
+ * Lifecycle: From our parent file's open() until its release()
+ * Locking: Protected by `ashmem_mutex'
+ * Big Note: Mappings do NOT pin this structure; it dies on close()
+ */
+struct ashmem_area {
+	char name[ASHMEM_FULL_NAME_LEN];/* optional name for /proc/pid/maps */
+	struct list_head unpinned_list;	/* list of all ashmem areas */
+	struct file *file;		/* the shmem-based backing file */
+	size_t size;			/* size of the mapping, in bytes */
+	unsigned long prot_mask;	/* allowed prot bits, as vm_flags */
+};
+
+/*
+ * ashmem_range - represents an interval of unpinned (evictable) pages
+ * Lifecycle: From unpin to pin
+ * Locking: Protected by `ashmem_mutex'
+ */
+struct ashmem_range {
+	struct list_head lru;		/* entry in LRU list */
+	struct list_head unpinned;	/* entry in its area's unpinned list */
+	struct ashmem_area *asma;	/* associated area */
+	size_t pgstart;			/* starting page, inclusive */
+	size_t pgend;			/* ending page, inclusive */
+	unsigned int purged;		/* ASHMEM_NOT or ASHMEM_WAS_PURGED */
+};
+
+/* LRU list of unpinned pages, protected by ashmem_mutex */
+static LIST_HEAD(ashmem_lru_list);
+
+/* Count of pages on our LRU list, protected by ashmem_mutex */
+static unsigned long lru_count;
+
+/*
+ * ashmem_mutex - protects the list of and each individual ashmem_area
+ *
+ * Lock Ordering: ashmex_mutex -> i_mutex -> i_alloc_sem
+ */
+static DEFINE_MUTEX(ashmem_mutex);
+
+static struct kmem_cache *ashmem_area_cachep __read_mostly;
+static struct kmem_cache *ashmem_range_cachep __read_mostly;
+
+#define range_size(range) \
+  ((range)->pgend - (range)->pgstart + 1)
+
+#define range_on_lru(range) \
+  ((range)->purged == ASHMEM_NOT_PURGED)
+
+#define page_range_subsumes_range(range, start, end) \
+  (((range)->pgstart >= (start)) && ((range)->pgend <= (end)))
+
+#define page_range_subsumed_by_range(range, start, end) \
+  (((range)->pgstart <= (start)) && ((range)->pgend >= (end)))
+
+#define page_in_range(range, page) \
+ (((range)->pgstart <= (page)) && ((range)->pgend >= (page)))
+
+#define page_range_in_range(range, start, end) \
+  (page_in_range(range, start) || page_in_range(range, end) || \
+   page_range_subsumes_range(range, start, end))
+
+#define range_before_page(range, page) \
+  ((range)->pgend < (page))
+
+#define PROT_MASK		(PROT_EXEC | PROT_READ | PROT_WRITE)
+
+static inline void lru_add(struct ashmem_range *range)
+{
+	list_add_tail(&range->lru, &ashmem_lru_list);
+	lru_count += range_size(range);
+}
+
+static inline void lru_del(struct ashmem_range *range)
+{
+	list_del(&range->lru);
+	lru_count -= range_size(range);
+}
+
+/*
+ * range_alloc - allocate and initialize a new ashmem_range structure
+ *
+ * 'asma' - associated ashmem_area
+ * 'prev_range' - the previous ashmem_range in the sorted asma->unpinned list
+ * 'purged' - initial purge value (ASMEM_NOT_PURGED or ASHMEM_WAS_PURGED)
+ * 'start' - starting page, inclusive
+ * 'end' - ending page, inclusive
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static int range_alloc(struct ashmem_area *asma,
+		       struct ashmem_range *prev_range, unsigned int purged,
+		       size_t start, size_t end)
+{
+	struct ashmem_range *range;
+
+	range = kmem_cache_zalloc(ashmem_range_cachep, GFP_KERNEL);
+	if (unlikely(!range))
+		return -ENOMEM;
+
+	range->asma = asma;
+	range->pgstart = start;
+	range->pgend = end;
+	range->purged = purged;
+
+	list_add_tail(&range->unpinned, &prev_range->unpinned);
+
+	if (range_on_lru(range))
+		lru_add(range);
+
+	return 0;
+}
+
+static void range_del(struct ashmem_range *range)
+{
+	list_del(&range->unpinned);
+	if (range_on_lru(range))
+		lru_del(range);
+	kmem_cache_free(ashmem_range_cachep, range);
+}
+
+/*
+ * range_shrink - shrinks a range
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static inline void range_shrink(struct ashmem_range *range,
+				size_t start, size_t end)
+{
+	size_t pre = range_size(range);
+
+	range->pgstart = start;
+	range->pgend = end;
+
+	if (range_on_lru(range))
+		lru_count -= pre - range_size(range);
+}
+
+static int ashmem_open(struct inode *inode, struct file *file)
+{
+	struct ashmem_area *asma;
+	int ret;
+
+	ret = nonseekable_open(inode, file);
+	if (unlikely(ret))
+		return ret;
+
+	asma = kmem_cache_zalloc(ashmem_area_cachep, GFP_KERNEL);
+	if (unlikely(!asma))
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&asma->unpinned_list);
+	memcpy(asma->name, ASHMEM_NAME_PREFIX, ASHMEM_NAME_PREFIX_LEN);
+	asma->prot_mask = PROT_MASK;
+	file->private_data = asma;
+
+	return 0;
+}
+
+static int ashmem_release(struct inode *ignored, struct file *file)
+{
+	struct ashmem_area *asma = file->private_data;
+	struct ashmem_range *range, *next;
+
+	mutex_lock(&ashmem_mutex);
+	list_for_each_entry_safe(range, next, &asma->unpinned_list, unpinned)
+		range_del(range);
+	mutex_unlock(&ashmem_mutex);
+
+	if (asma->file)
+		fput(asma->file);
+	kmem_cache_free(ashmem_area_cachep, asma);
+
+	return 0;
+}
+
+static ssize_t ashmem_read(struct file *file, char __user *buf,
+			   size_t len, loff_t *pos)
+{
+	struct ashmem_area *asma = file->private_data;
+	int ret = 0;
+
+	mutex_lock(&ashmem_mutex);
+
+	/* If size is not set, or set to 0, always return EOF. */
+	if (asma->size == 0) {
+		goto out;
+        }
+
+	if (!asma->file) {
+		ret = -EBADF;
+		goto out;
+	}
+
+	ret = asma->file->f_op->read(asma->file, buf, len, pos);
+
+out:
+	mutex_unlock(&ashmem_mutex);
+	return ret;
+}
+
+static inline unsigned long
+calc_vm_may_flags(unsigned long prot)
+{
+	return _calc_vm_trans(prot, PROT_READ,  VM_MAYREAD ) |
+	       _calc_vm_trans(prot, PROT_WRITE, VM_MAYWRITE) |
+	       _calc_vm_trans(prot, PROT_EXEC,  VM_MAYEXEC);
+}
+
+static int ashmem_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct ashmem_area *asma = file->private_data;
+	int ret = 0;
+
+	mutex_lock(&ashmem_mutex);
+
+	/* user needs to SET_SIZE before mapping */
+	if (unlikely(!asma->size)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* requested protection bits must match our allowed protection mask */
+	if (unlikely((vma->vm_flags & ~calc_vm_prot_bits(asma->prot_mask)) &
+						calc_vm_prot_bits(PROT_MASK))) {
+		ret = -EPERM;
+		goto out;
+	}
+	vma->vm_flags &= ~calc_vm_may_flags(~asma->prot_mask);
+
+	if (!asma->file) {
+		char *name = ASHMEM_NAME_DEF;
+		struct file *vmfile;
+
+		if (asma->name[ASHMEM_NAME_PREFIX_LEN] != '\0')
+			name = asma->name;
+
+		/* ... and allocate the backing shmem file */
+		vmfile = shmem_file_setup(name, asma->size, vma->vm_flags);
+		if (unlikely(IS_ERR(vmfile))) {
+			ret = PTR_ERR(vmfile);
+			goto out;
+		}
+		asma->file = vmfile;
+	}
+	get_file(asma->file);
+
+	if (vma->vm_flags & VM_SHARED)
+		shmem_set_file(vma, asma->file);
+	else {
+		if (vma->vm_file)
+			fput(vma->vm_file);
+		vma->vm_file = asma->file;
+	}
+	vma->vm_flags |= VM_CAN_NONLINEAR;
+
+out:
+	mutex_unlock(&ashmem_mutex);
+	return ret;
+}
+
+/*
+ * ashmem_shrink - our cache shrinker, called from mm/vmscan.c :: shrink_slab
+ *
+ * 'nr_to_scan' is the number of objects (pages) to prune, or 0 to query how
+ * many objects (pages) we have in total.
+ *
+ * 'gfp_mask' is the mask of the allocation that got us into this mess.
+ *
+ * Return value is the number of objects (pages) remaining, or -1 if we cannot
+ * proceed without risk of deadlock (due to gfp_mask).
+ *
+ * We approximate LRU via least-recently-unpinned, jettisoning unpinned partial
+ * chunks of ashmem regions LRU-wise one-at-a-time until we hit 'nr_to_scan'
+ * pages freed.
+ */
+static int ashmem_shrink(int nr_to_scan, gfp_t gfp_mask)
+{
+	struct ashmem_range *range, *next;
+
+	/* We might recurse into filesystem code, so bail out if necessary */
+	if (nr_to_scan && !(gfp_mask & __GFP_FS))
+		return -1;
+	if (!nr_to_scan)
+		return lru_count;
+
+	mutex_lock(&ashmem_mutex);
+	list_for_each_entry_safe(range, next, &ashmem_lru_list, lru) {
+		struct inode *inode = range->asma->file->f_dentry->d_inode;
+		loff_t start = range->pgstart * PAGE_SIZE;
+		loff_t end = (range->pgend + 1) * PAGE_SIZE - 1;
+
+		vmtruncate_range(inode, start, end);
+		range->purged = ASHMEM_WAS_PURGED;
+		lru_del(range);
+
+		nr_to_scan -= range_size(range);
+		if (nr_to_scan <= 0)
+			break;
+	}
+	mutex_unlock(&ashmem_mutex);
+
+	return lru_count;
+}
+
+static struct shrinker ashmem_shrinker = {
+	.shrink = ashmem_shrink,
+	.seeks = DEFAULT_SEEKS * 4,
+};
+
+static int set_prot_mask(struct ashmem_area *asma, unsigned long prot)
+{
+	int ret = 0;
+
+	mutex_lock(&ashmem_mutex);
+
+	/* the user can only remove, not add, protection bits */
+	if (unlikely((asma->prot_mask & prot) != prot)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* does the application expect PROT_READ to imply PROT_EXEC? */
+	if ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))
+		prot |= PROT_EXEC;
+
+	asma->prot_mask = prot;
+
+out:
+	mutex_unlock(&ashmem_mutex);
+	return ret;
+}
+
+static int set_name(struct ashmem_area *asma, void __user *name)
+{
+	int ret = 0;
+
+	mutex_lock(&ashmem_mutex);
+
+	/* cannot change an existing mapping's name */
+	if (unlikely(asma->file)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (unlikely(copy_from_user(asma->name + ASHMEM_NAME_PREFIX_LEN,
+				    name, ASHMEM_NAME_LEN)))
+		ret = -EFAULT;
+	asma->name[ASHMEM_FULL_NAME_LEN-1] = '\0';
+
+out:
+	mutex_unlock(&ashmem_mutex);
+
+	return ret;
+}
+
+static int get_name(struct ashmem_area *asma, void __user *name)
+{
+	int ret = 0;
+
+	mutex_lock(&ashmem_mutex);
+	if (asma->name[ASHMEM_NAME_PREFIX_LEN] != '\0') {
+		size_t len;
+
+		/*
+		 * Copying only `len', instead of ASHMEM_NAME_LEN, bytes
+		 * prevents us from revealing one user's stack to another.
+		 */
+		len = strlen(asma->name + ASHMEM_NAME_PREFIX_LEN) + 1;
+		if (unlikely(copy_to_user(name,
+				asma->name + ASHMEM_NAME_PREFIX_LEN, len)))
+			ret = -EFAULT;
+	} else {
+		if (unlikely(copy_to_user(name, ASHMEM_NAME_DEF,
+					  sizeof(ASHMEM_NAME_DEF))))
+			ret = -EFAULT;
+	}
+	mutex_unlock(&ashmem_mutex);
+
+	return ret;
+}
+
+/*
+ * ashmem_pin - pin the given ashmem region, returning whether it was
+ * previously purged (ASHMEM_WAS_PURGED) or not (ASHMEM_NOT_PURGED).
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static int ashmem_pin(struct ashmem_area *asma, size_t pgstart, size_t pgend)
+{
+	struct ashmem_range *range, *next;
+	int ret = ASHMEM_NOT_PURGED;
+
+	list_for_each_entry_safe(range, next, &asma->unpinned_list, unpinned) {
+		/* moved past last applicable page; we can short circuit */
+		if (range_before_page(range, pgstart))
+			break;
+
+		/*
+		 * The user can ask us to pin pages that span multiple ranges,
+		 * or to pin pages that aren't even unpinned, so this is messy.
+		 *
+		 * Four cases:
+		 * 1. The requested range subsumes an existing range, so we
+		 *    just remove the entire matching range.
+		 * 2. The requested range overlaps the start of an existing
+		 *    range, so we just update that range.
+		 * 3. The requested range overlaps the end of an existing
+		 *    range, so we just update that range.
+		 * 4. The requested range punches a hole in an existing range,
+		 *    so we have to update one side of the range and then
+		 *    create a new range for the other side.
+		 */
+		if (page_range_in_range(range, pgstart, pgend)) {
+			ret |= range->purged;
+
+			/* Case #1: Easy. Just nuke the whole thing. */
+			if (page_range_subsumes_range(range, pgstart, pgend)) {
+				range_del(range);
+				continue;
+			}
+
+			/* Case #2: We overlap from the start, so adjust it */
+			if (range->pgstart >= pgstart) {
+				range_shrink(range, pgend + 1, range->pgend);
+				continue;
+			}
+
+			/* Case #3: We overlap from the rear, so adjust it */
+			if (range->pgend <= pgend) {
+				range_shrink(range, range->pgstart, pgstart-1);
+				continue;
+			}
+
+			/*
+			 * Case #4: We eat a chunk out of the middle. A bit
+			 * more complicated, we allocate a new range for the
+			 * second half and adjust the first chunk's endpoint.
+			 */
+			range_alloc(asma, range, range->purged,
+				    pgend + 1, range->pgend);
+			range_shrink(range, range->pgstart, pgstart - 1);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+/*
+ * ashmem_unpin - unpin the given range of pages. Returns zero on success.
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static int ashmem_unpin(struct ashmem_area *asma, size_t pgstart, size_t pgend)
+{
+	struct ashmem_range *range, *next;
+	unsigned int purged = ASHMEM_NOT_PURGED;
+
+restart:
+	list_for_each_entry_safe(range, next, &asma->unpinned_list, unpinned) {
+		/* short circuit: this is our insertion point */
+		if (range_before_page(range, pgstart))
+			break;
+
+		/*
+		 * The user can ask us to unpin pages that are already entirely
+		 * or partially pinned. We handle those two cases here.
+		 */
+		if (page_range_subsumed_by_range(range, pgstart, pgend))
+			return 0;
+		if (page_range_in_range(range, pgstart, pgend)) {
+			pgstart = min_t(size_t, range->pgstart, pgstart),
+			pgend = max_t(size_t, range->pgend, pgend);
+			purged |= range->purged;
+			range_del(range);
+			goto restart;
+		}
+	}
+
+	return range_alloc(asma, range, purged, pgstart, pgend);
+}
+
+/*
+ * ashmem_get_pin_status - Returns ASHMEM_IS_UNPINNED if _any_ pages in the
+ * given interval are unpinned and ASHMEM_IS_PINNED otherwise.
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static int ashmem_get_pin_status(struct ashmem_area *asma, size_t pgstart,
+				 size_t pgend)
+{
+	struct ashmem_range *range;
+	int ret = ASHMEM_IS_PINNED;
+
+	list_for_each_entry(range, &asma->unpinned_list, unpinned) {
+		if (range_before_page(range, pgstart))
+			break;
+		if (page_range_in_range(range, pgstart, pgend)) {
+			ret = ASHMEM_IS_UNPINNED;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int ashmem_pin_unpin(struct ashmem_area *asma, unsigned long cmd,
+			    void __user *p)
+{
+	struct ashmem_pin pin;
+	size_t pgstart, pgend;
+	int ret = -EINVAL;
+
+	if (unlikely(!asma->file))
+		return -EINVAL;
+
+	if (unlikely(copy_from_user(&pin, p, sizeof(pin))))
+		return -EFAULT;
+
+	/* per custom, you can pass zero for len to mean "everything onward" */
+	if (!pin.len)
+		pin.len = PAGE_ALIGN(asma->size) - pin.offset;
+
+	if (unlikely((pin.offset | pin.len) & ~PAGE_MASK))
+		return -EINVAL;
+
+	if (unlikely(((__u32) -1) - pin.offset < pin.len))
+		return -EINVAL;
+
+	if (unlikely(PAGE_ALIGN(asma->size) < pin.offset + pin.len))
+		return -EINVAL;
+
+	pgstart = pin.offset / PAGE_SIZE;
+	pgend = pgstart + (pin.len / PAGE_SIZE) - 1;
+
+	mutex_lock(&ashmem_mutex);
+
+	switch (cmd) {
+	case ASHMEM_PIN:
+		ret = ashmem_pin(asma, pgstart, pgend);
+		break;
+	case ASHMEM_UNPIN:
+		ret = ashmem_unpin(asma, pgstart, pgend);
+		break;
+	case ASHMEM_GET_PIN_STATUS:
+		ret = ashmem_get_pin_status(asma, pgstart, pgend);
+		break;
+	}
+
+	mutex_unlock(&ashmem_mutex);
+
+	return ret;
+}
+
+static long ashmem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct ashmem_area *asma = file->private_data;
+	long ret = -ENOTTY;
+
+	switch (cmd) {
+	case ASHMEM_SET_NAME:
+		ret = set_name(asma, (void __user *) arg);
+		break;
+	case ASHMEM_GET_NAME:
+		ret = get_name(asma, (void __user *) arg);
+		break;
+	case ASHMEM_SET_SIZE:
+		ret = -EINVAL;
+		if (!asma->file) {
+			ret = 0;
+			asma->size = (size_t) arg;
+		}
+		break;
+	case ASHMEM_GET_SIZE:
+		ret = asma->size;
+		break;
+	case ASHMEM_SET_PROT_MASK:
+		ret = set_prot_mask(asma, arg);
+		break;
+	case ASHMEM_GET_PROT_MASK:
+		ret = asma->prot_mask;
+		break;
+	case ASHMEM_PIN:
+	case ASHMEM_UNPIN:
+	case ASHMEM_GET_PIN_STATUS:
+		ret = ashmem_pin_unpin(asma, cmd, (void __user *) arg);
+		break;
+	case ASHMEM_PURGE_ALL_CACHES:
+		ret = -EPERM;
+		if (capable(CAP_SYS_ADMIN)) {
+			ret = ashmem_shrink(0, GFP_KERNEL);
+			ashmem_shrink(ret, GFP_KERNEL);
+		}
+		break;
+	}
+
+	return ret;
+}
+
+static struct file_operations ashmem_fops = {
+	.owner = THIS_MODULE,
+	.open = ashmem_open,
+	.release = ashmem_release,
+        .read = ashmem_read,
+	.mmap = ashmem_mmap,
+	.unlocked_ioctl = ashmem_ioctl,
+	.compat_ioctl = ashmem_ioctl,
+};
+
+static struct miscdevice ashmem_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "ashmem",
+	.fops = &ashmem_fops,
+};
+
+static int __init ashmem_init(void)
+{
+	int ret;
+
+	ashmem_area_cachep = kmem_cache_create("ashmem_area_cache",
+					  sizeof(struct ashmem_area),
+					  0, 0, NULL);
+	if (unlikely(!ashmem_area_cachep)) {
+		printk(KERN_ERR "ashmem: failed to create slab cache\n");
+		return -ENOMEM;
+	}
+
+	ashmem_range_cachep = kmem_cache_create("ashmem_range_cache",
+					  sizeof(struct ashmem_range),
+					  0, 0, NULL);
+	if (unlikely(!ashmem_range_cachep)) {
+		printk(KERN_ERR "ashmem: failed to create slab cache\n");
+		return -ENOMEM;
+	}
+
+	ret = misc_register(&ashmem_misc);
+	if (unlikely(ret)) {
+		printk(KERN_ERR "ashmem: failed to register misc device!\n");
+		return ret;
+	}
+
+	register_shrinker(&ashmem_shrinker);
+
+	printk(KERN_INFO "ashmem: initialized\n");
+
+	return 0;
+}
+
+static void __exit ashmem_exit(void)
+{
+	int ret;
+
+	unregister_shrinker(&ashmem_shrinker);
+
+	ret = misc_deregister(&ashmem_misc);
+	if (unlikely(ret))
+		printk(KERN_ERR "ashmem: failed to unregister misc device!\n");
+
+	kmem_cache_destroy(ashmem_range_cachep);
+	kmem_cache_destroy(ashmem_area_cachep);
+
+	printk(KERN_INFO "ashmem: unloaded\n");
+}
+
+module_init(ashmem_init);
+module_exit(ashmem_exit);
+
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/mm/filemap.c iDroid-Project-kernel_common-9e90fd2/mm/filemap.c
--- linux-2.6.32-orig/mm/filemap.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/filemap.c	2010-11-18 21:05:30.000000000 +0600
@@ -1655,14 +1655,15 @@
 static struct page *__read_cache_page(struct address_space *mapping,
 				pgoff_t index,
 				int (*filler)(void *,struct page*),
-				void *data)
+				void *data,
+				gfp_t gfp)
 {
 	struct page *page;
 	int err;
 repeat:
 	page = find_get_page(mapping, index);
 	if (!page) {
-		page = page_cache_alloc_cold(mapping);
+		page = __page_cache_alloc(gfp | __GFP_COLD);
 		if (!page)
 			return ERR_PTR(-ENOMEM);
 		err = add_to_page_cache_lru(page, mapping, index, GFP_KERNEL);
@@ -1682,31 +1683,18 @@
 	return page;
 }
 
-/**
- * read_cache_page_async - read into page cache, fill it if needed
- * @mapping:	the page's address_space
- * @index:	the page index
- * @filler:	function to perform the read
- * @data:	destination for read data
- *
- * Same as read_cache_page, but don't wait for page to become unlocked
- * after submitting it to the filler.
- *
- * Read into the page cache. If a page already exists, and PageUptodate() is
- * not set, try to fill the page but don't wait for it to become unlocked.
- *
- * If the page does not get brought uptodate, return -EIO.
- */
-struct page *read_cache_page_async(struct address_space *mapping,
+static struct page *do_read_cache_page(struct address_space *mapping,
 				pgoff_t index,
 				int (*filler)(void *,struct page*),
-				void *data)
+				void *data,
+				gfp_t gfp)
+
 {
 	struct page *page;
 	int err;
 
 retry:
-	page = __read_cache_page(mapping, index, filler, data);
+	page = __read_cache_page(mapping, index, filler, data, gfp);
 	if (IS_ERR(page))
 		return page;
 	if (PageUptodate(page))
@@ -1731,8 +1719,67 @@
 	mark_page_accessed(page);
 	return page;
 }
+
+/**
+ * read_cache_page_async - read into page cache, fill it if needed
+ * @mapping:	the page's address_space
+ * @index:	the page index
+ * @filler:	function to perform the read
+ * @data:	destination for read data
+ *
+ * Same as read_cache_page, but don't wait for page to become unlocked
+ * after submitting it to the filler.
+ *
+ * Read into the page cache. If a page already exists, and PageUptodate() is
+ * not set, try to fill the page but don't wait for it to become unlocked.
+ *
+ * If the page does not get brought uptodate, return -EIO.
+ */
+struct page *read_cache_page_async(struct address_space *mapping,
+				pgoff_t index,
+				int (*filler)(void *,struct page*),
+				void *data)
+{
+	return do_read_cache_page(mapping, index, filler, data, mapping_gfp_mask(mapping));
+}
 EXPORT_SYMBOL(read_cache_page_async);
 
+static struct page *wait_on_page_read(struct page *page)
+{
+	if (!IS_ERR(page)) {
+		wait_on_page_locked(page);
+		if (!PageUptodate(page)) {
+			page_cache_release(page);
+			page = ERR_PTR(-EIO);
+		}
+	}
+	return page;
+}
+
+/**
+ * read_cache_page_gfp - read into page cache, using specified page allocation flags.
+ * @mapping:	the page's address_space
+ * @index:	the page index
+ * @gfp:	the page allocator flags to use if allocating
+ *
+ * This is the same as "read_mapping_page(mapping, index, NULL)", but with
+ * any new page allocations done using the specified allocation flags. Note
+ * that the Radix tree operations will still use GFP_KERNEL, so you can't
+ * expect to do this atomically or anything like that - but you can pass in
+ * other page requirements.
+ *
+ * If the page does not get brought uptodate, return -EIO.
+ */
+struct page *read_cache_page_gfp(struct address_space *mapping,
+				pgoff_t index,
+				gfp_t gfp)
+{
+	filler_t *filler = (filler_t *)mapping->a_ops->readpage;
+
+	return wait_on_page_read(do_read_cache_page(mapping, index, filler, NULL, gfp));
+}
+EXPORT_SYMBOL(read_cache_page_gfp);
+
 /**
  * read_cache_page - read into page cache, fill it if needed
  * @mapping:	the page's address_space
@@ -1750,18 +1797,7 @@
 				int (*filler)(void *,struct page*),
 				void *data)
 {
-	struct page *page;
-
-	page = read_cache_page_async(mapping, index, filler, data);
-	if (IS_ERR(page))
-		goto out;
-	wait_on_page_locked(page);
-	if (!PageUptodate(page)) {
-		page_cache_release(page);
-		page = ERR_PTR(-EIO);
-	}
- out:
-	return page;
+	return wait_on_page_read(read_cache_page_async(mapping, index, filler, data));
 }
 EXPORT_SYMBOL(read_cache_page);
 
@@ -2217,6 +2253,9 @@
 		if (unlikely(status))
 			break;
 
+		if (mapping_writably_mapped(mapping))
+			flush_dcache_page(page);
+
 		pagefault_disable();
 		copied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);
 		pagefault_enable();
diff -Nur linux-2.6.32-orig/mm/internal.h iDroid-Project-kernel_common-9e90fd2/mm/internal.h
--- linux-2.6.32-orig/mm/internal.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/internal.h	2010-11-18 21:05:30.000000000 +0600
@@ -107,9 +107,10 @@
 }
 
 /*
- * must be called with vma's mmap_sem held for read, and page locked.
+ * must be called with vma's mmap_sem held for read or write, and page locked.
  */
 extern void mlock_vma_page(struct page *page);
+extern void munlock_vma_page(struct page *page);
 
 /*
  * Clear the page's PageMlocked().  This can be useful in a situation where
diff -Nur linux-2.6.32-orig/mm/Kconfig iDroid-Project-kernel_common-9e90fd2/mm/Kconfig
--- linux-2.6.32-orig/mm/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -227,6 +227,7 @@
 
 config DEFAULT_MMAP_MIN_ADDR
         int "Low address space to protect from user allocation"
+	depends on MMU
         default 4096
         help
 	  This is the portion of low virtual memory which should be protected
diff -Nur linux-2.6.32-orig/mm/ksm.c iDroid-Project-kernel_common-9e90fd2/mm/ksm.c
--- linux-2.6.32-orig/mm/ksm.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/ksm.c	2010-11-18 21:05:30.000000000 +0600
@@ -34,6 +34,7 @@
 #include <linux/ksm.h>
 
 #include <asm/tlbflush.h>
+#include "internal.h"
 
 /*
  * A few notes about the KSM scanning process,
@@ -767,15 +768,14 @@
 	 * ptes are necessarily already write-protected.  But in either
 	 * case, we need to lock and check page_count is not raised.
 	 */
-	if (write_protect_page(vma, oldpage, &orig_pte)) {
-		unlock_page(oldpage);
-		goto out_putpage;
-	}
-	unlock_page(oldpage);
-
-	if (pages_identical(oldpage, newpage))
+	if (write_protect_page(vma, oldpage, &orig_pte) == 0 &&
+	    pages_identical(oldpage, newpage))
 		err = replace_page(vma, oldpage, newpage, orig_pte);
 
+	if ((vma->vm_flags & VM_LOCKED) && !err)
+		munlock_vma_page(oldpage);
+
+	unlock_page(oldpage);
 out_putpage:
 	put_page(oldpage);
 	put_page(newpage);
diff -Nur linux-2.6.32-orig/mm/Makefile iDroid-Project-kernel_common-9e90fd2/mm/Makefile
--- linux-2.6.32-orig/mm/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -22,6 +22,7 @@
 obj-$(CONFIG_NUMA) 	+= mempolicy.o
 obj-$(CONFIG_SPARSEMEM)	+= sparse.o
 obj-$(CONFIG_SPARSEMEM_VMEMMAP) += sparse-vmemmap.o
+obj-$(CONFIG_ASHMEM) += ashmem.o
 obj-$(CONFIG_TMPFS_POSIX_ACL) += shmem_acl.o
 obj-$(CONFIG_SLOB) += slob.o
 obj-$(CONFIG_MMU_NOTIFIER) += mmu_notifier.o
diff -Nur linux-2.6.32-orig/mm/memcontrol.c iDroid-Project-kernel_common-9e90fd2/mm/memcontrol.c
--- linux-2.6.32-orig/mm/memcontrol.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/memcontrol.c	2010-11-18 21:05:30.000000000 +0600
@@ -758,7 +758,13 @@
 	task_unlock(task);
 	if (!curr)
 		return 0;
-	if (curr->use_hierarchy)
+	/*
+	 * We should check use_hierarchy of "mem" not "curr". Because checking
+	 * use_hierarchy of "curr" here make this function true if hierarchy is
+	 * enabled in "curr" and "curr" is a child of "mem" in *cgroup*
+	 * hierarchy(even if use_hierarchy is disabled in "mem").
+	 */
+	if (mem->use_hierarchy)
 		ret = css_is_ancestor(&curr->css, &mem->css);
 	else
 		ret = (curr == mem);
@@ -2375,7 +2381,7 @@
 	if (free_all)
 		goto try_to_free;
 move_account:
-	while (mem->res.usage > 0) {
+	do {
 		ret = -EBUSY;
 		if (cgroup_task_count(cgrp) || !list_empty(&cgrp->children))
 			goto out;
@@ -2402,8 +2408,8 @@
 		if (ret == -ENOMEM)
 			goto try_to_free;
 		cond_resched();
-	}
-	ret = 0;
+	/* "ret" should also be checked to ensure all lists are empty. */
+	} while (mem->res.usage > 0 || ret);
 out:
 	css_put(&mem->css);
 	return ret;
@@ -2436,10 +2442,7 @@
 	}
 	lru_add_drain();
 	/* try move_account...there may be some *locked* pages. */
-	if (mem->res.usage)
-		goto move_account;
-	ret = 0;
-	goto out;
+	goto move_account;
 }
 
 int mem_cgroup_force_empty_write(struct cgroup *cont, unsigned int event)
@@ -2541,6 +2544,7 @@
 			val += idx_val;
 			mem_cgroup_get_recursive_idx_stat(mem,
 				MEM_CGROUP_STAT_SWAPOUT, &idx_val);
+			val += idx_val;
 			val <<= PAGE_SHIFT;
 		} else
 			val = res_counter_read_u64(&mem->memsw, name);
diff -Nur linux-2.6.32-orig/mm/memory.c iDroid-Project-kernel_common-9e90fd2/mm/memory.c
--- linux-2.6.32-orig/mm/memory.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/memory.c	2010-11-18 21:05:30.000000000 +0600
@@ -2514,7 +2514,7 @@
 			ret = VM_FAULT_HWPOISON;
 		} else {
 			print_bad_pte(vma, address, orig_pte, NULL);
-			ret = VM_FAULT_OOM;
+			ret = VM_FAULT_SIGBUS;
 		}
 		goto out;
 	}
@@ -2910,7 +2910,7 @@
 		 * Page table corrupted: show pte and kill process.
 		 */
 		print_bad_pte(vma, address, orig_pte, NULL);
-		return VM_FAULT_OOM;
+		return VM_FAULT_SIGBUS;
 	}
 
 	pgoff = pte_to_pgoff(orig_pte);
diff -Nur linux-2.6.32-orig/mm/migrate.c iDroid-Project-kernel_common-9e90fd2/mm/migrate.c
--- linux-2.6.32-orig/mm/migrate.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/migrate.c	2010-11-18 21:05:30.000000000 +0600
@@ -953,6 +953,9 @@
 				goto out_pm;
 
 			err = -ENODEV;
+			if (node < 0 || node >= MAX_NUMNODES)
+				goto out_pm;
+
 			if (!node_state(node, N_HIGH_MEMORY))
 				goto out_pm;
 
diff -Nur linux-2.6.32-orig/mm/mincore.c iDroid-Project-kernel_common-9e90fd2/mm/mincore.c
--- linux-2.6.32-orig/mm/mincore.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/mincore.c	2010-11-18 21:05:30.000000000 +0600
@@ -14,6 +14,7 @@
 #include <linux/syscalls.h>
 #include <linux/swap.h>
 #include <linux/swapops.h>
+#include <linux/hugetlb.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -72,6 +73,42 @@
 	if (!vma || addr < vma->vm_start)
 		return -ENOMEM;
 
+#ifdef CONFIG_HUGETLB_PAGE
+	if (is_vm_hugetlb_page(vma)) {
+		struct hstate *h;
+		unsigned long nr_huge;
+		unsigned char present;
+
+		i = 0;
+		nr = min(pages, (vma->vm_end - addr) >> PAGE_SHIFT);
+		h = hstate_vma(vma);
+		nr_huge = ((addr + pages * PAGE_SIZE - 1) >> huge_page_shift(h))
+			  - (addr >> huge_page_shift(h)) + 1;
+		nr_huge = min(nr_huge,
+			      (vma->vm_end - addr) >> huge_page_shift(h));
+		while (1) {
+			/* hugepage always in RAM for now,
+			 * but generally it needs to be check */
+			ptep = huge_pte_offset(current->mm,
+					       addr & huge_page_mask(h));
+			present = !!(ptep &&
+				     !huge_pte_none(huge_ptep_get(ptep)));
+			while (1) {
+				vec[i++] = present;
+				addr += PAGE_SIZE;
+				/* reach buffer limit */
+				if (i == nr)
+					return nr;
+				/* check hugepage border */
+				if (!((addr & ~huge_page_mask(h))
+				      >> PAGE_SHIFT))
+					break;
+			}
+		}
+		return nr;
+	}
+#endif
+
 	/*
 	 * Calculate how many pages there are left in the last level of the
 	 * PTE array for our address.
diff -Nur linux-2.6.32-orig/mm/mlock.c iDroid-Project-kernel_common-9e90fd2/mm/mlock.c
--- linux-2.6.32-orig/mm/mlock.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/mlock.c	2010-11-18 21:05:30.000000000 +0600
@@ -99,14 +99,14 @@
  * not get another chance to clear PageMlocked.  If we successfully
  * isolate the page and try_to_munlock() detects other VM_LOCKED vmas
  * mapping the page, it will restore the PageMlocked state, unless the page
- * is mapped in a non-linear vma.  So, we go ahead and SetPageMlocked(),
+ * is mapped in a non-linear vma.  So, we go ahead and ClearPageMlocked(),
  * perhaps redundantly.
  * If we lose the isolation race, and the page is mapped by other VM_LOCKED
  * vmas, we'll detect this in vmscan--via try_to_munlock() or try_to_unmap()
  * either of which will restore the PageMlocked state by calling
  * mlock_vma_page() above, if it can grab the vma's mmap sem.
  */
-static void munlock_vma_page(struct page *page)
+void munlock_vma_page(struct page *page)
 {
 	BUG_ON(!PageLocked(page));
 
diff -Nur linux-2.6.32-orig/mm/mmap.c iDroid-Project-kernel_common-9e90fd2/mm/mmap.c
--- linux-2.6.32-orig/mm/mmap.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/mmap.c	2010-11-18 21:05:30.000000000 +0600
@@ -932,13 +932,9 @@
 	if (!(flags & MAP_FIXED))
 		addr = round_hint_to_min(addr);
 
-	error = arch_mmap_check(addr, len, flags);
-	if (error)
-		return error;
-
 	/* Careful about overflows.. */
 	len = PAGE_ALIGN(len);
-	if (!len || len > TASK_SIZE)
+	if (!len)
 		return -ENOMEM;
 
 	/* offset overflow? */
@@ -949,24 +945,6 @@
 	if (mm->map_count > sysctl_max_map_count)
 		return -ENOMEM;
 
-	if (flags & MAP_HUGETLB) {
-		struct user_struct *user = NULL;
-		if (file)
-			return -EINVAL;
-
-		/*
-		 * VM_NORESERVE is used because the reservations will be
-		 * taken when vm_ops->mmap() is called
-		 * A dummy user value is used because we are not locking
-		 * memory so no accounting is necessary
-		 */
-		len = ALIGN(len, huge_page_size(&default_hstate));
-		file = hugetlb_file_setup(HUGETLB_ANON_FILE, len, VM_NORESERVE,
-						&user, HUGETLB_ANONHUGE_INODE);
-		if (IS_ERR(file))
-			return PTR_ERR(file);
-	}
-
 	/* Obtain the address to map to. we verify (or select) it and ensure
 	 * that it represents a valid section of the address space.
 	 */
@@ -1459,6 +1437,14 @@
 	unsigned long (*get_area)(struct file *, unsigned long,
 				  unsigned long, unsigned long, unsigned long);
 
+	unsigned long error = arch_mmap_check(addr, len, flags);
+	if (error)
+		return error;
+
+	/* Careful about overflows.. */
+	if (len > TASK_SIZE)
+		return -ENOMEM;
+
 	get_area = current->mm->get_unmapped_area;
 	if (file && file->f_op && file->f_op->get_unmapped_area)
 		get_area = file->f_op->get_unmapped_area;
@@ -2003,20 +1989,14 @@
 	if (!len)
 		return addr;
 
-	if ((addr + len) > TASK_SIZE || (addr + len) < addr)
-		return -EINVAL;
-
-	if (is_hugepage_only_range(mm, addr, len))
-		return -EINVAL;
-
 	error = security_file_mmap(NULL, 0, 0, 0, addr, 1);
 	if (error)
 		return error;
 
 	flags = VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm->def_flags;
 
-	error = arch_mmap_check(addr, len, flags);
-	if (error)
+	error = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED);
+	if (error & ~PAGE_MASK)
 		return error;
 
 	/*
diff -Nur linux-2.6.32-orig/mm/mremap.c iDroid-Project-kernel_common-9e90fd2/mm/mremap.c
--- linux-2.6.32-orig/mm/mremap.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/mremap.c	2010-11-18 21:05:30.000000000 +0600
@@ -261,6 +261,137 @@
 	return new_addr;
 }
 
+static struct vm_area_struct *vma_to_resize(unsigned long addr,
+	unsigned long old_len, unsigned long new_len, unsigned long *p)
+{
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma = find_vma(mm, addr);
+
+	if (!vma || vma->vm_start > addr)
+		goto Efault;
+
+	if (is_vm_hugetlb_page(vma))
+		goto Einval;
+
+	/* We can't remap across vm area boundaries */
+	if (old_len > vma->vm_end - addr)
+		goto Efault;
+
+	if (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {
+		if (new_len > old_len)
+			goto Efault;
+	}
+
+	if (vma->vm_flags & VM_LOCKED) {
+		unsigned long locked, lock_limit;
+		locked = mm->locked_vm << PAGE_SHIFT;
+		lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;
+		locked += new_len - old_len;
+		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
+			goto Eagain;
+	}
+
+	if (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))
+		goto Enomem;
+
+	if (vma->vm_flags & VM_ACCOUNT) {
+		unsigned long charged = (new_len - old_len) >> PAGE_SHIFT;
+		if (security_vm_enough_memory(charged))
+			goto Efault;
+		*p = charged;
+	}
+
+	return vma;
+
+Efault:	/* very odd choice for most of the cases, but... */
+	return ERR_PTR(-EFAULT);
+Einval:
+	return ERR_PTR(-EINVAL);
+Enomem:
+	return ERR_PTR(-ENOMEM);
+Eagain:
+	return ERR_PTR(-EAGAIN);
+}
+
+static unsigned long mremap_to(unsigned long addr,
+	unsigned long old_len, unsigned long new_addr,
+	unsigned long new_len)
+{
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+	unsigned long ret = -EINVAL;
+	unsigned long charged = 0;
+	unsigned long map_flags;
+
+	if (new_addr & ~PAGE_MASK)
+		goto out;
+
+	if (new_len > TASK_SIZE || new_addr > TASK_SIZE - new_len)
+		goto out;
+
+	/* Check if the location we're moving into overlaps the
+	 * old location at all, and fail if it does.
+	 */
+	if ((new_addr <= addr) && (new_addr+new_len) > addr)
+		goto out;
+
+	if ((addr <= new_addr) && (addr+old_len) > new_addr)
+		goto out;
+
+	ret = security_file_mmap(NULL, 0, 0, 0, new_addr, 1);
+	if (ret)
+		goto out;
+
+	ret = do_munmap(mm, new_addr, new_len);
+	if (ret)
+		goto out;
+
+	if (old_len >= new_len) {
+		ret = do_munmap(mm, addr+new_len, old_len - new_len);
+		if (ret && old_len != new_len)
+			goto out;
+		old_len = new_len;
+	}
+
+	vma = vma_to_resize(addr, old_len, new_len, &charged);
+	if (IS_ERR(vma)) {
+		ret = PTR_ERR(vma);
+		goto out;
+	}
+
+	map_flags = MAP_FIXED;
+	if (vma->vm_flags & VM_MAYSHARE)
+		map_flags |= MAP_SHARED;
+
+	ret = get_unmapped_area(vma->vm_file, new_addr, new_len, vma->vm_pgoff +
+				((addr - vma->vm_start) >> PAGE_SHIFT),
+				map_flags);
+	if (ret & ~PAGE_MASK)
+		goto out1;
+
+	ret = move_vma(vma, addr, old_len, new_len, new_addr);
+	if (!(ret & ~PAGE_MASK))
+		goto out;
+out1:
+	vm_unacct_memory(charged);
+
+out:
+	return ret;
+}
+
+static int vma_expandable(struct vm_area_struct *vma, unsigned long delta)
+{
+	unsigned long end = vma->vm_end + delta;
+	if (end < vma->vm_end) /* overflow */
+		return 0;
+	if (vma->vm_next && vma->vm_next->vm_start < end) /* intersection */
+		return 0;
+	if (get_unmapped_area(NULL, vma->vm_start, end - vma->vm_start,
+			      0, MAP_FIXED) & ~PAGE_MASK)
+		return 0;
+	return 1;
+}
+
 /*
  * Expand (or shrink) an existing mapping, potentially moving it at the
  * same time (controlled by the MREMAP_MAYMOVE flag and available VM space)
@@ -294,32 +425,10 @@
 	if (!new_len)
 		goto out;
 
-	/* new_addr is only valid if MREMAP_FIXED is specified */
 	if (flags & MREMAP_FIXED) {
-		if (new_addr & ~PAGE_MASK)
-			goto out;
-		if (!(flags & MREMAP_MAYMOVE))
-			goto out;
-
-		if (new_len > TASK_SIZE || new_addr > TASK_SIZE - new_len)
-			goto out;
-
-		/* Check if the location we're moving into overlaps the
-		 * old location at all, and fail if it does.
-		 */
-		if ((new_addr <= addr) && (new_addr+new_len) > addr)
-			goto out;
-
-		if ((addr <= new_addr) && (addr+old_len) > new_addr)
-			goto out;
-
-		ret = security_file_mmap(NULL, 0, 0, 0, new_addr, 1);
-		if (ret)
-			goto out;
-
-		ret = do_munmap(mm, new_addr, new_len);
-		if (ret)
-			goto out;
+		if (flags & MREMAP_MAYMOVE)
+			ret = mremap_to(addr, old_len, new_addr, new_len);
+		goto out;
 	}
 
 	/*
@@ -332,60 +441,23 @@
 		if (ret && old_len != new_len)
 			goto out;
 		ret = addr;
-		if (!(flags & MREMAP_FIXED) || (new_addr == addr))
-			goto out;
-		old_len = new_len;
+		goto out;
 	}
 
 	/*
-	 * Ok, we need to grow..  or relocate.
+	 * Ok, we need to grow..
 	 */
-	ret = -EFAULT;
-	vma = find_vma(mm, addr);
-	if (!vma || vma->vm_start > addr)
+	vma = vma_to_resize(addr, old_len, new_len, &charged);
+	if (IS_ERR(vma)) {
+		ret = PTR_ERR(vma);
 		goto out;
-	if (is_vm_hugetlb_page(vma)) {
-		ret = -EINVAL;
-		goto out;
-	}
-	/* We can't remap across vm area boundaries */
-	if (old_len > vma->vm_end - addr)
-		goto out;
-	if (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {
-		if (new_len > old_len)
-			goto out;
-	}
-	if (vma->vm_flags & VM_LOCKED) {
-		unsigned long locked, lock_limit;
-		locked = mm->locked_vm << PAGE_SHIFT;
-		lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;
-		locked += new_len - old_len;
-		ret = -EAGAIN;
-		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
-			goto out;
-	}
-	if (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT)) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	if (vma->vm_flags & VM_ACCOUNT) {
-		charged = (new_len - old_len) >> PAGE_SHIFT;
-		if (security_vm_enough_memory(charged))
-			goto out_nc;
 	}
 
 	/* old_len exactly to the end of the area..
-	 * And we're not relocating the area.
 	 */
-	if (old_len == vma->vm_end - addr &&
-	    !((flags & MREMAP_FIXED) && (addr != new_addr)) &&
-	    (old_len != new_len || !(flags & MREMAP_MAYMOVE))) {
-		unsigned long max_addr = TASK_SIZE;
-		if (vma->vm_next)
-			max_addr = vma->vm_next->vm_start;
+	if (old_len == vma->vm_end - addr) {
 		/* can we just expand the current mapping? */
-		if (max_addr - addr >= new_len) {
+		if (vma_expandable(vma, new_len - old_len)) {
 			int pages = (new_len - old_len) >> PAGE_SHIFT;
 
 			vma_adjust(vma, vma->vm_start,
@@ -409,28 +481,27 @@
 	 */
 	ret = -ENOMEM;
 	if (flags & MREMAP_MAYMOVE) {
-		if (!(flags & MREMAP_FIXED)) {
-			unsigned long map_flags = 0;
-			if (vma->vm_flags & VM_MAYSHARE)
-				map_flags |= MAP_SHARED;
-
-			new_addr = get_unmapped_area(vma->vm_file, 0, new_len,
-						vma->vm_pgoff, map_flags);
-			if (new_addr & ~PAGE_MASK) {
-				ret = new_addr;
-				goto out;
-			}
-
-			ret = security_file_mmap(NULL, 0, 0, 0, new_addr, 1);
-			if (ret)
-				goto out;
+		unsigned long map_flags = 0;
+		if (vma->vm_flags & VM_MAYSHARE)
+			map_flags |= MAP_SHARED;
+
+		new_addr = get_unmapped_area(vma->vm_file, 0, new_len,
+					vma->vm_pgoff +
+					((addr - vma->vm_start) >> PAGE_SHIFT),
+					map_flags);
+		if (new_addr & ~PAGE_MASK) {
+			ret = new_addr;
+			goto out;
 		}
+
+		ret = security_file_mmap(NULL, 0, 0, 0, new_addr, 1);
+		if (ret)
+			goto out;
 		ret = move_vma(vma, addr, old_len, new_len, new_addr);
 	}
 out:
 	if (ret & ~PAGE_MASK)
 		vm_unacct_memory(charged);
-out_nc:
 	return ret;
 }
 
diff -Nur linux-2.6.32-orig/mm/oom_kill.c iDroid-Project-kernel_common-9e90fd2/mm/oom_kill.c
--- linux-2.6.32-orig/mm/oom_kill.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/oom_kill.c	2010-11-18 21:05:30.000000000 +0600
@@ -404,7 +404,7 @@
 		cpuset_print_task_mems_allowed(current);
 		task_unlock(current);
 		dump_stack();
-		mem_cgroup_print_oom_info(mem, current);
+		mem_cgroup_print_oom_info(mem, p);
 		show_mem();
 		if (sysctl_oom_dump_tasks)
 			dump_tasks(mem);
diff -Nur linux-2.6.32-orig/mm/page_alloc.c iDroid-Project-kernel_common-9e90fd2/mm/page_alloc.c
--- linux-2.6.32-orig/mm/page_alloc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/page_alloc.c	2010-11-18 21:05:30.000000000 +0600
@@ -122,6 +122,7 @@
 };
 
 int min_free_kbytes = 1024;
+int min_free_order_shift = 1;
 
 static unsigned long __meminitdata nr_kernel_pages;
 static unsigned long __meminitdata nr_all_pages;
@@ -559,8 +560,9 @@
 			page = list_entry(list->prev, struct page, lru);
 			/* must delete as __free_one_page list manipulates */
 			list_del(&page->lru);
-			__free_one_page(page, zone, 0, migratetype);
-			trace_mm_page_pcpu_drain(page, 0, migratetype);
+			/* MIGRATE_MOVABLE list may include MIGRATE_RESERVEs */
+			__free_one_page(page, zone, 0, page_private(page));
+			trace_mm_page_pcpu_drain(page, 0, page_private(page));
 		} while (--count && --batch_free && !list_empty(list));
 	}
 	spin_unlock(&zone->lock);
@@ -1225,10 +1227,10 @@
 		}
 		spin_lock_irqsave(&zone->lock, flags);
 		page = __rmqueue(zone, order, migratetype);
-		__mod_zone_page_state(zone, NR_FREE_PAGES, -(1 << order));
 		spin_unlock(&zone->lock);
 		if (!page)
 			goto failed;
+		__mod_zone_page_state(zone, NR_FREE_PAGES, -(1 << order));
 	}
 
 	__count_zone_vm_events(PGALLOC, zone, 1 << order);
@@ -1379,7 +1381,7 @@
 		free_pages -= z->free_area[o].nr_free << o;
 
 		/* Require fewer higher order pages to be free */
-		min >>= 1;
+		min >>= min_free_order_shift;
 
 		if (free_pages <= min)
 			return 0;
@@ -2858,6 +2860,20 @@
 #define LONG_ALIGN(x) (((x)+(sizeof(long))-1)&~((sizeof(long))-1))
 
 /*
+ * Check if a pageblock contains reserved pages
+ */
+static int pageblock_is_reserved(unsigned long start_pfn)
+{
+	unsigned long end_pfn = start_pfn + pageblock_nr_pages;
+	unsigned long pfn;
+
+	for (pfn = start_pfn; pfn < end_pfn; pfn++)
+		if (PageReserved(pfn_to_page(pfn)))
+			return 1;
+	return 0;
+}
+
+/*
  * Mark a number of pageblocks as MIGRATE_RESERVE. The number
  * of blocks reserved is based on min_wmark_pages(zone). The memory within
  * the reserve will tend to store contiguous free pages. Setting min_free_kbytes
@@ -2896,7 +2912,7 @@
 			continue;
 
 		/* Blocks with reserved pages will never free, skip them. */
-		if (PageReserved(page))
+		if (pageblock_is_reserved(pfn))
 			continue;
 
 		block_migratetype = get_pageblock_migratetype(page);
diff -Nur linux-2.6.32-orig/mm/pagewalk.c iDroid-Project-kernel_common-9e90fd2/mm/pagewalk.c
--- linux-2.6.32-orig/mm/pagewalk.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/pagewalk.c	2010-11-18 21:05:30.000000000 +0600
@@ -1,6 +1,7 @@
 #include <linux/mm.h>
 #include <linux/highmem.h>
 #include <linux/sched.h>
+#include <linux/hugetlb.h>
 
 static int walk_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,
 			  struct mm_walk *walk)
@@ -107,6 +108,7 @@
 	pgd_t *pgd;
 	unsigned long next;
 	int err = 0;
+	struct vm_area_struct *vma;
 
 	if (addr >= end)
 		return err;
@@ -117,11 +119,22 @@
 	pgd = pgd_offset(walk->mm, addr);
 	do {
 		next = pgd_addr_end(addr, end);
+
+		/* skip hugetlb vma to avoid hugepage PMD being cleared
+		 * in pmd_none_or_clear_bad(). */
+		vma = find_vma(walk->mm, addr);
+		if (vma && is_vm_hugetlb_page(vma)) {
+			if (vma->vm_end < next)
+				next = vma->vm_end;
+			continue;
+		}
+
 		if (pgd_none_or_clear_bad(pgd)) {
 			if (walk->pte_hole)
 				err = walk->pte_hole(addr, next, walk);
 			if (err)
 				break;
+			pgd++;
 			continue;
 		}
 		if (walk->pgd_entry)
@@ -131,7 +144,8 @@
 			err = walk_pud_range(pgd, addr, next, walk);
 		if (err)
 			break;
-	} while (pgd++, addr = next, addr != end);
+		pgd++;
+	} while (addr = next, addr != end);
 
 	return err;
 }
diff -Nur linux-2.6.32-orig/mm/shmem.c iDroid-Project-kernel_common-9e90fd2/mm/shmem.c
--- linux-2.6.32-orig/mm/shmem.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/shmem.c	2010-11-18 21:05:30.000000000 +0600
@@ -2674,6 +2674,14 @@
 }
 EXPORT_SYMBOL_GPL(shmem_file_setup);
 
+void shmem_set_file(struct vm_area_struct *vma, struct file *file)
+{
+	if (vma->vm_file)
+		fput(vma->vm_file);
+	vma->vm_file = file;
+	vma->vm_ops = &shmem_vm_ops;
+}
+
 /**
  * shmem_zero_setup - setup a shared anonymous mapping
  * @vma: the vma to be mmapped is prepared by do_mmap_pgoff
@@ -2686,10 +2694,6 @@
 	file = shmem_file_setup("dev/zero", size, vma->vm_flags);
 	if (IS_ERR(file))
 		return PTR_ERR(file);
-
-	if (vma->vm_file)
-		fput(vma->vm_file);
-	vma->vm_file = file;
-	vma->vm_ops = &shmem_vm_ops;
+	shmem_set_file(vma, file);
 	return 0;
 }
diff -Nur linux-2.6.32-orig/mm/truncate.c iDroid-Project-kernel_common-9e90fd2/mm/truncate.c
--- linux-2.6.32-orig/mm/truncate.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/truncate.c	2010-11-18 21:05:30.000000000 +0600
@@ -516,22 +516,20 @@
  */
 void truncate_pagecache(struct inode *inode, loff_t old, loff_t new)
 {
-	if (new < old) {
-		struct address_space *mapping = inode->i_mapping;
+	struct address_space *mapping = inode->i_mapping;
 
-		/*
-		 * unmap_mapping_range is called twice, first simply for
-		 * efficiency so that truncate_inode_pages does fewer
-		 * single-page unmaps.  However after this first call, and
-		 * before truncate_inode_pages finishes, it is possible for
-		 * private pages to be COWed, which remain after
-		 * truncate_inode_pages finishes, hence the second
-		 * unmap_mapping_range call must be made for correctness.
-		 */
-		unmap_mapping_range(mapping, new + PAGE_SIZE - 1, 0, 1);
-		truncate_inode_pages(mapping, new);
-		unmap_mapping_range(mapping, new + PAGE_SIZE - 1, 0, 1);
-	}
+	/*
+	 * unmap_mapping_range is called twice, first simply for
+	 * efficiency so that truncate_inode_pages does fewer
+	 * single-page unmaps.  However after this first call, and
+	 * before truncate_inode_pages finishes, it is possible for
+	 * private pages to be COWed, which remain after
+	 * truncate_inode_pages finishes, hence the second
+	 * unmap_mapping_range call must be made for correctness.
+	 */
+	unmap_mapping_range(mapping, new + PAGE_SIZE - 1, 0, 1);
+	truncate_inode_pages(mapping, new);
+	unmap_mapping_range(mapping, new + PAGE_SIZE - 1, 0, 1);
 }
 EXPORT_SYMBOL(truncate_pagecache);
 
diff -Nur linux-2.6.32-orig/mm/util.c iDroid-Project-kernel_common-9e90fd2/mm/util.c
--- linux-2.6.32-orig/mm/util.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/util.c	2010-11-18 21:05:30.000000000 +0600
@@ -4,6 +4,10 @@
 #include <linux/module.h>
 #include <linux/err.h>
 #include <linux/sched.h>
+#include <linux/hugetlb.h>
+#include <linux/syscalls.h>
+#include <linux/mman.h>
+#include <linux/file.h>
 #include <asm/uaccess.h>
 
 #define CREATE_TRACE_POINTS
@@ -268,6 +272,46 @@
 }
 EXPORT_SYMBOL_GPL(get_user_pages_fast);
 
+SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,
+		unsigned long, prot, unsigned long, flags,
+		unsigned long, fd, unsigned long, pgoff)
+{
+	struct file * file = NULL;
+	unsigned long retval = -EBADF;
+
+	if (!(flags & MAP_ANONYMOUS)) {
+		if (unlikely(flags & MAP_HUGETLB))
+			return -EINVAL;
+		file = fget(fd);
+		if (!file)
+			goto out;
+	} else if (flags & MAP_HUGETLB) {
+		struct user_struct *user = NULL;
+		/*
+		 * VM_NORESERVE is used because the reservations will be
+		 * taken when vm_ops->mmap() is called
+		 * A dummy user value is used because we are not locking
+		 * memory so no accounting is necessary
+		 */
+		len = ALIGN(len, huge_page_size(&default_hstate));
+		file = hugetlb_file_setup(HUGETLB_ANON_FILE, len, VM_NORESERVE,
+						&user, HUGETLB_ANONHUGE_INODE);
+		if (IS_ERR(file))
+			return PTR_ERR(file);
+	}
+
+	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
+
+	down_write(&current->mm->mmap_sem);
+	retval = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
+	up_write(&current->mm->mmap_sem);
+
+	if (file)
+		fput(file);
+out:
+	return retval;
+}
+
 /* Tracepoints definitions. */
 EXPORT_TRACEPOINT_SYMBOL(kmalloc);
 EXPORT_TRACEPOINT_SYMBOL(kmem_cache_alloc);
diff -Nur linux-2.6.32-orig/mm/vmalloc.c iDroid-Project-kernel_common-9e90fd2/mm/vmalloc.c
--- linux-2.6.32-orig/mm/vmalloc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/vmalloc.c	2010-11-18 21:05:30.000000000 +0600
@@ -509,6 +509,9 @@
 
 static atomic_t vmap_lazy_nr = ATOMIC_INIT(0);
 
+/* for per-CPU blocks */
+static void purge_fragmented_blocks_allcpus(void);
+
 /*
  * Purges all lazily-freed vmap areas.
  *
@@ -539,6 +542,9 @@
 	} else
 		spin_lock(&purge_lock);
 
+	if (sync)
+		purge_fragmented_blocks_allcpus();
+
 	rcu_read_lock();
 	list_for_each_entry_rcu(va, &vmap_area_list, list) {
 		if (va->flags & VM_LAZY_FREE) {
@@ -555,10 +561,8 @@
 	}
 	rcu_read_unlock();
 
-	if (nr) {
-		BUG_ON(nr > atomic_read(&vmap_lazy_nr));
+	if (nr)
 		atomic_sub(nr, &vmap_lazy_nr);
-	}
 
 	if (nr || force_flush)
 		flush_tlb_kernel_range(*start, *end);
@@ -669,8 +673,6 @@
 struct vmap_block_queue {
 	spinlock_t lock;
 	struct list_head free;
-	struct list_head dirty;
-	unsigned int nr_dirty;
 };
 
 struct vmap_block {
@@ -680,10 +682,9 @@
 	unsigned long free, dirty;
 	DECLARE_BITMAP(alloc_map, VMAP_BBMAP_BITS);
 	DECLARE_BITMAP(dirty_map, VMAP_BBMAP_BITS);
-	union {
-		struct list_head free_list;
-		struct rcu_head rcu_head;
-	};
+	struct list_head free_list;
+	struct rcu_head rcu_head;
+	struct list_head purge;
 };
 
 /* Queue of free and dirty vmap blocks, for allocation and flushing purposes */
@@ -759,7 +760,7 @@
 	vbq = &get_cpu_var(vmap_block_queue);
 	vb->vbq = vbq;
 	spin_lock(&vbq->lock);
-	list_add(&vb->free_list, &vbq->free);
+	list_add_rcu(&vb->free_list, &vbq->free);
 	spin_unlock(&vbq->lock);
 	put_cpu_var(vmap_cpu_blocks);
 
@@ -778,8 +779,6 @@
 	struct vmap_block *tmp;
 	unsigned long vb_idx;
 
-	BUG_ON(!list_empty(&vb->free_list));
-
 	vb_idx = addr_to_vb_idx(vb->va->va_start);
 	spin_lock(&vmap_block_tree_lock);
 	tmp = radix_tree_delete(&vmap_block_tree, vb_idx);
@@ -790,12 +789,61 @@
 	call_rcu(&vb->rcu_head, rcu_free_vb);
 }
 
+static void purge_fragmented_blocks(int cpu)
+{
+	LIST_HEAD(purge);
+	struct vmap_block *vb;
+	struct vmap_block *n_vb;
+	struct vmap_block_queue *vbq = &per_cpu(vmap_block_queue, cpu);
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(vb, &vbq->free, free_list) {
+
+		if (!(vb->free + vb->dirty == VMAP_BBMAP_BITS && vb->dirty != VMAP_BBMAP_BITS))
+			continue;
+
+		spin_lock(&vb->lock);
+		if (vb->free + vb->dirty == VMAP_BBMAP_BITS && vb->dirty != VMAP_BBMAP_BITS) {
+			vb->free = 0; /* prevent further allocs after releasing lock */
+			vb->dirty = VMAP_BBMAP_BITS; /* prevent purging it again */
+			bitmap_fill(vb->alloc_map, VMAP_BBMAP_BITS);
+			bitmap_fill(vb->dirty_map, VMAP_BBMAP_BITS);
+			spin_lock(&vbq->lock);
+			list_del_rcu(&vb->free_list);
+			spin_unlock(&vbq->lock);
+			spin_unlock(&vb->lock);
+			list_add_tail(&vb->purge, &purge);
+		} else
+			spin_unlock(&vb->lock);
+	}
+	rcu_read_unlock();
+
+	list_for_each_entry_safe(vb, n_vb, &purge, purge) {
+		list_del(&vb->purge);
+		free_vmap_block(vb);
+	}
+}
+
+static void purge_fragmented_blocks_thiscpu(void)
+{
+	purge_fragmented_blocks(smp_processor_id());
+}
+
+static void purge_fragmented_blocks_allcpus(void)
+{
+	int cpu;
+
+	for_each_possible_cpu(cpu)
+		purge_fragmented_blocks(cpu);
+}
+
 static void *vb_alloc(unsigned long size, gfp_t gfp_mask)
 {
 	struct vmap_block_queue *vbq;
 	struct vmap_block *vb;
 	unsigned long addr = 0;
 	unsigned int order;
+	int purge = 0;
 
 	BUG_ON(size & ~PAGE_MASK);
 	BUG_ON(size > PAGE_SIZE*VMAP_MAX_ALLOC);
@@ -808,24 +856,37 @@
 		int i;
 
 		spin_lock(&vb->lock);
+		if (vb->free < 1UL << order)
+			goto next;
 		i = bitmap_find_free_region(vb->alloc_map,
 						VMAP_BBMAP_BITS, order);
 
-		if (i >= 0) {
-			addr = vb->va->va_start + (i << PAGE_SHIFT);
-			BUG_ON(addr_to_vb_idx(addr) !=
-					addr_to_vb_idx(vb->va->va_start));
-			vb->free -= 1UL << order;
-			if (vb->free == 0) {
-				spin_lock(&vbq->lock);
-				list_del_init(&vb->free_list);
-				spin_unlock(&vbq->lock);
+		if (i < 0) {
+			if (vb->free + vb->dirty == VMAP_BBMAP_BITS) {
+				/* fragmented and no outstanding allocations */
+				BUG_ON(vb->dirty != VMAP_BBMAP_BITS);
+				purge = 1;
 			}
-			spin_unlock(&vb->lock);
-			break;
+			goto next;
+		}
+		addr = vb->va->va_start + (i << PAGE_SHIFT);
+		BUG_ON(addr_to_vb_idx(addr) !=
+				addr_to_vb_idx(vb->va->va_start));
+		vb->free -= 1UL << order;
+		if (vb->free == 0) {
+			spin_lock(&vbq->lock);
+			list_del_rcu(&vb->free_list);
+			spin_unlock(&vbq->lock);
 		}
 		spin_unlock(&vb->lock);
+		break;
+next:
+		spin_unlock(&vb->lock);
 	}
+
+	if (purge)
+		purge_fragmented_blocks_thiscpu();
+
 	put_cpu_var(vmap_cpu_blocks);
 	rcu_read_unlock();
 
@@ -862,11 +923,11 @@
 	BUG_ON(!vb);
 
 	spin_lock(&vb->lock);
-	bitmap_allocate_region(vb->dirty_map, offset >> PAGE_SHIFT, order);
+	BUG_ON(bitmap_allocate_region(vb->dirty_map, offset >> PAGE_SHIFT, order));
 
 	vb->dirty += 1UL << order;
 	if (vb->dirty == VMAP_BBMAP_BITS) {
-		BUG_ON(vb->free || !list_empty(&vb->free_list));
+		BUG_ON(vb->free);
 		spin_unlock(&vb->lock);
 		free_vmap_block(vb);
 	} else
@@ -1035,8 +1096,6 @@
 		vbq = &per_cpu(vmap_block_queue, i);
 		spin_lock_init(&vbq->lock);
 		INIT_LIST_HEAD(&vbq->free);
-		INIT_LIST_HEAD(&vbq->dirty);
-		vbq->nr_dirty = 0;
 	}
 
 	/* Import existing vmlist entries. */
@@ -1993,6 +2052,7 @@
 }
 EXPORT_SYMBOL_GPL(free_vm_area);
 
+#ifndef CONFIG_HAVE_LEGACY_PER_CPU_AREA
 static struct vmap_area *node_to_va(struct rb_node *n)
 {
 	return n ? rb_entry(n, struct vmap_area, rb_node) : NULL;
@@ -2257,6 +2317,7 @@
 	kfree(vms);
 	return NULL;
 }
+#endif
 
 /**
  * pcpu_free_vm_areas - free vmalloc areas for percpu allocator
diff -Nur linux-2.6.32-orig/mm/vmscan.c iDroid-Project-kernel_common-9e90fd2/mm/vmscan.c
--- linux-2.6.32-orig/mm/vmscan.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/mm/vmscan.c	2010-11-18 21:05:30.000000000 +0600
@@ -1464,20 +1464,26 @@
 	return low;
 }
 
+static int inactive_list_is_low(struct zone *zone, struct scan_control *sc,
+				int file)
+{
+	if (file)
+		return inactive_file_is_low(zone, sc);
+	else
+		return inactive_anon_is_low(zone, sc);
+}
+
 static unsigned long shrink_list(enum lru_list lru, unsigned long nr_to_scan,
 	struct zone *zone, struct scan_control *sc, int priority)
 {
 	int file = is_file_lru(lru);
 
-	if (lru == LRU_ACTIVE_FILE && inactive_file_is_low(zone, sc)) {
-		shrink_active_list(nr_to_scan, zone, sc, priority, file);
+	if (is_active_lru(lru)) {
+		if (inactive_list_is_low(zone, sc, file))
+		    shrink_active_list(nr_to_scan, zone, sc, priority, file);
 		return 0;
 	}
 
-	if (lru == LRU_ACTIVE_ANON && inactive_anon_is_low(zone, sc)) {
-		shrink_active_list(nr_to_scan, zone, sc, priority, file);
-		return 0;
-	}
 	return shrink_inactive_list(nr_to_scan, zone, sc, priority, file);
 }
 
diff -Nur linux-2.6.32-orig/net/ax25/ax25_out.c iDroid-Project-kernel_common-9e90fd2/net/ax25/ax25_out.c
--- linux-2.6.32-orig/net/ax25/ax25_out.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ax25/ax25_out.c	2010-11-18 21:05:30.000000000 +0600
@@ -92,6 +92,12 @@
 #endif
 	}
 
+	/*
+	 * There is one ref for the state machine; a caller needs
+	 * one more to put it back, just like with the existing one.
+	 */
+	ax25_cb_hold(ax25);
+
 	ax25_cb_add(ax25);
 
 	ax25->state = AX25_STATE_1;
diff -Nur linux-2.6.32-orig/net/bluetooth/af_bluetooth.c iDroid-Project-kernel_common-9e90fd2/net/bluetooth/af_bluetooth.c
--- linux-2.6.32-orig/net/bluetooth/af_bluetooth.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/bluetooth/af_bluetooth.c	2010-11-18 21:05:30.000000000 +0600
@@ -41,6 +41,15 @@
 
 #include <net/bluetooth/bluetooth.h>
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+#endif
+
+#ifndef CONFIG_BT_SOCK_DEBUG
+#undef  BT_DBG
+#define BT_DBG(D...)
+#endif
+
 #define VERSION "2.15"
 
 /* Bluetooth sockets */
@@ -126,10 +135,39 @@
 }
 EXPORT_SYMBOL(bt_sock_unregister);
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+static inline int current_has_bt_admin(void)
+{
+	return (!current_euid() || in_egroup_p(AID_NET_BT_ADMIN));
+}
+
+static inline int current_has_bt(void)
+{
+	return (current_has_bt_admin() || in_egroup_p(AID_NET_BT));
+}
+# else
+static inline int current_has_bt_admin(void)
+{
+	return 1;
+}
+
+static inline int current_has_bt(void)
+{
+	return 1;
+}
+#endif
+
 static int bt_sock_create(struct net *net, struct socket *sock, int proto)
 {
 	int err;
 
+	if (proto == BTPROTO_RFCOMM || proto == BTPROTO_SCO ||
+			proto == BTPROTO_L2CAP) {
+		if (!current_has_bt())
+			return -EPERM;
+	} else if (!current_has_bt_admin())
+		return -EPERM;
+
 	if (net != &init_net)
 		return -EAFNOSUPPORT;
 
diff -Nur linux-2.6.32-orig/net/bluetooth/hci_conn.c iDroid-Project-kernel_common-9e90fd2/net/bluetooth/hci_conn.c
--- linux-2.6.32-orig/net/bluetooth/hci_conn.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/bluetooth/hci_conn.c	2010-11-18 21:05:30.000000000 +0600
@@ -196,7 +196,8 @@
 	hci_conn_enter_sniff_mode(conn);
 }
 
-struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
+					__u16 pkt_type, bdaddr_t *dst)
 {
 	struct hci_conn *conn;
 
@@ -221,14 +222,22 @@
 		conn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;
 		break;
 	case SCO_LINK:
-		if (lmp_esco_capable(hdev))
-			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
-					(hdev->esco_type & EDR_ESCO_MASK);
-		else
-			conn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;
-		break;
+		if (!pkt_type)
+			pkt_type = SCO_ESCO_MASK;
 	case ESCO_LINK:
-		conn->pkt_type = hdev->esco_type & ~EDR_ESCO_MASK;
+		if (!pkt_type)
+			pkt_type = ALL_ESCO_MASK;
+		if (lmp_esco_capable(hdev)) {
+			/* HCI Setup Synchronous Connection Command uses
+			   reverse logic on the EDR_ESCO_MASK bits */
+			conn->pkt_type = (pkt_type ^ EDR_ESCO_MASK) &
+					hdev->esco_type;
+		} else {
+			/* Legacy HCI Add Sco Connection Command uses a
+			   shifted bitmask */
+			conn->pkt_type = (pkt_type << 5) & hdev->pkt_type &
+					SCO_PTYPE_MASK;
+		}
 		break;
 	}
 
@@ -340,7 +349,9 @@
 
 /* Create SCO or ACL connection.
  * Device _must_ be locked */
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type)
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
+					__u16 pkt_type, bdaddr_t *dst,
+					__u8 sec_level, __u8 auth_type)
 {
 	struct hci_conn *acl;
 	struct hci_conn *sco;
@@ -348,7 +359,7 @@
 	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
 	if (!(acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst))) {
-		if (!(acl = hci_conn_add(hdev, ACL_LINK, dst)))
+		if (!(acl = hci_conn_add(hdev, ACL_LINK, 0, dst)))
 			return NULL;
 	}
 
@@ -364,7 +375,7 @@
 		return acl;
 
 	if (!(sco = hci_conn_hash_lookup_ba(hdev, type, dst))) {
-		if (!(sco = hci_conn_add(hdev, type, dst))) {
+		if (!(sco = hci_conn_add(hdev, type, pkt_type, dst))) {
 			hci_conn_put(acl);
 			return NULL;
 		}
@@ -377,6 +388,9 @@
 
 	if (acl->state == BT_CONNECTED &&
 			(sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
+		acl->power_save = 1;
+		hci_conn_enter_active_mode(acl);
+
 		if (lmp_esco_capable(hdev))
 			hci_setup_sync(sco, acl->handle);
 		else
@@ -497,7 +511,7 @@
 	if (test_bit(HCI_RAW, &hdev->flags))
 		return;
 
-	if (conn->mode != HCI_CM_SNIFF || !conn->power_save)
+	if (conn->mode != HCI_CM_SNIFF /* || !conn->power_save */)
 		goto timer;
 
 	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
@@ -636,6 +650,15 @@
 		(ci + n)->out   = c->out;
 		(ci + n)->state = c->state;
 		(ci + n)->link_mode = c->link_mode;
+		if (c->type == SCO_LINK) {
+			(ci + n)->mtu = hdev->sco_mtu;
+			(ci + n)->cnt = hdev->sco_cnt;
+			(ci + n)->pkts = hdev->sco_pkts;
+		} else {
+			(ci + n)->mtu = hdev->acl_mtu;
+			(ci + n)->cnt = hdev->acl_cnt;
+			(ci + n)->pkts = hdev->acl_pkts;
+		}
 		if (++n >= req.conn_num)
 			break;
 	}
@@ -672,6 +695,15 @@
 		ci.out   = conn->out;
 		ci.state = conn->state;
 		ci.link_mode = conn->link_mode;
+		if (req.type == SCO_LINK) {
+			ci.mtu = hdev->sco_mtu;
+			ci.cnt = hdev->sco_cnt;
+			ci.pkts = hdev->sco_pkts;
+		} else {
+			ci.mtu = hdev->acl_mtu;
+			ci.cnt = hdev->acl_cnt;
+			ci.pkts = hdev->acl_pkts;
+		}
 	}
 	hci_dev_unlock_bh(hdev);
 
diff -Nur linux-2.6.32-orig/net/bluetooth/hci_core.c iDroid-Project-kernel_common-9e90fd2/net/bluetooth/hci_core.c
--- linux-2.6.32-orig/net/bluetooth/hci_core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/bluetooth/hci_core.c	2010-11-18 21:05:30.000000000 +0600
@@ -1239,7 +1239,7 @@
 
 	skb->dev = (void *) hdev;
 	bt_cb(skb)->pkt_type = HCI_ACLDATA_PKT;
-	hci_add_acl_hdr(skb, conn->handle, flags | ACL_START);
+	hci_add_acl_hdr(skb, conn->handle, flags);
 
 	if (!(list = skb_shinfo(skb)->frag_list)) {
 		/* Non fragmented */
@@ -1256,12 +1256,14 @@
 		spin_lock_bh(&conn->data_q.lock);
 
 		__skb_queue_tail(&conn->data_q, skb);
+		flags &= ~ACL_PB_MASK;
+		flags |= ACL_CONT;
 		do {
 			skb = list; list = list->next;
 
 			skb->dev = (void *) hdev;
 			bt_cb(skb)->pkt_type = HCI_ACLDATA_PKT;
-			hci_add_acl_hdr(skb, conn->handle, flags | ACL_CONT);
+			hci_add_acl_hdr(skb, conn->handle, flags);
 
 			BT_DBG("%s frag %p len %d", hdev->name, skb, skb->len);
 
diff -Nur linux-2.6.32-orig/net/bluetooth/hci_event.c iDroid-Project-kernel_common-9e90fd2/net/bluetooth/hci_event.c
--- linux-2.6.32-orig/net/bluetooth/hci_event.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/bluetooth/hci_event.c	2010-11-18 21:05:30.000000000 +0600
@@ -579,7 +579,7 @@
 		}
 	} else {
 		if (!conn) {
-			conn = hci_conn_add(hdev, ACL_LINK, &cp->bdaddr);
+			conn = hci_conn_add(hdev, ACL_LINK, 0, &cp->bdaddr);
 			if (conn) {
 				conn->out = 1;
 				conn->link_mode |= HCI_LM_MASTER;
@@ -964,7 +964,9 @@
 
 		conn = hci_conn_hash_lookup_ba(hdev, ev->link_type, &ev->bdaddr);
 		if (!conn) {
-			if (!(conn = hci_conn_add(hdev, ev->link_type, &ev->bdaddr))) {
+			/* pkt_type not yet used for incoming connections */
+			if (!(conn = hci_conn_add(hdev, ev->link_type, 0,
+							&ev->bdaddr))) {
 				BT_ERR("No memmory for new connection");
 				hci_dev_unlock(hdev);
 				return;
@@ -1698,7 +1700,9 @@
 		hci_conn_add_sysfs(conn);
 		break;
 
+	case 0x10:	/* Connection Accept Timeout */
 	case 0x1c:	/* SCO interval rejected */
+	case 0x1a:	/* unsupported feature */
 	case 0x1f:	/* Unspecified error */
 		if (conn->out && conn->attempt < 2) {
 			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
diff -Nur linux-2.6.32-orig/net/bluetooth/l2cap.c iDroid-Project-kernel_common-9e90fd2/net/bluetooth/l2cap.c
--- linux-2.6.32-orig/net/bluetooth/l2cap.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/bluetooth/l2cap.c	2010-11-18 21:05:30.000000000 +0600
@@ -325,13 +325,19 @@
 static inline int l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data)
 {
 	struct sk_buff *skb = l2cap_build_cmd(conn, code, ident, len, data);
+	u8 flags;
 
 	BT_DBG("code 0x%2.2x", code);
 
 	if (!skb)
 		return -ENOMEM;
 
-	return hci_send_acl(conn->hcon, skb, 0);
+	if (lmp_no_flush_capable(conn->hcon->hdev))
+		flags = ACL_START_NO_FLUSH;
+	else
+		flags = ACL_START;
+
+	return hci_send_acl(conn->hcon, skb, flags);
 }
 
 static inline int l2cap_send_sframe(struct l2cap_pinfo *pi, u16 control)
@@ -458,7 +464,8 @@
 					struct sock *parent = bt_sk(sk)->parent;
 					rsp.result = cpu_to_le16(L2CAP_CR_PEND);
 					rsp.status = cpu_to_le16(L2CAP_CS_AUTHOR_PEND);
-					parent->sk_data_ready(parent, 0);
+					if (parent)
+						parent->sk_data_ready(parent, 0);
 
 				} else {
 					sk->sk_state = BT_CONFIG;
@@ -770,6 +777,7 @@
 		pi->sec_level = l2cap_pi(parent)->sec_level;
 		pi->role_switch = l2cap_pi(parent)->role_switch;
 		pi->force_reliable = l2cap_pi(parent)->force_reliable;
+		pi->flushable = l2cap_pi(parent)->flushable;
 	} else {
 		pi->imtu = L2CAP_DEFAULT_MTU;
 		pi->omtu = 0;
@@ -778,6 +786,7 @@
 		pi->sec_level = BT_SECURITY_LOW;
 		pi->role_switch = 0;
 		pi->force_reliable = 0;
+		pi->flushable = 0;
 	}
 
 	/* Default config options */
@@ -953,7 +962,7 @@
 		}
 	}
 
-	hcon = hci_connect(hdev, ACL_LINK, dst,
+	hcon = hci_connect(hdev, ACL_LINK, 0, dst,
 					l2cap_pi(sk)->sec_level, auth_type);
 	if (!hcon)
 		goto done;
@@ -1258,11 +1267,18 @@
 static inline int l2cap_do_send(struct sock *sk, struct sk_buff *skb)
 {
 	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct hci_conn *hcon = pi->conn->hcon;
 	int err;
+	u16 flags;
 
 	BT_DBG("sk %p, skb %p len %d", sk, skb, skb->len);
 
-	err = hci_send_acl(pi->conn->hcon, skb, 0);
+	if (lmp_no_flush_capable(hcon->hdev) && !l2cap_pi(sk)->flushable)
+		flags = ACL_START_NO_FLUSH;
+	else
+		flags = ACL_START;
+
+	err = hci_send_acl(hcon, skb, flags);
 	if (err < 0)
 		kfree_skb(skb);
 
@@ -1747,6 +1763,7 @@
 
 		l2cap_pi(sk)->role_switch    = (opt & L2CAP_LM_MASTER);
 		l2cap_pi(sk)->force_reliable = (opt & L2CAP_LM_RELIABLE);
+		l2cap_pi(sk)->flushable = (opt & L2CAP_LM_FLUSHABLE);
 		break;
 
 	default:
@@ -1874,6 +1891,9 @@
 		if (l2cap_pi(sk)->force_reliable)
 			opt |= L2CAP_LM_RELIABLE;
 
+		if (l2cap_pi(sk)->flushable)
+			opt |= L2CAP_LM_FLUSHABLE;
+
 		if (put_user(opt, (u32 __user *) optval))
 			err = -EFAULT;
 		break;
@@ -3801,7 +3821,7 @@
 
 	BT_DBG("conn %p len %d flags 0x%x", conn, skb->len, flags);
 
-	if (flags & ACL_START) {
+	if (!(flags & ACL_CONT)) {
 		struct l2cap_hdr *hdr;
 		int len;
 
diff -Nur linux-2.6.32-orig/net/bluetooth/rfcomm/core.c iDroid-Project-kernel_common-9e90fd2/net/bluetooth/rfcomm/core.c
--- linux-2.6.32-orig/net/bluetooth/rfcomm/core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/bluetooth/rfcomm/core.c	2010-11-18 21:05:30.000000000 +0600
@@ -244,33 +244,6 @@
 								auth_type);
 }
 
-static void rfcomm_session_timeout(unsigned long arg)
-{
-	struct rfcomm_session *s = (void *) arg;
-
-	BT_DBG("session %p state %ld", s, s->state);
-
-	set_bit(RFCOMM_TIMED_OUT, &s->flags);
-	rfcomm_session_put(s);
-	rfcomm_schedule(RFCOMM_SCHED_TIMEO);
-}
-
-static void rfcomm_session_set_timer(struct rfcomm_session *s, long timeout)
-{
-	BT_DBG("session %p state %ld timeout %ld", s, s->state, timeout);
-
-	if (!mod_timer(&s->timer, jiffies + timeout))
-		rfcomm_session_hold(s);
-}
-
-static void rfcomm_session_clear_timer(struct rfcomm_session *s)
-{
-	BT_DBG("session %p state %ld", s, s->state);
-
-	if (timer_pending(&s->timer) && del_timer(&s->timer))
-		rfcomm_session_put(s);
-}
-
 /* ---- RFCOMM DLCs ---- */
 static void rfcomm_dlc_timeout(unsigned long arg)
 {
@@ -347,7 +320,6 @@
 
 	rfcomm_session_hold(s);
 
-	rfcomm_session_clear_timer(s);
 	rfcomm_dlc_hold(d);
 	list_add(&d->list, &s->dlcs);
 	d->session = s;
@@ -363,9 +335,6 @@
 	d->session = NULL;
 	rfcomm_dlc_put(d);
 
-	if (list_empty(&s->dlcs))
-		rfcomm_session_set_timer(s, RFCOMM_IDLE_TIMEOUT);
-
 	rfcomm_session_put(s);
 }
 
@@ -459,7 +428,6 @@
 
 	switch (d->state) {
 	case BT_CONNECT:
-	case BT_CONFIG:
 		if (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {
 			set_bit(RFCOMM_AUTH_REJECT, &d->flags);
 			rfcomm_schedule(RFCOMM_SCHED_AUTH);
@@ -479,7 +447,6 @@
 		break;
 
 	case BT_OPEN:
-	case BT_CONNECT2:
 		if (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {
 			set_bit(RFCOMM_AUTH_REJECT, &d->flags);
 			rfcomm_schedule(RFCOMM_SCHED_AUTH);
@@ -598,8 +565,6 @@
 
 	BT_DBG("session %p sock %p", s, sock);
 
-	setup_timer(&s->timer, rfcomm_session_timeout, (unsigned long) s);
-
 	INIT_LIST_HEAD(&s->dlcs);
 	s->state = state;
 	s->sock  = sock;
@@ -631,7 +596,6 @@
 	if (state == BT_CONNECTED)
 		rfcomm_send_disc(s, 0);
 
-	rfcomm_session_clear_timer(s);
 	sock_release(s->sock);
 	kfree(s);
 
@@ -673,7 +637,6 @@
 		__rfcomm_dlc_close(d, err);
 	}
 
-	rfcomm_session_clear_timer(s);
 	rfcomm_session_put(s);
 }
 
@@ -1148,7 +1111,8 @@
 			break;
 
 		case BT_DISCONN:
-			rfcomm_session_put(s);
+			if (s->sock->sk->sk_state != BT_CLOSED)
+				rfcomm_session_put(s);
 			break;
 		}
 	}
@@ -1229,8 +1193,6 @@
 
 	rfcomm_send_ua(d->session, d->dlci);
 
-	rfcomm_dlc_clear_timer(d);
-
 	rfcomm_dlc_lock(d);
 	d->state = BT_CONNECTED;
 	d->state_change(d, 0);
@@ -1248,11 +1210,6 @@
 		if (d->defer_setup) {
 			set_bit(RFCOMM_DEFER_SETUP, &d->flags);
 			rfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);
-
-			rfcomm_dlc_lock(d);
-			d->state = BT_CONNECT2;
-			d->state_change(d, 0);
-			rfcomm_dlc_unlock(d);
 		} else
 			rfcomm_dlc_accept(d);
 	} else {
@@ -1794,11 +1751,6 @@
 				if (d->defer_setup) {
 					set_bit(RFCOMM_DEFER_SETUP, &d->flags);
 					rfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);
-
-					rfcomm_dlc_lock(d);
-					d->state = BT_CONNECT2;
-					d->state_change(d, 0);
-					rfcomm_dlc_unlock(d);
 				} else
 					rfcomm_dlc_accept(d);
 			}
@@ -1914,12 +1866,6 @@
 		struct rfcomm_session *s;
 		s = list_entry(p, struct rfcomm_session, list);
 
-		if (test_and_clear_bit(RFCOMM_TIMED_OUT, &s->flags)) {
-			s->state = BT_DISCONN;
-			rfcomm_send_disc(s, 0);
-			continue;
-		}
-
 		if (s->state == BT_LISTEN) {
 			rfcomm_accept_connection(s);
 			continue;
diff -Nur linux-2.6.32-orig/net/bluetooth/sco.c iDroid-Project-kernel_common-9e90fd2/net/bluetooth/sco.c
--- linux-2.6.32-orig/net/bluetooth/sco.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/bluetooth/sco.c	2010-11-18 21:05:30.000000000 +0600
@@ -176,6 +176,7 @@
 {
 	bdaddr_t *src = &bt_sk(sk)->src;
 	bdaddr_t *dst = &bt_sk(sk)->dst;
+	__u16 pkt_type = sco_pi(sk)->pkt_type;
 	struct sco_conn *conn;
 	struct hci_conn *hcon;
 	struct hci_dev  *hdev;
@@ -192,10 +193,13 @@
 
 	if (lmp_esco_capable(hdev) && !disable_esco)
 		type = ESCO_LINK;
-	else
+	else {
 		type = SCO_LINK;
+		pkt_type &= SCO_ESCO_MASK;
+	}
 
-	hcon = hci_connect(hdev, type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);
+	hcon = hci_connect(hdev, type, pkt_type, dst,
+					BT_SECURITY_LOW, HCI_AT_NO_BONDING);
 	if (!hcon)
 		goto done;
 
@@ -451,18 +455,22 @@
 	return 0;
 }
 
-static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
+static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 {
-	struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
+	struct sockaddr_sco sa;
 	struct sock *sk = sock->sk;
-	bdaddr_t *src = &sa->sco_bdaddr;
-	int err = 0;
+	bdaddr_t *src = &sa.sco_bdaddr;
+	int len, err = 0;
 
-	BT_DBG("sk %p %s", sk, batostr(&sa->sco_bdaddr));
+	BT_DBG("sk %p %s", sk, batostr(&sa.sco_bdaddr));
 
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
+	memset(&sa, 0, sizeof(sa));
+	len = min_t(unsigned int, sizeof(sa), alen);
+	memcpy(&sa, addr, len);
+
 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {
@@ -476,7 +484,8 @@
 		err = -EADDRINUSE;
 	} else {
 		/* Save source address */
-		bacpy(&bt_sk(sk)->src, &sa->sco_bdaddr);
+		bacpy(&bt_sk(sk)->src, &sa.sco_bdaddr);
+		sco_pi(sk)->pkt_type = sa.sco_pkt_type;
 		sk->sk_state = BT_BOUND;
 	}
 
@@ -489,26 +498,34 @@
 
 static int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)
 {
-	struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
 	struct sock *sk = sock->sk;
-	int err = 0;
-
+	struct sockaddr_sco sa;
+	int len, err = 0;
 
 	BT_DBG("sk %p", sk);
 
-	if (addr->sa_family != AF_BLUETOOTH || alen < sizeof(struct sockaddr_sco))
+	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
-	if (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)
-		return -EBADFD;
-
-	if (sk->sk_type != SOCK_SEQPACKET)
-		return -EINVAL;
+	memset(&sa, 0, sizeof(sa));
+	len = min_t(unsigned int, sizeof(sa), alen);
+	memcpy(&sa, addr, len);
 
 	lock_sock(sk);
 
+	if (sk->sk_type != SOCK_SEQPACKET) {
+		err = -EINVAL;
+		goto done;
+	}
+
+	if (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND) {
+		err = -EBADFD;
+		goto done;
+	}
+
 	/* Set destination address and psm */
-	bacpy(&bt_sk(sk)->dst, &sa->sco_bdaddr);
+	bacpy(&bt_sk(sk)->dst, &sa.sco_bdaddr);
+	sco_pi(sk)->pkt_type = sa.sco_pkt_type;
 
 	if ((err = sco_connect(sk)))
 		goto done;
@@ -614,6 +631,7 @@
 		bacpy(&sa->sco_bdaddr, &bt_sk(sk)->dst);
 	else
 		bacpy(&sa->sco_bdaddr, &bt_sk(sk)->src);
+	sa->sco_pkt_type = sco_pi(sk)->pkt_type;
 
 	return 0;
 }
diff -Nur linux-2.6.32-orig/net/bridge/netfilter/ebtables.c iDroid-Project-kernel_common-9e90fd2/net/bridge/netfilter/ebtables.c
--- linux-2.6.32-orig/net/bridge/netfilter/ebtables.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/bridge/netfilter/ebtables.c	2010-11-18 21:05:30.000000000 +0600
@@ -1406,6 +1406,9 @@
 {
 	int ret;
 
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
 	switch(cmd) {
 	case EBT_SO_SET_ENTRIES:
 		ret = do_replace(sock_net(sk), user, len);
@@ -1425,6 +1428,9 @@
 	struct ebt_replace tmp;
 	struct ebt_table *t;
 
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
 	if (copy_from_user(&tmp, user, sizeof(tmp)))
 		return -EFAULT;
 
diff -Nur linux-2.6.32-orig/net/core/dev.c iDroid-Project-kernel_common-9e90fd2/net/core/dev.c
--- linux-2.6.32-orig/net/core/dev.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/core/dev.c	2010-11-18 21:05:30.000000000 +0600
@@ -4860,6 +4860,11 @@
 		rollback_registered(dev);
 		dev->reg_state = NETREG_UNREGISTERED;
 	}
+	/*
+	 *	Prevent userspace races by waiting until the network
+	 *	device is fully setup before sending notifications.
+	 */
+	rtmsg_ifinfo(RTM_NEWLINK, dev, ~0U);
 
 out:
 	return ret;
@@ -5398,6 +5403,12 @@
 	/* Notify protocols, that a new device appeared. */
 	call_netdevice_notifiers(NETDEV_REGISTER, dev);
 
+	/*
+	 *	Prevent userspace races by waiting until the network
+	 *	device is fully setup before sending notifications.
+	 */
+	rtmsg_ifinfo(RTM_NEWLINK, dev, ~0U);
+
 	synchronize_net();
 	err = 0;
 out:
diff -Nur linux-2.6.32-orig/net/core/dst.c iDroid-Project-kernel_common-9e90fd2/net/core/dst.c
--- linux-2.6.32-orig/net/core/dst.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/core/dst.c	2010-11-18 21:05:30.000000000 +0600
@@ -17,6 +17,7 @@
 #include <linux/string.h>
 #include <linux/types.h>
 #include <net/net_namespace.h>
+#include <linux/sched.h>
 
 #include <net/dst.h>
 
@@ -79,6 +80,7 @@
 	while ((dst = next) != NULL) {
 		next = dst->next;
 		prefetch(&next->next);
+		cond_resched();
 		if (likely(atomic_read(&dst->__refcnt))) {
 			last->next = dst;
 			last = dst;
diff -Nur linux-2.6.32-orig/net/core/pktgen.c iDroid-Project-kernel_common-9e90fd2/net/core/pktgen.c
--- linux-2.6.32-orig/net/core/pktgen.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/core/pktgen.c	2010-11-18 21:05:30.000000000 +0600
@@ -3516,6 +3516,7 @@
 			wait_event_interruptible_timeout(t->queue,
 							 t->control != 0,
 							 HZ/10);
+			try_to_freeze();
 			continue;
 		}
 
diff -Nur linux-2.6.32-orig/net/core/rtnetlink.c iDroid-Project-kernel_common-9e90fd2/net/core/rtnetlink.c
--- linux-2.6.32-orig/net/core/rtnetlink.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/core/rtnetlink.c	2010-11-18 21:05:30.000000000 +0600
@@ -1334,13 +1334,11 @@
 	case NETDEV_UNREGISTER:
 		rtmsg_ifinfo(RTM_DELLINK, dev, ~0U);
 		break;
-	case NETDEV_REGISTER:
-		rtmsg_ifinfo(RTM_NEWLINK, dev, ~0U);
-		break;
 	case NETDEV_UP:
 	case NETDEV_DOWN:
 		rtmsg_ifinfo(RTM_NEWLINK, dev, IFF_UP|IFF_RUNNING);
 		break;
+	case NETDEV_REGISTER:
 	case NETDEV_CHANGE:
 	case NETDEV_GOING_DOWN:
 		break;
diff -Nur linux-2.6.32-orig/net/core/sock.c iDroid-Project-kernel_common-9e90fd2/net/core/sock.c
--- linux-2.6.32-orig/net/core/sock.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/core/sock.c	2010-11-18 21:05:30.000000000 +0600
@@ -1181,6 +1181,10 @@
 
 		if (newsk->sk_prot->sockets_allocated)
 			percpu_counter_inc(newsk->sk_prot->sockets_allocated);
+
+		if (sock_flag(newsk, SOCK_TIMESTAMP) ||
+		    sock_flag(newsk, SOCK_TIMESTAMPING_RX_SOFTWARE))
+			net_enable_timestamp();
 	}
 out:
 	return newsk;
diff -Nur linux-2.6.32-orig/net/ipv4/af_inet.c iDroid-Project-kernel_common-9e90fd2/net/ipv4/af_inet.c
--- linux-2.6.32-orig/net/ipv4/af_inet.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/af_inet.c	2010-11-18 21:05:30.000000000 +0600
@@ -116,6 +116,19 @@
 #include <linux/mroute.h>
 #endif
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+
+static inline int current_has_network(void)
+{
+	return in_egroup_p(AID_INET) || capable(CAP_NET_RAW);
+}
+#else
+static inline int current_has_network(void)
+{
+	return 1;
+}
+#endif
 
 /* The inetsw table contains everything that inet_create needs to
  * build a new socket.
@@ -258,6 +271,7 @@
 	return ipprot->netns_ok;
 }
 
+
 /*
  *	Create an inet socket.
  */
@@ -273,6 +287,9 @@
 	int try_loading_module = 0;
 	int err;
 
+	if (!current_has_network())
+		return -EACCES;
+
 	if (unlikely(!inet_ehash_secret))
 		if (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)
 			build_ehash_secret();
@@ -836,6 +853,7 @@
 	case SIOCSIFPFLAGS:
 	case SIOCGIFPFLAGS:
 	case SIOCSIFFLAGS:
+	case SIOCKILLADDR:
 		err = devinet_ioctl(net, cmd, (void __user *)arg);
 		break;
 	default:
diff -Nur linux-2.6.32-orig/net/ipv4/devinet.c iDroid-Project-kernel_common-9e90fd2/net/ipv4/devinet.c
--- linux-2.6.32-orig/net/ipv4/devinet.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/devinet.c	2010-11-18 21:05:30.000000000 +0600
@@ -57,6 +57,7 @@
 
 #include <net/arp.h>
 #include <net/ip.h>
+#include <net/tcp.h>
 #include <net/route.h>
 #include <net/ip_fib.h>
 #include <net/rtnetlink.h>
@@ -631,6 +632,7 @@
 	case SIOCSIFBRDADDR:	/* Set the broadcast address */
 	case SIOCSIFDSTADDR:	/* Set the destination address */
 	case SIOCSIFNETMASK: 	/* Set the netmask for the interface */
+	case SIOCKILLADDR:	/* Nuke all sockets on this address */
 		ret = -EACCES;
 		if (!capable(CAP_NET_ADMIN))
 			goto out;
@@ -680,7 +682,8 @@
 	}
 
 	ret = -EADDRNOTAVAIL;
-	if (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS)
+	if (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS
+	    && cmd != SIOCKILLADDR)
 		goto done;
 
 	switch (cmd) {
@@ -804,6 +807,10 @@
 			inet_insert_ifa(ifa);
 		}
 		break;
+	case SIOCKILLADDR:	/* Nuke all connections on this address */
+		ret = 0;
+		tcp_v4_nuke_addr(sin->sin_addr.s_addr);
+		break;
 	}
 done:
 	rtnl_unlock();
@@ -1450,6 +1457,7 @@
 		DEVINET_SYSCTL_RW_ENTRY(SEND_REDIRECTS, "send_redirects"),
 		DEVINET_SYSCTL_RW_ENTRY(ACCEPT_SOURCE_ROUTE,
 					"accept_source_route"),
+		DEVINET_SYSCTL_RW_ENTRY(SRC_VMARK, "src_valid_mark"),
 		DEVINET_SYSCTL_RW_ENTRY(PROXY_ARP, "proxy_arp"),
 		DEVINET_SYSCTL_RW_ENTRY(MEDIUM_ID, "medium_id"),
 		DEVINET_SYSCTL_RW_ENTRY(BOOTP_RELAY, "bootp_relay"),
diff -Nur linux-2.6.32-orig/net/ipv4/fib_frontend.c iDroid-Project-kernel_common-9e90fd2/net/ipv4/fib_frontend.c
--- linux-2.6.32-orig/net/ipv4/fib_frontend.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/fib_frontend.c	2010-11-18 21:05:30.000000000 +0600
@@ -251,6 +251,8 @@
 	if (in_dev) {
 		no_addr = in_dev->ifa_list == NULL;
 		rpf = IN_DEV_RPFILTER(in_dev);
+		if (mark && !IN_DEV_SRC_VMARK(in_dev))
+			fl.mark = 0;
 	}
 	rcu_read_unlock();
 
diff -Nur linux-2.6.32-orig/net/ipv4/ip_output.c iDroid-Project-kernel_common-9e90fd2/net/ipv4/ip_output.c
--- linux-2.6.32-orig/net/ipv4/ip_output.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/ip_output.c	2010-11-18 21:05:30.000000000 +0600
@@ -501,8 +501,8 @@
 			if (skb->sk) {
 				frag->sk = skb->sk;
 				frag->destructor = sock_wfree;
-				truesizes += frag->truesize;
 			}
+			truesizes += frag->truesize;
 		}
 
 		/* Everything is OK. Generate! */
diff -Nur linux-2.6.32-orig/net/ipv4/Makefile iDroid-Project-kernel_common-9e90fd2/net/ipv4/Makefile
--- linux-2.6.32-orig/net/ipv4/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -14,6 +14,7 @@
 	     inet_fragment.o
 
 obj-$(CONFIG_SYSCTL) += sysctl_net_ipv4.o
+obj-$(CONFIG_SYSFS) += sysfs_net_ipv4.o
 obj-$(CONFIG_IP_FIB_HASH) += fib_hash.o
 obj-$(CONFIG_IP_FIB_TRIE) += fib_trie.o
 obj-$(CONFIG_PROC_FS) += proc.o
diff -Nur linux-2.6.32-orig/net/ipv4/netfilter/arp_tables.c iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/arp_tables.c
--- linux-2.6.32-orig/net/ipv4/netfilter/arp_tables.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/arp_tables.c	2010-11-18 21:05:30.000000000 +0600
@@ -925,10 +925,10 @@
 	if (t && !IS_ERR(t)) {
 		struct arpt_getinfo info;
 		const struct xt_table_info *private = t->private;
-
 #ifdef CONFIG_COMPAT
+		struct xt_table_info tmp;
+
 		if (compat) {
-			struct xt_table_info tmp;
 			ret = compat_table_info(private, &tmp);
 			xt_compat_flush_offsets(NFPROTO_ARP);
 			private = &tmp;
diff -Nur linux-2.6.32-orig/net/ipv4/netfilter/ip_tables.c iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/ip_tables.c
--- linux-2.6.32-orig/net/ipv4/netfilter/ip_tables.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/ip_tables.c	2010-11-18 21:05:30.000000000 +0600
@@ -1132,10 +1132,10 @@
 	if (t && !IS_ERR(t)) {
 		struct ipt_getinfo info;
 		const struct xt_table_info *private = t->private;
-
 #ifdef CONFIG_COMPAT
+		struct xt_table_info tmp;
+
 		if (compat) {
-			struct xt_table_info tmp;
 			ret = compat_table_info(private, &tmp);
 			xt_compat_flush_offsets(AF_INET);
 			private = &tmp;
diff -Nur linux-2.6.32-orig/net/ipv4/netfilter/ipt_ECN.c iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/ipt_ECN.c
--- linux-2.6.32-orig/net/ipv4/netfilter/ipt_ECN.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/ipt_ECN.c	2010-11-18 21:05:30.000000000 +0600
@@ -1,141 +1,129 @@
-/* iptables module for the IPv4 and TCP ECN bits, Version 1.5
+/* IP tables module for matching the value of the IPv4 and TCP ECN bits
  *
- * (C) 2002 by Harald Welte <laforge@netfilter.org>
+ * (C) 2002 by Harald Welte <laforge@gnumonks.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
-*/
+ */
 
 #include <linux/in.h>
-#include <linux/module.h>
-#include <linux/skbuff.h>
 #include <linux/ip.h>
 #include <net/ip.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
 #include <linux/tcp.h>
-#include <net/checksum.h>
 
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
-#include <linux/netfilter_ipv4/ipt_ECN.h>
+#include <linux/netfilter_ipv4/ipt_ecn.h>
 
-MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Harald Welte <laforge@netfilter.org>");
-MODULE_DESCRIPTION("Xtables: Explicit Congestion Notification (ECN) flag modification");
+MODULE_DESCRIPTION("Xtables: Explicit Congestion Notification (ECN) flag match for IPv4");
+MODULE_LICENSE("GPL");
 
-/* set ECT codepoint from IP header.
- * 	return false if there was an error. */
-static inline bool
-set_ect_ip(struct sk_buff *skb, const struct ipt_ECN_info *einfo)
-{
-	struct iphdr *iph = ip_hdr(skb);
-
-	if ((iph->tos & IPT_ECN_IP_MASK) != (einfo->ip_ect & IPT_ECN_IP_MASK)) {
-		__u8 oldtos;
-		if (!skb_make_writable(skb, sizeof(struct iphdr)))
-			return false;
-		iph = ip_hdr(skb);
-		oldtos = iph->tos;
-		iph->tos &= ~IPT_ECN_IP_MASK;
-		iph->tos |= (einfo->ip_ect & IPT_ECN_IP_MASK);
-		csum_replace2(&iph->check, htons(oldtos), htons(iph->tos));
-	}
-	return true;
+static inline bool match_ip(const struct sk_buff *skb,
+			    const struct ipt_ecn_info *einfo)
+{
+	return (ip_hdr(skb)->tos & IPT_ECN_IP_MASK) == einfo->ip_ect;
 }
 
-/* Return false if there was an error. */
-static inline bool
-set_ect_tcp(struct sk_buff *skb, const struct ipt_ECN_info *einfo)
-{
-	struct tcphdr _tcph, *tcph;
-	__be16 oldval;
-
-	/* Not enought header? */
-	tcph = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(_tcph), &_tcph);
-	if (!tcph)
-		return false;
-
-	if ((!(einfo->operation & IPT_ECN_OP_SET_ECE) ||
-	     tcph->ece == einfo->proto.tcp.ece) &&
-	    (!(einfo->operation & IPT_ECN_OP_SET_CWR) ||
-	     tcph->cwr == einfo->proto.tcp.cwr))
-		return true;
+static inline bool match_tcp(const struct sk_buff *skb,
+			     const struct ipt_ecn_info *einfo,
+			     bool *hotdrop)
+{
+	struct tcphdr _tcph;
+	const struct tcphdr *th;
 
-	if (!skb_make_writable(skb, ip_hdrlen(skb) + sizeof(*tcph)))
+	/* In practice, TCP match does this, so can't fail.  But let's
+	 * be good citizens.
+	 */
+	th = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(_tcph), &_tcph);
+	if (th == NULL) {
+		*hotdrop = false;
 		return false;
-	tcph = (void *)ip_hdr(skb) + ip_hdrlen(skb);
+	}
 
-	oldval = ((__be16 *)tcph)[6];
-	if (einfo->operation & IPT_ECN_OP_SET_ECE)
-		tcph->ece = einfo->proto.tcp.ece;
-	if (einfo->operation & IPT_ECN_OP_SET_CWR)
-		tcph->cwr = einfo->proto.tcp.cwr;
+	if (einfo->operation & IPT_ECN_OP_MATCH_ECE) {
+		if (einfo->invert & IPT_ECN_OP_MATCH_ECE) {
+			if (th->ece == 1)
+				return false;
+		} else {
+			if (th->ece == 0)
+				return false;
+		}
+	}
+
+	if (einfo->operation & IPT_ECN_OP_MATCH_CWR) {
+		if (einfo->invert & IPT_ECN_OP_MATCH_CWR) {
+			if (th->cwr == 1)
+				return false;
+		} else {
+			if (th->cwr == 0)
+				return false;
+		}
+	}
 
-	inet_proto_csum_replace2(&tcph->check, skb,
-				 oldval, ((__be16 *)tcph)[6], 0);
 	return true;
 }
 
-static unsigned int
-ecn_tg(struct sk_buff *skb, const struct xt_target_param *par)
+static bool ecn_mt(const struct sk_buff *skb, const struct xt_match_param *par)
 {
-	const struct ipt_ECN_info *einfo = par->targinfo;
+	const struct ipt_ecn_info *info = par->matchinfo;
 
-	if (einfo->operation & IPT_ECN_OP_SET_IP)
-		if (!set_ect_ip(skb, einfo))
-			return NF_DROP;
+	if (info->operation & IPT_ECN_OP_MATCH_IP)
+		if (!match_ip(skb, info))
+			return false;
 
-	if (einfo->operation & (IPT_ECN_OP_SET_ECE | IPT_ECN_OP_SET_CWR)
-	    && ip_hdr(skb)->protocol == IPPROTO_TCP)
-		if (!set_ect_tcp(skb, einfo))
-			return NF_DROP;
+	if (info->operation & (IPT_ECN_OP_MATCH_ECE|IPT_ECN_OP_MATCH_CWR)) {
+		if (ip_hdr(skb)->protocol != IPPROTO_TCP)
+			return false;
+		if (!match_tcp(skb, info, par->hotdrop))
+			return false;
+	}
 
-	return XT_CONTINUE;
+	return true;
 }
 
-static bool ecn_tg_check(const struct xt_tgchk_param *par)
+static bool ecn_mt_check(const struct xt_mtchk_param *par)
 {
-	const struct ipt_ECN_info *einfo = par->targinfo;
-	const struct ipt_entry *e = par->entryinfo;
+	const struct ipt_ecn_info *info = par->matchinfo;
+	const struct ipt_ip *ip = par->entryinfo;
 
-	if (einfo->operation & IPT_ECN_OP_MASK) {
-		printk(KERN_WARNING "ECN: unsupported ECN operation %x\n",
-			einfo->operation);
+	if (info->operation & IPT_ECN_OP_MATCH_MASK)
 		return false;
-	}
-	if (einfo->ip_ect & ~IPT_ECN_IP_MASK) {
-		printk(KERN_WARNING "ECN: new ECT codepoint %x out of mask\n",
-			einfo->ip_ect);
+
+	if (info->invert & IPT_ECN_OP_MATCH_MASK)
 		return false;
-	}
-	if ((einfo->operation & (IPT_ECN_OP_SET_ECE|IPT_ECN_OP_SET_CWR))
-	    && (e->ip.proto != IPPROTO_TCP || (e->ip.invflags & XT_INV_PROTO))) {
-		printk(KERN_WARNING "ECN: cannot use TCP operations on a "
-		       "non-tcp rule\n");
+
+	if (info->operation & (IPT_ECN_OP_MATCH_ECE|IPT_ECN_OP_MATCH_CWR)
+	    && ip->proto != IPPROTO_TCP) {
+		printk(KERN_WARNING "ipt_ecn: can't match TCP bits in rule for"
+		       " non-tcp packets\n");
 		return false;
 	}
+
 	return true;
 }
 
-static struct xt_target ecn_tg_reg __read_mostly = {
-	.name		= "ECN",
+static struct xt_match ecn_mt_reg __read_mostly = {
+	.name		= "ecn",
 	.family		= NFPROTO_IPV4,
-	.target		= ecn_tg,
-	.targetsize	= sizeof(struct ipt_ECN_info),
-	.table		= "mangle",
-	.checkentry	= ecn_tg_check,
+	.match		= ecn_mt,
+	.matchsize	= sizeof(struct ipt_ecn_info),
+	.checkentry	= ecn_mt_check,
 	.me		= THIS_MODULE,
 };
 
-static int __init ecn_tg_init(void)
+static int __init ecn_mt_init(void)
 {
-	return xt_register_target(&ecn_tg_reg);
+	return xt_register_match(&ecn_mt_reg);
 }
 
-static void __exit ecn_tg_exit(void)
+static void __exit ecn_mt_exit(void)
 {
-	xt_unregister_target(&ecn_tg_reg);
+	xt_unregister_match(&ecn_mt_reg);
 }
 
-module_init(ecn_tg_init);
-module_exit(ecn_tg_exit);
+module_init(ecn_mt_init);
+module_exit(ecn_mt_exit);
diff -Nur linux-2.6.32-orig/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
--- linux-2.6.32-orig/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2010-11-18 21:05:30.000000000 +0600
@@ -213,7 +213,7 @@
 	{
 		.ctl_name	= NET_IPV4_NF_CONNTRACK_BUCKETS,
 		.procname	= "ip_conntrack_buckets",
-		.data		= &nf_conntrack_htable_size,
+		.data		= &init_net.ct.htable_size,
 		.maxlen		= sizeof(unsigned int),
 		.mode		= 0444,
 		.proc_handler	= proc_dointvec,
diff -Nur linux-2.6.32-orig/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
--- linux-2.6.32-orig/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c	2010-11-18 21:05:30.000000000 +0600
@@ -32,7 +32,7 @@
 	struct hlist_nulls_node *n;
 
 	for (st->bucket = 0;
-	     st->bucket < nf_conntrack_htable_size;
+	     st->bucket < net->ct.htable_size;
 	     st->bucket++) {
 		n = rcu_dereference(net->ct.hash[st->bucket].first);
 		if (!is_a_nulls(n))
@@ -50,7 +50,7 @@
 	head = rcu_dereference(head->next);
 	while (is_a_nulls(head)) {
 		if (likely(get_nulls_value(head) == st->bucket)) {
-			if (++st->bucket >= nf_conntrack_htable_size)
+			if (++st->bucket >= net->ct.htable_size)
 				return NULL;
 		}
 		head = rcu_dereference(net->ct.hash[st->bucket].first);
diff -Nur linux-2.6.32-orig/net/ipv4/netfilter/nf_defrag_ipv4.c iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/nf_defrag_ipv4.c
--- linux-2.6.32-orig/net/ipv4/netfilter/nf_defrag_ipv4.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/nf_defrag_ipv4.c	2010-11-18 21:05:30.000000000 +0600
@@ -14,6 +14,7 @@
 #include <net/route.h>
 #include <net/ip.h>
 
+#include <linux/netfilter_bridge.h>
 #include <linux/netfilter_ipv4.h>
 #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
 
@@ -34,6 +35,20 @@
 	return err;
 }
 
+static enum ip_defrag_users nf_ct_defrag_user(unsigned int hooknum,
+					      struct sk_buff *skb)
+{
+#ifdef CONFIG_BRIDGE_NETFILTER
+	if (skb->nf_bridge &&
+	    skb->nf_bridge->mask & BRNF_NF_BRIDGE_PREROUTING)
+		return IP_DEFRAG_CONNTRACK_BRIDGE_IN;
+#endif
+	if (hooknum == NF_INET_PRE_ROUTING)
+		return IP_DEFRAG_CONNTRACK_IN;
+	else
+		return IP_DEFRAG_CONNTRACK_OUT;
+}
+
 static unsigned int ipv4_conntrack_defrag(unsigned int hooknum,
 					  struct sk_buff *skb,
 					  const struct net_device *in,
@@ -50,10 +65,8 @@
 #endif
 	/* Gather fragments. */
 	if (ip_hdr(skb)->frag_off & htons(IP_MF | IP_OFFSET)) {
-		if (nf_ct_ipv4_gather_frags(skb,
-					    hooknum == NF_INET_PRE_ROUTING ?
-					    IP_DEFRAG_CONNTRACK_IN :
-					    IP_DEFRAG_CONNTRACK_OUT))
+		enum ip_defrag_users user = nf_ct_defrag_user(hooknum, skb);
+		if (nf_ct_ipv4_gather_frags(skb, user))
 			return NF_STOLEN;
 	}
 	return NF_ACCEPT;
diff -Nur linux-2.6.32-orig/net/ipv4/netfilter/nf_nat_core.c iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/nf_nat_core.c
--- linux-2.6.32-orig/net/ipv4/netfilter/nf_nat_core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/netfilter/nf_nat_core.c	2010-11-18 21:05:30.000000000 +0600
@@ -35,9 +35,6 @@
 
 static struct nf_conntrack_l3proto *l3proto __read_mostly;
 
-/* Calculated at init based on memory size */
-static unsigned int nf_nat_htable_size __read_mostly;
-
 #define MAX_IP_NAT_PROTO 256
 static const struct nf_nat_protocol *nf_nat_protos[MAX_IP_NAT_PROTO]
 						__read_mostly;
@@ -72,7 +69,7 @@
 
 /* We keep an extra hash for each conntrack, for fast searching. */
 static inline unsigned int
-hash_by_src(const struct nf_conntrack_tuple *tuple)
+hash_by_src(const struct net *net, const struct nf_conntrack_tuple *tuple)
 {
 	unsigned int hash;
 
@@ -80,7 +77,7 @@
 	hash = jhash_3words((__force u32)tuple->src.u3.ip,
 			    (__force u32)tuple->src.u.all,
 			    tuple->dst.protonum, 0);
-	return ((u64)hash * nf_nat_htable_size) >> 32;
+	return ((u64)hash * net->ipv4.nat_htable_size) >> 32;
 }
 
 /* Is this tuple already taken? (not by us) */
@@ -147,7 +144,7 @@
 		     struct nf_conntrack_tuple *result,
 		     const struct nf_nat_range *range)
 {
-	unsigned int h = hash_by_src(tuple);
+	unsigned int h = hash_by_src(net, tuple);
 	const struct nf_conn_nat *nat;
 	const struct nf_conn *ct;
 	const struct hlist_node *n;
@@ -330,7 +327,7 @@
 	if (have_to_hash) {
 		unsigned int srchash;
 
-		srchash = hash_by_src(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
+		srchash = hash_by_src(net, &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
 		spin_lock_bh(&nf_nat_lock);
 		/* nf_conntrack_alter_reply might re-allocate exntension aera */
 		nat = nfct_nat(ct);
@@ -679,8 +676,10 @@
 
 static int __net_init nf_nat_net_init(struct net *net)
 {
-	net->ipv4.nat_bysource = nf_ct_alloc_hashtable(&nf_nat_htable_size,
-						      &net->ipv4.nat_vmalloced, 0);
+	/* Leave them the same for the moment. */
+	net->ipv4.nat_htable_size = net->ct.htable_size;
+	net->ipv4.nat_bysource = nf_ct_alloc_hashtable(&net->ipv4.nat_htable_size,
+						       &net->ipv4.nat_vmalloced, 0);
 	if (!net->ipv4.nat_bysource)
 		return -ENOMEM;
 	return 0;
@@ -703,7 +702,7 @@
 	nf_ct_iterate_cleanup(net, &clean_nat, NULL);
 	synchronize_rcu();
 	nf_ct_free_hashtable(net->ipv4.nat_bysource, net->ipv4.nat_vmalloced,
-			     nf_nat_htable_size);
+			     net->ipv4.nat_htable_size);
 }
 
 static struct pernet_operations nf_nat_net_ops = {
@@ -724,9 +723,6 @@
 		return ret;
 	}
 
-	/* Leave them the same for the moment. */
-	nf_nat_htable_size = nf_conntrack_htable_size;
-
 	ret = register_pernet_subsys(&nf_nat_net_ops);
 	if (ret < 0)
 		goto cleanup_extend;
diff -Nur linux-2.6.32-orig/net/ipv4/sysfs_net_ipv4.c iDroid-Project-kernel_common-9e90fd2/net/ipv4/sysfs_net_ipv4.c
--- linux-2.6.32-orig/net/ipv4/sysfs_net_ipv4.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/sysfs_net_ipv4.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,88 @@
+/*
+ * net/ipv4/sysfs_net_ipv4.c
+ *
+ * sysfs-based networking knobs (so we can, unlike with sysctl, control perms)
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * Robert Love <rlove@google.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/init.h>
+#include <net/tcp.h>
+
+#define CREATE_IPV4_FILE(_name, _var) \
+static ssize_t _name##_show(struct kobject *kobj, \
+			    struct kobj_attribute *attr, char *buf) \
+{ \
+	return sprintf(buf, "%d\n", _var); \
+} \
+static ssize_t _name##_store(struct kobject *kobj, \
+			     struct kobj_attribute *attr, \
+			     const char *buf, size_t count) \
+{ \
+	int val, ret; \
+	ret = sscanf(buf, "%d", &val); \
+	if (ret != 1) \
+		return -EINVAL; \
+	if (val < 0) \
+		return -EINVAL; \
+	_var = val; \
+	return count; \
+} \
+static struct kobj_attribute _name##_attr = \
+	__ATTR(_name, 0644, _name##_show, _name##_store)
+
+CREATE_IPV4_FILE(tcp_wmem_min, sysctl_tcp_wmem[0]);
+CREATE_IPV4_FILE(tcp_wmem_def, sysctl_tcp_wmem[1]);
+CREATE_IPV4_FILE(tcp_wmem_max, sysctl_tcp_wmem[2]);
+
+CREATE_IPV4_FILE(tcp_rmem_min, sysctl_tcp_rmem[0]);
+CREATE_IPV4_FILE(tcp_rmem_def, sysctl_tcp_rmem[1]);
+CREATE_IPV4_FILE(tcp_rmem_max, sysctl_tcp_rmem[2]);
+
+static struct attribute *ipv4_attrs[] = {
+	&tcp_wmem_min_attr.attr,
+	&tcp_wmem_def_attr.attr,
+	&tcp_wmem_max_attr.attr,
+	&tcp_rmem_min_attr.attr,
+	&tcp_rmem_def_attr.attr,
+	&tcp_rmem_max_attr.attr,
+	NULL
+};
+
+static struct attribute_group ipv4_attr_group = {
+	.attrs = ipv4_attrs,
+};
+
+static __init int sysfs_ipv4_init(void)
+{
+	struct kobject *ipv4_kobject;
+	int ret;
+
+	ipv4_kobject = kobject_create_and_add("ipv4", kernel_kobj);
+	if (!ipv4_kobject)
+		return -ENOMEM;
+
+	ret = sysfs_create_group(ipv4_kobject, &ipv4_attr_group);
+	if (ret) {
+		kobject_put(ipv4_kobject);
+		return ret;
+	}
+
+	return 0;
+}
+
+subsys_initcall(sysfs_ipv4_init);
diff -Nur linux-2.6.32-orig/net/ipv4/tcp_ipv4.c iDroid-Project-kernel_common-9e90fd2/net/ipv4/tcp_ipv4.c
--- linux-2.6.32-orig/net/ipv4/tcp_ipv4.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv4/tcp_ipv4.c	2010-11-18 21:05:30.000000000 +0600
@@ -1884,6 +1884,49 @@
 
 EXPORT_SYMBOL(tcp_v4_destroy_sock);
 
+/*
+ * tcp_v4_nuke_addr - destroy all sockets on the given local address
+ */
+void tcp_v4_nuke_addr(__u32 saddr)
+{
+	unsigned int bucket;
+
+	for (bucket = 0; bucket < tcp_hashinfo.ehash_size; bucket++) {
+		struct hlist_nulls_node *node;
+		struct sock *sk;
+		spinlock_t *lock = inet_ehash_lockp(&tcp_hashinfo, bucket);
+
+restart:
+		spin_lock_bh(lock);
+		sk_nulls_for_each(sk, node, &tcp_hashinfo.ehash[bucket].chain) {
+			struct inet_sock *inet = inet_sk(sk);
+
+			if (inet->rcv_saddr != saddr)
+				continue;
+			if (sysctl_ip_dynaddr && sk->sk_state == TCP_SYN_SENT)
+				continue;
+			if (sock_flag(sk, SOCK_DEAD))
+				continue;
+
+			sock_hold(sk);
+			spin_unlock_bh(lock);
+
+			local_bh_disable();
+			bh_lock_sock(sk);
+			sk->sk_err = ETIMEDOUT;
+			sk->sk_error_report(sk);
+
+			tcp_done(sk);
+			bh_unlock_sock(sk);
+			local_bh_enable();
+			sock_put(sk);
+
+			goto restart;
+		}
+		spin_unlock_bh(lock);
+	}
+}
+
 #ifdef CONFIG_PROC_FS
 /* Proc filesystem TCP sock list dumping. */
 
@@ -2493,4 +2536,3 @@
 EXPORT_SYMBOL(tcp_proc_unregister);
 #endif
 EXPORT_SYMBOL(sysctl_tcp_low_latency);
-
diff -Nur linux-2.6.32-orig/net/ipv6/af_inet6.c iDroid-Project-kernel_common-9e90fd2/net/ipv6/af_inet6.c
--- linux-2.6.32-orig/net/ipv6/af_inet6.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv6/af_inet6.c	2010-11-18 21:05:30.000000000 +0600
@@ -62,6 +62,20 @@
 #include <asm/system.h>
 #include <linux/mroute6.h>
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+
+static inline int current_has_network(void)
+{
+	return in_egroup_p(AID_INET) || capable(CAP_NET_RAW);
+}
+#else
+static inline int current_has_network(void)
+{
+	return 1;
+}
+#endif
+
 MODULE_AUTHOR("Cast of dozens");
 MODULE_DESCRIPTION("IPv6 protocol stack for Linux");
 MODULE_LICENSE("GPL");
@@ -107,6 +121,9 @@
 	int try_loading_module = 0;
 	int err;
 
+	if (!current_has_network())
+		return -EACCES;
+
 	if (sock->type != SOCK_RAW &&
 	    sock->type != SOCK_DGRAM &&
 	    !inet_ehash_secret)
diff -Nur linux-2.6.32-orig/net/ipv6/exthdrs.c iDroid-Project-kernel_common-9e90fd2/net/ipv6/exthdrs.c
--- linux-2.6.32-orig/net/ipv6/exthdrs.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv6/exthdrs.c	2010-11-18 21:05:30.000000000 +0600
@@ -559,6 +559,11 @@
 	return skb_dst(skb) ? ip6_dst_idev(skb_dst(skb)) : __in6_dev_get(skb->dev);
 }
 
+static inline struct net *ipv6_skb_net(struct sk_buff *skb)
+{
+	return skb_dst(skb) ? dev_net(skb_dst(skb)->dev) : dev_net(skb->dev);
+}
+
 /* Router Alert as of RFC 2711 */
 
 static int ipv6_hop_ra(struct sk_buff *skb, int optoff)
@@ -580,8 +585,8 @@
 static int ipv6_hop_jumbo(struct sk_buff *skb, int optoff)
 {
 	const unsigned char *nh = skb_network_header(skb);
+	struct net *net = ipv6_skb_net(skb);
 	u32 pkt_len;
-	struct net *net = dev_net(skb_dst(skb)->dev);
 
 	if (nh[optoff + 1] != 4 || (optoff & 3) != 2) {
 		LIMIT_NETDEBUG(KERN_DEBUG "ipv6_hop_jumbo: wrong jumbo opt length/alignment %d\n",
diff -Nur linux-2.6.32-orig/net/ipv6/netfilter/ip6_tables.c iDroid-Project-kernel_common-9e90fd2/net/ipv6/netfilter/ip6_tables.c
--- linux-2.6.32-orig/net/ipv6/netfilter/ip6_tables.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv6/netfilter/ip6_tables.c	2010-11-18 21:05:30.000000000 +0600
@@ -1164,10 +1164,10 @@
 	if (t && !IS_ERR(t)) {
 		struct ip6t_getinfo info;
 		const struct xt_table_info *private = t->private;
-
 #ifdef CONFIG_COMPAT
+		struct xt_table_info tmp;
+
 		if (compat) {
-			struct xt_table_info tmp;
 			ret = compat_table_info(private, &tmp);
 			xt_compat_flush_offsets(AF_INET6);
 			private = &tmp;
diff -Nur linux-2.6.32-orig/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c iDroid-Project-kernel_common-9e90fd2/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
--- linux-2.6.32-orig/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c	2010-11-18 21:05:30.000000000 +0600
@@ -20,6 +20,7 @@
 #include <net/ipv6.h>
 #include <net/inet_frag.h>
 
+#include <linux/netfilter_bridge.h>
 #include <linux/netfilter_ipv6.h>
 #include <net/netfilter/nf_conntrack.h>
 #include <net/netfilter/nf_conntrack_helper.h>
@@ -187,6 +188,21 @@
 	return nf_conntrack_confirm(skb);
 }
 
+static enum ip6_defrag_users nf_ct6_defrag_user(unsigned int hooknum,
+						struct sk_buff *skb)
+{
+#ifdef CONFIG_BRIDGE_NETFILTER
+	if (skb->nf_bridge &&
+	    skb->nf_bridge->mask & BRNF_NF_BRIDGE_PREROUTING)
+		return IP6_DEFRAG_CONNTRACK_BRIDGE_IN;
+#endif
+	if (hooknum == NF_INET_PRE_ROUTING)
+		return IP6_DEFRAG_CONNTRACK_IN;
+	else
+		return IP6_DEFRAG_CONNTRACK_OUT;
+
+}
+
 static unsigned int ipv6_defrag(unsigned int hooknum,
 				struct sk_buff *skb,
 				const struct net_device *in,
@@ -199,8 +215,7 @@
 	if (skb->nfct)
 		return NF_ACCEPT;
 
-	reasm = nf_ct_frag6_gather(skb);
-
+	reasm = nf_ct_frag6_gather(skb, nf_ct6_defrag_user(hooknum, skb));
 	/* queued */
 	if (reasm == NULL)
 		return NF_STOLEN;
diff -Nur linux-2.6.32-orig/net/ipv6/netfilter/nf_conntrack_reasm.c iDroid-Project-kernel_common-9e90fd2/net/ipv6/netfilter/nf_conntrack_reasm.c
--- linux-2.6.32-orig/net/ipv6/netfilter/nf_conntrack_reasm.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv6/netfilter/nf_conntrack_reasm.c	2010-11-18 21:05:30.000000000 +0600
@@ -170,13 +170,14 @@
 /* Creation primitives. */
 
 static __inline__ struct nf_ct_frag6_queue *
-fq_find(__be32 id, struct in6_addr *src, struct in6_addr *dst)
+fq_find(__be32 id, u32 user, struct in6_addr *src, struct in6_addr *dst)
 {
 	struct inet_frag_queue *q;
 	struct ip6_create_arg arg;
 	unsigned int hash;
 
 	arg.id = id;
+	arg.user = user;
 	arg.src = src;
 	arg.dst = dst;
 
@@ -561,7 +562,7 @@
 	return 0;
 }
 
-struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb)
+struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)
 {
 	struct sk_buff *clone;
 	struct net_device *dev = skb->dev;
@@ -607,7 +608,7 @@
 	if (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)
 		nf_ct_frag6_evictor();
 
-	fq = fq_find(fhdr->identification, &hdr->saddr, &hdr->daddr);
+	fq = fq_find(fhdr->identification, user, &hdr->saddr, &hdr->daddr);
 	if (fq == NULL) {
 		pr_debug("Can't find and can't create new queue\n");
 		goto ret_orig;
diff -Nur linux-2.6.32-orig/net/ipv6/reassembly.c iDroid-Project-kernel_common-9e90fd2/net/ipv6/reassembly.c
--- linux-2.6.32-orig/net/ipv6/reassembly.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/ipv6/reassembly.c	2010-11-18 21:05:30.000000000 +0600
@@ -72,6 +72,7 @@
 	struct inet_frag_queue	q;
 
 	__be32			id;		/* fragment id		*/
+	u32			user;
 	struct in6_addr		saddr;
 	struct in6_addr		daddr;
 
@@ -141,7 +142,7 @@
 	struct ip6_create_arg *arg = a;
 
 	fq = container_of(q, struct frag_queue, q);
-	return (fq->id == arg->id &&
+	return (fq->id == arg->id && fq->user == arg->user &&
 			ipv6_addr_equal(&fq->saddr, arg->src) &&
 			ipv6_addr_equal(&fq->daddr, arg->dst));
 }
@@ -163,6 +164,7 @@
 	struct ip6_create_arg *arg = a;
 
 	fq->id = arg->id;
+	fq->user = arg->user;
 	ipv6_addr_copy(&fq->saddr, arg->src);
 	ipv6_addr_copy(&fq->daddr, arg->dst);
 }
@@ -244,6 +246,7 @@
 	unsigned int hash;
 
 	arg.id = id;
+	arg.user = IP6_DEFRAG_LOCAL_DELIVER;
 	arg.src = src;
 	arg.dst = dst;
 
diff -Nur linux-2.6.32-orig/net/Kconfig iDroid-Project-kernel_common-9e90fd2/net/Kconfig
--- linux-2.6.32-orig/net/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -79,6 +79,12 @@
 
 endif # if INET
 
+config ANDROID_PARANOID_NETWORK
+	bool "Only allow certain groups to create sockets"
+	default y
+	help
+		none
+
 config NETWORK_SECMARK
 	bool "Security Marking"
 	help
diff -Nur linux-2.6.32-orig/net/mac80211/cfg.c iDroid-Project-kernel_common-9e90fd2/net/mac80211/cfg.c
--- linux-2.6.32-orig/net/mac80211/cfg.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/cfg.c	2010-11-18 21:05:30.000000000 +0600
@@ -338,7 +338,8 @@
 	sinfo->rx_packets = sta->rx_packets;
 	sinfo->tx_packets = sta->tx_packets;
 
-	if (sta->local->hw.flags & IEEE80211_HW_SIGNAL_DBM) {
+	if ((sta->local->hw.flags & IEEE80211_HW_SIGNAL_DBM) ||
+	    (sta->local->hw.flags & IEEE80211_HW_SIGNAL_UNSPEC)) {
 		sinfo->filled |= STATION_INFO_SIGNAL;
 		sinfo->signal = (s8)sta->last_signal;
 	}
@@ -1305,6 +1306,9 @@
 	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
 	struct ieee80211_conf *conf = &local->hw.conf;
 
+	if (sdata->vif.type != NL80211_IFTYPE_STATION)
+		return -EOPNOTSUPP;
+
 	if (!(local->hw.flags & IEEE80211_HW_SUPPORTS_PS))
 		return -EOPNOTSUPP;
 
diff -Nur linux-2.6.32-orig/net/mac80211/driver-trace.h iDroid-Project-kernel_common-9e90fd2/net/mac80211/driver-trace.h
--- linux-2.6.32-orig/net/mac80211/driver-trace.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/driver-trace.h	2010-11-18 21:05:30.000000000 +0600
@@ -655,7 +655,7 @@
 		__entry->ret = ret;
 		__entry->action = action;
 		__entry->tid = tid;
-		__entry->ssn = *ssn;
+		__entry->ssn = ssn ? *ssn : 0;
 	),
 
 	TP_printk(
diff -Nur linux-2.6.32-orig/net/mac80211/ibss.c iDroid-Project-kernel_common-9e90fd2/net/mac80211/ibss.c
--- linux-2.6.32-orig/net/mac80211/ibss.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/ibss.c	2010-11-18 21:05:30.000000000 +0600
@@ -455,6 +455,10 @@
 
 	ieee80211_sta_expire(sdata, IEEE80211_IBSS_INACTIVITY_LIMIT);
 
+	if (time_before(jiffies, ifibss->last_scan_completed +
+		       IEEE80211_IBSS_MERGE_INTERVAL))
+		return;
+
 	if (ieee80211_sta_active_ibss(sdata))
 		return;
 
@@ -639,7 +643,7 @@
 	}
 	if (pos[1] != 0 &&
 	    (pos[1] != ifibss->ssid_len ||
-	     !memcmp(pos + 2, ifibss->ssid, ifibss->ssid_len))) {
+	     memcmp(pos + 2, ifibss->ssid, ifibss->ssid_len))) {
 		/* Ignore ProbeReq for foreign SSID */
 		return;
 	}
diff -Nur linux-2.6.32-orig/net/mac80211/ieee80211_i.h iDroid-Project-kernel_common-9e90fd2/net/mac80211/ieee80211_i.h
--- linux-2.6.32-orig/net/mac80211/ieee80211_i.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/ieee80211_i.h	2010-11-18 21:05:30.000000000 +0600
@@ -808,6 +808,7 @@
 	unsigned int wmm_acm; /* bit field of ACM bits (BIT(802.1D tag)) */
 
 	bool pspolling;
+	bool scan_ps_enabled;
 	/*
 	 * PS can only be enabled when we have exactly one managed
 	 * interface (and monitors) in PS, this then points there.
diff -Nur linux-2.6.32-orig/net/mac80211/iface.c iDroid-Project-kernel_common-9e90fd2/net/mac80211/iface.c
--- linux-2.6.32-orig/net/mac80211/iface.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/iface.c	2010-11-18 21:05:30.000000000 +0600
@@ -15,12 +15,14 @@
 #include <linux/netdevice.h>
 #include <linux/rtnetlink.h>
 #include <net/mac80211.h>
+#include <net/ieee80211_radiotap.h>
 #include "ieee80211_i.h"
 #include "sta_info.h"
 #include "debugfs_netdev.h"
 #include "mesh.h"
 #include "led.h"
 #include "driver-ops.h"
+#include "wme.h"
 
 /**
  * DOC: Interface list locking
@@ -642,6 +644,12 @@
 	WARN_ON(flushed);
 }
 
+static u16 ieee80211_netdev_select_queue(struct net_device *dev,
+					 struct sk_buff *skb)
+{
+	return ieee80211_select_queue(IEEE80211_DEV_TO_SUB_IF(dev), skb);
+}
+
 static const struct net_device_ops ieee80211_dataif_ops = {
 	.ndo_open		= ieee80211_open,
 	.ndo_stop		= ieee80211_stop,
@@ -650,8 +658,35 @@
 	.ndo_set_multicast_list = ieee80211_set_multicast_list,
 	.ndo_change_mtu 	= ieee80211_change_mtu,
 	.ndo_set_mac_address 	= eth_mac_addr,
+	.ndo_select_queue	= ieee80211_netdev_select_queue,
 };
 
+static u16 ieee80211_monitor_select_queue(struct net_device *dev,
+					  struct sk_buff *skb)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_hdr *hdr;
+	struct ieee80211_radiotap_header *rtap = (void *)skb->data;
+
+	if (local->hw.queues < 4)
+		return 0;
+
+	if (skb->len < 4 ||
+	    skb->len < le16_to_cpu(rtap->it_len) + 2 /* frame control */)
+		return 0; /* doesn't matter, frame will be dropped */
+
+	hdr = (void *)((u8 *)skb->data + le16_to_cpu(rtap->it_len));
+
+	if (!ieee80211_is_data(hdr->frame_control)) {
+		skb->priority = 7;
+		return ieee802_1d_to_ac[skb->priority];
+	}
+
+	skb->priority = 0;
+	return ieee80211_downgrade_queue(local, skb);
+}
+
 static const struct net_device_ops ieee80211_monitorif_ops = {
 	.ndo_open		= ieee80211_open,
 	.ndo_stop		= ieee80211_stop,
@@ -660,6 +695,7 @@
 	.ndo_set_multicast_list = ieee80211_set_multicast_list,
 	.ndo_change_mtu 	= ieee80211_change_mtu,
 	.ndo_set_mac_address 	= eth_mac_addr,
+	.ndo_select_queue	= ieee80211_monitor_select_queue,
 };
 
 static void ieee80211_if_setup(struct net_device *dev)
@@ -768,8 +804,8 @@
 
 	ASSERT_RTNL();
 
-	ndev = alloc_netdev(sizeof(*sdata) + local->hw.vif_data_size,
-			    name, ieee80211_if_setup);
+	ndev = alloc_netdev_mq(sizeof(*sdata) + local->hw.vif_data_size,
+			       name, ieee80211_if_setup, local->hw.queues);
 	if (!ndev)
 		return -ENOMEM;
 	dev_net_set(ndev, wiphy_net(local->hw.wiphy));
diff -Nur linux-2.6.32-orig/net/mac80211/mesh.h iDroid-Project-kernel_common-9e90fd2/net/mac80211/mesh.h
--- linux-2.6.32-orig/net/mac80211/mesh.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/mesh.h	2010-11-18 21:05:30.000000000 +0600
@@ -186,8 +186,9 @@
  */
 #define MESH_PREQ_MIN_INT	10
 #define MESH_DIAM_TRAVERSAL_TIME 50
-/* Paths will be refreshed if they are closer than PATH_REFRESH_TIME to their
- * expiration
+/* A path will be refreshed if it is used PATH_REFRESH_TIME milliseconds before
+ * timing out.  This way it will remain ACTIVE and no data frames will be
+ * unnecesarily held in the pending queue.
  */
 #define MESH_PATH_REFRESH_TIME			1000
 #define MESH_MIN_DISCOVERY_TIMEOUT (2 * MESH_DIAM_TRAVERSAL_TIME)
diff -Nur linux-2.6.32-orig/net/mac80211/mesh_hwmp.c iDroid-Project-kernel_common-9e90fd2/net/mac80211/mesh_hwmp.c
--- linux-2.6.32-orig/net/mac80211/mesh_hwmp.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/mesh_hwmp.c	2010-11-18 21:05:30.000000000 +0600
@@ -813,7 +813,7 @@
 	}
 
 	if (mpath->flags & MESH_PATH_ACTIVE) {
-		if (time_after(jiffies, mpath->exp_time +
+		if (time_after(jiffies, mpath->exp_time -
 			msecs_to_jiffies(sdata->u.mesh.mshcfg.path_refresh_time))
 				&& !memcmp(sdata->dev->dev_addr, hdr->addr4,
 					   ETH_ALEN)
diff -Nur linux-2.6.32-orig/net/mac80211/mlme.c iDroid-Project-kernel_common-9e90fd2/net/mac80211/mlme.c
--- linux-2.6.32-orig/net/mac80211/mlme.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/mlme.c	2010-11-18 21:05:30.000000000 +0600
@@ -904,6 +904,14 @@
 	sdata->u.mgd.flags &= ~(IEEE80211_STA_CONNECTION_POLL |
 				IEEE80211_STA_BEACON_POLL);
 
+	/*
+	 * Always handle WMM once after association regardless
+	 * of the first value the AP uses. Setting -1 here has
+	 * that effect because the AP values is an unsigned
+	 * 4-bit value.
+	 */
+	sdata->u.mgd.wmm_last_param_set = -1;
+
 	ieee80211_led_assoc(local, 1);
 
 	sdata->vif.bss_conf.assoc = 1;
@@ -1945,7 +1953,9 @@
 			rma = ieee80211_rx_mgmt_disassoc(sdata, mgmt, skb->len);
 			break;
 		case IEEE80211_STYPE_ACTION:
-			/* XXX: differentiate, can only happen for CSA now! */
+			if (mgmt->u.action.category != WLAN_CATEGORY_SPECTRUM_MGMT)
+				break;
+
 			ieee80211_sta_process_chanswitch(sdata,
 					&mgmt->u.action.u.chan_switch.sw_elem,
 					ifmgd->associated);
diff -Nur linux-2.6.32-orig/net/mac80211/rx.c iDroid-Project-kernel_common-9e90fd2/net/mac80211/rx.c
--- linux-2.6.32-orig/net/mac80211/rx.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/rx.c	2010-11-18 21:05:30.000000000 +0600
@@ -1514,7 +1514,6 @@
 			mpp_path_add(mesh_hdr->eaddr2, hdr->addr4, sdata);
 		} else {
 			spin_lock_bh(&mppath->state_lock);
-			mppath->exp_time = jiffies;
 			if (compare_ether_addr(mppath->mpp, hdr->addr4) != 0)
 				memcpy(mppath->mpp, hdr->addr4, ETH_ALEN);
 			spin_unlock_bh(&mppath->state_lock);
@@ -1549,7 +1548,9 @@
 			memset(info, 0, sizeof(*info));
 			info->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;
 			info->control.vif = &rx->sdata->vif;
-			ieee80211_select_queue(local, fwd_skb);
+			skb_set_queue_mapping(skb,
+				ieee80211_select_queue(rx->sdata, fwd_skb));
+			ieee80211_set_qos_hdr(local, skb);
 			if (is_multicast_ether_addr(fwd_hdr->addr1))
 				IEEE80211_IFSTA_MESH_CTR_INC(&sdata->u.mesh,
 								fwded_mcast);
@@ -1809,6 +1810,10 @@
 		}
 		break;
 	default:
+		/* do not process rejected action frames */
+		if (mgmt->u.action.category & 0x80)
+			return RX_DROP_MONITOR;
+
 		return RX_CONTINUE;
 	}
 
diff -Nur linux-2.6.32-orig/net/mac80211/scan.c iDroid-Project-kernel_common-9e90fd2/net/mac80211/scan.c
--- linux-2.6.32-orig/net/mac80211/scan.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/scan.c	2010-11-18 21:05:30.000000000 +0600
@@ -196,7 +196,8 @@
 static void ieee80211_scan_ps_enable(struct ieee80211_sub_if_data *sdata)
 {
 	struct ieee80211_local *local = sdata->local;
-	bool ps = false;
+
+	local->scan_ps_enabled = false;
 
 	/* FIXME: what to do when local->pspolling is true? */
 
@@ -204,12 +205,13 @@
 	cancel_work_sync(&local->dynamic_ps_enable_work);
 
 	if (local->hw.conf.flags & IEEE80211_CONF_PS) {
-		ps = true;
+		local->scan_ps_enabled = true;
 		local->hw.conf.flags &= ~IEEE80211_CONF_PS;
 		ieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);
 	}
 
-	if (!ps || !(local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK))
+	if (!(local->scan_ps_enabled) ||
+	    !(local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK))
 		/*
 		 * If power save was enabled, no need to send a nullfunc
 		 * frame because AP knows that we are sleeping. But if the
@@ -230,7 +232,7 @@
 
 	if (!local->ps_sdata)
 		ieee80211_send_nullfunc(local, sdata, 0);
-	else {
+	else if (local->scan_ps_enabled) {
 		/*
 		 * In !IEEE80211_HW_PS_NULLFUNC_STACK case the hardware
 		 * will send a nullfunc frame with the powersave bit set
@@ -246,6 +248,16 @@
 		 */
 		local->hw.conf.flags |= IEEE80211_CONF_PS;
 		ieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);
+	} else if (local->hw.conf.dynamic_ps_timeout > 0) {
+		/*
+		 * If IEEE80211_CONF_PS was not set and the dynamic_ps_timer
+		 * had been running before leaving the operating channel,
+		 * restart the timer now and send a nullfunc frame to inform
+		 * the AP that we are awake.
+		 */
+		ieee80211_send_nullfunc(local, sdata, 0);
+		mod_timer(&local->dynamic_ps_timer, jiffies +
+			  msecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));
 	}
 }
 
@@ -264,10 +276,14 @@
 
 	mutex_lock(&local->scan_mtx);
 
-	if (WARN_ON(!local->scanning)) {
-		mutex_unlock(&local->scan_mtx);
-		return;
-	}
+	/*
+	 * It's ok to abort a not-yet-running scan (that
+	 * we have one at all will be verified by checking
+	 * local->scan_req next), but not to complete it
+	 * successfully.
+	 */
+	if (WARN_ON(!local->scanning && !aborted))
+		aborted = true;
 
 	if (WARN_ON(!local->scan_req)) {
 		mutex_unlock(&local->scan_mtx);
diff -Nur linux-2.6.32-orig/net/mac80211/tx.c iDroid-Project-kernel_common-9e90fd2/net/mac80211/tx.c
--- linux-2.6.32-orig/net/mac80211/tx.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/tx.c	2010-11-18 21:05:30.000000000 +0600
@@ -1401,6 +1401,7 @@
 
 	if ((local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK) &&
 	    local->hw.conf.dynamic_ps_timeout > 0 &&
+	    !local->quiescing &&
 	    !(local->scanning) && local->ps_sdata) {
 		if (local->hw.conf.flags & IEEE80211_CONF_PS) {
 			ieee80211_stop_queues_by_reason(&local->hw,
@@ -1481,7 +1482,7 @@
 				return;
 			}
 
-	ieee80211_select_queue(local, skb);
+	ieee80211_set_qos_hdr(local, skb);
 	ieee80211_tx(sdata, skb, false);
 	dev_put(sdata->dev);
 }
@@ -2225,6 +2226,9 @@
 	if (!encrypt)
 		info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
 
+	/* send all internal mgmt frames on VO */
+	skb_set_queue_mapping(skb, 0);
+
 	/*
 	 * The other path calling ieee80211_xmit is from the tasklet,
 	 * and while we can handle concurrent transmissions locking
diff -Nur linux-2.6.32-orig/net/mac80211/util.c iDroid-Project-kernel_common-9e90fd2/net/mac80211/util.c
--- linux-2.6.32-orig/net/mac80211/util.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/util.c	2010-11-18 21:05:30.000000000 +0600
@@ -269,6 +269,7 @@
 				   enum queue_stop_reason reason)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_sub_if_data *sdata;
 
 	if (WARN_ON(queue >= hw->queues))
 		return;
@@ -281,6 +282,11 @@
 
 	if (!skb_queue_empty(&local->pending[queue]))
 		tasklet_schedule(&local->tx_pending_tasklet);
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(sdata, &local->interfaces, list)
+		netif_tx_wake_queue(netdev_get_tx_queue(sdata->dev, queue));
+	rcu_read_unlock();
 }
 
 void ieee80211_wake_queue_by_reason(struct ieee80211_hw *hw, int queue,
@@ -305,11 +311,17 @@
 				   enum queue_stop_reason reason)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_sub_if_data *sdata;
 
 	if (WARN_ON(queue >= hw->queues))
 		return;
 
 	__set_bit(reason, &local->queue_stop_reasons[queue]);
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(sdata, &local->interfaces, list)
+		netif_tx_stop_queue(netdev_get_tx_queue(sdata->dev, queue));
+	rcu_read_unlock();
 }
 
 void ieee80211_stop_queue_by_reason(struct ieee80211_hw *hw, int queue,
@@ -579,7 +591,7 @@
 		if (elen > left)
 			break;
 
-		if (calc_crc && id < 64 && (filter & BIT(id)))
+		if (calc_crc && id < 64 && (filter & (1ULL << id)))
 			crc = crc32_be(crc, pos - 2, elen + 2);
 
 		switch (id) {
@@ -1031,7 +1043,19 @@
 
 	/* restart hardware */
 	if (local->open_count) {
+		/*
+		 * Upon resume hardware can sometimes be goofy due to
+		 * various platform / driver / bus issues, so restarting
+		 * the device may at times not work immediately. Propagate
+		 * the error.
+		 */
 		res = drv_start(local);
+		if (res) {
+			WARN(local->suspended, "Harware became unavailable "
+			     "upon resume. This is could be a software issue"
+			     "prior to suspend or a harware issue\n");
+			return res;
+		}
 
 		ieee80211_led_radio(local, true);
 	}
diff -Nur linux-2.6.32-orig/net/mac80211/wme.c iDroid-Project-kernel_common-9e90fd2/net/mac80211/wme.c
--- linux-2.6.32-orig/net/mac80211/wme.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/wme.c	2010-11-18 21:05:30.000000000 +0600
@@ -44,22 +44,62 @@
 }
 
 
-/* Indicate which queue to use.  */
-static u16 classify80211(struct ieee80211_local *local, struct sk_buff *skb)
+/* Indicate which queue to use. */
+u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
+			   struct sk_buff *skb)
 {
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct ieee80211_local *local = sdata->local;
+	struct sta_info *sta = NULL;
+	u32 sta_flags = 0;
+	const u8 *ra = NULL;
+	bool qos = false;
 
-	if (!ieee80211_is_data(hdr->frame_control)) {
-		/* management frames go on AC_VO queue, but are sent
-		* without QoS control fields */
-		return 0;
+	if (local->hw.queues < 4 || skb->len < 6) {
+		skb->priority = 0; /* required for correct WPA/11i MIC */
+		return min_t(u16, local->hw.queues - 1,
+			     ieee802_1d_to_ac[skb->priority]);
+	}
+
+	rcu_read_lock();
+	switch (sdata->vif.type) {
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_AP:
+		ra = skb->data;
+		break;
+	case NL80211_IFTYPE_WDS:
+		ra = sdata->u.wds.remote_addr;
+		break;
+#ifdef CONFIG_MAC80211_MESH
+	case NL80211_IFTYPE_MESH_POINT:
+		/*
+		 * XXX: This is clearly broken ... but already was before,
+		 * because ieee80211_fill_mesh_addresses() would clear A1
+		 * except for multicast addresses.
+		 */
+		break;
+#endif
+	case NL80211_IFTYPE_STATION:
+		ra = sdata->u.mgd.bssid;
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		ra = skb->data;
+		break;
+	default:
+		break;
 	}
 
-	if (0 /* injected */) {
-		/* use AC from radiotap */
+	if (!sta && ra && !is_multicast_ether_addr(ra)) {
+		sta = sta_info_get(local, ra);
+		if (sta)
+			sta_flags = get_sta_flags(sta);
 	}
 
-	if (!ieee80211_is_data_qos(hdr->frame_control)) {
+	if (sta_flags & WLAN_STA_WME)
+		qos = true;
+
+	rcu_read_unlock();
+
+	if (!qos) {
 		skb->priority = 0; /* required for correct WPA/11i MIC */
 		return ieee802_1d_to_ac[skb->priority];
 	}
@@ -68,6 +108,12 @@
 	 * data frame has */
 	skb->priority = cfg80211_classify8021d(skb);
 
+	return ieee80211_downgrade_queue(local, skb);
+}
+
+u16 ieee80211_downgrade_queue(struct ieee80211_local *local,
+			      struct sk_buff *skb)
+{
 	/* in case we are a client verify acm is not set for this ac */
 	while (unlikely(local->wmm_acm & BIT(skb->priority))) {
 		if (wme_downgrade_ac(skb)) {
@@ -85,24 +131,17 @@
 	return ieee802_1d_to_ac[skb->priority];
 }
 
-void ieee80211_select_queue(struct ieee80211_local *local, struct sk_buff *skb)
+void ieee80211_set_qos_hdr(struct ieee80211_local *local, struct sk_buff *skb)
 {
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
-	u16 queue;
-	u8 tid;
-
-	queue = classify80211(local, skb);
-	if (unlikely(queue >= local->hw.queues))
-		queue = local->hw.queues - 1;
-
-	/*
-	 * Now we know the 1d priority, fill in the QoS header if
-	 * there is one (and we haven't done this before).
-	 */
+	struct ieee80211_hdr *hdr = (void *)skb->data;
+
+	/* Fill in the QoS header if there is one. */
 	if (ieee80211_is_data_qos(hdr->frame_control)) {
 		u8 *p = ieee80211_get_qos_ctl(hdr);
-		u8 ack_policy = 0;
+		u8 ack_policy = 0, tid;
+
 		tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;
+
 		if (unlikely(local->wifi_wme_noack_test))
 			ack_policy |= QOS_CONTROL_ACK_POLICY_NOACK <<
 					QOS_CONTROL_ACK_POLICY_SHIFT;
@@ -110,6 +149,4 @@
 		*p++ = ack_policy | tid;
 		*p = 0;
 	}
-
-	skb_set_queue_mapping(skb, queue);
 }
diff -Nur linux-2.6.32-orig/net/mac80211/wme.h iDroid-Project-kernel_common-9e90fd2/net/mac80211/wme.h
--- linux-2.6.32-orig/net/mac80211/wme.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/mac80211/wme.h	2010-11-18 21:05:30.000000000 +0600
@@ -20,7 +20,11 @@
 
 extern const int ieee802_1d_to_ac[8];
 
-void ieee80211_select_queue(struct ieee80211_local *local,
-			    struct sk_buff *skb);
+u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
+			   struct sk_buff *skb);
+void ieee80211_set_qos_hdr(struct ieee80211_local *local, struct sk_buff *skb);
+u16 ieee80211_downgrade_queue(struct ieee80211_local *local,
+                              struct sk_buff *skb);
+
 
 #endif /* _WME_H */
diff -Nur linux-2.6.32-orig/net/netfilter/ipvs/ip_vs_ctl.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/ipvs/ip_vs_ctl.c
--- linux-2.6.32-orig/net/netfilter/ipvs/ip_vs_ctl.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/ipvs/ip_vs_ctl.c	2010-11-18 21:05:30.000000000 +0600
@@ -2714,6 +2714,8 @@
 	if (!(nla_af && (nla_fwmark || (nla_port && nla_protocol && nla_addr))))
 		return -EINVAL;
 
+	memset(usvc, 0, sizeof(*usvc));
+
 	usvc->af = nla_get_u16(nla_af);
 #ifdef CONFIG_IP_VS_IPV6
 	if (usvc->af != AF_INET && usvc->af != AF_INET6)
@@ -2901,6 +2903,8 @@
 	if (!(nla_addr && nla_port))
 		return -EINVAL;
 
+	memset(udest, 0, sizeof(*udest));
+
 	nla_memcpy(&udest->addr, nla_addr, sizeof(udest->addr));
 	udest->port = nla_get_u16(nla_port);
 
diff -Nur linux-2.6.32-orig/net/netfilter/nf_conntrack_core.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/nf_conntrack_core.c
--- linux-2.6.32-orig/net/netfilter/nf_conntrack_core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/nf_conntrack_core.c	2010-11-18 21:05:30.000000000 +0600
@@ -30,6 +30,7 @@
 #include <linux/netdevice.h>
 #include <linux/socket.h>
 #include <linux/mm.h>
+#include <linux/nsproxy.h>
 #include <linux/rculist_nulls.h>
 
 #include <net/netfilter/nf_conntrack.h>
@@ -63,8 +64,6 @@
 struct nf_conn nf_conntrack_untracked __read_mostly;
 EXPORT_SYMBOL_GPL(nf_conntrack_untracked);
 
-static struct kmem_cache *nf_conntrack_cachep __read_mostly;
-
 static int nf_conntrack_hash_rnd_initted;
 static unsigned int nf_conntrack_hash_rnd;
 
@@ -86,9 +85,10 @@
 	return ((u64)h * size) >> 32;
 }
 
-static inline u_int32_t hash_conntrack(const struct nf_conntrack_tuple *tuple)
+static inline u_int32_t hash_conntrack(const struct net *net,
+				       const struct nf_conntrack_tuple *tuple)
 {
-	return __hash_conntrack(tuple, nf_conntrack_htable_size,
+	return __hash_conntrack(tuple, net->ct.htable_size,
 				nf_conntrack_hash_rnd);
 }
 
@@ -296,7 +296,7 @@
 {
 	struct nf_conntrack_tuple_hash *h;
 	struct hlist_nulls_node *n;
-	unsigned int hash = hash_conntrack(tuple);
+	unsigned int hash = hash_conntrack(net, tuple);
 
 	/* Disable BHs the entire time since we normally need to disable them
 	 * at least once for the stats anyway.
@@ -366,10 +366,11 @@
 
 void nf_conntrack_hash_insert(struct nf_conn *ct)
 {
+	struct net *net = nf_ct_net(ct);
 	unsigned int hash, repl_hash;
 
-	hash = hash_conntrack(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
-	repl_hash = hash_conntrack(&ct->tuplehash[IP_CT_DIR_REPLY].tuple);
+	hash = hash_conntrack(net, &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
+	repl_hash = hash_conntrack(net, &ct->tuplehash[IP_CT_DIR_REPLY].tuple);
 
 	__nf_conntrack_hash_insert(ct, hash, repl_hash);
 }
@@ -397,8 +398,8 @@
 	if (CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL)
 		return NF_ACCEPT;
 
-	hash = hash_conntrack(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
-	repl_hash = hash_conntrack(&ct->tuplehash[IP_CT_DIR_REPLY].tuple);
+	hash = hash_conntrack(net, &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
+	repl_hash = hash_conntrack(net, &ct->tuplehash[IP_CT_DIR_REPLY].tuple);
 
 	/* We're not in hash table, and we refuse to set up related
 	   connections for unconfirmed conns.  But packet copies and
@@ -468,7 +469,7 @@
 	struct net *net = nf_ct_net(ignored_conntrack);
 	struct nf_conntrack_tuple_hash *h;
 	struct hlist_nulls_node *n;
-	unsigned int hash = hash_conntrack(tuple);
+	unsigned int hash = hash_conntrack(net, tuple);
 
 	/* Disable BHs the entire time since we need to disable them at
 	 * least once for the stats anyway.
@@ -503,7 +504,7 @@
 	int dropped = 0;
 
 	rcu_read_lock();
-	for (i = 0; i < nf_conntrack_htable_size; i++) {
+	for (i = 0; i < net->ct.htable_size; i++) {
 		hlist_nulls_for_each_entry_rcu(h, n, &net->ct.hash[hash],
 					 hnnode) {
 			tmp = nf_ct_tuplehash_to_ctrack(h);
@@ -517,7 +518,8 @@
 			ct = NULL;
 		if (ct || cnt >= NF_CT_EVICTION_RANGE)
 			break;
-		hash = (hash + 1) % nf_conntrack_htable_size;
+
+		hash = (hash + 1) % net->ct.htable_size;
 	}
 	rcu_read_unlock();
 
@@ -551,7 +553,7 @@
 
 	if (nf_conntrack_max &&
 	    unlikely(atomic_read(&net->ct.count) > nf_conntrack_max)) {
-		unsigned int hash = hash_conntrack(orig);
+		unsigned int hash = hash_conntrack(net, orig);
 		if (!early_drop(net, hash)) {
 			atomic_dec(&net->ct.count);
 			if (net_ratelimit())
@@ -566,7 +568,7 @@
 	 * Do not use kmem_cache_zalloc(), as this cache uses
 	 * SLAB_DESTROY_BY_RCU.
 	 */
-	ct = kmem_cache_alloc(nf_conntrack_cachep, gfp);
+	ct = kmem_cache_alloc(net->ct.nf_conntrack_cachep, gfp);
 	if (ct == NULL) {
 		pr_debug("nf_conntrack_alloc: Can't alloc conntrack.\n");
 		atomic_dec(&net->ct.count);
@@ -605,7 +607,7 @@
 	nf_ct_ext_destroy(ct);
 	atomic_dec(&net->ct.count);
 	nf_ct_ext_free(ct);
-	kmem_cache_free(nf_conntrack_cachep, ct);
+	kmem_cache_free(net->ct.nf_conntrack_cachep, ct);
 }
 EXPORT_SYMBOL_GPL(nf_conntrack_free);
 
@@ -1008,7 +1010,7 @@
 	struct hlist_nulls_node *n;
 
 	spin_lock_bh(&nf_conntrack_lock);
-	for (; *bucket < nf_conntrack_htable_size; (*bucket)++) {
+	for (; *bucket < net->ct.htable_size; (*bucket)++) {
 		hlist_nulls_for_each_entry(h, n, &net->ct.hash[*bucket], hnnode) {
 			ct = nf_ct_tuplehash_to_ctrack(h);
 			if (iter(ct, data))
@@ -1107,9 +1109,12 @@
 
 static void nf_conntrack_cleanup_init_net(void)
 {
+	/* wait until all references to nf_conntrack_untracked are dropped */
+	while (atomic_read(&nf_conntrack_untracked.ct_general.use) > 1)
+		schedule();
+
 	nf_conntrack_helper_fini();
 	nf_conntrack_proto_fini();
-	kmem_cache_destroy(nf_conntrack_cachep);
 }
 
 static void nf_conntrack_cleanup_net(struct net *net)
@@ -1121,15 +1126,14 @@
 		schedule();
 		goto i_see_dead_people;
 	}
-	/* wait until all references to nf_conntrack_untracked are dropped */
-	while (atomic_read(&nf_conntrack_untracked.ct_general.use) > 1)
-		schedule();
 
 	nf_ct_free_hashtable(net->ct.hash, net->ct.hash_vmalloc,
-			     nf_conntrack_htable_size);
+			     net->ct.htable_size);
 	nf_conntrack_ecache_fini(net);
 	nf_conntrack_acct_fini(net);
 	nf_conntrack_expect_fini(net);
+	kmem_cache_destroy(net->ct.nf_conntrack_cachep);
+	kfree(net->ct.slabname);
 	free_percpu(net->ct.stat);
 }
 
@@ -1184,10 +1188,12 @@
 {
 	int i, bucket, vmalloced, old_vmalloced;
 	unsigned int hashsize, old_size;
-	int rnd;
 	struct hlist_nulls_head *hash, *old_hash;
 	struct nf_conntrack_tuple_hash *h;
 
+	if (current->nsproxy->net_ns != &init_net)
+		return -EOPNOTSUPP;
+
 	/* On boot, we can set this without any fancy locking. */
 	if (!nf_conntrack_htable_size)
 		return param_set_uint(val, kp);
@@ -1200,33 +1206,29 @@
 	if (!hash)
 		return -ENOMEM;
 
-	/* We have to rehahs for the new table anyway, so we also can
-	 * use a newrandom seed */
-	get_random_bytes(&rnd, sizeof(rnd));
-
 	/* Lookups in the old hash might happen in parallel, which means we
 	 * might get false negatives during connection lookup. New connections
 	 * created because of a false negative won't make it into the hash
 	 * though since that required taking the lock.
 	 */
 	spin_lock_bh(&nf_conntrack_lock);
-	for (i = 0; i < nf_conntrack_htable_size; i++) {
+	for (i = 0; i < init_net.ct.htable_size; i++) {
 		while (!hlist_nulls_empty(&init_net.ct.hash[i])) {
 			h = hlist_nulls_entry(init_net.ct.hash[i].first,
 					struct nf_conntrack_tuple_hash, hnnode);
 			hlist_nulls_del_rcu(&h->hnnode);
-			bucket = __hash_conntrack(&h->tuple, hashsize, rnd);
+			bucket = __hash_conntrack(&h->tuple, hashsize,
+						  nf_conntrack_hash_rnd);
 			hlist_nulls_add_head_rcu(&h->hnnode, &hash[bucket]);
 		}
 	}
-	old_size = nf_conntrack_htable_size;
+	old_size = init_net.ct.htable_size;
 	old_vmalloced = init_net.ct.hash_vmalloc;
 	old_hash = init_net.ct.hash;
 
-	nf_conntrack_htable_size = hashsize;
+	init_net.ct.htable_size = nf_conntrack_htable_size = hashsize;
 	init_net.ct.hash_vmalloc = vmalloced;
 	init_net.ct.hash = hash;
-	nf_conntrack_hash_rnd = rnd;
 	spin_unlock_bh(&nf_conntrack_lock);
 
 	nf_ct_free_hashtable(old_hash, old_vmalloced, old_size);
@@ -1265,15 +1267,6 @@
 	       NF_CONNTRACK_VERSION, nf_conntrack_htable_size,
 	       nf_conntrack_max);
 
-	nf_conntrack_cachep = kmem_cache_create("nf_conntrack",
-						sizeof(struct nf_conn),
-						0, SLAB_DESTROY_BY_RCU, NULL);
-	if (!nf_conntrack_cachep) {
-		printk(KERN_ERR "Unable to create nf_conn slab cache\n");
-		ret = -ENOMEM;
-		goto err_cache;
-	}
-
 	ret = nf_conntrack_proto_init();
 	if (ret < 0)
 		goto err_proto;
@@ -1282,13 +1275,19 @@
 	if (ret < 0)
 		goto err_helper;
 
+	/* Set up fake conntrack: to never be deleted, not in any hashes */
+#ifdef CONFIG_NET_NS
+	nf_conntrack_untracked.ct_net = &init_net;
+#endif
+	atomic_set(&nf_conntrack_untracked.ct_general.use, 1);
+	/*  - and look it like as a confirmed connection */
+	set_bit(IPS_CONFIRMED_BIT, &nf_conntrack_untracked.status);
+
 	return 0;
 
 err_helper:
 	nf_conntrack_proto_fini();
 err_proto:
-	kmem_cache_destroy(nf_conntrack_cachep);
-err_cache:
 	return ret;
 }
 
@@ -1310,7 +1309,24 @@
 		ret = -ENOMEM;
 		goto err_stat;
 	}
-	net->ct.hash = nf_ct_alloc_hashtable(&nf_conntrack_htable_size,
+
+	net->ct.slabname = kasprintf(GFP_KERNEL, "nf_conntrack_%p", net);
+	if (!net->ct.slabname) {
+		ret = -ENOMEM;
+		goto err_slabname;
+	}
+
+	net->ct.nf_conntrack_cachep = kmem_cache_create(net->ct.slabname,
+							sizeof(struct nf_conn), 0,
+							SLAB_DESTROY_BY_RCU, NULL);
+	if (!net->ct.nf_conntrack_cachep) {
+		printk(KERN_ERR "Unable to create nf_conn slab cache\n");
+		ret = -ENOMEM;
+		goto err_cache;
+	}
+
+	net->ct.htable_size = nf_conntrack_htable_size;
+	net->ct.hash = nf_ct_alloc_hashtable(&net->ct.htable_size,
 					     &net->ct.hash_vmalloc, 1);
 	if (!net->ct.hash) {
 		ret = -ENOMEM;
@@ -1327,15 +1343,6 @@
 	if (ret < 0)
 		goto err_ecache;
 
-	/* Set up fake conntrack:
-	    - to never be deleted, not in any hashes */
-#ifdef CONFIG_NET_NS
-	nf_conntrack_untracked.ct_net = &init_net;
-#endif
-	atomic_set(&nf_conntrack_untracked.ct_general.use, 1);
-	/*  - and look it like as a confirmed connection */
-	set_bit(IPS_CONFIRMED_BIT, &nf_conntrack_untracked.status);
-
 	return 0;
 
 err_ecache:
@@ -1344,8 +1351,12 @@
 	nf_conntrack_expect_fini(net);
 err_expect:
 	nf_ct_free_hashtable(net->ct.hash, net->ct.hash_vmalloc,
-			     nf_conntrack_htable_size);
+			     net->ct.htable_size);
 err_hash:
+	kmem_cache_destroy(net->ct.nf_conntrack_cachep);
+err_cache:
+	kfree(net->ct.slabname);
+err_slabname:
 	free_percpu(net->ct.stat);
 err_stat:
 	return ret;
diff -Nur linux-2.6.32-orig/net/netfilter/nf_conntrack_expect.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/nf_conntrack_expect.c
--- linux-2.6.32-orig/net/netfilter/nf_conntrack_expect.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/nf_conntrack_expect.c	2010-11-18 21:05:30.000000000 +0600
@@ -569,7 +569,7 @@
 #endif /* CONFIG_PROC_FS */
 }
 
-module_param_named(expect_hashsize, nf_ct_expect_hsize, uint, 0600);
+module_param_named(expect_hashsize, nf_ct_expect_hsize, uint, 0400);
 
 int nf_conntrack_expect_init(struct net *net)
 {
@@ -577,7 +577,7 @@
 
 	if (net_eq(net, &init_net)) {
 		if (!nf_ct_expect_hsize) {
-			nf_ct_expect_hsize = nf_conntrack_htable_size / 256;
+			nf_ct_expect_hsize = net->ct.htable_size / 256;
 			if (!nf_ct_expect_hsize)
 				nf_ct_expect_hsize = 1;
 		}
diff -Nur linux-2.6.32-orig/net/netfilter/nf_conntrack_ftp.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/nf_conntrack_ftp.c
--- linux-2.6.32-orig/net/netfilter/nf_conntrack_ftp.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/nf_conntrack_ftp.c	2010-11-18 21:05:30.000000000 +0600
@@ -323,24 +323,24 @@
 			  struct nf_ct_ftp_master *info, int dir,
 			  struct sk_buff *skb)
 {
-	unsigned int i, oldest = NUM_SEQ_TO_REMEMBER;
+	unsigned int i, oldest;
 
 	/* Look for oldest: if we find exact match, we're done. */
 	for (i = 0; i < info->seq_aft_nl_num[dir]; i++) {
 		if (info->seq_aft_nl[dir][i] == nl_seq)
 			return;
-
-		if (oldest == info->seq_aft_nl_num[dir] ||
-		    before(info->seq_aft_nl[dir][i],
-			   info->seq_aft_nl[dir][oldest]))
-			oldest = i;
 	}
 
 	if (info->seq_aft_nl_num[dir] < NUM_SEQ_TO_REMEMBER) {
 		info->seq_aft_nl[dir][info->seq_aft_nl_num[dir]++] = nl_seq;
-	} else if (oldest != NUM_SEQ_TO_REMEMBER &&
-		   after(nl_seq, info->seq_aft_nl[dir][oldest])) {
-		info->seq_aft_nl[dir][oldest] = nl_seq;
+	} else {
+		if (before(info->seq_aft_nl[dir][0], info->seq_aft_nl[dir][1]))
+			oldest = 0;
+		else
+			oldest = 1;
+
+		if (after(nl_seq, info->seq_aft_nl[dir][oldest]))
+			info->seq_aft_nl[dir][oldest] = nl_seq;
 	}
 }
 
diff -Nur linux-2.6.32-orig/net/netfilter/nf_conntrack_helper.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/nf_conntrack_helper.c
--- linux-2.6.32-orig/net/netfilter/nf_conntrack_helper.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/nf_conntrack_helper.c	2010-11-18 21:05:30.000000000 +0600
@@ -192,7 +192,7 @@
 	/* Get rid of expecteds, set helpers to NULL. */
 	hlist_nulls_for_each_entry(h, nn, &net->ct.unconfirmed, hnnode)
 		unhelp(h, me);
-	for (i = 0; i < nf_conntrack_htable_size; i++) {
+	for (i = 0; i < net->ct.htable_size; i++) {
 		hlist_nulls_for_each_entry(h, nn, &net->ct.hash[i], hnnode)
 			unhelp(h, me);
 	}
diff -Nur linux-2.6.32-orig/net/netfilter/nf_conntrack_netlink.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/nf_conntrack_netlink.c
--- linux-2.6.32-orig/net/netfilter/nf_conntrack_netlink.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/nf_conntrack_netlink.c	2010-11-18 21:05:30.000000000 +0600
@@ -594,7 +594,7 @@
 
 	rcu_read_lock();
 	last = (struct nf_conn *)cb->args[1];
-	for (; cb->args[0] < nf_conntrack_htable_size; cb->args[0]++) {
+	for (; cb->args[0] < init_net.ct.htable_size; cb->args[0]++) {
 restart:
 		hlist_nulls_for_each_entry_rcu(h, n, &init_net.ct.hash[cb->args[0]],
 					 hnnode) {
diff -Nur linux-2.6.32-orig/net/netfilter/nf_conntrack_standalone.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/nf_conntrack_standalone.c
--- linux-2.6.32-orig/net/netfilter/nf_conntrack_standalone.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/nf_conntrack_standalone.c	2010-11-18 21:05:30.000000000 +0600
@@ -51,7 +51,7 @@
 	struct hlist_nulls_node *n;
 
 	for (st->bucket = 0;
-	     st->bucket < nf_conntrack_htable_size;
+	     st->bucket < net->ct.htable_size;
 	     st->bucket++) {
 		n = rcu_dereference(net->ct.hash[st->bucket].first);
 		if (!is_a_nulls(n))
@@ -69,7 +69,7 @@
 	head = rcu_dereference(head->next);
 	while (is_a_nulls(head)) {
 		if (likely(get_nulls_value(head) == st->bucket)) {
-			if (++st->bucket >= nf_conntrack_htable_size)
+			if (++st->bucket >= net->ct.htable_size)
 				return NULL;
 		}
 		head = rcu_dereference(net->ct.hash[st->bucket].first);
@@ -358,7 +358,7 @@
 	{
 		.ctl_name       = NET_NF_CONNTRACK_BUCKETS,
 		.procname       = "nf_conntrack_buckets",
-		.data           = &nf_conntrack_htable_size,
+		.data           = &init_net.ct.htable_size,
 		.maxlen         = sizeof(unsigned int),
 		.mode           = 0444,
 		.proc_handler   = proc_dointvec,
@@ -429,6 +429,7 @@
 		goto out_kmemdup;
 
 	table[1].data = &net->ct.count;
+	table[2].data = &net->ct.htable_size;
 	table[3].data = &net->ct.sysctl_checksum;
 	table[4].data = &net->ct.sysctl_log_invalid;
 
diff -Nur linux-2.6.32-orig/net/netfilter/xt_CONNMARK.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_CONNMARK.c
--- linux-2.6.32-orig/net/netfilter/xt_CONNMARK.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_CONNMARK.c	2010-11-18 21:05:30.000000000 +0600
@@ -1,5 +1,5 @@
 /*
- *	xt_CONNMARK - Netfilter module to modify the connection mark values
+ *	xt_connmark - Netfilter module to match connection mark values
  *
  *	Copyright (C) 2002,2004 MARA Systems AB <http://www.marasystems.com>
  *	by Henrik Nordstrom <hno@marasystems.com>
@@ -20,60 +20,34 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
+
 #include <linux/module.h>
 #include <linux/skbuff.h>
-#include <linux/ip.h>
-#include <net/checksum.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_connmark.h>
 
 MODULE_AUTHOR("Henrik Nordstrom <hno@marasystems.com>");
-MODULE_DESCRIPTION("Xtables: connection mark modification");
+MODULE_DESCRIPTION("Xtables: connection mark match");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("ipt_CONNMARK");
-MODULE_ALIAS("ip6t_CONNMARK");
-
-#include <linux/netfilter/x_tables.h>
-#include <linux/netfilter/xt_CONNMARK.h>
-#include <net/netfilter/nf_conntrack_ecache.h>
+MODULE_ALIAS("ipt_connmark");
+MODULE_ALIAS("ip6t_connmark");
 
-static unsigned int
-connmark_tg(struct sk_buff *skb, const struct xt_target_param *par)
+static bool
+connmark_mt(const struct sk_buff *skb, const struct xt_match_param *par)
 {
-	const struct xt_connmark_tginfo1 *info = par->targinfo;
+	const struct xt_connmark_mtinfo1 *info = par->matchinfo;
 	enum ip_conntrack_info ctinfo;
-	struct nf_conn *ct;
-	u_int32_t newmark;
+	const struct nf_conn *ct;
 
 	ct = nf_ct_get(skb, &ctinfo);
 	if (ct == NULL)
-		return XT_CONTINUE;
-
-	switch (info->mode) {
-	case XT_CONNMARK_SET:
-		newmark = (ct->mark & ~info->ctmask) ^ info->ctmark;
-		if (ct->mark != newmark) {
-			ct->mark = newmark;
-			nf_conntrack_event_cache(IPCT_MARK, ct);
-		}
-		break;
-	case XT_CONNMARK_SAVE:
-		newmark = (ct->mark & ~info->ctmask) ^
-		          (skb->mark & info->nfmask);
-		if (ct->mark != newmark) {
-			ct->mark = newmark;
-			nf_conntrack_event_cache(IPCT_MARK, ct);
-		}
-		break;
-	case XT_CONNMARK_RESTORE:
-		newmark = (skb->mark & ~info->nfmask) ^
-		          (ct->mark & info->ctmask);
-		skb->mark = newmark;
-		break;
-	}
+		return false;
 
-	return XT_CONTINUE;
+	return ((ct->mark & info->mask) == info->mark) ^ info->invert;
 }
 
-static bool connmark_tg_check(const struct xt_tgchk_param *par)
+static bool connmark_mt_check(const struct xt_mtchk_param *par)
 {
 	if (nf_ct_l3proto_try_module_get(par->family) < 0) {
 		printk(KERN_WARNING "cannot load conntrack support for "
@@ -83,31 +57,31 @@
 	return true;
 }
 
-static void connmark_tg_destroy(const struct xt_tgdtor_param *par)
+static void connmark_mt_destroy(const struct xt_mtdtor_param *par)
 {
 	nf_ct_l3proto_module_put(par->family);
 }
 
-static struct xt_target connmark_tg_reg __read_mostly = {
-	.name           = "CONNMARK",
+static struct xt_match connmark_mt_reg __read_mostly = {
+	.name           = "connmark",
 	.revision       = 1,
 	.family         = NFPROTO_UNSPEC,
-	.checkentry     = connmark_tg_check,
-	.target         = connmark_tg,
-	.targetsize     = sizeof(struct xt_connmark_tginfo1),
-	.destroy        = connmark_tg_destroy,
+	.checkentry     = connmark_mt_check,
+	.match          = connmark_mt,
+	.matchsize      = sizeof(struct xt_connmark_mtinfo1),
+	.destroy        = connmark_mt_destroy,
 	.me             = THIS_MODULE,
 };
 
-static int __init connmark_tg_init(void)
+static int __init connmark_mt_init(void)
 {
-	return xt_register_target(&connmark_tg_reg);
+	return xt_register_match(&connmark_mt_reg);
 }
 
-static void __exit connmark_tg_exit(void)
+static void __exit connmark_mt_exit(void)
 {
-	xt_unregister_target(&connmark_tg_reg);
+	xt_unregister_match(&connmark_mt_reg);
 }
 
-module_init(connmark_tg_init);
-module_exit(connmark_tg_exit);
+module_init(connmark_mt_init);
+module_exit(connmark_mt_exit);
diff -Nur linux-2.6.32-orig/net/netfilter/xt_conntrack.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_conntrack.c
--- linux-2.6.32-orig/net/netfilter/xt_conntrack.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_conntrack.c	2010-11-18 21:05:30.000000000 +0600
@@ -113,7 +113,8 @@
 }
 
 static bool
-conntrack_mt(const struct sk_buff *skb, const struct xt_match_param *par)
+conntrack_mt(const struct sk_buff *skb, const struct xt_match_param *par,
+             u16 state_mask, u16 status_mask)
 {
 	const struct xt_conntrack_mtinfo2 *info = par->matchinfo;
 	enum ip_conntrack_info ctinfo;
@@ -136,7 +137,7 @@
 			if (test_bit(IPS_DST_NAT_BIT, &ct->status))
 				statebit |= XT_CONNTRACK_STATE_DNAT;
 		}
-		if (!!(info->state_mask & statebit) ^
+		if (!!(state_mask & statebit) ^
 		    !(info->invert_flags & XT_CONNTRACK_STATE))
 			return false;
 	}
@@ -172,7 +173,7 @@
 		return false;
 
 	if ((info->match_flags & XT_CONNTRACK_STATUS) &&
-	    (!!(info->status_mask & ct->status) ^
+	    (!!(status_mask & ct->status) ^
 	    !(info->invert_flags & XT_CONNTRACK_STATUS)))
 		return false;
 
@@ -192,11 +193,17 @@
 static bool
 conntrack_mt_v1(const struct sk_buff *skb, const struct xt_match_param *par)
 {
-	const struct xt_conntrack_mtinfo2 *const *info = par->matchinfo;
-	struct xt_match_param newpar = *par;
+	const struct xt_conntrack_mtinfo1 *info = par->matchinfo;
 
-	newpar.matchinfo = *info;
-	return conntrack_mt(skb, &newpar);
+	return conntrack_mt(skb, par, info->state_mask, info->status_mask);
+}
+
+static bool
+conntrack_mt_v2(const struct sk_buff *skb, const struct xt_match_param *par)
+{
+	const struct xt_conntrack_mtinfo2 *info = par->matchinfo;
+
+	return conntrack_mt(skb, par, info->state_mask, info->status_mask);
 }
 
 static bool conntrack_mt_check(const struct xt_mtchk_param *par)
@@ -209,45 +216,11 @@
 	return true;
 }
 
-static bool conntrack_mt_check_v1(const struct xt_mtchk_param *par)
-{
-	struct xt_conntrack_mtinfo1 *info = par->matchinfo;
-	struct xt_conntrack_mtinfo2 *up;
-	int ret = conntrack_mt_check(par);
-
-	if (ret < 0)
-		return ret;
-
-	up = kmalloc(sizeof(*up), GFP_KERNEL);
-	if (up == NULL) {
-		nf_ct_l3proto_module_put(par->family);
-		return -ENOMEM;
-	}
-
-	/*
-	 * The strategy here is to minimize the overhead of v1 matching,
-	 * by prebuilding a v2 struct and putting the pointer into the
-	 * v1 dataspace.
-	 */
-	memcpy(up, info, offsetof(typeof(*info), state_mask));
-	up->state_mask  = info->state_mask;
-	up->status_mask = info->status_mask;
-	*(void **)info  = up;
-	return true;
-}
-
 static void conntrack_mt_destroy(const struct xt_mtdtor_param *par)
 {
 	nf_ct_l3proto_module_put(par->family);
 }
 
-static void conntrack_mt_destroy_v1(const struct xt_mtdtor_param *par)
-{
-	struct xt_conntrack_mtinfo2 **info = par->matchinfo;
-	kfree(*info);
-	conntrack_mt_destroy(par);
-}
-
 static struct xt_match conntrack_mt_reg[] __read_mostly = {
 	{
 		.name       = "conntrack",
@@ -255,8 +228,8 @@
 		.family     = NFPROTO_UNSPEC,
 		.matchsize  = sizeof(struct xt_conntrack_mtinfo1),
 		.match      = conntrack_mt_v1,
-		.checkentry = conntrack_mt_check_v1,
-		.destroy    = conntrack_mt_destroy_v1,
+		.checkentry = conntrack_mt_check,
+		.destroy    = conntrack_mt_destroy,
 		.me         = THIS_MODULE,
 	},
 	{
@@ -264,7 +237,7 @@
 		.revision   = 2,
 		.family     = NFPROTO_UNSPEC,
 		.matchsize  = sizeof(struct xt_conntrack_mtinfo2),
-		.match      = conntrack_mt,
+		.match      = conntrack_mt_v2,
 		.checkentry = conntrack_mt_check,
 		.destroy    = conntrack_mt_destroy,
 		.me         = THIS_MODULE,
diff -Nur linux-2.6.32-orig/net/netfilter/xt_DSCP.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_DSCP.c
--- linux-2.6.32-orig/net/netfilter/xt_DSCP.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_DSCP.c	2010-11-18 21:05:30.000000000 +0600
@@ -1,14 +1,11 @@
-/* x_tables module for setting the IPv4/IPv6 DSCP field, Version 1.8
+/* IP tables module for matching the value of the IPv4/IPv6 DSCP field
  *
  * (C) 2002 by Harald Welte <laforge@netfilter.org>
- * based on ipt_FTOS.c (C) 2000 by Matthew G. Marsh <mgm@paktronix.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
- *
- * See RFC2474 for a description of the DSCP field within the IP Header.
-*/
+ */
 
 #include <linux/module.h>
 #include <linux/skbuff.h>
@@ -17,148 +14,102 @@
 #include <net/dsfield.h>
 
 #include <linux/netfilter/x_tables.h>
-#include <linux/netfilter/xt_DSCP.h>
+#include <linux/netfilter/xt_dscp.h>
 
 MODULE_AUTHOR("Harald Welte <laforge@netfilter.org>");
-MODULE_DESCRIPTION("Xtables: DSCP/TOS field modification");
+MODULE_DESCRIPTION("Xtables: DSCP/TOS field match");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("ipt_DSCP");
-MODULE_ALIAS("ip6t_DSCP");
-MODULE_ALIAS("ipt_TOS");
-MODULE_ALIAS("ip6t_TOS");
+MODULE_ALIAS("ipt_dscp");
+MODULE_ALIAS("ip6t_dscp");
+MODULE_ALIAS("ipt_tos");
+MODULE_ALIAS("ip6t_tos");
 
-static unsigned int
-dscp_tg(struct sk_buff *skb, const struct xt_target_param *par)
+static bool
+dscp_mt(const struct sk_buff *skb, const struct xt_match_param *par)
 {
-	const struct xt_DSCP_info *dinfo = par->targinfo;
+	const struct xt_dscp_info *info = par->matchinfo;
 	u_int8_t dscp = ipv4_get_dsfield(ip_hdr(skb)) >> XT_DSCP_SHIFT;
 
-	if (dscp != dinfo->dscp) {
-		if (!skb_make_writable(skb, sizeof(struct iphdr)))
-			return NF_DROP;
-
-		ipv4_change_dsfield(ip_hdr(skb), (__u8)(~XT_DSCP_MASK),
-				    dinfo->dscp << XT_DSCP_SHIFT);
-
-	}
-	return XT_CONTINUE;
+	return (dscp == info->dscp) ^ !!info->invert;
 }
 
-static unsigned int
-dscp_tg6(struct sk_buff *skb, const struct xt_target_param *par)
+static bool
+dscp_mt6(const struct sk_buff *skb, const struct xt_match_param *par)
 {
-	const struct xt_DSCP_info *dinfo = par->targinfo;
+	const struct xt_dscp_info *info = par->matchinfo;
 	u_int8_t dscp = ipv6_get_dsfield(ipv6_hdr(skb)) >> XT_DSCP_SHIFT;
 
-	if (dscp != dinfo->dscp) {
-		if (!skb_make_writable(skb, sizeof(struct ipv6hdr)))
-			return NF_DROP;
-
-		ipv6_change_dsfield(ipv6_hdr(skb), (__u8)(~XT_DSCP_MASK),
-				    dinfo->dscp << XT_DSCP_SHIFT);
-	}
-	return XT_CONTINUE;
+	return (dscp == info->dscp) ^ !!info->invert;
 }
 
-static bool dscp_tg_check(const struct xt_tgchk_param *par)
+static bool dscp_mt_check(const struct xt_mtchk_param *par)
 {
-	const struct xt_DSCP_info *info = par->targinfo;
+	const struct xt_dscp_info *info = par->matchinfo;
 
 	if (info->dscp > XT_DSCP_MAX) {
-		printk(KERN_WARNING "DSCP: dscp %x out of range\n", info->dscp);
+		printk(KERN_ERR "xt_dscp: dscp %x out of range\n", info->dscp);
 		return false;
 	}
-	return true;
-}
 
-static unsigned int
-tos_tg(struct sk_buff *skb, const struct xt_target_param *par)
-{
-	const struct xt_tos_target_info *info = par->targinfo;
-	struct iphdr *iph = ip_hdr(skb);
-	u_int8_t orig, nv;
-
-	orig = ipv4_get_dsfield(iph);
-	nv   = (orig & ~info->tos_mask) ^ info->tos_value;
-
-	if (orig != nv) {
-		if (!skb_make_writable(skb, sizeof(struct iphdr)))
-			return NF_DROP;
-		iph = ip_hdr(skb);
-		ipv4_change_dsfield(iph, 0, nv);
-	}
-
-	return XT_CONTINUE;
+	return true;
 }
 
-static unsigned int
-tos_tg6(struct sk_buff *skb, const struct xt_target_param *par)
+static bool tos_mt(const struct sk_buff *skb, const struct xt_match_param *par)
 {
-	const struct xt_tos_target_info *info = par->targinfo;
-	struct ipv6hdr *iph = ipv6_hdr(skb);
-	u_int8_t orig, nv;
-
-	orig = ipv6_get_dsfield(iph);
-	nv   = (orig & info->tos_mask) ^ info->tos_value;
-
-	if (orig != nv) {
-		if (!skb_make_writable(skb, sizeof(struct iphdr)))
-			return NF_DROP;
-		iph = ipv6_hdr(skb);
-		ipv6_change_dsfield(iph, 0, nv);
-	}
+	const struct xt_tos_match_info *info = par->matchinfo;
 
-	return XT_CONTINUE;
+	if (par->match->family == NFPROTO_IPV4)
+		return ((ip_hdr(skb)->tos & info->tos_mask) ==
+		       info->tos_value) ^ !!info->invert;
+	else
+		return ((ipv6_get_dsfield(ipv6_hdr(skb)) & info->tos_mask) ==
+		       info->tos_value) ^ !!info->invert;
 }
 
-static struct xt_target dscp_tg_reg[] __read_mostly = {
+static struct xt_match dscp_mt_reg[] __read_mostly = {
 	{
-		.name		= "DSCP",
+		.name		= "dscp",
 		.family		= NFPROTO_IPV4,
-		.checkentry	= dscp_tg_check,
-		.target		= dscp_tg,
-		.targetsize	= sizeof(struct xt_DSCP_info),
-		.table		= "mangle",
+		.checkentry	= dscp_mt_check,
+		.match		= dscp_mt,
+		.matchsize	= sizeof(struct xt_dscp_info),
 		.me		= THIS_MODULE,
 	},
 	{
-		.name		= "DSCP",
+		.name		= "dscp",
 		.family		= NFPROTO_IPV6,
-		.checkentry	= dscp_tg_check,
-		.target		= dscp_tg6,
-		.targetsize	= sizeof(struct xt_DSCP_info),
-		.table		= "mangle",
+		.checkentry	= dscp_mt_check,
+		.match		= dscp_mt6,
+		.matchsize	= sizeof(struct xt_dscp_info),
 		.me		= THIS_MODULE,
 	},
 	{
-		.name		= "TOS",
+		.name		= "tos",
 		.revision	= 1,
 		.family		= NFPROTO_IPV4,
-		.table		= "mangle",
-		.target		= tos_tg,
-		.targetsize	= sizeof(struct xt_tos_target_info),
+		.match		= tos_mt,
+		.matchsize	= sizeof(struct xt_tos_match_info),
 		.me		= THIS_MODULE,
 	},
 	{
-		.name		= "TOS",
+		.name		= "tos",
 		.revision	= 1,
 		.family		= NFPROTO_IPV6,
-		.table		= "mangle",
-		.target		= tos_tg6,
-		.targetsize	= sizeof(struct xt_tos_target_info),
+		.match		= tos_mt,
+		.matchsize	= sizeof(struct xt_tos_match_info),
 		.me		= THIS_MODULE,
 	},
 };
 
-static int __init dscp_tg_init(void)
+static int __init dscp_mt_init(void)
 {
-	return xt_register_targets(dscp_tg_reg, ARRAY_SIZE(dscp_tg_reg));
+	return xt_register_matches(dscp_mt_reg, ARRAY_SIZE(dscp_mt_reg));
 }
 
-static void __exit dscp_tg_exit(void)
+static void __exit dscp_mt_exit(void)
 {
-	xt_unregister_targets(dscp_tg_reg, ARRAY_SIZE(dscp_tg_reg));
+	xt_unregister_matches(dscp_mt_reg, ARRAY_SIZE(dscp_mt_reg));
 }
 
-module_init(dscp_tg_init);
-module_exit(dscp_tg_exit);
+module_init(dscp_mt_init);
+module_exit(dscp_mt_exit);
diff -Nur linux-2.6.32-orig/net/netfilter/xt_HL.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_HL.c
--- linux-2.6.32-orig/net/netfilter/xt_HL.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_HL.c	2010-11-18 21:05:30.000000000 +0600
@@ -1,171 +1,108 @@
 /*
- * TTL modification target for IP tables
- * (C) 2000,2005 by Harald Welte <laforge@netfilter.org>
+ * IP tables module for matching the value of the TTL
+ * (C) 2000,2001 by Harald Welte <laforge@netfilter.org>
  *
- * Hop Limit modification target for ip6tables
- * Maciej Soltysiak <solt@dns.toxicfilms.tv>
+ * Hop Limit matching module
+ * (C) 2001-2002 Maciej Soltysiak <solt@dns.toxicfilms.tv>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
 
-#include <linux/module.h>
-#include <linux/skbuff.h>
 #include <linux/ip.h>
 #include <linux/ipv6.h>
-#include <net/checksum.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
 
 #include <linux/netfilter/x_tables.h>
-#include <linux/netfilter_ipv4/ipt_TTL.h>
-#include <linux/netfilter_ipv6/ip6t_HL.h>
+#include <linux/netfilter_ipv4/ipt_ttl.h>
+#include <linux/netfilter_ipv6/ip6t_hl.h>
 
-MODULE_AUTHOR("Harald Welte <laforge@netfilter.org>");
 MODULE_AUTHOR("Maciej Soltysiak <solt@dns.toxicfilms.tv>");
-MODULE_DESCRIPTION("Xtables: Hoplimit/TTL Limit field modification target");
+MODULE_DESCRIPTION("Xtables: Hoplimit/TTL field match");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_ttl");
+MODULE_ALIAS("ip6t_hl");
 
-static unsigned int
-ttl_tg(struct sk_buff *skb, const struct xt_target_param *par)
+static bool ttl_mt(const struct sk_buff *skb, const struct xt_match_param *par)
 {
-	struct iphdr *iph;
-	const struct ipt_TTL_info *info = par->targinfo;
-	int new_ttl;
-
-	if (!skb_make_writable(skb, skb->len))
-		return NF_DROP;
-
-	iph = ip_hdr(skb);
+	const struct ipt_ttl_info *info = par->matchinfo;
+	const u8 ttl = ip_hdr(skb)->ttl;
 
 	switch (info->mode) {
-		case IPT_TTL_SET:
-			new_ttl = info->ttl;
-			break;
-		case IPT_TTL_INC:
-			new_ttl = iph->ttl + info->ttl;
-			if (new_ttl > 255)
-				new_ttl = 255;
-			break;
-		case IPT_TTL_DEC:
-			new_ttl = iph->ttl - info->ttl;
-			if (new_ttl < 0)
-				new_ttl = 0;
-			break;
+		case IPT_TTL_EQ:
+			return ttl == info->ttl;
+		case IPT_TTL_NE:
+			return ttl != info->ttl;
+		case IPT_TTL_LT:
+			return ttl < info->ttl;
+		case IPT_TTL_GT:
+			return ttl > info->ttl;
 		default:
-			new_ttl = iph->ttl;
-			break;
+			printk(KERN_WARNING "ipt_ttl: unknown mode %d\n",
+				info->mode);
+			return false;
 	}
 
-	if (new_ttl != iph->ttl) {
-		csum_replace2(&iph->check, htons(iph->ttl << 8),
-					   htons(new_ttl << 8));
-		iph->ttl = new_ttl;
-	}
-
-	return XT_CONTINUE;
+	return false;
 }
 
-static unsigned int
-hl_tg6(struct sk_buff *skb, const struct xt_target_param *par)
+static bool hl_mt6(const struct sk_buff *skb, const struct xt_match_param *par)
 {
-	struct ipv6hdr *ip6h;
-	const struct ip6t_HL_info *info = par->targinfo;
-	int new_hl;
-
-	if (!skb_make_writable(skb, skb->len))
-		return NF_DROP;
-
-	ip6h = ipv6_hdr(skb);
+	const struct ip6t_hl_info *info = par->matchinfo;
+	const struct ipv6hdr *ip6h = ipv6_hdr(skb);
 
 	switch (info->mode) {
-		case IP6T_HL_SET:
-			new_hl = info->hop_limit;
+		case IP6T_HL_EQ:
+			return ip6h->hop_limit == info->hop_limit;
 			break;
-		case IP6T_HL_INC:
-			new_hl = ip6h->hop_limit + info->hop_limit;
-			if (new_hl > 255)
-				new_hl = 255;
+		case IP6T_HL_NE:
+			return ip6h->hop_limit != info->hop_limit;
 			break;
-		case IP6T_HL_DEC:
-			new_hl = ip6h->hop_limit - info->hop_limit;
-			if (new_hl < 0)
-				new_hl = 0;
+		case IP6T_HL_LT:
+			return ip6h->hop_limit < info->hop_limit;
 			break;
-		default:
-			new_hl = ip6h->hop_limit;
+		case IP6T_HL_GT:
+			return ip6h->hop_limit > info->hop_limit;
 			break;
+		default:
+			printk(KERN_WARNING "ip6t_hl: unknown mode %d\n",
+				info->mode);
+			return false;
 	}
 
-	ip6h->hop_limit = new_hl;
-
-	return XT_CONTINUE;
-}
-
-static bool ttl_tg_check(const struct xt_tgchk_param *par)
-{
-	const struct ipt_TTL_info *info = par->targinfo;
-
-	if (info->mode > IPT_TTL_MAXMODE) {
-		printk(KERN_WARNING "ipt_TTL: invalid or unknown Mode %u\n",
-			info->mode);
-		return false;
-	}
-	if (info->mode != IPT_TTL_SET && info->ttl == 0)
-		return false;
-	return true;
-}
-
-static bool hl_tg6_check(const struct xt_tgchk_param *par)
-{
-	const struct ip6t_HL_info *info = par->targinfo;
-
-	if (info->mode > IP6T_HL_MAXMODE) {
-		printk(KERN_WARNING "ip6t_HL: invalid or unknown Mode %u\n",
-			info->mode);
-		return false;
-	}
-	if (info->mode != IP6T_HL_SET && info->hop_limit == 0) {
-		printk(KERN_WARNING "ip6t_HL: increment/decrement doesn't "
-			"make sense with value 0\n");
-		return false;
-	}
-	return true;
+	return false;
 }
 
-static struct xt_target hl_tg_reg[] __read_mostly = {
+static struct xt_match hl_mt_reg[] __read_mostly = {
 	{
-		.name       = "TTL",
+		.name       = "ttl",
 		.revision   = 0,
 		.family     = NFPROTO_IPV4,
-		.target     = ttl_tg,
-		.targetsize = sizeof(struct ipt_TTL_info),
-		.table      = "mangle",
-		.checkentry = ttl_tg_check,
+		.match      = ttl_mt,
+		.matchsize  = sizeof(struct ipt_ttl_info),
 		.me         = THIS_MODULE,
 	},
 	{
-		.name       = "HL",
+		.name       = "hl",
 		.revision   = 0,
 		.family     = NFPROTO_IPV6,
-		.target     = hl_tg6,
-		.targetsize = sizeof(struct ip6t_HL_info),
-		.table      = "mangle",
-		.checkentry = hl_tg6_check,
+		.match      = hl_mt6,
+		.matchsize  = sizeof(struct ip6t_hl_info),
 		.me         = THIS_MODULE,
 	},
 };
 
-static int __init hl_tg_init(void)
+static int __init hl_mt_init(void)
 {
-	return xt_register_targets(hl_tg_reg, ARRAY_SIZE(hl_tg_reg));
+	return xt_register_matches(hl_mt_reg, ARRAY_SIZE(hl_mt_reg));
 }
 
-static void __exit hl_tg_exit(void)
+static void __exit hl_mt_exit(void)
 {
-	xt_unregister_targets(hl_tg_reg, ARRAY_SIZE(hl_tg_reg));
+	xt_unregister_matches(hl_mt_reg, ARRAY_SIZE(hl_mt_reg));
 }
 
-module_init(hl_tg_init);
-module_exit(hl_tg_exit);
-MODULE_ALIAS("ipt_TTL");
-MODULE_ALIAS("ip6t_HL");
+module_init(hl_mt_init);
+module_exit(hl_mt_exit);
diff -Nur linux-2.6.32-orig/net/netfilter/xt_MARK.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_MARK.c
--- linux-2.6.32-orig/net/netfilter/xt_MARK.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_MARK.c	2010-11-18 21:05:30.000000000 +0600
@@ -1,9 +1,9 @@
 /*
- *	xt_MARK - Netfilter module to modify the NFMARK field of an skb
+ *	xt_mark - Netfilter module to match NFMARK value
  *
  *	(C) 1999-2001 Marc Boucher <marc@mbsi.ca>
  *	Copyright  CC Computer Consultants GmbH, 2007 - 2008
- *	Jan Engelhardt <jengelh@computergmbh.de>
+ *	Jan Engelhardt <jengelh@medozas.de>
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License version 2 as
@@ -12,45 +12,42 @@
 
 #include <linux/module.h>
 #include <linux/skbuff.h>
-#include <linux/ip.h>
-#include <net/checksum.h>
 
+#include <linux/netfilter/xt_mark.h>
 #include <linux/netfilter/x_tables.h>
-#include <linux/netfilter/xt_MARK.h>
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Marc Boucher <marc@mbsi.ca>");
-MODULE_DESCRIPTION("Xtables: packet mark modification");
-MODULE_ALIAS("ipt_MARK");
-MODULE_ALIAS("ip6t_MARK");
+MODULE_DESCRIPTION("Xtables: packet mark match");
+MODULE_ALIAS("ipt_mark");
+MODULE_ALIAS("ip6t_mark");
 
-static unsigned int
-mark_tg(struct sk_buff *skb, const struct xt_target_param *par)
+static bool
+mark_mt(const struct sk_buff *skb, const struct xt_match_param *par)
 {
-	const struct xt_mark_tginfo2 *info = par->targinfo;
+	const struct xt_mark_mtinfo1 *info = par->matchinfo;
 
-	skb->mark = (skb->mark & ~info->mask) ^ info->mark;
-	return XT_CONTINUE;
+	return ((skb->mark & info->mask) == info->mark) ^ info->invert;
 }
 
-static struct xt_target mark_tg_reg __read_mostly = {
-	.name           = "MARK",
-	.revision       = 2,
+static struct xt_match mark_mt_reg __read_mostly = {
+	.name           = "mark",
+	.revision       = 1,
 	.family         = NFPROTO_UNSPEC,
-	.target         = mark_tg,
-	.targetsize     = sizeof(struct xt_mark_tginfo2),
+	.match          = mark_mt,
+	.matchsize      = sizeof(struct xt_mark_mtinfo1),
 	.me             = THIS_MODULE,
 };
 
-static int __init mark_tg_init(void)
+static int __init mark_mt_init(void)
 {
-	return xt_register_target(&mark_tg_reg);
+	return xt_register_match(&mark_mt_reg);
 }
 
-static void __exit mark_tg_exit(void)
+static void __exit mark_mt_exit(void)
 {
-	xt_unregister_target(&mark_tg_reg);
+	xt_unregister_match(&mark_mt_reg);
 }
 
-module_init(mark_tg_init);
-module_exit(mark_tg_exit);
+module_init(mark_mt_init);
+module_exit(mark_mt_exit);
diff -Nur linux-2.6.32-orig/net/netfilter/xt_RATEEST.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_RATEEST.c
--- linux-2.6.32-orig/net/netfilter/xt_RATEEST.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_RATEEST.c	2010-11-18 21:05:30.000000000 +0600
@@ -8,176 +8,149 @@
 #include <linux/module.h>
 #include <linux/skbuff.h>
 #include <linux/gen_stats.h>
-#include <linux/jhash.h>
-#include <linux/rtnetlink.h>
-#include <linux/random.h>
-#include <net/gen_stats.h>
-#include <net/netlink.h>
 
 #include <linux/netfilter/x_tables.h>
-#include <linux/netfilter/xt_RATEEST.h>
+#include <linux/netfilter/xt_rateest.h>
 #include <net/netfilter/xt_rateest.h>
 
-static DEFINE_MUTEX(xt_rateest_mutex);
 
-#define RATEEST_HSIZE	16
-static struct hlist_head rateest_hash[RATEEST_HSIZE] __read_mostly;
-static unsigned int jhash_rnd __read_mostly;
-
-static unsigned int xt_rateest_hash(const char *name)
+static bool
+xt_rateest_mt(const struct sk_buff *skb, const struct xt_match_param *par)
 {
-	return jhash(name, FIELD_SIZEOF(struct xt_rateest, name), jhash_rnd) &
-	       (RATEEST_HSIZE - 1);
-}
-
-static void xt_rateest_hash_insert(struct xt_rateest *est)
-{
-	unsigned int h;
-
-	h = xt_rateest_hash(est->name);
-	hlist_add_head(&est->list, &rateest_hash[h]);
-}
+	const struct xt_rateest_match_info *info = par->matchinfo;
+	struct gnet_stats_rate_est *r;
+	u_int32_t bps1, bps2, pps1, pps2;
+	bool ret = true;
+
+	spin_lock_bh(&info->est1->lock);
+	r = &info->est1->rstats;
+	if (info->flags & XT_RATEEST_MATCH_DELTA) {
+		bps1 = info->bps1 >= r->bps ? info->bps1 - r->bps : 0;
+		pps1 = info->pps1 >= r->pps ? info->pps1 - r->pps : 0;
+	} else {
+		bps1 = r->bps;
+		pps1 = r->pps;
+	}
+	spin_unlock_bh(&info->est1->lock);
 
-struct xt_rateest *xt_rateest_lookup(const char *name)
-{
-	struct xt_rateest *est;
-	struct hlist_node *n;
-	unsigned int h;
-
-	h = xt_rateest_hash(name);
-	mutex_lock(&xt_rateest_mutex);
-	hlist_for_each_entry(est, n, &rateest_hash[h], list) {
-		if (strcmp(est->name, name) == 0) {
-			est->refcnt++;
-			mutex_unlock(&xt_rateest_mutex);
-			return est;
+	if (info->flags & XT_RATEEST_MATCH_ABS) {
+		bps2 = info->bps2;
+		pps2 = info->pps2;
+	} else {
+		spin_lock_bh(&info->est2->lock);
+		r = &info->est2->rstats;
+		if (info->flags & XT_RATEEST_MATCH_DELTA) {
+			bps2 = info->bps2 >= r->bps ? info->bps2 - r->bps : 0;
+			pps2 = info->pps2 >= r->pps ? info->pps2 - r->pps : 0;
+		} else {
+			bps2 = r->bps;
+			pps2 = r->pps;
 		}
+		spin_unlock_bh(&info->est2->lock);
 	}
-	mutex_unlock(&xt_rateest_mutex);
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(xt_rateest_lookup);
 
-void xt_rateest_put(struct xt_rateest *est)
-{
-	mutex_lock(&xt_rateest_mutex);
-	if (--est->refcnt == 0) {
-		hlist_del(&est->list);
-		gen_kill_estimator(&est->bstats, &est->rstats);
-		kfree(est);
+	switch (info->mode) {
+	case XT_RATEEST_MATCH_LT:
+		if (info->flags & XT_RATEEST_MATCH_BPS)
+			ret &= bps1 < bps2;
+		if (info->flags & XT_RATEEST_MATCH_PPS)
+			ret &= pps1 < pps2;
+		break;
+	case XT_RATEEST_MATCH_GT:
+		if (info->flags & XT_RATEEST_MATCH_BPS)
+			ret &= bps1 > bps2;
+		if (info->flags & XT_RATEEST_MATCH_PPS)
+			ret &= pps1 > pps2;
+		break;
+	case XT_RATEEST_MATCH_EQ:
+		if (info->flags & XT_RATEEST_MATCH_BPS)
+			ret &= bps1 == bps2;
+		if (info->flags & XT_RATEEST_MATCH_PPS)
+			ret &= pps1 == pps2;
+		break;
 	}
-	mutex_unlock(&xt_rateest_mutex);
+
+	ret ^= info->flags & XT_RATEEST_MATCH_INVERT ? true : false;
+	return ret;
 }
-EXPORT_SYMBOL_GPL(xt_rateest_put);
 
-static unsigned int
-xt_rateest_tg(struct sk_buff *skb, const struct xt_target_param *par)
+static bool xt_rateest_mt_checkentry(const struct xt_mtchk_param *par)
 {
-	const struct xt_rateest_target_info *info = par->targinfo;
-	struct gnet_stats_basic_packed *stats = &info->est->bstats;
+	struct xt_rateest_match_info *info = par->matchinfo;
+	struct xt_rateest *est1, *est2;
 
-	spin_lock_bh(&info->est->lock);
-	stats->bytes += skb->len;
-	stats->packets++;
-	spin_unlock_bh(&info->est->lock);
+	if (hweight32(info->flags & (XT_RATEEST_MATCH_ABS |
+				     XT_RATEEST_MATCH_REL)) != 1)
+		goto err1;
 
-	return XT_CONTINUE;
-}
+	if (!(info->flags & (XT_RATEEST_MATCH_BPS | XT_RATEEST_MATCH_PPS)))
+		goto err1;
 
-static bool xt_rateest_tg_checkentry(const struct xt_tgchk_param *par)
-{
-	struct xt_rateest_target_info *info = par->targinfo;
-	struct xt_rateest *est;
-	struct {
-		struct nlattr		opt;
-		struct gnet_estimator	est;
-	} cfg;
-
-	est = xt_rateest_lookup(info->name);
-	if (est) {
-		/*
-		 * If estimator parameters are specified, they must match the
-		 * existing estimator.
-		 */
-		if ((!info->interval && !info->ewma_log) ||
-		    (info->interval != est->params.interval ||
-		     info->ewma_log != est->params.ewma_log)) {
-			xt_rateest_put(est);
-			return false;
-		}
-		info->est = est;
-		return true;
+	switch (info->mode) {
+	case XT_RATEEST_MATCH_EQ:
+	case XT_RATEEST_MATCH_LT:
+	case XT_RATEEST_MATCH_GT:
+		break;
+	default:
+		goto err1;
 	}
 
-	est = kzalloc(sizeof(*est), GFP_KERNEL);
-	if (!est)
+	est1 = xt_rateest_lookup(info->name1);
+	if (!est1)
 		goto err1;
 
-	strlcpy(est->name, info->name, sizeof(est->name));
-	spin_lock_init(&est->lock);
-	est->refcnt		= 1;
-	est->params.interval	= info->interval;
-	est->params.ewma_log	= info->ewma_log;
-
-	cfg.opt.nla_len		= nla_attr_size(sizeof(cfg.est));
-	cfg.opt.nla_type	= TCA_STATS_RATE_EST;
-	cfg.est.interval	= info->interval;
-	cfg.est.ewma_log	= info->ewma_log;
-
-	if (gen_new_estimator(&est->bstats, &est->rstats, &est->lock,
-			      &cfg.opt) < 0)
-		goto err2;
+	if (info->flags & XT_RATEEST_MATCH_REL) {
+		est2 = xt_rateest_lookup(info->name2);
+		if (!est2)
+			goto err2;
+	} else
+		est2 = NULL;
 
-	info->est = est;
-	xt_rateest_hash_insert(est);
 
+	info->est1 = est1;
+	info->est2 = est2;
 	return true;
 
 err2:
-	kfree(est);
+	xt_rateest_put(est1);
 err1:
 	return false;
 }
 
-static void xt_rateest_tg_destroy(const struct xt_tgdtor_param *par)
+static void xt_rateest_mt_destroy(const struct xt_mtdtor_param *par)
 {
-	struct xt_rateest_target_info *info = par->targinfo;
+	struct xt_rateest_match_info *info = par->matchinfo;
 
-	xt_rateest_put(info->est);
+	xt_rateest_put(info->est1);
+	if (info->est2)
+		xt_rateest_put(info->est2);
 }
 
-static struct xt_target xt_rateest_tg_reg __read_mostly = {
-	.name       = "RATEEST",
+static struct xt_match xt_rateest_mt_reg __read_mostly = {
+	.name       = "rateest",
 	.revision   = 0,
 	.family     = NFPROTO_UNSPEC,
-	.target     = xt_rateest_tg,
-	.checkentry = xt_rateest_tg_checkentry,
-	.destroy    = xt_rateest_tg_destroy,
-	.targetsize = sizeof(struct xt_rateest_target_info),
+	.match      = xt_rateest_mt,
+	.checkentry = xt_rateest_mt_checkentry,
+	.destroy    = xt_rateest_mt_destroy,
+	.matchsize  = sizeof(struct xt_rateest_match_info),
 	.me         = THIS_MODULE,
 };
 
-static int __init xt_rateest_tg_init(void)
+static int __init xt_rateest_mt_init(void)
 {
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(rateest_hash); i++)
-		INIT_HLIST_HEAD(&rateest_hash[i]);
-
-	get_random_bytes(&jhash_rnd, sizeof(jhash_rnd));
-	return xt_register_target(&xt_rateest_tg_reg);
+	return xt_register_match(&xt_rateest_mt_reg);
 }
 
-static void __exit xt_rateest_tg_fini(void)
+static void __exit xt_rateest_mt_fini(void)
 {
-	xt_unregister_target(&xt_rateest_tg_reg);
+	xt_unregister_match(&xt_rateest_mt_reg);
 }
 
-
 MODULE_AUTHOR("Patrick McHardy <kaber@trash.net>");
 MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("Xtables: packet rate estimator");
-MODULE_ALIAS("ipt_RATEEST");
-MODULE_ALIAS("ip6t_RATEEST");
-module_init(xt_rateest_tg_init);
-module_exit(xt_rateest_tg_fini);
+MODULE_DESCRIPTION("xtables rate estimator match");
+MODULE_ALIAS("ipt_rateest");
+MODULE_ALIAS("ip6t_rateest");
+module_init(xt_rateest_mt_init);
+module_exit(xt_rateest_mt_fini);
diff -Nur linux-2.6.32-orig/net/netfilter/xt_TCPMSS.c iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_TCPMSS.c
--- linux-2.6.32-orig/net/netfilter/xt_TCPMSS.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netfilter/xt_TCPMSS.c	2010-11-18 21:05:30.000000000 +0600
@@ -1,7 +1,7 @@
-/*
- * This is a module which is used for setting the MSS option in TCP packets.
- *
- * Copyright (C) 2000 Marc Boucher <marc@mbsi.ca>
+/* Kernel module to match TCP MSS values. */
+
+/* Copyright (C) 2000 Marc Boucher <marc@mbsi.ca>
+ * Portions (C) 2005 by Harald Welte <laforge@netfilter.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -10,305 +10,101 @@
 
 #include <linux/module.h>
 #include <linux/skbuff.h>
-#include <linux/ip.h>
-#include <linux/ipv6.h>
-#include <linux/tcp.h>
-#include <net/dst.h>
-#include <net/flow.h>
-#include <net/ipv6.h>
-#include <net/route.h>
 #include <net/tcp.h>
 
+#include <linux/netfilter/xt_tcpmss.h>
+#include <linux/netfilter/x_tables.h>
+
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <linux/netfilter_ipv6/ip6_tables.h>
-#include <linux/netfilter/x_tables.h>
-#include <linux/netfilter/xt_tcpudp.h>
-#include <linux/netfilter/xt_TCPMSS.h>
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Marc Boucher <marc@mbsi.ca>");
-MODULE_DESCRIPTION("Xtables: TCP Maximum Segment Size (MSS) adjustment");
-MODULE_ALIAS("ipt_TCPMSS");
-MODULE_ALIAS("ip6t_TCPMSS");
-
-static inline unsigned int
-optlen(const u_int8_t *opt, unsigned int offset)
-{
-	/* Beware zero-length options: make finite progress */
-	if (opt[offset] <= TCPOPT_NOP || opt[offset+1] == 0)
-		return 1;
-	else
-		return opt[offset+1];
-}
+MODULE_DESCRIPTION("Xtables: TCP MSS match");
+MODULE_ALIAS("ipt_tcpmss");
+MODULE_ALIAS("ip6t_tcpmss");
+
+static bool
+tcpmss_mt(const struct sk_buff *skb, const struct xt_match_param *par)
+{
+	const struct xt_tcpmss_match_info *info = par->matchinfo;
+	const struct tcphdr *th;
+	struct tcphdr _tcph;
+	/* tcp.doff is only 4 bits, ie. max 15 * 4 bytes */
+	const u_int8_t *op;
+	u8 _opt[15 * 4 - sizeof(_tcph)];
+	unsigned int i, optlen;
+
+	/* If we don't have the whole header, drop packet. */
+	th = skb_header_pointer(skb, par->thoff, sizeof(_tcph), &_tcph);
+	if (th == NULL)
+		goto dropit;
+
+	/* Malformed. */
+	if (th->doff*4 < sizeof(*th))
+		goto dropit;
+
+	optlen = th->doff*4 - sizeof(*th);
+	if (!optlen)
+		goto out;
+
+	/* Truncated options. */
+	op = skb_header_pointer(skb, par->thoff + sizeof(*th), optlen, _opt);
+	if (op == NULL)
+		goto dropit;
+
+	for (i = 0; i < optlen; ) {
+		if (op[i] == TCPOPT_MSS
+		    && (optlen - i) >= TCPOLEN_MSS
+		    && op[i+1] == TCPOLEN_MSS) {
+			u_int16_t mssval;
 
-static int
-tcpmss_mangle_packet(struct sk_buff *skb,
-		     const struct xt_tcpmss_info *info,
-		     unsigned int in_mtu,
-		     unsigned int tcphoff,
-		     unsigned int minlen)
-{
-	struct tcphdr *tcph;
-	unsigned int tcplen, i;
-	__be16 oldval;
-	u16 newmss;
-	u8 *opt;
-
-	if (!skb_make_writable(skb, skb->len))
-		return -1;
-
-	tcplen = skb->len - tcphoff;
-	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
-
-	/* Since it passed flags test in tcp match, we know it is is
-	   not a fragment, and has data >= tcp header length.  SYN
-	   packets should not contain data: if they did, then we risk
-	   running over MTU, sending Frag Needed and breaking things
-	   badly. --RR */
-	if (tcplen != tcph->doff*4) {
-		if (net_ratelimit())
-			printk(KERN_ERR "xt_TCPMSS: bad length (%u bytes)\n",
-			       skb->len);
-		return -1;
-	}
+			mssval = (op[i+2] << 8) | op[i+3];
 
-	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
-		if (dst_mtu(skb_dst(skb)) <= minlen) {
-			if (net_ratelimit())
-				printk(KERN_ERR "xt_TCPMSS: "
-				       "unknown or invalid path-MTU (%u)\n",
-				       dst_mtu(skb_dst(skb)));
-			return -1;
-		}
-		if (in_mtu <= minlen) {
-			if (net_ratelimit())
-				printk(KERN_ERR "xt_TCPMSS: unknown or "
-				       "invalid path-MTU (%u)\n", in_mtu);
-			return -1;
-		}
-		newmss = min(dst_mtu(skb_dst(skb)), in_mtu) - minlen;
-	} else
-		newmss = info->mss;
-
-	opt = (u_int8_t *)tcph;
-	for (i = sizeof(struct tcphdr); i < tcph->doff*4; i += optlen(opt, i)) {
-		if (opt[i] == TCPOPT_MSS && tcph->doff*4 - i >= TCPOLEN_MSS &&
-		    opt[i+1] == TCPOLEN_MSS) {
-			u_int16_t oldmss;
-
-			oldmss = (opt[i+2] << 8) | opt[i+3];
-
-			/* Never increase MSS, even when setting it, as
-			 * doing so results in problems for hosts that rely
-			 * on MSS being set correctly.
-			 */
-			if (oldmss <= newmss)
-				return 0;
-
-			opt[i+2] = (newmss & 0xff00) >> 8;
-			opt[i+3] = newmss & 0x00ff;
-
-			inet_proto_csum_replace2(&tcph->check, skb,
-						 htons(oldmss), htons(newmss),
-						 0);
-			return 0;
+			return (mssval >= info->mss_min &&
+				mssval <= info->mss_max) ^ info->invert;
 		}
+		if (op[i] < 2)
+			i++;
+		else
+			i += op[i+1] ? : 1;
 	}
+out:
+	return info->invert;
 
-	/*
-	 * MSS Option not found ?! add it..
-	 */
-	if (skb_tailroom(skb) < TCPOLEN_MSS) {
-		if (pskb_expand_head(skb, 0,
-				     TCPOLEN_MSS - skb_tailroom(skb),
-				     GFP_ATOMIC))
-			return -1;
-		tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
-	}
-
-	skb_put(skb, TCPOLEN_MSS);
-
-	opt = (u_int8_t *)tcph + sizeof(struct tcphdr);
-	memmove(opt + TCPOLEN_MSS, opt, tcplen - sizeof(struct tcphdr));
-
-	inet_proto_csum_replace2(&tcph->check, skb,
-				 htons(tcplen), htons(tcplen + TCPOLEN_MSS), 1);
-	opt[0] = TCPOPT_MSS;
-	opt[1] = TCPOLEN_MSS;
-	opt[2] = (newmss & 0xff00) >> 8;
-	opt[3] = newmss & 0x00ff;
-
-	inet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), 0);
-
-	oldval = ((__be16 *)tcph)[6];
-	tcph->doff += TCPOLEN_MSS/4;
-	inet_proto_csum_replace2(&tcph->check, skb,
-				 oldval, ((__be16 *)tcph)[6], 0);
-	return TCPOLEN_MSS;
-}
-
-static u_int32_t tcpmss_reverse_mtu(const struct sk_buff *skb,
-				    unsigned int family)
-{
-	struct flowi fl = {};
-	const struct nf_afinfo *ai;
-	struct rtable *rt = NULL;
-	u_int32_t mtu     = ~0U;
-
-	if (family == PF_INET)
-		fl.fl4_dst = ip_hdr(skb)->saddr;
-	else
-		fl.fl6_dst = ipv6_hdr(skb)->saddr;
-
-	rcu_read_lock();
-	ai = nf_get_afinfo(family);
-	if (ai != NULL)
-		ai->route((struct dst_entry **)&rt, &fl);
-	rcu_read_unlock();
-
-	if (rt != NULL) {
-		mtu = dst_mtu(&rt->u.dst);
-		dst_release(&rt->u.dst);
-	}
-	return mtu;
-}
-
-static unsigned int
-tcpmss_tg4(struct sk_buff *skb, const struct xt_target_param *par)
-{
-	struct iphdr *iph = ip_hdr(skb);
-	__be16 newlen;
-	int ret;
-
-	ret = tcpmss_mangle_packet(skb, par->targinfo,
-				   tcpmss_reverse_mtu(skb, PF_INET),
-				   iph->ihl * 4,
-				   sizeof(*iph) + sizeof(struct tcphdr));
-	if (ret < 0)
-		return NF_DROP;
-	if (ret > 0) {
-		iph = ip_hdr(skb);
-		newlen = htons(ntohs(iph->tot_len) + ret);
-		csum_replace2(&iph->check, iph->tot_len, newlen);
-		iph->tot_len = newlen;
-	}
-	return XT_CONTINUE;
-}
-
-#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
-static unsigned int
-tcpmss_tg6(struct sk_buff *skb, const struct xt_target_param *par)
-{
-	struct ipv6hdr *ipv6h = ipv6_hdr(skb);
-	u8 nexthdr;
-	int tcphoff;
-	int ret;
-
-	nexthdr = ipv6h->nexthdr;
-	tcphoff = ipv6_skip_exthdr(skb, sizeof(*ipv6h), &nexthdr);
-	if (tcphoff < 0)
-		return NF_DROP;
-	ret = tcpmss_mangle_packet(skb, par->targinfo,
-				   tcpmss_reverse_mtu(skb, PF_INET6),
-				   tcphoff,
-				   sizeof(*ipv6h) + sizeof(struct tcphdr));
-	if (ret < 0)
-		return NF_DROP;
-	if (ret > 0) {
-		ipv6h = ipv6_hdr(skb);
-		ipv6h->payload_len = htons(ntohs(ipv6h->payload_len) + ret);
-	}
-	return XT_CONTINUE;
-}
-#endif
-
-#define TH_SYN 0x02
-
-/* Must specify -p tcp --syn */
-static inline bool find_syn_match(const struct xt_entry_match *m)
-{
-	const struct xt_tcp *tcpinfo = (const struct xt_tcp *)m->data;
-
-	if (strcmp(m->u.kernel.match->name, "tcp") == 0 &&
-	    tcpinfo->flg_cmp & TH_SYN &&
-	    !(tcpinfo->invflags & XT_TCP_INV_FLAGS))
-		return true;
-
-	return false;
-}
-
-static bool tcpmss_tg4_check(const struct xt_tgchk_param *par)
-{
-	const struct xt_tcpmss_info *info = par->targinfo;
-	const struct ipt_entry *e = par->entryinfo;
-
-	if (info->mss == XT_TCPMSS_CLAMP_PMTU &&
-	    (par->hook_mask & ~((1 << NF_INET_FORWARD) |
-			   (1 << NF_INET_LOCAL_OUT) |
-			   (1 << NF_INET_POST_ROUTING))) != 0) {
-		printk("xt_TCPMSS: path-MTU clamping only supported in "
-		       "FORWARD, OUTPUT and POSTROUTING hooks\n");
-		return false;
-	}
-	if (IPT_MATCH_ITERATE(e, find_syn_match))
-		return true;
-	printk("xt_TCPMSS: Only works on TCP SYN packets\n");
-	return false;
-}
-
-#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
-static bool tcpmss_tg6_check(const struct xt_tgchk_param *par)
-{
-	const struct xt_tcpmss_info *info = par->targinfo;
-	const struct ip6t_entry *e = par->entryinfo;
-
-	if (info->mss == XT_TCPMSS_CLAMP_PMTU &&
-	    (par->hook_mask & ~((1 << NF_INET_FORWARD) |
-			   (1 << NF_INET_LOCAL_OUT) |
-			   (1 << NF_INET_POST_ROUTING))) != 0) {
-		printk("xt_TCPMSS: path-MTU clamping only supported in "
-		       "FORWARD, OUTPUT and POSTROUTING hooks\n");
-		return false;
-	}
-	if (IP6T_MATCH_ITERATE(e, find_syn_match))
-		return true;
-	printk("xt_TCPMSS: Only works on TCP SYN packets\n");
+dropit:
+	*par->hotdrop = true;
 	return false;
 }
-#endif
 
-static struct xt_target tcpmss_tg_reg[] __read_mostly = {
+static struct xt_match tcpmss_mt_reg[] __read_mostly = {
 	{
+		.name		= "tcpmss",
 		.family		= NFPROTO_IPV4,
-		.name		= "TCPMSS",
-		.checkentry	= tcpmss_tg4_check,
-		.target		= tcpmss_tg4,
-		.targetsize	= sizeof(struct xt_tcpmss_info),
+		.match		= tcpmss_mt,
+		.matchsize	= sizeof(struct xt_tcpmss_match_info),
 		.proto		= IPPROTO_TCP,
 		.me		= THIS_MODULE,
 	},
-#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
 	{
+		.name		= "tcpmss",
 		.family		= NFPROTO_IPV6,
-		.name		= "TCPMSS",
-		.checkentry	= tcpmss_tg6_check,
-		.target		= tcpmss_tg6,
-		.targetsize	= sizeof(struct xt_tcpmss_info),
+		.match		= tcpmss_mt,
+		.matchsize	= sizeof(struct xt_tcpmss_match_info),
 		.proto		= IPPROTO_TCP,
 		.me		= THIS_MODULE,
 	},
-#endif
 };
 
-static int __init tcpmss_tg_init(void)
+static int __init tcpmss_mt_init(void)
 {
-	return xt_register_targets(tcpmss_tg_reg, ARRAY_SIZE(tcpmss_tg_reg));
+	return xt_register_matches(tcpmss_mt_reg, ARRAY_SIZE(tcpmss_mt_reg));
 }
 
-static void __exit tcpmss_tg_exit(void)
+static void __exit tcpmss_mt_exit(void)
 {
-	xt_unregister_targets(tcpmss_tg_reg, ARRAY_SIZE(tcpmss_tg_reg));
+	xt_unregister_matches(tcpmss_mt_reg, ARRAY_SIZE(tcpmss_mt_reg));
 }
 
-module_init(tcpmss_tg_init);
-module_exit(tcpmss_tg_exit);
+module_init(tcpmss_mt_init);
+module_exit(tcpmss_mt_exit);
diff -Nur linux-2.6.32-orig/net/netrom/nr_route.c iDroid-Project-kernel_common-9e90fd2/net/netrom/nr_route.c
--- linux-2.6.32-orig/net/netrom/nr_route.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/netrom/nr_route.c	2010-11-18 21:05:30.000000000 +0600
@@ -842,12 +842,13 @@
 	dptr  = skb_push(skb, 1);
 	*dptr = AX25_P_NETROM;
 
-	ax25s = ax25_send_frame(skb, 256, (ax25_address *)dev->dev_addr, &nr_neigh->callsign, nr_neigh->digipeat, nr_neigh->dev);
-	if (nr_neigh->ax25 && ax25s) {
-		/* We were already holding this ax25_cb */
+	ax25s = nr_neigh->ax25;
+	nr_neigh->ax25 = ax25_send_frame(skb, 256,
+					 (ax25_address *)dev->dev_addr,
+					 &nr_neigh->callsign,
+					 nr_neigh->digipeat, nr_neigh->dev);
+	if (ax25s)
 		ax25_cb_put(ax25s);
-	}
-	nr_neigh->ax25 = ax25s;
 
 	dev_put(dev);
 	ret = (nr_neigh->ax25 != NULL);
diff -Nur linux-2.6.32-orig/net/packet/af_packet.c iDroid-Project-kernel_common-9e90fd2/net/packet/af_packet.c
--- linux-2.6.32-orig/net/packet/af_packet.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/packet/af_packet.c	2010-11-18 21:05:30.000000000 +0600
@@ -1028,8 +1028,20 @@
 
 		status = TP_STATUS_SEND_REQUEST;
 		err = dev_queue_xmit(skb);
-		if (unlikely(err > 0 && (err = net_xmit_errno(err)) != 0))
-			goto out_xmit;
+		if (unlikely(err > 0)) {
+			err = net_xmit_errno(err);
+			if (err && __packet_get_status(po, ph) ==
+				   TP_STATUS_AVAILABLE) {
+				/* skb was destructed already */
+				skb = NULL;
+				goto out_status;
+			}
+			/*
+			 * skb was dropped but not destructed yet;
+			 * let's treat it like congestion or err < 0
+			 */
+			err = 0;
+		}
 		packet_increment_head(&po->tx_ring);
 		len_sum += tp_len;
 	} while (likely((ph != NULL) || ((!(msg->msg_flags & MSG_DONTWAIT))
@@ -1039,9 +1051,6 @@
 	err = len_sum;
 	goto out_put;
 
-out_xmit:
-	skb->destructor = sock_wfree;
-	atomic_dec(&po->tx_ring.pending);
 out_status:
 	__packet_set_status(po, ph, status);
 	kfree_skb(skb);
diff -Nur linux-2.6.32-orig/net/rfkill/core.c iDroid-Project-kernel_common-9e90fd2/net/rfkill/core.c
--- linux-2.6.32-orig/net/rfkill/core.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/rfkill/core.c	2010-11-18 21:05:30.000000000 +0600
@@ -741,6 +741,7 @@
 }
 EXPORT_SYMBOL(rfkill_pause_polling);
 
+#ifdef CONFIG_RFKILL_PM
 void rfkill_resume_polling(struct rfkill *rfkill)
 {
 	BUG_ON(!rfkill);
@@ -775,14 +776,17 @@
 
 	return 0;
 }
+#endif
 
 static struct class rfkill_class = {
 	.name		= "rfkill",
 	.dev_release	= rfkill_release,
 	.dev_attrs	= rfkill_dev_attrs,
 	.dev_uevent	= rfkill_dev_uevent,
+#ifdef CONFIG_RFKILL_PM
 	.suspend	= rfkill_suspend,
 	.resume		= rfkill_resume,
+#endif
 };
 
 bool rfkill_blocked(struct rfkill *rfkill)
diff -Nur linux-2.6.32-orig/net/rfkill/Kconfig iDroid-Project-kernel_common-9e90fd2/net/rfkill/Kconfig
--- linux-2.6.32-orig/net/rfkill/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/rfkill/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -10,6 +10,11 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called rfkill.
 
+config RFKILL_PM
+	bool "Power off on suspend"
+	depends on RFKILL && PM
+	default y
+
 # LED trigger support
 config RFKILL_LEDS
 	bool
diff -Nur linux-2.6.32-orig/net/rose/rose_link.c iDroid-Project-kernel_common-9e90fd2/net/rose/rose_link.c
--- linux-2.6.32-orig/net/rose/rose_link.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/rose/rose_link.c	2010-11-18 21:05:30.000000000 +0600
@@ -101,13 +101,17 @@
 static int rose_send_frame(struct sk_buff *skb, struct rose_neigh *neigh)
 {
 	ax25_address *rose_call;
+	ax25_cb *ax25s;
 
 	if (ax25cmp(&rose_callsign, &null_ax25_address) == 0)
 		rose_call = (ax25_address *)neigh->dev->dev_addr;
 	else
 		rose_call = &rose_callsign;
 
+	ax25s = neigh->ax25;
 	neigh->ax25 = ax25_send_frame(skb, 260, rose_call, &neigh->callsign, neigh->digipeat, neigh->dev);
+	if (ax25s)
+		ax25_cb_put(ax25s);
 
 	return (neigh->ax25 != NULL);
 }
@@ -120,13 +124,17 @@
 static int rose_link_up(struct rose_neigh *neigh)
 {
 	ax25_address *rose_call;
+	ax25_cb *ax25s;
 
 	if (ax25cmp(&rose_callsign, &null_ax25_address) == 0)
 		rose_call = (ax25_address *)neigh->dev->dev_addr;
 	else
 		rose_call = &rose_callsign;
 
+	ax25s = neigh->ax25;
 	neigh->ax25 = ax25_find_cb(rose_call, &neigh->callsign, neigh->digipeat, neigh->dev);
+	if (ax25s)
+		ax25_cb_put(ax25s);
 
 	return (neigh->ax25 != NULL);
 }
diff -Nur linux-2.6.32-orig/net/rose/rose_route.c iDroid-Project-kernel_common-9e90fd2/net/rose/rose_route.c
--- linux-2.6.32-orig/net/rose/rose_route.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/rose/rose_route.c	2010-11-18 21:05:30.000000000 +0600
@@ -234,6 +234,8 @@
 
 	if ((s = rose_neigh_list) == rose_neigh) {
 		rose_neigh_list = rose_neigh->next;
+		if (rose_neigh->ax25)
+			ax25_cb_put(rose_neigh->ax25);
 		kfree(rose_neigh->digipeat);
 		kfree(rose_neigh);
 		return;
@@ -242,6 +244,8 @@
 	while (s != NULL && s->next != NULL) {
 		if (s->next == rose_neigh) {
 			s->next = rose_neigh->next;
+			if (rose_neigh->ax25)
+				ax25_cb_put(rose_neigh->ax25);
 			kfree(rose_neigh->digipeat);
 			kfree(rose_neigh);
 			return;
@@ -810,6 +814,7 @@
 
 	if (rose_neigh != NULL) {
 		rose_neigh->ax25 = NULL;
+		ax25_cb_put(ax25);
 
 		rose_del_route_by_neigh(rose_neigh);
 		rose_kill_by_neigh(rose_neigh);
diff -Nur linux-2.6.32-orig/net/socket.c iDroid-Project-kernel_common-9e90fd2/net/socket.c
--- linux-2.6.32-orig/net/socket.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/socket.c	2010-11-18 21:05:30.000000000 +0600
@@ -97,6 +97,10 @@
 #include <net/sock.h>
 #include <linux/netfilter.h>
 
+#ifdef CONFIG_UID_STAT
+#include <linux/uid_stat.h>
+#endif
+
 static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
 static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
 			 unsigned long nr_segs, loff_t pos);
@@ -570,7 +574,12 @@
 	if (err)
 		return err;
 
-	return sock->ops->sendmsg(iocb, sock, msg, size);
+	err = sock->ops->sendmsg(iocb, sock, msg, size);
+#ifdef CONFIG_UID_STAT
+	if (err > 0)
+		update_tcp_snd(current_uid(), err);
+#endif
+	return err;
 }
 
 int sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
@@ -684,7 +693,12 @@
 	if (err)
 		return err;
 
-	return sock->ops->recvmsg(iocb, sock, msg, size, flags);
+	err = sock->ops->recvmsg(iocb, sock, msg, size, flags);
+#ifdef CONFIG_UID_STAT
+	if (err > 0)
+		update_tcp_rcv(current_uid(), err);
+#endif
+	return err;
 }
 
 int sock_recvmsg(struct socket *sock, struct msghdr *msg,
diff -Nur linux-2.6.32-orig/net/sunrpc/auth_gss/auth_gss.c iDroid-Project-kernel_common-9e90fd2/net/sunrpc/auth_gss/auth_gss.c
--- linux-2.6.32-orig/net/sunrpc/auth_gss/auth_gss.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/sunrpc/auth_gss/auth_gss.c	2010-11-18 21:05:30.000000000 +0600
@@ -485,7 +485,7 @@
 	dprintk("RPC: %5u gss_refresh_upcall for uid %u\n", task->tk_pid,
 								cred->cr_uid);
 	gss_msg = gss_setup_upcall(task->tk_client, gss_auth, cred);
-	if (IS_ERR(gss_msg) == -EAGAIN) {
+	if (PTR_ERR(gss_msg) == -EAGAIN) {
 		/* XXX: warning on the first, under the assumption we
 		 * shouldn't normally hit this case on a refresh. */
 		warn_gssd();
@@ -644,7 +644,22 @@
 	p = gss_fill_context(p, end, ctx, gss_msg->auth->mech);
 	if (IS_ERR(p)) {
 		err = PTR_ERR(p);
-		gss_msg->msg.errno = (err == -EAGAIN) ? -EAGAIN : -EACCES;
+		switch (err) {
+		case -EACCES:
+			gss_msg->msg.errno = err;
+			err = mlen;
+			break;
+		case -EFAULT:
+		case -ENOMEM:
+		case -EINVAL:
+		case -ENOSYS:
+			gss_msg->msg.errno = -EAGAIN;
+			break;
+		default:
+			printk(KERN_CRIT "%s: bad return from "
+				"gss_fill_context: %ld\n", __func__, err);
+			BUG();
+		}
 		goto err_release_msg;
 	}
 	gss_msg->ctx = gss_get_ctx(ctx);
diff -Nur linux-2.6.32-orig/net/sunrpc/auth_gss/gss_krb5_mech.c iDroid-Project-kernel_common-9e90fd2/net/sunrpc/auth_gss/gss_krb5_mech.c
--- linux-2.6.32-orig/net/sunrpc/auth_gss/gss_krb5_mech.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/sunrpc/auth_gss/gss_krb5_mech.c	2010-11-18 21:05:30.000000000 +0600
@@ -131,8 +131,10 @@
 	struct	krb5_ctx *ctx;
 	int tmp;
 
-	if (!(ctx = kzalloc(sizeof(*ctx), GFP_NOFS)))
+	if (!(ctx = kzalloc(sizeof(*ctx), GFP_NOFS))) {
+		p = ERR_PTR(-ENOMEM);
 		goto out_err;
+	}
 
 	p = simple_get_bytes(p, end, &ctx->initiate, sizeof(ctx->initiate));
 	if (IS_ERR(p))
diff -Nur linux-2.6.32-orig/net/sunrpc/auth_gss/gss_mech_switch.c iDroid-Project-kernel_common-9e90fd2/net/sunrpc/auth_gss/gss_mech_switch.c
--- linux-2.6.32-orig/net/sunrpc/auth_gss/gss_mech_switch.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/sunrpc/auth_gss/gss_mech_switch.c	2010-11-18 21:05:30.000000000 +0600
@@ -252,7 +252,7 @@
 		       struct gss_ctx		**ctx_id)
 {
 	if (!(*ctx_id = kzalloc(sizeof(**ctx_id), GFP_KERNEL)))
-		return GSS_S_FAILURE;
+		return -ENOMEM;
 	(*ctx_id)->mech_type = gss_mech_get(mech);
 
 	return mech->gm_ops
diff -Nur linux-2.6.32-orig/net/sunrpc/svc_xprt.c iDroid-Project-kernel_common-9e90fd2/net/sunrpc/svc_xprt.c
--- linux-2.6.32-orig/net/sunrpc/svc_xprt.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/sunrpc/svc_xprt.c	2010-11-18 21:05:30.000000000 +0600
@@ -711,7 +711,8 @@
 	spin_unlock_bh(&pool->sp_lock);
 
 	len = 0;
-	if (test_bit(XPT_LISTENER, &xprt->xpt_flags)) {
+	if (test_bit(XPT_LISTENER, &xprt->xpt_flags) &&
+	    !test_bit(XPT_CLOSE, &xprt->xpt_flags)) {
 		struct svc_xprt *newxpt;
 		newxpt = xprt->xpt_ops->xpo_accept(xprt);
 		if (newxpt) {
diff -Nur linux-2.6.32-orig/net/wireless/mlme.c iDroid-Project-kernel_common-9e90fd2/net/wireless/mlme.c
--- linux-2.6.32-orig/net/wireless/mlme.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/wireless/mlme.c	2010-11-18 21:05:30.000000000 +0600
@@ -94,7 +94,18 @@
 			}
 		}
 
-		WARN_ON(!bss);
+		/*
+		 * We might be coming here because the driver reported
+		 * a successful association at the same time as the
+		 * user requested a deauth. In that case, we will have
+		 * removed the BSS from the auth_bsses list due to the
+		 * deauth request when the assoc response makes it. If
+		 * the two code paths acquire the lock the other way
+		 * around, that's just the standard situation of a
+		 * deauth being requested while connected.
+		 */
+		if (!bss)
+			goto out;
 	} else if (wdev->conn) {
 		cfg80211_sme_failed_assoc(wdev);
 		need_connect_result = false;
diff -Nur linux-2.6.32-orig/net/wireless/reg.c iDroid-Project-kernel_common-9e90fd2/net/wireless/reg.c
--- linux-2.6.32-orig/net/wireless/reg.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/wireless/reg.c	2010-11-18 21:05:30.000000000 +0600
@@ -1714,7 +1714,7 @@
 	request->wiphy_idx = WIPHY_IDX_STALE;
 	request->alpha2[0] = alpha2[0];
 	request->alpha2[1] = alpha2[1];
-	request->initiator = NL80211_REGDOM_SET_BY_USER,
+	request->initiator = NL80211_REGDOM_SET_BY_USER;
 
 	queue_regulatory_request(request);
 
diff -Nur linux-2.6.32-orig/net/wireless/sme.c iDroid-Project-kernel_common-9e90fd2/net/wireless/sme.c
--- linux-2.6.32-orig/net/wireless/sme.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/net/wireless/sme.c	2010-11-18 21:05:30.000000000 +0600
@@ -655,6 +655,7 @@
 	memset(&wrqu, 0, sizeof(wrqu));
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
 	wireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);
+	wdev->wext.connect.ssid_len = 0;
 #endif
 }
 
diff -Nur linux-2.6.32-orig/security/commoncap.c iDroid-Project-kernel_common-9e90fd2/security/commoncap.c
--- linux-2.6.32-orig/security/commoncap.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/security/commoncap.c	2010-11-18 21:05:30.000000000 +0600
@@ -28,6 +28,10 @@
 #include <linux/prctl.h>
 #include <linux/securebits.h>
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+#endif
+
 /*
  * If a non-root user executes a setuid-root binary in
  * !secure(SECURE_NOROOT) mode, then we raise capabilities.
@@ -82,6 +86,12 @@
 int cap_capable(struct task_struct *tsk, const struct cred *cred, int cap,
 		int audit)
 {
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+	if (cap == CAP_NET_RAW && in_egroup_p(AID_NET_RAW))
+		return 0;
+	if (cap == CAP_NET_ADMIN && in_egroup_p(AID_NET_ADMIN))
+		return 0;
+#endif
 	return cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;
 }
 
diff -Nur linux-2.6.32-orig/security/keys/keyctl.c iDroid-Project-kernel_common-9e90fd2/security/keys/keyctl.c
--- linux-2.6.32-orig/security/keys/keyctl.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/security/keys/keyctl.c	2010-11-18 21:05:30.000000000 +0600
@@ -1236,6 +1236,7 @@
  */
 long keyctl_session_to_parent(void)
 {
+#ifdef TIF_NOTIFY_RESUME
 	struct task_struct *me, *parent;
 	const struct cred *mycred, *pcred;
 	struct cred *cred, *oldcred;
@@ -1326,6 +1327,15 @@
 error_keyring:
 	key_ref_put(keyring_r);
 	return ret;
+
+#else /* !TIF_NOTIFY_RESUME */
+	/*
+	 * To be removed when TIF_NOTIFY_RESUME has been implemented on
+	 * m68k/xtensa
+	 */
+#warning TIF_NOTIFY_RESUME not implemented
+	return -EOPNOTSUPP;
+#endif /* !TIF_NOTIFY_RESUME */
 }
 
 /*****************************************************************************/
diff -Nur linux-2.6.32-orig/security/Makefile iDroid-Project-kernel_common-9e90fd2/security/Makefile
--- linux-2.6.32-orig/security/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/security/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -8,7 +8,8 @@
 subdir-$(CONFIG_SECURITY_TOMOYO)        += tomoyo
 
 # always enable default capabilities
-obj-y		+= commoncap.o min_addr.o
+obj-y					+= commoncap.o
+obj-$(CONFIG_MMU)			+= min_addr.o
 
 # Object file lists
 obj-$(CONFIG_SECURITY)			+= security.o capability.o
diff -Nur linux-2.6.32-orig/security/selinux/hooks.c iDroid-Project-kernel_common-9e90fd2/security/selinux/hooks.c
--- linux-2.6.32-orig/security/selinux/hooks.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/security/selinux/hooks.c	2010-11-18 21:05:30.000000000 +0600
@@ -2366,7 +2366,7 @@
 			initrlim = init_task.signal->rlim + i;
 			rlim->rlim_cur = min(rlim->rlim_max, initrlim->rlim_cur);
 		}
-		update_rlimit_cpu(rlim->rlim_cur);
+		update_rlimit_cpu(current->signal->rlim[RLIMIT_CPU].rlim_cur);
 	}
 }
 
diff -Nur linux-2.6.32-orig/sound/core/hrtimer.c iDroid-Project-kernel_common-9e90fd2/sound/core/hrtimer.c
--- linux-2.6.32-orig/sound/core/hrtimer.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/core/hrtimer.c	2010-11-18 21:05:30.000000000 +0600
@@ -37,14 +37,22 @@
 struct snd_hrtimer {
 	struct snd_timer *timer;
 	struct hrtimer hrt;
+	atomic_t running;
 };
 
 static enum hrtimer_restart snd_hrtimer_callback(struct hrtimer *hrt)
 {
 	struct snd_hrtimer *stime = container_of(hrt, struct snd_hrtimer, hrt);
 	struct snd_timer *t = stime->timer;
+
+	if (!atomic_read(&stime->running))
+		return HRTIMER_NORESTART;
+
 	hrtimer_forward_now(hrt, ns_to_ktime(t->sticks * resolution));
 	snd_timer_interrupt(stime->timer, t->sticks);
+
+	if (!atomic_read(&stime->running))
+		return HRTIMER_NORESTART;
 	return HRTIMER_RESTART;
 }
 
@@ -58,6 +66,7 @@
 	hrtimer_init(&stime->hrt, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 	stime->timer = t;
 	stime->hrt.function = snd_hrtimer_callback;
+	atomic_set(&stime->running, 0);
 	t->private_data = stime;
 	return 0;
 }
@@ -78,16 +87,18 @@
 {
 	struct snd_hrtimer *stime = t->private_data;
 
+	atomic_set(&stime->running, 0);
+	hrtimer_cancel(&stime->hrt);
 	hrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),
 		      HRTIMER_MODE_REL);
+	atomic_set(&stime->running, 1);
 	return 0;
 }
 
 static int snd_hrtimer_stop(struct snd_timer *t)
 {
 	struct snd_hrtimer *stime = t->private_data;
-
-	hrtimer_cancel(&stime->hrt);
+	atomic_set(&stime->running, 0);
 	return 0;
 }
 
diff -Nur linux-2.6.32-orig/sound/mips/sgio2audio.c iDroid-Project-kernel_common-9e90fd2/sound/mips/sgio2audio.c
--- linux-2.6.32-orig/sound/mips/sgio2audio.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/mips/sgio2audio.c	2010-11-18 21:05:30.000000000 +0600
@@ -609,7 +609,7 @@
 	/* alloc virtual 'dma' area */
 	if (runtime->dma_area)
 		vfree(runtime->dma_area);
-	runtime->dma_area = vmalloc(size);
+	runtime->dma_area = vmalloc_user(size);
 	if (runtime->dma_area == NULL)
 		return -ENOMEM;
 	runtime->dma_bytes = size;
diff -Nur linux-2.6.32-orig/sound/pci/ac97/ac97_patch.c iDroid-Project-kernel_common-9e90fd2/sound/pci/ac97/ac97_patch.c
--- linux-2.6.32-orig/sound/pci/ac97/ac97_patch.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/pci/ac97/ac97_patch.c	2010-11-18 21:05:30.000000000 +0600
@@ -1870,6 +1870,7 @@
 	0x10140554, /* Thinkpad T42p/R50p */
 	0x10140567, /* Thinkpad T43p 2668-G7U */
 	0x10140581, /* Thinkpad X41-2527 */
+	0x10280160, /* Dell Dimension 2400 */
 	0x104380b0, /* Asus A7V8X-MX */
 	0x11790241, /* Toshiba Satellite A-15 S127 */
 	0x144dc01a, /* Samsung NP-X20C004/SEG */
diff -Nur linux-2.6.32-orig/sound/pci/atiixp.c iDroid-Project-kernel_common-9e90fd2/sound/pci/atiixp.c
--- linux-2.6.32-orig/sound/pci/atiixp.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/pci/atiixp.c	2010-11-18 21:05:30.000000000 +0600
@@ -297,6 +297,7 @@
 MODULE_DEVICE_TABLE(pci, snd_atiixp_ids);
 
 static struct snd_pci_quirk atiixp_quirks[] __devinitdata = {
+	SND_PCI_QUIRK(0x105b, 0x0c81, "Foxconn RC4107MA-RS2", 0),
 	SND_PCI_QUIRK(0x15bd, 0x3100, "DFI RS482", 0),
 	{ } /* terminator */
 };
diff -Nur linux-2.6.32-orig/sound/pci/ctxfi/ctatc.c iDroid-Project-kernel_common-9e90fd2/sound/pci/ctxfi/ctatc.c
--- linux-2.6.32-orig/sound/pci/ctxfi/ctatc.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/pci/ctxfi/ctatc.c	2010-11-18 21:05:30.000000000 +0600
@@ -166,18 +166,7 @@
 
 static unsigned long atc_get_ptp_phys(struct ct_atc *atc, int index)
 {
-	struct ct_vm *vm;
-	void *kvirt_addr;
-	unsigned long phys_addr;
-
-	vm = atc->vm;
-	kvirt_addr = vm->get_ptp_virt(vm, index);
-	if (kvirt_addr == NULL)
-		phys_addr = (~0UL);
-	else
-		phys_addr = virt_to_phys(kvirt_addr);
-
-	return phys_addr;
+	return atc->vm->get_ptp_phys(atc->vm, index);
 }
 
 static unsigned int convert_format(snd_pcm_format_t snd_format)
@@ -1669,7 +1658,7 @@
 	}
 
 	/* Set up device virtual memory management object */
-	err = ct_vm_create(&atc->vm);
+	err = ct_vm_create(&atc->vm, pci);
 	if (err < 0)
 		goto error1;
 
diff -Nur linux-2.6.32-orig/sound/pci/ctxfi/ctvmem.c iDroid-Project-kernel_common-9e90fd2/sound/pci/ctxfi/ctvmem.c
--- linux-2.6.32-orig/sound/pci/ctxfi/ctvmem.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/pci/ctxfi/ctvmem.c	2010-11-18 21:05:30.000000000 +0600
@@ -138,7 +138,7 @@
 		return NULL;
 	}
 
-	ptp = vm->ptp[0];
+	ptp = (unsigned long *)vm->ptp[0].area;
 	pte_start = (block->addr >> CT_PAGE_SHIFT);
 	pages = block->size >> CT_PAGE_SHIFT;
 	for (i = 0; i < pages; i++) {
@@ -158,25 +158,25 @@
 }
 
 /* *
- * return the host (kmalloced) addr of the @index-th device
- * page talbe page on success, or NULL on failure.
- * The first returned NULL indicates the termination.
+ * return the host physical addr of the @index-th device
+ * page table page on success, or ~0UL on failure.
+ * The first returned ~0UL indicates the termination.
  * */
-static void *
-ct_get_ptp_virt(struct ct_vm *vm, int index)
+static dma_addr_t
+ct_get_ptp_phys(struct ct_vm *vm, int index)
 {
-	void *addr;
+	dma_addr_t addr;
 
-	addr = (index >= CT_PTP_NUM) ? NULL : vm->ptp[index];
+	addr = (index >= CT_PTP_NUM) ? ~0UL : vm->ptp[index].addr;
 
 	return addr;
 }
 
-int ct_vm_create(struct ct_vm **rvm)
+int ct_vm_create(struct ct_vm **rvm, struct pci_dev *pci)
 {
 	struct ct_vm *vm;
 	struct ct_vm_block *block;
-	int i;
+	int i, err = 0;
 
 	*rvm = NULL;
 
@@ -188,23 +188,21 @@
 
 	/* Allocate page table pages */
 	for (i = 0; i < CT_PTP_NUM; i++) {
-		vm->ptp[i] = kmalloc(PAGE_SIZE, GFP_KERNEL);
-		if (!vm->ptp[i])
+		err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
+					  snd_dma_pci_data(pci),
+					  PAGE_SIZE, &vm->ptp[i]);
+		if (err < 0)
 			break;
 	}
-	if (!i) {
+	if (err < 0) {
 		/* no page table pages are allocated */
-		kfree(vm);
+		ct_vm_destroy(vm);
 		return -ENOMEM;
 	}
 	vm->size = CT_ADDRS_PER_PAGE * i;
-	/* Initialise remaining ptps */
-	for (; i < CT_PTP_NUM; i++)
-		vm->ptp[i] = NULL;
-
 	vm->map = ct_vm_map;
 	vm->unmap = ct_vm_unmap;
-	vm->get_ptp_virt = ct_get_ptp_virt;
+	vm->get_ptp_phys = ct_get_ptp_phys;
 	INIT_LIST_HEAD(&vm->unused);
 	INIT_LIST_HEAD(&vm->used);
 	block = kzalloc(sizeof(*block), GFP_KERNEL);
@@ -242,7 +240,7 @@
 
 	/* free allocated page table pages */
 	for (i = 0; i < CT_PTP_NUM; i++)
-		kfree(vm->ptp[i]);
+		snd_dma_free_pages(&vm->ptp[i]);
 
 	vm->size = 0;
 
diff -Nur linux-2.6.32-orig/sound/pci/ctxfi/ctvmem.h iDroid-Project-kernel_common-9e90fd2/sound/pci/ctxfi/ctvmem.h
--- linux-2.6.32-orig/sound/pci/ctxfi/ctvmem.h	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/pci/ctxfi/ctvmem.h	2010-11-18 21:05:30.000000000 +0600
@@ -22,6 +22,8 @@
 
 #include <linux/mutex.h>
 #include <linux/list.h>
+#include <linux/pci.h>
+#include <sound/memalloc.h>
 
 /* The chip can handle the page table of 4k pages
  * (emu20k1 can handle even 8k pages, but we don't use it right now)
@@ -41,7 +43,7 @@
 
 /* Virtual memory management object for card device */
 struct ct_vm {
-	void *ptp[CT_PTP_NUM];		/* Device page table pages */
+	struct snd_dma_buffer ptp[CT_PTP_NUM];	/* Device page table pages */
 	unsigned int size;		/* Available addr space in bytes */
 	struct list_head unused;	/* List of unused blocks */
 	struct list_head used;		/* List of used blocks */
@@ -52,10 +54,10 @@
 				   int size);
 	/* Unmap device logical addr area. */
 	void (*unmap)(struct ct_vm *, struct ct_vm_block *block);
-	void *(*get_ptp_virt)(struct ct_vm *vm, int index);
+	dma_addr_t (*get_ptp_phys)(struct ct_vm *vm, int index);
 };
 
-int ct_vm_create(struct ct_vm **rvm);
+int ct_vm_create(struct ct_vm **rvm, struct pci_dev *pci);
 void ct_vm_destroy(struct ct_vm *vm);
 
 #endif /* CTVMEM_H */
diff -Nur linux-2.6.32-orig/sound/pci/hda/hda_intel.c iDroid-Project-kernel_common-9e90fd2/sound/pci/hda/hda_intel.c
--- linux-2.6.32-orig/sound/pci/hda/hda_intel.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/pci/hda/hda_intel.c	2010-11-18 21:05:30.000000000 +0600
@@ -1858,6 +1858,9 @@
 
 	if (!bdl_pos_adj[chip->dev_index])
 		return 1; /* no delayed ack */
+	if (WARN_ONCE(!azx_dev->period_bytes,
+		      "hda-intel: zero azx_dev->period_bytes"))
+		return 0; /* this shouldn't happen! */
 	if (pos % azx_dev->period_bytes > azx_dev->period_bytes / 2)
 		return 0; /* NG - it's below the period boundary */
 	return 1; /* OK, it's fine */
@@ -2436,6 +2439,11 @@
 		}
 	}
 
+	/* disable 64bit DMA address for Teradici */
+	/* it does not work with device 6549:1200 subsys e4a2:040b */
+	if (chip->driver_type == AZX_DRIVER_TERA)
+		gcap &= ~ICH6_GCAP_64OK;
+
 	/* allow 64bit DMA address if supported by H/W */
 	if ((gcap & ICH6_GCAP_64OK) && !pci_set_dma_mask(pci, DMA_BIT_MASK(64)))
 		pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(64));
@@ -2689,6 +2697,9 @@
 	{ PCI_DEVICE(0x10de, 0x0ac1), .driver_data = AZX_DRIVER_NVIDIA },
 	{ PCI_DEVICE(0x10de, 0x0ac2), .driver_data = AZX_DRIVER_NVIDIA },
 	{ PCI_DEVICE(0x10de, 0x0ac3), .driver_data = AZX_DRIVER_NVIDIA },
+	{ PCI_DEVICE(0x10de, 0x0be2), .driver_data = AZX_DRIVER_NVIDIA },
+	{ PCI_DEVICE(0x10de, 0x0be3), .driver_data = AZX_DRIVER_NVIDIA },
+	{ PCI_DEVICE(0x10de, 0x0be4), .driver_data = AZX_DRIVER_NVIDIA },
 	{ PCI_DEVICE(0x10de, 0x0d94), .driver_data = AZX_DRIVER_NVIDIA },
 	{ PCI_DEVICE(0x10de, 0x0d95), .driver_data = AZX_DRIVER_NVIDIA },
 	{ PCI_DEVICE(0x10de, 0x0d96), .driver_data = AZX_DRIVER_NVIDIA },
diff -Nur linux-2.6.32-orig/sound/pci/hda/patch_intelhdmi.c iDroid-Project-kernel_common-9e90fd2/sound/pci/hda/patch_intelhdmi.c
--- linux-2.6.32-orig/sound/pci/hda/patch_intelhdmi.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/pci/hda/patch_intelhdmi.c	2010-11-18 21:05:30.000000000 +0600
@@ -684,7 +684,7 @@
 	{ .id = 0x80862801, .name = "G45 DEVBLC", .patch = patch_intel_hdmi },
 	{ .id = 0x80862802, .name = "G45 DEVCTG", .patch = patch_intel_hdmi },
 	{ .id = 0x80862803, .name = "G45 DEVELK", .patch = patch_intel_hdmi },
-	{ .id = 0x80862804, .name = "G45 DEVIBX", .patch = patch_intel_hdmi },
+	{ .id = 0x80862804, .name = "G45 DEVIBX", .patch = patch_intel_hdmi_ibexpeak },
 	{ .id = 0x80860054, .name = "Q57 DEVIBX", .patch = patch_intel_hdmi_ibexpeak },
 	{ .id = 0x10951392, .name = "SiI1392 HDMI",     .patch = patch_intel_hdmi },
 	{} /* terminator */
diff -Nur linux-2.6.32-orig/sound/pci/hda/patch_realtek.c iDroid-Project-kernel_common-9e90fd2/sound/pci/hda/patch_realtek.c
--- linux-2.6.32-orig/sound/pci/hda/patch_realtek.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/pci/hda/patch_realtek.c	2010-11-18 21:05:30.000000000 +0600
@@ -2401,6 +2401,8 @@
 	"Speaker Playback Switch",
 	"Mono Playback Switch",
 	"IEC958 Playback Switch",
+	"Line-Out Playback Switch",
+	"PCM Playback Switch",
 	NULL,
 };
 
@@ -7040,8 +7042,8 @@
 	HDA_BIND_MUTE   ("Surround Playback Switch", 0x0d, 0x02, HDA_INPUT),
 	HDA_CODEC_VOLUME("LFE Playback Volume", 0x0e, 0x00, HDA_OUTPUT),
 	HDA_BIND_MUTE   ("LFE Playback Switch", 0x0e, 0x02, HDA_INPUT),
-	HDA_CODEC_VOLUME("HP Playback Volume", 0x0f, 0x00, HDA_OUTPUT),
-	HDA_BIND_MUTE   ("HP Playback Switch", 0x0f, 0x02, HDA_INPUT),
+	HDA_CODEC_VOLUME("Headphone Playback Volume", 0x0f, 0x00, HDA_OUTPUT),
+	HDA_BIND_MUTE   ("Headphone Playback Switch", 0x0f, 0x02, HDA_INPUT),
 	HDA_CODEC_VOLUME("Line Playback Volume", 0x0b, 0x02, HDA_INPUT),
 	HDA_CODEC_MUTE  ("Line Playback Switch", 0x0b, 0x02, HDA_INPUT),
 	HDA_CODEC_VOLUME("Mic Playback Volume", 0x0b, 0x01, HDA_INPUT),
@@ -7428,6 +7430,7 @@
 	{0x14, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT},
 	{0x14, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE},
 	{0x14, AC_VERB_SET_CONNECT_SEL, 0x03},
+	{0x14, AC_VERB_SET_UNSOLICITED_ENABLE, ALC880_HP_EVENT | AC_USRSP_EN},
 	/* Front Mic pin: input vref at 80% */
 	{0x19, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF80},
 	{0x19, AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE},
@@ -7552,6 +7555,27 @@
 	spec->autocfg.speaker_pins[0] = 0x14;
 }
 
+static void alc885_mb5_automute(struct hda_codec *codec)
+{
+	unsigned int present;
+
+	present = snd_hda_codec_read(codec, 0x14, 0,
+				     AC_VERB_GET_PIN_SENSE, 0) & 0x80000000;
+	snd_hda_codec_amp_stereo(codec, 0x18, HDA_OUTPUT, 0,
+				 HDA_AMP_MUTE, present ? HDA_AMP_MUTE : 0);
+	snd_hda_codec_amp_stereo(codec, 0x1a, HDA_OUTPUT, 0,
+				 HDA_AMP_MUTE, present ? HDA_AMP_MUTE : 0);
+
+}
+
+static void alc885_mb5_unsol_event(struct hda_codec *codec,
+				    unsigned int res)
+{
+	/* Headphone insertion or removal. */
+	if ((res >> 26) == ALC880_HP_EVENT)
+		alc885_mb5_automute(codec);
+}
+
 
 static struct hda_verb alc882_targa_verbs[] = {
 	{0x0c, AC_VERB_SET_AMP_GAIN_MUTE, AMP_IN_UNMUTE(0)},
@@ -8839,7 +8863,7 @@
 	SND_PCI_QUIRK(0x1462, 0x040d, "MSI", ALC883_TARGA_2ch_DIG),
 	SND_PCI_QUIRK(0x1462, 0x0579, "MSI", ALC883_TARGA_2ch_DIG),
 	SND_PCI_QUIRK(0x1462, 0x28fb, "Targa T8", ALC882_TARGA), /* MSI-1049 T8  */
-	SND_PCI_QUIRK(0x1462, 0x2fb3, "MSI", ALC883_TARGA_2ch_DIG),
+	SND_PCI_QUIRK(0x1462, 0x2fb3, "MSI", ALC882_AUTO),
 	SND_PCI_QUIRK(0x1462, 0x6668, "MSI", ALC882_6ST_DIG),
 	SND_PCI_QUIRK(0x1462, 0x3729, "MSI S420", ALC883_TARGA_DIG),
 	SND_PCI_QUIRK(0x1462, 0x3783, "NEC S970", ALC883_TARGA_DIG),
@@ -8994,6 +9018,8 @@
 		.input_mux = &mb5_capture_source,
 		.dig_out_nid = ALC882_DIGOUT_NID,
 		.dig_in_nid = ALC882_DIGIN_NID,
+		.unsol_event = alc885_mb5_unsol_event,
+		.init_hook = alc885_mb5_automute,
 	},
 	[ALC885_MACPRO] = {
 		.mixers = { alc882_macpro_mixer },
@@ -9141,6 +9167,8 @@
 		.dac_nids = alc883_dac_nids,
 		.num_adc_nids = ARRAY_SIZE(alc889_adc_nids),
 		.adc_nids = alc889_adc_nids,
+		.capsrc_nids = alc889_capsrc_nids,
+		.capsrc_nids = alc889_capsrc_nids,
 		.dig_out_nid = ALC883_DIGOUT_NID,
 		.dig_in_nid = ALC883_DIGIN_NID,
 		.slave_dig_outs = alc883_slave_dig_outs,
@@ -9187,6 +9215,7 @@
 		.dac_nids = alc883_dac_nids,
 		.adc_nids = alc883_adc_nids_alt,
 		.num_adc_nids = ARRAY_SIZE(alc883_adc_nids_alt),
+		.capsrc_nids = alc883_capsrc_nids,
 		.dig_out_nid = ALC883_DIGOUT_NID,
 		.num_channel_mode = ARRAY_SIZE(alc883_3ST_2ch_modes),
 		.channel_mode = alc883_3ST_2ch_modes,
@@ -9333,6 +9362,7 @@
 		.dac_nids = alc883_dac_nids,
 		.adc_nids = alc883_adc_nids_alt,
 		.num_adc_nids = ARRAY_SIZE(alc883_adc_nids_alt),
+		.capsrc_nids = alc883_capsrc_nids,
 		.num_channel_mode = ARRAY_SIZE(alc883_sixstack_modes),
 		.channel_mode = alc883_sixstack_modes,
 		.input_mux = &alc883_capture_source,
@@ -9394,6 +9424,7 @@
 		.dac_nids = alc883_dac_nids,
 		.adc_nids = alc883_adc_nids_alt,
 		.num_adc_nids = ARRAY_SIZE(alc883_adc_nids_alt),
+		.capsrc_nids = alc883_capsrc_nids,
 		.num_channel_mode = ARRAY_SIZE(alc883_3ST_2ch_modes),
 		.channel_mode = alc883_3ST_2ch_modes,
 		.input_mux = &alc883_lenovo_101e_capture_source,
@@ -9573,6 +9604,7 @@
 			alc880_gpio1_init_verbs },
 		.adc_nids = alc883_adc_nids,
 		.num_adc_nids = ARRAY_SIZE(alc883_adc_nids),
+		.capsrc_nids = alc883_capsrc_nids,
 		.dac_nids = alc883_dac_nids,
 		.num_dacs = ARRAY_SIZE(alc883_dac_nids),
 		.channel_mode = alc889A_mb31_6ch_modes,
@@ -10146,7 +10178,7 @@
 	struct alc_spec *spec = codec->spec;
 
 	spec->autocfg.hp_pins[0] = 0x15;
-	spec->autocfg.speaker_pins[0] = 0x0c; /* HACK: not actually a pin */
+	spec->autocfg.speaker_pins[0] = 0x14;
 }
 
 static struct snd_kcontrol_new alc262_hp_t5735_mixer[] = {
@@ -11580,9 +11612,9 @@
 		.num_channel_mode = ARRAY_SIZE(alc262_modes),
 		.channel_mode = alc262_modes,
 		.input_mux = &alc262_capture_source,
-		.unsol_event = alc_automute_amp_unsol_event,
+		.unsol_event = alc_sku_unsol_event,
 		.setup = alc262_hp_t5735_setup,
-		.init_hook = alc_automute_amp,
+		.init_hook = alc_inithook,
 	},
 	[ALC262_HP_RP5700] = {
 		.mixers = { alc262_hp_rp5700_mixer },
@@ -14679,6 +14711,8 @@
 	spec->stream_digital_playback = &alc861_pcm_digital_playback;
 	spec->stream_digital_capture = &alc861_pcm_digital_capture;
 
+	if (!spec->cap_mixer)
+		set_capture_mixer(codec);
 	set_beep_amp(spec, 0x23, 0, HDA_OUTPUT);
 
 	spec->vmaster_nid = 0x03;
@@ -15317,7 +15351,7 @@
 static int alc861vd_auto_create_input_ctls(struct hda_codec *codec,
 						const struct auto_pin_cfg *cfg)
 {
-	return alc_auto_create_input_ctls(codec, cfg, 0x15, 0x09, 0);
+	return alc_auto_create_input_ctls(codec, cfg, 0x15, 0x22, 0);
 }
 
 
diff -Nur linux-2.6.32-orig/sound/pci/ice1712/juli.c iDroid-Project-kernel_common-9e90fd2/sound/pci/ice1712/juli.c
--- linux-2.6.32-orig/sound/pci/ice1712/juli.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/pci/ice1712/juli.c	2010-11-18 21:05:30.000000000 +0600
@@ -504,6 +504,31 @@
 }
 
 /*
+ * suspend/resume
+ * */
+
+#ifdef CONFIG_PM
+static int juli_resume(struct snd_ice1712 *ice)
+{
+	struct snd_akm4xxx *ak = ice->akm;
+	struct juli_spec *spec = ice->spec;
+	/* akm4358 un-reset, un-mute */
+	snd_akm4xxx_reset(ak, 0);
+	/* reinit ak4114 */
+	snd_ak4114_reinit(spec->ak4114);
+	return 0;
+}
+
+static int juli_suspend(struct snd_ice1712 *ice)
+{
+	struct snd_akm4xxx *ak = ice->akm;
+	/* akm4358 reset and soft-mute */
+	snd_akm4xxx_reset(ak, 1);
+	return 0;
+}
+#endif
+
+/*
  * initialize the chip
  */
 
@@ -646,6 +671,13 @@
 	ice->set_spdif_clock = juli_set_spdif_clock;
 
 	ice->spdif.ops.open = juli_spdif_in_open;
+
+#ifdef CONFIG_PM
+	ice->pm_resume = juli_resume;
+	ice->pm_suspend = juli_suspend;
+	ice->pm_suspend_enabled = 1;
+#endif
+
 	return 0;
 }
 
diff -Nur linux-2.6.32-orig/sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c iDroid-Project-kernel_common-9e90fd2/sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c
--- linux-2.6.32-orig/sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c	2010-11-18 21:05:30.000000000 +0600
@@ -51,7 +51,7 @@
 			return 0; /* already enough large */
 		vfree(runtime->dma_area);
 	}
-	runtime->dma_area = vmalloc_32(size);
+	runtime->dma_area = vmalloc_32_user(size);
 	if (! runtime->dma_area)
 		return -ENOMEM;
 	runtime->dma_bytes = size;
diff -Nur linux-2.6.32-orig/sound/soc/codecs/Kconfig iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/Kconfig
--- linux-2.6.32-orig/sound/soc/codecs/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -50,6 +50,7 @@
 	select SND_SOC_WM8974 if I2C
 	select SND_SOC_WM8988 if SND_SOC_I2C_AND_SPI
 	select SND_SOC_WM8990 if I2C
+	select SND_SOC_WM8991 if I2C
 	select SND_SOC_WM8993 if I2C
 	select SND_SOC_WM9081 if I2C
 	select SND_SOC_WM9705 if SND_SOC_AC97_BUS
@@ -202,6 +203,9 @@
 config SND_SOC_WM8990
 	tristate
 
+config SND_SOC_WM8991
+	tristate
+
 config SND_SOC_WM8993
 	tristate
 
diff -Nur linux-2.6.32-orig/sound/soc/codecs/Makefile iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/Makefile
--- linux-2.6.32-orig/sound/soc/codecs/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -38,6 +38,7 @@
 snd-soc-wm8974-objs := wm8974.o
 snd-soc-wm8988-objs := wm8988.o
 snd-soc-wm8990-objs := wm8990.o
+snd-soc-wm8991-objs := wm8991.o
 snd-soc-wm8993-objs := wm8993.o
 snd-soc-wm9081-objs := wm9081.o
 snd-soc-wm9705-objs := wm9705.o
@@ -88,6 +89,7 @@
 obj-$(CONFIG_SND_SOC_WM8961)	+= snd-soc-wm8961.o
 obj-$(CONFIG_SND_SOC_WM8988)	+= snd-soc-wm8988.o
 obj-$(CONFIG_SND_SOC_WM8990)	+= snd-soc-wm8990.o
+obj-$(CONFIG_SND_SOC_WM8991)	+= snd-soc-wm8991.o
 obj-$(CONFIG_SND_SOC_WM8993)	+= snd-soc-wm8993.o
 obj-$(CONFIG_SND_SOC_WM9081)	+= snd-soc-wm9081.o
 obj-$(CONFIG_SND_SOC_WM9705)	+= snd-soc-wm9705.o
diff -Nur linux-2.6.32-orig/sound/soc/codecs/wm8350.c iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8350.c
--- linux-2.6.32-orig/sound/soc/codecs/wm8350.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8350.c	2010-11-18 21:05:30.000000000 +0600
@@ -925,7 +925,7 @@
 		iface |= 0x3 << 8;
 		break;
 	case SND_SOC_DAIFMT_DSP_B:
-		iface |= 0x3 << 8;	/* lg not sure which mode */
+		iface |= 0x3 << 8 | WM8350_AIF_LRCLK_INV;
 		break;
 	default:
 		return -EINVAL;
diff -Nur linux-2.6.32-orig/sound/soc/codecs/wm8510.c iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8510.c
--- linux-2.6.32-orig/sound/soc/codecs/wm8510.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8510.c	2010-11-18 21:05:30.000000000 +0600
@@ -425,23 +425,23 @@
 
 	/* filter coefficient */
 	switch (params_rate(params)) {
-	case SNDRV_PCM_RATE_8000:
+	case 8000:
 		adn |= 0x5 << 1;
 		break;
-	case SNDRV_PCM_RATE_11025:
+	case 11025:
 		adn |= 0x4 << 1;
 		break;
-	case SNDRV_PCM_RATE_16000:
+	case 16000:
 		adn |= 0x3 << 1;
 		break;
-	case SNDRV_PCM_RATE_22050:
+	case 22050:
 		adn |= 0x2 << 1;
 		break;
-	case SNDRV_PCM_RATE_32000:
+	case 32000:
 		adn |= 0x1 << 1;
 		break;
-	case SNDRV_PCM_RATE_44100:
-	case SNDRV_PCM_RATE_48000:
+	case 44100:
+	case 48000:
 		break;
 	}
 
diff -Nur linux-2.6.32-orig/sound/soc/codecs/wm8903.c iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8903.c
--- linux-2.6.32-orig/sound/soc/codecs/wm8903.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8903.c	2010-11-18 21:05:30.000000000 +0600
@@ -1506,7 +1506,7 @@
 	struct i2c_client *i2c = codec->control_data;
 	int i;
 	u16 *reg_cache = codec->reg_cache;
-	u16 *tmp_cache = kmemdup(codec->reg_cache, sizeof(wm8903_reg_defaults),
+	u16 *tmp_cache = kmemdup(reg_cache, sizeof(wm8903_reg_defaults),
 				 GFP_KERNEL);
 
 	/* Bring the codec back up to standby first to minimise pop/clicks */
@@ -1518,6 +1518,7 @@
 		for (i = 2; i < ARRAY_SIZE(wm8903_reg_defaults); i++)
 			if (tmp_cache[i] != reg_cache[i])
 				snd_soc_write(codec, i, tmp_cache[i]);
+		kfree(tmp_cache);
 	} else {
 		dev_err(&i2c->dev, "Failed to allocate temporary cache\n");
 	}
diff -Nur linux-2.6.32-orig/sound/soc/codecs/wm8940.c iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8940.c
--- linux-2.6.32-orig/sound/soc/codecs/wm8940.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8940.c	2010-11-18 21:05:30.000000000 +0600
@@ -379,23 +379,23 @@
 		iface |= (1 << 9);
 
 	switch (params_rate(params)) {
-	case SNDRV_PCM_RATE_8000:
+	case 8000:
 		addcntrl |= (0x5 << 1);
 		break;
-	case SNDRV_PCM_RATE_11025:
+	case 11025:
 		addcntrl |= (0x4 << 1);
 		break;
-	case SNDRV_PCM_RATE_16000:
+	case 16000:
 		addcntrl |= (0x3 << 1);
 		break;
-	case SNDRV_PCM_RATE_22050:
+	case 22050:
 		addcntrl |= (0x2 << 1);
 		break;
-	case SNDRV_PCM_RATE_32000:
+	case 32000:
 		addcntrl |= (0x1 << 1);
 		break;
-	case SNDRV_PCM_RATE_44100:
-	case SNDRV_PCM_RATE_48000:
+	case 44100:
+	case 48000:
 		break;
 	}
 	ret = snd_soc_write(codec, WM8940_ADDCNTRL, addcntrl);
diff -Nur linux-2.6.32-orig/sound/soc/codecs/wm8974.c iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8974.c
--- linux-2.6.32-orig/sound/soc/codecs/wm8974.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8974.c	2010-11-18 21:05:30.000000000 +0600
@@ -47,7 +47,7 @@
 };
 
 #define WM8974_POWER1_BIASEN  0x08
-#define WM8974_POWER1_BUFIOEN 0x10
+#define WM8974_POWER1_BUFIOEN 0x04
 
 struct wm8974_priv {
 	struct snd_soc_codec codec;
@@ -480,23 +480,23 @@
 
 	/* filter coefficient */
 	switch (params_rate(params)) {
-	case SNDRV_PCM_RATE_8000:
+	case 8000:
 		adn |= 0x5 << 1;
 		break;
-	case SNDRV_PCM_RATE_11025:
+	case 11025:
 		adn |= 0x4 << 1;
 		break;
-	case SNDRV_PCM_RATE_16000:
+	case 16000:
 		adn |= 0x3 << 1;
 		break;
-	case SNDRV_PCM_RATE_22050:
+	case 22050:
 		adn |= 0x2 << 1;
 		break;
-	case SNDRV_PCM_RATE_32000:
+	case 32000:
 		adn |= 0x1 << 1;
 		break;
-	case SNDRV_PCM_RATE_44100:
-	case SNDRV_PCM_RATE_48000:
+	case 44100:
+	case 48000:
 		break;
 	}
 
diff -Nur linux-2.6.32-orig/sound/soc/codecs/wm8991.c iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8991.c
--- linux-2.6.32-orig/sound/soc/codecs/wm8991.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8991.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,1814 @@
+/*
+ * wm8991.c  --  WM8991 ALSA Soc Audio driver
+ *
+ * Copyright 2007, 2008 Wolfson Microelectronics PLC.
+ * Author: Graeme Gregory
+ *         linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <asm/div64.h>
+#include <linux/interrupt.h>
+#include <mach/gpio.h>
+#include <linux/switch.h>
+#include <linux/debugfs.h>
+
+#include "wm8991.h"
+
+#define WM8991_INT_GPIO 0x1604
+
+/* codec private data */
+struct wm8991_priv {
+	struct snd_soc_codec codec;
+	u16 reg_cache[WM8991_MAX_REGISTER + 1];
+	unsigned int sysclk;
+	unsigned int pcmclk;
+	struct switch_dev sdev;
+	struct work_struct switch_work;
+};
+
+static u32 headphone_plugged_in = 0;
+
+static struct dentry* debugfs_entry;
+struct debugfs_blob_wrapper debugfs_blob;
+
+/*
+ * wm8991 register cache
+ * We can't read the WM8991 register space when we
+ * are using 2 wire for device control, so we cache them instead.
+ */
+static const u16 wm8991_reg[] = {
+	0x8990,     /* R0  - Reset */
+	0x0000,     /* R1  - Power Management (1) */
+	0x6000,     /* R2  - Power Management (2) */
+	0x0000,     /* R3  - Power Management (3) */
+	0x4050,     /* R4  - Audio Interface (1) */
+	0x4000,     /* R5  - Audio Interface (2) */
+	0x01C8,     /* R6  - Clocking (1) */
+	0x0000,     /* R7  - Clocking (2) */
+	0x0020,     /* R8  - Audio Interface (3) */
+	0x0020,     /* R9  - Audio Interface (4) */
+	0x0004,     /* R10 - DAC CTRL */
+	0x00C0,     /* R11 - Left DAC Digital Volume */
+	0x00C0,     /* R12 - Right DAC Digital Volume */
+	0x0000,     /* R13 - Digital Side Tone */
+	0x0100,     /* R14 - ADC CTRL */
+	0x00C0,     /* R15 - Left ADC Digital Volume */
+	0x00C0,     /* R16 - Right ADC Digital Volume */
+	0x0000,     /* R17 */
+	0x0000,     /* R18 - GPIO CTRL 1 */
+	0x1700,     /* R19 - GPIO1 & GPIO2 */
+	0x1000,     /* R20 - GPIO3 & GPIO4 */
+	0x1040,     /* R21 - GPIO5 & GPIO6 */
+	0x0000,     /* R22 - GPIOCTRL 2 */
+	0x0804,     /* R23 - GPIO_POL */
+	0x008B,     /* R24 - Left Line Input 1&2 Volume */
+	0x008B,     /* R25 - Left Line Input 3&4 Volume */
+	0x008B,     /* R26 - Right Line Input 1&2 Volume */
+	0x008B,     /* R27 - Right Line Input 3&4 Volume */
+	0x0000,     /* R28 - Left Output Volume */
+	0x0000,     /* R29 - Right Output Volume */
+	0x0066,     /* R30 - Line Outputs Volume */
+	0x0022,     /* R31 - Out3/4 Volume */
+	0x0079,     /* R32 - Left OPGA Volume */
+	0x0079,     /* R33 - Right OPGA Volume */
+	0x0003,     /* R34 - Speaker Volume */
+	0x0003,     /* R35 - ClassD1 */
+	0x0057,     /* R36 */
+	0x0100,     /* R37 - ClassD3 */
+	0x0000,     /* R38 */
+	0x0000,     /* R39 - Input Mixer1 */
+	0x0000,     /* R40 - Input Mixer2 */
+	0x0000,     /* R41 - Input Mixer3 */
+	0x0000,     /* R42 - Input Mixer4 */
+	0x0000,     /* R43 - Input Mixer5 */
+	0x0000,     /* R44 - Input Mixer6 */
+	0x0000,     /* R45 - Output Mixer1 */
+	0x0000,     /* R46 - Output Mixer2 */
+	0x0000,     /* R47 - Output Mixer3 */
+	0x0000,     /* R48 - Output Mixer4 */
+	0x0000,     /* R49 - Output Mixer5 */
+	0x0000,     /* R50 - Output Mixer6 */
+	0x0180,     /* R51 - Out3/4 Mixer */
+	0x0000,     /* R52 - Line Mixer1 */
+	0x0000,     /* R53 - Line Mixer2 */
+	0x0000,     /* R54 - Speaker Mixer */
+	0x0000,     /* R55 - Additional Control */
+	0x0000,     /* R56 - AntiPOP1 */
+	0x0000,     /* R57 - AntiPOP2 */
+	0x0000,     /* R58 - MICBIAS */
+	0x0000,     /* R59 */
+	0x0008,     /* R60 - PLL1 */
+	0x0031,     /* R61 - PLL2 */
+	0x0026,     /* R62 - PLL3 */
+};
+
+/*
+ * read wm8991 register cache
+ */
+static inline unsigned int wm8991_read_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg < 1 || reg >= (ARRAY_SIZE(wm8991_reg)))
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * write wm8991 register cache
+ */
+static inline void wm8991_write_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg < 1 || reg > 0x3f)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the wm8991 register space
+ */
+static int wm8991_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	int ret = 0;
+	u8 data[3];
+
+	data[0] = reg & 0xFF;
+	data[1] = (value >> 8) & 0xFF;
+	data[2] = value & 0xFF;
+
+	wm8991_write_reg_cache(codec, reg, value);
+	ret = codec->hw_write(codec->control_data, data, 3);
+	if(ret != 3)
+	{
+		printk("WM8991 i2c returned %d!\n", ret);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static unsigned int wm8991_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	struct i2c_client* i2c = codec->control_data;
+	struct i2c_msg xfer[2];
+	u8 in;
+	u8 out[2];
+
+	in = reg;
+	xfer[0].addr = i2c->addr;
+	xfer[0].flags = 0;
+	xfer[0].len = 1;
+	xfer[0].buf = (u8*) &in;
+
+	xfer[1].addr = i2c->addr;
+	xfer[1].flags = I2C_M_RD;
+	xfer[1].len = 2;
+	xfer[1].buf = out;
+
+	if(i2c_transfer(i2c->adapter, xfer, 2) == 2)
+	{
+		u16 value = (out[0] << 8) | out[1];
+		wm8991_write_reg_cache(codec, reg, value);
+		return value;
+	}
+
+	return 0xFFFFFFFF;
+}
+
+#define wm8991_reset(c) wm8991_write(c, WM8991_RESET, 0)
+
+static const unsigned int rec_mix_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 7, TLV_DB_LINEAR_ITEM(-1500, 600),
+};
+
+static const unsigned int in_pga_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 0x1F, TLV_DB_LINEAR_ITEM(-1650, 3000),
+};
+
+static const unsigned int out_mix_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 7, TLV_DB_LINEAR_ITEM(0, -2100),
+};
+
+static const unsigned int out_pga_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 127, TLV_DB_LINEAR_ITEM(-7300, 600),
+};
+
+static const unsigned int out_omix_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 7, TLV_DB_LINEAR_ITEM(-600, 0),
+};
+
+static const unsigned int out_dac_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 255, TLV_DB_LINEAR_ITEM(-7163, 0),
+};
+
+static const unsigned int in_adc_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 255, TLV_DB_LINEAR_ITEM(-7163, 1763),
+};
+
+static const unsigned int out_sidetone_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 31, TLV_DB_LINEAR_ITEM(-3600, 0),
+};
+
+static int wm899x_outpga_put_volsw_vu(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control* ctrl = (struct soc_mixer_control*) kcontrol->private_value;
+	int reg = ctrl->reg;
+	int ret;
+	u16 val;
+
+	ret = snd_soc_put_volsw(kcontrol, ucontrol);
+	if (ret < 0)
+		return ret;
+
+	/* now hit the volume update bits (always bit 8) */
+	val = wm8991_read_reg_cache(codec, reg);
+	return wm8991_write(codec, reg, val | 0x0100);
+}
+
+static int wm899x_outpga_put_volsw_vu_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control* ctrl = (struct soc_mixer_control*) kcontrol->private_value;
+	int reg = ctrl->reg;
+	int reg_right = ctrl->rreg;
+	int ret;
+	u16 val;
+
+	ret = snd_soc_put_volsw_2r(kcontrol, ucontrol);
+	if (ret < 0)
+		return ret;
+
+	/* now hit the volume update bits (always bit 8) */
+	val = wm8991_read_reg_cache(codec, reg);
+	ret = wm8991_write(codec, reg, val | 0x0100);
+	if (ret < 0)
+		return ret;
+
+	val = wm8991_read_reg_cache(codec, reg_right);
+	return wm8991_write(codec, reg, val | 0x0100);
+}
+
+#define SOC_WM899X_OUTPGA_SINGLE_R_TLV(xname, reg, shift, max, invert,\
+					 tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw, \
+	.get = snd_soc_get_volsw, .put = wm899x_outpga_put_volsw_vu, \
+	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert) }
+
+#define SOC_WM899X_OUTPGA_DOUBLE_R_TLV(xname, reg_left, reg_right, xshift, xmax, xinvert,\
+					 tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw_2r, \
+	.get = snd_soc_get_volsw_2r, .put = wm899x_outpga_put_volsw_vu_2r, \
+	.private_value = (unsigned long)&(struct soc_mixer_control) \
+		{.reg = reg_left, .rreg = reg_right, .shift = xshift, \
+		.max = xmax, .invert = xinvert} }
+
+static const char *wm8991_digital_sidetone[] =
+	{"None", "Left ADC", "Right ADC", "Reserved"};
+
+static const struct soc_enum wm8991_left_digital_sidetone_enum =
+SOC_ENUM_SINGLE(WM8991_DIGITAL_SIDE_TONE,
+	WM8991_ADC_TO_DACL_SHIFT,
+	WM8991_ADC_TO_DACL_MASK,
+	wm8991_digital_sidetone);
+
+static const struct soc_enum wm8991_right_digital_sidetone_enum =
+SOC_ENUM_SINGLE(WM8991_DIGITAL_SIDE_TONE,
+	WM8991_ADC_TO_DACR_SHIFT,
+	WM8991_ADC_TO_DACR_MASK,
+	wm8991_digital_sidetone);
+
+static const char *wm8991_adcmode[] =
+	{"Hi-fi mode", "Voice mode 1", "Voice mode 2", "Voice mode 3"};
+
+static const struct soc_enum wm8991_right_adcmode_enum =
+SOC_ENUM_SINGLE(WM8991_ADC_CTRL,
+	WM8991_ADC_HPF_CUT_SHIFT,
+	WM8991_ADC_HPF_CUT_MASK,
+	wm8991_adcmode);
+
+static const struct snd_kcontrol_new wm8991_snd_controls[] = {
+/* INMIXL */
+SOC_SINGLE("LIN12 PGA Boost", WM8991_INPUT_MIXER3, WM8991_L12MNBST_BIT, 1, 0),
+SOC_SINGLE("LIN34 PGA Boost", WM8991_INPUT_MIXER3, WM8991_L34MNBST_BIT, 1, 0),
+/* INMIXR */
+SOC_SINGLE("RIN12 PGA Boost", WM8991_INPUT_MIXER3, WM8991_R12MNBST_BIT, 1, 0),
+SOC_SINGLE("RIN34 PGA Boost", WM8991_INPUT_MIXER3, WM8991_R34MNBST_BIT, 1, 0),
+
+/* LOMIX */
+SOC_SINGLE_TLV("LOMIX LIN3 Bypass Volume", WM8991_OUTPUT_MIXER3,
+	WM8991_LLI3LOVOL_SHIFT, WM8991_LLI3LOVOL_MASK, 1, out_mix_tlv),
+SOC_SINGLE_TLV("LOMIX RIN12 PGA Bypass Volume", WM8991_OUTPUT_MIXER3,
+	WM8991_LR12LOVOL_SHIFT, WM8991_LR12LOVOL_MASK, 1, out_mix_tlv),
+SOC_SINGLE_TLV("LOMIX LIN12 PGA Bypass Volume", WM8991_OUTPUT_MIXER3,
+	WM8991_LL12LOVOL_SHIFT, WM8991_LL12LOVOL_MASK, 1, out_mix_tlv),
+SOC_SINGLE_TLV("LOMIX RIN3 Bypass Volume", WM8991_OUTPUT_MIXER5,
+	WM8991_LRI3LOVOL_SHIFT, WM8991_LRI3LOVOL_MASK, 1, out_mix_tlv),
+SOC_SINGLE_TLV("LOMIX AINRMUX Bypass Volume", WM8991_OUTPUT_MIXER5,
+	WM8991_LRBLOVOL_SHIFT, WM8991_LRBLOVOL_MASK, 1, out_mix_tlv),
+SOC_SINGLE_TLV("LOMIX AINLMUX Bypass Volume", WM8991_OUTPUT_MIXER5,
+	WM8991_LRBLOVOL_SHIFT, WM8991_LRBLOVOL_MASK, 1, out_mix_tlv),
+
+/* ROMIX */
+SOC_SINGLE_TLV("ROMIX RIN3 Bypass Volume", WM8991_OUTPUT_MIXER4,
+	WM8991_RRI3ROVOL_SHIFT, WM8991_RRI3ROVOL_MASK, 1, out_mix_tlv),
+SOC_SINGLE_TLV("ROMIX LIN12 PGA Bypass Volume", WM8991_OUTPUT_MIXER4,
+	WM8991_RL12ROVOL_SHIFT, WM8991_RL12ROVOL_MASK, 1, out_mix_tlv),
+SOC_SINGLE_TLV("ROMIX RIN12 PGA Bypass Volume", WM8991_OUTPUT_MIXER4,
+	WM8991_RR12ROVOL_SHIFT, WM8991_RR12ROVOL_MASK, 1, out_mix_tlv),
+SOC_SINGLE_TLV("ROMIX LIN3 Bypass Volume", WM8991_OUTPUT_MIXER6,
+	WM8991_RLI3ROVOL_SHIFT, WM8991_RLI3ROVOL_MASK, 1, out_mix_tlv),
+SOC_SINGLE_TLV("ROMIX AINLMUX Bypass Volume", WM8991_OUTPUT_MIXER6,
+	WM8991_RLBROVOL_SHIFT, WM8991_RLBROVOL_MASK, 1, out_mix_tlv),
+SOC_SINGLE_TLV("ROMIX AINRMUX Bypass Volume", WM8991_OUTPUT_MIXER6,
+	WM8991_RRBROVOL_SHIFT, WM8991_RRBROVOL_MASK, 1, out_mix_tlv),
+
+/* LOUT */
+SOC_WM899X_OUTPGA_SINGLE_R_TLV("LOUT Volume", WM8991_LEFT_OUTPUT_VOLUME,
+	WM8991_LOUTVOL_SHIFT, WM8991_LOUTVOL_MASK, 0, out_pga_tlv),
+SOC_SINGLE("LOUT ZC", WM8991_LEFT_OUTPUT_VOLUME, WM8991_LOZC_BIT, 1, 0),
+
+/* ROUT */
+SOC_WM899X_OUTPGA_SINGLE_R_TLV("ROUT Volume", WM8991_RIGHT_OUTPUT_VOLUME,
+	WM8991_ROUTVOL_SHIFT, WM8991_ROUTVOL_MASK, 0, out_pga_tlv),
+SOC_SINGLE("ROUT ZC", WM8991_RIGHT_OUTPUT_VOLUME, WM8991_ROZC_BIT, 1, 0),
+
+SOC_WM899X_OUTPGA_DOUBLE_R_TLV("Headphone Volume", WM8991_LEFT_OUTPUT_VOLUME, WM8991_RIGHT_OUTPUT_VOLUME,
+	WM8991_ROUTVOL_SHIFT, WM8991_ROUTVOL_MASK, 0, out_pga_tlv),
+
+/* LOPGA */
+SOC_WM899X_OUTPGA_SINGLE_R_TLV("LOPGA Volume", WM8991_LEFT_OPGA_VOLUME,
+	WM8991_LOPGAVOL_SHIFT, WM8991_LOPGAVOL_MASK, 0, out_pga_tlv),
+SOC_SINGLE("LOPGA ZC Switch", WM8991_LEFT_OPGA_VOLUME,
+	WM8991_LOPGAZC_BIT, 1, 0),
+
+/* ROPGA */
+SOC_WM899X_OUTPGA_SINGLE_R_TLV("ROPGA Volume", WM8991_RIGHT_OPGA_VOLUME,
+	WM8991_ROPGAVOL_SHIFT, WM8991_ROPGAVOL_MASK, 0, out_pga_tlv),
+SOC_SINGLE("ROPGA ZC Switch", WM8991_RIGHT_OPGA_VOLUME,
+	WM8991_ROPGAZC_BIT, 1, 0),
+
+SOC_SINGLE("LON Mute Switch", WM8991_LINE_OUTPUTS_VOLUME,
+	WM8991_LONMUTE_BIT, 1, 0),
+SOC_SINGLE("LOP Mute Switch", WM8991_LINE_OUTPUTS_VOLUME,
+	WM8991_LOPMUTE_BIT, 1, 0),
+SOC_SINGLE("LOP Attenuation Switch", WM8991_LINE_OUTPUTS_VOLUME,
+	WM8991_LOATTN_BIT, 1, 0),
+SOC_SINGLE("RON Mute Switch", WM8991_LINE_OUTPUTS_VOLUME,
+	WM8991_RONMUTE_BIT, 1, 0),
+SOC_SINGLE("ROP Mute Switch", WM8991_LINE_OUTPUTS_VOLUME,
+	WM8991_ROPMUTE_BIT, 1, 0),
+SOC_SINGLE("ROP Attenuation Switch", WM8991_LINE_OUTPUTS_VOLUME,
+	WM8991_ROATTN_BIT, 1, 0),
+
+SOC_SINGLE("OUT3 Mute Switch", WM8991_OUT3_4_VOLUME,
+	WM8991_OUT3MUTE_BIT, 1, 0),
+SOC_SINGLE("OUT3 Attenuation Switch", WM8991_OUT3_4_VOLUME,
+	WM8991_OUT3ATTN_BIT, 1, 0),
+
+SOC_SINGLE("OUT4 Mute Switch", WM8991_OUT3_4_VOLUME,
+	WM8991_OUT4MUTE_BIT, 1, 0),
+SOC_SINGLE("OUT4 Attenuation Switch", WM8991_OUT3_4_VOLUME,
+	WM8991_OUT4ATTN_BIT, 1, 0),
+
+SOC_SINGLE("Speaker Mode Switch", WM8991_CLASSD1,
+	WM8991_CDMODE_BIT, 1, 0),
+
+SOC_SINGLE("Speaker Output Attenuation Volume", WM8991_SPEAKER_VOLUME,
+	WM8991_SPKATTN_SHIFT, WM8991_SPKATTN_MASK, 0),
+SOC_SINGLE("Speaker PGA Volume", WM8991_CLASSD4,
+	WM8991_SPKVOL_SHIFT, WM8991_SPKVOL_MASK, 0),
+SOC_SINGLE("Speaker ZC", WM8991_CLASSD4, WM8991_SPKZC_BIT, 1, 0), 
+SOC_SINGLE("Speaker DC Boost Volume", WM8991_CLASSD3,
+	WM8991_DCGAIN_SHIFT, WM8991_DCGAIN_MASK, 0),
+SOC_SINGLE("Speaker AC Boost Volume", WM8991_CLASSD3,
+	WM8991_ACGAIN_SHIFT, WM8991_ACGAIN_MASK, 0),
+
+SOC_WM899X_OUTPGA_SINGLE_R_TLV("Left DAC Digital Volume",
+	WM8991_LEFT_DAC_DIGITAL_VOLUME,
+	WM8991_DACL_VOL_SHIFT,
+	WM8991_DACL_VOL_MASK,
+	0,
+	out_dac_tlv),
+
+SOC_WM899X_OUTPGA_SINGLE_R_TLV("Right DAC Digital Volume",
+	WM8991_RIGHT_DAC_DIGITAL_VOLUME,
+	WM8991_DACR_VOL_SHIFT,
+	WM8991_DACR_VOL_MASK,
+	0,
+	out_dac_tlv),
+
+SOC_ENUM("Left Digital Sidetone", wm8991_left_digital_sidetone_enum),
+SOC_ENUM("Right Digital Sidetone", wm8991_right_digital_sidetone_enum),
+
+SOC_SINGLE_TLV("Left Digital Sidetone Volume", WM8991_DIGITAL_SIDE_TONE,
+	WM8991_ADCL_DAC_SVOL_SHIFT, WM8991_ADCL_DAC_SVOL_MASK, 0,
+	out_sidetone_tlv),
+SOC_SINGLE_TLV("Right Digital Sidetone Volume", WM8991_DIGITAL_SIDE_TONE,
+	WM8991_ADCR_DAC_SVOL_SHIFT, WM8991_ADCR_DAC_SVOL_MASK, 0,
+	out_sidetone_tlv),
+
+SOC_SINGLE("ADC Digital High Pass Filter Switch", WM8991_ADC_CTRL,
+	WM8991_ADC_HPF_ENA_BIT, 1, 0),
+
+SOC_ENUM("ADC HPF Mode", wm8991_right_adcmode_enum),
+
+SOC_WM899X_OUTPGA_SINGLE_R_TLV("Left ADC Digital Volume",
+	WM8991_LEFT_ADC_DIGITAL_VOLUME,
+	WM8991_ADCL_VOL_SHIFT,
+	WM8991_ADCL_VOL_MASK,
+	0,
+	in_adc_tlv),
+
+SOC_WM899X_OUTPGA_SINGLE_R_TLV("Right ADC Digital Volume",
+	WM8991_RIGHT_ADC_DIGITAL_VOLUME,
+	WM8991_ADCR_VOL_SHIFT,
+	WM8991_ADCR_VOL_MASK,
+	0,
+	in_adc_tlv),
+
+SOC_WM899X_OUTPGA_SINGLE_R_TLV("LIN12 Volume",
+	WM8991_LEFT_LINE_INPUT_1_2_VOLUME,
+	WM8991_LIN12VOL_SHIFT,
+	WM8991_LIN12VOL_MASK,
+	0,
+	in_pga_tlv),
+
+SOC_SINGLE("LIN12 ZC Switch", WM8991_LEFT_LINE_INPUT_1_2_VOLUME,
+	WM8991_LI12ZC_BIT, 1, 0),
+
+SOC_SINGLE("LIN12 Mute Switch", WM8991_LEFT_LINE_INPUT_1_2_VOLUME,
+	WM8991_LI12MUTE_BIT, 1, 0),
+
+SOC_WM899X_OUTPGA_SINGLE_R_TLV("LIN34 Volume",
+	WM8991_LEFT_LINE_INPUT_3_4_VOLUME,
+	WM8991_LIN34VOL_SHIFT,
+	WM8991_LIN34VOL_MASK,
+	0,
+	in_pga_tlv),
+
+SOC_SINGLE("LIN34 ZC Switch", WM8991_LEFT_LINE_INPUT_3_4_VOLUME,
+	WM8991_LI34ZC_BIT, 1, 0),
+
+SOC_SINGLE("LIN34 Mute Switch", WM8991_LEFT_LINE_INPUT_3_4_VOLUME,
+	WM8991_LI34MUTE_BIT, 1, 0),
+
+SOC_WM899X_OUTPGA_SINGLE_R_TLV("RIN12 Volume",
+	WM8991_RIGHT_LINE_INPUT_1_2_VOLUME,
+	WM8991_RIN12VOL_SHIFT,
+	WM8991_RIN12VOL_MASK,
+	0,
+	in_pga_tlv),
+
+SOC_SINGLE("RIN12 ZC Switch", WM8991_RIGHT_LINE_INPUT_1_2_VOLUME,
+	WM8991_RI12ZC_BIT, 1, 0),
+
+SOC_SINGLE("RIN12 Mute Switch", WM8991_RIGHT_LINE_INPUT_1_2_VOLUME,
+	WM8991_RI12MUTE_BIT, 1, 0),
+
+SOC_WM899X_OUTPGA_SINGLE_R_TLV("RIN34 Volume",
+	WM8991_RIGHT_LINE_INPUT_3_4_VOLUME,
+	WM8991_RIN34VOL_SHIFT,
+	WM8991_RIN34VOL_MASK,
+	0,
+	in_pga_tlv),
+
+SOC_SINGLE("RIN34 ZC Switch", WM8991_RIGHT_LINE_INPUT_3_4_VOLUME,
+	WM8991_RI34ZC_BIT, 1, 0),
+
+SOC_SINGLE("RIN34 Mute Switch", WM8991_RIGHT_LINE_INPUT_3_4_VOLUME,
+	WM8991_RI34MUTE_BIT, 1, 0),
+
+SOC_SINGLE("Mic Short Circuit Current Detect Threshold", WM8991_MICBIAS,
+	WM8991_MCDSCTH, 3, 0),
+
+SOC_SINGLE("Mic Enable Switch", WM8991_POWER_MANAGEMENT_1,
+	WM8991_MIC_ENA_BIT, 1, 0),
+
+};
+
+/*
+ * _DAPM_ Controls
+ */
+static int inmixer_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	u16 reg, fakepower;
+
+	reg = wm8991_read_reg_cache(w->codec, WM8991_POWER_MANAGEMENT_2);
+	fakepower = wm8991_read_reg_cache(w->codec, WM8991_INTDRIVBITS);
+
+	if (fakepower & ((1 << WM8991_INMIXL_PWR_BIT) |
+		(1 << WM8991_AINLMUX_PWR_BIT))) {
+		reg |= WM8991_AINL_ENA;
+	} else {
+		reg &= ~WM8991_AINL_ENA;
+	}
+
+	if (fakepower & ((1 << WM8991_INMIXR_PWR_BIT) |
+		(1 << WM8991_AINRMUX_PWR_BIT))) {
+		reg |= WM8991_AINR_ENA;
+	} else {
+		reg &= ~WM8991_AINL_ENA;
+	}
+	wm8991_write(w->codec, WM8991_POWER_MANAGEMENT_2, reg);
+
+	return 0;
+}
+
+static int outmixer_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct soc_mixer_control* ctrl = (struct soc_mixer_control*) kcontrol->private_value;
+	u32 reg_shift = ctrl->reg | (ctrl->shift << 8);
+	int ret = 0;
+	u16 reg;
+
+	switch (reg_shift) {
+	case WM8991_SPEAKER_MIXER | (WM8991_LDSPK_BIT << 8):
+		reg = wm8991_read_reg_cache(w->codec, WM8991_OUTPUT_MIXER1);
+		if (reg & WM8991_LDLO) {
+			printk(KERN_WARNING
+			"Cannot set as Output Mixer 1 LDLO Set\n");
+			ret = -1;
+		}
+		break;
+
+	case WM8991_SPEAKER_MIXER | (WM8991_RDSPK_BIT << 8):
+		reg = wm8991_read_reg_cache(w->codec, WM8991_OUTPUT_MIXER2);
+		if (reg & WM8991_RDRO) {
+			printk(KERN_WARNING
+			"Cannot set as Output Mixer 2 RDRO Set\n");
+			ret = -1;
+		}
+		break;
+
+	case WM8991_OUTPUT_MIXER1 | (WM8991_LDLO_BIT << 8):
+		reg = wm8991_read_reg_cache(w->codec, WM8991_SPEAKER_MIXER);
+		if (reg & WM8991_LDSPK) {
+			printk(KERN_WARNING
+			"Cannot set as Speaker Mixer LDSPK Set\n");
+			ret = -1;
+		}
+		break;
+
+	case WM8991_OUTPUT_MIXER2 | (WM8991_RDRO_BIT << 8):
+		reg = wm8991_read_reg_cache(w->codec, WM8991_SPEAKER_MIXER);
+		if (reg & WM8991_RDSPK) {
+			printk(KERN_WARNING
+			"Cannot set as Speaker Mixer RDSPK Set\n");
+			ret = -1;
+		}
+		break;
+
+	default:
+		printk("wm8991: unknown event 0x%x\n", reg_shift);
+//		BUG();
+	}
+
+	return ret;
+}
+
+/* INMIX dB values */
+static const unsigned int in_mix_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 7, TLV_DB_LINEAR_ITEM(-1200, 600),
+};
+
+/* Left In PGA Connections */
+static const struct snd_kcontrol_new wm8991_dapm_lin12_pga_controls[] = {
+SOC_DAPM_SINGLE("LIN1 Switch", WM8991_INPUT_MIXER2, WM8991_LMN1_BIT, 1, 0),
+SOC_DAPM_SINGLE("LIN2 Switch", WM8991_INPUT_MIXER2, WM8991_LMP2_BIT, 1, 0),
+};
+
+static const struct snd_kcontrol_new wm8991_dapm_lin34_pga_controls[] = {
+SOC_DAPM_SINGLE("LIN3 Switch", WM8991_INPUT_MIXER2, WM8991_LMN3_BIT, 1, 0),
+SOC_DAPM_SINGLE("LIN4 Switch", WM8991_INPUT_MIXER2, WM8991_LMP4_BIT, 1, 0),
+};
+
+/* Right In PGA Connections */
+static const struct snd_kcontrol_new wm8991_dapm_rin12_pga_controls[] = {
+SOC_DAPM_SINGLE("RIN1 Switch", WM8991_INPUT_MIXER2, WM8991_RMN1_BIT, 1, 0),
+SOC_DAPM_SINGLE("RIN2 Switch", WM8991_INPUT_MIXER2, WM8991_RMP2_BIT, 1, 0),
+};
+
+static const struct snd_kcontrol_new wm8991_dapm_rin34_pga_controls[] = {
+SOC_DAPM_SINGLE("RIN3 Switch", WM8991_INPUT_MIXER2, WM8991_RMN3_BIT, 1, 0),
+SOC_DAPM_SINGLE("RIN4 Switch", WM8991_INPUT_MIXER2, WM8991_RMP4_BIT, 1, 0),
+};
+
+/* INMIXL */
+static const struct snd_kcontrol_new wm8991_dapm_inmixl_controls[] = {
+SOC_DAPM_SINGLE_TLV("Record Left Volume", WM8991_INPUT_MIXER3,
+	WM8991_LDBVOL_SHIFT, WM8991_LDBVOL_MASK, 0, in_mix_tlv),
+SOC_DAPM_SINGLE_TLV("LIN2 Volume", WM8991_INPUT_MIXER5, WM8991_LI2BVOL_SHIFT,
+	7, 0, in_mix_tlv),
+SOC_DAPM_SINGLE("LINPGA12 Switch", WM8991_INPUT_MIXER3, WM8991_L12MNB_BIT,
+		1, 0),
+SOC_DAPM_SINGLE("LINPGA34 Switch", WM8991_INPUT_MIXER3, WM8991_L34MNB_BIT,
+		1, 0),
+};
+
+/* INMIXR */
+static const struct snd_kcontrol_new wm8991_dapm_inmixr_controls[] = {
+SOC_DAPM_SINGLE_TLV("Record Right Volume", WM8991_INPUT_MIXER4,
+	WM8991_RDBVOL_SHIFT, WM8991_RDBVOL_MASK, 0, in_mix_tlv),
+SOC_DAPM_SINGLE_TLV("RIN2 Volume", WM8991_INPUT_MIXER6, WM8991_RI2BVOL_SHIFT,
+	7, 0, in_mix_tlv),
+SOC_DAPM_SINGLE("RINPGA12 Switch", WM8991_INPUT_MIXER3, WM8991_L12MNB_BIT,
+	1, 0),
+SOC_DAPM_SINGLE("RINPGA34 Switch", WM8991_INPUT_MIXER3, WM8991_L34MNB_BIT,
+	1, 0),
+};
+
+/* AINLMUX */
+static const char *wm8991_ainlmux[] =
+	{"INMIXL Mix", "RXVOICE Mix", "DIFFINL Mix"};
+
+static const struct soc_enum wm8991_ainlmux_enum =
+SOC_ENUM_SINGLE(WM8991_INPUT_MIXER1, WM8991_AINLMODE_SHIFT,
+	ARRAY_SIZE(wm8991_ainlmux), wm8991_ainlmux);
+
+static const struct snd_kcontrol_new wm8991_dapm_ainlmux_controls =
+SOC_DAPM_ENUM("Route", wm8991_ainlmux_enum);
+
+/* DIFFINL */
+
+/* AINRMUX */
+static const char *wm8991_ainrmux[] =
+	{"INMIXR Mix", "RXVOICE Mix", "DIFFINR Mix"};
+
+static const struct soc_enum wm8991_ainrmux_enum =
+SOC_ENUM_SINGLE(WM8991_INPUT_MIXER1, WM8991_AINRMODE_SHIFT,
+	ARRAY_SIZE(wm8991_ainrmux), wm8991_ainrmux);
+
+static const struct snd_kcontrol_new wm8991_dapm_ainrmux_controls =
+SOC_DAPM_ENUM("Route", wm8991_ainrmux_enum);
+
+/* RXVOICE */
+static const struct snd_kcontrol_new wm8991_dapm_rxvoice_controls[] = {
+SOC_DAPM_SINGLE_TLV("LIN4/RXN", WM8991_INPUT_MIXER5, WM8991_LR4BVOL_SHIFT,
+			WM8991_LR4BVOL_MASK, 0, in_mix_tlv),
+SOC_DAPM_SINGLE_TLV("RIN4/RXP", WM8991_INPUT_MIXER6, WM8991_RL4BVOL_SHIFT,
+			WM8991_RL4BVOL_MASK, 0, in_mix_tlv),
+};
+
+/* LOMIX */
+static const struct snd_kcontrol_new wm8991_dapm_lomix_controls[] = {
+SOC_DAPM_SINGLE("LOMIX Right ADC Bypass Switch", WM8991_OUTPUT_MIXER1,
+	WM8991_LRBLO_BIT, 1, 0),
+SOC_DAPM_SINGLE("LOMIX Left ADC Bypass Switch", WM8991_OUTPUT_MIXER1,
+	WM8991_LLBLO_BIT, 1, 0),
+SOC_DAPM_SINGLE("LOMIX RIN3 Bypass Switch", WM8991_OUTPUT_MIXER1,
+	WM8991_LRI3LO_BIT, 1, 0),
+SOC_DAPM_SINGLE("LOMIX LIN3 Bypass Switch", WM8991_OUTPUT_MIXER1,
+	WM8991_LLI3LO_BIT, 1, 0),
+SOC_DAPM_SINGLE("LOMIX RIN12 PGA Bypass Switch", WM8991_OUTPUT_MIXER1,
+	WM8991_LR12LO_BIT, 1, 0),
+SOC_DAPM_SINGLE("LOMIX LIN12 PGA Bypass Switch", WM8991_OUTPUT_MIXER1,
+	WM8991_LL12LO_BIT, 1, 0),
+SOC_DAPM_SINGLE("LOMIX Left DAC Switch", WM8991_OUTPUT_MIXER1,
+	WM8991_LDLO_BIT, 1, 0),
+};
+
+/* ROMIX */
+static const struct snd_kcontrol_new wm8991_dapm_romix_controls[] = {
+SOC_DAPM_SINGLE("ROMIX Left ADC Bypass Switch", WM8991_OUTPUT_MIXER2,
+	WM8991_RLBRO_BIT, 1, 0),
+SOC_DAPM_SINGLE("ROMIX Right ADC Bypass Switch", WM8991_OUTPUT_MIXER2,
+	WM8991_RRBRO_BIT, 1, 0),
+SOC_DAPM_SINGLE("ROMIX LIN3 Bypass Switch", WM8991_OUTPUT_MIXER2,
+	WM8991_RLI3RO_BIT, 1, 0),
+SOC_DAPM_SINGLE("ROMIX RIN3 Bypass Switch", WM8991_OUTPUT_MIXER2,
+	WM8991_RRI3RO_BIT, 1, 0),
+SOC_DAPM_SINGLE("ROMIX LIN12 PGA Bypass Switch", WM8991_OUTPUT_MIXER2,
+	WM8991_RL12RO_BIT, 1, 0),
+SOC_DAPM_SINGLE("ROMIX RIN12 PGA Bypass Switch", WM8991_OUTPUT_MIXER2,
+	WM8991_RR12RO_BIT, 1, 0),
+SOC_DAPM_SINGLE("ROMIX Right DAC Switch", WM8991_OUTPUT_MIXER2,
+	WM8991_RDRO_BIT, 1, 0),
+};
+
+/* LONMIX */
+static const struct snd_kcontrol_new wm8991_dapm_lonmix_controls[] = {
+SOC_DAPM_SINGLE("LONMIX Left Mixer PGA Switch", WM8991_LINE_MIXER1,
+	WM8991_LLOPGALON_BIT, 1, 0),
+SOC_DAPM_SINGLE("LONMIX Right Mixer PGA Switch", WM8991_LINE_MIXER1,
+	WM8991_LROPGALON_BIT, 1, 0),
+SOC_DAPM_SINGLE("LONMIX Inverted LOP Switch", WM8991_LINE_MIXER1,
+	WM8991_LOPLON_BIT, 1, 0),
+};
+
+/* LOPMIX */
+static const struct snd_kcontrol_new wm8991_dapm_lopmix_controls[] = {
+SOC_DAPM_SINGLE("LOPMIX Right Mic Bypass Switch", WM8991_LINE_MIXER1,
+	WM8991_LR12LOP_BIT, 1, 0),
+SOC_DAPM_SINGLE("LOPMIX Left Mic Bypass Switch", WM8991_LINE_MIXER1,
+	WM8991_LL12LOP_BIT, 1, 0),
+SOC_DAPM_SINGLE("LOPMIX Left Mixer PGA Switch", WM8991_LINE_MIXER1,
+	WM8991_LLOPGALOP_BIT, 1, 0),
+};
+
+/* RONMIX */
+static const struct snd_kcontrol_new wm8991_dapm_ronmix_controls[] = {
+SOC_DAPM_SINGLE("RONMIX Right Mixer PGA Switch", WM8991_LINE_MIXER2,
+	WM8991_RROPGARON_BIT, 1, 0),
+SOC_DAPM_SINGLE("RONMIX Left Mixer PGA Switch", WM8991_LINE_MIXER2,
+	WM8991_RLOPGARON_BIT, 1, 0),
+SOC_DAPM_SINGLE("RONMIX Inverted ROP Switch", WM8991_LINE_MIXER2,
+	WM8991_ROPRON_BIT, 1, 0),
+};
+
+/* ROPMIX */
+static const struct snd_kcontrol_new wm8991_dapm_ropmix_controls[] = {
+SOC_DAPM_SINGLE("ROPMIX Left Mic Bypass Switch", WM8991_LINE_MIXER2,
+	WM8991_RL12ROP_BIT, 1, 0),
+SOC_DAPM_SINGLE("ROPMIX Right Mic Bypass Switch", WM8991_LINE_MIXER2,
+	WM8991_RR12ROP_BIT, 1, 0),
+SOC_DAPM_SINGLE("ROPMIX Right Mixer PGA Switch", WM8991_LINE_MIXER2,
+	WM8991_RROPGAROP_BIT, 1, 0),
+};
+
+/* OUT3MIX */
+static const struct snd_kcontrol_new wm8991_dapm_out3mix_controls[] = {
+SOC_DAPM_SINGLE("OUT3MIX LIN4/RXN Bypass Switch", WM8991_OUT3_4_MIXER,
+	WM8991_LI4O3_BIT, 1, 0),
+SOC_DAPM_SINGLE("OUT3MIX Left Out PGA Switch", WM8991_OUT3_4_MIXER,
+	WM8991_LPGAO3_BIT, 1, 0),
+};
+
+/* OUT4MIX */
+static const struct snd_kcontrol_new wm8991_dapm_out4mix_controls[] = {
+SOC_DAPM_SINGLE("OUT4MIX Right Out PGA Switch", WM8991_OUT3_4_MIXER,
+	WM8991_RPGAO4_BIT, 1, 0),
+SOC_DAPM_SINGLE("OUT4MIX RIN4/RXP Bypass Switch", WM8991_OUT3_4_MIXER,
+	WM8991_RI4O4_BIT, 1, 0),
+};
+
+/* SPKMIX */
+static const struct snd_kcontrol_new wm8991_dapm_spkmix_controls[] = {
+SOC_DAPM_SINGLE("SPKMIX LIN2 Bypass Switch", WM8991_SPEAKER_MIXER,
+	WM8991_LI2SPK_BIT, 1, 0),
+SOC_DAPM_SINGLE("SPKMIX LADC Bypass Switch", WM8991_SPEAKER_MIXER,
+	WM8991_LB2SPK_BIT, 1, 0),
+SOC_DAPM_SINGLE("SPKMIX Left Mixer PGA Switch", WM8991_SPEAKER_MIXER,
+	WM8991_LOPGASPK_BIT, 1, 0),
+SOC_DAPM_SINGLE("SPKMIX Left DAC Switch", WM8991_SPEAKER_MIXER,
+	WM8991_LDSPK_BIT, 1, 0),
+SOC_DAPM_SINGLE("SPKMIX Right DAC Switch", WM8991_SPEAKER_MIXER,
+	WM8991_RDSPK_BIT, 1, 0),
+SOC_DAPM_SINGLE("SPKMIX Right Mixer PGA Switch", WM8991_SPEAKER_MIXER,
+	WM8991_ROPGASPK_BIT, 1, 0),
+SOC_DAPM_SINGLE("SPKMIX RADC Bypass Switch", WM8991_SPEAKER_MIXER,
+	WM8991_RL12ROP_BIT, 1, 0),
+SOC_DAPM_SINGLE("SPKMIX RIN2 Bypass Switch", WM8991_SPEAKER_MIXER,
+	WM8991_RI2SPK_BIT, 1, 0),
+};
+
+static const struct snd_soc_dapm_widget wm8991_dapm_widgets[] = {
+/* Input Side */
+/* Input Lines */
+SND_SOC_DAPM_INPUT("LIN1"),
+SND_SOC_DAPM_INPUT("LIN2"),
+SND_SOC_DAPM_INPUT("LIN3"),
+SND_SOC_DAPM_INPUT("LIN4/RXN"),
+SND_SOC_DAPM_INPUT("RIN3"),
+SND_SOC_DAPM_INPUT("RIN4/RXP"),
+SND_SOC_DAPM_INPUT("RIN1"),
+SND_SOC_DAPM_INPUT("RIN2"),
+SND_SOC_DAPM_INPUT("Internal ADC Source"),
+
+/* DACs */
+SND_SOC_DAPM_ADC("Left ADC", "Left Capture", WM8991_POWER_MANAGEMENT_2,
+	WM8991_ADCL_ENA_BIT, 0),
+SND_SOC_DAPM_ADC("Right ADC", "Right Capture", WM8991_POWER_MANAGEMENT_2,
+	WM8991_ADCR_ENA_BIT, 0),
+
+/* Input PGAs */
+SND_SOC_DAPM_MIXER("LIN12 PGA", WM8991_POWER_MANAGEMENT_2, WM8991_LIN12_ENA_BIT,
+	0, &wm8991_dapm_lin12_pga_controls[0],
+	ARRAY_SIZE(wm8991_dapm_lin12_pga_controls)),
+SND_SOC_DAPM_MIXER("LIN34 PGA", WM8991_POWER_MANAGEMENT_2, WM8991_LIN34_ENA_BIT,
+	0, &wm8991_dapm_lin34_pga_controls[0],
+	ARRAY_SIZE(wm8991_dapm_lin34_pga_controls)),
+SND_SOC_DAPM_MIXER("RIN12 PGA", WM8991_POWER_MANAGEMENT_2, WM8991_RIN12_ENA_BIT,
+	0, &wm8991_dapm_rin12_pga_controls[0],
+	ARRAY_SIZE(wm8991_dapm_rin12_pga_controls)),
+SND_SOC_DAPM_MIXER("RIN34 PGA", WM8991_POWER_MANAGEMENT_2, WM8991_RIN34_ENA_BIT,
+	0, &wm8991_dapm_rin34_pga_controls[0],
+	ARRAY_SIZE(wm8991_dapm_rin34_pga_controls)),
+
+/* INMIXL */
+SND_SOC_DAPM_MIXER_E("INMIXL", WM8991_INTDRIVBITS, WM8991_INMIXL_PWR_BIT, 0,
+	&wm8991_dapm_inmixl_controls[0],
+	ARRAY_SIZE(wm8991_dapm_inmixl_controls),
+	inmixer_event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+/* AINLMUX */
+SND_SOC_DAPM_MUX_E("AILNMUX", WM8991_INTDRIVBITS, WM8991_AINLMUX_PWR_BIT, 0,
+	&wm8991_dapm_ainlmux_controls, inmixer_event,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+/* INMIXR */
+SND_SOC_DAPM_MIXER_E("INMIXR", WM8991_INTDRIVBITS, WM8991_INMIXR_PWR_BIT, 0,
+	&wm8991_dapm_inmixr_controls[0],
+	ARRAY_SIZE(wm8991_dapm_inmixr_controls),
+	inmixer_event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+/* AINRMUX */
+SND_SOC_DAPM_MUX_E("AIRNMUX", WM8991_INTDRIVBITS, WM8991_AINRMUX_PWR_BIT, 0,
+	&wm8991_dapm_ainrmux_controls, inmixer_event,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+/* Output Side */
+/* DACs */
+SND_SOC_DAPM_DAC("Left DAC", "Left Playback", WM8991_POWER_MANAGEMENT_3,
+	WM8991_DACL_ENA_BIT, 0),
+SND_SOC_DAPM_DAC("Right DAC", "Right Playback", WM8991_POWER_MANAGEMENT_3,
+	WM8991_DACR_ENA_BIT, 0),
+
+/* LOMIX */
+SND_SOC_DAPM_MIXER_E("LOMIX", WM8991_POWER_MANAGEMENT_3, WM8991_LOMIX_ENA_BIT,
+	0, &wm8991_dapm_lomix_controls[0],
+	ARRAY_SIZE(wm8991_dapm_lomix_controls),
+	outmixer_event, SND_SOC_DAPM_PRE_REG),
+
+/* LONMIX */
+SND_SOC_DAPM_MIXER("LONMIX", WM8991_POWER_MANAGEMENT_3, WM8991_LON_ENA_BIT, 0,
+	&wm8991_dapm_lonmix_controls[0],
+	ARRAY_SIZE(wm8991_dapm_lonmix_controls)),
+
+/* LOPMIX */
+SND_SOC_DAPM_MIXER("LOPMIX", WM8991_POWER_MANAGEMENT_3, WM8991_LOP_ENA_BIT, 0,
+	&wm8991_dapm_lopmix_controls[0],
+	ARRAY_SIZE(wm8991_dapm_lopmix_controls)),
+
+/* OUT3MIX */
+SND_SOC_DAPM_MIXER("OUT3MIX", WM8991_POWER_MANAGEMENT_1, WM8991_OUT3_ENA_BIT, 0,
+	&wm8991_dapm_out3mix_controls[0],
+	ARRAY_SIZE(wm8991_dapm_out3mix_controls)),
+
+/* SPKMIX */
+SND_SOC_DAPM_MIXER_E("SPKMIX", WM8991_POWER_MANAGEMENT_1, WM8991_SPK_ENA_BIT, 0,
+	&wm8991_dapm_spkmix_controls[0],
+	ARRAY_SIZE(wm8991_dapm_spkmix_controls), outmixer_event,
+	SND_SOC_DAPM_PRE_REG),
+
+/* OUT4MIX */
+SND_SOC_DAPM_MIXER("OUT4MIX", WM8991_POWER_MANAGEMENT_1, WM8991_OUT4_ENA_BIT, 0,
+	&wm8991_dapm_out4mix_controls[0],
+	ARRAY_SIZE(wm8991_dapm_out4mix_controls)),
+
+/* ROPMIX */
+SND_SOC_DAPM_MIXER("ROPMIX", WM8991_POWER_MANAGEMENT_3, WM8991_ROP_ENA_BIT, 0,
+	&wm8991_dapm_ropmix_controls[0],
+	ARRAY_SIZE(wm8991_dapm_ropmix_controls)),
+
+/* RONMIX */
+SND_SOC_DAPM_MIXER("RONMIX", WM8991_POWER_MANAGEMENT_3, WM8991_RON_ENA_BIT, 0,
+	&wm8991_dapm_ronmix_controls[0],
+	ARRAY_SIZE(wm8991_dapm_ronmix_controls)),
+
+/* ROMIX */
+SND_SOC_DAPM_MIXER_E("ROMIX", WM8991_POWER_MANAGEMENT_3, WM8991_ROMIX_ENA_BIT,
+	0, &wm8991_dapm_romix_controls[0],
+	ARRAY_SIZE(wm8991_dapm_romix_controls),
+	outmixer_event, SND_SOC_DAPM_PRE_REG),
+
+/* LOUT PGA */
+SND_SOC_DAPM_PGA("LOUT PGA", WM8991_POWER_MANAGEMENT_1, WM8991_LOUT_ENA_BIT, 0,
+	NULL, 0),
+
+/* ROUT PGA */
+SND_SOC_DAPM_PGA("ROUT PGA", WM8991_POWER_MANAGEMENT_1, WM8991_ROUT_ENA_BIT, 0,
+	NULL, 0),
+
+/* LOPGA */
+SND_SOC_DAPM_PGA("LOPGA", WM8991_POWER_MANAGEMENT_3, WM8991_LOPGA_ENA_BIT, 0,
+	NULL, 0),
+
+/* ROPGA */
+SND_SOC_DAPM_PGA("ROPGA", WM8991_POWER_MANAGEMENT_3, WM8991_ROPGA_ENA_BIT, 0,
+	NULL, 0),
+
+/* MICBIAS */
+SND_SOC_DAPM_MICBIAS("MICBIAS", WM8991_POWER_MANAGEMENT_1,
+	WM8991_MICBIAS_ENA_BIT, 0),
+
+SND_SOC_DAPM_OUTPUT("LON"),
+SND_SOC_DAPM_OUTPUT("LOP"),
+SND_SOC_DAPM_OUTPUT("OUT3"),
+SND_SOC_DAPM_OUTPUT("LOUT"),
+SND_SOC_DAPM_OUTPUT("SPKN"),
+SND_SOC_DAPM_OUTPUT("SPKP"),
+SND_SOC_DAPM_OUTPUT("ROUT"),
+SND_SOC_DAPM_OUTPUT("OUT4"),
+SND_SOC_DAPM_OUTPUT("ROP"),
+SND_SOC_DAPM_OUTPUT("RON"),
+
+SND_SOC_DAPM_OUTPUT("Internal DAC Sink"),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	/* Make DACs turn on when playing even if not mixed into any outputs */
+	{"Internal DAC Sink", NULL, "Left DAC"},
+	{"Internal DAC Sink", NULL, "Right DAC"},
+
+	/* Make ADCs turn on when recording even if not mixed from any inputs */
+	{"Left ADC", NULL, "Internal ADC Source"},
+	{"Right ADC", NULL, "Internal ADC Source"},
+
+	/* Input Side */
+	/* LIN12 PGA */
+	{"LIN12 PGA", "LIN1 Switch", "LIN1"},
+	{"LIN12 PGA", "LIN2 Switch", "LIN2"},
+	/* LIN34 PGA */
+	{"LIN34 PGA", "LIN3 Switch", "LIN3"},
+	{"LIN34 PGA", "LIN4 Switch", "LIN4/RXN"},
+	/* INMIXL */
+	{"INMIXL", "Record Left Volume", "LOMIX"},
+	{"INMIXL", "LIN2 Volume", "LIN2"},
+	{"INMIXL", "LINPGA12 Switch", "LIN12 PGA"},
+	{"INMIXL", "LINPGA34 Switch", "LIN34 PGA"},
+	/* AILNMUX */
+	{"AILNMUX", "INMIXL Mix", "INMIXL"},
+	{"AILNMUX", "DIFFINL Mix", "LIN12 PGA"},
+	{"AILNMUX", "DIFFINL Mix", "LIN34 PGA"},
+	{"AILNMUX", "RXVOICE Mix", "LIN4/RXN"},
+	{"AILNMUX", "RXVOICE Mix", "RIN4/RXP"},
+	/* ADC */
+	{"Left ADC", NULL, "AILNMUX"},
+
+	/* RIN12 PGA */
+	{"RIN12 PGA", "RIN1 Switch", "RIN1"},
+	{"RIN12 PGA", "RIN2 Switch", "RIN2"},
+	/* RIN34 PGA */
+	{"RIN34 PGA", "RIN3 Switch", "RIN3"},
+	{"RIN34 PGA", "RIN4 Switch", "RIN4/RXP"},
+	/* INMIXL */
+	{"INMIXR", "Record Right Volume", "ROMIX"},
+	{"INMIXR", "RIN2 Volume", "RIN2"},
+	{"INMIXR", "RINPGA12 Switch", "RIN12 PGA"},
+	{"INMIXR", "RINPGA34 Switch", "RIN34 PGA"},
+	/* AIRNMUX */
+	{"AIRNMUX", "INMIXR Mix", "INMIXR"},
+	{"AIRNMUX", "DIFFINR Mix", "RIN12 PGA"},
+	{"AIRNMUX", "DIFFINR Mix", "RIN34 PGA"},
+	{"AIRNMUX", "RXVOICE Mix", "LIN4/RXN"},
+	{"AIRNMUX", "RXVOICE Mix", "RIN4/RXP"},
+	/* ADC */
+	{"Right ADC", NULL, "AIRNMUX"},
+
+	/* LOMIX */
+	{"LOMIX", "LOMIX RIN3 Bypass Switch", "RIN3"},
+	{"LOMIX", "LOMIX LIN3 Bypass Switch", "LIN3"},
+	{"LOMIX", "LOMIX LIN12 PGA Bypass Switch", "LIN12 PGA"},
+	{"LOMIX", "LOMIX RIN12 PGA Bypass Switch", "RIN12 PGA"},
+	{"LOMIX", "LOMIX Right ADC Bypass Switch", "AIRNMUX"},
+	{"LOMIX", "LOMIX Left ADC Bypass Switch", "AILNMUX"},
+	{"LOMIX", "LOMIX Left DAC Switch", "Left DAC"},
+
+	/* ROMIX */
+	{"ROMIX", "ROMIX RIN3 Bypass Switch", "RIN3"},
+	{"ROMIX", "ROMIX LIN3 Bypass Switch", "LIN3"},
+	{"ROMIX", "ROMIX LIN12 PGA Bypass Switch", "LIN12 PGA"},
+	{"ROMIX", "ROMIX RIN12 PGA Bypass Switch", "RIN12 PGA"},
+	{"ROMIX", "ROMIX Right ADC Bypass Switch", "AIRNMUX"},
+	{"ROMIX", "ROMIX Left ADC Bypass Switch", "AILNMUX"},
+	{"ROMIX", "ROMIX Right DAC Switch", "Right DAC"},
+
+	/* SPKMIX */
+	{"SPKMIX", "SPKMIX LIN2 Bypass Switch", "LIN2"},
+	{"SPKMIX", "SPKMIX RIN2 Bypass Switch", "RIN2"},
+	{"SPKMIX", "SPKMIX LADC Bypass Switch", "AILNMUX"},
+	{"SPKMIX", "SPKMIX RADC Bypass Switch", "AIRNMUX"},
+	{"SPKMIX", "SPKMIX Left Mixer PGA Switch", "LOPGA"},
+	{"SPKMIX", "SPKMIX Right Mixer PGA Switch", "ROPGA"},
+	{"SPKMIX", "SPKMIX Right DAC Switch", "Right DAC"},
+	{"SPKMIX", "SPKMIX Left DAC Switch", "Left DAC"},
+
+	/* LONMIX */
+	{"LONMIX", "LONMIX Left Mixer PGA Switch", "LOPGA"},
+	{"LONMIX", "LONMIX Right Mixer PGA Switch", "ROPGA"},
+	{"LONMIX", "LONMIX Inverted LOP Switch", "LOPMIX"},
+
+	/* LOPMIX */
+	{"LOPMIX", "LOPMIX Right Mic Bypass Switch", "RIN12 PGA"},
+	{"LOPMIX", "LOPMIX Left Mic Bypass Switch", "LIN12 PGA"},
+	{"LOPMIX", "LOPMIX Left Mixer PGA Switch", "LOPGA"},
+
+	/* OUT3MIX */
+	{"OUT3MIX", "OUT3MIX LIN4/RXN Bypass Switch", "LIN4/RXN"},
+	{"OUT3MIX", "OUT3MIX Left Out PGA Switch", "LOPGA"},
+
+	/* OUT4MIX */
+	{"OUT4MIX", "OUT4MIX Right Out PGA Switch", "ROPGA"},
+	{"OUT4MIX", "OUT4MIX RIN4/RXP Bypass Switch", "RIN4/RXP"},
+
+	/* RONMIX */
+	{"RONMIX", "RONMIX Right Mixer PGA Switch", "ROPGA"},
+	{"RONMIX", "RONMIX Left Mixer PGA Switch", "LOPGA"},
+	{"RONMIX", "RONMIX Inverted ROP Switch", "ROPMIX"},
+
+	/* ROPMIX */
+	{"ROPMIX", "ROPMIX Left Mic Bypass Switch", "LIN12 PGA"},
+	{"ROPMIX", "ROPMIX Right Mic Bypass Switch", "RIN12 PGA"},
+	{"ROPMIX", "ROPMIX Right Mixer PGA Switch", "ROPGA"},
+
+	/* Out Mixer PGAs */
+	{"LOPGA", NULL, "LOMIX"},
+	{"ROPGA", NULL, "ROMIX"},
+
+	{"LOUT PGA", NULL, "LOMIX"},
+	{"ROUT PGA", NULL, "ROMIX"},
+
+	/* Output Pins */
+	{"LON", NULL, "LONMIX"},
+	{"LOP", NULL, "LOPMIX"},
+	{"OUT3", NULL, "OUT3MIX"},
+	{"LOUT", NULL, "LOUT PGA"},
+	{"SPKN", NULL, "SPKMIX"},
+	{"ROUT", NULL, "ROUT PGA"},
+	{"OUT4", NULL, "OUT4MIX"},
+	{"ROP", NULL, "ROPMIX"},
+	{"RON", NULL, "RONMIX"},
+};
+
+static int wm8991_add_widgets(struct snd_soc_codec *codec)
+{
+	snd_soc_dapm_new_controls(codec, wm8991_dapm_widgets,
+				  ARRAY_SIZE(wm8991_dapm_widgets));
+
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+/* PLL divisors */
+struct _pll_div {
+	u32 div2;
+	u32 n;
+	u32 k;
+};
+
+/* The size in bits of the pll divide multiplied by 10
+ * to allow rounding later */
+#define FIXED_PLL_SIZE ((1 << 16) * 10)
+
+static void pll_factors(struct _pll_div *pll_div, unsigned int target,
+	unsigned int source)
+{
+	u64 Kpart;
+	unsigned int K, Ndiv, Nmod;
+
+
+	Ndiv = target / source;
+	if (Ndiv < 6) {
+		source >>= 1;
+		pll_div->div2 = 1;
+		Ndiv = target / source;
+	} else
+		pll_div->div2 = 0;
+
+	if ((Ndiv < 6) || (Ndiv > 12))
+		printk(KERN_WARNING
+		"WM8991 N value outwith recommended range! N = %d\n", Ndiv);
+
+	pll_div->n = Ndiv;
+	Nmod = target % source;
+	Kpart = FIXED_PLL_SIZE * (long long)Nmod;
+
+	do_div(Kpart, source);
+
+	K = Kpart & 0xFFFFFFFF;
+
+	/* Check if we need to round */
+	if ((K % 10) >= 5)
+		K += 5;
+
+	/* Move down to proper range now rounding is done */
+	K /= 10;
+
+	pll_div->k = K;
+}
+
+static int wm8991_set_dai_pll(struct snd_soc_dai *codec_dai,
+	int pll_id, unsigned int freq_in, unsigned int freq_out)
+{
+	u16 reg;
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct _pll_div pll_div;
+
+	if (freq_in && freq_out) {
+		pll_factors(&pll_div, freq_out * 4, freq_in);
+
+		/* Turn on PLL */
+		reg = wm8991_read_reg_cache(codec, WM8991_POWER_MANAGEMENT_2);
+		reg |= WM8991_PLL_ENA;
+		wm8991_write(codec, WM8991_POWER_MANAGEMENT_2, reg);
+
+		/* sysclk comes from PLL */
+		reg = wm8991_read_reg_cache(codec, WM8991_CLOCKING_2);
+		wm8991_write(codec, WM8991_CLOCKING_2, reg | WM8991_SYSCLK_SRC);
+
+		/* set up N , fractional mode and pre-divisor if neccessary */
+		wm8991_write(codec, WM8991_PLL1, pll_div.n | WM8991_SDM |
+			(pll_div.div2 ? WM8991_PRESCALE : 0));
+		wm8991_write(codec, WM8991_PLL2, (u8)(pll_div.k>>8));
+		wm8991_write(codec, WM8991_PLL3, (u8)(pll_div.k & 0xFF));
+	} else if(freq_out) {
+		/* Turn on PLL */
+		reg = wm8991_read_reg_cache(codec, WM8991_POWER_MANAGEMENT_2);
+		reg |= WM8991_PLL_ENA;
+		wm8991_write(codec, WM8991_POWER_MANAGEMENT_2, reg);
+
+		/* sysclk comes from PLL */
+		reg = wm8991_read_reg_cache(codec, WM8991_CLOCKING_2);
+		wm8991_write(codec, WM8991_CLOCKING_2, reg | WM8991_SYSCLK_SRC);
+
+		/* set up N , fractional mode and pre-divisor if neccessary */
+		wm8991_write(codec, WM8991_PLL1, freq_out >> 16 | WM8991_SDM);
+		wm8991_write(codec, WM8991_PLL2, (u8)(freq_out>>8));
+		wm8991_write(codec, WM8991_PLL3, (u8)(freq_out & 0xFF));
+	
+	} else {
+		/* Turn off PLL */
+		reg = wm8991_read_reg_cache(codec, WM8991_POWER_MANAGEMENT_2);
+		reg &= ~WM8991_PLL_ENA;
+		wm8991_write(codec, WM8991_POWER_MANAGEMENT_2, reg);
+	}
+	return 0;
+}
+
+/*
+ * Clock after PLL and dividers
+ */
+static int wm8991_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct wm8991_priv *wm8991 = codec->private_data;
+
+	wm8991->sysclk = freq;
+	return 0;
+}
+
+/*
+ * Set's ADC and Voice DAC format.
+ */
+static int wm8991_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u16 audio1, audio3;
+
+	audio1 = wm8991_read_reg_cache(codec, WM8991_AUDIO_INTERFACE_1);
+	audio3 = wm8991_read_reg_cache(codec, WM8991_AUDIO_INTERFACE_3);
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		audio3 &= ~WM8991_AIF_MSTR1;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		audio3 |= WM8991_AIF_MSTR1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	audio1 &= ~WM8991_AIF_FMT_MASK;
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		audio1 |= WM8991_AIF_TMF_I2S;
+		audio1 &= ~WM8991_AIF_LRCLK_INV;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		audio1 |= WM8991_AIF_TMF_RIGHTJ;
+		audio1 &= ~WM8991_AIF_LRCLK_INV;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		audio1 |= WM8991_AIF_TMF_LEFTJ;
+		audio1 &= ~WM8991_AIF_LRCLK_INV;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		audio1 |= WM8991_AIF_TMF_DSP;
+		audio1 &= ~WM8991_AIF_LRCLK_INV;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		audio1 |= WM8991_AIF_TMF_DSP | WM8991_AIF_LRCLK_INV;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	wm8991_write(codec, WM8991_AUDIO_INTERFACE_1, audio1);
+	wm8991_write(codec, WM8991_AUDIO_INTERFACE_3, audio3);
+	return 0;
+}
+
+static int wm8991_set_dai_clkdiv(struct snd_soc_dai *codec_dai,
+		int div_id, int div)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u16 reg;
+
+	switch (div_id) {
+	case WM8991_MCLK_DIV:
+		reg = wm8991_read_reg_cache(codec, WM8991_CLOCKING_2) &
+			~WM8991_MCLK_DIV_MASK;
+		wm8991_write(codec, WM8991_CLOCKING_2, reg | div);
+		break;
+	case WM8991_DACCLK_DIV:
+		reg = wm8991_read_reg_cache(codec, WM8991_CLOCKING_2) &
+			~WM8991_DAC_CLKDIV_MASK;
+		wm8991_write(codec, WM8991_CLOCKING_2, reg | div);
+		break;
+	case WM8991_ADCCLK_DIV:
+		reg = wm8991_read_reg_cache(codec, WM8991_CLOCKING_2) &
+			~WM8991_ADC_CLKDIV_MASK;
+		wm8991_write(codec, WM8991_CLOCKING_2, reg | div);
+		break;
+	case WM8991_BCLK_DIV:
+		reg = wm8991_read_reg_cache(codec, WM8991_CLOCKING_1) &
+			~WM8991_BCLK_DIV_MASK;
+		wm8991_write(codec, WM8991_CLOCKING_1, reg | div);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Set PCM DAI bit size and sample rate.
+ */
+static int wm8991_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->card->codec;
+	u16 audio1 = wm8991_read_reg_cache(codec, WM8991_AUDIO_INTERFACE_1);
+
+	audio1 &= ~WM8991_AIF_WL_MASK;
+	/* bit size */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		audio1 |= WM8991_AIF_WL_20BITS;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		audio1 |= WM8991_AIF_WL_24BITS;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		audio1 |= WM8991_AIF_WL_32BITS;
+		break;
+	}
+
+	wm8991_write(codec, WM8991_AUDIO_INTERFACE_1, audio1);
+	return 0;
+}
+
+static int wm8991_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u16 val;
+
+	val  = snd_soc_read(codec, WM8991_DAC_CTRL) & ~WM8991_DAC_MUTE;
+
+	if (mute)
+		snd_soc_write(codec, WM8991_DAC_CTRL, val | WM8991_DAC_MUTE);
+	else
+		snd_soc_write(codec, WM8991_DAC_CTRL, val);
+
+	return 0;
+}
+
+static int wm8991_set_bias_level(struct snd_soc_codec *codec,
+	enum snd_soc_bias_level level)
+{
+	u16 val;
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		/* VMID=2*50k */
+		val = snd_soc_read(codec, WM8991_POWER_MANAGEMENT_1) &
+			~WM8991_VMID_MODE_MASK;
+		snd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, val | 0x2);
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		if (codec->bias_level == SND_SOC_BIAS_OFF) {
+			/* Enable all output discharge bits */
+			snd_soc_write(codec, WM8991_ANTIPOP1, WM8991_DIS_LLINE |
+				WM8991_DIS_RLINE | WM8991_DIS_OUT3 |
+				WM8991_DIS_OUT4 | WM8991_DIS_LOUT |
+				WM8991_DIS_ROUT);
+
+			/* Enable POBCTRL, SOFT_ST, VMIDTOG and BUFDCOPEN */
+			snd_soc_write(codec, WM8991_ANTIPOP2, WM8991_SOFTST |
+				     WM8991_BUFDCOPEN | WM8991_POBCTRL |
+				     WM8991_VMIDTOG);
+
+			/* Delay to allow output caps to discharge */
+			msleep(msecs_to_jiffies(300));
+
+			/* Disable VMIDTOG */
+			snd_soc_write(codec, WM8991_ANTIPOP2, WM8991_SOFTST |
+				     WM8991_BUFDCOPEN | WM8991_POBCTRL);
+
+			/* disable all output discharge bits */
+			snd_soc_write(codec, WM8991_ANTIPOP1, 0);
+
+			/* Enable outputs */
+			snd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x1b00);
+
+			msleep(msecs_to_jiffies(50));
+
+			/* Enable VMID at 2x50k */
+			snd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x1f02);
+
+			msleep(msecs_to_jiffies(100));
+
+			/* Enable VREF */
+			snd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x1f03);
+
+			msleep(msecs_to_jiffies(600));
+
+			/* Enable BUFIOEN */
+			snd_soc_write(codec, WM8991_ANTIPOP2, WM8991_SOFTST |
+				     WM8991_BUFDCOPEN | WM8991_POBCTRL |
+				     WM8991_BUFIOEN);
+
+			/* Disable outputs */
+			snd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x3);
+
+			/* disable POBCTRL, SOFT_ST and BUFDCOPEN */
+			snd_soc_write(codec, WM8991_ANTIPOP2, WM8991_BUFIOEN);
+
+		}
+
+		/* VMID=2*250k */
+		val = snd_soc_read(codec, WM8991_POWER_MANAGEMENT_1) &
+			~WM8991_VMID_MODE_MASK;
+		snd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, val | 0x4);
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		/* Enable POBCTRL and SOFT_ST */
+		snd_soc_write(codec, WM8991_ANTIPOP2, WM8991_SOFTST |
+			WM8991_POBCTRL | WM8991_BUFIOEN);
+
+		/* Enable POBCTRL, SOFT_ST and BUFDCOPEN */
+		snd_soc_write(codec, WM8991_ANTIPOP2, WM8991_SOFTST |
+			WM8991_BUFDCOPEN | WM8991_POBCTRL |
+			WM8991_BUFIOEN);
+
+		/* mute DAC */
+		val = snd_soc_read(codec, WM8991_DAC_CTRL);
+		snd_soc_write(codec, WM8991_DAC_CTRL, val | WM8991_DAC_MUTE);
+
+		/* Enable any disabled outputs */
+		snd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x1f03);
+
+		/* Disable VMID */
+		snd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x1f01);
+
+		msleep(msecs_to_jiffies(300));
+
+		/* Enable all output discharge bits */
+		snd_soc_write(codec, WM8991_ANTIPOP1, WM8991_DIS_LLINE |
+			WM8991_DIS_RLINE | WM8991_DIS_OUT3 |
+			WM8991_DIS_OUT4 | WM8991_DIS_LOUT |
+			WM8991_DIS_ROUT);
+
+		/* Disable VREF */
+		snd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x0);
+
+		/* disable POBCTRL, SOFT_ST and BUFDCOPEN */
+		snd_soc_write(codec, WM8991_ANTIPOP2, 0x0);
+		break;
+	}
+
+	codec->bias_level = level;
+	return 0;
+}
+
+#define WM8991_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+	SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+#define WM8991_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_ops wm8991_ops = {
+	.hw_params = wm8991_hw_params,
+	.digital_mute = wm8991_mute,
+	.set_fmt = wm8991_set_dai_fmt,
+	.set_clkdiv = wm8991_set_dai_clkdiv,
+	.set_pll = wm8991_set_dai_pll,
+	.set_sysclk = wm8991_set_dai_sysclk,
+};
+
+/*
+ * The WM8991 supports 2 different and mutually exclusive DAI
+ * configurations.
+ *
+ * 1. ADC/DAC on Primary Interface
+ * 2. ADC on Primary Interface/DAC on secondary
+ */
+struct snd_soc_dai wm8991_dai = {
+/* ADC/DAC on primary */
+	.name = "WM8991 ADC/DAC Primary",
+	.id = 1,
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = WM8991_RATES,
+		.formats = WM8991_FORMATS,},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = WM8991_RATES,
+		.formats = WM8991_FORMATS,},
+	.ops = &wm8991_ops,
+};
+EXPORT_SYMBOL_GPL(wm8991_dai);
+
+static struct snd_soc_codec *wm8991_codec;
+
+static int wm8991_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->card->codec;
+
+	/* we only need to suspend if we are a valid card */
+	if (!codec->card)
+		return 0;
+
+	wm8991_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	
+	return 0;
+}
+
+static int wm8991_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->card->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+	/* we only need to resume if we are a valid card */
+	if (!codec->card)
+		return 0;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(wm8991_reg); i++) {
+		if (i + 1 == WM8991_RESET)
+			continue;
+		data[0] = ((i + 1) << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+
+	wm8991_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	return 0;
+}
+
+static int wm8991_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	if (wm8991_codec == NULL) {
+		dev_err(&pdev->dev, "Codec device not registered\n");
+		return -ENODEV;
+	}
+
+	socdev->card->codec = wm8991_codec;
+	codec = wm8991_codec;
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		dev_err(codec->dev, "failed to create pcms: %d\n", ret);
+		goto pcm_err;
+	}
+
+	snd_soc_add_controls(codec, wm8991_snd_controls,
+			     ARRAY_SIZE(wm8991_snd_controls));
+	wm8991_add_widgets(codec);
+
+	ret = snd_soc_init_card(socdev);
+	if (ret < 0) {
+		printk(KERN_ERR "wm8991: failed to register card\n");
+		goto pcm_err;	
+	}
+
+	return 0;
+
+pcm_err:
+	return ret;
+}
+
+/* power down chip */
+static int wm8991_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8991 = {
+	.probe = 	wm8991_probe,
+	.remove = 	wm8991_remove,
+	.suspend = 	wm8991_suspend,
+	.resume =	wm8991_resume,
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8991);
+
+static ssize_t wm8991_switch_print_state(struct switch_dev *sdev, char *buf)
+{
+	if(headphone_plugged_in)
+		return sprintf(buf, "1\n");
+	else
+		return sprintf(buf, "0\n");
+}
+
+static void wm8991_switch_work(struct work_struct *work)
+{
+	struct wm8991_priv* wm8991 = container_of(work, struct wm8991_priv, switch_work);
+	struct snd_soc_codec *codec = &wm8991->codec;
+	uint16_t status;
+	uint16_t polarity;
+
+	if(!gpio_get_value(WM8991_INT_GPIO))
+		return;
+
+	status = wm8991_read(codec, WM8991_GPIO_CTRL_1);
+	polarity = wm8991_read(codec, WM8991_GPIO_POL);
+
+	if(status & (1 << 4))
+	{
+		if(polarity & (1 << 4))
+		{
+			polarity = polarity & ~(1 << 4);
+			headphone_plugged_in = 0;
+		} else
+		{
+			polarity = polarity | (1 << 4);
+			headphone_plugged_in = 1;
+		}
+
+		switch_set_state(&wm8991->sdev, headphone_plugged_in);
+
+		wm8991_write(codec, WM8991_GPIO_POL, polarity);
+	}
+
+	wm8991_write(codec, WM8991_GPIO_CTRL_1, status);
+}
+
+static irqreturn_t wm8991_irq(int irq, void* pToken)
+{
+	struct wm8991_priv* wm8991 = (struct wm8991_priv*) pToken;
+	schedule_work(&wm8991->switch_work);
+	return IRQ_HANDLED;
+}
+
+static int wm8991_register(struct wm8991_priv *wm8991)
+{
+	int ret;
+	struct snd_soc_codec *codec = &wm8991->codec;
+	u16 reg;
+
+	if (wm8991_codec) {
+		dev_err(codec->dev, "Another WM8991 is registered\n");
+		return -EINVAL;
+	}
+
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	codec->private_data = wm8991;
+	codec->name = "WM8991";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8991_read_reg_cache;
+	codec->write = wm8991_write;
+	codec->bias_level = SND_SOC_BIAS_OFF;
+	codec->set_bias_level = wm8991_set_bias_level;
+	codec->dai = &wm8991_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = WM8991_MAX_REGISTER + 1;
+	codec->reg_cache = &wm8991->reg_cache;
+
+	memcpy(codec->reg_cache, wm8991_reg, sizeof(wm8991_reg));
+
+	ret = wm8991_reset(codec);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to issue reset\n");
+		return ret;
+	}
+
+	wm8991_dai.dev = codec->dev;
+
+	wm8991_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	reg = wm8991_read_reg_cache(codec, WM8991_AUDIO_INTERFACE_4);
+	wm8991_write(codec, WM8991_AUDIO_INTERFACE_4, reg | WM8991_ALRCGPIO1);
+
+	reg = wm8991_read_reg_cache(codec, WM8991_GPIO1_GPIO2) &
+		~WM8991_GPIO1_SEL_MASK;
+	wm8991_write(codec, WM8991_GPIO1_GPIO2, reg | 1);
+
+	reg = wm8991_read_reg_cache(codec, WM8991_POWER_MANAGEMENT_1);
+	wm8991_write(codec, WM8991_POWER_MANAGEMENT_1, reg | WM8991_VREF_ENA |
+	    ((1 << 1) & WM8991_VMID_MODE_MASK));
+
+	wm8991_write(codec, WM8991_ANTIPOP2, WM8991_BUFIOEN);
+
+	wm8991_write(codec, WM8991_DAC_CTRL, 0);
+	wm8991_write(codec, WM8991_LEFT_OUTPUT_VOLUME, 0x50 | (1<<8));
+	wm8991_write(codec, WM8991_RIGHT_OUTPUT_VOLUME, 0x50 | (1<<8));
+
+	wm8991_write(codec, WM8991_GPIO1_GPIO2, WM8991_GPIO2_PD | 0x700);	// GPIO2 pulldown, GPIO2 is IRQ
+	wm8991_write(codec, WM8991_GPIO3_GPIO4, WM8991_GPIO4_PD);
+	wm8991_write(codec, WM8991_GPIO5_GPIO6, WM8991_GPIO6_PD | WM8991_GPIO5_IRQ_ENA);
+	wm8991_write(codec, WM8991_GPIO_POL, WM8991_TEMPOK_POL | WM8991_GPIO3_POL);
+
+	wm8991_codec = codec;
+
+	ret = snd_soc_register_codec(codec);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to register codec: %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_register_dai(&wm8991_dai);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to register DAI: %d\n", ret);
+		snd_soc_unregister_codec(codec);
+		return ret;
+	}
+
+	INIT_WORK(&wm8991->switch_work, wm8991_switch_work);
+
+	iphone_gpio_pin_reset(WM8991_INT_GPIO);
+	request_irq(gpio_to_irq(WM8991_INT_GPIO), wm8991_irq, IRQF_TRIGGER_RISING, "wm8991", wm8991);
+
+	wm8991->sdev.name = "h2w";
+	wm8991->sdev.print_state = wm8991_switch_print_state;
+
+	ret = switch_dev_register(&wm8991->sdev);
+	if (ret < 0)
+	{
+		dev_err(codec->dev, "Failed to register headphone detection switch: %d\n", ret);
+		snd_soc_unregister_dai(&wm8991_dai);
+		snd_soc_unregister_codec(codec);
+	}
+
+	debugfs_entry = debugfs_create_dir("wm8991", NULL);
+	debugfs_blob.data = &wm8991->reg_cache;
+	debugfs_blob.size = (WM8991_MAX_REGISTER + 1) * sizeof(u16);
+	debugfs_create_blob("registers", S_IRUSR, debugfs_entry, &debugfs_blob);
+	debugfs_create_bool("headphone", S_IRUSR, debugfs_entry, &headphone_plugged_in);
+
+	return 0;
+}
+
+static void wm8991_unregister(struct wm8991_priv *wm8991)
+{
+	debugfs_remove_recursive(debugfs_entry);
+	switch_dev_unregister(&wm8991->sdev);
+	free_irq(gpio_to_irq(WM8991_INT_GPIO), wm8991->codec.dev);
+	wm8991_set_bias_level(&wm8991->codec, SND_SOC_BIAS_OFF);
+	snd_soc_unregister_dai(&wm8991_dai);
+	snd_soc_unregister_codec(&wm8991->codec);
+	kfree(wm8991);
+	wm8991_codec = NULL;
+}
+
+static __devinit int wm8991_i2c_probe(struct i2c_client *i2c,
+				      const struct i2c_device_id *id)
+{
+	struct wm8991_priv *wm8991;
+	struct snd_soc_codec *codec;
+
+	wm8991 = kzalloc(sizeof(struct wm8991_priv), GFP_KERNEL);
+	if (wm8991 == NULL)
+		return -ENOMEM;
+
+	codec = &wm8991->codec;
+	codec->hw_write = (hw_write_t)i2c_master_send;
+
+	i2c_set_clientdata(i2c, wm8991);
+	codec->control_data = i2c;
+
+	codec->dev = &i2c->dev;
+
+	return wm8991_register(wm8991);
+}
+
+static __devexit int wm8991_i2c_remove(struct i2c_client *client)
+{
+	struct wm8991_priv *wm8991 = i2c_get_clientdata(client);
+	wm8991_unregister(wm8991);
+	return 0;
+}
+
+static const struct i2c_device_id wm8991_i2c_id[] = {
+	{ "wm8991", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, wm8991_i2c_id);
+
+static struct i2c_driver wm8991_i2c_driver = {
+	.driver = {
+		.name = "WM8991 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.probe =    wm8991_i2c_probe,
+	.remove =   __devexit_p(wm8991_i2c_remove),
+	.id_table = wm8991_i2c_id,
+};
+
+static int __init wm8991_modinit(void)
+{
+	int ret;
+	ret = i2c_add_driver(&wm8991_i2c_driver);
+	if (ret != 0) {
+		printk(KERN_ERR "Failed to register WM8991 I2C driver: %d\n",
+		       ret);
+	}
+	return 0;
+}
+module_init(wm8991_modinit);
+
+static void __exit wm8991_exit(void)
+{
+	i2c_del_driver(&wm8991_i2c_driver);
+}
+module_exit(wm8991_exit);
+
+MODULE_DESCRIPTION("ASoC WM8991 driver");
+MODULE_AUTHOR("Graeme Gregory");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/sound/soc/codecs/wm8991.h iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8991.h
--- linux-2.6.32-orig/sound/soc/codecs/wm8991.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm8991.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,842 @@
+/*
+ * wm8991.h  --  audio driver for WM8991
+ *
+ * Copyright 2007 Wolfson Microelectronics PLC.
+ * Author: Graeme Gregory
+ *         graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#ifndef __WM8991REGISTERDEFS_H__
+#define __WM8991REGISTERDEFS_H__
+
+/*
+ * Register values.
+ */
+#define WM8991_RESET                            0x00
+#define WM8991_POWER_MANAGEMENT_1               0x01
+#define WM8991_POWER_MANAGEMENT_2               0x02
+#define WM8991_POWER_MANAGEMENT_3               0x03
+#define WM8991_AUDIO_INTERFACE_1                0x04
+#define WM8991_AUDIO_INTERFACE_2                0x05
+#define WM8991_CLOCKING_1                       0x06
+#define WM8991_CLOCKING_2                       0x07
+#define WM8991_AUDIO_INTERFACE_3                0x08
+#define WM8991_AUDIO_INTERFACE_4                0x09
+#define WM8991_DAC_CTRL                         0x0A
+#define WM8991_LEFT_DAC_DIGITAL_VOLUME          0x0B
+#define WM8991_RIGHT_DAC_DIGITAL_VOLUME         0x0C
+#define WM8991_DIGITAL_SIDE_TONE                0x0D
+#define WM8991_ADC_CTRL                         0x0E
+#define WM8991_LEFT_ADC_DIGITAL_VOLUME          0x0F
+#define WM8991_RIGHT_ADC_DIGITAL_VOLUME         0x10
+#define WM8991_GPIO_CTRL_1                      0x12
+#define WM8991_GPIO1_GPIO2                      0x13
+#define WM8991_GPIO3_GPIO4                      0x14
+#define WM8991_GPIO5_GPIO6                      0x15
+#define WM8991_GPIOCTRL_2                       0x16
+#define WM8991_GPIO_POL                         0x17
+#define WM8991_LEFT_LINE_INPUT_1_2_VOLUME       0x18
+#define WM8991_LEFT_LINE_INPUT_3_4_VOLUME       0x19
+#define WM8991_RIGHT_LINE_INPUT_1_2_VOLUME      0x1A
+#define WM8991_RIGHT_LINE_INPUT_3_4_VOLUME      0x1B
+#define WM8991_LEFT_OUTPUT_VOLUME               0x1C
+#define WM8991_RIGHT_OUTPUT_VOLUME              0x1D
+#define WM8991_LINE_OUTPUTS_VOLUME              0x1E
+#define WM8991_OUT3_4_VOLUME                    0x1F
+#define WM8991_LEFT_OPGA_VOLUME                 0x20
+#define WM8991_RIGHT_OPGA_VOLUME                0x21
+#define WM8991_SPEAKER_VOLUME                   0x22
+#define WM8991_CLASSD1                          0x23
+#define WM8991_CLASSD2							0x24
+#define WM8991_CLASSD3                          0x25
+#define WM8991_CLASSD4                          0x26
+#define WM8991_INPUT_MIXER1                     0x27
+#define WM8991_INPUT_MIXER2                     0x28
+#define WM8991_INPUT_MIXER3                     0x29
+#define WM8991_INPUT_MIXER4                     0x2A
+#define WM8991_INPUT_MIXER5                     0x2B
+#define WM8991_INPUT_MIXER6                     0x2C
+#define WM8991_OUTPUT_MIXER1                    0x2D
+#define WM8991_OUTPUT_MIXER2                    0x2E
+#define WM8991_OUTPUT_MIXER3                    0x2F
+#define WM8991_OUTPUT_MIXER4                    0x30
+#define WM8991_OUTPUT_MIXER5                    0x31
+#define WM8991_OUTPUT_MIXER6                    0x32
+#define WM8991_OUT3_4_MIXER                     0x33
+#define WM8991_LINE_MIXER1                      0x34
+#define WM8991_LINE_MIXER2                      0x35
+#define WM8991_SPEAKER_MIXER                    0x36
+#define WM8991_ADDITIONAL_CONTROL               0x37
+#define WM8991_ANTIPOP1                         0x38
+#define WM8991_ANTIPOP2                         0x39
+#define WM8991_MICBIAS                          0x3A
+#define WM8991_PLL1                             0x3C
+#define WM8991_PLL2                             0x3D
+#define WM8991_PLL3                             0x3E
+#define WM8991_INTDRIVBITS			0x3F
+
+#define WM8991_REGISTER_COUNT                   60
+#define WM8991_MAX_REGISTER                     0x3F
+
+/*
+ * Field Definitions.
+ */
+
+/*
+ * R0 (0x00) - Reset
+ */
+#define WM8991_SW_RESET_CHIP_ID_MASK            0xFFFF  /* SW_RESET_CHIP_ID - [15:0] */
+
+/*
+ * R1 (0x01) - Power Management (1)
+ */
+#define WM8991_SPK_ENA                          0x1000  /* SPK_ENA */
+#define WM8991_SPK_ENA_BIT			12
+#define WM8991_OUT3_ENA                         0x0800  /* OUT3_ENA */
+#define WM8991_OUT3_ENA_BIT			11
+#define WM8991_OUT4_ENA                         0x0400  /* OUT4_ENA */
+#define WM8991_OUT4_ENA_BIT			10
+#define WM8991_LOUT_ENA                         0x0200  /* LOUT_ENA */
+#define WM8991_LOUT_ENA_BIT			9
+#define WM8991_ROUT_ENA                         0x0100  /* ROUT_ENA */
+#define WM8991_ROUT_ENA_BIT			8
+#define WM8991_MIC_ENA				0x0020  /* MICBIAS_ENA */
+#define WM8991_MIC_ENA_BIT			5
+#define WM8991_MICBIAS_ENA                      0x0010  /* MICBIAS_ENA */
+#define WM8991_MICBIAS_ENA_BIT			4
+#define WM8991_VMID_MODE_MASK                   0x0006  /* VMID_MODE - [2:1] */
+#define WM8991_VREF_ENA                         0x0001  /* VREF_ENA */
+#define WM8991_VREF_ENA_BIT			0
+
+/*
+ * R2 (0x02) - Power Management (2)
+ */
+#define WM8991_PLL_ENA                          0x8000  /* PLL_ENA */
+#define WM8991_PLL_ENA_BIT			15
+#define WM8991_TSHUT_ENA                        0x4000  /* TSHUT_ENA */
+#define WM8991_TSHUT_ENA_BIT			14
+#define WM8991_TSHUT_OPDIS                      0x2000  /* TSHUT_OPDIS */
+#define WM8991_TSHUT_OPDIS_BIT			13
+#define WM8991_OPCLK_ENA                        0x0800  /* OPCLK_ENA */
+#define WM8991_OPCLK_ENA_BIT			11
+#define WM8991_AINL_ENA                         0x0200  /* AINL_ENA */
+#define WM8991_AINL_ENA_BIT			9
+#define WM8991_AINR_ENA                         0x0100  /* AINR_ENA */
+#define WM8991_AINR_ENA_BIT			8
+#define WM8991_LIN34_ENA                        0x0080  /* LIN34_ENA */
+#define WM8991_LIN34_ENA_BIT			7
+#define WM8991_LIN12_ENA                        0x0040  /* LIN12_ENA */
+#define WM8991_LIN12_ENA_BIT			6
+#define WM8991_RIN34_ENA                        0x0020  /* RIN34_ENA */
+#define WM8991_RIN34_ENA_BIT			5
+#define WM8991_RIN12_ENA                        0x0010  /* RIN12_ENA */
+#define WM8991_RIN12_ENA_BIT			4
+#define WM8991_ADCL_ENA                         0x0002  /* ADCL_ENA */
+#define WM8991_ADCL_ENA_BIT			1
+#define WM8991_ADCR_ENA                         0x0001  /* ADCR_ENA */
+#define WM8991_ADCR_ENA_BIT			0
+
+/*
+ * R3 (0x03) - Power Management (3)
+ */
+#define WM8991_LON_ENA                          0x2000  /* LON_ENA */
+#define WM8991_LON_ENA_BIT			13
+#define WM8991_LOP_ENA                          0x1000  /* LOP_ENA */
+#define WM8991_LOP_ENA_BIT			12
+#define WM8991_RON_ENA                          0x0800  /* RON_ENA */
+#define WM8991_RON_ENA_BIT			11
+#define WM8991_ROP_ENA                          0x0400  /* ROP_ENA */
+#define WM8991_ROP_ENA_BIT			10
+#define WM8991_LOPGA_ENA                        0x0080  /* LOPGA_ENA */
+#define WM8991_LOPGA_ENA_BIT			7
+#define WM8991_ROPGA_ENA                        0x0040  /* ROPGA_ENA */
+#define WM8991_ROPGA_ENA_BIT			6
+#define WM8991_LOMIX_ENA                        0x0020  /* LOMIX_ENA */
+#define WM8991_LOMIX_ENA_BIT			5
+#define WM8991_ROMIX_ENA                        0x0010  /* ROMIX_ENA */
+#define WM8991_ROMIX_ENA_BIT			4
+#define WM8991_DACL_ENA                         0x0002  /* DACL_ENA */
+#define WM8991_DACL_ENA_BIT			1
+#define WM8991_DACR_ENA                         0x0001  /* DACR_ENA */
+#define WM8991_DACR_ENA_BIT			0
+
+/*
+ * R4 (0x04) - Audio Interface (1)
+ */
+#define WM8991_AIFADCL_SRC                      0x8000  /* AIFADCL_SRC */
+#define WM8991_AIFADCR_SRC                      0x4000  /* AIFADCR_SRC */
+#define WM8991_AIFADC_TDM                       0x2000  /* AIFADC_TDM */
+#define WM8991_AIFADC_TDM_CHAN                  0x1000  /* AIFADC_TDM_CHAN */
+#define WM8991_AIF_BCLK_INV                     0x0100  /* AIF_BCLK_INV */
+#define WM8991_AIF_LRCLK_INV                    0x0080  /* AIF_LRCLK_INV */
+#define WM8991_AIF_WL_MASK                      0x0060  /* AIF_WL - [6:5] */
+#define WM8991_AIF_WL_16BITS			(0 << 5)
+#define WM8991_AIF_WL_20BITS			(1 << 5)
+#define WM8991_AIF_WL_24BITS			(2 << 5)
+#define WM8991_AIF_WL_32BITS			(3 << 5)
+#define WM8991_AIF_FMT_MASK                     0x0018  /* AIF_FMT - [4:3] */
+#define WM8991_AIF_TMF_RIGHTJ			(0 << 3)
+#define WM8991_AIF_TMF_LEFTJ			(1 << 3)
+#define WM8991_AIF_TMF_I2S			(2 << 3)
+#define WM8991_AIF_TMF_DSP			(3 << 3)
+
+/*
+ * R5 (0x05) - Audio Interface (2)
+ */
+#define WM8991_DACL_SRC                         0x8000  /* DACL_SRC */
+#define WM8991_DACR_SRC                         0x4000  /* DACR_SRC */
+#define WM8991_AIFDAC_TDM                       0x2000  /* AIFDAC_TDM */
+#define WM8991_AIFDAC_TDM_CHAN                  0x1000  /* AIFDAC_TDM_CHAN */
+#define WM8991_DAC_BOOST_MASK                   0x0C00  /* DAC_BOOST - [11:10] */
+#define WM8991_DAC_COMP                         0x0010  /* DAC_COMP */
+#define WM8991_DAC_COMPMODE                     0x0008  /* DAC_COMPMODE */
+#define WM8991_ADC_COMP                         0x0004  /* ADC_COMP */
+#define WM8991_ADC_COMPMODE                     0x0002  /* ADC_COMPMODE */
+#define WM8991_LOOPBACK                         0x0001  /* LOOPBACK */
+
+/*
+ * R6 (0x06) - Clocking (1)
+ */
+#define WM8991_TOCLK_RATE                       0x8000  /* TOCLK_RATE */
+#define WM8991_TOCLK_ENA                        0x4000  /* TOCLK_ENA */
+#define WM8991_OPCLKDIV_MASK                    0x1E00  /* OPCLKDIV - [12:9] */
+#define WM8991_DCLKDIV_MASK                     0x01C0  /* DCLKDIV - [8:6] */
+#define WM8991_BCLK_DIV_MASK                    0x001E  /* BCLK_DIV - [4:1] */
+#define WM8991_BCLK_DIV_1			(0x0 << 1)
+#define WM8991_BCLK_DIV_1_5			(0x1 << 1)
+#define WM8991_BCLK_DIV_2			(0x2 << 1)
+#define WM8991_BCLK_DIV_3			(0x3 << 1)
+#define WM8991_BCLK_DIV_4			(0x4 << 1)
+#define WM8991_BCLK_DIV_5_5			(0x5 << 1)
+#define WM8991_BCLK_DIV_6			(0x6 << 1)
+#define WM8991_BCLK_DIV_8			(0x7 << 1)
+#define WM8991_BCLK_DIV_11			(0x8 << 1)
+#define WM8991_BCLK_DIV_12			(0x9 << 1)
+#define WM8991_BCLK_DIV_16			(0xA << 1)
+#define WM8991_BCLK_DIV_22			(0xB << 1)
+#define WM8991_BCLK_DIV_24			(0xC << 1)
+#define WM8991_BCLK_DIV_32			(0xD << 1)
+#define WM8991_BCLK_DIV_44			(0xE << 1)
+#define WM8991_BCLK_DIV_48			(0xF << 1)
+
+/*
+ * R7 (0x07) - Clocking (2)
+ */
+#define WM8991_MCLK_SRC                         0x8000  /* MCLK_SRC */
+#define WM8991_SYSCLK_SRC                       0x4000  /* SYSCLK_SRC */
+#define WM8991_CLK_FORCE                        0x2000  /* CLK_FORCE */
+#define WM8991_MCLK_DIV_MASK                    0x1800  /* MCLK_DIV - [12:11] */
+#define WM8991_MCLK_DIV_1			(0 << 11)
+#define WM8991_MCLK_DIV_2			( 2 << 11)
+#define WM8991_MCLK_INV                         0x0400  /* MCLK_INV */
+#define WM8991_ADC_CLKDIV_MASK                  0x00E0  /* ADC_CLKDIV - [7:5] */
+#define WM8991_ADC_CLKDIV_1			(0 << 5)
+#define WM8991_ADC_CLKDIV_1_5			(1 << 5)
+#define WM8991_ADC_CLKDIV_2			(2 << 5)
+#define WM8991_ADC_CLKDIV_3			(3 << 5)
+#define WM8991_ADC_CLKDIV_4			(4 << 5)
+#define WM8991_ADC_CLKDIV_5_5			(5 << 5)
+#define WM8991_ADC_CLKDIV_6			(6 << 5)
+#define WM8991_DAC_CLKDIV_MASK                  0x001C  /* DAC_CLKDIV - [4:2] */
+#define WM8991_DAC_CLKDIV_1			(0 << 2)
+#define WM8991_DAC_CLKDIV_1_5			(1 << 2)
+#define WM8991_DAC_CLKDIV_2			(2 << 2)
+#define WM8991_DAC_CLKDIV_3			(3 << 2)
+#define WM8991_DAC_CLKDIV_4			(4 << 2)
+#define WM8991_DAC_CLKDIV_5_5			(5 << 2)
+#define WM8991_DAC_CLKDIV_6			(6 << 2)
+
+/*
+ * R8 (0x08) - Audio Interface (3)
+ */
+#define WM8991_AIF_MSTR1                        0x8000  /* AIF_MSTR1 */
+#define WM8991_AIF_MSTR2                        0x4000  /* AIF_MSTR2 */
+#define WM8991_AIF_SEL                          0x2000  /* AIF_SEL */
+#define WM8991_ADCLRC_DIR                       0x0800  /* ADCLRC_DIR */
+#define WM8991_ADCLRC_RATE_MASK                 0x07FF  /* ADCLRC_RATE - [10:0] */
+
+/*
+ * R9 (0x09) - Audio Interface (4)
+ */
+#define WM8991_ALRCGPIO1                        0x8000  /* ALRCGPIO1 */
+#define WM8991_ALRCBGPIO6                       0x4000  /* ALRCBGPIO6 */
+#define WM8991_AIF_TRIS                         0x2000  /* AIF_TRIS */
+#define WM8991_DACLRC_DIR                       0x0800  /* DACLRC_DIR */
+#define WM8991_DACLRC_RATE_MASK                 0x07FF  /* DACLRC_RATE - [10:0] */
+
+/*
+ * R10 (0x0A) - DAC CTRL
+ */
+#define WM8991_AIF_LRCLKRATE                    0x0400  /* AIF_LRCLKRATE */
+#define WM8991_DAC_MONO                         0x0200  /* DAC_MONO */
+#define WM8991_DAC_SB_FILT                      0x0100  /* DAC_SB_FILT */
+#define WM8991_DAC_MUTERATE                     0x0080  /* DAC_MUTERATE */
+#define WM8991_DAC_MUTEMODE                     0x0040  /* DAC_MUTEMODE */
+#define WM8991_DEEMP_MASK                       0x0030  /* DEEMP - [5:4] */
+#define WM8991_DAC_MUTE                         0x0004  /* DAC_MUTE */
+#define WM8991_DACL_DATINV                      0x0002  /* DACL_DATINV */
+#define WM8991_DACR_DATINV                      0x0001  /* DACR_DATINV */
+
+/*
+ * R11 (0x0B) - Left DAC Digital Volume
+ */
+#define WM8991_DAC_VU                           0x0100  /* DAC_VU */
+#define WM8991_DACL_VOL_MASK                    0x00FF  /* DACL_VOL - [7:0] */
+#define WM8991_DACL_VOL_SHIFT			0
+/*
+ * R12 (0x0C) - Right DAC Digital Volume
+ */
+#define WM8991_DAC_VU                           0x0100  /* DAC_VU */
+#define WM8991_DACR_VOL_MASK                    0x00FF  /* DACR_VOL - [7:0] */
+#define WM8991_DACR_VOL_SHIFT			0
+/*
+ * R13 (0x0D) - Digital Side Tone
+ */
+#define WM8991_ADCL_DAC_SVOL_MASK               0x0F  /* ADCL_DAC_SVOL - [12:9] */
+#define WM8991_ADCL_DAC_SVOL_SHIFT		9
+#define WM8991_ADCR_DAC_SVOL_MASK               0x0F  /* ADCR_DAC_SVOL - [8:5] */
+#define WM8991_ADCR_DAC_SVOL_SHIFT		5
+#define WM8991_ADC_TO_DACL_MASK                 0x03  /* ADC_TO_DACL - [3:2] */
+#define WM8991_ADC_TO_DACL_SHIFT		2
+#define WM8991_ADC_TO_DACR_MASK                 0x03  /* ADC_TO_DACR - [1:0] */
+#define WM8991_ADC_TO_DACR_SHIFT		0
+
+/*
+ * R14 (0x0E) - ADC CTRL
+ */
+#define WM8991_ADC_HPF_ENA                      0x0100  /* ADC_HPF_ENA */
+#define WM8991_ADC_HPF_ENA_BIT			8
+#define WM8991_ADC_HPF_CUT_MASK                 0x03  /* ADC_HPF_CUT - [6:5] */
+#define WM8991_ADC_HPF_CUT_SHIFT		5
+#define WM8991_ADCL_DATINV                      0x0002  /* ADCL_DATINV */
+#define WM8991_ADCL_DATINV_BIT			1
+#define WM8991_ADCR_DATINV                      0x0001  /* ADCR_DATINV */
+#define WM8991_ADCR_DATINV_BIT			0
+
+/*
+ * R15 (0x0F) - Left ADC Digital Volume
+ */
+#define WM8991_ADC_VU                           0x0100  /* ADC_VU */
+#define WM8991_ADCL_VOL_MASK                    0x00FF  /* ADCL_VOL - [7:0] */
+#define WM8991_ADCL_VOL_SHIFT			0
+
+/*
+ * R16 (0x10) - Right ADC Digital Volume
+ */
+#define WM8991_ADC_VU                           0x0100  /* ADC_VU */
+#define WM8991_ADCR_VOL_MASK                    0x00FF  /* ADCR_VOL - [7:0] */
+#define WM8991_ADCR_VOL_SHIFT			0
+
+/*
+ * R18 (0x12) - GPIO CTRL 1
+ */
+#define WM8991_IRQ                              0x1000  /* IRQ */
+#define WM8991_TEMPOK                           0x0800  /* TEMPOK */
+#define WM8991_MICSHRT                          0x0400  /* MICSHRT */
+#define WM8991_MICDET                           0x0200  /* MICDET */
+#define WM8991_PLL_LCK                          0x0100  /* PLL_LCK */
+#define WM8991_GPI8_STATUS                      0x0080  /* GPI8_STATUS */
+#define WM8991_GPI7_STATUS                      0x0040  /* GPI7_STATUS */
+#define WM8991_GPIO6_STATUS                     0x0020  /* GPIO6_STATUS */
+#define WM8991_GPIO5_STATUS                     0x0010  /* GPIO5_STATUS */
+#define WM8991_GPIO4_STATUS                     0x0008  /* GPIO4_STATUS */
+#define WM8991_GPIO3_STATUS                     0x0004  /* GPIO3_STATUS */
+#define WM8991_GPIO2_STATUS                     0x0002  /* GPIO2_STATUS */
+#define WM8991_GPIO1_STATUS                     0x0001  /* GPIO1_STATUS */
+
+/*
+ * R19 (0x13) - GPIO1 & GPIO2
+ */
+#define WM8991_GPIO2_DEB_ENA                    0x8000  /* GPIO2_DEB_ENA */
+#define WM8991_GPIO2_IRQ_ENA                    0x4000  /* GPIO2_IRQ_ENA */
+#define WM8991_GPIO2_PU                         0x2000  /* GPIO2_PU */
+#define WM8991_GPIO2_PD                         0x1000  /* GPIO2_PD */
+#define WM8991_GPIO2_SEL_MASK                   0x0F00  /* GPIO2_SEL - [11:8] */
+#define WM8991_GPIO1_DEB_ENA                    0x0080  /* GPIO1_DEB_ENA */
+#define WM8991_GPIO1_IRQ_ENA                    0x0040  /* GPIO1_IRQ_ENA */
+#define WM8991_GPIO1_PU                         0x0020  /* GPIO1_PU */
+#define WM8991_GPIO1_PD                         0x0010  /* GPIO1_PD */
+#define WM8991_GPIO1_SEL_MASK                   0x000F  /* GPIO1_SEL - [3:0] */
+
+/*
+ * R20 (0x14) - GPIO3 & GPIO4
+ */
+#define WM8991_GPIO4_DEB_ENA                    0x8000  /* GPIO4_DEB_ENA */
+#define WM8991_GPIO4_IRQ_ENA                    0x4000  /* GPIO4_IRQ_ENA */
+#define WM8991_GPIO4_PU                         0x2000  /* GPIO4_PU */
+#define WM8991_GPIO4_PD                         0x1000  /* GPIO4_PD */
+#define WM8991_GPIO4_SEL_MASK                   0x0F00  /* GPIO4_SEL - [11:8] */
+#define WM8991_GPIO3_DEB_ENA                    0x0080  /* GPIO3_DEB_ENA */
+#define WM8991_GPIO3_IRQ_ENA                    0x0040  /* GPIO3_IRQ_ENA */
+#define WM8991_GPIO3_PU                         0x0020  /* GPIO3_PU */
+#define WM8991_GPIO3_PD                         0x0010  /* GPIO3_PD */
+#define WM8991_GPIO3_SEL_MASK                   0x000F  /* GPIO3_SEL - [3:0] */
+
+/*
+ * R21 (0x15) - GPIO5 & GPIO6
+ */
+#define WM8991_GPIO6_DEB_ENA                    0x8000  /* GPIO6_DEB_ENA */
+#define WM8991_GPIO6_IRQ_ENA                    0x4000  /* GPIO6_IRQ_ENA */
+#define WM8991_GPIO6_PU                         0x2000  /* GPIO6_PU */
+#define WM8991_GPIO6_PD                         0x1000  /* GPIO6_PD */
+#define WM8991_GPIO6_SEL_MASK                   0x0F00  /* GPIO6_SEL - [11:8] */
+#define WM8991_GPIO5_DEB_ENA                    0x0080  /* GPIO5_DEB_ENA */
+#define WM8991_GPIO5_IRQ_ENA                    0x0040  /* GPIO5_IRQ_ENA */
+#define WM8991_GPIO5_PU                         0x0020  /* GPIO5_PU */
+#define WM8991_GPIO5_PD                         0x0010  /* GPIO5_PD */
+#define WM8991_GPIO5_SEL_MASK                   0x000F  /* GPIO5_SEL - [3:0] */
+
+/*
+ * R22 (0x16) - GPIOCTRL 2
+ */
+#define WM8991_RD_3W_ENA                        0x8000  /* RD_3W_ENA */
+#define WM8991_MODE_3W4W                        0x4000  /* MODE_3W4W */
+#define WM8991_TEMPOK_IRQ_ENA                   0x0800  /* TEMPOK_IRQ_ENA */
+#define WM8991_MICSHRT_IRQ_ENA                  0x0400  /* MICSHRT_IRQ_ENA */
+#define WM8991_MICDET_IRQ_ENA                   0x0200  /* MICDET_IRQ_ENA */
+#define WM8991_PLL_LCK_IRQ_ENA                  0x0100  /* PLL_LCK_IRQ_ENA */
+#define WM8991_GPI8_DEB_ENA                     0x0080  /* GPI8_DEB_ENA */
+#define WM8991_GPI8_IRQ_ENA                     0x0040  /* GPI8_IRQ_ENA */
+#define WM8991_GPI8_ENA                         0x0010  /* GPI8_ENA */
+#define WM8991_GPI7_DEB_ENA                     0x0008  /* GPI7_DEB_ENA */
+#define WM8991_GPI7_IRQ_ENA                     0x0004  /* GPI7_IRQ_ENA */
+#define WM8991_GPI7_ENA                         0x0001  /* GPI7_ENA */
+
+/*
+ * R23 (0x17) - GPIO_POL
+ */
+#define WM8991_IRQ_INV                          0x1000  /* IRQ_INV */
+#define WM8991_TEMPOK_POL                       0x0800  /* TEMPOK_POL */
+#define WM8991_MICSHRT_POL                      0x0400  /* MICSHRT_POL */
+#define WM8991_MICDET_POL                       0x0200  /* MICDET_POL */
+#define WM8991_PLL_LCK_POL                      0x0100  /* PLL_LCK_POL */
+#define WM8991_GPI8_POL                         0x0080  /* GPI8_POL */
+#define WM8991_GPI7_POL                         0x0040  /* GPI7_POL */
+#define WM8991_GPIO6_POL                        0x0020  /* GPIO6_POL */
+#define WM8991_GPIO5_POL                        0x0010  /* GPIO5_POL */
+#define WM8991_GPIO4_POL                        0x0008  /* GPIO4_POL */
+#define WM8991_GPIO3_POL                        0x0004  /* GPIO3_POL */
+#define WM8991_GPIO2_POL                        0x0002  /* GPIO2_POL */
+#define WM8991_GPIO1_POL                        0x0001  /* GPIO1_POL */
+
+/*
+ * R24 (0x18) - Left Line Input 1&2 Volume
+ */
+#define WM8991_IPVU                             0x0100  /* IPVU */
+#define WM8991_LI12MUTE                         0x0080  /* LI12MUTE */
+#define WM8991_LI12MUTE_BIT			7
+#define WM8991_LI12ZC                           0x0040  /* LI12ZC */
+#define WM8991_LI12ZC_BIT			6
+#define WM8991_LIN12VOL_MASK                    0x001F  /* LIN12VOL - [4:0] */
+#define WM8991_LIN12VOL_SHIFT			0
+/*
+ * R25 (0x19) - Left Line Input 3&4 Volume
+ */
+#define WM8991_IPVU                             0x0100  /* IPVU */
+#define WM8991_LI34MUTE                         0x0080  /* LI34MUTE */
+#define WM8991_LI34MUTE_BIT			7
+#define WM8991_LI34ZC                           0x0040  /* LI34ZC */
+#define WM8991_LI34ZC_BIT			6
+#define WM8991_LIN34VOL_MASK                    0x001F  /* LIN34VOL - [4:0] */
+#define WM8991_LIN34VOL_SHIFT			0
+
+/*
+ * R26 (0x1A) - Right Line Input 1&2 Volume
+ */
+#define WM8991_IPVU                             0x0100  /* IPVU */
+#define WM8991_RI12MUTE                         0x0080  /* RI12MUTE */
+#define WM8991_RI12MUTE_BIT			7
+#define WM8991_RI12ZC                           0x0040  /* RI12ZC */
+#define WM8991_RI12ZC_BIT			6
+#define WM8991_RIN12VOL_MASK                    0x001F  /* RIN12VOL - [4:0] */
+#define WM8991_RIN12VOL_SHIFT			0
+
+/*
+ * R27 (0x1B) - Right Line Input 3&4 Volume
+ */
+#define WM8991_IPVU                             0x0100  /* IPVU */
+#define WM8991_RI34MUTE                         0x0080  /* RI34MUTE */
+#define WM8991_RI34MUTE_BIT			7
+#define WM8991_RI34ZC                           0x0040  /* RI34ZC */
+#define WM8991_RI34ZC_BIT			6
+#define WM8991_RIN34VOL_MASK                    0x001F  /* RIN34VOL - [4:0] */
+#define WM8991_RIN34VOL_SHIFT			0
+
+/*
+ * R28 (0x1C) - Left Output Volume
+ */
+#define WM8991_OPVU                             0x0100  /* OPVU */
+#define WM8991_LOZC                             0x0080  /* LOZC */
+#define WM8991_LOZC_BIT				7
+#define WM8991_LOUTVOL_MASK                     0x007F  /* LOUTVOL - [6:0] */
+#define WM8991_LOUTVOL_SHIFT			0
+/*
+ * R29 (0x1D) - Right Output Volume
+ */
+#define WM8991_OPVU                             0x0100  /* OPVU */
+#define WM8991_ROZC                             0x0080  /* ROZC */
+#define WM8991_ROZC_BIT				7
+#define WM8991_ROUTVOL_MASK                     0x007F  /* ROUTVOL - [6:0] */
+#define WM8991_ROUTVOL_SHIFT			0
+/*
+ * R30 (0x1E) - Line Outputs Volume
+ */
+#define WM8991_LONMUTE                          0x0040  /* LONMUTE */
+#define WM8991_LONMUTE_BIT			6
+#define WM8991_LOPMUTE                          0x0020  /* LOPMUTE */
+#define WM8991_LOPMUTE_BIT			5
+#define WM8991_LOATTN                           0x0010  /* LOATTN */
+#define WM8991_LOATTN_BIT			4
+#define WM8991_RONMUTE                          0x0004  /* RONMUTE */
+#define WM8991_RONMUTE_BIT			2
+#define WM8991_ROPMUTE                          0x0002  /* ROPMUTE */
+#define WM8991_ROPMUTE_BIT			1
+#define WM8991_ROATTN                           0x0001  /* ROATTN */
+#define WM8991_ROATTN_BIT			0
+
+/*
+ * R31 (0x1F) - Out3/4 Volume
+ */
+#define WM8991_OUT3MUTE                         0x0020  /* OUT3MUTE */
+#define WM8991_OUT3MUTE_BIT			5
+#define WM8991_OUT3ATTN                         0x0010  /* OUT3ATTN */
+#define WM8991_OUT3ATTN_BIT			4
+#define WM8991_OUT4MUTE                         0x0002  /* OUT4MUTE */
+#define WM8991_OUT4MUTE_BIT			1
+#define WM8991_OUT4ATTN                         0x0001  /* OUT4ATTN */
+#define WM8991_OUT4ATTN_BIT			0
+
+/*
+ * R32 (0x20) - Left OPGA Volume
+ */
+#define WM8991_OPVU                             0x0100  /* OPVU */
+#define WM8991_LOPGAZC                          0x0080  /* LOPGAZC */
+#define WM8991_LOPGAZC_BIT			7
+#define WM8991_LOPGAVOL_MASK                    0x007F  /* LOPGAVOL - [6:0] */
+#define WM8991_LOPGAVOL_SHIFT			0
+
+/*
+ * R33 (0x21) - Right OPGA Volume
+ */
+#define WM8991_OPVU                             0x0100  /* OPVU */
+#define WM8991_ROPGAZC                          0x0080  /* ROPGAZC */
+#define WM8991_ROPGAZC_BIT			7
+#define WM8991_ROPGAVOL_MASK                    0x007F  /* ROPGAVOL - [6:0] */
+#define WM8991_ROPGAVOL_SHIFT			0
+/*
+ * R34 (0x22) - Speaker Volume
+ */
+#define WM8991_SPKATTN_MASK                      0x0003  /* SPKVOL - [1:0] */
+#define WM8991_SPKATTN_SHIFT			 0
+
+/*
+ * R35 (0x23) - ClassD1
+ */
+#define WM8991_CDMODE                           0x0100  /* CDMODE */
+#define WM8991_CDMODE_BIT			8
+
+/*
+ * R37 (0x25) - ClassD3
+ */
+#define WM8991_DCGAIN_MASK                      0x0007  /* DCGAIN - [5:3] */
+#define WM8991_DCGAIN_SHIFT			3
+#define WM8991_ACGAIN_MASK                      0x0007  /* ACGAIN - [2:0] */
+#define WM8991_ACGAIN_SHIFT			0
+
+/*
+ * R37 (0x26) - ClassD4
+ */
+#define WM8991_SPKZC				0x0080  /* LOPGAZC */
+#define WM8991_SPKZC_BIT			7
+#define WM8991_SPKVOL_MASK			0x007F
+#define WM8991_SPKVOL_SHIFT			0
+
+/*
+ * R39 (0x27) - Input Mixer1
+ */
+#define WM8991_AINLMODE_MASK                    0x000C  /* AINLMODE - [3:2] */
+#define WM8991_AINLMODE_SHIFT			2
+#define WM8991_AINRMODE_MASK                    0x0003  /* AINRMODE - [1:0] */
+#define WM8991_AINRMODE_SHIFT			0
+
+/*
+ * R40 (0x28) - Input Mixer2
+ */
+#define WM8991_LMP4								0x0080	/* LMP4 */
+#define WM8991_LMP4_BIT                         7		/* LMP4 */
+#define WM8991_LMN3                             0x0040  /* LMN3 */
+#define WM8991_LMN3_BIT                         6       /* LMN3 */
+#define WM8991_LMP2                             0x0020  /* LMP2 */
+#define WM8991_LMP2_BIT                         5       /* LMP2 */
+#define WM8991_LMN1                             0x0010  /* LMN1 */
+#define WM8991_LMN1_BIT                         4       /* LMN1 */
+#define WM8991_RMP4                             0x0008  /* RMP4 */
+#define WM8991_RMP4_BIT                         3       /* RMP4 */
+#define WM8991_RMN3                             0x0004  /* RMN3 */
+#define WM8991_RMN3_BIT                         2       /* RMN3 */
+#define WM8991_RMP2                             0x0002  /* RMP2 */
+#define WM8991_RMP2_BIT                         1       /* RMP2 */
+#define WM8991_RMN1                             0x0001  /* RMN1 */
+#define WM8991_RMN1_BIT                         0       /* RMN1 */
+
+/*
+ * R41 (0x29) - Input Mixer3
+ */
+#define WM8991_L34MNB                           0x0100  /* L34MNB */
+#define WM8991_L34MNB_BIT			8
+#define WM8991_L34MNBST                         0x0080  /* L34MNBST */
+#define WM8991_L34MNBST_BIT			7
+#define WM8991_L12MNB                           0x0020  /* L12MNB */
+#define WM8991_L12MNB_BIT			5
+#define WM8991_L12MNBST                         0x0010  /* L12MNBST */
+#define WM8991_L12MNBST_BIT			4
+#define WM8991_LDBVOL_MASK                      0x0007  /* LDBVOL - [2:0] */
+#define WM8991_LDBVOL_SHIFT			0
+
+/*
+ * R42 (0x2A) - Input Mixer4
+ */
+#define WM8991_R34MNB                           0x0100  /* R34MNB */
+#define WM8991_R34MNB_BIT			8
+#define WM8991_R34MNBST                         0x0080  /* R34MNBST */
+#define WM8991_R34MNBST_BIT			7
+#define WM8991_R12MNB                           0x0020  /* R12MNB */
+#define WM8991_R12MNB_BIT			5
+#define WM8991_R12MNBST                         0x0010  /* R12MNBST */
+#define WM8991_R12MNBST_BIT			4
+#define WM8991_RDBVOL_MASK                      0x0007  /* RDBVOL - [2:0] */
+#define WM8991_RDBVOL_SHIFT			0
+
+/*
+ * R43 (0x2B) - Input Mixer5
+ */
+#define WM8991_LI2BVOL_MASK                     0x07  /* LI2BVOL - [8:6] */
+#define WM8991_LI2BVOL_SHIFT			6
+#define WM8991_LR4BVOL_MASK                     0x07  /* LR4BVOL - [5:3] */
+#define WM8991_LR4BVOL_SHIFT			3
+#define WM8991_LL4BVOL_MASK                     0x07  /* LL4BVOL - [2:0] */
+#define WM8991_LL4BVOL_SHIFT			0
+
+/*
+ * R44 (0x2C) - Input Mixer6
+ */
+#define WM8991_RI2BVOL_MASK                     0x07  /* RI2BVOL - [8:6] */
+#define WM8991_RI2BVOL_SHIFT			6
+#define WM8991_RL4BVOL_MASK                     0x07  /* RL4BVOL - [5:3] */
+#define WM8991_RL4BVOL_SHIFT			3
+#define WM8991_RR4BVOL_MASK                     0x07  /* RR4BVOL - [2:0] */
+#define WM8991_RR4BVOL_SHIFT			0
+
+/*
+ * R45 (0x2D) - Output Mixer1
+ */
+#define WM8991_LRBLO                            0x0080  /* LRBLO */
+#define WM8991_LRBLO_BIT			7
+#define WM8991_LLBLO                            0x0040  /* LLBLO */
+#define WM8991_LLBLO_BIT			6
+#define WM8991_LRI3LO                           0x0020  /* LRI3LO */
+#define WM8991_LRI3LO_BIT			5
+#define WM8991_LLI3LO                           0x0010  /* LLI3LO */
+#define WM8991_LLI3LO_BIT			4
+#define WM8991_LR12LO                           0x0008  /* LR12LO */
+#define WM8991_LR12LO_BIT			3
+#define WM8991_LL12LO                           0x0004  /* LL12LO */
+#define WM8991_LL12LO_BIT			2
+#define WM8991_LDLO                             0x0001  /* LDLO */
+#define WM8991_LDLO_BIT				0
+
+/*
+ * R46 (0x2E) - Output Mixer2
+ */
+#define WM8991_RLBRO                            0x0080  /* RLBRO */
+#define WM8991_RLBRO_BIT			7
+#define WM8991_RRBRO                            0x0040  /* RRBRO */
+#define WM8991_RRBRO_BIT			6
+#define WM8991_RLI3RO                           0x0020  /* RLI3RO */
+#define WM8991_RLI3RO_BIT			5
+#define WM8991_RRI3RO                           0x0010  /* RRI3RO */
+#define WM8991_RRI3RO_BIT			4
+#define WM8991_RL12RO                           0x0008  /* RL12RO */
+#define WM8991_RL12RO_BIT			3
+#define WM8991_RR12RO                           0x0004  /* RR12RO */
+#define WM8991_RR12RO_BIT			2
+#define WM8991_RDRO                             0x0001  /* RDRO */
+#define WM8991_RDRO_BIT				0
+
+/*
+ * R47 (0x2F) - Output Mixer3
+ */
+#define WM8991_LLI3LOVOL_MASK                   0x07  /* LLI3LOVOL - [8:6] */
+#define WM8991_LLI3LOVOL_SHIFT			6
+#define WM8991_LR12LOVOL_MASK                   0x07  /* LR12LOVOL - [5:3] */
+#define WM8991_LR12LOVOL_SHIFT			3
+#define WM8991_LL12LOVOL_MASK                   0x07  /* LL12LOVOL - [2:0] */
+#define WM8991_LL12LOVOL_SHIFT			0
+
+/*
+ * R48 (0x30) - Output Mixer4
+ */
+#define WM8991_RRI3ROVOL_MASK                   0x07  /* RRI3ROVOL - [8:6] */
+#define WM8991_RRI3ROVOL_SHIFT			6
+#define WM8991_RL12ROVOL_MASK                   0x07  /* RL12ROVOL - [5:3] */
+#define WM8991_RL12ROVOL_SHIFT			3
+#define WM8991_RR12ROVOL_MASK                   0x07  /* RR12ROVOL - [2:0] */
+#define WM8991_RR12ROVOL_SHIFT			0
+
+/*
+ * R49 (0x31) - Output Mixer5
+ */
+#define WM8991_LRI3LOVOL_MASK                   0x07  /* LRI3LOVOL - [8:6] */
+#define WM8991_LRI3LOVOL_SHIFT			6
+#define WM8991_LRBLOVOL_MASK                    0x07  /* LRBLOVOL - [5:3] */
+#define WM8991_LRBLOVOL_SHIFT			3
+#define WM8991_LLBLOVOL_MASK                    0x07  /* LLBLOVOL - [2:0] */
+#define WM8991_LLBLOVOL_SHIFT			0
+
+/*
+ * R50 (0x32) - Output Mixer6
+ */
+#define WM8991_RLI3ROVOL_MASK                   0x07  /* RLI3ROVOL - [8:6] */
+#define WM8991_RLI3ROVOL_SHIFT			6
+#define WM8991_RLBROVOL_MASK                    0x07  /* RLBROVOL - [5:3] */
+#define WM8991_RLBROVOL_SHIFT			3
+#define WM8991_RRBROVOL_MASK                    0x07  /* RRBROVOL - [2:0] */
+#define WM8991_RRBROVOL_SHIFT			0
+
+/*
+ * R51 (0x33) - Out3/4 Mixer
+ */
+#define WM8991_VSEL_MASK                        0x0180  /* VSEL - [8:7] */
+#define WM8991_LI4O3                            0x0020  /* LI4O3 */
+#define WM8991_LI4O3_BIT			5
+#define WM8991_LPGAO3                           0x0010  /* LPGAO3 */
+#define WM8991_LPGAO3_BIT			4
+#define WM8991_RI4O4                            0x0002  /* RI4O4 */
+#define WM8991_RI4O4_BIT			1
+#define WM8991_RPGAO4                           0x0001  /* RPGAO4 */
+#define WM8991_RPGAO4_BIT			0
+/*
+ * R52 (0x34) - Line Mixer1
+ */
+#define WM8991_LLOPGALON                        0x0040  /* LLOPGALON */
+#define WM8991_LLOPGALON_BIT			6
+#define WM8991_LROPGALON                        0x0020  /* LROPGALON */
+#define WM8991_LROPGALON_BIT			5
+#define WM8991_LOPLON                           0x0010  /* LOPLON */
+#define WM8991_LOPLON_BIT			4
+#define WM8991_LR12LOP                          0x0004  /* LR12LOP */
+#define WM8991_LR12LOP_BIT			2
+#define WM8991_LL12LOP                          0x0002  /* LL12LOP */
+#define WM8991_LL12LOP_BIT			1
+#define WM8991_LLOPGALOP                        0x0001  /* LLOPGALOP */
+#define WM8991_LLOPGALOP_BIT			0
+/*
+ * R53 (0x35) - Line Mixer2
+ */
+#define WM8991_RROPGARON                        0x0040  /* RROPGARON */
+#define WM8991_RROPGARON_BIT			6
+#define WM8991_RLOPGARON                        0x0020  /* RLOPGARON */
+#define WM8991_RLOPGARON_BIT			5
+#define WM8991_ROPRON                           0x0010  /* ROPRON */
+#define WM8991_ROPRON_BIT			4
+#define WM8991_RL12ROP                          0x0004  /* RL12ROP */
+#define WM8991_RL12ROP_BIT			2
+#define WM8991_RR12ROP                          0x0002  /* RR12ROP */
+#define WM8991_RR12ROP_BIT			1
+#define WM8991_RROPGAROP                        0x0001  /* RROPGAROP */
+#define WM8991_RROPGAROP_BIT			0
+
+/*
+ * R54 (0x36) - Speaker Mixer
+ */
+#define WM8991_LB2SPK                           0x0080  /* LB2SPK */
+#define WM8991_LB2SPK_BIT			7
+#define WM8991_RB2SPK                           0x0040  /* RB2SPK */
+#define WM8991_RB2SPK_BIT			6
+#define WM8991_LI2SPK                           0x0020  /* LI2SPK */
+#define WM8991_LI2SPK_BIT			5
+#define WM8991_RI2SPK                           0x0010  /* RI2SPK */
+#define WM8991_RI2SPK_BIT			4
+#define WM8991_LOPGASPK                         0x0008  /* LOPGASPK */
+#define WM8991_LOPGASPK_BIT			3
+#define WM8991_ROPGASPK                         0x0004  /* ROPGASPK */
+#define WM8991_ROPGASPK_BIT			2
+#define WM8991_LDSPK                            0x0002  /* LDSPK */
+#define WM8991_LDSPK_BIT			1
+#define WM8991_RDSPK                            0x0001  /* RDSPK */
+#define WM8991_RDSPK_BIT			0
+
+/*
+ * R55 (0x37) - Additional Control
+ */
+#define WM8991_VROI                             0x0001  /* VROI */
+
+/*
+ * R56 (0x38) - AntiPOP1
+ */
+#define WM8991_DIS_LLINE                        0x0020  /* DIS_LLINE */
+#define WM8991_DIS_RLINE                        0x0010  /* DIS_RLINE */
+#define WM8991_DIS_OUT3                         0x0008  /* DIS_OUT3 */
+#define WM8991_DIS_OUT4                         0x0004  /* DIS_OUT4 */
+#define WM8991_DIS_LOUT                         0x0002  /* DIS_LOUT */
+#define WM8991_DIS_ROUT                         0x0001  /* DIS_ROUT */
+
+/*
+ * R57 (0x39) - AntiPOP2
+ */
+#define WM8991_SOFTST                           0x0040  /* SOFTST */
+#define WM8991_BUFIOEN                          0x0008  /* BUFIOEN */
+#define WM8991_BUFDCOPEN                        0x0004  /* BUFDCOPEN */
+#define WM8991_POBCTRL                          0x0002  /* POBCTRL */
+#define WM8991_VMIDTOG                          0x0001  /* VMIDTOG */
+
+/*
+ * R58 (0x3A) - MICBIAS
+ */
+#define WM8991_MCDSCTH_MASK                     0x00C0  /* MCDSCTH - [7:6] */
+#define WM8991_MCDSCTH                          6       /* MCDSCTH - [7:6] */
+#define WM8991_MCDTHR_MASK                      0x0038  /* MCDTHR - [5:3] */
+#define WM8991_MCD                              0x0004  /* MCD */
+#define WM8991_MBSEL                            0x0001  /* MBSEL */
+
+/*
+ * R60 (0x3C) - PLL1
+ */
+#define WM8991_SDM                              0x0080  /* SDM */
+#define WM8991_PRESCALE                         0x0040  /* PRESCALE */
+#define WM8991_PLLN_MASK                        0x000F  /* PLLN - [3:0] */
+
+/*
+ * R61 (0x3D) - PLL2
+ */
+#define WM8991_PLLK1_MASK                       0x00FF  /* PLLK1 - [7:0] */
+
+/*
+ * R62 (0x3E) - PLL3
+ */
+#define WM8991_PLLK2_MASK                       0x00FF  /* PLLK2 - [7:0] */
+
+/*
+ * R63 (0x3F) - Internal Driver Bits
+ */
+#define WM8991_INMIXL_PWR_BIT			0
+#define WM8991_AINLMUX_PWR_BIT			1
+#define WM8991_INMIXR_PWR_BIT			2
+#define WM8991_AINRMUX_PWR_BIT			3
+
+#define WM8991_MCLK_DIV 0
+#define WM8991_DACCLK_DIV 1
+#define WM8991_ADCCLK_DIV 2
+#define WM8991_BCLK_DIV 3
+
+extern struct snd_soc_dai wm8991_dai;
+extern struct snd_soc_codec_device soc_codec_dev_wm8991;
+
+#endif	/* __WM8991REGISTERDEFS_H__ */
+/*------------------------------ END OF FILE ---------------------------------*/
diff -Nur linux-2.6.32-orig/sound/soc/codecs/wm9712.c iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm9712.c
--- linux-2.6.32-orig/sound/soc/codecs/wm9712.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/codecs/wm9712.c	2010-11-18 21:05:30.000000000 +0600
@@ -464,7 +464,8 @@
 {
 	u16 *cache = codec->reg_cache;
 
-	soc_ac97_ops.write(codec->ac97, reg, val);
+	if (reg < 0x7c)
+		soc_ac97_ops.write(codec->ac97, reg, val);
 	reg = reg >> 1;
 	if (reg < (ARRAY_SIZE(wm9712_reg)))
 		cache[reg] = val;
diff -Nur linux-2.6.32-orig/sound/soc/iphone/iphone-audio.h iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/iphone-audio.h
--- linux-2.6.32-orig/sound/soc/iphone/iphone-audio.h	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/iphone-audio.h	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,18 @@
+#ifndef IPHONE_AUDIO_H
+#define IPHONE_AUDIO_H
+
+#include <linux/dma-mapping.h>
+
+struct iphone_i2s_dma_params
+{
+	dma_addr_t dma_target;
+	u32 i2sController;
+};
+
+extern struct snd_soc_platform snd_iphone_soc_platform;
+extern struct snd_soc_dai iphone_i2s_wm8758_dai;
+extern struct snd_soc_dai iphone_i2s_bb_dai;
+extern struct snd_soc_dai iphone_bb_dai;
+extern struct snd_soc_dai iphone_wm8758_dai;
+extern struct snd_soc_codec_device soc_codec_dev_wm8758;
+#endif
diff -Nur linux-2.6.32-orig/sound/soc/iphone/iphone-bb-audio.c iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/iphone-bb-audio.c
--- linux-2.6.32-orig/sound/soc/iphone/iphone-bb-audio.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/iphone-bb-audio.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,100 @@
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/tlv.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "iphone-audio.h"
+
+static int iphone_bb_pcm_startup(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	dev_info(codec->dev, "ENTER iphone_bb_pcm_startup\n");
+	return 0;
+}
+
+
+static int iphone_bb_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	dev_info(codec->dev, "ENTER iphone_bb_pcm_hw_params\n");
+	return 0;
+}
+
+static int iphone_bb_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+
+	dev_info(codec->dev, "ENTER iphone_bb_set_dai_fmt %u\n", fmt);
+	return 0;
+}
+
+static int iphone_bb_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+
+	dev_info(codec->dev, "ENTER iphone_bb_set_dai_sysclk %d %u %d\n", clk_id, freq, dir);
+	return 0;
+}
+
+static int iphone_bb_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	dev_info(codec->dev, "ENTER iphone_bb_mute\n");
+	return 0;
+}
+
+static struct snd_soc_dai_ops iphone_bb_dai_ops = {
+	.startup = iphone_bb_pcm_startup,
+	.hw_params = iphone_bb_pcm_hw_params,
+	.set_fmt = iphone_bb_set_dai_fmt,
+	.set_sysclk = iphone_bb_set_dai_sysclk,
+	.digital_mute = iphone_bb_mute,
+};
+
+struct snd_soc_dai iphone_bb_dai = {
+	.name = "Baseband",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	 },
+	.ops = &iphone_bb_dai_ops,
+	.symmetric_rates = 1,
+};
+
+static int __init iphone_bb_audio_init(void)
+{
+	return snd_soc_register_dai(&iphone_bb_dai);
+}
+
+static void __exit iphone_bb_audio_exit(void)
+{
+	snd_soc_unregister_dai(&iphone_bb_dai);
+}
+
+module_init(iphone_bb_audio_init);
+module_exit(iphone_bb_audio_exit);
+
+MODULE_DESCRIPTION("iPhone baseband audio codec driver");
+MODULE_AUTHOR("Yiduo Wang");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/sound/soc/iphone/iphone-i2s.c iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/iphone-i2s.c
--- linux-2.6.32-orig/sound/soc/iphone/iphone-i2s.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/iphone-i2s.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,301 @@
+/*
+ * pxa2xx-i2s.c  --  ALSA Soc Audio Layer
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         lrg@slimlogic.co.uk
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#ifdef CONFIG_IPHONE_3G
+#	include "../codecs/wm8991.h"
+#endif
+
+#include <mach/iphone-clock.h>
+#include <mach/hardware.h>
+#include <mach/iphone-dma.h>
+
+#include "iphone-audio.h"
+
+#define I2S0_CLOCK 0x27
+#define I2S1_CLOCK 0x2A
+
+#define I2S0 IO_ADDRESS(0x3CA00000)
+#define I2S1 IO_ADDRESS(0x3CD00000)
+
+#define I2S_CLKCON 0
+#define I2S_TXCON 0x4
+#define I2S_TXCOM 0x8
+#define I2S_RXCON 0x30
+#define I2S_RXCOM 0x34
+#define I2S_STATUS 0x3C
+
+#ifdef CONFIG_IPODTOUCH_1G
+#define WM_I2S I2S1
+#define DMA_WM_I2S_TX IPHONE_DMA_I2S1_TX
+#define DMA_WM_I2S_RX IPHONE_DMA_I2S1_RX
+#else
+#define WM_I2S I2S0
+#define DMA_WM_I2S_TX IPHONE_DMA_I2S0_TX
+#define DMA_WM_I2S_RX IPHONE_DMA_I2S0_RX
+#define BB_I2S I2S1
+#define DMA_BB_I2S_TX IPHONE_DMA_I2S1_TX
+#define DMA_BB_I2S_RX IPHONE_DMA_I2S1_RX
+#endif
+
+struct iphone_i2s_dma_params dma_playback_wm = {
+	.dma_target	= DMA_WM_I2S_TX,
+	.i2sController	= WM_I2S,
+};
+
+struct iphone_i2s_dma_params dma_recording_wm = {
+	.dma_target = DMA_WM_I2S_RX,
+	.i2sController	= WM_I2S,
+};
+
+#ifndef CONFIG_IPODTOUCH_1G
+struct iphone_i2s_dma_params dma_playback_bb = {
+	.dma_target	= DMA_BB_I2S_TX,
+	.i2sController	= BB_I2S,
+};
+
+struct iphone_i2s_dma_params dma_recording_bb = {
+	.dma_target = DMA_BB_I2S_RX,
+	.i2sController	= BB_I2S,
+};
+#endif
+
+static int iphone_i2s_startup(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *socdai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_link *dai = rtd->dai;
+
+	pr_debug("ENTER iphone_i2s_startup\n");
+
+	/* prepopulate DMA data so that anyone can figure out which DMA controller is needed */
+#ifdef CONFIG_IPODTOUCH_1G
+	dai->cpu_dai->dma_data = &dma_playback_wm;
+#else
+	dai->cpu_dai->dma_data = (socdai->id == 0) ? &dma_playback_wm : &dma_playback_bb;
+#endif
+	return 0;
+}
+
+static int iphone_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,
+		unsigned int fmt)
+{
+	pr_debug("ENTER iphone_i2s_set_dai_fmt %u\n", fmt);
+	return 0;
+}
+
+static int iphone_i2s_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	pr_debug("ENTER iphone_i2s_set_dai_sysclk %d %u %d\n", clk_id, freq, dir);
+	return 0;
+}
+
+static int iphone_i2s_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *socdai)
+{
+	int ret = 0;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_link *dai = rtd->dai;
+	struct iphone_i2s_dma_params* dma_params;
+
+	pr_debug("ENTER iphone_i2s_hw_params\n");
+
+#ifdef CONFIG_IPHONE_3G
+	snd_soc_dai_set_pll(socdai, 0, 0, 0x785fc);
+#endif
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	{
+#ifdef CONFIG_IPODTOUCH_1G
+		dma_params = &dma_playback_wm;
+#else
+		dma_params = (socdai->id == 0) ? &dma_playback_wm : &dma_playback_bb;
+#endif
+		dai->cpu_dai->dma_data = dma_params;
+		writel( (1 << 24) |  /* undocumented */
+			(1 << 20) |  /* undocumented */
+			(0 << 16) |  /* burst length */
+			(0 << 15) |  /* 0 = falling edge */
+			(0 << 13) |  /* 0 = basic I2S format */
+			(0 << 12) |  /* 0 = MSB first */
+			(0 << 11) |  /* 0 = left channel for low polarity */
+			(3 << 8) |   /* MCLK divider */
+			(0 << 5) |   /* 0 = 16-bit */
+			(0 << 3) |   /* bit clock per frame */
+			(1 << 0),
+			dma_params->i2sController + I2S_TXCON);    /* channel index */
+
+		writel((1 << 0), dma_params->i2sController + I2S_CLKCON);
+
+		writel(	(0 << 3) |   /* 1 = transmit mode on */
+			(1 << 2) |   /* 1 = I2S interface enable */
+			(1 << 1) |   /* 1 = DMA request enable */
+			(0 << 0),
+			dma_params->i2sController + I2S_TXCOM);    /* 0 = LRCK on */
+	} else
+	{
+#ifdef CONFIG_IPODTOUCH_1G
+		dma_params = &dma_recording_wm;
+#else
+		dma_params = (socdai->id == 0) ? &dma_recording_wm : &dma_recording_bb;
+#endif
+		dai->cpu_dai->dma_data = dma_params;
+		writel(
+			(0 << 12) |  /* 0 = falling edge */
+			(0 << 10) |  /* 0 = basic I2S format */
+			(0 << 9) |  /* 0 = MSB first */
+			(0 << 8) |  /* 0 = left channel for low polarity */
+			(3 << 5) |   /* MCLK divider */
+			(0 << 2) |   /* 0 = 16-bit */
+			(0 << 0),   /* bit clock per frame */
+			dma_params->i2sController + I2S_RXCON);    /* channel index */
+
+		writel((1 << 0), dma_params->i2sController + I2S_CLKCON);
+
+		writel(	(0 << 3) |   /* 1 = transmit mode on */
+			(1 << 2) |   /* 1 = I2S interface enable */
+			(1 << 1) |   /* 1 = DMA request enable */
+			(0 << 0),
+			dma_params->i2sController + I2S_RXCOM);    /* 0 = LRCK on */
+	}
+
+	return ret;
+}
+
+static int iphone_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+			      struct snd_soc_dai *dai)
+{
+	int ret = 0;
+
+	pr_debug("ENTER iphone_i2s_trigger\n");
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void iphone_i2s_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *socdai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_link *dai = rtd->dai;
+	struct iphone_i2s_dma_params* dma_params = dai->cpu_dai->dma_data;
+
+	writel((1 << 0), dma_params->i2sController + I2S_CLKCON);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		writel(1, dma_params->i2sController + I2S_TXCOM);
+	} else {
+		writel(1, dma_params->i2sController + I2S_RXCOM);
+}
+}
+
+static struct snd_soc_dai_ops iphone_i2s_dai_ops = {
+	.startup	= iphone_i2s_startup,
+	.shutdown	= iphone_i2s_shutdown,
+	.trigger	= iphone_i2s_trigger,
+	.hw_params	= iphone_i2s_hw_params,
+	.set_fmt	= iphone_i2s_set_dai_fmt,
+	.set_sysclk	= iphone_i2s_set_dai_sysclk,
+};
+
+struct snd_soc_dai iphone_i2s_wm8758_dai = {
+	.name = "iphone-i2s-wm8758",
+	.id = 0,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = &iphone_i2s_dai_ops,
+	.symmetric_rates = 1,
+};
+
+struct snd_soc_dai iphone_i2s_bb_dai = {
+	.name = "iphone-i2s-baseband",
+	.id = 1,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = &iphone_i2s_dai_ops,
+	.symmetric_rates = 1,
+};
+
+static int __init iphone_i2s_init(void)
+{
+	int ret;
+	iphone_clock_gate_switch(I2S0_CLOCK, 1);
+	iphone_clock_gate_switch(I2S1_CLOCK, 1);
+	ret = snd_soc_register_dai(&iphone_i2s_wm8758_dai);
+	if(ret)
+		return ret;
+
+	ret = snd_soc_register_dai(&iphone_i2s_bb_dai);
+	if(ret)
+	{
+		snd_soc_unregister_dai(&iphone_i2s_wm8758_dai);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit iphone_i2s_exit(void)
+{
+	snd_soc_unregister_dai(&iphone_i2s_bb_dai);
+	snd_soc_unregister_dai(&iphone_i2s_wm8758_dai);
+	iphone_clock_gate_switch(I2S0_CLOCK, 0);
+	iphone_clock_gate_switch(I2S1_CLOCK, 0);
+}
+
+module_init(iphone_i2s_init);
+module_exit(iphone_i2s_exit);
+
+/* Module information */
+MODULE_AUTHOR("Yiduo Wang");
+MODULE_DESCRIPTION("Apple iPhone I2S SoC Interface");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/sound/soc/iphone/iphone-i2s-dma.c iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/iphone-i2s-dma.c
--- linux-2.6.32-orig/sound/soc/iphone/iphone-i2s-dma.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/iphone-i2s-dma.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,431 @@
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <mach/iphone-dma.h>
+#include <mach/iphone-clock.h>
+#include <mach/hardware.h>
+
+#include "iphone-audio.h"
+
+struct iphone_runtime_data
+{
+	spinlock_t lock;
+
+	int dummy;
+	int params;
+
+	int controller;
+	int channel;
+	int i2s;
+
+	dma_addr_t dma_start;
+	unsigned int dma_periods;
+	size_t dma_period_bytes;
+
+	DMALinkedList* continueList;
+	size_t continueListPeriodSize;
+	size_t continueListSize;
+	dma_addr_t continueListPhys;
+};
+
+static const struct snd_pcm_hardware iphone_pcm_hardware = {
+	.info                   = SNDRV_PCM_INFO_INTERLEAVED |
+                                  SNDRV_PCM_INFO_BLOCK_TRANSFER |
+                                  SNDRV_PCM_INFO_MMAP |
+                                  SNDRV_PCM_INFO_MMAP_VALID |
+                                  SNDRV_PCM_INFO_PAUSE |
+                                  SNDRV_PCM_INFO_RESUME,
+	.formats                = SNDRV_PCM_FMTBIT_S16_LE,
+	.channels_min           = 2,
+	.channels_max           = 2,
+	.buffer_bytes_max       = 128*1024,
+	.period_bytes_min       = PAGE_SIZE,
+	.period_bytes_max       = PAGE_SIZE*2,
+	.periods_min            = 2,
+	.periods_max            = 128,
+	.fifo_size              = 32,
+};
+
+static int iphone_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct iphone_runtime_data *rtd;
+	int ret;
+
+	pr_debug("ENTER iphone_pcm_open\n");
+
+	runtime->hw = iphone_pcm_hardware;
+
+	/*
+	 * For mysterious reasons (and despite what the manual says)
+	 * playback samples are lost if the DMA count is not a multiple
+	 * of the DMA burst size.  Let's add a rule to enforce that.
+	ret = snd_pcm_hw_constraint_step(runtime, 0,
+		SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);
+	if (ret)
+		goto out;
+
+	ret = snd_pcm_hw_constraint_step(runtime, 0,
+		SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 32);
+	if (ret)
+		goto out;
+	 */
+
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		goto out;
+
+	ret = snd_soc_set_runtime_hwparams(substream, &iphone_pcm_hardware);
+	if (ret < 0)
+		goto out;
+
+	ret = -ENOMEM;
+	rtd = kzalloc(sizeof(*rtd), GFP_KERNEL);
+	if (!rtd)
+		goto out;
+
+	rtd->controller = -1;
+	rtd->channel = -1;
+
+	spin_lock_init(&rtd->lock);
+
+	runtime->private_data = rtd;
+	return 0;
+
+	kfree(rtd);
+ out:
+	return ret;
+}
+
+static int iphone_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct iphone_runtime_data *rtd = runtime->private_data;
+
+	pr_debug("ENTER iphone_pcm_close\n");
+
+	kfree(rtd);
+	return 0;
+}
+
+static void iphone_pcm_period_handler(int controller, int channel, void* token)
+{
+	struct snd_pcm_substream *substream = token;
+
+	pr_debug("ENTER iphone_pcm_period_handler\n");
+
+	if (substream)
+		snd_pcm_period_elapsed(substream);
+}
+
+static int iphone_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct iphone_runtime_data *prtd = substream->runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct iphone_i2s_dma_params *dma = rtd->dai->cpu_dai->dma_data;
+	dma_addr_t src;
+	dma_addr_t dest;
+	dma_addr_t orig_src;
+	dma_addr_t orig_dest;
+	dma_addr_t* memory;
+
+	DMALinkedList* item;
+	dma_addr_t itemPhys;
+	DMALinkedList* last;
+
+	int i;
+
+	pr_debug("ENTER iphone_pcm_prepare\n");
+
+	if (!prtd || prtd->controller == -1)
+		return 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	{
+		iphone_dma_request(IPHONE_DMA_MEMORY, 2, 1, dma->dma_target, 2, 1, &prtd->controller, &prtd->channel);
+		src = prtd->dma_start;
+		dest = dma->dma_target;
+		memory = &src;
+	} else
+	{
+		iphone_dma_request(dma->dma_target, 2, 1, IPHONE_DMA_MEMORY, 2, 1, &prtd->controller, &prtd->channel);
+		src = dma->dma_target;
+		dest = prtd->dma_start;
+		memory = &dest;
+	}
+
+	orig_src = src;
+	orig_dest = dest;
+
+	/* Create a circular continue list of periods, with each period being a link in the circular chain */
+	item = prtd->continueList;
+	itemPhys = prtd->continueListPhys;
+
+	for(i = 0; i < prtd->dma_periods; ++i)
+	{
+		iphone_dma_create_continue_list(src, dest, prtd->dma_period_bytes, &prtd->controller, &prtd->channel,
+				&item, &itemPhys, &prtd->continueListPeriodSize, &last);
+
+		itemPhys += prtd->continueListPeriodSize;
+		item = (DMALinkedList*)(((u32)(item)) + prtd->continueListPeriodSize);
+		last->next = itemPhys;
+		*memory += prtd->dma_period_bytes;
+	}
+
+	/* Close the loop */
+	last->next = prtd->continueListPhys;
+
+	return iphone_dma_prepare(orig_src, orig_dest, 0, prtd->continueList, &prtd->controller, &prtd->channel);
+}
+
+static int iphone_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct iphone_runtime_data *prtd = runtime->private_data;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct iphone_i2s_dma_params *dma = rtd->dai->cpu_dai->dma_data;
+	unsigned int period_bytes = params_period_bytes(params);
+	unsigned int periods = params_periods(params);
+	unsigned int totbytes = params_buffer_bytes(params);
+
+	pr_debug("ENTER iphone_pcm_hw_params\n");
+
+	if((periods * period_bytes) != totbytes)
+	{
+		printk(KERN_ERR "iphone-audio: periods must be integral\n");
+		return -EINVAL;
+	}
+
+	if(prtd->controller == -1)
+	{
+		int controller = 0;
+		int channel = 0;
+
+		/* the details don't matter yet at this point, we're just trying to get a channel.. we need to get a controller that can send to the peripheral, though */
+		/* but whether it's the source or the destination doesn't really matter at this point. */
+		int ret = iphone_dma_request(dma->dma_target, 2, 1, IPHONE_DMA_MEMORY, 2, 1, &controller, &channel);
+		if(ret != 0)
+		{
+			printk(KERN_ERR "iphone-audio: failed to get dma channel\n");
+			return -EBUSY;
+		}
+
+		iphone_dma_set_done_handler(&controller, &channel, iphone_pcm_period_handler, substream);
+
+		prtd->controller = controller;
+		prtd->channel = channel;
+
+		prtd->continueListPeriodSize = iphone_dma_continue_list_size(runtime->dma_addr, IPHONE_DMA_I2S0_TX, period_bytes, &prtd->controller, &prtd->channel);
+		prtd->continueListSize = prtd->continueListPeriodSize * periods;
+		prtd->continueList = dma_alloc_writecombine(buf->dev.dev, prtd->continueListSize, &prtd->continueListPhys, GFP_KERNEL);
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = totbytes;
+
+	spin_lock_irq(&prtd->lock);
+	prtd->i2s = 1;
+	prtd->dma_start = runtime->dma_addr;
+	prtd->dma_periods = periods;
+	prtd->dma_period_bytes = period_bytes;
+	spin_unlock_irq(&prtd->lock);
+
+	return 0;
+}
+
+static int iphone_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct iphone_runtime_data *prtd = substream->runtime->private_data;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+
+	pr_debug("ENTER iphone_pcm_hw_free\n");
+
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	if (prtd->controller != -1)
+	{
+		iphone_dma_pause(prtd->controller, prtd->channel);
+		iphone_dma_finish(prtd->controller, prtd->channel, 0);
+		prtd->controller = -1;
+		prtd->channel = -1;
+		dma_free_writecombine(buf->dev.dev, prtd->continueListSize, prtd->continueList, prtd->continueListPhys);
+
+	}
+
+	return 0;
+}
+
+static int iphone_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct iphone_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	pr_debug("ENTER iphone_pcm_trigger\n");
+
+	spin_lock(&prtd->lock);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		iphone_dma_resume(prtd->controller, prtd->channel);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		iphone_dma_pause(prtd->controller, prtd->channel);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	spin_unlock(&prtd->lock);
+
+	return ret;
+}
+
+static snd_pcm_uframes_t iphone_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct iphone_runtime_data *prtd = runtime->private_data;
+
+	dma_addr_t ptr;
+	dma_addr_t diff;
+	snd_pcm_uframes_t x;
+
+	spin_lock(&prtd->lock);
+	ptr = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+			 iphone_dma_srcpos(prtd->controller, prtd->channel) : iphone_dma_dstpos(prtd->controller, prtd->channel);
+
+	diff = ptr - runtime->dma_addr;
+	spin_unlock(&prtd->lock);
+
+	x = bytes_to_frames(runtime, diff);
+
+	if (x == runtime->buffer_size)
+		x = 0;
+
+	return x;
+}
+
+static int iphone_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops iphone_pcm_ops = {
+	.open		= iphone_pcm_open,
+	.close		= iphone_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= iphone_pcm_hw_params,
+	.hw_free	= iphone_pcm_hw_free,
+	.prepare	= iphone_pcm_prepare,
+	.trigger	= iphone_pcm_trigger,
+	.pointer	= iphone_pcm_pointer,
+	.mmap		= iphone_pcm_mmap,
+};
+
+static u64 iphone_pcm_dmamask = DMA_BIT_MASK(32);
+
+static int iphone_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = iphone_pcm_hardware.buffer_bytes_max;
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	return 0;
+}
+
+static int iphone_soc_pcm_new(struct snd_card *card, struct snd_soc_dai *dai,
+	struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	pr_debug("ENTER iphone_soc_pcm_new\n");
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &iphone_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	if (dai->playback.channels_min) {
+		ret = iphone_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->capture.channels_min) {
+		ret = iphone_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+ out:
+	return ret;
+}
+
+static void iphone_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	pr_debug("ENTER iphone_soc_pcm_free_dma_buffers\n");
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+struct snd_soc_platform snd_iphone_soc_platform = {
+	.name		= "iphone-i2s-dma",
+	.pcm_ops 	= &iphone_pcm_ops,
+	.pcm_new	= iphone_soc_pcm_new,
+	.pcm_free	= iphone_pcm_free_dma_buffers,
+};
+EXPORT_SYMBOL_GPL(snd_iphone_soc_platform);
+
+static int __init snd_iphone_soc_platform_init(void)
+{
+	return snd_soc_register_platform(&snd_iphone_soc_platform);
+}
+module_init(snd_iphone_soc_platform_init);
+
+static void __exit snd_iphone_soc_platform_exit(void)
+{
+	snd_soc_unregister_platform(&snd_iphone_soc_platform);
+}
+module_exit(snd_iphone_soc_platform_exit);
+
+MODULE_AUTHOR("Yiduo Wang");
+MODULE_DESCRIPTION("Apple iPhone PCM DMA module");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/sound/soc/iphone/iphone-sound.c iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/iphone-sound.c
--- linux-2.6.32-orig/sound/soc/iphone/iphone-sound.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/iphone-sound.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,165 @@
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/tlv.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "iphone-audio.h"
+
+#ifdef CONFIG_IPHONE_3G
+#include "../codecs/wm8991.h"
+#endif
+
+#ifndef CONFIG_IPHONE_3G
+static int iphone_soc_to_wm8758_init(struct snd_soc_codec *codec)
+{
+	pr_debug("ENTER iphone_soc_to_wm8758_init\n");
+	return 0;
+}
+
+static int iphone_soc_to_bb_init(struct snd_soc_codec *codec)
+{
+	pr_debug("ENTER iphone_soc_to_bb_init\n");
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_IPHONE_3G
+static int iphone_wm8991_init(struct snd_soc_codec *codec)
+{
+	printk("WM8991 initialising...\n");
+	return 0;
+}
+
+static int iphone_wm8991_link_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	int ret;
+
+	ret = snd_soc_dai_set_clkdiv(codec_dai, WM8991_MCLK_DIV, WM8991_MCLK_DIV_2);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(codec_dai, WM8991_BCLK_DIV, WM8991_BCLK_DIV_8);
+	if (ret < 0)
+		return ret;
+
+	// this forces N = 7, K = 0x85FC for wm8991.
+	ret = snd_soc_dai_set_pll(codec_dai, 0, 0, 0x0785FC);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops iphone_wm8991_link_ops =
+{
+	.hw_params = iphone_wm8991_link_hw_params,
+};
+#endif
+
+static struct snd_soc_dai_link iphone_dai_links[] = {
+#ifndef CONFIG_IPHONE_3G
+	{
+		.name           = "WM8758",
+		.stream_name    = "WM8758",
+		.cpu_dai        = &iphone_i2s_wm8758_dai,
+		.codec_dai      = &iphone_wm8758_dai,
+		.init           = iphone_soc_to_wm8758_init,
+	},
+#ifndef CONFIG_IPODTOUCH_1G
+	{
+		.name           = "Baseband",
+		.stream_name    = "Baseband",
+		.cpu_dai        = &iphone_i2s_bb_dai,
+		.codec_dai      = &iphone_bb_dai,
+		.init           = iphone_soc_to_bb_init,
+	}
+#endif
+#else
+	{
+		.name			= "WM8991",
+		.stream_name	= "WM8991",
+		.cpu_dai		= &iphone_i2s_wm8758_dai, // This is bad, jah?
+		.codec_dai		= &wm8991_dai,
+		.init			= iphone_wm8991_init,
+		.ops			= &iphone_wm8991_link_ops,
+	},
+#endif
+};
+
+static struct snd_soc_card iphone_snd_soc_card = {
+	.name           = "iPhoneSound",
+	.platform       = &snd_iphone_soc_platform,
+	.dai_link       = iphone_dai_links,
+	.num_links      = ARRAY_SIZE(iphone_dai_links),
+};
+
+//#ifdef CONFIG_IPHONE_3G
+#if 0
+static struct wm8990_setup_data wm8991_i2c_setup = {
+	.i2c_bus = 0,
+	.i2c_address = 0x36,
+};
+#endif
+
+static struct snd_soc_device iphone_snd_soc_device = {
+	.card           = &iphone_snd_soc_card,
+
+#ifndef CONFIG_IPHONE_3G
+	.codec_dev      = &soc_codec_dev_wm8758,
+#else
+	.codec_dev		= &soc_codec_dev_wm8991,
+	//.codec_data		= &wm8991_i2c_setup,
+#endif
+};
+
+static struct platform_device *snd_dev;
+
+static int __init iphone_sound_init(void)
+{
+	int ret = 0;
+
+	snd_dev = platform_device_alloc("soc-audio", -1);
+	if (!snd_dev) {
+		printk("failed to alloc soc-audio device\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	platform_set_drvdata(snd_dev, &iphone_snd_soc_device);
+	iphone_snd_soc_device.dev = &snd_dev->dev;
+
+	ret = platform_device_add(snd_dev);
+	if (ret) {
+
+		printk("failed to add soc-audio dev\n");
+		platform_device_put(snd_dev);
+	}
+
+	return ret;
+}
+
+static void __exit iphone_sound_exit(void)
+{
+	platform_device_unregister(snd_dev);
+}
+
+module_init(iphone_sound_init);
+module_exit(iphone_sound_exit);
+
+MODULE_DESCRIPTION("iPhone SoC sound driver");
+MODULE_AUTHOR("Yiduo Wang");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/sound/soc/iphone/iphone-wm8758-audio.c iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/iphone-wm8758-audio.c
--- linux-2.6.32-orig/sound/soc/iphone/iphone-wm8758-audio.c	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/iphone-wm8758-audio.c	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,793 @@
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/tlv.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <linux/i2c.h>
+
+/*
+ *
+ * FIXME: This is an ugly as sin hack because technically we should implement a proper i2c driver and
+ * use something based off the wm8978. We'd also have to implement the hw_params op on the dai_link and figure
+ * out how to translate our magic numbers here into numbers that codec driver can use.
+ *
+ */
+
+#define RESET       0x00
+#define PWRMGMT1    0x01
+#define PWRMGMT2    0x02
+#define PWRMGMT3    0x03
+#define AINTFCE     0x04
+#define COMPAND     0x05
+#define CLKGEN      0x06
+#define SRATECTRL   0x07
+#define GPIOCTL     0x08
+#define JACKDETECT0 0x09
+#define DACCTRL     0x0a
+#define LDACVOL     0x0b
+#define RDACVOL     0x0c
+#define JACKDETECT1 0x0d
+#define ADCCTL      0x0e
+#define LADCVOL     0x0f
+#define RADCVOL     0x10
+
+#define EQ1         0x12
+#define EQ2         0x13
+#define EQ3         0x14
+#define EQ4         0x15
+#define EQ5         0x16
+#define EQ_GAIN_MASK       0x001f
+#define EQ_CUTOFF_MASK     0x0060
+#define EQ_GAIN_VALUE(x)   (((-x) + 12) & 0x1f)
+#define EQ_CUTOFF_VALUE(x) ((((x) - 1) & 0x03) << 5)
+
+#define CLASSDCTL   0x17
+#define DACLIMIT1   0x18
+#define DACLIMIT2   0x19
+
+#define NOTCH1      0x1b
+#define NOTCH2      0x1c
+#define NOTCH3      0x1d
+#define NOTCH4      0x1e
+
+#define ALCCTL1     0x20
+#define ALCCTL2     0x21
+#define ALCCTL3     0x22
+#define NOISEGATE   0x23
+#define PLLN        0x24
+#define PLLK1       0x25
+#define PLLK2       0x26
+#define PLLK3       0x27
+
+#define THREEDCTL   0x29
+#define OUT4ADC     0x2a
+#define BEEPCTRL    0x2b
+#define INCTRL      0x2c
+#define LINPGAGAIN  0x2d
+#define RINPGAGAIN  0x2e
+#define LADCBOOST   0x2f
+#define RADCBOOST   0x30
+#define OUTCTRL     0x31
+#define LOUTMIX     0x32
+#define ROUTMIX     0x33
+#define LOUT1VOL    0x34
+#define ROUT1VOL    0x35
+#define LOUT2VOL    0x36
+#define ROUT2VOL    0x37
+#define OUT3MIX     0x38
+#define OUT4MIX     0x39
+
+#define BIASCTL     0x3d
+#define WMREG_3E    0x3e
+
+static const u16 wm8978_reg[0x3A] = {
+	0x0000, 0x0000, 0x0000, 0x0000,	/* 0x00...0x03 */
+	0x0050, 0x0000, 0x0140, 0x0000,	/* 0x04...0x07 */
+	0x0000, 0x0000, 0x0000, 0x00ff,	/* 0x08...0x0b */
+	0x00ff, 0x0000, 0x0100, 0x00ff,	/* 0x0c...0x0f */
+	0x00ff, 0x0000, 0x012c, 0x002c,	/* 0x10...0x13 */
+	0x002c, 0x002c, 0x002c, 0x0000,	/* 0x14...0x17 */
+	0x0032, 0x0000, 0x0000, 0x0000,	/* 0x18...0x1b */
+	0x0000, 0x0000, 0x0000, 0x0000,	/* 0x1c...0x1f */
+	0x0038, 0x000b, 0x0032, 0x0000,	/* 0x20...0x23 */
+	0x0008, 0x000c, 0x0093, 0x00e9,	/* 0x24...0x27 */
+	0x0000, 0x0000, 0x0000, 0x0000,	/* 0x28...0x2b */
+	0x0033, 0x0010, 0x0010, 0x0100,	/* 0x2c...0x2f */
+	0x0100, 0x0002, 0x0001, 0x0001,	/* 0x30...0x33 */
+	0x0039, 0x0039, 0x0039, 0x0039,	/* 0x34...0x37 */
+	0x0001,	0x0001,			/* 0x38...0x3b */
+};
+
+static const char *wm8978_companding[] = {"Off", "NC", "u-law", "A-law"};
+static const char *wm8978_eqmode[] = {"Capture", "Playback"};
+static const char *wm8978_bw[] = {"Narrow", "Wide"};
+static const char *wm8978_eq1[] = {"80Hz", "105Hz", "135Hz", "175Hz"};
+static const char *wm8978_eq2[] = {"230Hz", "300Hz", "385Hz", "500Hz"};
+static const char *wm8978_eq3[] = {"650Hz", "850Hz", "1.1kHz", "1.4kHz"};
+static const char *wm8978_eq4[] = {"1.8kHz", "2.4kHz", "3.2kHz", "4.1kHz"};
+static const char *wm8978_eq5[] = {"5.3kHz", "6.9kHz", "9kHz", "11.7kHz"};
+static const char *wm8978_alc3[] = {"ALC", "Limiter"};
+static const char *wm8978_alc1[] = {"Off", "Right", "Left", "Both"};
+
+static const SOC_ENUM_SINGLE_DECL(adc_compand, COMPAND, 1,
+				  wm8978_companding);
+static const SOC_ENUM_SINGLE_DECL(dac_compand, COMPAND, 3,
+				  wm8978_companding);
+static const SOC_ENUM_SINGLE_DECL(eqmode, EQ1, 8, wm8978_eqmode);
+static const SOC_ENUM_SINGLE_DECL(eq1, EQ1, 5, wm8978_eq1);
+static const SOC_ENUM_SINGLE_DECL(eq2bw, EQ2, 8, wm8978_bw);
+static const SOC_ENUM_SINGLE_DECL(eq2, EQ2, 5, wm8978_eq2);
+static const SOC_ENUM_SINGLE_DECL(eq3bw, EQ3, 8, wm8978_bw);
+static const SOC_ENUM_SINGLE_DECL(eq3, EQ3, 5, wm8978_eq3);
+static const SOC_ENUM_SINGLE_DECL(eq4bw, EQ4, 8, wm8978_bw);
+static const SOC_ENUM_SINGLE_DECL(eq4, EQ4, 5, wm8978_eq4);
+static const SOC_ENUM_SINGLE_DECL(eq5, EQ5, 5, wm8978_eq5);
+static const SOC_ENUM_SINGLE_DECL(alc3, ALCCTL3, 8, wm8978_alc3);
+static const SOC_ENUM_SINGLE_DECL(alc1, ALCCTL1, 7, wm8978_alc1);
+
+static const DECLARE_TLV_DB_SCALE(digital_tlv, -12750, 50, 1);
+static const DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
+static const DECLARE_TLV_DB_SCALE(inpga_tlv, -1200, 75, 0);
+static const DECLARE_TLV_DB_SCALE(spk_tlv, -5700, 100, 0);
+static const DECLARE_TLV_DB_SCALE(boost_tlv, -1500, 300, 1);
+
+static int bb_volume_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
+static int bb_volume_set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
+
+static const struct snd_kcontrol_new wm8978_snd_controls[] = {
+
+	SOC_SINGLE("Digital Loopback Switch",
+		COMPAND, 0, 1, 0),
+
+	SOC_ENUM("ADC Companding", adc_compand),
+	SOC_ENUM("DAC Companding", dac_compand),
+
+	SOC_DOUBLE("DAC Inversion Switch", DACCTRL, 0, 1, 1, 0),
+
+	SOC_DOUBLE_R_TLV("PCM Volume",
+		LDACVOL, RDACVOL,
+		0, 255, 0, digital_tlv),
+
+	SOC_SINGLE("High Pass Filter Switch", ADCCTL, 8, 1, 0),
+	SOC_SINGLE("High Pass Cut Off", ADCCTL, 4, 7, 0),
+	SOC_DOUBLE("ADC Inversion Switch", ADCCTL, 0, 1, 1, 0),
+
+	SOC_DOUBLE_R_TLV("ADC Volume",
+		LADCVOL, RADCVOL,
+		0, 255, 0, digital_tlv),
+
+	SOC_ENUM("Equaliser Function", eqmode),
+	SOC_ENUM("EQ1 Cut Off", eq1),
+	SOC_SINGLE_TLV("EQ1 Volume", EQ1,  0, 24, 1, eq_tlv),
+
+	SOC_ENUM("Equaliser EQ2 Bandwith", eq2bw),
+	SOC_ENUM("EQ2 Cut Off", eq2),
+	SOC_SINGLE_TLV("EQ2 Volume", EQ2,  0, 24, 1, eq_tlv),
+
+	SOC_ENUM("Equaliser EQ3 Bandwith", eq3bw),
+	SOC_ENUM("EQ3 Cut Off", eq3),
+	SOC_SINGLE_TLV("EQ3 Volume", EQ3,  0, 24, 1, eq_tlv),
+
+	SOC_ENUM("Equaliser EQ4 Bandwith", eq4bw),
+	SOC_ENUM("EQ4 Cut Off", eq4),
+	SOC_SINGLE_TLV("EQ4 Volume", EQ4,  0, 24, 1, eq_tlv),
+
+	SOC_ENUM("EQ5 Cut Off", eq5),
+	SOC_SINGLE_TLV("EQ5 Volume", EQ5, 0, 24, 1, eq_tlv),
+
+	SOC_SINGLE("DAC Playback Limiter Switch",
+		DACLIMIT1, 8, 1, 0),
+	SOC_SINGLE("DAC Playback Limiter Decay",
+		DACLIMIT1, 4, 15, 0),
+	SOC_SINGLE("DAC Playback Limiter Attack",
+		DACLIMIT1, 0, 15, 0),
+
+	SOC_SINGLE("DAC Playback Limiter Threshold",
+		DACLIMIT2, 4, 7, 0),
+	SOC_SINGLE("DAC Playback Limiter Boost",
+		DACLIMIT2, 0, 15, 0),
+
+	SOC_ENUM("ALC Enable Switch", alc1),
+	SOC_SINGLE("ALC Capture Min Gain", ALCCTL1, 0, 7, 0),
+	SOC_SINGLE("ALC Capture Max Gain", ALCCTL1, 3, 7, 0),
+
+	SOC_SINGLE("ALC Capture Hold", ALCCTL2, 4, 7, 0),
+	SOC_SINGLE("ALC Capture Target", ALCCTL2, 0, 15, 0),
+
+	SOC_ENUM("ALC Capture Mode", alc3),
+	SOC_SINGLE("ALC Capture Decay", ALCCTL3, 4, 15, 0),
+	SOC_SINGLE("ALC Capture Attack", ALCCTL3, 0, 15, 0),
+
+	SOC_SINGLE("ALC Capture Noise Gate Switch", NOISEGATE, 3, 1, 0),
+	SOC_SINGLE("ALC Capture Noise Gate Threshold",
+		NOISEGATE, 0, 7, 0),
+
+	SOC_DOUBLE_R("Capture PGA ZC Switch",
+		LINPGAGAIN, RINPGAGAIN,
+		7, 1, 0),
+
+	/* OUT1 - Headphones */
+	SOC_DOUBLE_R("Headphone Playback ZC Switch",
+		LOUT1VOL, ROUT1VOL, 7, 1, 0),
+
+	SOC_DOUBLE_R_TLV("Headphone Playback Volume",
+		LOUT1VOL, ROUT1VOL,
+		0, 63, 0, spk_tlv),
+
+	/* OUT2 */
+	SOC_DOUBLE_R("OUT2 Playback ZC Switch",
+		LOUT2VOL, ROUT2VOL, 7, 1, 0),
+
+	SOC_DOUBLE_R_TLV("OUT2 Playback Volume",
+		LOUT2VOL, ROUT2VOL,
+		0, 63, 0, spk_tlv),
+
+	/* OUT3/4 - Line Output */
+	SOC_DOUBLE_R("Line Playback Switch",
+		OUT3MIX, OUT4MIX, 6, 1, 1),
+
+	/* Mixer #3: Boost (Input) mixer */
+	SOC_DOUBLE_R("PGA Boost (+20dB)",
+		LADCBOOST, RADCBOOST,
+		8, 1, 0),
+	SOC_DOUBLE_R_TLV("L2/R2 Boost Volume",
+		LADCBOOST, RADCBOOST,
+		4, 7, 0, boost_tlv),
+	SOC_DOUBLE_R_TLV("Aux Boost Volume",
+		LADCBOOST, RADCBOOST,
+		0, 7, 0, boost_tlv),
+
+	/* Input PGA volume */
+	SOC_DOUBLE_R_TLV("Input PGA Volume",
+		LINPGAGAIN, RINPGAGAIN,
+		0, 63, 0, inpga_tlv),
+
+	/* Headphone */
+	SOC_DOUBLE_R("Headphone Switch",
+		LOUT1VOL, ROUT1VOL, 6, 1, 1),
+
+	/* OUT2 */
+	SOC_DOUBLE_R("OUT2 Switch",
+		LOUT2VOL, ROUT2VOL, 6, 1, 1),
+
+	/* DAC / ADC oversampling */
+	SOC_SINGLE("DAC 128x Oversampling Switch", DACCTRL, 8, 1, 0),
+	SOC_SINGLE("ADC 128x Oversampling Switch", ADCCTL, 8, 1, 0),
+
+	SOC_SINGLE_EXT("Speaker 1 Volume", 2, 0, 100, 0, bb_volume_get, bb_volume_set),
+	SOC_SINGLE_EXT("Speaker 2 Volume", 0, 0, 100, 0, bb_volume_get, bb_volume_set),
+};
+
+/* Mixer #1: Output (OUT1, OUT2) Mixer: mix AUX, Input mixer output and DAC */
+static const struct snd_kcontrol_new wm8978_left_out_mixer[] = {
+	SOC_DAPM_SINGLE("Line Bypass Switch", LOUTMIX, 1, 1, 0),
+	SOC_DAPM_SINGLE("Aux Playback Switch", LOUTMIX, 5, 1, 0),
+	SOC_DAPM_SINGLE("PCM Playback Switch", LOUTMIX, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new wm8978_right_out_mixer[] = {
+	SOC_DAPM_SINGLE("Line Bypass Switch", ROUTMIX, 1, 1, 0),
+	SOC_DAPM_SINGLE("Aux Playback Switch", ROUTMIX, 5, 1, 0),
+	SOC_DAPM_SINGLE("PCM Playback Switch", ROUTMIX, 0, 1, 0),
+};
+
+/* OUT3/OUT4 Mixer not implemented */
+
+/* Mixer #2: Input PGA Mute */
+static const struct snd_kcontrol_new wm8978_left_input_mixer[] = {
+	SOC_DAPM_SINGLE("L2 Switch", INCTRL, 2, 1, 0),
+	SOC_DAPM_SINGLE("MicN Switch", INCTRL, 1, 1, 0),
+	SOC_DAPM_SINGLE("MicP Switch", INCTRL, 0, 1, 0),
+};
+static const struct snd_kcontrol_new wm8978_right_input_mixer[] = {
+	SOC_DAPM_SINGLE("R2 Switch", INCTRL, 6, 1, 0),
+	SOC_DAPM_SINGLE("MicN Switch", INCTRL, 5, 1, 0),
+	SOC_DAPM_SINGLE("MicP Switch", INCTRL, 4, 1, 0),
+};
+
+static const struct snd_soc_dapm_widget wm8978_dapm_widgets[] = {
+	SND_SOC_DAPM_DAC("Left DAC", "Left HiFi Playback",
+			 PWRMGMT3, 0, 0),
+	SND_SOC_DAPM_DAC("Right DAC", "Right HiFi Playback",
+			 PWRMGMT3, 1, 0),
+	SND_SOC_DAPM_ADC("Left ADC", "Left HiFi Capture",
+			 PWRMGMT2, 0, 0),
+	SND_SOC_DAPM_ADC("Right ADC", "Right HiFi Capture",
+			 PWRMGMT2, 1, 0),
+
+	/* Mixer #1: OUT1,2 */
+	SOC_MIXER_ARRAY("Left Output Mixer", PWRMGMT3,
+			2, 0, wm8978_left_out_mixer),
+	SOC_MIXER_ARRAY("Right Output Mixer", PWRMGMT3,
+			3, 0, wm8978_right_out_mixer),
+
+	SOC_MIXER_ARRAY("Left Input Mixer", PWRMGMT2,
+			2, 0, wm8978_left_input_mixer),
+	SOC_MIXER_ARRAY("Right Input Mixer", PWRMGMT2,
+			3, 0, wm8978_right_input_mixer),
+
+	SND_SOC_DAPM_PGA("Left Boost Mixer", PWRMGMT2,
+			 4, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Boost Mixer", PWRMGMT2,
+			 5, 0, NULL, 0),
+
+	SND_SOC_DAPM_PGA("Left Capture PGA", LINPGAGAIN,
+			 6, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Capture PGA", RINPGAGAIN,
+			 6, 1, NULL, 0),
+
+	SND_SOC_DAPM_PGA("Left Headphone Out", PWRMGMT2,
+			 7, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Headphone Out", PWRMGMT2,
+			 8, 0, NULL, 0),
+
+	SND_SOC_DAPM_PGA("Left OUT2 Out", PWRMGMT3,
+			 6, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right OUT2 Out", PWRMGMT3,
+			 5, 0, NULL, 0),
+
+	SND_SOC_DAPM_MIXER("OUT4 VMID", PWRMGMT3,
+			   8, 0, NULL, 0),
+
+	SND_SOC_DAPM_MICBIAS("Mic Bias", PWRMGMT1, 4, 0),
+
+	SND_SOC_DAPM_INPUT("LMICN"),
+	SND_SOC_DAPM_INPUT("LMICP"),
+	SND_SOC_DAPM_INPUT("RMICN"),
+	SND_SOC_DAPM_INPUT("RMICP"),
+	SND_SOC_DAPM_INPUT("LAUX"),
+	SND_SOC_DAPM_INPUT("RAUX"),
+	SND_SOC_DAPM_INPUT("L2"),
+	SND_SOC_DAPM_INPUT("R2"),
+	SND_SOC_DAPM_OUTPUT("LHP"),
+	SND_SOC_DAPM_OUTPUT("RHP"),
+	SND_SOC_DAPM_OUTPUT("LOUT2"),
+	SND_SOC_DAPM_OUTPUT("ROUT2"),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	/* Output mixer */
+	{"Right Output Mixer", "PCM Playback Switch", "Right DAC"},
+	{"Right Output Mixer", "Aux Playback Switch", "RAUX"},
+	{"Right Output Mixer", "Line Bypass Switch", "Right Boost Mixer"},
+
+	{"Left Output Mixer", "PCM Playback Switch", "Left DAC"},
+	{"Left Output Mixer", "Aux Playback Switch", "LAUX"},
+	{"Left Output Mixer", "Line Bypass Switch", "Left Boost Mixer"},
+
+	/* Outputs */
+	{"Right Headphone Out", NULL, "Right Output Mixer"},
+	{"RHP", NULL, "Right Headphone Out"},
+
+	{"Left Headphone Out", NULL, "Left Output Mixer"},
+	{"LHP", NULL, "Left Headphone Out"},
+
+	{"Right OUT2 Out", NULL, "Right Output Mixer"},
+	{"ROUT2", NULL, "Right OUT2 Out"},
+
+	{"Left OUT2 Out", NULL, "Left Output Mixer"},
+	{"LOUT2", NULL, "Left OUT2 Out"},
+
+	/* Boost Mixer */
+	{"Right ADC", NULL, "Right Boost Mixer"},
+
+	{"Right Boost Mixer", NULL, "RAUX"},
+	{"Right Boost Mixer", NULL, "Right Capture PGA"},
+	{"Right Boost Mixer", NULL, "R2"},
+
+	{"Left ADC", NULL, "Left Boost Mixer"},
+
+	{"Left Boost Mixer", NULL, "LAUX"},
+	{"Left Boost Mixer", NULL, "Left Capture PGA"},
+	{"Left Boost Mixer", NULL, "L2"},
+
+	/* Input PGA */
+	{"Right Capture PGA", NULL, "Right Input Mixer"},
+	{"Left Capture PGA", NULL, "Left Input Mixer"},
+
+	{"Right Input Mixer", "R2 Switch", "R2"},
+	{"Right Input Mixer", "MicN Switch", "RMICN"},
+	{"Right Input Mixer", "MicP Switch", "RMICP"},
+
+	{"Left Input Mixer", "L2 Switch", "L2"},
+	{"Left Input Mixer", "MicN Switch", "LMICN"},
+	{"Left Input Mixer", "MicP Switch", "LMICP"},
+};
+
+static const int update_reg[] = {
+	LDACVOL,
+	RDACVOL,
+	LADCVOL,
+	RADCVOL,
+	LINPGAGAIN,
+	RINPGAGAIN,
+	LOUT1VOL,
+	ROUT1VOL,
+	LOUT1VOL,
+	ROUT1VOL
+};
+
+static struct iphone_wm8758_priv {
+	unsigned int sysclk;
+	struct snd_soc_codec codec;
+	struct snd_pcm_hw_constraint_list *sysclk_constraints;
+	u16 reg_cache[0x40];
+	u16 bb_volume_cache[10];
+} priv;
+
+static int bb_volume_set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc = (struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct iphone_wm8758_priv* priv = (struct iphone_wm8758_priv*) codec->private_data;
+	int val;
+
+	if(ucontrol->value.integer.value[0] > mc->max)
+		val = mc->max;
+	else
+		val = ucontrol->value.integer.value[0];
+
+	priv->bb_volume_cache[mc->reg] = val;
+
+	// TODO
+	dev_info(codec->dev, "TODO: set baseband volume %d to %d\n", mc->reg, val);
+
+	return 0;
+}
+
+static int bb_volume_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc = (struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct iphone_wm8758_priv* priv = (struct iphone_wm8758_priv*) codec->private_data;
+
+	ucontrol->value.integer.value[0] = priv->bb_volume_cache[mc->reg];
+
+	return 0;
+}
+
+static int wm8978_add_widgets(struct snd_soc_codec *codec)
+{
+	snd_soc_dapm_new_controls(codec, wm8978_dapm_widgets,
+				  ARRAY_SIZE(wm8978_dapm_widgets));
+
+	/* set up the WM8978 audio map */
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+
+	return 0;
+}
+
+static int iphone_wm8758_pcm_startup(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	dev_info(codec->dev, "ENTER iphone_wm8758_pcm_startup\n");
+	return 0;
+}
+
+
+static int iphone_wm8758_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	dev_info(codec->dev, "ENTER iphone_wm8758_pcm_hw_params\n");
+	return 0;
+}
+
+static int iphone_wm8758_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+
+	dev_info(codec->dev, "ENTER iphone_wm8758_set_dai_fmt %u\n", fmt);
+	return 0;
+}
+
+static int iphone_wm8758_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+
+	dev_info(codec->dev, "ENTER iphone_wm8758_set_dai_sysclk %d %u %d\n", clk_id, freq, dir);
+	return 0;
+}
+
+static int iphone_wm8758_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	dev_info(codec->dev, "ENTER iphone_wm8758_mute\n");
+
+	if (mute)
+		snd_soc_update_bits(codec, DACCTRL, 0x40, 0x40);
+	else
+		snd_soc_update_bits(codec, DACCTRL, 0x40, 0);
+
+	return 0;
+}
+
+static struct snd_soc_dai_ops iphone_wm8758_dai_ops = {
+	.startup = iphone_wm8758_pcm_startup,
+	.hw_params = iphone_wm8758_pcm_hw_params,
+	.set_fmt = iphone_wm8758_set_dai_fmt,
+	.set_sysclk = iphone_wm8758_set_dai_sysclk,
+	.digital_mute = iphone_wm8758_mute,
+};
+
+struct snd_soc_dai iphone_wm8758_dai = {
+	.name = "wm8758",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	 },
+	.ops = &iphone_wm8758_dai_ops,
+	.symmetric_rates = 1,
+};
+
+
+static int iphone_wm8758_register(void)
+{
+	int ret;
+	int i;
+
+	struct snd_soc_codec *codec = &priv.codec;
+
+	pr_debug("ENTER iphone_wm8758_audio_probe\n");
+
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	codec->private_data = &priv;
+	codec->name = "wm8758";
+	codec->owner = THIS_MODULE;
+	codec->dai = &iphone_wm8758_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = ARRAY_SIZE(priv.reg_cache);
+	codec->reg_cache = &priv.reg_cache;
+
+	iphone_wm8758_dai.dev = codec->dev;
+
+	memcpy(codec->reg_cache, wm8978_reg, sizeof(wm8978_reg));
+
+	ret = snd_soc_codec_set_cache_io(codec, 7, 9, SND_SOC_I2C);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+		goto err;
+	}
+
+	ret = snd_soc_register_codec(codec);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to register codec: %d\n", ret);
+		goto err;
+	}
+
+	ret = snd_soc_register_dai(&iphone_wm8758_dai);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to register DAI: %d\n", ret);
+		snd_soc_unregister_codec(codec);
+		goto err_codec;
+	}
+
+	priv.bb_volume_cache[2] = 100;
+	priv.bb_volume_cache[0] = 68;
+
+	snd_soc_write(codec, RESET,    0x1ff);    /* Reset */
+
+	snd_soc_write(codec, LOUT1VOL, 0xc0);
+	snd_soc_write(codec, ROUT1VOL, 0x1c0);
+	snd_soc_write(codec, LOUT2VOL, 0xb9);
+	snd_soc_write(codec, ROUT2VOL, 0x1b9);
+
+	snd_soc_write(codec, BIASCTL,  0x100); /* BIASCUT = 1 */
+
+	snd_soc_write(codec, PWRMGMT1, 0x2d);   /* BIASEN = 1, PLLEN = 1, BUFIOEN = 1, VMIDSEL = 1 */
+	snd_soc_write(codec, PWRMGMT2, 0x180);
+	snd_soc_write(codec, PWRMGMT3, 0x6f);
+
+	snd_soc_write(codec, AINTFCE, 0x10);   /* 16-bit, I2S format */
+
+	snd_soc_write(codec, COMPAND, 0x0);
+	snd_soc_write(codec, CLKGEN, 0x14d);
+	snd_soc_write(codec, SRATECTRL, 0x0);
+	snd_soc_write(codec, GPIOCTL, 0x0);
+	snd_soc_write(codec, JACKDETECT0, 0x0);
+
+	snd_soc_write(codec, DACCTRL,  0x3);
+	snd_soc_write(codec, LDACVOL,  0xff);
+	snd_soc_write(codec, RDACVOL,  0x1ff);
+
+	snd_soc_write(codec, JACKDETECT1, 0x0);
+
+	snd_soc_write(codec, ADCCTL, 0x0);
+	snd_soc_write(codec, LADCVOL, 0xff);
+	snd_soc_write(codec, RADCVOL, 0xff);
+
+	snd_soc_write(codec, EQ1, 0x12c);
+	snd_soc_write(codec, EQ2, 0x2c);
+	snd_soc_write(codec, EQ3, 0x2c);
+	snd_soc_write(codec, EQ4, 0x2c);
+	snd_soc_write(codec, EQ5, 0x2c);
+
+	snd_soc_write(codec, DACLIMIT1, 0x32);
+	snd_soc_write(codec, DACLIMIT2, 0x0);
+
+	snd_soc_write(codec, NOTCH1, 0x0);
+	snd_soc_write(codec, NOTCH2, 0x0);
+	snd_soc_write(codec, NOTCH3, 0x0);
+	snd_soc_write(codec, NOTCH4, 0x0);
+
+	snd_soc_write(codec, PLLN, 0xa);
+
+	snd_soc_write(codec, PLLK1, 0x1);
+	snd_soc_write(codec, PLLK2, 0x1fd);
+	snd_soc_write(codec, PLLK3, 0x1e8);
+
+	snd_soc_write(codec, THREEDCTL, 0x0);
+	snd_soc_write(codec, OUT4ADC, 0x0);
+	snd_soc_write(codec, BEEPCTRL, 0x0);
+
+	snd_soc_write(codec, INCTRL, 0x0);
+	snd_soc_write(codec, LINPGAGAIN, 0x40);
+	snd_soc_write(codec, RINPGAGAIN, 0x140);
+
+	snd_soc_write(codec, LADCBOOST, 0x0);
+	snd_soc_write(codec, RADCBOOST, 0x0);
+
+	snd_soc_write(codec, OUTCTRL,  0x186);   /* Thermal shutdown, DACL2RMIX = 1, DACR2LMIX = 1, SPKBOOST = 1 */
+	snd_soc_write(codec, LOUTMIX, 0x15);
+	snd_soc_write(codec, ROUTMIX, 0x15);
+
+	snd_soc_write(codec, OUT3MIX,  0x40);
+	snd_soc_write(codec, OUT4MIX,  0x40);
+
+	snd_soc_write(codec, WMREG_3E, 0x8c90);
+
+	for (i = 0; i < ARRAY_SIZE(update_reg); i++)
+		((u16 *)codec->reg_cache)[update_reg[i]] |= 0x100;
+
+	dev_info(codec->dev, "DAI and codec registered\n");
+
+	return 0;
+
+err_codec:
+	snd_soc_unregister_codec(codec);
+err:
+	return ret;
+}
+
+static int iphone_wm8758_unregister(void)
+{
+	struct snd_soc_codec *codec = &priv.codec;
+
+	snd_soc_unregister_dai(&iphone_wm8758_dai);
+	snd_soc_unregister_codec(codec);
+
+	return 0;
+}
+
+static int soc_codec_dev_iphone_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct snd_soc_codec *codec;
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+
+	pr_debug("ENTER soc_codec_dev_iphone_probe\n");
+	socdev->card->codec = &priv.codec;
+	codec = &priv.codec;
+
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		pr_debug(KERN_ERR "iphone-wm8758-audio: failed to create pcms\n");
+		goto pcm_err;
+	}
+
+	snd_soc_add_controls(codec, wm8978_snd_controls,
+			     ARRAY_SIZE(wm8978_snd_controls));
+	wm8978_add_widgets(codec);
+
+	ret = snd_soc_init_card(socdev);
+	if (ret < 0) {
+		printk(KERN_ERR "iphone-wm8758-audio: failed to register card\n");
+		goto card_err;
+	}
+
+	return ret;
+
+card_err:
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+	return ret;
+
+pcm_err:
+	return ret;
+}
+
+static int soc_codec_dev_iphone_remove(struct platform_device *pdev)
+{
+	pr_debug("ENTER soc_codec_dev_iphone_remove\n");
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8758 = {
+	.probe          = soc_codec_dev_iphone_probe,
+	.remove         = soc_codec_dev_iphone_remove,
+};
+
+static int wm8758_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct iphone_wm8758_priv *wm8758;
+	struct snd_soc_codec *codec;
+
+	wm8758 = &priv;
+
+	codec = &wm8758->codec;
+
+	i2c_set_clientdata(i2c, wm8758);
+	codec->control_data = i2c;
+
+	codec->dev = &i2c->dev;
+
+	return iphone_wm8758_register();
+}
+
+static int wm8758_i2c_remove(struct i2c_client *client)
+{
+	struct wm8758_priv *wm8758 = i2c_get_clientdata(client);
+	iphone_wm8758_unregister();
+	return 0;
+}
+
+static const struct i2c_device_id wm8758_i2c_id[] = {
+	{ "wm8758", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, wm8758_i2c_id);
+
+static struct i2c_driver wm8758_i2c_driver = {
+	.driver = {
+		.name = "wm8758",
+		.owner = THIS_MODULE,
+	},
+	.probe = wm8758_i2c_probe,
+	.remove = wm8758_i2c_remove,
+	.id_table = wm8758_i2c_id,
+};
+
+static int __init wm8758_modinit(void)
+{
+	int ret;
+
+	ret = i2c_add_driver(&wm8758_i2c_driver);
+	if (ret != 0)
+		pr_err("WM8758: Unable to register I2C driver: %d\n", ret);
+	return ret;
+}
+module_init(wm8758_modinit);
+
+static void __exit wm8758_exit(void)
+{
+	i2c_del_driver(&wm8758_i2c_driver);
+}
+module_exit(wm8758_exit);
+
+
+MODULE_DESCRIPTION("ASoC WM8758 driver");
+MODULE_AUTHOR("Mark Brown <broonie@opensource.wolfsonmicro.com>");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.32-orig/sound/soc/iphone/Kconfig iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/Kconfig
--- linux-2.6.32-orig/sound/soc/iphone/Kconfig	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,4 @@
+config SND_APPLE_IPHONE
+	tristate "Audio for the Apple iPhone"
+	select SND_SOC_WM8991 if IPHONE_3G
+	depends on MACH_APPLE_IPHONE
diff -Nur linux-2.6.32-orig/sound/soc/iphone/Makefile iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/Makefile
--- linux-2.6.32-orig/sound/soc/iphone/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/iphone/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -0,0 +1,3 @@
+# PXA Platform Support
+
+obj-$(CONFIG_SND_APPLE_IPHONE) += iphone-i2s-dma.o iphone-i2s.o iphone-wm8758-audio.o iphone-bb-audio.o iphone-sound.o
diff -Nur linux-2.6.32-orig/sound/soc/Kconfig iDroid-Project-kernel_common-9e90fd2/sound/soc/Kconfig
--- linux-2.6.32-orig/sound/soc/Kconfig	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/Kconfig	2010-11-18 21:05:30.000000000 +0600
@@ -36,6 +36,7 @@
 source "sound/soc/s6000/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/txx9/Kconfig"
+source "sound/soc/iphone/Kconfig"
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
diff -Nur linux-2.6.32-orig/sound/soc/Makefile iDroid-Project-kernel_common-9e90fd2/sound/soc/Makefile
--- linux-2.6.32-orig/sound/soc/Makefile	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/soc/Makefile	2010-11-18 21:05:30.000000000 +0600
@@ -14,3 +14,4 @@
 obj-$(CONFIG_SND_SOC)	+= s6000/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= txx9/
+obj-$(CONFIG_SND_SOC)	+= iphone/
diff -Nur linux-2.6.32-orig/sound/usb/usbaudio.c iDroid-Project-kernel_common-9e90fd2/sound/usb/usbaudio.c
--- linux-2.6.32-orig/sound/usb/usbaudio.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/sound/usb/usbaudio.c	2010-11-18 21:05:30.000000000 +0600
@@ -752,7 +752,7 @@
 			return 0; /* already large enough */
 		vfree(runtime->dma_area);
 	}
-	runtime->dma_area = vmalloc(size);
+	runtime->dma_area = vmalloc_user(size);
 	if (!runtime->dma_area)
 		return -ENOMEM;
 	runtime->dma_bytes = size;
@@ -1936,7 +1936,7 @@
 	struct snd_usb_stream *as = snd_pcm_substream_chip(substream);
 	struct snd_usb_substream *subs = &as->substream[direction];
 
-	if (subs->interface >= 0) {
+	if (!as->chip->shutdown && subs->interface >= 0) {
 		usb_set_interface(subs->dev, subs->interface, 0);
 		subs->interface = -1;
 	}
diff -Nur linux-2.6.32-orig/tools/perf/builtin-timechart.c iDroid-Project-kernel_common-9e90fd2/tools/perf/builtin-timechart.c
--- linux-2.6.32-orig/tools/perf/builtin-timechart.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/tools/perf/builtin-timechart.c	2010-11-18 21:05:30.000000000 +0600
@@ -275,7 +275,7 @@
 static int
 process_comm_event(event_t *event)
 {
-	pid_set_comm(event->comm.pid, event->comm.comm);
+	pid_set_comm(event->comm.tid, event->comm.comm);
 	return 0;
 }
 static int
diff -Nur linux-2.6.32-orig/virt/kvm/eventfd.c iDroid-Project-kernel_common-9e90fd2/virt/kvm/eventfd.c
--- linux-2.6.32-orig/virt/kvm/eventfd.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/virt/kvm/eventfd.c	2010-11-18 21:05:30.000000000 +0600
@@ -168,7 +168,7 @@
 static int
 kvm_irqfd_assign(struct kvm *kvm, int fd, int gsi)
 {
-	struct _irqfd *irqfd;
+	struct _irqfd *irqfd, *tmp;
 	struct file *file = NULL;
 	struct eventfd_ctx *eventfd = NULL;
 	int ret;
@@ -205,9 +205,20 @@
 	init_waitqueue_func_entry(&irqfd->wait, irqfd_wakeup);
 	init_poll_funcptr(&irqfd->pt, irqfd_ptable_queue_proc);
 
+	spin_lock_irq(&kvm->irqfds.lock);
+
+	ret = 0;
+	list_for_each_entry(tmp, &kvm->irqfds.items, list) {
+		if (irqfd->eventfd != tmp->eventfd)
+			continue;
+		/* This fd is used for another irq already. */
+		ret = -EBUSY;
+		spin_unlock_irq(&kvm->irqfds.lock);
+		goto fail;
+	}
+
 	events = file->f_op->poll(file, &irqfd->pt);
 
-	spin_lock_irq(&kvm->irqfds.lock);
 	list_add_tail(&irqfd->list, &kvm->irqfds.items);
 	spin_unlock_irq(&kvm->irqfds.lock);
 
diff -Nur linux-2.6.32-orig/virt/kvm/irq_comm.c iDroid-Project-kernel_common-9e90fd2/virt/kvm/irq_comm.c
--- linux-2.6.32-orig/virt/kvm/irq_comm.c	2009-12-03 09:51:21.000000000 +0600
+++ iDroid-Project-kernel_common-9e90fd2/virt/kvm/irq_comm.c	2010-11-18 21:05:30.000000000 +0600
@@ -205,16 +205,17 @@
 	int irq_source_id;
 
 	mutex_lock(&kvm->irq_lock);
-	irq_source_id = find_first_zero_bit(bitmap,
-				sizeof(kvm->arch.irq_sources_bitmap));
+	irq_source_id = find_first_zero_bit(bitmap, BITS_PER_LONG);
 
-	if (irq_source_id >= sizeof(kvm->arch.irq_sources_bitmap)) {
+	if (irq_source_id >= BITS_PER_LONG) {
 		printk(KERN_WARNING "kvm: exhaust allocatable IRQ sources!\n");
-		return -EFAULT;
+		irq_source_id = -EFAULT;
+		goto unlock;
 	}
 
 	ASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);
 	set_bit(irq_source_id, bitmap);
+unlock:
 	mutex_unlock(&kvm->irq_lock);
 
 	return irq_source_id;
@@ -228,13 +229,17 @@
 
 	mutex_lock(&kvm->irq_lock);
 	if (irq_source_id < 0 ||
-	    irq_source_id >= sizeof(kvm->arch.irq_sources_bitmap)) {
+	    irq_source_id >= BITS_PER_LONG) {
 		printk(KERN_ERR "kvm: IRQ source ID out of range!\n");
-		return;
+		goto unlock;
 	}
+	clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+	if (!irqchip_in_kernel(kvm))
+		goto unlock;
+
 	for (i = 0; i < KVM_IOAPIC_NUM_PINS; i++)
 		clear_bit(irq_source_id, &kvm->arch.irq_states[i]);
-	clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+unlock:
 	mutex_unlock(&kvm->irq_lock);
 }
 
