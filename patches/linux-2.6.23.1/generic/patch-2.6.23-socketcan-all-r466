---
 CREDITS                             |   16 
 MAINTAINERS                         |    9 
 drivers/net/Makefile                |    1 
 drivers/net/can/Kconfig             |   97 +
 drivers/net/can/Makefile            |   29 
 drivers/net/can/ccan/Makefile       |   58 +
 drivers/net/can/ccan/ccan.c         |  566 +++++++++++
 drivers/net/can/ccan/ccan.h         |  140 ++
 drivers/net/can/ccan/h7202_can.c    |  200 ++++
 drivers/net/can/hal/c200.c          |  207 ++++
 drivers/net/can/hal/esdio.c         |  186 +++
 drivers/net/can/hal/gw2.c           |  162 +++
 drivers/net/can/hal/hal.h           |  100 ++
 drivers/net/can/hal/io.c            |  124 ++
 drivers/net/can/hal/iomem.c         |  143 ++
 drivers/net/can/hal/iomux.c         |  126 ++
 drivers/net/can/hal/pc7io.c         |  127 ++
 drivers/net/can/i82527/Makefile     |   62 +
 drivers/net/can/i82527/i82527.c     | 1285 ++++++++++++++++++++++++++
 drivers/net/can/i82527/i82527.h     |  302 ++++++
 drivers/net/can/i82527/proc.c       |  211 ++++
 drivers/net/can/mscan/Makefile      |   59 +
 drivers/net/can/mscan/mpc52xx_can.c |  241 ++++
 drivers/net/can/mscan/mscan.c       |  703 ++++++++++++++
 drivers/net/can/mscan/mscan.h       |  247 +++++
 drivers/net/can/sja1000/Makefile    |   66 +
 drivers/net/can/sja1000/proc.c      |  232 ++++
 drivers/net/can/sja1000/sja1000.c   | 1173 ++++++++++++++++++++++++
 drivers/net/can/sja1000/sja1000.h   |  189 +++
 drivers/net/can/slcan.c             |  908 ++++++++++++++++++
 drivers/net/can/vcan.c              |  261 +++++
 include/linux/can.h                 |  113 ++
 include/linux/can/bcm.h             |   65 +
 include/linux/can/core.h            |   78 +
 include/linux/can/dev.h             |   59 +
 include/linux/can/error.h           |   93 +
 include/linux/can/ioctl.h           |  149 +++
 include/linux/can/raw.h             |   31 
 include/linux/if_arp.h              |    1 
 include/linux/if_ether.h            |    1 
 include/linux/socket.h              |    2 
 include/linux/tty.h                 |    3 
 net/Kconfig                         |    1 
 net/Makefile                        |    1 
 net/can/Kconfig                     |   82 +
 net/can/Makefile                    |   71 +
 net/can/af_can.c                    |  995 ++++++++++++++++++++
 net/can/af_can.h                    |  121 ++
 net/can/bcm.c                       | 1757 ++++++++++++++++++++++++++++++++++++
 net/can/dev.c                       |  275 +++++
 net/can/proc.c                      |  531 ++++++++++
 net/can/raw.c                       |  763 +++++++++++++++
 52 files changed, 13421 insertions(+), 1 deletion(-)

Index: CREDITS
===================================================================
--- CREDITS.orig
+++ CREDITS
@@ -1331,6 +1331,14 @@ S: Gen Stedmanstraat 212
 S: 5623 HZ Eindhoven
 S: The Netherlands
 
+N: Oliver Hartkopp
+E: oliver.hartkopp@volkswagen.de
+W: http://www.volkswagen.de
+D: Controller Area Network (network layer core)
+S: Brieffach 1776
+S: 38436 Wolfsburg
+S: Germany 
+
 N: Andrew Haylett
 E: ajh@primag.co.uk
 D: Selection mechanism
@@ -3284,6 +3292,14 @@ S: Universit=E9 de Rennes I
 S: F-35042 Rennes Cedex
 S: France
 
+N: Urs Thuermann
+E: urs.thuermann@volkswagen.de
+W: http://www.volkswagen.de
+D: Controller Area Network (network layer core)
+S: Brieffach 1776
+S: 38436 Wolfsburg
+S: Germany 
+
 N: Jon Tombs
 E: jon@gte.esi.us.es
 W: http://www.esi.us.es/~jon
Index: MAINTAINERS
===================================================================
--- MAINTAINERS.orig
+++ MAINTAINERS
@@ -967,6 +967,15 @@ M:	corbet@lwn.net
 L:	video4linux-list@redhat.com
 S:	Maintained
 
+CAN NETWORK LAYER
+P:	Urs Thuermann
+M:	urs.thuermann@volkswagen.de
+P:	Oliver Hartkopp
+M:	oliver.hartkopp@volkswagen.de
+L:	socketcan-core@lists.berlios.de
+W:	http://developer.berlios.de/projects/socketcan/
+S:	Maintained
+
 CALGARY x86-64 IOMMU
 P:	Muli Ben-Yehuda
 M:	muli@il.ibm.com
Index: drivers/net/Makefile
===================================================================
--- drivers/net/Makefile.orig
+++ drivers/net/Makefile
@@ -8,6 +8,7 @@ obj-$(CONFIG_IXGB) += ixgb/
 obj-$(CONFIG_CHELSIO_T1) += chelsio/
 obj-$(CONFIG_CHELSIO_T3) += cxgb3/
 obj-$(CONFIG_EHEA) += ehea/
+obj-$(CONFIG_CAN) += can/
 obj-$(CONFIG_BONDING) += bonding/
 obj-$(CONFIG_ATL1) += atl1/
 obj-$(CONFIG_GIANFAR) += gianfar_driver.o
Index: drivers/net/can/Kconfig
===================================================================
--- /dev/null
+++ drivers/net/can/Kconfig
@@ -0,0 +1,97 @@
+menu "CAN Device Drivers"
+	depends on CAN
+
+config CAN_VCAN
+	tristate "Virtual Local CAN Interface (vcan)"
+ 	depends on CAN
+	default N
+ 	---help---
+	  Similar to the network loopback devices, vcan offers a
+	  virtual local CAN interface.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called vcan.
+
+config CAN_SLCAN
+	tristate "Serial / USB serial CAN Adaptors (slcan)"
+	depends on CAN
+	default N
+	---help---
+	  CAN driver for several 'low cost' CAN interfaces that are attached
+	  via serial lines or via USB-to-serial adapters using the LAWICEL
+	  ASCII protocol. The driver implements the tty linediscipline N_SLCAN.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called slcan.
+
+config CAN_DEBUG_DEVICES
+	bool "CAN devices debugging messages"
+	depends on CAN
+	default N
+	---help---
+	  Say Y here if you want the CAN device drivers to produce a bunch of
+	  debug messages to the system log.  Select this if you are having
+	  a problem with CAN support and want to see more of what is going
+	  on.
+
+config CAN_SJA1000
+	depends on CAN
+	tristate "Philips SJA1000"
+	---help---
+	  The SJA1000 is one of the top CAN controllers out there. As it
+	  has a multiplexed interface it fits directly to 8051
+	  microcontrollers or into the PC I/O port space. The SJA1000
+	  is a full CAN controller, with shadow registers for RX and TX.
+	  It can send and receive any kinds of CAN frames (SFF/EFF/RTR)
+	  with a single (simple) filter setup.
+
+config CAN_I82527
+	depends on CAN
+	tristate "Intel 82527"
+	---help---
+	  The i82527 is a complex CAN controller that can handle RTR
+	  frame replies on it's own. This feature (and diffent RX filters)  
+	  lead to an amount of 15 message objects (for RX & TX). Message
+	  object 15 has (as only) a shadow register for a reliable
+	  receiption of EFF or(!) SFF frames at high CAN traffic.
+	  This driver can send each type of CAN frames (SFF/EFF/RTR).
+	  Using 4 message objects it can also receive each type of CAN
+	  frames. But due to the onchip filter matching trigger method
+	  it is not possible to determine the received RTR CAN-ID.
+	  The reliable message object 15 receives SFF frames by default.
+	  This message object 15 usage maybe changed with the mo15 param.
+
+config CAN_MSCAN
+	depends on CAN && (PPC || M68K || M68KNOMMU)
+	tristate "Support for a Freescale MSCAN based chips"
+	---help---
+	  The Motorola Scalable Controller Area Network (MSCAN) definition
+	  is based on the MSCAN12 definition which is the specific
+	  implementation of the Motorola Scalable CAN concept targeted for
+	  the Motorola MC68HC12 Microcontroller Family.
+
+config CAN_MPC52XX
+	tristate "Freescale MPC5200 onboard CAN controller"
+	depends on CAN_MSCAN && (PPC_MPC52xx || PPC_52xx)
+	default LITE5200
+	---help---
+	  If you say yes here you get support for Freescale MPC5200
+	  onboard dualCAN controller.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called mpc52xx_can.
+
+config CAN_CCAN
+	depends on CAN
+	tristate "Bosch CCAN driver"
+	---help---
+	  This is a driver for the Bosch CCAN controller found for example
+	  on the hynix h7202 chip.
+
+config CAN_H7202
+	tristate "Hynix H7202 onboard CAN controller"
+	depends on CAN_CCAN
+	---help---
+	  This is a driver for the hynix h7202 can controller.
+
+endmenu
Index: drivers/net/can/Makefile
===================================================================
--- /dev/null
+++ drivers/net/can/Makefile
@@ -0,0 +1,29 @@
+#
+#
+
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../..
+
+export CONFIG_CAN_VCAN=m
+export CONFIG_CAN_SJA1000=m
+export CONFIG_CAN_I82527=m
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+obj-$(CONFIG_CAN_VCAN)		+= vcan.o
+obj-$(CONFIG_CAN_SLCAN)		+= slcan.o
+obj-$(CONFIG_CAN_SJA1000)	+= sja1000/
+obj-$(CONFIG_CAN_I82527)	+= i82527/
+obj-$(CONFIG_CAN_MSCAN)		+= mscan/
+obj-$(CONFIG_CAN_CCAN)		+= ccan/
+
+endif
Index: drivers/net/can/ccan/Makefile
===================================================================
--- /dev/null
+++ drivers/net/can/ccan/Makefile
@@ -0,0 +1,58 @@
+#
+#
+#  Copyright (c) 2007 intefo AG
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#  1. Redistributions of source code must retain the above copyright
+#     notice, this list of conditions, the following disclaimer and
+#     the referenced file 'COPYING'.
+#  2. Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#  3. Neither the name of Volkswagen nor the names of its contributors
+#     may be used to endorse or promote products derived from this software
+#     without specific prior written permission.
+#
+#  Alternatively, provided that this notice is retained in full, this
+#  software may be distributed under the terms of the GNU General
+#  Public License ("GPL") version 2 as distributed in the 'COPYING'
+#  file from the main directory of the linux kernel source.
+#
+#  The provided data structures and external interfaces from this code
+#  are not restricted to be used by modules with a GPL compatible license.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+#  DAMAGE.
+#
+#  Send feedback to <socketcan-users@lists.berlios.de>
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+obj-$(CONFIG_CAN_CCAN)		+= ccan.o
+obj-$(CONFIG_CAN_H7202)		+= h7202_can.o
+
+endif
Index: drivers/net/can/ccan/ccan.c
===================================================================
--- /dev/null
+++ drivers/net/can/ccan/ccan.c
@@ -0,0 +1,566 @@
+/*
+ * drivers/can/c_can.c
+ *
+ * Copyright (C) 2007
+ *
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix
+ * - Simon Kallweit, intefo AG
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+#define DBG(args...) printk(args)
+#else
+#define DBG(args...)
+#endif
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/can.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <asm/io.h>
+
+#include <linux/can/dev.h>
+#include <linux/can/error.h>
+#include "ccan.h"
+
+static u32 ccan_read_reg32(struct net_device *dev, enum c_regs reg)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	
+	u32 val = priv->read_reg(dev, reg);
+	val |= ((u32) priv->read_reg(dev, reg + 2)) << 16;
+
+	return val;
+}
+
+static void ccan_write_reg32(struct net_device *dev, enum c_regs reg, u32 val)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	priv->write_reg(dev, reg, val & 0xffff);
+	priv->write_reg(dev, reg + 2, val >> 16);
+}
+
+static inline void ccan_object_get(struct net_device *dev,
+				   int iface, int objno, int mask)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	priv->write_reg(dev, CAN_IF_COMM(iface), mask);
+	priv->write_reg(dev, CAN_IF_COMR(iface), objno + 1);
+	while (priv->read_reg(dev, CAN_IF_COMR(iface)) & IF_COMR_BUSY)
+		DBG("busy\n");
+}
+
+static inline void ccan_object_put(struct net_device *dev,
+				   int iface, int objno, int mask)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	priv->write_reg(dev, CAN_IF_COMM(iface), IF_COMM_WR | mask);
+	priv->write_reg(dev, CAN_IF_COMR(iface), objno + 1);
+	while (priv->read_reg(dev, CAN_IF_COMR(iface)) & IF_COMR_BUSY)
+		DBG("busy\n");
+}
+
+static int ccan_write_object(struct net_device *dev,
+			     int iface, struct can_frame *frame, int objno)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	unsigned int val;
+	
+	if (frame->can_id & CAN_EFF_FLAG)
+		val = IF_ARB_MSGXTD | (frame->can_id & CAN_EFF_MASK);
+	else
+		val = ((frame->can_id & CAN_SFF_MASK) << 18);
+
+	if (!(frame->can_id & CAN_RTR_FLAG))
+		val |=  IF_ARB_TRANSMIT;
+
+	val |=  IF_ARB_MSGVAL;
+	ccan_write_reg32(dev, CAN_IF_ARB(iface), val);
+
+	memcpy(&val, &frame->data[0], 4);
+	ccan_write_reg32(dev, CAN_IF_DATAA(iface), val);
+	memcpy(&val, &frame->data[4], 4);
+	ccan_write_reg32(dev, CAN_IF_DATAB(iface), val);
+	priv->write_reg(dev, CAN_IF_MCONT(iface),
+			IF_MCONT_TXIE |	IF_MCONT_TXRQST | IF_MCONT_EOB |
+			(frame->can_dlc & 0xf));
+
+	ccan_object_put(dev, 0, objno, IF_COMM_ALL);
+
+	return 0;
+}
+
+static int ccan_read_object(struct net_device *dev, int iface, int objno)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	unsigned int val, ctrl, data;
+	struct sk_buff *skb;
+	struct can_frame *frame;
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	skb->dev = dev;
+
+	ccan_object_get(dev, 0, objno, IF_COMM_ALL & ~IF_COMM_TXRQST);
+#ifdef CCAN_DEBUG
+	priv->bufstat[objno]++;
+#endif
+	frame = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
+
+	ctrl = priv->read_reg(dev, CAN_IF_MCONT(iface));
+
+	if (ctrl & IF_MCONT_MSGLST) {
+		priv->can.net_stats.rx_errors++;
+		DBG("%s: msg lost in buffer %d\n", __FUNCTION__, objno);
+	}
+
+	frame->can_dlc = ctrl & 0xf;
+
+	val = ccan_read_reg32(dev, CAN_IF_ARB(iface));
+	
+	data = ccan_read_reg32(dev, CAN_IF_DATAA(iface));
+	memcpy(&frame->data[0], &data, 4);
+	data = ccan_read_reg32(dev, CAN_IF_DATAB(iface));
+	memcpy(&frame->data[4], &data, 4);
+
+	if (val & IF_ARB_MSGXTD)
+		frame->can_id = (val & CAN_EFF_MASK) | CAN_EFF_FLAG;
+	else
+		frame->can_id = (val >> 18) & CAN_SFF_MASK;
+
+	if (val & IF_ARB_TRANSMIT)
+		frame->can_id |= CAN_RTR_FLAG;
+
+	priv->write_reg(dev, CAN_IF_MCONT(iface), ctrl &
+			~(IF_MCONT_MSGLST | IF_MCONT_INTPND | IF_MCONT_NEWDAT));
+
+	ccan_object_put(dev, 0, objno, IF_COMM_CONTROL);
+
+	skb->protocol = __constant_htons(ETH_P_CAN);
+	netif_rx(skb);
+
+	priv->can.net_stats.rx_packets++;
+	priv->can.net_stats.rx_bytes += frame->can_dlc;
+
+	return 0;
+}
+
+static int ccan_setup_receive_object(struct net_device *dev, int iface,
+				     int objno, unsigned int mask,
+				     unsigned int id, unsigned int mcont)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	ccan_write_reg32(dev, CAN_IF_MASK(iface), mask);
+	ccan_write_reg32(dev, CAN_IF_ARB(iface), IF_ARB_MSGVAL | id);
+
+	priv->write_reg(dev, CAN_IF_MCONT(iface), mcont);
+
+	ccan_object_put(dev, 0, objno, IF_COMM_ALL & ~IF_COMM_TXRQST);
+
+	DBG("%s: obj no %d msgval: 0x%08x\n", __FUNCTION__, 
+		objno, ccan_read_reg32(dev, CAN_MSGVAL));
+		
+	return 0;
+}
+
+static int ccan_inval_object(struct net_device *dev, int iface, int objno)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	ccan_write_reg32(dev, CAN_IF_ARB(iface), 0);
+	priv->write_reg(dev, CAN_IF_MCONT(iface), 0);
+	ccan_object_put(dev, 0, objno, IF_COMM_ARB | IF_COMM_CONTROL);
+
+	DBG("%s: obj no %d msgval: 0x%08x\n", __FUNCTION__, 
+		objno, ccan_read_reg32(dev, CAN_MSGVAL));
+		
+	return 0;
+}
+
+static int ccan_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	struct can_frame *frame = (struct can_frame *)skb->data;
+
+	spin_lock_irq(&priv->can.irq_lock);
+
+	ccan_write_object(dev, 0, frame, priv->tx_object);
+#ifdef CCAN_DEBUG
+	priv->bufstat[priv->tx_object]++;
+#endif
+	priv->tx_object++;
+	if (priv->tx_object > 5)
+		netif_stop_queue(dev);
+
+	spin_unlock_irq(&priv->can.irq_lock);
+
+	priv->can.net_stats.tx_packets++;
+	priv->can.net_stats.tx_bytes += frame->can_dlc;
+
+	dev->trans_start = jiffies;
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+static void ccan_tx_timeout(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	
+	priv->can.net_stats.tx_errors++;
+}
+
+static int ccan_set_bit_time(struct net_device *dev, struct can_bittime *br)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	unsigned int reg_timing, ctrl_save;
+	u8 brp, sjw, tseg1, tseg2; 
+
+	if (br->type != CAN_BITTIME_STD)
+		return -EINVAL;
+
+	brp = br->std.brp - 1;
+	sjw = br->std.sjw - 1;
+	tseg1 = br->std.prop_seg + br->std.phase_seg1 - 1;
+	tseg2 = br->std.phase_seg2 - 1;
+
+	reg_timing = (brp & BTR_BRP_MASK) |
+		     ((sjw << BTR_SJW_SHIFT) & BTR_SJW_MASK) |
+		     ((tseg1 << BTR_TSEG1_SHIFT) & BTR_TSEG1_MASK) |
+		     ((tseg2 << BTR_TSEG2_SHIFT) & BTR_TSEG2_MASK);
+		     
+	DBG("%s: brp = %d sjw = %d seg1 = %d seg2 = %d\n", __FUNCTION__, 
+		brp, sjw, tseg1, tseg2);
+	DBG("%s: setting BTR to %04x\n", __FUNCTION__, reg_timing);
+
+	spin_lock_irq(&priv->can.irq_lock);
+
+	ctrl_save = priv->read_reg(dev, CAN_CONTROL);
+	priv->write_reg(dev, CAN_CONTROL,
+			ctrl_save | CONTROL_CCE | CONTROL_INIT);
+	priv->write_reg(dev, CAN_BTR, reg_timing);
+	priv->write_reg(dev, CAN_CONTROL, ctrl_save);
+
+	spin_unlock_irq(&priv->can.irq_lock);
+	
+	return 0;
+}
+
+static int ccan_set_mode(struct net_device *dev, can_mode_t mode)
+{
+	switch (mode) {
+	case CAN_MODE_START:
+		DBG("%s: CAN_MODE_START requested\n", __FUNCTION__);
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int ccan_get_state(struct net_device *dev, can_state_t *state)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	u32 reg_status;
+#ifdef CCAN_DEBUG
+	int i;
+#endif
+
+	reg_status = priv->read_reg(dev, CAN_STATUS);
+
+	if (reg_status & STATUS_EPASS)
+		*state = CAN_STATE_BUS_PASSIVE;
+	else if (reg_status & STATUS_EWARN)
+		*state = CAN_STATE_BUS_WARNING;
+	else if (reg_status & STATUS_BOFF)
+		*state = CAN_STATE_BUS_OFF;
+	else
+		*state = CAN_STATE_ACTIVE;
+#ifdef CCAN_DEBUG
+	DBG("buffer statistic:\n");
+	for (i=0; i<= MAX_OBJECT; i++)
+		DBG("%d: %d\n", i, priv->bufstat[i]);
+#endif
+	return 0;
+}
+
+static int ccan_do_status_irq(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	int status, diff;
+
+	status = priv->read_reg(dev, CAN_STATUS);
+	status &= ~(STATUS_TXOK | STATUS_RXOK);
+	diff = status ^ priv->last_status;
+
+	if (diff & STATUS_EPASS) {
+		if (status & STATUS_EPASS)
+			dev_info(ND2D(dev), "entered error passive state\n");
+		else
+			dev_info(ND2D(dev), "left error passive state\n");
+	}
+	if (diff & STATUS_EWARN) {
+		if (status & STATUS_EWARN)
+			dev_info(ND2D(dev), "entered error warning state\n");
+		else
+			dev_info(ND2D(dev), "left error warning state\n");
+	}
+	if (diff & STATUS_BOFF) {
+		if (status & STATUS_BOFF)
+			dev_info(ND2D(dev), "entered busoff state\n");
+		else
+			dev_info(ND2D(dev), "left busoff state\n");
+	}
+
+	if ( diff & STATUS_LEC_MASK) {
+		switch (status & STATUS_LEC_MASK) {
+		case LEC_STUFF_ERROR:
+			dev_info(ND2D(dev), "suffing error\n");
+			break;
+		case LEC_FORM_ERROR:
+			dev_info(ND2D(dev), "form error\n");
+			break;
+		case LEC_ACK_ERROR:
+			dev_info(ND2D(dev), "ack error\n");
+			break;
+		case LEC_BIT1_ERROR:
+			dev_info(ND2D(dev), "bit1 error\n");
+			break;
+		}
+	}
+
+	priv->write_reg(dev, CAN_STATUS, 0);
+	priv->last_status = status;
+	
+	return diff ? 1 : 0;
+}
+
+static void ccan_do_object_irq(struct net_device *dev, u16 irqstatus)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	int i;
+	u32 val;
+
+	if (irqstatus > MAX_TRANSMIT_OBJECT) {
+		val = ccan_read_reg32(dev, CAN_NEWDAT);
+		while (val & RECEIVE_OBJECT_BITS) {
+			for (i = MAX_TRANSMIT_OBJECT + 1; i <= MAX_OBJECT; i++)
+				if (val & (1<<i))
+					ccan_read_object(dev, 0, i);
+			val = ccan_read_reg32(dev, CAN_NEWDAT);
+		}
+	} else {
+		ccan_inval_object(dev, 0, irqstatus - 1);
+		val = ccan_read_reg32(dev, CAN_TXRQST);
+		if (!val) {
+			priv->tx_object = 0;
+			netif_wake_queue(dev);
+		}
+	}
+}
+
+static void do_statuspoll(struct work_struct *work)
+{
+	struct ccan_priv *priv = container_of(((struct delayed_work *) work), 
+					      struct ccan_priv, work);
+
+	priv->write_reg(priv->dev, CAN_CONTROL,
+			CONTROL_SIE | CONTROL_EIE | CONTROL_IE);
+}
+
+static irqreturn_t ccan_isr(int irq, void *dev_id)
+{
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct ccan_priv *priv = netdev_priv(dev);
+	u16 irqstatus;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&priv->can.irq_lock, flags);
+
+	irqstatus = priv->read_reg(dev, CAN_IR);
+	while (irqstatus) {
+		if (irqstatus == 0x8000) {
+			if (ccan_do_status_irq(dev)) {
+				/* The c_can core tends to flood us with
+				 * interrupts when certain error states don't
+				 * disappear. Disable interrupts and see if it's
+				 * getting better later. This is at least the
+				 * case on the Magnachip h7202.
+				 */
+				priv->write_reg(dev, CAN_CONTROL, CONTROL_EIE |
+						CONTROL_IE );
+				schedule_delayed_work(&priv->work, HZ / 10);
+				goto exit;
+			}
+		} else {
+			ccan_do_object_irq(dev, irqstatus);
+		}
+		irqstatus = priv->read_reg(dev, CAN_IR);
+	}
+
+exit:
+	spin_unlock_irqrestore(&priv->can.irq_lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static int ccan_open(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+
+	if (request_irq(dev->irq, &ccan_isr, 0, dev->name, dev)) {
+		dev_err(ND2D(dev), "failed to attach interrupt\n");
+		return -EAGAIN;
+	}
+
+	priv->write_reg(dev, CAN_CONTROL,
+			CONTROL_EIE | CONTROL_SIE | CONTROL_IE);
+
+	netif_wake_queue(dev);
+
+	return 0;
+}
+
+static int ccan_stop(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	unsigned long flags;
+
+	netif_stop_queue(dev);
+
+	cancel_delayed_work(&priv->work);
+	flush_scheduled_work();
+
+	/* mask all IRQs */
+	spin_lock_irqsave(&priv->can.irq_lock, flags);
+	priv->write_reg(dev, CAN_CONTROL, 0);
+	spin_unlock_irqrestore(&priv->can.irq_lock, flags);
+
+	free_irq(dev->irq, dev);
+
+	return 0;
+}
+
+static int ccan_chip_config(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	struct can_bittime bit_time;
+	int ret, i;
+	
+	/* set bit timing */
+	bit_time.type = CAN_BITTIME_STD;
+	ret = can_calc_bit_time(&priv->can, priv->can.baudrate, &bit_time.std);
+	if (ret == 0)
+		ret = ccan_set_bit_time(dev, &bit_time);
+	if (ret)
+		dev_err(ND2D(dev), "failed to config bit timing\n");
+
+	/* setup message objects */
+	for(i = 0; i <= MAX_OBJECT; i++)
+		ccan_inval_object(dev, 0, i);
+
+	for(i = MAX_TRANSMIT_OBJECT + 1; i < MAX_OBJECT; i++)
+		ccan_setup_receive_object(dev, 0, i, 0, 0,
+					  IF_MCONT_RXIE | IF_MCONT_UMASK);
+					  
+	ccan_setup_receive_object(dev, 0, MAX_OBJECT, 0, 0, IF_MCONT_EOB |
+				  IF_MCONT_RXIE | IF_MCONT_UMASK);
+				  
+#ifdef CCAN_DEBUG
+	for(i = 0; i <= MAX_OBJECT; i++)
+		priv->bufstat[i] = 0;
+#endif
+
+	return 0;
+}
+
+struct net_device *alloc_ccandev(int sizeof_priv)
+{
+	struct net_device *dev;
+	struct ccan_priv *priv;
+
+	dev = alloc_candev(sizeof_priv);
+	if(!dev)
+		return NULL;
+		
+	priv = netdev_priv(dev);
+
+	dev->open = ccan_open;
+	dev->stop = ccan_stop;
+	dev->hard_start_xmit = ccan_hard_start_xmit;
+	dev->tx_timeout = ccan_tx_timeout;
+
+	priv->can.baudrate = 500000;
+
+	priv->can.do_set_bit_time = ccan_set_bit_time;
+	priv->can.do_get_state = ccan_get_state;
+	priv->can.do_set_mode = ccan_set_mode;
+
+	priv->dev = dev;	
+	priv->tx_object = 0;
+
+	return dev;
+}
+EXPORT_SYMBOL(alloc_ccandev);
+
+void free_ccandev(struct net_device *dev)
+{
+	free_candev(dev);
+}
+EXPORT_SYMBOL(free_ccandev);
+
+int register_ccandev(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	
+	ccan_set_mode(dev, CAN_MODE_START);
+
+	ccan_chip_config(dev);
+	INIT_DELAYED_WORK(&priv->work, do_statuspoll);
+	
+	return register_netdev(dev);	
+}
+EXPORT_SYMBOL(register_ccandev);
+
+void unregister_ccandev(struct net_device *dev)
+{
+	struct ccan_priv *priv = netdev_priv(dev);
+	
+	ccan_set_mode(dev, CAN_MODE_START);
+
+	cancel_delayed_work(&priv->work);
+	flush_scheduled_work();
+
+	unregister_netdev(dev);
+}
+EXPORT_SYMBOL(unregister_ccandev);
+
+
+MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
+MODULE_AUTHOR("Simon Kallweit <simon.kallweit@intefo.ch>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("CAN port driver for C_CAN based chips");
Index: drivers/net/can/ccan/ccan.h
===================================================================
--- /dev/null
+++ drivers/net/can/ccan/ccan.h
@@ -0,0 +1,140 @@
+/*
+ * drivers/can/c_can.h
+ *
+ * Copyright (C) 2007
+ *
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix
+ * - Simon Kallweit, intefo AG
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __CCAN_H__
+#define __CCAN_H__
+
+#include <linux/can.h>
+#include <linux/platform_device.h>
+
+#undef CCAN_DEBUG
+
+enum c_regs {
+	CAN_CONTROL = 0x00,
+	CAN_STATUS  = 0x02,
+	CAN_ERROR   = 0x04,
+	CAN_BTR     = 0x06,
+	CAN_IR      = 0x08,
+	CAN_TEST    = 0x0a,
+	CAN_BRP_EXT = 0x0c,
+	CAN_IF1     = 0x10,
+	CAN_IF2     = 0x40,
+	CAN_TXRQST  = 0x80, /* 32bit */
+	CAN_NEWDAT  = 0x90, /* 32bit */
+	CAN_INTPND  = 0xa0, /* 32bit */
+	CAN_MSGVAL  = 0xb0, /* 32bit */
+};
+
+#define CAN_IF_COMR(x)   (CAN_IF1 + (x) * 0x30 + 0x00)
+#define CAN_IF_COMM(x)   (CAN_IF1 + (x) * 0x30 + 0x02)
+#define CAN_IF_MASK(x)   (CAN_IF1 + (x) * 0x30 + 0x04)  /* 32bit */
+#define CAN_IF_ARB(x)    (CAN_IF1 + (x) * 0x30 + 0x08)  /* 32bit */
+#define CAN_IF_MCONT(x)  (CAN_IF1 + (x) * 0x30 + 0x0c)
+#define CAN_IF_DATAA(x)  (CAN_IF1 + (x) * 0x30 + 0x0e)  /* 32bit */
+#define CAN_IF_DATAB(x)  (CAN_IF1 + (x) * 0x30 + 0x12)  /* 32bit */
+
+#define CONTROL_TEST (1<<7)
+#define CONTROL_CCE  (1<<6)
+#define CONTROL_DAR  (1<<5)
+#define CONTROL_EIE  (1<<3)
+#define CONTROL_SIE  (1<<2)
+#define CONTROL_IE   (1<<1)
+#define CONTROL_INIT (1<<0)
+
+#define TEST_RX     (1<<7)
+#define TEST_TX1    (1<<6)
+#define TEST_TX2    (1<<5)
+#define TEST_LBACK  (1<<4)
+#define TEST_SILENT (1<<3)
+#define TEST_BASIC  (1<<2)
+
+#define STATUS_BOFF     (1<<7)
+#define STATUS_EWARN    (1<<6)
+#define STATUS_EPASS    (1<<5)
+#define STATUS_RXOK     (1<<4)
+#define STATUS_TXOK     (1<<3)
+#define STATUS_LEC_MASK (1<<2)
+#define LEC_STUFF_ERROR 1
+#define LEC_FORM_ERROR  2
+#define LEC_ACK_ERROR   3
+#define LEC_BIT1_ERROR  4
+
+#define BTR_BRP_MASK	0x3f
+#define BTR_BRP_SHIFT	0
+#define BTR_SJW_SHIFT	6
+#define BTR_SJW_MASK	(0x3 << BTR_SJW_SHIFT)
+#define BTR_TSEG1_SHIFT	8
+#define BTR_TSEG1_MASK	(0xf << BTR_TSEG1_SHIFT)
+#define BTR_TSEG2_SHIFT	12
+#define BTR_TSEG2_MASK	(0x7 << BTR_TSEG2_SHIFT)
+
+#define IF_COMR_BUSY (1<<15)
+
+#define IF_COMM_WR          (1<<7)
+#define IF_COMM_MASK        (1<<6)
+#define IF_COMM_ARB         (1<<5)
+#define IF_COMM_CONTROL     (1<<4)
+#define IF_COMM_CLR_INT_PND (1<<3)
+#define IF_COMM_TXRQST      (1<<2)
+#define IF_COMM_DATAA       (1<<1)
+#define IF_COMM_DATAB       (1<<0)
+
+#define IF_COMM_ALL (IF_COMM_MASK | IF_COMM_ARB | IF_COMM_CONTROL | \
+		     IF_COMM_TXRQST | IF_COMM_DATAA | IF_COMM_DATAB)
+
+#define IF_ARB_MSGVAL   (1<<31)
+#define IF_ARB_MSGXTD   (1<<30)
+#define IF_ARB_TRANSMIT (1<<29)
+
+#define IF_MCONT_NEWDAT (1<<15)
+#define IF_MCONT_MSGLST (1<<14)
+#define IF_MCONT_INTPND (1<<13)
+#define IF_MCONT_UMASK  (1<<12)
+#define IF_MCONT_TXIE   (1<<11)
+#define IF_MCONT_RXIE   (1<<10)
+#define IF_MCONT_RMTEN  (1<<9)
+#define IF_MCONT_TXRQST (1<<8)
+#define IF_MCONT_EOB    (1<<7)
+
+#define MAX_OBJECT 31
+#define MAX_TRANSMIT_OBJECT 15
+#define RECEIVE_OBJECT_BITS 0xffff0000
+
+struct ccan_priv {
+	struct can_priv can;
+	struct net_device *dev;
+	int tx_object;
+	int last_status;
+	struct delayed_work work;
+	u16 (*read_reg)(struct net_device *dev, enum c_regs reg);
+	void (*write_reg)(struct net_device *dev, enum c_regs reg, u16 val);
+#ifdef CCAN_DEBUG
+	unsigned int bufstat[MAX_OBJECT + 1];
+#endif
+};
+
+extern struct net_device *alloc_ccandev(int sizeof_priv);
+extern void free_ccandev(struct net_device *dev);
+extern int register_ccandev(struct net_device *dev);
+extern void unregister_ccandev(struct net_device *dev);
+
+#endif /* __CCAN_H__ */
Index: drivers/net/can/ccan/h7202_can.c
===================================================================
--- /dev/null
+++ drivers/net/can/ccan/h7202_can.c
@@ -0,0 +1,200 @@
+/*
+ * drivers/can/h7202_can.c
+ *
+ * Copyright (C) 2007
+ *
+ * - Sascha Hauer, Marc Kleine-Budde, Pengutronix
+ * - Simon Kallweit, intefo AG
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <linux/can.h>
+#include <linux/can/dev.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+
+#include "ccan.h"
+
+#define DRV_NAME      "h7202can"
+#define DELAY         5
+#define CAN_ENABLE    0x0e
+
+static u16 h7202can_read_reg(struct net_device *dev, enum c_regs reg)
+{
+	u16 val;
+	volatile int i;
+
+	/* The big kernel lock is used to prevent any other AMBA devices from
+	 * interfering with the current register read operation. The register
+	 * is read twice because of braindamaged hynix cpu.
+	 */ 
+	lock_kernel();
+	val = inw(dev->base_addr + (reg<<1));
+	for (i=0;i<DELAY;i++);
+	val = inw(dev->base_addr + (reg<<1));
+	for (i=0;i<DELAY;i++);
+	unlock_kernel();
+	
+	return val;
+}
+
+static void h7202can_write_reg(struct net_device *dev, enum c_regs reg, u16 val)
+{
+	volatile int i;
+
+	lock_kernel();
+	outw(val, dev->base_addr + (reg<<1));
+	for (i=0;i<DELAY;i++);
+	unlock_kernel();
+}
+
+static int h7202can_drv_probe(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	struct ccan_priv *priv;
+	struct resource *mem;
+	u32 mem_size;
+	int ret = -ENODEV;
+	
+	dev = alloc_ccandev(sizeof(struct ccan_priv));
+	if (!dev)
+		return -ENOMEM;
+		
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->irq = platform_get_irq(pdev, 0);
+	if (!mem || !dev->irq)
+		goto req_error;
+
+	mem_size = mem->end - mem->start + 1;
+	if (!request_mem_region(mem->start, mem_size, pdev->dev.driver->name)) {
+		dev_err(&pdev->dev, "resource unavailable\n");
+		goto req_error;
+	}
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+	SET_MODULE_OWNER(THIS_MODULE);
+
+	dev->base_addr = (unsigned long)ioremap_nocache(mem->start, mem_size);
+
+	if (!dev->base_addr) {
+		dev_err(&pdev->dev, "failed to map can port\n");
+		ret = -ENOMEM;
+		goto fail_map;
+	}
+
+	priv = netdev_priv(dev);
+	priv->can.can_sys_clock = 8000000;
+	priv->read_reg = h7202can_read_reg;
+	priv->write_reg = h7202can_write_reg;
+
+	platform_set_drvdata(pdev, dev);
+	
+	/* configure ports */
+	switch (mem->start) {
+	case CAN0_PHYS:
+		CPU_REG(GPIO_C_VIRT, GPIO_EN) &= ~(3<<1);
+		CPU_REG(GPIO_C_VIRT, GPIO_DIR) &= ~(1<<1);
+		CPU_REG(GPIO_C_VIRT, GPIO_DIR) |= (1<<2);
+		break;
+	case CAN1_PHYS:
+		CPU_REG(GPIO_E_VIRT, GPIO_EN) &= ~(3<<16);
+		CPU_REG(GPIO_E_VIRT, GPIO_DIR) |= (1<<16);
+		CPU_REG(GPIO_E_VIRT, GPIO_DIR) &= ~(1<<17);
+		break;
+	}
+
+	/* enable can */	
+	h7202can_write_reg(dev, CAN_ENABLE, 1);
+
+	ret = register_ccandev(dev);
+	if (ret >= 0) {
+		dev_info(&pdev->dev, "probe for a port 0x%lX done\n",
+			 dev->base_addr);
+		return ret;
+	}
+
+	iounmap((unsigned long *)dev->base_addr);
+fail_map:
+	release_mem_region(mem->start, mem_size);
+req_error:
+	free_ccandev(dev);
+	dev_err(&pdev->dev, "probe failed\n");
+	return ret;
+}
+
+static int h7202can_drv_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct resource *mem;
+
+	platform_set_drvdata(pdev, NULL);
+	unregister_ccandev(dev);
+
+	iounmap((volatile void __iomem *)(dev->base_addr));
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem->start, mem->end - mem->start + 1);
+	free_ccandev(dev);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int h7202can_drv_suspend(struct platform_device *pdev,
+				pm_message_t state)
+{
+	return 0;
+}
+
+static int h7202can_drv_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+static struct platform_driver h7202can_driver = {
+	.driver		= {
+		.name		= DRV_NAME,
+	},
+	.probe		= h7202can_drv_probe,
+	.remove		= h7202can_drv_remove,
+#ifdef CONFIG_PM
+	.suspend	= h7202can_drv_suspend,
+	.resume		= h7202can_drv_resume,
+#endif	/* CONFIG_PM */
+};
+
+static int __init h7202can_init(void)
+{
+	printk(KERN_INFO "%s initializing\n", h7202can_driver.driver.name);
+	return platform_driver_register(&h7202can_driver);
+}
+
+static void __exit h7202can_cleanup(void)
+{
+	platform_driver_unregister(&h7202can_driver);
+	printk(KERN_INFO "%s unloaded\n", h7202can_driver.driver.name);
+}
+
+module_init(h7202can_init);
+module_exit(h7202can_cleanup);
+
+MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
+MODULE_AUTHOR("Simon Kallweit <simon.kallweit@intefo.ch>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("CAN port driver Hynix H7202 processor");
Index: drivers/net/can/hal/c200.c
===================================================================
--- /dev/null
+++ drivers/net/can/hal/c200.c
@@ -0,0 +1,207 @@
+/*
+ * c200.c - low cost parallelport CAN adaptor hardware abstraction layer
+ *          ( direct register access without parport subsystem support )
+ *
+ *          CAN200 project homepage http://private.addcom.de/horo/can200
+ *
+ *          This hal is based on a patch from Uwe Bonnes.
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include "hal.h"
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "c200"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+
+	base[0]		= 0x378UL;
+	irq[0]		= 7;
+}
+
+#define ECR_REGS_OFFSET 0x400
+#define ECR_CTRL_OFFSET (ECR_REGS_OFFSET + 2)
+
+static u8 ecr_crtl_save;
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	/* set for device base_addr */
+	rbase[dev_num] = base[dev_num];
+
+	/* grab ECR control registers and set parport to 'byte mode' */
+	if (request_region(rbase[dev_num] + ECR_REGS_OFFSET, 3, drv_name)) {
+
+		ecr_crtl_save = inb(rbase[dev_num] + ECR_CTRL_OFFSET);
+
+		outb((ecr_crtl_save & 0x1F) | 0x20,
+		     rbase[dev_num] + ECR_CTRL_OFFSET);
+	} else
+		return 0;
+
+	if (request_region(rbase[dev_num], 4, drv_name))
+		return 1;
+
+	release_region(rbase[dev_num] + ECR_REGS_OFFSET, 3);
+
+	return 0;
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+
+	release_region(base[dev_num], 4);
+
+	/* restore original ECR control register value */
+	outb(ecr_crtl_save, base[dev_num] + ECR_CTRL_OFFSET);
+	release_region(base[dev_num] + ECR_REGS_OFFSET, 3);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num)
+{
+	extern unsigned long rbase[];
+	unsigned long pc = rbase[dev_num] + 2;
+
+	/* enable irq */
+	outb(inb(pc) | 0x10, pc);
+
+	return 0;
+}
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num)
+{
+	extern unsigned long rbase[];
+	unsigned long pc = rbase[dev_num] + 2;
+
+	/* disable irq */
+	outb(inb(pc) & ~0x10, pc);
+
+	return 0;
+}
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+#define WRITEP		0x01 /* inverted at port  */
+#define DATASTB		0x02 /* inverted at port and at device*/
+#define ADDRSTB		0x08 /* inverted at port and at device*/
+#define PORTREAD	0x20
+
+static DEFINE_SPINLOCK(c200_lock);
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg)
+{
+	unsigned long pa = base;
+	unsigned long pc = pa + 2;
+	unsigned long flags;
+	u8 irqstatus = (inb(pc) & 0x10) | 0x04;
+	u8 val;
+
+	spin_lock_irqsave(&c200_lock, flags);
+
+	outb(irqstatus | ADDRSTB, pc);
+	outb((reg & 0x1F) | 0x80, pa);
+	outb(irqstatus, pc);
+	outb(irqstatus | PORTREAD, pc);
+	outb(irqstatus | DATASTB | PORTREAD, pc);
+	val = inb(pa);
+	outb(irqstatus, pc);
+
+	spin_unlock_irqrestore(&c200_lock, flags);
+
+	return val;
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val)
+{
+	unsigned long pa = base;
+	unsigned long pc = pa + 2;
+	unsigned long flags;
+	u8 irqstatus = (inb(pc) & 0x10) | 0x04;
+
+	spin_lock_irqsave(&c200_lock, flags);
+
+	outb(irqstatus | ADDRSTB, pc);
+	outb(reg & 0x1F, pa);
+	outb(irqstatus, pc);
+	outb(irqstatus | WRITEP, pc);
+	outb(irqstatus | DATASTB | WRITEP, pc);
+	outb(val, pa);
+	outb(irqstatus, pc);
+
+	spin_unlock_irqrestore(&c200_lock, flags);
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
Index: drivers/net/can/hal/esdio.c
===================================================================
--- /dev/null
+++ drivers/net/can/hal/esdio.c
@@ -0,0 +1,186 @@
+/*
+ * esdio.c - multiplex register access CAN hardware abstraction layer
+ *           for the esd 3xCAN pc104 board
+ *           http://www.esd-electronics.de/products/CAN/can-pc104-200_e.htm
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2007 Fraunhofer FOKUS
+ *
+ * Provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ * History:
+ * 2007-05-22 Bjoern Riemer: initial release
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include "hal.h"
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+#define DBG(args...) printk(args)
+#else
+#define DBG(args...)
+#endif
+
+//#define DBG(args...)   printk(args)
+
+int esd_ale_offset = 1;	//default for the sja1000 chip
+int esd_cs_offset = 0;	//default for the sja1000 chip
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "esdio"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+
+	base[0]		= 0x1e8UL;
+	irq[0]		= 5;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+	
+	if (!memcmp(drv_name,"i82527-esdio",sizeof("i82527-esdio"))){
+		esd_ale_offset = 7; 
+		esd_cs_offset = 4;
+	} else if (!memcmp(drv_name,"sja1000-esdio",sizeof("sja1000-esdio"))){
+		esd_ale_offset = 1;
+		esd_cs_offset = 0;
+	}
+	
+	/* set for device base_addr */
+	rbase[dev_num] = base[dev_num];
+
+	/* ignore num_regs and create the 2 register region: */
+	/* address register = base + esd_ale_offset          */
+	/* data register    = base + esd_cs_offset           */
+	if (request_region(base[dev_num] + esd_ale_offset, 1, drv_name)){
+		if (request_region(base[dev_num] + esd_cs_offset, 1,drv_name)){
+			return 1;
+		} else {
+			release_region(base[dev_num]+esd_ale_offset, 1);
+			return 0; // error
+		}
+	}
+
+	return 0; // error 
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+
+	/* ignore num_regs and create the 2 register region: */
+	/* address register = base + esd_ale_offset          */
+	/* data register    = base + esd_cs_offset           */
+	release_region(base[dev_num] + esd_cs_offset, 1);
+	release_region(base[dev_num] + esd_ale_offset, 1);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num)
+{
+	int i, stat, i1;
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+	 
+	i1 = irq[dev_num]; //get IRQ number
+	DBG(KERN_INFO "esdio.c: enabling IRQ %d for dev_num %d\n",i1,dev_num);
+	
+	for (i=0; i<4; i++){
+		stat=i; // bit 0,1 selects the latch bit to write
+		if (i1 & 0x01){
+			stat |= 0x80; //bit7 carrys the value of the latch bit
+		}
+		outb(stat,base[dev_num]+3);
+		i1 = i1>>1;
+	}
+
+	outb(0x87,base[dev_num]+3); //enable irq selection
+	outb(0x86,base[dev_num]+3); //enable irq tristate buffer
+
+	return 1; 
+}
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num)
+{
+	int i;
+	extern unsigned long base[];
+	
+	DBG(KERN_INFO "esdio.c: diabling IRQ for dev_num %d\n",dev_num);
+	
+	outb(0x07,base[dev_num]+3); //disable irq selection
+	outb(0x06,base[dev_num]+3); //disable irq tristate buffer
+	
+	for (i=0; i<4; i++)
+		outb(i,base[dev_num]+3);
+
+	return 1;
+}
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) {	return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {	
+	
+	outb(reg, base + esd_ale_offset);	/* address */
+	return inb(base + esd_cs_offset);	/* data */
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+	
+	outb(reg, base + esd_ale_offset);	/* address */
+	outb(val, base + esd_cs_offset);	/* data */
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) {	
+
+	outb(0x86,dev->base_addr+3); //enable irq tristate buffer 
+	return; 
+}
Index: drivers/net/can/hal/gw2.c
===================================================================
--- /dev/null
+++ drivers/net/can/hal/gw2.c
@@ -0,0 +1,162 @@
+/*
+ * gw2.c - Trajet GW2 register access CAN hardware abstraction layer
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include "hal.h"
+
+#define ADDR_GAP 1
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "gw2"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+	extern unsigned int  speed[];
+
+	base[0]		= 0xF0100200UL;
+	irq[0]		= 26;
+	speed[0]	= 500;
+
+	base[1]		= 0xF0100300UL;
+	irq[1]		= 26;
+	speed[1]	= 100;
+
+	base[2]		= 0xF0100400UL;
+	irq[2]		= 26;
+	speed[2]	= 100;
+
+	base[3]		= 0xF0100500UL;
+	irq[3]		= 26;
+	speed[3]	= 500;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	unsigned int gw2_regs = num_regs * (ADDR_GAP + 1);
+
+	/* creating the region for IOMEM is pretty easy */
+	if (!request_mem_region(base[dev_num], gw2_regs, drv_name))
+		return 0; /* failed */
+
+	/* set device base_addr */
+	rbase[dev_num] = (unsigned long)ioremap(base[dev_num], gw2_regs);
+
+	if (rbase[dev_num])
+		return 1; /* success */
+
+	/* cleanup due to failed ioremap() */
+	release_mem_region(base[dev_num], gw2_regs);
+	return 0; /* failed */
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	unsigned int gw2_regs = num_regs * (ADDR_GAP + 1);
+
+	iounmap((void *)rbase[dev_num]);
+	release_mem_region(base[dev_num], gw2_regs);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) { return 0; }
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	static u8 val;
+	void __iomem *addr = (void __iomem *)base +
+		reg * (ADDR_GAP + 1) + ADDR_GAP;
+
+	val = (u8)readw(addr);
+	rmb();
+
+        return val;
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	void __iomem *addr = (void __iomem *)base +
+		reg * (ADDR_GAP + 1) + ADDR_GAP;
+
+	writew(val, addr);
+	wmb();
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+
Index: drivers/net/can/hal/hal.h
===================================================================
--- /dev/null
+++ drivers/net/can/hal/hal.h
@@ -0,0 +1,100 @@
+/*
+ * hal.h - definitions for CAN controller hardware abstraction layer
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_HAL_H
+#define CAN_HAL_H
+
+#include <linux/types.h>
+#include <linux/netdevice.h>
+
+/* Number of supported CAN devices for each HAL (default) */
+#define MAXDEV 8
+
+/* general function prototypes for CAN HAL */
+
+/* init the HAL - call at driver module init */
+int hal_init(void);
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void);
+
+/* get name of this CAN HAL */
+char *hal_name(void);
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void);
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name);
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs);
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num);
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num);
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num);
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg);
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val);
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev);
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev);
+
+#endif /* CAN_HAL_H */
Index: drivers/net/can/hal/io.c
===================================================================
--- /dev/null
+++ drivers/net/can/hal/io.c
@@ -0,0 +1,124 @@
+/*
+ * io.c - linear register access CAN hardware abstraction layer
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include "hal.h"
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "io"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+
+	base[0]		= 0x2C0UL;
+	irq[0]		= 10;
+
+	base[1]		= 0x320UL;
+	irq[1]		= 5;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	/* set for device base_addr */
+	rbase[dev_num] = base[dev_num];
+
+	/* creating the region for IO is pretty easy */
+	return (request_region(base[dev_num], num_regs, drv_name))? 1 : 0;
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+
+	release_region(base[dev_num], num_regs);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) { return 0; }
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	return inb(base + reg);
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	outb(val, base + reg);
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+
Index: drivers/net/can/hal/iomem.c
===================================================================
--- /dev/null
+++ drivers/net/can/hal/iomem.c
@@ -0,0 +1,143 @@
+/*
+ * iomem.c - linear register access CAN hardware abstraction layer
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include "hal.h"
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "iomem"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+
+	base[0]		= 0xd8000UL;
+	irq[0]		= 5;
+
+	base[1]		= 0xd8100UL;
+	irq[1]		= 15;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	/* creating the region for IOMEM is pretty easy */
+	if (!request_mem_region(base[dev_num], num_regs, drv_name))
+		return 0; /* failed */
+
+	/* set device base_addr */
+	rbase[dev_num] = (unsigned long)ioremap(base[dev_num], num_regs);
+
+	if (rbase[dev_num])
+		return 1; /* success */
+
+	/* cleanup due to failed ioremap() */
+	release_mem_region(base[dev_num], num_regs);
+	return 0; /* failed */
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	iounmap((void *)rbase[dev_num]);
+	release_mem_region(base[dev_num], num_regs);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) { return 0; }
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	static u8 val;
+	void __iomem *addr = (void __iomem *)base + reg;
+
+	val = (u8)readb(addr);
+	rmb();
+
+        return val;
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	void __iomem *addr = (void __iomem *)base + reg;
+
+	writeb(val, addr);
+	wmb();
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+
Index: drivers/net/can/hal/iomux.c
===================================================================
--- /dev/null
+++ drivers/net/can/hal/iomux.c
@@ -0,0 +1,126 @@
+/*
+ * iomux.c - multiplex register access CAN hardware abstraction layer
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include "hal.h"
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "iomux"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+
+	base[0]		= 0x300UL;
+	irq[0]		= 5;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	/* set for device base_addr */
+	rbase[dev_num] = base[dev_num];
+
+	/* ignore num_regs and create the 2 register region:  */
+	/* address register = base / data register = base + 1 */
+	return (request_region(base[dev_num], 2, drv_name))? 1 : 0;
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+
+	/* ignore num_regs and create the 2 register region:  */
+	/* address register = base / data register = base + 1 */
+	release_region(base[dev_num], 2);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) { return 0; }
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	outb(reg, base);	/* address */
+	return inb(base + 1);	/* data */
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	outb(reg, base);	/* address */
+	outb(val, base + 1);	/* data */
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+
Index: drivers/net/can/hal/pc7io.c
===================================================================
--- /dev/null
+++ drivers/net/can/hal/pc7io.c
@@ -0,0 +1,127 @@
+/*
+ * pc7io.c - linear register access CAN hardware abstraction layer
+ *
+ * Inspired by the OCAN driver http://ar.linux.it/software/#ocan
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include "hal.h"
+
+/* init the HAL - call at driver module init */
+int hal_init(void) { return 0; }
+
+/* exit the HAL - call at driver module exit */
+int hal_exit(void) { return 0; }
+
+/* get name of this CAN HAL */
+char *hal_name(void) { return "pc7io"; }
+
+/* fill arrays base[] and irq[] with HAL specific defaults */
+void hal_use_defaults(void)
+{
+	extern unsigned long base[];
+	extern unsigned int  irq[];
+
+	base[0]		= 0x1000UL;
+	irq[0]		= 9;
+}
+
+/* request controller register access space */
+int hal_request_region(int dev_num,
+		       unsigned int num_regs,
+		       char *drv_name)
+{
+	extern unsigned long base[];
+	extern unsigned long rbase[];
+
+	/* set for device base_addr */
+	rbase[dev_num] = base[dev_num];
+
+	/* creating the region for IO is pretty easy */
+	return (request_region(base[dev_num], num_regs, drv_name))? 1 : 0;
+}
+
+/* release controller register access space */
+void hal_release_region(int dev_num,
+			unsigned int num_regs)
+{
+	extern unsigned long base[];
+
+	release_region(base[dev_num], num_regs);
+}
+
+/* enable non controller hardware (e.g. irq routing, etc.) */
+int hw_attach(int dev_num) {
+
+	/* Unlock special function register */
+	outb(5, 0x169);
+
+	return 0;
+}
+
+/* disable non controller hardware (e.g. irq routing, etc.) */
+int hw_detach(int dev_num) { return 0; }
+
+/* reset controller hardware (with specific non controller hardware) */
+int hw_reset_dev(int dev_num) { return 0; }
+
+/* read from controller register */
+u8 hw_readreg(unsigned long base, int reg) {
+
+	return inb(base + reg);
+}
+
+/* write to controller register */
+void hw_writereg(unsigned long base, int reg, u8 val) {
+
+	outb(val, base + reg);
+}
+
+/* hardware specific work to do at start of irq handler */
+void hw_preirq(struct net_device *dev) { return; }
+
+/* hardware specific work to do at end of irq handler */
+void hw_postirq(struct net_device *dev) { return; }
+
Index: drivers/net/can/i82527/Makefile
===================================================================
--- /dev/null
+++ drivers/net/can/i82527/Makefile
@@ -0,0 +1,62 @@
+#
+#
+#  Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#  1. Redistributions of source code must retain the above copyright
+#     notice, this list of conditions, the following disclaimer and
+#     the referenced file 'COPYING'.
+#  2. Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#  3. Neither the name of Volkswagen nor the names of its contributors
+#     may be used to endorse or promote products derived from this software
+#     without specific prior written permission.
+#
+#  Alternatively, provided that this notice is retained in full, this
+#  software may be distributed under the terms of the GNU General
+#  Public License ("GPL") version 2 as distributed in the 'COPYING'
+#  file from the main directory of the linux kernel source.
+#
+#  The provided data structures and external interfaces from this code
+#  are not restricted to be used by modules with a GPL compatible license.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+#  DAMAGE.
+#
+#  Send feedback to <socketcan-users@lists.berlios.de>
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+EXTRA_CFLAGS += -I$(TOPDIR)/drivers/net/can/hal
+
+obj-m := i82527-pc7io.o i82527-iomem.o i82527-esdio.o
+
+i82527-pc7io-objs := i82527.o proc.o ../hal/pc7io.o
+i82527-iomem-objs := i82527.o proc.o ../hal/iomem.o
+i82527-esdio-objs := i82527.o proc.o ../hal/esdio.o
+
+endif
Index: drivers/net/can/i82527/i82527.c
===================================================================
--- /dev/null
+++ drivers/net/can/i82527/i82527.c
@@ -0,0 +1,1285 @@
+/*
+ * i82527.c -  Intel I82527 network device driver
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+
+#include <linux/can.h>
+#include <linux/can/ioctl.h> /* for struct can_device_stats */
+#include "hal.h"
+#include "i82527.h"
+
+MODULE_AUTHOR("Oliver Hartkopp <oliver.hartkopp@volkswagen.de>");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("LLCF/socketcan '" CHIP_NAME "' network device driver");
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+#define DBG(args...)   ((priv->debug > 0) ? printk(args) : 0)
+/* logging in interrupt context! */
+#define iDBG(args...)  ((priv->debug > 1) ? printk(args) : 0)
+#define iiDBG(args...) ((priv->debug > 2) ? printk(args) : 0)
+#else
+#define DBG(args...)
+#define iDBG(args...)
+#define iiDBG(args...)
+#endif
+
+char drv_name[DRV_NAME_LEN] = "undefined";
+
+/* driver and version information */
+static const char *drv_version	= "0.0.4";
+static const char *drv_reldate	= "2007-08-03";
+
+static const canid_t rxobjflags[] = {0, CAN_EFF_FLAG,
+				     CAN_RTR_FLAG, CAN_RTR_FLAG | CAN_EFF_FLAG,
+				     0, CAN_EFF_FLAG}; 
+#define RXOBJBASE 10
+
+/* array of all can chips */
+struct net_device *can_dev[MAXDEV];
+
+/* module parameters */
+unsigned long base[MAXDEV]	= { 0 }; /* hardware address */
+unsigned long rbase[MAXDEV]	= { 0 }; /* (remapped) device address */
+unsigned int  irq[MAXDEV]	= { 0 };
+
+unsigned int speed[MAXDEV]	= { DEFAULT_SPEED, DEFAULT_SPEED };
+unsigned int btr[MAXDEV]	= { 0 };
+unsigned int bcr[MAXDEV]	= { 0 }; /* bus configuration register */
+unsigned int cdv[MAXDEV]	= { 0 }; /* CLKOUT clock divider */
+unsigned int mo15[MAXDEV]	= { MO15_DEFLT, MO15_DEFLT }; /* msg obj 15 */
+
+static int rx_probe[MAXDEV]	= { 0 };
+static int clk			= DEFAULT_HW_CLK;
+static int force_dmc		= DEFAULT_FORCE_DMC;
+static int irq_mode		= DEFAULT_IRQ_MODE;
+static int debug		= 0;
+static int restart_ms		= 100;
+
+static int base_n;
+static int irq_n;
+static int speed_n;
+static int btr_n;
+static int bcr_n;
+static int cdv_n;
+static int mo15_n;
+static int rx_probe_n;
+
+static u8 dsc; /* devide system clock */
+static u8 dmc; /* devide memory clock */
+static unsigned long irqflags; /* for shared / disabled local interrupts */
+
+module_param_array(base, int, &base_n, 0);
+module_param_array(irq, int, &irq_n, 0);
+module_param_array(speed, int, &speed_n, 0);
+module_param_array(btr, int, &btr_n, 0);
+module_param_array(bcr, int, &bcr_n, 0);
+module_param_array(cdv, int, &cdv_n, 0);
+module_param_array(mo15, int, &mo15_n, 0);
+module_param_array(rx_probe, int, &rx_probe_n, 0);
+
+module_param(clk, int, 0);
+module_param(force_dmc, int, 0);
+module_param(irq_mode, int, 0);
+module_param(debug, int, 0);
+module_param(restart_ms, int, 0);
+
+MODULE_PARM_DESC(base, "CAN controller base address");
+MODULE_PARM_DESC(irq, "CAN controller interrupt");
+MODULE_PARM_DESC(speed, "CAN bus bitrate");
+MODULE_PARM_DESC(btr, "Bit Timing Register value 0x<btr0><btr1>, e.g. 0x4014");
+MODULE_PARM_DESC(bcr, "i82527 bus configuration register value (default: 0)");
+MODULE_PARM_DESC(cdv, "clockout devider value (0-14) (default: 0)");
+MODULE_PARM_DESC(mo15, "rx message object 15 usage. 0:none 1:sff(default) 2:eff");
+MODULE_PARM_DESC(rx_probe, "switch to trx mode after correct msg receiption. (default off)");
+
+MODULE_PARM_DESC(clk, "CAN controller chip clock (default: 16MHz)");
+MODULE_PARM_DESC(force_dmc, "set i82527 DMC bit (default: calculate from clk)"); 
+MODULE_PARM_DESC(irq_mode, "specify irq setup bits (1:shared 2:disable local irqs while processing) (default: 1)"); 
+MODULE_PARM_DESC(debug, "set debug mask (default: 0)");
+MODULE_PARM_DESC(restart_ms, "restart chip on heavy bus errors / bus off after x ms (default 100ms)");
+
+/* function declarations */
+
+static void chipset_init(struct net_device *dev, int wake);
+static void chipset_init_rx(struct net_device *dev);
+static void chipset_init_trx(struct net_device *dev);
+static void can_netdev_setup(struct net_device *dev);
+static struct net_device* can_create_netdev(int dev_num, int hw_regs);
+static int  can_set_drv_name(void);
+int set_reset_mode(struct net_device *dev);
+
+static int i82527_probe_chip(unsigned long base)
+{
+	// Check if hardware reset is still inactive OR
+	// maybe there is no chip in this address space
+	if (CANin(base, cpuInterfaceReg) & iCPU_RST) {
+		printk(KERN_INFO "%s: probing @ 0x%lX failed (reset)\n",
+		       drv_name, base);
+		return 0;
+	}
+
+	// Write test pattern
+	CANout(base, message1Reg.dataReg[1], 0x25);
+	CANout(base, message2Reg.dataReg[3], 0x52);
+	CANout(base, message10Reg.dataReg[6], 0xc3);
+
+	// Read back test pattern
+	if ((CANin(base, message1Reg.dataReg[1]) != 0x25 ) ||
+	    (CANin(base, message2Reg.dataReg[3]) != 0x52 ) ||
+	    (CANin(base, message10Reg.dataReg[6]) != 0xc3 )) {
+		printk(KERN_INFO "%s: probing @ 0x%lX failed (pattern)\n",
+		       drv_name, base);
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * set baud rate divisor values
+ */
+static void set_btr(struct net_device *dev, int btr0, int btr1)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base = dev->base_addr;
+
+	/* no bla bla when restarting the device */
+	if (priv->state == STATE_UNINITIALIZED)
+		printk(KERN_INFO "%s: setting BTR0=%02X BTR1=%02X\n",
+		       dev->name, btr0, btr1);
+
+	CANout(base, bitTiming0Reg, btr0);
+	CANout(base, bitTiming1Reg, btr1);
+}
+
+/*
+ * calculate baud rate divisor values
+ */
+static void set_baud(struct net_device *dev, int baud, int clock)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	int error;
+	int brp;
+	int tseg;
+	int tseg1 = 0;
+	int tseg2 = 0;
+
+	int best_error = 1000000000;
+	int best_tseg = 0;
+	int best_brp = 0;
+	int best_baud = 0;
+
+	int SAM = (baud > 100000 ? 0 : 1);
+
+	if (dsc) /* devide system clock */
+		clock >>= 1; /* calculate BTR with this value */
+
+	for (tseg = (0 + 0 + 2) * 2;
+	     tseg <= (MAX_TSEG2 + MAX_TSEG1 + 2) * 2 + 1;
+	     tseg++) {
+		brp = clock / ((1 + tseg / 2) * baud) + tseg % 2;
+		if ((brp > 0) && (brp <= 64)) {
+			error = baud - clock / (brp * (1 + tseg / 2));
+			if (error < 0) {
+				error = -error;
+			}
+			if (error <= best_error) {
+				best_error = error;
+				best_tseg = tseg / 2;
+				best_brp = brp - 1;
+				best_baud = clock / (brp * (1 + tseg / 2));
+			}
+		}
+	}
+	if (best_error && (baud / best_error < 10)) {
+		printk("%s: unable to set baud rate %d (ext clock %dHz)\n",
+		       dev->name, baud, clock * 2);
+		return;
+//		return -EINVAL;
+	}
+	tseg2 = best_tseg - (SAMPLE_POINT * (best_tseg + 1)) / 100;
+	if (tseg2 < 0) {
+		tseg2 = 0;
+	} else if (tseg2 > MAX_TSEG2) {
+		tseg2 = MAX_TSEG2;
+	}
+	tseg1 = best_tseg - tseg2 - 2;
+	if (tseg1 > MAX_TSEG1) {
+		tseg1 = MAX_TSEG1;
+		tseg2 = best_tseg - tseg1 - 2;
+	}
+
+	priv->btr = ((best_brp | JUMPWIDTH)<<8) + 
+		((SAM << 7) | (tseg2 << 4) | tseg1);
+
+	printk(KERN_INFO "%s: calculated best baudrate: %d / btr is 0x%04X\n",
+	       dev->name, best_baud, priv->btr);
+
+	set_btr(dev, (priv->btr>>8) & 0xFF, priv->btr & 0xFF);
+//	set_btr(dev, best_brp | JUMPWIDTH, (SAM << 7) | (tseg2 << 4) | tseg1);
+}
+
+static inline int obj2rxo(int obj)
+{
+	/* obj4 = obj15 SFF, obj5 = obj15 EFF */ 
+	if (obj < 4)
+		return RXOBJBASE + obj;
+	else
+		return 15;
+}
+
+void enable_rx_obj(unsigned long base, int obj)
+{
+	u8 mcfg = 0;
+	int rxo = obj2rxo(obj);
+
+	// Configure message object for receiption
+	if (rxobjflags[obj] & CAN_EFF_FLAG)
+		mcfg = MCFG_XTD;
+
+	if (rxobjflags[obj] & CAN_RTR_FLAG) {
+		CANout(base, msgArr[rxo].messageReg.messageConfigReg,
+		       mcfg | MCFG_DIR);
+		CANout(base, msgArr[rxo].messageReg.msgCtrl0Reg,
+		       MVAL_SET | TXIE_RES | RXIE_SET | INTPD_RES);
+		CANout(base, msgArr[rxo].messageReg.msgCtrl1Reg,
+		       NEWD_RES | CPUU_SET | TXRQ_RES | RMPD_RES);
+	} else {
+		CANout(base, msgArr[rxo].messageReg.messageConfigReg, mcfg);
+		CANout(base, msgArr[rxo].messageReg.msgCtrl0Reg,
+		       MVAL_SET | TXIE_RES | RXIE_SET | INTPD_RES);
+		CANout(base, msgArr[rxo].messageReg.msgCtrl1Reg,
+		       NEWD_RES | MLST_RES | TXRQ_RES | RMPD_RES);
+	}
+}
+
+void disable_rx_obj(unsigned long base, int obj)
+{
+	int rxo = obj2rxo(obj);
+
+	CANout(base, msgArr[rxo].messageReg.msgCtrl1Reg,
+	       NEWD_RES | MLST_RES | TXRQ_RES | RMPD_RES);
+	CANout(base, msgArr[rxo].messageReg.msgCtrl0Reg,
+	       MVAL_RES | TXIE_RES | RXIE_RES | INTPD_RES);
+}
+
+int set_reset_mode(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base = dev->base_addr;
+
+	// Configure cpu interface
+	CANout(base, cpuInterfaceReg,(dsc | dmc | iCPU_CEN));
+
+	// Enable configuration and puts chip in bus-off, disable interrupts
+	CANout(base, controlReg, iCTL_CCE | iCTL_INI);
+
+	// Clear interrupts
+	CANin(base, interruptReg);
+
+	// Clear status register
+	CANout(base, statusReg, 0);
+
+	// Clear message objects for receiption
+	if (priv->mo15 == MO15_SFF)
+		disable_rx_obj(base, 4); /* rx via obj15 SFF */
+	else
+		disable_rx_obj(base, 0); /* rx via obj10 SFF */
+
+	if (priv->mo15 == MO15_EFF)
+		disable_rx_obj(base, 5); /* rx via obj15 EFF */
+	else
+		disable_rx_obj(base, 1); /* rx via obj11 EFF */
+
+	disable_rx_obj(base, 2);
+	disable_rx_obj(base, 3);
+
+	// Clear message object for send
+	CANout(base, message1Reg.msgCtrl1Reg,
+	       RMPD_RES | TXRQ_RES | CPUU_RES | NEWD_RES);
+	CANout(base, message1Reg.msgCtrl0Reg,
+	       MVAL_RES | TXIE_RES | RXIE_RES | INTPD_RES);
+
+	DBG(KERN_INFO "%s: %s: CtrlReg 0x%x CPUifReg 0x%x\n",
+	    dev->name, __FUNCTION__,
+	    CANin(base, controlReg), CANin(base, cpuInterfaceReg));
+
+	return 0;
+}
+
+static int set_normal_mode(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base = dev->base_addr;
+
+	// Clear interrupts
+	CANin(base, interruptReg);
+
+	// Clear status register
+	CANout(base, statusReg, 0);
+
+	// Configure message objects for receiption
+	if (priv->mo15 == MO15_SFF) {
+		enable_rx_obj(base, 4); /* rx via obj15 SFF */
+		printk(KERN_INFO "%s: %s: using msg object 15 for "
+		       "SFF receiption.\n",
+		       dev->name, CHIP_NAME);
+	} else
+		enable_rx_obj(base, 0); /* rx via obj10 SFF */
+
+	if (priv->mo15 == MO15_EFF) {
+		enable_rx_obj(base, 5); /* rx via obj15 EFF */
+		printk(KERN_INFO "%s: %s: using msg object 15 for "
+		       "EFF receiption.\n",
+		       dev->name, CHIP_NAME);
+	} else
+		enable_rx_obj(base, 1); /* rx via obj11 EFF */
+
+	enable_rx_obj(base, 2);
+	enable_rx_obj(base, 3);
+
+	// Clear message object for send
+	CANout(base, message1Reg.msgCtrl1Reg,
+	       RMPD_RES | TXRQ_RES | CPUU_RES | NEWD_RES);
+	CANout(base, message1Reg.msgCtrl0Reg,
+	       MVAL_RES | TXIE_RES | RXIE_RES | INTPD_RES);
+
+	return 0;
+}
+
+static int set_listen_mode(struct net_device *dev)
+{
+	return set_normal_mode(dev); /* for now */
+}
+
+/*
+ * Clear and invalidate message objects
+ */
+int i82527_clear_msg_objects(unsigned long base)
+{
+    int i;
+    int id;
+    int data;
+
+    for (i = 1; i <= 15; i++) {
+	    CANout(base, msgArr[i].messageReg.msgCtrl0Reg,
+		   INTPD_UNC | RXIE_RES | TXIE_RES | MVAL_RES);
+	    CANout(base, msgArr[i].messageReg.msgCtrl0Reg,
+		   INTPD_RES | RXIE_RES | TXIE_RES | MVAL_RES);
+	    CANout(base, msgArr[i].messageReg.msgCtrl1Reg,
+		   NEWD_RES | MLST_RES | TXRQ_RES | RMPD_RES);
+	    for (data = 0; data < 8; data++)
+		    CANout(base, msgArr[i].messageReg.dataReg[data], 0);
+	    for (id = 0; id < 4; id++)
+		    CANout(base, msgArr[i].messageReg.idReg[id], 0);
+	    CANout(base, msgArr[i].messageReg.messageConfigReg, 0);
+    }
+
+    return 0;
+}
+
+/*
+ * initialize I82527 chip:
+ *   - reset chip
+ *   - set output mode
+ *   - set baudrate
+ *   - enable interrupts
+ *   - start operating mode
+ */
+static void chipset_init_regs(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base = dev->base_addr;
+
+	// Enable configuration and puts chip in bus-off, disable interrupts
+	CANout(base, controlReg, (iCTL_CCE | iCTL_INI));
+
+	// Set CLKOUT devider and slew rates is was done in i82527_init_module
+
+	// Bus configuration was done in i82527_init_module
+
+	// Clear interrupts
+	CANin(base, interruptReg);
+
+	// Clear status register
+	CANout(base, statusReg, 0);
+
+	i82527_clear_msg_objects(base);
+
+	// Set all global ID masks to "don't care"
+	CANout(base, globalMaskStandardReg[0], 0);	
+	CANout(base, globalMaskStandardReg[1], 0);
+	CANout(base, globalMaskExtendedReg[0], 0);
+	CANout(base, globalMaskExtendedReg[1], 0);
+	CANout(base, globalMaskExtendedReg[2], 0);
+	CANout(base, globalMaskExtendedReg[3], 0);
+
+	DBG(KERN_INFO "%s: %s: CtrlReg 0x%x CPUifReg 0x%x\n",
+	    dev->name, __FUNCTION__,
+	    CANin(base, controlReg), CANin(base, cpuInterfaceReg));
+
+	// Note: At this stage the CAN ship is still in bus-off condition
+	// and must be started using StartChip()
+
+	/* set baudrate */
+	if (priv->btr) { /* no calculation when btr is provided */
+		set_btr(dev, (priv->btr>>8) & 0xFF, priv->btr & 0xFF);
+	} else {
+		if (priv->speed == 0) {
+			priv->speed = DEFAULT_SPEED;
+		}
+		set_baud(dev, priv->speed * 1000, priv->clock);
+	}
+
+}
+
+static void chipset_init(struct net_device *dev, int wake)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (priv->rx_probe)
+		chipset_init_rx(dev); /* wait for valid reception first */
+	else
+		chipset_init_trx(dev);
+
+	if ((wake) && netif_queue_stopped(dev))
+		netif_wake_queue(dev);
+}
+
+static void chipset_init_rx(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base    = dev->base_addr;
+
+	iDBG(KERN_INFO "%s: %s()\n", dev->name, __FUNCTION__);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	/* set registers */
+	chipset_init_regs(dev);
+
+	/* automatic bit rate detection */
+	set_listen_mode(dev);
+
+	priv->state = STATE_PROBE;
+
+	// Clear bus-off, Interrupts only for errors, not for status change
+	CANout(base, controlReg, iCTL_IE | iCTL_EIE);
+
+	DBG(KERN_INFO "%s: %s: CtrlReg 0x%x CPUifReg 0x%x\n",
+	    dev->name, __FUNCTION__,
+	    CANin(base, controlReg), CANin(base, cpuInterfaceReg));
+}
+
+static void chipset_init_trx(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base    = dev->base_addr;
+
+	iDBG(KERN_INFO "%s: %s()\n", dev->name, __FUNCTION__);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	/* set registers */
+	chipset_init_regs(dev);
+
+	/* leave reset mode */
+	set_normal_mode(dev);
+
+	priv->state = STATE_ACTIVE;
+
+	// Clear bus-off, Interrupts only for errors, not for status change
+	CANout(base, controlReg, iCTL_IE | iCTL_EIE);
+
+	DBG(KERN_INFO "%s: %s: CtrlReg 0x%x CPUifReg 0x%x\n",
+	    dev->name, __FUNCTION__,
+	    CANin(base, controlReg), CANin(base, cpuInterfaceReg));
+}
+
+/*
+ * transmit a CAN message
+ * message layout in the sk_buff should be like this:
+ * xx xx xx xx  ll   00 11 22 33 44 55 66 77
+ * [  can-id ] [len] [can data (up to 8 bytes]
+ */
+static int can_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct can_priv  *priv	= netdev_priv(dev);
+	struct can_frame *cf	= (struct can_frame*)skb->data;
+	unsigned long base	= dev->base_addr;
+	uint8_t	dlc;
+	uint8_t	rtr;
+	canid_t	id;
+	int	i;
+
+	if ((CANin(base, message1Reg.msgCtrl1Reg) & TXRQ_UNC) == TXRQ_SET) {
+		printk(KERN_ERR "%s: %s: TX register is occupied!\n",
+		       dev->name, drv_name);
+		return 0;
+	}
+
+	netif_stop_queue(dev);
+
+	dlc = cf->can_dlc;
+	id  = cf->can_id;
+
+	if ( cf->can_id & CAN_RTR_FLAG )
+		rtr = 0;
+	else
+		rtr = MCFG_DIR;
+
+	CANout(base, message1Reg.msgCtrl1Reg,
+	       RMPD_RES | TXRQ_RES | CPUU_SET | NEWD_RES);
+	CANout(base, message1Reg.msgCtrl0Reg,
+	       MVAL_SET | TXIE_SET | RXIE_RES | INTPD_RES);
+
+	if (id & CAN_EFF_FLAG) {
+		id &= CAN_EFF_MASK;
+		CANout(base, message1Reg.messageConfigReg,
+		       (dlc << 4) + rtr + MCFG_XTD);
+		CANout(base, message1Reg.idReg[3], (id << 3) & 0xFFU);
+		CANout(base, message1Reg.idReg[2], (id >> 5) & 0xFFU);
+		CANout(base, message1Reg.idReg[1], (id >> 13) & 0xFFU);
+		CANout(base, message1Reg.idReg[0], (id >> 21) & 0xFFU);
+	}
+	else {
+		id &= CAN_SFF_MASK;
+		CANout(base, message1Reg.messageConfigReg,
+		       ( dlc << 4 ) + rtr);
+		CANout(base, message1Reg.idReg[0], (id >> 3) & 0xFFU);
+		CANout(base, message1Reg.idReg[1], (id << 5) & 0xFFU);
+	}
+
+	dlc &= 0x0f; //restore length only
+	for ( i=0; i < dlc; i++ ) {
+		CANout(base, message1Reg.dataReg[i],
+		       cf->data[i]);
+	}
+
+	CANout(base, message1Reg.msgCtrl1Reg,
+	       (RMPD_RES | TXRQ_SET | CPUU_RES | NEWD_UNC));
+
+	// HM: We had some cases of repeated IRQs
+	// so make sure the INT is acknowledged
+	// I know it's already further up, but doing again fixed the issue
+	CANout(base, message1Reg.msgCtrl0Reg,
+	       (MVAL_UNC | TXIE_UNC | RXIE_UNC | INTPD_RES));
+
+	priv->stats.tx_bytes += dlc;
+
+	dev->trans_start = jiffies;
+
+	kfree_skb(skb);
+
+	return 0;
+}
+
+static void can_tx_timeout(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	priv->stats.tx_errors++;
+
+	/* do not conflict with e.g. bus error handling */
+	if (!(priv->timer.expires)){ /* no restart on the run */
+		chipset_init_trx(dev); /* no tx queue wakeup */
+		netif_wake_queue(dev); /* wakeup here */
+	}
+	else
+		DBG(KERN_INFO "%s: %s: can_restart_dev already active.\n",
+		    dev->name, __FUNCTION__ );
+
+}
+
+# if 0
+static void can_restart_on(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (!(priv->timer.expires)){ /* no restart on the run */
+
+		set_reset_mode(dev);
+
+		priv->timer.function = can_restart_dev;
+		priv->timer.data = (unsigned long) dev;
+
+		/* restart chip on persistent error in <xxx> ms */
+		priv->timer.expires = jiffies + (priv->restart_ms * HZ) / 1000;
+		add_timer(&priv->timer);
+
+		iDBG(KERN_INFO "%s: %s start (%ld)\n",
+		     dev->name, __FUNCTION__ , jiffies);
+	} else
+		iDBG(KERN_INFO "%s: %s already (%ld)\n",
+		     dev->name, __FUNCTION__ , jiffies);
+}
+
+static void can_restart_dev(unsigned long data)
+{
+	struct net_device *dev = (struct net_device*) data;
+	struct can_priv *priv = netdev_priv(dev);
+
+	DBG(KERN_INFO "%s: can_restart_dev (%ld)\n",
+	    dev->name, jiffies);
+
+	/* mark inactive timer */
+	priv->timer.expires = 0;
+
+	if (priv->state != STATE_UNINITIALIZED) {
+
+		/* count number of restarts */
+		priv->can_stats.restarts++;
+
+		chipset_init(dev, 1);
+	}
+}
+#endif
+
+#if 0
+/* the timerless version */
+
+static void can_restart_now(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (priv->state != STATE_UNINITIALIZED) {
+
+		/* count number of restarts */
+		priv->can_stats.restarts++;
+
+		chipset_init(dev, 1);
+	}
+}
+#endif
+
+/*
+ * Subroutine of ISR for RX interrupts.
+ *
+ */
+static void can_rx(struct net_device *dev, int obj)
+{
+	struct can_priv *priv	= netdev_priv(dev);
+	unsigned long base	= dev->base_addr;
+	struct can_frame *cf;
+	struct sk_buff	*skb;
+	uint8_t msgctlreg;
+	uint8_t ctl1reg;
+	canid_t	id;
+	uint8_t	dlc;
+	int	i;
+	int	rxo = obj2rxo(obj);
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (skb == NULL) {
+		return;
+	}
+	skb->dev = dev;
+	skb->protocol = htons(ETH_P_CAN);
+	skb->pkt_type = PACKET_BROADCAST;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+	ctl1reg = CANin(base, msgArr[rxo].messageReg.msgCtrl1Reg);
+	msgctlreg = CANin(base, msgArr[rxo].messageReg.messageConfigReg);
+
+	if( msgctlreg & MCFG_XTD ) {
+		id = CANin(base, msgArr[rxo].messageReg.idReg[3])
+			| (CANin(base, msgArr[rxo].messageReg.idReg[2]) << 8)
+			| (CANin(base, msgArr[rxo].messageReg.idReg[1]) << 16)
+			| (CANin(base, msgArr[rxo].messageReg.idReg[0]) << 24);
+		id >>= 3;
+		id |= CAN_EFF_FLAG;
+	} else {
+		id = CANin(base, msgArr[rxo].messageReg.idReg[1])
+			|(CANin(base, msgArr[rxo].messageReg.idReg[0]) << 8);
+		id >>= 5;
+	}
+
+	if (ctl1reg & RMPD_SET) {
+		id |= CAN_RTR_FLAG;
+	}
+
+	msgctlreg  &= 0xf0;/* strip length code */
+	dlc  = msgctlreg >> 4;
+	dlc %= 9;	/* limit count to 8 bytes */
+
+	cf = (struct can_frame*)skb_put(skb, sizeof(struct can_frame));
+	memset(cf, 0, sizeof(struct can_frame));
+	cf->can_id    = id;
+	cf->can_dlc   = dlc;
+	for (i = 0; i < dlc; i++) {
+		cf->data[i] = CANin(base, msgArr[rxo].messageReg.dataReg[i]);
+	}
+
+	// Make the chip ready to receive the next message
+	enable_rx_obj(base, obj);
+
+	netif_rx(skb);
+
+	dev->last_rx = jiffies;
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += dlc;
+}
+
+static struct net_device_stats *can_get_stats(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* TODO: read statistics from chip */
+	return &priv->stats;
+}
+
+static int can_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	switch (cmd) {
+	case SIOCSCANBAUDRATE:
+		;
+		return 0;
+	case SIOCGCANBAUDRATE:
+		;
+		return 0;
+	}
+	return 0;
+}
+
+/*
+ * I82527 interrupt handler
+ */
+static irqreturn_t can_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev	= (struct net_device*)dev_id;
+	struct can_priv *priv	= netdev_priv(dev);
+	unsigned long base	= dev->base_addr;
+	uint8_t irqreg;
+	uint8_t lastIrqreg;
+	int n = 0;
+
+	hw_preirq(dev);
+
+	iiDBG(KERN_INFO "%s: interrupt\n", dev->name);
+
+	if (priv->state == STATE_UNINITIALIZED) {
+		printk(KERN_ERR "%s: %s: uninitialized controller!\n",
+		       dev->name, __FUNCTION__);
+		//chipset_init(dev, 1); /* should be possible at this stage */
+		return IRQ_NONE;
+	}
+
+	if (priv->state == STATE_RESET_MODE) {
+		iiDBG(KERN_ERR "%s: %s: controller is in reset mode!\n",
+		      dev->name, __FUNCTION__);
+		return IRQ_NONE;
+	}
+
+     
+	// Read the highest pending interrupt request
+	irqreg = CANin(base, interruptReg);
+	lastIrqreg = irqreg;
+    
+	while ( irqreg ) {
+		n++;
+		switch (irqreg)	{
+
+		case 1: // Status register
+		{
+			uint8_t status;
+
+			// Read the STATUS reg
+			status = CANin(base, statusReg);
+			CANout (base, statusReg, 0);
+
+			if ( status & iSTAT_RXOK ) {
+				// Intel: Software must clear this bit in ISR
+				CANout (base, statusReg, status & ~iSTAT_RXOK);
+			}
+			if ( status & iSTAT_TXOK ) {
+				// Intel: Software must clear this bit in ISR
+				CANout (base, statusReg, status & ~iSTAT_TXOK);
+			}
+			if ( status & iSTAT_WARN ) {
+				// Note: status bit is read-only, don't clear
+				/* error warning interrupt */
+				iDBG(KERN_INFO "%s: error warning\n",
+				     dev->name);
+				priv->can_stats.error_warning++;
+			}
+			if ( status & iSTAT_BOFF ) {
+				uint8_t flags;
+
+				// Note: status bit is read-only, don't clear
+
+				priv->can_stats.bus_error++;
+
+				// Clear init flag and reenable interrupts
+				flags = CANin(base, controlReg) |
+					( iCTL_IE | iCTL_EIE );
+
+				flags &= ~iCTL_INI; // Reset init flag
+				CANout(base, controlReg, flags);
+			}
+		}
+		break;
+
+		case 0x2: // Receiption, message object 15
+		{
+			uint8_t ctl1reg;
+
+			ctl1reg = CANin(base, message15Reg.msgCtrl1Reg);
+			while (ctl1reg & NEWD_SET) {
+				if (ctl1reg & MLST_SET)
+					priv->can_stats.data_overrun++;
+
+				if (priv->mo15 == MO15_SFF)
+					can_rx(dev, 4); /* rx via obj15 SFF */
+				else
+					can_rx(dev, 5); /* rx via obj15 EFF */
+
+				ctl1reg = CANin(base, message15Reg.msgCtrl1Reg);
+			}
+
+			if (priv->state == STATE_PROBE) {
+				/* valid RX -> switch to trx-mode */
+				chipset_init_trx(dev); /* no tx queue wakeup */
+				break; /* check again after init controller */
+			}
+		}
+		break;
+
+		case 0xC: // Receiption, message object 10
+		case 0xD: // Receiption, message object 11
+		{
+			int obj = irqreg - 0xC;
+			int rxo = obj2rxo(obj);
+			uint8_t ctl1reg;
+			ctl1reg = CANin(base, msgArr[rxo].messageReg.msgCtrl1Reg);
+			while (ctl1reg & NEWD_SET) {
+				if (ctl1reg & MLST_SET)
+					priv->can_stats.data_overrun++;
+				CANout(base, msgArr[rxo].messageReg.msgCtrl1Reg,
+				       NEWD_RES | MLST_RES | TXRQ_UNC | RMPD_UNC);
+				can_rx(dev, obj);
+				ctl1reg = CANin(base,
+						msgArr[rxo].messageReg.msgCtrl1Reg);
+			}
+
+			if (priv->state == STATE_PROBE) {
+				/* valid RX -> switch to trx-mode */
+				chipset_init_trx(dev); /* no tx queue wakeup */
+				break; /* check again after init controller */
+			}
+		}
+		break;
+
+		case 0xE: // Receiption, message object 12 (RTR)
+		case 0xF: // Receiption, message object 13 (RTR)
+		{
+			int obj = irqreg - 0xC;
+			int rxo = obj2rxo(obj);
+			uint8_t ctl0reg;
+			ctl0reg = CANin(base, msgArr[rxo].messageReg.msgCtrl0Reg);
+			while (ctl0reg & INTPD_SET) {
+				can_rx(dev, obj);
+				ctl0reg = CANin(base, msgArr[rxo].messageReg.msgCtrl0Reg);
+			}
+
+			if (priv->state == STATE_PROBE) {
+				/* valid RX -> switch to trx-mode */
+				chipset_init_trx(dev); /* no tx queue wakeup */
+				break; /* check again after init controller */
+			}
+		}
+		break;
+
+		case 3: // Message object 1 (our write object)
+			/* transmission complete interrupt */
+
+			// Nothing more to send, switch off interrupts
+			CANout(base, message1Reg.msgCtrl0Reg,
+			       (MVAL_RES | TXIE_RES | RXIE_RES | INTPD_RES));
+			// We had some cases of repeated IRQ
+			// so make sure the INT is acknowledged
+			CANout(base, message1Reg.msgCtrl0Reg,
+			       (MVAL_UNC | TXIE_UNC | RXIE_UNC | INTPD_RES));
+
+			priv->stats.tx_packets++;
+			netif_wake_queue(dev);
+			break;
+
+		default: // Unexpected
+			iDBG(KERN_INFO "%s: Unexpected i82527 interrupt: "
+			     "irqreq=0x%X\n", dev->name, irqreg);
+			break;
+		}
+
+		// Get irq status again for next loop iteration
+		irqreg = CANin(base, interruptReg);
+		if (irqreg == lastIrqreg)
+			iDBG(KERN_INFO "%s: i82527 interrupt repeated: "
+			     "irqreq=0x%X\n", dev->name, irqreg);
+
+		lastIrqreg = irqreg;
+	} /* end while (irqreq) */
+
+	if (n > 1) {
+		iDBG(KERN_INFO "%s: handled %d IRQs\n", dev->name, n);
+	}
+
+	hw_postirq(dev);
+
+	return n == 0 ? IRQ_NONE : IRQ_HANDLED;
+}
+
+/*
+ * initialize CAN bus driver
+ */
+static int can_open(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	priv->state = STATE_UNINITIALIZED;
+
+	/* register interrupt handler */
+	if (request_irq(dev->irq, &can_interrupt, irqflags,
+			dev->name, (void*)dev))
+		return -EAGAIN;
+
+	/* clear statistics */
+	memset(&priv->stats, 0, sizeof(priv->stats));
+
+	/* init chip */
+	chipset_init(dev, 0);
+	priv->open_time = jiffies;
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+/*
+ * stop CAN bus activity
+ */
+static int can_close(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	priv->open_time = 0;
+
+	if (priv->timer.expires) {
+		del_timer(&priv->timer);
+		priv->timer.expires = 0;
+	}
+
+	free_irq(dev->irq, (void*)dev);
+	priv->state = STATE_UNINITIALIZED;
+
+	netif_stop_queue(dev);
+
+	return 0;
+}
+
+void can_netdev_setup(struct net_device *dev)
+{
+	/* Fill in the the fields of the device structure
+	   with CAN netdev generic values */
+
+	dev->change_mtu			= NULL;
+	dev->hard_header		= NULL;
+	dev->rebuild_header		= NULL;
+	dev->set_mac_address		= NULL;
+	dev->hard_header_cache		= NULL;
+	dev->header_cache_update	= NULL;
+	dev->hard_header_parse		= NULL;
+
+	dev->type			= ARPHRD_CAN;
+	dev->hard_header_len		= 0;
+	dev->mtu			= sizeof(struct can_frame);
+	dev->addr_len			= 0;
+	dev->tx_queue_len		= 10;
+
+	dev->flags			= IFF_NOARP;
+	dev->features			= NETIF_F_NO_CSUM;
+
+	dev->open			= can_open;
+	dev->stop			= can_close;
+	dev->hard_start_xmit		= can_start_xmit;
+	dev->get_stats			= can_get_stats;
+	dev->do_ioctl           	= can_ioctl;
+
+	dev->tx_timeout			= can_tx_timeout;
+	dev->watchdog_timeo		= TX_TIMEOUT;
+
+	SET_MODULE_OWNER(dev);
+}
+
+static struct net_device* can_create_netdev(int dev_num, int hw_regs)
+{
+	struct net_device	*dev;
+	struct can_priv		*priv;
+
+	const char mo15mode [3][6] = {"none", "sff", "eff"};
+
+	if (!(dev = alloc_netdev(sizeof(struct can_priv), CAN_NETDEV_NAME,
+				 can_netdev_setup))) {
+		printk(KERN_ERR "%s: out of memory\n", CHIP_NAME);
+		return NULL;
+	}
+
+	printk(KERN_INFO "%s: base 0x%lX / irq %d / speed %d / "
+	       "btr 0x%X / rx_probe %d / mo15 %s\n",
+	       drv_name, rbase[dev_num], irq[dev_num],
+	       speed[dev_num], btr[dev_num], rx_probe[dev_num],
+	       mo15mode[mo15[dev_num]]);
+
+	/* fill net_device structure */
+
+	priv             = netdev_priv(dev);
+
+	dev->irq         = irq[dev_num];
+	dev->base_addr   = rbase[dev_num];
+
+	priv->speed      = speed[dev_num];
+	priv->btr        = btr[dev_num];
+	priv->rx_probe   = rx_probe[dev_num];
+	priv->mo15       = mo15[dev_num];
+	priv->clock      = clk;
+	priv->hw_regs    = hw_regs;
+	priv->restart_ms = restart_ms;
+	priv->debug      = debug;
+
+	init_timer(&priv->timer);
+	priv->timer.expires = 0;
+
+	if (register_netdev(dev)) {
+		printk(KERN_INFO "%s: register netdev failed\n", CHIP_NAME);
+		free_netdev(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+
+int can_set_drv_name(void)
+{
+	char *hname = hal_name();
+
+	if (strlen(CHIP_NAME) + strlen(hname) >= DRV_NAME_LEN-1) {
+		printk(KERN_ERR "%s: driver name too long!\n", CHIP_NAME);
+		return -EINVAL;
+	}
+	sprintf(drv_name, "%s-%s", CHIP_NAME, hname);
+	return 0;
+}
+
+static __exit void i82527_exit_module(void)
+{
+	int i, ret;
+
+	for (i = 0; i < MAXDEV; i++) {
+		if (can_dev[i] != NULL) {
+			struct can_priv *priv = netdev_priv(can_dev[i]);
+			unregister_netdev(can_dev[i]);
+			del_timer(&priv->timer);
+			hw_detach(i);
+			hal_release_region(i, I82527_IO_SIZE);
+			free_netdev(can_dev[i]);
+		}
+	}
+	can_proc_remove(drv_name);
+
+	if ((ret = hal_exit()))
+		printk(KERN_INFO "%s: hal_exit error %d.\n", drv_name, ret);
+}
+
+static __init int i82527_init_module(void)
+{
+	int i, ret;
+	struct net_device *dev;
+
+	if ((sizeof(canmessage_t) != 15) || (sizeof(canregs_t) != 256)) {
+		printk(KERN_WARNING "%s sizes: canmessage_t %d canregs_t %d\n",
+		       CHIP_NAME, (int)sizeof(canmessage_t),
+		       (int)sizeof(canregs_t));
+		return -EBUSY;
+	}
+
+	if ((ret = hal_init()))
+		return ret;
+
+	if ((ret = can_set_drv_name()))
+		return ret;
+
+	if (clk < 1000 ) /* MHz command line value */
+		clk *= 1000000;
+
+	if (clk < 1000000 ) /* kHz command line value */
+		clk *= 1000;
+
+	printk(KERN_INFO "%s driver v%s (%s)\n",
+	       drv_name, drv_version, drv_reldate);
+	printk(KERN_INFO "%s - options [clk %d.%06d MHz] [restart_ms %dms]"
+	       " [debug %d]\n",
+	       drv_name, clk/1000000, clk%1000000, restart_ms, debug);
+	printk(KERN_INFO "%s - options [force_dmc %d] [irq_mode %d]\n",
+	       drv_name, force_dmc, irq_mode);
+
+	if (!base[0]) {
+		printk(KERN_INFO "%s: loading defaults.\n", drv_name);
+		hal_use_defaults();
+	}
+		
+	/* to ensure the proper access to the i82527 registers */
+	/* the timing dependend settings have to be done first */
+	if (clk > 10000000)
+		dsc = iCPU_DSC; /* devide system clock => MCLK is 8MHz save */
+	else if (clk > 8000000) /* 8MHz < clk <= 10MHz */
+		dmc = iCPU_DMC; /* devide memory clock */
+
+	/* devide memory clock even if it's not needed (regarding the spec) */
+	if (force_dmc)
+		dmc = iCPU_DMC;
+
+	if (irq_mode & IRQ_MODE_SHARED)
+		irqflags |= IRQF_SHARED;
+	if (irq_mode & IRQ_MODE_DISABLE_LOCAL_IRQS)
+		irqflags |= IRQF_DISABLED;
+
+	for (i = 0; base[i]; i++) {
+		int clkout;
+		u8 clockdiv;
+
+		printk(KERN_DEBUG "%s: checking for %s on address 0x%lX ...\n",
+		       drv_name, CHIP_NAME, base[i]);
+
+		if (!hal_request_region(i, I82527_IO_SIZE, drv_name)) {
+			printk(KERN_ERR "%s: memory already in use\n",
+			       drv_name);
+			i82527_exit_module();
+			return -EBUSY;
+		}
+
+		hw_attach(i);
+		hw_reset_dev(i);
+
+		// Enable configuration, put chip in bus-off, disable ints
+		CANout(rbase[i], controlReg, iCTL_CCE | iCTL_INI);
+
+		// Configure cpu interface / CLKOUT disable
+		CANout(rbase[i], cpuInterfaceReg,(dsc | dmc));
+
+		if (!i82527_probe_chip(rbase[i])) {
+			printk(KERN_ERR "%s: probably missing controller"
+			       " hardware\n", drv_name);
+			hw_detach(i);
+			hal_release_region(i, I82527_IO_SIZE);
+			i82527_exit_module();
+			return -ENODEV;
+		}
+
+		/* CLKOUT devider and slew rate calculation */
+		if ((cdv[i] < 0) || (cdv[i] > 14)) {
+			printk(KERN_WARNING "%s: adjusted cdv[%d]=%d to 0.\n",
+			       drv_name, i, cdv[i]);
+			cdv[i] = 0;
+		}
+
+		clkout = clk / (cdv[i] + 1); /* CLKOUT frequency */
+		clockdiv = (u8)cdv[i]; /* devider value (see i82527 spec) */
+
+		if (clkout <= 16000000) {
+			clockdiv |= iCLK_SL1;
+			if (clkout <= 8000000)
+				clockdiv |= iCLK_SL0;
+		} else if (clkout <= 24000000)
+				clockdiv |= iCLK_SL0;
+
+		// Set CLKOUT devider and slew rates
+		CANout(rbase[i], clkOutReg, clockdiv);
+
+		// Configure cpu interface / CLKOUT enable
+		CANout(rbase[i], cpuInterfaceReg,(dsc | dmc | iCPU_CEN));
+
+		CANout(rbase[i], busConfigReg, bcr[i]);
+
+		dev = can_create_netdev(i, I82527_IO_SIZE);
+
+		if (dev != NULL) {
+			can_dev[i] = dev;
+			set_reset_mode(dev);
+			can_proc_create(drv_name);
+		} else {
+			can_dev[i] = NULL;
+			hw_detach(i);
+			hal_release_region(i, I82527_IO_SIZE);
+		}
+	}
+	return 0;
+}
+
+module_init(i82527_init_module);
+module_exit(i82527_exit_module);
+
Index: drivers/net/can/i82527/i82527.h
===================================================================
--- /dev/null
+++ drivers/net/can/i82527/i82527.h
@@ -0,0 +1,302 @@
+/*
+ * i82527.h -  Intel I82527 network device driver
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Original version Written by Arnaud Westenberg email:arnaud@wanadoo.nl
+ * This software is released under the GPL-License.
+ *
+ * Major Refactoring and Integration into can4linux version 3.1 by
+ * Henrik W Maier of FOCUS Software Engineering Pty Ltd <www.focus-sw.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef I82527_H
+#define I82527_H
+
+#define I82527_IO_SIZE 0x100
+
+#define CHIP_NAME	"i82527"
+
+#define DRV_NAME_LEN	30 /* for "<chip_name>-<hal_name>" */
+
+#define PROCBASE          "driver" /* /proc/ ... */
+
+#define DEFAULT_HW_CLK	16000000
+#define DEFAULT_SPEED	500 /* kBit/s */
+#define DEFAULT_FORCE_DMC 0 /* for critical register access, e.g. ser1274 */
+
+#define IRQ_MODE_SHARED 1 /* enable shared interrupts */
+#define IRQ_MODE_DISABLE_LOCAL_IRQS 2 /* when processing the irq handler */
+#define DEFAULT_IRQ_MODE IRQ_MODE_SHARED
+
+/* The message object 15 has a shadow register for reliable data receiption  */
+/* under heavy bus load. Therefore it makes sense to use this message object */
+/* (mo15) for the needed use case. The frame type (EFF/SFF) for the mo15 can */
+/* be defined on the module command line. The default is 11 bit SFF format.  */
+
+#define MO15_NONE 0
+#define MO15_SFF  1
+#define MO15_EFF  2
+
+#define MO15_DEFLT MO15_SFF /* the default */
+
+#define CAN_NETDEV_NAME	"can%d"
+
+#define TX_TIMEOUT      (50*HZ/1000) /* 50ms */ 
+#define RESTART_MS      100  /* restart chip on persistent errors in 100ms */
+#define MAX_BUS_ERRORS  200  /* prevent from flooding bus error interrupts */
+
+/* bus timing */
+#define MAX_TSEG1	15
+#define MAX_TSEG2	 7
+#define SAMPLE_POINT	62
+#define JUMPWIDTH     0x40
+
+typedef struct canmessage {
+	uint8_t	msgCtrl0Reg;	
+	uint8_t	msgCtrl1Reg;	
+	uint8_t	idReg[4];
+	uint8_t	messageConfigReg;
+	uint8_t	dataReg[8];	
+} canmessage_t; // __attribute__ ((packed));
+
+typedef struct canregs {
+  union
+  {
+    struct
+    {
+      canmessage_t messageReg;
+      uint8_t someOtherReg; // padding
+    } msgArr[16];
+    struct
+    {
+      uint8_t      controlReg;               // Control Register
+      uint8_t      statusReg;                // Status Register
+      uint8_t      cpuInterfaceReg;          // CPU Interface Register
+      uint8_t      reserved1Reg;
+      uint8_t      highSpeedReadReg[2];      // High Speed Read
+      uint8_t      globalMaskStandardReg[2]; // Standard Global Mask byte 0
+      uint8_t      globalMaskExtendedReg[4]; // Extended Global Mask bytes
+      uint8_t      message15MaskReg[4];      // Message 15 Mask bytes
+      canmessage_t message1Reg;
+      uint8_t      clkOutReg;                // Clock Out Register
+      canmessage_t message2Reg;
+      uint8_t      busConfigReg;             // Bus Configuration Register
+      canmessage_t message3Reg;
+      uint8_t      bitTiming0Reg;            // Bit Timing Register byte 0
+      canmessage_t message4Reg;
+      uint8_t      bitTiming1Reg;            // Bit Timing Register byte 1
+      canmessage_t message5Reg;
+      uint8_t      interruptReg;             // Interrupt Register
+      canmessage_t message6Reg;
+      uint8_t      reserved2Reg;
+      canmessage_t message7Reg;
+      uint8_t      reserved3Reg;
+      canmessage_t message8Reg;
+      uint8_t      reserved4Reg;
+      canmessage_t message9Reg;
+      uint8_t      p1ConfReg;
+      canmessage_t message10Reg;
+      uint8_t      p2ConfReg;
+      canmessage_t message11Reg;
+      uint8_t      p1InReg;
+      canmessage_t message12Reg;
+      uint8_t      p2InReg;
+      canmessage_t message13Reg;
+      uint8_t      p1OutReg;
+      canmessage_t message14Reg;
+      uint8_t      p2OutReg;
+      canmessage_t message15Reg;
+      uint8_t      serialResetAddressReg;
+    };
+  };
+} canregs_t; // __attribute__ ((packed));
+
+/* Control Register (0x00) */
+enum i82527_iCTL {
+	iCTL_INI = 1,		// Initialization
+	iCTL_IE  = 1<<1,	// Interrupt Enable
+	iCTL_SIE = 1<<2,	// Status Interrupt Enable
+	iCTL_EIE = 1<<3,	// Error Interrupt Enable
+	iCTL_CCE = 1<<6		// Change Configuration Enable
+};
+
+/* Status Register (0x01) */
+enum i82527_iSTAT {
+	iSTAT_TXOK = 1<<3,	// Transmit Message Successfully
+	iSTAT_RXOK = 1<<4,	// Receive Message Successfully
+	iSTAT_WAKE = 1<<5,	// Wake Up Status
+	iSTAT_WARN = 1<<6,	// Warning Status
+	iSTAT_BOFF = 1<<7	// Bus Off Status
+};
+
+/* CPU Interface Register (0x02) */
+enum i82527_iCPU {
+	iCPU_CEN = 1,		// Clock Out Enable
+	iCPU_MUX = 1<<2,	// Multiplex
+	iCPU_SLP = 1<<3,	// Sleep
+	iCPU_PWD = 1<<4,	// Power Down Mode
+	iCPU_DMC = 1<<5,	// Divide Memory Clock
+	iCPU_DSC = 1<<6,	// Divide System Clock
+	iCPU_RST = 1<<7,	// Hardware Reset Status
+};
+
+/* Clock Out Register (0x1f) */
+enum i82527_iCLK {
+	iCLK_CD0 = 1,		// Clock Divider bit 0
+	iCLK_CD1 = 1<<1,
+	iCLK_CD2 = 1<<2,
+	iCLK_CD3 = 1<<3,
+	iCLK_SL0 = 1<<4,	// Slew Rate bit 0
+	iCLK_SL1 = 1<<5
+};
+
+/* Bus Configuration Register (0x2f) */
+enum i82527_iBUS {
+	iBUS_DR0 = 1,		// Disconnect RX0 Input
+	iBUS_DR1 = 1<<1,	// Disconnect RX1 Input
+	iBUS_DT1 = 1<<3,	// Disconnect TX1 Output
+	iBUS_POL = 1<<5,	// Polarity
+	iBUS_CBY = 1<<6		// Comparator Bypass
+};
+
+#define RESET 1			// Bit Pair Reset Status
+#define SET 2			// Bit Pair Set Status
+#define UNCHANGED 3		// Bit Pair Unchanged
+
+/* Message Control Register 0 (Base Address + 0x0) */
+enum i82527_iMSGCTL0 {
+	INTPD_SET = SET,		// Interrupt pending
+	INTPD_RES = RESET,		// No Interrupt pending
+	INTPD_UNC = UNCHANGED,
+	RXIE_SET  = SET<<2,		// Receive Interrupt Enable
+	RXIE_RES  = RESET<<2,		// Receive Interrupt Disable
+	RXIE_UNC  = UNCHANGED<<2,
+	TXIE_SET  = SET<<4,		// Transmit Interrupt Enable
+	TXIE_RES  = RESET<<4,		// Transmit Interrupt Disable
+	TXIE_UNC  = UNCHANGED<<4,
+	MVAL_SET  = SET<<6,		// Message Valid
+	MVAL_RES  = RESET<<6,		// Message Invalid
+	MVAL_UNC  = UNCHANGED<<6
+};
+
+/* Message Control Register 1 (Base Address + 0x01) */
+enum i82527_iMSGCTL1 {
+	NEWD_SET = SET,			// New Data
+	NEWD_RES = RESET,		// No New Data
+	NEWD_UNC = UNCHANGED,
+	MLST_SET = SET<<2,		// Message Lost
+	MLST_RES = RESET<<2,		// No Message Lost
+	MLST_UNC = UNCHANGED<<2,
+	CPUU_SET = SET<<2,		// CPU Updating
+	CPUU_RES = RESET<<2,		// No CPU Updating
+	CPUU_UNC = UNCHANGED<<2,
+	TXRQ_SET = SET<<4,		// Transmission Request
+	TXRQ_RES = RESET<<4,		// No Transmission Request
+	TXRQ_UNC = UNCHANGED<<4,
+	RMPD_SET = SET<<6,		// Remote Request Pending
+	RMPD_RES = RESET<<6,		// No Remote Request Pending
+	RMPD_UNC = UNCHANGED<<6
+};
+
+/* Message Configuration Register (Base Address + 0x06) */
+enum i82527_iMSGCFG {
+	MCFG_XTD = 1<<2,		// Extended Identifier
+	MCFG_DIR = 1<<3			// Direction is Transmit
+};
+
+#undef IOPRINT
+#undef IODEBUG
+
+#ifdef IOPRINT
+#define CANout(base,adr,v) \
+	printk("CANout: (%lx+%x)=%x\n", base,\
+					(int)(long)&((canregs_t *)0)->adr,v)
+
+#define CANin(base,adr) \
+	printk("CANin: (%lx+%x)\n", base, (int)(long)&((canregs_t *)0)->adr)
+
+#else /* IOPRINT */
+
+#ifdef IODEBUG
+#define CANout(base,adr,v)      \
+	(printk("CANout: (%lx+%x)=%x\n", base,\
+		(int)(long)&((canregs_t *)0)->adr,v),\
+		hw_writereg(base, (int)(long)&((canregs_t *)0)->adr, v))
+#else
+#define CANout(base,adr,v) hw_writereg(base,\
+					(int)(long)&((canregs_t *)0)->adr, v)
+#endif
+
+#define CANin(base,adr)	hw_readreg(base, (int)(long)&((canregs_t *)0)->adr)
+
+#endif /* IOPRINT */
+
+/* CAN private data structure */
+
+struct can_priv {
+	struct net_device_stats	stats;
+	struct can_device_stats	can_stats;
+	long			open_time;
+	int			clock;
+	int			hw_regs;
+	int			restart_ms;
+	int			debug;
+	int			speed;
+	int			btr;
+	int			rx_probe;
+	int			mo15;
+	struct timer_list       timer;
+	int			state;
+};
+
+#define STATE_UNINITIALIZED	0
+#define STATE_PROBE		1
+#define STATE_ACTIVE		2
+#define STATE_ERROR_ACTIVE	3
+#define STATE_ERROR_PASSIVE	4
+#define STATE_BUS_OFF		5
+#define STATE_RESET_MODE	6
+
+void can_proc_create(const char *drv_name);
+void can_proc_remove(const char *drv_name);
+
+#endif /* I82527_H */
Index: drivers/net/can/i82527/proc.c
===================================================================
--- /dev/null
+++ drivers/net/can/i82527/proc.c
@@ -0,0 +1,211 @@
+/*
+ * proc.c -  proc file system functions for I82527 CAN driver.
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/netdevice.h>
+
+#include <linux/can.h>
+#include <linux/can/ioctl.h>
+#include "i82527.h"
+#include "hal.h"
+
+extern struct net_device *can_dev[];
+
+static struct proc_dir_entry *pde       = NULL;
+static struct proc_dir_entry *pde_regs  = NULL;
+static struct proc_dir_entry *pde_reset = NULL;
+
+static int can_proc_read_stats(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	int len = 0;
+	int i;
+
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"CAN bus device statistics:\n");
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"       errwarn  overrun   wakeup   buserr   "
+			"errpass  arbitr   restarts clock        baud\n");
+	for (i = 0; (i < MAXDEV) && (len < PAGE_SIZE - 200); i++) {
+		if (can_dev[i]) {
+			struct net_device *dev = can_dev[i];
+			struct can_priv *priv  = netdev_priv(dev);
+			len += snprintf(page + len, PAGE_SIZE - len,
+					"%s: %8d %8d %8d %8d %8d "
+					"%8d %8d %10d %8d\n", dev->name,
+					priv->can_stats.error_warning,
+					priv->can_stats.data_overrun,
+					priv->can_stats.wakeup,
+					priv->can_stats.bus_error,
+					priv->can_stats.error_passive,
+					priv->can_stats.arbitration_lost,
+					priv->can_stats.restarts,
+					priv->clock,
+					priv->speed
+				);
+
+		}
+	}
+
+	*eof = 1;
+	return len;
+}
+
+
+static int can_proc_dump_regs(char *page, int len, struct net_device *dev)
+{
+	int r,s;
+	struct can_priv	*priv = netdev_priv(dev);
+	int regs = priv->hw_regs;
+
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"%s registers:\n", dev->name);
+
+	for (r = 0; r < regs; r += 0x10) {
+		len += snprintf(page + len, PAGE_SIZE - len, "%02X: ", r);
+		for (s = 0; s < 0x10; s++) {
+			if (r+s < regs)
+				len += snprintf(page + len, PAGE_SIZE-len,
+						"%02X ",
+						hw_readreg(dev->base_addr,
+							   r+s));
+		}
+		len += snprintf(page + len, PAGE_SIZE - len, "\n");
+	}
+
+        return len;
+}
+
+static int can_proc_read_regs(char *page, char **start, off_t off,
+				  int count, int *eof, void *data)
+{
+	int len = 0;
+	int i;
+
+	for (i = 0; (i < MAXDEV) && (len < PAGE_SIZE - 200); i++) {
+		if (can_dev[i])
+			len = can_proc_dump_regs(page, len, can_dev[i]);
+	}
+
+	*eof = 1;
+	return len;
+}
+
+static int can_proc_read_reset(char *page, char **start, off_t off,
+				   int count, int *eof, void *data)
+{
+	int len = 0;
+	struct net_device *dev;
+	int i;
+	struct can_priv   *priv;
+
+	len += snprintf(page + len, PAGE_SIZE - len, "resetting ");
+	for (i = 0; (i < MAXDEV) && (len < PAGE_SIZE - 200); i++) {
+		if (can_dev[i]) {
+			dev = can_dev[i];
+			priv = netdev_priv(can_dev[i]);
+			if ((priv->state != STATE_UNINITIALIZED)
+			    && (priv->state != STATE_RESET_MODE)) {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"%s ", dev->name);
+				dev->stop(dev);
+				dev->open(dev);
+				/* count number of restarts */
+				priv->can_stats.restarts++;
+
+			} else {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"(%s|%d) ", dev->name,
+						priv->state);
+			}
+		}
+	}
+
+	len += snprintf(page + len, PAGE_SIZE - len, "done\n");
+
+	*eof = 1;
+	return len;
+}
+
+void can_proc_create(const char *drv_name)
+{
+	char fname[256];
+
+	if (pde == NULL) {
+		sprintf(fname, PROCBASE "/%s_stats", drv_name);
+		pde = create_proc_read_entry(fname, 0644, NULL,
+					     can_proc_read_stats, NULL);
+	}
+	if (pde_regs == NULL) {
+		sprintf(fname, PROCBASE "/%s_regs", drv_name);
+		pde_regs = create_proc_read_entry(fname, 0644, NULL,
+						  can_proc_read_regs, NULL);
+	}
+	if (pde_reset == NULL) {
+		sprintf(fname, PROCBASE "/%s_reset", drv_name);
+		pde_reset = create_proc_read_entry(fname, 0644, NULL,
+						   can_proc_read_reset, NULL);
+	}
+}
+
+void can_proc_remove(const char *drv_name)
+{
+	char fname[256];
+
+	if (pde) {
+		sprintf(fname, PROCBASE "/%s_stats", drv_name);
+		remove_proc_entry(fname, NULL);
+	}
+	if (pde_regs) {
+		sprintf(fname, PROCBASE "/%s_regs", drv_name);
+		remove_proc_entry(fname, NULL);
+	}
+	if (pde_reset) {
+		sprintf(fname, PROCBASE "/%s_reset", drv_name);
+		remove_proc_entry(fname, NULL);
+	}
+}
Index: drivers/net/can/mscan/Makefile
===================================================================
--- /dev/null
+++ drivers/net/can/mscan/Makefile
@@ -0,0 +1,59 @@
+#
+#
+#  Copyright (c) 2002-2005 Volkswagen Group Electronic Research
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#  1. Redistributions of source code must retain the above copyright
+#     notice, this list of conditions, the following disclaimer and
+#     the referenced file 'COPYING'.
+#  2. Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#  3. Neither the name of Volkswagen nor the names of its contributors
+#     may be used to endorse or promote products derived from this software
+#     without specific prior written permission.
+#
+#  Alternatively, provided that this notice is retained in full, this
+#  software may be distributed under the terms of the GNU General
+#  Public License ("GPL") version 2 as distributed in the 'COPYING'
+#  file from the main directory of the linux kernel source.
+#
+#  The provided data structures and external interfaces from this code
+#  are not restricted to be used by modules with a GPL compatible license.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+#  DAMAGE.
+#
+#  Send feedback to <socketcan-users@lists.berlios.de>
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+obj-$(CONFIG_CAN_MPC52XX)	+= mscan-mpc52xx.o
+
+mscan-mpc52xx-objs	:= mscan.o mpc52xx_can.o
+
+endif
Index: drivers/net/can/mscan/mpc52xx_can.c
===================================================================
--- /dev/null
+++ drivers/net/can/mscan/mpc52xx_can.c
@@ -0,0 +1,241 @@
+/*
+ * DESCRIPTION:
+ *  CAN bus driver for the Freescale MPC52xx embedded CPU.
+ *
+ * AUTHOR:
+ *  Andrey Volkov <avolkov@varma-el.com>
+ *
+ * COPYRIGHT:
+ *  2004-2005, Varma Electronics Oy
+ *
+ * LICENCE:
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * HISTORY:
+ *	 2005-02-03 created
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <linux/can.h>
+#include <linux/can/dev.h>
+#include <asm/io.h>
+#include <asm/mpc52xx.h>
+
+#include "mscan.h"
+
+
+#define PDEV_MAX 2
+
+struct platform_device *pdev[PDEV_MAX];
+
+static int __devinit mpc52xx_can_probe(struct platform_device *pdev)
+{
+	struct resource *mem;
+	struct net_device *dev;
+	struct mscan_platform_data *pdata = pdev->dev.platform_data;
+	struct can_priv *can;
+	u32 mem_size;
+	int ret = -ENODEV;
+
+	if (!pdata)
+		return ret;
+
+	dev = alloc_mscandev();
+	if (!dev)
+		return -ENOMEM;
+	can = netdev_priv(dev);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->irq = platform_get_irq(pdev, 0);
+	if (!mem || !dev->irq)
+		goto req_error;
+
+	mem_size = mem->end - mem->start + 1;
+	if (!request_mem_region(mem->start, mem_size, pdev->dev.driver->name)) {
+		dev_err(&pdev->dev, "resource unavailable\n");
+		goto req_error;
+	}
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+	SET_MODULE_OWNER(THIS_MODULE);
+
+	dev->base_addr = (unsigned long)ioremap_nocache(mem->start, mem_size);
+
+	if (!dev->base_addr) {
+		dev_err(&pdev->dev, "failed to map can port\n");
+		ret = -ENOMEM;
+		goto fail_map;
+	}
+
+	can->can_sys_clock = pdata->clock_frq;
+
+	platform_set_drvdata(pdev, dev);
+
+	ret = register_mscandev(dev, pdata->clock_src);
+	if (ret >= 0) {
+		dev_info(&pdev->dev, "probe for a port 0x%lX done\n",
+			 dev->base_addr);
+		return ret;
+	}
+
+	iounmap((unsigned long *)dev->base_addr);
+      fail_map:
+	release_mem_region(mem->start, mem_size);
+      req_error:
+	free_candev(dev);
+	dev_err(&pdev->dev, "probe failed\n");
+	return ret;
+}
+
+static int __devexit mpc52xx_can_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct resource *mem;
+
+	platform_set_drvdata(pdev, NULL);
+	unregister_mscandev(dev);
+
+	iounmap((volatile void __iomem *)dev->base_addr);
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem->start, mem->end - mem->start + 1);
+	free_candev(dev);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static struct mscan_regs saved_regs;
+static int mpc52xx_can_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	_memcpy_fromio(&saved_regs, regs, sizeof(*regs));
+
+	return 0;
+}
+
+static int mpc52xx_can_resume(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	regs->canctl0 |= MSCAN_INITRQ;
+	while ((regs->canctl1 & MSCAN_INITAK) == 0)
+		udelay(10);
+
+	regs->canctl1 = saved_regs.canctl1;
+	regs->canbtr0 = saved_regs.canbtr0;
+	regs->canbtr1 = saved_regs.canbtr1;
+	regs->canidac = saved_regs.canidac;
+
+	/* restore masks, buffers etc. */
+	_memcpy_toio(&regs->canidar1_0, (void *)&saved_regs.canidar1_0,
+		     sizeof(*regs) - offsetof(struct mscan_regs, canidar1_0));
+
+	regs->canctl0 &= ~MSCAN_INITRQ;
+	regs->cantbsel = saved_regs.cantbsel;
+	regs->canrier = saved_regs.canrier;
+	regs->cantier = saved_regs.cantier;
+	regs->canctl0 = saved_regs.canctl0;
+
+	return 0;
+}
+#endif
+
+static struct platform_driver mpc52xx_can_driver = {
+	.driver = {
+		   .name = "mpc52xx-mscan",
+		   },
+	.probe = mpc52xx_can_probe,
+	.remove = __devexit_p(mpc52xx_can_remove),
+#ifdef CONFIG_PM
+	.suspend = mpc52xx_can_suspend,
+	.resume = mpc52xx_can_resume,
+#endif
+};
+
+#ifdef CONFIG_PPC_MERGE
+static int __init mpc52xx_of_to_pdev(void)
+{
+	struct device_node *np = NULL;
+	unsigned int i;
+	int ret;
+
+	for (i = 0;
+	     (np = of_find_compatible_node(np, "mscan", "mpc5200-mscan"));
+	     i++) {
+		struct resource r[2] = { };
+		struct mscan_platform_data pdata;
+
+		if (i >= PDEV_MAX) {
+			printk(KERN_WARNING "%s: increase PDEV_MAX for more "
+			       "than %i devices\n", __func__, PDEV_MAX);
+			break;
+		}
+
+		ret = of_address_to_resource(np, 0, &r[0]);
+		if (ret)
+			goto err;
+
+		of_irq_to_resource(np, 0, &r[1]);
+
+		pdev[i] =
+		    platform_device_register_simple("mpc52xx-mscan", i, r, 2);
+		if (IS_ERR(pdev[i])) {
+			ret = PTR_ERR(pdev[i]);
+			goto err;
+		}
+
+		pdata.clock_src = MSCAN_CLKSRC_BUS;
+		pdata.clock_frq = mpc52xx_find_ipb_freq(np);
+		ret = platform_device_add_data(pdev[i], &pdata, sizeof(pdata));
+		if (ret)
+			goto err;
+	}
+	return 0;
+      err:
+	return ret;
+}
+#else
+#define mscan_of_to_pdev()
+#endif
+
+int __init mpc52xx_can_init(void)
+{
+	mpc52xx_of_to_pdev();
+	printk(KERN_INFO "%s initializing\n", mpc52xx_can_driver.driver.name);
+	return platform_driver_register(&mpc52xx_can_driver);
+}
+
+void __exit mpc52xx_can_exit(void)
+{
+	int i;
+	platform_driver_unregister(&mpc52xx_can_driver);
+	for (i = 0; i < PDEV_MAX; i++)
+		platform_device_unregister(pdev[i]);
+	printk(KERN_INFO "%s unloaded\n", mpc52xx_can_driver.driver.name);
+}
+
+module_init(mpc52xx_can_init);
+module_exit(mpc52xx_can_exit);
+
+MODULE_AUTHOR("Andrey Volkov <avolkov@varma-el.com>");
+MODULE_DESCRIPTION("Freescale MPC5200 CAN driver");
+MODULE_LICENSE("GPL v2");
Index: drivers/net/can/mscan/mscan.c
===================================================================
--- /dev/null
+++ drivers/net/can/mscan/mscan.c
@@ -0,0 +1,703 @@
+/*
+ * mscan.c
+ *
+ * DESCRIPTION:
+ *  CAN bus driver for the alone generic (as possible as) MSCAN controller.
+ *
+ * AUTHOR:
+ *  Andrey Volkov <avolkov@varma-el.com>
+ *
+ * COPYRIGHT:
+ *  2005-2006, Varma Electronics Oy
+ *
+ * LICENCE:
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/can.h>
+#include <linux/list.h>
+#include <asm/io.h>
+
+#include <linux/can/dev.h>
+#include <linux/can/error.h>
+#include "mscan.h"
+
+#define MSCAN_NORMAL_MODE	0
+#define MSCAN_SLEEP_MODE	MSCAN_SLPRQ
+#define MSCAN_INIT_MODE		(MSCAN_INITRQ | MSCAN_SLPRQ)
+#define MSCAN_POWEROFF_MODE	(MSCAN_CSWAI | MSCAN_SLPRQ)
+#define MSCAN_SET_MODE_RETRIES	255
+
+
+#define BTR0_BRP_MASK		0x3f
+#define BTR0_SJW_SHIFT		6
+#define BTR0_SJW_MASK		(0x3 << BTR0_SJW_SHIFT)
+
+#define BTR1_TSEG1_MASK 	0xf
+#define BTR1_TSEG2_SHIFT	4
+#define BTR1_TSEG2_MASK 	(0x7 << BTR1_TSEG2_SHIFT)
+#define BTR1_SAM_SHIFT  	7
+
+#define BTR0_SET_BRP(brp)	(((brp) - 1) & BTR0_BRP_MASK)
+#define BTR0_SET_SJW(sjw)	((((sjw) - 1) << BTR0_SJW_SHIFT) & \
+				 BTR0_SJW_MASK)
+
+#define BTR1_SET_TSEG1(tseg1)	(((tseg1) - 1) &  BTR1_TSEG1_MASK)
+#define BTR1_SET_TSEG2(tseg2)	((((tseg2) - 1) << BTR1_TSEG2_SHIFT) & \
+				 BTR1_TSEG2_MASK)
+#define BTR1_SET_SAM(sam)	(((sam) & 1) << BTR1_SAM_SHIFT)
+
+struct mscan_state {
+	u8 mode;
+	u8 canrier;
+	u8 cantier;
+};
+
+#define TX_QUEUE_SIZE	3
+
+typedef struct {
+	struct list_head list;
+	u8 mask;
+} tx_queue_entry_t;
+
+struct mscan_priv {
+	struct can_priv can;
+	volatile unsigned long flags;
+	u8 shadow_statflg;
+	u8 shadow_canrier;
+	u8 cur_pri;
+	u8 tx_active;
+
+	struct list_head tx_head;
+	tx_queue_entry_t tx_queue[TX_QUEUE_SIZE];
+};
+
+#define F_RX_PROGRESS	0
+#define F_TX_PROGRESS	1
+#define F_TX_WAIT_ALL	2
+
+static int mscan_set_mode(struct net_device *dev, u8 mode)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	int ret = 0;
+	int i;
+	u8 canctl1;
+
+	if (mode != MSCAN_NORMAL_MODE) {
+		canctl1 = in_8(&regs->canctl1);
+		if ((mode & MSCAN_SLPRQ) && (canctl1 & MSCAN_SLPAK) == 0) {
+			out_8(&regs->canctl0,
+			      in_8(&regs->canctl0) | MSCAN_SLPRQ);
+			for (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {
+				if (in_8(&regs->canctl1) & MSCAN_SLPAK)
+					break;
+				udelay(100);
+			}
+			if (i >= MSCAN_SET_MODE_RETRIES)
+				ret = -ENODEV;
+		}
+
+		if (!ret && (mode & MSCAN_INITRQ)
+		    && (canctl1 & MSCAN_INITAK) == 0) {
+			out_8(&regs->canctl0,
+			      in_8(&regs->canctl0) | MSCAN_INITRQ);
+			for (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {
+				if (in_8(&regs->canctl1) & MSCAN_INITAK)
+					break;
+			}
+			if (i >= MSCAN_SET_MODE_RETRIES)
+				ret = -ENODEV;
+		}
+
+		if (!ret && (mode & MSCAN_CSWAI))
+			out_8(&regs->canctl0,
+			      in_8(&regs->canctl0) | MSCAN_CSWAI);
+
+	} else {
+		canctl1 = in_8(&regs->canctl1);
+		if (canctl1 & (MSCAN_SLPAK | MSCAN_INITAK)) {
+			out_8(&regs->canctl0, in_8(&regs->canctl0) &
+			      ~(MSCAN_SLPRQ | MSCAN_INITRQ));
+			for (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {
+				canctl1 = in_8(&regs->canctl1);
+				if (!(canctl1 & (MSCAN_INITAK | MSCAN_SLPAK)))
+					break;
+			}
+			if (i >= MSCAN_SET_MODE_RETRIES)
+				ret = -ENODEV;
+		}
+	}
+	return ret;
+}
+
+static void mscan_push_state(struct net_device *dev, struct mscan_state *state)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	state->mode = in_8(&regs->canctl0) & (MSCAN_SLPRQ | MSCAN_INITRQ |
+					      MSCAN_CSWAI);
+	state->canrier = in_8(&regs->canrier);
+	state->cantier = in_8(&regs->cantier);
+}
+
+static int mscan_pop_state(struct net_device *dev, struct mscan_state *state)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	int ret;
+	ret = mscan_set_mode(dev, state->mode);
+	if (!ret) {
+		out_8(&regs->canrier, state->canrier);
+		out_8(&regs->cantier, state->cantier);
+	}
+	return ret;
+}
+
+static int mscan_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct can_frame *frame = (struct can_frame *)skb->data;
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	struct mscan_priv *priv = netdev_priv(dev);
+
+	int i, rtr, buf_id;
+	u32 can_id;
+
+	if (frame->can_dlc > 8)
+		return -EINVAL;
+
+	dev_dbg(ND2D(dev), "%s\n", __FUNCTION__);
+	out_8(&regs->cantier, 0);
+
+	i = ~priv->tx_active & MSCAN_TXE;
+	buf_id = ffs(i) - 1;
+	switch (hweight8(i)) {
+	case 0:
+		netif_stop_queue(dev);
+		dev_err(ND2D(dev), "BUG! Tx Ring full when queue awake!\n");
+		return NETDEV_TX_BUSY;
+	case 1:
+		/* if buf_id < 3, then current frame will be send out of order,
+		   since  buffer with lower id have higher priority (hell..) */
+		if (buf_id < 3)
+			priv->cur_pri++;
+		if (priv->cur_pri == 0xff)
+			set_bit(F_TX_WAIT_ALL, &priv->flags);
+		netif_stop_queue(dev);
+	case 2:
+		set_bit(F_TX_PROGRESS, &priv->flags);
+	}
+	out_8(&regs->cantbsel, i);
+
+	rtr = frame->can_id & CAN_RTR_FLAG;
+
+	if (frame->can_id & CAN_EFF_FLAG) {
+		dev_dbg(ND2D(dev), "sending extended frame\n");
+
+		can_id = (frame->can_id & CAN_EFF_MASK) << 1;
+		if (rtr)
+			can_id |= 1;
+		out_be16(&regs->tx.idr3_2, can_id);
+
+		can_id >>= 16;
+		can_id = (can_id & 0x7) | ((can_id << 2) & 0xffe0) | (3 << 3);
+	} else {
+		dev_dbg(ND2D(dev), "sending standard frame\n");
+		can_id = (frame->can_id & CAN_SFF_MASK) << 5;
+		if (rtr)
+			can_id |= 1 << 4;
+	}
+	out_be16(&regs->tx.idr1_0, can_id);
+
+	if (!rtr) {
+		volatile void __iomem *data = &regs->tx.dsr1_0;
+		u16 *payload = (u16 *) frame->data;
+		/*Its safe to write into dsr[dlc+1] */
+		for (i = 0; i < (frame->can_dlc + 1) / 2; i++) {
+			out_be16(data, *payload++);
+			data += 2 + _MSCAN_RESERVED_DSR_SIZE;
+		}
+	}
+
+	out_8(&regs->tx.dlr, frame->can_dlc);
+	out_8(&regs->tx.tbpr, priv->cur_pri);
+
+	/* Start transmission. */
+	out_8(&regs->cantflg, 1 << buf_id);
+
+	if (!test_bit(F_TX_PROGRESS, &priv->flags))
+		dev->trans_start = jiffies;
+
+	list_add_tail(&priv->tx_queue[buf_id].list, &priv->tx_head);
+
+	kfree_skb(skb);
+
+	/* Enable interrupt. */
+	priv->tx_active |= 1 << buf_id;
+	out_8(&regs->cantier, priv->tx_active);
+
+	return NETDEV_TX_OK;
+}
+
+static void mscan_tx_timeout(struct net_device *dev)
+{
+	struct sk_buff *skb;
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct can_frame *frame;
+	u8 mask;
+
+	printk("%s\n", __FUNCTION__);
+
+	out_8(&regs->cantier, 0);
+
+	mask = list_entry(priv->tx_head.next, tx_queue_entry_t, list)->mask;
+	dev->trans_start = jiffies;
+	out_8(&regs->cantarq, mask);
+	out_8(&regs->cantier, priv->tx_active);
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (!skb) {
+		if (printk_ratelimit())
+			dev_notice(ND2D(dev), "TIMEOUT packet dropped\n");
+		return;
+	}
+	frame = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
+
+	frame->can_id = CAN_ERR_FLAG | CAN_ERR_TX_TIMEOUT;
+	frame->can_dlc = CAN_ERR_DLC;
+
+	skb->dev = dev;
+	skb->protocol = __constant_htons(ETH_P_CAN);
+	skb->pkt_type = PACKET_BROADCAST;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+	netif_rx(skb);
+
+}
+
+static can_state_t state_map[] = {
+	CAN_STATE_ACTIVE,
+	CAN_STATE_BUS_WARNING,
+	CAN_STATE_BUS_PASSIVE,
+	CAN_STATE_BUS_OFF
+};
+
+static inline int check_set_state(struct net_device *dev, u8 canrflg)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	can_state_t state;
+	int ret = 0;
+
+	if (!(canrflg & MSCAN_CSCIF) || priv->can.state > CAN_STATE_BUS_OFF)
+		return 0;
+
+	state =
+	    state_map[max(MSCAN_STATE_RX(canrflg), MSCAN_STATE_TX(canrflg))];
+	if (priv->can.state < state)
+		ret = 1;
+	if (state == CAN_STATE_BUS_OFF)
+		netif_carrier_off(dev);
+	else if (priv->can.state == CAN_STATE_BUS_OFF
+		 && state != CAN_STATE_BUS_OFF)
+		netif_carrier_on(dev);
+	priv->can.state = state;
+	return ret;
+}
+
+static int mscan_rx_poll(struct net_device *dev, int *budget)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	struct mscan_priv *priv = netdev_priv(dev);
+	int npackets = 0, quota = min(dev->quota, *budget);
+	int ret = 1;
+	struct sk_buff *skb;
+	struct can_frame *frame;
+	u32 can_id;
+	u8 canrflg;
+	int i;
+
+	while (npackets < quota && ((canrflg = in_8(&regs->canrflg)) &
+				    (MSCAN_RXF | MSCAN_ERR_IF))) {
+
+		skb = dev_alloc_skb(sizeof(struct can_frame));
+		if (!skb) {
+			if (printk_ratelimit())
+				dev_notice(ND2D(dev), "packet dropped\n");
+			priv->can.net_stats.rx_dropped++;
+			out_8(&regs->canrflg, canrflg);
+			continue;
+		}
+
+		frame = (struct can_frame *)skb_put(skb,
+						    sizeof(struct can_frame));
+
+		if (canrflg & MSCAN_RXF) {
+			can_id = in_be16(&regs->rx.idr1_0);
+			if (can_id & (1 << 3)) {
+				frame->can_id = CAN_EFF_FLAG;
+				can_id = ((can_id << 16) |
+					  in_be16(&regs->rx.idr3_2));
+				can_id = ((can_id & 0xffe00000) |
+					  ((can_id & 0x7ffff) << 2)) >> 2;
+			} else {
+				can_id >>= 4;
+				frame->can_id = 0;
+			}
+
+			frame->can_id |= can_id >> 1;
+			if (can_id & 1)
+				frame->can_id |= CAN_RTR_FLAG;
+			frame->can_dlc = in_8(&regs->rx.dlr) & 0xf;
+
+			if (!(frame->can_id & CAN_RTR_FLAG)) {
+				volatile void __iomem *data = &regs->rx.dsr1_0;
+				u16 *payload = (u16 *) frame->data;
+				for (i = 0; i < (frame->can_dlc + 1) / 2; i++) {
+					*payload++ = in_be16(data);
+					data += 2 + _MSCAN_RESERVED_DSR_SIZE;
+				}
+			}
+
+			dev_dbg(ND2D(dev),
+				"received pkt: id: %u dlc: %u data: ",
+				frame->can_id, frame->can_dlc);
+#ifdef DEBUG
+			for (i = 0;
+			     i < frame->can_dlc && !(frame->can_id &
+						     CAN_FLAG_RTR); i++)
+				printk("%2x ", frame->data[i]);
+			printk("\n");
+#endif
+
+			out_8(&regs->canrflg, MSCAN_RXF);
+			dev->last_rx = jiffies;
+			priv->can.net_stats.rx_packets++;
+			priv->can.net_stats.rx_bytes += frame->can_dlc;
+		} else if (canrflg & MSCAN_ERR_IF) {
+			frame->can_id = CAN_ERR_FLAG;
+
+			if (canrflg & MSCAN_OVRIF) {
+				frame->can_id |= CAN_ERR_CRTL;
+				frame->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+				priv->can.net_stats.rx_over_errors++;
+			} else
+				frame->data[1] = 0;
+
+			if (check_set_state(dev, canrflg)) {
+				frame->can_id |= CAN_ERR_CRTL;
+				switch (priv->can.state) {
+				case CAN_STATE_BUS_WARNING:
+					if ((priv->shadow_statflg &
+					     MSCAN_RSTAT_MSK) <
+					    (canrflg & MSCAN_RSTAT_MSK))
+						frame->data[1] |=
+						    CAN_ERR_CRTL_RX_WARNING;
+
+					if ((priv->shadow_statflg &
+					     MSCAN_TSTAT_MSK) <
+					    (canrflg & MSCAN_TSTAT_MSK))
+						frame->data[1] |=
+							CAN_ERR_CRTL_TX_WARNING;
+					break;
+				case CAN_STATE_BUS_PASSIVE:
+					frame->data[1] |=
+					    CAN_ERR_CRTL_RX_PASSIVE;
+					break;
+				case CAN_STATE_BUS_OFF:
+					frame->can_id |= CAN_ERR_BUSOFF;
+					frame->can_id &= ~CAN_ERR_CRTL;
+					break;
+				}
+			}
+			priv->shadow_statflg = canrflg & MSCAN_STAT_MSK;
+			frame->can_dlc = CAN_ERR_DLC;
+			out_8(&regs->canrflg, MSCAN_ERR_IF);
+		}
+
+		npackets++;
+		skb->dev = dev;
+		skb->protocol = __constant_htons(ETH_P_CAN);
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		netif_receive_skb(skb);
+	}
+
+	*budget -= npackets;
+	dev->quota -= npackets;
+
+	if (!(in_8(&regs->canrflg) & (MSCAN_RXF | MSCAN_ERR_IF))) {
+		netif_rx_complete(dev);
+		clear_bit(F_RX_PROGRESS, &priv->flags);
+		out_8(&regs->canrier,
+		      in_8(&regs->canrier) | MSCAN_ERR_IF | MSCAN_RXFIE);
+		ret = 0;
+	}
+	return ret;
+}
+
+
+static irqreturn_t mscan_isr(int irq, void *dev_id)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	u8 cantflg, canrflg;
+	irqreturn_t ret = IRQ_NONE;
+
+	if (in_8(&regs->cantier) & MSCAN_TXE) {
+		struct list_head *tmp, *pos;
+
+		cantflg = in_8(&regs->cantflg) & MSCAN_TXE;
+
+		list_for_each_safe(pos, tmp, &priv->tx_head) {
+			tx_queue_entry_t *entry =
+			    list_entry(pos, tx_queue_entry_t, list);
+			u8 mask = entry->mask;
+
+			if (!(cantflg & mask))
+				continue;
+
+			if (in_8(&regs->cantaak) & mask) {
+				priv->can.net_stats.tx_dropped++;
+				priv->can.net_stats.tx_aborted_errors++;
+			} else {
+				out_8(&regs->cantbsel, mask);
+				priv->can.net_stats.tx_bytes +=
+				    in_8(&regs->tx.dlr);
+				priv->can.net_stats.tx_packets++;
+			}
+			priv->tx_active &= ~mask;
+			list_del(pos);
+		}
+
+		if (list_empty(&priv->tx_head)) {
+			clear_bit(F_TX_WAIT_ALL, &priv->flags);
+			clear_bit(F_TX_PROGRESS, &priv->flags);
+			priv->cur_pri = 0;
+		} else
+			dev->trans_start = jiffies;
+
+		if (!test_bit(F_TX_WAIT_ALL, &priv->flags))
+			netif_wake_queue(dev);
+
+		out_8(&regs->cantier, priv->tx_active);
+		ret = IRQ_HANDLED;
+	}
+
+	if ((((canrflg = in_8(&regs->canrflg)) & ~MSCAN_STAT_MSK)) &&
+	    !test_and_set_bit(F_RX_PROGRESS, &priv->flags)) {
+		if (check_set_state(dev, canrflg)) {
+			out_8(&regs->canrflg, MSCAN_CSCIF);
+			ret = IRQ_HANDLED;
+		}
+		if (canrflg & ~MSCAN_STAT_MSK) {
+			priv->shadow_canrier = in_8(&regs->canrier);
+			out_8(&regs->canrier, 0);
+			netif_rx_schedule(dev);
+			ret = IRQ_HANDLED;
+		} else
+			clear_bit(F_RX_PROGRESS, &priv->flags);
+	}
+	return ret;
+}
+
+static int mscan_do_set_mode(struct net_device *dev, can_mode_t mode)
+{
+	switch (mode) {
+	case CAN_MODE_SLEEP:
+	case CAN_MODE_STOP:
+		netif_stop_queue(dev);
+		mscan_set_mode(dev,
+			       (mode ==
+				CAN_MODE_STOP) ? MSCAN_INIT_MODE :
+			       MSCAN_SLEEP_MODE);
+		break;
+	case CAN_MODE_START:
+		printk("%s: CAN_MODE_START requested\n", __FUNCTION__);
+		mscan_set_mode(dev, MSCAN_NORMAL_MODE);
+		netif_wake_queue(dev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static int mscan_do_set_bit_time(struct net_device *dev,
+				 struct can_bittime *bt)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	int ret = 0;
+	u8 reg;
+	struct mscan_state state;
+
+	if (bt->type != CAN_BITTIME_STD)
+		return -EINVAL;
+
+	spin_lock_irq(&priv->can.irq_lock);
+
+	mscan_push_state(dev, &state);
+	ret = mscan_set_mode(dev, MSCAN_INIT_MODE);
+	if (!ret) {
+		reg = BTR0_SET_BRP(bt->std.brp) | BTR0_SET_SJW(bt->std.sjw);
+		out_8(&regs->canbtr0, reg);
+
+		reg = (BTR1_SET_TSEG1(bt->std.prop_seg + bt->std.phase_seg1) |
+		       BTR1_SET_TSEG2(bt->std.phase_seg2) |
+		       BTR1_SET_SAM(bt->std.sam));
+		out_8(&regs->canbtr1, reg);
+
+		ret = mscan_pop_state(dev, &state);
+	}
+
+	spin_unlock_irq(&priv->can.irq_lock);
+	return ret;
+}
+
+static int mscan_open(struct net_device *dev)
+{
+	int ret;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	ret = request_irq(dev->irq, mscan_isr, IRQF_SHARED, dev->name, dev);
+
+	if (ret  < 0) {
+		printk(KERN_ERR "%s - failed to attach interrupt\n",
+		       dev->name);
+		return ret;
+	}
+
+	INIT_LIST_HEAD(&priv->tx_head);
+	/* acceptance mask/acceptance code (accept everything) */
+	out_be16(&regs->canidar1_0, 0);
+	out_be16(&regs->canidar3_2, 0);
+	out_be16(&regs->canidar5_4, 0);
+	out_be16(&regs->canidar7_6, 0);
+
+	out_be16(&regs->canidmr1_0, 0xffff);
+	out_be16(&regs->canidmr3_2, 0xffff);
+	out_be16(&regs->canidmr5_4, 0xffff);
+	out_be16(&regs->canidmr7_6, 0xffff);
+	/* Two 32 bit Acceptance Filters */
+	out_8(&regs->canidac, MSCAN_AF_32BIT);
+
+	out_8(&regs->canctl1, in_8(&regs->canctl1) & ~MSCAN_LISTEN);
+	mscan_set_mode(dev, MSCAN_NORMAL_MODE);
+
+	priv->shadow_statflg = in_8(&regs->canrflg) & MSCAN_STAT_MSK;
+	priv->cur_pri = 0;
+	priv->tx_active = 0;
+
+	out_8(&regs->cantier, 0);
+	/* Enable receive interrupts. */
+	out_8(&regs->canrier, MSCAN_OVRIE | MSCAN_RXFIE | MSCAN_CSCIE |
+	      MSCAN_RSTATE1 | MSCAN_RSTATE0 | MSCAN_TSTATE1 | MSCAN_TSTATE0);
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int mscan_close(struct net_device *dev)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	netif_stop_queue(dev);
+
+	/* disable interrupts */
+	out_8(&regs->cantier, 0);
+	out_8(&regs->canrier, 0);
+	free_irq(dev->irq, dev);
+
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+	return 0;
+}
+
+int register_mscandev(struct net_device *dev, int clock_src)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	u8 ctl1;
+
+	ctl1 = in_8(&regs->canctl1);
+	if (clock_src)
+		ctl1 |= MSCAN_CLKSRC;
+	else
+		ctl1 &= ~MSCAN_CLKSRC;
+
+	ctl1 |= MSCAN_CANE;
+	out_8(&regs->canctl1, ctl1);
+	udelay(100);
+
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+
+	return register_netdev(dev);
+}
+
+EXPORT_SYMBOL(register_mscandev);
+
+void unregister_mscandev(struct net_device *dev)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+	out_8(&regs->canctl1, in_8(&regs->canctl1) & ~MSCAN_CANE);
+	unregister_netdev(dev);
+}
+
+EXPORT_SYMBOL(unregister_mscandev);
+
+struct net_device *alloc_mscandev(void)
+{
+	struct net_device *dev;
+	struct mscan_priv *priv;
+	int i;
+
+	dev = alloc_candev(sizeof(struct mscan_priv));
+	if (!dev)
+		return NULL;
+	priv = netdev_priv(dev);
+
+	dev->watchdog_timeo = MSCAN_WATCHDOG_TIMEOUT;
+	dev->open = mscan_open;
+	dev->stop = mscan_close;
+	dev->hard_start_xmit = mscan_hard_start_xmit;
+	dev->tx_timeout = mscan_tx_timeout;
+
+	dev->poll = mscan_rx_poll;
+	dev->weight = 8;
+
+	priv->can.do_set_bit_time = mscan_do_set_bit_time;
+	priv->can.do_set_mode = mscan_do_set_mode;
+
+	for (i = 0; i < TX_QUEUE_SIZE; i++)
+		priv->tx_queue[i].mask = 1 << i;
+
+	return dev;
+}
+
+EXPORT_SYMBOL(alloc_mscandev);
+
+MODULE_AUTHOR("Andrey Volkov <avolkov@varma-el.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("CAN port driver for a mscan based chips");
Index: drivers/net/can/mscan/mscan.h
===================================================================
--- /dev/null
+++ drivers/net/can/mscan/mscan.h
@@ -0,0 +1,247 @@
+/*
+ * DESCRIPTION:
+ *  Definitions of consts/structs to drive the Freescale MSCAN.
+ *
+ * AUTHOR:
+ *  Andrey Volkov <avolkov@varma-el.com>
+ *
+ * COPYRIGHT:
+ *  2004-2006, Varma Electronics Oy
+ *
+ * LICENCE:
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __MSCAN_H__
+#define __MSCAN_H__
+
+#include <linux/autoconf.h>
+#include <asm/types.h>
+
+/* MSCAN control register 0 (CANCTL0) bits */
+#define MSCAN_RXFRM		0x80
+#define MSCAN_RXACT		0x40
+#define MSCAN_CSWAI		0x20
+#define MSCAN_SYNCH		0x10
+#define MSCAN_TIME		0x08
+#define MSCAN_WUPE		0x04
+#define MSCAN_SLPRQ		0x02
+#define MSCAN_INITRQ		0x01
+
+/* MSCAN control register 1 (CANCTL1) bits */
+#define MSCAN_CANE		0x80
+#define MSCAN_CLKSRC		0x40
+#define MSCAN_LOOPB		0x20
+#define MSCAN_LISTEN		0x10
+#define MSCAN_WUPM		0x04
+#define MSCAN_SLPAK		0x02
+#define MSCAN_INITAK		0x01
+
+#ifdef	CONFIG_PPC_MPC52xx
+#define MSCAN_CLKSRC_BUS	0
+#define MSCAN_CLKSRC_XTAL	MSCAN_CLKSRC
+#else
+#define MSCAN_CLKSRC_BUS	MSCAN_CLKSRC
+#define MSCAN_CLKSRC_XTAL	0
+#endif
+
+/* MSCAN receiver flag register (CANRFLG) bits */
+#define MSCAN_WUPIF		0x80
+#define MSCAN_CSCIF		0x40
+#define MSCAN_RSTAT1		0x20
+#define MSCAN_RSTAT0		0x10
+#define MSCAN_TSTAT1		0x08
+#define MSCAN_TSTAT0		0x04
+#define MSCAN_OVRIF		0x02
+#define MSCAN_RXF		0x01
+#define MSCAN_ERR_IF 		(MSCAN_OVRIF | MSCAN_CSCIF)
+#define MSCAN_RSTAT_MSK		(MSCAN_RSTAT1 | MSCAN_RSTAT0)
+#define MSCAN_TSTAT_MSK		(MSCAN_TSTAT1 | MSCAN_TSTAT0)
+#define MSCAN_STAT_MSK		(MSCAN_RSTAT_MSK | MSCAN_TSTAT_MSK)
+
+#define MSCAN_STATE_BUS_OFF	(MSCAN_RSTAT1 | MSCAN_RSTAT0 | \
+				 MSCAN_TSTAT1 | MSCAN_TSTAT0)
+#define MSCAN_STATE_TX(canrflg)	(((canrflg)&MSCAN_TSTAT_MSK)>>2)
+#define MSCAN_STATE_RX(canrflg)	(((canrflg)&MSCAN_RSTAT_MSK)>>4)
+#define MSCAN_STATE_ACTIVE	0
+#define MSCAN_STATE_WARNING	1
+#define MSCAN_STATE_PASSIVE	2
+#define MSCAN_STATE_BUSOFF	3
+
+/* MSCAN receiver interrupt enable register (CANRIER) bits */
+#define MSCAN_WUPIE		0x80
+#define MSCAN_CSCIE		0x40
+#define MSCAN_RSTATE1		0x20
+#define MSCAN_RSTATE0		0x10
+#define MSCAN_TSTATE1		0x08
+#define MSCAN_TSTATE0		0x04
+#define MSCAN_OVRIE		0x02
+#define MSCAN_RXFIE		0x01
+
+/* MSCAN transmitter flag register (CANTFLG) bits */
+#define MSCAN_TXE2		0x04
+#define MSCAN_TXE1		0x02
+#define MSCAN_TXE0		0x01
+#define MSCAN_TXE		(MSCAN_TXE2 | MSCAN_TXE1 | MSCAN_TXE0)
+
+/* MSCAN transmitter interrupt enable register (CANTIER) bits */
+#define MSCAN_TXIE2		0x04
+#define MSCAN_TXIE1		0x02
+#define MSCAN_TXIE0		0x01
+#define MSCAN_TXIE		(MSCAN_TXIE2 | MSCAN_TXIE1 | MSCAN_TXIE0)
+
+/* MSCAN transmitter message abort request (CANTARQ) bits */
+#define MSCAN_ABTRQ2		0x04
+#define MSCAN_ABTRQ1		0x02
+#define MSCAN_ABTRQ0		0x01
+
+/* MSCAN transmitter message abort ack (CANTAAK) bits */
+#define MSCAN_ABTAK2		0x04
+#define MSCAN_ABTAK1		0x02
+#define MSCAN_ABTAK0		0x01
+
+/* MSCAN transmit buffer selection (CANTBSEL) bits */
+#define MSCAN_TX2		0x04
+#define MSCAN_TX1		0x02
+#define MSCAN_TX0		0x01
+
+/* MSCAN ID acceptance control register (CANIDAC) bits */
+#define MSCAN_IDAM1		0x20
+#define MSCAN_IDAM0		0x10
+#define MSCAN_IDHIT2		0x04
+#define MSCAN_IDHIT1		0x02
+#define MSCAN_IDHIT0		0x01
+
+#define MSCAN_AF_32BIT		0x00
+#define MSCAN_AF_16BIT		MSCAN_IDAM0
+#define MSCAN_AF_8BIT		MSCAN_IDAM1
+#define MSCAN_AF_CLOSED		(MSCAN_IDAM0|MSCAN_IDAM1)
+#define MSCAN_AF_MASK		(~(MSCAN_IDAM0|MSCAN_IDAM1))
+
+/* MSCAN Miscellaneous Register (CANMISC) bits */
+#define MSCAN_BOHOLD		0x01
+
+#ifdef	CONFIG_PPC_MPC52xx
+#define _MSCAN_RESERVED_(n,num)	u8	_res##n[num]
+#define _MSCAN_RESERVED_DSR_SIZE	2
+#else
+#define _MSCAN_RESERVED_(n,num)
+#define _MSCAN_RESERVED_DSR_SIZE	0
+#endif
+
+/* Structure of the hardware registers */
+struct mscan_regs {
+	/* (see doco S12MSCANV3/D)		  MPC5200    MSCAN */
+	u8 canctl0;				/* + 0x00     0x00 */
+	u8 canctl1;				/* + 0x01     0x01 */
+	_MSCAN_RESERVED_(1, 2);			/* + 0x02          */
+	u8 canbtr0;				/* + 0x04     0x02 */
+	u8 canbtr1;				/* + 0x05     0x03 */
+	_MSCAN_RESERVED_(2, 2);			/* + 0x06          */
+	u8 canrflg;				/* + 0x08     0x04 */
+	u8 canrier;				/* + 0x09     0x05 */
+	_MSCAN_RESERVED_(3, 2);			/* + 0x0a          */
+	u8 cantflg;				/* + 0x0c     0x06 */
+	u8 cantier;				/* + 0x0d     0x07 */
+	_MSCAN_RESERVED_(4, 2);			/* + 0x0e          */
+	u8 cantarq;				/* + 0x10     0x08 */
+	u8 cantaak;				/* + 0x11     0x09 */
+	_MSCAN_RESERVED_(5, 2);			/* + 0x12          */
+	u8 cantbsel;				/* + 0x14     0x0a */
+	u8 canidac;				/* + 0x15     0x0b */
+	u8 reserved;				/* + 0x16     0x0c */
+	_MSCAN_RESERVED_(6, 5);			/* + 0x17          */
+#ifndef CONFIG_PPC_MPC52xx
+	u8 canmisc;				/*            0x0d */
+#endif
+	u8 canrxerr;				/* + 0x1c     0x0e */
+	u8 cantxerr;				/* + 0x1d     0x0f */
+	_MSCAN_RESERVED_(7, 2);			/* + 0x1e          */
+	u16 canidar1_0;				/* + 0x20     0x10 */
+	_MSCAN_RESERVED_(8, 2);			/* + 0x22          */
+	u16 canidar3_2;				/* + 0x24     0x12 */
+	_MSCAN_RESERVED_(9, 2);			/* + 0x26          */
+	u16 canidmr1_0;				/* + 0x28     0x14 */
+	_MSCAN_RESERVED_(10, 2);		/* + 0x2a          */
+	u16 canidmr3_2;				/* + 0x2c     0x16 */
+	_MSCAN_RESERVED_(11, 2);		/* + 0x2e          */
+	u16 canidar5_4;				/* + 0x30     0x18 */
+	_MSCAN_RESERVED_(12, 2);		/* + 0x32          */
+	u16 canidar7_6;				/* + 0x34     0x1a */
+	_MSCAN_RESERVED_(13, 2);		/* + 0x36          */
+	u16 canidmr5_4;				/* + 0x38     0x1c */
+	_MSCAN_RESERVED_(14, 2);		/* + 0x3a          */
+	u16 canidmr7_6;				/* + 0x3c     0x1e */
+	_MSCAN_RESERVED_(15, 2);		/* + 0x3e          */
+	struct {
+		u16 idr1_0;			/* + 0x40     0x20 */
+		 _MSCAN_RESERVED_(16, 2);	/* + 0x42          */
+		u16 idr3_2;			/* + 0x44     0x22 */
+		 _MSCAN_RESERVED_(17, 2);	/* + 0x46          */
+		u16 dsr1_0;			/* + 0x48     0x24 */
+		 _MSCAN_RESERVED_(18, 2);	/* + 0x4a          */
+		u16 dsr3_2;			/* + 0x4c     0x26 */
+		 _MSCAN_RESERVED_(19, 2);	/* + 0x4e          */
+		u16 dsr5_4;			/* + 0x50     0x28 */
+		 _MSCAN_RESERVED_(20, 2);	/* + 0x52          */
+		u16 dsr7_6;			/* + 0x54     0x2a */
+		 _MSCAN_RESERVED_(21, 2);	/* + 0x56          */
+		u8 dlr;				/* + 0x58     0x2c */
+		 u8:8;				/* + 0x59     0x2d */
+		 _MSCAN_RESERVED_(22, 2);	/* + 0x5a          */
+		u16 time;			/* + 0x5c     0x2e */
+	} rx;
+	 _MSCAN_RESERVED_(23, 2);		/* + 0x5e          */
+	struct {
+		u16 idr1_0;			/* + 0x60     0x30 */
+		 _MSCAN_RESERVED_(24, 2);	/* + 0x62          */
+		u16 idr3_2;			/* + 0x64     0x32 */
+		 _MSCAN_RESERVED_(25, 2);	/* + 0x66          */
+		u16 dsr1_0;			/* + 0x68     0x34 */
+		 _MSCAN_RESERVED_(26, 2);	/* + 0x6a          */
+		u16 dsr3_2;			/* + 0x6c     0x36 */
+		 _MSCAN_RESERVED_(27, 2);	/* + 0x6e          */
+		u16 dsr5_4;			/* + 0x70     0x38 */
+		 _MSCAN_RESERVED_(28, 2);	/* + 0x72          */
+		u16 dsr7_6;			/* + 0x74     0x3a */
+		 _MSCAN_RESERVED_(29, 2);	/* + 0x76          */
+		u8 dlr;				/* + 0x78     0x3c */
+		u8 tbpr;			/* + 0x79     0x3d */
+		 _MSCAN_RESERVED_(30, 2);	/* + 0x7a          */
+		u16 time;			/* + 0x7c     0x3e */
+	} tx;
+	 _MSCAN_RESERVED_(31, 2);		/* + 0x7e          */
+} __attribute__ ((packed));
+
+#undef _MSCAN_RESERVED_
+#define MSCAN_REGION 	sizeof(struct mscan)
+
+#define MSCAN_WATCHDOG_TIMEOUT	((500*HZ)/1000)
+
+struct mscan_platform_data {
+	u8 clock_src;		/* MSCAN_CLKSRC_BUS or MSCAN_CLKSRC_XTAL */
+	u32 clock_frq;		/* can ref. clock, in Hz */
+};
+
+struct net_device *alloc_mscandev(void);
+/* @clock_src:
+	1 = The MSCAN clock source is the onchip Bus Clock.
+	0 = The MSCAN clock source is the chip Oscillator Clock.
+*/
+extern int register_mscandev(struct net_device *dev, int clock_src);
+extern void unregister_mscandev(struct net_device *dev);
+
+#endif				/* __MSCAN_H__ */
Index: drivers/net/can/sja1000/Makefile
===================================================================
--- /dev/null
+++ drivers/net/can/sja1000/Makefile
@@ -0,0 +1,66 @@
+#
+#
+#  Copyright (c) 2002-2005 Volkswagen Group Electronic Research
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#  1. Redistributions of source code must retain the above copyright
+#     notice, this list of conditions, the following disclaimer and
+#     the referenced file 'COPYING'.
+#  2. Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#  3. Neither the name of Volkswagen nor the names of its contributors
+#     may be used to endorse or promote products derived from this software
+#     without specific prior written permission.
+#
+#  Alternatively, provided that this notice is retained in full, this
+#  software may be distributed under the terms of the GNU General
+#  Public License ("GPL") version 2 as distributed in the 'COPYING'
+#  file from the main directory of the linux kernel source.
+#
+#  The provided data structures and external interfaces from this code
+#  are not restricted to be used by modules with a GPL compatible license.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+#  DAMAGE.
+#
+#  Send feedback to <socketcan-users@lists.berlios.de>
+
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../../../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+else
+
+-include $(TOPDIR)/Makefile.common
+EXTRA_CFLAGS += -I$(TOPDIR)/drivers/net/can/hal
+
+obj-m := sja1000-io.o sja1000-iomem.o sja1000-iomux.o sja1000-gw2.o sja1000-esdio.o sja1000-c200.o
+
+sja1000-io-objs    := sja1000.o proc.o ../hal/io.o
+sja1000-iomem-objs := sja1000.o proc.o ../hal/iomem.o
+sja1000-iomux-objs := sja1000.o proc.o ../hal/iomux.o
+sja1000-gw2-objs   := sja1000.o proc.o ../hal/gw2.o
+sja1000-esdio-objs := sja1000.o proc.o ../hal/esdio.o
+sja1000-c200-objs  := sja1000.o proc.o ../hal/c200.o
+
+endif
Index: drivers/net/can/sja1000/proc.c
===================================================================
--- /dev/null
+++ drivers/net/can/sja1000/proc.c
@@ -0,0 +1,232 @@
+/*
+ * proc.c -  proc file system functions for SJA1000 CAN driver.
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/netdevice.h>
+
+#include <linux/can.h>
+#include <linux/can/ioctl.h>
+#include "sja1000.h"
+#include "hal.h"
+
+extern struct net_device *can_dev[];
+
+static struct proc_dir_entry *pde       = NULL;
+static struct proc_dir_entry *pde_regs  = NULL;
+static struct proc_dir_entry *pde_reset = NULL;
+
+static int can_proc_read_stats(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	int len = 0;
+	int i;
+
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"CAN bus device statistics:\n");
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"       errwarn  overrun   wakeup   buserr   "
+			"errpass  arbitr   restarts clock        baud\n");
+	for (i = 0; (i < MAXDEV) && (len < PAGE_SIZE - 200); i++) {
+		if (can_dev[i]) {
+			struct net_device *dev = can_dev[i];
+			struct can_priv *priv  = netdev_priv(dev);
+#ifdef SJA1000_H
+			u8 stat = hw_readreg(dev->base_addr, REG_SR);
+
+			if (stat & 0x80) {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"%s: bus status: "
+						"BUS OFF, ", dev->name);
+			} else if (stat & 0x40) {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"%s: bus status: ERROR "
+						"PASSIVE, ", dev->name);
+			} else {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"%s: bus status: OK, ",
+						dev->name);
+			}
+			len += snprintf(page + len, PAGE_SIZE - len,
+					"RXERR: %d, TXERR: %d\n",
+					hw_readreg(dev->base_addr, REG_RXERR),
+					hw_readreg(dev->base_addr, REG_TXERR));
+#endif
+			len += snprintf(page + len, PAGE_SIZE - len,
+					"%s: %8d %8d %8d %8d %8d "
+					"%8d %8d %10d %8d\n", dev->name,
+					priv->can_stats.error_warning,
+					priv->can_stats.data_overrun,
+					priv->can_stats.wakeup,
+					priv->can_stats.bus_error,
+					priv->can_stats.error_passive,
+					priv->can_stats.arbitration_lost,
+					priv->can_stats.restarts,
+					priv->clock,
+					priv->speed
+				);
+
+		}
+	}
+
+	*eof = 1;
+	return len;
+}
+
+
+static int can_proc_dump_regs(char *page, int len, struct net_device *dev)
+{
+	int r,s;
+	struct can_priv	*priv = netdev_priv(dev);
+	int regs = priv->hw_regs;
+
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"%s registers:\n", dev->name);
+
+	for (r = 0; r < regs; r += 0x10) {
+		len += snprintf(page + len, PAGE_SIZE - len, "%02X: ", r);
+		for (s = 0; s < 0x10; s++) {
+			if (r+s < regs)
+				len += snprintf(page + len, PAGE_SIZE-len,
+						"%02X ",
+						hw_readreg(dev->base_addr,
+							   r+s));
+		}
+		len += snprintf(page + len, PAGE_SIZE - len, "\n");
+	}
+
+        return len;
+}
+
+static int can_proc_read_regs(char *page, char **start, off_t off,
+				  int count, int *eof, void *data)
+{
+	int len = 0;
+	int i;
+
+	for (i = 0; (i < MAXDEV) && (len < PAGE_SIZE - 200); i++) {
+		if (can_dev[i])
+			len = can_proc_dump_regs(page, len, can_dev[i]);
+	}
+
+	*eof = 1;
+	return len;
+}
+
+static int can_proc_read_reset(char *page, char **start, off_t off,
+				   int count, int *eof, void *data)
+{
+	int len = 0;
+	struct net_device *dev;
+	int i;
+	struct can_priv   *priv;
+
+	len += snprintf(page + len, PAGE_SIZE - len, "resetting ");
+	for (i = 0; (i < MAXDEV) && (len < PAGE_SIZE - 200); i++) {
+		if (can_dev[i]) {
+			dev = can_dev[i];
+			priv = netdev_priv(can_dev[i]);
+			if ((priv->state != STATE_UNINITIALIZED)
+			    && (priv->state != STATE_RESET_MODE)) {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"%s ", dev->name);
+				dev->stop(dev);
+				dev->open(dev);
+				/* count number of restarts */
+				priv->can_stats.restarts++;
+
+			} else {
+				len += snprintf(page + len, PAGE_SIZE - len,
+						"(%s|%d) ", dev->name,
+						priv->state);
+			}
+		}
+	}
+
+	len += snprintf(page + len, PAGE_SIZE - len, "done\n");
+
+	*eof = 1;
+	return len;
+}
+
+void can_proc_create(const char *drv_name)
+{
+	char fname[256];
+
+	if (pde == NULL) {
+		sprintf(fname, PROCBASE "/%s_stats", drv_name);
+		pde = create_proc_read_entry(fname, 0644, NULL,
+					     can_proc_read_stats, NULL);
+	}
+	if (pde_regs == NULL) {
+		sprintf(fname, PROCBASE "/%s_regs", drv_name);
+		pde_regs = create_proc_read_entry(fname, 0644, NULL,
+						  can_proc_read_regs, NULL);
+	}
+	if (pde_reset == NULL) {
+		sprintf(fname, PROCBASE "/%s_reset", drv_name);
+		pde_reset = create_proc_read_entry(fname, 0644, NULL,
+						   can_proc_read_reset, NULL);
+	}
+}
+
+void can_proc_remove(const char *drv_name)
+{
+	char fname[256];
+
+	if (pde) {
+		sprintf(fname, PROCBASE "/%s_stats", drv_name);
+		remove_proc_entry(fname, NULL);
+	}
+	if (pde_regs) {
+		sprintf(fname, PROCBASE "/%s_regs", drv_name);
+		remove_proc_entry(fname, NULL);
+	}
+	if (pde_reset) {
+		sprintf(fname, PROCBASE "/%s_reset", drv_name);
+		remove_proc_entry(fname, NULL);
+	}
+}
Index: drivers/net/can/sja1000/sja1000.c
===================================================================
--- /dev/null
+++ drivers/net/can/sja1000/sja1000.c
@@ -0,0 +1,1173 @@
+/*
+ * sja1000.c -  Philips SJA1000 network device driver
+ *
+ * Copyright (c) 2003 Matthias Brukner, Trajet Gmbh, Rebenring 33,
+ * 38106 Braunschweig, GERMANY
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+
+#include <linux/can.h>
+#include <linux/can/ioctl.h> /* for struct can_device_stats */
+#include "sja1000.h"
+#include "hal.h"
+
+MODULE_AUTHOR("Oliver Hartkopp <oliver.hartkopp@volkswagen.de>");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("LLCF/socketcan '" CHIP_NAME "' network device driver");
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+#define DBG(args...)   ((priv->debug > 0) ? printk(args) : 0)
+/* logging in interrupt context! */
+#define iDBG(args...)  ((priv->debug > 1) ? printk(args) : 0)
+#define iiDBG(args...) ((priv->debug > 2) ? printk(args) : 0)
+#else
+#define DBG(args...)
+#define iDBG(args...)
+#define iiDBG(args...)
+#endif
+
+char drv_name[DRV_NAME_LEN] = "undefined";
+
+/* driver and version information */
+static const char *drv_version	= "0.1.1";
+static const char *drv_reldate	= "2007-04-13";
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+static const char *ecc_errors[] = {
+	NULL,
+	NULL,
+	"ID.28 to ID.28",
+	"start of frame",
+	"bit SRTR",
+	"bit IDE",
+	"ID.20 to ID.18",
+	"ID.17 to ID.13",
+	"CRC sequence",
+	"reserved bit 0",
+	"data field",
+	"data length code",
+	"bit RTR",
+	"reserved bit 1",
+	"ID.4 to ID.0",
+	"ID.12 to ID.5",
+	NULL,
+	"active error flag",
+	"intermission",
+	"tolerate dominant bits",
+	NULL,
+	NULL,
+	"passive error flag",
+	"error delimiter",
+	"CRC delimiter",
+	"acknowledge slot",
+	"end of frame",
+	"acknowledge delimiter",
+	"overload flag",
+	NULL,
+	NULL,
+	NULL
+};
+
+static const char *ecc_types[] = {
+	"bit error",
+	"form error",
+	"stuff error",
+	"other type of error"
+};
+#endif
+
+/* array of all can chips */
+struct net_device *can_dev[MAXDEV];
+
+/* module parameters */
+unsigned long base[MAXDEV]	= { 0 }; /* hardware address */
+unsigned long rbase[MAXDEV]	= { 0 }; /* (remapped) device address */
+unsigned int  irq[MAXDEV]	= { 0 };
+
+unsigned int speed[MAXDEV]	= { DEFAULT_SPEED, DEFAULT_SPEED };
+unsigned int btr[MAXDEV]	= { 0 };
+
+static int rx_probe[MAXDEV]	= { 0 };
+static int clk			= DEFAULT_HW_CLK;
+static int debug		= 0;
+static int restart_ms		= 100;
+static int loopback		= 1;
+
+static int base_n;
+static int irq_n;
+static int speed_n;
+static int btr_n;
+static int rx_probe_n;
+
+module_param_array(base, int, &base_n, 0);
+module_param_array(irq, int, &irq_n, 0);
+module_param_array(speed, int, &speed_n, 0);
+module_param_array(btr, int, &btr_n, 0);
+module_param_array(rx_probe, int, &rx_probe_n, 0);
+
+module_param(clk, int, 0);
+module_param(debug, int, 0);
+module_param(restart_ms, int, 0);
+module_param(loopback, int, S_IRUGO);
+
+MODULE_PARM_DESC(base, "CAN controller base address");
+MODULE_PARM_DESC(irq, "CAN controller interrupt");
+MODULE_PARM_DESC(speed, "CAN bus bitrate");
+MODULE_PARM_DESC(btr, "Bit Timing Register value 0x<btr0><btr1>, e.g. 0x4014");
+MODULE_PARM_DESC(rx_probe, "switch to trx mode after correct msg receiption. (default off)");
+
+MODULE_PARM_DESC(clk, "CAN controller chip clock (default: 16MHz)");
+MODULE_PARM_DESC(debug, "set debug mask (default: 0)");
+MODULE_PARM_DESC(restart_ms, "restart chip on heavy bus errors / bus off after x ms (default 100ms)");
+MODULE_PARM_DESC(loopback, "Loop back sent frames. default: 1 (On)");
+
+/*
+ * CAN network devices *should* support a local loopback functionality
+ * (see Documentation/networking/can.txt). To test the handling of CAN
+ * interfaces that do not support the loopback both driver types are
+ * implemented inside this sja1000 driver. In the case that the driver does
+ * not support the loopback the IFF_LOOPBACK remains clear in dev->flags.
+ * This causes the PF_CAN core to perform the loopback as a fallback solution.
+ */
+
+/* function declarations */
+
+static void can_restart_dev(unsigned long data);
+static void chipset_init(struct net_device *dev, int wake);
+static void chipset_init_rx(struct net_device *dev);
+static void chipset_init_trx(struct net_device *dev);
+static void can_netdev_setup(struct net_device *dev);
+static struct net_device* can_create_netdev(int dev_num, int hw_regs);
+static int  can_set_drv_name(void);
+int set_reset_mode(struct net_device *dev);
+
+static int sja1000_probe_chip(unsigned long base)
+{
+	if (base && (hw_readreg(base, 0) == 0xFF)) {
+		printk(KERN_INFO "%s: probing @0x%lX failed\n",
+		       drv_name, base);
+		return 0;
+	}
+	return 1;
+}
+
+/*
+ * set baud rate divisor values
+ */
+static void set_btr(struct net_device *dev, int btr0, int btr1)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* no bla bla when restarting the device */
+	if (priv->state == STATE_UNINITIALIZED)
+		printk(KERN_INFO "%s: setting BTR0=%02X BTR1=%02X\n",
+		       dev->name, btr0, btr1);
+
+	hw_writereg(dev->base_addr, REG_BTR0, btr0);
+	hw_writereg(dev->base_addr, REG_BTR1, btr1);
+}
+
+/*
+ * calculate baud rate divisor values
+ */
+static void set_baud(struct net_device *dev, int baud, int clock)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	int error;
+	int brp;
+	int tseg;
+	int tseg1 = 0;
+	int tseg2 = 0;
+
+	int best_error = 1000000000;
+	int best_tseg = 0;
+	int best_brp = 0;
+	int best_baud = 0;
+
+	int SAM = (baud > 100000 ? 0 : 1);
+
+	clock >>= 1;
+
+	for (tseg = (0 + 0 + 2) * 2;
+	     tseg <= (MAX_TSEG2 + MAX_TSEG1 + 2) * 2 + 1;
+	     tseg++) {
+		brp = clock / ((1 + tseg / 2) * baud) + tseg % 2;
+		if ((brp > 0) && (brp <= 64)) {
+			error = baud - clock / (brp * (1 + tseg / 2));
+			if (error < 0) {
+				error = -error;
+			}
+			if (error <= best_error) {
+				best_error = error;
+				best_tseg = tseg / 2;
+				best_brp = brp - 1;
+				best_baud = clock / (brp * (1 + tseg / 2));
+			}
+		}
+	}
+	if (best_error && (baud / best_error < 10)) {
+		printk("%s: unable to set baud rate %d (ext clock %dHz)\n",
+		       dev->name, baud, clock * 2);
+		return;
+//		return -EINVAL;
+	}
+	tseg2 = best_tseg - (SAMPLE_POINT * (best_tseg + 1)) / 100;
+	if (tseg2 < 0) {
+		tseg2 = 0;
+	} else if (tseg2 > MAX_TSEG2) {
+		tseg2 = MAX_TSEG2;
+	}
+	tseg1 = best_tseg - tseg2 - 2;
+	if (tseg1 > MAX_TSEG1) {
+		tseg1 = MAX_TSEG1;
+		tseg2 = best_tseg - tseg1 - 2;
+	}
+
+	priv->btr = ((best_brp | JUMPWIDTH)<<8) + 
+		((SAM << 7) | (tseg2 << 4) | tseg1);
+
+	printk(KERN_INFO "%s: calculated best baudrate: %d / btr is 0x%04X\n",
+	       dev->name, best_baud, priv->btr);
+
+	set_btr(dev, (priv->btr>>8) & 0xFF, priv->btr & 0xFF);
+//	set_btr(dev, best_brp | JUMPWIDTH, (SAM << 7) | (tseg2 << 4) | tseg1);
+}
+
+int set_reset_mode(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned char status = hw_readreg(dev->base_addr, REG_MOD);
+	int i;
+
+	priv->can_stats.bus_error_at_init = priv->can_stats.bus_error;
+
+	/* disable interrupts */
+	hw_writereg(dev->base_addr, REG_IER, IRQ_OFF);
+
+	for (i = 0; i < 10; i++) {
+		/* check reset bit */
+		if (status & MOD_RM) {
+			if (i > 1) {
+				iDBG(KERN_INFO "%s: %s looped %d times\n",
+				     dev->name, __FUNCTION__, i);
+			}
+			priv->state = STATE_RESET_MODE;
+			return 0;
+		}
+
+		hw_writereg(dev->base_addr, REG_MOD, MOD_RM); /* reset chip */
+		status = hw_readreg(dev->base_addr, REG_MOD);
+
+	}
+
+	printk(KERN_ERR "%s: setting sja1000 into reset mode failed!\n",
+	       dev->name);
+	return 1;
+
+}
+
+static int set_normal_mode(struct net_device *dev)
+{
+	unsigned char status = hw_readreg(dev->base_addr, REG_MOD);
+	int i;
+
+	for (i = 0; i < 10; i++) {
+		/* check reset bit */
+		if ((status & MOD_RM) == 0) {
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+			if (i > 1) {
+				struct can_priv *priv = netdev_priv(dev);
+				iDBG(KERN_INFO "%s: %s looped %d times\n",
+				     dev->name, __FUNCTION__, i);
+			}
+#endif
+			return 0;
+		}
+
+		/* set chip to normal mode */
+		hw_writereg(dev->base_addr, REG_MOD, 0x00);
+		status = hw_readreg(dev->base_addr, REG_MOD);
+	}
+
+	printk(KERN_ERR "%s: setting sja1000 into normal mode failed!\n",
+	       dev->name);
+	return 1;
+
+}
+
+static int set_listen_mode(struct net_device *dev)
+{
+	unsigned char status = hw_readreg(dev->base_addr, REG_MOD);
+	int i;
+
+	for (i = 0; i < 10; i++) {
+		/* check reset mode bit */
+		if ((status & MOD_RM) == 0) {
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+			if (i > 1) {
+				struct can_priv *priv = netdev_priv(dev);
+				iDBG(KERN_INFO "%s: %s looped %d times\n",
+				     dev->name, __FUNCTION__, i);
+			}
+#endif
+			return 0;
+		}
+
+		/* set listen only mode, clear reset */
+		hw_writereg(dev->base_addr, REG_MOD, MOD_LOM);
+		status = hw_readreg(dev->base_addr, REG_MOD);
+	}
+
+	printk(KERN_ERR "%s: setting sja1000 into listen mode failed!\n",
+	       dev->name);
+	return 1;
+
+}
+
+/*
+ * initialize SJA1000 chip:
+ *   - reset chip
+ *   - set output mode
+ *   - set baudrate
+ *   - enable interrupts
+ *   - start operating mode
+ */
+static void chipset_init_regs(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned long base = dev->base_addr;
+
+	/* go into Pelican mode, disable clkout, disable comparator */
+	hw_writereg(base, REG_CDR, 0xCF);
+
+	/* output control */
+	/* connected to external transceiver */
+	hw_writereg(base, REG_OCR, 0x1A);
+
+	/* set acceptance filter (accept all) */
+	hw_writereg(base, REG_ACCC0, 0x00);
+	hw_writereg(base, REG_ACCC1, 0x00);
+	hw_writereg(base, REG_ACCC2, 0x00);
+	hw_writereg(base, REG_ACCC3, 0x00);
+
+	hw_writereg(base, REG_ACCM0, 0xFF);
+	hw_writereg(base, REG_ACCM1, 0xFF);
+	hw_writereg(base, REG_ACCM2, 0xFF);
+	hw_writereg(base, REG_ACCM3, 0xFF);
+
+	/* set baudrate */
+	if (priv->btr) { /* no calculation when btr is provided */
+		set_btr(dev, (priv->btr>>8) & 0xFF, priv->btr & 0xFF);
+	} else {
+		if (priv->speed == 0) {
+			priv->speed = DEFAULT_SPEED;
+		}
+		set_baud(dev, priv->speed * 1000, priv->clock);
+	}
+
+	/* output control */
+	/* connected to external transceiver */
+	hw_writereg(base, REG_OCR, 0x1A);
+}
+
+static void chipset_init(struct net_device *dev, int wake)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (priv->rx_probe)
+		chipset_init_rx(dev); /* wait for valid reception first */
+	else
+		chipset_init_trx(dev);
+
+	if ((wake) && netif_queue_stopped(dev)) {
+		if (priv->loop_skb) { /* pending loopback? */
+			kfree_skb(priv->loop_skb);
+			priv->loop_skb = NULL;
+		}
+		netif_wake_queue(dev);
+	}
+}
+
+static void chipset_init_rx(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	iDBG(KERN_INFO "%s: %s()\n", dev->name, __FUNCTION__);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	/* set registers */
+	chipset_init_regs(dev);
+
+	/* automatic bit rate detection */
+	set_listen_mode(dev);
+
+	priv->state = STATE_PROBE;
+
+	/* enable receive and error interrupts */
+	hw_writereg(dev->base_addr, REG_IER, IRQ_RI | IRQ_EI);
+}
+
+static void chipset_init_trx(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	iDBG(KERN_INFO "%s: %s()\n", dev->name, __FUNCTION__);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	/* set registers */
+	chipset_init_regs(dev);
+
+	/* leave reset mode */
+	set_normal_mode(dev);
+
+	priv->state = STATE_ACTIVE;
+
+	/* enable all interrupts */
+	hw_writereg(dev->base_addr, REG_IER, IRQ_ALL);
+}
+
+/*
+ * transmit a CAN message
+ * message layout in the sk_buff should be like this:
+ * xx xx xx xx	 ff	 ll   00 11 22 33 44 55 66 77
+ * [  can-id ] [flags] [len] [can data (up to 8 bytes]
+ */
+static int can_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct can_priv  *priv	= netdev_priv(dev);
+	struct can_frame *cf	= (struct can_frame*)skb->data;
+	unsigned long base	= dev->base_addr;
+	uint8_t	fi;
+	uint8_t	dlc;
+	canid_t	id;
+	uint8_t	dreg;
+	int	loop;
+	int	i;
+
+	netif_stop_queue(dev);
+
+	fi = dlc = cf->can_dlc;
+	id = cf->can_id;
+
+	if (id & CAN_RTR_FLAG)
+		fi |= FI_RTR;
+
+	if (id & CAN_EFF_FLAG) {
+		fi |= FI_FF;
+		dreg = EFF_BUF;
+		hw_writereg(base, REG_FI, fi);
+		hw_writereg(base, REG_ID1, (id & 0x1fe00000) >> (5 + 16));
+		hw_writereg(base, REG_ID2, (id & 0x001fe000) >> (5 + 8));
+		hw_writereg(base, REG_ID3, (id & 0x00001fe0) >> 5);
+		hw_writereg(base, REG_ID4, (id & 0x0000001f) << 3);
+	} else {
+		dreg = SFF_BUF;
+		hw_writereg(base, REG_FI, fi);
+		hw_writereg(base, REG_ID1, (id & 0x000007f8) >> 3);
+		hw_writereg(base, REG_ID2, (id & 0x00000007) << 5);
+	}
+
+	for (i = 0; i < dlc; i++) {
+		hw_writereg(base, dreg++, cf->data[i]);
+	}
+
+	hw_writereg(base, REG_CMR, CMD_TR);
+
+	priv->stats.tx_bytes += dlc;
+
+	dev->trans_start = jiffies;
+
+	/* set flag whether this packet has to be looped back */
+	loop = skb->pkt_type == PACKET_LOOPBACK;
+
+	if (!loopback || !loop) {
+		kfree_skb(skb);
+		return 0;
+	}
+
+	if (!priv->loop_skb) {
+		struct sock *srcsk = skb->sk;
+
+		if (atomic_read(&skb->users) != 1) {
+			struct sk_buff *old_skb = skb;
+
+			skb = skb_clone(old_skb, GFP_ATOMIC);
+			DBG(KERN_INFO "%s: %s: freeing old skbuff %p, "
+			    "using new skbuff %p\n",
+			    dev->name, __FUNCTION__, old_skb, skb);
+			kfree_skb(old_skb);
+			if (!skb) {
+				return 0;
+			}
+		} else
+			skb_orphan(skb);
+
+		skb->sk = srcsk;
+
+		/* make settings for loopback to reduce code in irq context */
+		skb->protocol	= htons(ETH_P_CAN);
+		skb->pkt_type	= PACKET_BROADCAST;
+		skb->ip_summed	= CHECKSUM_UNNECESSARY;
+		skb->dev	= dev;
+
+		/* save this skb for tx interrupt loopback handling */
+		priv->loop_skb = skb;
+
+	} else {
+		/* locking problem with netif_stop_queue() ?? */
+		printk(KERN_ERR "%s: %s: occupied loop_skb!\n",
+		       dev->name, __FUNCTION__ );
+		kfree_skb(skb);
+	}
+
+	return 0;
+}
+
+static void can_tx_timeout(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	priv->stats.tx_errors++;
+
+	/* do not conflict with e.g. bus error handling */
+	if (!(priv->timer.expires)){ /* no restart on the run */
+		chipset_init_trx(dev); /* no tx queue wakeup */
+		if (priv->loop_skb) { /* pending loopback? */
+			kfree_skb(priv->loop_skb);
+			priv->loop_skb = NULL;
+		}
+		netif_wake_queue(dev); /* wakeup here */
+	}
+	else
+		DBG(KERN_INFO "%s: %s: can_restart_dev already active.\n",
+		    dev->name, __FUNCTION__ );
+
+}
+
+static void can_restart_on(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (!(priv->timer.expires)){ /* no restart on the run */
+
+		set_reset_mode(dev);
+
+		priv->timer.function = can_restart_dev;
+		priv->timer.data = (unsigned long) dev;
+
+		/* restart chip on persistent error in <xxx> ms */
+		priv->timer.expires = jiffies + (priv->restart_ms * HZ) / 1000;
+		add_timer(&priv->timer);
+
+		iDBG(KERN_INFO "%s: %s start (%ld)\n",
+		     dev->name, __FUNCTION__ , jiffies);
+	} else
+		iDBG(KERN_INFO "%s: %s already (%ld)\n",
+		     dev->name, __FUNCTION__ , jiffies);
+}
+
+static void can_restart_dev(unsigned long data)
+{
+	struct net_device *dev = (struct net_device*) data;
+	struct can_priv *priv = netdev_priv(dev);
+
+	DBG(KERN_INFO "%s: can_restart_dev (%ld)\n",
+	    dev->name, jiffies);
+
+	/* mark inactive timer */
+	priv->timer.expires = 0;
+
+	if (priv->state != STATE_UNINITIALIZED) {
+
+		/* count number of restarts */
+		priv->can_stats.restarts++;
+
+		chipset_init(dev, 1);
+	}
+}
+
+#if 0
+/* the timerless version */
+
+static void can_restart_now(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	if (priv->state != STATE_UNINITIALIZED) {
+
+		/* count number of restarts */
+		priv->can_stats.restarts++;
+
+		chipset_init(dev, 1);
+	}
+}
+#endif
+
+static void can_rx(struct net_device *dev)
+{
+	struct can_priv *priv	= netdev_priv(dev);
+	unsigned long base	= dev->base_addr;
+	struct can_frame *cf;
+	struct sk_buff	*skb;
+	uint8_t	fi;
+	uint8_t	dreg;
+	canid_t	id;
+	uint8_t	dlc;
+	int	i;
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (skb == NULL) {
+		return;
+	}
+	skb->dev = dev;
+	skb->protocol = htons(ETH_P_CAN);
+
+	fi = hw_readreg(base, REG_FI);
+	dlc = fi & 0x0F;
+
+	if (fi & FI_FF) {
+		/* extended frame format (EFF) */
+		dreg = EFF_BUF;
+		id = (hw_readreg(base, REG_ID1) << (5+16))
+			| (hw_readreg(base, REG_ID2) << (5+8))
+			| (hw_readreg(base, REG_ID3) << 5)
+			| (hw_readreg(base, REG_ID4) >> 3);
+		id |= CAN_EFF_FLAG;
+	} else {
+		/* standard frame format (SFF) */
+		dreg = SFF_BUF;
+		id = (hw_readreg(base, REG_ID1) << 3)
+			| (hw_readreg(base, REG_ID2) >> 5);
+	}
+
+	if (fi & FI_RTR)
+		id |= CAN_RTR_FLAG;
+
+	cf = (struct can_frame*)skb_put(skb, sizeof(struct can_frame));
+	memset(cf, 0, sizeof(struct can_frame));
+	cf->can_id    = id;
+	cf->can_dlc   = dlc;
+	for (i = 0; i < dlc; i++) {
+		cf->data[i] = hw_readreg(base, dreg++);
+	}
+	while (i < 8)
+		cf->data[i++] = 0;
+
+	/* release receive buffer */
+	hw_writereg(base, REG_CMR, CMD_RRB);
+
+	netif_rx(skb);
+
+	dev->last_rx = jiffies;
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += dlc;
+}
+
+static struct net_device_stats *can_get_stats(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* TODO: read statistics from chip */
+	return &priv->stats;
+}
+
+static int can_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	switch (cmd) {
+	case SIOCSCANBAUDRATE:
+		;
+		return 0;
+	case SIOCGCANBAUDRATE:
+		;
+		return 0;
+	}
+	return 0;
+}
+
+/*
+ * SJA1000 interrupt handler
+ */
+static irqreturn_t can_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev	= (struct net_device*)dev_id;
+	struct can_priv *priv	= netdev_priv(dev);
+	unsigned long base	= dev->base_addr;
+	uint8_t isrc, status, ecc, alc;
+	int n = 0;
+
+	hw_preirq(dev);
+
+	iiDBG(KERN_INFO "%s: interrupt\n", dev->name);
+
+	if (priv->state == STATE_UNINITIALIZED) {
+		printk(KERN_ERR "%s: %s: uninitialized controller!\n",
+		       dev->name, __FUNCTION__);
+		chipset_init(dev, 1); /* should be possible at this stage */
+		return IRQ_NONE;
+	}
+
+	if (priv->state == STATE_RESET_MODE) {
+		iiDBG(KERN_ERR "%s: %s: controller is in reset mode! "
+		      "MOD=0x%02X IER=0x%02X IR=0x%02X SR=0x%02X!\n",
+		      dev->name, __FUNCTION__, hw_readreg(base, REG_MOD),
+		      hw_readreg(base, REG_IER), hw_readreg(base, REG_IR),
+		      hw_readreg(base, REG_SR));
+		return IRQ_NONE;
+	}
+
+	while ((isrc = hw_readreg(base, REG_IR)) && (n < 20)) {
+		n++;
+		status = hw_readreg(base, REG_SR);
+
+		if (isrc & IRQ_WUI) {
+			/* wake-up interrupt */
+			priv->can_stats.wakeup++;
+		}
+		if (isrc & IRQ_TI) {
+			/* transmission complete interrupt */
+			priv->stats.tx_packets++;
+
+			if (loopback && priv->loop_skb) {
+				netif_rx(priv->loop_skb);
+				priv->loop_skb = NULL;
+			}
+
+			netif_wake_queue(dev);
+		}
+		if (isrc & IRQ_RI) {
+			/* receive interrupt */
+
+			while (status & SR_RBS) {
+				can_rx(dev);
+				status = hw_readreg(base, REG_SR);
+			}
+			if (priv->state == STATE_PROBE) {
+				/* valid RX -> switch to trx-mode */
+				iDBG(KERN_INFO "%s: RI #%d#\n", dev->name, n);
+				chipset_init_trx(dev); /* no tx queue wakeup */
+				break; /* check again after init controller */
+			}
+		}
+		if (isrc & IRQ_DOI) {
+			/* data overrun interrupt */
+			iiDBG(KERN_INFO "%s: data overrun isrc=0x%02X "
+			      "status=0x%02X\n",
+			      dev->name, isrc, status);
+			iDBG(KERN_INFO "%s: DOI #%d#\n", dev->name, n);
+			priv->can_stats.data_overrun++;
+			hw_writereg(base, REG_CMR, CMD_CDO); /* clear bit */
+		}
+		if (isrc & IRQ_EI) {
+			/* error warning interrupt */
+			iiDBG(KERN_INFO "%s: error warning isrc=0x%02X "
+			      "status=0x%02X\n",
+			      dev->name, isrc, status);
+			iDBG(KERN_INFO "%s: EI #%d#\n", dev->name, n);
+			priv->can_stats.error_warning++;
+			if (status & SR_BS) {
+				printk(KERN_INFO "%s: BUS OFF, "
+				       "restarting device\n", dev->name);
+				can_restart_on(dev);
+				/* controller has been restarted: leave here */
+				return IRQ_HANDLED;
+			} else if (status & SR_ES) {
+				iDBG(KERN_INFO "%s: error\n", dev->name);
+			}
+		}
+		if (isrc & IRQ_BEI) {
+			/* bus error interrupt */
+			iiDBG(KERN_INFO "%s: bus error isrc=0x%02X "
+			      "status=0x%02X\n",
+			      dev->name, isrc, status);
+			iDBG(KERN_INFO "%s: BEI #%d# [%d]\n", dev->name, n,
+			     priv->can_stats.bus_error - 
+			     priv->can_stats.bus_error_at_init);
+			priv->can_stats.bus_error++;
+			ecc = hw_readreg(base, REG_ECC);
+			iDBG(KERN_INFO "%s: ECC = 0x%02X (%s, %s, %s)\n",
+			     dev->name, ecc,
+			     (ecc & ECC_DIR) ? "RX" : "TX",
+			     ecc_types[ecc >> ECC_ERR],
+			     ecc_errors[ecc & ECC_SEG]);
+
+			/* when the bus errors flood the system, */
+			/* restart the controller                */
+			if (priv->can_stats.bus_error_at_init +
+			    MAX_BUS_ERRORS < priv->can_stats.bus_error) {
+				iDBG(KERN_INFO "%s: heavy bus errors,"
+				     " restarting device\n", dev->name);
+				can_restart_on(dev);
+				/* controller has been restarted: leave here */
+				return IRQ_HANDLED;
+			}
+#if 1
+			/* don't know, if this is a good idea, */
+			/* but it works fine ...               */
+			if (hw_readreg(base, REG_RXERR) > 128) {
+				iDBG(KERN_INFO "%s: RX_ERR > 128,"
+				     " restarting device\n", dev->name);
+				can_restart_on(dev);
+				/* controller has been restarted: leave here */
+				return IRQ_HANDLED;
+			}
+#endif
+		}
+		if (isrc & IRQ_EPI) {
+			/* error passive interrupt */
+			iiDBG(KERN_INFO "%s: error passive isrc=0x%02X"
+			      " status=0x%02X\n",
+			      dev->name, isrc, status);
+			iDBG(KERN_INFO "%s: EPI #%d#\n", dev->name, n);
+			priv->can_stats.error_passive++;
+			if (status & SR_ES) {
+				iDBG(KERN_INFO "%s: -> ERROR PASSIVE, "
+				     "restarting device\n", dev->name);
+				can_restart_on(dev);
+				/* controller has been restarted: leave here */
+				return IRQ_HANDLED;
+			} else {
+				iDBG(KERN_INFO "%s: -> ERROR ACTIVE\n",
+				     dev->name);
+			}
+		}
+		if (isrc & IRQ_ALI) {
+			/* arbitration lost interrupt */
+			iiDBG(KERN_INFO "%s: error arbitration lost "
+			      "isrc=0x%02X status=0x%02X\n",
+			      dev->name, isrc, status);
+			iDBG(KERN_INFO "%s: ALI #%d#\n", dev->name, n);
+			priv->can_stats.arbitration_lost++;
+			alc = hw_readreg(base, REG_ALC);
+			iDBG(KERN_INFO "%s: ALC = 0x%02X\n", dev->name, alc);
+		}
+	}
+	if (n > 1) {
+		iDBG(KERN_INFO "%s: handled %d IRQs\n", dev->name, n);
+	}
+
+	hw_postirq(dev);
+
+	return n == 0 ? IRQ_NONE : IRQ_HANDLED;
+}
+
+/*
+ * initialize CAN bus driver
+ */
+static int can_open(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	priv->state = STATE_UNINITIALIZED;
+
+	/* register interrupt handler */
+	if (request_irq(dev->irq, &can_interrupt, IRQF_SHARED,
+			dev->name, (void*)dev)) {
+		return -EAGAIN;
+	}
+
+	/* clear statistics */
+	memset(&priv->stats, 0, sizeof(priv->stats));
+
+	/* init chip */
+	chipset_init(dev, 0);
+	priv->open_time = jiffies;
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+/*
+ * stop CAN bus activity
+ */
+static int can_close(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* set chip into reset mode */
+	set_reset_mode(dev);
+
+	priv->open_time = 0;
+
+	if (priv->timer.expires) {
+		del_timer(&priv->timer);
+		priv->timer.expires = 0;
+	}
+
+	free_irq(dev->irq, (void*)dev);
+	priv->state = STATE_UNINITIALIZED;
+
+	netif_stop_queue(dev);
+
+	return 0;
+}
+
+#if 0
+static void test_if(struct net_device *dev)
+{
+	int i;
+	int j;
+	int x;
+
+	hw_writereg(base, REG_CDR, 0xCF);
+	for (i = 0; i < 10000; i++) {
+		for (j = 0; j < 256; j++) {
+			hw_writereg(base, REG_EWL, j);
+			x = hw_readreg(base, REG_EWL);
+			if (x != j) {
+				printk(KERN_INFO "%s: is: %02X expected: "
+				       "%02X (%d)\n", dev->name, x, j, i);
+			}
+		}
+	}
+}
+#endif
+
+void can_netdev_setup(struct net_device *dev)
+{
+	/* Fill in the the fields of the device structure
+	   with CAN netdev generic values */
+
+	dev->change_mtu			= NULL;
+	dev->hard_header		= NULL;
+	dev->rebuild_header		= NULL;
+	dev->set_mac_address		= NULL;
+	dev->hard_header_cache		= NULL;
+	dev->header_cache_update	= NULL;
+	dev->hard_header_parse		= NULL;
+
+	dev->type			= ARPHRD_CAN;
+	dev->hard_header_len		= 0;
+	dev->mtu			= sizeof(struct can_frame);
+	dev->addr_len			= 0;
+	dev->tx_queue_len		= 10;
+
+	dev->flags			= IFF_NOARP;
+
+	/* set flags according to driver capabilities */
+	if (loopback)
+		dev->flags |= IFF_LOOPBACK;
+
+	dev->features			= NETIF_F_NO_CSUM;
+
+	dev->open			= can_open;
+	dev->stop			= can_close;
+	dev->hard_start_xmit		= can_start_xmit;
+	dev->get_stats			= can_get_stats;
+	dev->do_ioctl           	= can_ioctl;
+
+	dev->tx_timeout			= can_tx_timeout;
+	dev->watchdog_timeo		= TX_TIMEOUT;
+
+	SET_MODULE_OWNER(dev);
+}
+
+static struct net_device* can_create_netdev(int dev_num, int hw_regs)
+{
+	struct net_device	*dev;
+	struct can_priv		*priv;
+
+	if (!(dev = alloc_netdev(sizeof(struct can_priv), CAN_NETDEV_NAME,
+				 can_netdev_setup))) {
+		printk(KERN_ERR "%s: out of memory\n", CHIP_NAME);
+		return NULL;
+	}
+
+	printk(KERN_INFO "%s: base 0x%lX / irq %d / speed %d / "
+	       "btr 0x%X / rx_probe %d\n",
+	       drv_name, rbase[dev_num], irq[dev_num],
+	       speed[dev_num], btr[dev_num], rx_probe[dev_num]);
+
+	/* fill net_device structure */
+
+	priv             = netdev_priv(dev);
+
+	dev->irq         = irq[dev_num];
+	dev->base_addr   = rbase[dev_num];
+
+	priv->speed      = speed[dev_num];
+	priv->btr        = btr[dev_num];
+	priv->rx_probe   = rx_probe[dev_num];
+	priv->clock      = clk;
+	priv->hw_regs    = hw_regs;
+	priv->restart_ms = restart_ms;
+	priv->debug      = debug;
+
+	init_timer(&priv->timer);
+	priv->timer.expires = 0;
+
+	if (register_netdev(dev)) {
+		printk(KERN_INFO "%s: register netdev failed\n", CHIP_NAME);
+		free_netdev(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+
+int can_set_drv_name(void)
+{
+	char *hname = hal_name();
+
+	if (strlen(CHIP_NAME) + strlen(hname) >= DRV_NAME_LEN-1) {
+		printk(KERN_ERR "%s: driver name too long!\n", CHIP_NAME);
+		return -EINVAL;
+	}
+	sprintf(drv_name, "%s-%s", CHIP_NAME, hname);
+	return 0;
+}
+
+static __exit void sja1000_exit_module(void)
+{
+	int i, ret;
+
+	for (i = 0; i < MAXDEV; i++) {
+		if (can_dev[i] != NULL) {
+			struct can_priv *priv = netdev_priv(can_dev[i]);
+			unregister_netdev(can_dev[i]);
+			del_timer(&priv->timer);
+			hw_detach(i);
+			hal_release_region(i, SJA1000_IO_SIZE_BASIC);
+			free_netdev(can_dev[i]);
+		}
+	}
+	can_proc_remove(drv_name);
+
+	if ((ret = hal_exit()))
+		printk(KERN_INFO "%s: hal_exit error %d.\n", drv_name, ret);
+}
+
+static __init int sja1000_init_module(void)
+{
+	int i, ret;
+	struct net_device *dev;
+
+	if ((ret = hal_init()))
+		return ret;
+
+	if ((ret = can_set_drv_name()))
+		return ret;
+
+	if (clk < 1000 ) /* MHz command line value */
+		clk *= 1000000;
+
+	if (clk < 1000000 ) /* kHz command line value */
+		clk *= 1000;
+
+	printk(KERN_INFO "%s driver v%s (%s)\n",
+	       drv_name, drv_version, drv_reldate);
+	printk(KERN_INFO "%s - options [clk %d.%06d MHz] [restart_ms %dms]"
+	       " [debug %d]\n",
+	       drv_name, clk/1000000, clk%1000000, restart_ms, debug);
+
+	if (!base[0]) {
+		printk(KERN_INFO "%s: loading defaults.\n", drv_name);
+		hal_use_defaults();
+	}
+		
+	for (i = 0; base[i]; i++) {
+		printk(KERN_DEBUG "%s: checking for %s on address 0x%lX ...\n",
+		       drv_name, CHIP_NAME, base[i]);
+
+		if (!hal_request_region(i, SJA1000_IO_SIZE_BASIC, drv_name)) {
+			printk(KERN_ERR "%s: memory already in use\n",
+			       drv_name);
+			sja1000_exit_module();
+			return -EBUSY;
+		}
+
+		hw_attach(i);
+		hw_reset_dev(i);
+
+		if (!sja1000_probe_chip(rbase[i])) {
+			printk(KERN_ERR "%s: probably missing controller"
+			       " hardware\n", drv_name);
+			hw_detach(i);
+			hal_release_region(i, SJA1000_IO_SIZE_BASIC);
+			sja1000_exit_module();
+			return -ENODEV;
+		}
+
+		dev = can_create_netdev(i, SJA1000_IO_SIZE_BASIC);
+
+		if (dev != NULL) {
+			can_dev[i] = dev;
+			set_reset_mode(dev);
+			can_proc_create(drv_name);
+		} else {
+			can_dev[i] = NULL;
+			hw_detach(i);
+			hal_release_region(i, SJA1000_IO_SIZE_BASIC);
+		}
+	}
+	return 0;
+}
+
+module_init(sja1000_init_module);
+module_exit(sja1000_exit_module);
+
Index: drivers/net/can/sja1000/sja1000.h
===================================================================
--- /dev/null
+++ drivers/net/can/sja1000/sja1000.h
@@ -0,0 +1,189 @@
+/*
+ * sja1000.h -  Philips SJA1000 network device driver
+ *
+ * Copyright (c) 2003 Matthias Brukner, Trajet Gmbh, Rebenring 33,
+ * 38106 Braunschweig, GERMANY
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef SJA1000_H
+#define SJA1000_H
+
+#define SJA1000_IO_SIZE_BASIC   0x20
+#define SJA1000_IO_SIZE_PELICAN 0x80 /* unused */
+
+#define CHIP_NAME	"sja1000"
+
+#define DRV_NAME_LEN	30 /* for "<chip_name>-<hal_name>" */
+
+#define PROCBASE          "driver" /* /proc/ ... */
+
+#define DEFAULT_HW_CLK	16000000
+#define DEFAULT_SPEED	500 /* kBit/s */
+
+#define CAN_NETDEV_NAME	"can%d"
+
+#define TX_TIMEOUT      (50*HZ/1000) /* 50ms */ 
+#define RESTART_MS      100  /* restart chip on persistent errors in 100ms */
+#define MAX_BUS_ERRORS  200  /* prevent from flooding bus error interrupts */
+
+/* SJA1000 registers - manual section 6.4 (Pelican Mode) */
+#define REG_MOD		0x00
+#define REG_CMR		0x01
+#define REG_SR		0x02
+#define REG_IR		0x03
+#define REG_IER		0x04
+#define REG_ALC		0x0B
+#define REG_ECC		0x0C
+#define REG_EWL		0x0D
+#define REG_RXERR	0x0E
+#define REG_TXERR	0x0F
+#define REG_ACCC0	0x10
+#define REG_ACCC1	0x11
+#define REG_ACCC2	0x12
+#define REG_ACCC3	0x13
+#define REG_ACCM0	0x14
+#define REG_ACCM1	0x15
+#define REG_ACCM2	0x16
+#define REG_ACCM3	0x17
+#define REG_RMC		0x1D
+#define REG_RBSA	0x1E
+
+/* Common registers - manual section 6.5 */
+#define REG_BTR0	0x06
+#define REG_BTR1	0x07
+#define REG_OCR		0x08
+#define REG_CDR		0x1F
+
+#define REG_FI		0x10
+#define SFF_BUF		0x13
+#define EFF_BUF		0x15
+
+#define FI_FF		0x80
+#define FI_RTR		0x40
+
+#define REG_ID1		0x11
+#define REG_ID2		0x12
+#define REG_ID3		0x13
+#define REG_ID4		0x14
+
+#define CAN_RAM		0x20
+
+/* mode register */
+#define MOD_RM		0x01
+#define MOD_LOM		0x02
+#define MOD_STM		0x04
+#define MOD_AFM		0x08
+#define MOD_SM		0x10
+
+/* commands */
+#define CMD_SRR		0x10
+#define CMD_CDO		0x08
+#define CMD_RRB		0x04
+#define CMD_AT		0x02
+#define CMD_TR		0x01
+
+/* interrupt sources */
+#define IRQ_BEI		0x80
+#define IRQ_ALI		0x40
+#define IRQ_EPI		0x20
+#define IRQ_WUI		0x10
+#define IRQ_DOI		0x08
+#define IRQ_EI		0x04
+#define IRQ_TI		0x02
+#define IRQ_RI		0x01
+#define IRQ_ALL		0xFF
+#define IRQ_OFF		0x00
+
+/* status register content */
+#define SR_BS		0x80
+#define SR_ES		0x40
+#define SR_TS		0x20
+#define SR_RS		0x10
+#define SR_TCS		0x08
+#define SR_TBS		0x04
+#define SR_DOS		0x02
+#define SR_RBS		0x01
+
+#define SR_CRIT (SR_BS|SR_ES)
+
+/* ECC register */
+#define ECC_DIR		0x20
+#define ECC_SEG		0x1F
+#define ECC_ERR		6
+
+/* bus timing */
+#define MAX_TSEG1	15
+#define MAX_TSEG2	 7
+#define SAMPLE_POINT	75
+#define JUMPWIDTH     0x40
+
+/* CAN private data structure */
+
+struct can_priv {
+	struct net_device_stats	stats;
+	struct can_device_stats	can_stats;
+	long			open_time;
+	int			clock;
+	int			hw_regs;
+	int			restart_ms;
+	int			debug;
+	int			speed;
+	int			btr;
+	int			rx_probe;
+	struct timer_list       timer;
+	int			state;
+	struct sk_buff		*loop_skb;
+};
+
+#define STATE_UNINITIALIZED	0
+#define STATE_PROBE		1
+#define STATE_ACTIVE		2
+#define STATE_ERROR_ACTIVE	3
+#define STATE_ERROR_PASSIVE	4
+#define STATE_BUS_OFF		5
+#define STATE_RESET_MODE	6
+
+void can_proc_create(const char *drv_name);
+void can_proc_remove(const char *drv_name);
+
+#endif /* SJA1000_H */
Index: drivers/net/can/slcan.c
===================================================================
--- /dev/null
+++ drivers/net/can/slcan.c
@@ -0,0 +1,908 @@
+/*
+ * slcan.c - serial line CAN interface driver (using tty line discipline)
+ *
+ * Copyright (c) 2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+/*
+ * This file is derived from linux/drivers/net/slip.c
+ *
+ * Therefore it has the same (strange?) behaviour not to unregister the
+ * netdevice when detaching the tty. Is there any better solution?
+ *
+ * Do not try to attach, detach and re-attach a tty for this reason ...
+ *
+ * slip.c Authors: Laurence Culhane, <loz@holmes.demon.co.uk>
+ *                 Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <linux/bitops.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/tty.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/rtnetlink.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/if_slip.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+
+#include <linux/can.h>
+
+static __initdata const char banner[] =
+	KERN_INFO "slcan: serial line CAN interface driver\n";
+
+MODULE_ALIAS_LDISC(N_SLCAN);
+MODULE_DESCRIPTION("serial line CAN interface");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Oliver Hartkopp <oliver.hartkopp@volkswagen.de>");
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+static int debug = 0;
+module_param(debug, int, S_IRUGO);
+#define DBG(args...)       (debug & 1 ? \
+			       (printk(KERN_DEBUG "slcan %s: ", __func__), \
+				printk(args)) : 0)
+#else
+#define DBG(args...)
+#endif
+
+#ifndef N_SLCAN
+#error Your kernel does not support tty line discipline N_SLCAN
+#endif
+/*
+ * As there is currently no line discipline N_SLCAN in the mainstream kernel
+ * you will have to modify two kernel includes & recompile the kernel.
+ *
+ * Add this in include/asm/termios.h after the definition of N_HCI:
+ *        #define N_SLCAN         16 
+ *
+ * Increment NR_LDICS in include/linux/tty.h from 16 to 17
+ *
+ * NEW: Since Kernel 2.6.21 you only have to change include/linux/tty.h
+ *
+ */
+
+#define SLC_CHECK_TRANSMIT
+#define SLCAN_MAGIC 0x53CA
+
+static int maxdev = 10;		/* MAX number of SLCAN channels;
+				   This can be overridden with
+				   insmod slcan.ko maxdev=nnn	*/
+module_param(maxdev, int, 0);
+MODULE_PARM_DESC(maxdev, "Maximum number of slcan interfaces");
+
+/* maximum rx buffer len: extended CAN frame with timestamp */
+#define SLC_MTU (sizeof("T1111222281122334455667788EA5F\r")+1)
+
+struct slcan {
+	int			magic;
+
+	/* Various fields. */
+	struct tty_struct	*tty;		/* ptr to TTY structure	     */
+	struct net_device	*dev;		/* easy for intr handling    */
+	spinlock_t		lock;
+
+	/* These are pointers to the malloc()ed frame buffers. */
+	unsigned char		rbuff[SLC_MTU];	/* receiver buffer	     */
+	int			rcount;         /* received chars counter    */
+	unsigned char		xbuff[SLC_MTU];	/* transmitter buffer	     */
+	unsigned char		*xhead;         /* pointer to next XMIT byte */
+	int			xleft;          /* bytes left in XMIT queue  */
+
+	/* SLCAN interface statistics. */
+	struct net_device_stats stats;
+
+	unsigned long		flags;		/* Flag values/ mode etc     */
+#define SLF_INUSE		0		/* Channel in use            */
+#define SLF_ERROR		1               /* Parity, etc. error        */
+
+	unsigned char		leased;
+	dev_t			line;
+	pid_t			pid;
+};
+
+static struct net_device **slcan_devs;
+
+ /************************************************************************
+  *			SLCAN ENCAPSULATION FORMAT		  	 *
+  ************************************************************************/
+
+/*
+ * A CAN frame has a can_id (11 bit standard frame format OR 29 bit extended
+ * frame format) a data length code (can_dlc) which can be from 0 to 8
+ * and up to <can_dlc> data bytes as payload.
+ * Additionally a CAN frame may become a remote transmission frame if the
+ * RTR-bit is set. This causes another ECU to send a CAN frame with the
+ * given can_id.
+ *
+ * The SLCAN ASCII representation of these different frame types is:
+ * <type> <id> <dlc> <data>*
+ *
+ * Extended frames (29 bit) are defined by capital characters in the type.
+ * RTR frames are defined as 'r' types - normal frames have 't' type:
+ * t => 11 bit data frame
+ * r => 11 bit RTR frame
+ * T => 29 bit data frame
+ * R => 29 bit RTR frame
+ *
+ * The <id> is 3 (standard) or 8 (extended) bytes in ASCII Hex (base64).
+ * The <dlc> is a one byte ASCII number ('0' - '8')
+ * The <data> section has at much ASCII Hex bytes as defined by the <dlc>
+ * 
+ * Examples:
+ *
+ * t1230 : can_id 0x123, can_dlc 0, no data
+ * t4563112233 : can_id 0x456, can_dlc 3, data 0x11 0x22 0x33
+ * T12ABCDEF2AA55 : extended can_id 0x12ABCDEF, can_dlc 2, data 0xAA 0x55
+ * r1230 : can_id 0x123, can_dlc 0, no data, remote transmission request
+ *
+ */
+
+ /************************************************************************
+  *			STANDARD SLCAN DECAPSULATION		  	 *
+  ************************************************************************/
+
+static int asc2nibble(char c) {
+
+	if ((c >= '0') && (c <= '9'))
+		return c - '0';
+
+	if ((c >= 'A') && (c <= 'F'))
+		return c - 'A' + 10;
+
+	if ((c >= 'a') && (c <= 'f'))
+		return c - 'a' + 10;
+
+	return 16; /* error */
+}
+
+/* Send one completely decapsulated can_frame to the network layer */
+static void slc_bump(struct slcan *sl)
+{
+	struct sk_buff *skb;
+	struct can_frame cf;
+	int i, dlc_pos, tmp;
+	char cmd = sl->rbuff[0];
+
+	if ((cmd != 't') && (cmd != 'T') && (cmd != 'r') && (cmd != 'R'))
+		return;
+
+	if (cmd & 0x20) /* tiny chars 'r' 't' => standard frame format */
+		dlc_pos = 4; /* dlc position tiiid */
+	else
+		dlc_pos = 9; /* dlc position Tiiiiiiiid */
+
+	if (!((sl->rbuff[dlc_pos] >= '0') && (sl->rbuff[dlc_pos] < '9')))
+		return;
+
+	cf.can_dlc = sl->rbuff[dlc_pos] & 0x0F; /* get can_dlc */
+
+	sl->rbuff[dlc_pos] = 0; /* terminate can_id string */
+	cf.can_id = simple_strtoul(sl->rbuff+1, NULL, 16);
+	
+	if (!(cmd & 0x20)) /* NO tiny chars => extended frame format */
+		cf.can_id |= CAN_EFF_FLAG;
+
+	if ((cmd | 0x20) == 'r') /* RTR frame */
+		cf.can_id |= CAN_RTR_FLAG;
+
+	*(u64 *) (&cf.data) = 0; /* clear payload */
+
+	for (i = 0, dlc_pos++; i < cf.can_dlc; i++){
+		
+		if ((tmp = asc2nibble(sl->rbuff[dlc_pos++])) > 0x0F)
+			return;
+		cf.data[i] = (tmp << 4);
+		if ((tmp = asc2nibble(sl->rbuff[dlc_pos++])) > 0x0F)
+			return;
+		cf.data[i] |= tmp;
+	}
+
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (!skb)
+		return;
+
+	skb->dev = sl->dev;
+	skb->protocol = htons(ETH_P_CAN);
+	skb->pkt_type = PACKET_BROADCAST;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	memcpy(skb_put(skb, sizeof(struct can_frame)),
+	       &cf, sizeof(struct can_frame));
+	netif_rx(skb);
+
+	sl->dev->last_rx = jiffies;
+	sl->stats.rx_packets++;
+	sl->stats.rx_bytes += cf.can_dlc;
+}
+
+/* parse tty input stream */
+static void slcan_unesc(struct slcan *sl, unsigned char s)
+{
+	if ((s == '\r') || (s == '\a')) { /* CR or BEL ends the pdu */
+		if (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&
+		    (sl->rcount > 4))  {
+			slc_bump(sl);
+		}
+		sl->rcount = 0;
+	} else {
+		if (!test_bit(SLF_ERROR, &sl->flags))  {
+			if (sl->rcount < SLC_MTU)  {
+				sl->rbuff[sl->rcount++] = s;
+				return;
+			} else {
+				sl->stats.rx_over_errors++;
+				set_bit(SLF_ERROR, &sl->flags);
+			}
+		}
+	}
+}
+
+ /************************************************************************
+  *			STANDARD SLCAN ENCAPSULATION		  	 *
+  ************************************************************************/
+
+/* Encapsulate one can_frame and stuff into a TTY queue. */
+static void slc_encaps(struct slcan *sl, struct can_frame *cf)
+{
+	int actual, idx, i;
+	char cmd;
+
+	if (cf->can_id & CAN_RTR_FLAG)
+		cmd = 'R'; /* becomes 'r' in standard frame format */
+	else
+		cmd = 'T'; /* becomes 't' in standard frame format */
+
+	if (cf->can_id & CAN_EFF_FLAG)
+		sprintf(sl->xbuff, "%c%08X%d", cmd,
+			cf->can_id & CAN_EFF_MASK, cf->can_dlc);
+	else
+		sprintf(sl->xbuff, "%c%03X%d", cmd | 0x20,
+			cf->can_id & CAN_SFF_MASK, cf->can_dlc);
+
+	idx = strlen(sl->xbuff);
+
+	for (i = 0; i < cf->can_dlc; i++)
+		sprintf(&sl->xbuff[idx + 2*i], "%02X", cf->data[i]);
+
+	DBG("ASCII frame = '%s'\n", sl->xbuff);
+
+	strcat(sl->xbuff, "\r"); /* add terminating character */
+
+	/* Order of next two lines is *very* important.
+	 * When we are sending a little amount of data,
+	 * the transfer may be completed inside driver.write()
+	 * routine, because it's running with interrupts enabled.
+	 * In this case we *never* got WRITE_WAKEUP event,
+	 * if we did not request it before write operation.
+	 *       14 Oct 1994  Dmitry Gorodchanin.
+	 */
+	sl->tty->flags |= (1 << TTY_DO_WRITE_WAKEUP);
+	actual = sl->tty->driver->write(sl->tty, sl->xbuff, strlen(sl->xbuff));
+#ifdef SLC_CHECK_TRANSMIT
+	sl->dev->trans_start = jiffies;
+#endif
+	sl->xleft = strlen(sl->xbuff) - actual;
+	sl->xhead = sl->xbuff + actual;
+	sl->stats.tx_bytes += cf->can_dlc;
+}
+
+/*
+ * Called by the driver when there's room for more data.  If we have
+ * more packets to send, we send them here.
+ */
+static void slcan_write_wakeup(struct tty_struct *tty)
+{
+	int actual;
+	struct slcan *sl = (struct slcan *) tty->disc_data;
+
+	/* First make sure we're connected. */
+	if (!sl || sl->magic != SLCAN_MAGIC || !netif_running(sl->dev)) {
+		return;
+	}
+	if (sl->xleft <= 0)  {
+		/* Now serial buffer is almost free & we can start
+		 * transmission of another packet */
+		sl->stats.tx_packets++;
+		tty->flags &= ~(1 << TTY_DO_WRITE_WAKEUP);
+		netif_wake_queue(sl->dev);
+		return;
+	}
+
+	actual = tty->driver->write(tty, sl->xhead, sl->xleft);
+	sl->xleft -= actual;
+	sl->xhead += actual;
+}
+
+static void slc_tx_timeout(struct net_device *dev)
+{
+	struct slcan *sl = netdev_priv(dev);
+
+	spin_lock(&sl->lock);
+
+	if (netif_queue_stopped(dev)) {
+		if (!netif_running(dev))
+			goto out;
+
+		/* May be we must check transmitter timeout here ?
+		 *      14 Oct 1994 Dmitry Gorodchanin.
+		 */
+#ifdef SLC_CHECK_TRANSMIT
+		if (time_before(jiffies, dev->trans_start + 20 * HZ))  {
+			/* 20 sec timeout not reached */
+			goto out;
+		}
+		printk(KERN_WARNING "%s: transmit timed out, %s?\n", dev->name,
+		       (sl->tty->driver->chars_in_buffer(sl->tty) || sl->xleft)
+		       ? "bad line quality" : "driver error");
+		sl->xleft = 0;
+		sl->tty->flags &= ~(1 << TTY_DO_WRITE_WAKEUP);
+		netif_wake_queue(sl->dev);
+#endif
+	}
+out:
+	spin_unlock(&sl->lock);
+}
+
+
+/******************************************
+ *   Routines looking at netdevice side.
+ ******************************************/
+
+/* Send a can_frame to a TTY queue. */
+static int slc_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct slcan *sl = netdev_priv(dev);
+
+	if (skb->len != sizeof(struct can_frame))
+		goto out;
+
+	spin_lock(&sl->lock);
+	if (!netif_running(dev))  {
+		spin_unlock(&sl->lock);
+		printk(KERN_WARNING "%s: xmit: iface is down\n", dev->name);
+		goto out;
+	}
+
+	if (sl->tty == NULL) {
+		spin_unlock(&sl->lock);
+		goto out;
+	}
+
+	netif_stop_queue(sl->dev);
+	slc_encaps(sl, (struct can_frame *) skb->data); /* encaps & send */
+	spin_unlock(&sl->lock);
+
+out:
+	kfree_skb(skb);
+	return 0;
+}
+
+
+/* Netdevice UP -> DOWN routine */
+static int slc_close(struct net_device *dev)
+{
+	struct slcan *sl = netdev_priv(dev);
+
+	spin_lock_bh(&sl->lock);
+	if (sl->tty) {
+		/* TTY discipline is running. */
+		sl->tty->flags &= ~(1 << TTY_DO_WRITE_WAKEUP);
+	}
+	netif_stop_queue(dev);
+	sl->rcount   = 0;
+	sl->xleft    = 0;
+	spin_unlock_bh(&sl->lock);
+
+	return 0;
+}
+
+/* Netdevice DOWN -> UP routine */
+static int slc_open(struct net_device *dev)
+{
+	struct slcan *sl = netdev_priv(dev);
+
+	if (sl->tty==NULL)
+		return -ENODEV;
+
+	sl->flags &= (1 << SLF_INUSE);
+	netif_start_queue(dev);
+	return 0;
+}
+
+/* Netdevice get statistics request */
+static struct net_device_stats *slc_get_stats(struct net_device *dev)
+{
+	struct slcan *sl = netdev_priv(dev);
+
+	return (&sl->stats);
+}
+
+/* Netdevice register callback */
+static void slc_setup(struct net_device *dev)
+{
+	dev->open		= slc_open;
+	dev->destructor		= free_netdev;
+	dev->stop		= slc_close;
+	dev->get_stats	        = slc_get_stats;
+	dev->hard_start_xmit	= slc_xmit;
+
+	dev->hard_header_len	= 0;
+	dev->addr_len		= 0;
+	dev->tx_queue_len	= 10;
+
+	SET_MODULE_OWNER(dev);
+
+	dev->mtu		= sizeof(struct can_frame);
+	dev->type		= ARPHRD_CAN;
+#ifdef SLC_CHECK_TRANSMIT
+	dev->tx_timeout		= slc_tx_timeout;
+	dev->watchdog_timeo	= 20*HZ;
+#endif
+
+	/* New-style flags. */
+	dev->flags		= IFF_NOARP;
+	dev->features           = NETIF_F_NO_CSUM;
+}
+
+/******************************************
+ * Routines looking at TTY side.
+ ******************************************/
+
+/*
+ * Handle the 'receiver data ready' interrupt.
+ * This function is called by the 'tty_io' module in the kernel when
+ * a block of SLCAN data has been received, which can now be decapsulated
+ * and sent on to some IP layer for further processing. This will not
+ * be re-entered while running but other ldisc functions may be called
+ * in parallel
+ */
+
+static void slcan_receive_buf(struct tty_struct *tty,
+			      const unsigned char *cp, char *fp, int count)
+{
+	struct slcan *sl = (struct slcan *) tty->disc_data;
+
+	if (!sl || sl->magic != SLCAN_MAGIC ||
+	    !netif_running(sl->dev))
+		return;
+
+	/* Read the characters out of the buffer */
+	while (count--) {
+		if (fp && *fp++) {
+			if (!test_and_set_bit(SLF_ERROR, &sl->flags))  {
+				sl->stats.rx_errors++;
+			}
+			cp++;
+			continue;
+		}
+		slcan_unesc(sl, *cp++);
+	}
+}
+
+/************************************
+ *  slcan_open helper routines.
+ ************************************/
+
+/* Collect hanged up channels */
+
+static void slc_sync(void)
+{
+	int i;
+	struct net_device *dev;
+	struct slcan	  *sl;
+
+	for (i = 0; i < maxdev; i++) {
+		if ((dev = slcan_devs[i]) == NULL)
+			break;
+
+		sl = netdev_priv(dev);
+		if (sl->tty || sl->leased)
+			continue;
+		if (dev->flags&IFF_UP)
+			dev_close(dev);
+	}
+}
+
+
+/* Find a free SLCAN channel, and link in this `tty' line. */
+static struct slcan *slc_alloc(dev_t line)
+{
+	int i;
+	int sel = -1;
+	int score = -1;
+	struct net_device *dev = NULL;
+	struct slcan       *sl;
+
+	if (slcan_devs == NULL)
+		return NULL;	/* Master array missing ! */
+
+	for (i = 0; i < maxdev; i++) {
+		dev = slcan_devs[i];
+		if (dev == NULL)
+			break;
+
+		sl = netdev_priv(dev);
+		if (sl->leased) {
+			if (sl->line != line)
+				continue;
+			if (sl->tty)
+				return NULL;
+
+			/* Clear ESCAPE & ERROR flags */
+			sl->flags &= (1 << SLF_INUSE);
+			return sl;
+		}
+
+		if (sl->tty)
+			continue;
+
+		if (current->pid == sl->pid) {
+			if (sl->line == line && score < 3) {
+				sel = i;
+				score = 3;
+				continue;
+			}
+			if (score < 2) {
+				sel = i;
+				score = 2;
+			}
+			continue;
+		}
+		if (sl->line == line && score < 1) {
+			sel = i;
+			score = 1;
+			continue;
+		}
+		if (score < 0) {
+			sel = i;
+			score = 0;
+		}
+	}
+
+	if (sel >= 0) {
+		i = sel;
+		dev = slcan_devs[i];
+		if (score > 1) {
+			sl = netdev_priv(dev);
+			sl->flags &= (1 << SLF_INUSE);
+			return sl;
+		}
+	}
+
+	/* Sorry, too many, all slots in use */
+	if (i >= maxdev)
+		return NULL;
+
+	if (dev) {
+		sl = netdev_priv(dev);
+		if (test_bit(SLF_INUSE, &sl->flags)) {
+			unregister_netdevice(dev);
+			free_netdev(dev); /* new in slcan.c */
+			dev = NULL;
+			slcan_devs[i] = NULL;
+		}
+	}
+
+	if (!dev) {
+		char name[IFNAMSIZ];
+		sprintf(name, "slc%d", i);
+
+		dev = alloc_netdev(sizeof(*sl), name, slc_setup);
+		if (!dev)
+			return NULL;
+		dev->base_addr  = i;
+	}
+
+	sl = netdev_priv(dev);
+
+	/* Initialize channel control data */
+	sl->magic       = SLCAN_MAGIC;
+	sl->dev	      	= dev;
+	spin_lock_init(&sl->lock);
+	slcan_devs[i] = dev;
+
+	return sl;
+}
+
+/*
+ * Open the high-level part of the SLCAN channel.
+ * This function is called by the TTY module when the
+ * SLCAN line discipline is called for.  Because we are
+ * sure the tty line exists, we only have to link it to
+ * a free SLCAN channel...
+ *
+ * Called in process context serialized from other ldisc calls.
+ */
+
+static int slcan_open(struct tty_struct *tty)
+{
+	struct slcan *sl;
+	int err;
+
+	if(!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* RTnetlink lock is misused here to serialize concurrent
+	   opens of slcan channels. There are better ways, but it is
+	   the simplest one.
+	 */
+	rtnl_lock();
+
+	/* Collect hanged up channels. */
+	slc_sync();
+
+	sl = (struct slcan *) tty->disc_data;
+
+	err = -EEXIST;
+	/* First make sure we're not already connected. */
+	if (sl && sl->magic == SLCAN_MAGIC)
+		goto err_exit;
+
+	/* OK.  Find a free SLCAN channel to use. */
+	err = -ENFILE;
+	if ((sl = slc_alloc(tty_devnum(tty))) == NULL)
+		goto err_exit;
+
+	sl->tty = tty;
+	tty->disc_data = sl;
+	sl->line = tty_devnum(tty);
+	sl->pid = current->pid;
+
+	if (!test_bit(SLF_INUSE, &sl->flags)) {
+		/* Perform the low-level SLCAN initialization. */
+		sl->rcount   = 0;
+		sl->xleft    = 0;
+
+		set_bit(SLF_INUSE, &sl->flags);
+
+		if ((err = register_netdevice(sl->dev)))
+			goto err_free_chan;
+	}
+
+	/* Done.  We have linked the TTY line to a channel. */
+	rtnl_unlock();
+
+	tty->receive_room = 65536;	/* We don't flow control */
+
+	return sl->dev->base_addr;
+
+err_free_chan:
+	sl->tty = NULL;
+	tty->disc_data = NULL;
+	clear_bit(SLF_INUSE, &sl->flags);
+
+err_exit:
+	rtnl_unlock();
+
+	/* Count references from TTY module */
+	return err;
+}
+
+/*
+
+  FIXME: 1,2 are fixed 3 was never true anyway.
+
+   Let me to blame a bit.
+   1. TTY module calls this funstion on soft interrupt.
+   2. TTY module calls this function WITH MASKED INTERRUPTS!
+   3. TTY module does not notify us about line discipline
+      shutdown,
+
+   Seems, now it is clean. The solution is to consider netdevice and
+   line discipline sides as two independent threads.
+
+   By-product (not desired): slc? does not feel hangups and remains open.
+   It is supposed, that user level program (dip, diald, slattach...)
+   will catch SIGHUP and make the rest of work.
+
+   I see no way to make more with current tty code. --ANK
+ */
+
+/*
+ * Close down a SLCAN channel.
+ * This means flushing out any pending queues, and then returning. This
+ * call is serialized against other ldisc functions.
+ */
+static void slcan_close(struct tty_struct *tty)
+{
+	struct slcan *sl = (struct slcan *) tty->disc_data;
+
+	/* First make sure we're connected. */
+	if (!sl || sl->magic != SLCAN_MAGIC || sl->tty != tty)
+		return;
+
+	tty->disc_data = NULL;
+	sl->tty = NULL;
+	if (!sl->leased)
+		sl->line = 0;
+
+	/* Count references from TTY module */
+}
+
+/* Perform I/O control on an active SLCAN channel. */
+static int slcan_ioctl(struct tty_struct *tty, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	struct slcan *sl = (struct slcan *) tty->disc_data;
+	unsigned int tmp;
+
+	/* First make sure we're connected. */
+	if (!sl || sl->magic != SLCAN_MAGIC) {
+		return -EINVAL;
+	}
+
+	switch(cmd) {
+	case SIOCGIFNAME:
+		tmp = strlen(sl->dev->name) + 1;
+		if (copy_to_user((void __user *)arg, sl->dev->name, tmp))
+			return -EFAULT;
+		return 0;
+
+	case SIOCSIFHWADDR:
+		return -EINVAL;
+
+
+	/* Allow stty to read, but not set, the serial port */
+	case TCGETS:
+	case TCGETA:
+		return n_tty_ioctl(tty, file, cmd, arg);
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+
+static struct tty_ldisc	slc_ldisc = {
+	.owner 		= THIS_MODULE,
+	.magic 		= TTY_LDISC_MAGIC,
+	.name 		= "slcan",
+	.open 		= slcan_open,
+	.close	 	= slcan_close,
+	.ioctl		= slcan_ioctl,
+	.receive_buf	= slcan_receive_buf,
+	.write_wakeup	= slcan_write_wakeup,
+};
+
+/************************************
+ * general slcan module init/exit
+ ************************************/
+
+static int __init slcan_init(void)
+{
+	int status;
+
+	if (maxdev < 4)
+		maxdev = 4; /* Sanity */
+
+	printk(banner);
+	printk(KERN_INFO "slcan: %d dynamic interface channels.\n", maxdev );
+
+	slcan_devs = kmalloc(sizeof(struct net_device *)*maxdev, GFP_KERNEL);
+	if (!slcan_devs) {
+		printk(KERN_ERR "slcan: can't allocate slcan device array!\n");
+		return -ENOMEM;
+	}
+
+	/* Clear the pointer array, we allocate devices when we need them */
+	memset(slcan_devs, 0, sizeof(struct net_device *)*maxdev);
+
+	/* Fill in our line protocol discipline, and register it */
+	if ((status = tty_register_ldisc(N_SLCAN, &slc_ldisc)) != 0)  {
+		printk(KERN_ERR "slcan: can't register line discipline\n");
+		kfree(slcan_devs);
+	}
+	return status;
+}
+
+static void __exit slcan_exit(void)
+{
+	int i;
+	struct net_device *dev;
+	struct slcan *sl;
+	unsigned long timeout = jiffies + HZ;
+	int busy = 0;
+
+	if (slcan_devs == NULL)
+		return;
+
+	/* First of all: check for active disciplines and hangup them.
+	 */
+	do {
+		if (busy)
+			msleep_interruptible(100);
+
+		busy = 0;
+		for (i = 0; i < maxdev; i++) {
+			dev = slcan_devs[i];
+			if (!dev)
+				continue;
+			sl = netdev_priv(dev);
+			spin_lock_bh(&sl->lock);
+			if (sl->tty) {
+				busy++;
+				tty_hangup(sl->tty);
+			}
+			spin_unlock_bh(&sl->lock);
+		}
+	} while (busy && time_before(jiffies, timeout));
+
+
+	for (i = 0; i < maxdev; i++) {
+		dev = slcan_devs[i];
+		if (!dev)
+			continue;
+		slcan_devs[i] = NULL;
+
+		sl = netdev_priv(dev);
+		if (sl->tty) {
+			printk(KERN_ERR "%s: tty discipline still running\n",
+			       dev->name);
+			/* Intentionally leak the control block. */
+			dev->destructor = NULL;
+		}
+
+		unregister_netdev(dev);
+	}
+
+	kfree(slcan_devs);
+	slcan_devs = NULL;
+
+	if ((i = tty_unregister_ldisc(N_SLCAN)))
+	{
+		printk(KERN_ERR "slcan: can't unregister ldisc (err %d)\n", i);
+	}
+}
+
+module_init(slcan_init);
+module_exit(slcan_exit);
Index: drivers/net/can/vcan.c
===================================================================
--- /dev/null
+++ drivers/net/can/vcan.c
@@ -0,0 +1,261 @@
+/*
+ * vcan.c - Virtual CAN interface
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/can.h>
+#include <net/rtnetlink.h>
+
+static __initdata const char banner[] =
+	KERN_INFO "vcan: Virtual CAN interface driver\n";
+
+MODULE_DESCRIPTION("virtual CAN interface");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Urs Thuermann <urs.thuermann@volkswagen.de>");
+
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+static int debug;
+module_param(debug, int, S_IRUGO);
+#endif
+
+/* To be moved to linux/can/dev.h */
+#ifdef CONFIG_CAN_DEBUG_DEVICES
+#define DBG(args...)       (debug & 1 ? \
+			       (printk(KERN_DEBUG "vcan %s: ", __func__), \
+				printk(args)) : 0)
+#else
+#define DBG(args...)
+#endif
+
+
+/*
+ * CAN test feature:
+ * Enable the loopback on driver level for testing the CAN core loopback modes.
+ * See Documentation/networking/can.txt for details.
+ */
+
+static int loopback; /* loopback testing. Default: 0 (Off) */
+module_param(loopback, int, S_IRUGO);
+MODULE_PARM_DESC(loopback, "Loop back frames (for testing). Default: 0 (Off)");
+
+struct vcan_priv {
+	struct net_device *dev;
+	struct list_head list;
+};
+static LIST_HEAD(vcan_devs);
+
+static int vcan_open(struct net_device *dev)
+{
+	DBG("%s: interface up\n", dev->name);
+
+	netif_start_queue(dev);
+	return 0;
+}
+
+static int vcan_stop(struct net_device *dev)
+{
+	DBG("%s: interface down\n", dev->name);
+
+	netif_stop_queue(dev);
+	return 0;
+}
+
+static void vcan_rx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct net_device_stats *stats = &dev->stats;
+
+	stats->rx_packets++;
+	stats->rx_bytes += skb->len;
+
+	skb->protocol  = htons(ETH_P_CAN);
+	skb->pkt_type  = PACKET_BROADCAST;
+	skb->dev       = dev;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+	DBG("received skbuff on interface %d\n", dev->ifindex);
+
+	netif_rx(skb);
+}
+
+static int vcan_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct net_device_stats *stats = &dev->stats;
+	int loop;
+
+	DBG("sending skbuff on interface %s\n", dev->name);
+
+	stats->tx_packets++;
+	stats->tx_bytes += skb->len;
+
+	/* set flag whether this packet has to be looped back */
+	loop = skb->pkt_type == PACKET_LOOPBACK;
+
+	if (!loopback) {
+		/* no loopback handling available inside this driver */
+
+		if (loop) {
+			/*
+			 * only count the packets here, because the
+			 * CAN core already did the loopback for us
+			 */
+			stats->rx_packets++;
+			stats->rx_bytes += skb->len;
+		}
+		kfree_skb(skb);
+		return 0;
+	}
+
+	/* perform standard loopback handling for CAN network interfaces */
+
+	if (loop) {
+		struct sock *srcsk = skb->sk;
+
+		if (atomic_read(&skb->users) != 1) {
+			struct sk_buff *old_skb = skb;
+
+			skb = skb_clone(old_skb, GFP_ATOMIC);
+			DBG(KERN_INFO "%s: %s: freeing old skbuff %p, "
+			    "using new skbuff %p\n",
+			    dev->name, __FUNCTION__, old_skb, skb);
+			kfree_skb(old_skb);
+			if (!skb)
+				return 0;
+		} else
+			skb_orphan(skb);
+
+		/* receive with packet counting */
+		skb->sk = srcsk;
+		vcan_rx(skb, dev);
+	} else {
+		/* no looped packets => no counting */
+		kfree_skb(skb);
+	}
+	return 0;
+}
+
+static void vcan_setup(struct net_device *dev)
+{
+	DBG("dev %s\n", dev->name);
+
+	dev->type              = ARPHRD_CAN;
+	dev->mtu               = sizeof(struct can_frame);
+	dev->hard_header_len   = 0;
+	dev->addr_len          = 0;
+	dev->tx_queue_len      = 0;
+	dev->flags             = IFF_NOARP;
+
+	/* set flags according to driver capabilities */
+	if (loopback)
+		dev->flags |= IFF_LOOPBACK;
+
+	dev->open              = vcan_open;
+	dev->stop              = vcan_stop;
+	dev->hard_start_xmit   = vcan_tx;
+	dev->destructor        = free_netdev;
+
+	SET_MODULE_OWNER(dev);
+}
+
+static int vcan_newlink(struct net_device *dev,
+			struct nlattr *tb[], struct nlattr *data[])
+{
+	struct vcan_priv *priv = netdev_priv(dev);
+	int err;
+
+	err = register_netdevice(dev);
+	if (err < 0)
+		return err;
+
+	priv->dev = dev;
+	list_add_tail(&priv->list, &vcan_devs);
+	return 0;
+}
+
+static void vcan_dellink(struct net_device *dev)
+{
+	struct vcan_priv *priv = netdev_priv(dev);
+
+	list_del(&priv->list);
+	unregister_netdevice(dev);
+}
+
+static struct rtnl_link_ops vcan_link_ops __read_mostly = {
+       .kind           = "vcan",
+       .priv_size      = sizeof(struct vcan_priv),
+       .setup          = vcan_setup,
+       .newlink        = vcan_newlink,
+       .dellink        = vcan_dellink,
+};
+
+static __init int vcan_init_module(void)
+{
+	int err;
+
+	printk(banner);
+
+	if (loopback)
+		printk(KERN_INFO "vcan: enabled loopback on driver level.\n");
+
+	rtnl_lock();
+	err = __rtnl_link_register(&vcan_link_ops);
+	rtnl_unlock();
+	return err;
+}
+
+static __exit void vcan_cleanup_module(void)
+{
+	struct vcan_priv *priv, *n;
+
+	rtnl_lock();
+	list_for_each_entry_safe(priv, n, &vcan_devs, list)
+		vcan_dellink(priv->dev);
+	__rtnl_link_unregister(&vcan_link_ops);
+	rtnl_unlock();
+}
+
+module_init(vcan_init_module);
+module_exit(vcan_cleanup_module);
Index: include/linux/can.h
===================================================================
--- /dev/null
+++ include/linux/can.h
@@ -0,0 +1,113 @@
+/*
+ * linux/can.h
+ *
+ * Definitions for CAN networklayer (socket addr / CAN frame / CAN filter)
+ *
+ * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ *          Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_H
+#define CAN_H
+
+#include <linux/types.h>
+#include <linux/socket.h>
+
+/* controller area network (CAN) kernel definitions */
+
+/* special address description flags for the CAN_ID */
+#define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */
+#define CAN_RTR_FLAG 0x40000000U /* remote transmission request */
+#define CAN_ERR_FLAG 0x20000000U /* error frame */
+
+/* valid bits in CAN ID for frame formats */
+#define CAN_SFF_MASK 0x000007FFU /* standard frame format (SFF) */
+#define CAN_EFF_MASK 0x1FFFFFFFU /* extended frame format (EFF) */
+#define CAN_ERR_MASK 0x1FFFFFFFU /* omit EFF, RTR, ERR flags */
+
+/*
+ * Controller Area Network Identifier structure
+ *
+ * bit 0-28	: CAN identifier (11/29 bit)
+ * bit 29	: error frame flag (0 = data frame, 1 = error frame)
+ * bit 30	: remote transmission request flag (1 = rtr frame)
+ * bit 31	: frame format flag (0 = standard 11 bit, 1 = extended 29 bit)
+ */
+typedef __u32 canid_t;
+
+/*
+ * Controller Area Network Error Frame Mask structure
+ *
+ * bit 0-28	: error class mask (see include/linux/can/error.h)
+ * bit 29-31	: set to zero
+ */
+typedef __u32 can_err_mask_t;
+
+/**
+ * struct can_frame - basic CAN frame structure
+ * @can_id:  the CAN ID of the frame and CAN_*_FLAG flags, see above.
+ * @can_dlc: the data length field of the CAN frame
+ * @data:    the CAN frame payload.
+ */
+struct can_frame {
+	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
+	__u8    can_dlc; /* data length code: 0 .. 8 */
+	__u8    data[8] __attribute__((aligned(8)));
+};
+
+/* particular protocols of the protocol family PF_CAN */
+#define CAN_RAW		1 /* RAW sockets */
+#define CAN_BCM		2 /* Broadcast Manager */
+#define CAN_TP16	3 /* VAG Transport Protocol v1.6 */
+#define CAN_TP20	4 /* VAG Transport Protocol v2.0 */
+#define CAN_MCNET	5 /* Bosch MCNet */
+#define CAN_ISOTP	6 /* ISO 15765-2 Transport Protocol */
+#define CAN_BAP		7 /* VAG Bedien- und Anzeigeprotokoll */
+#define CAN_NPROTO	8
+
+#define SOL_CAN_BASE 100
+
+/**
+ * struct sockaddr_can - the sockaddr structure for CAN sockets
+ * @can_family:  address family number AF_CAN.
+ * @can_ifindex: CAN network interface index.
+ * @can_addr:    transport protocol specific address, mostly CAN IDs.
+ */
+struct sockaddr_can {
+	sa_family_t can_family;
+	int         can_ifindex;
+	union {
+		struct { canid_t rx_id, tx_id; } tp16;
+		struct { canid_t rx_id, tx_id; } tp20;
+		struct { canid_t rx_id, tx_id; } mcnet;
+		struct { canid_t rx_id, tx_id; } isotp;
+		struct { int     lcu,   type;  } bap;
+	} can_addr;
+};
+
+/**
+ * struct can_filter - CAN ID based filter in can_register().
+ * @can_id:   relevant bits of CAN ID which are not masked out.
+ * @can_mask: CAN mask (see description)
+ *
+ * Description:
+ * A filter matches, when
+ *
+ *          <received_can_id> & mask == can_id & mask
+ *
+ * The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
+ * filter for error frames (CAN_ERR_FLAG bit set in mask).
+ */
+struct can_filter {
+	canid_t can_id;
+	canid_t can_mask;
+};
+
+#define CAN_INV_FILTER 0x20000000U /* to be set in can_filter.can_id */
+
+#endif /* CAN_H */
Index: include/linux/can/bcm.h
===================================================================
--- /dev/null
+++ include/linux/can/bcm.h
@@ -0,0 +1,65 @@
+/*
+ * linux/can/bcm.h
+ *
+ * Definitions for CAN Broadcast Manager (BCM)
+ *
+ * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_BCM_H
+#define CAN_BCM_H
+
+/**
+ * struct bcm_msg_head - head of messages to/from the broadcast manager
+ * @opcode:    opcode, see enum below.
+ * @flags:     special flags, see below.
+ * @count:     number of frames to send before changing interval.
+ * @ival1:     interval for the first @count frames.
+ * @ival2:     interval for the following frames.
+ * @can_id:    CAN ID of frames to be sent or received.
+ * @nframes:   number of frames appended to the message head.
+ * @frames:    array of CAN frames.
+ */
+struct bcm_msg_head {
+	int opcode;
+	int flags;
+	int count;
+	struct timeval ival1, ival2;
+	canid_t can_id;
+	int nframes;
+	struct can_frame frames[0];
+};
+
+enum {
+	TX_SETUP = 1,	/* create (cyclic) transmission task */
+	TX_DELETE,	/* remove (cyclic) transmission task */
+	TX_READ,	/* read properties of (cyclic) transmission task */
+	TX_SEND,	/* send one CAN frame */
+	RX_SETUP,	/* create RX content filter subscription */
+	RX_DELETE,	/* remove RX content filter subscription */
+	RX_READ,	/* read properties of RX content filter subscription */
+	TX_STATUS,	/* reply to TX_READ request */
+	TX_EXPIRED,	/* notification on performed transmissions (count=0) */
+	RX_STATUS,	/* reply to RX_READ request */
+	RX_TIMEOUT,	/* cyclic message is absent */
+	RX_CHANGED	/* updated CAN frame (detected content change) */
+};
+
+#define SETTIMER            0x0001
+#define STARTTIMER          0x0002
+#define TX_COUNTEVT         0x0004
+#define TX_ANNOUNCE         0x0008
+#define TX_CP_CAN_ID        0x0010
+#define RX_FILTER_ID        0x0020
+#define RX_CHECK_DLC        0x0040
+#define RX_NO_AUTOTIMER     0x0080
+#define RX_ANNOUNCE_RESUME  0x0100
+#define TX_RESET_MULTI_IDX  0x0200
+#define RX_RTR_FRAME        0x0400
+
+#endif /* CAN_BCM_H */
Index: include/linux/can/core.h
===================================================================
--- /dev/null
+++ include/linux/can/core.h
@@ -0,0 +1,78 @@
+/*
+ * linux/can/core.h
+ *
+ * Protoypes and definitions for CAN protocol modules using the PF_CAN core
+ *
+ * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ *          Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_CORE_H
+#define CAN_CORE_H
+
+#include <linux/can.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+
+#define CAN_VERSION "20070916"
+
+/* increment this number each time you change some user-space interface */
+#define CAN_ABI_VERSION "8"
+
+#define CAN_VERSION_STRING "rev " CAN_VERSION " abi " CAN_ABI_VERSION
+
+#define DNAME(dev) ((dev) ? (dev)->name : "any")
+
+/**
+ * struct can_proto - CAN protocol structure
+ * @type:       type argument in socket() syscall, e.g. SOCK_DGRAM.
+ * @protocol:   protocol number in socket() syscall.
+ * @capability: capability needed to open the socket, or -1 for no restriction.
+ * @ops:        pointer to struct proto_ops for sock->ops.
+ * @prot:       pointer to struct proto structure.
+ */
+struct can_proto {
+	int              type;
+	int              protocol;
+	int              capability;
+	struct proto_ops *ops;
+	struct proto     *prot;
+};
+
+/* function prototypes for the CAN networklayer core (af_can.c) */
+
+extern int can_proto_register(struct can_proto *cp);
+extern int can_proto_unregister(struct can_proto *cp);
+
+extern int can_rx_register(struct net_device *dev, canid_t can_id,
+			   canid_t mask,
+			   void (*func)(struct sk_buff *, void *),
+			   void *data, char *ident);
+
+extern int can_rx_unregister(struct net_device *dev, canid_t can_id,
+			     canid_t mask,
+			     void (*func)(struct sk_buff *, void *),
+			     void *data);
+
+extern int can_send(struct sk_buff *skb, int loop);
+
+#ifdef CONFIG_CAN_DEBUG_CORE
+extern void can_debug_skb(struct sk_buff *skb);
+extern void can_debug_cframe(const char *msg, struct can_frame *cframe, ...);
+#define DBG(args...)       (debug & 1 ? \
+			       (printk(KERN_DEBUG "can-%s %s: ", \
+				IDENT, __func__), printk(args)) : 0)
+#define DBG_FRAME(args...) (debug & 2 ? can_debug_cframe(args) : 0)
+#define DBG_SKB(skb)       (debug & 4 ? can_debug_skb(skb) : 0)
+#else
+#define DBG(args...)
+#define DBG_FRAME(args...)
+#define DBG_SKB(skb)
+#endif
+
+#endif /* CAN_CORE_H */
Index: include/linux/can/dev.h
===================================================================
--- /dev/null
+++ include/linux/can/dev.h
@@ -0,0 +1,59 @@
+/*
+ * linux/can/dev.h
+ *
+ * Definitions for CAN controller network devices lib (work in progress)
+ *
+ * Author: Andrey Volkov <avolkov@varma-el.com>
+ * Copyright (c) 2006 Varma Electronics Oy
+ *
+ */
+
+#ifndef CAN_DEVICE_H
+#define CAN_DEVICE_H
+
+#include <linux/can/error.h>
+#include <linux/can/ioctl.h>
+
+struct can_priv {
+	struct can_device_stats can_stats;
+
+	/* can-bus oscillator frequency, in Hz,
+	   BE CAREFUL! SOME CONTROLLERS (LIKE SJA1000)
+	   FOOLISH ABOUT THIS FRQ (for sja1000 as ex. this
+	   clock must be xtal clock divided by 2). */
+	u32	can_sys_clock;
+
+	/* by default max_brp is equal 64,
+	   but for a Freescale TouCAN, as ex., it can be 255*/
+	u32	max_brp;
+	/* For the mostly all controllers, max_sjw is equal 4, but
+	   some, hmm, CAN implementations hardwared it to 1 */
+	u8	max_sjw;
+
+	u32	baudrate;	/* in bauds */
+	struct can_bittime	bit_time;
+
+	spinlock_t irq_lock;
+	/* Please hold this lock when touching net_stats/can_stats*/
+	spinlock_t stats_lock;
+
+	can_state_t state;
+	can_mode_t  mode;
+	can_ctrlmode_t ctrlmode;
+
+	int (*do_set_bit_time)(struct net_device *dev, struct can_bittime *br);
+	int (*do_get_state)   (struct net_device *dev, can_state_t *state);
+	int (*do_set_mode)    (struct net_device *dev, can_mode_t mode);
+	int (*do_set_ctrlmode)(struct net_device *dev, can_ctrlmode_t ctrlmode);
+	int (*do_get_ctrlmode)(struct net_device *dev, can_ctrlmode_t *ctrlmode);
+};
+
+#define ND2D(_ndev)		(_ndev->dev.parent)
+
+struct net_device *alloc_candev(int sizeof_priv);
+void free_candev(struct net_device *dev);
+
+int can_calc_bit_time(struct can_priv *can, u32 baudrate,
+		      struct can_bittime_std *bit_time);
+
+#endif /* CAN_DEVICE_H */
Index: include/linux/can/error.h
===================================================================
--- /dev/null
+++ include/linux/can/error.h
@@ -0,0 +1,93 @@
+/*
+ * linux/can/error.h
+ *
+ * Definitions of the CAN error frame to be filtered and passed to the user.
+ *
+ * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_ERROR_H
+#define CAN_ERROR_H
+
+#define CAN_ERR_DLC 8 /* dlc for error frames */
+
+/* error class (mask) in can_id */
+#define CAN_ERR_TX_TIMEOUT   0x00000001U /* TX timeout (by netdevice driver) */
+#define CAN_ERR_LOSTARB      0x00000002U /* lost arbitration    / data[0]    */
+#define CAN_ERR_CRTL         0x00000004U /* controller problems / data[1]    */
+#define CAN_ERR_PROT         0x00000008U /* protocol violations / data[2..3] */
+#define CAN_ERR_TRX          0x00000010U /* transceiver status  / data[4]    */
+#define CAN_ERR_ACK          0x00000020U /* received no ACK on transmission */
+#define CAN_ERR_BUSOFF       0x00000040U /* bus off */
+#define CAN_ERR_BUSERROR     0x00000080U /* bus error (may flood!) */
+#define CAN_ERR_RESTARTED    0x00000100U /* controller restarted */
+
+/* arbitration lost in bit ... / data[0] */
+#define CAN_ERR_LOSTARB_UNSPEC   0x00 /* unspecified */
+				      /* else bit number in bitstream */
+
+/* error status of CAN-controller / data[1] */
+#define CAN_ERR_CRTL_UNSPEC      0x00 /* unspecified */
+#define CAN_ERR_CRTL_RX_OVERFLOW 0x01 /* RX buffer overflow */
+#define CAN_ERR_CRTL_TX_OVERFLOW 0x02 /* TX buffer overflow */
+#define CAN_ERR_CRTL_RX_WARNING  0x04 /* reached warning level for RX errors */
+#define CAN_ERR_CRTL_TX_WARNING  0x08 /* reached warning level for TX errors */
+#define CAN_ERR_CRTL_RX_PASSIVE  0x10 /* reached error passive status RX */
+#define CAN_ERR_CRTL_TX_PASSIVE  0x20 /* reached error passive status TX */
+				      /* (at least one error counter exceeds */
+				      /* the protocol-defined level of 127)  */
+
+/* error in CAN protocol (type) / data[2] */
+#define CAN_ERR_PROT_UNSPEC      0x00 /* unspecified */
+#define CAN_ERR_PROT_BIT         0x01 /* single bit error */
+#define CAN_ERR_PROT_FORM        0x02 /* frame format error */
+#define CAN_ERR_PROT_STUFF       0x04 /* bit stuffing error */
+#define CAN_ERR_PROT_BIT0        0x08 /* unable to send dominant bit */
+#define CAN_ERR_PROT_BIT1        0x10 /* unable to send recessive bit */
+#define CAN_ERR_PROT_OVERLOAD    0x20 /* bus overload */
+#define CAN_ERR_PROT_ACTIVE      0x40 /* active error announcement */
+#define CAN_ERR_PROT_TX          0x80 /* error occured on transmission */
+
+/* error in CAN protocol (location) / data[3] */
+#define CAN_ERR_PROT_LOC_UNSPEC  0x00 /* unspecified */
+#define CAN_ERR_PROT_LOC_SOF     0x03 /* start of frame */
+#define CAN_ERR_PROT_LOC_ID28_21 0x02 /* ID bits 28 - 21 (SFF: 10 - 3) */
+#define CAN_ERR_PROT_LOC_ID20_18 0x06 /* ID bits 20 - 18 (SFF: 2 - 0 )*/
+#define CAN_ERR_PROT_LOC_SRTR    0x04 /* substitute RTR (SFF: RTR) */
+#define CAN_ERR_PROT_LOC_IDE     0x05 /* identifier extension */
+#define CAN_ERR_PROT_LOC_ID17_13 0x07 /* ID bits 17-13 */
+#define CAN_ERR_PROT_LOC_ID12_05 0x0F /* ID bits 12-5 */
+#define CAN_ERR_PROT_LOC_ID04_00 0x0E /* ID bits 4-0 */
+#define CAN_ERR_PROT_LOC_RTR     0x0C /* RTR */
+#define CAN_ERR_PROT_LOC_RES1    0x0D /* reserved bit 1 */
+#define CAN_ERR_PROT_LOC_RES0    0x09 /* reserved bit 0 */
+#define CAN_ERR_PROT_LOC_DLC     0x0B /* data length code */
+#define CAN_ERR_PROT_LOC_DATA    0x0A /* data section */
+#define CAN_ERR_PROT_LOC_CRC_SEQ 0x08 /* CRC sequence */
+#define CAN_ERR_PROT_LOC_CRC_DEL 0x18 /* CRC delimiter */
+#define CAN_ERR_PROT_LOC_ACK     0x19 /* ACK slot */
+#define CAN_ERR_PROT_LOC_ACK_DEL 0x1B /* ACK delimiter */
+#define CAN_ERR_PROT_LOC_EOF     0x1A /* end of frame */
+#define CAN_ERR_PROT_LOC_INTERM  0x12 /* intermission */
+
+/* error status of CAN-transceiver / data[4] */
+/*                                             CANH CANL */
+#define CAN_ERR_TRX_UNSPEC             0x00 /* 0000 0000 */
+#define CAN_ERR_TRX_CANH_NO_WIRE       0x04 /* 0000 0100 */
+#define CAN_ERR_TRX_CANH_SHORT_TO_BAT  0x05 /* 0000 0101 */
+#define CAN_ERR_TRX_CANH_SHORT_TO_VCC  0x06 /* 0000 0110 */
+#define CAN_ERR_TRX_CANH_SHORT_TO_GND  0x07 /* 0000 0111 */
+#define CAN_ERR_TRX_CANL_NO_WIRE       0x40 /* 0100 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_BAT  0x50 /* 0101 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_VCC  0x60 /* 0110 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_GND  0x70 /* 0111 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_CANH 0x80 /* 1000 0000 */
+
+/* controller specific additional information / data[5..7] */
+
+#endif /* CAN_ERROR_H */
Index: include/linux/can/ioctl.h
===================================================================
--- /dev/null
+++ include/linux/can/ioctl.h
@@ -0,0 +1,149 @@
+/*
+ * linux/can/ioctl.h
+ *
+ * Definitions for CAN controller setup (work in progress)
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_IOCTL_H
+#define CAN_IOCTL_H
+
+#include <linux/sockios.h>
+
+
+/* max. 16 private ioctls */
+
+#define SIOCSCANBAUDRATE	(SIOCDEVPRIVATE+0)
+#define SIOCGCANBAUDRATE	(SIOCDEVPRIVATE+1)
+
+#define SIOCSCANCUSTOMBITTIME   (SIOCDEVPRIVATE+2)
+#define SIOCGCANCUSTOMBITTIME   (SIOCDEVPRIVATE+3)
+
+#define SIOCSCANMODE		(SIOCDEVPRIVATE+4)
+#define SIOCGCANMODE		(SIOCDEVPRIVATE+5)
+
+#define SIOCSCANCTRLMODE	(SIOCDEVPRIVATE+6)
+#define SIOCGCANCTRLMODE	(SIOCDEVPRIVATE+7)
+
+#define SIOCSCANFILTER		(SIOCDEVPRIVATE+8)
+#define SIOCGCANFILTER		(SIOCDEVPRIVATE+9)
+
+#define SIOCGCANSTATE		(SIOCDEVPRIVATE+10)
+#define SIOCGCANSTATS		(SIOCDEVPRIVATE+11)
+
+#define SIOCSCANERRORCONFIG	(SIOCDEVPRIVATE+12)
+#define SIOCGCANERRORCONFIG	(SIOCDEVPRIVATE+13)
+
+/* parameters for ioctls */
+
+/* SIOC[SG]CANBAUDRATE */
+/* baudrate for CAN-controller in bits per second. */
+/* 0 = Scan for baudrate (Autobaud) */
+
+typedef __u32 can_baudrate_t;
+
+
+/* SIOC[SG]CANCUSTOMBITTIME */
+
+typedef enum CAN_BITTIME_TYPE {
+	CAN_BITTIME_STD,
+	CAN_BITTIME_BTR
+} can_bittime_type_t;
+
+/* TSEG1 of controllers usually is a sum of synch_seg (always 1),
+ * prop_seg and phase_seg1, TSEG2 = phase_seg2 */
+
+struct can_bittime_std {
+	__u32 brp;        /* baud rate prescaler */
+	__u8  prop_seg;   /* from 1 to 8 */
+	__u8  phase_seg1; /* from 1 to 8 */
+	__u8  phase_seg2; /* from 1 to 8 */
+	__u8  sjw:7;      /* from 1 to 4 */
+	__u8  sam:1;      /* 1 - enable triple sampling */
+};
+
+struct can_bittime_btr {
+	__u8  btr0;
+	__u8  btr1;
+};
+
+struct can_bittime {
+	can_bittime_type_t type;
+	union {
+		struct can_bittime_std std;
+		struct can_bittime_btr btr;
+	};
+};
+
+#define CAN_BAUDRATE_UNCONFIGURED	((__u32) 0xFFFFFFFFU)
+#define CAN_BAUDRATE_UNKNOWN		0
+
+/* SIOC[SG]CANMODE */
+
+typedef __u32 can_mode_t;
+
+#define CAN_MODE_STOP	0
+#define CAN_MODE_START	1
+#define CAN_MODE_SLEEP	2
+
+
+/* SIOC[SG]CANCTRLMODE */
+
+typedef __u32 can_ctrlmode_t;
+
+#define CAN_CTRLMODE_LOOPBACK   0x1
+#define CAN_CTRLMODE_LISTENONLY 0x2
+
+
+/* SIOCGCANFILTER */
+
+typedef __u32 can_filter_t;
+
+/* filter modes (may vary due to controller specific capabilities) */
+#define CAN_FILTER_CAPAB       0  /* get filter type capabilities (32 Bit value) */
+#define CAN_FILTER_MASK_VALUE  1  /* easy bit filter (see struct can_filter) */
+#define CAN_FILTER_SFF_BITMASK 2  /* bitfield with 2048 bit SFF filter */
+				  /* filters 3 - 31 currently undefined */
+
+#define CAN_FILTER_MAX         31 /* max. filter type value */
+
+
+/* SIOCGCANSTATE */
+
+typedef __u32 can_state_t;
+
+#define CAN_STATE_ACTIVE		0
+#define CAN_STATE_BUS_WARNING		1
+#define CAN_STATE_BUS_PASSIVE		2
+#define CAN_STATE_BUS_OFF		3
+#define CAN_STATE_SCANNING_BAUDRATE	4
+#define CAN_STATE_STOPPED		5
+#define CAN_STATE_SLEEPING		6
+
+
+/* SIOCGCANSTATS */
+
+struct can_device_stats {
+	int error_warning;
+	int data_overrun;
+	int wakeup;
+	int bus_error;
+	int error_passive;
+	int arbitration_lost;
+	int restarts;
+	int bus_error_at_init;
+};
+
+/* SIOC[SG]CANERRORCONFIG */
+
+typedef enum CAN_ERRCFG_TYPE {
+	CAN_ERRCFG_MASK,
+	CAN_ERRCFG_BUSERR,
+	CAN_ERRCFG_BUSOFF
+} can_errcfg_type_t;
+
+/* tbd */
+
+#endif /* CAN_IOCTL_H */
Index: include/linux/can/raw.h
===================================================================
--- /dev/null
+++ include/linux/can/raw.h
@@ -0,0 +1,31 @@
+/*
+ * linux/can/raw.h
+ *
+ * Definitions for raw CAN sockets
+ *
+ * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ *          Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_RAW_H
+#define CAN_RAW_H
+
+#include <linux/can.h>
+
+#define SOL_CAN_RAW (SOL_CAN_BASE + CAN_RAW)
+
+/* for socket options affecting the socket (not the global system) */
+
+enum {
+	CAN_RAW_FILTER = 1,	/* set 0 .. n can_filter(s)          */
+	CAN_RAW_ERR_FILTER,	/* set filter for error frames       */
+	CAN_RAW_LOOPBACK,	/* local loopback (default:on)       */
+	CAN_RAW_RECV_OWN_MSGS	/* receive my own msgs (default:off) */
+};
+
+#endif
Index: include/linux/if_arp.h
===================================================================
--- include/linux/if_arp.h.orig
+++ include/linux/if_arp.h
@@ -52,6 +52,7 @@
 #define ARPHRD_ROSE	270
 #define ARPHRD_X25	271		/* CCITT X.25			*/
 #define ARPHRD_HWX25	272		/* Boards with X.25 in firmware	*/
+#define ARPHRD_CAN	280		/* Controller Area Network      */
 #define ARPHRD_PPP	512
 #define ARPHRD_CISCO	513		/* Cisco HDLC	 		*/
 #define ARPHRD_HDLC	ARPHRD_CISCO
Index: include/linux/if_ether.h
===================================================================
--- include/linux/if_ether.h.orig
+++ include/linux/if_ether.h
@@ -90,6 +90,7 @@
 #define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
 #define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
 #define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_CAN	0x000C		/* Controller Area Network      */
 #define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
 #define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
 #define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
Index: include/linux/socket.h
===================================================================
--- include/linux/socket.h.orig
+++ include/linux/socket.h
@@ -185,6 +185,7 @@ struct ucred {
 #define AF_PPPOX	24	/* PPPoX sockets		*/
 #define AF_WANPIPE	25	/* Wanpipe API Sockets */
 #define AF_LLC		26	/* Linux LLC			*/
+#define AF_CAN		29	/* Controller Area Network      */
 #define AF_TIPC		30	/* TIPC sockets			*/
 #define AF_BLUETOOTH	31	/* Bluetooth sockets 		*/
 #define AF_IUCV		32	/* IUCV sockets			*/
@@ -220,6 +221,7 @@ struct ucred {
 #define PF_PPPOX	AF_PPPOX
 #define PF_WANPIPE	AF_WANPIPE
 #define PF_LLC		AF_LLC
+#define PF_CAN		AF_CAN
 #define PF_TIPC		AF_TIPC
 #define PF_BLUETOOTH	AF_BLUETOOTH
 #define PF_IUCV		AF_IUCV
Index: include/linux/tty.h
===================================================================
--- include/linux/tty.h.orig
+++ include/linux/tty.h
@@ -24,7 +24,7 @@
 #define NR_PTYS	CONFIG_LEGACY_PTY_COUNT   /* Number of legacy ptys */
 #define NR_UNIX98_PTY_DEFAULT	4096      /* Default maximum for Unix98 ptys */
 #define NR_UNIX98_PTY_MAX	(1 << MINORBITS) /* Absolute limit */
-#define NR_LDISCS		17
+#define NR_LDISCS		18
 
 /* line disciplines */
 #define N_TTY		0
@@ -45,6 +45,7 @@
 #define N_SYNC_PPP	14	/* synchronous PPP */
 #define N_HCI		15	/* Bluetooth HCI UART */
 #define N_GIGASET_M101	16	/* Siemens Gigaset M101 serial DECT adapter */
+#define N_SLCAN		17	/* Serial / USB serial CAN Adaptors */
 
 /*
  * This character is the same as _POSIX_VDISABLE: it cannot be used as
Index: net/Kconfig
===================================================================
--- net/Kconfig.orig
+++ net/Kconfig
@@ -210,6 +210,7 @@ endmenu
 endmenu
 
 source "net/ax25/Kconfig"
+source "net/can/Kconfig"
 source "net/irda/Kconfig"
 source "net/bluetooth/Kconfig"
 source "net/rxrpc/Kconfig"
Index: net/Makefile
===================================================================
--- net/Makefile.orig
+++ net/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_LAPB)		+= lapb/
 obj-$(CONFIG_NETROM)		+= netrom/
 obj-$(CONFIG_ROSE)		+= rose/
 obj-$(CONFIG_AX25)		+= ax25/
+obj-$(CONFIG_CAN)		+= can/
 obj-$(CONFIG_IRDA)		+= irda/
 obj-$(CONFIG_BT)		+= bluetooth/
 obj-$(CONFIG_SUNRPC)		+= sunrpc/
Index: net/can/Kconfig
===================================================================
--- /dev/null
+++ net/can/Kconfig
@@ -0,0 +1,82 @@
+#
+# Controller Area Network (CAN) network layer core configuration
+#
+
+menuconfig CAN
+	depends on NET
+	tristate "CAN bus subsystem support"
+	---help---
+	  Controller Area Network (CAN) is a slow (up to 1Mbit/s) serial
+	  communications protocol, which was developed by Bosch at
+	  1991 mainly for automotive, but now widely used in marine
+	  (NMEA2000), industrial and medical applications.
+	  More information on the CAN network protocol family PF_CAN
+	  is contained in <Documentation/networking/can.txt>.
+
+	  If you want CAN support, you should say Y here and also to the
+	  specific driver for your controller(s) below.
+
+config CAN_RAW
+	tristate "Raw CAN Protocol (raw access with CAN-ID filtering)"
+	depends on CAN
+	default N
+	---help---
+	  The Raw CAN protocol option offers access to the CAN bus via
+	  the BSD socket API. You probably want to use the raw socket in
+	  most cases where no higher level protocol is being used. The raw
+	  socket has several filter options e.g. ID-Masking / Errorframes.
+	  To receive/send raw CAN messages, use AF_CAN with protocol CAN_RAW.
+
+config CAN_RAW_USER
+	bool "Allow non-root users to access Raw CAN Protocol sockets"
+	depends on CAN_RAW
+	default N
+	---help---
+	  The Controller Area Network is a local field bus transmitting only
+	  broadcast messages without any routing and security concepts.
+	  In the majority of cases the user application has to deal with
+	  raw CAN frames. Therefore it might be reasonable NOT to restrict
+	  the CAN access only to the user root, as known from other networks.
+	  Since CAN_RAW sockets can only send and receive frames to/from CAN
+	  interfaces this does not affect security of others networks.
+	  Say Y here if you want non-root users to be able to access CAN_RAW
+	  sockets.
+
+config CAN_BCM
+	tristate "Broadcast Manager CAN Protocol (with content filtering)"
+	depends on CAN
+	default N
+	---help---
+	  The Broadcast Manager offers content filtering, timeout monitoring,
+	  sending of RTR-frames and cyclic CAN messages without permanent user
+	  interaction. The BCM can be 'programmed' via the BSD socket API and
+	  informs you on demand e.g. only on content updates / timeouts.
+	  You probably want to use the bcm socket in most cases where cyclic
+	  CAN messages are used on the bus (e.g. in automotive environments).
+	  To use the Broadcast Manager, use AF_CAN with protocol CAN_BCM.
+
+config CAN_BCM_USER
+	bool "Allow non-root users to access CAN broadcast manager sockets"
+	depends on CAN_BCM
+	default N
+	---help---
+	  The Controller Area Network is a local field bus transmitting only
+	  broadcast messages without any routing and security concepts.
+	  In the majority of cases the user application has to deal with
+	  raw CAN frames. Therefore it might be reasonable NOT to restrict
+	  the CAN access only to the user root, as known from other networks.
+	  Since CAN_BCM sockets can only send and receive frames to/from CAN
+	  interfaces this does not affect security of others networks.
+	  Say Y here if you want non-root users to be able to access CAN_BCM
+	  sockets.
+
+config CAN_DEBUG_CORE
+	bool "CAN Core debugging messages"
+	depends on CAN
+	---help---
+	  Say Y here if you want the CAN core to produce a bunch of debug
+	  messages to the system log.  Select this if you are having a
+	  problem with CAN support and want to see more of what is going on.
+
+
+source "drivers/net/can/Kconfig"
Index: net/can/Makefile
===================================================================
--- /dev/null
+++ net/can/Makefile
@@ -0,0 +1,71 @@
+#
+#
+#  Copyright (c) 2002-2005 Volkswagen Group Electronic Research
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#  1. Redistributions of source code must retain the above copyright
+#     notice, this list of conditions, the following disclaimer and
+#     the referenced file 'COPYING'.
+#  2. Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#  3. Neither the name of Volkswagen nor the names of its contributors
+#     may be used to endorse or promote products derived from this software
+#     without specific prior written permission.
+#
+#  Alternatively, provided that this notice is retained in full, this
+#  software may be distributed under the terms of the GNU General
+#  Public License ("GPL") version 2 as distributed in the 'COPYING'
+#  file from the main directory of the linux kernel source.
+#
+#  The provided data structures and external interfaces from this code
+#  are not restricted to be used by modules with a GPL compatible license.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+#  DAMAGE.
+#
+#  Send feedback to <socketcan-users@lists.berlios.de>
+
+ifeq ($(KERNELRELEASE),)
+
+KERNELDIR := /lib/modules/$(shell uname -r)/build
+PWD       := $(shell pwd)
+TOPDIR    := $(PWD)/../..
+
+modules modules_install clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@ TOPDIR=$(TOPDIR)
+
+export CONFIG_CAN=m
+export CONFIG_CAN_RAW=m
+export CONFIG_CAN_BCM=m
+
+else
+
+-include $(TOPDIR)/Makefile.common
+
+obj-$(CONFIG_CAN)	+= can.o
+can-objs		:= af_can.o proc.o
+
+obj-$(CONFIG_CAN_RAW)	+= can-raw.o
+can-raw-objs		:= raw.o
+
+obj-$(CONFIG_CAN_BCM)	+= can-bcm.o
+can-bcm-objs		:= bcm.o
+
+obj-$(CONFIG_CAN)	+= candev.o
+candev-objs		:= dev.o
+
+endif
Index: net/can/af_can.c
===================================================================
--- /dev/null
+++ net/can/af_can.c
@@ -0,0 +1,995 @@
+/*
+ * af_can.c - Protocol family CAN core module
+ *            (used by different CAN protocol modules)
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/rcupdate.h>
+#include <linux/uaccess.h>
+#include <linux/net.h>
+#include <linux/netdevice.h>
+#include <linux/socket.h>
+#include <linux/if_ether.h>
+#include <linux/if_arp.h>
+#include <linux/skbuff.h>
+#include <linux/can.h>
+#include <linux/can/core.h>
+#include <net/sock.h>
+
+#include "af_can.h"
+
+#define IDENT "core"
+static __initdata const char banner[] = KERN_INFO
+	"can: controller area network core (" CAN_VERSION_STRING ")\n";
+
+MODULE_DESCRIPTION("Controller Area Network PF_CAN core");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Urs Thuermann <urs.thuermann@volkswagen.de>, "
+	      "Oliver Hartkopp <oliver.hartkopp@volkswagen.de>");
+
+MODULE_ALIAS_NETPROTO(PF_CAN);
+
+int stats_timer = 1; /* default: on */
+module_param(stats_timer, int, S_IRUGO);
+MODULE_PARM_DESC(stats_timer, "enable timer for statistics (default:on)");
+
+#ifdef CONFIG_CAN_DEBUG_CORE
+static int debug;
+module_param(debug, int, S_IRUGO);
+MODULE_PARM_DESC(debug, "debug print mask: 1:debug, 2:frames, 4:skbs");
+#endif
+
+HLIST_HEAD(rx_dev_list);
+static struct dev_rcv_lists rx_alldev_list;
+static DEFINE_SPINLOCK(rcv_lists_lock);
+
+static struct kmem_cache *rcv_cache __read_mostly;
+
+/* table of registered CAN protocols */
+static struct can_proto *proto_tab[CAN_NPROTO];
+
+struct timer_list stattimer; /* timer for statistics update */
+struct s_stats  stats;       /* packet statistics */
+struct s_pstats pstats;      /* receive list statistics */
+
+/*
+ * af_can socket functions
+ */
+
+static int can_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
+{
+	struct sock *sk = sock->sk;
+
+	switch (cmd) {
+
+	case SIOCGSTAMP:
+		return sock_get_timestamp(sk, (struct timeval __user *)arg);
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+
+static void can_sock_destruct(struct sock *sk)
+{
+	DBG("called for sock %p\n", sk);
+
+	skb_queue_purge(&sk->sk_receive_queue);
+	if (sk->sk_protinfo)
+		kfree(sk->sk_protinfo);
+}
+
+static int can_create(struct socket *sock, int protocol)
+{
+	struct sock *sk;
+	struct can_proto *cp;
+	char module_name[sizeof("can-proto-000")];
+	int ret = 0;
+
+	DBG("socket %p, type %d, proto %d\n", sock, sock->type, protocol);
+
+	sock->state = SS_UNCONNECTED;
+
+	if (protocol < 0 || protocol >= CAN_NPROTO)
+		return -EINVAL;
+
+	DBG("looking up proto %d in proto_tab[]\n", protocol);
+
+	/* try to load protocol module, when CONFIG_KMOD is defined */
+	if (!proto_tab[protocol]) {
+		sprintf(module_name, "can-proto-%d", protocol);
+		ret = request_module(module_name);
+
+		/*
+		 * In case of error we only print a message but don't
+		 * return the error code immediately.  Below we will
+		 * return -EPROTONOSUPPORT
+		 */
+		if (ret == -ENOSYS)
+			printk(KERN_INFO "can: request_module(%s) not"
+			       " implemented.\n", module_name);
+		else if (ret)
+			printk(KERN_ERR "can: request_module(%s) failed\n",
+			       module_name);
+	}
+
+	/* check for success and correct type */
+	cp = proto_tab[protocol];
+	if (!cp || cp->type != sock->type)
+		return -EPROTONOSUPPORT;
+
+	if (cp->capability >= 0 && !capable(cp->capability))
+		return -EPERM;
+
+	sock->ops = cp->ops;
+
+	sk = sk_alloc(PF_CAN, GFP_KERNEL, cp->prot, 1);
+	if (!sk)
+		return -ENOMEM;
+
+	sock_init_data(sock, sk);
+	sk->sk_destruct = can_sock_destruct;
+
+	DBG("created sock: %p\n", sk);
+
+	if (sk->sk_prot->init)
+		ret = sk->sk_prot->init(sk);
+
+	if (ret) {
+		/* release sk on errors */
+		sock_orphan(sk);
+		sock_put(sk);
+	}
+
+	return ret;
+}
+
+/*
+ * af_can tx path
+ */
+
+/**
+ * can_send - transmit a CAN frame (optional with local loopback)
+ * @skb: pointer to socket buffer with CAN frame in data section
+ * @loop: loopback for listeners on local CAN sockets (recommended default!)
+ *
+ * Return:
+ *  0 on success
+ *  -ENETDOWN when the selected interface is down
+ *  -ENOBUFS on full driver queue (see net_xmit_errno())
+ *  -ENOMEM when local loopback failed at calling skb_clone()
+ */
+int can_send(struct sk_buff *skb, int loop)
+{
+	int err;
+
+	if (skb->dev->type != ARPHRD_CAN) {
+		kfree_skb(skb);
+		return -EPERM;
+	}
+
+	if (!(skb->dev->flags & IFF_UP)) {
+		kfree_skb(skb);
+		return -ENETDOWN;
+	}
+
+	skb->protocol = htons(ETH_P_CAN);
+
+	if (loop) {
+		/* local loopback of sent CAN frames */
+
+		/* indication for the CAN driver: do loopback */
+		skb->pkt_type = PACKET_LOOPBACK;
+
+		/*
+		 * The reference to the originating sock may be required
+		 * by the receiving socket to check whether the frame is
+		 * its own. Example: can_raw sockopt CAN_RAW_RECV_OWN_MSGS
+		 * Therefore we have to ensure that skb->sk remains the
+		 * reference to the originating sock by restoring skb->sk
+		 * after each skb_clone() or skb_orphan() usage.
+		 */
+
+		if (!(skb->dev->flags & IFF_LOOPBACK)) {
+			/*
+			 * If the interface is not capable to do loopback
+			 * itself, we do it here.
+			 */
+			struct sk_buff *newskb = skb_clone(skb, GFP_ATOMIC);
+
+			if (!newskb) {
+				kfree_skb(skb);
+				return -ENOMEM;
+			}
+
+			newskb->sk = skb->sk;
+			newskb->ip_summed = CHECKSUM_UNNECESSARY;
+			newskb->pkt_type = PACKET_BROADCAST;
+			netif_rx(newskb);
+		}
+	} else {
+		/* indication for the CAN driver: no loopback required */
+		skb->pkt_type = PACKET_HOST;
+	}
+
+	/* send to netdevice */
+	err = dev_queue_xmit(skb);
+	if (err > 0)
+		err = net_xmit_errno(err);
+
+	/* update statistics */
+	stats.tx_frames++;
+	stats.tx_frames_delta++;
+
+	return err;
+}
+EXPORT_SYMBOL(can_send);
+
+/*
+ * af_can rx path
+ */
+
+static struct dev_rcv_lists *find_dev_rcv_lists(struct net_device *dev)
+{
+	struct dev_rcv_lists *d;
+	struct hlist_node *n;
+
+	/*
+	 * find receive list for this device
+	 *
+	 * The hlist_for_each_entry*() macros curse through the list
+	 * using the pointer variable n and set d to the containing
+	 * struct in each list iteration.  Therefore, after list
+	 * iteration, d is unmodified when the list is empty, and it
+	 * points to last list element, when the list is non-empty
+	 * but no match in the loop body is found.  I.e. d is *not*
+	 * NULL when no match is found.  We can, however, use the
+	 * cursor variable n to decide if a match was found.
+	 */
+
+	hlist_for_each_entry(d, n, &rx_dev_list, list) {
+		if (d->dev == dev)
+			break;
+	}
+
+	return n ? d : NULL;
+}
+
+static struct hlist_head *find_rcv_list(canid_t *can_id, canid_t *mask,
+					struct dev_rcv_lists *d)
+{
+	canid_t inv = *can_id & CAN_INV_FILTER; /* save flag before masking */
+
+	/* filter error frames */
+	if (*mask & CAN_ERR_FLAG) {
+		/* clear CAN_ERR_FLAG in list entry */
+		*mask &= CAN_ERR_MASK;
+		return &d->rx[RX_ERR];
+	}
+
+	/* ensure valid values in can_mask */
+	if (*mask & CAN_EFF_FLAG)
+		*mask &= (CAN_EFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG);
+	else
+		*mask &= (CAN_SFF_MASK | CAN_RTR_FLAG);
+
+	/* reduce condition testing at receive time */
+	*can_id &= *mask;
+
+	/* inverse can_id/can_mask filter */
+	if (inv)
+		return &d->rx[RX_INV];
+
+	/* mask == 0 => no condition testing at receive time */
+	if (!(*mask))
+		return &d->rx[RX_ALL];
+
+	/* use extra filterset for the subscription of exactly *ONE* can_id */
+	if (*can_id & CAN_EFF_FLAG) {
+		if (*mask == (CAN_EFF_MASK | CAN_EFF_FLAG)) {
+			/* RFC: a use-case for hash-tables in the future? */
+			return &d->rx[RX_EFF];
+		}
+	} else {
+		if (*mask == CAN_SFF_MASK)
+			return &d->rx_sff[*can_id];
+	}
+
+	/* default: filter via can_id/can_mask */
+	return &d->rx[RX_FIL];
+}
+
+/**
+ * can_rx_register - subscribe CAN frames from a specific interface
+ * @dev: pointer to netdevice (NULL => subcribe from 'all' CAN devices list)
+ * @can_id: CAN identifier (see description)
+ * @mask: CAN mask (see description)
+ * @func: callback function on filter match
+ * @data: returned parameter for callback function
+ * @ident: string for calling module indentification
+ *
+ * Description:
+ *  Invokes the callback function with the received sk_buff and the given
+ *  parameter 'data' on a matching receive filter. A filter matches, when
+ *
+ *          <received_can_id> & mask == can_id & mask
+ *
+ *  The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
+ *  filter for error frames (CAN_ERR_FLAG bit set in mask).
+ *
+ * Return:
+ *  0 on success
+ *  -ENOMEM on missing cache mem to create subscription entry
+ *  -ENODEV unknown device
+ */
+int can_rx_register(struct net_device *dev, canid_t can_id, canid_t mask,
+		    void (*func)(struct sk_buff *, void *), void *data,
+		    char *ident)
+{
+	struct receiver *r;
+	struct hlist_head *rl;
+	struct dev_rcv_lists *d;
+	int ret = 0;
+
+	/* insert new receiver  (dev,canid,mask) -> (func,data) */
+
+	DBG("dev %p (%s), id %03X, mask %03X, callback %p, data %p, "
+	    "ident %s\n", dev, DNAME(dev), can_id, mask, func, data, ident);
+
+	r = kmem_cache_alloc(rcv_cache, GFP_KERNEL);
+	if (!r)
+		return -ENOMEM;
+
+	spin_lock_bh(&rcv_lists_lock);
+
+	d = find_dev_rcv_lists(dev);
+	if (d) {
+		rl = find_rcv_list(&can_id, &mask, d);
+
+		r->can_id  = can_id;
+		r->mask    = mask;
+		r->matches = 0;
+		r->func    = func;
+		r->data    = data;
+		r->ident   = ident;
+
+		hlist_add_head_rcu(&r->list, rl);
+		d->entries++;
+
+		pstats.rcv_entries++;
+		if (pstats.rcv_entries_max < pstats.rcv_entries)
+			pstats.rcv_entries_max = pstats.rcv_entries;
+	} else {
+		DBG("receive list not found for dev %s, id %03X, mask %03X\n",
+		    DNAME(dev), can_id, mask);
+		kmem_cache_free(rcv_cache, r);
+		ret = -ENODEV;
+	}
+
+	spin_unlock_bh(&rcv_lists_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(can_rx_register);
+
+/*
+ * can_rx_delete_device - rcu callback for dev_rcv_lists structure removal
+ */
+static void can_rx_delete_device(struct rcu_head *rp)
+{
+	struct dev_rcv_lists *d = container_of(rp, struct dev_rcv_lists, rcu);
+
+	DBG("removing dev_rcv_list at %p\n", d);
+	kfree(d);
+}
+
+/*
+ * can_rx_delete_receiver - rcu callback for single receiver entry removal
+ */
+static void can_rx_delete_receiver(struct rcu_head *rp)
+{
+	struct receiver *r = container_of(rp, struct receiver, rcu);
+
+	DBG("removing receiver at %p\n", r);
+	kmem_cache_free(rcv_cache, r);
+}
+
+/**
+ * can_rx_unregister - unsubscribe CAN frames from a specific interface
+ * @dev: pointer to netdevice (NULL => unsubcribe from 'all' CAN devices list)
+ * @can_id: CAN identifier
+ * @mask: CAN mask
+ * @func: callback function on filter match
+ * @data: returned parameter for callback function
+ *
+ * Description:
+ *  Removes subscription entry depending on given (subscription) values.
+ *
+ * Return:
+ *  0 on success
+ *  -EINVAL on missing subscription entry
+ *  -ENODEV unknown device
+ */
+int can_rx_unregister(struct net_device *dev, canid_t can_id, canid_t mask,
+		      void (*func)(struct sk_buff *, void *), void *data)
+{
+	struct receiver *r = NULL;
+	struct hlist_head *rl;
+	struct hlist_node *next;
+	struct dev_rcv_lists *d;
+	int ret = 0;
+
+	DBG("dev %p (%s), id %03X, mask %03X, callback %p, data %p\n",
+	    dev, DNAME(dev), can_id, mask, func, data);
+
+	spin_lock_bh(&rcv_lists_lock);
+
+	d = find_dev_rcv_lists(dev);
+	if (!d) {
+		DBG("receive list not found for dev %s, id %03X, mask %03X\n",
+		    DNAME(dev), can_id, mask);
+		ret = -ENODEV;
+		goto out;
+	}
+
+	rl = find_rcv_list(&can_id, &mask, d);
+
+	/*
+	 * Search the receiver list for the item to delete.  This should
+	 * exist, since no receiver may be unregistered that hasn't
+	 * been registered before.
+	 */
+
+	hlist_for_each_entry(r, next, rl, list) {
+		if (r->can_id == can_id && r->mask == mask
+		    && r->func == func && r->data == data)
+			break;
+	}
+
+	/*
+	 * Check for bug in CAN protocol implementations:
+	 * If no matching list item was found, the list cursor variable next
+	 * will be NULL, while r will point to the last item of the list.
+	 */
+
+	if (!next) {
+		DBG("receive list entry not found for "
+		    "dev %s, id %03X, mask %03X\n", DNAME(dev), can_id, mask);
+		ret = -EINVAL;
+		r = NULL;
+		d = NULL;
+		goto out;
+	}
+
+	hlist_del_rcu(&r->list);
+	d->entries--;
+
+	if (pstats.rcv_entries > 0)
+		pstats.rcv_entries--;
+
+	/* remove device structure requested by NETDEV_UNREGISTER */
+	if (d->remove_on_zero_entries && !d->entries) {
+		DBG("removing dev_rcv_list for %s on zero entries\n",
+		    dev->name);
+		hlist_del_rcu(&d->list);
+	} else
+		d = NULL;
+
+ out:
+	spin_unlock_bh(&rcv_lists_lock);
+
+	/* schedule the receiver item for deletion */
+	if (r)
+		call_rcu(&r->rcu, can_rx_delete_receiver);
+
+	/* schedule the device structure for deletion */
+	if (d)
+		call_rcu(&d->rcu, can_rx_delete_device);
+
+	return ret;
+}
+EXPORT_SYMBOL(can_rx_unregister);
+
+static inline void deliver(struct sk_buff *skb, struct receiver *r)
+{
+	struct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);
+
+	DBG("skbuff %p cloned to %p\n", skb, clone);
+	if (clone) {
+		clone->sk = skb->sk;
+		r->func(clone, r->data);
+		r->matches++;
+	}
+}
+
+static int can_rcv_filter(struct dev_rcv_lists *d, struct sk_buff *skb)
+{
+	struct receiver *r;
+	struct hlist_node *n;
+	int matches = 0;
+	struct can_frame *cf = (struct can_frame *)skb->data;
+	canid_t can_id = cf->can_id;
+
+	if (d->entries == 0)
+		return 0;
+
+	if (can_id & CAN_ERR_FLAG) {
+		/* check for error frame entries only */
+		hlist_for_each_entry_rcu(r, n, &d->rx[RX_ERR], list) {
+			if (can_id & r->mask) {
+				DBG("match on rx_err skbuff %p\n", skb);
+				deliver(skb, r);
+				matches++;
+			}
+		}
+		return matches;
+	}
+
+	/* check for unfiltered entries */
+	hlist_for_each_entry_rcu(r, n, &d->rx[RX_ALL], list) {
+		DBG("match on rx_all skbuff %p\n", skb);
+		deliver(skb, r);
+		matches++;
+	}
+
+	/* check for can_id/mask entries */
+	hlist_for_each_entry_rcu(r, n, &d->rx[RX_FIL], list) {
+		if ((can_id & r->mask) == r->can_id) {
+			DBG("match on rx_fil skbuff %p\n", skb);
+			deliver(skb, r);
+			matches++;
+		}
+	}
+
+	/* check for inverted can_id/mask entries */
+	hlist_for_each_entry_rcu(r, n, &d->rx[RX_INV], list) {
+		if ((can_id & r->mask) != r->can_id) {
+			DBG("match on rx_inv skbuff %p\n", skb);
+			deliver(skb, r);
+			matches++;
+		}
+	}
+
+	/* check CAN_ID specific entries */
+	if (can_id & CAN_EFF_FLAG) {
+		hlist_for_each_entry_rcu(r, n, &d->rx[RX_EFF], list) {
+			if (r->can_id == can_id) {
+				DBG("match on rx_eff skbuff %p\n", skb);
+				deliver(skb, r);
+				matches++;
+			}
+		}
+	} else {
+		can_id &= CAN_SFF_MASK;
+		hlist_for_each_entry_rcu(r, n, &d->rx_sff[can_id], list) {
+			DBG("match on rx_sff skbuff %p\n", skb);
+			deliver(skb, r);
+			matches++;
+		}
+	}
+
+	return matches;
+}
+
+static int can_rcv(struct sk_buff *skb, struct net_device *dev,
+		   struct packet_type *pt, struct net_device *orig_dev)
+{
+	struct dev_rcv_lists *d;
+	int matches;
+
+	DBG("received skbuff on device %s, ptype %04x\n",
+	    dev->name, ntohs(pt->type));
+	DBG_SKB(skb);
+	DBG_FRAME("af_can: can_rcv: received CAN frame",
+		  (struct can_frame *)skb->data);
+
+	if (dev->type != ARPHRD_CAN) {
+		kfree_skb(skb);
+		return 0;
+	}
+
+	/* update statistics */
+	stats.rx_frames++;
+	stats.rx_frames_delta++;
+
+	rcu_read_lock();
+
+	/* deliver the packet to sockets listening on all devices */
+	matches = can_rcv_filter(&rx_alldev_list, skb);
+
+	/* find receive list for this device */
+	d = find_dev_rcv_lists(dev);
+	if (d)
+		matches += can_rcv_filter(d, skb);
+
+	rcu_read_unlock();
+
+	/* free the skbuff allocated by the netdevice driver */
+	DBG("freeing skbuff %p\n", skb);
+	kfree_skb(skb);
+
+	if (matches > 0) {
+		stats.matches++;
+		stats.matches_delta++;
+	}
+
+	return 0;
+}
+
+/*
+ * af_can protocol functions
+ */
+
+/**
+ * can_proto_register - register CAN transport protocol
+ * @cp: pointer to CAN protocol structure
+ *
+ * Return:
+ *  0 on success
+ *  -EINVAL invalid (out of range) protocol number
+ *  -EBUSY  protocol already in use
+ *  -ENOBUF if proto_register() fails
+ */
+int can_proto_register(struct can_proto *cp)
+{
+	int proto = cp->protocol;
+	int err = 0;
+
+	if (proto < 0 || proto >= CAN_NPROTO) {
+		printk(KERN_ERR "can: protocol number %d out of range\n",
+		       proto);
+		return -EINVAL;
+	}
+	if (proto_tab[proto]) {
+		printk(KERN_ERR "can: protocol %d already registered\n",
+		       proto);
+		return -EBUSY;
+	}
+
+	err = proto_register(cp->prot, 0);
+	if (err < 0)
+		return err;
+
+	proto_tab[proto] = cp;
+
+	/* use generic ioctl function if the module doesn't bring its own */
+	if (!cp->ops->ioctl)
+		cp->ops->ioctl = can_ioctl;
+
+	return err;
+}
+EXPORT_SYMBOL(can_proto_register);
+
+/**
+ * can_proto_unregister - unregister CAN transport protocol
+ * @cp: pointer to CAN protocol structure
+ *
+ * Return:
+ *  0 on success
+ *  -ESRCH protocol number was not registered
+ */
+int can_proto_unregister(struct can_proto *cp)
+{
+	int proto = cp->protocol;
+
+	if (!proto_tab[proto]) {
+		printk(KERN_ERR "can: protocol %d is not registered\n", proto);
+		return -ESRCH;
+	}
+	proto_unregister(cp->prot);
+	proto_tab[proto] = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL(can_proto_unregister);
+
+/*
+ * af_can notifier to create/remove CAN netdevice specific structs
+ */
+static int can_notifier(struct notifier_block *nb, unsigned long msg,
+			void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct dev_rcv_lists *d;
+
+	DBG("msg %ld for dev %p (%s idx %d)\n",
+	    msg, dev, dev->name, dev->ifindex);
+
+	if (dev->type != ARPHRD_CAN)
+		return NOTIFY_DONE;
+
+	switch (msg) {
+
+	case NETDEV_REGISTER:
+
+		/*
+		 * create new dev_rcv_lists for this device
+		 *
+		 * N.B. zeroing the struct is the correct initialization
+		 * for the embedded hlist_head structs.
+		 * Another list type, e.g. list_head, would require
+		 * explicit initialization.
+		 */
+
+		DBG("creating new dev_rcv_lists for %s\n", dev->name);
+
+		d = kzalloc(sizeof(*d),
+			    in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+		if (!d) {
+			printk(KERN_ERR
+			       "can: allocation of receive list failed\n");
+			return NOTIFY_DONE;
+		}
+		d->dev = dev;
+
+		spin_lock_bh(&rcv_lists_lock);
+		hlist_add_head_rcu(&d->list, &rx_dev_list);
+		spin_unlock_bh(&rcv_lists_lock);
+
+		break;
+
+	case NETDEV_UNREGISTER:
+		spin_lock_bh(&rcv_lists_lock);
+
+		d = find_dev_rcv_lists(dev);
+		if (d) {
+			DBG("remove dev_rcv_list for %s (%d entries)\n",
+			    dev->name, d->entries);
+
+			if (d->entries) {
+				d->remove_on_zero_entries = 1;
+				d = NULL;
+			} else
+				hlist_del_rcu(&d->list);
+		} else
+			printk(KERN_ERR "can: notifier: receive list not "
+			       "found for dev %s\n", dev->name);
+
+		spin_unlock_bh(&rcv_lists_lock);
+
+		if (d)
+			call_rcu(&d->rcu, can_rx_delete_device);
+
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+/*
+ * af_can debugging stuff
+ */
+
+#ifdef CONFIG_CAN_DEBUG_CORE
+
+#define DBG_BSIZE 1024
+
+/**
+ * can_debug_cframe - print CAN frame
+ * @msg: pointer to message printed before the given CAN frame
+ * @cf: pointer to CAN frame
+ */
+void can_debug_cframe(const char *msg, struct can_frame *cf, ...)
+{
+	va_list ap;
+	int len;
+	int dlc, i;
+	char *buf;
+
+	buf = kmalloc(DBG_BSIZE, GFP_ATOMIC);
+	if (!buf)
+		return;
+
+	len = sprintf(buf, KERN_DEBUG);
+	va_start(ap, cf);
+	len += snprintf(buf + len, DBG_BSIZE - 64, msg, ap);
+	buf[len++] = ':';
+	buf[len++] = ' ';
+	va_end(ap);
+
+	dlc = cf->can_dlc;
+	if (dlc > 8)
+		dlc = 8;
+
+	if (cf->can_id & CAN_EFF_FLAG)
+		len += sprintf(buf + len, "<%08X> [%X] ",
+			       cf->can_id & CAN_EFF_MASK, dlc);
+	else
+		len += sprintf(buf + len, "<%03X> [%X] ",
+			       cf->can_id & CAN_SFF_MASK, dlc);
+
+	for (i = 0; i < dlc; i++)
+		len += sprintf(buf + len, "%02X ", cf->data[i]);
+
+	if (cf->can_id & CAN_RTR_FLAG)
+		len += sprintf(buf + len, "(RTR)");
+
+	buf[len++] = '\n';
+	buf[len]   = '\0';
+	printk(buf);
+	kfree(buf);
+}
+EXPORT_SYMBOL(can_debug_cframe);
+
+/**
+ * can_debug_skb - print socket buffer content to kernel log
+ * @skb: pointer to socket buffer
+ */
+void can_debug_skb(struct sk_buff *skb)
+{
+	int len, nbytes, i;
+	char *buf;
+
+	buf = kmalloc(DBG_BSIZE, GFP_ATOMIC);
+	if (!buf)
+		return;
+
+	len = sprintf(buf,
+		      KERN_DEBUG "  skbuff at %p, dev: %d, proto: %04x\n"
+		      KERN_DEBUG "  users: %d, dataref: %d, nr_frags: %d, "
+		      "h,d,t,e,l: %p %+d %+d %+d, %d",
+		      skb, skb->dev ? skb->dev->ifindex : -1,
+		      ntohs(skb->protocol),
+		      atomic_read(&skb->users),
+		      atomic_read(&(skb_shinfo(skb)->dataref)),
+		      skb_shinfo(skb)->nr_frags,
+		      skb->head, skb->data - skb->head,
+		      skb->tail - skb->head, skb->end - skb->head, skb->len);
+	nbytes = skb->end - skb->head;
+	for (i = 0; i < nbytes; i++) {
+		if (i % 16 == 0)
+			len += sprintf(buf + len, "\n" KERN_DEBUG "  ");
+		if (len < DBG_BSIZE - 16) {
+			len += sprintf(buf + len, " %02x", skb->head[i]);
+		} else {
+			len += sprintf(buf + len, "...");
+			break;
+		}
+	}
+	buf[len++] = '\n';
+	buf[len]   = '\0';
+	printk(buf);
+	kfree(buf);
+}
+EXPORT_SYMBOL(can_debug_skb);
+
+#endif
+
+/*
+ * af_can module init/exit functions
+ */
+
+static struct packet_type can_packet = {
+	.type = __constant_htons(ETH_P_CAN),
+	.dev  = NULL,
+	.func = can_rcv,
+};
+
+static struct net_proto_family can_family_ops = {
+	.family = PF_CAN,
+	.create = can_create,
+	.owner  = THIS_MODULE,
+};
+
+/* notifier block for netdevice event */
+static struct notifier_block can_netdev_notifier = {
+	.notifier_call = can_notifier,
+};
+
+static __init int can_init(void)
+{
+	printk(banner);
+
+	rcv_cache = kmem_cache_create("can_receiver", sizeof(struct receiver),
+				      0, 0, NULL);
+	if (!rcv_cache)
+		return -ENOMEM;
+
+	/*
+	 * Insert rx_alldev_list for reception on all devices.
+	 * This struct is zero initialized which is correct for the
+	 * embedded hlist heads, the dev pointer, and the entries counter.
+	 */
+
+	spin_lock_bh(&rcv_lists_lock);
+	hlist_add_head_rcu(&rx_alldev_list.list, &rx_dev_list);
+	spin_unlock_bh(&rcv_lists_lock);
+
+	if (stats_timer) {
+		/* the statistics are updated every second (timer triggered) */
+		init_timer(&stattimer);
+		stattimer.function = can_stat_update;
+		stattimer.data = 0;
+		/* update every second */
+		stattimer.expires = jiffies + HZ;
+		/* start statistics timer */
+		add_timer(&stattimer);
+	} else
+		stattimer.function = NULL;
+
+	/* procfs init */
+	can_init_proc();
+
+	/* protocol register */
+	sock_register(&can_family_ops);
+	register_netdevice_notifier(&can_netdev_notifier);
+	dev_add_pack(&can_packet);
+
+	return 0;
+}
+
+static __exit void can_exit(void)
+{
+	struct dev_rcv_lists *d;
+	struct hlist_node *n, *next;
+
+	if (stats_timer)
+		del_timer(&stattimer);
+
+	/* procfs remove */
+	can_remove_proc();
+
+	/* protocol unregister */
+	dev_remove_pack(&can_packet);
+	unregister_netdevice_notifier(&can_netdev_notifier);
+	sock_unregister(PF_CAN);
+
+	/* remove rx_dev_list */
+	spin_lock_bh(&rcv_lists_lock);
+	hlist_del(&rx_alldev_list.list);
+	hlist_for_each_entry_safe(d, n, next, &rx_dev_list, list) {
+		hlist_del(&d->list);
+		kfree(d);
+	}
+	spin_unlock_bh(&rcv_lists_lock);
+
+	kmem_cache_destroy(rcv_cache);
+}
+
+module_init(can_init);
+module_exit(can_exit);
Index: net/can/af_can.h
===================================================================
--- /dev/null
+++ net/can/af_can.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef AF_CAN_H
+#define AF_CAN_H
+
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/list.h>
+#include <linux/rcupdate.h>
+#include <linux/can.h>
+
+/* af_can rx dispatcher structures */
+
+struct receiver {
+	struct hlist_node list;
+	struct rcu_head rcu;
+	canid_t can_id;
+	canid_t mask;
+	unsigned long matches;
+	void (*func)(struct sk_buff *, void *);
+	void *data;
+	char *ident;
+};
+
+enum { RX_ERR, RX_ALL, RX_FIL, RX_INV, RX_EFF, RX_MAX };
+
+struct dev_rcv_lists {
+	struct hlist_node list;
+	struct rcu_head rcu;
+	struct net_device *dev;
+	struct hlist_head rx[RX_MAX];
+	struct hlist_head rx_sff[0x800];
+	int remove_on_zero_entries;
+	int entries;
+};
+
+/* statistic structures */
+
+struct s_stats {
+	unsigned long jiffies_init;
+
+	unsigned long rx_frames;
+	unsigned long tx_frames;
+	unsigned long matches;
+
+	unsigned long total_rx_rate;
+	unsigned long total_tx_rate;
+	unsigned long total_rx_match_ratio;
+
+	unsigned long current_rx_rate;
+	unsigned long current_tx_rate;
+	unsigned long current_rx_match_ratio;
+
+	unsigned long max_rx_rate;
+	unsigned long max_tx_rate;
+	unsigned long max_rx_match_ratio;
+
+	unsigned long rx_frames_delta;
+	unsigned long tx_frames_delta;
+	unsigned long matches_delta;
+}; /* can be reset e.g. by can_init_stats() */
+
+struct s_pstats {
+	unsigned long stats_reset;
+	unsigned long user_reset;
+	unsigned long rcv_entries;
+	unsigned long rcv_entries_max;
+}; /* persistent statistics */
+
+/* function prototypes for the CAN networklayer procfs (proc.c) */
+extern void can_init_proc(void);
+extern void can_remove_proc(void);
+extern void can_stat_update(unsigned long data);
+
+/* structures and variables from af_can.c needed in proc.c for reading */
+extern struct timer_list stattimer;	/* timer for statistics update */
+extern struct s_stats  stats;		/* packet statistics */
+extern struct s_pstats pstats;		/* receive list statistics */
+extern struct hlist_head rx_dev_list;	/* rx dispatcher structures */
+
+#endif /* AF_CAN_H */
Index: net/can/bcm.c
===================================================================
--- /dev/null
+++ net/can/bcm.c
@@ -0,0 +1,1757 @@
+/*
+ * bcm.c - Broadcast Manager to filter/send (cyclic) CAN content
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/uio.h>
+#include <linux/poll.h>
+#include <linux/net.h>
+#include <linux/netdevice.h>
+#include <linux/socket.h>
+#include <linux/if_arp.h>
+#include <linux/skbuff.h>
+#include <linux/can.h>
+#include <linux/can/core.h>
+#include <linux/can/bcm.h>
+#include <net/sock.h>
+
+/* use of last_frames[index].can_dlc */
+#define RX_RECV    0x40 /* received data for this element */
+#define RX_THR     0x80 /* element not been sent due to throttle feature */
+#define BCM_CAN_DLC_MASK 0x0F /* clean private flags in can_dlc by masking */
+
+/* get best masking value for can_rx_register() for a given single can_id */
+#define REGMASK(id) ((id & CAN_RTR_FLAG) | ((id & CAN_EFF_FLAG) ? \
+			(CAN_EFF_MASK | CAN_EFF_FLAG) : CAN_SFF_MASK))
+
+#define IDENT "bcm"
+#define CAN_BCM_VERSION CAN_VERSION
+static __initdata const char banner[] = KERN_INFO
+	"can: broadcast manager protocol (rev " CAN_BCM_VERSION ")\n";
+
+MODULE_DESCRIPTION("PF_CAN broadcast manager protocol");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Oliver Hartkopp <oliver.hartkopp@volkswagen.de>");
+
+#ifdef CONFIG_CAN_DEBUG_CORE
+static int debug;
+module_param(debug, int, S_IRUGO);
+MODULE_PARM_DESC(debug, "debug print mask: 1:debug, 2:frames, 4:skbs");
+#endif
+
+/* easy access to can_frame payload */
+static inline u64 GET_U64(const struct can_frame *cp)
+{
+	return *(u64 *)cp->data;
+}
+
+struct bcm_op {
+	struct list_head list;
+	int ifindex;
+	canid_t can_id;
+	int flags;
+	unsigned long j_ival1, j_ival2, j_lastmsg;
+	unsigned long frames_abs, frames_filtered;
+	struct timer_list timer, thrtimer;
+	struct timeval ival1, ival2;
+	ktime_t rx_stamp;
+	int rx_ifindex;
+	int count;
+	int nframes;
+	int currframe;
+	struct can_frame *frames;
+	struct can_frame *last_frames;
+	struct can_frame sframe;
+	struct can_frame last_sframe;
+	struct sock *sk;
+	struct net_device *rx_reg_dev;
+};
+
+static struct proc_dir_entry *proc_dir;
+
+#ifdef CONFIG_CAN_BCM_USER
+#define BCM_CAP (-1)
+#else
+#define BCM_CAP CAP_NET_RAW
+#endif
+
+struct bcm_sock {
+	struct sock sk;
+	int bound;
+	int ifindex;
+	struct notifier_block notifier;
+	struct list_head rx_ops;
+	struct list_head tx_ops;
+	unsigned long dropped_usr_msgs;
+	struct proc_dir_entry *bcm_proc_read;
+	char procname [9]; /* pointer printed in ASCII with \0 */
+};
+
+static inline struct bcm_sock *bcm_sk(const struct sock *sk)
+{
+	return (struct bcm_sock *)sk;
+}
+
+#define CFSIZ sizeof(struct can_frame)
+#define OPSIZ sizeof(struct bcm_op)
+#define MHSIZ sizeof(struct bcm_msg_head)
+
+/*
+ * rounded_tv2jif - calculate jiffies from timeval including optional up
+ * @tv: pointer to timeval
+ *
+ * Description:
+ * In opposite to timeval_to_jiffies() provided in include/linux/jiffies.h this
+ * function is intentionally more relaxed on precise timer ticks to get exact
+ * one jiffy for requested 1000us on a 1000HZ machine.
+ * This code is to be removed when upgrading to kernel hrtimer.
+ *
+ * Return:
+ *  calculated jiffies (max: ULONG_MAX)
+ */
+static unsigned long rounded_tv2jif(const struct timeval *tv)
+{
+	unsigned long sec  = tv->tv_sec;
+	unsigned long usec = tv->tv_usec;
+	unsigned long jif;
+
+	if (sec > ULONG_MAX / HZ)
+		return ULONG_MAX;
+
+	/* round up to get at least the requested time */
+	usec += 1000000 / HZ - 1;
+
+	jif  = usec / (1000000 / HZ);
+
+	if (sec * HZ > ULONG_MAX - jif)
+		return ULONG_MAX;
+
+	return jif + sec * HZ;
+}
+
+/*
+ * procfs functions
+ */
+static char *bcm_proc_getifname(int ifindex)
+{
+	struct net_device *dev;
+
+	if (!ifindex)
+		return "any";
+
+	dev = __dev_get_by_index(ifindex); /* no usage counting */
+	if (dev)
+		return dev->name;
+
+	return "???";
+}
+
+static int bcm_read_proc(char *page, char **start, off_t off,
+			 int count, int *eof, void *data)
+{
+	int len = 0;
+	struct sock *sk = (struct sock *)data;
+	struct bcm_sock *bo = bcm_sk(sk);
+	struct bcm_op *op;
+
+	len += snprintf(page + len, PAGE_SIZE - len, ">>> socket %p",
+			sk->sk_socket);
+	len += snprintf(page + len, PAGE_SIZE - len, " / sk %p", sk);
+	len += snprintf(page + len, PAGE_SIZE - len, " / bo %p", bo);
+	len += snprintf(page + len, PAGE_SIZE - len, " / dropped %lu",
+			bo->dropped_usr_msgs);
+	len += snprintf(page + len, PAGE_SIZE - len, " / bound %s",
+			bcm_proc_getifname(bo->ifindex));
+	len += snprintf(page + len, PAGE_SIZE - len, " <<<\n");
+
+	list_for_each_entry(op, &bo->rx_ops, list) {
+
+		unsigned long reduction;
+
+		/* print only active entries & prevent division by zero */
+		if (!op->frames_abs)
+			continue;
+
+		len += snprintf(page + len, PAGE_SIZE - len,
+				"rx_op: %03X %-5s ",
+				op->can_id, bcm_proc_getifname(op->ifindex));
+		len += snprintf(page + len, PAGE_SIZE - len, "[%d]%c ",
+				op->nframes,
+				(op->flags & RX_CHECK_DLC)?'d':' ');
+		if (op->j_ival1)
+			len += snprintf(page + len, PAGE_SIZE - len,
+					"timeo=%ld ", op->j_ival1);
+
+		if (op->j_ival2)
+			len += snprintf(page + len, PAGE_SIZE - len,
+					"thr=%ld ", op->j_ival2);
+
+		len += snprintf(page + len, PAGE_SIZE - len,
+				"# recv %ld (%ld) => reduction: ",
+				op->frames_filtered, op->frames_abs);
+
+		reduction = 100 - (op->frames_filtered * 100) / op->frames_abs;
+
+		len += snprintf(page + len, PAGE_SIZE - len, "%s%ld%%\n",
+				(reduction == 100)?"near ":"", reduction);
+
+		if (len > PAGE_SIZE - 200) {
+			/* mark output cut off */
+			len += snprintf(page + len, PAGE_SIZE - len, "(..)\n");
+			break;
+		}
+	}
+
+	list_for_each_entry(op, &bo->tx_ops, list) {
+
+		len += snprintf(page + len, PAGE_SIZE - len,
+				"tx_op: %03X %s [%d] ",
+				op->can_id, bcm_proc_getifname(op->ifindex),
+				op->nframes);
+		if (op->j_ival1)
+			len += snprintf(page + len, PAGE_SIZE - len, "t1=%ld ",
+					op->j_ival1);
+
+		if (op->j_ival2)
+			len += snprintf(page + len, PAGE_SIZE - len, "t2=%ld ",
+					op->j_ival2);
+
+		len += snprintf(page + len, PAGE_SIZE - len, "# sent %ld\n",
+				op->frames_abs);
+
+		if (len > PAGE_SIZE - 100) {
+			/* mark output cut off */
+			len += snprintf(page + len, PAGE_SIZE - len, "(..)\n");
+			break;
+		}
+	}
+
+	len += snprintf(page + len, PAGE_SIZE - len, "\n");
+
+	*eof = 1;
+	return len;
+}
+
+/*
+ * bcm_can_tx - send the (next) CAN frame to the appropriate CAN interface
+ *              of the given bcm tx op
+ */
+static void bcm_can_tx(struct bcm_op *op)
+{
+	struct sk_buff *skb;
+	struct net_device *dev;
+	struct can_frame *cf = &op->frames[op->currframe];
+
+	DBG_FRAME("BCM: bcm_can_tx: sending frame", cf);
+
+	/* no target device? => exit */
+	if (!op->ifindex)
+		return;
+
+	dev = dev_get_by_index(op->ifindex);
+	if (!dev) {
+		/* RFC: should this bcm_op remove itself here? */
+		return;
+	}
+
+	skb = alloc_skb(CFSIZ,
+			in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+
+	if (!skb)
+		goto out;
+
+	memcpy(skb_put(skb, CFSIZ), cf, CFSIZ);
+
+	/* send with loopback */
+	skb->dev = dev;
+	skb->sk = op->sk;
+	can_send(skb, 1);
+
+	/* update statistics */
+	op->currframe++;
+	op->frames_abs++;
+
+	/* reached last frame? */
+	if (op->currframe >= op->nframes)
+		op->currframe = 0;
+ out:
+	dev_put(dev);
+}
+
+/*
+ * bcm_send_to_user - send a BCM message to the userspace
+ *                    (consisting of bcm_msg_head + x CAN frames)
+ */
+static void bcm_send_to_user(struct bcm_op *op, struct bcm_msg_head *head,
+			     struct can_frame *frames, int has_timestamp)
+{
+	struct sk_buff *skb;
+	struct can_frame *firstframe;
+	struct sockaddr_can *addr;
+	struct sock *sk = op->sk;
+	int datalen = head->nframes * CFSIZ;
+	int err;
+
+	skb = alloc_skb(sizeof(*head) + datalen,
+			in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+	if (!skb)
+		return;
+
+	memcpy(skb_put(skb, sizeof(*head)), head, sizeof(*head));
+
+	if (head->nframes) {
+		/* can_frames starting here */
+		firstframe = (struct can_frame *) skb_tail_pointer(skb);
+
+		memcpy(skb_put(skb, datalen), frames, datalen);
+
+		/*
+		 * the BCM uses the can_dlc-element of the can_frame
+		 * structure for internal purposes. This is only
+		 * relevant for updates that are generated by the
+		 * BCM, where nframes is 1
+		 */
+		if (head->nframes == 1)
+			firstframe->can_dlc &= BCM_CAN_DLC_MASK;
+	}
+
+	if (has_timestamp) {
+		/* restore rx timestamp */
+		skb->tstamp = op->rx_stamp;
+	}
+
+	/* restore originator for recvfrom() */
+	addr = (struct sockaddr_can *)skb->cb;
+	memset(addr, 0, sizeof(*addr));
+	addr->can_family  = AF_CAN;
+	addr->can_ifindex = op->rx_ifindex;
+
+	err = sock_queue_rcv_skb(sk, skb);
+	if (err < 0) {
+		struct bcm_sock *bo = bcm_sk(sk);
+
+		DBG("sock_queue_rcv_skb failed: %d\n", err);
+		kfree_skb(skb);
+		/* don't care about overflows in this statistic */
+		bo->dropped_usr_msgs++;
+	}
+}
+
+/*
+ * bcm_tx_timeout_handler - performes cyclic CAN frame transmissions
+ */
+static void bcm_tx_timeout_handler(unsigned long data)
+{
+	struct bcm_op *op = (struct bcm_op *)data;
+
+	DBG("Called with bcm_op %p\n", op);
+
+	if (op->j_ival1 && (op->count > 0)) {
+
+		op->count--;
+		if (!op->count && (op->flags & TX_COUNTEVT)) {
+			struct bcm_msg_head msg_head;
+
+			/* create notification to user */
+			DBG("sending TX_EXPIRED for can_id %03X\n",
+			    op->can_id);
+
+			msg_head.opcode  = TX_EXPIRED;
+			msg_head.flags   = op->flags;
+			msg_head.count   = op->count;
+			msg_head.ival1   = op->ival1;
+			msg_head.ival2   = op->ival2;
+			msg_head.can_id  = op->can_id;
+			msg_head.nframes = 0;
+
+			bcm_send_to_user(op, &msg_head, NULL, 0);
+		}
+	}
+
+	DBG("count=%d j_ival1=%ld j_ival2=%ld\n",
+	    op->count, op->j_ival1, op->j_ival2);
+
+	if (op->j_ival1 && (op->count > 0)) {
+
+		op->timer.expires = jiffies + op->j_ival1;
+		add_timer(&op->timer);
+
+		DBG("adding timer ival1. func=%p data=%p exp=0x%08X\n",
+		    op->timer.function,
+		    (char *) op->timer.data,
+		    (unsigned int) op->timer.expires);
+
+		/* send (next) frame */
+		bcm_can_tx(op);
+
+	} else {
+		if (op->j_ival2) {
+			op->timer.expires = jiffies + op->j_ival2;
+			add_timer(&op->timer);
+
+			DBG("adding timer ival2. func=%p data=%p exp=0x%08X\n",
+			    op->timer.function,
+			    (char *) op->timer.data,
+			    (unsigned int) op->timer.expires);
+
+			/* send (next) frame */
+			bcm_can_tx(op);
+
+		} else
+			DBG("no timer restart\n");
+	}
+
+	return;
+}
+
+/*
+ * bcm_rx_changed - create a RX_CHANGED notification due to changed content
+ */
+static void bcm_rx_changed(struct bcm_op *op, struct can_frame *data)
+{
+	struct bcm_msg_head head;
+
+	op->j_lastmsg = jiffies;
+
+	/* update statistics */
+	op->frames_filtered++;
+
+	/* prevent statistics overflow */
+	if (op->frames_filtered > ULONG_MAX/100)
+		op->frames_filtered = op->frames_abs = 0;
+
+	DBG("setting j_lastmsg to 0x%08X for rx_op %p\n",
+	    (unsigned int) op->j_lastmsg, op);
+	DBG("sending notification\n");
+
+	head.opcode  = RX_CHANGED;
+	head.flags   = op->flags;
+	head.count   = op->count;
+	head.ival1   = op->ival1;
+	head.ival2   = op->ival2;
+	head.can_id  = op->can_id;
+	head.nframes = 1;
+
+	bcm_send_to_user(op, &head, data, 1);
+}
+
+/*
+ * bcm_rx_update_and_send - process a detected relevant receive content change
+ *                          1. update the last received data
+ *                          2. send a notification to the user (if possible)
+ */
+static void bcm_rx_update_and_send(struct bcm_op *op,
+				   struct can_frame *lastdata,
+				   struct can_frame *rxdata)
+{
+	unsigned long nexttx = op->j_lastmsg + op->j_ival2;
+
+	memcpy(lastdata, rxdata, CFSIZ);
+
+	/* mark as used */
+	lastdata->can_dlc |= RX_RECV;
+
+	/* throttle bcm_rx_changed ? */
+	if ((op->thrtimer.expires) ||
+	    ((op->j_ival2) && (nexttx > jiffies))) {
+		/* we are already waiting OR we have to start waiting */
+
+		/* mark as 'throttled' */
+		lastdata->can_dlc |= RX_THR;
+
+		if (!(op->thrtimer.expires)) {
+			/* start the timer only the first time */
+			op->thrtimer.expires = nexttx;
+			add_timer(&op->thrtimer);
+
+			DBG("adding thrtimer. func=%p data=%p exp=0x%08X\n",
+			    op->thrtimer.function,
+			    (char *) op->thrtimer.data,
+			    (unsigned int) op->thrtimer.expires);
+		}
+
+	} else {
+		/* send RX_CHANGED to the user immediately */
+		bcm_rx_changed(op, rxdata);
+	}
+}
+
+/*
+ * bcm_rx_cmp_to_index - (bit)compares the currently received data to formerly
+ *                       received data stored in op->last_frames[]
+ */
+static void bcm_rx_cmp_to_index(struct bcm_op *op, int index,
+				struct can_frame *rxdata)
+{
+	/*
+	 * no one uses the MSBs of can_dlc for comparation,
+	 * so we use it here to detect the first time of reception
+	 */
+
+	if (!(op->last_frames[index].can_dlc & RX_RECV)) {
+		/* received data for the first time => send update to user */
+		DBG("first time :)\n");
+		bcm_rx_update_and_send(op, &op->last_frames[index], rxdata);
+		return;
+	}
+
+	/* do a real check in can_frame data section */
+
+	DBG("op->frames[index].data = 0x%016llx\n",
+	    GET_U64(&op->frames[index]));
+	DBG("op->last_frames[index].data = 0x%016llx\n",
+	    GET_U64(&op->last_frames[index]));
+	DBG("rxdata->data = 0x%016llx\n", GET_U64(rxdata));
+
+	if ((GET_U64(&op->frames[index]) & GET_U64(rxdata)) !=
+	    (GET_U64(&op->frames[index]) & GET_U64(&op->last_frames[index]))) {
+		DBG("relevant data change :)\n");
+		bcm_rx_update_and_send(op, &op->last_frames[index], rxdata);
+		return;
+	}
+
+	if (op->flags & RX_CHECK_DLC) {
+		/* do a real check in can_frame dlc */
+		if (rxdata->can_dlc != (op->last_frames[index].can_dlc &
+					BCM_CAN_DLC_MASK)) {
+			DBG("dlc change :)\n");
+			bcm_rx_update_and_send(op, &op->last_frames[index],
+					       rxdata);
+			return;
+		}
+	}
+	DBG("no relevant change :(\n");
+}
+
+/*
+ * bcm_rx_starttimer - enable timeout monitoring for CAN frame receiption
+ */
+static void bcm_rx_starttimer(struct bcm_op *op)
+{
+	if (op->flags & RX_NO_AUTOTIMER)
+		return;
+
+	if (op->j_ival1) {
+		op->timer.expires = jiffies + op->j_ival1;
+
+		DBG("adding rx timeout timer ival1. func=%p data=%p "
+		    "exp=0x%08X\n",
+		    op->timer.function,
+		    (char *) op->timer.data,
+		    (unsigned int) op->timer.expires);
+
+		add_timer(&op->timer);
+	}
+}
+
+/*
+ * bcm_rx_timeout_handler - when the (cyclic) CAN frame receiption timed out
+ */
+static void bcm_rx_timeout_handler(unsigned long data)
+{
+	struct bcm_op *op = (struct bcm_op *)data;
+	struct bcm_msg_head msg_head;
+
+	DBG("sending RX_TIMEOUT for can_id %03X. op is %p\n", op->can_id, op);
+
+	msg_head.opcode  = RX_TIMEOUT;
+	msg_head.flags   = op->flags;
+	msg_head.count   = op->count;
+	msg_head.ival1   = op->ival1;
+	msg_head.ival2   = op->ival2;
+	msg_head.can_id  = op->can_id;
+	msg_head.nframes = 0;
+
+	bcm_send_to_user(op, &msg_head, NULL, 0);
+
+	/* no restart of the timer is done here! */
+
+	/* if user wants to be informed, when cyclic CAN-Messages come back */
+	if ((op->flags & RX_ANNOUNCE_RESUME) && op->last_frames) {
+		/* clear received can_frames to indicate 'nothing received' */
+		memset(op->last_frames, 0, op->nframes * CFSIZ);
+		DBG("RX_ANNOUNCE_RESTART\n");
+	}
+}
+
+/*
+ * bcm_rx_thr_handler - the time for blocked content updates is over now:
+ *                      Check for throttled data and send it to the userspace
+ */
+static void bcm_rx_thr_handler(unsigned long data)
+{
+	struct bcm_op *op = (struct bcm_op *)data;
+	int i = 0;
+
+	/* mark disabled / consumed timer */
+	op->thrtimer.expires = 0;
+
+	if (op->nframes > 1) {
+		DBG("sending MUX RX_CHANGED for can_id %03X. op is %p\n",
+		    op->can_id, op);
+		/* for MUX filter we start at index 1 */
+		for (i = 1; i < op->nframes; i++) {
+			if ((op->last_frames) &&
+			    (op->last_frames[i].can_dlc & RX_THR)) {
+				op->last_frames[i].can_dlc &= ~RX_THR;
+				bcm_rx_changed(op, &op->last_frames[i]);
+			}
+		}
+
+	} else {
+		DBG("sending simple RX_CHANGED for can_id %03X. op is %p\n",
+		    op->can_id, op);
+		/* for RX_FILTER_ID and simple filter */
+		if (op->last_frames && (op->last_frames[0].can_dlc & RX_THR)) {
+			op->last_frames[0].can_dlc &= ~RX_THR;
+			bcm_rx_changed(op, &op->last_frames[0]);
+		}
+	}
+}
+
+/*
+ * bcm_rx_handler - handle a CAN frame receiption
+ */
+static void bcm_rx_handler(struct sk_buff *skb, void *data)
+{
+	struct bcm_op *op = (struct bcm_op *)data;
+	struct can_frame rxframe;
+	int i;
+
+	/* disable timeout */
+	del_timer(&op->timer);
+
+	DBG("Called with bcm_op %p\n", op);
+
+	if (skb->len == sizeof(rxframe)) {
+		memcpy(&rxframe, skb->data, sizeof(rxframe));
+		/* save rx timestamp */
+		op->rx_stamp = skb->tstamp;
+		/* save originator for recvfrom() */
+		op->rx_ifindex = skb->dev->ifindex;
+		/* update statistics */
+		op->frames_abs++;
+		kfree_skb(skb);
+		DBG("got can_frame with can_id %03X\n", rxframe.can_id);
+
+	} else {
+		DBG("Wrong skb->len = %d\n", skb->len);
+		kfree_skb(skb);
+		return;
+	}
+
+	DBG_FRAME("BCM: bcm_rx_handler: CAN frame", &rxframe);
+
+	if (op->can_id != rxframe.can_id) {
+		DBG("ERROR! Got wrong can_id %03X! Expected %03X.\n",
+		    rxframe.can_id, op->can_id);
+		return;
+	}
+
+	if (op->flags & RX_RTR_FRAME) {
+		/* send reply for RTR-request */
+		DBG("RTR-request\n");
+
+		/* send op->frames[0] to CAN device */
+		bcm_can_tx(op);
+		return;
+	}
+
+	if (op->flags & RX_FILTER_ID) {
+		/* the easiest case */
+		DBG("Easy does it with RX_FILTER_ID\n");
+
+		bcm_rx_update_and_send(op, &op->last_frames[0], &rxframe);
+		bcm_rx_starttimer(op);
+		return;
+	}
+
+	if (op->nframes == 1) {
+		/* simple compare with index 0 */
+		DBG("Simple compare\n");
+
+		bcm_rx_cmp_to_index(op, 0, &rxframe);
+		bcm_rx_starttimer(op);
+		return;
+	}
+
+	if (op->nframes > 1) {
+		/* multiplex compare */
+		DBG("Multiplex compare\n");
+
+		/*
+		 * find the first multiplex mask that fits.
+		 * Remark: The MUX-mask is stored in index 0
+		 */
+
+		for (i = 1; i < op->nframes; i++) {
+			if ((GET_U64(&op->frames[0]) & GET_U64(&rxframe)) ==
+			    (GET_U64(&op->frames[0]) &
+			     GET_U64(&op->frames[i]))) {
+				DBG("found MUX index %d\n", i);
+				bcm_rx_cmp_to_index(op, i, &rxframe);
+				break;
+			}
+		}
+		bcm_rx_starttimer(op);
+	}
+}
+
+/*
+ * helpers for bcm_op handling: find & delete bcm [rx|tx] op elements
+ */
+static struct bcm_op *bcm_find_op(struct list_head *ops, canid_t can_id,
+				  int ifindex)
+{
+	struct bcm_op *op;
+
+	list_for_each_entry(op, ops, list) {
+		if ((op->can_id == can_id) && (op->ifindex == ifindex))
+			return op;
+	}
+
+	return NULL;
+}
+
+static void bcm_remove_op(struct bcm_op *op)
+{
+	del_timer(&op->timer);
+	del_timer(&op->thrtimer);
+
+	if ((op->frames) && (op->frames != &op->sframe))
+		kfree(op->frames);
+
+	if ((op->last_frames) && (op->last_frames != &op->last_sframe))
+		kfree(op->last_frames);
+
+	kfree(op);
+
+	return;
+}
+
+static void bcm_rx_unreg(struct net_device *dev, struct bcm_op *op)
+{
+	if (op->rx_reg_dev == dev) {
+		can_rx_unregister(dev, op->can_id, REGMASK(op->can_id),
+				  bcm_rx_handler, op);
+
+		/* mark as removed subscription */
+		op->rx_reg_dev = NULL;
+	} else
+		printk(KERN_ERR "can-bcm: bcm_rx_unreg: registered device "
+		       "mismatch %p %p\n", op->rx_reg_dev, dev);
+}
+
+/*
+ * bcm_delete_rx_op - find and remove a rx op (returns number of removed ops)
+ */
+static int bcm_delete_rx_op(struct list_head *ops, canid_t can_id, int ifindex)
+{
+	struct bcm_op *op, *n;
+
+	list_for_each_entry_safe(op, n, ops, list) {
+		if ((op->can_id == can_id) && (op->ifindex == ifindex)) {
+			DBG("removing rx_op %p for can_id %03X\n",
+			    op, op->can_id);
+
+			/*
+			 * Don't care if we're bound or not (due to netdev
+			 * problems) can_rx_unregister() is always a save
+			 * thing to do here.
+			 */
+			if (op->ifindex) {
+				/*
+				 * Only remove subscriptions that had not
+				 * been removed due to NETDEV_UNREGISTER
+				 * in bcm_notifier()
+				 */
+				if (op->rx_reg_dev) {
+					struct net_device *dev;
+
+					dev = dev_get_by_index(op->ifindex);
+					if (dev) {
+						bcm_rx_unreg(dev, op);
+						dev_put(dev);
+					}
+				}
+			} else
+				can_rx_unregister(NULL, op->can_id,
+						  REGMASK(op->can_id),
+						  bcm_rx_handler, op);
+
+			list_del(&op->list);
+			bcm_remove_op(op);
+			return 1; /* done */
+		}
+	}
+
+	return 0; /* not found */
+}
+
+/*
+ * bcm_delete_tx_op - find and remove a tx op (returns number of removed ops)
+ */
+static int bcm_delete_tx_op(struct list_head *ops, canid_t can_id, int ifindex)
+{
+	struct bcm_op *op, *n;
+
+	list_for_each_entry_safe(op, n, ops, list) {
+		if ((op->can_id == can_id) && (op->ifindex == ifindex)) {
+			DBG("removing rx_op %p for can_id %03X\n",
+			    op, op->can_id);
+			list_del(&op->list);
+			bcm_remove_op(op);
+			return 1; /* done */
+		}
+	}
+
+	return 0; /* not found */
+}
+
+/*
+ * bcm_read_op - read out a bcm_op and send it to the user (for bcm_sendmsg)
+ */
+static int bcm_read_op(struct list_head *ops, struct bcm_msg_head *msg_head,
+		       int ifindex)
+{
+	struct bcm_op *op = bcm_find_op(ops, msg_head->can_id, ifindex);
+
+	if (!op) {
+		DBG("TRX_READ: did not find op for can_id %03X\n",
+		    msg_head->can_id);
+		return -EINVAL;
+	}
+
+	DBG("TRX_READ: sending status for can_id %03X\n",
+	    msg_head->can_id);
+	/* put current values into msg_head */
+	msg_head->flags   = op->flags;
+	msg_head->count   = op->count;
+	msg_head->ival1   = op->ival1;
+	msg_head->ival2   = op->ival2;
+	msg_head->nframes = op->nframes;
+
+	bcm_send_to_user(op, msg_head, op->frames, 0);
+
+	return MHSIZ;
+}
+
+/*
+ * bcm_tx_setup - create or update a bcm tx op (for bcm_sendmsg)
+ */
+static int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
+			int ifindex, struct sock *sk)
+{
+	struct bcm_sock *bo = bcm_sk(sk);
+	struct bcm_op *op;
+	int i, err;
+
+	/* we need a real device to send frames */
+	if (!ifindex)
+		return -ENODEV;
+
+	/* we need at least one can_frame */
+	if (msg_head->nframes < 1)
+		return -EINVAL;
+
+	/* check the given can_id */
+	op = bcm_find_op(&bo->tx_ops, msg_head->can_id, ifindex);
+
+	if (op) {
+		/* update existing BCM operation */
+
+		DBG("TX_SETUP: modifying existing tx_op %p for can_id %03X\n",
+		    op, msg_head->can_id);
+
+		/*
+		 * Do we need more space for the can_frames than currently
+		 * allocated? -> This is a _really_ unusual use-case and
+		 * therefore (complexity / locking) it is not supported.
+		 */
+		if (msg_head->nframes > op->nframes)
+			return -E2BIG;
+
+		/* update can_frames content */
+		for (i = 0; i < msg_head->nframes; i++) {
+			err = memcpy_fromiovec((u8 *)&op->frames[i],
+					       msg->msg_iov, CFSIZ);
+			if (err < 0)
+				return err;
+
+			if (msg_head->flags & TX_CP_CAN_ID) {
+				/* copy can_id into frame */
+				op->frames[i].can_id = msg_head->can_id;
+			}
+		}
+
+	} else {
+		/* insert new BCM operation for the given can_id */
+
+		op = kzalloc(OPSIZ, GFP_KERNEL);
+		if (!op)
+			return -ENOMEM;
+
+		DBG("TX_SETUP: creating new tx_op %p for can_id %03X\n",
+		    op, msg_head->can_id);
+
+		op->can_id    = msg_head->can_id;
+
+		/* create array for can_frames and copy the data */
+		if (msg_head->nframes > 1) {
+			op->frames = kmalloc(msg_head->nframes * CFSIZ,
+					     GFP_KERNEL);
+			if (!op->frames) {
+				kfree(op);
+				return -ENOMEM;
+			}
+		} else
+			op->frames = &op->sframe;
+
+		for (i = 0; i < msg_head->nframes; i++) {
+			err = memcpy_fromiovec((u8 *)&op->frames[i],
+					       msg->msg_iov, CFSIZ);
+			if (err < 0) {
+				if (op->frames != &op->sframe)
+					kfree(op->frames);
+				kfree(op);
+				return err;
+			}
+
+			if (msg_head->flags & TX_CP_CAN_ID) {
+				/* copy can_id into frame */
+				op->frames[i].can_id = msg_head->can_id;
+			}
+		}
+
+		/* tx_ops never compare with previous received messages */
+		op->last_frames = NULL;
+
+		/* bcm_can_tx / bcm_tx_timeout_handler needs this */
+		op->sk = sk;
+
+		op->ifindex = ifindex;
+
+		/* initialize uninitialized (kmalloc) structure */
+		init_timer(&op->timer);
+
+		/* currently unused in tx_ops */
+		init_timer(&op->thrtimer);
+
+		/* handler for tx_ops */
+		op->timer.function = bcm_tx_timeout_handler;
+
+		/* timer.data points to this op-structure */
+		op->timer.data = (unsigned long)op;
+
+		/* add this bcm_op to the list of the tx_ops */
+		list_add(&op->list, &bo->tx_ops);
+
+	} /* if ((op = bcm_find_op(&bo->tx_ops, msg_head->can_id, ifindex))) */
+
+	if (op->nframes != msg_head->nframes) {
+		op->nframes   = msg_head->nframes;
+		/* start multiple frame transmission with index 0 */
+		op->currframe = 0;
+	}
+
+	/* check flags */
+
+	op->flags = msg_head->flags;
+
+	if (op->flags & TX_RESET_MULTI_IDX) {
+		/* start multiple frame transmission with index 0 */
+		op->currframe = 0;
+	}
+
+	if (op->flags & SETTIMER) {
+		/* set timer values */
+
+		op->count = msg_head->count;
+		op->ival1 = msg_head->ival1;
+		op->ival2 = msg_head->ival2;
+		op->j_ival1 = rounded_tv2jif(&msg_head->ival1);
+		op->j_ival2 = rounded_tv2jif(&msg_head->ival2);
+
+		DBG("TX_SETUP: SETTIMER count=%d j_ival1=%ld j_ival2=%ld\n",
+		    op->count, op->j_ival1, op->j_ival2);
+
+		/* disable an active timer due to zero values? */
+		if (!op->j_ival1 && !op->j_ival2) {
+			del_timer(&op->timer);
+			DBG("TX_SETUP: SETTIMER disabled timer.\n");
+		}
+	}
+
+	if ((op->flags & STARTTIMER) &&
+	    ((op->j_ival1 && op->count) || op->j_ival2)) {
+
+		del_timer(&op->timer);
+
+		/* spec: send can_frame when starting timer */
+		op->flags |= TX_ANNOUNCE;
+
+		if (op->j_ival1 && (op->count > 0)) {
+			op->timer.expires = jiffies + op->j_ival1;
+			/* op->count-- is done in bcm_tx_timeout_handler */
+			DBG("TX_SETUP: adding timer ival1. func=%p data=%p "
+			    "exp=0x%08X\n",
+			    op->timer.function,
+			    (char *) op->timer.data,
+			    (unsigned int) op->timer.expires);
+
+		} else {
+			op->timer.expires = jiffies + op->j_ival2;
+			DBG("TX_SETUP: adding timer ival2. func=%p data=%p "
+			    "exp=0x%08X\n",
+			    op->timer.function,
+			    (char *) op->timer.data,
+			    (unsigned int) op->timer.expires);
+		}
+
+		add_timer(&op->timer);
+	}
+
+	if (op->flags & TX_ANNOUNCE)
+		bcm_can_tx(op);
+
+	return msg_head->nframes * CFSIZ + MHSIZ;
+}
+
+/*
+ * bcm_rx_setup - create or update a bcm rx op (for bcm_sendmsg)
+ */
+static int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
+			int ifindex, struct sock *sk)
+{
+	struct bcm_sock *bo = bcm_sk(sk);
+	struct bcm_op *op;
+	int do_rx_register;
+	int err;
+
+	if ((msg_head->flags & RX_FILTER_ID) || (!(msg_head->nframes))) {
+		/* be robust against wrong usage ... */
+		msg_head->flags |= RX_FILTER_ID;
+		msg_head->nframes = 0; /* ignore trailing garbage */
+	}
+
+	if ((msg_head->flags & RX_RTR_FRAME) &&
+	    ((msg_head->nframes != 1) ||
+	     (!(msg_head->can_id & CAN_RTR_FLAG)))) {
+
+		DBG("RX_SETUP: bad RX_RTR_FRAME setup!\n");
+		return -EINVAL;
+	}
+
+	/* check the given can_id */
+	op = bcm_find_op(&bo->rx_ops, msg_head->can_id, ifindex);
+	if (op) {
+		/* update existing BCM operation */
+
+		DBG("RX_SETUP: modifying existing rx_op %p for can_id %03X\n",
+		    op, msg_head->can_id);
+
+		/*
+		 * Do we need more space for the can_frames than currently
+		 * allocated? -> This is a _really_ unusual use-case and
+		 * therefore (complexity / locking) it is not supported.
+		 */
+		if (msg_head->nframes > op->nframes)
+			return -E2BIG;
+
+		if (msg_head->nframes) {
+			/* update can_frames content */
+			err = memcpy_fromiovec((u8 *)op->frames,
+					       msg->msg_iov,
+					       msg_head->nframes * CFSIZ);
+			if (err < 0)
+				return err;
+
+			/* clear last_frames to indicate 'nothing received' */
+			memset(op->last_frames, 0, msg_head->nframes * CFSIZ);
+		}
+
+		op->nframes = msg_head->nframes;
+
+		/* Only an update -> do not call can_rx_register() */
+		do_rx_register = 0;
+
+	} else {
+		/* insert new BCM operation for the given can_id */
+
+		op = kzalloc(OPSIZ, GFP_KERNEL);
+		if (!op)
+			return -ENOMEM;
+
+		DBG("RX_SETUP: creating new rx_op %p for can_id %03X\n",
+		    op, msg_head->can_id);
+
+		op->can_id    = msg_head->can_id;
+		op->nframes   = msg_head->nframes;
+
+		if (msg_head->nframes > 1) {
+			/* create array for can_frames and copy the data */
+			op->frames = kmalloc(msg_head->nframes * CFSIZ,
+					     GFP_KERNEL);
+			if (!op->frames) {
+				kfree(op);
+				return -ENOMEM;
+			}
+
+			/* create and init array for received can_frames */
+			op->last_frames = kzalloc(msg_head->nframes * CFSIZ,
+						  GFP_KERNEL);
+			if (!op->last_frames) {
+				kfree(op->frames);
+				kfree(op);
+				return -ENOMEM;
+			}
+
+		} else {
+			op->frames = &op->sframe;
+			op->last_frames = &op->last_sframe;
+		}
+
+		if (msg_head->nframes) {
+			err = memcpy_fromiovec((u8 *)op->frames, msg->msg_iov,
+					       msg_head->nframes * CFSIZ);
+			if (err < 0) {
+				if (op->frames != &op->sframe)
+					kfree(op->frames);
+				if (op->last_frames != &op->last_sframe)
+					kfree(op->last_frames);
+				kfree(op);
+				return err;
+			}
+		}
+
+		op->sk = sk;
+		op->ifindex = ifindex;
+
+		/* initialize uninitialized (kzalloc) structure */
+		init_timer(&op->timer);
+
+		/* init throttle timer for RX_CHANGED */
+		init_timer(&op->thrtimer);
+
+		/* handler for rx timeouts */
+		op->timer.function = bcm_rx_timeout_handler;
+
+		/* timer.data points to this op-structure */
+		op->timer.data = (unsigned long)op;
+
+		/* handler for RX_CHANGED throttle timeouts */
+		op->thrtimer.function = bcm_rx_thr_handler;
+
+		/* timer.data points to this op-structure */
+		op->thrtimer.data = (unsigned long)op;
+
+		/* mark disabled timer */
+		op->thrtimer.expires = 0;
+
+		/* add this bcm_op to the list of the tx_ops */
+		list_add(&op->list, &bo->rx_ops);
+
+		/* call can_rx_register() */
+		do_rx_register = 1;
+
+	} /* if ((op = bcm_find_op(&bo->rx_ops, msg_head->can_id, ifindex))) */
+
+	/* check flags */
+	op->flags = msg_head->flags;
+
+	if (op->flags & RX_RTR_FRAME) {
+
+		/* no timers in RTR-mode */
+		del_timer(&op->thrtimer);
+		del_timer(&op->timer);
+
+		/*
+		 * funny feature in RX(!)_SETUP only for RTR-mode:
+		 * copy can_id into frame BUT without RTR-flag to
+		 * prevent a full-load-loopback-test ... ;-]
+		 */
+		if ((op->flags & TX_CP_CAN_ID) ||
+		    (op->frames[0].can_id == op->can_id))
+			op->frames[0].can_id = op->can_id & ~CAN_RTR_FLAG;
+
+	} else {
+		if (op->flags & SETTIMER) {
+
+			/* set timer value */
+			op->ival1 = msg_head->ival1;
+			op->ival2 = msg_head->ival2;
+			op->j_ival1 = rounded_tv2jif(&msg_head->ival1);
+			op->j_ival2 = rounded_tv2jif(&msg_head->ival2);
+
+			DBG("RX_SETUP: SETTIMER j_ival1=%ld j_ival2=%ld\n",
+			    op->j_ival1, op->j_ival2);
+
+			/* disable an active timer due to zero value? */
+			if (!op->j_ival1) {
+				del_timer(&op->timer);
+				DBG("RX_SETUP: disabled timer rx timeouts.\n");
+			}
+
+			/* free currently blocked msgs ? */
+			if (op->thrtimer.expires) {
+				DBG("RX_SETUP: unblocking throttled msgs.\n");
+				del_timer(&op->thrtimer);
+				/* send blocked msgs hereafter */
+				op->thrtimer.expires = jiffies + 2;
+				add_timer(&op->thrtimer);
+			}
+			/*
+			 * if (op->j_ival2) is zero, no (new) throttling
+			 * will happen. For details see functions
+			 * bcm_rx_update_and_send() and bcm_rx_thr_handler()
+			 */
+		}
+
+		if ((op->flags & STARTTIMER) && op->j_ival1) {
+
+			del_timer(&op->timer);
+			op->timer.expires = jiffies + op->j_ival1;
+
+			DBG("RX_SETUP: adding timer ival1. func=%p data=%p"
+			    " exp=0x%08X\n",
+			    (char *) op->timer.function,
+			    (char *) op->timer.data,
+			    (unsigned int) op->timer.expires);
+
+			add_timer(&op->timer);
+		}
+	}
+
+	/* now we can register for can_ids, if we added a new bcm_op */
+	if (do_rx_register) {
+		DBG("RX_SETUP: can_rx_register() for can_id %03X. "
+		    "rx_op is %p\n", op->can_id, op);
+
+		if (ifindex) {
+			struct net_device *dev;
+
+			dev = dev_get_by_index(ifindex);
+			if (dev) {
+				can_rx_register(dev, op->can_id,
+						REGMASK(op->can_id),
+						bcm_rx_handler, op, IDENT);
+				op->rx_reg_dev = dev;
+				dev_put(dev);
+			}
+
+		} else
+			can_rx_register(NULL, op->can_id, REGMASK(op->can_id),
+					bcm_rx_handler, op, IDENT);
+	}
+
+	return msg_head->nframes * CFSIZ + MHSIZ;
+}
+
+/*
+ * bcm_tx_send - send a single CAN frame to the CAN interface (for bcm_sendmsg)
+ */
+static int bcm_tx_send(struct msghdr *msg, int ifindex, struct sock *sk)
+{
+	struct sk_buff *skb;
+	struct net_device *dev;
+	int err;
+
+	/* just copy and send one can_frame */
+
+	if (!ifindex) /* we need a real device to send frames */
+		return -ENODEV;
+
+	skb = alloc_skb(CFSIZ, GFP_KERNEL);
+
+	if (!skb)
+		return -ENOMEM;
+
+	err = memcpy_fromiovec(skb_put(skb, CFSIZ), msg->msg_iov, CFSIZ);
+	if (err < 0) {
+		kfree_skb(skb);
+		return err;
+	}
+
+	DBG_FRAME("BCM: TX_SEND: sending frame",
+		  (struct can_frame *)skb->data);
+
+	dev = dev_get_by_index(ifindex);
+	if (!dev) {
+		kfree_skb(skb);
+		return -ENODEV;
+	}
+
+	skb->dev = dev;
+	skb->sk  = sk;
+	can_send(skb, 1); /* send with loopback */
+	dev_put(dev);
+
+	return CFSIZ + MHSIZ;
+}
+
+/*
+ * bcm_sendmsg - process BCM commands (opcodes) from the userspace
+ */
+static int bcm_sendmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct bcm_sock *bo = bcm_sk(sk);
+	int ifindex = bo->ifindex; /* default ifindex for this bcm_op */
+	struct bcm_msg_head msg_head;
+	int ret; /* read bytes or error codes as return value */
+
+	if (!bo->bound) {
+		DBG("sock %p not bound\n", sk);
+		return -ENOTCONN;
+	}
+
+	/* check for alternative ifindex for this bcm_op */
+
+	if (!ifindex && msg->msg_name) {
+		/* no bound device as default => check msg_name */
+		struct sockaddr_can *addr =
+			(struct sockaddr_can *)msg->msg_name;
+
+		if (addr->can_family != AF_CAN)
+			return -EINVAL;
+
+		ifindex = addr->can_ifindex; /* ifindex from sendto() */
+
+		if (ifindex) {
+			struct net_device *dev;
+
+			dev = dev_get_by_index(ifindex);
+			if (!dev) {
+				DBG("device %d not found\n", ifindex);
+				return -ENODEV;
+			}
+
+			if (dev->type != ARPHRD_CAN) {
+				DBG("device %d no CAN device\n", ifindex);
+				dev_put(dev);
+				return -ENODEV;
+			}
+
+			dev_put(dev);
+		}
+	}
+
+	/* read message head information */
+
+	ret = memcpy_fromiovec((u8 *)&msg_head, msg->msg_iov, MHSIZ);
+	if (ret < 0)
+		return ret;
+
+	DBG("opcode %d for can_id %03X\n", msg_head.opcode, msg_head.can_id);
+
+	lock_sock(sk);
+
+	switch (msg_head.opcode) {
+
+	case TX_SETUP:
+		ret = bcm_tx_setup(&msg_head, msg, ifindex, sk);
+		break;
+
+	case RX_SETUP:
+		ret = bcm_rx_setup(&msg_head, msg, ifindex, sk);
+		break;
+
+	case TX_DELETE:
+		if (bcm_delete_tx_op(&bo->tx_ops, msg_head.can_id, ifindex))
+			ret = MHSIZ;
+		else
+			ret = -EINVAL;
+		break;
+
+	case RX_DELETE:
+		if (bcm_delete_rx_op(&bo->rx_ops, msg_head.can_id, ifindex))
+			ret = MHSIZ;
+		else
+			ret = -EINVAL;
+		break;
+
+	case TX_READ:
+		/* reuse msg_head for the reply to TX_READ */
+		msg_head.opcode  = TX_STATUS;
+		ret = bcm_read_op(&bo->tx_ops, &msg_head, ifindex);
+		break;
+
+	case RX_READ:
+		/* reuse msg_head for the reply to RX_READ */
+		msg_head.opcode  = RX_STATUS;
+		ret = bcm_read_op(&bo->rx_ops, &msg_head, ifindex);
+		break;
+
+	case TX_SEND:
+		/* we need at least one can_frame */
+		if (msg_head.nframes < 1)
+			ret = -EINVAL;
+		else
+			ret = bcm_tx_send(msg, ifindex, sk);
+		break;
+
+	default:
+		DBG("Unknown opcode %d\n", msg_head.opcode);
+		ret = -EINVAL;
+		break;
+	}
+
+	release_sock(sk);
+
+	return ret;
+}
+
+/*
+ * notification handler for netdevice status changes
+ */
+static int bcm_notifier(struct notifier_block *nb, unsigned long msg,
+			void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct bcm_sock *bo = container_of(nb, struct bcm_sock, notifier);
+	struct sock *sk = &bo->sk;
+	struct bcm_op *op;
+	int notify_enodev = 0;
+
+	DBG("msg %ld for dev %p (%s idx %d) sk %p bo->ifindex %d\n",
+	    msg, dev, dev->name, dev->ifindex, sk, bo->ifindex);
+
+	if (dev->type != ARPHRD_CAN)
+		return NOTIFY_DONE;
+
+	switch (msg) {
+
+	case NETDEV_UNREGISTER:
+		lock_sock(sk);
+
+		/* remove device specific receive entries */
+		list_for_each_entry(op, &bo->rx_ops, list)
+			if (op->rx_reg_dev == dev)
+				bcm_rx_unreg(dev, op);
+
+		/* remove device reference, if this is our bound device */
+		if (bo->bound && bo->ifindex == dev->ifindex) {
+			bo->bound   = 0;
+			bo->ifindex = 0;
+			notify_enodev = 1;
+		}
+
+		release_sock(sk);
+
+		if (notify_enodev) {
+			sk->sk_err = ENODEV;
+			if (!sock_flag(sk, SOCK_DEAD))
+				sk->sk_error_report(sk);
+		}
+		break;
+
+	case NETDEV_DOWN:
+		if (bo->bound && bo->ifindex == dev->ifindex) {
+			sk->sk_err = ENETDOWN;
+			if (!sock_flag(sk, SOCK_DEAD))
+				sk->sk_error_report(sk);
+		}
+	}
+
+	return NOTIFY_DONE;
+}
+
+/*
+ * initial settings for all BCM sockets to be set at socket creation time
+ */
+static int bcm_init(struct sock *sk)
+{
+	struct bcm_sock *bo = bcm_sk(sk);
+
+	bo->bound            = 0;
+	bo->ifindex          = 0;
+	bo->dropped_usr_msgs = 0;
+	bo->bcm_proc_read    = NULL;
+
+	INIT_LIST_HEAD(&bo->tx_ops);
+	INIT_LIST_HEAD(&bo->rx_ops);
+
+	/* set notifier */
+	bo->notifier.notifier_call = bcm_notifier;
+
+	register_netdevice_notifier(&bo->notifier);
+
+	return 0;
+}
+
+/*
+ * standard socket functions
+ */
+static int bcm_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct bcm_sock *bo = bcm_sk(sk);
+	struct bcm_op *op, *next;
+
+	DBG("socket %p, sk %p\n", sock, sk);
+
+	/* remove bcm_ops, timer, rx_unregister(), etc. */
+
+	unregister_netdevice_notifier(&bo->notifier);
+
+	lock_sock(sk);
+
+	list_for_each_entry_safe(op, next, &bo->tx_ops, list) {
+		DBG("removing tx_op %p for can_id %03X\n", op, op->can_id);
+		bcm_remove_op(op);
+	}
+
+	list_for_each_entry_safe(op, next, &bo->rx_ops, list) {
+		DBG("removing rx_op %p for can_id %03X\n", op, op->can_id);
+
+		/*
+		 * Don't care if we're bound or not (due to netdev problems)
+		 * can_rx_unregister() is always a save thing to do here.
+		 */
+		if (op->ifindex) {
+			/*
+			 * Only remove subscriptions that had not
+			 * been removed due to NETDEV_UNREGISTER
+			 * in bcm_notifier()
+			 */
+			if (op->rx_reg_dev) {
+				struct net_device *dev;
+
+				dev = dev_get_by_index(op->ifindex);
+				if (dev) {
+					bcm_rx_unreg(dev, op);
+					dev_put(dev);
+				}
+			}
+		} else
+			can_rx_unregister(NULL, op->can_id,
+					  REGMASK(op->can_id),
+					  bcm_rx_handler, op);
+
+		bcm_remove_op(op);
+	}
+
+	/* remove procfs entry */
+	if (proc_dir && bo->bcm_proc_read)
+		remove_proc_entry(bo->procname, proc_dir);
+
+	/* remove device reference */
+	if (bo->bound) {
+		bo->bound   = 0;
+		bo->ifindex = 0;
+	}
+
+	release_sock(sk);
+	sock_put(sk);
+
+	return 0;
+}
+
+static int bcm_connect(struct socket *sock, struct sockaddr *uaddr, int len,
+		       int flags)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct sock *sk = sock->sk;
+	struct bcm_sock *bo = bcm_sk(sk);
+
+	if (bo->bound)
+		return -EISCONN;
+
+	/* bind a device to this socket */
+	if (addr->can_ifindex) {
+		struct net_device *dev;
+
+		dev = dev_get_by_index(addr->can_ifindex);
+		if (!dev) {
+			DBG("could not find device index %d\n",
+			    addr->can_ifindex);
+			return -ENODEV;
+		}
+
+		if (dev->type != ARPHRD_CAN) {
+			DBG("device %d no CAN device\n", addr->can_ifindex);
+			dev_put(dev);
+			return -ENODEV;
+		}
+
+		bo->ifindex = dev->ifindex;
+		dev_put(dev);
+
+		DBG("socket %p bound to device %s (idx %d)\n",
+		    sock, dev->name, dev->ifindex);
+
+	} else {
+		/* no interface reference for ifindex = 0 ('any' CAN device) */
+		bo->ifindex = 0;
+	}
+
+	bo->bound = 1;
+
+	if (proc_dir) {
+		/* unique socket address as filename */
+		sprintf(bo->procname, "%p", sock);
+		bo->bcm_proc_read = create_proc_read_entry(bo->procname, 0644,
+							   proc_dir,
+							   bcm_read_proc, sk);
+	}
+
+	return 0;
+}
+
+static int bcm_recvmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct sk_buff *skb;
+	int error = 0;
+	int noblock;
+	int err;
+
+	DBG("socket %p, sk %p\n", sock, sk);
+
+	noblock =  flags & MSG_DONTWAIT;
+	flags   &= ~MSG_DONTWAIT;
+	skb = skb_recv_datagram(sk, flags, noblock, &error);
+	if (!skb)
+		return error;
+
+	DBG("delivering skbuff %p\n", skb);
+	DBG_SKB(skb);
+
+	if (skb->len < size)
+		size = skb->len;
+
+	err = memcpy_toiovec(msg->msg_iov, skb->data, size);
+	if (err < 0) {
+		skb_free_datagram(sk, skb);
+		return err;
+	}
+
+	sock_recv_timestamp(msg, sk, skb);
+
+	if (msg->msg_name) {
+		msg->msg_namelen = sizeof(struct sockaddr_can);
+		memcpy(msg->msg_name, skb->cb, msg->msg_namelen);
+	}
+
+	DBG("freeing sock %p, skbuff %p\n", sk, skb);
+	skb_free_datagram(sk, skb);
+
+	return size;
+}
+
+static unsigned int bcm_poll(struct file *file, struct socket *sock,
+			     poll_table *wait)
+{
+	unsigned int mask = 0;
+
+	DBG("socket %p\n", sock);
+
+	mask = datagram_poll(file, sock, wait);
+	return mask;
+}
+
+static struct proto_ops bcm_ops = {
+	.family        = PF_CAN,
+	.release       = bcm_release,
+	.bind          = sock_no_bind,
+	.connect       = bcm_connect,
+	.socketpair    = sock_no_socketpair,
+	.accept        = sock_no_accept,
+	.getname       = sock_no_getname,
+	.poll          = bcm_poll,
+	.ioctl         = NULL,		/* use can_ioctl() from af_can.c */
+	.listen        = sock_no_listen,
+	.shutdown      = sock_no_shutdown,
+	.setsockopt    = sock_no_setsockopt,
+	.getsockopt    = sock_no_getsockopt,
+	.sendmsg       = bcm_sendmsg,
+	.recvmsg       = bcm_recvmsg,
+	.mmap          = sock_no_mmap,
+	.sendpage      = sock_no_sendpage,
+};
+
+static struct proto bcm_proto = {
+	.name       = "CAN_BCM",
+	.owner      = THIS_MODULE,
+	.obj_size   = sizeof(struct bcm_sock),
+	.init       = bcm_init,
+};
+
+static struct can_proto bcm_can_proto = {
+	.type       = SOCK_DGRAM,
+	.protocol   = CAN_BCM,
+	.capability = BCM_CAP,
+	.ops        = &bcm_ops,
+	.prot       = &bcm_proto,
+};
+
+static int __init bcm_module_init(void)
+{
+	printk(banner);
+
+	can_proto_register(&bcm_can_proto);
+
+	/* create /proc/net/can-bcm directory */
+	proc_dir = proc_mkdir("can-"IDENT, proc_net);
+
+	if (proc_dir)
+		proc_dir->owner = THIS_MODULE;
+
+	return 0;
+}
+
+static void __exit bcm_module_exit(void)
+{
+	can_proto_unregister(&bcm_can_proto);
+
+	if (proc_dir)
+		proc_net_remove("can-"IDENT);
+}
+
+module_init(bcm_module_init);
+module_exit(bcm_module_exit);
Index: net/can/dev.c
===================================================================
--- /dev/null
+++ net/can/dev.c
@@ -0,0 +1,275 @@
+/*
+ * Copyright (C) 2005 Marc Kleine-Budde, Pengutronix
+ * Copyright (C) 2006 Andrey Volkov, Varma Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/can.h>
+#include <linux/can/dev.h>
+
+MODULE_DESCRIPTION("CAN netdevice library");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Marc Kleine-Budde <mkl@pengutronix.de>, "
+	      "Andrey Volkov <avolkov@varma-el.com>");
+
+/*
+ Abstract:
+	Baud rate calculated with next formula:
+	baud = frq/(brp*(1 + prop_seg+ phase_seg1 + phase_seg2))
+
+	This calc function based on work of Florian Hartwich and Armin Bassemi
+	"The Configuration of the CAN Bit Timing"
+	(http://www.semiconductors.bosch.de/pdf/CiA99Paper.pdf)
+
+ Parameters:
+  [in]
+    bit_time_nsec - expected bit time in nanosecs
+
+  [out]
+	bit_time	- calculated time segments, for meaning of
+			  each field read CAN standard.
+*/
+
+#define DEFAULT_MAX_BRP			64U
+#define DEFAULT_MAX_SJW			4U
+
+/* All below values in tq units */
+#define MAX_BIT_TIME	25U
+#define MIN_BIT_TIME	8U
+#define MAX_PROP_SEG	8U
+#define MAX_PHASE_SEG1	8U
+#define MAX_PHASE_SEG2	8U
+
+int can_calc_bit_time(struct can_priv *can, u32 baudrate,
+		      struct can_bittime_std *bit_time)
+{
+	int best_error  = -1; /* Ariphmetic error */
+	int df, best_df = -1; /* oscillator's tolerance range, greater is better*/
+	u32 quanta;	      /*in tq units*/
+	u32 brp, phase_seg1, phase_seg2, sjw, prop_seg;
+	u32 brp_min, brp_max, brp_expected;
+	u64 tmp;
+
+	/* baudrate range [1baud,1Mbaud] */
+	if (baudrate == 0 || baudrate > 1000000UL)
+		return -EINVAL;
+
+	tmp = (u64)can->can_sys_clock*1000;
+	do_div(tmp, baudrate);
+	brp_expected = (u32)tmp;
+
+	brp_min = brp_expected / (1000 * MAX_BIT_TIME);
+	if (brp_min == 0)
+		brp_min = 1;
+	if (brp_min > can->max_brp)
+		return -ERANGE;
+
+	brp_max = (brp_expected + 500 * MIN_BIT_TIME) / (1000 * MIN_BIT_TIME);
+	if (brp_max == 0)
+		brp_max = 1;
+	if (brp_max > can->max_brp)
+		brp_max = can->max_brp;
+
+	for (brp = brp_min; brp <= brp_max; brp++) {
+		quanta = brp_expected / (brp * 1000);
+		if (quanta < MAX_BIT_TIME && quanta * brp * 1000 != brp_expected)
+			quanta++;
+		if (quanta < MIN_BIT_TIME || quanta > MAX_BIT_TIME)
+			continue;
+
+		phase_seg2 = min((quanta - 3) / 2, MAX_PHASE_SEG2);
+		for (sjw = can->max_sjw; sjw > 0; sjw--) {
+			for (; phase_seg2 > sjw; phase_seg2--) {
+				u32 err1, err2;
+				phase_seg1 = phase_seg2 % 2 ? phase_seg2-1 : phase_seg2;
+				prop_seg = quanta-1 - phase_seg2 - phase_seg1;
+				/*
+				 * FIXME: support of longer lines (i.e. bigger prop_seg)
+				 * is more prefered than support of cheap oscillators
+				 * (i.e. bigger df/phase_seg1/phase_seg2)
+				 */
+				if (prop_seg < phase_seg1)
+						continue;
+				if (prop_seg > MAX_PROP_SEG)
+						goto next_brp;
+
+				err1 = phase_seg1*brp*500*1000/
+					(13*brp_expected-phase_seg2*brp*1000);
+				err2 = sjw*brp*50*1000/brp_expected;
+
+				df = min(err1,err2);
+				if (df >= best_df) {
+					unsigned error = abs(brp_expected*10/
+							   (brp*(1+prop_seg+phase_seg1+phase_seg2))-10000);
+
+					if (error > 10 || error > best_error)
+						continue;
+
+					if (error == best_error && prop_seg < bit_time->prop_seg)
+						continue;
+
+					best_error = error;
+					best_df = df;
+					bit_time->brp = brp;
+					bit_time->prop_seg = prop_seg;
+					bit_time->phase_seg1 = phase_seg1;
+					bit_time->phase_seg2 = phase_seg2;
+					bit_time->sjw = sjw;
+					bit_time->sam = (bit_time->phase_seg1 > 3);
+				}
+			}
+		}
+	next_brp:	;
+	}
+
+	if (best_error < 0)
+		return -EDOM;
+	return 0;
+}
+EXPORT_SYMBOL(can_calc_bit_time);
+
+static int can_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct can_priv *can = netdev_priv(dev);
+	struct can_bittime *bt = (struct can_bittime *)&ifr->ifr_ifru;
+	ulong *baudrate = (ulong *)&ifr->ifr_ifru;
+	int ret = -EOPNOTSUPP;
+
+	dev_dbg(ND2D(dev), "(%s) 0x%08x %p\n", __FUNCTION__, cmd, &ifr->ifr_ifru);
+
+	switch (cmd) {
+	case SIOCSCANBAUDRATE:
+		if (can->do_set_bit_time) {
+			struct can_bittime bit_time;
+			ret = can_calc_bit_time(can, *baudrate, &bit_time.std);
+			if (ret != 0)
+				break;
+			bit_time.type = CAN_BITTIME_STD;
+			ret = can->do_set_bit_time(dev, &bit_time);
+			if (!ret) {
+				can->baudrate = *baudrate;
+				can->bit_time = bit_time;
+			}
+		}
+		break;
+	case SIOCGCANBAUDRATE:
+		*baudrate = can->baudrate;
+		ret = 0;
+		break;
+	case SIOCSCANCUSTOMBITTIME:
+		if (can->do_set_bit_time) {
+			ret = can->do_set_bit_time(dev, bt);
+			if (!ret) {
+				can->bit_time = *bt;
+				if (bt->type == CAN_BITTIME_STD && bt->std.brp) {
+					can->baudrate = can->can_sys_clock/(bt->std.brp*
+						(1+bt->std.prop_seg+bt->std.phase_seg1+bt->std.phase_seg2));
+				} else
+					can->baudrate = CAN_BAUDRATE_UNKNOWN;
+			}
+		}
+		break;
+	case SIOCGCANCUSTOMBITTIME:
+		*bt = can->bit_time;
+		ret = 0;
+		break;
+	case SIOCSCANMODE:
+		if (can->do_set_mode) {
+			can_mode_t mode = *((can_mode_t *)(&ifr->ifr_ifru));
+			if (mode == CAN_MODE_START &&
+			    can->baudrate == CAN_BAUDRATE_UNCONFIGURED) {
+				dev_info(ND2D(dev), "Impossible to start on UNKNOWN speed\n");
+				ret = EINVAL;
+			} else
+				return can->do_set_mode(dev, mode);
+		}
+		break;
+	case SIOCGCANMODE:
+		*((can_mode_t *)(&ifr->ifr_ifru)) = can->mode;
+		ret = 0;
+		break;
+	case SIOCSCANCTRLMODE:
+		if (can->do_set_ctrlmode) {
+			can_ctrlmode_t ctrlmode = *((can_ctrlmode_t *)(&ifr->ifr_ifru));
+			return can->do_set_ctrlmode(dev, ctrlmode);
+		}
+		break;
+	case SIOCGCANCTRLMODE:
+		*((can_ctrlmode_t *)(&ifr->ifr_ifru)) = can->ctrlmode;
+		ret = 0;
+		break;
+	case SIOCSCANFILTER:
+		break;
+	case SIOCGCANFILTER:
+		break;
+	case SIOCGCANSTATE:
+		if(can->do_get_state)
+			return can->do_get_state(dev, (can_state_t *)(&ifr->ifr_ifru));
+		break;
+	case SIOCGCANSTATS:
+		*((struct can_device_stats *)(&ifr->ifr_ifru)) = can->can_stats;
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static void can_setup(struct net_device *dev)
+{
+	dev->type            = ARPHRD_CAN;
+	dev->mtu             = sizeof(struct can_frame);
+	dev->do_ioctl        = can_ioctl;
+	dev->hard_header_len = 0;
+	dev->addr_len        = 0;
+	dev->tx_queue_len    = 10;
+
+	/* New-style flags. */
+	dev->flags           = IFF_NOARP;
+	dev->features        = NETIF_F_NO_CSUM;
+}
+
+/*
+ * Function  alloc_candev
+ * 	Allocates and sets up an CAN device
+ */
+struct net_device *alloc_candev(int sizeof_priv)
+{
+	struct net_device *dev;
+	struct can_priv *priv;
+
+	dev = alloc_netdev(sizeof_priv, "can%d", can_setup);
+	if (!dev)
+		return NULL;
+
+	priv = netdev_priv(dev);
+
+	priv->baudrate = CAN_BAUDRATE_UNCONFIGURED;
+	priv->max_brp  = DEFAULT_MAX_BRP;
+	priv->max_sjw  = DEFAULT_MAX_SJW;
+	spin_lock_init(&priv->irq_lock);
+
+	return dev;
+}
+EXPORT_SYMBOL(alloc_candev);
+
+void free_candev(struct net_device *dev)
+{
+	free_netdev(dev);
+}
+EXPORT_SYMBOL(free_candev);
Index: net/can/proc.c
===================================================================
--- /dev/null
+++ net/can/proc.c
@@ -0,0 +1,531 @@
+/*
+ * proc.c - procfs support for Protocol family CAN core module
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/list.h>
+#include <linux/rcupdate.h>
+#include <linux/can/core.h>
+
+#include "af_can.h"
+
+/*
+ * proc filenames for the PF_CAN core
+ */
+
+#define CAN_PROC_VERSION     "version"
+#define CAN_PROC_STATS       "stats"
+#define CAN_PROC_RESET_STATS "reset_stats"
+#define CAN_PROC_RCVLIST_ALL "rcvlist_all"
+#define CAN_PROC_RCVLIST_FIL "rcvlist_fil"
+#define CAN_PROC_RCVLIST_INV "rcvlist_inv"
+#define CAN_PROC_RCVLIST_SFF "rcvlist_sff"
+#define CAN_PROC_RCVLIST_EFF "rcvlist_eff"
+#define CAN_PROC_RCVLIST_ERR "rcvlist_err"
+
+static struct proc_dir_entry *can_dir;
+static struct proc_dir_entry *pde_version;
+static struct proc_dir_entry *pde_stats;
+static struct proc_dir_entry *pde_reset_stats;
+static struct proc_dir_entry *pde_rcvlist_all;
+static struct proc_dir_entry *pde_rcvlist_fil;
+static struct proc_dir_entry *pde_rcvlist_inv;
+static struct proc_dir_entry *pde_rcvlist_sff;
+static struct proc_dir_entry *pde_rcvlist_eff;
+static struct proc_dir_entry *pde_rcvlist_err;
+
+static int user_reset;
+
+static const char *rx_list_name[] = {
+	[RX_ERR] = "rx_err",
+	[RX_ALL] = "rx_all",
+	[RX_FIL] = "rx_fil",
+	[RX_INV] = "rx_inv",
+	[RX_EFF] = "rx_eff",
+};
+
+/*
+ * af_can statistics stuff
+ */
+
+static void can_init_stats(void)
+{
+	/*
+	 * This memset function is called from a timer context (when
+	 * stattimer is active which is the default) OR in a process
+	 * context (reading the proc_fs when stattimer is disabled).
+	 */
+	memset(&stats, 0, sizeof(stats));
+	stats.jiffies_init = jiffies;
+
+	pstats.stats_reset++;
+
+	if (user_reset) {
+		user_reset = 0;
+		pstats.user_reset++;
+	}
+}
+
+static unsigned long calc_rate(unsigned long oldjif, unsigned long newjif,
+			       unsigned long count)
+{
+	unsigned long ret = 0;
+
+	if (oldjif == newjif)
+		return 0;
+
+	/* see can_rcv() - this should NEVER happen! */
+	if (count > (ULONG_MAX / HZ)) {
+		printk(KERN_ERR "can: calc_rate: count exceeded! %ld\n",
+		       count);
+		return 99999999;
+	}
+
+	ret = (count * HZ) / (newjif - oldjif);
+
+	return ret;
+}
+
+void can_stat_update(unsigned long data)
+{
+	unsigned long j = jiffies; /* snapshot */
+
+	/* restart counting in timer context on user request */
+	if (user_reset)
+		can_init_stats();
+
+	/* restart counting on jiffies overflow */
+	if (j < stats.jiffies_init)
+		can_init_stats();
+
+	/* stats.rx_frames is the definitively max. statistic value */
+
+	/* prevent overflow in calc_rate() */
+	if (stats.rx_frames > (ULONG_MAX / HZ))
+		can_init_stats();
+
+	/* matches overflow - very improbable */
+	if (stats.matches > (ULONG_MAX / 100))
+		can_init_stats();
+
+	/* calc total values */
+	if (stats.rx_frames)
+		stats.total_rx_match_ratio = (stats.matches * 100) /
+						stats.rx_frames;
+
+	stats.total_tx_rate = calc_rate(stats.jiffies_init, j,
+					stats.tx_frames);
+	stats.total_rx_rate = calc_rate(stats.jiffies_init, j,
+					stats.rx_frames);
+
+	/* calc current values */
+	if (stats.rx_frames_delta)
+		stats.current_rx_match_ratio =
+			(stats.matches_delta * 100) / stats.rx_frames_delta;
+
+	stats.current_tx_rate = calc_rate(0, HZ, stats.tx_frames_delta);
+	stats.current_rx_rate = calc_rate(0, HZ, stats.rx_frames_delta);
+
+	/* check / update maximum values */
+	if (stats.max_tx_rate < stats.current_tx_rate)
+		stats.max_tx_rate = stats.current_tx_rate;
+
+	if (stats.max_rx_rate < stats.current_rx_rate)
+		stats.max_rx_rate = stats.current_rx_rate;
+
+	if (stats.max_rx_match_ratio < stats.current_rx_match_ratio)
+		stats.max_rx_match_ratio = stats.current_rx_match_ratio;
+
+	/* clear values for 'current rate' calculation */
+	stats.tx_frames_delta = 0;
+	stats.rx_frames_delta = 0;
+	stats.matches_delta   = 0;
+
+	/* restart timer (one second) */
+	stattimer.expires = jiffies + HZ;
+	add_timer(&stattimer);
+}
+
+/*
+ * proc read functions
+ *
+ * From known use-cases we expect about 10 entries in a receive list to be
+ * printed in the proc_fs. So PAGE_SIZE is definitely enough space here.
+ *
+ */
+
+static int can_print_rcvlist(char *page, int len, struct hlist_head *rx_list,
+			     struct net_device *dev)
+{
+	struct receiver *r;
+	struct hlist_node *n;
+
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(r, n, rx_list, list) {
+		char *fmt = (r->can_id & CAN_EFF_FLAG)?
+			"   %-5s  %08X  %08x  %08x  %08x  %8ld  %s\n" :
+			"   %-5s     %03X    %08x  %08lx  %08lx  %8ld  %s\n";
+
+		len += snprintf(page + len, PAGE_SIZE - len, fmt,
+				DNAME(dev), r->can_id, r->mask,
+				(unsigned long)r->func, (unsigned long)r->data,
+				r->matches, r->ident);
+
+		/* does a typical line fit into the current buffer? */
+
+		/* 100 Bytes before end of buffer */
+		if (len > PAGE_SIZE - 100) {
+			/* mark output cut off */
+			len += snprintf(page + len, PAGE_SIZE - len,
+					"   (..)\n");
+			break;
+		}
+	}
+	rcu_read_unlock();
+
+	return len;
+}
+
+static int can_print_recv_banner(char *page, int len)
+{
+	/*
+	 *                  can1.  00000000  00000000  00000000
+	 *                 .......          0  tp20
+	 */
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"  device   can_id   can_mask  function"
+			"  userdata   matches  ident\n");
+
+	return len;
+}
+
+static int can_proc_read_stats(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	int len = 0;
+
+	len += snprintf(page + len, PAGE_SIZE - len, "\n");
+	len += snprintf(page + len, PAGE_SIZE - len,
+			" %8ld transmitted frames (TXF)\n", stats.tx_frames);
+	len += snprintf(page + len, PAGE_SIZE - len,
+			" %8ld received frames (RXF)\n", stats.rx_frames);
+	len += snprintf(page + len, PAGE_SIZE - len,
+			" %8ld matched frames (RXMF)\n", stats.matches);
+
+	len += snprintf(page + len, PAGE_SIZE - len, "\n");
+
+	if (stattimer.function == can_stat_update) {
+		len += snprintf(page + len, PAGE_SIZE - len,
+				" %8ld %% total match ratio (RXMR)\n",
+				stats.total_rx_match_ratio);
+
+		len += snprintf(page + len, PAGE_SIZE - len,
+				" %8ld frames/s total tx rate (TXR)\n",
+				stats.total_tx_rate);
+		len += snprintf(page + len, PAGE_SIZE - len,
+				" %8ld frames/s total rx rate (RXR)\n",
+				stats.total_rx_rate);
+
+		len += snprintf(page + len, PAGE_SIZE - len, "\n");
+
+		len += snprintf(page + len, PAGE_SIZE - len,
+				" %8ld %% current match ratio (CRXMR)\n",
+				stats.current_rx_match_ratio);
+
+		len += snprintf(page + len, PAGE_SIZE - len,
+				" %8ld frames/s current tx rate (CTXR)\n",
+				stats.current_tx_rate);
+		len += snprintf(page + len, PAGE_SIZE - len,
+				" %8ld frames/s current rx rate (CRXR)\n",
+				stats.current_rx_rate);
+
+		len += snprintf(page + len, PAGE_SIZE - len, "\n");
+
+		len += snprintf(page + len, PAGE_SIZE - len,
+				" %8ld %% max match ratio (MRXMR)\n",
+				stats.max_rx_match_ratio);
+
+		len += snprintf(page + len, PAGE_SIZE - len,
+				" %8ld frames/s max tx rate (MTXR)\n",
+				stats.max_tx_rate);
+		len += snprintf(page + len, PAGE_SIZE - len,
+				" %8ld frames/s max rx rate (MRXR)\n",
+				stats.max_rx_rate);
+
+		len += snprintf(page + len, PAGE_SIZE - len, "\n");
+	}
+
+	len += snprintf(page + len, PAGE_SIZE - len,
+			" %8ld current receive list entries (CRCV)\n",
+			pstats.rcv_entries);
+	len += snprintf(page + len, PAGE_SIZE - len,
+			" %8ld maximum receive list entries (MRCV)\n",
+			pstats.rcv_entries_max);
+
+	if (pstats.stats_reset)
+		len += snprintf(page + len, PAGE_SIZE - len,
+				"\n %8ld statistic resets (STR)\n",
+				pstats.stats_reset);
+
+	if (pstats.user_reset)
+		len += snprintf(page + len, PAGE_SIZE - len,
+				" %8ld user statistic resets (USTR)\n",
+				pstats.user_reset);
+
+	len += snprintf(page + len, PAGE_SIZE - len, "\n");
+
+	*eof = 1;
+	return len;
+}
+
+static int can_proc_read_reset_stats(char *page, char **start, off_t off,
+				     int count, int *eof, void *data)
+{
+	int len = 0;
+
+	user_reset = 1;
+
+	if (stattimer.function == can_stat_update) {
+		len += snprintf(page + len, PAGE_SIZE - len,
+				"Scheduled statistic reset #%ld.\n",
+				pstats.stats_reset + 1);
+
+	} else {
+		if (stats.jiffies_init != jiffies)
+			can_init_stats();
+
+		len += snprintf(page + len, PAGE_SIZE - len,
+				"Performed statistic reset #%ld.\n",
+				pstats.stats_reset);
+	}
+
+	*eof = 1;
+	return len;
+}
+
+static int can_proc_read_version(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+	int len = 0;
+
+	len += snprintf(page + len, PAGE_SIZE - len, "%s\n",
+			CAN_VERSION_STRING);
+	*eof = 1;
+	return len;
+}
+
+static int can_proc_read_rcvlist(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+	/* double cast to prevent GCC warning */
+	int idx = (int)(long)data;
+	int len = 0;
+	struct dev_rcv_lists *d;
+	struct hlist_node *n;
+
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"\nreceive list '%s':\n", rx_list_name[idx]);
+
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(d, n, &rx_dev_list, list) {
+
+		if (!hlist_empty(&d->rx[idx])) {
+			len = can_print_recv_banner(page, len);
+			len = can_print_rcvlist(page, len, &d->rx[idx], d->dev);
+		} else
+			len += snprintf(page + len, PAGE_SIZE - len,
+					"  (%s: no entry)\n", DNAME(d->dev));
+
+		/* exit on end of buffer? */
+		if (len > PAGE_SIZE - 100)
+			break;
+	}
+	rcu_read_unlock();
+
+	len += snprintf(page + len, PAGE_SIZE - len, "\n");
+
+	*eof = 1;
+	return len;
+}
+
+static int can_proc_read_rcvlist_sff(char *page, char **start, off_t off,
+				     int count, int *eof, void *data)
+{
+	int len = 0;
+	struct dev_rcv_lists *d;
+	struct hlist_node *n;
+
+	/* RX_SFF */
+	len += snprintf(page + len, PAGE_SIZE - len,
+			"\nreceive list 'rx_sff':\n");
+
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(d, n, &rx_dev_list, list) {
+		int i, all_empty = 1;
+		/* check wether at least one list is non-empty */
+		for (i = 0; i < 0x800; i++)
+			if (!hlist_empty(&d->rx_sff[i])) {
+				all_empty = 0;
+				break;
+			}
+
+		if (!all_empty) {
+			len = can_print_recv_banner(page, len);
+			for (i = 0; i < 0x800; i++) {
+				if (!hlist_empty(&d->rx_sff[i]) &&
+				    len < PAGE_SIZE - 100)
+					len = can_print_rcvlist(page, len,
+								&d->rx_sff[i],
+								d->dev);
+			}
+		} else
+			len += snprintf(page + len, PAGE_SIZE - len,
+					"  (%s: no entry)\n", DNAME(d->dev));
+
+		/* exit on end of buffer? */
+		if (len > PAGE_SIZE - 100)
+			break;
+	}
+	rcu_read_unlock();
+
+	len += snprintf(page + len, PAGE_SIZE - len, "\n");
+
+	*eof = 1;
+	return len;
+}
+
+/*
+ * proc utility functions
+ */
+
+static struct proc_dir_entry *can_create_proc_readentry(const char *name,
+							mode_t mode,
+							read_proc_t *read_proc,
+							void *data)
+{
+	if (can_dir)
+		return create_proc_read_entry(name, mode, can_dir, read_proc,
+					      data);
+	else
+		return NULL;
+}
+
+static void can_remove_proc_readentry(const char *name)
+{
+	if (can_dir)
+		remove_proc_entry(name, can_dir);
+}
+
+/*
+ * can_init_proc - create main CAN proc directory and procfs entries
+ */
+void can_init_proc(void)
+{
+	/* create /proc/net/can directory */
+	can_dir = proc_mkdir("can", proc_net);
+
+	if (!can_dir) {
+		printk(KERN_INFO "can: failed to create /proc/net/can . "
+		       "CONFIG_PROC_FS missing?\n");
+		return;
+	}
+
+	can_dir->owner = THIS_MODULE;
+
+	/* own procfs entries from the AF_CAN core */
+	pde_version     = can_create_proc_readentry(CAN_PROC_VERSION, 0644,
+					can_proc_read_version, NULL);
+	pde_stats       = can_create_proc_readentry(CAN_PROC_STATS, 0644,
+					can_proc_read_stats, NULL);
+	pde_reset_stats = can_create_proc_readentry(CAN_PROC_RESET_STATS, 0644,
+					can_proc_read_reset_stats, NULL);
+	pde_rcvlist_err = can_create_proc_readentry(CAN_PROC_RCVLIST_ERR, 0644,
+					can_proc_read_rcvlist, (void *)RX_ERR);
+	pde_rcvlist_all = can_create_proc_readentry(CAN_PROC_RCVLIST_ALL, 0644,
+					can_proc_read_rcvlist, (void *)RX_ALL);
+	pde_rcvlist_fil = can_create_proc_readentry(CAN_PROC_RCVLIST_FIL, 0644,
+					can_proc_read_rcvlist, (void *)RX_FIL);
+	pde_rcvlist_inv = can_create_proc_readentry(CAN_PROC_RCVLIST_INV, 0644,
+					can_proc_read_rcvlist, (void *)RX_INV);
+	pde_rcvlist_eff = can_create_proc_readentry(CAN_PROC_RCVLIST_EFF, 0644,
+					can_proc_read_rcvlist, (void *)RX_EFF);
+	pde_rcvlist_sff = can_create_proc_readentry(CAN_PROC_RCVLIST_SFF, 0644,
+					can_proc_read_rcvlist_sff, NULL);
+}
+
+/*
+ * can_remove_proc - remove procfs entries and main CAN proc directory
+ */
+void can_remove_proc(void)
+{
+	if (pde_version)
+		can_remove_proc_readentry(CAN_PROC_VERSION);
+
+	if (pde_stats)
+		can_remove_proc_readentry(CAN_PROC_STATS);
+
+	if (pde_reset_stats)
+		can_remove_proc_readentry(CAN_PROC_RESET_STATS);
+
+	if (pde_rcvlist_err)
+		can_remove_proc_readentry(CAN_PROC_RCVLIST_ERR);
+
+	if (pde_rcvlist_all)
+		can_remove_proc_readentry(CAN_PROC_RCVLIST_ALL);
+
+	if (pde_rcvlist_fil)
+		can_remove_proc_readentry(CAN_PROC_RCVLIST_FIL);
+
+	if (pde_rcvlist_inv)
+		can_remove_proc_readentry(CAN_PROC_RCVLIST_INV);
+
+	if (pde_rcvlist_eff)
+		can_remove_proc_readentry(CAN_PROC_RCVLIST_EFF);
+
+	if (pde_rcvlist_sff)
+		can_remove_proc_readentry(CAN_PROC_RCVLIST_SFF);
+
+	if (can_dir)
+		proc_net_remove("can");
+}
Index: net/can/raw.c
===================================================================
--- /dev/null
+++ net/can/raw.c
@@ -0,0 +1,763 @@
+/*
+ * raw.c - Raw sockets for protocol family CAN
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, the following disclaimer and
+ *    the referenced file 'COPYING'.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2 as distributed in the 'COPYING'
+ * file from the main directory of the linux kernel source.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/uio.h>
+#include <linux/poll.h>
+#include <linux/net.h>
+#include <linux/netdevice.h>
+#include <linux/socket.h>
+#include <linux/if_arp.h>
+#include <linux/skbuff.h>
+#include <linux/can.h>
+#include <linux/can/core.h>
+#include <linux/can/raw.h>
+#include <net/sock.h>
+
+#define IDENT "raw"
+#define CAN_RAW_VERSION CAN_VERSION
+static __initdata const char banner[] =
+	KERN_INFO "can: raw protocol (rev " CAN_RAW_VERSION ")\n";
+
+MODULE_DESCRIPTION("PF_CAN raw protocol");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Urs Thuermann <urs.thuermann@volkswagen.de>");
+
+#ifdef CONFIG_CAN_DEBUG_CORE
+static int debug;
+module_param(debug, int, S_IRUGO);
+MODULE_PARM_DESC(debug, "debug print mask: 1:debug, 2:frames, 4:skbs");
+#endif
+
+#ifdef CONFIG_CAN_RAW_USER
+#define RAW_CAP (-1)
+#else
+#define RAW_CAP CAP_NET_RAW
+#endif
+
+#define MASK_ALL 0
+
+/*
+ * A raw socket has a list of can_filters attached to it, each receiving
+ * the CAN frames matching that filter.  If the filter list is empty,
+ * no CAN frames will be received by the socket.  The default after
+ * opening the socket, is to have one filter which receives all frames.
+ * The filter list is allocated dynamically with the exception of the
+ * list containing only one item.  This common case is optimized by
+ * storing the single filter in dfilter, to avoid using dynamic memory.
+ */
+
+struct raw_sock {
+	struct sock sk;
+	int bound;
+	int ifindex;
+	struct notifier_block notifier;
+	int loopback;
+	int recv_own_msgs;
+	int count;                 /* number of active filters */
+	struct can_filter dfilter; /* default/single filter */
+	struct can_filter *filter; /* pointer to filter(s) */
+	can_err_mask_t err_mask;
+};
+
+static inline struct raw_sock *raw_sk(const struct sock *sk)
+{
+	return (struct raw_sock *)sk;
+}
+
+static void raw_rcv(struct sk_buff *skb, void *data)
+{
+	struct sock *sk = (struct sock *)data;
+	struct raw_sock *ro = raw_sk(sk);
+	struct sockaddr_can *addr;
+	int error;
+
+	DBG("received skbuff %p, sk %p\n", skb, sk);
+	DBG_SKB(skb);
+
+	if (!ro->recv_own_msgs) {
+		/* check the received tx sock reference */
+		if (skb->sk == sk) {
+			DBG("trashed own tx msg\n");
+			kfree_skb(skb);
+			return;
+		}
+	}
+
+	addr = (struct sockaddr_can *)skb->cb;
+	memset(addr, 0, sizeof(*addr));
+	addr->can_family  = AF_CAN;
+	addr->can_ifindex = skb->dev->ifindex;
+
+	error = sock_queue_rcv_skb(sk, skb);
+	if (error < 0) {
+		DBG("sock_queue_rcv_skb failed: %d\n", error);
+		DBG("freeing skbuff %p\n", skb);
+		kfree_skb(skb);
+	}
+}
+
+static void raw_enable_filters(struct net_device *dev, struct sock *sk)
+{
+	struct raw_sock *ro = raw_sk(sk);
+	struct can_filter *filter = ro->filter;
+	int i;
+
+	for (i = 0; i < ro->count; i++) {
+		DBG("filter can_id %08X, can_mask %08X%s, sk %p\n",
+		    filter[i].can_id, filter[i].can_mask,
+		    filter[i].can_id & CAN_INV_FILTER ? " (inv)" : "", sk);
+
+		can_rx_register(dev, filter[i].can_id, filter[i].can_mask,
+				raw_rcv, sk, IDENT);
+	}
+}
+
+static void raw_enable_errfilter(struct net_device *dev, struct sock *sk)
+{
+	struct raw_sock *ro = raw_sk(sk);
+
+	if (ro->err_mask)
+		can_rx_register(dev, 0, ro->err_mask | CAN_ERR_FLAG,
+				raw_rcv, sk, IDENT);
+}
+
+static void raw_disable_filters(struct net_device *dev, struct sock *sk)
+{
+	struct raw_sock *ro = raw_sk(sk);
+	struct can_filter *filter = ro->filter;
+	int i;
+
+	for (i = 0; i < ro->count; i++) {
+		DBG("filter can_id %08X, can_mask %08X%s, sk %p\n",
+		    filter[i].can_id, filter[i].can_mask,
+		    filter[i].can_id & CAN_INV_FILTER ? " (inv)" : "", sk);
+
+		can_rx_unregister(dev, filter[i].can_id, filter[i].can_mask,
+				  raw_rcv, sk);
+	}
+}
+
+static void raw_disable_errfilter(struct net_device *dev, struct sock *sk)
+{
+	struct raw_sock *ro = raw_sk(sk);
+
+	if (ro->err_mask)
+		can_rx_unregister(dev, 0, ro->err_mask | CAN_ERR_FLAG,
+				  raw_rcv, sk);
+}
+
+static int raw_notifier(struct notifier_block *nb,
+			unsigned long msg, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct raw_sock *ro = container_of(nb, struct raw_sock, notifier);
+	struct sock *sk = &ro->sk;
+
+	DBG("msg %ld for dev %p (%s idx %d) sk %p ro->ifindex %d\n",
+	    msg, dev, dev->name, dev->ifindex, sk, ro->ifindex);
+
+	if (dev->type != ARPHRD_CAN)
+		return NOTIFY_DONE;
+
+	if (ro->ifindex != dev->ifindex)
+		return NOTIFY_DONE;
+
+	switch (msg) {
+
+	case NETDEV_UNREGISTER:
+		lock_sock(sk);
+		/* remove current filters & unregister */
+		if (ro->bound) {
+			raw_disable_filters(dev, sk);
+			raw_disable_errfilter(dev, sk);
+		}
+
+		if (ro->count > 1)
+			kfree(ro->filter);
+
+		ro->ifindex = 0;
+		ro->bound   = 0;
+		ro->count   = 0;
+		release_sock(sk);
+
+		sk->sk_err = ENODEV;
+		if (!sock_flag(sk, SOCK_DEAD))
+			sk->sk_error_report(sk);
+		break;
+
+	case NETDEV_DOWN:
+		sk->sk_err = ENETDOWN;
+		if (!sock_flag(sk, SOCK_DEAD))
+			sk->sk_error_report(sk);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int raw_init(struct sock *sk)
+{
+	struct raw_sock *ro = raw_sk(sk);
+
+	ro->bound            = 0;
+	ro->ifindex          = 0;
+
+	/* set default filter to single entry dfilter */
+	ro->dfilter.can_id   = 0;
+	ro->dfilter.can_mask = MASK_ALL;
+	ro->filter           = &ro->dfilter;
+	ro->count            = 1;
+
+	/* set default loopback behaviour */
+	ro->loopback         = 1;
+	ro->recv_own_msgs    = 0;
+
+	/* set notifier */
+	ro->notifier.notifier_call = raw_notifier;
+
+	register_netdevice_notifier(&ro->notifier);
+
+	return 0;
+}
+
+static int raw_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct raw_sock *ro = raw_sk(sk);
+
+	DBG("socket %p, sk %p, refcnt %d\n", sock, sk,
+	    atomic_read(&sk->sk_refcnt));
+
+	unregister_netdevice_notifier(&ro->notifier);
+
+	lock_sock(sk);
+
+	/* remove current filters & unregister */
+	if (ro->bound) {
+		if (ro->ifindex) {
+			struct net_device *dev;
+
+			dev = dev_get_by_index(ro->ifindex);
+			if (dev) {
+				raw_disable_filters(dev, sk);
+				raw_disable_errfilter(dev, sk);
+				dev_put(dev);
+			}
+		} else {
+			raw_disable_filters(NULL, sk);
+			raw_disable_errfilter(NULL, sk);
+		}
+	}
+
+	if (ro->count > 1)
+		kfree(ro->filter);
+
+	ro->ifindex = 0;
+	ro->bound   = 0;
+	ro->count   = 0;
+
+	release_sock(sk);
+	sock_put(sk);
+
+	return 0;
+}
+
+static int raw_bind(struct socket *sock, struct sockaddr *uaddr, int len)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct sock *sk = sock->sk;
+	struct raw_sock *ro = raw_sk(sk);
+	int err = 0;
+	int notify_enetdown = 0;
+
+	DBG("socket %p to device %d\n", sock, addr->can_ifindex);
+
+	if (len < sizeof(*addr))
+		return -EINVAL;
+
+	lock_sock(sk);
+
+	if (ro->bound) {
+		/* unregister current filters for this device */
+		if (ro->ifindex) {
+			struct net_device *dev;
+
+			dev = dev_get_by_index(ro->ifindex);
+			if (dev) {
+				raw_disable_filters(dev, sk);
+				raw_disable_errfilter(dev, sk);
+				dev_put(dev);
+			}
+			ro->ifindex = 0;
+
+		} else {
+			raw_disable_filters(NULL, sk);
+			raw_disable_errfilter(NULL, sk);
+		}
+
+		ro->bound = 0;
+	}
+
+	if (addr->can_ifindex) {
+		struct net_device *dev;
+
+		dev = dev_get_by_index(addr->can_ifindex);
+		if (!dev) {
+			DBG("could not find device %d\n", addr->can_ifindex);
+			err = -ENODEV;
+			goto out;
+		}
+		if (dev->type != ARPHRD_CAN) {
+			DBG("device %d no CAN device\n", addr->can_ifindex);
+			dev_put(dev);
+			err = -ENODEV;
+			goto out;
+		}
+		if (!(dev->flags & IFF_UP))
+			notify_enetdown = 1;
+
+		ro->ifindex = dev->ifindex;
+
+		/* filters set by default/setsockopt */
+		raw_enable_filters(dev, sk);
+		raw_enable_errfilter(dev, sk);
+		dev_put(dev);
+
+	} else {
+		ro->ifindex = 0;
+
+		/* filters set by default/setsockopt */
+		raw_enable_filters(NULL, sk);
+		raw_enable_errfilter(NULL, sk);
+	}
+
+	ro->bound = 1;
+
+ out:
+	release_sock(sk);
+
+	if (notify_enetdown) {
+		sk->sk_err = ENETDOWN;
+		if (!sock_flag(sk, SOCK_DEAD))
+			sk->sk_error_report(sk);
+	}
+
+	return err;
+}
+
+static int raw_getname(struct socket *sock, struct sockaddr *uaddr,
+		       int *len, int peer)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct sock *sk = sock->sk;
+	struct raw_sock *ro = raw_sk(sk);
+
+	if (peer)
+		return -EOPNOTSUPP;
+
+	addr->can_family  = AF_CAN;
+	addr->can_ifindex = ro->ifindex;
+
+	*len = sizeof(*addr);
+
+	return 0;
+}
+
+static unsigned int raw_poll(struct file *file, struct socket *sock,
+			     poll_table *wait)
+{
+	unsigned int mask = 0;
+
+	DBG("socket %p\n", sock);
+
+	mask = datagram_poll(file, sock, wait);
+	return mask;
+}
+
+static int raw_setsockopt(struct socket *sock, int level, int optname,
+			  char __user *optval, int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct raw_sock *ro = raw_sk(sk);
+	struct can_filter *filter = NULL;  /* dyn. alloc'ed filters */
+	struct can_filter sfilter;         /* single filter */
+	struct net_device *dev = NULL;
+	can_err_mask_t err_mask = 0;
+	int count = 0;
+	int err;
+
+	if (level != SOL_CAN_RAW)
+		return -EINVAL;
+	if (optlen < 0)
+		return -EINVAL;
+
+	switch (optname) {
+
+	case CAN_RAW_FILTER:
+		if (optlen % sizeof(struct can_filter) != 0)
+			return -EINVAL;
+
+		count = optlen / sizeof(struct can_filter);
+
+		if (count > 1) {
+			/* filter does not fit into dfilter => alloc space */
+			filter = kmalloc(optlen, GFP_KERNEL);
+			if (!filter)
+				return -ENOMEM;
+
+			err = copy_from_user(filter, optval, optlen);
+			if (err) {
+				kfree(filter);
+				return err;
+			}
+		} else if (count == 1) {
+			err = copy_from_user(&sfilter, optval, optlen);
+			if (err)
+				return err;
+		}
+
+		lock_sock(sk);
+
+		if (ro->bound && ro->ifindex)
+			dev = dev_get_by_index(ro->ifindex);
+
+		/* remove current filters & unregister */
+		if (ro->bound)
+			raw_disable_filters(dev, sk);
+
+		if (ro->count > 1)
+			kfree(ro->filter);
+
+		if (count == 1) {
+			/* copy filter data for single filter */
+			ro->dfilter = sfilter;
+			filter = &ro->dfilter;
+		}
+
+		/* add new filters & register */
+		ro->filter = filter;
+		ro->count  = count;
+		if (ro->bound)
+			raw_enable_filters(dev, sk);
+
+		if (dev)
+			dev_put(dev);
+
+		release_sock(sk);
+
+		break;
+
+	case CAN_RAW_ERR_FILTER:
+		if (optlen != sizeof(err_mask))
+			return -EINVAL;
+
+		err = copy_from_user(&err_mask, optval, optlen);
+		if (err)
+			return err;
+
+		err_mask &= CAN_ERR_MASK;
+
+		lock_sock(sk);
+
+		if (ro->bound && ro->ifindex)
+			dev = dev_get_by_index(ro->ifindex);
+
+		/* remove current error mask */
+		if (ro->bound)
+			raw_disable_errfilter(dev, sk);
+
+		ro->err_mask = err_mask;
+
+		/* add new error mask */
+		if (ro->bound)
+			raw_enable_errfilter(dev, sk);
+
+		if (dev)
+			dev_put(dev);
+
+		release_sock(sk);
+
+		break;
+
+	case CAN_RAW_LOOPBACK:
+		if (optlen != sizeof(ro->loopback))
+			return -EINVAL;
+
+		err = copy_from_user(&ro->loopback, optval, optlen);
+		if (err)
+			return err;
+
+		break;
+
+	case CAN_RAW_RECV_OWN_MSGS:
+		if (optlen != sizeof(ro->recv_own_msgs))
+			return -EINVAL;
+
+		err = copy_from_user(&ro->recv_own_msgs, optval, optlen);
+		if (err)
+			return err;
+
+		break;
+
+	default:
+		return -ENOPROTOOPT;
+	}
+	return 0;
+}
+
+static int raw_getsockopt(struct socket *sock, int level, int optname,
+			  char __user *optval, int __user *optlen)
+{
+	struct sock *sk = sock->sk;
+	struct raw_sock *ro = raw_sk(sk);
+	int len;
+	void *val;
+	int err = 0;
+
+	if (level != SOL_CAN_RAW)
+		return -EINVAL;
+	if (get_user(len, optlen))
+		return -EFAULT;
+	if (len < 0)
+		return -EINVAL;
+
+	switch (optname) {
+
+	case CAN_RAW_FILTER:
+		lock_sock(sk);
+		if (ro->count > 0) {
+			int fsize = ro->count * sizeof(struct can_filter);
+			if (len > fsize)
+				len = fsize;
+			err = copy_to_user(optval, ro->filter, len);
+		} else
+			len = 0;
+		release_sock(sk);
+
+		if (!err)
+			err = put_user(len, optlen);
+		return err;
+
+	case CAN_RAW_ERR_FILTER:
+		if (len > sizeof(can_err_mask_t))
+			len = sizeof(can_err_mask_t);
+		val = &ro->err_mask;
+		break;
+
+	case CAN_RAW_LOOPBACK:
+		if (len > sizeof(int))
+			len = sizeof(int);
+		val = &ro->loopback;
+		break;
+
+	case CAN_RAW_RECV_OWN_MSGS:
+		if (len > sizeof(int))
+			len = sizeof(int);
+		val = &ro->recv_own_msgs;
+		break;
+
+	default:
+		return -ENOPROTOOPT;
+	}
+
+	if (put_user(len, optlen))
+		return -EFAULT;
+	if (copy_to_user(optval, val, len))
+		return -EFAULT;
+	return 0;
+}
+
+static int raw_sendmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct raw_sock *ro = raw_sk(sk);
+	struct sk_buff *skb;
+	struct net_device *dev;
+	int ifindex;
+	int err;
+
+	DBG("socket %p, sk %p\n", sock, sk);
+
+	if (msg->msg_name) {
+		struct sockaddr_can *addr =
+			(struct sockaddr_can *)msg->msg_name;
+
+		if (addr->can_family != AF_CAN)
+			return -EINVAL;
+
+		ifindex = addr->can_ifindex;
+	} else
+		ifindex = ro->ifindex;
+
+	dev = dev_get_by_index(ifindex);
+	if (!dev) {
+		DBG("device %d not found\n", ifindex);
+		return -ENXIO;
+	}
+
+	skb = alloc_skb(size, GFP_KERNEL);
+	if (!skb) {
+		dev_put(dev);
+		return -ENOMEM;
+	}
+
+	err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
+	if (err < 0) {
+		kfree_skb(skb);
+		dev_put(dev);
+		return err;
+	}
+	skb->dev = dev;
+	skb->sk  = sk;
+
+	DBG("sending skbuff to interface %d\n", ifindex);
+	DBG_SKB(skb);
+
+	err = can_send(skb, ro->loopback);
+
+	dev_put(dev);
+
+	if (err)
+		return err;
+
+	return size;
+}
+
+static int raw_recvmsg(struct kiocb *iocb, struct socket *sock,
+		       struct msghdr *msg, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct sk_buff *skb;
+	int error = 0;
+	int noblock;
+
+	DBG("socket %p, sk %p\n", sock, sk);
+
+	noblock =  flags & MSG_DONTWAIT;
+	flags   &= ~MSG_DONTWAIT;
+
+	skb = skb_recv_datagram(sk, flags, noblock, &error);
+	if (!skb)
+		return error;
+
+	DBG("delivering skbuff %p\n", skb);
+	DBG_SKB(skb);
+
+	if (size < skb->len)
+		msg->msg_flags |= MSG_TRUNC;
+	else
+		size = skb->len;
+
+	error = memcpy_toiovec(msg->msg_iov, skb->data, size);
+	if (error < 0) {
+		skb_free_datagram(sk, skb);
+		return error;
+	}
+
+	sock_recv_timestamp(msg, sk, skb);
+
+	if (msg->msg_name) {
+		msg->msg_namelen = sizeof(struct sockaddr_can);
+		memcpy(msg->msg_name, skb->cb, msg->msg_namelen);
+	}
+
+	DBG("freeing sock %p, skbuff %p\n", sk, skb);
+	skb_free_datagram(sk, skb);
+
+	return size;
+}
+
+static struct proto_ops raw_ops = {
+	.family        = PF_CAN,
+	.release       = raw_release,
+	.bind          = raw_bind,
+	.connect       = sock_no_connect,
+	.socketpair    = sock_no_socketpair,
+	.accept        = sock_no_accept,
+	.getname       = raw_getname,
+	.poll          = raw_poll,
+	.ioctl         = NULL,		/* use can_ioctl() from af_can.c */
+	.listen        = sock_no_listen,
+	.shutdown      = sock_no_shutdown,
+	.setsockopt    = raw_setsockopt,
+	.getsockopt    = raw_getsockopt,
+	.sendmsg       = raw_sendmsg,
+	.recvmsg       = raw_recvmsg,
+	.mmap          = sock_no_mmap,
+	.sendpage      = sock_no_sendpage,
+};
+
+static struct proto raw_proto = {
+	.name       = "CAN_RAW",
+	.owner      = THIS_MODULE,
+	.obj_size   = sizeof(struct raw_sock),
+	.init       = raw_init,
+};
+
+static struct can_proto raw_can_proto = {
+	.type       = SOCK_RAW,
+	.protocol   = CAN_RAW,
+	.capability = RAW_CAP,
+	.ops        = &raw_ops,
+	.prot       = &raw_proto,
+};
+
+static __init int raw_module_init(void)
+{
+	printk(banner);
+
+	can_proto_register(&raw_can_proto);
+	return 0;
+}
+
+static __exit void raw_module_exit(void)
+{
+	can_proto_unregister(&raw_can_proto);
+}
+
+module_init(raw_module_init);
+module_exit(raw_module_exit);
