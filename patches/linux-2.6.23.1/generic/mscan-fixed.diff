Subject: fix mscan driver for 2.6.23+
From: Marc Kleine-Budde <mkl@pengutronix.de>

This patch fixed several errors with >= 2.6.23 kernels

Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

---
 drivers/net/can/mscan/mscan.c |   27 +++++++++++++++++++--------
 1 file changed, 19 insertions(+), 8 deletions(-)

Index: linux-2.6.23-rc6/drivers/net/can/mscan/mscan.c
===================================================================
--- linux-2.6.23-rc6.orig/drivers/net/can/mscan/mscan.c
+++ linux-2.6.23-rc6/drivers/net/can/mscan/mscan.c
@@ -82,6 +82,7 @@ typedef struct {
 
 struct mscan_priv {
 	struct can_priv can;
+	struct net_device_stats	net_stats;
 	volatile unsigned long flags;
 	u8 shadow_statflg;
 	u8 shadow_canrier;
@@ -343,7 +344,7 @@ static int mscan_rx_poll(struct net_devi
 		if (!skb) {
 			if (printk_ratelimit())
 				dev_notice(ND2D(dev), "packet dropped\n");
-			priv->can.net_stats.rx_dropped++;
+			priv->net_stats.rx_dropped++;
 			out_8(&regs->canrflg, canrflg);
 			continue;
 		}
@@ -391,15 +392,15 @@ static int mscan_rx_poll(struct net_devi
 
 			out_8(&regs->canrflg, MSCAN_RXF);
 			dev->last_rx = jiffies;
-			priv->can.net_stats.rx_packets++;
-			priv->can.net_stats.rx_bytes += frame->can_dlc;
+			priv->net_stats.rx_packets++;
+			priv->net_stats.rx_bytes += frame->can_dlc;
 		} else if (canrflg & MSCAN_ERR_IF) {
 			frame->can_id = CAN_ERR_FLAG;
 
 			if (canrflg & MSCAN_OVRIF) {
 				frame->can_id |= CAN_ERR_CRTL;
 				frame->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
-				priv->can.net_stats.rx_over_errors++;
+				priv->net_stats.rx_over_errors++;
 			} else
 				frame->data[1] = 0;
 
@@ -477,13 +478,13 @@ static irqreturn_t mscan_isr(int irq, vo
 				continue;
 
 			if (in_8(&regs->cantaak) & mask) {
-				priv->can.net_stats.tx_dropped++;
-				priv->can.net_stats.tx_aborted_errors++;
+				priv->net_stats.tx_dropped++;
+				priv->net_stats.tx_aborted_errors++;
 			} else {
 				out_8(&regs->cantbsel, mask);
-				priv->can.net_stats.tx_bytes +=
+				priv->net_stats.tx_bytes +=
 				    in_8(&regs->tx.dlr);
-				priv->can.net_stats.tx_packets++;
+				priv->net_stats.tx_packets++;
 			}
 			priv->tx_active &= ~mask;
 			list_del(pos);
@@ -667,6 +668,13 @@ void unregister_mscandev(struct net_devi
 
 EXPORT_SYMBOL(unregister_mscandev);
 
+static struct net_device_stats *can_get_stats(struct net_device *dev)
+{
+        struct mscan_priv *priv = netdev_priv(dev);
+
+        /* TODO: read statistics from chip */
+        return &priv->net_stats;
+}
 struct net_device *alloc_mscandev(void)
 {
 	struct net_device *dev;
@@ -683,12 +691,15 @@ struct net_device *alloc_mscandev(void)
 	dev->stop = mscan_close;
 	dev->hard_start_xmit = mscan_hard_start_xmit;
 	dev->tx_timeout = mscan_tx_timeout;
+	dev->get_stats = can_get_stats;
 
 	dev->poll = mscan_rx_poll;
 	dev->weight = 8;
 
 	priv->can.do_set_bit_time = mscan_do_set_bit_time;
 	priv->can.do_set_mode = mscan_do_set_mode;
+	priv->can.max_brp = 64;
+	priv->can.max_sjw = 4;
 
 	for (i = 0; i < TX_QUEUE_SIZE; i++)
 		priv->tx_queue[i].mask = 1 << i;
