From linux-rt-users-owner@vger.kernel.org Fri Jun 22 23:36:42 2007
Return-Path: <linux-rt-users-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.1.7-deb (2006-10-05) on debian
X-Spam-Level: 
X-Spam-Status: No, score=0.0 required=5.0 tests=none autolearn=unavailable 
	version=3.1.7-deb
Received: from vger.kernel.org (vger.kernel.org [209.132.176.167]) by
	mail.tglx.de (Postfix) with ESMTP id E246465C292; Fri, 22 Jun 2007 23:36:42
	+0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand id
	S1753653AbXFVVgk (ORCPT <rfc822;jan.altenberg@linutronix.de> + 1 other);
	Fri, 22 Jun 2007 17:36:40 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id
	S1753545AbXFVVgk (ORCPT <rfc822;linux-rt-users-outgoing>); Fri, 22 Jun 2007
	17:36:40 -0400
Received: from homer.mvista.com ([63.81.120.158]:10787 "EHLO
	gateway-1237.mvista.com" rhost-flags-OK-FAIL-OK-OK) by vger.kernel.org with
	ESMTP id S1753234AbXFVVgk (ORCPT <rfc822;linux-rt-users@vger.kernel.org>);
	Fri, 22 Jun 2007 17:36:40 -0400
Received: from [192.168.0.30] (unknown [10.0.10.125]) by hermes.mvista.com
	(Postfix) with ESMTP id EDA2D1DBDB; Fri, 22 Jun 2007 14:36:38 -0700 (PDT)
Message-ID: <467C40D3.206@ncos.nec.co.jp>
Date:	Fri, 22 Jun 2007 14:36:19 -0700
From:	Masayuki Nakagawa <nakagawa.msy@ncos.nec.co.jp>
User-Agent: Thunderbird 1.5.0.12 (Windows/20070509)
MIME-Version: 1.0
To:	mingo@elte.hu
Cc:	linux-rt-users@vger.kernel.org, dwalker@mvista.com
Subject: [PATCH 2.6.21.5-rt17] IPV6: estalished connections are not shown
	with "cat /proc/net/tcp6"
Content-Type: text/plain; charset=UTF-8
Sender:	linux-rt-users-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List:	linux-rt-users@vger.kernel.org
X-Filter-To: .Kernel.rt-users
X-Evolution-Source: imap://tglx%40linutronix.de@localhost:8993/
Content-Transfer-Encoding: 8bit

I found an issue regarding networking in the real-time patch (patch-2.6.21.5-rt17).
The issue happens only with the kernel, which the real-time patch was applied.
However, the latest stable main kernel (2.6.21.5) doesn't have the same issue.
Therefore, please don't transfer this report to netdev.

The detail of issue is below.
I ran my test program, which is a very simple IPv6 client-server program.
These programs establish a TCP/IPv6 connection between two hosts, and then sleep,
like following diagram.
And then, the problem appears with "cat /proc/net/tcp6".

    serverA          serverB
       |      SYN       |
       +--------------->+
       |    SYN/ACK     |
       +<---------------+
       |      ACK       |
       +--------------->+
       |                |
     sleep...         sleep...
       |                |

When I "cat /proc/net/tcp6" on serverA while establishing connection between serverA and B,
the established connections are not shown.
If you need my test program, please let me know. I can provide it to you.

However, in case of the main-line kernel, the established connections will be
shown appropriately with "cat /proc/net/tcp6". It's different because the
real-time patch has implemented a new socket lookup mechanism for a high-latency.
So, real-time patch has a different mechanism from main-line kernel.

The real-time patch, which implemented a new socket lookup mechanism is using
bitmap(ebitmask). When establishing TCP connection, it sets a flag bit into
the bitmap like followings.

[ebitmask in struct inet_hashinfo]
 Before connecting
  0000000000000000000000000000000000000000000000000000000000000000
 After connecting
  0000001000000000000000000000000000000000000000000000000000000000
        ^

And when reading "/proc/net/tcp and tcp6", the kernel searches the currently active
TCP connections with reference to the bitmap.

However, the kernel can't search the active TCP/IPv6 connection in established state.
It is because the kernel doesn't set a flag bit when establishing TCP/IPv6 connection.
In case of TCP/IPv4, __inet_hash() sets the flag bit properly with __inet_hash_setbit().
But, in case of TCP/IPv6, the setting the flag bit is missing in __inet6_hash().

[include/net/inet_hashtables.h]
static inline void __inet_hash(struct inet_hashinfo *hashinfo,
                               struct sock *sk, const int listen_possible)
{
        struct hlist_head *list;
        rwlock_t *lock;
        unsigned long *bitmask = NULL;
        unsigned int index = 0;

        BUG_TRAP(sk_unhashed(sk));
        if (listen_possible && sk->sk_state == TCP_LISTEN) {
                list = &hashinfo->listening_hash[inet_sk_listen_hashfn(sk)];
                lock = &hashinfo->lhash_lock;
                inet_listen_wlock(hashinfo);
        } else {
                struct inet_ehash_bucket *head;
                sk->sk_hash = inet_sk_ehashfn(sk);
                index = inet_ehash_index(hashinfo, sk->sk_hash);
                head = inet_ehash_bucket(hashinfo, sk->sk_hash);
                list = &head->chain;
                lock = &head->lock;
                bitmask = hashinfo->ebitmask;
                write_lock(lock);
        }
        __sk_add_node(sk, list);
        __inet_hash_setbit(bitmask, index);
        sock_prot_inc_use(sk->sk_prot);
        write_unlock(lock);
        if (listen_possible && sk->sk_state == TCP_LISTEN)
                wake_up(&hashinfo->lhash_wait);
}

[net/ipv6/inet6_hashtables.c]
void __inet6_hash(struct inet_hashinfo *hashinfo,
                                struct sock *sk)
{
        struct hlist_head *list;
        rwlock_t *lock;

        printk("__inet6_hash hit\n");

        BUG_TRAP(sk_unhashed(sk));

        if (sk->sk_state == TCP_LISTEN) {
                list = &hashinfo->listening_hash[inet_sk_listen_hashfn(sk)];
                lock = &hashinfo->lhash_lock;
                inet_listen_wlock(hashinfo);
        } else {
                unsigned int hash;
                sk->sk_hash = hash = inet6_sk_ehashfn(sk);
                hash &= (hashinfo->ehash_size - 1);
                list = &hashinfo->ehash[hash].chain;
                lock = &hashinfo->ehash[hash].lock;
                write_lock(lock);
        }

        __sk_add_node(sk, list);
        sock_prot_inc_use(sk->sk_prot);
        write_unlock(lock);
}

So, I suggest a following change.
The change is to set the flag bit appropriately in __inet6_hash().

Signed-off-by: Masayuki Nakagawa <nakagawa.msy@ncos.nec.co.jp>


---
 net/ipv6/inet6_hashtables.c |   13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

Index: linux-2.6.23.1-rt5/net/ipv6/inet6_hashtables.c
===================================================================
--- linux-2.6.23.1-rt5.orig/net/ipv6/inet6_hashtables.c
+++ linux-2.6.23.1-rt5/net/ipv6/inet6_hashtables.c
@@ -27,6 +27,8 @@ void __inet6_hash(struct inet_hashinfo *
 {
 	struct hlist_head *list;
 	rwlock_t *lock;
+	unsigned long *bitmask = NULL;
+	unsigned int index = 0;
 
 	BUG_TRAP(sk_unhashed(sk));
 
@@ -35,15 +37,16 @@ void __inet6_hash(struct inet_hashinfo *
 		lock = &hashinfo->lhash_lock;
 		inet_listen_wlock(hashinfo);
 	} else {
-		unsigned int hash;
-		sk->sk_hash = hash = inet6_sk_ehashfn(sk);
-		hash &= (hashinfo->ehash_size - 1);
-		list = &hashinfo->ehash[hash].chain;
-		lock = &hashinfo->ehash[hash].lock;
+		sk->sk_hash = inet6_sk_ehashfn(sk);
+		index = inet_ehash_index(hashinfo, sk->sk_hash);
+		list = &hashinfo->ehash[index].chain;
+		lock = &hashinfo->ehash[index].lock;
+		bitmask = hashinfo->ebitmask;
 		write_lock(lock);
 	}
 
 	__sk_add_node(sk, list);
+	__inet_hash_setbit(bitmask, index);
 	sock_prot_inc_use(sk->sk_prot);
 	write_unlock(lock);
 }
