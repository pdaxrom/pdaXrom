diff -Nur linux-2.6.29.1/arch/mips/include/asm/clock.h linux-2.6.29.1-lemote/arch/mips/include/asm/clock.h
--- linux-2.6.29.1/arch/mips/include/asm/clock.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/include/asm/clock.h	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,62 @@
+#ifndef __ASM_MIPS_CLOCK_H
+#define __ASM_MIPS_CLOCK_H
+
+#include <linux/kref.h>
+#include <linux/list.h>
+#include <linux/seq_file.h>
+#include <linux/clk.h>
+
+struct clk;
+
+struct clk_ops {
+	void (*init)(struct clk *clk);
+	void (*enable)(struct clk *clk);
+	void (*disable)(struct clk *clk);
+	void (*recalc)(struct clk *clk);
+	int (*set_rate)(struct clk *clk, unsigned long rate, int algo_id);
+	long (*round_rate)(struct clk *clk, unsigned long rate);
+};
+
+struct clk {
+	struct list_head	node;
+	const char		*name;
+	int			id;
+	struct module		*owner;
+
+	struct clk		*parent;
+	struct clk_ops		*ops;
+
+	struct kref		kref;
+
+	unsigned long		rate;
+	unsigned long		flags;
+};
+
+#define CLK_ALWAYS_ENABLED	(1 << 0)
+#define CLK_RATE_PROPAGATES	(1 << 1)
+
+/* Should be defined by processor-specific code */
+void arch_init_clk_ops(struct clk_ops **, int type);
+
+int clk_init(void);
+
+int __clk_enable(struct clk *);
+void __clk_disable(struct clk *);
+
+void clk_recalc_rate(struct clk *);
+
+int clk_register(struct clk *);
+void clk_unregister(struct clk *);
+
+/* the exported API, in addition to clk_set_rate */
+/**
+ * clk_set_rate_ex - set the clock rate for a clock source, with additional parameter
+ * @clk: clock source
+ * @rate: desired clock rate in Hz
+ * @algo_id: algorithm id to be passed down to ops->set_rate
+ *
+ * Returns success (0) or negative errno.
+ */
+int clk_set_rate_ex(struct clk *clk, unsigned long rate, int algo_id);
+
+#endif /* __ASM_MIPS_CLOCK_H */
diff -Nur linux-2.6.29.1/arch/mips/include/asm/mach-lemote/dma-coherence.h linux-2.6.29.1-lemote/arch/mips/include/asm/mach-lemote/dma-coherence.h
--- linux-2.6.29.1/arch/mips/include/asm/mach-lemote/dma-coherence.h	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/include/asm/mach-lemote/dma-coherence.h	2009-04-07 09:39:28.000000000 +0000
@@ -27,7 +27,18 @@
 
 static inline unsigned long plat_dma_addr_to_phys(dma_addr_t dma_addr)
 {
+#ifdef CONFIG_64BIT
+#ifdef CONFIG_MACH_LM2F
+	if (dma_addr > 0x8fffffff)
+		return dma_addr;
+	else
+		return dma_addr & 0x0fffffff;
+#else
 	return dma_addr & 0x7fffffff;
+#endif
+#else
+	return dma_addr & 0x7fffffff;
+#endif
 }
 
 static inline void plat_unmap_dma_mem(struct device *dev, dma_addr_t dma_addr)
diff -Nur linux-2.6.29.1/arch/mips/include/asm/mips-boards/bonito64.h linux-2.6.29.1-lemote/arch/mips/include/asm/mips-boards/bonito64.h
--- linux-2.6.29.1/arch/mips/include/asm/mips-boards/bonito64.h	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/include/asm/mips-boards/bonito64.h	2009-04-07 09:39:28.000000000 +0000
@@ -26,7 +26,7 @@
 /* offsets from base register */
 #define BONITO(x)	(x)
 
-#elif defined(CONFIG_LEMOTE_FULONG)
+#elif defined(CONFIG_LEMOTE_FULONG) || defined(CONFIG_MACH_LM2F)
 
 #define BONITO(x) (*(volatile u32 *)((char *)CKSEG1ADDR(BONITO_REG_BASE) + (x)))
 #define BONITO_IRQ_BASE   32
diff -Nur linux-2.6.29.1/arch/mips/include/asm/mipsregs.h linux-2.6.29.1-lemote/arch/mips/include/asm/mipsregs.h
--- linux-2.6.29.1/arch/mips/include/asm/mipsregs.h	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/include/asm/mipsregs.h	2009-04-07 09:39:28.000000000 +0000
@@ -1391,11 +1391,11 @@
 static inline unsigned int					\
 set_c0_##name(unsigned int set)					\
 {								\
-	unsigned int res;					\
+	unsigned int res, new;					\
 								\
 	res = read_c0_##name();					\
-	res |= set;						\
-	write_c0_##name(res);					\
+	new = res | set;					\
+	write_c0_##name(new);					\
 								\
 	return res;						\
 }								\
@@ -1403,24 +1403,24 @@
 static inline unsigned int					\
 clear_c0_##name(unsigned int clear)				\
 {								\
-	unsigned int res;					\
+	unsigned int res, new;					\
 								\
 	res = read_c0_##name();					\
-	res &= ~clear;						\
-	write_c0_##name(res);					\
+	new = res & ~clear;					\
+	write_c0_##name(new);					\
 								\
 	return res;						\
 }								\
 								\
 static inline unsigned int					\
-change_c0_##name(unsigned int change, unsigned int new)		\
+change_c0_##name(unsigned int change, unsigned int val)		\
 {								\
-	unsigned int res;					\
+	unsigned int res, new;					\
 								\
 	res = read_c0_##name();					\
-	res &= ~change;						\
-	res |= (new & change);					\
-	write_c0_##name(res);					\
+	new = res & ~change;					\
+	new |= (val & change);					\
+	write_c0_##name(new);					\
 								\
 	return res;						\
 }
@@ -1484,14 +1484,15 @@
 set_c0_##name(unsigned int set)					\
 {								\
 	unsigned int res;					\
+	unsigned int new;					\
 	unsigned int omt;					\
 	unsigned long flags;					\
 								\
 	local_irq_save(flags);					\
 	omt = __dmt();						\
 	res = read_c0_##name();					\
-	res |= set;						\
-	write_c0_##name(res);					\
+	new = res | set;					\
+	write_c0_##name(new);					\
 	__emt(omt);						\
 	local_irq_restore(flags);				\
 								\
@@ -1502,14 +1503,15 @@
 clear_c0_##name(unsigned int clear)				\
 {								\
 	unsigned int res;					\
+	unsigned int new;					\
 	unsigned int omt;					\
 	unsigned long flags;					\
 								\
 	local_irq_save(flags);					\
 	omt = __dmt();						\
 	res = read_c0_##name();					\
-	res &= ~clear;						\
-	write_c0_##name(res);					\
+	new = res & ~clear;					\
+	write_c0_##name(new);					\
 	__emt(omt);						\
 	local_irq_restore(flags);				\
 								\
@@ -1517,9 +1519,10 @@
 }								\
 								\
 static inline unsigned int					\
-change_c0_##name(unsigned int change, unsigned int new)		\
+change_c0_##name(unsigned int change, unsigned int newbits)	\
 {								\
 	unsigned int res;					\
+	unsigned int new;					\
 	unsigned int omt;					\
 	unsigned long flags;					\
 								\
@@ -1527,9 +1530,9 @@
 								\
 	omt = __dmt();						\
 	res = read_c0_##name();					\
-	res &= ~change;						\
-	res |= (new & change);					\
-	write_c0_##name(res);					\
+	new = res & ~change;					\
+	new |= (newbits & change);				\
+	write_c0_##name(new);					\
 	__emt(omt);						\
 	local_irq_restore(flags);				\
 								\
diff -Nur linux-2.6.29.1/arch/mips/include/asm/pgtable.h linux-2.6.29.1-lemote/arch/mips/include/asm/pgtable.h
--- linux-2.6.29.1/arch/mips/include/asm/pgtable.h	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/include/asm/pgtable.h	2009-04-07 09:39:28.000000000 +0000
@@ -369,6 +369,16 @@
 
 #include <asm-generic/pgtable.h>
 
+#ifdef CONFIG_MACH_LM2F
+#define __HAVE_PHYS_MEM_ACCESS_PROT
+
+struct file;
+pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
+                              unsigned long size, pgprot_t vma_prot);
+int phys_mem_access_prot_allowed(struct file *file, unsigned long pfn,
+                              unsigned long size, pgprot_t *vma_prot);
+#endif
+
 /*
  * We provide our own get_unmapped area to cope with the virtual aliasing
  * constraints placed on us by the cache architecture.
diff -Nur linux-2.6.29.1/arch/mips/include/asm/spinlock.h linux-2.6.29.1-lemote/arch/mips/include/asm/spinlock.h
--- linux-2.6.29.1/arch/mips/include/asm/spinlock.h	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/include/asm/spinlock.h	2009-04-07 09:39:28.000000000 +0000
@@ -76,7 +76,7 @@
 		"2:							\n"
 		"	.subsection 2					\n"
 		"4:	andi	%[ticket], %[ticket], 0x1fff		\n"
-		"5:	sll	%[ticket], 5				\n"
+		"	sll	%[ticket], 5				\n"
 		"							\n"
 		"6:	bnez	%[ticket], 6b				\n"
 		"	 subu	%[ticket], 1				\n"
@@ -85,7 +85,7 @@
 		"	andi	%[ticket], %[ticket], 0x1fff		\n"
 		"	beq	%[ticket], %[my_ticket], 2b		\n"
 		"	 subu	%[ticket], %[my_ticket], %[ticket]	\n"
-		"	b	5b					\n"
+		"	b	4b					\n"
 		"	 subu	%[ticket], %[ticket], 1			\n"
 		"	.previous					\n"
 		"	.set pop					\n"
@@ -113,7 +113,7 @@
 		"	 ll	%[ticket], %[ticket_ptr]		\n"
 		"							\n"
 		"4:	andi	%[ticket], %[ticket], 0x1fff		\n"
-		"5:	sll	%[ticket], 5				\n"
+		"	sll	%[ticket], 5				\n"
 		"							\n"
 		"6:	bnez	%[ticket], 6b				\n"
 		"	 subu	%[ticket], 1				\n"
@@ -122,7 +122,7 @@
 		"	andi	%[ticket], %[ticket], 0x1fff		\n"
 		"	beq	%[ticket], %[my_ticket], 2b		\n"
 		"	 subu	%[ticket], %[my_ticket], %[ticket]	\n"
-		"	b	5b					\n"
+		"	b	4b					\n"
 		"	 subu	%[ticket], %[ticket], 1			\n"
 		"	.previous					\n"
 		"	.set pop					\n"
diff -Nur linux-2.6.29.1/arch/mips/include/asm/stackframe.h linux-2.6.29.1-lemote/arch/mips/include/asm/stackframe.h
--- linux-2.6.29.1/arch/mips/include/asm/stackframe.h	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/include/asm/stackframe.h	2009-04-07 09:39:28.000000000 +0000
@@ -117,6 +117,24 @@
 		.endm
 #else
 		.macro	get_saved_sp	/* Uniprocessor variation */
+#ifdef CONFIG_CPU_LOONGSON2
+		move k0,ra
+		jal 2008f
+		nop
+		2008:
+		jal 2008f
+		nop
+		2008:
+		jal 2008f
+		nop
+		2008:
+		jal 2008f
+		nop
+		2008:
+		move ra,k0
+		li k0,3
+		mtc0 k0,$22
+#endif
 #if defined(CONFIG_32BIT) || defined(KBUILD_64BIT_SYM32)
 		lui	k1, %hi(kernelsp)
 #else
diff -Nur linux-2.6.29.1/arch/mips/include/asm/suspend.h linux-2.6.29.1-lemote/arch/mips/include/asm/suspend.h
--- linux-2.6.29.1/arch/mips/include/asm/suspend.h	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/include/asm/suspend.h	2009-04-07 09:39:28.000000000 +0000
@@ -3,4 +3,6 @@
 
 /* Somewhen...  Maybe :-)  */
 
+static inline int arch_prepare_suspend(void) { return 0; }
+
 #endif /* __ASM_SUSPEND_H */
diff -Nur linux-2.6.29.1/arch/mips/include/asm/time.h linux-2.6.29.1-lemote/arch/mips/include/asm/time.h
--- linux-2.6.29.1/arch/mips/include/asm/time.h	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/include/asm/time.h	2009-04-07 09:39:28.000000000 +0000
@@ -57,7 +57,11 @@
 
 static inline int mips_clockevent_init(void)
 {
-#ifdef CONFIG_CEVT_R4K
+#ifdef CONFIG_MIPS_MT_SMTC
+	extern int smtc_clockevent_init(void);
+
+	return smtc_clockevent_init();
+#elif defined(CONFIG_CEVT_R4K)
 	return r4k_clockevent_init();
 #else
 	return -ENXIO;
diff -Nur linux-2.6.29.1/arch/mips/Kconfig linux-2.6.29.1-lemote/arch/mips/Kconfig
--- linux-2.6.29.1/arch/mips/Kconfig	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/Kconfig	2009-04-07 09:39:28.000000000 +0000
@@ -182,6 +182,13 @@
 	  Lemote Fulong mini-PC board based on the Chinese Loongson-2E CPU and
 	  an FPGA northbridge
 
+config MACH_LM2F
+	bool "Lemote Loongson2F based machines"
+	help 
+	  Loongson2F have built-in DDR2 and PCIX controller. The PCIX controller
+	  have a similar programming interface with FPGA northbridge used in
+	  Loongson2E.
+
 config MIPS_MALTA
 	bool "MIPS Malta board"
 	select ARCH_MAY_HAVE_PC_FDC
@@ -649,6 +656,7 @@
 source "arch/mips/txx9/Kconfig"
 source "arch/mips/vr41xx/Kconfig"
 source "arch/mips/cavium-octeon/Kconfig"
+source "arch/mips/lemote/lm2f/Kconfig"
 
 endmenu
 
@@ -1401,7 +1409,6 @@
 config 64BIT
 	bool "64-bit kernel"
 	depends on CPU_SUPPORTS_64BIT_KERNEL && SYS_SUPPORTS_64BIT_KERNEL
-	select HAVE_SYSCALL_WRAPPERS
 	help
 	  Select this option if you want to build a 64-bit kernel.
 
@@ -2126,6 +2133,9 @@
 
 menu "Power management options"
 
+config ARCH_HIBERNATION_POSSIBLE
+	def_bool y
+
 config ARCH_SUSPEND_POSSIBLE
 	def_bool y
 	depends on !SMP
@@ -2134,6 +2144,23 @@
 
 endmenu
 
+menu "CPU Frequency scaling"
+
+source "drivers/cpufreq/Kconfig"
+
+config LS2F_CPU_FREQ
+	bool "Loongson-2F CPU Frequency driver"
+	depends on CPU_LOONGSON2 && CPU_FREQ
+	select CPU_FREQ_TABLE
+	help
+	  This adds the cpufreq driver for Loongson-2F.
+
+	  For details, take a look at <file:Documentation/cpu-freq>.
+
+	  If unsure, say N.
+
+endmenu
+
 source "net/Kconfig"
 
 source "drivers/Kconfig"
diff -Nur linux-2.6.29.1/arch/mips/kernel/asm-offsets.c linux-2.6.29.1-lemote/arch/mips/kernel/asm-offsets.c
--- linux-2.6.29.1/arch/mips/kernel/asm-offsets.c	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/kernel/asm-offsets.c	2009-04-07 09:39:28.000000000 +0000
@@ -14,6 +14,7 @@
 #include <linux/mm.h>
 #include <linux/interrupt.h>
 #include <linux/kbuild.h>
+#include <linux/suspend.h>
 #include <asm/ptrace.h>
 #include <asm/processor.h>
 
@@ -326,3 +327,15 @@
 	BLANK();
 }
 #endif
+
+#ifdef CONFIG_HIBERNATION
+void output_pbe_defines(void)
+{
+ 	COMMENT(" Linux struct pbe offsets. ");
+ 	OFFSET(PBE_ADDRESS , pbe, address);
+ 	OFFSET(PBE_ORIG_ADDRESS  , pbe, orig_address);
+ 	OFFSET(PBE_NEXT  , pbe, next);
+ 	DEFINE(PBE_SIZE  , sizeof(struct pbe));
+ 	BLANK();
+}
+#endif
diff -Nur linux-2.6.29.1/arch/mips/kernel/cevt-smtc.c linux-2.6.29.1-lemote/arch/mips/kernel/cevt-smtc.c
--- linux-2.6.29.1/arch/mips/kernel/cevt-smtc.c	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/kernel/cevt-smtc.c	2009-04-07 09:39:28.000000000 +0000
@@ -245,7 +245,7 @@
 }
 
 
-int __cpuinit mips_clockevent_init(void)
+int __cpuinit smtc_clockevent_init(void)
 {
 	uint64_t mips_freq = mips_hpt_frequency;
 	unsigned int cpu = smp_processor_id();
diff -Nur linux-2.6.29.1/arch/mips/kernel/i8259.c linux-2.6.29.1-lemote/arch/mips/kernel/i8259.c
--- linux-2.6.29.1/arch/mips/kernel/i8259.c	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/kernel/i8259.c	2009-04-07 09:39:28.000000000 +0000
@@ -175,11 +175,13 @@
 	if (irq & 8) {
 		inb(PIC_SLAVE_IMR);	/* DUMMY - (do we need this?) */
 		outb(cached_slave_mask, PIC_SLAVE_IMR);
+		inb(PIC_SLAVE_IMR);
 		outb(0x60+(irq&7), PIC_SLAVE_CMD);/* 'Specific EOI' to slave */
 		outb(0x60+PIC_CASCADE_IR, PIC_MASTER_CMD); /* 'Specific EOI' to master-IRQ2 */
 	} else {
 		inb(PIC_MASTER_IMR);	/* DUMMY - (do we need this?) */
 		outb(cached_master_mask, PIC_MASTER_IMR);
+		inb(PIC_MASTER_IMR);
 		outb(0x60+irq, PIC_MASTER_CMD);	/* 'Specific EOI to master */
 	}
 	smtc_im_ack_irq(irq);
diff -Nur linux-2.6.29.1/arch/mips/kernel/ls2f_freq.c linux-2.6.29.1-lemote/arch/mips/kernel/ls2f_freq.c
--- linux-2.6.29.1/arch/mips/kernel/ls2f_freq.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/kernel/ls2f_freq.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,216 @@
+/*
+ * arch/mips/kernel/cpufreq.c
+ *
+ * cpufreq driver for the loongson-2f processors.
+ *
+ * Copyright (C) 2006 - 2008 Yanhua
+ *
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/types.h>
+#include <linux/cpufreq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/cpumask.h>
+#include <linux/smp.h>
+#include <linux/sched.h>	/* set_cpus_allowed() */
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <asm/delay.h>
+
+#include <asm/clock.h>
+
+static uint nowait = 0;
+
+static struct clk *cpuclk;
+extern unsigned long cpu_clock_freq;
+extern struct cpufreq_frequency_table ls2f_clockmod_table[];
+
+extern void (*cpu_wait)(void);
+extern void ls2f_cpu_wait(void);
+static void (*saved_cpu_wait)(void);
+
+static int
+ls2f_cpu_freq_notifier(struct notifier_block *nb, unsigned long val,
+	void *data);
+
+static struct notifier_block ls2f_cpufreq_notifier_block = {
+	.notifier_call = ls2f_cpu_freq_notifier
+};
+
+static int
+ls2f_cpu_freq_notifier(struct notifier_block *nb, unsigned long val, void *data)
+{
+	if (val == CPUFREQ_POSTCHANGE) {
+		__udelay_val = loops_per_jiffy;
+	}
+	return 0;
+}
+
+static unsigned int ls2f_cpufreq_get(unsigned int cpu)
+{
+	return clk_get_rate(cpuclk);
+}
+
+/*
+ * Here we notify other drivers of the proposed change and the final change.
+ */
+static int ls2f_cpufreq_target(struct cpufreq_policy *policy,
+			     unsigned int target_freq,
+			     unsigned int relation)
+{
+	unsigned int cpu = policy->cpu;
+	unsigned int newstate = 0;
+	cpumask_t cpus_allowed;
+	struct cpufreq_freqs freqs;
+	long freq;
+
+	if (!cpu_online(cpu))
+		return -ENODEV;
+
+	cpus_allowed = current->cpus_allowed;
+	set_cpus_allowed(current, cpumask_of_cpu(cpu));
+
+#ifdef CONFIG_SMP
+	BUG_ON(smp_processor_id() != cpu);
+#endif
+
+	if (cpufreq_frequency_table_target(policy, &ls2f_clockmod_table[0], target_freq, relation, &newstate))
+		return -EINVAL;
+
+	freq = cpu_clock_freq / 1000 * ls2f_clockmod_table[newstate].index / 8;
+	if (freq < policy->min || freq > policy->max )
+		return -EINVAL;
+
+	pr_debug("cpufreq: requested frequency %u Hz\n", target_freq * 1000);
+
+	freqs.cpu	= cpu;
+	freqs.old	= ls2f_cpufreq_get(cpu);
+	freqs.new	= freq;
+	freqs.flags	= 0;
+
+	if (freqs.new == freqs.old)
+		return 0;
+
+	/* notifiers */
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	set_cpus_allowed(current, cpus_allowed);
+
+	/* setting the cpu frequency */
+	clk_set_rate(cpuclk, freq);
+
+	/* notifiers */
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+	pr_debug("cpufreq: set frequency %lu kHz\n", freq);
+
+	return 0;
+}
+
+static int ls2f_cpufreq_cpu_init(struct cpufreq_policy *policy)
+{
+	int i;
+	int result;
+
+	if (!cpu_online(policy->cpu))
+		return -ENODEV;
+
+	cpuclk = clk_get(NULL, "cpu_clk");
+	if (IS_ERR(cpuclk)) {
+		printk(KERN_ERR "cpufreq: couldn't get CPU clk\n");
+		return PTR_ERR(cpuclk);
+	}
+	
+	cpuclk->rate = cpu_clock_freq / 1000;
+	if(!cpuclk->rate)
+		return -EINVAL;
+
+	/* clock table init */
+	for (i=2; (ls2f_clockmod_table[i].frequency != CPUFREQ_TABLE_END); i++) {
+		ls2f_clockmod_table[i].frequency = (cpuclk->rate * i)/8;
+	}
+
+	policy->cur	= ls2f_cpufreq_get(policy->cpu);
+
+	cpufreq_frequency_table_get_attr(&ls2f_clockmod_table[0], policy->cpu);
+
+	result = cpufreq_frequency_table_cpuinfo(policy, &ls2f_clockmod_table[0]);
+	if (result)
+		return (result);
+
+	return 0;
+}
+
+static int ls2f_cpufreq_verify(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy, &ls2f_clockmod_table[0]);
+}
+
+static int ls2f_cpufreq_exit(struct cpufreq_policy *policy)
+{
+	clk_put(cpuclk);
+	return 0;
+}
+
+static struct freq_attr* ls2f_table_attr[] = {
+	&cpufreq_freq_attr_scaling_available_freqs,
+	NULL,
+};
+
+static struct cpufreq_driver ls2f_cpufreq_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "ls2f",
+	.init		= ls2f_cpufreq_cpu_init,
+	.verify		= ls2f_cpufreq_verify,
+	.target		= ls2f_cpufreq_target,
+	.get		= ls2f_cpufreq_get,
+	.exit		= ls2f_cpufreq_exit,
+	.attr		= ls2f_table_attr,
+};
+
+static int __init ls2f_cpufreq_module_init(void)
+{
+	struct cpuinfo_mips *c = &cpu_data[0];
+	int result;
+	
+	if (c->processor_id != 0x6303)
+		return -ENODEV;
+
+	printk(KERN_INFO "cpufreq: Loongson-2F CPU frequency driver.\n");
+	result =  cpufreq_register_driver(&ls2f_cpufreq_driver);
+
+	if(!result && !nowait) {
+		saved_cpu_wait = cpu_wait;
+		cpu_wait = ls2f_cpu_wait;
+	}
+
+	cpufreq_register_notifier(&ls2f_cpufreq_notifier_block,
+				CPUFREQ_TRANSITION_NOTIFIER);
+	return result;
+}
+
+static void __exit ls2f_cpufreq_module_exit(void)
+{
+	if(!nowait && saved_cpu_wait)
+		cpu_wait = saved_cpu_wait;
+	cpufreq_unregister_driver(&ls2f_cpufreq_driver);
+	cpufreq_unregister_notifier(&ls2f_cpufreq_notifier_block, 
+				CPUFREQ_TRANSITION_NOTIFIER);
+}
+
+//late_initcall(ls2f_cpufreq_module_init);
+module_init(ls2f_cpufreq_module_init);
+module_exit(ls2f_cpufreq_module_exit);
+
+module_param(nowait, uint, 0644);
+MODULE_PARM_DESC(nowait, "Disable Loongson-2F specific wait");
+
+MODULE_AUTHOR("Yanhua <yanh@lemote.com>");
+MODULE_DESCRIPTION("cpufreq driver for Loongson2F");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29.1/arch/mips/kernel/Makefile linux-2.6.29.1-lemote/arch/mips/kernel/Makefile
--- linux-2.6.29.1/arch/mips/kernel/Makefile	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/kernel/Makefile	2009-04-07 09:39:28.000000000 +0000
@@ -73,6 +73,7 @@
 obj-$(CONFIG_MIPS32_COMPAT)	+= linux32.o ptrace32.o signal32.o
 obj-$(CONFIG_MIPS32_N32)	+= binfmt_elfn32.o scall64-n32.o signal_n32.o
 obj-$(CONFIG_MIPS32_O32)	+= binfmt_elfo32.o scall64-o32.o
+obj-$(CONFIG_LS2F_CPU_FREQ) += ls2f_freq.o
 
 obj-$(CONFIG_KGDB)		+= kgdb.o
 obj-$(CONFIG_PROC_FS)		+= proc.o
diff -Nur linux-2.6.29.1/arch/mips/kernel/traps.c linux-2.6.29.1-lemote/arch/mips/kernel/traps.c
--- linux-2.6.29.1/arch/mips/kernel/traps.c	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/kernel/traps.c	2009-04-07 09:39:28.000000000 +0000
@@ -1520,7 +1520,9 @@
 #endif /* CONFIG_MIPS_MT_SMTC */
 
 	if (cpu_has_veic || cpu_has_vint) {
+		unsigned long sr = set_c0_status(ST0_BEV);
 		write_c0_ebase(ebase);
+		write_c0_status(sr);
 		/* Setting vector spacing enables EI/VI mode  */
 		change_c0_intctl(0x3e0, VECTORSPACING);
 	}
@@ -1602,8 +1604,6 @@
 #ifdef CONFIG_64BIT
 	unsigned long uncached_ebase = TO_UNCAC(ebase);
 #endif
-	if (cpu_has_mips_r2)
-		uncached_ebase += (read_c0_ebase() & 0x3ffff000);
 
 	if (!addr)
 		panic(panic_null_cerr);
@@ -1635,9 +1635,11 @@
 		return;	/* Already done */
 #endif
 
-	if (cpu_has_veic || cpu_has_vint)
-		ebase = (unsigned long) alloc_bootmem_low_pages(0x200 + VECTORSPACING*64);
-	else {
+	if (cpu_has_veic || cpu_has_vint) {
+		unsigned long size = 0x200 + VECTORSPACING*64;
+		ebase = (unsigned long)
+			__alloc_bootmem(size, 1 << fls(size), 0);
+	} else {
 		ebase = CAC_BASE;
 		if (cpu_has_mips_r2)
 			ebase += (read_c0_ebase() & 0x3ffff000);
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/common/clock.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/clock.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/common/clock.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/clock.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,160 @@
+#include <linux/cpufreq.h>
+#include <linux/platform_device.h>
+#include <asm/clock.h>
+
+#ifdef CONFIG_64BIT
+#define PTR_PAD(p) ((0xffffffff00000000)|((unsigned long)(p)))
+#else
+#define PTR_PAD(p) (p)
+#endif
+
+static LIST_HEAD(clock_list);
+static DEFINE_SPINLOCK(clock_lock);
+static DEFINE_MUTEX(clock_list_sem);
+
+/* Minimum CLK support */
+enum {
+	DC_ZERO, DC_25PT=2, DC_37PT, DC_50PT, DC_62PT, DC_75PT,
+	DC_87PT, DC_DISABLE, DC_RESV
+};
+
+struct cpufreq_frequency_table ls2f_clockmod_table[] = {
+	{DC_RESV, CPUFREQ_ENTRY_INVALID},
+	{DC_ZERO, CPUFREQ_ENTRY_INVALID},
+	{DC_25PT, 0},
+	{DC_37PT, 0},
+	{DC_50PT, 0},
+	{DC_62PT, 0},
+	{DC_75PT, 0},
+	{DC_87PT, 0},
+	{DC_DISABLE, 0},
+	{DC_RESV, CPUFREQ_TABLE_END},
+};
+
+
+static struct clk cpu_clk = {
+	.name		= "cpu_clk",
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+	.rate		= 800000000,
+};
+
+struct clk *clk_get(struct device *dev, const char *id)
+{
+	return &cpu_clk;
+}
+EXPORT_SYMBOL(clk_get);
+
+static void propagate_rate(struct clk *clk)
+{
+	struct clk *clkp;
+
+	list_for_each_entry(clkp, &clock_list, node) {
+		if (likely(clkp->parent != clk))
+			continue;
+		if (likely(clkp->ops && clkp->ops->recalc))
+			clkp->ops->recalc(clkp);
+		if (unlikely(clkp->flags & CLK_RATE_PROPAGATES))
+			propagate_rate(clkp);
+	}
+}
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return (unsigned long)clk->rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+void clk_put(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_put);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	return clk_set_rate_ex(clk, rate, 0);
+}
+EXPORT_SYMBOL_GPL(clk_set_rate);
+
+int clk_set_rate_ex(struct clk *clk, unsigned long rate, int algo_id)
+{
+	//int ret = -EOPNOTSUPP;
+	int ret = 0; //-EOPNOTSUPP;
+	int regval;
+	int i;
+
+	if (likely(clk->ops && clk->ops->set_rate)) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&clock_lock, flags);
+		ret = clk->ops->set_rate(clk, rate, algo_id);
+		spin_unlock_irqrestore(&clock_lock, flags);
+	}
+
+	if (unlikely(clk->flags & CLK_RATE_PROPAGATES))
+		propagate_rate(clk);
+	
+	for (i =0; ls2f_clockmod_table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		if (ls2f_clockmod_table[i].frequency == CPUFREQ_ENTRY_INVALID)
+			continue;
+		if (rate == ls2f_clockmod_table[i].frequency)
+			break;
+	}
+	if (rate != ls2f_clockmod_table[i].frequency)
+		return -ENOTSUPP;
+
+	clk->rate = rate;
+
+	regval = *(volatile unsigned int*) PTR_PAD(0xbfe00180);
+	regval = (regval & ~0x7) | (ls2f_clockmod_table[i].index -1);
+	*(volatile unsigned int *) PTR_PAD(0xbfe00180) = regval;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clk_set_rate_ex);
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	if (likely(clk->ops && clk->ops->round_rate)) {
+		unsigned long flags, rounded;
+
+		spin_lock_irqsave(&clock_lock, flags);
+		rounded = clk->ops->round_rate(clk, rate);
+		spin_unlock_irqrestore(&clock_lock, flags);
+
+		return rounded;
+	}
+
+	return rate; //clk_get_rate(clk);
+}
+EXPORT_SYMBOL_GPL(clk_round_rate);
+
+/*
+ * This is the simple version of Loongson-2F wait
+ * Maybe we need do this in interrupt disabled content
+ */
+DEFINE_SPINLOCK(ls2f_wait_lock);
+void ls2f_cpu_wait(void)
+{
+	u32 cpu_freq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ls2f_wait_lock, flags);	
+	cpu_freq = *(volatile u32*)PTR_PAD(0xbfe00180);
+	*(volatile u32*)PTR_PAD(0xbfe00180) &= ~0x7;  //Put CPU into wait mode
+	*(volatile u32*)PTR_PAD(0xbfe00180) = cpu_freq; //Restore CPU state
+	spin_unlock_irqrestore(&ls2f_wait_lock, flags);
+}
+
+EXPORT_SYMBOL_GPL(ls2f_cpu_wait);
+EXPORT_SYMBOL_GPL(ls2f_clockmod_table);
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/common/cs5536.h linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/cs5536.h
--- linux-2.6.29.1/arch/mips/lemote/lm2f/common/cs5536.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/cs5536.h	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,578 @@
+/*
+ * cs5536.h
+ * 
+ * The include file of cs5536 sourthbridge define which is used in the pmon only.
+ * you can modify it or change it, please set the modify time and steps.
+ *
+ * Author : jlliu <liujl@lemote.com>
+ * Data : 07-6-27
+ */
+
+#ifndef	_CS5536_H
+#define	_CS5536_H
+
+/*************************************************************************/
+
+/*
+ * basic define
+ */
+#define	PCI_IO_BASE		0x1fd00000	//( < 0x1fe00000)
+#define	PCI_IO_BASE_VA		0xbfd00000
+#define	PCI_MEM_BASE		0x10000000	//( < 0x1c000000 )
+#define	PCI_MEM_BASE_VA		0xb0000000
+
+/*
+ * MSR module base
+ */ 
+#define	CS5536_SB_MSR_BASE		(0x00000000)
+#define	CS5536_GLIU_MSR_BASE		(0x10000000)
+#define	CS5536_ILLEGAL_MSR_BASE		(0x20000000)
+#define	CS5536_USB_MSR_BASE		(0x40000000)
+#define	CS5536_IDE_MSR_BASE		(0x60000000)
+#define	CS5536_DIVIL_MSR_BASE		(0x80000000)
+#define	CS5536_ACC_MSR_BASE		(0xa0000000)
+#define	CS5536_UNUSED_MSR_BASE		(0xc0000000)
+#define	CS5536_GLCP_MSR_BASE		(0xe0000000)
+
+#define	SB_MSR_REG(offset)	(CS5536_SB_MSR_BASE	| offset)
+#define	GLIU_MSR_REG(offset)	(CS5536_GLIU_MSR_BASE	| offset)
+#define	ILLEGAL_MSR_REG(offset)	(CS5536_ILLEGAL_MSR_BASE| offset)
+#define	USB_MSR_REG(offset)	(CS5536_USB_MSR_BASE	| offset)
+#define	IDE_MSR_REG(offset)	(CS5536_IDE_MSR_BASE	| offset)
+#define	DIVIL_MSR_REG(offset)	(CS5536_DIVIL_MSR_BASE	| offset)
+#define	ACC_MSR_REG(offset)	(CS5536_ACC_MSR_BASE	| offset)
+#define	UNUSED_MSR_REG(offset)	(CS5536_UNUSED_MSR_BASE	| offset)
+#define	GLCP_MSR_REG(offset)	(CS5536_GLCP_MSR_BASE	| offset)
+
+/*
+ * BAR SPACE OF VIRTUAL PCI : range for pci probe use, length is the actual size. 
+ */
+// IO space for all DIVIL modules
+#define	CS5536_IRQ_RANGE		0xffffffe0	// USERD FOR PCI PROBE
+#define	CS5536_IRQ_LENGTH		0x20		// THE REGS ACTUAL LENGTH
+#define	CS5536_SMB_RANGE		0xfffffff8
+#define	CS5536_SMB_LENGTH		0x08
+#define	CS5536_GPIO_RANGE		0xffffff00
+#define	CS5536_GPIO_LENGTH		0x100
+#define	CS5536_MFGPT_RANGE		0xffffffc0
+#define	CS5536_MFGPT_LENGTH		0x40
+#define	CS5536_ACPI_RANGE		0xffffffe0
+#define	CS5536_ACPI_LENGTH		0x20
+#define	CS5536_PMS_RANGE		0xffffff80
+#define	CS5536_PMS_LENGTH		0x80
+// MEM space for 4KB nand flash; IO space for 16B nor flash.
+#ifdef	CS5536_USE_NOR_FLASH
+#define	CS5536_FLSH0_RANGE	0xfffffff0
+#define	CS5536_FLSH0_LENGTH	0x10
+#define	CS5536_FLSH1_RANGE	0xfffffff0
+#define	CS5536_FLSH1_LENGTH	0x10
+#define	CS5536_FLSH2_RANGE	0xfffffff0
+#define	CS5536_FLSH2_LENGTH	0x10
+#define	CS5536_FLSH3_RANGE	0xfffffff0
+#define	CS5536_FLSH3_LENGTH	0x10
+#else
+#define	CS5536_FLSH0_RANGE	0xfffff000
+#define	CS5536_FLSH0_LENGTH	0x1000
+#define	CS5536_FLSH1_RANGE	0xfffff000
+#define	CS5536_FLSH1_LENGTH	0x1000
+#define	CS5536_FLSH2_RANGE	0xfffff000
+#define	CS5536_FLSH2_LENGTH	0x1000
+#define	CS5536_FLSH3_RANGE	0xfffff000
+#define	CS5536_FLSH3_LENGTH	0x1000
+#endif
+// IO space for IDE
+#define	CS5536_IDE_RANGE	0xfffffff0
+#define	CS5536_IDE_LENGTH	0x10
+// IO space for ACC
+#define	CS5536_ACC_RANGE	0xffffff80
+#define	CS5536_ACC_LENGTH	0x80
+// MEM space for ALL USB modules
+//#define	CS5536_OHCI_RANGE	0xfffffff0
+#define	CS5536_OHCI_RANGE	0xfffff000
+#define	CS5536_OHCI_LENGTH	0x1000
+//#define	CS5536_EHCI_RANGE	0xfffffff0
+#define	CS5536_EHCI_RANGE	0xfffff000
+#define	CS5536_EHCI_LENGTH	0x1000
+#define	CS5536_UDC_RANGE	0xffffe000
+#define	CS5536_UDC_LENGTH	0x2000
+#define	CS5536_OTG_RANGE	0xfffff000
+#define	CS5536_OTG_LENGTH	0x1000
+
+/*
+ * PCI MSR ACCESS
+ */
+#define	PCI_MSR_CTRL		0xF0
+#define	PCI_MSR_ADDR		0xF4
+#define	PCI_MSR_DATA_LO		0xF8
+#define	PCI_MSR_DATA_HI		0xFC
+
+/******************************* MSR *********************************************/
+
+/*
+ * GLIU STANDARD MSR
+ */
+#define	GLIU_CAP		0x00
+#define	GLIU_CONFIG		0x01
+#define	GLIU_SMI		0x02
+#define	GLIU_ERROR		0x03
+#define	GLIU_PM			0x04
+#define	GLIU_DIAG		0x05
+
+/*
+ * GLIU SPEC. MSR
+ */
+#define	GLIU_P2D_BM0		0x20 
+#define	GLIU_P2D_BM1		0x21 
+#define	GLIU_P2D_BM2		0x22 
+#define	GLIU_P2D_BMK0		0x23
+#define	GLIU_P2D_BMK1		0x24
+#define	GLIU_P2D_BM3		0x25 
+#define	GLIU_P2D_BM4		0x26 
+#define	GLIU_COH		0x80
+#define	GLIU_PAE		0x81	
+#define	GLIU_ARB		0x82
+#define	GLIU_ASMI		0x83
+#define	GLIU_AERR		0x84
+#define	GLIU_DEBUG		0x85
+#define	GLIU_PHY_CAP		0x86
+#define	GLIU_NOUT_RESP		0x87
+#define	GLIU_NOUT_WDATA		0x88
+#define	GLIU_WHOAMI		0x8B
+#define	GLIU_SLV_DIS		0x8C
+#define	GLIU_IOD_BM0		0xE0
+#define	GLIU_IOD_BM1		0xE1
+#define	GLIU_IOD_BM2		0xE2
+#define	GLIU_IOD_BM3		0xE3
+#define	GLIU_IOD_BM4		0xE4
+#define	GLIU_IOD_BM5		0xE5
+#define	GLIU_IOD_BM6		0xE6
+#define	GLIU_IOD_BM7		0xE7
+#define	GLIU_IOD_BM8		0xE8
+#define	GLIU_IOD_BM9		0xE9
+#define	GLIU_IOD_SC0		0xEA
+#define	GLIU_IOD_SC1		0xEB
+#define	GLIU_IOD_SC2		0xEC
+#define	GLIU_IOD_SC3		0xED
+#define	GLIU_IOD_SC4		0xEE
+#define	GLIU_IOD_SC5		0xEF
+#define	GLIU_IOD_SC6		0xF0
+#define	GLIU_IOD_SC7		0xF1
+
+/*
+ * SB STANDARD
+ */
+#define	SB_CAP		0x00
+#define	SB_CONFIG	0x01
+#define	SB_SMI		0x02
+#define	SB_ERROR	0x03
+#define	SB_MAR_ERR_EN		0x00000001
+#define	SB_TAR_ERR_EN		0x00000002
+#define	SB_RSVD_BIT1		0x00000004
+#define	SB_EXCEP_ERR_EN		0x00000008
+#define	SB_SYSE_ERR_EN		0x00000010
+#define	SB_PARE_ERR_EN		0x00000020
+#define	SB_TAS_ERR_EN		0x00000040
+#define	SB_MAR_ERR_FLAG		0x00010000
+#define	SB_TAR_ERR_FLAG		0x00020000
+#define	SB_RSVD_BIT2		0x00040000
+#define	SB_EXCEP_ERR_FLAG	0x00080000
+#define	SB_SYSE_ERR_FLAG	0x00100000
+#define	SB_PARE_ERR_FLAG	0x00200000
+#define	SB_TAS_ERR_FLAG		0x00400000
+#define	SB_PM		0x04
+#define	SB_DIAG		0x05
+
+/*
+ * SB SPEC.
+ */
+#define	SB_CTRL		0x10
+#define	SB_R0		0x20
+#define	SB_R1		0x21
+#define	SB_R2		0x22
+#define	SB_R3		0x23
+#define	SB_R4		0x24
+#define	SB_R5		0x25
+#define	SB_R6		0x26
+#define	SB_R7		0x27
+#define	SB_R8		0x28
+#define	SB_R9		0x29
+#define	SB_R10		0x2A
+#define	SB_R11		0x2B
+#define	SB_R12		0x2C
+#define	SB_R13		0x2D
+#define	SB_R14		0x2E
+#define	SB_R15		0x2F
+
+/*
+ * GLCP STANDARD
+ */
+#define	GLCP_CAP		0x00
+#define	GLCP_CONFIG		0x01
+#define	GLCP_SMI		0x02
+#define	GLCP_ERROR		0x03
+#define	GLCP_PM			0x04
+#define	GLCP_DIAG		0x05
+
+/*
+ * GLCP SPEC. 
+ */
+#define	GLCP_CLK_DIS_DELAY	0x08
+#define	GLCP_PM_CLK_DISABLE	0x09
+#define	GLCP_GLB_PM		0x0B
+#define	GLCP_DBG_OUT		0x0C
+#define	GLCP_RSVD1		0x0D
+#define	GLCP_SOFT_COM		0x0E
+#define	SOFT_BAR_SMB_FLAG		0x00000001
+#define	SOFT_BAR_GPIO_FLAG		0x00000002
+#define	SOFT_BAR_MFGPT_FLAG		0x00000004
+#define	SOFT_BAR_IRQ_FLAG		0x00000008
+#define	SOFT_BAR_PMS_FLAG		0x00000010
+#define	SOFT_BAR_ACPI_FLAG		0x00000020
+#define	SOFT_BAR_FLSH0_FLAG		0x00000040
+#define	SOFT_BAR_FLSH1_FLAG		0x00000080
+#define	SOFT_BAR_FLSH2_FLAG		0x00000100
+#define	SOFT_BAR_FLSH3_FLAG		0x00000200
+#define	SOFT_BAR_IDE_FLAG		0x00000400
+#define	SOFT_BAR_ACC_FLAG		0x00000800
+#define	SOFT_BAR_OHCI_FLAG		0x00001000
+#define	SOFT_BAR_EHCI_FLAG		0x00002000
+#define	SOFT_BAR_UDC_FLAG		0x00004000
+#define	SOFT_BAR_OTG_FLAG		0x00008000
+#define	GLCP_RSVD2		0x0F
+#define	GLCP_CLK_OFF		0x10
+#define	GLCP_CLK_ACTIVE		0x11
+#define	GLCP_CLK_DISABLE	0x12
+#define	GLCP_CLK4ACK		0x13
+#define	GLCP_SYS_RST		0x14
+#define	GLCP_RSVD3		0x15
+#define	GLCP_DBG_CLK_CTRL	0x16
+#define	GLCP_CHIP_REV_ID	0x17
+
+/*
+ * DIVIL STANDARD
+ */
+#define	DIVIL_CAP		0x00
+#define	DIVIL_CONFIG		0x01
+#define	DIVIL_SMI		0x02
+#define	DIVIL_ERROR		0x03
+#define	DIVIL_PM		0x04
+#define	DIVIL_DIAG		0x05
+
+/*
+ * DIVIL SPEC. 
+ */
+#define	DIVIL_LBAR_IRQ		0x08
+#define	DIVIL_LBAR_KEL		0x09
+#define	DIVIL_LBAR_SMB		0x0B
+#define	DIVIL_LBAR_GPIO		0x0C
+#define	DIVIL_LBAR_MFGPT	0x0D
+#define	DIVIL_LBAR_ACPI		0x0E
+#define	DIVIL_LBAR_PMS		0x0F
+#define	DIVIL_LBAR_FLSH0	0x10
+#define	DIVIL_LBAR_FLSH1	0x11
+#define	DIVIL_LBAR_FLSH2	0x12
+#define	DIVIL_LBAR_FLSH3	0x13
+#define	DIVIL_LEG_IO		0x14
+#define	DIVIL_BALL_OPTS		0x15
+#define	DIVIL_SOFT_IRQ		0x16
+#define	DIVIL_SOFT_RESET	0x17
+// NOR FLASH
+#define	NORF_CTRL		0x18
+#define	NORF_T01		0x19
+#define	NORF_T23		0x1A
+// NAND FLASH
+#define	NANDF_DATA		0x1B
+#define	NANDF_CTRL		0x1C
+#define	NANDF_RSVD		0x1D
+// KEL Keyboard Emulation Logic
+#define	KEL_CTRL		0x1F
+// PIC
+#define	PIC_YSEL_LOW		0x20
+#define	PIC_YSEL_LOW_USB_SHIFT		8
+#define	PIC_YSEL_LOW_ACC_SHIFT		16
+#define	PIC_YSEL_LOW_FLASH_SHIFT	24
+#define	PIC_YSEL_HIGH		0x21
+#define	PIC_ZSEL_LOW		0x22
+#define	PIC_ZSEL_HIGH		0x23
+#define	PIC_IRQM_PRIM		0x24
+#define	PIC_IRQM_LPC		0x25
+#define	PIC_XIRR_STS_LOW	0x26
+#define	PIC_XIRR_STS_HIGH	0x27
+#define	PCI_SHDW		0x34
+// MFGPT
+#define	MFGPT_IRQ		0x28
+#define	MFGPT_NR		0x29
+#define	MFGPT_RSVD		0x2A
+#define	MFGPT_SETUP		0x2B
+// FLOPPY
+#define	FLPY_3F2_SHDW		0x30
+#define	FLPY_3F7_SHDW		0x31
+#define	FLPY_372_SHDW		0x32
+#define	FLPY_377_SHDW		0x33
+// PIT
+#define	PIT_SHDW		0x36
+#define	PIT_CNTRL		0x37
+// UART
+#define	UART1_MOD		0x38
+#define	UART1_DONG		0x39
+#define	UART1_CONF		0x3A
+#define	UART1_RSVD		0x3B
+#define	UART2_MOD		0x3C
+#define	UART2_DONG		0x3D
+#define	UART2_CONF		0x3E
+#define	UART2_RSVD		0x3F
+// DMA
+#define	DIVIL_AC_DMA		0x1E
+#define	DMA_MAP			0x40
+#define	DMA_SHDW_CH0		0x41
+#define	DMA_SHDW_CH1		0x42
+#define	DMA_SHDW_CH2		0x43
+#define	DMA_SHDW_CH3		0x44
+#define	DMA_SHDW_CH4		0x45
+#define	DMA_SHDW_CH5		0x46
+#define	DMA_SHDW_CH6		0x47
+#define	DMA_SHDW_CH7		0x48
+#define	DMA_MSK_SHDW		0x49
+// LPC
+#define	LPC_EADDR		0x4C
+#define	LPC_ESTAT		0x4D
+#define	LPC_SIRQ		0x4E
+#define	LPC_RSVD		0x4F
+// PMC
+#define	PMC_LTMR		0x50
+#define	PMC_RSVD		0x51
+// RTC
+#define	RTC_RAM_LOCK		0x54
+#define	RTC_DOMA_OFFSET		0x55
+#define	RTC_MONA_OFFSET		0x56
+#define	RTC_CEN_OFFSET		0x57
+
+/*
+ * IDE STANDARD 
+ */
+#define	IDE_CAP		0x00
+#define	IDE_CONFIG	0x01
+#define	IDE_SMI		0x02
+#define	IDE_ERROR	0x03
+#define	IDE_PM		0x04
+#define	IDE_DIAG	0x05
+
+/*
+ * IDE SPEC. 
+ */
+#define	IDE_IO_BAR	0x08
+#define	IDE_CFG		0x10
+#define	IDE_DTC		0x12
+#define	IDE_CAST	0x13
+#define	IDE_ETC		0x14
+#define	IDE_INTERNAL_PM	0x15
+
+/*
+ * ACC STANDARD
+ */
+#define	ACC_CAP		0x00
+#define	ACC_CONFIG	0x01
+#define	ACC_SMI		0x02
+#define	ACC_ERROR	0x03
+#define	ACC_PM		0x04
+#define	ACC_DIAG	0x05
+
+/*
+ * USB STANDARD
+ */
+#define	USB_CAP		0x00
+#define	USB_CONFIG	0x01
+#define	USB_SMI		0x02
+#define	USB_ERROR	0x03
+#define	USB_PM		0x04
+#define	USB_DIAG	0x05
+
+/*
+ * USB SPEC.
+ */
+#define	USB_OHCI	0x08
+#define	USB_EHCI	0x09
+#define	USB_UDC		0x0A
+#define	USB_OTG		0x0B
+
+/********************************** NATIVE ****************************************/
+// IDE NATIVE registers
+#define	IDE_BM_CMD	0x00
+#define	IDE_BM_STS	0x02
+#define	IDE_BM_PRD	0x04
+
+// OHCI native registers
+#define	OHCI_REVISION		0x00
+#define	OHCI_CONTROL		0x04
+#define	OHCI_COMMAND_STATUS	0x08
+#define	OHCI_INT_STATUS		0x0C
+#define	OHCI_INT_ENABLE		0x10
+#define	OHCI_INT_DISABLE	0x14
+#define	OHCI_HCCA		0x18
+#define	OHCI_PERI_CUR_ED	0x1C
+#define	OHCI_CTRL_HEAD_ED	0x20
+#define	OHCI_CTRL_CUR_ED	0x24
+#define	OHCI_BULK_HEAD_ED	0x28
+#define	OHCI_BULK_CUR_ED	0x2C
+#define	OHCI_DONE_HEAD		0x30
+#define	OHCI_FM_INTERVAL	0x34
+#define	OHCI_FM_REMAINING	0x38
+#define	OHCI_FM_NUMBER		0x3C
+#define	OHCI_PERI_START		0x40
+#define	OHCI_LS_THRESHOLD	0x44
+#define	OHCI_RH_DESCRIPTORA	0x48
+#define	OHCI_RH_DESCRIPTORB	0x4C
+#define	OHCI_RH_STATUS		0x50
+#define	OHCI_RH_PORT_STATUS1	0x54
+#define	OHCI_RH_PORT_STATUS2	0x58
+#define	OHCI_RH_PORT_STATUS3	0x5C
+#define	OHCI_RH_PORT_STATUS4	0x60
+
+// KEL : MEM SPACE; REG :32BITS WIDTH
+#define	KEL_HCE_CTRL	0x100
+#define	KEL_HCE_IN	0x104
+#define	KEL_HCE_OUT	0x108
+#define	KEL_HCE_STS	0x10C
+#define	KEL_PORTA	0x92	//8bits
+// PIC : I/O SPACE; REG : 8BITS
+#define	PIC_ICW1_MASTER	0x20
+#define	PIC_ICW1_SLAVE	0xA0
+#define	PIC_ICW2_MASTER	0x21
+#define	PIC_ICW2_SLAVE	0xA1
+#define	PIC_ICW3_MASTER	0x21
+#define	PIC_ICW3_SLAVE	0xA1
+#define	PIC_ICW4_MASTER	0x21
+#define	PIC_ICW4_SLAVE	0xA1
+#define	PIC_OCW1_MASTER	0x21
+#define	PIC_OCW1_SLAVE	0xA1
+#define	PIC_OCW2_MASTER	0x20
+#define	PIC_OCW2_SLAVE	0xA0
+#define	PIC_OCW3_MASTER	0x20
+#define	PIC_OCW3_SLAVE	0xA0
+#define	PIC_IRR_MASTER	0x20
+#define	PIC_IRR_SLAVE	0xA0
+#define	PIC_ISR_MASTER	0x20
+#define	PIC_ISR_SLAVE	0xA0
+#define	PIC_INT_SEL1	0x4D0
+#define	PIC_INT_SEL2	0x4D1
+// GPIO : I/O SPACE; REG : 32BITS
+#define	GPIOL_OUT_VAL		0x00
+#define	GPIOL_OUT_EN		0x04
+#define	GPIOL_OUT_OD_EN		0x08
+#define	GPIOL_OUT_INVRT_EN	0x0c
+#define	GPIOL_OUT_AUX1_SEL	0x10
+#define	GPIOL_OUT_AUX2_SEL	0x14
+#define	GPIOL_PU_EN		0x18
+#define	GPIOL_PD_EN		0x1c
+#define	GPIOL_IN_EN		0x20
+#define	GPIOL_IN_INVRT_EN	0x24
+#define	GPIOL_IN_FLTR_EN	0x28
+#define	GPIOL_IN_EVNTCNT_EN	0x2c
+#define	GPIOL_IN_READBACK	0x30
+#define	GPIOL_IN_AUX1_SEL	0x34
+#define	GPIOL_EVNT_EN		0x38
+#define	GPIOL_LOCK_EN		0x3c
+#define	GPIOL_IN_POSEDGE_EN	0x40
+#define	GPIOL_IN_NEGEDGE_EN	0x44
+#define	GPIOL_IN_POSEDGE_STS	0x48
+#define	GPIOL_IN_NEGEDGE_STS	0x4c
+#define	GPIOH_OUT_VAL		0x80
+#define	GPIOH_OUT_EN		0x84
+#define	GPIOH_OUT_OD_EN		0x88
+#define	GPIOH_OUT_INVRT_EN	0x8c
+#define	GPIOH_OUT_AUX1_SEL	0x90
+#define	GPIOH_OUT_AUX2_SEL	0x94
+#define	GPIOH_PU_EN		0x98
+#define	GPIOH_PD_EN		0x9c
+#define	GPIOH_IN_EN		0xA0
+#define	GPIOH_IN_INVRT_EN	0xA4
+#define	GPIOH_IN_FLTR_EN	0xA8
+#define	GPIOH_IN_EVNTCNT_EN	0xAc
+#define	GPIOH_IN_READBACK	0xB0
+#define	GPIOH_IN_AUX1_SEL	0xB4
+#define	GPIOH_EVNT_EN		0xB8
+#define	GPIOH_LOCK_EN		0xBc
+#define	GPIOH_IN_POSEDGE_EN	0xC0
+#define	GPIOH_IN_NEGEDGE_EN	0xC4
+#define	GPIOH_IN_POSEDGE_STS	0xC8
+#define	GPIOH_IN_NEGEDGE_STS	0xCC
+// SMB : I/O SPACE, REG : 8BITS WIDTH
+#define	SMB_SDA				0x00
+#define	SMB_STS				0x01
+#define	SMB_STS_SLVSTP		(1 << 7)
+#define	SMB_STS_SDAST		(1 << 6)
+#define	SMB_STS_BER		(1 << 5)
+#define	SMB_STS_NEGACK		(1 << 4)
+#define	SMB_STS_STASTR		(1 << 3)
+#define	SMB_STS_NMATCH		(1 << 2)
+#define	SMB_STS_MASTER		(1 << 1)
+#define	SMB_STS_XMIT		(1 << 0)
+#define	SMB_CTRL_STS			0x02
+#define	SMB_CSTS_TGSTL		(1 << 5)
+#define	SMB_CSTS_TSDA		(1 << 4)
+#define	SMB_CSTS_GCMTCH		(1 << 3)
+#define	SMB_CSTS_MATCH		(1 << 2)
+#define	SMB_CSTS_BB		(1 << 1)
+#define	SMB_CSTS_BUSY		(1 << 0)
+#define	SMB_CTRL1			0x03
+#define	SMB_CTRL1_STASTRE	(1 << 7)
+#define	SMB_CTRL1_NMINTE	(1 << 6)
+#define	SMB_CTRL1_GCMEN		(1 << 5)
+#define	SMB_CTRL1_ACK		(1 << 4)
+#define	SMB_CTRL1_RSVD		(1 << 3)
+#define	SMB_CTRL1_INTEN		(1 << 2)
+#define	SMB_CTRL1_STOP		(1 << 1)
+#define	SMB_CTRL1_START		(1 << 0)
+#define	SMB_ADDR			0x04
+#define	SMB_ADDR_SAEN		(1 << 7)
+#define	SMB_CONTROLLER_ADDR	(0xef << 0)
+#define	SMB_CTRL2			0x05
+#define	SMB_FREQ		(0x20 << 1)	//(0x7f << 1)
+#define	SMB_ENABLE		(0x01 << 0)
+#define	SMB_CTRL3			0x06
+
+/*********************************** LEGACY I/O *******************************/
+
+/*
+ * LEGACY I/O SPACE BASE
+ */
+#define	CS5536_LEGACY_BASE_ADDR		(PCI_IO_BASE_VA | 0x0000)
+
+/*
+ * IDE LEGACY REG : legacy IO address is 0x170~0x177 and 0x376 (0x1f0~0x1f7 and 0x3f6)
+ * all registers are 16bits except the IDE_LEGACY_DATA reg
+ * some registers are read only and the 
+ */
+#define	PRI_IDE_LEGACY_REG(offset) 	(CS5536_LEGACY_BASE_ADDR | 0x1f0 | offset)
+#define	SEC_IDE_LEGACY_REG(offset)	(CS5536_LEGACY_BASE_ADDR | 0x170 | offset)
+
+#define	IDE_LEGACY_DATA		0x00 // RW
+#define	IDE_LEGACY_ERROR	0x01 // RO
+#define	IDE_LEGACY_FEATURE	0x01 // WO
+#define	IDE_LEGACY_SECTOR_COUNT	0x02 // RW
+#define	IDE_LEGACY_SECTOR_NUM	0x03 // RW
+#define	IDE_LEGACY_CYL_LO	0x04 // RW
+#define	IDE_LEGACY_CYL_HI	0x05 // RW
+#define	IDE_LEGACY_HEAD		0x06 // RW
+#define	IDE_LEGACY_HEAD_DRV		(1 << 4)
+#define	IDE_LEGACY_HEAD_LBA		(1 << 6)
+#define	IDE_LEGACY_HEAD_IBM		(1 << 7 | 1 << 5)
+#define	IDE_LEGACY_STATUS	0x07 // RO
+#define IDE_LEGACY_STATUS_ERR		(1 << 0)
+#define	IDE_LEGACY_STATUS_IDX		(1 << 1)
+#define IDE_LEGACY_STATUS_CORR		(1 << 2)
+#define	IDE_LEGACY_STATUS_DRQ		(1 << 3)
+#define	IDE_LEGACY_STATUS_DSC 		(1 << 4)
+#define	IDE_LEGACY_STATUS_DWF		(1 << 5)
+#define	IDE_LEGACY_STATUS_DRDY		(1 << 6)
+#define	IDE_LEGACY_STATUS_BUSY		(1 << 7)
+#define	IDE_LEGACY_COMMAND	0x07 // WO
+#define	IDE_LEGACY_ASTATUS	0x206 // RO
+#define	IDE_LEGACY_CTRL		0x206 // WO
+#define	IDE_LEGACY_CTRL_IDS	0x02
+#define	IDE_LEGACY_CTRL_RST	0x04
+#define	IDE_LEGACY_CTRL_4BIT	0x08
+
+/**********************************************************************************/
+
+#endif	/* _CS5536_H */
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/common/cs5536_pci.h linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/cs5536_pci.h
--- linux-2.6.29.1/arch/mips/lemote/lm2f/common/cs5536_pci.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/cs5536_pci.h	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,181 @@
+/*
+ * cs5536_vsm.h
+ * the definition file of cs5536 Virtual Support Module(VSM).
+ * pci configuration space can be accessed through the VSM, so
+ * there is no need the MSR read/write now, except the spec. MSR
+ * registers which are not implemented yet.
+ *
+ * Author : jlliu <liujl@lemote.com>
+ * Date : 07-07-04
+ *
+ */
+
+#ifndef	_CS5536_PCI_H
+#define	_CS5536_PCI_H
+
+/**********************************************************************/
+
+//#define	TEST_CS5536_USE_FLASH
+//#ifdef	TEST_CS5536_USE_FLASH
+//#define	TEST_CS5536_USE_NOR_FLASH
+//#endif
+#define		TEST_CS5536_USE_EHCI
+#define	TEST_CS5536_USE_UDC
+#define	TEST_CS5536_USE_OTG
+
+/**********************************************************************/
+
+#define	PCI_SPECIAL_SHUTDOWN	1
+#define	CS5536_FLASH_INTR	6
+#define	CS5536_ACC_INTR		9
+#define	CS5536_IDE_INTR		14
+#define	CS5536_USB_INTR		11
+#define	CS5536_UART1_INTR	4
+#define	CS5536_UART2_INTR	3
+
+/************************* PCI BUS DEVICE FUNCTION ********************/
+
+/*
+ * PCI bus device function
+ */
+#define	PCI_BUS_CS5536		0
+#define	PCI_IDSEL_CS5536	14
+#define	PCI_CFG_BASE		0x02000000
+
+#define	CS5536_ISA_FUNC		0
+#define	CS5536_FLASH_FUNC	1
+#define	CS5536_IDE_FUNC		2
+#define	CS5536_ACC_FUNC		3
+#define	CS5536_OHCI_FUNC	4
+#define	CS5536_EHCI_FUNC	5
+#define	CS5536_UDC_FUNC		6
+#define	CS5536_OTG_FUNC		7
+#define	CS5536_FUNC_START	0
+#define	CS5536_FUNC_END		7
+#define	CS5536_FUNC_COUNT	(CS5536_FUNC_END - CS5536_FUNC_START + 1)
+
+/***************************** STANDARD PCI-2.2 EXPANSION ***********************/
+
+/*
+ * PCI configuration space
+ * we have to virtualize the PCI configure space head, so we should
+ * define the necessary IDs and some others.
+ */
+/* VENDOR ID */ 
+#define	CS5536_VENDOR_ID	0x1022
+
+/* DEVICE ID */
+#define	CS5536_ISA_DEVICE_ID		0x2090
+#define	CS5536_FLASH_DEVICE_ID		0x2091
+#define	CS5536_IDE_DEVICE_ID		0x209a
+#define	CS5536_ACC_DEVICE_ID		0x2093
+#define	CS5536_OHCI_DEVICE_ID		0x2094
+#define	CS5536_EHCI_DEVICE_ID		0x2095
+#define	CS5536_UDC_DEVICE_ID		0x2096
+#define	CS5536_OTG_DEVICE_ID		0x2097
+
+/* CLASS CODE : CLASS SUB-CLASS INTERFACE */
+#define	CS5536_ISA_CLASS_CODE		0x060100
+#define	CS5536_FLASH_CLASS_CODE		0x050100
+#define CS5536_IDE_CLASS_CODE		0x010180
+#define	CS5536_ACC_CLASS_CODE		0x040100
+#define	CS5536_OHCI_CLASS_CODE		0x0C0310
+#define	CS5536_EHCI_CLASS_CODE		0x0C0320
+#define	CS5536_UDC_CLASS_CODE		0x0C03FE
+#define	CS5536_OTG_CLASS_CODE		0x0C0380
+
+/* BHLC : BIST HEADER-TYPE LATENCY-TIMER CACHE-LINE-SIZE */
+#define	PCI_NONE_BIST			0x00	//RO not implemented yet.
+#define	PCI_BRIDGE_HEADER_TYPE		0x80	//RO
+#define	PCI_NORMAL_HEADER_TYPE		0x00
+#define	PCI_NORMAL_LATENCY_TIMER	0x00
+#define	PCI_NORMAL_CACHE_LINE_SIZE	0x08	//RW
+
+/* BAR */
+#define	PCI_BAR0_REG			0x10
+#define	PCI_BAR1_REG			0x14
+#define	PCI_BAR2_REG			0x18
+#define	PCI_BAR3_REG			0x1c
+#define	PCI_BAR4_REG			0x20
+#define	PCI_BAR5_REG			0x24
+#define	PCI_BAR_COUNT			6
+#define	PCI_BAR_RANGE_MASK		0xFFFFFFFF
+
+/* CARDBUS CIS POINTER */
+#define	PCI_CARDBUS_CIS_POINTER		0x00000000
+
+/* SUBSYSTEM VENDOR ID  */
+#define	CS5536_SUB_VENDOR_ID		CS5536_VENDOR_ID
+
+/* SUBSYSTEM ID */
+#define	CS5536_ISA_SUB_ID		CS5536_ISA_DEVICE_ID
+#define	CS5536_FLASH_SUB_ID		CS5536_FLASH_DEVICE_ID
+#define	CS5536_IDE_SUB_ID		CS5536_IDE_DEVICE_ID
+#define	CS5536_ACC_SUB_ID		CS5536_ACC_DEVICE_ID
+#define	CS5536_OHCI_SUB_ID		CS5536_OHCI_DEVICE_ID
+#define	CS5536_EHCI_SUB_ID		CS5536_EHCI_DEVICE_ID
+#define	CS5536_UDC_SUB_ID		CS5536_UDC_DEVICE_ID
+#define	CS5536_OTG_SUB_ID		CS5536_OTG_DEVICE_ID
+
+/* EXPANSION ROM BAR */
+#define	PCI_EXPANSION_ROM_BAR		0x00000000
+
+/* CAPABILITIES POINTER */
+#define	PCI_CAPLIST_POINTER		0x00000000
+#define PCI_CAPLIST_USB_POINTER		0x40
+/* INTERRUPT */
+#define	PCI_MAX_LATENCY			0x40
+#define	PCI_MIN_GRANT			0x00
+#define	PCI_DEFAULT_PIN			0x01
+
+/**************************** EXPANSION PCI REG **************************************/
+
+/*
+ * ISA EXPANSION
+ */
+#define	PCI_UART1_INT_REG 	0x50
+#define PCI_UART2_INT_REG	0x54
+#define	PCI_ISA_FIXUP_REG	0x58
+
+/*
+ * FLASH EXPANSION
+ */
+#define	PCI_FLASH_INT_REG		0x50
+#define	PCI_NOR_FLASH_CTRL_REG		0x40
+#define	PCI_NOR_FLASH_T01_REG		0x44
+#define	PCI_NOR_FLASH_T23_REG		0x48
+#define	PCI_NAND_FLASH_TDATA_REG	0x60
+#define	PCI_NAND_FLASH_TCTRL_REG	0x64
+#define	PCI_NAND_FLASH_RSVD_REG		0x68
+#define	PCI_FLASH_SELECT_REG		0x70
+
+/*
+ * IDE EXPANSION
+ */ 
+#define	PCI_IDE_CFG_REG		0x40
+#define	CS5536_IDE_FLASH_SIGNATURE	0xDEADBEEF
+#define	PCI_IDE_DTC_REG		0x48
+#define	PCI_IDE_CAST_REG	0x4C
+#define	PCI_IDE_ETC_REG		0x50
+#define	PCI_IDE_PM_REG		0x54
+#define	PCI_IDE_INT_REG		0x60
+
+/*
+ * ACC EXPANSION
+ */
+#define	PCI_ACC_INT_REG		0x50
+
+/*
+ * OHCI EXPANSION : INTTERUPT IS IMPLEMENTED BY THE OHCI
+ */
+#define	PCI_OHCI_PM_REG		0x40
+#define	PCI_OHCI_INT_REG	0x50
+
+/*
+ * EHCI EXPANSION
+ */
+#define	PCI_EHCI_LEGSMIEN_REG	0x50
+#define	PCI_EHCI_LEGSMISTS_REG	0x54
+#define	PCI_EHCI_FLADJ_REG	0x60
+
+#endif /* _CS5536_PCI_H_ */
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/common/cs5536_vsm.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/cs5536_vsm.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/common/cs5536_vsm.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/cs5536_vsm.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,2294 @@
+/*
+ * pci_machdep_cs5536.c  
+ * 	the Virtual Support Module(VSM) for virtulize the PCI configure  
+ * 	space. so user can access the PCI configure space directly as
+ *	a normal multi-function PCI device which following the PCI-2.2 spec.
+ *
+ * Author : jlliu <liujl@lemote.com>
+ * Date : 07-07-05
+ *
+ */
+#include <linux/types.h>
+
+#include "cs5536.h"
+#include "cs5536_pci.h"
+#include "pcireg.h"
+
+extern void _wrmsr(u32 reg, u32 hi, u32 lo);
+extern void _rdmsr(u32 reg, u32 *hi, u32 *lo);
+
+/******************************INTERNAL USED FUNCTIONS***********************************/
+
+/*
+ * divil_lbar_enable_disable : enable/disable the divil module bar space.
+ * For all the DIVIL module LBAR, you should control the DIVIL LBAR reg
+ * and the RCONFx(0~5) reg to use the modules.
+ */
+static void divil_lbar_enable_disable(int enable)
+{
+	u32 hi, lo;
+	
+	/* 
+	 * The DIVIL IRQ is not used yet. and make the RCONF0 reserved.
+	 */
+	
+	_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_SMB), &hi, &lo);
+	if(enable)
+		hi |= 0x01;
+	else
+		hi &= ~0x01;
+	_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_SMB), hi, lo);
+
+	_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_GPIO), &hi, &lo);
+	if(enable)
+		hi |= 0x01;
+	else
+		hi &= ~0x01;
+	_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_GPIO), hi, lo);
+
+	_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_MFGPT), &hi, &lo);
+	if(enable)
+		hi |= 0x01;
+	else
+		hi &= ~0x01;
+	_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_MFGPT), hi, lo);
+
+	_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_PMS), &hi, &lo);
+	if(enable)
+		hi |= 0x01;
+	else
+		hi &= ~0x01;
+	_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_PMS), hi, lo);
+
+	_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_ACPI), &hi, &lo);
+	if(enable)
+		hi |= 0x01;
+	else
+		hi &= ~0x01;
+	_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_ACPI), hi, lo);
+	
+	/*
+	 * RCONF0 is reserved to the DIVIL IRQ mdoule
+	 */
+#if	0	
+	_rdmsr(SB_MSR_REG(SB_R1), &hi, &lo);
+	if(enable)
+		lo |= 0x01;
+	else
+		lo &= ~0x01;
+	_wrmsr(SB_MSR_REG(SB_R1), hi, lo);
+	
+	_rdmsr(SB_MSR_REG(SB_R2), &hi, &lo);
+	if(enable)
+		lo |= 0x01;
+	else
+		lo &= ~0x01;
+	_wrmsr(SB_MSR_REG(SB_R2), hi, lo);
+
+	_rdmsr(SB_MSR_REG(SB_R3), &hi, &lo);
+	if(enable)
+		lo |= 0x01;
+	else
+		lo &= ~0x01;
+	_wrmsr(SB_MSR_REG(SB_R3), hi, lo);
+	
+	_rdmsr(SB_MSR_REG(SB_R4), &hi, &lo);
+	if(enable)
+		lo |= 0x01;
+	else
+		lo &= ~0x01;
+	_wrmsr(SB_MSR_REG(SB_R4), hi, lo);
+
+	_rdmsr(SB_MSR_REG(SB_R5), &hi, &lo);
+	if(enable)
+		lo |= 0x01;
+	else
+		lo &= ~0x01;
+	_wrmsr(SB_MSR_REG(SB_R5), hi, lo);
+#endif	
+	return;
+}
+
+#ifdef	TEST_CS5536_USE_FLASH
+/*
+ * flash_lbar_enable_disable : enable or disable the region of flashs(NOR or NAND)
+ * the same as the DIVIL other modules above, two groups of regs should be modified
+ * here to control the region. DIVIL flash LBAR and the RCONFx(6~9 reserved).
+ */
+static void flash_lbar_enable_disable(int enable)
+{
+	u32 hi, lo;
+	
+	_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH0), &hi, &lo);
+	if(enable)
+		hi |= 0x01;
+	else
+		hi &= ~0x01;
+	_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH0), hi, lo);
+
+	_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH1), &hi, &lo);
+	if(enable)
+		hi |= 0x01;
+	else
+		hi &= ~0x01;
+	_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH1), hi, lo);
+
+	_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH2), &hi, &lo);
+	if(enable)
+		hi |= 0x01;
+	else
+		hi &= ~0x01;
+	_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH2), hi, lo);
+
+	_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH3), &hi, &lo);
+	if(enable)
+		hi |= 0x01;
+	else
+		hi &= ~0x01;
+	_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH3), hi, lo);
+
+	_rdmsr(SB_MSR_REG(SB_R6), &hi, &lo);
+	if(enable)
+		lo |= 0x01;
+	else
+		lo &= ~0x01;
+	_wrmsr(SB_MSR_REG(SB_R6), hi, lo);
+	
+	_rdmsr(SB_MSR_REG(SB_R7), &hi, &lo);
+	if(enable)
+		lo |= 0x01;
+	else
+		lo &= ~0x01;
+	_wrmsr(SB_MSR_REG(SB_R7), hi, lo);
+	
+	_rdmsr(SB_MSR_REG(SB_R8), &hi, &lo);
+	if(enable)
+		lo |= 0x01;
+	else
+		lo &= ~0x01;
+	_wrmsr(SB_MSR_REG(SB_R8), hi, lo);
+
+	_rdmsr(SB_MSR_REG(SB_R9), &hi, &lo);
+	if(enable)
+		lo |= 0x01;
+	else
+		lo &= ~0x01;
+	_wrmsr(SB_MSR_REG(SB_R9), hi, lo);
+	
+	return;
+}
+#endif
+
+
+/**********************************MODULES*********************************************/
+
+/*
+ * isa_write : isa write transfering.
+ * WE assume that the ISA is not the BUS MASTER.!!!
+ */
+/* FAST BACK TO BACK '1' for BUS MASTER '0' for BUS SALVE */
+/* COMMAND :
+ * 	bit0 : IO SPACE ENABLE
+ *	bit1 : MEMORY SPACE ENABLE(ignore)
+ *	bit2 : BUS MASTER ENABLE(ignore)
+ *	bit3 : SPECIAL CYCLE(ignore)? default is ignored.
+ *	bit4 : MEMORY WRITE and INVALIDATE(ignore)
+ *	bit5 : VGA PALETTE(ignore)
+ *	bit6 : PARITY ERROR(ignore)? : default is ignored.
+ *	bit7 : WAIT CYCLE CONTROL(ignore)
+ *	bit8 : SYSTEM ERROR(ignore)
+ *	bit9 : FAST BACK TO BACK(ignore)
+ *	bit10-bit15 : RESERVED
+ * STATUS :
+ *	bit0-bit3 : RESERVED
+ *	bit4 : CAPABILITY LIST(ignore)
+ *	bit5 : 66MHZ CAPABLE
+ *	bit6 : RESERVED
+ *	bit7 : FAST BACK TO BACK(ignore)
+ *	bit8 : DATA PARITY ERROR DETECED(ignore)
+ *	bit9-bit10 : DEVSEL TIMING(ALL MEDIUM)
+ *	bit11: SIGNALED TARGET ABORT
+ *	bit12: RECEIVED TARGET ABORT
+ *	bit13: RECEIVED MASTER ABORT
+ *	bit14: SIGNALED SYSTEM ERROR
+ *	bit15: DETECTED PARITY ERROR
+ */
+static void pci_isa_write_reg(int reg, u32 value)
+{
+	u32 hi, lo;
+	u32 temp;
+
+	switch(reg){
+		case PCI_COMMAND_STATUS_REG :
+			// command
+			if( value & PCI_COMMAND_IO_ENABLE ){
+				divil_lbar_enable_disable(1);
+			}else{
+				divil_lbar_enable_disable(0);
+			}
+#if	0
+			/* PER response enable or disable. */
+			if( value & PCI_COMMAND_PARITY_ENABLE ){
+				_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+				lo |= SB_PARE_ERR_EN;
+				_wrmsr(SB_MSR_REG(SB_ERROR), hi, lo);			
+			}else{
+				_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+				lo &= ~SB_PARE_ERR_EN;
+				_wrmsr(SB_MSR_REG(SB_ERROR), hi, lo);			
+			}
+#endif
+			// status
+			_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+			temp = lo & 0x0000ffff;
+			if( (value & PCI_STATUS_TARGET_TARGET_ABORT) && 
+				(lo & SB_TAS_ERR_EN) ){
+				temp |= SB_TAS_ERR_FLAG;
+			}
+			if( (value & PCI_STATUS_MASTER_TARGET_ABORT) &&
+				(lo & SB_TAR_ERR_EN) ){
+				temp |= SB_TAR_ERR_FLAG;
+			}
+			if( (value & PCI_STATUS_MASTER_ABORT) &&
+				(lo & SB_MAR_ERR_EN) ){
+				temp |= SB_MAR_ERR_FLAG;
+			}
+			if( (value & PCI_STATUS_PARITY_DETECT) &&
+				(lo & SB_PARE_ERR_EN) ){
+				temp |= SB_PARE_ERR_FLAG; 
+			}
+			lo = temp;
+			_wrmsr(SB_MSR_REG(SB_ERROR), hi, lo);
+			break;
+		case PCI_BHLC_REG :
+			value &= 0x0000ff00;
+			_rdmsr(SB_MSR_REG(SB_CTRL), &hi, &lo);
+			hi &= 0xffffff00;
+			hi |= (value >> 8);
+			_wrmsr(SB_MSR_REG(SB_CTRL), hi, lo);
+			break;
+		case PCI_BAR0_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_SMB_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if(value & 0x01){
+				// SMB NATIVE IO space has 8bytes
+				hi = 0x0000f001;
+				lo = value & 0x0000fff8;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_SMB), hi, lo);
+				
+				// RCONFx is 4bytes in units for IO space.
+				hi = ((value & 0x000ffffc) << 12) | ((CS5536_SMB_LENGTH - 4) << 12) | 0x01;
+				lo = ((value & 0x000ffffc) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R0), hi, lo);
+			}
+			break;
+		case PCI_BAR1_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_GPIO_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if(value & 0x01){
+				// GPIO NATIVE reg is 256bytes
+				hi = 0x0000f001;
+				lo = value & 0x0000ff00;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_GPIO), hi, lo);
+
+				// RCONFx is 4bytes in units for IO space
+				hi = ((value & 0x000ffffc) << 12) | ((CS5536_GPIO_LENGTH - 4) << 12) | 0x01;
+				lo = ((value & 0x000ffffc) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R1), hi, lo);
+			}
+			break;
+		case PCI_BAR2_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_MFGPT_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if(value & 0x01){
+				// MFGPT NATIVE reg is 64bytes
+				hi = 0x0000f001;
+				lo = value & 0x0000ffc0;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_MFGPT), hi, lo);
+
+				// RCONFx is 4bytes in units for IO space
+				hi = ((value & 0x000ffffc) << 12) | ((CS5536_MFGPT_LENGTH - 4) << 12) | 0x01;
+				lo = ((value & 0x000ffffc) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R2), hi, lo);
+			}
+			break;
+		case PCI_BAR3_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_IRQ_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if(value & 0x01){
+				// IRQ NATIVE reg is 32bytes
+				hi = 0x0000f001;
+				lo = value & 0x0000ffc0;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_IRQ), hi, lo);
+
+				// RCONFx is 4bytes in units for IO space
+				hi = ((value & 0x000ffffc) << 12) | ((CS5536_IRQ_LENGTH - 4) << 12) | 0x01;
+				lo = ((value & 0x000ffffc) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R3), hi, lo);
+			}
+			break;
+		case PCI_BAR4_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_PMS_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if(value & 0x01){
+				// PMS NATIVE reg is 128bytes
+				hi = 0x0000f001;
+				lo = value & 0x0000ff80;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_PMS), hi, lo);
+
+				// RCONFx is 4bytes in units for IO space.
+				hi = ((value & 0x000ffffc) << 12) | ((CS5536_PMS_LENGTH - 4) << 12) | 0x01;
+				lo = ((value & 0x000ffffc) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R4), hi, lo);
+			}
+			break;
+		case PCI_BAR5_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_ACPI_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if(value & 0x01){
+				// ACPI NATIVE reg is 32bytes
+				hi = 0x0000f001;
+				lo = value & 0x0000ffe0;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_ACPI), hi, lo);
+				
+				// RCONFx is 4bytes in units for IO space.
+				hi = ((value & 0x000ffffc) << 12) | ((CS5536_ACPI_LENGTH - 4) << 12) | 0x01;
+				lo = ((value & 0x000ffffc) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R5), hi, lo);
+			}
+			break;
+		case PCI_UART1_INT_REG :
+			if(value){
+			/* enable uart1 interrupt in PIC */	
+				_rdmsr(DIVIL_MSR_REG(PIC_YSEL_HIGH), &hi, &lo);
+				lo &= ~(0xf << 24);
+				lo |= (CS5536_UART1_INTR << 24);
+				_wrmsr(DIVIL_MSR_REG(PIC_YSEL_HIGH), hi, lo);
+			}else{
+			/* disable uart1 interrupt in PIC */
+				_rdmsr(DIVIL_MSR_REG(PIC_YSEL_HIGH), &hi, &lo);
+				lo &= ~(0xf << 24);
+				_wrmsr(DIVIL_MSR_REG(PIC_YSEL_HIGH), hi, lo);
+			}
+			break;
+		case PCI_UART2_INT_REG :
+			if(value){
+			/* enable uart2 interrupt in PIC */	
+				_rdmsr(DIVIL_MSR_REG(PIC_YSEL_HIGH), &hi, &lo);
+				lo &= ~(0xf << 28);
+				lo |= (CS5536_UART2_INTR << 28);
+				_wrmsr(DIVIL_MSR_REG(PIC_YSEL_HIGH), hi, lo);
+			}else{
+			/* disable uart2 interrupt in PIC */
+				_rdmsr(DIVIL_MSR_REG(PIC_YSEL_HIGH), &hi, &lo);
+				lo &= ~(0xf << 28);
+				_wrmsr(DIVIL_MSR_REG(PIC_YSEL_HIGH), hi, lo);
+			}
+			break;
+		case PCI_ISA_FIXUP_REG :
+			if(value){
+				/* enable the TARGET ABORT/MASTER ABORT etc. */
+				_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+				lo |= 0x00000063;
+				_wrmsr(SB_MSR_REG(SB_ERROR), hi, lo);
+			}
+
+		default :
+			/* ALL OTHER PCI CONFIG SPACE HEADER IS NOT IMPLEMENTED. */
+			break;			
+	}
+	
+	return;
+}
+
+/*
+ * isa_read : isa read transfering.
+ * we assume that the ISA is not the BUS MASTER. 
+ */
+ 
+ /* COMMAND :
+ * 	bit0 : IO SPACE ENABLE
+ *	bit1 : MEMORY SPACE ENABLE(ignore)
+ *	bit2 : BUS MASTER ENABLE(ignore)
+ *	bit3 : SPECIAL CYCLE(ignore)? default is ignored.
+ *	bit4 : MEMORY WRITE and INVALIDATE(ignore)
+ *	bit5 : VGA PALETTE(ignore)
+ *	bit6 : PARITY ERROR(ignore)? : default is ignored.
+ *	bit7 : WAIT CYCLE CONTROL(ignore)
+ *	bit8 : SYSTEM ERROR(ignore)
+ *	bit9 : FAST BACK TO BACK(ignore)
+ *	bit10-bit15 : RESERVED
+ * STATUS :
+ *	bit0-bit3 : RESERVED
+ *	bit4 : CAPABILITY LIST(ignore)
+ *	bit5 : 66MHZ CAPABLE
+ *	bit6 : RESERVED
+ *	bit7 : FAST BACK TO BACK(ignore)
+ *	bit8 : DATA PARITY ERROR DETECED(ignore)?
+ *	bit9-bit10 : DEVSEL TIMING(ALL MEDIUM)
+ *	bit11: SIGNALED TARGET ABORT
+ *	bit12: RECEIVED TARGET ABORT
+ *	bit13: RECEIVED MASTER ABORT
+ *	bit14: SIGNALED SYSTEM ERROR
+ *	bit15: DETECTED PARITY ERROR(?)
+ */
+
+static u32 pci_isa_read_reg(int reg)
+{
+	u32 conf_data;
+	u32 hi, lo;
+	
+	switch(reg){
+		case PCI_ID_REG :
+			conf_data = (CS5536_ISA_DEVICE_ID << 16 | CS5536_VENDOR_ID);
+			break;
+		case PCI_COMMAND_STATUS_REG :
+			conf_data = 0;
+			// COMMAND
+			// we just check the first LBAR for the IO enable bit,
+			// maybe we should changed later.
+			_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_SMB), &hi, &lo);
+			if(hi & 0x01){
+				conf_data |= PCI_COMMAND_IO_ENABLE;
+			}
+			//conf_data |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE;
+#if	0
+			conf_data |= PCI_COMMAND_SPECIAL_ENABLE;
+#endif
+#if	0
+			_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+			if(lo & SB_PARE_ERR_EN){
+				conf_data |= PCI_COMMAND_PARITY_ENABLE;
+			}else{
+				conf_data &= ~PCI_COMMAND_PARITY_ENABLE;
+			}
+#endif
+			// STATUS	
+			conf_data |= PCI_STATUS_66MHZ_SUPPORT;
+			conf_data |= PCI_STATUS_DEVSEL_MEDIUM;
+#if	1
+			conf_data |= PCI_STATUS_BACKTOBACK_SUPPORT;
+#endif
+			_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+			if(lo & SB_TAS_ERR_FLAG)
+				conf_data |= PCI_STATUS_TARGET_TARGET_ABORT;
+			if(lo & SB_TAR_ERR_FLAG)
+				conf_data |= PCI_STATUS_MASTER_TARGET_ABORT;
+			if(lo & SB_MAR_ERR_FLAG)
+				conf_data |= PCI_STATUS_MASTER_ABORT;
+			if(lo & SB_PARE_ERR_FLAG)
+				conf_data |= PCI_STATUS_PARITY_DETECT;
+			break;
+		case PCI_CLASS_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_CHIP_REV_ID), &hi, &lo);
+			conf_data = lo & 0x000000ff;
+			conf_data |= (CS5536_ISA_CLASS_CODE << 8);
+			break;
+		case PCI_BHLC_REG :
+			_rdmsr(SB_MSR_REG(SB_CTRL), &hi, &lo);
+			hi &= 0x000000f8;
+			conf_data = (PCI_NONE_BIST << 24) | (PCI_BRIDGE_HEADER_TYPE << 16) |
+				(hi << 8) | PCI_NORMAL_CACHE_LINE_SIZE;
+			break;
+		/*
+		 * we only use the LBAR of DIVIL, no RCONF used. 
+		 * all of them are IO space.
+		 */
+		case PCI_BAR0_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_SMB_FLAG){
+				conf_data = CS5536_SMB_RANGE | PCI_MAPREG_TYPE_IO;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_SMB_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_SMB), &hi, &lo);
+				conf_data = lo & 0x0000fff8;
+				conf_data |= 0x01;
+				conf_data &= ~0x02;
+			}
+			break;
+		case PCI_BAR1_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_GPIO_FLAG){
+				conf_data = CS5536_GPIO_RANGE | PCI_MAPREG_TYPE_IO;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_GPIO_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_GPIO), &hi, &lo);
+				conf_data = lo & 0x0000ff00;
+				conf_data |= 0x01;
+				conf_data &= ~0x02;
+			}
+			break;
+		case PCI_BAR2_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_MFGPT_FLAG){
+				conf_data = CS5536_MFGPT_RANGE | PCI_MAPREG_TYPE_IO;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_MFGPT_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_MFGPT), &hi, &lo);
+				conf_data = lo & 0x0000ffc0;
+				conf_data |= 0x01;
+				conf_data &= ~0x02;
+			}
+			break;
+#if	1
+		case PCI_BAR3_REG :
+			conf_data = 0;
+			break;
+#else
+		case PCI_BAR3_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_IRQ_FLAG){
+				conf_data = CS5536_IRQ_RANGE | PCI_MAPREG_TYPE_IO;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_IRQ_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_IRQ), &hi, &lo);
+				conf_data = lo & 0x0000ffc0;
+				conf_data |= 0x01;
+				conf_data &= ~0x02;
+			}
+			break;
+#endif
+		case PCI_BAR4_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_PMS_FLAG){
+				conf_data = CS5536_PMS_RANGE | PCI_MAPREG_TYPE_IO;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_PMS_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_PMS), &hi, &lo);
+				conf_data = lo & 0x0000ff80;
+				conf_data |= 0x01;
+				conf_data &= ~0x02;
+			}
+			break;
+		case PCI_BAR5_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_ACPI_FLAG){
+				conf_data = CS5536_ACPI_RANGE | PCI_MAPREG_TYPE_IO;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_ACPI_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_ACPI), &hi, &lo);
+				conf_data = lo & 0x0000ffe0;
+				conf_data |= 0x01;
+				conf_data &= ~0x02;
+			}
+			break;
+		case PCI_CARDBUS_CIS_REG :
+			conf_data = PCI_CARDBUS_CIS_POINTER;
+			break;
+		case PCI_SUBSYS_ID_REG :
+			conf_data = (CS5536_ISA_SUB_ID << 16) | CS5536_SUB_VENDOR_ID;
+			break;
+		case PCI_MAPREG_ROM :
+			conf_data = PCI_EXPANSION_ROM_BAR;
+			break;
+		case PCI_CAPLISTPTR_REG :
+			conf_data = PCI_CAPLIST_POINTER;
+			break;
+		case PCI_INTERRUPT_REG :
+			conf_data = (PCI_MAX_LATENCY << 24) | (PCI_MIN_GRANT << 16) | 
+				(0x00 << 8) | 0x00;
+			break;
+		default :
+			conf_data = 0;
+			break;
+	}
+	
+	return conf_data;
+}
+
+#ifdef	TEST_CS5536_USE_FLASH
+
+#ifndef	TEST_CS5536_USE_NOR_FLASH	/* for nand flash */
+static void pci_flash_write_reg(int reg, u32 value)
+{
+	u32 hi, lo;
+
+	switch(reg){
+		case PCI_COMMAND_STATUS_REG :
+			// command
+			if( value & PCI_COMMAND_MEM_ENABLE ){
+				flash_lbar_enable_disable(1);
+			}else{
+				flash_lbar_enable_disable(0);
+			}
+			// STATUS
+			if(value & PCI_STATUS_PARITY_ERROR){
+				_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+				if(lo & SB_PARE_ERR_FLAG){
+					lo = (lo & 0x0000ffff) | SB_PARE_ERR_FLAG;
+					_wrmsr(SB_MSR_REG(SB_ERROR), hi, lo);
+				}				
+			}
+			break;
+		case PCI_BAR0_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				// make the flag for reading the bar length.
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_FLSH0_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if( (value & 0x01) == 0x00 ){
+				// mem space nand flash native reg base addr
+				hi = 0xfffff007;
+				lo = value & 0xfffff000;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH0), hi, lo);
+	
+				// RCONFx is 4KB in units for mem space.
+				hi = ((value & 0xfffff000) << 12) | ( (CS5536_FLSH0_LENGTH & 0xfffff000) - (1 << 12) ) | 0x00;
+				lo = ((value & 0xfffff000) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R6), hi, lo);			
+			}
+			break;
+		case PCI_BAR1_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_FLSH1_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if( (value & 0x01) == 0x00 ){
+				// mem space nand flash native reg base addr
+				hi = 0xfffff007;
+				lo = value & 0xfffff000;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH1), hi, lo);
+	
+				// RCONFx is 4KB in units for mem space.
+				hi = ((value & 0xfffff000) << 12) | ( (CS5536_FLSH1_LENGTH & 0xfffff000) - (1 << 12) ) | 0x00;
+				lo = ((value & 0xfffff000) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R7), hi, lo);
+			}
+			break;
+		case PCI_BAR2_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_FLSH2_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if( (value & 0x01) == 0x00 ){
+				// mem space nand flash native reg base addr
+				hi = 0xfffff007;
+				lo = value & 0xfffff000;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH2), hi, lo);
+	
+				// RCONFx is 4KB in units for mem space.
+				hi = ((value & 0xfffff000) << 12) | ( (CS5536_FLSH2_LENGTH & 0xfffff000) - (1 << 12) ) | 0x00;
+				lo = ((value & 0xfffff000) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R8), hi, lo);
+			}
+			break;		
+		case PCI_BAR3_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_FLSH3_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if( (value & 0x01) == 0x00 ){
+				// mem space nand flash native reg base addr
+				hi = 0xfffff007;
+				lo = value & 0xfffff000;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH3), hi, lo);
+	
+				// RCONFx is 4KB in units for mem space.
+				hi = ((value & 0xfffff000) << 12) | ( (CS5536_FLSH3_LENGTH & 0xfffff000)- (1 << 12) ) | 0x00;
+				lo = ((value & 0xfffff000) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R9), hi, lo);
+			}
+			break;
+		case PCI_FLASH_INT_REG :
+			if(value){
+			/* enable all the flash interrupt in PIC */	
+				_rdmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), &hi, &lo);
+				lo &= ~(0xf << PIC_YSEL_LOW_FLASH_SHIFT);
+				lo |= (CS5536_FLASH_INTR << PIC_YSEL_LOW_FLASH_SHIFT);
+				_wrmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), hi, lo);
+			}else{
+			/* disable all the flash interrupt in PIC */
+				_rdmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), &hi, &lo);
+				lo &= ~(0xf << PIC_YSEL_LOW_FLASH_SHIFT);
+				_wrmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), hi, lo);
+			}
+			break;
+		case PCI_NAND_FLASH_TDATA_REG :
+			hi = 0;
+			lo = value;
+			_wrmsr(DIVIL_MSR_REG(NANDF_DATA), hi, lo);
+			break;
+		case PCI_NAND_FLASH_TCTRL_REG :
+			hi = 0;
+			lo = value & 0x00000fff;
+			_wrmsr(DIVIL_MSR_REG(NANDF_CTRL), hi, lo);
+			break;
+		case PCI_NAND_FLASH_RSVD_REG :
+			hi = 0;
+			lo = value;
+			_wrmsr(DIVIL_MSR_REG(NANDF_RSVD), hi, lo);
+			break;
+		case PCI_FLASH_SELECT_REG :
+			if(value == CS5536_IDE_FLASH_SIGNATURE){
+				_rdmsr(DIVIL_MSR_REG(DIVIL_BALL_OPTS), &hi, &lo);
+				lo &= ~0x01;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_BALL_OPTS), hi, lo);
+			}
+			break;
+		default :
+			break;
+	}
+	
+	return;
+}
+
+static u32 pci_flash_read_reg(int reg)
+{
+	u32 conf_data;
+	u32 hi, lo;
+	
+	switch(reg){
+		case PCI_ID_REG :
+			conf_data = (CS5536_FLASH_DEVICE_ID << 16 | CS5536_VENDOR_ID);
+			break;
+		case PCI_COMMAND_STATUS_REG :
+			conf_data = 0;
+			// COMMAND
+			// we just read one lbar for returning.
+			_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH0), &hi, &lo);
+			if(hi & 0x01)
+				conf_data |= PCI_COMMAND_MEM_ENABLE;
+			//STATUS
+			conf_data |= PCI_STATUS_66MHZ_SUPPORT;
+			conf_data |= PCI_STATUS_BACKTOBACK_SUPPORT;
+			_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+			if(lo & SB_PARE_ERR_FLAG)
+				conf_data |= PCI_STATUS_PARITY_ERROR;
+			conf_data |= PCI_STATUS_DEVSEL_MEDIUM;
+			break;
+		case PCI_CLASS_REG :
+			_rdmsr(DIVIL_MSR_REG(DIVIL_CAP), &hi, &lo);
+			conf_data = lo & 0x000000ff;
+			conf_data |= (CS5536_FLASH_CLASS_CODE << 8);
+			break;
+		case PCI_BHLC_REG :
+			conf_data = (PCI_NONE_BIST << 24) | (PCI_NORMAL_HEADER_TYPE << 16) |
+				(PCI_NORMAL_LATENCY_TIMER << 8) | PCI_NORMAL_CACHE_LINE_SIZE;
+			break;
+		case PCI_BAR0_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_FLSH0_FLAG){
+				conf_data = CS5536_FLSH0_RANGE | PCI_MAPREG_TYPE_MEM;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_FLSH0_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH0), &hi, &lo);
+				conf_data = lo;
+				conf_data &= ~0x0f;
+			}
+			break;
+		case PCI_BAR1_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_FLSH1_FLAG){
+				conf_data = CS5536_FLSH1_RANGE | PCI_MAPREG_TYPE_MEM;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_FLSH1_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH1), &hi, &lo);
+				conf_data = lo;
+				conf_data &= ~0x0f;
+			}
+			break;
+		case PCI_BAR2_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_FLSH2_FLAG){
+				conf_data = CS5536_FLSH2_RANGE | PCI_MAPREG_TYPE_MEM;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_FLSH2_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH2), &hi, &lo);
+				conf_data = lo;
+				conf_data &= ~0x0f;
+			}
+			break;
+		case PCI_BAR3_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_FLSH3_FLAG){
+				conf_data = CS5536_FLSH3_RANGE | PCI_MAPREG_TYPE_MEM;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_FLSH3_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH3), &hi, &lo);
+				conf_data = lo;
+				conf_data &= ~0x0f;
+			}
+			break;	
+		case PCI_CARDBUS_CIS_REG :
+			conf_data = PCI_CARDBUS_CIS_POINTER;
+			break;
+		case PCI_SUBSYS_ID_REG :
+			conf_data = (CS5536_FLASH_SUB_ID << 16) | CS5536_SUB_VENDOR_ID;
+			break;
+		case PCI_MAPREG_ROM :
+			conf_data = PCI_EXPANSION_ROM_BAR;
+			break;
+		case PCI_CAPLISTPTR_REG :
+			conf_data = PCI_CAPLIST_POINTER;
+			break;
+		case PCI_INTERRUPT_REG :
+			conf_data = (PCI_MAX_LATENCY << 24) | (PCI_MIN_GRANT << 16) | 
+				(PCI_DEFAULT_PIN << 8) | (CS5536_FLASH_INTR);
+			break;
+		case PCI_NAND_FLASH_TDATA_REG :
+			_rdmsr(DIVIL_MSR_REG(NANDF_DATA), &hi, &lo);
+			conf_data = lo;
+			break;
+		case PCI_NAND_FLASH_TCTRL_REG :
+			_rdmsr(DIVIL_MSR_REG(NANDF_CTRL), &hi, &lo);
+			conf_data = lo & 0x00000fff;
+			break;
+		case PCI_NAND_FLASH_RSVD_REG :
+			_rdmsr(DIVIL_MSR_REG(NANDF_RSVD), &hi, &lo);
+			conf_data = lo;
+			break;
+		case PCI_FLASH_SELECT_REG :
+			_rdmsr(DIVIL_MSR_REG(DIVIL_BALL_OPTS), &hi, &lo);
+			conf_data = lo & 0x01;
+			break;
+
+		}
+	return 0;
+}
+
+#else /* nor flash */
+
+static void pci_flash_write_reg(int reg, u32 value)
+{
+	u32 hi, lo;
+
+	switch(reg){
+		case PCI_COMMAND_STATUS_REG :
+			// command
+			if( value & PCI_COMMAND_IO_ENABLE ){
+				flash_lbar_enable_disable(1);
+			}else{
+				flash_lbar_enable_disable(0);
+			}
+			// STATUS
+			if(value & PCI_STATUS_PARITY_ERROR){
+				_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+				if(lo & SB_PARE_ERR_FLAG){
+					lo = (lo & 0x0000ffff) | SB_PARE_ERR_FLAG;
+					_wrmsr(SB_MSR_REG(SB_ERROR), hi, lo);
+				}				
+			}
+			break;
+		case PCI_BAR0_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_FLSH0_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if(value & 0x01){
+				// IO space of 16bytes nor flash
+				hi = 0x0000fff1;
+				lo = value & 0x0000fff0;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH0), hi, lo);
+	
+				// RCONFx used for 16bytes reserved.
+				hi = ((value & 0x000ffffc) << 12) | ((CS5536_FLSH0_LENGTH - 4) << 12) | 0x01;
+				lo = ((value & 0x000ffffc) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R6), hi, lo);
+			}
+			break;
+		case PCI_BAR1_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_FLSH1_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if(value & 0x01){
+				// IO space of 16bytes nor flash
+				hi = 0x0000fff1;
+				lo = value & 0x0000fff0;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH1), hi, lo);
+	
+				// RCONFx used for 16bytes reserved.
+				hi = ((value & 0x000ffffc) << 12) | ((CS5536_FLSH1_LENGTH - 4) << 12) | 0x01;
+				lo = ((value & 0x000ffffc) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R7), hi, lo);			
+			}
+			break;
+		case PCI_BAR2_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_FLSH2_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if(value & 0x01){
+				hi = 0x0000fff1;
+				lo = value & 0x0000fff0;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH2), hi, lo);
+	
+				hi = ((value & 0x000ffffc) << 12) | ((CS5536_FLSH2_LENGTH - 4) << 12) | 0x01;
+				lo = ((value & 0x000ffffc) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R8), hi, lo);				
+			}
+			break;		
+		case PCI_BAR3_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_FLSH3_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if(value & 0x01){
+				// 16bytes for nor flash
+				hi = 0x0000fff1;
+				lo = value & 0x0000fff0;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH3), hi, lo);
+	
+				// 16bytes of IO space of RCONFx region.
+				hi = ((value & 0x000ffffc) << 12) | ((CS5536_FLSH3_LENGTH - 4) << 12) | 0x01;
+				lo = ((value & 0x000ffffc) << 12) | 0x01;
+				_wrmsr(SB_MSR_REG(SB_R9), hi, lo);	
+			}
+			break;
+			
+		case PCI_INTERRUPT_REG :
+			conf_data = (PCI_MAX_LATENCY << 24) | (PCI_MIN_GRANT << 16) | 
+				(PCI_DEFAULT_PIN << 8) | (CS5536_FLASH_INTR);
+			break;
+		case PCI_FLASH_INT_REG :
+			if(value){
+			/* enable all the flash interrupt in PIC */	
+				_rdmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), &hi, &lo);
+				lo &= ~(0xf << PIC_YSEL_LOW_FLASH_SHIFT);
+				lo |= (CS5536_FLASH_INTR << PIC_YSEL_LOW_FLASH_SHIFT);
+				_wrmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), hi, lo);
+			}else{
+			/* disable all the flash interrupt in PIC */
+				_rdmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), &hi, &lo);
+				lo &= ~(0xf << PIC_YSEL_LOW_FLASH_SHIFT);
+				_wrmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), hi, lo);
+			}
+			break;
+		case PCI_NOR_FLASH_CTRL_REG :
+			hi = 0;
+			lo = value & 0x000000ff;
+			_wrmsr(DIVIL_MSR_REG(NORF_CTRL), hi, lo);
+			break;
+		case PCI_NOR_FLASH_T01_REG :
+			hi = 0;
+			lo = value;
+			_wrmsr(DIVIL_MSR_REG(NORF_T01), hi, lo);
+			break;
+		case PCI_NOR_FLASH_T23_REG :
+			hi = 0;
+			lo = value;
+			_wrmsr(DIVIL_MSR_REG(NORF_T23), hi, lo);
+			break;
+		case PCI_FLASH_SELECT_REG :
+			if(value == CS5536_IDE_FLASH_SIGNATURE){
+				_rdmsr(DIVIL_MSR_REG(DIVIL_BALL_OPTS), &hi, &lo);
+				lo &= ~0x01;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_BALL_OPTS), hi, lo);
+			}
+			break;
+
+		default :
+			break;			
+	}
+	
+	return;
+}
+
+static u32 pci_flash_read_reg(int reg)
+{
+	u32 conf_data;
+	u32 hi, lo;
+	
+	switch(reg){
+		case PCI_ID_REG :
+			conf_data = (CS5536_FLASH_DEVICE_ID << 16 | CS5536_VENDOR_ID);
+			break;
+		case PCI_COMMAND_STATUS_REG :
+			conf_data = 0;
+			// COMMAND
+			// we just check one flash bar for returning.
+			_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH0), &hi, &lo);
+			if(hi & 0x01)
+				conf_data |= PCI_COMMAND_IO_ENABLE;
+			//STATUS
+			conf_data |= PCI_STATUS_66MHZ_SUPPORT;
+			conf_data |= PCI_STATUS_BACKTOBACK_SUPPORT;
+			_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+			if(lo & SB_PARE_ERR_FLAG)
+				conf_data |= PCI_STATUS_PARITY_ERROR;
+			conf_data |= PCI_STATUS_DEVSEL_MEDIUM;
+			break;
+		case PCI_CLASS_REG :
+			_rdmsr(DIVIL_MSR_REG(DIVIL_CAP), &hi, &lo);
+			conf_data = lo & 0x000000ff;
+			conf_data |= (CS5536_FLASH_CLASS_CODE << 8);
+			break;
+		case PCI_BHLC_REG :
+			conf_data = (PCI_NONE_BIST << 24) | (PCI_NORMAL_HEADER_TYPE << 16) |
+				(PCI_NORMAL_LATENCY_TIMER << 8) | PCI_NORMAL_CACHE_LINE_SIZE;
+			break;
+		case PCI_BAR0_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_FLSH0_FLAG){
+				conf_data = CS5536_FLSH0_RANGE | PCI_MAPREG_TYPE_IO;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_FLSH0_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH0), &hi, &lo);
+				conf_data = lo & 0x0000ffff;
+				conf_data |= 0x01;
+				conf_data &= ~0x02;
+			}
+			break;
+		case PCI_BAR1_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_FLSH1_FLAG){
+				conf_data = CS5536_FLSH1_RANGE | PCI_MAPREG_TYPE_IO;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_FLSH1_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH1), &hi, &lo);
+				conf_data = lo & 0x0000ffff;
+				conf_data |= 0x01;
+				conf_data &= ~0x02;
+			}
+			break;
+		case PCI_BAR2_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_FLSH2_FLAG){
+				conf_data = CS5536_FLSH2_RANGE | PCI_MAPREG_TYPE_IO;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_FLSH2_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH2), &hi, &lo);
+				conf_data = lo & 0x0000ffff;
+				conf_data |= 0x01;
+				conf_data &= ~0x02;
+			}
+			break;
+		case PCI_BAR3_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_FLSH3_FLAG){
+				conf_data = CS5536_FLSH3_RANGE | PCI_MAPREG_TYPE_IO;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_FLSH3_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(DIVIL_MSR_REG(DIVIL_LBAR_FLSH3), &hi, &lo);
+				conf_data = lo & 0x0000ffff;
+				conf_data |= 0x01;
+				conf_data &= ~0x02;
+			}
+			break;	
+		case PCI_CARDBUS_CIS_REG :
+			conf_data = PCI_CARDBUS_CIS_POINTER;
+			break;
+		case PCI_SUBSYS_ID_REG :
+			conf_data = (CS5536_FLASH_SUB_ID << 16) | CS5536_SUB_VENDOR_ID;
+			break;
+		case PCI_MAPREG_ROM :
+			conf_data = PCI_EXPANSION_ROM_BAR;
+			break;
+		case PCI_CAPLISTPTR_REG :
+			conf_data = PCI_CAPLIST_POINTER;
+			break;
+		case PCI_INTERRUPT_REG :
+			conf_data = (PCI_MAX_LATENCY << 24) | (PCI_MIN_GRANT << 16) | 
+				(PCI_DEFAULT_PIN << 8) | (CS5536_FLASH_INTR);
+			break;
+		case PCI_NOR_FLASH_CTRL_REG :
+			_rdmsr(DIVIL_MSR_REG(NORF_CTRL), &hi, &lo);
+			conf_data = lo & 0x000000ff;
+			break;
+		case PCI_NOR_FLASH_T01_REG :
+			_rdmsr(DIVIL_MSR_REG(NORF_T01), &hi, &lo);
+			conf_data = lo;
+			break;
+		case PCI_NOR_FLASH_T23_REG :
+			_rdmsr(DIVIL_MSR_REG(NORF_T23), &hi, &lo);
+			conf_data = lo;
+			break;
+		default :
+			conf_data = 0;
+			break;
+	}
+	return conf_data;
+}
+#endif  /* TEST_CS5536_USE_NOR_FLASH */
+
+#else	/* TEST_CS5536_USE_FLASH */
+
+static void pci_flash_write_reg(int reg, u32 value)
+{
+	return;
+}
+
+static u32 pci_flash_read_reg(int reg)
+{
+	return 0xffffffff;
+}
+
+#endif	/* TEST_CS5536_USE_FLASH */
+
+/*
+ * ide_write : ide write transfering
+ */
+static void pci_ide_write_reg(int reg, u32 value)
+{
+	u32 hi, lo;
+	
+	switch(reg){
+		case PCI_COMMAND_STATUS_REG :
+			// COMMAND
+			if(value & PCI_COMMAND_MASTER_ENABLE){
+				_rdmsr(GLIU_MSR_REG(GLIU_PAE), &hi, &lo);
+				lo |= (0x03 << 4);
+				_wrmsr(GLIU_MSR_REG(GLIU_PAE), hi, lo);			
+			}else{
+				_rdmsr(GLIU_MSR_REG(GLIU_PAE), &hi, &lo);
+				lo &= ~(0x03 << 4);
+				_wrmsr(GLIU_MSR_REG(GLIU_PAE), hi, lo);	
+			}
+			// STATUS
+			if(value & PCI_STATUS_PARITY_ERROR){
+				_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+				if(lo & SB_PARE_ERR_FLAG){
+					lo = (lo & 0x0000ffff) | SB_PARE_ERR_FLAG;
+					_wrmsr(SB_MSR_REG(SB_ERROR), hi, lo);
+				}				
+			}
+			break;
+		case PCI_BHLC_REG :
+			value &= 0x0000ff00;
+			_rdmsr(SB_MSR_REG(SB_CTRL), &hi, &lo);
+			hi &= 0xffffff00;
+			hi |= (value >> 8);
+			_wrmsr(SB_MSR_REG(SB_CTRL), hi, lo);
+			break;
+		case PCI_BAR4_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_IDE_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if(value & 0x01){
+				hi = 0x00000000;
+				//lo = ((value & 0x0fffffff) << 4) | 0x001;
+				lo = (value & 0xfffffff0) | 0x1;
+				_wrmsr(IDE_MSR_REG(IDE_IO_BAR), hi, lo);
+
+				value &= 0xfffffffc;
+				hi = 0x60000000 | ((value & 0x000ff000) >> 12);
+				lo = 0x000ffff0 | ((value & 0x00000fff) << 20);
+				_wrmsr(GLIU_MSR_REG(GLIU_IOD_BM2), hi, lo);
+	   		}
+			break;
+		case PCI_IDE_CFG_REG :
+			if(value == CS5536_IDE_FLASH_SIGNATURE){
+				_rdmsr(DIVIL_MSR_REG(DIVIL_BALL_OPTS), &hi, &lo);
+				lo |= 0x01;
+				_wrmsr(DIVIL_MSR_REG(DIVIL_BALL_OPTS), hi, lo);
+			}else{
+				hi = 0;
+				lo = value;
+				_wrmsr(IDE_MSR_REG(IDE_CFG), hi, lo);			
+			}
+			break;
+		case PCI_IDE_DTC_REG :
+			hi = 0;
+			lo = value;
+			_wrmsr(IDE_MSR_REG(IDE_DTC), hi, lo);
+			break;
+		case PCI_IDE_CAST_REG :
+			hi = 0;
+			lo = value;
+			_wrmsr(IDE_MSR_REG(IDE_CAST), hi, lo);
+			break;
+		case PCI_IDE_ETC_REG :
+			hi = 0;
+			lo = value;
+			_wrmsr(IDE_MSR_REG(IDE_ETC), hi, lo);
+			break;
+		case PCI_IDE_PM_REG :
+			hi = 0;
+			lo = value;
+			_wrmsr(IDE_MSR_REG(IDE_INTERNAL_PM), hi, lo);
+			break;
+		default :
+			break;			
+	}
+	
+	return;
+}
+
+/*
+ * ide_read : ide read tranfering.
+ */
+static u32 pci_ide_read_reg(int reg)
+{
+	u32 conf_data;
+	u32 hi, lo;
+	
+	switch(reg){
+		case PCI_ID_REG :
+			conf_data = (CS5536_IDE_DEVICE_ID << 16 | CS5536_VENDOR_ID);
+			break;
+		case PCI_COMMAND_STATUS_REG :
+			conf_data = 0;
+			// COMMAND
+			_rdmsr(IDE_MSR_REG(IDE_IO_BAR), &hi, &lo);
+			if(lo & 0xfffffff0)
+				conf_data |= PCI_COMMAND_IO_ENABLE;
+			_rdmsr(GLIU_MSR_REG(GLIU_PAE), &hi, &lo);
+			if( (lo & 0x30) == 0x30 )
+				conf_data |= PCI_COMMAND_MASTER_ENABLE;
+			/* conf_data |= PCI_COMMAND_BACKTOBACK_ENABLE??? HOW TO GET..*/
+			//STATUS
+			conf_data |= PCI_STATUS_66MHZ_SUPPORT;
+			conf_data |= PCI_STATUS_BACKTOBACK_SUPPORT;
+			_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+			if(lo & SB_PARE_ERR_FLAG)
+				conf_data |= PCI_STATUS_PARITY_ERROR;
+			conf_data |= PCI_STATUS_DEVSEL_MEDIUM;
+			break;
+		case PCI_CLASS_REG :
+			_rdmsr(IDE_MSR_REG(IDE_CAP), &hi, &lo);
+			conf_data = lo & 0x000000ff;
+			conf_data |= (CS5536_IDE_CLASS_CODE << 8);
+			break;
+		case PCI_BHLC_REG :
+			_rdmsr(SB_MSR_REG(SB_CTRL), &hi, &lo);
+			hi &= 0x000000f8;
+			conf_data = (PCI_NONE_BIST << 24) | (PCI_NORMAL_HEADER_TYPE << 16) |
+				(hi << 8) | PCI_NORMAL_CACHE_LINE_SIZE;
+			break;
+		case PCI_BAR0_REG :
+			conf_data = 0x00000000;
+			break;
+		case PCI_BAR1_REG :
+			conf_data = 0x00000000;
+			break;
+		case PCI_BAR2_REG :
+			conf_data = 0x00000000;
+			break;
+		case PCI_BAR3_REG :
+			conf_data = 0x00000000;
+			break;
+		case PCI_BAR4_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_IDE_FLAG){
+				conf_data = CS5536_IDE_RANGE | PCI_MAPREG_TYPE_IO;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_IDE_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(IDE_MSR_REG(IDE_IO_BAR), &hi, &lo);
+				//conf_data = lo >> 4;
+				conf_data = lo & 0xfffffff0;
+				conf_data |= 0x01;
+				conf_data &= ~0x02;
+			}
+			break;
+		case PCI_BAR5_REG :
+			conf_data = 0x00000000;
+			break;
+		case PCI_CARDBUS_CIS_REG :
+			conf_data = PCI_CARDBUS_CIS_POINTER;
+			break;
+		case PCI_SUBSYS_ID_REG :
+			conf_data = (CS5536_IDE_SUB_ID << 16) | CS5536_SUB_VENDOR_ID;
+			break;
+		case PCI_MAPREG_ROM :
+			conf_data = PCI_EXPANSION_ROM_BAR;
+			break;
+		case PCI_CAPLISTPTR_REG :
+			conf_data = PCI_CAPLIST_POINTER;
+			break;
+		case PCI_INTERRUPT_REG :
+			conf_data = (PCI_MAX_LATENCY << 24) | (PCI_MIN_GRANT << 16) | 
+				(PCI_DEFAULT_PIN << 8) | (CS5536_IDE_INTR);
+			break;
+		case PCI_IDE_CFG_REG :
+			_rdmsr(IDE_MSR_REG(IDE_CFG), &hi, &lo);
+			conf_data = lo;
+			break;
+		case PCI_IDE_DTC_REG :
+			_rdmsr(IDE_MSR_REG(IDE_DTC), &hi, &lo);
+			conf_data = lo;
+			break;
+		case PCI_IDE_CAST_REG :
+			_rdmsr(IDE_MSR_REG(IDE_CAST), &hi, &lo);
+			conf_data = lo;
+			break;
+		case PCI_IDE_ETC_REG :
+			_rdmsr(IDE_MSR_REG(IDE_ETC), &hi, &lo);
+			conf_data = lo;
+		case PCI_IDE_PM_REG :
+			_rdmsr(IDE_MSR_REG(IDE_INTERNAL_PM), &hi, &lo);
+			conf_data = lo;
+			break;
+			
+		default :
+			conf_data = 0;
+			break;
+	}
+
+	return conf_data;
+}
+
+static void pci_acc_write_reg(int reg, u32 value)
+{
+	u32 hi, lo;
+
+	switch(reg){
+		case PCI_COMMAND_STATUS_REG :
+			// COMMAND
+			if(value & PCI_COMMAND_MASTER_ENABLE){
+				_rdmsr(GLIU_MSR_REG(GLIU_PAE), &hi, &lo);
+				lo |= (0x03 << 8);
+				_wrmsr(GLIU_MSR_REG(GLIU_PAE), hi, lo);			
+			}else{
+				_rdmsr(GLIU_MSR_REG(GLIU_PAE), &hi, &lo);
+				lo &= ~(0x03 << 8);
+				_wrmsr(GLIU_MSR_REG(GLIU_PAE), hi, lo);	
+			}
+			// STATUS
+			if(value & PCI_STATUS_PARITY_ERROR){
+				_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+				if(lo & SB_PARE_ERR_FLAG){
+					lo = (lo & 0x0000ffff) | SB_PARE_ERR_FLAG;
+					_wrmsr(SB_MSR_REG(SB_ERROR), hi, lo);
+				}				
+			}
+			break;
+		case PCI_BAR0_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_ACC_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if( value & 0x01 ){
+				value &= 0xfffffffc;
+				hi = 0xA0000000 | ((value & 0x000ff000) >> 12);
+				lo = 0x000fff80 | ((value & 0x00000fff) << 20);
+				_wrmsr(GLIU_MSR_REG(GLIU_IOD_BM1), hi, lo);
+			}
+			break;
+		case PCI_ACC_INT_REG :
+			if(value){
+			/* enable all the acc interrupt in PIC */	
+				_rdmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), &hi, &lo);
+				lo &= ~(0xf << PIC_YSEL_LOW_ACC_SHIFT);
+				lo |= (CS5536_ACC_INTR << PIC_YSEL_LOW_ACC_SHIFT);
+				_wrmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), hi, lo);
+			}else{
+			/* disable all the usb interrupt in PIC */
+				_rdmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), &hi, &lo);
+				lo &= ~(0xf << PIC_YSEL_LOW_ACC_SHIFT);
+				_wrmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), hi, lo);
+			}
+			break;
+		default :
+			break;			
+	}
+
+	return;
+}
+
+static u32 pci_acc_read_reg(int reg)
+{
+	u32 hi, lo;
+	u32 conf_data;
+
+	switch(reg){
+		case PCI_ID_REG :
+			conf_data = (CS5536_ACC_DEVICE_ID << 16 | CS5536_VENDOR_ID);
+			break;
+		case PCI_COMMAND_STATUS_REG :
+			
+			conf_data = 0;
+			// COMMAND
+			_rdmsr(GLIU_MSR_REG(GLIU_IOD_BM1), &hi, &lo);
+			if( ( (lo & 0xfff00000) || (hi & 0x000000ff) ) 
+					&& ((hi & 0xf0000000) == 0xa0000000) )
+				conf_data |= PCI_COMMAND_IO_ENABLE;
+			_rdmsr(GLIU_MSR_REG(GLIU_PAE), &hi, &lo);
+			if( (lo & 0x300) == 0x300 )
+				conf_data |= PCI_COMMAND_MASTER_ENABLE;
+			/* conf_data |= PCI_COMMAND_BACKTOBACK_ENABLE??? HOW TO GET..*/
+			//STATUS
+			conf_data |= PCI_STATUS_66MHZ_SUPPORT;
+			conf_data |= PCI_STATUS_BACKTOBACK_SUPPORT;
+			_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+			if(lo & SB_PARE_ERR_FLAG)
+				conf_data |= PCI_STATUS_PARITY_ERROR;
+			conf_data |= PCI_STATUS_DEVSEL_MEDIUM;
+			break;
+		case PCI_CLASS_REG :
+			_rdmsr(ACC_MSR_REG(ACC_CAP), &hi, &lo);
+			conf_data = lo & 0x000000ff;
+			conf_data |= (CS5536_ACC_CLASS_CODE << 8);
+			break;
+		case PCI_BHLC_REG :
+			conf_data = (PCI_NONE_BIST << 24) | (PCI_NORMAL_HEADER_TYPE << 16) |
+				(PCI_NORMAL_LATENCY_TIMER << 8) | PCI_NORMAL_CACHE_LINE_SIZE;
+			break;
+		case PCI_BAR0_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_ACC_FLAG){
+				conf_data = CS5536_ACC_RANGE | PCI_MAPREG_TYPE_IO;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_ACC_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(GLIU_MSR_REG(GLIU_IOD_BM1), &hi, &lo);
+				conf_data = (hi & 0x000000ff) << 12;
+				conf_data |= (lo & 0xfff00000) >> 20; 
+				conf_data |= 0x01;
+				conf_data &= ~0x02;
+			}
+			break;
+		case PCI_BAR1_REG :
+			conf_data = 0x000000;
+			break;		
+		case PCI_BAR2_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR3_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR4_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR5_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_CARDBUS_CIS_REG :
+			conf_data = PCI_CARDBUS_CIS_POINTER;
+			break;
+		case PCI_SUBSYS_ID_REG :
+			conf_data = (CS5536_ACC_SUB_ID << 16) | CS5536_SUB_VENDOR_ID;
+			break;
+		case PCI_MAPREG_ROM :
+			conf_data = PCI_EXPANSION_ROM_BAR;
+			break;
+		case PCI_CAPLISTPTR_REG :
+			conf_data = PCI_CAPLIST_USB_POINTER;
+			break;
+		case PCI_INTERRUPT_REG :
+			conf_data = (PCI_MAX_LATENCY << 24) | (PCI_MIN_GRANT << 16) | 
+				(PCI_DEFAULT_PIN << 8) | (CS5536_ACC_INTR);
+			break;
+		default :
+			conf_data = 0;
+			break;
+	}
+
+	return conf_data;
+}
+
+
+/*
+ * ohci_write : ohci write tranfering.
+ */
+static void pci_ohci_write_reg(int reg, u32 value)
+{
+	u32 hi, lo;
+	
+	switch(reg){
+		case PCI_COMMAND_STATUS_REG :
+			// COMMAND
+			if(value & PCI_COMMAND_MASTER_ENABLE){
+				_rdmsr(USB_MSR_REG(USB_OHCI), &hi, &lo);
+				hi |= (1 << 2);
+				_wrmsr(USB_MSR_REG(USB_OHCI), hi, lo);
+			}else{
+				_rdmsr(USB_MSR_REG(USB_OHCI), &hi, &lo);
+				hi &= ~(1 << 2);
+				_wrmsr(USB_MSR_REG(USB_OHCI), hi, lo);
+			}
+			if(value & PCI_COMMAND_MEM_ENABLE){
+				_rdmsr(USB_MSR_REG(USB_OHCI), &hi, &lo);
+				hi |= (1 << 1);
+				_wrmsr(USB_MSR_REG(USB_OHCI), hi, lo);
+			}else{
+				_rdmsr(USB_MSR_REG(USB_OHCI), &hi, &lo);
+				hi &= ~(1 << 1);
+				_wrmsr(USB_MSR_REG(USB_OHCI), hi, lo);				
+			}
+			// STATUS
+			if(value & PCI_STATUS_PARITY_ERROR){
+				_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+				if(lo & SB_PARE_ERR_FLAG){
+					lo = (lo & 0x0000ffff) | SB_PARE_ERR_FLAG;
+					_wrmsr(SB_MSR_REG(SB_ERROR), hi, lo);
+				}				
+			}
+			break;
+		case PCI_BAR0_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_OHCI_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if( (value & 0x01) == 0x00 ){
+				_rdmsr(USB_MSR_REG(USB_OHCI), &hi, &lo);
+				//lo = (value & 0xffffff00) << 8;
+				lo = value;
+				_wrmsr(USB_MSR_REG(USB_OHCI), hi, lo);
+				
+				value &= 0xfffffff0;
+				hi = 0x40000000 | ((value & 0xff000000) >> 24);
+				lo = 0x000fffff | ((value & 0x00fff000) << 8);
+				_wrmsr(GLIU_MSR_REG(GLIU_P2D_BM3), hi, lo);
+			}
+			break;
+		case PCI_INTERRUPT_REG :
+			value &= 0x000000ff;
+			break;
+		case PCI_OHCI_PM_REG :
+			break;
+		case PCI_OHCI_INT_REG :
+			if(value){
+			/* enable all the usb interrupt in PIC */	
+				_rdmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), &hi, &lo);
+				lo &= ~(0xf << 8);
+				lo |= (CS5536_USB_INTR << 8);
+				_wrmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), hi, lo);
+			}else{
+			/* disable all the usb interrupt in PIC */
+				_rdmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), &hi, &lo);
+				lo &= ~(0xf << 8);
+				_wrmsr(DIVIL_MSR_REG(PIC_YSEL_LOW), hi, lo);
+			}
+			break;
+		default :
+			break;			
+	}
+	
+	return;
+}
+
+/*
+ * ohci_read : ohci read transfering.
+ */
+static u32 pci_ohci_read_reg(int reg)
+{
+	u32 conf_data;
+	u32 hi, lo;
+	
+	switch(reg){
+		case PCI_ID_REG :
+			conf_data = (CS5536_OHCI_DEVICE_ID << 16 | CS5536_VENDOR_ID);
+			break;
+		case PCI_COMMAND_STATUS_REG :
+			conf_data = 0;
+			// COMMAND
+			_rdmsr(USB_MSR_REG(USB_OHCI), &hi, &lo);
+			if(hi & 0x04)
+				conf_data |= PCI_COMMAND_MASTER_ENABLE;
+			if(hi & 0x02)
+				conf_data |= PCI_COMMAND_MEM_ENABLE;
+			// STATUS
+			conf_data |= PCI_STATUS_66MHZ_SUPPORT;
+			conf_data |= PCI_STATUS_BACKTOBACK_SUPPORT;
+			_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+			if(lo & SB_PARE_ERR_FLAG)
+				conf_data |= PCI_STATUS_PARITY_ERROR;
+			conf_data |= PCI_STATUS_DEVSEL_MEDIUM;
+			break;
+		case PCI_CLASS_REG :
+			_rdmsr(USB_MSR_REG(USB_CAP), &hi, &lo);
+			conf_data = lo & 0x000000ff;
+			conf_data |= (CS5536_OHCI_CLASS_CODE << 8);
+			break;
+		case PCI_BHLC_REG :
+			conf_data = (PCI_NONE_BIST << 24) | (PCI_NORMAL_HEADER_TYPE << 16) |
+				(0x00 << 8) | PCI_NORMAL_CACHE_LINE_SIZE;
+			break;
+		case PCI_BAR0_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_OHCI_FLAG){
+				conf_data = CS5536_OHCI_RANGE | PCI_MAPREG_TYPE_MEM;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_OHCI_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(USB_MSR_REG(USB_OHCI), &hi, &lo);
+				//conf_data = lo >> 8;
+				conf_data = lo & 0xffffff00;
+				conf_data &= ~0x0000000f; // 32bit mem
+			}
+			break;
+		case PCI_BAR1_REG :
+			conf_data = 0x000000;
+			break;		
+		case PCI_BAR2_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR3_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR4_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR5_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_CARDBUS_CIS_REG :
+			conf_data = PCI_CARDBUS_CIS_POINTER;
+			break;
+		case PCI_SUBSYS_ID_REG :
+			conf_data = (CS5536_OHCI_SUB_ID << 16) | CS5536_SUB_VENDOR_ID;
+			break;
+		case PCI_MAPREG_ROM :
+			conf_data = PCI_EXPANSION_ROM_BAR;
+			break;
+		case PCI_CAPLISTPTR_REG :
+			conf_data = PCI_CAPLIST_USB_POINTER;
+			break;
+		case PCI_INTERRUPT_REG :
+			conf_data = (PCI_MAX_LATENCY << 24) | (PCI_MIN_GRANT << 16) | 
+				(PCI_DEFAULT_PIN << 8) | (CS5536_USB_INTR);
+			break;
+		case PCI_OHCI_PM_REG :
+			conf_data = 0;
+			break;
+		case PCI_OHCI_INT_REG :
+			_rdmsr(DIVIL_MSR_REG(0x20), &hi, &lo);
+			if((lo & 0x00000f00) == 11)
+				conf_data = 1;
+			else
+				conf_data = 0;
+			break;
+		default :
+			conf_data = 0;
+			break;
+	}
+
+	return conf_data;
+}
+
+#ifdef	TEST_CS5536_USE_EHCI
+static void pci_ehci_write_reg(int reg, u32 value)
+{
+	u32 hi, lo;
+	
+	switch(reg){
+		case PCI_COMMAND_STATUS_REG :
+			// COMMAND
+			if(value & PCI_COMMAND_MASTER_ENABLE){
+				_rdmsr(USB_MSR_REG(USB_EHCI), &hi, &lo);
+				hi |= (1 << 2);
+				_wrmsr(USB_MSR_REG(USB_EHCI), hi, lo);
+			}else{
+				_rdmsr(USB_MSR_REG(USB_EHCI), &hi, &lo);
+				hi &= ~(1 << 2);
+				_wrmsr(USB_MSR_REG(USB_EHCI), hi, lo);
+			}
+			if(value & PCI_COMMAND_MEM_ENABLE){
+				_rdmsr(USB_MSR_REG(USB_EHCI), &hi, &lo);
+				hi |= (1 << 1);
+				_wrmsr(USB_MSR_REG(USB_EHCI), hi, lo);
+			}else{
+				_rdmsr(USB_MSR_REG(USB_EHCI), &hi, &lo);
+				hi &= ~(1 << 1);
+				_wrmsr(USB_MSR_REG(USB_EHCI), hi, lo);				
+			}
+			// STATUS
+			if(value & PCI_STATUS_PARITY_ERROR){
+				_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+				if(lo & SB_PARE_ERR_FLAG){
+					lo = (lo & 0x0000ffff) | SB_PARE_ERR_FLAG;
+					_wrmsr(SB_MSR_REG(SB_ERROR), hi, lo);
+				}				
+			}
+			break;
+		case PCI_BAR0_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_EHCI_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if( (value & 0x01) == 0x00 ){
+				_rdmsr(USB_MSR_REG(USB_EHCI), &hi, &lo);
+				lo = value;
+				_wrmsr(USB_MSR_REG(USB_EHCI), hi, lo);
+				
+				value &= 0xfffffff0;
+				hi = 0x40000000 | ((value & 0xff000000) >> 24);
+				lo = 0x000fffff | ((value & 0x00fff000) << 8);
+				_wrmsr(GLIU_MSR_REG(GLIU_P2D_BM4), hi, lo);
+			}
+			break;
+		case PCI_EHCI_LEGSMIEN_REG :
+			_rdmsr(USB_MSR_REG(USB_EHCI), &hi, &lo);
+			hi &= 0x003f0000;
+			hi |= (value & 0x3f) << 16;
+			_wrmsr(USB_MSR_REG(USB_EHCI), hi, lo);
+			break;
+		case PCI_EHCI_FLADJ_REG :
+			_rdmsr(USB_MSR_REG(USB_EHCI), &hi, &lo);
+			hi &= ~0x00003f00;
+			hi |= value & 0x00003f00;
+			_wrmsr(USB_MSR_REG(USB_EHCI), hi, lo);
+			break;
+		default :
+			break;			
+	}
+	
+	return;
+}
+
+static u32 pci_ehci_read_reg(int reg)
+{
+	u32 conf_data;
+	u32 hi, lo;
+	
+	switch(reg){
+		case PCI_ID_REG :
+			conf_data = (CS5536_EHCI_DEVICE_ID << 16 | CS5536_VENDOR_ID);
+			break;
+		case PCI_COMMAND_STATUS_REG :
+			conf_data = 0;
+			// COMMAND
+			_rdmsr(USB_MSR_REG(USB_EHCI), &hi, &lo);
+			if(hi & 0x04)
+				conf_data |= PCI_COMMAND_MASTER_ENABLE;
+			if(hi & 0x02)
+				conf_data |= PCI_COMMAND_MEM_ENABLE;
+			// STATUS
+			conf_data |= PCI_STATUS_66MHZ_SUPPORT;
+			conf_data |= PCI_STATUS_BACKTOBACK_SUPPORT;
+			_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+			if(lo & SB_PARE_ERR_FLAG)
+				conf_data |= PCI_STATUS_PARITY_ERROR;
+			conf_data |= PCI_STATUS_DEVSEL_MEDIUM;
+			break;
+		case PCI_CLASS_REG :
+			_rdmsr(USB_MSR_REG(USB_CAP), &hi, &lo);
+			conf_data = lo & 0x000000ff;
+			conf_data |= (CS5536_EHCI_CLASS_CODE << 8);
+			break;
+		case PCI_BHLC_REG :
+			conf_data = (PCI_NONE_BIST << 24) | (PCI_NORMAL_HEADER_TYPE << 16) |
+				(PCI_NORMAL_LATENCY_TIMER << 8) | PCI_NORMAL_CACHE_LINE_SIZE;
+			break;
+		case PCI_BAR0_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_EHCI_FLAG){
+				conf_data = CS5536_EHCI_RANGE | PCI_MAPREG_TYPE_MEM;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_EHCI_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(USB_MSR_REG(USB_EHCI), &hi, &lo);
+				conf_data = lo & 0xfffff000;
+			}
+			break;
+		case PCI_BAR1_REG :
+			conf_data = 0x000000;
+			break;		
+		case PCI_BAR2_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR3_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR4_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR5_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_CARDBUS_CIS_REG :
+			conf_data = PCI_CARDBUS_CIS_POINTER;
+			break;
+		case PCI_SUBSYS_ID_REG :
+			conf_data = (CS5536_EHCI_SUB_ID << 16) | CS5536_SUB_VENDOR_ID;
+			break;
+		case PCI_MAPREG_ROM :
+			conf_data = PCI_EXPANSION_ROM_BAR;
+			break;
+		case PCI_CAPLISTPTR_REG :
+			conf_data = PCI_CAPLIST_USB_POINTER;
+			break;
+		case PCI_INTERRUPT_REG :
+			conf_data = (PCI_MAX_LATENCY << 24) | (PCI_MIN_GRANT << 16) | 
+				(PCI_DEFAULT_PIN << 8) | (CS5536_USB_INTR);
+			break;
+		case PCI_EHCI_LEGSMIEN_REG :
+			_rdmsr(USB_MSR_REG(USB_EHCI), &hi, &lo);
+			conf_data = (hi & 0x003f0000) >> 16;
+			break;
+		case PCI_EHCI_LEGSMISTS_REG :
+			_rdmsr(USB_MSR_REG(USB_EHCI), &hi, &lo);
+			conf_data = (hi & 0x3f000000) >> 24;
+			break;
+		case PCI_EHCI_FLADJ_REG :
+			_rdmsr(USB_MSR_REG(USB_EHCI), &hi, &lo);
+			conf_data = hi & 0x00003f00;
+			break;
+		default :
+			conf_data = 0;
+			break;
+	}
+
+	return conf_data;
+}
+#else
+static void pci_ehci_write_reg(int reg, u32 value)
+{
+	return;
+}
+
+static u32 pci_ehci_read_reg(int reg)
+{
+	return  0xffffffff;
+}
+
+
+#endif
+
+#ifdef	TEST_CS5536_USE_UDC
+static void pci_udc_write_reg(int reg, u32 value)
+{
+	u32 hi, lo;
+	
+	switch(reg){
+		case PCI_COMMAND_STATUS_REG :
+			// COMMAND
+			if(value & PCI_COMMAND_MASTER_ENABLE){
+				_rdmsr(USB_MSR_REG(USB_UDC), &hi, &lo);
+				hi |= (1 << 2);
+				_wrmsr(USB_MSR_REG(USB_UDC), hi, lo);
+			}else{
+				_rdmsr(USB_MSR_REG(USB_UDC), &hi, &lo);
+				hi &= ~(1 << 2);
+				_wrmsr(USB_MSR_REG(USB_UDC), hi, lo);
+			}
+			if(value & PCI_COMMAND_MEM_ENABLE){
+				_rdmsr(USB_MSR_REG(USB_UDC), &hi, &lo);
+				hi |= (1 << 1);
+				_wrmsr(USB_MSR_REG(USB_UDC), hi, lo);
+			}else{
+				_rdmsr(USB_MSR_REG(USB_UDC), &hi, &lo);
+				hi &= ~(1 << 1);
+				_wrmsr(USB_MSR_REG(USB_UDC), hi, lo);				
+			}
+			// STATUS
+			if(value & PCI_STATUS_PARITY_ERROR){
+				_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+				if(lo & SB_PARE_ERR_FLAG){
+					lo = (lo & 0x0000ffff) | SB_PARE_ERR_FLAG;
+					_wrmsr(SB_MSR_REG(SB_ERROR), hi, lo);
+				}				
+			}
+			break;
+		case PCI_BAR0_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_UDC_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if( (value & 0x01) == 0x00 ){
+				_rdmsr(USB_MSR_REG(USB_UDC), &hi, &lo);
+				lo = value;
+				_wrmsr(USB_MSR_REG(USB_UDC), hi, lo);
+				
+				value &= 0xfffffff0;
+				hi = 0x40000000 | ((value & 0xff000000) >> 24);
+				lo = 0x000fffff | ((value & 0x00fff000) << 8);
+				_wrmsr(GLIU_MSR_REG(GLIU_P2D_BM0), hi, lo);
+			}
+			break;
+		default :
+			break;			
+	}
+	
+	return;
+}
+
+static u32 pci_udc_read_reg(int reg)
+{
+	u32 conf_data;
+	u32 hi, lo;
+	
+	switch(reg){
+		case PCI_ID_REG :
+			conf_data = (CS5536_UDC_DEVICE_ID << 16 | CS5536_VENDOR_ID);
+			break;
+		case PCI_COMMAND_STATUS_REG :
+			conf_data = 0;
+			// COMMAND
+			_rdmsr(USB_MSR_REG(USB_UDC), &hi, &lo);
+			if(hi & 0x04)
+				conf_data |= PCI_COMMAND_MASTER_ENABLE;
+			if(hi & 0x02)
+				conf_data |= PCI_COMMAND_MEM_ENABLE;
+			// STATUS
+			conf_data |= PCI_STATUS_66MHZ_SUPPORT;
+			conf_data |= PCI_STATUS_BACKTOBACK_SUPPORT;
+			_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+			if(lo & SB_PARE_ERR_FLAG)
+				conf_data |= PCI_STATUS_PARITY_ERROR;
+			conf_data |= PCI_STATUS_DEVSEL_MEDIUM;
+			break;
+		case PCI_CLASS_REG :
+			_rdmsr(USB_MSR_REG(USB_CAP), &hi, &lo);
+			conf_data = lo & 0x000000ff;
+			conf_data |= (CS5536_UDC_CLASS_CODE << 8);
+			break;
+		case PCI_BHLC_REG :
+			conf_data = (PCI_NONE_BIST << 24) | (PCI_NORMAL_HEADER_TYPE << 16) |
+				(0x00 << 8) | PCI_NORMAL_CACHE_LINE_SIZE;
+			break;
+		case PCI_BAR0_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_UDC_FLAG){
+				conf_data = CS5536_UDC_RANGE | PCI_MAPREG_TYPE_MEM;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_UDC_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(USB_MSR_REG(USB_UDC), &hi, &lo);
+				conf_data = lo & 0xfffff000;
+				conf_data &= ~0x0000000f; // 32bit mem
+			}
+			break;
+		case PCI_BAR1_REG :
+			conf_data = 0x000000;
+			break;		
+		case PCI_BAR2_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR3_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR4_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR5_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_CARDBUS_CIS_REG :
+			conf_data = PCI_CARDBUS_CIS_POINTER;
+			break;
+		case PCI_SUBSYS_ID_REG :
+			conf_data = (CS5536_UDC_SUB_ID << 16) | CS5536_SUB_VENDOR_ID;
+			break;
+		case PCI_MAPREG_ROM :
+			conf_data = PCI_EXPANSION_ROM_BAR;
+			break;
+		case PCI_CAPLISTPTR_REG :
+			conf_data = PCI_CAPLIST_USB_POINTER;
+			break;
+		case PCI_INTERRUPT_REG :
+			conf_data = (PCI_MAX_LATENCY << 24) | (PCI_MIN_GRANT << 16) | 
+				(PCI_DEFAULT_PIN << 8) | (CS5536_USB_INTR);
+			break;
+		default :
+			conf_data = 0;
+			break;
+	}
+
+	return conf_data;
+}
+
+#else	/* TEST_CS5536_USE_UDC */
+
+static void pci_udc_write_reg(int reg, u32 value)
+{
+	return;
+}
+
+static u32 pci_udc_read_reg(int reg)
+{
+	return  0xffffffff;
+}
+
+#endif	/* TEST_CS5536_USE_UDC */
+
+
+#ifdef	TEST_CS5536_USE_OTG
+static void pci_otg_write_reg(int reg, u32 value)
+{
+	u32 hi, lo;
+	
+	switch(reg){
+		case PCI_COMMAND_STATUS_REG :
+			// COMMAND
+			if(value & PCI_COMMAND_MEM_ENABLE){
+				_rdmsr(USB_MSR_REG(USB_OTG), &hi, &lo);
+				hi |= (1 << 1);
+				_wrmsr(USB_MSR_REG(USB_OTG), hi, lo);
+			}else{
+				_rdmsr(USB_MSR_REG(USB_OTG), &hi, &lo);
+				hi &= ~(1 << 1);
+				_wrmsr(USB_MSR_REG(USB_OTG), hi, lo);				
+			}
+			// STATUS
+			if(value & PCI_STATUS_PARITY_ERROR){
+				_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+				if(lo & SB_PARE_ERR_FLAG){
+					lo = (lo & 0x0000ffff) | SB_PARE_ERR_FLAG;
+					_wrmsr(SB_MSR_REG(SB_ERROR), hi, lo);
+				}				
+			}
+			break;
+		case PCI_BAR0_REG :
+			if(value == PCI_BAR_RANGE_MASK){
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo |= SOFT_BAR_OTG_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else if( (value & 0x01) == 0x00 ){
+				_rdmsr(USB_MSR_REG(USB_OTG), &hi, &lo);
+				lo = value & 0xffffff00;
+				_wrmsr(USB_MSR_REG(USB_OTG), hi, lo);
+				
+				value &= 0xfffffff0;
+				hi = 0x40000000 | ((value & 0xff000000) >> 24);
+				lo = 0x000fffff | ((value & 0x00fff000) << 8);
+				_wrmsr(GLIU_MSR_REG(GLIU_P2D_BM1), hi, lo);
+			}
+			break;
+		default :
+			break;			
+	}
+	
+	return;
+}
+
+static u32 pci_otg_read_reg(int reg)
+{
+	u32 conf_data;
+	u32 hi, lo;
+	
+	switch(reg){
+		case PCI_ID_REG :
+			conf_data = (CS5536_OTG_DEVICE_ID << 16 | CS5536_VENDOR_ID);
+			break;
+		case PCI_COMMAND_STATUS_REG :
+			conf_data = 0;
+			// COMMAND
+			_rdmsr(USB_MSR_REG(USB_OTG), &hi, &lo);
+			if(hi & 0x02)
+				conf_data |= PCI_COMMAND_MEM_ENABLE;
+			// STATUS
+			conf_data |= PCI_STATUS_66MHZ_SUPPORT;
+			conf_data |= PCI_STATUS_BACKTOBACK_SUPPORT;
+			_rdmsr(SB_MSR_REG(SB_ERROR), &hi, &lo);
+			if(lo & SB_PARE_ERR_FLAG)
+				conf_data |= PCI_STATUS_PARITY_ERROR;
+			conf_data |= PCI_STATUS_DEVSEL_MEDIUM;
+			break;
+		case PCI_CLASS_REG :
+			_rdmsr(USB_MSR_REG(USB_CAP), &hi, &lo);
+			conf_data = lo & 0x000000ff;
+			conf_data |= (CS5536_OTG_CLASS_CODE << 8);
+			break;
+		case PCI_BHLC_REG :
+			conf_data = (PCI_NONE_BIST << 24) | (PCI_NORMAL_HEADER_TYPE << 16) |
+				(0x00 << 8) | PCI_NORMAL_CACHE_LINE_SIZE;
+			break;
+		case PCI_BAR0_REG :
+			_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+			if(lo & SOFT_BAR_OTG_FLAG){
+				conf_data = CS5536_OTG_RANGE | PCI_MAPREG_TYPE_MEM;
+				_rdmsr(GLCP_MSR_REG(GLCP_SOFT_COM), &hi, &lo);
+				lo &= ~SOFT_BAR_OTG_FLAG;
+				_wrmsr(GLCP_MSR_REG(GLCP_SOFT_COM), hi, lo);
+			}else{
+				_rdmsr(USB_MSR_REG(USB_OTG), &hi, &lo);
+				conf_data = lo & 0xffffff00;
+				conf_data &= ~0x0000000f;
+			}
+			break;
+		case PCI_BAR1_REG :
+			conf_data = 0x000000;
+			break;		
+		case PCI_BAR2_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR3_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR4_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_BAR5_REG :
+			conf_data = 0x000000;
+			break;
+		case PCI_CARDBUS_CIS_REG :
+			conf_data = PCI_CARDBUS_CIS_POINTER;
+			break;
+		case PCI_SUBSYS_ID_REG :
+			conf_data = (CS5536_OTG_SUB_ID << 16) | CS5536_SUB_VENDOR_ID;
+			break;
+		case PCI_MAPREG_ROM :
+			conf_data = PCI_EXPANSION_ROM_BAR;
+			break;
+		case PCI_CAPLISTPTR_REG :
+			conf_data = PCI_CAPLIST_USB_POINTER;
+			break;
+		case PCI_INTERRUPT_REG :
+			conf_data = (PCI_MAX_LATENCY << 24) | (PCI_MIN_GRANT << 16) | 
+				(PCI_DEFAULT_PIN << 8) | (CS5536_USB_INTR);
+			break;
+		default :
+			conf_data = 0;
+			break;
+	}
+
+	return conf_data;
+}
+
+#else	/* TEST_CS5536_USE_OTG */
+
+static void pci_otg_write_reg(int reg, u32 value)
+{
+	return;
+}
+
+static u32 pci_otg_read_reg(int reg)
+{
+	return 0xffffffff;
+}
+
+#endif	/* TEST_CS5536_USE_OTG */
+
+/*******************************************************************************/
+
+/*
+ * writen : write to PCI config space and transfer it to MSR write.
+ */
+void cs5536_pci_conf_write4(int function, int reg, u32 value)
+{
+	/* some basic checking. */
+	if( (function < CS5536_FUNC_START) || (function > CS5536_FUNC_END) ){
+		return;
+	}
+	if( (reg < 0) || (reg > 0x100) || ((reg & 0x03) != 0) ){
+		return;
+	}
+	
+	switch(function){
+		case CS5536_ISA_FUNC :
+			pci_isa_write_reg(reg, value);		
+			break;
+
+		case CS5536_FLASH_FUNC :
+			pci_flash_write_reg(reg, value);
+			break;
+		
+		case CS5536_IDE_FUNC :
+			pci_ide_write_reg(reg, value);
+			break;
+
+		case CS5536_ACC_FUNC :
+			pci_acc_write_reg(reg, value);
+			break;
+
+		case CS5536_OHCI_FUNC :
+			pci_ohci_write_reg(reg, value);
+			break;
+
+		case CS5536_EHCI_FUNC :
+			pci_ehci_write_reg(reg, value);
+			break;
+
+		case CS5536_UDC_FUNC :
+			pci_udc_write_reg(reg, value);
+			break;
+
+		case CS5536_OTG_FUNC :
+			pci_otg_write_reg(reg, value);
+			break;
+		
+		default :
+			break;
+	}
+	
+	return;
+}
+
+/*
+ * readn : read PCI config space and transfer it to MSR access.
+ */
+u32 cs5536_pci_conf_read4(int function, int reg)
+{
+	u32 data = 0;
+
+	/* some basic checking. */
+	if( (function < CS5536_FUNC_START) || (function > CS5536_FUNC_END) ){
+		return 0;
+	}
+	if( (reg < 0) || ((reg & 0x03) != 0) ){
+		return 0;
+	}
+	if( reg > 0x100 )
+		return 0xffffffff;
+	
+	switch(function){
+		case CS5536_ISA_FUNC :
+			data = pci_isa_read_reg(reg);
+			break;
+
+		case CS5536_FLASH_FUNC :
+			data = pci_flash_read_reg(reg);
+			break;
+		
+		case CS5536_IDE_FUNC :
+			data = pci_ide_read_reg(reg);
+			break;
+
+		case CS5536_ACC_FUNC :
+			data = pci_acc_read_reg(reg);
+			break;
+
+		case CS5536_OHCI_FUNC :
+			data = pci_ohci_read_reg(reg);
+			break;
+
+		case CS5536_EHCI_FUNC :
+			data = pci_ehci_read_reg(reg);
+			break;
+
+		case CS5536_UDC_FUNC :
+			data = pci_udc_read_reg(reg);
+			break;
+
+		case CS5536_OTG_FUNC :
+			data = pci_otg_read_reg(reg);
+			break;
+		
+		default :
+			break;
+	
+	}
+	
+	return data;
+}
+
+/**************************************************************************/
+
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/common/Makefile linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/Makefile
--- linux-2.6.29.1/arch/mips/lemote/lm2f/common/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/Makefile	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,10 @@
+#
+#  Copyright 2007, 2008 Lemote Tec
+#  Author: www.lemote.com Inc
+#
+# Makefile for the loongson2f CPUS, generic files
+#
+
+obj-y += mem.o mipsdha.o pci.o mem.o plat.o mfgpt.o
+obj-$(CONFIG_CS5536) += cs5536_vsm.o
+obj-$(CONFIG_LS2F_CPU_FREQ) += clock.o
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/common/mem.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/mem.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/common/mem.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/mem.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,76 @@
+/*
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/fs.h>
+#include <linux/fcntl.h>
+#include <linux/mm.h>
+
+#include <linux/pci.h>
+
+#include <linux/sched.h>
+#include <asm/current.h>
+
+static unsigned long uca_start; 
+static unsigned long uca_size = CONFIG_UCA_SIZE;
+/* override of arch/mips/mm/cache.c: __uncached_access */
+int __uncached_access(struct file *file, unsigned long addr)
+{
+	if (file->f_flags & O_SYNC)
+		return 1;
+
+	/*
+	 * On the Lemote 2f system, the peripheral IO/MMIO space 
+	 * reside between 0x1000:0000 and 0x8000:0000.
+	 */
+	return addr >= __pa(high_memory) ||
+		((addr >= 0x10000000) && (addr < 0x80000000));
+}
+
+pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
+				     unsigned long size, pgprot_t vma_prot)
+{
+	unsigned long offset = pfn << PAGE_SHIFT;
+	unsigned long end = offset + size;
+
+	if (__uncached_access(file, offset)) {
+		if(uca_start && offset >= uca_start && end <= (uca_start + uca_size))
+			return __pgprot((pgprot_val(vma_prot) & ~_CACHE_MASK)|_CACHE_UNCACHED_ACCELERATED);
+		else 
+			return pgprot_noncached(vma_prot);
+	}
+	return vma_prot;
+}
+
+static int __init find_vga_mem_init(void)
+{
+	struct pci_dev *dev = 0;
+	struct resource *r;
+	int idx;
+
+	if(uca_start)
+		return 0;
+	for_each_pci_dev(dev) {
+		if ((dev->class >> 8) == PCI_CLASS_DISPLAY_VGA){
+			for (idx=0; idx < PCI_NUM_RESOURCES; idx++) {
+				r = &dev->resource[idx];
+				if (!r->start && r->end) {
+					continue;
+				}
+				if (r->flags & IORESOURCE_IO)
+					continue;
+				if (r->flags & IORESOURCE_MEM){
+					uca_start = r->start;
+					printk("find the frame buffer:start=%lx\n", uca_start);
+					return 0;
+				}
+			}
+
+		}
+	}
+	return 0;
+}
+late_initcall(find_vga_mem_init);
+
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/common/mfgpt.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/mfgpt.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/common/mfgpt.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/mfgpt.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,222 @@
+/*
+ * CS5536 General timer functions
+ *
+ */
+#include <linux/clockchips.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <asm/time.h>
+
+DEFINE_SPINLOCK(mfgpt_lock);
+
+#if 1
+#define MFGFT_TICK_RATE 14318000
+#else
+#define MFGFT_TICK_RATE (14318180 / 8)
+#endif
+#define COMPARE  ((MFGFT_TICK_RATE + HZ/2) / HZ)
+
+extern void _wrmsr(u32 reg, u32 hi, u32 lo);
+extern void _rdmsr(u32 reg, u32 *hi, u32 *lo);
+
+static u32 base ;
+
+/*
+ * Initialize the MFGPT timer.
+ *
+ * This is also called after resume to bring the MFGPT into operation again.
+ */
+/* setup register bit fields:
+   15: counter enable
+   14: compare2 output status, write 1 to clear when in event mode
+   13: compare1 output status
+   12: setup(ro)
+   11: stop enable, stop on sleep
+   10: external enable
+   9:8 compare2 mode; 00: disable, 01: compare on equal; 10: compare on GE, 11 event: GE + irq
+   7:6 compare1 mode
+   5:  reverse enable, bit reverse of the counter
+   4:  clock select. 0: 32KHz, 1: 14.318MHz
+   3:0 counter prescaler scale factor. select the input clock divide-by value. 2^n
+   bit 11:0 is write once.
+*/
+   
+ 
+static void init_mfgpt_timer(enum clock_event_mode mode,
+			   struct clock_event_device *evt)
+{
+	spin_lock(&mfgpt_lock);
+
+	switch(mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		/* set comparator2 */
+		outw(COMPARE, base + 2);
+		/* set counter to 0 */
+		outw(0, base + 4);
+		/* setup; enable, comparator2 to event mode,14.318MHz clock */
+		//outw(0xe313, base + 6);
+		outw(0xe310, base + 6);
+		break;
+
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_UNUSED:
+		if (evt->mode == CLOCK_EVT_MODE_PERIODIC ||
+		    evt->mode == CLOCK_EVT_MODE_ONESHOT) {
+			/* disable counter */
+			outw(inw(base+6) & 0x7fff, base + 6);
+		}
+		break;
+
+	case CLOCK_EVT_MODE_ONESHOT:
+		/* One shot setup */
+		break;
+
+	case CLOCK_EVT_MODE_RESUME:
+		/* Nothing to do here */
+		break;
+	}
+	spin_unlock(&mfgpt_lock);
+}
+
+/*
+ * Program the next event in oneshot mode
+ *
+ * Delta is given in MFGPT ticks
+ */
+static int mfgpt_next_event(unsigned long delta, struct clock_event_device *evt)
+{
+	spin_lock(&mfgpt_lock);
+
+	/* set comparator2 */
+	outw(delta & 0xffff, base + 2);
+	/* set counter to 0 */
+	outw(0, base + 4);
+	/* setup; enable, comparator2 */
+	outw(0xe310, base + 6);
+
+	spin_unlock(&mfgpt_lock);
+
+	return 0;
+}
+
+static struct clock_event_device mfgpt_clockevent = {
+	.name		= "mfgpt",
+	.features	= CLOCK_EVT_FEAT_PERIODIC,
+	.set_mode	= init_mfgpt_timer,
+	.set_next_event = mfgpt_next_event,
+	.rating         = 2000,
+	.irq		= 5,
+};
+
+static irqreturn_t timer_interrupt(int irq, void *dev_id)
+{
+	u32 basehi,baselo;
+
+	_rdmsr(0x8000000d,&basehi,&baselo);
+
+	base = baselo;
+	/* ack */
+//	outw(0x0, baselo + 4);
+	outw(0xc000, baselo + 6);
+
+	mfgpt_clockevent.event_handler(&mfgpt_clockevent);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction irq5  = {
+	.handler = timer_interrupt,
+	.flags = IRQF_DISABLED | IRQF_NOBALANCING,
+	.mask = CPU_MASK_NONE,
+	.name = "timer"
+};
+
+/*
+ * Initialize the conversion factor and the min/max deltas of the clock event
+ * structure and register the clock event source with the framework.
+ */
+void __init setup_mfgpt_timer(void)
+{
+	u32 basehi;
+	struct clock_event_device *cd = &mfgpt_clockevent;
+	unsigned int cpu = smp_processor_id();
+
+	cd->cpumask = cpumask_of(cpu);
+	clockevent_set_clock(cd, MFGFT_TICK_RATE);
+	cd->max_delta_ns = clockevent_delta2ns(0xFFFF, cd);
+	cd->min_delta_ns = clockevent_delta2ns(0xF, cd);
+
+	/* connect multifunction timer0 comparator 2 to irq mapper*/
+	_wrmsr(0x80000028, 0, 0x100);
+
+	/* map unrestricted interrupt source Z4 to IG5 */
+	_wrmsr(0x80000022, 0, 0x50000);
+
+	_rdmsr(0x8000000d, &basehi, &base);
+
+	irq5.mask = cpumask_of_cpu(cpu);
+
+	clockevents_register_device(cd);
+
+	setup_irq(5, &irq5);
+
+}
+
+/*
+ * Since the MFGPT overflows every tick, its not very useful
+ * to just read by itself. So use jiffies to emulate a free
+ * running counter:
+ */
+static cycle_t mfgpt_read(void)
+{
+	static cycle_t count, old_count;
+	static unsigned long old_jifs;
+	unsigned long jifs;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mfgpt_lock, flags);
+
+	jifs = jiffies;
+
+	count =  inw(base + 4);
+
+	/* overflow ?*/
+	if (count < old_count && jifs == old_jifs) {
+		count = old_count;
+	}
+	old_count = count;
+	old_jifs = jifs;
+
+	spin_unlock_irqrestore(&mfgpt_lock, flags);
+
+	return (cycle_t)(jifs * COMPARE) + count;
+}
+
+static struct clocksource clocksource_mfgpt = {
+	.name	= "mfgpt",
+	.rating = 1200,
+	.read	= mfgpt_read,
+	.mask	= CLOCKSOURCE_MASK(32),
+	.mult	= 0,
+	.shift	= 22,
+};
+
+int __init init_mfgpt_clocksource(void)
+{
+
+	if (num_possible_cpus() > 1) /* MFGPT does not scale! */
+		return 0;
+
+	setup_mfgpt_timer();
+
+	clocksource_mfgpt.mult = clocksource_hz2mult(MFGFT_TICK_RATE, 22);
+	return clocksource_register(&clocksource_mfgpt);
+}
+/* too late to calc delay */
+//arch_initcall(init_mfgpt_clocksource);
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/common/mipsdha.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/mipsdha.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/common/mipsdha.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/mipsdha.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2007 Lemote, Inc. & Institute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+static ssize_t mipsdha_proc_read(struct file *file, char *buf, size_t len, loff_t *ppos);
+
+static ssize_t mipsdha_proc_write(struct file *file, const char *buf, size_t len, loff_t *ppos);
+
+
+static struct proc_dir_entry *mipsdha_proc_entry;
+
+#define INFO_SIZE 4096
+static char info_buf[INFO_SIZE];
+
+static struct file_operations mipsdha_fops =
+{
+    owner:	THIS_MODULE,
+    read:	mipsdha_proc_read,
+    write:	mipsdha_proc_write,
+};
+
+static enum {CMD_ERR, CMD_GIB, CMD_GPI} cmd;
+
+typedef struct pciinfo_s
+{
+  int		bus,card,func;
+  unsigned short command;
+  unsigned short vendor,device;
+  unsigned	base0,base1,base2,baserom;
+} pciinfo_t;
+
+
+extern struct proc_dir_entry proc_root;
+
+static int __init mipsdha_proc_init(void)
+{
+	mipsdha_proc_entry = create_proc_entry("mipsdha", S_IWUSR | S_IRUGO, &proc_root);
+	if (mipsdha_proc_entry == NULL) {
+		printk("MIPSDHA: register /proc/mipsdha failed!\n");
+		return 0;
+	}
+	
+	mipsdha_proc_entry->owner = THIS_MODULE;
+	mipsdha_proc_entry->proc_fops = &mipsdha_fops;
+
+	cmd=CMD_ERR;
+	return 0;
+}
+
+static ssize_t mipsdha_proc_write (struct file *file, const char *buf, size_t len, loff_t *ppos)
+{
+	char cmd_gib[]="GET IO BASE";
+	char cmd_gpi[]="GET PCI INFO";
+
+	if (len >= INFO_SIZE) return -ENOMEM;
+
+	if (copy_from_user(info_buf, buf, len)) return -EFAULT;
+	info_buf[len] = '\0';
+
+	if (strncmp(info_buf, cmd_gib, sizeof(cmd_gib)-1)==0) {
+		cmd = CMD_GIB;
+		return len;
+	} else if (strncmp(info_buf, cmd_gpi, sizeof(cmd_gpi)-1)==0) {
+		cmd = CMD_GPI;
+		return len;
+	} else {
+		return -EINVAL;
+	}
+}
+
+static ssize_t mipsdha_proc_read (struct file *file, char *buf, size_t len, loff_t *ppos)
+{
+	int info_cnt;
+	pciinfo_t *pciinfo;
+	struct pci_dev *dev = NULL;
+
+	switch (cmd) {
+		default:
+			printk("MIPSDHA: BUG found in function %s!(cmd=%d)\n", 
+					__FUNCTION__, cmd);
+			return -EINVAL;
+
+
+		case CMD_ERR:
+			return -EINVAL;
+
+
+		case CMD_GIB:
+			*(unsigned long *)info_buf = 
+				virt_to_phys((void *) mips_io_port_base);
+			info_cnt=sizeof(unsigned long);
+			break;
+
+
+		case CMD_GPI:
+			pciinfo = (pciinfo_t *) info_buf;
+			info_cnt = 0;
+			for_each_pci_dev(dev) {
+
+				if (info_cnt+sizeof(pciinfo_t)>INFO_SIZE) return -ENOMEM;
+
+				pciinfo->bus = dev->bus->number;
+				pciinfo->card = PCI_SLOT(dev->devfn);
+				pciinfo->func = PCI_FUNC(dev->devfn);
+
+				if (pci_read_config_word(dev, PCI_COMMAND, &pciinfo->command)
+						!= PCIBIOS_SUCCESSFUL) {
+					printk("MIPSDHA: BUG found in function %s!\n", 
+							__FUNCTION__);
+					pciinfo->command=0;
+				}
+
+				pciinfo->vendor = dev->vendor;
+				pciinfo->device = dev->device;
+
+				pciinfo->base0 = (dev->resource[0]).start;
+				pciinfo->base1 = (dev->resource[1]).start;
+				pciinfo->base2 = (dev->resource[2]).start;
+				pciinfo->baserom = (dev->resource[PCI_ROM_RESOURCE]).start;
+
+				pciinfo++;
+				info_cnt += sizeof(pciinfo_t);
+			}
+			break;
+	}
+
+	if (len < info_cnt) return -ENOMEM;
+	if (copy_to_user(buf, info_buf, info_cnt)) return -EFAULT;
+
+	return info_cnt;
+}
+
+__initcall(mipsdha_proc_init);
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/common/pci.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/pci.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/common/pci.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/pci.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,89 @@
+/*
+ * pci.c
+ *
+ * Copyright (C) 2007 Lemote, Inc. & Institute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+extern struct pci_ops loongson2f_pci_pci_ops;
+/* if you want to expand the pci memory space, you should config 64bits kernel too. */
+
+static struct resource loongson2f_pci_mem_resource = {
+	.name   = "PCI MEM",
+	.start  = 0x14000000UL,
+	.end    = 0x1fffffffUL,
+	.flags  = IORESOURCE_MEM,
+};
+
+static struct resource loongson2f_pci_io_resource = {
+	.name   = "PCI IO MEM",
+	.start  = 0x00004000UL,
+	.end    = 0x0000ffffUL,
+	.flags  = IORESOURCE_IO,
+};
+
+
+static struct pci_controller  loongson2f_pci_controller = {
+	.pci_ops        = &loongson2f_pci_pci_ops,
+	.io_resource    = &loongson2f_pci_io_resource,
+	.mem_resource   = &loongson2f_pci_mem_resource,
+	.mem_offset     = 0x00000000UL,
+	.io_offset      = 0x00000000UL,
+};
+
+static int __init pcibios_init(void)
+{
+	extern int pci_probe_only;
+	pci_probe_only = 0;
+
+#ifdef CONFIG_TRACE_BOOT
+	printk(KERN_INFO"arch_initcall:pcibios_init\n");
+	printk(KERN_INFO"register_pci_controller : %x\n",&loongson2f_pci_controller);
+#endif
+	
+#ifdef	CONFIG_64BIT
+	loongson2f_pci_mem_resource.start	= 0x50000000UL; 
+	loongson2f_pci_mem_resource.end		= 0x7fffffffUL;
+	__asm__(".set mips3\n"
+	         "dli $2,0x900000003ff00000\n"
+		 "li $3,0x40000000\n"
+		 "sd $3,0x18($2)\n"
+		 "or $3,1\n"
+		 "sd $3,0x58($2)\n"
+		 "dli $3,0xffffffffc0000000\n"
+		 "sd $3,0x38($2)\n"
+		 ".set mips0\n"
+		 :::"$2","$3","memory"
+			   );
+#endif
+	loongson2f_pci_controller.io_map_base = mips_io_port_base;
+	register_pci_controller(&loongson2f_pci_controller);
+	return 0;
+}
+
+arch_initcall(pcibios_init);
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/common/pcireg.h linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/pcireg.h
--- linux-2.6.29.1/arch/mips/lemote/lm2f/common/pcireg.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/pcireg.h	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,485 @@
+/*
+ * Copyright (c) 2001, 2006 www.ict.ac.cn.
+ * Copyright (c) 2006, 2008 www.lemote.com.cn.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DEV_PCI_PCIREG_H_
+#define	_DEV_PCI_PCIREG_H_
+
+
+/*
+ * Standardized PCI configuration information
+ *
+ * XXX This is not complete.
+ */
+
+/*
+ * Device identification register; contains a vendor ID and a device ID.
+ */
+#define	PCI_ID_REG			0x00
+
+typedef u_int16_t pci_vendor_id_t;
+typedef u_int16_t pci_product_id_t;
+
+#define	PCI_VENDOR_SHIFT			0
+#define	PCI_VENDOR_MASK				0xffff
+#define	PCI_VENDOR(id) \
+	    (((id) >> PCI_VENDOR_SHIFT) & PCI_VENDOR_MASK)
+
+#define	PCI_PRODUCT_SHIFT			16
+#define	PCI_PRODUCT_MASK			0xffff
+#define	PCI_PRODUCT(id) \
+	    (((id) >> PCI_PRODUCT_SHIFT) & PCI_PRODUCT_MASK)
+
+/*
+ * Command and status register.
+ */
+#define	PCI_COMMAND_STATUS_REG			0x04
+
+#define	PCI_COMMAND_IO_ENABLE			0x00000001
+#define	PCI_COMMAND_MEM_ENABLE			0x00000002
+#define	PCI_COMMAND_MASTER_ENABLE		0x00000004
+#define	PCI_COMMAND_SPECIAL_ENABLE		0x00000008
+#define	PCI_COMMAND_INVALIDATE_ENABLE		0x00000010
+#define	PCI_COMMAND_PALETTE_ENABLE		0x00000020
+#define	PCI_COMMAND_PARITY_ENABLE		0x00000040
+#define	PCI_COMMAND_STEPPING_ENABLE		0x00000080
+#define	PCI_COMMAND_SERR_ENABLE			0x00000100
+#define	PCI_COMMAND_BACKTOBACK_ENABLE		0x00000200
+
+#define	PCI_STATUS_CAPLIST_SUPPORT		0x00100000
+#define	PCI_STATUS_66MHZ_SUPPORT		0x00200000
+#define	PCI_STATUS_UDF_SUPPORT			0x00400000
+#define	PCI_STATUS_BACKTOBACK_SUPPORT		0x00800000
+#define	PCI_STATUS_PARITY_ERROR			0x01000000
+#define	PCI_STATUS_DEVSEL_FAST			0x00000000
+#define	PCI_STATUS_DEVSEL_MEDIUM		0x02000000
+#define	PCI_STATUS_DEVSEL_SLOW			0x04000000
+#define	PCI_STATUS_DEVSEL_MASK			0x06000000
+#define	PCI_STATUS_TARGET_TARGET_ABORT		0x08000000
+#define	PCI_STATUS_MASTER_TARGET_ABORT		0x10000000
+#define	PCI_STATUS_MASTER_ABORT			0x20000000
+#define	PCI_STATUS_SPECIAL_ERROR		0x40000000
+#define	PCI_STATUS_PARITY_DETECT		0x80000000
+
+/*
+ * PCI Class and Revision Register; defines type and revision of device.
+ */
+#define	PCI_CLASS_REG			0x08
+
+typedef u_int8_t pci_class_t;
+typedef u_int8_t pci_subclass_t;
+typedef u_int8_t pci_interface_t;
+typedef u_int8_t pci_revision_t;
+
+#define	PCI_CLASS_SHIFT				24
+#define	PCI_CLASS_MASK				0xff
+#define	PCI_CLASS(cr) \
+	    (((cr) >> PCI_CLASS_SHIFT) & PCI_CLASS_MASK)
+
+#define	PCI_SUBCLASS_SHIFT			16
+#define	PCI_SUBCLASS_MASK			0xff
+#define	PCI_SUBCLASS(cr) \
+	    (((cr) >> PCI_SUBCLASS_SHIFT) & PCI_SUBCLASS_MASK)
+
+#define PCI_ISCLASS(what, class, subclass) \
+	(((what) & 0xffff0000) == (class << 24 | subclass << 16))
+
+#define	PCI_INTERFACE_SHIFT			8
+#define	PCI_INTERFACE_MASK			0xff
+#define	PCI_INTERFACE(cr) \
+	    (((cr) >> PCI_INTERFACE_SHIFT) & PCI_INTERFACE_MASK)
+
+#define	PCI_REVISION_SHIFT			0
+#define	PCI_REVISION_MASK			0xff
+#define	PCI_REVISION(cr) \
+	    (((cr) >> PCI_REVISION_SHIFT) & PCI_REVISION_MASK)
+
+/* base classes */
+#define	PCI_CLASS_PREHISTORIC			0x00
+#define	PCI_CLASS_MASS_STORAGE			0x01
+#define	PCI_CLASS_NETWORK			0x02
+#define	PCI_CLASS_DISPLAY			0x03
+#define	PCI_CLASS_MULTIMEDIA			0x04
+#define	PCI_CLASS_MEMORY			0x05
+#define	PCI_CLASS_BRIDGE			0x06
+#define	PCI_CLASS_COMMUNICATIONS		0x07
+#define	PCI_CLASS_SYSTEM			0x08
+#define	PCI_CLASS_INPUT				0x09
+#define	PCI_CLASS_DOCK				0x0a
+#define	PCI_CLASS_PROCESSOR			0x0b
+#define	PCI_CLASS_SERIALBUS			0x0c
+#define	PCI_CLASS_WIRELESS			0x0d
+#define	PCI_CLASS_I2O				0x0e
+#define	PCI_CLASS_SATCOM			0x0f
+#define	PCI_CLASS_CRYPTO			0x10
+#define	PCI_CLASS_DASP				0x11
+#define	PCI_CLASS_UNDEFINED			0xff
+
+/* 0x00 prehistoric subclasses */
+#define	PCI_SUBCLASS_PREHISTORIC_MISC		0x00
+#define	PCI_SUBCLASS_PREHISTORIC_VGA		0x01
+
+/* 0x01 mass storage subclasses */
+#define	PCI_SUBCLASS_MASS_STORAGE_SCSI		0x00
+#define	PCI_SUBCLASS_MASS_STORAGE_IDE		0x01
+#define	PCI_SUBCLASS_MASS_STORAGE_FLOPPY	0x02
+#define	PCI_SUBCLASS_MASS_STORAGE_IPI		0x03
+#define	PCI_SUBCLASS_MASS_STORAGE_RAID		0x04
+#define	PCI_SUBCLASS_MASS_STORAGE_ATA		0x05
+#define	PCI_SUBCLASS_MASS_STORAGE_MISC		0x80
+
+/* 0x02 network subclasses */
+#define	PCI_SUBCLASS_NETWORK_ETHERNET		0x00
+#define	PCI_SUBCLASS_NETWORK_TOKENRING		0x01
+#define	PCI_SUBCLASS_NETWORK_FDDI		0x02
+#define	PCI_SUBCLASS_NETWORK_ATM		0x03
+#define	PCI_SUBCLASS_NETWORK_ISDN		0x04
+#define	PCI_SUBCLASS_NETWORK_WORLDFIP		0x05
+#define	PCI_SUBCLASS_NETWORK_PCIMGMULTICOMP	0x06
+#define	PCI_SUBCLASS_NETWORK_MISC		0x80
+
+/* 0x03 display subclasses */
+#define	PCI_SUBCLASS_DISPLAY_VGA		0x00
+#define	PCI_SUBCLASS_DISPLAY_XGA		0x01
+#define	PCI_SUBCLASS_DISPLAY_3D			0x02
+#define	PCI_SUBCLASS_DISPLAY_MISC		0x80
+
+/* 0x04 multimedia subclasses */
+#define	PCI_SUBCLASS_MULTIMEDIA_VIDEO		0x00
+#define	PCI_SUBCLASS_MULTIMEDIA_AUDIO		0x01
+#define	PCI_SUBCLASS_MULTIMEDIA_TELEPHONY	0x02
+#define	PCI_SUBCLASS_MULTIMEDIA_MISC		0x80
+
+/* 0x05 memory subclasses */
+#define	PCI_SUBCLASS_MEMORY_RAM			0x00
+#define	PCI_SUBCLASS_MEMORY_FLASH		0x01
+#define	PCI_SUBCLASS_MEMORY_MISC		0x80
+
+/* 0x06 bridge subclasses */
+#define	PCI_SUBCLASS_BRIDGE_HOST		0x00
+#define	PCI_SUBCLASS_BRIDGE_ISA			0x01
+#define	PCI_SUBCLASS_BRIDGE_EISA		0x02
+#define	PCI_SUBCLASS_BRIDGE_MC			0x03
+#define	PCI_SUBCLASS_BRIDGE_PCI			0x04
+#define	PCI_SUBCLASS_BRIDGE_PCMCIA		0x05
+#define	PCI_SUBCLASS_BRIDGE_NUBUS		0x06
+#define	PCI_SUBCLASS_BRIDGE_CARDBUS		0x07
+#define	PCI_SUBCLASS_BRIDGE_RACEWAY		0x08
+#define	PCI_SUBCLASS_BRIDGE_STPCI		0x09
+#define	PCI_SUBCLASS_BRIDGE_INFINIBAND		0x0a
+#define	PCI_SUBCLASS_BRIDGE_MISC		0x80
+
+/* 0x07 communications subclasses */
+#define	PCI_SUBCLASS_COMMUNICATIONS_SERIAL	0x00
+#define	PCI_SUBCLASS_COMMUNICATIONS_PARALLEL	0x01
+#define	PCI_SUBCLASS_COMMUNICATIONS_MPSERIAL	0x02
+#define	PCI_SUBCLASS_COMMUNICATIONS_MODEM	0x03
+#define	PCI_SUBCLASS_COMMUNICATIONS_MISC	0x80
+
+/* 0x08 system subclasses */
+#define	PCI_SUBCLASS_SYSTEM_PIC			0x00
+#define	PCI_SUBCLASS_SYSTEM_DMA			0x01
+#define	PCI_SUBCLASS_SYSTEM_TIMER		0x02
+#define	PCI_SUBCLASS_SYSTEM_RTC			0x03
+#define	PCI_SUBCLASS_SYSTEM_PCIHOTPLUG		0x04
+#define	PCI_SUBCLASS_SYSTEM_MISC		0x80
+
+/* 0x09 input subclasses */
+#define	PCI_SUBCLASS_INPUT_KEYBOARD		0x00
+#define	PCI_SUBCLASS_INPUT_DIGITIZER		0x01
+#define	PCI_SUBCLASS_INPUT_MOUSE		0x02
+#define	PCI_SUBCLASS_INPUT_SCANNER		0x03
+#define	PCI_SUBCLASS_INPUT_GAMEPORT		0x04
+#define	PCI_SUBCLASS_INPUT_MISC			0x80
+
+/* 0x0a dock subclasses */
+#define	PCI_SUBCLASS_DOCK_GENERIC		0x00
+#define	PCI_SUBCLASS_DOCK_MISC			0x80
+
+/* 0x0b processor subclasses */
+#define	PCI_SUBCLASS_PROCESSOR_386		0x00
+#define	PCI_SUBCLASS_PROCESSOR_486		0x01
+#define	PCI_SUBCLASS_PROCESSOR_PENTIUM		0x02
+#define	PCI_SUBCLASS_PROCESSOR_ALPHA		0x10
+#define	PCI_SUBCLASS_PROCESSOR_POWERPC		0x20
+#define	PCI_SUBCLASS_PROCESSOR_MIPS		0x30
+#define	PCI_SUBCLASS_PROCESSOR_COPROC		0x40
+
+/* 0x0c serial bus subclasses */
+#define	PCI_SUBCLASS_SERIALBUS_FIREWIRE		0x00
+#define	PCI_SUBCLASS_SERIALBUS_ACCESS		0x01
+#define	PCI_SUBCLASS_SERIALBUS_SSA		0x02
+#define	PCI_SUBCLASS_SERIALBUS_USB		0x03
+#define	PCI_SUBCLASS_SERIALBUS_FIBER		0x04
+#define	PCI_SUBCLASS_SERIALBUS_SMBUS		0x05
+#define	PCI_SUBCLASS_SERIALBUS_INFINIBAND	0x06
+#define	PCI_SUBCLASS_SERIALBUS_IPMI		0x07
+#define	PCI_SUBCLASS_SERIALBUS_SERCOS		0x08
+#define	PCI_SUBCLASS_SERIALBUS_CANBUS		0x09
+
+/* 0x0d wireless subclasses */
+#define	PCI_SUBCLASS_WIRELESS_IRDA		0x00
+#define	PCI_SUBCLASS_WIRELESS_CONSUMERIR	0x01
+#define	PCI_SUBCLASS_WIRELESS_RF		0x10
+#define	PCI_SUBCLASS_WIRELESS_MISC		0x80
+
+/* 0x0e I2O (Intelligent I/O) subclasses */
+#define	PCI_SUBCLASS_I2O_STANDARD		0x00
+
+/* 0x0f satellite communication subclasses */
+/*	PCI_SUBCLASS_SATCOM_???			0x00    / * XXX ??? */
+#define	PCI_SUBCLASS_SATCOM_TV			0x01
+#define	PCI_SUBCLASS_SATCOM_AUDIO		0x02
+#define	PCI_SUBCLASS_SATCOM_VOICE		0x03
+#define	PCI_SUBCLASS_SATCOM_DATA		0x04
+
+/* 0x10 encryption/decryption subclasses */
+#define	PCI_SUBCLASS_CRYPTO_NETCOMP		0x00
+#define	PCI_SUBCLASS_CRYPTO_ENTERTAINMENT	0x10
+#define	PCI_SUBCLASS_CRYPTO_MISC		0x80
+
+/* 0x11 data acquisition and signal processing subclasses */
+#define	PCI_SUBCLASS_DASP_DPIO			0x00
+#define	PCI_SUBCLASS_DASP_TIMEFREQ		0x01
+#define	PCI_SUBCLASS_DASP_MISC			0x80
+
+/*
+ * PCI BIST/Header Type/Latency Timer/Cache Line Size Register.
+ */
+#define	PCI_BHLC_REG			0x0c
+
+#define	PCI_BIST_SHIFT				24
+#define	PCI_BIST_MASK				0xff
+#define	PCI_BIST(bhlcr) \
+	    (((bhlcr) >> PCI_BIST_SHIFT) & PCI_BIST_MASK)
+
+#define	PCI_HDRTYPE_SHIFT			16
+#define	PCI_HDRTYPE_MASK			0xff
+#define	PCI_HDRTYPE(bhlcr) \
+	    (((bhlcr) >> PCI_HDRTYPE_SHIFT) & PCI_HDRTYPE_MASK)
+
+#define PCI_HDRTYPE_TYPE(bhlcr) \
+	    (PCI_HDRTYPE(bhlcr) & 0x7f)
+#define	PCI_HDRTYPE_MULTIFN(bhlcr) \
+	    ((PCI_HDRTYPE(bhlcr) & 0x80) != 0)
+
+#define	PCI_LATTIMER_SHIFT			8
+#define	PCI_LATTIMER_MASK			0xff
+#define	PCI_LATTIMER(bhlcr) \
+	    (((bhlcr) >> PCI_LATTIMER_SHIFT) & PCI_LATTIMER_MASK)
+
+#define	PCI_CACHELINE_SHIFT			0
+#define	PCI_CACHELINE_MASK			0xff
+#define	PCI_CACHELINE(bhlcr) \
+	    (((bhlcr) >> PCI_CACHELINE_SHIFT) & PCI_CACHELINE_MASK)
+
+/* config registers for header type 0 devices */
+
+#define PCI_MAPS	0x10
+#define PCI_CARDBUSCIS	0x28
+#define PCI_SUBVEND_0	0x2c
+#define PCI_SUBDEV_0	0x2e
+#define PCI_INTLINE	0x3c
+#define PCI_INTPIN	0x3d
+#define PCI_MINGNT	0x3e
+#define PCI_MAXLAT	0x3f
+
+/* config registers for header type 1 devices */
+
+#define PCI_SECSTAT_1	0 /**/
+
+#define PCI_PRIBUS_1	0x18
+#define PCI_SECBUS_1	0x19
+#define PCI_SUBBUS_1	0x1a
+#define PCI_SECLAT_1	0x1b
+
+#define PCI_IOBASEL_1	0x1c
+#define PCI_IOLIMITL_1	0x1d
+#define PCI_IOBASEH_1	0x30 /**/
+#define PCI_IOLIMITH_1	0x32 /**/ 
+
+#define PCI_MEMBASE_1	0x20
+#define PCI_MEMLIMIT_1	0x22
+
+#define PCI_PMBASEL_1	0x24
+#define PCI_PMLIMITL_1	0x26
+#define PCI_PMBASEH_1	0 /**/
+#define PCI_PMLIMITH_1	0 /**/
+
+#define PCI_BRIDGECTL_1 0 /**/
+
+#define PCI_SUBVEND_1	0x34
+#define PCI_SUBDEV_1	0x36
+
+/* config registers for header type 2 devices */
+
+#define PCI_SECSTAT_2	0x16
+
+#define PCI_PRIBUS_2	0x18
+#define PCI_SECBUS_2	0x19
+#define PCI_SUBBUS_2	0x1a
+#define PCI_SECLAT_2	0x1b
+
+#define PCI_MEMBASE0_2	0x1c
+#define PCI_MEMLIMIT0_2 0x20
+#define PCI_MEMBASE1_2	0x24
+#define PCI_MEMLIMIT1_2 0x28
+#define PCI_IOBASE0_2	0x2c
+#define PCI_IOLIMIT0_2	0x30
+#define PCI_IOBASE1_2	0x34
+#define PCI_IOLIMIT1_2	0x38
+
+#define PCI_BRIDGECTL_2 0x3e
+
+#define PCI_SUBVEND_2	0x40
+#define PCI_SUBDEV_2	0x42
+
+#define PCI_PCCARDIF_2	0x44
+
+/*
+ * Mapping registers
+ */
+#define	PCI_MAPREG_START		0x10
+#define	PCI_MAPREG_END			0x28
+#define	PCI_MAPREG_ROM			0x30
+#define	PCI_MAPREG_PPB_END		0x18
+#define	PCI_MAPREG_PCB_END		0x14
+
+#define	PCI_MAPREG_TYPE(mr)						\
+	    ((mr) & PCI_MAPREG_TYPE_MASK)
+#define	PCI_MAPREG_TYPE_MASK			0x00000001
+
+#define	PCI_MAPREG_TYPE_MEM			0x00000000
+#define	PCI_MAPREG_TYPE_IO			0x00000001
+#define	PCI_MAPREG_TYPE_ROM			0x00000001
+
+#define	PCI_MAPREG_MEM_TYPE(mr)						\
+	    ((mr) & PCI_MAPREG_MEM_TYPE_MASK)
+#define	PCI_MAPREG_MEM_TYPE_MASK		0x00000006
+
+#define	PCI_MAPREG_MEM_TYPE_32BIT		0x00000000
+#define	PCI_MAPREG_MEM_TYPE_32BIT_1M		0x00000002
+#define	PCI_MAPREG_MEM_TYPE_64BIT		0x00000004
+
+#define	PCI_MAPREG_MEM_CACHEABLE(mr)					\
+	    (((mr) & PCI_MAPREG_MEM_CACHEABLE_MASK) != 0)
+#define	PCI_MAPREG_MEM_CACHEABLE_MASK		0x00000008
+
+#define	PCI_MAPREG_MEM_PREFETCHABLE(mr)					\
+	    (((mr) & PCI_MAPREG_MEM_PREFETCHABLE_MASK) != 0)
+#define	PCI_MAPREG_MEM_PREFETCHABLE_MASK	0x00000008
+
+#define	PCI_MAPREG_MEM_ADDR(mr)						\
+	    ((mr) & PCI_MAPREG_MEM_ADDR_MASK)
+#define	PCI_MAPREG_MEM_SIZE(mr)						\
+	    (PCI_MAPREG_MEM_ADDR(mr) & -PCI_MAPREG_MEM_ADDR(mr))
+#define	PCI_MAPREG_MEM_ADDR_MASK		0xfffffff0
+
+#define	PCI_MAPREG_MEM64_ADDR(mr)					\
+	    ((mr) & PCI_MAPREG_MEM64_ADDR_MASK)
+#define	PCI_MAPREG_MEM64_SIZE(mr)					\
+	    (PCI_MAPREG_MEM64_ADDR(mr) & -PCI_MAPREG_MEM64_ADDR(mr))
+#define	PCI_MAPREG_MEM64_ADDR_MASK		0xfffffffffffffff0
+
+#define	PCI_MAPREG_IO_ADDR(mr)						\
+	    ((mr) & PCI_MAPREG_IO_ADDR_MASK)
+#define	PCI_MAPREG_IO_SIZE(mr)						\
+	    (PCI_MAPREG_IO_ADDR(mr) & -PCI_MAPREG_IO_ADDR(mr))
+#define	PCI_MAPREG_IO_ADDR_MASK			0xfffffffe
+
+#define	PCI_MAPREG_ROM_ADDR(mr)						\
+	    ((mr) & PCI_MAPREG_ROM_ADDR_MASK)
+#define	PCI_MAPREG_ROM_SIZE(mr)						\
+	    (PCI_MAPREG_ROM_ADDR(mr) & -PCI_MAPREG_ROM_ADDR(mr))
+#define	PCI_MAPREG_ROM_ADDR_MASK		0xfffff800
+
+/*
+ * Cardbus CIS pointer (PCI rev. 2.1)
+ */
+#define PCI_CARDBUS_CIS_REG 0x28
+
+/*
+ * Subsystem identification register; contains a vendor ID and a device ID.
+ * Types/macros for PCI_ID_REG apply.
+ * (PCI rev. 2.1)
+ */
+#define PCI_SUBSYS_ID_REG 0x2c
+
+/*
+ * capabilities link list (PCI rev. 2.2)
+ */
+#define PCI_CAPLISTPTR_REG		0x34
+#define PCI_CAPLIST_PTR(cpr) ((cpr) & 0xff)
+#define PCI_CAPLIST_NEXT(cr) (((cr) >> 8) & 0xff)
+#define PCI_CAPLIST_CAP(cr) ((cr) & 0xff)
+
+#define PCI_CAP_REESSERVED	0x00
+#define PCI_CAP_PWRMGMT		0x01
+#define PCI_CAP_AGP		0x02
+#define PCI_CAP_VPD		0x03
+#define PCI_CAP_SLOTID		0x04
+#define PCI_CAP_MBI		0x05
+#define PCI_CAP_CPCI_HOTSWAP	0x06
+#define PCI_CAP_PCIX		0x07
+#define PCI_CAP_LDT		0x08
+#define PCI_CAP_VENDSPEC	0x09
+#define PCI_CAP_DEBUGPORT	0x0a
+#define PCI_CAP_CPCI_RSRCCTL	0x0b
+#define PCI_CAP_HOTPLUG		0x0c
+
+/*
+ * Power Management Control Status Register; access via capability pointer.
+ */
+#define PCI_PMCSR_STATE_MASK	0x03
+#define PCI_PMCSR_STATE_D0	0x00
+#define PCI_PMCSR_STATE_D1	0x01
+#define PCI_PMCSR_STATE_D2	0x02
+#define PCI_PMCSR_STATE_D3	0x03
+
+/*
+ * Interrupt Configuration Register; contains interrupt pin and line.
+ */
+#define	PCI_INTERRUPT_REG		0x3c
+
+typedef u_int8_t pci_intr_pin_t;
+typedef u_int8_t pci_intr_line_t;
+
+#define	PCI_INTERRUPT_PIN_SHIFT			8
+#define	PCI_INTERRUPT_PIN_MASK			0xff
+#define	PCI_INTERRUPT_PIN(icr) \
+	    (((icr) >> PCI_INTERRUPT_PIN_SHIFT) & PCI_INTERRUPT_PIN_MASK)
+
+#define	PCI_INTERRUPT_LINE_SHIFT		0
+#define	PCI_INTERRUPT_LINE_MASK			0xff
+#define	PCI_INTERRUPT_LINE(icr) \
+	    (((icr) >> PCI_INTERRUPT_LINE_SHIFT) & PCI_INTERRUPT_LINE_MASK)
+
+#define	PCI_MIN_GNT_SHIFT			16
+#define	PCI_MIN_GNT_MASK			0xff
+#define	PCI_MIN_GNT(icr) \
+	    (((icr) >> PCI_MIN_GNT_SHIFT) & PCI_MIN_GNT_MASK)
+
+#define	PCI_MAX_LAT_SHIFT			24
+#define	PCI_MAX_LAT_MASK			0xff
+#define	PCI_MAX_LAT(icr) \
+	    (((icr) >> PCI_MAX_LAT_SHIFT) & PCI_MAX_LAT_MASK)
+
+#define	PCI_INTERRUPT_PIN_NONE			0x00
+#define	PCI_INTERRUPT_PIN_A			0x01
+#define	PCI_INTERRUPT_PIN_B			0x02
+#define	PCI_INTERRUPT_PIN_C			0x03
+#define	PCI_INTERRUPT_PIN_D			0x04
+#define	PCI_INTERRUPT_PIN_MAX			0x04
+
+#endif /* _DEV_PCI_PCIREG_H_ */
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/common/plat.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/plat.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/common/plat.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/common/plat.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,82 @@
+
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 yanhua (yanhua@lemote.com)
+ * Copyright (C) 2007 Ralf Baechle (ralf@linux-mips.org)
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/serial_8250.h>
+
+#ifdef CONFIG_64BIT
+#define CPU_UART_BASE  (void *)0xffffffffbff003f8
+#else 
+#define CPU_UART_BASE  (void *)0xbff003f8
+#endif
+
+#define PORT(base, int)							\
+{									\
+	.iobase		= base,						\
+	.irq		= int,						\
+	.uartclk	= 1843200,					\
+	.iotype		= UPIO_PORT,					\
+	.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,		\
+	.regshift	= 0,						\
+}
+
+static struct plat_serial8250_port uart8250_data[] = {
+#if defined(CONFIG_LEMOTE_YEELOONG2F) || defined(CONFIG_LEMOTE_NAS)		
+	{ .membase = CPU_UART_BASE,
+	  .irq = 19,
+	  .uartclk = 3686400,
+	  .iotype = UPIO_MEM,
+	  .flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+	  .regshift = 0,
+	},
+#else
+	PORT(0x2F8, 3),
+#endif
+	{ },
+};
+
+static struct platform_device uart8250_device = {
+	.name			= "serial8250",
+	.id			= PLAT8250_DEV_PLATFORM,
+	.dev			= {
+		.platform_data	= uart8250_data,
+	},
+};
+
+static struct resource cmos_rsrc[] = {
+        {
+                .start = 0x70,
+                .end   = 0x71,
+                .flags = IORESOURCE_IO
+        },
+        {
+                .start = 8,
+                .end   = 8,
+                .flags = IORESOURCE_IRQ
+        }
+};
+
+static struct platform_device cmos_device = {
+	.name			= "rtc_cmos",
+	.num_resources 	= ARRAY_SIZE(cmos_rsrc),
+	.resource		= cmos_rsrc
+};
+
+static int __init plat_init(void)
+{
+	platform_device_register(&uart8250_device);
+	platform_device_register(&cmos_device);
+
+	return 0;
+}
+
+device_initcall(plat_init);
+
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/bonito-irq.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/bonito-irq.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/bonito-irq.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/bonito-irq.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ * Copyright (C) 2000, 2001 Ralf Baechle (ralf@gnu.org)
+ *
+ * Copyright (C) 2007 Lemote Inc. & Insititute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/io.h>
+
+#include <asm/mips-boards/bonito64.h>
+
+#define	bonito_irq_shutdown	bonito_irq_disable
+
+
+static inline void bonito_irq_enable(unsigned int irq)
+{
+	BONITO_INTENSET = (1 << (irq - BONITO_IRQ_BASE));
+	(void)BONITO_INTENSET;
+	mmiowb();
+}
+
+static unsigned int bonito_irq_startup(unsigned int irq) 
+{
+	bonito_irq_enable(irq);
+	return 0;
+}
+
+static inline void bonito_irq_ack(unsigned int irq) 
+{
+	BONITO_INTENCLR = (1 << (irq - BONITO_IRQ_BASE));
+	(void)BONITO_INTENCLR;
+	mmiowb();
+}
+
+static inline void bonito_irq_end(unsigned int irq) 
+{
+	BONITO_INTENSET = (1 << (irq - BONITO_IRQ_BASE ));
+	mmiowb();
+}
+
+static inline void bonito_irq_disable(unsigned int irq)
+{
+	BONITO_INTENCLR = (1 << (irq - BONITO_IRQ_BASE));
+	(void)BONITO_INTENCLR; 
+	mmiowb();
+}
+
+static struct irq_chip bonito_irq_type = {
+	.name	= "bonito_irq",
+	.startup = bonito_irq_startup,
+	.shutdown = bonito_irq_shutdown,
+	.enable = bonito_irq_enable,
+	.disable = bonito_irq_disable,
+	.ack	= bonito_irq_ack,
+	.end    = bonito_irq_end,
+	.mask	= bonito_irq_disable,
+	.mask_ack = bonito_irq_disable,
+	.unmask	= bonito_irq_enable,
+};
+
+/* There is no need to handle the DMA IO problem on godson2f any more. */
+/*
+static struct irqaction dma_timeout_irqaction = {
+	.handler	= no_action,
+	.name		= "dma_timeout",
+};
+*/
+
+void bonito_irq_init(void)
+{
+	u32 i;
+
+	for (i = BONITO_IRQ_BASE; i < BONITO_IRQ_BASE + 32; i++) {
+		set_irq_chip_and_handler(i, &bonito_irq_type, handle_level_irq);
+	}
+
+	/* setup_irq(BONITO_IRQ_BASE + 10, &dma_timeout_irqaction); */
+}
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/dbg_io.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/dbg_io.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/dbg_io.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/dbg_io.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,182 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ * Copyright (C) 2000, 2001 Ralf Baechle (ralf@gnu.org)
+ *
+ * Copyright (C) 2007 Lemote Inc. & Insititute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/io.h>
+#include <asm/types.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <asm/serial.h>		/* For the serial port location and base baud */
+
+#define         UART16550_BAUD_2400             2400
+#define         UART16550_BAUD_4800             4800
+#define         UART16550_BAUD_9600             9600
+#define         UART16550_BAUD_19200            19200
+#define         UART16550_BAUD_38400            38400
+#define         UART16550_BAUD_57600            57600
+#define         UART16550_BAUD_115200           115200
+
+#define         UART16550_PARITY_NONE           0
+#define         UART16550_PARITY_ODD            0x08
+#define         UART16550_PARITY_EVEN           0x18
+#define         UART16550_PARITY_MARK           0x28
+#define         UART16550_PARITY_SPACE          0x38
+
+#define         UART16550_DATA_5BIT             0x0
+#define         UART16550_DATA_6BIT             0x1
+#define         UART16550_DATA_7BIT             0x2
+#define         UART16550_DATA_8BIT             0x3
+
+#define         UART16550_STOP_1BIT             0x0
+#define         UART16550_STOP_2BIT             0x4
+
+/* ----------------------------------------------------- */
+
+#ifdef	USE_GODSON2F_UART
+
+/* === CONFIG === */
+#ifdef CONFIG_64BIT
+#define         BASE                    (0xffffffffbff003f8)
+#else
+#define         BASE                    (0xbff003f8)
+#endif
+
+#else	/* USE_CS5536_UART1/2 */
+
+#ifdef CONFIG_64BIT
+#define         BASE                    0xffffffffbfd002f8
+#else
+#define         BASE                    0xbfd002f8
+#endif
+
+#endif	/* end of USE_GODSON2F_UART */
+
+#define         MAX_BAUD                BASE_BAUD
+/* === END OF CONFIG === */
+
+#define         REG_OFFSET              1
+
+/* register offset */
+#define         OFS_RCV_BUFFER          0
+#define         OFS_TRANS_HOLD          0
+#define         OFS_SEND_BUFFER         0
+#define         OFS_INTR_ENABLE         (1*REG_OFFSET)
+#define         OFS_INTR_ID             (2*REG_OFFSET)
+#define         OFS_DATA_FORMAT         (3*REG_OFFSET)
+#define         OFS_LINE_CONTROL        (3*REG_OFFSET)
+#define         OFS_MODEM_CONTROL       (4*REG_OFFSET)
+#define         OFS_RS232_OUTPUT        (4*REG_OFFSET)
+#define         OFS_LINE_STATUS         (5*REG_OFFSET)
+#define         OFS_MODEM_STATUS        (6*REG_OFFSET)
+#define         OFS_RS232_INPUT         (6*REG_OFFSET)
+#define         OFS_SCRATCH_PAD         (7*REG_OFFSET)
+
+#define         OFS_DIVISOR_LSB         (0*REG_OFFSET)
+#define         OFS_DIVISOR_MSB         (1*REG_OFFSET)
+
+/* memory-mapped read/write of the port */
+#define         UART16550_READ(y)    (*((volatile u8*)(BASE + y)))
+#define         UART16550_WRITE(y, z)  ((*((volatile u8*)(BASE + y))) = z)
+
+void debugInit(u32 baud, u8 data, u8 parity, u8 stop)
+{
+	/* disable interrupts */
+	UART16550_WRITE(OFS_INTR_ENABLE, 0);
+
+	/* set up buad rate */
+	{
+		u32 divisor;
+
+		/* set DIAB bit */
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x80);
+
+		/* set divisor */
+		divisor = MAX_BAUD / baud;
+		UART16550_WRITE(OFS_DIVISOR_LSB, divisor & 0xff);
+		UART16550_WRITE(OFS_DIVISOR_MSB, (divisor & 0xff00) >> 8);
+
+		/* clear DIAB bit */
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x0);
+	}
+
+	/* set data format */
+	UART16550_WRITE(OFS_DATA_FORMAT, data | parity | stop);
+}
+
+static int remoteDebugInitialized = 0;
+
+u8 getDebugChar(void)
+{
+	if (!remoteDebugInitialized) {
+		remoteDebugInitialized = 1;
+		debugInit(UART16550_BAUD_115200,
+			  UART16550_DATA_8BIT,
+			  UART16550_PARITY_NONE, UART16550_STOP_1BIT);
+	}
+
+	while ((UART16550_READ(OFS_LINE_STATUS) & 0x1) == 0) ;
+	return UART16550_READ(OFS_RCV_BUFFER);
+}
+
+int putDebugChar(u8 byte)
+{
+	if (!remoteDebugInitialized) {
+		remoteDebugInitialized = 1;
+		/*
+		   debugInit(UART16550_BAUD_115200,
+		   UART16550_DATA_8BIT,
+		   UART16550_PARITY_NONE, UART16550_STOP_1BIT); */
+	}
+
+	while ((UART16550_READ(OFS_LINE_STATUS) & 0x20) == 0) ;
+	UART16550_WRITE(OFS_SEND_BUFFER, byte);
+	return 1;
+}
+
+extern void prom_putchar(char c);
+
+void prom_printf(char *fmt, ...)
+{
+	va_list args;
+	char ppbuf[1024];
+	char *bptr;
+
+	va_start(args, fmt);
+	vsprintf(ppbuf, fmt, args);
+
+	bptr = ppbuf;
+
+	while (*bptr != 0) {
+		if (*bptr == '\n')
+			prom_putchar('\r');
+
+		prom_putchar(*bptr++);
+	}
+	va_end(args);
+}
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/irq.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/irq.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/irq.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/irq.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2007 Lemote Inc. & Insititute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/irq_cpu.h>
+#include <asm/i8259.h>
+#include <asm/mipsregs.h>
+#include <asm/delay.h>
+#include <asm/mips-boards/bonito64.h>
+
+#define	BONITO_INT_BIT_GPIO0		(1 << 0)
+#define	BONITO_INT_BIT_GPIO1		(1 << 1)
+#define	BONITO_INT_BIT_GPIO2		(1 << 2)
+#define	BONITO_INT_BIT_GPIO3		(1 << 3)
+#define	BONITO_INT_BIT_PCI_INTA		(1 << 4)
+#define	BONITO_INT_BIT_PCI_INTB		(1 << 5)
+#define	BONITO_INT_BIT_PCI_INTC		(1 << 6)
+#define	BONITO_INT_BIT_PCI_INTD		(1 << 7)
+#define	BONITO_INT_BIT_PCI_PERR		(1 << 8)
+#define	BONITO_INT_BIT_PCI_SERR		(1 << 9)
+#define	BONITO_INT_BIT_DDR		(1 << 10)
+#define	BONITO_INT_BIT_INT0		(1 << 11)
+#define	BONITO_INT_BIT_INT1		(1 << 12)
+#define	BONITO_INT_BIT_INT2		(1 << 13)
+#define	BONITO_INT_BIT_INT3		(1 << 14)
+
+#define	BONITO_INT_TIMER_OFF		7
+#define	BONITO_INT_BONITO_OFF		6
+#define	BONITO_INT_UART_OFF			3
+#define	BONITO_INT_I8259_OFF		2
+
+/****************************************************************/
+
+static void loongson2f_timer_dispatch(void)
+{
+	/* place the loongson2f timer interrupt on 23 */
+	do_IRQ(MIPS_CPU_IRQ_BASE + BONITO_INT_TIMER_OFF);
+	return;
+}
+
+static void loongson2f_bonito_dispatch(void)
+{
+	int int_status;
+	int i = 0;
+
+	/* place the other interrupt on bit6 for bonito, inclding PCI and so on */
+	int_status = BONITO_INTISR & BONITO_INTEN;
+	
+	for(i = 0; (i < 10) && int_status; i++){
+		if(int_status & (1 << i)){
+			if(i == 10)
+				printk("ddr int.\n");
+			if(int_status & 0x000000f0)
+				do_IRQ(BONITO_IRQ_BASE + i);
+			int_status &= ~(1 << i);
+		}
+	}
+	
+	return;
+}
+
+static void loongson2f_int3_dispatch(void)
+{
+	int int_status;
+	
+	int_status = BONITO_INTISR & BONITO_INTEN;
+	if(int_status & BONITO_INT_BIT_INT3){
+	}
+	
+	return;
+}
+
+static void loongson2f_int2_dispatch(void)
+{
+	int int_status;
+	
+	int_status = BONITO_INTISR & BONITO_INTEN;
+	if(int_status & BONITO_INT_BIT_INT2){
+	}
+	
+	return;
+}
+
+static void loongson2f_int1_dispatch(void)
+{
+	/* place the loongson2f uart interrupt on int1 */
+	do_IRQ(MIPS_CPU_IRQ_BASE + BONITO_INT_UART_OFF);
+}
+
+static void i8259_irqdispatch(void)
+{
+	int irq, isr, imr;
+
+	if((BONITO_INTISR & BONITO_INTEN) & BONITO_INT_BIT_INT0) {
+
+		imr = inb(0x21) | (inb(0xa1) << 8);
+		isr = inb(0x20) | (inb(0xa0) << 8);
+		isr &= ~0x4; // irq2 for cascade
+		isr &= ~imr;
+		irq = ffs(isr) - 1;
+
+		if(irq >= 0) {
+			do_IRQ(irq);
+		} else {
+			spurious_interrupt();
+		}
+	}
+}
+
+static void loongson2f_steer1_dispatch(void)
+{
+	return;
+}
+
+static void loongson2f_steer0_dispatch(void)
+{
+	return;
+}
+
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	unsigned int pending = read_c0_cause() & read_c0_status() & ST0_IM;
+
+	if(pending & CAUSEF_IP7){
+		loongson2f_timer_dispatch();
+	}else if(pending & CAUSEF_IP6){ /* North Bridge, Performance counter */
+		do_IRQ(MIPS_CPU_IRQ_BASE + 6);
+		loongson2f_bonito_dispatch();
+	}else if(pending & CAUSEF_IP5){
+		loongson2f_int3_dispatch();
+	}else if(pending & CAUSEF_IP4){
+		loongson2f_int2_dispatch();
+	}else if(pending & CAUSEF_IP3){ /* CPU UART */
+		loongson2f_int1_dispatch();
+	}else if(pending & CAUSEF_IP2){ /* South Bridge */
+		i8259_irqdispatch();
+	}else if(pending & CAUSEF_IP1){
+		loongson2f_steer1_dispatch();
+	}else if(pending & CAUSEF_IP0){
+		loongson2f_steer0_dispatch();
+	}else{
+		spurious_interrupt();
+	}
+	return;
+}
+
+static struct irqaction cascade_irqaction = {
+	.handler = no_action,
+	.mask = CPU_MASK_NONE,
+	.name = "cascade",
+};
+
+irqreturn_t ip6_action(int cpl, void *dev_id, struct pt_regs *regs)
+{
+	return IRQ_HANDLED;
+}
+
+static struct irqaction ip6_irqaction = {
+	.handler = ip6_action,
+	.mask = CPU_MASK_NONE,
+	.name = "cascade",
+	.flags = IRQF_SHARED,
+};
+
+void __init arch_init_irq(void)
+{
+	extern void bonito_irq_init(void);
+
+	/*
+	 * Clear all of the interrupts while we change the able around a bit.
+	 * int-handler is not on bootstrap
+	 */
+	clear_c0_status(ST0_IM | ST0_BEV);
+	local_irq_disable();
+	
+	/* setup cs5536 as high level */
+	BONITO_INTPOL  = (1 << 11 | 1 << 12);
+	BONITO_INTEDGE &= ~(1 << 11 | 1 << 12);
+
+	/* no steer */
+	BONITO_INTSTEER = 0;
+
+	/*
+	 * Mask out all interrupt by writing "1" to all bit position in
+	 * the interrupt reset reg.
+	 */
+	BONITO_INTENCLR = ~0;
+
+	/* init all controller
+	 *   0-15         ------> i8259 interrupt
+	 *   16-23        ------> mips cpu interrupt
+	 *   32-63        ------> bonito irq
+	 */
+	
+	/* Sets the first-level interrupt dispatcher. */
+	mips_cpu_irq_init();
+
+	init_i8259_irqs();
+	bonito_irq_init();
+	
+	/* setup bonito interrupt */
+	setup_irq(MIPS_CPU_IRQ_BASE + BONITO_INT_BONITO_OFF, &ip6_irqaction);
+	/* 8259 irq at IP2 */
+	setup_irq(MIPS_CPU_IRQ_BASE + BONITO_INT_I8259_OFF, &cascade_irqaction);
+
+}
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/Makefile linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/Makefile
--- linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/Makefile	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,7 @@
+#
+# Makefile for Lemote Loongson-2F based mini box.
+#
+
+obj-y	+= setup.o prom.o reset.o irq.o bonito-irq.o dbg_io.o 
+
+EXTRA_AFLAGS := $(CFLAGS)
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/prom.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/prom.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/prom.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/prom.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,106 @@
+/*
+ * Based on Ocelot Linux port, which is
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: jsun@mvista.com or jsun@junsun.net
+ *
+ * Copyright 2003 ICT CAS
+ * Author: Michael Guo <guoyi@ict.ac.cn>
+ *
+ * Copyright (C) 2007 Lemote Inc. & Insititute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+
+extern unsigned long bus_clock;
+extern unsigned long cpu_clock_freq;
+extern unsigned int memsize, highmemsize;
+extern int putDebugChar(unsigned char byte);
+
+static int argc;
+/* pmon passes arguments in 32bit pointers */
+static int *arg;
+static int *env;
+
+const char *get_system_type(void)
+{
+	return "lemote-fuloong(2F)";
+}
+
+void __init prom_init_cmdline(void)
+{
+	int i;
+	long l;
+
+	/* arg[0] is "g", the rest is boot parameters */
+	arcs_cmdline[0] = '\0';
+	for (i = 1; i < argc; i++) {
+		l = (long)arg[i];
+		if (strlen(arcs_cmdline) + strlen(((char *)l) + 1)
+		    >= sizeof(arcs_cmdline))
+			break;
+		strcat(arcs_cmdline, ((char *)l));
+		strcat(arcs_cmdline, " ");
+	}
+}
+
+void __init prom_init(void)
+{
+	long l;
+	argc = fw_arg0;
+	arg = (int *)fw_arg1;
+	env = (int *)fw_arg2;
+
+	prom_init_cmdline();
+
+	if ((strstr(arcs_cmdline, "console=")) == NULL)
+		strcat(arcs_cmdline, " console=ttyS0,115200");
+	if ((strstr(arcs_cmdline, "root=")) == NULL)
+		strcat(arcs_cmdline, " root=/dev/hda1");
+
+	l = (long)*env;
+	while (l != 0) {
+		if (strncmp("busclock", (char *)l, strlen("busclock")) == 0) {
+			bus_clock = simple_strtol((char *)l + strlen("busclock="),
+					NULL, 10);
+		}
+		if (strncmp("cpuclock", (char *)l, strlen("cpuclock")) == 0) {
+			cpu_clock_freq = simple_strtol((char *)l + strlen("cpuclock="),
+					NULL, 10);
+		}
+		if (strncmp("memsize", (char *)l, strlen("memsize")) == 0) {
+			memsize = simple_strtol((char *)l + strlen("memsize="),
+						NULL, 10);
+		}
+		if (strncmp("highmemsize", (char *)l, strlen("highmemsize")) == 0) {
+			highmemsize = simple_strtol((char *)l + strlen("highmemsize="),
+					  NULL, 10);
+		}
+		env++;
+		l = (long)*env;
+	}
+	if (memsize == 0)
+		memsize = 256;
+
+	printk("busclock=%ld, cpuclock=%ld,memsize=%d,highmemsize=%d\n",
+	       bus_clock, cpu_clock_freq, memsize, highmemsize);
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
+
+void prom_putchar(char c)
+{
+	putDebugChar(c);
+}
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/reset.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/reset.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/reset.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/reset.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,87 @@
+/*
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Copyright (C) 2007 Lemote, Inc. & Institute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ */
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/reboot.h>
+#include <asm/system.h>
+
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+
+extern void _wrmsr(u32 reg, u32 hi, u32 lo);
+extern void _rdmsr(u32 reg, u32 *hi, u32 *lo);
+
+static void loongson2f_restart(char *command)
+{
+	u32 hi, lo;
+
+#ifdef CONFIG_32BIT
+	*(volatile u32*)0xbfe00180 |= 0x7;
+#else
+	*(volatile u32*)0xffffffffbfe00180 |= 0x7;
+#endif
+	_rdmsr(0xe0000014, &hi, &lo);
+	lo |= 0x00000001;
+	_wrmsr(0xe0000014, hi, lo);
+
+	printk("Hard reset not take effect!!\n");
+	__asm__ __volatile__ (
+					".long 0x3c02bfc0\n"
+					".long 0x00400008\n"
+					:::"v0"
+					);
+}
+
+
+static void delay(void)
+{
+	volatile int i;
+	for (i=0; i<0x10000; i++);
+}
+static void loongson2f_halt(void)
+{
+#ifdef CONFIG_32BIT
+	u32 base;
+#else
+	u64 base;
+#endif
+	u32 hi, lo, val;
+	
+	_rdmsr(0x8000000c, &hi, &lo);
+#ifdef CONFIG_32BIT
+	base = (lo & 0xff00) | 0xbfd00000;
+#else
+	base = (lo & 0xff00) | 0xffffffffbfd00000ULL;
+#endif
+	val = (val & ~(1 << (16 + 13))) | (1 << 13);
+	delay();
+	*(__volatile__ u32 *)(base + 0x04) = val;
+	delay();
+	val = (val & ~(1 << (13))) | (1 << (16 + 13));
+	delay();
+	*(__volatile__ u32 *)(base + 0x00) = val;
+	delay();
+}
+
+static void loongson2f_power_off(void)
+{
+	loongson2f_halt();
+}
+
+void mips_reboot_setup(void)
+{
+	_machine_restart = loongson2f_restart;
+	_machine_halt = loongson2f_halt;
+	pm_power_off = loongson2f_power_off;
+}
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/setup.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/setup.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/fuloong/setup.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/fuloong/setup.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,132 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ * setup.c - board dependent boot routines
+ *
+ * Copyright (C) 2007 Lemote Inc. & Insititute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/bootmem.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/bootinfo.h>
+#include <asm/mc146818-time.h>
+#include <asm/time.h>
+#include <asm/wbflush.h>
+
+#ifdef CONFIG_VT
+#include <linux/console.h>
+#include <linux/screen_info.h>
+#endif
+
+extern void mips_reboot_setup(void);
+
+#ifdef CONFIG_64BIT
+#define PTR_PAD(p) ((0xffffffff00000000)|((unsigned long long)(p)))
+#else
+#define PTR_PAD(p) (p)
+#endif
+
+unsigned long cpu_clock_freq;
+unsigned long bus_clock;
+unsigned int memsize;
+unsigned int highmemsize = 0;
+
+extern int __init init_mfgpt_clocksource(void);
+
+void __init plat_time_init(void)
+{
+	/* setup mips r4k timer */
+	mips_hpt_frequency = cpu_clock_freq / 2;
+
+#ifdef CONFIG_CS5536_MFGPT
+	init_mfgpt_clocksource();
+#endif
+}
+
+unsigned long read_persistent_clock(void)
+{
+	return mc146818_get_cmos_time();
+}
+
+void (*__wbflush)(void);
+EXPORT_SYMBOL(__wbflush);
+
+static void wbflush_loongson2f(void)
+{
+	asm(".set\tpush\n\t"
+	    ".set\tnoreorder\n\t"
+	    ".set mips3\n\t"
+	    "sync\n\t"
+	    "nop\n\t"
+	    ".set\tpop\n\t"
+	    ".set mips0\n\t");
+}
+
+void __init plat_mem_setup(void)
+{
+	set_io_port_base(PTR_PAD(0xbfd00000));
+
+	mips_reboot_setup();
+
+	__wbflush = wbflush_loongson2f;
+
+	add_memory_region(0x0, (memsize << 20), BOOT_MEM_RAM);
+#ifdef CONFIG_64BIT
+	__asm__(
+		".set mips3\n"			
+		"dli $2, 0x900000003ff00000\n"
+		"dli $3, 0x0000000080000000\n"
+		"sd  $3, 0x10($2)\n"
+		"sd  $0, 0x50($2)\n"
+		"dli $3, 0xffffffff80000000\n"
+		"sd  $3, 0x30($2)\n"
+		".set mips0\n"
+		:::"$2","$3","memory");
+	if (highmemsize > 0) {
+		add_memory_region(0x90000000, highmemsize << 20, BOOT_MEM_RAM);
+	}
+#endif
+
+#ifdef CONFIG_VT
+#if defined(CONFIG_VGA_CONSOLE)
+	conswitchp = &vga_con;
+
+	screen_info = (struct screen_info) {
+		0, 25,		/* orig-x, orig-y */
+		    0,		/* unused */
+		    0,		/* orig-video-page */
+		    0,		/* orig-video-mode */
+		    80,		/* orig-video-cols */
+		    0, 0, 0,	/* ega_ax, ega_bx, ega_cx */
+		    25,		/* orig-video-lines */
+		    VIDEO_TYPE_VGAC,	/* orig-video-isVGA */
+		    16		/* orig-video-points */
+	};
+#elif defined(CONFIG_DUMMY_CONSOLE)
+	conswitchp = &dummy_con;
+#endif
+#endif
+
+}
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/Kconfig linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/Kconfig
--- linux-2.6.29.1/arch/mips/lemote/lm2f/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/Kconfig	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,87 @@
+choice
+	prompt "Machine type"
+	depends on MACH_LM2F
+	default LEMOTE_FULOONG2F
+
+config LEMOTE_FULOONG2F
+	bool "Lemote Fuloong mini-PC"
+	select ARCH_SPARSEMEM_ENABLE
+	select CEVT_R4K if ! CS5536_MFGPT
+	select CSRC_R4K if ! CS5536_MFGPT
+	select SYS_HAS_CPU_LOONGSON2
+	select DMA_NONCOHERENT
+	select BOOT_ELF32
+	select BOARD_SCACHE
+	select HW_HAS_PCI
+	select I8259
+	select ISA
+	select IRQ_CPU
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_HAS_EARLY_PRINTK
+	select GENERIC_HARDIRQS_NO__DO_IRQ
+	select GENERIC_ISA_DMA_SUPPORT_BROKEN
+	select CPU_HAS_WB
+	select CS5536
+	help
+	  Lemote Fulong mini-PC board based on the Chinese Loongson-2F CPU
+
+config LEMOTE_YEELOONG2F
+	bool "Lemote Yeloong2F mini Notebook"
+	select ARCH_SPARSEMEM_ENABLE
+	select CEVT_R4K if ! CS5536_MFGPT 
+	select CSRC_R4K if ! CS5536_MFGPT
+	select SYS_HAS_CPU_LOONGSON2
+	select DMA_NONCOHERENT
+	select BOOT_ELF32
+	select BOARD_SCACHE
+	select HW_HAS_PCI
+	select I8259
+	select ISA
+	select IRQ_CPU
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_HAS_EARLY_PRINTK
+	select GENERIC_HARDIRQS_NO__DO_IRQ
+	select GENERIC_ISA_DMA_SUPPORT_BROKEN
+	select CPU_HAS_WB
+	select CS5536
+	help
+	  Lemote Notebook based on the Chinese Loongson-2F CPU
+
+endchoice
+
+config CS5536_RTC_BUG
+	bool
+
+config CS5536
+	bool
+	select CS5536_RTC_BUG
+
+config CS5536_MFGPT
+	bool "Using cs5536's MFGPT as system clock"
+	depends on CS5536
+	help
+		This is needed if cpufreq and oprofile should be enabled in
+		Loongson2(F) machines
+
+config LEMOTE_NAS
+	bool "Lemote NAS machine"
+	depends on LEMOTE_FULOONG2F
+	help 
+	  Lemote's Loongson-2F based network attached system
+
+config UCA_SIZE
+	hex "Uncache Accelerated Region size"
+	depends on MACH_LM2F
+	default 0x400000  if LEMOTE_YELOONG2F
+	default 0x2000000 if LEMOTE_FULOONG2F
+	help
+	  Uncached Acceleration(UCA) can greatly improve video performance.
+	  Normally the Video memory can be accessed in Uncached Accelerated mode,
+	  other peripheral spaces not.
+	  Specify a zeroed size to disable this feature. 
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/bonito-irq.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/bonito-irq.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/bonito-irq.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/bonito-irq.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ * Copyright (C) 2000, 2001 Ralf Baechle (ralf@gnu.org)
+ *
+ * Copyright (C) 2007 Lemote Inc. & Insititute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/io.h>
+
+#include <asm/mips-boards/bonito64.h>
+
+#define	bonito_irq_shutdown	bonito_irq_disable
+
+
+static inline void bonito_irq_enable(unsigned int irq)
+{
+	BONITO_INTENSET = (1 << (irq - BONITO_IRQ_BASE));
+	(void)BONITO_INTENSET;
+	mmiowb();
+}
+
+static unsigned int bonito_irq_startup(unsigned int irq) 
+{
+	bonito_irq_enable(irq);
+	return 0;
+}
+
+static inline void bonito_irq_ack(unsigned int irq) 
+{
+	BONITO_INTENCLR = (1 << (irq - BONITO_IRQ_BASE));
+	(void)BONITO_INTENCLR;
+	mmiowb();
+}
+
+static inline void bonito_irq_end(unsigned int irq) 
+{
+	BONITO_INTENSET = (1 << (irq - BONITO_IRQ_BASE ));
+	mmiowb();
+}
+
+static inline void bonito_irq_disable(unsigned int irq)
+{
+	BONITO_INTENCLR = (1 << (irq - BONITO_IRQ_BASE));
+	(void)BONITO_INTENCLR; 
+	mmiowb();
+}
+
+static struct irq_chip bonito_irq_type = {
+	.name	= "bonito_irq",
+	.startup = bonito_irq_startup,
+	.shutdown = bonito_irq_shutdown,
+	.enable = bonito_irq_enable,
+	.disable = bonito_irq_disable,
+	.ack	= bonito_irq_ack,
+	.end    = bonito_irq_end,
+	.mask	= bonito_irq_disable,
+	.mask_ack = bonito_irq_disable,
+	.unmask	= bonito_irq_enable,
+};
+
+/* There is no need to handle the DMA IO problem on godson2f any more. */
+/*
+static struct irqaction dma_timeout_irqaction = {
+	.handler	= no_action,
+	.name		= "dma_timeout",
+};
+*/
+
+void bonito_irq_init(void)
+{
+	u32 i;
+
+	for (i = BONITO_IRQ_BASE; i < BONITO_IRQ_BASE + 32; i++) {
+		set_irq_chip_and_handler(i, &bonito_irq_type, handle_level_irq);
+	}
+
+}
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/dbg_io.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/dbg_io.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/dbg_io.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/dbg_io.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ * Copyright (C) 2000, 2001 Ralf Baechle (ralf@gnu.org)
+ *
+ * Copyright (C) 2007 Lemote Inc. & Insititute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/io.h>
+#include <asm/types.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <asm/serial.h>		/* For the serial port location and base baud */
+
+#define         UART16550_BAUD_2400             2400
+#define         UART16550_BAUD_4800             4800
+#define         UART16550_BAUD_9600             9600
+#define         UART16550_BAUD_19200            19200
+#define         UART16550_BAUD_38400            38400
+#define         UART16550_BAUD_57600            57600
+#define         UART16550_BAUD_115200           115200
+
+#define         UART16550_PARITY_NONE           0
+#define         UART16550_PARITY_ODD            0x08
+#define         UART16550_PARITY_EVEN           0x18
+#define         UART16550_PARITY_MARK           0x28
+#define         UART16550_PARITY_SPACE          0x38
+
+#define         UART16550_DATA_5BIT             0x0
+#define         UART16550_DATA_6BIT             0x1
+#define         UART16550_DATA_7BIT             0x2
+#define         UART16550_DATA_8BIT             0x3
+
+#define         UART16550_STOP_1BIT             0x0
+#define         UART16550_STOP_2BIT             0x4
+
+/* ----------------------------------------------------- */
+
+/* === CONFIG === */
+#ifdef CONFIG_64BIT
+#define         BASE                    (0xffffffffbff003f8)
+#else
+#define         BASE                    (0xbff003f8)
+#endif
+
+#define         MAX_BAUD                BASE_BAUD
+/* === END OF CONFIG === */
+
+#define         REG_OFFSET              1
+
+/* register offset */
+#define         OFS_RCV_BUFFER          0
+#define         OFS_TRANS_HOLD          0
+#define         OFS_SEND_BUFFER         0
+#define         OFS_INTR_ENABLE         (1*REG_OFFSET)
+#define         OFS_INTR_ID             (2*REG_OFFSET)
+#define         OFS_DATA_FORMAT         (3*REG_OFFSET)
+#define         OFS_LINE_CONTROL        (3*REG_OFFSET)
+#define         OFS_MODEM_CONTROL       (4*REG_OFFSET)
+#define         OFS_RS232_OUTPUT        (4*REG_OFFSET)
+#define         OFS_LINE_STATUS         (5*REG_OFFSET)
+#define         OFS_MODEM_STATUS        (6*REG_OFFSET)
+#define         OFS_RS232_INPUT         (6*REG_OFFSET)
+#define         OFS_SCRATCH_PAD         (7*REG_OFFSET)
+
+#define         OFS_DIVISOR_LSB         (0*REG_OFFSET)
+#define         OFS_DIVISOR_MSB         (1*REG_OFFSET)
+
+/* memory-mapped read/write of the port */
+#define         UART16550_READ(y)    (*((volatile u8*)(BASE + y)))
+#define         UART16550_WRITE(y, z)  ((*((volatile u8*)(BASE + y))) = z)
+
+void debugInit(u32 baud, u8 data, u8 parity, u8 stop)
+{
+	/* disable interrupts */
+	UART16550_WRITE(OFS_INTR_ENABLE, 0);
+
+	/* set up buad rate */
+	{
+		u32 divisor;
+
+		/* set DIAB bit */
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x80);
+
+		/* set divisor */
+		divisor = MAX_BAUD / baud;
+		UART16550_WRITE(OFS_DIVISOR_LSB, divisor & 0xff);
+		UART16550_WRITE(OFS_DIVISOR_MSB, (divisor & 0xff00) >> 8);
+
+		/* clear DIAB bit */
+		UART16550_WRITE(OFS_LINE_CONTROL, 0x0);
+	}
+
+	/* set data format */
+	UART16550_WRITE(OFS_DATA_FORMAT, data | parity | stop);
+}
+
+static int remoteDebugInitialized = 0;
+
+u8 getDebugChar(void)
+{
+	if (!remoteDebugInitialized) {
+		remoteDebugInitialized = 1;
+		debugInit(UART16550_BAUD_115200,
+			  UART16550_DATA_8BIT,
+			  UART16550_PARITY_NONE, UART16550_STOP_1BIT);
+	}
+
+	while ((UART16550_READ(OFS_LINE_STATUS) & 0x1) == 0) ;
+	return UART16550_READ(OFS_RCV_BUFFER);
+}
+
+int putDebugChar(u8 byte)
+{
+	if (!remoteDebugInitialized) {
+		remoteDebugInitialized = 1;
+		/*
+		   debugInit(UART16550_BAUD_115200,
+		   UART16550_DATA_8BIT,
+		   UART16550_PARITY_NONE, UART16550_STOP_1BIT); */
+	}
+
+	while ((UART16550_READ(OFS_LINE_STATUS) & 0x20) == 0) ;
+	UART16550_WRITE(OFS_SEND_BUFFER, byte);
+	return 1;
+}
+
+extern void prom_putchar(char c);
+
+void prom_printf(char *fmt, ...)
+{
+	va_list args;
+	char ppbuf[1024];
+	char *bptr;
+
+	va_start(args, fmt);
+	vsprintf(ppbuf, fmt, args);
+
+	bptr = ppbuf;
+
+	while (*bptr != 0) {
+		if (*bptr == '\n')
+			prom_putchar('\r');
+
+		prom_putchar(*bptr++);
+	}
+	va_end(args);
+}
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/irq.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/irq.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/irq.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/irq.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2007 Lemote Inc. & Insititute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/irq_cpu.h>
+#include <asm/i8259.h>
+#include <asm/mipsregs.h>
+#include <asm/delay.h>
+#include <asm/mips-boards/bonito64.h>
+
+#define	BONITO_INT_BIT_GPIO0		(1 << 0)
+#define	BONITO_INT_BIT_GPIO1		(1 << 1)
+#define	BONITO_INT_BIT_GPIO2		(1 << 2)
+#define	BONITO_INT_BIT_GPIO3		(1 << 3)
+#define	BONITO_INT_BIT_PCI_INTA		(1 << 4)
+#define	BONITO_INT_BIT_PCI_INTB		(1 << 5)
+#define	BONITO_INT_BIT_PCI_INTC		(1 << 6)
+#define	BONITO_INT_BIT_PCI_INTD		(1 << 7)
+#define	BONITO_INT_BIT_PCI_PERR		(1 << 8)
+#define	BONITO_INT_BIT_PCI_SERR		(1 << 9)
+#define	BONITO_INT_BIT_DDR		(1 << 10)
+#define	BONITO_INT_BIT_INT0		(1 << 11)
+#define	BONITO_INT_BIT_INT1		(1 << 12)
+#define	BONITO_INT_BIT_INT2		(1 << 13)
+#define	BONITO_INT_BIT_INT3		(1 << 14)
+
+#define	BONITO_INT_TIMER_OFF		7
+#define	BONITO_INT_BONITO_OFF		6
+#define	BONITO_INT_UART_OFF			3
+#define	BONITO_INT_I8259_OFF		2
+
+/****************************************************************/
+
+static void loongson2f_timer_dispatch(void)
+{
+	/* place the loongson2f timer interrupt on 23 */
+	do_IRQ(MIPS_CPU_IRQ_BASE + BONITO_INT_TIMER_OFF);
+	return;
+}
+
+static void loongson2f_bonito_dispatch(void)
+{
+	int int_status;
+	int i = 0;
+
+	/* place the other interrupt on bit6 for bonito, inclding PCI and so on */
+	int_status = BONITO_INTISR & BONITO_INTEN;
+	
+	for(i = 0; (i < 10) && int_status; i++){
+		if(int_status & (1 << i)){
+			if(i == 10)
+				printk("ddr int.\n");
+			if(int_status & 0x000000f0)
+				do_IRQ(BONITO_IRQ_BASE + i);
+			int_status &= ~(1 << i);
+		}
+	}
+	
+	return;
+}
+
+static void loongson2f_int3_dispatch(void)
+{
+	int int_status;
+	
+	int_status = BONITO_INTISR & BONITO_INTEN;
+	if(int_status & BONITO_INT_BIT_INT3){
+	}
+	
+	return;
+}
+
+static void loongson2f_int2_dispatch(void)
+{
+	int int_status;
+	
+	int_status = BONITO_INTISR & BONITO_INTEN;
+	if(int_status & BONITO_INT_BIT_INT2){
+	}
+	
+	return;
+}
+
+static void loongson2f_int1_dispatch(void)
+{
+	/* place the loongson2f uart interrupt on int1 */
+	do_IRQ(MIPS_CPU_IRQ_BASE + BONITO_INT_UART_OFF);
+}
+
+static void i8259_irqdispatch(void)
+{
+	int irq, isr, imr;
+
+	if((BONITO_INTISR & BONITO_INTEN) & BONITO_INT_BIT_INT0) {
+
+		imr = inb(0x21) | (inb(0xa1) << 8);
+		isr = inb(0x20) | (inb(0xa0) << 8);
+		isr &= ~0x4; // irq2 for cascade
+		isr &= ~imr;
+		irq = ffs(isr) - 1;
+
+		if(irq >= 0) {
+			do_IRQ(irq);
+		} else {
+			spurious_interrupt();
+		}
+	}
+}
+
+static void loongson2f_steer1_dispatch(void)
+{
+	return;
+}
+
+static void loongson2f_steer0_dispatch(void)
+{
+	return;
+}
+
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	unsigned int pending = read_c0_cause() & read_c0_status() & ST0_IM;
+
+	if(pending & CAUSEF_IP7){
+		loongson2f_timer_dispatch();
+	}else if(pending & CAUSEF_IP6){ /* North Bridge, Performance counter */
+		do_IRQ(MIPS_CPU_IRQ_BASE + 6);
+		loongson2f_bonito_dispatch();
+	}else if(pending & CAUSEF_IP5){
+		loongson2f_int3_dispatch();
+	}else if(pending & CAUSEF_IP4){
+		loongson2f_int2_dispatch();
+	}else if(pending & CAUSEF_IP3){ /* CPU UART */
+		loongson2f_int1_dispatch();
+	}else if(pending & CAUSEF_IP2){ /* South Bridge */
+		i8259_irqdispatch();
+	}else if(pending & CAUSEF_IP1){
+		loongson2f_steer1_dispatch();
+	}else if(pending & CAUSEF_IP0){
+		loongson2f_steer0_dispatch();
+	}else{
+		spurious_interrupt();
+	}
+	return;
+}
+
+static struct irqaction cascade_irqaction = {
+	.handler = no_action,
+	.mask = CPU_MASK_NONE,
+	.name = "cascade",
+};
+
+irqreturn_t ip6_action(int cpl, void *dev_id, struct pt_regs *regs)
+{
+	return IRQ_HANDLED;
+}
+
+static struct irqaction ip6_irqaction = {
+	.handler = ip6_action,
+	.mask = CPU_MASK_NONE,
+	.name = "cascade",
+	.flags = IRQF_SHARED,
+};
+
+void __init arch_init_irq(void)
+{
+	extern void bonito_irq_init(void);
+
+	/*
+	 * Clear all of the interrupts while we change the able around a bit.
+	 * int-handler is not on bootstrap
+	 */
+	clear_c0_status(ST0_IM | ST0_BEV);
+	local_irq_disable();
+	
+	/* setup cs5536 as high level */
+	BONITO_INTPOL  = (1 << 11 | 1 << 12);
+	BONITO_INTEDGE &= ~(1 << 11 | 1 << 12);
+
+	/* no steer */
+	BONITO_INTSTEER = 0;
+
+	/*
+	 * Mask out all interrupt by writing "1" to all bit position in
+	 * the interrupt reset reg.
+	 */
+	BONITO_INTENCLR = ~0;
+
+	/* init all controller
+	 *   0-15         ------> i8259 interrupt
+	 *   16-23        ------> mips cpu interrupt
+	 *   32-63        ------> bonito irq
+	 */
+	
+	/* Sets the first-level interrupt dispatcher. */
+	mips_cpu_irq_init();
+
+	init_i8259_irqs();
+	bonito_irq_init();
+	
+	/* setup bonito interrupt */
+	setup_irq(MIPS_CPU_IRQ_BASE + BONITO_INT_BONITO_OFF, &ip6_irqaction);
+	/* 8259 irq at IP2 */
+	setup_irq(MIPS_CPU_IRQ_BASE + BONITO_INT_I8259_OFF, &cascade_irqaction);
+
+}
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/Makefile linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/Makefile
--- linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/Makefile	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,7 @@
+#
+# Makefile for Lemote Loongson-2F mini notebook
+#
+
+obj-y	+= setup.o prom.o reset.o irq.o bonito-irq.o dbg_io.o 
+
+EXTRA_AFLAGS := $(CFLAGS)
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/prom.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/prom.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/prom.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/prom.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,157 @@
+/*
+ * Based on Ocelot Linux port, which is
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: jsun@mvista.com or jsun@junsun.net
+ *
+ * Copyright 2003 ICT CAS
+ * Author: Michael Guo <guoyi@ict.ac.cn>
+ *
+ * Copyright (C) 2007 Lemote Inc. & Insititute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+
+extern unsigned long bus_clock;
+extern unsigned long cpu_clock_freq;
+extern unsigned int memsize, highmemsize;
+extern int putDebugChar(unsigned char byte);
+
+static int argc;
+/* pmon passes arguments in 32bit pointers */
+static int *arg;
+static int *env;
+
+const char *get_system_type(void)
+{
+	return "lemote-yeloong";
+}
+
+void __init prom_init_cmdline(void)
+{
+	int i;
+	long l;
+
+	/* arg[0] is "g", the rest is boot parameters */
+	arcs_cmdline[0] = '\0';
+	for (i = 1; i < argc; i++) {
+		l = (long)arg[i];
+		if (strlen(arcs_cmdline) + strlen(((char *)l) + 1)
+		    >= sizeof(arcs_cmdline))
+			break;
+		strcat(arcs_cmdline, ((char *)l));
+		strcat(arcs_cmdline, " ");
+	}
+}
+
+extern void _wrmsr(u32 msr, u32 hi, u32 lo);
+
+void __init prom_init(void)
+{
+	long l;
+	unsigned char default_root[50] = "/dev/hda1";
+	argc = fw_arg0;
+	arg = (int *)fw_arg1;
+	env = (int *)fw_arg2;
+
+	 /* set lpc irq to quiet mode*/
+	//_wrmsr(0x8000004e, 0, 0);
+	//_wrmsr(0x8000004e, 0, 0xc0);
+	_wrmsr(0x80000014, 0x00, 0x16000003);
+
+	/*Emulate post for usb*/
+	_wrmsr(0x40000001, 0x4, 0xBF000);
+
+	prom_init_cmdline();
+
+#if 1
+	if (!strstr(arcs_cmdline, "no_auto_cmd")) {
+		char *pmon_ver, *ec_ver, *p, version[60], ec_version[64];
+		
+		p = arcs_cmdline;
+
+		pmon_ver = strstr(arcs_cmdline, "PMON_VER");
+		if (pmon_ver) {
+			if((p = strstr(pmon_ver, " ")))
+				*p++ = '\0';
+			strncpy(version, pmon_ver, 60);
+		} else
+			strncpy(version, "PMON_VER=Unknown", 60);
+
+		ec_ver = strstr(p, "EC_VER");
+		if (ec_ver) {
+			if((p = strstr(ec_ver, " ")))
+				*p = '\0';
+			strncpy(ec_version, ec_ver, 64);
+		} else
+			strncpy(ec_version, "EC_VER=Unknown", 64);
+
+		p = strstr(arcs_cmdline, "root=");
+		if(p) {
+			strncpy(default_root, p, sizeof(default_root));
+			if(p=strstr(default_root, " "))
+				*p = '\0';
+		}
+
+		memset(arcs_cmdline, 0, sizeof(arcs_cmdline));
+		strcat(arcs_cmdline, version);
+		strcat(arcs_cmdline, " ");
+		strcat(arcs_cmdline, ec_version);
+		strcat(arcs_cmdline, " ");
+		strcat(arcs_cmdline, default_root);
+		strcat(arcs_cmdline, " console=tty2");
+		strcat(arcs_cmdline, " quiet");
+	}
+#endif
+	if ((strstr(arcs_cmdline, "console=")) == NULL)
+		strcat(arcs_cmdline, " console=ttyS0,115200");
+
+	if ((strstr(arcs_cmdline, "root=")) == NULL)
+		strcat(arcs_cmdline, " root=/dev/hda1");
+
+	l = (long)*env;
+	while (l != 0) {
+		if (strncmp("busclock", (char *)l, strlen("busclock")) == 0) {
+			bus_clock = simple_strtol((char *)l + strlen("busclock="),
+					NULL, 10);
+		}
+		if (strncmp("cpuclock", (char *)l, strlen("cpuclock")) == 0) {
+			cpu_clock_freq = simple_strtol((char *)l + strlen("cpuclock="),
+					NULL, 10);
+		}
+		if (strncmp("memsize", (char *)l, strlen("memsize")) == 0) {
+			memsize = simple_strtol((char *)l + strlen("memsize="),
+						NULL, 10);
+		}
+		if (strncmp("highmemsize", (char *)l, strlen("highmemsize")) == 0) {
+			highmemsize = simple_strtol((char *)l + strlen("highmemsize="),
+					  NULL, 10);
+		}
+		env++;
+		l = (long)*env;
+	}
+	if (memsize == 0)
+		memsize = 256;
+
+	printk("busclock=%ld, cpuclock=%ld,memsize=%d,highmemsize=%d\n",
+	       bus_clock, cpu_clock_freq, memsize, highmemsize);
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
+
+void prom_putchar(char c)
+{
+	putDebugChar(c);
+}
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/reset.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/reset.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/reset.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/reset.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,80 @@
+/*
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Copyright (C) 2007 Lemote, Inc. & Institute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ */
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/reboot.h>
+#include <asm/system.h>
+
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+
+extern void _wrmsr(u32 reg, u32 hi, u32 lo);
+extern void _rdmsr(u32 reg, u32 *hi, u32 *lo);
+
+static void loongson2f_restart(char *command)
+{
+#ifdef CONFIG_32BIT
+	*(volatile u32*)0xbfe00180 |= 0x7;
+#else
+	*(volatile u32*)0xffffffffbfe00180 |= 0x7;
+#endif
+
+#ifdef	CONFIG_64BIT
+	*((volatile u8*)(0xffffffffbfd00381)) = 0xf4;
+	*((volatile u8*)(0xffffffffbfd00382)) = 0xec;
+	*((volatile u8*)(0xffffffffbfd00383)) = 0x01;
+#else
+	*((volatile u8*)(0xbfd00381)) = 0xfe;
+	*((volatile u8*)(0xbfd00382)) = 0xec;
+	*((volatile u8*)(0xbfd00383)) = 0x01;
+#endif
+
+	while (1);
+	/* Wait the system reset completely */
+#if 0
+	__asm__ __volatile__ (
+					".long 0x3c02bfc0\n"
+					".long 0x00400008\n"
+					:::"v0"
+					);
+#endif
+}
+
+static void loongson2f_halt(void)
+{
+#ifdef	CONFIG_64BIT
+	/* cpu-gpio0 output low */
+	*((volatile u32*)(0xffffffffbfe0011c)) &= ~0x00000001;
+	/* cpu-gpio0 as output */
+	*((volatile u32*)(0xffffffffbfe00120)) &= ~0x00000001;
+#else
+	/* cpu-gpio0 output low */
+	*((volatile u32*)(0xbfe0011c)) &= ~0x00000001;
+	/* cpu-gpio0 as output */
+	*((volatile u32*)(0xbfe00120)) &= ~0x00000001;
+#endif
+
+}
+
+static void loongson2f_power_off(void)
+{
+	loongson2f_halt();
+}
+
+void mips_reboot_setup(void)
+{
+	_machine_restart = loongson2f_restart;
+	_machine_halt = loongson2f_halt;
+	pm_power_off = loongson2f_power_off;
+}
diff -Nur linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/setup.c linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/setup.c
--- linux-2.6.29.1/arch/mips/lemote/lm2f/yeeloong/setup.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/lemote/lm2f/yeeloong/setup.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,134 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ * setup.c - board dependent boot routines
+ *
+ * Copyright (C) 2007 Lemote Inc. & Insititute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/bootmem.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/bootinfo.h>
+#include <asm/mc146818-time.h>
+#include <asm/time.h>
+#include <asm/wbflush.h>
+
+#ifdef CONFIG_VT
+#include <linux/console.h>
+#include <linux/screen_info.h>
+#endif
+
+extern void mips_reboot_setup(void);
+
+#ifdef CONFIG_64BIT
+#define PTR_PAD(p) ((0xffffffff00000000)|((unsigned long long)(p)))
+#else
+#define PTR_PAD(p) (p)
+#endif
+
+unsigned long cpu_clock_freq;
+unsigned long bus_clock;
+unsigned int memsize;
+unsigned int highmemsize = 0;
+
+extern int __init init_mfgpt_clocksource(void);
+
+void __init plat_time_init(void)
+{
+	/* setup mips r4k timer */
+	mips_hpt_frequency = cpu_clock_freq / 2;
+
+#ifdef CONFIG_CS5536_MFGPT
+	init_mfgpt_clocksource();
+#endif
+}
+
+unsigned long read_persistent_clock(void)
+{
+	return mc146818_get_cmos_time();
+}
+
+void (*__wbflush)(void);
+EXPORT_SYMBOL(__wbflush);
+
+static void wbflush_loongson2f(void)
+{
+	asm(".set\tpush\n\t"
+	    ".set\tnoreorder\n\t"
+	    ".set mips3\n\t"
+	    "sync\n\t"
+	    "nop\n\t"
+	    ".set\tpop\n\t"
+	    ".set mips0\n\t");
+}
+
+void __init plat_mem_setup(void)
+{
+	set_io_port_base(PTR_PAD(0xbfd00000));
+
+	mips_reboot_setup();
+
+	__wbflush = wbflush_loongson2f;
+
+	add_memory_region(0x0, (memsize << 20), BOOT_MEM_RAM);
+#ifdef CONFIG_64BIT
+	__asm__(
+		".set mips3\n"			
+		"dli $2, 0x900000003ff00000\n"
+		"dli $3, 0x0000000080000000\n"
+		"sd  $3, 0x10($2)\n"
+		"sd  $0, 0x50($2)\n"
+		"dli $3, 0xffffffffc0000000\n"
+		"sd  $3, 0x30($2)\n"
+		".set mips0\n"
+		:::"$2","$3","memory");
+	if (highmemsize > 0) {
+		add_memory_region(0x90000000, highmemsize << 20, BOOT_MEM_RAM);
+	}
+#endif
+
+#ifdef CONFIG_VT
+#if defined(CONFIG_VGA_CONSOLE)
+	conswitchp = &vga_con;
+
+	screen_info = (struct screen_info) {
+		0, 25,		/* orig-x, orig-y */
+		    0,		/* unused */
+		    0,		/* orig-video-page */
+		    0,		/* orig-video-mode */
+		    80,		/* orig-video-cols */
+		    0, 0, 0,	/* ega_ax, ega_bx, ega_cx */
+		    25,		/* orig-video-lines */
+		    VIDEO_TYPE_VGAC,	/* orig-video-isVGA */
+		    16		/* orig-video-points */
+	};
+#elif defined(CONFIG_DUMMY_CONSOLE)
+	conswitchp = &dummy_con;
+#endif
+#endif
+
+}
+
+EXPORT_SYMBOL(cpu_clock_freq);
diff -Nur linux-2.6.29.1/arch/mips/Makefile linux-2.6.29.1-lemote/arch/mips/Makefile
--- linux-2.6.29.1/arch/mips/Makefile	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/Makefile	2009-04-07 09:39:28.000000000 +0000
@@ -311,6 +311,25 @@
 cflags-$(CONFIG_LEMOTE_FULONG) += -I$(srctree)/arch/mips/include/asm/mach-lemote
 
 #
+# common lemote loongson2f stuffs
+#
+core-$(CONFIG_MACH_LM2F) +=arch/mips/lemote/lm2f/common/
+
+#
+# lemote loongson2f fuloong mini-PC board
+#
+core-$(CONFIG_LEMOTE_FULOONG2F) +=arch/mips/lemote/lm2f/fuloong/
+load-$(CONFIG_LEMOTE_FULOONG2F) +=0xffffffff80200000
+cflags-$(CONFIG_LEMOTE_FULOONG2F) += -I$(srctree)/arch/mips/include/asm/mach-lemote
+
+#
+# lemote loongson2f yeeloong mini laptop 
+#
+core-$(CONFIG_LEMOTE_YEELOONG2F) +=arch/mips/lemote/lm2f/yeeloong/
+load-$(CONFIG_LEMOTE_YEELOONG2F) +=0xffffffff80200000
+cflags-$(CONFIG_LEMOTE_YEELOONG2F) += -I$(srctree)/arch/mips/include/asm/mach-lemote
+
+#
 # MIPS Malta board
 #
 core-$(CONFIG_MIPS_MALTA)	+= arch/mips/mti-malta/
@@ -674,6 +693,9 @@
 
 drivers-$(CONFIG_OPROFILE)	+= arch/mips/oprofile/
 
+# suspend and hibernation support
+drivers-$(CONFIG_PM)	+= arch/mips/power/
+
 ifdef CONFIG_LASAT
 rom.bin rom.sw: vmlinux
 	$(Q)$(MAKE) $(build)=arch/mips/lasat/image $@
diff -Nur linux-2.6.29.1/arch/mips/mm/c-r4k.c linux-2.6.29.1-lemote/arch/mips/mm/c-r4k.c
--- linux-2.6.29.1/arch/mips/mm/c-r4k.c	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/mm/c-r4k.c	2009-04-07 09:39:28.000000000 +0000
@@ -780,7 +780,7 @@
 		c->dcache.ways = 2;
 		c->dcache.waybit = 0;
 
-		c->options |= MIPS_CPU_CACHE_CDEX_P;
+		c->options |= MIPS_CPU_CACHE_CDEX_P | MIPS_CPU_PREFETCH;
 		break;
 
 	case CPU_TX49XX:
@@ -1047,7 +1047,7 @@
 
 	printk("Primary instruction cache %ldkB, %s, %s, linesize %d bytes.\n",
 	       icache_size >> 10,
-	       cpu_has_vtag_icache ? "VIVT" : "VIPT",
+	       c->icache.flags & MIPS_CACHE_VTAG ? "VIVT" : "VIPT",
 	       way_string[c->icache.ways], c->icache.linesz);
 
 	printk("Primary data cache %ldkB, %s, %s, %s, linesize %d bytes\n",
diff -Nur linux-2.6.29.1/arch/mips/mm/dma-default.c linux-2.6.29.1-lemote/arch/mips/mm/dma-default.c
--- linux-2.6.29.1/arch/mips/mm/dma-default.c	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/mm/dma-default.c	2009-04-07 09:39:28.000000000 +0000
@@ -225,7 +225,7 @@
 	if (!plat_device_is_coherent(dev) && direction != DMA_TO_DEVICE) {
 		unsigned long addr;
 
-		addr = plat_dma_addr_to_phys(dma_address);
+		addr = dma_addr_to_virt(dma_address);
 		dma_cache_wback_inv(addr, size);
 	}
 
diff -Nur linux-2.6.29.1/arch/mips/oprofile/common.c linux-2.6.29.1-lemote/arch/mips/oprofile/common.c
--- linux-2.6.29.1/arch/mips/oprofile/common.c	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/oprofile/common.c	2009-04-07 09:39:28.000000000 +0000
@@ -16,6 +16,7 @@
 
 extern struct op_mips_model op_model_mipsxx_ops __attribute__((weak));
 extern struct op_mips_model op_model_rm9000_ops __attribute__((weak));
+extern struct op_mips_model op_model_loongson2_ops __attribute__((weak));
 
 static struct op_mips_model *model;
 
@@ -93,6 +94,10 @@
 	case CPU_RM9000:
 		lmodel = &op_model_rm9000_ops;
 		break;
+	
+	case CPU_LOONGSON2:
+		lmodel = &op_model_loongson2_ops;
+		break;
 	};
 
 	if (!lmodel)
diff -Nur linux-2.6.29.1/arch/mips/oprofile/Makefile linux-2.6.29.1-lemote/arch/mips/oprofile/Makefile
--- linux-2.6.29.1/arch/mips/oprofile/Makefile	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/oprofile/Makefile	2009-04-07 09:39:28.000000000 +0000
@@ -15,3 +15,4 @@
 oprofile-$(CONFIG_CPU_R10000)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_SB1)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_RM9000)		+= op_model_rm9000.o
+oprofile-$(CONFIG_CPU_LOONGSON2)  	+= op_model_loongson2.o
diff -Nur linux-2.6.29.1/arch/mips/oprofile/op_model_loongson2.c linux-2.6.29.1-lemote/arch/mips/oprofile/op_model_loongson2.c
--- linux-2.6.29.1/arch/mips/oprofile/op_model_loongson2.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/oprofile/op_model_loongson2.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,190 @@
+/*
+ * Loongson2 performance counter driver for oprofile
+ *
+ * Author: Yanhua <yanh@lemote.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+#include <linux/init.h>
+#include <linux/oprofile.h>
+#include <linux/interrupt.h>
+#include <linux/smp.h>
+#include <linux/spinlock.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+
+#include <irq.h>
+#include "op_impl.h"
+
+#define PERF_IRQ (MIPS_CPU_IRQ_BASE + 6 )
+
+#define LOONGSON_COUNTER1_EVENT(event)	((event&0x0f) << 5)
+#define LOONGSON_COUNTER1_SUPERVISOR	(1UL    <<  2)
+#define LOONGSON_COUNTER1_KERNEL		(1UL    <<  1)
+#define LOONGSON_COUNTER1_USER		(1UL    <<  3)
+#define LOONGSON_COUNTER1_ENABLE		(1UL    << 4)
+#define LOONGSON_COUNTER1_OVERFLOW	(1ULL    << 31)
+#define LOONGSON_COUNTER1_EXL			(1UL	<< 0)
+
+#define LOONGSON_COUNTER2_EVENT(event)	((event&0x0f) << 9)
+#define LOONGSON_COUNTER2_SUPERVISOR	LOONGSON_COUNTER1_SUPERVISOR
+#define LOONGSON_COUNTER2_KERNEL		LOONGSON_COUNTER1_KERNEL
+#define LOONGSON_COUNTER2_USER		LOONGSON_COUNTER1_USER
+#define LOONGSON_COUNTER2_ENABLE		LOONGSON_COUNTER1_ENABLE
+#define LOONGSON_COUNTER2_OVERFLOW	(1ULL   << 31)
+#define LOONGSON_COUNTER2_EXL			(1UL	<< 0 )
+#define LOONGSON_COUNTER_EXL		    (1UL << 0)	
+
+/* Loongson2 PerfCount performance counter register */
+#define read_c0_perflo() __read_64bit_c0_register($24, 0)
+#define write_c0_perflo(val) __write_64bit_c0_register($24, 0, val)
+#define read_c0_perfhi() __read_64bit_c0_register($25, 0)
+#define write_c0_perfhi(val) __write_64bit_c0_register($25, 0, val)
+
+extern unsigned int loongson2_perfcount_irq;
+
+static struct loongson2_register_config {
+	unsigned int control;
+	unsigned long long reset_counter1;
+	unsigned long long reset_counter2;
+	int ctr1_enable, ctr2_enable;
+} reg;
+
+DEFINE_SPINLOCK(sample_lock);
+
+static char *oprofid = "LoongsonPerf";
+static irqreturn_t loongson2_perfcount_handler(int irq, void * dev_id);
+/* Compute all of the registers in preparation for enabling profiling.  */
+
+static void loongson2_reg_setup(struct op_counter_config *ctr)
+{
+	unsigned int control = 0;
+
+	reg.reset_counter1 = 0;
+	reg.reset_counter2 = 0;
+	/* Compute the performance counter control word.  */
+	/* For now count kernel and user mode */
+	if (ctr[0].enabled){
+		control |= LOONGSON_COUNTER1_EVENT(ctr[0].event) |
+					LOONGSON_COUNTER1_ENABLE;
+		if(ctr[0].kernel)
+			control |= LOONGSON_COUNTER1_KERNEL;
+		if(ctr[0].user)
+			control |= LOONGSON_COUNTER1_USER;
+		reg.reset_counter1 = 0x80000000ULL - ctr[0].count;
+	}
+
+	if (ctr[1].enabled){
+		control |= LOONGSON_COUNTER2_EVENT(ctr[1].event) |
+		           LOONGSON_COUNTER2_ENABLE;
+		if(ctr[1].kernel)
+			control |= LOONGSON_COUNTER2_KERNEL;
+		if(ctr[1].user)
+			control |= LOONGSON_COUNTER2_USER;
+		reg.reset_counter2 = (0x80000000ULL- ctr[1].count) ;
+	}
+
+	if(ctr[0].enabled ||ctr[1].enabled)
+		control |= LOONGSON_COUNTER_EXL;
+
+	reg.control = control;
+
+	reg.ctr1_enable = ctr[0].enabled;
+	reg.ctr2_enable = ctr[1].enabled;
+
+}
+
+/* Program all of the registers in preparation for enabling profiling.  */
+
+static void loongson2_cpu_setup (void *args)
+{
+	uint64_t perfcount;
+
+	perfcount = (reg.reset_counter2 << 32) |reg.reset_counter1; 
+	write_c0_perfhi(perfcount);
+}
+
+static void loongson2_cpu_start(void *args)
+{
+	/* Start all counters on current CPU */
+	if(reg.ctr1_enable || reg.ctr2_enable) {
+		write_c0_perflo(reg.control);
+	}
+}
+
+static void loongson2_cpu_stop(void *args)
+{
+	/* Stop all counters on current CPU */
+	write_c0_perflo(0);
+	memset(&reg, 0, sizeof(reg));
+}
+
+static irqreturn_t loongson2_perfcount_handler(int irq, void * dev_id)
+{
+	uint64_t counter, counter1, counter2;
+	struct pt_regs *regs = get_irq_regs();
+	int enabled;
+	unsigned long flags;
+	
+	/*
+	 * LOONGSON2 defines two 32-bit performance counters.
+	 * To avoid a race updating the registers we need to stop the counters 
+	 * while we're messing with
+	 * them ...
+	 */
+	
+	/* Check whether the irq belongs to me*/
+	enabled = reg.ctr1_enable| reg.ctr2_enable;
+	if(!enabled){
+		return IRQ_NONE;
+	}
+
+	counter = read_c0_perfhi();
+	counter1 = counter & 0xffffffff;
+	counter2 = counter >> 32;
+
+	spin_lock_irqsave(&sample_lock, flags);
+
+	if (counter1 & LOONGSON_COUNTER1_OVERFLOW) {
+		if(reg.ctr1_enable) 
+			oprofile_add_sample(regs, 0);
+		counter1 = reg.reset_counter1;
+	}
+	if (counter2 & LOONGSON_COUNTER2_OVERFLOW) {
+		if(reg.ctr2_enable)
+			oprofile_add_sample(regs, 1);
+		counter2 = reg.reset_counter2;
+	}
+
+	spin_unlock_irqrestore(&sample_lock, flags);
+
+	write_c0_perfhi((counter2 << 32) | counter1);
+
+	return IRQ_HANDLED;
+}
+
+static int __init loongson2_init(void)
+{
+	return  request_irq(PERF_IRQ, loongson2_perfcount_handler,
+	                   IRQF_SHARED, "Perfcounter", oprofid);
+}
+
+static void loongson2_exit(void)
+{
+	write_c0_perflo(0);
+	free_irq(PERF_IRQ, oprofid);
+}
+
+struct op_mips_model op_model_loongson2_ops = {
+	.reg_setup	= loongson2_reg_setup,
+	.cpu_setup	= loongson2_cpu_setup,
+	.init		= loongson2_init,	
+	.exit		= loongson2_exit,
+	.cpu_start	= loongson2_cpu_start,
+	.cpu_stop	= loongson2_cpu_stop,
+	.cpu_type	= "mips/godson2",
+	.num_counters	= 2
+};
diff -Nur linux-2.6.29.1/arch/mips/pci/fixup-fl2f.c linux-2.6.29.1-lemote/arch/mips/pci/fixup-fl2f.c
--- linux-2.6.29.1/arch/mips/pci/fixup-fl2f.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/pci/fixup-fl2f.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,256 @@
+/*
+ * fixup-lm2f.c
+ *
+ * Copyright (C) 2004 ICT CAS
+ * Author: Li xiaoyu, ICT CAS
+ *   lixy@ict.ac.cn
+ *
+ * Copyright (C) 2007 Lemote, Inc. & Institute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <asm/mips-boards/bonito64.h>
+
+/* PCI interrupt pins */
+/* These should not be changed, or you should consider godson2f interrupt register and
+ * your pci card dispatch
+ */
+#define PCIA		4
+#define PCIB		5
+#define PCIC		6
+#define PCID		7
+
+/* all the pci device has the PCIA pin, check the datasheet. */
+static char irq_tab[][5] __initdata = {
+	/*      INTA    INTB    INTC    INTD */
+	{0,	0,	0,	0,	0 },	/*  11: Unused */
+	{0,	0,	0,	0,	0 },	/*  12: Unused */
+	{0,	0,	0,	0,	0 },	/*  13: Unused */
+	{0,	0,	0,	0,	0 },	/*  14: Unused */
+	{0,	0,	0,	0,	0 },	/*  15: Unused */
+	{0,	0,	0,	0,	0 },	/*  16: Unused */
+	{0,	PCIA,	0,	0,	0 },	/*  17: RTL8110-0 */
+	{0,	PCIB,	0,	0,	0 },	/*  18: RTL8110-1 */
+	{0,	PCIC,	0,	0,	0 },	/*  19: SiI3114 */
+	{0,	PCID,	0,	0,	0 },	/*  20: 3-ports nec usb*/
+	{0,	PCIA,	PCIB,	PCIC,	PCID },	/*  21: PCI-SLOT */
+	{0,	0,	0,	0,	0 },	/*  22: Unused */
+	{0,	0,	0,	0,	0 },	/*  23: Unused */
+	{0,	0,	0,	0,	0 },	/*  24: Unused */
+	{0,	0,	0,	0,	0 },	/*  25: Unused */
+	{0,	0,	0,	0,	0 },	/*  26: Unused */
+	{0,	0,	0,	0,	0 },	/*  27: Unused */
+};
+
+int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int virq;
+
+	if( (PCI_SLOT(dev->devfn) != (14)) && (PCI_SLOT(dev->devfn) < 32) ){
+		virq = irq_tab[slot][pin];
+		printk("slot: %d, pin: %d, irq: %d\n", slot, pin, virq+BONITO_IRQ_BASE);
+		if(virq != 0)
+			return (BONITO_IRQ_BASE + virq);
+		else	
+			return 0;
+	}else if( PCI_SLOT(dev->devfn) == 14){	// cs5536
+		switch(PCI_FUNC(dev->devfn)){
+			case 2 :
+				pci_write_config_byte(dev, PCI_INTERRUPT_LINE, 14);
+				return 14;	// for IDE
+			case 3 :
+				pci_write_config_byte(dev, PCI_INTERRUPT_LINE, 9);
+				return 9;	// for AUDIO
+			case 4 :		// for OHCI
+			case 5 :		// for EHCI
+			case 6 :		// for UDC
+			case 7 :		// for OTG
+				pci_write_config_byte(dev, PCI_INTERRUPT_LINE, 11);
+				return 11;	
+		}
+		return dev->irq;
+	}else{
+		printk(" strange pci slot number.\n");
+		return 0;
+	}
+}
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+#ifndef	TEST_NO_CS5536
+
+extern void _wrmsr(u32 reg, u32 hi, u32 lo);
+extern void _rdmsr(u32 reg, u32 *hi, u32 *lo);
+
+/* CS5536 SPEC. fixup */
+static void __init loongson2f_cs5536_isa_fixup(struct pci_dev *pdev)
+{
+	/* the uart1 and uart2 interrupt in PIC is enabled as default */
+	pci_write_config_dword(pdev, 0x50, 1);
+	pci_write_config_dword(pdev, 0x54, 1);
+	/* enable the pci MASTER ABORT/ TARGET ABORT etc. */
+	//pci_write_config_dword(pdev, 0x58, 1);
+	return;
+}
+
+
+static void __init loongson2f_cs5536_ide_fixup(struct pci_dev *pdev)
+{
+	/* setting the mutex pin as IDE function */
+	/* the IDE interrupt in PIC is enabled as default */
+	pci_write_config_dword(pdev, 0x40, 0xDEADBEEF);
+	return;
+}
+
+static void __init loongson2f_cs5536_acc_fixup(struct pci_dev *pdev)
+{
+	u8 val;
+
+	/* enable the AUDIO interrupt in PIC  */
+	pci_write_config_dword(pdev, 0x50, 1);
+
+#if 1
+	pci_read_config_byte(pdev, PCI_LATENCY_TIMER, &val);
+	printk("cs5536 acc latency %x\n", val);
+	pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0xc0);
+#endif
+	return;
+}
+
+static void __init loongson2f_cs5536_ohci_fixup(struct pci_dev *pdev)
+{
+	/* enable the OHCI interrupt in PIC */
+	/* THE OHCI, EHCI, UDC, OTG are shared with interrupt in PIC */
+	pci_write_config_dword(pdev, 0x50, 1);
+	return;
+}
+
+static void __init loongson2f_cs5536_ehci_fixup(struct pci_dev *pdev)
+{
+	u32 hi, lo;
+#if 0
+	u32 bar;
+	void __iomem *base;
+#endif
+	
+	/* Serial short detect enable */
+	_rdmsr(0x40000001, &hi, &lo);
+	_wrmsr(0x40000001, (1<<1)|(1<<2)|(1<<3), lo);
+
+#if 0
+	/* Write to clear diag register */
+	_rdmsr(0x40000005, &hi, &lo);
+	_wrmsr(0x40000005, hi, lo);
+
+	pci_read_config_dword(pdev, 0x10, &bar);
+	base = ioremap_nocache(bar, 0x100);
+
+	/* Make HCCAPARMS writable */
+	writel(readl(base + 0xA0) | (1<<1), (base + 0xA0));
+	
+	/* EECP=50h, IST=01h, ASPC=1h */
+	writel(0x00000012, base + 0x08);
+	iounmap(base);
+#endif
+
+	/* setting the USB2.0 micro frame length */
+	pci_write_config_dword(pdev, 0x60, 0x2000);
+	return;
+}
+#endif	/* TEST_NO_CS5536 */
+
+static void __init loongson2f_fixup_pcimap(struct pci_dev *pdev)
+{
+	static int first = 1;
+
+	(void)pdev;
+	if (first)
+		first = 0;
+	else
+		return;
+
+	/* local to PCI mapping: [256M,512M] -> [256M,512M]; differ from pmon */
+	/*
+	 *       cpu address space [256M,448M] is window for accessing pci space
+	 *       we set pcimap_lo[0,1,2] to map it to pci space [256M,448M]
+	 *        pcimap: bit18,pcimap_2; bit[17-12],lo2;bit[11-6],lo1;bit[5-0],lo0
+	 */
+	/* 1,00 0110 ,0001 01,00 0000 */
+	BONITO_PCIMAP = 0x46140;
+	//1, 00 0010, 0000,01, 00 0000
+	//BONITO_PCIMAP = 0x42040;
+
+	/*
+	 * PCI to local mapping: [2G,2G+256M] -> [0,256M]
+	 */
+#if	1	// for GODSON2F
+	BONITO_PCIBASE0 = 0x80000000;
+	BONITO_PCIBASE1 = 0x00000000;
+	BONITO(BONITO_REGBASE + 0x50) = 0xc000000c;
+	BONITO(BONITO_REGBASE + 0x54) = 0xffffffff;
+	BONITO(BONITO_REGBASE + 0x58) = 0x00000006;
+	BONITO(BONITO_REGBASE + 0x5c) = 0x00000000;
+	BONITO(BONITO_REGBASE + 0x60) = 0x00000006;
+	BONITO(BONITO_REGBASE + 0x64) = 0x00000000;
+#else		// for GODSON2E
+	BONITO_PCIBASE0 = 0x80000000;
+	BONITO_PCIBASE1 = 0x00800000;
+	BONITO_PCIBASE2 = 0x90000000;
+#endif
+
+#ifdef CONFIG_64BIT
+	*(volatile u32*)0xffffffffbfe0004c = 0xd2000001;
+#else
+	*(volatile u32*)0xbfe0004c = 0xd2000001;
+#endif
+}
+
+static void __init loongson2f_nec_fixup(struct pci_dev *pdev) 
+{ 
+	unsigned int val; 
+
+	/* Configues port 1, 2, 3 to be validate*/ 
+	pci_read_config_dword(pdev, 0xe0, &val); 
+	pci_write_config_dword(pdev, 0xe0, (val & ~3) | 0x2); /*Only 2 port be used*/
+}
+#ifndef	TEST_NO_CS5536
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_ISA, 
+			 loongson2f_cs5536_isa_fixup);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_OHC, 
+			 loongson2f_cs5536_ohci_fixup);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_EHC, 
+			 loongson2f_cs5536_ehci_fixup);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_AUDIO, 
+			 loongson2f_cs5536_acc_fixup);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_IDE, 
+			 loongson2f_cs5536_ide_fixup);
+#endif	/* TEST_NO_CS5536 */
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, loongson2f_fixup_pcimap);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NEC, PCI_DEVICE_ID_NEC_USB,
+			loongson2f_nec_fixup);
diff -Nur linux-2.6.29.1/arch/mips/pci/fixup-yl2f.c linux-2.6.29.1-lemote/arch/mips/pci/fixup-yl2f.c
--- linux-2.6.29.1/arch/mips/pci/fixup-yl2f.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/pci/fixup-yl2f.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,245 @@
+/*
+ * fixup-lm2f.c
+ *
+ * Copyright (C) 2008 Lemote Technology
+ * Copyright (C) 2004 ICT CAS
+ * Author: Li xiaoyu, ICT CAS
+ *   lixy@ict.ac.cn
+ *
+ * Copyright (C) 2007 Lemote, Inc. & Institute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <asm/mips-boards/bonito64.h>
+
+/* PCI interrupt pins */
+/* These should not be changed, or you should consider godson2f interrupt register and
+ * your pci card dispatch
+ */
+#define PCIA		4
+#define PCIB		5
+#define PCIC		6
+#define PCID		7
+
+/* all the pci device has the PCIA pin, check the datasheet. */
+static char irq_tab[][5] __initdata = {
+	/*      INTA    INTB    INTC    INTD */
+	{0,	0,	0,	0,	0 },	/*  11: Unused */
+	{0,	0,	0,	0,	0 },	/*  12: Unused */
+	{0,	0,	0,	0,	0 },	/*  13: Unused */
+	{0,	0,	0,	0,	0 },	/*  14: Unused */
+	{0,	0,	0,	0,	0 },	/*  15: Unused */
+	{0,	0,	0,	0,	0 },	/*  16: Unused */
+	{0,	PCIA,	0,	0,	0 },	/*  17: RTL8110-0 */
+	{0,	PCIB,	0,	0,	0 },	/*  18: RTL8110-1 */
+	{0,	PCIC,	0,	0,	0 },	/*  19: SiI3114 */
+	{0,	PCID,	0,	0,	0 },	/*  20: 3-ports nec usb*/
+	{0,	PCIA,	PCIB,	PCIC,	PCID },	/*  21: PCI-SLOT */
+	{0,	0,	0,	0,	0 },	/*  22: Unused */
+	{0,	0,	0,	0,	0 },	/*  23: Unused */
+	{0,	0,	0,	0,	0 },	/*  24: Unused */
+	{0,	0,	0,	0,	0 },	/*  25: Unused */
+	{0,	0,	0,	0,	0 },	/*  26: Unused */
+	{0,	0,	0,	0,	0 },	/*  27: Unused */
+};
+
+int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int virq;
+
+	if( (PCI_SLOT(dev->devfn) != (14)) && (PCI_SLOT(dev->devfn) < 32) ){
+		virq = irq_tab[slot][pin];
+		printk("slot: %d, pin: %d, irq: %d\n", slot, pin, virq+BONITO_IRQ_BASE);
+		if(virq != 0)
+			return (BONITO_IRQ_BASE + virq);
+		else	
+			return 0;
+	}else if( PCI_SLOT(dev->devfn) == 14){	// cs5536
+		switch(PCI_FUNC(dev->devfn)){
+			case 2 :
+				pci_write_config_byte(dev, PCI_INTERRUPT_LINE, 14);
+				return 14;	// for IDE
+			case 3 :
+				pci_write_config_byte(dev, PCI_INTERRUPT_LINE, 9);
+				return 9;	// for AUDIO
+			case 4 :		// for OHCI
+			case 5 :		// for EHCI
+			case 6 :		// for UDC
+			case 7 :		// for OTG
+				pci_write_config_byte(dev, PCI_INTERRUPT_LINE, 11);
+				return 11;	
+		}
+		return dev->irq;
+	}else{
+		printk(" strange pci slot number.\n");
+		return 0;
+	}
+}
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+extern void _wrmsr(u32 reg, u32 hi, u32 lo);
+extern void _rdmsr(u32 reg, u32 *hi, u32 *lo);
+
+/* CS5536 SPEC. fixup */
+static void __init loongson2f_cs5536_isa_fixup(struct pci_dev *pdev)
+{
+	/* the uart1 and uart2 interrupt in PIC is enabled as default */
+	pci_write_config_dword(pdev, 0x50, 1);
+	pci_write_config_dword(pdev, 0x54, 1);
+	/* enable the pci MASTER ABORT/ TARGET ABORT etc. */
+	//pci_write_config_dword(pdev, 0x58, 1);
+	return;
+}
+
+
+static void __init loongson2f_cs5536_ide_fixup(struct pci_dev *pdev)
+{
+	/* setting the mutex pin as IDE function */
+	/* the IDE interrupt in PIC is enabled as default */
+	pci_write_config_dword(pdev, 0x40, 0xDEADBEEF);
+	return;
+}
+
+static void __init loongson2f_cs5536_acc_fixup(struct pci_dev *pdev)
+{
+	u8 val;
+
+	/* enable the AUDIO interrupt in PIC  */
+	pci_write_config_dword(pdev, 0x50, 1);
+
+#if 1
+	pci_read_config_byte(pdev, PCI_LATENCY_TIMER, &val);
+	printk("cs5536 acc latency %x\n", val);
+	pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0xc0);
+#endif
+	return;
+}
+
+static void __init loongson2f_cs5536_ohci_fixup(struct pci_dev *pdev)
+{
+	/* enable the OHCI interrupt in PIC */
+	/* THE OHCI, EHCI, UDC, OTG are shared with interrupt in PIC */
+	pci_write_config_dword(pdev, 0x50, 1);
+	return;
+}
+
+static void __init loongson2f_cs5536_ehci_fixup(struct pci_dev *pdev)
+{
+	u32 hi, lo;
+#if 0
+	u32 bar;
+	void __iomem *base;
+#endif
+	
+	/* Serial short detect enable */
+	_rdmsr(0x40000001, &hi, &lo);
+	_wrmsr(0x40000001, (1<<1)|(1<<2)|(1<<3), lo);
+
+#if 0
+	/* Write to clear diag register */
+	_rdmsr(0x40000005, &hi, &lo);
+	_wrmsr(0x40000005, hi, lo);
+
+	pci_read_config_dword(pdev, 0x10, &bar);
+	base = ioremap_nocache(bar, 0x100);
+
+	/* Make HCCAPARMS writable */
+	writel(readl(base + 0xA0) | (1<<1), (base + 0xA0));
+	
+	/* EECP=50h, IST=01h, ASPC=1h */
+	writel(0x00000012, base + 0x08);
+	iounmap(base);
+#endif
+
+	/* setting the USB2.0 micro frame length */
+	pci_write_config_dword(pdev, 0x60, 0x2000);
+	return;
+}
+
+static void __init loongson2f_fixup_pcimap(struct pci_dev *pdev)
+{
+	static int first = 1;
+
+	(void)pdev;
+	if (first)
+		first = 0;
+	else
+		return;
+
+	/* local to PCI mapping: [256M,512M] -> [256M,512M]; differ from pmon */
+	/*
+	 *       cpu address space [256M,448M] is window for accessing pci space
+	 *       we set pcimap_lo[0,1,2] to map it to pci space [256M,448M]
+	 *        pcimap: bit18,pcimap_2; bit[17-12],lo2;bit[11-6],lo1;bit[5-0],lo0
+	 */
+	/* 1,00 0110 ,0001 01,00 0000 */
+	BONITO_PCIMAP = 0x46140;
+
+	/*
+	 * PCI to local mapping: [2G,2G+256M] -> [0,256M]
+	 */
+	BONITO_PCIBASE0 = 0x80000000;
+	BONITO_PCIBASE1 = 0x00000000;
+	BONITO(BONITO_REGBASE + 0x50) = 0xc000000c;
+	BONITO(BONITO_REGBASE + 0x54) = 0xffffffff;
+	BONITO(BONITO_REGBASE + 0x58) = 0x00000006;
+	BONITO(BONITO_REGBASE + 0x5c) = 0x00000000;
+	BONITO(BONITO_REGBASE + 0x60) = 0x00000006;
+	BONITO(BONITO_REGBASE + 0x64) = 0x00000000;
+
+	BONITO(0x4c) = 0xd2000001;	
+#ifdef CONFIG_64BIT
+	*(volatile u32*)0xffffffffbfe0004c = 0xd2000001;
+#else
+	*(volatile u32*)0xbfe0004c = 0xd2000001;
+#endif
+}
+
+static void __init loongson2f_nec_fixup(struct pci_dev *pdev) 
+{ 
+	unsigned int val; 
+
+	pci_read_config_dword(pdev, 0xe0, &val); 
+	/* Only 2 port be used */
+	pci_write_config_dword(pdev, 0xe0, (val & ~3) | 0x2); 
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_ISA, 
+			 loongson2f_cs5536_isa_fixup);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_OHC, 
+			 loongson2f_cs5536_ohci_fixup);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_EHC, 
+			 loongson2f_cs5536_ehci_fixup);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_AUDIO, 
+			 loongson2f_cs5536_acc_fixup);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_IDE, 
+			 loongson2f_cs5536_ide_fixup);
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, loongson2f_fixup_pcimap);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NEC, PCI_DEVICE_ID_NEC_USB,
+			loongson2f_nec_fixup);
diff -Nur linux-2.6.29.1/arch/mips/pci/Makefile linux-2.6.29.1-lemote/arch/mips/pci/Makefile
--- linux-2.6.29.1/arch/mips/pci/Makefile	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/pci/Makefile	2009-04-07 09:39:28.000000000 +0000
@@ -27,6 +27,8 @@
 obj-$(CONFIG_SOC_AU1550)	+= fixup-au1000.o ops-au1000.o
 obj-$(CONFIG_SOC_PNX8550)	+= fixup-pnx8550.o ops-pnx8550.o
 obj-$(CONFIG_LEMOTE_FULONG)	+= fixup-lm2e.o ops-bonito64.o
+obj-$(CONFIG_LEMOTE_FULOONG2F) += fixup-fl2f.o ops-lm2f.o
+obj-$(CONFIG_LEMOTE_YEELOONG2F) += fixup-yl2f.o ops-lm2f.o
 obj-$(CONFIG_MIPS_MALTA)	+= fixup-malta.o
 obj-$(CONFIG_PMC_MSP7120_GW)	+= fixup-pmcmsp.o ops-pmcmsp.o
 obj-$(CONFIG_PMC_MSP7120_EVAL)	+= fixup-pmcmsp.o ops-pmcmsp.o
diff -Nur linux-2.6.29.1/arch/mips/pci/ops-lm2f.c linux-2.6.29.1-lemote/arch/mips/pci/ops-lm2f.c
--- linux-2.6.29.1/arch/mips/pci/ops-lm2f.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/pci/ops-lm2f.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,205 @@
+/*
+ * ops-lm2f.c
+ *
+ * Copyright (C) 2004 ICT CAS
+ * Author: Li xiaoyu, ICT CAS
+ *   lixy@ict.ac.cn
+ *
+ * Copyright (C) 2007 Lemote, Inc. & Institute of Computing Technology
+ * Author: Fuxin Zhang, zhangfx@lemote.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+
+#include <asm/mips-boards/bonito64.h>
+
+#define	PCI_OPS_CS5536_IDSEL	14
+
+#define PCI_ACCESS_READ  0
+#define PCI_ACCESS_WRITE 1
+
+extern void	cs5536_pci_conf_write4(int function, int reg, u32 value);
+extern u32	cs5536_pci_conf_read4(int function, int reg);
+
+static inline void bflush(void)
+{
+	/* flush Bonito register writes */
+	(void)BONITO_PCICMD;
+}
+
+static int lm2f_pci_config_access(unsigned char access_type,
+				  struct pci_bus *bus, unsigned int devfn,
+				  int where, u32 *data)
+{
+	u32 busnum = bus->number;
+	u32 addr, type;
+	void *addrp;
+	int device = PCI_SLOT(devfn);
+	int function = PCI_FUNC(devfn);
+	int reg = where & ~3;
+	
+	/************************************************************************/
+	/* CS5536 PCI ACCESS ROUTINE :						*/
+	/*	Note the functions circle call :				*/
+	/* lm2e_pci_config_access()--->cs5536_pci_conf_read/write4()--->	*/
+	/* _rdmsr/_wrmsr()--->lm2e_pci_config_access()				*/
+	/************************************************************************/
+	if( (busnum == 0) && (device == PCI_OPS_CS5536_IDSEL) && (reg < 0xF0) ){
+		switch(access_type){
+			case PCI_ACCESS_READ :
+				*data = cs5536_pci_conf_read4(function, reg);
+				break;
+			case PCI_ACCESS_WRITE :
+				cs5536_pci_conf_write4(function, reg, *data);
+				break;
+		}
+		return 0;
+	}
+	
+	if (busnum == 0) {
+		/* Type 0 configuration on onboard PCI bus */
+		if (device > 20 || function > 7) {
+			*data = -1;	/* device out of range */
+			return PCIBIOS_DEVICE_NOT_FOUND;
+		}
+		addr = (1 << (device + 11)) | (function << 8) | reg;
+		type = 0;
+	} else {
+		/* Type 1 configuration on offboard PCI bus */
+		if (device > 31 || function > 7) {
+			*data = -1;	/* device out of range */
+			return PCIBIOS_DEVICE_NOT_FOUND;
+		}
+		addr = (busnum << 16) | (device << 11) | (function << 8) | reg;
+		type = 0x10000;
+	}
+
+	/* clear aborts */
+	BONITO_PCICMD |= BONITO_PCICMD_MABORT_CLR | BONITO_PCICMD_MTABORT_CLR;
+
+	BONITO_PCIMAP_CFG = (addr >> 16) | type;
+	bflush();
+
+	addrp = (void *)CKSEG1ADDR(BONITO_PCICFG_BASE | (addr & 0xffff));
+	if (access_type == PCI_ACCESS_WRITE) {
+		*(volatile unsigned int *)addrp = cpu_to_le32(*data);
+	} else {
+		*data = le32_to_cpu(*(volatile unsigned int *)addrp);
+	}
+
+	/* Detect Master/Target abort */
+	if (BONITO_PCICMD & (BONITO_PCICMD_MABORT_CLR | BONITO_PCICMD_MTABORT_CLR)) {
+		BONITO_PCICMD |= BONITO_PCICMD_MABORT_CLR | BONITO_PCICMD_MTABORT_CLR;
+		*data = -1;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+
+}
+
+static int lm2f_pci_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+				 int where, int size, u32 * val)
+{
+	u32 data = 0;
+
+	int ret = lm2f_pci_config_access(PCI_ACCESS_READ,
+			bus, devfn, where, &data);
+
+	if (ret != PCIBIOS_SUCCESSFUL)
+		return ret;
+
+	if (size == 1)
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+	else if (size == 2)
+		*val = (data >> ((where & 3) << 3)) & 0xffff;
+	else
+		*val = data;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int lm2f_pci_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+				  int where, int size, u32 val)
+{
+	u32 data = 0;
+	int ret;
+
+	if (size == 4)
+		data = val;
+	else {
+		ret = lm2f_pci_config_access(PCI_ACCESS_READ,
+				bus, devfn, where, &data);
+		if (ret != PCIBIOS_SUCCESSFUL)
+			return ret;
+
+		if (size == 1)
+			data = (data & ~(0xff << ((where & 3) << 3))) |
+			    (val << ((where & 3) << 3));
+		else if (size == 2)
+			data = (data & ~(0xffff << ((where & 3) << 3))) |
+			    (val << ((where & 3) << 3));
+	}
+
+	ret = lm2f_pci_config_access(PCI_ACCESS_WRITE,
+			bus, devfn, where, &data);
+	if (ret != PCIBIOS_SUCCESSFUL)
+		return ret;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+void _rdmsr(u32 msr, u32 *hi, u32 *lo)
+{
+	struct pci_bus bus = {
+		.number = 0
+	};
+	u32 devfn = PCI_DEVFN(14, 0);
+	lm2f_pci_pcibios_write(&bus, devfn, 0xf4, 4, msr);
+	lm2f_pci_pcibios_read(&bus, devfn, 0xf8, 4, lo);
+	lm2f_pci_pcibios_read(&bus, devfn, 0xfc, 4, hi);
+	//printk("rdmsr msr %x, lo %x, hi %x\n", msr, *lo, *hi);
+}
+
+void _wrmsr(u32 msr, u32 hi, u32 lo)
+{
+	struct pci_bus bus = {
+		.number = 0
+	};
+	u32 devfn = PCI_DEVFN(14, 0);
+	lm2f_pci_pcibios_write(&bus, devfn, 0xf4, 4, msr);
+	lm2f_pci_pcibios_write(&bus, devfn, 0xf8, 4, lo);
+	lm2f_pci_pcibios_write(&bus, devfn, 0xfc, 4, hi);
+	//printk("wrmsr msr %x, lo %x, hi %x\n", msr, lo, hi); 
+}
+
+EXPORT_SYMBOL(_rdmsr);
+EXPORT_SYMBOL(_wrmsr);
+
+struct pci_ops loongson2f_pci_pci_ops = {
+	.read = lm2f_pci_pcibios_read,
+	.write = lm2f_pci_pcibios_write
+};
diff -Nur linux-2.6.29.1/arch/mips/power/cpu.c linux-2.6.29.1-lemote/arch/mips/power/cpu.c
--- linux-2.6.29.1/arch/mips/power/cpu.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/power/cpu.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,48 @@
+/*
+ * Suspend support specific for mips.
+ *
+ */
+#include <linux/mm.h>
+#include <asm/mipsregs.h>
+#include <asm/page.h>
+#include <asm/suspend.h>
+
+/* References to section boundaries */
+extern const void __nosave_begin, __nosave_end;
+static uint32_t saved_status;
+unsigned long 
+	 saved_ra,
+	 saved_sp,
+	 saved_fp,
+	 saved_gp,
+	 saved_s0,
+	 saved_s1,
+	 saved_s2,
+	 saved_s3,
+	 saved_s4,
+	 saved_s5,
+	 saved_s6,
+	 saved_s7,
+	 saved_a0,
+	 saved_a1,
+	 saved_a2,
+	 saved_a3,
+	 saved_v0,
+	 saved_v1;
+
+void save_processor_state(void)
+{
+	saved_status = read_c0_status();
+}
+
+void restore_processor_state(void)
+{
+	write_c0_status(saved_status);
+}
+
+int pfn_is_nosave(unsigned long pfn)
+{
+ 	unsigned long nosave_begin_pfn = __pa(&__nosave_begin) >> PAGE_SHIFT;
+ 	unsigned long nosave_end_pfn = PAGE_ALIGN(__pa(&__nosave_end)) >> PAGE_SHIFT;
+ 	return (pfn >= nosave_begin_pfn) && (pfn < nosave_end_pfn);
+}
diff -Nur linux-2.6.29.1/arch/mips/power/hibernate.S linux-2.6.29.1-lemote/arch/mips/power/hibernate.S
--- linux-2.6.29.1/arch/mips/power/hibernate.S	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/power/hibernate.S	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,78 @@
+#incldue <linux/linkage.h>
+#include <asm/asm-offsets.h>
+#include <asm/regdef.h>
+#include <asm/asm.h>
+
+.text 
+LEAF(swsusp_arch_suspend)
+	 PTR_LA t0, saved_ra
+	 PTR_S ra, (t0)
+	 PTR_LA t0, saved_sp
+	 PTR_S sp, (t0)
+	 PTR_LA t0, saved_fp
+	 PTR_S fp, (t0)
+	 PTR_LA t0, saved_gp
+	 PTR_S gp, (t0)
+	 PTR_LA t0, saved_s0
+	 PTR_S s0, (t0) 
+	 PTR_LA t0, saved_s1
+	 PTR_S s1, (t0)
+	 PTR_LA t0, saved_s2
+	 PTR_S s2, (t0)
+	 PTR_LA t0, saved_s3
+	 PTR_S s3, (t0)
+	 PTR_LA t0, saved_s4
+	 PTR_S s4, (t0)
+	 PTR_LA t0, saved_s5
+	 PTR_S s5, (t0)
+	 PTR_LA t0, saved_s6
+	 PTR_S s6, (t0)
+	 PTR_LA t0, saved_s7
+	 PTR_S s7, (t0)
+	 PTR_LA t0, saved_a0
+	 PTR_S a0, (t0)
+	 PTR_LA t0, saved_a1
+	 PTR_S a1, (t0)
+	 PTR_LA t0, saved_a2
+	 PTR_S a2, (t0)
+	 PTR_LA t0, saved_v1
+	 PTR_S v1, (t0)
+	 j swsusp_save
+	 nop
+END(swsusp_arch_suspend)
+
+LEAF(swsusp_arch_resume)
+	PTR_L t0, restore_pblist
+0: 
+	PTR_L t1, PBE_ADDRESS(t0)   /* source */
+ 	PTR_L t2, PBE_ORIG_ADDRESS(t0) /* destination */
+ 	PTR_ADDIU t3, t1, _PAGE_SIZE
+1: 
+	REG_L t8, (t1)
+ 	REG_S t8, (t2)
+ 	PTR_ADDIU t1, t1, SZREG
+ 	PTR_ADDIU t2, t2, SZREG
+ 	bne t1, t3, 1b
+ 	PTR_L t0, PBE_NEXT(t0)
+ 	bnez t0, 0b
+	//flush cache and tlb. no need?I am not sure.
+	PTR_L ra, saved_ra
+	PTR_L sp, saved_sp
+	PTR_L fp, saved_fp
+	PTR_L s0, saved_s0
+	PTR_L s1, saved_s1
+	PTR_L s2, saved_s2
+	PTR_L s3, saved_s3
+	PTR_L s4, saved_s4
+	PTR_L s5, saved_s5
+	PTR_L s6, saved_s6
+	PTR_L s7, saved_s7
+	PTR_L a0, saved_a0
+	PTR_L a1, saved_a1
+	PTR_L a2, saved_a2
+	PTR_L a3, saved_a3
+	PTR_LI v0, 0x0 
+	PTR_L v1, saved_v1
+	jr ra
+	nop
+END(swsusp_arch_resume)
diff -Nur linux-2.6.29.1/arch/mips/power/Makefile linux-2.6.29.1-lemote/arch/mips/power/Makefile
--- linux-2.6.29.1/arch/mips/power/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/arch/mips/power/Makefile	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1 @@
+obj-$(CONFIG_HIBERNATION) += cpu.o hibernate.o
diff -Nur linux-2.6.29.1/drivers/ide/amd74xx.c linux-2.6.29.1-lemote/drivers/ide/amd74xx.c
--- linux-2.6.29.1/drivers/ide/amd74xx.c	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/ide/amd74xx.c	2009-04-07 09:39:28.000000000 +0000
@@ -23,6 +23,11 @@
 
 #define DRV_NAME "amd74xx"
 
+static const char *am74xx_quirk_drives[] = {
+	"FUJITSU MHZ2160BH G2",
+	NULL
+};
+
 enum {
 	AMD_IDE_CONFIG		= 0x41,
 	AMD_CABLE_DETECT	= 0x42,
@@ -112,6 +117,20 @@
 	amd_set_drive(drive, XFER_PIO_0 + pio);
 }
 
+static void amd_quirkproc(ide_drive_t *drive, const u8 pio)
+{	
+	const char **list, *m = (char *)&drive->id[ATA_ID_PROD];
+
+	for (list = am74xx_quirk_drives; *list != NULL; list++)
+			if (strstr(m, *list) != NULL) {
+				drive->quirk_list = 2;
+				return;
+			}
+
+	drive->quirk_list = 0;
+	
+}
+
 static void amd7409_cable_detect(struct pci_dev *dev)
 {
 	/* no host side cable detection */
@@ -194,6 +213,7 @@
 static const struct ide_port_ops amd_port_ops = {
 	.set_pio_mode		= amd_set_pio_mode,
 	.set_dma_mode		= amd_set_drive,
+	.quirkproc			= amd_quirkproc,
 	.cable_detect		= amd_cable_detect,
 };
 
diff -Nur linux-2.6.29.1/drivers/net/Kconfig linux-2.6.29.1-lemote/drivers/net/Kconfig
--- linux-2.6.29.1/drivers/net/Kconfig	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/net/Kconfig	2009-04-07 09:39:28.000000000 +0000
@@ -2321,6 +2321,13 @@
 	  Some boards that use the Discovery chipset are the Momenco
 	  Ocelot C and Jaguar ATX and Pegasos II.
 
+config TITAN_GE
+	bool "PMC-Sierra TITAN Gigabit Ethernet Support"
+	depends on PMC_YOSEMITE
+	help
+	  This enables support for the the integrated ethernet of
+	  PMC-Sierra's Titan SoC.
+
 config QLA3XXX
 	tristate "QLogic QLA3XXX Network Driver Support"
 	depends on PCI
diff -Nur linux-2.6.29.1/drivers/net/Makefile linux-2.6.29.1-lemote/drivers/net/Makefile
--- linux-2.6.29.1/drivers/net/Makefile	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/net/Makefile	2009-04-07 09:39:28.000000000 +0000
@@ -135,6 +135,8 @@
 obj-$(CONFIG_QLA3XXX) += qla3xxx.o
 obj-$(CONFIG_QLGE) += qlge/
 
+obj-$(CONFIG_TITAN_GE) += titan_mdio.o titan_ge.o
+
 obj-$(CONFIG_PPP) += ppp_generic.o
 obj-$(CONFIG_PPP_ASYNC) += ppp_async.o
 obj-$(CONFIG_PPP_SYNC_TTY) += ppp_synctty.o
diff -Nur linux-2.6.29.1/drivers/net/titan_ge.c linux-2.6.29.1-lemote/drivers/net/titan_ge.c
--- linux-2.6.29.1/drivers/net/titan_ge.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/net/titan_ge.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,2069 @@
+/*
+ * drivers/net/titan_ge.c - Driver for Titan ethernet ports
+ *
+ * Copyright (C) 2003 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * The MAC unit of the Titan consists of the following:
+ *
+ * -> XDMA Engine to move data to from the memory to the MAC packet FIFO
+ * -> FIFO is where the incoming and outgoing data is placed
+ * -> TRTG is the unit that pulls the data from the FIFO for Tx and pushes
+ *    the data into the FIFO for Rx
+ * -> TMAC is the outgoing MAC interface and RMAC is the incoming.
+ * -> AFX is the address filtering block
+ * -> GMII block to communicate with the PHY
+ *
+ * Rx will look like the following:
+ * GMII --> RMAC --> AFX --> TRTG --> Rx FIFO --> XDMA --> CPU memory
+ *
+ * Tx will look like the following:
+ * CPU memory --> XDMA --> Tx FIFO --> TRTG --> TMAC --> GMII
+ *
+ * The Titan driver has support for the following performance features:
+ * -> Rx side checksumming
+ * -> Jumbo Frames
+ * -> Interrupt Coalscing
+ * -> Rx NAPI
+ * -> SKB Recycling
+ * -> Transmit/Receive descriptors in SRAM
+ * -> Fast routing for IP forwarding
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/ip.h>
+#include <linux/init.h>
+#include <linux/in.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/delay.h>
+#include <linux/skbuff.h>
+#include <linux/prefetch.h>
+
+/* For MII specifc registers, titan_mdio.h should be included */
+#include <net/ip.h>
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+#include <asm/titan_dep.h>
+
+#include "titan_ge.h"
+#include "titan_mdio.h"
+
+/* Static Function Declarations	 */
+static int titan_ge_eth_open(struct net_device *);
+static void titan_ge_eth_stop(struct net_device *);
+static struct net_device_stats *titan_ge_get_stats(struct net_device *);
+static int titan_ge_init_rx_desc_ring(titan_ge_port_info *, int, int,
+				      unsigned long, unsigned long,
+				      unsigned long);
+static int titan_ge_init_tx_desc_ring(titan_ge_port_info *, int,
+				      unsigned long, unsigned long);
+
+static int titan_ge_open(struct net_device *);
+static int titan_ge_start_xmit(struct sk_buff *, struct net_device *);
+static int titan_ge_stop(struct net_device *);
+
+static unsigned long titan_ge_tx_coal(unsigned long, int);
+
+static void titan_ge_port_reset(unsigned int);
+static int titan_ge_free_tx_queue(titan_ge_port_info *);
+static int titan_ge_rx_task(struct net_device *, titan_ge_port_info *);
+static int titan_ge_port_start(struct net_device *, titan_ge_port_info *);
+
+static int titan_ge_return_tx_desc(titan_ge_port_info *, int);
+
+/*
+ * Some configuration for the FIFO and the XDMA channel needs
+ * to be done only once for all the ports. This flag controls
+ * that
+ */
+static unsigned long config_done;
+
+/*
+ * One time out of memory flag
+ */
+static unsigned int oom_flag;
+
+static int titan_ge_poll(struct net_device *netdev, int *budget);
+
+static int titan_ge_receive_queue(struct net_device *, unsigned int);
+
+static struct platform_device *titan_ge_device[3];
+
+/* MAC Address */
+extern unsigned char titan_ge_mac_addr_base[6];
+
+unsigned long titan_ge_base;
+static unsigned long titan_ge_sram;
+
+static char titan_string[] = "titan";
+
+/*
+ * The Titan GE has two alignment requirements:
+ * -> skb->data to be cacheline aligned (32 byte)
+ * -> IP header alignment to 16 bytes
+ *
+ * The latter is not implemented. So, that results in an extra copy on
+ * the Rx. This is a big performance hog. For the former case, the
+ * dev_alloc_skb() has been replaced with titan_ge_alloc_skb(). The size
+ * requested is calculated:
+ *
+ * Ethernet Frame Size : 1518
+ * Ethernet Header     : 14
+ * Future Titan change for IP header alignment : 2
+ *
+ * Hence, we allocate (1518 + 14 + 2+ 64) = 1580 bytes.  For IP header
+ * alignment, we use skb_reserve().
+ */
+
+#define ALIGNED_RX_SKB_ADDR(addr) \
+	((((unsigned long)(addr) + (64UL - 1UL)) \
+	& ~(64UL - 1UL)) - (unsigned long)(addr))
+
+#define titan_ge_alloc_skb(__length, __gfp_flags) \
+({      struct sk_buff *__skb; \
+	__skb = alloc_skb((__length) + 64, (__gfp_flags)); \
+	if(__skb) { \
+		int __offset = (int) ALIGNED_RX_SKB_ADDR(__skb->data); \
+		if(__offset) \
+			skb_reserve(__skb, __offset); \
+	} \
+	__skb; \
+})
+
+/*
+ * Configure the GMII block of the Titan based on what the PHY tells us
+ */
+static void titan_ge_gmii_config(int port_num)
+{
+	unsigned int reg_data = 0, phy_reg;
+	int err;
+
+	err = titan_ge_mdio_read(port_num, TITAN_GE_MDIO_PHY_STATUS, &phy_reg);
+
+	if (err == TITAN_GE_MDIO_ERROR) {
+		printk(KERN_ERR
+		       "Could not read PHY control register 0x11 \n");
+		printk(KERN_ERR
+			"Setting speed to 1000 Mbps and Duplex to Full \n");
+
+		return;
+	}
+
+	err = titan_ge_mdio_write(port_num, TITAN_GE_MDIO_PHY_IE, 0);
+
+	if (phy_reg & 0x8000) {
+		if (phy_reg & 0x2000) {
+			/* Full Duplex and 1000 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x201);
+		}  else {
+			/* Half Duplex and 1000 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x2201);
+			}
+	}
+	if (phy_reg & 0x4000) {
+		if (phy_reg & 0x2000) {
+			/* Full Duplex and 100 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x100);
+		} else {
+			/* Half Duplex and 100 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x2100);
+		}
+	}
+	reg_data = TITAN_GE_READ(TITAN_GE_GMII_CONFIG_GENERAL +
+				(port_num << 12));
+	reg_data |= 0x3;
+	TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_GENERAL +
+			(port_num << 12)), reg_data);
+}
+
+/*
+ * Enable the TMAC if it is not
+ */
+static void titan_ge_enable_tx(unsigned int port_num)
+{
+	unsigned long reg_data;
+
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 + (port_num << 12));
+	if (!(reg_data & 0x8000)) {
+		printk("TMAC disabled for port %d!! \n", port_num);
+
+		reg_data |= 0x0001;	/* Enable TMAC */
+		reg_data |= 0x4000;	/* CRC Check Enable */
+		reg_data |= 0x2000;	/* Padding enable */
+		reg_data |= 0x0800;	/* CRC Add enable */
+		reg_data |= 0x0080;	/* PAUSE frame */
+
+		TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
+				(port_num << 12)), reg_data);
+	}
+}
+
+/*
+ * Tx Timeout function
+ */
+static void titan_ge_tx_timeout(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+
+	printk(KERN_INFO "%s: TX timeout  ", netdev->name);
+	printk(KERN_INFO "Resetting card \n");
+
+	/* Do the reset outside of interrupt context */
+	schedule_work(&titan_ge_eth->tx_timeout_task);
+}
+
+/*
+ * Update the AFX tables for UC and MC for slice 0 only
+ */
+static void titan_ge_update_afx(titan_ge_port_info * titan_ge_eth)
+{
+	int port = titan_ge_eth->port_num;
+	unsigned int i;
+	volatile unsigned long reg_data = 0;
+	u8 p_addr[6];
+
+	memcpy(p_addr, titan_ge_eth->port_mac_addr, 6);
+
+	/* Set the MAC address here for TMAC and RMAC */
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_HI + (port << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_MID + (port << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_LOW + (port << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_HI + (port << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_MID + (port << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_LOW + (port << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+
+	TITAN_GE_WRITE((0x112c | (port << 12)), 0x1);
+	/* Configure the eight address filters */
+	for (i = 0; i < 8; i++) {
+		/* Select each of the eight filters */
+		TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_2 +
+				(port << 12)), i);
+
+		/* Configure the match */
+		reg_data = 0x9;	/* Forward Enable Bit */
+		TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_0 +
+				(port << 12)), reg_data);
+
+		/* Finally, AFX Exact Match Address Registers */
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_LOW + (port << 12)),
+			       ((p_addr[1] << 8) | p_addr[0]));
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_MID + (port << 12)),
+			       ((p_addr[3] << 8) | p_addr[2]));
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_HIGH + (port << 12)),
+			       ((p_addr[5] << 8) | p_addr[4]));
+
+		/* VLAN id set to 0 */
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_VID +
+				(port << 12)), 0);
+	}
+}
+
+/*
+ * Actual Routine to reset the adapter when the timeout occurred
+ */
+static void titan_ge_tx_timeout_task(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	int port = titan_ge_eth->port_num;
+
+	printk("Titan GE: Transmit timed out. Resetting ... \n");
+
+	/* Dump debug info */
+	printk(KERN_ERR "TRTG cause : %x \n",
+			TITAN_GE_READ(0x100c + (port << 12)));
+
+	/* Fix this for the other ports */
+	printk(KERN_ERR "FIFO cause : %x \n", TITAN_GE_READ(0x482c));
+	printk(KERN_ERR "IE cause : %x \n", TITAN_GE_READ(0x0040));
+	printk(KERN_ERR "XDMA GDI ERROR : %x \n",
+			TITAN_GE_READ(0x5008 + (port << 8)));
+	printk(KERN_ERR "CHANNEL ERROR: %x \n",
+			TITAN_GE_READ(TITAN_GE_CHANNEL0_INTERRUPT
+						+ (port << 8)));
+
+	netif_device_detach(netdev);
+	titan_ge_port_reset(titan_ge_eth->port_num);
+	titan_ge_port_start(netdev, titan_ge_eth);
+	netif_device_attach(netdev);
+}
+
+/*
+ * Change the MTU of the Ethernet Device
+ */
+static int titan_ge_change_mtu(struct net_device *netdev, int new_mtu)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned long flags;
+
+	if ((new_mtu > 9500) || (new_mtu < 64))
+		return -EINVAL;
+
+	spin_lock_irqsave(&titan_ge_eth->lock, flags);
+
+	netdev->mtu = new_mtu;
+
+	/* Now we have to reopen the interface so that SKBs with the new
+	 * size will be allocated */
+
+	if (netif_running(netdev)) {
+		titan_ge_eth_stop(netdev);
+
+		if (titan_ge_eth_open(netdev) != TITAN_OK) {
+			printk(KERN_ERR
+			       "%s: Fatal error on opening device\n",
+			       netdev->name);
+			spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+			return -1;
+		}
+	}
+
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+	return 0;
+}
+
+/*
+ * Titan Gbe Interrupt Handler. All the three ports send interrupt to one line
+ * only. Once an interrupt is triggered, figure out the port and then check
+ * the channel.
+ */
+static irqreturn_t titan_ge_int_handler(int irq, void *dev_id)
+{
+	struct net_device *netdev = (struct net_device *) dev_id;
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned int reg_data;
+	unsigned int eth_int_cause_error = 0, is;
+	unsigned long eth_int_cause1;
+	int err = 0;
+#ifdef CONFIG_SMP
+	unsigned long eth_int_cause2;
+#endif
+
+	/* Ack the CPU interrupt */
+	switch (port_num) {
+	case 0:
+		is = OCD_READ(RM9000x2_OCD_INTP0STATUS1);
+		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR1, is);
+
+#ifdef CONFIG_SMP
+		is = OCD_READ(RM9000x2_OCD_INTP1STATUS1);
+		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR1, is);
+#endif
+		break;
+
+	case 1:
+		is = OCD_READ(RM9000x2_OCD_INTP0STATUS0);
+		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR0, is);
+
+#ifdef CONFIG_SMP
+		is = OCD_READ(RM9000x2_OCD_INTP1STATUS0);
+		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR0, is);
+#endif
+		break;
+
+	case 2:
+		is = OCD_READ(RM9000x2_OCD_INTP0STATUS4);
+		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR4, is);
+
+#ifdef CONFIG_SMP
+		is = OCD_READ(RM9000x2_OCD_INTP1STATUS4);
+		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR4, is);
+#endif
+	}
+
+	eth_int_cause1 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_A);
+#ifdef CONFIG_SMP
+	eth_int_cause2 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_B);
+#endif
+
+	/* Spurious interrupt */
+#ifdef CONFIG_SMP
+	if ( (eth_int_cause1 == 0) && (eth_int_cause2 == 0)) {
+#else
+	if (eth_int_cause1 == 0) {
+#endif
+		eth_int_cause_error = TITAN_GE_READ(TITAN_GE_CHANNEL0_INTERRUPT +
+					(port_num << 8));
+
+		if (eth_int_cause_error == 0)
+			return IRQ_NONE;
+	}
+
+	/* Handle Tx first. No need to ack interrupts */
+#ifdef CONFIG_SMP
+	if ( (eth_int_cause1 & 0x20202) ||
+		(eth_int_cause2 & 0x20202) )
+#else
+	if (eth_int_cause1 & 0x20202)
+#endif
+		titan_ge_free_tx_queue(titan_ge_eth);
+
+	/* Handle the Rx next */
+#ifdef CONFIG_SMP
+	if ( (eth_int_cause1 & 0x10101) ||
+		(eth_int_cause2 & 0x10101)) {
+#else
+	if (eth_int_cause1 & 0x10101) {
+#endif
+		if (netif_rx_schedule_prep(netdev)) {
+			unsigned int ack;
+
+			ack = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
+			/* Disable Tx and Rx both */
+			if (port_num == 0)
+				ack &= ~(0x3);
+			if (port_num == 1)
+				ack &= ~(0x300);
+
+			if (port_num == 2)
+				ack &= ~(0x30000);
+
+			/* Interrupts have been disabled */
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, ack);
+
+			__netif_rx_schedule(netdev);
+		}
+	}
+
+	/* Handle error interrupts */
+	if (eth_int_cause_error && (eth_int_cause_error != 0x2)) {
+		printk(KERN_ERR
+			"XDMA Channel Error : %x  on port %d\n",
+			eth_int_cause_error, port_num);
+
+		printk(KERN_ERR
+			"XDMA GDI Hardware error : %x  on port %d\n",
+			TITAN_GE_READ(0x5008 + (port_num << 8)), port_num);
+
+		printk(KERN_ERR
+			"XDMA currently has %d Rx descriptors \n",
+			TITAN_GE_READ(0x5048 + (port_num << 8)));
+
+		printk(KERN_ERR
+			"XDMA currently has prefetcted %d Rx descriptors \n",
+			TITAN_GE_READ(0x505c + (port_num << 8)));
+
+		TITAN_GE_WRITE((TITAN_GE_CHANNEL0_INTERRUPT +
+			       (port_num << 8)), eth_int_cause_error);
+	}
+
+	/*
+	 * PHY interrupt to inform abt the changes. Reading the
+	 * PHY Status register will clear the interrupt
+	 */
+	if ((!(eth_int_cause1 & 0x30303)) &&
+		(eth_int_cause_error == 0)) {
+		err =
+		    titan_ge_mdio_read(port_num,
+			       TITAN_GE_MDIO_PHY_IS, &reg_data);
+
+		if (reg_data & 0x0400) {
+			/* Link status change */
+			titan_ge_mdio_read(port_num,
+				   TITAN_GE_MDIO_PHY_STATUS, &reg_data);
+			if (!(reg_data & 0x0400)) {
+				/* Link is down */
+				netif_carrier_off(netdev);
+				netif_stop_queue(netdev);
+			} else {
+				/* Link is up */
+				netif_carrier_on(netdev);
+				netif_wake_queue(netdev);
+
+				/* Enable the queue */
+				titan_ge_enable_tx(port_num);
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Multicast and Promiscuous mode set. The
+ * set_multi entry point is called whenever the
+ * multicast address list or the network interface
+ * flags are updated.
+ */
+static void titan_ge_set_multi(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned long reg_data;
+
+	reg_data = TITAN_GE_READ(TITAN_GE_AFX_ADDRS_FILTER_CTRL_1 +
+				(port_num << 12));
+
+	if (netdev->flags & IFF_PROMISC) {
+		reg_data |= 0x2;
+	}
+	else if (netdev->flags & IFF_ALLMULTI) {
+		reg_data |= 0x01;
+		reg_data |= 0x400; /* Use the 64-bit Multicast Hash bin */
+	}
+	else {
+		reg_data = 0x2;
+	}
+
+	TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_1 +
+			(port_num << 12)), reg_data);
+	if (reg_data & 0x01) {
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_LOW +
+				(port_num << 12)), 0xffff);
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_MIDLOW +
+				(port_num << 12)), 0xffff);
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_MIDHI +
+				(port_num << 12)), 0xffff);
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_HI +
+				(port_num << 12)), 0xffff);
+	}
+}
+
+/*
+ * Open the network device
+ */
+static int titan_ge_open(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned int irq = TITAN_ETH_PORT_IRQ - port_num;
+	int retval;
+
+	retval = request_irq(irq, titan_ge_int_handler,
+		     SA_INTERRUPT | SA_SAMPLE_RANDOM , netdev->name, netdev);
+
+	if (retval != 0) {
+		printk(KERN_ERR "Cannot assign IRQ number to TITAN GE \n");
+		return -1;
+	}
+
+	netdev->irq = irq;
+	printk(KERN_INFO "Assigned IRQ %d to port %d\n", irq, port_num);
+
+	spin_lock_irq(&(titan_ge_eth->lock));
+
+	if (titan_ge_eth_open(netdev) != TITAN_OK) {
+		spin_unlock_irq(&(titan_ge_eth->lock));
+		printk("%s: Error opening interface \n", netdev->name);
+		free_irq(netdev->irq, netdev);
+		return -EBUSY;
+	}
+
+	spin_unlock_irq(&(titan_ge_eth->lock));
+
+	return 0;
+}
+
+/*
+ * Allocate the SKBs for the Rx ring. Also used
+ * for refilling the queue
+ */
+static int titan_ge_rx_task(struct net_device *netdev,
+				titan_ge_port_info *titan_ge_port)
+{
+	struct device *device = &titan_ge_device[titan_ge_port->port_num]->dev;
+	volatile titan_ge_rx_desc *rx_desc;
+	struct sk_buff *skb;
+	int rx_used_desc;
+	int count = 0;
+
+	while (titan_ge_port->rx_ring_skbs < titan_ge_port->rx_ring_size) {
+
+	/* First try to get the skb from the recycler */
+#ifdef TITAN_GE_JUMBO_FRAMES
+		skb = titan_ge_alloc_skb(TITAN_GE_JUMBO_BUFSIZE, GFP_ATOMIC);
+#else
+		skb = titan_ge_alloc_skb(TITAN_GE_STD_BUFSIZE, GFP_ATOMIC);
+#endif
+		if (unlikely(!skb)) {
+			/* OOM, set the flag */
+			printk("OOM \n");
+			oom_flag = 1;
+			break;
+		}
+		count++;
+		skb->dev = netdev;
+
+		titan_ge_port->rx_ring_skbs++;
+
+		rx_used_desc = titan_ge_port->rx_used_desc_q;
+		rx_desc = &(titan_ge_port->rx_desc_area[rx_used_desc]);
+
+#ifdef TITAN_GE_JUMBO_FRAMES
+		rx_desc->buffer_addr = dma_map_single(device, skb->data,
+				TITAN_GE_JUMBO_BUFSIZE - 2, DMA_FROM_DEVICE);
+#else
+		rx_desc->buffer_addr = dma_map_single(device, skb->data,
+				TITAN_GE_STD_BUFSIZE - 2, DMA_FROM_DEVICE);
+#endif
+
+		titan_ge_port->rx_skb[rx_used_desc] = skb;
+		rx_desc->cmd_sts = TITAN_GE_RX_BUFFER_OWNED;
+
+		titan_ge_port->rx_used_desc_q =
+			(rx_used_desc + 1) % TITAN_GE_RX_QUEUE;
+	}
+
+	return count;
+}
+
+/*
+ * Actual init of the Tital GE port. There is one register for
+ * the channel configuration
+ */
+static void titan_port_init(struct net_device *netdev,
+			    titan_ge_port_info * titan_ge_eth)
+{
+	unsigned long reg_data;
+
+	titan_ge_port_reset(titan_ge_eth->port_num);
+
+	/* First reset the TMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data |= 0x80000000;
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+
+	udelay(30);
+
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data &= ~(0xc0000000);
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+
+	/* Now reset the RMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data |= 0x00080000;
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+
+	udelay(30);
+
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data &= ~(0x000c0000);
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+}
+
+/*
+ * Start the port. All the hardware specific configuration
+ * for the XDMA, Tx FIFO, Rx FIFO, TMAC, RMAC, TRTG and AFX
+ * go here
+ */
+static int titan_ge_port_start(struct net_device *netdev,
+				titan_ge_port_info * titan_port)
+{
+	volatile unsigned long reg_data, reg_data1;
+	int port_num = titan_port->port_num;
+	int count = 0;
+	unsigned long reg_data_1;
+
+	if (config_done == 0) {
+		reg_data = TITAN_GE_READ(0x0004);
+		reg_data |= 0x100;
+		TITAN_GE_WRITE(0x0004, reg_data);
+
+		reg_data &= ~(0x100);
+		TITAN_GE_WRITE(0x0004, reg_data);
+
+		/* Turn on GMII/MII mode and turn off TBI mode */
+		reg_data = TITAN_GE_READ(TITAN_GE_TSB_CTRL_1);
+		reg_data |= 0x00000700;
+		reg_data &= ~(0x00800000); /* Fencing */
+
+		TITAN_GE_WRITE(0x000c, 0x00001100);
+
+		TITAN_GE_WRITE(TITAN_GE_TSB_CTRL_1, reg_data);
+
+		/* Set the CPU Resource Limit register */
+		TITAN_GE_WRITE(0x00f8, 0x8);
+
+		/* Be conservative when using the BIU buffers */
+		TITAN_GE_WRITE(0x0068, 0x4);
+	}
+
+	titan_port->tx_threshold = 0;
+	titan_port->rx_threshold = 0;
+
+	/* We need to write the descriptors for Tx and Rx */
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_TX_DESC + (port_num << 8)),
+		       (unsigned long) titan_port->tx_dma);
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_RX_DESC + (port_num << 8)),
+		       (unsigned long) titan_port->rx_dma);
+
+	if (config_done == 0) {
+		/* Step 1:  XDMA config	*/
+		reg_data = TITAN_GE_READ(TITAN_GE_XDMA_CONFIG);
+		reg_data &= ~(0x80000000);      /* clear reset */
+		reg_data |= 0x1 << 29;	/* sparse tx descriptor spacing */
+		reg_data |= 0x1 << 28;	/* sparse rx descriptor spacing */
+		reg_data |= (0x1 << 23) | (0x1 << 24);  /* Descriptor Coherency */
+		reg_data |= (0x1 << 21) | (0x1 << 22);  /* Data Coherency */
+		TITAN_GE_WRITE(TITAN_GE_XDMA_CONFIG, reg_data);
+	}
+
+	/* IR register for the XDMA */
+	reg_data = TITAN_GE_READ(TITAN_GE_GDI_INTERRUPT_ENABLE + (port_num << 8));
+	reg_data |= 0x80068000; /* No Rx_OOD */
+	TITAN_GE_WRITE((TITAN_GE_GDI_INTERRUPT_ENABLE + (port_num << 8)), reg_data);
+
+	/* Start the Tx and Rx XDMA controller */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG + (port_num << 8));
+	reg_data &= 0x4fffffff;     /* Clear tx reset */
+	reg_data &= 0xfff4ffff;     /* Clear rx reset */
+
+#ifdef TITAN_GE_JUMBO_FRAMES
+	reg_data |= 0xa0 | 0x30030000;
+#else
+	reg_data |= 0x40 | 0x20030000;
+#endif
+
+#ifndef CONFIG_SMP
+	reg_data &= ~(0x10);
+	reg_data |= 0x0f; /* All of the packet */
+#endif
+
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG + (port_num << 8)), reg_data);
+
+	/* Rx desc count */
+	count = titan_ge_rx_task(netdev, titan_port);
+	TITAN_GE_WRITE((0x5048 + (port_num << 8)), count);
+	count = TITAN_GE_READ(0x5048 + (port_num << 8));
+
+	udelay(30);
+
+	/*
+	 * Step 2:  Configure the SDQPF, i.e. FIFO
+	 */
+	if (config_done == 0) {
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_CTL);
+		reg_data = 0x1;
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
+		reg_data &= ~(0x1);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_CTL);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
+
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_CTL);
+		reg_data = 0x1;
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
+		reg_data &= ~(0x1);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_CTL);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
+	}
+	/*
+	 * Enable RX FIFO 0, 4 and 8
+	 */
+	if (port_num == 0) {
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_0);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10);
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_0, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4844);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x4844, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_0, reg_data);
+
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_0);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
+
+		reg_data |= (0xff << 10);
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4944);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x4944, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
+
+	}
+
+	if (port_num == 1) {
+		reg_data = TITAN_GE_READ(0x4870);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10) | (0xff + 1);
+
+		TITAN_GE_WRITE(0x4870, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4874);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x4874, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x4870, reg_data);
+
+		reg_data = TITAN_GE_READ(0x494c);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(0x494c, reg_data);
+		reg_data |= (0xff << 10) | (0xff + 1);
+		TITAN_GE_WRITE(0x494c, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4950);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x4950, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x494c, reg_data);
+	}
+
+	/*
+	 * Titan 1.2 revision does support port #2
+	 */
+	if (port_num == 2) {
+		/*
+		 * Put the descriptors in the SRAM
+		 */
+		reg_data = TITAN_GE_READ(0x48a0);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x48a4);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x48a4, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+
+		reg_data = TITAN_GE_READ(0x4958);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+		TITAN_GE_WRITE(0x4958, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x495c);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x495c, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+	}
+
+	if (port_num == 2) {
+		reg_data = TITAN_GE_READ(0x48a0);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x48a4);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x48a4, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+
+		reg_data = TITAN_GE_READ(0x4958);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+		TITAN_GE_WRITE(0x4958, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x495c);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x495c, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+	}
+
+	/*
+	 * Step 3:  TRTG block enable
+	 */
+	reg_data = TITAN_GE_READ(TITAN_GE_TRTG_CONFIG + (port_num << 12));
+
+	/*
+	 * This is the 1.2 revision of the chip. It has fix for the
+	 * IP header alignment. Now, the IP header begins at an
+	 * aligned address and this wont need an extra copy in the
+	 * driver. This performance drawback existed in the previous
+	 * versions of the silicon
+	 */
+	reg_data_1 = TITAN_GE_READ(0x103c + (port_num << 12));
+	reg_data_1 |= 0x40000000;
+	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
+
+	reg_data_1 |= 0x04000000;
+	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
+
+	mdelay(5);
+
+	reg_data_1 &= ~(0x04000000);
+	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
+
+	mdelay(5);
+
+	reg_data |= 0x0001;
+	TITAN_GE_WRITE((TITAN_GE_TRTG_CONFIG + (port_num << 12)), reg_data);
+
+	/*
+	 * Step 4:  Start the Tx activity
+	 */
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_2 + (port_num << 12)), 0xe197);
+#ifdef TITAN_GE_JUMBO_FRAMES
+	TITAN_GE_WRITE((0x1258 + (port_num << 12)), 0x4000);
+#endif
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 + (port_num << 12));
+	reg_data |= 0x0001;	/* Enable TMAC */
+	reg_data |= 0x6c70;	/* PAUSE also set */
+
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 + (port_num << 12)), reg_data);
+
+	udelay(30);
+
+	/* Destination Address drop bit */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_2 + (port_num << 12));
+	reg_data |= 0x218;        /* DA_DROP bit and pause */
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_2 + (port_num << 12)), reg_data);
+
+	TITAN_GE_WRITE((0x1218 + (port_num << 12)), 0x3);
+
+#ifdef TITAN_GE_JUMBO_FRAMES
+	TITAN_GE_WRITE((0x1208 + (port_num << 12)), 0x4000);
+#endif
+	/* Start the Rx activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 + (port_num << 12));
+	reg_data |= 0x0001;	/* RMAC Enable */
+	reg_data |= 0x0010;	/* CRC Check enable */
+	reg_data |= 0x0040;	/* Min Frame check enable */
+	reg_data |= 0x4400;	/* Max Frame check enable */
+
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 + (port_num << 12)), reg_data);
+
+	udelay(30);
+
+	/*
+	 * Enable the Interrupts for Tx and Rx
+	 */
+	reg_data1 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
+
+	if (port_num == 0) {
+		reg_data1 |= 0x3;
+#ifdef CONFIG_SMP
+		TITAN_GE_WRITE(0x0038, 0x003);
+#else
+		TITAN_GE_WRITE(0x0038, 0x303);
+#endif
+	}
+
+	if (port_num == 1) {
+		reg_data1 |= 0x300;
+	}
+
+	if (port_num == 2)
+		reg_data1 |= 0x30000;
+
+	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, reg_data1);
+	TITAN_GE_WRITE(0x003c, 0x300);
+
+	if (config_done == 0) {
+		TITAN_GE_WRITE(0x0024, 0x04000024);	/* IRQ vector */
+		TITAN_GE_WRITE(0x0020, 0x000fb000);	/* INTMSG base */
+	}
+
+	/* Priority */
+	reg_data = TITAN_GE_READ(0x1038 + (port_num << 12));
+	reg_data &= ~(0x00f00000);
+	TITAN_GE_WRITE((0x1038 + (port_num << 12)), reg_data);
+
+	/* Step 5:  GMII config */
+	titan_ge_gmii_config(port_num);
+
+	if (config_done == 0) {
+		TITAN_GE_WRITE(0x1a80, 0);
+		config_done = 1;
+	}
+
+	return TITAN_OK;
+}
+
+/*
+ * Function to queue the packet for the Ethernet device
+ */
+static void titan_ge_tx_queue(titan_ge_port_info * titan_ge_eth,
+				struct sk_buff * skb)
+{
+	struct device *device = &titan_ge_device[titan_ge_eth->port_num]->dev;
+	unsigned int curr_desc = titan_ge_eth->tx_curr_desc_q;
+	volatile titan_ge_tx_desc *tx_curr;
+	int port_num = titan_ge_eth->port_num;
+
+	tx_curr = &(titan_ge_eth->tx_desc_area[curr_desc]);
+	tx_curr->buffer_addr =
+		dma_map_single(device, skb->data, skb_headlen(skb),
+			       DMA_TO_DEVICE);
+
+	titan_ge_eth->tx_skb[curr_desc] = (struct sk_buff *) skb;
+	tx_curr->buffer_len = skb_headlen(skb);
+
+	/* Last descriptor enables interrupt and changes ownership */
+	tx_curr->cmd_sts = 0x1 | (1 << 15) | (1 << 5);
+
+	/* Kick the XDMA to start the transfer from memory to the FIFO */
+	TITAN_GE_WRITE((0x5044 + (port_num << 8)), 0x1);
+
+	/* Current descriptor updated */
+	titan_ge_eth->tx_curr_desc_q = (curr_desc + 1) % TITAN_GE_TX_QUEUE;
+
+	/* Prefetch the next descriptor */
+	prefetch((const void *)
+		 &titan_ge_eth->tx_desc_area[titan_ge_eth->tx_curr_desc_q]);
+}
+
+/*
+ * Actually does the open of the Ethernet device
+ */
+static int titan_ge_eth_open(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	struct device *device = &titan_ge_device[port_num]->dev;
+	unsigned long reg_data;
+	unsigned int phy_reg;
+	int err = 0;
+
+	/* Stop the Rx activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 + (port_num << 12));
+	reg_data &= ~(0x00000001);
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 + (port_num << 12)), reg_data);
+
+	/* Clear the port interrupts */
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_INTERRUPT + (port_num << 8)), 0x0);
+
+	if (config_done == 0) {
+		TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0);
+		TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_B, 0);
+	}
+
+	/* Set the MAC Address */
+	memcpy(titan_ge_eth->port_mac_addr, netdev->dev_addr, 6);
+
+	if (config_done == 0)
+		titan_port_init(netdev, titan_ge_eth);
+
+	titan_ge_update_afx(titan_ge_eth);
+
+	/* Allocate the Tx ring now */
+	titan_ge_eth->tx_ring_skbs = 0;
+	titan_ge_eth->tx_ring_size = TITAN_GE_TX_QUEUE;
+
+	/* Allocate space in the SRAM for the descriptors */
+	titan_ge_eth->tx_desc_area = (titan_ge_tx_desc *)
+		(titan_ge_sram + TITAN_TX_RING_BYTES * port_num);
+	titan_ge_eth->tx_dma = TITAN_SRAM_BASE + TITAN_TX_RING_BYTES * port_num;
+
+	if (!titan_ge_eth->tx_desc_area) {
+		printk(KERN_ERR
+		       "%s: Cannot allocate Tx Ring (size %d bytes) for port %d\n",
+		       netdev->name, TITAN_TX_RING_BYTES, port_num);
+		return -ENOMEM;
+	}
+
+	memset(titan_ge_eth->tx_desc_area, 0, titan_ge_eth->tx_desc_area_size);
+
+	/* Now initialize the Tx descriptor ring */
+	titan_ge_init_tx_desc_ring(titan_ge_eth,
+				   titan_ge_eth->tx_ring_size,
+				   (unsigned long) titan_ge_eth->tx_desc_area,
+				   (unsigned long) titan_ge_eth->tx_dma);
+
+	/* Allocate the Rx ring now */
+	titan_ge_eth->rx_ring_size = TITAN_GE_RX_QUEUE;
+	titan_ge_eth->rx_ring_skbs = 0;
+
+	titan_ge_eth->rx_desc_area =
+		(titan_ge_rx_desc *)(titan_ge_sram + 0x1000 + TITAN_RX_RING_BYTES * port_num);
+
+	titan_ge_eth->rx_dma = TITAN_SRAM_BASE + 0x1000 + TITAN_RX_RING_BYTES * port_num;
+
+	if (!titan_ge_eth->rx_desc_area) {
+		printk(KERN_ERR "%s: Cannot allocate Rx Ring (size %d bytes)\n",
+		       netdev->name, TITAN_RX_RING_BYTES);
+
+		printk(KERN_ERR "%s: Freeing previously allocated TX queues...",
+		       netdev->name);
+
+		dma_free_coherent(device, titan_ge_eth->tx_desc_area_size,
+				    (void *) titan_ge_eth->tx_desc_area,
+				    titan_ge_eth->tx_dma);
+
+		return -ENOMEM;
+	}
+
+	memset(titan_ge_eth->rx_desc_area, 0, titan_ge_eth->rx_desc_area_size);
+
+	/* Now initialize the Rx ring */
+#ifdef TITAN_GE_JUMBO_FRAMES
+	if ((titan_ge_init_rx_desc_ring
+	    (titan_ge_eth, titan_ge_eth->rx_ring_size, TITAN_GE_JUMBO_BUFSIZE,
+	     (unsigned long) titan_ge_eth->rx_desc_area, 0,
+	      (unsigned long) titan_ge_eth->rx_dma)) == 0)
+#else
+	if ((titan_ge_init_rx_desc_ring
+	     (titan_ge_eth, titan_ge_eth->rx_ring_size, TITAN_GE_STD_BUFSIZE,
+	      (unsigned long) titan_ge_eth->rx_desc_area, 0,
+	      (unsigned long) titan_ge_eth->rx_dma)) == 0)
+#endif
+		panic("%s: Error initializing RX Ring\n", netdev->name);
+
+	/* Fill the Rx ring with the SKBs */
+	titan_ge_port_start(netdev, titan_ge_eth);
+
+	/*
+	 * Check if Interrupt Coalscing needs to be turned on. The
+	 * values specified in the register is multiplied by
+	 * (8 x 64 nanoseconds) to determine when an interrupt should
+	 * be sent to the CPU.
+	 */
+
+	if (TITAN_GE_TX_COAL) {
+		titan_ge_eth->tx_int_coal =
+		    titan_ge_tx_coal(TITAN_GE_TX_COAL, port_num);
+	}
+
+	err = titan_ge_mdio_read(port_num, TITAN_GE_MDIO_PHY_STATUS, &phy_reg);
+	if (err == TITAN_GE_MDIO_ERROR) {
+		printk(KERN_ERR
+		       "Could not read PHY control register 0x11 \n");
+		return TITAN_ERROR;
+	}
+	if (!(phy_reg & 0x0400)) {
+		netif_carrier_off(netdev);
+		netif_stop_queue(netdev);
+		return TITAN_ERROR;
+	} else {
+		netif_carrier_on(netdev);
+		netif_start_queue(netdev);
+	}
+
+	return TITAN_OK;
+}
+
+/*
+ * Queue the packet for Tx. Currently no support for zero copy,
+ * checksum offload and Scatter Gather. The chip does support
+ * Scatter Gather only. But, that wont help here since zero copy
+ * requires support for Tx checksumming also.
+ */
+int titan_ge_start_xmit(struct sk_buff *skb, struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned long flags;
+	struct net_device_stats *stats;
+//printk("titan_ge_start_xmit\n");
+
+	stats = &titan_ge_eth->stats;
+	spin_lock_irqsave(&titan_ge_eth->lock, flags);
+
+	if ((TITAN_GE_TX_QUEUE - titan_ge_eth->tx_ring_skbs) <=
+	    (skb_shinfo(skb)->nr_frags + 1)) {
+		netif_stop_queue(netdev);
+		spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+		printk(KERN_ERR "Tx OOD \n");
+		return 1;
+	}
+
+	titan_ge_tx_queue(titan_ge_eth, skb);
+	titan_ge_eth->tx_ring_skbs++;
+
+	if (TITAN_GE_TX_QUEUE <= (titan_ge_eth->tx_ring_skbs + 4)) {
+		spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+		titan_ge_free_tx_queue(titan_ge_eth);
+		spin_lock_irqsave(&titan_ge_eth->lock, flags);
+	}
+
+	stats->tx_bytes += skb->len;
+	stats->tx_packets++;
+
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+
+	netdev->trans_start = jiffies;
+
+	return 0;
+}
+
+/*
+ * Actually does the Rx. Rx side checksumming supported.
+ */
+static int titan_ge_rx(struct net_device *netdev, int port_num,
+			titan_ge_port_info * titan_ge_port,
+		       titan_ge_packet * packet)
+{
+	int rx_curr_desc, rx_used_desc;
+	volatile titan_ge_rx_desc *rx_desc;
+
+	rx_curr_desc = titan_ge_port->rx_curr_desc_q;
+	rx_used_desc = titan_ge_port->rx_used_desc_q;
+
+	if (((rx_curr_desc + 1) % TITAN_GE_RX_QUEUE) == rx_used_desc)
+		return TITAN_ERROR;
+
+	rx_desc = &(titan_ge_port->rx_desc_area[rx_curr_desc]);
+
+	if (rx_desc->cmd_sts & TITAN_GE_RX_BUFFER_OWNED)
+		return TITAN_ERROR;
+
+	packet->skb = titan_ge_port->rx_skb[rx_curr_desc];
+	packet->len = (rx_desc->cmd_sts & 0x7fff);
+
+	/*
+	 * At this point, we dont know if the checksumming
+	 * actually helps relieve CPU. So, keep it for
+	 * port 0 only
+	 */
+	packet->checksum = ntohs((rx_desc->buffer & 0xffff0000) >> 16);
+	packet->cmd_sts = rx_desc->cmd_sts;
+
+	titan_ge_port->rx_curr_desc_q = (rx_curr_desc + 1) % TITAN_GE_RX_QUEUE;
+
+	/* Prefetch the next descriptor */
+	prefetch((const void *)
+	       &titan_ge_port->rx_desc_area[titan_ge_port->rx_curr_desc_q + 1]);
+
+	return TITAN_OK;
+}
+
+/*
+ * Free the Tx queue of the used SKBs
+ */
+static int titan_ge_free_tx_queue(titan_ge_port_info *titan_ge_eth)
+{
+	unsigned long flags;
+
+	/* Take the lock */
+	spin_lock_irqsave(&(titan_ge_eth->lock), flags);
+
+	while (titan_ge_return_tx_desc(titan_ge_eth, titan_ge_eth->port_num) == 0)
+		if (titan_ge_eth->tx_ring_skbs != 1)
+			titan_ge_eth->tx_ring_skbs--;
+
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+
+	return TITAN_OK;
+}
+
+/*
+ * Threshold beyond which we do the cleaning of
+ * Tx queue and new allocation for the Rx
+ * queue
+ */
+#define	TX_THRESHOLD	4
+#define	RX_THRESHOLD	10
+
+/*
+ * Receive the packets and send it to the kernel.
+ */
+static int titan_ge_receive_queue(struct net_device *netdev, unsigned int max)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	titan_ge_packet packet;
+	struct net_device_stats *stats;
+	struct sk_buff *skb;
+	unsigned long received_packets = 0;
+	unsigned int ack;
+
+	stats = &titan_ge_eth->stats;
+
+	while ((--max)
+	       && (titan_ge_rx(netdev, port_num, titan_ge_eth, &packet) == TITAN_OK)) {
+		skb = (struct sk_buff *) packet.skb;
+
+		titan_ge_eth->rx_ring_skbs--;
+
+		if (--titan_ge_eth->rx_work_limit < 0)
+			break;
+		received_packets++;
+
+		stats->rx_packets++;
+		stats->rx_bytes += packet.len;
+
+		if ((packet.cmd_sts & TITAN_GE_RX_PERR) ||
+			(packet.cmd_sts & TITAN_GE_RX_OVERFLOW_ERROR) ||
+			(packet.cmd_sts & TITAN_GE_RX_TRUNC) ||
+			(packet.cmd_sts & TITAN_GE_RX_CRC_ERROR)) {
+				stats->rx_dropped++;
+				dev_kfree_skb_any(skb);
+
+				continue;
+		}
+		/*
+		 * Either support fast path or slow path. Decision
+		 * making can really slow down the performance. The
+		 * idea is to cut down the number of checks and improve
+		 * the fastpath.
+		 */
+
+		skb_put(skb, packet.len - 2);
+
+		/*
+		 * Increment data pointer by two since thats where
+		 * the MAC starts
+		 */
+		skb_reserve(skb, 2);
+		skb->protocol = eth_type_trans(skb, netdev);
+		netif_receive_skb(skb);
+
+		if (titan_ge_eth->rx_threshold > RX_THRESHOLD) {
+			ack = titan_ge_rx_task(netdev, titan_ge_eth);
+			TITAN_GE_WRITE((0x5048 + (port_num << 8)), ack);
+			titan_ge_eth->rx_threshold = 0;
+		} else
+			titan_ge_eth->rx_threshold++;
+
+		if (titan_ge_eth->tx_threshold > TX_THRESHOLD) {
+			titan_ge_eth->tx_threshold = 0;
+			titan_ge_free_tx_queue(titan_ge_eth);
+		}
+		else
+			titan_ge_eth->tx_threshold++;
+
+	}
+	return received_packets;
+}
+
+
+/*
+ * Enable the Rx side interrupts
+ */
+static void titan_ge_enable_int(unsigned int port_num,
+			titan_ge_port_info *titan_ge_eth,
+			struct net_device *netdev)
+{
+	unsigned long reg_data = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
+
+	if (port_num == 0)
+		reg_data |= 0x3;
+	if (port_num == 1)
+		reg_data |= 0x300;
+	if (port_num == 2)
+		reg_data |= 0x30000;
+
+	/* Re-enable interrupts */
+	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, reg_data);
+}
+
+/*
+ * Main function to handle the polling for Rx side NAPI.
+ * Receive interrupts have been disabled at this point.
+ * The poll schedules the transmit followed by receive.
+ */
+static int titan_ge_poll(struct net_device *netdev, int *budget)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	int port_num = titan_ge_eth->port_num;
+	int work_done = 0;
+	unsigned long flags, status;
+
+	titan_ge_eth->rx_work_limit = *budget;
+	if (titan_ge_eth->rx_work_limit > netdev->quota)
+		titan_ge_eth->rx_work_limit = netdev->quota;
+
+	do {
+		/* Do the transmit cleaning work here */
+		titan_ge_free_tx_queue(titan_ge_eth);
+
+		/* Ack the Rx interrupts */
+		if (port_num == 0)
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x3);
+		if (port_num == 1)
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x300);
+		if (port_num == 2)
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x30000);
+
+		work_done += titan_ge_receive_queue(netdev, 0);
+
+		/* Out of quota and there is work to be done */
+		if (titan_ge_eth->rx_work_limit < 0)
+			goto not_done;
+
+		/* Receive alloc_skb could lead to OOM */
+		if (oom_flag == 1) {
+			oom_flag = 0;
+			goto oom;
+		}
+
+		status = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_A);
+	} while (status & 0x30300);
+
+	/* If we are here, then no more interrupts to process */
+	goto done;
+
+not_done:
+	*budget -= work_done;
+	netdev->quota -= work_done;
+	return 1;
+
+oom:
+	printk(KERN_ERR "OOM \n");
+	netif_rx_complete(netdev);
+	return 0;
+
+done:
+	/*
+	 * No more packets on the poll list. Turn the interrupts
+	 * back on and we should be able to catch the new
+	 * packets in the interrupt handler
+	 */
+	if (!work_done)
+		work_done = 1;
+
+	*budget -= work_done;
+	netdev->quota -= work_done;
+
+	spin_lock_irqsave(&titan_ge_eth->lock, flags);
+
+	/* Remove us from the poll list */
+	netif_rx_complete(netdev);
+
+	/* Re-enable interrupts */
+	titan_ge_enable_int(port_num, titan_ge_eth, netdev);
+
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+
+	return 0;
+}
+
+/*
+ * Close the network device
+ */
+int titan_ge_stop(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+
+	spin_lock_irq(&(titan_ge_eth->lock));
+	titan_ge_eth_stop(netdev);
+	free_irq(netdev->irq, netdev);
+	spin_unlock_irq(&titan_ge_eth->lock);
+
+	return TITAN_OK;
+}
+
+/*
+ * Free the Tx ring
+ */
+static void titan_ge_free_tx_rings(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned int curr;
+	unsigned long reg_data;
+
+	/* Stop the Tx DMA */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG +
+				(port_num << 8));
+	reg_data |= 0xc0000000;
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG +
+			(port_num << 8)), reg_data);
+
+	/* Disable the TMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x00000001);
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	for (curr = 0;
+	     (titan_ge_eth->tx_ring_skbs) && (curr < TITAN_GE_TX_QUEUE);
+	     curr++) {
+		if (titan_ge_eth->tx_skb[curr]) {
+			dev_kfree_skb(titan_ge_eth->tx_skb[curr]);
+			titan_ge_eth->tx_ring_skbs--;
+		}
+	}
+
+	if (titan_ge_eth->tx_ring_skbs != 0)
+		printk
+		    ("%s: Error on Tx descriptor free - could not free %d"
+		     " descriptors\n", netdev->name,
+		     titan_ge_eth->tx_ring_skbs);
+
+#ifndef TITAN_RX_RING_IN_SRAM
+	dma_free_coherent(&titan_ge_device[port_num]->dev,
+			  titan_ge_eth->tx_desc_area_size,
+			  (void *) titan_ge_eth->tx_desc_area,
+			  titan_ge_eth->tx_dma);
+#endif
+}
+
+/*
+ * Free the Rx ring
+ */
+static void titan_ge_free_rx_rings(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned int curr;
+	unsigned long reg_data;
+
+	/* Stop the Rx DMA */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG +
+				(port_num << 8));
+	reg_data |= 0x000c0000;
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG +
+			(port_num << 8)), reg_data);
+
+	/* Disable the RMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x00000001);
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	for (curr = 0;
+	     titan_ge_eth->rx_ring_skbs && (curr < TITAN_GE_RX_QUEUE);
+	     curr++) {
+		if (titan_ge_eth->rx_skb[curr]) {
+			dev_kfree_skb(titan_ge_eth->rx_skb[curr]);
+			titan_ge_eth->rx_ring_skbs--;
+		}
+	}
+
+	if (titan_ge_eth->rx_ring_skbs != 0)
+		printk(KERN_ERR
+		       "%s: Error in freeing Rx Ring. %d skb's still"
+		       " stuck in RX Ring - ignoring them\n", netdev->name,
+		       titan_ge_eth->rx_ring_skbs);
+
+#ifndef TITAN_RX_RING_IN_SRAM
+	dma_free_coherent(&titan_ge_device[port_num]->dev,
+			  titan_ge_eth->rx_desc_area_size,
+			  (void *) titan_ge_eth->rx_desc_area,
+			  titan_ge_eth->rx_dma);
+#endif
+}
+
+/*
+ * Actually does the stop of the Ethernet device
+ */
+static void titan_ge_eth_stop(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+
+	netif_stop_queue(netdev);
+
+	titan_ge_port_reset(titan_ge_eth->port_num);
+
+	titan_ge_free_tx_rings(netdev);
+	titan_ge_free_rx_rings(netdev);
+
+	/* Disable the Tx and Rx Interrupts for all channels */
+	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, 0x0);
+}
+
+/*
+ * Update the MAC address. Note that we have to write the
+ * address in three station registers, 16 bits each. And this
+ * has to be done for TMAC and RMAC
+ */
+static void titan_ge_update_mac_address(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	u8 p_addr[6];
+
+	memcpy(titan_ge_eth->port_mac_addr, netdev->dev_addr, 6);
+	memcpy(p_addr, netdev->dev_addr, 6);
+
+	/* Update the Address Filtering Match tables */
+	titan_ge_update_afx(titan_ge_eth);
+
+	printk("Station MAC : %d %d %d %d %d %d  \n",
+		p_addr[5], p_addr[4], p_addr[3],
+		p_addr[2], p_addr[1], p_addr[0]);
+
+	/* Set the MAC address here for TMAC and RMAC */
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_HI + (port_num << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_MID + (port_num << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_LOW + (port_num << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_HI + (port_num << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_MID + (port_num << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_LOW + (port_num << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+}
+
+/*
+ * Set the MAC address of the Ethernet device
+ */
+static int titan_ge_set_mac_address(struct net_device *dev, void *addr)
+{
+	titan_ge_port_info *tp = netdev_priv(dev);
+	struct sockaddr *sa = addr;
+
+	memcpy(dev->dev_addr, sa->sa_data, dev->addr_len);
+
+	spin_lock_irq(&tp->lock);
+	titan_ge_update_mac_address(dev);
+	spin_unlock_irq(&tp->lock);
+
+	return 0;
+}
+
+/*
+ * Get the Ethernet device stats
+ */
+static struct net_device_stats *titan_ge_get_stats(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+
+	return &titan_ge_eth->stats;
+}
+
+/*
+ * Initialize the Rx descriptor ring for the Titan Ge
+ */
+static int titan_ge_init_rx_desc_ring(titan_ge_port_info * titan_eth_port,
+				      int rx_desc_num,
+				      int rx_buff_size,
+				      unsigned long rx_desc_base_addr,
+				      unsigned long rx_buff_base_addr,
+				      unsigned long rx_dma)
+{
+	volatile titan_ge_rx_desc *rx_desc;
+	unsigned long buffer_addr;
+	int index;
+	unsigned long titan_ge_rx_desc_bus = rx_dma;
+
+	buffer_addr = rx_buff_base_addr;
+	rx_desc = (titan_ge_rx_desc *) rx_desc_base_addr;
+
+	/* Check alignment */
+	if (rx_buff_base_addr & 0xF)
+		return 0;
+
+	/* Check Rx buffer size */
+	if ((rx_buff_size < 8) || (rx_buff_size > TITAN_GE_MAX_RX_BUFFER))
+		return 0;
+
+	/* 64-bit alignment
+	if ((rx_buff_base_addr + rx_buff_size) & 0x7)
+		return 0; */
+
+	/* Initialize the Rx desc ring */
+	for (index = 0; index < rx_desc_num; index++) {
+		titan_ge_rx_desc_bus += sizeof(titan_ge_rx_desc);
+		rx_desc[index].cmd_sts = 0;
+		rx_desc[index].buffer_addr = buffer_addr;
+		titan_eth_port->rx_skb[index] = NULL;
+		buffer_addr += rx_buff_size;
+	}
+
+	titan_eth_port->rx_curr_desc_q = 0;
+	titan_eth_port->rx_used_desc_q = 0;
+
+	titan_eth_port->rx_desc_area = (titan_ge_rx_desc *) rx_desc_base_addr;
+	titan_eth_port->rx_desc_area_size =
+	    rx_desc_num * sizeof(titan_ge_rx_desc);
+
+	titan_eth_port->rx_dma = rx_dma;
+
+	return TITAN_OK;
+}
+
+/*
+ * Initialize the Tx descriptor ring. Descriptors in the SRAM
+ */
+static int titan_ge_init_tx_desc_ring(titan_ge_port_info * titan_ge_port,
+				      int tx_desc_num,
+				      unsigned long tx_desc_base_addr,
+				      unsigned long tx_dma)
+{
+	titan_ge_tx_desc *tx_desc;
+	int index;
+	unsigned long titan_ge_tx_desc_bus = tx_dma;
+
+	if (tx_desc_base_addr & 0xF)
+		return 0;
+
+	tx_desc = (titan_ge_tx_desc *) tx_desc_base_addr;
+
+	for (index = 0; index < tx_desc_num; index++) {
+		titan_ge_port->tx_dma_array[index] =
+		    (dma_addr_t) titan_ge_tx_desc_bus;
+		titan_ge_tx_desc_bus += sizeof(titan_ge_tx_desc);
+		tx_desc[index].cmd_sts = 0x0000;
+		tx_desc[index].buffer_len = 0;
+		tx_desc[index].buffer_addr = 0x00000000;
+		titan_ge_port->tx_skb[index] = NULL;
+	}
+
+	titan_ge_port->tx_curr_desc_q = 0;
+	titan_ge_port->tx_used_desc_q = 0;
+
+	titan_ge_port->tx_desc_area = (titan_ge_tx_desc *) tx_desc_base_addr;
+	titan_ge_port->tx_desc_area_size =
+	    tx_desc_num * sizeof(titan_ge_tx_desc);
+
+	titan_ge_port->tx_dma = tx_dma;
+	return TITAN_OK;
+}
+
+/*
+ * Initialize the device as an Ethernet device
+ */
+static int __init titan_ge_probe(struct device *device)
+{
+	titan_ge_port_info *titan_ge_eth;
+	struct net_device *netdev;
+	int port = to_platform_device(device)->id;
+	int err;
+
+	netdev = alloc_etherdev(sizeof(titan_ge_port_info));
+	if (!netdev) {
+		err = -ENODEV;
+		goto out;
+	}
+
+	netdev->open = titan_ge_open;
+	netdev->stop = titan_ge_stop;
+	netdev->hard_start_xmit = titan_ge_start_xmit;
+	netdev->get_stats = titan_ge_get_stats;
+	netdev->set_multicast_list = titan_ge_set_multi;
+	netdev->set_mac_address = titan_ge_set_mac_address;
+
+	/* Tx timeout */
+	netdev->tx_timeout = titan_ge_tx_timeout;
+	netdev->watchdog_timeo = 2 * HZ;
+
+	/* Set these to very high values */
+	netdev->poll = titan_ge_poll;
+	netdev->weight = 64;
+
+	netdev->tx_queue_len = TITAN_GE_TX_QUEUE;
+	netif_carrier_off(netdev);
+	netdev->base_addr = 0;
+
+	netdev->change_mtu = titan_ge_change_mtu;
+
+	titan_ge_eth = netdev_priv(netdev);
+	/* Allocation of memory for the driver structures */
+
+	titan_ge_eth->port_num = port;
+
+	/* Configure the Tx timeout handler */
+	INIT_WORK(&titan_ge_eth->tx_timeout_task,
+		  (void (*)(void *)) titan_ge_tx_timeout_task, netdev);
+
+	spin_lock_init(&titan_ge_eth->lock);
+
+	/* set MAC addresses */
+	memcpy(netdev->dev_addr, titan_ge_mac_addr_base, 6);
+	netdev->dev_addr[5] += port;
+
+	err = register_netdev(netdev);
+
+	if (err)
+		goto out_free_netdev;
+
+	printk(KERN_NOTICE
+	       "%s: port %d with MAC address %02x:%02x:%02x:%02x:%02x:%02x\n",
+	       netdev->name, port, netdev->dev_addr[0],
+	       netdev->dev_addr[1], netdev->dev_addr[2],
+	       netdev->dev_addr[3], netdev->dev_addr[4],
+	       netdev->dev_addr[5]);
+
+	printk(KERN_NOTICE "Rx NAPI supported, Tx Coalescing ON \n");
+
+	return 0;
+
+out_free_netdev:
+	kfree(netdev);
+
+out:
+	return err;
+}
+
+static void __devexit titan_device_remove(struct device *device)
+{
+}
+
+/*
+ * Reset the Ethernet port
+ */
+static void titan_ge_port_reset(unsigned int port_num)
+{
+	unsigned int reg_data;
+
+	/* Stop the Tx port activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x0001);
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	/* Stop the Rx port activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x0001);
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	return;
+}
+
+/*
+ * Return the Tx desc after use by the XDMA
+ */
+static int titan_ge_return_tx_desc(titan_ge_port_info * titan_ge_eth, int port)
+{
+	int tx_desc_used;
+	struct sk_buff *skb;
+
+	tx_desc_used = titan_ge_eth->tx_used_desc_q;
+
+	/* return right away */
+	if (tx_desc_used == titan_ge_eth->tx_curr_desc_q)
+		return TITAN_ERROR;
+
+	/* Now the critical stuff */
+	skb = titan_ge_eth->tx_skb[tx_desc_used];
+
+	dev_kfree_skb_any(skb);
+
+	titan_ge_eth->tx_skb[tx_desc_used] = NULL;
+	titan_ge_eth->tx_used_desc_q =
+	    (tx_desc_used + 1) % TITAN_GE_TX_QUEUE;
+
+	return 0;
+}
+
+/*
+ * Coalescing for the Tx path
+ */
+static unsigned long titan_ge_tx_coal(unsigned long delay, int port)
+{
+	unsigned long rx_delay;
+
+	rx_delay = TITAN_GE_READ(TITAN_GE_INT_COALESCING);
+	delay = (delay << 16) | rx_delay;
+
+	TITAN_GE_WRITE(TITAN_GE_INT_COALESCING, delay);
+	TITAN_GE_WRITE(0x5038, delay);
+
+	return delay;
+}
+
+static struct device_driver titan_soc_driver = {
+	.name   = titan_string,
+	.bus    = &platform_bus_type,
+	.probe  = titan_ge_probe,
+	.remove = __devexit_p(titan_device_remove),
+};
+
+static void titan_platform_release (struct device *device)
+{
+	struct platform_device *pldev;
+
+	/* free device */
+	pldev = to_platform_device (device);
+	kfree (pldev);
+}
+
+/*
+ * Register the Titan GE with the kernel
+ */
+static int __init titan_ge_init_module(void)
+{
+	struct platform_device *pldev;
+	unsigned int version, device;
+	int i;
+
+	printk(KERN_NOTICE
+	       "PMC-Sierra TITAN 10/100/1000 Ethernet Driver \n");
+
+	titan_ge_base = (unsigned long) ioremap(TITAN_GE_BASE, TITAN_GE_SIZE);
+	if (!titan_ge_base) {
+		printk("Mapping Titan GE failed\n");
+		goto out;
+	}
+
+	device = TITAN_GE_READ(TITAN_GE_DEVICE_ID);
+	version = (device & 0x000f0000) >> 16;
+	device &= 0x0000ffff;
+
+	printk(KERN_NOTICE "Device Id : %x,  Version : %x \n", device, version);
+
+#ifdef TITAN_RX_RING_IN_SRAM
+	titan_ge_sram = (unsigned long) ioremap(TITAN_SRAM_BASE,
+						TITAN_SRAM_SIZE);
+	if (!titan_ge_sram) {
+		printk("Mapping Titan SRAM failed\n");
+		goto out_unmap_ge;
+	}
+#endif
+
+	if (driver_register(&titan_soc_driver)) {
+		printk(KERN_ERR "Driver registration failed\n");
+		goto out_unmap_sram;
+	}
+
+	for (i = 0; i < 3; i++) {
+		titan_ge_device[i] = NULL;
+
+		if (!(pldev = kmalloc (sizeof (*pldev), GFP_KERNEL)))
+			continue;
+
+		memset (pldev, 0, sizeof (*pldev));
+		pldev->name		= titan_string;
+		pldev->id		= i;
+		pldev->dev.release	= titan_platform_release;
+		titan_ge_device[i]	= pldev;
+
+		if (platform_device_register (pldev)) {
+			kfree (pldev);
+			titan_ge_device[i] = NULL;
+			continue;
+		}
+
+		if (!pldev->dev.driver) {
+			/*
+			 * The driver was not bound to this device, there was
+			 * no hardware at this address. Unregister it, as the
+			 * release fuction will take care of freeing the
+			 * allocated structure
+			 */
+			titan_ge_device[i] = NULL;
+			platform_device_unregister (pldev);
+		}
+	}
+
+	return 0;
+
+out_unmap_sram:
+	iounmap((void *)titan_ge_sram);
+
+out_unmap_ge:
+	iounmap((void *)titan_ge_base);
+
+out:
+	return -ENOMEM;
+}
+
+/*
+ * Unregister the Titan GE from the kernel
+ */
+static void __exit titan_ge_cleanup_module(void)
+{
+	int i;
+
+	driver_unregister(&titan_soc_driver);
+
+	for (i = 0; i < 3; i++) {
+		if (titan_ge_device[i]) {
+			platform_device_unregister (titan_ge_device[i]);
+			titan_ge_device[i] = NULL;
+		}
+	}
+
+	iounmap((void *)titan_ge_sram);
+	iounmap((void *)titan_ge_base);
+}
+
+MODULE_AUTHOR("Manish Lachwani <lachwani@pmc-sierra.com>");
+MODULE_DESCRIPTION("Titan GE Ethernet driver");
+MODULE_LICENSE("GPL");
+
+module_init(titan_ge_init_module);
+module_exit(titan_ge_cleanup_module);
diff -Nur linux-2.6.29.1/drivers/net/titan_ge.h linux-2.6.29.1-lemote/drivers/net/titan_ge.h
--- linux-2.6.29.1/drivers/net/titan_ge.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/net/titan_ge.h	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,415 @@
+#ifndef _TITAN_GE_H_
+#define _TITAN_GE_H_
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <asm/byteorder.h>
+
+/*
+ * These functions should be later moved to a more generic location since there
+ * will be others accessing it also
+ */
+
+/*
+ * This is the way it works: LKB5 Base is at 0x0128. TITAN_BASE is defined in
+ * include/asm/titan_dep.h. TITAN_GE_BASE is the value in the TITAN_GE_LKB5
+ * register.
+ */
+
+#define	TITAN_GE_BASE	0xfe000000UL
+#define	TITAN_GE_SIZE	0x10000UL
+
+extern unsigned long titan_ge_base;
+
+#define	TITAN_GE_WRITE(offset, data) \
+		*(volatile u32 *)(titan_ge_base + (offset)) = (data)
+
+#define TITAN_GE_READ(offset) *(volatile u32 *)(titan_ge_base + (offset))
+
+#ifndef msec_delay
+#define msec_delay(x)   do { if(in_interrupt()) { \
+				/* Don't mdelay in interrupt context! */ \
+				BUG(); \
+			} else { \
+				set_current_state(TASK_UNINTERRUPTIBLE); \
+				schedule_timeout((x * HZ)/1000); \
+			} } while(0)
+#endif
+
+#define TITAN_GE_PORT_0
+
+#define	TITAN_SRAM_BASE		((OCD_READ(RM9000x2_OCD_LKB13) & ~1) << 4)
+#define	TITAN_SRAM_SIZE		0x2000UL
+
+/*
+ * We may need these constants
+ */
+#define TITAN_BIT0    0x00000001
+#define TITAN_BIT1    0x00000002
+#define TITAN_BIT2    0x00000004
+#define TITAN_BIT3    0x00000008
+#define TITAN_BIT4    0x00000010
+#define TITAN_BIT5    0x00000020
+#define TITAN_BIT6    0x00000040
+#define TITAN_BIT7    0x00000080
+#define TITAN_BIT8    0x00000100
+#define TITAN_BIT9    0x00000200
+#define TITAN_BIT10   0x00000400
+#define TITAN_BIT11   0x00000800
+#define TITAN_BIT12   0x00001000
+#define TITAN_BIT13   0x00002000
+#define TITAN_BIT14   0x00004000
+#define TITAN_BIT15   0x00008000
+#define TITAN_BIT16   0x00010000
+#define TITAN_BIT17   0x00020000
+#define TITAN_BIT18   0x00040000
+#define TITAN_BIT19   0x00080000
+#define TITAN_BIT20   0x00100000
+#define TITAN_BIT21   0x00200000
+#define TITAN_BIT22   0x00400000
+#define TITAN_BIT23   0x00800000
+#define TITAN_BIT24   0x01000000
+#define TITAN_BIT25   0x02000000
+#define TITAN_BIT26   0x04000000
+#define TITAN_BIT27   0x08000000
+#define TITAN_BIT28   0x10000000
+#define TITAN_BIT29   0x20000000
+#define TITAN_BIT30   0x40000000
+#define TITAN_BIT31   0x80000000
+
+/* Flow Control */
+#define	TITAN_GE_FC_NONE	0x0
+#define	TITAN_GE_FC_FULL	0x1
+#define	TITAN_GE_FC_TX_PAUSE	0x2
+#define	TITAN_GE_FC_RX_PAUSE	0x3
+
+/* Duplex Settings */
+#define	TITAN_GE_FULL_DUPLEX	0x1
+#define	TITAN_GE_HALF_DUPLEX	0x2
+
+/* Speed settings */
+#define	TITAN_GE_SPEED_1000	0x1
+#define	TITAN_GE_SPEED_100	0x2
+#define	TITAN_GE_SPEED_10	0x3
+
+/* Debugging info only */
+#undef TITAN_DEBUG
+
+/* Keep the rings in the Titan's SSRAM */
+#define TITAN_RX_RING_IN_SRAM
+
+#ifdef CONFIG_64BIT
+#define	TITAN_GE_IE_MASK	0xfffffffffb001b64
+#define	TITAN_GE_IE_STATUS	0xfffffffffb001b60
+#else
+#define	TITAN_GE_IE_MASK	0xfb001b64
+#define	TITAN_GE_IE_STATUS	0xfb001b60
+#endif
+
+/* Support for Jumbo Frames */
+#undef TITAN_GE_JUMBO_FRAMES
+
+/* Rx buffer size */
+#ifdef TITAN_GE_JUMBO_FRAMES
+#define	TITAN_GE_JUMBO_BUFSIZE	9080
+#else
+#define	TITAN_GE_STD_BUFSIZE	1580
+#endif
+
+/*
+ * Tx and Rx Interrupt Coalescing parameter. These values are
+ * for 1 Ghz processor. Rx coalescing can be taken care of
+ * by NAPI. NAPI is adaptive and hence useful. Tx coalescing
+ * is not adaptive. Hence, these values need to be adjusted
+ * based on load, CPU speed etc.
+ */
+#define	TITAN_GE_RX_COAL	150
+#define	TITAN_GE_TX_COAL	300
+
+#if defined(__BIG_ENDIAN)
+
+/* Define the Rx descriptor */
+typedef struct eth_rx_desc {
+	u32     reserved;	/* Unused 		*/
+	u32     buffer_addr;	/* CPU buffer address 	*/
+	u32	cmd_sts;	/* Command and Status	*/
+	u32	buffer;		/* XDMA buffer address	*/
+} titan_ge_rx_desc;
+
+/* Define the Tx descriptor */
+typedef struct eth_tx_desc {
+	u16     cmd_sts;	/* Command, Status and Buffer count */
+	u16	buffer_len;	/* Length of the buffer	*/
+	u32     buffer_addr;	/* Physical address of the buffer */
+} titan_ge_tx_desc;
+
+#elif defined(__LITTLE_ENDIAN)
+
+/* Define the Rx descriptor */
+typedef struct eth_rx_desc {
+	u32	buffer_addr;	/* CPU buffer address   */
+	u32	reserved;	/* Unused               */
+	u32	buffer;		/* XDMA buffer address  */
+	u32	cmd_sts;	/* Command and Status   */
+} titan_ge_rx_desc;
+
+/* Define the Tx descriptor */
+typedef struct eth_tx_desc {
+	u32     buffer_addr;	/* Physical address of the buffer */
+	u16     buffer_len;     /* Length of the buffer */
+	u16     cmd_sts;        /* Command, Status and Buffer count */
+} titan_ge_tx_desc;
+#endif
+
+/* Default Tx Queue Size */
+#define	TITAN_GE_TX_QUEUE	128
+#define TITAN_TX_RING_BYTES	(TITAN_GE_TX_QUEUE * sizeof(struct eth_tx_desc))
+
+/* Default Rx Queue Size */
+#define	TITAN_GE_RX_QUEUE	64
+#define TITAN_RX_RING_BYTES	(TITAN_GE_RX_QUEUE * sizeof(struct eth_rx_desc))
+
+/* Packet Structure */
+typedef struct _pkt_info {
+	unsigned int           len;
+	unsigned int            cmd_sts;
+	unsigned int            buffer;
+	struct sk_buff          *skb;
+	unsigned int		checksum;
+} titan_ge_packet;
+
+
+#define	PHYS_CNT	3
+
+/* Titan Port specific data structure */
+typedef struct _eth_port_ctrl {
+	unsigned int		port_num;
+	u8			port_mac_addr[6];
+
+	/* Rx descriptor pointers */
+	int 			rx_curr_desc_q, rx_used_desc_q;
+
+	/* Tx descriptor pointers */
+	int 			tx_curr_desc_q, tx_used_desc_q;
+
+	/* Rx descriptor area */
+	volatile titan_ge_rx_desc	*rx_desc_area;
+	unsigned int			rx_desc_area_size;
+	struct sk_buff*			rx_skb[TITAN_GE_RX_QUEUE];
+
+	/* Tx Descriptor area */
+	volatile titan_ge_tx_desc	*tx_desc_area;
+	unsigned int                    tx_desc_area_size;
+	struct sk_buff*                 tx_skb[TITAN_GE_TX_QUEUE];
+
+	/* Timeout task */
+	struct work_struct		tx_timeout_task;
+
+	/* DMA structures and handles */
+	dma_addr_t			tx_dma;
+	dma_addr_t			rx_dma;
+	dma_addr_t			tx_dma_array[TITAN_GE_TX_QUEUE];
+
+	/* Device lock */
+	spinlock_t			lock;
+
+	unsigned int			tx_ring_skbs;
+	unsigned int			rx_ring_size;
+	unsigned int			tx_ring_size;
+	unsigned int			rx_ring_skbs;
+
+	struct net_device_stats		stats;
+
+	/* Tx and Rx coalescing */
+	unsigned long			rx_int_coal;
+	unsigned long			tx_int_coal;
+
+	/* Threshold for replenishing the Rx and Tx rings */
+	unsigned int			tx_threshold;
+	unsigned int			rx_threshold;
+
+	/* NAPI work limit */
+	unsigned int			rx_work_limit;
+} titan_ge_port_info;
+
+/* Titan specific constants */
+#define	TITAN_ETH_PORT_IRQ		3
+
+/* Max Rx buffer */
+#define	TITAN_GE_MAX_RX_BUFFER		65536
+
+/* Tx and Rx Error */
+#define	TITAN_GE_ERROR
+
+/* Rx Descriptor Command and Status */
+
+#define	TITAN_GE_RX_CRC_ERROR		TITAN_BIT27	/* crc error */
+#define	TITAN_GE_RX_OVERFLOW_ERROR	TITAN_BIT15	/* overflow */
+#define TITAN_GE_RX_BUFFER_OWNED	TITAN_BIT21	/* buffer ownership */
+#define	TITAN_GE_RX_STP			TITAN_BIT31	/* start of packet */
+#define	TITAN_GE_RX_BAM			TITAN_BIT30	/* broadcast address match */
+#define TITAN_GE_RX_PAM			TITAN_BIT28	/* physical address match */
+#define TITAN_GE_RX_LAFM		TITAN_BIT29	/* logical address filter match */
+#define TITAN_GE_RX_VLAN		TITAN_BIT26	/* virtual lans */
+#define TITAN_GE_RX_PERR		TITAN_BIT19	/* packet error */
+#define TITAN_GE_RX_TRUNC		TITAN_BIT20	/* packet size greater than 32 buffers */
+
+/* Tx Descriptor Command */
+#define	TITAN_GE_TX_BUFFER_OWNED	TITAN_BIT5	/* buffer ownership */
+#define	TITAN_GE_TX_ENABLE_INTERRUPT	TITAN_BIT15	/* Interrupt Enable */
+
+/* Return Status */
+#define	TITAN_OK	0x1	/* Good Status */
+#define	TITAN_ERROR	0x2	/* Error Status */
+
+/* MIB specific register offset */
+#define TITAN_GE_MSTATX_STATS_BASE_LOW       0x0800  /* MSTATX COUNTL[15:0] */
+#define TITAN_GE_MSTATX_STATS_BASE_MID       0x0804  /* MSTATX COUNTM[15:0] */
+#define TITAN_GE_MSTATX_STATS_BASE_HI        0x0808  /* MSTATX COUNTH[7:0] */
+#define TITAN_GE_MSTATX_CONTROL              0x0828  /* MSTATX Control */
+#define TITAN_GE_MSTATX_VARIABLE_SELECT      0x082C  /* MSTATX Variable Select */
+
+/* MIB counter offsets, add to the TITAN_GE_MSTATX_STATS_BASE_XXX */
+#define TITAN_GE_MSTATX_RXFRAMESOK                   0x0040
+#define TITAN_GE_MSTATX_RXOCTETSOK                   0x0050
+#define TITAN_GE_MSTATX_RXFRAMES                     0x0060
+#define TITAN_GE_MSTATX_RXOCTETS                     0x0070
+#define TITAN_GE_MSTATX_RXUNICASTFRAMESOK            0x0080
+#define TITAN_GE_MSTATX_RXBROADCASTFRAMESOK          0x0090
+#define TITAN_GE_MSTATX_RXMULTICASTFRAMESOK          0x00A0
+#define TITAN_GE_MSTATX_RXTAGGEDFRAMESOK             0x00B0
+#define TITAN_GE_MSTATX_RXMACPAUSECONTROLFRAMESOK    0x00C0
+#define TITAN_GE_MSTATX_RXMACCONTROLFRAMESOK         0x00D0
+#define TITAN_GE_MSTATX_RXFCSERROR                   0x00E0
+#define TITAN_GE_MSTATX_RXALIGNMENTERROR             0x00F0
+#define TITAN_GE_MSTATX_RXSYMBOLERROR                0x0100
+#define TITAN_GE_MSTATX_RXLAYER1ERROR                0x0110
+#define TITAN_GE_MSTATX_RXINRANGELENGTHERROR         0x0120
+#define TITAN_GE_MSTATX_RXLONGLENGTHERROR            0x0130
+#define TITAN_GE_MSTATX_RXLONGLENGTHCRCERROR         0x0140
+#define TITAN_GE_MSTATX_RXSHORTLENGTHERROR           0x0150
+#define TITAN_GE_MSTATX_RXSHORTLLENGTHCRCERROR       0x0160
+#define TITAN_GE_MSTATX_RXFRAMES64OCTETS             0x0170
+#define TITAN_GE_MSTATX_RXFRAMES65TO127OCTETS        0x0180
+#define TITAN_GE_MSTATX_RXFRAMES128TO255OCTETS       0x0190
+#define TITAN_GE_MSTATX_RXFRAMES256TO511OCTETS       0x01A0
+#define TITAN_GE_MSTATX_RXFRAMES512TO1023OCTETS      0x01B0
+#define TITAN_GE_MSTATX_RXFRAMES1024TO1518OCTETS     0x01C0
+#define TITAN_GE_MSTATX_RXFRAMES1519TOMAXSIZE        0x01D0
+#define TITAN_GE_MSTATX_RXSTATIONADDRESSFILTERED     0x01E0
+#define TITAN_GE_MSTATX_RXVARIABLE                   0x01F0
+#define TITAN_GE_MSTATX_GENERICADDRESSFILTERED       0x0200
+#define TITAN_GE_MSTATX_UNICASTFILTERED              0x0210
+#define TITAN_GE_MSTATX_MULTICASTFILTERED            0x0220
+#define TITAN_GE_MSTATX_BROADCASTFILTERED            0x0230
+#define TITAN_GE_MSTATX_HASHFILTERED                 0x0240
+#define TITAN_GE_MSTATX_TXFRAMESOK                   0x0250
+#define TITAN_GE_MSTATX_TXOCTETSOK                   0x0260
+#define TITAN_GE_MSTATX_TXOCTETS                     0x0270
+#define TITAN_GE_MSTATX_TXTAGGEDFRAMESOK             0x0280
+#define TITAN_GE_MSTATX_TXMACPAUSECONTROLFRAMESOK    0x0290
+#define TITAN_GE_MSTATX_TXFCSERROR                   0x02A0
+#define TITAN_GE_MSTATX_TXSHORTLENGTHERROR           0x02B0
+#define TITAN_GE_MSTATX_TXLONGLENGTHERROR            0x02C0
+#define TITAN_GE_MSTATX_TXSYSTEMERROR                0x02D0
+#define TITAN_GE_MSTATX_TXMACERROR                   0x02E0
+#define TITAN_GE_MSTATX_TXCARRIERSENSEERROR          0x02F0
+#define TITAN_GE_MSTATX_TXSQETESTERROR               0x0300
+#define TITAN_GE_MSTATX_TXUNICASTFRAMESOK            0x0310
+#define TITAN_GE_MSTATX_TXBROADCASTFRAMESOK          0x0320
+#define TITAN_GE_MSTATX_TXMULTICASTFRAMESOK          0x0330
+#define TITAN_GE_MSTATX_TXUNICASTFRAMESATTEMPTED     0x0340
+#define TITAN_GE_MSTATX_TXBROADCASTFRAMESATTEMPTED   0x0350
+#define TITAN_GE_MSTATX_TXMULTICASTFRAMESATTEMPTED   0x0360
+#define TITAN_GE_MSTATX_TXFRAMES64OCTETS             0x0370
+#define TITAN_GE_MSTATX_TXFRAMES65TO127OCTETS        0x0380
+#define TITAN_GE_MSTATX_TXFRAMES128TO255OCTETS       0x0390
+#define TITAN_GE_MSTATX_TXFRAMES256TO511OCTETS       0x03A0
+#define TITAN_GE_MSTATX_TXFRAMES512TO1023OCTETS      0x03B0
+#define TITAN_GE_MSTATX_TXFRAMES1024TO1518OCTETS     0x03C0
+#define TITAN_GE_MSTATX_TXFRAMES1519TOMAXSIZE        0x03D0
+#define TITAN_GE_MSTATX_TXVARIABLE                   0x03E0
+#define TITAN_GE_MSTATX_RXSYSTEMERROR                0x03F0
+#define TITAN_GE_MSTATX_SINGLECOLLISION              0x0400
+#define TITAN_GE_MSTATX_MULTIPLECOLLISION            0x0410
+#define TITAN_GE_MSTATX_DEFERREDXMISSIONS            0x0420
+#define TITAN_GE_MSTATX_LATECOLLISIONS               0x0430
+#define TITAN_GE_MSTATX_ABORTEDDUETOXSCOLLS          0x0440
+
+/* Interrupt specific defines */
+#define TITAN_GE_DEVICE_ID         0x0000  /* Device ID */
+#define TITAN_GE_RESET             0x0004  /* Reset reg */
+#define TITAN_GE_TSB_CTRL_0        0x000C  /* TSB Control reg 0 */
+#define TITAN_GE_TSB_CTRL_1        0x0010  /* TSB Control reg 1 */
+#define TITAN_GE_INTR_GRP0_STATUS  0x0040  /* General Interrupt Group 0 Status */
+#define TITAN_GE_INTR_XDMA_CORE_A  0x0048  /* XDMA Channel Interrupt Status, Core A*/
+#define TITAN_GE_INTR_XDMA_CORE_B  0x004C  /* XDMA Channel Interrupt Status, Core B*/
+#define	TITAN_GE_INTR_XDMA_IE	   0x0058  /* XDMA Channel Interrupt Enable */
+#define TITAN_GE_SDQPF_ECC_INTR    0x480C  /* SDQPF ECC Interrupt Status */
+#define TITAN_GE_SDQPF_RXFIFO_CTL  0x4828  /* SDQPF RxFifo Control and Interrupt Enb*/
+#define TITAN_GE_SDQPF_RXFIFO_INTR 0x482C  /* SDQPF RxFifo Interrupt Status */
+#define TITAN_GE_SDQPF_TXFIFO_CTL  0x4928  /* SDQPF TxFifo Control and Interrupt Enb*/
+#define TITAN_GE_SDQPF_TXFIFO_INTR 0x492C  /* SDQPF TxFifo Interrupt Status */
+#define	TITAN_GE_SDQPF_RXFIFO_0	   0x4840  /* SDQPF RxFIFO Enable */
+#define	TITAN_GE_SDQPF_TXFIFO_0	   0x4940  /* SDQPF TxFIFO Enable */
+#define TITAN_GE_XDMA_CONFIG       0x5000  /* XDMA Global Configuration */
+#define TITAN_GE_XDMA_INTR_SUMMARY 0x5010  /* XDMA Interrupt Summary */
+#define TITAN_GE_XDMA_BUFADDRPRE   0x5018  /* XDMA Buffer Address Prefix */
+#define TITAN_GE_XDMA_DESCADDRPRE  0x501C  /* XDMA Descriptor Address Prefix */
+#define TITAN_GE_XDMA_PORTWEIGHT   0x502C  /* XDMA Port Weight Configuration */
+
+/* Rx MAC defines */
+#define TITAN_GE_RMAC_CONFIG_1               0x1200  /* RMAC Configuration 1 */
+#define TITAN_GE_RMAC_CONFIG_2               0x1204  /* RMAC Configuration 2 */
+#define TITAN_GE_RMAC_MAX_FRAME_LEN          0x1208  /* RMAC Max Frame Length */
+#define TITAN_GE_RMAC_STATION_HI             0x120C  /* Rx Station Address High */
+#define TITAN_GE_RMAC_STATION_MID            0x1210  /* Rx Station Address Middle */
+#define TITAN_GE_RMAC_STATION_LOW            0x1214  /* Rx Station Address Low */
+#define TITAN_GE_RMAC_LINK_CONFIG            0x1218  /* RMAC Link Configuration */
+
+/* Tx MAC defines */
+#define TITAN_GE_TMAC_CONFIG_1               0x1240  /* TMAC Configuration 1 */
+#define TITAN_GE_TMAC_CONFIG_2               0x1244  /* TMAC Configuration 2 */
+#define TITAN_GE_TMAC_IPG                    0x1248  /* TMAC Inter-Packet Gap */
+#define TITAN_GE_TMAC_STATION_HI             0x124C  /* Tx Station Address High */
+#define TITAN_GE_TMAC_STATION_MID            0x1250  /* Tx Station Address Middle */
+#define TITAN_GE_TMAC_STATION_LOW            0x1254  /* Tx Station Address Low */
+#define TITAN_GE_TMAC_MAX_FRAME_LEN          0x1258  /* TMAC Max Frame Length */
+#define TITAN_GE_TMAC_MIN_FRAME_LEN          0x125C  /* TMAC Min Frame Length */
+#define TITAN_GE_TMAC_PAUSE_FRAME_TIME       0x1260  /* TMAC Pause Frame Time */
+#define TITAN_GE_TMAC_PAUSE_FRAME_INTERVAL   0x1264  /* TMAC Pause Frame Interval */
+
+/* GMII register */
+#define TITAN_GE_GMII_INTERRUPT_STATUS       0x1348  /* GMII Interrupt Status */
+#define TITAN_GE_GMII_CONFIG_GENERAL         0x134C  /* GMII Configuration General */
+#define TITAN_GE_GMII_CONFIG_MODE            0x1350  /* GMII Configuration Mode */
+
+/* Tx and Rx XDMA defines */
+#define	TITAN_GE_INT_COALESCING		     0x5030 /* Interrupt Coalescing */
+#define	TITAN_GE_CHANNEL0_CONFIG	     0x5040 /* Channel 0 XDMA config */
+#define	TITAN_GE_CHANNEL0_INTERRUPT	     0x504c /* Channel 0 Interrupt Status */
+#define	TITAN_GE_GDI_INTERRUPT_ENABLE        0x5050 /* IE for the GDI Errors */
+#define	TITAN_GE_CHANNEL0_PACKET	     0x5060 /* Channel 0 Packet count */
+#define	TITAN_GE_CHANNEL0_BYTE		     0x5064 /* Channel 0 Byte count */
+#define	TITAN_GE_CHANNEL0_TX_DESC	     0x5054 /* Channel 0 Tx first desc */
+#define	TITAN_GE_CHANNEL0_RX_DESC	     0x5058 /* Channel 0 Rx first desc */
+
+/* AFX (Address Filter Exact) register offsets for Slice 0 */
+#define TITAN_GE_AFX_EXACT_MATCH_LOW         0x1100  /* AFX Exact Match Address Low*/
+#define TITAN_GE_AFX_EXACT_MATCH_MID         0x1104  /* AFX Exact Match Address Mid*/
+#define TITAN_GE_AFX_EXACT_MATCH_HIGH        0x1108  /* AFX Exact Match Address Hi */
+#define TITAN_GE_AFX_EXACT_MATCH_VID         0x110C  /* AFX Exact Match VID */
+#define TITAN_GE_AFX_MULTICAST_HASH_LOW      0x1110  /* AFX Multicast HASH Low */
+#define TITAN_GE_AFX_MULTICAST_HASH_MIDLOW   0x1114  /* AFX Multicast HASH MidLow */
+#define TITAN_GE_AFX_MULTICAST_HASH_MIDHI    0x1118  /* AFX Multicast HASH MidHi */
+#define TITAN_GE_AFX_MULTICAST_HASH_HI       0x111C  /* AFX Multicast HASH Hi */
+#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_0     0x1120  /* AFX Address Filter Ctrl 0 */
+#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_1     0x1124  /* AFX Address Filter Ctrl 1 */
+#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_2     0x1128  /* AFX Address Filter Ctrl 2 */
+
+/* Traffic Groomer block */
+#define        TITAN_GE_TRTG_CONFIG	     0x1000  /* TRTG Config */
+
+#endif 				/* _TITAN_GE_H_ */
+
diff -Nur linux-2.6.29.1/drivers/net/titan_mdio.c linux-2.6.29.1-lemote/drivers/net/titan_mdio.c
--- linux-2.6.29.1/drivers/net/titan_mdio.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/net/titan_mdio.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,217 @@
+/*
+ * drivers/net/titan_mdio.c - Driver for Titan ethernet ports
+ *
+ * Copyright (C) 2003 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * Management Data IO (MDIO) driver for the Titan GMII. Interacts with the Marvel PHY
+ * on the Titan. No support for the TBI as yet.
+ *
+ */
+
+#include	"titan_mdio.h"
+
+#define MDIO_DEBUG
+
+/*
+ * Local constants
+ */
+#define MAX_CLKA            1023
+#define MAX_PHY_DEV         31
+#define MAX_PHY_REG         31
+#define WRITEADDRS_OPCODE   0x0
+#define	READ_OPCODE	    0x2
+#define WRITE_OPCODE        0x1
+#define MAX_MDIO_POLL       100
+
+/*
+ * Titan MDIO and SCMB registers
+ */
+#define TITAN_GE_SCMB_CONTROL                0x01c0  /* SCMB Control */
+#define TITAN_GE_SCMB_CLKA	             0x01c4  /* SCMB Clock A */
+#define TITAN_GE_MDIO_COMMAND                0x01d0  /* MDIO Command */
+#define TITAN_GE_MDIO_DEVICE_PORT_ADDRESS    0x01d4  /* MDIO Device and Port addrs */
+#define TITAN_GE_MDIO_DATA                   0x01d8  /* MDIO Data */
+#define TITAN_GE_MDIO_INTERRUPTS             0x01dC  /* MDIO Interrupts */
+
+/*
+ * Function to poll the MDIO
+ */
+static int titan_ge_mdio_poll(void)
+{
+	int	i, val;
+
+	for (i = 0; i < MAX_MDIO_POLL; i++) {
+		val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+
+		if (!(val & 0x8000))
+			return TITAN_GE_MDIO_GOOD;
+	}
+
+	return TITAN_GE_MDIO_ERROR;
+}
+
+
+/*
+ * Initialize and configure the MDIO
+ */
+int titan_ge_mdio_setup(titan_ge_mdio_config *titan_mdio)
+{
+	unsigned long	val;
+
+	/* Reset the SCMB and program into MDIO mode*/
+	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CONTROL, 0x9000);
+	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CONTROL, 0x1000);
+
+	/* CLK A */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_SCMB_CLKA);
+	val = ( (val & ~(0x03ff)) | (titan_mdio->clka & 0x03ff));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CLKA, val);
+
+	/* Preamble Suppresion */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0001)) | (titan_mdio->mdio_spre & 0x0001));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	/* MDIO mode */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x4000)) | (titan_mdio->mdio_mode & 0x4000));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
+/*
+ * Set the PHY address in indirect mode
+ */
+int titan_ge_mdio_inaddrs(int dev_addr, int reg_addr)
+{
+	volatile unsigned long	val;
+
+	/* Setup the PHY device */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
+	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	/* Write the new address */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0300)) | ( (WRITEADDRS_OPCODE << 8) & 0x0300));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
+/*
+ * Read the MDIO register. This is what the individual parametes mean:
+ *
+ * dev_addr : PHY ID
+ * reg_addr : register offset
+ *
+ * See the spec for the Titan MAC. We operate in the Direct Mode.
+ */
+
+#define MAX_RETRIES	2
+
+int titan_ge_mdio_read(int dev_addr, int reg_addr, unsigned int *pdata)
+{
+	volatile unsigned long	val;
+	int retries = 0;
+
+	/* Setup the PHY device */
+
+again:
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
+	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
+	val |= 0x4000;
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	udelay(30);
+
+	/* Issue the read command */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0300)) | ( (READ_OPCODE << 8) & 0x0300));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	udelay(30);
+
+	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
+		return TITAN_GE_MDIO_ERROR;
+
+	*pdata = (unsigned int)TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DATA);
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_INTERRUPTS);
+
+	udelay(30);
+
+	if (val & 0x2) {
+		if (retries == MAX_RETRIES)
+			return TITAN_GE_MDIO_ERROR;
+		else {
+			retries++;
+			goto again;
+		}
+	}
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
+/*
+ * Write to the MDIO register
+ *
+ * dev_addr : PHY ID
+ * reg_addr : register that needs to be written to
+ *
+ */
+int titan_ge_mdio_write(int dev_addr, int reg_addr, unsigned int data)
+{
+	volatile unsigned long	val;
+
+	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
+		return TITAN_GE_MDIO_ERROR;
+
+	/* Setup the PHY device */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
+	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
+	val |= 0x4000;
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	udelay(30);
+
+	/* Setup the data to write */
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DATA, data);
+
+	udelay(30);
+
+	/* Issue the write command */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0300)) | ( (WRITE_OPCODE << 8) & 0x0300));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	udelay(30);
+
+	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
+		return TITAN_GE_MDIO_ERROR;
+
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_INTERRUPTS);
+	if (val & 0x2)
+		return TITAN_GE_MDIO_ERROR;
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
diff -Nur linux-2.6.29.1/drivers/net/titan_mdio.h linux-2.6.29.1-lemote/drivers/net/titan_mdio.h
--- linux-2.6.29.1/drivers/net/titan_mdio.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/net/titan_mdio.h	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,56 @@
+/*
+ * MDIO used to interact with the PHY when using GMII/MII
+ */
+#ifndef _TITAN_MDIO_H
+#define _TITAN_MDIO_H
+
+#include <linux/netdevice.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include "titan_ge.h"
+
+
+#define	TITAN_GE_MDIO_ERROR	(-9000)
+#define	TITAN_GE_MDIO_GOOD	0
+
+#define	TITAN_GE_MDIO_BASE		titan_ge_base
+
+#define	TITAN_GE_MDIO_READ(offset)	\
+	*(volatile u32 *)(titan_ge_base + (offset))
+
+#define	TITAN_GE_MDIO_WRITE(offset, data)	\
+	*(volatile u32 *)(titan_ge_base + (offset)) = (data)
+
+
+/* GMII specific registers */
+#define	TITAN_GE_MARVEL_PHY_ID		0x00
+#define	TITAN_PHY_AUTONEG_ADV		0x04
+#define	TITAN_PHY_LP_ABILITY		0x05
+#define	TITAN_GE_MDIO_MII_CTRL		0x09
+#define	TITAN_GE_MDIO_MII_EXTENDED	0x0f
+#define	TITAN_GE_MDIO_PHY_CTRL		0x10
+#define	TITAN_GE_MDIO_PHY_STATUS	0x11
+#define	TITAN_GE_MDIO_PHY_IE		0x12
+#define	TITAN_GE_MDIO_PHY_IS		0x13
+#define	TITAN_GE_MDIO_PHY_LED		0x18
+#define	TITAN_GE_MDIO_PHY_LED_OVER	0x19
+#define	PHY_ANEG_TIME_WAIT		45	/* 45 seconds wait time */
+
+/*
+ * MDIO Config Structure
+ */
+typedef struct {
+	unsigned int		clka;
+	int			mdio_spre;
+	int			mdio_mode;
+} titan_ge_mdio_config;
+
+/*
+ * Function Prototypes
+ */
+int titan_ge_mdio_setup(titan_ge_mdio_config *);
+int titan_ge_mdio_inaddrs(int, int);
+int titan_ge_mdio_read(int, int, unsigned int *);
+int titan_ge_mdio_write(int, int, unsigned int);
+
+#endif /* _TITAN_MDIO_H */
diff -Nur linux-2.6.29.1/drivers/rtc/rtc-cmos.c linux-2.6.29.1-lemote/drivers/rtc/rtc-cmos.c
--- linux-2.6.29.1/drivers/rtc/rtc-cmos.c	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/rtc/rtc-cmos.c	2009-04-07 09:39:28.000000000 +0000
@@ -757,7 +757,7 @@
 	 * <asm-generic/rtc.h> doesn't know 12-hour mode either.
 	 */
 	if (is_valid_irq(rtc_irq) &&
-	    (!(rtc_control & RTC_24H) || (rtc_control & (RTC_DM_BINARY)))) {
+	    (!(rtc_control & RTC_24H) /*|| (rtc_control & (RTC_DM_BINARY))*/)) {
 		dev_dbg(dev, "only 24-hr BCD mode supported\n");
 		retval = -ENXIO;
 		goto cleanup1;
diff -Nur linux-2.6.29.1/drivers/video/Kconfig linux-2.6.29.1-lemote/drivers/video/Kconfig
--- linux-2.6.29.1/drivers/video/Kconfig	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/video/Kconfig	2009-04-07 09:39:28.000000000 +0000
@@ -1943,6 +1943,29 @@
 	  Turn on debugging messages. Note that you can set/unset at run time
 	  through sysfs
 
+config FB_SILICONMOTION
+	bool "Silicon Motion Display Support"
+	depends on FB
+	---help---
+	  Frame Buffer driver for the Silicon Motion serial graphic card.
+
+config FB_SM7XX
+	bool "Silicon Motion SM7XX Frame Buffer Support"
+	depends on FB_SILICONMOTION
+	depends on FB
+ 	select FB_CFB_FILLRECT
+ 	select FB_CFB_COPYAREA
+ 	select FB_CFB_IMAGEBLIT
+	---help---
+	  Frame Buffer driver for the Silicon Motion SM7XX serial graphic card.
+
+config FB_SM7XX_ACCEL
+	bool "Siliconmotion Acceleration functions (EXPERIMENTAL)"
+	depends on FB_SM7XX && EXPERIMENTAL
+	---help---
+	This will compile the Trident frame buffer device with
+	acceleration functions.
+
 config FB_SM501
 	tristate "Silicon Motion SM501 framebuffer support"
 	depends on FB && MFD_SM501
diff -Nur linux-2.6.29.1/drivers/video/Makefile linux-2.6.29.1-lemote/drivers/video/Makefile
--- linux-2.6.29.1/drivers/video/Makefile	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/video/Makefile	2009-04-07 09:39:28.000000000 +0000
@@ -71,6 +71,7 @@
 obj-$(CONFIG_FB_TCX)              += tcx.o sbuslib.o
 obj-$(CONFIG_FB_LEO)              += leo.o sbuslib.o
 obj-$(CONFIG_FB_SGIVW)            += sgivwfb.o
+obj-$(CONFIG_FB_SILICONMOTION)	  += smi/
 obj-$(CONFIG_FB_ACORN)            += acornfb.o
 obj-$(CONFIG_FB_ATARI)            += atafb.o c2p_iplan2.o atafb_mfb.o \
                                      atafb_iplan2p2.o atafb_iplan2p4.o atafb_iplan2p8.o
diff -Nur linux-2.6.29.1/drivers/video/smi/Makefile linux-2.6.29.1-lemote/drivers/video/smi/Makefile
--- linux-2.6.29.1/drivers/video/smi/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/video/smi/Makefile	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,6 @@
+obj-y +=  smi.o
+
+smi-y := $(DRIVER_OBJS)
+
+smi-y +=smtcfb.o
+
diff -Nur linux-2.6.29.1/drivers/video/smi/sm501hw.h linux-2.6.29.1-lemote/drivers/video/smi/sm501hw.h
--- linux-2.6.29.1/drivers/video/smi/sm501hw.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/video/smi/sm501hw.h	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,2160 @@
+/*
+ *  linux/drivers/video/sm501hw.h -- Silicon Motion SM501 frame buffer device
+ *
+ *      Copyright (C) 2006 Silicon Motion, Inc.
+ *      Ge Wang, gewang@siliconmotion.com
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+
+#define SM501_VIDEOMEMORYSIZE    0x00800000  /*Assume SMTC graphics chip has 8MB VRAM */
+#define SM502_REV_ID             0xC0
+
+/*
+ *
+ * Definitions for the System Configuration registers.
+ *
+ */
+
+#define SYSTEM_CTRL                                     0x000000
+#define SYSTEM_CTRL_DPMS                                31:30
+#define SYSTEM_CTRL_DPMS_VPHP                           0
+#define SYSTEM_CTRL_DPMS_VPHN                           1
+#define SYSTEM_CTRL_DPMS_VNHP                           2
+#define SYSTEM_CTRL_DPMS_VNHN                           3
+#define SYSTEM_CTRL_PCI_BURST                           29:29
+#define SYSTEM_CTRL_PCI_BURST_DISABLE                   0
+#define SYSTEM_CTRL_PCI_BURST_ENABLE                    1
+#define SYSTEM_CTRL_CSC_STATUS                          28:28
+#define SYSTEM_CTRL_CSC_STATUS_IDLE                     0
+#define SYSTEM_CTRL_CSC_STATUS_BUSY                     1
+#define SYSTEM_CTRL_PCI_MASTER                          25:25
+#define SYSTEM_CTRL_PCI_MASTER_STOP                     0
+#define SYSTEM_CTRL_PCI_MASTER_START                    1
+#define SYSTEM_CTRL_LATENCY_TIMER                       24:24
+#define SYSTEM_CTRL_LATENCY_TIMER_ENABLE                0
+#define SYSTEM_CTRL_LATENCY_TIMER_DISABLE               1
+#define SYSTEM_CTRL_PANEL_STATUS                        23:23
+#define SYSTEM_CTRL_PANEL_STATUS_CURRENT                0
+#define SYSTEM_CTRL_PANEL_STATUS_PENDING                1
+#define SYSTEM_CTRL_VIDEO_STATUS                        22:22
+#define SYSTEM_CTRL_VIDEO_STATUS_CURRENT                0
+#define SYSTEM_CTRL_VIDEO_STATUS_PENDING                1
+#define SYSTEM_CTRL_DE_FIFO                             20:20
+#define SYSTEM_CTRL_DE_FIFO_NOT_EMPTY                   0
+#define SYSTEM_CTRL_DE_FIFO_EMPTY                       1
+#define SYSTEM_CTRL_DE_STATUS                           19:19
+#define SYSTEM_CTRL_DE_STATUS_IDLE                      0
+#define SYSTEM_CTRL_DE_STATUS_BUSY                      1
+#define SYSTEM_CTRL_CRT_STATUS                          17:17
+#define SYSTEM_CTRL_CRT_STATUS_CURRENT                  0
+#define SYSTEM_CTRL_CRT_STATUS_PENDING                  1
+#define SYSTEM_CTRL_ZVPORT                              16:16
+#define SYSTEM_CTRL_ZVPORT_0                            0
+#define SYSTEM_CTRL_ZVPORT_1                            1
+#define SYSTEM_CTRL_PCI_BURST_READ                      15:15
+#define SYSTEM_CTRL_PCI_BURST_READ_DISABLE              0
+#define SYSTEM_CTRL_PCI_BURST_READ_ENABLE               1
+#define SYSTEM_CTRL_DE_ABORT                            13:12
+#define SYSTEM_CTRL_DE_ABORT_NORMAL                     0
+#define SYSTEM_CTRL_DE_ABORT_2D_ABORT                   3
+#define SYSTEM_CTRL_PCI_SUBSYS_LOCK                     11:11
+#define SYSTEM_CTRL_PCI_SUBSYS_LOCK_DISABLE             0
+#define SYSTEM_CTRL_PCI_SUBSYS_LOCK_ENABLE              1
+#define SYSTEM_CTRL_PCI_RETRY                           7:7
+#define SYSTEM_CTRL_PCI_RETRY_ENABLE                    0
+#define SYSTEM_CTRL_PCI_RETRY_DISABLE                   1
+#define SYSTEM_CTRL_PCI_CLOCK_RUN                       6:6
+#define SYSTEM_CTRL_PCI_CLOCK_RUN_DISABLE               0
+#define SYSTEM_CTRL_PCI_CLOCK_RUN_ENABLE                1
+#define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE           5:4
+#define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_1         0
+#define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_2         1
+#define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_4         2
+#define SYSTEM_CTRL_PCI_SLAVE_BURST_READ_SIZE_8         3
+#define SYSTEM_CTRL_CRT_TRISTATE                        2:2
+#define SYSTEM_CTRL_CRT_TRISTATE_DISABLE                0
+#define SYSTEM_CTRL_CRT_TRISTATE_ENABLE                 1
+#define SYSTEM_CTRL_INTMEM_TRISTATE                     1:1
+#define SYSTEM_CTRL_INTMEM_TRISTATE_DISABLE             0
+#define SYSTEM_CTRL_INTMEM_TRISTATE_ENABLE              1
+#define SYSTEM_CTRL_PANEL_TRISTATE                      0:0
+#define SYSTEM_CTRL_PANEL_TRISTATE_DISABLE              0
+#define SYSTEM_CTRL_PANEL_TRISTATE_ENABLE               1
+
+#define MISC_CTRL                                       0x000004
+#define MISC_CTRL_PCI_PAD                               31:30
+#define MISC_CTRL_PCI_PAD_24MA                          0
+#define MISC_CTRL_PCI_PAD_12MA                          1
+#define MISC_CTRL_PCI_PAD_8MA                           2
+#define MISC_CTRL_48_SELECT                             29:28
+#define MISC_CTRL_48_SELECT_CRYSTAL                     0
+#define MISC_CTRL_48_SELECT_CPU_96                      2
+#define MISC_CTRL_48_SELECT_CPU_48                      3
+#define MISC_CTRL_UART1_SELECT                          27:27
+#define MISC_CTRL_UART1_SELECT_UART                     0
+#define MISC_CTRL_UART1_SELECT_SSP                      1
+#define MISC_CTRL_8051_LATCH                            26:26
+#define MISC_CTRL_8051_LATCH_DISABLE                    0
+#define MISC_CTRL_8051_LATCH_ENABLE                     1
+#define MISC_CTRL_FPDATA                                25:25
+#define MISC_CTRL_FPDATA_18                             0
+#define MISC_CTRL_FPDATA_24                             1
+#define MISC_CTRL_CRYSTAL                               24:24
+#define MISC_CTRL_CRYSTAL_24                            0
+#define MISC_CTRL_CRYSTAL_12                            1
+#define MISC_CTRL_DRAM_REFRESH                          22:21
+#define MISC_CTRL_DRAM_REFRESH_8                        0
+#define MISC_CTRL_DRAM_REFRESH_16                       1
+#define MISC_CTRL_DRAM_REFRESH_32                       2
+#define MISC_CTRL_DRAM_REFRESH_64                       3
+#define MISC_CTRL_BUS_HOLD                              20:18
+#define MISC_CTRL_BUS_HOLD_FIFO_EMPTY                   0
+#define MISC_CTRL_BUS_HOLD_8                            1
+#define MISC_CTRL_BUS_HOLD_16                           2
+#define MISC_CTRL_BUS_HOLD_24                           3
+#define MISC_CTRL_BUS_HOLD_32                           4
+#define MISC_CTRL_HITACHI_READY                         17:17
+#define MISC_CTRL_HITACHI_READY_NEGATIVE                0
+#define MISC_CTRL_HITACHI_READY_POSITIVE                1
+#define MISC_CTRL_INTERRUPT                             16:16
+#define MISC_CTRL_INTERRUPT_NORMAL                      0
+#define MISC_CTRL_INTERRUPT_INVERT                      1
+#define MISC_CTRL_PLL_CLOCK_COUNT                       15:15
+#define MISC_CTRL_PLL_CLOCK_COUNT_DISABLE               0
+#define MISC_CTRL_PLL_CLOCK_COUNT_ENABLE                1
+#define MISC_CTRL_DAC_BAND_GAP                          14:13
+#define MISC_CTRL_DAC_POWER                             12:12
+#define MISC_CTRL_DAC_POWER_ENABLE                      0
+#define MISC_CTRL_DAC_POWER_DISABLE                     1
+#define MISC_CTRL_USB_SLAVE_CONTROLLER                  11:11
+#define MISC_CTRL_USB_SLAVE_CONTROLLER_CPU              0
+#define MISC_CTRL_USB_SLAVE_CONTROLLER_8051             1
+#define MISC_CTRL_BURST_LENGTH                          10:10
+#define MISC_CTRL_BURST_LENGTH_8                        0
+#define MISC_CTRL_BURST_LENGTH_1                        1
+#define MISC_CTRL_USB_SELECT                            9:9
+#define MISC_CTRL_USB_SELECT_MASTER                     0
+#define MISC_CTRL_USB_SELECT_SLAVE                      1
+#define MISC_CTRL_LOOPBACK                              8:8
+#define MISC_CTRL_LOOPBACK_NORMAL                       0
+#define MISC_CTRL_LOOPBACK_USB_HOST                     1
+#define MISC_CTRL_CLOCK_DIVIDER_RESET                   7:7
+#define MISC_CTRL_CLOCK_DIVIDER_RESET_ENABLE            0
+#define MISC_CTRL_CLOCK_DIVIDER_RESET_DISABLE           1
+#define MISC_CTRL_TEST_MODE                             6:5
+#define MISC_CTRL_TEST_MODE_NORMAL                      0
+#define MISC_CTRL_TEST_MODE_DEBUGGING                   1
+#define MISC_CTRL_TEST_MODE_NAND                        2
+#define MISC_CTRL_TEST_MODE_MEMORY                      3
+#define MISC_CTRL_NEC_MMIO                              4:4
+#define MISC_CTRL_NEC_MMIO_30                           0
+#define MISC_CTRL_NEC_MMIO_62                           1
+#define MISC_CTRL_CLOCK                                 3:3
+#define MISC_CTRL_CLOCK_PLL                             0
+#define MISC_CTRL_CLOCK_TEST                            1
+#define MISC_CTRL_HOST_BUS                              2:0
+#define MISC_CTRL_HOST_BUS_HITACHI                      0
+#define MISC_CTRL_HOST_BUS_PCI                          1
+#define MISC_CTRL_HOST_BUS_XSCALE                       2
+#define MISC_CTRL_HOST_BUS_STRONGARM                    4
+#define MISC_CTRL_HOST_BUS_NEC                          6
+
+#define GPIO_MUX_LOW                                    0x000008
+#define GPIO_MUX_LOW_31                                 31:31
+#define GPIO_MUX_LOW_31_GPIO                            0
+#define GPIO_MUX_LOW_31_PWM                             1
+#define GPIO_MUX_LOW_30                                 30:30
+#define GPIO_MUX_LOW_30_GPIO                            0
+#define GPIO_MUX_LOW_30_PWM                             1
+#define GPIO_MUX_LOW_29                                 29:29
+#define GPIO_MUX_LOW_29_GPIO                            0
+#define GPIO_MUX_LOW_29_PWM                             1
+#define GPIO_MUX_LOW_28                                 28:28
+#define GPIO_MUX_LOW_28_GPIO                            0
+#define GPIO_MUX_LOW_28_AC97_I2S                        1
+#define GPIO_MUX_LOW_27                                 27:27
+#define GPIO_MUX_LOW_27_GPIO                            0
+#define GPIO_MUX_LOW_27_AC97_I2S                        1
+#define GPIO_MUX_LOW_26                                 26:26
+#define GPIO_MUX_LOW_26_GPIO                            0
+#define GPIO_MUX_LOW_26_AC97_I2S                        1
+#define GPIO_MUX_LOW_25                                 25:25
+#define GPIO_MUX_LOW_25_GPIO                            0
+#define GPIO_MUX_LOW_25_AC97_I2S                        1
+#define GPIO_MUX_LOW_24                                 24:24
+#define GPIO_MUX_LOW_24_GPIO                            0
+#define GPIO_MUX_LOW_24_AC97                            1
+#define GPIO_MUX_LOW_23                                 23:23
+#define GPIO_MUX_LOW_23_GPIO                            0
+#define GPIO_MUX_LOW_23_ZVPORT                          1
+#define GPIO_MUX_LOW_22                                 22:22
+#define GPIO_MUX_LOW_22_GPIO                            0
+#define GPIO_MUX_LOW_22_ZVPORT                          1
+#define GPIO_MUX_LOW_21                                 21:21
+#define GPIO_MUX_LOW_21_GPIO                            0
+#define GPIO_MUX_LOW_21_ZVPORT                          1
+#define GPIO_MUX_LOW_20                                 20:20
+#define GPIO_MUX_LOW_20_GPIO                            0
+#define GPIO_MUX_LOW_20_ZVPORT                          1
+#define GPIO_MUX_LOW_19                                 19:19
+#define GPIO_MUX_LOW_19_GPIO                            0
+#define GPIO_MUX_LOW_19_ZVPORT                          1
+#define GPIO_MUX_LOW_18                                 18:18
+#define GPIO_MUX_LOW_18_GPIO                            0
+#define GPIO_MUX_LOW_18_ZVPORT                          1
+#define GPIO_MUX_LOW_17                                 17:17
+#define GPIO_MUX_LOW_17_GPIO                            0
+#define GPIO_MUX_LOW_17_ZVPORT                          1
+#define GPIO_MUX_LOW_16                                 16:16
+#define GPIO_MUX_LOW_16_GPIO                            0
+#define GPIO_MUX_LOW_16_ZVPORT                          1
+#define GPIO_MUX_LOW_15                                 15:15
+#define GPIO_MUX_LOW_15_GPIO                            0
+#define GPIO_MUX_LOW_15_8051                            1
+#define GPIO_MUX_LOW_14                                 14:14
+#define GPIO_MUX_LOW_14_GPIO                            0
+#define GPIO_MUX_LOW_14_8051                            1
+#define GPIO_MUX_LOW_13                                 13:13
+#define GPIO_MUX_LOW_13_GPIO                            0
+#define GPIO_MUX_LOW_13_8051                            1
+#define GPIO_MUX_LOW_12                                 12:12
+#define GPIO_MUX_LOW_12_GPIO                            0
+#define GPIO_MUX_LOW_12_8051                            1
+#define GPIO_MUX_LOW_11                                 11:11
+#define GPIO_MUX_LOW_11_GPIO                            0
+#define GPIO_MUX_LOW_11_8051                            1
+#define GPIO_MUX_LOW_10                                 10:10
+#define GPIO_MUX_LOW_10_GPIO                            0
+#define GPIO_MUX_LOW_10_8051                            1
+#define GPIO_MUX_LOW_9                                  9:9
+#define GPIO_MUX_LOW_9_GPIO                             0
+#define GPIO_MUX_LOW_9_8051                             1
+#define GPIO_MUX_LOW_8                                  8:8
+#define GPIO_MUX_LOW_8_GPIO                             0
+#define GPIO_MUX_LOW_8_8051                             1
+#define GPIO_MUX_LOW_7                                  7:7
+#define GPIO_MUX_LOW_7_GPIO                             0
+#define GPIO_MUX_LOW_7_8051                             1
+#define GPIO_MUX_LOW_6                                  6:6
+#define GPIO_MUX_LOW_6_GPIO                             0
+#define GPIO_MUX_LOW_6_8051                             1
+#define GPIO_MUX_LOW_5                                  5:5
+#define GPIO_MUX_LOW_5_GPIO                             0
+#define GPIO_MUX_LOW_5_8051                             1
+#define GPIO_MUX_LOW_4                                  4:4
+#define GPIO_MUX_LOW_4_GPIO                             0
+#define GPIO_MUX_LOW_4_8051                             1
+#define GPIO_MUX_LOW_3                                  3:3
+#define GPIO_MUX_LOW_3_GPIO                             0
+#define GPIO_MUX_LOW_3_8051                             1
+#define GPIO_MUX_LOW_2                                  2:2
+#define GPIO_MUX_LOW_2_GPIO                             0
+#define GPIO_MUX_LOW_2_8051                             1
+#define GPIO_MUX_LOW_1                                  1:1
+#define GPIO_MUX_LOW_1_GPIO                             0
+#define GPIO_MUX_LOW_1_8051                             1
+#define GPIO_MUX_LOW_0                                  0:0
+#define GPIO_MUX_LOW_0_GPIO                             0
+#define GPIO_MUX_LOW_0_8051                             1
+
+#define GPIO_MUX_HIGH                                   0x00000C
+#define GPIO_MUX_HIGH_63                                31:31
+#define GPIO_MUX_HIGH_63_GPIO                           0
+#define GPIO_MUX_HIGH_63_CRT_ZVPORT_FPDATA              1
+#define GPIO_MUX_HIGH_62                                30:30
+#define GPIO_MUX_HIGH_62_GPIO                           0
+#define GPIO_MUX_HIGH_62_CRT_ZVPORT_FPDATA              1
+#define GPIO_MUX_HIGH_61                                29:29
+#define GPIO_MUX_HIGH_61_GPIO                           0
+#define GPIO_MUX_HIGH_61_CRT_ZVPORT_FPDATA              1
+#define GPIO_MUX_HIGH_60                                28:28
+#define GPIO_MUX_HIGH_60_GPIO                           0
+#define GPIO_MUX_HIGH_60_CRT_ZVPORT_FPDATA              1
+#define GPIO_MUX_HIGH_59                                27:27
+#define GPIO_MUX_HIGH_59_GPIO                           0
+#define GPIO_MUX_HIGH_59_CRT_ZVPORT_FPDATA              1
+#define GPIO_MUX_HIGH_58                                26:26
+#define GPIO_MUX_HIGH_58_GPIO                           0
+#define GPIO_MUX_HIGH_58_CRT_ZVPORT_FPDATA              1
+#define GPIO_MUX_HIGH_57                                25:25
+#define GPIO_MUX_HIGH_57_GPIO                           0
+#define GPIO_MUX_HIGH_57_CRT_ZVPORT                     1
+#define GPIO_MUX_HIGH_56                                24:24
+#define GPIO_MUX_HIGH_56_GPIO                           0
+#define GPIO_MUX_HIGH_56_CRT_ZVPORT                     1
+#define GPIO_MUX_HIGH_55                                23:23
+#define GPIO_MUX_HIGH_55_GPIO                           0
+#define GPIO_MUX_HIGH_55_CRT                            1
+#define GPIO_MUX_HIGH_47                                15:15
+#define GPIO_MUX_HIGH_47_GPIO                           0
+#define GPIO_MUX_HIGH_47_I2C                            1
+#define GPIO_MUX_HIGH_46                                14:14
+#define GPIO_MUX_HIGH_46_GPIO                           0
+#define GPIO_MUX_HIGH_46_I2C                            1
+#define GPIO_MUX_HIGH_45                                13:13
+#define GPIO_MUX_HIGH_45_GPIO                           0
+#define GPIO_MUX_HIGH_45_SSP1                           1
+#define GPIO_MUX_HIGH_44                                12:12
+#define GPIO_MUX_HIGH_44_GPIO                           0
+#define GPIO_MUX_HIGH_44_UART1_SSP1                     1
+#define GPIO_MUX_HIGH_43                                11:11
+#define GPIO_MUX_HIGH_43_GPIO                           0
+#define GPIO_MUX_HIGH_43_UART1_SSP1                     1
+#define GPIO_MUX_HIGH_42                                10:10
+#define GPIO_MUX_HIGH_42_GPIO                           0
+#define GPIO_MUX_HIGH_42_UART1_SSP1                     1
+#define GPIO_MUX_HIGH_41                                9:9
+#define GPIO_MUX_HIGH_41_GPIO                           0
+#define GPIO_MUX_HIGH_41_UART1_SSP1                     1
+#define GPIO_MUX_HIGH_40                                8:8
+#define GPIO_MUX_HIGH_40_GPIO                           0
+#define GPIO_MUX_HIGH_40_UART0                          1
+#define GPIO_MUX_HIGH_39                                7:7
+#define GPIO_MUX_HIGH_39_GPIO                           0
+#define GPIO_MUX_HIGH_39_UART0                          1
+#define GPIO_MUX_HIGH_38                                6:6
+#define GPIO_MUX_HIGH_38_GPIO                           0
+#define GPIO_MUX_HIGH_38_UART0                          1
+#define GPIO_MUX_HIGH_37                                5:5
+#define GPIO_MUX_HIGH_37_GPIO                           0
+#define GPIO_MUX_HIGH_37_UART0                          1
+#define GPIO_MUX_HIGH_36                                4:4
+#define GPIO_MUX_HIGH_36_GPIO                           0
+#define GPIO_MUX_HIGH_36_SSP0                           1
+#define GPIO_MUX_HIGH_35                                3:3
+#define GPIO_MUX_HIGH_35_GPIO                           0
+#define GPIO_MUX_HIGH_35_SSP0                           1
+#define GPIO_MUX_HIGH_34                                2:2
+#define GPIO_MUX_HIGH_34_GPIO                           0
+#define GPIO_MUX_HIGH_34_SSP0                           1
+#define GPIO_MUX_HIGH_33                                1:1
+#define GPIO_MUX_HIGH_33_GPIO                           0
+#define GPIO_MUX_HIGH_33_SSP0                           1
+#define GPIO_MUX_HIGH_32                                0:0
+#define GPIO_MUX_HIGH_32_GPIO                           0
+#define GPIO_MUX_HIGH_32_SSP0                           1
+
+#define DRAM_CTRL                                       0x000010
+#define DRAM_CTRL_EMBEDDED                              31:31
+#define DRAM_CTRL_EMBEDDED_ENABLE                       0
+#define DRAM_CTRL_EMBEDDED_DISABLE                      1
+#define DRAM_CTRL_CPU_BURST                             30:28
+#define DRAM_CTRL_CPU_BURST_1                           0
+#define DRAM_CTRL_CPU_BURST_2                           1
+#define DRAM_CTRL_CPU_BURST_4                           2
+#define DRAM_CTRL_CPU_BURST_8                           3
+#define DRAM_CTRL_CPU_CAS_LATENCY                       27:27
+#define DRAM_CTRL_CPU_CAS_LATENCY_2                     0
+#define DRAM_CTRL_CPU_CAS_LATENCY_3                     1
+#define DRAM_CTRL_CPU_SIZE                              26:24
+#define DRAM_CTRL_CPU_SIZE_2                            0
+#define DRAM_CTRL_CPU_SIZE_4                            1
+#define DRAM_CTRL_CPU_SIZE_64                           4
+#define DRAM_CTRL_CPU_SIZE_32                           5
+#define DRAM_CTRL_CPU_SIZE_16                           6
+#define DRAM_CTRL_CPU_SIZE_8                            7
+#define DRAM_CTRL_CPU_COLUMN_SIZE                       23:22
+#define DRAM_CTRL_CPU_COLUMN_SIZE_1024                  0
+#define DRAM_CTRL_CPU_COLUMN_SIZE_512                   2
+#define DRAM_CTRL_CPU_COLUMN_SIZE_256                   3
+#define DRAM_CTRL_CPU_ACTIVE_PRECHARGE                  21:21
+#define DRAM_CTRL_CPU_ACTIVE_PRECHARGE_6                0
+#define DRAM_CTRL_CPU_ACTIVE_PRECHARGE_7                1
+#define DRAM_CTRL_CPU_RESET                             20:20
+#define DRAM_CTRL_CPU_RESET_ENABLE                      0
+#define DRAM_CTRL_CPU_RESET_DISABLE                     1
+#define DRAM_CTRL_CPU_BANKS                             19:19
+#define DRAM_CTRL_CPU_BANKS_2                           0
+#define DRAM_CTRL_CPU_BANKS_4                           1
+#define DRAM_CTRL_CPU_WRITE_PRECHARGE                   18:18
+#define DRAM_CTRL_CPU_WRITE_PRECHARGE_2                 0
+#define DRAM_CTRL_CPU_WRITE_PRECHARGE_1                 1
+#define DRAM_CTRL_BLOCK_WRITE                           17:17
+#define DRAM_CTRL_BLOCK_WRITE_DISABLE                   0
+#define DRAM_CTRL_BLOCK_WRITE_ENABLE                    1
+#define DRAM_CTRL_REFRESH_COMMAND                       16:16
+#define DRAM_CTRL_REFRESH_COMMAND_10                    0
+#define DRAM_CTRL_REFRESH_COMMAND_12                    1
+#define DRAM_CTRL_SIZE                                  15:13
+#define DRAM_CTRL_SIZE_4                                0
+#define DRAM_CTRL_SIZE_8                                1
+#define DRAM_CTRL_SIZE_16                               2
+#define DRAM_CTRL_SIZE_32                               3
+#define DRAM_CTRL_SIZE_64                               4
+#define DRAM_CTRL_SIZE_2                                5
+#define DRAM_CTRL_COLUMN_SIZE                           12:11
+#define DRAM_CTRL_COLUMN_SIZE_256                       0
+#define DRAM_CTRL_COLUMN_SIZE_512                       2
+#define DRAM_CTRL_COLUMN_SIZE_1024                      3
+#define DRAM_CTRL_BLOCK_WRITE_TIME                      10:10
+#define DRAM_CTRL_BLOCK_WRITE_TIME_1                    0
+#define DRAM_CTRL_BLOCK_WRITE_TIME_2                    1
+#define DRAM_CTRL_BLOCK_WRITE_PRECHARGE                 9:9
+#define DRAM_CTRL_BLOCK_WRITE_PRECHARGE_4               0
+#define DRAM_CTRL_BLOCK_WRITE_PRECHARGE_1               1
+#define DRAM_CTRL_ACTIVE_PRECHARGE                      8:8
+#define DRAM_CTRL_ACTIVE_PRECHARGE_6                    0
+#define DRAM_CTRL_ACTIVE_PRECHARGE_7                    1
+#define DRAM_CTRL_RESET                                 7:7
+#define DRAM_CTRL_RESET_ENABLE                          0
+#define DRAM_CTRL_RESET_DISABLE                         1
+#define DRAM_CTRL_REMAIN_ACTIVE                         6:6
+#define DRAM_CTRL_REMAIN_ACTIVE_ENABLE                  0
+#define DRAM_CTRL_REMAIN_ACTIVE_DISABLE                 1
+#define DRAM_CTRL_BANKS                                 1:1
+#define DRAM_CTRL_BANKS_2                               0
+#define DRAM_CTRL_BANKS_4                               1
+#define DRAM_CTRL_WRITE_PRECHARGE                       0:0
+#define DRAM_CTRL_WRITE_PRECHARGE_2                     0
+#define DRAM_CTRL_WRITE_PRECHARGE_1                     1
+
+#define ARBITRATION_CTRL                                0x000014
+#define ARBITRATION_CTRL_CPUMEM                         29:29
+#define ARBITRATION_CTRL_CPUMEM_FIXED                   0
+#define ARBITRATION_CTRL_CPUMEM_ROTATE                  1
+#define ARBITRATION_CTRL_INTMEM                         28:28
+#define ARBITRATION_CTRL_INTMEM_FIXED                   0
+#define ARBITRATION_CTRL_INTMEM_ROTATE                  1
+#define ARBITRATION_CTRL_USB                            27:24
+#define ARBITRATION_CTRL_USB_OFF                        0
+#define ARBITRATION_CTRL_USB_PRIORITY_1                 1
+#define ARBITRATION_CTRL_USB_PRIORITY_2                 2
+#define ARBITRATION_CTRL_USB_PRIORITY_3                 3
+#define ARBITRATION_CTRL_USB_PRIORITY_4                 4
+#define ARBITRATION_CTRL_USB_PRIORITY_5                 5
+#define ARBITRATION_CTRL_USB_PRIORITY_6                 6
+#define ARBITRATION_CTRL_USB_PRIORITY_7                 7
+#define ARBITRATION_CTRL_PANEL                          23:20
+#define ARBITRATION_CTRL_PANEL_OFF                      0
+#define ARBITRATION_CTRL_PANEL_PRIORITY_1               1
+#define ARBITRATION_CTRL_PANEL_PRIORITY_2               2
+#define ARBITRATION_CTRL_PANEL_PRIORITY_3               3
+#define ARBITRATION_CTRL_PANEL_PRIORITY_4               4
+#define ARBITRATION_CTRL_PANEL_PRIORITY_5               5
+#define ARBITRATION_CTRL_PANEL_PRIORITY_6               6
+#define ARBITRATION_CTRL_PANEL_PRIORITY_7               7
+#define ARBITRATION_CTRL_ZVPORT                         19:16
+#define ARBITRATION_CTRL_ZVPORT_OFF                     0
+#define ARBITRATION_CTRL_ZVPORT_PRIORITY_1              1
+#define ARBITRATION_CTRL_ZVPORT_PRIORITY_2              2
+#define ARBITRATION_CTRL_ZVPORT_PRIORITY_3              3
+#define ARBITRATION_CTRL_ZVPORT_PRIORITY_4              4
+#define ARBITRATION_CTRL_ZVPORT_PRIORITY_5              5
+#define ARBITRATION_CTRL_ZVPORT_PRIORITY_6              6
+#define ARBITRATION_CTRL_ZVPORT_PRIORITY_7              7
+#define ARBITRATION_CTRL_CMD_INTPR                      15:12
+#define ARBITRATION_CTRL_CMD_INTPR_OFF                  0
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_1           1
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_2           2
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_3           3
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_4           4
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_5           5
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_6           6
+#define ARBITRATION_CTRL_CMD_INTPR_PRIORITY_7           7
+#define ARBITRATION_CTRL_DMA                            11:8
+#define ARBITRATION_CTRL_DMA_OFF                        0
+#define ARBITRATION_CTRL_DMA_PRIORITY_1                 1
+#define ARBITRATION_CTRL_DMA_PRIORITY_2                 2
+#define ARBITRATION_CTRL_DMA_PRIORITY_3                 3
+#define ARBITRATION_CTRL_DMA_PRIORITY_4                 4
+#define ARBITRATION_CTRL_DMA_PRIORITY_5                 5
+#define ARBITRATION_CTRL_DMA_PRIORITY_6                 6
+#define ARBITRATION_CTRL_DMA_PRIORITY_7                 7
+#define ARBITRATION_CTRL_VIDEO                          7:4
+#define ARBITRATION_CTRL_VIDEO_OFF                      0
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_1               1
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_2               2
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_3               3
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_4               4
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_5               5
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_6               6
+#define ARBITRATION_CTRL_VIDEO_PRIORITY_7               7
+#define ARBITRATION_CTRL_CRT                            3:0
+#define ARBITRATION_CTRL_CRT_OFF                        0
+#define ARBITRATION_CTRL_CRT_PRIORITY_1                 1
+#define ARBITRATION_CTRL_CRT_PRIORITY_2                 2
+#define ARBITRATION_CTRL_CRT_PRIORITY_3                 3
+#define ARBITRATION_CTRL_CRT_PRIORITY_4                 4
+#define ARBITRATION_CTRL_CRT_PRIORITY_5                 5
+#define ARBITRATION_CTRL_CRT_PRIORITY_6                 6
+#define ARBITRATION_CTRL_CRT_PRIORITY_7                 7
+
+#define CMD_INTPR_CTRL                                  0x000018
+#define CMD_INTPR_CTRL_STATUS                           31:31
+#define CMD_INTPR_CTRL_STATUS_STOPPED                   0
+#define CMD_INTPR_CTRL_STATUS_RUNNING                   1
+#define CMD_INTPR_CTRL_EXT                              27:27
+#define CMD_INTPR_CTRL_EXT_LOCAL                        0
+#define CMD_INTPR_CTRL_EXT_EXTERNAL                     1
+#define CMD_INTPR_CTRL_CS                               26:26
+#define CMD_INTPR_CTRL_CS_0                             0
+#define CMD_INTPR_CTRL_CS_1                             1
+#define CMD_INTPR_CTRL_ADDRESS                          25:0
+
+#define CMD_INTPR_CONDITIONS                            0x00001C
+
+#define CMD_INTPR_RETURN                                0x000020
+#define CMD_INTPR_RETURN_EXT                            27:27
+#define CMD_INTPR_RETURN_EXT_LOCAL                      0
+#define CMD_INTPR_RETURN_EXT_EXTERNAL                   1
+#define CMD_INTPR_RETURN_CS                             26:26
+#define CMD_INTPR_RETURN_CS_0                           0
+#define CMD_INTPR_RETURN_CS_1                           1
+#define CMD_INTPR_RETURN_ADDRESS                        25:0
+
+#define CMD_INTPR_STATUS                                0x000024
+#define CMD_INTPR_STATUS_2D_MEMORY_FIFO                 20:20
+#define CMD_INTPR_STATUS_2D_MEMORY_FIFO_NOT_EMPTY       0
+#define CMD_INTPR_STATUS_2D_MEMORY_FIFO_EMPTY           1
+#define CMD_INTPR_STATUS_COMMAND_FIFO                   19:19
+#define CMD_INTPR_STATUS_COMMAND_FIFO_NOT_EMPTY         0
+#define CMD_INTPR_STATUS_COMMAND_FIFO_EMPTY             1
+#define CMD_INTPR_STATUS_CSC_STATUS                     18:18
+#define CMD_INTPR_STATUS_CSC_STATUS_IDLE                0
+#define CMD_INTPR_STATUS_CSC_STATUS_BUSY                1
+#define CMD_INTPR_STATUS_MEMORY_DMA                     17:17
+#define CMD_INTPR_STATUS_MEMORY_DMA_IDLE                0
+#define CMD_INTPR_STATUS_MEMORY_DMA_BUSY                1
+#define CMD_INTPR_STATUS_CRT_STATUS                     16:16
+#define CMD_INTPR_STATUS_CRT_STATUS_CURRENT             0
+#define CMD_INTPR_STATUS_CRT_STATUS_PENDING             1
+#define CMD_INTPR_STATUS_CURRENT_FIELD                  15:15
+#define CMD_INTPR_STATUS_CURRENT_FIELD_ODD              0
+#define CMD_INTPR_STATUS_CURRENT_FIELD_EVEN             1
+#define CMD_INTPR_STATUS_VIDEO_STATUS                   14:14
+#define CMD_INTPR_STATUS_VIDEO_STATUS_CURRENT           0
+#define CMD_INTPR_STATUS_VIDEO_STATUS_PENDING           1
+#define CMD_INTPR_STATUS_PANEL_STATUS                   13:13
+#define CMD_INTPR_STATUS_PANEL_STATUS_CURRENT           0
+#define CMD_INTPR_STATUS_PANEL_STATUS_PENDING           1
+#define CMD_INTPR_STATUS_CRT_SYNC                       12:12
+#define CMD_INTPR_STATUS_CRT_SYNC_INACTIVE              0
+#define CMD_INTPR_STATUS_CRT_SYNC_ACTIVE                1
+#define CMD_INTPR_STATUS_PANEL_SYNC                     11:11
+#define CMD_INTPR_STATUS_PANEL_SYNC_INACTIVE            0
+#define CMD_INTPR_STATUS_PANEL_SYNC_ACTIVE              1
+#define CMD_INTPR_STATUS_2D_SETUP                       2:2
+#define CMD_INTPR_STATUS_2D_SETUP_IDLE                  0
+#define CMD_INTPR_STATUS_2D_SETUP_BUSY                  1
+#define CMD_INTPR_STATUS_2D_FIFO                        1:1
+#define CMD_INTPR_STATUS_2D_FIFO_NOT_EMPTY              0
+#define CMD_INTPR_STATUS_2D_FIFO_EMPTY                  1
+#define CMD_INTPR_STATUS_2D_ENGINE                      0:0
+#define CMD_INTPR_STATUS_2D_ENGINE_IDLE                 0
+#define CMD_INTPR_STATUS_2D_ENGINE_BUSY                 1
+
+#define RAW_INT_STATUS                                  0x000028
+#define RAW_INT_STATUS_USB_SLAVE_PLUG_IN                5:5
+#define RAW_INT_STATUS_USB_SLAVE_PLUG_IN_INACTIVE       0
+#define RAW_INT_STATUS_USB_SLAVE_PLUG_IN_ACTIVE         1
+#define RAW_INT_STATUS_USB_SLAVE_PLUG_IN_CLEAR          1
+#define RAW_INT_STATUS_ZVPORT                           4:4
+#define RAW_INT_STATUS_ZVPORT_INACTIVE                  0
+#define RAW_INT_STATUS_ZVPORT_ACTIVE                    1
+#define RAW_INT_STATUS_ZVPORT_CLEAR                     1
+#define RAW_INT_STATUS_CRT_VSYNC                        3:3
+#define RAW_INT_STATUS_CRT_VSYNC_INACTIVE               0
+#define RAW_INT_STATUS_CRT_VSYNC_ACTIVE                 1
+#define RAW_INT_STATUS_CRT_VSYNC_CLEAR                  1
+#define RAW_INT_STATUS_USB_SLAVE                        2:2
+#define RAW_INT_STATUS_USB_SLAVE_INACTIVE               0
+#define RAW_INT_STATUS_USB_SLAVE_ACTIVE                 1
+#define RAW_INT_STATUS_USB_SLAVE_CLEAR                  1
+#define RAW_INT_STATUS_PANEL_VSYNC                      1:1
+#define RAW_INT_STATUS_PANEL_VSYNC_INACTIVE             0
+#define RAW_INT_STATUS_PANEL_VSYNC_ACTIVE               1
+#define RAW_INT_STATUS_PANEL_VSYNC_CLEAR                1
+#define RAW_INT_STATUS_CMD_INTPR                        0:0
+#define RAW_INT_STATUS_CMD_INTPR_INACTIVE               0
+#define RAW_INT_STATUS_CMD_INTPR_ACTIVE                 1
+#define RAW_INT_STATUS_CMD_INTPR_CLEAR                  1
+
+#define INT_STATUS                                      0x00002C
+#define INT_STATUS_USB_SLAVE_PLUG_IN                    31:31
+#define INT_STATUS_USB_SLAVE_PLUG_IN_INACTIVE           0
+#define INT_STATUS_USB_SLAVE_PLUG_IN_ACTIVE             1
+#define INT_STATUS_GPIO54                               30:30
+#define INT_STATUS_GPIO54_INACTIVE                      0
+#define INT_STATUS_GPIO54_ACTIVE                        1
+#define INT_STATUS_GPIO53                               29:29
+#define INT_STATUS_GPIO53_INACTIVE                      0
+#define INT_STATUS_GPIO53_ACTIVE                        1
+#define INT_STATUS_GPIO52                               28:28
+#define INT_STATUS_GPIO52_INACTIVE                      0
+#define INT_STATUS_GPIO52_ACTIVE                        1
+#define INT_STATUS_GPIO51                               27:27
+#define INT_STATUS_GPIO51_INACTIVE                      0
+#define INT_STATUS_GPIO51_ACTIVE                        1
+#define INT_STATUS_GPIO50                               26:26
+#define INT_STATUS_GPIO50_INACTIVE                      0
+#define INT_STATUS_GPIO50_ACTIVE                        1
+#define INT_STATUS_GPIO49                               25:25
+#define INT_STATUS_GPIO49_INACTIVE                      0
+#define INT_STATUS_GPIO49_ACTIVE                        1
+#define INT_STATUS_GPIO48                               24:24
+#define INT_STATUS_GPIO48_INACTIVE                      0
+#define INT_STATUS_GPIO48_ACTIVE                        1
+#define INT_STATUS_I2C                                  23:23
+#define INT_STATUS_I2C_INACTIVE                         0
+#define INT_STATUS_I2C_ACTIVE                           1
+#define INT_STATUS_PWM                                  22:22
+#define INT_STATUS_PWM_INACTIVE                         0
+#define INT_STATUS_PWM_ACTIVE                           1
+#define INT_STATUS_DMA                                  20:20
+#define INT_STATUS_DMA_INACTIVE                         0
+#define INT_STATUS_DMA_ACTIVE                           1
+#define INT_STATUS_PCI                                  19:19
+#define INT_STATUS_PCI_INACTIVE                         0
+#define INT_STATUS_PCI_ACTIVE                           1
+#define INT_STATUS_I2S                                  18:18
+#define INT_STATUS_I2S_INACTIVE                         0
+#define INT_STATUS_I2S_ACTIVE                           1
+#define INT_STATUS_AC97                                 17:17
+#define INT_STATUS_AC97_INACTIVE                        0
+#define INT_STATUS_AC97_ACTIVE                          1
+#define INT_STATUS_USB_SLAVE                            16:16
+#define INT_STATUS_USB_SLAVE_INACTIVE                   0
+#define INT_STATUS_USB_SLAVE_ACTIVE                     1
+#define INT_STATUS_UART1                                13:13
+#define INT_STATUS_UART1_INACTIVE                       0
+#define INT_STATUS_UART1_ACTIVE                         1
+#define INT_STATUS_UART0                                12:12
+#define INT_STATUS_UART0_INACTIVE                       0
+#define INT_STATUS_UART0_ACTIVE                         1
+#define INT_STATUS_CRT_VSYNC                            11:11
+#define INT_STATUS_CRT_VSYNC_INACTIVE                   0
+#define INT_STATUS_CRT_VSYNC_ACTIVE                     1
+#define INT_STATUS_8051                                 10:10
+#define INT_STATUS_8051_INACTIVE                        0
+#define INT_STATUS_8051_ACTIVE                          1
+#define INT_STATUS_SSP1                                 9:9
+#define INT_STATUS_SSP1_INACTIVE                        0
+#define INT_STATUS_SSP1_ACTIVE                          1
+#define INT_STATUS_SSP0                                 8:8
+#define INT_STATUS_SSP0_INACTIVE                        0
+#define INT_STATUS_SSP0_ACTIVE                          1
+#define INT_STATUS_USB_HOST                             6:6
+#define INT_STATUS_USB_HOST_INACTIVE                    0
+#define INT_STATUS_USB_HOST_ACTIVE                      1
+#define INT_STATUS_2D                                   3:3
+#define INT_STATUS_2D_INACTIVE                          0
+#define INT_STATUS_2D_ACTIVE                            1
+#define INT_STATUS_ZVPORT                               2:2
+#define INT_STATUS_ZVPORT_INACTIVE                      0
+#define INT_STATUS_ZVPORT_ACTIVE                        1
+#define INT_STATUS_PANEL_VSYNC                          1:1
+#define INT_STATUS_PANEL_VSYNC_INACTIVE                 0
+#define INT_STATUS_PANEL_VSYNC_ACTIVE                   1
+#define INT_STATUS_CMD_INTPR                            0:0
+#define INT_STATUS_CMD_INTPR_INACTIVE                   0
+#define INT_STATUS_CMD_INTPR_ACTIVE                     1
+
+#define INT_MASK                                        0x000030
+#define INT_MASK_USB_SLAVE_PLUG_IN                      31:31
+#define INT_MASK_USB_SLAVE_PLUG_IN_DISABLE              0
+#define INT_MASK_USB_SLAVE_PLUG_IN_ENABLE               1
+#define INT_MASK_GPIO54                                 30:30
+#define INT_MASK_GPIO54_DISABLE                         0
+#define INT_MASK_GPIO54_ENABLE                          1
+#define INT_MASK_GPIO53                                 29:29
+#define INT_MASK_GPIO53_DISABLE                         0
+#define INT_MASK_GPIO53_ENABLE                          1
+#define INT_MASK_GPIO52                                 28:28
+#define INT_MASK_GPIO52_DISABLE                         0
+#define INT_MASK_GPIO52_ENABLE                          1
+#define INT_MASK_GPIO51                                 27:27
+#define INT_MASK_GPIO51_DISABLE                         0
+#define INT_MASK_GPIO51_ENABLE                          1
+#define INT_MASK_GPIO50                                 26:26
+#define INT_MASK_GPIO50_DISABLE                         0
+#define INT_MASK_GPIO50_ENABLE                          1
+#define INT_MASK_GPIO49                                 25:25
+#define INT_MASK_GPIO49_DISABLE                         0
+#define INT_MASK_GPIO49_ENABLE                          1
+#define INT_MASK_GPIO48                                 24:24
+#define INT_MASK_GPIO48_DISABLE                         0
+#define INT_MASK_GPIO48_ENABLE                          1
+#define INT_MASK_I2C                                    23:23
+#define INT_MASK_I2C_DISABLE                            0
+#define INT_MASK_I2C_ENABLE                             1
+#define INT_MASK_PWM                                    22:22
+#define INT_MASK_PWM_DISABLE                            0
+#define INT_MASK_PWM_ENABLE                             1
+#define INT_MASK_DMA                                    20:20
+#define INT_MASK_DMA_DISABLE                            0
+#define INT_MASK_DMA_ENABLE                             1
+#define INT_MASK_PCI                                    19:19
+#define INT_MASK_PCI_DISABLE                            0
+#define INT_MASK_PCI_ENABLE                             1
+#define INT_MASK_I2S                                    18:18
+#define INT_MASK_I2S_DISABLE                            0
+#define INT_MASK_I2S_ENABLE                             1
+#define INT_MASK_AC97                                   17:17
+#define INT_MASK_AC97_DISABLE                           0
+#define INT_MASK_AC97_ENABLE                            1
+#define INT_MASK_USB_SLAVE                              16:16
+#define INT_MASK_USB_SLAVE_DISABLE                      0
+#define INT_MASK_USB_SLAVE_ENABLE                       1
+#define INT_MASK_UART1                                  13:13
+#define INT_MASK_UART1_DISABLE                          0
+#define INT_MASK_UART1_ENABLE                           1
+#define INT_MASK_UART0                                  12:12
+#define INT_MASK_UART0_DISABLE                          0
+#define INT_MASK_UART0_ENABLE                           1
+#define INT_MASK_CRT_VSYNC                              11:11
+#define INT_MASK_CRT_VSYNC_DISABLE                      0
+#define INT_MASK_CRT_VSYNC_ENABLE                       1
+#define INT_MASK_8051                                   10:10
+#define INT_MASK_8051_DISABLE                           0
+#define INT_MASK_8051_ENABLE                            1
+#define INT_MASK_SSP1                                   9:9
+#define INT_MASK_SSP1_DISABLE                           0
+#define INT_MASK_SSP1_ENABLE                            1
+#define INT_MASK_SSP0                                   8:8
+#define INT_MASK_SSP0_DISABLE                           0
+#define INT_MASK_SSP0_ENABLE                            1
+#define INT_MASK_USB_HOST                               6:6
+#define INT_MASK_USB_HOST_DISABLE                       0
+#define INT_MASK_USB_HOST_ENABLE                        1
+#define INT_MASK_2D                                     3:3
+#define INT_MASK_2D_DISABLE                             0
+#define INT_MASK_2D_ENABLE                              1
+#define INT_MASK_ZVPORT                                 2:2
+#define INT_MASK_ZVPORT_DISABLE                         0
+#define INT_MASK_ZVPORT_ENABLE                          1
+#define INT_MASK_PANEL_VSYNC                            1:1
+#define INT_MASK_PANEL_VSYNC_DISABLE                    0
+#define INT_MASK_PANEL_VSYNC_ENABLE                     1
+#define INT_MASK_CMD_INTPR                              0:0
+#define INT_MASK_CMD_INTPR_DISABLE                      0
+#define INT_MASK_CMD_INTPR_ENABLE                       1
+
+#define DEBUG_CTRL                                      0x000034
+#define DEBUG_CTRL_MODULE                               7:5
+#define DEBUG_CTRL_PARTITION                            4:0
+#define DEBUG_CTRL_PARTITION_HIF                        0
+#define DEBUG_CTRL_PARTITION_CPUMEM                     1
+#define DEBUG_CTRL_PARTITION_PCI                        2
+#define DEBUG_CTRL_PARTITION_CMD_INTPR                  3
+#define DEBUG_CTRL_PARTITION_DISPLAY                    4
+#define DEBUG_CTRL_PARTITION_ZVPORT                     5
+#define DEBUG_CTRL_PARTITION_2D                         6
+#define DEBUG_CTRL_PARTITION_MIF                        8
+#define DEBUG_CTRL_PARTITION_USB_HOST                   10
+#define DEBUG_CTRL_PARTITION_SSP0                       12
+#define DEBUG_CTRL_PARTITION_SSP1                       13
+#define DEBUG_CTRL_PARTITION_UART0                      19
+#define DEBUG_CTRL_PARTITION_UART1                      20
+#define DEBUG_CTRL_PARTITION_I2C                        21
+#define DEBUG_CTRL_PARTITION_8051                       23
+#define DEBUG_CTRL_PARTITION_AC97                       24
+#define DEBUG_CTRL_PARTITION_I2S                        25
+#define DEBUG_CTRL_PARTITION_INTMEM                     26
+#define DEBUG_CTRL_PARTITION_DMA                        27
+#define DEBUG_CTRL_PARTITION_SIMULATION                 28
+
+#define CURRENT_POWER_GATE                              0x000038
+#define CURRENT_POWER_GATE_AC97_I2S                     18:18
+#define CURRENT_POWER_GATE_AC97_I2S_DISABLE             0
+#define CURRENT_POWER_GATE_AC97_I2S_ENABLE              1
+#define CURRENT_POWER_GATE_8051                         17:17
+#define CURRENT_POWER_GATE_8051_DISABLE                 0
+#define CURRENT_POWER_GATE_8051_ENABLE                  1
+#define CURRENT_POWER_GATE_PLL                          16:16
+#define CURRENT_POWER_GATE_PLL_DISABLE                  0
+#define CURRENT_POWER_GATE_PLL_ENABLE                   1
+#define CURRENT_POWER_GATE_OSCILLATOR                   15:15
+#define CURRENT_POWER_GATE_OSCILLATOR_DISABLE           0
+#define CURRENT_POWER_GATE_OSCILLATOR_ENABLE            1
+#define CURRENT_POWER_GATE_PLL_RECOVERY                 14:13
+#define CURRENT_POWER_GATE_PLL_RECOVERY_32              0
+#define CURRENT_POWER_GATE_PLL_RECOVERY_64              1
+#define CURRENT_POWER_GATE_PLL_RECOVERY_96              2
+#define CURRENT_POWER_GATE_PLL_RECOVERY_128             3
+#define CURRENT_POWER_GATE_USB_SLAVE                    12:12
+#define CURRENT_POWER_GATE_USB_SLAVE_DISABLE            0
+#define CURRENT_POWER_GATE_USB_SLAVE_ENABLE             1
+#define CURRENT_POWER_GATE_USB_HOST                     11:11
+#define CURRENT_POWER_GATE_USB_HOST_DISABLE             0
+#define CURRENT_POWER_GATE_USB_HOST_ENABLE              1
+#define CURRENT_POWER_GATE_SSP0_SSP1                    10:10
+#define CURRENT_POWER_GATE_SSP0_SSP1_DISABLE            0
+#define CURRENT_POWER_GATE_SSP0_SSP1_ENABLE             1
+#define CURRENT_POWER_GATE_UART1                        8:8
+#define CURRENT_POWER_GATE_UART1_DISABLE                0
+#define CURRENT_POWER_GATE_UART1_ENABLE                 1
+#define CURRENT_POWER_GATE_UART0                        7:7
+#define CURRENT_POWER_GATE_UART0_DISABLE                0
+#define CURRENT_POWER_GATE_UART0_ENABLE                 1
+#define CURRENT_POWER_GATE_GPIO_PWM_I2C                 6:6
+#define CURRENT_POWER_GATE_GPIO_PWM_I2C_DISABLE         0
+#define CURRENT_POWER_GATE_GPIO_PWM_I2C_ENABLE          1
+#define CURRENT_POWER_GATE_ZVPORT                       5:5
+#define CURRENT_POWER_GATE_ZVPORT_DISABLE               0
+#define CURRENT_POWER_GATE_ZVPORT_ENABLE                1
+#define CURRENT_POWER_GATE_CSC                          4:4
+#define CURRENT_POWER_GATE_CSC_DISABLE                  0
+#define CURRENT_POWER_GATE_CSC_ENABLE                   1
+#define CURRENT_POWER_GATE_2D                           3:3
+#define CURRENT_POWER_GATE_2D_DISABLE                   0
+#define CURRENT_POWER_GATE_2D_ENABLE                    1
+#define CURRENT_POWER_GATE_DISPLAY                      2:2
+#define CURRENT_POWER_GATE_DISPLAY_DISABLE              0
+#define CURRENT_POWER_GATE_DISPLAY_ENABLE               1
+#define CURRENT_POWER_GATE_INTMEM                       1:1
+#define CURRENT_POWER_GATE_INTMEM_DISABLE               0
+#define CURRENT_POWER_GATE_INTMEM_ENABLE                1
+#define CURRENT_POWER_GATE_HOST                         0:0
+#define CURRENT_POWER_GATE_HOST_DISABLE                 0
+#define CURRENT_POWER_GATE_HOST_ENABLE                  1
+
+#define CURRENT_POWER_CLOCK                             0x00003C
+#define CURRENT_POWER_CLOCK_P1XCLK               31:31
+#define CURRENT_POWER_CLOCK_P1XCLK_ENABLE               1
+#define CURRENT_POWER_CLOCK_P1XCLK_DISABLE              0
+#define CURRENT_POWER_CLOCK_PLLCLK_SELECT               30:30
+#define CURRENT_POWER_CLOCK_PLLCLK_SELECT_ENABLE               1
+#define CURRENT_POWER_CLOCK_PLLCLK_SELECT_DISABLE              0
+#define CURRENT_POWER_CLOCK_P2XCLK_SELECT               29:29
+#define CURRENT_POWER_CLOCK_P2XCLK_SELECT_288           0
+#define CURRENT_POWER_CLOCK_P2XCLK_SELECT_336           1
+#define CURRENT_POWER_CLOCK_P2XCLK_DIVIDER              28:27
+#define CURRENT_POWER_CLOCK_P2XCLK_DIVIDER_1            0
+#define CURRENT_POWER_CLOCK_P2XCLK_DIVIDER_3            1
+#define CURRENT_POWER_CLOCK_P2XCLK_DIVIDER_5            2
+#define CURRENT_POWER_CLOCK_P2XCLK_SHIFT                26:24
+#define CURRENT_POWER_CLOCK_P2XCLK_SHIFT_0              0
+#define CURRENT_POWER_CLOCK_P2XCLK_SHIFT_1              1
+#define CURRENT_POWER_CLOCK_P2XCLK_SHIFT_2              2
+#define CURRENT_POWER_CLOCK_P2XCLK_SHIFT_3              3
+#define CURRENT_POWER_CLOCK_P2XCLK_SHIFT_4              4
+#define CURRENT_POWER_CLOCK_P2XCLK_SHIFT_5              5
+#define CURRENT_POWER_CLOCK_P2XCLK_SHIFT_6              6
+#define CURRENT_POWER_CLOCK_P2XCLK_SHIFT_7              7
+#define CURRENT_POWER_CLOCK_V2XCLK_SELECT               20:20
+#define CURRENT_POWER_CLOCK_V2XCLK_SELECT_288           0
+#define CURRENT_POWER_CLOCK_V2XCLK_SELECT_336           1
+#define CURRENT_POWER_CLOCK_V2XCLK_DIVIDER              19:19
+#define CURRENT_POWER_CLOCK_V2XCLK_DIVIDER_1            0
+#define CURRENT_POWER_CLOCK_V2XCLK_DIVIDER_3            1
+#define CURRENT_POWER_CLOCK_V2XCLK_SHIFT                18:16
+#define CURRENT_POWER_CLOCK_V2XCLK_SHIFT_0              0
+#define CURRENT_POWER_CLOCK_V2XCLK_SHIFT_1              1
+#define CURRENT_POWER_CLOCK_V2XCLK_SHIFT_2              2
+#define CURRENT_POWER_CLOCK_V2XCLK_SHIFT_3              3
+#define CURRENT_POWER_CLOCK_V2XCLK_SHIFT_4              4
+#define CURRENT_POWER_CLOCK_V2XCLK_SHIFT_5              5
+#define CURRENT_POWER_CLOCK_V2XCLK_SHIFT_6              6
+#define CURRENT_POWER_CLOCK_V2XCLK_SHIFT_7              7
+#define CURRENT_POWER_CLOCK_MCLK_SELECT                 12:12
+#define CURRENT_POWER_CLOCK_MCLK_SELECT_288             0
+#define CURRENT_POWER_CLOCK_MCLK_SELECT_336             1
+#define CURRENT_POWER_CLOCK_MCLK_DIVIDER                11:11
+#define CURRENT_POWER_CLOCK_MCLK_DIVIDER_1              0
+#define CURRENT_POWER_CLOCK_MCLK_DIVIDER_3              1
+#define CURRENT_POWER_CLOCK_MCLK_SHIFT                  10:8
+#define CURRENT_POWER_CLOCK_MCLK_SHIFT_0                0
+#define CURRENT_POWER_CLOCK_MCLK_SHIFT_1                1
+#define CURRENT_POWER_CLOCK_MCLK_SHIFT_2                2
+#define CURRENT_POWER_CLOCK_MCLK_SHIFT_3                3
+#define CURRENT_POWER_CLOCK_MCLK_SHIFT_4                4
+#define CURRENT_POWER_CLOCK_MCLK_SHIFT_5                5
+#define CURRENT_POWER_CLOCK_MCLK_SHIFT_6                6
+#define CURRENT_POWER_CLOCK_MCLK_SHIFT_7                7
+#define CURRENT_POWER_CLOCK_M2XCLK_SELECT               4:4
+#define CURRENT_POWER_CLOCK_M2XCLK_SELECT_288           0
+#define CURRENT_POWER_CLOCK_M2XCLK_SELECT_336           1
+#define CURRENT_POWER_CLOCK_M2XCLK_DIVIDER              3:3
+#define CURRENT_POWER_CLOCK_M2XCLK_DIVIDER_1            0
+#define CURRENT_POWER_CLOCK_M2XCLK_DIVIDER_3            1
+#define CURRENT_POWER_CLOCK_M2XCLK_SHIFT                2:0
+#define CURRENT_POWER_CLOCK_M2XCLK_SHIFT_0              0
+#define CURRENT_POWER_CLOCK_M2XCLK_SHIFT_1              1
+#define CURRENT_POWER_CLOCK_M2XCLK_SHIFT_2              2
+#define CURRENT_POWER_CLOCK_M2XCLK_SHIFT_3              3
+#define CURRENT_POWER_CLOCK_M2XCLK_SHIFT_4              4
+#define CURRENT_POWER_CLOCK_M2XCLK_SHIFT_5              5
+#define CURRENT_POWER_CLOCK_M2XCLK_SHIFT_6              6
+#define CURRENT_POWER_CLOCK_M2XCLK_SHIFT_7              7
+
+#define POWER_MODE0_GATE                                0x000040
+#define POWER_MODE0_GATE_AC97_I2S                       18:18
+#define POWER_MODE0_GATE_AC97_I2S_DISABLE               0
+#define POWER_MODE0_GATE_AC97_I2S_ENABLE                1
+#define POWER_MODE0_GATE_8051                           17:17
+#define POWER_MODE0_GATE_8051_DISABLE                   0
+#define POWER_MODE0_GATE_8051_ENABLE                    1
+#define POWER_MODE0_GATE_USB_SLAVE                      12:12
+#define POWER_MODE0_GATE_USB_SLAVE_DISABLE              0
+#define POWER_MODE0_GATE_USB_SLAVE_ENABLE               1
+#define POWER_MODE0_GATE_USB_HOST                       11:11
+#define POWER_MODE0_GATE_USB_HOST_DISABLE               0
+#define POWER_MODE0_GATE_USB_HOST_ENABLE                1
+#define POWER_MODE0_GATE_SSP0_SSP1                      10:10
+#define POWER_MODE0_GATE_SSP0_SSP1_DISABLE              0
+#define POWER_MODE0_GATE_SSP0_SSP1_ENABLE               1
+#define POWER_MODE0_GATE_UART1                          8:8
+#define POWER_MODE0_GATE_UART1_DISABLE                  0
+#define POWER_MODE0_GATE_UART1_ENABLE                   1
+#define POWER_MODE0_GATE_UART0                          7:7
+#define POWER_MODE0_GATE_UART0_DISABLE                  0
+#define POWER_MODE0_GATE_UART0_ENABLE                   1
+#define POWER_MODE0_GATE_GPIO_PWM_I2C                   6:6
+#define POWER_MODE0_GATE_GPIO_PWM_I2C_DISABLE           0
+#define POWER_MODE0_GATE_GPIO_PWM_I2C_ENABLE            1
+#define POWER_MODE0_GATE_ZVPORT                         5:5
+#define POWER_MODE0_GATE_ZVPORT_DISABLE                 0
+#define POWER_MODE0_GATE_ZVPORT_ENABLE                  1
+#define POWER_MODE0_GATE_CSC                            4:4
+#define POWER_MODE0_GATE_CSC_DISABLE                    0
+#define POWER_MODE0_GATE_CSC_ENABLE                     1
+#define POWER_MODE0_GATE_2D                             3:3
+#define POWER_MODE0_GATE_2D_DISABLE                     0
+#define POWER_MODE0_GATE_2D_ENABLE                      1
+#define POWER_MODE0_GATE_DISPLAY                        2:2
+#define POWER_MODE0_GATE_DISPLAY_DISABLE                0
+#define POWER_MODE0_GATE_DISPLAY_ENABLE                 1
+#define POWER_MODE0_GATE_INTMEM                         1:1
+#define POWER_MODE0_GATE_INTMEM_DISABLE                 0
+#define POWER_MODE0_GATE_INTMEM_ENABLE                  1
+#define POWER_MODE0_GATE_HOST                           0:0
+#define POWER_MODE0_GATE_HOST_DISABLE                   0
+#define POWER_MODE0_GATE_HOST_ENABLE                    1
+
+#define POWER_MODE0_CLOCK                               0x000044
+#define POWER_MODE0_CLOCK_PLL3_P1XCLK					31:31
+#define POWER_MODE0_CLOCK_PLL3_P1XCLK_ENABLE			1
+#define POWER_MODE0_CLOCK_PLL3_P1XCLK_DISABLE			0
+#define POWER_MODE0_CLOCK_PLL3							30:30
+#define POWER_MODE0_CLOCK_PLL3_ENABLE					1
+#define POWER_MODE0_CLOCK_PLL3_DISABLE					0							
+#define POWER_MODE0_CLOCK_P2XCLK_SELECT                 29:29
+#define POWER_MODE0_CLOCK_P2XCLK_SELECT_288             0
+#define POWER_MODE0_CLOCK_P2XCLK_SELECT_336             1
+#define POWER_MODE0_CLOCK_P2XCLK_DIVIDER                28:27
+#define POWER_MODE0_CLOCK_P2XCLK_DIVIDER_1              0
+#define POWER_MODE0_CLOCK_P2XCLK_DIVIDER_3              1
+#define POWER_MODE0_CLOCK_P2XCLK_DIVIDER_5              2
+#define POWER_MODE0_CLOCK_P2XCLK_SHIFT                  26:24
+#define POWER_MODE0_CLOCK_P2XCLK_SHIFT_0                0
+#define POWER_MODE0_CLOCK_P2XCLK_SHIFT_1                1
+#define POWER_MODE0_CLOCK_P2XCLK_SHIFT_2                2
+#define POWER_MODE0_CLOCK_P2XCLK_SHIFT_3                3
+#define POWER_MODE0_CLOCK_P2XCLK_SHIFT_4                4
+#define POWER_MODE0_CLOCK_P2XCLK_SHIFT_5                5
+#define POWER_MODE0_CLOCK_P2XCLK_SHIFT_6                6
+#define POWER_MODE0_CLOCK_P2XCLK_SHIFT_7                7
+#define POWER_MODE0_CLOCK_V2XCLK_SELECT                 20:20
+#define POWER_MODE0_CLOCK_V2XCLK_SELECT_288             0
+#define POWER_MODE0_CLOCK_V2XCLK_SELECT_336             1
+#define POWER_MODE0_CLOCK_V2XCLK_DIVIDER                19:19
+#define POWER_MODE0_CLOCK_V2XCLK_DIVIDER_1              0
+#define POWER_MODE0_CLOCK_V2XCLK_DIVIDER_3              1
+#define POWER_MODE0_CLOCK_V2XCLK_SHIFT                  18:16
+#define POWER_MODE0_CLOCK_V2XCLK_SHIFT_0                0
+#define POWER_MODE0_CLOCK_V2XCLK_SHIFT_1                1
+#define POWER_MODE0_CLOCK_V2XCLK_SHIFT_2                2
+#define POWER_MODE0_CLOCK_V2XCLK_SHIFT_3                3
+#define POWER_MODE0_CLOCK_V2XCLK_SHIFT_4                4
+#define POWER_MODE0_CLOCK_V2XCLK_SHIFT_5                5
+#define POWER_MODE0_CLOCK_V2XCLK_SHIFT_6                6
+#define POWER_MODE0_CLOCK_V2XCLK_SHIFT_7                7
+#define POWER_MODE0_CLOCK_MCLK_SELECT                   12:12
+#define POWER_MODE0_CLOCK_MCLK_SELECT_288               0
+#define POWER_MODE0_CLOCK_MCLK_SELECT_336               1
+#define POWER_MODE0_CLOCK_MCLK_DIVIDER                  11:11
+#define POWER_MODE0_CLOCK_MCLK_DIVIDER_1                0
+#define POWER_MODE0_CLOCK_MCLK_DIVIDER_3                1
+#define POWER_MODE0_CLOCK_MCLK_SHIFT                    10:8
+#define POWER_MODE0_CLOCK_MCLK_SHIFT_0                  0
+#define POWER_MODE0_CLOCK_MCLK_SHIFT_1                  1
+#define POWER_MODE0_CLOCK_MCLK_SHIFT_2                  2
+#define POWER_MODE0_CLOCK_MCLK_SHIFT_3                  3
+#define POWER_MODE0_CLOCK_MCLK_SHIFT_4                  4
+#define POWER_MODE0_CLOCK_MCLK_SHIFT_5                  5
+#define POWER_MODE0_CLOCK_MCLK_SHIFT_6                  6
+#define POWER_MODE0_CLOCK_MCLK_SHIFT_7                  7
+#define POWER_MODE0_CLOCK_M2XCLK_SELECT                 4:4
+#define POWER_MODE0_CLOCK_M2XCLK_SELECT_288             0
+#define POWER_MODE0_CLOCK_M2XCLK_SELECT_336             1
+#define POWER_MODE0_CLOCK_M2XCLK_DIVIDER                3:3
+#define POWER_MODE0_CLOCK_M2XCLK_DIVIDER_1              0
+#define POWER_MODE0_CLOCK_M2XCLK_DIVIDER_3              1
+#define POWER_MODE0_CLOCK_M2XCLK_SHIFT                  2:0
+#define POWER_MODE0_CLOCK_M2XCLK_SHIFT_0                0
+#define POWER_MODE0_CLOCK_M2XCLK_SHIFT_1                1
+#define POWER_MODE0_CLOCK_M2XCLK_SHIFT_2                2
+#define POWER_MODE0_CLOCK_M2XCLK_SHIFT_3                3
+#define POWER_MODE0_CLOCK_M2XCLK_SHIFT_4                4
+#define POWER_MODE0_CLOCK_M2XCLK_SHIFT_5                5
+#define POWER_MODE0_CLOCK_M2XCLK_SHIFT_6                6
+#define POWER_MODE0_CLOCK_M2XCLK_SHIFT_7                7
+
+#define POWER_MODE1_GATE                                0x000048
+#define POWER_MODE1_GATE_AC97_I2S                       18:18
+#define POWER_MODE1_GATE_AC97_I2S_DISABLE               0
+#define POWER_MODE1_GATE_AC97_I2S_ENABLE                1
+#define POWER_MODE1_GATE_8051                           17:17
+#define POWER_MODE1_GATE_8051_DISABLE                   0
+#define POWER_MODE1_GATE_8051_ENABLE                    1
+#define POWER_MODE1_GATE_USB_SLAVE                      12:12
+#define POWER_MODE1_GATE_USB_SLAVE_DISABLE              0
+#define POWER_MODE1_GATE_USB_SLAVE_ENABLE               1
+#define POWER_MODE1_GATE_USB_HOST                       11:11
+#define POWER_MODE1_GATE_USB_HOST_DISABLE               0
+#define POWER_MODE1_GATE_USB_HOST_ENABLE                1
+#define POWER_MODE1_GATE_SSP0_SSP1                      10:10
+#define POWER_MODE1_GATE_SSP0_SSP1_DISABLE              0
+#define POWER_MODE1_GATE_SSP0_SSP1_ENABLE               1
+#define POWER_MODE1_GATE_UART1                          8:8
+#define POWER_MODE1_GATE_UART1_DISABLE                  0
+#define POWER_MODE1_GATE_UART1_ENABLE                   1
+#define POWER_MODE1_GATE_UART0                          7:7
+#define POWER_MODE1_GATE_UART0_DISABLE                  0
+#define POWER_MODE1_GATE_UART0_ENABLE                   1
+#define POWER_MODE1_GATE_GPIO_PWM_I2C                   6:6
+#define POWER_MODE1_GATE_GPIO_PWM_I2C_DISABLE           0
+#define POWER_MODE1_GATE_GPIO_PWM_I2C_ENABLE            1
+#define POWER_MODE1_GATE_ZVPORT                         5:5
+#define POWER_MODE1_GATE_ZVPORT_DISABLE                 0
+#define POWER_MODE1_GATE_ZVPORT_ENABLE                  1
+#define POWER_MODE1_GATE_CSC                            4:4
+#define POWER_MODE1_GATE_CSC_DISABLE                    0
+#define POWER_MODE1_GATE_CSC_ENABLE                     1
+#define POWER_MODE1_GATE_2D                             3:3
+#define POWER_MODE1_GATE_2D_DISABLE                     0
+#define POWER_MODE1_GATE_2D_ENABLE                      1
+#define POWER_MODE1_GATE_DISPLAY                        2:2
+#define POWER_MODE1_GATE_DISPLAY_DISABLE                0
+#define POWER_MODE1_GATE_DISPLAY_ENABLE                 1
+#define POWER_MODE1_GATE_INTMEM                         1:1
+#define POWER_MODE1_GATE_INTMEM_DISABLE                 0
+#define POWER_MODE1_GATE_INTMEM_ENABLE                  1
+#define POWER_MODE1_GATE_HOST                           0:0
+#define POWER_MODE1_GATE_HOST_DISABLE                   0
+#define POWER_MODE1_GATE_HOST_ENABLE                    1
+
+#define POWER_MODE1_CLOCK                               0x00004C
+#define POWER_MODE1_CLOCK_PLL3_P1XCLK					31:31
+#define POWER_MODE1_CLOCK_PLL3_P1XCLK_ENABLE			1
+#define POWER_MODE1_CLOCK_PLL3_P1XCLK_DISABLE			0
+#define POWER_MODE1_CLOCK_PLL3							30:30
+#define POWER_MODE1_CLOCK_PLL3_ENABLE					1
+#define POWER_MODE1_CLOCK_PLL3_DISABLE					0							
+#define POWER_MODE1_CLOCK_P2XCLK_SELECT                 29:29
+#define POWER_MODE1_CLOCK_P2XCLK_SELECT_288             0
+#define POWER_MODE1_CLOCK_P2XCLK_SELECT_336             1
+#define POWER_MODE1_CLOCK_P2XCLK_DIVIDER                28:27
+#define POWER_MODE1_CLOCK_P2XCLK_DIVIDER_1              0
+#define POWER_MODE1_CLOCK_P2XCLK_DIVIDER_3              1
+#define POWER_MODE1_CLOCK_P2XCLK_DIVIDER_5              2
+#define POWER_MODE1_CLOCK_P2XCLK_SHIFT                  26:24
+#define POWER_MODE1_CLOCK_P2XCLK_SHIFT_0                0
+#define POWER_MODE1_CLOCK_P2XCLK_SHIFT_1                1
+#define POWER_MODE1_CLOCK_P2XCLK_SHIFT_2                2
+#define POWER_MODE1_CLOCK_P2XCLK_SHIFT_3                3
+#define POWER_MODE1_CLOCK_P2XCLK_SHIFT_4                4
+#define POWER_MODE1_CLOCK_P2XCLK_SHIFT_5                5
+#define POWER_MODE1_CLOCK_P2XCLK_SHIFT_6                6
+#define POWER_MODE1_CLOCK_P2XCLK_SHIFT_7                7
+#define POWER_MODE1_CLOCK_V2XCLK_SELECT                 20:20
+#define POWER_MODE1_CLOCK_V2XCLK_SELECT_288             0
+#define POWER_MODE1_CLOCK_V2XCLK_SELECT_336             1
+#define POWER_MODE1_CLOCK_V2XCLK_DIVIDER                19:19
+#define POWER_MODE1_CLOCK_V2XCLK_DIVIDER_1              0
+#define POWER_MODE1_CLOCK_V2XCLK_DIVIDER_3              1
+#define POWER_MODE1_CLOCK_V2XCLK_SHIFT                  18:16
+#define POWER_MODE1_CLOCK_V2XCLK_SHIFT_0                0
+#define POWER_MODE1_CLOCK_V2XCLK_SHIFT_1                1
+#define POWER_MODE1_CLOCK_V2XCLK_SHIFT_2                2
+#define POWER_MODE1_CLOCK_V2XCLK_SHIFT_3                3
+#define POWER_MODE1_CLOCK_V2XCLK_SHIFT_4                4
+#define POWER_MODE1_CLOCK_V2XCLK_SHIFT_5                5
+#define POWER_MODE1_CLOCK_V2XCLK_SHIFT_6                6
+#define POWER_MODE1_CLOCK_V2XCLK_SHIFT_7                7
+#define POWER_MODE1_CLOCK_MCLK_SELECT                   12:12
+#define POWER_MODE1_CLOCK_MCLK_SELECT_288               0
+#define POWER_MODE1_CLOCK_MCLK_SELECT_336               1
+#define POWER_MODE1_CLOCK_MCLK_DIVIDER                  11:11
+#define POWER_MODE1_CLOCK_MCLK_DIVIDER_1                0
+#define POWER_MODE1_CLOCK_MCLK_DIVIDER_3                1
+#define POWER_MODE1_CLOCK_MCLK_SHIFT                    10:8
+#define POWER_MODE1_CLOCK_MCLK_SHIFT_0                  0
+#define POWER_MODE1_CLOCK_MCLK_SHIFT_1                  1
+#define POWER_MODE1_CLOCK_MCLK_SHIFT_2                  2
+#define POWER_MODE1_CLOCK_MCLK_SHIFT_3                  3
+#define POWER_MODE1_CLOCK_MCLK_SHIFT_4                  4
+#define POWER_MODE1_CLOCK_MCLK_SHIFT_5                  5
+#define POWER_MODE1_CLOCK_MCLK_SHIFT_6                  6
+#define POWER_MODE1_CLOCK_MCLK_SHIFT_7                  7
+#define POWER_MODE1_CLOCK_M2XCLK_SELECT                 4:4
+#define POWER_MODE1_CLOCK_M2XCLK_SELECT_288             0
+#define POWER_MODE1_CLOCK_M2XCLK_SELECT_336             1
+#define POWER_MODE1_CLOCK_M2XCLK_DIVIDER                3:3
+#define POWER_MODE1_CLOCK_M2XCLK_DIVIDER_1              0
+#define POWER_MODE1_CLOCK_M2XCLK_DIVIDER_3              1
+#define POWER_MODE1_CLOCK_M2XCLK_SHIFT                  2:0
+#define POWER_MODE1_CLOCK_M2XCLK_SHIFT_0                0
+#define POWER_MODE1_CLOCK_M2XCLK_SHIFT_1                1
+#define POWER_MODE1_CLOCK_M2XCLK_SHIFT_2                2
+#define POWER_MODE1_CLOCK_M2XCLK_SHIFT_3                3
+#define POWER_MODE1_CLOCK_M2XCLK_SHIFT_4                4
+#define POWER_MODE1_CLOCK_M2XCLK_SHIFT_5                5
+#define POWER_MODE1_CLOCK_M2XCLK_SHIFT_6                6
+#define POWER_MODE1_CLOCK_M2XCLK_SHIFT_7                7
+
+#define POWER_SLEEP_GATE                                0x000050
+#define POWER_SLEEP_GATE_PLL_RECOVERY_CLOCK             22:19
+#define POWER_SLEEP_GATE_PLL_RECOVERY_CLOCK_4096        0
+#define POWER_SLEEP_GATE_PLL_RECOVERY_CLOCK_2048        1
+#define POWER_SLEEP_GATE_PLL_RECOVERY_CLOCK_1024        2
+#define POWER_SLEEP_GATE_PLL_RECOVERY_CLOCK_512         3
+#define POWER_SLEEP_GATE_PLL_RECOVERY_CLOCK_256         4
+#define POWER_SLEEP_GATE_PLL_RECOVERY_CLOCK_128         5
+#define POWER_SLEEP_GATE_PLL_RECOVERY_CLOCK_64          6
+#define POWER_SLEEP_GATE_PLL_RECOVERY_CLOCK_32          7
+#define POWER_SLEEP_GATE_PLL_RECOVERY_CLOCK_16          8
+#define POWER_SLEEP_GATE_PLL_RECOVERY_CLOCK_8           9
+#define POWER_SLEEP_GATE_PLL_RECOVERY_CLOCK_4           10
+#define POWER_SLEEP_GATE_PLL_RECOVERY_CLOCK_2           11
+#define POWER_SLEEP_GATE_PLL_RECOVERY                   14:13
+#define POWER_SLEEP_GATE_PLL_RECOVERY_32                0
+#define POWER_SLEEP_GATE_PLL_RECOVERY_64                1
+#define POWER_SLEEP_GATE_PLL_RECOVERY_96                2
+#define POWER_SLEEP_GATE_PLL_RECOVERY_128               3
+
+#define POWER_MODE_CTRL                                 0x000054
+#define POWER_MODE_CTRL_SLEEP_STATUS                    2:2
+#define POWER_MODE_CTRL_SLEEP_STATUS_INACTIVE           0
+#define POWER_MODE_CTRL_SLEEP_STATUS_ACTIVE             1
+#define POWER_MODE_CTRL_MODE                            1:0
+#define POWER_MODE_CTRL_MODE_MODE0                      0
+#define POWER_MODE_CTRL_MODE_MODE1                      1
+#define POWER_MODE_CTRL_MODE_SLEEP                      2
+
+#define PCI_MASTER_BASE                                 0x000058
+#define PCI_MASTER_BASE_ADDRESS                         31:20
+
+#define ENDIAN_CTRL                                     0x00005C
+#define ENDIAN_CTRL_ENDIAN                              0:0
+#define ENDIAN_CTRL_ENDIAN_LITTLE                       0
+#define ENDIAN_CTRL_ENDIAN_BIG                          1
+
+#define DEVICE_ID                                       0x000060
+#define DEVICE_ID_DEVICE_ID                             31:16
+#define DEVICE_ID_REVISION_ID                           7:0
+
+#define PLL_CLOCK_COUNT                                 0x000064
+#define PLL_CLOCK_COUNT_COUNTER                         15:0
+
+#define SYSTEM_DRAM_CTRL                                0x000068
+#define SYSTEM_DRAM_CTRL_READ_DELAY                     2:0
+#define SYSTEM_DRAM_CTRL_READ_DELAY_OFF                 0
+#define SYSTEM_DRAM_CTRL_READ_DELAY_0_5NS               1
+#define SYSTEM_DRAM_CTRL_READ_DELAY_1NS                 2
+#define SYSTEM_DRAM_CTRL_READ_DELAY_1_5NS               3
+#define SYSTEM_DRAM_CTRL_READ_DELAY_2NS                 4
+#define SYSTEM_DRAM_CTRL_READ_DELAY_2_5NS               5
+
+#define SYSTEM_PLL3_CLOCK								0x000074
+#define SYSTEM_PLL3_CLOCK_M								7:0
+#define SYSTEM_PLL3_CLOCK_N								14:8
+#define SYSTEM_PLL3_CLOCK_DIVIDE						15:15
+#define SYSTEM_PLL3_CLOCK_DIVIDE_1						0
+#define SYSTEM_PLL3_CLOCK_DIVIDE_2						1
+#define SYSTEM_PLL3_CLOCK_INPUT							16:16
+#define SYSTEM_PLL3_CLOCK_INPUT_CRYSTAL					0
+#define SYSTEM_PLL3_CLOCK_INPUT_TEST					1
+#define SYSTEM_PLL3_CLOCK_POWER							17:17
+#define SYSTEM_PLL3_CLOCK_POWER_OFF						0
+#define SYSTEM_PLL3_CLOCK_POWER_ON						1						
+
+
+#define CURRENT_POWER_PLLCLOCK                    0x000074
+#define CURRENT_POWER_PLLCLOCK_TEST_OUTPUT            	20:20
+#define CURRENT_POWER_PLLCLOCK_TEST_OUTPUT_ENABLE		1
+#define CURRENT_POWER_PLLCLOCK_TEST_OUTPUT_DISABLE      	0
+#define CURRENT_POWER_PLLCLOCK_TESTMODE              	19:18
+#define CURRENT_POWER_PLLCLOCK_TESTMODE_ENABLE              	1
+#define CURRENT_POWER_PLLCLOCK_TESTMODE_DISABLE            	0
+#define CURRENT_POWER_PLLCLOCK_POWER              	17:17
+#define CURRENT_POWER_PLLCLOCK_POWER_DOWN              	0
+#define CURRENT_POWER_PLLCLOCK_POWER_ON              	1
+#define CURRENT_POWER_PLLCLOCK_INPUT_SELECT              16:16
+#define CURRENT_POWER_PLLCLOCK_INPUT_SELECT_TEST        1
+#define CURRENT_POWER_PLLCLOCK_INPUT_SELECT_CRYSTAL    0
+#define CURRENT_POWER_PLLCLOCK_DIVIDEBY2                    15:15
+#define CURRENT_POWER_PLLCLOCK_DIVIDE_N                     14:8
+#define CURRENT_POWER_PLLCLOCK_MULTIPLE_M                     7:0
+
+// Panel Graphics Control
+
+#define PANEL_DISPLAY_CTRL                              0x080000
+#define PANEL_DISPLAY_CTRL_FPEN                         27:27
+#define PANEL_DISPLAY_CTRL_FPEN_LOW                     0
+#define PANEL_DISPLAY_CTRL_FPEN_HIGH                    1
+#define PANEL_DISPLAY_CTRL_VBIASEN                      26:26
+#define PANEL_DISPLAY_CTRL_VBIASEN_LOW                  0
+#define PANEL_DISPLAY_CTRL_VBIASEN_HIGH                 1
+#define PANEL_DISPLAY_CTRL_DATA                         25:25
+#define PANEL_DISPLAY_CTRL_DATA_DISABLE                 0
+#define PANEL_DISPLAY_CTRL_DATA_ENABLE                  1
+#define PANEL_DISPLAY_CTRL_FPVDDEN                      24:24
+#define PANEL_DISPLAY_CTRL_FPVDDEN_LOW                  0
+#define PANEL_DISPLAY_CTRL_FPVDDEN_HIGH                 1
+#define PANEL_DISPLAY_CTRL_PATTERN                      23:23
+#define PANEL_DISPLAY_CTRL_PATTERN_4                    0
+#define PANEL_DISPLAY_CTRL_PATTERN_8                    1
+#define PANEL_DISPLAY_CTRL_TFT                          22:21
+#define PANEL_DISPLAY_CTRL_TFT_24                       0
+#define PANEL_DISPLAY_CTRL_TFT_9                        1
+#define PANEL_DISPLAY_CTRL_TFT_12                       2
+#define PANEL_DISPLAY_CTRL_DITHER                       20:20
+#define PANEL_DISPLAY_CTRL_DITHER_DISABLE               0
+#define PANEL_DISPLAY_CTRL_DITHER_ENABLE                1
+#define PANEL_DISPLAY_CTRL_LCD                          19:18
+#define PANEL_DISPLAY_CTRL_LCD_TFT                      0
+#define PANEL_DISPLAY_CTRL_LCD_STN_8                    2
+#define PANEL_DISPLAY_CTRL_LCD_STN_12                   3
+#define PANEL_DISPLAY_CTRL_FIFO                         17:16
+#define PANEL_DISPLAY_CTRL_FIFO_1                       0
+#define PANEL_DISPLAY_CTRL_FIFO_3                       1
+#define PANEL_DISPLAY_CTRL_FIFO_7                       2
+#define PANEL_DISPLAY_CTRL_FIFO_11                      3
+#define PANEL_DISPLAY_CTRL_CLOCK_PHASE                  14:14
+#define PANEL_DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_HIGH      0
+#define PANEL_DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_LOW       1
+#define PANEL_DISPLAY_CTRL_VSYNC_PHASE                  13:13
+#define PANEL_DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_HIGH      0
+#define PANEL_DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_LOW       1
+#define PANEL_DISPLAY_CTRL_HSYNC_PHASE                  12:12
+#define PANEL_DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_HIGH      0
+#define PANEL_DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_LOW       1
+#define PANEL_DISPLAY_CTRL_COLOR_KEY                    9:9
+#define PANEL_DISPLAY_CTRL_COLOR_KEY_DISABLE            0
+#define PANEL_DISPLAY_CTRL_COLOR_KEY_ENABLE             1
+#define PANEL_DISPLAY_CTRL_TIMING                       8:8
+#define PANEL_DISPLAY_CTRL_TIMING_DISABLE               0
+#define PANEL_DISPLAY_CTRL_TIMING_ENABLE                1
+#define PANEL_DISPLAY_CTRL_VERTICAL_PAN_DIR             7:7
+#define PANEL_DISPLAY_CTRL_VERTICAL_PAN_DIR_DOWN        0
+#define PANEL_DISPLAY_CTRL_VERTICAL_PAN_DIR_UP          1
+#define PANEL_DISPLAY_CTRL_VERTICAL_PAN                 6:6
+#define PANEL_DISPLAY_CTRL_VERTICAL_PAN_DISABLE         0
+#define PANEL_DISPLAY_CTRL_VERTICAL_PAN_ENABLE          1
+#define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN_DIR           5:5
+#define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN_DIR_RIGHT     0
+#define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN_DIR_LEFT      1
+#define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN               4:4
+#define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN_DISABLE       0
+#define PANEL_DISPLAY_CTRL_HORIZONTAL_PAN_ENABLE        1
+#define PANEL_DISPLAY_CTRL_GAMMA                        3:3
+#define PANEL_DISPLAY_CTRL_GAMMA_DISABLE                0
+#define PANEL_DISPLAY_CTRL_GAMMA_ENABLE                 1
+#define PANEL_DISPLAY_CTRL_PLANE                        2:2
+#define PANEL_DISPLAY_CTRL_PLANE_DISABLE                0
+#define PANEL_DISPLAY_CTRL_PLANE_ENABLE                 1
+#define PANEL_DISPLAY_CTRL_FORMAT                       1:0
+#define PANEL_DISPLAY_CTRL_FORMAT_8                     0
+#define PANEL_DISPLAY_CTRL_FORMAT_16                    1
+#define PANEL_DISPLAY_CTRL_FORMAT_32                    2
+
+#define PANEL_PAN_CTRL                                  0x080004
+#define PANEL_PAN_CTRL_VERTICAL_PAN                     31:24
+#define PANEL_PAN_CTRL_VERTICAL_VSYNC                   21:16
+#define PANEL_PAN_CTRL_HORIZONTAL_PAN                   15:8
+#define PANEL_PAN_CTRL_HORIZONTAL_VSYNC                 5:0
+
+#define PANEL_COLOR_KEY                                 0x080008
+#define PANEL_COLOR_KEY_MASK                            31:16
+#define PANEL_COLOR_KEY_VALUE                           15:0
+
+#define PANEL_FB_ADDRESS                                0x08000C
+#define PANEL_FB_ADDRESS_STATUS                         31:31
+#define PANEL_FB_ADDRESS_STATUS_CURRENT                 0
+#define PANEL_FB_ADDRESS_STATUS_PENDING                 1
+#define PANEL_FB_ADDRESS_EXT                            27:27
+#define PANEL_FB_ADDRESS_EXT_LOCAL                      0
+#define PANEL_FB_ADDRESS_EXT_EXTERNAL                   1
+#define PANEL_FB_ADDRESS_CS                             26:26
+#define PANEL_FB_ADDRESS_CS_0                           0
+#define PANEL_FB_ADDRESS_CS_1                           1
+#define PANEL_FB_ADDRESS_ADDRESS                        25:0
+
+#define PANEL_FB_WIDTH                                  0x080010
+#define PANEL_FB_WIDTH_WIDTH                            29:16
+#define PANEL_FB_WIDTH_OFFSET                           13:0
+
+#define PANEL_WINDOW_WIDTH                              0x080014
+#define PANEL_WINDOW_WIDTH_WIDTH                        27:16
+#define PANEL_WINDOW_WIDTH_X                            11:0
+
+#define PANEL_WINDOW_HEIGHT                             0x080018
+#define PANEL_WINDOW_HEIGHT_HEIGHT                      27:16
+#define PANEL_WINDOW_HEIGHT_Y                           11:0
+
+#define PANEL_PLANE_TL                                  0x08001C
+#define PANEL_PLANE_TL_TOP                              26:16
+#define PANEL_PLANE_TL_LEFT                             10:0
+
+#define PANEL_PLANE_BR                                  0x080020
+#define PANEL_PLANE_BR_BOTTOM                           26:16
+#define PANEL_PLANE_BR_RIGHT                            10:0
+
+#define PANEL_HORIZONTAL_TOTAL                          0x080024
+#define PANEL_HORIZONTAL_TOTAL_TOTAL                    27:16
+#define PANEL_HORIZONTAL_TOTAL_DISPLAY_END              11:0
+
+#define PANEL_HORIZONTAL_SYNC                           0x080028
+#define PANEL_HORIZONTAL_SYNC_WIDTH                     23:16
+#define PANEL_HORIZONTAL_SYNC_START                     11:0
+
+#define PANEL_VERTICAL_TOTAL                            0x08002C
+#define PANEL_VERTICAL_TOTAL_TOTAL                      26:16
+#define PANEL_VERTICAL_TOTAL_DISPLAY_END                10:0
+
+#define PANEL_VERTICAL_SYNC                             0x080030
+#define PANEL_VERTICAL_SYNC_HEIGHT                      21:16
+#define PANEL_VERTICAL_SYNC_START                       10:0
+
+#define PANEL_CURRENT_LINE                              0x080034
+#define PANEL_CURRENT_LINE_LINE                         10:0
+
+// Video Control
+
+#define VIDEO_DISPLAY_CTRL                              0x080040
+#define VIDEO_DISPLAY_CTRL_FIFO                         17:16
+#define VIDEO_DISPLAY_CTRL_FIFO_1                       0
+#define VIDEO_DISPLAY_CTRL_FIFO_3                       1
+#define VIDEO_DISPLAY_CTRL_FIFO_7                       2
+#define VIDEO_DISPLAY_CTRL_FIFO_11                      3
+#define VIDEO_DISPLAY_CTRL_BUFFER                       15:15
+#define VIDEO_DISPLAY_CTRL_BUFFER_0                     0
+#define VIDEO_DISPLAY_CTRL_BUFFER_1                     1
+#define VIDEO_DISPLAY_CTRL_CAPTURE                      14:14
+#define VIDEO_DISPLAY_CTRL_CAPTURE_DISABLE              0
+#define VIDEO_DISPLAY_CTRL_CAPTURE_ENABLE               1
+#define VIDEO_DISPLAY_CTRL_DOUBLE_BUFFER                13:13
+#define VIDEO_DISPLAY_CTRL_DOUBLE_BUFFER_DISABLE        0
+#define VIDEO_DISPLAY_CTRL_DOUBLE_BUFFER_ENABLE         1
+#define VIDEO_DISPLAY_CTRL_BYTE_SWAP                    12:12
+#define VIDEO_DISPLAY_CTRL_BYTE_SWAP_DISABLE            0
+#define VIDEO_DISPLAY_CTRL_BYTE_SWAP_ENABLE             1
+#define VIDEO_DISPLAY_CTRL_VERTICAL_SCALE               11:11
+#define VIDEO_DISPLAY_CTRL_VERTICAL_SCALE_NORMAL        0
+#define VIDEO_DISPLAY_CTRL_VERTICAL_SCALE_HALF          1
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_SCALE             10:10
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_SCALE_NORMAL      0
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_SCALE_HALF        1
+#define VIDEO_DISPLAY_CTRL_VERTICAL_MODE                9:9
+#define VIDEO_DISPLAY_CTRL_VERTICAL_MODE_REPLICATE      0
+#define VIDEO_DISPLAY_CTRL_VERTICAL_MODE_INTERPOLATE    1
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE              8:8
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE_REPLICATE    0
+#define VIDEO_DISPLAY_CTRL_HORIZONTAL_MODE_INTERPOLATE  1
+#define VIDEO_DISPLAY_CTRL_PIXEL                        7:4
+#define VIDEO_DISPLAY_CTRL_GAMMA                        3:3
+#define VIDEO_DISPLAY_CTRL_GAMMA_DISABLE                0
+#define VIDEO_DISPLAY_CTRL_GAMMA_ENABLE                 1
+#define VIDEO_DISPLAY_CTRL_PLANE                        2:2
+#define VIDEO_DISPLAY_CTRL_PLANE_DISABLE                0
+#define VIDEO_DISPLAY_CTRL_PLANE_ENABLE                 1
+#define VIDEO_DISPLAY_CTRL_FORMAT                       1:0
+#define VIDEO_DISPLAY_CTRL_FORMAT_8                     0
+#define VIDEO_DISPLAY_CTRL_FORMAT_16                    1
+#define VIDEO_DISPLAY_CTRL_FORMAT_32                    2
+#define VIDEO_DISPLAY_CTRL_FORMAT_YUV                   3
+
+#define VIDEO_FB_0_ADDRESS                              0x080044
+#define VIDEO_FB_0_ADDRESS_STATUS                       31:31
+#define VIDEO_FB_0_ADDRESS_STATUS_CURRENT               0
+#define VIDEO_FB_0_ADDRESS_STATUS_PENDING               1
+#define VIDEO_FB_0_ADDRESS_EXT                          27:27
+#define VIDEO_FB_0_ADDRESS_EXT_LOCAL                    0
+#define VIDEO_FB_0_ADDRESS_EXT_EXTERNAL                 1
+#define VIDEO_FB_0_ADDRESS_CS                           26:26
+#define VIDEO_FB_0_ADDRESS_CS_0                         0
+#define VIDEO_FB_0_ADDRESS_CS_1                         1
+#define VIDEO_FB_0_ADDRESS_ADDRESS                      25:0
+
+#define VIDEO_FB_WIDTH                                  0x080048
+#define VIDEO_FB_WIDTH_WIDTH                            29:16
+#define VIDEO_FB_WIDTH_OFFSET                           13:0
+
+#define VIDEO_FB_0_LAST_ADDRESS                         0x08004C
+#define VIDEO_FB_0_LAST_ADDRESS_EXT                     27:27
+#define VIDEO_FB_0_LAST_ADDRESS_EXT_LOCAL               0
+#define VIDEO_FB_0_LAST_ADDRESS_EXT_EXTERNAL            1
+#define VIDEO_FB_0_LAST_ADDRESS_CS                      26:26
+#define VIDEO_FB_0_LAST_ADDRESS_CS_0                    0
+#define VIDEO_FB_0_LAST_ADDRESS_CS_1                    1
+#define VIDEO_FB_0_LAST_ADDRESS_ADDRESS                 25:0
+
+#define VIDEO_PLANE_TL                                  0x080050
+#define VIDEO_PLANE_TL_TOP                              26:16
+#define VIDEO_PLANE_TL_LEFT                             13:0
+
+#define VIDEO_PLANE_BR                                  0x080054
+#define VIDEO_PLANE_BR_BOTTOM                           26:16
+#define VIDEO_PLANE_BR_RIGHT                            13:0
+
+#define VIDEO_SCALE                                     0x080058
+#define VIDEO_SCALE_VERTICAL_MODE                       31:31
+#define VIDEO_SCALE_VERTICAL_MODE_EXPAND                0
+#define VIDEO_SCALE_VERTICAL_MODE_SHRINK                1
+#define VIDEO_SCALE_VERTICAL_SCALE                      27:16
+#define VIDEO_SCALE_HORIZONTAL_MODE                     15:15
+#define VIDEO_SCALE_HORIZONTAL_MODE_EXPAND              0
+#define VIDEO_SCALE_HORIZONTAL_MODE_SHRINK              1
+#define VIDEO_SCALE_HORIZONTAL_SCALE                    11:0
+
+#define VIDEO_INITIAL_SCALE                             0x08005C
+#define VIDEO_INITIAL_SCALE_FB_1                        27:16
+#define VIDEO_INITIAL_SCALE_FB_0                        11:0
+
+#define VIDEO_YUV_CONSTANTS                             0x080060
+#define VIDEO_YUV_CONSTANTS_Y                           31:24
+#define VIDEO_YUV_CONSTANTS_R                           23:16
+#define VIDEO_YUV_CONSTANTS_G                           15:8
+#define VIDEO_YUV_CONSTANTS_B                           7:0
+
+#define VIDEO_FB_1_ADDRESS                              0x080064
+#define VIDEO_FB_1_ADDRESS_STATUS                       31:31
+#define VIDEO_FB_1_ADDRESS_STATUS_CURRENT               0
+#define VIDEO_FB_1_ADDRESS_STATUS_PENDING               1
+#define VIDEO_FB_1_ADDRESS_EXT                          27:27
+#define VIDEO_FB_1_ADDRESS_EXT_LOCAL                    0
+#define VIDEO_FB_1_ADDRESS_EXT_EXTERNAL                 1
+#define VIDEO_FB_1_ADDRESS_CS                           26:26
+#define VIDEO_FB_1_ADDRESS_CS_0                         0
+#define VIDEO_FB_1_ADDRESS_CS_1                         1
+#define VIDEO_FB_1_ADDRESS_ADDRESS                      25:0
+
+#define VIDEO_FB_1_LAST_ADDRESS                         0x080068
+#define VIDEO_FB_1_LAST_ADDRESS_EXT                     27:27
+#define VIDEO_FB_1_LAST_ADDRESS_EXT_LOCAL               0
+#define VIDEO_FB_1_LAST_ADDRESS_EXT_EXTERNAL            1
+#define VIDEO_FB_1_LAST_ADDRESS_CS                      26:26
+#define VIDEO_FB_1_LAST_ADDRESS_CS_0                    0
+#define VIDEO_FB_1_LAST_ADDRESS_CS_1                    1
+#define VIDEO_FB_1_LAST_ADDRESS_ADDRESS                 25:0
+
+// Video Alpha Control
+
+#define VIDEO_ALPHA_DISPLAY_CTRL                        0x080080
+#define VIDEO_ALPHA_DISPLAY_CTRL_SELECT                 28:28
+#define VIDEO_ALPHA_DISPLAY_CTRL_SELECT_PER_PIXEL       0
+#define VIDEO_ALPHA_DISPLAY_CTRL_SELECT_ALPHA           1
+#define VIDEO_ALPHA_DISPLAY_CTRL_ALPHA                  27:24
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO                   17:16
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_1                 0
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_3                 1
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_7                 2
+#define VIDEO_ALPHA_DISPLAY_CTRL_FIFO_11                3
+#define VIDEO_ALPHA_DISPLAY_CTRL_VERT_SCALE             11:11
+#define VIDEO_ALPHA_DISPLAY_CTRL_VERT_SCALE_NORMAL      0
+#define VIDEO_ALPHA_DISPLAY_CTRL_VERT_SCALE_HALF        1
+#define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_SCALE             10:10
+#define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_SCALE_NORMAL      0
+#define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_SCALE_HALF        1
+#define VIDEO_ALPHA_DISPLAY_CTRL_VERT_MODE              9:9
+#define VIDEO_ALPHA_DISPLAY_CTRL_VERT_MODE_REPLICATE    0
+#define VIDEO_ALPHA_DISPLAY_CTRL_VERT_MODE_INTERPOLATE  1
+#define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_MODE              8:8
+#define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_MODE_REPLICATE    0
+#define VIDEO_ALPHA_DISPLAY_CTRL_HORZ_MODE_INTERPOLATE  1
+#define VIDEO_ALPHA_DISPLAY_CTRL_PIXEL                  7:4
+#define VIDEO_ALPHA_DISPLAY_CTRL_CHROMA_KEY             3:3
+#define VIDEO_ALPHA_DISPLAY_CTRL_CHROMA_KEY_DISABLE     0
+#define VIDEO_ALPHA_DISPLAY_CTRL_CHROMA_KEY_ENABLE      1
+#define VIDEO_ALPHA_DISPLAY_CTRL_PLANE                  2:2
+#define VIDEO_ALPHA_DISPLAY_CTRL_PLANE_DISABLE          0
+#define VIDEO_ALPHA_DISPLAY_CTRL_PLANE_ENABLE           1
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT                 1:0
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_8               0
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_16              1
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4       2
+#define VIDEO_ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4_4_4   3
+
+#define VIDEO_ALPHA_FB_ADDRESS                          0x080084
+#define VIDEO_ALPHA_FB_ADDRESS_STATUS                   31:31
+#define VIDEO_ALPHA_FB_ADDRESS_STATUS_CURRENT           0
+#define VIDEO_ALPHA_FB_ADDRESS_STATUS_PENDING           1
+#define VIDEO_ALPHA_FB_ADDRESS_EXT                      27:27
+#define VIDEO_ALPHA_FB_ADDRESS_EXT_LOCAL                0
+#define VIDEO_ALPHA_FB_ADDRESS_EXT_EXTERNAL             1
+#define VIDEO_ALPHA_FB_ADDRESS_CS                       26:26
+#define VIDEO_ALPHA_FB_ADDRESS_CS_0                     0
+#define VIDEO_ALPHA_FB_ADDRESS_CS_1                     1
+#define VIDEO_ALPHA_FB_ADDRESS_ADDRESS                  25:0
+
+#define VIDEO_ALPHA_FB_WIDTH                            0x080088
+#define VIDEO_ALPHA_FB_WIDTH_WIDTH                      29:16
+#define VIDEO_ALPHA_FB_WIDTH_OFFSET                     13:0
+
+#define VIDEO_ALPHA_FB_LAST_ADDRESS                     0x08008C
+#define VIDEO_ALPHA_FB_LAST_ADDRESS_EXT                 27:27
+#define VIDEO_ALPHA_FB_LAST_ADDRESS_EXT_LOCAL           0
+#define VIDEO_ALPHA_FB_LAST_ADDRESS_EXT_EXTERNAL        1
+#define VIDEO_ALPHA_FB_LAST_ADDRESS_CS                  26:26
+#define VIDEO_ALPHA_FB_LAST_ADDRESS_CS_0                0
+#define VIDEO_ALPHA_FB_LAST_ADDRESS_CS_1                1
+#define VIDEO_ALPHA_FB_LAST_ADDRESS_ADDRESS             25:0
+
+#define VIDEO_ALPHA_PLANE_TL                            0x080090
+#define VIDEO_ALPHA_PLANE_TL_TOP                        26:16
+#define VIDEO_ALPHA_PLANE_TL_LEFT                       10:0
+
+#define VIDEO_ALPHA_PLANE_BR                            0x080094
+#define VIDEO_ALPHA_PLANE_BR_BOTTOM                     26:16
+#define VIDEO_ALPHA_PLANE_BR_RIGHT                      10:0
+
+#define VIDEO_ALPHA_SCALE                               0x080098
+#define VIDEO_ALPHA_SCALE_VERTICAL_MODE                 31:31
+#define VIDEO_ALPHA_SCALE_VERTICAL_MODE_EXPAND          0
+#define VIDEO_ALPHA_SCALE_VERTICAL_MODE_SHRINK          1
+#define VIDEO_ALPHA_SCALE_VERTICAL_SCALE                27:16
+#define VIDEO_ALPHA_SCALE_HORIZONTAL_MODE               15:15
+#define VIDEO_ALPHA_SCALE_HORIZONTAL_MODE_EXPAND        0
+#define VIDEO_ALPHA_SCALE_HORIZONTAL_MODE_SHRINK        1
+#define VIDEO_ALPHA_SCALE_HORIZONTAL_SCALE              11:0
+
+#define VIDEO_ALPHA_INITIAL_SCALE                       0x08009C
+#define VIDEO_ALPHA_INITIAL_SCALE_FB                    11:0
+
+#define VIDEO_ALPHA_CHROMA_KEY                          0x0800A0
+#define VIDEO_ALPHA_CHROMA_KEY_MASK                     31:16
+#define VIDEO_ALPHA_CHROMA_KEY_VALUE                    15:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_01                     0x0800A4
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_1_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_1_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_1_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_0_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_0_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_01_0_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_23                     0x0800A8
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_3_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_3_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_3_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_2_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_2_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_23_2_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_45                     0x0800AC
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_5_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_5_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_5_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_4_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_4_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_45_4_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_67                     0x0800B0
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_7_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_7_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_7_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_6_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_6_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_67_6_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_89                     0x0800B4
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_9_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_9_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_9_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_8_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_8_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_89_8_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB                     0x0800B8
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_B_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_AB_A_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD                     0x0800BC
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_D_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_CD_C_BLUE              4:0
+
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF                     0x0800C0
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_RED               31:27
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_GREEN             26:21
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_F_BLUE              20:16
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_RED               15:11
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_GREEN             10:5
+#define VIDEO_ALPHA_COLOR_LOOKUP_EF_E_BLUE              4:0
+
+// Panel Cursor Control
+
+#define PANEL_HWC_ADDRESS                               0x0800F0
+#define PANEL_HWC_ADDRESS_ENABLE                        31:31
+#define PANEL_HWC_ADDRESS_ENABLE_DISABLE                0
+#define PANEL_HWC_ADDRESS_ENABLE_ENABLE                 1
+#define PANEL_HWC_ADDRESS_EXT                           27:27
+#define PANEL_HWC_ADDRESS_EXT_LOCAL                     0
+#define PANEL_HWC_ADDRESS_EXT_EXTERNAL                  1
+#define PANEL_HWC_ADDRESS_CS                            26:26
+#define PANEL_HWC_ADDRESS_CS_0                          0
+#define PANEL_HWC_ADDRESS_CS_1                          1
+#define PANEL_HWC_ADDRESS_ADDRESS                       25:0
+
+#define PANEL_HWC_LOCATION                              0x0800F4
+#define PANEL_HWC_LOCATION_TOP                          27:27
+#define PANEL_HWC_LOCATION_TOP_INSIDE                   0
+#define PANEL_HWC_LOCATION_TOP_OUTSIDE                  1
+#define PANEL_HWC_LOCATION_Y                            26:16
+#define PANEL_HWC_LOCATION_LEFT                         11:11
+#define PANEL_HWC_LOCATION_LEFT_INSIDE                  0
+#define PANEL_HWC_LOCATION_LEFT_OUTSIDE                 1
+#define PANEL_HWC_LOCATION_X                            10:0
+
+#define PANEL_HWC_COLOR_12                              0x0800F8
+#define PANEL_HWC_COLOR_12_2_RGB565                     31:16
+#define PANEL_HWC_COLOR_12_1_RGB565                     15:0
+
+#define PANEL_HWC_COLOR_3                               0x0800FC
+#define PANEL_HWC_COLOR_3_RGB565                        15:0
+
+// Old Definitions +++
+#define PANEL_HWC_COLOR_01                              0x0800F8
+#define PANEL_HWC_COLOR_01_1_RED                        31:27
+#define PANEL_HWC_COLOR_01_1_GREEN                      26:21
+#define PANEL_HWC_COLOR_01_1_BLUE                       20:16
+#define PANEL_HWC_COLOR_01_0_RED                        15:11
+#define PANEL_HWC_COLOR_01_0_GREEN                      10:5
+#define PANEL_HWC_COLOR_01_0_BLUE                       4:0
+
+#define PANEL_HWC_COLOR_2                               0x0800FC
+#define PANEL_HWC_COLOR_2_RED                           15:11
+#define PANEL_HWC_COLOR_2_GREEN                         10:5
+#define PANEL_HWC_COLOR_2_BLUE                          4:0
+// Old Definitions ---
+
+// Alpha Control
+
+#define ALPHA_DISPLAY_CTRL                              0x080100
+#define ALPHA_DISPLAY_CTRL_SELECT                       28:28
+#define ALPHA_DISPLAY_CTRL_SELECT_PER_PIXEL             0
+#define ALPHA_DISPLAY_CTRL_SELECT_ALPHA                 1
+#define ALPHA_DISPLAY_CTRL_ALPHA                        27:24
+#define ALPHA_DISPLAY_CTRL_FIFO                         17:16
+#define ALPHA_DISPLAY_CTRL_FIFO_1                       0
+#define ALPHA_DISPLAY_CTRL_FIFO_3                       1
+#define ALPHA_DISPLAY_CTRL_FIFO_7                       2
+#define ALPHA_DISPLAY_CTRL_FIFO_11                      3
+#define ALPHA_DISPLAY_CTRL_PIXEL                        7:4
+#define ALPHA_DISPLAY_CTRL_CHROMA_KEY                   3:3
+#define ALPHA_DISPLAY_CTRL_CHROMA_KEY_DISABLE           0
+#define ALPHA_DISPLAY_CTRL_CHROMA_KEY_ENABLE            1
+#define ALPHA_DISPLAY_CTRL_PLANE                        2:2
+#define ALPHA_DISPLAY_CTRL_PLANE_DISABLE                0
+#define ALPHA_DISPLAY_CTRL_PLANE_ENABLE                 1
+#define ALPHA_DISPLAY_CTRL_FORMAT                       1:0
+#define ALPHA_DISPLAY_CTRL_FORMAT_16                    1
+#define ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4             2
+#define ALPHA_DISPLAY_CTRL_FORMAT_ALPHA_4_4_4_4         3
+
+#define ALPHA_FB_ADDRESS                                0x080104
+#define ALPHA_FB_ADDRESS_STATUS                         31:31
+#define ALPHA_FB_ADDRESS_STATUS_CURRENT                 0
+#define ALPHA_FB_ADDRESS_STATUS_PENDING                 1
+#define ALPHA_FB_ADDRESS_EXT                            27:27
+#define ALPHA_FB_ADDRESS_EXT_LOCAL                      0
+#define ALPHA_FB_ADDRESS_EXT_EXTERNAL                   1
+#define ALPHA_FB_ADDRESS_CS                             26:26
+#define ALPHA_FB_ADDRESS_CS_0                           0
+#define ALPHA_FB_ADDRESS_CS_1                           1
+#define ALPHA_FB_ADDRESS_ADDRESS                        25:0
+
+#define ALPHA_FB_WIDTH                                  0x080108
+#define ALPHA_FB_WIDTH_WIDTH                            29:16
+#define ALPHA_FB_WIDTH_OFFSET                           13:0
+
+#define ALPHA_PLANE_TL                                  0x08010C
+#define ALPHA_PLANE_TL_TOP                              26:16
+#define ALPHA_PLANE_TL_LEFT                             10:0
+
+#define ALPHA_PLANE_BR                                  0x080110
+#define ALPHA_PLANE_BR_BOTTOM                           26:16
+#define ALPHA_PLANE_BR_RIGHT                            10:0
+
+#define ALPHA_CHROMA_KEY                                0x080114
+#define ALPHA_CHROMA_KEY_MASK                           31:16
+#define ALPHA_CHROMA_KEY_VALUE                          15:0
+
+#define ALPHA_COLOR_LOOKUP_01                           0x080118
+#define ALPHA_COLOR_LOOKUP_01_1_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_01_1_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_01_1_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_01_0_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_01_0_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_01_0_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_23                           0x08011C
+#define ALPHA_COLOR_LOOKUP_23_3_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_23_3_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_23_3_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_23_2_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_23_2_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_23_2_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_45                           0x080120
+#define ALPHA_COLOR_LOOKUP_45_5_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_45_5_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_45_5_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_45_4_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_45_4_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_45_4_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_67                           0x080124
+#define ALPHA_COLOR_LOOKUP_67_7_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_67_7_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_67_7_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_67_6_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_67_6_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_67_6_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_89                           0x080128
+#define ALPHA_COLOR_LOOKUP_89_9_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_89_9_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_89_9_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_89_8_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_89_8_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_89_8_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_AB                           0x08012C
+#define ALPHA_COLOR_LOOKUP_AB_B_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_AB_B_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_AB_B_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_AB_A_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_AB_A_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_AB_A_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_CD                           0x080130
+#define ALPHA_COLOR_LOOKUP_CD_D_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_CD_D_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_CD_D_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_CD_C_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_CD_C_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_CD_C_BLUE                    4:0
+
+#define ALPHA_COLOR_LOOKUP_EF                           0x080134
+#define ALPHA_COLOR_LOOKUP_EF_F_RED                     31:27
+#define ALPHA_COLOR_LOOKUP_EF_F_GREEN                   26:21
+#define ALPHA_COLOR_LOOKUP_EF_F_BLUE                    20:16
+#define ALPHA_COLOR_LOOKUP_EF_E_RED                     15:11
+#define ALPHA_COLOR_LOOKUP_EF_E_GREEN                   10:5
+#define ALPHA_COLOR_LOOKUP_EF_E_BLUE                    4:0
+
+// CRT Graphics Control
+
+#define CRT_DISPLAY_CTRL                                0x080200
+#define CRT_DISPLAY_CTRL_FIFO                           17:16
+#define CRT_DISPLAY_CTRL_FIFO_1                         0
+#define CRT_DISPLAY_CTRL_FIFO_3                         1
+#define CRT_DISPLAY_CTRL_FIFO_7                         2
+#define CRT_DISPLAY_CTRL_FIFO_11                        3
+#define CRT_DISPLAY_CTRL_TV_PHASE                       15:15
+#define CRT_DISPLAY_CTRL_TV_PHASE_ACTIVE_HIGH           0
+#define CRT_DISPLAY_CTRL_TV_PHASE_ACTIVE_LOW            1
+#define CRT_DISPLAY_CTRL_CLOCK_PHASE                    14:14
+#define CRT_DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_HIGH        0
+#define CRT_DISPLAY_CTRL_CLOCK_PHASE_ACTIVE_LOW         1
+#define CRT_DISPLAY_CTRL_VSYNC_PHASE                    13:13
+#define CRT_DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_HIGH        0
+#define CRT_DISPLAY_CTRL_VSYNC_PHASE_ACTIVE_LOW         1
+#define CRT_DISPLAY_CTRL_HSYNC_PHASE                    12:12
+#define CRT_DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_HIGH        0
+#define CRT_DISPLAY_CTRL_HSYNC_PHASE_ACTIVE_LOW         1
+#define CRT_DISPLAY_CTRL_BLANK                          10:10
+#define CRT_DISPLAY_CTRL_BLANK_OFF                      0
+#define CRT_DISPLAY_CTRL_BLANK_ON                       1
+#define CRT_DISPLAY_CTRL_SELECT                         9:9
+#define CRT_DISPLAY_CTRL_SELECT_PANEL                   0
+#define CRT_DISPLAY_CTRL_SELECT_CRT                     1
+#define CRT_DISPLAY_CTRL_TIMING                         8:8
+#define CRT_DISPLAY_CTRL_TIMING_DISABLE                 0
+#define CRT_DISPLAY_CTRL_TIMING_ENABLE                  1
+#define CRT_DISPLAY_CTRL_PIXEL                          7:4
+#define CRT_DISPLAY_CTRL_GAMMA                          3:3
+#define CRT_DISPLAY_CTRL_GAMMA_DISABLE                  0
+#define CRT_DISPLAY_CTRL_GAMMA_ENABLE                   1
+#define CRT_DISPLAY_CTRL_PLANE                          2:2
+#define CRT_DISPLAY_CTRL_PLANE_DISABLE                  0
+#define CRT_DISPLAY_CTRL_PLANE_ENABLE                   1
+#define CRT_DISPLAY_CTRL_FORMAT                         1:0
+#define CRT_DISPLAY_CTRL_FORMAT_8                       0
+#define CRT_DISPLAY_CTRL_FORMAT_16                      1
+#define CRT_DISPLAY_CTRL_FORMAT_32                      2
+
+#define CRT_FB_ADDRESS                                  0x080204
+#define CRT_FB_ADDRESS_STATUS                           31:31
+#define CRT_FB_ADDRESS_STATUS_CURRENT                   0
+#define CRT_FB_ADDRESS_STATUS_PENDING                   1
+#define CRT_FB_ADDRESS_EXT                              27:27
+#define CRT_FB_ADDRESS_EXT_LOCAL                        0
+#define CRT_FB_ADDRESS_EXT_EXTERNAL                     1
+#define CRT_FB_ADDRESS_CS                               26:26
+#define CRT_FB_ADDRESS_CS_0                             0
+#define CRT_FB_ADDRESS_CS_1                             1
+#define CRT_FB_ADDRESS_ADDRESS                          25:0
+
+#define CRT_FB_WIDTH                                    0x080208
+#define CRT_FB_WIDTH_WIDTH                              29:16
+#define CRT_FB_WIDTH_OFFSET                             13:0
+
+#define CRT_HORIZONTAL_TOTAL                            0x08020C
+#define CRT_HORIZONTAL_TOTAL_TOTAL                      27:16
+#define CRT_HORIZONTAL_TOTAL_DISPLAY_END                11:0
+
+#define CRT_HORIZONTAL_SYNC                             0x080210
+#define CRT_HORIZONTAL_SYNC_WIDTH                       23:16
+#define CRT_HORIZONTAL_SYNC_START                       11:0
+
+#define CRT_VERTICAL_TOTAL                              0x080214
+#define CRT_VERTICAL_TOTAL_TOTAL                        26:16
+#define CRT_VERTICAL_TOTAL_DISPLAY_END                  10:0
+
+#define CRT_VERTICAL_SYNC                               0x080218
+#define CRT_VERTICAL_SYNC_HEIGHT                        21:16
+#define CRT_VERTICAL_SYNC_START                         10:0
+
+#define CRT_SIGNATURE_ANALYZER                          0x08021C
+#define CRT_SIGNATURE_ANALYZER_STATUS                   31:16
+#define CRT_SIGNATURE_ANALYZER_ENABLE                   3:3
+#define CRT_SIGNATURE_ANALYZER_ENABLE_DISABLE           0
+#define CRT_SIGNATURE_ANALYZER_ENABLE_ENABLE            1
+#define CRT_SIGNATURE_ANALYZER_RESET                    2:2
+#define CRT_SIGNATURE_ANALYZER_RESET_NORMAL             0
+#define CRT_SIGNATURE_ANALYZER_RESET_RESET              1
+#define CRT_SIGNATURE_ANALYZER_SOURCE                   1:0
+#define CRT_SIGNATURE_ANALYZER_SOURCE_RED               0
+#define CRT_SIGNATURE_ANALYZER_SOURCE_GREEN             1
+#define CRT_SIGNATURE_ANALYZER_SOURCE_BLUE              2
+
+#define CRT_CURRENT_LINE                                0x080220
+#define CRT_CURRENT_LINE_LINE                           10:0
+
+#define CRT_MONITOR_DETECT                              0x080224
+#define CRT_MONITOR_DETECT_ENABLE                       24:24
+#define CRT_MONITOR_DETECT_ENABLE_DISABLE               0
+#define CRT_MONITOR_DETECT_ENABLE_ENABLE                1
+#define CRT_MONITOR_DETECT_RED                          23:16
+#define CRT_MONITOR_DETECT_GREEN                        15:8
+#define CRT_MONITOR_DETECT_BLUE                         7:0
+
+// CRT Cursor Control
+
+#define CRT_HWC_ADDRESS                                 0x080230
+#define CRT_HWC_ADDRESS_ENABLE                          31:31
+#define CRT_HWC_ADDRESS_ENABLE_DISABLE                  0
+#define CRT_HWC_ADDRESS_ENABLE_ENABLE                   1
+#define CRT_HWC_ADDRESS_EXT                             27:27
+#define CRT_HWC_ADDRESS_EXT_LOCAL                       0
+#define CRT_HWC_ADDRESS_EXT_EXTERNAL                    1
+#define CRT_HWC_ADDRESS_CS                              26:26
+#define CRT_HWC_ADDRESS_CS_0                            0
+#define CRT_HWC_ADDRESS_CS_1                            1
+#define CRT_HWC_ADDRESS_ADDRESS                         25:0
+
+#define CRT_HWC_LOCATION                                0x080234
+#define CRT_HWC_LOCATION_TOP                            27:27
+#define CRT_HWC_LOCATION_TOP_INSIDE                     0
+#define CRT_HWC_LOCATION_TOP_OUTSIDE                    1
+#define CRT_HWC_LOCATION_Y                              26:16
+#define CRT_HWC_LOCATION_LEFT                           11:11
+#define CRT_HWC_LOCATION_LEFT_INSIDE                    0
+#define CRT_HWC_LOCATION_LEFT_OUTSIDE                   1
+#define CRT_HWC_LOCATION_X                              10:0
+
+#define CRT_HWC_COLOR_12                                0x080238
+#define CRT_HWC_COLOR_12_2_RGB565                       31:16
+#define CRT_HWC_COLOR_12_1_RGB565                       15:0
+
+#define CRT_HWC_COLOR_3                                 0x08023C
+#define CRT_HWC_COLOR_3_RGB565                          15:0
+
+// Old Definitions +++
+#define CRT_HWC_COLOR_01                                0x080238
+#define CRT_HWC_COLOR_01_1_RED                          31:27
+#define CRT_HWC_COLOR_01_1_GREEN                        26:21
+#define CRT_HWC_COLOR_01_1_BLUE                         20:16
+#define CRT_HWC_COLOR_01_0_RED                          15:11
+#define CRT_HWC_COLOR_01_0_GREEN                        10:5
+#define CRT_HWC_COLOR_01_0_BLUE                         4:0
+
+#define CRT_HWC_COLOR_2                                 0x08023C
+#define CRT_HWC_COLOR_2_RED                             15:11
+#define CRT_HWC_COLOR_2_GREEN                           10:5
+#define CRT_HWC_COLOR_2_BLUE                            4:0
+// Old Definitions ---
+
+// Palette RAM
+
+#define PANEL_PALETTE_RAM                               0x080400
+#define VIDEO_PALETTE_RAM                               0x080800
+#define CRT_PALETTE_RAM                                 0x080C00
+
+// Power constants to use with setDPMS function.
+typedef enum _DPMS_t
+{
+	DPMS_ON,
+	DPMS_STANDBY,
+	DPMS_SUSPEND,
+	DPMS_OFF
+}
+DPMS_t;
+
+////////////////////////////////////////////////////////////////////////////////
+//                                                                            //
+// D I S P L A Y   C O N T R O L L E R                                        //
+//                                                                            //
+////////////////////////////////////////////////////////////////////////////////
+
+// Display type constants to use with setMode function and others.
+typedef enum _display_t
+{
+	PANEL = 0,
+	CRT = 1,
+}
+display_t;
+
+// Type of LCD display
+typedef enum _lcd_display_t
+{
+    LCD_TFT = 0,
+    LCD_STN_8 = 2,
+	LCD_STN_12 = 3
+}
+lcd_display_t;
+
+// Polarity constants.
+typedef enum _polarity_t
+{
+	POSITIVE,
+	NEGATIVE,
+}
+polarity_t;
+
+
+// Format of mode table record.
+typedef struct _mode_table_t
+{
+	// Horizontal timing.
+	int horizontal_total;
+	int horizontal_display_end;
+	int horizontal_sync_start;
+	int horizontal_sync_width;
+	polarity_t horizontal_sync_polarity;
+
+	// Vertical timing.
+	int vertical_total;
+	int vertical_display_end;
+	int vertical_sync_start;
+	int vertical_sync_height;
+	polarity_t vertical_sync_polarity;
+
+	// Refresh timing.
+	long pixel_clock;
+	long horizontal_frequency;
+	long vertical_frequency;
+/*
+    //Programe PLL3 
+	int M;
+	int N;
+	int bit15;
+	int bit31;
+*/
+}
+mode_table_t, *pmode_table_t;
+
+// Clock value structure.
+typedef struct clock_select_t
+{
+	long mclk;
+	long test_clock;
+	int divider;
+	int shift;
+
+	long multipleM;
+	int dividerN;
+	short divby2;
+}
+clock_select_t, *pclock_select_t;
+
+// Registers necessary to set mode.
+typedef struct _reg_table_t
+{
+	unsigned long clock;
+	unsigned long control;
+	unsigned long fb_width;
+	unsigned long horizontal_total;
+	unsigned long horizontal_sync;
+	unsigned long vertical_total;
+	unsigned long vertical_sync;
+	unsigned long width;
+	unsigned long height;
+	display_t display;
+}
+reg_table_t, *preg_table_t;
+
+// Panel On/Off constants to use with panelPowerSequence.
+typedef enum _panel_state_t
+{
+	PANEL_OFF,
+	PANEL_ON,
+}
+panel_state_t;
+
+// Structure used to initialize Panel hardware module
+typedef struct
+{
+    unsigned long mask;       // Holds flags indicating which register bitfields to init
+	unsigned long dp;         // TFT dithering pattern
+	unsigned long tft;        // TFT panel interface
+	unsigned long de;         // Enable/disable TFT dithering
+	unsigned long lcd;        // LCD type
+	unsigned long fifo_level; // FIFO request level
+	unsigned long cp;         // Clock phase select
+	unsigned long format;     // Panel graphics plane format
+} init_panel, *pinit_panel;
+
+// Structure used to initialize Panel cursor hardware module
+typedef struct
+{
+    unsigned long mask;       // Holds flags indicating which register bitfields to init
+} init_panel_hwc, *pinit_panel_hwc;
+
+// Structure used to initialize Alpha hardware module
+typedef struct
+{
+    unsigned long mask;       // Holds flags indicating which register bitfields to init
+	unsigned long fifo_level; // FIFO request level
+	unsigned long format;     // Alpha plane format
+} init_alpha, *pinit_alpha;
+
+// Structure used to initialize CRT hardware module
+typedef struct
+{
+    unsigned long mask;       // Holds flags indicating which register bitfields to init
+	unsigned long fifo_level; // FIFO request level
+	unsigned long tvp;        // TV clock phase select
+	unsigned long cp;         // CRT clock phase select
+	unsigned long blank;      // CRT data blanking
+	unsigned long format;     // CRT graphics plane format
+} init_crt, *pinit_crt;
+
+// Structure used to initialize CRT cursor hardware module
+typedef struct
+{
+    unsigned long mask;       // Holds flags indicating which register bitfields to init
+} init_crt_hwc, *pinit_crt_hwc;
+
+// Init flags and values used in init_panel, init_alpha, and init_crt structures
+#define DISP_FIFO_LEVEL                    0x00000001    // FIFO request level
+#define DISP_FIFO_LEVEL_1                  0x00000000
+#define DISP_FIFO_LEVEL_3                  0x00010000
+#define DISP_FIFO_LEVEL_7                  0x00020000
+#define DISP_FIFO_LEVEL_11                 0x00030000
+
+// Init flags and values used in init_panel structure
+#define DISP_PANEL_DP                      0x00000100    // TFT dithering pattern
+#define DISP_PANEL_DP_4GRAY                0x00000000
+#define DISP_PANEL_DP_8GRAY                0x00800000
+
+#define DISP_PANEL_TFT                     0x00000200    // TFT panel interface
+#define DISP_PANEL_TFT_24                  0x00000000
+#define DISP_PANEL_TFT_9                   0x00200000
+#define DISP_PANEL_TFT_12                  0x00400000
+
+#define DISP_PANEL_DE                      0x00000400    // Enable/disable TFT dithering
+#define DISP_PANEL_DE_DISABLE              0x00000000
+#define DISP_PANEL_DE_ENABLE               0x00100000
+
+#define DISP_PANEL_LCD                     0x00000800    // LCD type
+#define DISP_PANEL_LCD_TFT                 0x00000000
+#define DISP_PANEL_LCD_STN8                0x00080000
+#define DISP_PANEL_LCD_STN12               0x000C0000
+
+#define DISP_PANEL_CP                      0x00001000    // Clock phase select
+#define DISP_PANEL_CP_HIGH                 0x00000000
+#define DISP_PANEL_CP_LOW                  0x00004000
+
+#define DISP_PANEL_FORMAT                  0x00002000    // Panel graphics plane format
+#define DISP_PANEL_FORMAT_8                0x00000000
+#define DISP_PANEL_FORMAT_16               0x00000001
+#define DISP_PANEL_FORMAT_32               0x00000002
+
+// Init flags and values used in init_alpha structure
+#define DISP_ALPHA_FORMAT                  0x00000100    // Alpha plane format
+#define DISP_ALPHA_FORMAT_RGB565           0x00000001
+#define DISP_ALPHA_FORMAT_ALPHA44          0x00000002
+#define DISP_ALPHA_FORMAT_ALPHA4444        0x00000003
+
+// Init flags and values used in init_crt structure
+#define DISP_CRT_TVP                       0x00000100    // TV clock phase select
+#define DISP_CRT_TVP_HIGH                  0x00000000
+#define DISP_CRT_TVP_LOW                   0x00008000
+
+#define DISP_CRT_CP                        0x00000200    // CRT clock phase select
+#define DISP_CRT_CP_HIGH                   0x00000000
+#define DISP_CRT_CP_LOW                    0x00004000
+
+#define DISP_CRT_BLANK                     0x00000400    // CRT data blanking
+#define DISP_CRT_BLANK_OFF                 0x00000000
+#define DISP_CRT_BLANK_ON                  0x00000400
+
+#define DISP_CRT_FORMAT                    0x00000800    // CRT graphics plane format
+#define DISP_CRT_FORMAT_8                  0x00000000
+#define DISP_CRT_FORMAT_16                 0x00000001
+#define DISP_CRT_FORMAT_32                 0x00000002
+
+#define DISP_MODE_8_BPP			           0		     // 8 bits per pixel i8RGB
+#define DISP_MODE_16_BPP		           1		     // 16 bits per pixel RGB565
+#define DISP_MODE_32_BPP		           2		     // 32 bits per pixel RGB888
+#define DISP_MODE_YUV			           3		     // 16 bits per pixel YUV422
+#define DISP_MODE_ALPHA_8		           4		     // 8 bits per pixel a4i4RGB
+#define DISP_MODE_ALPHA_16		           5		     // 16 bits per pixel a4RGB444
+
+#define DISP_PAN_LEFT			           0		     // Pan left
+#define DISP_PAN_RIGHT			           1		     // Pan right
+#define DISP_PAN_UP				           2		     // Pan upwards
+#define DISP_PAN_DOWN		               3		     // Pan downwards
+
+#define DISP_DPMS_QUERY			           -1		     // Query DPMS value
+#define DISP_DPMS_ON			           0		     // DPMS on
+#define DISP_DPMS_STANDBY	               1		     // DPMS standby
+#define DISP_DPMS_SUSPEND		           2		     // DPMS suspend
+#define DISP_DPMS_OFF			           3		     // DPMS off
+
+#define DISP_DELAY_DEFAULT		           0		     // Default delay
+
+#define DISP_HVTOTAL_UNKNOWN               -1            // Used in panelSetTiming, crtSetTiming if
+                                                         // nHTotal, nVTotal not specified by user
+#define DISP_HVTOTAL_SCALEFACTOR           1.25          // Used in panelSetTiming, crtSetTiming if
+                                                         // nHTotal, nVTotal not specified by user
+
+#define VGX_SIGNAL_PANEL_VSYNC	           100		     // Panel VSYNC
+#define VGX_SIGNAL_PANEL_PAN               101		     // Panel auto panning complete
+#define VGX_SIGNAL_CRT_VSYNC               102		     // CRT VSYNC
+
+#define VSYNCTIMEOUT                       10000
+
+#define ALPHA_MODE_PER_PIXEL               0             // Use per-pixel alpha values
+#define ALPHA_MODE_ALPHA                   1             // Use alpha value specified in Alpha bitfield
+#define ALPHA_COLOR_LUT_SIZE               16            // Number of colors in alpha/video alpha palette
+
+#define HWC_ON_SCREEN                      0             // Cursor is within screen top/left boundary
+#define HWC_OFF_SCREEN                     1             // Cursor is outside screen top/left boundary
+#define HWC_NUM_COLORS                     3             // Number of cursor colors
+
diff -Nur linux-2.6.29.1/drivers/video/smi/sm7xxhw.h linux-2.6.29.1-lemote/drivers/video/smi/sm7xxhw.h
--- linux-2.6.29.1/drivers/video/smi/sm7xxhw.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/video/smi/sm7xxhw.h	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,104 @@
+/*
+ *  linux/drivers/video/sm7xxhw.h -- Silicon Motion SM7xx frame buffer device
+ *
+ *      Copyright (C) 2006 Silicon Motion, Inc.
+ *      Ge Wang, gewang@siliconmotion.com
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+
+#define SM712_VIDEOMEMORYSIZE    0x00400000  /*Assume SM712 graphics chip has 4MB VRAM */
+#define SM722_VIDEOMEMORYSIZE    0x00800000  /*Assume SM722 graphics chip has 8MB VRAM */
+
+#define dac_reg	(0x3c8)
+#define dac_val	(0x3c9)
+
+#define smtc_mmiowb(dat,reg)	writeb(dat, smtc_RegBaseAddress + reg)
+#define smtc_mmioww(dat,reg)	writew(dat, smtc_RegBaseAddress + reg)
+#define smtc_mmiowl(dat,reg)	writel(dat, smtc_RegBaseAddress + reg)
+
+#define smtc_mmiorb(reg)	        readb(smtc_RegBaseAddress + reg)
+#define smtc_mmiorw(reg)	        readw(smtc_RegBaseAddress + reg)
+#define smtc_mmiorl(reg)	        readl(smtc_RegBaseAddress + reg)
+
+#define SIZE_SR00_SR04      (0x04 - 0x00 + 1)
+#define SIZE_SR10_SR24      (0x24 - 0x10 + 1)
+#define SIZE_SR30_SR75      (0x75 - 0x30 + 1)
+#define SIZE_SR80_SR93      (0x93 - 0x80 + 1)
+#define SIZE_SRA0_SRAF      (0xAF - 0xA0 + 1)
+#define SIZE_GR00_GR08      (0x08 - 0x00 + 1)
+#define SIZE_AR00_AR14      (0x14 - 0x00 + 1)
+#define SIZE_CR00_CR18      (0x18 - 0x00 + 1)
+#define SIZE_CR30_CR4D      (0x4D - 0x30 + 1)
+#define SIZE_CR90_CRA7      (0xA7 - 0x90 + 1)
+#define SIZE_VPR            (0x6C + 1)
+#define SIZE_DPR			(0x44 + 1)
+
+
+static inline void smtc_crtcw(int reg, int val)
+{
+        smtc_mmiowb(reg, 0x3d4);
+        smtc_mmiowb(val, 0x3d5);
+}
+
+static inline unsigned int smtc_crtcr(int reg)
+{
+        smtc_mmiowb(reg, 0x3d4);
+        return smtc_mmiorb(0x3d5);
+}
+
+static inline void smtc_grphw(int reg, int val)
+{
+        smtc_mmiowb(reg, 0x3ce);
+        smtc_mmiowb(val, 0x3cf);
+}
+
+static inline unsigned int smtc_grphr(int reg)
+{
+        smtc_mmiowb(reg, 0x3ce);
+        return smtc_mmiorb(0x3cf);
+}
+
+static inline void smtc_attrw(int reg, int val)
+{
+        smtc_mmiorb(0x3da);
+        smtc_mmiowb(reg, 0x3c0);
+        smtc_mmiorb(0x3c1);
+        smtc_mmiowb(val, 0x3c0);
+}
+
+static inline void smtc_seqw(int reg, int val)
+{
+        smtc_mmiowb(reg, 0x3c4);
+        smtc_mmiowb(val, 0x3c5);
+}
+
+static inline unsigned int smtc_seqr(int reg)
+{
+        smtc_mmiowb(reg, 0x3c4);
+        return smtc_mmiorb(0x3c5);
+}
+
+// The next structure holds all information relevant for a specific video mode.
+struct ModeInit
+{
+	int			  mmSizeX;
+	int			  mmSizeY;
+	int			  bpp;
+	int			  hz;
+	unsigned char Init_MISC;
+	unsigned char Init_SR00_SR04[SIZE_SR00_SR04];
+	unsigned char Init_SR10_SR24[SIZE_SR10_SR24];
+	unsigned char Init_SR30_SR75[SIZE_SR30_SR75];
+	unsigned char Init_SR80_SR93[SIZE_SR80_SR93];
+	unsigned char Init_SRA0_SRAF[SIZE_SRA0_SRAF];
+	unsigned char Init_GR00_GR08[SIZE_GR00_GR08];
+	unsigned char Init_AR00_AR14[SIZE_AR00_AR14];
+	unsigned char Init_CR00_CR18[SIZE_CR00_CR18];
+	unsigned char Init_CR30_CR4D[SIZE_CR30_CR4D];
+	unsigned char Init_CR90_CRA7[SIZE_CR90_CRA7];
+};
+
diff -Nur linux-2.6.29.1/drivers/video/smi/smtc2d.c linux-2.6.29.1-lemote/drivers/video/smi/smtc2d.c
--- linux-2.6.29.1/drivers/video/smi/smtc2d.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/video/smi/smtc2d.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,1371 @@
+/*
+ *  linux/drivers/video/smtc2d.c -- Silicon Motion SM501 and SM7xx 2D drawing engine functions.
+ *
+ *      Copyright (C) 2006 Silicon Motion Technology Corp.
+ *      Boyod boyod.yang@siliconmotion.com.cn
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+*
+*
+* Version 0.10.26192.21.01
+    - Add PowerPC support
+	- Add 2D support for Lynx
+    - Verified on 2.6.19.2                          Boyod.yang  <boyod.yang@siliconmotion.com.cn>
+
+*/
+
+unsigned char smtc_de_busy = 0;
+void SMTC_write2Dreg(unsigned long nOffset, unsigned long nData)
+{
+    writel(nData, smtc_2DBaseAddress+nOffset) ;
+}
+
+unsigned long SMTC_read2Dreg(unsigned long nOffset)
+{
+    readl(smtc_2DBaseAddress+nOffset) ;
+}
+
+
+void SMTC_write2Ddataport(unsigned long nOffset, unsigned long nData)
+{
+    writel(nData, smtc_2Ddataport+nOffset);
+}
+
+/**********************************************************************
+ *
+ * deInit
+ *
+ * Purpose
+ *    Drawing engine initialization.
+ *
+ **********************************************************************/
+void deInit(unsigned int nModeWidth, unsigned int nModeHeight, unsigned int bpp)
+{
+
+	// Get current power configuration.
+	unsigned char gate, clock;
+	clock = smtc_seqr(0x21);
+	// Enable 2D Drawing Engine
+	smtc_seqw(0x21,clock& 0xF8);
+	
+	SMTC_write2Dreg(DE_CLIP_TL,
+		FIELD_VALUE(0, DE_CLIP_TL, TOP,     0)       |
+		FIELD_SET  (0, DE_CLIP_TL, STATUS,  DISABLE) |
+		FIELD_SET  (0, DE_CLIP_TL, INHIBIT, OUTSIDE) |
+		FIELD_VALUE(0, DE_CLIP_TL, LEFT,    0));
+
+	if (bpp>=24){
+	    SMTC_write2Dreg(DE_PITCH,
+			FIELD_VALUE(0, DE_PITCH, DESTINATION, nModeWidth*3) |
+			FIELD_VALUE(0, DE_PITCH, SOURCE,      nModeWidth*3));
+	}else{
+	    SMTC_write2Dreg(DE_PITCH,
+			FIELD_VALUE(0, DE_PITCH, DESTINATION, nModeWidth) |
+			FIELD_VALUE(0, DE_PITCH, SOURCE,      nModeWidth));
+	}
+	
+    SMTC_write2Dreg(DE_WINDOW_WIDTH,
+		FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, nModeWidth) |
+		FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      nModeWidth));
+
+    switch (bpp)
+    {
+    case 8:
+        SMTC_write2Dreg(DE_STRETCH_FORMAT,
+            FIELD_SET  (0, DE_STRETCH_FORMAT, PATTERN_XY,    NORMAL) |
+            FIELD_VALUE(0, DE_STRETCH_FORMAT, PATTERN_Y,     0)      |
+            FIELD_VALUE(0, DE_STRETCH_FORMAT, PATTERN_X,     0)      |
+            FIELD_SET  (0, DE_STRETCH_FORMAT, PIXEL_FORMAT,  8)      |
+            FIELD_SET  (0, DE_STRETCH_FORMAT, ADDRESSING,	 XY)     |
+            FIELD_VALUE(0, DE_STRETCH_FORMAT, SOURCE_HEIGHT, 3));
+        break;
+    case 24:
+        SMTC_write2Dreg(DE_STRETCH_FORMAT,
+            FIELD_SET  (0, DE_STRETCH_FORMAT, PATTERN_XY,    NORMAL) |
+            FIELD_VALUE(0, DE_STRETCH_FORMAT, PATTERN_Y,     0)      |
+            FIELD_VALUE(0, DE_STRETCH_FORMAT, PATTERN_X,     0)      |
+            FIELD_SET  (0, DE_STRETCH_FORMAT, PIXEL_FORMAT,  24)     |
+            FIELD_SET  (0, DE_STRETCH_FORMAT, ADDRESSING,	 XY)     |
+            FIELD_VALUE(0, DE_STRETCH_FORMAT, SOURCE_HEIGHT, 3));
+        break;
+    case 16:
+    default:
+        SMTC_write2Dreg(DE_STRETCH_FORMAT,
+            FIELD_SET  (0, DE_STRETCH_FORMAT, PATTERN_XY,    NORMAL) |
+            FIELD_VALUE(0, DE_STRETCH_FORMAT, PATTERN_Y,     0)      |
+            FIELD_VALUE(0, DE_STRETCH_FORMAT, PATTERN_X,     0)      |
+            FIELD_SET  (0, DE_STRETCH_FORMAT, PIXEL_FORMAT,  16)     |
+            FIELD_SET  (0, DE_STRETCH_FORMAT, ADDRESSING,	 XY)     |
+            FIELD_VALUE(0, DE_STRETCH_FORMAT, SOURCE_HEIGHT, 3));
+        break;
+    }
+
+	SMTC_write2Dreg(DE_MASKS,
+		FIELD_VALUE(0, DE_MASKS, BYTE_MASK, 0xFFFF) |
+		FIELD_VALUE(0, DE_MASKS, BIT_MASK,  0xFFFF));
+	SMTC_write2Dreg(DE_COLOR_COMPARE_MASK,
+		FIELD_VALUE(0, DE_COLOR_COMPARE_MASK, MASKS, 0xFFFFFF));
+	SMTC_write2Dreg(DE_COLOR_COMPARE,
+		FIELD_VALUE(0, DE_COLOR_COMPARE, COLOR, 0xFFFFFF));
+}
+
+
+/**********************************************************************
+ *
+ * deSetClipRectangle
+ *
+ * Purpose
+ *    Set drawing engine clip rectangle.
+ *
+ * Remarks
+ *       Caller need to pass in valid rectangle parameter in device coordinate.
+ **********************************************************************/
+void deSetClipRectangle(int left, int top, int right, int bottom)
+{
+    /* Top left of clipping rectangle cannot be negative */
+    if (top < 0)
+    {
+        top = 0;
+    }
+    
+    if (left < 0)
+    {
+        left = 0;
+    }
+    
+    SMTC_write2Dreg(DE_CLIP_TL,
+        FIELD_VALUE(0, DE_CLIP_TL, TOP,     top) |
+        FIELD_SET  (0, DE_CLIP_TL, STATUS,  ENABLE)         |
+        FIELD_SET  (0, DE_CLIP_TL, INHIBIT, OUTSIDE)        |
+        FIELD_VALUE(0, DE_CLIP_TL, LEFT,    left));
+    SMTC_write2Dreg(DE_CLIP_BR,
+        FIELD_VALUE(0, DE_CLIP_BR, BOTTOM, bottom) |
+        FIELD_VALUE(0, DE_CLIP_BR, RIGHT,  right));
+}
+
+
+void deVerticalLine(unsigned long dst_base,
+                    unsigned long dst_pitch, 
+                    unsigned long nX, 
+                    unsigned long nY, 
+                    unsigned long dst_height, 
+                    unsigned long nColor)
+{
+    deWaitForNotBusy();
+
+    SMTC_write2Dreg(DE_WINDOW_DESTINATION_BASE, FIELD_VALUE(0, DE_WINDOW_DESTINATION_BASE, ADDRESS, dst_base));
+
+	SMTC_write2Dreg(DE_PITCH,
+		FIELD_VALUE(0, DE_PITCH, DESTINATION, dst_pitch) |
+		FIELD_VALUE(0, DE_PITCH, SOURCE,      dst_pitch));
+    
+	SMTC_write2Dreg(DE_WINDOW_WIDTH,
+		FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dst_pitch) |
+		FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dst_pitch));
+
+    SMTC_write2Dreg(DE_FOREGROUND,
+        FIELD_VALUE(0, DE_FOREGROUND, COLOR, nColor));
+
+    SMTC_write2Dreg(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    nX)      |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    nY));
+
+    SMTC_write2Dreg(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    1) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, dst_height));
+
+    SMTC_write2Dreg(DE_CONTROL,
+        FIELD_SET  (0, DE_CONTROL, STATUS,     START)         |
+        FIELD_SET  (0, DE_CONTROL, DIRECTION,  LEFT_TO_RIGHT) |
+        FIELD_SET  (0, DE_CONTROL, MAJOR,      Y)             |
+        FIELD_SET  (0, DE_CONTROL, STEP_X,     NEGATIVE)      |
+        FIELD_SET  (0, DE_CONTROL, STEP_Y,     POSITIVE)      |
+        FIELD_SET  (0, DE_CONTROL, LAST_PIXEL, OFF)           |
+        FIELD_SET  (0, DE_CONTROL, COMMAND,    SHORT_STROKE)  |
+        FIELD_SET  (0, DE_CONTROL, ROP_SELECT, ROP2)          |
+        FIELD_VALUE(0, DE_CONTROL, ROP,        0x0C));
+    
+    smtc_de_busy = 1;
+}
+
+void deHorizontalLine(unsigned long dst_base,
+                      unsigned long dst_pitch, 
+                      unsigned long nX, 
+                      unsigned long nY, 
+                      unsigned long dst_width, 
+                      unsigned long nColor)
+{
+    deWaitForNotBusy();
+    
+    SMTC_write2Dreg(DE_WINDOW_DESTINATION_BASE, FIELD_VALUE(0, DE_WINDOW_DESTINATION_BASE, ADDRESS, dst_base));
+    
+    SMTC_write2Dreg(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dst_pitch) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      dst_pitch));
+    
+    SMTC_write2Dreg(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dst_pitch) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dst_pitch));
+    SMTC_write2Dreg(DE_FOREGROUND,
+        FIELD_VALUE(0, DE_FOREGROUND, COLOR, nColor));
+    SMTC_write2Dreg(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    nX)      |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    nY));
+    SMTC_write2Dreg(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    dst_width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, 1));
+    SMTC_write2Dreg(DE_CONTROL,
+        FIELD_SET  (0, DE_CONTROL, STATUS,     START)         |
+        FIELD_SET  (0, DE_CONTROL, DIRECTION,  RIGHT_TO_LEFT) |
+        FIELD_SET  (0, DE_CONTROL, MAJOR,      X)             |
+        FIELD_SET  (0, DE_CONTROL, STEP_X,     POSITIVE)      |
+        FIELD_SET  (0, DE_CONTROL, STEP_Y,     NEGATIVE)      |
+        FIELD_SET  (0, DE_CONTROL, LAST_PIXEL, OFF)           |
+        FIELD_SET  (0, DE_CONTROL, COMMAND,    SHORT_STROKE)  |
+        FIELD_SET  (0, DE_CONTROL, ROP_SELECT, ROP2)          |
+        FIELD_VALUE(0, DE_CONTROL, ROP,        0x0C));
+
+    smtc_de_busy = 1;
+}
+
+
+void deLine(unsigned long dst_base,
+            unsigned long dst_pitch,  
+            unsigned long nX1, 
+            unsigned long nY1, 
+            unsigned long nX2, 
+            unsigned long nY2, 
+            unsigned long nColor)
+{
+    unsigned long nCommand =
+        FIELD_SET  (0, DE_CONTROL, STATUS,     START)         |
+        FIELD_SET  (0, DE_CONTROL, DIRECTION,  LEFT_TO_RIGHT) |
+        FIELD_SET  (0, DE_CONTROL, MAJOR,      X)             |
+        FIELD_SET  (0, DE_CONTROL, STEP_X,     POSITIVE)      |
+        FIELD_SET  (0, DE_CONTROL, STEP_Y,     POSITIVE)      |
+        FIELD_SET  (0, DE_CONTROL, LAST_PIXEL, OFF)           |
+        FIELD_SET  (0, DE_CONTROL, ROP_SELECT, ROP2)          |
+        FIELD_VALUE(0, DE_CONTROL, ROP,        0x0C);
+    unsigned long DeltaX;
+    unsigned long DeltaY;
+    
+    /* Calculate delta X */
+    if (nX1 <= nX2)
+    {
+        DeltaX = nX2 - nX1;
+    }
+    else
+    {
+        DeltaX = nX1 - nX2;
+        nCommand = FIELD_SET(nCommand, DE_CONTROL, STEP_X, NEGATIVE);
+    }
+    
+    /* Calculate delta Y */
+    if (nY1 <= nY2)
+    {
+        DeltaY = nY2 - nY1;
+    }
+    else
+    {
+        DeltaY = nY1 - nY2;
+        nCommand = FIELD_SET(nCommand, DE_CONTROL, STEP_Y, NEGATIVE);
+    }
+    
+    /* Determine the major axis */
+    if (DeltaX < DeltaY)
+    {
+        nCommand = FIELD_SET(nCommand, DE_CONTROL, MAJOR, Y);
+    }
+    
+    /* Vertical line? */
+    if (nX1 == nX2)
+        deVerticalLine(dst_base, dst_pitch, nX1, nY1, DeltaY, nColor);
+    
+    /* Horizontal line? */
+    else if (nY1 == nY2)
+        deHorizontalLine(dst_base, dst_pitch, nX1, nY1, DeltaX, nColor);
+    
+    /* Diagonal line? */
+    else if (DeltaX == DeltaY)
+    {
+        deWaitForNotBusy();
+        
+        SMTC_write2Dreg(DE_WINDOW_DESTINATION_BASE, FIELD_VALUE(0, DE_WINDOW_DESTINATION_BASE, ADDRESS, dst_base));
+        
+        SMTC_write2Dreg(DE_PITCH,
+            FIELD_VALUE(0, DE_PITCH, DESTINATION, dst_pitch) |
+            FIELD_VALUE(0, DE_PITCH, SOURCE,      dst_pitch));
+        
+        SMTC_write2Dreg(DE_WINDOW_WIDTH,
+            FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dst_pitch) |
+            FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dst_pitch));
+        
+        SMTC_write2Dreg(DE_FOREGROUND,
+            FIELD_VALUE(0, DE_FOREGROUND, COLOR, nColor));
+        
+        SMTC_write2Dreg(DE_DESTINATION,
+            FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_DESTINATION, X,    1)       |
+            FIELD_VALUE(0, DE_DESTINATION, Y,    nY1));
+        
+        SMTC_write2Dreg(DE_DIMENSION,
+            FIELD_VALUE(0, DE_DIMENSION, X,    1) |
+            FIELD_VALUE(0, DE_DIMENSION, Y_ET, DeltaX));
+        
+        SMTC_write2Dreg(DE_CONTROL,
+            FIELD_SET(nCommand, DE_CONTROL, COMMAND, SHORT_STROKE));
+    }
+    
+    /* Generic line */
+    else
+    {
+        unsigned int k1, k2, et, w;
+        if (DeltaX < DeltaY)
+        {
+            k1 = 2 * DeltaX;
+            et = k1 - DeltaY;
+            k2 = et - DeltaY;
+            w  = DeltaY + 1;
+        } 
+        else 
+        {
+            k1 = 2 * DeltaY;
+            et = k1 - DeltaX;
+            k2 = et - DeltaX;
+            w  = DeltaX + 1;
+        }
+        
+        deWaitForNotBusy();
+        
+        SMTC_write2Dreg(DE_WINDOW_DESTINATION_BASE, FIELD_VALUE(0, DE_WINDOW_DESTINATION_BASE, ADDRESS, dst_base));
+        
+        SMTC_write2Dreg(DE_PITCH,
+            FIELD_VALUE(0, DE_PITCH, DESTINATION, dst_pitch) |
+            FIELD_VALUE(0, DE_PITCH, SOURCE,      dst_pitch));
+        
+        SMTC_write2Dreg(DE_WINDOW_WIDTH,
+            FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dst_pitch) |
+            FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dst_pitch));
+        
+        SMTC_write2Dreg(DE_FOREGROUND,
+            FIELD_VALUE(0, DE_FOREGROUND, COLOR, nColor));
+        
+        SMTC_write2Dreg(DE_SOURCE,
+            FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_SOURCE, X_K1, k1)      |
+            FIELD_VALUE(0, DE_SOURCE, Y_K2, k2));
+        
+        SMTC_write2Dreg(DE_DESTINATION,
+            FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_DESTINATION, X,    nX1)     |
+            FIELD_VALUE(0, DE_DESTINATION, Y,    nY1));
+        
+        SMTC_write2Dreg(DE_DIMENSION,
+            FIELD_VALUE(0, DE_DIMENSION, X,    w) |
+            FIELD_VALUE(0, DE_DIMENSION, Y_ET, et));
+        
+        SMTC_write2Dreg(DE_CONTROL,
+            FIELD_SET(nCommand, DE_CONTROL, COMMAND, LINE_DRAW));
+    }
+
+    smtc_de_busy = 1;
+}
+
+
+void deFillRect(unsigned long dst_base,
+                unsigned long dst_pitch,  
+                unsigned long dst_X, 
+                unsigned long dst_Y, 
+                unsigned long dst_width, 
+                unsigned long dst_height, 
+                unsigned long nColor)
+{
+    deWaitForNotBusy();
+
+    SMTC_write2Dreg(DE_WINDOW_DESTINATION_BASE, FIELD_VALUE(0, DE_WINDOW_DESTINATION_BASE, ADDRESS, dst_base));
+    
+    if (dst_pitch)
+    {
+        SMTC_write2Dreg(DE_PITCH,
+            FIELD_VALUE(0, DE_PITCH, DESTINATION, dst_pitch) |
+            FIELD_VALUE(0, DE_PITCH, SOURCE,      dst_pitch));
+        
+        SMTC_write2Dreg(DE_WINDOW_WIDTH,
+            FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dst_pitch) |
+            FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dst_pitch));
+    }
+
+    SMTC_write2Dreg(DE_FOREGROUND,
+        FIELD_VALUE(0, DE_FOREGROUND, COLOR, nColor));
+
+    SMTC_write2Dreg(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    dst_X)     |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    dst_Y));
+
+    SMTC_write2Dreg(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    dst_width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, dst_height));
+
+    SMTC_write2Dreg(DE_CONTROL,
+        FIELD_SET  (0, DE_CONTROL, STATUS,     START)          |
+        FIELD_SET  (0, DE_CONTROL, DIRECTION,  LEFT_TO_RIGHT)  |
+        FIELD_SET  (0, DE_CONTROL, LAST_PIXEL, OFF)            |
+        FIELD_SET  (0, DE_CONTROL, COMMAND,    RECTANGLE_FILL) |
+        FIELD_SET  (0, DE_CONTROL, ROP_SELECT, ROP2)           |
+        FIELD_VALUE(0, DE_CONTROL, ROP,        0x0C));
+
+    smtc_de_busy = 1;
+}
+
+
+/**********************************************************************
+ *
+ * deRotatePattern
+ *
+ * Purpose
+ *    Rotate the given pattern if necessary
+ *
+ * Parameters
+ *    [in]
+ *        pPattern  - Pointer to DE_SURFACE structure containing
+ *                    pattern attributes
+ *        patternX  - X position (0-7) of pattern origin
+ *        patternY  - Y position (0-7) of pattern origin
+ *
+ *    [out]
+ *        pattern_dstaddr - Pointer to pre-allocated buffer containing rotated pattern
+ *
+ *
+ **********************************************************************/
+void deRotatePattern(unsigned char* pattern_dstaddr,
+                     unsigned long pattern_src_addr,
+                     unsigned long pattern_BPP,
+                     unsigned long pattern_stride,
+                     int patternX,
+                     int patternY)
+{
+    unsigned int i;
+    unsigned long pattern_read_addr;
+    unsigned long pattern[PATTERN_WIDTH * PATTERN_HEIGHT];
+    unsigned int x, y;
+	unsigned char* pjPatByte;
+
+    if (pattern_dstaddr != NULL)
+    {
+        deWaitForNotBusy();
+        
+        /* Load pattern from local video memory into pattern array */
+        pattern_read_addr = pattern_src_addr;
+        
+        for (i = 0; i < (pattern_BPP * 2); i++)
+        {
+//            pattern[i] = memRead32(pattern_read_addr);       removed by boyod
+            pattern_read_addr += 4;
+        }
+        
+        if (patternX || patternY)
+        {
+            /* Rotate pattern */
+            pjPatByte = (unsigned char*)pattern;
+            
+            switch (pattern_BPP)
+            {
+            case 8:
+                {
+                    for (y = 0; y < 8; y++)
+                    {
+                        unsigned char* pjBuffer = pattern_dstaddr + ((patternY + y) & 7) * 8;
+                        for (x = 0; x < 8; x++)
+                        {
+                            pjBuffer[(patternX + x) & 7] = pjPatByte[x];
+                        }
+                        pjPatByte += pattern_stride;
+                    }
+                    break;
+                }
+                
+            case 16:
+                {
+                    for (y = 0; y < 8; y++)
+                    {
+                        unsigned short* pjBuffer = (unsigned short*) pattern_dstaddr + ((patternY + y) & 7) * 8;
+                        for (x = 0; x < 8; x++)
+                        {
+                            pjBuffer[(patternX + x) & 7] = ((unsigned short*) pjPatByte)[x];
+                        }
+                        pjPatByte += pattern_stride;
+                    }
+                    break;
+                }
+                
+            case 32:
+                {
+                    for (y = 0; y < 8; y++)
+                    {
+                        unsigned long* pjBuffer = (unsigned long*) pattern_dstaddr + ((patternY + y) & 7) * 8;
+                        for (x = 0; x < 8; x++)
+                        {
+                            pjBuffer[(patternX + x) & 7] = ((unsigned long*) pjPatByte)[x];
+                        }
+                        pjPatByte += pattern_stride;
+                    }
+                    break;
+                }
+            }
+        }
+        else
+        {
+            /* Don't rotate, just copy pattern into pattern_dstaddr */
+            for (i = 0; i < (pattern_BPP * 2); i++)
+            {
+                ((unsigned long *)pattern_dstaddr)[i] = pattern[i];
+            }
+        }
+        
+    }
+}
+
+
+/**********************************************************************
+ *
+ * deMonoPatternFill
+ *
+ * Purpose
+ *    Copy the specified monochrome pattern into the destination surface
+ *
+ * Remarks
+ *       Pattern size must be 8x8 pixel. 
+ *       Pattern color depth must be same as destination bitmap or monochrome.
+**********************************************************************/
+void deMonoPatternFill(unsigned long dst_base,
+                       unsigned long dst_pitch,  
+                       unsigned long dst_BPP,
+                       unsigned long dstX, 
+                       unsigned long dstY,
+                       unsigned long dst_width,
+                       unsigned long dst_height,
+                       unsigned long pattern_FGcolor,
+                       unsigned long pattern_BGcolor,
+                       unsigned long pattern_low, 
+                       unsigned long pattern_high)
+{
+    deWaitForNotBusy();
+    
+    SMTC_write2Dreg(DE_WINDOW_DESTINATION_BASE, FIELD_VALUE(0, DE_WINDOW_DESTINATION_BASE, ADDRESS, dst_base));
+    
+    SMTC_write2Dreg(DE_PITCH, FIELD_VALUE(0, DE_PITCH, DESTINATION, dst_pitch) |  FIELD_VALUE(0, DE_PITCH, SOURCE, dst_pitch));
+    
+    SMTC_write2Dreg(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dst_pitch) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dst_pitch));
+
+    SMTC_write2Dreg(DE_FOREGROUND,
+        FIELD_VALUE(0, DE_FOREGROUND, COLOR, pattern_FGcolor));
+
+    SMTC_write2Dreg(DE_BACKGROUND,
+        FIELD_VALUE(0, DE_BACKGROUND, COLOR, pattern_BGcolor));
+
+    SMTC_write2Dreg(DE_MONO_PATTERN_LOW,
+        FIELD_VALUE(0, DE_MONO_PATTERN_LOW, PATTERN, pattern_low));
+
+    SMTC_write2Dreg(DE_MONO_PATTERN_HIGH,
+        FIELD_VALUE(0, DE_MONO_PATTERN_HIGH, PATTERN, pattern_high));
+    
+    SMTC_write2Dreg(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    dstX)      |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    dstY));
+
+    SMTC_write2Dreg(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    dst_width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, dst_height));
+    
+    SMTC_write2Dreg(DE_CONTROL, 
+        FIELD_VALUE(0, DE_CONTROL, ROP, 0xF0) |
+        FIELD_SET(0, DE_CONTROL, COMMAND, BITBLT) |
+        FIELD_SET(0, DE_CONTROL, PATTERN, MONO)  |
+        FIELD_SET(0, DE_CONTROL, STATUS, START));
+
+    smtc_de_busy = 1;
+} /* deMonoPatternFill() */
+
+
+/**********************************************************************
+ *
+ * deColorPatternFill
+ *
+ * Purpose
+ *    Copy the specified pattern into the destination surface
+ *
+ * Parameters
+ *    [in]
+ *        pDestSurface   - Pointer to DE_SURFACE structure containing
+ *                         destination surface attributes
+ *        nX             - X coordinate of destination surface to be filled
+ *        nY             - Y coordinate of destination surface to be filled
+ *        dst_width         - Width (in pixels) of area to be filled
+ *        dst_height        - Height (in lines) of area to be filled
+ *        pPattern       - Pointer to DE_SURFACE structure containing
+ *                         pattern attributes
+ *        pPatternOrigin - Pointer to Point structure containing pattern origin
+ *        pMonoInfo      - Pointer to mono_pattern_info structure
+ *        pClipRect      - Pointer to Rect structure describing clipping
+ *                         rectangle; NULL if no clipping required
+ *
+ *    [out]
+ *        None
+ *
+ * Remarks
+ *       Pattern size must be 8x8 pixel. 
+ *       Pattern color depth must be same as destination bitmap.
+**********************************************************************/
+void deColorPatternFill(unsigned long dst_base,
+                        unsigned long dst_pitch,  
+                        unsigned long dst_BPP,  
+                        unsigned long dst_X, 
+                        unsigned long dst_Y, 
+                        unsigned long dst_width,
+                        unsigned long dst_height,
+                        unsigned long pattern_src_addr,
+                        unsigned long pattern_stride,
+                        int PatternOriginX,
+                        int PatternOriginY)
+{
+    unsigned int i;
+    unsigned long de_data_port_write_addr;
+    unsigned char ajPattern[PATTERN_WIDTH * PATTERN_HEIGHT * 4];
+    unsigned long de_ctrl = 0;
+    
+    deWaitForNotBusy();
+    
+    de_ctrl = FIELD_SET(0, DE_CONTROL, PATTERN, COLOR);
+    
+    SMTC_write2Dreg(DE_CONTROL, de_ctrl);
+    
+    /* Rotate pattern if necessary */
+    deRotatePattern(ajPattern, pattern_src_addr, dst_BPP, pattern_stride, PatternOriginX, PatternOriginY);
+    
+    /* Load pattern to 2D Engine Data Port */
+    de_data_port_write_addr = 0;
+    
+    for (i = 0; i < (dst_BPP * 2); i++)
+    {
+        SMTC_write2Ddataport(de_data_port_write_addr, ((unsigned long *)ajPattern)[i]);
+        de_data_port_write_addr += 4;
+    }
+    
+    deWaitForNotBusy();
+
+    SMTC_write2Dreg(DE_WINDOW_DESTINATION_BASE, FIELD_VALUE(0, DE_WINDOW_DESTINATION_BASE, ADDRESS, dst_base));
+ 
+    SMTC_write2Dreg(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dst_pitch) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      dst_pitch));
+
+    SMTC_write2Dreg(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dst_pitch) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dst_pitch));
+
+    SMTC_write2Dreg(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    dst_X)      |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    dst_Y));
+
+    SMTC_write2Dreg(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    dst_width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, dst_height));
+    
+    SMTC_write2Dreg(DE_CONTROL, 
+        FIELD_VALUE(0, DE_CONTROL, ROP, 0xF0) |
+        FIELD_SET(0, DE_CONTROL, COMMAND, BITBLT) |
+        FIELD_SET(0, DE_CONTROL, PATTERN, COLOR) |
+        FIELD_SET(0, DE_CONTROL, STATUS, START));
+
+    smtc_de_busy = 1;
+} /* deColorPatternFill() */
+
+
+/**********************************************************************
+ *
+ * deCopy
+ *
+ * Purpose
+ *    Copy a rectangular area of the source surface to a destination surface
+ *
+ * Remarks
+ *       Source bitmap must have the same color depth (BPP) as the destination bitmap.
+ *
+**********************************************************************/
+void deCopy(unsigned long dst_base,
+            unsigned long dst_pitch,  
+            unsigned long dst_BPP,  
+            unsigned long dst_X, 
+            unsigned long dst_Y, 
+            unsigned long dst_width,
+            unsigned long dst_height,
+            unsigned long src_base, 
+            unsigned long src_pitch,  
+            unsigned long src_X, 
+            unsigned long src_Y, 
+            pTransparent pTransp,
+            unsigned char nROP2)
+{
+    unsigned long nDirection = 0;
+    unsigned long nTransparent = 0;
+    unsigned long opSign = 1;    // Direction of ROP2 operation: 1 = Left to Right, (-1) = Right to Left
+    unsigned long xWidth = 192 / (dst_BPP / 8); // xWidth is in pixels
+    unsigned long de_ctrl = 0;
+    
+    deWaitForNotBusy();
+
+
+    SMTC_write2Dreg(DE_WINDOW_DESTINATION_BASE, FIELD_VALUE(0, DE_WINDOW_DESTINATION_BASE, ADDRESS, dst_base));
+
+    SMTC_write2Dreg(DE_WINDOW_SOURCE_BASE, FIELD_VALUE(0, DE_WINDOW_SOURCE_BASE, ADDRESS, src_base));
+
+    if (dst_pitch && src_pitch)
+    {
+        SMTC_write2Dreg(DE_PITCH,
+            FIELD_VALUE(0, DE_PITCH, DESTINATION, dst_pitch) |
+            FIELD_VALUE(0, DE_PITCH, SOURCE,      src_pitch));
+        
+        SMTC_write2Dreg(DE_WINDOW_WIDTH,
+            FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dst_pitch) |
+            FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      src_pitch));
+    }
+    
+    /* Set transparent bits if necessary */
+    if (pTransp != NULL)
+    {
+        nTransparent = pTransp->match | pTransp->select | pTransp->control;
+        
+        /* Set color compare register */
+        SMTC_write2Dreg(DE_COLOR_COMPARE,
+            FIELD_VALUE(0, DE_COLOR_COMPARE, COLOR, pTransp->color));
+    }
+    
+    /* Determine direction of operation */
+    if (src_Y < dst_Y)
+    {
+    /* +----------+
+    |S         |
+    |   +----------+
+    |   |      |   |
+    |   |      |   |
+    +---|------+   |
+    |         D|
+        +----------+ */
+        
+        nDirection = BOTTOM_TO_TOP;
+    }
+    else if (src_Y > dst_Y)
+    {
+    /* +----------+
+    |D         |
+    |   +----------+
+    |   |      |   |
+    |   |      |   |
+    +---|------+   |
+    |         S|
+        +----------+ */
+        
+        nDirection = TOP_TO_BOTTOM;
+    }
+    else
+    {
+        /* src_Y == dst_Y */
+        
+        if (src_X <= dst_X)
+        {
+        /* +------+---+------+
+        |S     |   |     D|
+        |      |   |      |
+        |      |   |      |
+        |      |   |      |
+            +------+---+------+ */
+            
+            nDirection = RIGHT_TO_LEFT;
+        }
+        else
+        {
+            /* src_X > dst_X */
+            
+            /* +------+---+------+
+            |D     |   |     S|
+            |      |   |      |
+            |      |   |      |
+            |      |   |      |
+            +------+---+------+ */
+            
+            nDirection = LEFT_TO_RIGHT;
+        }
+    }
+    
+    if ((nDirection == BOTTOM_TO_TOP) || (nDirection == RIGHT_TO_LEFT))
+    {
+        src_X += dst_width - 1;
+        src_Y += dst_height - 1;
+        dst_X += dst_width - 1;
+        dst_Y += dst_height - 1;
+        opSign = (-1);
+    }
+
+
+    if (dst_BPP>=24){
+            src_X*=3;
+            src_Y*=3;
+            dst_X*=3;
+	     dst_Y*=3;
+            dst_width*=3;
+	    if ((nDirection == BOTTOM_TO_TOP) || (nDirection == RIGHT_TO_LEFT))
+		    {
+		        src_X += 2;
+		        dst_X += 2;
+		    }
+    	}
+		
+    /* Workaround for 192 byte hw bug */
+    if ((nROP2 != 0x0C) && ((dst_width * (dst_BPP / 8)) >= 192))
+    {
+        /* Perform the ROP2 operation in chunks of (xWidth * dst_height) */
+        while (1)
+        {
+            deWaitForNotBusy();
+            SMTC_write2Dreg(DE_SOURCE,
+                FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_SOURCE, X_K1, src_X)   |
+                FIELD_VALUE(0, DE_SOURCE, Y_K2, src_Y));
+            SMTC_write2Dreg(DE_DESTINATION,
+                FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+                FIELD_VALUE(0, DE_DESTINATION, X,    dst_X)  |
+                FIELD_VALUE(0, DE_DESTINATION, Y,    dst_Y));
+            SMTC_write2Dreg(DE_DIMENSION,
+                FIELD_VALUE(0, DE_DIMENSION, X,    xWidth) |
+                FIELD_VALUE(0, DE_DIMENSION, Y_ET, dst_height));
+            de_ctrl = FIELD_VALUE(0, DE_CONTROL, ROP, nROP2) |
+                nTransparent |
+                FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+                FIELD_SET(0, DE_CONTROL, COMMAND, BITBLT) |
+                ((nDirection == 1) ? FIELD_SET(0, DE_CONTROL, DIRECTION, RIGHT_TO_LEFT)
+                : FIELD_SET(0, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT)) |
+                FIELD_SET(0, DE_CONTROL, STATUS, START);
+            SMTC_write2Dreg(DE_CONTROL, de_ctrl);
+            
+            src_X += (opSign * xWidth);
+            dst_X += (opSign * xWidth);
+            dst_width -= xWidth;
+            
+            if (dst_width <= 0)
+            {
+                /* ROP2 operation is complete */
+                break;
+            }
+            
+            if (xWidth > dst_width)
+            {
+                xWidth = dst_width;
+            }
+        }
+    }
+    else
+    {
+        deWaitForNotBusy();
+        SMTC_write2Dreg(DE_SOURCE,
+            FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_SOURCE, X_K1, src_X)   |
+            FIELD_VALUE(0, DE_SOURCE, Y_K2, src_Y));
+        SMTC_write2Dreg(DE_DESTINATION,
+            FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+            FIELD_VALUE(0, DE_DESTINATION, X,    dst_X)  |
+            FIELD_VALUE(0, DE_DESTINATION, Y,    dst_Y));
+        SMTC_write2Dreg(DE_DIMENSION,
+            FIELD_VALUE(0, DE_DIMENSION, X,    dst_width) |
+            FIELD_VALUE(0, DE_DIMENSION, Y_ET, dst_height));
+        de_ctrl = FIELD_VALUE(0, DE_CONTROL, ROP, nROP2) |
+            nTransparent |
+            FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+            FIELD_SET(0, DE_CONTROL, COMMAND, BITBLT) |
+            ((nDirection == 1) ? FIELD_SET(0, DE_CONTROL, DIRECTION, RIGHT_TO_LEFT)
+            : FIELD_SET(0, DE_CONTROL, DIRECTION, LEFT_TO_RIGHT)) |
+            FIELD_SET(0, DE_CONTROL, STATUS, START);
+        SMTC_write2Dreg(DE_CONTROL, de_ctrl);
+    }
+
+    smtc_de_busy = 1;
+}
+
+
+/**********************************************************************
+ *
+ * deSrcCopyHost
+ *
+ * Purpose
+ *    Copy a rectangular area of the source surface in system memory to
+ *    a destination surface in video memory
+ *
+ * Remarks
+ *       Source bitmap must have the same color depth (BPP) as the destination bitmap.
+ *
+**********************************************************************/
+void deSrcCopyHost(unsigned long dst_base, 
+                   unsigned long dst_pitch,  
+                   unsigned long dst_BPP,  
+                   unsigned long dst_X, 
+                   unsigned long dst_Y,
+                   unsigned long dst_width, 
+                   unsigned long dst_height, 
+                   unsigned long src_base, 
+                   unsigned long src_stride,  
+                   unsigned long src_X, 
+                   unsigned long src_Y,
+                   pTransparent pTransp,
+                   unsigned char nROP2)
+{
+    int nBytes_per_scan;
+    int nBytes8_per_scan;
+    int nBytes_remain;
+    int nLong;
+    unsigned long nTransparent = 0;
+    unsigned long de_ctrl = 0;
+    unsigned long i;
+    int j;
+    unsigned long ulSrc;
+    unsigned long de_data_port_write_addr;
+    unsigned char abyRemain[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+    unsigned char *pSrcBuffer;
+    
+    pSrcBuffer = (unsigned char*)(src_base + src_Y * src_stride + src_X * (dst_BPP / 8));
+
+    nBytes_per_scan = dst_width * (dst_BPP / 8);
+    nBytes8_per_scan = (nBytes_per_scan + 7) & ~7;
+    nBytes_remain = nBytes_per_scan & 7;
+    nLong = nBytes_per_scan & ~7;
+    
+    /* Program 2D Drawing Engine */
+    deWaitForNotBusy();
+
+    /* Set transparent bits if necessary */
+    if (pTransp != NULL)
+    {
+        nTransparent = pTransp->match | pTransp->select | pTransp->control;
+        
+        /* Set color compare register */
+        SMTC_write2Dreg(DE_COLOR_COMPARE,
+            FIELD_VALUE(0, DE_COLOR_COMPARE, COLOR, pTransp->color));
+    }
+    
+    SMTC_write2Dreg(DE_WINDOW_DESTINATION_BASE, FIELD_VALUE(0, DE_WINDOW_DESTINATION_BASE, ADDRESS, dst_base));
+    
+    SMTC_write2Dreg(DE_WINDOW_SOURCE_BASE, FIELD_VALUE(0, DE_WINDOW_SOURCE_BASE, ADDRESS, 0));
+    
+    SMTC_write2Dreg(DE_SOURCE,
+        FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_SOURCE, X_K1, 0)       |
+        FIELD_VALUE(0, DE_SOURCE, Y_K2, src_Y));
+    SMTC_write2Dreg(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    dst_X)  |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    dst_Y));
+    SMTC_write2Dreg(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    dst_width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, dst_height));
+    SMTC_write2Dreg(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dst_width) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      dst_width));
+    SMTC_write2Dreg(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dst_width) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dst_width));
+    de_ctrl = FIELD_VALUE(0, DE_CONTROL, ROP, nROP2) |
+        nTransparent |
+        FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+        FIELD_SET(0, DE_CONTROL, COMMAND, HOST_WRITE) |
+        FIELD_SET(0, DE_CONTROL, STATUS, START);
+    SMTC_write2Dreg(DE_CONTROL, de_ctrl);
+    
+    /* Write bitmap/image data (line by line) to 2D Engine data port */
+    de_data_port_write_addr = 0;
+    
+    for (i = 1; i < dst_height; i++)
+    {
+        for (j = 0; j < (nBytes8_per_scan / 4); j++)
+        {
+            memcpy(&ulSrc, (pSrcBuffer + (j * 4)), 4);
+            SMTC_write2Ddataport(de_data_port_write_addr, ulSrc);
+        }
+        
+        pSrcBuffer += src_stride;
+    }
+    
+    /* Special handling for last line of bitmap */
+    if (nLong)
+    {
+        for (j = 0; j < (nLong / 4); j++)
+        {
+            memcpy(&ulSrc, (pSrcBuffer + (j * 4)), 4);
+            SMTC_write2Ddataport(de_data_port_write_addr, ulSrc);
+        }
+    }
+    
+    if (nBytes_remain)
+    {
+        memcpy(abyRemain, (pSrcBuffer + nLong), nBytes_remain);
+        SMTC_write2Ddataport(de_data_port_write_addr, *(unsigned long*)abyRemain);
+        SMTC_write2Ddataport(de_data_port_write_addr, *(unsigned long*)(abyRemain + 4));
+    }
+
+    smtc_de_busy = 1;
+}
+
+
+/**********************************************************************
+ *
+ * deMonoSrcCopyHost
+ *
+ * Purpose
+ *    Copy a rectangular area of the monochrome source surface in 
+ *    system memory to a destination surface in video memory
+ *
+ * Parameters
+ *    [in]
+ *        pSrcSurface  - Pointer to DE_SURFACE structure containing
+ *                       source surface attributes
+ *        pSrcBuffer   - Pointer to source buffer (system memory)
+ *                       containing monochrome image
+ *        src_X        - X coordinate of source surface
+ *        src_Y        - Y coordinate of source surface
+ *        pDestSurface - Pointer to DE_SURFACE structure containing
+ *                       destination surface attributes
+ *        dst_X       - X coordinate of destination surface
+ *        dst_Y       - Y coordinate of destination surface
+ *        dst_width       - Width (in pixels) of the area to be copied
+ *        dst_height      - Height (in lines) of the area to be copied
+ *        nFgColor     - Foreground color
+ *        nBgColor     - Background color
+ *        pClipRect    - Pointer to Rect structure describing clipping
+ *                       rectangle; NULL if no clipping required
+ *        pTransp      - Pointer to Transparent structure containing
+ *                       transparency settings; NULL if no transparency
+ *                       required
+ *
+ *    [out]
+ *        None
+ *
+ * Returns
+ *    DDK_OK                      - function is successful
+ *    DDK_ERROR_NULL_PSRCSURFACE  - pSrcSurface is NULL
+ *    DDK_ERROR_NULL_PDESTSURFACE - pDestSurface is NULL
+ *
+**********************************************************************/
+void deMonoSrcCopyHost(unsigned long dst_base, 
+                      unsigned long dst_pitch,  
+                      unsigned long dst_BPP,  
+                      unsigned long dst_X, 
+                      unsigned long dst_Y,
+                      unsigned long dst_width, 
+                      unsigned long dst_height, 
+                      unsigned long src_base, 
+                      unsigned long src_stride,  
+                      unsigned long src_X, 
+                      unsigned long src_Y,
+                      unsigned long nFgColor, 
+                      unsigned long nBgColor,
+                      pTransparent pTransp)
+{
+    int nLeft_bits_off;
+    int nBytes_per_scan;
+    int nBytes4_per_scan;
+    int nBytes_remain;
+    int nLong;
+    unsigned long nTransparent = 0;
+    unsigned long de_ctrl = 0;
+    unsigned long de_data_port_write_addr;
+    unsigned long i;
+    int j;
+	unsigned long ulSrc;
+    unsigned char * pSrcBuffer;
+
+    pSrcBuffer = (unsigned char *)src_base+(src_Y * src_stride) + (src_X / 8);
+    nLeft_bits_off = (src_X & 0x07);
+    nBytes_per_scan = (dst_width + nLeft_bits_off + 7) / 8;
+    nBytes4_per_scan = (nBytes_per_scan + 3) & ~3;
+    nBytes_remain = nBytes_per_scan & 3;
+    nLong = nBytes_per_scan & ~3;
+
+    deWaitForNotBusy();
+    
+    /* Set transparent bits if necessary */
+    if (pTransp != NULL)
+    {
+        nTransparent = pTransp->match | pTransp->select | pTransp->control;
+        
+        /* Set color compare register */
+        SMTC_write2Dreg(DE_COLOR_COMPARE,
+            FIELD_VALUE(0, DE_COLOR_COMPARE, COLOR, pTransp->color));
+    }
+    
+    /* Program 2D Drawing Engine */
+
+    SMTC_write2Dreg(DE_WINDOW_DESTINATION_BASE, FIELD_VALUE(0, DE_WINDOW_DESTINATION_BASE, ADDRESS, dst_base));
+
+    SMTC_write2Dreg(DE_WINDOW_SOURCE_BASE, FIELD_VALUE(0, DE_WINDOW_SOURCE_BASE, ADDRESS, 0));
+
+    SMTC_write2Dreg(DE_PITCH,
+        FIELD_VALUE(0, DE_PITCH, DESTINATION, dst_pitch) |
+        FIELD_VALUE(0, DE_PITCH, SOURCE,      dst_pitch));
+    
+    SMTC_write2Dreg(DE_WINDOW_WIDTH,
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, dst_pitch) |
+        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      dst_pitch));
+
+    SMTC_write2Dreg(DE_SOURCE,
+        FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE)        |
+        FIELD_VALUE(0, DE_SOURCE, X_K1, nLeft_bits_off) |
+        FIELD_VALUE(0, DE_SOURCE, Y_K2, src_Y));
+
+    SMTC_write2Dreg(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    dst_X)  |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    dst_Y));
+
+    SMTC_write2Dreg(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    dst_width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, dst_height));
+
+    SMTC_write2Dreg(DE_FOREGROUND,
+        FIELD_VALUE(0, DE_FOREGROUND, COLOR, nFgColor));
+
+    SMTC_write2Dreg(DE_BACKGROUND,
+        FIELD_VALUE(0, DE_BACKGROUND, COLOR, nBgColor));
+    
+    de_ctrl = 0x0000000C |
+        FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2) |
+        FIELD_SET(0, DE_CONTROL, COMMAND, HOST_WRITE) |
+        FIELD_SET(0, DE_CONTROL, HOST, MONO) |
+        nTransparent |
+        FIELD_SET(0, DE_CONTROL, STATUS, START);
+    SMTC_write2Dreg(DE_CONTROL, de_ctrl);
+    
+    /* Write bitmap/image data (line by line) to 2D Engine data port */
+    de_data_port_write_addr = 0;
+    
+    for (i = 1; i < dst_height; i++)
+    {
+        for (j = 0; j < (nBytes4_per_scan / 4); j++)
+        {
+            memcpy(&ulSrc, (pSrcBuffer + (j * 4)), 4);
+            SMTC_write2Ddataport(de_data_port_write_addr, ulSrc);
+        }
+        
+        pSrcBuffer += src_stride;
+    }
+    
+    /* Special handling for last line of bitmap */
+    if (nLong)
+    {
+        for (j = 0; j < (nLong / 4); j++)
+        {
+            memcpy(&ulSrc, (pSrcBuffer + (j * 4)), 4);
+            SMTC_write2Ddataport(de_data_port_write_addr, ulSrc);
+        }
+    }
+    
+    if (nBytes_remain)
+    {
+        memcpy(&ulSrc, (pSrcBuffer + nLong), nBytes_remain);
+        SMTC_write2Ddataport(de_data_port_write_addr, ulSrc);
+    }
+
+    smtc_de_busy = 1;
+}
+
+/*
+ * This function sets the pixel format that will apply to the 2D Engine.
+ */
+void deSetPixelFormat(
+    unsigned long bpp
+)
+{
+    unsigned long de_format;
+    
+    de_format = SMTC_read2Dreg(DE_STRETCH_FORMAT);
+    
+    switch (bpp)
+    {
+        case 8:
+            de_format = FIELD_SET(de_format, DE_STRETCH_FORMAT, PIXEL_FORMAT, 8);
+            break;
+        default:
+        case 16:
+            de_format = FIELD_SET(de_format, DE_STRETCH_FORMAT, PIXEL_FORMAT, 16);
+            break;
+        case 32:
+            de_format = FIELD_SET(de_format, DE_STRETCH_FORMAT, PIXEL_FORMAT, 32);
+            break;
+    }
+    
+    SMTC_write2Dreg(DE_STRETCH_FORMAT, de_format);
+}
+
+
+
+/*
+ * System memory to Video memory monochrome expansion.
+ * Source is monochrome image in system memory.
+ * This function expands the monochrome data to color image in video memory.
+ */
+long deSystemMem2VideoMemMonoBlt(
+unsigned char *pSrcbuf, /* pointer to start of source buffer in system memory */
+long srcDelta,          /* Pitch value (in bytes) of the source buffer, +ive means top down and -ive mean button up */
+unsigned long startBit, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
+unsigned long dBase,    /* Address of destination: offset in frame buffer */
+unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+unsigned long bpp,      /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,       /* Starting coordinate of destination surface */
+unsigned long width, 
+unsigned long height,   /* width and height of rectange in pixel value */
+unsigned long fColor,   /* Foreground color (corresponding to a 1 in the monochrome data */
+unsigned long bColor,   /* Background color (corresponding to a 0 in the monochrome data */
+unsigned long rop2)     /* ROP value */
+{
+    unsigned long bytePerPixel;
+    unsigned long ulBytesPerScan;
+    unsigned long ul4BytesPerScan;
+    unsigned long ulBytesRemain;
+    unsigned long de_ctrl = 0;
+    unsigned char ajRemain[4];
+    long i, j;
+
+    bytePerPixel = bpp/8;
+
+    startBit &= 7; /* Just make sure the start bit is within legal range */
+    ulBytesPerScan = (width + startBit + 7) / 8;
+    ul4BytesPerScan = ulBytesPerScan & ~3;
+    ulBytesRemain = ulBytesPerScan & 3;
+
+ 	if (smtc_de_busy)
+       	deWaitForNotBusy();
+
+    /* 2D Source Base.
+       Use 0 for HOST Blt.
+    */
+    SMTC_write2Dreg(DE_WINDOW_SOURCE_BASE, 0);
+
+    /* 2D Destination Base.
+       It is an address offset (128 bit aligned) from the beginning of frame buffer.
+    */
+    SMTC_write2Dreg(DE_WINDOW_DESTINATION_BASE, dBase);
+
+
+    if (dPitch)
+    	{
+	    /* Program pitch (distance between the 1st points of two adjacent lines).
+	       Note that input pitch is BYTE value, but the 2D Pitch register uses
+	       pixel values. Need Byte to pixel convertion.
+	    */
+	    SMTC_write2Dreg(DE_PITCH,
+	        FIELD_VALUE(0, DE_PITCH, DESTINATION, dPitch/bytePerPixel) |
+	        FIELD_VALUE(0, DE_PITCH, SOURCE,      dPitch/bytePerPixel));
+
+	    /* Screen Window width in Pixels.
+	       2D engine uses this value to calculate the linear address in frame buffer for a given point.
+	    */
+	    SMTC_write2Dreg(DE_WINDOW_WIDTH,
+	        FIELD_VALUE(0, DE_WINDOW_WIDTH, DESTINATION, (dPitch/bytePerPixel)) |
+	        FIELD_VALUE(0, DE_WINDOW_WIDTH, SOURCE,      (dPitch/bytePerPixel)));
+    	}
+    /* Note: For 2D Source in Host Write, only X_K1 field is needed, and Y_K2 field is not used.
+             For mono bitmap, use startBit for X_K1. */
+    SMTC_write2Dreg(DE_SOURCE,
+        FIELD_SET  (0, DE_SOURCE, WRAP, DISABLE)  |
+        FIELD_VALUE(0, DE_SOURCE, X_K1, startBit) |
+        FIELD_VALUE(0, DE_SOURCE, Y_K2, 0));
+
+    SMTC_write2Dreg(DE_DESTINATION,
+        FIELD_SET  (0, DE_DESTINATION, WRAP, DISABLE) |
+        FIELD_VALUE(0, DE_DESTINATION, X,    dx)    |
+        FIELD_VALUE(0, DE_DESTINATION, Y,    dy));
+
+    SMTC_write2Dreg(DE_DIMENSION,
+        FIELD_VALUE(0, DE_DIMENSION, X,    width) |
+        FIELD_VALUE(0, DE_DIMENSION, Y_ET, height));
+
+    SMTC_write2Dreg(DE_FOREGROUND, fColor);
+    SMTC_write2Dreg(DE_BACKGROUND, bColor);
+
+    if (bpp)
+	    deSetPixelFormat(bpp);
+    /* Set the pixel format of the destination */
+
+
+    de_ctrl = FIELD_VALUE(0, DE_CONTROL, ROP, rop2)         |
+              FIELD_SET(0, DE_CONTROL, ROP_SELECT, ROP2)    |
+              FIELD_SET(0, DE_CONTROL, COMMAND, HOST_WRITE) |
+              FIELD_SET(0, DE_CONTROL, HOST, MONO)          |
+              FIELD_SET(0, DE_CONTROL, STATUS, START);
+
+    SMTC_write2Dreg(DE_CONTROL, de_ctrl | deGetTransparency());
+
+    /* Write MONO data (line by line) to 2D Engine data port */
+    for (i=0; i<height; i++)
+    {
+        /* For each line, send the data in chunks of 4 bytes */
+        for (j=0; j<(ul4BytesPerScan/4); j++)
+        {
+            SMTC_write2Ddataport( 0, *(unsigned long *)(pSrcbuf + (j * 4)));
+        }
+
+        if (ulBytesRemain)
+        {
+            memcpy(ajRemain, pSrcbuf+ul4BytesPerScan, ulBytesRemain);
+            SMTC_write2Ddataport(0,*(unsigned long *)ajRemain);
+        }
+
+        pSrcbuf += srcDelta;
+    }
+    smtc_de_busy = 1;
+	
+    return 0;
+}
+
+
+/*
+ * This function gets the transparency status from DE_CONTROL register.
+ * It returns a double word with the transparent fields properly set,
+ * while other fields are 0.
+ */
+unsigned long deGetTransparency()
+{
+    unsigned long de_ctrl;
+
+    de_ctrl = SMTC_read2Dreg(DE_CONTROL);
+
+    de_ctrl &= 
+        FIELD_MASK(DE_CONTROL_TRANSPARENCY_MATCH) | 
+        FIELD_MASK(DE_CONTROL_TRANSPARENCY_SELECT)| 
+        FIELD_MASK(DE_CONTROL_TRANSPARENCY);
+
+    return de_ctrl;
+}
+
+
+/**********************************************************************
+*
+ * Misc. functions
+ *
+ **********************************************************************/
+// Load 8x8 pattern into local video memory
+void deLoadPattern(unsigned char* pattern, unsigned long write_addr)
+{
+    int i;
+    for (i = 0; i < (8 * 8 * 2); i += 4)
+    {
+//        memWrite32(write_addr, *(unsigned long*)(&pattern[i]));     removed by boyod
+        write_addr += 4;
+    }
+}
diff -Nur linux-2.6.29.1/drivers/video/smi/smtc2d.h linux-2.6.29.1-lemote/drivers/video/smi/smtc2d.h
--- linux-2.6.29.1/drivers/video/smi/smtc2d.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/video/smi/smtc2d.h	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,580 @@
+/*
+ *  linux/drivers/video/smtc2d.h -- Silicon Motion SM501 and SM7xx 2D drawing engine functions.
+ *
+ *      Copyright (C) 2006 Silicon Motion Technology Corp.
+ *      Ge Wang, gewang@siliconmotion.com
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#ifndef NULL
+#define NULL    0
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+//                                                                            //
+// Internal macros                                                            //
+//                                                                            //
+////////////////////////////////////////////////////////////////////////////////
+
+#define _F_START(f)             (0 ? f)
+#define _F_END(f)               (1 ? f)
+#define _F_SIZE(f)              (1 + _F_END(f) - _F_START(f))
+#define _F_MASK(f)              (((1 << _F_SIZE(f)) - 1) << _F_START(f))
+#define _F_NORMALIZE(v, f)      (((v) & _F_MASK(f)) >> _F_START(f))
+#define _F_DENORMALIZE(v, f)    (((v) << _F_START(f)) & _F_MASK(f))
+
+
+////////////////////////////////////////////////////////////////////////////////
+//                                                                            //
+// Global macros                                                              //
+//                                                                            //
+////////////////////////////////////////////////////////////////////////////////
+
+#define FIELD_GET(x, reg, field) \
+( \
+    _F_NORMALIZE((x), reg ## _ ## field) \
+)
+
+#define FIELD_SET(x, reg, field, value) \
+( \
+    (x & ~_F_MASK(reg ## _ ## field)) \
+    | _F_DENORMALIZE(reg ## _ ## field ## _ ## value, reg ## _ ## field) \
+)
+
+#define FIELD_VALUE(x, reg, field, value) \
+( \
+    (x & ~_F_MASK(reg ## _ ## field)) \
+    | _F_DENORMALIZE(value, reg ## _ ## field) \
+)
+
+#define FIELD_CLEAR(reg, field) \
+( \
+    ~ _F_MASK(reg ## _ ## field) \
+)
+
+
+////////////////////////////////////////////////////////////////////////////////
+//                                                                            //
+// Field Macros                                                               //
+//                                                                            //
+////////////////////////////////////////////////////////////////////////////////
+
+#define FIELD_START(field)              (0 ? field)
+#define FIELD_END(field)                (1 ? field)
+#define FIELD_SIZE(field)               (1 + FIELD_END(field) - FIELD_START(field))
+#define FIELD_MASK(field)               (((1 << (FIELD_SIZE(field)-1)) | ((1 << (FIELD_SIZE(field)-1)) - 1)) << FIELD_START(field))
+#define FIELD_NORMALIZE(reg, field)     (((reg) & FIELD_MASK(field)) >> FIELD_START(field))
+#define FIELD_DENORMALIZE(field, value) (((value) << FIELD_START(field)) & FIELD_MASK(field))
+
+#define FIELD_INIT(reg, field, value)   FIELD_DENORMALIZE(reg ## _ ## field, \
+                                                          reg ## _ ## field ## _ ## value)
+#define FIELD_INIT_VAL(reg, field, value) \
+                                        (FIELD_DENORMALIZE(reg ## _ ## field, value))
+#define FIELD_VAL_SET(x, r, f, v)       x = x & ~FIELD_MASK(r ## _ ## f) \
+                                              | FIELD_DENORMALIZE(r ## _ ## f, r ## _ ## f ## _ ## v)
+
+
+
+
+
+#define RGB(r, g, b) ((unsigned long)(((r) << 16) | ((g) << 8) | (b)))
+
+// Transparent info definition
+typedef struct
+{
+    unsigned long match;    // Matching pixel is OPAQUE/TRANSPARENT
+	unsigned long select;   // Transparency controlled by SOURCE/DESTINATION
+	unsigned long control;  // ENABLE/DISABLE transparency
+	unsigned long color;    // Transparent color
+} Transparent, *pTransparent;
+
+#define PIXEL_DEPTH_1_BP		0		// 1 bit per pixel
+#define PIXEL_DEPTH_8_BPP		1		// 8 bits per pixel
+#define PIXEL_DEPTH_16_BPP		2		// 16 bits per pixel
+#define PIXEL_DEPTH_32_BPP		3		// 32 bits per pixel
+#define PIXEL_DEPTH_YUV422		8		// 16 bits per pixel YUV422
+#define PIXEL_DEPTH_YUV420		9		// 16 bits per pixel YUV420
+
+#define PATTERN_WIDTH           8
+#define PATTERN_HEIGHT          8
+
+#define	TOP_TO_BOTTOM			0
+#define	BOTTOM_TO_TOP			1
+#define RIGHT_TO_LEFT			BOTTOM_TO_TOP
+#define LEFT_TO_RIGHT			TOP_TO_BOTTOM
+
+// Constants used in Transparent structure
+#define MATCH_OPAQUE            0x00000000
+#define MATCH_TRANSPARENT       0x00000400
+#define SOURCE                  0x00000000
+#define DESTINATION             0x00000200
+
+// 2D registers.
+
+#define DE_SOURCE                                       0x000000
+#define DE_SOURCE_WRAP                                  31:31
+#define DE_SOURCE_WRAP_DISABLE                          0
+#define DE_SOURCE_WRAP_ENABLE                           1
+#define DE_SOURCE_X_K1                                  29:16
+#define DE_SOURCE_Y_K2                                  15:0
+
+#define DE_DESTINATION                                  0x000004
+#define DE_DESTINATION_WRAP                             31:31
+#define DE_DESTINATION_WRAP_DISABLE                     0
+#define DE_DESTINATION_WRAP_ENABLE                      1
+#define DE_DESTINATION_X                                28:16
+#define DE_DESTINATION_Y                                15:0
+
+#define DE_DIMENSION                                    0x000008
+#define DE_DIMENSION_X                                  28:16
+#define DE_DIMENSION_Y_ET                               15:0
+
+#define DE_CONTROL                                      0x00000C
+#define DE_CONTROL_STATUS                               31:31
+#define DE_CONTROL_STATUS_STOP                          0
+#define DE_CONTROL_STATUS_START                         1
+#define DE_CONTROL_PATTERN                              30:30
+#define DE_CONTROL_PATTERN_MONO                         0
+#define DE_CONTROL_PATTERN_COLOR                        1
+#define DE_CONTROL_UPDATE_DESTINATION_X                 29:29
+#define DE_CONTROL_UPDATE_DESTINATION_X_DISABLE         0
+#define DE_CONTROL_UPDATE_DESTINATION_X_ENABLE          1
+#define DE_CONTROL_QUICK_START                          28:28
+#define DE_CONTROL_QUICK_START_DISABLE                  0
+#define DE_CONTROL_QUICK_START_ENABLE                   1
+#define DE_CONTROL_DIRECTION                            27:27
+#define DE_CONTROL_DIRECTION_LEFT_TO_RIGHT              0
+#define DE_CONTROL_DIRECTION_RIGHT_TO_LEFT              1
+#define DE_CONTROL_MAJOR                                26:26
+#define DE_CONTROL_MAJOR_X                              0
+#define DE_CONTROL_MAJOR_Y                              1
+#define DE_CONTROL_STEP_X                               25:25
+#define DE_CONTROL_STEP_X_POSITIVE                      1
+#define DE_CONTROL_STEP_X_NEGATIVE                      0
+#define DE_CONTROL_STEP_Y                               24:24
+#define DE_CONTROL_STEP_Y_POSITIVE                      1
+#define DE_CONTROL_STEP_Y_NEGATIVE                      0
+#define DE_CONTROL_STRETCH                              23:23
+#define DE_CONTROL_STRETCH_DISABLE                      0
+#define DE_CONTROL_STRETCH_ENABLE                       1
+#define DE_CONTROL_HOST                                 22:22
+#define DE_CONTROL_HOST_COLOR                           0
+#define DE_CONTROL_HOST_MONO                            1
+#define DE_CONTROL_LAST_PIXEL                           21:21
+#define DE_CONTROL_LAST_PIXEL_OFF                       0
+#define DE_CONTROL_LAST_PIXEL_ON                        1
+#define DE_CONTROL_COMMAND                              20:16
+#define DE_CONTROL_COMMAND_BITBLT                       0
+#define DE_CONTROL_COMMAND_RECTANGLE_FILL               1
+#define DE_CONTROL_COMMAND_DE_TILE                      2
+#define DE_CONTROL_COMMAND_TRAPEZOID_FILL               3
+#define DE_CONTROL_COMMAND_ALPHA_BLEND                  4
+#define DE_CONTROL_COMMAND_RLE_STRIP                    5
+#define DE_CONTROL_COMMAND_SHORT_STROKE                 6
+#define DE_CONTROL_COMMAND_LINE_DRAW                    7
+#define DE_CONTROL_COMMAND_HOST_WRITE                   8
+#define DE_CONTROL_COMMAND_HOST_READ                    9
+#define DE_CONTROL_COMMAND_HOST_WRITE_BOTTOM_UP         10
+#define DE_CONTROL_COMMAND_ROTATE                       11
+#define DE_CONTROL_COMMAND_FONT                         12
+#define DE_CONTROL_COMMAND_TEXTURE_LOAD                 15
+#define DE_CONTROL_ROP_SELECT                           15:15
+#define DE_CONTROL_ROP_SELECT_ROP3                      0
+#define DE_CONTROL_ROP_SELECT_ROP2                      1
+#define DE_CONTROL_ROP2_SOURCE                          14:14
+#define DE_CONTROL_ROP2_SOURCE_BITMAP                   0
+#define DE_CONTROL_ROP2_SOURCE_PATTERN                  1
+#define DE_CONTROL_MONO_DATA                            13:12
+#define DE_CONTROL_MONO_DATA_NOT_PACKED                 0
+#define DE_CONTROL_MONO_DATA_8_PACKED                   1
+#define DE_CONTROL_MONO_DATA_16_PACKED                  2
+#define DE_CONTROL_MONO_DATA_32_PACKED                  3
+#define DE_CONTROL_REPEAT_ROTATE                        11:11
+#define DE_CONTROL_REPEAT_ROTATE_DISABLE                0
+#define DE_CONTROL_REPEAT_ROTATE_ENABLE                 1
+#define DE_CONTROL_TRANSPARENCY_MATCH                   10:10
+#define DE_CONTROL_TRANSPARENCY_MATCH_OPAQUE            0
+#define DE_CONTROL_TRANSPARENCY_MATCH_TRANSPARENT       1
+#define DE_CONTROL_TRANSPARENCY_SELECT                  9:9
+#define DE_CONTROL_TRANSPARENCY_SELECT_SOURCE           0
+#define DE_CONTROL_TRANSPARENCY_SELECT_DESTINATION      1
+#define DE_CONTROL_TRANSPARENCY                         8:8
+#define DE_CONTROL_TRANSPARENCY_DISABLE                 0
+#define DE_CONTROL_TRANSPARENCY_ENABLE                  1
+#define DE_CONTROL_ROP                                  7:0
+
+// Pseudo fields.
+
+#define DE_CONTROL_SHORT_STROKE_DIR                     27:24
+#define DE_CONTROL_SHORT_STROKE_DIR_225                 0
+#define DE_CONTROL_SHORT_STROKE_DIR_135                 1
+#define DE_CONTROL_SHORT_STROKE_DIR_315                 2
+#define DE_CONTROL_SHORT_STROKE_DIR_45                  3
+#define DE_CONTROL_SHORT_STROKE_DIR_270                 4
+#define DE_CONTROL_SHORT_STROKE_DIR_90                  5
+#define DE_CONTROL_SHORT_STROKE_DIR_180                 8
+#define DE_CONTROL_SHORT_STROKE_DIR_0                   10
+#define DE_CONTROL_ROTATION                             25:24
+#define DE_CONTROL_ROTATION_0                           0
+#define DE_CONTROL_ROTATION_270                         1
+#define DE_CONTROL_ROTATION_90                          2
+#define DE_CONTROL_ROTATION_180                         3
+
+#define DE_PITCH                                        0x000010
+#define DE_PITCH_DESTINATION                            28:16
+#define DE_PITCH_SOURCE                                 12:0
+
+#define DE_FOREGROUND                                   0x000014
+#define DE_FOREGROUND_COLOR                             31:0
+
+#define DE_BACKGROUND                                   0x000018
+#define DE_BACKGROUND_COLOR                             31:0
+
+#define DE_STRETCH_FORMAT                               0x00001C
+#define DE_STRETCH_FORMAT_PATTERN_XY                    30:30
+#define DE_STRETCH_FORMAT_PATTERN_XY_NORMAL             0
+#define DE_STRETCH_FORMAT_PATTERN_XY_OVERWRITE          1
+#define DE_STRETCH_FORMAT_PATTERN_Y                     29:27
+#define DE_STRETCH_FORMAT_PATTERN_X                     25:23
+#define DE_STRETCH_FORMAT_PIXEL_FORMAT                  21:20
+#define DE_STRETCH_FORMAT_PIXEL_FORMAT_8                0
+#define DE_STRETCH_FORMAT_PIXEL_FORMAT_16               1
+#define DE_STRETCH_FORMAT_PIXEL_FORMAT_24               3
+#define DE_STRETCH_FORMAT_PIXEL_FORMAT_32               2
+#define DE_STRETCH_FORMAT_ADDRESSING                    19:16
+#define DE_STRETCH_FORMAT_ADDRESSING_XY                 0
+#define DE_STRETCH_FORMAT_ADDRESSING_LINEAR             15
+#define DE_STRETCH_FORMAT_SOURCE_HEIGHT                 11:0
+
+#define DE_COLOR_COMPARE                                0x000020
+#define DE_COLOR_COMPARE_COLOR                          23:0
+
+#define DE_COLOR_COMPARE_MASK                           0x000024
+#define DE_COLOR_COMPARE_MASK_MASKS                     23:0
+
+#define DE_MASKS                                        0x000028
+#define DE_MASKS_BYTE_MASK                              31:16
+#define DE_MASKS_BIT_MASK                               15:0
+
+#define DE_CLIP_TL                                      0x00002C
+#define DE_CLIP_TL_TOP                                  31:16
+#define DE_CLIP_TL_STATUS                               13:13
+#define DE_CLIP_TL_STATUS_DISABLE                       0
+#define DE_CLIP_TL_STATUS_ENABLE                        1
+#define DE_CLIP_TL_INHIBIT                              12:12
+#define DE_CLIP_TL_INHIBIT_OUTSIDE                      0
+#define DE_CLIP_TL_INHIBIT_INSIDE                       1
+#define DE_CLIP_TL_LEFT                                 11:0
+
+#define DE_CLIP_BR                                      0x000030
+#define DE_CLIP_BR_BOTTOM                               31:16
+#define DE_CLIP_BR_RIGHT                                12:0
+
+#define DE_MONO_PATTERN_LOW                             0x000034
+#define DE_MONO_PATTERN_LOW_PATTERN                     31:0
+
+#define DE_MONO_PATTERN_HIGH                            0x000038
+#define DE_MONO_PATTERN_HIGH_PATTERN                    31:0
+
+#define DE_WINDOW_WIDTH                                 0x00003C
+#define DE_WINDOW_WIDTH_DESTINATION                     28:16
+#define DE_WINDOW_WIDTH_SOURCE                          12:0
+
+#define DE_WINDOW_SOURCE_BASE                           0x000040
+#define DE_WINDOW_SOURCE_BASE_EXT                       27:27
+#define DE_WINDOW_SOURCE_BASE_EXT_LOCAL                 0
+#define DE_WINDOW_SOURCE_BASE_EXT_EXTERNAL              1
+#define DE_WINDOW_SOURCE_BASE_CS                        26:26
+#define DE_WINDOW_SOURCE_BASE_CS_0                      0
+#define DE_WINDOW_SOURCE_BASE_CS_1                      1
+#define DE_WINDOW_SOURCE_BASE_ADDRESS                   25:0
+
+#define DE_WINDOW_DESTINATION_BASE                      0x000044
+#define DE_WINDOW_DESTINATION_BASE_EXT                  27:27
+#define DE_WINDOW_DESTINATION_BASE_EXT_LOCAL            0
+#define DE_WINDOW_DESTINATION_BASE_EXT_EXTERNAL         1
+#define DE_WINDOW_DESTINATION_BASE_CS                   26:26
+#define DE_WINDOW_DESTINATION_BASE_CS_0                 0
+#define DE_WINDOW_DESTINATION_BASE_CS_1                 1
+#define DE_WINDOW_DESTINATION_BASE_ADDRESS              25:0
+
+#define DE_ALPHA                                        0x000048
+#define DE_ALPHA_VALUE                                  7:0
+
+#define DE_WRAP                                         0x00004C
+#define DE_WRAP_X                                       31:16
+#define DE_WRAP_Y                                       15:0
+
+#define DE_STATUS                                       0x000050
+#define DE_STATUS_CSC                                   1:1
+#define DE_STATUS_CSC_CLEAR                             0
+#define DE_STATUS_CSC_NOT_ACTIVE                        0
+#define DE_STATUS_CSC_ACTIVE                            1
+#define DE_STATUS_2D                                    0:0
+#define DE_STATUS_2D_CLEAR                              0
+#define DE_STATUS_2D_NOT_ACTIVE                         0
+#define DE_STATUS_2D_ACTIVE                             1
+
+// Color Space Conversion registers.
+
+#define CSC_Y_SOURCE_BASE                               0x0000C8
+#define CSC_Y_SOURCE_BASE_EXT                           27:27
+#define CSC_Y_SOURCE_BASE_EXT_LOCAL                     0
+#define CSC_Y_SOURCE_BASE_EXT_EXTERNAL                  1
+#define CSC_Y_SOURCE_BASE_CS                            26:26
+#define CSC_Y_SOURCE_BASE_CS_0                          0
+#define CSC_Y_SOURCE_BASE_CS_1                          1
+#define CSC_Y_SOURCE_BASE_ADDRESS                       25:0
+
+#define CSC_CONSTANTS                                   0x0000CC
+#define CSC_CONSTANTS_Y                                 31:24
+#define CSC_CONSTANTS_R                                 23:16
+#define CSC_CONSTANTS_G                                 15:8
+#define CSC_CONSTANTS_B                                 7:0
+
+#define CSC_Y_SOURCE_X                                  0x0000D0
+#define CSC_Y_SOURCE_X_INTEGER                          26:16
+#define CSC_Y_SOURCE_X_FRACTION                         15:3
+
+#define CSC_Y_SOURCE_Y                                  0x0000D4
+#define CSC_Y_SOURCE_Y_INTEGER                          27:16
+#define CSC_Y_SOURCE_Y_FRACTION                         15:3
+
+#define CSC_U_SOURCE_BASE                               0x0000D8
+#define CSC_U_SOURCE_BASE_EXT                           27:27
+#define CSC_U_SOURCE_BASE_EXT_LOCAL                     0
+#define CSC_U_SOURCE_BASE_EXT_EXTERNAL                  1
+#define CSC_U_SOURCE_BASE_CS                            26:26
+#define CSC_U_SOURCE_BASE_CS_0                          0
+#define CSC_U_SOURCE_BASE_CS_1                          1
+#define CSC_U_SOURCE_BASE_ADDRESS                       25:0
+
+#define CSC_V_SOURCE_BASE                               0x0000DC
+#define CSC_V_SOURCE_BASE_EXT                           27:27
+#define CSC_V_SOURCE_BASE_EXT_LOCAL                     0
+#define CSC_V_SOURCE_BASE_EXT_EXTERNAL                  1
+#define CSC_V_SOURCE_BASE_CS                            26:26
+#define CSC_V_SOURCE_BASE_CS_0                          0
+#define CSC_V_SOURCE_BASE_CS_1                          1
+#define CSC_V_SOURCE_BASE_ADDRESS                       25:0
+
+#define CSC_SOURCE_DIMENSION                            0x0000E0
+#define CSC_SOURCE_DIMENSION_X                          31:16
+#define CSC_SOURCE_DIMENSION_Y                          15:0
+
+#define CSC_SOURCE_PITCH                                0x0000E4
+#define CSC_SOURCE_PITCH_Y                              31:16
+#define CSC_SOURCE_PITCH_UV                             15:0
+
+#define CSC_DESTINATION                                 0x0000E8
+#define CSC_DESTINATION_WRAP                            31:31
+#define CSC_DESTINATION_WRAP_DISABLE                    0
+#define CSC_DESTINATION_WRAP_ENABLE                     1
+#define CSC_DESTINATION_X                               27:16
+#define CSC_DESTINATION_Y                               11:0
+
+#define CSC_DESTINATION_DIMENSION                       0x0000EC
+#define CSC_DESTINATION_DIMENSION_X                     31:16
+#define CSC_DESTINATION_DIMENSION_Y                     15:0
+
+#define CSC_DESTINATION_PITCH                           0x0000F0
+#define CSC_DESTINATION_PITCH_X                         31:16
+#define CSC_DESTINATION_PITCH_Y                         15:0
+
+#define CSC_SCALE_FACTOR                                0x0000F4
+#define CSC_SCALE_FACTOR_HORIZONTAL                     31:16
+#define CSC_SCALE_FACTOR_VERTICAL                       15:0
+
+#define CSC_DESTINATION_BASE                            0x0000F8
+#define CSC_DESTINATION_BASE_EXT                        27:27
+#define CSC_DESTINATION_BASE_EXT_LOCAL                  0
+#define CSC_DESTINATION_BASE_EXT_EXTERNAL               1
+#define CSC_DESTINATION_BASE_CS                         26:26
+#define CSC_DESTINATION_BASE_CS_0                       0
+#define CSC_DESTINATION_BASE_CS_1                       1
+#define CSC_DESTINATION_BASE_ADDRESS                    25:0
+
+#define CSC_CONTROL                                     0x0000FC
+#define CSC_CONTROL_STATUS                              31:31
+#define CSC_CONTROL_STATUS_STOP                         0
+#define CSC_CONTROL_STATUS_START                        1
+#define CSC_CONTROL_SOURCE_FORMAT                       30:28
+#define CSC_CONTROL_SOURCE_FORMAT_YUV422                0
+#define CSC_CONTROL_SOURCE_FORMAT_YUV420I               1
+#define CSC_CONTROL_SOURCE_FORMAT_YUV420                2
+#define CSC_CONTROL_SOURCE_FORMAT_YVU9                  3
+#define CSC_CONTROL_SOURCE_FORMAT_IYU1                  4
+#define CSC_CONTROL_SOURCE_FORMAT_IYU2                  5
+#define CSC_CONTROL_SOURCE_FORMAT_RGB565                6
+#define CSC_CONTROL_SOURCE_FORMAT_RGB8888               7
+#define CSC_CONTROL_DESTINATION_FORMAT                  27:26
+#define CSC_CONTROL_DESTINATION_FORMAT_RGB565           0
+#define CSC_CONTROL_DESTINATION_FORMAT_RGB8888          1
+#define CSC_CONTROL_HORIZONTAL_FILTER                   25:25
+#define CSC_CONTROL_HORIZONTAL_FILTER_DISABLE           0
+#define CSC_CONTROL_HORIZONTAL_FILTER_ENABLE            1
+#define CSC_CONTROL_VERTICAL_FILTER                     24:24
+#define CSC_CONTROL_VERTICAL_FILTER_DISABLE             0
+#define CSC_CONTROL_VERTICAL_FILTER_ENABLE              1
+#define CSC_CONTROL_BYTE_ORDER                          23:23
+#define CSC_CONTROL_BYTE_ORDER_YUYV                     0
+#define CSC_CONTROL_BYTE_ORDER_UYVY                     1
+
+#define DE_DATA_PORT_501                                0x110000
+#define DE_DATA_PORT_712                                0x400000
+#define DE_DATA_PORT_722                                0x6000
+
+extern char *smtc_RegBaseAddress;	// point to virtual Memory Map IO starting address
+extern char *smtc_VRAMBaseAddress;		// point to virtual video memory starting address
+extern unsigned char smtc_de_busy;
+
+extern unsigned long memRead32(unsigned long nOffset);
+extern void memWrite32(unsigned long nOffset, unsigned long nData);
+unsigned long SMTC_read2Dreg(unsigned long nOffset);
+
+
+
+/* 2D functions */
+extern void deInit(unsigned int nModeWidth, unsigned int nModeHeight, unsigned int bpp);
+
+extern void deWaitForNotBusy(void);
+
+extern void deSetClipRectangle(int left, int top, int right, int bottom);
+
+extern void deVerticalLine(unsigned long dst_base,
+                    unsigned long dst_pitch, 
+                    unsigned long nX, 
+                    unsigned long nY, 
+                    unsigned long dst_height, 
+                    unsigned long nColor);
+
+extern void deHorizontalLine(unsigned long dst_base,
+                      unsigned long dst_pitch, 
+                      unsigned long nX, 
+                      unsigned long nY, 
+                      unsigned long dst_width, 
+                      unsigned long nColor);
+
+extern void deLine(unsigned long dst_base,
+            unsigned long dst_pitch,  
+            unsigned long nX1, 
+            unsigned long nY1, 
+            unsigned long nX2, 
+            unsigned long nY2, 
+            unsigned long nColor);
+
+extern void deFillRect(unsigned long dst_base,
+                unsigned long dst_pitch,  
+                unsigned long dst_X, 
+                unsigned long dst_Y, 
+                unsigned long dst_width, 
+                unsigned long dst_height, 
+                unsigned long nColor);
+
+extern void deRotatePattern(unsigned char* pattern_dstaddr,
+                     unsigned long pattern_src_addr,
+                     unsigned long pattern_BPP,
+                     unsigned long pattern_stride,
+                     int patternX,
+                     int patternY);
+
+extern void deMonoPatternFill(unsigned long dst_base,
+                       unsigned long dst_pitch,  
+                       unsigned long dst_BPP,
+                       unsigned long dstX, 
+                       unsigned long dstY,
+                       unsigned long dst_width,
+                       unsigned long dst_height,
+                       unsigned long pattern_FGcolor,
+                       unsigned long pattern_BGcolor,
+                       unsigned long pattern_low, 
+                       unsigned long pattern_high);
+
+extern void deColorPatternFill(unsigned long dst_base,
+                        unsigned long dst_pitch,  
+                        unsigned long dst_BPP,  
+                        unsigned long dst_X, 
+                        unsigned long dst_Y, 
+                        unsigned long dst_width,
+                        unsigned long dst_height,
+                        unsigned long pattern_src_addr,
+                        unsigned long pattern_stride,
+                        int PatternOriginX,
+                        int PatternOriginY);
+
+extern void deCopy(unsigned long dst_base,
+            unsigned long dst_pitch,  
+            unsigned long dst_BPP,  
+            unsigned long dst_X, 
+            unsigned long dst_Y, 
+            unsigned long dst_width,
+            unsigned long dst_height,
+            unsigned long src_base, 
+            unsigned long src_pitch,  
+            unsigned long src_X, 
+            unsigned long src_Y, 
+            pTransparent pTransp,
+            unsigned char nROP2);
+
+extern void deSrcCopyHost(unsigned long dst_base, 
+                   unsigned long dst_pitch,  
+                   unsigned long dst_BPP,  
+                   unsigned long dst_X, 
+                   unsigned long dst_Y,
+                   unsigned long dst_width, 
+                   unsigned long dst_height, 
+                   unsigned long src_base, 
+                   unsigned long src_stride,  
+                   unsigned long src_X, 
+                   unsigned long src_Y,
+                   pTransparent pTransp,
+                   unsigned char nROP2);
+
+extern void deMonoSrcCopyHost(unsigned long dst_base, 
+                      unsigned long dst_pitch,  
+                      unsigned long dst_BPP,  
+                      unsigned long dst_X, 
+                      unsigned long dst_Y,
+                      unsigned long dst_width, 
+                      unsigned long dst_height, 
+                      unsigned long src_base, 
+                      unsigned long src_stride,  
+                      unsigned long src_X, 
+                      unsigned long src_Y,
+                      unsigned long nFgColor, 
+                      unsigned long nBgColor,
+                      pTransparent pTransp);
+
+/*
+ * System memory to Video memory monochrome expansion.
+ * Source is monochrome image in system memory.
+ * This function expands the monochrome data to color image in video memory.
+ */
+long deSystemMem2VideoMemMonoBlt(
+unsigned char *pSrcbuf, /* pointer to start of source buffer in system memory */
+long srcDelta,          /* Pitch value (in bytes) of the source buffer, +ive means top down and -ive mean button up */
+unsigned long startBit, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
+unsigned long dBase,    /* Address of destination: offset in frame buffer */
+unsigned long dPitch,   /* Pitch value of destination surface in BYTE */
+unsigned long bpp,      /* Color depth of destination surface */
+unsigned long dx,
+unsigned long dy,       /* Starting coordinate of destination surface */
+unsigned long width, 
+unsigned long height,   /* width and height of rectange in pixel value */
+unsigned long fColor,   /* Foreground color (corresponding to a 1 in the monochrome data */
+unsigned long bColor,   /* Background color (corresponding to a 0 in the monochrome data */
+unsigned long rop2);    /* ROP value */
+
+unsigned long deGetTransparency();
+void deSetPixelFormat(
+    unsigned long bpp
+);
+
+
+	
+
+extern void deLoadPattern(unsigned char* pattern, unsigned long write_addr);
+
diff -Nur linux-2.6.29.1/drivers/video/smi/smtcfb.c linux-2.6.29.1-lemote/drivers/video/smi/smtcfb.c
--- linux-2.6.29.1/drivers/video/smi/smtcfb.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/video/smi/smtcfb.c	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,1196 @@
+/*
+ *  linux/drivers/video/smtcfb.c -- Silicon Motion SM501 and SM7xx frame buffer device
+ *
+ *      Copyright (C) 2006 Silicon Motion Technology Corp.
+ *      Ge Wang, gewang@siliconmotion.com
+ *      Boyod boyod.yang@siliconmotion.com.cn
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+*
+*
+* Version 0.10.26192.21.01
+    - Add PowerPC/Big endian support
+	- Add 2D support for Lynx
+    - Verified on 2.6.19.2                          Boyod.yang  <boyod.yang@siliconmotion.com.cn>
+
+* Version 0.09.2621.00.01
+    - Only support Linux Kernel's version 2.6.21.	Boyod.yang  <boyod.yang@siliconmotion.com.cn>
+
+* Version 0.09
+    - Only support Linux Kernel's version 2.6.12.	Boyod.yang  <boyod.yang@siliconmotion.com.cn>
+    
+*/
+
+#ifndef __KERNEL__
+#define __KERNEL__
+#endif
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/console.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/div64.h>
+
+#ifdef CONFIG_PM
+#include <linux/pm.h>
+#endif
+
+#include <linux/screen_info.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+
+#include "smtcfb.h"
+#include "smtc2d.h"
+
+#ifdef DEBUG
+#define smdbg(format, arg...)	printk(KERN_DEBUG format , ## arg)
+#else
+#define smdbg(format, arg...)
+#endif
+
+#define DEFAULT_VIDEO_MODE "800x600-16@60"
+#ifdef __BIG_ENDIAN
+struct screen_info screen_info;
+#endif
+
+
+
+/*
+ * globals
+ */
+ 
+static char *mode_option __devinitdata = DEFAULT_VIDEO_MODE;
+
+/*
+* Private structure
+*/
+struct smtcfb_info {
+        /*
+        * The following is a pointer to be passed into the
+        * functions below.  The modules outside the main
+        * voyager.c driver have no knowledge as to what
+        * is within this structure.
+        */
+        struct fb_info          fb;
+        struct display_switch   *dispsw;
+        struct pci_dev	        *dev;
+        signed int              currcon;
+
+        struct {
+                u8 red, green, blue;
+        } palette[NR_RGB];
+
+        u_int                   palette_size;
+};
+
+struct par_info {
+	/*
+	 * Hardware
+	 */
+	u16	chipID;
+	unsigned char   __iomem *m_pMMIO;
+       char            __iomem *m_pLFB;
+	char	*m_pDPR;
+	char	*m_pVPR;
+	char	*m_pCPR;
+
+	u_int	width;
+	u_int	height;
+	u_int	hz;
+    u_long  BaseAddressInVRAM;
+	u8	chipRevID;
+};
+
+struct vesa_mode_table	{
+	char mode_index[6];
+	u16 lfb_width;	
+	u16 lfb_height;		
+	u16 lfb_depth;	
+};
+
+
+static struct vesa_mode_table vesa_mode[] = 
+{
+	{"0x301", 640,  480,  8},
+	{"0x303", 800,  600,  8},
+	{"0x305", 1024, 768,	8},
+	{"0x307", 1280, 1024, 8},
+	
+	{"0x311", 640,  480,  16},
+	{"0x314", 800,  600,  16},
+	{"0x317", 1024, 768,	16},
+	{"0x31A", 1280, 1024, 16},
+	
+	{"0x312", 640,  480,  24},
+	{"0x315", 800,  600,  24},
+	{"0x318", 1024, 768,	24},
+	{"0x31B", 1280, 1024, 24},	
+	
+};
+
+char __iomem *smtc_RegBaseAddress;	// Memory Map IO starting address
+char __iomem *smtc_VRAMBaseAddress;	// video memory starting address
+
+
+char *smtc_2DBaseAddress;	// 2D engine starting address
+char *smtc_2Ddataport   ;	// 2D data port offset
+short smtc_2Dacceleration = 0;  //default no 2D acceleration
+
+static u32 colreg[17];
+static struct par_info hw;	// hardware information
+
+#if defined(CONFIG_FB_SM7XX_DUALHEAD)
+
+static u32 colreg2[17];
+static struct par_info hw2;	// hardware information for second display (CRT)
+struct smtcfb_info smtcfb_info2; //fb_info for second display (CRT)
+
+#endif //CONFIG_FB_SM501_DUALHEAD
+
+u16 smtc_ChipIDs[] = {
+    0x710,
+    0x712,
+    0x720
+};
+
+int sm712be_flag;
+
+int numSMTCchipIDs = sizeof(smtc_ChipIDs)/sizeof(u16);
+
+void deWaitForNotBusy(void)
+{
+	unsigned long i = 0x1000000;
+	while (i--)
+	{
+        if ((smtc_seqr(0x16) & 0x18) == 0x10)
+            break;
+	}
+    	smtc_de_busy = 0;
+}
+
+
+static void sm712_set_timing(struct smtcfb_info *sfb,struct par_info *ppar_info)
+{
+		int i=0,j=0;
+    u32 m_nScreenStride;
+    
+		smdbg("\nppar_info->width = %d ppar_info->height = %d sfb->fb.var.bits_per_pixel = %d ppar_info->hz = %d\n", 
+		ppar_info->width, ppar_info->height, sfb->fb.var.bits_per_pixel , ppar_info->hz);
+		
+    for (j=0;j < numVGAModes;j++) {
+		if (VGAMode[j].mmSizeX == ppar_info->width &&
+			VGAMode[j].mmSizeY == ppar_info->height &&
+			VGAMode[j].bpp == sfb->fb.var.bits_per_pixel &&
+			VGAMode[j].hz == ppar_info->hz)
+		{
+			smdbg("\nVGAMode[j].mmSizeX  = %d VGAMode[j].mmSizeY = %d VGAMode[j].bpp = %d VGAMode[j].hz=%d\n", 
+				VGAMode[j].mmSizeX , VGAMode[j].mmSizeY, VGAMode[j].bpp, VGAMode[j].hz);			
+		  smdbg("VGAMode index=%d\n",j);
+			 
+			smtc_mmiowb(0x0,0x3c6);
+
+			smtc_seqw(0,0x1);
+
+			smtc_mmiowb(VGAMode[j].Init_MISC,0x3c2);
+
+			for (i=0;i<SIZE_SR00_SR04;i++)	// init SEQ register SR00 - SR04
+			{
+				smtc_seqw(i,VGAMode[j].Init_SR00_SR04[i]);
+			}
+
+			for (i=0;i<SIZE_SR10_SR24;i++)	// init SEQ register SR10 - SR24
+			{
+				smtc_seqw(i+0x10,VGAMode[j].Init_SR10_SR24[i]);
+			}
+
+			for (i=0;i<SIZE_SR30_SR75;i++)	// init SEQ register SR30 - SR75
+			{
+				if (((i+0x30) != 0x62) && ((i+0x30) != 0x6a) && ((i+0x30) != 0x6b))
+					smtc_seqw(i+0x30,VGAMode[j].Init_SR30_SR75[i]);
+			}
+			for (i=0;i<SIZE_SR80_SR93;i++)	// init SEQ register SR80 - SR93
+			{
+				smtc_seqw(i+0x80,VGAMode[j].Init_SR80_SR93[i]);
+			}
+			for (i=0;i<SIZE_SRA0_SRAF;i++)	// init SEQ register SRA0 - SRAF
+			{
+				smtc_seqw(i+0xa0,VGAMode[j].Init_SRA0_SRAF[i]);
+			}
+
+			for (i=0;i<SIZE_GR00_GR08;i++)	// init Graphic register GR00 - GR08
+			{
+				smtc_grphw(i,VGAMode[j].Init_GR00_GR08[i]);
+			}
+
+			for (i=0;i<SIZE_AR00_AR14;i++)	// init Attribute register AR00 - AR14
+			{
+
+				smtc_attrw(i,VGAMode[j].Init_AR00_AR14[i]);
+			}
+
+			for (i=0;i<SIZE_CR00_CR18;i++)	// init CRTC register CR00 - CR18
+			{
+				smtc_crtcw(i,VGAMode[j].Init_CR00_CR18[i]);
+			}
+
+			for (i=0;i<SIZE_CR30_CR4D;i++)	// init CRTC register CR30 - CR4D
+			{
+				smtc_crtcw(i+0x30,VGAMode[j].Init_CR30_CR4D[i]);
+			}
+
+			for (i=0;i<SIZE_CR90_CRA7;i++)	// init CRTC register CR90 - CRA7
+			{
+				smtc_crtcw(i+0x90,VGAMode[j].Init_CR90_CRA7[i]);
+			}
+			
+		}
+	}
+	smtc_mmiowb(0x67,0x3c2);
+	
+	// set VPR registers
+	writel(0x0,ppar_info->m_pVPR+0x0C);
+	writel(0x0,ppar_info->m_pVPR+0x40);
+	
+	// set data width
+	m_nScreenStride = (ppar_info->width * sfb->fb.var.bits_per_pixel) / 64;
+	switch (sfb->fb.var.bits_per_pixel)
+	{
+		case 8:
+			writel(0x0,ppar_info->m_pVPR+0x0);
+			break;
+		case 16:
+			writel(0x00020000,ppar_info->m_pVPR+0x0);
+			break;
+		case 24:
+			writel(0x00040000,ppar_info->m_pVPR+0x0);
+            break;
+    case 32:
+      writel(0x00030000,ppar_info->m_pVPR+0x0);
+			break;
+	}
+	writel((u32)(((m_nScreenStride + 2) << 16) | m_nScreenStride),ppar_info->m_pVPR+0x10);
+
+}
+
+
+static void sm712_setpalette(int regno, unsigned red, unsigned green, unsigned blue, struct fb_info *info)
+{
+    struct par_info *cur_par = (struct par_info*)info->par;
+    
+    if (cur_par->BaseAddressInVRAM)
+        smtc_seqw(0x66,(smtc_seqr(0x66) & 0xC3) | 0x20);//second display palette for dual head. Enable CRT RAM, 6-bit RAM
+    else
+        smtc_seqw(0x66,(smtc_seqr(0x66) & 0xC3) | 0x10); //primary display palette. Enable LCD RAM only, 6-bit RAM
+    smtc_mmiowb(regno,       dac_reg);
+    smtc_mmiowb(red   >> 10, dac_val);
+    smtc_mmiowb(green >> 10, dac_val);
+    smtc_mmiowb(blue  >> 10, dac_val);
+}
+
+
+static void smtc_set_timing(struct smtcfb_info *sfb,struct par_info *ppar_info)
+{
+    switch (ppar_info->chipID) 
+    {
+     case 0x710:
+    case 0x712:
+    case 0x720:
+        sm712_set_timing(sfb,ppar_info);
+        break;
+    }
+}
+
+static struct fb_var_screeninfo smtcfb_var = {
+	.xres 		= 1024,
+	.yres 		= 600,
+	.xres_virtual 	= 1024,
+	.yres_virtual 	= 600,
+	.bits_per_pixel = 16,
+        .red            = { 16, 8, 0 },
+        .green          = {  8, 8, 0 },
+        .blue           = {  0, 8, 0 },
+	.activate	= FB_ACTIVATE_NOW,
+	.height		= -1,
+	.width		= -1,
+	.vmode		= FB_VMODE_NONINTERLACED,
+};
+
+static struct fb_fix_screeninfo smtcfb_fix = {
+	.id 		= "sm712fb",
+	.type 		= FB_TYPE_PACKED_PIXELS,
+	.visual 	= FB_VISUAL_TRUECOLOR,
+	.line_length 	= 800*3,
+	.accel 		= FB_ACCEL_SMI_LYNX,
+};
+
+
+/* chan_to_field
+ *
+ * convert a colour value into a field position
+ *
+ * from pxafb.c
+*/
+
+static inline unsigned int chan_to_field(unsigned int chan,
+					 struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int smtc_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue,  unsigned trans, struct fb_info *info)
+{
+	struct smtcfb_info *sfb = (struct smtcfb_info *)info;
+	u32 *pal,val;
+
+	if (regno > 255)
+		return 1;
+
+	switch (sfb->fb.fix.visual) {
+	case FB_VISUAL_DIRECTCOLOR:
+	case FB_VISUAL_TRUECOLOR:
+		/* 16/32 bit true-colour, use pseuo-palette for 16 base color*/
+		if (regno < 16) {
+			if (sfb->fb.var.bits_per_pixel==16)	{
+				u32 *pal = sfb->fb.pseudo_palette;	
+				val  = chan_to_field(red,   &sfb->fb.var.red);
+				val |= chan_to_field(green, &sfb->fb.var.green);
+				val |= chan_to_field(blue,  &sfb->fb.var.blue);
+#ifdef __BIG_ENDIAN
+				pal[regno] =( (red & 0xf800) >> 8) | ((green & 0xe000) >> 13) |((green & 0x1c00) << 3) | ((blue & 0xf800) >> 3);
+#else
+				pal[regno] = val;
+#endif
+			}
+			else{
+				u32 *pal = sfb->fb.pseudo_palette;	
+				val  = chan_to_field(red,   &sfb->fb.var.red);
+				val |= chan_to_field(green, &sfb->fb.var.green);
+				val |= chan_to_field(blue,  &sfb->fb.var.blue);
+#ifdef __BIG_ENDIAN
+				val = (val& 0xff00ff00>>8)|(val& 0x00ff00ff<<8);
+#endif
+				pal[regno] = val;
+			}
+		}
+		break;
+
+	case FB_VISUAL_PSEUDOCOLOR:
+		/* color depth 8 bit*/
+			sm712_setpalette(regno,red,green,blue, info);
+		break;
+
+	default:
+		return 1;   /* unknown type */
+	}
+
+	return 0;
+
+        
+}
+
+
+static ssize_t
+smtcfb_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	unsigned long p = *ppos;
+
+//	struct inode *inode = file->f_path.dentry->d_inode;
+        struct inode *inode = file->f_dentry->d_inode;
+        int fbidx = iminor(inode);
+        struct fb_info *info = registered_fb[fbidx];
+
+	u32 *buffer, *dst;
+	u32 __iomem *src;
+	int c, i, cnt = 0, err = 0;
+	unsigned long total_size;
+
+	if (!info || ! info->screen_base)
+		return -ENODEV;
+
+	if (info->state != FBINFO_STATE_RUNNING)
+		return -EPERM;
+
+	total_size = info->screen_size;
+
+	if (total_size == 0)
+		total_size = info->fix.smem_len;
+
+	if (p >= total_size)
+		return 0;
+
+	if (count >= total_size)
+		count = total_size;
+
+	if (count + p > total_size)
+		count = total_size - p;
+
+	buffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count,
+			 GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	src = (u32 __iomem *) (info->screen_base + p);
+
+	if (info->fbops->fb_sync)
+		info->fbops->fb_sync(info);
+
+	while (count) {
+		c  = (count > PAGE_SIZE) ? PAGE_SIZE : count;
+		dst = buffer;
+		for (i = c >> 2; i--; ){
+			*dst = fb_readl(src++);
+			*dst  = (*dst & 0xff00ff00>>8)|(*dst & 0x00ff00ff<<8);
+			dst++;
+			}
+		if (c & 3) {
+			u8 *dst8 = (u8 *) dst;
+			u8 __iomem *src8 = (u8 __iomem *) src;
+
+			for (i = c & 3; i--;){
+				if (i&1){
+				*dst8++ = fb_readb(++src8);
+				}
+				else{
+				*dst8++ = fb_readb(--src8);
+				src8 +=2;
+				}
+			}
+			src = (u32 __iomem *) src8;
+		}
+
+		if (copy_to_user(buf, buffer, c)) {
+			err = -EFAULT;
+			break;
+		}
+		*ppos += c;
+		buf += c;
+		cnt += c;
+		count -= c;
+	}
+
+	kfree(buffer);
+
+	return (err) ? err : cnt;
+}
+
+
+
+static ssize_t
+smtcfb_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+	unsigned long p = *ppos;
+//	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = file->f_dentry->d_inode;
+	int fbidx = iminor(inode);
+	struct fb_info *info = registered_fb[fbidx];
+	u32 *buffer, *src;
+	u32 __iomem *dst;
+	int c, i, cnt = 0, err = 0;
+	unsigned long total_size;
+
+	if (!info || !info->screen_base)
+		return -ENODEV;
+
+	if (info->state != FBINFO_STATE_RUNNING)
+		return -EPERM;
+
+	
+	total_size = info->screen_size;
+
+	if (total_size == 0)
+		total_size = info->fix.smem_len;
+
+	if (p > total_size)
+		return -EFBIG;
+
+	if (count > total_size) {
+		err = -EFBIG;
+		count = total_size;
+	}
+
+	if (count + p > total_size) {
+		if (!err)
+			err = -ENOSPC;
+
+		count = total_size - p;
+	}
+
+	buffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count,
+			 GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	dst = (u32 __iomem *) (info->screen_base + p);
+
+	if (info->fbops->fb_sync)
+		info->fbops->fb_sync(info);
+
+	while (count) {
+		c = (count > PAGE_SIZE) ? PAGE_SIZE : count;
+		src = buffer;
+
+		if (copy_from_user(src, buf, c)) {
+			err = -EFAULT;
+			break;
+		}
+
+		for (i = c >> 2; i--; ){
+			fb_writel( (*src& 0xff00ff00>>8)|(*src& 0x00ff00ff<<8), dst++);
+			src++;
+		}
+		if (c & 3) {
+			u8 *src8 = (u8 *) src;
+			u8 __iomem *dst8 = (u8 __iomem *) dst;
+
+			for (i = c & 3; i--; ){
+				if (i&1){
+				fb_writeb(*src8++, ++dst8);
+				}
+				else{
+				fb_writeb(*src8++, --dst8);
+				dst8 +=2;
+				}
+			}
+			dst = (u32 __iomem *) dst8;
+		}
+
+		*ppos += c;
+		buf += c;
+		cnt += c;
+		count -= c;
+	}
+
+	kfree(buffer);
+
+	return (cnt) ? cnt : err;
+}
+
+
+
+#include "smtc2d.c"
+
+
+void smtcfb_copyarea(struct fb_info *info, const struct fb_copyarea *area)
+{
+   struct par_info *p = (struct par_info*)info->par;
+
+    if (smtc_2Dacceleration)
+    {
+        if (!area->width || !area->height)
+            return;
+
+        deCopy(p->BaseAddressInVRAM, 0, info->var.bits_per_pixel,  
+            area->dx, area->dy, area->width, area->height, 
+            p->BaseAddressInVRAM, 0, area->sx, area->sy, 0, 0xC);
+
+    }
+    else
+
+        cfb_copyarea(info, area);
+}
+
+void smtcfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)
+{
+    struct par_info *p = (struct par_info*)info->par;
+    
+    if (smtc_2Dacceleration)
+    {
+        if (!rect->width || !rect->height)
+            return;
+	if (info->var.bits_per_pixel>=24)
+        deFillRect(p->BaseAddressInVRAM, 0, rect->dx*3, rect->dy*3, rect->width*3, rect->height, rect->color);
+	else
+        deFillRect(p->BaseAddressInVRAM, 0, rect->dx, rect->dy, rect->width, rect->height, rect->color);
+    }
+    else
+
+        cfb_fillrect(info, rect);
+}
+
+void smtcfb_imageblit(struct fb_info *info, const struct fb_image *image)
+{
+	    struct par_info *p = (struct par_info*)info->par;
+		u32 size, bg_col = 0, fg_col = 0;
+    if (smtc_2Dacceleration)
+    {
+        	if (image->depth == 1){
+		        if (smtc_de_busy)
+       		     deWaitForNotBusy();
+
+				switch (info->var.bits_per_pixel) {
+				case 8:
+					bg_col = image->bg_color;
+					fg_col = image->fg_color;
+					break;
+				case 16:
+					bg_col = ((u32 *) (info->pseudo_palette))[image->bg_color];
+					fg_col = ((u32 *) (info->pseudo_palette))[image->fg_color];
+					break;
+				case 32:
+					bg_col = ((u32 *) (info->pseudo_palette))[image->bg_color];
+					fg_col = ((u32 *) (info->pseudo_palette))[image->fg_color];
+					break;
+					}
+			deSystemMem2VideoMemMonoBlt(
+				image->data, /* pointer to start of source buffer in system memory */
+				image->width/8,          /* Pitch value (in bytes) of the source buffer, +ive means top down and -ive mean button up */
+				0, /* Mono data can start at any bit in a byte, this value should be 0 to 7 */
+				p->BaseAddressInVRAM,    /* Address of destination: offset in frame buffer */
+				0,   /* Pitch value of destination surface in BYTE */
+				0,      /* Color depth of destination surface */
+				image->dx,
+				image->dy,       /* Starting coordinate of destination surface */
+				image->width, 
+				image->height,   /* width and height of rectange in pixel value */
+				fg_col,   /* Foreground color (corresponding to a 1 in the monochrome data */
+				bg_col,   /* Background color (corresponding to a 0 in the monochrome data */
+				0x0C)     /* ROP value */;
+        	}
+		else
+       		 cfb_imageblit(info, image);
+    }
+    else
+        cfb_imageblit(info, image);
+}
+
+
+static struct fb_ops smtcfb_ops = {
+	.owner        =	THIS_MODULE,
+		.fb_setcolreg = smtc_setcolreg,
+		.fb_fillrect  = smtcfb_fillrect,
+		.fb_imageblit = smtcfb_imageblit,
+		.fb_copyarea  = smtcfb_copyarea,
+#ifdef __BIG_ENDIAN	
+		.fb_read = smtcfb_read,
+		.fb_write = smtcfb_write,
+#endif
+
+};
+
+
+void smtcfb_setmode(struct smtcfb_info *sfb)
+{
+	switch (sfb->fb.var.bits_per_pixel) {
+	//kylin
+	case 32:
+		sfb->fb.fix.visual              = FB_VISUAL_TRUECOLOR;
+		sfb->fb.fix.line_length= sfb->fb.var.xres * 4;
+		sfb->fb.var.red.length  = 8;
+		sfb->fb.var.green.length = 8;
+		sfb->fb.var.blue.length = 8;
+		sfb->fb.var.red.offset  = 16;
+                sfb->fb.var.green.offset= 8;
+                sfb->fb.var.blue.offset = 0;
+		
+		break;
+	case 8:
+		sfb->fb.fix.visual		= FB_VISUAL_PSEUDOCOLOR;
+		sfb->fb.fix.line_length= sfb->fb.var.xres ;
+		sfb->fb.var.red.offset	= 5;
+		sfb->fb.var.red.length	= 3;
+		sfb->fb.var.green.offset= 2;
+		sfb->fb.var.green.length= 3;
+		sfb->fb.var.blue.offset	= 0;
+		sfb->fb.var.blue.length	= 2;
+		break;
+	case 24:
+		sfb->fb.fix.visual		= FB_VISUAL_TRUECOLOR;
+		sfb->fb.fix.line_length= sfb->fb.var.xres * 3;
+		sfb->fb.var.red.length	= 8;
+		sfb->fb.var.green.length=8;
+		sfb->fb.var.blue.length	= 8;
+		
+
+		sfb->fb.var.red.offset	= 16;
+		sfb->fb.var.green.offset= 8;
+		sfb->fb.var.blue.offset	= 0;
+
+		break;
+	case 16:
+	default:
+		sfb->fb.fix.visual		= FB_VISUAL_TRUECOLOR;
+		sfb->fb.fix.line_length= sfb->fb.var.xres * 2;
+
+		sfb->fb.var.red.length	= 5;
+		sfb->fb.var.green.length= 6;
+		sfb->fb.var.blue.length	= 5;
+
+		sfb->fb.var.red.offset	= 11;
+		sfb->fb.var.green.offset= 5;
+		sfb->fb.var.blue.offset	= 0;
+
+		break;
+	}
+
+    hw.width = sfb->fb.var.xres;
+    hw.height = sfb->fb.var.yres;
+    hw.hz = 60;
+    smtc_set_timing(sfb, &hw);
+    if (smtc_2Dacceleration)
+    {
+    	printk("2D acceleration enabled!\n");
+       deInit(sfb->fb.var.xres, sfb->fb.var.yres, sfb->fb.var.bits_per_pixel); /* Init smtc drawing engine */
+    }
+}
+
+
+#if defined(CONFIG_FB_SM7XX_DUALHEAD)
+void smtc_head2_init(struct smtcfb_info *sfb)
+{
+    smtcfb_info2 = *sfb;
+    smtcfb_info2.fb.pseudo_palette = &colreg2;
+    smtcfb_info2.fb.par = &hw2;
+    sprintf(smtcfb_info2.fb.fix.id, "sm%Xfb2", hw.chipID);
+    hw2.chipID = hw.chipID;
+    hw2.chipRevID = hw.chipRevID;
+    hw2.width = smtcfb_info2.fb.var.xres;
+    hw2.height = smtcfb_info2.fb.var.yres;
+    hw2.hz = 60;
+    hw2.m_pMMIO = smtc_RegBaseAddress;
+    hw2.BaseAddressInVRAM = smtcfb_info2.fb.fix.smem_len/2; /*hard code 2nd head starting from half VRAM size postion */
+    smtcfb_info2.fb.screen_base = hw2.m_pLFB = smtc_VRAMBaseAddress+hw2.BaseAddressInVRAM;
+
+//    sm712crtSetMode(hw2.width, hw2.height, 0, hw2.hz, smtcfb_info2.fb.var.bits_per_pixel); 
+	writel(hw2.BaseAddressInVRAM >> 3,hw2.m_pVPR+0x10);
+}
+#endif
+
+
+/*
+ * Alloc struct smtcfb_info and assign the default value
+ */
+static struct smtcfb_info * __devinit smtc_alloc_fb_info(struct pci_dev *dev, char *name)
+{
+    struct smtcfb_info *sfb;
+
+    sfb = kmalloc(sizeof(struct smtcfb_info), GFP_KERNEL);
+
+    if (!sfb)
+        return NULL;
+
+    memset(sfb, 0, sizeof(struct smtcfb_info));
+
+    sfb->currcon        = -1;
+    sfb->dev            = dev;
+
+	/*** Init sfb->fb with default value ***/
+	sfb->fb.flags = FBINFO_FLAG_DEFAULT;
+	sfb->fb.fbops = &smtcfb_ops;
+	sfb->fb.var = smtcfb_var;
+	sfb->fb.fix = smtcfb_fix;
+    
+	strcpy(sfb->fb.fix.id, name);
+
+    sfb->fb.fix.type		= FB_TYPE_PACKED_PIXELS;
+    sfb->fb.fix.type_aux	= 0;
+    sfb->fb.fix.xpanstep	= 0;
+    sfb->fb.fix.ypanstep	= 0;
+    sfb->fb.fix.ywrapstep	= 0;
+    sfb->fb.fix.accel		= FB_ACCEL_SMI_LYNX;
+
+    sfb->fb.var.nonstd		= 0;
+    sfb->fb.var.activate	= FB_ACTIVATE_NOW;
+    sfb->fb.var.height		= -1;
+    sfb->fb.var.width		= -1;
+    sfb->fb.var.accel_flags	= FB_ACCELF_TEXT; /* text mode acceleration */
+    sfb->fb.var.vmode		= FB_VMODE_NONINTERLACED;
+    sfb->fb.par		        = &hw;
+    sfb->fb.pseudo_palette = colreg;
+	
+    return sfb;
+}
+
+/*
+ * Unmap in the memory mapped IO registers
+ *
+ */
+
+static void __devinit smtc_unmap_mmio(struct smtcfb_info *sfb)
+{
+    if (sfb && smtc_RegBaseAddress)
+    {
+        smtc_RegBaseAddress = NULL;
+    }
+}
+
+/*
+ * Map in the screen memory
+ *
+ */
+static int __devinit smtc_map_smem(struct smtcfb_info *sfb, struct pci_dev *dev, u_long smem_len)
+{
+	if(sfb->fb.var.bits_per_pixel == 32)
+    {
+        #ifdef __BIG_ENDIAN    
+        sfb->fb.fix.smem_start = pci_resource_start(dev, 0) + 0x800000;
+        #else
+        sfb->fb.fix.smem_start = pci_resource_start(dev, 0);
+        #endif
+    }
+    else
+    {
+        sfb->fb.fix.smem_start = pci_resource_start(dev, 0);
+    }
+
+    sfb->fb.fix.smem_len  = smem_len;
+
+    sfb->fb.screen_base = smtc_VRAMBaseAddress;
+
+    if (!sfb->fb.screen_base)
+    {
+        printk("%s: unable to map screen memory\n",sfb->fb.fix.id);
+        return -ENOMEM;
+    }
+
+    return 0;
+}
+
+
+/*
+ * Unmap in the screen memory
+ *
+ */
+static void __devinit smtc_unmap_smem(struct smtcfb_info *sfb)
+{
+    if (sfb && sfb->fb.screen_base)
+    {
+        iounmap(sfb->fb.screen_base);
+        sfb->fb.screen_base = NULL;
+    }
+}
+
+/*
+ * We need to wake up the LynxEM+, and make sure its in linear memory mode.
+ */
+static inline void __devinit sm7xx_init_hw(void)
+{
+		outb_p(0x18, 0x3c4);
+		outb_p(0x11, 0x3c5);
+}
+
+
+
+
+static void __devinit smtc_free_fb_info(struct smtcfb_info *sfb)
+{
+	if (sfb) {
+		fb_alloc_cmap(&sfb->fb.cmap, 0, 0);
+		kfree(sfb);
+	}
+}
+
+static int __init smtcfb_init(void)
+{
+	struct smtcfb_info *sfb;
+	u_long smem_size= 0x00800000; //default 8MB
+	char name[16];
+	int err;
+	unsigned long pFramebufferPhysical;
+	unsigned long pRegPhysical=0;
+	struct pci_dev *pdev = NULL;
+
+
+
+	printk("Silicon Motion display driver " SMTC_LINUX_FB_VERSION "\n");
+
+	int i = 0;
+    
+	do {
+		pdev = pci_find_device(0x126f,smtc_ChipIDs[i], pdev);
+		if (pdev == NULL)
+		{
+			i++;
+		}
+		else
+		{
+			hw.chipID = smtc_ChipIDs[i];
+			break;
+		}
+	} while (i< numSMTCchipIDs);
+
+	err = pci_enable_device(pdev); // enable SMTC chip
+
+	if (err) 
+	{
+		return err;
+	}
+	err = -ENOMEM;
+
+	sprintf(name, "sm%Xfb", hw.chipID);
+
+	sfb = smtc_alloc_fb_info(pdev, name);
+
+	if (!sfb) 
+	{
+		goto failed;
+	}
+
+	sm7xx_init_hw();
+
+/*get mode parameter from screen_info*/
+	if(screen_info.lfb_width != 0)
+	{
+		sfb->fb.var.xres = screen_info.lfb_width;
+		sfb->fb.var.yres = screen_info.lfb_height;
+		sfb->fb.var.bits_per_pixel = screen_info.lfb_depth;
+	}
+	else
+	{
+		sfb->fb.var.xres = SCREEN_X_RES;	// default resolution 1024x600 16bit mode
+		sfb->fb.var.yres = SCREEN_Y_RES;
+		sfb->fb.var.bits_per_pixel = SCREEN_BPP;
+	}	
+
+	
+	smdbg("\nsfb->fb.var.bits_per_pixel = %d sm712be_flag = %d\n", sfb->fb.var.bits_per_pixel, sm712be_flag);	
+#ifdef __BIG_ENDIAN	
+	if(sm712be_flag == 1 && sfb->fb.var.bits_per_pixel == 24)
+	{
+		sfb->fb.var.bits_per_pixel = screen_info.lfb_depth =32;	
+	}
+#endif
+	// Map address and memory detection
+	pFramebufferPhysical = pci_resource_start(pdev,0);
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &hw.chipRevID);
+   
+    switch (hw.chipID) 
+    {
+
+    case 0x710:
+    case 0x712:
+        sfb->fb.fix.mmio_start = pFramebufferPhysical + 0x00400000;
+        sfb->fb.fix.mmio_len   = 0x00400000;
+        smem_size = SM712_VIDEOMEMORYSIZE;        
+#ifdef __BIG_ENDIAN
+//        hw.m_pLFB = smtc_VRAMBaseAddress = ioremap(pFramebufferPhysical, 0x00a00000);
+        hw.m_pLFB = smtc_VRAMBaseAddress = ioremap(pFramebufferPhysical, 0x00c00000);       
+#else
+        hw.m_pLFB = smtc_VRAMBaseAddress = ioremap(pFramebufferPhysical, 0x00800000);
+#endif
+        hw.m_pMMIO = smtc_RegBaseAddress = smtc_VRAMBaseAddress + 0x00700000;
+        smtc_2DBaseAddress = hw.m_pDPR = smtc_VRAMBaseAddress + 0x00408000;
+        smtc_2Ddataport = smtc_VRAMBaseAddress + DE_DATA_PORT_712;
+        hw.m_pVPR = hw.m_pLFB + 0x0040c000;
+	if(sfb->fb.var.bits_per_pixel == 32)
+        {
+#ifdef __BIG_ENDIAN
+        smtc_VRAMBaseAddress += 0x800000;
+        hw.m_pLFB += 0x800000;
+				printk("\nsmtc_VRAMBaseAddress=0x%X hw.m_pLFB=0x%X\n", smtc_VRAMBaseAddress, hw.m_pLFB);
+#endif
+        }
+        if (!smtc_RegBaseAddress)
+        {
+            printk("%s: unable to map memory mapped IO\n",sfb->fb.fix.id);
+            return -ENOMEM;
+        }
+	
+/*        
+        smtc_seqw(0x62,0x7A);
+        smtc_seqw(0x6a,0x0c);
+        smtc_seqw(0x6b,0x02);
+ 
+        //LynxEM+ memory detection
+        *(u32 *)(smtc_VRAMBaseAddress + 4) = 0xAA551133;
+        if (*(u32 *)(smtc_VRAMBaseAddress + 4) != 0xAA551133)
+        {
+
+            smem_size = 0x00200000;
+            // Program the MCLK to 130 MHz
+            smtc_seqw(0x6a,0x12);
+            smtc_seqw(0x6b,0x02);
+            smtc_seqw(0x62,0x3e);
+        }
+*/
+	smtc_seqw(0x6a,0x16); //set MCLK = 14.31818 *  (0x16 / 0x2)
+	smtc_seqw(0x6b,0x02);
+	smtc_seqw(0x62,0x3e);
+	smtc_seqw(0x17,0x20); //enable PCI burst
+	//enabel word swap
+	if(sfb->fb.var.bits_per_pixel == 32)
+	{
+#ifdef __BIG_ENDIAN
+		smtc_seqw(0x17,0x30);
+#endif
+	}
+
+#ifdef CONFIG_FB_SM7XX_ACCEL			
+        smtc_2Dacceleration = 1;
+#endif
+
+        break;
+
+    case 0x720:
+        sfb->fb.fix.mmio_start = pFramebufferPhysical;
+        sfb->fb.fix.mmio_len   = 0x00200000;
+        smem_size = SM722_VIDEOMEMORYSIZE;        
+        smtc_2DBaseAddress = hw.m_pDPR = ioremap(pFramebufferPhysical, 0x00a00000);
+        hw.m_pLFB = smtc_VRAMBaseAddress = smtc_2DBaseAddress + 0x00200000;
+        hw.m_pMMIO = smtc_RegBaseAddress = smtc_2DBaseAddress + 0x000c0000;
+        smtc_2Ddataport = smtc_2DBaseAddress + DE_DATA_PORT_722;
+        hw.m_pVPR = smtc_2DBaseAddress + 0x800;
+        
+        smtc_seqw(0x62,0xff);
+        smtc_seqw(0x6a,0x0d);
+        smtc_seqw(0x6b,0x02);
+        smtc_2Dacceleration = 0;
+        break;
+	default:
+		printk("No valid Silicon Motion display chip was detected!\n");
+		smtc_free_fb_info(sfb);
+		return err;
+    }
+
+
+	//can support 32 bpp
+	if (15 == sfb->fb.var.bits_per_pixel)
+		sfb->fb.var.bits_per_pixel = 16;
+	//else if (32==sfb->fb.var.bits_per_pixel)
+	//	sfb->fb.var.bits_per_pixel = 24; 
+
+   	sfb->fb.var.xres_virtual = sfb->fb.var.xres;
+
+	sfb->fb.var.yres_virtual = sfb->fb.var.yres;
+	err = smtc_map_smem(sfb, pdev, smem_size);
+	if (err)
+	{
+		goto failed;
+	}
+
+	smtcfb_setmode(sfb);
+	hw.BaseAddressInVRAM = 0;  //Primary display starting from 0 postion 
+	sfb->fb.par = &hw;
+
+	err = register_framebuffer(&sfb->fb);
+	if (err < 0) 
+	{
+		goto failed;
+	}
+
+	printk("Silicon Motion SM%X Rev%X primary display mode %dx%d-%d Init Complete.\n",
+		hw.chipID, hw.chipRevID, sfb->fb.var.xres, sfb->fb.var.yres, sfb->fb.var.bits_per_pixel);
+
+#if defined(CONFIG_FB_SM7XX_DUALHEAD)
+	smtc_head2_init(sfb);
+	err = register_framebuffer(&smtcfb_info2.fb);
+
+	if (err < 0)
+	{
+		printk("Silicon Motion, Inc.  second head init fail\n");
+		goto failed; //if second head display fails, also fails the primary display
+	}
+
+	printk("Silicon Motion SM%X Rev%X secondary display mode %dx%d-%d Init Complete.\n",
+		hw.chipID, hw.chipRevID, hw2.width, hw2.height, smtcfb_info2.fb.var.bits_per_pixel);
+
+#endif
+
+	return 0;
+
+failed:
+	printk("Silicon Motion, Inc.  primary display init fail\n");
+	smtc_unmap_smem(sfb);
+	smtc_unmap_mmio(sfb);
+	smtc_free_fb_info(sfb);
+
+	return err;
+}
+
+static void __exit smtcfb_exit(void){}
+
+module_init(smtcfb_init);
+module_exit(smtcfb_exit);
+
+
+//#ifndef MODULE
+/**
+	*	sm712be_setup - process command line options 
+	*	@options: string of options 
+	*	Returns zero. 
+	* 
+*/
+static int __init sm712be_setup(char *options)
+{	
+	int retval = 0;	
+	sm712be_flag = 0;	
+	if (!options || !*options) 	
+	{
+		retval = 1;	
+		smdbg("\n No sm712be parameter\n", __LINE__);
+	}
+	if (!retval && strstr(options, "enable")) 	
+	{		
+		sm712be_flag = 1;		 	
+	}	
+	smdbg("\nsm712be_setup = %s sm712be_flag = %d\n", options, sm712be_flag); 	
+	return 1;
+}
+
+__setup("sm712be=", sm712be_setup);
+
+//#endif
+
+#ifdef __BIG_ENDIAN
+/**
+	*	sm712vga_setup - process command line options, get vga parameter 
+	*	@options: string of options 
+	*	Returns zero. 
+	* 
+*/
+static int __init sm712vga_setup(char *options)
+{	
+	int retval = 0;	
+	int index ;
+	sm712be_flag = 0;	
+	
+	if (!options || !*options) 	
+	{
+		retval = 1;	
+		smdbg("\n No vga parameter\n", __LINE__);
+	}
+		
+	screen_info.lfb_width = 0;
+	screen_info.lfb_height = 0;
+	screen_info.lfb_depth = 0;
+	
+	for (index = 0; index < (sizeof(vesa_mode) / sizeof(struct vesa_mode_table)); index++)
+	{
+		if(strstr(options, vesa_mode[index].mode_index))
+		{
+			screen_info.lfb_width = vesa_mode[index].lfb_width;
+			screen_info.lfb_height = vesa_mode[index].lfb_height;
+			screen_info.lfb_depth = vesa_mode[index].lfb_depth;
+		}
+	}
+	smdbg("\nsm712vga_setup = %s\n", options); 
+	return 1;
+}
+
+__setup("vga=", sm712vga_setup);
+#endif
+
+MODULE_AUTHOR("Siliconmotion ");
+MODULE_DESCRIPTION("Framebuffer driver for SMI Graphic Cards");
+MODULE_LICENSE("GPL");
+
diff -Nur linux-2.6.29.1/drivers/video/smi/smtcfb.h linux-2.6.29.1-lemote/drivers/video/smi/smtcfb.h
--- linux-2.6.29.1/drivers/video/smi/smtcfb.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29.1-lemote/drivers/video/smi/smtcfb.h	2009-04-07 09:39:28.000000000 +0000
@@ -0,0 +1,795 @@
+/*
+ *  linux/drivers/video/smtcfb.h -- Silicon Motion SM501 and SM7xx frame buffer device
+ *
+ *      Copyright (C) 2006 Silicon Motion Technology Corp.
+ *      Ge Wang, gewang@siliconmotion.com
+ *      Boyod boyod.yang@siliconmotion.com.cn
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License. See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#define SMTC_LINUX_FB_VERSION	"version 0.11.2619.21.01 July 27, 2008"
+
+#define NR_PALETTE	256
+#define NR_RGB          2
+
+#define FB_ACCEL_SMI_LYNX  88
+
+
+
+#ifdef __BIG_ENDIAN
+#define PC_VGA 0
+#else
+#define PC_VGA 1
+#endif
+
+#define SCREEN_X_RES	1024
+#define SCREEN_Y_RES	600
+#define SCREEN_BPP	16
+
+#ifndef FIELD_OFFSET
+#define FIELD_OFSFET(type, field) 	((unsigned long) (PUCHAR) &(((type *)0)->field))
+#endif
+
+#define SM712_VIDEOMEMORYSIZE    0x00400000  /*Assume SM712 graphics chip has 4MB VRAM */
+#define SM722_VIDEOMEMORYSIZE    0x00800000  /*Assume SM722 graphics chip has 8MB VRAM */
+
+#define dac_reg	(0x3c8)
+#define dac_val	(0x3c9)
+
+extern char *smtc_RegBaseAddress;
+#define smtc_mmiowb(dat,reg)	writeb(dat, smtc_RegBaseAddress + reg)
+#define smtc_mmioww(dat,reg)	writew(dat, smtc_RegBaseAddress + reg)
+#define smtc_mmiowl(dat,reg)	writel(dat, smtc_RegBaseAddress + reg)
+
+#define smtc_mmiorb(reg)	        readb(smtc_RegBaseAddress + reg)
+#define smtc_mmiorw(reg)	        readw(smtc_RegBaseAddress + reg)
+#define smtc_mmiorl(reg)	        readl(smtc_RegBaseAddress + reg)
+
+#define SIZE_SR00_SR04      (0x04 - 0x00 + 1)
+#define SIZE_SR10_SR24      (0x24 - 0x10 + 1)
+#define SIZE_SR30_SR75      (0x75 - 0x30 + 1)
+#define SIZE_SR80_SR93      (0x93 - 0x80 + 1)
+#define SIZE_SRA0_SRAF      (0xAF - 0xA0 + 1)
+#define SIZE_GR00_GR08      (0x08 - 0x00 + 1)
+#define SIZE_AR00_AR14      (0x14 - 0x00 + 1)
+#define SIZE_CR00_CR18      (0x18 - 0x00 + 1)
+#define SIZE_CR30_CR4D      (0x4D - 0x30 + 1)
+#define SIZE_CR90_CRA7      (0xA7 - 0x90 + 1)
+#define SIZE_VPR            (0x6C + 1)
+#define SIZE_DPR			(0x44 + 1)
+
+
+static inline void smtc_crtcw(int reg, int val)
+{
+        smtc_mmiowb(reg, 0x3d4);
+        smtc_mmiowb(val, 0x3d5);
+}
+
+static inline unsigned int smtc_crtcr(int reg)
+{
+        smtc_mmiowb(reg, 0x3d4);
+        return smtc_mmiorb(0x3d5);
+}
+
+static inline void smtc_grphw(int reg, int val)
+{
+        smtc_mmiowb(reg, 0x3ce);
+        smtc_mmiowb(val, 0x3cf);
+}
+
+static inline unsigned int smtc_grphr(int reg)
+{
+        smtc_mmiowb(reg, 0x3ce);
+        return smtc_mmiorb(0x3cf);
+}
+
+static inline void smtc_attrw(int reg, int val)
+{
+        smtc_mmiorb(0x3da);
+        smtc_mmiowb(reg, 0x3c0);
+        smtc_mmiorb(0x3c1);
+        smtc_mmiowb(val, 0x3c0);
+}
+
+static inline void smtc_seqw(int reg, int val)
+{
+        smtc_mmiowb(reg, 0x3c4);
+        smtc_mmiowb(val, 0x3c5);
+}
+
+static inline unsigned int smtc_seqr(int reg)
+{
+        smtc_mmiowb(reg, 0x3c4);
+        return smtc_mmiorb(0x3c5);
+}
+
+// The next structure holds all information relevant for a specific video mode.
+
+
+struct ModeInit
+{
+	int			  mmSizeX;
+	int			  mmSizeY;
+	int			  bpp;
+	int			  hz;
+	unsigned char Init_MISC;
+	unsigned char Init_SR00_SR04[SIZE_SR00_SR04];
+	unsigned char Init_SR10_SR24[SIZE_SR10_SR24];
+	unsigned char Init_SR30_SR75[SIZE_SR30_SR75];
+	unsigned char Init_SR80_SR93[SIZE_SR80_SR93];
+	unsigned char Init_SRA0_SRAF[SIZE_SRA0_SRAF];
+	unsigned char Init_GR00_GR08[SIZE_GR00_GR08];
+	unsigned char Init_AR00_AR14[SIZE_AR00_AR14];
+	unsigned char Init_CR00_CR18[SIZE_CR00_CR18];
+	unsigned char Init_CR30_CR4D[SIZE_CR30_CR4D];
+	unsigned char Init_CR90_CRA7[SIZE_CR90_CRA7];
+};
+
+
+
+/**********************************************************************
+                        SM712 Mode table.
+ **********************************************************************/
+struct ModeInit VGAMode[] =
+{
+	{
+		/*  mode#0: 640 x 480  16Bpp  60Hz */
+		640, 480, 16, 60,
+		/*  Init_MISC */
+		0xE3,
+		{   /*  Init_SR0_SR4 */
+			0x03, 0x01, 0x0F, 0x00, 0x0E,
+		},
+		{   /*  Init_SR10_SR24 */
+			0xFF, 0xBE, 0xEF, 0xFF, 0x00, 0x0E, 0x17, 0x2C,
+			0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0xC4, 0x30, 0x02, 0x01, 0x01,
+		},
+		{   /*  Init_SR30_SR75 */
+			0x32, 0x03, 0xA0, 0x09, 0xC0, 0x32, 0x32, 0x32,
+			0x32, 0x32, 0x32, 0x32, 0x00, 0x00, 0x03, 0xFF,
+			0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+			0x20, 0x0C, 0x44, 0x20, 0x00, 0x32, 0x32, 0x32,
+			0x04, 0x24, 0x63, 0x4F, 0x52, 0x0B, 0xDF, 0xEA,
+			0x04, 0x50, 0x19, 0x32, 0x32, 0x00, 0x00, 0x32,
+			0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+			0x50, 0x03, 0x74, 0x14, 0x07, 0x82, 0x07, 0x04,
+			0x00, 0x45, 0x30, 0x30, 0x40, 0x30,
+		},
+		{   /*  Init_SR80_SR93 */
+			0xFF, 0x07, 0x00, 0x6F, 0x7F, 0x7F, 0xFF, 0x32,
+			0xF7, 0x00, 0x00, 0x00, 0xEF, 0xFF, 0x32, 0x32,
+			0x00, 0x00, 0x00, 0x00,
+		},
+		{   /*  Init_SRA0_SRAF */
+			0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xED, 0xED, 0xED,
+			0x7B, 0xFF, 0xFF, 0xFF, 0xBF, 0xEF, 0xFF, 0xDF,
+		},
+		{   /*  Init_GR00_GR08 */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+			0xFF,
+		},
+		{   /*  Init_AR00_AR14 */
+			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+			0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+			0x41, 0x00, 0x0F, 0x00, 0x00,
+		},
+		{   /*  Init_CR00_CR18 */
+			0x5F, 0x4F, 0x4F, 0x00, 0x53, 0x1F, 0x0B, 0x3E,
+			0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0xEA, 0x0C, 0xDF, 0x50, 0x40, 0xDF, 0x00, 0xE3,
+			0xFF,
+		},
+		{   /*  Init_CR30_CR4D */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x03, 0x20,
+			0x00, 0x00, 0x00, 0x40, 0x00, 0xE7, 0xFF, 0xFD,
+			0x5F, 0x4F, 0x00, 0x54, 0x00, 0x0B, 0xDF, 0x00,
+			0xEA, 0x0C, 0x2E, 0x00, 0x4F, 0xDF,
+		},
+		{   /*  Init_CR90_CRA7 */
+			0x56, 0xDD, 0x5E, 0xEA, 0x87, 0x44, 0x8F, 0x55,
+			0x0A, 0x8F, 0x55, 0x0A, 0x00, 0x00, 0x18, 0x00,
+			0x11, 0x10, 0x0B, 0x0A, 0x0A, 0x0A, 0x0A, 0x00,
+		},
+	},
+	{
+		/*  mode#1: 640 x 480  24Bpp  60Hz */
+		640, 480, 24, 60,
+		/*  Init_MISC */
+		0xE3,
+		{   /*  Init_SR0_SR4 */
+			0x03, 0x01, 0x0F, 0x00, 0x0E,
+		},
+		{   /*  Init_SR10_SR24 */
+			0xFF, 0xBE, 0xEF, 0xFF, 0x00, 0x0E, 0x17, 0x2C,
+			0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0xC4, 0x30, 0x02, 0x01, 0x01,
+		},
+		{   /*  Init_SR30_SR75 */
+			0x32, 0x03, 0xA0, 0x09, 0xC0, 0x32, 0x32, 0x32,
+			0x32, 0x32, 0x32, 0x32, 0x00, 0x00, 0x03, 0xFF,
+			0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+			0x20, 0x0C, 0x44, 0x20, 0x00, 0x32, 0x32, 0x32,
+			0x04, 0x24, 0x63, 0x4F, 0x52, 0x0B, 0xDF, 0xEA,
+			0x04, 0x50, 0x19, 0x32, 0x32, 0x00, 0x00, 0x32,
+			0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+			0x50, 0x03, 0x74, 0x14, 0x07, 0x82, 0x07, 0x04,
+			0x00, 0x45, 0x30, 0x30, 0x40, 0x30,
+		},
+		{   /*  Init_SR80_SR93 */
+			0xFF, 0x07, 0x00, 0x6F, 0x7F, 0x7F, 0xFF, 0x32,
+			0xF7, 0x00, 0x00, 0x00, 0xEF, 0xFF, 0x32, 0x32,
+			0x00, 0x00, 0x00, 0x00,
+		},
+		{   /*  Init_SRA0_SRAF */
+			0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xED, 0xED, 0xED,
+			0x7B, 0xFF, 0xFF, 0xFF, 0xBF, 0xEF, 0xFF, 0xDF,
+		},
+		{   /*  Init_GR00_GR08 */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+			0xFF,
+		},
+		{   /*  Init_AR00_AR14 */
+			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+			0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+			0x41, 0x00, 0x0F, 0x00, 0x00,
+		},
+		{   /*  Init_CR00_CR18 */
+			0x5F, 0x4F, 0x4F, 0x00, 0x53, 0x1F, 0x0B, 0x3E,
+			0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0xEA, 0x0C, 0xDF, 0x50, 0x40, 0xDF, 0x00, 0xE3,
+			0xFF,
+		},
+		{   /*  Init_CR30_CR4D */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x03, 0x20,
+			0x00, 0x00, 0x00, 0x40, 0x00, 0xE7, 0xFF, 0xFD,
+			0x5F, 0x4F, 0x00, 0x54, 0x00, 0x0B, 0xDF, 0x00,
+			0xEA, 0x0C, 0x2E, 0x00, 0x4F, 0xDF,
+		},
+		{   /*  Init_CR90_CRA7 */
+			0x56, 0xDD, 0x5E, 0xEA, 0x87, 0x44, 0x8F, 0x55,
+			0x0A, 0x8F, 0x55, 0x0A, 0x00, 0x00, 0x18, 0x00,
+			0x11, 0x10, 0x0B, 0x0A, 0x0A, 0x0A, 0x0A, 0x00,
+		},
+	},
+	{
+		/*  mode#0: 640 x 480  32Bpp  60Hz */
+		640, 480, 32, 60,
+		/*  Init_MISC */
+		0xE3,
+		{   /*  Init_SR0_SR4 */
+			0x03, 0x01, 0x0F, 0x00, 0x0E,
+		},
+		{   /*  Init_SR10_SR24 */
+			0xFF, 0xBE, 0xEF, 0xFF, 0x00, 0x0E, 0x17, 0x2C,
+			0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0xC4, 0x30, 0x02, 0x01, 0x01,
+		},
+		{   /*  Init_SR30_SR75 */
+			0x32, 0x03, 0xA0, 0x09, 0xC0, 0x32, 0x32, 0x32,
+			0x32, 0x32, 0x32, 0x32, 0x00, 0x00, 0x03, 0xFF,
+			0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+			0x20, 0x0C, 0x44, 0x20, 0x00, 0x32, 0x32, 0x32,
+			0x04, 0x24, 0x63, 0x4F, 0x52, 0x0B, 0xDF, 0xEA,
+			0x04, 0x50, 0x19, 0x32, 0x32, 0x00, 0x00, 0x32,
+			0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+			0x50, 0x03, 0x74, 0x14, 0x07, 0x82, 0x07, 0x04,
+			0x00, 0x45, 0x30, 0x30, 0x40, 0x30,
+		},
+		{   /*  Init_SR80_SR93 */
+			0xFF, 0x07, 0x00, 0x6F, 0x7F, 0x7F, 0xFF, 0x32,
+			0xF7, 0x00, 0x00, 0x00, 0xEF, 0xFF, 0x32, 0x32,
+			0x00, 0x00, 0x00, 0x00,
+		},
+		{   /*  Init_SRA0_SRAF */
+			0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xED, 0xED, 0xED,
+			0x7B, 0xFF, 0xFF, 0xFF, 0xBF, 0xEF, 0xFF, 0xDF,
+		},
+		{   /*  Init_GR00_GR08 */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+			0xFF,
+		},
+		{   /*  Init_AR00_AR14 */
+			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+			0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+			0x41, 0x00, 0x0F, 0x00, 0x00,
+		},
+		{   /*  Init_CR00_CR18 */
+			0x5F, 0x4F, 0x4F, 0x00, 0x53, 0x1F, 0x0B, 0x3E,
+			0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0xEA, 0x0C, 0xDF, 0x50, 0x40, 0xDF, 0x00, 0xE3,
+			0xFF,
+		},
+		{   /*  Init_CR30_CR4D */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x03, 0x20,
+			0x00, 0x00, 0x00, 0x40, 0x00, 0xE7, 0xFF, 0xFD,
+			0x5F, 0x4F, 0x00, 0x54, 0x00, 0x0B, 0xDF, 0x00,
+			0xEA, 0x0C, 0x2E, 0x00, 0x4F, 0xDF,
+		},
+		{   /*  Init_CR90_CRA7 */
+			0x56, 0xDD, 0x5E, 0xEA, 0x87, 0x44, 0x8F, 0x55,
+			0x0A, 0x8F, 0x55, 0x0A, 0x00, 0x00, 0x18, 0x00,
+			0x11, 0x10, 0x0B, 0x0A, 0x0A, 0x0A, 0x0A, 0x00,
+		},
+	},
+
+	{/*  mode#2: 800 x 600  16Bpp  60Hz */
+		800, 600, 16, 60,
+		/*  Init_MISC */
+		0x2B,
+		{   /*  Init_SR0_SR4 */
+			0x03, 0x01, 0x0F, 0x03, 0x0E,
+		},
+		{   /*  Init_SR10_SR24 */
+			0xFF, 0xBE, 0xEE, 0xFF, 0x00, 0x0E, 0x17, 0x2C,
+			0x99, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0xC4, 0x30, 0x02, 0x01, 0x01,
+		},
+		{   /*  Init_SR30_SR75 */
+			0x34, 0x03, 0x20, 0x09, 0xC0, 0x24, 0x24, 0x24,
+			0x24, 0x24, 0x24, 0x24, 0x00, 0x00, 0x03, 0xFF,
+			0x00, 0xFC, 0x00, 0x00, 0x20, 0x38, 0x00, 0xFC,
+			0x20, 0x0C, 0x44, 0x20, 0x00, 0x24, 0x24, 0x24,
+			0x04, 0x48, 0x83, 0x63, 0x68, 0x72, 0x57, 0x58,
+			0x04, 0x55, 0x59, 0x24, 0x24, 0x00, 0x00, 0x24,
+			0x01, 0x80, 0x7A, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+			0x50, 0x03, 0x74, 0x14, 0x1C, 0x85, 0x35, 0x13,
+			0x02, 0x45, 0x30, 0x35, 0x40, 0x20,
+		},
+		{   /*  Init_SR80_SR93 */
+			0x00, 0x00, 0x00, 0x6F, 0x7F, 0x7F, 0xFF, 0x24,
+			0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x24, 0x24,
+			0x00, 0x00, 0x00, 0x00,
+		},
+		{   /*  Init_SRA0_SRAF */
+			0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xED, 0xED, 0xED,
+			0x7B, 0xFF, 0xFF, 0xFF, 0xBF, 0xEF, 0xBF, 0xDF,
+		},
+		{   /*  Init_GR00_GR08 */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+			0xFF,
+		},
+		{   /*  Init_AR00_AR14 */
+			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+			0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+			0x41, 0x00, 0x0F, 0x00, 0x00,
+		},
+		{   /*  Init_CR00_CR18 */
+			0x7F, 0x63, 0x63, 0x00, 0x68, 0x18, 0x72, 0xF0,
+			0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x58, 0x0C, 0x57, 0x64, 0x40, 0x57, 0x00, 0xE3,
+			0xFF,
+ 		},
+		{   /*  Init_CR30_CR4D */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x03, 0x20,
+			0x00, 0x00, 0x00, 0x40, 0x00, 0xE7, 0xBF, 0xFD,
+			0x7F, 0x63, 0x00, 0x69, 0x18, 0x72, 0x57, 0x00,
+			0x58, 0x0C, 0xE0, 0x20, 0x63, 0x57,
+		},
+		{   /*  Init_CR90_CRA7 */
+			0x56, 0x4B, 0x5E, 0x55, 0x86, 0x9D, 0x8E, 0xAA,
+			0xDB, 0x2A, 0xDF, 0x33, 0x00, 0x00, 0x18, 0x00,
+			0x20, 0x1F, 0x1A, 0x19, 0x0F, 0x0F, 0x0F, 0x00,
+		},
+	},
+		{/*  mode#3: 800 x 600  24Bpp  60Hz */
+		800,600,24,60,
+		0x2B,
+		{   /*  Init_SR0_SR4 */
+			0x03, 0x01, 0x0F, 0x03, 0x0E,
+		},
+		{   /*  Init_SR10_SR24 */
+			0xFF, 0xBE, 0xEE, 0xFF, 0x00, 0x0E, 0x17, 0x2C,
+			0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0xC4, 0x30, 0x02, 0x01, 0x01,
+		},
+		{   /*  Init_SR30_SR75 */
+			0x36, 0x03, 0x20, 0x09, 0xC0, 0x36, 0x36, 0x36,
+			0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x03, 0xFF,
+			0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+			0x20, 0x0C, 0x44, 0x20, 0x00, 0x36, 0x36, 0x36,
+			0x04, 0x48, 0x83, 0x63, 0x68, 0x72, 0x57, 0x58,
+			0x04, 0x55, 0x59, 0x36, 0x36, 0x00, 0x00, 0x36,
+			0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+			0x50, 0x03, 0x74, 0x14, 0x1C, 0x85, 0x35, 0x13,
+			0x02, 0x45, 0x30, 0x30, 0x40, 0x20,
+		},
+		{   /*  Init_SR80_SR93 */
+			0xFF, 0x07, 0x00, 0x6F, 0x7F, 0x7F, 0xFF, 0x36,
+			0xF7, 0x00, 0x00, 0x00, 0xEF, 0xFF, 0x36, 0x36,
+			0x00, 0x00, 0x00, 0x00,
+		},
+		{   /*  Init_SRA0_SRAF */
+			0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xED, 0xED, 0xED,
+			0x7B, 0xFF, 0xFF, 0xFF, 0xBF, 0xEF, 0xBF, 0xDF,
+		},
+		{   /*  Init_GR00_GR08 */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+			0xFF,
+		},
+		{   /*  Init_AR00_AR14 */
+			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+			0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+			0x41, 0x00, 0x0F, 0x00, 0x00,
+		},
+		{   /*  Init_CR00_CR18 */
+			0x7F, 0x63, 0x63, 0x00, 0x68, 0x18, 0x72, 0xF0,
+			0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x58, 0x0C, 0x57, 0x64, 0x40, 0x57, 0x00, 0xE3,
+			0xFF,
+		},
+		{   /*  Init_CR30_CR4D */
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x03, 0x20,
+			0x00, 0x00, 0x00, 0x40, 0x00, 0xE7, 0xBF, 0xFD,
+			0x7F, 0x63, 0x00, 0x69, 0x18, 0x72, 0x57, 0x00,
+			0x58, 0x0C, 0xE0, 0x20, 0x63, 0x57,
+		},
+		{   /*  Init_CR90_CRA7 */
+			0x56, 0x4B, 0x5E, 0x55, 0x86, 0x9D, 0x8E, 0xAA,
+			0xDB, 0x2A, 0xDF, 0x33, 0x00, 0x00, 0x18, 0x00,
+			0x20, 0x1F, 0x1A, 0x19, 0x0F, 0x0F, 0x0F, 0x00,
+		},
+	},
+	{/*  mode#7: 800 x 600  32Bpp  60Hz */
+                800, 600, 32, 60,
+                /*  Init_MISC */
+                0x2B,
+                {   /*  Init_SR0_SR4 */
+                        0x03, 0x01, 0x0F, 0x03, 0x0E,
+                },
+                {   /*  Init_SR10_SR24 */
+                        0xFF, 0xBE, 0xEE, 0xFF, 0x00, 0x0E, 0x17, 0x2C,
+                        0x99, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+                        0xC4, 0x30, 0x02, 0x01, 0x01,
+                },
+                {   /*  Init_SR30_SR75 */
+                        0x34, 0x03, 0x20, 0x09, 0xC0, 0x24, 0x24, 0x24,
+                        0x24, 0x24, 0x24, 0x24, 0x00, 0x00, 0x03, 0xFF,
+                        0x00, 0xFC, 0x00, 0x00, 0x20, 0x38, 0x00, 0xFC,
+                        0x20, 0x0C, 0x44, 0x20, 0x00, 0x24, 0x24, 0x24,
+                        0x04, 0x48, 0x83, 0x63, 0x68, 0x72, 0x57, 0x58,
+                        0x04, 0x55, 0x59, 0x24, 0x24, 0x00, 0x00, 0x24,
+                        0x01, 0x80, 0x7A, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+                        0x50, 0x03, 0x74, 0x14, 0x1C, 0x85, 0x35, 0x13,
+                        0x02, 0x45, 0x30, 0x35, 0x40, 0x20,
+                },
+                {   /*  Init_SR80_SR93 */
+                        0x00, 0x00, 0x00, 0x6F, 0x7F, 0x7F, 0xFF, 0x24,
+                        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x24, 0x24,
+                        0x00, 0x00, 0x00, 0x00,
+                },
+                {   /*  Init_SRA0_SRAF */
+                        0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xED, 0xED, 0xED,
+                        0x7B, 0xFF, 0xFF, 0xFF, 0xBF, 0xEF, 0xBF, 0xDF,
+                },
+                {   /*  Init_GR00_GR08 */
+                        0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+                        0xFF,
+                },
+                {   /*  Init_AR00_AR14 */
+                        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+                        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+                        0x41, 0x00, 0x0F, 0x00, 0x00,
+                },
+                {   /*  Init_CR00_CR18 */
+                        0x7F, 0x63, 0x63, 0x00, 0x68, 0x18, 0x72, 0xF0,
+                        0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                        0x58, 0x0C, 0x57, 0x64, 0x40, 0x57, 0x00, 0xE3,
+                        0xFF,
+                },
+                {   /*  Init_CR30_CR4D */
+                        0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x03, 0x20,
+                        0x00, 0x00, 0x00, 0x40, 0x00, 0xE7, 0xBF, 0xFD,
+                        0x7F, 0x63, 0x00, 0x69, 0x18, 0x72, 0x57, 0x00,
+                        0x58, 0x0C, 0xE0, 0x20, 0x63, 0x57,
+                },
+                {   /*  Init_CR90_CRA7 */
+                        0x56, 0x4B, 0x5E, 0x55, 0x86, 0x9D, 0x8E, 0xAA,
+                        0xDB, 0x2A, 0xDF, 0x33, 0x00, 0x00, 0x18, 0x00,
+                        0x20, 0x1F, 0x1A, 0x19, 0x0F, 0x0F, 0x0F, 0x00,
+		},
+	},
+
+    { /*  mode#4: 1024 x 600  16Bpp  60Hz  We use 1024x768 table to light 1024x600 panel for lemote*/ 
+        1024,600,16,60,
+	/*  Init_MISC */                                    
+		0xEB,                                               
+		{   /*  Init_SR0_SR4 */                             
+			0x03, 0x01, 0x0F, 0x00, 0x0E,                   
+		},                                                  
+		{   /*  Init_SR10_SR24 */                           
+			0xC8, 0x40, 0x14, 0x60, 0x00, 0x0A, 0x17, 0x20, 
+			0x51, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
+			0xC4, 0x30, 0x02, 0x00, 0x01,                   
+		},                                                  
+		{   /*  Init_SR30_SR75 */                           
+			0x22, 0x03, 0x24, 0x09, 0xC0, 0x22, 0x22, 0x22, 
+			0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x03, 0xFF, 
+			0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC, 
+			0x20, 0x0C, 0x44, 0x20, 0x00, 0x22, 0x22, 0x22, 
+			0x06, 0x68, 0xA7, 0x7F, 0x83, 0x24, 0xFF, 0x03, 
+			0x00, 0x60, 0x59, 0x22, 0x22, 0x00, 0x00, 0x22, 
+			0x01, 0x80, 0x7A, 0x1A, 0x1A, 0x00, 0x00, 0x00, 
+			0x50, 0x03, 0x16, 0x02, 0x0D, 0x82, 0x09, 0x02, 
+			0x04, 0x45, 0x3F, 0x30, 0x40, 0x20,             
+		},                                                  
+		{   /*  Init_SR80_SR93 */                           
+			0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x3A, 
+			0xF7, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3A, 0x3A, 
+			0x00, 0x00, 0x00, 0x00,                         
+		},                                                  
+		{   /*  Init_SRA0_SRAF */                           
+			0x00, 0xFB, 0x9F, 0x01, 0x00, 0xED, 0xED, 0xED, 
+			0x7B, 0xFB, 0xFF, 0xFF, 0x97, 0xEF, 0xBF, 0xDF, 
+		},                                                  
+		{   /*  Init_GR00_GR08 */                           
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 
+			0xFF,                                           
+		},                                                  
+		{   /*  Init_AR00_AR14 */                           
+			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
+			0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
+			0x41, 0x00, 0x0F, 0x00, 0x00,                   
+		},                                                  
+		{   /*  Init_CR00_CR18 */                           
+			0xA3, 0x7F, 0x7F, 0x00, 0x85, 0x16, 0x24, 0xF5, 
+			0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+			0x03, 0x09, 0xFF, 0x80, 0x40, 0xFF, 0x00, 0xE3, 
+			0xFF,                                           
+		},                                                  
+		{   /*  Init_CR30_CR4D */                           
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x20, 
+			0x00, 0x00, 0x00, 0x40, 0x00, 0xFF, 0xBF, 0xFF, 
+			0xA3, 0x7F, 0x00, 0x82, 0x0b, 0x6f, 0x57, 0x00, 
+			0x5c, 0x0f, 0xE0, 0xe0, 0x7F, 0x57,             
+		},                                                  
+		{   /*  Init_CR90_CRA7 */                           
+			0x55, 0xD9, 0x5D, 0xE1, 0x86, 0x1B, 0x8E, 0x26, 
+			0xDA, 0x8D, 0xDE, 0x94, 0x00, 0x00, 0x18, 0x00, 
+			0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x15, 0x03, 
+		},                                                  
+	},                                                       
+	{  /*  mode#5: 1024 x 768  24Bpp  60Hz */               
+        1024,768,24,60,
+			/*  Init_MISC */                                
+		0xEB,                                               
+		{   /*  Init_SR0_SR4 */                             
+			0x03, 0x01, 0x0F, 0x03, 0x0E,                   
+		},                                                  
+		{   /*  Init_SR10_SR24 */                           
+			0xF3, 0xB6, 0xC0, 0xDD, 0x00, 0x0E, 0x17, 0x2C, 
+			0x99, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
+			0xC4, 0x30, 0x02, 0x01, 0x01,                   
+		},                                                  
+		{   /*  Init_SR30_SR75 */                           
+			0x38, 0x03, 0x20, 0x09, 0xC0, 0x3A, 0x3A, 0x3A, 
+			0x3A, 0x3A, 0x3A, 0x3A, 0x00, 0x00, 0x03, 0xFF, 
+			0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC, 
+			0x20, 0x0C, 0x44, 0x20, 0x00, 0x00, 0x00, 0x3A, 
+			0x06, 0x68, 0xA7, 0x7F, 0x83, 0x24, 0xFF, 0x03, 
+			0x00, 0x60, 0x59, 0x3A, 0x3A, 0x00, 0x00, 0x3A, 
+			0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00, 
+			0x50, 0x03, 0x74, 0x14, 0x3B, 0x0D, 0x09, 0x02, 
+			0x04, 0x45, 0x30, 0x30, 0x40, 0x20,             
+		},                                                  
+		{   /*  Init_SR80_SR93 */                           
+			0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x3A, 
+			0xF7, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3A, 0x3A, 
+			0x00, 0x00, 0x00, 0x00,                         
+		},                                                  
+		{   /*  Init_SRA0_SRAF */                           
+			0x00, 0xFB, 0x9F, 0x01, 0x00, 0xED, 0xED, 0xED, 
+			0x7B, 0xFB, 0xFF, 0xFF, 0x97, 0xEF, 0xBF, 0xDF, 
+		},                                                  
+		{   /*  Init_GR00_GR08 */                           
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 
+			0xFF,                                           
+		},                                                  
+		{   /*  Init_AR00_AR14 */                           
+			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
+			0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
+			0x41, 0x00, 0x0F, 0x00, 0x00,                   
+		},                                                  
+		{   /*  Init_CR00_CR18 */                           
+			0xA3, 0x7F, 0x7F, 0x00, 0x85, 0x16, 0x24, 0xF5, 
+			0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+			0x03, 0x09, 0xFF, 0x80, 0x40, 0xFF, 0x00, 0xE3, 
+			0xFF,                                           
+		},                                                  
+		{   /*  Init_CR30_CR4D */                           
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x20, 
+			0x00, 0x00, 0x00, 0x40, 0x00, 0xFF, 0xBF, 0xFF, 
+			0xA3, 0x7F, 0x00, 0x86, 0x15, 0x24, 0xFF, 0x00, 
+			0x01, 0x07, 0xE5, 0x20, 0x7F, 0xFF,             
+		},                                                  
+		{   /*  Init_CR90_CRA7 */                           
+			0x55, 0xD9, 0x5D, 0xE1, 0x86, 0x1B, 0x8E, 0x26, 
+			0xDA, 0x8D, 0xDE, 0x94, 0x00, 0x00, 0x18, 0x00, 
+			0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x15, 0x03, 
+		},                                                  
+	},
+	{ /*  mode#4: 1024 x 768  32Bpp  60Hz */ 
+        1024,768,32,60,
+		/*  Init_MISC */                                    
+		0xEB,                                               
+		{   /*  Init_SR0_SR4 */                             
+			0x03, 0x01, 0x0F, 0x03, 0x0E,                   
+		},                                                  
+		{   /*  Init_SR10_SR24 */                           
+			0xF3, 0xB6, 0xC0, 0xDD, 0x00, 0x0E, 0x17, 0x2C, 
+			0x99, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
+			0xC4, 0x32, 0x02, 0x01, 0x01,                   
+		},                                                  
+		{   /*  Init_SR30_SR75 */                           
+			0x38, 0x03, 0x20, 0x09, 0xC0, 0x3A, 0x3A, 0x3A, 
+			0x3A, 0x3A, 0x3A, 0x3A, 0x00, 0x00, 0x03, 0xFF, 
+			0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC, 
+			0x20, 0x0C, 0x44, 0x20, 0x00, 0x00, 0x00, 0x3A, 
+			0x06, 0x68, 0xA7, 0x7F, 0x83, 0x24, 0xFF, 0x03, 
+			0x00, 0x60, 0x59, 0x3A, 0x3A, 0x00, 0x00, 0x3A, 
+			0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00, 
+			0x50, 0x03, 0x74, 0x14, 0x3B, 0x0D, 0x09, 0x02, 
+			0x04, 0x45, 0x30, 0x30, 0x40, 0x20,             
+		},                                                  
+		{   /*  Init_SR80_SR93 */                           
+			0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x3A, 
+			0xF7, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3A, 0x3A, 
+			0x00, 0x00, 0x00, 0x00,                         
+		},                                                  
+		{   /*  Init_SRA0_SRAF */                           
+			0x00, 0xFB, 0x9F, 0x01, 0x00, 0xED, 0xED, 0xED, 
+			0x7B, 0xFB, 0xFF, 0xFF, 0x97, 0xEF, 0xBF, 0xDF, 
+		},                                                  
+		{   /*  Init_GR00_GR08 */                           
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 
+			0xFF,                                           
+		},                                                  
+		{   /*  Init_AR00_AR14 */                           
+			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
+			0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
+			0x41, 0x00, 0x0F, 0x00, 0x00,                   
+		},                                                  
+		{   /*  Init_CR00_CR18 */                           
+			0xA3, 0x7F, 0x7F, 0x00, 0x85, 0x16, 0x24, 0xF5, 
+			0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+			0x03, 0x09, 0xFF, 0x80, 0x40, 0xFF, 0x00, 0xE3, 
+			0xFF,                                           
+		},                                                  
+		{   /*  Init_CR30_CR4D */                           
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x20, 
+			0x00, 0x00, 0x00, 0x40, 0x00, 0xFF, 0xBF, 0xFF, 
+			0xA3, 0x7F, 0x00, 0x86, 0x15, 0x24, 0xFF, 0x00, 
+			0x01, 0x07, 0xE5, 0x20, 0x7F, 0xFF,             
+		},                                                  
+		{   /*  Init_CR90_CRA7 */                           
+			0x55, 0xD9, 0x5D, 0xE1, 0x86, 0x1B, 0x8E, 0x26, 
+			0xDA, 0x8D, 0xDE, 0x94, 0x00, 0x00, 0x18, 0x00, 
+			0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x15, 0x03, 
+		},                                                  
+	},
+	{ /*  mode#6: 320 x 240  16Bpp  60Hz */
+        320,240,16,60,
+                /*  Init_MISC */
+                0xEB,
+                {   /*  Init_SR0_SR4 */
+                        0x03, 0x01, 0x0F, 0x03, 0x0E,
+                },
+                {   /*  Init_SR10_SR24 */
+                        0xF3, 0xB6, 0xC0, 0xDD, 0x00, 0x0E, 0x17, 0x2C,
+                        0x99, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+                        0xC4, 0x32, 0x02, 0x01, 0x01,
+                },
+                {   /*  Init_SR30_SR75 */
+                        0x38, 0x03, 0x20, 0x09, 0xC0, 0x3A, 0x3A, 0x3A,
+                        0x3A, 0x3A, 0x3A, 0x3A, 0x00, 0x00, 0x03, 0xFF,
+                        0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+                        0x20, 0x0C, 0x44, 0x20, 0x00, 0x00, 0x00, 0x3A,
+                        0x06, 0x68, 0xA7, 0x7F, 0x83, 0x24, 0xFF, 0x03,
+                        0x00, 0x60, 0x59, 0x3A, 0x3A, 0x00, 0x00, 0x3A,
+                        0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+                        0x50, 0x03, 0x74, 0x14, 0x08, 0x43, 0x08, 0x43,
+                        0x04, 0x45, 0x30, 0x30, 0x40, 0x20,
+                },
+                {   /*  Init_SR80_SR93 */
+                        0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x3A,
+                        0xF7, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3A, 0x3A,
+                        0x00, 0x00, 0x00, 0x00,
+                },
+                {   /*  Init_SRA0_SRAF */
+                        0x00, 0xFB, 0x9F, 0x01, 0x00, 0xED, 0xED, 0xED,
+                        0x7B, 0xFB, 0xFF, 0xFF, 0x97, 0xEF, 0xBF, 0xDF,
+                },
+                {   /*  Init_GR00_GR08 */
+                        0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+                        0xFF,
+                },
+                {   /*  Init_AR00_AR14 */
+                        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+                        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+                        0x41, 0x00, 0x0F, 0x00, 0x00,
+                },
+                {   /*  Init_CR00_CR18 */
+                        0xA3, 0x7F, 0x7F, 0x00, 0x85, 0x16, 0x24, 0xF5,
+                        0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                        0x03, 0x09, 0xFF, 0x80, 0x40, 0xFF, 0x00, 0xE3,
+                        0xFF,
+                },
+                {   /*  Init_CR30_CR4D */
+                        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x20,
+                        0x00, 0x00, 0x30, 0x40, 0x00, 0xFF, 0xBF, 0xFF,
+                        0x2E, 0x27, 0x00, 0x2b, 0x0c, 0x0F, 0xEF, 0x00,
+                        0xFe, 0x0f, 0x01, 0xC0, 0x27, 0xEF,
+                },
+                {   /*  Init_CR90_CRA7 */
+                        0x55, 0xD9, 0x5D, 0xE1, 0x86, 0x1B, 0x8E, 0x26,
+                        0xDA, 0x8D, 0xDE, 0x94, 0x00, 0x00, 0x18, 0x00,
+                        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x15, 0x03,
+                },
+        },
+	
+	{ /*  mode#8: 320 x 240  32Bpp  60Hz */
+        320,240,32,60,
+                /*  Init_MISC */
+                0xEB,
+                {   /*  Init_SR0_SR4 */
+                        0x03, 0x01, 0x0F, 0x03, 0x0E,
+                },
+                {   /*  Init_SR10_SR24 */
+                        0xF3, 0xB6, 0xC0, 0xDD, 0x00, 0x0E, 0x17, 0x2C,
+                        0x99, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+                        0xC4, 0x32, 0x02, 0x01, 0x01,
+                },
+                {   /*  Init_SR30_SR75 */
+                        0x38, 0x03, 0x20, 0x09, 0xC0, 0x3A, 0x3A, 0x3A,
+                        0x3A, 0x3A, 0x3A, 0x3A, 0x00, 0x00, 0x03, 0xFF,
+                        0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+                        0x20, 0x0C, 0x44, 0x20, 0x00, 0x00, 0x00, 0x3A,
+                        0x06, 0x68, 0xA7, 0x7F, 0x83, 0x24, 0xFF, 0x03,
+                        0x00, 0x60, 0x59, 0x3A, 0x3A, 0x00, 0x00, 0x3A,
+                        0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+                        0x50, 0x03, 0x74, 0x14, 0x08, 0x43, 0x08, 0x43,
+                        0x04, 0x45, 0x30, 0x30, 0x40, 0x20,
+                },
+                {   /*  Init_SR80_SR93 */
+                        0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x3A,
+                        0xF7, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3A, 0x3A,
+                        0x00, 0x00, 0x00, 0x00,
+                },
+                {   /*  Init_SRA0_SRAF */
+                        0x00, 0xFB, 0x9F, 0x01, 0x00, 0xED, 0xED, 0xED,
+                        0x7B, 0xFB, 0xFF, 0xFF, 0x97, 0xEF, 0xBF, 0xDF,
+                },
+                {   /*  Init_GR00_GR08 */
+                        0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+                        0xFF,
+                },
+                {   /*  Init_AR00_AR14 */
+                        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+                        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+                        0x41, 0x00, 0x0F, 0x00, 0x00,
+                },
+                {   /*  Init_CR00_CR18 */
+                        0xA3, 0x7F, 0x7F, 0x00, 0x85, 0x16, 0x24, 0xF5,
+                        0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                        0x03, 0x09, 0xFF, 0x80, 0x40, 0xFF, 0x00, 0xE3,
+                        0xFF,
+                },
+                {   /*  Init_CR30_CR4D */
+                        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x20,
+                        0x00, 0x00, 0x30, 0x40, 0x00, 0xFF, 0xBF, 0xFF,
+                        0x2E, 0x27, 0x00, 0x2b, 0x0c, 0x0F, 0xEF, 0x00,
+                        0xFe, 0x0f, 0x01, 0xC0, 0x27, 0xEF,
+                },
+                {   /*  Init_CR90_CRA7 */
+                        0x55, 0xD9, 0x5D, 0xE1, 0x86, 0x1B, 0x8E, 0x26,
+                        0xDA, 0x8D, 0xDE, 0x94, 0x00, 0x00, 0x18, 0x00,
+                        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x15, 0x03,
+                },
+        },
+};
+
+#define numVGAModes			sizeof(VGAMode)/sizeof(struct ModeInit)
+
diff -Nur linux-2.6.29.1/include/linux/suspend.h linux-2.6.29.1-lemote/include/linux/suspend.h
--- linux-2.6.29.1/include/linux/suspend.h	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/include/linux/suspend.h	2009-04-07 09:39:28.000000000 +0000
@@ -1,7 +1,7 @@
 #ifndef _LINUX_SUSPEND_H
 #define _LINUX_SUSPEND_H
 
-#if defined(CONFIG_X86) || defined(CONFIG_FRV) || defined(CONFIG_PPC32) || defined(CONFIG_PPC64)
+#if defined(CONFIG_X86) || defined(CONFIG_FRV) || defined(CONFIG_PPC32) || defined(CONFIG_PPC64) || defined(CONFIG_MIPS)
 #include <asm/suspend.h>
 #endif
 #include <linux/swap.h>
diff -Nur linux-2.6.29.1/sound/core/pcm_native.c linux-2.6.29.1-lemote/sound/core/pcm_native.c
--- linux-2.6.29.1/sound/core/pcm_native.c	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/sound/core/pcm_native.c	2009-04-07 09:39:28.000000000 +0000
@@ -3099,7 +3099,11 @@
 			return VM_FAULT_SIGBUS;
 	} else {
 		vaddr = runtime->dma_area + offset;
+#if defined(__mips__) && defined(CONFIG_DMA_NONCOHERENT)
+		page = virt_to_page(CAC_ADDR(vaddr));
+#else
 		page = virt_to_page(vaddr);
+#endif
 	}
 	get_page(page);
 	vmf->page = page;
@@ -3214,6 +3218,11 @@
 	if (PCM_RUNTIME_CHECK(substream))
 		return -ENXIO;
 
+#if defined(__mips__) && defined(CONFIG_DMA_NONCOHERENT)	
+	/* all mmap using uncached mode */
+	area->vm_page_prot = pgprot_noncached(area->vm_page_prot);
+	area->vm_flags |= ( VM_RESERVED | VM_IO);
+#endif
 	offset = area->vm_pgoff << PAGE_SHIFT;
 	switch (offset) {
 	case SNDRV_PCM_MMAP_OFFSET_STATUS:
diff -Nur linux-2.6.29.1/sound/core/sgbuf.c linux-2.6.29.1-lemote/sound/core/sgbuf.c
--- linux-2.6.29.1/sound/core/sgbuf.c	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/sound/core/sgbuf.c	2009-04-07 09:39:28.000000000 +0000
@@ -114,7 +114,11 @@
 			if (!i)
 				table->addr |= chunk; /* mark head */
 			table++;
+#if defined(__mips__) && defined(CONFIG_DMA_NONCOHERENT)
+			*pgtable++ = virt_to_page(CAC_ADDR(tmpb.area));
+#else
 			*pgtable++ = virt_to_page(tmpb.area);
+#endif
 			tmpb.area += PAGE_SIZE;
 			tmpb.addr += PAGE_SIZE;
 		}
@@ -125,7 +129,11 @@
 	}
 
 	sgbuf->size = size;
+#if defined(__mips__) && defined(CONFIG_DMA_NONCOHERENT)
+	dmab->area = vmap(sgbuf->page_table, sgbuf->pages, VM_MAP | VM_IO, pgprot_noncached(PAGE_KERNEL));
+#else
 	dmab->area = vmap(sgbuf->page_table, sgbuf->pages, VM_MAP, PAGE_KERNEL);
+#endif
 	if (! dmab->area)
 		goto _failed;
 	if (res_size)
diff -Nur linux-2.6.29.1/sound/pci/Kconfig linux-2.6.29.1-lemote/sound/pci/Kconfig
--- linux-2.6.29.1/sound/pci/Kconfig	2009-04-02 20:55:27.000000000 +0000
+++ linux-2.6.29.1-lemote/sound/pci/Kconfig	2009-04-07 09:39:28.000000000 +0000
@@ -259,7 +259,6 @@
 
 config SND_CS5535AUDIO
 	tristate "CS5535/CS5536 Audio"
-	depends on X86 && !X86_64
 	select SND_PCM
 	select SND_AC97_CODEC
 	help
