diff -Nur kexec-tools-1.101/AUTHORS kexec-tools-1.101-geoff/AUTHORS
--- kexec-tools-1.101/AUTHORS	2004-12-20 17:33:50.000000000 +0600
+++ kexec-tools-1.101-geoff/AUTHORS	2007-10-23 16:24:40.000000000 +0700
@@ -3,4 +3,11 @@
 Jesse Barnes <jbarnes@sgi.com>
 Khalid Aziz <khalid.aziz@hp.com>
 Hariprasad Nellitheertha <hari@in.ibm.com>
-Tim Deegan <tjd21@cl.cam.ac.uk>
\ В конце файла нет новой строки
+Tim Deegan <tjd21@cl.cam.ac.uk>
+And others...
+
+Currently maintained by
+P:      Simon Horman
+M:      horms@verge.net.au
+L:      fastboot@lists.osdl.org
+
diff -Nur kexec-tools-1.101/configure kexec-tools-1.101-geoff/configure
--- kexec-tools-1.101/configure	2005-02-16 18:37:44.000000000 +0600
+++ kexec-tools-1.101-geoff/configure	1970-01-01 07:00:00.000000000 +0700
@@ -1,4840 +0,0 @@
-#! /bin/sh
-# Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.59.
-#
-# Copyright (C) 2003 Free Software Foundation, Inc.
-# This configure script is free software; the Free Software Foundation
-# gives unlimited permission to copy, distribute and modify it.
-## --------------------- ##
-## M4sh Initialization.  ##
-## --------------------- ##
-
-# Be Bourne compatible
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
-  emulate sh
-  NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
-  set -o posix
-fi
-DUALCASE=1; export DUALCASE # for MKS sh
-
-# Support unset when possible.
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
-  as_unset=unset
-else
-  as_unset=false
-fi
-
-
-# Work around bugs in pre-3.0 UWIN ksh.
-$as_unset ENV MAIL MAILPATH
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-for as_var in \
-  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
-  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
-  LC_TELEPHONE LC_TIME
-do
-  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
-    eval $as_var=C; export $as_var
-  else
-    $as_unset $as_var
-  fi
-done
-
-# Required to use basename.
-if expr a : '\(a\)' >/dev/null 2>&1; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-
-# Name of the executable.
-as_me=`$as_basename "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)$' \| \
-	 .     : '\(.\)' 2>/dev/null ||
-echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
-  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\/\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-
-
-# PATH needs CR, and LINENO needs CR and PATH.
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  echo "#! /bin/sh" >conf$$.sh
-  echo  "exit 0"   >>conf$$.sh
-  chmod +x conf$$.sh
-  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
-    PATH_SEPARATOR=';'
-  else
-    PATH_SEPARATOR=:
-  fi
-  rm -f conf$$.sh
-fi
-
-
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
-  # Find who we are.  Look in the path if we contain no path at all
-  # relative or not.
-  case $0 in
-    *[\\/]* ) as_myself=$0 ;;
-    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-done
-
-       ;;
-  esac
-  # We did not find ourselves, most probably we were run as `sh COMMAND'
-  # in which case we are not to be found in the path.
-  if test "x$as_myself" = x; then
-    as_myself=$0
-  fi
-  if test ! -f "$as_myself"; then
-    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
-   { (exit 1); exit 1; }; }
-  fi
-  case $CONFIG_SHELL in
-  '')
-    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for as_base in sh bash ksh sh5; do
-	 case $as_dir in
-	 /*)
-	   if ("$as_dir/$as_base" -c '
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
-	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
-	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
-	     CONFIG_SHELL=$as_dir/$as_base
-	     export CONFIG_SHELL
-	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
-	   fi;;
-	 esac
-       done
-done
-;;
-  esac
-
-  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
-  # uniformly replaced by the line number.  The first 'sed' inserts a
-  # line-number line before each line; the second 'sed' does the real
-  # work.  The second script uses 'N' to pair each line-number line
-  # with the numbered line, and appends trailing '-' during
-  # substitution so that $LINENO is not a special case at line end.
-  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
-  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
-  sed '=' <$as_myself |
-    sed '
-      N
-      s,$,-,
-      : loop
-      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
-      t loop
-      s,-$,,
-      s,^['$as_cr_digits']*\n,,
-    ' >$as_me.lineno &&
-  chmod +x $as_me.lineno ||
-    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
-   { (exit 1); exit 1; }; }
-
-  # Don't try to exec as it changes $[0], causing all sort of problems
-  # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensible to this).
-  . ./$as_me.lineno
-  # Exit status is that of the last command.
-  exit
-}
-
-
-case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
-  *c*,-n*) ECHO_N= ECHO_C='
-' ECHO_T='	' ;;
-  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
-  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
-esac
-
-if expr a : '\(a\)' >/dev/null 2>&1; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-rm -f conf$$ conf$$.exe conf$$.file
-echo >conf$$.file
-if ln -s conf$$.file conf$$ 2>/dev/null; then
-  # We could just check for DJGPP; but this test a) works b) is more generic
-  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
-  if test -f conf$$.exe; then
-    # Don't use ln at all; we don't have any links
-    as_ln_s='cp -p'
-  else
-    as_ln_s='ln -s'
-  fi
-elif ln conf$$.file conf$$ 2>/dev/null; then
-  as_ln_s=ln
-else
-  as_ln_s='cp -p'
-fi
-rm -f conf$$ conf$$.exe conf$$.file
-
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p=:
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
-fi
-
-as_executable_p="test -f"
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
-
-
-# IFS
-# We need space, tab and new line, in precisely that order.
-as_nl='
-'
-IFS=" 	$as_nl"
-
-# CDPATH.
-$as_unset CDPATH
-
-
-# Name of the host.
-# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
-# so uname gets run too.
-ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
-
-exec 6>&1
-
-#
-# Initializations.
-#
-ac_default_prefix=/usr/local
-ac_config_libobj_dir=.
-cross_compiling=no
-subdirs=
-MFLAGS=
-MAKEFLAGS=
-SHELL=${CONFIG_SHELL-/bin/sh}
-
-# Maximum number of lines to put in a shell here document.
-# This variable seems obsolete.  It should probably be removed, and
-# only ac_max_sed_lines should be used.
-: ${ac_max_here_lines=38}
-
-# Identity of this package.
-PACKAGE_NAME=
-PACKAGE_TARNAME=
-PACKAGE_VERSION=
-PACKAGE_STRING=
-PACKAGE_BUGREPORT=
-
-ac_unique_file="Makefile.conf.in"
-# Factoring default headers for most tests.
-ac_includes_default="\
-#include <stdio.h>
-#if HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-#if HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-#if STDC_HEADERS
-# include <stdlib.h>
-# include <stddef.h>
-#else
-# if HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-#endif
-#if HAVE_STRING_H
-# if !STDC_HEADERS && HAVE_MEMORY_H
-#  include <memory.h>
-# endif
-# include <string.h>
-#endif
-#if HAVE_STRINGS_H
-# include <strings.h>
-#endif
-#if HAVE_INTTYPES_H
-# include <inttypes.h>
-#else
-# if HAVE_STDINT_H
-#  include <stdint.h>
-# endif
-#endif
-#if HAVE_UNISTD_H
-# include <unistd.h>
-#endif"
-
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CPP LD ac_ct_LD AS ac_ct_AS OBJCOPY ac_ct_OBJCOPY AR ac_ct_AR INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA MKDIR RM CP LN TAR RPMBUILD SED FIND XARGS DIRNAME EGREP BUILD_CC BUILD_CFLAGS EXTRA_CFLAGS ARCH OBJDIR INSTALL LIBOBJS LTLIBOBJS'
-ac_subst_files=''
-
-# Initialize some variables set by options.
-ac_init_help=
-ac_init_version=false
-# The variables have the same names as the options, with
-# dashes changed to underlines.
-cache_file=/dev/null
-exec_prefix=NONE
-no_create=
-no_recursion=
-prefix=NONE
-program_prefix=NONE
-program_suffix=NONE
-program_transform_name=s,x,x,
-silent=
-site=
-srcdir=
-verbose=
-x_includes=NONE
-x_libraries=NONE
-
-# Installation directory options.
-# These are left unexpanded so users can "make install exec_prefix=/foo"
-# and all the variables that are supposed to be based on exec_prefix
-# by default will actually change.
-# Use braces instead of parens because sh, perl, etc. also accept them.
-bindir='${exec_prefix}/bin'
-sbindir='${exec_prefix}/sbin'
-libexecdir='${exec_prefix}/libexec'
-datadir='${prefix}/share'
-sysconfdir='${prefix}/etc'
-sharedstatedir='${prefix}/com'
-localstatedir='${prefix}/var'
-libdir='${exec_prefix}/lib'
-includedir='${prefix}/include'
-oldincludedir='/usr/include'
-infodir='${prefix}/info'
-mandir='${prefix}/man'
-
-ac_prev=
-for ac_option
-do
-  # If the previous option needs an argument, assign it.
-  if test -n "$ac_prev"; then
-    eval "$ac_prev=\$ac_option"
-    ac_prev=
-    continue
-  fi
-
-  ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
-
-  # Accept the important Cygnus configure options, so we can diagnose typos.
-
-  case $ac_option in
-
-  -bindir | --bindir | --bindi | --bind | --bin | --bi)
-    ac_prev=bindir ;;
-  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
-    bindir=$ac_optarg ;;
-
-  -build | --build | --buil | --bui | --bu)
-    ac_prev=build_alias ;;
-  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
-    build_alias=$ac_optarg ;;
-
-  -cache-file | --cache-file | --cache-fil | --cache-fi \
-  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
-    ac_prev=cache_file ;;
-  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
-  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
-    cache_file=$ac_optarg ;;
-
-  --config-cache | -C)
-    cache_file=config.cache ;;
-
-  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
-    ac_prev=datadir ;;
-  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
-  | --da=*)
-    datadir=$ac_optarg ;;
-
-  -disable-* | --disable-*)
-    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
-   { (exit 1); exit 1; }; }
-    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
-    eval "enable_$ac_feature=no" ;;
-
-  -enable-* | --enable-*)
-    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
-   { (exit 1); exit 1; }; }
-    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
-    case $ac_option in
-      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
-      *) ac_optarg=yes ;;
-    esac
-    eval "enable_$ac_feature='$ac_optarg'" ;;
-
-  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
-  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
-  | --exec | --exe | --ex)
-    ac_prev=exec_prefix ;;
-  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
-  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
-  | --exec=* | --exe=* | --ex=*)
-    exec_prefix=$ac_optarg ;;
-
-  -gas | --gas | --ga | --g)
-    # Obsolete; use --with-gas.
-    with_gas=yes ;;
-
-  -help | --help | --hel | --he | -h)
-    ac_init_help=long ;;
-  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
-    ac_init_help=recursive ;;
-  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
-    ac_init_help=short ;;
-
-  -host | --host | --hos | --ho)
-    ac_prev=host_alias ;;
-  -host=* | --host=* | --hos=* | --ho=*)
-    host_alias=$ac_optarg ;;
-
-  -includedir | --includedir | --includedi | --included | --include \
-  | --includ | --inclu | --incl | --inc)
-    ac_prev=includedir ;;
-  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
-  | --includ=* | --inclu=* | --incl=* | --inc=*)
-    includedir=$ac_optarg ;;
-
-  -infodir | --infodir | --infodi | --infod | --info | --inf)
-    ac_prev=infodir ;;
-  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
-    infodir=$ac_optarg ;;
-
-  -libdir | --libdir | --libdi | --libd)
-    ac_prev=libdir ;;
-  -libdir=* | --libdir=* | --libdi=* | --libd=*)
-    libdir=$ac_optarg ;;
-
-  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
-  | --libexe | --libex | --libe)
-    ac_prev=libexecdir ;;
-  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
-  | --libexe=* | --libex=* | --libe=*)
-    libexecdir=$ac_optarg ;;
-
-  -localstatedir | --localstatedir | --localstatedi | --localstated \
-  | --localstate | --localstat | --localsta | --localst \
-  | --locals | --local | --loca | --loc | --lo)
-    ac_prev=localstatedir ;;
-  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
-  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
-  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
-    localstatedir=$ac_optarg ;;
-
-  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
-    ac_prev=mandir ;;
-  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
-    mandir=$ac_optarg ;;
-
-  -nfp | --nfp | --nf)
-    # Obsolete; use --without-fp.
-    with_fp=no ;;
-
-  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-  | --no-cr | --no-c | -n)
-    no_create=yes ;;
-
-  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
-    no_recursion=yes ;;
-
-  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
-  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
-  | --oldin | --oldi | --old | --ol | --o)
-    ac_prev=oldincludedir ;;
-  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
-  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
-  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
-    oldincludedir=$ac_optarg ;;
-
-  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
-    ac_prev=prefix ;;
-  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
-    prefix=$ac_optarg ;;
-
-  -program-prefix | --program-prefix | --program-prefi | --program-pref \
-  | --program-pre | --program-pr | --program-p)
-    ac_prev=program_prefix ;;
-  -program-prefix=* | --program-prefix=* | --program-prefi=* \
-  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
-    program_prefix=$ac_optarg ;;
-
-  -program-suffix | --program-suffix | --program-suffi | --program-suff \
-  | --program-suf | --program-su | --program-s)
-    ac_prev=program_suffix ;;
-  -program-suffix=* | --program-suffix=* | --program-suffi=* \
-  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
-    program_suffix=$ac_optarg ;;
-
-  -program-transform-name | --program-transform-name \
-  | --program-transform-nam | --program-transform-na \
-  | --program-transform-n | --program-transform- \
-  | --program-transform | --program-transfor \
-  | --program-transfo | --program-transf \
-  | --program-trans | --program-tran \
-  | --progr-tra | --program-tr | --program-t)
-    ac_prev=program_transform_name ;;
-  -program-transform-name=* | --program-transform-name=* \
-  | --program-transform-nam=* | --program-transform-na=* \
-  | --program-transform-n=* | --program-transform-=* \
-  | --program-transform=* | --program-transfor=* \
-  | --program-transfo=* | --program-transf=* \
-  | --program-trans=* | --program-tran=* \
-  | --progr-tra=* | --program-tr=* | --program-t=*)
-    program_transform_name=$ac_optarg ;;
-
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil)
-    silent=yes ;;
-
-  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
-    ac_prev=sbindir ;;
-  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
-  | --sbi=* | --sb=*)
-    sbindir=$ac_optarg ;;
-
-  -sharedstatedir | --sharedstatedir | --sharedstatedi \
-  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
-  | --sharedst | --shareds | --shared | --share | --shar \
-  | --sha | --sh)
-    ac_prev=sharedstatedir ;;
-  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
-  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
-  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
-  | --sha=* | --sh=*)
-    sharedstatedir=$ac_optarg ;;
-
-  -site | --site | --sit)
-    ac_prev=site ;;
-  -site=* | --site=* | --sit=*)
-    site=$ac_optarg ;;
-
-  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
-    ac_prev=srcdir ;;
-  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
-    srcdir=$ac_optarg ;;
-
-  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
-  | --syscon | --sysco | --sysc | --sys | --sy)
-    ac_prev=sysconfdir ;;
-  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
-  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
-    sysconfdir=$ac_optarg ;;
-
-  -target | --target | --targe | --targ | --tar | --ta | --t)
-    ac_prev=target_alias ;;
-  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
-    target_alias=$ac_optarg ;;
-
-  -v | -verbose | --verbose | --verbos | --verbo | --verb)
-    verbose=yes ;;
-
-  -version | --version | --versio | --versi | --vers | -V)
-    ac_init_version=: ;;
-
-  -with-* | --with-*)
-    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid package name: $ac_package" >&2
-   { (exit 1); exit 1; }; }
-    ac_package=`echo $ac_package| sed 's/-/_/g'`
-    case $ac_option in
-      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
-      *) ac_optarg=yes ;;
-    esac
-    eval "with_$ac_package='$ac_optarg'" ;;
-
-  -without-* | --without-*)
-    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid package name: $ac_package" >&2
-   { (exit 1); exit 1; }; }
-    ac_package=`echo $ac_package | sed 's/-/_/g'`
-    eval "with_$ac_package=no" ;;
-
-  --x)
-    # Obsolete; use --with-x.
-    with_x=yes ;;
-
-  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
-  | --x-incl | --x-inc | --x-in | --x-i)
-    ac_prev=x_includes ;;
-  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
-  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
-    x_includes=$ac_optarg ;;
-
-  -x-libraries | --x-libraries | --x-librarie | --x-librari \
-  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
-    ac_prev=x_libraries ;;
-  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
-  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
-    x_libraries=$ac_optarg ;;
-
-  -*) { echo "$as_me: error: unrecognized option: $ac_option
-Try \`$0 --help' for more information." >&2
-   { (exit 1); exit 1; }; }
-    ;;
-
-  *=*)
-    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
-   { (exit 1); exit 1; }; }
-    ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
-    eval "$ac_envvar='$ac_optarg'"
-    export $ac_envvar ;;
-
-  *)
-    # FIXME: should be removed in autoconf 3.0.
-    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
-    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
-      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
-    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
-    ;;
-
-  esac
-done
-
-if test -n "$ac_prev"; then
-  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  { echo "$as_me: error: missing argument to $ac_option" >&2
-   { (exit 1); exit 1; }; }
-fi
-
-# Be sure to have absolute paths.
-for ac_var in exec_prefix prefix
-do
-  eval ac_val=$`echo $ac_var`
-  case $ac_val in
-    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
-    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
-   { (exit 1); exit 1; }; };;
-  esac
-done
-
-# Be sure to have absolute paths.
-for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
-	      localstatedir libdir includedir oldincludedir infodir mandir
-do
-  eval ac_val=$`echo $ac_var`
-  case $ac_val in
-    [\\/$]* | ?:[\\/]* ) ;;
-    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
-   { (exit 1); exit 1; }; };;
-  esac
-done
-
-# There might be people who depend on the old broken behavior: `$host'
-# used to hold the argument of --host etc.
-# FIXME: To remove some day.
-build=$build_alias
-host=$host_alias
-target=$target_alias
-
-# FIXME: To remove some day.
-if test "x$host_alias" != x; then
-  if test "x$build_alias" = x; then
-    cross_compiling=maybe
-    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used." >&2
-  elif test "x$build_alias" != "x$host_alias"; then
-    cross_compiling=yes
-  fi
-fi
-
-ac_tool_prefix=
-test -n "$host_alias" && ac_tool_prefix=$host_alias-
-
-test "$silent" = yes && exec 6>/dev/null
-
-
-# Find the source files, if location was not specified.
-if test -z "$srcdir"; then
-  ac_srcdir_defaulted=yes
-  # Try the directory containing this script, then its parent.
-  ac_confdir=`(dirname "$0") 2>/dev/null ||
-$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$0" : 'X\(//\)[^/]' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| \
-	 .     : '\(.\)' 2>/dev/null ||
-echo X"$0" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-  srcdir=$ac_confdir
-  if test ! -r $srcdir/$ac_unique_file; then
-    srcdir=..
-  fi
-else
-  ac_srcdir_defaulted=no
-fi
-if test ! -r $srcdir/$ac_unique_file; then
-  if test "$ac_srcdir_defaulted" = yes; then
-    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or .." >&2
-   { (exit 1); exit 1; }; }
-  else
-    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
-   { (exit 1); exit 1; }; }
-  fi
-fi
-(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
-  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
-   { (exit 1); exit 1; }; }
-srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
-ac_env_build_alias_set=${build_alias+set}
-ac_env_build_alias_value=$build_alias
-ac_cv_env_build_alias_set=${build_alias+set}
-ac_cv_env_build_alias_value=$build_alias
-ac_env_host_alias_set=${host_alias+set}
-ac_env_host_alias_value=$host_alias
-ac_cv_env_host_alias_set=${host_alias+set}
-ac_cv_env_host_alias_value=$host_alias
-ac_env_target_alias_set=${target_alias+set}
-ac_env_target_alias_value=$target_alias
-ac_cv_env_target_alias_set=${target_alias+set}
-ac_cv_env_target_alias_value=$target_alias
-ac_env_CC_set=${CC+set}
-ac_env_CC_value=$CC
-ac_cv_env_CC_set=${CC+set}
-ac_cv_env_CC_value=$CC
-ac_env_CFLAGS_set=${CFLAGS+set}
-ac_env_CFLAGS_value=$CFLAGS
-ac_cv_env_CFLAGS_set=${CFLAGS+set}
-ac_cv_env_CFLAGS_value=$CFLAGS
-ac_env_LDFLAGS_set=${LDFLAGS+set}
-ac_env_LDFLAGS_value=$LDFLAGS
-ac_cv_env_LDFLAGS_set=${LDFLAGS+set}
-ac_cv_env_LDFLAGS_value=$LDFLAGS
-ac_env_CPPFLAGS_set=${CPPFLAGS+set}
-ac_env_CPPFLAGS_value=$CPPFLAGS
-ac_cv_env_CPPFLAGS_set=${CPPFLAGS+set}
-ac_cv_env_CPPFLAGS_value=$CPPFLAGS
-ac_env_CPP_set=${CPP+set}
-ac_env_CPP_value=$CPP
-ac_cv_env_CPP_set=${CPP+set}
-ac_cv_env_CPP_value=$CPP
-
-#
-# Report the --help message.
-#
-if test "$ac_init_help" = "long"; then
-  # Omit some internal or obsolete options to make the list less imposing.
-  # This message is too long to be a string in the A/UX 3.1 sh.
-  cat <<_ACEOF
-\`configure' configures this package to adapt to many kinds of systems.
-
-Usage: $0 [OPTION]... [VAR=VALUE]...
-
-To assign environment variables (e.g., CC, CFLAGS...), specify them as
-VAR=VALUE.  See below for descriptions of some of the useful variables.
-
-Defaults for the options are specified in brackets.
-
-Configuration:
-  -h, --help              display this help and exit
-      --help=short        display options specific to this package
-      --help=recursive    display the short help of all the included packages
-  -V, --version           display version information and exit
-  -q, --quiet, --silent   do not print \`checking...' messages
-      --cache-file=FILE   cache test results in FILE [disabled]
-  -C, --config-cache      alias for \`--cache-file=config.cache'
-  -n, --no-create         do not create output files
-      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
-
-_ACEOF
-
-  cat <<_ACEOF
-Installation directories:
-  --prefix=PREFIX         install architecture-independent files in PREFIX
-			  [$ac_default_prefix]
-  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
-			  [PREFIX]
-
-By default, \`make install' will install all the files in
-\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
-an installation prefix other than \`$ac_default_prefix' using \`--prefix',
-for instance \`--prefix=\$HOME'.
-
-For better control, use the options below.
-
-Fine tuning of the installation directories:
-  --bindir=DIR           user executables [EPREFIX/bin]
-  --sbindir=DIR          system admin executables [EPREFIX/sbin]
-  --libexecdir=DIR       program executables [EPREFIX/libexec]
-  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
-  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
-  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
-  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
-  --libdir=DIR           object code libraries [EPREFIX/lib]
-  --includedir=DIR       C header files [PREFIX/include]
-  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
-  --infodir=DIR          info documentation [PREFIX/info]
-  --mandir=DIR           man documentation [PREFIX/man]
-_ACEOF
-
-  cat <<\_ACEOF
-
-System types:
-  --build=BUILD     configure for building on BUILD [guessed]
-  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
-_ACEOF
-fi
-
-if test -n "$ac_init_help"; then
-
-  cat <<\_ACEOF
-
-Optional Packages:
-  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
-  --with-objdir=<dir>     select directory for object files
-  --with-gamecube         enable gamecube support
-  --without-zlib          disable gamecube support
-
-Some influential environment variables:
-  CC          C compiler command
-  CFLAGS      C compiler flags
-  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
-              nonstandard directory <lib dir>
-  CPPFLAGS    C/C++ preprocessor flags, e.g. -I<include dir> if you have
-              headers in a nonstandard directory <include dir>
-  CPP         C preprocessor
-
-Use these variables to override the choices made by `configure' or to help
-it to find libraries and programs with nonstandard names/locations.
-
-_ACEOF
-fi
-
-if test "$ac_init_help" = "recursive"; then
-  # If there are subdirs, report their specific --help.
-  ac_popdir=`pwd`
-  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
-    test -d $ac_dir || continue
-    ac_builddir=.
-
-if test "$ac_dir" != .; then
-  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
-  # A "../" for each directory in $ac_dir_suffix.
-  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
-else
-  ac_dir_suffix= ac_top_builddir=
-fi
-
-case $srcdir in
-  .)  # No --srcdir option.  We are building in place.
-    ac_srcdir=.
-    if test -z "$ac_top_builddir"; then
-       ac_top_srcdir=.
-    else
-       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
-    fi ;;
-  [\\/]* | ?:[\\/]* )  # Absolute path.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir ;;
-  *) # Relative path.
-    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_builddir$srcdir ;;
-esac
-
-# Do not use `cd foo && pwd` to compute absolute paths, because
-# the directories may not exist.
-case `pwd` in
-.) ac_abs_builddir="$ac_dir";;
-*)
-  case "$ac_dir" in
-  .) ac_abs_builddir=`pwd`;;
-  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
-  *) ac_abs_builddir=`pwd`/"$ac_dir";;
-  esac;;
-esac
-case $ac_abs_builddir in
-.) ac_abs_top_builddir=${ac_top_builddir}.;;
-*)
-  case ${ac_top_builddir}. in
-  .) ac_abs_top_builddir=$ac_abs_builddir;;
-  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
-  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
-  esac;;
-esac
-case $ac_abs_builddir in
-.) ac_abs_srcdir=$ac_srcdir;;
-*)
-  case $ac_srcdir in
-  .) ac_abs_srcdir=$ac_abs_builddir;;
-  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
-  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
-  esac;;
-esac
-case $ac_abs_builddir in
-.) ac_abs_top_srcdir=$ac_top_srcdir;;
-*)
-  case $ac_top_srcdir in
-  .) ac_abs_top_srcdir=$ac_abs_builddir;;
-  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
-  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
-  esac;;
-esac
-
-    cd $ac_dir
-    # Check for guested configure; otherwise get Cygnus style configure.
-    if test -f $ac_srcdir/configure.gnu; then
-      echo
-      $SHELL $ac_srcdir/configure.gnu  --help=recursive
-    elif test -f $ac_srcdir/configure; then
-      echo
-      $SHELL $ac_srcdir/configure  --help=recursive
-    elif test -f $ac_srcdir/configure.ac ||
-	   test -f $ac_srcdir/configure.in; then
-      echo
-      $ac_configure --help
-    else
-      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
-    fi
-    cd "$ac_popdir"
-  done
-fi
-
-test -n "$ac_init_help" && exit 0
-if $ac_init_version; then
-  cat <<\_ACEOF
-
-Copyright (C) 2003 Free Software Foundation, Inc.
-This configure script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it.
-_ACEOF
-  exit 0
-fi
-exec 5>config.log
-cat >&5 <<_ACEOF
-This file contains any messages produced by compilers while
-running configure, to aid debugging if configure makes a mistake.
-
-It was created by $as_me, which was
-generated by GNU Autoconf 2.59.  Invocation command line was
-
-  $ $0 $@
-
-_ACEOF
-{
-cat <<_ASUNAME
-## --------- ##
-## Platform. ##
-## --------- ##
-
-hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
-
-/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
-hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
-/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
-/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
-
-_ASUNAME
-
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  echo "PATH: $as_dir"
-done
-
-} >&5
-
-cat >&5 <<_ACEOF
-
-
-## ----------- ##
-## Core tests. ##
-## ----------- ##
-
-_ACEOF
-
-
-# Keep a trace of the command line.
-# Strip out --no-create and --no-recursion so they do not pile up.
-# Strip out --silent because we don't want to record it for future runs.
-# Also quote any args containing shell meta-characters.
-# Make two passes to allow for proper duplicate-argument suppression.
-ac_configure_args=
-ac_configure_args0=
-ac_configure_args1=
-ac_sep=
-ac_must_keep_next=false
-for ac_pass in 1 2
-do
-  for ac_arg
-  do
-    case $ac_arg in
-    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
-    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-    | -silent | --silent | --silen | --sile | --sil)
-      continue ;;
-    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
-      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    esac
-    case $ac_pass in
-    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
-    2)
-      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
-      if test $ac_must_keep_next = true; then
-	ac_must_keep_next=false # Got value, back to normal.
-      else
-	case $ac_arg in
-	  *=* | --config-cache | -C | -disable-* | --disable-* \
-	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
-	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
-	  | -with-* | --with-* | -without-* | --without-* | --x)
-	    case "$ac_configure_args0 " in
-	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
-	    esac
-	    ;;
-	  -* ) ac_must_keep_next=true ;;
-	esac
-      fi
-      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
-      # Get rid of the leading space.
-      ac_sep=" "
-      ;;
-    esac
-  done
-done
-$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
-$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
-
-# When interrupted or exit'd, cleanup temporary files, and complete
-# config.log.  We remove comments because anyway the quotes in there
-# would cause problems or look ugly.
-# WARNING: Be sure not to use single quotes in there, as some shells,
-# such as our DU 5.0 friend, will then `close' the trap.
-trap 'exit_status=$?
-  # Save into config.log some information that might help in debugging.
-  {
-    echo
-
-    cat <<\_ASBOX
-## ---------------- ##
-## Cache variables. ##
-## ---------------- ##
-_ASBOX
-    echo
-    # The following way of writing the cache mishandles newlines in values,
-{
-  (set) 2>&1 |
-    case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
-    *ac_space=\ *)
-      sed -n \
-	"s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
-      ;;
-    *)
-      sed -n \
-	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
-      ;;
-    esac;
-}
-    echo
-
-    cat <<\_ASBOX
-## ----------------- ##
-## Output variables. ##
-## ----------------- ##
-_ASBOX
-    echo
-    for ac_var in $ac_subst_vars
-    do
-      eval ac_val=$`echo $ac_var`
-      echo "$ac_var='"'"'$ac_val'"'"'"
-    done | sort
-    echo
-
-    if test -n "$ac_subst_files"; then
-      cat <<\_ASBOX
-## ------------- ##
-## Output files. ##
-## ------------- ##
-_ASBOX
-      echo
-      for ac_var in $ac_subst_files
-      do
-	eval ac_val=$`echo $ac_var`
-	echo "$ac_var='"'"'$ac_val'"'"'"
-      done | sort
-      echo
-    fi
-
-    if test -s confdefs.h; then
-      cat <<\_ASBOX
-## ----------- ##
-## confdefs.h. ##
-## ----------- ##
-_ASBOX
-      echo
-      sed "/^$/d" confdefs.h | sort
-      echo
-    fi
-    test "$ac_signal" != 0 &&
-      echo "$as_me: caught signal $ac_signal"
-    echo "$as_me: exit $exit_status"
-  } >&5
-  rm -f core *.core &&
-  rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
-    exit $exit_status
-     ' 0
-for ac_signal in 1 2 13 15; do
-  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
-done
-ac_signal=0
-
-# confdefs.h avoids OS command line length limits that DEFS can exceed.
-rm -rf conftest* confdefs.h
-# AIX cpp loses on an empty file, so make sure it contains at least a newline.
-echo >confdefs.h
-
-# Predefined preprocessor variables.
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_NAME "$PACKAGE_NAME"
-_ACEOF
-
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
-_ACEOF
-
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_VERSION "$PACKAGE_VERSION"
-_ACEOF
-
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_STRING "$PACKAGE_STRING"
-_ACEOF
-
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
-_ACEOF
-
-
-# Let the site file select an alternate cache file if it wants to.
-# Prefer explicitly selected file to automatically selected ones.
-if test -z "$CONFIG_SITE"; then
-  if test "x$prefix" != xNONE; then
-    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
-  else
-    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
-  fi
-fi
-for ac_site_file in $CONFIG_SITE; do
-  if test -r "$ac_site_file"; then
-    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
-echo "$as_me: loading site script $ac_site_file" >&6;}
-    sed 's/^/| /' "$ac_site_file" >&5
-    . "$ac_site_file"
-  fi
-done
-
-if test -r "$cache_file"; then
-  # Some versions of bash will fail to source /dev/null (special
-  # files actually), so we avoid doing that.
-  if test -f "$cache_file"; then
-    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
-echo "$as_me: loading cache $cache_file" >&6;}
-    case $cache_file in
-      [\\/]* | ?:[\\/]* ) . $cache_file;;
-      *)                      . ./$cache_file;;
-    esac
-  fi
-else
-  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
-echo "$as_me: creating cache $cache_file" >&6;}
-  >$cache_file
-fi
-
-# Check that the precious variables saved in the cache have kept the same
-# value.
-ac_cache_corrupted=false
-for ac_var in `(set) 2>&1 |
-	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
-  eval ac_old_set=\$ac_cv_env_${ac_var}_set
-  eval ac_new_set=\$ac_env_${ac_var}_set
-  eval ac_old_val="\$ac_cv_env_${ac_var}_value"
-  eval ac_new_val="\$ac_env_${ac_var}_value"
-  case $ac_old_set,$ac_new_set in
-    set,)
-      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
-echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,set)
-      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
-echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,);;
-    *)
-      if test "x$ac_old_val" != "x$ac_new_val"; then
-	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
-echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
-echo "$as_me:   former value:  $ac_old_val" >&2;}
-	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
-echo "$as_me:   current value: $ac_new_val" >&2;}
-	ac_cache_corrupted=:
-      fi;;
-  esac
-  # Pass precious variables to config.status.
-  if test "$ac_new_set" = set; then
-    case $ac_new_val in
-    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
-      ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
-    *) ac_arg=$ac_var=$ac_new_val ;;
-    esac
-    case " $ac_configure_args " in
-      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
-      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
-    esac
-  fi
-done
-if $ac_cache_corrupted; then
-  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
-echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
-echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-ac_aux_dir=
-for ac_dir in ./config $srcdir/./config; do
-  if test -f $ac_dir/install-sh; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f $ac_dir/install.sh; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  elif test -f $ac_dir/shtool; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/shtool install -c"
-    break
-  fi
-done
-if test -z "$ac_aux_dir"; then
-  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in ./config $srcdir/./config" >&5
-echo "$as_me: error: cannot find install-sh or install.sh in ./config $srcdir/./config" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"
-ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
-
-
-# Make sure we can run config.sub.
-$ac_config_sub sun4 >/dev/null 2>&1 ||
-  { { echo "$as_me:$LINENO: error: cannot run $ac_config_sub" >&5
-echo "$as_me: error: cannot run $ac_config_sub" >&2;}
-   { (exit 1); exit 1; }; }
-
-echo "$as_me:$LINENO: checking build system type" >&5
-echo $ECHO_N "checking build system type... $ECHO_C" >&6
-if test "${ac_cv_build+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_build_alias=$build_alias
-test -z "$ac_cv_build_alias" &&
-  ac_cv_build_alias=`$ac_config_guess`
-test -z "$ac_cv_build_alias" &&
-  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
-echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
-   { (exit 1); exit 1; }; }
-ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
-  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_build_alias failed" >&5
-echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
-
-fi
-echo "$as_me:$LINENO: result: $ac_cv_build" >&5
-echo "${ECHO_T}$ac_cv_build" >&6
-build=$ac_cv_build
-build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
-build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
-build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
-
-
-echo "$as_me:$LINENO: checking host system type" >&5
-echo $ECHO_N "checking host system type... $ECHO_C" >&6
-if test "${ac_cv_host+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_host_alias=$host_alias
-test -z "$ac_cv_host_alias" &&
-  ac_cv_host_alias=$ac_cv_build_alias
-ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
-  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_host_alias failed" >&5
-echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
-
-fi
-echo "$as_me:$LINENO: result: $ac_cv_host" >&5
-echo "${ECHO_T}$ac_cv_host" >&6
-host=$ac_cv_host
-host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
-host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
-host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
-
-
-
-
-case $host_cpu in
-	i?86 )
-		host_cpu="i386"
-		;;
-	powerpc )
-		host_cpu="ppc"
-		;;
-	* )
-		host_cpu="$host_cpu"
-		;;
-esac
-case $host_cpu in
-	i386|ppc|x86_64|alpha|ppc64|ia64)
-		;;
-	* )
-		{ { echo "$as_me:$LINENO: error:  unsupported architecture $host_cpu" >&5
-echo "$as_me: error:  unsupported architecture $host_cpu" >&2;}
-   { (exit 1); exit 1; }; }
-		;;
-esac
-ARCH=$host_cpu
-
-
-OBJDIR=`pwd`/objdir
-if test "${host_alias}" ; then
-	OBJDIR="$OBJDIR-${host_alias}"
-fi
-EXTRA_CFLAGS=""
-
-# Check whether --with-objdir or --without-objdir was given.
-if test "${with_objdir+set}" = set; then
-  withval="$with_objdir"
-   OBJDIR="$withval"
-else
-   OBJDIR="$OBJDIR"
-fi;
-
-
-# Check whether --with-gamecube or --without-gamecube was given.
-if test "${with_gamecube+set}" = set; then
-  withval="$with_gamecube"
-   EXTRA_CFLAGS="$EXTRA_CFLAGS -DCONFIG_GAMECUBE=1"
-fi;
-
-
-# Check whether --with-zlib or --without-zlib was given.
-if test "${with_zlib+set}" = set; then
-  withval="$with_zlib"
-   with_zlib="$withval"
-else
-   with_zlib=yes
-fi;
-
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}gcc; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-fi
-if test -z "$ac_cv_prog_CC"; then
-  ac_ct_CC=$CC
-  # Extract the first word of "gcc", so it can be a program name with args.
-set dummy gcc; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_CC="gcc"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
-echo "${ECHO_T}$ac_ct_CC" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-  CC=$ac_ct_CC
-else
-  CC="$ac_cv_prog_CC"
-fi
-
-if test -z "$CC"; then
-  if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}cc; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_CC="${ac_tool_prefix}cc"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-fi
-if test -z "$ac_cv_prog_CC"; then
-  ac_ct_CC=$CC
-  # Extract the first word of "cc", so it can be a program name with args.
-set dummy cc; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_CC="cc"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
-echo "${ECHO_T}$ac_ct_CC" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-  CC=$ac_ct_CC
-else
-  CC="$ac_cv_prog_CC"
-fi
-
-fi
-if test -z "$CC"; then
-  # Extract the first word of "cc", so it can be a program name with args.
-set dummy cc; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  ac_prog_rejected=no
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
-       ac_prog_rejected=yes
-       continue
-     fi
-    ac_cv_prog_CC="cc"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-if test $ac_prog_rejected = yes; then
-  # We found a bogon in the path, so make sure we never use it.
-  set dummy $ac_cv_prog_CC
-  shift
-  if test $# != 0; then
-    # We chose a different compiler from the bogus one.
-    # However, it has the same basename, so the bogon will be chosen
-    # first if we set CC to just the basename; use the full file name.
-    shift
-    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
-  fi
-fi
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-fi
-if test -z "$CC"; then
-  if test -n "$ac_tool_prefix"; then
-  for ac_prog in cl
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-    test -n "$CC" && break
-  done
-fi
-if test -z "$CC"; then
-  ac_ct_CC=$CC
-  for ac_prog in cl
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_CC="$ac_prog"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
-echo "${ECHO_T}$ac_ct_CC" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-  test -n "$ac_ct_CC" && break
-done
-
-  CC=$ac_ct_CC
-fi
-
-fi
-
-
-test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
-See \`config.log' for more details." >&5
-echo "$as_me: error: no acceptable C compiler found in \$PATH
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
-
-# Provide some information about the compiler.
-echo "$as_me:$LINENO:" \
-     "checking for C compiler version" >&5
-ac_compiler=`set X $ac_compile; echo $2`
-{ (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
-  (eval $ac_compiler --version </dev/null >&5) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
-{ (eval echo "$as_me:$LINENO: \"$ac_compiler -v </dev/null >&5\"") >&5
-  (eval $ac_compiler -v </dev/null >&5) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
-{ (eval echo "$as_me:$LINENO: \"$ac_compiler -V </dev/null >&5\"") >&5
-  (eval $ac_compiler -V </dev/null >&5) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
-
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files a.out a.exe b.out"
-# Try to create an executable without -o first, disregard a.out.
-# It will help us diagnose broken compilers, and finding out an intuition
-# of exeext.
-echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
-echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6
-ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
-if { (eval echo "$as_me:$LINENO: \"$ac_link_default\"") >&5
-  (eval $ac_link_default) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  # Find the output, starting from the most likely.  This scheme is
-# not robust to junk in `.', hence go to wildcards (a.*) only as a last
-# resort.
-
-# Be careful to initialize this variable, since it used to be cached.
-# Otherwise an old cache value of `no' led to `EXEEXT = no' in a Makefile.
-ac_cv_exeext=
-# b.out is created by i960 compilers.
-for ac_file in a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out
-do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj )
-	;;
-    conftest.$ac_ext )
-	# This is the source file.
-	;;
-    [ab].out )
-	# We found the default executable, but exeext='' is most
-	# certainly right.
-	break;;
-    *.* )
-	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	# FIXME: I believe we export ac_cv_exeext for Libtool,
-	# but it would be cool to find out if it's true.  Does anybody
-	# maintain Libtool? --akim.
-	export ac_cv_exeext
-	break;;
-    * )
-	break;;
-  esac
-done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { echo "$as_me:$LINENO: error: C compiler cannot create executables
-See \`config.log' for more details." >&5
-echo "$as_me: error: C compiler cannot create executables
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-fi
-
-ac_exeext=$ac_cv_exeext
-echo "$as_me:$LINENO: result: $ac_file" >&5
-echo "${ECHO_T}$ac_file" >&6
-
-# Check the compiler produces executables we can run.  If not, either
-# the compiler is broken, or we cross compile.
-echo "$as_me:$LINENO: checking whether the C compiler works" >&5
-echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
-# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
-# If not cross compiling, check that we can run a simple program.
-if test "$cross_compiling" != yes; then
-  if { ac_try='./$ac_file'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-    cross_compiling=no
-  else
-    if test "$cross_compiling" = maybe; then
-	cross_compiling=yes
-    else
-	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
-If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot run C compiled programs.
-If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
-    fi
-  fi
-fi
-echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-
-rm -f a.out a.exe conftest$ac_cv_exeext b.out
-ac_clean_files=$ac_clean_files_save
-# Check the compiler produces executables we can run.  If not, either
-# the compiler is broken, or we cross compile.
-echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
-echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6
-echo "$as_me:$LINENO: result: $cross_compiling" >&5
-echo "${ECHO_T}$cross_compiling" >&6
-
-echo "$as_me:$LINENO: checking for suffix of executables" >&5
-echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  # If both `conftest.exe' and `conftest' are `present' (well, observable)
-# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
-# work properly (i.e., refer to `conftest.exe'), while it won't with
-# `rm'.
-for ac_file in conftest.exe conftest conftest.*; do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj ) ;;
-    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	  export ac_cv_exeext
-	  break;;
-    * ) break;;
-  esac
-done
-else
-  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-rm -f conftest$ac_cv_exeext
-echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
-echo "${ECHO_T}$ac_cv_exeext" >&6
-
-rm -f conftest.$ac_ext
-EXEEXT=$ac_cv_exeext
-ac_exeext=$EXEEXT
-echo "$as_me:$LINENO: checking for suffix of object files" >&5
-echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6
-if test "${ac_cv_objext+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.o conftest.obj
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2>/dev/null`; do
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg ) ;;
-    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
-       break;;
-  esac
-done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-rm -f conftest.$ac_cv_objext conftest.$ac_ext
-fi
-echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
-echo "${ECHO_T}$ac_cv_objext" >&6
-OBJEXT=$ac_cv_objext
-ac_objext=$OBJEXT
-echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
-echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
-if test "${ac_cv_c_compiler_gnu+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-#ifndef __GNUC__
-       choke me
-#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_compiler_gnu=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-ac_compiler_gnu=no
-fi
-rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
-ac_cv_c_compiler_gnu=$ac_compiler_gnu
-
-fi
-echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
-echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
-GCC=`test $ac_compiler_gnu = yes && echo yes`
-ac_test_CFLAGS=${CFLAGS+set}
-ac_save_CFLAGS=$CFLAGS
-CFLAGS="-g"
-echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
-echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
-if test "${ac_cv_prog_cc_g+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_prog_cc_g=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-ac_cv_prog_cc_g=no
-fi
-rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
-echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
-if test "$ac_test_CFLAGS" = set; then
-  CFLAGS=$ac_save_CFLAGS
-elif test $ac_cv_prog_cc_g = yes; then
-  if test "$GCC" = yes; then
-    CFLAGS="-g -O2"
-  else
-    CFLAGS="-g"
-  fi
-else
-  if test "$GCC" = yes; then
-    CFLAGS="-O2"
-  else
-    CFLAGS=
-  fi
-fi
-echo "$as_me:$LINENO: checking for $CC option to accept ANSI C" >&5
-echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
-if test "${ac_cv_prog_cc_stdc+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_prog_cc_stdc=no
-ac_save_CC=$CC
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
-{
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
-}
-
-/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
-   function prototypes and stuff, but not '\xHH' hex character constants.
-   These don't provoke an error unfortunately, instead are silently treated
-   as 'x'.  The following induces an error, until -std1 is added to get
-   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
-   array size at least.  It's necessary to write '\x00'==0 to get something
-   that's true only with -std1.  */
-int osf4_cc_array ['\x00' == 0 ? 1 : -1];
-
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
-int
-main ()
-{
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-  ;
-  return 0;
-}
-_ACEOF
-# Don't try gcc -ansi; that turns off useful extensions and
-# breaks some systems' header files.
-# AIX			-qlanglvl=ansi
-# Ultrix and OSF/1	-std1
-# HP-UX 10.20 and later	-Ae
-# HP-UX older versions	-Aa -D_HPUX_SOURCE
-# SVR4			-Xc -D__EXTENSIONS__
-for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
-do
-  CC="$ac_save_CC $ac_arg"
-  rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_prog_cc_stdc=$ac_arg
-break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-fi
-rm -f conftest.err conftest.$ac_objext
-done
-rm -f conftest.$ac_ext conftest.$ac_objext
-CC=$ac_save_CC
-
-fi
-
-case "x$ac_cv_prog_cc_stdc" in
-  x|xno)
-    echo "$as_me:$LINENO: result: none needed" >&5
-echo "${ECHO_T}none needed" >&6 ;;
-  *)
-    echo "$as_me:$LINENO: result: $ac_cv_prog_cc_stdc" >&5
-echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
-    CC="$CC $ac_cv_prog_cc_stdc" ;;
-esac
-
-# Some people use a C++ compiler to compile C.  Since we use `exit',
-# in C++ we need to declare it.  In case someone uses the same compiler
-# for both compiling C and C++ we need to have the C++ compiler decide
-# the declaration of exit, since it's the most demanding environment.
-cat >conftest.$ac_ext <<_ACEOF
-#ifndef __cplusplus
-  choke me
-#endif
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  for ac_declaration in \
-   '' \
-   'extern "C" void std::exit (int) throw (); using std::exit;' \
-   'extern "C" void std::exit (int); using std::exit;' \
-   'extern "C" void exit (int) throw ();' \
-   'extern "C" void exit (int);' \
-   'void exit (int);'
-do
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_declaration
-#include <stdlib.h>
-int
-main ()
-{
-exit (42);
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  :
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-continue
-fi
-rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_declaration
-int
-main ()
-{
-exit (42);
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-fi
-rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-rm -f conftest*
-if test -n "$ac_declaration"; then
-  echo '#ifdef __cplusplus' >>confdefs.h
-  echo $ac_declaration      >>confdefs.h
-  echo '#endif'             >>confdefs.h
-fi
-
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-fi
-rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-if test "${build}" != "${host}" ; then
-	BUILD_CC=${CC_FOR_BUILD-gcc}
-else
-	BUILD_CC="\$(CC)"
-fi
-
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
-echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if test "${ac_cv_prog_CPP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  :
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether non-existent headers
-  # can be detected and how.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  # Broken: success on invalid input.
-continue
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then
-  break
-fi
-
-    done
-    ac_cv_prog_CPP=$CPP
-
-fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
-fi
-echo "$as_me:$LINENO: result: $CPP" >&5
-echo "${ECHO_T}$CPP" >&6
-ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  :
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether non-existent headers
-  # can be detected and how.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  # Broken: success on invalid input.
-continue
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then
-  :
-else
-  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." >&5
-echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ld", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ld; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_LD+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$LD"; then
-  ac_cv_prog_LD="$LD" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_LD="${ac_tool_prefix}ld"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-fi
-fi
-LD=$ac_cv_prog_LD
-if test -n "$LD"; then
-  echo "$as_me:$LINENO: result: $LD" >&5
-echo "${ECHO_T}$LD" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-fi
-if test -z "$ac_cv_prog_LD"; then
-  ac_ct_LD=$LD
-  # Extract the first word of "ld", so it can be a program name with args.
-set dummy ld; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_ac_ct_LD+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$ac_ct_LD"; then
-  ac_cv_prog_ac_ct_LD="$ac_ct_LD" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_LD="ld"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_ac_ct_LD" && ac_cv_prog_ac_ct_LD=""no""
-fi
-fi
-ac_ct_LD=$ac_cv_prog_ac_ct_LD
-if test -n "$ac_ct_LD"; then
-  echo "$as_me:$LINENO: result: $ac_ct_LD" >&5
-echo "${ECHO_T}$ac_ct_LD" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-  LD=$ac_ct_LD
-else
-  LD="$ac_cv_prog_LD"
-fi
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}as", so it can be a program name with args.
-set dummy ${ac_tool_prefix}as; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_AS+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$AS"; then
-  ac_cv_prog_AS="$AS" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_AS="${ac_tool_prefix}as"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-fi
-fi
-AS=$ac_cv_prog_AS
-if test -n "$AS"; then
-  echo "$as_me:$LINENO: result: $AS" >&5
-echo "${ECHO_T}$AS" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-fi
-if test -z "$ac_cv_prog_AS"; then
-  ac_ct_AS=$AS
-  # Extract the first word of "as", so it can be a program name with args.
-set dummy as; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_ac_ct_AS+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$ac_ct_AS"; then
-  ac_cv_prog_ac_ct_AS="$ac_ct_AS" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_AS="as"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_ac_ct_AS" && ac_cv_prog_ac_ct_AS=""no""
-fi
-fi
-ac_ct_AS=$ac_cv_prog_ac_ct_AS
-if test -n "$ac_ct_AS"; then
-  echo "$as_me:$LINENO: result: $ac_ct_AS" >&5
-echo "${ECHO_T}$ac_ct_AS" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-  AS=$ac_ct_AS
-else
-  AS="$ac_cv_prog_AS"
-fi
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}objcopy", so it can be a program name with args.
-set dummy ${ac_tool_prefix}objcopy; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_OBJCOPY+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$OBJCOPY"; then
-  ac_cv_prog_OBJCOPY="$OBJCOPY" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_OBJCOPY="${ac_tool_prefix}objcopy"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-fi
-fi
-OBJCOPY=$ac_cv_prog_OBJCOPY
-if test -n "$OBJCOPY"; then
-  echo "$as_me:$LINENO: result: $OBJCOPY" >&5
-echo "${ECHO_T}$OBJCOPY" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-fi
-if test -z "$ac_cv_prog_OBJCOPY"; then
-  ac_ct_OBJCOPY=$OBJCOPY
-  # Extract the first word of "objcopy", so it can be a program name with args.
-set dummy objcopy; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_ac_ct_OBJCOPY+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$ac_ct_OBJCOPY"; then
-  ac_cv_prog_ac_ct_OBJCOPY="$ac_ct_OBJCOPY" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_OBJCOPY="objcopy"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_ac_ct_OBJCOPY" && ac_cv_prog_ac_ct_OBJCOPY=""no""
-fi
-fi
-ac_ct_OBJCOPY=$ac_cv_prog_ac_ct_OBJCOPY
-if test -n "$ac_ct_OBJCOPY"; then
-  echo "$as_me:$LINENO: result: $ac_ct_OBJCOPY" >&5
-echo "${ECHO_T}$ac_ct_OBJCOPY" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-  OBJCOPY=$ac_ct_OBJCOPY
-else
-  OBJCOPY="$ac_cv_prog_OBJCOPY"
-fi
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ar; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_AR+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$AR"; then
-  ac_cv_prog_AR="$AR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_AR="${ac_tool_prefix}ar"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-fi
-fi
-AR=$ac_cv_prog_AR
-if test -n "$AR"; then
-  echo "$as_me:$LINENO: result: $AR" >&5
-echo "${ECHO_T}$AR" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-fi
-if test -z "$ac_cv_prog_AR"; then
-  ac_ct_AR=$AR
-  # Extract the first word of "ar", so it can be a program name with args.
-set dummy ar; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_ac_ct_AR+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$ac_ct_AR"; then
-  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_AR="ar"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_ac_ct_AR" && ac_cv_prog_ac_ct_AR=""""
-fi
-fi
-ac_ct_AR=$ac_cv_prog_ac_ct_AR
-if test -n "$ac_ct_AR"; then
-  echo "$as_me:$LINENO: result: $ac_ct_AR" >&5
-echo "${ECHO_T}$ac_ct_AR" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-  AR=$ac_ct_AR
-else
-  AR="$ac_cv_prog_AR"
-fi
-
-
-# Find a good install program.  We prefer a C program (faster),
-# so one script is as good as another.  But avoid the broken or
-# incompatible versions:
-# SysV /etc/install, /usr/sbin/install
-# SunOS /usr/etc/install
-# IRIX /sbin/install
-# AIX /bin/install
-# AmigaOS /C/install, which installs bootblocks on floppy discs
-# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
-# AFS /usr/afsws/bin/install, which mishandles nonexistent args
-# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
-# OS/2's system install, which has a completely different semantic
-# ./install, which can be erroneously created by make from ./install.sh.
-echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
-echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
-if test -z "$INSTALL"; then
-if test "${ac_cv_path_install+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  # Account for people who put trailing slashes in PATH elements.
-case $as_dir/ in
-  ./ | .// | /cC/* | \
-  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
-  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
-  /usr/ucb/* ) ;;
-  *)
-    # OSF1 and SCO ODT 3.0 have their own names for install.
-    # Don't use installbsd from OSF since it installs stuff as root
-    # by default.
-    for ac_prog in ginstall scoinst install; do
-      for ac_exec_ext in '' $ac_executable_extensions; do
-	if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
-	  if test $ac_prog = install &&
-	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # AIX install.  It has an incompatible calling convention.
-	    :
-	  elif test $ac_prog = install &&
-	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # program-specific install script used by HP pwplus--don't use.
-	    :
-	  else
-	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
-	    break 3
-	  fi
-	fi
-      done
-    done
-    ;;
-esac
-done
-
-
-fi
-  if test "${ac_cv_path_install+set}" = set; then
-    INSTALL=$ac_cv_path_install
-  else
-    # As a last resort, use the slow shell script.  We don't cache a
-    # path for INSTALL within a source directory, because that will
-    # break other packages using the cache if that directory is
-    # removed, or if the path is relative.
-    INSTALL=$ac_install_sh
-  fi
-fi
-echo "$as_me:$LINENO: result: $INSTALL" >&5
-echo "${ECHO_T}$INSTALL" >&6
-
-# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
-# It thinks the first close brace ends the variable substitution.
-test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
-
-test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
-
-test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
-
-# Extract the first word of "mkdir", so it can be a program name with args.
-set dummy mkdir; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_MKDIR+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$MKDIR"; then
-  ac_cv_prog_MKDIR="$MKDIR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_MKDIR="mkdir"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_MKDIR" && ac_cv_prog_MKDIR=""no""
-fi
-fi
-MKDIR=$ac_cv_prog_MKDIR
-if test -n "$MKDIR"; then
-  echo "$as_me:$LINENO: result: $MKDIR" >&5
-echo "${ECHO_T}$MKDIR" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-# Extract the first word of "rm", so it can be a program name with args.
-set dummy rm; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_RM+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$RM"; then
-  ac_cv_prog_RM="$RM" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_RM="rm"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_RM" && ac_cv_prog_RM=""no""
-fi
-fi
-RM=$ac_cv_prog_RM
-if test -n "$RM"; then
-  echo "$as_me:$LINENO: result: $RM" >&5
-echo "${ECHO_T}$RM" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-# Extract the first word of "cp", so it can be a program name with args.
-set dummy cp; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_CP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$CP"; then
-  ac_cv_prog_CP="$CP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_CP="cp"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_CP" && ac_cv_prog_CP=""no""
-fi
-fi
-CP=$ac_cv_prog_CP
-if test -n "$CP"; then
-  echo "$as_me:$LINENO: result: $CP" >&5
-echo "${ECHO_T}$CP" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-# Extract the first word of "ln", so it can be a program name with args.
-set dummy ln; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_LN+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$LN"; then
-  ac_cv_prog_LN="$LN" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_LN="ln"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_LN" && ac_cv_prog_LN=""no""
-fi
-fi
-LN=$ac_cv_prog_LN
-if test -n "$LN"; then
-  echo "$as_me:$LINENO: result: $LN" >&5
-echo "${ECHO_T}$LN" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-# Extract the first word of "tar", so it can be a program name with args.
-set dummy tar; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_TAR+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$TAR"; then
-  ac_cv_prog_TAR="$TAR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_TAR="tar"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_TAR" && ac_cv_prog_TAR=""no""
-fi
-fi
-TAR=$ac_cv_prog_TAR
-if test -n "$TAR"; then
-  echo "$as_me:$LINENO: result: $TAR" >&5
-echo "${ECHO_T}$TAR" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-# Extract the first word of "rpmbuild", so it can be a program name with args.
-set dummy rpmbuild; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_RPMBUILD+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$RPMBUILD"; then
-  ac_cv_prog_RPMBUILD="$RPMBUILD" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_RPMBUILD="rpmbuild"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_RPMBUILD" && ac_cv_prog_RPMBUILD=""no""
-fi
-fi
-RPMBUILD=$ac_cv_prog_RPMBUILD
-if test -n "$RPMBUILD"; then
-  echo "$as_me:$LINENO: result: $RPMBUILD" >&5
-echo "${ECHO_T}$RPMBUILD" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-# Extract the first word of "sed", so it can be a program name with args.
-set dummy sed; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_SED+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$SED"; then
-  ac_cv_prog_SED="$SED" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_SED="sed"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_SED" && ac_cv_prog_SED=""no""
-fi
-fi
-SED=$ac_cv_prog_SED
-if test -n "$SED"; then
-  echo "$as_me:$LINENO: result: $SED" >&5
-echo "${ECHO_T}$SED" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-# Extract the first word of "find", so it can be a program name with args.
-set dummy find; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_FIND+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$FIND"; then
-  ac_cv_prog_FIND="$FIND" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_FIND="find"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_FIND" && ac_cv_prog_FIND=""no""
-fi
-fi
-FIND=$ac_cv_prog_FIND
-if test -n "$FIND"; then
-  echo "$as_me:$LINENO: result: $FIND" >&5
-echo "${ECHO_T}$FIND" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-# Extract the first word of "xargs", so it can be a program name with args.
-set dummy xargs; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_XARGS+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$XARGS"; then
-  ac_cv_prog_XARGS="$XARGS" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_XARGS="xargs"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_XARGS" && ac_cv_prog_XARGS=""no""
-fi
-fi
-XARGS=$ac_cv_prog_XARGS
-if test -n "$XARGS"; then
-  echo "$as_me:$LINENO: result: $XARGS" >&5
-echo "${ECHO_T}$XARGS" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-# Extract the first word of "dirname", so it can be a program name with args.
-set dummy dirname; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_prog_DIRNAME+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$DIRNAME"; then
-  ac_cv_prog_DIRNAME="$DIRNAME" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_DIRNAME="dirname"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  test -z "$ac_cv_prog_DIRNAME" && ac_cv_prog_DIRNAME=""no""
-fi
-fi
-DIRNAME=$ac_cv_prog_DIRNAME
-if test -n "$DIRNAME"; then
-  echo "$as_me:$LINENO: result: $DIRNAME" >&5
-echo "${ECHO_T}$DIRNAME" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-
-if test "$with_zlib" = yes ; then
-
-echo "$as_me:$LINENO: checking for egrep" >&5
-echo $ECHO_N "checking for egrep... $ECHO_C" >&6
-if test "${ac_cv_prog_egrep+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
-    then ac_cv_prog_egrep='grep -E'
-    else ac_cv_prog_egrep='egrep'
-    fi
-fi
-echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
-echo "${ECHO_T}$ac_cv_prog_egrep" >&6
- EGREP=$ac_cv_prog_egrep
-
-
-echo "$as_me:$LINENO: checking for ANSI C header files" >&5
-echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
-if test "${ac_cv_header_stdc+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_header_stdc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-ac_cv_header_stdc=no
-fi
-rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
-
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <string.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then
-  :
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdlib.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then
-  :
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then
-  :
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <ctype.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-		   (('a' <= (c) && (c) <= 'i') \
-		     || ('j' <= (c) && (c) <= 'r') \
-		     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
-
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
-int
-main ()
-{
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-	|| toupper (i) != TOUPPER (i))
-      exit(2);
-  exit (0);
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  :
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ac_cv_header_stdc=no
-fi
-rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-fi
-fi
-echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
-echo "${ECHO_T}$ac_cv_header_stdc" >&6
-if test $ac_cv_header_stdc = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define STDC_HEADERS 1
-_ACEOF
-
-fi
-
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-
-
-
-
-
-
-
-
-
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_Header=yes"
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-eval "$as_ac_Header=no"
-fi
-rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-if test "${ac_cv_header_zlib_h+set}" = set; then
-  echo "$as_me:$LINENO: checking for zlib.h" >&5
-echo $ECHO_N "checking for zlib.h... $ECHO_C" >&6
-if test "${ac_cv_header_zlib_h+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-echo "$as_me:$LINENO: result: $ac_cv_header_zlib_h" >&5
-echo "${ECHO_T}$ac_cv_header_zlib_h" >&6
-else
-  # Is the header compilable?
-echo "$as_me:$LINENO: checking zlib.h usability" >&5
-echo $ECHO_N "checking zlib.h usability... $ECHO_C" >&6
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <zlib.h>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_header_compiler=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-ac_header_compiler=no
-fi
-rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
-echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6
-
-# Is the header present?
-echo "$as_me:$LINENO: checking zlib.h presence" >&5
-echo $ECHO_N "checking zlib.h presence... $ECHO_C" >&6
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <zlib.h>
-_ACEOF
-if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  ac_header_preproc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-rm -f conftest.err conftest.$ac_ext
-echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { echo "$as_me:$LINENO: WARNING: zlib.h: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: zlib.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: zlib.h: proceeding with the compiler's result" >&5
-echo "$as_me: WARNING: zlib.h: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { echo "$as_me:$LINENO: WARNING: zlib.h: present but cannot be compiled" >&5
-echo "$as_me: WARNING: zlib.h: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: zlib.h:     check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: zlib.h:     check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: zlib.h: see the Autoconf documentation" >&5
-echo "$as_me: WARNING: zlib.h: see the Autoconf documentation" >&2;}
-    { echo "$as_me:$LINENO: WARNING: zlib.h:     section \"Present But Cannot Be Compiled\"" >&5
-echo "$as_me: WARNING: zlib.h:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { echo "$as_me:$LINENO: WARNING: zlib.h: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: zlib.h: proceeding with the preprocessor's result" >&2;}
-    { echo "$as_me:$LINENO: WARNING: zlib.h: in the future, the compiler will take precedence" >&5
-echo "$as_me: WARNING: zlib.h: in the future, the compiler will take precedence" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------------ ##
-## Report this to the AC_PACKAGE_NAME lists.  ##
-## ------------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-esac
-echo "$as_me:$LINENO: checking for zlib.h" >&5
-echo $ECHO_N "checking for zlib.h... $ECHO_C" >&6
-if test "${ac_cv_header_zlib_h+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_header_zlib_h=$ac_header_preproc
-fi
-echo "$as_me:$LINENO: result: $ac_cv_header_zlib_h" >&5
-echo "${ECHO_T}$ac_cv_header_zlib_h" >&6
-
-fi
-if test $ac_cv_header_zlib_h = yes; then
-  echo "$as_me:$LINENO: checking for inflateInit_ in -lz" >&5
-echo $ECHO_N "checking for inflateInit_ in -lz... $ECHO_C" >&6
-if test "${ac_cv_lib_z_inflateInit_+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lz  $LIBS"
-
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char inflateInit_ ();
-int
-main ()
-{
-inflateInit_ ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_lib_z_inflateInit_=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-ac_cv_lib_z_inflateInit_=no
-fi
-rm -f conftest.err conftest.$ac_objext \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_z_inflateInit_" >&5
-echo "${ECHO_T}$ac_cv_lib_z_inflateInit_" >&6
-if test $ac_cv_lib_z_inflateInit_ = yes; then
-  cat >>confdefs.h <<\_ACEOF
-#define HAVE_ZLIB_H 1
-_ACEOF
- LIBS="$LIBS -lz"
-fi
-
-fi
-
-
-fi
-
-
-CFLAGS='-Wall -g -fno-strict-aliasing $(CPPFLAGS)'
-BUILD_CFLAGS='-O2 -Wall $(CPPFLAGS)'
-
-if test "$CC"      = "no"; then { { echo "$as_me:$LINENO: error: cc not found" >&5
-echo "$as_me: error: cc not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$CPP"     = "no"; then { { echo "$as_me:$LINENO: error: cpp not found" >&5
-echo "$as_me: error: cpp not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$LD"      = "no"; then { { echo "$as_me:$LINENO: error: ld not found" >&5
-echo "$as_me: error: ld not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$AS"      = "no"; then { { echo "$as_me:$LINENO: error: as not found" >&5
-echo "$as_me: error: as not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$OBJCOPY" = "no"; then	{ { echo "$as_me:$LINENO: error: objcopy not found" >&5
-echo "$as_me: error: objcopy not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$AR"      = "no"; then	{ { echo "$as_me:$LINENO: error: ar not found" >&5
-echo "$as_me: error: ar not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-
-if test "$MKDIR"   = "no"; then { { echo "$as_me:$LINENO: error:  mkdir not found" >&5
-echo "$as_me: error:  mkdir not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$RM"      = "no"; then { { echo "$as_me:$LINENO: error:  rm not found" >&5
-echo "$as_me: error:  rm not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$CP"      = "no"; then { { echo "$as_me:$LINENO: error:  cp not found" >&5
-echo "$as_me: error:  cp not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$LN"      = "no"; then { { echo "$as_me:$LINENO: error:  ln not found" >&5
-echo "$as_me: error:  ln not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$TAR"     = "no"; then { { echo "$as_me:$LINENO: error:  tar not found" >&5
-echo "$as_me: error:  tar not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$RPM"     = "no"; then { { echo "$as_me:$LINENO: error:  rpm not found" >&5
-echo "$as_me: error:  rpm not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$SED"     = "no"; then { { echo "$as_me:$LINENO: error:  sed not found" >&5
-echo "$as_me: error:  sed not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$FIND"    = "no"; then { { echo "$as_me:$LINENO: error:  find not found" >&5
-echo "$as_me: error:  find not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$XARGS"   = "no"; then { { echo "$as_me:$LINENO: error:  xargs not found" >&5
-echo "$as_me: error:  xargs not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-if test "$DIRNAME" = "no"; then { { echo "$as_me:$LINENO: error:  dirname not found" >&5
-echo "$as_me: error:  dirname not found" >&2;}
-   { (exit 1); exit 1; }; } fi
-
-
-
-
-
-
-
-
-
-
-          ac_config_files="$ac_config_files Makefile.conf"
-cat >confcache <<\_ACEOF
-# This file is a shell script that caches the results of configure
-# tests run on this system so they can be shared between configure
-# scripts and configure runs, see configure's option --config-cache.
-# It is not useful on other systems.  If it contains results you don't
-# want to keep, you may remove or edit it.
-#
-# config.status only pays attention to the cache file if you give it
-# the --recheck option to rerun configure.
-#
-# `ac_cv_env_foo' variables (set or unset) will be overridden when
-# loading this file, other *unset* `ac_cv_foo' will be assigned the
-# following values.
-
-_ACEOF
-
-# The following way of writing the cache mishandles newlines in values,
-# but we know of no workaround that is simple, portable, and efficient.
-# So, don't put newlines in cache variables' values.
-# Ultrix sh set writes to stderr and can't be redirected directly,
-# and sets the high bit in the cache file unless we assign to the vars.
-{
-  (set) 2>&1 |
-    case `(ac_space=' '; set | grep ac_space) 2>&1` in
-    *ac_space=\ *)
-      # `set' does not quote correctly, so add quotes (double-quote
-      # substitution turns \\\\ into \\, and sed turns \\ into \).
-      sed -n \
-	"s/'/'\\\\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
-      ;;
-    *)
-      # `set' quotes correctly as required by POSIX, so do not add quotes.
-      sed -n \
-	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
-      ;;
-    esac;
-} |
-  sed '
-     t clear
-     : clear
-     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
-     t end
-     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
-     : end' >>confcache
-if diff $cache_file confcache >/dev/null 2>&1; then :; else
-  if test -w $cache_file; then
-    test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
-    cat confcache >$cache_file
-  else
-    echo "not updating unwritable cache $cache_file"
-  fi
-fi
-rm -f confcache
-
-test "x$prefix" = xNONE && prefix=$ac_default_prefix
-# Let make expand exec_prefix.
-test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
-
-# VPATH may cause trouble with some makes, so we remove $(srcdir),
-# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
-# trailing colons and then remove the whole line if VPATH becomes empty
-# (actually we leave an empty line to preserve line numbers).
-if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
-s/:*\$(srcdir):*/:/;
-s/:*\${srcdir}:*/:/;
-s/:*@srcdir@:*/:/;
-s/^\([^=]*=[	 ]*\):*/\1/;
-s/:*$//;
-s/^[^=]*=[	 ]*$//;
-}'
-fi
-
-# Transform confdefs.h into DEFS.
-# Protect against shell expansion while executing Makefile rules.
-# Protect against Makefile macro expansion.
-#
-# If the first sed substitution is executed (which looks for macros that
-# take arguments), then we branch to the quote section.  Otherwise,
-# look for a macro that doesn't take arguments.
-cat >confdef2opt.sed <<\_ACEOF
-t clear
-: clear
-s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\),-D\1=\2,g
-t quote
-s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\),-D\1=\2,g
-t quote
-d
-: quote
-s,[	 `~#$^&*(){}\\|;'"<>?],\\&,g
-s,\[,\\&,g
-s,\],\\&,g
-s,\$,$$,g
-p
-_ACEOF
-# We use echo to avoid assuming a particular line-breaking character.
-# The extra dot is to prevent the shell from consuming trailing
-# line-breaks from the sub-command output.  A line-break within
-# single-quotes doesn't work because, if this script is created in a
-# platform that uses two characters for line-breaks (e.g., DOS), tr
-# would break.
-ac_LF_and_DOT=`echo; echo .`
-DEFS=`sed -n -f confdef2opt.sed confdefs.h | tr "$ac_LF_and_DOT" ' .'`
-rm -f confdef2opt.sed
-
-
-ac_libobjs=
-ac_ltlibobjs=
-for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
-  # 1. Remove the extension, and $U if already installed.
-  ac_i=`echo "$ac_i" |
-	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
-  # 2. Add them.
-  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
-done
-LIBOBJS=$ac_libobjs
-
-LTLIBOBJS=$ac_ltlibobjs
-
-
-
-: ${CONFIG_STATUS=./config.status}
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
-echo "$as_me: creating $CONFIG_STATUS" >&6;}
-cat >$CONFIG_STATUS <<_ACEOF
-#! $SHELL
-# Generated by $as_me.
-# Run this file to recreate the current configuration.
-# Compiler output produced by configure, useful for debugging
-# configure, is in config.log if it exists.
-
-debug=false
-ac_cs_recheck=false
-ac_cs_silent=false
-SHELL=\${CONFIG_SHELL-$SHELL}
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF
-## --------------------- ##
-## M4sh Initialization.  ##
-## --------------------- ##
-
-# Be Bourne compatible
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
-  emulate sh
-  NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
-  set -o posix
-fi
-DUALCASE=1; export DUALCASE # for MKS sh
-
-# Support unset when possible.
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
-  as_unset=unset
-else
-  as_unset=false
-fi
-
-
-# Work around bugs in pre-3.0 UWIN ksh.
-$as_unset ENV MAIL MAILPATH
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-for as_var in \
-  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
-  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
-  LC_TELEPHONE LC_TIME
-do
-  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
-    eval $as_var=C; export $as_var
-  else
-    $as_unset $as_var
-  fi
-done
-
-# Required to use basename.
-if expr a : '\(a\)' >/dev/null 2>&1; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-
-# Name of the executable.
-as_me=`$as_basename "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)$' \| \
-	 .     : '\(.\)' 2>/dev/null ||
-echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
-  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\/\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-
-
-# PATH needs CR, and LINENO needs CR and PATH.
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  echo "#! /bin/sh" >conf$$.sh
-  echo  "exit 0"   >>conf$$.sh
-  chmod +x conf$$.sh
-  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
-    PATH_SEPARATOR=';'
-  else
-    PATH_SEPARATOR=:
-  fi
-  rm -f conf$$.sh
-fi
-
-
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
-  # Find who we are.  Look in the path if we contain no path at all
-  # relative or not.
-  case $0 in
-    *[\\/]* ) as_myself=$0 ;;
-    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-done
-
-       ;;
-  esac
-  # We did not find ourselves, most probably we were run as `sh COMMAND'
-  # in which case we are not to be found in the path.
-  if test "x$as_myself" = x; then
-    as_myself=$0
-  fi
-  if test ! -f "$as_myself"; then
-    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
-echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
-   { (exit 1); exit 1; }; }
-  fi
-  case $CONFIG_SHELL in
-  '')
-    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for as_base in sh bash ksh sh5; do
-	 case $as_dir in
-	 /*)
-	   if ("$as_dir/$as_base" -c '
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
-	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
-	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
-	     CONFIG_SHELL=$as_dir/$as_base
-	     export CONFIG_SHELL
-	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
-	   fi;;
-	 esac
-       done
-done
-;;
-  esac
-
-  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
-  # uniformly replaced by the line number.  The first 'sed' inserts a
-  # line-number line before each line; the second 'sed' does the real
-  # work.  The second script uses 'N' to pair each line-number line
-  # with the numbered line, and appends trailing '-' during
-  # substitution so that $LINENO is not a special case at line end.
-  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
-  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
-  sed '=' <$as_myself |
-    sed '
-      N
-      s,$,-,
-      : loop
-      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
-      t loop
-      s,-$,,
-      s,^['$as_cr_digits']*\n,,
-    ' >$as_me.lineno &&
-  chmod +x $as_me.lineno ||
-    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
-echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
-   { (exit 1); exit 1; }; }
-
-  # Don't try to exec as it changes $[0], causing all sort of problems
-  # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensible to this).
-  . ./$as_me.lineno
-  # Exit status is that of the last command.
-  exit
-}
-
-
-case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
-  *c*,-n*) ECHO_N= ECHO_C='
-' ECHO_T='	' ;;
-  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
-  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
-esac
-
-if expr a : '\(a\)' >/dev/null 2>&1; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-rm -f conf$$ conf$$.exe conf$$.file
-echo >conf$$.file
-if ln -s conf$$.file conf$$ 2>/dev/null; then
-  # We could just check for DJGPP; but this test a) works b) is more generic
-  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
-  if test -f conf$$.exe; then
-    # Don't use ln at all; we don't have any links
-    as_ln_s='cp -p'
-  else
-    as_ln_s='ln -s'
-  fi
-elif ln conf$$.file conf$$ 2>/dev/null; then
-  as_ln_s=ln
-else
-  as_ln_s='cp -p'
-fi
-rm -f conf$$ conf$$.exe conf$$.file
-
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p=:
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
-fi
-
-as_executable_p="test -f"
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
-
-
-# IFS
-# We need space, tab and new line, in precisely that order.
-as_nl='
-'
-IFS=" 	$as_nl"
-
-# CDPATH.
-$as_unset CDPATH
-
-exec 6>&1
-
-# Open the log real soon, to keep \$[0] and so on meaningful, and to
-# report actual input values of CONFIG_FILES etc. instead of their
-# values after options handling.  Logging --version etc. is OK.
-exec 5>>config.log
-{
-  echo
-  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
-## Running $as_me. ##
-_ASBOX
-} >&5
-cat >&5 <<_CSEOF
-
-This file was extended by $as_me, which was
-generated by GNU Autoconf 2.59.  Invocation command line was
-
-  CONFIG_FILES    = $CONFIG_FILES
-  CONFIG_HEADERS  = $CONFIG_HEADERS
-  CONFIG_LINKS    = $CONFIG_LINKS
-  CONFIG_COMMANDS = $CONFIG_COMMANDS
-  $ $0 $@
-
-_CSEOF
-echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
-echo >&5
-_ACEOF
-
-# Files that config.status was made for.
-if test -n "$ac_config_files"; then
-  echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
-fi
-
-if test -n "$ac_config_headers"; then
-  echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
-fi
-
-if test -n "$ac_config_links"; then
-  echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
-fi
-
-if test -n "$ac_config_commands"; then
-  echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
-fi
-
-cat >>$CONFIG_STATUS <<\_ACEOF
-
-ac_cs_usage="\
-\`$as_me' instantiates files from templates according to the
-current configuration.
-
-Usage: $0 [OPTIONS] [FILE]...
-
-  -h, --help       print this help, then exit
-  -V, --version    print version number, then exit
-  -q, --quiet      do not print progress messages
-  -d, --debug      don't remove temporary files
-      --recheck    update $as_me by reconfiguring in the same conditions
-  --file=FILE[:TEMPLATE]
-		   instantiate the configuration file FILE
-
-Configuration files:
-$config_files
-
-Report bugs to <bug-autoconf@gnu.org>."
-_ACEOF
-
-cat >>$CONFIG_STATUS <<_ACEOF
-ac_cs_version="\\
-config.status
-configured by $0, generated by GNU Autoconf 2.59,
-  with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
-
-Copyright (C) 2003 Free Software Foundation, Inc.
-This config.status script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it."
-srcdir=$srcdir
-INSTALL="$INSTALL"
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF
-# If no file are specified by the user, then we need to provide default
-# value.  By we need to know if files were specified by the user.
-ac_need_defaults=:
-while test $# != 0
-do
-  case $1 in
-  --*=*)
-    ac_option=`expr "x$1" : 'x\([^=]*\)='`
-    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
-    ac_shift=:
-    ;;
-  -*)
-    ac_option=$1
-    ac_optarg=$2
-    ac_shift=shift
-    ;;
-  *) # This is not an option, so the user has probably given explicit
-     # arguments.
-     ac_option=$1
-     ac_need_defaults=false;;
-  esac
-
-  case $ac_option in
-  # Handling of the options.
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF
-  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-    ac_cs_recheck=: ;;
-  --version | --vers* | -V )
-    echo "$ac_cs_version"; exit 0 ;;
-  --he | --h)
-    # Conflict between --help and --header
-    { { echo "$as_me:$LINENO: error: ambiguous option: $1
-Try \`$0 --help' for more information." >&5
-echo "$as_me: error: ambiguous option: $1
-Try \`$0 --help' for more information." >&2;}
-   { (exit 1); exit 1; }; };;
-  --help | --hel | -h )
-    echo "$ac_cs_usage"; exit 0 ;;
-  --debug | --d* | -d )
-    debug=: ;;
-  --file | --fil | --fi | --f )
-    $ac_shift
-    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
-    ac_need_defaults=false;;
-  --header | --heade | --head | --hea )
-    $ac_shift
-    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
-    ac_need_defaults=false;;
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil | --si | --s)
-    ac_cs_silent=: ;;
-
-  # This is an error.
-  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
-Try \`$0 --help' for more information." >&5
-echo "$as_me: error: unrecognized option: $1
-Try \`$0 --help' for more information." >&2;}
-   { (exit 1); exit 1; }; } ;;
-
-  *) ac_config_targets="$ac_config_targets $1" ;;
-
-  esac
-  shift
-done
-
-ac_configure_extra_args=
-
-if $ac_cs_silent; then
-  exec 6>/dev/null
-  ac_configure_extra_args="$ac_configure_extra_args --silent"
-fi
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF
-if \$ac_cs_recheck; then
-  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
-  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
-fi
-
-_ACEOF
-
-
-
-
-
-cat >>$CONFIG_STATUS <<\_ACEOF
-for ac_config_target in $ac_config_targets
-do
-  case "$ac_config_target" in
-  # Handling of arguments.
-  "Makefile.conf" ) CONFIG_FILES="$CONFIG_FILES Makefile.conf" ;;
-  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
-echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
-   { (exit 1); exit 1; }; };;
-  esac
-done
-
-# If the user did not use the arguments to specify the items to instantiate,
-# then the envvar interface is used.  Set only those that are not.
-# We use the long form for the default assignment because of an extremely
-# bizarre bug on SunOS 4.1.3.
-if $ac_need_defaults; then
-  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
-fi
-
-# Have a temporary directory for convenience.  Make it in the build tree
-# simply because there is no reason to put it here, and in addition,
-# creating and moving files from /tmp can sometimes cause problems.
-# Create a temporary directory, and hook for its removal unless debugging.
-$debug ||
-{
-  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
-  trap '{ (exit 1); exit 1; }' 1 2 13 15
-}
-
-# Create a (secure) tmp directory for tmp files.
-
-{
-  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
-  test -n "$tmp" && test -d "$tmp"
-}  ||
-{
-  tmp=./confstat$$-$RANDOM
-  (umask 077 && mkdir $tmp)
-} ||
-{
-   echo "$me: cannot create a temporary directory in ." >&2
-   { (exit 1); exit 1; }
-}
-
-_ACEOF
-
-cat >>$CONFIG_STATUS <<_ACEOF
-
-#
-# CONFIG_FILES section.
-#
-
-# No need to generate the scripts if there are no CONFIG_FILES.
-# This happens for instance when ./config.status config.h
-if test -n "\$CONFIG_FILES"; then
-  # Protect against being on the right side of a sed subst in config.status.
-  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
-   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
-s,@SHELL@,$SHELL,;t t
-s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
-s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
-s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
-s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
-s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
-s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
-s,@exec_prefix@,$exec_prefix,;t t
-s,@prefix@,$prefix,;t t
-s,@program_transform_name@,$program_transform_name,;t t
-s,@bindir@,$bindir,;t t
-s,@sbindir@,$sbindir,;t t
-s,@libexecdir@,$libexecdir,;t t
-s,@datadir@,$datadir,;t t
-s,@sysconfdir@,$sysconfdir,;t t
-s,@sharedstatedir@,$sharedstatedir,;t t
-s,@localstatedir@,$localstatedir,;t t
-s,@libdir@,$libdir,;t t
-s,@includedir@,$includedir,;t t
-s,@oldincludedir@,$oldincludedir,;t t
-s,@infodir@,$infodir,;t t
-s,@mandir@,$mandir,;t t
-s,@build_alias@,$build_alias,;t t
-s,@host_alias@,$host_alias,;t t
-s,@target_alias@,$target_alias,;t t
-s,@DEFS@,$DEFS,;t t
-s,@ECHO_C@,$ECHO_C,;t t
-s,@ECHO_N@,$ECHO_N,;t t
-s,@ECHO_T@,$ECHO_T,;t t
-s,@LIBS@,$LIBS,;t t
-s,@build@,$build,;t t
-s,@build_cpu@,$build_cpu,;t t
-s,@build_vendor@,$build_vendor,;t t
-s,@build_os@,$build_os,;t t
-s,@host@,$host,;t t
-s,@host_cpu@,$host_cpu,;t t
-s,@host_vendor@,$host_vendor,;t t
-s,@host_os@,$host_os,;t t
-s,@CC@,$CC,;t t
-s,@CFLAGS@,$CFLAGS,;t t
-s,@LDFLAGS@,$LDFLAGS,;t t
-s,@CPPFLAGS@,$CPPFLAGS,;t t
-s,@ac_ct_CC@,$ac_ct_CC,;t t
-s,@EXEEXT@,$EXEEXT,;t t
-s,@OBJEXT@,$OBJEXT,;t t
-s,@CPP@,$CPP,;t t
-s,@LD@,$LD,;t t
-s,@ac_ct_LD@,$ac_ct_LD,;t t
-s,@AS@,$AS,;t t
-s,@ac_ct_AS@,$ac_ct_AS,;t t
-s,@OBJCOPY@,$OBJCOPY,;t t
-s,@ac_ct_OBJCOPY@,$ac_ct_OBJCOPY,;t t
-s,@AR@,$AR,;t t
-s,@ac_ct_AR@,$ac_ct_AR,;t t
-s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
-s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
-s,@INSTALL_DATA@,$INSTALL_DATA,;t t
-s,@MKDIR@,$MKDIR,;t t
-s,@RM@,$RM,;t t
-s,@CP@,$CP,;t t
-s,@LN@,$LN,;t t
-s,@TAR@,$TAR,;t t
-s,@RPMBUILD@,$RPMBUILD,;t t
-s,@SED@,$SED,;t t
-s,@FIND@,$FIND,;t t
-s,@XARGS@,$XARGS,;t t
-s,@DIRNAME@,$DIRNAME,;t t
-s,@EGREP@,$EGREP,;t t
-s,@BUILD_CC@,$BUILD_CC,;t t
-s,@BUILD_CFLAGS@,$BUILD_CFLAGS,;t t
-s,@EXTRA_CFLAGS@,$EXTRA_CFLAGS,;t t
-s,@ARCH@,$ARCH,;t t
-s,@OBJDIR@,$OBJDIR,;t t
-s,@INSTALL@,$INSTALL,;t t
-s,@LIBOBJS@,$LIBOBJS,;t t
-s,@LTLIBOBJS@,$LTLIBOBJS,;t t
-CEOF
-
-_ACEOF
-
-  cat >>$CONFIG_STATUS <<\_ACEOF
-  # Split the substitutions into bite-sized pieces for seds with
-  # small command number limits, like on Digital OSF/1 and HP-UX.
-  ac_max_sed_lines=48
-  ac_sed_frag=1 # Number of current file.
-  ac_beg=1 # First line for current file.
-  ac_end=$ac_max_sed_lines # Line after last line for current file.
-  ac_more_lines=:
-  ac_sed_cmds=
-  while $ac_more_lines; do
-    if test $ac_beg -gt 1; then
-      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
-    else
-      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
-    fi
-    if test ! -s $tmp/subs.frag; then
-      ac_more_lines=false
-    else
-      # The purpose of the label and of the branching condition is to
-      # speed up the sed processing (if there are no `@' at all, there
-      # is no need to browse any of the substitutions).
-      # These are the two extra sed commands mentioned above.
-      (echo ':t
-  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
-      if test -z "$ac_sed_cmds"; then
-	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
-      else
-	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
-      fi
-      ac_sed_frag=`expr $ac_sed_frag + 1`
-      ac_beg=$ac_end
-      ac_end=`expr $ac_end + $ac_max_sed_lines`
-    fi
-  done
-  if test -z "$ac_sed_cmds"; then
-    ac_sed_cmds=cat
-  fi
-fi # test -n "$CONFIG_FILES"
-
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF
-for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
-  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
-  case $ac_file in
-  - | *:- | *:-:* ) # input from stdin
-	cat >$tmp/stdin
-	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
-	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
-  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
-	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
-  * )   ac_file_in=$ac_file.in ;;
-  esac
-
-  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
-  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
-$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$ac_file" : 'X\(//\)[^/]' \| \
-	 X"$ac_file" : 'X\(//\)$' \| \
-	 X"$ac_file" : 'X\(/\)' \| \
-	 .     : '\(.\)' 2>/dev/null ||
-echo X"$ac_file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-  { if $as_mkdir_p; then
-    mkdir -p "$ac_dir"
-  else
-    as_dir="$ac_dir"
-    as_dirs=
-    while test ! -d "$as_dir"; do
-      as_dirs="$as_dir $as_dirs"
-      as_dir=`(dirname "$as_dir") 2>/dev/null ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| \
-	 .     : '\(.\)' 2>/dev/null ||
-echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-    done
-    test ! -n "$as_dirs" || mkdir $as_dirs
-  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
-echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
-   { (exit 1); exit 1; }; }; }
-
-  ac_builddir=.
-
-if test "$ac_dir" != .; then
-  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
-  # A "../" for each directory in $ac_dir_suffix.
-  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
-else
-  ac_dir_suffix= ac_top_builddir=
-fi
-
-case $srcdir in
-  .)  # No --srcdir option.  We are building in place.
-    ac_srcdir=.
-    if test -z "$ac_top_builddir"; then
-       ac_top_srcdir=.
-    else
-       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
-    fi ;;
-  [\\/]* | ?:[\\/]* )  # Absolute path.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir ;;
-  *) # Relative path.
-    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_builddir$srcdir ;;
-esac
-
-# Do not use `cd foo && pwd` to compute absolute paths, because
-# the directories may not exist.
-case `pwd` in
-.) ac_abs_builddir="$ac_dir";;
-*)
-  case "$ac_dir" in
-  .) ac_abs_builddir=`pwd`;;
-  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
-  *) ac_abs_builddir=`pwd`/"$ac_dir";;
-  esac;;
-esac
-case $ac_abs_builddir in
-.) ac_abs_top_builddir=${ac_top_builddir}.;;
-*)
-  case ${ac_top_builddir}. in
-  .) ac_abs_top_builddir=$ac_abs_builddir;;
-  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
-  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
-  esac;;
-esac
-case $ac_abs_builddir in
-.) ac_abs_srcdir=$ac_srcdir;;
-*)
-  case $ac_srcdir in
-  .) ac_abs_srcdir=$ac_abs_builddir;;
-  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
-  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
-  esac;;
-esac
-case $ac_abs_builddir in
-.) ac_abs_top_srcdir=$ac_top_srcdir;;
-*)
-  case $ac_top_srcdir in
-  .) ac_abs_top_srcdir=$ac_abs_builddir;;
-  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
-  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
-  esac;;
-esac
-
-
-  case $INSTALL in
-  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
-  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
-  esac
-
-  # Let's still pretend it is `configure' which instantiates (i.e., don't
-  # use $as_me), people would be surprised to read:
-  #    /* config.h.  Generated by config.status.  */
-  if test x"$ac_file" = x-; then
-    configure_input=
-  else
-    configure_input="$ac_file.  "
-  fi
-  configure_input=$configure_input"Generated from `echo $ac_file_in |
-				     sed 's,.*/,,'` by configure."
-
-  # First look for the input files in the build tree, otherwise in the
-  # src tree.
-  ac_file_inputs=`IFS=:
-    for f in $ac_file_in; do
-      case $f in
-      -) echo $tmp/stdin ;;
-      [\\/$]*)
-	 # Absolute (can't be DOS-style, as IFS=:)
-	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
-echo "$as_me: error: cannot find input file: $f" >&2;}
-   { (exit 1); exit 1; }; }
-	 echo "$f";;
-      *) # Relative
-	 if test -f "$f"; then
-	   # Build tree
-	   echo "$f"
-	 elif test -f "$srcdir/$f"; then
-	   # Source tree
-	   echo "$srcdir/$f"
-	 else
-	   # /dev/null tree
-	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
-echo "$as_me: error: cannot find input file: $f" >&2;}
-   { (exit 1); exit 1; }; }
-	 fi;;
-      esac
-    done` || { (exit 1); exit 1; }
-
-  if test x"$ac_file" != x-; then
-    { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    rm -f "$ac_file"
-  fi
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF
-  sed "$ac_vpsub
-$extrasub
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF
-:t
-/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
-s,@configure_input@,$configure_input,;t t
-s,@srcdir@,$ac_srcdir,;t t
-s,@abs_srcdir@,$ac_abs_srcdir,;t t
-s,@top_srcdir@,$ac_top_srcdir,;t t
-s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
-s,@builddir@,$ac_builddir,;t t
-s,@abs_builddir@,$ac_abs_builddir,;t t
-s,@top_builddir@,$ac_top_builddir,;t t
-s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
-s,@INSTALL@,$ac_INSTALL,;t t
-" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
-  rm -f $tmp/stdin
-  if test x"$ac_file" != x-; then
-    mv $tmp/out $ac_file
-  else
-    cat $tmp/out
-    rm -f $tmp/out
-  fi
-
-done
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF
-
-{ (exit 0); exit 0; }
-_ACEOF
-chmod +x $CONFIG_STATUS
-ac_clean_files=$ac_clean_files_save
-
-
-# configure is writing to config.log, and then calls config.status.
-# config.status does its own redirection, appending to config.log.
-# Unfortunately, on DOS this fails, as config.log is still kept open
-# by configure, so config.status won't be able to write to it; its
-# output is simply discarded.  So we exec the FD to /dev/null,
-# effectively closing config.log, so it can be properly (re)opened and
-# appended to by config.status.  When coming back to configure, we
-# need to make the FD available again.
-if test "$no_create" != yes; then
-  ac_cs_success=:
-  ac_config_status_args=
-  test "$silent" = yes &&
-    ac_config_status_args="$ac_config_status_args --quiet"
-  exec 5>/dev/null
-  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
-  exec 5>>config.log
-  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
-  # would make configure fail if this is the last instruction.
-  $ac_cs_success || { (exit 1); exit 1; }
-fi
-
diff -Nur kexec-tools-1.101/configure.ac kexec-tools-1.101-geoff/configure.ac
--- kexec-tools-1.101/configure.ac	2005-01-09 07:36:57.000000000 +0600
+++ kexec-tools-1.101-geoff/configure.ac	2007-10-23 16:24:40.000000000 +0700
@@ -25,18 +25,32 @@
 	powerpc )
 		host_cpu="ppc"
 		;;
+	powerpc64 )
+		host_cpu="ppc64"
+		;;
+	s390x )
+		host_cpu="s390"
+		;;
+	sh4|sh4a|sh3 )
+		host_cpu="sh"
+		;;
 	* ) 
 		host_cpu="$host_cpu"
 		;;
 esac
 case $host_cpu in
-	i386|ppc|x86_64|alpha|ppc64|ia64)
+	i386|ppc|x86_64|alpha|ppc64|ia64|s390|sh)
 		;;
 	* )
 		AC_MSG_ERROR([ unsupported architecture $host_cpu])
 		;;
 esac
-ARCH=$host_cpu
+
+dnl Try to guess the kernel ARCH based on the autoconf host_cpu variable.
+
+if ! test "${ARCH}" ; then
+	ARCH=$host_cpu
+fi
 
 dnl ---Options
 
@@ -44,16 +58,32 @@
 if test "${host_alias}" ; then
 	OBJDIR="$OBJDIR-${host_alias}"
 fi 
-EXTRA_CFLAGS=""
+
+EXTRA_CFLAGS='-Wall -g -fno-strict-aliasing -Wstrict-prototypes $(CPPFLAGS) $(EXTRA_CPPFLAGS)'
+BUILD_CFLAGS='-O2 -Wall $(CPPFLAGS)'
+
+# Check whether ppc64. Add -m64 for building 64-bit binary
+# Add -mcall-aixdesc to generate dot-symbols as in gcc 3.3.3
+if test "$host_cpu" = ppc64; then
+  EXTRA_CFLAGS="$EXTRA_CFLAGS -m64 -mcall-aixdesc"
+fi;
+
+if test "$host_cpu" = ppc; then
+  EXTRA_CFLAGS="$EXTRA_CFLAGS -m32"
+fi;
+
 AC_ARG_WITH([objdir], AC_HELP_STRING([--with-objdir=<dir>],[select directory for object files]),
 	[ OBJDIR="$withval" ], [ OBJDIR="$OBJDIR" ])
 
 AC_ARG_WITH([gamecube], AC_HELP_STRING([--with-gamecube],[enable gamecube support]),
 	[ EXTRA_CFLAGS="$EXTRA_CFLAGS -DCONFIG_GAMECUBE=1" ])
 
-AC_ARG_WITH([zlib], AC_HELP_STRING([--without-zlib],[disable gamecube support]),
+AC_ARG_WITH([zlib], AC_HELP_STRING([--without-zlib],[disable zlib support]),
 	[ with_zlib="$withval"], [ with_zlib=yes ] )
 
+AC_ARG_WITH([xen], AC_HELP_STRING([--without-xen],
+	[disable extended xen support]), [ with_xen="$withval"], [ with_xen=yes ] )
+
 dnl ---Programs
 dnl To specify a different compiler, just 'export CC=/path/to/compiler'
 
@@ -91,10 +121,11 @@
 	AC_CHECK_HEADER(zlib.h, AC_CHECK_LIB(z, inflateInit_, [AC_DEFINE(HAVE_ZLIB_H, 1) LIBS="$LIBS -lz"]))
 fi
 
-dnl ---Hard codes
-
-CFLAGS='-Wall -g -fno-strict-aliasing $(CPPFLAGS)'
-BUILD_CFLAGS='-O2 -Wall $(CPPFLAGS)'
+dnl find Xen control stack libraries
+if test "$with_xen" = yes ; then
+	AC_CHECK_HEADER(xenctrl.h, AC_CHECK_LIB(xenctrl, xc_version,
+		[AC_DEFINE(HAVE_XENCTRL_H, 1) LIBS="$LIBS -lxenctrl"]))
+fi
 
 dnl ---Sanity checks
 if test "$CC"      = "no"; then AC_MSG_ERROR([cc not found]) fi
diff -Nur kexec-tools-1.101/include/x86/x86-linux.h kexec-tools-1.101-geoff/include/x86/x86-linux.h
--- kexec-tools-1.101/include/x86/x86-linux.h	2004-12-20 16:10:21.000000000 +0600
+++ kexec-tools-1.101-geoff/include/x86/x86-linux.h	2007-10-23 16:24:40.000000000 +0700
@@ -141,7 +141,10 @@
 	uint32_t high_filesz;			/* 0x254 */
 	uint8_t  reserved15[0x2d0 - 0x258];	/* 0x258 */
 #else
-	uint8_t  reserved15[0x2d0 - 0x230];	/* 0x230 */
+	/* 2.04+ */
+	uint32_t kernel_alignment;		/* 0x230 */
+	uint8_t  relocatable_kernel;		/* 0x234 */
+	uint8_t  reserved15[0x2d0 - 0x235];	/* 0x230 */
 #endif
 	struct e820entry e820_map[E820MAX];	/* 0x2d0 */
 						/* 0x550 */
@@ -201,12 +204,15 @@
 	uint32_t high_filesz;			/* 0x254 */
 	uint32_t tail[32*1024 - 0x258];		/* 0x258 */
 #else
-	uint8_t  tail[32*1024 - 0x230];		/* 0x230 */
+	uint32_t kernel_alignment;		/* 0x230 */
+	uint8_t  relocatable_kernel;		/* 0x234 */
+	uint8_t  tail[32*1024 - 0x235];		/* 0x230 */
 #endif
 } PACKED;
 
 #endif /* ASSEMBLY */
 
 #define DEFAULT_INITRD_ADDR_MAX 0x37FFFFFF
+#define DEFAULT_BZIMAGE_ADDR_MAX 0x37FFFFFF
 
 #endif /* X86_LINUX_H */
diff -Nur kexec-tools-1.101/INSTALL kexec-tools-1.101-geoff/INSTALL
--- kexec-tools-1.101/INSTALL	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/INSTALL	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,29 @@
+To build kexec-tools
+
+1. If ./configure deosn't exist, create it
+
+   # autoconf
+
+   If you obtain kexec-tools from a released tarball, you can ommit this
+   step.  If on the other hand you obtain kexec-tools from git or some
+   other revision control system, then you will probably need to do this.
+
+2. Run ./configure [--prefix=/usr/local] [options]...
+
+   e.g.
+   # ./configure --prefix=/usr/local
+
+   For a full list of options run
+
+   # ./configure --help
+
+3. Run make
+
+   # make
+
+To install kexec-tools
+
+   After following the above instructions to build-kexec tools, run
+
+   # make install
+
diff -Nur kexec-tools-1.101/kdump/kdump.8 kexec-tools-1.101-geoff/kdump/kdump.8
--- kexec-tools-1.101/kdump/kdump.8	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kdump/kdump.8	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,39 @@
+.\"                                      Hey, EMACS: -*- nroff -*-
+.\" First parameter, NAME, should be all caps
+.\" Second parameter, SECTION, should be 1-8, maybe w/ subsection
+.\" other parameters are allowed: see man(7), man(1)
+.TH KDUMP 8 "Jul 27, 2005"
+.\" Please adjust this date whenever revising the manpage.
+.\"
+.\" Some roff macros, for reference:
+.\" .nh        disable hyphenation
+.\" .hy        enable hyphenation
+.\" .ad l      left justify
+.\" .ad b      justify to both left and right margins
+.\" .nf        disable filling
+.\" .fi        enable filling
+.\" .br        insert line break
+.\" .sp <n>    insert n+1 empty lines
+.\" for manpage-specific macros, see man(7)
+.SH NAME
+kdump \- This is just a placeholder until real man page has been written
+.SH SYNOPSIS
+.B kdump
+.RI [ options ] " start_address" ...
+.SH DESCRIPTION
+.PP
+.\" TeX users may be more comfortable with the \fB<whatever>\fP and
+.\" \fI<whatever>\fP escape sequences to invode bold face and italics,
+.\" respectively.
+\fBkdump\fP does not have a man page yet.
+.SH OPTIONS
+.\"These programs follow the usual GNU command line syntax, with long
+.\"options starting with two dashes (`-').
+.\"A summary of options is included below.
+.\"For a complete description, see the Info files.
+.SH SEE ALSO
+.SH AUTHOR
+kdump was written by Eric Biederman.
+.PP
+This manual page was written by Khalid Aziz <khalid.aziz@hp.com>,
+for the Debian project (but may be used by others).
diff -Nur kexec-tools-1.101/kdump/kdump.c kexec-tools-1.101-geoff/kdump/kdump.c
--- kexec-tools-1.101/kdump/kdump.c	2005-02-06 07:58:15.000000000 +0600
+++ kexec-tools-1.101-geoff/kdump/kdump.c	2007-10-23 16:24:40.000000000 +0700
@@ -54,7 +54,7 @@
 	result = malloc(size);
 	if (result == NULL) {
 		fprintf(stderr, "malloc of %u bytes failed: %s\n",
-			size, strerror(errno));
+			(unsigned int)size, strerror(errno));
 		exit(7);
 	}
 	return result;
@@ -188,7 +188,7 @@
 
 static void write_all(int fd, const void *buf, size_t count)
 {
-	ssize_t result, written;
+	ssize_t result, written = 0;
 	const char *ptr;
 	size_t left;
 	ptr = buf;
diff -Nur kexec-tools-1.101/kdump/Makefile kexec-tools-1.101-geoff/kdump/Makefile
--- kexec-tools-1.101/kdump/Makefile	2005-02-06 07:40:36.000000000 +0600
+++ kexec-tools-1.101-geoff/kdump/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -10,21 +10,25 @@
 KDUMP_OBJS:= $(KDUMP_C_OBJS)
 KDUMP_DEPS:= $(KDUMP_C_DEPS)
 KDUMP:= $(SBINDIR)/kdump
+KDUMP_MANPAGE:= $(MANDIR)/man8/kdump.8
 
 include $(KDUMP_DEPS)
 
 $(KDUMP_C_DEPS): $(OBJDIR)/%.d: %.c
 	mkdir -p $(@D)
-	$(CC) $(CFLAGS) -M $< | sed -e 's|$(patsubst %.d,%.o,$(@F))|$(patsubst %.d,%.o,$(@))|' > $@
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -M $< | sed -e 's|$(patsubst %.d,%.o,$(@F))|$(patsubst %.d,%.o,$(@))|' > $@
 
 $(KDUMP_C_OBJS): $(OBJDIR)/%.o: %.c $(OBJDIR)/%.d
 	mkdir -p $(@D)
-	$(CC) $(CFLAGS) -o $@ -c $<
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ -c $<
 
 $(KDUMP): $(KDUMP_OBJS)
 	mkdir -p $(@D)
-	$(CC) $(CFLAGS) -o $@ $(KDUMP_OBJS)
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -o $@ $(KDUMP_OBJS)
 
+$(KDUMP_MANPAGE): kdump/kdump.8
+	$(MKDIR) -p     $(MANDIR)/man8
+	cp kdump/kdump.8 $(KDUMP_MANPAGE)
 echo::
 	@echo "KDUMP_C_SRCS $(KDUMP_C_SRCS)"
 	@echo "KDUMP_C_DEPS $(KDUMP_C_DEPS)"
diff -Nur kexec-tools-1.101/kexec/arch/i386/crashdump-x86.c kexec-tools-1.101-geoff/kexec/arch/i386/crashdump-x86.c
--- kexec-tools-1.101/kexec/arch/i386/crashdump-x86.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/i386/crashdump-x86.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,587 @@
+/*
+ * kexec: Linux boots Linux
+ *
+ * Created by: Vivek Goyal (vgoyal@in.ibm.com)
+ * Copyright (C) IBM Corporation, 2005. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <limits.h>
+#include <elf.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include "../../kexec.h"
+#include "../../kexec-elf.h"
+#include "../../kexec-syscall.h"
+#include "../../crashdump.h"
+#include "kexec-x86.h"
+#include "crashdump-x86.h"
+#include <x86/x86-linux.h>
+
+extern struct arch_options_t arch_options;
+
+/* Forward Declaration. */
+static int exclude_crash_reserve_region(int *nr_ranges);
+
+/* Stores a sorted list of RAM memory ranges for which to create elf headers.
+ * A separate program header is created for backup region */
+static struct memory_range crash_memory_range[CRASH_MAX_MEMORY_RANGES];
+
+/* Memory region reserved for storing panic kernel and other data. */
+static struct memory_range crash_reserved_mem;
+
+/* Reads the appropriate file and retrieves the SYSTEM RAM regions for whom to
+ * create Elf headers. Keeping it separate from get_memory_ranges() as
+ * requirements are different in the case of normal kexec and crashdumps.
+ *
+ * Normal kexec needs to look at all of available physical memory irrespective
+ * of the fact how much of it is being used by currently running kernel.
+ * Crashdumps need to have access to memory regions actually being used by
+ * running  kernel. Expecting a different file/data structure than /proc/iomem
+ * to look into down the line. May be something like /proc/kernelmem or may
+ * be zone data structures exported from kernel.
+ */
+static int get_crash_memory_ranges(struct memory_range **range, int *ranges)
+{
+	const char iomem[]= "/proc/iomem";
+	int memory_ranges = 0;
+	char line[MAX_LINE];
+	FILE *fp;
+	unsigned long long start, end;
+
+	fp = fopen(iomem, "r");
+	if (!fp) {
+		fprintf(stderr, "Cannot open %s: %s\n",
+			iomem, strerror(errno));
+		return -1;
+	}
+
+	/* First entry is for first 640K region. Different bios report first
+	 * 640K in different manner hence hardcoding it */
+	crash_memory_range[0].start = 0x00000000;
+	crash_memory_range[0].end = 0x0009ffff;
+	crash_memory_range[0].type = RANGE_RAM;
+	memory_ranges++;
+
+	while(fgets(line, sizeof(line), fp) != 0) {
+		char *str;
+		int type, consumed, count;
+		if (memory_ranges >= CRASH_MAX_MEMORY_RANGES)
+			break;
+		count = sscanf(line, "%Lx-%Lx : %n",
+			&start, &end, &consumed);
+		if (count != 2)
+			continue;
+		str = line + consumed;
+#if 0
+		printf("%016Lx-%016Lx : %s",
+			start, end, str);
+#endif
+		/* Only Dumping memory of type System RAM. */
+		if (memcmp(str, "System RAM\n", 11) == 0) {
+			type = RANGE_RAM;
+		} else if (memcmp(str, "Crash kernel\n", 13) == 0) {
+				/* Reserved memory region. New kernel can
+				 * use this region to boot into. */
+				crash_reserved_mem.start = start;
+				crash_reserved_mem.end = end;
+				crash_reserved_mem.type = RANGE_RAM;
+				continue;
+		} else {
+			continue;
+		}
+
+		/* First 640K already registered */
+		if (start >= 0x00000000 && end <= 0x0009ffff)
+			continue;
+
+		crash_memory_range[memory_ranges].start = start;
+		crash_memory_range[memory_ranges].end = end;
+		crash_memory_range[memory_ranges].type = type;
+		memory_ranges++;
+
+		/* Segregate linearly mapped region. */
+		if ((MAXMEM - 1) >= start && (MAXMEM - 1) <= end) {
+			crash_memory_range[memory_ranges-1].end = MAXMEM -1;
+
+			/* Add segregated region. */
+			crash_memory_range[memory_ranges].start = MAXMEM;
+			crash_memory_range[memory_ranges].end = end;
+			crash_memory_range[memory_ranges].type = type;
+			memory_ranges++;
+		}
+	}
+	fclose(fp);
+	if (exclude_crash_reserve_region(&memory_ranges) < 0)
+		return -1;
+	*range = crash_memory_range;
+	*ranges = memory_ranges;
+#if 0
+	int i;
+	printf("CRASH MEMORY RANGES\n");
+	for(i = 0; i < memory_ranges; i++) {
+		start = crash_memory_range[i].start;
+		end = crash_memory_range[i].end;
+		printf("%016Lx-%016Lx\n", start, end);
+	}
+#endif
+	return 0;
+}
+
+/* Removes crash reserve region from list of memory chunks for whom elf program
+ * headers have to be created. Assuming crash reserve region to be a single
+ * continuous area fully contained inside one of the memory chunks */
+static int exclude_crash_reserve_region(int *nr_ranges)
+{
+	int i, j, tidx = -1;
+	unsigned long long cstart, cend;
+	struct memory_range temp_region;
+
+	/* Crash reserved region. */
+	cstart = crash_reserved_mem.start;
+	cend = crash_reserved_mem.end;
+
+	for (i = 0; i < (*nr_ranges); i++) {
+		unsigned long long mstart, mend;
+		mstart = crash_memory_range[i].start;
+		mend = crash_memory_range[i].end;
+		if (cstart < mend && cend > mstart) {
+			if (cstart != mstart && cend != mend) {
+				/* Split memory region */
+				crash_memory_range[i].end = cstart - 1;
+				temp_region.start = cend + 1;
+				temp_region.end = mend;
+				temp_region.type = RANGE_RAM;
+				tidx = i+1;
+			} else if (cstart != mstart)
+				crash_memory_range[i].end = cstart - 1;
+			else
+				crash_memory_range[i].start = cend + 1;
+		}
+	}
+	/* Insert split memory region, if any. */
+	if (tidx >= 0) {
+		if (*nr_ranges == CRASH_MAX_MEMORY_RANGES) {
+			/* No space to insert another element. */
+			fprintf(stderr, "Error: Number of crash memory ranges"
+					" excedeed the max limit\n");
+			return -1;
+		}
+		for (j = (*nr_ranges - 1); j >= tidx; j--)
+			crash_memory_range[j+1] = crash_memory_range[j];
+		crash_memory_range[tidx].start = temp_region.start;
+		crash_memory_range[tidx].end = temp_region.end;
+		crash_memory_range[tidx].type = temp_region.type;
+		(*nr_ranges)++;
+	}
+	return 0;
+}
+
+/* Adds a segment from list of memory regions which new kernel can use to
+ * boot. Segment start and end should be aligned to 1K boundary. */
+static int add_memmap(struct memory_range *memmap_p, unsigned long long addr,
+								size_t size)
+{
+	int i, j, nr_entries = 0, tidx = 0, align = 1024;
+	unsigned long long mstart, mend;
+
+	/* Do alignment check. */
+	if ((addr%align) || (size%align))
+		return -1;
+
+	/* Make sure at least one entry in list is free. */
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		mstart = memmap_p[i].start;
+		mend = memmap_p[i].end;
+		if (!mstart  && !mend)
+			break;
+		else
+			nr_entries++;
+	}
+	if (nr_entries == CRASH_MAX_MEMMAP_NR)
+		return -1;
+
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		mstart = memmap_p[i].start;
+		mend = memmap_p[i].end;
+		if (mstart == 0 && mend == 0)
+			break;
+		if (mstart <= (addr+size-1) && mend >=addr)
+			/* Overlapping region. */
+			return -1;
+		else if (addr > mend)
+			tidx = i+1;
+	}
+		/* Insert the memory region. */
+		for (j = nr_entries-1; j >= tidx; j--)
+			memmap_p[j+1] = memmap_p[j];
+		memmap_p[tidx].start = addr;
+		memmap_p[tidx].end = addr + size - 1;
+#if 0
+	printf("Memmap after adding segment\n");
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		mstart = memmap_p[i].start;
+		mend = memmap_p[i].end;
+		if (mstart == 0 && mend == 0)
+			break;
+		printf("%016llx - %016llx\n",
+			mstart, mend);
+	}
+#endif
+	return 0;
+}
+
+/* Removes a segment from list of memory regions which new kernel can use to
+ * boot. Segment start and end should be aligned to 1K boundary. */
+static int delete_memmap(struct memory_range *memmap_p, unsigned long long addr,
+								size_t size)
+{
+	int i, j, nr_entries = 0, tidx = -1, operation = 0, align = 1024;
+	unsigned long long mstart, mend;
+	struct memory_range temp_region;
+
+	/* Do alignment check. */
+	if ((addr%align) || (size%align))
+		return -1;
+
+	/* Make sure at least one entry in list is free. */
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		mstart = memmap_p[i].start;
+		mend = memmap_p[i].end;
+		if (!mstart  && !mend)
+			break;
+		else
+			nr_entries++;
+	}
+	if (nr_entries == CRASH_MAX_MEMMAP_NR)
+		/* List if full */
+		return -1;
+
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		mstart = memmap_p[i].start;
+		mend = memmap_p[i].end;
+		if (mstart == 0 && mend == 0)
+			/* Did not find the segment in the list. */
+			return -1;
+		if (mstart <= addr && mend >= (addr + size - 1)) {
+			if (mstart == addr && mend == (addr + size - 1)) {
+				/* Exact match. Delete region */
+				operation = -1;
+				tidx = i;
+				break;
+			}
+			if (mstart != addr && mend != (addr + size - 1)) {
+				/* Split in two */
+				memmap_p[i].end = addr - 1;
+				temp_region.start = addr + size;
+				temp_region.end = mend;
+				operation = 1;
+				tidx = i;
+				break;
+			}
+
+			/* No addition/deletion required. Adjust the existing.*/
+			if (mstart != addr) {
+				memmap_p[i].end = addr - 1;
+				break;
+			} else {
+				memmap_p[i].start = addr + size;
+				break;
+			}
+		}
+	}
+	if ((operation == 1) && tidx >=0) {
+		/* Insert the split memory region. */
+		for (j = nr_entries-1; j > tidx; j--)
+			memmap_p[j+1] = memmap_p[j];
+		memmap_p[tidx+1] = temp_region;
+	}
+	if ((operation == -1) && tidx >=0) {
+		/* Delete the exact match memory region. */
+		for (j = i+1; j < CRASH_MAX_MEMMAP_NR; j++)
+			memmap_p[j-1] = memmap_p[j];
+		memmap_p[j-1].start = memmap_p[j-1].end = 0;
+	}
+#if 0
+	printf("Memmap after deleting segment\n");
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		mstart = memmap_p[i].start;
+		mend = memmap_p[i].end;
+		if (mstart == 0 && mend == 0) {
+			break;
+		}
+		printf("%016llx - %016llx\n",
+			mstart, mend);
+	}
+#endif
+	return 0;
+}
+
+/* Converts unsigned long to ascii string. */
+static void ultoa(unsigned long i, char *str)
+{
+	int j = 0, k;
+	char tmp;
+
+	do {
+		str[j++] = i % 10 + '0';
+	} while ((i /=10) > 0);
+	str[j] = '\0';
+
+	/* Reverse the string. */
+	for (j = 0, k = strlen(str) - 1; j < k; j++, k--) {
+		tmp = str[k];
+		str[k] = str[j];
+		str[j] = tmp;
+	}
+}
+
+/* Adds the appropriate memmap= options to command line, indicating the
+ * memory regions the new kernel can use to boot into. */
+static int cmdline_add_memmap(char *cmdline, struct memory_range *memmap_p)
+{
+	int i, cmdlen, len, min_sizek = 100;
+	char str_mmap[256], str_tmp[20];
+
+	/* Exact map */
+	strcpy(str_mmap, " memmap=exactmap");
+	len = strlen(str_mmap);
+	cmdlen = strlen(cmdline) + len;
+	if (cmdlen > (COMMAND_LINE_SIZE - 1))
+		die("Command line overflow\n");
+	strcat(cmdline, str_mmap);
+
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		unsigned long startk, endk;
+		startk = (memmap_p[i].start/1024);
+		endk = ((memmap_p[i].end + 1)/1024);
+		if (!startk && !endk)
+			/* All regions traversed. */
+			break;
+
+		/* A region is not worth adding if region size < 100K. It eats
+		 * up precious command line length. */
+		if ((endk - startk) < min_sizek)
+			continue;
+		strcpy (str_mmap, " memmap=");
+		ultoa((endk-startk), str_tmp);
+		strcat (str_mmap, str_tmp);
+		strcat (str_mmap, "K@");
+		ultoa(startk, str_tmp);
+		strcat (str_mmap, str_tmp);
+		strcat (str_mmap, "K");
+		len = strlen(str_mmap);
+		cmdlen = strlen(cmdline) + len;
+		if (cmdlen > (COMMAND_LINE_SIZE - 1))
+			die("Command line overflow\n");
+		strcat(cmdline, str_mmap);
+	}
+
+#if 0
+		printf("Command line after adding memmap\n");
+		printf("%s\n", cmdline);
+#endif
+	return 0;
+}
+
+/* Adds the elfcorehdr= command line parameter to command line. */
+static int cmdline_add_elfcorehdr(char *cmdline, unsigned long addr)
+{
+	int cmdlen, len, align = 1024;
+	char str[30], *ptr;
+
+	/* Passing in elfcorehdr=xxxK format. Saves space required in cmdline.
+	 * Ensure 1K alignment*/
+	if (addr%align)
+		return -1;
+	addr = addr/align;
+	ptr = str;
+	strcpy(str, " elfcorehdr=");
+	ptr += strlen(str);
+	ultoa(addr, ptr);
+	strcat(str, "K");
+	len = strlen(str);
+	cmdlen = strlen(cmdline) + len;
+	if (cmdlen > (COMMAND_LINE_SIZE - 1))
+		die("Command line overflow\n");
+	strcat(cmdline, str);
+#if 0
+		printf("Command line after adding elfcorehdr\n");
+		printf("%s\n", cmdline);
+#endif
+	return 0;
+}
+
+
+/*
+ * This routine is specific to i386 architecture to maintain the
+ * backward compatibility, other architectures can use the per
+ * cpu version get_crash_notes_per_cpu() directly.
+ */
+static int get_crash_notes(int cpu, uint64_t *addr, uint64_t *len)
+{
+	char crash_notes[PATH_MAX];
+	char line[MAX_LINE];
+	FILE *fp;
+	unsigned long vaddr;
+	int count;
+
+	sprintf(crash_notes, "/sys/kernel/crash_notes");
+	fp = fopen(crash_notes, "r");
+	if (fp) {
+		if (fgets(line, sizeof(line), fp) != 0) {
+			count = sscanf(line, "%lx", &vaddr);
+			if (count != 1)
+				die("Cannot parse %s: %s\n", crash_notes,
+						strerror(errno));
+		}
+
+		*addr = __pa(vaddr + (cpu * MAX_NOTE_BYTES));
+		*len = MAX_NOTE_BYTES;
+#if 0
+		printf("crash_notes addr = %Lx\n", *addr);
+#endif
+		return 0;
+	} else
+		return get_crash_notes_per_cpu(cpu, addr, len);
+}
+
+static struct crash_elf_info elf_info64 =
+{
+	class: ELFCLASS64,
+	data: ELFDATA2LSB,
+	machine: EM_386,
+	backup_src_start: BACKUP_SRC_START,
+	backup_src_end: BACKUP_SRC_END,
+	page_offset: PAGE_OFFSET,
+	lowmem_limit: MAXMEM,
+	get_note_info: get_crash_notes,
+};
+
+static struct crash_elf_info elf_info32 =
+{
+	class: ELFCLASS32,
+	data: ELFDATA2LSB,
+	machine: EM_386,
+	backup_src_start: BACKUP_SRC_START,
+	backup_src_end: BACKUP_SRC_END,
+	page_offset: PAGE_OFFSET,
+	lowmem_limit: MAXMEM,
+	get_note_info: get_crash_notes,
+};
+
+static enum coretype get_core_type(struct kexec_info *info,
+				   struct memory_range *range, int ranges)
+{
+	if (info->kexec_flags & KEXEC_ARCH_X86_64)
+		return CORE_TYPE_ELF64;
+	else {
+		/* fall back to default */
+		if (ranges == 0)
+			return CORE_TYPE_ELF64;
+
+		if (range[ranges].end > 0xFFFFFFFFUL)
+			return CORE_TYPE_ELF64;
+		else
+			return CORE_TYPE_ELF32;
+	}
+}
+
+/* Loads additional segments in case of a panic kernel is being loaded.
+ * One segment for backup region, another segment for storing elf headers
+ * for crash memory image.
+ */
+int load_crashdump_segments(struct kexec_info *info, char* mod_cmdline,
+				unsigned long max_addr, unsigned long min_base)
+{
+	void *tmp;
+	unsigned long sz, elfcorehdr;
+	int nr_ranges, align = 1024;
+	struct memory_range *mem_range, *memmap_p;
+
+	if (get_crash_memory_ranges(&mem_range, &nr_ranges) < 0)
+		return -1;
+
+	/*
+	 * if the core type has not been set on command line, set it here
+	 * automatically
+	 */
+	if (arch_options.core_header_type == CORE_TYPE_UNDEF) {
+		arch_options.core_header_type =
+			get_core_type(info, mem_range, nr_ranges);
+	}
+
+	/* Memory regions which panic kernel can safely use to boot into */
+	sz = (sizeof(struct memory_range) * (KEXEC_MAX_SEGMENTS + 1));
+	memmap_p = xmalloc(sz);
+	memset(memmap_p, 0, sz);
+	add_memmap(memmap_p, BACKUP_SRC_START, BACKUP_SRC_SIZE);
+	sz = crash_reserved_mem.end - crash_reserved_mem.start +1;
+	add_memmap(memmap_p, crash_reserved_mem.start, sz);
+
+	/* Create a backup region segment to store backup data*/
+	sz = (BACKUP_SRC_SIZE + align - 1) & ~(align - 1);
+	tmp = xmalloc(sz);
+	memset(tmp, 0, sz);
+	info->backup_start = add_buffer(info, tmp, sz, sz, align,
+				0, max_addr, -1);
+	dbgprintf("Created backup segment at 0x%lx\n", info->backup_start);
+	if (delete_memmap(memmap_p, info->backup_start, sz) < 0)
+		return -1;
+
+	/* Create elf header segment and store crash image data. */
+	if (arch_options.core_header_type == CORE_TYPE_ELF64) {
+		if (crash_create_elf64_headers(info, &elf_info64,
+					       crash_memory_range, nr_ranges,
+					       &tmp, &sz,
+					       ELF_CORE_HEADER_ALIGN) < 0)
+			return -1;
+	}
+	else {
+		if (crash_create_elf32_headers(info, &elf_info32,
+					       crash_memory_range, nr_ranges,
+					       &tmp, &sz,
+					       ELF_CORE_HEADER_ALIGN) < 0)
+			return -1;
+	}
+
+	/* Hack: With some ld versions (GNU ld version 2.14.90.0.4 20030523),
+	 * vmlinux program headers show a gap of two pages between bss segment
+	 * and data segment but effectively kernel considers it as bss segment
+	 * and overwrites the any data placed there. Hence bloat the memsz of
+	 * elf core header segment to 16K to avoid being placed in such gaps.
+	 * This is a makeshift solution until it is fixed in kernel.
+	 */
+	elfcorehdr = add_buffer(info, tmp, sz, 16*1024, align, min_base,
+							max_addr, -1);
+	dbgprintf("Created elf header segment at 0x%lx\n", elfcorehdr);
+	if (delete_memmap(memmap_p, elfcorehdr, sz) < 0)
+		return -1;
+	cmdline_add_memmap(mod_cmdline, memmap_p);
+	cmdline_add_elfcorehdr(mod_cmdline, elfcorehdr);
+	return 0;
+}
+
+int is_crashkernel_mem_reserved(void)
+{
+	uint64_t start, end;
+
+	return parse_iomem_single("Crash kernel\n", &start, &end) == 0 ?
+	  (start != end) : 0;
+}
diff -Nur kexec-tools-1.101/kexec/arch/i386/crashdump-x86.h kexec-tools-1.101-geoff/kexec/arch/i386/crashdump-x86.h
--- kexec-tools-1.101/kexec/arch/i386/crashdump-x86.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/i386/crashdump-x86.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,22 @@
+#ifndef CRASHDUMP_X86_H
+#define CRASHDUMP_X86_H
+
+struct kexec_info;
+int load_crashdump_segments(struct kexec_info *info, char *mod_cmdline,
+				unsigned long max_addr, unsigned long min_base);
+
+#define PAGE_OFFSET	0xc0000000
+#define __pa(x)		((unsigned long)(x)-PAGE_OFFSET)
+
+#define __VMALLOC_RESERVE       (128 << 20)
+#define MAXMEM                  (-PAGE_OFFSET-__VMALLOC_RESERVE)
+
+#define CRASH_MAX_MEMMAP_NR	(KEXEC_MAX_SEGMENTS + 1)
+#define CRASH_MAX_MEMORY_RANGES	(MAX_MEMORY_RANGES + 2)
+
+/* Backup Region, First 640K of System RAM. */
+#define BACKUP_SRC_START	0x00000000
+#define BACKUP_SRC_END		0x0009ffff
+#define BACKUP_SRC_SIZE	(BACKUP_SRC_END - BACKUP_SRC_START + 1)
+
+#endif /* CRASHDUMP_X86_H */
diff -Nur kexec-tools-1.101/kexec/arch/i386/include/arch/options.h kexec-tools-1.101-geoff/kexec/arch/i386/include/arch/options.h
--- kexec-tools-1.101/kexec/arch/i386/include/arch/options.h	2004-12-22 02:53:37.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/i386/include/arch/options.h	2007-10-23 16:24:40.000000000 +0700
@@ -6,7 +6,9 @@
 #define OPT_SERIAL_BAUD    (OPT_MAX+2)
 #define OPT_CONSOLE_VGA    (OPT_MAX+3)
 #define OPT_CONSOLE_SERIAL (OPT_MAX+4)
-#define OPT_ARCH_MAX       (OPT_MAX+5)
+#define OPT_ELF32_CORE     (OPT_MAX+5)
+#define OPT_ELF64_CORE     (OPT_MAX+6)
+#define OPT_ARCH_MAX       (OPT_MAX+7)
 
 #define KEXEC_ARCH_OPTIONS \
 	KEXEC_OPTIONS \
@@ -15,6 +17,8 @@
 	{ "serial-baud",    1, 0, OPT_SERIAL_BAUD }, \
 	{ "console-vga",    0, 0, OPT_CONSOLE_VGA }, \
 	{ "console-serial", 0, 0, OPT_CONSOLE_SERIAL }, \
+	{ "elf32-core-headers", 0, 0, OPT_ELF32_CORE }, \
+	{ "elf64-core-headers", 0, 0, OPT_ELF64_CORE }, \
 
 #define KEXEC_ARCH_OPT_STR KEXEC_OPT_STR ""
 
diff -Nur kexec-tools-1.101/kexec/arch/i386/kexec-bzImage.c kexec-tools-1.101-geoff/kexec/arch/i386/kexec-bzImage.c
--- kexec-tools-1.101/kexec/arch/i386/kexec-bzImage.c	2005-01-13 19:32:01.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/i386/kexec-bzImage.c	2007-10-23 16:24:40.000000000 +0700
@@ -34,8 +34,10 @@
 #include <x86/x86-linux.h>
 #include "../../kexec.h"
 #include "../../kexec-elf.h"
+#include "../../kexec-syscall.h"
 #include "kexec-x86.h"
 #include "x86-linux-setup.h"
+#include "crashdump-x86.h"
 #include <arch/options.h>
 
 static const int probe_debug = 0;
@@ -109,6 +111,9 @@
 	unsigned long setup_base, setup_size;
 	struct entry32_regs regs32;
 	struct entry16_regs regs16;
+	unsigned int relocatable_kernel = 0;
+	unsigned long kernel32_load_addr;
+	char *modified_cmdline;
 
 	/*
 	 * Find out about the file I am about to load.
@@ -121,6 +126,7 @@
 	if (setup_sects == 0) {
 		setup_sects = 4;
 	}
+
 	kern16_size = (setup_sects +1) *512;
 	kernel_version = ((unsigned char *)&setup_header) + 512 + setup_header.kver_addr;
 	if (kernel_len < kern16_size) {
@@ -128,25 +134,89 @@
 		return -1;
 	}
 
+	if (setup_header.protocol_version >= 0x0205) {
+		relocatable_kernel = setup_header.relocatable_kernel;
+		dbgprintf("bzImage is relocatable\n");
+	}
+
+	/* Can't use bzImage for crash dump purposes with real mode entry */
+	if((info->kexec_flags & KEXEC_ON_CRASH) && real_mode_entry) {
+		fprintf(stderr, "Can't use bzImage for crash dump purposes"
+				" with real mode entry\n");
+		return -1;
+	}
+
+	if((info->kexec_flags & KEXEC_ON_CRASH) && !relocatable_kernel) {
+		fprintf(stderr, "BzImage is not relocatable. Can't be used"
+				" as capture kernel.\n");
+		return -1;
+	}
+
+	/* Need to append some command line parameters internally in case of
+	 * taking crash dumps.
+	 */
+	if (info->kexec_flags & KEXEC_ON_CRASH) {
+		modified_cmdline = xmalloc(COMMAND_LINE_SIZE);
+		memset((void *)modified_cmdline, 0, COMMAND_LINE_SIZE);
+		if (command_line) {
+			strncpy(modified_cmdline, command_line,
+					COMMAND_LINE_SIZE);
+			modified_cmdline[COMMAND_LINE_SIZE - 1] = '\0';
+		}
+
+		/* If panic kernel is being loaded, additional segments need
+		 * to be created. load_crashdump_segments will take care of
+		 * loading the segments as high in memory as possible, hence
+		 * in turn as away as possible from kernel to avoid being
+		 * stomped by the kernel.
+		 */
+		if (load_crashdump_segments(info, modified_cmdline, -1, 0) < 0)
+			return -1;
+
+		/* Use new command line buffer */
+		command_line = modified_cmdline;
+		command_line_len = strlen(command_line) +1;
+	}
+
 	/* Load the trampoline.  This must load at a higher address
 	 * the the argument/parameter segment or the kernel will stomp
 	 * it's gdt.
+	 *
+	 * x86_64 purgatory code has got relocations type R_X86_64_32S
+	 * that means purgatory got to be loaded within first 2G otherwise
+	 * overflow takes place while applying relocations.
 	 */
-	elf_rel_build_load(info, &info->rhdr, purgatory, purgatory_size,
-		0x3000, 640*1024, -1);
-
+	if (!real_mode_entry && relocatable_kernel)
+		elf_rel_build_load(info, &info->rhdr, purgatory, purgatory_size,
+					0x3000, 0x7fffffff, -1, 0);
+	else
+		elf_rel_build_load(info, &info->rhdr, purgatory, purgatory_size,
+					0x3000, 640*1024, -1, 0);
+	dbgprintf("Loaded purgatory at addr 0x%lx\n", info->rhdr.rel_addr);
 	/* The argument/parameter segment */
 	setup_size = kern16_size + command_line_len;
 	real_mode = xmalloc(setup_size);
 	memcpy(real_mode, kernel, kern16_size);
-	if (real_mode->protocol_version >= 0x0200) {
+
+	if (info->kexec_flags & KEXEC_ON_CRASH) {
+		/* If using bzImage for capture kernel, then we will not be
+		 * executing real mode code. setup segment can be loaded
+		 * anywhere as we will be just reading command line.
+		 */
+		setup_base = add_buffer(info, real_mode, setup_size, setup_size,
+			16, 0x3000, -1, 1);
+	}
+	else if (real_mode->protocol_version >= 0x0200) {
 		/* Careful setup_base must be greater than 8K */
 		setup_base = add_buffer(info, real_mode, setup_size, setup_size,
-			16, 0x3000, 640*1024, -1);
+			16, 0x3000, 640*1024, 1);
 	} else {
 		add_segment(info, real_mode, setup_size, SETUP_BASE, setup_size);
 		setup_base = SETUP_BASE;
 	}
+	dbgprintf("Loaded real-mode code and command line at 0x%lx\n",
+			setup_base);
+
 	/* Verify purgatory loads higher than the parameters */
 	if (info->rhdr.rel_addr < setup_base) {
 		die("Could not put setup code above the kernel parameters\n");
@@ -154,9 +224,30 @@
 	
 	/* The main kernel segment */
 	size = kernel_len - kern16_size;
-	add_segment(info, kernel + kern16_size, size, KERN32_BASE,  size);
 
+	if (real_mode->protocol_version >=0x0205 && relocatable_kernel) {
+		/* Relocatable bzImage */
+		unsigned long kern_align = real_mode->kernel_alignment;
+		unsigned long kernel32_max_addr = DEFAULT_BZIMAGE_ADDR_MAX;
+
+		if (real_mode->protocol_version >= 0x0203) {
+			if (kernel32_max_addr > real_mode->initrd_addr_max)
+				kernel32_max_addr = real_mode->initrd_addr_max;
+		}
+
+		kernel32_load_addr = add_buffer(info, kernel + kern16_size,
+						size, size, kern_align,
+						0x100000, kernel32_max_addr,
+						1);
+	}
+	else {
+		kernel32_load_addr = KERN32_BASE;
+		add_segment(info, kernel + kern16_size, size,
+				kernel32_load_addr, size);
+	}
 		
+	dbgprintf("Loaded 32bit kernel at 0x%lx\n", kernel32_load_addr);
+
 	/* Tell the kernel what is going on */
 	setup_linux_bootloader_parameters(info, real_mode, setup_base,
 		kern16_size, command_line, command_line_len,
@@ -177,12 +268,12 @@
 	regs32.edi = 0; /* unused */
 	regs32.esp = elf_rel_get_addr(&info->rhdr, "stack_end"); /* stack, unused */
 	regs32.ebp = 0; /* unused */
-	regs32.eip = KERN32_BASE; /* kernel entry point */
+	regs32.eip = kernel32_load_addr; /* kernel entry point */
 
 	/*
 	 * Initialize the 16bit start information.
 	 */
-	regs16.cs = setup_base + 0x20;
+	regs16.cs = (setup_base>>4) + 0x20;
 	regs16.ip = 0;
 	regs16.ss = (elf_rel_get_addr(&info->rhdr, "stack_end") - 64*1024) >> 4;
 	regs16.esp = 0xFFFC;
@@ -190,7 +281,7 @@
 		printf("Starting the kernel in real mode\n");
 		regs32.eip = elf_rel_get_addr(&info->rhdr, "entry16");
 	}
-	if (real_mode && debug) {
+	if (real_mode_entry && debug) {
 		unsigned long entry16_debug, pre32, first32;
 		uint32_t old_first32;
 		/* Find the location of the symbols */
@@ -214,7 +305,7 @@
 
 	/* Fill in the information BIOS calls would normally provide. */
 	if (!real_mode_entry) {
-		setup_linux_system_parameters(real_mode);
+		setup_linux_system_parameters(real_mode, info->kexec_flags);
 	}
 
 	return 0;
diff -Nur kexec-tools-1.101/kexec/arch/i386/kexec-elf-x86.c kexec-tools-1.101-geoff/kexec/arch/i386/kexec-elf-x86.c
--- kexec-tools-1.101/kexec/arch/i386/kexec-elf-x86.c	2005-01-13 19:59:19.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/i386/kexec-elf-x86.c	2007-10-23 16:24:40.000000000 +0700
@@ -32,10 +32,12 @@
 #include <elf.h>
 #include <x86/x86-linux.h>
 #include "../../kexec.h"
+#include "../../kexec-syscall.h"
 #include "../../kexec-elf.h"
 #include "../../kexec-elf-boot.h"
 #include "x86-linux-setup.h"
 #include "kexec-x86.h"
+#include "crashdump-x86.h"
 #include <arch/options.h>
 
 static const int probe_debug = 0;
@@ -45,7 +47,7 @@
 	
 	struct mem_ehdr ehdr;
 	int result;
-	result = build_elf_exec_info(buf, len, &ehdr);
+	result = build_elf_exec_info(buf, len, &ehdr, 0);
 	if (result < 0) {
 		if (probe_debug) {
 			fprintf(stderr, "Not an ELF executable\n");
@@ -86,7 +88,9 @@
 {
 	struct mem_ehdr ehdr;
 	const char *command_line;
+	char *modified_cmdline;
 	int command_line_len;
+	int modified_cmdline_len;
 	const char *ramdisk;
 	unsigned long entry, max_addr;
 	int arg_style;
@@ -119,6 +123,8 @@
 	 */
 	arg_style = ARG_STYLE_ELF;
 	command_line = 0;
+	modified_cmdline = 0;
+	modified_cmdline_len = 0;
 	ramdisk = 0;
 	while((opt = getopt_long(argc, argv, short_options, options, 0)) != -1) {
 		switch(opt) {
@@ -143,7 +149,7 @@
 			arg_style = ARG_STYLE_LINUX;
 			break;
 		case OPT_ARGS_NONE:
-#ifdef __i386___
+#ifdef __i386__
 			arg_style = ARG_STYLE_NONE;
 #else
 			die("--args-none only works on arch i386\n");
@@ -156,8 +162,22 @@
 		command_line_len = strlen(command_line) +1;
 	}
 
+	/* Need to append some command line parameters internally in case of
+	 * taking crash dumps.
+	 */
+	if (info->kexec_flags & KEXEC_ON_CRASH) {
+		modified_cmdline = xmalloc(COMMAND_LINE_SIZE);
+		memset((void *)modified_cmdline, 0, COMMAND_LINE_SIZE);
+		if (command_line) {
+			strncpy(modified_cmdline, command_line,
+						COMMAND_LINE_SIZE);
+			modified_cmdline[COMMAND_LINE_SIZE - 1] = '\0';
+		}
+		modified_cmdline_len = strlen(modified_cmdline);
+	}
+
 	/* Load the ELF executable */
-	elf_exec_build_load(info, &ehdr, buf, len);
+	elf_exec_build_load(info, &ehdr, buf, len, 0);
 
 	entry = ehdr.e_entry;
 	max_addr = elf_max_addr(&ehdr);
@@ -166,7 +186,7 @@
 	if (arg_style != ARG_STYLE_NONE) {
 		/* Load the setup code */
 		elf_rel_build_load(info, &info->rhdr, purgatory, purgatory_size,
-			0, ULONG_MAX, 1);
+			0, ULONG_MAX, 1, 0);
 	}
 	if (arg_style == ARG_STYLE_NONE) {
 		info->entry = (void *)entry;
@@ -203,10 +223,20 @@
 		const unsigned char *ramdisk_buf;
 		off_t ramdisk_length;
 		struct entry32_regs regs;
+		int rc = 0;
 
 		/* Get the linux parameter header */
 		hdr = xmalloc(sizeof(*hdr));
-		param_base = add_buffer(info, hdr, sizeof(*hdr), sizeof(*hdr),
+
+		/* Hack: With some ld versions, vmlinux program headers show
+		 * a gap of two pages between bss segment and data segment
+		 * but effectively kernel considers it as bss segment and
+		 * overwrites the any data placed there. Hence bloat the
+		 * memsz of parameter segment to 16K to avoid being placed
+		 * in such gaps.
+		 * This is a makeshift solution until it is fixed in kernel
+		 */
+		param_base = add_buffer(info, hdr, sizeof(*hdr), 16*1024,
 			16, 0, max_addr, 1);
 
 		/* Initialize the parameter header */
@@ -217,10 +247,21 @@
 		ramdisk_buf = NULL;
 		ramdisk_length = 0;
 		if (ramdisk) {
-			unsigned char *ramdisk_buf;
 			ramdisk_buf = slurp_file(ramdisk, &ramdisk_length);
 		}
 
+		/* If panic kernel is being loaded, additional segments need
+		 * to be created. */
+		if (info->kexec_flags & KEXEC_ON_CRASH) {
+			rc = load_crashdump_segments(info, modified_cmdline,
+						max_addr, 0);
+			if (rc < 0)
+				return -1;
+			/* Use new command line. */
+			command_line = modified_cmdline;
+			command_line_len = strlen(modified_cmdline) + 1;
+		}
+
 		/* Tell the kernel what is going on */
 		setup_linux_bootloader_parameters(info, &hdr->hdr, param_base, 
 			offsetof(struct x86_linux_faked_param_header, command_line),
@@ -228,7 +269,7 @@
 			ramdisk_buf, ramdisk_length);
 
 		/* Fill in the information bios calls would usually provide */
-		setup_linux_system_parameters(&hdr->hdr);
+		setup_linux_system_parameters(&hdr->hdr, info->kexec_flags);
 
 		/* Initialize the registers */
 		elf_rel_get_symbol(&info->rhdr, "entry32_regs", &regs, sizeof(regs));
diff -Nur kexec-tools-1.101/kexec/arch/i386/kexec-multiboot-x86.c kexec-tools-1.101-geoff/kexec/arch/i386/kexec-multiboot-x86.c
--- kexec-tools-1.101/kexec/arch/i386/kexec-multiboot-x86.c	2005-01-25 01:58:04.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/i386/kexec-multiboot-x86.c	2007-10-23 16:24:40.000000000 +0700
@@ -47,7 +47,6 @@
 #include <getopt.h>
 #include <elf.h>
 #include <boot/elf_boot.h>
-#include <asm/page.h>
 #include <ip_checksum.h>
 #include "../../kexec.h"
 #include "../../kexec-elf.h"
@@ -210,10 +209,11 @@
 
 	
 	/* Load the ELF executable */
-	elf_exec_build_load(info, &ehdr, buf, len);
+	elf_exec_build_load(info, &ehdr, buf, len, 0);
 
 	/* Load the setup code */
-	elf_rel_build_load(info, &info->rhdr, purgatory, purgatory_size, 0, ULONG_MAX, 1);
+	elf_rel_build_load(info, &info->rhdr, purgatory, purgatory_size, 0,
+				ULONG_MAX, 1, 0);
 	
 	/* The first segment will contain the multiboot headers:
 	 * =============
@@ -246,7 +246,8 @@
 	mbi->boot_loader_name = sizeof(*mbi) + command_line_len; 
 
 	/* Memory map */
-	if ((get_memory_ranges(&range, &ranges) < 0) || ranges == 0) {
+	if ((get_memory_ranges(&range, &ranges, info->kexec_flags) < 0)
+			|| ranges == 0) {
 		fprintf(stderr, "Cannot get memory information\n");
 		return -1;
 	}
@@ -341,7 +342,7 @@
 			/* Pick the next aligned spot to load it in */
 			freespace = add_buffer(info,
 				buf, mod_size, mod_size,
-				PAGE_SIZE, 0, 0xffffffffUL, 1);
+				getpagesize(), 0, 0xffffffffUL, 1);
 
 			/* Add the module command line */
 			sprintf(mod_clp, "%s", mod_command_line);
diff -Nur kexec-tools-1.101/kexec/arch/i386/kexec-nbi.c kexec-tools-1.101-geoff/kexec/arch/i386/kexec-nbi.c
--- kexec-tools-1.101/kexec/arch/i386/kexec-nbi.c	2005-02-06 05:31:48.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/i386/kexec-nbi.c	2007-10-23 16:24:40.000000000 +0700
@@ -216,6 +216,11 @@
 		else if ((seg.flags & NBI_SEG) == NBI_SEG_PREPEND) {
 			loadaddr = last0 - seg.loadaddr;
 		}
+		else {
+			printf("warning: unhandled segment of type %0x\n",
+				seg.flags & NBI_SEG);
+			continue;
+		}
 		add_segment(info, buf + file_off, seg.imglength,
 			loadaddr, seg.memlength);
 		last0 = loadaddr;
diff -Nur kexec-tools-1.101/kexec/arch/i386/kexec-x86.c kexec-tools-1.101-geoff/kexec/arch/i386/kexec-x86.c
--- kexec-tools-1.101/kexec/arch/i386/kexec-x86.c	2005-02-06 05:24:35.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/i386/kexec-x86.c	2007-10-23 16:24:40.000000000 +0700
@@ -30,14 +30,14 @@
 #include "../../kexec-elf.h"
 #include "../../kexec-syscall.h"
 #include "kexec-x86.h"
+#include "crashdump-x86.h"
 #include <arch/options.h>
 
-#define MAX_MEMORY_RANGES 64
-#define MAX_LINE 160
 static struct memory_range memory_range[MAX_MEMORY_RANGES];
 
 /* Return a sorted list of memory ranges. */
-int get_memory_ranges(struct memory_range **range, int *ranges)
+int get_memory_ranges(struct memory_range **range, int *ranges,
+				unsigned long kexec_flags)
 {
 	const char iomem[]= "/proc/iomem";
 	int memory_ranges = 0;
@@ -79,6 +79,20 @@
 		else if (memcmp(str, "ACPI Non-volatile Storage\n", 26) == 0) {
 			type = RANGE_ACPI_NVS;
 		}
+		else if (memcmp(str, "Crash kernel\n", 13) == 0) {
+		/* Redefine the memory region boundaries if kernel
+		 * exports the limits and if it is panic kernel.
+		 * Override user values only if kernel exported values are
+		 * subset of user defined values.
+		 */
+			if (kexec_flags & KEXEC_ON_CRASH) {
+				if (start > mem_min)
+					mem_min = start;
+				if (end < mem_max)
+					mem_max = end;
+			}
+			continue;
+		}
 		else {
 			continue;
 		}
@@ -117,24 +131,21 @@
 	printf(
 		"     --reset-vga               Attempt to reset a standard vga device\n"
 		"     --serial=<port>           Specify the serial port for debug output\n"
-		"     --serial-baud=<buad_rate> Specify the serial port baud rate\n"
+		"     --serial-baud=<baud_rate> Specify the serial port baud rate\n"
 		"     --console-vga             Enable the vga console\n"
 		"     --console-serial          Enable the serial console\n"
+		"     --elf32-core-headers      Prepare core headers in ELF32 format\n"
+		"     --elf64-core-headers      Prepare core headers in ELF64 format\n"
 		);
 }
 
-static struct {
-	uint8_t  reset_vga;
-	uint16_t serial_base;
-	uint32_t serial_baud;
-	uint8_t  console_vga;
-	uint8_t  console_serial;
-} arch_options = {
+struct arch_options_t arch_options = {
 	.reset_vga   = 0,
 	.serial_base = 0x3f8,
 	.serial_baud = 0,
 	.console_vga = 0,
 	.console_serial = 0,
+	.core_header_type = CORE_TYPE_UNDEF,
 };
 
 int arch_process_options(int argc, char **argv)
@@ -198,6 +209,12 @@
 			}
 			arch_options.serial_baud = value;
 			break;
+		case OPT_ELF32_CORE:
+			arch_options.core_header_type = CORE_TYPE_ELF32;
+			break;
+		case OPT_ELF64_CORE:
+			arch_options.core_header_type = CORE_TYPE_ELF64;
+			break;
 		}
 	}
 	/* Reset getopt for the next pass; called in other source modules */
@@ -206,7 +223,7 @@
 	return 0;
 }
 
-int arch_compat_trampoline(struct kexec_info *info, unsigned long *flags)
+int arch_compat_trampoline(struct kexec_info *info)
 {
 	int result;
 	struct utsname utsname;
@@ -224,11 +241,11 @@
 		/* For compatibility with older patches 
 		 * use KEXEC_ARCH_DEFAULT instead of KEXEC_ARCH_386 here.
 		 */
-		*flags |= KEXEC_ARCH_DEFAULT;
+		info->kexec_flags |= KEXEC_ARCH_DEFAULT;
 	}
 	else if (strcmp(utsname.machine, "x86_64") == 0)
 	{
-		*flags |= KEXEC_ARCH_X86_64;
+		info->kexec_flags |= KEXEC_ARCH_X86_64;
 		if (!info->rhdr.e_shdr) {
 			fprintf(stderr, 
 				"A trampoline is required for cross architecture support\n");
@@ -237,7 +254,7 @@
 		elf_rel_set_symbol(&info->rhdr, "compat_x86_64_entry32",
 			&info->entry, sizeof(info->entry));
 		
-		info->entry = elf_rel_get_addr(&info->rhdr, "compat_x86_64");
+		info->entry = (void *)elf_rel_get_addr(&info->rhdr, "compat_x86_64");
 	}
 	else {
 		fprintf(stderr, "Unsupported machine type: %s\n",
@@ -249,6 +266,8 @@
 
 void arch_update_purgatory(struct kexec_info *info)
 {
+	uint8_t panic_kernel = 0;
+
 	elf_rel_set_symbol(&info->rhdr, "reset_vga",
 		&arch_options.reset_vga, sizeof(arch_options.reset_vga));
 	elf_rel_set_symbol(&info->rhdr, "serial_base",
@@ -259,4 +278,11 @@
 		&arch_options.console_vga, sizeof(arch_options.console_vga));
 	elf_rel_set_symbol(&info->rhdr, "console_serial", 
 		&arch_options.console_serial, sizeof(arch_options.console_serial));
+	if (info->kexec_flags & KEXEC_ON_CRASH) {
+		panic_kernel = 1;
+		elf_rel_set_symbol(&info->rhdr, "backup_start",
+				&info->backup_start, sizeof(info->backup_start));
+	}
+	elf_rel_set_symbol(&info->rhdr, "panic_kernel",
+		&panic_kernel, sizeof(panic_kernel));
 }
diff -Nur kexec-tools-1.101/kexec/arch/i386/kexec-x86.h kexec-tools-1.101-geoff/kexec/arch/i386/kexec-x86.h
--- kexec-tools-1.101/kexec/arch/i386/kexec-x86.h	2005-02-06 05:11:32.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/i386/kexec-x86.h	2007-10-23 16:24:40.000000000 +0700
@@ -1,6 +1,14 @@
 #ifndef KEXEC_X86_H
 #define KEXEC_X86_H
 
+#define MAX_MEMORY_RANGES 64
+
+enum coretype {
+	CORE_TYPE_UNDEF = 0,
+	CORE_TYPE_ELF32 = 1,
+	CORE_TYPE_ELF64 = 2
+};
+
 extern unsigned char compat_x86_64[];
 extern uint32_t compat_x86_64_size, compat_x86_64_entry32;
 
@@ -35,6 +43,15 @@
 	uint16_t pad;
 };
 
+struct arch_options_t {
+	uint8_t  	reset_vga;
+	uint16_t 	serial_base;
+	uint32_t 	serial_baud;
+	uint8_t  	console_vga;
+	uint8_t  	console_serial;
+	enum coretype	core_header_type;
+};
+
 int multiboot_x86_probe(const char *buf, off_t len);
 int multiboot_x86_load(int argc, char **argv, const char *buf, off_t len,
 	struct kexec_info *info);
diff -Nur kexec-tools-1.101/kexec/arch/i386/Makefile kexec-tools-1.101-geoff/kexec/arch/i386/Makefile
--- kexec-tools-1.101/kexec/arch/i386/Makefile	2005-02-06 05:23:58.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/i386/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -9,3 +9,4 @@
 KEXEC_C_SRCS+= kexec/arch/i386/kexec-beoboot-x86.c
 KEXEC_C_SRCS+= kexec/arch/i386/kexec-nbi.c
 KEXEC_C_SRCS+= kexec/arch/i386/x86-linux-setup.c
+KEXEC_C_SRCS+= kexec/arch/i386/crashdump-x86.c
diff -Nur kexec-tools-1.101/kexec/arch/i386/x86-linux-setup.c kexec-tools-1.101-geoff/kexec/arch/i386/x86-linux-setup.c
--- kexec-tools-1.101/kexec/arch/i386/x86-linux-setup.c	2005-01-13 19:10:01.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/i386/x86-linux-setup.c	2007-10-23 16:24:40.000000000 +0700
@@ -24,6 +24,8 @@
 #include <sys/stat.h>
 #include <sys/mman.h>
 #include <fcntl.h>
+#include <sys/ioctl.h>
+#include <linux/fb.h>
 #include <unistd.h>
 #include <x86/x86-linux.h>
 #include "../../kexec.h"
@@ -59,6 +61,7 @@
 	initrd_addr_max = DEFAULT_INITRD_ADDR_MAX;
 	if (real_mode->protocol_version >= 0x0203) {
 		initrd_addr_max = real_mode->initrd_addr_max;
+		dbgprintf("initrd_addr_max is 0x%lx\n", initrd_addr_max);
 	}
 
 	/* Load the initrd if we have one */
@@ -66,6 +69,8 @@
 		initrd_base = add_buffer(info,
 			initrd_buf, initrd_size, initrd_size,
 			4096, INITRD_BASE, initrd_addr_max, -1);
+		dbgprintf("Loaded initrd at 0x%lx size 0x%lx\n", initrd_base,
+			initrd_size);
 	} else {
 		initrd_base = 0;
 		initrd_size = 0;
@@ -94,7 +99,59 @@
 	cmdline_ptr[cmdline_len - 1] = '\0';
 }
 
-void setup_linux_system_parameters(struct x86_linux_param_header *real_mode)
+int setup_linux_vesafb(struct x86_linux_param_header *real_mode)
+{
+	struct fb_fix_screeninfo fix;
+	struct fb_var_screeninfo var;
+	static char *magic = "VESA VGA";
+	int fd;
+
+	fd = open("/dev/fb0", O_RDONLY);
+	if (-1 == fd)
+		return -1;
+
+	if (-1 == ioctl(fd, FBIOGET_FSCREENINFO, &fix))
+		goto out;
+	if (-1 == ioctl(fd, FBIOGET_VSCREENINFO, &var))
+		goto out;
+	if (0 != strcmp(fix.id, magic))
+		goto out;
+	close(fd);
+
+	real_mode->orig_video_isVGA = 0x23 /* VIDEO_TYPE_VLFB */;
+	real_mode->lfb_width      = var.xres;
+	real_mode->lfb_height     = var.yres;
+	real_mode->lfb_depth      = var.bits_per_pixel;
+	real_mode->lfb_base       = fix.smem_start;
+	real_mode->lfb_linelength = fix.line_length;
+	real_mode->vesapm_seg     = 0;
+
+	/* FIXME: better get size from /proc/iomem */
+	real_mode->lfb_size       = (fix.smem_len + 65535) / 65536;
+	real_mode->pages          = (fix.smem_len + 4095) / 4096;
+
+	if (var.bits_per_pixel > 8) {
+		real_mode->red_pos    = var.red.offset;
+		real_mode->red_size   = var.red.length;
+		real_mode->green_pos  = var.green.offset;
+		real_mode->green_size = var.green.length;
+		real_mode->blue_pos   = var.blue.offset;
+		real_mode->blue_size  = var.blue.length;
+		real_mode->rsvd_pos   = var.transp.offset;
+		real_mode->rsvd_size  = var.transp.length;
+	}
+	fprintf(stderr, "%s: %dx%dx%d @ %lx +%x\n", __FUNCTION__,
+		var.xres, var.yres, var.bits_per_pixel,
+		fix.smem_start, fix.smem_len);
+	return 0;
+
+ out:
+	close(fd);
+	return -1;
+}
+
+void setup_linux_system_parameters(struct x86_linux_param_header *real_mode,
+					unsigned long kexec_flags)
 {
 	/* Fill in information the BIOS would usually provide */
 	struct memory_range *range;
@@ -110,6 +167,7 @@
 	real_mode->orig_video_ega_bx = 0;
 	real_mode->orig_video_isVGA = 1;
 	real_mode->orig_video_points = 16;
+	setup_linux_vesafb(real_mode);
 
 	/* Fill in the memsize later */
 	real_mode->ext_mem_k = 0;
@@ -135,7 +193,7 @@
 	real_mode->aux_device_info = 0;
 
 	/* Fill in the memory info */
-	if ((get_memory_ranges(&range, &ranges) < 0) || ranges == 0) {
+	if ((get_memory_ranges(&range, &ranges, kexec_flags) < 0) || ranges == 0) {
 		die("Cannot get memory information\n");
 	}
 	if (ranges > E820MAX) {
@@ -164,7 +222,7 @@
 		if (range[i].type != RANGE_RAM)
 			continue;
 		if ((range[i].start <= 0x100000) && range[i].end > 0x100000) {
-			unsigned long long mem_k = (range[i].end >> 10) - 0x100000;
+			unsigned long long mem_k = (range[i].end >> 10) - (0x100000 >> 10);
 			real_mode->ext_mem_k = mem_k;
 			real_mode->alt_mem_k = mem_k;
 			if (mem_k > 0xfc00) {
diff -Nur kexec-tools-1.101/kexec/arch/i386/x86-linux-setup.h kexec-tools-1.101-geoff/kexec/arch/i386/x86-linux-setup.h
--- kexec-tools-1.101/kexec/arch/i386/x86-linux-setup.h	2004-12-20 18:20:22.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/i386/x86-linux-setup.h	2007-10-23 16:24:40.000000000 +0700
@@ -7,7 +7,8 @@
 	unsigned long real_mode_base, unsigned long cmdline_offset,
 	const char *cmdline, off_t cmdline_len,
 	const unsigned char *initrd_buf, off_t initrd_size);
-void setup_linux_system_parameters(struct x86_linux_param_header *real_mode);
+void setup_linux_system_parameters(struct x86_linux_param_header *real_mode,
+					unsigned long kexec_flags);
 
 
 #define SETUP_BASE    0x90000
diff -Nur kexec-tools-1.101/kexec/arch/ia64/crashdump-ia64.c kexec-tools-1.101-geoff/kexec/arch/ia64/crashdump-ia64.c
--- kexec-tools-1.101/kexec/arch/ia64/crashdump-ia64.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/ia64/crashdump-ia64.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,266 @@
+/*
+ * kexec: crashdump support
+ * Copyright (C) 2005-2006 Zou Nan hai <nanhai.zou@intel.com> Intel Corp
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <limits.h>
+#include <elf.h>
+#include "../../kexec.h"
+#include "../../kexec-elf.h"
+#include "../../kexec-syscall.h"
+#include "kexec-ia64.h"
+#include "crashdump-ia64.h"
+#include "../kexec/crashdump.h"
+
+int memory_ranges = 0;
+#define LOAD_OFFSET 	(0xa000000000000000UL + 0x100000000UL -		\
+			 kernel_code_start)
+
+static struct crash_elf_info elf_info =
+{
+	class: ELFCLASS64,
+	data: ELFDATA2LSB,
+	machine: EM_IA_64,
+	page_offset: PAGE_OFFSET,
+};
+
+/* Stores a sorted list of RAM memory ranges for which to create elf headers.
+ * A separate program header is created for backup region.
+ * The number of entries in memory_range array is always smaller than
+ * the number of entries in /proc/iomem, stored in max_memory_ranges. */
+static struct memory_range *crash_memory_range;
+/* Memory region reserved for storing panic kernel and other data. */
+static struct memory_range crash_reserved_mem;
+unsigned long elfcorehdr;
+static unsigned long kernel_code_start;
+static unsigned long kernel_code_end;
+struct loaded_segment {
+        unsigned long start;
+        unsigned long end;
+};
+
+#define MAX_LOAD_SEGMENTS	128
+struct loaded_segment loaded_segments[MAX_LOAD_SEGMENTS];
+
+unsigned long loaded_segments_num, loaded_segments_base;
+static int seg_comp(const void *a, const void *b)
+{
+        const struct loaded_segment *x = a, *y = b;
+        /* avoid overflow */
+        if (x->start > y->start) return 1;
+	if (x->start < y->start) return -1;
+	return 0;
+}
+
+/* purgatory code need this info to patch the EFI memmap
+ */
+static void add_loaded_segments_info(struct kexec_info *info,
+	struct mem_ehdr *ehdr, unsigned long max_addr)
+{
+	 int i;
+         for(i = 0; i < ehdr->e_phnum; i++) {
+                unsigned long start, end;
+                struct mem_phdr *phdr;
+                phdr = &ehdr->e_phdr[i];
+                if (phdr->p_type != PT_LOAD)
+                        continue;
+                start = phdr->p_paddr;
+                end = phdr->p_paddr + phdr->p_memsz;
+
+		loaded_segments[loaded_segments_num].start =
+                        start&~(ELF_PAGE_SIZE-1);
+                loaded_segments[loaded_segments_num].end =
+                        (end + ELF_PAGE_SIZE - 1)&~(ELF_PAGE_SIZE - 1);
+		loaded_segments_num++;
+	}
+}
+
+/* Removes crash reserve region from list of memory chunks for whom elf program
+ * headers have to be created. Assuming crash reserve region to be a single
+ * continuous area fully contained inside one of the memory chunks */
+static int exclude_crash_reserve_region(int *nr_ranges)
+{
+	int i, j, tidx = -1;
+	unsigned long cstart, cend;
+	struct memory_range temp_region;
+
+	/* Crash reserved region. */
+	cstart = crash_reserved_mem.start;
+	cend = crash_reserved_mem.end;
+
+	for (i = 0; i < (*nr_ranges); i++) {
+		unsigned long mstart, mend;
+		mstart = crash_memory_range[i].start;
+		mend = crash_memory_range[i].end;
+		if (cstart < mend && cend > mstart) {
+			if (cstart != mstart && cend != mend) {
+				/* Split memory region */
+				crash_memory_range[i].end = cstart - 1;
+				temp_region.start = cend + 1;
+				temp_region.end = mend;
+				temp_region.type = RANGE_RAM;
+				tidx = i+1;
+			} else if (cstart != mstart)
+				crash_memory_range[i].end = cstart - 1;
+			else
+				crash_memory_range[i].start = cend + 1;
+		}
+	}
+	/* Insert split memory region, if any. */
+	if (tidx >= 0) {
+		if (*nr_ranges == max_memory_ranges) {
+			/* No space to insert another element. */
+			fprintf(stderr, "Error: Number of crash memory ranges"
+					" excedeed the max limit\n");
+			return -1;
+		}
+		for (j = (*nr_ranges - 1); j >= tidx; j--)
+			crash_memory_range[j+1] = crash_memory_range[j];
+		crash_memory_range[tidx].start = temp_region.start;
+		crash_memory_range[tidx].end = temp_region.end;
+		crash_memory_range[tidx].type = temp_region.type;
+		(*nr_ranges)++;
+	}
+	return 0;
+}
+
+static int get_crash_memory_ranges(struct memory_range **range, int *ranges)
+{
+	const char iomem[]= "/proc/iomem";
+        char line[MAX_LINE];
+        FILE *fp;
+        unsigned long start, end;
+
+	crash_memory_range = xmalloc(sizeof(struct memory_range) *
+				max_memory_ranges);
+        fp = fopen(iomem, "r");
+        if (!fp) {
+                fprintf(stderr, "Cannot open %s: %s\n",
+                        iomem, strerror(errno));
+                return -1;
+        }
+	while(fgets(line, sizeof(line), fp) != 0) {
+		char *str;
+		int type, consumed, count;
+		if (memory_ranges >= max_memory_ranges)
+			break;
+		count = sscanf(line, "%lx-%lx : %n",
+				&start, &end, &consumed);
+		str = line + consumed;
+		if (count != 2)
+			continue;
+
+		if (memcmp(str, "System RAM\n", 11) == 0) {
+			type = RANGE_RAM;
+		} else if (memcmp(str, "Crash kernel\n", 13) == 0) {
+			/* Reserved memory region. New kernel can
+			 * use this region to boot into. */
+			crash_reserved_mem.start = start;
+			crash_reserved_mem.end = end;
+			crash_reserved_mem.type = RANGE_RAM;
+			continue;
+		}
+		else if (memcmp(str, "Kernel code\n", 12) == 0) {
+			kernel_code_start = start;
+			kernel_code_end = end;
+			continue;
+		}else
+			continue;
+		crash_memory_range[memory_ranges].start = start;
+		crash_memory_range[memory_ranges].end = end;
+		crash_memory_range[memory_ranges].type = type;
+		memory_ranges++;
+	}
+        fclose(fp);
+	if (exclude_crash_reserve_region(&memory_ranges) < 0)
+		return -1;
+	*ranges = memory_ranges;
+	return 0;
+}
+
+/*
+ * Note that this assignes a malloced pointer to *cmdline,
+ * which is likely never freed by the caller
+ */
+static void
+cmdline_add_elfcorehdr(const char **cmdline, unsigned long addr)
+{
+	char *str;
+	char buf[64];
+	size_t len;
+	sprintf(buf, " elfcorehdr=%ldK", addr/1024);
+	len = strlen(*cmdline) + strlen(buf) + 1;
+	str = xmalloc(len);
+	sprintf(str, "%s%s", *cmdline, buf);
+	*cmdline = str;
+}
+
+int load_crashdump_segments(struct kexec_info *info, struct mem_ehdr *ehdr,
+                            unsigned long max_addr, unsigned long min_base,
+			    const char **cmdline)
+{
+	struct memory_range *mem_range;
+	int nr_ranges;
+	unsigned long sz;
+	size_t size;
+	void *tmp;
+	if (info->kexec_flags & KEXEC_ON_CRASH ) {
+		if (get_crash_memory_ranges(&mem_range, &nr_ranges) == 0) {
+
+			info->kern_paddr_start = kernel_code_start;
+			info->kern_vaddr_start = LOAD_OFFSET;
+			info->kern_size = kernel_code_end - kernel_code_start + 1;
+			if (crash_create_elf64_headers(info, &elf_info,
+						       crash_memory_range,
+						       nr_ranges,
+						       &tmp, &sz,
+						       EFI_PAGE_SIZE) < 0)
+				return -1;
+
+			elfcorehdr = add_buffer(info, tmp, sz, sz,
+						EFI_PAGE_SIZE, min_base,
+						max_addr, -1);
+			loaded_segments[loaded_segments_num].start = elfcorehdr;
+			loaded_segments[loaded_segments_num].end = elfcorehdr +
+								   sz;
+			loaded_segments_num++;
+			cmdline_add_elfcorehdr(cmdline, elfcorehdr);
+		}
+	}
+	add_loaded_segments_info(info, ehdr, max_addr);
+	size = sizeof(struct loaded_segment) * loaded_segments_num;
+	qsort(loaded_segments, loaded_segments_num,
+                        sizeof(struct loaded_segment), seg_comp);
+        loaded_segments_base = add_buffer(info, loaded_segments,
+                        size, size, 16, 0, max_addr, -1);
+
+        elf_rel_set_symbol(&info->rhdr, "__loaded_segments",
+                        &loaded_segments_base, sizeof(long));
+        elf_rel_set_symbol(&info->rhdr, "__loaded_segments_num",
+                         &loaded_segments_num, sizeof(long));
+	return 0;
+}
+
+int is_crashkernel_mem_reserved(void)
+{
+	uint64_t start, end;
+
+	return parse_iomem_single("Crash kernel\n", &start, &end) == 0 ?
+	  (start != end) : 0;
+}
diff -Nur kexec-tools-1.101/kexec/arch/ia64/crashdump-ia64.h kexec-tools-1.101-geoff/kexec/arch/ia64/crashdump-ia64.h
--- kexec-tools-1.101/kexec/arch/ia64/crashdump-ia64.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/ia64/crashdump-ia64.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,12 @@
+#ifndef CRASHDUMP_IA64_H
+#define CRASHDUMP_IA64_H
+
+#define PAGE_OFFSET             0xe000000000000000UL
+#define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
+extern int load_crashdump_segments(struct kexec_info *info,
+		struct mem_ehdr *ehdr, unsigned long max_addr,
+		unsigned long min_base, const char **cmdline);
+
+#define CRASH_MAX_MEMMAP_NR     (KEXEC_MAX_SEGMENTS + 1)
+
+#endif
diff -Nur kexec-tools-1.101/kexec/arch/ia64/kexec-elf-ia64.c kexec-tools-1.101-geoff/kexec/arch/ia64/kexec-elf-ia64.c
--- kexec-tools-1.101/kexec/arch/ia64/kexec-elf-ia64.c	2004-12-22 02:01:37.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/ia64/kexec-elf-ia64.c	2007-10-23 16:24:40.000000000 +0700
@@ -6,6 +6,7 @@
  * Copyright (C) 2004 Silicon Graphics, Inc.
  *   Jesse Barnes <jbarnes@sgi.com>
  * Copyright (C) 2004 Khalid Aziz <khalid.aziz@hp.com> Hewlett Packard Co
+ * Copyright (C) 2005 Zou Nan hai <nanhai.zou@intel.com> Intel Corp
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -34,14 +35,24 @@
 #include <fcntl.h>
 #include <unistd.h>
 #include <getopt.h>
+#include <limits.h>
 #include <elf.h>
 #include <boot/elf_boot.h>
 #include <ip_checksum.h>
 #include "../../kexec.h"
+#include "../../kexec-syscall.h"
 #include "../../kexec-elf.h"
+#include "kexec-ia64.h"
+#include "crashdump-ia64.h"
 #include <arch/options.h>
 
+#define OPT_APPEND	(OPT_ARCH_MAX+0)
+#define OPT_RAMDISK	(OPT_ARCH_MAX+1)
+#define OPT_NOIO	(OPT_ARCH_MAX+2)
+#define OPT_VMM		(OPT_ARCH_MAX+3)
+
 static const int probe_debug = 0;
+extern unsigned long saved_efi_memmap_size;
 
 /*
  * elf_ia64_probe - sanity check the elf image
@@ -52,7 +63,7 @@
 {
 	struct mem_ehdr ehdr;
 	int result;
-	result = build_elf_exec_info(buf, len, &ehdr);
+	result = build_elf_exec_info(buf, len, &ehdr, 0);
 	if (result < 0) {
 		if (probe_debug) {
 			fprintf(stderr, "Not an ELF executable\n");
@@ -72,32 +83,72 @@
 
 void elf_ia64_usage(void)
 {
-	printf(
-		"    --command-line=STRING Set the kernel command line to STRING.\n"
-		"    --append=STRING       Set the kernel command line to STRING.\n");
+	printf("    --command-line=STRING Set the kernel command line to "
+			"STRING.\n"
+	       "    --append=STRING       Set the kernel command line to "
+			"STRING.\n"
+	       "    --initrd=FILE         Use FILE as the kernel's initial "
+			"ramdisk.\n"
+	       "    --noio                Disable I/O in purgatory code.\n"
+	       "    --vmm=FILE            Use FILE as the kernel image for a\n"
+	       "                          virtual machine monitor "
+			"(aka hypervisor)\n");
+}
+
+/* Move the crash kerenl physical offset to reserved region
+ */
+void move_loaded_segments(struct kexec_info *info, struct mem_ehdr *ehdr,
+			  unsigned long addr)
+{
+	int i;
+	long offset;
+	struct mem_phdr *phdr;
+	for(i = 0; i < ehdr->e_phnum; i++) {
+		phdr = &ehdr->e_phdr[i];
+		if (phdr->p_type == PT_LOAD) {
+			offset = addr - phdr->p_paddr;
+			break;
+		}
+	}
+	ehdr->e_entry += offset;
+	for(i = 0; i < ehdr->e_phnum; i++) {
+		phdr = &ehdr->e_phdr[i];
+		if (phdr->p_type == PT_LOAD)
+			phdr->p_paddr += offset;
+	}
 }
 
 int elf_ia64_load(int argc, char **argv, const char *buf, off_t len,
 	struct kexec_info *info)
 {
 	struct mem_ehdr ehdr;
-	const char *command_line;
-	int command_line_len;
-	unsigned long entry, max_addr;
+	const char *command_line, *ramdisk=0, *vmm=0, *kernel_buf;
+	char *ramdisk_buf = NULL;
+	off_t ramdisk_size = 0, kernel_size;
+	unsigned long command_line_len;
+	unsigned long entry, max_addr, gp_value;
+	unsigned long command_line_base, ramdisk_base, image_base;
+	unsigned long efi_memmap_base, efi_memmap_size;
+	unsigned long boot_param_base;
+	unsigned long noio=0;
 	int result;
 	int opt;
-#define OPT_APPEND	(OPT_ARCH_MAX+0)
+	char *efi_memmap_buf, *boot_param;
 	static const struct option options[] = {
 		KEXEC_ARCH_OPTIONS
 		{"command-line", 1, 0, OPT_APPEND},
 		{"append",       1, 0, OPT_APPEND},
+		{"initrd",       1, 0, OPT_RAMDISK},
+		{"noio",         0, 0, OPT_NOIO},
+		{"vmm",          1, 0, OPT_VMM},
 		{0, 0, 0, 0},
 	};
 
 	static const char short_options[] = KEXEC_ARCH_OPT_STR "";
 
 	command_line = 0;
-	while ((opt = getopt_long(argc, argv, short_options, options, 0)) != -1) {
+	while ((opt = getopt_long(argc, argv, short_options,
+				  options, 0)) != -1) {
 		switch (opt) {
 		default:
 			/* Ignore core options */
@@ -110,32 +161,147 @@
 		case OPT_APPEND:
 			command_line = optarg;
 			break;
+		case OPT_RAMDISK:
+			ramdisk = optarg;
+			break;
+		case OPT_NOIO:	/* disable PIO and MMIO in purgatory code*/
+			noio = 1;
+			break;
+		case OPT_VMM:
+			vmm = optarg;
+			break;
 		}
 	}
 	command_line_len = 0;
 	if (command_line) {
-		command_line_len = strlen(command_line) + 1;
+		command_line_len = strlen(command_line) + 16;
+	}
+
+	if (vmm)
+		kernel_buf = slurp_decompress_file(vmm, &kernel_size);
+	else {
+		kernel_buf = buf;
+		kernel_size = len;
 	}
 
 	/* Parse the Elf file */
-	result = build_elf_exec_info(buf, len, &ehdr);
+	result = build_elf_exec_info(kernel_buf, kernel_size, &ehdr, 0);
 	if (result < 0) {
 		fprintf(stderr, "ELF parse failed\n");
 		free_elf_info(&ehdr);
 		return result;
 	}
+
+	if (info->kexec_flags & KEXEC_ON_CRASH ) {
+		if ((mem_min == 0x00) && (mem_max == ULONG_MAX)) {
+			fprintf(stderr, "Failed to find crash kernel region "
+				"in /proc/iomem\n");
+			free_elf_info(&ehdr);
+			return -1;
+		}
+		move_loaded_segments(info, &ehdr, mem_min);
+	} else if (update_loaded_segments(info, &ehdr) < 0) {
+		fprintf(stderr, "Failed to place kernel\n");
+		return -1;
+	}
+
 	entry = ehdr.e_entry;
 	max_addr = elf_max_addr(&ehdr);
 
 	/* Load the Elf data */
 	result = elf_exec_load(&ehdr, info);
-	free_elf_info(&ehdr);
 	if (result < 0) {
 		fprintf(stderr, "ELF load failed\n");
+		free_elf_info(&ehdr);
 		return result;
 	}
+
+
+	/* Load the setup code */
+	elf_rel_build_load(info, &info->rhdr, purgatory, purgatory_size,
+			0x0, ULONG_MAX, -1, 0);
+
+
+	if (load_crashdump_segments(info, &ehdr, max_addr, 0,
+				&command_line) < 0)
+		return -1;
+
+	// reverve 4k for ia64_boot_param
+	boot_param = xmalloc(4096);
+        boot_param_base = add_buffer(info, boot_param, 4096, 4096, 4096, 0,
+                        max_addr, -1);
+
+	elf_rel_set_symbol(&info->rhdr, "__noio",
+			   &noio, sizeof(long));
+
+        elf_rel_set_symbol(&info->rhdr, "__boot_param_base",
+                        &boot_param_base, sizeof(long));
+
+	// reserve efi_memmap of actual size allocated in production kernel
+	efi_memmap_size = saved_efi_memmap_size;
+	efi_memmap_buf = xmalloc(efi_memmap_size);
+	efi_memmap_base = add_buffer(info, efi_memmap_buf,
+			efi_memmap_size, efi_memmap_size, 4096, 0,
+			max_addr, -1);
+
+	elf_rel_set_symbol(&info->rhdr, "__efi_memmap_base",
+			&efi_memmap_base, sizeof(long));
+
+	elf_rel_set_symbol(&info->rhdr, "__efi_memmap_size",
+			&efi_memmap_size, sizeof(long));
+	if (command_line) {
+		command_line_len = strlen(command_line) + 1;
+	}
+	if (command_line_len || (info->kexec_flags & KEXEC_ON_CRASH )) {
+		char *cmdline = xmalloc(command_line_len);
+		strcpy(cmdline, command_line);
+
+		if (info->kexec_flags & KEXEC_ON_CRASH) {
+			char buf[128];
+			sprintf(buf," max_addr=%lluM min_addr=%lluM",
+					mem_max>>20, mem_min>>20);
+			command_line_len = strlen(cmdline) + strlen(buf) + 1;
+			cmdline = xrealloc(cmdline, command_line_len);
+			strcat(cmdline, buf);
+		}
+
+		command_line_len = (command_line_len + 15)&(~15);
+		command_line_base = add_buffer(info, cmdline,
+				command_line_len, command_line_len,
+				getpagesize(), 0UL,
+				max_addr, -1);
+		elf_rel_set_symbol(&info->rhdr, "__command_line_len",
+				&command_line_len, sizeof(long));
+		elf_rel_set_symbol(&info->rhdr, "__command_line",
+				&command_line_base, sizeof(long));
+	}
 	
-	/* For now we don't have arguments to pass :( */
-	info->entry = (void *)entry;
+	if (ramdisk) {
+		ramdisk_buf = slurp_file(ramdisk, &ramdisk_size);
+		ramdisk_base = add_buffer(info, ramdisk_buf, ramdisk_size,
+				ramdisk_size,
+				getpagesize(), 0, max_addr, -1);
+		elf_rel_set_symbol(&info->rhdr, "__ramdisk_base",
+				&ramdisk_base, sizeof(long));
+		elf_rel_set_symbol(&info->rhdr, "__ramdisk_size",
+				&ramdisk_size, sizeof(long));
+	}
+
+	if (vmm) {
+		image_base = add_buffer(info, buf, len, len,
+				getpagesize(), 0, max_addr, -1);
+		elf_rel_set_symbol(&info->rhdr, "__vmcode_base",
+				&image_base, sizeof(long));
+		elf_rel_set_symbol(&info->rhdr, "__vmcode_size",
+				&len, sizeof(long));
+	}
+
+	gp_value = info->rhdr.rel_addr + 0x200000;
+        elf_rel_set_symbol(&info->rhdr, "__gp_value", &gp_value,
+                        sizeof(gp_value));
+
+	elf_rel_set_symbol(&info->rhdr, "__kernel_entry", &entry,
+			   sizeof(entry));
+	free_elf_info(&ehdr);
 	return 0;
 }
diff -Nur kexec-tools-1.101/kexec/arch/ia64/kexec-elf-rel-ia64.c kexec-tools-1.101-geoff/kexec/arch/ia64/kexec-elf-rel-ia64.c
--- kexec-tools-1.101/kexec/arch/ia64/kexec-elf-rel-ia64.c	2004-12-21 04:43:23.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/ia64/kexec-elf-rel-ia64.c	2007-10-23 16:24:40.000000000 +0700
@@ -1,8 +1,37 @@
+/*
+ * Copyright (C) 2005-2006  Zou Nan hai (nanhai.zou@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*  pugatory relocation code
+ *  Most of the code in this file is
+ *  based on arch/ia64/kernel/module.c in Linux kernel
+ */
+
+
+/*  Most of the code in this file is
+ *  based on arch/ia64/kernel/module.c in Linux kernel
+ */
+
 #include <stdio.h>
 #include <elf.h>
 #include "../../kexec.h"
 #include "../../kexec-elf.h"
 
+#define MAX_LTOFF       ((uint64_t) (1 << 22))
+
 int machine_verify_elf_rel(struct mem_ehdr *ehdr)
 {
 	if (ehdr->ei_data != ELFDATA2LSB) {
@@ -17,12 +46,49 @@
 	return 1;
 }
 
+static void
+ia64_patch (uint64_t insn_addr, uint64_t mask, uint64_t val)
+{
+        uint64_t m0, m1, v0, v1, b0, b1, *b = (uint64_t *) (insn_addr & -16);
+#       define insn_mask ((1UL << 41) - 1)
+        unsigned long shift;
+
+        b0 = b[0]; b1 = b[1];
+        shift = 5 + 41 * (insn_addr % 16); /* 5 bits of template, then 3 x 41-bit instructions */
+        if (shift >= 64) {
+                m1 = mask << (shift - 64);
+                v1 = val << (shift - 64);
+        } else {
+                m0 = mask << shift; m1 = mask >> (64 - shift);
+                v0 = val  << shift; v1 = val >> (64 - shift);
+                b[0] = (b0 & ~m0) | (v0 & m0);
+        }
+        b[1] = (b1 & ~m1) | (v1 & m1);
+}
+
+static void
+put_unaligned64(unsigned long val, unsigned char *location)
+{
+	unsigned char *src = (unsigned char *)&val;
+	int i;
+	for (i = 0; i < sizeof(long); i++)
+		*location++ = *src++;
+}
+
+static inline uint64_t
+bundle (const uint64_t insn)
+{
+        return insn & ~0xfUL;
+}
+
 void machine_apply_elf_rel(struct mem_ehdr *ehdr, unsigned long r_type,
 	void *location, unsigned long address, unsigned long value)
 {
+	uint64_t gp_value = ehdr->rel_addr + 0x200000;
 	switch(r_type) {
 	case R_IA64_NONE:
 		break;
+	case R_IA64_SEGREL64LSB:
 	case R_IA64_DIR64LSB:
 		*((uint64_t *)location) = value;
 		break;
@@ -31,15 +97,72 @@
 		if (value != *((uint32_t *)location))
 			goto overflow;
 		break;
-	case R_IA64_PCREL21B:
+	case R_IA64_IMM64:
+		ia64_patch((uint64_t)location, 0x01fffefe000UL,
+				/* bit 63 -> 36 */
+				(((value & 0x8000000000000000UL) >> 27)
+				/* bit 21 -> 21 */
+				  | ((value & 0x0000000000200000UL) <<  0)
+				/* bit 16 -> 22 */
+				  | ((value & 0x00000000001f0000UL) <<  6)
+				/* bit 7 -> 27 */
+				  | ((value & 0x000000000000ff80UL) << 20)
+				/* bit 0 -> 13 */
+				  | ((value & 0x000000000000007fUL) << 13)));
+		ia64_patch((uint64_t)location - 1, 0x1ffffffffffUL, value>>22);
+		break;
+	case R_IA64_IMM22:
+		if (value + (1 << 21) >= (1 << 22))
+                	die("value out of IMM22 range\n");
+		ia64_patch((uint64_t)location, 0x01fffcfe000UL,
+				/* bit 21 -> 36 */
+				(((value & 0x200000UL) << 15)
+				/* bit 16 -> 22 */
+				 | ((value & 0x1f0000UL) <<  6)
+				/* bit  7 -> 27 */
+				 | ((value & 0x00ff80UL) << 20)
+				/* bit  0 -> 13 */
+				 | ((value & 0x00007fUL) << 13) ));
+		break;
+	case R_IA64_PCREL21B: {
+		uint64_t delta = ((int64_t)value - (int64_t)address)/16;
+		if (delta + (1 << 20) >= (1 << 21))
+			die("value out of IMM21B range\n");
+		value = ((int64_t)(value - bundle(address)))/16;
+		ia64_patch((uint64_t)location, 0x11ffffe000UL,
+				(((value & 0x100000UL) << 16) /* bit 20 -> 36 */
+				 | ((value & 0x0fffffUL) << 13) /* bit  0 -> 13 */));
+		}
+		break;
+	case R_IA64_PCREL64LSB: {
+		value = value - address;
+		put_unaligned64(value, location);
+	} break;
+	case R_IA64_GPREL22:
+	case R_IA64_LTOFF22X:
+		if (value - gp_value + MAX_LTOFF/2 >= MAX_LTOFF)
+			die("value out of gp relative range");
+		value -= gp_value;
+		ia64_patch((uint64_t)location, 0x01fffcfe000UL,
+				(((value & 0x200000UL) << 15) /* bit 21 -> 36 */
+				   |((value & 0x1f0000UL) <<  6) /* bit 16 -> 22 */
+				   |((value & 0x00ff80UL) << 20) /* bit  7 -> 27 */
+				   |((value & 0x00007fUL) << 13) /* bit  0 -> 13 */));
+		break;
+	case R_IA64_LDXMOV:
+		if (value - gp_value + MAX_LTOFF/2 >= MAX_LTOFF)
+			die("value out of gp relative range");
+		ia64_patch((uint64_t)location, 0x1fff80fe000UL, 0x10000000000UL);
+	        break;
 	case R_IA64_LTOFF22:
-	case R_IA64_SEGREL64LSB:
+
 	default:
-		die("Unknown rela relocation: %lu\n", r_type);
+		die("Unknown rela relocation: 0x%lx 0x%lx\n",
+				r_type, address);
 		break;
 	}
 	return;
- overflow:
+overflow:
 	die("overflow in relocation type %lu val %Lx\n", 
-		r_type, value);
+			r_type, value);
 }
diff -Nur kexec-tools-1.101/kexec/arch/ia64/kexec-ia64.c kexec-tools-1.101-geoff/kexec/arch/ia64/kexec-ia64.c
--- kexec-tools-1.101/kexec/arch/ia64/kexec-ia64.c	2005-01-11 12:28:36.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/ia64/kexec-ia64.c	2007-10-23 16:24:40.000000000 +0700
@@ -27,42 +27,141 @@
 #include <stdint.h>
 #include <string.h>
 #include <getopt.h>
+#include <sched.h>
 #include <sys/utsname.h>
+#include <limits.h>
 #include "../../kexec.h"
 #include "../../kexec-syscall.h"
+#include "elf.h"
 #include "kexec-ia64.h"
 #include <arch/options.h>
 
-#define MAX_MEMORY_RANGES 64
-#define MAX_LINE 160
-static struct memory_range memory_range[MAX_MEMORY_RANGES];
+/* The number of entries in memory_range array is always smaller than
+   the number of entries in /proc/iomem, stored in max_memory_ranges. */
+static struct memory_range *memory_range;
+int max_memory_ranges;
+static int memory_ranges;
+unsigned long saved_efi_memmap_size;
+
+/* Reserve range for EFI memmap and Boot parameter */
+static int split_range(int range, unsigned long start, unsigned long end)
+{
+	unsigned long ram_end = memory_range[range - 1].end;
+	unsigned int type = memory_range[range - 1].type;
+	int i;
+	//align end and start to page size of EFI
+	start = start & ~((1UL<<12) - 1);
+	end = (end + (1UL<<12) - 1)& ~((1UL<<12) - 1);
+	for (i = 0; i < range; i++)
+		if(memory_range[i].start <= start && memory_range[i].end >=end)
+			break;
+	if (i >= range)
+		return range;
+	range = i;
+	if (memory_range[range].start < start) {
+		memory_range[range].end = start;
+		range++;
+	}
+	memory_range[range].start = start;
+	memory_range[range].end = end;
+	memory_range[range].type = RANGE_RESERVED;
+	range++;
+	if (end < ram_end) {
+		memory_range[range].start = end;
+		memory_range[range].end = ram_end;
+		memory_range[range].type = type;
+		range++;
+	}
+	return range;
+}
 
 /* Return a sorted list of available memory ranges. */
-int get_memory_ranges(struct memory_range **range, int *ranges)
+int get_memory_ranges(struct memory_range **range, int *ranges,
+				unsigned long kexec_flags)
 {
-	int memory_ranges;
-	/*
-	 * /proc/iomem on ia64 does not show where all memory is. If
-	 * that is fixed up, we can make use of that to validate
-	 * the memory range kernel will be loade din. Until then.....
-	 * -- Khalid Aziz
-	 */
-	
-	/* Note that the ia64 architecture mandates all systems will
-	 * have at least 64MB at 0-64M.  The SGI altix does not follow
-	 * that restriction, but a reasonable guess is better than nothing
-	 * at all.
-	 * -- Eric Biederman
-	 */
-	fprintf(stderr, "Warning assuming memory at 0-64MB is present\n");
-	memory_ranges = 0;
-	memory_range[memory_ranges].start = 0x00010000;
-	memory_range[memory_ranges].end   = 0x10000000;
-	memory_range[memory_ranges].type  = RANGE_RAM;
-	memory_ranges++;
-	*range = memory_range;
-	*ranges = memory_ranges;
-	return 0;
+	const char iomem[]= "/proc/iomem";
+	char line[MAX_LINE];
+	FILE *fp;
+	fp = fopen(iomem, "r");
+	if (!fp) {
+		fprintf(stderr, "Cannot open %s: %s\n",
+			iomem, strerror(errno));
+		return -1;
+	}
+
+	/* allocate memory_range dynamically */
+	max_memory_ranges = 0;
+	while(fgets(line, sizeof(line), fp) != 0) {
+		max_memory_ranges++;
+	}
+	memory_range = xmalloc(sizeof(struct memory_range) *
+			max_memory_ranges);
+	rewind(fp);
+
+	while(fgets(line, sizeof(line), fp) != 0) {
+		unsigned long start, end;
+		char *str;
+		int type;
+		int consumed;
+		int count;
+		if (memory_ranges >= max_memory_ranges)
+			break;
+		count = sscanf(line, "%lx-%lx : %n",
+				&start, &end, &consumed);
+		if (count != 2)
+			continue;
+		str = line + consumed;
+		end = end + 1;
+		if (memcmp(str, "System RAM\n", 11) == 0) {
+			type = RANGE_RAM;
+		}
+		else if (memcmp(str, "reserved\n", 9) == 0) {
+			type = RANGE_RESERVED;
+		}
+		else if (memcmp(str, "Crash kernel\n", 13) == 0) {
+			/* Redefine the memory region boundaries if kernel
+			 * exports the limits and if it is panic kernel.
+			 * Override user values only if kernel exported
+			 * values are subset of user defined values.
+			 */
+
+			if (kexec_flags & KEXEC_ON_CRASH) {
+				if (start > mem_min)
+					mem_min = start;
+				if (end < mem_max)
+					mem_max = end;
+			}
+			continue;
+		} else if (memcmp(str, "Boot parameter\n", 14) == 0) {
+			memory_ranges = split_range(memory_ranges, start, end);
+			continue;
+		} else if (memcmp(str, "EFI Memory Map\n", 14) == 0) {
+			memory_ranges = split_range(memory_ranges, start, end);
+			saved_efi_memmap_size = end - start;
+			continue;
+		} else
+			continue;
+		/*
+		 * Check if this memory range can be coalesced with
+		 * the previous range
+		 */
+		if ((memory_ranges > 0) &&
+			(start == memory_range[memory_ranges-1].end) &&
+			(type == memory_range[memory_ranges-1].type)) {
+			memory_range[memory_ranges-1].end = end;
+		}
+		else {
+			memory_range[memory_ranges].start = start;
+			memory_range[memory_ranges].end = end;
+			memory_range[memory_ranges].type = type;
+			memory_ranges++;
+		}
+	}
+	fclose(fp);
+ 	*range = memory_range;
+ 	*ranges = memory_ranges;
+
+ 	return 0;
 }
 
 /* Supported file types and callbacks */
@@ -76,19 +175,20 @@
 {
 }
 
-static struct {
-} arch_options = {
-};
 int arch_process_options(int argc, char **argv)
 {
 	static const struct option options[] = {
 		KEXEC_ARCH_OPTIONS
-		{ 0, 			0, NULL, 0 },
+		{ 0, 0, NULL, 0 },
 	};
 	static const char short_options[] = KEXEC_ARCH_OPT_STR;
 	int opt;
-	unsigned long value;
-	char *end;
+
+	/* execute from monarch processor */
+        cpu_set_t affinity;
+	CPU_ZERO(&affinity);
+	CPU_SET(0, &affinity);
+        sched_setaffinity(0, sizeof(affinity), &affinity);
 
 	opterr = 0; /* Don't complain about unrecognized options here */
 	while((opt = getopt_long(argc, argv, short_options, options, 0)) != -1) {
@@ -103,7 +203,7 @@
 	return 0;
 }
 
-int arch_compat_trampoline(struct kexec_info *info, unsigned long *flags)
+int arch_compat_trampoline(struct kexec_info *info)
 {
 	int result;
 	struct utsname utsname;
@@ -115,7 +215,7 @@
 	}
 	if (strcmp(utsname.machine, "ia64") == 0)
 	{
-		*flags |= KEXEC_ARCH_X86_64;
+		info->kexec_flags |= KEXEC_ARCH_IA_64;
 	}
 	else {
 		fprintf(stderr, "Unsupported machine type: %s\n",
@@ -125,29 +225,43 @@
 	return 0;
 }
 
-int arch_compat_trampoline(struct kexec_info *info, unsigned long *flags)
+int update_loaded_segments(struct kexec_info *info, struct mem_ehdr *ehdr)
 {
-	int result;
-	struct utsname utsname;
-	result = uname(&utsname);
-	if (result < 0) {
-		fprintf(stderr, "uname failed: %s\n",
-			strerror(errno));
-		return -1;
-	}
-	if (strcmp(utsname.machine, "ia64") == 0)
-	{
-		/* For compatibility with older patches 
-		 * use KEXEC_ARCH_DEFAULT instead of KEXEC_ARCH_IA64 here.
-		 */
-		*flags |= KEXEC_ARCH_DEFAULT;
-	}
-	else {
-		fprintf(stderr, "Unsupported machine type: %s\n",
-			utsname.machine);
-		return -1;
+	int i;
+	struct mem_phdr *phdr;
+	unsigned long start_addr = ULONG_MAX, end_addr = 0;
+	unsigned long align = 1UL<<26; /* 64M */
+	unsigned long start, end;
+
+	for (i = 0; i < ehdr->e_phnum; i++) {
+		phdr = &ehdr->e_phdr[i];
+		if (phdr->p_type != PT_LOAD)
+			continue;
+		if (phdr->p_paddr < start_addr)
+			start_addr = phdr->p_paddr;
+		if ((phdr->p_paddr + phdr->p_memsz) > end_addr)
+			end_addr = phdr->p_paddr + phdr->p_memsz;
+	}
+
+	for (i = 0; i < memory_ranges && memory_range[i].start <= start_addr;
+	     i++) {
+		if (memory_range[i].type == RANGE_RAM &&
+		    memory_range[i].end > end_addr)
+			return 0;
+	}
+
+	for (i = 0; i < memory_ranges; i++) {
+		if (memory_range[i].type != RANGE_RAM)
+			continue;
+		start = (memory_range[i].start + align - 1) & ~(align - 1);
+		end = memory_range[i].end;
+		if (end > start && (end - start) > (end_addr - start_addr)) {
+		    move_loaded_segments(info, ehdr, start);
+			return 0;
+		}
 	}
-	return 0;
+
+	return -1;
 }
 
 void arch_update_purgatory(struct kexec_info *info)
diff -Nur kexec-tools-1.101/kexec/arch/ia64/kexec-ia64.h kexec-tools-1.101-geoff/kexec/arch/ia64/kexec-ia64.h
--- kexec-tools-1.101/kexec/arch/ia64/kexec-ia64.h	2004-12-20 05:52:38.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/ia64/kexec-ia64.h	2007-10-23 16:24:40.000000000 +0700
@@ -1,9 +1,15 @@
 #ifndef KEXEC_IA64_H
 #define KEXEC_IA64_H
 
+extern int max_memory_ranges;
 int elf_ia64_probe(const char *buf, off_t len);
 int elf_ia64_load(int argc, char **argv, const char *buf, off_t len,
 	struct kexec_info *info);
 void elf_ia64_usage(void);
+int update_loaded_segments(struct kexec_info *info, struct mem_ehdr *ehdr);
+void move_loaded_segments(struct kexec_info *info, struct mem_ehdr *ehdr,
+			  unsigned long addr);
 
+#define EFI_PAGE_SIZE	  (1UL<<12)
+#define ELF_PAGE_SIZE	  (1UL<<16)
 #endif /* KEXEC_IA64_H */
diff -Nur kexec-tools-1.101/kexec/arch/ia64/Makefile kexec-tools-1.101-geoff/kexec/arch/ia64/Makefile
--- kexec-tools-1.101/kexec/arch/ia64/Makefile	2004-12-20 06:11:13.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/ia64/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -4,3 +4,5 @@
 KEXEC_C_SRCS+= kexec/arch/ia64/kexec-ia64.c 
 KEXEC_C_SRCS+= kexec/arch/ia64/kexec-elf-ia64.c 
 KEXEC_C_SRCS+= kexec/arch/ia64/kexec-elf-rel-ia64.c
+KEXEC_C_SRCS+= kexec/arch/ia64/crashdump-ia64.c
+
diff -Nur kexec-tools-1.101/kexec/arch/ppc/kexec-elf-ppc.c kexec-tools-1.101-geoff/kexec/arch/ppc/kexec-elf-ppc.c
--- kexec-tools-1.101/kexec/arch/ppc/kexec-elf-ppc.c	2005-01-21 01:10:56.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/ppc/kexec-elf-ppc.c	2007-10-23 16:24:40.000000000 +0700
@@ -72,7 +72,7 @@
 
 	struct mem_ehdr ehdr;
 	int result;
-	result = build_elf_exec_info(buf, len, &ehdr);
+	result = build_elf_exec_info(buf, len, &ehdr, 0);
 	if (result < 0) {
 		goto out;
 	}
@@ -180,7 +180,7 @@
 	}
 
 	/* Parse the Elf file */
-	result = build_elf_exec_info(buf, len, &ehdr);
+	result = build_elf_exec_info(buf, len, &ehdr, 0);
 	if (result < 0) {
 		free_elf_info(&ehdr);
 		return result;
diff -Nur kexec-tools-1.101/kexec/arch/ppc/kexec-ppc.c kexec-tools-1.101-geoff/kexec/arch/ppc/kexec-ppc.c
--- kexec-tools-1.101/kexec/arch/ppc/kexec-ppc.c	2005-01-11 12:28:03.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/ppc/kexec-ppc.c	2007-10-23 16:24:40.000000000 +0700
@@ -19,11 +19,11 @@
 #include <arch/options.h>
 
 #define MAX_MEMORY_RANGES  64
-#define MAX_LINE          160
 static struct memory_range memory_range[MAX_MEMORY_RANGES];
 
 /* Return a sorted list of memory ranges. */
-int get_memory_ranges(struct memory_range **range, int *ranges)
+int get_memory_ranges(struct memory_range **range, int *ranges,
+					unsigned long kexec_flags)
 {
 	int memory_ranges = 0;
 #ifdef CONFIG_GAMECUBE
@@ -93,9 +93,6 @@
 {
 }
 
-static struct {
-} arch_options = {
-};
 int arch_process_options(int argc, char **argv)
 {
 	static const struct option options[] = {
@@ -104,8 +101,6 @@
 	};
 	static const char short_options[] = KEXEC_ARCH_OPT_STR;
 	int opt;
-	unsigned long value;
-	char *end;
 
 	opterr = 0; /* Don't complain about unrecognized options here */
 	while((opt = getopt_long(argc, argv, short_options, options, 0)) != -1) {
@@ -120,7 +115,7 @@
 	return 0;
 }
 
-int arch_compat_trampoline(struct kexec_info *info, unsigned long *flags)
+int arch_compat_trampoline(struct kexec_info *info)
 {
 	int result;
 	struct utsname utsname;
@@ -135,7 +130,7 @@
 		/* For compatibility with older patches 
 		 * use KEXEC_ARCH_DEFAULT instead of KEXEC_ARCH_PPC here.
 		 */
-		*flags |= KEXEC_ARCH_DEFAULT;
+		info->kexec_flags |= KEXEC_ARCH_DEFAULT;
 	}
 	else {
 		fprintf(stderr, "Unsupported machine type: %s\n",
@@ -149,3 +144,7 @@
 {
 }
 
+int is_crashkernel_mem_reserved(void)
+{
+	return 0; /* kdump is not supported on this platform (yet) */
+}
diff -Nur kexec-tools-1.101/kexec/arch/ppc64/crashdump-ppc64.c kexec-tools-1.101-geoff/kexec/arch/ppc64/crashdump-ppc64.c
--- kexec-tools-1.101/kexec/arch/ppc64/crashdump-ppc64.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/ppc64/crashdump-ppc64.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,444 @@
+/*
+ * kexec: Linux boots Linux
+ *
+ * Created by: R Sharada (sharada@in.ibm.com)
+ * Copyright (C) IBM Corporation, 2005. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <limits.h>
+#include <elf.h>
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include "../../kexec.h"
+#include "../../kexec-elf.h"
+#include "../../kexec-syscall.h"
+#include "../../crashdump.h"
+#include "kexec-ppc64.h"
+#include "crashdump-ppc64.h"
+
+static struct crash_elf_info elf_info64 =
+{
+	class: ELFCLASS64,
+	data: ELFDATA2MSB,
+	machine: EM_PPC64,
+	backup_src_start: BACKUP_SRC_START,
+	backup_src_end: BACKUP_SRC_END,
+	page_offset: PAGE_OFFSET,
+	lowmem_limit: MAXMEM,
+};
+
+static struct crash_elf_info elf_info32 =
+{
+	class: ELFCLASS32,
+	data: ELFDATA2MSB,
+	machine: EM_PPC64,
+	backup_src_start: BACKUP_SRC_START,
+	backup_src_end: BACKUP_SRC_END,
+	page_offset: PAGE_OFFSET,
+	lowmem_limit: MAXMEM,
+};
+
+extern struct arch_options_t arch_options;
+
+/* Stores a sorted list of RAM memory ranges for which to create elf headers.
+ * A separate program header is created for backup region
+ */
+static struct memory_range *crash_memory_range = NULL;
+
+/* Define a variable to replace the CRASH_MAX_MEMORY_RANGES macro */
+static int crash_max_memory_ranges;
+
+/*
+ * Used to save various memory ranges/regions needed for the captured
+ * kernel to boot. (lime memmap= option in other archs)
+ */
+mem_rgns_t usablemem_rgns = {0, NULL};
+
+/*
+ * To store the memory size of the first kernel and this value will be
+ * passed to the second kernel as command line (savemaxmem=xM).
+ * The second kernel will be calculated saved_max_pfn based on this
+ * variable.
+ * Since we are creating/using usable-memory property, there is no way
+ * we can determine the RAM size unless parsing the device-tree/memoy@/reg
+ * property in the kernel.
+ */
+unsigned long saved_max_mem = 0;
+
+/* Reads the appropriate file and retrieves the SYSTEM RAM regions for whom to
+ * create Elf headers. Keeping it separate from get_memory_ranges() as
+ * requirements are different in the case of normal kexec and crashdumps.
+ *
+ * Normal kexec needs to look at all of available physical memory irrespective
+ * of the fact how much of it is being used by currently running kernel.
+ * Crashdumps need to have access to memory regions actually being used by
+ * running  kernel. Expecting a different file/data structure than /proc/iomem
+ * to look into down the line. May be something like /proc/kernelmem or may
+ * be zone data structures exported from kernel.
+ */
+static int get_crash_memory_ranges(struct memory_range **range, int *ranges)
+{
+
+	int memory_ranges = 0;
+	char device_tree[256] = "/proc/device-tree/";
+	char fname[256];
+	char buf[MAXBYTES-1];
+	DIR *dir, *dmem;
+	FILE *file;
+	struct dirent *dentry, *mentry;
+	int i, n, crash_rng_len = 0;
+	unsigned long long start, end, cstart, cend;
+
+	crash_max_memory_ranges = max_memory_ranges + 6;
+	crash_rng_len = sizeof(struct memory_range) * crash_max_memory_ranges;
+
+	crash_memory_range = (struct memory_range *) malloc(crash_rng_len);
+	if (!crash_memory_range) {
+		fprintf(stderr, "Allocation for crash memory range failed\n");
+		return -1;
+	}
+	memset(crash_memory_range, 0, crash_rng_len);
+
+	/* create a separate program header for the backup region */
+	crash_memory_range[0].start = BACKUP_SRC_START;
+	crash_memory_range[0].end = BACKUP_SRC_END + 1;
+	crash_memory_range[0].type = RANGE_RAM;
+	memory_ranges++;
+
+	if ((dir = opendir(device_tree)) == NULL) {
+		perror(device_tree);
+		goto err;
+	}
+	while ((dentry = readdir(dir)) != NULL) {
+		if (strncmp(dentry->d_name, "memory@", 7) &&
+			strcmp(dentry->d_name, "memory"))
+			continue;
+		strcpy(fname, device_tree);
+		strcat(fname, dentry->d_name);
+		if ((dmem = opendir(fname)) == NULL) {
+			perror(fname);
+			closedir(dir);
+			goto err;
+		}
+		while ((mentry = readdir(dmem)) != NULL) {
+			if (strcmp(mentry->d_name, "reg"))
+				continue;
+			strcat(fname, "/reg");
+			if ((file = fopen(fname, "r")) == NULL) {
+				perror(fname);
+				closedir(dmem);
+				closedir(dir);
+				goto err;
+			}
+			if ((n = fread(buf, 1, MAXBYTES, file)) < 0) {
+				perror(fname);
+				fclose(file);
+				closedir(dmem);
+				closedir(dir);
+				goto err;
+			}
+			if (memory_ranges >= (max_memory_ranges + 1)) {
+				/* No space to insert another element. */
+				fprintf(stderr,
+					"Error: Number of crash memory ranges"
+					" excedeed the max limit\n");
+				goto err;
+			}
+
+			start = ((unsigned long long *)buf)[0];
+			end = start + ((unsigned long long *)buf)[1];
+			if (start == 0 && end >= (BACKUP_SRC_END + 1))
+				start = BACKUP_SRC_END + 1;
+
+			cstart = crash_base;
+			cend = crash_base + crash_size;
+			/*
+			 * Exclude the region that lies within crashkernel
+			 */
+			if (cstart < end && cend > start) {
+				if (start < cstart && end > cend) {
+					crash_memory_range[memory_ranges].start = start;
+					crash_memory_range[memory_ranges].end = cstart;
+					crash_memory_range[memory_ranges].type = RANGE_RAM;
+					memory_ranges++;
+					crash_memory_range[memory_ranges].start = cend;
+					crash_memory_range[memory_ranges].end = end;
+					crash_memory_range[memory_ranges].type = RANGE_RAM;
+					memory_ranges++;
+				} else if (start < cstart) {
+					crash_memory_range[memory_ranges].start = start;
+					crash_memory_range[memory_ranges].end = cstart;
+					crash_memory_range[memory_ranges].type = RANGE_RAM;
+					memory_ranges++;
+				} else if (end > cend){
+					crash_memory_range[memory_ranges].start = cend;
+					crash_memory_range[memory_ranges].end = end;
+					crash_memory_range[memory_ranges].type = RANGE_RAM;
+					memory_ranges++;
+				}
+			} else {
+				crash_memory_range[memory_ranges].start = start;
+				crash_memory_range[memory_ranges].end  = end;
+				crash_memory_range[memory_ranges].type = RANGE_RAM;
+				memory_ranges++;
+			}
+			fclose(file);
+		}
+		closedir(dmem);
+	}
+	closedir(dir);
+
+	/*
+	 * If RTAS region is overlapped with crashkernel, need to create ELF
+	 * Program header for the overlapped memory.
+	 */
+	if (crash_base < rtas_base + rtas_size &&
+		rtas_base < crash_base + crash_size) {
+		cstart = rtas_base;
+		cend = rtas_base + rtas_size;
+		if (cstart < crash_base)
+			cstart = crash_base;
+		if (cend > crash_base + crash_size)
+			cend = crash_base + crash_size;
+		crash_memory_range[memory_ranges].start = cstart;
+		crash_memory_range[memory_ranges++].end = cend;
+	}
+	/*
+	 * Can not trust the memory regions order that we read from
+	 * device-tree. Hence, get the MAX end value.
+	 */
+	for (i = 0; i < memory_ranges; i++)
+		if (saved_max_mem < crash_memory_range[i].end)
+			saved_max_mem = crash_memory_range[i].end;
+
+	*range = crash_memory_range;
+	*ranges = memory_ranges;
+#if DEBUG
+	int j;
+	printf("CRASH MEMORY RANGES\n");
+	for(j = 0; j < *ranges; j++) {
+		start = crash_memory_range[j].start;
+		end = crash_memory_range[j].end;
+		fprintf(stderr, "%016Lx-%016Lx\n", start, end);
+	}
+#endif
+	return 0;
+
+err:
+	if (crash_memory_range)
+		free(crash_memory_range);
+	return -1;
+}
+
+/* Converts unsigned long to ascii string. */
+static void ultoa(unsigned long i, char *str)
+{
+	int j = 0, k;
+	char tmp;
+
+	do {
+		str[j++] = i % 10 + '0';
+	} while ((i /=10) > 0);
+	str[j] = '\0';
+
+	/* Reverse the string. */
+	for (j = 0, k = strlen(str) - 1; j < k; j++, k--) {
+		tmp = str[k];
+		str[k] = str[j];
+		str[j] = tmp;
+	}
+}
+
+static int add_cmdline_param(char *cmdline, unsigned long addr,
+				char *cmdstr, char *byte)
+{
+	int cmdlen, len, align = 1024;
+	char str[COMMAND_LINE_SIZE], *ptr;
+
+	/* Passing in =xxxK / =xxxM format. Saves space required in cmdline.*/
+	switch (byte[0]) {
+		case 'K':
+			if (addr%align)
+				return -1;
+			addr = addr/align;
+			break;
+		case 'M':
+			addr = addr/(align *align);
+			break;
+	}
+	ptr = str;
+	strcpy(str, cmdstr);
+	ptr += strlen(str);
+	ultoa(addr, ptr);
+	strcat(str, byte);
+	len = strlen(str);
+	cmdlen = strlen(cmdline) + len;
+	if (cmdlen > (COMMAND_LINE_SIZE - 1))
+		die("Command line overflow\n");
+	strcat(cmdline, str);
+#if DEBUG
+	fprintf(stderr, "Command line after adding elfcorehdr: %s\n", cmdline);
+#endif
+	return 0;
+}
+
+/* Loads additional segments in case of a panic kernel is being loaded.
+ * One segment for backup region, another segment for storing elf headers
+ * for crash memory image.
+ */
+int load_crashdump_segments(struct kexec_info *info, char* mod_cmdline,
+				unsigned long max_addr, unsigned long min_base)
+{
+	void *tmp;
+	unsigned long sz, elfcorehdr;
+	int nr_ranges, align = 1024, i;
+	unsigned long long end;
+	struct memory_range *mem_range;
+
+	if (get_crash_memory_ranges(&mem_range, &nr_ranges) < 0)
+		return -1;
+
+	/* Create a backup region segment to store backup data*/
+	sz = (BACKUP_SRC_SIZE + align - 1) & ~(align - 1);
+	tmp = xmalloc(sz);
+	memset(tmp, 0, sz);
+	info->backup_start = add_buffer(info, tmp, sz, sz, align,
+					0, max_addr, 1);
+	reserve(info->backup_start, sz);
+
+	/* On ppc64 memory ranges in device-tree is denoted as start
+	 * and size rather than start and end, as is the case with
+	 * other architectures like i386 . Because of this when loading
+	 * the memory ranges in crashdump-elf.c the filesz calculation
+	 * [ end - start + 1 ] goes for a toss.
+	 *
+	 * To be in sync with other archs adjust the end value for
+	 * every crash memory range before calling the generic function
+	 */
+
+	for (i = 0; i < nr_ranges; i++) {
+		end = crash_memory_range[i].end - 1;
+		crash_memory_range[i].end = end;
+	}
+
+
+	/* Create elf header segment and store crash image data. */
+	if (arch_options.core_header_type == CORE_TYPE_ELF64) {
+		if (crash_create_elf64_headers(info, &elf_info64,
+					       crash_memory_range, nr_ranges,
+					       &tmp, &sz,
+					       ELF_CORE_HEADER_ALIGN) < 0)
+			return -1;
+	}
+	else {
+		if (crash_create_elf32_headers(info, &elf_info32,
+					       crash_memory_range, nr_ranges,
+					       &tmp, &sz,
+					       ELF_CORE_HEADER_ALIGN) < 0)
+			return -1;
+	}
+
+	elfcorehdr = add_buffer(info, tmp, sz, sz, align, min_base,
+				max_addr, 1);
+	reserve(elfcorehdr, sz);
+	/* modify and store the cmdline in a global array. This is later
+	 * read by flatten_device_tree and modified if required
+	 */
+	add_cmdline_param(mod_cmdline, elfcorehdr, " elfcorehdr=", "K");
+	add_cmdline_param(mod_cmdline, saved_max_mem, " savemaxmem=", "M");
+	return 0;
+}
+
+/*
+ * Used to save various memory regions needed for the captured kernel.
+ */
+
+void add_usable_mem_rgns(unsigned long long base, unsigned long long size)
+{
+	int i;
+	unsigned long long end = base + size;
+	unsigned long long ustart, uend;
+
+	base = _ALIGN_DOWN(base, getpagesize());
+	end = _ALIGN_UP(end, getpagesize());
+
+	for (i=0; i < usablemem_rgns.size; i++) {
+		ustart = usablemem_rgns.ranges[i].start;
+		uend = usablemem_rgns.ranges[i].end;
+		if (base < uend && end > ustart) {
+			if ((base >= ustart) && (end <= uend))
+				return;
+			if (base < ustart && end > uend) {
+				usablemem_rgns.ranges[i].start = base;
+				usablemem_rgns.ranges[i].end = end;
+				return;
+			} else if (base < ustart) {
+				usablemem_rgns.ranges[i].start = base;
+				return;
+			} else if (end > uend){
+				usablemem_rgns.ranges[i].end = end;
+				return;
+			}
+		}
+	}
+	usablemem_rgns.ranges[usablemem_rgns.size].start = base;
+	usablemem_rgns.ranges[usablemem_rgns.size++].end = end;
+
+#ifdef DEBUG
+	fprintf(stderr, "usable memory rgns size:%u base:%llx size:%llx\n",
+		usablemem_rgns.size, base, size);
+#endif
+}
+
+int is_crashkernel_mem_reserved(void)
+{
+	int fd;
+
+	fd = open("/proc/device-tree/chosen/linux,crashkernel-base", O_RDONLY);
+	if (fd < 0)
+		return 0;
+	close(fd);
+	return 1;
+}
+
+#if 0
+static int sort_regions(mem_rgns_t *rgn)
+{
+	int i, j;
+	unsigned long long tstart, tend;
+	for (i = 0; i < rgn->size; i++) {
+		for (j = 0; j < rgn->size - i - 1; j++) {
+			if (rgn->ranges[j].start > rgn->ranges[j+1].start) {
+				tstart = rgn->ranges[j].start;
+				tend = rgn->ranges[j].end;
+				rgn->ranges[j].start = rgn->ranges[j+1].start;
+				rgn->ranges[j].end = rgn->ranges[j+1].end;
+				rgn->ranges[j+1].start = tstart;
+				rgn->ranges[j+1].end = tend;
+			}
+		}
+	}
+	return 0;
+
+}
+#endif
+
diff -Nur kexec-tools-1.101/kexec/arch/ppc64/crashdump-ppc64.h kexec-tools-1.101-geoff/kexec/arch/ppc64/crashdump-ppc64.h
--- kexec-tools-1.101/kexec/arch/ppc64/crashdump-ppc64.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/ppc64/crashdump-ppc64.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,31 @@
+#ifndef CRASHDUMP_PPC64_H
+#define CRASHDUMP_PPC64_H
+
+struct kexec_info;
+int load_crashdump_segments(struct kexec_info *info, char *mod_cmdline,
+				unsigned long max_addr, unsigned long min_base);
+void add_usable_mem_rgns(unsigned long long base, unsigned long long size);
+
+#define PAGE_OFFSET     0xC000000000000000
+#define KERNELBASE      PAGE_OFFSET
+#define VMALLOCBASE     0xD000000000000000
+
+#define __pa(x)         ((unsigned long)(x)-PAGE_OFFSET)
+#define MAXMEM          (-KERNELBASE-VMALLOCBASE)
+
+#define COMMAND_LINE_SIZE       512 /* from kernel */
+/* Backup Region, First 64K of System RAM. */
+#define BACKUP_SRC_START    0x0000
+#define BACKUP_SRC_END      0xffff
+#define BACKUP_SRC_SIZE     (BACKUP_SRC_END - BACKUP_SRC_START + 1)
+
+#define KDUMP_BACKUP_LIMIT	BACKUP_SRC_SIZE
+#define _ALIGN_UP(addr,size)	(((addr)+((size)-1))&(~((size)-1)))
+#define _ALIGN_DOWN(addr,size)	((addr)&(~((size)-1)))
+
+extern uint64_t crash_base;
+extern uint64_t crash_size;
+extern unsigned int rtas_base;
+extern unsigned int rtas_size;
+
+#endif /* CRASHDUMP_PPC64_H */
diff -Nur kexec-tools-1.101/kexec/arch/ppc64/fs2dt.c kexec-tools-1.101-geoff/kexec/arch/ppc64/fs2dt.c
--- kexec-tools-1.101/kexec/arch/ppc64/fs2dt.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/ppc64/fs2dt.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,546 @@
+/*
+ * fs2dt: creates a flattened device-tree
+ *
+ * Copyright (C) 2004,2005  Milton D Miller II, IBM Corporation
+ * Copyright (C) 2005  R Sharada (sharada@in.ibm.com), IBM Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define _GNU_SOURCE
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <fcntl.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <stdio.h>
+#include "../../kexec.h"
+#include "kexec-ppc64.h"
+#include "crashdump-ppc64.h"
+
+#define MAXPATH 1024		/* max path name length */
+#define NAMESPACE 16384		/* max bytes for property names */
+#define TREEWORDS 65536		/* max 32 bit words for property values */
+#define MEMRESERVE 256		/* max number of reserved memory blocks */
+#define MAX_MEMORY_RANGES 1024
+
+static char pathname[MAXPATH], *pathstart;
+static char propnames[NAMESPACE] = { 0 };
+static unsigned dtstruct[TREEWORDS], *dt;
+static unsigned long long mem_rsrv[2*MEMRESERVE] = { 0, 0 };
+
+static int crash_param = 0;
+static char local_cmdline[COMMAND_LINE_SIZE] = { "" };
+static unsigned *dt_len; /* changed len of modified cmdline
+			    in flat device-tree */
+extern mem_rgns_t usablemem_rgns;
+static struct bootblock bb[1];
+
+void reserve(unsigned long long where, unsigned long long length)
+{
+	size_t offset;
+
+	for (offset = 0; mem_rsrv[offset + 1]; offset += 2)
+		;
+
+	if (offset + 4 >= 2 * MEMRESERVE)
+		die("unrecoverable error: exhasuted reservation meta data\n");
+
+	mem_rsrv[offset] = where;
+	mem_rsrv[offset + 1] = length;
+	mem_rsrv[offset + 3] = 0;  /* N.B: don't care about offset + 2 */
+}
+
+/* look for properties we need to reserve memory space for */
+static void checkprop(char *name, unsigned *data, int len)
+{
+	static unsigned long long base, size, end;
+
+	if ((data == NULL) && (base || size || end))
+		die("unrecoverable error: no property data");
+	else if (!strcmp(name, "linux,rtas-base"))
+		base = *data;
+	else if (!strcmp(name, "linux,tce-base"))
+		base = *(unsigned long long *) data;
+	else if (!strcmp(name, "rtas-size") ||
+			!strcmp(name, "linux,tce-size"))
+		size = *data;
+	else if (reuse_initrd && !strcmp(name, "linux,initrd-start"))
+		if (len == 8)
+			base = *(unsigned long long *) data;
+		else
+			base = *data;
+	else if (reuse_initrd && !strcmp(name, "linux,initrd-end"))
+		end = *(unsigned long long *) data;
+
+	if (size && end)
+		die("unrecoverable error: size and end set at same time\n");
+	if (base && size) {
+		reserve(base, size);
+		base = size = 0;
+	}
+	if (base && end) {
+		reserve(base, end-base);
+		base = end = 0;
+	}
+}
+
+/*
+ * return the property index for a property name, creating a new one
+ * if needed.
+ */
+static unsigned propnum(const char *name)
+{
+	unsigned offset = 0;
+
+	while(propnames[offset])
+		if (strcmp(name, propnames+offset))
+			offset += strlen(propnames+offset)+1;
+		else
+			return offset;
+
+	if (NAMESPACE - offset < strlen(name) + 1)
+		die("unrecoverable error: propnames overrun\n");
+
+	strcpy(propnames+offset, name);
+
+	return offset;
+}
+
+static void add_usable_mem_property(int fd, int len)
+{
+	char fname[MAXPATH], *bname;
+	unsigned long long buf[2];
+	unsigned long ranges[2*MAX_MEMORY_RANGES];
+	unsigned long long base, end, loc_base, loc_end;
+	int range, rlen = 0;
+
+	strcpy(fname, pathname);
+	bname = strrchr(fname,'/');
+	bname[0] = '\0';
+	bname = strrchr(fname,'/');
+	if (strncmp(bname, "/memory@", 8))
+		return;
+
+	if (len < 2 * sizeof(unsigned long long))
+		die("unrecoverable error: not enough data for mem property\n");
+	len = 2 * sizeof(unsigned long long);
+
+	if (lseek(fd, 0, SEEK_SET) < 0)
+		die("unrecoverable error: error seeking in \"%s\": %s\n",
+		    pathname, strerror(errno));
+	if (read(fd, buf, len) != len)
+		die("unrecoverable error: error reading \"%s\": %s\n",
+		    pathname, strerror(errno));
+
+	if (~0ULL - buf[0] < buf[1])
+		die("unrecoverable error: mem property overflow\n");
+	base = buf[0];
+	end = base + buf[1];
+
+	for (range = 0; range < usablemem_rgns.size; range++) {
+		loc_base = usablemem_rgns.ranges[range].start;
+		loc_end = usablemem_rgns.ranges[range].end;
+		if (loc_base >= base && loc_end <= end) {
+			ranges[rlen++] = loc_base;
+			ranges[rlen++] = loc_end - loc_base;
+		} else if (base < loc_end && end > loc_base) {
+			if (loc_base < base)
+				loc_base = base;
+			if (loc_end > end)
+				loc_end = end;
+			ranges[rlen++] = loc_base;
+			ranges[rlen++] = loc_end - loc_base;
+		}
+	}
+
+	if (!rlen) {
+		/*
+		 * User did not pass any ranges for thsi region. Hence, write
+		 * (0,0) duple in linux,usable-memory property such that
+		 * this region will be ignored.
+		 */
+		ranges[rlen++] = 0;
+		ranges[rlen++] = 0;
+	}
+
+	rlen = rlen * sizeof(unsigned long);
+	/*
+	 * No add linux,usable-memory property.
+	 */
+	*dt++ = 3;
+	*dt++ = rlen;
+	*dt++ = propnum("linux,usable-memory");
+	if ((rlen >= 8) && ((unsigned long)dt & 0x4))
+		dt++;
+	memcpy(dt,&ranges,rlen);
+	dt += (rlen + 3)/4;
+}
+
+/* put all properties (files) in the property structure */
+static void putprops(char *fn, struct dirent **nlist, int numlist)
+{
+	struct dirent *dp;
+	int i = 0, fd, len;
+	struct stat statbuf;
+
+	for (i = 0; i < numlist; i++) {
+		dp = nlist[i];
+		strcpy(fn, dp->d_name);
+
+		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
+                        continue;
+
+		if (lstat(pathname, &statbuf))
+			die("unrecoverable error: could not stat \"%s\": %s\n",
+			    pathname, strerror(errno));
+
+		if (!crash_param && !strcmp(fn,"linux,crashkernel-base"))
+			continue;
+
+		if (!crash_param && !strcmp(fn,"linux,crashkernel-size"))
+			continue;
+
+		/*
+		 * This property will be created for each node during kexec
+		 * boot. So, ignore it.
+		 */
+		if (!strcmp(dp->d_name, "linux,pci-domain") ||
+			!strcmp(dp->d_name, "linux,htab-base") ||
+			!strcmp(dp->d_name, "linux,htab-size") ||
+			!strcmp(dp->d_name, "linux,kernel-end"))
+				continue;
+
+		/* This property will be created/modified later in putnode()
+		 * So ignore it, unless we are reusing the initrd.
+		 */
+		if ((!strcmp(dp->d_name, "linux,initrd-start") ||
+		     !strcmp(dp->d_name, "linux,initrd-end")) &&
+		    !reuse_initrd)
+				continue;
+
+		/* This property will be created later in putnode() So
+		 * ignore it now.
+		 */
+		if (!strcmp(dp->d_name, "bootargs"))
+			continue;
+
+		if (! S_ISREG(statbuf.st_mode))
+			continue;
+
+		len = statbuf.st_size;
+
+		*dt++ = 3;
+		dt_len = dt;
+		*dt++ = len;
+		*dt++ = propnum(fn);
+
+		if ((len >= 8) && ((unsigned long)dt & 0x4))
+			dt++;
+
+		fd = open(pathname, O_RDONLY);
+		if (fd == -1)
+			die("unrecoverable error: could not open \"%s\": %s\n",
+			    pathname, strerror(errno));
+
+		if (read(fd, dt, len) != len)
+			die("unrecoverable error: could not read \"%s\": %s\n",
+			    pathname, strerror(errno));
+
+		/* ps3 legacy - Add 'PS3PF' to compatible */
+
+		if (ps3_legacy && !strcmp(dp->d_name, "compatible")) {
+			static const char s[] = "PS3PF";
+			char *const tmp = (char *)dt + len;
+
+			memcpy(tmp, s, sizeof(s));
+			len += sizeof(s);
+			*dt_len = len;
+
+			fprintf(stdout, "ps3 legacy: Changed dt entry "
+				"/compatible: <%s> -> <%s %s>\n",
+				(char *)dt, (char *)dt, tmp);
+		}
+
+		/* ps3 legacy - force memory.reg to 224 MiB */
+
+		if (ps3_legacy && !strcmp(dp->d_name, "reg") && len == 16) {
+			uint64_t tmp = *((uint64_t *)dt + 1);
+
+			*((uint64_t *)dt + 1) = 0xe000000ULL;
+			fprintf(stdout, "ps3 legacy: Changed dt entry "
+				"/memory/reg: <%llx> -> <%llx>\n",
+				(unsigned long long)tmp,
+				*((unsigned long long *)dt + 1));
+		}
+
+		checkprop(fn, dt, len);
+
+		dt += (len + 3)/4;
+		if (!strcmp(dp->d_name, "reg") && usablemem_rgns.size)
+			add_usable_mem_property(fd, len);
+		close(fd);
+	}
+
+	fn[0] = '\0';
+	checkprop(pathname, NULL, 0);
+}
+
+/*
+ * Compare function used to sort the device-tree directories
+ * This function will be passed to scandir.
+ */
+static int comparefunc(const void *dentry1, const void *dentry2)
+{
+	char *str1 = (*(struct dirent **)dentry1)->d_name;
+	char *str2 = (*(struct dirent **)dentry2)->d_name;
+
+	/*
+	 * strcmp scans from left to right and fails to idetify for some
+	 * strings such as memory@10000000 and memory@f000000.
+	 * Therefore, we get the wrong sorted order like memory@10000000 and
+	 * memory@f000000.
+	 */
+	if (strchr(str1, '@') && strchr(str2, '@') &&
+		(strlen(str1) > strlen(str2)))
+		return 1;
+
+	return strcmp(str1, str2);
+}
+
+/*
+ * put a node (directory) in the property structure.  first properties
+ * then children.
+ */
+static void putnode(void)
+{
+	char *dn;
+	struct dirent *dp;
+	char *basename;
+	struct dirent **namelist;
+	int numlist, i;
+	struct stat statbuf;
+
+	*dt++ = 1;
+	strcpy((void *)dt, *pathstart ? pathstart : "/");
+	while(*dt)
+		dt++;
+	if (dt[-1] & 0xff)
+		dt++;
+
+	numlist = scandir(pathname, &namelist, 0, comparefunc);
+	if (numlist < 0)
+		die("unrecoverable error: could not scan \"%s\": %s\n",
+		    pathname, strerror(errno));
+	if (numlist == 0)
+		die("unrecoverable error: no directory entries in \"%s\"",
+		    pathname);
+
+	basename = strrchr(pathname,'/');
+
+	strcat(pathname, "/");
+	dn = pathname + strlen(pathname);
+
+	putprops(dn, namelist, numlist);
+
+	/* Add initrd entries to the second kernel */
+	if (initrd_base && !strcmp(basename,"/chosen/")) {
+		int len = 8;
+		unsigned long long initrd_end;
+		*dt++ = 3;
+		*dt++ = len;
+		*dt++ = propnum("linux,initrd-start");
+
+		if ((len >= 8) && ((unsigned long)dt & 0x4))
+			dt++;
+
+		memcpy(dt,&initrd_base,len);
+		dt += (len + 3)/4;
+
+		len = 8;
+		*dt++ = 3;
+		*dt++ = len;
+		*dt++ = propnum("linux,initrd-end");
+
+		initrd_end = initrd_base + initrd_size;
+		if ((len >= 8) && ((unsigned long)dt & 0x4))
+			dt++;
+
+		memcpy(dt,&initrd_end,len);
+		dt += (len + 3)/4;
+
+		reserve(initrd_base, initrd_size);
+	}
+
+	/* ps3 legacy - add entry linux,platform <801> */
+
+	if (ps3_legacy && !strcmp(basename,"/chosen/")) {
+		int len = 4;
+		static const uint32_t data = 0x801UL;
+
+		*dt++ = 3;
+		*dt++ = len;
+		*dt++ = propnum("linux,platform");
+
+		if ((len >= 8) && ((unsigned long)dt & 0x4))
+			dt++;
+
+		memcpy(dt,&data,len);
+		dt += (len + 3)/4;
+
+		fprintf(stdout, "ps3 legacy: Added dt entry "
+			"/chosen/linux,platform = <801>\n");
+	}
+
+	/* Add cmdline to the second kernel.  Check to see if the new
+	 * cmdline has a root=.  If not, use the old root= cmdline.  */
+	if (!strcmp(basename,"/chosen/")) {
+		size_t cmd_len = 0;
+		char *param = NULL;
+
+		cmd_len = strlen(local_cmdline);
+		if (cmd_len != 0) {
+			param = strstr(local_cmdline, "crashkernel=");
+			if (param)
+				crash_param = 1;
+			/* does the new cmdline have a root= ? ... */
+			param = strstr(local_cmdline, "root=");
+		}
+
+		/* ... if not, grab root= from the old command line */
+		if (!param) {
+			char filename[MAXPATH];
+			FILE *fp;
+			char *last_cmdline = NULL;
+			char *old_param;
+
+			strcpy(filename, pathname);
+			strcat(filename, "bootargs");
+			fp = fopen(filename, "r");
+			if (fp) {
+				if (getline(&last_cmdline, &cmd_len, fp) == -1)
+					die("unable to read %s\n", filename);
+
+				param = strstr(last_cmdline, "root=");
+				if (param) {
+					old_param = strtok(param, " ");
+					if (cmd_len != 0)
+						strcat(local_cmdline, " ");
+					strcat(local_cmdline, old_param);
+				}
+			}
+			if (last_cmdline)
+				free(last_cmdline);
+		}
+		strcat(local_cmdline, " ");
+		cmd_len = strlen(local_cmdline);
+		cmd_len = cmd_len + 1;
+
+		/* add new bootargs */
+		*dt++ = 3;
+		*dt++ = cmd_len;
+		*dt++ = propnum("bootargs");
+		if ((cmd_len >= 8) && ((unsigned long)dt & 0x4))
+			dt++;
+		memcpy(dt, local_cmdline,cmd_len);
+		dt += (cmd_len + 3)/4;
+
+		fprintf(stderr, "Modified cmdline:%s\n", local_cmdline);
+	}
+
+	for (i=0; i < numlist; i++) {
+		dp = namelist[i];
+		strcpy(dn, dp->d_name);
+		free(namelist[i]);
+
+		if (!strcmp(dn, ".") || !strcmp(dn, ".."))
+			continue;
+
+		if (lstat(pathname, &statbuf))
+			die("unrecoverable error: could not stat \"%s\": %s\n",
+			    pathname, strerror(errno));
+
+		if (S_ISDIR(statbuf.st_mode))
+			putnode();
+	}
+
+	*dt++ = 2;
+	dn[-1] = '\0';
+	free(namelist);
+}
+
+int create_flatten_tree(struct kexec_info *info, unsigned char **bufp,
+			unsigned long *sizep, char *cmdline)
+{
+	unsigned long len;
+	unsigned long tlen;
+	unsigned char *buf;
+	unsigned long me;
+
+	me = 0;
+
+	strcpy(pathname, "/proc/device-tree/");
+
+	pathstart = pathname + strlen(pathname);
+	dt = dtstruct;
+
+	if (cmdline)
+		strcpy(local_cmdline, cmdline);
+
+	putnode();
+	*dt++ = 9;
+
+	len = sizeof(bb[0]);
+	len += 7; len &= ~7;
+
+	bb->off_mem_rsvmap = len;
+
+	for (len = 1; mem_rsrv[len]; len += 2)
+		;
+	len+= 3;
+	len *= sizeof(mem_rsrv[0]);
+
+	bb->off_dt_struct = bb->off_mem_rsvmap + len;
+
+	len = dt - dtstruct;
+	len *= sizeof(unsigned);
+	bb->off_dt_strings = bb->off_dt_struct + len;
+
+	len = propnum("");
+	len +=  3; len &= ~3;
+	bb->totalsize = bb->off_dt_strings + len;
+
+	bb->magic = 0xd00dfeed;
+	bb->version = 2;
+	bb->last_comp_version = 2;
+
+	reserve(me, bb->totalsize); /* patched later in kexec_load */
+
+	buf = (unsigned char *) malloc(bb->totalsize);
+	*bufp = buf;
+	memcpy(buf, bb, bb->off_mem_rsvmap);
+	tlen = bb->off_mem_rsvmap;
+	memcpy(buf+tlen, mem_rsrv, bb->off_dt_struct - bb->off_mem_rsvmap);
+	tlen = tlen + (bb->off_dt_struct - bb->off_mem_rsvmap);
+	memcpy(buf+tlen, dtstruct,  bb->off_dt_strings - bb->off_dt_struct);
+	tlen = tlen +  (bb->off_dt_strings - bb->off_dt_struct);
+	memcpy(buf+tlen, propnames,  bb->totalsize - bb->off_dt_strings);
+	tlen = tlen + bb->totalsize - bb->off_dt_strings;
+	*sizep = tlen;
+	return 0;
+}
diff -Nur kexec-tools-1.101/kexec/arch/ppc64/include/arch/options.h kexec-tools-1.101-geoff/kexec/arch/ppc64/include/arch/options.h
--- kexec-tools-1.101/kexec/arch/ppc64/include/arch/options.h	2004-12-22 02:26:00.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/ppc64/include/arch/options.h	2007-10-23 16:24:40.000000000 +0700
@@ -2,9 +2,11 @@
 #define KEXEC_ARCH_PPC64_OPTIONS_H
 
 #define OPT_ARCH_MAX   (OPT_MAX+0)
+#define OPT_ELF64_CORE  (OPT_MAX+1)
 
 #define KEXEC_ARCH_OPTIONS \
 	KEXEC_OPTIONS \
+	{ "elf64-core-headers", 0, 0, OPT_ELF64_CORE }, \
 
 #define KEXEC_ARCH_OPT_STR KEXEC_OPT_STR ""
 
diff -Nur kexec-tools-1.101/kexec/arch/ppc64/kexec-elf-ppc64.c kexec-tools-1.101-geoff/kexec/arch/ppc64/kexec-elf-ppc64.c
--- kexec-tools-1.101/kexec/arch/ppc64/kexec-elf-ppc64.c	2004-12-17 15:32:04.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/ppc64/kexec-elf-ppc64.c	2007-10-23 16:24:40.000000000 +0700
@@ -3,6 +3,8 @@
  *
  * Copyright (C) 2004  Adam Litke (agl@us.ibm.com)
  * Copyright (C) 2004  IBM Corp.
+ * Copyright (C) 2005  R Sharada (sharada@in.ibm.com)
+ * Copyright (C) 2006  Mohan Kumar M (mohan@in.ibm.com)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -32,52 +34,28 @@
 #include <linux/elf.h>
 #include "../../kexec.h"
 #include "../../kexec-elf.h"
+#include "../../kexec-syscall.h"
 #include "kexec-ppc64.h"
+#include "crashdump-ppc64.h"
+#include <arch/options.h>
 
 #define BOOTLOADER         "kexec"
 #define BOOTLOADER_VERSION VERSION
-#define MAX_COMMAND_LINE   256
 
-#define UPSZ(X) ((sizeof(X) + 3) & ~3)
-static struct boot_notes {
-	Elf_Bhdr hdr;
-	Elf_Nhdr bl_hdr;
-	unsigned char bl_desc[UPSZ(BOOTLOADER)];
-	Elf_Nhdr blv_hdr;
-	unsigned char blv_desc[UPSZ(BOOTLOADER_VERSION)];
-	Elf_Nhdr cmd_hdr;
-	unsigned char command_line[0];
-} elf_boot_notes = {
-	.hdr = {
-		.b_signature = 0x0E1FB007,
-		.b_size = sizeof(elf_boot_notes),
-		.b_checksum = 0,
-		.b_records = 3,
-	},
-	.bl_hdr = {
-		.n_namesz = 0,
-		.n_descsz = sizeof(BOOTLOADER),
-		.n_type = EBN_BOOTLOADER_NAME,
-	},
-	.bl_desc = BOOTLOADER,
-	.blv_hdr = {
-		.n_namesz = 0,
-		.n_descsz = sizeof(BOOTLOADER_VERSION),
-		.n_type = EBN_BOOTLOADER_VERSION,
-	},
-	.blv_desc = BOOTLOADER_VERSION,
-	.cmd_hdr = {
-		.n_namesz = 0,
-		.n_descsz = 0,
-		.n_type = EBN_COMMAND_LINE,
-	},
-};
+uint64_t initrd_base, initrd_size;
+unsigned char reuse_initrd = 0;
+const char *ramdisk;
+int ps3_legacy = -1; /* default to probe */
+
+int create_flatten_tree(struct kexec_info *, unsigned char **, unsigned long *,
+			char *);
+int my_r2(struct mem_ehdr *ehdr);
 
 int elf_ppc64_probe(const char *buf, off_t len)
 {
 	struct mem_ehdr ehdr;
 	int result;
-	result = build_elf_exec_info(buf, len, &ehdr);
+	result = build_elf_exec_info(buf, len, &ehdr, 0);
 	if (result < 0) {
 		goto out;
 	}
@@ -94,27 +72,334 @@
 	return result;
 }
 
-int elf_ppc64_load(int argc, char **argv, const char *buf, off_t len, 
-	struct kexec_info *info)
+void arch_reuse_initrd(void)
+{
+	reuse_initrd = 1;
+}
+
+/**
+ * ps3_legacy_probe - Probe kernel version.
+ */
+
+static int ps3_legacy_probe(const char *p, off_t len)
+{
+	static const char d1[] = "linux,platform";    /* legacy 2.6.16 */
+	static const char d2[] = "2.6.21-1.3194.fc7"; /* fedora 7 installer */
+	const char *const end = p + len - sizeof(d2);
+
+	while(p < end) {
+		if (p[0] == d1[0] && !memcmp(p, d1, sizeof(d1) - 1)) {
+			fprintf(stdout, "ps3 legacy: Legacy kernel found: "
+				"'%s'\n", d1);
+			break;
+		}
+		if (p[0] == d2[0] && !memcmp(p, d2, sizeof(d2) - 1)) {
+			fprintf(stdout, "ps3 legacy: Legacy kernel found: "
+				"'%s'\n", d2);
+			break;
+		}
+		p++;
+	}
+
+	return (p != end);
+}
+
+int elf_ppc64_load(int argc, char **argv, const char *buf, off_t len,
+			struct kexec_info *info)
 {
 	struct mem_ehdr ehdr;
+	char *cmdline, *modified_cmdline;
+	const char *devicetreeblob;
+	int cmdline_len, modified_cmdline_len;
+	uint64_t max_addr, hole_addr;
+	unsigned char *seg_buf = NULL;
+	off_t seg_size = 0;
+	struct mem_phdr *phdr;
+	size_t size;
+	uint64_t *rsvmap_ptr;
+	struct bootblock *bb_ptr;
+	unsigned int nr_segments, i;
+	int result, opt;
+	uint64_t my_kernel, my_dt_offset;
+	unsigned int my_panic_kernel;
+	uint64_t my_stack, my_backup_start;
+	uint64_t toc_addr;
+	unsigned int slave_code[256/sizeof (unsigned int)], master_entry;
+
+#define OPT_APPEND     (OPT_ARCH_MAX+0)
+#define OPT_RAMDISK     (OPT_ARCH_MAX+1)
+#define OPT_DEVICETREEBLOB     (OPT_ARCH_MAX+2)
+#define OPT_ARGS_IGNORE		(OPT_ARCH_MAX+3)
+#define OPT_PS3_LEGACY (OPT_ARCH_MAX+4)
+#define OPT_PS3_LEGACY_NO (OPT_ARCH_MAX+5)
+
+	static const struct option options[] = {
+		KEXEC_ARCH_OPTIONS
+		{ "command-line",       1, NULL, OPT_APPEND },
+		{ "append",             1, NULL, OPT_APPEND },
+		{ "ramdisk",            1, NULL, OPT_RAMDISK },
+		{ "initrd",             1, NULL, OPT_RAMDISK },
+		{ "devicetreeblob",     1, NULL, OPT_DEVICETREEBLOB },
+		{ "args-linux",		0, NULL, OPT_ARGS_IGNORE },
+		{ "ps3-legacy",         0, NULL, OPT_PS3_LEGACY },
+		{ "ps3-no-legacy",      0, NULL, OPT_PS3_LEGACY_NO },
+		{ 0,                    0, NULL, 0 },
+	};
+
+	static const char short_options[] = KEXEC_OPT_STR "";
 
 	/* Parse command line arguments */
+	initrd_base = 0;
+	initrd_size = 0;
+	cmdline = 0;
+	ramdisk = 0;
+	devicetreeblob = 0;
+	max_addr = 0xFFFFFFFFFFFFFFFFUL;
+	hole_addr = 0;
+
+	while ((opt = getopt_long(argc, argv, short_options,
+					options, 0)) != -1) {
+		switch (opt) {
+		default:
+			/* Ignore core options */
+			if (opt < OPT_ARCH_MAX)
+				break;
+		case '?':
+			usage();
+			return -1;
+		case OPT_APPEND:
+			cmdline = optarg;
+			break;
+		case OPT_RAMDISK:
+			ramdisk = optarg;
+			break;
+		case OPT_DEVICETREEBLOB:
+			devicetreeblob = optarg;
+			break;
+		case OPT_ARGS_IGNORE:
+			break;
+		case OPT_PS3_LEGACY:
+			ps3_legacy = 1;
+			break;
+		case OPT_PS3_LEGACY_NO:
+			ps3_legacy = 0;
+			break;
+		}
+	}
+
+	if (ps3_legacy == -1)
+		ps3_legacy = ps3_legacy_probe(buf, len);
+
+	cmdline_len = 0;
+	if (cmdline)
+		cmdline_len = strlen(cmdline) + 1;
+	else
+		fprintf(stdout, "Warning: append= option is not passed. Using the first kernel root partition\n");
+
+	if (ramdisk && reuse_initrd)
+		die("Can't specify --ramdisk or --initrd with --reuseinitrd\n");
+
+	if (ps3_legacy && devicetreeblob)
+		die("Can't specify --devicetreeblob with --ps3-legacy\n");
+
+	setup_memory_ranges(info->kexec_flags);
+
+	/* Need to append some command line parameters internally in case of
+	 * taking crash dumps.
+	 */
+	if (info->kexec_flags & KEXEC_ON_CRASH) {
+		modified_cmdline = xmalloc(COMMAND_LINE_SIZE);
+		memset((void *)modified_cmdline, 0, COMMAND_LINE_SIZE);
+		if (cmdline) {
+			strncpy(modified_cmdline, cmdline, COMMAND_LINE_SIZE);
+			modified_cmdline[COMMAND_LINE_SIZE - 1] = '\0';
+		}
+		modified_cmdline_len = strlen(modified_cmdline);
+	}
 
 	/* Parse the Elf file */
-	result = build_elf_exec_info(buf, len, &ehdr);
+	result = build_elf_exec_info(buf, len, &ehdr, 0);
 	if (result < 0) {
 		free_elf_info(&ehdr);
 		return result;
 	}
 
-	/* Load the Elf data */
+	/* Load the Elf data. Physical load addresses in elf64 header do not
+	 * show up correctly. Use user supplied address for now to patch the
+	 * elf header
+	 */
+
+	phdr = &ehdr.e_phdr[0];
+	size = phdr->p_filesz;
+	if (size > phdr->p_memsz)
+		size = phdr->p_memsz;
+
+	hole_addr = (unsigned long)locate_hole(info, size, 0, 0,
+			max_addr, 1);
+	ehdr.e_phdr[0].p_paddr = hole_addr;
 	result = elf_exec_load(&ehdr, info);
 	if (result < 0) {
 		free_elf_info(&ehdr);
 		return result;
 	}
-	return 1;
+
+	/* If panic kernel is being loaded, additional segments need
+	 * to be created.
+	 */
+	if (info->kexec_flags & KEXEC_ON_CRASH) {
+		result = load_crashdump_segments(info, modified_cmdline,
+						max_addr, 0);
+		if (result < 0)
+			return -1;
+		/* Use new command line. */
+		cmdline = modified_cmdline;
+		cmdline_len = strlen(modified_cmdline) + 1;
+	}
+
+	/* Add v2wrap to the current image */
+	seg_buf = NULL;
+	seg_size = 0;
+
+	seg_buf = (unsigned char *) malloc(purgatory_size);
+	if (seg_buf == NULL) {
+		free_elf_info(&ehdr);
+		return -1;
+	}
+	memcpy(seg_buf, purgatory, purgatory_size);
+	seg_size = purgatory_size;
+	elf_rel_build_load(info, &info->rhdr, (const char *)purgatory,
+				purgatory_size, 0, max_addr, 1, 0);
+
+	/* Add a ram-disk to the current image
+	 * Note: Add the ramdisk after elf_rel_build_load
+	 */
+	if (ramdisk) {
+		if (devicetreeblob) {
+			fprintf(stderr,
+			"Can't use ramdisk with device tree blob input\n");
+			return -1;
+		}
+		seg_buf = (unsigned char *)slurp_file(ramdisk, &seg_size);
+		add_buffer(info, seg_buf, seg_size, seg_size, 0, 0, max_addr, 1);
+		hole_addr = (uint64_t)
+			info->segment[info->nr_segments-1].mem;
+		initrd_base = hole_addr;
+		initrd_size = (uint64_t)
+			info->segment[info->nr_segments-1].memsz;
+	} /* ramdisk */
+
+	if (devicetreeblob) {
+		unsigned char *blob_buf = NULL;
+		off_t blob_size = 0;
+
+		/* Grab device tree from buffer */
+		blob_buf =
+			(unsigned char *)slurp_file(devicetreeblob, &blob_size);
+		add_buffer(info, blob_buf, blob_size, blob_size, 0, 0,
+				max_addr, -1);
+
+	} else {
+		/* create from fs2dt */
+		seg_buf = NULL;
+		seg_size = 0;
+		create_flatten_tree(info, (unsigned char **)&seg_buf,
+				(unsigned long *)&seg_size,cmdline);
+		add_buffer(info, seg_buf, seg_size, seg_size,
+				0, 0, max_addr, -1);
+	}
+
+	/* patch reserve map address for flattened device-tree
+	 * find last entry (both 0) in the reserve mem list.  Assume DT
+	 * entry is before this one
+	 */
+	bb_ptr = (struct bootblock *)(
+		(unsigned char *)info->segment[(info->nr_segments)-1].buf);
+	rsvmap_ptr = (uint64_t *)(
+		(unsigned char *)info->segment[(info->nr_segments)-1].buf +
+		bb_ptr->off_mem_rsvmap);
+	while (*rsvmap_ptr || *(rsvmap_ptr+1))
+		rsvmap_ptr += 2;
+	rsvmap_ptr -= 2;
+	*rsvmap_ptr = (uint64_t)(
+		info->segment[(info->nr_segments)-1].mem);
+	rsvmap_ptr++;
+	*rsvmap_ptr = (uint64_t)bb_ptr->totalsize;
+
+	nr_segments = info->nr_segments;
+
+	/* Set kernel */
+	my_kernel = (uint64_t)info->segment[0].mem;
+	elf_rel_set_symbol(&info->rhdr, "kernel", &my_kernel, sizeof(my_kernel));
+
+	/* Set dt_offset */
+	my_dt_offset = (uint64_t)info->segment[nr_segments-1].mem;
+	elf_rel_set_symbol(&info->rhdr, "dt_offset", &my_dt_offset,
+				sizeof(my_dt_offset));
+
+	/* get slave code from new kernel, put in purgatory */
+	elf_rel_get_symbol(&info->rhdr, "purgatory_start", slave_code,
+			sizeof(slave_code));
+	master_entry = slave_code[0];
+	memcpy(slave_code, info->segment[0].buf, sizeof(slave_code));
+	slave_code[0] = master_entry;
+	elf_rel_set_symbol(&info->rhdr, "purgatory_start", slave_code,
+				sizeof(slave_code));
+
+	if (info->kexec_flags & KEXEC_ON_CRASH) {
+		my_panic_kernel = 1;
+		/* Set panic flag */
+		elf_rel_set_symbol(&info->rhdr, "panic_kernel",
+				&my_panic_kernel, sizeof(my_panic_kernel));
+
+		/* Set backup address */
+		my_backup_start = info->backup_start;
+		elf_rel_set_symbol(&info->rhdr, "backup_start",
+				&my_backup_start, sizeof(my_backup_start));
+	}
+
+	/* Set stack address */
+	my_stack = locate_hole(info, 16*1024, 0, 0, max_addr, 1);
+	my_stack += 16*1024;
+	elf_rel_set_symbol(&info->rhdr, "stack", &my_stack, sizeof(my_stack));
+
+	/* Set toc */
+	toc_addr = (unsigned long) my_r2(&info->rhdr);
+	elf_rel_set_symbol(&info->rhdr, "my_toc", &toc_addr, sizeof(toc_addr));
+
+#ifdef DEBUG
+	my_kernel = 0;
+	my_dt_offset = 0;
+	my_panic_kernel = 0;
+	my_backup_start = 0;
+	my_stack = 0;
+	toc_addr = 0;
+
+	elf_rel_get_symbol(&info->rhdr, "kernel", &my_kernel, sizeof(my_kernel));
+	elf_rel_get_symbol(&info->rhdr, "dt_offset", &my_dt_offset,
+				sizeof(my_dt_offset));
+	elf_rel_get_symbol(&info->rhdr, "panic_kernel", &my_panic_kernel,
+				sizeof(my_panic_kernel));
+	elf_rel_get_symbol(&info->rhdr, "backup_start", &my_backup_start,
+				sizeof(my_backup_start));
+	elf_rel_get_symbol(&info->rhdr, "stack", &my_stack, sizeof(my_stack));
+	elf_rel_get_symbol(&info->rhdr, "my_toc", &toc_addr,
+				sizeof(toc_addr));
+
+	fprintf(stderr, "info->entry is %p\n", info->entry);
+	fprintf(stderr, "kernel is %lx\n", my_kernel);
+	fprintf(stderr, "dt_offset is %lx\n", my_dt_offset);
+	fprintf(stderr, "panic_kernel is %x\n", my_panic_kernel);
+	fprintf(stderr, "backup_start is %lx\n", my_backup_start);
+	fprintf(stderr, "stack is %lx\n", my_stack);
+	fprintf(stderr, "toc_addr is %lx\n", toc_addr);
+	fprintf(stderr, "purgatory size is %lu\n", purgatory_size);
+#endif
+
+	for (i = 0; i < nr_segments; i++)
+		fprintf(stderr, "segment[%d].mem:%p memsz:%ld\n", i,
+			info->segment[i].mem, info->segment[i].memsz);
+
+	return 0;
 }
 
 void elf_ppc64_usage(void)
diff -Nur kexec-tools-1.101/kexec/arch/ppc64/kexec-elf-rel-ppc64.c kexec-tools-1.101-geoff/kexec/arch/ppc64/kexec-elf-rel-ppc64.c
--- kexec-tools-1.101/kexec/arch/ppc64/kexec-elf-rel-ppc64.c	2004-12-20 08:06:04.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/ppc64/kexec-elf-rel-ppc64.c	2007-10-23 16:24:40.000000000 +0700
@@ -1,5 +1,6 @@
 #include <stdio.h>
 #include <elf.h>
+#include <string.h>
 #include "../../kexec.h"
 #include "../../kexec-elf.h"
 
@@ -21,20 +22,20 @@
 {
 	struct mem_shdr *shdr, *shdr_end;
 	unsigned char *strtab;
-	strtab = ehdr->e_shdr[ehdr->e_shstrndx].sh_data;
-	shdr_end = &ehdr->e_shdr[ehdr->shnum];
-	for(shdr = ehdr->e_shdr; shdr != shdr_end; shdr++) {
-		if (strcmp(shdr->sh_name, ".toc") == 0) {
+	strtab = (unsigned char *)ehdr->e_shdr[ehdr->e_shstrndx].sh_data;
+	shdr_end = &ehdr->e_shdr[ehdr->e_shnum];
+	for(shdr = ehdr->e_shdr; shdr != shdr_end; shdr++)
+		if ( shdr->sh_size &&
+			strcmp((char *)&strtab[shdr->sh_name],
+						".toc") == 0)
 			return shdr;
-		}
-	}
 	return NULL;
 }
 
 /* r2 is the TOC pointer: it actually points 0x8000 into the TOC (this
    gives the value maximum span in an instruction which uses a signed
    offset) */
-static unsigned long my_r2(const struct mem_ehdr *ehdr)
+unsigned long my_r2(const struct mem_ehdr *ehdr)
 {
 	struct mem_shdr *shdr;
 	shdr = toc_section(ehdr);
@@ -53,7 +54,7 @@
 		/* Simply set it */
 		*(uint32_t *)location = value;
 		break;
-		
+
 	case R_PPC64_ADDR64:
 		/* Simply set it */
 		*(uint64_t *)location = value;
@@ -78,15 +79,34 @@
 		/* Convert value to relative */
 		value -= address;
 		if (value + 0x2000000 > 0x3ffffff || (value & 3) != 0){
-			die("REL24 %li out of range!\n", 
+			die("REL24 %li out of range!\n",
 				(long int)value);
 		}
 
 		/* Only replace bits 2 through 26 */
-		*(uint32_t *)location 
-			= (*(uint32_t *)location & ~0x03fffffc)
-			| (value & 0x03fffffc);
+		*(uint32_t *)location = (*(uint32_t *)location & ~0x03fffffc)
+					| (value & 0x03fffffc);
+		break;
+
+	case R_PPC64_ADDR16_LO:
+		*(uint16_t *)location = value & 0xffff;
+		break;
+
+	case R_PPC64_ADDR16_HI:
+		*(uint16_t *)location = (value>>16) & 0xffff;
 		break;
+
+	case R_PPC64_ADDR16_HA:
+		*(uint16_t *)location = (((value+0x8000)>>16)  & 0xffff);
+		break;
+
+	case R_PPC64_ADDR16_HIGHEST:
+		*(uint16_t *)location = (((uint64_t)value>>48)  & 0xffff);
+		break;
+	case R_PPC64_ADDR16_HIGHER:
+		*(uint16_t *)location = (((uint64_t)value>>32)  & 0xffff);
+		break;
+
 	default:
 		die("Unknown rela relocation: %lu\n", r_type);
 		break;
diff -Nur kexec-tools-1.101/kexec/arch/ppc64/kexec-ppc64.c kexec-tools-1.101-geoff/kexec/arch/ppc64/kexec-ppc64.c
--- kexec-tools-1.101/kexec/arch/ppc64/kexec-ppc64.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/ppc64/kexec-ppc64.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,716 @@
+/*
+ * kexec: Linux boots Linux
+ *
+ * Copyright (C) 2003-2005  Eric Biederman (ebiederm@xmission.com)
+ * Copyright (C) 2005  R Sharada (sharada@in.ibm.com), IBM Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <getopt.h>
+#include <sys/utsname.h>
+#include "../../kexec.h"
+#include "../../kexec-syscall.h"
+#include "kexec-ppc64.h"
+#include "crashdump-ppc64.h"
+#include <arch/options.h>
+
+static struct memory_range *exclude_range = NULL;
+static struct memory_range *memory_range = NULL;
+static struct memory_range *base_memory_range = NULL;
+static unsigned long long rmo_top;
+unsigned long long memory_max = 0;
+static int nr_memory_ranges, nr_exclude_ranges;
+uint64_t crash_base, crash_size;
+unsigned int rtas_base, rtas_size;
+int max_memory_ranges;
+
+static void cleanup_memory_ranges(void)
+{
+	if (memory_range)
+		free(memory_range);
+	if (base_memory_range)
+		free(base_memory_range);
+	if (exclude_range)
+		free(exclude_range);
+	if (usablemem_rgns.ranges)
+		free(usablemem_rgns.ranges);
+}
+
+/*
+ * Allocate memory for various data structures used to hold
+ * values of different memory ranges
+ */
+static int alloc_memory_ranges(void)
+{
+	int memory_range_len;
+
+	memory_range_len = sizeof(struct memory_range) * max_memory_ranges;
+
+	memory_range = (struct memory_range *) malloc(memory_range_len);
+	if (!memory_range)
+		return -1;
+
+	base_memory_range = (struct memory_range *) malloc(memory_range_len);
+	if (!base_memory_range)
+		goto err1;
+
+	exclude_range = (struct memory_range *) malloc(memory_range_len);
+	if (!exclude_range)
+		goto err1;
+
+	usablemem_rgns.ranges = (struct memory_range *)
+				malloc(memory_range_len);
+	if (!(usablemem_rgns.ranges))
+		goto err1;
+
+	memset(memory_range, 0, memory_range_len);
+	memset(base_memory_range, 0, memory_range_len);
+	memset(exclude_range, 0, memory_range_len);
+	memset(usablemem_rgns.ranges, 0, memory_range_len);
+	return 0;
+
+err1:
+	fprintf(stderr, "memory range structure allocation failure\n");
+	cleanup_memory_ranges();
+	return -1;
+
+}
+
+/*
+ * Count the memory nodes under /proc/device-tree and populate the
+ * max_memory_ranges variable. This variable replaces MAX_MEMORY_RANGES
+ * macro used earlier.
+ */
+static int count_memory_ranges(void)
+{
+	char device_tree[256] = "/proc/device-tree/";
+	struct dirent *dentry;
+	DIR *dir;
+
+	if ((dir = opendir(device_tree)) == NULL) {
+		perror(device_tree);
+		return -1;
+	}
+
+	while ((dentry = readdir(dir)) != NULL) {
+		if (strncmp(dentry->d_name, "memory@", 7) &&
+			strcmp(dentry->d_name, "memory") &&
+			strncmp(dentry->d_name, "pci@", 4))
+			continue;
+		max_memory_ranges++;
+	}
+	/* need to add extra region for retained initrd */
+	if (reuse_initrd) {
+		max_memory_ranges++;
+	}
+
+	closedir(dir);
+
+	return 0;
+}
+
+/* Sort the base ranges in memory - this is useful for ensuring that our
+ * ranges are in ascending order, even if device-tree read of memory nodes
+ * is done differently. Also, could be used for other range coalescing later
+ */
+static int sort_base_ranges(void)
+{
+	int i, j;
+	unsigned long long tstart, tend;
+
+	for (i = 0; i < nr_memory_ranges - 1; i++) {
+		for (j = 0; j < nr_memory_ranges - i - 1; j++) {
+			if (base_memory_range[j].start > base_memory_range[j+1].start) {
+				tstart = base_memory_range[j].start;
+				tend = base_memory_range[j].end;
+				base_memory_range[j].start = base_memory_range[j+1].start;
+				base_memory_range[j].end = base_memory_range[j+1].end;
+				base_memory_range[j+1].start = tstart;
+				base_memory_range[j+1].end = tend;
+			}
+		}
+	}
+	return 0;
+}
+
+/* Get base memory ranges */
+static int get_base_ranges(void)
+{
+	int local_memory_ranges = 0;
+	char device_tree[256] = "/proc/device-tree/";
+	char fname[256];
+	char buf[MAXBYTES-1];
+	DIR *dir, *dmem;
+	FILE *file;
+	struct dirent *dentry, *mentry;
+	int n;
+
+	if ((dir = opendir(device_tree)) == NULL) {
+		perror(device_tree);
+		return -1;
+	}
+	while ((dentry = readdir(dir)) != NULL) {
+		if (strncmp(dentry->d_name, "memory@", 7) &&
+			strcmp(dentry->d_name, "memory"))
+			continue;
+		strcpy(fname, device_tree);
+		strcat(fname, dentry->d_name);
+		if ((dmem = opendir(fname)) == NULL) {
+			perror(fname);
+			closedir(dir);
+			return -1;
+		}
+		while ((mentry = readdir(dmem)) != NULL) {
+			if (strcmp(mentry->d_name, "reg"))
+				continue;
+			strcat(fname, "/reg");
+			if ((file = fopen(fname, "r")) == NULL) {
+				perror(fname);
+				closedir(dmem);
+				closedir(dir);
+				return -1;
+			}
+			if ((n = fread(buf, 1, MAXBYTES, file)) < 0) {
+				perror(fname);
+				fclose(file);
+				closedir(dmem);
+				closedir(dir);
+				return -1;
+			}
+			if (local_memory_ranges >= max_memory_ranges) {
+				fclose(file);
+				break;
+			}
+			base_memory_range[local_memory_ranges].start =
+				((uint64_t *)buf)[0];
+			base_memory_range[local_memory_ranges].end  =
+				base_memory_range[local_memory_ranges].start +
+				((uint64_t *)buf)[1];
+			base_memory_range[local_memory_ranges].type = RANGE_RAM;
+			local_memory_ranges++;
+			dbgprintf("%016llx-%016llx : %x\n",
+				base_memory_range[local_memory_ranges-1].start,
+				base_memory_range[local_memory_ranges-1].end,
+				base_memory_range[local_memory_ranges-1].type);
+			fclose(file);
+		}
+		closedir(dmem);
+	}
+	closedir(dir);
+	nr_memory_ranges = local_memory_ranges;
+	sort_base_ranges();
+	memory_max = base_memory_range[nr_memory_ranges - 1].end;
+#ifdef DEBUG
+	fprintf(stderr, "get base memory ranges:%d\n", nr_memory_ranges);
+#endif
+	return 0;
+}
+
+/* Sort the exclude ranges in memory */
+static int sort_ranges(void)
+{
+	int i, j;
+	uint64_t tstart, tend;
+	for (i = 0; i < nr_exclude_ranges - 1; i++) {
+		for (j = 0; j < nr_exclude_ranges - i - 1; j++) {
+			if (exclude_range[j].start > exclude_range[j+1].start) {
+				tstart = exclude_range[j].start;
+				tend = exclude_range[j].end;
+				exclude_range[j].start = exclude_range[j+1].start;
+				exclude_range[j].end = exclude_range[j+1].end;
+				exclude_range[j+1].start = tstart;
+				exclude_range[j+1].end = tend;
+			}
+		}
+	}
+	return 0;
+}
+
+/* Get devtree details and create exclude_range array
+ * Also create usablemem_ranges for KEXEC_ON_CRASH
+ */
+static int get_devtree_details(unsigned long kexec_flags)
+{
+	unsigned long long rmo_base;
+	unsigned long long tce_base;
+	unsigned int tce_size;
+	unsigned long long htab_base, htab_size;
+	unsigned long long kernel_end;
+	unsigned long long initrd_start, initrd_end;
+	char buf[MAXBYTES-1];
+	char device_tree[256] = "/proc/device-tree/";
+	char fname[256];
+	DIR *dir, *cdir;
+	FILE *file;
+	struct dirent *dentry;
+	struct stat fstat;
+	int n, i = 0;
+
+	if ((dir = opendir(device_tree)) == NULL) {
+		perror(device_tree);
+		return -1;
+	}
+
+	while ((dentry = readdir(dir)) != NULL) {
+		if (strncmp(dentry->d_name, "chosen", 6) &&
+			strncmp(dentry->d_name, "memory@", 7) &&
+			strcmp(dentry->d_name, "memory") &&
+			strncmp(dentry->d_name, "pci@", 4) &&
+			strncmp(dentry->d_name, "rtas", 4))
+			continue;
+		strcpy(fname, device_tree);
+		strcat(fname, dentry->d_name);
+		if ((cdir = opendir(fname)) == NULL) {
+			perror(fname);
+			goto error_opendir;
+		}
+
+		if (strncmp(dentry->d_name, "chosen", 6) == 0) {
+			strcat(fname, "/linux,kernel-end");
+			if ((file = fopen(fname, "r")) == NULL) {
+				perror(fname);
+				goto error_opencdir;
+			}
+			if (fread(&kernel_end, sizeof(uint64_t), 1, file) != 1) {
+				perror(fname);
+				goto error_openfile;
+			}
+			fclose(file);
+
+			/* Add kernel memory to exclude_range */
+			exclude_range[i].start = 0x0UL;
+			exclude_range[i].end = kernel_end;
+			i++;
+
+			if (kexec_flags & KEXEC_ON_CRASH) {
+				memset(fname, 0, sizeof(fname));
+				strcpy(fname, device_tree);
+				strcat(fname, dentry->d_name);
+				strcat(fname, "/linux,crashkernel-base");
+				if ((file = fopen(fname, "r")) == NULL) {
+					perror(fname);
+					goto error_opencdir;
+				}
+				if (fread(&crash_base, sizeof(uint64_t), 1,
+						file) != 1) {
+					perror(fname);
+					goto error_openfile;
+				}
+				fclose(file);
+
+				memset(fname, 0, sizeof(fname));
+				strcpy(fname, device_tree);
+				strcat(fname, dentry->d_name);
+				strcat(fname, "/linux,crashkernel-size");
+				if ((file = fopen(fname, "r")) == NULL) {
+					perror(fname);
+					goto error_opencdir;
+				}
+				if (fread(&crash_size, sizeof(uint64_t), 1,
+						file) != 1) {
+					perror(fname);
+					goto error_openfile;
+				}
+
+				if (crash_base > mem_min)
+					mem_min = crash_base;
+				if (crash_base + crash_size < mem_max)
+					mem_max = crash_base + crash_size;
+
+				add_usable_mem_rgns(0, crash_base + crash_size);
+				reserve(KDUMP_BACKUP_LIMIT, crash_base-KDUMP_BACKUP_LIMIT);
+			}
+
+			memset(fname, 0, sizeof(fname));
+			strcpy(fname, device_tree);
+			strcat(fname, dentry->d_name);
+			strcat(fname, "/linux,htab-base");
+			if ((file = fopen(fname, "r")) == NULL) {
+				closedir(cdir);
+				if (errno == ENOENT) {
+					/* Non LPAR */
+					errno = 0;
+					continue;
+                                }
+				perror(fname);
+				goto error_opendir;
+			}
+			if (fread(&htab_base, sizeof(uint64_t), 1, file) != 1) {
+				perror(fname);
+				goto error_openfile;
+			}
+			memset(fname, 0, sizeof(fname));
+			strcpy(fname, device_tree);
+			strcat(fname, dentry->d_name);
+			strcat(fname, "/linux,htab-size");
+			if ((file = fopen(fname, "r")) == NULL) {
+				perror(fname);
+				goto error_opencdir;
+			}
+			if (fread(&htab_size, sizeof(uint64_t), 1, file) != 1) {
+				perror(fname);
+				goto error_openfile;
+			}
+			/* Add htab address to exclude_range - NON-LPAR only */
+			exclude_range[i].start = htab_base;
+			exclude_range[i].end = htab_base + htab_size;
+			i++;
+
+			/* reserve the initrd_start and end locations. */
+			if (reuse_initrd) {
+				memset(fname, 0, sizeof(fname));
+				strcpy(fname, device_tree);
+				strcat(fname, dentry->d_name);
+				strcat(fname, "/linux,initrd-start");
+				if ((file = fopen(fname, "r")) == NULL) {
+					perror(fname);
+					goto error_opencdir;
+				}
+				/* check for 4 and 8 byte initrd offset sizes */
+				if (stat(fname, &fstat) != 0) {
+					perror(fname);
+					goto error_openfile;
+				}
+				if (fread(&initrd_start, fstat.st_size, 1, file) != 1) {
+					perror(fname);
+					goto error_openfile;
+				}
+				fclose(file);
+
+				memset(fname, 0, sizeof(fname));
+				strcpy(fname, device_tree);
+				strcat(fname, dentry->d_name);
+				strcat(fname, "/linux,initrd-end");
+				if ((file = fopen(fname, "r")) == NULL) {
+					perror(fname);
+					goto error_opencdir;
+				}
+				/* check for 4 and 8 byte initrd offset sizes */
+				if (stat(fname, &fstat) != 0) {
+					perror(fname);
+					goto error_openfile;
+				}
+				if (fread(&initrd_end, fstat.st_size, 1, file) != 1) {
+					perror(fname);
+					goto error_openfile;
+				}
+				fclose(file);
+
+				/* Add initrd address to exclude_range */
+				exclude_range[i].start = initrd_start;
+				exclude_range[i].end = initrd_end;
+				i++;
+			}
+		} /* chosen */
+
+		if (strncmp(dentry->d_name, "rtas", 4) == 0) {
+			strcat(fname, "/linux,rtas-base");
+			if ((file = fopen(fname, "r")) == NULL) {
+				perror(fname);
+				goto error_opencdir;
+			}
+			if (fread(&rtas_base, sizeof(unsigned int), 1, file) != 1) {
+				perror(fname);
+				goto error_openfile;
+			}
+			memset(fname, 0, sizeof(fname));
+			strcpy(fname, device_tree);
+			strcat(fname, dentry->d_name);
+			strcat(fname, "/rtas-size");
+			if ((file = fopen(fname, "r")) == NULL) {
+				perror(fname);
+				goto error_opencdir;
+			}
+			if (fread(&rtas_size, sizeof(unsigned int), 1, file) != 1) {
+				perror(fname);
+				goto error_openfile;
+			}
+			closedir(cdir);
+			/* Add rtas to exclude_range */
+			exclude_range[i].start = rtas_base;
+			exclude_range[i].end = rtas_base + rtas_size;
+			i++;
+			if (kexec_flags & KEXEC_ON_CRASH)
+				add_usable_mem_rgns(rtas_base, rtas_size);
+		} /* rtas */
+
+		if (!strncmp(dentry->d_name, "memory@", 7) ||
+			!strcmp(dentry->d_name, "memory")) {
+			strcat(fname, "/reg");
+			if ((file = fopen(fname, "r")) == NULL) {
+				perror(fname);
+				goto error_opencdir;
+			}
+			if ((n = fread(buf, 1, MAXBYTES, file)) < 0) {
+				perror(fname);
+				goto error_openfile;
+			}
+			rmo_base = ((unsigned long long *)buf)[0];
+			rmo_top = rmo_base + ((unsigned long long *)buf)[1];
+			if (rmo_top > 0x30000000UL)
+				rmo_top = 0x30000000UL;
+
+			fclose(file);
+			closedir(cdir);
+		} /* memory */
+
+		if (strncmp(dentry->d_name, "pci@", 4) == 0) {
+			strcat(fname, "/linux,tce-base");
+			if ((file = fopen(fname, "r")) == NULL) {
+				closedir(cdir);
+				if (errno == ENOENT) {
+					/* Non LPAR */
+					errno = 0;
+					continue;
+				}
+				perror(fname);
+				goto error_opendir;
+			}
+			if (fread(&tce_base, sizeof(uint64_t), 1, file) != 1) {
+				perror(fname);
+				goto error_openfile;
+				return -1;
+			}
+			memset(fname, 0, sizeof(fname));
+			strcpy(fname, device_tree);
+			strcat(fname, dentry->d_name);
+			strcat(fname, "/linux,tce-size");
+			if ((file = fopen(fname, "r")) == NULL) {
+				perror(fname);
+				goto error_opencdir;
+			}
+			if (fread(&tce_size, sizeof(unsigned int), 1, file) != 1) {
+				perror(fname);
+				goto error_openfile;
+			}
+			/* Add tce to exclude_range - NON-LPAR only */
+			exclude_range[i].start = tce_base;
+			exclude_range[i].end = tce_base + tce_size;
+			i++;
+			if (kexec_flags & KEXEC_ON_CRASH)
+				add_usable_mem_rgns(tce_base, tce_size);
+			closedir(cdir);
+		} /* pci */
+	}
+	closedir(dir);
+
+	nr_exclude_ranges = i;
+
+	sort_ranges();
+
+#ifdef DEBUG
+	int k;
+	for (k = 0; k < i; k++)
+		fprintf(stderr, "exclude_range sorted exclude_range[%d] "
+			"start:%llx, end:%llx\n", k, exclude_range[k].start,
+			exclude_range[k].end);
+#endif
+	return 0;
+
+error_openfile:
+	fclose(file);
+error_opencdir:
+	closedir(cdir);
+error_opendir:
+	closedir(dir);
+	return -1;
+}
+
+/* Setup a sorted list of memory ranges. */
+int setup_memory_ranges(unsigned long kexec_flags)
+{
+	int i, j = 0;
+
+	/* Get the base list of memory ranges from /proc/device-tree/memory
+	 * nodes. Build list of ranges to be excluded from valid memory
+	 */
+
+	if (get_base_ranges())
+		goto out;
+	if (get_devtree_details(kexec_flags))
+		goto out;
+
+	for (i = 0; i < nr_exclude_ranges; i++) {
+		/* If first exclude range does not start with 0, include the
+		 * first hole of valid memory from 0 - exclude_range[0].start
+		 */
+		if (i == 0) {
+			if (exclude_range[i].start != 0) {
+				memory_range[j].start = 0;
+				memory_range[j].end = exclude_range[i].start - 1;
+				memory_range[j].type = RANGE_RAM;
+				j++;
+			}
+		} /* i == 0 */
+		/* If the last exclude range does not end at memory_max, include
+		 * the last hole of valid memory from exclude_range[last].end -
+		 * memory_max
+		 */
+		if (i == nr_exclude_ranges - 1) {
+			if (exclude_range[i].end < memory_max) {
+				memory_range[j].start = exclude_range[i].end + 1;
+				memory_range[j].end = memory_max;
+				memory_range[j].type = RANGE_RAM;
+				j++;
+				/* Limit the end to rmo_top */
+				if (memory_range[j-1].start >= rmo_top) {
+					j--;
+					break;
+				}
+				if ((memory_range[j-1].start < rmo_top) &&
+				(memory_range[j-1].end >= rmo_top)) {
+					memory_range[j-1].end = rmo_top;
+					break;
+				}
+				continue;
+			}
+		} /* i == nr_exclude_ranges - 1 */
+		/* contiguous exclude ranges - skip */
+		if (exclude_range[i+1].start == exclude_range[i].end + 1)
+			continue;
+		memory_range[j].start = exclude_range[i].end + 1;
+		memory_range[j].end = exclude_range[i+1].start - 1;
+		memory_range[j].type = RANGE_RAM;
+		j++;
+		/* Limit range to rmo_top */
+		if (memory_range[j-1].start >= rmo_top) {
+			j--;
+			break;
+		}
+		if ((memory_range[j-1].start < rmo_top) &&
+			(memory_range[j-1].end >= rmo_top)) {
+			memory_range[j-1].end = rmo_top;
+			break;
+		}
+	}
+	nr_memory_ranges = j;
+
+#ifdef DEBUG
+	int k;
+	for (k = 0; k < j; k++)
+		fprintf(stderr, "setup_memory_ranges memory_range[%d] "
+			"start:%llx, end:%llx\n", k, memory_range[k].start,
+			memory_range[k].end);
+#endif
+	return 0;
+
+out:
+	cleanup_memory_ranges();
+	return -1;
+}
+
+/* Return a list of valid memory ranges */
+int get_memory_ranges(struct memory_range **range, int *ranges,
+			unsigned long kexec_flags)
+{
+	if (count_memory_ranges())
+		return -1;
+	if (alloc_memory_ranges())
+		return -1;
+	if (setup_memory_ranges(kexec_flags))
+		return -1;
+
+	*range = memory_range;
+	*ranges = nr_memory_ranges;
+	fprintf(stderr, "get memory ranges:%d\n", nr_memory_ranges);
+	return 0;
+}
+
+struct file_type file_type[] = {
+	{ "elf-ppc64", elf_ppc64_probe, elf_ppc64_load, elf_ppc64_usage },
+};
+int file_types = sizeof(file_type) / sizeof(file_type[0]);
+
+void arch_usage(void)
+{
+	fprintf(stderr, "     --command-line=<Command line> command line to append.\n");
+	fprintf(stderr, "     --append=<Command line> same as --command-line.\n");
+	fprintf(stderr, "     --ramdisk=<filename> Initial RAM disk.\n");
+	fprintf(stderr, "     --initrd=<filename> same as --ramdisk.\n");
+	fprintf(stderr, "     --devicetreeblob=<filename> Specify device tree blob file.\n");
+	fprintf(stderr, "     --elf64-core-headers Prepare core headers in ELF64 format\n");
+	fprintf(stderr, "     --ps3-legacy    Make fixups needed to boot PS3 legacy kernels.\n");
+	fprintf(stderr, "                     The default is to probe the kernel type.\n");
+	fprintf(stderr, "     --ps3-no-legacy Do not make fixups needed to boot PS3 legacy\n");
+	fprintf(stderr, "                     kernels. The default is to probe the kernel\n");
+	fprintf(stderr, "                     type.\n");
+}
+
+struct arch_options_t arch_options = {
+	.core_header_type = CORE_TYPE_ELF64,
+};
+
+int arch_process_options(int argc, char **argv)
+{
+	static const struct option options[] = {
+		KEXEC_ARCH_OPTIONS
+		{ 0, 0, NULL, 0 },
+	};
+	static const char short_options[] = KEXEC_ARCH_OPT_STR;
+	int opt;
+
+	opterr = 0; /* Don't complain about unrecognized options here */
+	while((opt = getopt_long(argc, argv, short_options, options, 0)) != -1) {
+		switch(opt) {
+		default:
+			break;
+		case OPT_ELF64_CORE:
+			arch_options.core_header_type = CORE_TYPE_ELF64;
+			break;
+		}
+	}
+	/* Reset getopt for the next pass; called in other source modules */
+	opterr = 1;
+	optind = 1;
+	return 0;
+}
+
+int arch_compat_trampoline(struct kexec_info *info)
+{
+	int result;
+	struct utsname utsname;
+	result = uname(&utsname);
+	if (result < 0) {
+		fprintf(stderr, "uname failed: %s\n",
+			strerror(errno));
+		return -1;
+	}
+	if (strcmp(utsname.machine, "ppc64") == 0)
+	{
+		/* We are running a 32-bit kexec-tools on 64-bit ppc64.
+		 * So pass KEXEC_ARCH_PPC64 here
+		 */
+		info->kexec_flags |= KEXEC_ARCH_PPC64;
+	}
+	else {
+		fprintf(stderr, "Unsupported machine type: %s\n",
+			utsname.machine);
+		return -1;
+	}
+	return 0;
+}
+
+void arch_update_purgatory(struct kexec_info *info)
+{
+}
diff -Nur kexec-tools-1.101/kexec/arch/ppc64/kexec-ppc64.h kexec-tools-1.101-geoff/kexec/arch/ppc64/kexec-ppc64.h
--- kexec-tools-1.101/kexec/arch/ppc64/kexec-ppc64.h	2004-12-17 12:44:42.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/ppc64/kexec-ppc64.h	2007-10-23 16:24:40.000000000 +0700
@@ -1,9 +1,46 @@
 #ifndef KEXEC_PPC64_H
 #define KEXEC_PPC64_H
 
+#define MAXBYTES 128
+#define MAX_LINE 160
+#define CORE_TYPE_ELF32 1
+#define CORE_TYPE_ELF64 2
+
+int setup_memory_ranges(unsigned long kexec_flags);
+
 int elf_ppc64_probe(const char *buf, off_t len);
 int elf_ppc64_load(int argc, char **argv, const char *buf, off_t len,
 	struct kexec_info *info);
 void elf_ppc64_usage(void);
+void reserve(unsigned long long where, unsigned long long length);
+
+extern uint64_t initrd_base, initrd_size;
+extern int max_memory_ranges;
+extern unsigned char reuse_initrd;
+
+/* boot block version 2 as defined by the linux kernel */
+struct bootblock {
+	unsigned magic,
+		totalsize,
+		off_dt_struct,
+		off_dt_strings,
+		off_mem_rsvmap,
+		version,
+		last_comp_version,
+		boot_physid;
+};
+
+struct arch_options_t {
+	int core_header_type;
+};
+
+typedef struct mem_rgns {
+        unsigned int size;
+        struct memory_range *ranges;
+} mem_rgns_t;
+
+extern mem_rgns_t usablemem_rgns;
+
+extern int ps3_legacy;
 
-#endif /* KEXEC_PPC_H */
+#endif /* KEXEC_PPC64_H */
diff -Nur kexec-tools-1.101/kexec/arch/ppc64/kexec-zImage-ppc64.c kexec-tools-1.101-geoff/kexec/arch/ppc64/kexec-zImage-ppc64.c
--- kexec-tools-1.101/kexec/arch/ppc64/kexec-zImage-ppc64.c	2004-12-16 18:17:51.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/ppc64/kexec-zImage-ppc64.c	2007-10-23 16:24:40.000000000 +0700
@@ -71,7 +71,7 @@
 	Elf32_Phdr *p, *ph;
 	struct kexec_segment *segment;
 	int i;
-	unsigned long memsize, filesize, offset, load_loc;
+	unsigned long memsize, filesize, offset, load_loc = 0;
 
 	/* Parse command line arguments */
 
@@ -153,7 +153,8 @@
 			return -1;
 		}
 		mem_offset = p->p_vaddr - load_loc;
-		if (fread(segment->buf+mem_offset, p->p_filesz, 1, file) != 1) {
+		if (fread((void *)segment->buf+mem_offset, p->p_filesz, 1,
+				file) != 1) {
 			perror("read error: ");
 			return -1;
 		}
@@ -161,7 +162,7 @@
 	segment->mem = (void *) load_loc;
 	segment->memsz = memsize;
 	segment->bufsz = filesize;
-	*ret_entry = elf.e_entry;
+	*ret_entry = (void *)((uint64_t)elf.e_entry);
 	*ret_nr_segments = i - 1;
 	free(ph);
 	return 0;
diff -Nur kexec-tools-1.101/kexec/arch/ppc64/Makefile kexec-tools-1.101-geoff/kexec/arch/ppc64/Makefile
--- kexec-tools-1.101/kexec/arch/ppc64/Makefile	2004-12-17 12:35:30.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/ppc64/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -2,6 +2,10 @@
 # kexec ppc64 (linux booting linux)
 #
 KEXEC_C_SRCS+= kexec/arch/ppc64/kexec-elf-rel-ppc64.c
-KEXEC_C_SRCS+= kexec/arch/ppc64/kexec-zImage-ppc64.c 
+KEXEC_C_SRCS+= kexec/arch/ppc64/kexec-zImage-ppc64.c
+KEXEC_C_SRCS+= kexec/arch/ppc64/fs2dt.c
+KEXEC_C_SRCS+= kexec/arch/ppc64/kexec-elf-ppc64.c
+KEXEC_C_SRCS+= kexec/arch/ppc64/kexec-ppc64.c
+KEXEC_C_SRCS+= kexec/arch/ppc64/crashdump-ppc64.c
 
 KEXEC_S_SRCS+=
diff -Nur kexec-tools-1.101/kexec/arch/s390/include/arch/options.h kexec-tools-1.101-geoff/kexec/arch/s390/include/arch/options.h
--- kexec-tools-1.101/kexec/arch/s390/include/arch/options.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/s390/include/arch/options.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,11 @@
+#ifndef KEXEC_ARCH_S390_OPTIONS_H
+#define KEXEC_ARCH_S390_OPTIONS_H
+
+#define OPT_ARCH_MAX   (OPT_MAX+0)
+
+#define KEXEC_ARCH_OPTIONS \
+	KEXEC_OPTIONS \
+
+#define KEXEC_ARCH_OPT_STR KEXEC_OPT_STR ""
+
+#endif /* KEXEC_ARCH_S390_OPTIONS_H */
diff -Nur kexec-tools-1.101/kexec/arch/s390/kexec-elf-rel-s390.c kexec-tools-1.101-geoff/kexec/arch/s390/kexec-elf-rel-s390.c
--- kexec-tools-1.101/kexec/arch/s390/kexec-elf-rel-s390.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/s390/kexec-elf-rel-s390.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,23 @@
+/*
+ * kexec/arch/s390/kexec-elf-rel-s390.c
+ *
+ * (C) Copyright IBM Corp. 2005
+ *
+ * Author(s): Heiko Carstens <heiko.carstens@de.ibm.com>
+ *
+ */
+
+#include <stdio.h>
+#include <elf.h>
+#include "../../kexec.h"
+#include "../../kexec-elf.h"
+
+int machine_verify_elf_rel(struct mem_ehdr *ehdr)
+{
+	return 0;
+}
+
+void machine_apply_elf_rel(struct mem_ehdr *ehdr, unsigned long r_type,
+	void *location, unsigned long address, unsigned long value)
+{
+}
diff -Nur kexec-tools-1.101/kexec/arch/s390/kexec-image.c kexec-tools-1.101-geoff/kexec/arch/s390/kexec-image.c
--- kexec-tools-1.101/kexec/arch/s390/kexec-image.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/s390/kexec-image.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,137 @@
+/*
+ * kexec/arch/s390/kexec-image.c
+ *
+ * (C) Copyright IBM Corp. 2005
+ *
+ * Author(s): Rolf Adelsberger <adelsberger@de.ibm.com>
+ *            Heiko Carstens <heiko.carstens@de.ibm.com>
+ *
+ */
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <getopt.h>
+#include "../../kexec.h"
+#include "kexec-s390.h"
+
+#define OPT_APPEND     OPT_MAX+0
+#define OPT_RAMDISK    OPT_MAX+1
+
+int
+image_s390_load(int argc, char **argv, const char *kernel_buf,
+		off_t kernel_size, struct kexec_info *info)
+{
+	void *krnl_buffer;
+	char *rd_buffer;
+	const char *command_line;
+	const char *ramdisk;
+	int command_line_len;
+	off_t ramdisk_len;
+	unsigned int ramdisk_origin;
+	int opt;
+
+	static const struct option options[] =
+		{
+			KEXEC_OPTIONS
+			{"command-line",     1, 0, OPT_APPEND},
+			{"initrd",           1, 0, OPT_RAMDISK},
+			{0,                  0, 0, 0},
+		};
+	static const char short_options[] = KEXEC_OPT_STR "";
+
+	ramdisk = NULL;
+	command_line = NULL;
+	ramdisk_len = 0;
+	ramdisk_origin = 0;
+
+	while ((opt = getopt_long(argc,argv,short_options,options,0)) != -1) {
+		switch(opt) {
+		case '?':
+			usage();
+			return -1;
+			break;
+		case OPT_APPEND:
+			command_line = optarg;
+			break;
+		case OPT_RAMDISK:
+			ramdisk = optarg;
+			break;
+		}
+	}
+
+	/* Process a given command_line: */
+	if (command_line) {
+		command_line_len = strlen(command_line) + 1; /* Remember the '\0' */
+		if (command_line_len > COMMAND_LINESIZE) {
+		        fprintf(stderr, "Command line too long.\n");
+			return -1;
+		}
+	}
+
+	/* Add kernel segment */
+	add_segment(info, kernel_buf + IMAGE_READ_OFFSET,
+		    kernel_size - IMAGE_READ_OFFSET, IMAGE_READ_OFFSET,
+		    kernel_size - IMAGE_READ_OFFSET);
+
+	/* We do want to change the kernel image */
+	krnl_buffer = (void *) kernel_buf + IMAGE_READ_OFFSET;
+
+	/* Load ramdisk if present */
+	if (ramdisk) {
+		rd_buffer = slurp_file(ramdisk, &ramdisk_len);
+		if (rd_buffer == NULL) {
+			fprintf(stderr, "Could not read ramdisk.\n");
+			return -1;
+		}
+		ramdisk_origin = RAMDISK_ORIGIN_ADDR;
+		add_segment(info, rd_buffer, ramdisk_len, RAMDISK_ORIGIN_ADDR, ramdisk_len);
+	}
+	
+	/* Register the ramdisk in the kernel. */
+	{
+		unsigned long long *tmp;
+
+		tmp = krnl_buffer + INITRD_START_OFFS;
+		*tmp = (unsigned long long) ramdisk_origin;
+
+		tmp = krnl_buffer + INITRD_SIZE_OFFS;
+		*tmp = (unsigned long long) ramdisk_len;
+	}
+
+	/*
+	 * We will write a probably given command line.
+	 * First, erase the old area, then setup the new parameters:
+	 */
+	if (command_line) {
+		memset(krnl_buffer + COMMAND_LINE_OFFS, 0, COMMAND_LINESIZE);
+		memcpy(krnl_buffer + COMMAND_LINE_OFFS, command_line, strlen(command_line));
+	}
+
+	info->entry = (void *) IMAGE_READ_OFFSET;
+
+	return 0;
+}
+
+int 
+image_s390_probe(const char *kernel_buf, off_t kernel_size)
+{
+	/*
+	 * Can't reliably tell if an image is valid,
+	 * therefore everything is valid.
+	 */
+	return 0;
+}
+
+void
+image_s390_usage(void)
+{
+	printf("--command-line=STRING Pass a custom command line STRING to the kernel.\n"
+	       "--initrd=FILENAME     Use the file FILENAME as a ramdisk.\n"
+		);
+}
diff -Nur kexec-tools-1.101/kexec/arch/s390/kexec-s390.c kexec-tools-1.101-geoff/kexec/arch/s390/kexec-s390.c
--- kexec-tools-1.101/kexec/arch/s390/kexec-s390.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/s390/kexec-s390.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,110 @@
+/*
+ * kexec/arch/s390/kexec-s390.c
+ *
+ * (C) Copyright IBM Corp. 2005
+ *
+ * Author(s): Rolf Adelsberger <adelsberger@de.ibm.com>
+ *
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+#include <string.h>
+#include <getopt.h>
+#include <sys/utsname.h>
+#include "../../kexec.h"
+#include "../../kexec-syscall.h"
+#include "kexec-s390.h"
+#include <arch/options.h>
+
+#define MAX_MEMORY_RANGES 64
+static struct memory_range memory_range[MAX_MEMORY_RANGES];
+
+/*
+ * get_memory_ranges:
+ *  Return a list of memory ranges by parsing /proc/iomem
+ *
+ * INPUT:
+ *  - Pointer to an array of memory_range structures.
+ *  - Pointer to an integer with holds the number of memory ranges.
+ *
+ * RETURN:
+ *  - 0 on normal execution.
+ *  - (-1) if something went wrong.
+ */
+
+int get_memory_ranges(struct memory_range **range, int *ranges, unsigned long flags)
+{
+	char sys_ram[] = "System RAM\n";
+	char iomem[] = "/proc/iomem";
+	FILE *fp;
+	char line[80];
+	int current_range = 0;
+
+	fp = fopen(iomem,"r");
+	if(fp == 0) {
+		fprintf(stderr,"Unable to open %s: %s\n",iomem,strerror(errno));
+		return -1;
+	}
+
+	/* Setup the compare string properly. */
+	while(fgets(line,sizeof(line),fp) != 0) {
+		unsigned long long start, end;
+		int cons;
+		char *str;
+
+		if (current_range == MAX_MEMORY_RANGES)
+			break;
+
+		sscanf(line,"%Lx-%Lx : %n", &start, &end, &cons);
+		str = line+cons;
+		if(memcmp(str,sys_ram,strlen(sys_ram)) == 0) {
+			memory_range[current_range].start = start;
+			memory_range[current_range].end = end;
+			memory_range[current_range].type = RANGE_RAM;
+			current_range++;
+		}
+		else {
+			continue;
+		}
+	}
+	fclose(fp);
+	*range = memory_range;
+	*ranges = current_range;
+
+	return 0;
+}
+
+/* Supported file types and callbacks */
+struct file_type file_type[] = {
+	{ "image", image_s390_probe, image_s390_load, image_s390_usage},
+};
+int file_types = sizeof(file_type) / sizeof(file_type[0]);
+
+
+void arch_usage(void)
+{
+}
+
+int arch_process_options(int argc, char **argv)
+{
+	return 0;
+}
+
+int arch_compat_trampoline(struct kexec_info *info)
+{
+	info->kexec_flags |= KEXEC_ARCH_S390;
+	return 0;
+}
+
+void arch_update_purgatory(struct kexec_info *info)
+{
+}
+
+int is_crashkernel_mem_reserved(void)
+{
+	return 0; /* kdump is not supported on this platform (yet) */
+}
diff -Nur kexec-tools-1.101/kexec/arch/s390/kexec-s390.h kexec-tools-1.101-geoff/kexec/arch/s390/kexec-s390.h
--- kexec-tools-1.101/kexec/arch/s390/kexec-s390.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/s390/kexec-s390.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,25 @@
+/*
+ * kexec/arch/s390/kexec-s390.h
+ *
+ * (C) Copyright IBM Corp. 2005
+ *
+ * Author(s): Rolf Adelsberger <adelsberger@de.ibm.com>
+ *
+ */
+
+#ifndef KEXEC_S390_H
+#define KEXEC_S390_H
+
+#define IMAGE_READ_OFFSET     0x10000
+
+#define RAMDISK_ORIGIN_ADDR   0x800000
+#define INITRD_START_OFFS     0x408
+#define INITRD_SIZE_OFFS      0x410
+#define COMMAND_LINE_OFFS     0x480
+#define COMMAND_LINESIZE      896
+
+extern int image_s390_load(int, char **, const char *, off_t, struct kexec_info *);
+extern int image_s390_probe(const char *, off_t);
+extern void image_s390_usage(void);
+
+#endif /* KEXEC_IA64_H */
diff -Nur kexec-tools-1.101/kexec/arch/s390/Makefile kexec-tools-1.101-geoff/kexec/arch/s390/Makefile
--- kexec-tools-1.101/kexec/arch/s390/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/s390/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,6 @@
+#
+# kexec s390 (linux booting linux)
+#
+KEXEC_C_SRCS+= kexec/arch/s390/kexec-s390.c
+KEXEC_C_SRCS+= kexec/arch/s390/kexec-image.c
+KEXEC_C_SRCS+= kexec/arch/s390/kexec-elf-rel-s390.c
diff -Nur kexec-tools-1.101/kexec/arch/sh/include/arch/options.h kexec-tools-1.101-geoff/kexec/arch/sh/include/arch/options.h
--- kexec-tools-1.101/kexec/arch/sh/include/arch/options.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/sh/include/arch/options.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,22 @@
+#ifndef KEXEC_ARCH_SH_OPTIONS_H
+#define KEXEC_ARCH_SH_OPTIONS_H
+
+#define OPT_ARCH_MAX     (OPT_MAX+0)
+#define OPT_APPEND       (OPT_ARCH_MAX+1)
+#define OPT_EMPTYZERO    (OPT_ARCH_MAX+2)
+#define OPT_NBSD_HOWTO   (OPT_ARCH_MAX+3)
+#define OPT_NBSD_MROOT   (OPT_ARCH_MAX+4)
+
+
+#define KEXEC_ARCH_OPTIONS \
+	KEXEC_OPTIONS \
+        {"command-line",   1, 0, OPT_APPEND}, \
+        {"append",         1, 0, OPT_APPEND}, \
+        {"empty-zero",     1, 0, OPT_APPEND}, \
+        {"howto",          1, 0, OPT_NBSD_HOWTO}, \
+        {"miniroot",       1, 0, OPT_NBSD_MROOT}, \
+
+
+#define KEXEC_ARCH_OPT_STR KEXEC_OPT_STR ""
+
+#endif /* KEXEC_ARCH_SH_OPTIONS_H */
diff -Nur kexec-tools-1.101/kexec/arch/sh/kexec-elf-rel-sh.c kexec-tools-1.101-geoff/kexec/arch/sh/kexec-elf-rel-sh.c
--- kexec-tools-1.101/kexec/arch/sh/kexec-elf-rel-sh.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/sh/kexec-elf-rel-sh.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,18 @@
+#include <stdio.h>
+#include <elf.h>
+#include "../../kexec.h"
+#include "../../kexec-elf.h"
+
+int machine_verify_elf_rel(struct mem_ehdr *ehdr)
+{
+
+        die("machine_verify_elf_rel is not implemented\n");
+	return 0;
+}
+
+void machine_apply_elf_rel(struct mem_ehdr *ehdr, unsigned long r_type,
+	void *location, unsigned long address, unsigned long value)
+{
+        die("Unknown rela relocation: %lu\n", r_type);
+	return;
+}
diff -Nur kexec-tools-1.101/kexec/arch/sh/kexec-netbsd-sh.c kexec-tools-1.101-geoff/kexec/arch/sh/kexec-netbsd-sh.c
--- kexec-tools-1.101/kexec/arch/sh/kexec-netbsd-sh.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/sh/kexec-netbsd-sh.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,153 @@
+/*
+ * kexec-netbsd-sh.c - kexec netbsd loader for the SH
+ * Copyright (C) 2005 kogiidena@eggplant.ddo.jp
+ *
+ * This source code is licensed under the GNU General Public License,
+ * Version 2.  See the file COPYING for more details.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <elf.h>
+#include <boot/elf_boot.h>
+#include <ip_checksum.h>
+#include "../../kexec.h"
+#include "../../kexec-elf.h"
+#include <arch/options.h>
+#include <asm/page.h>
+
+static const int probe_debug = 0;
+const extern unsigned char netbsd_booter[];
+
+#define PAGE_ALIGN(addr)        (((addr)+PAGE_SIZE-1)&PAGE_MASK)
+
+/*
+ * netbsd_sh_probe - sanity check the elf image
+ *
+ * Make sure that the file image has a reasonable chance of working.
+ */
+int netbsd_sh_probe(const char *buf, off_t len)
+{
+	Elf32_Ehdr *ehdr;
+
+	ehdr = (Elf32_Ehdr *)buf;
+	if(memcmp(buf, ELFMAG, SELFMAG) != 0){
+	        return -1;
+	}
+	if (ehdr->e_machine != EM_SH) {
+		return -1;
+	}
+	return 0;
+}
+
+void netbsd_sh_usage(void)
+{
+	printf(
+		" --howto=VALUE        NetBSD kernel boot option.\n"
+		" --miniroot=FILE      NetBSD miniroot ramdisk.\n\n");
+}
+
+int netbsd_sh_load(int argc, char **argv, const char *buf, off_t len,
+	struct kexec_info *info)
+{
+	const char *howto, *miniroot;
+	unsigned long entry, start, size;
+	char *miniroot_buf;
+	off_t miniroot_length;
+	unsigned int howto_value;
+	unsigned char *param;
+	unsigned long *paraml;
+	unsigned char *img;
+
+	int opt;
+
+	static const struct option options[] = {
+		KEXEC_ARCH_OPTIONS
+		{0, 0, 0, 0},
+	};
+
+	static const char short_options[] = KEXEC_ARCH_OPT_STR "";
+
+	howto = miniroot = 0;
+	while ((opt = getopt_long(argc, argv, short_options, options, 0)) != -1) {
+		switch (opt) {
+		default:
+			/* Ignore core options */
+			if (opt < OPT_ARCH_MAX) {
+				break;
+			}
+		case '?':
+			usage();
+			return -1;
+		case OPT_NBSD_HOWTO:
+			howto = optarg;
+			break;
+		case OPT_NBSD_MROOT:
+			miniroot = optarg;
+			break;
+		}
+	}
+
+	/* howto */
+	howto_value = 0;
+	if(howto){
+	        howto_value = strtol(howto, NULL, 0);
+	}
+
+	/* Parse the Elf file */
+	{
+	        Elf32_Ehdr *ehdr;
+		Elf32_Phdr *phdr;
+		unsigned long bbs;
+		ehdr = (Elf32_Ehdr *)buf;
+		phdr = (Elf32_Phdr *)&buf[ehdr->e_phoff];
+
+		entry     = ehdr->e_entry;
+		img       = (unsigned char *)&buf[phdr->p_offset];
+		start     = (phdr->p_paddr) & 0x1fffffff;
+		bbs       = phdr->p_filesz;
+		size      = phdr->p_memsz;
+
+		if(size < bbs){
+		        size = bbs;
+		}
+		size  = PAGE_ALIGN(size);
+		memset(&img[bbs], 0, size-bbs);
+		add_segment(info, img, size, start, size);
+		start += size;
+	}
+
+	/* miniroot file */
+	miniroot_buf = 0;
+	if (miniroot) {
+		miniroot_buf = slurp_file(miniroot, &miniroot_length);
+		howto_value |= 0x200;
+		size = PAGE_ALIGN(miniroot_length);
+		add_segment(info, miniroot_buf, size, start, size);
+		start += size;
+	}
+
+	/* howto & bootinfo */
+	param  = xmalloc(4096);
+	memset(param, 0, 4096);
+	paraml = (unsigned long *) &param[256];
+	memcpy(param, netbsd_booter, 256);
+	paraml[0] = entry;
+	paraml[1] = howto_value;
+	add_segment(info, param, 4096, start, 4096);
+
+	/* For now we don't have arguments to pass :( */
+	info->entry = (void *) (start | 0xa0000000);
+	return 0;
+}
diff -Nur kexec-tools-1.101/kexec/arch/sh/kexec-sh.c kexec-tools-1.101-geoff/kexec/arch/sh/kexec-sh.c
--- kexec-tools-1.101/kexec/arch/sh/kexec-sh.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/sh/kexec-sh.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,171 @@
+/*
+ * kexec-sh.c - kexec for the SH
+ * Copyright (C) 2004 kogiidena@eggplant.ddo.jp
+ *
+ * This source code is licensed under the GNU General Public License,
+ * Version 2.  See the file COPYING for more details.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include <sys/utsname.h>
+#include "../../kexec.h"
+#include "../../kexec-syscall.h"
+#include "kexec-sh.h"
+#include <arch/options.h>
+
+#define MAX_MEMORY_RANGES 64
+static struct memory_range memory_range[MAX_MEMORY_RANGES];
+
+/* Return a sorted list of available memory ranges. */
+int get_memory_ranges(struct memory_range **range, int *ranges,
+		      unsigned long kexec_flags)
+{
+	int memory_ranges;
+
+	memory_ranges = 0;
+	memory_range[memory_ranges].start = 0x08000000;
+	memory_range[memory_ranges].end   = 0x10000000;
+	memory_range[memory_ranges].type  = RANGE_RAM;
+	memory_ranges++;
+	*range = memory_range;
+	*ranges = memory_ranges;
+	return 0;
+}
+
+/* Supported file types and callbacks */
+struct file_type file_type[] = {
+       {"zImage-sh", zImage_sh_probe, zImage_sh_load, zImage_sh_usage},
+       {"netbsd-sh", netbsd_sh_probe, netbsd_sh_load, netbsd_sh_usage},
+};
+int file_types = sizeof(file_type) / sizeof(file_type[0]);
+
+
+void arch_usage(void)
+{
+
+  printf(
+    " none\n\n"
+    "Default options:\n"
+    " --append=\"%s\"\n"
+    " --empty-zero=0x%08x\n\n"
+    " STRING of --appned is set form /proc/cmdline as default.\n"
+    " ADDRESS of --empty-zero can be set SHELL environment variable\n"
+    " KEXEC_EMPTY_ZERO as default.\n\n"
+    " ADDRESS can be get in the following method in your system. \n"
+    " 1) \"grep empty_zero /proc/kallsyms\". \n"
+    " 2) \"grep empty_zero System.map\". \n"
+    " 3) CONFIG_MEMORY_START + CONFIG_ZERO_PAGE_OFFSET in your kernel\n"
+    "    config file.\n"
+    ,get_append(), (unsigned int) get_empty_zero(NULL));
+
+}
+
+int arch_process_options(int argc, char **argv)
+{
+	static const struct option options[] = {
+		KEXEC_ARCH_OPTIONS
+		{ 0, 			0, NULL, 0 },
+	};
+	static const char short_options[] = KEXEC_ARCH_OPT_STR;
+	int opt;
+
+	opterr = 0; /* Don't complain about unrecognized options here */
+	while((opt = getopt_long(argc, argv, short_options, options, 0)) != -1) {
+		switch(opt) {
+		default:
+			/* Ignore core options */
+			if (opt < OPT_MAX) {
+				break;
+			}
+		case '?':
+		        usage();
+		  	return -1;
+		case OPT_APPEND:
+		case OPT_NBSD_HOWTO:
+		case OPT_NBSD_MROOT:
+		  ;
+		}
+	}
+	/* Reset getopt for the next pass; called in other source modules */
+	opterr = 1;
+	optind = 1;
+	return 0;
+}
+
+int arch_compat_trampoline(struct kexec_info *info)
+{
+	int result;
+	struct utsname utsname;
+	result = uname(&utsname);
+	if (result < 0) {
+		fprintf(stderr, "uname failed: %s\n",
+			strerror(errno));
+		return -1;
+	}
+	if (	(strcmp(utsname.machine, "sh3") == 0) ||
+		(strcmp(utsname.machine, "sh4") == 0) ||
+		(strcmp(utsname.machine, "sh4a") == 0))
+	{
+		/*
+		 * For compatibility with older patches
+		 * use KEXEC_ARCH_DEFAULT instead of KEXEC_ARCH_SH here.
+		 */
+		info->kexec_flags |= KEXEC_ARCH_DEFAULT;
+	}
+	else {
+		fprintf(stderr, "Unsupported machine type: %s\n",
+			utsname.machine);
+		return -1;
+	}
+	return 0;
+}
+
+void arch_update_purgatory(struct kexec_info *info)
+{
+}
+
+
+unsigned long get_empty_zero(char *s)
+{
+        char *env;
+
+	env = getenv("KEXEC_EMPTY_ZERO");
+
+	if(s){
+	  env = s;
+	}else if(!env){
+	  env = "0x0c001000";
+	}
+	return 0x1fffffff & strtoul(env,(char **)NULL,0);
+}
+
+char append_buf[256];
+
+char *get_append(void)
+{
+        FILE *fp;
+        int len;
+        if((fp = fopen("/proc/cmdline", "r")) == NULL){
+              printf("/proc/cmdline file open error !!\n");
+              exit(1);
+        }
+        fgets(append_buf, 256, fp);
+        len = strlen(append_buf);
+        append_buf[len-1] = 0;
+        fclose(fp);
+        return append_buf;
+}
+
+
+int is_crashkernel_mem_reserved(void)
+{
+	return 0; /* kdump is not supported on this platform (yet) */
+}
+
diff -Nur kexec-tools-1.101/kexec/arch/sh/kexec-sh.h kexec-tools-1.101-geoff/kexec/arch/sh/kexec-sh.h
--- kexec-tools-1.101/kexec/arch/sh/kexec-sh.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/sh/kexec-sh.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,17 @@
+#ifndef KEXEC_SH_H
+#define KEXEC_SH_H
+
+int zImage_sh_probe(const char *buf, off_t len);
+int zImage_sh_load(int argc, char **argv, const char *buf, off_t len,
+	struct kexec_info *info);
+void zImage_sh_usage(void);
+
+int netbsd_sh_probe(const char *buf, off_t len);
+int netbsd_sh_load(int argc, char **argv, const char *buf, off_t len,
+	struct kexec_info *info);
+void netbsd_sh_usage(void);
+
+char *get_append(void);
+unsigned long get_empty_zero(char *s);
+
+#endif /* KEXEC_SH_H */
diff -Nur kexec-tools-1.101/kexec/arch/sh/kexec-zImage-sh.c kexec-tools-1.101-geoff/kexec/arch/sh/kexec-zImage-sh.c
--- kexec-tools-1.101/kexec/arch/sh/kexec-zImage-sh.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/sh/kexec-zImage-sh.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,106 @@
+/*
+ * kexec-zImage-sh.c - kexec zImage loader for the SH
+ * Copyright (C) 2005 kogiidena@eggplant.ddo.jp
+ *
+ * This source code is licensed under the GNU General Public License,
+ * Version 2.  See the file COPYING for more details.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <elf.h>
+#include <boot/elf_boot.h>
+#include <ip_checksum.h>
+#include "../../kexec.h"
+#include "../../kexec-elf.h"
+#include <arch/options.h>
+#include "kexec-sh.h"
+
+static const int probe_debug = 0;
+
+/*
+ * zImage_sh_probe - sanity check the elf image
+ *
+ * Make sure that the file image has a reasonable chance of working.
+ */
+int zImage_sh_probe(const char *buf, off_t len)
+{
+	if (memcmp(&buf[0x202], "HdrS", 4) != 0) {
+	        fprintf(stderr, "Not a zImage\n");
+	        return -1;
+	}
+	return 0;
+}
+
+void zImage_sh_usage(void)
+{
+	printf(
+    " --append=STRING      Set the kernel command line to STRING.\n"
+    " --empty-zero=ADDRESS Set the kernel top ADDRESS. \n\n");
+
+}
+
+int zImage_sh_load(int argc, char **argv, const char *buf, off_t len,
+	struct kexec_info *info)
+{
+        char *command_line;
+	int opt;
+	unsigned long empty_zero, area;
+	unsigned char *param;
+	unsigned long *paraml;
+
+	static const struct option options[] = {
+       	        KEXEC_ARCH_OPTIONS
+		{0, 0, 0, 0},
+	};
+
+	static const char short_options[] = KEXEC_ARCH_OPT_STR "";
+
+	command_line = 0;
+	empty_zero = get_empty_zero(NULL);
+	while ((opt = getopt_long(argc, argv, short_options, options, 0)) != -1) {
+		switch (opt) {
+		default:
+			/* Ignore core options */
+			if (opt < OPT_ARCH_MAX) {
+				break;
+			}
+		case '?':
+			usage();
+			return -1;
+		case OPT_APPEND:
+			command_line = optarg;
+			break;
+		case OPT_EMPTYZERO:
+			empty_zero = get_empty_zero(optarg);
+			break;
+		}
+	}
+	param = xmalloc(4096);
+	memset(param, 0, 4096);
+	area       = empty_zero & 0x1c000000;
+	if (!command_line) {
+	        command_line = get_append();
+	}
+	strncpy(&param[256], command_line, strlen(command_line));
+        paraml = (unsigned long *)param;
+	// paraml[0] = 1;  // readonly flag is set as default
+
+	add_segment(info, param, 4096, empty_zero, 4096);
+	add_segment(info, buf,   len,  (area | 0x00210000), len);
+
+	/* For now we don't have arguments to pass :( */
+	info->entry = (void *)(0x80210000 | area);
+	return 0;
+}
diff -Nur kexec-tools-1.101/kexec/arch/sh/Makefile kexec-tools-1.101-geoff/kexec/arch/sh/Makefile
--- kexec-tools-1.101/kexec/arch/sh/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/sh/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,8 @@
+#
+# kexec sh (linux booting linux)
+#
+KEXEC_C_SRCS+= kexec/arch/sh/kexec-sh.c
+KEXEC_C_SRCS+= kexec/arch/sh/kexec-zImage-sh.c
+KEXEC_C_SRCS+= kexec/arch/sh/kexec-netbsd-sh.c
+KEXEC_C_SRCS+= kexec/arch/sh/kexec-elf-rel-sh.c
+KEXEC_S_SRCS+= kexec/arch/sh/netbsd_booter.S
diff -Nur kexec-tools-1.101/kexec/arch/sh/netbsd_booter.S kexec-tools-1.101-geoff/kexec/arch/sh/netbsd_booter.S
--- kexec-tools-1.101/kexec/arch/sh/netbsd_booter.S	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/sh/netbsd_booter.S	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,47 @@
+	.globl	netbsd_booter
+netbsd_booter:
+	mov.l	ccr,r0
+	mov	#0,r1
+	mov.l	r1,@r0
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	mova	netbsd_start,r0
+	mov.l	@r0,r1
+	add	#4,r0
+	mov.l	@r0,r4		! howto
+	add	#4,r0
+	mov	r0,r5		! bootinfo
+	jmp	@r1
+	nop
+	nop
+	nop
+	.align 4
+ccr:	.long 0xff00001c
+
+	.align 8
+netbsd_start:
+	.long 0x8c001000
+	.long 0x200		! howto
+	.long 0			! bootinfo
+	.long 0			! bootinfo
+	.long 0			! bootinfo
+	.long 0			! bootinfo
+	.long 0			! bootinfo
+	.long 0			! bootinfo
+	.long 0			! bootinfo
+	.long 0			! bootinfo
+	.long 0			! bootinfo
+	.long 0			! bootinfo
+	.long 0			! bootinfo
+	.long 0			! bootinfo
+	.long 0			! bootinfo
+	.long 0			! bootinfo
+
diff -Nur kexec-tools-1.101/kexec/arch/x86_64/crashdump-x86_64.c kexec-tools-1.101-geoff/kexec/arch/x86_64/crashdump-x86_64.c
--- kexec-tools-1.101/kexec/arch/x86_64/crashdump-x86_64.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/x86_64/crashdump-x86_64.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,647 @@
+/*
+ * kexec: Linux boots Linux
+ *
+ * Created by: Murali M Chakravarthy (muralim@in.ibm.com)
+ * Copyright (C) IBM Corporation, 2005. All rights reserved
+ * Heavily borrowed from kexec/arch/i386/crashdump-x86.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <limits.h>
+#include <elf.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include "../../kexec.h"
+#include "../../kexec-elf.h"
+#include "../../kexec-syscall.h"
+#include "../../crashdump.h"
+#include "kexec-x86_64.h"
+#include "crashdump-x86_64.h"
+#include <x86/x86-linux.h>
+
+static struct crash_elf_info elf_info =
+{
+	class: ELFCLASS64,
+	data: ELFDATA2LSB,
+	machine: EM_X86_64,
+	backup_src_start: BACKUP_SRC_START,
+	backup_src_end: BACKUP_SRC_END,
+	page_offset: PAGE_OFFSET,
+};
+
+/* Forward Declaration. */
+static int exclude_crash_reserve_region(int *nr_ranges);
+
+#define KERN_VADDR_ALIGN	0x100000	/* 1MB */
+
+/* Read kernel physical load addr from /proc/iomem (Kernel Code) and
+ * store in kexec_info */
+static int get_kernel_paddr(struct kexec_info *info)
+{
+	uint64_t start;
+
+	if (xen_present()) /* Kernel not entity mapped under Xen */
+		return 0;
+
+	if (parse_iomem_single("Kernel code\n", &start, NULL) == 0) {
+		info->kern_paddr_start = start;
+#ifdef DEBUG
+		printf("kernel load physical addr start = 0x%016Lx\n", start);
+#endif
+		return 0;
+	}
+
+	fprintf(stderr, "Cannot determine kernel physical load addr\n");
+	return -1;
+}
+
+/* Retrieve info regarding virtual address kernel has been compiled for and
+ * size of the kernel from /proc/kcore. Current /proc/kcore parsing from
+ * from kexec-tools fails because of malformed elf notes. A kernel patch has
+ * been submitted. For the folks using older kernels, this function
+ * hard codes the values to remain backward compatible. Once things stablize
+ * we should get rid of backward compatible code. */
+
+static int get_kernel_vaddr_and_size(struct kexec_info *info)
+{
+	int result;
+	const char kcore[] = "/proc/kcore";
+	char *buf;
+	struct mem_ehdr ehdr;
+	struct mem_phdr *phdr, *end_phdr;
+	int align;
+	unsigned long size;
+	uint32_t elf_flags = 0;
+
+	if (xen_present()) /* Kernel not entity mapped under Xen */
+		return 0;
+
+	align = getpagesize();
+	size = KCORE_ELF_HEADERS_SIZE;
+	buf = slurp_file_len(kcore, size);
+	if (!buf) {
+		fprintf(stderr, "Cannot read %s: %s\n", kcore, strerror(errno));
+		return -1;
+	}
+
+	/* Don't perform checks to make sure stated phdrs and shdrs are
+	 * actually present in the core file. It is not practical
+	 * to read the GB size file into a user space buffer, Given the
+	 * fact that we don't use any info from that.
+	 */
+	elf_flags |= ELF_SKIP_FILESZ_CHECK;
+	result = build_elf_core_info(buf, size, &ehdr, elf_flags);
+	if (result < 0) {
+		fprintf(stderr, "ELF core (kcore) parse failed\n");
+		return -1;
+	}
+
+	/* Traverse through the Elf headers and find the region where
+	 * kernel is mapped. */
+	end_phdr = &ehdr.e_phdr[ehdr.e_phnum];
+	for(phdr = ehdr.e_phdr; phdr != end_phdr; phdr++) {
+		if (phdr->p_type == PT_LOAD) {
+			unsigned long saddr = phdr->p_vaddr;
+			unsigned long eaddr = phdr->p_vaddr + phdr->p_memsz;
+			unsigned long size;
+
+			/* Look for kernel text mapping header. */
+			if ((saddr >= __START_KERNEL_map) &&
+			    (eaddr <= __START_KERNEL_map + KERNEL_TEXT_SIZE)) {
+				saddr = (saddr) & (~(KERN_VADDR_ALIGN - 1));
+				info->kern_vaddr_start = saddr;
+				size = eaddr - saddr;
+				/* Align size to page size boundary. */
+				size = (size + align - 1) & (~(align - 1));
+				info->kern_size = size;
+#ifdef DEBUG
+			printf("kernel vaddr = 0x%lx size = 0x%lx\n",
+					saddr, size);
+#endif
+				return 0;
+			}
+		}
+	}
+	fprintf(stderr, "Can't find kernel text map area from kcore\n");
+	return -1;
+}
+
+/* Stores a sorted list of RAM memory ranges for which to create elf headers.
+ * A separate program header is created for backup region */
+static struct memory_range crash_memory_range[CRASH_MAX_MEMORY_RANGES];
+
+/* Memory region reserved for storing panic kernel and other data. */
+static struct memory_range crash_reserved_mem;
+
+/* Reads the appropriate file and retrieves the SYSTEM RAM regions for whom to
+ * create Elf headers. Keeping it separate from get_memory_ranges() as
+ * requirements are different in the case of normal kexec and crashdumps.
+ *
+ * Normal kexec needs to look at all of available physical memory irrespective
+ * of the fact how much of it is being used by currently running kernel.
+ * Crashdumps need to have access to memory regions actually being used by
+ * running  kernel. Expecting a different file/data structure than /proc/iomem
+ * to look into down the line. May be something like /proc/kernelmem or may
+ * be zone data structures exported from kernel.
+ */
+static int get_crash_memory_ranges(struct memory_range **range, int *ranges)
+{
+	const char iomem[]= "/proc/iomem";
+	int memory_ranges = 0;
+	char line[MAX_LINE];
+	FILE *fp;
+	unsigned long long start, end;
+
+	fp = fopen(iomem, "r");
+	if (!fp) {
+		fprintf(stderr, "Cannot open %s: %s\n",
+			iomem, strerror(errno));
+		return -1;
+	}
+
+	/* First entry is for first 640K region. Different bios report first
+	 * 640K in different manner hence hardcoding it */
+	crash_memory_range[0].start = 0x00000000;
+	crash_memory_range[0].end = 0x0009ffff;
+	crash_memory_range[0].type = RANGE_RAM;
+	memory_ranges++;
+
+	while(fgets(line, sizeof(line), fp) != 0) {
+		char *str;
+		int type, consumed, count;
+
+		if (memory_ranges >= CRASH_MAX_MEMORY_RANGES)
+			break;
+		count = sscanf(line, "%Lx-%Lx : %n",
+			&start, &end, &consumed);
+		if (count != 2)
+			continue;
+		str = line + consumed;
+#ifdef DEBUG
+		printf("%016Lx-%016Lx : %s",
+			start, end, str);
+#endif
+		/* Only Dumping memory of type System RAM. */
+		if (memcmp(str, "System RAM\n", 11) == 0) {
+			type = RANGE_RAM;
+		} else if (memcmp(str, "Crash kernel\n", 13) == 0) {
+				/* Reserved memory region. New kernel can
+				 * use this region to boot into. */
+				crash_reserved_mem.start = start;
+				crash_reserved_mem.end = end;
+				crash_reserved_mem.type = RANGE_RAM;
+				continue;
+		} else if (memcmp(str, "ACPI Tables\n", 12) == 0) {
+			/*
+			 * ACPI Tables area need to be passed to new
+			 * kernel with appropriate memmap= option. This
+			 * is needed so that x86_64 kernel creates linear
+			 * mapping for this region which is required for
+			 * initializing acpi tables in second kernel.
+			 */
+			type = RANGE_ACPI;
+		} else if(memcmp(str,"ACPI Non-volatile Storage\n",26) == 0 ) {
+			type = RANGE_ACPI_NVS;
+		} else {
+			continue;
+		}
+
+		/* First 640K already registered */
+		if (start >= 0x00000000 && end <= 0x0009ffff)
+			continue;
+
+		crash_memory_range[memory_ranges].start = start;
+		crash_memory_range[memory_ranges].end = end;
+		crash_memory_range[memory_ranges].type = type;
+		memory_ranges++;
+	}
+	fclose(fp);
+	if (exclude_crash_reserve_region(&memory_ranges) < 0)
+		return -1;
+	*range = crash_memory_range;
+	*ranges = memory_ranges;
+#ifdef DEBUG
+	int i;
+	printf("CRASH MEMORY RANGES\n");
+	for(i = 0; i < memory_ranges; i++) {
+		start = crash_memory_range[i].start;
+		end = crash_memory_range[i].end;
+		printf("%016Lx-%016Lx\n", start, end);
+	}
+#endif
+	return 0;
+}
+
+/* Removes crash reserve region from list of memory chunks for whom elf program
+ * headers have to be created. Assuming crash reserve region to be a single
+ * continuous area fully contained inside one of the memory chunks */
+static int exclude_crash_reserve_region(int *nr_ranges)
+{
+	int i, j, tidx = -1;
+	unsigned long long cstart, cend;
+	struct memory_range temp_region;
+
+	/* Crash reserved region. */
+	cstart = crash_reserved_mem.start;
+	cend = crash_reserved_mem.end;
+
+	for (i = 0; i < (*nr_ranges); i++) {
+		unsigned long long mstart, mend;
+		mstart = crash_memory_range[i].start;
+		mend = crash_memory_range[i].end;
+		if (cstart < mend && cend > mstart) {
+			if (cstart != mstart && cend != mend) {
+				/* Split memory region */
+				crash_memory_range[i].end = cstart - 1;
+				temp_region.start = cend + 1;
+				temp_region.end = mend;
+				temp_region.type = RANGE_RAM;
+				tidx = i+1;
+			} else if (cstart != mstart)
+				crash_memory_range[i].end = cstart - 1;
+			else
+				crash_memory_range[i].start = cend + 1;
+		}
+	}
+	/* Insert split memory region, if any. */
+	if (tidx >= 0) {
+		if (*nr_ranges == CRASH_MAX_MEMORY_RANGES) {
+			/* No space to insert another element. */
+			fprintf(stderr, "Error: Number of crash memory ranges"
+					" excedeed the max limit\n");
+			return -1;
+		}
+		for (j = (*nr_ranges - 1); j >= tidx; j--)
+			crash_memory_range[j+1] = crash_memory_range[j];
+		crash_memory_range[tidx].start = temp_region.start;
+		crash_memory_range[tidx].end = temp_region.end;
+		crash_memory_range[tidx].type = temp_region.type;
+		(*nr_ranges)++;
+	}
+	return 0;
+}
+
+/* Adds a segment from list of memory regions which new kernel can use to
+ * boot. Segment start and end should be aligned to 1K boundary. */
+static int add_memmap(struct memory_range *memmap_p, unsigned long long addr,
+								size_t size)
+{
+	int i, j, nr_entries = 0, tidx = 0, align = 1024;
+	unsigned long long mstart, mend;
+
+	/* Do alignment check. */
+	if ((addr%align) || (size%align))
+		return -1;
+
+	/* Make sure at least one entry in list is free. */
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		mstart = memmap_p[i].start;
+		mend = memmap_p[i].end;
+		if (!mstart  && !mend)
+			break;
+		else
+			nr_entries++;
+	}
+	if (nr_entries == CRASH_MAX_MEMMAP_NR)
+		return -1;
+
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		mstart = memmap_p[i].start;
+		mend = memmap_p[i].end;
+		if (mstart == 0 && mend == 0)
+			break;
+		if (mstart <= (addr+size-1) && mend >=addr)
+			/* Overlapping region. */
+			return -1;
+		else if (addr > mend)
+			tidx = i+1;
+	}
+		/* Insert the memory region. */
+		for (j = nr_entries-1; j >= tidx; j--)
+			memmap_p[j+1] = memmap_p[j];
+		memmap_p[tidx].start = addr;
+		memmap_p[tidx].end = addr + size - 1;
+#ifdef DEBUG
+	printf("Memmap after adding segment\n");
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		mstart = memmap_p[i].start;
+		mend = memmap_p[i].end;
+		if (mstart == 0 && mend == 0)
+			break;
+		printf("%016llx - %016llx\n",
+			mstart, mend);
+	}
+#endif
+	return 0;
+}
+
+/* Removes a segment from list of memory regions which new kernel can use to
+ * boot. Segment start and end should be aligned to 1K boundary. */
+static int delete_memmap(struct memory_range *memmap_p, unsigned long long addr,
+								size_t size)
+{
+	int i, j, nr_entries = 0, tidx = -1, operation = 0, align = 1024;
+	unsigned long long mstart, mend;
+	struct memory_range temp_region;
+
+	/* Do alignment check. */
+	if ((addr%align) || (size%align))
+		return -1;
+
+	/* Make sure at least one entry in list is free. */
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		mstart = memmap_p[i].start;
+		mend = memmap_p[i].end;
+		if (!mstart  && !mend)
+			break;
+		else
+			nr_entries++;
+	}
+	if (nr_entries == CRASH_MAX_MEMMAP_NR)
+		/* List if full */
+		return -1;
+
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		mstart = memmap_p[i].start;
+		mend = memmap_p[i].end;
+		if (mstart == 0 && mend == 0)
+			/* Did not find the segment in the list. */
+			return -1;
+		if (mstart <= addr && mend >= (addr + size - 1)) {
+			if (mstart == addr && mend == (addr + size - 1)) {
+				/* Exact match. Delete region */
+				operation = -1;
+				tidx = i;
+				break;
+			}
+			if (mstart != addr && mend != (addr + size - 1)) {
+				/* Split in two */
+				memmap_p[i].end = addr - 1;
+				temp_region.start = addr + size;
+				temp_region.end = mend;
+				operation = 1;
+				tidx = i;
+				break;
+			}
+
+			/* No addition/deletion required. Adjust the existing.*/
+			if (mstart != addr) {
+				memmap_p[i].end = addr - 1;
+				break;
+			} else {
+				memmap_p[i].start = addr + size;
+				break;
+			}
+		}
+	}
+	if ((operation == 1) && tidx >=0) {
+		/* Insert the split memory region. */
+		for (j = nr_entries-1; j > tidx; j--)
+			memmap_p[j+1] = memmap_p[j];
+		memmap_p[tidx+1] = temp_region;
+	}
+	if ((operation == -1) && tidx >=0) {
+		/* Delete the exact match memory region. */
+		for (j = i+1; j < CRASH_MAX_MEMMAP_NR; j++)
+			memmap_p[j-1] = memmap_p[j];
+		memmap_p[j-1].start = memmap_p[j-1].end = 0;
+	}
+#ifdef DEBUG
+	printf("Memmap after deleting segment\n");
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		mstart = memmap_p[i].start;
+		mend = memmap_p[i].end;
+		if (mstart == 0 && mend == 0) {
+			break;
+		}
+		printf("%016llx - %016llx\n",
+			mstart, mend);
+	}
+#endif
+	return 0;
+}
+
+/* Converts unsigned long to ascii string. */
+static void ultoa(unsigned long i, char *str)
+{
+	int j = 0, k;
+	char tmp;
+
+	do {
+		str[j++] = i % 10 + '0';
+	} while ((i /=10) > 0);
+	str[j] = '\0';
+
+	/* Reverse the string. */
+	for (j = 0, k = strlen(str) - 1; j < k; j++, k--) {
+		tmp = str[k];
+		str[k] = str[j];
+		str[j] = tmp;
+	}
+}
+
+/* Adds the appropriate memmap= options to command line, indicating the
+ * memory regions the new kernel can use to boot into. */
+static int cmdline_add_memmap(char *cmdline, struct memory_range *memmap_p)
+{
+	int i, cmdlen, len, min_sizek = 100;
+	char str_mmap[256], str_tmp[20];
+
+	/* Exact map */
+	strcpy(str_mmap, " memmap=exactmap");
+	len = strlen(str_mmap);
+	cmdlen = strlen(cmdline) + len;
+	if (cmdlen > (COMMAND_LINE_SIZE - 1))
+		die("Command line overflow\n");
+	strcat(cmdline, str_mmap);
+
+	for (i = 0; i < CRASH_MAX_MEMMAP_NR;  i++) {
+		unsigned long startk, endk;
+		startk = (memmap_p[i].start/1024);
+		endk = ((memmap_p[i].end + 1)/1024);
+		if (!startk && !endk)
+			/* All regions traversed. */
+			break;
+
+		/* A region is not worth adding if region size < 100K. It eats
+		 * up precious command line length. */
+		if ((endk - startk) < min_sizek)
+			continue;
+		strcpy (str_mmap, " memmap=");
+		ultoa((endk-startk), str_tmp);
+		strcat (str_mmap, str_tmp);
+		strcat (str_mmap, "K@");
+		ultoa(startk, str_tmp);
+		strcat (str_mmap, str_tmp);
+		strcat (str_mmap, "K");
+		len = strlen(str_mmap);
+		cmdlen = strlen(cmdline) + len;
+		if (cmdlen > (COMMAND_LINE_SIZE - 1))
+			die("Command line overflow\n");
+		strcat(cmdline, str_mmap);
+	}
+#ifdef DEBUG
+		printf("Command line after adding memmap\n");
+		printf("%s\n", cmdline);
+#endif
+	return 0;
+}
+
+/* Adds the elfcorehdr= command line parameter to command line. */
+static int cmdline_add_elfcorehdr(char *cmdline, unsigned long addr)
+{
+	int cmdlen, len, align = 1024;
+	char str[30], *ptr;
+
+	/* Passing in elfcorehdr=xxxK format. Saves space required in cmdline.
+	 * Ensure 1K alignment*/
+	if (addr%align)
+		return -1;
+	addr = addr/align;
+	ptr = str;
+	strcpy(str, " elfcorehdr=");
+	ptr += strlen(str);
+	ultoa(addr, ptr);
+	strcat(str, "K");
+	len = strlen(str);
+	cmdlen = strlen(cmdline) + len;
+	if (cmdlen > (COMMAND_LINE_SIZE - 1))
+		die("Command line overflow\n");
+	strcat(cmdline, str);
+#ifdef DEBUG
+		printf("Command line after adding elfcorehdr\n");
+		printf("%s\n", cmdline);
+#endif
+	return 0;
+}
+
+/* Appends memmap=X#Y commandline for ACPI to command line*/
+static int cmdline_add_memmap_acpi(char *cmdline, unsigned long start,
+					unsigned long end)
+{
+	int cmdlen, len, align = 1024;
+	unsigned long startk, endk;
+	char str_mmap[256], str_tmp[20];
+
+	if (!(end - start))
+		return 0;
+
+	startk = start/1024;
+	endk = (end + align - 1)/1024;
+	strcpy (str_mmap, " memmap=");
+	ultoa((endk - startk), str_tmp);
+	strcat (str_mmap, str_tmp);
+	strcat (str_mmap, "K#");
+	ultoa(startk, str_tmp);
+	strcat (str_mmap, str_tmp);
+	strcat (str_mmap, "K");
+	len = strlen(str_mmap);
+	cmdlen = strlen(cmdline) + len;
+	if (cmdlen > (COMMAND_LINE_SIZE - 1))
+		die("Command line overflow\n");
+	strcat(cmdline, str_mmap);
+
+#ifdef DEBUG
+		printf("Command line after adding acpi memmap\n");
+		printf("%s\n", cmdline);
+#endif
+	return 0;
+}
+
+/* Loads additional segments in case of a panic kernel is being loaded.
+ * One segment for backup region, another segment for storing elf headers
+ * for crash memory image.
+ */
+int load_crashdump_segments(struct kexec_info *info, char* mod_cmdline,
+				unsigned long max_addr, unsigned long min_base)
+{
+	void *tmp;
+	unsigned long sz, elfcorehdr;
+	int nr_ranges, align = 1024, i;
+	struct memory_range *mem_range, *memmap_p;
+
+	if (get_kernel_paddr(info))
+		return -1;
+
+	if (get_kernel_vaddr_and_size(info))
+		return -1;
+
+	if (get_crash_memory_ranges(&mem_range, &nr_ranges) < 0)
+		return -1;
+
+	/* Memory regions which panic kernel can safely use to boot into */
+	sz = (sizeof(struct memory_range) * (KEXEC_MAX_SEGMENTS + 1));
+	memmap_p = xmalloc(sz);
+	memset(memmap_p, 0, sz);
+	add_memmap(memmap_p, BACKUP_SRC_START, BACKUP_SRC_SIZE);
+	sz = crash_reserved_mem.end - crash_reserved_mem.start +1;
+	add_memmap(memmap_p, crash_reserved_mem.start, sz);
+
+	/* Create a backup region segment to store backup data*/
+	sz = (BACKUP_SRC_SIZE + align - 1) & ~(align - 1);
+	tmp = xmalloc(sz);
+	memset(tmp, 0, sz);
+	info->backup_start = add_buffer(info, tmp, sz, sz, align,
+				0, max_addr, 1);
+	if (delete_memmap(memmap_p, info->backup_start, sz) < 0)
+		return -1;
+
+	/* Create elf header segment and store crash image data. */
+	if (crash_create_elf64_headers(info, &elf_info,
+				       crash_memory_range, nr_ranges,
+				       &tmp, &sz,
+				       ELF_CORE_HEADER_ALIGN) < 0)
+		return -1;
+
+	/* Hack: With some ld versions (GNU ld version 2.14.90.0.4 20030523),
+	 * vmlinux program headers show a gap of two pages between bss segment
+	 * and data segment but effectively kernel considers it as bss segment
+	 * and overwrites the any data placed there. Hence bloat the memsz of
+	 * elf core header segment to 16K to avoid being placed in such gaps.
+	 * This is a makeshift solution until it is fixed in kernel.
+	 */
+	elfcorehdr = add_buffer(info, tmp, sz, 16*1024, align, min_base,
+							max_addr, -1);
+	if (delete_memmap(memmap_p, elfcorehdr, sz) < 0)
+		return -1;
+	cmdline_add_memmap(mod_cmdline, memmap_p);
+	cmdline_add_elfcorehdr(mod_cmdline, elfcorehdr);
+
+	/* Inform second kernel about the presence of ACPI tables. */
+	for (i = 0; i < CRASH_MAX_MEMORY_RANGES; i++) {
+		unsigned long start, end;
+		if ( !( mem_range[i].type == RANGE_ACPI
+			|| mem_range[i].type == RANGE_ACPI_NVS) )
+			continue;
+		start = mem_range[i].start;
+		end = mem_range[i].end;
+		cmdline_add_memmap_acpi(mod_cmdline, start, end);
+	}
+	return 0;
+}
+
+int is_crashkernel_mem_reserved(void)
+{
+	uint64_t start, end;
+
+	return parse_iomem_single("Crash kernel\n", &start, &end) == 0 ?
+	  (start != end) : 0;
+}
diff -Nur kexec-tools-1.101/kexec/arch/x86_64/crashdump-x86_64.h kexec-tools-1.101-geoff/kexec/arch/x86_64/crashdump-x86_64.h
--- kexec-tools-1.101/kexec/arch/x86_64/crashdump-x86_64.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/arch/x86_64/crashdump-x86_64.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,24 @@
+#ifndef CRASHDUMP_X86_64_H
+#define CRASHDUMP_X86_64_H
+
+int load_crashdump_segments(struct kexec_info *info, char *mod_cmdline,
+				unsigned long max_addr, unsigned long min_base);
+
+#define __START_KERNEL_map      0xffffffff80000000UL
+#define PAGE_OFFSET		0xffff810000000000UL
+#define __pa(x)                 (((unsigned long)(x)>=__START_KERNEL_map)?(unsigned long)(x) - (unsigned long)__START_KERNEL_map:(unsigned long)(x) - PAGE_OFFSET)
+
+#define MAXMEM           0x3fffffffffffUL
+
+/* Kernel text size */
+#define KERNEL_TEXT_SIZE  (40UL*1024*1024)
+
+#define CRASH_MAX_MEMMAP_NR	(KEXEC_MAX_SEGMENTS + 1)
+#define CRASH_MAX_MEMORY_RANGES	(MAX_MEMORY_RANGES + 2)
+
+/* Backup Region, First 640K of System RAM. */
+#define BACKUP_SRC_START	0x00000000
+#define BACKUP_SRC_END		0x0009ffff
+#define BACKUP_SRC_SIZE		(BACKUP_SRC_END - BACKUP_SRC_START + 1)
+
+#endif /* CRASHDUMP_X86_64_H */
diff -Nur kexec-tools-1.101/kexec/arch/x86_64/kexec-elf-rel-x86_64.c kexec-tools-1.101-geoff/kexec/arch/x86_64/kexec-elf-rel-x86_64.c
--- kexec-tools-1.101/kexec/arch/x86_64/kexec-elf-rel-x86_64.c	2004-12-21 23:51:24.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/x86_64/kexec-elf-rel-x86_64.c	2007-10-23 16:24:40.000000000 +0700
@@ -47,7 +47,7 @@
 	};
 	static char buf[100];
 	const char *name;
-	if (r_type < (sizeof(reloc_name)/sizeof(r_name[0]))){
+	if (r_type < (sizeof(r_name)/sizeof(r_name[0]))){
 		name = r_name[r_type];
 	}
 	else {
@@ -60,7 +60,7 @@
 void machine_apply_elf_rel(struct mem_ehdr *ehdr, unsigned long r_type, 
 	void *location, unsigned long address, unsigned long value)
 {
-#if 0
+#ifdef DEBUG
 	fprintf(stderr, "%s\n", reloc_name(r_type));
 #endif
 	switch(r_type) {
diff -Nur kexec-tools-1.101/kexec/arch/x86_64/kexec-elf-x86_64.c kexec-tools-1.101-geoff/kexec/arch/x86_64/kexec-elf-x86_64.c
--- kexec-tools-1.101/kexec/arch/x86_64/kexec-elf-x86_64.c	2005-01-13 19:10:54.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/x86_64/kexec-elf-x86_64.c	2007-10-23 16:24:40.000000000 +0700
@@ -32,10 +32,12 @@
 #include <elf.h>
 #include <x86/x86-linux.h>
 #include "../../kexec.h"
+#include "../../kexec-syscall.h"
 #include "../../kexec-elf.h"
 #include "../../kexec-elf-boot.h"
 #include "../i386/x86-linux-setup.h"
 #include "kexec-x86_64.h"
+#include "crashdump-x86_64.h"
 #include <arch/options.h>
 
 static const int probe_debug = 0;
@@ -45,7 +47,7 @@
 	
 	struct mem_ehdr ehdr;
 	int result;
-	result = build_elf_exec_info(buf, len, &ehdr);
+	result = build_elf_exec_info(buf, len, &ehdr, 0);
 	if (result < 0) {
 		if (probe_debug) {
 			fprintf(stderr, "Not an ELF executable\n");
@@ -85,7 +87,9 @@
 {
 	struct mem_ehdr ehdr;
 	const char *command_line;
+	char *modified_cmdline;
 	int command_line_len;
+	int modified_cmdline_len;
 	const char *ramdisk;
 	unsigned long entry, max_addr;
 	int arg_style;
@@ -118,6 +122,8 @@
 	 */
 	arg_style = ARG_STYLE_ELF;
 	command_line = 0;
+	modified_cmdline = 0;
+	modified_cmdline_len = 0;
 	ramdisk = 0;
 	while((opt = getopt_long(argc, argv, short_options, options, 0)) != -1) {
 		switch(opt) {
@@ -143,7 +149,7 @@
 			arg_style = ARG_STYLE_LINUX;
 			break;
 		case OPT_ARGS_NONE:
-#ifdef __x86_64___
+#ifdef __x86_64__
 			arg_style = ARG_STYLE_NONE;
 #else
 			die("--args-none only works on arch x86_64\n");
@@ -156,8 +162,22 @@
 		command_line_len = strlen(command_line) +1;
 	}
 
+	/* Need to append some command line parameters internally in case of
+	 * taking crash dumps.
+	 */
+	if (info->kexec_flags & KEXEC_ON_CRASH) {
+		modified_cmdline = xmalloc(COMMAND_LINE_SIZE);
+		memset((void *)modified_cmdline, 0, COMMAND_LINE_SIZE);
+		if (command_line) {
+			strncpy(modified_cmdline, command_line,
+						COMMAND_LINE_SIZE);
+			modified_cmdline[COMMAND_LINE_SIZE - 1] = '\0';
+		}
+		modified_cmdline_len = strlen(modified_cmdline);
+	}
+
 	/* Load the ELF executable */
-	elf_exec_build_load(info, &ehdr, buf, len);
+	elf_exec_build_load(info, &ehdr, buf, len, 0);
 
 	entry = ehdr.e_entry;
 	max_addr = elf_max_addr(&ehdr);
@@ -166,7 +186,7 @@
 	if (arg_style != ARG_STYLE_NONE) {
 		/* Load the setup code */
 		elf_rel_build_load(info, &info->rhdr, purgatory, purgatory_size,
-			0, ULONG_MAX, 1);
+			0, ULONG_MAX, 1, 0);
 	}
 	if (arg_style == ARG_STYLE_NONE) {
 		info->entry = (void *)entry;
@@ -197,6 +217,7 @@
 		const unsigned char *ramdisk_buf;
 		off_t ramdisk_length;
 		struct entry64_regs regs;
+		int rc=0;
 
 		/* Get the linux parameter header */
 		hdr = xmalloc(sizeof(*hdr));
@@ -211,10 +232,21 @@
 		ramdisk_buf = 0;
 		ramdisk_length = 0;
 		if (ramdisk) {
-			unsigned char *ramdisk_buf;
 			ramdisk_buf = slurp_file(ramdisk, &ramdisk_length);
 		}
 
+		/* If panic kernel is being loaded, additional segments need
+		 * to be created. */
+		if (info->kexec_flags & KEXEC_ON_CRASH) {
+			rc = load_crashdump_segments(info, modified_cmdline,
+							max_addr, 0);
+			if (rc < 0)
+				return -1;
+			/* Use new command line. */
+			command_line = modified_cmdline;
+			command_line_len = strlen(modified_cmdline) + 1;
+		}
+
 		/* Tell the kernel what is going on */
 		setup_linux_bootloader_parameters(info, &hdr->hdr, param_base, 
 			offsetof(struct x86_linux_faked_param_header, command_line),
@@ -222,7 +254,7 @@
 			ramdisk_buf, ramdisk_length);
 
 		/* Fill in the information bios calls would usually provide */
-		setup_linux_system_parameters(&hdr->hdr);
+		setup_linux_system_parameters(&hdr->hdr, info->kexec_flags);
 
 		/* Initialize the registers */
 		elf_rel_get_symbol(&info->rhdr, "entry64_regs", &regs, sizeof(regs));
diff -Nur kexec-tools-1.101/kexec/arch/x86_64/kexec-x86_64.c kexec-tools-1.101-geoff/kexec/arch/x86_64/kexec-x86_64.c
--- kexec-tools-1.101/kexec/arch/x86_64/kexec-x86_64.c	2005-02-06 05:25:01.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/x86_64/kexec-x86_64.c	2007-10-23 16:24:40.000000000 +0700
@@ -30,14 +30,15 @@
 #include "../../kexec-elf.h"
 #include "../../kexec-syscall.h"
 #include "kexec-x86_64.h"
+#include "crashdump-x86_64.h"
 #include <arch/options.h>
 
 #define MAX_MEMORY_RANGES 64
-#define MAX_LINE 160
 static struct memory_range memory_range[MAX_MEMORY_RANGES];
 
 /* Return a sorted list of memory ranges. */
-int get_memory_ranges(struct memory_range **range, int *ranges)
+int get_memory_ranges(struct memory_range **range, int *ranges,
+					unsigned long kexec_flags)
 {
 	const char iomem[]= "/proc/iomem";
 	int memory_ranges = 0;
@@ -63,7 +64,7 @@
 			continue;
 		str = line + consumed;
 		end = end + 1;
-#if 0
+#ifdef DEBUG
 		printf("%016Lx-%016Lx : %s",
 			start, end, str);
 #endif
@@ -79,6 +80,20 @@
 		else if (memcmp(str, "ACPI Non-volatile Storage\n", 26) == 0) {
 			type = RANGE_ACPI_NVS;
 		}
+		else if (memcmp(str, "Crash kernel\n", 13) == 0) {
+			/* Redefine the memory region boundaries if kernel
+			 * exports the limits and if it is panic kernel.
+			 * Override user values only if kernel exported
+			 * values are subset of user defined values.
+			 */
+			if (kexec_flags & KEXEC_ON_CRASH) {
+				if (start > mem_min)
+					mem_min = start;
+				if (end < mem_max)
+					mem_max = end;
+			}
+			continue;
+		}
 		else {
 			continue;
 		}
@@ -89,7 +104,7 @@
 		memory_range[memory_ranges].start = start;
 		memory_range[memory_ranges].end = end;
 		memory_range[memory_ranges].type = type;
-#if 0
+#ifdef DEBUG
 		printf("%016Lx-%016Lx : %x\n",
 			start, end, type);
 #endif
@@ -118,7 +133,7 @@
 	printf(
 		"     --reset-vga               Attempt to reset a standard vga device\n"
 		"     --serial=<port>           Specify the serial port for debug output\n"
-		"     --serial-baud=<buad_rate> Specify the serial port baud rate\n"
+		"     --serial-baud=<baud_rate> Specify the serial port baud rate\n"
 		"     --console-vga             Enable the vga console\n"
 		"     --console-serial          Enable the serial console\n"
 		);
@@ -130,12 +145,14 @@
 	uint32_t serial_baud;
 	uint8_t  console_vga;
 	uint8_t  console_serial;
+	int core_header_type;
 } arch_options = {
 	.reset_vga   = 0,
 	.serial_base = 0x3f8,
 	.serial_baud = 0,
 	.console_vga = 0,
 	.console_serial = 0,
+	.core_header_type = CORE_TYPE_ELF64,
 };
 
 int arch_process_options(int argc, char **argv)
@@ -207,7 +224,7 @@
 	return 0;
 }
 
-int arch_compat_trampoline(struct kexec_info *info, unsigned long *flags)
+int arch_compat_trampoline(struct kexec_info *info)
 {
 	int result;
 	struct utsname utsname;
@@ -222,7 +239,7 @@
 		/* For compatibility with older patches 
 		 * use KEXEC_ARCH_DEFAULT instead of KEXEC_ARCH_X86_64 here.
 		 */
-		*flags |= KEXEC_ARCH_DEFAULT;
+		info->kexec_flags |= KEXEC_ARCH_DEFAULT;
 	}
 	else {
 		fprintf(stderr, "Unsupported machine type: %s\n",
@@ -234,6 +251,8 @@
 
 void arch_update_purgatory(struct kexec_info *info)
 {
+	uint8_t panic_kernel = 0;
+
 	elf_rel_set_symbol(&info->rhdr, "reset_vga",
 		&arch_options.reset_vga, sizeof(arch_options.reset_vga));
 	elf_rel_set_symbol(&info->rhdr, "serial_base", 
@@ -244,4 +263,12 @@
 		&arch_options.console_vga, sizeof(arch_options.console_vga));
 	elf_rel_set_symbol(&info->rhdr, "console_serial", 
 		&arch_options.console_serial, sizeof(arch_options.console_serial));
+
+	if (info->kexec_flags & KEXEC_ON_CRASH) {
+		panic_kernel = 1;
+		elf_rel_set_symbol(&info->rhdr, "backup_start",
+					&info->backup_start, sizeof(info->backup_start));
+	}
+	elf_rel_set_symbol(&info->rhdr, "panic_kernel",
+				&panic_kernel, sizeof(panic_kernel));
 }
diff -Nur kexec-tools-1.101/kexec/arch/x86_64/Makefile kexec-tools-1.101-geoff/kexec/arch/x86_64/Makefile
--- kexec-tools-1.101/kexec/arch/x86_64/Makefile	2005-02-06 05:25:19.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/arch/x86_64/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -7,6 +7,7 @@
 KEXEC_C_SRCS+= kexec/arch/i386/kexec-beoboot-x86.c
 KEXEC_C_SRCS+= kexec/arch/i386/kexec-nbi.c
 KEXEC_C_SRCS+= kexec/arch/i386/x86-linux-setup.c
+KEXEC_C_SRCS+= kexec/arch/x86_64/crashdump-x86_64.c
 KEXEC_C_SRCS+= kexec/arch/x86_64/kexec-x86_64.c 
 KEXEC_C_SRCS+= kexec/arch/x86_64/kexec-elf-x86_64.c 
 KEXEC_C_SRCS+= kexec/arch/x86_64/kexec-elf-rel-x86_64.c
diff -Nur kexec-tools-1.101/kexec/crashdump.c kexec-tools-1.101-geoff/kexec/crashdump.c
--- kexec-tools-1.101/kexec/crashdump.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/crashdump.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,110 @@
+/*
+ * crashdump.c: Architecture independent code for crashdump support.
+ *
+ * Created by: Vivek Goyal (vgoyal@in.ibm.com)
+ * Copyright (C) IBM Corporation, 2005. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <limits.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <elf.h>
+#include "kexec.h"
+#include "crashdump.h"
+
+/* include "crashdump-elf.c" twice to create two functions from one */
+
+#define ELF_WIDTH 64
+#define FUNC crash_create_elf64_headers
+#define EHDR Elf64_Ehdr
+#define PHDR Elf64_Phdr
+#include "crashdump-elf.c"
+#undef ELF_WIDTH
+#undef PHDR
+#undef EHDR
+#undef FUNC
+
+#define ELF_WIDTH 32
+#define FUNC crash_create_elf32_headers
+#define EHDR Elf32_Ehdr
+#define PHDR Elf32_Phdr
+#include "crashdump-elf.c"
+#undef ELF_WIDTH
+#undef PHDR
+#undef EHDR
+#undef FUNC
+
+unsigned long crash_architecture(struct crash_elf_info *elf_info)
+{
+	if (xen_present())
+		return xen_architecture(elf_info);
+	else
+		return elf_info->machine;
+}
+
+/* Returns the physical address of start of crash notes buffer for a cpu. */
+int get_crash_notes_per_cpu(int cpu, uint64_t *addr, uint64_t *len)
+{
+	char crash_notes[PATH_MAX];
+	char line[MAX_LINE];
+	FILE *fp;
+	struct stat cpu_stat;
+	int count;
+	unsigned long long temp;
+	int fopen_errno;
+	int stat_errno;
+
+	*addr = 0;
+	*len = 0;
+
+	sprintf(crash_notes, "/sys/devices/system/cpu/cpu%d/crash_notes", cpu);
+	fp = fopen(crash_notes, "r");
+	if (!fp) {
+		fopen_errno = errno;
+		if (fopen_errno != ENOENT)
+			die("Could not open \"%s\": %s\n", crash_notes,
+			    strerror(fopen_errno));
+		if (!stat("/sys/devices", &cpu_stat)) {
+			stat_errno = errno;
+			fprintf(stderr, "Could not open \"%s\": %s\n",
+				crash_notes, strerror(fopen_errno));
+			if (stat_errno == ENOENT)
+				die("\"/sys/devices\" does not exist. "
+				    "Sysfs does not seem to be mounted. "
+				    "Try mounting sysfs.\n");
+			die("Could not open \"/sys/devices\": %s\n",
+			    crash_notes, strerror(stat_errno));
+		}
+		/* CPU is not physically present.*/
+		return -1;
+	}
+	if (!fgets(line, sizeof(line), fp))
+		die("Cannot parse %s: %s\n", crash_notes, strerror(errno));
+	count = sscanf(line, "%Lx", &temp);
+	if (count != 1)
+		die("Cannot parse %s: %s\n", crash_notes, strerror(errno));
+	*addr = (uint64_t) temp;
+	*len = MAX_NOTE_BYTES; /* we should get this from the kernel instead */
+#if 0
+	printf("crash_notes addr = %Lx\n", *addr);
+#endif
+
+	return 0;
+}
diff -Nur kexec-tools-1.101/kexec/crashdump-elf.c kexec-tools-1.101-geoff/kexec/crashdump-elf.c
--- kexec-tools-1.101/kexec/crashdump-elf.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/crashdump-elf.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,209 @@
+
+#if !defined(FUNC) || !defined(EHDR) || !defined(PHDR)
+#error FUNC, EHDR and PHDR must be defined
+#endif
+
+#if (ELF_WIDTH == 64)
+#define dbgprintf_phdr(prefix, phdr)					\
+do {									\
+	dbgprintf("%s: p_type = %u, p_offset = 0x%lx p_paddr = 0x%lx "	\
+		"p_vaddr = 0x%lx p_filesz = 0x%lx p_memsz = 0x%lx\n",	\
+		(prefix), (phdr)->p_type, (phdr)->p_offset, (phdr)->p_paddr, \
+		(phdr)->p_vaddr, (phdr)->p_filesz, (phdr)->p_memsz);	\
+} while(0)
+#else
+#define dbgprintf_phdr(prefix, phdr)					\
+do {									\
+	dbgprintf("%s: p_type = %u, p_offset = 0x%x " "p_paddr = 0x%x "	\
+		"p_vaddr = 0x%x p_filesz = 0x%x p_memsz = 0x%x\n",	\
+		(prefix), (phdr)->p_type, (phdr)->p_offset, (phdr)->p_paddr, \
+		(phdr)->p_vaddr, (phdr)->p_filesz, (phdr)->p_memsz);	\
+} while(0)
+#endif
+
+/* Prepares the crash memory headers and stores in supplied buffer. */
+int FUNC(struct kexec_info *info,
+	 struct crash_elf_info *elf_info,
+	 struct memory_range *range, int ranges,
+	 void **buf, unsigned long *size, unsigned long align)
+{
+	EHDR *elf;
+	PHDR *phdr;
+	int i;
+	unsigned long sz;
+	char *bufp;
+	long int nr_cpus = 0;
+	uint64_t notes_addr, notes_len;
+	int (*get_note_info)(int cpu, uint64_t *addr, uint64_t *len);
+
+	if (xen_present())
+		nr_cpus = xen_get_nr_phys_cpus();
+	else
+		nr_cpus = sysconf(_SC_NPROCESSORS_CONF);
+
+	if (nr_cpus < 0) {
+		return -1;
+	}
+
+	sz = sizeof(EHDR) + nr_cpus * sizeof(PHDR) + ranges * sizeof(PHDR);
+
+	/*
+	 * Certain architectures such as x86_64 and ia64 require a separate
+	 * PT_LOAD program header for the kernel. This is controlled through
+	 * info->kern_size.
+	 *
+	 * The separate PT_LOAD program header is required either because the
+	 * kernel is mapped at a different location than the rest of the
+	 * physical memory or because we need to support relocatable kernels.
+	 * Or both as on x86_64.
+	 *
+	 * In the relocatable kernel case this PT_LOAD segment is used to tell
+	 * where the kernel was actually loaded which may be different from
+	 * the load address present in the vmlinux file.
+	 *
+	 * The extra kernel PT_LOAD program header results in a vmcore file
+	 * which is larger than the size of the physical memory. This is
+	 * because the memory for the kernel is present both in the kernel
+	 * PT_LOAD program header and in the physical RAM program headers.
+	 */
+
+	if (info->kern_size && !xen_present()) {
+		sz += sizeof(PHDR);
+	}
+
+	/*
+	 * Make sure the ELF core header is aligned to at least 1024.
+	 * We do this because the secondary kernel gets the ELF core
+	 * header address on the kernel command line through the memmap=
+	 * option, and this option requires 1k granularity.
+	 */
+
+	if (align % ELF_CORE_HEADER_ALIGN) {
+		return -1;
+	}
+
+	sz += align - 1;
+	sz &= ~(align - 1);
+
+	bufp = xmalloc(sz);
+	memset(bufp, 0, sz);
+
+	*buf = bufp;
+	*size = sz;
+
+	/* Setup ELF Header*/
+	elf = (EHDR *) bufp;
+	bufp += sizeof(EHDR);
+	memcpy(elf->e_ident, ELFMAG, SELFMAG);
+	elf->e_ident[EI_CLASS]  = elf_info->class;
+	elf->e_ident[EI_DATA]   = elf_info->data;
+	elf->e_ident[EI_VERSION]= EV_CURRENT;
+	elf->e_ident[EI_OSABI] = ELFOSABI_NONE;
+	memset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);
+	elf->e_type	= ET_CORE;
+	elf->e_machine  = crash_architecture(elf_info);
+	elf->e_version	= EV_CURRENT;
+	elf->e_entry	= 0;
+	elf->e_phoff	= sizeof(EHDR);
+	elf->e_shoff	= 0;
+	elf->e_flags	= 0;
+	elf->e_ehsize   = sizeof(EHDR);
+	elf->e_phentsize= sizeof(PHDR);
+	elf->e_phnum    = 0;
+	elf->e_shentsize= 0;
+	elf->e_shnum    = 0;
+	elf->e_shstrndx = 0;
+
+	/* Default way to get crash notes is by get_crash_notes_per_cpu() */
+
+	get_note_info = elf_info->get_note_info;
+	if (!get_note_info)
+		get_note_info = get_crash_notes_per_cpu;
+
+	if (xen_present())
+		get_note_info = xen_get_note;
+
+	/* PT_NOTE program headers. One per cpu */
+
+	for (i = 0; i < nr_cpus; i++) {
+		if (get_note_info(i, &notes_addr, &notes_len) < 0) {
+			/* This cpu is not present. Skip it. */
+			continue;
+		}
+
+		phdr = (PHDR *) bufp;
+		bufp += sizeof(PHDR);
+		phdr->p_type	= PT_NOTE;
+		phdr->p_flags	= 0;
+		phdr->p_offset  = phdr->p_paddr = notes_addr;
+		phdr->p_vaddr   = 0;
+		phdr->p_filesz	= phdr->p_memsz	= notes_len;
+		/* Do we need any alignment of segments? */
+		phdr->p_align	= 0;
+
+		/* Increment number of program headers. */
+		(elf->e_phnum)++;
+		dbgprintf_phdr("Elf header", phdr);
+	}
+
+	/* Setup an PT_LOAD type program header for the region where
+	 * Kernel is mapped if info->kern_size is non-zero.
+	 */
+
+	if (info->kern_size && !xen_present()) {
+		phdr = (PHDR *) bufp;
+		bufp += sizeof(PHDR);
+		phdr->p_type	= PT_LOAD;
+		phdr->p_flags	= PF_R|PF_W|PF_X;
+		phdr->p_offset	= phdr->p_paddr = info->kern_paddr_start;
+		phdr->p_vaddr	= info->kern_vaddr_start;
+		phdr->p_filesz	= phdr->p_memsz	= info->kern_size;
+		phdr->p_align	= 0;
+		(elf->e_phnum)++;
+		dbgprintf_phdr("Kernel text Elf header", phdr);
+	}
+
+	/* Setup PT_LOAD type program header for every system RAM chunk.
+	 * A seprate program header for Backup Region*/
+	for (i = 0; i < ranges; i++, range++) {
+		unsigned long long mstart, mend;
+		if (range->type != RANGE_RAM)
+			continue;
+		mstart = range->start;
+		mend = range->end;
+		if (!mstart && !mend)
+			continue;
+		phdr = (PHDR *) bufp;
+		bufp += sizeof(PHDR);
+		phdr->p_type	= PT_LOAD;
+		phdr->p_flags	= PF_R|PF_W|PF_X;
+		phdr->p_offset	= mstart;
+
+		if (mstart == elf_info->backup_src_start
+		    && mend == elf_info->backup_src_end)
+			phdr->p_offset	= info->backup_start;
+
+		/* We already prepared the header for kernel text. Map
+		 * rest of the memory segments to kernel linearly mapped
+		 * memory region.
+		 */
+		phdr->p_paddr = mstart;
+		phdr->p_vaddr = mstart + elf_info->page_offset;
+		phdr->p_filesz	= phdr->p_memsz	= mend - mstart + 1;
+		/* Do we need any alignment of segments? */
+		phdr->p_align	= 0;
+
+		/* HIGMEM has a virtual address of -1 */
+
+		if (elf_info->lowmem_limit
+		    && (mend > (elf_info->lowmem_limit - 1)))
+			phdr->p_vaddr = -1;
+
+		/* Increment number of program headers. */
+		(elf->e_phnum)++;
+		dbgprintf_phdr("Elf header", phdr);
+	}
+	return 0;
+}
+
+#undef dbgprintf_phdr
diff -Nur kexec-tools-1.101/kexec/crashdump.h kexec-tools-1.101-geoff/kexec/crashdump.h
--- kexec-tools-1.101/kexec/crashdump.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/crashdump.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,52 @@
+#ifndef CRASHDUMP_H
+#define CRASHDUMP_H
+
+extern int get_crash_notes_per_cpu(int cpu, uint64_t *addr, uint64_t *len);
+
+/* Need to find a better way to determine per cpu notes section size. */
+#define MAX_NOTE_BYTES		1024
+/* Expecting ELF headers to fit in 4K. Increase it if you need more. */
+#define KCORE_ELF_HEADERS_SIZE  4096
+/* The address of the ELF header is passed to the secondary kernel
+ * using the kernel command line option memmap=nnn.
+ * The smallest unit the kernel accepts is in kilobytes,
+ * so we need to make sure the ELF header is aligned to 1024.
+ */
+#define ELF_CORE_HEADER_ALIGN   1024
+
+/* structure passed to crash_create_elf32/64_headers() */
+
+struct crash_elf_info {
+	unsigned long class;
+	unsigned long data;
+	unsigned long machine;
+
+	unsigned long backup_src_start;
+	unsigned long backup_src_end;
+
+	unsigned long page_offset;
+	unsigned long lowmem_limit;
+
+	int (*get_note_info)(int cpu, uint64_t *addr, uint64_t *len);
+};
+
+int crash_create_elf32_headers(struct kexec_info *info,
+			       struct crash_elf_info *elf_info,
+			       struct memory_range *range, int ranges,
+			       void **buf, unsigned long *size,
+			       unsigned long align);
+
+int crash_create_elf64_headers(struct kexec_info *info,
+			       struct crash_elf_info *elf_info,
+			       struct memory_range *range, int ranges,
+			       void **buf, unsigned long *size,
+			       unsigned long align);
+
+unsigned long crash_architecture(struct crash_elf_info *elf_info);
+
+int xen_present(void);
+unsigned long xen_architecture(struct crash_elf_info *elf_info);
+int xen_get_nr_phys_cpus(void);
+int xen_get_note(int cpu, uint64_t *addr, uint64_t *len);
+
+#endif /* CRASHDUMP_H */
diff -Nur kexec-tools-1.101/kexec/crashdump-xen.c kexec-tools-1.101-geoff/kexec/crashdump-xen.c
--- kexec-tools-1.101/kexec/crashdump-xen.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/crashdump-xen.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,121 @@
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdlib.h>
+#include <elf.h>
+#include <errno.h>
+#include <limits.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include "kexec.h"
+#include "crashdump.h"
+
+#ifdef HAVE_XENCTRL_H
+#include <xenctrl.h>
+#endif
+
+struct crash_note_info {
+	unsigned long base;
+	unsigned long length;
+};
+
+int xen_phys_cpus = 0;
+struct crash_note_info *xen_phys_notes;
+
+int xen_present(void)
+{
+	struct stat buf;
+
+	return stat("/proc/xen", &buf) == 0;
+}
+
+unsigned long xen_architecture(struct crash_elf_info *elf_info)
+{
+	unsigned long machine = elf_info->machine;
+#ifdef HAVE_XENCTRL_H
+	int xc, rc;
+	xen_capabilities_info_t capabilities;
+
+	if (!xen_present())
+		goto out;
+
+	memset(capabilities, '0', XEN_CAPABILITIES_INFO_LEN);
+
+	xc = xc_interface_open();
+	if ( xc == -1 ) {
+		fprintf(stderr, "failed to open xen control interface.\n");
+		goto out;
+	}
+
+	rc = xc_version(xc, XENVER_capabilities, &capabilities[0]);
+	if ( rc == -1 ) {
+		fprintf(stderr, "failed to make Xen version hypercall.\n");
+		goto out_close;
+	}
+
+	if (strstr(capabilities, "xen-3.0-x86_64"))
+		machine = EM_X86_64;
+        else if (strstr(capabilities, "xen-3.0-x86_32"))
+		machine = EM_386;
+
+ out_close:
+	xc_interface_close(xc);
+
+ out:
+#endif
+	return machine;
+}
+
+static int xen_crash_note_callback(void *data, int nr,
+				   char *str,
+				   unsigned long base,
+				   unsigned long length)
+{
+	struct crash_note_info *note = xen_phys_notes + nr;
+
+	note->base = base;
+	note->length = length;
+
+	return 0;
+}
+
+int xen_get_nr_phys_cpus(void)
+{
+	char *match = "Crash note\n";
+	int cpus, n;
+
+	if (xen_phys_cpus)
+		return xen_phys_cpus;
+
+	if ((cpus = kexec_iomem_for_each_line(match, NULL, NULL))) {
+		n = sizeof(struct crash_note_info) * cpus;
+		xen_phys_notes = malloc(n);
+		if (!xen_phys_notes) {
+			fprintf(stderr, "failed to allocate xen_phys_notes.\n");
+			return -1;
+		}
+		memset(xen_phys_notes, 0, n);
+		kexec_iomem_for_each_line(match, xen_crash_note_callback, NULL);
+		xen_phys_cpus = cpus;
+	}
+
+	return cpus;
+}
+
+int xen_get_note(int cpu, uint64_t *addr, uint64_t *len)
+{
+	struct crash_note_info *note;
+
+	if (xen_phys_cpus <= 0)
+		return -1;
+
+	note = xen_phys_notes + cpu;
+
+	*addr = note->base;
+	*len = note->length;
+
+	return 0;
+}
diff -Nur kexec-tools-1.101/kexec/kexec.8 kexec-tools-1.101-geoff/kexec/kexec.8
--- kexec-tools-1.101/kexec/kexec.8	2004-12-20 04:27:31.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/kexec.8	2007-10-23 16:24:40.000000000 +0700
@@ -1,45 +1,226 @@
-.\"                                      Hey, EMACS: -*- nroff -*-
-.\" First parameter, NAME, should be all caps
-.\" Second parameter, SECTION, should be 1-8, maybe w/ subsection
-.\" other parameters are allowed: see man(7), man(1)
-.TH KEXEC-TOOLS 8 "October 13, 2004"
-.\" Please adjust this date whenever revising the manpage.
+.\" Process this file with
+.\" groff -man -Tascii kexec.8
 .\"
-.\" Some roff macros, for reference:
-.\" .nh        disable hyphenation
-.\" .hy        enable hyphenation
-.\" .ad l      left justify
-.\" .ad b      justify to both left and right margins
-.\" .nf        disable filling
-.\" .fi        enable filling
-.\" .br        insert line break
-.\" .sp <n>    insert n+1 empty lines
-.\" for manpage-specific macros, see man(7)
+.TH kexec 8 "April 2006" Linux "User Manuals"
 .SH NAME
-kexec-tools \- Tool to load a kernel for warm reboot and initiate a warm reboot
+kexec \- directly boot into a new kernel
 .SH SYNOPSIS
-.B kexec-tools
-.RI [ options ] " files" ...
+.B /sbin/kexec
+.B [-v (\-\-version)] [-f (\-\-force)] [-x (\-\-no-ifdown)] [-l (\-\-load)] [-p (\-\-load-panic)] [-u (\-\-unload)] [-e (\-\-exec)] [-t (\-\-type)]
+.BI [\-\-mem\-min= addr ]
+.BI [\-\-mem\-max= addr ]
+
 .SH DESCRIPTION
+.B kexec
+is a system call that enables you to load and boot into another
+kernel from the currently running kernel.
+.B kexec
+performs the function of the boot loader from within the kernel. The
+primary difference between a standard system boot and a
+.B kexec
+boot is that the hardware initialization normally performed by the BIOS
+or firmware (depending on architecture) is not performed during a
+.B kexec
+boot. This has the effect of reducing the time required for a reboot.
 .PP
-.\" TeX users may be more comfortable with the \fB<whatever>\fP and
-.\" \fI<whatever>\fP escape sequences to invode bold face and italics, 
-.\" respectively.
-\fBkexec-tools\fP does not have a man page yet. Please use "kexec -h" for help.
+Make sure you have selected
+.B CONFIG_KEXEC=y
+when configuring the kernel. The
+.B CONFIG_KEXEC
+option enables the
+.B kexec
+system call.
+.SH USAGE
+Using
+.B kexec
+consists of
+
+.RS
+(1) loading the kernel to be rebooted to into memory, and
+.RE
+.RS
+(2) actually rebooting to the pre-loaded kernel.
+.RE
+.PP
+To load a kernel, the syntax is as follows:
+
+.RS
+.B kexec
+.RI \-l\  kernel-image
+.RI "\-\-append=" command\-line\-options
+.RI "\-\-initrd=" initrd\-image
+.RE
+
+where
+.I kernel\-image
+is the kernel file that you intend to reboot to.
+.PP
+Note: Compressed kernel images such as bzImage are not supported by
+.BR kexec .
+Use the uncompressed vmlinux.
+.PP
+Insert the command-line parameters that must be passed to the new
+kernel into
+.IR command\-line\-options .
+Passing the exact contents of /proc/cmdline into
+.I command\-line\-options
+is the safest way to ensure that correct values are passed to the
+rebooting kernel.
+.PP
+The optional
+.I initrd-image
+is the initrd image to be used during boot.
+.PP
+
+.SH EXAMPLE
+.PP
+For example, if the kernel image you want to reboot to is
+.BR /boot/vmlinux ,
+the contents of /proc/cmdline is
+.BR "root\=/dev/hda1" ,
+and the path to the initrd is
+.BR /boot/initrd ,
+then you would use the following command to load the kernel:
+
+.RS
+.B kexec
+.RB \-l\  /boot/vmlinux
+.RB "\-\-append=" "root=/dev/hda1" "\ \-\-initrd=" /boot/initrd
+.RE
+.PP
+After this kernel is loaded, it can be booted to at any time using the
+command:
+
+.RS
+.BR kexec \ \-e
+.RE
+
 .SH OPTIONS
-These programs follow the usual GNU command line syntax, with long
-options starting with two dashes (`-').
-A summary of options is included below.
-For a complete description, see the Info files.
-.TP
-.B \-h, \-\-help
-Show summary of options.
-.TP
-.B \-v, \-\-version
-Show version of program.
-.SH SEE ALSO
-.SH AUTHOR
-kexec-tools was written by Eric Biederman.
+.TP
+.B \-e\ (\-\-exec)
+Run the currently loaded kernel.
+.TP
+.B \-f\ (\-\-force)
+Force an immediate
+.B kexec
+call, do not call shutdown.
+.TP
+.B \-h\ (\-\-help)
+Open a help file for
+.BR kexec .
+.TP
+.BI \-l\ (\-\-load) \ kernel
+Load the specified
+.I kernel
+into the current kernel.
+.TP
+.B \-p\ (\-\-load\-panic)
+Load the new kernel for use on panic.
+.TP
+.BI \-t\ (\-\-type= type )
+Specify that the new kernel is of this
+.I type.
+.TP
+.B \-u\ (\-\-unload)
+Unload the current
+.B kexec
+target kernel. If a capture kernel is being unloaded then specify -p with -u.
+.TP
+.B \-v\ (\-\-version)
+Return the version number of the installed utility.
+.TP
+.B \-x\ (\-\-no\-ifdown)
+Shut down the running kernel, but restore the interface on reload. (If
+this option is used, it must be specified last.)
+.TP
+.BI \-\-mem\-min= addr
+Specify the lowest memory address
+.I addr
+to load code into.
+.TP
+.BI \-\-mem\-max= addr
+Specify the highest memory address
+.I addr
+to load code into.
+
+.SH SUPPORTED KERNEL FILE TYPES AND OPTIONS
+.B Beoboot-x86
+.RS
+.TP
+.B \-\-args\-elf
+Pass ELF boot notes.
+.TP
+.B \-\-args\-linux
+Pass Linux kernel style options.
+.TP
+.B \-d \ (\-\-debug)
+Enable debugging messages.
+.TP
+.B \-\-real\-mode
+Use the kernel's real mode entry point.
+.RE
+.PP
+.B elf-x86
+.RS
+.TP
+.BI \-\-append= string
+Append
+.I string
+to the kernel command line.
+.TP
+.BI \-\-command\-line= string
+Set the kernel command line to
+.IR string .
+.TP
+.BI \-\-initrd= file
+Use
+.I file
+as the kernel's initial ramdisk.
+.TP
+.BI \-\-ramdisk= file
+Use
+.I file
+as the kernel's initial ramdisk.
+.RE
 .PP
-This manual page was written by Khalid Aziz <khalid_aziz@hp.com>,
-for the Debian project (but may be used by others).
+.B multiboot-x86
+.RS
+.TP
+.BI \-\-command\-line= string
+Set the kernel command line to
+.IR string .
+.TP
+.BI \-\-module= "mod arg1 arg2 ..."
+Load module
+.I mod
+with command-line arguments
+.I "arg1 arg2 ..."
+This parameter can be specified multiple times.
+.RE
+
+.SH ARCHITECTURE OPTIONS
+.TP
+.B \-\-console\-serial
+Enable the serial console.
+.TP
+.B \-\-console\-vga
+Enable the VGA console.
+.TP
+.B \-\-elf32\-core\-headers
+Prepare core headers in ELF32 format.
+.TP
+.B \-\-elf64\-core\-headers
+Prepare core headers in ELF64 format.
+.TP
+.B \-\-reset\-vga
+Attempt to reset a standard VGA device.
+.TP
+.BI \-\-serial= port
+Specify the serial
+.I port
+for debug output.
+.TP
+.BI \-\-serial\-baud= baud_rate
+Specify the
+.I baud rate
+of the serial port.
diff -Nur kexec-tools-1.101/kexec/kexec.c kexec-tools-1.101-geoff/kexec/kexec.c
--- kexec-tools-1.101/kexec/kexec.c	2005-01-13 19:24:29.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/kexec.c	2007-10-23 16:24:40.000000000 +0700
@@ -37,9 +37,10 @@
 #include "kexec-syscall.h"
 #include "kexec-elf.h"
 #include "kexec-sha256.h"
+#include <arch/options.h>
 
-static unsigned long long mem_min = 0;
-static unsigned long long mem_max = ULONG_MAX;
+unsigned long long mem_min = 0;
+unsigned long long mem_max = ULONG_MAX;
 
 void die(char *fmt, ...)
 {
@@ -57,6 +58,8 @@
 {
 	void *buf;
 	buf = malloc(size);
+	if (!size)
+		return NULL;
 	if (!buf) {
 		die("Cannot malloc %ld bytes: %s\n",
 			size + 0UL, strerror(errno));
@@ -75,12 +78,8 @@
 	return buf;
 }
 
-
-/* local variables */
-static struct memory_range *memory_range;
-static int memory_ranges;
-
-int valid_memory_range(unsigned long sstart, unsigned long send)
+int valid_memory_range(struct kexec_info *info,
+		       unsigned long sstart, unsigned long send)
 {
 	int i;
 	if (sstart > send) {
@@ -89,13 +88,17 @@
 	if ((send > mem_max) || (sstart < mem_min)) {
 		return 0;
 	}
-	for (i = 0; i < memory_ranges; i++) {
+	for (i = 0; i < info->memory_ranges; i++) {
 		unsigned long mstart, mend;
 		/* Only consider memory ranges */
-		if (memory_range[i].type != RANGE_RAM)
+		if (info->memory_range[i].type != RANGE_RAM)
 			continue;
-		mstart = memory_range[i].start;
-		mend = memory_range[i].end;
+		mstart = info->memory_range[i].start;
+		mend = info->memory_range[i].end;
+		if (i < info->memory_ranges - 1
+		    && mend == info->memory_range[i+1].start)
+			mend = info->memory_range[i+1].end;
+
 		/* Check to see if we are fully contained */
 		if ((mstart <= sstart) && (mend >= send)) {
 			return 1;
@@ -104,13 +107,14 @@
 	return 0;
 }
 
-int valid_memory_segment(struct kexec_segment *segment)
+static int valid_memory_segment(struct kexec_info *info,
+				struct kexec_segment *segment)
 {
 	unsigned long sstart, send;
 	sstart = (unsigned long)segment->mem;
 	send   = sstart + segment->memsz - 1;
 
-	return valid_memory_range(sstart, send);
+	return valid_memory_range(info, sstart, send);
 }
 
 void print_segments(FILE *f, struct kexec_info *info)
@@ -119,10 +123,14 @@
 
 	fprintf(f, "nr_segments = %d\n", info->nr_segments);
 	for (i = 0; i < info->nr_segments; i++) {
-		fprintf(f, "segment[%d].buf   = %p\n",	i, info->segment[i].buf);
-		fprintf(f, "segment[%d].bufsz = %zx\n", i, info->segment[i].bufsz);
-		fprintf(f, "segment[%d].mem   = %p\n",	i, info->segment[i].mem);
-		fprintf(f, "segment[%d].memsz = %zx\n", i, info->segment[i].memsz);
+		fprintf(f, "segment[%d].buf   = %p\n",	i,
+			info->segment[i].buf);
+		fprintf(f, "segment[%d].bufsz = %zx\n", i,
+			info->segment[i].bufsz);
+		fprintf(f, "segment[%d].mem   = %p\n",	i,
+			info->segment[i].mem);
+		fprintf(f, "segment[%d].memsz = %zx\n", i,
+			info->segment[i].memsz);
 	}
 }
 
@@ -187,19 +195,20 @@
 	}
 
 	/* Compute the free memory ranges */
-	max_mem_ranges = memory_ranges + (info->nr_segments -1);
-	mem_range = malloc(max_mem_ranges *sizeof(struct memory_range));
+	max_mem_ranges = info->memory_ranges + info->nr_segments;
+	mem_range = xmalloc(max_mem_ranges *sizeof(struct memory_range));
 	mem_ranges = 0;
 		
 	/* Perform a merge on the 2 sorted lists of memory ranges  */
-	for (j = 0, i = 0; i < memory_ranges; i++) {
-		unsigned long sstart, send;
-		unsigned long mstart, mend;
-		mstart = memory_range[i].start;
-		mend = memory_range[i].end;
-		if (memory_range[i].type != RANGE_RAM)
+	for (j = 0, i = 0; i < info->memory_ranges; i++) {
+		unsigned long long sstart, send;
+		unsigned long long mstart, mend;
+		mstart = info->memory_range[i].start;
+		mend = info->memory_range[i].end;
+		if (info->memory_range[i].type != RANGE_RAM)
 			continue;
-		while ((j < info->nr_segments) && (((unsigned long)info->segment[j].mem) <= mend)) {
+		while ((j < info->nr_segments) &&
+		       (((unsigned long)info->segment[j].mem) <= mend)) {
 			sstart = (unsigned long)info->segment[j].mem;
 			send = sstart + info->segment[j].memsz -1;
 			if (mstart < sstart) {
@@ -211,7 +220,7 @@
 			mstart = send +1;
 			j++;
 		}
-		if (mstart <= mend) {
+		if (mstart < mend) {
 			mem_range[mem_ranges].start = mstart;
 			mem_range[mem_ranges].end = mend;
 			mem_range[mem_ranges].type = RANGE_RAM;
@@ -232,7 +241,8 @@
 		if (start < hole_min) {
 			start = hole_min;
 		}
-		start = (start + hole_align - 1) & ~(hole_align - 1);
+		start = (start + hole_align - 1) &
+			~((unsigned long long)hole_align - 1);
 		if (end > mem_max) {
 			end = mem_max;
 		}
@@ -250,18 +260,20 @@
 				hole_base = start;
 				break;
 			} else {
-				hole_base = (end - hole_size) & ~(hole_align - 1);
+				hole_base = (end - hole_size) &
+					~((unsigned long long)hole_align - 1);
 			}
 		}
 	}
+	free(mem_range);
 	if (hole_base == ULONG_MAX) {
-		fprintf(stderr, "Could not find a free area of memory of %lx bytes...\n",
-			hole_size);
+		fprintf(stderr, "Could not find a free area of memory of "
+			"%lx bytes...\n", hole_size);
 		return ULONG_MAX;
 	}
 	if ((hole_base + hole_size)  > hole_max) {
-		fprintf(stderr, "Could not find a free area of memory below: %lx...\n",
-			hole_max);
+		fprintf(stderr, "Could not find a free area of memory below: "
+			"%lx...\n", hole_max);
 		return ULONG_MAX;
 	}
 	return hole_base;
@@ -298,7 +310,7 @@
 	}
 	
 	last = base + memsz -1;
-	if (!valid_memory_range(base, last)) {
+	if (!valid_memory_range(info, base, last)) {
 		die("Invalid memory segment %p - %p\n",
 			(void *)base, (void *)last);
 	}
@@ -311,8 +323,8 @@
 	info->segment[info->nr_segments].memsz = memsz;
 	info->nr_segments++;
 	if (info->nr_segments > KEXEC_MAX_SEGMENTS) {
-		fprintf(stderr, 
-			"Warning: kernel segment limit reached. This will likely fail\n");
+		fprintf(stderr, "Warning: kernel segment limit reached. "
+			"This will likely fail\n");
 	}
 }
 
@@ -323,12 +335,17 @@
 {
 	unsigned long base;
 	int result;
+	int pagesize;
 
 	result = sort_segments(info);
 	if (result < 0) {
 		die("sort_segments failed\n");
 	}
 
+	/* Round memsz up to a multiple of pagesize */
+	pagesize = getpagesize();
+	memsz = (memsz + (pagesize - 1)) & ~(pagesize - 1);
+
 	base = locate_hole(info, memsz, buf_align, buf_min, buf_max, buf_end);
 	if (base == ULONG_MAX) {
 		die("locate_hole failed\n");
@@ -370,9 +387,52 @@
 		if (result < 0) {
 			if ((errno == EINTR) ||	(errno == EAGAIN))
 				continue;
-			die("read on %s of %ld bytes failed: %s\n",
-				filename, (size - progress)+ 0UL, strerror(errno));
+			die("read on %s of %ld bytes failed: %s\n", filename,
+			    (size - progress)+ 0UL, strerror(errno));
+		}
+		progress += result;
+	}
+	result = close(fd);
+	if (result < 0) {
+		die("Close of %s failed: %s\n", filename, strerror(errno));
+	}
+	return buf;
+}
+
+/* This functions reads either specified number of bytes from the file or
+   lesser if EOF is met. */
+
+char *slurp_file_len(const char *filename, off_t size)
+{
+	int fd;
+	char *buf;
+	off_t progress;
+	ssize_t result;
+
+	if (!filename)
+		return 0;
+	fd = open(filename, O_RDONLY);
+	if (fd < 0) {
+		fprintf(stderr, "Cannot open %s: %s\n", filename,
+				strerror(errno));
+		return 0;
+	}
+	buf = xmalloc(size);
+	progress = 0;
+	while(progress < size) {
+		result = read(fd, buf + progress, size - progress);
+		if (result < 0) {
+			if ((errno == EINTR) ||	(errno == EAGAIN))
+				continue;
+			fprintf(stderr, "read on %s of %ld bytes failed: %s\n",
+					filename, (size - progress)+ 0UL,
+					strerror(errno));
+			free(buf);
+			return 0;
 		}
+		if (result == 0)
+			/* EOF */
+			break;
 		progress += result;
 	}
 	result = close(fd);
@@ -470,7 +530,8 @@
 		if (info->segment[i].mem == (void *)info->rhdr.rel_addr) {
 			continue;
 		}
-		sha256_update(&ctx, info->segment[i].buf, info->segment[i].bufsz);
+		sha256_update(&ctx, info->segment[i].buf,
+			      info->segment[i].bufsz);
 		nullsz = info->segment[i].memsz - info->segment[i].bufsz;
 		while(nullsz) {
 			unsigned long bytes = nullsz;
@@ -485,8 +546,10 @@
 		j++;
 	}
 	sha256_finish(&ctx, digest);
-	elf_rel_set_symbol(&info->rhdr, "sha256_regions", &region, sizeof(region));
-	elf_rel_set_symbol(&info->rhdr, "sha256_digest", &digest, sizeof(digest));
+	elf_rel_set_symbol(&info->rhdr, "sha256_regions", &region,
+			   sizeof(region));
+	elf_rel_set_symbol(&info->rhdr, "sha256_digest", &digest,
+			   sizeof(digest));
 }
 
 /*
@@ -507,6 +570,8 @@
 	info.segment = NULL;
 	info.nr_segments = 0;
 	info.entry = NULL;
+	info.backup_start = 0;
+	info.kexec_flags = kexec_flags;
 
 	result = 0;
 	if (argc - fileind <= 0) {
@@ -522,7 +587,8 @@
 		kernel_buf, kernel_size);
 #endif
 
-	if (get_memory_ranges(&memory_range, &memory_ranges) < 0) {
+	if (get_memory_ranges(&info.memory_range, &info.memory_ranges,
+		info.kexec_flags) < 0) {
 		fprintf(stderr, "Could not get memory layout\n");
 		return -1;
 	}
@@ -559,17 +625,18 @@
 			}
 		}
 	}
-	if (file_type[i].load(argc, argv, kernel_buf, kernel_size, &info) < 0) {
+	if (file_type[i].load(argc, argv, kernel_buf,
+			      kernel_size, &info) < 0) {
 		fprintf(stderr, "Cannot load %s\n", kernel);
 		return -1;
 	}
 	/* If we are not in native mode setup an appropriate trampoline */
-	if (arch_compat_trampoline(&info, &kexec_flags) < 0) {
+	if (arch_compat_trampoline(&info) < 0) {
 		return -1;
 	}
 	/* Verify all of the segments load to a valid location in memory */
 	for (i = 0; i < info.nr_segments; i++) {
-		if (!valid_memory_segment(info.segment +i)) {
+		if (!valid_memory_segment(&info, info.segment +i)) {
 			fprintf(stderr, "Invalid memory segment %p - %p\n",
 				info.segment[i].mem,
 				((char *)info.segment[i].mem) + 
@@ -585,17 +652,17 @@
 	update_purgatory(&info);
 #if 0
 	fprintf(stderr, "kexec_load: entry = %p flags = %lx\n", 
-		info.entry, kexec_flags);
+		info.entry, info.kexec_flags);
 	print_segments(stderr, &info);
 #endif
 	result = kexec_load(
-		info.entry, info.nr_segments, info.segment, kexec_flags);
+		info.entry, info.nr_segments, info.segment, info.kexec_flags);
 	if (result != 0) {
 		/* The load failed, print some debugging information */
 		fprintf(stderr, "kexec_load failed: %s\n", 
 			strerror(errno));
 		fprintf(stderr, "entry       = %p flags = %lx\n", 
-			info.entry, kexec_flags);
+			info.entry, info.kexec_flags);
 		print_segments(stderr, &info);
 	}
 	return result;
@@ -651,7 +718,7 @@
 
 static void version(void)
 {
-	printf("kexec " VERSION " released " RELEASE_DATE "\n");
+	printf(PACKAGE " " VERSION " released " RELEASE_DATE "\n");
 }
 
 void usage(void)
@@ -659,25 +726,31 @@
 	int i;
 
 	version();
-	printf(
-		"Usage: kexec [OPTION]... [kernel]\n"
-		"Directly reboot into a new kernel\n"
-		"\n"
-		" -h, --help           Print this help.\n"
-		" -v, --version        Print the version of kexec.\n"
-		" -f, --force          Force an immediate kexec, don't call shutdown.\n"
-		" -x, --no-ifdown      Don't bring down network interfaces.\n"
-		"                      (if used, must be last option specified)\n"
-		" -l, --load           Load the new kernel into the current kernel.\n"
-		" -p, --load-panic     Load the new kernel for use on panic.\n"
-		" -u, --unload         Unload the current kexec target kernel.\n"
-		" -e, --exec           Execute a currently loaded kernel.\n"
-		" -t, --type=TYPE      Specify the new kernel is of this type.\n"
-		"     --mem-min=<addr> Specify the lowest memory addres to load code into.\n"
-		"     --mem-max=<addr> Specify the highest memory addres to load code into.\n"
-		"\n"
-		"Supported kernel file types and options: \n"
-		);
+	printf("Usage: kexec [OPTION]... [kernel]\n"
+	       "Directly reboot into a new kernel\n"
+	       "\n"
+	       " -h, --help           Print this help.\n"
+	       " -v, --version        Print the version of kexec.\n"
+	       " -f, --force          Force an immediate kexec,\n"
+	       "                      don't call shutdown.\n"
+	       " -x, --no-ifdown      Don't bring down network interfaces.\n"
+	       "                      (if used, must be last option\n"
+	       "                       specified)\n"
+	       " -l, --load           Load the new kernel into the\n"
+	       "                      current kernel.\n"
+	       " -p, --load-panic     Load the new kernel for use on panic.\n"
+	       " -u, --unload         Unload the current kexec target kernel.\n"
+	       "                      If capture kernel is being unloaded\n"
+	       "                      specify -p with -u.\n"
+	       " -e, --exec           Execute a currently loaded kernel.\n"
+	       " -t, --type=TYPE      Specify the new kernel is of this type.\n"
+	       "     --mem-min=<addr> Specify the lowest memory address to\n"
+	       "                      load code into.\n"
+	       "     --mem-max=<addr> Specify the highest memory address to\n"
+	       "                      load code into.\n"
+	       "     --reuseinird     Reuse initrd from first boot.\n"
+	       "\n"
+	       "Supported kernel file types and options: \n");
 	for (i = 0; i < file_types; i++) {
 		printf("%s\n", file_type[i].name);
 		file_type[i].usage();
@@ -687,6 +760,45 @@
 	printf("\n");
 }
 
+static int kexec_loaded(void)
+{
+	int ret;
+	FILE *fp;
+
+	fp = fopen("/sys/kernel/kexec_loaded", "r");
+	if (fp == NULL)
+		return -1;
+	fscanf(fp, "%d", &ret);
+	fclose(fp);
+	return ret;
+}
+
+/* check we retained the initrd */
+void check_reuse_initrd(void)
+{
+	FILE * fp;
+	char * line = NULL;
+	size_t len = 0;
+	ssize_t read;
+
+	fp = fopen("/proc/cmdline", "r");
+	if (fp == NULL)
+		die("unable to open /proc/cmdline\n");
+	read = getline(&line, &len, fp);
+	if (strstr(line, "retain_initrd") == NULL)
+		die("unrecoverable error: current boot didn't "
+		    "retain the initrd for reuse.\n");
+	if (line)
+		free(line);
+	close(fp);
+}
+
+/* Arch hook for reuse_initrd */
+void __attribute__((weak)) arch_reuse_initrd(void)
+{
+	die("--reuseinitrd not implemented on this architecture\n");
+}
+
 int main(int argc, char *argv[])
 {
 	int do_load = 1;
@@ -695,6 +807,7 @@
 	int do_sync = 1;
 	int do_ifdown = 0;
 	int do_unload = 0;
+	int do_reuse_initrd = 0;
 	unsigned long kexec_flags = 0;
 	char *type = 0;
 	char *endptr;
@@ -702,13 +815,14 @@
 	int result = 0;
 	int fileind;
 	static const struct option options[] = {
-		KEXEC_OPTIONS
+		KEXEC_ARCH_OPTIONS
 		{ 0, 0, 0, 0},
 	};
 	static const char short_options[] = KEXEC_OPT_STR;
 
 	opterr = 0; /* Don't complain about unrecognized options here */
-	while ((opt = getopt_long(argc, argv, short_options, options, 0)) != -1) {
+	while ((opt = getopt_long(argc, argv, short_options,
+				  options, 0)) != -1) {
 		switch(opt) {
 		case OPT_HELP:
 			usage();
@@ -757,7 +871,8 @@
 		case OPT_MEM_MIN:
 			mem_min = strtoul(optarg, &endptr, 0);
 			if (*endptr) {
-				fprintf(stderr, "Bad option value in --mem-min=%s\n",
+				fprintf(stderr,
+					"Bad option value in --mem-min=%s\n",
 					optarg);
 				usage();
 				return 1;
@@ -766,17 +881,28 @@
 		case OPT_MEM_MAX:
 			mem_max = strtoul(optarg, &endptr, 0);
 			if (*endptr) {
-				fprintf(stderr, "Bad option value in --mem-max=%s\n",
+				fprintf(stderr,
+					"Bad option value in --mem-max=%s\n",
 					optarg);
 				usage();
 				return 1;
 			}
 			break;
+		case OPT_REUSE_INITRD:
+			do_reuse_initrd = 1;
+			break;
 		default:
 			break;
 		}
 	}
 
+	if ((kexec_flags & KEXEC_ON_CRASH) && !is_crashkernel_mem_reserved()) {
+		printf("Memory for crashkernel is not reserved\n");
+		printf("Please reserve memory by passing ");
+		printf("\"crashkernel=X@Y\" parameter to the kernel\n");
+		die("Then try loading kdump kernel\n");
+	}
+
 	fileind = optind;
 	/* Reset getopt for the next pass; called in other source modules */
 	opterr = 1;
@@ -784,12 +910,32 @@
 
 	result = arch_process_options(argc, argv);
 
+	/* Check for bogus options */
+	if (!do_load) {
+		while((opt = getopt_long(argc, argv, short_options,
+					 options, 0)) != -1) {
+			if ((opt == '?') || (opt >= OPT_ARCH_MAX)) {
+				usage();
+				return 1;
+			}
+		}
+	}
+
+	if (do_reuse_initrd){
+		check_reuse_initrd();
+		arch_reuse_initrd();
+	}
+
 	if (do_unload) {
 		result = k_unload(kexec_flags);
 	}
 	if (do_load && (result == 0)) {
 		result = my_load(type, fileind, argc, argv, kexec_flags);
 	}
+	/* Don't shutdown unless there is something to reboot to! */
+	if ((result == 0) && (do_shutdown || do_exec) && !kexec_loaded()) {
+		die("Nothing has been loaded!\n");
+	}
 	if ((result == 0) && do_shutdown) {
 		result = my_shutdown();
 	}
diff -Nur kexec-tools-1.101/kexec/kexec-elf.c kexec-tools-1.101-geoff/kexec/kexec-elf.c
--- kexec-tools-1.101/kexec/kexec-elf.c	2004-12-20 15:28:30.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/kexec-elf.c	2007-10-23 16:24:40.000000000 +0700
@@ -113,21 +113,21 @@
 		}
 		return -1;
 	}
-	if (elf32_to_cpu(ehdr, lehdr.e_entry) > ULONG_MAX) {
+	if (elf32_to_cpu(ehdr, lehdr.e_entry) > UINT32_MAX) {
 		/* entry is to large */
 		if (probe_debug) {
 			fprintf(stderr, "ELF e_entry to large\n");
 		}
 		return -1;
 	}
-	if (elf32_to_cpu(ehdr, lehdr.e_phoff) > ULONG_MAX) {
+	if (elf32_to_cpu(ehdr, lehdr.e_phoff) > UINT32_MAX) {
 		/* phoff is to large */
 		if (probe_debug) {
 			fprintf(stderr, "ELF e_phoff to large\n");
 		}
 		return -1;
 	}
-	if (elf32_to_cpu(ehdr, lehdr.e_shoff) > ULONG_MAX) {
+	if (elf32_to_cpu(ehdr, lehdr.e_shoff) > UINT32_MAX) {
 		/* shoff is to large */
 		if (probe_debug) {
 			fprintf(stderr, "ELF e_shoff to large\n");
@@ -146,7 +146,7 @@
 	ehdr->e_shstrndx  = elf16_to_cpu(ehdr, lehdr.e_shstrndx);
 
 	if ((ehdr->e_phnum > 0) &&
-		(elf16_to_cpu(ehdr, lehdr.e_phentsize) != sizeof(Elf32_Phdr))) 
+		(elf16_to_cpu(ehdr, lehdr.e_phentsize) != sizeof(Elf32_Phdr)))
 	{
 		/* Invalid program header size */
 		if (probe_debug) {
@@ -185,21 +185,21 @@
 		}
 		return -1;
 	}
-	if (elf32_to_cpu(ehdr, lehdr.e_entry) > ULONG_MAX) {
+	if (elf32_to_cpu(ehdr, lehdr.e_entry) > UINT32_MAX) {
 		/* entry is to large */
 		if (probe_debug) {
 			fprintf(stderr, "ELF e_entry to large\n");
 		}
 		return -1;
 	}
-	if (elf32_to_cpu(ehdr, lehdr.e_phoff) > ULONG_MAX) {
+	if (elf32_to_cpu(ehdr, lehdr.e_phoff) > UINT32_MAX) {
 		/* phoff is to large */
 		if (probe_debug) {
 			fprintf(stderr, "ELF e_phoff to large\n");
 		}
 		return -1;
 	}
-	if (elf32_to_cpu(ehdr, lehdr.e_shoff) > ULONG_MAX) {
+	if (elf32_to_cpu(ehdr, lehdr.e_shoff) > UINT32_MAX) {
 		/* shoff is to large */
 		if (probe_debug) {
 			fprintf(stderr, "ELF e_shoff to large\n");
@@ -218,7 +218,7 @@
 	ehdr->e_shstrndx  = elf16_to_cpu(ehdr, lehdr.e_shstrndx);
 
 	if ((ehdr->e_phnum > 0) &&
-		(elf16_to_cpu(ehdr, lehdr.e_phentsize) != sizeof(Elf64_Phdr))) 
+		(elf16_to_cpu(ehdr, lehdr.e_phentsize) != sizeof(Elf64_Phdr)))
 	{
 		/* Invalid program header size */
 		if (probe_debug) {
@@ -302,7 +302,7 @@
 	return 0;
 }
 
-static int build_mem_elf32_phdr(const char *buf, off_t len, 
+static int build_mem_elf32_phdr(const char *buf, off_t len,
 	struct mem_ehdr *ehdr, int idx)
 {
 	struct mem_phdr *phdr;
@@ -312,12 +312,12 @@
 	phdr = &ehdr->e_phdr[idx];
 	memcpy(&lphdr, pbuf, sizeof(lphdr));
 
-	if (	(elf32_to_cpu(ehdr, lphdr.p_filesz) > ULONG_MAX) || 
-		(elf32_to_cpu(ehdr, lphdr.p_memsz)  > ULONG_MAX) ||
-		(elf32_to_cpu(ehdr, lphdr.p_offset) > ULONG_MAX) ||
-		(elf32_to_cpu(ehdr, lphdr.p_paddr)  > ULONG_MAX) ||
-		(elf32_to_cpu(ehdr, lphdr.p_vaddr)  > ULONG_MAX) ||
-		(elf32_to_cpu(ehdr, lphdr.p_align)  > ULONG_MAX))
+	if (	(elf32_to_cpu(ehdr, lphdr.p_filesz) > UINT32_MAX) ||
+		(elf32_to_cpu(ehdr, lphdr.p_memsz)  > UINT32_MAX) ||
+		(elf32_to_cpu(ehdr, lphdr.p_offset) > UINT32_MAX) ||
+		(elf32_to_cpu(ehdr, lphdr.p_paddr)  > UINT32_MAX) ||
+		(elf32_to_cpu(ehdr, lphdr.p_vaddr)  > UINT32_MAX) ||
+		(elf32_to_cpu(ehdr, lphdr.p_align)  > UINT32_MAX))
 	{
 		fprintf(stderr, "Program segment size out of range\n");
 		return -1;
@@ -345,12 +345,12 @@
 	phdr = &ehdr->e_phdr[idx];
 	memcpy(&lphdr, pbuf, sizeof(lphdr));
 
-	if (	(elf64_to_cpu(ehdr, lphdr.p_filesz) > ULONG_MAX) || 
-		(elf64_to_cpu(ehdr, lphdr.p_memsz)  > ULONG_MAX) ||
-		(elf64_to_cpu(ehdr, lphdr.p_offset) > ULONG_MAX) ||
-		(elf64_to_cpu(ehdr, lphdr.p_paddr)  > ULONG_MAX) ||
-		(elf64_to_cpu(ehdr, lphdr.p_vaddr)  > ULONG_MAX) ||
-		(elf64_to_cpu(ehdr, lphdr.p_align)  > ULONG_MAX))
+	if (	(elf64_to_cpu(ehdr, lphdr.p_filesz) > UINT64_MAX) ||
+		(elf64_to_cpu(ehdr, lphdr.p_memsz)  > UINT64_MAX) ||
+		(elf64_to_cpu(ehdr, lphdr.p_offset) > UINT64_MAX) ||
+		(elf64_to_cpu(ehdr, lphdr.p_paddr)  > UINT64_MAX) ||
+		(elf64_to_cpu(ehdr, lphdr.p_vaddr)  > UINT64_MAX) ||
+		(elf64_to_cpu(ehdr, lphdr.p_align)  > UINT64_MAX))
 	{
 		fprintf(stderr, "Program segment size out of range\n");
 		return -1;
@@ -368,7 +368,8 @@
 	return 0;
 }
 
-static int build_mem_phdrs(const char *buf, off_t len, struct mem_ehdr *ehdr)
+static int build_mem_phdrs(const char *buf, off_t len, struct mem_ehdr *ehdr,
+				uint32_t flags)
 {
 	size_t phdr_size, mem_phdr_size;
 	int i;
@@ -388,7 +389,7 @@
 		fprintf(stderr, "Invalid ei_class?\n");
 		return -1;
 	}
-	phdr_size *= ehdr->e_phnum; 
+	phdr_size *= ehdr->e_phnum;
 	if (ehdr->e_phoff + phdr_size > len) {
 		/* The program header did not fit in the file buffer */
 		if (probe_debug) {
@@ -396,7 +397,7 @@
 		}
 		return -1;
 	}
-	
+
 	/* Allocate the e_phdr array */
 	mem_phdr_size = sizeof(ehdr->e_phdr[0]) * ehdr->e_phnum;
 	ehdr->e_phdr = xmalloc(mem_phdr_size);
@@ -418,9 +419,11 @@
 
 		/* Check the program headers to be certain
 		 * they are safe to use.
+		 * Skip the check if ELF_SKIP_FILESZ_CHECK is set.
 		 */
 		phdr = &ehdr->e_phdr[i];
-		if ((phdr->p_offset + phdr->p_filesz) > len) {
+		if (!(flags & ELF_SKIP_FILESZ_CHECK)
+			&& (phdr->p_offset + phdr->p_filesz) > len) {
 			/* The segment does not fit in the buffer */
 			if (probe_debug) {
 				fprintf(stderr, "ELF segment not in file\n");
@@ -440,7 +443,7 @@
 	return 0;
 }
 
-static int build_mem_elf32_shdr(const char *buf, off_t len, 
+static int build_mem_elf32_shdr(const char *buf, off_t len,
 	struct mem_ehdr *ehdr, int idx)
 {
 	struct mem_shdr *shdr;
@@ -451,12 +454,12 @@
 	shdr = &ehdr->e_shdr[idx];
 	memcpy(&lshdr, sbuf, sizeof(lshdr));
 
-	if (	(elf32_to_cpu(ehdr, lshdr.sh_flags)     > ULONG_MAX) || 
-		(elf32_to_cpu(ehdr, lshdr.sh_addr)      > ULONG_MAX) ||
-		(elf32_to_cpu(ehdr, lshdr.sh_offset)    > ULONG_MAX) ||
-		(elf32_to_cpu(ehdr, lshdr.sh_size)      > ULONG_MAX) ||
-		(elf32_to_cpu(ehdr, lshdr.sh_addralign) > ULONG_MAX) ||
-		(elf32_to_cpu(ehdr, lshdr.sh_entsize)   > ULONG_MAX))
+	if (	(elf32_to_cpu(ehdr, lshdr.sh_flags)     > UINT32_MAX) ||
+		(elf32_to_cpu(ehdr, lshdr.sh_addr)      > UINT32_MAX) ||
+		(elf32_to_cpu(ehdr, lshdr.sh_offset)    > UINT32_MAX) ||
+		(elf32_to_cpu(ehdr, lshdr.sh_size)      > UINT32_MAX) ||
+		(elf32_to_cpu(ehdr, lshdr.sh_addralign) > UINT32_MAX) ||
+		(elf32_to_cpu(ehdr, lshdr.sh_entsize)   > UINT32_MAX))
 	{
 		fprintf(stderr, "Program section size out of range\n");
 		return -1;
@@ -510,7 +513,7 @@
 	return 0;
 }
 
-static int build_mem_elf64_shdr(const char *buf, off_t len, 
+static int build_mem_elf64_shdr(const char *buf, off_t len,
 	struct mem_ehdr *ehdr, int idx)
 {
 	struct mem_shdr *shdr;
@@ -521,12 +524,12 @@
 	shdr = &ehdr->e_shdr[idx];
 	memcpy(&lshdr, sbuf, sizeof(lshdr));
 
-	if (	(elf64_to_cpu(ehdr, lshdr.sh_flags)     > ULONG_MAX) || 
-		(elf64_to_cpu(ehdr, lshdr.sh_addr)      > ULONG_MAX) ||
-		(elf64_to_cpu(ehdr, lshdr.sh_offset)    > ULONG_MAX) ||
-		(elf64_to_cpu(ehdr, lshdr.sh_size)      > ULONG_MAX) ||
-		(elf64_to_cpu(ehdr, lshdr.sh_addralign) > ULONG_MAX) ||
-		(elf64_to_cpu(ehdr, lshdr.sh_entsize)   > ULONG_MAX))
+	if (	(elf64_to_cpu(ehdr, lshdr.sh_flags)     > UINT64_MAX) ||
+		(elf64_to_cpu(ehdr, lshdr.sh_addr)      > UINT64_MAX) ||
+		(elf64_to_cpu(ehdr, lshdr.sh_offset)    > UINT64_MAX) ||
+		(elf64_to_cpu(ehdr, lshdr.sh_size)      > UINT64_MAX) ||
+		(elf64_to_cpu(ehdr, lshdr.sh_addralign) > UINT64_MAX) ||
+		(elf64_to_cpu(ehdr, lshdr.sh_entsize)   > UINT64_MAX))
 	{
 		fprintf(stderr, "Program section size out of range\n");
 		return -1;
@@ -580,7 +583,8 @@
 	return 0;
 }
 
-static int build_mem_shdrs(const char *buf, off_t len, struct mem_ehdr *ehdr)
+static int build_mem_shdrs(const char *buf, off_t len, struct mem_ehdr *ehdr,
+				uint32_t flags)
 {
 	size_t shdr_size, mem_shdr_size;
 	int i;
@@ -608,7 +612,7 @@
 		}
 		return -1;
 	}
-	
+
 	/* Allocate the e_shdr array */
 	mem_shdr_size = sizeof(ehdr->e_shdr[0]) * ehdr->e_shnum;
 	ehdr->e_shdr = xmalloc(mem_shdr_size);
@@ -628,14 +632,15 @@
 		}
 		/* Check the section headers to be certain
 		 * they are safe to use.
+		 * Skip the check if ELF_SKIP_FILESZ_CHECK is set.
 		 */
 		shdr = &ehdr->e_shdr[i];
-		if ((shdr->sh_type != SHT_NOBITS) &&
-			((shdr->sh_offset + shdr->sh_size) > len))
-		{
+		if (!(flags & ELF_SKIP_FILESZ_CHECK)
+			&& (shdr->sh_type != SHT_NOBITS)
+			&& (shdr->sh_offset + shdr->sh_size) > len) {
 			/* The section does not fit in the buffer */
 			if (probe_debug) {
-				fprintf(stderr, "ELF section %d not in file\n", 
+				fprintf(stderr, "ELF section %d not in file\n",
 					i);
 			}
 			return -1;
@@ -648,19 +653,19 @@
 			return -1;
 		}
 		/* Remember where the section lives in the buffer */
-		shdr->sh_data = buf + shdr->sh_offset;
+		shdr->sh_data = (unsigned char *)(buf + shdr->sh_offset);
 	}
 	return 0;
 }
 
-static void read_nhdr(const struct mem_ehdr *ehdr, 
+static void read_nhdr(const struct mem_ehdr *ehdr,
 	ElfNN_Nhdr *hdr, const unsigned char *note)
 {
 	memcpy(hdr, note, sizeof(*hdr));
 	hdr->n_namesz = elf32_to_cpu(ehdr, hdr->n_namesz);
 	hdr->n_descsz = elf32_to_cpu(ehdr, hdr->n_descsz);
 	hdr->n_type   = elf32_to_cpu(ehdr, hdr->n_type);
-		
+
 }
 static int build_mem_notes(const char *buf, off_t len, struct mem_ehdr *ehdr)
 {
@@ -671,8 +676,15 @@
 	note_start = note_end = NULL;
 	for(i = 0; !note_start && (i < ehdr->e_phnum); i++) {
 		struct mem_phdr *phdr = &ehdr->e_phdr[i];
-		if (phdr->p_type == PT_NOTE) {
-			note_start = phdr->p_data;
+		/*
+		 * binutils <= 2.17 has a bug where it can create the
+		 * PT_NOTE segment with an offset of 0. Therefore
+		 * check p_offset > 0.
+		 *
+		 * See: http://sourceware.org/bugzilla/show_bug.cgi?id=594
+		 */
+		if (phdr->p_type == PT_NOTE && phdr->p_offset) {
+			note_start = (unsigned char *)phdr->p_data;
 			note_end = note_start + phdr->p_filesz;
 		}
 	}
@@ -686,7 +698,7 @@
 	if (!note_start) {
 		return 0;
 	}
-	
+
 	/* Walk through and count the notes */
 	ehdr->e_notenum = 0;
 	for(note = note_start; note < note_end; note+= note_size) {
@@ -708,20 +720,26 @@
 		note_size += (hdr.n_namesz + 3) & ~3;
 		desc       = note + note_size;
 		note_size += (hdr.n_descsz + 3) & ~3;
-		
+
 		if ((hdr.n_namesz != 0) && (name[hdr.n_namesz -1] != '\0')) {
-			die("Note name is not null termiated");
+			/* If note name string is not null terminated, just
+			 * warn user about it and continue processing. This
+			 * allows us to parse /proc/kcore on older kernels
+			 * where /proc/kcore elf notes were not null
+			 * terminated. It has been fixed in 2.6.19.
+			 */
+			fprintf(stderr, "Warning: Elf Note name is not null "
+					"terminated\n");
 		}
 		ehdr->e_note[i].n_type = hdr.n_type;
-		ehdr->e_note[i].n_name = name;
+		ehdr->e_note[i].n_name = (char *)name;
 		ehdr->e_note[i].n_desc = desc;
 		ehdr->e_note[i].n_descsz = hdr.n_descsz;
-		
+
 	}
 	return 0;
 }
 
-
 void free_elf_info(struct mem_ehdr *ehdr)
 {
 	free(ehdr->e_phdr);
@@ -729,7 +747,8 @@
 	memset(ehdr, 0, sizeof(*ehdr));
 }
 
-int build_elf_info(const char *buf, off_t len, struct mem_ehdr *ehdr)
+int build_elf_info(const char *buf, off_t len, struct mem_ehdr *ehdr,
+			uint32_t flags)
 {
 	int result;
 	result = build_mem_ehdr(buf, len, ehdr);
@@ -737,14 +756,14 @@
 		return result;
 	}
 	if ((ehdr->e_phoff > 0) && (ehdr->e_phnum > 0)) {
-		result = build_mem_phdrs(buf, len, ehdr);
+		result = build_mem_phdrs(buf, len, ehdr, flags);
 		if (result < 0) {
 			free_elf_info(ehdr);
 			return result;
 		}
 	}
 	if ((ehdr->e_shoff > 0) && (ehdr->e_shnum > 0)) {
-		result = build_mem_shdrs(buf, len, ehdr);
+		result = build_mem_shdrs(buf, len, ehdr, flags);
 		if (result < 0) {
 			free_elf_info(ehdr);
 			return result;
diff -Nur kexec-tools-1.101/kexec/kexec-elf-core.c kexec-tools-1.101-geoff/kexec/kexec-elf-core.c
--- kexec-tools-1.101/kexec/kexec-elf-core.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/kexec-elf-core.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,29 @@
+#include <stdio.h>
+#include <stdint.h>
+#include <errno.h>
+#include <stdlib.h>
+#include "elf.h"
+#include "kexec-elf.h"
+
+
+int build_elf_core_info(const char *buf, off_t len, struct mem_ehdr *ehdr,
+				uint32_t flags)
+{
+	int result;
+	result = build_elf_info(buf, len, ehdr, flags);
+	if (result < 0) {
+		return result;
+	}
+	if ((ehdr->e_type != ET_CORE)) {
+		/* not an ELF Core */
+		fprintf(stderr, "Not ELF type ET_CORE\n");
+		return -1;
+	}
+	if (!ehdr->e_phdr) {
+		/* No program header */
+		fprintf(stderr, "No ELF program header\n");
+		return -1;
+	}
+
+	return 0;
+}
diff -Nur kexec-tools-1.101/kexec/kexec-elf-exec.c kexec-tools-1.101-geoff/kexec/kexec-elf-exec.c
--- kexec-tools-1.101/kexec/kexec-elf-exec.c	2005-01-13 19:03:53.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/kexec-elf-exec.c	2007-10-23 16:24:40.000000000 +0700
@@ -11,11 +11,12 @@
 
 static const int probe_debug = 0;
 
-int build_elf_exec_info(const char *buf, off_t len, struct mem_ehdr *ehdr)
+int build_elf_exec_info(const char *buf, off_t len, struct mem_ehdr *ehdr,
+				uint32_t flags)
 {
 	struct mem_phdr *phdr, *end_phdr;
 	int result;
-	result = build_elf_info(buf, len, ehdr);
+	result = build_elf_info(buf, len, ehdr, flags);
 	if (result < 0) {
 		return result;
 	}
@@ -47,7 +48,7 @@
 }
 
 
-int elf_exec_load(const struct mem_ehdr *ehdr, struct kexec_info *info)
+int elf_exec_load(struct mem_ehdr *ehdr, struct kexec_info *info)
 {
 	unsigned long base;
 	int result;
@@ -79,8 +80,8 @@
 			}
 			start = phdr->p_paddr;
 			stop  = start + phdr->p_memsz;
-			if (start > first) {
-				start = first;
+			if (first > start) {
+				first = start;
 			}
 			if (last < stop) {
 				last = stop;
@@ -92,7 +93,7 @@
 		/* If I can't use the default paddr find a new
 		 * hole for the dynamic executable.
 		 */
-		if (!valid_memory_range(first, last)) {
+		if (!valid_memory_range(info, first, last)) {
 			unsigned long hole;
 			hole = locate_hole(info,
 				last - first + 1, align, 
@@ -126,17 +127,21 @@
 			phdr->p_data, size,
 			phdr->p_paddr + base, phdr->p_memsz);
 	}
+
+	/* Update entry point to reflect new load address*/
+	ehdr->e_entry += base;
+
 	result = 0;
  out:
 	return result;
 }
 
 void elf_exec_build_load(struct kexec_info *info, struct mem_ehdr *ehdr, 
-	const char *buf, off_t len)
+	const char *buf, off_t len, uint32_t flags)
 {
 	int result;
 	/* Parse the Elf file */
-	result = build_elf_exec_info(buf, len, ehdr);
+	result = build_elf_exec_info(buf, len, ehdr, flags);
 	if (result < 0) {
 		die("ELF exec parse failed\n");
 	}
diff -Nur kexec-tools-1.101/kexec/kexec-elf.h kexec-tools-1.101-geoff/kexec/kexec-elf.h
--- kexec-tools-1.101/kexec/kexec-elf.h	2005-01-13 19:04:58.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/kexec-elf.h	2007-10-23 16:24:40.000000000 +0700
@@ -82,22 +82,29 @@
 	uint32_t n_type;		/* Type of the note.  */
 } ElfNN_Nhdr;
 
+/* Misc flags */
 
+#define ELF_SKIP_FILESZ_CHECK		0x00000001
 
 extern void free_elf_info(struct mem_ehdr *ehdr);
-extern int build_elf_info(const char *buf, off_t len, struct mem_ehdr *ehdr);
-extern int build_elf_exec_info(const char *buf, off_t len, struct mem_ehdr *ehdr);
-extern int build_elf_rel_info(const char *buf, off_t len, struct mem_ehdr *ehdr);
-
-extern int elf_exec_load(const struct mem_ehdr *ehdr, struct kexec_info *info);
+extern int build_elf_info(const char *buf, off_t len, struct mem_ehdr *ehdr,
+				uint32_t flags);
+extern int build_elf_exec_info(const char *buf, off_t len,
+				struct mem_ehdr *ehdr, uint32_t flags);
+extern int build_elf_rel_info(const char *buf, off_t len, struct mem_ehdr *ehdr,
+				uint32_t flags);
+
+extern int build_elf_core_info(const char *buf, off_t len,
+					struct mem_ehdr *ehdr, uint32_t flags);
+extern int elf_exec_load(struct mem_ehdr *ehdr, struct kexec_info *info);
 extern int elf_rel_load(struct mem_ehdr *ehdr, struct kexec_info *info,
 	unsigned long min, unsigned long max, int end);
 
 extern void elf_exec_build_load(struct kexec_info *info, struct mem_ehdr *ehdr, 
-	const char *buf, off_t len);
+				const char *buf, off_t len, uint32_t flags);
 extern void elf_rel_build_load(struct kexec_info *info, struct mem_ehdr *ehdr, 
 	const char *buf, off_t len, unsigned long min, unsigned long max, 
-	int end);
+	int end, uint32_t flags);
 
 extern int elf_rel_find_symbol(struct mem_ehdr *ehdr,
 	const char *name, struct mem_sym *ret_sym);
diff -Nur kexec-tools-1.101/kexec/kexec-elf-rel.c kexec-tools-1.101-geoff/kexec/kexec-elf-rel.c
--- kexec-tools-1.101/kexec/kexec-elf-rel.c	2005-01-13 19:04:21.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/kexec-elf-rel.c	2007-10-23 16:24:40.000000000 +0700
@@ -135,10 +135,11 @@
 	return rela;
 }
 
-int build_elf_rel_info(const char *buf, off_t len, struct mem_ehdr *ehdr)
+int build_elf_rel_info(const char *buf, off_t len, struct mem_ehdr *ehdr,
+				uint32_t flags)
 {
 	int result;
-	result = build_elf_info(buf, len, ehdr);
+	result = build_elf_info(buf, len, ehdr, flags);
 	if (result < 0) {
 		return result;
 	}
@@ -155,7 +156,7 @@
 		if (probe_debug) {
 			fprintf(stderr, "No ELF section headers\n");
 		}
-		return -1; 
+		return -1;
 	}
 	if (!machine_verify_elf_rel(ehdr)) {
 		/* It does not meant the native architecture constraints */
@@ -251,7 +252,7 @@
 
 	/* Allocate where we will put the relocated object */
 	buf = xmalloc(bufsz);
-	buf_addr = add_buffer(info, buf, bufsz, bufsz + bss_pad + bsssz, 
+	buf_addr = add_buffer(info, buf, bufsz, bufsz + bss_pad + bsssz,
 		buf_align, min, max, end);
 	ehdr->rel_addr = buf_addr;
 	ehdr->rel_size = bufsz + bss_pad + bsssz;
@@ -269,7 +270,7 @@
 			unsigned long off;
 			/* Adjust the address */
 			data_addr = (data_addr + (align - 1)) & ~(align -1);
-			
+
 			/* Update the section */
 			off = data_addr - buf_addr;
 			memcpy(buf + off, shdr->sh_data, shdr->sh_size);
@@ -306,7 +307,7 @@
 			continue;
 		}
 		if ((shdr->sh_info > ehdr->e_shnum) ||
-			(shdr->sh_link > ehdr->e_shnum)) 
+			(shdr->sh_link > ehdr->e_shnum))
 		{
 			die("Invalid section number\n");
 		}
@@ -338,6 +339,7 @@
 			struct mem_rela rel;
 			struct mem_sym sym;
 			const void *location;
+			const char *name;
 			unsigned long address, value, sec_base;
 			if (shdr->sh_type == SHT_REL) {
 				rel = elf_rel(ehdr, ptr);
@@ -350,12 +352,20 @@
 
 			/* The final address of that location */
 			address = section->sh_addr + rel.r_offset;
-			
+
 			/* The relevant symbol */
 			sym = elf_sym(ehdr, symtab->sh_data + (rel.r_sym * elf_sym_size(ehdr)));
-#if 0
+
+			if (sym.st_name) {
+				name = strtab + sym.st_name;
+			}
+			else {
+				name = ehdr->e_shdr[ehdr->e_shstrndx].sh_data;
+				name += ehdr->e_shdr[sym.st_shndx].sh_name;
+			}
+#ifdef DEBUG
 			fprintf(stderr, "sym: %10s info: %02x other: %02x shndx: %lx value: %lx size: %lx\n",
-				strtab + sym.st_name, 
+				name,
 				sym.st_info,
 				sym.st_other,
 				sym.st_shndx,
@@ -364,33 +374,42 @@
 
 #endif
 			if (sym.st_shndx == STN_UNDEF) {
-				die("Undefined symbol: %s\n", 
-					strtab + sym.st_name);
+			/*
+			 * NOTE: ppc64 elf .ro shows up a  UNDEF section.
+			 * From Elf 1.2 Spec:
+			 * Relocation Entries: If the index is STN_UNDEF,
+			 * the undefined symbol index, the relocation uses 0
+			 * as the "symbol value".
+			 * So, is this really an error condition to flag die?
+			 */
+			/*
+				die("Undefined symbol: %s\n", name);
+			*/
+				continue;
 			}
 			sec_base = 0;
 			if (sym.st_shndx == SHN_COMMON) {
 				die("symbol: '%s' in common section\n",
-					strtab + sym.st_name);
+					name);
 			}
 			else if (sym.st_shndx == SHN_ABS) {
 				sec_base = 0;
 			}
 			else if (sym.st_shndx > ehdr->e_shnum) {
 				die("Invalid section: %d for symbol %s\n",
-					sym.st_shndx,
-					strtab + sym.st_name);
+					sym.st_shndx, name);
 			}
 			else {
 				sec_base = ehdr->e_shdr[sym.st_shndx].sh_addr;
 			}
-#if 0
+#ifdef DEBUG
 			fprintf(stderr, "sym: %s value: %lx addr: %lx\n",
-				strtab + sym.st_name, value, address);
+				name, value, address);
 #endif
 			value = sym.st_value;
 			value += sec_base;
 			value += rel.r_addend;
-			machine_apply_elf_rel(ehdr, rel.r_type, 
+			machine_apply_elf_rel(ehdr, rel.r_type,
 				(void *)location, address, value);
 		}
 	}
@@ -399,14 +418,14 @@
 	return result;
 }
 
-void elf_rel_build_load(struct kexec_info *info, struct mem_ehdr *ehdr, 
+void elf_rel_build_load(struct kexec_info *info, struct mem_ehdr *ehdr,
 	const char *buf, off_t len, unsigned long min, unsigned long max,
-	int end)
+	int end, uint32_t flags)
 {
 	int result;
 
 	/* Parse the Elf file */
-	result = build_elf_rel_info(purgatory, purgatory_size, ehdr);
+	result = build_elf_rel_info(buf, len, ehdr, flags);
 	if (result < 0) {
 		die("ELF rel parse failed\n");
 	}
@@ -439,7 +458,7 @@
 			/* Invalid strtab section number? */
 			continue;
 		}
-		strtab = ehdr->e_shdr[shdr->sh_link].sh_data;
+		strtab = (char *)ehdr->e_shdr[shdr->sh_link].sh_data;
 		/* Walk through the symbol table and find the symbol */
 		sym_size = elf_sym_size(ehdr);
 		sym_end = shdr->sh_data + shdr->sh_size;
@@ -452,8 +471,8 @@
 			if (strcmp(strtab + sym.st_name, name) != 0) {
 				continue;
 			}
-			if ((sym.st_shndx == STN_UNDEF) || 
-				(sym.st_shndx > ehdr->e_shnum)) 
+			if ((sym.st_shndx == STN_UNDEF) ||
+				(sym.st_shndx > ehdr->e_shnum))
 			{
 				die("Symbol: %s has Bad section index %d\n",
 					name, sym.st_shndx);
@@ -491,7 +510,7 @@
 
 	result = elf_rel_find_symbol(ehdr, name, &sym);
 	if (result < 0) {
-		die("Symbol: %s not found cannot set\n", 
+		die("Symbol: %s not found cannot set\n",
 			name);
 	}
 	if (sym.st_size != size) {
diff -Nur kexec-tools-1.101/kexec/kexec.h kexec-tools-1.101-geoff/kexec/kexec.h
--- kexec-tools-1.101/kexec/kexec.h	2005-01-13 19:03:00.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/kexec.h	2007-10-23 16:24:40.000000000 +0700
@@ -91,6 +91,8 @@
 } while(0)
 #endif
 
+extern unsigned long long mem_min, mem_max;
+
 struct kexec_segment {
 	const void *buf;
 	size_t bufsz;
@@ -110,14 +112,22 @@
 struct kexec_info {
 	struct kexec_segment *segment;
 	int nr_segments;
+	struct memory_range *memory_range;
+	int memory_ranges;
 	void *entry;
 	struct mem_ehdr rhdr;
+	unsigned long backup_start;
+	unsigned long kexec_flags;
+	unsigned long kern_vaddr_start;
+	unsigned long kern_paddr_start;
+	unsigned long kern_size;
 };
 
 void usage(void);
-int get_memory_ranges(struct memory_range **range, int *ranges);
-int valid_memory_range(unsigned long sstart, unsigned long send);
-int valid_memory_segment(struct kexec_segment *segment);
+int get_memory_ranges(struct memory_range **range, int *ranges,
+						unsigned long kexec_flags);
+int valid_memory_range(struct kexec_info *info,
+		       unsigned long sstart, unsigned long send);
 void print_segments(FILE *file, struct kexec_info *info);
 int sort_segments(struct kexec_info *info);
 unsigned long locate_hole(struct kexec_info *info,
@@ -152,7 +162,8 @@
 #define OPT_PANIC		'p'
 #define OPT_MEM_MIN             256
 #define OPT_MEM_MAX             257
-#define OPT_MAX			258
+#define OPT_REUSE_INITRD	258
+#define OPT_MAX			259
 #define KEXEC_OPTIONS \
 	{ "help",		0, 0, OPT_HELP }, \
 	{ "version",		0, 0, OPT_VERSION }, \
@@ -165,6 +176,7 @@
 	{ "load-panic",         0, 0, OPT_PANIC }, \
 	{ "mem-min",		1, 0, OPT_MEM_MIN }, \
 	{ "mem-max",		1, 0, OPT_MEM_MAX }, \
+	{ "reuseinitrd",	0, 0, OPT_REUSE_INITRD }, \
 
 #define KEXEC_OPT_STR "hvdfxluet:p"
 
@@ -172,6 +184,7 @@
 extern void *xmalloc(size_t size);
 extern void *xrealloc(void *ptr, size_t size);
 extern char *slurp_file(const char *filename, off_t *r_size);
+extern char *slurp_file_len(const char *filename, off_t size);
 extern char *slurp_decompress_file(const char *filename, off_t *r_size);
 extern void add_segment(struct kexec_info *info,
 	const void *buf, size_t bufsz, unsigned long base, size_t memsz);
@@ -188,7 +201,27 @@
 
 void arch_usage(void);
 int arch_process_options(int argc, char **argv);
-int arch_compat_trampoline(struct kexec_info *info, unsigned long *flags);
+int arch_compat_trampoline(struct kexec_info *info);
 void arch_update_purgatory(struct kexec_info *info);
+int is_crashkernel_mem_reserved(void);
+
+int kexec_iomem_for_each_line(char *match,
+			      int (*callback)(void *data,
+					      int nr,
+					      char *str,
+					      unsigned long base,
+					      unsigned long length),
+			      void *data);
+int parse_iomem_single(char *str, uint64_t *start, uint64_t *end);
+
+
+#define MAX_LINE	160
+
+#ifdef DEBUG
+#define dbgprintf(_args...) do {printf(_args);} while(0)
+#else
+static inline int __attribute__ ((format (printf, 1, 2)))
+	dbgprintf(const char *fmt, ...) {return 0;}
+#endif
 
 #endif /* KEXEC_H */
diff -Nur kexec-tools-1.101/kexec/kexec-iomem.c kexec-tools-1.101-geoff/kexec/kexec-iomem.c
--- kexec-tools-1.101/kexec/kexec-iomem.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/kexec/kexec-iomem.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,101 @@
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <limits.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include "kexec.h"
+#include "crashdump.h"
+
+/*
+ * kexec_iomem_for_each_line()
+ *
+ * Iterate over each line in /proc/iomem. If match is NULL or if the line
+ * matches with our match-pattern then call the callback if non-NULL.
+ * Return the number of lines matched.
+ */
+
+int kexec_iomem_for_each_line(char *match,
+			      int (*callback)(void *data,
+					      int nr,
+					      char *str,
+					      unsigned long base,
+					      unsigned long length),
+			      void *data)
+{
+	const char iomem[]= "/proc/iomem";
+	char line[MAX_LINE];
+	FILE *fp;
+	unsigned long long start, end, size;
+	char *str;
+	int consumed;
+	int count;
+	int nr = 0;
+
+	fp = fopen(iomem, "r");
+	if (!fp)
+		die("Cannot open /proc/iomem");
+
+	while(fgets(line, sizeof(line), fp) != 0) {
+		count = sscanf(line, "%Lx-%Lx : %n", &start, &end, &consumed);
+		if (count != 2)
+			continue;
+		str = line + consumed;
+		size = end - start + 1;
+		if (!match || memcmp(str, match, strlen(match)) == 0) {
+			if (callback
+			    && callback(data, nr, str, start, size) < 0) {
+				break;
+			}
+			nr++;
+		}
+	}
+
+	fclose(fp);
+
+	return nr;
+}
+
+static int kexec_iomem_single_callback(void *data, int nr,
+				       char *str,
+				       unsigned long base,
+				       unsigned long length)
+{
+	struct memory_range *range = data;
+
+	if (nr == 0) {
+		range->start = base;
+		range->end = base + length - 1;
+	}
+
+	return 0;
+}
+
+int parse_iomem_single(char *str, uint64_t *start, uint64_t *end)
+{
+	struct memory_range range;
+	int ret;
+
+	memset(&range, 0, sizeof(range));
+
+	ret = kexec_iomem_for_each_line(str, kexec_iomem_single_callback,
+					&range);
+
+	if (ret == 1) {
+		if (start)
+			*start = range.start;
+		if (end)
+			*end = range.end;
+
+		ret = 0;
+	}
+	else
+		ret = -1;
+
+	return ret;
+}
diff -Nur kexec-tools-1.101/kexec/kexec-sha256.h kexec-tools-1.101-geoff/kexec/kexec-sha256.h
--- kexec-tools-1.101/kexec/kexec-sha256.h	2004-12-22 00:35:01.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/kexec-sha256.h	2007-10-23 16:24:40.000000000 +0700
@@ -2,10 +2,10 @@
 #define KEXEC_SHA256_H
 
 struct sha256_region {
-	const void *start;
-	unsigned long len;
+	uint64_t start;
+	uint64_t len;
 };
 
-#define SHA256_REGIONS 8
+#define SHA256_REGIONS 16
 
 #endif /* KEXEC_SHA256_H */
diff -Nur kexec-tools-1.101/kexec/kexec-syscall.h kexec-tools-1.101-geoff/kexec/kexec-syscall.h
--- kexec-tools-1.101/kexec/kexec-syscall.h	2005-01-06 12:59:50.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/kexec-syscall.h	2007-10-23 16:24:40.000000000 +0700
@@ -25,6 +25,9 @@
 #ifdef __i386__
 #define __NR_kexec_load		283
 #endif
+#ifdef __sh__
+#define __NR_kexec_load		283
+#endif
 #ifdef __ia64__
 #define __NR_kexec_load		1268
 #endif
@@ -37,6 +40,12 @@
 #ifdef __x86_64__
 #define __NR_kexec_load		246
 #endif
+#ifdef __s390x__
+#define __NR_kexec_load		277
+#endif
+#ifdef __s390__
+#define __NR_kexec_load		277
+#endif
 #ifndef __NR_kexec_load
 #error Unknown processor architecture.  Needs a kexec_load syscall number.
 #endif
@@ -67,7 +76,8 @@
 #define KEXEC_ARCH_PPC     (20 << 16)
 #define KEXEC_ARCH_PPC64   (21 << 16)
 #define KEXEC_ARCH_IA_64   (50 << 16)
+#define KEXEC_ARCH_S390    (22 << 16)
 
-#define KEXEC_MAX_SEGMENTS 8
+#define KEXEC_MAX_SEGMENTS 16
 
 #endif /* KEXEC_SYSCALL_H */
diff -Nur kexec-tools-1.101/kexec/Makefile kexec-tools-1.101-geoff/kexec/Makefile
--- kexec-tools-1.101/kexec/Makefile	2004-12-22 01:36:39.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -7,26 +7,36 @@
 	$(MKDIR) -p $(@D)
 	$(BIN_TO_HEX) purgatory < $(PURGATORY) > $@
 
-KCFLAGS:= $(CFLAGS) -Ikexec/arch/$(ARCH)/include
+KCFLAGS:= $(CFLAGS) $(EXTRA_CFLAGS) -Ikexec/arch/$(ARCH)/include
 
 KEXEC_C_SRCS:= kexec/kexec.c 
 KEXEC_C_SRCS+= kexec/ifdown.c
 KEXEC_C_SRCS+= kexec/kexec-elf.c 
 KEXEC_C_SRCS+= kexec/kexec-elf-exec.c 
+KEXEC_C_SRCS+= kexec/kexec-elf-core.c
 KEXEC_C_SRCS+= kexec/kexec-elf-rel.c 
 KEXEC_C_SRCS+= kexec/kexec-elf-boot.c 
-KEXEC_C_SRCS+= $(PURGATORY_HEX_C)
+KEXEC_C_SRCS+= kexec/kexec-iomem.c
+KEXEC_C_SRCS+= kexec/crashdump.c
+KEXEC_C_SRCS+= kexec/crashdump-xen.c
+KEXEC_C_GENERATED_SRCS+= $(PURGATORY_HEX_C)
 KEXEC_S_SRCS:= 
+KEXEC_S_GENERATED_SRCS:=
 include kexec/arch/$(ARCH)/Makefile
 
-KEXEC_C_OBJS:= $(patsubst %.c, $(OBJDIR)/%.o, $(KEXEC_C_SRCS))
+KEXEC_C_OBJS:= $(patsubst %.c, $(OBJDIR)/%.o, $(KEXEC_C_SRCS) \
+	       $(KEXEC_C_GENERATED_SRCS))
 KEXEC_C_DEPS:= $(patsubst %.c, $(OBJDIR)/%.d, $(KEXEC_C_SRCS))
-KEXEC_S_OBJS:= $(patsubst %.S, $(OBJDIR)/%.o, $(KEXEC_S_SRCS))
+KEXEC_C_DUMMY_DEPS:= $(patsubst %.c, $(OBJDIR)/%.d, $(KEXEC_C_GENERATED_SRCS))
+KEXEC_S_OBJS:= $(patsubst %.S, $(OBJDIR)/%.o, $(KEXEC_S_SRCS) \
+	       $(KEXEC_S_GENERATED_SRCS))
 KEXEC_S_DEPS:= $(patsubst %.S, $(OBJDIR)/%.d, $(KEXEC_S_SRCS))
+KEXEC_S_DUMMY_DEPS:= $(patsubst %.c, $(OBJDIR)/%.d, $(KEXEC_S_GENERATED_SRCS))
 KEXEC_SRCS:= $(KEXEC_C_SRCS) $(KEXEC_S_SRCS)
 KEXEC_OBJS:= $(KEXEC_C_OBJS) $(KEXEC_S_OBJS)
 KEXEC_DEPS:= $(KEXEC_C_DEPS) $(KEXEC_S_DEPS)
 KEXEC:= $(SBINDIR)/kexec
+KEXEC_MANPAGE:= $(MANDIR)/man8/kexec.8
 
 include $(KEXEC_DEPS)
 
@@ -38,6 +48,18 @@
 	mkdir -p $(@D)
 	$(CC) $(KCFLAGS) -M $< | sed -e 's|$(patsubst %.d,%.o,$(@F))|$(patsubst %.d,%.o,$(@))|' > $@
 
+# This is needed to ensure that the rule below that depend
+# on each .c file having a .d file don't break
+$(KEXEC_C_DUMMY_DEPS): $(OBJDIR)/%.d: %.c
+	mkdir -p $(@D)
+	touch $@
+
+# This is needed to ensure that the rule below that depend
+# on each .S file having a .d file don't break
+$(KEXEC_S_DUMMY_DEPS): $(OBJDIR)/%.d: %.S
+	mkdir -p $(@D)
+	touch $@
+
 $(KEXEC_C_OBJS): $(OBJDIR)/%.o: %.c $(OBJDIR)/%.d
 	mkdir -p $(@D)
 	$(CC) $(KCFLAGS) -o $@ -c $<
@@ -48,8 +70,12 @@
 
 $(KEXEC): $(KEXEC_OBJS) $(UTIL_LIB)
 	mkdir -p $(@D)
-	$(CC) $(KCFLAGS) -o $@ $(KEXEC_OBJS) $(UTIL_LIB) $(LIBS)
+	$(CC) $(LDFLAGS) $(EXTRA_LDFLAGS) $(KCFLAGS) -o $@ \
+		$(KEXEC_OBJS) $(UTIL_LIB) $(LIBS)
 
+$(KEXEC_MANPAGE): kexec/kexec.8
+	 $(MKDIR) -p     $(MANDIR)/man8
+	cp kexec/kexec.8 $(KEXEC_MANPAGE)
 echo::
 	@echo "KEXEC_C_SRCS $(KEXEC_C_SRCS)"
 	@echo "KEXEC_C_DEPS $(KEXEC_C_DEPS)"
diff -Nur kexec-tools-1.101/kexec_test/Makefile kexec-tools-1.101-geoff/kexec_test/Makefile
--- kexec-tools-1.101/kexec_test/Makefile	2004-12-16 17:05:57.000000000 +0600
+++ kexec-tools-1.101-geoff/kexec_test/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -15,11 +15,11 @@
 
 $(KEXEC_TEST_S_DEPS): $(OBJDIR)/%.d: %.S
 	mkdir -p $(@D)
-	$(CC) -m32 $(CFLAGS) -M $< | sed -e 's|$(patsubst %.d,%.o,$(@F))|$(patsubst %.d,%.o,$(@))|' > $@
+	$(CC) -m32 $(CFLAGS) $(EXTRA_CFLAGS) -M $< | sed -e 's|$(patsubst %.d,%.o,$(@F))|$(patsubst %.d,%.o,$(@))|' > $@
 
 $(KEXEC_TEST_S_TEMPS): $(OBJDIR)/%.s: %.S 
 	mkdir -p $(@D)
-	$(CPP) $(CPPFLAGS) -DRELOC=$(RELOC) $< > $@
+	$(CPP) $(CPPFLAGS) $(EXTRA_CPPFLAGS) -DRELOC=$(RELOC) $< > $@
 
 $(KEXEC_TEST_S_OBJS): $(OBJDIR)/%.o: $(OBJDIR)/%.s 
 	mkdir -p $(@D)
diff -Nur kexec-tools-1.101/Makefile kexec-tools-1.101-geoff/Makefile
--- kexec-tools-1.101/Makefile	2005-02-18 18:26:09.000000000 +0600
+++ kexec-tools-1.101-geoff/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -1,8 +1,8 @@
 # Hey Emacs this is a -*- makefile-*-
 include Makefile.conf
-VERSION=1.101
-DATE=15 February 2005
-PACKAGE=kexec-tools
+VERSION=20070330-git
+DATE=30th March 2007
+PACKAGE=kexec-tools-testing
 
 pkgdatadir = $(datadir)/$(PACKAGE)
 pkglibdir = $(libdir)/$(PACKAGE)
@@ -13,9 +13,9 @@
 # Useful for building binary packages
 DESTDIR =
 
-CPPFLAGS:= -I./include -I./util_lib/include \
+EXTRA_CPPFLAGS:= -I./include -I./util_lib/include \
 	-DVERSION='"$(VERSION)"' -DRELEASE_DATE='"$(DATE)"' \
-	$(DEFS) $(EXTRA_CFLAGS)
+	-DPACKAGE='"$(PACKAGE)"' $(DEFS) $(EXTRA_CFLAGS)
 
 PREFIX:=$(OBJDIR)/build
 SBINDIR=$(PREFIX)/sbin
@@ -43,6 +43,7 @@
 PKGINCLUDEIR=$(INCLUDEDIR)/$(PACKAGE)
 
 MAN_PAGES:= kexec/kexec.8
+MAN_PAGES+= kdump/kdump.8
 BINARIES_i386:=  $(SBINDIR)/kexec $(PKGLIBDIR)/kexec_test
 BINARIES_x86_64:=$(SBINDIR)/kexec $(PKGLIBDIR)/kexec_test
 BINARIES:=$(SBINDIR)/kexec $(SBINDIR)/kdump $(BINARIES_$(ARCH)) 
@@ -53,8 +54,9 @@
 
 # cc-option
 # Usage: cflags-y += $(call cc-option, -march=winchip-c6, -march=i586)
-cc-option = $(shell if $(CC) $(CFLAGS) $(1) -S -o /dev/null -xc /dev/null \
-             > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi ;)
+cc-option = $(shell if $(CC) $(CFLAGS) $(EXTRA_CFLAGS) $(1) -S -o /dev/null \
+	     -xc /dev/null > /dev/null 2>&1; then echo "$(1)"; else \
+	     echo "$(2)"; fi ;)
 
 # Utility function library
 #
@@ -90,8 +92,8 @@
 include kexec_test/Makefile
 endif
 
-GENERATED_SRCS:= ./configure
-SPEC=$(OBJDIR)/$(PACKAGE)-$(VERSION).spec
+SPEC=$(PACKAGE).spec
+GENERATED_SRCS:= ./configure ./$(SPEC)
 TARBALL=$(OBJDIR)/$(PACKAGE)-$(VERSION).tar.gz
 SRCS:=$(shell $(FIND) \
 	./AUTHORS ./COPYING ./News ./TODO \
@@ -102,7 +104,6 @@
 	-type f -print )
 SRCS+=$(GENERATED_SRCS)
 PSRCS:=$(patsubst ./%,$(PACKAGE)-$(VERSION)/%,$(SRCS))
-PSRCS+=$(PACKAGE)-$(VERSION).spec
 
 Makefile.conf: Makefile.conf.in configure
 	/bin/sh ./configure
@@ -149,11 +150,15 @@
 	@$(RM) -f config.log config.status config.cache
 	@$(RM) -f $(TARBALL)
 
+distclean: dist-clean
+
 dist-clean: clean
 	@$(RM) -rf $(OBJDIR)
 	@$(FIND) . -type f -name '*~' -o -name '*.orig' | $(XARGS) $(RM) -f
 	@$(RM) -f Makefile.conf
 
+maintainerclean: maintainer-clean
+
 maintainer-clean: dist-clean
 	@$(RM) -f $(GENERATED_SRCS)
 
@@ -246,4 +251,5 @@
 		fi; \
 	done
 
-.PHONY: echo install all clean dist-clean maintainer-clean tarball rpm
+.PHONY: echo install all clean dist-clean distclean maintainer-clean 	\
+	maintainerclean tarball rpm
diff -Nur kexec-tools-1.101/patches/ppc64-32-bit-build.diff kexec-tools-1.101-geoff/patches/ppc64-32-bit-build.diff
--- kexec-tools-1.101/patches/ppc64-32-bit-build.diff	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/patches/ppc64-32-bit-build.diff	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,256 @@
+Enable building a 32 bit binary for ppc64 platforms.
+
+Based on
+http://cvs.fedora.redhat.com/viewcvs/rpms/kexec-tools/devel/kexec-tools-1.101-ppc-boots-ppc64.patch?rev=1.2&view=auto
+
+64 bit: OK
+32 bit: purgatory build fails
+
+From: David Woodhouse <dwmw2@infradead.org>
+Work-in-progress-by: Geoff Levand <geoffrey.levand@am.sony.com>
+---
+ kexec/arch/ppc64/crashdump-ppc64.h     |    4 ++--
+ kexec/arch/ppc64/kexec-elf-ppc64.c     |   26 +++++++++++++-------------
+ kexec/arch/ppc64/kexec-elf-rel-ppc64.c |    4 ++--
+ kexec/arch/ppc64/kexec-ppc64.c         |   20 ++++++++++----------
+ kexec/arch/ppc64/kexec-ppc64.h         |    2 +-
+ kexec/kexec-sha256.h                   |    4 ++--
+ purgatory/arch/ppc64/Makefile          |    2 ++
+ purgatory/purgatory.c                  |    2 ++
+ 8 files changed, 34 insertions(+), 30 deletions(-)
+
+--- a/kexec/arch/ppc64/crashdump-ppc64.h
++++ b/kexec/arch/ppc64/crashdump-ppc64.h
+@@ -23,8 +23,8 @@ void add_usable_mem_rgns(unsigned long l
+ #define _ALIGN_UP(addr,size)	(((addr)+((size)-1))&(~((size)-1)))
+ #define _ALIGN_DOWN(addr,size)	((addr)&(~((size)-1)))
+ 
+-extern unsigned long long crash_base;
+-extern unsigned long long crash_size;
++extern uint64_t crash_base;
++extern uint64_t crash_size;
+ extern unsigned int rtas_base;
+ extern unsigned int rtas_size;
+ 
+--- a/kexec/arch/ppc64/kexec-elf-ppc64.c
++++ b/kexec/arch/ppc64/kexec-elf-ppc64.c
+@@ -42,7 +42,7 @@
+ #define BOOTLOADER         "kexec"
+ #define BOOTLOADER_VERSION VERSION
+ 
+-unsigned long initrd_base, initrd_size;
++uint64_t initrd_base, initrd_size;
+ unsigned char reuse_initrd = 0;
+ const char *ramdisk;
+ 
+@@ -83,19 +83,19 @@ int elf_ppc64_load(int argc, char **argv
+ 	char *cmdline, *modified_cmdline;
+ 	const char *devicetreeblob;
+ 	int cmdline_len, modified_cmdline_len;
+-	unsigned long long max_addr, hole_addr;
++	uint64_t max_addr, hole_addr;
+ 	unsigned char *seg_buf = NULL;
+ 	off_t seg_size = 0;
+ 	struct mem_phdr *phdr;
+ 	size_t size;
+-	unsigned long long *rsvmap_ptr;
++	uint64_t *rsvmap_ptr;
+ 	struct bootblock *bb_ptr;
+ 	unsigned int nr_segments, i;
+ 	int result, opt;
+-	unsigned long my_kernel, my_dt_offset;
++	uint64_t my_kernel, my_dt_offset;
+ 	unsigned int my_panic_kernel;
+-	unsigned long my_stack, my_backup_start;
+-	unsigned long toc_addr;
++	uint64_t my_stack, my_backup_start;
++	uint64_t toc_addr;
+ 	unsigned int slave_code[256/sizeof (unsigned int)], master_entry;
+ 
+ #define OPT_APPEND     (OPT_ARCH_MAX+0)
+@@ -237,10 +237,10 @@ int elf_ppc64_load(int argc, char **argv
+ 		}
+ 		seg_buf = (unsigned char *)slurp_file(ramdisk, &seg_size);
+ 		add_buffer(info, seg_buf, seg_size, seg_size, 0, 0, max_addr, 1);
+-		hole_addr = (unsigned long long)
++		hole_addr = (uint64_t)
+ 			info->segment[info->nr_segments-1].mem;
+ 		initrd_base = hole_addr;
+-		initrd_size = (unsigned long long)
++		initrd_size = (uint64_t)
+ 			info->segment[info->nr_segments-1].memsz;
+ 	} /* ramdisk */
+ 
+@@ -270,25 +270,25 @@ int elf_ppc64_load(int argc, char **argv
+ 	 */
+ 	bb_ptr = (struct bootblock *)(
+ 		(unsigned char *)info->segment[(info->nr_segments)-1].buf);
+-	rsvmap_ptr = (unsigned long long *)(
++	rsvmap_ptr = (uint64_t *)(
+ 		(unsigned char *)info->segment[(info->nr_segments)-1].buf +
+ 		bb_ptr->off_mem_rsvmap);
+ 	while (*rsvmap_ptr || *(rsvmap_ptr+1))
+ 		rsvmap_ptr += 2;
+ 	rsvmap_ptr -= 2;
+-	*rsvmap_ptr = (unsigned long long)(
++	*rsvmap_ptr = (uint64_t)(
+ 		info->segment[(info->nr_segments)-1].mem);
+ 	rsvmap_ptr++;
+-	*rsvmap_ptr = (unsigned long long)bb_ptr->totalsize;
++	*rsvmap_ptr = (uint64_t)bb_ptr->totalsize;
+ 
+ 	nr_segments = info->nr_segments;
+ 
+ 	/* Set kernel */
+-	my_kernel = (unsigned long )info->segment[0].mem;
++	my_kernel = (uint64_t)info->segment[0].mem;
+ 	elf_rel_set_symbol(&info->rhdr, "kernel", &my_kernel, sizeof(my_kernel));
+ 
+ 	/* Set dt_offset */
+-	my_dt_offset = (unsigned long )info->segment[nr_segments-1].mem;
++	my_dt_offset = (uint64_t)info->segment[nr_segments-1].mem;
+ 	elf_rel_set_symbol(&info->rhdr, "dt_offset", &my_dt_offset,
+ 				sizeof(my_dt_offset));
+ 
+--- a/kexec/arch/ppc64/kexec-elf-rel-ppc64.c
++++ b/kexec/arch/ppc64/kexec-elf-rel-ppc64.c
+@@ -101,10 +101,10 @@ void machine_apply_elf_rel(struct mem_eh
+ 		break;
+ 
+ 	case R_PPC64_ADDR16_HIGHEST:
+-		*(uint16_t *)location = ((value>>48)  & 0xffff);
++		*(uint16_t *)location = (((uint64_t)value>>48)  & 0xffff);
+ 		break;
+ 	case R_PPC64_ADDR16_HIGHER:
+-		*(uint16_t *)location = ((value>>32)  & 0xffff);
++		*(uint16_t *)location = (((uint64_t)value>>32)  & 0xffff);
+ 		break;
+ 
+ 	default:
+--- a/kexec/arch/ppc64/kexec-ppc64.c
++++ b/kexec/arch/ppc64/kexec-ppc64.c
+@@ -41,7 +41,7 @@ static struct memory_range *base_memory_
+ static unsigned long long rmo_top;
+ unsigned long long memory_max = 0;
+ static int nr_memory_ranges, nr_exclude_ranges;
+-unsigned long long crash_base, crash_size;
++uint64_t crash_base, crash_size;
+ unsigned int rtas_base, rtas_size;
+ int max_memory_ranges;
+ 
+@@ -203,10 +203,10 @@ static int get_base_ranges(void)
+ 				break;
+ 			}
+ 			base_memory_range[local_memory_ranges].start =
+-				((unsigned long long *)buf)[0];
++				((uint64_t *)buf)[0];
+ 			base_memory_range[local_memory_ranges].end  =
+ 				base_memory_range[local_memory_ranges].start +
+-				((unsigned long long *)buf)[1];
++				((uint64_t *)buf)[1];
+ 			base_memory_range[local_memory_ranges].type = RANGE_RAM;
+ 			local_memory_ranges++;
+ 			dbgprintf("%016llx-%016llx : %x\n",
+@@ -231,7 +231,7 @@ static int get_base_ranges(void)
+ static int sort_ranges(void)
+ {
+ 	int i, j;
+-	unsigned long long tstart, tend;
++	uint64_t tstart, tend;
+ 	for (i = 0; i < nr_exclude_ranges - 1; i++) {
+ 		for (j = 0; j < nr_exclude_ranges - i - 1; j++) {
+ 			if (exclude_range[j].start > exclude_range[j+1].start) {
+@@ -292,7 +292,7 @@ static int get_devtree_details(unsigned 
+ 				perror(fname);
+ 				goto error_opencdir;
+ 			}
+-			if (fread(&kernel_end, sizeof(unsigned long), 1, file) != 1) {
++			if (fread(&kernel_end, sizeof(uint64_t), 1, file) != 1) {
+ 				perror(fname);
+ 				goto error_openfile;
+ 			}
+@@ -312,7 +312,7 @@ static int get_devtree_details(unsigned 
+ 					perror(fname);
+ 					goto error_opencdir;
+ 				}
+-				if (fread(&crash_base, sizeof(unsigned long), 1,
++				if (fread(&crash_base, sizeof(uint64_t), 1,
+ 						file) != 1) {
+ 					perror(fname);
+ 					goto error_openfile;
+@@ -327,7 +327,7 @@ static int get_devtree_details(unsigned 
+ 					perror(fname);
+ 					goto error_opencdir;
+ 				}
+-				if (fread(&crash_size, sizeof(unsigned long), 1,
++				if (fread(&crash_size, sizeof(uint64_t), 1,
+ 						file) != 1) {
+ 					perror(fname);
+ 					goto error_openfile;
+@@ -356,7 +356,7 @@ static int get_devtree_details(unsigned 
+ 				perror(fname);
+ 				goto error_opendir;
+ 			}
+-			if (fread(&htab_base, sizeof(unsigned long), 1, file) != 1) {
++			if (fread(&htab_base, sizeof(uint64_t), 1, file) != 1) {
+ 				perror(fname);
+ 				goto error_openfile;
+ 			}
+@@ -368,7 +368,7 @@ static int get_devtree_details(unsigned 
+ 				perror(fname);
+ 				goto error_opencdir;
+ 			}
+-			if (fread(&htab_size, sizeof(unsigned long), 1, file) != 1) {
++			if (fread(&htab_size, sizeof(uint64_t), 1, file) != 1) {
+ 				perror(fname);
+ 				goto error_openfile;
+ 			}
+@@ -487,7 +487,7 @@ static int get_devtree_details(unsigned 
+ 				perror(fname);
+ 				goto error_opendir;
+ 			}
+-			if (fread(&tce_base, sizeof(unsigned long), 1, file) != 1) {
++			if (fread(&tce_base, sizeof(uint64_t), 1, file) != 1) {
+ 				perror(fname);
+ 				goto error_openfile;
+ 				return -1;
+--- a/kexec/arch/ppc64/kexec-ppc64.h
++++ b/kexec/arch/ppc64/kexec-ppc64.h
+@@ -14,7 +14,7 @@ int elf_ppc64_load(int argc, char **argv
+ void elf_ppc64_usage(void);
+ void reserve(unsigned long long where, unsigned long long length);
+ 
+-extern unsigned long initrd_base, initrd_size;
++extern uint64_t initrd_base, initrd_size;
+ extern int max_memory_ranges;
+ extern unsigned char reuse_initrd;
+ 
+--- a/kexec/kexec-sha256.h
++++ b/kexec/kexec-sha256.h
+@@ -2,8 +2,8 @@
+ #define KEXEC_SHA256_H
+ 
+ struct sha256_region {
+-	const void *start;
+-	unsigned long len;
++	uint64_t start;
++	uint64_t len;
+ };
+ 
+ #define SHA256_REGIONS 16
+--- a/purgatory/arch/ppc64/Makefile
++++ b/purgatory/arch/ppc64/Makefile
+@@ -6,3 +6,5 @@ PURGATORY_S_SRCS+= purgatory/arch/ppc64/
+ PURGATORY_C_SRCS += purgatory/arch/ppc64/purgatory-ppc64.c
+ PURGATORY_C_SRCS += purgatory/arch/ppc64/console-ppc64.c
+ PURGATORY_C_SRCS += purgatory/arch/ppc64/crashdump_backup.c
++
++PCFLAGS += -m64 -mcall-aixdesc
+--- a/purgatory/purgatory.c
++++ b/purgatory/purgatory.c
+@@ -46,3 +46,5 @@ void purgatory(void)
+ 	verify_sha256_digest();
+ 	post_verification_setup_arch();
+ }
++
++#include "../util_lib/sha256.c"
diff -Nur kexec-tools-1.101/patches/ps3-load-legacy-kernel-hack.diff kexec-tools-1.101-geoff/patches/ps3-load-legacy-kernel-hack.diff
--- kexec-tools-1.101/patches/ps3-load-legacy-kernel-hack.diff	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/patches/ps3-load-legacy-kernel-hack.diff	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,187 @@
+Hack to load PS3 legacy kernels (2.6.16 and fc7 installer) with the 2.6.23
+mainline linux kernel.
+
+---
+ kexec/arch/ppc64/fs2dt.c           |   47 +++++++++++++++++++++++++++++++++++++
+ kexec/arch/ppc64/kexec-elf-ppc64.c |   44 ++++++++++++++++++++++++++++++++++
+ kexec/arch/ppc64/kexec-ppc64.c     |    5 +++
+ kexec/arch/ppc64/kexec-ppc64.h     |    2 +
+ 4 files changed, 98 insertions(+)
+
+--- a/kexec/arch/ppc64/fs2dt.c
++++ b/kexec/arch/ppc64/fs2dt.c
+@@ -262,6 +262,33 @@ static void putprops(char *fn, struct di
+ 			die("unrecoverable error: could not read \"%s\": %s\n",
+ 			    pathname, strerror(errno));
+ 
++		/* ps3 legacy - Add 'PS3PF' to compatible */
++
++		if (ps3_legacy && !strcmp(dp->d_name, "compatible")) {
++			static const char s[] = "PS3PF";
++			char *const tmp = (char *)dt + len;
++
++			memcpy(tmp, s, sizeof(s));
++			len += sizeof(s);
++			*dt_len = len;
++
++			fprintf(stdout, "ps3 legacy: Changed dt entry "
++				"/compatible: <%s> -> <%s %s>\n",
++				(char *)dt, (char *)dt, tmp);
++		}
++
++		/* ps3 legacy - force memory.reg to 224 MiB */
++
++		if (ps3_legacy && !strcmp(dp->d_name, "reg") && len == 16) {
++			uint64_t tmp = *((uint64_t *)dt + 1);
++
++			*((uint64_t *)dt + 1) = 0xe000000ULL;
++			fprintf(stdout, "ps3 legacy: Changed dt entry "
++				"/memory/reg: <%llx> -> <%llx>\n",
++				(unsigned long long)tmp,
++				*((unsigned long long *)dt + 1));
++		}
++
+ 		checkprop(fn, dt, len);
+ 
+ 		dt += (len + 3)/4;
+@@ -360,6 +387,26 @@ static void putnode(void)
+ 		reserve(initrd_base, initrd_size);
+ 	}
+ 
++	/* ps3 legacy - add entry linux,platform <801> */
++
++	if (ps3_legacy && !strcmp(basename,"/chosen/")) {
++		int len = 4;
++		static const uint32_t data = 0x801UL;
++
++		*dt++ = 3;
++		*dt++ = len;
++		*dt++ = propnum("linux,platform");
++
++		if ((len >= 8) && ((unsigned long)dt & 0x4))
++			dt++;
++
++		memcpy(dt,&data,len);
++		dt += (len + 3)/4;
++
++		fprintf(stdout, "ps3 legacy: Added dt entry "
++			"/chosen/linux,platform = <801>\n");
++	}
++
+ 	/* Add cmdline to the second kernel.  Check to see if the new
+ 	 * cmdline has a root=.  If not, use the old root= cmdline.  */
+ 	if (!strcmp(basename,"/chosen/")) {
+--- a/kexec/arch/ppc64/kexec-elf-ppc64.c
++++ b/kexec/arch/ppc64/kexec-elf-ppc64.c
+@@ -45,6 +45,7 @@
+ uint64_t initrd_base, initrd_size;
+ unsigned char reuse_initrd = 0;
+ const char *ramdisk;
++int ps3_legacy = -1; /* default to probe */
+ 
+ int create_flatten_tree(struct kexec_info *, unsigned char **, unsigned long *,
+ 			char *);
+@@ -76,6 +77,33 @@ void arch_reuse_initrd(void)
+ 	reuse_initrd = 1;
+ }
+ 
++/**
++ * ps3_legacy_probe - Probe kernel version.
++ */
++
++static int ps3_legacy_probe(const char *p, off_t len)
++{
++	static const char d1[] = "linux,platform";    /* legacy 2.6.16 */
++	static const char d2[] = "2.6.21-1.3194.fc7"; /* fedora 7 installer */
++	const char *const end = p + len - sizeof(d2);
++
++	while(p < end) {
++		if (p[0] == d1[0] && !memcmp(p, d1, sizeof(d1) - 1)) {
++			fprintf(stdout, "ps3 legacy: Legacy kernel found: "
++				"'%s'\n", d1);
++			break;
++		}
++		if (p[0] == d2[0] && !memcmp(p, d2, sizeof(d2) - 1)) {
++			fprintf(stdout, "ps3 legacy: Legacy kernel found: "
++				"'%s'\n", d2);
++			break;
++		}
++		p++;
++	}
++
++	return (p != end);
++}
++
+ int elf_ppc64_load(int argc, char **argv, const char *buf, off_t len,
+ 			struct kexec_info *info)
+ {
+@@ -102,6 +130,8 @@ int elf_ppc64_load(int argc, char **argv
+ #define OPT_RAMDISK     (OPT_ARCH_MAX+1)
+ #define OPT_DEVICETREEBLOB     (OPT_ARCH_MAX+2)
+ #define OPT_ARGS_IGNORE		(OPT_ARCH_MAX+3)
++#define OPT_PS3_LEGACY (OPT_ARCH_MAX+4)
++#define OPT_PS3_LEGACY_NO (OPT_ARCH_MAX+5)
+ 
+ 	static const struct option options[] = {
+ 		KEXEC_ARCH_OPTIONS
+@@ -111,6 +141,8 @@ int elf_ppc64_load(int argc, char **argv
+ 		{ "initrd",             1, NULL, OPT_RAMDISK },
+ 		{ "devicetreeblob",     1, NULL, OPT_DEVICETREEBLOB },
+ 		{ "args-linux",		0, NULL, OPT_ARGS_IGNORE },
++		{ "ps3-legacy",         0, NULL, OPT_PS3_LEGACY },
++		{ "ps3-no-legacy",      0, NULL, OPT_PS3_LEGACY_NO },
+ 		{ 0,                    0, NULL, 0 },
+ 	};
+ 
+@@ -146,9 +178,18 @@ int elf_ppc64_load(int argc, char **argv
+ 			break;
+ 		case OPT_ARGS_IGNORE:
+ 			break;
++		case OPT_PS3_LEGACY:
++			ps3_legacy = 1;
++			break;
++		case OPT_PS3_LEGACY_NO:
++			ps3_legacy = 0;
++			break;
+ 		}
+ 	}
+ 
++	if (ps3_legacy == -1)
++		ps3_legacy = ps3_legacy_probe(buf, len);
++
+ 	cmdline_len = 0;
+ 	if (cmdline)
+ 		cmdline_len = strlen(cmdline) + 1;
+@@ -158,6 +199,9 @@ int elf_ppc64_load(int argc, char **argv
+ 	if (ramdisk && reuse_initrd)
+ 		die("Can't specify --ramdisk or --initrd with --reuseinitrd\n");
+ 
++	if (ps3_legacy && devicetreeblob)
++		die("Can't specify --devicetreeblob with --ps3-legacy\n");
++
+ 	setup_memory_ranges(info->kexec_flags);
+ 
+ 	/* Need to append some command line parameters internally in case of
+--- a/kexec/arch/ppc64/kexec-ppc64.c
++++ b/kexec/arch/ppc64/kexec-ppc64.c
+@@ -650,6 +650,11 @@ void arch_usage(void)
+ 	fprintf(stderr, "     --initrd=<filename> same as --ramdisk.\n");
+ 	fprintf(stderr, "     --devicetreeblob=<filename> Specify device tree blob file.\n");
+ 	fprintf(stderr, "     --elf64-core-headers Prepare core headers in ELF64 format\n");
++	fprintf(stderr, "     --ps3-legacy    Make fixups needed to boot PS3 legacy kernels.\n");
++	fprintf(stderr, "                     The default is to probe the kernel type.\n");
++	fprintf(stderr, "     --ps3-no-legacy Do not make fixups needed to boot PS3 legacy\n");
++	fprintf(stderr, "                     kernels. The default is to probe the kernel\n");
++	fprintf(stderr, "                     type.\n");
+ }
+ 
+ struct arch_options_t arch_options = {
+--- a/kexec/arch/ppc64/kexec-ppc64.h
++++ b/kexec/arch/ppc64/kexec-ppc64.h
+@@ -41,4 +41,6 @@ typedef struct mem_rgns {
+ 
+ extern mem_rgns_t usablemem_rgns;
+ 
++extern int ps3_legacy;
++
+ #endif /* KEXEC_PPC64_H */
diff -Nur kexec-tools-1.101/patches/ps3-readme.diff kexec-tools-1.101-geoff/patches/ps3-readme.diff
--- kexec-tools-1.101/patches/ps3-readme.diff	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/patches/ps3-readme.diff	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,30 @@
+---
+ ps3.readme |   23 +++++++++++++++++++++++
+ 1 file changed, 23 insertions(+)
+
+--- /dev/null
++++ b/ps3.readme
+@@ -0,0 +1,23 @@
++ps3-kexec-tools readme
++
++Latest PS3 sources:
++
++  git://git.kernel.org/pub/scm/linux/kernel/git/geoff/ps3-kexec-tools.git
++
++The current sources can only support building kexec as a 64 bit binary.
++The unapplied patch ppc64-32-bit-build.diff (a rebase from David
++Woodhouse's kexec-tools-1.101-ppc-boots-ppc64.patch) is a WIP to build
++kexec as a 32 bit binary.
++
++I used the following to build kexec cross with the IBM SDK 3.0 toolchain:
++
++  export PATH=/opt/cell/toolchain/bin:$PATH
++  autoconf
++  ./configure CC=ppu-gcc CFLAGS='-g -O0 -DDEBUG' LD=ppu-ld AS=ppu-as OBJCOPY=ppu-objcopy AR=ppu-ar ARCH=ppc64 --without-zlib --host=powerpc64
++  make
++
++To run on ubuntu-7.04 I needed to install the 64 bit libc package:
++
++  sudo apt-get install libc6-ppc64
++
++-Geoff
diff -Nur kexec-tools-1.101/patches/series kexec-tools-1.101-geoff/patches/series
--- kexec-tools-1.101/patches/series	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/patches/series	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,5 @@
+# kernel.org:/pub/scm/linux/kernel/git/horms/kexec-tools-testing.git
+
+ps3-readme.diff
+ppc64-32-bit-build.diff
+ps3-load-legacy-kernel-hack.diff
diff -Nur kexec-tools-1.101/ps3.readme kexec-tools-1.101-geoff/ps3.readme
--- kexec-tools-1.101/ps3.readme	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/ps3.readme	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,23 @@
+ps3-kexec-tools readme
+
+Latest PS3 sources:
+
+  git://git.kernel.org/pub/scm/linux/kernel/git/geoff/ps3-kexec-tools.git
+
+The current sources can only support building kexec as a 64 bit binary.
+The unapplied patch ppc64-32-bit-build.diff (a rebase from David
+Woodhouse's kexec-tools-1.101-ppc-boots-ppc64.patch) is a WIP to build
+kexec as a 32 bit binary.
+
+I used the following to build kexec cross with the IBM SDK 3.0 toolchain:
+
+  export PATH=/opt/cell/toolchain/bin:$PATH
+  autoconf
+  ./configure CC=ppu-gcc CFLAGS='-g -O0 -DDEBUG' LD=ppu-ld AS=ppu-as OBJCOPY=ppu-objcopy AR=ppu-ar ARCH=ppc64 --without-zlib --host=powerpc64
+  make
+
+To run on ubuntu-7.04 I needed to install the 64 bit libc package:
+
+  sudo apt-get install libc6-ppc64
+
+-Geoff
diff -Nur kexec-tools-1.101/purgatory/arch/i386/crashdump_backup.c kexec-tools-1.101-geoff/purgatory/arch/i386/crashdump_backup.c
--- kexec-tools-1.101/purgatory/arch/i386/crashdump_backup.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/i386/crashdump_backup.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,44 @@
+/*
+ * kexec: Linux boots Linux
+ *
+ * Created by:  Vivek goyal (vgoyal@in.ibm.com)
+ * Copyright (C) IBM Corporation, 2005. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stdint.h>
+#include <string.h>
+#include "../../../kexec/arch/i386/crashdump-x86.h"
+
+/* Backup region start gets set after /proc/iomem has been parsed. */
+/* We reuse the same code for x86_64 also so changing backup_start to
+   unsigned long */
+unsigned long  backup_start = 0;
+
+/* Backup first 640K of memory to backup region as reserved by kexec.
+ * Assuming first 640K has to be present on i386 machines and no address
+ * validity checks have to be performed. */
+
+void crashdump_backup_memory(void)
+{
+	void *dest, *src;
+
+	src = (void *) BACKUP_SRC_START;
+
+	if (backup_start) {
+		dest = (void *)(backup_start);
+		memcpy(dest, src, BACKUP_SRC_SIZE);
+	}
+}
diff -Nur kexec-tools-1.101/purgatory/arch/i386/entry32-16-debug.S kexec-tools-1.101-geoff/purgatory/arch/i386/entry32-16-debug.S
--- kexec-tools-1.101/purgatory/arch/i386/entry32-16-debug.S	2004-12-21 05:11:43.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/i386/entry32-16-debug.S	2007-10-23 16:24:40.000000000 +0700
@@ -55,15 +55,15 @@
 	orl	%ecx, 0x14 + gdt	
 	
 	
-DEBUG('a')	
+DEBUG_CHAR('a')
 	/* Setup the classic BIOS interrupt table at 0x0 */
 	lidt	idtptr
 
-DEBUG('b')		
+DEBUG_CHAR('b')
 	/* Provide us with 16bit segments that we can use */
 	lgdt	gdt
 
-DEBUG('c')	
+DEBUG_CHAR('c')
 	/* Note we don't disable the a20 line, (this shouldn't be required)
 	 * The code to do it is in kexec_test and it is a real pain.
 	 * I will worry about that when I need it.
@@ -77,26 +77,26 @@
 	movl	%eax, %fs
 	movl	%eax, %gs
 
-DEBUG('d')
+DEBUG_CHAR('d')
 
 	/* switch to 16bit mode */
 	ljmp	$0x08, $1f - entry16_debug
 1:
 	.code16
-DEBUG('e')	
+DEBUG_CHAR('e')
 	/* Disable Paging and protected mode */
 	/* clear the PG & PE bits of CR0 */
 	movl	%cr0,%eax
 	andl	$~((1 << 31)|(1<<0)),%eax
 	movl	%eax,%cr0
 
-DEBUG('f')
+DEBUG_CHAR('f')
 	/* make intersegment jmp to flush the processor pipeline
 	 * and reload %cs:%eip (to clear upper 16 bits of %eip).
 	 */
 	ljmp	*(realptr - entry16_debug)
 3:
-DEBUG('g')
+DEBUG_CHAR('g')
 	/* we are in real mode now
 	 * set up the real mode segment registers : %ds, $ss, %es
 	 */
@@ -104,7 +104,7 @@
 	movw	%cs, %ax
 	movw	%ax, %ds
 
-DEBUG('h')
+DEBUG_CHAR('h')
 	/* Load the registers */
 	movl	eax - entry16_debug, %eax
 	movl	ebx - entry16_debug, %ebx
@@ -176,7 +176,7 @@
 	.text	
 entry16_debug_pre32:
 	.code16
-DEBUG('i')
+DEBUG_CHAR('i')
 	cli					# no interrupts allowed !
 	movb	$0x80, %al			# disable NMI for bootup
 						# sequence
@@ -186,7 +186,7 @@
 	
 entry16_debug_first32:
 	.code32
-DEBUG('j')
+DEBUG_CHAR('j')
 	.byte	0xb8	/* movl $0x10000, %eax */
 entry16_debug_old_first32:
 	.long 0x100000
diff -Nur kexec-tools-1.101/purgatory/arch/i386/include/arch/debug.h kexec-tools-1.101-geoff/purgatory/arch/i386/include/arch/debug.h
--- kexec-tools-1.101/purgatory/arch/i386/include/arch/debug.h	2004-12-21 05:03:17.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/i386/include/arch/debug.h	2007-10-23 16:24:40.000000000 +0700
@@ -311,6 +311,6 @@
 	TTYS0_TX_AL
 	
 
-#define DEBUG(x) TTYS0_TX_CHAR($x) ;  TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
+#define DEBUG_CHAR(x) TTYS0_TX_CHAR($x) ;  TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
 #define DEBUG_TX_HEX32(x) TTYS0_TX_HEX32(x); TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
 #define DEBUG_TX_HEX64(x) TTYS0_TX_HEX64(x); TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
diff -Nur kexec-tools-1.101/purgatory/arch/i386/linux-entry16.S kexec-tools-1.101-geoff/purgatory/arch/i386/linux-entry16.S
--- kexec-tools-1.101/purgatory/arch/i386/linux-entry16.S	2004-12-20 16:48:45.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/i386/linux-entry16.S	2007-10-23 16:24:40.000000000 +0700
@@ -127,10 +127,10 @@
 	TTYS0_TX_AL
 
 
-#define DEBUG(x) TTYS0_TX_CHAR($x) ;  TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
+#define DEBUG_CHAR(x) TTYS0_TX_CHAR($x) ;  TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
 #define DEBUG_TX_HEX32(x) TTYS0_TX_HEX32(x) ;  TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
 #else
-#define DEBUG(x)
+#define DEBUG_CHAR(x)
 #define DEBUG_TX_HEX32(x)
 #endif
 	
@@ -142,15 +142,15 @@
 entry16:
 	.code32
 
-DEBUG('a')	
+DEBUG_CHAR('a')
 	/* Setup the classic BIOS interrupt table at 0x0 */
 	lidt	idtptr
 
-DEBUG('b')		
+DEBUG_CHAR('b')
 	/* Provide us with 16bit segments that we can use */
 	lgdt	gdt
 
-DEBUG('c')	
+DEBUG_CHAR('c')
 	/* Note we don't disable the a20 line, (this shouldn't be required)
 	 * The code to do it is in kexec_test and it is a real pain.
 	 * I will worry about that when I need it.
@@ -164,26 +164,26 @@
 	movl	%eax, %fs
 	movl	%eax, %gs
 
-DEBUG('d')
+DEBUG_CHAR('d')
 
 	/* switch to 16bit mode */
 	ljmp	$0x08, $1f - entry16
 1:
 	.code16
-DEBUG('e')	
+DEBUG_CHAR('e')
 	/* Disable Paging and protected mode */
 	/* clear the PG & PE bits of CR0 */
 	movl	%cr0,%eax
 	andl	$~((1 << 31)|(1<<0)),%eax
 	movl	%eax,%cr0
 
-DEBUG('f')
+DEBUG_CHAR('f')
 	/* make intersegment jmp to flush the processor pipeline
 	 * and reload %cs:%eip (to clear upper 16 bits of %eip).
 	 */
 	ljmp	*(realptr - entry16)
 3:
-DEBUG('g')
+DEBUG_CHAR('g')
 	/* we are in real mode now
 	 * set up the real mode segment registers : %ds, $ss, %es
 	 */
@@ -191,7 +191,7 @@
 	movw	%cs, %ax
 	movw	%ax, %ds
 
-DEBUG('h')
+DEBUG_CHAR('h')
 	/* Load the registers */
 	movl	eax - entry16, %eax
 	movl	ebx - entry16, %ebx
@@ -386,10 +386,10 @@
 	TTYS0_TX_AL
 
 
-#define DEBUG(x) TTYS0_TX_CHAR($x) ;  TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
+#define DEBUG_CHAR(x) TTYS0_TX_CHAR($x) ;  TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
 #define DEBUG_TX_HEX32(x) TTYS0_TX_HEX32(x) ;  TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
 #else
-#define DEBUG(x)
+#define DEBUG_CHAR(x)
 #define DEBUG_TX_HEX32(x)
 #endif
 
@@ -403,7 +403,7 @@
 _reloc = .
 	.balign 16
 	.code32
-DEBUG('a')
+DEBUG_CHAR('a')
 	/* Compute where I am running at */
 	call	1f
 1:	popl	%ebx
@@ -412,13 +412,13 @@
 	/* Remember where I am running at */
 	movl	%ebx, location - _reloc(%ebx)
 	
-DEBUG('b')
+DEBUG_CHAR('b')
 	/* Fixup my real mode segment */
 	movl	%ebx, %eax
 	shrl	$4, %eax
 	movw	%ax, 2 + realptr - _reloc(%ebx)
 
-DEBUG('c')
+DEBUG_CHAR('c')
 	/* Fixup the gdt */
 	movl	%ebx, %eax
 	shll	$16, %eax
@@ -440,7 +440,7 @@
 
 
 	
-DEBUG('d')
+DEBUG_CHAR('d')
 	/* Setup the classic BIOS interrupt table at 0x0 */
 	lidt	idtptr - _reloc(%ebx)
 	
@@ -465,20 +465,20 @@
 	ljmp	$0x08, $2f - _reloc
 2:
 	.code16
-DEBUG('e')
+DEBUG_CHAR('e')
 	/* Disable Paging and protected mode */
 	/* clear the PG & PE bits of CR0 */
 	movl	%cr0,%eax
 	andl	$~((1 << 31)|(1<<0)),%eax
 	movl	%eax,%cr0
 
-DEBUG('f')
+DEBUG_CHAR('f')
 	/* make intersegment jmp to flush the processor pipeline
 	 * and reload %cs:%eip (to clear upper 16 bits of %eip).
 	 */
 	ljmp	*(realptr - _reloc)
 3:
-DEBUG('g')
+DEBUG_CHAR('g')
 	/* we are in real mode now
 	 * set up the real mode segment registers : %ds, $ss, %es
 	 */
@@ -486,7 +486,7 @@
 	movw	%cs, %ax
 	movw	%ax, %ds
 
-DEBUG('h')
+DEBUG_CHAR('h')
 	/* Load the registers */
 	movl	eax - _reloc, %eax
 	movl	ebx - _reloc, %ebx
@@ -600,7 +600,7 @@
 		
 setup16_debug_kernel_pre_protected:
 	.code16
-	DEBUG('i')
+	DEBUG_CHAR('i')
 	cli					# no interrupts allowed !
 	movb	$0x80, %al			# disable NMI for bootup
 						# sequence
@@ -611,7 +611,7 @@
 	.byte	0xbf	/* movl $0x12345678, %edi */
 location:
 	.long	0x12345678
-	DEBUG('j')
+	DEBUG_CHAR('j')
 	.byte	0xb8	/* movl $0x10000, %eax */
 setup16_debug_old_code32:
 	.long	0x10000
diff -Nur kexec-tools-1.101/purgatory/arch/i386/Makefile kexec-tools-1.101-geoff/purgatory/arch/i386/Makefile
--- kexec-tools-1.101/purgatory/arch/i386/Makefile	2005-01-11 07:07:58.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/i386/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -12,3 +12,4 @@
 PURGATORY_C_SRCS+= purgatory/arch/i386/console-x86.c
 PURGATORY_C_SRCS+= purgatory/arch/i386/vga.c
 PURGATORY_C_SRCS+= purgatory/arch/i386/pic.c
+PURGATORY_C_SRCS+= purgatory/arch/i386/crashdump_backup.c
diff -Nur kexec-tools-1.101/purgatory/arch/i386/purgatory-x86.c kexec-tools-1.101-geoff/purgatory/arch/i386/purgatory-x86.c
--- kexec-tools-1.101/purgatory/arch/i386/purgatory-x86.c	2004-12-21 22:29:48.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/i386/purgatory-x86.c	2007-10-23 16:24:40.000000000 +0700
@@ -30,6 +30,7 @@
 uint8_t reset_vga = 0;
 uint8_t legacy_timer = 0;
 uint8_t legacy_pic   = 0;
+uint8_t panic_kernel = 0;
 
 void setup_arch(void)
 {
@@ -38,3 +39,9 @@
 	if (legacy_pic)   x86_setup_legacy_pic();
 	/* if (legacy_timer) x86_setup_legacy_timer(); */
 }
+
+/* This function can be used to execute after the SHA256 verification. */
+void post_verification_setup_arch(void)
+{
+	if (panic_kernel)   crashdump_backup_memory();
+}
diff -Nur kexec-tools-1.101/purgatory/arch/i386/purgatory-x86.h kexec-tools-1.101-geoff/purgatory/arch/i386/purgatory-x86.h
--- kexec-tools-1.101/purgatory/arch/i386/purgatory-x86.h	2004-12-20 18:22:26.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/i386/purgatory-x86.h	2007-10-23 16:24:40.000000000 +0700
@@ -4,5 +4,6 @@
 void x86_reset_vga(void);
 void x86_setup_legacy_pic(void);
 void x86_setup_legacy_timer(void);
+void crashdump_backup_memory(void);
 
 #endif /* PURGATORY_X86_H */
diff -Nur kexec-tools-1.101/purgatory/arch/ia64/console-ia64.c kexec-tools-1.101-geoff/purgatory/arch/ia64/console-ia64.c
--- kexec-tools-1.101/purgatory/arch/ia64/console-ia64.c	2004-12-21 04:41:26.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/ia64/console-ia64.c	2007-10-23 16:24:40.000000000 +0700
@@ -1,5 +1,47 @@
 #include <purgatory.h>
+#include "io.h"
+
+#define VGABASE         UNCACHED(0xb8000)
+
+/* code based on i386 console code
+ * TODO add serial support
+ */
+#define MAX_YPOS        25
+#define MAX_XPOS        80
+
+unsigned long current_ypos = 1, current_xpos = 0;
+
+static void putchar_vga(int ch)
+{
+	int  i, k, j;
+
+	if (current_ypos >= MAX_YPOS) {
+		/* scroll 1 line up */
+		for (k = 1, j = 0; k < MAX_YPOS; k++, j++) {
+			for (i = 0; i < MAX_XPOS; i++) {
+				writew(readw(VGABASE + 2*(MAX_XPOS*k + i)),
+						VGABASE + 2*(MAX_XPOS*j + i));
+			}
+		}
+		for (i = 0; i < MAX_XPOS; i++)
+			writew(0x720, VGABASE + 2*(MAX_XPOS*j + i));
+		current_ypos = MAX_YPOS-1;
+	}
+	if (ch == '\n') {
+		current_xpos = 0;
+		current_ypos++;
+	} else if (ch != '\r')  {
+		writew(((0x7 << 8) | (unsigned short) ch),
+				VGABASE + 2*(MAX_XPOS*current_ypos +
+					current_xpos++));
+		if (current_xpos >= MAX_XPOS) {
+			current_xpos = 0;
+			current_ypos++;
+		}
+	}
+}
+
 void putchar(int ch)
 {
-	/* Nothing for now */
+	putchar_vga(ch);
 }
diff -Nur kexec-tools-1.101/purgatory/arch/ia64/entry.S kexec-tools-1.101-geoff/purgatory/arch/ia64/entry.S
--- kexec-tools-1.101/purgatory/arch/ia64/entry.S	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/ia64/entry.S	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,73 @@
+/*
+ * purgatory:  setup code
+ *
+ * Copyright (C) 2005-2006  Zou Nan hai (nanhai.zou@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#define DECLARE_DATA8(name)	\
+.global name;	\
+.size	name, 8;	\
+name:	data8 0x0
+
+.global __dummy_efi_function
+.align  32
+.proc  __dummy_efi_function
+__dummy_efi_function:
+	mov r8=r0;;
+	br.ret.sptk.many rp;;
+.global __dummy_efi_function_end
+__dummy_efi_function_end:
+.endp 	__dummy_efi_function
+
+.global purgatory_start
+.align  32
+.proc   purgatory_start
+purgatory_start:
+	movl r2=__gp_value;;
+	ld8 gp=[r2];;
+	br.call.sptk.many b0=purgatory
+	;;
+	alloc r2 = ar.pfs, 0, 0, 2, 0
+	;;
+	mov out0=r28
+	movl out1=__vmcode_base;
+	br.call.sptk.many b0=ia64_env_setup
+	movl r10=__kernel_entry;;
+	ld8 r14=[r10];;
+	movl r10=__boot_param_base;;
+	ld8 r28=[r10];;
+	mov b6=r14;;
+	mov ar.lc=r0
+	mov ar.ec=r0
+	cover;;
+	invala;;
+	br.call.sptk.many  b0=b6
+.endp   purgatory_start
+
+DECLARE_DATA8(__kernel_entry)
+DECLARE_DATA8(__vmcode_base)
+DECLARE_DATA8(__vmcode_size)
+DECLARE_DATA8(__ramdisk_base)
+DECLARE_DATA8(__ramdisk_size)
+DECLARE_DATA8(__command_line)
+DECLARE_DATA8(__command_line_len)
+DECLARE_DATA8(__efi_memmap_base)
+DECLARE_DATA8(__efi_memmap_size)
+DECLARE_DATA8(__boot_param_base)
+DECLARE_DATA8(__loaded_segments)
+DECLARE_DATA8(__loaded_segments_num)
+
+DECLARE_DATA8(__gp_value)
+DECLARE_DATA8(__noio)
diff -Nur kexec-tools-1.101/purgatory/arch/ia64/io.h kexec-tools-1.101-geoff/purgatory/arch/ia64/io.h
--- kexec-tools-1.101/purgatory/arch/ia64/io.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/ia64/io.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,108 @@
+#ifndef IO_H
+#define IO_H
+#define UNCACHED(x) (void *)((x)|(1UL<<63))
+#define MF()	asm volatile ("mf.a" ::: "memory")
+#define IO_SPACE_ENCODING(p)     ((((p) >> 2) << 12) | (p & 0xfff))
+extern long __noio;
+static inline void *io_addr (unsigned long port)
+{
+        unsigned long offset;
+	unsigned long io_base;
+	asm volatile ("mov %0=ar.k0":"=r"(io_base));
+	offset = IO_SPACE_ENCODING(port);
+        return UNCACHED(io_base | offset);
+}
+
+static inline unsigned int inb (unsigned long port)
+{
+        volatile unsigned char *addr = io_addr(port);
+	unsigned char ret = 0;
+	if (!__noio) {
+		ret = *addr;
+		MF();
+	}
+        return ret;
+}
+
+static inline unsigned int inw (unsigned long port)
+{
+        volatile unsigned short *addr = io_addr(port);
+	unsigned short ret = 0;
+
+	if (!__noio) {
+		ret = *addr;
+		MF();
+	}
+        return ret;
+}
+
+static inline unsigned int inl (unsigned long port)
+{
+	volatile unsigned int *addr = io_addr(port);
+	unsigned int ret ;
+	if (!__noio) {
+		ret = *addr;
+		MF();
+	}
+        return ret;
+}
+
+static inline void outb (unsigned char val, unsigned long port)
+{
+        volatile unsigned char *addr = io_addr(port);
+
+	if (!__noio) {
+		*addr = val;
+		MF();
+	}
+}
+
+static inline void outw (unsigned short val, unsigned long port)
+{
+        volatile unsigned short *addr = io_addr(port);
+
+	if (!__noio) {
+		*addr = val;
+		MF();
+	}
+}
+
+static inline void outl (unsigned int val, unsigned long port)
+{
+        volatile unsigned int *addr = io_addr(port);
+
+	if (!__noio) {
+		*addr = val;
+		MF();
+	}
+}
+
+static inline unsigned char readb(const volatile void  *addr)
+{
+	return __noio ? 0 :*(volatile unsigned char *) addr;
+}
+static inline unsigned short readw(const volatile void  *addr)
+{
+	return __noio ? 0 :*(volatile unsigned short *) addr;
+}
+static inline unsigned int readl(const volatile void  *addr)
+{
+	return __noio ? 0 :*(volatile unsigned int *) addr;
+}
+
+static inline void writeb(unsigned char b, volatile void  *addr)
+{
+	if (!__noio)
+		*(volatile unsigned char *) addr = b;
+}
+static inline void writew(unsigned short b, volatile void  *addr)
+{
+	if (!__noio)
+		*(volatile unsigned short *) addr = b;
+}
+static inline void writel(unsigned int b, volatile void  *addr)
+{
+	if (!__noio)
+		*(volatile unsigned int *) addr = b;
+}
+#endif
diff -Nur kexec-tools-1.101/purgatory/arch/ia64/Makefile kexec-tools-1.101-geoff/purgatory/arch/ia64/Makefile
--- kexec-tools-1.101/purgatory/arch/ia64/Makefile	2004-12-21 04:44:22.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/ia64/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -1,9 +1,9 @@
 #
 # Purgatory ia64
 #
-
-PURGATORY_S_SRCS+=
+PCFLAGS		+= -ffixed-r28
+PURGATORY_S_SRCS+= purgatory/arch/ia64/entry.S
 PURGATORY_C_SRCS+= purgatory/arch/ia64/purgatory-ia64.c
 PURGATORY_C_SRCS+= purgatory/arch/ia64/console-ia64.c
-PURGATORY_C_SRCS+=
+PURGATORY_C_SRCS+= purgatory/arch/ia64/vga.c
 
diff -Nur kexec-tools-1.101/purgatory/arch/ia64/purgatory-ia64.c kexec-tools-1.101-geoff/purgatory/arch/ia64/purgatory-ia64.c
--- kexec-tools-1.101/purgatory/arch/ia64/purgatory-ia64.c	2004-12-21 04:45:21.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/ia64/purgatory-ia64.c	2007-10-23 16:24:40.000000000 +0700
@@ -1,7 +1,291 @@
+/*
+ * purgatory:  setup code
+ *
+ * Copyright (C) 2005-2006  Zou Nan hai (nanhai.zou@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 #include <purgatory.h>
+#include <stdint.h>
+#include <string.h>
 #include "purgatory-ia64.h"
 
-void setup_arch(void)
+#define PAGE_OFFSET             0xe000000000000000UL
+
+#define EFI_PAGE_SHIFT          12
+#define EFI_PAGE_SIZE		(1UL<<EFI_PAGE_SHIFT)
+#define EFI_PAGE_ALIGN(x)	((x + EFI_PAGE_SIZE - 1)&~(EFI_PAGE_SIZE-1))
+/* Memory types: */
+#define EFI_RESERVED_TYPE                0
+#define EFI_LOADER_CODE                  1
+#define EFI_LOADER_DATA                  2
+#define EFI_BOOT_SERVICES_CODE           3
+#define EFI_BOOT_SERVICES_DATA           4
+#define EFI_RUNTIME_SERVICES_CODE        5
+#define EFI_RUNTIME_SERVICES_DATA        6
+#define EFI_CONVENTIONAL_MEMORY          7
+#define EFI_UNUSABLE_MEMORY              8
+#define EFI_ACPI_RECLAIM_MEMORY          9
+#define EFI_ACPI_MEMORY_NVS             10
+#define EFI_MEMORY_MAPPED_IO            11
+#define EFI_MEMORY_MAPPED_IO_PORT_SPACE 12
+#define EFI_PAL_CODE                    13
+#define EFI_MAX_MEMORY_TYPE             14
+
+typedef struct {
+        uint64_t signature;
+        uint32_t revision;
+        uint32_t headersize;
+        uint32_t crc32;
+        uint32_t reserved;
+} efi_table_hdr_t;
+
+typedef struct {
+        efi_table_hdr_t hdr;
+        unsigned long get_time;
+        unsigned long set_time;
+        unsigned long get_wakeup_time;
+        unsigned long set_wakeup_time;
+        unsigned long set_virtual_address_map;
+        unsigned long convert_pointer;
+        unsigned long get_variable;
+        unsigned long get_next_variable;
+        unsigned long set_variable;
+        unsigned long get_next_high_mono_count;
+        unsigned long reset_system;
+} efi_runtime_services_t;
+
+typedef struct {
+        efi_table_hdr_t hdr;
+        unsigned long fw_vendor;          /* physical addr of
+					     CHAR16 vendor string */
+        uint32_t fw_revision;
+        unsigned long con_in_handle;
+        unsigned long con_in;
+        unsigned long con_out_handle;
+        unsigned long con_out;
+        unsigned long stderr_handle;
+        unsigned long stderr;
+        unsigned long runtime;
+        unsigned long boottime;
+        unsigned long nr_tables;
+        unsigned long tables;
+} efi_system_table_t;
+
+struct ia64_boot_param {
+        uint64_t command_line;             /* physical address of
+					      command linearguments */
+        uint64_t efi_systab;               /* physical address of
+					      EFI system table */
+        uint64_t efi_memmap;               /* physical address of
+					      EFI memory map */
+        uint64_t efi_memmap_size;          /* size of EFI memory map */
+        uint64_t efi_memdesc_size;         /* size of an EFI memory map
+					      descriptor */
+        uint32_t efi_memdesc_version;      /* memory descriptor version */
+        struct {
+                uint16_t num_cols;         /* number of columns on console
+					      output device */
+                uint16_t num_rows;         /* number of rows on console
+					      output device */
+                uint16_t orig_x;           /* cursor's x position */
+                uint16_t orig_y;           /* cursor's y position */
+        } console_info;
+        uint64_t fpswa;                    /* physical address of
+					      the fpswa interface */
+        uint64_t initrd_start;
+        uint64_t initrd_size;
+
+        uint64_t vmcode_start;
+        uint64_t vmcode_size;
+};
+
+typedef struct {
+        uint32_t type;
+        uint32_t pad;
+        uint64_t phys_addr;
+        uint64_t virt_addr;
+        uint64_t num_pages;
+        uint64_t attribute;
+} efi_memory_desc_t;
+
+struct loaded_segment {
+        unsigned long start;
+        unsigned long end;
+};
+
+struct kexec_boot_params {
+	uint64_t vmcode_base;
+	uint64_t vmcode_size;
+	uint64_t ramdisk_base;
+	uint64_t ramdisk_size;
+	uint64_t command_line;
+	uint64_t command_line_len;
+	uint64_t efi_memmap_base;
+	uint64_t efi_memmap_size;
+	uint64_t boot_param_base;
+	struct loaded_segment *loaded_segments;
+	unsigned long loaded_segments_num;
+};
+
+void
+setup_arch(void)
+{
+	reset_vga();
+}
+
+inline unsigned long PA(unsigned long addr)
+{
+	return addr - PAGE_OFFSET;
+}
+
+void
+patch_efi_memmap(struct kexec_boot_params *params,
+		struct ia64_boot_param *boot_param)
+{
+	void *dest = (void *)params->efi_memmap_base;
+	void *src  = (void *)boot_param->efi_memmap;
+	uint64_t orig_type;
+	efi_memory_desc_t *src_md, *dst_md;
+	void *src_end = src + boot_param->efi_memmap_size;
+	int i;
+	for (; src < src_end; src += boot_param->efi_memdesc_size,
+	     dest += boot_param->efi_memdesc_size) {
+		unsigned long mstart, mend;
+		src_md = src;
+		dst_md = dest;
+		if (src_md->num_pages == 0)
+			continue;
+		mstart = src_md->phys_addr;
+		mend = src_md->phys_addr +
+			(src_md->num_pages << EFI_PAGE_SHIFT);
+		*dst_md = *src_md;
+		if (src_md->type == EFI_LOADER_DATA)
+			dst_md->type = EFI_CONVENTIONAL_MEMORY;
+		/* segments are already sorted and aligned to 4K */
+		orig_type = dst_md->type;
+		for (i = 0; i < params->loaded_segments_num; i++) {
+			struct loaded_segment *seg;
+			unsigned long start_pages, mid_pages, end_pages;
+
+			seg = &params->loaded_segments[i];
+			if (seg->start < mstart || seg->start >= mend)
+				continue;
+
+			while (seg->end > mend && src < src_end) {
+				src += boot_param->efi_memdesc_size;
+				src_md = src;
+				/* TODO check contig and attribute here */
+				mend = src_md->phys_addr +
+					(src_md->num_pages << EFI_PAGE_SHIFT);
+			}
+			start_pages = (seg->start - mstart) >> EFI_PAGE_SHIFT;
+			mid_pages = (seg->end - seg->start) >> EFI_PAGE_SHIFT;
+			end_pages = (mend - seg->end) >> EFI_PAGE_SHIFT;
+			if (start_pages) {
+				dst_md->num_pages = start_pages;
+				dest += boot_param->efi_memdesc_size;
+				dst_md = dest;
+				*dst_md = *src_md;
+			}
+			dst_md->phys_addr = seg->start;
+			dst_md->num_pages = mid_pages;
+			dst_md->type = EFI_LOADER_DATA;
+			if (!end_pages)
+				break;
+			dest += boot_param->efi_memdesc_size;
+			dst_md = dest;
+			*dst_md = *src_md;
+			dst_md->phys_addr = seg->end;
+			dst_md->num_pages = end_pages;
+			dst_md->type = orig_type;
+			mstart = seg->end;
+		}
+	}
+
+	boot_param->efi_memmap_size = dest - (void *)params->efi_memmap_base;
+}
+
+void
+flush_icache_range(char *start, unsigned long len)
+{
+	unsigned long i, addr;
+	addr = (unsigned long)start & ~31UL;
+	len += (unsigned long)start - addr;
+	for (i = 0;i < len; i += 32)
+	  asm volatile("fc.i %0"::"r"(start + i):"memory");
+	asm volatile (";;sync.i;;":::"memory");
+	asm volatile ("srlz.i":::"memory");
+}
+
+extern char __dummy_efi_function[], __dummy_efi_function_end[];
+
+
+void
+ia64_env_setup(struct ia64_boot_param *boot_param,
+	struct kexec_boot_params *params)
+{
+	unsigned long len;
+        efi_system_table_t *systab;
+        efi_runtime_services_t *runtime;
+	unsigned long *set_virtual_address_map;
+	char *command_line = (char *)params->command_line;
+	uint64_t command_line_len = params->command_line_len;
+	struct ia64_boot_param *new_boot_param =
+	(struct ia64_boot_param *) params->boot_param_base;
+	memcpy(new_boot_param, boot_param, 4096);
+
+	/*
+	 * patch efi_runtime->set_virtual_address_map to a dummy function
+	 *
+	 * The EFI specification mandates that set_virtual_address_map only
+	 * takes effect the first time that it is called, and that
+	 * subsequent calls will return error.  By replacing it with a
+	 * dummy function the new OS can think it is calling it again
+	 * without either the OS or any buggy EFI implementations getting
+	 * upset.
+	 *
+	 * Note: as the EFI specification says that set_virtual_address_map
+	 * will only take affect the first time it is called, the mapping
+	 * can't be updated, and thus mapping of the old and new OS really
+	 * needs to be the same.
+	 */
+	len = __dummy_efi_function_end - __dummy_efi_function;
+	memcpy(command_line + command_line_len,
+		__dummy_efi_function, len);
+	systab = (efi_system_table_t *)new_boot_param->efi_systab;
+	runtime = (efi_runtime_services_t *)PA(systab->runtime);
+	set_virtual_address_map =
+		(unsigned long *)PA(runtime->set_virtual_address_map);
+	*(set_virtual_address_map) =
+		(unsigned long)(command_line + command_line_len);
+	flush_icache_range(command_line + command_line_len, len);
+
+	patch_efi_memmap(params, new_boot_param);
+
+	new_boot_param->efi_memmap = params->efi_memmap_base;
+	new_boot_param->command_line = params->command_line;
+	new_boot_param->console_info.orig_x = 0;
+	new_boot_param->console_info.orig_y = 0;
+	new_boot_param->initrd_start = params->ramdisk_base;
+	new_boot_param->initrd_size =  params->ramdisk_size;
+	new_boot_param->vmcode_start = params->vmcode_base;
+	new_boot_param->vmcode_size =  params->vmcode_size;
+}
+
+/* This function can be used to execute after the SHA256 verification. */
+void post_verification_setup_arch(void)
 {
 	/* Nothing for now */
 }
diff -Nur kexec-tools-1.101/purgatory/arch/ia64/purgatory-ia64.h kexec-tools-1.101-geoff/purgatory/arch/ia64/purgatory-ia64.h
--- kexec-tools-1.101/purgatory/arch/ia64/purgatory-ia64.h	2004-12-21 04:44:55.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/ia64/purgatory-ia64.h	2007-10-23 16:24:40.000000000 +0700
@@ -1,6 +1,5 @@
 #ifndef PURGATORY_IA64_H
 #define PURGATORY_IA64_H
 
-/* nothing yet */
-
+void reset_vga(void);
 #endif /* PURGATORY_IA64_H */
diff -Nur kexec-tools-1.101/purgatory/arch/ia64/vga.c kexec-tools-1.101-geoff/purgatory/arch/ia64/vga.c
--- kexec-tools-1.101/purgatory/arch/ia64/vga.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/ia64/vga.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,143 @@
+#include "io.h"
+void reset_vga(void)
+{
+	/* Hello */
+	inb(0x3da);
+	outb(0, 0x3c0);
+
+	/* Sequencer registers */
+	outw(0x0300, 0x3c4);
+	outw(0x0001, 0x3c4);
+	outw(0x0302, 0x3c4);
+	outw(0x0003, 0x3c4);
+	outw(0x0204, 0x3c4);
+
+	/* Ensure CRTC regs 0-7 are unlocked by clearing bit 7 of CRTC[17] */
+	outw(0x0e11, 0x3d4);
+	/* CRTC registers */
+	outw(0x5f00, 0x3d4);
+	outw(0x4f01, 0x3d4);
+	outw(0x5002, 0x3d4);
+	outw(0x8203, 0x3d4);
+	outw(0x5504, 0x3d4);
+	outw(0x8105, 0x3d4);
+	outw(0xbf06, 0x3d4);
+	outw(0x1f07, 0x3d4);
+	outw(0x0008, 0x3d4);
+	outw(0x4f09, 0x3d4);
+	outw(0x200a, 0x3d4);
+	outw(0x0e0b, 0x3d4);
+	outw(0x000c, 0x3d4);
+	outw(0x000d, 0x3d4);
+	outw(0x010e, 0x3d4);
+	outw(0xe00f, 0x3d4);
+	outw(0x9c10, 0x3d4);
+	outw(0x8e11, 0x3d4);
+	outw(0x8f12, 0x3d4);
+	outw(0x2813, 0x3d4);
+	outw(0x1f14, 0x3d4);
+	outw(0x9615, 0x3d4);
+	outw(0xb916, 0x3d4);
+	outw(0xa317, 0x3d4);
+	outw(0xff18, 0x3d4);
+
+	/* Graphic registers */
+	outw(0x0000, 0x3ce);
+	outw(0x0001, 0x3ce);
+	outw(0x0002, 0x3ce);
+	outw(0x0003, 0x3ce);
+	outw(0x0004, 0x3ce);
+	outw(0x1005, 0x3ce);
+	outw(0x0e06, 0x3ce);
+	outw(0x0007, 0x3ce);
+	outw(0xff08, 0x3ce);
+
+	/* Attribute registers */
+	inb(0x3da);
+	outb(0x00, 0x3c0);
+	outb(0x00, 0x3c0);
+
+	inb(0x3da);
+	outb(0x01, 0x3c0);
+	outb(0x01, 0x3c0);
+
+	inb(0x3da);
+	outb(0x02, 0x3c0);
+	outb(0x02, 0x3c0);
+
+	inb(0x3da);
+	outb(0x03, 0x3c0);
+	outb(0x03, 0x3c0);
+
+	inb(0x3da);
+	outb(0x04, 0x3c0);
+	outb(0x04, 0x3c0);
+
+	inb(0x3da);
+	outb(0x05, 0x3c0);
+	outb(0x05, 0x3c0);
+
+	inb(0x3da);
+	outb(0x06, 0x3c0);
+	outb(0x14, 0x3c0);
+
+	inb(0x3da);
+	outb(0x07, 0x3c0);
+	outb(0x07, 0x3c0);
+
+	inb(0x3da);
+	outb(0x08, 0x3c0);
+	outb(0x38, 0x3c0);
+
+	inb(0x3da);
+	outb(0x09, 0x3c0);
+	outb(0x39, 0x3c0);
+
+	inb(0x3da);
+	outb(0x0a, 0x3c0);
+	outb(0x3a, 0x3c0);
+
+	inb(0x3da);
+	outb(0x0b, 0x3c0);
+	outb(0x3b, 0x3c0);
+
+	inb(0x3da);
+	outb(0x0c, 0x3c0);
+	outb(0x3c, 0x3c0);
+
+	inb(0x3da);
+	outb(0x0d, 0x3c0);
+	outb(0x3d, 0x3c0);
+
+	inb(0x3da);
+	outb(0x0e, 0x3c0);
+	outb(0x3e, 0x3c0);
+
+	inb(0x3da);
+	outb(0x0f, 0x3c0);
+	outb(0x3f, 0x3c0);
+
+	inb(0x3da);
+	outb(0x10, 0x3c0);
+	outb(0x0c, 0x3c0);
+
+	inb(0x3da);
+	outb(0x11, 0x3c0);
+	outb(0x00, 0x3c0);
+
+	inb(0x3da);
+	outb(0x12, 0x3c0);
+	outb(0x0f, 0x3c0);
+
+	inb(0x3da);
+	outb(0x13, 0x3c0);
+	outb(0x08, 0x3c0);
+
+	inb(0x3da);
+	outb(0x14, 0x3c0);
+	outb(0x00, 0x3c0);
+
+	/* Goodbye */
+	inb(0x3da);
+	outb(0x20, 0x3c0);
+}
diff -Nur kexec-tools-1.101/purgatory/arch/ppc/purgatory-ppc.c kexec-tools-1.101-geoff/purgatory/arch/ppc/purgatory-ppc.c
--- kexec-tools-1.101/purgatory/arch/ppc/purgatory-ppc.c	2004-12-21 04:47:43.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/ppc/purgatory-ppc.c	2007-10-23 16:24:40.000000000 +0700
@@ -5,3 +5,9 @@
 {
 	/* Nothing for now */
 }
+
+/* This function can be used to execute after the SHA256 verification. */
+void post_verification_setup_arch(void)
+{
+	/* Nothing for now */
+}
diff -Nur kexec-tools-1.101/purgatory/arch/ppc64/console-ppc64.c kexec-tools-1.101-geoff/purgatory/arch/ppc64/console-ppc64.c
--- kexec-tools-1.101/purgatory/arch/ppc64/console-ppc64.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/ppc64/console-ppc64.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,27 @@
+/*
+ * kexec: Linux boots Linux
+ *
+ * Created by: Mohan Kumar M (mohan@in.ibm.com)
+ *
+ * Copyright (C) IBM Corporation, 2005. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <purgatory.h>
+
+void putchar(int c)
+{
+	return;
+}
diff -Nur kexec-tools-1.101/purgatory/arch/ppc64/crashdump_backup.c kexec-tools-1.101-geoff/purgatory/arch/ppc64/crashdump_backup.c
--- kexec-tools-1.101/purgatory/arch/ppc64/crashdump_backup.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/ppc64/crashdump_backup.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,39 @@
+/*
+ * kexec: Linux boots Linux
+ *
+ * Created by: Mohan Kumar M (mohan@in.ibm.com)
+ *
+ * Copyright (C) IBM Corporation, 2005. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stdint.h>
+#include <string.h>
+#include "../../../kexec/arch/ppc64/crashdump-ppc64.h"
+
+extern unsigned long backup_start;
+
+/* Backup first 32KB of memory to backup region reserved by kexec */
+void crashdump_backup_memory(void)
+{
+	void *dest, *src;
+
+	src = (void *)BACKUP_SRC_START;
+
+	if (backup_start) {
+		dest = (void *)(backup_start);
+		memcpy(dest, src, BACKUP_SRC_SIZE);
+	}
+}
diff -Nur kexec-tools-1.101/purgatory/arch/ppc64/Makefile kexec-tools-1.101-geoff/purgatory/arch/ppc64/Makefile
--- kexec-tools-1.101/purgatory/arch/ppc64/Makefile	2004-12-17 11:30:20.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/ppc64/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -2,6 +2,9 @@
 # Purgatory ppc
 #
 
-PURGATORY_C_SRCS+=
-PURGATORY_S_SRCS+=
+PURGATORY_S_SRCS+= purgatory/arch/ppc64/v2wrap.S
+PURGATORY_C_SRCS += purgatory/arch/ppc64/purgatory-ppc64.c
+PURGATORY_C_SRCS += purgatory/arch/ppc64/console-ppc64.c
+PURGATORY_C_SRCS += purgatory/arch/ppc64/crashdump_backup.c
 
+PCFLAGS += -m64 -mcall-aixdesc
diff -Nur kexec-tools-1.101/purgatory/arch/ppc64/purgatory-ppc64.c kexec-tools-1.101-geoff/purgatory/arch/ppc64/purgatory-ppc64.c
--- kexec-tools-1.101/purgatory/arch/ppc64/purgatory-ppc64.c	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/ppc64/purgatory-ppc64.c	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,41 @@
+/*
+ * kexec: Linux boots Linux
+ *
+ * Created by: Mohan Kumar M (mohan@in.ibm.com)
+ *
+ * Copyright (C) IBM Corporation, 2005. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <purgatory.h>
+#include "purgatory-ppc64.h"
+
+unsigned int panic_kernel = 0;
+unsigned long backup_start = 0;
+unsigned long stack = 0;
+unsigned long dt_offset = 0;
+unsigned long my_toc = 0;
+unsigned long kernel = 0;
+
+void setup_arch(void)
+{
+	return;
+}
+
+void post_verification_setup_arch(void)
+{
+	if (panic_kernel)
+		crashdump_backup_memory();
+}
diff -Nur kexec-tools-1.101/purgatory/arch/ppc64/purgatory-ppc64.h kexec-tools-1.101-geoff/purgatory/arch/ppc64/purgatory-ppc64.h
--- kexec-tools-1.101/purgatory/arch/ppc64/purgatory-ppc64.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/ppc64/purgatory-ppc64.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,6 @@
+#ifndef PURGATORY_PPC64_H
+#define PURGATORY_PPC64_H
+
+void crashdump_backup_memory(void);
+
+#endif /* PURGATORY_PPC64_H */
diff -Nur kexec-tools-1.101/purgatory/arch/ppc64/v2wrap.S kexec-tools-1.101-geoff/purgatory/arch/ppc64/v2wrap.S
--- kexec-tools-1.101/purgatory/arch/ppc64/v2wrap.S	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/ppc64/v2wrap.S	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,101 @@
+#
+#  kexec: Linux boots Linux
+#
+#  Copyright (C) 2004 - 2005, Milton D Miller II, IBM Corporation
+#  Copyright (C) 2006, Mohan Kumar M (mohan@in.ibm.com), IBM Corporation
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation (version 2 of the License).
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program; if not, write to the Free Software
+#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+#
+
+# v2wrap.S
+# a wrapper to call purgatory code to backup first
+# 32kB of first kernel into the backup region
+# reserved by kexec-tools.
+# Invokes ppc64 kernel with the expected arguments
+# of kernel(device-tree, phys-offset, 0)
+
+#
+# calling convention:
+#   r3 = physical number of this cpu (all cpus)
+#   r4 = address of this chunk (master only)
+# master enters at purgatory_start (aka first byte of this chunk)
+# slaves (additional cpus), if any, enter a copy of the
+# first 0x100 bytes of this code relocated to 0x0
+#
+# in other words,
+#   a copy of the first 0x100 bytes of this code is copied to 0
+#   and the slaves are sent to address 0x60
+#   with r3 = their physical cpu number.
+
+#define LOADADDR(rn,name) \
+	lis     rn,name##@highest;      \
+	ori     rn,rn,name##@higher;    \
+	rldicr  rn,rn,32,31;            \
+	oris    rn,rn,name##@h;         \
+	ori     rn,rn,name##@l
+
+
+	.machine ppc64
+	.globl purgatory_start
+purgatory_start:	b	master
+	.org purgatory_start + 0x60     # ABI: slaves start at 60 with r3=phys
+slave:	b $
+	.org purgatory_start + 0x100    # ABI: end of copied region
+	.size purgatory_start, . - purgatory_start
+
+#
+# The above 0x100 bytes at purgatory_start are replaced with the
+# code from the kernel (or next stage) by kexec/arch/ppc64/kexec-ppc64.c
+#
+
+master:
+	or	1,1,1		# low priority to let other threads catchup
+	isync
+	mr      17,3            # save cpu id to r17
+	mr      15,4            # save physical address in reg15
+
+	LOADADDR(6,my_toc)
+	ld      2,0(6)          #setup toc
+
+	LOADADDR(6,stack)
+	ld      1,0(6)          #setup stack
+
+	subi    1,1,112
+	bl      .purgatory
+	nop
+
+	or	3,3,3		# ok now to high priority, lets boot
+	lis	6,0x1
+	mtctr	6		# delay a bit for slaves to catch up
+83:	bdnz	83b		# before we overwrite 0-100 again
+
+	LOADADDR(16, dt_offset)
+	ld      3,0(16)         # load device-tree address
+	mr      16,3            # save dt address in reg16
+	lwz     6,20(3)         # fetch version number
+	cmpwi   0,6,2           # v2 ?
+	blt     80f
+	stw     17,28(3)        # save my cpu number as boot_cpu_phys
+80:
+	LOADADDR(6,kernel)
+	ld      4,0(6)          # load the kernel address
+	li	5,0		# r5 will be 0 for kernel
+	mtctr	4		# prepare branch too
+	mr      3,16            # restore dt address
+
+	lwz	7,0(4)		# get the first instruction that we stole
+	stw	7,0(0)		# and put it in the slave loop at 0
+				# skip cache flush, do we care?
+
+	bctr			# start kernel
diff -Nur kexec-tools-1.101/purgatory/arch/s390/include/limits.h kexec-tools-1.101-geoff/purgatory/arch/s390/include/limits.h
--- kexec-tools-1.101/purgatory/arch/s390/include/limits.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/s390/include/limits.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,54 @@
+#ifndef _LIMITS_H_
+#define _LIMITS_H_
+
+/* Number of bits in a `char'.	*/
+#  define CHAR_BIT	8
+
+/* Minimum and maximum values a `signed char' can hold.  */
+#  define SCHAR_MIN	(-128)
+#  define SCHAR_MAX	127
+
+/* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  */
+#  define UCHAR_MAX	255
+
+#  define CHAR_MIN	SCHAR_MIN
+#  define CHAR_MAX	SCHAR_MAX
+
+/* Minimum and maximum values a `signed short int' can hold.  */
+#  define SHRT_MIN	(-32768)
+#  define SHRT_MAX	32767
+
+/* Maximum value an `unsigned short int' can hold.  (Minimum is 0.)  */
+#  define USHRT_MAX	65535
+
+/* Minimum and maximum values a `signed int' can hold.  */
+#  define INT_MIN	(-INT_MAX - 1)
+#  define INT_MAX	2147483647
+
+/* Maximum value an `unsigned int' can hold.  (Minimum is 0.)  */
+#  define UINT_MAX	4294967295U
+
+/* Minimum and maximum values a `signed long int' can hold.  */
+#ifdef __s390x__
+#   define LONG_MAX	9223372036854775807L
+#else
+#   define LONG_MAX	2147483647L
+#endif
+
+#  define LONG_MIN	(-LONG_MAX - 1L)
+
+/* Maximum value an `unsigned long int' can hold.  (Minimum is 0.)  */
+#ifdef __s390x__
+#   define ULONG_MAX	18446744073709551615UL
+#else
+#   define ULONG_MAX	4294967295UL
+#endif
+
+/* Minimum and maximum values a `signed long long int' can hold.  */
+#   define LLONG_MAX	9223372036854775807LL
+#   define LLONG_MIN	(-LLONG_MAX - 1LL)
+
+/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0.)  */
+#   define ULLONG_MAX	18446744073709551615ULL
+
+#endif	/* !_LIMITS_H_ */
diff -Nur kexec-tools-1.101/purgatory/arch/s390/include/stdint.h kexec-tools-1.101-geoff/purgatory/arch/s390/include/stdint.h
--- kexec-tools-1.101/purgatory/arch/s390/include/stdint.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/s390/include/stdint.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,24 @@
+#ifndef _STDINT_H
+#define _STDINT_H
+
+typedef unsigned long		size_t;
+
+typedef unsigned char		uint8_t;
+typedef unsigned short		uint16_t;
+typedef unsigned int		uint32_t;
+#ifdef __s390x__
+typedef unsigned long		uint64_t;
+#else
+typedef unsigned long long	uint64_t;
+#endif
+
+typedef signed char 		int8_t;
+typedef short 			int16_t;
+typedef int 			int32_t;
+#ifdef __s390x__
+typedef long			int64_t;
+#else
+typedef long long		int64_t;
+#endif
+
+#endif
diff -Nur kexec-tools-1.101/purgatory/arch/s390/Makefile kexec-tools-1.101-geoff/purgatory/arch/s390/Makefile
--- kexec-tools-1.101/purgatory/arch/s390/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/s390/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,7 @@
+#
+# Purgatory s390
+#
+
+PURGATORY_C_SRCS+=
+PURGATORY_S_SRCS+=
+
diff -Nur kexec-tools-1.101/purgatory/arch/sh/include/limits.h kexec-tools-1.101-geoff/purgatory/arch/sh/include/limits.h
--- kexec-tools-1.101/purgatory/arch/sh/include/limits.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/sh/include/limits.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,58 @@
+#ifndef LIMITS_H
+#define LIMITS_H	1
+
+
+/* Number of bits in a `char' */
+#define CHAR_BIT	8
+
+/* Minimum and maximum values a `signed char' can hold */
+#define SCHAR_MIN	(-128)
+#define SCHAR_MAX	127
+
+/* Maximum value an `unsigned char' can hold. (Minimum is 0.) */
+#define UCHAR_MAX	255
+
+/* Minimum and maximum values a `char' can hold */
+#define CHAR_MIN	SCHAR_MIN
+#define CHAR_MAX	SCHAR_MAX
+
+/* Minimum and maximum values a `signed short int' can hold */
+#define SHRT_MIN	(-32768)
+#define SHRT_MAX	32767
+
+/* Maximum value an `unsigned short' can hold. (Minimum is 0.) */
+#define USHRT_MAX	65535
+
+
+/* Minimum and maximum values a `signed int' can hold */
+#define INT_MIN		(-INT_MAX - 1)
+#define INT_MAX		2147483647
+
+/* Maximum value an `unsigned int' can hold. (Minimum is 0.) */
+#define UINT_MAX	4294967295U
+
+
+/* Minimum and maximum values a `signed int' can hold */
+#define INT_MIN		(-INT_MAX - 1)
+#define INT_MAX		2147483647
+
+/* Maximum value an `unsigned int' can hold. (Minimum is 0.) */
+#define UINT_MAX	4294967295U
+
+/* Minimum and maximum values a `signed long' can hold */
+#define LONG_MAX	2147483647L
+#define LONG_MIN	(-LONG_MAX - 1L)
+
+/* Maximum value an `unsigned long' can hold. (Minimum is 0.) */
+#define ULONG_MAX	4294967295UL
+
+/* Minimum and maximum values a `signed long long' can hold */
+#define LLONG_MAX	9223372036854775807LL
+#define LLONG_MIN	(-LONG_MAX - 1LL)
+
+
+/* Maximum value an `unsigned long long' can hold. (Minimum is 0.) */
+#define ULLONG_MAX	18446744073709551615ULL
+
+
+#endif /* LIMITS_H */
diff -Nur kexec-tools-1.101/purgatory/arch/sh/include/stdint.h kexec-tools-1.101-geoff/purgatory/arch/sh/include/stdint.h
--- kexec-tools-1.101/purgatory/arch/sh/include/stdint.h	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/sh/include/stdint.h	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,16 @@
+#ifndef STDINT_H
+#define STDINT_H
+
+typedef unsigned long      size_t;
+
+typedef unsigned char      uint8_t;
+typedef unsigned short     uint16_t;
+typedef unsigned int       uint32_t;
+typedef unsigned long long uint64_t;
+
+typedef signed char        int8_t;
+typedef signed short       int16_t;
+typedef signed int         int32_t;
+typedef signed long long   int64_t;
+
+#endif /* STDINT_H */
diff -Nur kexec-tools-1.101/purgatory/arch/sh/Makefile kexec-tools-1.101-geoff/purgatory/arch/sh/Makefile
--- kexec-tools-1.101/purgatory/arch/sh/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ kexec-tools-1.101-geoff/purgatory/arch/sh/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -0,0 +1,7 @@
+#
+# Purgatory alpha
+#
+
+PURGATORY_C_SRCS+=
+PURGATORY_S_SRCS+=
+
diff -Nur kexec-tools-1.101/purgatory/arch/x86_64/entry64.S kexec-tools-1.101-geoff/purgatory/arch/x86_64/entry64.S
--- kexec-tools-1.101/purgatory/arch/x86_64/entry64.S	2004-12-21 05:28:50.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/x86_64/entry64.S	2007-10-23 16:24:40.000000000 +0700
@@ -37,7 +37,11 @@
 	movl	%eax, %fs
 	movl	%eax, %gs
 
-	/* In 64bit mode the code segment is meaningless */
+	movq	$stack_init, %rsp
+	pushq	$0x10 /* CS */
+	pushq	$new_cs_exit
+	lretq
+new_cs_exit:
 
 	/* Load the registers */
 	movq	rax(%rip), %rax
@@ -93,8 +97,10 @@
 	.word	0, 0, 0
 			
 	/* 0x10 4GB flat code segment */
-	.word	0xFFFF, 0x0000, 0x9A00, 0x00CF
+	.word	0xFFFF, 0x0000, 0x9A00, 0x00AF
 	
 	/* 0x18 4GB flat data segment */
 	.word	0xFFFF, 0x0000, 0x9200, 0x00CF
 gdt_end:
+stack:	.quad	0, 0
+stack_init:
diff -Nur kexec-tools-1.101/purgatory/arch/x86_64/include/arch/debug.h kexec-tools-1.101-geoff/purgatory/arch/x86_64/include/arch/debug.h
--- kexec-tools-1.101/purgatory/arch/x86_64/include/arch/debug.h	2004-12-21 05:05:40.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/x86_64/include/arch/debug.h	2007-10-23 16:24:40.000000000 +0700
@@ -311,7 +311,7 @@
 	TTYS0_TX_AL
 	
 
-#define DEBUG(x) TTYS0_TX_CHAR($x) ;  TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
+#define DEBUG_CHAR(x) TTYS0_TX_CHAR($x) ;  TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
 #define DEBUG_TX_HEX32(x) TTYS0_TX_HEX32(x); TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
 #define DEBUG_TX_HEX64(x) TTYS0_TX_HEX64(x); TTYS0_TX_CHAR($'\r') ;  TTYS0_TX_CHAR($'\n')
 
diff -Nur kexec-tools-1.101/purgatory/arch/x86_64/Makefile kexec-tools-1.101-geoff/purgatory/arch/x86_64/Makefile
--- kexec-tools-1.101/purgatory/arch/x86_64/Makefile	2004-12-21 13:13:53.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/x86_64/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -9,6 +9,7 @@
 PURGATORY_S_SRCS+= purgatory/arch/x86_64/setup-x86_64.S
 PURGATORY_S_SRCS+= purgatory/arch/x86_64/stack.S
 PURGATORY_C_SRCS+= purgatory/arch/x86_64/purgatory-x86_64.c
+PURGATORY_C_SRCS+= purgatory/arch/i386/crashdump_backup.c
 PURGATORY_C_SRCS+= purgatory/arch/i386/console-x86.c
 PURGATORY_C_SRCS+= purgatory/arch/i386/vga.c
 PURGATORY_C_SRCS+= purgatory/arch/i386/pic.c
diff -Nur kexec-tools-1.101/purgatory/arch/x86_64/purgatory-x86_64.c kexec-tools-1.101-geoff/purgatory/arch/x86_64/purgatory-x86_64.c
--- kexec-tools-1.101/purgatory/arch/x86_64/purgatory-x86_64.c	2004-12-21 22:37:41.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/arch/x86_64/purgatory-x86_64.c	2007-10-23 16:24:40.000000000 +0700
@@ -4,9 +4,16 @@
 
 uint8_t reset_vga = 0;
 uint8_t legacy_pic = 0;
+uint8_t panic_kernel = 0;
 
 void setup_arch(void)
 {
 	if (reset_vga)    x86_reset_vga();
 	if (legacy_pic)   x86_setup_legacy_pic();
 }
+
+/* This function can be used to execute after the SHA256 verification. */
+void post_verification_setup_arch(void)
+{
+	 if (panic_kernel)   crashdump_backup_memory();
+}
diff -Nur kexec-tools-1.101/purgatory/include/purgatory.h kexec-tools-1.101-geoff/purgatory/include/purgatory.h
--- kexec-tools-1.101/purgatory/include/purgatory.h	2004-12-18 19:12:15.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/include/purgatory.h	2007-10-23 16:24:40.000000000 +0700
@@ -4,5 +4,6 @@
 void putchar(int ch);
 void printf(const char *fmt, ...);
 void setup_arch(void);
+void post_verification_setup_arch(void);
 
 #endif /* PURGATORY_H */
diff -Nur kexec-tools-1.101/purgatory/Makefile kexec-tools-1.101-geoff/purgatory/Makefile
--- kexec-tools-1.101/purgatory/Makefile	2005-01-09 04:36:32.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -6,21 +6,26 @@
 # There is probably a cleaner way to do this but for now this
 # should keep us from accidentially include unsafe library functions
 # or headers.
+
+ifeq ($(ARCH),ppc64)
+EXTRA_LDFLAGS = -melf64ppc
+endif
+
 PCFLAGS:=-Wall -Os  \
 	-I$(shell $(CC) -print-file-name=include) \
 	-Ipurgatory/include -Ipurgatory/arch/$(ARCH)/include \
-	$(CPPFLAGS)
+	$(CPPFLAGS) $(EXTRA_CPPFLAGS)
 
 PCFLAGS += $(call cc-option, -ffreestanding)
 PCFLAGS += $(call cc-option, -fnobuiltin)
 PCFLAGS += $(call cc-option, -fnostdinc)
 PCFLAGS += $(call cc-option, -fno-zero-initialized-in-bss)
 
-PURGATORY_C_SRCS:= 
+PURGATORY_C_SRCS:=
 PURGATORY_C_SRCS += purgatory/purgatory.c
 PURGATORY_C_SRCS += purgatory/printf.c
 PURGATORY_C_SRCS += purgatory/string.c
-PURGATORY_S_OBJS:= 
+PURGATORY_S_OBJS:=
 
 include purgatory/arch/$(ARCH)/Makefile
 
@@ -54,7 +59,7 @@
 
 $(PURGATORY): $(PURGATORY_OBJS) $(UTIL_LIB)
 	$(MKDIR) -p $(@D)
-	$(LD) $(LDFLAGS) --no-undefined -e purgatory_start -r -o $@ $(PURGATORY_OBJS) $(UTIL_LIB)
+	$(LD) $(LDFLAGS) $(EXTRA_LDFLAGS) --no-undefined -e purgatory_start -r -o $@ $(PURGATORY_OBJS) $(UTIL_LIB)
 
 echo::
 	@echo "PURGATORY_C_SRCS $(PURGATORY_C_SRCS)"
diff -Nur kexec-tools-1.101/purgatory/purgatory.c kexec-tools-1.101-geoff/purgatory/purgatory.c
--- kexec-tools-1.101/purgatory/purgatory.c	2004-12-22 00:51:03.000000000 +0600
+++ kexec-tools-1.101-geoff/purgatory/purgatory.c	2007-10-23 16:24:40.000000000 +0700
@@ -44,4 +44,7 @@
 	printf("I'm in purgatory\n");
 	setup_arch();
 	verify_sha256_digest();
+	post_verification_setup_arch();
 }
+
+#include "../util_lib/sha256.c"
diff -Nur kexec-tools-1.101/TODO kexec-tools-1.101-geoff/TODO
--- kexec-tools-1.101/TODO	2005-02-06 10:32:25.000000000 +0600
+++ kexec-tools-1.101-geoff/TODO	2007-10-23 16:24:40.000000000 +0700
@@ -1,10 +1,10 @@
+- x86 handle x86 vmlinux parameter header allocation issues.
+  There is a bug where it can get stomped but the current code
+  does not allow us much flexibility in what we do with it.
 - Restore enough state that DOS/arbitrary BIOS calls can be run on some
   platforms.  Currently disk-related calls are quite likely to blow up.
 - x86 filling in other kernel parameters.
 - Merge reboot via kexec functionality into /sbin/reboot
-- In the kexec-on-panic case preserving memory the both kernels
-  must use.
-- Finish the kexec-on-panic case.
 - Improve the documentation 
 - Add support for loading a boot sector
 - Autobuilding of initramfs
diff -Nur kexec-tools-1.101/util_lib/Makefile kexec-tools-1.101-geoff/util_lib/Makefile
--- kexec-tools-1.101/util_lib/Makefile	2004-12-21 23:14:22.000000000 +0600
+++ kexec-tools-1.101-geoff/util_lib/Makefile	2007-10-23 16:24:40.000000000 +0700
@@ -11,11 +11,16 @@
 
 $(UTIL_LIB_DEPS): $(OBJDIR)/%.d: %.c 
 	$(MKDIR) -p $(@D)
-	$(CC) $(CFLAGS) -M $< | sed -e 's|$(patsubst %.d,%.o,$(@F))|$(patsubst %.d,%.o,$(@))|' > $@
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -M $< | sed -e 's|$(patsubst %.d,%.o,$(@F))|$(patsubst %.d,%.o,$(@))|' > $@
 
+# sha256.c needs to be compiled without optimization, else
+# purgatory fails to execute (on ia64 at least).
+# By placing -O0 after $(CFLAGS), which is provided by
+# the prevailing environment, it overrides any other -O flags
+# provided.
 $(UTIL_LIB_OBJS): $(OBJDIR)/%.o: %.c $(OBJDIR)/%.d
 	$(MKDIR) -p $(@D)
-	$(CC) $(CFLAGS) -c -o $@ $<
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -O0 -c -o $@ $<
 
 $(UTIL_LIB): $(UTIL_LIB_OBJS)
 	$(MKDIR) -p $(@D)
