diff -Nur lxpanel-0.5.3-orig/configure.ac lxpanel-0.5.3/configure.ac
--- lxpanel-0.5.3-orig/configure.ac	2009-09-08 13:53:48.000000000 +0700
+++ lxpanel-0.5.3/configure.ac	2009-09-08 14:26:57.000000000 +0700
@@ -173,6 +173,7 @@
 
 dnl Here are plugin listing.
 plugin_netstatus=
+plugin_netstat=
 plugin_volume=
 plugin_volumealsa=
 plugin_cpu=
@@ -188,7 +189,7 @@
 [                         plugins may be comma separated ]
 [                         'all' builds all plugins (default), 'none' builds none ]
 [                         Possible plugins are: ]
-[                         netstatus, volume, volumealsa, cpu, deskno, batt, kbled, xkb, thermal], plugins="$withval",[plugins="all"])
+[                         netstatus, netstat, volume, volumealsa, cpu, deskno, batt, kbled, xkb, thermal], plugins="$withval",[plugins="all"])
 
 if test x"$plugins" != xall -a x"$plugins" != xnone; then
     if test x"$plugins_loading" = xno; then
@@ -197,7 +198,7 @@
     fi
 fi
 
-ALL_PLUGINS_LIST="netstatus volume volumealsa cpu deskno batt kbled xkb thermal"
+ALL_PLUGINS_LIST="netstatus netstat volume volumealsa cpu deskno batt kbled xkb thermal"
 AC_SUBST(ALL_PLUGINS_LIST)
 
 if test x"$plugins" = xall; then
@@ -207,6 +208,7 @@
 dnl    done
 
     plugin_netstatus=netstatus
+    plugin_netstat=netstat
     plugin_volume=volume
     plugin_volumealsa=volumealsa
     plugin_cpu=cpu
@@ -226,6 +228,9 @@
             netstatus)
                 plugin_netstatus=netstatus
                 ;;
+            netstat)
+                plugin_netstat=netstat
+                ;;
             volume)
                 plugin_volume=volume
                 ;;
@@ -272,6 +277,7 @@
 fi
 PLUGINS_LIST="\
     $plugin_netstatus \
+    $plugin_netstat \
     $plugin_volume \
     $plugin_volumealsa \
     $plugin_cpu \
@@ -334,6 +340,7 @@
     src/Makefile
     src/plugins/Makefile
     src/plugins/netstatus/Makefile
+    src/plugins/netstat/Makefile
     src/plugins/volume/Makefile
     src/plugins/volumealsa/Makefile
     src/plugins/cpu/Makefile
@@ -358,6 +365,9 @@
     if test x"$plugin_netstatus" != x; then
         AC_MSG_RESULT([    netstatus - Monitor networking status])
     fi
+    if test x"$plugin_netstat" != x; then
+        AC_MSG_RESULT([    netstat - Configure network])
+    fi
     if test x"$plugin_volume" != x; then
         AC_MSG_RESULT([    volume - Display and adjust volume of sound card for OSS])
     fi
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/devproc.c lxpanel-0.5.3/src/plugins/netstat/devproc.c
--- lxpanel-0.5.3-orig/src/plugins/netstat/devproc.c	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/devproc.c	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,527 @@
+/**
+ * Copyright (c) 2008 LxDE Developers, see the file AUTHORS for details.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <string.h>
+#include <glib.h>
+#include <fcntl.h>
+#include <sys/select.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <linux/sockios.h>
+#include <linux/types.h>
+#include <linux/ethtool.h>
+#include <iwlib.h>
+#include "nsconfig.h"
+#include "netstat.h"
+#include "statusicon.h"
+#include "devproc.h"
+
+/* network device list */
+static void netproc_netdevlist_add(NETDEVLIST_PTR *netdev_list,
+                                   const char *ifname,
+                                   gulong recv_bytes,
+                                   gulong recv_packets,
+                                   gulong trans_bytes,
+                                   gulong trans_packets,
+                                   gboolean wireless)
+{
+	NETDEVLIST_PTR new_dev;
+
+	new_dev = malloc(sizeof(NETDEVLIST));
+	new_dev->info.ifname = g_strdup(ifname);
+	new_dev->info.mac = NULL;
+	new_dev->info.ipaddr = NULL;
+	new_dev->info.dest = NULL;
+	new_dev->info.bcast = NULL;
+	new_dev->info.mask = NULL;
+	new_dev->info.alive = TRUE;
+	new_dev->info.enable = FALSE;
+	new_dev->info.updated = TRUE;
+	new_dev->info.plug = TRUE;
+	new_dev->info.connected = TRUE;
+	new_dev->info.wireless = wireless;
+	new_dev->info.status = NETDEV_STAT_NORMAL;
+	new_dev->info.recv_bytes = recv_bytes;
+	new_dev->info.recv_packets = recv_packets;
+	new_dev->info.trans_bytes = trans_bytes;
+	new_dev->info.trans_packets = trans_packets;
+	new_dev->info.status_icon = NULL;
+	new_dev->info.pg = NULL;
+	new_dev->prev = NULL;
+	new_dev->next = *netdev_list;
+	if (new_dev->next!=NULL) {
+		new_dev->next->prev = new_dev;
+	}
+	*netdev_list = new_dev;
+}
+
+static void netproc_netdevlist_destroy(NETDEVLIST_PTR netdev_list)
+{
+	g_free(netdev_list->info.ifname);
+	g_free(netdev_list->info.mac);
+	g_free(netdev_list->info.ipaddr);
+	g_free(netdev_list->info.dest);
+	g_free(netdev_list->info.bcast);
+	g_free(netdev_list->info.mask);
+	statusicon_destroy(netdev_list->info.status_icon);
+}
+
+int netproc_netdevlist_clear(NETDEVLIST_PTR *netdev_list)
+{
+	NETDEVLIST_PTR ptr;
+	NETDEVLIST_PTR ptr_del;
+
+	if (*netdev_list==NULL)
+		return 0;
+
+	ptr = *netdev_list;
+	while(ptr->next!=NULL) {
+		ptr_del = ptr;
+		ptr = ptr->next;
+		netproc_netdevlist_destroy(ptr_del);
+		free(ptr_del);
+	}
+
+	*netdev_list = NULL;
+
+	return 0;
+}
+
+
+static NETDEVLIST_PTR netproc_netdevlist_find(
+		NETDEVLIST_PTR netdev_list, const char *ifname)
+{
+	NETDEVLIST_PTR ptr;
+
+	if (netdev_list==NULL)
+		return NULL;
+
+	ptr = netdev_list;
+	do {
+
+		if (strcmp(ptr->info.ifname, ifname)==0)
+			return ptr;
+
+		ptr = ptr->next;
+	} while(ptr!=NULL);
+
+	return NULL;
+}
+
+static char *netproc_parse_ifname(const char *buffer)
+{
+	char *ptr;
+	if ((ptr = strchr(buffer, ':'))) {
+		*ptr++ = '\0';
+	}
+
+	return ptr;
+}
+
+static void netproc_parse_stats_header(const char *buffer,
+                                       int *prx_idx,
+                                       int *ptx_idx,
+                                       int *brx_idx,
+                                       int *btx_idx)
+{
+	char *p;
+	int i;
+
+	*prx_idx = *ptx_idx = -1;
+	*brx_idx = *btx_idx = -1;
+
+	p = strtok (buffer, "| \t\n");
+	p = strtok (NULL, "| \t\n");
+	for (i = 0; p; i++, p = strtok (NULL, "| \t\n")) {
+		if (!strcmp (p, "packets")) {
+			if (*prx_idx == -1)
+				*prx_idx = i;
+			else
+				*ptx_idx = i;
+		} else if (!strcmp (p, "bytes")) {
+			if (*brx_idx == -1)
+				*brx_idx = i;
+			else
+				*btx_idx = i;
+		}
+	}
+}
+
+static gboolean netproc_parse_status(const char *buffer,
+                                     int *prx_idx,
+                                     int *ptx_idx,
+                                     gulong *in_packets,
+                                     gulong *out_packets,
+                                     int *brx_idx,
+                                     int *btx_idx,
+                                     gulong *in_bytes,
+                                     gulong *out_bytes)
+{
+	char *ptr;
+	int i;
+	ptr = strtok(buffer, " \t\n");
+	for (i=0;ptr;i++, ptr = strtok(NULL, " \t\n")) {
+		if (i==prx_idx)
+			*in_packets = g_ascii_strtoull(ptr, NULL, 10);
+		else if (i==ptx_idx)
+			*out_packets = g_ascii_strtoull(ptr, NULL, 10);
+		else if (i==brx_idx)
+			*in_bytes = g_ascii_strtoull(ptr, NULL, 10);
+		else if (i==btx_idx)
+			*out_bytes = g_ascii_strtoull(ptr, NULL, 10);
+	}
+
+	if (i <= prx_idx || i <= ptx_idx || i <= brx_idx || i <=btx_idx)
+		return FALSE;
+
+	return TRUE;
+}
+
+FILE *netproc_open()
+{
+	return fopen("/proc/net/dev", "r");
+}
+
+void netproc_close(FILE *fp)
+{
+	fclose(fp);
+}
+
+int netproc_scandevice(int sockfd, int iwsockfd, FILE *fp, NETDEVLIST_PTR *netdev_list)
+{
+	char buffer[512];
+	int count = 0;
+	int prx_idx, ptx_idx, brx_idx, btx_idx;
+	gulong in_packets, out_packets, in_bytes, out_bytes;
+	NETDEVLIST_PTR devptr = NULL;
+
+	/* interface information */
+	struct ifreq ifr;
+	struct ethtool_test edata;
+	iwstats iws;
+	struct iwreq iwr;
+	char *status;
+	char *name;
+	struct iw_range iwrange;
+	int has_iwrange;
+
+	fgets (buffer, sizeof(buffer), fp);
+	fgets (buffer, sizeof(buffer), fp);
+	netproc_parse_stats_header(buffer, &prx_idx, &ptx_idx, &brx_idx, &btx_idx);
+
+	while (fgets(buffer, sizeof(buffer), fp)) {
+		/* getting interface name */
+		name = buffer;
+		while (g_ascii_isspace(name[0])) {
+			name++;
+		}
+
+		/* reading packet infomation */
+		status = netproc_parse_ifname(name);
+		netproc_parse_status(status, prx_idx, ptx_idx, &in_packets, &out_packets,
+				     brx_idx, btx_idx, &in_bytes, &out_bytes);
+
+		/* check interface hw_type */
+		bzero(&ifr, sizeof(ifr));
+		strncpy(ifr.ifr_name, name, strlen(name));
+  		ifr.ifr_name[strlen(name)+1] = '\0';
+		if (ioctl(sockfd, SIOCGIFHWADDR, &ifr)<0)
+			continue;
+
+		/* hw_types is not Ethernet and PPP */
+		if (ifr.ifr_hwaddr.sa_family!=ARPHRD_ETHER&&ifr.ifr_hwaddr.sa_family!=ARPHRD_PPP)
+			continue;
+
+		/* detecting new interface */
+		if ((devptr = netproc_netdevlist_find(*netdev_list, name))==NULL) {
+			/* check wireless device */
+			has_iwrange = (iw_get_range_info(iwsockfd, name, &iwrange)>=0);
+			if (!(has_iwrange) || (iwrange.we_version_compiled < 14))
+				netproc_netdevlist_add(netdev_list, name, in_bytes, in_packets, out_bytes, out_packets, FALSE);
+			else
+				netproc_netdevlist_add(netdev_list, name, in_bytes, in_packets, out_bytes, out_packets, TRUE);
+
+			devptr = netproc_netdevlist_find(*netdev_list, name);
+
+			/* MAC Address */
+			devptr->info.mac = g_strdup_printf ("%02X:%02X:%02X:%02X:%02X:%02X",
+					ifr.ifr_hwaddr.sa_data[0] & 0377,
+					ifr.ifr_hwaddr.sa_data[1] & 0377,
+					ifr.ifr_hwaddr.sa_data[2] & 0377,
+					ifr.ifr_hwaddr.sa_data[3] & 0377,
+					ifr.ifr_hwaddr.sa_data[4] & 0377,
+					ifr.ifr_hwaddr.sa_data[5] & 0377);
+		} else {
+			/* Setting device status and update flags */
+			if (devptr->info.recv_packets!=in_packets&&devptr->info.trans_packets!=out_packets) {
+				if (devptr->info.status!=NETDEV_STAT_BOTHRS)
+					devptr->info.updated = TRUE;
+			
+				devptr->info.status = NETDEV_STAT_BOTHRS;
+			} else if (devptr->info.recv_packets!=in_packets) {
+				if (devptr->info.status!=NETDEV_STAT_RECVDATA)
+					devptr->info.updated = TRUE;
+
+				devptr->info.status = NETDEV_STAT_RECVDATA;
+			} else if (devptr->info.trans_packets!=out_packets) {
+				if (devptr->info.status!=NETDEV_STAT_SENDDATA)
+					devptr->info.updated = TRUE;
+
+				devptr->info.status = NETDEV_STAT_SENDDATA;
+			} else {
+				if (devptr->info.status!=NETDEV_STAT_NORMAL)
+					devptr->info.updated = TRUE;
+
+				devptr->info.status = NETDEV_STAT_NORMAL;
+			}
+
+			/* Recording r/t information */
+			devptr->info.recv_bytes = in_bytes;
+			devptr->info.recv_packets = in_packets;
+			devptr->info.trans_bytes = out_bytes;
+			devptr->info.trans_packets = out_packets;
+
+			/* give device a life */
+			devptr->info.alive = TRUE;
+		}
+
+		/* Enable */
+		bzero(&ifr, sizeof(ifr));
+		strcpy(ifr.ifr_name, devptr->info.ifname);
+		ifr.ifr_name[IF_NAMESIZE - 1] = '\0';
+		if (ioctl(sockfd, SIOCGIFFLAGS, &ifr)>=0) {
+			devptr->info.flags = ifr.ifr_flags;
+			if (ifr.ifr_flags & IFF_UP) {
+				devptr->info.enable = TRUE;
+				devptr->info.updated = TRUE;
+			} else {
+				devptr->info.enable = FALSE;
+				devptr->info.updated = TRUE;
+			}
+
+			if (devptr->info.enable) {
+				/* Workaround for Atheros Cards */
+				if (strncmp(devptr->info.ifname, "ath", 3)==0)
+					wireless_refresh(iwsockfd, devptr->info.ifname);
+				
+				/* plug */
+				bzero(&ifr, sizeof(ifr));
+				strcpy(ifr.ifr_name, devptr->info.ifname);
+				ifr.ifr_name[IF_NAMESIZE - 1] = '\0';
+
+				edata.cmd = 0x0000000a;
+				ifr.ifr_data = (caddr_t)&edata;
+				if (ioctl(sockfd, SIOCETHTOOL, &ifr)<0) {
+					/* using IFF_RUNNING instead due to system doesn't have ethtool or working in non-root */
+					if (devptr->info.flags & IFF_RUNNING) {
+						if (!devptr->info.plug) {
+							devptr->info.plug = TRUE;
+							devptr->info.updated = TRUE;
+						}
+					} else if (devptr->info.plug) {
+						devptr->info.plug = FALSE;
+						devptr->info.updated = TRUE;
+					}
+				} else {
+					if (edata.data) {
+						if (!devptr->info.plug) {
+							devptr->info.plug = TRUE;
+							devptr->info.updated = TRUE;
+						}
+					} else if (devptr->info.plug) {
+						devptr->info.plug = FALSE;
+						devptr->info.updated = TRUE;
+					}
+				}
+
+				/* get network information */
+				if (devptr->info.enable&&devptr->info.plug) {
+					if (devptr->info.flags & IFF_RUNNING) {
+						/* release old information */
+						g_free(devptr->info.ipaddr);
+						g_free(devptr->info.bcast);
+						g_free(devptr->info.mask);
+
+						/* IP Address */
+						bzero(&ifr, sizeof(ifr));
+						strcpy(ifr.ifr_name, devptr->info.ifname);
+						ifr.ifr_name[IF_NAMESIZE - 1] = '\0';
+						if (ioctl(sockfd, SIOCGIFADDR, &ifr)<0)
+							devptr->info.ipaddr = g_strdup("0.0.0.0");
+						else
+							devptr->info.ipaddr = g_strdup(inet_ntoa(((struct sockaddr_in*)&ifr.ifr_addr)->sin_addr));
+
+						/* Point-to-Porint Address */
+						if (devptr->info.flags & IFF_POINTOPOINT) {
+							bzero(&ifr, sizeof(ifr));
+							strcpy(ifr.ifr_name, devptr->info.ifname);
+							ifr.ifr_name[IF_NAMESIZE - 1] = '\0';
+							if (ioctl(sockfd, SIOCGIFDSTADDR, &ifr)<0)
+								devptr->info.dest = NULL;
+							else
+								devptr->info.dest = g_strdup(inet_ntoa(((struct sockaddr_in*)&ifr.ifr_dstaddr)->sin_addr));
+						}
+
+						/* Broadcast */
+						if (devptr->info.flags & IFF_BROADCAST) {
+							bzero(&ifr, sizeof(ifr));
+							strcpy(ifr.ifr_name, devptr->info.ifname);
+							ifr.ifr_name[IF_NAMESIZE - 1] = '\0';
+							if (ioctl(sockfd, SIOCGIFBRDADDR, &ifr)<0)
+								devptr->info.bcast = NULL;
+							else
+								devptr->info.bcast = g_strdup(inet_ntoa(((struct sockaddr_in*)&ifr.ifr_broadaddr)->sin_addr));
+						}
+
+						/* Netmask */
+						bzero(&ifr, sizeof(ifr));
+						strcpy(ifr.ifr_name, devptr->info.ifname);
+						ifr.ifr_name[IF_NAMESIZE - 1] = '\0';
+						if (ioctl(sockfd, SIOCGIFNETMASK, &ifr)<0)
+							devptr->info.mask = NULL;
+						else
+							devptr->info.mask = g_strdup(inet_ntoa(((struct sockaddr_in*)&ifr.ifr_addr)->sin_addr));
+
+						/* Wireless Information */
+						if (devptr->info.wireless) {
+							struct wireless_config wconfig;
+
+							/* get wireless config */
+							if (iw_get_basic_config(iwsockfd, devptr->info.ifname, &wconfig)>=0) {
+								/* Protocol */
+								devptr->info.protocol = g_strdup(wconfig.name);
+								/* ESSID */
+								devptr->info.essid = g_strdup(wconfig.essid);
+
+								/* Signal Quality */
+								iw_get_stats(iwsockfd, devptr->info.ifname, &iws, &iwrange, has_iwrange);
+								devptr->info.quality = (int)rint((log (iws.qual.qual) / log (92)) * 100.0);
+							}
+						}
+
+						/* check problem connection */
+						if (strcmp(devptr->info.ipaddr, "0.0.0.0")==0) {
+							devptr->info.status = NETDEV_STAT_PROBLEM;
+							/* has connection problem  */
+							if (devptr->info.connected) {
+								devptr->info.connected = FALSE;
+								devptr->info.updated = TRUE;
+							}
+						} else if (!devptr->info.connected) {
+								devptr->info.status = NETDEV_STAT_NORMAL;
+								devptr->info.connected = TRUE;
+								devptr->info.updated = TRUE;
+						}
+					} else {
+						/* has connection problem  */
+						devptr->info.status = NETDEV_STAT_PROBLEM;
+						if (devptr->info.connected) {
+							devptr->info.connected = FALSE;
+							devptr->info.updated = TRUE;
+						}
+					}
+				}
+			}
+		}
+
+		devptr = NULL;
+		count++;
+	}
+
+	rewind(fp);
+	fflush(fp);
+
+	return count;
+}
+
+static void netproc_alive(NETDEVLIST_PTR netdev_list)
+{
+	NETDEVLIST_PTR ptr;
+
+	if (netdev_list==NULL) {
+		return;
+	}
+
+	ptr = netdev_list;
+	do {
+		ptr->info.alive = FALSE;
+		ptr = ptr->next;
+	} while(ptr!=NULL);
+}
+
+void netproc_devicelist_clear(NETDEVLIST_PTR *netdev_list)
+{
+	NETDEVLIST_PTR ptr;
+	NETDEVLIST_PTR prev_ptr;
+	NETDEVLIST_PTR del_ptr;
+
+	if (*netdev_list==NULL) {
+		return;
+	}
+
+	prev_ptr = NULL;
+	ptr = *netdev_list;
+	do {
+		if (!ptr->info.alive) { /* if device was removed */
+			if (prev_ptr!=NULL) {
+				ptr->prev->next = ptr->next;
+				ptr->next->prev = ptr->prev;
+			} else {
+				ptr->next->prev = NULL;
+				*netdev_list = ptr->next;
+			}
+
+			del_ptr = ptr;
+			ptr = ptr->next;
+			netproc_netdevlist_destroy(del_ptr);
+			g_free(del_ptr);
+		} else {
+			prev_ptr = ptr;
+			ptr = ptr->next;
+		}
+	} while(ptr!=NULL);
+}
+
+void netproc_listener(FNETD *fnetd)
+{
+	if (fnetd->sockfd) {
+		netproc_alive(fnetd->netdevlist);
+		fnetd->netdev_fp = netproc_open();
+		netproc_scandevice(fnetd->sockfd, fnetd->iwsockfd, fnetd->netdev_fp, &fnetd->netdevlist);
+		netproc_close(fnetd->netdev_fp);
+	}
+}
+
+#ifdef DEBUG
+void netproc_print(NETDEVLIST_PTR netdev_list)
+{
+	NETDEVLIST_PTR ptr;
+
+	if (netdev_list==NULL) {
+		return;
+	}
+
+	ptr = netdev_list;
+	do {
+		printf("%s: %d\n", ptr->info.ifname, ptr->info.status);
+		ptr = ptr->next;
+	} while(ptr!=NULL);
+}
+#endif
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/devproc.h lxpanel-0.5.3/src/plugins/netstat/devproc.h
--- lxpanel-0.5.3-orig/src/plugins/netstat/devproc.h	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/devproc.h	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,17 @@
+#ifndef HAVE_DEVPROC_H
+#define HAVE_DEVPROC_H
+
+struct linktest_value {
+        unsigned int    cmd;
+        unsigned int    data;
+};
+
+FILE *netproc_open(void);
+void netproc_close(FILE *fp);
+int netproc_netdevlist_clear(NETDEVLIST_PTR *netdev_list);
+int netproc_scandevice(int sockfd, int iwsockfd, FILE *fp, NETDEVLIST_PTR *netdev_list);
+void netproc_print(NETDEVLIST_PTR netdev_list);
+void netproc_listener(FNETD *fnetd);
+void netproc_devicelist_clear(NETDEVLIST_PTR *netdev_list);
+
+#endif
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/lxnm_client.c lxpanel-0.5.3/src/plugins/netstat/lxnm_client.c
--- lxpanel-0.5.3-orig/src/plugins/netstat/lxnm_client.c	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/lxnm_client.c	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,157 @@
+/**
+ * Copyright (c) 2008 LxDE Developers, see the file AUTHORS for details.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <glib.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <iwlib.h>
+#include "netstat.h"
+#include "lxnm_client.h"
+
+char*
+asc2hex(char *src)
+{
+    char *buf, *tmp;
+    char c[3];
+
+    buf = malloc(sizeof(char)+strlen(src)*2);
+    tmp = buf;
+
+    for (;*src!='\0';src++) {
+        sprintf(c, "%X", *src);
+        *tmp = c[0];
+        *(tmp+1) = c[1];
+        tmp += 2;
+    }
+
+    *tmp = '\0';
+    return buf;
+}
+
+static gboolean
+lxnm_read_channel(GIOChannel *gio, GIOCondition condition, gpointer data)
+{
+/*
+    GIOStatus ret;
+    GError *err = NULL;
+    gchar *msg;
+    gsize len;
+
+    if (condition & G_IO_HUP)
+        g_error ("Read end of pipe died!\n");
+
+    ret = g_io_channel_read_line (gio, &msg, &len, NULL, &err);
+    if (ret == G_IO_STATUS_ERROR)
+        g_error ("Error reading: %s\n", err->message);
+
+    printf ("Read %u bytes: %s\n", len, msg);
+
+    g_free (msg);
+*/
+    return TRUE;
+}
+
+GIOChannel *
+lxnm_socket(void)
+{
+    GIOChannel *gio;
+    int sockfd;
+    struct sockaddr_un sa_un;
+
+    /* create socket */
+    sockfd = socket(PF_UNIX, SOCK_STREAM, 0);
+    if (sockfd < 0) {
+        return NULL;
+    }
+
+    /* Initiate socket */
+    bzero(&sa_un, sizeof(sa_un));
+
+    /* setting UNIX socket */
+    sa_un.sun_family = AF_UNIX;
+    snprintf(sa_un.sun_path, sizeof(sa_un.sun_path), LXNM_SOCKET);
+
+    if (connect(sockfd, (struct sockaddr *) &sa_un, sizeof (sa_un)) < 0) {
+        return NULL;
+    }
+
+    gio = g_io_channel_unix_new(sockfd);
+    g_io_channel_set_encoding(gio, NULL, NULL);
+    g_io_add_watch(gio, G_IO_IN | G_IO_HUP, lxnm_read_channel, NULL);
+
+    return gio;
+}
+
+void lxnm_close(GIOChannel *gio)
+{
+    if (gio)
+        close(g_io_channel_unix_get_fd(gio));
+}
+
+void
+lxnm_send_command(GIOChannel *gio, int command, const char* cmdargs)
+{
+    char *msg;
+    gsize len;
+
+    if (gio==NULL)
+        return;
+
+    msg = g_strdup_printf("%d %s\n", command, cmdargs);
+    g_io_channel_write_chars(gio, msg, -1, &len, NULL);
+    g_io_channel_flush(gio, NULL);
+}
+
+char *lxnm_wireless_command_make(const char *ifname, const char *essid,
+								 const char *apaddr, const char *key,
+								 int protocol, int key_mgmt,
+								 int group, int pairwise)
+{
+    char *cmd_essid;
+    char *cmd_key;
+
+    if (essid==NULL) {
+        cmd_essid = g_strdup("NULL");
+    } else if (strlen(essid)==0) {
+        cmd_essid = g_strdup("NULL");
+    } else {
+        cmd_essid = essid;
+    }
+
+    if (strlen(key)==0) {
+        cmd_key = g_strdup("OFF");
+    } else {
+        cmd_key = key;
+    }
+
+    return g_strdup_printf("%s %s %s %s %d %d %d %d", ifname, asc2hex(cmd_essid),
+                                                   apaddr, asc2hex(cmd_key),
+                                                   protocol, key_mgmt,
+                                                   group, pairwise);
+}
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/lxnm_client.h lxpanel-0.5.3/src/plugins/netstat/lxnm_client.h
--- lxpanel-0.5.3-orig/src/plugins/netstat/lxnm_client.h	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/lxnm_client.h	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,23 @@
+#ifndef HAVE_NS_LXNM_H
+#define HAVE_NS_LXNM_H
+
+#include "netstat.h"
+
+#define LXNM_SOCKET "/var/run/lxnm.socket"
+
+/* Command */
+#define LXNM_VERSION                   0
+#define LXNM_ETHERNET_UP               1
+#define LXNM_ETHERNET_DOWN             2
+#define LXNM_ETHERNET_REPAIR           3
+#define LXNM_WIRELESS_UP               4
+#define LXNM_WIRELESS_DOWN             5
+#define LXNM_WIRELESS_REPAIR           6
+#define LXNM_WIRELESS_CONNECT          7
+
+char *asc2hex(char *src);
+GIOChannel *lxnm_socket(void);
+void lxnm_close(GIOChannel *gio);
+void lxnm_send_command(GIOChannel *gio, int command, const char* cmdargs);
+
+#endif
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/Makefile.am lxpanel-0.5.3/src/plugins/netstat/Makefile.am
--- lxpanel-0.5.3-orig/src/plugins/netstat/Makefile.am	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/Makefile.am	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,38 @@
+#if BUILD_LIBIW_PLUGINS
+
+INCLUDES = \
+    -I. \
+    -I$(top_srcdir)/src \
+    -DPACKAGE_DATA_DIR=\""$(datadir)"\" \
+    $(PACKAGE_CFLAGS) \
+    $(G_CAST_CHECKS)
+
+module_LTLIBRARIES = netstat.la
+
+moduledir = $(libdir)/lxpanel/plugins
+
+netstat_la_SOURCES = \
+        netstat.c \
+        netstat.h \
+        nsconfig.h \
+        devproc.c \
+        devproc.h \
+        statusicon.c \
+        statusicon.h \
+        wireless.c \
+        wireless.h \
+        lxnm_client.c \
+        lxnm_client.h \
+        passwd_gui.c \
+        passwd_gui.h
+
+netstat_la_LIBADD = -liw $(PACKAGE_LIBS)
+
+netstat_la_LDFLAGS = \
+    -module \
+    @LXPANEL_MODULE@
+
+install-exec-hook:
+	rm -f "$(moduledir)\*.la" *.a
+
+#endif
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/netstat.c lxpanel-0.5.3/src/plugins/netstat/netstat.c
--- lxpanel-0.5.3-orig/src/plugins/netstat/netstat.c	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/netstat.c	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,479 @@
+/**
+ * Copyright (c) 2008 LxDE Developers, see the file AUTHORS for details.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <string.h>
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <pthread.h>
+#include <iwlib.h>
+#include "nsconfig.h"
+#include "netstat.h"
+#include "lxnm_client.h"
+#include "statusicon.h"
+#include "passwd_gui.h"
+#include "devproc.h"
+#include "wireless.h"
+#include "panel.h"
+#include "misc.h"
+#include "plugin.h"
+#include "dbg.h"
+
+/* 1 second */
+#define NETSTAT_IFACE_POLL_DELAY 3000
+
+static int actionProcess(void *arg)
+{
+    ENTER;
+    RET(system((char *)arg));
+}
+
+/* menu handlers */
+static void ethernet_repair(GtkWidget *widget, netdev_info *ni)
+{
+    if (ni->ns->fixcmd) {
+        pthread_t actionThread;
+        char *fixcmd;
+
+        fixcmd = g_strdup_printf(ni->ns->fixcmd, ni->netdev_list->info.ifname);
+
+        pthread_create(&actionThread, NULL, actionProcess, fixcmd);
+    } else {
+        lxnm_send_command(ni->ns->fnetd->lxnmchannel, LXNM_ETHERNET_REPAIR, ni->netdev_list->info.ifname);
+    }
+}
+
+static void ethernet_down(GtkWidget *widget, netdev_info *ni)
+{
+    lxnm_send_command(ni->ns->fnetd->lxnmchannel, LXNM_ETHERNET_DOWN, ni->netdev_list->info.ifname);
+}
+
+static void wireless_connect(GtkWidget *widget, ap_setting *aps)
+{
+    char *cmdargs;
+
+    /* without encryption */
+    if (!aps->apinfo->haskey) {
+        cmdargs = lxnm_wireless_command_make(aps->ifname, aps->apinfo->essid, aps->apinfo->apaddr, "",
+                                   aps->apinfo->en_method, aps->apinfo->key_mgmt,
+                                   aps->apinfo->group, aps->apinfo->pairwise);
+        lxnm_send_command(aps->gio, LXNM_WIRELESS_CONNECT, cmdargs);
+        g_free(cmdargs);
+    } else {
+        /* with encryption */
+        if (aps->ni->netdev_list->info.pg!=NULL)
+            passwd_gui_destroy(aps->ni->netdev_list->info.pg);
+
+        /* record information for password dialog */
+        ap_setting *aps_new;
+        ap_info *apinfo;
+	apinfo = malloc(sizeof(ap_info));
+	if (aps->apinfo->essid==NULL)
+		apinfo->essid = NULL;
+	else
+		apinfo->essid = g_strdup(aps->apinfo->essid);
+
+	apinfo->apaddr = g_strdup(aps->apinfo->apaddr);
+	apinfo->quality = aps->apinfo->quality;
+	apinfo->en_method = aps->apinfo->en_method;
+	apinfo->pairwise = aps->apinfo->pairwise;
+	apinfo->group = aps->apinfo->group;
+	apinfo->key_mgmt = aps->apinfo->key_mgmt;
+	apinfo->haskey = aps->apinfo->haskey;
+
+        aps_new = g_new0(ap_setting, 1);
+        aps_new->ni = aps->ni;
+        aps_new->gio = aps->gio;
+        aps_new->ifname = g_strdup(aps->ifname);
+        aps_new->apinfo = apinfo;
+        /* create dialog window for typing password */
+        aps->ni->netdev_list->info.pg = passwd_gui_new(aps_new);
+        //passwd_gui_set_style(aps->ni->netdev_list->info.pg, gtk_style_new());
+    }
+}
+
+static GtkWidget *
+wireless_menu(netdev_info *ni)
+{
+    APLIST *aplist;
+    APLIST *ptr;
+    GtkWidget *menu;
+    GtkWidget *menu_item;
+    GtkWidget *wireless_label;
+
+    /* AP status widget */
+    GtkWidget *item_box;
+    GtkWidget *essid_label;
+    GtkWidget *lockicon;
+    GtkWidget *signal_quality;
+    gdouble quality_per;
+    ap_setting *aps;
+
+    /* create menu */
+    menu = gtk_menu_new();
+	g_signal_connect(menu, "selection-done", gtk_widget_destroy, NULL);
+
+    /* Scanning AP */
+    aplist = wireless_scanning(ni->ns->fnetd->iwsockfd, ni->netdev_list->info.ifname);
+    if (aplist!=NULL) {
+        /* release AP list after menu */
+        g_object_weak_ref(menu, wireless_aplist_free, aplist);
+        ptr = aplist;
+        do {
+            /* skip hidden AP with Encryption */
+            if (ptr->info->haskey&&ptr->info->essid==NULL) {
+                /* handle next AP */
+                ptr = ptr->next;
+				continue;
+            }
+
+            aps = g_new0(ap_setting, 1);
+            aps->ni = ni;
+            aps->gio = ni->ns->fnetd->lxnmchannel;
+            aps->ifname = ni->netdev_list->info.ifname;
+			aps->apinfo = ptr->info;
+
+            /* create a new item */
+            menu_item = gtk_menu_item_new();
+            item_box = gtk_hbox_new(FALSE, 0);
+
+            /* Encryption */
+            if (aps->apinfo->haskey) {
+                lockicon = gtk_image_new_from_file(ICONS_WL_LOCK);
+                gtk_box_pack_start(GTK_BOX(item_box), lockicon, FALSE, FALSE, 0);
+            }
+
+            /* ESSID */
+            if (aps->apinfo->essid==NULL)
+                essid_label = gtk_label_new(_("<Hidden Access Point>"));
+            else
+                essid_label = gtk_label_new(aps->apinfo->essid);
+
+            gtk_label_set_justify(essid_label, GTK_JUSTIFY_LEFT);
+            gtk_misc_set_padding(GTK_MISC(essid_label), 2, 0);
+            gtk_box_pack_start(GTK_BOX(item_box), essid_label, TRUE, FALSE, 0);
+
+            /* Quality */
+            quality_per = (gdouble)((double)aps->apinfo->quality/100);
+            if (quality_per>1)
+                quality_per = 1;
+            else if (quality_per<0)
+                quality_per = 0;
+
+            signal_quality = gtk_progress_bar_new();
+            gtk_widget_set_size_request(signal_quality, 100, -1);
+            gtk_progress_bar_set_orientation(signal_quality, GTK_PROGRESS_LEFT_TO_RIGHT);
+            gtk_progress_bar_set_fraction(signal_quality, quality_per);
+            gtk_box_pack_start(GTK_BOX(item_box), signal_quality, FALSE, FALSE, 0);
+
+            /* add this item to menu */
+            gtk_container_add(GTK_CONTAINER(menu_item), item_box);
+            gtk_menu_append(GTK_MENU(menu), menu_item);
+            g_signal_connect(G_OBJECT(menu_item), "activate", G_CALLBACK(wireless_connect), aps);
+            g_object_weak_ref(menu_item, g_free, aps);
+
+			/* handle next AP */
+            ptr = ptr->next;
+        } while(ptr!=NULL);
+    } else {
+        /* we do not found any wireless networks */
+        menu_item = gtk_menu_item_new();
+        wireless_label = gtk_label_new(_("Wireless Networks not found in range"));
+        gtk_label_set_justify(wireless_label, GTK_JUSTIFY_LEFT);
+        gtk_widget_set_sensitive(GTK_WIDGET(wireless_label), FALSE);
+        gtk_container_add(GTK_CONTAINER(menu_item), wireless_label);
+        gtk_menu_append(GTK_MENU(menu), menu_item);
+    }
+
+    gtk_widget_show_all(menu);
+
+    return menu;
+}
+
+static gint menupopup(GtkWidget *widget, GdkEvent *event, netdev_info *ni)
+{
+    GdkEventButton *event_button;
+
+    g_return_val_if_fail (event != NULL, FALSE);
+
+    if (event->type == GDK_BUTTON_PRESS) {
+        event_button = (GdkEventButton *) event;
+        if (event_button->button == 1) {
+            /* wireless device */
+            if (ni->netdev_list->info.wireless) {
+                gtk_menu_popup(wireless_menu(ni), NULL, NULL, NULL, NULL, event_button->button, event_button->time);
+            }
+            return TRUE;
+        } else if (event_button->button == 3) {
+            GtkWidget *menu;
+            GtkWidget *menu_item;
+
+            /* create menu */
+            menu = gtk_menu_new();
+
+            /* Repair */
+            menu_item = gtk_menu_item_new_with_label(_("Repair"));
+            gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
+            g_signal_connect(G_OBJECT(menu_item), "activate", G_CALLBACK(ethernet_repair), ni);
+
+            /* interface down */
+            menu_item = gtk_menu_item_new_with_label(_("Disable"));
+            gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
+            g_signal_connect(G_OBJECT(menu_item), "activate", G_CALLBACK(ethernet_down), ni);
+
+            gtk_widget_show_all(menu);
+
+            gtk_menu_popup(menu, NULL, NULL, NULL, NULL, event_button->button, event_button->time);
+            return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+static char *select_icon(gboolean plug, gboolean connected, int stat)
+{
+    if (!plug)
+        return ICONS_DISCONNECT;
+
+    switch(stat) {
+        case NETDEV_STAT_NORMAL:
+            return ICONS_CONNECTED;
+            break;
+        case NETDEV_STAT_PROBLEM:
+            return ICONS_PROBLEM;
+            break;
+        case NETDEV_STAT_RENEW:
+            return ICONS_RENEW;
+            break;
+        case NETDEV_STAT_BOTHRS:
+            return ICONS_BOTHRS;
+            break;
+        case NETDEV_STAT_SENDDATA:
+            return ICONS_SENDDATA;
+            break;
+        case NETDEV_STAT_RECVDATA:
+            return ICONS_RECVDATA;
+            break;
+    }
+}
+
+static void refresh_systray(netstat *ns, NETDEVLIST_PTR netdev_list)
+{
+    NETDEVLIST_PTR ptr;
+    char *tooltip;
+
+    if (netdev_list==NULL) {
+        return;
+    }
+
+    ptr = netdev_list;
+    do {
+        if (!ptr->info.enable) {
+            if (ptr->info.status_icon!=NULL) {
+                set_statusicon_visible(ptr->info.status_icon, FALSE);
+            }
+        } else if (ptr->info.updated) {
+            if (!ptr->info.plug) {
+                if (ptr->info.wireless)
+                    tooltip = g_strdup_printf("%s\n  %s", ptr->info.ifname, _("Wireless Connection has no connectivity"));
+				else
+                    tooltip = g_strdup_printf("%s\n  %s", ptr->info.ifname, _("Network cable is plugged out"));
+            } else if (!ptr->info.connected)
+                tooltip = g_strdup_printf("%s\n  %s", ptr->info.ifname, _("Connection has limited or no connectivity"));
+            else if (ptr->info.flags & IFF_POINTOPOINT)
+                tooltip = g_strdup_printf("%s\n  %s\t%s\n  %s\t%s\n  %s\t%s\n\n %s(%s/%s)\n   %lu/%lu %s\n   %lu/%lu %s",
+                                                                 ptr->info.ifname,
+                                                                _("IP Address:"), ptr->info.ipaddr,
+                                                                _("Remote IP:"), ptr->info.dest,
+                                                                _("Netmask:"), ptr->info.mask,
+                                                                _("Activity"), _("Sent"),_("Received"),
+                                                                ptr->info.trans_bytes, ptr->info.recv_bytes, _("bytes"),
+                                                                ptr->info.trans_packets, ptr->info.recv_packets, _("packets"));
+            else if (ptr->info.wireless)
+                tooltip = g_strdup_printf("%s(%s) - %s(%d%%)\n  %s\t%s\n  %s\t%s\n  %s\t%s\n  %s\t%s\n  %s\t%s\n\n %s(%s/%s)\n   %lu/%lu %s\n   %lu/%lu %s",
+                                                                ptr->info.ifname, _("Wireless"),
+                                                                ptr->info.essid, ptr->info.quality,
+                                                                _("Protocol:"), ptr->info.protocol,
+                                                                _("IP Address:"), ptr->info.ipaddr,
+                                                                _("Broadcast:"), ptr->info.bcast,
+                                                                _("Netmask:"), ptr->info.mask,
+                                                                _("HW Address:"), ptr->info.mac,
+                                                                _("Activity"), _("Sent"), _("Received"),
+                                                                ptr->info.trans_bytes, ptr->info.recv_bytes, _("bytes"),
+                                                                ptr->info.trans_packets, ptr->info.recv_packets, _("packets"));
+
+            else
+                tooltip = g_strdup_printf("%s\n  %s\t%s\n  %s\t%s\n  %s\t%s\n  %s\t%s\n\n %s(%s/%s)\n   %lu/%lu %s\n   %lu/%lu %s",
+                                                                ptr->info.ifname,
+                                                                _("IP Address:"), ptr->info.ipaddr,
+                                                                _("Broadcast:"), ptr->info.bcast,
+                                                                _("Netmask:"), ptr->info.mask,
+                                                                _("HW Address:"), ptr->info.mac,
+                                                                _("Activity"), _("Sent"), _("Received"),
+                                                                ptr->info.trans_bytes, ptr->info.recv_bytes, _("bytes"),
+                                                                ptr->info.trans_packets, ptr->info.recv_packets, _("packets"));
+
+            /* status icon doesn't exist  */
+            if (ptr->info.status_icon==NULL) {
+                netdev_info *ni;
+                ni = malloc(sizeof(netdev_info));
+                ni->ns = ns;
+                ni->netdev_list = ptr;
+
+                ptr->info.status_icon = create_statusicon(ns->mainw, select_icon(ptr->info.plug, ptr->info.connected, ptr->info.status), tooltip);
+                g_signal_connect(ptr->info.status_icon->main, "button_press_event", G_CALLBACK(menupopup), ni);
+                g_object_weak_ref(ptr->info.status_icon->main, g_free, ni);
+            } else {
+                set_statusicon_tooltips(ptr->info.status_icon, tooltip);
+                set_statusicon_image_from_file(ptr->info.status_icon, select_icon(ptr->info.plug, ptr->info.connected, ptr->info.status));
+                set_statusicon_visible(ptr->info.status_icon, TRUE);
+            }
+            g_free(tooltip);
+        }
+        ptr = ptr->next;
+    } while(ptr!=NULL);
+}
+
+static gboolean refresh_devstat(netstat *ns)
+{
+    netproc_listener(ns->fnetd);
+#ifdef DEBUG
+    netproc_print(ns->fnetd->netdevlist);
+#endif
+    refresh_systray(ns, ns->fnetd->netdevlist);
+    netproc_devicelist_clear(&ns->fnetd->netdevlist);
+    return TRUE;
+}
+
+/* Plugin constructor */
+static void netstat_destructor(Plugin *p)
+{
+    netstat *ns = (netstat *) p->priv;
+
+    ENTER;
+    g_source_remove(ns->ttag);
+    netproc_netdevlist_clear(&ns->fnetd->netdevlist);
+    /* The widget is destroyed in plugin_stop().
+    gtk_widget_destroy(ns->mainw);
+    */
+    lxnm_close(ns->fnetd->lxnmchannel);
+    close(ns->fnetd->sockfd);
+    close(ns->fnetd->iwsockfd);
+    g_free(ns->fnetd);
+    g_free(ns->fixcmd);
+    g_free(ns);
+    RET();
+}
+
+static int netstat_constructor(Plugin *p, char **fp)
+{
+    netstat *ns;
+    line s;
+
+    ENTER;
+    s.len = 256;
+    ns = g_new0(netstat, 1);
+    g_return_val_if_fail(ns != NULL, 0);
+    p->priv = ns;
+	ns->fixcmd = NULL;
+
+    if( fp ) {
+        while (lxpanel_get_line(fp, &s) != LINE_BLOCK_END) {
+            if (s.type == LINE_NONE) {
+                ERR( "netstat: illegal token %s\n", s.str);
+                goto error;
+            }
+            if (s.type == LINE_VAR) {
+                if (!g_ascii_strcasecmp(s.t[0], "FixCommand"))
+                    ns->fixcmd = g_strdup(s.t[1]);
+                else {
+                    ERR( "netstat: unknown var %s\n", s.t[0]);
+                    goto error;
+                }
+            } else {
+                ERR( "netstat: illegal in this context %s\n", s.str);
+                goto error;
+            }
+        }
+    }
+
+    /* initializing */
+    ns->fnetd = malloc(sizeof(FNETD));
+    ns->fnetd->netdevlist = NULL;
+    ns->fnetd->sockfd = socket(AF_INET, SOCK_DGRAM, 0);
+    ns->fnetd->iwsockfd = iw_sockets_open();
+    ns->fnetd->lxnmchannel = lxnm_socket();
+
+    /* main */
+    ns->mainw = p->panel->my_box_new(FALSE, 1);
+    gtk_widget_show_all(ns->mainw);
+
+    /* Initializing network device list*/
+    ns->fnetd->netdev_fp = netproc_open();
+    ns->fnetd->dev_count = netproc_netdevlist_clear(&ns->fnetd->netdevlist);
+    ns->fnetd->dev_count = netproc_scandevice(ns->fnetd->sockfd, ns->fnetd->iwsockfd, ns->fnetd->netdev_fp, &ns->fnetd->netdevlist);
+    netproc_close(ns->fnetd->netdev_fp);
+    refresh_systray(ns, ns->fnetd->netdevlist);
+
+    ns->ttag = g_timeout_add(NETSTAT_IFACE_POLL_DELAY, (GSourceFunc)refresh_devstat, ns);
+
+    p->pwid = gtk_event_box_new();
+    GTK_WIDGET_SET_FLAGS(p->pwid, GTK_NO_WINDOW);
+    gtk_container_add((GtkContainer*)p->pwid, ns->mainw);
+
+    RET(1);
+error:
+    g_free(ns->fnetd);
+    g_free(ns->fixcmd);
+    g_free(ns);
+    RET(0);
+}
+
+static void orientation_changed(Plugin* p)
+{
+    netstat *ns = (netstat *)p->priv;
+    GtkBox* newbox;
+    newbox = GTK_BOX(recreate_box(GTK_BOX(ns->mainw), p->panel->orientation));
+    if( GTK_WIDGET(newbox) != ns->mainw ) {
+        /* Since the old box has been destroyed,
+        we need to re-add the new box to the container */
+        ns->mainw = GTK_WIDGET(newbox);
+        gtk_container_add(GTK_CONTAINER(p->pwid), ns->mainw);
+    }
+}
+
+PluginClass netstat_plugin_class = {
+    PLUGINCLASS_VERSIONING,
+
+    type : "netstat",
+    name : N_("Manage Networks"),
+    version: "1.0",
+    description : N_("Monitor and Manage networks"),
+
+    constructor : netstat_constructor,
+    destructor  : netstat_destructor,
+    panel_configuration_changed : orientation_changed,
+    config : NULL,
+    save : NULL
+};
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/netstat.h lxpanel-0.5.3/src/plugins/netstat/netstat.h
--- lxpanel-0.5.3-orig/src/plugins/netstat/netstat.h	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/netstat.h	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,90 @@
+#ifndef HAVE_FNETDAEMON_H
+#define HAVE_FNETDAEMON_H
+
+#include <stdio.h>
+#include <netinet/in.h>
+#include <gtk/gtk.h>
+#include "wireless.h"
+
+#define NETDEV_STAT_NORMAL	0
+#define NETDEV_STAT_PROBLEM	1
+#define NETDEV_STAT_RENEW	2
+#define NETDEV_STAT_BOTHRS	3
+#define NETDEV_STAT_SENDDATA	4
+#define NETDEV_STAT_RECVDATA	5
+
+/* forward declaration for UI interaction. */
+struct statusicon;
+
+struct pgui {
+    GtkWidget *dlg;
+    GtkWidget *pentry;
+};
+
+typedef struct {
+	char *ifname;
+	char *mac;
+	char *ipaddr;
+	char *dest;
+	char *bcast;
+	char *mask;
+	int flags;
+	gboolean alive;
+	gboolean enable;
+	gboolean updated;
+	gboolean plug;
+	gboolean connected;
+
+	/* wireless */
+	gboolean wireless;
+	char *protocol;
+	char *essid;
+	int *quality;
+	struct pgui *pg;
+
+	int status;
+	gulong recv_bytes;
+	gulong recv_packets;
+	gulong trans_bytes;
+	gulong trans_packets;
+
+	/* systray */
+	struct statusicon *status_icon;
+} netdevice;
+
+typedef struct netdevice_node {
+	netdevice             info;
+	struct netdevice_node *prev;
+	struct netdevice_node *next;
+} NETDEVLIST;
+typedef NETDEVLIST *NETDEVLIST_PTR;
+
+typedef struct {
+	int dev_count;
+	int sockfd;
+	int iwsockfd;
+	GIOChannel *lxnmchannel;
+	FILE *netdev_fp;
+	NETDEVLIST_PTR netdevlist;
+} FNETD;
+
+typedef struct {
+    GtkWidget *mainw;
+    FNETD *fnetd;
+    char *fixcmd;
+    gint ttag;
+} netstat;
+
+typedef struct {
+    netstat *ns;
+    NETDEVLIST_PTR netdev_list;
+} netdev_info;
+
+typedef struct {
+	netdev_info *ni;
+	GIOChannel *gio;
+	ap_info *apinfo;
+	char *ifname;
+} ap_setting;
+
+#endif
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/nsconfig.h lxpanel-0.5.3/src/plugins/netstat/nsconfig.h
--- lxpanel-0.5.3-orig/src/plugins/netstat/nsconfig.h	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/nsconfig.h	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,17 @@
+#ifndef HAVE_NSCONFIG_H
+#define HAVE_NSCONFIG_H
+
+#define RESOURCE_DIR PACKAGE_DATA_DIR "/lxpanel/images"
+#define ICONS_CONNECTED		RESOURCE_DIR "/ns-connected.png"
+#define ICONS_DISCONNECT	RESOURCE_DIR "/ns-disconnect.png"
+#define ICONS_PROBLEM		RESOURCE_DIR "/ns-problem.png"
+#define ICONS_RENEW		RESOURCE_DIR "/ns-renew.png"
+#define ICONS_BOTHRS		RESOURCE_DIR "/ns-bothrs.png"
+#define ICONS_SENDDATA		RESOURCE_DIR "/ns-senddata.png"
+#define ICONS_RECVDATA		RESOURCE_DIR "/ns-recvdata.png"
+#define ICONS_WL_CONNECTED	RESOURCE_DIR "/ns-wlconnected.png"
+#define ICONS_WL_DISCONNECT	RESOURCE_DIR "/ns-wldisconnect.png"
+#define ICONS_WL_RENEW		RESOURCE_DIR "/ns-wlrenew.png"
+#define ICONS_WL_LOCK		RESOURCE_DIR "/ns-lock.png"
+
+#endif
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/passwd_gui.c lxpanel-0.5.3/src/plugins/netstat/passwd_gui.c
--- lxpanel-0.5.3-orig/src/plugins/netstat/passwd_gui.c	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/passwd_gui.c	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,118 @@
+/**
+ * Copyright (c) 2008 LxDE Developers, see the file AUTHORS for details.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+#include <glib.h>
+#include <glib/gi18n.h>
+#include "netstat.h"
+#include "lxnm_client.h"
+#include "wireless.h"
+#include "passwd_gui.h"
+
+struct passwd_resp {
+    ap_setting *aps;
+    GtkEntry *entry;
+};
+
+static void passwd_gui_on_response(GtkDialog* dlg, gint response, struct passwd_resp *pr)
+{
+    char *cmdargs;
+    //GtkEntry* entry = (GtkEntry*)user_data;
+
+    if(G_LIKELY(response == GTK_RESPONSE_OK)) {
+        cmdargs = lxnm_wireless_command_make(pr->aps->ifname, pr->aps->apinfo->essid,
+                                             pr->aps->apinfo->apaddr, gtk_entry_get_text(pr->entry),
+                                             pr->aps->apinfo->en_method, pr->aps->apinfo->key_mgmt,
+                                             pr->aps->apinfo->group, pr->aps->apinfo->pairwise);
+        lxnm_send_command(pr->aps->gio, LXNM_WIRELESS_CONNECT, cmdargs);
+    	g_free(cmdargs);
+    }
+
+    g_source_remove_by_user_data(pr->entry); /* remove timeout */
+    gtk_widget_destroy((GtkWidget*)dlg);
+}
+
+void passwd_gui_set_style(struct pgui *pg, GtkStyle *style)
+{
+    gtk_widget_set_style(pg->dlg, style);
+}
+
+void passwd_gui_free(struct passwd_resp *pr)
+{
+    g_free(pr->aps->ifname);
+    g_free(pr->aps->apinfo->essid);
+    g_free(pr->aps->apinfo->apaddr);
+    g_free(pr->aps->apinfo);
+    g_free(pr->aps);
+    g_free(pr);
+}
+
+void passwd_gui_destroy(struct pgui *pg)
+{
+    gtk_widget_destroy((GtkWidget*)pg->dlg);
+}
+
+struct pgui *passwd_gui_new(ap_setting *aps)
+{
+    GtkWidget *msg, *inputlabel;
+    GtkWidget *inputbox;
+    struct pgui *pwdgui;
+    struct passwd_resp *pr;
+
+    pwdgui = malloc(sizeof(struct pgui));
+    pr = malloc(sizeof(struct passwd_resp));
+
+    /* create dialog */
+    pwdgui->dlg = gtk_dialog_new_with_buttons(_("Setting Encryption Key"),
+                                       NULL,
+                                       GTK_DIALOG_NO_SEPARATOR,
+                                       GTK_STOCK_OK, GTK_RESPONSE_OK,
+                                       GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+                                       NULL );
+    gtk_dialog_set_default_response(GTK_WINDOW(pwdgui->dlg), GTK_RESPONSE_OK);
+    gtk_window_set_position(GTK_WINDOW(pwdgui->dlg), GTK_WIN_POS_CENTER);
+
+    /* messages */
+    msg = gtk_label_new(_("This wireless network was encrypted.\nYou must have the encryption key."));
+    gtk_box_pack_start(((GtkDialog*)(pwdgui->dlg))->vbox, msg, FALSE, FALSE, 8);
+
+    /* entry Box */
+    inputbox = gtk_hbox_new(FALSE, 0);
+    inputlabel = gtk_label_new(_("Encryption Key:"));
+    gtk_box_pack_start(GTK_BOX(inputbox), inputlabel, TRUE, TRUE, 4);
+    pwdgui->pentry = gtk_entry_new();
+    gtk_entry_set_visibility(GTK_ENTRY(pwdgui->pentry), FALSE);
+    gtk_entry_set_activates_default(GTK_ENTRY(pwdgui->pentry), TRUE);
+    gtk_box_pack_start(GTK_BOX(inputbox), pwdgui->pentry, FALSE, FALSE, 4);
+    gtk_box_pack_start(((GtkDialog*)(pwdgui->dlg))->vbox, inputbox, FALSE, FALSE, 8);
+
+    /* passwd_resp structure */
+    pr->aps = aps;
+    pr->entry = pwdgui->pentry;
+
+    /* g_signal */
+    g_signal_connect(pwdgui->dlg, "response", G_CALLBACK(passwd_gui_on_response), pr);
+    g_object_weak_ref(pwdgui->dlg, passwd_gui_free, pr);
+
+    gtk_widget_show_all(pwdgui->dlg);
+
+    return pwdgui;
+}
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/passwd_gui.h lxpanel-0.5.3/src/plugins/netstat/passwd_gui.h
--- lxpanel-0.5.3-orig/src/plugins/netstat/passwd_gui.h	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/passwd_gui.h	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,9 @@
+#ifndef HAVE_NS_PASSWDGUI_H
+#define HAVE_NS_PASSWDGUI_H
+
+#include "netstat.h"
+
+struct pgui *passwd_gui_new(ap_setting *aps);
+void passwd_gui_set_style(struct pgui *pg, GtkStyle *style);
+void passwd_gui_destroy(struct pgui *pg);
+#endif
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/statusicon.c lxpanel-0.5.3/src/plugins/netstat/statusicon.c
--- lxpanel-0.5.3-orig/src/plugins/netstat/statusicon.c	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/statusicon.c	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,85 @@
+/**
+ * Copyright (c) 2008 LxDE Developers, see the file AUTHORS for details.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <string.h>
+#include <glib.h>
+#include <glib/gi18n.h>
+#include "netstat.h"
+#include "statusicon.h"
+
+struct statusicon *create_statusicon(GtkWidget *box, const char *filename,
+        const char *tooltips)
+{
+    struct statusicon *newicon;
+    newicon = malloc(sizeof(struct statusicon));
+
+    /* main */
+    newicon->main = gtk_event_box_new();
+
+    GTK_WIDGET_SET_FLAGS(newicon->main, GTK_NO_WINDOW);
+    gtk_widget_add_events(newicon->main, GDK_BUTTON_PRESS_MASK);
+    gtk_widget_set_size_request(newicon->main, 24, 24);
+    gtk_box_pack_start(GTK_BOX(box), newicon->main, TRUE, TRUE, 0);
+
+    /* icon */
+    newicon->icon = gtk_image_new_from_file(filename);
+    gtk_container_add(GTK_CONTAINER(newicon->main), newicon->icon);
+    gtk_widget_show_all(newicon->main);
+
+    /* tooltip */
+    newicon->tooltips = gtk_tooltips_new();
+#if GLIB_CHECK_VERSION( 2, 10, 0 )
+    g_object_ref_sink(newicon->tooltips);
+#else
+    g_object_ref(newicon->tooltips);
+    gtk_object_sink(newicon->tooltips);
+#endif
+    gtk_tooltips_set_tip(newicon->tooltips, newicon->main, tooltips, NULL);
+
+    return newicon;
+}
+
+void statusicon_destroy(struct statusicon *icon)
+{
+	if (icon==NULL)
+        return;
+
+    g_object_unref(icon->tooltips);
+    gtk_widget_destroy(GTK_WIDGET(icon->icon));
+    gtk_widget_destroy(GTK_WIDGET(icon->main));
+    g_free(icon);
+}
+
+
+void set_statusicon_image_from_file(struct statusicon *widget, const char *filename)
+{
+    gtk_image_set_from_file(widget->icon, filename);
+}
+
+void set_statusicon_tooltips(struct statusicon *widget, const char *tooltips)
+{
+    gtk_tooltips_set_tip(widget->tooltips, widget->main, tooltips, NULL);
+}
+
+void set_statusicon_visible(struct statusicon *widget, gboolean b)
+{
+    if (b)
+        gtk_widget_show(widget->main);
+    else
+        gtk_widget_hide(widget->main);
+}
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/statusicon.h lxpanel-0.5.3/src/plugins/netstat/statusicon.h
--- lxpanel-0.5.3-orig/src/plugins/netstat/statusicon.h	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/statusicon.h	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,20 @@
+#ifndef HAVE_NS_STATUSICON_H
+#define HAVE_NS_STATUSICON_H
+
+#include "netstat.h"
+#include <gtk/gtk.h>
+
+struct statusicon {
+        GtkWidget *main;
+        GtkWidget *icon;
+        GtkTooltips *tooltips;
+};
+
+struct statusicon *create_statusicon(GtkWidget *box, const char *filename,
+		const char *tooltips);
+void statusicon_destroy(struct statusicon *icon);
+void set_statusicon_image_from_file(struct statusicon *widget, const char *filename);
+void set_statusicon_tooltips(struct statusicon *widget, const char *tooltips);
+void set_statusicon_visible(struct statusicon *widget, gboolean b);
+
+#endif
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/wireless.c lxpanel-0.5.3/src/plugins/netstat/wireless.c
--- lxpanel-0.5.3-orig/src/plugins/netstat/wireless.c	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/wireless.c	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,468 @@
+/**
+ * Copyright (c) 2008 LxDE Developers, see the file AUTHORS for details.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <stdio.h>
+#include <string.h>
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <sys/time.h>
+#include <iwlib.h>
+#include "netstat.h"
+#include "wireless.h"
+
+/*
+static const char * iw_ie_cypher_name[] = {
+	"none",
+	"WEP-40",
+	"TKIP",
+	"WRAP",
+	"CCMP",
+	"WEP-104",
+};
+
+static const char * iw_ie_key_mgmt_name[] = {
+	"none",
+	"802.1x",
+	"PSK",
+};
+*/
+
+void wireless_aplist_free(APLIST *aplist)
+{
+	APLIST *ptr;
+	APLIST *delptr;
+
+    if (aplist!=NULL) {
+        ptr = aplist;
+        do {
+			g_free(ptr->info->essid);
+			g_free(ptr->info->apaddr);
+			g_free(ptr->info);
+
+            delptr = ptr;
+            ptr = ptr->next;
+			g_free(delptr);
+        } while(ptr!=NULL);
+    }
+}
+
+void 
+wireless_gen_ie(ap_info *info, unsigned char *buffer, int ielen)
+{
+	int offset = 2;
+	int count;
+	int i;
+	unsigned char wpa1_oui[3] = {0x00, 0x50, 0xf2};
+	unsigned char wpa2_oui[3] = {0x00, 0x0f, 0xac};
+	unsigned char *wpa_oui;
+
+	/* check IE type */
+	switch(buffer[0]) {
+		case 0xdd: /* WPA or else */
+			wpa_oui = wpa1_oui;
+
+			if((ielen < 8)
+				|| (memcmp(&buffer[offset], wpa_oui, 3) != 0)
+				|| (buffer[offset + 3] != 0x01)) {
+				if (info->haskey)
+					info->en_method = NS_WIRELESS_AUTH_WEP;
+				else
+					info->en_method = NS_WIRELESS_AUTH_OFF;
+
+				info->key_mgmt = NS_IW_IE_KEY_MGMT_NONE;
+				info->group = NS_IW_IE_CIPHER_NONE;
+				info->pairwise = NS_IW_IE_CIPHER_NONE;
+
+				return;
+			}
+
+			/* OUI and 0x01 */
+			offset += 4;
+			break;
+
+		case 0x30: /* IEEE 802.11i/WPA2 */ 
+			wpa_oui = wpa2_oui;
+			break;
+
+		default: /* Unknown */
+			if (info->haskey)
+				info->en_method = NS_WIRELESS_AUTH_WEP;
+			else
+				info->en_method = NS_WIRELESS_AUTH_OFF;
+
+			info->key_mgmt = NS_IW_IE_KEY_MGMT_NONE;
+			info->group = NS_IW_IE_CIPHER_NONE;
+			info->pairwise = NS_IW_IE_CIPHER_NONE;
+			return;
+	}
+
+	/* assume TKIP */
+	info->en_method = NS_WIRELESS_AUTH_WPA;
+	info->key_mgmt = NS_IW_IE_KEY_MGMT_NONE;
+	info->group = NS_IW_IE_CIPHER_TKIP;
+	info->pairwise = NS_IW_IE_CIPHER_TKIP;
+
+	/* 2 bytes for version number (little endian) */
+	offset += 2;
+
+	/* check group cipher for short IE */
+	if ((offset+4) > ielen) {
+		/* this is a short IE, we can assume TKIP/TKIP. */
+		info->group = NS_IW_IE_CIPHER_TKIP;
+		info->pairwise = NS_IW_IE_CIPHER_TKIP;
+		return;
+	}
+
+	/* 4 Bytes for group cipher information [3 bytes][1 Byte] */
+	if(memcmp(&buffer[offset], wpa_oui, 3)!=0) {
+		/* the group cipher is proprietary */
+		info->group = NS_IW_IE_CIPHER_NONE;
+	} else {
+		/* pick a byte for type of group cipher */
+		info->group = buffer[offset+3];
+	}
+	offset += 4;
+
+	/* check pairwise cipher for short IE */
+	if ((offset+2) > ielen) {
+		/* this is a short IE, we can assume TKIP. */
+		info->pairwise = NS_IW_IE_CIPHER_TKIP;
+		return;
+	}
+
+	/* 2 bytes for number of pairwise ciphers (little endian) */
+	count = buffer[offset] | (buffer[offset + 1] << 8);
+	offset += 2;
+
+	/* if we are done */
+	if ((offset+4*count) > ielen) {
+		return;
+	}
+
+	/* choose first cipher of pairwise ciphers to use,
+	 * FIXME: Let user decide the cipher is the best way. */
+	for(i=0;i<count;i++) {
+		if(memcmp(&buffer[offset], wpa_oui, 3)==0) {
+			/* pick a byte for type of group cipher */
+			info->pairwise = buffer[offset+3];
+		}
+		offset += 4;
+    }
+
+	/* check authentication suites */
+	if ((offset+2) > ielen) {
+		/* this is a short IE, we can assume TKIP. */
+		info->key_mgmt = NS_IW_IE_KEY_MGMT_NONE;
+		return;
+	}
+
+	/* 2 bytes for number of authentication suites (little endian) */
+	count = buffer[offset] | (buffer[offset + 1] << 8);
+	offset += 2;
+
+	/* if we are done */
+	if ((offset+4*count) > ielen) {
+		return;
+	}
+
+	/* choose first key_mgmt of authentication suites to use,
+	 * FIXME: Let user decide the key_mgmt is the best way. */
+	for(i=0;i<count;i++) {
+		if(memcmp(&buffer[offset], wpa_oui, 3)==0) {
+			/* pick a byte for type of key_mgmt */
+			info->key_mgmt = buffer[offset+3];
+		}
+		offset += 4;
+    }
+}
+
+ap_info *
+wireless_parse_scanning_event(struct iw_event *event, ap_info *oldinfo)
+{
+	ap_info *info;
+
+	/* found a new AP */
+	if (event->cmd==SIOCGIWAP) {
+		char buf[128];
+		info = g_new0(ap_info, 1);
+		info->apaddr = g_strdup(iw_saether_ntop(&event->u.ap_addr, buf));
+		info->en_method = NS_WIRELESS_AUTH_OFF;
+		info->haskey = FALSE;
+		info->key_mgmt = NS_IW_IE_KEY_MGMT_NONE;
+		info->group = NS_IW_IE_CIPHER_TKIP;
+		info->pairwise = NS_IW_IE_CIPHER_TKIP;
+	} else {
+		info = oldinfo;
+	}
+
+    switch (event->cmd) {
+        case SIOCGIWESSID: /* ESSID */
+			if (!event->u.essid.flags
+				|| event->u.essid.length==0
+				|| strlen(event->u.essid.pointer)==0) {
+				info->essid = NULL;
+			} else {
+				info->essid = g_strndup(event->u.essid.pointer, event->u.essid.length);
+			}
+            break;
+		case IWEVQUAL: /* Signal Quality */
+				info->quality = (int)rint((log (event->u.qual.qual) / log (92)) * 100.0);
+            break;
+        case SIOCGIWENCODE: /* Encryption */
+			if (!event->u.data.pointer)
+				event->u.data.flags |= IW_ENCODE_NOKEY;
+
+			if (!(event->u.data.flags & IW_ENCODE_DISABLED)) {
+				info->haskey = TRUE;
+				/* assume WEP */
+				info->en_method = NS_WIRELESS_AUTH_WEP;
+			} else {
+				info->haskey = FALSE;
+				info->en_method = NS_WIRELESS_AUTH_OFF;
+			}
+            break;
+		case IWEVGENIE: /* Extra information */
+		{
+			int offset = 0;
+			int ielen = event->u.data.length;
+			unsigned char *iebuf;
+
+			while(offset <= (ielen - 2)) {
+				iebuf = (event->u.data.pointer + offset);
+				/* check IE type */
+				switch(iebuf[offset]) {
+					case 0xdd: /* WPA or else */
+					case 0x30: /* IEEE 802.11i/WPA2 */ 
+						wireless_gen_ie(info, iebuf, ielen);
+						break;
+				}
+				offset += iebuf[offset+1] + 2;
+			}
+		}
+			break;
+	}
+
+    return info;
+}
+
+/* when we have some workaround problems,
+ * we need this function to rescanning access-point.
+ * */
+gboolean wireless_refresh(int iwsockfd, const char *ifname)
+{
+	struct iwreq wrq;
+	struct iw_range range;
+	struct timeval tv;
+	fd_set rfds; /* File descriptors for select */
+	int selfd;
+	char buffer[IW_SCAN_MAX_DATA];
+
+	/* setting interfaces name */
+	strncpy(wrq.ifr_name, ifname, IFNAMSIZ);
+
+	/* Getting range */
+	iw_get_range_info(iwsockfd, ifname, &range);
+
+	/* check scanning support */
+	if (range.we_version_compiled < 14)
+		return FALSE;
+
+	/* Initiate Scanning */
+	wrq.u.data.pointer = buffer;
+	wrq.u.data.length = IW_SCAN_MAX_DATA;
+	wrq.u.data.flags = 0;
+
+	if (ioctl(iwsockfd, SIOCSIWSCAN, &wrq) < 0) {
+		if (errno!=EPERM)
+			return FALSE;
+	}
+
+	/* Init timeout value -> 250ms */
+	tv.tv_sec = 0;
+	tv.tv_usec = 250000;
+
+	/* Scanning APs */
+	while(1) {
+		if (ioctl(iwsockfd, SIOCGIWSCAN, &wrq) < 0) {
+			if (errno == EAGAIN) { /* not yet ready */
+				FD_ZERO(&rfds);
+				selfd = -1;
+
+				if (select(selfd + 1, &rfds, NULL, NULL, &tv)==0)
+					continue; /* timeout */
+			} else {
+				break;
+			}
+		}
+
+		if (wrq.u.data.length <= 0)
+			break;
+	}
+
+	return TRUE;
+}
+
+APLIST *wireless_scanning(int iwsockfd, const char *ifname)
+{
+	APLIST *ap = NULL;
+	APLIST *newap;
+
+	struct iwreq wrq;
+	int scanflags = 0;		/* Flags for scan */
+	unsigned char *	buffer = NULL;	/* Results */
+	int buflen = IW_SCAN_MAX_DATA;	/* Min for compat WE < 17 */
+	struct iw_range	range;
+	int has_range;
+	struct timeval tv;		/* select timeout */
+	int timeout = 15000000;		/* 15s */
+
+	/* Get range stuff */
+	has_range = (iw_get_range_info(iwsockfd, ifname, &range) >= 0);
+
+	/* Check if the interface could support scanning. */
+	if ((!has_range) || (range.we_version_compiled < 14)) {
+		fprintf(stderr, "%-8.16s  Interface doesn't support scanning.\n\n",
+				ifname);
+		return NULL;
+	}
+
+	/* Init timeout value -> 250ms between set and first get */
+	tv.tv_sec = 0;
+	tv.tv_usec = 250000;
+
+	wrq.u.data.pointer = NULL;
+	wrq.u.data.flags = 0;
+	wrq.u.data.length = 0;
+
+	/* Initiate Scanning */
+	if (iw_set_ext(iwsockfd, ifname, SIOCSIWSCAN, &wrq) < 0) {
+		if ((errno != EPERM) || (scanflags != 0)) {
+			fprintf(stderr, "%-8.16s  Interface doesn't support "
+				"scanning : %s\n\n", ifname, strerror(errno));
+			return NULL;
+		}
+		tv.tv_usec = 0;
+	}
+	timeout -= tv.tv_usec;
+
+	/* Forever */
+	while (1) {
+		fd_set rfds;		/* File descriptors for select */
+		int last_fd;	/* Last fd */
+		int ret;
+
+		/* Guess what ? We must re-generate rfds each time */
+		FD_ZERO(&rfds);
+		last_fd = -1;
+
+		/* In here, add the rtnetlink fd in the list */
+
+		/* Wait until something happens */
+		ret = select(last_fd + 1, &rfds, NULL, NULL, &tv);
+
+		/* Check if there was an error */
+		if (ret < 0) {
+			if (errno == EAGAIN || errno == EINTR)
+				continue;
+			fprintf(stderr, "Unhandled signal - exiting...\n");
+			return NULL;
+		}
+
+		/* Check if there was a timeout */
+		if (ret == 0) {
+			unsigned char *newbuf;
+
+realloc:
+			/* (Re)allocate the buffer - realloc(NULL, len) == malloc(len) */
+			newbuf = realloc(buffer, buflen);
+			if (newbuf == NULL) {
+				if (buffer)
+					free(buffer);
+				fprintf(stderr, "%s: Allocation failed\n", __FUNCTION__);
+				return NULL;
+			}
+			buffer = newbuf;
+
+			/* Try to read the results */
+			wrq.u.data.pointer = buffer;
+			wrq.u.data.flags = 0;
+			wrq.u.data.length = buflen;
+			if (iw_get_ext(iwsockfd, ifname, SIOCGIWSCAN, &wrq) < 0)	{
+				/* Check if buffer was too small (WE-17 only) */
+				if ((errno == E2BIG) &&
+				    (range.we_version_compiled > 16)) {
+					/* Check if the driver gave us any hints. */
+					if (wrq.u.data.length > buflen)
+						buflen = wrq.u.data.length;
+					else
+						buflen *= 2;
+					/* Try again */
+					goto realloc;
+				}
+
+				/* Check if results not available yet */
+				if(errno == EAGAIN) {
+					/* Restart timer for only 100ms*/
+					tv.tv_sec = 0;
+					tv.tv_usec = 100000;
+					timeout -= tv.tv_usec;
+					if (timeout > 0)
+						continue; /* Try again later */
+				}
+
+				/* Bad error */
+				free(buffer);
+				fprintf(stderr, 
+				"%-8.16s  Failed to read scan data : %s\n\n",
+						ifname, strerror(errno));
+				return NULL;
+			}
+			else
+				/* We have the results, go to process them */
+				break;
+		}
+
+		/* In here, check if event and event type
+		 * if scan event, read results. All errors bad & no reset timeout */
+	}
+
+	if(wrq.u.data.length) {
+		struct iw_event           iwe;
+		struct stream_descr       stream;
+		int                       ret;
+
+		iw_init_event_stream(&stream, (char *) buffer, wrq.u.data.length);
+		do {
+			/* Extract an event and print it */
+			ret = iw_extract_event_stream(&stream, &iwe, range.we_version_compiled);
+			if (iwe.cmd==SIOCGIWAP) {
+				newap = malloc(sizeof(APLIST));
+				newap->info = NULL;
+				newap->next = ap;
+				ap = newap;
+			}
+			ap->info = wireless_parse_scanning_event(&iwe, ap->info);
+		}
+		while (ret > 0);
+		printf("\n");
+	}
+	else
+		printf("%-8.16s  No scan results\n\n", ifname);
+
+	free(buffer);
+	return ap;
+}
diff -Nur lxpanel-0.5.3-orig/src/plugins/netstat/wireless.h lxpanel-0.5.3/src/plugins/netstat/wireless.h
--- lxpanel-0.5.3-orig/src/plugins/netstat/wireless.h	1970-01-01 07:00:00.000000000 +0700
+++ lxpanel-0.5.3/src/plugins/netstat/wireless.h	2009-09-08 14:26:18.000000000 +0700
@@ -0,0 +1,43 @@
+#ifndef HAVE_NS_WIRELESS_H
+#define HAVE_NS_WIRELESS_H
+
+#include "netstat.h"
+
+/* auth protocol */
+#define NS_WIRELESS_AUTH_OFF          0
+#define NS_WIRELESS_AUTH_WEP          1
+#define NS_WIRELESS_AUTH_WPA          2
+
+/* Cypher values in GENIE (pairwise and group) */
+#define NS_IW_IE_CIPHER_NONE          0
+#define NS_IW_IE_CIPHER_WEP40         1
+#define NS_IW_IE_CIPHER_TKIP          2
+#define NS_IW_IE_CIPHER_WRAP          3
+#define NS_IW_IE_CIPHER_CCMP          4
+#define NS_IW_IE_CIPHER_WEP104        5
+
+/* Key management in GENIE */
+#define NS_IW_IE_KEY_MGMT_NONE        0
+#define NS_IW_IE_KEY_MGMT_802_1X      1
+#define NS_IW_IE_KEY_MGMT_PSK         2
+
+typedef struct {
+	char *essid;
+	char *apaddr;
+	int quality;
+	int en_method;
+	int pairwise;
+	int group;
+	int key_mgmt;
+	gboolean haskey;
+} ap_info;
+
+typedef struct {
+	ap_info             *info;
+	struct ap_info_node *next;
+} APLIST;
+
+void wireless_aplist_free(APLIST *aplist);
+APLIST *wireless_scanning(int iwsockfd, const char *ifname);
+
+#endif
