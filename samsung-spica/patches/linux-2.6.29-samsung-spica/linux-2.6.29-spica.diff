diff -Nur linux-2.6.29/arch/arm/configs/m900_android_defconfig linux-2.6.29-spica/arch/arm/configs/m900_android_defconfig
--- linux-2.6.29/arch/arm/configs/m900_android_defconfig	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/configs/m900_android_defconfig	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,1547 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.29
+# Wed Nov 18 16:04:34 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+CONFIG_NO_IOPORT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=".initram_list"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+# CONFIG_INITRAMFS_COMPRESS is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=1
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ASHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+CONFIG_ARCH_S3C64XX=y
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_W90X900 is not set
+CONFIG_PLAT_S3C64XX=y
+CONFIG_CPU_S3C64XX_INIT=y
+CONFIG_CPU_S3C64XX_CLOCK=y
+CONFIG_S3C64XX_SETUP_I2C0=y
+CONFIG_S3C64XX_SETUP_I2C1=y
+# CONFIG_S3C64XX_ADCTS is not set
+CONFIG_PWM=y
+CONFIG_S3C6410_PWM=y
+CONFIG_S3C64XX_DOMAIN_GATING=y
+# CONFIG_S3C64XX_DOMAIN_GATING_DEBUG is not set
+CONFIG_PLAT_S3C=y
+
+#
+# Boot options
+#
+# CONFIG_S3C_BOOT_ERROR_RESET is not set
+CONFIG_S3C_BOOT_UART_FORCE_FIFO=y
+
+#
+# Power management
+#
+# CONFIG_S3C_PM_DEBUG is not set
+# CONFIG_S3C_PM_CHECK is not set
+CONFIG_S3C_LOWLEVEL_UART_PORT=2
+CONFIG_S3C_GPIO_SPACE=0
+CONFIG_S3C_GPIO_TRACK=y
+CONFIG_S3C_GPIO_PULL_UPDOWN=y
+CONFIG_S3C_GPIO_CFG_S3C24XX=y
+CONFIG_S3C_GPIO_CFG_S3C64XX=y
+CONFIG_S3C_DEV_HSMMC=y
+CONFIG_S3C_DEV_HSMMC2=y
+CONFIG_S3C_DEV_I2C1=y
+
+#
+# Select DMA Controller
+#
+CONFIG_S3C_DMA_PL080_SOL=y
+# CONFIG_S3C_DMA_PL080 is not set
+# CONFIG_S3C_DMA_PL330 is not set
+# CONFIG_FIXED_TIMER is not set
+CONFIG_DYNAMIC_TIMER=y
+CONFIG_CPU_S3C6410=y
+CONFIG_S3C6410_SETUP_SDHCI=y
+
+#
+# Samsung S3C6410 Implementations
+#
+# CONFIG_MACH_SMDK6410 is not set
+CONFIG_MACH_INSTINCTQ=y
+CONFIG_BOARD_REVISION=0x02
+CONFIG_SEC_HEADSET=y
+# CONFIG_SEC_LOG_BUF is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+# CONFIG_CPU_32v6K is not set
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+CONFIG_CPU_BPREDICT_DISABLE=y
+# CONFIG_OUTER_CACHE is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_VIC=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=200
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/tbml6 rootfstype=cramfs init=/linuxrc console=ttySAC2,115200"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+# CONFIG_CPU_FREQ_STAT is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_MIN_TICKS=10
+CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=1000
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_COMPAT_NET_DEV_OPS=y
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+# CONFIG_BT_BNEP is not set
+# CONFIG_BT_HIDP is not set
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+# CONFIG_BT_HCIUART_LL is not set
+CONFIG_BT_HCIVHCI=y
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_WIRELESS=y
+CONFIG_CFG80211=y
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_NL80211=y
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+
+#
+# Rate control algorithm selection
+#
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+# CONFIG_MAC80211_RC_DEFAULT_PID is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
+CONFIG_MAC80211_MESH=y
+# CONFIG_MAC80211_LEDS is not set
+CONFIG_MAC80211_DEBUG_MENU=y
+# CONFIG_MAC80211_DEBUG_PACKET_ALIGNMENT is not set
+# CONFIG_MAC80211_NOINLINE is not set
+# CONFIG_MAC80211_VERBOSE_DEBUG is not set
+# CONFIG_MAC80211_HT_DEBUG is not set
+# CONFIG_MAC80211_TKIP_DEBUG is not set
+# CONFIG_MAC80211_IBSS_DEBUG is not set
+# CONFIG_MAC80211_VERBOSE_PS_DEBUG is not set
+# CONFIG_MAC80211_VERBOSE_MPL_DEBUG is not set
+# CONFIG_MAC80211_VERBOSE_SPECT_MGMT_DEBUG is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+# CONFIG_RFKILL_PM is not set
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+CONFIG_PARPORT=y
+# CONFIG_PARPORT_PC is not set
+# CONFIG_PARPORT_GSC is not set
+# CONFIG_PARPORT_AX88796 is not set
+CONFIG_PARPORT_1284=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+CONFIG_ANDROID_PMEM=y
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_KERNEL_DEBUGGER_CORE is not set
+CONFIG_UID_STAT=y
+# CONFIG_WL127X_RFKILL is not set
+# CONFIG_APANIC is not set
+CONFIG_APANIC_PLABEL="kpanic"
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_PPP_DEFLATE is not set
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_PPPOLAC is not set
+# CONFIG_PPPOPNS is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=800
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=480
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_KEYRESET is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_GPIO is not set
+CONFIG_KEYPAD_S3C=y
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+CONFIG_MOUSE_OPTJOY=y
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_MELFAS=y
+CONFIG_TOUCHSCREEN_MELFAS_KEY=y
+CONFIG_TOUCHSCREEN_MELFAS_FIRMWARE_UPDATE=y
+# CONFIG_TOUCHSCREEN_S3C is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_INPUT_KEYCHORD is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PARKBD is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_UARTS=4
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+CONFIG_SERIAL_S3C64XX=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+CONFIG_PRINTER=y
+# CONFIG_LP_CONSOLE is not set
+CONFIG_PPDEV=y
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+CONFIG_S3C_ADC=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+CONFIG_S3C_MEM=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+CONFIG_I2C_GPIO=y
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_S3C=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_AKM8976 is not set
+# CONFIG_SENSORS_PCA963X is not set
+# CONFIG_PMIC_MAX8906 is not set
+CONFIG_PMIC_MAX8698=y
+# CONFIG_AMP_MAX9877 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+CONFIG_BATTERY_S3C6410=y
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_BWQCAM is not set
+# CONFIG_VIDEO_CQCAM is not set
+# CONFIG_VIDEO_W9966 is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_S3C=y
+# CONFIG_FB_S3C_LTE480WV is not set
+# CONFIG_FB_S3C_LTV350QV is not set
+# CONFIG_FB_S3C_LTS222QV is not set
+# CONFIG_FB_S3C_S6D05A0 is not set
+CONFIG_FB_S3C_AMS320FS01=y
+CONFIG_FB_S3C_BPP=y
+# CONFIG_FB_S3C_BPP_8 is not set
+CONFIG_FB_S3C_BPP_16=y
+# CONFIG_FB_S3C_BPP_24 is not set
+# CONFIG_FB_S3C_BPP_32 is not set
+CONFIG_FB_S3C_NUM=5
+CONFIG_FB_S3C_VIRTUAL_SCREEN=y
+CONFIG_FB_S3C_DOUBLE_BUFFERING=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_SEQUENCER=y
+# CONFIG_SND_SEQ_DUMMY is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+# CONFIG_SND_HRTIMER is not set
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_S3C64XX_SOC_SOL=y
+CONFIG_SND_S3C_I2S_V32=y
+CONFIG_SND_S3C64XX_SOC_AK4671=y
+CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING=y
+# CONFIG_SND_SMDK6410_WM8580 is not set
+# CONFIG_SND_SMDK6410_S5M8751 is not set
+# CONFIG_SND_SMDK6410_WM9713 is not set
+# CONFIG_SND_SMDK6440_WM8580 is not set
+# CONFIG_SND_SMDK6440_S5M8751 is not set
+# CONFIG_SND_SMDKC100_WM8580 is not set
+# CONFIG_SND_SMDKC100_S5M8751 is not set
+# CONFIG_SND_SMDKC100_WM9713 is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_AK4671=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_HID_PID is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_COMPAT=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+CONFIG_USB_GADGET_S3C_OTGD_HS=y
+CONFIG_USB_GADGET_S3C_OTGD_HS_DMA_MODE=y
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+CONFIG_USB_DUN_SUPPORT=y
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_ANDROID_ADB_UMS is not set
+CONFIG_USB_ANDROID_ADB_UMS_ACM=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+# CONFIG_MMC_PARANOID_SD_INIT is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_S3C=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_PCA955X is not set
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+CONFIG_SWITCH=y
+# CONFIG_SWITCH_GPIO is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_S3C=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_MEILHAUS is not set
+# CONFIG_ECHO is not set
+# CONFIG_COMEDI is not set
+# CONFIG_PANEL is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+# CONFIG_ANDROID_RAM_CONSOLE is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_NEW_SENSORS=y
+CONFIG_ACCEL=y
+CONFIG_ACCEL_BMA020=y
+# CONFIG_ACCEL_KXSD9 is not set
+CONFIG_COMPASS=y
+CONFIG_COMPASS_AK8973B=y
+CONFIG_OPTICAL=y
+CONFIG_OPTICAL_GP2A=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+# CONFIG_MINIX_SUBPARTITION is not set
+CONFIG_SOLARIS_X86_PARTITION=y
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=1
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_TRACE_BRANCH_PROFILING is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_S3C_UART=0
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
diff -Nur linux-2.6.29/arch/arm/configs/msm_defconfig linux-2.6.29-spica/arch/arm/configs/msm_defconfig
--- linux-2.6.29/arch/arm/configs/msm_defconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/configs/msm_defconfig	2010-03-30 11:00:08.000000000 +0700
@@ -69,6 +69,7 @@
 CONFIG_SIGNALFD=y
 CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
 CONFIG_VM_EVENT_COUNTERS=y
 CONFIG_SLAB=y
 # CONFIG_SLUB is not set
@@ -256,6 +257,7 @@
 CONFIG_UNIX=y
 # CONFIG_NET_KEY is not set
 CONFIG_INET=y
+CONFIG_ANDROID_PARANOID_NETWORK=y
 # CONFIG_IP_MULTICAST is not set
 # CONFIG_IP_ADVANCED_ROUTER is not set
 CONFIG_IP_FIB_HASH=y
diff -Nur linux-2.6.29/arch/arm/configs/spica_android_defconfig linux-2.6.29-spica/arch/arm/configs/spica_android_defconfig
--- linux-2.6.29/arch/arm/configs/spica_android_defconfig	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/configs/spica_android_defconfig	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,1514 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.29
+# Thu Nov 19 15:17:58 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+CONFIG_NO_IOPORT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=".initram_list"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=1
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ASHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+CONFIG_ARCH_S3C64XX=y
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_W90X900 is not set
+CONFIG_PLAT_S3C64XX=y
+CONFIG_CPU_S3C64XX_INIT=y
+CONFIG_CPU_S3C64XX_CLOCK=y
+CONFIG_S3C64XX_SETUP_I2C0=y
+CONFIG_S3C64XX_SETUP_I2C1=y
+CONFIG_S3C64XX_ADCTS=y
+CONFIG_PWM=y
+CONFIG_S3C6410_PWM=y
+CONFIG_S3C64XX_DOMAIN_GATING=y
+# CONFIG_S3C64XX_DOMAIN_GATING_DEBUG is not set
+CONFIG_PLAT_S3C=y
+
+#
+# Boot options
+#
+# CONFIG_S3C_BOOT_ERROR_RESET is not set
+CONFIG_S3C_BOOT_UART_FORCE_FIFO=y
+
+#
+# Power management
+#
+# CONFIG_S3C_PM_DEBUG is not set
+# CONFIG_S3C_PM_CHECK is not set
+CONFIG_S3C_LOWLEVEL_UART_PORT=2
+CONFIG_S3C_GPIO_SPACE=0
+CONFIG_S3C_GPIO_TRACK=y
+CONFIG_S3C_GPIO_PULL_UPDOWN=y
+CONFIG_S3C_GPIO_CFG_S3C24XX=y
+CONFIG_S3C_GPIO_CFG_S3C64XX=y
+CONFIG_S3C_DEV_HSMMC=y
+CONFIG_S3C_DEV_HSMMC2=y
+CONFIG_S3C_DEV_I2C1=y
+
+#
+# Select DMA Controller
+#
+CONFIG_S3C_DMA_PL080_SOL=y
+# CONFIG_S3C_DMA_PL080 is not set
+# CONFIG_S3C_DMA_PL330 is not set
+# CONFIG_FIXED_TIMER is not set
+CONFIG_DYNAMIC_TIMER=y
+CONFIG_CPU_S3C6410=y
+CONFIG_S3C6410_SETUP_SDHCI=y
+
+#
+# Samsung S3C6410 Implementations
+#
+# CONFIG_MACH_SMDK6410 is not set
+CONFIG_MACH_SPICA=y
+CONFIG_BOARD_REVISION=0x02
+CONFIG_SEC_HEADSET=y
+# CONFIG_SEC_LOG_BUF is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+# CONFIG_CPU_32v6K is not set
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+CONFIG_CPU_BPREDICT_DISABLE=y
+# CONFIG_OUTER_CACHE is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_VIC=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=200
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/tbml6 rootfstype=cramfs init=/linuxrc console=ttySAC2,115200"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+# CONFIG_CPU_FREQ_STAT is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_MIN_TICKS=10
+CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=1000
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_COMPAT_NET_DEV_OPS=y
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+# CONFIG_BT_BNEP is not set
+# CONFIG_BT_HIDP is not set
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+# CONFIG_BT_HCIUART_LL is not set
+CONFIG_BT_HCIVHCI=y
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_WIRELESS=y
+CONFIG_CFG80211=y
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_NL80211=y
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+
+#
+# Rate control algorithm selection
+#
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+# CONFIG_MAC80211_RC_DEFAULT_PID is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
+CONFIG_MAC80211_MESH=y
+# CONFIG_MAC80211_LEDS is not set
+CONFIG_MAC80211_DEBUG_MENU=y
+# CONFIG_MAC80211_DEBUG_PACKET_ALIGNMENT is not set
+# CONFIG_MAC80211_NOINLINE is not set
+# CONFIG_MAC80211_VERBOSE_DEBUG is not set
+# CONFIG_MAC80211_HT_DEBUG is not set
+# CONFIG_MAC80211_TKIP_DEBUG is not set
+# CONFIG_MAC80211_IBSS_DEBUG is not set
+# CONFIG_MAC80211_VERBOSE_PS_DEBUG is not set
+# CONFIG_MAC80211_VERBOSE_MPL_DEBUG is not set
+# CONFIG_MAC80211_VERBOSE_SPECT_MGMT_DEBUG is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+# CONFIG_RFKILL_PM is not set
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+CONFIG_PARPORT=y
+# CONFIG_PARPORT_PC is not set
+# CONFIG_PARPORT_GSC is not set
+# CONFIG_PARPORT_AX88796 is not set
+CONFIG_PARPORT_1284=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+CONFIG_ANDROID_PMEM=y
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_KERNEL_DEBUGGER_CORE is not set
+CONFIG_UID_STAT=y
+# CONFIG_WL127X_RFKILL is not set
+# CONFIG_APANIC is not set
+CONFIG_APANIC_PLABEL="kpanic"
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_NETDEVICES is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=800
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=480
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_KEYRESET is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_GPIO is not set
+CONFIG_KEYPAD_S3C=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_QT5480=y
+# CONFIG_TOUCHSCREEN_S3C is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_INPUT_KEYCHORD is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PARKBD is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_UARTS=4
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+CONFIG_SERIAL_S3C64XX=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+CONFIG_PRINTER=y
+# CONFIG_LP_CONSOLE is not set
+CONFIG_PPDEV=y
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+CONFIG_S3C_MEM=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+CONFIG_I2C_GPIO=y
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_S3C=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_PCA963X is not set
+# CONFIG_PMIC_MAX8906 is not set
+CONFIG_PMIC_MAX8698=y
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+CONFIG_BATTERY_S3C6410=y
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_BWQCAM is not set
+# CONFIG_VIDEO_CQCAM is not set
+# CONFIG_VIDEO_W9966 is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_S3C=y
+# CONFIG_FB_S3C_LTE480WV is not set
+# CONFIG_FB_S3C_LTV350QV is not set
+# CONFIG_FB_S3C_LTS222QV is not set
+# CONFIG_FB_S3C_S6D04D1 is not set
+CONFIG_FB_S3C_S6D05A=y
+CONFIG_FB_S3C_BPP=y
+# CONFIG_FB_S3C_BPP_8 is not set
+CONFIG_FB_S3C_BPP_16=y
+# CONFIG_FB_S3C_BPP_24 is not set
+# CONFIG_FB_S3C_BPP_32 is not set
+CONFIG_FB_S3C_NUM=5
+CONFIG_FB_S3C_VIRTUAL_SCREEN=y
+CONFIG_FB_S3C_DOUBLE_BUFFERING=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_SEQUENCER=y
+# CONFIG_SND_SEQ_DUMMY is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+# CONFIG_SND_HRTIMER is not set
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_S3C64XX_SOC_SOL=y
+CONFIG_SND_S3C_I2S_V32=y
+CONFIG_SND_S3C64XX_SOC_AK4671=y
+CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING=y
+# CONFIG_SND_SMDK6410_WM8580 is not set
+# CONFIG_SND_SMDK6410_S5M8751 is not set
+# CONFIG_SND_SMDK6410_WM9713 is not set
+# CONFIG_SND_SMDK6440_WM8580 is not set
+# CONFIG_SND_SMDK6440_S5M8751 is not set
+# CONFIG_SND_SMDKC100_WM8580 is not set
+# CONFIG_SND_SMDKC100_S5M8751 is not set
+# CONFIG_SND_SMDKC100_WM9713 is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_AK4671=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_HID_PID is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_COMPAT=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+CONFIG_USB_GADGET_S3C_OTGD_HS=y
+CONFIG_USB_GADGET_S3C_OTGD_HS_DMA_MODE=y
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+CONFIG_USB_DUN_SUPPORT=y
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_ANDROID_ADB_UMS is not set
+CONFIG_USB_ANDROID_ADB_UMS_ACM=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+# CONFIG_MMC_PARANOID_SD_INIT is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_S3C=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_PCA955X is not set
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+CONFIG_SWITCH=y
+# CONFIG_SWITCH_GPIO is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_S3C=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_MEILHAUS is not set
+# CONFIG_ECHO is not set
+# CONFIG_COMEDI is not set
+# CONFIG_PANEL is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+# CONFIG_ANDROID_RAM_CONSOLE is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_NEW_SENSORS=y
+CONFIG_ACCEL=y
+CONFIG_ACCEL_BMA020=y
+# CONFIG_ACCEL_KXSD9 is not set
+CONFIG_COMPASS=y
+CONFIG_COMPASS_AK8973B=y
+# CONFIG_OPTICAL is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+# CONFIG_MINIX_SUBPARTITION is not set
+CONFIG_SOLARIS_X86_PARTITION=y
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=1
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_TRACE_BRANCH_PROFILING is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_S3C_UART=0
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
diff -Nur linux-2.6.29/arch/arm/include/asm/cacheflush.h linux-2.6.29-spica/arch/arm/include/asm/cacheflush.h
--- linux-2.6.29/arch/arm/include/asm/cacheflush.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/include/asm/cacheflush.h	2010-03-30 11:00:11.000000000 +0700
@@ -413,6 +413,14 @@
 		__flush_anon_page(vma, page, vmaddr);
 }
 
+#define ARCH_HAS_FLUSH_KERNEL_DCACHE_PAGE
+static inline void flush_kernel_dcache_page(struct page *page)
+{
+	/* highmem pages are always flushed upon kunmap already */
+	if ((cache_is_vivt() || cache_is_vipt_aliasing()) && !PageHighMem(page))
+		__cpuc_flush_dcache_page(page_address(page));
+}
+
 #define flush_dcache_mmap_lock(mapping) \
 	spin_lock_irq(&(mapping)->tree_lock)
 #define flush_dcache_mmap_unlock(mapping) \
diff -Nur linux-2.6.29/arch/arm/include/asm/cache.h linux-2.6.29-spica/arch/arm/include/asm/cache.h
--- linux-2.6.29/arch/arm/include/asm/cache.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/include/asm/cache.h	2010-05-06 12:42:45.634864134 +0700
@@ -4,7 +4,23 @@
 #ifndef __ASMARM_CACHE_H
 #define __ASMARM_CACHE_H
 
-#define L1_CACHE_SHIFT		5
+#define L1_CACHE_SHIFT		CONFIG_ARM_L1_CACHE_SHIFT
 #define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
 
+/*
+ * Memory returned by kmalloc() may be used for DMA, so we must make
+ * sure that all such allocations are cache aligned. Otherwise,
+ * unrelated code may cause parts of the buffer to be read into the
+ * cache before the transfer is done, causing old data to be seen by
+ * the CPU.
+ */
+#define ARCH_KMALLOC_MINALIGN	L1_CACHE_BYTES
+
+/*
+ * With EABI on ARMv5 and above we must have 64-bit aligned slab pointers.
+ */
+#if defined(CONFIG_AEABI) && (__LINUX_ARM_ARCH__ >= 5)
+#define ARCH_SLAB_MINALIGN 8
+#endif
+
 #endif
diff -Nur linux-2.6.29/arch/arm/include/asm/dma.h linux-2.6.29-spica/arch/arm/include/asm/dma.h
--- linux-2.6.29/arch/arm/include/asm/dma.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/include/asm/dma.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,7 +1,10 @@
 #ifndef __ASM_ARM_DMA_H
 #define __ASM_ARM_DMA_H
 
+typedef unsigned int dmach_t;
+
 #include <asm/memory.h>
+#include <mach/dma.h>
 
 /*
  * This is the maximum virtual address which can be DMA'd from.
@@ -19,7 +22,6 @@
 #include <asm/system.h>
 #include <asm/scatterlist.h>
 
-typedef unsigned int dmach_t;
 
 #include <mach/isa-dma.h>
 
diff -Nur linux-2.6.29/arch/arm/include/asm/elf.h linux-2.6.29-spica/arch/arm/include/asm/elf.h
--- linux-2.6.29/arch/arm/include/asm/elf.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/include/asm/elf.h	2010-03-30 11:00:11.000000000 +0700
@@ -45,11 +45,15 @@
 #define EF_ARM_HASENTRY		0x00000002	/* All */
 #define EF_ARM_RELEXEC		0x00000001	/* All */
 
-#define R_ARM_NONE	0
-#define R_ARM_PC24	1
-#define R_ARM_ABS32	2
-#define R_ARM_CALL	28
-#define R_ARM_JUMP24	29
+#define R_ARM_NONE		0
+#define R_ARM_PC24		1
+#define R_ARM_ABS32		2
+#define R_ARM_CALL		28
+#define R_ARM_JUMP24		29
+#define R_ARM_V4BX		40
+#define R_ARM_PREL31		42
+#define R_ARM_MOVW_ABS_NC	43
+#define R_ARM_MOVT_ABS		44
 
 /*
  * These are used to set parameters in the core dumps.
@@ -82,6 +86,10 @@
 
 struct elf32_hdr;
 
+struct task_struct;
+
+extern int dump_task_regs (struct task_struct *, elf_gregset_t *);
+
 /*
  * This is used to ensure we don't load something for the wrong architecture.
  */
@@ -109,4 +117,6 @@
 extern void elf_set_personality(const struct elf32_hdr *);
 #define SET_PERSONALITY(ex)	elf_set_personality(&(ex))
 
+#define ELF_CORE_COPY_TASK_REGS(tsk, elf_regs) dump_task_regs(tsk, elf_regs)
+
 #endif
diff -Nur linux-2.6.29/arch/arm/include/asm/hwcap.h linux-2.6.29-spica/arch/arm/include/asm/hwcap.h
--- linux-2.6.29/arch/arm/include/asm/hwcap.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/include/asm/hwcap.h	2010-05-06 12:42:45.634864134 +0700
@@ -17,6 +17,8 @@
 #define HWCAP_CRUNCH	1024
 #define HWCAP_THUMBEE	2048
 #define HWCAP_NEON	4096
+#define HWCAP_VFPv3	8192
+#define HWCAP_VFPv3D16	16384
 
 #if defined(__KERNEL__) && !defined(__ASSEMBLY__)
 /*
diff -Nur linux-2.6.29/arch/arm/include/asm/mach/mmc.h linux-2.6.29-spica/arch/arm/include/asm/mach/mmc.h
--- linux-2.6.29/arch/arm/include/asm/mach/mmc.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/include/asm/mach/mmc.h	2010-03-30 11:00:11.000000000 +0700
@@ -5,11 +5,23 @@
 #define ASMARM_MACH_MMC_H
 
 #include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
+
+struct embedded_sdio_data {
+        struct sdio_cis cis;
+        struct sdio_cccr cccr;
+        struct sdio_embedded_func *funcs;
+        int num_funcs;
+};
 
 struct mmc_platform_data {
 	unsigned int ocr_mask;			/* available voltages */
 	u32 (*translate_vdd)(struct device *, unsigned int);
 	unsigned int (*status)(struct device *);
+	unsigned int status_irq;
+	struct embedded_sdio_data *embedded_sdio;
+	int (*register_status_notify)(void (*callback)(int card_present, void *dev_id), void *dev_id);
 };
 
 #endif
diff -Nur linux-2.6.29/arch/arm/include/asm/page.h linux-2.6.29-spica/arch/arm/include/asm/page.h
--- linux-2.6.29/arch/arm/include/asm/page.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/include/asm/page.h	2010-05-06 12:42:45.634864134 +0700
@@ -194,13 +194,6 @@
 	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
 	 VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
-/*
- * With EABI on ARMv5 and above we must have 64-bit aligned slab pointers.
- */
-#if defined(CONFIG_AEABI) && (__LINUX_ARM_ARCH__ >= 5)
-#define ARCH_SLAB_MINALIGN 8
-#endif
-
 #include <asm-generic/page.h>
 
 #endif
diff -Nur linux-2.6.29/arch/arm/include/asm/ptrace.h linux-2.6.29-spica/arch/arm/include/asm/ptrace.h
--- linux-2.6.29/arch/arm/include/asm/ptrace.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/include/asm/ptrace.h	2010-05-06 12:42:45.634864134 +0700
@@ -27,6 +27,8 @@
 /* PTRACE_SYSCALL is 24 */
 #define PTRACE_GETCRUNCHREGS	25
 #define PTRACE_SETCRUNCHREGS	26
+#define PTRACE_GETVFPREGS	27
+#define PTRACE_SETVFPREGS	28
 
 /*
  * PSR bits
diff -Nur linux-2.6.29/arch/arm/include/asm/thread_info.h linux-2.6.29-spica/arch/arm/include/asm/thread_info.h
--- linux-2.6.29/arch/arm/include/asm/thread_info.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/include/asm/thread_info.h	2010-05-06 12:42:45.634864134 +0700
@@ -113,6 +113,8 @@
 extern void iwmmxt_task_release(struct thread_info *);
 extern void iwmmxt_task_switch(struct thread_info *);
 
+extern void vfp_sync_state(struct thread_info *thread);
+
 #endif
 
 /*
diff -Nur linux-2.6.29/arch/arm/include/asm/user.h linux-2.6.29-spica/arch/arm/include/asm/user.h
--- linux-2.6.29/arch/arm/include/asm/user.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/include/asm/user.h	2010-05-06 12:42:45.634864134 +0700
@@ -81,4 +81,13 @@
 #define HOST_TEXT_START_ADDR (u.start_code)
 #define HOST_STACK_END_ADDR (u.start_stack + u.u_ssize * NBPG)
 
+/*
+ * User specific VFP registers. If only VFPv2 is present, registers 16 to 31
+ * are ignored by the ptrace system call.
+ */
+struct user_vfp {
+	unsigned long long fpregs[32];
+	unsigned long fpscr;
+};
+
 #endif /* _ARM_USER_H */
diff -Nur linux-2.6.29/arch/arm/Kconfig linux-2.6.29-spica/arch/arm/Kconfig
--- linux-2.6.29/arch/arm/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/Kconfig	2010-05-06 12:42:45.634864134 +0700
@@ -525,6 +525,7 @@
 	bool "Samsung S3C64XX"
 	select GENERIC_GPIO
 	select HAVE_CLK
+	select ZONE_DMA
 	help
 	  Samsung S3C64XX series based systems
 
@@ -854,7 +855,7 @@
 config HZ
 	int
 	default 128 if ARCH_L7200
-	default 200 if ARCH_EBSA110 || ARCH_S3C2410
+	default 200 if ARCH_EBSA110 || ARCH_S3C2410 || ARCH_S3C64XX
 	default OMAP_32K_TIMER_HZ if ARCH_OMAP && OMAP_32K_TIMER
 	default AT91_TIMER_HZ if ARCH_AT91
 	default 100
@@ -1086,7 +1087,7 @@
 
 menu "CPU Power Management"
 
-if (ARCH_SA1100 || ARCH_INTEGRATOR || ARCH_OMAP || ARCH_IMX || ARCH_PXA)
+if (ARCH_SA1100 || ARCH_INTEGRATOR || ARCH_OMAP || ARCH_IMX || ARCH_PXA || CPU_S3C6410)
 
 source "drivers/cpufreq/Kconfig"
 
@@ -1313,6 +1314,8 @@
 
 source "drivers/leds/Kconfig"
 
+source "drivers/switch/Kconfig"
+
 source "drivers/rtc/Kconfig"
 
 source "drivers/dma/Kconfig"
@@ -1327,6 +1330,8 @@
 
 source "drivers/staging/Kconfig"
 
+source "drivers/sensor/Kconfig"
+
 endmenu
 
 source "fs/Kconfig"
diff -Nur linux-2.6.29/arch/arm/kernel/module.c linux-2.6.29-spica/arch/arm/kernel/module.c
--- linux-2.6.29/arch/arm/kernel/module.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/kernel/module.c	2010-03-30 11:00:09.000000000 +0700
@@ -132,6 +132,21 @@
 			*(u32 *)loc |= offset & 0x00ffffff;
 			break;
 
+		case R_ARM_MOVW_ABS_NC:
+		case R_ARM_MOVT_ABS:
+			offset = *(u32 *)loc;
+			offset = ((offset & 0xf0000) >> 4) | (offset & 0xfff);
+			offset = (offset ^ 0x8000) - 0x8000;
+
+			offset += sym->st_value;
+			if (ELF32_R_TYPE(rel->r_info) == R_ARM_MOVT_ABS)
+				offset >>= 16;
+
+			*(u32 *)loc &= 0xfff0f000;
+			*(u32 *)loc |= ((offset & 0xf000) << 4) |
+					(offset & 0x0fff);
+			break;
+
 		default:
 			printk(KERN_ERR "%s: unknown relocation: %u\n",
 			       module->name, ELF32_R_TYPE(rel->r_info));
diff -Nur linux-2.6.29/arch/arm/kernel/process.c linux-2.6.29-spica/arch/arm/kernel/process.c
--- linux-2.6.29/arch/arm/kernel/process.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/kernel/process.c	2010-05-06 12:42:45.634864134 +0700
@@ -199,6 +199,77 @@
 	arm_pm_restart(reboot_mode);
 }
 
+/*
+ * dump a block of kernel memory from around the given address
+ */
+static void show_data(unsigned long addr, int nbytes, const char *name)
+{
+	int	i, j;
+	int	nlines;
+	u32	*p;
+
+	/*
+	 * don't attempt to dump non-kernel addresses or
+	 * values that are probably just small negative numbers
+	 */
+	if (addr < PAGE_OFFSET || addr > -256UL)
+		return;
+
+	printk("\n%s: %#lx:\n", name, addr);
+
+	/*
+	 * round address down to a 32 bit boundary
+	 * and always dump a multiple of 32 bytes
+	 */
+	p = (u32 *)(addr & ~(sizeof(u32) - 1));
+	nbytes += (addr & (sizeof(u32) - 1));
+	nlines = (nbytes + 31) / 32;
+
+
+	for (i = 0; i < nlines; i++) {
+		/*
+		 * just display low 16 bits of address to keep
+		 * each line of the dump < 80 characters
+		 */
+		printk("%04lx ", (unsigned long)p & 0xffff);
+		for (j = 0; j < 8; j++) {
+			u32	data;
+			if (probe_kernel_address(p, data)) {
+				printk(" ********");
+			} else {
+				printk(" %08x", data);
+			}
+			++p;
+		}
+		printk("\n");
+	}
+}
+
+static void show_extra_register_data(struct pt_regs *regs, int nbytes)
+{
+	mm_segment_t fs;
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	show_data(regs->ARM_pc - nbytes, nbytes * 2, "PC");
+	show_data(regs->ARM_lr - nbytes, nbytes * 2, "LR");
+	show_data(regs->ARM_sp - nbytes, nbytes * 2, "SP");
+	show_data(regs->ARM_ip - nbytes, nbytes * 2, "IP");
+	show_data(regs->ARM_fp - nbytes, nbytes * 2, "FP");
+	show_data(regs->ARM_r0 - nbytes, nbytes * 2, "R0");
+	show_data(regs->ARM_r1 - nbytes, nbytes * 2, "R1");
+	show_data(regs->ARM_r2 - nbytes, nbytes * 2, "R2");
+	show_data(regs->ARM_r3 - nbytes, nbytes * 2, "R3");
+	show_data(regs->ARM_r4 - nbytes, nbytes * 2, "R4");
+	show_data(regs->ARM_r5 - nbytes, nbytes * 2, "R5");
+	show_data(regs->ARM_r6 - nbytes, nbytes * 2, "R6");
+	show_data(regs->ARM_r7 - nbytes, nbytes * 2, "R7");
+	show_data(regs->ARM_r8 - nbytes, nbytes * 2, "R8");
+	show_data(regs->ARM_r9 - nbytes, nbytes * 2, "R9");
+	show_data(regs->ARM_r10 - nbytes, nbytes * 2, "R10");
+	set_fs(fs);
+}
+
 void __show_regs(struct pt_regs *regs)
 {
 	unsigned long flags;
@@ -257,6 +328,8 @@
 		printk("Control: %08x%s\n", ctrl, buf);
 	}
 #endif
+
+	show_extra_register_data(regs, 128);
 }
 
 void show_regs(struct pt_regs * regs)
@@ -336,6 +409,16 @@
 EXPORT_SYMBOL(dump_fpu);
 
 /*
+ * Capture the user space registers if the task is not running (in user space)
+ */
+int dump_task_regs(struct task_struct *tsk, elf_gregset_t *regs)
+{
+	struct pt_regs ptregs = *task_pt_regs(tsk);
+	elf_core_copy_regs(regs, &ptregs);
+	return 1;
+}
+
+/*
  * Shuffle the argument into the correct register before calling the
  * thread function.  r1 is the thread argument, r2 is the pointer to
  * the thread function, and r3 points to the exit function.
diff -Nur linux-2.6.29/arch/arm/kernel/ptrace.c linux-2.6.29-spica/arch/arm/kernel/ptrace.c
--- linux-2.6.29/arch/arm/kernel/ptrace.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/kernel/ptrace.c	2010-05-06 12:42:45.634864134 +0700
@@ -653,6 +653,54 @@
 }
 #endif
 
+#ifdef CONFIG_VFP
+/*
+ * Get the child VFP state.
+ */
+static int ptrace_getvfpregs(struct task_struct *tsk, void __user *data)
+{
+	struct thread_info *thread = task_thread_info(tsk);
+	union vfp_state *vfp = &thread->vfpstate;
+	struct user_vfp __user *ufp = data;
+
+	vfp_sync_state(thread);
+
+	/* copy the floating point registers */
+	if (copy_to_user(&ufp->fpregs, &vfp->hard.fpregs,
+			 sizeof(vfp->hard.fpregs)))
+		return -EFAULT;
+
+	/* copy the status and control register */
+	if (put_user(vfp->hard.fpscr, &ufp->fpscr))
+		return -EFAULT;
+
+	return 0;
+}
+
+/*
+ * Set the child VFP state.
+ */
+static int ptrace_setvfpregs(struct task_struct *tsk, void __user *data)
+{
+	struct thread_info *thread = task_thread_info(tsk);
+	union vfp_state *vfp = &thread->vfpstate;
+	struct user_vfp __user *ufp = data;
+
+	vfp_sync_state(thread);
+
+	/* copy the floating point registers */
+	if (copy_from_user(&vfp->hard.fpregs, &ufp->fpregs,
+			   sizeof(vfp->hard.fpregs)))
+		return -EFAULT;
+
+	/* copy the status and control register */
+	if (get_user(vfp->hard.fpscr, &ufp->fpscr))
+		return -EFAULT;
+
+	return 0;
+}
+#endif
+
 long arch_ptrace(struct task_struct *child, long request, long addr, long data)
 {
 	int ret;
@@ -775,6 +823,16 @@
 			break;
 #endif
 
+#ifdef CONFIG_VFP
+		case PTRACE_GETVFPREGS:
+			ret = ptrace_getvfpregs(child, (void __user *)data);
+			break;
+
+		case PTRACE_SETVFPREGS:
+			ret = ptrace_setvfpregs(child, (void __user *)data);
+			break;
+#endif
+
 		default:
 			ret = ptrace_request(child, request, addr, data);
 			break;
diff -Nur linux-2.6.29/arch/arm/kernel/setup.c linux-2.6.29-spica/arch/arm/kernel/setup.c
--- linux-2.6.29/arch/arm/kernel/setup.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/kernel/setup.c	2010-05-06 12:42:45.634864134 +0700
@@ -780,6 +780,8 @@
 	"crunch",
 	"thumbee",
 	"neon",
+	"vfpv3",
+	"vfpv3d16",
 	NULL
 };
 
diff -Nur linux-2.6.29/arch/arm/kernel/signal.c linux-2.6.29-spica/arch/arm/kernel/signal.c
--- linux-2.6.29/arch/arm/kernel/signal.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/kernel/signal.c	2010-03-30 11:00:09.000000000 +0700
@@ -534,6 +534,14 @@
 
 static inline void restart_syscall(struct pt_regs *regs)
 {
+	if (regs->ARM_ORIG_r0 == -ERESTARTNOHAND ||
+	    regs->ARM_ORIG_r0 == -ERESTARTSYS ||
+	    regs->ARM_ORIG_r0 == -ERESTARTNOINTR ||
+	    regs->ARM_ORIG_r0 == -ERESTART_RESTARTBLOCK) {
+		/* the syscall cannot be safely restarted, return -EINTR instead */
+		regs->ARM_r0 = -EINTR;
+		return;
+	}
 	regs->ARM_r0 = regs->ARM_ORIG_r0;
 	regs->ARM_pc -= thumb_mode(regs) ? 2 : 4;
 }
@@ -650,6 +658,7 @@
 	 */
 	if (syscall) {
 		if (regs->ARM_r0 == -ERESTART_RESTARTBLOCK) {
+			regs->ARM_r0 = -EAGAIN; /* prevent multiple restarts */
 			if (thumb_mode(regs)) {
 				regs->ARM_r7 = __NR_restart_syscall - __NR_SYSCALL_BASE;
 				regs->ARM_pc -= 2;
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/audio.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/audio.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/audio.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/audio.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,45 @@
+/* arch/arm/mach-s3c2410/include/mach/audio.h
+ *
+ * Copyright (c) 2004-2005 Simtec Electronics
+ *	http://www.simtec.co.uk/products/SWLINUX/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C24XX - Audio platfrom_device info
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_AUDIO_H
+#define __ASM_ARCH_AUDIO_H __FILE__
+
+/* struct s3c24xx_iis_ops
+ *
+ * called from the s3c24xx audio core to deal with the architecture
+ * or the codec's setup and control.
+ *
+ * the pointer to itself is passed through in case the caller wants to
+ * embed this in an larger structure for easy reference to it's context.
+*/
+
+struct s3c24xx_iis_ops {
+	struct module *owner;
+
+	int	(*startup)(struct s3c24xx_iis_ops *me);
+	void	(*shutdown)(struct s3c24xx_iis_ops *me);
+	int	(*suspend)(struct s3c24xx_iis_ops *me);
+	int	(*resume)(struct s3c24xx_iis_ops *me);
+
+	int	(*open)(struct s3c24xx_iis_ops *me, struct snd_pcm_substream *strm);
+	int	(*close)(struct s3c24xx_iis_ops *me, struct snd_pcm_substream *strm);
+	int	(*prepare)(struct s3c24xx_iis_ops *me, struct snd_pcm_substream *strm, struct snd_pcm_runtime *rt);
+};
+
+struct s3c24xx_platdata_iis {
+	const char		*codec_clk;
+	struct s3c24xx_iis_ops	*ops;
+	int			(*match_dev)(struct device *dev);
+};
+
+#endif /* __ASM_ARCH_AUDIO_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/dma.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/dma.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/dma.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/dma.h	2010-05-06 12:42:45.644210217 +0700
@@ -11,6 +11,6 @@
 #ifndef __ASM_ARCH_DMA_H
 #define __ASM_ARCH_DMA_H __FILE__
 
-/* currently nothing here, placeholder */
+#include <mach/s3c-dma.h>
 
 #endif /* __ASM_ARCH_IRQ_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/gpio-core.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/gpio-core.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/gpio-core.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/gpio-core.h	2010-05-06 12:42:45.644210217 +0700
@@ -18,4 +18,6 @@
 /* currently we just include the platform support */
 #include <plat/gpio-core.h>
 
+extern void s3c64xx_gpiolib_init(void);
+
 #endif /* __ASM_ARCH_GPIO_CORE_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/gpio.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/gpio.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/gpio.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/gpio.h	2010-05-06 12:42:45.644210217 +0700
@@ -12,10 +12,15 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H __FILE__
+
 #define gpio_get_value	__gpio_get_value
 #define gpio_set_value	__gpio_set_value
 #define gpio_cansleep	__gpio_cansleep
-#define gpio_to_irq	__gpio_to_irq
+
+extern int gpio_to_irq(unsigned gpio);
+extern int irq_to_gpio(unsigned irq);
 
 /* GPIO bank sizes */
 #define S3C64XX_GPIO_A_NR	(8)
@@ -90,7 +95,50 @@
 #define S3C64XX_GPIO_END	(S3C64XX_GPQ(S3C64XX_GPIO_Q_NR) + 1)
 #define S3C_GPIO_END		S3C64XX_GPIO_END
 
+#define S3C64XX_GPIO_OFF_PART_BASE		S3C64XX_GPA(0)
+#define S3C64XX_GPIO_ALIVE_PART_BASE		S3C64XX_GPK(0)
+#define S3C64XX_GPIO_MEM_PART_BASE		S3C64XX_GPO(0)
+
 /* define the number of gpios we need to the one after the GPQ() range */
 #define ARCH_NR_GPIOS	(S3C64XX_GPQ(S3C64XX_GPIO_Q_NR) + 1)
 
 #include <asm-generic/gpio.h>
+
+#define S3C_GPIO_LAVEL(x)	((x >= S3C64XX_GPIO_Q_START) ? "GPQ" : \
+								((x >= S3C64XX_GPIO_P_START) ? "GPP" : \
+								((x >= S3C64XX_GPIO_O_START) ? "GPO" : \
+								((x >= S3C64XX_GPIO_N_START) ? "GPN" : \
+								((x >= S3C64XX_GPIO_M_START) ? "GPM" : \
+								((x >= S3C64XX_GPIO_L_START) ? "GPL" : \
+								((x >= S3C64XX_GPIO_K_START) ? "GPK" : \
+								((x >= S3C64XX_GPIO_J_START) ? "GPJ" : \
+								((x >= S3C64XX_GPIO_I_START) ? "GPI" : \
+								((x >= S3C64XX_GPIO_H_START) ? "GPH" : \
+								((x >= S3C64XX_GPIO_G_START) ? "GPG" : \
+								((x >= S3C64XX_GPIO_F_START) ? "GPF" : \
+								((x >= S3C64XX_GPIO_E_START) ? "GPE" : \
+								((x >= S3C64XX_GPIO_D_START) ? "GPD" : \
+								((x >= S3C64XX_GPIO_C_START) ? "GPC" : \
+								((x >= S3C64XX_GPIO_B_START) ? "GPB" : \
+								((x >= S3C64XX_GPIO_A_START) ? "GPA" : NULL))))))))))))))))) \
+
+#include <plat/gpio-bank-a.h>
+#include <plat/gpio-bank-b.h>
+#include <plat/gpio-bank-c.h>
+#include <plat/gpio-bank-d.h>
+#include <plat/gpio-bank-e.h>
+#include <plat/gpio-bank-f.h>
+#include <plat/gpio-bank-g.h>
+#include <plat/gpio-bank-h.h>
+#include <plat/gpio-bank-i.h>
+#include <plat/gpio-bank-j.h>
+#include <plat/gpio-bank-k.h>
+#include <plat/gpio-bank-l.h>
+#include <plat/gpio-bank-m.h>
+#include <plat/gpio-bank-n.h>
+#include <plat/gpio-bank-o.h>
+#include <plat/gpio-bank-p.h>
+#include <plat/gpio-bank-q.h>
+
+
+#endif /* __ASM_ARCH_GPIO_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/hardware.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/hardware.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/hardware.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/hardware.h	2010-05-06 12:42:45.644210217 +0700
@@ -11,6 +11,8 @@
 #ifndef __ASM_ARCH_HARDWARE_H
 #define __ASM_ARCH_HARDWARE_H __FILE__
 
-/* currently nothing here, placeholder */
+#ifdef CONFIG_MACH_SPICA
+#include <mach/spica.h> 
+#endif
 
-#endif /* __ASM_ARCH_IRQ_H */
+#endif /* __ASM_ARCH_HARDWARE_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/idle.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/idle.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/idle.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/idle.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,24 @@
+/* linux/arch/arm/mach-s3c6400/include/mach/idle.h
+ *
+ * Copyright (c) 2004 Simtec Electronics <linux@simtec.co.uk>
+ *		http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C6400 CPU Idle controls
+*/
+
+#ifndef __ASM_ARCH_IDLE_H
+#define __ASM_ARCH_IDLE_H __FILE__
+
+/* This allows the over-ride of the default idle code, in case there
+ * is any other things to be done over idle (like DVS)
+*/
+
+extern void (*s3c64xx_idle)(void);
+
+extern void s3c64xx_default_idle(void);
+
+#endif /* __ASM_ARCH_IDLE_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/map.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/map.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/map.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/map.h	2010-05-06 12:42:45.644210217 +0700
@@ -22,6 +22,7 @@
 #define S3C64XX_PA_HSMMC0	S3C64XX_PA_HSMMC(0)
 #define S3C64XX_PA_HSMMC1	S3C64XX_PA_HSMMC(1)
 #define S3C64XX_PA_HSMMC2	S3C64XX_PA_HSMMC(2)
+#define S3C_SZ_HSMMC	   	SZ_1M
 
 #define S3C_PA_UART		(0x7F005000)
 #define S3C_PA_UART0		(S3C_PA_UART + 0x00)
@@ -31,14 +32,14 @@
 #define S3C_UART_OFFSET		(0x400)
 
 /* See notes on UART VA mapping in debug-macro.S */
-#define S3C_VA_UARTx(x)	(S3C_VA_UART + (S3C_PA_UART & 0xfffff) + ((x) * S3C_UART_OFFSET))
+#define S3C_VA_UARTx(x)		(S3C_VA_UART + (S3C_PA_UART & 0xfffff) + ((x) * S3C_UART_OFFSET))
 
 #define S3C_VA_UART0		S3C_VA_UARTx(0)
 #define S3C_VA_UART1		S3C_VA_UARTx(1)
 #define S3C_VA_UART2		S3C_VA_UARTx(2)
 #define S3C_VA_UART3		S3C_VA_UARTx(3)
+#define S3C_SZ_UART		SZ_256
 
-#define S3C64XX_PA_FB		(0x77100000)
 #define S3C64XX_PA_SYSCON	(0x7E00F000)
 #define S3C64XX_PA_TIMER	(0x7F006000)
 #define S3C64XX_PA_IIC0		(0x7F004000)
@@ -52,10 +53,124 @@
 #define S3C64XX_PA_VIC0		(0x71200000)
 #define S3C64XX_PA_VIC1		(0x71300000)
 
+#define S3C64XX_VA_SROMC	S3C_VA_SROMC
+#define S3C64XX_PA_SROMC	(0x70000000)
+#define S3C64XX_SZ_SROMC	SZ_1M
+
+#define S3C64XX_VA_LCD	   	S3C_VA_LCD
+#define S3C64XX_PA_LCD	   	(0x77100000)
+#define S3C64XX_SZ_LCD		SZ_1M
+
+#define S3C64XX_PA_G2D	   	(0x76100000)
+#define S3C64XX_SZ_G2D		SZ_1M
+
+#define S3C64XX_PA_G3D	   	(0x72000000)
+#define S3C64XX_SZ_G3D		SZ_16M
+
+#define S3C64XX_PA_FIMC		(0x78000000)
+#define S3C64XX_SZ_FIMC		SZ_1M
+
+#define S3C64XX_PA_ADC		(0x7E00B000)
+#define S3C64XX_PA_SMC9115	(0x18000000)
+#define S3C64XX_SZ_SMC9115	SZ_512M
+
+#define S3C64XX_PA_IIS	   	(0x7F002000)
+#define S3C64XX_PA_RTC      (0x7E005000)
+#define S3C64XX_PA_IIS_V40 	(0x7F00D000)
+#define S3C_SZ_IIS		SZ_8K
+
+/* DMA controller */
+#define S3C64XX_PA_DMA		(0x75000000)
+
+#if defined(CONFIG_S3C_DMA_PL080_SOL)
+#define S3C64XX_PA_DMA0     (0x75000000)
+#define S3C64XX_PA_DMA1     (0x75100000)
+#define S3C64XX_PA_DMA2     (0x7DB00000)
+#define S3C64XX_PA_DMA3     (0x7DC00000)
+#define S3C64XX_SZ_DMA      0x200
+#endif
+
 /* place VICs close together */
 #define S3C_VA_VIC0		(S3C_VA_IRQ + 0x00)
 #define S3C_VA_VIC1		(S3C_VA_IRQ + 0x10000)
 
+/* Host I/F Indirect & Direct */
+#define S3C64XX_VA_HOSTIFA	S3C_ADDR(0x00B00000)
+#define S3C64XX_PA_HOSTIFA	(0x74000000)
+#define S3C64XX_SZ_HOSTIFA	SZ_1M
+
+#define S3C64XX_VA_HOSTIFB	S3C_ADDR(0x00C00000)
+#define S3C64XX_PA_HOSTIFB	(0x74100000)
+#define S3C64XX_SZ_HOSTIFB	SZ_1M
+
+/* NAND flash controller */
+#define S3C64XX_PA_NAND	   	(0x70200000)
+#define S3C64XX_SZ_NAND	   	SZ_1M
+
+/* OneNAND */
+#define S3C64XX_PA_ONENAND	(0x70100000)
+#define S3C64XX_VA_ONENAND	S3C_VA_ONENAND
+#define S3C64XX_SZ_ONENAND	SZ_1M
+
+/* USB Host */
+#define S3C64XX_PA_USBHOST	(0x74300000)
+#define S3C64XX_SZ_USBHOST	SZ_1M
+
+/* USB OTG */
+#define S3C64XX_VA_OTG		S3C_ADDR(0x03900000)
+#define S3C64XX_PA_OTG		(0x7C000000)
+#define S3C64XX_SZ_OTG		SZ_1M
+
+/* USB OTG SFR */
+#define S3C64XX_VA_OTGSFR	S3C_ADDR(0x03a00000)
+#define S3C64XX_PA_OTGSFR	(0x7C100000)
+#define S3C64XX_SZ_OTGSFR	SZ_1M
+
+/* Keypad IF  */
+#define S3C64XX_PA_KEYPAD   (0x7E00A000)
+#define S3C64XX_SZ_KEYPAD   SZ_4K
+
+#define S3C64XX_PA_ROTATOR  (0x77200000)
+#define S3C_SZ_ROTATOR      SZ_1M
+
+/* TV-ENCODER */
+#define S3C64XX_PA_TVENC    (0x76200000)
+#define S3C_SZ_TVENC        SZ_1M
+
+/* TV-SCALER*/
+#define S3C64XX_PA_TVSCALER (0x76300000)
+#define S3C_SZ_TVSCALER     SZ_1M
+
+/* VPP */
+#define S3C64XX_PA_VPP      (0x77000000)
+#define S3C_SZ_VPP      SZ_1M
+
+/* MFC */
+#define S3C64XX_PA_MFC      (0x7E002000)
+#define S3C_SZ_MFC      SZ_4K
+
+/* JPEG */
+#define S3C64XX_PA_JPEG     (0x78800000)
+#define S3C_SZ_JPEG     SZ_4M
+
+/* CAM IF */
+#define S3C64XX_PA_FIMC	(0x78000000)
+#define S3C64XX_SZ_FIMC	SZ_1M
+
+/* SPI */
+#define S3C64XX_PA_SPI	   	(0x7F00B000)
+#define S3C64XX_PA_SPI0     (0x7F00B000)
+#define S3C64XX_PA_SPI1     (0x7F00C000)
+#define S3C64XX_SZ_SPI		SZ_8K
+#define S3C64XX_SZ_SPI0		SZ_4K
+#define S3C64XX_SZ_SPI1		SZ_4K
+
+/* Watch dog */
+#define S3C64XX_PA_WATCHDOG	(0x7E004000)
+#define S3C64XX_SZ_WATCHDOG 	SZ_4K
+
+#define S3C6410_PA_AXI_SYS        (0x7E003000)
+
 /* compatibiltiy defines. */
 #define S3C_PA_TIMER		S3C64XX_PA_TIMER
 #define S3C_PA_HSMMC0		S3C64XX_PA_HSMMC0
@@ -63,6 +178,29 @@
 #define S3C_PA_HSMMC2		S3C64XX_PA_HSMMC2
 #define S3C_PA_IIC		S3C64XX_PA_IIC0
 #define S3C_PA_IIC1		S3C64XX_PA_IIC1
-#define S3C_PA_FB		S3C64XX_PA_FB
+
+#define S3C_PA_RTC      S3C64XX_PA_RTC
+
+#define S3C_PA_SPI		S3C64XX_PA_SPI
+#define S3C_PA_SPI0		S3C64XX_PA_SPI0
+#define S3C_PA_SPI1		S3C64XX_PA_SPI1
+#define S3C_SZ_SPI		S3C64XX_SZ_SPI
+#define S3C_SZ_SPI0		S3C64XX_SZ_SPI0
+#define S3C_SZ_SPI1		S3C64XX_SZ_SPI1
+
+#define S3C_PA_IIS		S3C64XX_PA_IIS
+#define S3C_PA_ADC		S3C64XX_PA_ADC
+#define S3C_PA_DMA		S3C64XX_PA_DMA
+
+#define S3C_VA_OTG		S3C64XX_VA_OTG
+#define S3C_PA_OTG		S3C64XX_PA_OTG
+#define S3C_SZ_OTG		S3C64XX_SZ_OTG
+
+#define S3C_VA_OTGSFR		S3C64XX_VA_OTGSFR
+#define S3C_PA_OTGSFR		S3C64XX_PA_OTGSFR
+#define S3C_SZ_OTGSFR		S3C64XX_SZ_OTGSFR
+
+#define S3C_PA_KEYPAD		S3C64XX_PA_KEYPAD
+#define S3C_SZ_KEYPAD		S3C64XX_SZ_KEYPAD
 
 #endif /* __ASM_ARCH_6400_MAP_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/memory.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/memory.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/memory.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/memory.h	2010-05-06 12:42:45.644210217 +0700
@@ -1,4 +1,4 @@
-/* arch/arm/mach-s3c6400/include/mach/memory.h
+/* linux/arch/arm/mach-s3c6400/include/mach/memory.h
  *
  * Copyright 2008 Openmoko, Inc.
  * Copyright 2008 Simtec Electronics
@@ -13,6 +13,10 @@
 #ifndef __ASM_ARCH_MEMORY_H
 #define __ASM_ARCH_MEMORY_H
 
-#define PHYS_OFFSET     UL(0x50000000)
+#define PHYS_OFFSET     	UL(0x50000000)
+#define CONSISTENT_DMA_SIZE	(SZ_8M + SZ_4M + SZ_2M)
+
+#define __virt_to_bus(x) __virt_to_phys(x)
+#define __bus_to_virt(x) __phys_to_virt(x)
 
 #endif
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/param.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/param.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/param.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/param.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,87 @@
+
+/*
+ * Parameter Infomation
+ */
+
+#ifndef ASM_MACH_PARAM_H
+#define ASM_MACH_PARAM_H
+
+#define PARAM_MAGIC			0x72726624
+#define PARAM_VERSION		0x11	/* Rev 1.1 */
+#define PARAM_STRING_SIZE	1024	/* 1024 Characters */
+
+#define MAX_PARAM			20
+#define MAX_STRING_PARAM	5
+
+/* Default Parameter Values */
+
+#define SERIAL_SPEED		7		/* Baudrate */
+#define LCD_LEVEL			0x061	/* Backlight Level */
+#define BOOT_DELAY			0		/* Boot Wait Time */
+#define LOAD_RAMDISK		0		/* Enable Ramdisk Loading */
+#define SWITCH_SEL			1		/* Switch Setting (UART[1], USB[0]) */
+#define PHONE_DEBUG_ON		0		/* Enable Phone Debug Mode */
+#define LCD_DIM_LEVEL		0x011	/* Backlight Dimming Level */
+#define MELODY_MODE			0		/* Melody Mode */
+#define REBOOT_MODE			0		/* Reboot Mode */
+#define NATION_SEL			0		/* Language Configuration */
+#define SET_DEFAULT_PARAM	0		/* Set Param to Default */
+#define VERSION_LINE		"I8315XXIE00"	/* Set Image Info */
+#define COMMAND_LINE		"console=ttySAC2,115200"
+#define	BOOT_VERSION		" version=Sbl(1.0.0) "
+
+typedef enum {
+	__SERIAL_SPEED,
+	__LOAD_RAMDISK,
+	__BOOT_DELAY,
+	__LCD_LEVEL,
+	__SWITCH_SEL,
+	__PHONE_DEBUG_ON,
+	__LCD_DIM_LEVEL,
+	__MELODY_MODE,
+	__REBOOT_MODE,
+	__NATION_SEL,
+	__SET_DEFAULT_PARAM,
+	__PARAM_INT_11,
+	__PARAM_INT_12,
+	__PARAM_INT_13,
+	__PARAM_INT_14,
+	__VERSION,
+	__CMDLINE,
+	__PARAM_STR_2,
+	__PARAM_STR_3,
+	__PARAM_STR_4
+} param_idx;
+
+typedef struct _param_int_t {
+	param_idx ident;
+	int  value;
+} param_int_t;
+
+typedef struct _param_str_t {
+	param_idx ident;
+	char value[PARAM_STRING_SIZE];
+} param_str_t;
+
+typedef struct {
+	int param_magic;
+	int param_version;
+	param_int_t param_list[MAX_PARAM - MAX_STRING_PARAM];
+	param_str_t param_str_list[MAX_STRING_PARAM];
+} status_t;
+
+/* REBOOT_MODE */
+#define REBOOT_MODE_NONE		0
+#define REBOOT_MODE_DOWNLOAD		1
+#define REBOOT_MODE_CHARGING		3
+#define REBOOT_MODE_RECOVERY		4
+#define REBOOT_MODE_ARM11_FOTA		5
+#define REBOOT_MODE_ARM9_FOTA		6
+
+extern void (*sec_set_param_value)(int idx, void *value);
+extern void (*sec_get_param_value)(int idx, void *value);
+
+#define USB_SEL_MASK	(1 << 0)
+#define UART_SEL_MASK	(1 << 1)
+
+#endif	/* ASM_MACH_PARAM_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/regs-irq.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/regs-irq.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/regs-irq.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/regs-irq.h	2010-05-06 12:42:45.644210217 +0700
@@ -16,5 +16,54 @@
 #define __ASM_ARCH_REGS_IRQ_H __FILE__
 
 #include <asm/hardware/vic.h>
+#include <mach/map.h>
+/* interrupt controller */
+#define S3C_VIC0REG(x)          ((x) + S3C_VA_VIC0)
+#define S3C_VIC1REG(x)          ((x) + S3C_VA_VIC1)
+
+#define S3C64XX_VIC0IRQSTATUS       S3C_VIC0REG(0x000)
+#define S3C64XX_VIC1IRQSTATUS       S3C_VIC1REG(0x000)
+
+#define S3C64XX_VIC0FIQSTATUS       S3C_VIC0REG(0x004)
+#define S3C64XX_VIC1FIQSTATUS       S3C_VIC1REG(0x004)
+
+#define S3C64XX_VIC0RAWINTR         S3C_VIC0REG(0x008)
+#define S3C64XX_VIC1RAWINTR         S3C_VIC1REG(0x008)
+
+#define S3C64XX_VIC0INTSELECT       S3C_VIC0REG(0x00C)
+#define S3C64XX_VIC1INTSELECT       S3C_VIC1REG(0x00C)
+
+#define S3C64XX_VIC0INTENABLE       S3C_VIC0REG(0x010)
+#define S3C64XX_VIC1INTENABLE       S3C_VIC1REG(0x010)
+
+#define S3C64XX_VIC0INTENCLEAR      S3C_VIC0REG(0x014)
+#define S3C64XX_VIC1INTENCLEAR      S3C_VIC1REG(0x014)
+
+#define S3C64XX_VIC0SOFTINT         S3C_VIC0REG(0x018)
+#define S3C64XX_VIC1SOFTINT         S3C_VIC1REG(0x018)
+
+#define S3C64XX_VIC0SOFTINTCLEAR    S3C_VIC0REG(0x01C)
+#define S3C64XX_VIC1SOFTINTCLEAR    S3C_VIC1REG(0x01C)
+
+#define S3C64XX_VIC0PROTECTION      S3C_VIC0REG(0x020)
+#define S3C64XX_VIC1PROTECTION      S3C_VIC1REG(0x020)
+
+#define S3C64XX_VIC0SWPRIORITYMASK  S3C_VIC0REG(0x024)
+#define S3C64XX_VIC1SWPRIORITYMASK  S3C_VIC1REG(0x024)
+
+#define S3C64XX_VIC0PRIORITYDAISY   S3C_VIC0REG(0x028)
+#define S3C64XX_VIC1PRIORITYDAISY   S3C_VIC1REG(0x028)
+
+#define S3C64XX_VIC0VECTADDR0       S3C_VIC0REG(0x100)
+#define S3C64XX_VIC1VECTADDR0       S3C_VIC1REG(0x100)
+
+#define S3C64XX_VIC0VECTADDR1       S3C_VIC0REG(0x104)
+#define S3C64XX_VIC1VECTADDR1       S3C_VIC1REG(0x104)
+
+#define S3C64XX_VIC0VECTADDR2       S3C_VIC0REG(0x108)
+#define S3C64XX_VIC1VECTADDR2       S3C_VIC1REG(0x108)
+
+#define S3C64XX_VIC0ADDRESS         S3C_VIC0REG(0xF00)
+#define S3C64XX_VIC1ADDRESS         S3C_VIC1REG(0xF00)
 
 #endif /* __ASM_ARCH_6400_REGS_IRQ_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/regs-mem.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/regs-mem.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/regs-mem.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/regs-mem.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,70 @@
+/* linux/arch/arm/mach-s3c6400/include/mach/regs-mem.h
+ *
+ * Copyright (c) 2004 Simtec Electronics <linux@simtec.co.uk>
+ *		http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 Memory Control register definitions
+*/
+
+#ifndef __ASM_ARM_MEMREGS_H
+#define __ASM_ARM_MEMREGS_H
+
+#ifndef S3C64XX_MEMREG
+#define S3C64XX_MEMREG(x) (S3C64XX_VA_SROMC + (x))
+#endif
+
+
+/* Bank Idle Cycle Control Registers 0-5 */
+#define S3C64XX_SROM_BW		S3C64XX_MEMREG(0x00)
+
+#define S3C64XX_SROM_BC0	S3C64XX_MEMREG(0x04)
+#define S3C64XX_SROM_BC1	S3C64XX_MEMREG(0x08)
+#define S3C64XX_SROM_BC2	S3C64XX_MEMREG(0x0C)
+#define S3C64XX_SROM_BC3	S3C64XX_MEMREG(0x10)
+#define S3C64XX_SROM_BC4	S3C64XX_MEMREG(0x14)
+#define S3C64XX_SROM_BC5	S3C64XX_MEMREG(0x18)
+
+/* SROM BW */
+#define S3C64XX_SROM_BW_DATA_WIDTH0_8BIT	(0 << 0)
+#define S3C64XX_SROM_BW_DATA_WIDTH0_16BIT	(1 << 0)
+#define S3C64XX_SROM_BW_DATA_WIDTH0_MASK	(1 << 0)
+
+#define S3C64XX_SROM_BW_WAIT_ENABLE0_DISABLE	(0 << 2)
+#define S3C64XX_SROM_BW_WAIT_ENABLE0_ENABLE	(1 << 2)
+#define S3C64XX_SROM_BW_WAIT_ENABLE0_MASK	(1 << 2)
+
+#define S3C64XX_SROM_BW_BYTE_ENABLE0_DISABLE	(0 << 3)
+#define S3C64XX_SROM_BW_BYTE_ENABLE0_ENABLE	(1 << 3)
+#define S3C64XX_SROM_BW_BYTE_ENABLE0_MASK	(1 << 3)
+
+#define S3C64XX_SROM_BW_DATA_WIDTH1_8BIT	(0 << 4)
+#define S3C64XX_SROM_BW_DATA_WIDTH1_16BIT	(1 << 4)
+#define S3C64XX_SROM_BW_DATA_WIDTH1_MASK	(1 << 4)
+
+#define S3C64XX_SROM_BW_WAIT_ENABLE1_DISABLE	(0 << 6)
+#define S3C64XX_SROM_BW_WAIT_ENABLE1_ENABLE	(1 << 6)
+#define S3C64XX_SROM_BW_WAIT_ENABLE1_MASK	(1 << 6)
+
+#define S3C64XX_SROM_BW_BYTE_ENABLE1_DISABLE	(0 << 7)
+#define S3C64XX_SROM_BW_BYTE_ENABLE1_ENABLE	(1 << 7)
+#define S3C64XX_SROM_BW_BYTE_ENABLE1_MASK	(1 << 7)
+
+#define S3C64XX_SROM_BW_DATA_WIDTH2_8BIT	(0 << 8)
+#define S3C64XX_SROM_BW_DATA_WIDTH2_16BIT	(1 << 8)
+#define S3C64XX_SROM_BW_DATA_WIDTH2_MASK	(1 << 8)
+
+/* SROM BCn */
+#define S3C64XX_SROM_BCn_TACS(x)		(x << 28)
+#define S3C64XX_SROM_BCn_TCOS(x)		(x << 24)
+#define S3C64XX_SROM_BCn_TACC(x)		(x << 16)
+#define S3C64XX_SROM_BCn_TCOH(x)		(x << 12)
+#define S3C64XX_SROM_BCn_TCAH(x)		(x << 8)
+#define S3C64XX_SROM_BCn_TACP(x)		(x << 4)
+#define S3C64XX_SROM_BCn_PMC_NORMAL		(0 << 0)
+#define S3C64XX_SROM_BCn_PMC_4			(1 << 0)
+
+#endif /* __ASM_ARM_MEMREGS_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/sec_headset.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/sec_headset.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/sec_headset.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/sec_headset.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2008 Samsung Electronics, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ASM_ARCH_SEC_HEADSET_H
+#define __ASM_ARCH_SEC_HEADSET_H
+
+enum {
+	SEC_HEADSET_NO_DEVICE		= 0,
+	SEC_HEADSET_NORMAL_HEADSET	= 1,
+	SEC_HEADSET_SEC_HEADSET		= 2,
+};
+
+struct sec_gpio_info 
+{
+	int	eint;
+	int	gpio;
+	int	gpio_af;
+	int	low_active;
+};
+
+struct sec_headset_port
+{
+	struct sec_gpio_info	det_headset;
+	struct sec_gpio_info	send_end;
+};
+
+struct sec_headset_platform_data
+{
+	struct sec_headset_port	*port;
+	int			nheadsets;
+};
+
+#endif
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/spica.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/spica.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/spica.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/spica.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,168 @@
+/*
+ *  linux/include/asm-arm/arch-s3c2410/spica.h
+ *
+ *  Author:		Samsung Electronics
+ *  Created:	05, Jul, 2007
+ *  Copyright:	Samsung Electronics Co.Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef ASM_MACH_SPICA_H
+
+#define ASM_MACH_SPICA_H
+
+/* 
+ * Board Configuration
+ */
+
+#define CONFIG_SPICA_REV00			0x80	/* REV00 */
+#define CONFIG_SPICA_REV01			0x81	/* REV01 */
+#define CONFIG_SPICA_REV02			0x82	/* REV02 */
+#define CONFIG_SPICA_REV03			0x83	/* REV03 */
+#define CONFIG_SPICA_REV04			0x84	/* REV04 */
+#define CONFIG_SPICA_REV05			0x85	/* REV05 */
+#define CONFIG_SPICA_REV06			0x86	/* REV06 */
+#define CONFIG_SPICA_REV07			0x87	/* REV07 */
+#define CONFIG_SPICA_REV08			0x88	/* REV08 */
+#define CONFIG_SPICA_REV09			0x89	/* REV09 */
+
+#define CONFIG_SPICA_TEST_REV00	0x00	
+#define CONFIG_SPICA_TEST_REV01	0x01	
+#define CONFIG_SPICA_TEST_REV02	0x02	
+#define CONFIG_SPICA_TEST_REV03	0x03	
+
+#ifdef CONFIG_BOARD_REVISION
+#define CONFIG_SPICA_REV			CONFIG_BOARD_REVISION
+#else
+#error	"Board revision is not defined!"
+#endif
+
+#if (CONFIG_SPICA_REV == CONFIG_SPICA_TEST_REV00)
+#include "spica_rev00.h"
+#elif (CONFIG_SPICA_REV == CONFIG_SPICA_TEST_REV01)
+#include "spica_rev01.h"
+#elif (CONFIG_SPICA_REV == CONFIG_SPICA_TEST_REV02)
+#include "spica_rev02.h"
+#else
+#error	"Board revision is not valid!"
+#endif
+
+/*
+ * Partition Information
+ */
+
+#define BOOT_PART_ID			0x0
+#define CSA_PART_ID				0xF		/* Not Used */
+#define SBL_PART_ID				0x1
+#define PARAM_PART_ID			0x2
+#define KERNEL_PART_ID			0x3
+#define RAMDISK_PART_ID			0xF		/* Not Used */
+#define FILESYSTEM_PART_ID		0x4
+#define FILESYSTEM1_PART_ID		0x5
+#define FILESYSTEM2_PART_ID		0x6
+#define TEMP_PART_ID			0x7		/* Temp Area for FOTA */
+#define MODEM_IMG_PART_ID		0x8
+#define MODEM_EFS_PART_ID		0x9		/* Modem EFS Area for OneDRAM */
+
+#define I2C_CAM_DIS do {	\
+	s3c_gpio_cfgpin(GPIO_I2C1_SCL, S3C_GPIO_INPUT);			\
+	s3c_gpio_cfgpin(GPIO_I2C1_SDA, S3C_GPIO_INPUT);			\
+	s3c_gpio_setpull(GPIO_I2C1_SCL, S3C_GPIO_PULL_DOWN);		\
+	s3c_gpio_setpull(GPIO_I2C1_SDA, S3C_GPIO_PULL_DOWN);		\
+} while (0)
+
+#define I2C_CAM_EN do {		\
+	s3c_gpio_cfgpin(GPIO_I2C1_SCL, S3C_GPIO_SFN(GPIO_I2C1_SCL_AF));	\
+	s3c_gpio_cfgpin(GPIO_I2C1_SDA, S3C_GPIO_SFN(GPIO_I2C1_SDA_AF));	\
+	s3c_gpio_setpull(GPIO_I2C1_SCL, S3C_GPIO_PULL_NONE);		\
+	s3c_gpio_setpull(GPIO_I2C1_SDA, S3C_GPIO_PULL_NONE);		\
+} while (0)
+
+#define AF_PWR_DIS do {} while (0)
+#define AF_PWR_EN do {} while (0)
+
+#define	MCAM_RST_DIS do {	\
+	/* MCAM RST Low */	\
+	if (gpio_is_valid(GPIO_MCAM_RST_N)) {	\
+		gpio_direction_output(GPIO_MCAM_RST_N, GPIO_LEVEL_LOW);	\
+	}	\
+	s3c_gpio_setpull(GPIO_MCAM_RST_N, S3C_GPIO_PULL_NONE);	\
+} while (0)
+
+#define	MCAM_RST_EN do {	\
+	gpio_direction_output(GPIO_MCAM_RST_N, GPIO_LEVEL_HIGH);	\
+} while (0)
+
+#define	VCAM_RST_DIS do { } while (0)
+#define	VCAM_RST_EN do { } while (0)
+
+#define	CAM_PWR_DIS do {	\
+	/* CAM PWR Low */	\
+	if (gpio_is_valid(GPIO_CAM_EN)) {	\
+		gpio_direction_output(GPIO_CAM_EN, GPIO_LEVEL_LOW);	\
+	}	\
+	s3c_gpio_setpull(GPIO_CAM_EN, S3C_GPIO_PULL_NONE);	\
+} while (0)
+
+#define	CAM_PWR_EN do {	\
+	gpio_direction_output(GPIO_CAM_EN, GPIO_LEVEL_HIGH);	\
+} while (0)
+
+#define	MCAM_STB_EN do {	\
+	/* MCAM STB High */	\
+	gpio_set_value(GPIO_CAM_3M_STBY_N, GPIO_LEVEL_HIGH);	\
+} while (0)	
+
+#define	MCAM_STB_DIS do {	\
+	/* CAM_3M STB Low */	\
+	if (gpio_is_valid(GPIO_CAM_3M_STBY_N)) {	\
+		gpio_direction_output(GPIO_CAM_3M_STBY_N, GPIO_LEVEL_LOW);	\
+	}	\
+	s3c_gpio_setpull(GPIO_CAM_3M_STBY_N, S3C_GPIO_PULL_NONE);	\
+} while (0)
+
+#define	VCAM_STB_DIS do { } while (0)
+
+#define CAM_MEM_SIZE	0x0D000000
+
+#if (CONFIG_SPICA_REV == CONFIG_SPICA_TEST_REV02)
+#define S5K4CA_ID	0x78
+#else
+#define S5K4CA_ID	0x5A
+#endif
+
+#define	LCD_18V_OFF do {  \
+		if (Get_MAX8698_PM_REG(ELDO6, &onoff_lcd_18)) {  \
+			pr_info("%s: LCD 1.8V off(%d)\n", __func__, onoff_lcd_18);  \
+			if (onoff_lcd_18) \
+				Set_MAX8698_PM_REG(ELDO6, 0);  \
+		}  \
+}	while (0)
+#define	LCD_28V_OFF do {} while (0)
+#define	LCD_30V_OFF do {  \
+		if (Get_MAX8698_PM_REG(ELDO7, &onoff_lcd_30)) {  \
+			pr_info("%s: LCD 3.0V off(%d)\n", __func__, onoff_lcd_30);  \
+			if (onoff_lcd_30) \
+				Set_MAX8698_PM_REG(ELDO7, 0);  \
+		}  \
+	}	while (0)
+
+#define	LCD_18V_ON do {  \
+		if (!onoff_lcd_18) {  \
+			pr_info("%s: LCD 1.8V On\n", __func__);  \
+			Set_MAX8698_PM_REG(ELDO6, 1);  \
+		}  \
+}	while (0)
+#define	LCD_28V_ON do {} while (0)
+
+#define	LCD_30V_ON do {  \
+		if (!onoff_lcd_30) {  \
+		pr_info("%s: LCD 3.0V On\n", __func__);  \
+		Set_MAX8698_PM_REG(ELDO7, 1);  \
+	}  \
+}	while (0)
+
+#endif	/* ASM_MACH_SPICA_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/spica_rev00.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/spica_rev00.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/spica_rev00.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/spica_rev00.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,464 @@
+/*
+ *  linux/include/asm-arm/arch-s3c2410/spica_rev00.h
+ *
+ *  Author:		Samsung Electronics
+ *  Created:	05, Jul, 2007
+ *  Copyright:	Samsung Electronics Co.Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef ASM_MACH_SPICA_REV00_H
+
+#define ASM_MACH_SPICA_REV00_H
+
+/*
+ * Memory Configuration (Reserved Memory Setting)
+ */
+
+#define	PHYS_SIZE					(208 * 1024 * 1024)		/* 208MB */
+
+#define CONFIG_RESERVED_MEM_CMM_JPEG_MFC_POST_CAMERA
+
+/*
+ * GPIO Configuration
+ */
+
+#include <mach/gpio.h>
+
+#define GPIO_LEVEL_LOW      		0
+#define GPIO_LEVEL_HIGH     		1
+#define GPIO_LEVEL_NONE     		2
+
+#define GPIO_FLM_RXD			S3C64XX_GPA(0)
+#define GPIO_FLM_RXD_AF			2
+
+#define GPIO_FLM_TXD			S3C64XX_GPA(1)
+#define GPIO_FLM_TXD_AF			2
+
+/* S3C_GPA2 ~ S3C_GPA3 */
+
+#define GPIO_USB_SEL			S3C64XX_GPA(2)
+#define GPIO_USB_SEL_AF			1
+
+#define GPIO_MSENSE_RST			S3C64XX_GPA(3)
+#define GPIO_MSENSE_RST_AF		1
+
+#define GPIO_BT_RXD			S3C64XX_GPA(4)
+#define GPIO_BT_RXD_AF			2
+
+#define GPIO_BT_TXD			S3C64XX_GPA(5)
+#define GPIO_BT_TXD_AF			2
+
+#define GPIO_BT_CTS			S3C64XX_GPA(6)
+#define GPIO_BT_CTS_AF			2
+
+#define GPIO_BT_RTS			S3C64XX_GPA(7)
+#define GPIO_BT_RTS_AF			2
+
+#define GPIO_PDA_RXD			S3C64XX_GPB(0)
+#define GPIO_PDA_RXD_AF			2
+
+#define GPIO_PDA_TXD			S3C64XX_GPB(1)
+#define GPIO_PDA_TXD_AF			2
+
+#define GPIO_I2C1_SCL			S3C64XX_GPB(2)
+#define GPIO_I2C1_SCL_AF		6
+
+#define GPIO_I2C1_SDA			S3C64XX_GPB(3)
+#define GPIO_I2C1_SDA_AF		6
+
+#define GPIO_TOUCH_EN			S3C64XX_GPB(4)
+#define GPIO_TOUCH_EN_AF		1
+
+#define GPIO_I2C0_SCL			S3C64XX_GPB(5)
+#define GPIO_I2C0_SCL_AF		2
+
+#define GPIO_I2C0_SDA			S3C64XX_GPB(6)
+#define GPIO_I2C0_SDA_AF		2
+
+/* S3C64XX_GPC(0) */
+
+#define GPIO_PM_SET1			S3C64XX_GPC(1)
+#define GPIO_PM_SET1_AF			1
+
+#define GPIO_PM_SET2			S3C64XX_GPC(2)
+#define GPIO_PM_SET2_AF			1
+
+#define GPIO_PM_SET3			S3C64XX_GPC(3)
+#define GPIO_PM_SET3_AF			1
+
+#define GPIO_WLAN_CMD			S3C64XX_GPC(4)
+#define GPIO_WLAN_CMD_AF		3
+
+#define GPIO_WLAN_CLK			S3C64XX_GPC(5)
+#define GPIO_WLAN_CLK_AF		3
+
+#define GPIO_WLAN_WAKE			S3C64XX_GPC(6)
+#define GPIO_WLAN_WAKE_AF		1
+
+#define GPIO_BT_WAKE			S3C64XX_GPC(7)
+#define GPIO_BT_WAKE_AF			1
+
+#define GPIO_I2S_CLK			S3C64XX_GPD(0)
+#define GPIO_I2S_CLK_AF			3
+
+#define GPIO_BT_WLAN_REG_ON		S3C64XX_GPD(1)
+#define GPIO_BT_WLAN_REG_ON_AF		1
+
+#define GPIO_I2S_LRCLK			S3C64XX_GPD(2)
+#define GPIO_I2S_LRCLK_AF		3
+
+#define GPIO_I2S_DI			S3C64XX_GPD(3)
+#define GPIO_I2S_DI_AF			3
+
+#define GPIO_I2S_DO			S3C64XX_GPD(4)
+#define GPIO_I2S_DO_AF			3
+
+#define GPIO_BT_RST_N			S3C64XX_GPE(0)
+#define GPIO_BT_RST_N_AF		1
+
+#define GPIO_BOOT			S3C64XX_GPE(1)
+#define GPIO_BOOT_AF			0
+
+#define GPIO_WLAN_RST_N			S3C64XX_GPE(2)
+#define GPIO_WLAN_RST_N_AF		1
+
+#define GPIO_PWR_I2C_SCL		S3C64XX_GPE(3)
+#define GPIO_PWR_I2C_SCL_AF		1
+
+#define GPIO_PWR_I2C_SDA		S3C64XX_GPE(4)
+#define GPIO_PWR_I2C_SDA_AF		1
+
+#define GPIO_CAM_MCLK			S3C64XX_GPF(0)
+#define GPIO_CAM_MCLK_AF		2
+
+#define GPIO_CAM_HSYNC			S3C64XX_GPF(1)
+#define GPIO_CAM_HSYNC_AF		2
+
+#define GPIO_CAM_PCLK			S3C64XX_GPF(2)
+#define GPIO_CAM_PCLK_AF		2
+
+#define GPIO_MCAM_RST_N			S3C64XX_GPF(3)
+#define GPIO_MCAM_RST_N_AF		1
+
+#define GPIO_CAM_VSYNC			S3C64XX_GPF(4)
+#define GPIO_CAM_VSYNC_AF		2
+
+#define GPIO_CAM_D_0			S3C64XX_GPF(5)
+#define GPIO_CAM_D_0_AF			2
+
+#define GPIO_CAM_D_1			S3C64XX_GPF(6)
+#define GPIO_CAM_D_1_AF			2
+
+#define GPIO_CAM_D_2			S3C64XX_GPF(7)
+#define GPIO_CAM_D_2_AF			2
+
+#define GPIO_CAM_D_3			S3C64XX_GPF(8)
+#define GPIO_CAM_D_3_AF			2
+
+#define GPIO_CAM_D_4			S3C64XX_GPF(9)
+#define GPIO_CAM_D_4_AF			2
+
+#define GPIO_CAM_D_5			S3C64XX_GPF(10)
+#define GPIO_CAM_D_5_AF			2
+
+#define GPIO_CAM_D_6			S3C64XX_GPF(11)
+#define GPIO_CAM_D_6_AF			2
+
+#define GPIO_CAM_D_7			S3C64XX_GPF(12)
+#define GPIO_CAM_D_7_AF			2
+
+/* S3C_GPF13~14 */
+
+#define GPIO_VIBTONE_PWM		S3C64XX_GPF(15)
+#define GPIO_VIBTONE_PWM_AF		2
+
+#define GPIO_TF_CLK			S3C64XX_GPG(0)
+#define GPIO_TF_CLK_AF			2
+
+#define GPIO_TF_CMD			S3C64XX_GPG(1)
+#define GPIO_TF_CMD_AF			2
+
+#define GPIO_TF_D_0			S3C64XX_GPG(2)
+#define GPIO_TF_D_0_AF			2
+
+#define GPIO_TF_D_1			S3C64XX_GPG(3)
+#define GPIO_TF_D_1_AF			2
+
+#define GPIO_TF_D_2			S3C64XX_GPG(4)
+#define GPIO_TF_D_2_AF			2
+
+#define GPIO_TF_D_3			S3C64XX_GPG(5)
+#define GPIO_TF_D_3_AF			2
+
+/* S3C_GPG6 */
+
+#define GPIO_TOUCH_I2C_SCL		S3C64XX_GPH(0)
+#define GPIO_TOUCH_I2C_SCL_AF		1
+
+#define GPIO_TOUCH_I2C_SDA		S3C64XX_GPH(1)
+#define GPIO_TOUCH_I2C_SDA_AF		1
+
+#define GPIO_FM_I2C_SCL			S3C64XX_GPH(2)
+#define GPIO_FM_I2C_SCL_AF		1
+
+#define GPIO_FM_I2C_SDA			S3C64XX_GPH(3)
+#define GPIO_FM_I2C_SDA_AF		1
+
+#define GPIO_VIB_EN			S3C64XX_GPH(4)
+#define GPIO_VIB_EN_AF			1
+
+/* S3C_GPH5 */
+
+#define GPIO_WLAN_D_0			S3C64XX_GPH(6)
+#define GPIO_WLAN_D_0_AF		3
+
+#define GPIO_WLAN_D_1			S3C64XX_GPH(7)
+#define GPIO_WLAN_D_1_AF		3
+
+#define GPIO_WLAN_D_2			S3C64XX_GPH(8)
+#define GPIO_WLAN_D_2_AF		3
+
+#define GPIO_WLAN_D_3			S3C64XX_GPH(9)
+#define GPIO_WLAN_D_3_AF		3
+
+/* S3C64XX_GPH(6) ~ S3C64XX_GPI(1) */
+
+#define GPIO_LCD_B_0			S3C64XX_GPI(2)
+#define GPIO_LCD_B_0_AF			2
+
+#define GPIO_LCD_B_1			S3C64XX_GPI(3)
+#define GPIO_LCD_B_1_AF			2
+
+#define GPIO_LCD_B_2			S3C64XX_GPI(4)
+#define GPIO_LCD_B_2_AF			2
+
+#define GPIO_LCD_B_3			S3C64XX_GPI(5)
+#define GPIO_LCD_B_3_AF			2
+
+#define GPIO_LCD_B_4			S3C64XX_GPI(6)
+#define GPIO_LCD_B_4_AF			2
+
+#define GPIO_LCD_B_5			S3C64XX_GPI(7)
+#define GPIO_LCD_B_5_AF			2
+
+/* S3C64XX_GPI(8) ~ S3C64XX_GPI(9) */
+
+#define GPIO_LCD_G_0			S3C64XX_GPI(10)
+#define GPIO_LCD_G_0_AF			2
+
+#define GPIO_LCD_G_1			S3C64XX_GPI(11)
+#define GPIO_LCD_G_1_AF			2
+
+#define GPIO_LCD_G_2			S3C64XX_GPI(12)
+#define GPIO_LCD_G_2_AF			2
+
+#define GPIO_LCD_G_3			S3C64XX_GPI(13)
+#define GPIO_LCD_G_3_AF			2
+
+#define GPIO_LCD_G_4			S3C64XX_GPI(14)
+#define GPIO_LCD_G_4_AF			2
+
+#define GPIO_LCD_G_5			S3C64XX_GPI(15)
+#define GPIO_LCD_G_5_AF			2
+
+/* S3C64XX_GPJ(0) ~ S3C64XX_GPJ(1) */
+
+#define GPIO_LCD_R_0			S3C64XX_GPJ(2)
+#define GPIO_LCD_R_0_AF			2
+
+#define GPIO_LCD_R_1			S3C64XX_GPJ(3)
+#define GPIO_LCD_R_1_AF			2
+
+#define GPIO_LCD_R_2			S3C64XX_GPJ(4)
+#define GPIO_LCD_R_2_AF			2
+
+#define GPIO_LCD_R_3			S3C64XX_GPJ(5)
+#define GPIO_LCD_R_3_AF			2
+
+#define GPIO_LCD_R_4			S3C64XX_GPJ(6)
+#define GPIO_LCD_R_4_AF			2
+
+#define GPIO_LCD_R_5			S3C64XX_GPJ(7)
+#define GPIO_LCD_R_5_AF			2
+
+#define GPIO_LCD_HSYNC			S3C64XX_GPJ(8)
+#define GPIO_LCD_HSYNC_AF		2
+
+#define GPIO_LCD_VSYNC			S3C64XX_GPJ(9)
+#define GPIO_LCD_VSYNC_AF		2
+
+#define GPIO_LCD_DE			S3C64XX_GPJ(10)
+#define GPIO_LCD_DE_AF			2
+
+#define GPIO_LCD_CLK			S3C64XX_GPJ(11)
+#define GPIO_LCD_CLK_AF			2
+
+#define GPIO_TA_EN			S3C64XX_GPK(0)
+#define GPIO_TA_EN_AF			1
+
+#define GPIO_AUDIO_EN			S3C64XX_GPK(1)
+#define GPIO_AUDIO_EN_AF		1
+
+#define GPIO_PHONE_ON			S3C64XX_GPK(2)
+#define GPIO_PHONE_ON_AF		1
+
+#define GPIO_MICBIAS_EN			S3C64XX_GPK(3)
+#define GPIO_MICBIAS_EN_AF		1
+
+#define GPIO_UART_SEL			S3C64XX_GPK(4)
+#define GPIO_UART_SEL_AF		1
+
+#define GPIO_TOUCH_RST			S3C64XX_GPK(5)
+#define GPIO_TOUCH_RST_AF		1
+
+#define GPIO_CAM_EN			S3C64XX_GPK(6)
+#define GPIO_CAM_EN_AF			1
+
+#define GPIO_PHONE_RST_N		S3C64XX_GPK(7)
+#define GPIO_PHONE_RST_N_AF		1
+
+#define GPIO_KEYSCAN_0			S3C64XX_GPK(8)
+#define GPIO_KEYSCAN_0_AF		3
+
+#define GPIO_KEYSCAN_1			S3C64XX_GPK(9)
+#define GPIO_KEYSCAN_1_AF		3
+
+#define GPIO_KEYSCAN_2			S3C64XX_GPK(10)
+#define GPIO_KEYSCAN_2_AF		3
+
+#define GPIO_KEYSCAN_3			S3C64XX_GPK(11)
+#define GPIO_KEYSCAN_3_AF		3
+
+/* S3C64XX_GPK(12) ~ S3C64XX_GPK(14) */
+
+#define GPIO_VREG_MSMP_26V		S3C64XX_GPK(15)
+#define GPIO_VREG_MSMP_26V_AF		0
+
+#define GPIO_KEYSENSE_0			S3C64XX_GPL(0)
+#define GPIO_KEYSENSE_0_AF		3
+
+#define GPIO_KEYSENSE_1			S3C64XX_GPL(1)
+#define GPIO_KEYSENSE_1_AF		3
+
+#define GPIO_KEYSENSE_2			S3C64XX_GPL(2)
+#define GPIO_KEYSENSE_2_AF		3
+
+#define GPIO_KEYSENSE_3			S3C64XX_GPL(3)
+#define GPIO_KEYSENSE_3_AF		3
+
+/* S3C64XX_GPL(4) ~ S3C64XX_GPL(6) */
+
+#define GPIO_USIM_BOOT			S3C64XX_GPL(7)
+#define GPIO_USIM_BOOT_AF		1
+
+#define GPIO_CAM_3M_STBY_N		S3C64XX_GPL(8)
+#define GPIO_CAM_3M_STBY_N_AF		1
+
+/* S3C64XX_GPL(9) ~ S3C64XX_GPL(10) */
+
+#define GPIO_TA_CONNECTED_N		S3C64XX_GPL(11)
+#define GPIO_TA_CONNECTED_N_AF		3
+
+#define GPIO_TOUCH_INT_N		S3C64XX_GPL(12)
+#define GPIO_TOUCH_INT_N_AF		3
+
+#define GPIO_CP_BOOT_SEL		S3C64XX_GPL(13)
+#define GPIO_CP_BOOT_SEL_AF		1
+
+#define GPIO_BT_HOST_WAKE		S3C64XX_GPL(14)
+#define GPIO_BT_HOST_WAKE_AF		3
+
+/* S3C64XX_GPM(0) ~ S3C64XX_GPM(1) */
+
+#define GPIO_TA_CHG_N			S3C64XX_GPM(2)
+#define GPIO_TA_CHG_N_AF		3
+
+#define GPIO_PDA_ACTIVE			S3C64XX_GPM(3)
+#define GPIO_PDA_ACTIVE_AF		1
+
+/* S3C64XX_GPM(4) ~ S3C64XX_GPM(5) */
+
+#define GPIO_ONEDRAM_INT_N		S3C64XX_GPN(0)
+#define GPIO_ONEDRAM_INT_N_AF		2
+
+#define GPIO_WLAN_HOST_WAKE		S3C64XX_GPN(1)
+#define GPIO_WLAN_HOST_WAKE_AF		2
+
+#define GPIO_MSENSE_INT			S3C64XX_GPN(2)
+#define GPIO_MSENSE_INT_AF		2
+
+#define GPIO_ACC_INT			S3C64XX_GPN(3)
+#define GPIO_ACC_INT_AF			2
+
+#define GPIO_SIM_DETECT_N		S3C64XX_GPN(4)
+#define GPIO_SIM_DETECT_N_AF		2
+
+#define GPIO_POWER_N			S3C64XX_GPN(5)
+#define GPIO_POWER_N_AF			2
+
+#define GPIO_TF_DETECT			S3C64XX_GPN(6)
+#define GPIO_TF_DETECT_AF		2
+
+#define GPIO_PHONE_ACTIVE		S3C64XX_GPN(7)
+#define GPIO_PHONE_ACTIVE_AF		2
+
+#define GPIO_PMIC_INT_N			S3C64XX_GPN(8)
+#define GPIO_PMIC_INT_N_AF		2
+
+#define GPIO_JACK_INT_N			S3C64XX_GPN(9)
+#define GPIO_JACK_INT_N_AF		2
+
+#define GPIO_DET_35			S3C64XX_GPN(10)
+#define GPIO_DET_35_AF			2
+
+#define GPIO_EAR_SEND_END		S3C64XX_GPN(11)
+#define GPIO_EAR_SEND_END_AF		2
+
+#define GPIO_RESOUT_N			S3C64XX_GPN(12)
+#define GPIO_RESOUT_N_AF		2
+
+#define GPIO_BOOT_EINT13		S3C64XX_GPN(13)
+#define GPIO_BOOT_EINT13_AF		2
+
+#define GPIO_BOOT_EINT14		S3C64XX_GPN(14)
+#define GPIO_BOOT_EINT14_AF		2
+
+#define GPIO_BOOT_EINT15		S3C64XX_GPN(15)
+#define GPIO_BOOT_EINT15_AF		2
+
+#define GPIO_NAND_CS_N			S3C64XX_GPO(0)
+#define GPIO_NAND_CS_N_AF		2
+
+/* S3C64XX_GPO(1) */
+
+#define GPIO_LCD_RST_N			S3C64XX_GPO(2)
+#define GPIO_LCD_RST_N_AF		1
+
+/* S3C64XX_GPO(3) */
+
+#define GPIO_LCD_CS_N			S3C64XX_GPO(6)
+#define GPIO_LCD_CS_N_AF		1
+
+#define GPIO_LCD_SDI			S3C64XX_GPO(7)
+#define GPIO_LCD_SDI_AF			1
+
+/* S3C64XX_GPO(8) ~ S3C64XX_GPO(11) */
+
+#define GPIO_LCD_ID			S3C64XX_GPO(12)
+#define GPIO_LCD_ID_AF			0
+
+#define GPIO_LCD_SCLK			S3C64XX_GPO(13)
+#define GPIO_LCD_SCLK_AF		1
+
+/* S3C64XX_GPP(0) ~ S3C64XX_GPP(12) */
+
+#define GPIO_PDA_PS_HOLD		S3C64XX_GPP(13)
+#define GPIO_PDA_PS_HOLD_AF		1
+
+/* S3C64XX_GPP(14) ~ S3C64XX_GPQ(6) */
+
+#endif	/* ASM_MACH_SPICA_REV00_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/spica_rev01.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/spica_rev01.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/spica_rev01.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/spica_rev01.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,464 @@
+/*
+ *  linux/include/asm-arm/arch-s3c2410/spica_rev01.h
+ *
+ *  Author:		Samsung Electronics
+ *  Created:	05, Jul, 2007
+ *  Copyright:	Samsung Electronics Co.Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef ASM_MACH_SPICA_REV01_H
+
+#define ASM_MACH_SPICA_REV01_H
+
+/*
+ * Memory Configuration (Reserved Memory Setting)
+ */
+
+#define	PHYS_SIZE					(208 * 1024 * 1024)		/* 208MB */
+
+#define CONFIG_RESERVED_MEM_CMM_JPEG_MFC_POST_CAMERA
+
+/*
+ * GPIO Configuration
+ */
+
+#include <mach/gpio.h>
+
+#define GPIO_LEVEL_LOW      		0
+#define GPIO_LEVEL_HIGH     		1
+#define GPIO_LEVEL_NONE     		2
+
+#define GPIO_FLM_RXD			S3C64XX_GPA(0)
+#define GPIO_FLM_RXD_AF			2
+
+#define GPIO_FLM_TXD			S3C64XX_GPA(1)
+#define GPIO_FLM_TXD_AF			2
+
+/* S3C_GPA2 ~ S3C_GPA3 */
+
+#define GPIO_USB_SEL			S3C64XX_GPA(2)
+#define GPIO_USB_SEL_AF			1
+
+#define GPIO_MSENSE_RST			S3C64XX_GPA(3)
+#define GPIO_MSENSE_RST_AF		1
+
+#define GPIO_BT_RXD			S3C64XX_GPA(4)
+#define GPIO_BT_RXD_AF			2
+
+#define GPIO_BT_TXD			S3C64XX_GPA(5)
+#define GPIO_BT_TXD_AF			2
+
+#define GPIO_BT_CTS			S3C64XX_GPA(6)
+#define GPIO_BT_CTS_AF			2
+
+#define GPIO_BT_RTS			S3C64XX_GPA(7)
+#define GPIO_BT_RTS_AF			2
+
+#define GPIO_PDA_RXD			S3C64XX_GPB(0)
+#define GPIO_PDA_RXD_AF			2
+
+#define GPIO_PDA_TXD			S3C64XX_GPB(1)
+#define GPIO_PDA_TXD_AF			2
+
+#define GPIO_I2C1_SCL			S3C64XX_GPB(2)
+#define GPIO_I2C1_SCL_AF		6
+
+#define GPIO_I2C1_SDA			S3C64XX_GPB(3)
+#define GPIO_I2C1_SDA_AF		6
+
+#define GPIO_TOUCH_EN			S3C64XX_GPB(4)
+#define GPIO_TOUCH_EN_AF		1
+
+#define GPIO_I2C0_SCL			S3C64XX_GPB(5)
+#define GPIO_I2C0_SCL_AF		2
+
+#define GPIO_I2C0_SDA			S3C64XX_GPB(6)
+#define GPIO_I2C0_SDA_AF		2
+
+/* S3C64XX_GPC(0) */
+
+#define GPIO_PM_SET1			S3C64XX_GPC(1)
+#define GPIO_PM_SET1_AF			1
+
+#define GPIO_PM_SET2			S3C64XX_GPC(2)
+#define GPIO_PM_SET2_AF			1
+
+#define GPIO_PM_SET3			S3C64XX_GPC(3)
+#define GPIO_PM_SET3_AF			1
+
+#define GPIO_WLAN_CMD			S3C64XX_GPC(4)
+#define GPIO_WLAN_CMD_AF		3
+
+#define GPIO_WLAN_CLK			S3C64XX_GPC(5)
+#define GPIO_WLAN_CLK_AF		3
+
+#define GPIO_WLAN_WAKE			S3C64XX_GPC(6)
+#define GPIO_WLAN_WAKE_AF		1
+
+#define GPIO_BT_WAKE			S3C64XX_GPC(7)
+#define GPIO_BT_WAKE_AF			1
+
+#define GPIO_I2S_CLK			S3C64XX_GPD(0)
+#define GPIO_I2S_CLK_AF			3
+
+#define GPIO_BT_WLAN_REG_ON		S3C64XX_GPD(1)
+#define GPIO_BT_WLAN_REG_ON_AF		1
+
+#define GPIO_I2S_LRCLK			S3C64XX_GPD(2)
+#define GPIO_I2S_LRCLK_AF		3
+
+#define GPIO_I2S_DI			S3C64XX_GPD(3)
+#define GPIO_I2S_DI_AF			3
+
+#define GPIO_I2S_DO			S3C64XX_GPD(4)
+#define GPIO_I2S_DO_AF			3
+
+#define GPIO_BT_RST_N			S3C64XX_GPE(0)
+#define GPIO_BT_RST_N_AF		1
+
+#define GPIO_BOOT			S3C64XX_GPE(1)
+#define GPIO_BOOT_AF			0
+
+#define GPIO_WLAN_RST_N			S3C64XX_GPE(2)
+#define GPIO_WLAN_RST_N_AF		1
+
+#define GPIO_PWR_I2C_SCL		S3C64XX_GPE(3)
+#define GPIO_PWR_I2C_SCL_AF		1
+
+#define GPIO_PWR_I2C_SDA		S3C64XX_GPE(4)
+#define GPIO_PWR_I2C_SDA_AF		1
+
+#define GPIO_CAM_MCLK			S3C64XX_GPF(0)
+#define GPIO_CAM_MCLK_AF		2
+
+#define GPIO_CAM_HSYNC			S3C64XX_GPF(1)
+#define GPIO_CAM_HSYNC_AF		2
+
+#define GPIO_CAM_PCLK			S3C64XX_GPF(2)
+#define GPIO_CAM_PCLK_AF		2
+
+#define GPIO_MCAM_RST_N			S3C64XX_GPF(3)
+#define GPIO_MCAM_RST_N_AF		1
+
+#define GPIO_CAM_VSYNC			S3C64XX_GPF(4)
+#define GPIO_CAM_VSYNC_AF		2
+
+#define GPIO_CAM_D_0			S3C64XX_GPF(5)
+#define GPIO_CAM_D_0_AF			2
+
+#define GPIO_CAM_D_1			S3C64XX_GPF(6)
+#define GPIO_CAM_D_1_AF			2
+
+#define GPIO_CAM_D_2			S3C64XX_GPF(7)
+#define GPIO_CAM_D_2_AF			2
+
+#define GPIO_CAM_D_3			S3C64XX_GPF(8)
+#define GPIO_CAM_D_3_AF			2
+
+#define GPIO_CAM_D_4			S3C64XX_GPF(9)
+#define GPIO_CAM_D_4_AF			2
+
+#define GPIO_CAM_D_5			S3C64XX_GPF(10)
+#define GPIO_CAM_D_5_AF			2
+
+#define GPIO_CAM_D_6			S3C64XX_GPF(11)
+#define GPIO_CAM_D_6_AF			2
+
+#define GPIO_CAM_D_7			S3C64XX_GPF(12)
+#define GPIO_CAM_D_7_AF			2
+
+/* S3C_GPF13~14 */
+
+#define GPIO_VIBTONE_PWM		S3C64XX_GPF(15)
+#define GPIO_VIBTONE_PWM_AF		2
+
+#define GPIO_TF_CLK			S3C64XX_GPG(0)
+#define GPIO_TF_CLK_AF			2
+
+#define GPIO_TF_CMD			S3C64XX_GPG(1)
+#define GPIO_TF_CMD_AF			2
+
+#define GPIO_TF_D_0			S3C64XX_GPG(2)
+#define GPIO_TF_D_0_AF			2
+
+#define GPIO_TF_D_1			S3C64XX_GPG(3)
+#define GPIO_TF_D_1_AF			2
+
+#define GPIO_TF_D_2			S3C64XX_GPG(4)
+#define GPIO_TF_D_2_AF			2
+
+#define GPIO_TF_D_3			S3C64XX_GPG(5)
+#define GPIO_TF_D_3_AF			2
+
+/* S3C_GPG6 */
+
+#define GPIO_TOUCH_I2C_SCL		S3C64XX_GPH(0)
+#define GPIO_TOUCH_I2C_SCL_AF		1
+
+#define GPIO_TOUCH_I2C_SDA		S3C64XX_GPH(1)
+#define GPIO_TOUCH_I2C_SDA_AF		1
+
+#define GPIO_FM_I2C_SCL			S3C64XX_GPH(2)
+#define GPIO_FM_I2C_SCL_AF		1
+
+#define GPIO_FM_I2C_SDA			S3C64XX_GPH(3)
+#define GPIO_FM_I2C_SDA_AF		1
+
+#define GPIO_VIB_EN			S3C64XX_GPH(4)
+#define GPIO_VIB_EN_AF			1
+
+/* S3C_GPH5 */
+
+#define GPIO_WLAN_D_0			S3C64XX_GPH(6)
+#define GPIO_WLAN_D_0_AF		3
+
+#define GPIO_WLAN_D_1			S3C64XX_GPH(7)
+#define GPIO_WLAN_D_1_AF		3
+
+#define GPIO_WLAN_D_2			S3C64XX_GPH(8)
+#define GPIO_WLAN_D_2_AF		3
+
+#define GPIO_WLAN_D_3			S3C64XX_GPH(9)
+#define GPIO_WLAN_D_3_AF		3
+
+/* S3C64XX_GPH(6) ~ S3C64XX_GPI(1) */
+
+#define GPIO_LCD_B_0			S3C64XX_GPI(2)
+#define GPIO_LCD_B_0_AF			2
+
+#define GPIO_LCD_B_1			S3C64XX_GPI(3)
+#define GPIO_LCD_B_1_AF			2
+
+#define GPIO_LCD_B_2			S3C64XX_GPI(4)
+#define GPIO_LCD_B_2_AF			2
+
+#define GPIO_LCD_B_3			S3C64XX_GPI(5)
+#define GPIO_LCD_B_3_AF			2
+
+#define GPIO_LCD_B_4			S3C64XX_GPI(6)
+#define GPIO_LCD_B_4_AF			2
+
+#define GPIO_LCD_B_5			S3C64XX_GPI(7)
+#define GPIO_LCD_B_5_AF			2
+
+/* S3C64XX_GPI(8) ~ S3C64XX_GPI(9) */
+
+#define GPIO_LCD_G_0			S3C64XX_GPI(10)
+#define GPIO_LCD_G_0_AF			2
+
+#define GPIO_LCD_G_1			S3C64XX_GPI(11)
+#define GPIO_LCD_G_1_AF			2
+
+#define GPIO_LCD_G_2			S3C64XX_GPI(12)
+#define GPIO_LCD_G_2_AF			2
+
+#define GPIO_LCD_G_3			S3C64XX_GPI(13)
+#define GPIO_LCD_G_3_AF			2
+
+#define GPIO_LCD_G_4			S3C64XX_GPI(14)
+#define GPIO_LCD_G_4_AF			2
+
+#define GPIO_LCD_G_5			S3C64XX_GPI(15)
+#define GPIO_LCD_G_5_AF			2
+
+/* S3C64XX_GPJ(0) ~ S3C64XX_GPJ(1) */
+
+#define GPIO_LCD_R_0			S3C64XX_GPJ(2)
+#define GPIO_LCD_R_0_AF			2
+
+#define GPIO_LCD_R_1			S3C64XX_GPJ(3)
+#define GPIO_LCD_R_1_AF			2
+
+#define GPIO_LCD_R_2			S3C64XX_GPJ(4)
+#define GPIO_LCD_R_2_AF			2
+
+#define GPIO_LCD_R_3			S3C64XX_GPJ(5)
+#define GPIO_LCD_R_3_AF			2
+
+#define GPIO_LCD_R_4			S3C64XX_GPJ(6)
+#define GPIO_LCD_R_4_AF			2
+
+#define GPIO_LCD_R_5			S3C64XX_GPJ(7)
+#define GPIO_LCD_R_5_AF			2
+
+#define GPIO_LCD_HSYNC			S3C64XX_GPJ(8)
+#define GPIO_LCD_HSYNC_AF		2
+
+#define GPIO_LCD_VSYNC			S3C64XX_GPJ(9)
+#define GPIO_LCD_VSYNC_AF		2
+
+#define GPIO_LCD_DE			S3C64XX_GPJ(10)
+#define GPIO_LCD_DE_AF			2
+
+#define GPIO_LCD_CLK			S3C64XX_GPJ(11)
+#define GPIO_LCD_CLK_AF			2
+
+#define GPIO_TA_EN			S3C64XX_GPK(0)
+#define GPIO_TA_EN_AF			1
+
+#define GPIO_AUDIO_EN			S3C64XX_GPK(1)
+#define GPIO_AUDIO_EN_AF		1
+
+#define GPIO_PHONE_ON			S3C64XX_GPK(2)
+#define GPIO_PHONE_ON_AF		1
+
+#define GPIO_MICBIAS_EN			S3C64XX_GPK(3)
+#define GPIO_MICBIAS_EN_AF		1
+
+#define GPIO_UART_SEL			S3C64XX_GPK(4)
+#define GPIO_UART_SEL_AF		1
+
+#define GPIO_TOUCH_RST			S3C64XX_GPK(5)
+#define GPIO_TOUCH_RST_AF		1
+
+#define GPIO_CAM_EN			S3C64XX_GPK(6)
+#define GPIO_CAM_EN_AF			1
+
+#define GPIO_PHONE_RST_N		S3C64XX_GPK(7)
+#define GPIO_PHONE_RST_N_AF		1
+
+#define GPIO_KEYSCAN_0			S3C64XX_GPK(8)
+#define GPIO_KEYSCAN_0_AF		3
+
+#define GPIO_KEYSCAN_1			S3C64XX_GPK(9)
+#define GPIO_KEYSCAN_1_AF		3
+
+#define GPIO_KEYSCAN_2			S3C64XX_GPK(10)
+#define GPIO_KEYSCAN_2_AF		3
+
+#define GPIO_KEYSCAN_3			S3C64XX_GPK(11)
+#define GPIO_KEYSCAN_3_AF		3
+
+/* S3C64XX_GPK(12) ~ S3C64XX_GPK(14) */
+
+#define GPIO_VREG_MSMP_26V		S3C64XX_GPK(15)
+#define GPIO_VREG_MSMP_26V_AF		0
+
+#define GPIO_KEYSENSE_0			S3C64XX_GPL(0)
+#define GPIO_KEYSENSE_0_AF		3
+
+#define GPIO_KEYSENSE_1			S3C64XX_GPL(1)
+#define GPIO_KEYSENSE_1_AF		3
+
+#define GPIO_KEYSENSE_2			S3C64XX_GPL(2)
+#define GPIO_KEYSENSE_2_AF		3
+
+#define GPIO_KEYSENSE_3			S3C64XX_GPL(3)
+#define GPIO_KEYSENSE_3_AF		3
+
+/* S3C64XX_GPL(4) ~ S3C64XX_GPL(6) */
+
+#define GPIO_USIM_BOOT			S3C64XX_GPL(7)
+#define GPIO_USIM_BOOT_AF		1
+
+#define GPIO_CAM_3M_STBY_N		S3C64XX_GPL(8)
+#define GPIO_CAM_3M_STBY_N_AF		1
+
+/* S3C64XX_GPL(9) ~ S3C64XX_GPL(10) */
+
+#define GPIO_TA_CONNECTED_N		S3C64XX_GPL(11)
+#define GPIO_TA_CONNECTED_N_AF		3
+
+#define GPIO_TOUCH_INT_N		S3C64XX_GPL(12)
+#define GPIO_TOUCH_INT_N_AF		3
+
+#define GPIO_CP_BOOT_SEL		S3C64XX_GPL(13)
+#define GPIO_CP_BOOT_SEL_AF		1
+
+#define GPIO_BT_HOST_WAKE		S3C64XX_GPL(14)
+#define GPIO_BT_HOST_WAKE_AF		3
+
+/* S3C64XX_GPM(0) ~ S3C64XX_GPM(1) */
+
+#define GPIO_TA_CHG_N			S3C64XX_GPM(2)
+#define GPIO_TA_CHG_N_AF		3
+
+#define GPIO_PDA_ACTIVE			S3C64XX_GPM(3)
+#define GPIO_PDA_ACTIVE_AF		1
+
+/* S3C64XX_GPM(4) ~ S3C64XX_GPM(5) */
+
+#define GPIO_ONEDRAM_INT_N		S3C64XX_GPN(0)
+#define GPIO_ONEDRAM_INT_N_AF		2
+
+#define GPIO_WLAN_HOST_WAKE		S3C64XX_GPN(1)
+#define GPIO_WLAN_HOST_WAKE_AF		2
+
+#define GPIO_MSENSE_INT			S3C64XX_GPN(2)
+#define GPIO_MSENSE_INT_AF		2
+
+#define GPIO_ACC_INT			S3C64XX_GPN(3)
+#define GPIO_ACC_INT_AF			2
+
+#define GPIO_SIM_DETECT_N		S3C64XX_GPN(4)
+#define GPIO_SIM_DETECT_N_AF		2
+
+#define GPIO_POWER_N			S3C64XX_GPN(5)
+#define GPIO_POWER_N_AF			2
+
+#define GPIO_TF_DETECT			S3C64XX_GPN(6)
+#define GPIO_TF_DETECT_AF		2
+
+#define GPIO_PHONE_ACTIVE		S3C64XX_GPN(7)
+#define GPIO_PHONE_ACTIVE_AF		2
+
+#define GPIO_PMIC_INT_N			S3C64XX_GPN(8)
+#define GPIO_PMIC_INT_N_AF		2
+
+#define GPIO_JACK_INT_N			S3C64XX_GPN(9)
+#define GPIO_JACK_INT_N_AF		2
+
+#define GPIO_DET_35			S3C64XX_GPN(10)
+#define GPIO_DET_35_AF			2
+
+#define GPIO_EAR_SEND_END		S3C64XX_GPN(11)
+#define GPIO_EAR_SEND_END_AF		2
+
+#define GPIO_RESOUT_N			S3C64XX_GPN(12)
+#define GPIO_RESOUT_N_AF		2
+
+#define GPIO_BOOT_EINT13		S3C64XX_GPN(13)
+#define GPIO_BOOT_EINT13_AF		2
+
+#define GPIO_BOOT_EINT14		S3C64XX_GPN(14)
+#define GPIO_BOOT_EINT14_AF		2
+
+#define GPIO_BOOT_EINT15		S3C64XX_GPN(15)
+#define GPIO_BOOT_EINT15_AF		2
+
+#define GPIO_NAND_CS_N			S3C64XX_GPO(0)
+#define GPIO_NAND_CS_N_AF		2
+
+/* S3C64XX_GPO(1) */
+
+#define GPIO_LCD_RST_N			S3C64XX_GPO(2)
+#define GPIO_LCD_RST_N_AF		1
+
+/* S3C64XX_GPO(3) */
+
+#define GPIO_LCD_CS_N			S3C64XX_GPO(6)
+#define GPIO_LCD_CS_N_AF		1
+
+#define GPIO_LCD_SDI			S3C64XX_GPO(7)
+#define GPIO_LCD_SDI_AF			1
+
+/* S3C64XX_GPO(8) ~ S3C64XX_GPO(11) */
+
+#define GPIO_LCD_ID			S3C64XX_GPO(12)
+#define GPIO_LCD_ID_AF			0
+
+#define GPIO_LCD_SCLK			S3C64XX_GPO(13)
+#define GPIO_LCD_SCLK_AF		1
+
+/* S3C64XX_GPP(0) ~ S3C64XX_GPP(12) */
+
+#define GPIO_PDA_PS_HOLD		S3C64XX_GPP(13)
+#define GPIO_PDA_PS_HOLD_AF		1
+
+/* S3C64XX_GPP(14) ~ S3C64XX_GPQ(6) */
+
+#endif	/* ASM_MACH_SPICA_REV01_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/spica_rev02.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/spica_rev02.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/spica_rev02.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/spica_rev02.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,467 @@
+/*
+ *  linux/include/asm-arm/arch-s3c2410/spica_rev02.h
+ *
+ *  Author:		Samsung Electronics
+ *  Created:	05, Jul, 2007
+ *  Copyright:	Samsung Electronics Co.Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef ASM_MACH_SPICA_REV02_H
+
+#define ASM_MACH_SPICA_REV02_H
+
+/*
+ * Memory Configuration (Reserved Memory Setting)
+ */
+
+#define	PHYS_SIZE					(208 * 1024 * 1024)		/* 208MB */
+
+#define CONFIG_RESERVED_MEM_CMM_JPEG_MFC_POST_CAMERA
+
+/*
+ * GPIO Configuration
+ */
+
+#include <mach/gpio.h>
+
+#define GPIO_LEVEL_LOW      		0
+#define GPIO_LEVEL_HIGH     		1
+#define GPIO_LEVEL_NONE     		2
+
+#define GPIO_FLM_RXD			S3C64XX_GPA(0)
+#define GPIO_FLM_RXD_AF			2
+
+#define GPIO_FLM_TXD			S3C64XX_GPA(1)
+#define GPIO_FLM_TXD_AF			2
+
+/* S3C_GPA2 ~ S3C_GPA3 */
+
+#define GPIO_USB_SEL			S3C64XX_GPA(2)
+#define GPIO_USB_SEL_AF			1
+
+#define GPIO_MSENSE_RST			S3C64XX_GPA(3)
+#define GPIO_MSENSE_RST_AF		1
+
+#define GPIO_BT_RXD			S3C64XX_GPA(4)
+#define GPIO_BT_RXD_AF			2
+
+#define GPIO_BT_TXD			S3C64XX_GPA(5)
+#define GPIO_BT_TXD_AF			2
+
+#define GPIO_BT_CTS			S3C64XX_GPA(6)
+#define GPIO_BT_CTS_AF			2
+
+#define GPIO_BT_RTS			S3C64XX_GPA(7)
+#define GPIO_BT_RTS_AF			2
+
+#define GPIO_PDA_RXD			S3C64XX_GPB(0)
+#define GPIO_PDA_RXD_AF			2
+
+#define GPIO_PDA_TXD			S3C64XX_GPB(1)
+#define GPIO_PDA_TXD_AF			2
+
+#define GPIO_I2C1_SCL			S3C64XX_GPB(2)
+#define GPIO_I2C1_SCL_AF		6
+
+#define GPIO_I2C1_SDA			S3C64XX_GPB(3)
+#define GPIO_I2C1_SDA_AF		6
+
+#define GPIO_TOUCH_EN			S3C64XX_GPB(4)
+#define GPIO_TOUCH_EN_AF		1
+
+#define GPIO_I2C0_SCL			S3C64XX_GPB(5)
+#define GPIO_I2C0_SCL_AF		2
+
+#define GPIO_I2C0_SDA			S3C64XX_GPB(6)
+#define GPIO_I2C0_SDA_AF		2
+
+/* S3C64XX_GPC(0) */
+
+#define GPIO_PM_SET1			S3C64XX_GPC(1)
+#define GPIO_PM_SET1_AF			1
+
+#define GPIO_PM_SET2			S3C64XX_GPC(2)
+#define GPIO_PM_SET2_AF			1
+
+#define GPIO_PM_SET3			S3C64XX_GPC(3)
+#define GPIO_PM_SET3_AF			1
+
+#define GPIO_WLAN_CMD			S3C64XX_GPC(4)
+#define GPIO_WLAN_CMD_AF		3
+
+#define GPIO_WLAN_CLK			S3C64XX_GPC(5)
+#define GPIO_WLAN_CLK_AF		3
+
+#define GPIO_WLAN_WAKE			S3C64XX_GPC(6)
+#define GPIO_WLAN_WAKE_AF		1
+
+#define GPIO_BT_WAKE			S3C64XX_GPC(7)
+#define GPIO_BT_WAKE_AF			1
+
+#define GPIO_I2S_CLK			S3C64XX_GPD(0)
+#define GPIO_I2S_CLK_AF			3
+
+#define GPIO_BT_WLAN_REG_ON		S3C64XX_GPD(1)
+#define GPIO_BT_WLAN_REG_ON_AF		1
+
+#define GPIO_I2S_LRCLK			S3C64XX_GPD(2)
+#define GPIO_I2S_LRCLK_AF		3
+
+#define GPIO_I2S_DI			S3C64XX_GPD(3)
+#define GPIO_I2S_DI_AF			3
+
+#define GPIO_I2S_DO			S3C64XX_GPD(4)
+#define GPIO_I2S_DO_AF			3
+
+#define GPIO_BT_RST_N			S3C64XX_GPE(0)
+#define GPIO_BT_RST_N_AF		1
+
+#define GPIO_BOOT			S3C64XX_GPE(1)
+#define GPIO_BOOT_AF			0
+
+#define GPIO_WLAN_RST_N			S3C64XX_GPE(2)
+#define GPIO_WLAN_RST_N_AF		1
+
+#define GPIO_PWR_I2C_SCL		S3C64XX_GPE(3)
+#define GPIO_PWR_I2C_SCL_AF		1
+
+#define GPIO_PWR_I2C_SDA		S3C64XX_GPE(4)
+#define GPIO_PWR_I2C_SDA_AF		1
+
+#define GPIO_CAM_MCLK			S3C64XX_GPF(0)
+#define GPIO_CAM_MCLK_AF		2
+
+#define GPIO_CAM_HSYNC			S3C64XX_GPF(1)
+#define GPIO_CAM_HSYNC_AF		2
+
+#define GPIO_CAM_PCLK			S3C64XX_GPF(2)
+#define GPIO_CAM_PCLK_AF		2
+
+#define GPIO_MCAM_RST_N			S3C64XX_GPF(3)
+#define GPIO_MCAM_RST_N_AF		1
+
+#define GPIO_CAM_VSYNC			S3C64XX_GPF(4)
+#define GPIO_CAM_VSYNC_AF		2
+
+#define GPIO_CAM_D_0			S3C64XX_GPF(5)
+#define GPIO_CAM_D_0_AF			2
+
+#define GPIO_CAM_D_1			S3C64XX_GPF(6)
+#define GPIO_CAM_D_1_AF			2
+
+#define GPIO_CAM_D_2			S3C64XX_GPF(7)
+#define GPIO_CAM_D_2_AF			2
+
+#define GPIO_CAM_D_3			S3C64XX_GPF(8)
+#define GPIO_CAM_D_3_AF			2
+
+#define GPIO_CAM_D_4			S3C64XX_GPF(9)
+#define GPIO_CAM_D_4_AF			2
+
+#define GPIO_CAM_D_5			S3C64XX_GPF(10)
+#define GPIO_CAM_D_5_AF			2
+
+#define GPIO_CAM_D_6			S3C64XX_GPF(11)
+#define GPIO_CAM_D_6_AF			2
+
+#define GPIO_CAM_D_7			S3C64XX_GPF(12)
+#define GPIO_CAM_D_7_AF			2
+
+/* S3C_GPF13~14 */
+
+#define GPIO_VIBTONE_PWM		S3C64XX_GPF(15)
+#define GPIO_VIBTONE_PWM_AF		2
+
+#define GPIO_TF_CLK			S3C64XX_GPG(0)
+#define GPIO_TF_CLK_AF			2
+
+#define GPIO_TF_CMD			S3C64XX_GPG(1)
+#define GPIO_TF_CMD_AF			2
+
+#define GPIO_TF_D_0			S3C64XX_GPG(2)
+#define GPIO_TF_D_0_AF			2
+
+#define GPIO_TF_D_1			S3C64XX_GPG(3)
+#define GPIO_TF_D_1_AF			2
+
+#define GPIO_TF_D_2			S3C64XX_GPG(4)
+#define GPIO_TF_D_2_AF			2
+
+#define GPIO_TF_D_3			S3C64XX_GPG(5)
+#define GPIO_TF_D_3_AF			2
+
+/* S3C_GPG6 */
+
+#define GPIO_TOUCH_I2C_SCL		S3C64XX_GPH(0)
+#define GPIO_TOUCH_I2C_SCL_AF		1
+
+#define GPIO_TOUCH_I2C_SDA		S3C64XX_GPH(1)
+#define GPIO_TOUCH_I2C_SDA_AF		1
+
+#define GPIO_FM_I2C_SCL			S3C64XX_GPH(2)
+#define GPIO_FM_I2C_SCL_AF		1
+
+#define GPIO_FM_I2C_SDA			S3C64XX_GPH(3)
+#define GPIO_FM_I2C_SDA_AF		1
+
+#define GPIO_VIB_EN			S3C64XX_GPH(4)
+#define GPIO_VIB_EN_AF			1
+
+/* S3C_GPH5 */
+
+#define GPIO_WLAN_D_0			S3C64XX_GPH(6)
+#define GPIO_WLAN_D_0_AF		3
+
+#define GPIO_WLAN_D_1			S3C64XX_GPH(7)
+#define GPIO_WLAN_D_1_AF		3
+
+#define GPIO_WLAN_D_2			S3C64XX_GPH(8)
+#define GPIO_WLAN_D_2_AF		3
+
+#define GPIO_WLAN_D_3			S3C64XX_GPH(9)
+#define GPIO_WLAN_D_3_AF		3
+
+/* S3C64XX_GPH(6) ~ S3C64XX_GPI(1) */
+
+#define GPIO_LCD_B_0			S3C64XX_GPI(2)
+#define GPIO_LCD_B_0_AF			2
+
+#define GPIO_LCD_B_1			S3C64XX_GPI(3)
+#define GPIO_LCD_B_1_AF			2
+
+#define GPIO_LCD_B_2			S3C64XX_GPI(4)
+#define GPIO_LCD_B_2_AF			2
+
+#define GPIO_LCD_B_3			S3C64XX_GPI(5)
+#define GPIO_LCD_B_3_AF			2
+
+#define GPIO_LCD_B_4			S3C64XX_GPI(6)
+#define GPIO_LCD_B_4_AF			2
+
+#define GPIO_LCD_B_5			S3C64XX_GPI(7)
+#define GPIO_LCD_B_5_AF			2
+
+/* S3C64XX_GPI(8) ~ S3C64XX_GPI(9) */
+
+#define GPIO_LCD_G_0			S3C64XX_GPI(10)
+#define GPIO_LCD_G_0_AF			2
+
+#define GPIO_LCD_G_1			S3C64XX_GPI(11)
+#define GPIO_LCD_G_1_AF			2
+
+#define GPIO_LCD_G_2			S3C64XX_GPI(12)
+#define GPIO_LCD_G_2_AF			2
+
+#define GPIO_LCD_G_3			S3C64XX_GPI(13)
+#define GPIO_LCD_G_3_AF			2
+
+#define GPIO_LCD_G_4			S3C64XX_GPI(14)
+#define GPIO_LCD_G_4_AF			2
+
+#define GPIO_LCD_G_5			S3C64XX_GPI(15)
+#define GPIO_LCD_G_5_AF			2
+
+/* S3C64XX_GPJ(0) ~ S3C64XX_GPJ(1) */
+
+#define GPIO_LCD_R_0			S3C64XX_GPJ(2)
+#define GPIO_LCD_R_0_AF			2
+
+#define GPIO_LCD_R_1			S3C64XX_GPJ(3)
+#define GPIO_LCD_R_1_AF			2
+
+#define GPIO_LCD_R_2			S3C64XX_GPJ(4)
+#define GPIO_LCD_R_2_AF			2
+
+#define GPIO_LCD_R_3			S3C64XX_GPJ(5)
+#define GPIO_LCD_R_3_AF			2
+
+#define GPIO_LCD_R_4			S3C64XX_GPJ(6)
+#define GPIO_LCD_R_4_AF			2
+
+#define GPIO_LCD_R_5			S3C64XX_GPJ(7)
+#define GPIO_LCD_R_5_AF			2
+
+#define GPIO_LCD_HSYNC			S3C64XX_GPJ(8)
+#define GPIO_LCD_HSYNC_AF		2
+
+#define GPIO_LCD_VSYNC			S3C64XX_GPJ(9)
+#define GPIO_LCD_VSYNC_AF		2
+
+#define GPIO_LCD_DE			S3C64XX_GPJ(10)
+#define GPIO_LCD_DE_AF			2
+
+#define GPIO_LCD_CLK			S3C64XX_GPJ(11)
+#define GPIO_LCD_CLK_AF			2
+
+#define GPIO_TA_EN			S3C64XX_GPK(0)
+#define GPIO_TA_EN_AF			1
+
+#define GPIO_AUDIO_EN			S3C64XX_GPK(1)
+#define GPIO_AUDIO_EN_AF		1
+
+#define GPIO_PHONE_ON			S3C64XX_GPK(2)
+#define GPIO_PHONE_ON_AF		1
+
+#define GPIO_MICBIAS_EN			S3C64XX_GPK(3)
+#define GPIO_MICBIAS_EN_AF		1
+
+#define GPIO_UART_SEL			S3C64XX_GPK(4)
+#define GPIO_UART_SEL_AF		1
+
+#define GPIO_TOUCH_RST			S3C64XX_GPK(5)
+#define GPIO_TOUCH_RST_AF		1
+
+#define GPIO_CAM_EN			S3C64XX_GPK(6)
+#define GPIO_CAM_EN_AF			1
+
+#define GPIO_PHONE_RST_N		S3C64XX_GPK(7)
+#define GPIO_PHONE_RST_N_AF		1
+
+#define GPIO_KEYSCAN_0			S3C64XX_GPK(8)
+#define GPIO_KEYSCAN_0_AF		3
+
+#define GPIO_KEYSCAN_1			S3C64XX_GPK(9)
+#define GPIO_KEYSCAN_1_AF		3
+
+#define GPIO_KEYSCAN_2			S3C64XX_GPK(10)
+#define GPIO_KEYSCAN_2_AF		3
+
+#define GPIO_KEYSCAN_3			S3C64XX_GPK(11)
+#define GPIO_KEYSCAN_3_AF		3
+
+/* S3C64XX_GPK(12) ~ S3C64XX_GPK(14) */
+
+#define GPIO_VREG_MSMP_26V		S3C64XX_GPK(15)
+#define GPIO_VREG_MSMP_26V_AF		0
+
+#define GPIO_KEYSENSE_0			S3C64XX_GPL(0)
+#define GPIO_KEYSENSE_0_AF		3
+
+#define GPIO_KEYSENSE_1			S3C64XX_GPL(1)
+#define GPIO_KEYSENSE_1_AF		3
+
+#define GPIO_KEYSENSE_2			S3C64XX_GPL(2)
+#define GPIO_KEYSENSE_2_AF		3
+
+#define GPIO_KEYSENSE_3			S3C64XX_GPL(3)
+#define GPIO_KEYSENSE_3_AF		3
+
+/* S3C64XX_GPL(4) ~ S3C64XX_GPL(6) */
+
+#define GPIO_USIM_BOOT			S3C64XX_GPL(7)
+#define GPIO_USIM_BOOT_AF		1
+
+#define GPIO_CAM_3M_STBY_N		S3C64XX_GPL(8)
+#define GPIO_CAM_3M_STBY_N_AF		1
+
+#define GPIO_HOLD_KEY_N			S3C64XX_GPL(9)
+#define GPIO_HOLD_KEY_N_AF		3
+
+/* S3C64XX_GPL(10) */
+
+#define GPIO_TA_CONNECTED_N		S3C64XX_GPL(11)
+#define GPIO_TA_CONNECTED_N_AF		3
+
+#define GPIO_TOUCH_INT_N		S3C64XX_GPL(12)
+#define GPIO_TOUCH_INT_N_AF		3
+
+#define GPIO_CP_BOOT_SEL		S3C64XX_GPL(13)
+#define GPIO_CP_BOOT_SEL_AF		1
+
+#define GPIO_BT_HOST_WAKE		S3C64XX_GPL(14)
+#define GPIO_BT_HOST_WAKE_AF		3
+
+/* S3C64XX_GPM(0) ~ S3C64XX_GPM(1) */
+
+#define GPIO_TA_CHG_N			S3C64XX_GPM(2)
+#define GPIO_TA_CHG_N_AF		3
+
+#define GPIO_PDA_ACTIVE			S3C64XX_GPM(3)
+#define GPIO_PDA_ACTIVE_AF		1
+
+/* S3C64XX_GPM(4) ~ S3C64XX_GPM(5) */
+
+#define GPIO_ONEDRAM_INT_N		S3C64XX_GPN(0)
+#define GPIO_ONEDRAM_INT_N_AF		2
+
+#define GPIO_WLAN_HOST_WAKE		S3C64XX_GPN(1)
+#define GPIO_WLAN_HOST_WAKE_AF		2
+
+#define GPIO_MSENSE_INT			S3C64XX_GPN(2)
+#define GPIO_MSENSE_INT_AF		2
+
+#define GPIO_ACC_INT			S3C64XX_GPN(3)
+#define GPIO_ACC_INT_AF			2
+
+#define GPIO_SIM_DETECT_N		S3C64XX_GPN(4)
+#define GPIO_SIM_DETECT_N_AF		2
+
+#define GPIO_POWER_N			S3C64XX_GPN(5)
+#define GPIO_POWER_N_AF			2
+
+#define GPIO_TF_DETECT			S3C64XX_GPN(6)
+#define GPIO_TF_DETECT_AF		2
+
+#define GPIO_PHONE_ACTIVE		S3C64XX_GPN(7)
+#define GPIO_PHONE_ACTIVE_AF		2
+
+#define GPIO_PMIC_INT_N			S3C64XX_GPN(8)
+#define GPIO_PMIC_INT_N_AF		2
+
+#define GPIO_JACK_INT_N			S3C64XX_GPN(9)
+#define GPIO_JACK_INT_N_AF		2
+
+#define GPIO_DET_35			S3C64XX_GPN(10)
+#define GPIO_DET_35_AF			2
+
+#define GPIO_EAR_SEND_END		S3C64XX_GPN(11)
+#define GPIO_EAR_SEND_END_AF		2
+
+#define GPIO_RESOUT_N			S3C64XX_GPN(12)
+#define GPIO_RESOUT_N_AF		2
+
+#define GPIO_BOOT_EINT13		S3C64XX_GPN(13)
+#define GPIO_BOOT_EINT13_AF		2
+
+#define GPIO_BOOT_EINT14		S3C64XX_GPN(14)
+#define GPIO_BOOT_EINT14_AF		2
+
+#define GPIO_BOOT_EINT15		S3C64XX_GPN(15)
+#define GPIO_BOOT_EINT15_AF		2
+
+#define GPIO_NAND_CS_N			S3C64XX_GPO(0)
+#define GPIO_NAND_CS_N_AF		2
+
+/* S3C64XX_GPO(1) */
+
+#define GPIO_LCD_RST_N			S3C64XX_GPO(2)
+#define GPIO_LCD_RST_N_AF		1
+
+/* S3C64XX_GPO(3) */
+
+#define GPIO_LCD_CS_N			S3C64XX_GPO(6)
+#define GPIO_LCD_CS_N_AF		1
+
+#define GPIO_LCD_SDI			S3C64XX_GPO(7)
+#define GPIO_LCD_SDI_AF			1
+
+/* S3C64XX_GPO(8) ~ S3C64XX_GPO(11) */
+
+#define GPIO_LCD_ID			S3C64XX_GPO(12)
+#define GPIO_LCD_ID_AF			0
+
+#define GPIO_LCD_SCLK			S3C64XX_GPO(13)
+#define GPIO_LCD_SCLK_AF		1
+
+/* S3C64XX_GPP(0) ~ S3C64XX_GPP(12) */
+
+#define GPIO_PDA_PS_HOLD		S3C64XX_GPP(13)
+#define GPIO_PDA_PS_HOLD_AF		1
+
+/* S3C64XX_GPP(14) ~ S3C64XX_GPQ(6) */
+
+#endif	/* ASM_MACH_SPICA_REV02_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/system.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/system.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/system.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/system.h	2010-05-06 12:42:45.644210217 +0700
@@ -11,14 +11,45 @@
 #ifndef __ASM_ARCH_SYSTEM_H
 #define __ASM_ARCH_SYSTEM_H __FILE__
 
-static void arch_idle(void)
+#include <linux/io.h>
+#include <mach/map.h>
+#include <plat/regs-watchdog.h>
+
+void (*s3c64xx_idle)(void);
+void (*s3c64xx_reset_hook)(void);
+
+void s3c64xx_default_idle(void)
 {
 	/* nothing here yet */
 }
+	
+static void arch_idle(void)
+{
+	if (s3c64xx_idle != NULL)
+		(s3c64xx_idle)();
+	else
+		s3c64xx_default_idle();
+}
 
-static void arch_reset(char mode)
+void arch_reset(char mode)
 {
+	void __iomem	*wdt_reg;
+
+	wdt_reg = ioremap(S3C64XX_PA_WATCHDOG,S3C64XX_SZ_WATCHDOG);
+
 	/* nothing here yet */
+
+	writel(S3C_WTCNT_CNT, wdt_reg + S3C_WTCNT_OFFSET);	/* Watchdog Count Register*/
+	writel(S3C_WTCNT_CON, wdt_reg + S3C_WTCON_OFFSET);	/* Watchdog Controller Register*/
+	writel(S3C_WTCNT_DAT, wdt_reg + S3C_WTDAT_OFFSET);	/* Watchdog Data Register*/
+
+	/* wait for reset to assert... */
+	mdelay(500);
+
+	printk(KERN_ERR "Watchdog reset failed to assert reset\n");
+
+	/* delay to allow the serial port to show the message */
+	mdelay(50);
 }
 
 #endif /* __ASM_ARCH_IRQ_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6400/include/mach/uncompress.h linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/uncompress.h
--- linux-2.6.29/arch/arm/mach-s3c6400/include/mach/uncompress.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mach-s3c6400/include/mach/uncompress.h	2010-05-06 12:42:45.644210217 +0700
@@ -5,7 +5,7 @@
  *	http://armlinux.simtec.co.uk/
  *	Ben Dooks <ben@simtec.co.uk>
  *
- * S3C6400 - uncompress code
+ * S3C64XX - uncompress code
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -21,8 +21,8 @@
 static void arch_detect_cpu(void)
 {
 	/* we do not need to do any cpu detection here at the moment. */
-	fifo_mask = S3C2440_UFSTAT_TXMASK;
-	fifo_max = 63 << S3C2440_UFSTAT_TXSHIFT;
+	fifo_mask = S3C64XX_UFSTAT_TXMASK;
+	fifo_max = 63 << S3C64XX_UFSTAT_TXSHIFT;
 }
 
 #endif /* __ASM_ARCH_UNCOMPRESS_H */
diff -Nur linux-2.6.29/arch/arm/mach-s3c6410/board-rfkill.c linux-2.6.29-spica/arch/arm/mach-s3c6410/board-rfkill.c
--- linux-2.6.29/arch/arm/mach-s3c6410/board-rfkill.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6410/board-rfkill.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Nick Pelly <npelly@google.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/* Control bluetooth power for spica platform */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/rfkill.h>
+#include <linux/delay.h>
+#include <asm/gpio.h>
+#include <mach/gpio.h>
+#include <mach/spica.h>	/*Updated by kumar.gvs 22 Apr 2009*/
+#include <plat/gpio-cfg.h>
+#include <plat/egpio.h>
+#include <linux/wakelock.h>
+#include <linux/irq.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+
+#include <mach/hardware.h>
+#include <linux/i2c/pmic.h>
+
+#define BT_SLEEP_ENABLER
+
+#define IRQ_BT_HOST_WAKE      IRQ_EINT(22)
+
+static struct wake_lock rfkill_wake_lock;
+static struct wake_lock bt_wake_lock;
+
+void rfkill_switch_all(enum rfkill_type type, enum rfkill_state state);
+
+extern void s3c_setup_uart_cfg_gpio(unsigned char port);
+extern void s3c_reset_uart_cfg_gpio(unsigned char port);
+
+static struct rfkill *bt_rfk;
+static const char bt_name[] = "bcm4325";
+
+static int bluetooth_set_power(void *data, enum rfkill_state state)
+{
+	unsigned int ret = 0; 
+	switch (state) {
+
+		case RFKILL_STATE_UNBLOCKED:
+			printk(KERN_DEBUG "[BT] Device Powering ON \n");
+			s3c_setup_uart_cfg_gpio(1);
+
+			if (gpio_is_valid(GPIO_BT_WLAN_REG_ON))
+			{
+				ret = gpio_request(GPIO_BT_WLAN_REG_ON, S3C_GPIO_LAVEL(GPIO_BT_WLAN_REG_ON));
+				if (ret < 0) {
+					printk(KERN_ERR "[BT] Failed to request GPIO_BT_WLAN_REG_ON!\n");
+					return ret;
+				}
+				gpio_direction_output(GPIO_BT_WLAN_REG_ON, GPIO_LEVEL_HIGH);
+			}
+
+			if (gpio_is_valid(GPIO_BT_RST_N))
+			{
+				ret = gpio_request(GPIO_BT_RST_N, S3C_GPIO_LAVEL(GPIO_BT_RST_N));
+				if (ret < 0) {
+					gpio_free(GPIO_BT_WLAN_REG_ON);
+					printk(KERN_ERR "[BT] Failed to request GPIO_BT_RST_N!\n");
+					return ret;			
+				}
+				gpio_direction_output(GPIO_BT_RST_N, GPIO_LEVEL_LOW);
+			}
+
+			/* Set GPIO_BT_WLAN_REG_ON high */ 
+			s3c_gpio_setpull(GPIO_BT_WLAN_REG_ON, S3C_GPIO_PULL_NONE);
+			gpio_set_value(GPIO_BT_WLAN_REG_ON, GPIO_LEVEL_HIGH);
+
+			s3c_gpio_slp_cfgpin(GPIO_BT_WLAN_REG_ON, S3C_GPIO_SLP_OUT1);  
+			s3c_gpio_slp_setpull_updown(GPIO_BT_WLAN_REG_ON, S3C_GPIO_PULL_NONE);
+
+			printk(KERN_DEBUG "[BT] GPIO_BT_WLAN_REG_ON = %d\n", gpio_get_value(GPIO_BT_WLAN_REG_ON));		
+
+			msleep(150);  // 100msec, delay  between reg_on & rst. (bcm4325 powerup sequence)
+
+			/* Set GPIO_BT_RST_N high */
+			s3c_gpio_setpull(GPIO_BT_RST_N, S3C_GPIO_PULL_NONE);
+			gpio_set_value(GPIO_BT_RST_N, GPIO_LEVEL_HIGH);
+
+			s3c_gpio_slp_cfgpin(GPIO_BT_RST_N, S3C_GPIO_SLP_OUT1);
+			s3c_gpio_slp_setpull_updown(GPIO_BT_RST_N, S3C_GPIO_PULL_NONE);
+
+			printk(KERN_DEBUG "[BT] GPIO_BT_RST_N = %d\n", gpio_get_value(GPIO_BT_RST_N));
+
+			gpio_free(GPIO_BT_RST_N);
+			gpio_free(GPIO_BT_WLAN_REG_ON);
+
+			break;
+
+		case RFKILL_STATE_SOFT_BLOCKED:
+			printk(KERN_DEBUG "[BT] Device Powering OFF \n");
+			s3c_reset_uart_cfg_gpio(1);
+
+			s3c_gpio_setpull(GPIO_BT_RST_N, S3C_GPIO_PULL_NONE);
+			gpio_set_value(GPIO_BT_RST_N, GPIO_LEVEL_LOW);
+
+			s3c_gpio_slp_cfgpin(GPIO_BT_RST_N, S3C_GPIO_SLP_OUT0);
+			s3c_gpio_slp_setpull_updown(GPIO_BT_RST_N, S3C_GPIO_PULL_NONE);
+
+			printk(KERN_DEBUG "[BT] GPIO_BT_RST_N = %d\n",gpio_get_value(GPIO_BT_RST_N));
+
+			if(gpio_get_value(GPIO_WLAN_RST_N) == 0)
+			{		
+				s3c_gpio_setpull(GPIO_BT_WLAN_REG_ON, S3C_GPIO_PULL_NONE);
+				gpio_set_value(GPIO_BT_WLAN_REG_ON, GPIO_LEVEL_LOW);
+
+				s3c_gpio_slp_cfgpin(GPIO_BT_WLAN_REG_ON, S3C_GPIO_SLP_OUT0);
+				s3c_gpio_slp_setpull_updown(GPIO_BT_WLAN_REG_ON, S3C_GPIO_PULL_NONE);
+
+				printk(KERN_DEBUG "[BT] GPIO_BT_WLAN_REG_ON = %d\n", gpio_get_value(GPIO_BT_WLAN_REG_ON));
+			}
+
+			gpio_free(GPIO_BT_RST_N);
+			gpio_free(GPIO_BT_WLAN_REG_ON);
+
+			break;
+
+		default:
+			printk(KERN_ERR "[BT] Bad bluetooth rfkill state %d\n", state);
+	}
+
+	return 0;
+}
+
+
+static void bt_host_wake_work_func(struct work_struct *ignored)
+{
+	int gpio_val;
+
+	gpio_val = gpio_get_value(GPIO_BT_HOST_WAKE);
+	printk(KERN_DEBUG "[BT] GPIO_BT_HOST_WAKE = %d\n", gpio_val);
+/*
+	if(gpio_val == GPIO_LEVEL_LOW)
+	{
+		//wake_unlock^M
+		printk("[BT]:wake_unlock \n");
+		wake_unlock(&rfkill_wake_lock);
+	}
+	else
+	{
+		//wake_lock
+		printk("[BT]:wake_lock \n");
+		wake_lock(&rfkill_wake_lock);
+	}
+*/
+
+	if(gpio_val == GPIO_LEVEL_HIGH)
+	{
+		printk(KERN_DEBUG "[BT] wake_lock timeout = 5 sec\n");
+		wake_lock_timeout(&rfkill_wake_lock, 5*HZ);
+	}
+
+	enable_irq(IRQ_EINT(22));
+}
+static DECLARE_WORK(bt_host_wake_work, bt_host_wake_work_func);
+
+
+irqreturn_t bt_host_wake_irq_handler(int irq, void *dev_id)
+{
+	disable_irq(IRQ_EINT(22));
+	schedule_work(&bt_host_wake_work);
+
+	return IRQ_HANDLED;
+}
+
+
+static int __init spica_rfkill_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+	int irq,ret;
+
+	//Initialize wake locks
+	wake_lock_init(&rfkill_wake_lock, WAKE_LOCK_SUSPEND, "board-rfkill");
+	wake_lock_init(&bt_wake_lock, WAKE_LOCK_SUSPEND, "bt-rfkill");
+
+	//BT Host Wake IRQ
+	irq = IRQ_BT_HOST_WAKE;
+
+	ret = request_irq(irq, bt_host_wake_irq_handler, 0, "bt_host_wake_irq_handler", NULL);
+	if(ret < 0)
+		printk(KERN_DEBUG "[BT] Request_irq failed \n");
+
+	set_irq_type(irq, IRQ_TYPE_EDGE_BOTH);
+	enable_irq(IRQ_EINT(22));
+
+	//RFKILL init - default to bluetooth off
+	rfkill_switch_all(RFKILL_TYPE_BLUETOOTH, RFKILL_STATE_SOFT_BLOCKED);
+
+	bt_rfk = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
+	if (!bt_rfk)
+		return -ENOMEM;
+
+	bt_rfk->name = bt_name;
+	bt_rfk->state = RFKILL_STATE_SOFT_BLOCKED;
+	/* userspace cannot take exclusive control */
+	bt_rfk->user_claim_unsupported = 1;
+	bt_rfk->user_claim = 0;
+	bt_rfk->data = NULL;  // user data
+	bt_rfk->toggle_radio = bluetooth_set_power;
+
+	printk(KERN_DEBUG "[BT] rfkill_register(bt_rfk) \n");
+	rc = rfkill_register(bt_rfk);
+	if (rc)
+		rfkill_free(bt_rfk);
+
+	bluetooth_set_power(NULL, RFKILL_STATE_SOFT_BLOCKED);
+
+	return rc;
+}
+
+static struct platform_driver spica_device_rfkill = {
+	.probe = spica_rfkill_probe,
+	.driver = {
+		.name = "bt_rfkill",
+		.owner = THIS_MODULE,
+	},
+};
+
+#ifdef BT_SLEEP_ENABLER
+static struct rfkill *bt_sleep;
+
+static int bluetooth_set_sleep(void *data, enum rfkill_state state)
+{	unsigned int ret =0;
+	switch (state) {
+
+		case RFKILL_STATE_UNBLOCKED:
+			if (gpio_is_valid(GPIO_BT_WAKE))
+			{
+				ret = gpio_request(GPIO_BT_WAKE, S3C_GPIO_LAVEL(GPIO_BT_WAKE));
+				if(ret < 0) {
+					printk(KERN_DEBUG "[BT] Failed to request GPIO_BT_WAKE!\n");
+					return ret;
+				}
+				gpio_direction_output(GPIO_BT_WAKE, GPIO_LEVEL_LOW);
+			}
+
+			s3c_gpio_setpull(GPIO_BT_WAKE, S3C_GPIO_PULL_NONE);
+			gpio_set_value(GPIO_BT_WAKE, GPIO_LEVEL_LOW);
+
+			printk(KERN_DEBUG "[BT] GPIO_BT_WAKE = %d\n", gpio_get_value(GPIO_BT_WAKE) );
+			gpio_free(GPIO_BT_WAKE);
+			//billy's changes
+			printk(KERN_DEBUG "[BT] wake_unlock(bt_wake_lock)\n");
+			wake_unlock(&bt_wake_lock);
+			break;
+
+		case RFKILL_STATE_SOFT_BLOCKED:
+			if (gpio_is_valid(GPIO_BT_WAKE))
+			{
+				ret = gpio_request(GPIO_BT_WAKE, S3C_GPIO_LAVEL(GPIO_BT_WAKE));
+				if(ret < 0) {
+					printk(KERN_DEBUG "[BT] Failed to request GPIO_BT_WAKE!\n");
+					return ret;
+				}
+				gpio_direction_output(GPIO_BT_WAKE, GPIO_LEVEL_HIGH);
+			}
+
+			s3c_gpio_setpull(GPIO_BT_WAKE, S3C_GPIO_PULL_NONE);
+			gpio_set_value(GPIO_BT_WAKE, GPIO_LEVEL_HIGH);
+
+			printk(KERN_DEBUG "[BT] GPIO_BT_WAKE = %d\n", gpio_get_value(GPIO_BT_WAKE) );
+			gpio_free(GPIO_BT_WAKE);
+			//billy's changes
+			printk(KERN_DEBUG "[BT] wake_lock(bt_wake_lock)\n");
+			wake_lock(&bt_wake_lock);
+			break;
+
+		default:
+			printk(KERN_ERR "[BT] bad bluetooth rfkill state %d\n", state);
+	}
+	return 0;
+}
+
+static int __init spica_btsleep_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+
+	bt_sleep = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
+	if (!bt_sleep)
+		return -ENOMEM;
+
+	bt_sleep->name = bt_name;
+	bt_sleep->state = RFKILL_STATE_UNBLOCKED;
+	/* userspace cannot take exclusive control */
+	bt_sleep->user_claim_unsupported = 1;
+	bt_sleep->user_claim = 0;
+	bt_sleep->data = NULL;  // user data
+	bt_sleep->toggle_radio = bluetooth_set_sleep;
+
+	rc = rfkill_register(bt_sleep);
+	if (rc)
+		rfkill_free(bt_sleep);
+
+	printk(KERN_DEBUG "[BT] rfkill_force_state(bt_sleep, RFKILL_STATE_UNBLOCKED) \n");
+	rfkill_force_state(bt_sleep, RFKILL_STATE_UNBLOCKED);
+
+	bluetooth_set_sleep(NULL, RFKILL_STATE_UNBLOCKED);
+
+	return rc;
+}
+
+static struct platform_driver spica_device_btsleep = {
+	.probe = spica_btsleep_probe,
+	.driver = {
+		.name = "bt_sleep",
+		.owner = THIS_MODULE,
+	},
+};
+#endif
+
+static int __init spica_rfkill_init(void)
+{
+	int rc = 0;
+	rc = platform_driver_register(&spica_device_rfkill);
+
+#ifdef BT_SLEEP_ENABLER
+	platform_driver_register(&spica_device_btsleep);
+#endif
+
+	return rc;
+}
+
+module_init(spica_rfkill_init);
+MODULE_DESCRIPTION("spica rfkill");
+MODULE_AUTHOR("Nick Pelly <npelly@google.com>");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/arch/arm/mach-s3c6410/cpu.c linux-2.6.29-spica/arch/arm/mach-s3c6410/cpu.c
--- linux-2.6.29/arch/arm/mach-s3c6410/cpu.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mach-s3c6410/cpu.c	2010-05-06 12:42:45.644210217 +0700
@@ -26,11 +26,15 @@
 #include <asm/mach/map.h>
 #include <asm/mach/irq.h>
 
+#include <asm/proc-fns.h>
+#include <mach/idle.h>
+
 #include <mach/hardware.h>
 #include <asm/irq.h>
 
 #include <plat/cpu-freq.h>
 #include <plat/regs-serial.h>
+#include <plat/regs-clock.h>
 
 #include <plat/cpu.h>
 #include <plat/devs.h>
@@ -39,12 +43,34 @@
 #include <plat/iic-core.h>
 #include <plat/s3c6400.h>
 #include <plat/s3c6410.h>
+#include <mach/map.h>
 
 /* Initial IO mappings */
 
 static struct map_desc s3c6410_iodesc[] __initdata = {
+	IODESC_ENT(LCD),
+	IODESC_ENT(SROMC),
+	IODESC_ENT(HOSTIFB),
+	IODESC_ENT(OTG),
+	IODESC_ENT(OTGSFR),
+	IODESC_ENT(ONENAND),
 };
 
+static void s3c6410_idle(void)
+{
+	unsigned long tmp;
+
+	/* Ensure our idle mode is to go to idle */
+	/* Set WFI instruction to SLEEP mode */
+
+	tmp = __raw_readl(S3C_PWR_CFG);
+	tmp &= ~(0x3<<5);
+	tmp |= (0x1<<5);
+	__raw_writel(tmp, S3C_PWR_CFG);
+
+	cpu_do_idle();
+}
+
 /* s3c6410_map_io
  *
  * register the standard cpu IO areas
@@ -55,21 +81,28 @@
 	iotable_init(s3c6410_iodesc, ARRAY_SIZE(s3c6410_iodesc));
 
 	/* initialise device information early */
+
 	s3c6410_default_sdhci0();
-	s3c6410_default_sdhci1();
 
-	/* the i2c devices are directly compatible with s3c2440 */
-	s3c_i2c0_setname("s3c2440-i2c");
-	s3c_i2c1_setname("s3c2440-i2c");
+#if defined(CONFIG_MACH_SPICA)
+	s3c6410_default_sdhci2();
+#endif
+
+	/* the i2c devices are directly compatible with s3c */
+	s3c_i2c0_setname("s3c-i2c");
+	s3c_i2c1_setname("s3c-i2c");
+
+	/* set our idle function */
+	s3c64xx_idle = s3c6410_idle;
 }
 
 void __init s3c6410_init_clocks(int xtal)
 {
 	printk(KERN_DEBUG "%s: initialising clocks\n", __func__);
-	s3c24xx_register_baseclocks(xtal);
+	s3c_register_baseclocks(xtal);
 	s3c64xx_register_clocks();
-	s3c6400_register_clocks();
-	s3c6400_setup_clocks();
+	s3c6410_register_clocks();
+	s3c64xx_setup_clocks();
 }
 
 void __init s3c6410_init_irq(void)
diff -Nur linux-2.6.29/arch/arm/mach-s3c6410/dma.c linux-2.6.29-spica/arch/arm/mach-s3c6410/dma.c
--- linux-2.6.29/arch/arm/mach-s3c6410/dma.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6410/dma.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,364 @@
+/* linux/arch/arm/mach-s3c6410/dma.c
+ *
+ * Copyright (c) 2003-2005,2006 Samsung Electronics
+ *
+ * S3C6410 DMA selection
+ *
+ * http://www.samsung.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sysdev.h>
+#include <linux/serial_core.h>
+
+#include <asm/dma.h>
+#include <mach/dma.h>
+#include <asm/io.h>
+
+#include <plat/dma.h>
+#include <plat/cpu.h>
+
+
+/* DMAC-0 */
+#define MAP0(x) { \
+		[0]	= (x) | DMA_CH_VALID,	\
+		[1]	= (x) | DMA_CH_VALID,	\
+		[2]	= (x) | DMA_CH_VALID,	\
+		[3]	= (x) | DMA_CH_VALID,	\
+		[4]	= (x) | DMA_CH_VALID,	\
+		[5]     = (x) | DMA_CH_VALID,	\
+		[6]	= (x) | DMA_CH_VALID,	\
+		[7]     = (x) | DMA_CH_VALID,	\
+		[8]	= (x),	\
+		[9]	= (x),	\
+		[10]	= (x),	\
+		[11]	= (x),	\
+		[12]	= (x),	\
+		[13]    = (x),	\
+		[14]	= (x),	\
+		[15]    = (x),	\
+		[16]	= (x),	\
+		[17]	= (x),	\
+		[18]	= (x),	\
+		[19]	= (x),	\
+		[20]	= (x),	\
+		[21]    = (x),	\
+		[22]	= (x),	\
+		[23]    = (x),	\
+		[24]	= (x),	\
+		[25]	= (x),	\
+		[26]	= (x),	\
+		[27]	= (x),	\
+		[28]	= (x),	\
+		[29]    = (x),	\
+		[30]	= (x),	\
+		[31]    = (x),	\
+	}
+
+/* DMAC-1 */
+#define MAP1(x) { \
+		[0]	= (x),	\
+		[1]	= (x),	\
+		[2]	= (x),	\
+		[3]	= (x),	\
+		[4]	= (x),	\
+		[5]     = (x),	\
+		[6]	= (x),	\
+		[7]     = (x),	\
+		[8]	= (x) | DMA_CH_VALID,	\
+		[9]	= (x) | DMA_CH_VALID,	\
+		[10]	= (x) | DMA_CH_VALID,	\
+		[11]	= (x) | DMA_CH_VALID,	\
+		[12]	= (x) | DMA_CH_VALID,	\
+		[13]    = (x) | DMA_CH_VALID,	\
+		[14]	= (x) | DMA_CH_VALID,	\
+		[15]    = (x) | DMA_CH_VALID,	\
+		[16]	= (x),	\
+		[17]	= (x),	\
+		[18]	= (x),	\
+		[19]	= (x),	\
+		[20]	= (x),	\
+		[21]    = (x),	\
+		[22]	= (x),	\
+		[23]    = (x),	\
+		[24]	= (x),	\
+		[25]	= (x),	\
+		[26]	= (x),	\
+		[27]	= (x),	\
+		[28]	= (x),	\
+		[29]    = (x),	\
+		[30]	= (x),	\
+		[31]    = (x),	\
+	}
+
+/* SDMAC-0 */
+#define MAP2(x) { \
+		[0]	= (x),	\
+		[1]	= (x),	\
+		[2]	= (x),	\
+		[3]	= (x),	\
+		[4]	= (x),	\
+		[5]     = (x),	\
+		[6]	= (x),	\
+		[7]     = (x),	\
+		[8]	= (x),	\
+		[9]	= (x),	\
+		[10]	= (x),	\
+		[11]	= (x),	\
+		[12]	= (x),	\
+		[13]    = (x),	\
+		[14]	= (x),	\
+		[15]    = (x),	\
+		[16]	= (x) | DMA_CH_VALID,	\
+		[17]	= (x) | DMA_CH_VALID,	\
+		[18]	= (x) | DMA_CH_VALID,	\
+		[19]	= (x) | DMA_CH_VALID,	\
+		[20]	= (x) | DMA_CH_VALID,	\
+		[21]    = (x) | DMA_CH_VALID,	\
+		[22]	= (x) | DMA_CH_VALID,	\
+		[23]    = (x) | DMA_CH_VALID,	\
+		[24]	= (x),	\
+		[25]	= (x),	\
+		[26]	= (x),	\
+		[27]	= (x),	\
+		[28]	= (x),	\
+		[29]    = (x),	\
+		[30]	= (x),	\
+		[31]    = (x),	\
+	}
+
+/* SDMAC-1 */
+#define MAP3(x) { \
+		[0]	= (x),	\
+		[1]	= (x),	\
+		[2]	= (x),	\
+		[3]	= (x),	\
+		[4]	= (x),	\
+		[5]     = (x),	\
+		[6]	= (x),	\
+		[7]     = (x),	\
+		[8]	= (x),	\
+		[9]	= (x),	\
+		[10]	= (x),	\
+		[11]	= (x),	\
+		[12]	= (x),	\
+		[13]    = (x),	\
+		[14]	= (x),	\
+		[15]    = (x),	\
+		[16]	= (x),	\
+		[17]	= (x),	\
+		[18]	= (x),	\
+		[19]	= (x),	\
+		[20]	= (x),	\
+		[21]    = (x),	\
+		[22]	= (x),	\
+		[23]    = (x),	\
+		[24]	= (x) | DMA_CH_VALID,	\
+		[25]	= (x) | DMA_CH_VALID,	\
+		[26]	= (x) | DMA_CH_VALID,	\
+		[27]	= (x) | DMA_CH_VALID,	\
+		[28]	= (x) | DMA_CH_VALID,	\
+		[29]    = (x) | DMA_CH_VALID,	\
+		[30]	= (x) | DMA_CH_VALID,	\
+		[31]    = (x) | DMA_CH_VALID,	\
+	}
+
+/* SDMAC-0 */
+#define MAP2_ONENAND(x) { \
+		[0]	= (x),	\
+		[1]	= (x),	\
+		[2]	= (x),	\
+		[3]	= (x) ,	\
+		[4]	= (x),	\
+		[5]     = (x),	\
+		[6]	= (x),	\
+		[7]     = (x),	\
+		[8]	= (x),	\
+		[9]	= (x),	\
+		[10]	= (x),	\
+		[11]	= (x),	\
+		[12]	= (x),	\
+		[13]    = (x),	\
+		[14]	= (x),	\
+		[15]    = (x),	\
+		[16]	= (x),	\
+		[17]	= (x),	\
+		[18]	= (x) ,	\
+		[19]	= (x) | DMA_CH_VALID,	\
+		[20]	= (x),	\
+		[21]    = (x),	\
+		[22]	= (x),	\
+		[23]    = (x),	\
+		[24]	= (x),	\
+		[25]	= (x),	\
+		[26]	= (x),	\
+		[27]	= (x),	\
+		[28]	= (x),	\
+		[29]    = (x),	\
+		[30]	= (x),	\
+		[31]    = (x),	\
+	}
+
+
+/* DMAC0 DMA request sources */
+#define S3C_DMA0_UART0CH0	0
+#define S3C_DMA0_UART0CH1	1
+#define S3C_DMA0_UART1CH0	2
+#define S3C_DMA0_UART1CH1	3
+#define S3C_DMA0_ONENAND_RX	3	/* Memory to Memory DMA */
+#define S3C_DMA0_UART2CH0	4
+#define S3C_DMA0_UART2CH1	5
+#define S3C_DMA0_UART3CH0	6
+#define S3C_DMA0_UART3CH1	7
+#define S3C_DMA0_PCM0_TX	8
+#define S3C_DMA0_PCM0_RX	9
+#define S3C_DMA0_I2S0_TX	10
+#define S3C_DMA0_I2S0_RX	11
+#define S3C_DMA0_SPI0_TX	12
+#define S3C_DMA0_SPI0_RX	13
+#define S3C_DMA0_HSI_TX		14
+#define S3C_DMA0_HSI_RX		15
+
+/* DMAC1 DMA request sources */
+#define S3C_DMA1_PCM1_TX	0
+#define S3C_DMA1_PCM1_RX	1
+#define S3C_DMA1_I2S1_TX	2
+#define S3C_DMA1_I2S1_RX	3
+#define S3C_DMA1_SPI1_TX	4
+#define S3C_DMA1_SPI1_RX	5
+#define S3C_DMA1_AC97_PCMOUT	6
+#define S3C_DMA1_AC97_PCMIN	7
+#define S3C_DMA1_AC97_MICIN	8
+#define S3C_DMA1_PWM		9
+#define S3C_DMA1_IRDA		10
+#define S3C_DMA1_EXT		11
+
+
+static struct s3c_dma_map __initdata s3c6410_dma_mappings[] = {
+
+	[DMACH_I2S_IN] = {
+		.name		= "i2s0-in",
+		.channels	= MAP0(S3C_DMA0_I2S0_RX),
+		.hw_addr.from	= S3C_DMA0_I2S0_RX,
+		.sdma_sel	= 1 << S3C_DMA0_I2S0_RX,
+	},
+	[DMACH_I2S_OUT] = {
+		.name		= "i2s0-out",
+		.channels	= MAP0(S3C_DMA0_I2S0_TX),
+		.hw_addr.to	= S3C_DMA0_I2S0_TX,
+		.sdma_sel	= 1 << S3C_DMA0_I2S0_TX,
+	},
+	[DMACH_I2S1_IN] = {
+		.name		= "i2s1-in",
+		.channels	= MAP1(S3C_DMA1_I2S1_RX),
+		.hw_addr.from	= S3C_DMA1_I2S1_RX,
+		.sdma_sel	= 1 << (S3C_DMA1_I2S1_RX+S3C_DMA1),
+	},
+	[DMACH_I2S1_OUT] = {
+		.name		= "i2s1-out",
+		.channels	= MAP1(S3C_DMA1_I2S1_TX),
+		.hw_addr.to	= S3C_DMA1_I2S1_TX,
+		.sdma_sel	= 1 << (S3C_DMA1_I2S1_TX+S3C_DMA1),
+	},
+	[DMACH_SPI0_IN] = {
+		.name		= "spi0-in",
+		.channels	= MAP0(S3C_DMA0_SPI0_RX),
+		.hw_addr.from	= S3C_DMA0_SPI0_RX,
+		.sdma_sel	= 1 << S3C_DMA0_SPI0_RX,
+	},
+	[DMACH_SPI0_OUT] = {
+		.name		= "spi0-out",
+		.channels	= MAP0(S3C_DMA0_SPI0_TX),
+		.hw_addr.to	= S3C_DMA0_SPI0_TX,
+		.sdma_sel	= 1 << S3C_DMA0_SPI0_TX,
+	},
+	[DMACH_SPI1_IN] = {
+		.name		= "spi1-in",
+		.channels	= MAP1(S3C_DMA1_SPI1_RX),
+		.hw_addr.from	= S3C_DMA1_SPI1_RX,
+		.sdma_sel	= 1 << (S3C_DMA1_SPI1_RX+S3C_DMA1),
+	},
+	[DMACH_SPI1_OUT] = {
+		.name		= "spi1-out",
+		.channels	= MAP1(S3C_DMA1_SPI1_TX),
+		.hw_addr.to	= S3C_DMA1_SPI1_TX,
+		.sdma_sel	= 1 << (S3C_DMA1_SPI1_TX+S3C_DMA1),
+	},
+	[DMACH_AC97_PCM_OUT] = {
+		.name		= "ac97-pcm-out",
+		.channels	= MAP1(S3C_DMA1_AC97_PCMOUT),
+		.hw_addr.to	= S3C_DMA1_AC97_PCMOUT,
+		.sdma_sel	= 1 << (S3C_DMA1_AC97_PCMOUT+S3C_DMA1),
+	},
+	[DMACH_AC97_PCM_IN] = {
+		.name		= "ac97-pcm-in",
+		.channels	= MAP1(S3C_DMA1_AC97_PCMIN),
+		.hw_addr.from	= S3C_DMA1_AC97_PCMIN,
+		.sdma_sel	= 1 << (S3C_DMA1_AC97_PCMIN+S3C_DMA1),
+	},
+	[DMACH_AC97_MIC_IN] = {
+		.name		= "ac97-mic-in",
+		.channels	= MAP1(S3C_DMA1_AC97_MICIN),
+		.hw_addr.from	= S3C_DMA1_AC97_MICIN,
+		.sdma_sel	= 1 << (S3C_DMA1_AC97_MICIN+S3C_DMA1),
+	},
+	[DMACH_ONENAND_IN] = {
+		.name		= "onenand-in",
+		.channels	= MAP2_ONENAND(S3C_DMA0_ONENAND_RX),
+		.hw_addr.from	= S3C_DMA0_ONENAND_RX,
+	},
+	[DMACH_3D_M2M] = {
+		.name		= "3D-M2M",
+		.channels	= MAP1(S3C_DMA1_EXT),
+		.hw_addr.from	= S3C_DMA1_EXT,
+	},
+        [DMACH_I2S_V40_IN] = {                                                           
+		.name           = "i2s-v40-in",                                          
+		.channels       = MAP0(S3C_DMA0_HSI_RX),                                 
+		.hw_addr.from   = S3C_DMA0_HSI_RX,                                       
+		.sdma_sel       = 1 << S3C_DMA0_HSI_RX,                                  
+	},                                                                               
+	[DMACH_I2S_V40_OUT] = {                                                          
+		.name           = "i2s-v40-out",                                         
+		.channels       = MAP0(S3C_DMA0_HSI_TX),                                 
+		.hw_addr.to     = S3C_DMA0_HSI_TX,                                       
+		.sdma_sel       = 1 << S3C_DMA0_HSI_TX,                                  
+	}, 
+};
+
+static void s3c6410_dma_select(struct s3c2410_dma_chan *chan,
+			       struct s3c_dma_map *map)
+{
+	chan->map = map;
+}
+
+static struct s3c_dma_selection __initdata s3c6410_dma_sel = {
+	.select		= s3c6410_dma_select,
+	.dcon_mask	= 0,
+	.map		= s3c6410_dma_mappings,
+	.map_size	= ARRAY_SIZE(s3c6410_dma_mappings),
+};
+
+static int __init s3c6410_dma_add(struct sys_device *sysdev)
+{
+	s3c_dma_init(S3C_DMA_CHANNELS, IRQ_DMA0, 0x20);
+	return s3c_dma_init_map(&s3c6410_dma_sel);
+}
+
+static struct sysdev_driver s3c6410_dma_driver = {
+	.add	= s3c6410_dma_add,
+};
+
+static int __init s3c6410_dma_init(void)
+{
+	return sysdev_driver_register(&s3c6410_sysclass, &s3c6410_dma_driver);
+}
+
+arch_initcall(s3c6410_dma_init);
+
+
diff -Nur linux-2.6.29/arch/arm/mach-s3c6410/irq.c linux-2.6.29-spica/arch/arm/mach-s3c6410/irq.c
--- linux-2.6.29/arch/arm/mach-s3c6410/irq.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6410/irq.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,47 @@
+/* linux/arch/arm/mach-s3c6410/irq.c
+ *
+ * Copyright (c) 2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/sysdev.h>
+
+#include <plat/cpu.h>
+#include <plat/pm.h>
+
+static int s3c6410_irq_add(struct sys_device *sysdev)
+{
+	return 0;
+}
+
+static struct sysdev_driver s3c6410_irq_driver = {
+	.add		= s3c6410_irq_add,
+	.suspend	= s3c64xx_irq_suspend,
+	.resume		= s3c64xx_irq_resume,
+};
+
+static int s3c6410_irq_init(void)
+{
+	return sysdev_driver_register(&s3c6410_sysclass, &s3c6410_irq_driver);
+}
+
+arch_initcall(s3c6410_irq_init);
diff -Nur linux-2.6.29/arch/arm/mach-s3c6410/Kconfig linux-2.6.29-spica/arch/arm/mach-s3c6410/Kconfig
--- linux-2.6.29/arch/arm/mach-s3c6410/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mach-s3c6410/Kconfig	2010-05-06 12:42:45.644210217 +0700
@@ -9,8 +9,8 @@
 
 config CPU_S3C6410
 	bool
-	select CPU_S3C6400_INIT
-	select CPU_S3C6400_CLOCK
+	select CPU_S3C64XX_INIT
+	select CPU_S3C64XX_CLOCK
 	help
 	  Enable S3C6410 CPU support
 
@@ -19,44 +19,93 @@
 	help
 	  Internal helper functions for S3C6410 based SDHCI systems
 
+menu "Samsung S3C6410 Implementations"
+
+choice
+	prompt "Select Machine"
+
 config MACH_SMDK6410
 	bool "SMDK6410"
 	select CPU_S3C6410
 	select S3C_DEV_HSMMC
 	select S3C_DEV_HSMMC1
 	select S3C_DEV_I2C1
-	select S3C_DEV_FB
 	select S3C6410_SETUP_SDHCI
 	select S3C64XX_SETUP_I2C1
-	select S3C64XX_SETUP_FB_24BPP
+	select S3C_DMA_PL080
 	help
 	  Machine support for the Samsung SMDK6410
 
+config MACH_SPICA
+	bool "SPICA"
+	select CPU_S3C6410
+	select S3C_DEV_HSMMC
+	select S3C_DEV_HSMMC2
+	select S3C_DEV_I2C1
+	select S3C6410_SETUP_SDHCI
+	select S3C64XX_SETUP_I2C1
+	select S3C64XX_ADCTS
+#	select S3C_DMA_PL080_NEW
+	help
+	  Machine support for the Samsung SPICA
+
+endchoice
+
 # At least some of the SMDK6410s were shipped with the card detect
 # for the MMC/SD slots connected to the same input. This means that
 # either the boards need to be altered to have channel0 to an alternate
 # configuration or that only one slot can be used.
 
 choice
-	prompt "SMDK6410 MMC/SD slot setup"
+	prompt "S3C6410 MMC/SD slot setup"
 	depends on MACH_SMDK6410
 
-config SMDK6410_SD_CH0
+config S3C6410_SD_CH0
 	bool "Use channel 0 only"
 	depends on MACH_SMDK6410
 	help
-          Select CON7 (channel 0) as the MMC/SD slot, as
+      Select CON7 (channel 0) as the MMC/SD slot, as
 	  at least some SMDK6410 boards come with the
 	  resistors fitted so that the card detects for
 	  channels 0 and 1 are the same.
        
-config SMDK6410_SD_CH1
+config S3C6410_SD_CH1
 	bool "Use channel 1 only"
 	depends on MACH_SMDK6410
 	help
-          Select CON6 (channel 1) as the MMC/SD slot, as
+      Select CON6 (channel 1) as the MMC/SD slot, as
 	  at least some SMDK6410 boards come with the
 	  resistors fitted so that the card detects for
 	  channels 0 and 1 are the same.
 
+config S3C6410_SD_CH2
+	bool "Use channel 2 only"
+	depends on MACH_SMDK6410
+	help
+      Select CON6 (channel 1) as the MMC/SD slot, as
+	  at least some SMDK6410 boards come with the
+	  resistors fitted so that the card detects for
+	  channels 0 and 1 are the same.
+
+
 endchoice
+
+config BOARD_REVISION
+	hex "Select H/W Revision"
+	depends on MACH_SPICA
+	default "0x00"
+
+config SEC_HEADSET
+        tristate "SEC 2 Wire detection driver"
+        default n
+        help
+         Provides support for detecting SEC 2 wire devices, such as wired
+         headset.
+
+config SEC_LOG_BUF
+	tristate "SEC Log Buffer"
+	default n
+	help
+	  Provides support for SEC log buffer shared with Loke bootloader.
+
+endmenu
diff -Nur linux-2.6.29/arch/arm/mach-s3c6410/mach-spica.c linux-2.6.29-spica/arch/arm/mach-s3c6410/mach-spica.c
--- linux-2.6.29/arch/arm/mach-s3c6410/mach-spica.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6410/mach-spica.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,1487 @@
+/* linux/arch/arm/mach-s3c6410/mach-spica.c
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ctype.h>
+#include <linux/reboot.h>
+#include <linux/leds.h>
+
+#include <linux/bootmem.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_gpio.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/map.h>
+#include <mach/regs-mem.h>
+#include <mach/param.h>
+
+#include <asm/irq.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <plat/regs-serial.h>
+#include <plat/regs-rtc.h>
+#include <plat/regs-clock.h>
+#include <plat/regs-gpio.h>
+#include <plat/iic.h>
+
+#include <plat/nand.h>
+#include <plat/partition.h>
+#include <plat/s3c6410.h>
+#include <plat/clock.h>
+#include <plat/devs.h>
+#include <plat/cpu.h>
+#include <plat/adcts.h>
+#include <plat/ts.h>
+#include <plat/adc.h>
+#include <plat/reserved_mem.h>
+#include <plat/pm.h>
+
+#include <mach/gpio.h>
+#include <mach/gpio-core.h>
+
+#include <plat/gpio-cfg.h>
+#include <linux/android_pmem.h>
+#include <linux/i2c/pmic.h>
+
+#include <linux/delay.h> // yoohyuk 2009-03-16 just test codes.
+#include <mach/sec_headset.h>
+
+struct class *sec_class;
+EXPORT_SYMBOL(sec_class);
+
+struct device *switch_dev;
+EXPORT_SYMBOL(switch_dev);
+
+void (*sec_set_param_value)(int idx, void *value);
+EXPORT_SYMBOL(sec_set_param_value);
+
+void (*sec_get_param_value)(int idx, void *value);
+EXPORT_SYMBOL(sec_get_param_value);
+
+void spica_init_gpio(void);
+
+extern void (*ftm_enable_usb_sw)(int mode);
+extern void fsa9480_SetAutoSWMode(void);
+extern void fsa9480_MakeRxdLow(void);
+
+#define UCON S3C_UCON_DEFAULT
+#define ULCON S3C_LCON_CS8 | S3C_LCON_PNONE
+#define UFCON S3C_UFCON_RXTRIG8 | S3C_UFCON_FIFOMODE
+
+#define S3C64XX_KERNEL_PANIC_DUMP_SIZE 0x8000 /* 32kbytes */
+void *S3C64XX_KERNEL_PANIC_DUMP_ADDR;
+#ifndef CONFIG_HIGH_RES_TIMERS
+extern struct sys_timer s3c64xx_timer;
+#else
+extern struct sys_timer sec_timer;
+#endif /* CONFIG_HIGH_RES_TIMERS */
+
+static struct s3c_uartcfg spica_uartcfgs[] __initdata = {
+	[0] = {	/* Phone */
+		.hwport	     = 0,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
+	},
+	[1] = {	/* Bluetooth */
+		.hwport	     = 1,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
+	},
+	[2] = {	/* Serial */
+		.hwport	     = 2,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
+	},
+};
+
+#if defined(CONFIG_I2C_GPIO)
+#if 0	
+static struct i2c_gpio_platform_data i2c2_platdata = {
+	.sda_pin		= GPIO_EXT_I2C_SDA,
+	.scl_pin		= GPIO_EXT_I2C_SCL,
+	.udelay			= 2,	/* 250KHz */		
+	.sda_is_open_drain	= 0,
+	.scl_is_open_drain	= 0,
+	.scl_is_output_only	= 1,
+};
+
+static struct platform_device s3c_device_i2c2 = {
+	.name				= "i2c-gpio",
+	.id					= 2,
+	.dev.platform_data	= &i2c2_platdata,
+};
+#endif
+static struct i2c_gpio_platform_data i2c3_platdata = {
+	.sda_pin		= GPIO_PWR_I2C_SDA,
+	.scl_pin		= GPIO_PWR_I2C_SCL,
+	.udelay			= 2,	/* 250KHz */		
+	.sda_is_open_drain	= 0,
+	.scl_is_open_drain	= 0,
+	.scl_is_output_only	= 1,
+};
+
+static struct platform_device s3c_device_i2c3 = {
+	.name				= "i2c-gpio",
+	.id					= 3,
+	.dev.platform_data	= &i2c3_platdata,
+};
+
+#if 0
+static struct i2c_gpio_platform_data i2c4_platdata = {
+	.sda_pin		= GPIO_EMUL_I2C_SDA,
+	.scl_pin		= GPIO_EMUL_I2C_SCL,
+	.udelay			= 2,	/* 250KHz */		
+	.sda_is_open_drain	= 0,
+	.scl_is_open_drain	= 0,
+	.scl_is_output_only	= 1,
+};
+
+static struct platform_device s3c_device_i2c4 = {
+	.name				= "i2c-gpio",
+	.id					= 4,
+	.dev.platform_data	= &i2c4_platdata,
+};
+#endif
+
+static struct i2c_gpio_platform_data i2c5_platdata = {
+	.sda_pin		= GPIO_FM_I2C_SDA,
+	.scl_pin		= GPIO_FM_I2C_SCL,
+	.udelay			= 2,	/* 250KHz */		
+	.sda_is_open_drain	= 0,
+	.scl_is_open_drain	= 0,
+	.scl_is_output_only	= 1,
+};
+
+static struct platform_device s3c_device_i2c5 = {
+	.name				= "i2c-gpio",
+	.id					= 5,
+	.dev.platform_data	= &i2c5_platdata,
+};
+
+static struct i2c_gpio_platform_data i2c6_platdata = {
+	.sda_pin		= GPIO_TOUCH_I2C_SDA,
+	.scl_pin		= GPIO_TOUCH_I2C_SCL,
+	.udelay			= 6,	/* KSS : Change I2C speed to avoid error in TSP */
+	.sda_is_open_drain	= 0,
+	.scl_is_open_drain	= 0,
+	.scl_is_output_only	= 0,
+//	.scl_is_output_only	= 1,
+};
+
+static struct platform_device s3c_device_i2c6 = {
+	.name				= "i2c-gpio",
+	.id					= 6,
+	.dev.platform_data	= &i2c6_platdata,
+};
+#endif
+
+#ifdef CONFIG_FB_S3C_S6D04D1
+struct platform_device sec_device_backlight = {
+	.name   = "s6d04d1-backlight",
+	.id     = -1,
+};
+#elif defined(CONFIG_FB_S3C_S6D05A)
+struct platform_device sec_device_backlight = {
+	.name   = "s6d05a-backlight",
+	.id     = -1,
+};
+#endif
+
+
+struct platform_device sec_device_dpram = {
+	.name	= "dpram-device",
+	.id		= -1,
+};
+
+struct platform_device sec_device_ts = {
+	.name	= "qt5480-ts",
+	.id		= -1,
+};
+
+struct platform_device sec_device_eled = {
+	.name   = "bd2802gue2-eled",
+	.id		= -1,
+
+};
+
+struct platform_device sec_device_battery = {
+	.name   = "spica-battery",
+	.id		= -1,
+};
+
+struct platform_device sec_device_rfkill = {
+	.name = "bt_rfkill",
+	.id = -1,
+};
+
+struct platform_device sec_device_btsleep = {
+	.name = "bt_sleep",
+	.id = -1,
+};
+
+static struct sec_headset_port sec_headset_port[] = {
+        {
+		{ // HEADSET detect info
+			.eint		= IRQ_EINT(10), 
+			.gpio		= GPIO_DET_35,   
+			.gpio_af	= GPIO_DET_35_AF  , 
+			.low_active 	= 0
+		},{ // SEND/END info
+			.eint		= IRQ_EINT(11), 
+			.gpio		= GPIO_EAR_SEND_END, 
+			.gpio_af	= GPIO_EAR_SEND_END_AF, 
+			.low_active	= 1
+		}
+        }
+};
+ 
+static struct sec_headset_platform_data sec_headset_data = {
+        .port           = sec_headset_port,
+        .nheadsets      = ARRAY_SIZE(sec_headset_port),
+};
+
+static struct platform_device sec_device_headset = {
+        .name           = "sec_headset",
+        .id             = -1,
+        .dev            = {
+                .platform_data  = &sec_headset_data,
+        },
+};
+
+static struct s3c6410_pmem_setting pmem_setting = {
+        .pmem_start = RESERVED_PMEM_START,
+        .pmem_size = RESERVED_PMEM,
+        .pmem_gpu1_start = GPU1_RESERVED_PMEM_START,
+        .pmem_gpu1_size = RESERVED_PMEM_GPU1,
+        .pmem_render_start = RENDER_RESERVED_PMEM_START,
+        .pmem_render_size = RESERVED_PMEM_RENDER,
+        .pmem_stream_start = STREAM_RESERVED_PMEM_START,
+        .pmem_stream_size = RESERVED_PMEM_STREAM,
+        .pmem_preview_start = PREVIEW_RESERVED_PMEM_START,
+        .pmem_preview_size = RESERVED_PMEM_PREVIEW,
+        .pmem_picture_start = PICTURE_RESERVED_PMEM_START,
+        .pmem_picture_size = RESERVED_PMEM_PICTURE,
+        .pmem_jpeg_start = JPEG_RESERVED_PMEM_START,
+        .pmem_jpeg_size = RESERVED_PMEM_JPEG,
+        .pmem_skia_start = SKIA_RESERVED_PMEM_START,
+        .pmem_skia_size = RESERVED_PMEM_SKIA,
+};
+
+#ifdef CONFIG_S3C64XX_ADCTS
+static struct s3c_adcts_plat_info s3c_adcts_cfgs __initdata = {
+	.channel = {
+		{ /* 0 */
+			.delay = 0xFF,
+			.presc = 49,
+			.resol = S3C_ADCCON_RESSEL_12BIT,
+		},{ /* 1 */
+			.delay = 0xFF,
+			.presc = 49,
+			.resol = S3C_ADCCON_RESSEL_12BIT,
+		},{ /* 2 */
+			.delay = 0xFF,
+			.presc = 49,
+			.resol = S3C_ADCCON_RESSEL_12BIT,
+		},{ /* 3 */
+			.delay = 0xFF,
+			.presc = 49,
+			.resol = S3C_ADCCON_RESSEL_12BIT,
+		},{ /* 4 */
+			.delay = 0xFF,
+			.presc = 49,
+			.resol = S3C_ADCCON_RESSEL_12BIT,
+		},{ /* 5 */
+			.delay = 0xFF,
+			.presc = 49,
+			.resol = S3C_ADCCON_RESSEL_12BIT,
+		},{ /* 6 */
+			.delay = 0xFF,
+			.presc = 49,
+			.resol = S3C_ADCCON_RESSEL_12BIT,
+		},{ /* 7 */
+			.delay = 0xFF,
+			.presc = 49,
+			.resol = S3C_ADCCON_RESSEL_12BIT,
+		},
+	},
+};
+#endif
+
+struct map_desc spica_iodesc[] __initdata = {
+};
+
+static struct platform_device *spica_devices[] __initdata = {
+#if defined(CONFIG_S3C_DMA_PL080_SOL)
+	&s3c_device_dma0,
+	&s3c_device_dma1,
+	&s3c_device_dma2,
+	&s3c_device_dma3,
+#endif
+	&s3c_device_keypad,
+	&s3c_device_hsmmc0,
+	&s3c_device_hsmmc2,
+	&s3c_device_rtc,
+	&s3c_device_i2c0,
+	&s3c_device_i2c1,
+#if defined(CONFIG_I2C_GPIO)
+#if 0
+	&s3c_device_i2c2,
+#endif	
+	&s3c_device_i2c3,
+#if 0
+	&s3c_device_i2c4,
+#endif
+	&s3c_device_i2c5,
+	&s3c_device_i2c6,
+#endif
+	&s3c_device_spi0,
+	&sec_device_ts,
+#ifdef CONFIG_S3C64XX_ADCTS
+	&s3c_device_adcts,
+#endif
+#ifdef CONFIG_S3C_ADC
+	&s3c_device_adc,
+#endif
+	&s3c_device_lcd,
+	&s3c_device_usbgadget,
+	&s3c_device_camif,
+	&s3c_device_mfc,
+	&s3c_device_g3d,
+	&s3c_device_2d,
+	&s3c_device_rotator,
+	&s3c_device_jpeg,
+	&s3c_device_vpp,
+	&sec_device_backlight, 
+	&sec_device_dpram,
+	&sec_device_eled,
+	&sec_device_battery,
+	&sec_device_rfkill,   //BT POWER ON-OFF
+	&sec_device_btsleep,  //BT SLEEP-AWAKE
+	&sec_device_headset,
+};
+
+static struct i2c_board_info i2c_devs0[] __initdata = {
+};
+
+static struct i2c_board_info i2c_devs1[] __initdata = {
+};
+
+#ifdef CONFIG_S3C_ADC
+static struct s3c_adc_mach_info s3c_adc_platform __initdata = {
+	/* Support 12-bit resolution */
+	.delay		= 0xff,
+	.presc 		= 49,
+	.resolution	= 12,
+};
+#endif
+
+static void __init spica_fixup(struct machine_desc *desc,
+		struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+	mi->nr_banks = 1;
+	
+	mi->bank[0].start = PHYS_OFFSET;
+	mi->bank[0].size = PHYS_UNRESERVED_SIZE;
+	mi->bank[0].node = 0;
+}
+
+static void __init s3c64xx_allocate_memory_regions(void)
+{
+	void *addr;
+	unsigned long size;
+
+	size = S3C64XX_KERNEL_PANIC_DUMP_SIZE;
+	addr = alloc_bootmem(size);
+	S3C64XX_KERNEL_PANIC_DUMP_ADDR = addr;
+
+}
+static void __init spica_map_io(void)
+{
+	s3c64xx_init_io(spica_iodesc, ARRAY_SIZE(spica_iodesc));
+	s3c64xx_gpiolib_init();
+	s3c_init_clocks(12000000);
+	s3c_init_uarts(spica_uartcfgs, ARRAY_SIZE(spica_uartcfgs));
+	s3c64xx_allocate_memory_regions();
+}
+
+static void spica_set_qos(void) 
+{     
+	u32 reg;     							 /* AXI sfr */     
+
+	reg = (u32) ioremap((unsigned long) S3C6410_PA_AXI_SYS, SZ_4K); /* QoS override: FIMD min. latency */
+	writel(0x2, S3C_VA_SYS + 0x128);  	    			/* AXI QoS */
+	writel(0x7, reg + 0x460);   					/* (8 - MFC ch.) */
+	writel(0x7ff7, reg + 0x464);      				/* Bus cacheable */
+	writel(0x8ff, S3C_VA_SYS + 0x838); 
+	
+	__raw_writel(0x0, S3C_AHB_CON0);
+} 
+
+/*
+ *	Power Off Handler
+ */
+
+extern int get_usb_cable_state(void);
+
+#define AV					(0x1 << 14)
+#define TTY					(0x1 << 13)
+#define PPD					(0x1 << 12)
+#define JIG_UART_OFF		(0x1 << 11)
+#define JIG_UART_ON			(0x1 << 10)
+#define JIG_USB_OFF			(0x1 << 9)
+#define JIG_USB_ON			(0x1 << 8)
+#define USB_OTG				(0x1 << 7)
+#define DEDICATED_CHARGER	(0x1 << 6)
+#define USB_CHARGER			(0x1 << 5)
+#define CAR_KIT				(0x1 << 4)
+#define UART				(0x1 << 3)
+#define USB					(0x1 << 2)
+#define AUDIO_TYPE2			(0x1 << 1)
+#define AUDIO_TYPE1			(0x1 << 0)
+
+extern void arch_reset(char mode);
+
+static void spica_pm_power_off(void)
+{
+	int	mode = REBOOT_MODE_NONE;
+	char reset_mode = 'r';
+
+	if (!gpio_get_value(GPIO_TA_CONNECTED_N)) {	/* Reboot Charging */
+		mode = REBOOT_MODE_CHARGING;
+		if (sec_set_param_value)
+			sec_set_param_value(__REBOOT_MODE, &mode);
+		/* Watchdog Reset */
+		arch_reset(reset_mode);
+	}
+	else {	/* Power Off or Reboot */
+		if (sec_set_param_value)
+			sec_set_param_value(__REBOOT_MODE, &mode);
+
+		if (get_usb_cable_state() & (JIG_UART_ON | JIG_UART_OFF | JIG_USB_OFF | JIG_USB_ON)) {
+			/* Watchdog Reset */
+			arch_reset(reset_mode);
+		}
+		else {
+			/* POWER_N -> Input */
+			gpio_direction_input(GPIO_POWER_N);
+			/* VREG_MSMP_26V -> Input */
+			//gpio_direction_input(GPIO_VREG_MSMP_26V);
+			/* Check Power Off Condition */
+			//if (!gpio_get_value(GPIO_POWER_N)) {// || gpio_get_value(GPIO_VREG_MSMP_26V)) {
+				while (!gpio_get_value(GPIO_POWER_N));  /* Wait Power Button Release */
+#if 0
+				/* Wait Phone Power Off */	
+				while (gpio_get_value(GPIO_VREG_MSMP_26V)); 
+#endif	
+			//}
+
+			if (!gpio_get_value(GPIO_TA_CONNECTED_N) || !gpio_get_value(GPIO_TA_CHG_N) ) {
+				mode = REBOOT_MODE_CHARGING;
+				if (sec_set_param_value)
+					sec_set_param_value(__REBOOT_MODE, &mode);
+				/* Watchdog Reset */
+				arch_reset(reset_mode);			
+			}
+			else
+			{
+				msleep(50);
+				if (sec_set_param_value)
+					sec_set_param_value(__REBOOT_MODE, &mode);				
+				/* PS_HOLD -> Output Low */
+				gpio_direction_output(GPIO_PDA_PS_HOLD, GPIO_LEVEL_HIGH);
+				s3c_gpio_setpull(GPIO_PDA_PS_HOLD, S3C_GPIO_PULL_NONE);
+				gpio_set_value(GPIO_PDA_PS_HOLD, GPIO_LEVEL_LOW);
+			}
+		}
+	}
+
+	while (1);
+}
+
+static void spica_ftm_enable_usb_sw(int mode)
+{
+	pr_info("%s: mode(%d)\n", __func__, mode);
+	if (mode) {
+		fsa9480_SetAutoSWMode();
+	} else {
+		fsa9480_MakeRxdLow();
+		mdelay(10);
+		fsa9480_MakeRxdLow();
+	}
+}
+
+static int uart_current_owner = 0;
+
+static ssize_t uart_switch_show(struct device *dev, struct device_attribute *attr, char *buf)
+{	
+	if ( uart_current_owner )		
+		return sprintf(buf, "%s[UART Switch] Current UART owner = PDA \n", buf);	
+	else			
+		return sprintf(buf, "%s[UART Switch] Current UART owner = MODEM \n", buf);
+}
+
+static ssize_t uart_switch_store(struct device *dev, struct device_attribute *attr,	const char *buf, size_t size)
+{	
+	int switch_sel;
+
+	if (sec_get_param_value)
+		sec_get_param_value(__SWITCH_SEL, &switch_sel);
+
+	if (strncmp(buf, "PDA", 3) == 0 || strncmp(buf, "pda", 3) == 0)	{		
+		gpio_set_value(GPIO_UART_SEL, GPIO_LEVEL_HIGH);		
+		uart_current_owner = 1;		
+		switch_sel |= UART_SEL_MASK;
+		printk("[UART Switch] Path : PDA\n");	
+	}	
+
+	if (strncmp(buf, "MODEM", 5) == 0 || strncmp(buf, "modem", 5) == 0) {		
+		gpio_set_value(GPIO_UART_SEL, GPIO_LEVEL_LOW);		
+		uart_current_owner = 0;		
+		switch_sel &= ~UART_SEL_MASK;
+		printk("[UART Switch] Path : MODEM\n");	
+	}	
+
+	if (sec_set_param_value)
+		sec_set_param_value(__SWITCH_SEL, &switch_sel);
+
+	return size;
+}
+
+static DEVICE_ATTR(uart_sel, S_IRUGO |S_IWUGO | S_IRUSR | S_IWUSR, uart_switch_show, uart_switch_store);
+
+static int spica_notifier_call(struct notifier_block *this, unsigned long code, void *_cmd)
+{
+	int	mode = REBOOT_MODE_NONE;
+
+	if ((code == SYS_RESTART) && _cmd) {
+		if (!strcmp((char *)_cmd, "arm11_fota"))
+			mode = REBOOT_MODE_ARM11_FOTA;
+		else if (!strcmp((char *)_cmd, "arm9_fota"))
+			mode = REBOOT_MODE_ARM9_FOTA;
+		else if (!strcmp((char *)_cmd, "recovery")) 
+			mode = REBOOT_MODE_RECOVERY;
+		else if (!strcmp((char *)_cmd, "download")) 
+			mode = REBOOT_MODE_DOWNLOAD;
+	}
+
+	if (sec_set_param_value)
+		sec_set_param_value(__REBOOT_MODE, &mode);
+	
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block spica_reboot_notifier = {
+	.notifier_call = spica_notifier_call,
+};
+
+static void spica_switch_init(void)
+{
+	sec_class = class_create(THIS_MODULE, "sec");
+	if (IS_ERR(sec_class))
+		pr_err("Failed to create class(sec)!\n");
+
+	switch_dev = device_create(sec_class, NULL, 0, NULL, "switch");
+	if (IS_ERR(switch_dev))
+		pr_err("Failed to create device(switch)!\n");
+
+	if (gpio_is_valid(GPIO_UART_SEL)) {
+		if (gpio_request(GPIO_UART_SEL, S3C_GPIO_LAVEL(GPIO_UART_SEL))) 
+			printk(KERN_ERR "Failed to request GPIO_UART_SEL!\n");
+		gpio_direction_output(GPIO_UART_SEL, gpio_get_value(GPIO_UART_SEL));
+	}
+	s3c_gpio_setpull(GPIO_UART_SEL, S3C_GPIO_PULL_NONE);
+
+	if (device_create_file(switch_dev, &dev_attr_uart_sel) < 0)
+		pr_err("Failed to create device file(%s)!\n", dev_attr_uart_sel.attr.name);
+};
+
+static void __init spica_machine_init(void)
+{
+	spica_init_gpio();
+
+	s3c_i2c0_set_platdata(NULL);
+	s3c_i2c1_set_platdata(NULL);
+
+#ifdef CONFIG_S3C64XX_ADCTS
+	s3c_adcts_set_platdata (&s3c_adcts_cfgs);
+#endif
+#ifdef CONFIG_S3C_ADC
+	s3c_adc_set_platdata(&s3c_adc_platform);
+#endif
+
+	i2c_register_board_info(0, i2c_devs0, ARRAY_SIZE(i2c_devs0));
+	i2c_register_board_info(1, i2c_devs1, ARRAY_SIZE(i2c_devs1));
+
+	platform_add_devices(spica_devices, ARRAY_SIZE(spica_devices));
+	s3c6410_add_mem_devices (&pmem_setting);
+	
+	s3c6410_pm_init();
+
+	spica_set_qos();
+
+	pm_power_off = spica_pm_power_off;
+	
+	register_reboot_notifier(&spica_reboot_notifier);
+
+	spica_switch_init();
+
+	ftm_enable_usb_sw = spica_ftm_enable_usb_sw;
+}
+
+MACHINE_START(SPICA, "SPICA")
+	/* Maintainer: Ben Dooks <ben@fluff.org> */
+	.phys_io		= S3C_PA_UART & 0xfff00000,
+	.io_pg_offst	= (((u32)S3C_VA_UART) >> 18) & 0xfffc,
+	.boot_params	= S3C64XX_PA_SDRAM + 0x100,
+
+	.init_irq		= s3c6410_init_irq,
+	.fixup			= spica_fixup,
+	.map_io			= spica_map_io,
+	.init_machine	= spica_machine_init,
+#ifndef CONFIG_HIGH_RES_TIMERS
+	.timer			= &s3c64xx_timer,
+#else
+	.timer			= &sec_timer,
+#endif
+MACHINE_END
+
+#if defined(CONFIG_RTC_DRV_S3C)
+/* RTC common Function for samsung APs*/
+unsigned int s3c_rtc_set_bit_byte(void __iomem *base, uint offset, uint val)
+{
+	writeb(val, base + offset);
+
+	return 0;
+}
+
+unsigned int s3c_rtc_read_alarm_status(void __iomem *base)
+{
+	return 1;
+}
+
+void s3c_rtc_set_pie(void __iomem *base, uint to)
+{
+	unsigned int tmp;
+
+	tmp = readw(base + S3C_RTCCON) & ~S3C_RTCCON_TICEN;
+
+        if (to)
+                tmp |= S3C_RTCCON_TICEN;
+
+        writew(tmp, base + S3C_RTCCON);
+}
+
+void s3c_rtc_set_freq_regs(void __iomem *base, uint freq, uint s3c_freq)
+{
+	unsigned int tmp;
+
+        tmp = readw(base + S3C_RTCCON) & (S3C_RTCCON_TICEN | S3C_RTCCON_RTCEN );
+        writew(tmp, base + S3C_RTCCON);
+        s3c_freq = freq;
+        tmp = (32768 / freq)-1;
+        writel(tmp, base + S3C_TICNT);
+}
+
+void s3c_rtc_enable_set(struct platform_device *pdev,void __iomem *base, int en)
+{
+	unsigned int tmp;
+
+	if (!en) {
+		tmp = readw(base + S3C_RTCCON);
+		writew(tmp & ~ (S3C_RTCCON_RTCEN | S3C_RTCCON_TICEN), base + S3C_RTCCON);
+	} else {
+		/* re-enable the device, and check it is ok */
+		if ((readw(base+S3C_RTCCON) & S3C_RTCCON_RTCEN) == 0){
+			dev_info(&pdev->dev, "rtc disabled, re-enabling\n");
+
+			tmp = readw(base + S3C_RTCCON);
+			writew(tmp|S3C_RTCCON_RTCEN, base+S3C_RTCCON);
+		}
+
+		if ((readw(base + S3C_RTCCON) & S3C_RTCCON_CNTSEL)){
+			dev_info(&pdev->dev, "removing RTCCON_CNTSEL\n");
+
+			tmp = readw(base + S3C_RTCCON);
+			writew(tmp& ~S3C_RTCCON_CNTSEL, base+S3C_RTCCON);
+		}
+
+		if ((readw(base + S3C_RTCCON) & S3C_RTCCON_CLKRST)){
+			dev_info(&pdev->dev, "removing RTCCON_CLKRST\n");
+
+			tmp = readw(base + S3C_RTCCON);
+			writew(tmp & ~S3C_RTCCON_CLKRST, base+S3C_RTCCON);
+		}
+	}
+}
+#endif
+
+#if defined(CONFIG_KEYPAD_S3C) || defined (CONFIG_KEYPAD_S3C_MODULE)
+void s3c_setup_keypad_cfg_gpio(int rows, int columns)
+{
+	unsigned int gpio;
+	unsigned int end;
+
+	end = S3C64XX_GPK(8 + rows);
+
+	/* Set all the necessary GPK pins to special-function 0 */
+	for (gpio = S3C64XX_GPK(8); gpio < end; gpio++) {
+		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
+		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+	}
+
+	end = S3C64XX_GPL(0 + columns);
+
+	/* Set all the necessary GPK pins to special-function 0 */
+	for (gpio = S3C64XX_GPL(0); gpio < end; gpio++) {
+		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
+		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+	}
+}
+
+EXPORT_SYMBOL(s3c_setup_keypad_cfg_gpio);
+#endif
+
+void s3c_setup_uart_cfg_gpio(unsigned char port)
+{
+	if (port == 0) {
+		s3c_gpio_cfgpin(GPIO_FLM_RXD, S3C_GPIO_SFN(GPIO_FLM_RXD_AF));
+		s3c_gpio_setpull(GPIO_FLM_RXD, S3C_GPIO_PULL_NONE);
+		s3c_gpio_cfgpin(GPIO_FLM_TXD, S3C_GPIO_SFN(GPIO_FLM_TXD_AF));
+		s3c_gpio_setpull(GPIO_FLM_TXD, S3C_GPIO_PULL_NONE);
+	}
+	else if (port == 1) {
+		s3c_gpio_cfgpin(GPIO_BT_RXD, S3C_GPIO_SFN(GPIO_BT_RXD_AF));
+		s3c_gpio_setpull(GPIO_BT_RXD, S3C_GPIO_PULL_NONE);
+		s3c_gpio_cfgpin(GPIO_BT_TXD, S3C_GPIO_SFN(GPIO_BT_TXD_AF));
+		s3c_gpio_setpull(GPIO_BT_TXD, S3C_GPIO_PULL_NONE);
+		s3c_gpio_cfgpin(GPIO_BT_CTS, S3C_GPIO_SFN(GPIO_BT_CTS_AF));
+		s3c_gpio_setpull(GPIO_BT_CTS, S3C_GPIO_PULL_NONE);
+		s3c_gpio_cfgpin(GPIO_BT_RTS, S3C_GPIO_SFN(GPIO_BT_RTS_AF));
+		s3c_gpio_setpull(GPIO_BT_RTS, S3C_GPIO_PULL_NONE);
+	}
+	else if (port == 2) {
+		s3c_gpio_cfgpin(GPIO_PDA_RXD, S3C_GPIO_SFN(GPIO_PDA_RXD_AF));
+		s3c_gpio_setpull(GPIO_PDA_RXD, S3C_GPIO_PULL_NONE);
+		s3c_gpio_cfgpin(GPIO_PDA_TXD, S3C_GPIO_SFN(GPIO_PDA_TXD_AF));
+		s3c_gpio_setpull(GPIO_PDA_TXD, S3C_GPIO_PULL_NONE);
+	}
+}
+EXPORT_SYMBOL(s3c_setup_uart_cfg_gpio);
+
+void s3c_reset_uart_cfg_gpio(unsigned char port)
+{
+#if 0  // dgahn.temp
+	if (port == 0) {
+		s3c_gpio_cfgpin(GPIO_FLM_RXD, S3C_GPIO_SFN(GPIO_FLM_RXD_AF));
+		s3c_gpio_setpull(GPIO_FLM_RXD, S3C_GPIO_PULL_NONE);
+		s3c_gpio_cfgpin(GPIO_FLM_TXD, S3C_GPIO_SFN(GPIO_FLM_TXD_AF));
+		s3c_gpio_setpull(GPIO_FLM_TXD, S3C_GPIO_PULL_NONE);
+	}
+#endif
+	if (port == 1) {
+		s3c_gpio_cfgpin(GPIO_BT_RXD, 0);
+		s3c_gpio_setpull(GPIO_BT_RXD, S3C_GPIO_PULL_DOWN);
+		s3c_gpio_cfgpin(GPIO_BT_TXD, 0);
+		s3c_gpio_setpull(GPIO_BT_TXD, S3C_GPIO_PULL_DOWN);
+		s3c_gpio_cfgpin(GPIO_BT_CTS, 0);
+		s3c_gpio_setpull(GPIO_BT_CTS, S3C_GPIO_PULL_DOWN);
+		s3c_gpio_cfgpin(GPIO_BT_RTS, 0);
+		s3c_gpio_setpull(GPIO_BT_RTS, S3C_GPIO_PULL_DOWN);
+	}
+	else if (port == 2) {
+		s3c_gpio_cfgpin(GPIO_PDA_RXD, S3C_GPIO_SFN(GPIO_PDA_RXD_AF));
+		s3c_gpio_setpull(GPIO_PDA_RXD, S3C_GPIO_PULL_NONE);
+		s3c_gpio_cfgpin(GPIO_PDA_TXD, S3C_GPIO_SFN(GPIO_PDA_TXD_AF));
+		s3c_gpio_setpull(GPIO_PDA_TXD, S3C_GPIO_PULL_NONE);
+	}
+}
+EXPORT_SYMBOL(s3c_reset_uart_cfg_gpio);
+
+#if 0
+/******************************************************************
+ * Dump GPIO
+ * ****************************************************************/
+#define GPA_SIZE	8
+#define GPB_SIZE	7
+#define GPC_SIZE	8
+#define GPD_SIZE	5
+#define GPE_SIZE	5
+#define GPF_SIZE	16
+#define GPG_SIZE	7
+#define GPH_SIZE	10
+#define GPI_SIZE	16
+#define GPJ_SIZE	12
+#define GPK_SIZE	16
+#define GPL_SIZE	15
+#define GPM_SIZE	6
+#define GPN_SIZE	16
+#define GPO_SIZE	16
+#define GPP_SIZE	15
+#define GPQ_SIZE	9
+
+static char* GPA_str[GPA_SIZE] = { 
+	"GPA0 AP_FLM_RXD",
+	"GPA1 AP_FLM_TXD",
+	"GPA2 USB_SEL",
+	"GPA3 MSENSE_RST",
+	"GPA4 BT_UART_RXD",
+	"GPA5 BT_UART_TXD",
+	"GPA6 BT_UART_CTS",
+	"GPA7 BT_UART_RTS",
+};
+
+static char* GPB_str[GPB_SIZE] = { 
+	"GPB0 AP_RXD",
+	"GPB1 AP_TXD",
+	"GPB2 CAM_SCL",
+	"GPB3 CAM_SDA",
+	"GPB4 TOUCH_EN",
+	"GPB5 AP_SCL_3.0V",
+	"GPB6 AP_SDA_3.0V",
+};
+
+static char* GPC_str[GPC_SIZE] = { 
+	"GPC0 HM_MISO",
+	"GPC1 HM_CLK",
+	"GPC1 HM_MOSI",
+	"GPC3 HM_NCS",
+	"GPC4 WLAN_CMD",
+	"GPC5 WLAN_CLK",
+	"GPC6 WLAN_WAKE",
+	"GPC7 BT_WAKE",
+};
+
+static char* GPD_str[GPD_SIZE] = { 
+	"GPD0 I2C_SCLK",
+	"GPD1 BT_WLAN_REG_ON",
+	"GPD2 I2S_SYNC",
+	"GPD3 I2S_SDI",
+	"GPD4 I2S_SDO",
+};
+
+static char* GPE_str[GPE_SIZE] = { 
+	"GPE0 BT_RESET",
+	"GPE1 BOOT",
+	"GPE2 WLAN_RESET",
+	"GPE3 PWR_I2C_SCL",
+	"GPE4 PWR_I2C_SDA",
+};
+
+static char* GPF_str[GPF_SIZE] = { 
+	"GPF0 CAM_MCLK",
+	"GPF1 CAM_HSYNC",
+	"GPF2 CAM_PCLK",
+	"GPF3 CAM_3M_nRST",
+	"GPF4 CAM_VSYNC",
+	"GPF5 CAM_D(0)",
+	"GPF6 CAM_D(1)",
+	"GPF7 CAM_D(2)",
+	"GPF8 CAM_D(3)",
+	"GPF9 CAM_D(4)",
+	"GPF10 CAM_D(5)",
+	"GPF11 CAM_D(6)",
+	"GPF12 CAM_D(7)",
+	"GPF13 CAM_CIF_nRST",
+	"GPF14 CAM_CIF_nSTBY",
+	"GPF15 VIB_PWM",
+};
+
+static char* GPG_str[GPG_SIZE] = { 
+	"GPG0 T_FLASH_CLK",
+	"GPG1 T_FLASH_CMD",
+	"GPG2 T_FLASH_D(0)",
+	"GPG3 T_FLASH_D(1)",
+	"GPG4 T_FLASH_D(2)",
+	"GPG5 T_FLASH_D(3)",
+	"GPG6",
+};
+
+static char* GPH_str[GPH_SIZE] = { 
+	"GPH0",
+	"GPH1",
+	"GPH2",
+	"GPH3",
+	"GPH4",
+	"GPH5",
+	"GPH6 WLAN_DATA(0)",
+	"GPH7 WLAN_DATA(1)",
+	"GPH8 WLAN_DATA(2)",
+	"GPH9 WLAN_DATA(3)",
+};
+
+static char* GPI_str[GPI_SIZE] = { 
+	"GPI0",
+	"GPI1",
+	"GPI2 LCD_D(0)",
+	"GPI3 LCD_D(1)",
+	"GPI4 LCD_D(2)",
+	"GPI5 LCD_D(3)",
+	"GPI6 LCD_D(4)",
+	"GPI7 LCD_D(5)",
+	"GPI8",
+	"GPI9",
+	"GPI10 LCD_D(6)",
+	"GPI11 LCD_D(7)",
+	"GPI12 LCD_D(8)",
+	"GPI13 LCD_D(9)",
+	"GPI14 LCD_D(10)",
+	"GPI15 LCD_D(11)",
+};
+
+static char* GPJ_str[GPJ_SIZE] = { 
+	"GPJ0",
+	"GPJ1",
+	"GPJ2 LCD_D(12)",
+	"GPJ3 LCD_D(13)",
+	"GPJ4 LCD_D(14)",
+	"GPJ5 LCD_D(15)",
+	"GPJ6 LCD_D(16)",
+	"GPJ7 LCD_D(17)",
+	"GPJ8 LCD_HSYNC",
+	"GPJ9 LCD_VSYNC",
+	"GPJ10 LCD_DE",
+	"GPJ11 LCD_MCLK",
+};
+
+static char* GPK_str[GPK_SIZE] = { 
+	"GPK0 TA_EN",
+	"GPK1 AUDIO_EN",
+	"GPK2 PHONE_ON",
+	"GPK3 MICBIAS_EN",
+	"GPK4 UART_SEL",
+	"GPK5 FM_nRST",
+	"GPK6 CAM_EN",
+	"GPK7 nMSM_RST",
+	"GPK8 KBR(0)",
+	"GPK9 KBR(1)",
+	"GPK10 KBR(2)",
+	"GPK11 KBR(3)",
+	"GPK12 KBR(4)",
+	"GPK13 KBR(5)",
+	"GPK14 KBR(6)",
+	"GPK15 VREG_MSMP_2.6V",
+};
+
+static char* GPL_str[GPL_SIZE] = { 
+	"GPL0 KBC(0)",
+	"GPL1 KBC(1)",
+	"GPL2 KBC(2)",
+	"GPL3 KBC(3)",
+	"GPL4 KBC(4)",
+	"GPL5 KBC(5)",
+	"GPL6 KBC(6)",
+	"GPL7 USIM_BOOT",
+	"GPL8 CAM_3M_nSTBY",
+	"GPL9 HM_INT",
+	"GPL10 FM_INT",
+	"GPL11 TA_nCONNECTED",
+	"GPL12 TOUCH_INT",
+	"GPL13 CP_BOOT_SEL",
+	"GPL14 BT_HOST_WAKE",
+};
+
+static char* GPM_str[GPM_SIZE] = { 
+	"GPM0 FM_SCL",
+	"GPM1 FM_SDA",
+	"GPM2 TA_nCHG",
+	"GPM3 PDA_ACTIVE",
+	"GPM4 TOUCH_SCL",
+	"GPM5 TOUCH_SDA",
+};
+
+static char* GPN_str[GPN_SIZE] = { 
+	"GPN0 nONED_INT_AP",
+	"GPN1 WLAN_HOST_WAKE",
+	"GPN2 MSENSE_IRQ",
+	"GPN3 ACC_INT",
+	"GPN4 SLIDE_INT",
+	"GPN5 nPOWER",
+	"GPN6 T_FLASH_DETECT",
+	"GPN7 PHONE_ACTIVE",
+	"GPN8 PM_INT_N",
+	"GPN9 INTB",
+	"GPN10 DET_3.5",
+	"GPN11 EAR_SEND_END",
+	"GPN12 RESOUT_N",
+	"GPN13 BOOT_EINT13",
+	"GPN14 BOOT_EINT14",
+	"GPN15 BOOT_EINT15",
+};
+
+static char* GPO_str[GPO_SIZE] = { 
+	"GPO0 ONENAND_CS",
+	"GPO1",
+	"GPO2 LCD_nRST",
+	"GPO3",
+	"GPO4",
+	"GPO5",
+	"GPO6 LCD_nCS",
+	"GPO7 LCD_SI",
+	"GPO8",
+	"GPO9",
+	"GPO10",
+	"GPO11",
+	"GPO12 LCD_VENDOR",
+	"GPO13 LCD_CLK",
+	"GPO14",
+	"GPO15",
+};
+
+static char* GPP_str[GPP_SIZE] = { 
+	"GPP0",
+	"GPP1",
+	"GPP2",
+	"GPP3",
+	"GPP4",
+	"GPP5",
+	"GPP6",
+	"GPP7",
+	"GPP8",
+	"GPP9",
+	"GPP10",
+	"GPP11",
+	"GPP12",
+	"GPP13 AP_PSHOLD",
+	"GPP14",
+};
+
+static char* GPQ_str[GPQ_SIZE] = { 
+	"GPQ0",
+	"GPQ1",
+	"GPQ2",
+	"GPQ3 HMLDO_EN",
+	"GPQ4 MIC_SEL",
+	"GPQ5 VIB_EN",
+	"GPQ6 HM_EN",
+	"GPQ7",
+	"GPQ8",
+};
+
+void s3c_dump_gpio(void)
+{
+#define CHECK_GPIO(pin, name)						\
+	do {								\
+		unsigned int pinfun = s3c_gpio_get_cfgpin(pin);		\
+		unsigned int pinpud = s3c_gpio_getpull(pin);		\
+		if (pinfun != 0 || pinpud  != 1)			\
+			printk(KERN_INFO "%s->function:%x, pull up/down:%x\n",\
+					name, pinfun, pinpud);		\
+	} while (0)
+
+#define CHECK_GPIO_PORT(port)						\
+	do {								\
+		int i;							\
+		for (i = 0; i < GP##port##_SIZE; i++)			\
+			CHECK_GPIO(S3C64XX_GP##port(i), GP##port##_str[i]);\
+	} while (0)
+
+	CHECK_GPIO_PORT(A);
+	CHECK_GPIO_PORT(B);
+	CHECK_GPIO_PORT(C);
+	CHECK_GPIO_PORT(D);
+	CHECK_GPIO_PORT(E);
+	CHECK_GPIO_PORT(F);
+	CHECK_GPIO_PORT(G);
+	CHECK_GPIO_PORT(H);
+	CHECK_GPIO_PORT(I);
+	CHECK_GPIO_PORT(J);
+	CHECK_GPIO_PORT(K);
+	CHECK_GPIO_PORT(L);
+	CHECK_GPIO_PORT(M);
+	CHECK_GPIO_PORT(N);
+	CHECK_GPIO_PORT(O);
+	CHECK_GPIO_PORT(P);
+	CHECK_GPIO_PORT(Q);
+}
+EXPORT_SYMBOL(s3c_dump_gpio);
+#endif
+
+static int spica_gpio_table[][6] = {
+	/** OFF PART **/
+	/* GPA */
+	{ GPIO_FLM_RXD, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_FLM_TXD, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	/* { GPIO_USB_SEL, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE }, */
+	{ GPIO_MSENSE_RST, 1, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT1, S3C_GPIO_PULL_NONE }, 
+	{ GPIO_BT_RXD, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_BT_TXD, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_BT_CTS, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_BT_RTS, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	/* GPB */
+	{ GPIO_PDA_RXD, GPIO_PDA_RXD_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_PDA_TXD, GPIO_PDA_TXD_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+#if (CONFIG_SPICA_REV >= CONFIG_SPICA_TEST_REV02)
+	{ GPIO_I2C1_SCL, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_I2C1_SDA, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+#else
+	{ GPIO_I2C1_SCL, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_I2C1_SDA, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+#endif
+	{ GPIO_TOUCH_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT1, S3C_GPIO_PULL_NONE },
+	{ GPIO_I2C0_SCL, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_I2C0_SDA, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	/* GPC */
+	{ GPIO_PM_SET1, GPIO_PM_SET1_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
+	{ GPIO_PM_SET2, GPIO_PM_SET2_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
+	{ GPIO_PM_SET3, GPIO_PM_SET3_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
+	{ GPIO_WLAN_CMD, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },	
+	{ GPIO_WLAN_CLK, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_WLAN_WAKE, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ GPIO_BT_WAKE, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	/* GPD */
+	{ GPIO_I2S_CLK, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_BT_WLAN_REG_ON, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ GPIO_I2S_LRCLK, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_I2S_DI, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_I2S_DO, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	/* GPE */
+	{ GPIO_BT_RST_N, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ GPIO_BOOT, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_WLAN_RST_N, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ GPIO_PWR_I2C_SCL, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_PWR_I2C_SDA, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	/* GPF */
+	{ GPIO_CAM_MCLK, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_CAM_HSYNC, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_CAM_PCLK, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_MCAM_RST_N, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ GPIO_CAM_VSYNC, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_CAM_D_0, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_CAM_D_1, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_CAM_D_2, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_CAM_D_3, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_CAM_D_4, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_CAM_D_5, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_CAM_D_6, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_CAM_D_7, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_VIBTONE_PWM, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	/* GPG */
+	{ GPIO_TF_CLK, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_TF_CMD, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_TF_D_0, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_TF_D_1, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_TF_D_2, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_TF_D_3, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	/* GPH */
+	{ GPIO_TOUCH_I2C_SCL, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },	
+	{ GPIO_TOUCH_I2C_SDA, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_FM_I2C_SCL, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_FM_I2C_SDA, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_VIB_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ GPIO_WLAN_D_0, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_WLAN_D_1, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_WLAN_D_2, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_WLAN_D_3, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	/* GPI */
+	{ GPIO_LCD_B_0, GPIO_LCD_B_0_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_B_1, GPIO_LCD_B_1_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_B_2, GPIO_LCD_B_2_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_B_3, GPIO_LCD_B_3_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_B_4, GPIO_LCD_B_4_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_B_5, GPIO_LCD_B_5_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_G_0, GPIO_LCD_G_0_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_G_1, GPIO_LCD_G_1_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_G_2, GPIO_LCD_G_2_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_G_3, GPIO_LCD_G_3_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_G_4, GPIO_LCD_G_4_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_G_5, GPIO_LCD_G_5_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	/* GPJ */
+	{ GPIO_LCD_R_0, GPIO_LCD_R_0_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_R_1, GPIO_LCD_R_1_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_R_2, GPIO_LCD_R_2_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_R_3, GPIO_LCD_R_3_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_R_4, GPIO_LCD_R_4_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_R_5, GPIO_LCD_R_5_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_HSYNC, GPIO_LCD_HSYNC_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_VSYNC, GPIO_LCD_VSYNC_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_DE, GPIO_LCD_DE_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	{ GPIO_LCD_CLK, GPIO_LCD_CLK_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
+	/** ALIVE PART **/
+	/* GPK */
+	{ GPIO_TA_EN, GPIO_TA_EN_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, 
+	{ GPIO_AUDIO_EN, GPIO_AUDIO_EN_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_PHONE_ON, GPIO_PHONE_ON_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_MICBIAS_EN, GPIO_MICBIAS_EN_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	/* { GPIO_UART_SEL, GPIO_UART_SEL_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, */
+	{ GPIO_TOUCH_RST, GPIO_TOUCH_RST_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_CAM_EN, GPIO_CAM_EN_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_PHONE_RST_N, GPIO_PHONE_RST_N_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_KEYSCAN_0, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_KEYSCAN_1, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_KEYSCAN_2, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_KEYSCAN_3, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ S3C64XX_GPK(12), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ S3C64XX_GPK(13), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ S3C64XX_GPK(14), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_VREG_MSMP_26V, GPIO_VREG_MSMP_26V_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	/* GPL */
+	{ GPIO_KEYSENSE_0, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_KEYSENSE_1, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_KEYSENSE_2, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_KEYSENSE_3, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_USIM_BOOT, GPIO_USIM_BOOT_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_CAM_3M_STBY_N, GPIO_CAM_3M_STBY_N_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+#if (CONFIG_SPICA_REV >= CONFIG_SPICA_TEST_REV02)
+	{ GPIO_HOLD_KEY_N, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+#else
+	{ S3C64XX_GPL(9), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+#endif
+	{ S3C64XX_GPL(10), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_TA_CONNECTED_N, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_TOUCH_INT_N, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_CP_BOOT_SEL, GPIO_CP_BOOT_SEL_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_BT_HOST_WAKE, GPIO_BT_HOST_WAKE_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, 0, 0 },
+	/* GPM */
+	{ S3C64XX_GPM(0), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ S3C64XX_GPM(1), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_TA_CHG_N, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 }, 
+	{ S3C64XX_GPM(4), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ S3C64XX_GPM(5), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	/* GPN */
+	{ GPIO_ONEDRAM_INT_N, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_WLAN_HOST_WAKE, GPIO_WLAN_HOST_WAKE_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, 0, 0 },
+	{ GPIO_MSENSE_INT, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_ACC_INT, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_SIM_DETECT_N, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_POWER_N, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_TF_DETECT, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_PHONE_ACTIVE, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_PMIC_INT_N, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_JACK_INT_N, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_DET_35, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_EAR_SEND_END, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_RESOUT_N, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_BOOT_EINT13, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_BOOT_EINT14, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_BOOT_EINT15, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	/** MEMORY PART **/
+	/* GPO */
+	{ S3C64XX_GPO(4), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ S3C64XX_GPO(5), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	/* GPP */
+	{ S3C64XX_GPP(8), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ S3C64XX_GPP(10), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ S3C64XX_GPP(14), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	/* GPQ */
+	{ S3C64XX_GPQ(2), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ S3C64XX_GPQ(3), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ S3C64XX_GPQ(4), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ S3C64XX_GPQ(5), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ S3C64XX_GPQ(6), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+};
+
+void s3c_config_gpio_table(int array_size, int (*gpio_table)[6])
+{
+	u32 i, gpio;
+
+	pr_debug("%s: ++\n", __func__);
+	for (i = 0; i < array_size; i++) {
+		gpio = gpio_table[i][0];
+		if (gpio < S3C64XX_GPIO_ALIVE_PART_BASE) { /* Off Part */
+			pr_debug("%s: Off gpio=%d,%d\n", __func__, gpio, 
+					S3C64XX_GPIO_ALIVE_PART_BASE);
+			s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(gpio_table[i][1]));
+			s3c_gpio_setpull(gpio, gpio_table[i][3]);
+			s3c_gpio_slp_cfgpin(gpio, gpio_table[i][4]);
+			s3c_gpio_slp_setpull_updown(gpio, gpio_table[i][5]);
+			if (gpio_table[i][2] != GPIO_LEVEL_NONE)
+				gpio_set_value(gpio, gpio_table[i][2]);
+		} else if (gpio < S3C64XX_GPIO_MEM_PART_BASE) { /* Alive Part */
+			pr_debug("%s: Alive gpio=%d\n", __func__, gpio);
+			s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(gpio_table[i][1]));
+			s3c_gpio_setpull(gpio, gpio_table[i][3]);
+			if (gpio_table[i][2] != GPIO_LEVEL_NONE)
+				gpio_set_value(gpio, gpio_table[i][2]);
+		} else { /* Memory Part */
+			pr_debug("%s: Memory gpio=%d\n", __func__, gpio);
+			s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(gpio_table[i][1]));
+			s3c_gpio_setpull(gpio, gpio_table[i][3]);
+			s3c_gpio_slp_cfgpin(gpio, gpio_table[i][4]);
+			s3c_gpio_slp_setpull_updown(gpio, gpio_table[i][5]);
+			if (gpio_table[i][2] != GPIO_LEVEL_NONE)
+				gpio_set_value(gpio, gpio_table[i][2]);
+		}
+	}
+	pr_debug("%s: --\n", __func__);
+}
+EXPORT_SYMBOL(s3c_config_gpio_table);
+
+void spica_init_gpio(void)
+{
+	s3c_config_gpio_table(ARRAY_SIZE(spica_gpio_table),
+			spica_gpio_table);
+}
+
+static int spica_sleep_gpio_table[][6] = {
+	/** ALIVE PART **/
+	/* GPK */
+	{ GPIO_TOUCH_RST, GPIO_TOUCH_RST_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_CAM_EN, GPIO_CAM_EN_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_PHONE_RST_N, GPIO_PHONE_RST_N_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
+	// [ SEC Kernel2 : Enable Anykey Wakeup
+#if 0
+	{ GPIO_KEYSCAN_0, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_KEYSCAN_1, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_KEYSCAN_2, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_KEYSCAN_3, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+#endif
+	// ] SEC Kernel2 : Enable Anykey Wakeup
+	{ S3C64XX_GPK(12), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ S3C64XX_GPK(13), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ S3C64XX_GPK(14), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_VREG_MSMP_26V, GPIO_VREG_MSMP_26V_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	/* GPL */
+	{ GPIO_KEYSENSE_0, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_KEYSENSE_1, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_KEYSENSE_2, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_KEYSENSE_3, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ S3C64XX_GPL(4), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ S3C64XX_GPL(5), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ S3C64XX_GPL(6), 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_USIM_BOOT, GPIO_USIM_BOOT_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_CAM_3M_STBY_N, GPIO_CAM_3M_STBY_N_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
+	{ GPIO_TOUCH_INT_N, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
+	/* GPM */
+	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 }, 
+	/** MEMORY PART **/
+	/* GPO */
+	{ GPIO_LCD_RST_N, GPIO_LCD_RST_N_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ GPIO_LCD_CS_N, GPIO_LCD_CS_N_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ GPIO_LCD_SDI, GPIO_LCD_SDI_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+	{ GPIO_LCD_ID, GPIO_LCD_ID_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
+	{ GPIO_LCD_SCLK, GPIO_LCD_SCLK_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
+};
+
+static void check_pmic(void)
+{	
+	unsigned char reg_buff = 0;
+	if (Get_MAX8698_PM_REG(ELDO3, &reg_buff)) {
+		pr_info("%s: OTGI 1.2V (%d)\n", __func__, reg_buff);
+	}
+	if (Get_MAX8698_PM_REG(ELDO4, &reg_buff)) {
+		pr_info("%s: VLED 3.3V (%d)\n", __func__, reg_buff);
+	}
+	if (Get_MAX8698_PM_REG(ELDO5, &reg_buff)) {
+		pr_info("%s: VTF 3.0V (%d)\n", __func__, reg_buff);
+		if (reg_buff)
+			Set_MAX8698_PM_REG(ELDO5, 0);
+	}
+	if (Get_MAX8698_PM_REG(ELDO6, &reg_buff)) {
+		pr_info("%s: VLCD 1.8V (%d)\n", __func__, reg_buff);
+	}
+	if (Get_MAX8698_PM_REG(ELDO7, &reg_buff)) {
+		pr_info("%s: VLCD 3.0V (%d)\n", __func__, reg_buff);
+	}
+	if (Get_MAX8698_PM_REG(ELDO8, &reg_buff)) {
+		pr_info("%s: OTG 3.3V (%d)\n", __func__, reg_buff);
+	}
+}
+
+void s3c_config_sleep_gpio(void)
+{	
+	int spcon_val;
+
+	check_pmic();
+	s3c_config_gpio_table(ARRAY_SIZE(spica_sleep_gpio_table),
+			spica_sleep_gpio_table);
+
+	spcon_val = __raw_readl(S3C64XX_SPCON);
+	spcon_val = spcon_val & (~0xFFEC0000);
+	__raw_writel(spcon_val, S3C64XX_SPCON);
+	__raw_writel(0x20, S3C64XX_SPCONSLP);
+
+	/* mem interface reg config in sleep mode */
+	__raw_writel(0x00005000, S3C64XX_MEM0CONSLP0);
+	__raw_writel(0x01041595, S3C64XX_MEM0CONSLP1);
+	__raw_writel(0x10055000, S3C64XX_MEM1CONSLP);
+
+}
+EXPORT_SYMBOL(s3c_config_sleep_gpio);
+
+void s3c_config_wakeup_gpio(void)
+{
+	unsigned char reg_buff = 0;
+	if (Get_MAX8698_PM_REG(ELDO5, &reg_buff)) {
+		pr_info("%s: VTF 3.0V (%d)\n", __func__, reg_buff);
+		if (!reg_buff)
+			Set_MAX8698_PM_REG(ELDO5, 1);
+	}
+}
+EXPORT_SYMBOL(s3c_config_wakeup_gpio);
+
+void s3c_config_wakeup_source(void)
+{
+	unsigned int eint0pend_val;
+
+	/* Wake-up source 
+	 * ONEDRAM_INT(EINT0), Power key(EINT5), WLAN_HOST_WAKE(EINT1), 
+	 * DET_3.5(EINT10), EAR_SEND_END(EINT11), SIM_nDETECT(EINT4), T_FLASH_DETECT(EINT6)
+	 * Hold key(EINT17), TA_CONNECTED(EINT19),
+	 * BT_HOST_WAKE(EINT22), CHG_ING(EINT25)
+	 * T_FLASH_DETECT(EINT6), 
+	 */
+
+	//SEC_BP_WONSUK_20090811
+	//register INTB(EINT9) with wakeup source 
+#if 0
+	eint0pend_val= __raw_readl(S3C64XX_EINT0PEND);
+	eint0pend_val |= (0x1 << 25) | (0x1 << 22) | (0x1 << 19) |
+		(0x1 << 17) | (0x1 << 11) | (0x1 << 10) | (0x1 << 9)| (0x1 << 6) |(0x1 << 5) | (0x1 << 4) |(0x1 << 1) | 0x1;
+	__raw_writel(eint0pend_val, S3C64XX_EINT0PEND);
+
+	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 19) |
+		(0x1 << 17) | (0x1 << 11) | (0x1 << 10) |  (0x1 << 9)| (0x1 << 6) |(0x1 << 5) | (0x1 << 4) | (0x1 << 1) | 0x1;
+	__raw_writel(~eint0pend_val, S3C64XX_EINT0MASK);
+
+#else	// WLAN_HOST_WAKE(EINT1) Wake-up Source disable temporary by hskang.
+	eint0pend_val= __raw_readl(S3C64XX_EINT0PEND);
+	eint0pend_val |= (0x1 << 25) | (0x1 << 22) | (0x1 << 19) |
+		(0x1 << 17) | (0x1 << 11) | (0x1 << 10) | (0x1 << 9)| (0x1 << 6) |(0x1 << 5) | (0x1 << 4) | (0x1 << 1) | 0x1;
+	__raw_writel(eint0pend_val, S3C64XX_EINT0PEND);
+
+	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 19) |
+		(0x1 << 17) | (0x1 << 11) | (0x1 << 10) |  (0x1 << 9)| (0x1 << 6) |(0x1 << 5) | (0x1 << 4) |(0x1 << 1) | 0x1;
+	__raw_writel(~eint0pend_val, S3C64XX_EINT0MASK);
+#endif
+	__raw_writel((0x0FFFFFFF & ~eint0pend_val), S3C_EINT_MASK);	
+
+	/* Alarm Wakeup Enable */
+	__raw_writel((__raw_readl(S3C_PWR_CFG) & ~(0x1 << 10)), S3C_PWR_CFG);
+}
+EXPORT_SYMBOL(s3c_config_wakeup_source);
+
diff -Nur linux-2.6.29/arch/arm/mach-s3c6410/Makefile linux-2.6.29-spica/arch/arm/mach-s3c6410/Makefile
--- linux-2.6.29/arch/arm/mach-s3c6410/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mach-s3c6410/Makefile	2010-05-06 12:42:45.644210217 +0700
@@ -13,11 +13,17 @@
 # Core support for S3C6410 system
 
 obj-$(CONFIG_CPU_S3C6410)	+= cpu.o
+obj-$(CONFIG_S3C_DMA_PL080)	+= dma.o
+obj-$(CONFIG_CPU_S3C6410)	+= irq.o
 
 # Helper and device support
 
 obj-$(CONFIG_S3C6410_SETUP_SDHCI)	+= setup-sdhci.o
 
-# machine support
+obj-$(CONFIG_PM)    += pm.o
 
-obj-$(CONFIG_MACH_SMDK6410)	+= mach-smdk6410.o
+# Machine support
+
+obj-$(CONFIG_MACH_SMDK6410)		+= mach-smdk6410.o
+obj-$(CONFIG_MACH_SPICA)	+= mach-spica.o board-rfkill.o
+obj-$(CONFIG_SEC_HEADSET)	+= sec_headset.o
diff -Nur linux-2.6.29/arch/arm/mach-s3c6410/pm.c linux-2.6.29-spica/arch/arm/mach-s3c6410/pm.c
--- linux-2.6.29/arch/arm/mach-s3c6410/pm.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6410/pm.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,103 @@
+/* linux/arch/arm/mach-s3c6410/pm.c
+ *
+ * Copyright (c) 2006 Samsung Electronics
+ *
+ *
+ * S3C6410 (and compatible) Power Manager (Suspend-To-RAM) support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <linux/init.h>
+#include <linux/suspend.h>
+#include <linux/errno.h>
+#include <linux/time.h>
+#include <linux/sysdev.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+
+#include <asm/mach-types.h>
+
+#include <plat/regs-gpio.h>
+#include <plat/regs-clock.h>
+//#include <asm/plat-s3c/regs-rtc.h>
+#include <plat/cpu.h>
+#include <plat/pm.h>
+
+#ifdef CONFIG_S3C2410_PM_DEBUG
+extern void pm_dbg(const char *fmt, ...);
+#define DBG(fmt...) pm_dbg(fmt)
+#else
+#define DBG(fmt...) printk(KERN_DEBUG fmt)
+#endif
+
+//static void s3c6410_cpu_suspend(void)
+void s3c6410_cpu_suspend(void)
+{
+	unsigned long tmp;
+
+	/* issue the standby signal into the pm unit. Note, we
+	 * issue a write-buffer drain just in case */
+
+	tmp = 0;
+
+	asm("b 1f\n\t"
+	    ".align 5\n\t"
+	    "1:\n\t"
+	    "mcr p15, 0, %0, c7, c10, 5\n\t"
+	    "mcr p15, 0, %0, c7, c10, 4\n\t"
+	    "mcr p15, 0, %0, c7, c0, 4" :: "r" (tmp));
+
+	/* we should never get past here */
+
+	panic("sleep resumed to originator?");
+}
+
+static void s3c6410_pm_prepare(void)
+{
+
+}
+
+static int s3c6410_pm_add(struct sys_device *sysdev)
+{
+	pm_cpu_prep = s3c6410_pm_prepare;
+	pm_cpu_sleep = s3c6410_cpu_suspend;
+
+	return 0;
+}
+
+static struct sleep_save s3c6410_sleep[] = {
+
+};
+
+static int s3c6410_pm_resume(struct sys_device *dev)
+{
+	s3c6410_pm_do_restore(s3c6410_sleep, ARRAY_SIZE(s3c6410_sleep));
+	return 0;
+}
+
+static struct sysdev_driver s3c6410_pm_driver = {
+	.add		= s3c6410_pm_add,
+	.resume		= s3c6410_pm_resume,
+};
+
+static __init int s3c6410_pm_drvinit(void)
+{
+	return sysdev_driver_register(&s3c6410_sysclass, &s3c6410_pm_driver);
+}
+
+arch_initcall(s3c6410_pm_drvinit);
+
diff -Nur linux-2.6.29/arch/arm/mach-s3c6410/sec_headset.c linux-2.6.29-spica/arch/arm/mach-s3c6410/sec_headset.c
--- linux-2.6.29/arch/arm/mach-s3c6410/sec_headset.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/mach-s3c6410/sec_headset.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,467 @@
+/*
+ *  H2W device detection driver.
+ *
+ *  Copyright (C) 2009 Samsung Electronics, Inc.
+ *
+ *  Authors:
+ *      Eunki Kim <eunki_kim@samsung.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ */
+
+#include <linux/module.h>
+#include <linux/sysdev.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/switch.h>
+#include <linux/input.h>
+#include <linux/timer.h>
+#include <linux/wakelock.h>
+
+#include <mach/hardware.h>
+#include <plat/regs-gpio.h>
+#include <plat/gpio-cfg.h>
+#include <asm/gpio.h>
+#include <asm/mach-types.h>
+#include <mach/sec_headset.h>
+
+//#define CONFIG_DEBUG_SEC_HEADSET
+
+#ifdef CONFIG_DEBUG_SEC_HEADSET
+#define SEC_HEADSET_DBG(fmt, arg...) printk(KERN_INFO "[HEADSET] " fmt "\r\n", ## arg)
+#else
+#define SEC_HEADSET_DBG(fmt, arg...) 
+#endif
+
+#define KEYCODE_SENDEND 248
+
+#define HEADSET_CHECK_COUNT	3
+#define	HEADSET_CHECK_TIME	get_jiffies_64() + (HZ/5)// 1000ms / 10 = 100ms
+#define	SEND_END_ENABLE_TIME 	get_jiffies_64() + (HZ*2)// 1000ms * 2 = 2sec
+
+#define SEND_END_CHECK_COUNT	3
+#define SEND_END_CHECK_TIME get_jiffies_64() + 6 //30ms
+//#define SEND_END_CHECK_TIME get_jiffies_64() + 30 /*(HZ/25) //1000ms / 25 = 40ms*/
+//#define SEND_END_CHECK_TIME get_jiffies_64() + (HZ/100) //1000ms / 100 = 10ms 
+
+extern int s3c_adc_get_adc_data(int channel);
+
+struct sec_headset_info {
+	struct sec_headset_port port;
+	struct input_dev *input;
+};
+
+static struct sec_headset_info *hi;
+
+struct switch_dev switch_earjack = {
+        .name = "h2w",
+};
+
+//SISO Added support for send_end Sysfs node 
+struct switch_dev switch_sendend = {
+        .name = "send_end",
+};
+
+static struct timer_list headset_detect_timer;
+static struct timer_list send_end_key_event_timer;
+
+static unsigned int headset_detect_timer_token;
+static unsigned int send_end_key_timer_token;
+static unsigned int send_end_irq_token;
+static unsigned short int headset_status;
+static struct wake_lock headset_sendend_wake_lock;
+
+short int get_headset_status()
+{
+	SEC_HEADSET_DBG(" headset_status %d", headset_status);
+	return headset_status;
+}
+
+EXPORT_SYMBOL(get_headset_status);
+static void release_headset_event(unsigned long arg)
+{
+	printk("Headset attached\n");
+	headset_status = 1;
+	switch_set_state(&switch_earjack, 1);
+}
+static DECLARE_DELAYED_WORK(release_headset_event_work, release_headset_event);
+
+static void ear_adc_caculrator(unsigned long arg)
+{
+	int adc = 0;
+	struct sec_gpio_info   *det_headset = &hi->port.det_headset;
+	struct sec_gpio_info   *send_end = &hi->port.send_end;
+	int state = gpio_get_value(det_headset->gpio) ^ det_headset->low_active;
+	
+	if (state)
+	{
+		adc = s3c_adc_get_adc_data(3);
+        if((adc > 1700 && adc < 2000) || (adc > 2400 && adc < 2700) || (adc > 2900 && adc < 3400) || (adc > 400 && adc < 700))
+		{
+			printk("4pole ear-mic adc is %d\n", adc);
+			enable_irq (send_end->eint);
+			send_end_irq_token++;
+		}
+		else if(adc < 5)
+		{
+			printk("3pole earphone adc is %d\n", adc);
+			headset_status = 0;
+		}
+		else
+		{
+			printk(KERN_ALERT "Wrong adc value!! adc is %d\n", adc);
+			headset_status = 0;
+		}
+	}
+	else
+	{
+		printk(KERN_ALERT "Error : mic bias enable complete but headset detached!!\n");
+		gpio_set_value(GPIO_MICBIAS_EN, 0);
+	}
+
+	wake_unlock(&headset_sendend_wake_lock);
+}
+
+static DECLARE_DELAYED_WORK(ear_adc_cal_work, ear_adc_caculrator);
+
+static void headset_detect_timer_handler(unsigned long arg)
+{
+	struct sec_gpio_info   *det_headset = &hi->port.det_headset;
+	int state;
+	state = gpio_get_value(det_headset->gpio) ^ det_headset->low_active;
+
+	if(state)
+	{
+		SEC_HEADSET_DBG("headset_detect_timer_token is %d\n", headset_detect_timer_token);
+		if(headset_detect_timer_token < 3)
+		{
+			headset_detect_timer.expires = HEADSET_CHECK_TIME;
+			add_timer(&headset_detect_timer);
+			headset_detect_timer_token++;
+		}
+		else if(headset_detect_timer_token == 3)
+		{
+			headset_detect_timer.expires = SEND_END_ENABLE_TIME;
+			add_timer(&headset_detect_timer);
+			headset_detect_timer_token++;
+			schedule_work(&release_headset_event_work);
+		}
+		else if(headset_detect_timer_token == 4)
+		{
+			gpio_set_value(GPIO_MICBIAS_EN, 1); 
+			schedule_delayed_work(&ear_adc_cal_work, 200);
+			SEC_HEADSET_DBG("mic bias enable add work queue \n");
+			headset_detect_timer_token = 0;
+		}
+		else
+			printk(KERN_ALERT "wrong headset_detect_timer_token count %d", headset_detect_timer_token);
+	}
+	else
+		printk(KERN_ALERT "headset detach!! %d", headset_detect_timer_token);
+}
+
+static void ear_switch_change(struct work_struct *ignored)
+{
+	struct sec_gpio_info   *det_headset = &hi->port.det_headset;
+	struct sec_gpio_info   *send_end = &hi->port.send_end;
+	int state;
+
+	del_timer(&headset_detect_timer);
+	cancel_delayed_work_sync(&ear_adc_cal_work);
+	state = gpio_get_value(det_headset->gpio) ^ det_headset->low_active;
+
+	if (state && !send_end_irq_token)
+	{		
+		wake_lock(&headset_sendend_wake_lock);
+		SEC_HEADSET_DBG("Headset attached timer start\n");
+		headset_detect_timer_token = 0;
+		headset_detect_timer.expires = HEADSET_CHECK_TIME;
+		add_timer(&headset_detect_timer);
+	}
+	else if(!state)
+	{
+		switch_set_state(&switch_earjack, state);
+		printk("Headset detached %d \n", send_end_irq_token);        	
+		headset_status = state;
+		if(send_end_irq_token > 0)
+		{
+			disable_irq (send_end->eint);
+			send_end_irq_token--;
+		}
+		wake_unlock(&headset_sendend_wake_lock);
+	}
+	else
+		SEC_HEADSET_DBG("Headset state does not valid. or send_end event");
+
+}
+static void send_end_key_event_timer_handler(unsigned long arg)
+{
+	struct sec_gpio_info   *det_headset = &hi->port.det_headset;
+	struct sec_gpio_info   *send_end = &hi->port.send_end;
+	int sendend_state, headset_state = 0;
+	
+	headset_state = gpio_get_value(det_headset->gpio) ^ det_headset->low_active;
+	sendend_state = gpio_get_value(send_end->gpio) ^ send_end->low_active;
+
+	if(headset_state && sendend_state)
+	{
+		if(send_end_key_timer_token < SEND_END_CHECK_COUNT)
+		{	
+			send_end_key_timer_token++;
+			send_end_key_event_timer.expires = SEND_END_CHECK_TIME; 
+			add_timer(&send_end_key_event_timer);
+			SEC_HEADSET_DBG("SendEnd Timer Restart %d", send_end_key_timer_token);
+		}
+		else if(send_end_key_timer_token == SEND_END_CHECK_COUNT)
+		{
+			printk("SEND/END is pressed\n");
+			input_report_key(hi->input, KEYCODE_SENDEND, 1);
+			input_sync(hi->input);
+			send_end_key_timer_token = 0;
+		}
+		else
+			printk(KERN_ALERT "[Headset]wrong timer counter %d\n", send_end_key_timer_token);
+	}else
+			printk(KERN_ALERT "[Headset]GPIO Error\n");
+}
+
+static void sendend_switch_change(struct work_struct *ignored)
+{
+
+	struct sec_gpio_info   *det_headset = &hi->port.det_headset;
+	struct sec_gpio_info   *send_end = &hi->port.send_end;
+	int state, headset_state;
+
+	del_timer(&send_end_key_event_timer);
+	send_end_key_timer_token = 0;
+    mdelay(10); // for earjack keyevent delay	
+	headset_state = gpio_get_value(det_headset->gpio) ^ det_headset->low_active;
+	state = gpio_get_value(send_end->gpio) ^ send_end->low_active;
+
+	if(headset_state && send_end_irq_token)//headset connect && send irq enable
+	{
+		if(!state)
+		{
+			SEC_HEADSET_DBG(KERN_ERR "SISO:sendend isr work queue\n");
+    			switch_set_state(&switch_sendend, state);
+			input_report_key(hi->input, KEYCODE_SENDEND, state);
+			input_sync(hi->input);
+			printk("SEND/END %s.\n", "released");
+			wake_unlock(&headset_sendend_wake_lock);
+		}else{
+			wake_lock(&headset_sendend_wake_lock);
+			send_end_key_event_timer.expires = SEND_END_CHECK_TIME; // 10ms ??
+			add_timer(&send_end_key_event_timer);
+			switch_set_state(&switch_sendend, state);
+			SEC_HEADSET_DBG("SEND/END %s.timer start \n", "pressed");
+		}
+
+	}else{
+		SEC_HEADSET_DBG("SEND/END Button is %s but headset disconnect or irq disable.\n", state?"pressed":"released");
+	}
+}
+
+static DECLARE_WORK(ear_switch_work, ear_switch_change);
+static DECLARE_WORK(sendend_switch_work, sendend_switch_change);
+
+static irqreturn_t detect_irq_handler(int irq, void *dev_id)
+{
+	SEC_HEADSET_DBG("headset isr");
+	schedule_work(&ear_switch_work);
+	return IRQ_HANDLED;
+}
+ 
+
+static irqreturn_t send_end_irq_handler(int irq, void *dev_id)
+{
+   struct sec_gpio_info   *det_headset = &hi->port.det_headset;
+   int headset_state;
+
+   SEC_HEADSET_DBG("sendend isr");
+   del_timer(&send_end_key_event_timer);
+   headset_state = gpio_get_value(det_headset->gpio) ^ det_headset->low_active;
+
+   if (headset_state)
+   {
+      schedule_work(&sendend_switch_work);      
+   }
+  
+   return IRQ_HANDLED;
+}
+
+static int sec_headset_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct sec_headset_platform_data *pdata = pdev->dev.platform_data;
+	struct sec_gpio_info   *det_headset;
+	struct sec_gpio_info   *send_end;
+	struct input_dev       *input;
+
+	printk(KERN_INFO "SEC HEADSET: Registering headset driver\n");
+	hi = kzalloc(sizeof(struct sec_headset_info), GFP_KERNEL);
+	if (!hi)
+		return -ENOMEM;
+
+	memcpy (&hi->port, pdata->port, sizeof(struct sec_headset_port));
+
+	input = hi->input = input_allocate_device();
+	if (!input) {
+		ret = -ENOMEM;
+		printk(KERN_ERR "SEC HEADSET: Failed to allocate input device.\n");
+		goto err_request_input_dev;
+	}
+
+	input->name = "sec_headset";
+	set_bit(EV_SYN, input->evbit);
+	set_bit(EV_KEY, input->evbit);
+	set_bit(KEYCODE_SENDEND, input->keybit);
+
+	ret = input_register_device(input);
+	if (ret < 0){
+		printk(KERN_ERR "SEC HEADSET: Failed to register driver\n");
+		goto err_register_input_dev;
+	}
+	
+	init_timer(&headset_detect_timer);
+	headset_detect_timer.function = headset_detect_timer_handler;
+
+	init_timer(&send_end_key_event_timer);
+	send_end_key_event_timer.function = send_end_key_event_timer_handler;
+
+	ret = switch_dev_register(&switch_earjack);
+	if (ret < 0) {
+		printk(KERN_ERR "SEC HEADSET: Failed to register switch device\n");
+		goto err_switch_dev_register;
+	}
+
+    	printk(KERN_ERR "SISO:registering switch_sendend switch_dev");
+	ret = switch_dev_register(&switch_sendend);
+	if (ret < 0) {
+		printk(KERN_ERR "SEC HEADSET: Failed to register switch sendend device\n");
+		goto err_switch_dev_register;
+        }
+
+	send_end = &hi->port.send_end;
+        s3c_gpio_cfgpin(send_end->gpio, S3C_GPIO_SFN(send_end->gpio_af));
+        s3c_gpio_setpull(send_end->gpio, S3C_GPIO_PULL_NONE);
+        set_irq_type(send_end->eint, IRQ_TYPE_EDGE_BOTH);
+	
+	ret = request_irq(send_end->eint, send_end_irq_handler,
+			  IRQF_DISABLED, "sec_headset_send_end", NULL);
+	if (ret < 0) {
+		printk(KERN_ERR "SEC HEADSET: Failed to register send/end interrupt.\n");
+		goto err_request_send_end_irq;
+	}
+	disable_irq(send_end->eint);
+
+	det_headset = &hi->port.det_headset;
+        s3c_gpio_cfgpin(det_headset->gpio, S3C_GPIO_SFN(det_headset->gpio_af));
+        s3c_gpio_setpull(det_headset->gpio, S3C_GPIO_PULL_NONE);
+        set_irq_type(det_headset->eint, IRQ_TYPE_EDGE_BOTH);
+	
+	ret = request_irq(det_headset->eint, detect_irq_handler,
+			  IRQF_DISABLED, "sec_headset_detect", NULL);
+	if (ret < 0) {
+		printk(KERN_ERR "SEC HEADSET: Failed to register detect interrupt.\n");
+		goto err_request_detect_irq;
+	}
+	
+	wake_lock_init(&headset_sendend_wake_lock, WAKE_LOCK_SUSPEND, "sec_headset");
+
+	schedule_work(&ear_switch_work);
+	
+	return 0;
+
+err_request_send_end_irq:
+	free_irq(det_headset->eint, 0);
+err_request_detect_irq:
+	switch_dev_unregister(&switch_earjack);
+err_switch_dev_register:
+	input_unregister_device(input);
+err_register_input_dev:
+	input_free_device(input);
+err_request_input_dev:
+	kfree (hi);
+
+	return ret;
+}
+
+//kvpz: this is to add support for earjack, and send end key simulation from sysfs state store for the two
+void sec_headset_sendend_report_key(void)
+{
+	
+		input_report_key(hi->input, KEYCODE_SENDEND, 1);				
+		input_sync(hi->input);
+}
+
+EXPORT_SYMBOL(sec_headset_sendend_report_key);
+
+static int sec_headset_remove(struct platform_device *pdev)
+{
+	SEC_HEADSET_DBG("");
+	input_unregister_device(hi->input);
+	free_irq(hi->port.det_headset.eint, 0);
+	free_irq(hi->port.send_end.eint, 0);
+	switch_dev_unregister(&switch_earjack);
+	return 0;
+}
+#ifdef CONFIG_PM
+static int sec_headset_suspend(struct platform_device *pdev,
+		pm_message_t state)
+{
+
+	SEC_HEADSET_DBG("");
+	flush_scheduled_work();
+	return 0;
+}
+static int sec_headset_resume(struct platform_device *pdev)
+{
+	SEC_HEADSET_DBG("");
+	schedule_work(&ear_switch_work);
+	schedule_work(&sendend_switch_work);
+	return 0;
+}
+#else
+#define s3c_headset_resume 	NULL
+#define s3c_headset_suspend	NULL
+#endif
+
+static struct platform_driver sec_headset_driver = {
+	.probe		= sec_headset_probe,
+	.remove		= sec_headset_remove,
+	.suspend	= sec_headset_suspend,
+	.resume		= sec_headset_resume,
+	.driver		= {
+		.name		= "sec_headset",
+		.owner		= THIS_MODULE,
+	},
+};
+
+static int __init sec_headset_init(void)
+{
+	SEC_HEADSET_DBG("");
+	return platform_driver_register(&sec_headset_driver);
+}
+
+static void __exit sec_headset_exit(void)
+{
+	platform_driver_unregister(&sec_headset_driver);
+}
+
+module_init(sec_headset_init);
+module_exit(sec_headset_exit);
+
+MODULE_AUTHOR("Eunki Kim <eunki_kim@samsung.com>");
+MODULE_DESCRIPTION("SEC HEADSET detection driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/arch/arm/mach-s3c6410/setup-sdhci.c linux-2.6.29-spica/arch/arm/mach-s3c6410/setup-sdhci.c
--- linux-2.6.29/arch/arm/mach-s3c6410/setup-sdhci.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mach-s3c6410/setup-sdhci.c	2010-05-06 12:42:45.644210217 +0700
@@ -26,12 +26,19 @@
 #include <plat/regs-sdhci.h>
 #include <plat/sdhci.h>
 
+#include <mach/map.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+
+#include <mach/hardware.h>
+
+
 /* clock sources for the mmc bus clock, order as for the ctrl2[5..4] */
 
 char *s3c6410_hsmmc_clksrcs[4] = {
 	[0] = "hsmmc",
 	[1] = "hsmmc",
-	[2] = "mmc_bus",
+	[2] = "hsmmc",
 	/* [3] = "48m", - note not succesfully used yet */
 };
 
@@ -48,8 +55,42 @@
 		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
 	}
 
-	s3c_gpio_setpull(S3C64XX_GPG(6), S3C_GPIO_PULL_UP);
-	s3c_gpio_cfgpin(S3C64XX_GPG(6), S3C_GPIO_SFN(2));
+	s3c_gpio_cfgpin(GPIO_TF_DETECT, S3C_GPIO_SFN(GPIO_TF_DETECT_AF));
+	gpio_set_value(GPIO_TF_DETECT, GPIO_LEVEL_HIGH);
+	s3c_gpio_setpull(GPIO_TF_DETECT, S3C_GPIO_PULL_NONE);
+}
+
+void s3c6410_setup_sdhci1_cfg_gpio(struct platform_device *dev, int width)
+{
+	unsigned int gpio;
+	unsigned int end;
+
+	end = S3C64XX_GPH(2 + width);
+
+	/* Set all the necessary GPG pins to special-function 0 */
+	for (gpio = S3C64XX_GPH(0); gpio < end; gpio++) {
+		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(2));
+		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+	}
+}
+
+void s3c6410_setup_sdhci2_cfg_gpio(struct platform_device *dev, int width)
+{
+	unsigned int gpio;
+	unsigned int end;
+
+	end = S3C64XX_GPH(6 + width);
+
+	s3c_gpio_cfgpin(S3C64XX_GPC(5), S3C_GPIO_SFN(3));
+	s3c_gpio_cfgpin(S3C64XX_GPC(4), S3C_GPIO_SFN(3));
+
+	s3c_gpio_setpull(S3C64XX_GPC(5), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(S3C64XX_GPC(4), S3C_GPIO_PULL_NONE);
+
+	for (gpio = S3C64XX_GPH(6); gpio < end; gpio++) {
+		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
+		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+	}
 }
 
 void s3c6410_setup_sdhci0_cfg_card(struct platform_device *dev,
@@ -57,46 +98,31 @@
 				    struct mmc_ios *ios,
 				    struct mmc_card *card)
 {
-	u32 ctrl2, ctrl3;
+	u32 ctrl2 = 0, ctrl3 = 0;
 
 	/* don't need to alter anything acording to card-type */
 
-	writel(S3C64XX_SDHCI_CONTROL4_DRIVE_9mA, r + S3C64XX_SDHCI_CONTROL4);
+	writel(S3C64XX_SDHCI_CONTROL4_DRIVE_4mA, r + S3C64XX_SDHCI_CONTROL4);
 
 	ctrl2 = readl(r + S3C_SDHCI_CONTROL2);
 	ctrl2 &= S3C_SDHCI_CTRL2_SELBASECLK_MASK;
 	ctrl2 |= (S3C64XX_SDHCI_CTRL2_ENSTAASYNCCLR |
-		  S3C64XX_SDHCI_CTRL2_ENCMDCNFMSK |
-		  S3C_SDHCI_CTRL2_ENFBCLKRX |
-		  S3C_SDHCI_CTRL2_DFCNT_NONE |
-		  S3C_SDHCI_CTRL2_ENCLKOUTHOLD);
+		S3C64XX_SDHCI_CTRL2_ENCMDCNFMSK |
+		//S3C_SDHCI_CTRL2_ENFBCLKRX |
+		S3C_SDHCI_CTRL2_DFCNT_NONE |
+		S3C_SDHCI_CTRL2_ENCLKOUTHOLD);
 
 	if (ios->clock < 25 * 1000000)
+	{
 		ctrl3 = (S3C_SDHCI_CTRL3_FCSEL3 |
 			 S3C_SDHCI_CTRL3_FCSEL2 |
 			 S3C_SDHCI_CTRL3_FCSEL1 |
 			 S3C_SDHCI_CTRL3_FCSEL0);
+	}
 	else
-		ctrl3 = (S3C_SDHCI_CTRL3_FCSEL1 | S3C_SDHCI_CTRL3_FCSEL0);
-
-	printk(KERN_INFO "%s: CTRL 2=%08x, 3=%08x\n", __func__, ctrl2, ctrl3);
+	{
+		ctrl3 = S3C_SDHCI_CTRL3_FCSEL0;
+	}
 	writel(ctrl2, r + S3C_SDHCI_CONTROL2);
 	writel(ctrl3, r + S3C_SDHCI_CONTROL3);
 }
-
-void s3c6410_setup_sdhci1_cfg_gpio(struct platform_device *dev, int width)
-{
-	unsigned int gpio;
-	unsigned int end;
-
-	end = S3C64XX_GPH(2 + width);
-
-	/* Set all the necessary GPG pins to special-function 0 */
-	for (gpio = S3C64XX_GPH(0); gpio < end; gpio++) {
-		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(2));
-		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
-	}
-
-	s3c_gpio_setpull(S3C64XX_GPG(6), S3C_GPIO_PULL_UP);
-	s3c_gpio_cfgpin(S3C64XX_GPG(6), S3C_GPIO_SFN(3));
-}
diff -Nur linux-2.6.29/arch/arm/mm/cache-v6.S linux-2.6.29-spica/arch/arm/mm/cache-v6.S
--- linux-2.6.29/arch/arm/mm/cache-v6.S	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mm/cache-v6.S	2010-03-30 11:00:13.000000000 +0700
@@ -199,6 +199,11 @@
  *	- end     - virtual end address of region
  */
 ENTRY(v6_dma_flush_range)
+#ifdef CONFIG_CACHE_FLUSH_RANGE_LIMIT
+	sub	r2, r1, r0
+	cmp	r2, #CONFIG_CACHE_FLUSH_RANGE_LIMIT
+	bhi	v6_dma_flush_dcache_all
+#endif
 	bic	r0, r0, #D_CACHE_LINE_SIZE - 1
 1:
 #ifdef HARVARD_CACHE
@@ -213,6 +218,18 @@
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
 	mov	pc, lr
 
+#ifdef CONFIG_CACHE_FLUSH_RANGE_LIMIT
+v6_dma_flush_dcache_all:
+	mov	r0, #0
+#ifdef HARVARD_CACHE
+	mcr	p15, 0, r0, c7, c14, 0		@ D cache clean+invalidate
+#else
+	mcr	p15, 0, r0, c7, c15, 0		@ Cache clean+invalidate
+#endif
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
+	mov	pc, lr
+#endif
+
 	__INITDATA
 
 	.type	v6_cache_fns, #object
diff -Nur linux-2.6.29/arch/arm/mm/Kconfig linux-2.6.29-spica/arch/arm/mm/Kconfig
--- linux-2.6.29/arch/arm/mm/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/mm/Kconfig	2010-05-06 12:42:45.644210217 +0700
@@ -362,7 +362,8 @@
 
 # ARMv6
 config CPU_V6
-	bool "Support ARM V6 processor" if ARCH_INTEGRATOR || MACH_REALVIEW_EB
+	bool "Support ARM V6 processor" if ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_OMAP2 || ARCH_MX3 || ARCH_MSM7X00A || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176 || ARCH_S3C64XX
+	default y if ARCH_S3C64XX
 	select CPU_32v6
 	select CPU_ABRT_EV6
 	select CPU_PABRT_NOIFAR
@@ -717,3 +718,8 @@
 	select OUTER_CACHE
 	help
 	  This option enables the L2 cache on XScale3.
+
+config ARM_L1_CACHE_SHIFT
+	int
+	default 6 if ARCH_OMAP3
+	default 5
diff -Nur linux-2.6.29/arch/arm/plat-s3c/clock.c linux-2.6.29-spica/arch/arm/plat-s3c/clock.c
--- linux-2.6.29/arch/arm/plat-s3c/clock.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/clock.c	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* linux/arch/arm/plat-s3c24xx/clock.c
+/* linux/arch/arm/plat-s3c/clock.c
  *
  * Copyright (c) 2004-2005 Simtec Electronics
  *	Ben Dooks <ben@simtec.co.uk>
@@ -38,13 +38,15 @@
 #include <linux/ioport.h>
 #include <linux/clk.h>
 #include <linux/spinlock.h>
+#include <linux/delay.h>
 #include <linux/io.h>
 
 #include <mach/hardware.h>
+#include <mach/map.h>
 #include <asm/irq.h>
 
 #include <plat/cpu-freq.h>
-
+#include <plat/regs-clock.h>
 #include <plat/clock.h>
 #include <plat/cpu.h>
 
@@ -265,9 +267,8 @@
 	.name		= "fclk",
 	.id		= -1,
 	.rate		= 0,
-	.parent		= &clk_mpll,
+	.parent		= NULL,
 	.ctrlbit	= 0,
-	.set_rate	= clk_default_setrate,
 };
 
 struct clk clk_h = {
@@ -279,6 +280,23 @@
 	.set_rate	= clk_default_setrate,
 };
 
+struct clk clk_hx2 = {
+	.name       	= "hclkx2",
+	.id     	= -1,
+	.rate       	= 0,
+	.parent     	= NULL,
+	.ctrlbit    	= 0,
+	.set_rate	= clk_default_setrate,
+};
+
+struct clk clk_s = {
+	.name       	= "sclk",
+	.id     	= -1,
+	.rate       	= 0,
+	.parent     	= NULL,
+	.ctrlbit    	= 0,
+};
+
 struct clk clk_p = {
 	.name		= "pclk",
 	.id		= -1,
@@ -295,8 +313,6 @@
 	.parent		= &clk_upll,
 };
 
-
-
 struct clk s3c24xx_uclk = {
 	.name		= "uclk",
 	.id		= -1,
@@ -304,7 +320,7 @@
 
 /* initialise the clock system */
 
-int s3c24xx_register_clock(struct clk *clk)
+int s3c_register_clock(struct clk *clk)
 {
 	clk->owner = THIS_MODULE;
 
@@ -323,12 +339,12 @@
 	return 0;
 }
 
-int s3c24xx_register_clocks(struct clk **clks, int nr_clks)
+int s3c_register_clocks(struct clk **clks, int nr_clks)
 {
 	int fails = 0;
 
 	for (; nr_clks > 0; nr_clks--, clks++) {
-		if (s3c24xx_register_clock(*clks) < 0)
+		if (s3c_register_clock(*clks) < 0)
 			fails++;
 	}
 
@@ -337,30 +353,36 @@
 
 /* initalise all the clocks */
 
-int __init s3c24xx_register_baseclocks(unsigned long xtal)
+int __init s3c_register_baseclocks(unsigned long xtal)
 {
-	printk(KERN_INFO "S3C24XX Clocks, (c) 2004 Simtec Electronics\n");
+	printk(KERN_INFO "S3C Clocks, (c) 2004 Simtec Electronics\n");
 
 	clk_xtal.rate = xtal;
 
 	/* register our clocks */
 
-	if (s3c24xx_register_clock(&clk_xtal) < 0)
+	if (s3c_register_clock(&clk_xtal) < 0)
 		printk(KERN_ERR "failed to register master xtal\n");
 
-	if (s3c24xx_register_clock(&clk_mpll) < 0)
+	if (s3c_register_clock(&clk_mpll) < 0)
 		printk(KERN_ERR "failed to register mpll clock\n");
 
-	if (s3c24xx_register_clock(&clk_upll) < 0)
+	if (s3c_register_clock(&clk_upll) < 0)
 		printk(KERN_ERR "failed to register upll clock\n");
 
-	if (s3c24xx_register_clock(&clk_f) < 0)
+	if (s3c_register_clock(&clk_f) < 0)
 		printk(KERN_ERR "failed to register cpu fclk\n");
 
-	if (s3c24xx_register_clock(&clk_h) < 0)
+	if (s3c_register_clock(&clk_h) < 0)
 		printk(KERN_ERR "failed to register cpu hclk\n");
 
-	if (s3c24xx_register_clock(&clk_p) < 0)
+	if (s3c_register_clock(&clk_hx2) < 0)
+		printk(KERN_ERR "failed to register cpu hclkx2\n");
+
+	if (s3c_register_clock(&clk_s) < 0)
+		printk(KERN_ERR "failed to register cpu sclk\n");
+
+	if (s3c_register_clock(&clk_p) < 0)
 		printk(KERN_ERR "failed to register cpu pclk\n");
 
 	return 0;
diff -Nur linux-2.6.29/arch/arm/plat-s3c/dev-hsmmc1.c linux-2.6.29-spica/arch/arm/plat-s3c/dev-hsmmc1.c
--- linux-2.6.29/arch/arm/plat-s3c/dev-hsmmc1.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/dev-hsmmc1.c	2010-05-06 12:42:45.634864134 +0700
@@ -20,8 +20,6 @@
 #include <plat/devs.h>
 #include <plat/cpu.h>
 
-#define S3C_SZ_HSMMC	(0x1000)
-
 static struct resource s3c_hsmmc1_resource[] = {
 	[0] = {
 		.start = S3C_PA_HSMMC1,
@@ -39,8 +37,8 @@
 
 struct s3c_sdhci_platdata s3c_hsmmc1_def_platdata = {
 	.max_width	= 4,
-	.host_caps	= (MMC_CAP_4_BIT_DATA |
-			   MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+	.host_caps	= (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED |
+				MMC_CAP_SD_HIGHSPEED),
 };
 
 struct platform_device s3c_device_hsmmc1 = {
@@ -54,6 +52,7 @@
 		.platform_data		= &s3c_hsmmc1_def_platdata,
 	},
 };
+EXPORT_SYMBOL(s3c_device_hsmmc1);
 
 void s3c_sdhci1_set_platdata(struct s3c_sdhci_platdata *pd)
 {
@@ -61,8 +60,17 @@
 
 	set->max_width = pd->max_width;
 
+	if (pd->host_caps)
+		set->host_caps = pd->host_caps;
 	if (pd->cfg_gpio)
 		set->cfg_gpio = pd->cfg_gpio;
 	if (pd->cfg_card)
 		set->cfg_card = pd->cfg_card;
+	if (pd->cfg_ext_cd)
+		set->cfg_ext_cd = pd->cfg_ext_cd;
+	if (pd->detect_ext_cd)
+		set->detect_ext_cd = pd->detect_ext_cd;
+	if (pd->ext_cd)
+		set->ext_cd = pd->ext_cd;
 }
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/dev-hsmmc2.c linux-2.6.29-spica/arch/arm/plat-s3c/dev-hsmmc2.c
--- linux-2.6.29/arch/arm/plat-s3c/dev-hsmmc2.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/dev-hsmmc2.c	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,76 @@
+/* linux/arch/arm/plat-s3c/dev-hsmmc2.c
+ *
+ * Copyright (c) 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C series device definition for hsmmc device 1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/mmc/host.h>
+
+#include <mach/map.h>
+#include <plat/sdhci.h>
+#include <plat/devs.h>
+#include <plat/cpu.h>
+
+static struct resource s3c_hsmmc2_resource[] = {
+	[0] = {
+		.start = S3C_PA_HSMMC2,
+		.end   = S3C_PA_HSMMC2 + S3C_SZ_HSMMC - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_HSMMC2,
+		.end   = IRQ_HSMMC2,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static u64 s3c_device_hsmmc2_dmamask = 0xffffffffUL;
+
+struct s3c_sdhci_platdata s3c_hsmmc2_def_platdata = {
+	.max_width	= 4,
+	.host_caps	= (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED |
+				MMC_CAP_SD_HIGHSPEED | MMC_CAP_ON_BOARD),
+};
+
+struct platform_device s3c_device_hsmmc2 = {
+	.name		= "s3c-sdhci",
+	.id		= 2,
+	.num_resources	= ARRAY_SIZE(s3c_hsmmc2_resource),
+	.resource	= s3c_hsmmc2_resource,
+	.dev		= {
+		.dma_mask		= &s3c_device_hsmmc2_dmamask,
+		.coherent_dma_mask	= 0xffffffffUL,
+		.platform_data		= &s3c_hsmmc2_def_platdata,
+	},
+};
+EXPORT_SYMBOL(s3c_device_hsmmc2);
+
+void s3c_sdhci2_set_platdata(struct s3c_sdhci_platdata *pd)
+{
+	struct s3c_sdhci_platdata *set = &s3c_hsmmc2_def_platdata;
+
+	set->max_width = pd->max_width;
+
+	if (pd->host_caps)
+		set->host_caps = pd->host_caps;
+	if (pd->cfg_gpio)
+		set->cfg_gpio = pd->cfg_gpio;
+	if (pd->cfg_card)
+		set->cfg_card = pd->cfg_card;
+	if (pd->cfg_ext_cd)
+		set->cfg_ext_cd = pd->cfg_ext_cd;
+	if (pd->detect_ext_cd)
+		set->detect_ext_cd = pd->detect_ext_cd;
+	if (pd->ext_cd)
+		set->ext_cd = pd->ext_cd;
+}
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/dev-hsmmc.c linux-2.6.29-spica/arch/arm/plat-s3c/dev-hsmmc.c
--- linux-2.6.29/arch/arm/plat-s3c/dev-hsmmc.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/dev-hsmmc.c	2010-05-06 12:42:45.634864134 +0700
@@ -20,8 +20,6 @@
 #include <plat/devs.h>
 #include <plat/cpu.h>
 
-#define S3C_SZ_HSMMC	(0x1000)
-
 static struct resource s3c_hsmmc_resource[] = {
 	[0] = {
 		.start = S3C_PA_HSMMC0,
@@ -32,15 +30,21 @@
 		.start = IRQ_HSMMC0,
 		.end   = IRQ_HSMMC0,
 		.flags = IORESOURCE_IRQ,
-	}
+	},
+	[2] = {
+		.start = IRQ_EINT(6),
+		.end   = IRQ_EINT(6),
+		.flags = IORESOURCE_IRQ,
+	}	
+
 };
 
 static u64 s3c_device_hsmmc_dmamask = 0xffffffffUL;
 
 struct s3c_sdhci_platdata s3c_hsmmc0_def_platdata = {
 	.max_width	= 4,
-	.host_caps	= (MMC_CAP_4_BIT_DATA |
-			   MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+	.host_caps	= (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED |
+				MMC_CAP_SD_HIGHSPEED),
 };
 
 struct platform_device s3c_device_hsmmc0 = {
@@ -61,8 +65,17 @@
 
 	set->max_width = pd->max_width;
 
+	if (pd->host_caps)
+		set->host_caps = pd->host_caps;
 	if (pd->cfg_gpio)
 		set->cfg_gpio = pd->cfg_gpio;
 	if (pd->cfg_card)
 		set->cfg_card = pd->cfg_card;
+	if (pd->cfg_ext_cd)
+		set->cfg_ext_cd = pd->cfg_ext_cd;
+	if (pd->detect_ext_cd)
+		set->detect_ext_cd = pd->detect_ext_cd;
+	if (pd->ext_cd)
+		set->ext_cd = pd->ext_cd;
 }
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/dev-i2c0.c linux-2.6.29-spica/arch/arm/plat-s3c/dev-i2c0.c
--- linux-2.6.29/arch/arm/plat-s3c/dev-i2c0.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/dev-i2c0.c	2010-05-06 12:42:45.634864134 +0700
@@ -15,13 +15,13 @@
 #include <linux/string.h>
 #include <linux/platform_device.h>
 
-#include <mach/irqs.h>
 #include <mach/map.h>
 
 #include <plat/regs-iic.h>
 #include <plat/iic.h>
 #include <plat/devs.h>
 #include <plat/cpu.h>
+#include <plat/irqs.h>
 
 static struct resource s3c_i2c_resource[] = {
 	[0] = {
@@ -37,7 +37,7 @@
 };
 
 struct platform_device s3c_device_i2c0 = {
-	.name		  = "s3c2410-i2c",
+	.name		  = "s3c-i2c",
 #ifdef CONFIG_S3C_DEV_I2C1
 	.id		  = 0,
 #else
@@ -47,22 +47,26 @@
 	.resource	  = s3c_i2c_resource,
 };
 
-static struct s3c2410_platform_i2c default_i2c_data0 __initdata = {
+static struct s3c_platform_i2c default_i2c_data0 __initdata = {
 	.flags		= 0,
 	.slave_addr	= 0x10,
 	.bus_freq	= 100*1000,
+#if defined(CONFIG_MACH_CYGNUS) || defined(CONFIG_MACH_SATURN)
+	.max_freq	= 150*1000,
+#else
 	.max_freq	= 400*1000,
-	.sda_delay	= S3C2410_IICLC_SDA_DELAY5 | S3C2410_IICLC_FILTER_ON,
+#endif	
+	.sda_delay	= S3C_IICLC_SDA_DELAY5 | S3C_IICLC_FILTER_ON,
 };
 
-void __init s3c_i2c0_set_platdata(struct s3c2410_platform_i2c *pd)
+void __init s3c_i2c0_set_platdata(struct s3c_platform_i2c *pd)
 {
-	struct s3c2410_platform_i2c *npd;
+	struct s3c_platform_i2c *npd;
 
 	if (!pd)
 		pd = &default_i2c_data0;
 
-	npd = kmemdup(pd, sizeof(struct s3c2410_platform_i2c), GFP_KERNEL);
+	npd = kmemdup(pd, sizeof(struct s3c_platform_i2c), GFP_KERNEL);
 	if (!npd)
 		printk(KERN_ERR "%s: no memory for platform data\n", __func__);
 	else if (!npd->cfg_gpio)
diff -Nur linux-2.6.29/arch/arm/plat-s3c/dev-i2c1.c linux-2.6.29-spica/arch/arm/plat-s3c/dev-i2c1.c
--- linux-2.6.29/arch/arm/plat-s3c/dev-i2c1.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/dev-i2c1.c	2010-05-06 12:42:45.634864134 +0700
@@ -15,13 +15,13 @@
 #include <linux/string.h>
 #include <linux/platform_device.h>
 
-#include <mach/irqs.h>
 #include <mach/map.h>
 
 #include <plat/regs-iic.h>
 #include <plat/iic.h>
 #include <plat/devs.h>
 #include <plat/cpu.h>
+#include <plat/irqs.h>
 
 static struct resource s3c_i2c_resource[] = {
 	[0] = {
@@ -37,29 +37,29 @@
 };
 
 struct platform_device s3c_device_i2c1 = {
-	.name		  = "s3c2410-i2c",
+	.name		  = "s3c-i2c",
 	.id		  = 1,
 	.num_resources	  = ARRAY_SIZE(s3c_i2c_resource),
 	.resource	  = s3c_i2c_resource,
 };
 
-static struct s3c2410_platform_i2c default_i2c_data1 __initdata = {
+static struct s3c_platform_i2c default_i2c_data1 __initdata = {
 	.flags		= 0,
 	.bus_num	= 1,
 	.slave_addr	= 0x10,
 	.bus_freq	= 100*1000,
 	.max_freq	= 400*1000,
-	.sda_delay	= S3C2410_IICLC_SDA_DELAY5 | S3C2410_IICLC_FILTER_ON,
+	.sda_delay	= S3C_IICLC_SDA_DELAY5 | S3C_IICLC_FILTER_ON,
 };
 
-void __init s3c_i2c1_set_platdata(struct s3c2410_platform_i2c *pd)
+void __init s3c_i2c1_set_platdata(struct s3c_platform_i2c *pd)
 {
-	struct s3c2410_platform_i2c *npd;
+	struct s3c_platform_i2c *npd;
 
 	if (!pd)
 		pd = &default_i2c_data1;
 
-	npd = kmemdup(pd, sizeof(struct s3c2410_platform_i2c), GFP_KERNEL);
+	npd = kmemdup(pd, sizeof(struct s3c_platform_i2c), GFP_KERNEL);
 	if (!npd)
 		printk(KERN_ERR "%s: no memory for platform data\n", __func__);
 	else if (!npd->cfg_gpio)
diff -Nur linux-2.6.29/arch/arm/plat-s3c/dev-i2s.c linux-2.6.29-spica/arch/arm/plat-s3c/dev-i2s.c
--- linux-2.6.29/arch/arm/plat-s3c/dev-i2s.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/dev-i2s.c	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,49 @@
+/* linux/arch/arm/plat-s3c/dev-i2s.c
+ *
+ * Copyright (c) 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C series device definition for hsmmc devices
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <mach/map.h>
+#include <plat/devs.h>
+#include <plat/cpu.h>
+#include <asm/irq.h>
+
+
+/* IIS */
+static struct resource s3c_iis_resource[] = {
+	[0] = {
+		.start = S3C_PA_IIS,
+		.end   = S3C_PA_IIS + S3C_SZ_IIS -1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_S3C6410_IIS,
+		.end   = IRQ_S3C6410_IIS,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static u64 s3c_device_iis_dmamask = 0xffffffffUL;
+
+struct platform_device s3c_device_iis = {
+	.name		  = "s3c-iis",
+	.id		  = -1,
+	.num_resources	  = ARRAY_SIZE(s3c_iis_resource),
+	.resource	  = s3c_iis_resource,
+	.dev              = {
+		.dma_mask = &s3c_device_iis_dmamask,
+		.coherent_dma_mask = 0xffffffffUL
+	}
+};
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/dev-ts.c linux-2.6.29-spica/arch/arm/plat-s3c/dev-ts.c
--- linux-2.6.29/arch/arm/plat-s3c/dev-ts.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/dev-ts.c	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,42 @@
+/* linux/arch/arm/plat-s3c/dev-ts.c
+ *
+ * Copyright (c) 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C series device definition for hsmmc devices
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <mach/map.h>
+#include <plat/devs.h>
+#include <plat/cpu.h>
+#include <plat/adcts.h>
+#include <plat/ts.h>
+
+/* Touch srcreen */
+struct platform_device s3c_device_ts = {
+	.name		  = "s3c-ts",
+	.id		  = -1,
+};
+
+void __init s3c_ts_set_platdata(struct s3c_ts_mach_info *pd)
+{
+	struct s3c_ts_mach_info *npd;
+
+	npd = kmalloc(sizeof(*npd), GFP_KERNEL);
+	if (npd) {
+		memcpy(npd, pd, sizeof(*npd));
+		s3c_device_ts.dev.platform_data = npd;
+	} else {
+		printk(KERN_ERR "no memory for Touchscreen platform data\n");
+	}
+}
+
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/dma-pl080.c linux-2.6.29-spica/arch/arm/plat-s3c/dma-pl080.c
--- linux-2.6.29/arch/arm/plat-s3c/dma-pl080.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/dma-pl080.c	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,1602 @@
+/* linux/arch/arm/plat-s3c/dma-pl080.c
+ *
+ * Copyright (c) 2003-2005,2006 Samsung Electronics
+ *
+ * S3C6400/S3C6410 DMA core
+ *
+ * http://www.samsung.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifdef CONFIG_S3C_DMA_DEBUG
+#define DEBUG
+#endif
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/sysdev.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+
+#include <plat/regs-clock.h>
+#include <plat/dma.h>
+#include <mach/map.h>
+#include <mach/dma.h>
+
+
+/* io map for dma */
+static void __iomem *dma_base;
+static struct kmem_cache *dma_kmem;
+
+static int dma_channels;
+struct s3c_dma_selection 	dma_sel;
+static struct s3c2410_dma_chan *dma_chan_map[DMACH_MAX];
+
+/* dma channel state information */
+struct s3c2410_dma_chan 	s3c_dma_chans[S3C_DMA_CHANNELS];
+s3c_dma_controller_t s3c_dma_cntlrs[S3C_DMA_CONTROLLERS];
+
+#undef pr_debug		
+//#define dma_dbg
+
+#ifdef dma_dbg
+#define sh_printk(fmt...) printk( fmt)
+#define pr_debug(fmt...) printk( fmt)
+#else
+#define sh_printk(fmt...)
+#define pr_debug(fmt...)
+#endif
+
+/* debugging functions */
+
+#define BUF_MAGIC (0xcafebabe)
+
+#define dmawarn(fmt...) printk(KERN_DEBUG fmt)
+
+#define dma_regaddr(chan, reg) ((chan)->regs + (reg))
+#define dma_wrreg(chan, reg, val) writel((val), (chan)->regs + (reg))
+#define dma_rdreg(chan, reg) readl((chan)->regs + (reg))
+
+#define dbg_showregs(chan) do { } while(0)
+#define dbg_showchan(chan) do { } while(0)
+
+void s3c_dma_dump(int dcon_num, int channel)
+{
+	unsigned long tmp;
+	s3c_dma_controller_t *dma_controller = &s3c_dma_cntlrs[dcon_num];
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_INT_STATUS);
+	printk("%d dcon_num %d subchnnel INT_STATUS %lx\n", dcon_num, channel, tmp);
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_INT_TCSTATUS);
+	printk("%d dcon_num %d subchnnel INT_TCSTATUS %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_ENBLD_CHANNELS);
+	printk("%d dcon_num %d subchnnel ENBLD_CHANNELS %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_CONFIGURATION);
+	printk("%d dcon_num %d subchnnel DMAC_CONFIGUARATION %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_CSRCADDR(channel));
+	printk("%d dcon_num %d subchnnel SRCADDRESS %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_CDESTADDR(channel));
+	printk("%d dcon_num %d subchnnel DESTADDRESS %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_CLLI(channel));
+	printk("%d dcon_num %d subchnnel LLI %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_CCONTROL0(channel));
+	printk("%d dcon_num %d subchnnel CCONTROL0 %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_CCONTROL1(channel));
+	printk("%d dcon_num %d subchnnel CCONTROL1 %lx\n", dcon_num, channel, tmp);
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_CCONFIGURATION(channel));
+
+	printk("%d dcon_num %d subchnnel CH CONFIGUARATION %lx\n", dcon_num, channel, tmp);
+}
+
+
+/* lookup_dma_channel
+ *
+ * change the dma channel number given into a real dma channel id
+*/
+
+static struct s3c2410_dma_chan *lookup_dma_channel(unsigned int channel)
+{
+	if (channel & DMACH_LOW_LEVEL)
+		return &s3c_dma_chans[channel & ~DMACH_LOW_LEVEL];
+	else
+		return dma_chan_map[channel];
+}
+
+/* s3c_dma_stats_timeout
+ *
+ * Update DMA stats from timeout info
+ */
+static void s3c_dma_stats_timeout(struct s3c_dma_stats * stats, int val)
+{
+	if (stats == NULL)
+		return;
+
+	if (val > stats->timeout_longest)
+		stats->timeout_longest = val;
+	if (val < stats->timeout_shortest)
+		stats->timeout_shortest = val;
+
+	stats->timeout_avg += val;
+}
+
+void s3c_enable_dmac(unsigned int dcon_num)
+{
+	s3c_dma_controller_t *dma_controller = &s3c_dma_cntlrs[dcon_num];
+	dma_wrreg(dma_controller, S3C_DMAC_CONFIGURATION, S3C_DMA_CONTROLLER_ENABLE);
+}
+
+void s3c_disable_dmac(unsigned int dcon_num)
+{
+	unsigned long tmp;
+	s3c_dma_controller_t *dma_controller = &s3c_dma_cntlrs[dcon_num];
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_CONFIGURATION);
+	tmp &= ~S3C_DMA_CONTROLLER_ENABLE;
+	dma_wrreg(dma_controller, S3C_DMAC_CONFIGURATION, tmp);
+}
+
+void s3c_clear_interrupts (int dcon_num, int channel)
+{
+	unsigned long tmp;
+	s3c_dma_controller_t *dma_controller = &s3c_dma_cntlrs[dcon_num];
+	
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_INT_TCCLEAR);
+	tmp |= (1 << channel);
+	dma_wrreg(dma_controller, S3C_DMAC_INT_TCCLEAR, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_INT_ERRORCLEAR);
+	tmp |= (1 << channel);
+	dma_wrreg(dma_controller, S3C_DMAC_INT_ERRORCLEAR, tmp);
+}
+
+/* s3c_dma_waitforload
+ *
+ * wait for the DMA engine to load a buffer, and update the state accordingly
+ */
+static int s3c_dma_waitforload(struct s3c2410_dma_chan *chan, int line)
+{
+	int timeout = chan->load_timeout;
+	int took;
+
+	pr_debug("%s channel number : %d\n", __FUNCTION__, chan->number);
+
+	if (chan->load_state != S3C_DMALOAD_1LOADED) {
+		printk(KERN_ERR
+		       "dma%d: s3c_dma_waitforload() called in loadstate %d from line %d\n",
+		       chan->number, chan->load_state, line);
+		return 0;
+	}
+
+	if (chan->stats != NULL)
+		chan->stats->loads++;
+
+	while (--timeout > 0) {
+		if ((dma_rdreg(chan->dma_con, S3C_DMAC_ENBLD_CHANNELS)) & (0x1 << chan->number)) {
+			took = chan->load_timeout - timeout;
+			s3c_dma_stats_timeout(chan->stats, took);
+
+			switch (chan->load_state) {
+			case S3C_DMALOAD_1LOADED:
+				chan->load_state = S3C_DMALOAD_1RUNNING;
+				break;
+
+			default:
+				printk(KERN_ERR
+				       "dma%d: unknown load_state in s3c_dma_waitforload() %d\n",
+				       chan->number, chan->load_state);
+			}
+
+			return 1;
+		}
+	}
+
+	if (chan->stats != NULL) {
+		chan->stats->timeout_failed++;
+	}
+
+	return 0;
+}
+
+
+/* s3c_dma_loadbuffer
+ *
+ * load a buffer, and update the channel state
+ */
+static inline int s3c_dma_loadbuffer(struct s3c2410_dma_chan *chan,
+		       struct s3c_dma_buf *buf)
+{
+	unsigned long reload;
+
+	pr_debug("s3c_chan_loadbuffer: loading buffer %p (0x%08lx,0x%06x)\n",
+		 buf, (unsigned long) buf->data, buf->size);
+
+	if (buf == NULL) {
+		dmawarn("buffer is NULL\n");
+		return -EINVAL;
+	}
+
+	/* check the state of the channel before we do anything */
+
+	if (chan->load_state == S3C_DMALOAD_1LOADED) {
+		dmawarn("load_state is S3C2410_DMALOAD_1LOADED\n");
+		reload = (buf->next == NULL) ? S3C2410_DCON_NORELOAD : 0;
+	}
+
+	if (chan->load_state == S3C_DMALOAD_1LOADED_1RUNNING) {
+		dmawarn("state is S3C2410_DMALOAD_1LOADED_1RUNNING\n");
+		reload = S3C2410_DCON_AUTORELOAD;
+	}
+
+	writel(buf->data, chan->addr_reg);
+
+	pr_debug("%s: DMA control0 - %08x\n", __FUNCTION__, chan->dcon);
+	pr_debug("%s: DMA control1 - %08x\n", __FUNCTION__, (buf->size / chan->xfer_unit));
+	
+	dma_wrreg(chan, S3C_DMAC_CxCONTROL0, chan->dcon);
+	dma_wrreg(chan, S3C_DMAC_CxCONTROL1, (buf->size / chan->xfer_unit));
+	
+	chan->next = buf->next;
+
+	/* update the state of the channel */
+
+	switch (chan->load_state) {
+	case S3C_DMALOAD_NONE:
+		chan->load_state = S3C_DMALOAD_1LOADED;
+		break;
+
+	case S3C_DMALOAD_1RUNNING:
+		chan->load_state = S3C_DMALOAD_1LOADED_1RUNNING;
+		break;
+
+	default:
+		dmawarn("dmaload: unknown state %d in loadbuffer\n", chan->load_state);
+		break;
+	}
+
+	return 0;
+}
+
+
+/* s3c_dma_call_op
+ *
+ * small routine to call the o routine with the given op if it has been
+ * registered
+ */
+static void s3c_dma_call_op(struct s3c2410_dma_chan * chan, enum s3c_chan_op op)
+{
+	if (chan->op_fn != NULL) {
+		(chan->op_fn) (chan, op);
+	}
+}
+
+/* s3c_dma_buffdone
+ *
+ * small wrapper to check if callback routine needs to be called, and
+ * if so, call it
+ */
+static inline void s3c_dma_buffdone(struct s3c2410_dma_chan * chan,
+				struct s3c_dma_buf * buf,
+				enum s3c2410_dma_buffresult result)
+{
+	pr_debug("callback_fn will be called=%p, buf=%p, id=%p, size=%d, result=%d\n",
+		 chan->callback_fn, buf, buf->id, buf->size, result);
+
+	if (chan->callback_fn != NULL) {
+		(chan->callback_fn) (chan, buf->id, buf->size, result);
+	}
+}
+
+/* s3c_dma_start
+ *
+ * start a dma channel going
+ */
+static int s3c_dma_start(struct s3c2410_dma_chan *chan)
+{
+	unsigned long flags;
+
+	pr_debug("s3c_start_dma: channel number=%d, index=%d\n", chan->number, chan->index);
+
+	local_irq_save(flags);
+
+	if (chan->state == S3C_DMA_RUNNING) {
+		pr_debug("s3c_start_dma: already running (%d)\n", chan->state);
+		local_irq_restore(flags);
+		return 0;
+	}
+
+	chan->state = S3C_DMA_RUNNING;
+
+	/* check wether there is anything to load, and if not, see
+	 * if we can find anything to load
+	 */
+
+	if (chan->load_state == S3C_DMALOAD_NONE) {
+		if (chan->next == NULL) {
+			printk(KERN_ERR "dma%d: dcon_num has nothing loaded\n", chan->number);
+			chan->state = S3C_DMA_IDLE;
+			local_irq_restore(flags);
+			return -EINVAL;
+		}
+
+		s3c_dma_loadbuffer(chan, chan->next);
+	}
+
+	dbg_showchan(chan);
+
+	/* enable the channel */
+
+	if (!chan->irq_enabled) {
+		enable_irq(chan->irq);
+		chan->irq_enabled = 1;
+	}
+
+	/* Get the DMA channel  started ...*/
+	dma_wrreg(chan, S3C_DMAC_CxCONFIGURATION, chan->config_flags);
+
+	pr_debug("%s:wrote %08lx to S3C_DMAC_CxCONFIGURATION.\n",__FUNCTION__, chan->config_flags);
+
+	/* Start the DMA operation on Peripheral */
+	s3c_dma_call_op(chan, S3C2410_DMAOP_START);
+
+	dbg_showchan(chan);
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+
+/* s3c2410_dma_enqueue
+ *
+ * queue an given buffer for dma transfer.
+ *
+ * id         the device driver's id information for this buffer
+ * data       the physical address of the buffer data
+ * size       the size of the buffer in bytes
+ *
+ * If the channel is not running, then the flag S3C2410_DMAF_AUTOSTART
+ * is checked, and if set, the channel is started. If this flag isn't set,
+ * then an error will be returned.
+ *
+ * It is possible to queue more than one DMA buffer onto a channel at
+ * once, and the code will deal with the re-loading of the next buffer
+ * when necessary.
+ */
+int s3c2410_dma_enqueue(unsigned int channel, void *id,
+			dma_addr_t data, int size)
+{
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+	struct s3c_dma_buf *buf;
+	unsigned long flags;
+
+	pr_debug("%s: id=%p, data=%08x, size=%d\n", __FUNCTION__, id, (unsigned int) data, size);
+
+	buf = kmem_cache_alloc(dma_kmem, GFP_ATOMIC);
+	if (buf == NULL) {
+		printk(KERN_ERR "dma<%d> no memory for buffer\n", channel);
+		return -ENOMEM;
+	}
+
+	pr_debug("%s: new buffer %p\n", __FUNCTION__, buf);
+
+	//dbg_showchan(chan);
+
+	buf->next = NULL;
+	buf->data = buf->ptr = data;
+	buf->size = size;
+	buf->id = id;
+	buf->magic = BUF_MAGIC;
+
+	local_irq_save(flags);
+
+	if (chan->curr == NULL) {
+		/* we've got nothing loaded... */
+		pr_debug("%s: buffer %p queued onto empty channel\n", __FUNCTION__, buf);
+
+		chan->curr = buf;
+		chan->end = buf;
+		chan->next = NULL;
+	} else {
+		pr_debug("dma%d: %s: buffer %p queued onto non-empty channel\n",
+			 chan->number, __FUNCTION__, buf);
+
+		if (chan->end == NULL)   /* In case of flushing */
+			pr_debug("dma%d: %s: %p not empty, and chan->end==NULL?\n",
+				 chan->number, __FUNCTION__, chan);
+		else {
+			chan->end->next = buf;
+			chan->end = buf;
+		}
+	}
+
+	/* if necessary, update the next buffer field */
+	if (chan->next == NULL)
+		chan->next = buf;
+
+	/* check to see if we can load a buffer */
+	if (chan->state == S3C_DMA_RUNNING) {
+		if (chan->load_state == S3C_DMALOAD_1LOADED && 1) {
+			if (s3c_dma_waitforload(chan, __LINE__) == 0) {
+				printk(KERN_ERR "dma%d: loadbuffer:"
+				       "timeout loading buffer\n", chan->number);
+				dbg_showchan(chan);
+				local_irq_restore(flags);
+				return -EINVAL;
+			}
+		}
+	} else if (chan->state == S3C_DMA_IDLE) {
+		if (chan->flags & S3C2410_DMAF_AUTOSTART) {
+			s3c2410_dma_ctrl(channel, S3C2410_DMAOP_START);
+		} else {
+			pr_debug("loading onto stopped channel\n");
+		}
+	}
+
+	local_irq_restore(flags);
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_enqueue);
+
+/* s3c2410_dma_enqueue_sg
+ *
+ * queue an given buffer for dma transfer.
+ *
+ * id         the device driver's id information for this buffer
+ * data       the physical address of the buffer data
+ * size       the size of the buffer in bytes
+ * sg_reg     the scatter&gather list
+ *
+ * If the channel is not running, then the flag S3C2410_DMAF_AUTOSTART
+ * is checked, and if set, the channel is started. If this flag isn't set,
+ * then an error will be returned.
+ *
+ * It is possible to queue more than one DMA buffer onto a channel at
+ * once, and the code will deal with the re-loading of the next buffer
+ * when necessary.
+ */
+int s3c2410_dma_enqueue_sg(unsigned int channel, void *id,
+			dma_addr_t data, int size, struct s3c_sg_list *sg_list)
+{
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+	struct s3c_dma_buf *buf;
+	unsigned long flags;
+
+	pr_debug("%s: id=%p, data=%08x, size=%d\n", __FUNCTION__, id, (unsigned int) data, size);
+
+	buf = kmem_cache_alloc(dma_kmem, GFP_ATOMIC);
+	if (buf == NULL) {
+		printk(KERN_ERR "dma<%d> no memory for buffer\n", channel);
+		return -ENOMEM;
+	}
+
+	pr_debug("%s: new buffer %p\n", __FUNCTION__, buf);
+
+	//dbg_showchan(chan);
+
+	buf->next = NULL;
+	buf->data = buf->ptr = data;
+	buf->size = size;
+	buf->id = id;
+	buf->magic = BUF_MAGIC;
+
+	local_irq_save(flags);
+
+	if (chan->curr == NULL) {
+		/* we've got nothing loaded... */
+		pr_debug("%s: buffer %p queued onto empty channel\n", __FUNCTION__, buf);
+
+		chan->curr = buf;
+		chan->end = buf;
+		chan->next = NULL;
+	} else {
+		pr_debug("dma%d: %s: buffer %p queued onto non-empty channel\n",
+			 chan->number, __FUNCTION__, buf);
+
+		if (chan->end == NULL)   /* In case of flushing */
+			pr_debug("dma%d: %s: %p not empty, and chan->end==NULL?\n",
+				 chan->number, __FUNCTION__, chan);
+		else {
+			chan->end->next = buf;
+			chan->end = buf;
+		}
+	}
+
+	/* if necessary, update the next buffer field */
+	if (chan->next == NULL)
+		chan->next = buf;
+
+	/* check to see if we can load a buffer */
+	if (chan->state == S3C_DMA_RUNNING) {
+		if (chan->load_state == S3C_DMALOAD_1LOADED && 1) {
+			if (s3c_dma_waitforload(chan, __LINE__) == 0) {
+				printk(KERN_ERR "dma%d: loadbuffer:"
+				       "timeout loading buffer\n", chan->number);
+				dbg_showchan(chan);
+				local_irq_restore(flags);
+				return -EINVAL;
+			}
+		}
+	} else if (chan->state == S3C_DMA_IDLE) {
+		dma_wrreg(chan, S3C_DMAC_CxLLI, virt_to_phys(&sg_list));
+		
+		if (chan->flags & S3C2410_DMAF_AUTOSTART) {
+			s3c2410_dma_ctrl(channel, S3C2410_DMAOP_START);
+		} else {
+			pr_debug("loading onto stopped channel\n");
+		}
+	}
+
+	local_irq_restore(flags);
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_enqueue_sg);
+
+
+static inline void s3c_dma_freebuf(struct s3c_dma_buf * buf)
+{
+	int magicok = (buf->magic == BUF_MAGIC);
+
+	buf->magic = -1;
+
+	if (magicok) {
+		kmem_cache_free(dma_kmem, buf);
+	} else {
+		printk("s3c_dma_freebuf: buff %p with bad magic\n", buf);
+	}
+}
+
+/* s3c_dma_lastxfer
+ *
+ * called when the system is out of buffers, to ensure that the channel
+ * is prepared for shutdown.
+ */
+static inline void s3c_dma_lastxfer(struct s3c2410_dma_chan *chan)
+{
+	pr_debug("DMA CH %d: s3c_dma_lastxfer: load_state %d\n", chan->number, chan->load_state);
+	
+	switch (chan->load_state) {
+	case S3C_DMALOAD_NONE:
+		pr_debug("DMA CH %d: s3c_dma_lastxfer: load_state : S3C2_DMALOAD_NONE%d\n", chan->number);
+		break;
+
+	case S3C_DMALOAD_1LOADED:
+		if (s3c_dma_waitforload(chan, __LINE__) == 0) {
+			/* flag error? */
+			printk(KERN_ERR "dma%d: timeout waiting for load\n", chan->number);
+			return;
+		}
+		break;
+
+	default:
+		pr_debug("dma%d: lastxfer: unhandled load_state %d with no next",
+			 chan->number, chan->load_state);
+		return;
+
+	}
+
+}
+
+
+#define dmadbg2(x...)
+
+static irqreturn_t s3c_dma_irq(int irq, void *devpw)
+{
+	unsigned int channel = 0, dcon_num, i;
+	unsigned long tmp;
+	s3c_dma_controller_t *dma_controller = (s3c_dma_controller_t *) devpw;
+	
+	struct s3c2410_dma_chan *chan=NULL;
+	struct s3c_dma_buf *buf;
+
+	dcon_num = dma_controller->number;
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_INT_TCSTATUS);
+	pr_debug("# s3c_dma_irq: TC status : 0x%x\n", tmp);
+
+	if(tmp==0) {
+		return IRQ_HANDLED;
+	}
+
+	for (i = 0; i < S3C_CHANNELS_PER_DMA; i++) {
+		if (tmp & 0x01) {
+
+			pr_debug("# DMA Controller %d: requestor %d\n", dcon_num, i);
+			
+			channel = i;
+			chan = &s3c_dma_chans[channel + dcon_num * S3C_CHANNELS_PER_DMA];
+			pr_debug("# DMA channel number : %d, index : %d\n", chan->number, chan->index);
+			
+			buf = chan->curr;
+			
+			dbg_showchan(chan);
+
+			/* modify the channel state */
+			switch (chan->load_state) {
+			case S3C_DMALOAD_1RUNNING:
+				/* TODO - if we are running only one buffer, we probably
+				 * want to reload here, and then worry about the buffer
+				 * callback */
+
+				chan->load_state = S3C_DMALOAD_NONE;
+				break;
+
+			case S3C_DMALOAD_1LOADED:
+				/* iirc, we should go back to NONE loaded here, we
+				 * had a buffer, and it was never verified as being
+				 * loaded.
+				 */
+
+				chan->load_state = S3C_DMALOAD_NONE;
+				break;
+
+			case S3C_DMALOAD_1LOADED_1RUNNING:
+				/* we'll worry about checking to see if another buffer is
+				 * ready after we've called back the owner. This should
+				 * ensure we do not wait around too long for the DMA
+				 * engine to start the next transfer
+				 */
+
+				chan->load_state = S3C_DMALOAD_1LOADED;
+				break;
+
+			case S3C_DMALOAD_NONE:
+				printk(KERN_ERR "dma%d: IRQ with no loaded buffer?\n",
+				       chan->number);
+				break;
+
+			default:
+				printk(KERN_ERR "dma%d: IRQ in invalid load_state %d\n",
+				       chan->number, chan->load_state);
+				break;
+			}
+
+			if (buf != NULL) {
+				/* update the chain to make sure that if we load any more
+				 * buffers when we call the callback function, things should
+				 * work properly */
+
+				chan->curr = buf->next;
+				buf->next = NULL;
+
+				if (buf->magic != BUF_MAGIC) {
+					printk(KERN_ERR "dma%d: %s: buf %p incorrect magic\n",
+					       chan->number, __FUNCTION__, buf);
+					goto next_channel;
+				}
+
+				s3c_dma_buffdone(chan, buf, S3C2410_RES_OK);
+
+				/* free resouces */
+				s3c_dma_freebuf(buf);
+			} else {
+			
+			}
+
+			if (chan->next != NULL) {
+				unsigned long flags;
+
+				switch (chan->load_state) {
+				case S3C_DMALOAD_1RUNNING:
+					/* don't need to do anything for this state */
+					break;
+
+				case S3C_DMALOAD_NONE:
+					/* can load buffer immediately */
+					break;
+
+				case S3C_DMALOAD_1LOADED:
+					if (s3c_dma_waitforload(chan, __LINE__) == 0) {
+						/* flag error? */
+						printk(KERN_ERR "dma%d: timeout waiting for load\n",
+						       chan->number);
+						goto next_channel;
+					}
+
+					break;
+
+				case S3C_DMALOAD_1LOADED_1RUNNING:
+					goto next_channel;
+
+				default:
+					printk(KERN_ERR "dma%d: unknown load_state in irq, %d\n",
+					       chan->number, chan->load_state);
+					goto next_channel;
+				}
+
+				local_irq_save(flags);
+				s3c_dma_loadbuffer(chan, chan->next);
+				
+				//shaju added for dbg
+				dma_wrreg(chan, S3C_DMAC_CxCONFIGURATION, chan->config_flags);
+				
+				local_irq_restore(flags);
+				
+			} else {
+				s3c_dma_lastxfer(chan);
+				
+				/* see if we can stop this channel.. */
+				if (chan->load_state == S3C_DMALOAD_NONE) {
+					pr_debug("# DMA CH %d(index:%d): end of transfer, stopping channel (%ld)\n",
+						 chan->number, chan->index, jiffies);
+					s3c2410_dma_ctrl(chan->index | DMACH_LOW_LEVEL, S3C2410_DMAOP_STOP);
+				}
+			}
+		}
+
+next_channel:
+		tmp >>= 1;
+
+	}
+
+	s3c_clear_interrupts(chan->dma_con->number, chan->number);
+	
+	return IRQ_HANDLED;
+}
+
+static struct s3c2410_dma_chan *s3c_dma_map_channel(int channel);
+
+/* s3c_request_dma
+ *
+ * get control of an dma channel
+*/
+
+int s3c2410_dma_request(unsigned int channel,
+			struct s3c2410_dma_client *client,
+			void *dev)
+{
+	struct s3c2410_dma_chan *chan;
+	unsigned long flags;
+	int err;
+
+	pr_debug("DMA CH %d: s3c2410_request_dma: client=%s, dev=%p\n",
+		 channel, client->name, dev);
+
+	local_irq_save(flags);
+
+	chan = s3c_dma_map_channel(channel);
+	if (chan == NULL) {
+		local_irq_restore(flags);
+		return -EBUSY;
+	}
+
+	dbg_showchan(chan);
+
+	chan->client = client;
+	chan->in_use = 1;
+
+	chan->dma_con->in_use++;
+
+	if (!chan->irq_claimed) {
+		pr_debug("DMA CH %d: %s : requesting irq %d\n",
+			 channel, __FUNCTION__, chan->irq);
+
+		chan->irq_claimed = 1;
+		local_irq_restore(flags);
+
+		err = request_irq(chan->irq, s3c_dma_irq, IRQF_DISABLED|IRQF_SHARED,
+				  client->name, (void *) chan->dma_con);
+
+		local_irq_save(flags);
+
+		if (err) {
+			chan->in_use = 0;
+			chan->irq_claimed = 0;
+			chan->dma_con->in_use--;
+			local_irq_restore(flags);
+
+			printk(KERN_ERR "%s: cannot get IRQ %d for DMA %d\n",
+			       client->name, chan->irq, chan->number);
+			return err;
+		}
+
+		chan->irq_enabled = 1;
+		
+		/* enable the main dma.. this can be disabled
+		 * when main channel use count is 0 */
+		s3c_enable_dmac(chan->dma_con->number);
+	}
+	
+	s3c_clear_interrupts(chan->dma_con->number, chan->number);
+	local_irq_restore(flags);
+
+	/* need to setup */
+
+	pr_debug("%s: channel initialised, %p, number:%d, index:%d\n", __FUNCTION__, chan, chan->number, chan->index);
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_request);
+
+/* s3c_dma_free
+ *
+ * release the given channel back to the system, will stop and flush
+ * any outstanding transfers, and ensure the channel is ready for the
+ * next claimant.
+ *
+ * Note, although a warning is currently printed if the freeing client
+ * info is not the same as the registrant's client info, the free is still
+ * allowed to go through.
+ */
+int s3c2410_dma_free(dmach_t channel, struct s3c2410_dma_client *client)
+{
+	unsigned long flags;
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+	pr_debug("%s: DMA channel %d will be stopped\n", __FUNCTION__, chan->number);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	if (chan->client != client) {
+		printk(KERN_WARNING
+		       "DMA CH %d: possible free from different client (channel %p, passed %p)\n",
+		       channel, chan->client, client);
+	}
+
+	/* sort out stopping and freeing the channel */
+
+	if (chan->state != S3C_DMA_IDLE) {
+		pr_debug("%s: need to stop dma channel %p\n", __FUNCTION__, chan);
+
+		/* possibly flush the channel */
+		s3c2410_dma_ctrl(channel, S3C2410_DMAOP_STOP);
+	}
+
+	chan->client = NULL;
+	chan->in_use = 0;
+	
+	chan->dma_con->in_use--;
+
+	if (chan->irq_claimed)
+		free_irq(chan->irq, (void *)chan->dma_con);
+
+	chan->irq_claimed = 0;
+
+	if (!(channel & DMACH_LOW_LEVEL))
+		dma_chan_map[channel] = NULL;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_free);
+
+/*actively polling for the A bit can block the cpu*/
+void s3c_dma_flush_fifo(struct s3c2410_dma_chan *chan)
+{
+	unsigned long tmp;
+	
+	tmp = dma_rdreg(chan, S3C_DMAC_CxCONFIGURATION);
+	tmp |= S3C_DMACONFIG_HALT;
+	dma_wrreg(chan, S3C_DMAC_CxCONFIGURATION, tmp);
+
+	tmp = dma_rdreg(chan, S3C_DMAC_CxCONFIGURATION);
+	
+	/*this while loop can be very dangerous..may be put the process to sleep rather than waiting till fifo is drained */
+	while (tmp & S3C_DMACONFIG_ACTIVE) {
+		tmp = dma_rdreg(chan, S3C_DMAC_CxCONFIGURATION);
+	}
+}
+
+static int s3c_dma_dostop(struct s3c2410_dma_chan *chan) 
+{
+	unsigned long tmp;
+	unsigned long flags;
+
+	pr_debug("%s: DMA Channel No : %d\n", __FUNCTION__, chan->number);
+
+	dbg_showchan(chan);
+
+	local_irq_save(flags);
+
+    //Commenting out this function call(as its causing freeze) and even without this it adheres to  
+    //ARM Primecell 080's disabling a DMA channel and losing data in the FIFO method 
+	//s3c_dma_flush_fifo(chan);
+	
+	s3c_dma_call_op(chan, S3C2410_DMAOP_STOP);
+
+	tmp = dma_rdreg(chan, S3C_DMAC_CxCONFIGURATION);
+	
+	tmp &= ~S3C_DMACONFIG_CHANNEL_ENABLE;
+	dma_wrreg(chan, S3C_DMAC_CxCONFIGURATION, tmp);
+	
+	pr_debug("%s: S3C_DMAC_CxCONFIGURATION : %08x\n", __FUNCTION__, tmp);
+
+	chan->state = S3C_DMA_IDLE;
+	chan->load_state = S3C_DMALOAD_NONE;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static void s3c_dma_showchan(struct s3c2410_dma_chan * chan)
+{
+
+}
+
+/* s3c_dma_flush
+ *
+ * stop the channel, and remove all current and pending transfers
+ */
+
+void s3c_waitforstop(struct s3c2410_dma_chan *chan)
+{
+
+}
+
+static int s3c_dma_flush(struct s3c2410_dma_chan *chan)
+{
+	struct s3c_dma_buf *buf, *next;
+	unsigned long flags;
+
+	pr_debug("%s:\n", __FUNCTION__);
+
+	local_irq_save(flags);
+
+	s3c_dma_showchan(chan);
+
+	if (chan->state != S3C_DMA_IDLE) {
+		pr_debug("%s: stopping channel...\n", __FUNCTION__);
+		s3c2410_dma_ctrl(chan->number, S3C2410_DMAOP_STOP);
+	}
+
+	buf = chan->curr;
+	if (buf == NULL)
+		buf = chan->next;
+
+	chan->curr = chan->next = chan->end = NULL;
+	chan->load_state = S3C_DMALOAD_NONE;
+
+	if (buf != NULL) {
+		for (; buf != NULL; buf = next) {
+			next = buf->next;
+
+			pr_debug("%s: free buffer %p, next %p\n", __FUNCTION__, buf, buf->next);
+
+			s3c_dma_buffdone(chan, buf, S3C2410_RES_ABORT);
+			s3c_dma_freebuf(buf);
+		}
+	}
+	//s3c_dma_waitforstop(chan);
+	
+	s3c_dma_showchan(chan);
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+int s3c_dma_started(struct s3c2410_dma_chan *chan)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	dbg_showchan(chan);
+
+	/* if we've only loaded one buffer onto the channel, then chec
+	 * to see if we have another, and if so, try and load it so when
+	 * the first buffer is finished, the new one will be loaded onto
+	 * the channel */
+
+	if (chan->next != NULL) {
+		if (chan->load_state == S3C_DMALOAD_1LOADED) {
+
+			if (s3c_dma_waitforload(chan, __LINE__) == 0) {
+				pr_debug("%s: buff not yet loaded, no more todo\n",
+					 __FUNCTION__);
+			} else {
+				chan->load_state = S3C_DMALOAD_1RUNNING;
+				s3c_dma_loadbuffer(chan, chan->next);
+			}
+
+		} else if (chan->load_state == S3C_DMALOAD_1RUNNING) {
+			s3c_dma_loadbuffer(chan, chan->next);
+		}
+	}
+
+	local_irq_restore(flags);
+
+	return 0;
+
+}
+
+int s3c2410_dma_ctrl(dmach_t channel, enum s3c_chan_op op)
+{
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	switch (op) {
+	case S3C2410_DMAOP_START:
+		return s3c_dma_start(chan);
+
+	case S3C2410_DMAOP_STOP:
+		return s3c_dma_dostop(chan);
+
+	case S3C2410_DMAOP_PAUSE:
+	case S3C2410_DMAOP_RESUME:
+		return -ENOENT;
+
+	case S3C2410_DMAOP_FLUSH:
+		return s3c_dma_flush(chan);
+
+	case S3C2410_DMAOP_STARTED:
+		return s3c_dma_started(chan);
+
+	case S3C2410_DMAOP_TIMEOUT:
+		return 0;
+
+	}
+
+	return -ENOENT;      /* unknown, don't bother */
+}
+EXPORT_SYMBOL(s3c2410_dma_ctrl);
+
+
+/* s3c_dma_config
+ *
+ * xfersize:     size of unit in bytes (1,2,4)
+ * dcon:         base value of the DCONx register
+ */
+int s3c2410_dma_config(dmach_t channel,
+		       int xferunit,
+		       int dcon)
+{
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	pr_debug("%s: chan=%d, xfer_unit=%d, dcon=%08x\n",
+		 __FUNCTION__, channel, xferunit, dcon);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: Initial dcon is %08x\n", __FUNCTION__, dcon);
+
+	dcon |= chan->dcon & dma_sel.dcon_mask;
+
+	pr_debug("%s: New dcon is %08x\n", __FUNCTION__, dcon);
+	
+	switch (xferunit) {
+	case 1:
+		dcon |= S3C_DMACONTROL_SRC_WIDTH_BYTE;
+		dcon |= S3C_DMACONTROL_DEST_WIDTH_BYTE;
+		break;
+
+	case 2:
+		dcon |= S3C_DMACONTROL_SRC_WIDTH_HWORD;
+		dcon |= S3C_DMACONTROL_DEST_WIDTH_HWORD;
+		break;
+
+	case 4:
+		dcon |= S3C_DMACONTROL_SRC_WIDTH_WORD;
+		dcon |= S3C_DMACONTROL_DEST_WIDTH_WORD;
+		break;
+
+	default:
+		pr_debug("%s: Bad transfer size %d\n", __FUNCTION__, xferunit);
+		return -EINVAL;
+	}
+
+	pr_debug("%s: DMA Channel control :  %08x\n", __FUNCTION__, dcon);
+
+	dcon |= S3C_DMACONTROL_TC_INT_ENABLE;
+	dcon |= chan->control_flags;
+	pr_debug("%s: dcon now %08x\n", __FUNCTION__, dcon);
+
+	/* For DMCCxControl 0 */
+	chan->dcon = dcon;
+
+	/* For DMACCxControl 1 : xferunit means transfer width.*/
+	chan->xfer_unit = xferunit;
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_config);
+
+
+int s3c2410_dma_setflags(dmach_t channel, unsigned int flags)
+{
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: chan=%p, flags=%08x\n", __FUNCTION__, chan, flags);
+
+	chan->flags = flags;
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_setflags);
+
+
+/* do we need to protect the settings of the fields from
+ * irq?
+ */
+
+int s3c2410_dma_set_opfn(dmach_t channel, s3c2410_dma_opfn_t rtn)
+{
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: chan=%p, op rtn=%p\n", __FUNCTION__, chan, rtn);
+
+	chan->op_fn = rtn;
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_set_opfn);
+
+
+int s3c2410_dma_set_buffdone_fn(dmach_t channel, s3c2410_dma_cbfn_t rtn)
+{
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: chan=%p, callback rtn=%p\n", __FUNCTION__, chan, rtn);
+
+	chan->callback_fn = rtn;
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_set_buffdone_fn);
+
+
+/* s3c2410_dma_devconfig
+ *
+ * configure the dma source/destination hardware type and address
+ *
+ * flowctrl: direction of dma flow
+ *
+ * src_per dst_per: dma channel number of src and dst periphreal,
+ *
+ * devaddr:   physical address of the source
+ */
+
+int s3c2410_dma_devconfig(int channel,
+			  enum s3c2410_dmasrc source,
+			  int hwcfg,
+			  unsigned long devaddr)
+{
+	unsigned long tmp;
+
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: source=%d, hwcfg=%08x, devaddr=%08lx\n",
+		 __FUNCTION__, (int)source, hwcfg, devaddr);
+
+	chan->source = source;
+	chan->dev_addr = devaddr;
+
+	switch (source) {
+	case S3C2410_DMASRC_MEM:
+		/* source is Memory : Mem-to-Peri ( Write into FIFO) */
+		tmp = S3C_DMACONFIG_TCMASK | S3C_DMACONFIG_FLOWCTRL_MEM2PER | (chan->map->hw_addr.to) <<
+			S3C_DEST_SHIFT | S3C_DMACONFIG_CHANNEL_ENABLE;
+		
+		chan->config_flags = tmp;
+
+		/* TODO : Now, Scatter&Gather DMA NOT supported */
+		dma_wrreg(chan, S3C_DMAC_CxLLI, 0);
+		
+		/* devaddr : Periperal address (destination) */
+		dma_wrreg(chan, S3C_DMAC_CxDESTADDR, devaddr);
+
+		/* source address : memory(buffer) address */
+		chan->addr_reg = dma_regaddr(chan, S3C_DMAC_CxSRCADDR);
+		
+		chan->control_flags = S3C_DMACONTROL_SRC_INC | S3C_DMACONTROL_DEST_AXI_PERI ;
+		//chan->control_flags = hwcfg;
+		return 0;
+
+	case S3C2410_DMASRC_HW:
+		/* source is peripheral : Peri-to-Mem ( Read from FIFO) */
+		tmp = S3C_DMACONFIG_TCMASK | S3C_DMACONFIG_FLOWCTRL_PER2MEM | (chan->map->hw_addr.from) <<
+			S3C_SRC_SHIFT | S3C_DMACONFIG_CHANNEL_ENABLE;
+		
+		chan->config_flags = tmp;
+
+		/* TODO : Now, Scatter&Gather DMA NOT supported */
+		dma_wrreg(chan, S3C_DMAC_CxLLI, 0);
+		
+		/* devaddr : Periperal address (source) */
+		dma_wrreg(chan, S3C_DMAC_CxSRCADDR, devaddr);
+
+		/* destination address : memory(buffer) address */
+		chan->addr_reg = dma_regaddr(chan, S3C_DMAC_CxDESTADDR);
+		
+		chan->control_flags = S3C_DMACONTROL_DEST_INC | S3C_DMACONTROL_SRC_AXI_PERI;
+		//chan->control_flags = hwcfg;
+		
+		return 0;
+
+	case S3C_DMA_MEM2MEM:
+		/* this is temporary for G3D */
+		tmp = S3C_DMACONFIG_TCMASK | S3C_DMACONFIG_FLOWCTRL_MEM2MEM | S3C_DMACONFIG_CHANNEL_ENABLE;
+		
+		chan->config_flags = tmp;
+
+		/* TODO : Now, Scatter&Gather DMA NOT YET supported */
+		dma_wrreg(chan, S3C_DMAC_CxLLI, 0);
+		
+		/* devaddr : memory/onenand address (source) */
+		dma_wrreg(chan, S3C_DMAC_CxSRCADDR, devaddr);
+
+		/* destination address : memory(buffer) address */
+		chan->addr_reg = dma_regaddr(chan, S3C_DMAC_CxDESTADDR);
+	
+		chan->control_flags |= (S3C_DMACONTROL_SRC_INC | S3C_DMACONTROL_DEST_AXI_PERI
+				| S3C_DMACONTROL_SBSIZE_4 | S3C_DMACONTROL_DBSIZE_4);
+		//chan->control_flags = hwcfg;
+		
+		return 0;
+
+	case S3C_DMA_MEM2MEM_P:
+		/* source is memory : Memory-to-Mem ( Read/Write) */
+		tmp = S3C_DMACONFIG_TCMASK | S3C_DMACONFIG_FLOWCTRL_MEM2MEM | S3C_DMACONFIG_CHANNEL_ENABLE;
+
+		//if(chan->map->hw_addr.from == S3C_DMA0_ONENAND_RX) {
+			//tmp |= S3C_DMACONFIG_ONENANDMODESRC;
+		//}
+		
+		chan->config_flags = tmp;
+
+		/* TODO : Now, Scatter&Gather DMA NOT YET supported */
+		dma_wrreg(chan, S3C_DMAC_CxLLI, 0);
+		
+		/* devaddr : memory/onenand address (source) */
+		dma_wrreg(chan, S3C_DMAC_CxSRCADDR, devaddr);
+
+		/* destination address : memory(buffer) address */
+		chan->addr_reg = dma_regaddr(chan, S3C_DMAC_CxDESTADDR);
+		
+		chan->control_flags |= (S3C_DMACONTROL_SRC_INC | S3C_DMACONTROL_DEST_INC 
+				| S3C_DMACONTROL_SBSIZE_4 | S3C_DMACONTROL_DBSIZE_4);
+		//chan->control_flags = hwcfg;
+		
+		return 0;
+
+	case S3C_DMA_PER2PER:
+		printk("Peripheral-to-Peripheral DMA NOT YET implemented !! \n");
+		return -EINVAL;
+
+	default:
+		printk(KERN_ERR "DMA CH :%d - invalid source type ()\n", channel);
+		printk("Unsupported DMA configuration from the device driver using DMA driver \n");
+		return -EINVAL;
+	}
+	
+}
+
+EXPORT_SYMBOL(s3c2410_dma_devconfig);
+
+
+/* 
+ * s3c_dma_getposition
+ * returns the current transfer points for the dma source and destination
+ */
+int s3c2410_dma_getposition(dmach_t channel, dma_addr_t *src, dma_addr_t *dst)
+{
+ 	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	if (src != NULL)
+ 		*src = dma_rdreg(chan, S3C_DMAC_CxSRCADDR);
+	
+ 	if (dst != NULL)
+ 		*dst = dma_rdreg(chan, S3C_DMAC_CxDESTADDR);
+
+ 	return 0;
+}
+
+EXPORT_SYMBOL(s3c2410_dma_getposition);
+
+
+/* system device class */
+#ifdef CONFIG_PM
+static int s3c_dma_suspend (struct sys_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+static int s3c_dma_resume (struct sys_device *dev)
+{
+	return 0;
+}
+#else
+#define s3c_dma_suspend NULL
+#define s3c_dma_resume  NULL
+#endif				/* CONFIG_PM */
+
+struct sysdev_class dma_sysclass = {
+	.name = "s3c64xx-dma",
+	.suspend = s3c_dma_suspend,
+	.resume = s3c_dma_resume,
+};
+
+/* kmem cache implementation */
+
+static void s3c_dma_cache_ctor(void *p)
+{
+	memset(p, 0, sizeof(struct s3c_dma_buf));
+}
+
+
+void dma_test (int dcon_num, int channel)
+{
+	int tmp;
+	
+	s3c_dma_controller_t *dma_controller = &s3c_dma_cntlrs[dcon_num];
+
+	dma_wrreg(dma_controller, S3C_DMAC_CONFIGURATION, S3C_DMA_CONTROLLER_ENABLE);
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_CONFIGURATION);
+	printk("reg val %d\n", tmp);
+	dma_wrreg(dma_controller, S3C_DMAC_CCONFIGURATION(channel), 0x01);
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_CCONFIGURATION(channel));
+
+	printk("reg conf %x\n", tmp);
+	dma_wrreg(dma_controller, S3C_DMAC_CCONTROL0(channel), 0x8ff02064);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_CCONTROL0(channel));
+	printk("reg ctrl %x\n", tmp);
+}
+
+
+/* initialisation code */
+
+int __init s3c_dma_init(unsigned int channels, unsigned int irq,
+			    unsigned int stride)
+{
+	struct s3c2410_dma_chan *cp;
+	s3c_dma_controller_t *dconp;
+	int channel, controller;
+	int ret;
+
+	printk("S3C DMA-pl080 Controller Driver, (c) 2006-2007 Samsung Electronics\n");
+
+	dma_channels = channels;
+	printk("Total %d DMA channels will be initialized.\n", channels);
+
+	ret = sysdev_class_register(&dma_sysclass);
+	if (ret != 0) {
+		printk(KERN_ERR "dma sysclass registration failed.\n");
+		goto err;
+	}
+
+	dma_kmem = kmem_cache_create("dma_desc", sizeof(struct s3c_dma_buf), 0,
+				     SLAB_HWCACHE_ALIGN, (void *)s3c_dma_cache_ctor);
+
+	if (dma_kmem == NULL) {
+		printk(KERN_ERR "DMA failed to make kmem cache\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	for (controller = 0; controller < S3C_DMA_CONTROLLERS; controller++) {
+		dconp = &s3c_dma_cntlrs[controller];
+
+		memset(dconp, 0, sizeof(s3c_dma_controller_t));
+
+		if(controller < 2) {
+			dma_base = ioremap((S3C_PA_DMA + (controller * 0x100000)), 0x200);
+			if (dma_base == NULL) {
+				printk(KERN_ERR "DMA failed to ioremap register block\n");
+				return -ENOMEM;
+			}
+
+			/* dma controller's irqs are in order.. */
+			dconp->irq = controller + IRQ_DMA0;
+		}
+		else {
+			dma_base = ioremap(((S3C_PA_DMA + 0x8B00000) + ((controller%2) * 0x100000)), 0x200);
+			if (dma_base == NULL) {
+				printk(KERN_ERR "SDMA failed to ioremap register block\n");
+				return -ENOMEM;
+			}
+
+			/* dma controller's irqs are in order.. */
+			dconp->irq = (controller%2) + IRQ_SDMA0;
+		}
+		
+		dconp->number = controller;
+		dconp->regs = dma_base;
+		sh_printk("DMA controller : %d irq %d regs_base %x\n", dconp->number, dconp->irq,
+			  dconp->regs);
+	}
+
+	for (channel = 0; channel < channels; channel++) {
+		controller = channel / S3C_CHANNELS_PER_DMA;
+		cp = &s3c_dma_chans[channel];
+
+		memset(cp, 0, sizeof(struct s3c2410_dma_chan));
+
+		cp->dma_con = &s3c_dma_cntlrs[controller];
+		
+		/* dma channel irqs are in order.. */
+		cp->index = channel;
+		cp->number = channel%S3C_CHANNELS_PER_DMA;
+		
+		cp->irq = s3c_dma_cntlrs[controller].irq;
+		
+		cp->regs = s3c_dma_cntlrs[controller].regs + ((channel%S3C_CHANNELS_PER_DMA)*stride) + 0x100;
+
+		/* point current stats somewhere */
+		cp->stats = &cp->stats_store;
+		cp->stats_store.timeout_shortest = LONG_MAX;
+
+		/* basic channel configuration */
+		cp->load_timeout = 1 << 18;
+
+		/* register system device */
+		cp->dev.cls = &dma_sysclass;
+		cp->dev.id = channel;
+		//ret = sysdev_register(&cp->dev);
+
+		sh_printk("DMA channel %d at %p, irq %d\n", cp->number, cp->regs, cp->irq);
+	}
+
+	return 0;
+
+err:
+	kmem_cache_destroy(dma_kmem);
+	iounmap(dma_base);
+	dma_base = NULL;
+	return ret;
+}
+
+
+
+static inline int is_channel_valid(unsigned int channel)
+{
+	return (channel & DMA_CH_VALID);
+}
+
+static struct s3c_dma_order *dma_order;
+
+
+/* s3c_dma_map_channel()
+ *
+ * turn the virtual channel number into a real, and un-used hardware
+ * channel.
+ *
+ * first, try the dma ordering given to us by either the relevant
+ * dma code, or the board. Then just find the first usable free
+ * channel
+*/
+
+struct s3c2410_dma_chan *s3c_dma_map_channel(int channel)
+{
+	struct s3c_dma_order_ch *ord = NULL;
+	struct s3c_dma_map *ch_map;
+	struct s3c2410_dma_chan *dmach;
+	int ch;
+
+	if (dma_sel.map == NULL || channel > dma_sel.map_size)
+		return NULL;
+
+	ch_map = dma_sel.map + channel;
+
+	/* first, try the board mapping */
+
+	if (dma_order) {
+		ord = &dma_order->channels[channel];
+
+		for (ch = 0; ch < dma_channels; ch++) {
+			if (!is_channel_valid(ord->list[ch]))
+				continue;
+
+			if (s3c_dma_chans[ord->list[ch]].in_use == 0) {
+				ch = ord->list[ch] & ~DMA_CH_VALID;
+				goto found;
+			}
+		}
+
+		if (ord->flags & DMA_CH_NEVER)
+			return NULL;
+	}
+
+	/* second, search the channel map for first free */
+
+	for (ch = 0; ch < dma_channels; ch++) {
+		if (!is_channel_valid(ch_map->channels[ch]))
+			continue;
+
+		if (s3c_dma_chans[ch].in_use == 0) {
+			pr_debug("mapped channel %d to %d\n", channel, ch);
+			break;
+		}
+	}
+
+	if (ch >= dma_channels)
+		return NULL;
+
+	/* update our channel mapping */
+
+ found:
+	dmach = &s3c_dma_chans[ch];
+	dma_chan_map[channel] = dmach;
+
+	/* select the channel */
+	(dma_sel.select)(dmach, ch_map);
+
+	return dmach;
+}
+
+static int s3c_dma_check_entry(struct s3c_dma_map *map, int ch)
+{
+	unsigned long tmp = __raw_readl(S3C_SDMA_SEL);
+	
+	tmp |= map->sdma_sel;
+	__raw_writel(tmp, S3C_SDMA_SEL);
+	
+	return 0;
+}
+
+int __init s3c_dma_init_map(struct s3c_dma_selection *sel)
+{
+	struct s3c_dma_map *nmap;
+	size_t map_sz = sizeof(*nmap) * sel->map_size;
+	int ptr;
+
+	nmap = kmalloc(map_sz, GFP_KERNEL);
+	if (nmap == NULL)
+		return -ENOMEM;
+
+	memcpy(nmap, sel->map, map_sz);
+	memcpy(&dma_sel, sel, sizeof(*sel));
+
+	dma_sel.map = nmap;
+
+	for (ptr = 0; ptr < sel->map_size; ptr++)
+		s3c_dma_check_entry(nmap+ptr, ptr);
+
+	return 0;
+}
+
+int __init s3c_dma_order_set(struct s3c_dma_order *ord)
+{
+	struct s3c_dma_order *nord = dma_order;
+
+	if (nord == NULL)
+		nord = kmalloc(sizeof(struct s3c_dma_order), GFP_KERNEL);
+
+	if (nord == NULL) {
+		printk(KERN_ERR "no memory to store dma channel order\n");
+		return -ENOMEM;
+	}
+
+	dma_order = nord;
+	memcpy(nord, ord, sizeof(struct s3c_dma_order));
+	return 0;
+}
+
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/dma-pl080-sol.c linux-2.6.29-spica/arch/arm/plat-s3c/dma-pl080-sol.c
--- linux-2.6.29/arch/arm/plat-s3c/dma-pl080-sol.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/dma-pl080-sol.c	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,432 @@
+/*
+ * linux/arch/arm/pla-s3c/dma-pl080-sol.c
+ *
+ * Copyright (C) 2009 Samsung Electronics
+ * Copyright (C) 2006 ARM Ltd, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+
+#include <asm/io.h>
+#include <asm/bitops.h>
+#include <asm/mach-types.h>
+
+#include <plat/regs-clock.h>
+#include <plat/s3c6410-dma.h>
+#include <mach/map.h>
+#include "dma-pl080-sol.h"
+
+#define s3c6410_dmac_suspend	NULL
+#define s3c6410_dmac_resume		NULL
+#define DRIVER_NAME 			"s3c-dmac"
+
+#if defined(CONFIG_S3C6410_EB_DMAC_DEBUG)
+#define DBG(args...)                                printk(args)
+#define IFDBG(condition, args...)   if(condition)   printk(args)
+#else
+#define DBG(args...)                do{} while(0)
+#define IFDBG(condition, args...)   do{} while(0)
+#endif
+
+DEFINE_SPINLOCK(s3c6410_dma_spin_lock);
+
+static struct s3c6410_dmac_port dport[DMAC_NR];
+static unsigned int errCtr = 0;
+
+static int s3c6410_select_dmac(unsigned long dma_sel)
+{
+	unsigned long tmp = __raw_readl(S3C_SDMA_SEL);
+
+	tmp |= dma_sel;
+	__raw_writel(tmp, S3C_SDMA_SEL);
+
+	return 0;
+}
+
+static void s3c6410_dmac_post_irq(unsigned int dma_port, unsigned int dma_chan){
+
+	dmac_writel((1 << dma_chan), dma_port, DMACINTTCCLR);
+	dmac_writel((1 << dma_chan), dma_port, DMACINTERRCLR);
+}
+
+int s3c6410_dmac_transfer_setup(struct dma_data *dmadata)
+{
+	unsigned int dma_cfg   = 0;
+	unsigned int dma_ctrl0 = 0;
+	unsigned int dma_ctrl1 = 0;
+	unsigned int flow_ctrl = 0;
+
+	dma_cfg   = dmadata->dmac_cfg;
+	dma_ctrl0 = dmadata->dmac_ctrl0;
+	dma_ctrl1 = dmadata->dmac_ctrl1; 
+
+	flow_ctrl = (dmadata->dmac_cfg & 0x3800);
+	if(flow_ctrl == FCTL_DMA_M2P)
+		dmac_writel(dmadata->src_addr, dmadata->dma_port, DMACCxSRCADDR(dmadata->chan_num));
+	
+	else if(flow_ctrl == FCTL_DMA_P2M)
+		dmac_writel(dmadata->dst_addr, dmadata->dma_port, DMACCxDSTADDR(dmadata->chan_num));
+
+	dmac_writel(dma_ctrl0,	 	   dmadata->dma_port, DMACCxCTL0   (dmadata->chan_num));
+	dmac_writel(dma_ctrl1,	 	   dmadata->dma_port, DMACCxCTL1   (dmadata->chan_num));
+	dmac_writel(dma_cfg, 		   dmadata->dma_port, DMACCxCFG	   (dmadata->chan_num));
+
+	return 0;
+}
+
+unsigned int get_dma_channel(unsigned int dma_port)
+{
+	unsigned int i, channel = MAX_DMA_CHANNELS;
+
+	/* Searching Active DMA channel */
+	for(i = 0; i < MAX_DMA_CHANNELS; i++){
+		if(dport[dma_port].dmac[i]->dmadata == NULL){
+			channel = i;
+			break;
+		}
+	}	
+	return channel;
+}
+
+int s3c6410_dmac_halt(struct dma_data *dmadata, unsigned int val)
+{
+	unsigned int tmp;
+	if(val == HALT_SET) {
+		tmp = dmac_readl(dmadata->dma_port, DMACCxCFG(dmadata->chan_num)); 
+		dmac_writel(tmp | val, dmadata->dma_port, DMACCxCFG(dmadata->chan_num));
+	}
+
+	else {
+		tmp = dmac_readl(dmadata->dma_port, DMACCxCFG(dmadata->chan_num)); 
+		dmac_writel(tmp & val, dmadata->dma_port, DMACCxCFG(dmadata->chan_num));
+	}
+			
+	DBG("%s: Pass dmac_halt(), [chan:%d]\n", DRIVER_NAME, dmadata->chan_num);
+	return 0;
+}	
+EXPORT_SYMBOL(s3c6410_dmac_halt);
+
+unsigned int s3c6410_dmac_get_base(unsigned int port)
+{
+	unsigned int base_addr = (unsigned int) dport[port].dmac_base;
+	DBG("%s: Pass dmac_get_base(), address[0x%x]\n", DRIVER_NAME, base_addr);
+	return base_addr;
+}
+EXPORT_SYMBOL(s3c6410_dmac_get_base);
+
+int s3c6410_dmac_request(struct dma_data *dmadata, void *id)
+{
+	unsigned int 				channel = MAX_DMA_CHANNELS;
+	unsigned int 				flow_ctrl = 0;
+	unsigned int				val;
+
+	if(dmadata->active == DMA_USED) {
+		printk(KERN_WARNING "%s: Already allocated dma channel\n", DRIVER_NAME);
+		return -EBUSY;
+	}
+
+	channel = get_dma_channel(dmadata->dma_port);
+	DBG("%s: allocated dma channel[%d] for %s\n", DRIVER_NAME, channel, pdev->name);
+	if(channel == MAX_DMA_CHANNELS) {
+		printk(KERN_ERR "%s: Can't get dma channel\n", DRIVER_NAME);
+		return -EBUSY;
+	}
+
+	dmadata->active = DMA_USED;
+	dmadata->chan_num = channel;
+	dmadata->private_data = id;
+
+	/* Get the dmadata for the device which requested DMA */
+	dport[dmadata->dma_port].dmac[channel]->dmadata = dmadata;
+
+	dmac_writel(INTTC_CLR_CH(channel), 	 dmadata->dma_port, DMACINTTCCLR);
+	dmac_writel(ERR_INT_CLR_CH(channel), dmadata->dma_port, DMACINTERRCLR);
+
+	val = dmac_readl(dmadata->dma_port, DMACCFG);
+	if(!(val && DMAC_ENABLE)){
+		val |= DMAC_ENABLE;
+		dmac_writel(val, dmadata->dma_port, DMACCFG);
+	}
+	
+	/* Configuration SRC/DST Addr, LLI Register */
+	flow_ctrl = (dmadata->dmac_cfg & 0x3800);
+	
+	if(flow_ctrl == FCTL_DMA_M2P)
+		dmac_writel(dmadata->dst_addr, dmadata->dma_port, DMACCxDSTADDR(dmadata->chan_num));
+	
+	else if(flow_ctrl == FCTL_DMA_P2M)
+		dmac_writel(dmadata->src_addr, dmadata->dma_port, DMACCxSRCADDR(dmadata->chan_num));
+
+	dmac_writel(dmadata->lli_addr, dmadata->dma_port, DMACCxLLI	   (dmadata->chan_num));
+
+	DBG("%s: Pass dmac_request()\n", DRIVER_NAME);
+	
+    return 0;	
+}
+EXPORT_SYMBOL(s3c6410_dmac_request);
+
+int s3c6410_dmac_free(struct dma_data *dmadata)
+{
+	unsigned int i, active_count = 0;
+	unsigned int dma_port, chan_num;
+
+	DBG("%s: %s\n", DRIVER_NAME, __func__);
+
+	dma_port = dmadata->dma_port;
+	chan_num = dmadata->chan_num;
+	
+	/* DMAC Global data init for dmadata */
+	dport[dma_port].dmac[chan_num]->dmadata = NULL;
+	
+	for(i = 0; i < MAX_DMA_CHANNELS; i++){
+		if(dport[dma_port].dmac[i]->dmadata != NULL)
+			active_count += dport[dma_port].dmac[i]->dmadata->active;
+	}
+
+	/* Channel Disable */
+	dmac_writel(CHAN_DISABLE, dma_port, DMACCxCFG(chan_num));
+	dmadata->active = DMA_NOUSED;
+
+	/* For Power saving */ 
+	if(!active_count) {
+		unsigned int val;
+		val = dmac_readl(dma_port, DMACCFG);
+		val &= DMAC_DISABLE;
+		dmac_writel(val, dma_port, DMACCFG);
+	}
+	DBG("%s: Pass dmac_free(), [chan:%d]\n", DRIVER_NAME, chan_num);
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c6410_dmac_free);
+
+int s3c6410_dmac_enable(struct dma_data *dmadata)
+{
+	volatile unsigned int r;
+	unsigned int 		  channel = dmadata->chan_num;
+	unsigned int 		  dma_port  = dmadata->dma_port;
+
+	s3c6410_dmac_transfer_setup(dmadata);
+
+	r = dmac_readl(dma_port,  DMACCxCFG(channel));
+	dmac_writel((r | CHAN_ENABLE) & HALT_CLR, dma_port, DMACCxCFG(channel));
+	DBG("%s: Pass dmac_enable(), [chan:%d]\n", DRIVER_NAME, channel);
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c6410_dmac_enable);
+
+int s3c6410_dmac_disable(struct dma_data *dmadata)
+{
+	volatile unsigned int r;
+	unsigned int 		  channel = dmadata->chan_num;
+	unsigned int 		  dma_port  = dmadata->dma_port;
+
+	r = dmac_readl(dma_port, DMACCxCFG(channel));
+	dmac_writel((r & ~(CHAN_ENABLE)) | HALT_SET, dma_port, DMACCxCFG(channel));
+	DBG("%s: Pass dmac_disable(), [chan:%d]\n", DRIVER_NAME, channel);
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c6410_dmac_disable);
+
+static inline int find_channel(unsigned int x)
+{   
+	int r = 1;
+    if (!x)
+        return -1;
+    if (!(x & 0xf)) {
+        x >>= 4;
+        r += 4;
+    }
+    if (!(x & 3)) {
+        x >>= 2;
+        r += 2;
+    }
+    if (!(x & 1)) {
+        x >>= 1;
+        r += 1;
+    }
+    return r - 1;
+}   
+
+static irqreturn_t s3c6410_dmac_irq(int irq, void *devid)
+{
+//	struct platform_device		*pdev;
+	volatile unsigned int 		r;
+	unsigned int 				channel;
+	unsigned int 				dma_port;
+	unsigned long				flags;
+	void						*id;
+
+	flags = s3c6410_dma_lock();
+	r = dmac_readl(0, DMACINTTCSTAT);
+	channel = find_channel(r);
+	dma_port = 0;
+	if(channel == -1){
+		r = dmac_readl(1, DMACINTTCSTAT);
+		channel = find_channel(r);
+		dma_port = 1;
+	}
+	
+	if(channel == -1) {
+ 		r = dmac_readl(0, DMACINTERRSTAT);
+		channel = find_channel(r);
+		dma_port = 0;
+		if(channel == -1){
+			r = dmac_readl(1, DMACINTERRSTAT);
+			channel = find_channel(r);
+			dma_port = 1;
+		}	
+		if((1 << channel) & r){
+			errCtr++;
+			DBG("%s: DMA Error, channel %d\n", DRIVER_NAME, channel);
+	    }
+	}	
+	
+	else {
+		id = dport[dma_port].dmac[channel]->dmadata->private_data;
+		dport[dma_port].dmac[channel]->dmadata->dma_dev_handler(id);
+	}		
+	
+	/* e.g clear interrupt on the DMAC */
+	s3c6410_dmac_post_irq(dma_port, channel);
+
+	s3c6410_dma_unlock(flags);
+	return IRQ_HANDLED;
+}
+
+static int s3c6410_dmac_probe(struct platform_device *pdev)
+{
+	struct	 resource	 		*res;
+	unsigned int 				 ret = 0;
+	unsigned int 				 i;
+	unsigned int 				 j;
+
+	for(i = 0 ; i < DMAC_NR ; i++) {
+		if(dport[i].dmac_base == NULL)
+			break;
+	}
+
+	if(i == DMAC_NR) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	for(j = 0 ; j < MAX_DMA_CHANNELS ; j++) {
+		dport[i].dmac[j] = (struct s3c6410_dmac *)kmalloc(sizeof(struct s3c6410_dmac), GFP_KERNEL);
+		if(&dport[i].dmac[j] == NULL) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		dport[i].dmac[j]->dmadata = NULL;
+	}
+	
+	/* Get device resource(s3c6410-dmac) */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(!res) {
+		printk("%s: Couldn't Get Resource\n", DRIVER_NAME);
+		ret = -ENODEV;
+		goto out;
+	}
+
+	/* Allocate a memory region for DMAC */
+	if(!request_mem_region(res->start, (res->end - res->start) + 1, DRIVER_NAME)) {
+		printk("%s: Couldn't Get IO mem region for\n", DRIVER_NAME);
+		ret = -ENOMEM;
+		goto out;
+	}
+	
+	/* Remapping for Change with virtual address */
+	dport[i].dmac_base = ioremap(res->start, (res->end - res->start) + 1);
+	if(!dport[i].dmac_base) {
+		printk("%s: Couldn't get virtual io address\n", DRIVER_NAME);
+		ret = -ENOMEM;
+		goto release_mem;
+	}
+
+	dport[i].irq = platform_get_irq(pdev, 0);
+	ret = request_irq(dport[i].irq, s3c6410_dmac_irq, IRQF_SHARED|IRQF_DISABLED, DRIVER_NAME, pdev);
+	if(ret){
+		printk("%s: fail to request_irq() for dmac...\n", DRIVER_NAME);
+		goto free;
+	}	
+
+	printk("%s: Samsung S3C6410 DMA Controller base address at [phy]:0x%x, [virt]:0x%x, irq %d\n", 
+				DRIVER_NAME, res->start, (unsigned int)dport[i].dmac_base, dport[i].irq);
+	DBG("%s: Pass dmac_probe()\n", DRIVER_NAME);
+	return ret;
+
+free:
+	iounmap(dport[i].dmac_base);
+
+release_mem:
+	release_mem_region(res->start, (res->end - res->start) + 1);
+out:
+	return ret;
+}
+
+static int __devexit s3c6410_dmac_remove(struct platform_device *pdev)
+{
+	DBG("%s: Pass dmac_remove\n", DRIVER_NAME);
+	return 0;
+}
+
+static struct platform_driver s3c6410_dmac_driver = {
+	.driver = {
+		.name 	= DRIVER_NAME,
+	},
+	.probe		= s3c6410_dmac_probe,
+	.remove		= __devexit_p(s3c6410_dmac_remove),
+	.suspend	= s3c6410_dmac_suspend,
+	.resume		= s3c6410_dmac_resume,
+};
+
+static int __init s3c6410_dmac_init(void)
+{
+	unsigned long 		 dma_sel = 0;
+	unsigned int  		 i;
+
+	/* Find mapping of DMAC (DMA?, SDMA?) */
+	for(i = 0; i < CONNECTION_DEVICE_NUM; i++) {
+		if(s3c6410_dmac_sel[i].name) {
+			dma_sel |= s3c6410_dmac_sel[i].dma_sel;	
+		}
+	}
+
+	s3c6410_select_dmac(dma_sel);
+
+	return platform_driver_register(&s3c6410_dmac_driver);
+}
+
+static void __exit s3c6410_dmac_exit(void)
+{
+	platform_driver_unregister(&s3c6410_dmac_driver);
+}
+
+MODULE_DESCRIPTION ("Samsung S3C6410 PL080 DMAC Device driver");
+MODULE_LICENSE ("GPL");
+
+module_init(s3c6410_dmac_init);
+module_exit(s3c6410_dmac_exit);
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/dma-pl080-sol.h linux-2.6.29-spica/arch/arm/plat-s3c/dma-pl080-sol.h
--- linux-2.6.29/arch/arm/plat-s3c/dma-pl080-sol.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/dma-pl080-sol.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,24 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+struct s3c6410_dmac_port {
+	struct s3c6410_dmac		*dmac[MAX_DMA_CHANNELS];
+	void __iomem			*dmac_base;
+    unsigned int			irq;
+};
+
+struct s3c6410_dmac {
+    struct platform_device      *pdev;
+    struct dma_data             *dmadata;
+	void						*private_data;
+    spinlock_t                   lock;
+};
+
+#define dmac_readl(x, offset)			readl(dport[x].dmac_base + offset)
+#define dmac_writel(val, x, offset)	writel(val, dport[x].dmac_base + offset)
+
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/dma-pl330.c linux-2.6.29-spica/arch/arm/plat-s3c/dma-pl330.c
--- linux-2.6.29/arch/arm/plat-s3c/dma-pl330.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/dma-pl330.c	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,1487 @@
+/* linux/arch/arm/plat-s3c/dma-pl330.c
+ *
+ * Copyright (c) 2003-2008,2009 Samsung Electronics
+ *
+ * S5PC1XX, S5P6440 DMAC core (PL330 DMAC)
+ *
+ * http://www.samsung.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifdef CONFIG_S3C_DMA_DEBUG
+#define DEBUG
+#endif
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/sysdev.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/dma.h>
+
+#include <plat/regs-clock.h>
+#include <plat/dma.h>
+#include <mach/map.h>
+#include <mach/dma.h>
+
+#include "dma-pl330-mcode.h"
+
+#undef pr_debug		
+//#define dma_dbg
+
+#ifdef dma_dbg
+#define pr_debug(fmt...) printk( fmt)
+#else
+#define pr_debug(fmt...)
+#endif
+
+/* io map for dma */
+static void __iomem 		*dma_base;
+static struct kmem_cache 	*dma_kmem;
+
+static int dma_channels;
+struct s3c_dma_selection 	dma_sel;
+static struct s3c2410_dma_chan *dma_chan_map[DMACH_MAX];
+
+/* dma channel state information */
+struct s3c2410_dma_chan 	s3c_dma_chans[S3C_DMA_CHANNELS];
+s3c_dma_controller_t 		s3c_dma_cntlrs[S3C_DMA_CONTROLLERS];
+
+#define SIZE_OF_MICRO_CODES		512
+#define PL330_NON_SECURE_DMA		1
+#define PL330_SECURE_DMA		0
+
+#define BUF_MAGIC (0xcafebabe)
+
+#define dmawarn(fmt...) printk(KERN_DEBUG fmt)
+
+#define dma_regaddr(dcon, reg) 		((dcon)->regs + (reg))
+#define dma_wrreg(dcon, reg, val) 	writel((val), (dcon)->regs + (reg))
+#define dma_rdreg(dcon, reg) 		readl((dcon)->regs + (reg))
+
+#define dbg_showregs(chan) do { } while(0)
+#define dbg_showchan(chan) do { } while(0)
+
+void s3c_dma_dump(int dcon_num, int channel)
+{
+	unsigned long tmp;
+	s3c_dma_controller_t *dma_controller = &s3c_dma_cntlrs[dcon_num];
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_DS);
+	printk("%d dcon_num %d chnnel : DMA status %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_DPC);
+	printk("%d dcon_num %d chnnel : DMA program counter %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_INTEN);
+	printk("%d dcon_num %d chnnel : INT enable %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_ES);
+	printk("%d dcon_num %d chnnel : Event status %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_INTSTATUS);
+	printk("%d dcon_num %d chnnel : INT status %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_FSC);
+	printk("%d dcon_num %d chnnel : Fault status %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_FTC(channel));
+	printk("%d dcon_num %d chnnel : Fault type %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_CS(channel));
+	printk("%d dcon_num %d chnnel : Channel status %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_CPC(channel));
+	printk("%d dcon_num %d chnnel : Channel program counter %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_SA(channel));
+	printk("%d dcon_num %d chnnel : Source address %lx\n", dcon_num, channel, tmp);
+
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_DA(channel));
+	printk("%d dcon_num %d chnnel : Destination address %lx\n", dcon_num, channel, tmp);
+}
+
+
+/* lookup_dma_channel
+ *
+ * change the dma channel number given into a real dma channel id
+*/
+
+static struct s3c2410_dma_chan *lookup_dma_channel(unsigned int channel)
+{
+	if (channel & DMACH_LOW_LEVEL)
+		return &s3c_dma_chans[channel & ~DMACH_LOW_LEVEL];
+	else
+		return dma_chan_map[channel];
+}
+
+/* s3c_dma_stats_timeout
+ *
+ * Update DMA stats from timeout info
+ */
+static void s3c_dma_stats_timeout(struct s3c_dma_stats * stats, int val)
+{
+	if (stats == NULL)
+		return;
+
+	if (val > stats->timeout_longest)
+		stats->timeout_longest = val;
+	if (val < stats->timeout_shortest)
+		stats->timeout_shortest = val;
+
+	stats->timeout_avg += val;
+}
+
+void s3c_enable_dmac(unsigned int dcon_num)
+{
+	s3c_dma_controller_t *dma_controller = &s3c_dma_cntlrs[dcon_num];
+
+	start_DMA_controller(dma_regaddr(dma_controller, S3C_DMAC_DBGSTATUS));
+}
+
+void s3c_disable_dmac(unsigned int dcon_num)
+{
+	s3c_dma_controller_t *dma_controller = &s3c_dma_cntlrs[dcon_num];
+
+	stop_DMA_controller(dma_regaddr(dma_controller, S3C_DMAC_DBGSTATUS));
+}
+
+void s3c_clear_interrupts (int dcon_num, int channel)
+{
+	unsigned long tmp;
+	s3c_dma_controller_t *dma_controller = &s3c_dma_cntlrs[dcon_num];
+	
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_INTCLR);
+	tmp |= (1 << channel);
+	dma_wrreg(dma_controller, S3C_DMAC_INTCLR, tmp);
+}
+
+/* s3c_dma_waitforload
+ *
+ * wait for the DMA engine to load a buffer, and update the state accordingly
+ */
+static int s3c_dma_waitforload(struct s3c2410_dma_chan *chan, int line)
+{
+	int timeout = chan->load_timeout;
+	int took;
+
+	pr_debug("%s channel number : %d\n", __FUNCTION__, chan->number);
+
+	if (chan->load_state != S3C_DMALOAD_1LOADED) {
+		printk(KERN_ERR
+		       "dma CH %d: s3c_dma_waitforload() called in loadstate %d from line %d\n",
+		       chan->number, chan->load_state, line);
+		return 0;
+	}
+
+	if (chan->stats != NULL)
+		chan->stats->loads++;
+
+	while (--timeout > 0) {
+		//if ((dma_rdreg(chan->dma_con, S3C_DMAC_CS(chan->number))) & S3C_DMAC_CS_EXECUTING) {
+			took = chan->load_timeout - timeout;
+			s3c_dma_stats_timeout(chan->stats, took);
+
+			switch (chan->load_state) {
+			case S3C_DMALOAD_1LOADED:
+				chan->load_state = S3C_DMALOAD_1RUNNING;
+				break;
+
+			default:
+				printk(KERN_ERR
+				       "dma CH %d: unknown load_state in s3c_dma_waitforload() %d\n",
+				       chan->number, chan->load_state);
+			}
+			return 1;
+		//}
+	}
+
+	if (chan->stats != NULL) {
+		chan->stats->timeout_failed++;
+	}
+
+	return 0;
+}
+
+
+/* s3c_dma_loadbuffer
+ *
+ * load a buffer, and update the channel state
+ */
+static inline int s3c_dma_loadbuffer(struct s3c2410_dma_chan *chan,
+		       struct s3c_dma_buf *buf)
+{
+	unsigned long tmp;
+	pl330_DMA_parameters_t dma_param;
+	struct s3c_dma_buf *firstbuf;
+	int bwJump = 0;
+
+	memset(&dma_param, 0, sizeof(pl330_DMA_parameters_t));
+	pr_debug("s3c_chan_loadbuffer: loading buffer %p (0x%08lx,0x%06x)\n",
+		 buf, (unsigned long) buf->data, buf->size);
+
+	if (buf == NULL) {
+		dmawarn("buffer is NULL\n");
+		return -EINVAL;
+	}
+
+	pr_debug("%s: DMA CCR - %08x\n", __FUNCTION__, chan->dcon);
+	pr_debug("%s: DMA Loop count - %08x\n", __FUNCTION__, (buf->size / chan->xfer_unit));
+
+	firstbuf = buf;
+
+	do {
+		dma_param.mPeriNum = chan->config_flags;
+		dma_param.mDirection = chan->source;
+
+		switch (dma_param.mDirection) {
+		case S3C2410_DMASRC_MEM:	/* source is Memory : Mem-to-Peri (Write into FIFO) */
+			dma_param.mSrcAddr = buf->data;
+			dma_param.mDstAddr = chan->dev_addr;
+			break;
+
+		case S3C2410_DMASRC_HW:		/* source is peripheral : Peri-to-Mem (Read from FIFO) */
+			dma_param.mSrcAddr = chan->dev_addr;
+			dma_param.mDstAddr = buf->data;
+			break;
+
+		case S3C_DMA_MEM2MEM:		/* source & Destination : Mem-to-Mem  */
+			dma_param.mSrcAddr = chan->dev_addr;
+			dma_param.mDstAddr = buf->data;
+			break;
+
+		case S3C_DMA_MEM2MEM_SET:		/* source & Destination : Mem-to-Mem  */
+			dma_param.mDirection = S3C_DMA_MEM2MEM;
+			dma_param.mSrcAddr = chan->dev_addr;
+			dma_param.mDstAddr = buf->data;
+			break;
+
+		case S3C_DMA_PER2PER:
+		default:
+			printk("Peripheral-to-Peripheral DMA NOT YET implemented !! \n");
+			return -EINVAL;
+	}
+
+		dma_param.mTrSize = buf->size;
+
+		dma_param.mLoop = 0;
+		dma_param.mControl = *(pl330_DMA_control_t *) &chan->dcon;
+
+		chan->next = buf->next;
+		buf = chan->next;
+
+		if(buf==NULL) {
+			firstbuf->next = NULL;
+			dma_param.mLastReq = 1;
+			dma_param.mIrqEnable = 1;
+		}
+		else {
+			dma_param.mLastReq = 0;
+			dma_param.mIrqEnable = 0;
+	}
+
+		bwJump += setup_DMA_channel(((u8 *)firstbuf->mcptr_cpu)+bwJump, dma_param, chan->number);
+		pr_debug("%s: DMA bwJump - %d\n", __FUNCTION__, bwJump);
+
+	}while(buf != NULL);
+
+	if(dma_param.mIrqEnable) {
+		tmp = dma_rdreg(chan->dma_con, S3C_DMAC_INTEN);
+		tmp |= (1 << chan->number);
+		dma_wrreg(chan->dma_con, S3C_DMAC_INTEN, tmp);
+	}
+
+	/* update the state of the channel */
+
+	switch (chan->load_state) {
+	case S3C_DMALOAD_NONE:
+		chan->load_state = S3C_DMALOAD_1LOADED;
+		break;
+
+	case S3C_DMALOAD_1RUNNING:
+		chan->load_state = S3C_DMALOAD_1LOADED_1RUNNING;
+		break;
+
+	default:
+		dmawarn("dmaload: unknown state %d in loadbuffer\n", chan->load_state);
+		break;
+	}
+
+	return 0;
+}
+
+
+/* s3c_dma_call_op
+ *
+ * small routine to call the o routine with the given op if it has been
+ * registered
+ */
+static void s3c_dma_call_op(struct s3c2410_dma_chan * chan, enum s3c_chan_op op)
+{
+	if (chan->op_fn != NULL) {
+		(chan->op_fn) (chan, op);
+	}
+}
+
+/* s3c_dma_buffdone
+ *
+ * small wrapper to check if callback routine needs to be called, and
+ * if so, call it
+ */
+static inline void s3c_dma_buffdone(struct s3c2410_dma_chan * chan,
+				struct s3c_dma_buf * buf,
+				enum s3c2410_dma_buffresult result)
+{
+	pr_debug("callback_fn will be called=%p, buf=%p, id=%p, size=%d, result=%d\n",
+		 chan->callback_fn, buf, buf->id, buf->size, result);
+
+	if (chan->callback_fn != NULL) {
+		(chan->callback_fn) (chan, buf->id, buf->size, result);
+	}
+}
+
+/* s3c_dma_start
+ *
+ * start a dma channel going
+ */
+static int s3c_dma_start(struct s3c2410_dma_chan *chan)
+{
+	unsigned long flags;
+
+	pr_debug("s3c_start_dma: channel number=%d, index=%d\n", chan->number, chan->index);
+
+	local_irq_save(flags);
+
+	if (chan->state == S3C_DMA_RUNNING) {
+		pr_debug("s3c_start_dma: already running (%d)\n", chan->state);
+		local_irq_restore(flags);
+		return 0;
+	}
+
+	chan->state = S3C_DMA_RUNNING;
+
+	/* check wether there is anything to load, and if not, see
+	 * if we can find anything to load
+	 */
+
+	if (chan->load_state == S3C_DMALOAD_NONE) {
+		if (chan->next == NULL) {
+			printk(KERN_ERR "dma CH %d: dcon_num has nothing loaded\n", chan->number);
+			chan->state = S3C_DMA_IDLE;
+			local_irq_restore(flags);
+			return -EINVAL;
+		}
+		s3c_dma_loadbuffer(chan, chan->next);
+	}
+
+	dbg_showchan(chan);
+
+	/* enable the channel */
+
+	if (!chan->irq_enabled) {
+		enable_irq(chan->irq);
+		chan->irq_enabled = 1;
+	}
+
+	start_DMA_channel(dma_regaddr(chan->dma_con, S3C_DMAC_DBGSTATUS), chan->number,
+					chan->curr->mcptr, PL330_NON_SECURE_DMA);
+
+	/* Start the DMA operation on Peripheral */
+	s3c_dma_call_op(chan, S3C2410_DMAOP_START);
+
+	dbg_showchan(chan);
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+
+/* s3c_dma_canload
+ *
+ * work out if we can queue another buffer into the DMA engine
+ */
+
+
+static int s3c_dma_canload(struct s3c2410_dma_chan * chan)
+{
+	if (chan->load_state == S3C_DMALOAD_NONE || chan->load_state == S3C_DMALOAD_1RUNNING)
+		return 1;
+
+	return 0;
+}
+
+
+
+/* s3c2410_dma_enqueue
+ *
+ * queue an given buffer for dma transfer.
+ *
+ * id         the device driver's id information for this buffer
+ * data       the physical address of the buffer data
+ * size       the size of the buffer in bytes
+ *
+ * If the channel is not running, then the flag S3C2410_DMAF_AUTOSTART
+ * is checked, and if set, the channel is started. If this flag isn't set,
+ * then an error will be returned.
+ *
+ * It is possible to queue more than one DMA buffer onto a channel at
+ * once, and the code will deal with the re-loading of the next buffer
+ * when necessary.
+ */
+int s3c2410_dma_enqueue(unsigned int channel, void *id,
+			dma_addr_t data, int size)
+{
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+	struct s3c_dma_buf *buf;
+	unsigned long flags;
+
+	pr_debug("%s: id=%p, data=%08x, size=%d\n", __FUNCTION__, id, (unsigned int) data, size);
+
+	buf = kmem_cache_alloc(dma_kmem, GFP_ATOMIC);
+	if (buf == NULL) {
+		printk(KERN_ERR "dma<%d> no memory for buffer\n", channel);
+		return -ENOMEM;
+	}
+
+	pr_debug("%s: new buffer %p\n", __FUNCTION__, buf);
+
+	buf->next = NULL;
+	buf->data = buf->ptr = data;
+	buf->size = size;
+	buf->id = id;
+	buf->magic = BUF_MAGIC;
+
+	local_irq_save(flags);
+
+	buf->mcptr_cpu = dma_alloc_coherent(NULL, SIZE_OF_MICRO_CODES, &buf->mcptr, GFP_ATOMIC);
+
+	if (buf->mcptr_cpu == NULL) {
+		printk(KERN_ERR "%s: failed to allocate memory for micro codes\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	if (chan->curr == NULL) {
+		/* we've got nothing loaded... */
+		pr_debug("%s: buffer %p queued onto empty channel\n", __FUNCTION__, buf);
+
+		chan->curr = buf;
+		chan->end = buf;
+		chan->next = NULL;
+	} else {
+		pr_debug("dma CH %d: %s: buffer %p queued onto non-empty channel\n",
+			 chan->number, __FUNCTION__, buf);
+
+		if (chan->end == NULL)   /* In case of flushing */
+			pr_debug("dma CH %d: %s: %p not empty, and chan->end==NULL?\n",
+				 chan->number, __FUNCTION__, chan);
+		else {
+			chan->end->next = buf;
+			chan->end = buf;
+		}
+	}
+
+	/* if necessary, update the next buffer field */
+	if (chan->next == NULL)
+		chan->next = buf;
+
+	/* check to see if we can load a buffer */
+	if (chan->state == S3C_DMA_RUNNING) {
+		if (chan->load_state == S3C_DMALOAD_1LOADED && 1) {
+			if (s3c_dma_waitforload(chan, __LINE__) == 0) {
+				printk(KERN_ERR "dma CH %d: loadbuffer:"
+				       "timeout loading buffer\n", chan->number);
+				dbg_showchan(chan);
+				local_irq_restore(flags);
+				return -EINVAL;
+			}
+		}
+
+	} else if (chan->state == S3C_DMA_IDLE) {
+		if (chan->flags & S3C2410_DMAF_AUTOSTART) {
+			s3c2410_dma_ctrl(channel, S3C2410_DMAOP_START);
+		} else {
+			pr_debug("loading onto stopped channel\n");
+		}
+	}
+
+	local_irq_restore(flags);
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_enqueue);
+
+static inline void s3c_dma_freebuf(struct s3c_dma_buf * buf)
+{
+	int magicok = (buf->magic == BUF_MAGIC);
+
+	buf->magic = -1;
+
+	if (magicok) {
+		local_irq_enable();
+		dma_free_coherent(NULL, SIZE_OF_MICRO_CODES, buf->mcptr_cpu, buf->mcptr);
+		local_irq_disable();
+		
+		kmem_cache_free(dma_kmem, buf);
+	} else {
+		printk("s3c_dma_freebuf: buff %p with bad magic\n", buf);
+	}
+}
+
+/* s3c_dma_lastxfer
+ *
+ * called when the system is out of buffers, to ensure that the channel
+ * is prepared for shutdown.
+ */
+static inline void s3c_dma_lastxfer(struct s3c2410_dma_chan *chan)
+{
+	pr_debug("DMA CH %d: s3c_dma_lastxfer: load_state %d\n", chan->number, chan->load_state);
+	
+	switch (chan->load_state) {
+	case S3C_DMALOAD_NONE:
+		pr_debug("DMA CH %d: s3c_dma_lastxfer: load_state : S3C2410_DMALOAD_NONE%d\n", chan->number);
+		break;
+
+	case S3C_DMALOAD_1LOADED:
+		if (s3c_dma_waitforload(chan, __LINE__) == 0) {
+			/* flag error? */
+			printk(KERN_ERR "dma CH %d: timeout waiting for load\n", chan->number);
+			return;
+		}
+		break;
+
+	default:
+		pr_debug("dma CH %d: lastxfer: unhandled load_state %d with no next",
+			 chan->number, chan->load_state);
+		return;
+
+	}
+
+}
+
+
+#define dmadbg2(x...)
+
+static irqreturn_t s3c_dma_irq(int irq, void *devpw)
+{
+	unsigned int channel = 0, dcon_num, i;
+	unsigned long tmp;
+	s3c_dma_controller_t *dma_controller = (s3c_dma_controller_t *) devpw;
+	
+	struct s3c2410_dma_chan *chan=NULL;
+	struct s3c_dma_buf *buf;
+
+	dcon_num = dma_controller->number;
+	tmp = dma_rdreg(dma_controller, S3C_DMAC_INTSTATUS);
+	pr_debug("# s3c_dma_irq: IRQ status : 0x%x\n", tmp);
+
+	for (i = 0; i < S3C_CHANNELS_PER_DMA; i++) {
+		if (tmp & 0x01) {
+
+			pr_debug("# DMAC %d: requestor %d\n", dcon_num, i);
+			
+			channel = i;
+			chan = &s3c_dma_chans[channel + dcon_num * S3C_CHANNELS_PER_DMA];
+			pr_debug("# DMA CH:%d, index:%d load_state:%d\n", chan->number, chan->index, chan->load_state);
+			
+			buf = chan->curr;
+			
+			dbg_showchan(chan);
+
+			/* modify the channel state */
+			switch (chan->load_state) {
+			case S3C_DMALOAD_1RUNNING:
+				/* TODO - if we are running only one buffer, we probably
+				 * want to reload here, and then worry about the buffer
+				 * callback */
+
+				chan->load_state = S3C_DMALOAD_NONE;
+				break;
+
+			case S3C_DMALOAD_1LOADED:
+				/* iirc, we should go back to NONE loaded here, we
+				 * had a buffer, and it was never verified as being
+				 * loaded.
+				 */
+
+				chan->load_state = S3C_DMALOAD_NONE;
+				break;
+
+			case S3C_DMALOAD_1LOADED_1RUNNING:
+				/* we'll worry about checking to see if another buffer is
+				 * ready after we've called back the owner. This should
+				 * ensure we do not wait around too long for the DMA
+				 * engine to start the next transfer
+				 */
+
+				chan->load_state = S3C_DMALOAD_1LOADED;
+				break;
+
+			case S3C_DMALOAD_NONE:
+				printk(KERN_ERR "dma%d: IRQ with no loaded buffer?\n",
+				       chan->number);
+				break;
+
+			default:
+				printk(KERN_ERR "dma%d: IRQ in invalid load_state %d\n",
+				       chan->number, chan->load_state);
+				break;
+			}
+
+			if (buf != NULL) {
+				/* update the chain to make sure that if we load any more
+				 * buffers when we call the callback function, things should
+				 * work properly */
+
+				chan->curr = buf->next;
+				buf->next = NULL;
+
+				if (buf->magic != BUF_MAGIC) {
+					printk(KERN_ERR "dma CH %d: %s: buf %p incorrect magic\n",
+					       chan->number, __FUNCTION__, buf);
+					goto next_channel;
+				}
+
+				s3c_dma_buffdone(chan, buf, S3C2410_RES_OK);
+
+				/* free resouces */
+				s3c_dma_freebuf(buf);
+			} else {
+			}
+			
+			/* only reload if the channel is still running... our buffer done
+	 		* routine may have altered the state by requesting the dma channel
+			* to stop or shutdown... */
+
+			if (chan->next != NULL && chan->state != S3C_DMA_IDLE) {
+				unsigned long flags;
+
+				switch (chan->load_state) {
+				case S3C_DMALOAD_1RUNNING:
+					/* don't need to do anything for this state */
+					break;
+
+				case S3C_DMALOAD_NONE:
+					/* can load buffer immediately */
+					break;
+
+				case S3C_DMALOAD_1LOADED:
+					if (s3c_dma_waitforload(chan, __LINE__) == 0) {
+						/* flag error? */
+						printk(KERN_ERR "dma CH %d: timeout waiting for load\n",
+						       chan->number);
+						goto next_channel;
+					}
+
+					break;
+
+				case S3C_DMALOAD_1LOADED_1RUNNING:
+					goto next_channel;
+
+				default:
+					printk(KERN_ERR "dma CH %d: unknown load_state in irq, %d\n",
+					       chan->number, chan->load_state);
+					goto next_channel;
+				}
+
+				local_irq_save(flags);
+				s3c_dma_loadbuffer(chan, chan->next);
+				start_DMA_channel(dma_regaddr(chan->dma_con, S3C_DMAC_DBGSTATUS), chan->number,
+								chan->curr->mcptr, PL330_NON_SECURE_DMA);
+				
+				local_irq_restore(flags);
+				
+			} else {
+				s3c_dma_lastxfer(chan);
+				
+				/* see if we can stop this channel.. */
+				if (chan->load_state == S3C_DMALOAD_NONE) {
+					pr_debug("# DMA CH %d - (index:%d): end of transfer, stopping channel (%ld)\n",
+						 chan->number, chan->index, jiffies);
+					s3c2410_dma_ctrl(chan->index | DMACH_LOW_LEVEL, S3C2410_DMAOP_STOP);
+				}
+			}
+		}
+
+next_channel:
+		tmp >>= 1;
+
+	}
+
+	s3c_clear_interrupts(chan->dma_con->number, chan->number);
+	
+	return IRQ_HANDLED;
+}
+
+static struct s3c2410_dma_chan *s3c_dma_map_channel(int channel);
+
+/* s3c2410_dma_request
+ *
+ * get control of an dma channel
+*/
+
+int s3c2410_dma_request(unsigned int channel,
+			struct s3c2410_dma_client *client,
+			void *dev)
+{
+	struct s3c2410_dma_chan *chan;
+	unsigned long flags;
+	int err;
+
+	pr_debug("DMA CH %d: s3c2410_request_dma: client=%s, dev=%p\n",
+		 channel, client->name, dev);
+
+	local_irq_save(flags);
+
+	chan = s3c_dma_map_channel(channel);
+	if (chan == NULL) {
+		local_irq_restore(flags);
+		return -EBUSY;
+	}
+
+	dbg_showchan(chan);
+
+	chan->client = client;
+	chan->in_use = 1;
+
+	chan->dma_con->in_use++;
+
+	if (!chan->irq_claimed) {
+		pr_debug("DMA CH %d: %s : requesting irq %d\n",
+			 channel, __FUNCTION__, chan->irq);
+
+		chan->irq_claimed = 1;
+		local_irq_restore(flags);
+
+		err = request_irq(chan->irq, s3c_dma_irq, IRQF_DISABLED,
+				  client->name, (void *) chan->dma_con);
+
+		local_irq_save(flags);
+
+		if (err) {
+			chan->in_use = 0;
+			chan->irq_claimed = 0;
+			chan->dma_con->in_use--;
+			local_irq_restore(flags);
+
+			printk(KERN_ERR "%s: cannot get IRQ %d for DMA %d\n",
+			       client->name, chan->irq, chan->number);
+			return err;
+		}
+
+		chan->irq_enabled = 1;
+		
+		/* enable the main dma.. this can be disabled
+		 * when main channel use count is 0 */
+		s3c_enable_dmac(chan->dma_con->number);
+	}
+	
+	s3c_clear_interrupts(chan->dma_con->number, chan->number);
+	local_irq_restore(flags);
+
+	/* need to setup */
+
+	pr_debug("%s: channel initialised, %p, number:%d, index:%d\n", __FUNCTION__, chan, chan->number, chan->index);
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_request);
+
+/* s3c2410_dma_free
+ *
+ * release the given channel back to the system, will stop and flush
+ * any outstanding transfers, and ensure the channel is ready for the
+ * next claimant.
+ *
+ * Note, although a warning is currently printed if the freeing client
+ * info is not the same as the registrant's client info, the free is still
+ * allowed to go through.
+ */
+int s3c2410_dma_free(dmach_t channel, struct s3c2410_dma_client *client)
+{
+	unsigned long flags;
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+	pr_debug("%s: DMA channel %d will be stopped\n", __FUNCTION__, chan->number);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	if (chan->client != client) {
+		printk(KERN_WARNING
+		       "DMA CH %d: possible free from different client (channel %p, passed %p)\n",
+		       channel, chan->client, client);
+	}
+
+	/* sort out stopping and freeing the channel */
+
+	if (chan->state != S3C_DMA_IDLE) {
+		pr_debug("%s: need to stop dma channel %p\n", __FUNCTION__, chan);
+
+		/* possibly flush the channel */
+		s3c2410_dma_ctrl(channel, S3C2410_DMAOP_STOP);
+	}
+
+	chan->client = NULL;
+	chan->in_use = 0;
+	
+	chan->dma_con->in_use--;
+
+	if (chan->irq_claimed)
+		free_irq(chan->irq, (void *)chan->dma_con);
+
+	chan->irq_claimed = 0;
+
+	if (!(channel & DMACH_LOW_LEVEL))
+		dma_chan_map[channel] = NULL;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_free);
+
+
+static int s3c_dma_dostop(struct s3c2410_dma_chan *chan) 
+{
+	unsigned long flags;
+
+	pr_debug("%s: DMA Channel No : %d\n", __FUNCTION__, chan->number);
+
+	dbg_showchan(chan);
+
+	local_irq_save(flags);
+
+	s3c_dma_call_op(chan, S3C2410_DMAOP_STOP);
+
+	stop_DMA_channel(dma_regaddr(chan->dma_con, S3C_DMAC_DBGSTATUS), chan->number);
+	
+	chan->state = S3C_DMA_IDLE;
+	chan->load_state = S3C_DMALOAD_NONE;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static void s3c_dma_showchan(struct s3c2410_dma_chan * chan)
+{
+
+}
+
+/* s3c_dma_flush
+ *
+ * stop the channel, and remove all current and pending transfers
+ */
+
+void s3c_waitforstop(struct s3c2410_dma_chan *chan)
+{
+
+}
+
+static int s3c_dma_flush(struct s3c2410_dma_chan *chan)
+{
+	struct s3c_dma_buf *buf, *next;
+	unsigned long flags;
+
+	pr_debug("%s:\n", __FUNCTION__);
+
+	local_irq_save(flags);
+
+	s3c_dma_showchan(chan);
+
+	if (chan->state != S3C_DMA_IDLE) {
+		pr_debug("%s: stopping channel...\n", __FUNCTION__);
+		s3c2410_dma_ctrl(chan->number, S3C2410_DMAOP_STOP);
+	}
+
+	buf = chan->curr;
+	if (buf == NULL)
+		buf = chan->next;
+
+	chan->curr = chan->next = chan->end = NULL;
+	chan->load_state = S3C_DMALOAD_NONE;
+
+	if (buf != NULL) {
+		for (; buf != NULL; buf = next) {
+			next = buf->next;
+
+			pr_debug("%s: free buffer %p, next %p\n", __FUNCTION__, buf, buf->next);
+
+			s3c_dma_buffdone(chan, buf, S3C2410_RES_ABORT);
+			s3c_dma_freebuf(buf);
+		}
+	}
+	//s3c_dma_waitforstop(chan);
+	
+	s3c_dma_showchan(chan);
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+int s3c_dma_started(struct s3c2410_dma_chan *chan)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	dbg_showchan(chan);
+
+	/* if we've only loaded one buffer onto the channel, then chec
+	 * to see if we have another, and if so, try and load it so when
+	 * the first buffer is finished, the new one will be loaded onto
+	 * the channel */
+
+	if (chan->next != NULL) {
+		if (chan->load_state == S3C_DMALOAD_1LOADED) {
+
+			if (s3c_dma_waitforload(chan, __LINE__) == 0) {
+				pr_debug("%s: buff not yet loaded, no more todo\n",
+					 __FUNCTION__);
+			} else {
+				chan->load_state = S3C_DMALOAD_1RUNNING;
+				s3c_dma_loadbuffer(chan, chan->next);
+			}
+
+		} else if (chan->load_state == S3C_DMALOAD_1RUNNING) {
+			s3c_dma_loadbuffer(chan, chan->next);
+		}
+	}
+
+	local_irq_restore(flags);
+
+	return 0;
+
+}
+
+int s3c2410_dma_ctrl(dmach_t channel, enum s3c_chan_op op)
+{
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	switch (op) {
+	case S3C2410_DMAOP_START:
+		return s3c_dma_start(chan);
+
+	case S3C2410_DMAOP_STOP:
+		return s3c_dma_dostop(chan);
+
+	case S3C2410_DMAOP_PAUSE:
+	case S3C2410_DMAOP_RESUME:
+		return -ENOENT;
+
+	case S3C2410_DMAOP_FLUSH:
+		return s3c_dma_flush(chan);
+
+	case S3C2410_DMAOP_STARTED:
+		return s3c_dma_started(chan);
+
+	case S3C2410_DMAOP_TIMEOUT:
+		return 0;
+
+	}
+
+	printk("Invalid operation entered \n");
+	return -ENOENT;      /* unknown, don't bother */
+}
+EXPORT_SYMBOL(s3c2410_dma_ctrl);
+
+
+/* s3c2410_dma_config
+ *
+ * xfersize:     size of unit in bytes (1,2,4)
+ * dcon:         base value of the DCONx register
+ */
+int s3c2410_dma_config(dmach_t channel,
+		       int xferunit,
+		       int dcon)
+{
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	pr_debug("%s: chan=%d, xfer_unit=%d, dcon=%08x\n",
+		 __FUNCTION__, channel, xferunit, dcon);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: Initial dcon is %08x\n", __FUNCTION__, dcon);
+
+	dcon |= chan->dcon & dma_sel.dcon_mask;
+
+	pr_debug("%s: New dcon is %08x\n", __FUNCTION__, dcon);
+	
+	switch (xferunit) {
+	case 1:
+		dcon |= S3C_DMACONTROL_SRC_WIDTH_BYTE;
+		dcon |= S3C_DMACONTROL_DEST_WIDTH_BYTE;
+		break;
+
+	case 2:
+		dcon |= S3C_DMACONTROL_SRC_WIDTH_HWORD;
+		dcon |= S3C_DMACONTROL_DEST_WIDTH_HWORD;
+		break;
+
+	case 4:
+		dcon |= S3C_DMACONTROL_SRC_WIDTH_WORD;
+		dcon |= S3C_DMACONTROL_DEST_WIDTH_WORD;
+		break;
+
+	case 8:
+		dcon |= S3C_DMACONTROL_SRC_WIDTH_DWORD;
+		dcon |= S3C_DMACONTROL_DEST_WIDTH_DWORD;
+		break;
+
+	default:
+		printk("%s: Bad transfer size %d\n", __FUNCTION__, xferunit);
+		return -EINVAL;
+	}
+
+	pr_debug("%s: DMA Channel control :  %08x\n", __FUNCTION__, dcon);
+
+	dcon |= chan->control_flags;
+	pr_debug("%s: dcon now %08x\n", __FUNCTION__, dcon);
+
+	/* For DMCCxControl 0 */
+	chan->dcon = dcon;
+
+	/* For DMACCxControl 1 : xferunit means transfer width.*/
+	chan->xfer_unit = xferunit;
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_config);
+
+int s3c2410_dma_setflags(dmach_t channel, unsigned int flags)
+{
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: chan=%p, flags=%08x\n", __FUNCTION__, chan, flags);
+
+	chan->flags = flags;
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_setflags);
+
+
+/* do we need to protect the settings of the fields from
+ * irq?
+ */
+
+int s3c2410_dma_set_opfn(dmach_t channel, s3c2410_dma_opfn_t rtn)
+{
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: chan=%p, op rtn=%p\n", __FUNCTION__, chan, rtn);
+
+	chan->op_fn = rtn;
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_set_opfn);
+
+
+int s3c2410_dma_set_buffdone_fn(dmach_t channel, s3c2410_dma_cbfn_t rtn)
+{
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: chan=%p, callback rtn=%p\n", __FUNCTION__, chan, rtn);
+
+	chan->callback_fn = rtn;
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_set_buffdone_fn);
+
+
+/* s3c2410_dma_devconfig
+ *
+ * configure the dma source/destination hardware type and address
+ *
+ * flowctrl: direction of dma flow
+ *
+ * src_per dst_per: dma channel number of src and dst periphreal,
+ *
+ * devaddr:   physical address of the source
+ */
+
+int s3c2410_dma_devconfig(int channel,
+			  enum s3c2410_dmasrc source,
+			  int hwcfg,
+			  unsigned long devaddr)
+{
+
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: source=%d, hwcfg=%08x, devaddr=%08lx\n",
+		 __FUNCTION__, (int)source, hwcfg, devaddr);
+
+	chan->source = source;
+	chan->dev_addr = devaddr;
+
+	switch (source) {
+	case S3C2410_DMASRC_MEM:
+		/* source is Memory : Mem-to-Peri ( Write into FIFO) */
+		chan->config_flags = chan->map->hw_addr.to;
+		
+		hwcfg = S3C_DMACONTROL_DBSIZE(1)|S3C_DMACONTROL_SBSIZE(1);
+		chan->control_flags = S3C_DMACONTROL_DP_NON_SECURE|S3C_DMACONTROL_DEST_FIXED|
+				      S3C_DMACONTROL_SP_NON_SECURE|S3C_DMACONTROL_SRC_INC|
+				      hwcfg;
+		//chan->control_flags = hwcfg;
+		return 0;
+
+	case S3C2410_DMASRC_HW:
+		/* source is peripheral : Peri-to-Mem ( Read from FIFO) */
+		chan->config_flags = chan->map->hw_addr.from;
+		
+		hwcfg = S3C_DMACONTROL_DBSIZE(1)|S3C_DMACONTROL_SBSIZE(1);
+		chan->control_flags = S3C_DMACONTROL_DP_NON_SECURE|S3C_DMACONTROL_DEST_INC|
+				      S3C_DMACONTROL_SP_NON_SECURE|S3C_DMACONTROL_SRC_FIXED|
+				      hwcfg;
+		//chan->control_flags = hwcfg;
+		return 0;
+
+	case S3C_DMA_MEM2MEM:
+
+		chan->config_flags = 0;
+		
+		hwcfg = S3C_DMACONTROL_DBSIZE(16)|S3C_DMACONTROL_SBSIZE(16);
+		chan->control_flags = S3C_DMACONTROL_DP_NON_SECURE|S3C_DMACONTROL_DEST_INC|
+				      S3C_DMACONTROL_SP_NON_SECURE|S3C_DMACONTROL_SRC_INC|
+				      hwcfg;
+		//chan->control_flags = hwcfg;
+		return 0;
+
+	case S3C_DMA_MEM2MEM_SET:
+
+		chan->config_flags = 0;
+
+		hwcfg = S3C_DMACONTROL_DBSIZE(16)|S3C_DMACONTROL_SBSIZE(16);
+		chan->control_flags = S3C_DMACONTROL_DP_NON_SECURE|S3C_DMACONTROL_DEST_INC|
+				      S3C_DMACONTROL_SP_NON_SECURE|S3C_DMACONTROL_SRC_FIXED|
+				      hwcfg;
+		//chan->control_flags = hwcfg;
+		return 0;
+
+
+	case S3C_DMA_PER2PER:
+		printk("Peripheral-to-Peripheral DMA NOT YET implemented !! \n");
+		return -EINVAL;
+
+	default:
+		printk(KERN_ERR "DMA CH :%d - invalid source type ()\n", channel);
+		printk("Unsupported DMA configuration from the device driver using DMA driver \n");
+		return -EINVAL;
+	}
+	
+}
+
+EXPORT_SYMBOL(s3c2410_dma_devconfig);
+
+
+/* 
+ * s3c2410_dma_getposition
+ * returns the current transfer points for the dma source and destination
+ */
+int s3c2410_dma_getposition(dmach_t channel, dma_addr_t *src, dma_addr_t *dst)
+{
+ 	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	if (src != NULL)
+ 		*src = dma_rdreg(chan->dma_con, S3C_DMAC_SA(chan->number));
+	
+ 	if (dst != NULL)
+ 		*dst = dma_rdreg(chan->dma_con, S3C_DMAC_DA(chan->number));
+
+ 	return 0;
+}
+
+EXPORT_SYMBOL(s3c2410_dma_getposition);
+
+
+/* system device class */
+#ifdef CONFIG_PM
+static int s3c_dma_suspend (struct sys_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+static int s3c_dma_resume (struct sys_device *dev)
+{
+	return 0;
+}
+#else
+#define s3c_dma_suspend NULL
+#define s3c_dma_resume  NULL
+#endif				/* CONFIG_PM */
+
+struct sysdev_class dma_sysclass = {
+	.name = "pl330-dma",
+	.suspend = s3c_dma_suspend,
+	.resume = s3c_dma_resume,
+};
+
+/* kmem cache implementation */
+
+static void s3c_dma_cache_ctor(void *p)
+{
+	memset(p, 0, sizeof(struct s3c_dma_buf));
+}
+
+
+/* initialisation code */
+
+int __init s3c_dma_init(unsigned int channels, unsigned int irq,
+			    unsigned int stride)
+{
+	struct s3c2410_dma_chan *cp;
+	s3c_dma_controller_t *dconp;
+	int channel, controller;
+	int ret;
+
+	printk("S3C PL330-DMA Controller Driver, (c) 2008-2009 Samsung Electronics\n");
+
+	dma_channels = channels;
+	printk("Total %d DMA channels will be initialized.\n", channels);
+
+	ret = sysdev_class_register(&dma_sysclass);
+	if (ret != 0) {
+		printk(KERN_ERR "dma sysclass registration failed.\n");
+		goto err;
+	}
+
+	dma_kmem = kmem_cache_create("dma_desc",
+				     sizeof(struct s3c_dma_buf), 0,
+				     SLAB_HWCACHE_ALIGN,
+				     s3c_dma_cache_ctor);
+
+	if (dma_kmem == NULL) {
+		printk(KERN_ERR "DMA failed to make kmem cache for DMA channel descriptor\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	for (controller = 0; controller < S3C_DMA_CONTROLLERS; controller++) {
+		dconp = &s3c_dma_cntlrs[controller];
+
+		memset(dconp, 0, sizeof(s3c_dma_controller_t));
+
+		if(controller == 0) {
+			dma_base = ioremap(S3C_PA_DMA, stride);
+			if (dma_base == NULL) {
+				printk(KERN_ERR "M2M-DMA failed to ioremap register block\n");
+				return -ENOMEM;
+			}
+
+			/* dma controller's irqs are in order.. */
+			dconp->irq = controller + irq;
+		}
+		else {
+			dma_base = ioremap(((S3C_PA_DMA + 0xF00000) + ((controller-1) * 0x200000)), stride);
+			if (dma_base == NULL) {
+				printk(KERN_ERR "Peri-DMA failed to ioremap register block\n");
+				return -ENOMEM;
+			}
+
+			/* dma controller's irqs are in order.. */
+			dconp->irq = controller + irq;
+		}
+		
+		dconp->number = controller;
+		dconp->regs = dma_base;
+		pr_debug("PL330 DMA controller : %d irq %d regs_base %x\n", dconp->number, dconp->irq,
+			  dconp->regs);
+	}
+
+	for (channel = 0; channel < channels; channel++) {
+		controller = channel / S3C_CHANNELS_PER_DMA;
+		cp = &s3c_dma_chans[channel];
+
+		memset(cp, 0, sizeof(struct s3c2410_dma_chan));
+
+		cp->dma_con = &s3c_dma_cntlrs[controller];
+		
+		/* dma channel irqs are in order.. */
+		cp->index = channel;
+		cp->number = channel%S3C_CHANNELS_PER_DMA;
+		
+		cp->irq = s3c_dma_cntlrs[controller].irq;
+		
+		cp->regs = s3c_dma_cntlrs[controller].regs;
+
+		/* point current stats somewhere */
+		cp->stats = &cp->stats_store;
+		cp->stats_store.timeout_shortest = LONG_MAX;
+
+		/* basic channel configuration */
+		cp->load_timeout = 1 << 18;
+
+		/* register system device */
+		cp->dev.cls = &dma_sysclass;
+		cp->dev.id = channel;
+
+		pr_debug("DMA channel %d at %p, irq %d\n", cp->number, cp->regs, cp->irq);
+	}
+
+	return 0;
+err:
+	kmem_cache_destroy(dma_kmem);
+	iounmap(dma_base);
+	dma_base = NULL;
+	return ret;
+}
+
+
+
+static inline int is_channel_valid(unsigned int channel)
+{
+	return (channel & DMA_CH_VALID);
+}
+
+static struct s3c_dma_order *dma_order;
+
+
+/* s3c_dma_map_channel()
+ *
+ * turn the virtual channel number into a real, and un-used hardware
+ * channel.
+ *
+ * first, try the dma ordering given to us by either the relevant
+ * dma code, or the board. Then just find the first usable free
+ * channel
+*/
+
+struct s3c2410_dma_chan *s3c_dma_map_channel(int channel)
+{
+	struct s3c_dma_order_ch *ord = NULL;
+	struct s3c_dma_map *ch_map;
+	struct s3c2410_dma_chan *dmach;
+	int ch;
+
+	if (dma_sel.map == NULL || channel > dma_sel.map_size)
+		return NULL;
+
+	ch_map = dma_sel.map + channel;
+
+	/* first, try the board mapping */
+
+	if (dma_order) {
+		ord = &dma_order->channels[channel];
+
+		for (ch = 0; ch < dma_channels; ch++) {
+			if (!is_channel_valid(ord->list[ch]))
+				continue;
+
+			if (s3c_dma_chans[ord->list[ch]].in_use == 0) {
+				ch = ord->list[ch] & ~DMA_CH_VALID;
+				goto found;
+			}
+		}
+
+		if (ord->flags & DMA_CH_NEVER)
+			return NULL;
+	}
+
+	/* second, search the channel map for first free */
+
+	for (ch = 0; ch < dma_channels; ch++) {
+		if (!is_channel_valid(ch_map->channels[ch]))
+			continue;
+
+		if (s3c_dma_chans[ch].in_use == 0) {
+			pr_debug("mapped channel %d to %d\n", channel, ch);
+			break;
+		}
+	}
+
+	if (ch >= dma_channels)
+		return NULL;
+
+	/* update our channel mapping */
+
+ found:
+	dmach = &s3c_dma_chans[ch];
+	dma_chan_map[channel] = dmach;
+
+	/* select the channel */
+	(dma_sel.select)(dmach, ch_map);
+
+	return dmach;
+}
+
+static int s3c_dma_check_entry(struct s3c_dma_map *map, int ch)
+{
+	return 0;
+}
+
+int __init s3c_dma_init_map(struct s3c_dma_selection *sel)
+{
+	struct s3c_dma_map *nmap;
+	size_t map_sz = sizeof(*nmap) * sel->map_size;
+	int ptr;
+
+	nmap = kmalloc(map_sz, GFP_KERNEL);
+	if (nmap == NULL)
+		return -ENOMEM;
+
+	memcpy(nmap, sel->map, map_sz);
+	memcpy(&dma_sel, sel, sizeof(*sel));
+
+	dma_sel.map = nmap;
+
+	for (ptr = 0; ptr < sel->map_size; ptr++)
+		s3c_dma_check_entry(nmap+ptr, ptr);
+
+	return 0;
+}
+
+int __init s3c_dma_order_set(struct s3c_dma_order *ord)
+{
+	struct s3c_dma_order *nord = dma_order;
+
+	if (nord == NULL)
+		nord = kmalloc(sizeof(struct s3c_dma_order), GFP_KERNEL);
+
+	if (nord == NULL) {
+		printk(KERN_ERR "no memory to store dma channel order\n");
+		return -ENOMEM;
+	}
+
+	dma_order = nord;
+	memcpy(nord, ord, sizeof(struct s3c_dma_order));
+	return 0;
+}
+
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/dma-pl330-mcode.h linux-2.6.29-spica/arch/arm/plat-s3c/dma-pl330-mcode.h
--- linux-2.6.29/arch/arm/plat-s3c/dma-pl330-mcode.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/dma-pl330-mcode.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,1145 @@
+/* linux/arch/arm/plat-s3c/dma-pl330-mcode.h
+ *
+ * DMA PL330 microcode
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*------------------------------------------------------*/
+/*	Version : v1.1					*/
+/*	Date last updated : Dec. 10, 2008		*/
+/*------------------------------------------------------*/
+
+
+#define	PL330_DMA_DEBUG
+#undef	PL330_DMA_DEBUG
+
+#ifdef PL330_DMA_DEBUG
+#define dma_debug(fmt...) 		printk( fmt)
+#else
+#define dma_debug(fmt...)
+#endif
+
+#define print_warning(fmt...) 		printk( fmt)
+
+#define PL330_P2M_DMA			0
+#define PL330_M2P_DMA			1
+#define PL330_M2M_DMA			2
+#define PL330_P2P_DMA			3
+
+#define	PL330_MAX_ITERATION_NUM		256
+#define	PL330_MAX_JUMPBACK_NUM		256
+#define	PL330_MAX_EVENT_NUM		32
+#define	PL330_MAX_PERIPHERAL_NUM	32
+#define	PL330_MAX_CHANNEL_NUM		8
+
+#define DMA_DBGSTATUS			0x0
+#define DMA_DBGCMD			0x1
+#define DMA_DBGINST0			0x2
+#define DMA_DBGINST1			0x3
+
+#define memOutp8(addr, data) 		(*(volatile u8 *)(addr) = (data))
+#define Outp32(addr, data)		(*(volatile u32 *)(addr) = (data))
+#define Inp32(addr)			(*(volatile u32 *)(addr))
+
+
+/* Parameter set for Channel Control Register */
+typedef struct DMA_control
+{
+	unsigned uSI			:1 ;	/* [0] Transfer size not count		*/
+	unsigned uSBSize		:3 ;	/* [3:1] Source 1 transfer size		*/
+	unsigned uSBLength		:4 ;	/* [7:4] Sourse burst len		*/
+	unsigned uSProt			:3 ;	/* [10:8] Source Protection set 101b=5	*/
+	unsigned uSCache		:3 ;	/* [13:11] Source Cache control		*/
+	unsigned uDI 			:1 ;	/* [14] Destination increment		*/
+	unsigned uDBSize		:3 ;	/* [17:15] Destination 1 transfer size	*/
+	unsigned uDBLength		:4 ;	/* [21:18] Destination burst len	*/
+	unsigned uDProt			:3 ;	/* [24:22] Source Protection set 101b=5	*/
+	unsigned uDCache		:3 ;	/* [27:25] Source Cache control		*/
+	unsigned uESSize		:4 ;	/* [31:28] endian_swap_size		*/
+} pl330_DMA_control_t;
+
+
+/* Parameter list for a DMA operation */
+typedef struct DMA_parameters
+{
+	unsigned long			mDirection;	/* DMA direction */
+	unsigned long			mPeriNum;	/* DMA Peripheral number */
+	unsigned long			mSrcAddr;	/* DMA source address */
+	unsigned long			mDstAddr;	/* DMA destination address */
+	unsigned long			mTrSize;	/* DMA Transfer size */
+	pl330_DMA_control_t		mControl;	/* DMA control */
+	unsigned long			mIrqEnable;	/* DMA Send IRQ */
+	unsigned long			mLoop;		/* DMA Infinite Loop - 0(off) */
+	unsigned long			mBwJump;	/* DMA backward relative offset */
+	unsigned long			mLastReq;	/* The last DMA Req.  */
+} pl330_DMA_parameters_t;
+
+
+static void print_dma_param_info(pl330_DMA_parameters_t dma_param)
+{
+	/* Parameter list for a DMA operation */
+	dma_debug("	mDirection = %lu\n", dma_param.mDirection);
+	dma_debug("	mPeriNum = %lu\n", dma_param.mPeriNum);
+	dma_debug("	mSrcAddr = 0x%x\n", dma_param.mSrcAddr);
+	dma_debug("	mDstAddr = 0x%x\n", dma_param.mDstAddr);
+	dma_debug("	mTrSize = %lu\n", dma_param.mTrSize);
+	dma_debug("	mControl = 0x%x\n", dma_param.mControl);
+	dma_debug("	mIrqEnable = %lu\n", dma_param.mIrqEnable);
+	dma_debug("	mLoop = %lu\n", dma_param.mLoop);
+	dma_debug("	mBwJump = %lu\n", dma_param.mBwJump);
+	dma_debug("	mLastReq = %lu\n", dma_param.mLastReq);
+}
+
+/*---------------------- Primitive functions -------------*/
+/* When the DMAC is operating in real-time then you can only issue a limited subset of instructions as follows:
+ * DMAGO starts a DMA transaction using a DMA channel that you specify.
+ * DMASEV signals the occurrence of an event, or interrupt, using an event number that you specify.
+ * DMAKILL terminates a thread.
+
+ * Prior to issuing DMAGO, you must ensure that the system memory contains a suitable
+ * program for the DMAC to execute, starting at the address that the DMAGO specifies.
+ */
+
+/* DMAMOV CCR, ...  */
+static int encodeDmaMoveChCtrl(u8 * mcode_ptr, u32 dmacon)
+{
+	u8 uInsBytes[6];
+	u32 i;
+
+	uInsBytes[0] = (u8)(0xbc);
+	uInsBytes[1] = (u8)(0x1);
+	uInsBytes[2] = (u8)((dmacon>>0)&0xff);
+	uInsBytes[3] = (u8)((dmacon>>8)&0xff);
+	uInsBytes[4] = (u8)((dmacon>>16)&0xff);
+	uInsBytes[5] = (u8)((dmacon>>24)&0xff);
+
+	for(i=0; i<6; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 6;
+}
+
+/* DMAMOV SAR, uStAddr
+ * DMAMOV DAR, uStAddr   */
+static int encodeDmaMove(u8 * mcode_ptr, u8 uDir, u32 uStAddr)
+{
+	u8 uInsBytes[6];
+    	u32 i;
+
+	uInsBytes[0] = (u8)(0xbc);
+	uInsBytes[1] = (u8)(0x0|uDir);
+	uInsBytes[2] = (u8)((uStAddr>>0)&0xff);
+	uInsBytes[3] = (u8)((uStAddr>>8)&0xff);
+	uInsBytes[4] = (u8)((uStAddr>>16)&0xff);
+	uInsBytes[5] = (u8)((uStAddr>>24)&0xff);
+
+	for(i=0; i<6; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 6;
+}
+
+
+/* DMALD, DMALDS, DMALDB  */
+static int encodeDmaLoad(u8 * mcode_ptr)
+{
+	u8 bs=0;
+	u8 x=0;
+	u8 uInsBytes[1];
+	u32 i;
+
+	uInsBytes[0] = (u8)(0x04|(bs<<1)|(x<<0));
+
+	for(i=0; i<1; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 1;
+}
+
+/* DMALDPS, DMALDPB (Load Peripheral)  */
+static int encodeDmaLoadPeri(u8 * mcode_ptr, u8 mPeriNum)
+{
+	u8 bs;
+	u8 uInsBytes[2];
+	u32 i;
+	u8 m_uBurstSz=1;
+
+	if(mPeriNum > PL330_MAX_PERIPHERAL_NUM) {
+		print_warning("[%s] The peripheral number is too big ! : %d\n", __FUNCTION__, mPeriNum);
+		return 0;
+	}
+
+	bs = (m_uBurstSz == 1) ? 0 : 1; // single -> 0, burst -> 1
+
+	uInsBytes[0] = (u8)(0x25|(bs<<1));
+	uInsBytes[1] = (u8)(0x00|((mPeriNum&0x1f)<<3));
+
+	for(i=0; i<2; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 2;
+}
+
+/* DMAST, DMASTS, DMASTB  */
+static int encodeDmaStore(u8 * mcode_ptr)
+{
+	u8 bs=0;
+	u8 x=0;
+	u8 uInsBytes[1];
+	u32 i;
+
+	uInsBytes[0] = (u8)(0x08|(bs<<1)|(x<<0));
+
+	for(i=0; i<1; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 1;
+}
+
+/* DMASTPS, DMASTPB (Store and notify Peripheral)  */
+static int encodeDmaStorePeri(u8 * mcode_ptr, u8 mPeriNum)
+{
+	u8 bs;
+	u8 uInsBytes[2];
+	u32 i;
+	u8 m_uBurstSz=1;
+
+	if(mPeriNum > PL330_MAX_PERIPHERAL_NUM) {
+		print_warning("[%s] The peripheral number is too big ! : %d\n", __FUNCTION__, mPeriNum);
+		return 0;
+	}
+
+	bs = (m_uBurstSz == 1) ? 0 : 1; /* single:0, burst:1 */
+
+	uInsBytes[0] = (u8)(0x29|(bs<<1));
+	uInsBytes[1] = (u8)(0x00|((mPeriNum&0x1f)<<3));
+
+	for(i=0; i<2; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 2;
+}
+
+/* DMASTZ  */
+static int encodeDmaStoreZero(u8 * mcode_ptr)
+{
+	u8 uInsBytes[1];
+	u32 i;
+
+	uInsBytes[0] = (u8)(0x0c);
+
+	for(i=0; i<1; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 1;
+}
+
+/* DMALP  */
+static int encodeDmaLoop(u8 * mcode_ptr, u8 uLoopCnt, u8 uIteration)
+{
+	u8 uInsBytes[2];
+	u32 i;
+
+	uInsBytes[0] = (u8)(0x20|(uLoopCnt<<1));
+	uInsBytes[1] = (u8)(uIteration);
+
+	for(i=0; i<2; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 2;
+
+}
+
+/* DMALPFE  */
+static int encodeDmaLoopForever(u8 * mcode_ptr, u8 uBwJump)
+{
+	u8 bs=0;
+	u8 x=0;
+	u8 uInsBytes[2];
+	u32 i;
+
+	uInsBytes[0] = (u8)(0x28|(0<<4)|(0<<2)|(bs<<1)|x);
+	uInsBytes[1] = (u8)(uBwJump);
+
+	for(i=0; i<2; i++)
+	{
+		memOutp8(mcode_ptr + i, uInsBytes[i]);
+	}
+
+	return 2;
+}
+
+
+/* DMALPEND, DMALPENDS, DMALPENDB  */
+static int encodeDmaLoopEnd(u8 * mcode_ptr, u8 uLoopCnt, u8 uBwJump)
+{
+	u8 bs=0;
+	u8 x=0;
+	u8 uInsBytes[2];
+	u32 i;
+
+	uInsBytes[0] = (u8)(0x38|(1<<4)|(uLoopCnt<<2)|(bs<<1)|x);
+	uInsBytes[1] = (u8)(uBwJump);
+
+	for(i=0; i<2; i++)
+	{
+		memOutp8(mcode_ptr + i, uInsBytes[i]);
+	}
+
+	return 2;
+}
+
+/*  DMAWFP, DMAWFPS, DMAWFPB (Wait For Peripheral) */
+static int encodeDmaWaitForPeri(u8 * mcode_ptr, u8 mPeriNum)
+{
+	u8 bs=0;
+	u8 p=0;
+	u8 uInsBytes[2];
+    	u32 i;
+
+	if(mPeriNum > PL330_MAX_PERIPHERAL_NUM) {
+		print_warning("[%s] The peripheral number is too big ! : %d\n", __FUNCTION__, mPeriNum);
+		return 0;
+	}
+
+	uInsBytes[0] = (u8)(0x30|(bs<<1)|p);
+	uInsBytes[1] = (u8)(0x00|((mPeriNum&0x1f)<<3));
+
+	for(i=0; i<2; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 2;
+}
+
+/* DMAWFE (Wait For Event) : 0 ~ 31 */
+static int encodeDmaWaitForEvent(u8 * mcode_ptr, u8 uEventNum)
+{
+	u8 uInsBytes[2];
+	u32 i;
+
+	if(uEventNum > PL330_MAX_EVENT_NUM) {
+		print_warning("[%s] The uEventNum number is too big ! : %d\n", __FUNCTION__, uEventNum);
+		return 0;
+	}
+
+	uInsBytes[0] = (u8)(0x36);
+	uInsBytes[1] = (u8)((uEventNum<<3)|0x2); /* for cache coherency, invalid is issued.  */
+
+	for(i=0; i<2; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 2;
+}
+
+/*  DMAFLUSHP (Flush and notify Peripheral) */
+static int encodeDmaFlushPeri(u8 * mcode_ptr, u8 mPeriNum)
+{
+	u8 uInsBytes[2];
+	u32 i;
+
+	if(mPeriNum > PL330_MAX_PERIPHERAL_NUM) {
+		print_warning("[%s] The peripheral number is too big ! : %d\n", __FUNCTION__, mPeriNum);
+		return 0;
+	}
+
+	uInsBytes[0] = (u8)(0x35);
+	uInsBytes[1] = (u8)(0x00|((mPeriNum&0x1f)<<3));
+
+	for(i=0; i<2; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 2;
+}
+
+/* DMAEND */
+static int encodeDmaEnd(u8 * mcode_ptr)
+{
+	memOutp8(mcode_ptr, 0x00);
+
+	return 1;
+}
+
+/* DMAADDH (Add Halfword) */
+static int encodeDmaAddHalfword(u8 * mcode_ptr, bool bSrcDir, u16 uStAddr)
+{
+	u8 uDir = (bSrcDir) ? 0 : 1; /* src addr=0, dst addr=1 */
+	u8 uInsBytes[3];
+	u32 i;
+
+	uInsBytes[0] = (u8)(0x54|(uDir<<1));
+	uInsBytes[1] = (u8)((uStAddr>>0)&0xff);
+	uInsBytes[2] = (u8)((uStAddr>>8)&0xff);
+
+	for(i=0; i<3; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 3;
+}
+
+/* DMAKILL (Kill) */
+static int encodeDmaKill(u8 * mcode_ptr)
+{
+	u8 uInsBytes[1];
+	u32 i;
+	uInsBytes[0] = (u8)(0x01);
+
+	for(i=0; i<1; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 1;
+}
+
+/* DMANOP (No operation) */
+static int encodeDmaNop(u8 * mcode_ptr)
+{
+	u8 uInsBytes[1];
+	u32 i;
+	uInsBytes[0] = (u8)(0x18);
+
+	for(i=0; i<1; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 1;
+}
+
+
+/* DMARMB (Read Memory Barrier) */
+static int encodeDmaReadMemBarrier(u8 * mcode_ptr)
+{
+	u8 uInsBytes[1];
+	u32 i;
+	uInsBytes[0] = (u8)(0x12);
+
+	for(i=0; i<1; i++)
+	{
+		memOutp8(mcode_ptr+i, uInsBytes[i]);
+	}
+
+	return 1;
+}
+
+/* DMASEV (Send Event) : 0 ~ 31 */
+static int encodeDmaSendEvent(u8 * mcode_ptr, u8 uEventNum)
+{
+	u8 uInsBytes[2];
+	u32 i;
+	uInsBytes[0] = (u8)(0x34);
+	uInsBytes[1] = (u8)((uEventNum<<3)|0x0);
+
+	if(uEventNum > PL330_MAX_EVENT_NUM) {
+		print_warning("[%s] Event number is too big ! : %d\n", __FUNCTION__, uEventNum);
+		return 0;
+	}
+
+	for(i=0; i<2; i++)
+	{
+		memOutp8(mcode_ptr + i, uInsBytes[i]);
+	}
+
+	return 2;
+}
+
+
+/* DMAWMB (Write Memory Barrier) */
+static int encodeDmaWriteMemBarrier(u8 * mcode_ptr)
+{
+	u8 uInsBytes[1];
+	u32 i;
+	uInsBytes[0] = (u8)(0x13);
+
+	for(i=0; i<1; i++)
+	{
+		memOutp8(mcode_ptr + i, uInsBytes[i]);
+	}
+
+	return 1;
+}
+
+/* DMAGO over DBGINST[0:1] registers */
+static void encodeDmaGoOverDBGINST(u32 * mcode_ptr, u8 chanNum, u32 mbufAddr, u8 m_secureBit)
+{
+	u32 x;
+	u8 uDmaGo;		/* DMAGO instruction */
+
+	if(chanNum > PL330_MAX_CHANNEL_NUM) {
+		print_warning("[%s] Channel number is too big ! : %d\n", __FUNCTION__, chanNum);
+		return;
+	}
+
+	do
+	{
+		x = Inp32(mcode_ptr+DMA_DBGSTATUS);
+	} while ((x&0x1)==0x1);
+
+	uDmaGo = (m_secureBit==0) ?
+		(0xa0|(0<<1)) : 	/* secure mode : M2M DMA only   */
+		(0xa0|(1<<1));  	/* non-secure mode : M2P/P2M DMA only */
+
+	Outp32(mcode_ptr+DMA_DBGINST0, (chanNum<<24)|(uDmaGo<<16)|(chanNum<<8)|(0<<0));
+	Outp32(mcode_ptr+DMA_DBGINST1, mbufAddr);
+	Outp32(mcode_ptr+DMA_DBGCMD, 0); 	/* 0 : execute the instruction that the DBGINST0,1 registers contain */
+
+}
+
+/* DMAKILL over DBGINST[0:1] registers - Stop a DMA channel */
+static void encodeDmaKillChannelOverDBGINST(u32 * mcode_ptr, u8 chanNum)
+{
+	u32 x;
+
+	if(chanNum > PL330_MAX_CHANNEL_NUM) {
+		print_warning("[%s] Channel number is too big ! : %d\n", __FUNCTION__, chanNum);
+		return;
+	}
+
+	do
+	{
+		x = Inp32(mcode_ptr+DMA_DBGSTATUS);
+	} while ((x&0x1)==0x1);
+
+	Outp32(mcode_ptr+DMA_DBGINST0, (0<<24)|(1<<16)|(chanNum<<8)|(1<<0));	/* issue instruction by channel thread */
+	Outp32(mcode_ptr+DMA_DBGINST1, 0);
+	Outp32(mcode_ptr+DMA_DBGCMD, 0); 	/* 0 : execute the instruction that the DBGINST0,1 registers contain */
+
+	do
+	{
+		x = Inp32(mcode_ptr+DMA_DBGSTATUS);
+	} while ((x&0x1)==0x1);
+}
+
+/* DMAKILL over DBGINST[0:1] registers - Stop a DMA controller (stop all of the channels) */
+static void encodeDmaKillDMACOverDBGINST(u32 * mcode_ptr)
+{
+	u32 x;
+
+	do
+	{
+		x = Inp32(mcode_ptr+DMA_DBGSTATUS);
+	} while ((x&0x1)==0x1);
+
+	Outp32(mcode_ptr+DMA_DBGINST0, (0<<24)|(1<<16)|(0<<8)|(0<<0));	/* issue instruction by manager thread */
+	Outp32(mcode_ptr+DMA_DBGINST1, 0);
+	Outp32(mcode_ptr+DMA_DBGCMD, 0); 	/* 0 : execute the instruction that the DBGINST0,1 registers contain */
+
+	do
+	{
+		x = Inp32(mcode_ptr+DMA_DBGSTATUS);
+	} while ((x&0x1)==0x1);
+}
+
+/*----------------------------------------------------------*/
+/*                      Wrapper functions                   */
+/*----------------------------------------------------------*/
+
+/* config_DMA_Go_command
+ * - make DMA GO command into the Debug Instruction register 0/1
+ *
+ *	mcode_ptr	the buffer for PL330 DMAGO micro code to be stored into
+ *	chanNum		the DMA channel number to be started
+ *	mbufAddr	the start address of the buffer containing PL330 DMA micro codes
+ */
+static void config_DMA_GO_command(u32 * mcode_ptr, int chanNum, u32 mbufAddr, int secureMode)
+{
+	dma_debug("%s entered - channel Num=%d\n", __FUNCTION__, chanNum);
+	dma_debug("mcode_ptr=0x%p, mbufAddr=0x%x, secureMode=%d\n\n", mcode_ptr, mbufAddr, secureMode);
+	encodeDmaGoOverDBGINST(mcode_ptr, (u8)chanNum, mbufAddr, (u8)secureMode);
+}
+
+/* config_DMA_stop_channel
+ * - stop the DMA channel working on
+ *	mcode_ptr	the buffer for PL330 DMAKILL micro code to be stored into
+ *	chanNum		the DMA channel number to be stopped
+ */
+static void config_DMA_stop_channel(u32 * mcode_ptr, int chanNum)
+{
+	dma_debug("%s entered - channel Num=%d\n", __FUNCTION__, chanNum);
+	encodeDmaKillChannelOverDBGINST(mcode_ptr, (u8)chanNum);
+}
+
+/* config_DMA_stop_controller
+ * - stop the DMA controller
+ *	mcode_ptr	the buffer for PL330 DMAKILL micro code to be stored into
+ */
+static void config_DMA_stop_controller(u32 * mcode_ptr)
+{
+	dma_debug("%s entered - mcode_ptr=0x%p\n", __FUNCTION__, mcode_ptr);
+	encodeDmaKillDMACOverDBGINST(mcode_ptr);
+}
+
+
+/* config_DMA_start_address
+ * - set the DMA start address
+ *
+ *	mcode_ptr	the pointer to the buffer for PL330 DMAMOVE micro code to be stored into
+ *	uStAddr		the DMA start address
+ */
+static int config_DMA_start_address(u8 * mcode_ptr, int uStAddr)
+{
+	dma_debug("%s entered - start addr=0x%x\n", __FUNCTION__, uStAddr);
+	return encodeDmaMove(mcode_ptr, 0, (u32)uStAddr);
+}
+
+
+/* config_DMA_destination_address
+ * - set the DMA destination address
+ *
+ *	mcode_ptr	the pointer to the buffer for PL330 DMAMOVE micro code to be stored into
+ *	uStAddr		the DMA destination address
+ */
+static int config_DMA_destination_address(u8 * mcode_ptr, int uStAddr)
+{
+	dma_debug("%s entered - destination addr=0x%x\n", __FUNCTION__, uStAddr);
+	return encodeDmaMove(mcode_ptr, 2, (u32)uStAddr);
+}
+
+
+/* config_DMA_control
+ * - set the burst length, burst size, source and destination increment/fixed field
+ *
+ *	mcode_ptr	the pointer to the buffer for PL330 DMAMOVE micro code to be stored into
+ *	dmacon		the value for the DMA channel control register
+ */
+static int config_DMA_control(u8 * mcode_ptr, pl330_DMA_control_t dmacon)
+{
+	dma_debug("%s entered - dmacon : 0x%p\n", __FUNCTION__, &dmacon);
+	return encodeDmaMoveChCtrl(mcode_ptr, *(u32 *)&dmacon);
+}
+
+
+/* config_DMA_transfer_remainder
+ * - set the transfer size of the remainder
+ *
+ *	mcode_ptr	the pointer to the buffer for PL330 DMA micro code to be stored into
+ *	lcRemainder	the remainder except for the LC-aligned transfers
+ *	dma_param	the parameter set for a DMA operation
+ */
+static int config_DMA_transfer_remainder(u8 * mcode_ptr, int lcRemainder, pl330_DMA_parameters_t dma_param)
+{
+	int mcode_size = 0, msize = 0;
+	int lc0 = 0, lcSize = 0, mLoopStart0 = 0, dmaSent = 0;
+
+	dma_debug("%s entered - lcRemainder=%d\n", __FUNCTION__, lcRemainder);
+
+	dmaSent = dma_param.mTrSize - lcRemainder;
+
+	msize = config_DMA_start_address(mcode_ptr+mcode_size, dma_param.mSrcAddr+dmaSent);
+	mcode_size+= msize;
+
+	msize = config_DMA_destination_address(mcode_ptr+mcode_size, dma_param.mDstAddr+dmaSent);
+	mcode_size+= msize;
+
+	dma_param.mControl.uSBSize = 0x2;	/* 4 bytes    */
+	dma_param.mControl.uSBLength = 0x0;	/* 1 transfer */
+	dma_param.mControl.uDBSize = 0x2;	/* 4 bytes    */
+	dma_param.mControl.uDBLength = 0x0;	/* 1 transfer */
+
+	msize = config_DMA_control(mcode_ptr+mcode_size, dma_param.mControl);
+	mcode_size+= msize;
+
+	lcSize = (dma_param.mControl.uSBLength+1)*(1<<dma_param.mControl.uSBSize);
+	lc0 = lcRemainder/lcSize;
+
+	msize = encodeDmaLoop(mcode_ptr+mcode_size, 0, lc0-1);
+	mcode_size+= msize;
+	mLoopStart0 = mcode_size;
+
+	switch(dma_param.mDirection) {
+	case PL330_M2M_DMA:
+		msize = encodeDmaLoad(mcode_ptr+mcode_size);
+		mcode_size+= msize;
+		msize = encodeDmaStore(mcode_ptr+mcode_size);
+		mcode_size+= msize;
+		break;
+
+	case PL330_M2P_DMA:
+		msize = encodeDmaWaitForPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+		mcode_size+= msize;
+		msize = encodeDmaLoad(mcode_ptr+mcode_size);
+		mcode_size+= msize;
+		msize = encodeDmaStorePeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+		mcode_size+= msize;
+		msize = encodeDmaFlushPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+		mcode_size+= msize;
+		break;
+
+	case PL330_P2M_DMA:
+		msize = encodeDmaWaitForPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+		mcode_size+= msize;
+		msize = encodeDmaLoadPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+		mcode_size+= msize;
+		msize = encodeDmaStore(mcode_ptr+mcode_size);
+		mcode_size+= msize;
+		msize = encodeDmaFlushPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+		mcode_size+= msize;
+		break;
+
+	case PL330_P2P_DMA:
+		print_warning("[%s] P2P DMA selected !\n", __FUNCTION__);
+		break;
+
+	default:
+		print_warning("[%s] Invaild DMA direction selected !\n", __FUNCTION__);
+		break;
+	}
+
+	msize = encodeDmaLoopEnd(mcode_ptr+mcode_size, 0, (u8)(mcode_size-mLoopStart0));
+	mcode_size+= msize;
+
+	return mcode_size;
+
+}
+
+
+/* config_DMA_transfer_size
+ * - set the transfer size
+ *
+ *	mcode_ptr	the pointer to the buffer for PL330 DMA micro code to be stored into
+ *	dma_param	the parameter set for a DMA operation
+ */
+static int config_DMA_transfer_size(u8 * mcode_ptr, pl330_DMA_parameters_t dma_param)
+{
+	int mcode_size = 0, msize = 0;
+	int lc0 = 0, lc1 = 0, lcRemainder = 0, lcSize = 0;
+	int mLoopStart0 = 0, mLoopStart1 = 0;
+
+	dma_debug("%s entered \n", __FUNCTION__);
+
+	switch(dma_param.mDirection) {
+	case PL330_M2M_DMA:
+		if(dma_param.mTrSize > (8*1024*1024)) {
+			print_warning("[%s] The chunk size is too big !: %lu\n", __FUNCTION__, dma_param.mTrSize);
+			return 0;
+		}
+		break;
+
+	case PL330_M2P_DMA:
+	case PL330_P2M_DMA:
+		if(dma_param.mTrSize > (2*1024*1024)) {
+			print_warning("[%s] The chunk size is too big !: %lu\n", __FUNCTION__, dma_param.mTrSize);
+			return 0;
+		}
+		break;
+
+	case PL330_P2P_DMA:
+		print_warning("[%s] P2P DMA selected !\n", __FUNCTION__);
+		break;
+
+	default:
+		print_warning("[%s] Invaild DMA direction entered !\n", __FUNCTION__);
+		break;
+	}
+
+	lcSize = (dma_param.mControl.uSBLength+1)*(1<<dma_param.mControl.uSBSize);
+	lc0 = dma_param.mTrSize/lcSize;
+	lcRemainder = dma_param.mTrSize - (lc0*lcSize);
+	dma_debug("lcSize=%d,  lc0=%d,  lcRemainder=%d\n",lcSize, lc0, lcRemainder);
+
+	if(lc0 > PL330_MAX_ITERATION_NUM) {
+		lc1 = lc0/PL330_MAX_ITERATION_NUM;
+		dma_debug("  Inner loop : lc1=%d\n", lc1);
+
+		if(lc1 <= PL330_MAX_ITERATION_NUM) {
+			msize = encodeDmaLoop(mcode_ptr+mcode_size, 1, lc1-1);
+			mcode_size+= msize;
+			mLoopStart1 = mcode_size;
+
+			msize = encodeDmaLoop(mcode_ptr+mcode_size, 0, PL330_MAX_ITERATION_NUM-1);
+			mcode_size+= msize;
+			mLoopStart0 = mcode_size;
+
+			switch(dma_param.mDirection) {
+			case PL330_M2M_DMA:
+				msize = encodeDmaLoad(mcode_ptr+mcode_size);
+				mcode_size+= msize;
+				msize = encodeDmaReadMemBarrier(mcode_ptr+mcode_size);
+				mcode_size+= msize;
+				msize = encodeDmaStore(mcode_ptr+mcode_size);
+				mcode_size+= msize;
+				break;
+
+			case PL330_M2P_DMA:
+				msize = encodeDmaWaitForPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+				mcode_size+= msize;
+				msize = encodeDmaLoad(mcode_ptr+mcode_size);
+				mcode_size+= msize;
+				msize = encodeDmaStorePeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+				mcode_size+= msize;
+				msize = encodeDmaFlushPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+				mcode_size+= msize;
+				break;
+
+			case PL330_P2M_DMA:
+				msize = encodeDmaWaitForPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+				mcode_size+= msize;
+				msize = encodeDmaLoadPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+				mcode_size+= msize;
+				msize = encodeDmaStore(mcode_ptr+mcode_size);
+				mcode_size+= msize;
+				msize = encodeDmaFlushPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+				mcode_size+= msize;
+				break;
+
+			case PL330_P2P_DMA:
+				print_warning("[%s] P2P DMA selected !\n", __FUNCTION__);
+				break;
+
+			default:
+				print_warning("[%s] Invaild DMA direction selected !\n", __FUNCTION__);
+				break;
+			}
+
+			msize = encodeDmaLoopEnd(mcode_ptr+mcode_size, 0, (u8)(mcode_size-mLoopStart0));
+			mcode_size+= msize;
+
+			msize = encodeDmaLoopEnd(mcode_ptr+mcode_size, 1, (u8)(mcode_size-mLoopStart1));
+			mcode_size+= msize;
+
+			lc0 = lc0 - (lc1*PL330_MAX_ITERATION_NUM);
+		}
+		else {
+			print_warning("[%s] The transfer size is over the limit (lc1=%d)\n", __FUNCTION__, lc1);
+		}
+	}
+
+	if(lc0 > 0) {
+		dma_debug("Single loop : lc0=%d\n", lc0);
+		msize = encodeDmaLoop(mcode_ptr+mcode_size, 0, lc0-1);
+		mcode_size+= msize;
+		mLoopStart0 = mcode_size;
+
+		switch(dma_param.mDirection) {
+		case PL330_M2M_DMA:
+			msize = encodeDmaLoad(mcode_ptr+mcode_size);
+			mcode_size+= msize;
+			msize = encodeDmaStore(mcode_ptr+mcode_size);
+			mcode_size+= msize;
+			break;
+
+		case PL330_M2P_DMA:
+			msize = encodeDmaWaitForPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+			mcode_size+= msize;
+			msize = encodeDmaLoad(mcode_ptr+mcode_size);
+			mcode_size+= msize;
+			msize = encodeDmaStorePeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+			mcode_size+= msize;
+			msize = encodeDmaFlushPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+			mcode_size+= msize;
+			break;
+
+		case PL330_P2M_DMA:
+			msize = encodeDmaWaitForPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+			mcode_size+= msize;
+			msize = encodeDmaLoadPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+			mcode_size+= msize;
+			msize = encodeDmaStore(mcode_ptr+mcode_size);
+			mcode_size+= msize;
+			msize = encodeDmaFlushPeri(mcode_ptr+mcode_size, (u8)dma_param.mPeriNum);
+			mcode_size+= msize;
+			break;
+
+		case PL330_P2P_DMA:
+			print_warning("[%s] P2P DMA selected !\n", __FUNCTION__);
+			break;
+
+		default:
+			break;
+		}
+
+		msize = encodeDmaLoopEnd(mcode_ptr+mcode_size, 0, (u8)(mcode_size-mLoopStart0));
+		mcode_size+= msize;
+	}
+
+	if(lcRemainder !=0) {
+		msize = config_DMA_transfer_remainder(mcode_ptr+mcode_size, lcRemainder, dma_param);
+		mcode_size += msize;
+	}
+
+	return mcode_size;
+}
+
+
+/* config_DMA_transfer_size_for_oneNAND
+ * - set the transfer size
+ *
+ *	mcode_ptr	the pointer to the buffer for PL330 DMA micro code to be stored into
+ *	dma_param	the parameter set for a DMA operation
+ */
+#define ONENAND_PAGE_SIZE	2048
+#define ONENAND_OOB_SIZE	64
+#define ONENAND_PAGE_WITH_OOB	(ONENAND_PAGE_SIZE+ONENAND_OOB_SIZE)
+#define MAX_ONENAND_PAGE_CNT	64
+
+static int config_DMA_transfer_size_for_oneNAND(u8 * mcode_ptr, pl330_DMA_parameters_t dma_param)
+{
+	int i = 0, pageCnt =0;
+	int mcode_size = 0, msize = 0;
+	int lc0 = 0, lcSize = 0;
+	int mLoopStart = 0;
+
+	dma_debug("%s entered\n", __FUNCTION__);
+
+	if(dma_param.mTrSize > (MAX_ONENAND_PAGE_CNT*ONENAND_PAGE_WITH_OOB)) {
+		print_warning("[%s] The chunk size is too big !: %lu\n", __FUNCTION__, dma_param.mTrSize);
+		return 0;
+	}
+
+	/* Buffer address on SDRAM */
+	switch(dma_param.mDirection) {
+	case PL330_M2P_DMA:		/* Write into oneNAND */
+		msize = config_DMA_start_address(mcode_ptr+mcode_size, dma_param.mSrcAddr);
+		mcode_size+= msize;
+		break;
+
+	case PL330_P2M_DMA:		/* Read from oneNAND */
+		msize = config_DMA_destination_address(mcode_ptr+mcode_size, dma_param.mDstAddr);
+		mcode_size+= msize;
+		break;
+
+	case PL330_P2P_DMA:
+	case PL330_M2M_DMA:
+	default:
+		print_warning("[%s] Invaild DMA direction selected !\n", __FUNCTION__);
+		break;
+	}
+
+	lcSize = (dma_param.mControl.uSBLength+1)*(1<<dma_param.mControl.uSBSize);	/* 16 bursts * 4 bytes = 64 bytes */
+	lc0 = ONENAND_PAGE_WITH_OOB/lcSize;						/* 2114(1 page+oob)/64 	 	  */
+	pageCnt = dma_param.mTrSize/ONENAND_PAGE_WITH_OOB;				/* mTrsize/2112	 	  	  */
+	dma_debug("lcSize=%d,  lc0=%d, No. of pages=%d\n",lcSize, lc0, pageCnt);
+
+	for(i=0; i<pageCnt; i++) {
+
+		msize = encodeDmaLoop(mcode_ptr+mcode_size, 0, lc0-1);
+		mcode_size+= msize;
+		mLoopStart = mcode_size;
+
+		/* OneNAND address */
+		switch(dma_param.mDirection) {
+		case PL330_M2P_DMA:		/* Write into oneNAND */
+			msize = config_DMA_destination_address(mcode_ptr+mcode_size, dma_param.mDstAddr+(i*0x80));
+			mcode_size+= msize;
+			break;
+
+		case PL330_P2M_DMA:		/* Read from oneNAND */
+			msize = config_DMA_start_address(mcode_ptr+mcode_size, dma_param.mSrcAddr+(i*0x80));
+			mcode_size+= msize;
+			break;
+
+		case PL330_P2P_DMA:
+		case PL330_M2M_DMA:
+		default:
+			print_warning("[%s] Invaild DMA direction selected !\n", __FUNCTION__);
+			break;
+		}
+
+		msize = encodeDmaLoad(mcode_ptr+mcode_size);
+		mcode_size+= msize;
+		msize = encodeDmaStore(mcode_ptr+mcode_size);
+		mcode_size+= msize;
+
+		msize = encodeDmaLoopEnd(mcode_ptr+mcode_size, 0, (u8)(mcode_size-mLoopStart));
+		mcode_size+= msize;
+
+	}
+
+	return mcode_size;
+}
+
+
+/* register_irq_to_DMA_channel
+ * - register an event with the DMA channel
+ *
+ *	mcode_ptr	the pointer to the buffer for PL330 DMASEV micro code to be stored into
+ *	uEventNum	the event number to be assigned to this DMA channel
+ */
+static int register_irq_to_DMA_channel(u8 * mcode_ptr, int uEventNum)
+{
+	dma_debug("%s entered - Event num : %d\n", __FUNCTION__, uEventNum);
+	return encodeDmaSendEvent(mcode_ptr, (u8)uEventNum);
+}
+
+
+/* config_DMA_set_infinite_loop
+ * - set an infinite loop
+ *
+ *	mcode_ptr	the pointer to the buffer for PL330 DMAPLPEND micro code to be stored into
+ *	bBwJump		the relative location of the first instruction in the program loop
+ */
+static int config_DMA_set_infinite_loop(u8 * mcode_ptr, int uBwJump)
+{
+	dma_debug("%s entered - Backward jump offset : %d\n", __FUNCTION__, uBwJump);
+	return encodeDmaLoopForever(mcode_ptr, (u8)uBwJump);
+}
+
+
+/* config_DMA_mark_end
+ * - mark the end of the DMA request
+ *
+ *	mcode_ptr	the pointer to the buffer for PL330 DMAEND micro code to be stored into
+ */
+static int config_DMA_mark_end(u8 * mcode_ptr)
+{
+	dma_debug("%s entered \n\n", __FUNCTION__);
+	return encodeDmaEnd(mcode_ptr);
+}
+
+
+/*----------------------------------------------------------*/
+/*                       DMA Feature Functions              */
+/*----------------------------------------------------------*/
+
+/* start_DMA_controller
+ * - start the DMA controller
+ */
+void start_DMA_controller(u32 * mbuf)
+{
+	dma_debug("%s entered - mbuf=0x%p\n", __FUNCTION__, mbuf);
+	return;
+}
+
+
+/* stop_DMA_controller
+ * - stop the DMA controller
+ *
+ *	mbuf		the address of the buffer for DMAKILL micro code to be stored at
+ */
+void stop_DMA_controller(u32 * mbuf)
+{
+	dma_debug("%s entered - mbuf=0x%p\n", __FUNCTION__, mbuf);
+	config_DMA_stop_controller(mbuf);
+}
+
+
+/* setup_DMA_channel
+ * - set up a DMA channel for the DMA operation
+ *
+ *	mbuf		the address of the buffer that will contain PL330 DMA micro codes
+ *	dma_param	the parameter set for a DMA operation
+ *	chanNum		the DMA channel number to be started
+ */
+int setup_DMA_channel(u8 * mbuf, pl330_DMA_parameters_t dma_param, int chanNum)
+{
+	int mcode_size = 0, msize = 0;
+	dma_debug("%s entered : Channel Num=%d\n", __FUNCTION__, chanNum);
+	print_dma_param_info(dma_param);
+
+	msize = config_DMA_start_address(mbuf+mcode_size, dma_param.mSrcAddr);
+	mcode_size+= msize;
+
+	msize = config_DMA_destination_address(mbuf+mcode_size, dma_param.mDstAddr);
+	mcode_size+= msize;
+
+	msize = config_DMA_control(mbuf+mcode_size, dma_param.mControl);
+	mcode_size+= msize;
+
+	msize = config_DMA_transfer_size(mbuf+mcode_size, dma_param);
+	mcode_size+= msize;
+
+	if(dma_param.mIrqEnable) {
+		msize = register_irq_to_DMA_channel(mbuf+mcode_size, chanNum);
+		mcode_size+= msize;
+	}
+
+	if(dma_param.mLoop) {
+		msize = config_DMA_set_infinite_loop(mbuf+mcode_size, dma_param.mBwJump+mcode_size);
+		mcode_size+= msize;
+	}
+
+	if(dma_param.mLastReq) {
+		msize = config_DMA_mark_end(mbuf+mcode_size);
+		mcode_size+= msize;
+	}
+
+	return mcode_size;
+}
+
+/* setup_DMA_channel for oneNAND
+ * - set up a DMA channel for the oneNAND DMA operation
+ *
+ *	mbuf		the address of the buffer that will contain PL330 DMA micro codes
+ *	dma_param	the parameter set for a DMA operation
+ *	chanNum		the DMA channel number to be started
+ */
+int setup_DMA_channel_for_oneNAND(u8 * mbuf, pl330_DMA_parameters_t dma_param, int chanNum)
+{
+	int mcode_size = 0, msize = 0;
+	dma_debug("%s entered : Channel Num=%d\n", __FUNCTION__, chanNum);
+	print_dma_param_info(dma_param);
+
+	msize = config_DMA_control(mbuf+mcode_size, dma_param.mControl);
+	mcode_size+= msize;
+
+	msize = config_DMA_transfer_size_for_oneNAND(mbuf+mcode_size, dma_param);
+	mcode_size+= msize;
+
+	if(dma_param.mIrqEnable) {
+		msize = register_irq_to_DMA_channel(mbuf+mcode_size, chanNum);
+		mcode_size+= msize;
+	}
+
+	if(dma_param.mLastReq) {
+		msize = config_DMA_mark_end(mbuf+mcode_size);
+		mcode_size+= msize;
+	}
+
+	return mcode_size;
+}
+
+
+/* start_DMA_channel
+ * - get the DMA channel started
+ *
+ *	mbuf		the address of the buffer for DMAGO micro code to be stored at
+ *	chanNum		the DMA channel number to be started
+ *	mbufAddr	the start address of the buffer containing PL330 DMA micro codes
+ */
+void start_DMA_channel(u32 * mbuf, int chanNum, u32 mbufAddr, int secureMode)
+{
+	dma_debug("%s entered - channel Num=%d\n", __FUNCTION__, chanNum);
+	config_DMA_GO_command(mbuf, chanNum, mbufAddr, secureMode);
+}
+
+
+/* stop_DMA_channel
+ * - get the DMA channel stopped
+ *	mbuf		the address of the buffer for DMAKILL micro code to be stored at
+ *	chanNum		the DMA channel number to be stopped
+ */
+void stop_DMA_channel(u32 * mbuf, int chanNum)
+{
+	dma_debug("%s entered - channel Num=%d\n", __FUNCTION__, chanNum);
+	config_DMA_stop_channel(mbuf, chanNum);
+}
+
+
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/egpio.c linux-2.6.29-spica/arch/arm/plat-s3c/egpio.c
--- linux-2.6.29/arch/arm/plat-s3c/egpio.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/egpio.c	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,49 @@
+/*****************************************************************************/
+/*                                                                           */
+/* NAME    : GPIO EXPENDER control ROUTINE									 */
+/* FILE    : egpio.c														 */
+/* PURPOSE : control expand pin levels using i2c with bit-banging algo.      */
+/* DEVICE  : TCA6416                                                         */
+/*           linux/arch/arm/plat-s3c/gpio-ext.c                              */
+/*---------------------------------------------------------------------------*/
+/*                                                                           */
+/*              COPYRIGHT 2008 SAMSUNG ELECTRONICS CO., LTD.                 */
+/*                      ALL RIGHTS RESERVED                                  */
+/*                                                                           */
+/*   Permission is hereby granted to licensees of Samsung Electronics        */
+/*   Co., Ltd. products to use or abstract this computer program for the     */
+/*   sole purpose of implementing a product based on Samsung                 */
+/*   Electronics Co., Ltd. products. No other rights to reproduce, use,      */
+/*   or disseminate this computer program, whether in part or in whole,      */
+/*   are granted.                                                            */
+/*                                                                           */
+/*   Samsung Electronics Co., Ltd. makes no representation or warranties     */
+/*   with respect to the performance of this computer program, and           */
+/*   specifically disclaims any responsibility for any damages,              */
+/*   special or consequential, connected with the use of this program.       */
+/*                                                                           */
+/*****************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+
+#include <plat/regs-gpio.h>
+#include <plat/gpio-cfg.h>
+#include <mach/hardware.h>
+#include <plat/egpio.h>
+#include <mach/map.h>
+
+int egpio_set_value(unsigned int pin, unsigned int level)
+{
+	return 0;
+}
+EXPORT_SYMBOL(egpio_set_value);
+
+int egpio_get_value(unsigned int pin)
+{
+	return 0;
+}
+EXPORT_SYMBOL(egpio_get_value);
diff -Nur linux-2.6.29/arch/arm/plat-s3c/gpio-config.c linux-2.6.29-spica/arch/arm/plat-s3c/gpio-config.c
--- linux-2.6.29/arch/arm/plat-s3c/gpio-config.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/gpio-config.c	2010-05-06 12:42:45.634864134 +0700
@@ -12,7 +12,13 @@
  * published by the Free Software Foundation.
 */
 
+/*
+ *  <YAMAIA><drkim> - 2009.09.21
+ *  local_irq_save() and local_irq_restore() adds in each function
+ */
+ 
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/gpio.h>
 #include <linux/io.h>
 
@@ -38,6 +44,23 @@
 
 	return ret;
 }
+EXPORT_SYMBOL(s3c_gpio_cfgpin);
+
+unsigned int s3c_gpio_get_cfgpin(unsigned int pin)
+{
+	struct s3c_gpio_chip *chip = s3c_gpiolib_getchip(pin);
+	int offset;
+	unsigned int ret;
+
+	if (!chip)
+		return -EINVAL;
+
+	offset = pin - chip->chip.base;
+	ret = s3c_gpio_do_getcfg(chip, offset);
+
+	return ret;
+}
+EXPORT_SYMBOL(s3c_gpio_get_cfgpin);
 
 int s3c_gpio_setpull(unsigned int pin, s3c_gpio_pull_t pull)
 {
@@ -56,6 +79,23 @@
 
 	return ret;
 }
+EXPORT_SYMBOL(s3c_gpio_setpull);
+
+unsigned int s3c_gpio_getpull(unsigned int pin)
+{
+	struct s3c_gpio_chip *chip = s3c_gpiolib_getchip(pin);
+	int offset;
+	unsigned int ret;
+
+	if (!chip)
+		return -EINVAL;
+
+	offset = pin - chip->chip.base;
+	ret = s3c_gpio_do_getpull(chip, offset);
+
+	return ret;
+}
+EXPORT_SYMBOL(s3c_gpio_getpull);
 
 #ifdef CONFIG_S3C_GPIO_CFG_S3C24XX
 int s3c_gpio_setcfg_s3c24xx_banka(struct s3c_gpio_chip *chip,
@@ -63,6 +103,7 @@
 {
 	void __iomem *reg = chip->base;
 	unsigned int shift = off;
+	unsigned long flags;
 	u32 con;
 
 	if (s3c_gpio_is_cfg_special(cfg)) {
@@ -76,11 +117,15 @@
 		cfg <<= shift;
 	}
 
+	local_irq_save(flags);
+	
 	con = __raw_readl(reg);
 	con &= ~(0x1 << shift);
 	con |= cfg;
 	__raw_writel(con, reg);
-
+	
+	local_irq_restore(flags);
+	
 	return 0;
 }
 
@@ -89,6 +134,7 @@
 {
 	void __iomem *reg = chip->base;
 	unsigned int shift = off * 2;
+	unsigned long flags;
 	u32 con;
 
 	if (s3c_gpio_is_cfg_special(cfg)) {
@@ -98,14 +144,32 @@
 
 		cfg <<= shift;
 	}
+	
+	local_irq_save(flags);
 
 	con = __raw_readl(reg);
 	con &= ~(0x3 << shift);
 	con |= cfg;
 	__raw_writel(con, reg);
 
+	local_irq_restore(flags);
+
 	return 0;
 }
+
+u32 s3c_gpio_getcfg_s3c24xx(struct s3c_gpio_chip *chip,
+			    unsigned int off)
+{
+	void __iomem *reg = chip->base;
+	unsigned int shift = off * 2;
+	u32 con;
+
+	con = __raw_readl(reg);
+	con >>= shift;
+	con &= 0x3;
+
+	return con;
+}
 #endif
 
 #ifdef CONFIG_S3C_GPIO_CFG_S3C64XX
@@ -114,9 +178,10 @@
 {
 	void __iomem *reg = chip->base;
 	unsigned int shift = (off & 7) * 4;
+	unsigned long flags;	
 	u32 con;
 
-	if (off < 8 && chip->chip.ngpio >= 8)
+	if (off < 8 && chip->chip.ngpio > 8)
 		reg -= 4;
 
 	if (s3c_gpio_is_cfg_special(cfg)) {
@@ -124,28 +189,84 @@
 		cfg <<= shift;
 	}
 
+	local_irq_save(flags);
+	
 	con = __raw_readl(reg);
 	con &= ~(0xf << shift);
 	con |= cfg;
 	__raw_writel(con, reg);
 
+	local_irq_restore(flags);
+	
 	return 0;
 }
+
+u32 s3c_gpio_getcfg_s3c64xx_4bit(struct s3c_gpio_chip *chip,
+				 unsigned int off)
+{
+	void __iomem *reg = chip->base;
+	unsigned int shift = (off & 7) * 4;
+	u32 con;
+
+	if (off < 8 && chip->chip.ngpio > 8)
+		reg -= 4;
+
+	con = __raw_readl(reg);
+	con >>= shift;
+	con &= 0xf;
+
+	return con;
+}
 #endif /* CONFIG_S3C_GPIO_CFG_S3C64XX */
 
+#ifdef CONFIG_S3C_GPIO_CFG_S5PC1XX
+int s3c_gpio_setcfg_s5pc1xx(struct s3c_gpio_chip *chip,
+				 unsigned int off, unsigned int cfg)
+{
+	void __iomem *reg = chip->base;
+	unsigned int shift = (off & 7) * 4;
+	unsigned long flags;	
+	u32 con;
+
+	if (off < 8 && chip->chip.ngpio >= 8)
+		reg -= 4;
+
+	if (s3c_gpio_is_cfg_special(cfg)) {
+		cfg &= 0xf;
+		cfg <<= shift;
+	}
+
+	local_irq_save(flags);
+	
+	con = __raw_readl(reg);
+	con &= ~(0xf << shift);
+	con |= cfg;
+	__raw_writel(con, reg);
+
+	local_irq_restore(flags);	
+
+	return 0;
+}
+#endif /* CONFIG_S3C_GPIO_CFG_S5PC1XX */
+
 #ifdef CONFIG_S3C_GPIO_PULL_UPDOWN
 int s3c_gpio_setpull_updown(struct s3c_gpio_chip *chip,
 			    unsigned int off, s3c_gpio_pull_t pull)
 {
 	void __iomem *reg = chip->base + 0x08;
 	int shift = off * 2;
+	unsigned long flags;
 	u32 pup;
 
+	local_irq_save(flags);	
+
 	pup = __raw_readl(reg);
 	pup &= ~(3 << shift);
 	pup |= pull << shift;
 	__raw_writel(pup, reg);
 
+	local_irq_restore(flags);	
+	
 	return 0;
 }
 
diff -Nur linux-2.6.29/arch/arm/plat-s3c/hr-time.c linux-2.6.29-spica/arch/arm/plat-s3c/hr-time.c
--- linux-2.6.29/arch/arm/plat-s3c/hr-time.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/hr-time.c	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,397 @@
+/*
+ * linux/arch/arm/plat-s3c/hr-time.c
+ *
+ * SEC Timers
+ *
+ * Copyright (c) 2006 Samsung Electronics
+ *
+ *
+ * SEC (and compatible) Power Manager (Suspend-To-RAM) support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/io.h>
+
+#include <asm/system.h>
+#include <mach/hardware.h>
+#include <asm/leds.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+#include <asm/mach-types.h>
+#include <mach/map.h>
+#include <plat/regs-timer.h>
+#include <mach/regs-irq.h>
+#include <mach/tick.h>
+
+#include <plat/clock.h>
+#include <plat/cpu.h>
+
+
+static void sec_timer_setup(void);
+
+static inline void sec_tick_set_autoreset(void)
+{
+	unsigned long tcon;
+
+	tcon  = __raw_readl(S3C_TCON);
+	tcon |= (1<<22);
+	__raw_writel(tcon, S3C_TCON);
+}
+
+static inline void sec_tick_remove_autoreset(void)
+{
+	unsigned long tcon;	
+
+	tcon  = __raw_readl(S3C_TCON);
+	tcon &= ~(1<<22);
+	__raw_writel(tcon, S3C_TCON);
+}
+
+static void sec_tick_timer_start(unsigned long load_val,
+					int autoreset)
+{
+	unsigned long tcon;
+	unsigned long tcnt;
+	unsigned long tcfg1;
+	unsigned long tcfg0;
+	unsigned long tcstat;
+
+	tcon  = __raw_readl(S3C_TCON);
+	tcfg1 = __raw_readl(S3C_TCFG1);
+	tcfg0 = __raw_readl(S3C_TCFG0);
+	
+	tcstat = __raw_readl(S3C_TINT_CSTAT);
+	tcstat |=  0x10;
+	__raw_writel(tcstat, S3C_TINT_CSTAT);
+		
+	tcnt = load_val;
+	tcnt--;
+	__raw_writel(tcnt, S3C_TCNTB(4));
+
+	tcfg1 &= ~S3C_TCFG1_MUX4_MASK;
+	tcfg1 |= S3C_TCFG1_MUX4_DIV1;
+
+	tcfg0 &= ~S3C_TCFG_PRESCALER1_MASK;
+	tcfg0 |= (0) << S3C_TCFG_PRESCALER1_SHIFT;
+		
+	__raw_writel(tcfg1, S3C_TCFG1);
+	__raw_writel(tcfg0, S3C_TCFG0);
+
+	tcon &= ~(7<<20);
+	
+	tcon |= S3C_TCON_T4MANUALUPD;
+
+	if (autoreset) 
+		tcon |= S3C_TCON_T4RELOAD;
+
+	__raw_writel(tcon, S3C_TCON);
+
+	
+	/* start the timer running */
+	tcon |= S3C_TCON_T4START;
+	tcon &= ~S3C_TCON_T4MANUALUPD;
+	__raw_writel(tcon, S3C_TCON);
+
+}
+
+static inline void sec_tick_timer_stop(void)
+{
+	unsigned long tcon;
+
+	tcon  = __raw_readl(S3C_TCON);
+	tcon &= ~(1<<20);
+	__raw_writel(tcon, S3C_TCON);
+}
+
+static void sec_sched_timer_start(unsigned long load_val,
+					int autoreset)
+{
+	unsigned long tcon;
+	unsigned long tcnt;
+	unsigned long tcfg1;
+	unsigned long tcfg0;
+	unsigned long tcstat;
+
+	tcstat = __raw_readl(S3C_TINT_CSTAT);
+	tcstat |=  0x04;
+	__raw_writel(tcstat, S3C_TINT_CSTAT);
+
+	tcon  = __raw_readl(S3C_TCON);
+	tcfg1 = __raw_readl(S3C_TCFG1);
+	tcfg0 = __raw_readl(S3C_TCFG0);
+		
+	tcnt = load_val;
+	tcnt--;
+	__raw_writel(tcnt, S3C_TCNTB(2));
+	__raw_writel(tcnt, S3C_TCMPB(2));	
+	
+	tcon &= ~(0x0b<<12);
+	
+	if (autoreset) 
+		tcon |= S3C_TCON_T2RELOAD;
+
+	tcon |= S3C_TCON_T2MANUALUPD;
+
+	__raw_writel(tcon, S3C_TCON);
+	
+
+	
+	/* start the timer running */
+	tcon |= S3C_TCON_T2START;
+	tcon &= ~S3C_TCON_T2MANUALUPD;
+	__raw_writel(tcon, S3C_TCON);
+
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ * PWM timer 4 ... count down to zero, interrupt, reload
+ * ---------------------------------------------------------------------------
+ */
+static int sec_tick_set_next_event(unsigned long cycles,
+				   struct clock_event_device *evt)
+{
+	sec_tick_timer_start(cycles, 0);
+	return 0;
+}
+ 
+static void sec_tick_set_mode(enum clock_event_mode mode,
+			      struct clock_event_device *evt)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		sec_tick_set_autoreset();
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		sec_tick_timer_stop();
+		sec_tick_remove_autoreset();
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		break;
+	case CLOCK_EVT_MODE_RESUME:
+		sec_timer_setup();
+		break;
+	}
+}
+
+static struct clock_event_device clockevent_tick_timer = {
+	.name		= "pwm_timer4",
+	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.shift		= 32,
+	.set_next_event	= sec_tick_set_next_event,
+	.set_mode	= sec_tick_set_mode,
+};
+
+irqreturn_t sec_tick_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &clockevent_tick_timer;
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction sec_tick_timer_irq = {
+	.name		= "pwm_timer4",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= sec_tick_timer_interrupt,
+};
+
+static void __init  sec_init_dynamic_tick_timer(unsigned long rate)
+{
+	sec_tick_timer_start((rate / HZ) - 1, 1);
+
+	clockevent_tick_timer.mult = div_sc(rate, NSEC_PER_SEC,
+					    clockevent_tick_timer.shift);
+	clockevent_tick_timer.max_delta_ns =
+		clockevent_delta2ns(-1, &clockevent_tick_timer);
+	clockevent_tick_timer.min_delta_ns =
+		clockevent_delta2ns(1, &clockevent_tick_timer);
+
+	clockevent_tick_timer.cpumask = cpumask_of(0);
+	clockevents_register_device(&clockevent_tick_timer);
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * PWM timer 2 ... free running 32-bit clock source and scheduler clock
+ * ---------------------------------------------------------------------------
+ */
+ 
+static unsigned long sec_mpu_timer2_overflows;
+
+irqreturn_t sec_mpu_timer2_interrupt(int irq, void *dev_id)
+{
+	sec_mpu_timer2_overflows++;
+
+	return IRQ_HANDLED;
+}
+
+struct irqaction sec_timer2_irq = {
+	.name		= "pwm_timer2",
+	.flags		= IRQF_DISABLED ,
+	.handler	= sec_mpu_timer2_interrupt,
+};
+
+
+static cycle_t sec_sched_timer_read(void)
+{
+
+	return (cycle_t)~__raw_readl(S3C_TIMERREG(0x2c));
+}
+
+struct clocksource clocksource_sec= {
+	.name		= "clock_source_timer2",
+	.rating		= 300,
+	.read		= sec_sched_timer_read,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.shift		= 20,
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS ,
+};
+
+/*
+ *  Rounds down to nearest nsec.
+ */
+unsigned long long sec_ticks_to_nsecs(unsigned long ticks)
+{
+        return cyc2ns(&clocksource_sec, ticks);
+}
+
+/*
+ * Returns current time from boot in nsecs. It's OK for this to wrap
+ * around for now, as it's just a relative time stamp.
+ */
+unsigned long long sched_clock(void)
+{
+	static int first = 1;
+	static cycle_t saved_ticks;
+	static int saved_ticks_valid;
+	static unsigned long long base;
+	static unsigned long long last_result;
+
+	unsigned long irq_flags;
+	static cycle_t last_ticks;
+	cycle_t ticks;
+	static unsigned long long result;
+
+	local_irq_save(irq_flags);
+
+	last_ticks = saved_ticks;
+	saved_ticks = ticks = sec_sched_timer_read();
+
+	if(!saved_ticks_valid)
+	{
+		saved_ticks_valid = 1;
+		last_ticks = ticks;
+		base -= cyc2ns(&clocksource_sec, ticks);
+	}
+	if(ticks < last_ticks)
+	{
+		if (first)
+			first = 0;
+		else
+		{
+			base += cyc2ns(&clocksource_sec, clocksource_sec.mask);
+			base += cyc2ns(&clocksource_sec, 1);
+		}
+	}
+
+	last_result = result = cyc2ns(&clocksource_sec, ticks) + base;
+
+	local_irq_restore(irq_flags);
+
+	return result;
+}
+
+static void __init sec_init_clocksource(unsigned long rate)
+{
+	static char err[] __initdata = KERN_ERR
+			"%s: can't register clocksource!\n";
+
+	clocksource_sec.mult
+		= clocksource_khz2mult(rate/1000, clocksource_sec.shift);
+
+	sec_sched_timer_start(~0, 1);
+
+	if (clocksource_register(&clocksource_sec))
+		printk(err, clocksource_sec.name);
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *  Tick Timer initialization
+ * ---------------------------------------------------------------------------
+ */
+static void sec_dynamic_timer_setup(void)
+{
+	struct clk	*ck_ref = clk_get(NULL, "timers");
+	unsigned long	rate;
+
+	if (IS_ERR(ck_ref))
+		panic("failed to get clock for system timer");
+
+	rate = clk_get_rate(ck_ref);
+	clk_put(ck_ref);
+
+	sec_init_dynamic_tick_timer(rate);
+	sec_init_clocksource(rate);
+
+}
+
+
+static void sec_timer_setup(void)
+{
+	struct clk	*ck_ref = clk_get(NULL, "timers");
+	unsigned long	rate;
+
+	
+	if (IS_ERR(ck_ref))
+		panic("failed to get clock for system timer");
+
+	rate = clk_get_rate(ck_ref);
+	clk_put(ck_ref);
+
+	sec_tick_timer_start((rate / HZ) - 1, 1);
+	sec_sched_timer_start(~0, 1);
+
+}
+
+	
+static void __init sec_dynamic_timer_init(void)
+{
+	sec_dynamic_timer_setup();
+	setup_irq(IRQ_TIMER2, &sec_timer2_irq);	
+	setup_irq(IRQ_TIMER4, &sec_tick_timer_irq);
+}
+
+
+struct sys_timer sec_timer = {
+	.init		= sec_dynamic_timer_init,
+};
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/mach/dma-pl080.h linux-2.6.29-spica/arch/arm/plat-s3c/include/mach/dma-pl080.h
--- linux-2.6.29/arch/arm/plat-s3c/include/mach/dma-pl080.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/mach/dma-pl080.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,183 @@
+/* linux/arch/arm/plat-s3c/include/mach/dma-pl080.h
+ *
+ */
+
+#ifndef __ARM_MACH_DMA_PL080_H
+#define __ARM_MACH_DMA_PL080_H
+
+/*
+ * This is the maximum DMA address(physical address) that can be DMAd to.
+ *
+ */
+#define MAX_DMA_ADDRESS		0x40000000
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+#define DMACH_LOW_LEVEL	(1<<28)	/* use this to specifiy hardware ch no */
+
+/* We have 4 dma controllers - DMA0, DMA1, SDMA0, SDMA1 */
+#define S3C_DMA_CONTROLLERS        	(4)
+#define S3C_CHANNELS_PER_DMA       	(8)
+#define S3C_CANDIDATE_CHANNELS_PER_DMA  (16)
+#define S3C_DMA_CHANNELS		(S3C_DMA_CONTROLLERS*S3C_CHANNELS_PER_DMA)
+
+/* flags */
+#define S3C2410_DMAF_SLOW         (1<<0)   /* slow, so don't worry about */
+#define S3C2410_DMAF_AUTOSTART    (1<<1)   /* auto-start if buffer queued */
+
+/* DMA Register definitions */
+#define S3C2410_DCON_AUTORELOAD (0<<22)
+#define S3C2410_DCON_NORELOAD   (1<<22)
+
+/*=================================================*/
+/*   DMA Register Definitions for S3C6400          */
+
+#define S3C_DMAC_INT_STATUS   		(0x00)
+#define S3C_DMAC_INT_TCSTATUS   	(0x04)
+#define S3C_DMAC_INT_TCCLEAR   		(0x08)
+#define S3C_DMAC_INT_ERRORSTATUS   	(0x0c)
+#define S3C_DMAC_INT_ERRORCLEAR   	(0x10)
+#define S3C_DMAC_RAW_INTTCSTATUS   	(0x14)
+#define S3C_DMAC_RAW_INTERRORSTATUS   	(0x18)
+#define S3C_DMAC_ENBLD_CHANNELS	   	(0x1c)
+#define S3C_DMAC_SOFTBREQ	   	(0x20)
+#define S3C_DMAC_SOFTSREQ	   	(0x24)
+#define S3C_DMAC_SOFTLBREQ	   	(0x28)
+#define S3C_DMAC_SOFTLSREQ	   	(0x2c)
+#define S3C_DMAC_CONFIGURATION   	(0x30)
+#define S3C_DMAC_SYNC   		(0x34)
+
+#define S3C_DMAC_CxSRCADDR   		(0x00)
+#define S3C_DMAC_CxDESTADDR   		(0x04)
+#define S3C_DMAC_CxLLI   		(0x08)
+#define S3C_DMAC_CxCONTROL0   		(0x0C)
+#define S3C_DMAC_CxCONTROL1   		(0x10)
+#define S3C_DMAC_CxCONFIGURATION   	(0x14)
+
+#define S3C_DMAC_C0SRCADDR   		(0x100)
+#define S3C_DMAC_C0DESTADDR   		(0x104)
+#define S3C_DMAC_C0LLI   		(0x108)
+#define S3C_DMAC_C0CONTROL0   		(0x10C)
+#define S3C_DMAC_C0CONTROL1   		(0x110)
+#define S3C_DMAC_C0CONFIGURATION   	(0x114)
+
+#define S3C_DMAC_C1SRCADDR   		(0x120)
+#define S3C_DMAC_C1DESTADDR   		(0x124)
+#define S3C_DMAC_C1LLI   		(0x128)
+#define S3C_DMAC_C1CONTROL0   		(0x12C)
+#define S3C_DMAC_C1CONTROL1   		(0x130)
+#define S3C_DMAC_C1CONFIGURATION   	(0x134)
+
+#define S3C_DMAC_C2SRCADDR   		(0x140)
+#define S3C_DMAC_C2DESTADDR   		(0x144)
+#define S3C_DMAC_C2LLI   		(0x148)
+#define S3C_DMAC_C2CONTROL0   		(0x14C)
+#define S3C_DMAC_C2CONTROL1   		(0x150)
+#define S3C_DMAC_C2CONFIGURATION   	(0x154)
+
+#define S3C_DMAC_C3SRCADDR   		(0x160)
+#define S3C_DMAC_C3DESTADDR   		(0x164)
+#define S3C_DMAC_C3LLI   		(0x168)
+#define S3C_DMAC_C3CONTROL0   		(0x16C)
+#define S3C_DMAC_C3CONTROL1   		(0x170)
+#define S3C_DMAC_C3CONFIGURATION   	(0x174)
+
+#define S3C_DMAC_C4SRCADDR   		(0x180)
+#define S3C_DMAC_C4DESTADDR   		(0x184)
+#define S3C_DMAC_C4LLI   		(0x188)
+#define S3C_DMAC_C4CONTROL0   		(0x18C)
+#define S3C_DMAC_C4CONTROL1   		(0x190)
+#define S3C_DMAC_C4CONFIGURATION   	(0x194)
+
+#define S3C_DMAC_C5SRCADDR   		(0x1A0)
+#define S3C_DMAC_C5DESTADDR   		(0x1A4)
+#define S3C_DMAC_C5LLI   		(0x1A8)
+#define S3C_DMAC_C5CONTROL0   		(0x1AC)
+#define S3C_DMAC_C5CONTROL1   		(0x1B0)
+#define S3C_DMAC_C5CONFIGURATION   	(0x1B4)
+
+#define S3C_DMAC_C6SRCADDR   		(0x1C0)
+#define S3C_DMAC_C6DESTADDR   		(0x1C4)
+#define S3C_DMAC_C6LLI   		(0x1C8)
+#define S3C_DMAC_C6CONTROL0   		(0x1CC)
+#define S3C_DMAC_C6CONTROL1   		(0x1D0)
+#define S3C_DMAC_C6CONFIGURATION   	(0x1D4)
+
+#define S3C_DMAC_C7SRCADDR   		(0x1E0)
+#define S3C_DMAC_C7DESTADDR   		(0x1E4)
+#define S3C_DMAC_C7LLI   		(0x1E8)
+#define S3C_DMAC_C7CONTROL0   		(0x1EC)
+#define S3C_DMAC_C7CONTROL1   		(0x1F0)
+#define S3C_DMAC_C7CONFIGURATION   	(0x1F4)
+
+/*DMACConfiguration(0x30)*/
+#define S3C_DMA_CONTROLLER_ENABLE 	(1<<0)		
+
+/*DMACCxControl0 : Channel control register 0*/
+#define S3C_DMACONTROL_TC_INT_ENABLE 	(1<<31)	
+#define S3C_DMACONTROL_DEST_NO_INC	(0<<27)	
+#define S3C_DMACONTROL_DEST_INC		(1<<27)
+#define S3C_DMACONTROL_SRC_NO_INC	(0<<26)
+#define S3C_DMACONTROL_SRC_INC		(1<<26)
+#define S3C_DMACONTROL_DEST_AXI_SPINE	(0<<25)
+#define S3C_DMACONTROL_DEST_AXI_PERI	(1<<25)
+#define S3C_DMACONTROL_SRC_AXI_SPINE	(0<<24)
+#define S3C_DMACONTROL_SRC_AXI_PERI	(1<<24)
+#define S3C_DMACONTROL_DEST_WIDTH_BYTE	(0<<21)
+#define S3C_DMACONTROL_DEST_WIDTH_HWORD	(1<<21)
+#define S3C_DMACONTROL_DEST_WIDTH_WORD	(2<<21)
+#define S3C_DMACONTROL_SRC_WIDTH_BYTE	(0<<18)
+#define S3C_DMACONTROL_SRC_WIDTH_HWORD	(1<<18)
+#define S3C_DMACONTROL_SRC_WIDTH_WORD	(2<<18)
+
+#define S3C_DMACONTROL_DBSIZE_1		(0<<15)
+#define S3C_DMACONTROL_DBSIZE_4		(1<<15)
+#define S3C_DMACONTROL_DBSIZE_8		(2<<15)
+#define S3C_DMACONTROL_DBSIZE_16	(3<<15)
+#define S3C_DMACONTROL_DBSIZE_32	(4<<15)
+#define S3C_DMACONTROL_DBSIZE_64	(5<<15)
+#define S3C_DMACONTROL_DBSIZE_128	(6<<15)
+#define S3C_DMACONTROL_DBSIZE_256	(7<<15)
+
+#define S3C_DMACONTROL_SBSIZE_1		(0<<12)
+#define S3C_DMACONTROL_SBSIZE_4		(1<<12)
+#define S3C_DMACONTROL_SBSIZE_8		(2<<12)
+#define S3C_DMACONTROL_SBSIZE_16	(3<<12)
+#define S3C_DMACONTROL_SBSIZE_32	(4<<12)
+#define S3C_DMACONTROL_SBSIZE_64	(5<<12)
+#define S3C_DMACONTROL_SBSIZE_128	(6<<12)
+#define S3C_DMACONTROL_SBSIZE_256	(7<<12)
+
+
+/*Channel configuration register, DMACCxConfiguration*/
+#define S3C_DMACONFIG_HALT		(1<<18) /*The contents of the channels FIFO are drained*/
+#define S3C_DMACONFIG_ACTIVE		(1<<17) /*Check channel fifo has data or not*/
+#define S3C_DMACONFIG_LOCK		(1<<16)
+#define S3C_DMACONFIG_TCMASK	 	(1<<15) /*Terminal count interrupt mask*/
+#define S3C_DMACONFIG_ERRORMASK	 	(1<<14) /*Interrup error mask*/
+#define S3C_DMACONFIG_FLOWCTRL_MEM2MEM	(0<<11)
+#define S3C_DMACONFIG_FLOWCTRL_MEM2PER	(1<<11)
+#define S3C_DMACONFIG_FLOWCTRL_PER2MEM	(2<<11)
+#define S3C_DMACONFIG_FLOWCTRL_PER2PER	(3<<11)
+#define S3C_DMACONFIG_ONENANDMODEDST	(1<<10)	/* Reserved: OneNandModeDst */
+#define S3C_DMACONFIG_DESTPERIPHERAL(x)	((x)<<6)
+#define S3C_DMACONFIG_ONENANDMODESRC	(1<<5)	/* Reserved: OneNandModeSrc */
+#define S3C_DMACONFIG_SRCPERIPHERAL(x)	((x)<<1)
+#define S3C_DMACONFIG_CHANNEL_ENABLE	(1<<0)
+
+#define S3C_DMA1		16
+
+#define S3C_DEST_SHIFT 		6
+#define S3C_SRC_SHIFT 		1
+
+
+/* #define S3C_DMAC_CSRCADDR(ch)   	S3C_DMAC_C##ch##SRCADDR */
+#define S3C_DMAC_CSRCADDR(ch)   	(S3C_DMAC_C0SRCADDR+ch*0x20)
+#define S3C_DMAC_CDESTADDR(ch)   	(S3C_DMAC_C0DESTADDR+ch*0x20)
+#define S3C_DMAC_CLLI(ch)   		(S3C_DMAC_C0LLI+ch*0x20)
+#define S3C_DMAC_CCONTROL0(ch)   	(S3C_DMAC_C0CONTROL0+ch*0x20)
+#define S3C_DMAC_CCONTROL1(ch)   	(S3C_DMAC_C0CONTROL1+ch*0x20)
+#define S3C_DMAC_CCONFIGURATION(ch)   	(S3C_DMAC_C0CONFIGURATION+ch*0x20)
+
+
+
+#endif //__ARM_MACH_DMA_PL080_H 
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/mach/dma-pl330.h linux-2.6.29-spica/arch/arm/plat-s3c/include/mach/dma-pl330.h
--- linux-2.6.29/arch/arm/plat-s3c/include/mach/dma-pl330.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/mach/dma-pl330.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,114 @@
+/* linux/arch/arm/plat-s3c/include/mach/dma-pl330.h
+ *
+ */
+
+#ifndef __ARM_MACH_DMA_PL330_H
+#define __ARM_MACH_DMA_PL330_H __FILE__
+
+#define DMACH_LOW_LEVEL			(1<<28)	/* use this to specifiy hardware ch no */
+
+
+/* flags */
+#define S3C2410_DMAF_SLOW         	(1<<0)   /* slow, so don't worry about */
+#define S3C2410_DMAF_AUTOSTART    	(1<<1)   /* auto-start if buffer queued */
+
+/*=================================================*/
+/*   DMA Register Definitions for PL330 DMAC       */
+
+#define S3C_DMAC_DS  			(0x00)		
+#define S3C_DMAC_DPC   			(0x04)
+#define S3C_DMAC_INTEN  		(0x20)		/* R/W */
+#define S3C_DMAC_ES  			(0x24)		
+#define S3C_DMAC_INTSTATUS	   	(0x28)
+#define S3C_DMAC_INTCLR			(0x2C)		/* W/O */
+#define S3C_DMAC_FSM		  	(0x30)
+#define S3C_DMAC_FSC		   	(0x34)
+#define S3C_DMAC_FTM		   	(0x38)
+
+#define S3C_DMAC_FTC0   		(0x40)
+#define S3C_DMAC_CS0  			(0x100)
+#define S3C_DMAC_CPC0   		(0x104)
+#define S3C_DMAC_SA_0   		(0x400)
+#define S3C_DMAC_DA_0  			(0x404)
+#define S3C_DMAC_CC_0   		(0x408)
+#define S3C_DMAC_LC0_0  		(0x40C)
+#define S3C_DMAC_LC1_0   		(0x410)
+
+#define S3C_DMAC_FTC(ch)   		(S3C_DMAC_FTC0+ch*0x4)
+#define S3C_DMAC_CS(ch)   		(S3C_DMAC_CS0+ch*0x8)
+#define S3C_DMAC_CPC(ch)   		(S3C_DMAC_CPC0+ch*0x8)
+#define S3C_DMAC_SA(ch)   		(S3C_DMAC_SA_0+ch*0x20)
+#define S3C_DMAC_DA(ch)   		(S3C_DMAC_DA_0+ch*0x20)
+#define S3C_DMAC_CC(ch)   		(S3C_DMAC_CC_0+ch*0x20)
+#define S3C_DMAC_LC0(ch)   		(S3C_DMAC_LC0_0+ch*0x20)
+#define S3C_DMAC_LC10(ch)   		(S3C_DMAC_LC1_0+ch*0x20)
+
+#define S3C_DMAC_DBGSTATUS 		(0xD00)
+#define S3C_DMAC_DBGCMD   		(0xD04)		/* W/O */
+#define S3C_DMAC_DBGINST0  		(0xD08)		/* W/O */
+#define S3C_DMAC_DBGINST1   		(0xD0C)		/* W/O */
+#define S3C_DMAC_CR0   			(0xE00)
+#define S3C_DMAC_CR1   			(0xE04)
+#define S3C_DMAC_CR2   			(0xE08)
+#define S3C_DMAC_CR3   			(0xE0C)
+#define S3C_DMAC_CR4   			(0xE10)
+#define S3C_DMAC_CRDn   		(0xE14)
+
+#define S3C_DMAC_PERI_ID  		(0xFE0)
+#define S3C_DMAC_PCELL_ID  		(0xFF0)
+
+/* S3C_DMAC_CS[3:0] - Channel status */
+#define S3C_DMAC_CS_STOPPED		0x0
+#define S3C_DMAC_CS_EXECUTING		0x1
+#define S3C_DMAC_CS_CACHE_MISS		0x2
+#define S3C_DMAC_CS_UPDATING_PC		0x3
+#define S3C_DMAC_CS_WAITING_FOR_EVENT	0x4
+#define S3C_DMAC_CS_AT_BARRIER		0x5
+#define S3C_DMAC_CS_QUEUE_BUSY		0x6
+#define S3C_DMAC_CS_WAITING_FOR_PERI	0x7
+#define S3C_DMAC_CS_KILLING		0x8
+#define S3C_DMAC_CS_COMPLETING		0x9
+#define S3C_DMAC_CS_FAULT_COMPLETING	0xE
+#define S3C_DMAC_CS_FAULTING		0xF
+
+
+
+/* S3C_DMAC_INTEN : Interrupt Enable Register */
+#define S3C_DMAC_INTEN_EVENT(x)		((x)<<0)
+#define S3C_DMAC_INTEN_IRQ(x)		((x)<<1)
+
+/* S3C_DMAC_INTCLR : Interrupt Clear Register */
+#define S3C_DMAC_INTCLR_IRQ(x)		((x)<<1)
+
+/* S3C DMA Channel control */
+/* Source control */
+#define S3C_DMACONTROL_SRC_INC		(1<<0)
+#define S3C_DMACONTROL_SRC_FIXED	(0<<0)
+#define S3C_DMACONTROL_SRC_WIDTH_BYTE	(0<<1)
+#define S3C_DMACONTROL_SRC_WIDTH_HWORD	(1<<1)
+#define S3C_DMACONTROL_SRC_WIDTH_WORD	(2<<1)
+#define S3C_DMACONTROL_SRC_WIDTH_DWORD	(3<<1)
+#define S3C_DMACONTROL_SBSIZE(x)	(((x-1)&0xF)<<4)
+#define S3C_DMACONTROL_SP_SECURE	(0<<8)
+#define S3C_DMACONTROL_SP_NON_SECURE	(2<<8)
+#define S3C_DMACONTROL_SCACHE		(0<<11)
+
+/* Destination control */
+#define S3C_DMACONTROL_DEST_INC		(1<<14)
+#define S3C_DMACONTROL_DEST_FIXED	(0<<14)
+#define S3C_DMACONTROL_DEST_WIDTH_BYTE	(0<<15)
+#define S3C_DMACONTROL_DEST_WIDTH_HWORD	(1<<15)
+#define S3C_DMACONTROL_DEST_WIDTH_WORD	(2<<15)
+#define S3C_DMACONTROL_DEST_WIDTH_DWORD	(3<<15)
+#define S3C_DMACONTROL_DBSIZE(x)	(((x-1)&0xF)<<18)
+#define S3C_DMACONTROL_DP_SECURE	(0<<22)
+#define S3C_DMACONTROL_DP_NON_SECURE	(2<<22)
+#define S3C_DMACONTROL_DCACHE		(0<<25)
+
+#define S3C_DMACONTROL_ES_SIZE_8	(0<<28)
+#define S3C_DMACONTROL_ES_SIZE_16	(1<<28)
+#define S3C_DMACONTROL_ES_SIZE_32	(2<<28)
+#define S3C_DMACONTROL_ES_SIZE_64	(3<<28)
+
+#endif /* __ARM_MACH_DMA_PL330_H */
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/mach/s3c-dma.h linux-2.6.29-spica/arch/arm/plat-s3c/include/mach/s3c-dma.h
--- linux-2.6.29/arch/arm/plat-s3c/include/mach/s3c-dma.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/mach/s3c-dma.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,371 @@
+/* linux/arch/arm/plat-s3c/include/mach/s3c-dma.h
+ *
+ */
+
+#ifndef __ARM_MACH_S3C_DMA_H 
+#define __ARM_MACH_S3C_DMA_H 
+
+#include <linux/sysdev.h>
+#include <mach/hardware.h>
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+#include <mach/dma-pl080.h>
+#elif defined(CONFIG_CPU_S5PC100) || defined(CONFIG_CPU_S5P6440)
+#include <mach/dma-pl330.h>
+#endif
+
+/* We use `virtual` dma channels to hide the fact we have only a limited
+ * number of DMA channels, and not of all of them (dependant on the device)
+ * can be attached to any DMA source. We therefore let the DMA core handle
+ * the allocation of hardware channels to clients.
+*/
+
+enum dma_ch {
+	DMACH_XD0,
+	DMACH_XD1,
+	DMACH_SDI,
+	DMACH_SPI0,
+	DMACH_SPI_TX,
+	DMACH_SPI_RX,
+	DMACH_SPI1,
+	DMACH_UART0,
+	DMACH_UART1,
+	DMACH_UART2,
+	DMACH_TIMER,
+	DMACH_I2S_IN,
+	DMACH_I2S_OUT,
+	DMACH_I2S_IN_1,		/* s3c2450 iis_1 rx */
+	DMACH_I2S_OUT_1,	/* s3c2450 iis_1 tx */
+	DMACH_I2S_V40_IN,
+	DMACH_I2S_V40_OUT,
+	DMACH_I2S_V50_OUT,
+	DMACH_I2S_V50_IN,
+	DMACH_PCM_IN,
+	DMACH_PCM_OUT,
+	DMACH_MIC_IN,
+	DMACH_USB_EP1,
+	DMACH_USB_EP2,
+	DMACH_USB_EP3,
+	DMACH_USB_EP4,
+	DMACH_UART0_SRC2,	/* s3c2412 second uart sources */
+	DMACH_UART1_SRC2,
+	DMACH_UART2_SRC2,
+	DMACH_UART3,		/* s3c2443 has extra uart */
+	DMACH_UART3_SRC2,
+	DMACH_I2S1_IN,		/* S3C6400 */
+	DMACH_I2S1_OUT,
+	DMACH_SPI0_IN,
+	DMACH_SPI0_OUT,
+	DMACH_SPI1_IN,
+	DMACH_SPI1_OUT,
+	DMACH_AC97_PCM_OUT,
+	DMACH_AC97_PCM_IN,
+	DMACH_AC97_MIC_IN,
+	DMACH_ONENAND_IN,
+	DMACH_3D_M2M,
+	DMACH_MAX,		/* the end entry */
+};
+
+/* types */
+
+enum s3c_dma_state {
+	S3C_DMA_IDLE,
+	S3C_DMA_RUNNING,
+	S3C_DMA_PAUSED
+};
+
+
+/* enum s3c_dma_loadst
+ *
+ * This represents the state of the DMA engine, wrt to the loaded / running
+ * transfers. Since we don't have any way of knowing exactly the state of
+ * the DMA transfers, we need to know the state to make decisions on wether
+ * we can
+ *
+ * S3C_DMA_NONE
+ *
+ * There are no buffers loaded (the channel should be inactive)
+ *
+ * S3C_DMA_1LOADED
+ *
+ * There is one buffer loaded, however it has not been confirmed to be
+ * loaded by the DMA engine. This may be because the channel is not
+ * yet running, or the DMA driver decided that it was too costly to
+ * sit and wait for it to happen.
+ *
+ * S3C_DMA_1RUNNING
+ *
+ * The buffer has been confirmed running, and not finisged
+ *
+ * S3C_DMA_1LOADED_1RUNNING
+ *
+ * There is a buffer waiting to be loaded by the DMA engine, and one
+ * currently running.
+*/
+
+enum s3c_dma_loadst {
+	S3C_DMALOAD_NONE,
+	S3C_DMALOAD_1LOADED,
+	S3C_DMALOAD_1RUNNING,
+	S3C_DMALOAD_1LOADED_1RUNNING,
+};
+
+enum s3c2410_dma_buffresult {
+	S3C2410_RES_OK,
+	S3C2410_RES_ERR,
+	S3C2410_RES_ABORT
+};
+
+enum s3c2410_dmasrc {
+	S3C2410_DMASRC_HW,		/* source is memory */
+	S3C2410_DMASRC_MEM,		/* source is hardware */
+	S3C_DMA_MEM2MEM,      		/* source is memory - READ/WRITE */
+	S3C_DMA_MEM2MEM_SET,      	/* source is memory - READ/WRITE for MEMSET*/
+	S3C_DMA_MEM2MEM_P,      	/* source is hardware - READ/WRITE */
+	S3C_DMA_PER2PER      		/* source is hardware - READ/WRITE */
+};
+
+/* enum s3c_chan_op
+ *
+ * operation codes passed to the DMA code by the user, and also used
+ * to inform the current channel owner of any changes to the system state
+*/
+
+enum s3c_chan_op {
+	S3C2410_DMAOP_START,
+	S3C2410_DMAOP_STOP,
+	S3C2410_DMAOP_PAUSE,
+	S3C2410_DMAOP_RESUME,
+	S3C2410_DMAOP_FLUSH,
+	S3C2410_DMAOP_TIMEOUT,		/* internal signal to handler */
+	S3C2410_DMAOP_STARTED,		/* indicate channel started */
+};
+
+/* dma buffer */
+
+struct s3c2410_dma_client {
+	char                *name;
+};
+
+/* s3c2410_dma_buf_s
+ *
+ * internally used buffer structure to describe a queued or running
+ * buffer.
+*/
+
+struct s3c_dma_buf;
+struct s3c_dma_buf {
+	struct s3c_dma_buf	*next;
+	int			 magic;		/* magic */
+	int			 size;		/* buffer size in bytes */
+	dma_addr_t		 data;		/* start of DMA data */
+	dma_addr_t		 ptr;		/* where the DMA got to [1] */
+	void			*id;		/* client's id */
+	dma_addr_t		mcptr;		/* physical pointer to a set of micro codes */
+	unsigned long 		*mcptr_cpu;	/* virtual pointer to a set of micro codes */
+};
+
+/* [1] is this updated for both recv/send modes? */
+
+struct s3c2410_dma_chan;
+
+/* s3c2410_dma_cbfn_t
+ *
+ * buffer callback routine type
+*/
+
+typedef void (*s3c2410_dma_cbfn_t)(struct s3c2410_dma_chan *,
+				   void *buf, int size,
+				   enum s3c2410_dma_buffresult result);
+
+typedef int  (*s3c2410_dma_opfn_t)(struct s3c2410_dma_chan *,
+				   enum s3c_chan_op );
+
+struct s3c_dma_stats {
+	unsigned long		loads;
+	unsigned long		timeout_longest;
+	unsigned long		timeout_shortest;
+	unsigned long		timeout_avg;
+	unsigned long		timeout_failed;
+};
+
+struct s3c2410_dma_map;
+
+/* struct s3c2410_dma_chan
+ *
+ * full state information for each DMA channel
+*/
+
+/*========================== S3C DMA ===========================================*/
+typedef struct s3c_dma_controller s3c_dma_controller_t;
+struct s3c_dma_controller {
+	/* channel state flags and information */
+	unsigned char          number;      /* number of this dma channel */
+	unsigned char          in_use;      /* channel allocated and how many channel are used */
+	unsigned char          irq_claimed; /* irq claimed for channel */
+	unsigned char          irq_enabled; /* irq enabled for channel */
+	unsigned char          xfer_unit;   /* size of an transfer */
+
+	/* channel state */
+
+	enum s3c_dma_state    state;
+	enum s3c_dma_loadst   load_state;
+	struct s3c2410_dma_client  *client;
+
+	/* channel configuration */
+	unsigned long          dev_addr;
+	unsigned long          load_timeout;
+	unsigned int           flags;        /* channel flags */
+
+	/* channel's hardware position and configuration */
+	void __iomem           *regs;        /* channels registers */
+	void __iomem           *addr_reg;    /* data address register */
+	unsigned int           irq;          /* channel irq */
+	unsigned long          dcon;         /* default value of DCON */
+
+};
+
+struct s3c2410_dma_chan {
+	/* channel state flags and information */
+	unsigned char		 number;      /* number of this dma channel */
+	unsigned char		 in_use;      /* channel allocated */
+	unsigned char		 irq_claimed; /* irq claimed for channel */
+	unsigned char		 irq_enabled; /* irq enabled for channel */
+	unsigned char		 xfer_unit;   /* size of an transfer */
+
+	/* channel state */
+
+	enum s3c_dma_state	 state;
+	enum s3c_dma_loadst	 load_state;
+	struct s3c2410_dma_client *client;
+
+	/* channel configuration */
+	enum s3c2410_dmasrc	 source;
+	unsigned long		 dev_addr;
+	unsigned long		 load_timeout;
+	unsigned int		 flags;		/* channel flags */
+
+	struct s3c_dma_map	*map;		/* channel hw maps */
+
+	/* channel's hardware position and configuration */
+	void __iomem		*regs;		/* channels registers */
+	void __iomem		*addr_reg;	/* data address register */
+	unsigned int		 irq;		/* channel irq */
+	unsigned long		 dcon;		/* default value of DCON */
+
+	/* driver handles */
+	s3c2410_dma_cbfn_t	 callback_fn;	/* buffer done callback */
+	s3c2410_dma_opfn_t	 op_fn;		/* channel op callback */
+
+	/* stats gathering */
+	struct s3c_dma_stats *stats;
+	struct s3c_dma_stats  stats_store;
+
+	/* buffer list and information */
+	struct s3c_dma_buf	*curr;		/* current dma buffer */
+	struct s3c_dma_buf	*next;		/* next buffer to load */
+	struct s3c_dma_buf	*end;		/* end of queue */
+
+	/* system device */
+	struct sys_device	dev;
+	
+	unsigned int            index;        	/* channel index */
+	unsigned int            config_flags;        /* channel flags */
+	unsigned int            control_flags;        /* channel flags */
+	s3c_dma_controller_t	*dma_con;
+};
+
+/* the currently allocated channel information */
+extern struct s3c2410_dma_chan s3c2410_chans[];
+
+/* note, we don't really use dma_device_t at the moment */
+typedef unsigned long dma_device_t;
+
+struct s3c_sg_list {
+	unsigned long	uSrcAddr;
+	unsigned long	uDstAddr;
+	unsigned long	uNextLLI;
+	unsigned long	uCxControl0;
+	unsigned long	uCxControl1;
+};
+
+/* functions --------------------------------------------------------------- */
+
+/* s3c2410_dma_request
+ *
+ * request a dma channel exclusivley
+*/
+
+extern int s3c2410_dma_request(dmach_t channel,
+			       struct s3c2410_dma_client *, void *dev);
+
+
+/* s3c2410_dma_ctrl
+ *
+ * change the state of the dma channel
+*/
+
+extern int s3c2410_dma_ctrl(dmach_t channel, enum s3c_chan_op op);
+
+
+/* s3c2410_dma_setflags
+ *
+ * set the channel's flags to a given state
+*/
+
+extern int s3c2410_dma_setflags(dmach_t channel,
+				unsigned int flags);
+
+
+/* s3c2410_dma_free
+ *
+ * free the dma channel (will also abort any outstanding operations)
+*/
+
+extern int s3c2410_dma_free(dmach_t channel, struct s3c2410_dma_client *);
+
+
+/* s3c2410_dma_enqueue
+ *
+ * place the given buffer onto the queue of operations for the channel.
+ * The buffer must be allocated from dma coherent memory, or the Dcache/WB
+ * drained before the buffer is given to the DMA system.
+*/
+
+extern int s3c2410_dma_enqueue(dmach_t channel, void *id,
+			       dma_addr_t data, int size);
+
+extern int s3c2410_dma_enqueue_sg(dmach_t channel, void *id,
+			       dma_addr_t data, int size, struct s3c_sg_list *sg_list);
+
+/* s3c2410_dma_config
+ *
+ * configure the dma channel
+*/
+
+extern int s3c2410_dma_config(dmach_t channel, int xferunit, int dcon);
+
+/* s3c2410_dma_devconfig
+ *
+ * configure the device we're talking to
+*/
+
+extern int s3c2410_dma_devconfig(int channel, enum s3c2410_dmasrc source,
+				 int hwcfg, unsigned long devaddr);
+
+/* s3c2410_dma_getposition
+ *
+ * get the position that the dma transfer is currently at
+*/
+
+extern int s3c2410_dma_getposition(dmach_t channel,
+				   dma_addr_t *src, dma_addr_t *dest);
+
+
+extern int s3c2410_dma_set_opfn(dmach_t, s3c2410_dma_opfn_t rtn);
+extern int s3c2410_dma_set_buffdone_fn(dmach_t, s3c2410_dma_cbfn_t rtn);
+
+
+
+
+#endif //__ARM_MACH_S3C_DMA_H
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/adc.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/adc.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/adc.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/adc.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,29 +1,37 @@
 /* arch/arm/plat-s3c/include/plat/adc.h
  *
- * Copyright (c) 2008 Simtec Electronics
- *	http://armlinux.simnte.co.uk/
+ * Copyright (c) 2004 Simtec Electronics
  *	Ben Dooks <ben@simtec.co.uk>
  *
- * S3C24XX ADC driver information
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
 */
 
-#ifndef __ASM_PLAT_ADC_H
-#define __ASM_PLAT_ADC_H __FILE__
-
-struct s3c_adc_client;
+#ifndef __ASM_ARCH_ADC_H
+#define __ASM_ARCH_ADC_H __FILE__
 
-extern int s3c_adc_start(struct s3c_adc_client *client,
-			 unsigned int channel, unsigned int nr_samples);
 
-extern struct s3c_adc_client *s3c_adc_register(struct platform_device *pdev,
-					       void (*select)(unsigned selected),
-					       void (*conv)(unsigned d0, unsigned d1),
-					       unsigned int is_ts);
+struct s3c_adc_request
+{
+	/* for linked list */
+	struct list_head *list;
+	/* after finish ADC sampling, s3c_adc_request function call this function with three parameter */
+	void (*callback)( int channel, unsigned long int param, unsigned short sample);
+	/* for private data */
+	unsigned long int param;
+	/* selected channel for ADC sampling */
+	int channel;
+};
+
+struct s3c_adc_mach_info
+{
+	/* if you need to use some platform data, add in here*/
+	int delay;
+	int presc;
+	int resolution;
+};
 
-extern void s3c_adc_release(struct s3c_adc_client *client);
+void __init s3c_adc_set_platdata(struct s3c_adc_mach_info *pd);
 
-#endif /* __ASM_PLAT_ADC_H */
+#endif /* __ASM_ARCH_ADC_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/clock.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/clock.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/clock.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/clock.h	2010-05-06 12:42:45.634864134 +0700
@@ -41,13 +41,21 @@
 /* core clock support */
 
 extern struct clk clk_f;
+extern struct clk clk_hx2;
 extern struct clk clk_h;
+extern struct clk clk_s;
 extern struct clk clk_p;
 extern struct clk clk_mpll;
 extern struct clk clk_upll;
 extern struct clk clk_epll;
 extern struct clk clk_xtal;
 extern struct clk clk_ext;
+extern struct clk clk_dout_mpll;
+
+#ifdef CONFIG_CPU_S5PC100
+extern struct clk clk_hd0;
+extern struct clk clk_pd0;
+#endif
 
 /* S3C64XX specific clocks */
 extern struct clk clk_27m;
@@ -62,12 +70,13 @@
 
 extern int s3c2410_clkcon_enable(struct clk *clk, int enable);
 
-extern int s3c24xx_register_clock(struct clk *clk);
-extern int s3c24xx_register_clocks(struct clk **clk, int nr_clks);
+extern int s3c_register_clock(struct clk *clk);
+extern int s3c_register_clocks(struct clk **clk, int nr_clks);
 
-extern int s3c24xx_register_baseclocks(unsigned long xtal);
+extern int s3c_register_baseclocks(unsigned long xtal);
 
 extern void s3c64xx_register_clocks(void);
+extern void s5pc1xx_register_clocks(void);
 
 extern void s3c24xx_setup_clocks(unsigned long fclk,
 				 unsigned long hclk,
@@ -81,8 +90,3 @@
 /* S3C64XX specific functions and clocks */
 
 extern int s3c64xx_sclk_ctrl(struct clk *clk, int enable);
-
-/* Init for pwm clock code */
-
-extern void s3c_pwmclk_init(void);
-
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/cpu.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/cpu.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/cpu.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/cpu.h	2010-05-06 12:42:45.634864134 +0700
@@ -3,7 +3,7 @@
  * Copyright (c) 2004-2005 Simtec Electronics
  *	Ben Dooks <ben@simtec.co.uk>
  *
- * Header file for S3C24XX CPU support
+ * Header file for S3C CPU support
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -12,7 +12,7 @@
 
 /* todo - fix when rmk changes iodescs to use `void __iomem *` */
 
-#define IODESC_ENT(x) { (unsigned long)S3C24XX_VA_##x, __phys_to_pfn(S3C24XX_PA_##x), S3C24XX_SZ_##x, MT_DEVICE }
+#define IODESC_ENT(x) { (unsigned long)S3C64XX_VA_##x, __phys_to_pfn(S3C64XX_PA_##x), S3C64XX_SZ_##x, MT_DEVICE }
 
 #ifndef MHZ
 #define MHZ (1000*1000)
@@ -21,9 +21,9 @@
 #define print_mhz(m) ((m) / MHZ), (((m) / 1000) % 1000)
 
 /* forward declaration */
-struct s3c24xx_uart_resources;
+struct s3c_uart_resources;
 struct platform_device;
-struct s3c2410_uartcfg;
+struct s3c_uartcfg;
 struct map_desc;
 
 /* per-cpu initialisation function table. */
@@ -32,7 +32,7 @@
 	unsigned long	idcode;
 	unsigned long	idmask;
 	void		(*map_io)(void);
-	void		(*init_uarts)(struct s3c2410_uartcfg *cfg, int no);
+	void		(*init_uarts)(struct s3c_uartcfg *cfg, int no);
 	void		(*init_clocks)(int xtal);
 	int		(*init)(void);
 	const char	*name;
@@ -43,29 +43,17 @@
 
 /* core initialisation functions */
 
-extern void s3c24xx_init_irq(void);
 extern void s3c64xx_init_irq(u32 vic0, u32 vic1);
-
-extern void s3c24xx_init_io(struct map_desc *mach_desc, int size);
 extern void s3c64xx_init_io(struct map_desc *mach_desc, int size);
+extern void s3c_init_uarts(struct s3c_uartcfg *cfg, int no);
+extern void s3c_init_clocks(int xtal);
+extern void s3c_init_uartdevs(char *name,
+				  struct s3c_uart_resources *res,
+				  struct s3c_uartcfg *cfg, int no);
 
-extern void s3c24xx_init_uarts(struct s3c2410_uartcfg *cfg, int no);
-
-extern void s3c24xx_init_clocks(int xtal);
-
-extern void s3c24xx_init_uartdevs(char *name,
-				  struct s3c24xx_uart_resources *res,
-				  struct s3c2410_uartcfg *cfg, int no);
-
-/* timer for 2410/2440 */
-
+/* timer for S3C6410 */
 struct sys_timer;
-extern struct sys_timer s3c24xx_timer;
+extern struct sys_timer s3c64xx_timer;
 
 /* system device classes */
-
-extern struct sysdev_class s3c2410_sysclass;
-extern struct sysdev_class s3c2412_sysclass;
-extern struct sysdev_class s3c2440_sysclass;
-extern struct sysdev_class s3c2442_sysclass;
-extern struct sysdev_class s3c2443_sysclass;
+extern struct sysdev_class s3c6410_sysclass;
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/debug-macro.S linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/debug-macro.S
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/debug-macro.S	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/debug-macro.S	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* linux/include/asm-arm/plat-s3c/debug-macro.S
+/* linux/arch/arm/plat-s3c/include/plat/debug-macro.S
  *
  * Copyright 2005, 2007 Simtec Electronics
  *	http://armlinux.simtec.co.uk/
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/devs.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/devs.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/devs.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/devs.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* linux/include/asm-arm/plat-s3c24xx/devs.h
+/* linux/arch/arm/plat-s3c/include/plat/devs.h
  *
  * Copyright (c) 2004 Simtec Electronics
  * Ben Dooks <ben@simtec.co.uk>
@@ -11,20 +11,24 @@
 */
 #include <linux/platform_device.h>
 
-struct s3c24xx_uart_resources {
+struct s3c_uart_resources {
 	struct resource		*resources;
 	unsigned long		 nr_resources;
 };
 
-extern struct s3c24xx_uart_resources s3c2410_uart_resources[];
-extern struct s3c24xx_uart_resources s3c64xx_uart_resources[];
+extern struct s3c_uart_resources s3c64xx_uart_resources[];
 
-extern struct platform_device *s3c24xx_uart_devs[];
-extern struct platform_device *s3c24xx_uart_src[];
+extern struct platform_device *s3c_uart_devs[];
+extern struct platform_device *s3c_uart_src[];
 
 extern struct platform_device s3c_device_timer[];
 
-extern struct platform_device s3c_device_fb;
+#if defined(CONFIG_S3C_DMA_PL080_SOL)
+extern struct platform_device s3c_device_dma0;
+extern struct platform_device s3c_device_dma1;
+extern struct platform_device s3c_device_dma2;
+extern struct platform_device s3c_device_dma3;
+#endif
 extern struct platform_device s3c_device_usb;
 extern struct platform_device s3c_device_lcd;
 extern struct platform_device s3c_device_wdt;
@@ -32,23 +36,29 @@
 extern struct platform_device s3c_device_i2c1;
 extern struct platform_device s3c_device_iis;
 extern struct platform_device s3c_device_rtc;
+extern struct platform_device s3c_device_adcts;
 extern struct platform_device s3c_device_adc;
 extern struct platform_device s3c_device_sdi;
 extern struct platform_device s3c_device_hsmmc0;
 extern struct platform_device s3c_device_hsmmc1;
 extern struct platform_device s3c_device_hsmmc2;
-
 extern struct platform_device s3c_device_spi0;
 extern struct platform_device s3c_device_spi1;
-
 extern struct platform_device s3c_device_nand;
-
+extern struct platform_device s3c_device_keypad;
 extern struct platform_device s3c_device_usbgadget;
-
-/* s3c2440 specific devices */
-
-#ifdef CONFIG_CPU_S3C2440
-
+extern struct platform_device s3c_device_ts;
+extern struct platform_device s3c_device_smc911x;
+extern struct platform_device s3c_device_2d;
 extern struct platform_device s3c_device_camif;
-
+extern struct platform_device s3c_device_mfc;
+extern struct platform_device s3c_device_g3d;
+extern struct platform_device s3c_device_rotator;
+extern struct platform_device s3c_device_jpeg;
+extern struct platform_device s3c_device_vpp;
+
+#ifdef CONFIG_S3C6410_TVOUT
+extern struct platform_device s3c_device_tvenc;
+extern struct platform_device s3c_device_tvscaler;
 #endif
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/egpio.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/egpio.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/egpio.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/egpio.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,7 @@
+#ifndef __PLAT_EGPIO_H
+#define __PLAT_EGPIO_H __FILE__
+
+extern int egpio_set_value(unsigned int pin, unsigned int level);
+extern int egpio_get_value(unsigned int pin);
+
+#endif /*__PLAT_EGPIO_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/gpio-cfg.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/gpio-cfg.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/gpio-cfg.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/gpio-cfg.h	2010-05-06 12:42:45.634864134 +0700
@@ -77,6 +77,20 @@
  */
 extern int s3c_gpio_cfgpin(unsigned int pin, unsigned int to);
 
+/**
+ * s3c_gpio_get_cfgpin() - Get confiquraton for the GPIO function of a pin.
+ * @pin pin The pin number to configure.
+ */
+extern unsigned int s3c_gpio_get_cfgpin(unsigned int pin);
+
+#define S3C_GPIO_SLP_OUT0	((__force s3c_gpio_pull_t)0x00)
+#define S3C_GPIO_SLP_OUT1	((__force s3c_gpio_pull_t)0x01)
+#define S3C_GPIO_SLP_INPUT	((__force s3c_gpio_pull_t)0x02)
+#define S3C_GPIO_SLP_PREV	((__force s3c_gpio_pull_t)0x03)
+
+extern int s3c_gpio_slp_cfgpin(unsigned int pin, unsigned int to);
+extern s3c_gpio_pull_t s3c_gpio_get_slp_cfgpin(unsigned int pin);
+
 /* Define values for the pull-{up,down} available for each gpio pin.
  *
  * These values control the state of the weak pull-{up,down} resistors
@@ -98,6 +112,7 @@
  * code if the pin cannot support the requested pull setting.
 */
 extern int s3c_gpio_setpull(unsigned int pin, s3c_gpio_pull_t pull);
+extern int s3c_gpio_slp_setpull_updown(unsigned int pin, s3c_gpio_pull_t pull);
 
 /**
  * s3c_gpio_getpull() - get the pull resistor state of a gpio pin
@@ -106,5 +121,6 @@
  * Read the pull resistor value for the specified pin.
 */
 extern s3c_gpio_pull_t s3c_gpio_getpull(unsigned int pin);
+extern s3c_gpio_pull_t s3c_gpio_slp_getpull_updown(unsigned int pin);
 
 #endif /* __PLAT_GPIO_CFG_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/gpio-cfg-helpers.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/gpio-cfg-helpers.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/gpio-cfg-helpers.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/gpio-cfg-helpers.h	2010-05-06 12:42:45.634864134 +0700
@@ -30,12 +30,24 @@
 	return (chip->config->set_config)(chip, off, config);
 }
 
+static inline unsigned int s3c_gpio_do_getcfg(struct s3c_gpio_chip *chip,
+					      unsigned int off)
+{
+	return (chip->config->get_config)(chip, off);
+}
+
 static inline int s3c_gpio_do_setpull(struct s3c_gpio_chip *chip,
 				      unsigned int off, s3c_gpio_pull_t pull)
 {
 	return (chip->config->set_pull)(chip, off, pull);
 }
 
+static inline unsigned int s3c_gpio_do_getpull(struct s3c_gpio_chip *chip,
+				      	       unsigned int off)
+{
+	return (chip->config->get_pull)(chip, off);
+}
+
 /**
  * s3c_gpio_setcfg_s3c24xx - S3C24XX style GPIO configuration.
  * @chip: The gpio chip that is being configured.
@@ -53,6 +65,22 @@
 				   unsigned int off, unsigned int cfg);
 
 /**
+ * s3c_gpio_getcfg_s3c24xx - Get configuration for S3C24XX style GPIO.
+ * @chip: The gpio chip that is being configured.
+ * @off: The offset for the GPIO being configured.
+ *
+ * This helper deal with the GPIO cases where the control register
+ * has two bits of configuration per gpio, which have the following
+ * functions:
+ *	00 = input
+ *	01 = output
+ *	1x = special function
+*/
+extern u32 s3c_gpio_getcfg_s3c24xx(struct s3c_gpio_chip *chip,
+				   unsigned int off);
+
+
+/**
  * s3c_gpio_setcfg_s3c24xx_a - S3C24XX style GPIO configuration (Bank A)
  * @chip: The gpio chip that is being configured.
  * @off: The offset for the GPIO being configured.
@@ -84,6 +112,43 @@
 extern int s3c_gpio_setcfg_s3c64xx_4bit(struct s3c_gpio_chip *chip,
 					unsigned int off, unsigned int cfg);
 
+/**
+ * s3c_gpio_getcfg_s3c64xx_4bit - Get configuration for S3C64XX 4bit single 
+ * register GPIO.
+ * @chip: The gpio chip that is being configured.
+ * @off: The offset for the GPIO being configured.
+ *
+ * This helper deal with the GPIO cases where the control register has 4 bits
+ * of control per GPIO, generally in the form of:
+ *	0000 = Input
+ *	0001 = Output
+ *	others = Special functions (dependant on bank)
+ *
+ * Note, since the code to deal with the case where there are two control
+ * registers instead of one, we do not have a seperate set of functions for
+ * each case.
+*/
+extern u32 s3c_gpio_getcfg_s3c64xx_4bit(struct s3c_gpio_chip *chip,
+					unsigned int off);
+
+/**
+ * s3c_gpio_setcfg_s5pc1xx - S5PC1XX 4bit single register GPIO config.
+ * @chip: The gpio chip that is being configured.
+ * @off: The offset for the GPIO being configured.
+ * @cfg: The configuration value to set.
+ *
+ * This helper deal with the GPIO cases where the control register has 4 bits
+ * of control per GPIO, generally in the form of:
+ *	0000 = Input
+ *	0001 = Output
+ *	others = Special functions (dependant on bank)
+ *
+ * Note, since the code to deal with the case where there are two control
+ * registers instead of one, we do not have a seperate set of functions for
+ * each case.
+*/
+extern int s3c_gpio_setcfg_s5pc1xx(struct s3c_gpio_chip *chip,
+					unsigned int off, unsigned int cfg);
 
 /* Pull-{up,down} resistor controls.
  *
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/iic-core.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/iic-core.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/iic-core.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/iic-core.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* arch/arm/mach-s3c2410/include/mach/iic-core.h
+/* linux/arch/arm/plat-s3c/include/plat/iic-core.h
  *
  * Copyright 2008 Openmoko, Inc.
  * Copyright 2008 Simtec Electronics
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/iic.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/iic.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/iic.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/iic.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,9 +1,9 @@
-/* arch/arm/mach-s3c2410/include/mach/iic.h
+/* linux/arch/arm/plat-s3c/include/plat/iic.h
  *
  * Copyright (c) 2004 Simtec Electronics
  *	Ben Dooks <ben@simtec.co.uk>
  *
- * S3C2410 - I2C Controller platfrom_device info
+ * S3C - I2C Controller platfrom_device info
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -13,14 +13,14 @@
 #ifndef __ASM_ARCH_IIC_H
 #define __ASM_ARCH_IIC_H __FILE__
 
-#define S3C_IICFLG_FILTER	(1<<0)	/* enable s3c2440 filter */
+#define S3C_IICFLG_FILTER	(1<<0)	/* enable filter */
 
 /* Notes:
  *	1) All frequencies are expressed in Hz
  *	2) A value of zero is `do not care`
 */
 
-struct s3c2410_platform_i2c {
+struct s3c_platform_i2c {
 	int		bus_num;	/* bus number to use */
 	unsigned int	flags;
 	unsigned int	slave_addr;	/* slave address for controller */
@@ -47,8 +47,8 @@
  * NULL to ensure that the device is given the default platform data
  * as the driver will no longer carry defaults.
  */
-extern void s3c_i2c0_set_platdata(struct s3c2410_platform_i2c *i2c);
-extern void s3c_i2c1_set_platdata(struct s3c2410_platform_i2c *i2c);
+extern void s3c_i2c0_set_platdata(struct s3c_platform_i2c *i2c);
+extern void s3c_i2c1_set_platdata(struct s3c_platform_i2c *i2c);
 
 /* defined by architecture to configure gpio */
 extern void s3c_i2c0_cfg_gpio(struct platform_device *dev);
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/map-base.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/map-base.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/map-base.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/map-base.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* linux/include/asm-arm/plat-s3c/map.h
+/* linux/arch/arm/plat-s3c/include/plat/map-base.h
  *
  * Copyright 2003, 2007 Simtec Electronics
  *	http://armlinux.simtec.co.uk/
@@ -35,6 +35,11 @@
 #define S3C_VA_MEM	S3C_ADDR(0x00200000)	/* system control */
 #define S3C_VA_TIMER	S3C_ADDR(0x00300000)	/* timer block */
 #define S3C_VA_WATCHDOG	S3C_ADDR(0x00400000)	/* watchdog */
+#define S3C_VA_LCD	S3C_ADDR(0x00600000)	/* LCD */
 #define S3C_VA_UART	S3C_ADDR(0x01000000)	/* UART */
+#define S3C_VA_SROMC	S3C_ADDR(0x01100000)	/* SROM SFR */
+#define S3C_VA_SYSTIMER	S3C_ADDR(0x01200000)	/* SROM SFR */
+#define S3C_VA_NAND     S3C_ADDR(0x01400000)    /* NAND */
+#define S3C_VA_ONENAND	S3C_ADDR(0x01800000)	/* onenand */
 
 #endif /* __ASM_PLAT_MAP_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/nand.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/nand.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/nand.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/nand.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* arch/arm/mach-s3c2410/include/mach/nand.h
+/* linux/arch/arm/plat-s3c/include/plat/nand.h
  *
  * Copyright (c) 2004 Simtec Electronics
  *	Ben Dooks <ben@simtec.co.uk>
@@ -48,3 +48,8 @@
 					       int chip);
 };
 
+struct s3c_nand_mtd_info {
+	uint chip_nr;
+	uint mtd_part_nr;
+	struct mtd_partition *partition;
+};
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/partition.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/partition.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/partition.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/partition.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,43 @@
+/* linux/arch/arm/plat-s3c/include/plat/partition.h
+ *
+ * Copyright (c) 2008 Samsung Electronics
+ *
+ * Partition information
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+struct mtd_partition s3c_partition_info[] = {
+        {
+                .name		= "Bootloader",
+                .offset		= 0,
+                .size		= (256*SZ_1K),
+                .mask_flags	= MTD_CAP_NANDFLASH,
+        },
+        {
+                .name		= "Kernel",
+                .offset		= (256*SZ_1K),
+                .size		= (4*SZ_1M) - (256*SZ_1K),
+                .mask_flags	= MTD_CAP_NANDFLASH,
+        },
+#if defined(CONFIG_SPLIT_ROOT_FILESYSTEM)
+        {
+                .name		= "Rootfs",
+                .offset		= (4*SZ_1M),
+                .size		= (48*SZ_1M),
+        },
+#endif
+        {
+                .name		= "File System",
+                .offset		= MTDPART_OFS_APPEND,
+                .size		= MTDPART_SIZ_FULL,
+        }
+};
+
+struct s3c_nand_mtd_info s3c_nand_mtd_part_info = {
+	.chip_nr = 1,
+	.mtd_part_nr = ARRAY_SIZE(s3c_partition_info),
+	.partition = s3c_partition_info,
+};
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-ac97.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-ac97.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-ac97.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-ac97.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* arch/arm/mach-s3c2410/include/mach/regs-ac97.h
+/* linux/arch/arm/plat-s3c/include/plat/regs-ac97.h
  *
  * Copyright (c) 2006 Simtec Electronics <linux@simtec.co.uk>
  *		http://www.simtec.co.uk/products/SWLINUX/
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-adc.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-adc.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-adc.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-adc.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* arch/arm/mach-s3c2410/include/mach/regs-adc.h
+/* linux/arch/arm/plat-s3c/include/plat/regs-adc.h
  *
  * Copyright (c) 2004 Shannon Holland <holland@loser.net>
  *
@@ -14,20 +14,29 @@
 
 #define S3C2410_ADCREG(x) (x)
 
-#define S3C2410_ADCCON	   S3C2410_ADCREG(0x00)
-#define S3C2410_ADCTSC	   S3C2410_ADCREG(0x04)
-#define S3C2410_ADCDLY	   S3C2410_ADCREG(0x08)
-#define S3C2410_ADCDAT0	   S3C2410_ADCREG(0x0C)
-#define S3C2410_ADCDAT1	   S3C2410_ADCREG(0x10)
+#define S3C2410_ADCCON	   	S3C2410_ADCREG(0x00)
+#define S3C2410_ADCTSC	   	S3C2410_ADCREG(0x04)
+#define S3C2410_ADCDLY	   	S3C2410_ADCREG(0x08)
+#define S3C2410_ADCDAT0	   	S3C2410_ADCREG(0x0C)
+#define S3C2410_ADCDAT1	   	S3C2410_ADCREG(0x10)
+#define S3C2410_ADCUPDN		S3C2410_ADCREG(0x14)
+#define S3C2443_ADCMUX		S3C2410_ADCREG(0x18)
+#define S3C6400_ADCCLRINT	S3C2410_ADCREG(0x18)
+#define S3C6400_ADCCLRWK	S3C2410_ADCREG(0x20)
 
 
 /* ADCCON Register Bits */
+#define S3C6410_ADCCON_RESSEL_10BIT	(0x0<<16)
+#define S3C6410_ADCCON_RESSEL_12BIT	(0x1<<16)
 #define S3C2410_ADCCON_ECFLG		(1<<15)
 #define S3C2410_ADCCON_PRSCEN		(1<<14)
 #define S3C2410_ADCCON_PRSCVL(x)	(((x)&0xFF)<<6)
 #define S3C2410_ADCCON_PRSCVLMASK	(0xFF<<6)
 #define S3C2410_ADCCON_SELMUX(x)	(((x)&0x7)<<3)
+#define S3C2443_ADCCON_SELMUX(x)	(((x)&0xF)<<0)
 #define S3C2410_ADCCON_MUXMASK		(0x7<<3)
+#define S3C2450_ADCCON_RESSEL_10BIT	(0x0<<3)
+#define S3C2450_ADCCON_RESSEL_12BIT	(0x1<<3)
 #define S3C2410_ADCCON_STDBM		(1<<2)
 #define S3C2410_ADCCON_READ_START	(1<<1)
 #define S3C2410_ADCCON_ENABLE_START	(1<<0)
@@ -35,6 +44,7 @@
 
 
 /* ADCTSC Register Bits */
+#define S3C2410_ADCTSC_UD_SEN		(1<<8)
 #define S3C2410_ADCTSC_YM_SEN		(1<<7)
 #define S3C2410_ADCTSC_YP_SEN		(1<<6)
 #define S3C2410_ADCTSC_XM_SEN		(1<<5)
@@ -55,6 +65,65 @@
 #define S3C2410_ADCDAT1_XY_PST		(0x3<<12)
 #define S3C2410_ADCDAT1_YPDATA_MASK	(0x03FF)
 
+/*--------------------------- Common definitions for S3C  ---------------------------*/
+/* The following definitions will be applied to S3C24XX, S3C64XX, S5PC1XX.	     */
+/*-----------------------------------------------------------------------------------*/
+
+#define S3C_ADCREG(x) 			(x)
+
+#define S3C_ADCCON	   		S3C_ADCREG(0x00)
+#define S3C_ADCTSC	  		S3C_ADCREG(0x04)
+#define S3C_ADCDLY	   		S3C_ADCREG(0x08)
+#define S3C_ADCDAT0	   		S3C_ADCREG(0x0C)
+#define S3C_ADCDAT1	   		S3C_ADCREG(0x10)
+#define S3C_ADCUPDN			S3C_ADCREG(0x14)
+#define S3C_ADCCLRINT			S3C_ADCREG(0x18)
+#define S3C_ADCMUX			S3C_ADCREG(0x1C)
+#define S3C_ADCCLRINTPNDNUP		S3C_ADCREG(0x20)
+
+
+/* ADCCON Register Bits */
+#define S3C_ADCCON_RESSEL_10BIT		(0x0<<16)
+#define S3C_ADCCON_RESSEL_12BIT		(0x1<<16)
+#define S3C_ADCCON_ECFLG		(1<<15)
+#define S3C_ADCCON_PRSCEN		(1<<14)
+#define S3C_ADCCON_PRSCVL(x)		(((x)&0xFF)<<6)
+#define S3C_ADCCON_PRSCVLMASK		(0xFF<<6)
+#define S3C_ADCCON_SELMUX(x)		(((x)&0x7)<<3)
+#define S3C_ADCCON_SELMUX_1(x)		(((x)&0xF)<<0)
+#define S3C_ADCCON_MUXMASK		(0x7<<3)
+#define S3C_ADCCON_RESSEL_10BIT_1	(0x0<<3)
+#define S3C_ADCCON_RESSEL_12BIT_1	(0x1<<3)
+#define S3C_ADCCON_STDBM		(1<<2)
+#define S3C_ADCCON_READ_START		(1<<1)
+#define S3C_ADCCON_ENABLE_START		(1<<0)
+#define S3C_ADCCON_STARTMASK		(0x3<<0)
+
+
+/* ADCTSC Register Bits */
+#define S3C_ADCTSC_UD_SEN		(1<<8)
+#define S3C_ADCTSC_YM_SEN		(1<<7)
+#define S3C_ADCTSC_YP_SEN		(1<<6)
+#define S3C_ADCTSC_XM_SEN		(1<<5)
+#define S3C_ADCTSC_XP_SEN		(1<<4)
+#define S3C_ADCTSC_PULL_UP_DISABLE	(1<<3)
+#define S3C_ADCTSC_AUTO_PST		(1<<2)
+#define S3C_ADCTSC_XY_PST(x)		(((x)&0x3)<<0)
+
+/* ADCDAT0 Bits */
+#define S3C_ADCDAT0_UPDOWN		(1<<15)
+#define S3C_ADCDAT0_AUTO_PST		(1<<14)
+#define S3C_ADCDAT0_XY_PST		(0x3<<12)
+#define S3C_ADCDAT0_XPDATA_MASK		(0x03FF)
+#define S3C_ADCDAT0_XPDATA_MASK_12BIT	(0x0FFF)
+
+/* ADCDAT1 Bits */
+#define S3C_ADCDAT1_UPDOWN		(1<<15)
+#define S3C_ADCDAT1_AUTO_PST		(1<<14)
+#define S3C_ADCDAT1_XY_PST		(0x3<<12)
+#define S3C_ADCDAT1_YPDATA_MASK		(0x03FF)
+#define S3C_ADCDAT1_YPDATA_MASK_12BIT	(0x0FFF)
+
 #endif /* __ASM_ARCH_REGS_ADC_H */
 
 
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-camif.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-camif.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-camif.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-camif.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,460 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-lcd.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+
+#ifndef ___ASM_ARCH_REGS_CAMIF_H
+#define ___ASM_ARCH_REGS_CAMIF_H
+
+#define S3C_CAMIFREG(x) (x)
+
+/*************************************************************************
+ * Macro part
+ ************************************************************************/
+#define S3C_CISRCFMT_SOURCEHSIZE(x)			((x) << 16) 	
+#define S3C_CISRCFMT_GET_SOURCEHSIZE(x)			(((x) >> 16) & 0x1FFFF) 	
+#define S3C_CISRCFMT_SOURCEVSIZE(x)			((x) << 0) 
+#define S3C_CISRCFMT_GET_SOURCEVSIZE(x)			(((x) >> 0) & 0x1FFF) 
+
+#define S3C_CIWDOFST_WINHOROFST(x)			((x) << 16)
+#define S3C_CIWDOFST_GET_WINHOROFST(x)			(((x) >> 16) & 0x7FF)
+#define S3C_CIWDOFST_WINVEROFST(x)			((x) << 0)
+#define S3C_CIWDOFST_GET_WINVEROFST(x)			(((x) >> 0) & 0x7FF)
+
+#define S3C_CIDOWSFT2_WINHOROFST2(x)			((x) << 16)
+#define S3C_CIDOWSFT2_GET_WINHOROFST2(x)		(((x) >> 16) & 0x7FF)
+#define S3C_CIDOWSFT2_WINVEROFST2(x)			((x) << 0)
+#define S3C_CIDOWSFT2_GET_WINVEROFST2(x)		(((x) >> 0) & 0x7FF)
+
+#define S3C_CICOTRGFMT_TARGETHSIZE_CO(x)		((x) << 16)
+#define S3C_CICOTRGFMT_GET_TARGETHSIZE_CO(x)		(((x) >> 16) & 0x1FFF)
+
+#define S3C_CICOTRGFMT_TARGETVSIZE_CO(x)		((x) << 0)
+#define S3C_CICOTRGFMT_GET_TARGETVSIZE_CO(x)		(((x) >> 0) & 0x1FFF)
+
+#define S3C_CICOCTRL_YBURST1_CO(x)			((x) << 19)
+#define S3C_CICOCTRL_YBURST2_CO(x)			((x) << 14)
+#define S3C_CICOCTRL_CBURST1_CO(x)			((x) << 9)
+#define S3C_CICOCTRL_CBURST2_CO(x)			((x) << 4)
+
+#define S3C_CICOSCPRERATIO_SHFACTOR_CO(x)		((x) << 28)
+#define S3C_CICOSCPRERATIO_GET_SHFACTOR_CO(x)		(((x) >> 28) & 0x7F)
+#define S3C_CICOSCPRERATIO_PREHORRATIO_CO(x)		((x) << 16)
+#define S3C_CICOSCPRERATIO_GET_PREHORRATIO_CO(x)	(((x) >> 16) & 0x7F)
+#define S3C_CICOSCPRERATIO_PREVERRATIO_CO(x)		((x) << 0)
+#define S3C_CICOSCPRERATIO_GET_PREVERRATIO_CO(x)	(((x) >> 0) & 0x7F)
+
+#define S3C_CICOSCPREDST_PREDSTWIDTH_CO(x)		((x) << 16)
+#define S3C_CICOSCPREDST_GET_PREDSTWIDTH_CO(x)		(((x) >> 16) & 0x7FF)
+#define S3C_CICOSCPREDST_PREDSTHEIGHT_CO(x)		((x) << 0)
+#define S3C_CICOSCPREDST_GET_PREDSTHEIGHT_CO(x)		(((x) >> 0) & 0x7FF)
+
+#define S3C_CICOSCCTRL_MAINHORRATIO_CO(x)		((x) << 16)
+#define S3C_CICOSCCTRL_GET_MAINHORRATIO_CO(x)		(((x) >> 16) & 0x1FF)
+#define S3C_CICOSCCTRL_MAINVERRATIO_CO(x)		((x) << 0)
+
+#define S3C_CICOSTATUS_FRAMECNT_CO(x)			((x) << 26)
+#define S3C_CICOSTATUS_GET_FRAMECNT_CO(x)		(((x) >> 26) & 0x3)
+
+#define S3C_CIPRTRGFMT_TARGETHSIZE_PR(x)		((x) << 16)
+#define S3C_CIPRTRGFMT_GET_TARGETHSIZE_PR(x)		(((x) >> 16) & 0x1FFF)
+
+#define S3C_CIPRTRGFMT_GET_ROT90_PR(x)			(((x) >> 13) & 0x1)
+
+#define S3C_CIPRTRGFMT_TARGETVSIZE_PR(x)		((x) << 0)
+#define S3C_CIPRTRGFMT_GET_TARGETVSIZE_PR(x)		(((x) >> 0) & 0x1FFF)
+
+#define S3C_CIPRSCPRERATIO_SHFACTOR_PR(x)		((x) << 28)
+#define S3C_CIPRSCPRERATIO_GET_SHFACTOR_PR(x)		(((x) >> 28) & 0xF)
+#define S3C_CIPRSCPRERATIO_PREHORRATIO_PR(x)		((x) << 16)
+#define S3C_CIPRSCPRERATIO_GET_PREHORRATIO_PR(x)	(((x) >> 16) & 0x7F)
+#define S3C_CIPRSCPRERATIO_PREVERRATIO_PR(x)		((x) << 0)
+#define S3C_CIPRSCPRERATIO_GET_PREVERRATIO_PR(x)	(((x) >> 0) & 0x7F)
+
+#define S3C_CIPRSCPREDST_PREDSTWIDTH_PR(x)		((x) << 16)
+#define S3C_CIPRSCPREDST_GET_PREDSTWIDTH_PR(x)		(((x) >> 16) & 0xFFF)
+#define S3C_CIPRSCPREDST_PREDSTHEIGHT_PR(x)		((x) << 0)
+#define S3C_CIPRSCPREDST_GET_PREDSTHEIGHT_PR(x)		(((x) >> 0) & 0xFFF)
+
+#define S3C_CIPRSCCTRL_MAINHORRATIO_PR(x)		((x) << 16)
+#define S3C_CIPRSCCTRL_GET_MAINHORRATIO_PR(x)		(((x) >> 16) && 0x1FF)
+#define S3C_CIPRSCCTRL_MAINVERRATIO_PR(x)		((x) << 0)
+#define S3C_CIPRSCCTRL_GET_MAINVERRATIO_PR(x)		(((x) >> 0) && 0x1FF)
+
+/*************************************************************************
+ * Bit definition part
+ ************************************************************************/
+/* Windows Offset Register */
+#define S3C_CIWDOFST_WINOFSEN				(1 << 31)
+#define S3C_CIWDOFST_CLROVCOFIY				(1 << 30)
+#define S3C_CIWDOFST_CLROVRLB_CO			(1 << 29)
+#define S3C_CIWDOFST_CLROVRLB_PR			(1 << 28)
+#define S3C_CIWDOFST_CLROVPRFIY				(1 << 27)
+#define S3C_CIWDOFST_CLROVCOFICB			(1 << 15)
+#define S3C_CIWDOFST_CLROVCOFICR			(1 << 14)
+#define S3C_CIWDOFST_CLROVPRFICB			(1 << 13)
+#define S3C_CIWDOFST_CLROVPRFICR			(1 << 12)
+
+/* Global Control Register */
+#define S3C_CIGCTRL_SWRST				(1 << 31)
+#define S3C_CIGCTRL_CAMRST				(1 << 30)
+
+#if defined (CONFIG_CPU_S3C6400) || defined (CONFIG_CPU_S3C6410) 
+#define	S3C_CIGCTRL_IRQ_LEVEL				(1 << 20)
+#endif
+
+#define S3C_CIGCTRL_TESTPATTERN_VER_INC			(3 << 27)
+#define S3C_CIGCTRL_TESTPATTERN_HOR_INC			(2 << 27)
+#define S3C_CIGCTRL_TESTPATTERN_COLOR_BAR		(1 << 27)
+#define S3C_CIGCTRL_TESTPATTERN_NORMAL			(0 << 27)
+
+#define S3C_CIGCTRL_INVPOLPCLK				(1 << 26)
+#define S3C_CIGCTRL_INVPOLVSYNC				(1 << 25)
+#define S3C_CIGCTRL_INVPOLHREF				(1 << 24)
+#define S3C_CIGCTRL_IRQ_OVFEN				(1 << 22)
+#define S3C_CIGCTRL_HREF_MASK				(1 << 21)
+#define S3C_CIGCTRL_IRQ_LEVEL				(1 << 20)
+#define S3C_CIGCTRL_IRQ_CLR_C				(1 << 19)
+#define S3C_CIGCTRL_IRQ_CLR_P				(1 << 18)
+
+/* Codec Target Format Register */
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450)
+#define S3C_CICOTRGFMT_IN422_422			(1 << 31)
+#define S3C_CICOTRGFMT_IN422_420			(0 << 31)
+#define S3C_CICOTRGFMT_OUT422_422			(1 << 30)
+#define S3C_CICOTRGFMT_OUT422_420			(0 << 30)
+
+#elif defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410 )
+#define S3C_CICOTRGFMT_OUTFORMAT_RGBOUT			(3 << 29)
+#define S3C_CICOTRGFMT_OUTFORMAT_YCBCR422OUTINTERLEAVE	(2 << 29)
+#define S3C_CICOTRGFMT_OUTFORMAT_YCBCR422OUT		(1 << 29)
+#define S3C_CICOTRGFMT_OUTFORMAT_YCBCR420OUT		(0 << 29)
+#endif
+
+#define S3C_CICOTRGFMT_INTERLEAVE_ON			(1 << 29)
+#define S3C_CICOTRGFMT_INTERLEAVE_OFF			(0 << 29)
+
+#define S3C_CICOTRGFMT_FLIP_180				(3 << 14)
+#define S3C_CICOTRGFMT_FLIP_Y_MIRROR			(2 << 14)
+#define S3C_CICOTRGFMT_FLIP_X_MIRROR			(1 << 14)
+#define S3C_CICOTRGFMT_FLIP_NORMAL			(0 << 14)
+
+/* Codec DMA Control Register */
+#define S3C_CICOCTRL_LASTIRQEN				(1 << 2)
+#define S3C_CICOCTRL_ORDER422_CRYCBY			(3 << 0)
+#define S3C_CICOCTRL_ORDER422_CBYCRY			(2 << 0)
+#define S3C_CICOCTRL_ORDER422_YCRYCB			(1 << 0)
+#define S3C_CICOCTRL_ORDER422_YCBYCR			(0 << 0)
+
+/* Codec Main-Scaler Control Register */
+#define S3C_CICOSCCTRL_SCALERBYPASS_CO			(1 << 31)	
+#define S3C_CICOSCCTRL_SCALEUP_H			(1 << 30)
+#define S3C_CICOSCCTRL_SCALEUP_V			(1 << 29)
+
+#define S3C_CICOSCCTRL_CSCR2Y_WIDE			(1 << 28)
+#define S3C_CICOSCCTRL_CSCR2Y_NARROW			(0 << 28)
+
+#define S3C_CICOSCCTRL_CSCY2R_WIDE			(1 << 27)
+#define S3C_CICOSCCTRL_CSCY2R_NARROW			(0 << 27)
+
+#define S3C_CICOSCCTRL_LCDPATHEN_FIFO			(1 << 26)
+#define S3C_CICOSCCTRL_LCDPATHEN_DMA			(0 << 26)
+
+#define S3C_CICOSCCTRL_INTERLACE_INTERLACE		(1 << 25)
+#define S3C_CICOSCCTRL_INTERLACE_PROGRESSIVE		(0 << 25)
+
+#define S3C_CICOSCCTRL_COSCALERSTART			(1 << 15)
+
+#define S3C_CICOSCCTRL_INRGB_FMT_RGB888			(2 << 13)
+#define S3C_CICOSCCTRL_INRGB_FMT_RGB666			(1 << 13)
+#define S3C_CICOSCCTRL_INRGB_FMT_RGB565			(0 << 13)
+
+#define S3C_CICOSCCTRL_OUTRGB_FMT_RGB888		(2 << 11)
+#define S3C_CICOSCCTRL_OUTRGB_FMT_RGB666		(1 << 11)
+#define S3C_CICOSCCTRL_OUTRGB_FMT_RGB565		(0 << 11)
+
+#define S3C_CICOSCCTRL_EXTRGB_EXTENSION			(1 << 10)
+#define S3C_CICOSCCTRL_EXTRGB_NORMAL			(0 << 10)
+
+/* Codec Status Register */
+#define S3C_CICOSTATUS_OVFIY_CO				(1 << 31)
+#define S3C_CICOSTATUS_OVFICB_CO			(1 << 30)
+#define S3C_CICOSTATUS_OVFICR_CO			(1 << 29)
+#define S3C_CICOSTATUS_VSYNC				(1 << 28)
+#define S3C_CICOSTATUS_WINOFSTEN_CO			(1 << 25)
+#define S3C_CICOSTATUS_IMGCPTEN_CAMIF			(1 << 22)
+#define S3C_CICOSTATUS_IMGCPTEN_COSC			(1 << 21)
+#define S3C_CICOSTATUS_VSYNC_A				(1 << 20)
+#define S3C_CICOSTATUS_VSYNC_B				(1 << 19)
+#define S3C_CICOSTATUS_OVRLB_CO				(1 << 18)
+#define S3C_CICOSTATUS_FRAMEEND_CO			(1 << 17)
+
+/* Preview Target Format Register */
+#define S3C_CIPRTRGFMT_FLIPMD_180ROT			(3 << 14)
+#define S3C_CIPRTRGFMT_FLIPMD_YMIRROR			(2 << 14)
+#define S3C_CIPRTRGFMT_FLIPMD_XMIRROR			(1 << 14)
+#define S3C_CIPRTRGFMT_FLIPMD_NORMAL			(0 << 14)
+
+#define S3C_CIPRTRGFMT_ROT90_ROTATE			(1 << 13)
+#define S3C_CIPRTRGFMT_ROT90_BYPASS			(0 << 13)
+
+/* Preview DMA Control Register */
+#define S3C_CIPRCTRL_LASTIRQEN_ENABLE			(1 << 2)
+#define S3C_CIPRCTRL_LASTIRQEN_NORMAL			(0 << 2)
+
+#define S3C_CIPRCTRL_ORDER422_CRYCBY			(3 << 0)
+#define S3C_CIPRCTRL_ORDER422_CBYCRY			(2 << 0)
+#define S3C_CIPRCTRL_ORDER422_YCRYCB			(1 << 0)
+#define S3C_CIPRCTRL_ORDER422_YCBYCR			(0 << 0)
+
+/* Preview Main-Scaler Control Register */
+#define S3C_CIPRSCCTRL_SAMPLE_PR			(1 << 31)
+
+#define S3C_CIPRSCCTRL_RGBFORMAT_24			(1 << 30)
+#define S3C_CIPRSCCTRL_RGBFORMAT_16			(0 << 30)
+
+#define S3C_CIPRSCCTRL_START				(1 << 15)
+
+#define S3C_CIPRSCCTRL_INRGB_FMT_PR_RGB888		(2 << 13)
+#define S3C_CIPRSCCTRL_INRGB_FMT_PR_RGB666		(1 << 13)
+#define S3C_CIPRSCCTRL_INRGB_FMT_PR_RGB565		(0 << 13)
+
+#define S3C_CIPRSCCTRL_OUTRGB_FMT_PR_RGB888		(2 << 11)
+#define S3C_CIPRSCCTRL_OUTRGB_FMT_PR_RGB666		(1 << 11)
+#define S3C_CIPRSCCTRL_OUTRGB_FMT_PR_RGB565		(0 << 11)
+
+/* Preview Status Register */
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450)
+#define S3C_CIPRSTATUS_OVFICB_PR			(1 << 31)
+#define S3C_CIPRSTATUS_OVFICR_PR			(1 << 30)
+
+#elif defined CONFIG_CPU_S3C6400 || defined CONFIG_CPU_S3C6410 
+#define S3C_CIPRSTATUS_OVFIY_PR				(1 << 31)
+#define S3C_CIPRSTATUS_OVFICB_PR			(1 << 30)
+#define S3C_CIPRSTATUS_OVFICR_PR			(1 << 29)
+#endif
+
+/* Image Capture Enable Register */
+#define S3C_CIIMGCPT_IMGCPTEN				(1 << 31)
+#define S3C_CIIMGCPT_IMGCPTEN_COSC			(1 << 30)
+#define S3C_CIIMGCPT_IMGCPTEN_PRSC			(1 << 29)
+
+#define S3C_CIIMGCPT_CPT_CODMA_SEL_RGB			(1 << 26)
+#define S3C_CIIMGCPT_CPT_CODMA_SEL_YUV			(0 << 26)
+
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450)
+#define S3C_CIIMGCPT_CPT_CODMA_RGBFMT_24		(1 << 25)
+#define S3C_CIIMGCPT_CPT_CODMA_RGBFMT_16		(0 << 25)
+#define S3C_CIIMGCPT_CPT_CODMA_ENABLE			(1 << 24)
+#define S3C_CIIMGCPT_CPT_CODMA_DISABLE			(0 << 24)
+#define S3C_CIIMGCPT_CPT_CODMA_MOD_CNT			(1 << 18)
+#define S3C_CIIMGCPT_CPT_CODMA_MOD_EN			(0 << 18)
+
+#elif defined CONFIG_CPU_S3C6400 || defined CONFIG_CPU_S3C6410 
+#define S3C_CIIMGCPT_CPT_FREN_CO_ENABLE			(1 << 25)
+#define S3C_CIIMGCPT_CPT_FREN_CO_DISABLE		(0 << 25)
+#define S3C_CIIMGCPT_CPT_FREN_PR_ENABLE			(1 << 24)
+#define S3C_CIIMGCPT_CPT_FREN_PR_DISABLE		(0 << 24)
+#define S3C_CIIMGCPT_CPT_FRMOD_CNT			(1 << 18)
+#define S3C_CIIMGCPT_CPT_FRMOD_EN			(0 << 18)
+#endif
+
+/* Image Effects Register */
+#define S3C_CIIMGEFF_IE_ON_PR_ENABLE			(1 << 31)
+#define S3C_CIIMGEFF_IE_ON_PR_DISABLE			(0 << 31)
+
+#define S3C_CIIMGEFF_IE_ON_CO_ENABLE			(1 << 30)
+#define S3C_CIIMGEFF_IE_ON_CO_DISABLE			(0 << 30)
+
+#define S3C_CIIMGEFF_IE_AFTER_SC_BEFORE			(0 << 29)
+#define S3C_CIIMGEFF_IE_AFTER_SC_AFTER			(1 << 29)
+
+#define S3C_CIIMGEFF_FIN_SILHOUETTE			(5 << 26)
+#define S3C_CIIMGEFF_FIN_EMBOSSING			(4 << 26)
+#define S3C_CIIMGEFF_FIN_ARTFREEZE			(3 << 26)
+#define S3C_CIIMGEFF_FIN_NEGATIVE			(2 << 26)
+#define S3C_CIIMGEFF_FIN_ARBITRARY			(1 << 26)
+#define S3C_CIIMGEFF_FIN_BYPASS				(0 << 26)
+
+/* MSDMA for Codec Source Image Width Register */
+#define S3C_MSCOWIDTH_AUTOLOAD_ENABLE			(1 << 31)
+#define S3C_MSCOWIDTH_AUTOLOAD_DISABLE			(0 << 31)
+
+#define S3C_MSCOWIDTH_ADDR_CH_ENABLE			(1 << 30)
+#define S3C_MSCOWIDTH_ADDR_CH_DISABLE			(0 << 30)
+
+/* MSDMA Control Register */
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450)
+#define S3C_CIMSCTRL_INTERLEAVE_MS_INTERLEAVE		(1 << 5)
+#define S3C_CIMSCTRL_INTERLEAVE_MS_NONINTERLEAVE	(0 << 5)
+#define S3C_CIMSCTRL_ORDER422_MS_CRYCBY			(3 << 3)
+#define S3C_CIMSCTRL_ORDER422_MS_CBYCRY			(2 << 3)
+#define S3C_CIMSCTRL_ORDER422_MS_YCRYCB			(1 << 3)
+#define S3C_CIMSCTRL_ORDER422_MS_YCBYCR			(0 << 3)
+#define S3C_CIMSCTRL_SEL_DMA_CAM_MEMORY			(1 << 2)
+#define S3C_CIMSCTRL_SEL_DMA_CAM_EXTCAM			(0 << 2)
+#define S3C_CIMSCTRL_SRC420_MS_420			(1 << 1)
+#define S3C_CIMSCTRL_SRC420_MS_422			(0 << 1)
+#define S3C_CIMSCTRL_ENVID_MS_SET			(1 << 0)
+
+#elif defined CONFIG_CPU_S3C6400 || defined CONFIG_CPU_S3C6410 
+#define S3C_MSCOCTRL_BC_SEL_FRAME			(0 << 10)
+#define S3C_MSCOCTRL_BC_SEL_FIELD			(1 << 10)
+#define S3C_MSCOCTRL_BUFFER_INI_0			(0 << 8)
+#define S3C_MSCOCTRL_BUFFER_INI_1			(1 << 8)
+#define S3C_MSCOCTRL_TRG_MODE_SOFT			(0 << 7)
+#define S3C_MSCOCTRL_TRG_MODE_HARD			(1 << 7)
+#define S3C_MSCOCTRL_ORDER422_M_C_YCBYCR		(0 << 4)
+#define S3C_MSCOCTRL_ORDER422_M_C_YCRYCB		(1 << 4)
+#define S3C_MSCOCTRL_ORDER422_M_C_CBYCRY		(2 << 4)
+#define S3C_MSCOCTRL_ORDER422_M_C_CRYCBY		(3 << 4)
+#define S3C_MSCOCTRL_SEL_DMA_CAM_C_EXTCAM		(0 << 3)
+#define S3C_MSCOCTRL_SEL_DMA_CAM_C_MEMORY		(1 << 3)
+#define S3C_MSCOCTRL_INFORMAT_M_C_420			(0 << 1)
+#define S3C_MSCOCTRL_INFORMAT_M_C_422			(1 << 1)
+#define S3C_MSCOCTRL_INFORMAT_M_C_422_INT		(2 << 1)
+#define S3C_MSCOCTRL_INFORMAT_M_C_RGB			(3 << 1)
+#define S3C_MSCOCTRL_ENVID_M_C_SET			(1 << 0)
+#define S3C_MSPRCTRL_BC_SEL_FIELD			(0 << 10)
+#define S3C_MSPRCTRL_BC_SEL_FRAME			(1 << 10)
+#define S3C_MSPRCTRL_BUFFER_INI_0			(0 << 8)
+#define S3C_MSPRCTRL_BUFFER_INI_1			(1 << 8)
+#define S3C_MSPRCTRL_TRG_MODE_SOFT			(0 << 7)
+#define S3C_MSPRCTRL_TRG_MODE_HARD			(1 << 7)
+#define S3C_MSPRCTRL_ORDER422_M_P_YCBYCR		(0 << 4)
+#define S3C_MSPRCTRL_ORDER422_M_P_YCRYCB		(1 << 4)
+#define S3C_MSPRCTRL_ORDER422_M_P_CBYCRY		(2 << 4)
+#define S3C_MSPRCTRL_ORDER422_M_P_CRYCBY		(3 << 4)
+#define S3C_MSPRCTRL_SEL_DMA_CAM_P_EXTCAM		(0 << 3)
+#define S3C_MSPRCTRL_SEL_DMA_CAM_P_MEMORY		(1 << 3)
+#define S3C_MSPRCTRL_INFORMAT_M_P_420			(0 << 1)
+#define S3C_MSPRCTRL_INFORMAT_M_P_422			(1 << 1)
+#define S3C_MSPRCTRL_INFORMAT_M_P_422_INT		(2 << 1)
+#define S3C_MSPRCTRL_INFORMAT_M_P_RGB			(3 << 1)
+#define S3C_MSPRCTRL_ENVID_M_P_SET			(1 << 0)
+#endif
+
+/*************************************************************************
+ * Register part
+ ************************************************************************/
+#define S3C_CICOYSA(__x) 	S3C_CAMIFREG(0x18 + (__x) * 4)
+#define S3C_CICOCBSA(__x) 	S3C_CAMIFREG(0x28 + (__x) * 4)
+#define S3C_CICOCRSA(__x)  	S3C_CAMIFREG(0x38 + (__x) * 4)
+#define S3C_CIPRCLRSA(__x)  	S3C_CAMIFREG(0x6C + (__x) * 4)
+#define S3C_CIPRYSA(__x)     	S3C_CAMIFREG(0x6C + (__x) * 4)
+#define S3C_CIPRCBSA(__x)   	S3C_CAMIFREG(0x7C + (__x) * 4)
+#define S3C_CIPRCRSA(__x)   	S3C_CAMIFREG(0x8C + (__x) * 4)
+
+#define S3C_CISRCFMT		S3C_CAMIFREG(0x00)
+#define S3C_CIWDOFST		S3C_CAMIFREG(0x04)
+#define S3C_CIGCTRL		S3C_CAMIFREG(0x08)
+#define S3C_CIDOWSFT2		S3C_CAMIFREG(0x14)
+#define S3C_CICOYSA1		S3C_CAMIFREG(0x18)
+#define S3C_CICOYSA2		S3C_CAMIFREG(0x1C)
+#define S3C_CICOYSA3		S3C_CAMIFREG(0x20)
+#define S3C_CICOYSA4		S3C_CAMIFREG(0x24)
+#define S3C_CICOCBSA1		S3C_CAMIFREG(0x28)
+#define S3C_CICOCBSA2		S3C_CAMIFREG(0x2C)
+#define S3C_CICOCBSA3		S3C_CAMIFREG(0x30)
+#define S3C_CICOCBSA4		S3C_CAMIFREG(0x34)
+#define S3C_CICOCRSA1		S3C_CAMIFREG(0x38)
+#define S3C_CICOCRSA2		S3C_CAMIFREG(0x3C)
+#define S3C_CICOCRSA3		S3C_CAMIFREG(0x40)
+#define S3C_CICOCRSA4		S3C_CAMIFREG(0x44)
+#define S3C_CICOTRGFMT		S3C_CAMIFREG(0x48)	/* CODEC target format */
+#define S3C_CICOCTRL		S3C_CAMIFREG(0x4C)	/* CODEC DMA control register */
+#define S3C_CICOSCPRERATIO	S3C_CAMIFREG(0x50)	/* CODEC pre-scaler control register 1 */
+#define S3C_CICOSCPREDST	S3C_CAMIFREG(0x54)	/* CODEC pre-scaler control register 2 */
+#define S3C_CICOSCCTRL		S3C_CAMIFREG(0x58)	/* CODEC main-scaler control */
+#define S3C_CICOTAREA		S3C_CAMIFREG(0x5C)	/* CODEC DMA target area register */
+#define S3C_CICOSTATUS		S3C_CAMIFREG(0x64)	/* CODEC status register */
+
+#if defined (CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450)
+#define S3C_CIPRCLRSA1		S3C_CAMIFREG(0x6C)	/* RGB 1st frame start address for preview DMA */
+#define S3C_CIPRCLRSA2		S3C_CAMIFREG(0x70)	/* RGB 2nd frame start address for preview DMA */
+#define S3C_CIPRCLRSA3		S3C_CAMIFREG(0x74)	/* RGB 3rd frame start address for preview DMA */
+#define S3C_CIPRCLRSA4		S3C_CAMIFREG(0x78)	/* RGB 4th frame start address for preview DMA */
+#define S3C_CIPRTRGFMT		S3C_CAMIFREG(0x7C)	/* PREVIEW target format register */
+#define S3C_CIPRCTRL		S3C_CAMIFREG(0x80)	/* PREVIEW DMA control register */
+#define S3C_CIPRSCPRERATIO	S3C_CAMIFREG(0x84)	/* PREVIEW pre-scaler control register 1 */
+#define S3C_CIPRSCPREDST	S3C_CAMIFREG(0x88)	/* PREVIEW pre-scaler control register 2 */
+#define S3C_CIPRSCCTRL		S3C_CAMIFREG(0x8C)	/* PREVIEW main-scaler control register */
+#define S3C_CIPRTAREA		S3C_CAMIFREG(0x90)	/* PREVIEW DMA target area register */
+#define S3C_CIPRSTATUS		S3C_CAMIFREG(0x98)	/* PREVIEW status register */
+#define S3C_CIIMGCPT		S3C_CAMIFREG(0xA0)	/* image capture enable register */
+#define S3C_CICOCPTSEQ		S3C_CAMIFREG(0xA4)	/* CODEC capture sequence register */
+#define S3C_CICOSCOS		S3C_CAMIFREG(0xA8)	/* CODEC scan line offset register */
+#define S3C_CIIMGEFF		S3C_CAMIFREG(0xB0)	/* image effect register */
+#define S3C_CIMSYSA		S3C_CAMIFREG(0xB4)	/* MSDMA Y start address register */
+#define S3C_CIMSCBSA		S3C_CAMIFREG(0xB8)	/* MSDMA CB start address register */
+#define S3C_CIMSCRSA		S3C_CAMIFREG(0xBC)	/* MSDMA CR start address register */
+#define S3C_CIMSYEND		S3C_CAMIFREG(0xC0)	/* MSDMA Y end address register */
+#define S3C_CIMSCBEND		S3C_CAMIFREG(0xC4)	/* MSDMA CB end address register */
+#define S3C_CIMSCREND		S3C_CAMIFREG(0xC8)	/* MSDMA CR end address register */
+#define S3C_CIMSYOFF		S3C_CAMIFREG(0xCC)	/* MSDMA Y offset register */
+#define S3C_CIMSCBOFF		S3C_CAMIFREG(0xD0)	/* MSDMA CB offset register */
+#define S3C_CIMSCROFF		S3C_CAMIFREG(0xD4)	/* MSDMA CR offset register */
+#define S3C_CIMSWIDTH		S3C_CAMIFREG(0xD8)	/* MSDMA source image width register */
+#define S3C_CIMSCTRL		S3C_CAMIFREG(0xDC)	/* MSDMA control register */
+
+#elif defined CONFIG_CPU_S3C6400 || defined CONFIG_CPU_S3C6410 
+#define S3C_CIPRYSA1		S3C_CAMIFREG(0x6C)	/* 1st frame start address for preview DMA */
+#define S3C_CIPRYSA2		S3C_CAMIFREG(0x70)	/* 2nd frame start address for preview DMA */
+#define S3C_CIPRYSA3		S3C_CAMIFREG(0x74)	/* 3rd frame start address for preview DMA */
+#define S3C_CIPRYSA4		S3C_CAMIFREG(0x78)	/* 4th frame start address for preview DMA */
+#define S3C_CIPRCBSA1		S3C_CAMIFREG(0x7C)	/* 1st frame start address for preview DMA */
+#define S3C_CIPRCBSA2		S3C_CAMIFREG(0x80)	/* 2nd frame start address for preview DMA */
+#define S3C_CIPRCBSA3		S3C_CAMIFREG(0x84)	/* 3rd frame start address for preview DMA */
+#define S3C_CIPRCBSA4		S3C_CAMIFREG(0x88)	/* 4th frame start address for preview DMA */
+#define S3C_CIPRCRSA1		S3C_CAMIFREG(0x8C)	/* 1st frame start address for preview DMA */
+#define S3C_CIPRCRSA2		S3C_CAMIFREG(0x90)	/* 2nd frame start address for preview DMA */
+#define S3C_CIPRCRSA3		S3C_CAMIFREG(0x94)	/* 3rd frame start address for preview DMA */
+#define S3C_CIPRCRSA4		S3C_CAMIFREG(0x98)	/* 4th frame start address for preview DMA */
+#define S3C_CIPRTRGFMT		S3C_CAMIFREG(0x9C)	/* PREVIEW target format register */
+#define S3C_CIPRCTRL		S3C_CAMIFREG(0xA0)	/* PREVIEW DMA control register */
+#define S3C_CIPRSCPRERATIO	S3C_CAMIFREG(0xA4)	/* PREVIEW pre-scaler control register 1 */
+#define S3C_CIPRSCPREDST	S3C_CAMIFREG(0xA8)	/* PREVIEW pre-scaler control register 2 */
+#define S3C_CIPRSCCTRL		S3C_CAMIFREG(0xAC)	/* PREVIEW main-scaler control register */
+#define S3C_CIPRTAREA		S3C_CAMIFREG(0xB0)	/* PREVIEW DMA target area register */
+#define S3C_CIPRSTATUS		S3C_CAMIFREG(0xB8)	/* PREVIEW status register */
+#define S3C_CIIMGCPT		S3C_CAMIFREG(0xC0)	/* image capture enable register */
+#define S3C_CICOCPTSEQ		S3C_CAMIFREG(0xC4)	/* CODEC capture sequence register */
+#define S3C_CIIMGEFF		S3C_CAMIFREG(0xD0)	/* image effect register */
+#define S3C_MSCOY0SA		S3C_CAMIFREG(0xD4)	/* MSDMA for CODEC Y start address register */
+#define S3C_MSCOCB0SA		S3C_CAMIFREG(0xD8)	/* MSDMA for CODEC CB start address register */
+#define S3C_MSCOCR0SA		S3C_CAMIFREG(0xDC)	/* MSDMA for CODEC CR start address register */
+#define S3C_MSCOY0END		S3C_CAMIFREG(0xE0)	/* MSDMA for CODEC Y end address register */
+#define S3C_MSCOCB0END		S3C_CAMIFREG(0xE4)	/* MSDMA for CODEC CB end address register */
+#define S3C_MSCOCR0END		S3C_CAMIFREG(0xE8)	/* MSDMA for CODEC CR end address register */
+#define S3C_MSCOYOFF		S3C_CAMIFREG(0xEC)	/* MSDMA for CODEC Y offset register */
+#define S3C_MSCOCBOFF		S3C_CAMIFREG(0xF0)	/* MSDMA for CODEC CB offset register */
+#define S3C_MSCOCROFF		S3C_CAMIFREG(0xF4)	/* MSDMA for CODEC CR offset register */
+#define S3C_MSCOWIDTH		S3C_CAMIFREG(0xF8)	/* MSDMA for CODEC source image width register */
+#define S3C_MSCOCTRL		S3C_CAMIFREG(0xFC)	/* MSDMA for CODEC control register */
+#define S3C_MSPRY0SA		S3C_CAMIFREG(0x100)	/* MSDMA for PREVIEW Y0 start address register */
+#define S3C_MSPRCB0SA		S3C_CAMIFREG(0x104)	/* MSDMA for PREVIEW CB0 start address register */
+#define S3C_MSPRCR0SA		S3C_CAMIFREG(0x108)	/* MSDMA for PREVIEW CR0 start address register */
+#define S3C_MSPRY0END		S3C_CAMIFREG(0x10C)	/* MSDMA for PREVIEW Y0 end address register */
+#define S3C_MSPRCB0END		S3C_CAMIFREG(0x110)	/* MSDMA for PREVIEW CB0 end address register */
+#define S3C_MSPRCR0END		S3C_CAMIFREG(0x114)	/* MSDMA for PREVIEW CR0 end address register */
+#define S3C_MSPRYOFF		S3C_CAMIFREG(0x118)	/* MSDMA for PREVIEW Y offset register */
+#define S3C_MSPRCBOFF		S3C_CAMIFREG(0x11C)	/* MSDMA for PREVIEW CB offset register */
+#define S3C_MSPRCROFF		S3C_CAMIFREG(0x120)	/* MSDMA for PREVIEW CR offset register */
+#define S3C_MSPRWIDTH		S3C_CAMIFREG(0x124)	/* MSDMA for PREVIEW source image width register */
+#define S3C_CIMSCTRL		S3C_CAMIFREG(0x128)	/* MSDMA for PREVIEW control register */
+#define S3C_CICOSCOSY		S3C_CAMIFREG(0x12C)	/* CODEC scan line Y offset register */
+#define S3C_CICOSCOSCB		S3C_CAMIFREG(0x130)	/* CODEC scan line CB offset register */
+#define S3C_CICOSCOSCR		S3C_CAMIFREG(0x134)	/* CODEC scan line CR offset register */
+#define S3C_CIPRSCOSY		S3C_CAMIFREG(0x138)	/* PREVIEW scan line Y offset register */
+#define S3C_CIPRSCOSCB		S3C_CAMIFREG(0x13C)	/* PREVIEW scan line CB offset register */
+#define S3C_CIPRSCOSCR		S3C_CAMIFREG(0x140)	/* PREVIEW scan line CR offset register */
+#endif
+
+#endif /* ___ASM_ARCH_REGS_CAMIF_H */
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-iic.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-iic.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-iic.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-iic.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* arch/arm/mach-s3c2410/include/mach/regs-iic.h
+/* linux/arch/arm/plat-s3c/include/plat/regs-iic.h
  *
  * Copyright (c) 2004 Simtec Electronics <linux@simtec.co.uk>
  *		http://www.simtec.co.uk/products/SWLINUX/
@@ -7,50 +7,48 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * S3C2410 I2C Controller
+ * S3C I2C Controller
 */
 
 #ifndef __ASM_ARCH_REGS_IIC_H
 #define __ASM_ARCH_REGS_IIC_H __FILE__
 
-/* see s3c2410x user guide, v1.1, section 9 (p447) for more info */
+#define S3C_IICREG(x) (x)
 
-#define S3C2410_IICREG(x) (x)
+#define S3C_IICCON	S3C_IICREG(0x00)
+#define S3C_IICSTAT	S3C_IICREG(0x04)
+#define S3C_IICADD	S3C_IICREG(0x08)
+#define S3C_IICDS	S3C_IICREG(0x0C)
+#define S3C_IICLC	S3C_IICREG(0x10)
+
+#define S3C_IICCON_ACKEN		(1<<7)
+#define S3C_IICCON_TXDIV_16		(0<<6)
+#define S3C_IICCON_TXDIV_512		(1<<6)
+#define S3C_IICCON_IRQEN		(1<<5)
+#define S3C_IICCON_IRQPEND		(1<<4)
+#define S3C_IICCON_SCALE(x)		((x)&15)
+#define S3C_IICCON_SCALEMASK		(0xf)
+
+#define S3C_IICSTAT_MASTER_RX		(2<<6)
+#define S3C_IICSTAT_MASTER_TX		(3<<6)
+#define S3C_IICSTAT_SLAVE_RX		(0<<6)
+#define S3C_IICSTAT_SLAVE_TX		(1<<6)
+#define S3C_IICSTAT_MODEMASK		(3<<6)
+
+#define S3C_IICSTAT_START		(1<<5)
+#define S3C_IICSTAT_BUSBUSY		(1<<5)
+#define S3C_IICSTAT_TXRXEN		(1<<4)
+#define S3C_IICSTAT_ARBITR		(1<<3)
+#define S3C_IICSTAT_ASSLAVE		(1<<2)
+#define S3C_IICSTAT_ADDR0		(1<<1)
+#define S3C_IICSTAT_LASTBIT		(1<<0)
+
+#define S3C_IICLC_SDA_DELAY0		(0 << 0)
+#define S3C_IICLC_SDA_DELAY5		(1 << 0)
+#define S3C_IICLC_SDA_DELAY10		(2 << 0)
+#define S3C_IICLC_SDA_DELAY15		(3 << 0)
+#define S3C_IICLC_SDA_DELAY_MASK	(3 << 0)
 
-#define S3C2410_IICCON    S3C2410_IICREG(0x00)
-#define S3C2410_IICSTAT   S3C2410_IICREG(0x04)
-#define S3C2410_IICADD    S3C2410_IICREG(0x08)
-#define S3C2410_IICDS     S3C2410_IICREG(0x0C)
-#define S3C2440_IICLC	  S3C2410_IICREG(0x10)
-
-#define S3C2410_IICCON_ACKEN		(1<<7)
-#define S3C2410_IICCON_TXDIV_16		(0<<6)
-#define S3C2410_IICCON_TXDIV_512	(1<<6)
-#define S3C2410_IICCON_IRQEN		(1<<5)
-#define S3C2410_IICCON_IRQPEND		(1<<4)
-#define S3C2410_IICCON_SCALE(x)		((x)&15)
-#define S3C2410_IICCON_SCALEMASK	(0xf)
-
-#define S3C2410_IICSTAT_MASTER_RX	(2<<6)
-#define S3C2410_IICSTAT_MASTER_TX	(3<<6)
-#define S3C2410_IICSTAT_SLAVE_RX	(0<<6)
-#define S3C2410_IICSTAT_SLAVE_TX	(1<<6)
-#define S3C2410_IICSTAT_MODEMASK	(3<<6)
-
-#define S3C2410_IICSTAT_START		(1<<5)
-#define S3C2410_IICSTAT_BUSBUSY		(1<<5)
-#define S3C2410_IICSTAT_TXRXEN		(1<<4)
-#define S3C2410_IICSTAT_ARBITR		(1<<3)
-#define S3C2410_IICSTAT_ASSLAVE		(1<<2)
-#define S3C2410_IICSTAT_ADDR0		(1<<1)
-#define S3C2410_IICSTAT_LASTBIT		(1<<0)
-
-#define S3C2410_IICLC_SDA_DELAY0	(0 << 0)
-#define S3C2410_IICLC_SDA_DELAY5	(1 << 0)
-#define S3C2410_IICLC_SDA_DELAY10	(2 << 0)
-#define S3C2410_IICLC_SDA_DELAY15	(3 << 0)
-#define S3C2410_IICLC_SDA_DELAY_MASK	(3 << 0)
-
-#define S3C2410_IICLC_FILTER_ON		(1<<2)
+#define S3C_IICLC_FILTER_ON		(1<<2)
 
 #endif /* __ASM_ARCH_REGS_IIC_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-iis.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-iis.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-iis.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-iis.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,210 @@
+/* linux/arch/arm/plat-s3c/include/plat/regs-iis.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C64XX IIS register definition
+*/
+
+#ifndef __ASM_ARCH_REGS_IIS_H
+#define __ASM_ARCH_REGS_IIS_H
+
+#define S3C64XX_IIS0REG(x)	((x) + S3C64XX_PA_IIS_V40)
+
+//#define S3C_IIS0CON		S3C64XX_IIS0REG(0x00)
+//#define S3C_IIS0MOD		S3C64XX_IIS0REG(0x04)
+//#define S3C_IIS0FIC		S3C64XX_IIS0REG(0x08)
+//#define S3C_IIS0PSR		S3C64XX_IIS0REG(0x0C)
+//#define S3C_IIS0TXD		S3C64XX_IIS0REG(0x10)
+//#define S3C_IIS0RXD		S3C64XX_IIS0REG(0x14)
+
+#define S3C64XX_IIS0CON		(0x00)
+#define S3C64XX_IIS0MOD		(0x04)
+#define S3C64XX_IIS0FIC		(0x08)
+#define S3C64XX_IIS0PSR		(0x0C)
+#define S3C64XX_IIS0TXD		(0x10)
+#define S3C64XX_IIS0RXD		(0x14)
+
+#define S3C64XX_IISCON      (0x00)
+#define S3C64XX_IISMOD      (0x04)
+#define S3C64XX_IISFIC      (0x08)
+#define S3C64XX_IISPSR      (0x0C)
+#define S3C64XX_IISTXD      (0x10)
+#define S3C64XX_IISRXD      (0x14)
+
+#define S3C64XX_IISCON_LRINDEX		(1<<8)
+#define S3C64XX_IISCON_TXFIFORDY	(1<<7)
+#define S3C64XX_IISCON_RXFIFORDY	(1<<6)
+#define S3C64XX_IISCON_TXDMAEN		(1<<5)
+#define S3C64XX_IISCON_RXDMAEN		(1<<4)
+#define S3C64XX_IISCON_TXIDLE		(1<<3)
+#define S3C64XX_IISCON_RXIDLE		(1<<2)
+#define S3C64XX_IISCON_PSCEN		(1<<1)
+#define S3C64XX_IISCON_IISEN		(1<<0)
+
+#define S3C64XX_IISCON_I2SACTIVE    (0x1<<0)
+#define S3C64XX_IISCON_RXDMACTIVE   (0x1<<1)
+#define S3C64XX_IISCON_TXDMACTIVE   (0x1<<2)
+#define S3C64XX_IISCON_RXCHPAUSE    (0x1<<3)
+#define S3C64XX_IISCON_TXCHPAUSE    (0x1<<4)
+#define S3C64XX_IISCON_RXDMAPAUSE   (0x1<<5)
+#define S3C64XX_IISCON_TXDMAPAUSE   (0x1<<6)
+#define S3C64XX_IISCON_FRXFULL      (0x1<<7)
+#ifdef IIS_V40
+#define S3C64XX_IISCON_FTX0FULL     (0x1<<8)
+#else
+#define S3C64XX_IISCON_FTXFULL      (0x1<<8)
+#endif
+#define S3C64XX_IISCON_FRXEMPT      (0x1<<9)
+#define S3C64XX_IISCON_FTX0EMPT     (0x1<<10)
+#define S3C64XX_IISCON_LRI      (0x1<<11)
+#ifdef IIS_V40
+#define S3C64XX_IISCON_FTX1FULL     (0x1<<12)
+#define S3C64XX_IISCON_FTX2FULL     (0x1<<13)
+#define S3C64XX_IISCON_FTX1EMPT     (0x1<<14)
+#define S3C64XX_IISCON_FTX2EMPT     (0x1<<15)
+#endif
+#define S3C64XX_IISCON_FTXURINTEN   (0x1<<16)
+#define S3C64XX_IISCON_FTXURSTATUS  (0x1<<17)
+#ifndef IIS_V40
+#define S3C6410_IISCON_FRXORINTEN   (0x1<<18)
+#define S3C6410_IISCON_FRXORSTATUS  (0x1<<19)
+#endif
+
+//#define S3C64XX_IISMOD_MPLL	  (1<<9)
+#define S3C64XX_IISMOD_MPLL		(0x01<<10)
+#define S3C64XX_IISMOD_SLAVE		(1<<8)
+#define S3C64XX_IISMOD_NOXFER		(0<<6)
+#define S3C64XX_IISMOD_RXMODE		(1<<6)
+#define S3C64XX_IISMOD_TXMODE		(2<<6)
+#define S3C64XX_IISMOD_TXRXMODE		(3<<6)
+#define S3C64XX_IISMOD_LR_LLOW		(0<<5)
+#define S3C64XX_IISMOD_LR_RLOW		(1<<5)
+//#define S3C64XX_IISMOD_IIS		(0<<4)
+//#define S3C64XX_IISMOD_MSB		(1<<4)
+//#define S3C64XX_IISMOD_8BIT		(0<<3)
+//#define S3C64XX_IISMOD_16BIT		(1<<3)
+#define S3C64XX_IISMOD_BITMASK		(1<<3)
+//#define S3C64XX_IISMOD_256FS		(0<<2)
+//#define S3C64XX_IISMOD_384FS		(1<<2)
+//#define S3C64XX_IISMOD_16FS		(0<<0)
+//#define S3C64XX_IISMOD_32FS		(1<<0)
+//#define S3C64XX_IISMOD_48FS		(2<<0)
+#define S3C64XX_IISMOD_FS_MASK		(3<<0)
+
+#define S3C64XX_IISMOD_TXRMASK      (3<<8)
+#define S3C64XX_IISMOD_TX       (0<<8)
+#define S3C64XX_IISMOD_RX       (1<<8)
+#define S3C64XX_IISMOD_TXRX     (2<<8)
+
+#define S3C64XX_IISMOD_IMSMASK      (3<<10)
+#define S3C64XX_IISMOD_MSTPCLK      (0<<10)
+#define S3C64XX_IISMOD_MSTCLKAUDIO  (1<<10)
+#define S3C64XX_IISMOD_SLVPCLK      (2<<10)
+#define S3C64XX_IISMOD_SLVI2SCLK    (3<<10)
+
+#define S3C64XX_IISMOD_CDCLKCON     (1<<12)
+
+#define S3C64XX_IIS0MOD_DCE_MASK	(0x3<<16)
+#define S3C64XX_IIS0MOD_DCE_SD2		(0x1<<17)
+#define S3C64XX_IIS0MOD_DCE_SD1		(0x1<<16)
+#define S3C64XX_IIS0MOD_BLC_MASK	(0x3<<13)
+#define S3C64XX_IIS0MOD_BLC_16BIT	(0x0<<13)
+#define S3C64XX_IIS0MOD_BLC_08BIT	(0x1<<13)
+#define S3C64XX_IIS0MOD_BLC_24BIT	(0x2<<13)
+#define S3C64XX_IIS0MOD_CLK_MASK	(0x7<<10)
+#define S3C64XX_IIS0MOD_INTERNAL_CLK	(0x0<<12)
+#define S3C64XX_IIS0MOD_EXTERNAL_CLK	(0x1<<12)
+#define S3C64XX_IIS0MOD_IMS_INTERNAL_MASTER	(0x0<<10)
+#define S3C64XX_IIS0MOD_IMS_EXTERNAL_MASTER	(0x1<<10)
+#define S3C64XX_IIS0MOD_IMS_PCLK_SLAVE	(0x2<<10)
+#define S3C64XX_IIS0MOD_IMS_I2SCLK_SLAVE	(0x3<<10)
+#define S3C64XX_IIS0MOD_MODE_MASK	(0x3<<8)
+#define S3C64XX_IIS0MOD_TXMODE		(0x0<<8)
+#define S3C64XX_IIS0MOD_RXMODE		(0x1<<8)
+#define S3C64XX_IIS0MOD_TXRXMODE	(0x2<<8)
+#define S3C64XX_IIS0MOD_FM_MASK		(0x3<<5)
+#define S3C64XX_IIS0MOD_IIS		(0x0<<5)
+#define S3C64XX_IIS0MOD_MSB		(0x1<<5)
+#define S3C64XX_IIS0MOD_LSB		(0x2<<5)
+#define S3C64XX_IIS0MOD_FS_MASK		(0x3<<3)
+#define S3C64XX_IIS0MOD_768FS		(0x3<<3)
+#define S3C64XX_IIS0MOD_384FS		(0x2<<3)
+#define S3C64XX_IIS0MOD_512FS		(0x1<<3)
+#define S3C64XX_IIS0MOD_256FS		(0x0<<3)
+#define S3C64XX_IIS0MOD_BFS_MASK	(0x3<<1)
+#define S3C64XX_IIS0MOD_48FS		(0x1<<1)
+#define S3C64XX_IIS0MOD_32FS		(0x0<<1)
+
+
+#define S3C64XX_IISMOD_BFSMASK      (3<<1)
+#define S3C64XX_IISMOD_32FS     (0<<1)
+#define S3C64XX_IISMOD_48FS     (1<<1)
+#define S3C64XX_IISMOD_16FS     (2<<1)
+#define S3C64XX_IISMOD_24FS     (3<<1)
+
+#define S3C64XX_IISMOD_RFSMASK      (3<<3)
+#define S3C64XX_IISMOD_256FS        (0<<3)
+#define S3C64XX_IISMOD_512FS        (1<<3)
+#define S3C64XX_IISMOD_384FS        (2<<3)
+#define S3C64XX_IISMOD_768FS        (3<<3)
+
+#define S3C64XX_IISMOD_SDFMASK      (3<<5)
+#define S3C64XX_IISMOD_IIS      (0<<5)
+#define S3C64XX_IISMOD_MSB      (1<<5)
+#define S3C64XX_IISMOD_LSB      (2<<5)
+#define S3C64XX_IISMOD_LRP      (1<<7)
+
+#define S3C64XX_IISMOD_BLCMASK      (3<<13)
+#define S3C64XX_IISMOD_16BIT        (0<<13)
+#define S3C64XX_IISMOD_8BIT     (1<<13)
+#define S3C64XX_IISMOD_24BIT        (2<<13)
+
+//#define S3C64XX_IISPSR			(0x08)
+#define S3C64XX_IISPSR_INTMASK		(31<<5)
+#define S3C64XX_IISPSR_INTSHIFT		(5)
+#define S3C64XX_IISPSR_EXTMASK		(31<<0)
+#define S3C64XX_IISPSR_EXTSHFIT		(0)
+
+
+#define S3C64XX_IISPSR_PSVALA       (0x3f<<8)
+#define S3C64XX_IISPSR_PSRAEN       (1<<15)
+
+#define S3C64XX_IISFCON		(0x0c)
+
+#define S3C64XX_IISFCON_TXDMA		(1<<15)
+#define S3C64XX_IISFCON_RXDMA		(1<<14)
+#define S3C64XX_IISFCON_TXENABLE	(1<<13)
+#define S3C64XX_IISFCON_RXENABLE	(1<<12)
+#define S3C64XX_IISFCON_TXMASK		(0x3f << 6)
+#define S3C64XX_IISFCON_TXSHIFT		(6)
+#define S3C64XX_IISFCON_RXMASK		(0x3f)
+#define S3C64XX_IISFCON_RXSHIFT		(0)
+
+#define S3C64XX_IISFIFO		(0x10)
+#define S3C64XX_IISFIFORX	(0x14)
+
+#define S3C64XX_IIS0CON_I2SACTIVE	(0x1<<0)
+#define S3C64XX_IIS0CON_RXDMACTIVE	(0x1<<1)
+#define S3C64XX_IIS0CON_I2SACTIVE	(0x1<<0)
+#define S3C64XX_IIS0CON_TXDMACTIVE	(0x1<<2)
+
+#define S3C64XX_IIS_TX_FLUSH	(0x1<<15)
+#define S3C64XX_IIS_RX_FLUSH	(0x1<<7)
+
+#define S3C64XX_IISCON_FTXURINTEN 	(0x1<<16)
+
+#define S3C64XX_IIS0MOD_24BIT		(0x2<<13)
+#define S3C64XX_IIS0MOD_8BIT		(0x1<<13)
+#define S3C64XX_IIS0MOD_16BIT		(0x0<<13)
+
+#define S3C64XX_IISFIC_FRXCNTMSK    (0xf<<0)
+#define S3C64XX_IISFIC_RFLUSH       (1<<7)
+#define S3C64XX_IISFIC_FTX0CNTMSK   (0xf<<8)
+#define S3C64XX_IISFIC_TFLUSH       (1<<15)
+
+#endif /* __ASM_ARCH_REGS_IIS_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-keypad.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-keypad.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-keypad.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-keypad.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,45 @@
+/* linux/arch/arm/plat-s3c64xx/include/plat/regs-keypad.h
+ *
+ *
+ * S3C6410 Key Interface register definitions
+ *
+ * Kim Kyoungil, Copyright (c) 2006-2009 Samsung Electronics
+ *      http://www.samsungsemi.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef __ASM_ARCH_REGS_KEYPAD_H
+#define __ASM_ARCH_REGS_KEYPAD_H
+
+/* 
+ * Keypad Interface
+ */
+#define S3C_KEYPADREG(x)	(x)
+
+#define S3C_KEYIFCON		S3C_KEYPADREG(0x00)
+#define S3C_KEYIFSTSCLR		S3C_KEYPADREG(0x04)
+#define S3C_KEYIFCOL		S3C_KEYPADREG(0x08)
+#define S3C_KEYIFROW		S3C_KEYPADREG(0x0C)
+#define S3C_KEYIFFC		S3C_KEYPADREG(0x10)
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+#define KEYCOL_DMASK		(0xffff)
+#define KEYROW_DMASK		(0xff)
+#define	INT_F_EN		(1<<0)	/*falling edge(key-pressed) interuppt enable*/
+#define	INT_R_EN		(1<<1)	/*rising edge(key-released) interuppt enable*/
+#define	DF_EN			(1<<2)	/*debouncing filter enable*/
+#define	FC_EN			(1<<3)	/*filter clock enable*/
+#define	KEYIFCON_INIT		(KEYIFCON_CLEAR |INT_F_EN|INT_R_EN|DF_EN|FC_EN)
+#define KEYIFSTSCLR_CLEAR	(0xffff)
+
+#else
+#error "Not supported S3C Configuration!!"
+#endif
+
+#endif /* __ASM_ARCH_REGS_KEYPAD_H */
+
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-lcd.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-lcd.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-lcd.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-lcd.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,519 @@
+/* linux/arch/arm/plat-s3c/include/plat/regs-lcd.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+
+#ifndef ___ASM_ARCH_REGS_LCD_H
+#define ___ASM_ARCH_REGS_LCD_H
+
+#include <plat/map-base.h>
+
+/***************************************************************************/
+/* LCD Registers for S3C2443/2450/S3C6400/6410 */
+#define S3C_LCDREG(x)		((x) + S3C_VA_LCD)
+
+/* LCD control registers */
+#define S3C_VIDCON0		S3C_LCDREG(0x00)  	/* Video control 0 register */
+#define S3C_VIDCON1		S3C_LCDREG(0x04)  	/* Video control 1 register */
+
+#if defined(CONFIG_CPU_S3C2443)||defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+#define S3C_VIDTCON0		S3C_LCDREG(0x08)  	/* LCD CONTROL 1 */
+#define S3C_VIDTCON1		S3C_LCDREG(0x0C)  	/* LCD CONTROL 1 */
+#define S3C_VIDTCON2		S3C_LCDREG(0x10) 	/* LCD CONTROL 1 */
+#define S3C_WINCON0		S3C_LCDREG(0x14)  	/* LCD CONTROL 1 */
+#define S3C_WINCON1		S3C_LCDREG(0x18)  	/* LCD CONTROL 1 */
+#define S3C_VIDOSD0A		S3C_LCDREG(0x28)  	/* LCD CONTROL 1 */
+#define S3C_VIDOSD0B		S3C_LCDREG(0x2C)  	/* LCD CONTROL 1 */
+#define S3C_VIDOSD0C		S3C_LCDREG(0x30)  	/* LCD CONTROL 1 */
+#define S3C_VIDOSD1A		S3C_LCDREG(0x34)  	/* LCD CONTROL 1 */
+#define S3C_VIDOSD1B		S3C_LCDREG(0x38)  	/* LCD CONTROL 1 */
+#define S3C_VIDOSD1C		S3C_LCDREG(0x3C)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD0B0	S3C_LCDREG(0x64)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD0B1	S3C_LCDREG(0x68)  	/* LCD CONTROL 1 */
+#define S3C_VIDW01ADD0		S3C_LCDREG(0x6C)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD1B0	S3C_LCDREG(0x7C)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD1B1	S3C_LCDREG(0x80)  	/* LCD CONTROL 1 */
+#define S3C_VIDW01ADD1		S3C_LCDREG(0x84)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD2B0	S3C_LCDREG(0x94)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD2B1	S3C_LCDREG(0x98)  	/* LCD CONTROL 1 */
+#define S3C_VIDW01ADD2		S3C_LCDREG(0x9C)  	/* LCD CONTROL 1 */
+#define S3C_VIDINTCON		S3C_LCDREG(0xAC)  	/* LCD CONTROL 1 */
+#define S3C_W1KEYCON0		S3C_LCDREG(0xB0)  	/* LCD CONTROL 1 */
+#define S3C_W1KEYCON1		S3C_LCDREG(0xB4)  	/* LCD CONTROL 1 */
+#define S3C_WIN0MAP		S3C_LCDREG(0xD0)  	/* LCD CONTROL 1 */
+#define S3C_WIN1MAP		S3C_LCDREG(0xD4)  	/* LCD CONTROL 1 */
+#define S3C_WPALCON		S3C_LCDREG(0xE4)  	/* LCD CONTROL 1 */
+#define S3C_SYSIFCON0		S3C_LCDREG(0x130)  	/* LCD CONTROL 1 */
+#define S3C_SYSIFCON1		S3C_LCDREG(0x134)  	/* LCD CONTROL 1 */
+#define S3C_DITHMODE		S3C_LCDREG(0x138)  	/* LCD CONTROL 1 */
+#define S3C_SIFCCON0		S3C_LCDREG(0x13C)  	/* LCD CONTROL 1 */
+#define S3C_SIFCCON1		S3C_LCDREG(0x140)  	/* LCD CONTROL 1 */
+#define S3C_SIFCCON2		S3C_LCDREG(0x144)  	/* LCD CONTROL 1 */
+#define S3C_CPUTRIGCON2		S3C_LCDREG(0x160)  	/* LCD CONTROL 1 */
+
+#elif defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410) || defined(CONFIG_CPU_S5P6440) || defined(CONFIG_CPU_S5PC100)
+#define S3C_VIDCON2		S3C_LCDREG(0x08)  	/* Video control 2 register */
+#define S3C_PRTCON		S3C_LCDREG(0x0C)	/* Protection control register */
+#define S3C_VIDTCON0		S3C_LCDREG(0x10)  	/* Video time control 0 register */
+#define S3C_VIDTCON1		S3C_LCDREG(0x14)  	/* Video time control 1 register */
+#define S3C_VIDTCON2		S3C_LCDREG(0x18)  	/* Video time control 2 register */
+#define S3C_VIDTCON3		S3C_LCDREG(0x1C)  	/* Video time control 3 register */
+
+#define S3C_WINCON0		S3C_LCDREG(0x20)  	/* Window control 0 register */
+#define S3C_WINCON1		S3C_LCDREG(0x24)  	/* Window control 1 register */
+#define S3C_WINCON2		S3C_LCDREG(0x28)  	/* Window control 2 register */
+#define S3C_WINCON3		S3C_LCDREG(0x2C)  	/* Window control 3 register */
+#define S3C_WINCON4		S3C_LCDREG(0x30)  	/* Window control 4 register*/
+
+
+#define S3C_VIDOSD0A		S3C_LCDREG(0x40)  	/* Video Window 0 position control register */
+#define S3C_VIDOSD0B		S3C_LCDREG(0x44)  	/* Video Window 0 position control register1 */
+#define S3C_VIDOSD0C		S3C_LCDREG(0x48)  	/* Video Window 0 position control register */
+
+#define S3C_VIDOSD1A		S3C_LCDREG(0x50)  	/* Video Window 1 position control register */
+#define S3C_VIDOSD1B		S3C_LCDREG(0x54)  	/* Video Window 1 position control register */
+#define S3C_VIDOSD1C		S3C_LCDREG(0x58)  	/* Video Window 1 position control register */
+#define S3C_VIDOSD1D		S3C_LCDREG(0x5C)  	/* Video Window 1 position control register */
+
+#define S3C_VIDOSD2A		S3C_LCDREG(0x60)  	/* Video Window 2 position control register */
+#define S3C_VIDOSD2B		S3C_LCDREG(0x64)  	/* Video Window 2 position control register */
+#define S3C_VIDOSD2C		S3C_LCDREG(0x68)  	/* Video Window 2 position control register */
+#define S3C_VIDOSD2D		S3C_LCDREG(0x6C)  	/* Video Window 2 position control register */
+
+#define S3C_VIDOSD3A		S3C_LCDREG(0x70)  	/* Video Window 3 position control register */
+#define S3C_VIDOSD3B		S3C_LCDREG(0x74)  	/* Video Window 3 position control register */
+#define S3C_VIDOSD3C		S3C_LCDREG(0x78)  	/* Video Window 3 position control register */
+
+#define S3C_VIDOSD4A		S3C_LCDREG(0x80)  	/* Video Window 4 position control register */
+#define S3C_VIDOSD4B		S3C_LCDREG(0x84)  	/* Video Window 4 position control register */
+#define S3C_VIDOSD4C		S3C_LCDREG(0x88)  	/* Video Window 4 position control register */
+
+#define S3C_VIDW00ADD2B0	S3C_LCDREG(0x94)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD2B1	S3C_LCDREG(0x98)  	/* LCD CONTROL 1 */
+
+#define S3C_VIDW00ADD0B0	S3C_LCDREG(0x0A0) 	/* Window 0 buffer start address register, buffer 0 */
+#define S3C_VIDW00ADD0B1	S3C_LCDREG(0x0A4) 	/* Window 0 buffer start address register, buffer 1 */
+#define S3C_VIDW01ADD0B0	S3C_LCDREG(0x0A8) 	/* Window 1 buffer start address register, buffer 0 */
+#define S3C_VIDW01ADD0B1	S3C_LCDREG(0x0AC) 	/* Window 1 buffer start address register, buffer 1 */
+#define S3C_VIDW02ADD0		S3C_LCDREG(0x0B0) 	/* Window 2 buffer start address register */
+#define S3C_VIDW03ADD0		S3C_LCDREG(0x0B8) 	/* Window 3 buffer start address register */
+#define S3C_VIDW04ADD0		S3C_LCDREG(0x0C0) 	/* Window 4 buffer start address register */
+#define S3C_VIDW00ADD1B0	S3C_LCDREG(0x0D0) 	/* Window 0 buffer end address register, buffer 0 */
+#define S3C_VIDW00ADD1B1	S3C_LCDREG(0x0D4) 	/* Window 0 buffer end address register, buffer 1 */
+#define S3C_VIDW01ADD1B0	S3C_LCDREG(0x0D8) 	/* Window 1 buffer end address register, buffer 0 */
+#define S3C_VIDW01ADD1B1	S3C_LCDREG(0x0DC) 	/* Window 1 buffer end address register, buffer 1 */
+#define S3C_VIDW02ADD1		S3C_LCDREG(0x0E0) 	/* Window 2 buffer end address register */
+#define S3C_VIDW03ADD1		S3C_LCDREG(0x0E8) 	/* Window 3 buffer end address register */
+#define S3C_VIDW04ADD1		S3C_LCDREG(0x0F0) 	/* Window 4 buffer end address register */
+#define S3C_VIDW00ADD2		S3C_LCDREG(0x100) 	/* Window 0 buffer size register */
+#define S3C_VIDW01ADD2		S3C_LCDREG(0x104) 	/* Window 1 buffer size register */
+
+#define S3C_VIDW02ADD2		S3C_LCDREG(0x108) 	/* Window 2 buffer size register */
+#define S3C_VIDW03ADD2		S3C_LCDREG(0x10C) 	/* Window 3 buffer size register */
+#define S3C_VIDW04ADD2		S3C_LCDREG(0x110) 	/* Window 4 buffer size register */
+
+#define S3C_VIDINTCON0		S3C_LCDREG(0x130)	/* Indicate the Video interrupt control register */
+#define S3C_VIDINTCON1		S3C_LCDREG(0x134) 	/* Video Interrupt Pending register */
+#define S3C_W1KEYCON0		S3C_LCDREG(0x140) 	/* Color key control register */
+#define S3C_W1KEYCON1		S3C_LCDREG(0x144) 	/* Color key value ( transparent value) register */
+#define S3C_W2KEYCON0		S3C_LCDREG(0x148) 	/* Color key control register */
+#define S3C_W2KEYCON1		S3C_LCDREG(0x14C) 	/* Color key value (transparent value) register */
+
+#define S3C_W3KEYCON0		S3C_LCDREG(0x150)	/* Color key control register	*/
+#define S3C_W3KEYCON1		S3C_LCDREG(0x154)	/* Color key value (transparent value) register	*/
+#define S3C_W4KEYCON0		S3C_LCDREG(0x158)	/* Color key control register	*/
+#define S3C_W4KEYCON1		S3C_LCDREG(0x15C)	/* Color key value (transparent value) register	*/
+#define S3C_DITHMODE		S3C_LCDREG(0x170)	/* Dithering mode register.	*/
+
+#define S3C_WIN0MAP		S3C_LCDREG(0x180)	/* Window color control	*/
+#define S3C_WIN1MAP		S3C_LCDREG(0x184)	/* Window color control	*/
+#define S3C_WIN2MAP		S3C_LCDREG(0x188)	/* Window color control	*/
+#define S3C_WIN3MAP		S3C_LCDREG(0x18C)	/* Window color control	*/
+#define S3C_WIN4MAP		S3C_LCDREG(0x190)	/* Window color control	*/
+#define S3C_WPALCON		S3C_LCDREG(0x1A0)	/* Window Palette control register	*/
+
+#define S3C_TRIGCON		S3C_LCDREG(0x1A4)	/* I80 / RGB Trigger Control Regiter	*/
+#define S3C_I80IFCONA0		S3C_LCDREG(0x1B0)	/* I80 Interface control 0 for Main LDI	*/
+#define S3C_I80IFCONA1		S3C_LCDREG(0x1B4)	/* I80 Interface control 0 for Sub LDI	*/
+#define S3C_I80IFCONB0		S3C_LCDREG(0x1B8)	/* I80 Inteface control 1 for Main LDI	*/
+#define S3C_I80IFCONB1		S3C_LCDREG(0x1BC)	/* I80 Inteface control 1 for Sub LDI	*/
+#define S3C_LDI_CMDCON0		S3C_LCDREG(0x1D0)	/* I80 Interface LDI Command Control 0	*/
+#define S3C_LDI_CMDCON1		S3C_LCDREG(0x1D4)	/* I80 Interface LDI Command Control 1	*/
+#define S3C_SIFCCON0		S3C_LCDREG(0x1E0)	/* LCD i80 System Interface Command Control 0	*/
+#define S3C_SIFCCON1		S3C_LCDREG(0x1E4)	/* LCD i80 System Interface Command Control 1	*/
+#define S3C_SIFCCON2		S3C_LCDREG(0x1E8)	/* LCD i80 System Interface Command Control 2	*/
+
+#define S3C_LDI_CMD0		S3C_LCDREG(0x280)	/* I80 Inteface LDI Command 0	*/
+#define S3C_LDI_CMD1		S3C_LCDREG(0x284)	/* I80 Inteface LDI Command 1	*/
+#define S3C_LDI_CMD2		S3C_LCDREG(0x288)	/* I80 Inteface LDI Command 2	*/
+#define S3C_LDI_CMD3		S3C_LCDREG(0x28C)	/* I80 Inteface LDI Command 3	*/
+#define S3C_LDI_CMD4		S3C_LCDREG(0x290)	/* I80 Inteface LDI Command 4	*/
+#define S3C_LDI_CMD5		S3C_LCDREG(0x294)	/* I80 Inteface LDI Command 5	*/
+#define S3C_LDI_CMD6		S3C_LCDREG(0x298)	/* I80 Inteface LDI Command 6	*/
+#define S3C_LDI_CMD7		S3C_LCDREG(0x29C)	/* I80 Inteface LDI Command 7	*/
+#define S3C_LDI_CMD8		S3C_LCDREG(0x2A0)	/* I80 Inteface LDI Command 8	*/
+#define S3C_LDI_CMD9		S3C_LCDREG(0x2A4)	/* I80 Inteface LDI Command 9	*/
+#define S3C_LDI_CMD10		S3C_LCDREG(0x2A8)	/* I80 Inteface LDI Command 10	*/
+#define S3C_LDI_CMD11		S3C_LCDREG(0x2AC)	/* I80 Inteface LDI Command 11	*/
+
+#define S3C_W2PDATA01		S3C_LCDREG(0x300)	/* Window 2 Palette Data of the Index 0,1	*/
+#define S3C_W2PDATA23		S3C_LCDREG(0x304)	/* Window 2 Palette Data of the Index 2,3	*/
+#define S3C_W2PDATA45		S3C_LCDREG(0x308)	/* Window 2 Palette Data of the Index 4,5	*/
+#define S3C_W2PDATA67		S3C_LCDREG(0x30C)	/* Window 2 Palette Data of the Index 6,7	*/
+#define S3C_W2PDATA89		S3C_LCDREG(0x310)	/* Window 2 Palette Data of the Index 8,9	*/
+#define S3C_W2PDATAAB		S3C_LCDREG(0x314)	/* Window 2 Palette Data of the Index A, B	*/
+#define S3C_W2PDATACD		S3C_LCDREG(0x318)	/* Window 2 Palette Data of the Index C, D	*/
+#define S3C_W2PDATAEF		S3C_LCDREG(0x31C)	/* Window 2 Palette Data of the Index E, F	*/
+#define S3C_W3PDATA01		S3C_LCDREG(0x320)	/* Window 3 Palette Data of the Index 0,1	*/
+#define S3C_W3PDATA23		S3C_LCDREG(0x324)	/* Window 3 Palette Data of the Index 2,3	*/
+#define S3C_W3PDATA45		S3C_LCDREG(0x328)	/* Window 3 Palette Data of the Index 4,5	*/
+#define S3C_W3PDATA67		S3C_LCDREG(0x32C)	/* Window 3 Palette Data of the Index 6,7	*/
+#define S3C_W3PDATA89		S3C_LCDREG(0x330)	/* Window 3 Palette Data of the Index 8,9	*/
+#define S3C_W3PDATAAB		S3C_LCDREG(0x334)	/* Window 3 Palette Data of the Index A, B	*/
+#define S3C_W3PDATACD		S3C_LCDREG(0x338)	/* Window 3 Palette Data of the Index C, D	*/
+#define S3C_W3PDATAEF		S3C_LCDREG(0x33C)	/* Window 3 Palette Data of the Index E, F	*/
+#define S3C_W4PDATA01		S3C_LCDREG(0x340)	/* Window 3 Palette Data of the Index 0,1	*/
+#define S3C_W4PDATA23		S3C_LCDREG(0x344)	/* Window 3 Palette Data of the Index 2,3	*/
+#endif
+
+#define S3C_TFTPAL2(x)		S3C_LCDREG((0x300 + (x)*4))
+#define S3C_TFTPAL3(x) 		S3C_LCDREG((0x320 + (x)*4))
+#define S3C_TFTPAL4(x)		S3C_LCDREG((0x340 + (x)*4))
+#define S3C_TFTPAL0(x)		S3C_LCDREG((0x400 + (x)*4))
+#define S3C_TFTPAL1(x)		S3C_LCDREG((0x800 + (x)*4))
+
+/*--------------------------------------------------------------*/
+/* Video Main Control 0 register - VIDCON0 */
+#define S3C_VIDCON0_INTERLACE_F_PROGRESSIVE		(0<<29)
+#define S3C_VIDCON0_INTERLACE_F_INTERLACE		(1<<29)
+#define S3C_VIDCON0_INTERLACE_F_MASK			(1<<29)
+#define S3C_VIDCON0_VIDOUT(x)  				(((x)&0x7)<<26)
+#define S3C_VIDCON0_VIDOUT_RGB_IF			(0<<26)
+#define S3C_VIDCON0_VIDOUT_TV				(1<<26)
+#define S3C_VIDCON0_VIDOUT_I80IF0			(2<<26)
+#define S3C_VIDCON0_VIDOUT_I80IF1			(3<<26)
+#define S3C_VIDCON0_VIDOUT_TVNRGBIF 			(4<<26)
+#define S3C_VIDCON0_VIDOUT_TVNI80IF0			(6<<26)
+#define S3C_VIDCON0_VIDOUT_TVNI80IF1			(7<<26)
+#define S3C_VIDCON0_VIDOUT_MASK				(7<<26)
+#define S3C_VIDCON0_L1_DATA16(x)  			(((x)&0x7)<<23)
+#define S3C_VIDCON0_L1_DATA16_SUB_16_MODE		(0<<23)
+#define S3C_VIDCON0_L1_DATA16_SUB_16PLUS2_MODE		(1<<23)
+#define S3C_VIDCON0_L1_DATA16_SUB_9PLUS9_MODE 		(2<<23)
+#define S3C_VIDCON0_L1_DATA16_SUB_16PLUS8_MODE		(3<<23)
+#define S3C_VIDCON0_L1_DATA16_SUB_18_MODE		(4<<23)
+#define S3C_VIDCON0_L0_DATA16(x)  			(((x)&0x7)<<20)
+#define S3C_VIDCON0_L0_DATA16_MAIN_16_MODE		(0<<20)
+#define S3C_VIDCON0_L0_DATA16_MAIN_16PLUS2_MODE		(1<<20)
+#define S3C_VIDCON0_L0_DATA16_MAIN_9PLUS9_MODE		(2<<20)
+#define S3C_VIDCON0_L0_DATA16_MAIN_16PLUS8_MODE		(3<<20)
+#define S3C_VIDCON0_L0_DATA16_MAIN_18_MODE		(4<<20)
+#define S3C_VIDCON0_PNRMODE(x)  			(((x)&0x3)<<17)
+#define S3C_VIDCON0_PNRMODE_RGB_P			(0<<17)
+#define S3C_VIDCON0_PNRMODE_BGR_P			(1<<17)
+#define S3C_VIDCON0_PNRMODE_RGB_S			(2<<17)
+#define S3C_VIDCON0_PNRMODE_BGR_S			(3<<17)
+#define S3C_VIDCON0_PNRMODE_MASK			(3<<17)
+#define S3C_VIDCON0_CLKVALUP_ALWAYS 			(0<<16)
+#define S3C_VIDCON0_CLKVALUP_ST_FRM 			(1<<16)
+#define S3C_VIDCON0_CLKVAL_F(x)				(((x)&0xFF)<<6)
+#define S3C_VIDCON0_VCLKEN_ENABLE			(1<<5)
+#define S3C_VIDCON0_CLKDIR_DIVIDED   			(1<<4)
+#define S3C_VIDCON0_CLKDIR_DIRECTED  			(0<<4)
+#define S3C_VIDCON0_CLKSEL(x)   			(((x)&0x3)<<2)
+#define S3C_VIDCON0_CLKSEL_F_HCLK	  		(0<<2)
+#define S3C_VIDCON0_ENVID_ENABLE	    		(1 << 1)	/* 0:Disable 1:Enable LCD video output and logic immediatly */
+#define S3C_VIDCON0_ENVID_DISABLE	    		(0 << 1)	/* 0:Disable 1:Enable LCD video output and logic immediatly */
+#define S3C_VIDCON0_ENVID_F_ENABLE     			(1 << 0)	/* 0:Dis 1:Ena wait until Current frame end. */
+#define S3C_VIDCON0_ENVID_F_DISABLE     		(0 << 0)	/* 0:Dis 1:Ena wait until Current frame end. */
+
+/* Video Main Control 1 register - VIDCON1 */
+#define S3C_VIDCON1_IVCLK_FALL_EDGE 			(0<<7)
+#define S3C_VIDCON1_IVCLK_RISE_EDGE 			(1<<7)
+#define S3C_VIDCON1_IHSYNC_NORMAL			(0<<6)
+#define S3C_VIDCON1_IHSYNC_INVERT			(1<<6)
+#define S3C_VIDCON1_IVSYNC_NORMAL			(0<<5)
+#define S3C_VIDCON1_IVSYNC_INVERT			(1<<5)
+#define S3C_VIDCON1_IVDEN_NORMAL			(0<<4)
+#define S3C_VIDCON1_IVDEN_INVERT			(1<<4)
+
+/* Video Main Control 2 register - VIDCON2 */
+#define S3C_VIDCON2_EN601_DISABLE			(0<<23)
+#define S3C_VIDCON2_EN601_ENABLE			(1<<23)
+#define S3C_VIDCON2_EN601_MASK				(1<<23)
+#define S3C_VIDCON2_TVFORMATSEL0_HARDWARE		(0<<14)
+#define S3C_VIDCON2_TVFORMATSEL0_SOFTWARE		(1<<14)
+#define S3C_VIDCON2_TVFORMATSEL0_MASK			(1<<14)
+#define S3C_VIDCON2_TVFORMATSEL1_RGB			(0<<12)
+#define S3C_VIDCON2_TVFORMATSEL1_YUV422			(1<<12)
+#define S3C_VIDCON2_TVFORMATSEL1_YUV444			(2<<12)
+#define S3C_VIDCON2_TVFORMATSEL1_MASK			(0x3<<12)
+#define S3C_VIDCON2_ORGYUV_YCBCR			(0<<8)
+#define S3C_VIDCON2_ORGYUV_CBCRY			(1<<8)
+#define S3C_VIDCON2_ORGYUV_MASK				(1<<8)
+#define S3C_VIDCON2_YUVORD_CBCR				(0<<7)
+#define S3C_VIDCON2_YUVORD_CRCB				(1<<7)
+#define S3C_VIDCON2_YUVORD_MASK				(1<<7)
+
+/* VIDEO Time Control 0 register - VIDTCON0 */
+#define S3C_VIDTCON0_VBPDE(x)				(((x)&0xFF)<<24)
+#define S3C_VIDTCON0_VBPD(x)				(((x)&0xFF)<<16)
+#define S3C_VIDTCON0_VFPD(x) 				(((x)&0xFF)<<8)
+#define S3C_VIDTCON0_VSPW(x) 				(((x)&0xFF)<<0)
+
+/* VIDEO Time Control 1 register - VIDTCON1 */
+#define S3C_VIDTCON1_VFPDE(x)				(((x)&0xFF)<<24)
+#define S3C_VIDTCON1_HBPD(x) 				(((x)&0xFF)<<16)
+#define S3C_VIDTCON1_HFPD(x) 				(((x)&0xFF)<<8)
+#define S3C_VIDTCON1_HSPW(x) 				(((x)&0xFF)<<0)
+
+/* VIDEO Time Control 2 register - VIDTCON2 */
+#define S3C_VIDTCON2_LINEVAL(x)  			(((x)&0x7FF)<<11) /* these bits determine the vertical size of lcd panel */
+#define S3C_VIDTCON2_HOZVAL(x)   			(((x)&0x7FF)<<0) /* these bits determine the horizontal size of lcd panel*/
+
+
+/* Window 0~4 Control register - WINCONx */
+#define S3C_WINCONx_WIDE_NARROW(x)			(((x)&0x3)<<26)
+#define S3C_WINCONx_ENLOCAL_DMA				(0<<22)
+#define S3C_WINCONx_ENLOCAL				(1<<22)
+#define S3C_WINCONx_ENLOCAL_MASK			(1<<22)
+#define S3C_WINCONx_BUFSEL_0				(0<<20)
+#define S3C_WINCONx_BUFSEL_1				(1<<20)
+#define S3C_WINCONx_BUFSEL_MASK				(1<<20)
+#define S3C_WINCONx_BUFAUTOEN_DISABLE			(0<<19)
+#define S3C_WINCONx_BUFAUTOEN_ENABLE			(1<<19)
+#define S3C_WINCONx_BUFAUTOEN_MASK			(1<<19)
+#define S3C_WINCONx_BITSWP_DISABLE			(0<<18)
+#define S3C_WINCONx_BITSWP_ENABLE			(1<<18)
+#define S3C_WINCONx_BYTSWP_DISABLE			(0<<17)
+#define S3C_WINCONx_BYTSWP_ENABLE			(1<<17)
+#define S3C_WINCONx_HAWSWP_DISABLE			(0<<16)
+#define S3C_WINCONx_HAWSWP_ENABLE			(1<<16)
+#define S3C_WINCONx_WSWP_DISABLE			(0<<15)
+#define S3C_WINCONx_WSWP_ENABLE				(1<<15)
+#define S3C_WINCONx_INRGB_RGB		   		(0<<13)
+#define S3C_WINCONx_INRGB_YUV		 		(1<<13)
+#define S3C_WINCONx_INRGB_MASK				(1<<13)
+#define S3C_WINCONx_BURSTLEN_16WORD			(0<<9)
+#define S3C_WINCONx_BURSTLEN_8WORD			(1<<9)
+#define S3C_WINCONx_BURSTLEN_4WORD			(2<<9)
+#define S3C_WINCONx_BLD_PIX_PLANE			(0<<6)
+#define S3C_WINCONx_BLD_PIX_PIXEL			(1<<6)
+#define S3C_WINCONx_BLD_PIX_MASK			(1<<6)
+#define S3C_WINCONx_BPPMODE_F_1BPP			(0<<2)
+#define S3C_WINCONx_BPPMODE_F_2BPP			(1<<2)
+#define S3C_WINCONx_BPPMODE_F_4BPP			(2<<2)
+#define S3C_WINCONx_BPPMODE_F_8BPP_PAL			(3<<2)
+#define S3C_WINCONx_BPPMODE_F_8BPP_NOPAL		(4<<2)
+#define S3C_WINCONx_BPPMODE_F_16BPP_565			(5<<2)
+#define S3C_WINCONx_BPPMODE_F_16BPP_A555		(6<<2)
+#define S3C_WINCONx_BPPMODE_F_18BPP_666			(8<<2)
+#define S3C_WINCONx_BPPMODE_F_24BPP_888			(11<<2)
+#define S3C_WINCONx_BPPMODE_F_24BPP_A887		(0xc<<2)
+#define S3C_WINCONx_BPPMODE_F_25BPP_A888		(0xd<<2)
+#define S3C_WINCONx_BPPMODE_F_28BPP_A888		(0xd<<2)
+#define S3C_WINCONx_BPPMODE_F_MASK			(0xf<<2)
+#define S3C_WINCONx_ALPHA_SEL_0				(0<<1)
+#define S3C_WINCONx_ALPHA_SEL_1				(1<<1)
+#define S3C_WINCONx_ALPHA_SEL_MASK			(1<<1)
+#define S3C_WINCONx_ENWIN_F_DISABLE 			(0<<0)
+#define S3C_WINCONx_ENWIN_F_ENABLE			(1<<0)
+
+/* Window 1-2 Control register - WINCON1 */
+#define S3C_WINCON1_LOCALSEL_TV				(0<<23)
+#define S3C_WINCON1_LOCALSEL_CAMERA			(1<<23)
+#define S3C_WINCON1_LOCALSEL_MASK			(1<<23)
+#define S3C_WINCON2_LOCALSEL_TV				(0<<23)
+#define S3C_WINCON2_LOCALSEL_CAMERA			(1<<23)
+#define S3C_WINCON2_LOCALSEL_MASK			(1<<23)
+
+/* Window 0~4 Position Control A register - VIDOSDxA */
+#define S3C_VIDOSDxA_OSD_LTX_F(x)			(((x)&0x7FF)<<11)
+#define S3C_VIDOSDxA_OSD_LTY_F(x)			(((x)&0x7FF)<<0)
+
+/* Window 0~4 Position Control B register - VIDOSDxB */
+#define S3C_VIDOSDxB_OSD_RBX_F(x)			(((x)&0x7FF)<<11)
+#define S3C_VIDOSDxB_OSD_RBY_F(x)			(((x)&0x7FF)<<0)
+
+/* Window 0 Position Control C register - VIDOSD0C */
+#define  S3C_VIDOSD0C_OSDSIZE(x)			(((x)&0xFFFFFF)<<0)
+
+/* Window 1~4 Position Control C register - VIDOSDxC */
+#define S3C_VIDOSDxC_ALPHA0_R(x)			(((x)&0xF)<<20)
+#define S3C_VIDOSDxC_ALPHA0_G(x)			(((x)&0xF)<<16)
+#define S3C_VIDOSDxC_ALPHA0_B(x)			(((x)&0xF)<<12)
+#define S3C_VIDOSDxC_ALPHA1_R(x)			(((x)&0xF)<<8)
+#define S3C_VIDOSDxC_ALPHA1_G(x)			(((x)&0xF)<<4)
+#define S3C_VIDOSDxC_ALPHA1_B(x)			(((x)&0xF)<<0)
+
+/* Window 1~2 Position Control D register - VIDOSDxD */
+#define  S3C_VIDOSDxD_OSDSIZE(x)			(((x)&0xFFFFFF)<<0)
+
+/* Frame buffer Start Address register - VIDWxxADD0 */
+#define S3C_VIDWxxADD0_VBANK_F(x) 			(((x)&0xFF)<<23) /* the end address of the LCD frame buffer. */
+#define S3C_VIDWxxADD0_VBASEU_F(x)			(((x)&0xFFFFFF)<<0) /* Virtual screen offset size (the number of byte). */
+
+/* Frame buffer End Address register - VIDWxxADD1 */
+#define S3C_VIDWxxADD1_VBASEL_F(x) 			(((x)&0xFFFFFF)<<0)  /* the end address of the LCD frame buffer. */
+
+/* Frame buffer Size register - VIDWxxADD2 */
+#define S3C_VIDWxxADD2_OFFSIZE_F(x)  			(((x)&0x1FFF)<<13) /* Virtual screen offset size (the number of byte). */
+#define S3C_VIDWxxADD2_PAGEWIDTH_F(x)			(((x)&0x1FFF)<<0) /* Virtual screen page width (the number of byte). */
+
+/* VIDEO Interrupt Control 0 register - VIDINTCON0 */
+#define S3C_VIDINTCON0_FIFOINTERVAL(x)			(((x)&0x3F)<<20)
+#define S3C_VIDINTCON0_SYSMAINCON_DISABLE		(0<<19)
+#define S3C_VIDINTCON0_SYSMAINCON_ENABLE		(1<<19)
+#define S3C_VIDINTCON0_SYSSUBCON_DISABLE		(0<<18)
+#define S3C_VIDINTCON0_SYSSUBCON_ENABLE			(1<<18)
+#define S3C_VIDINTCON0_SYSIFDONE_DISABLE		(0<<17)
+#define S3C_VIDINTCON0_SYSIFDONE_ENABLE			(1<<17)
+#define S3C_VIDINTCON0_FRAMESEL0_BACK			(0<<15)
+#define S3C_VIDINTCON0_FRAMESEL0_VSYNC 			(1<<15)
+#define S3C_VIDINTCON0_FRAMESEL0_ACTIVE			(2<<15)
+#define S3C_VIDINTCON0_FRAMESEL0_FRONT 			(3<<15)
+#define S3C_VIDINTCON0_FRAMESEL0_MASK 			(3<<15)
+#define S3C_VIDINTCON0_FRAMESEL1_NONE			(0<<13)
+#define S3C_VIDINTCON0_FRAMESEL1_BACK			(1<<13)
+#define S3C_VIDINTCON0_FRAMESEL1_VSYNC 			(2<<13)
+#define S3C_VIDINTCON0_FRAMESEL1_FRONT 			(3<<13)
+#define S3C_VIDINTCON0_INTFRMEN_DISABLE			(0<<12)
+#define S3C_VIDINTCON0_INTFRMEN_ENABLE 			(1<<12)
+#define S3C_VIDINTCON0_FRAMEINT_MASK			(0x1F<<12)
+#define S3C_VIDINTCON0_FIFOSEL_WIN4			(1<<11)
+#define S3C_VIDINTCON0_FIFOSEL_WIN3			(1<<10)
+#define S3C_VIDINTCON0_FIFOSEL_WIN2			(1<<9)
+#define S3C_VIDINTCON0_FIFOSEL_WIN1			(1<<6)
+#define S3C_VIDINTCON0_FIFOSEL_WIN0			(1<<5)
+#define S3C_VIDINTCON0_FIFOSEL_ALL			(0x73<<5)
+#define S3C_VIDINTCON0_FIFOLEVEL_25			(0<<2)
+#define S3C_VIDINTCON0_FIFOLEVEL_50			(1<<2)
+#define S3C_VIDINTCON0_FIFOLEVEL_75			(2<<2)
+#define S3C_VIDINTCON0_FIFOLEVEL_EMPTY 			(3<<2)
+#define S3C_VIDINTCON0_FIFOLEVEL_FULL			(4<<2)
+#define S3C_VIDINTCON0_INTFIFOEN_DISABLE		(0<<1)
+#define S3C_VIDINTCON0_INTFIFOEN_ENABLE			(1<<1)
+#define S3C_VIDINTCON0_INTEN_DISABLE			(0<<0)
+#define S3C_VIDINTCON0_INTEN_ENABLE			(1<<0)
+#define S3C_VIDINTCON0_INTEN_MASK			(1<<0)
+
+/* VIDEO Interrupt Control 1 register - VIDINTCON1 */
+#define S3C_VIDINTCON1_INTI80PEND			(0<<2)
+#define S3C_VIDINTCON1_INTFRMPEND			(1<<1)
+#define S3C_VIDINTCON1_INTFIFOPEND			(1<<0)
+
+/* WIN 1~4 Color Key 0 register - WxKEYCON0 */
+#define S3C_WxKEYCON0_KEYBLEN_DISABLE 			(0<<26)
+#define S3C_WxKEYCON0_KEYBLEN_ENABLE			(1<<26)
+#define S3C_WxKEYCON0_KEYEN_F_DISABLE 			(0<<25)
+#define S3C_WxKEYCON0_KEYEN_F_ENABLE			(1<<25)
+#define S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE		(0<<24)
+#define S3C_WxKEYCON0_DIRCON_MATCH_BG_IMAGE		(1<<24)
+#define S3C_WxKEYCON0_COMPKEY(x)			(((x)&0xFFFFFF)<<0)
+
+/* WIN 1~4 Color Key 1 register - WxKEYCON1 */
+#define S3C_WxKEYCON1_COLVAL(x)				(((x)&0xFFFFFF)<<0)
+
+/* Dithering Control 1 register - DITHMODE */
+#define S3C_DITHMODE_RDITHPOS_8BIT			(0<<5)
+#define S3C_DITHMODE_RDITHPOS_6BIT			(1<<5)
+#define S3C_DITHMODE_RDITHPOS_5BIT			(2<<5)
+#define S3C_DITHMODE_GDITHPOS_8BIT			(0<<3)
+#define S3C_DITHMODE_GDITHPOS_6BIT			(1<<3)
+#define S3C_DITHMODE_GDITHPOS_5BIT			(2<<3)
+#define S3C_DITHMODE_BDITHPOS_8BIT			(0<<1)
+#define S3C_DITHMODE_BDITHPOS_6BIT			(1<<1)
+#define S3C_DITHMODE_BDITHPOS_5BIT			(2<<1)
+#define S3C_DITHMODE_RGB_DITHPOS_MASK			(0x3f<<1)
+#define S3C_DITHMODE_DITHERING_DISABLE			(0<<0)
+#define S3C_DITHMODE_DITHERING_ENABLE			(1<<0)
+#define S3C_DITHMODE_DITHERING_MASK			(1<<0)
+
+/* Window 0~4 Color map register - WINxMAP */
+#define S3C_WINxMAP_MAPCOLEN_F_ENABLE			(1<<24)
+#define S3C_WINxMAP_MAPCOLEN_F_DISABLE			(0<<24)
+#define S3C_WINxMAP_MAPCOLOR				(((x)&0xFFFFFF)<<0)
+
+/* Window Palette Control register - WPALCON */
+#define S3C_WPALCON_PALUPDATEEN				(1<<9)
+#define S3C_WPALCON_W4PAL_16BIT_A	 		(1<<8)		/* A:5:5:5 */
+#define S3C_WPALCON_W4PAL_16BIT	 			(0<<8)		/*  5:6:5 */
+#define S3C_WPALCON_W3PAL_16BIT_A	 		(1<<7)		/* A:5:5:5 */
+#define S3C_WPALCON_W3PAL_16BIT	 			(0<<7)		/*  5:6:5 */
+#define S3C_WPALCON_W2PAL_16BIT_A	 		(1<<6)		/* A:5:5:5 */
+#define S3C_WPALCON_W2PAL_16BIT	 			(0<<6)		/*  5:6:5 */
+#define S3C_WPALCON_W1PAL_25BIT_A	 		(0<<3)		/* A:8:8:8 */
+#define S3C_WPALCON_W1PAL_24BIT				(1<<3)		/*  8:8:8 */
+#define S3C_WPALCON_W1PAL_19BIT_A			(2<<3)		/* A:6:6:6 */
+#define S3C_WPALCON_W1PAL_18BIT_A	 		(3<<3)		/* A:6:6:5 */
+#define S3C_WPALCON_W1PAL_18BIT				(4<<3)		/*  6:6:6 */
+#define S3C_WPALCON_W1PAL_16BIT_A	 		(5<<3)		/* A:5:5:5 */
+#define S3C_WPALCON_W1PAL_16BIT	 			(6<<3)		/*  5:6:5 */
+#define S3C_WPALCON_W0PAL_25BIT_A	 		(0<<0)		/* A:8:8:8 */
+#define S3C_WPALCON_W0PAL_24BIT				(1<<0)		/*  8:8:8 */
+#define S3C_WPALCON_W0PAL_19BIT_A			(2<<0)		/* A:6:6:6 */
+#define S3C_WPALCON_W0PAL_18BIT_A	 		(3<<0)		/* A:6:6:5 */
+#define S3C_WPALCON_W0PAL_18BIT				(4<<0)		/*  6:6:6 */
+#define S3C_WPALCON_W0PAL_16BIT_A	 		(5<<0)		/* A:5:5:5 */
+#define S3C_WPALCON_W0PAL_16BIT	 			(6<<0)		/*  5:6:5 */
+
+/* I80/RGB Trigger Control register - TRIGCON */
+#define S3C_TRIGCON_SWFRSTATUS_REQUESTED		(1<<2)
+#define S3C_TRIGCON_SWFRSTATUS_NOT_REQUESTED		(0<<2)
+#define S3C_TRIGCON_SWTRGCMD				(1<<1)
+#define S3C_TRIGCON_TRGMODE_ENABLE			(1<<0)
+#define S3C_TRIGCON_TRGMODE_DISABLE			(0<<0)
+
+/* LCD I80 Interface Control 0 register - I80IFCONA0 */
+#define S3C_I80IFCONAx_LCD_CS_SETUP(x) 			(((x)&0xF)<<16)
+#define S3C_I80IFCONAx_LCD_WR_SETUP(x) 			(((x)&0xF)<<12)
+#define S3C_I80IFCONAx_LCD_WR_ACT(x)			(((x)&0xF)<<8)
+#define S3C_I80IFCONAx_LCD_WR_HOLD(x)			(((x)&0xF)<<4)
+
+
+/***************************************************************************/
+/*HOST IF registers */
+/* Host I/F A - */
+#define S3C_HOSTIFAREG(x)				((x) + S3C64XX_VA_HOSTIFA)
+#define S3C_HOSTIFAREG_PHYS(x)				((x) + S3C64XX_PA_HOSTIFA)
+
+/* Host I/F B - Modem I/F */
+#define S3C_HOSTIFBREG(x)				((x) + S3C64XX_VA_HOSTIFB)
+#define S3C_HOSTIFBREG_PHYS(x)				((x) + S3C64XX_PA_HOSTIFB)
+
+#define S3C_HOSTIFB_INT2AP				S3C_HOSTIFBREG(0x8000)
+#define S3C_HOSTIFB_INT2MSM				S3C_HOSTIFBREG(0x8004)
+#define S3C_HOSTIFB_MIFCON				S3C_HOSTIFBREG(0x8008)
+#define S3C_HOSTIFB_MIFPCON				S3C_HOSTIFBREG(0x800C)
+#define S3C_HOSTIFB_MSMINTCLR				S3C_HOSTIFBREG(0x8010)
+
+#define S3C_HOSTIFB_MIFCON_INT2MSM_DIS			(0x0<<3)
+#define S3C_HOSTIFB_MIFCON_INT2MSM_EN			(0x1<<3)
+#define S3C_HOSTIFB_MIFCON_INT2AP_DIS			(0x0<<2)
+#define S3C_HOSTIFB_MIFCON_INT2AP_EN			(0x1<<2)
+#define S3C_HOSTIFB_MIFCON_WAKEUP_DIS			(0x0<<1)
+#define S3C_HOSTIFB_MIFCON_WAKEUP_EN			(0x1<<1)
+
+#define S3C_HOSTIFB_MIFPCON_SEL_VSYNC_DIR_OUT		(0x0<<5)
+#define S3C_HOSTIFB_MIFPCON_SEL_VSYNC_DIR_IN		(0x1<<5)
+#define S3C_HOSTIFB_MIFPCON_INT2M_LEVEL_DIS		(0x0<<4)
+#define S3C_HOSTIFB_MIFPCON_INT2M_LEVEL_EN		(0x1<<4)
+#define S3C_HOSTIFB_MIFPCON_SEL_NORMAL			(0x0<<3)
+#define S3C_HOSTIFB_MIFPCON_SEL_BYPASS			(0x1<<3)
+
+#define S3C_HOSTIFB_MIFPCON_SEL_RS0			0
+#define S3C_HOSTIFB_MIFPCON_SEL_RS1			1
+#define S3C_HOSTIFB_MIFPCON_SEL_RS2			2
+#define S3C_HOSTIFB_MIFPCON_SEL_RS3			3
+#define S3C_HOSTIFB_MIFPCON_SEL_RS4			4
+#define S3C_HOSTIFB_MIFPCON_SEL_RS5			5
+#define S3C_HOSTIFB_MIFPCON_SEL_RS6			6
+
+#define S3C_WINCONx_ENLOCAL_POST                    	(1<<22)
+#endif
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-nand.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-nand.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-nand.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-nand.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* arch/arm/mach-s3c2410/include/mach/regs-nand.h
+/* linux/arch/arm/plat-s3c/include/plat/regs-nand.h
  *
  * Copyright (c) 2004,2005 Simtec Electronics <linux@simtec.co.uk>
  *		      http://www.simtec.co.uk/products/SWLINUX/
@@ -117,7 +117,56 @@
 #define S3C2412_NFECCERR_MULTIBIT	(2)
 #define S3C2412_NFECCERR_ECCAREA	(3)
 
+/* for s3c_nand.c */
+#define S3C_NFCONF		S3C2410_NFREG(0x00)
+#define S3C_NFCONT		S3C2410_NFREG(0x04)
+#define S3C_NFCMMD		S3C2410_NFREG(0x08)
+#define S3C_NFADDR		S3C2410_NFREG(0x0c)
+#define S3C_NFDATA8		S3C2410_NFREG(0x10)
+#define S3C_NFDATA		S3C2410_NFREG(0x10)
+#define S3C_NFMECCDATA0		S3C2410_NFREG(0x14)
+#define S3C_NFMECCDATA1		S3C2410_NFREG(0x18)
+#define S3C_NFSECCDATA		S3C2410_NFREG(0x1c)
+#define S3C_NFSBLK		S3C2410_NFREG(0x20)
+#define S3C_NFEBLK		S3C2410_NFREG(0x24)
+#define S3C_NFSTAT		S3C2410_NFREG(0x28)
+#define S3C_NFMECCERR0		S3C2410_NFREG(0x2c)
+#define S3C_NFMECCERR1		S3C2410_NFREG(0x30)
+#define S3C_NFMECC0		S3C2410_NFREG(0x34)
+#define S3C_NFMECC1		S3C2410_NFREG(0x38)
+#define S3C_NFSECC		S3C2410_NFREG(0x3c)
+#define S3C_NFMLCBITPT		S3C2410_NFREG(0x40)
+
+#define S3C_NFCONF_NANDBOOT	(1<<31)
+#define S3C_NFCONF_ECCCLKCON	(1<<30)
+#define S3C_NFCONF_ECC_MLC	(1<<24)
+#define	S3C_NFCONF_ECC_1BIT	(0<<23)
+#define	S3C_NFCONF_ECC_4BIT	(2<<23)
+#define	S3C_NFCONF_ECC_8BIT	(1<<23)
+#define S3C_NFCONF_TACLS(x)	((x)<<12)
+#define S3C_NFCONF_TWRPH0(x)	((x)<<8)
+#define S3C_NFCONF_TWRPH1(x)	((x)<<4)
+#define S3C_NFCONF_ADVFLASH	(1<<3)
+#define S3C_NFCONF_PAGESIZE	(1<<2)
+#define S3C_NFCONF_ADDRCYCLE	(1<<1)
+#define S3C_NFCONF_BUSWIDTH	(1<<0)
+
+#define S3C_NFCONT_ECC_ENC	(1<<18)
+#define S3C_NFCONT_LOCKTGHT	(1<<17)
+#define S3C_NFCONT_LOCKSOFT	(1<<16)
+#define S3C_NFCONT_MECCLOCK	(1<<7)
+#define S3C_NFCONT_SECCLOCK	(1<<6)
+#define S3C_NFCONT_INITMECC	(1<<5)
+#define S3C_NFCONT_INITSECC	(1<<4)
+#define S3C_NFCONT_nFCE1	(1<<2)
+#define S3C_NFCONT_nFCE0	(1<<1)
+#define S3C_NFCONT_INITECC	(S3C_NFCONT_INITSECC | S3C_NFCONT_INITMECC)
+
+#define S3C_NFSTAT_ECCENCDONE	(1<<7)
+#define S3C_NFSTAT_ECCDECDONE	(1<<6)
+#define S3C_NFSTAT_BUSY		(1<<0)
 
+#define S3C_NFECCERR0_ECCBUSY	(1<<31)
 
 #endif /* __ASM_ARM_REGS_NAND */
 
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-pp.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-pp.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-pp.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-pp.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,80 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-hsmmc.h
+ *
+ * Copyright (c) 2004 Samsung Electronics 
+ *		http://www.samsung.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C HSMMC Controller
+*/
+
+#ifndef __ASM_ARCH_REGS_PP_H
+#define __ASM_ARCH_REGS_PP_H __FILE__
+
+#define S3C_VPP(x)	((x))
+
+#define S3C_VPP_MODE 				S3C_VPP(0x00)
+#define S3C_VPP_PRESCALE_RATIO 		S3C_VPP(0x04)
+#define S3C_VPP_PRESCALEIMGSIZE 	S3C_VPP(0x08)
+#define S3C_VPP_SRCIMGSIZE 			S3C_VPP(0x0C)
+#define S3C_VPP_MAINSCALE_H_RATIO 	S3C_VPP(0x10)
+#define S3C_VPP_MAINSCALE_V_RATIO 	S3C_VPP(0x14)
+#define S3C_VPP_DSTIMGSIZE 			S3C_VPP(0x18)
+#define S3C_VPP_PRESCALE_SHFACTOR 	S3C_VPP(0x1C)
+#define S3C_VPP_ADDRSTART_Y 		S3C_VPP(0x20)
+#define S3C_VPP_ADDRSTART_CB 		S3C_VPP(0x24)
+#define S3C_VPP_ADDRSTART_CR 		S3C_VPP(0x28)
+#define S3C_VPP_ADDRSTART_RGB 		S3C_VPP(0x2C)
+#define S3C_VPP_ADDREND_Y 			S3C_VPP(0x30)
+#define S3C_VPP_ADDREND_CB 			S3C_VPP(0x34)
+#define S3C_VPP_ADDREND_CR 			S3C_VPP(0x38)
+#define S3C_VPP_ADDREND_RGB 		S3C_VPP(0x3C)	
+#define S3C_VPP_OFFSET_Y 			S3C_VPP(0x40)
+#define S3C_VPP_OFFSET_CB 			S3C_VPP(0x44)
+#define S3C_VPP_OFFSET_CR 			S3C_VPP(0x48)
+#define S3C_VPP_OFFSET_RGB 			S3C_VPP(0x4C)	
+#define S3C_VPP_NXTADDRSTART_Y 		S3C_VPP(0x54)
+#define S3C_VPP_NXTADDRSTART_CB 	S3C_VPP(0x58)
+#define S3C_VPP_NXTADDRSTART_CR 	S3C_VPP(0x5C)
+#define S3C_VPP_NXTADDRSTART_RGB 	S3C_VPP(0x60)
+#define S3C_VPP_NXTADDREND_Y 		S3C_VPP(0x64)
+#define S3C_VPP_NXTADDREND_CB 		S3C_VPP(0x68)
+#define S3C_VPP_NXTADDREND_CR 		S3C_VPP(0x6C)
+#define S3C_VPP_NXTADDREND_RGB 		S3C_VPP(0x70)	
+#define S3C_VPP_ADDRSTART_OCB 		S3C_VPP(0x74)
+#define S3C_VPP_ADDRSTART_OCR 		S3C_VPP(0x78)
+#define S3C_VPP_ADDREND_OCB 		S3C_VPP(0x7C)
+#define S3C_VPP_ADDREND_OCR 		S3C_VPP(0x80)
+#define S3C_VPP_OFFSET_OCB 			S3C_VPP(0x84)
+#define S3C_VPP_OFFSET_OCR 			S3C_VPP(0x88)
+#define S3C_VPP_NXTADDRSTART_OCB 	S3C_VPP(0x8C)
+#define S3C_VPP_NXTADDRSTART_OCR 	S3C_VPP(0x90)
+#define S3C_VPP_NXTADDREND_OCB 		S3C_VPP(0x94)
+#define S3C_VPP_NXTADDREND_OCR 		S3C_VPP(0x98)
+#define S3C_VPP_POSTENVID 			S3C_VPP(0x9C)
+#define S3C_VPP_MODE_2 				S3C_VPP(0xA0)
+
+//POSTENVID
+#define S3C_POSTENVID_ENABLE	(0x1<<31) // khlee
+#define S3C_POSTENVID_DISABLE	(0x0<<31) 
+
+//MODE Control register
+#define S3C_MODE_AUTOLOAD_ENABLE         (0x1<<14)
+#define S3C_MODE_POST_INT_ENABLE         (0x1<<7)
+#define S3C_MODE_POST_PENDING            (0x1<<6)
+#define S3C_MODE_IRQ_LEVEL               (0x1<<5)
+#define S3C_MODE_H_CLK_INPUT              (0x0<<2)
+#define S3C_MODE_EXT_CLK_0_INPUT          (0x1<<2)
+#define S3C_MODE_EXT_CLK_1_INPUT          (0x3<<2)
+
+//MODE Control register 2
+#define S3C_MODE2_ADDR_CHANGE_ENABLE      (0x0<<4)
+#define S3C_MODE2_ADDR_CHANGE_DISABLE     (0x1<<4)
+#define S3C_MODE2_CHANGE_AT_FIELD_END     (0x0<<3)
+#define S3C_MODE2_CHANGE_AT_FRAME_END     (0x1<<3)
+#define S3C_MODE2_SOFTWARE_TRIGGER        (0x0<<0)
+#define S3C_MODE2_HARDWARE_TRIGGER        (0x1<<0)
+
+#endif /* __ASM_ARCH_REGS_HSMMC_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-rtc.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-rtc.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-rtc.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-rtc.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* arch/arm/mach-s3c2410/include/mach/regs-rtc.h
+/* linux/arch/arm/plat-s3c/include/plat/regs-rtc.h
  *
  * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
  *		      http://www.simtec.co.uk/products/SWLINUX/
@@ -13,49 +13,69 @@
 #ifndef __ASM_ARCH_REGS_RTC_H
 #define __ASM_ARCH_REGS_RTC_H __FILE__
 
-#define S3C2410_RTCREG(x) (x)
-
-#define S3C2410_RTCCON	      S3C2410_RTCREG(0x40)
-#define S3C2410_RTCCON_RTCEN  (1<<0)
-#define S3C2410_RTCCON_CLKSEL (1<<1)
-#define S3C2410_RTCCON_CNTSEL (1<<2)
-#define S3C2410_RTCCON_CLKRST (1<<3)
-
-#define S3C2410_TICNT	      S3C2410_RTCREG(0x44)
-#define S3C2410_TICNT_ENABLE  (1<<7)
-
-#define S3C2410_RTCALM	      S3C2410_RTCREG(0x50)
-#define S3C2410_RTCALM_ALMEN  (1<<6)
-#define S3C2410_RTCALM_YEAREN (1<<5)
-#define S3C2410_RTCALM_MONEN  (1<<4)
-#define S3C2410_RTCALM_DAYEN  (1<<3)
-#define S3C2410_RTCALM_HOUREN (1<<2)
-#define S3C2410_RTCALM_MINEN  (1<<1)
-#define S3C2410_RTCALM_SECEN  (1<<0)
-
-#define S3C2410_RTCALM_ALL \
-  S3C2410_RTCALM_ALMEN | S3C2410_RTCALM_YEAREN | S3C2410_RTCALM_MONEN |\
-  S3C2410_RTCALM_DAYEN | S3C2410_RTCALM_HOUREN | S3C2410_RTCALM_MINEN |\
-  S3C2410_RTCALM_SECEN
-
-
-#define S3C2410_ALMSEC	      S3C2410_RTCREG(0x54)
-#define S3C2410_ALMMIN	      S3C2410_RTCREG(0x58)
-#define S3C2410_ALMHOUR	      S3C2410_RTCREG(0x5c)
-
-#define S3C2410_ALMDATE	      S3C2410_RTCREG(0x60)
-#define S3C2410_ALMMON	      S3C2410_RTCREG(0x64)
-#define S3C2410_ALMYEAR	      S3C2410_RTCREG(0x68)
-
-#define S3C2410_RTCRST	      S3C2410_RTCREG(0x6c)
-
-#define S3C2410_RTCSEC	      S3C2410_RTCREG(0x70)
-#define S3C2410_RTCMIN	      S3C2410_RTCREG(0x74)
-#define S3C2410_RTCHOUR	      S3C2410_RTCREG(0x78)
-#define S3C2410_RTCDATE	      S3C2410_RTCREG(0x7c)
-#define S3C2410_RTCDAY	      S3C2410_RTCREG(0x80)
-#define S3C2410_RTCMON	      S3C2410_RTCREG(0x84)
-#define S3C2410_RTCYEAR	      S3C2410_RTCREG(0x88)
+#define S3C_RTCREG(x) (x)
 
+#define S3C_INTP	      S3C_RTCREG(0x30)
+#define S3C_INTP_ALM	(1<<1)
+#define S3C_INTP_TIC	(1<<0)
+
+#define S3C_RTCCON	      S3C_RTCREG(0x40)
+#define S3C_RTCCON_RTCEN  (1<<0)
+#define S3C_RTCCON_CLKSEL (1<<1)
+#define S3C_RTCCON_CNTSEL (1<<2)
+#define S3C_RTCCON_CLKRST (1<<3)
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+#define S3C_MAX_CNT	32768
+#define S3C_RTCCON_TICEN	(1<<8)
+#define S3C_RTC_TICNT	S3C_RTCREG(0x40)
+#else
+#define S3C_INTP_ALM	(1<<1)
+#define S3C_MAX_CNT	128
+#define S3C_RTCCON_TICEN  (1<<7)
+#define S3C_RTC_TICNT	S3C_RTCREG(0x44)
+#endif
+
+/* Common Reg for samsung AP*/
+#define S3C_INTP	S3C_RTCREG(0x30)
+#define S3C_INTP_ALM	(1<<1)
+#define S3C_INTP_TIC	(1<<0)
+
+
+#define S3C_TICNT	      S3C_RTCREG(0x44)
+#define S3C_TICNT_ENABLE  (1<<7)
+
+#define S3C_RTCALM	S3C_RTCREG(0x50)
+#define S3C_RTCALM_ALMEN  (1<<6)
+#define S3C_RTCALM_YEAREN (1<<5)
+#define S3C_RTCALM_MONEN  (1<<4)
+#define S3C_RTCALM_DAYEN  (1<<3)
+#define S3C_RTCALM_HOUREN (1<<2)
+#define S3C_RTCALM_MINEN  (1<<1)
+#define S3C_RTCALM_SECEN  (1<<0)
+
+#define S3C_RTCALM_ALL \
+  S3C_RTCALM_ALMEN | S3C_RTCALM_YEAREN | S3C_RTCALM_MONEN |\
+  S3C_RTCALM_DAYEN | S3C_RTCALM_HOUREN | S3C_RTCALM_MINEN |\
+  S3C_RTCALM_SECEN
+
+
+#define S3C_ALMSEC	      S3C_RTCREG(0x54)
+#define S3C_ALMMIN	      S3C_RTCREG(0x58)
+#define S3C_ALMHOUR	      S3C_RTCREG(0x5c)
+
+#define S3C_ALMDATE	      S3C_RTCREG(0x60)
+#define S3C_ALMMON	      S3C_RTCREG(0x64)
+#define S3C_ALMYEAR	      S3C_RTCREG(0x68)
+
+#define S3C_RTCRST	      S3C_RTCREG(0x6c)
+
+#define S3C_RTCSEC	      S3C_RTCREG(0x70)
+#define S3C_RTCMIN	      S3C_RTCREG(0x74)
+#define S3C_RTCHOUR	      S3C_RTCREG(0x78)
+#define S3C_RTCDATE	      S3C_RTCREG(0x7c)
+#define S3C_RTCDAY	      S3C_RTCREG(0x80)
+#define S3C_RTCMON	      S3C_RTCREG(0x84)
+#define S3C_RTCYEAR	      S3C_RTCREG(0x88)
 
 #endif /* __ASM_ARCH_REGS_RTC_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-serial.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-serial.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-serial.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-serial.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* arch/arm/mach-s3c2410/include/mach/regs-serial.h
+/* linux/arch/arm/plat-s3c/include/plat/regs-serial.h
  *
  *  From linux/include/asm-arm/hardware/serial_s3c2410.h
  *
@@ -32,6 +32,17 @@
 #ifndef __ASM_ARM_REGS_SERIAL_H
 #define __ASM_ARM_REGS_SERIAL_H
 
+#if defined(CONFIG_PLAT_S3C64XX)
+#define S3C24XX_VA_UART0      (S3C_VA_UART)
+#define S3C24XX_VA_UART1      (S3C_VA_UART + 0x400)
+#define S3C24XX_VA_UART2      (S3C_VA_UART + 0x800)
+#define S3C24XX_VA_UART3      (S3C_VA_UART + 0xC00)
+
+#define S3C2410_PA_UART0      (S3C24XX_PA_UART)
+#define S3C2410_PA_UART1      (S3C24XX_PA_UART + 0x400)
+#define S3C2410_PA_UART2      (S3C24XX_PA_UART + 0x800)
+#define S3C2443_PA_UART3      (S3C24XX_PA_UART + 0xC00)
+#else
 #define S3C24XX_VA_UART0      (S3C_VA_UART)
 #define S3C24XX_VA_UART1      (S3C_VA_UART + 0x4000 )
 #define S3C24XX_VA_UART2      (S3C_VA_UART + 0x8000 )
@@ -41,70 +52,52 @@
 #define S3C2410_PA_UART1      (S3C24XX_PA_UART + 0x4000 )
 #define S3C2410_PA_UART2      (S3C24XX_PA_UART + 0x8000 )
 #define S3C2443_PA_UART3      (S3C24XX_PA_UART + 0xC000 )
+#endif
 
-#define S3C2410_URXH	  (0x24)
-#define S3C2410_UTXH	  (0x20)
-#define S3C2410_ULCON	  (0x00)
-#define S3C2410_UCON	  (0x04)
-#define S3C2410_UFCON	  (0x08)
-#define S3C2410_UMCON	  (0x0C)
-#define S3C2410_UBRDIV	  (0x28)
-#define S3C2410_UTRSTAT	  (0x10)
-#define S3C2410_UERSTAT	  (0x14)
-#define S3C2410_UFSTAT	  (0x18)
-#define S3C2410_UMSTAT	  (0x1C)
-
-#define S3C2410_LCON_CFGMASK	  ((0xF<<3)|(0x3))
-
-#define S3C2410_LCON_CS5	  (0x0)
-#define S3C2410_LCON_CS6	  (0x1)
-#define S3C2410_LCON_CS7	  (0x2)
-#define S3C2410_LCON_CS8	  (0x3)
-#define S3C2410_LCON_CSMASK	  (0x3)
-
-#define S3C2410_LCON_PNONE	  (0x0)
-#define S3C2410_LCON_PEVEN	  (0x5 << 3)
-#define S3C2410_LCON_PODD	  (0x4 << 3)
-#define S3C2410_LCON_PMASK	  (0x7 << 3)
-
-#define S3C2410_LCON_STOPB	  (1<<2)
-#define S3C2410_LCON_IRM          (1<<6)
-
-#define S3C2440_UCON_CLKMASK	  (3<<10)
-#define S3C2440_UCON_PCLK	  (0<<10)
-#define S3C2440_UCON_UCLK	  (1<<10)
-#define S3C2440_UCON_PCLK2	  (2<<10)
-#define S3C2440_UCON_FCLK	  (3<<10)
-#define S3C2443_UCON_EPLL	  (3<<10)
-
-#define S3C6400_UCON_CLKMASK	(3<<10)
-#define S3C6400_UCON_PCLK	(0<<10)
-#define S3C6400_UCON_PCLK2	(2<<10)
-#define S3C6400_UCON_UCLK0	(1<<10)
-#define S3C6400_UCON_UCLK1	(3<<10)
-
-#define S3C2440_UCON2_FCLK_EN	  (1<<15)
-#define S3C2440_UCON0_DIVMASK	  (15 << 12)
-#define S3C2440_UCON1_DIVMASK	  (15 << 12)
-#define S3C2440_UCON2_DIVMASK	  (7 << 12)
-#define S3C2440_UCON_DIVSHIFT	  (12)
-
-#define S3C2412_UCON_CLKMASK	(3<<10)
-#define S3C2412_UCON_UCLK	(1<<10)
-#define S3C2412_UCON_USYSCLK	(3<<10)
-#define S3C2412_UCON_PCLK	(0<<10)
-#define S3C2412_UCON_PCLK2	(2<<10)
-
-#define S3C2410_UCON_UCLK	  (1<<10)
-#define S3C2410_UCON_SBREAK	  (1<<4)
-
-#define S3C2410_UCON_TXILEVEL	  (1<<9)
-#define S3C2410_UCON_RXILEVEL	  (1<<8)
-#define S3C2410_UCON_TXIRQMODE	  (1<<2)
-#define S3C2410_UCON_RXIRQMODE	  (1<<0)
-#define S3C2410_UCON_RXFIFO_TOI	  (1<<7)
-#define S3C2443_UCON_RXERR_IRQEN  (1<<6)
-#define S3C2443_UCON_LOOPBACK	  (1<<5)
+#define S3C_URXH	  (0x24)
+#define S3C_UTXH	  (0x20)
+#define S3C_ULCON	  (0x00)
+#define S3C_UCON	  (0x04)
+#define S3C_UFCON	  (0x08)
+#define S3C_UMCON	  (0x0C)
+#define S3C_UTRSTAT	  (0x10)
+#define S3C_UERSTAT	  (0x14)
+#define S3C_UFSTAT	  (0x18)
+#define S3C_UMSTAT	  (0x1C)
+#define S3C_UBRDIV	  (0x28)
+#define S3C_UDIVSLOT  (0x2C)
+#define S3C_UINTMSK  (0x38)
+
+#define S3C_LCON_CFGMASK	  ((0xF<<3)|(0x3))
+
+#define S3C_LCON_CS5	  (0x0)
+#define S3C_LCON_CS6	  (0x1)
+#define S3C_LCON_CS7	  (0x2)
+#define S3C_LCON_CS8	  (0x3)
+#define S3C_LCON_CSMASK	  (0x3)
+
+#define S3C_LCON_PNONE	  (0x0)
+#define S3C_LCON_PEVEN	  (0x5 << 3)
+#define S3C_LCON_PODD	  (0x4 << 3)
+#define S3C_LCON_PMASK	  (0x7 << 3)
+
+#define S3C_LCON_STOPB	  (1<<2)
+#define S3C_LCON_IRM          (1<<6)
+
+#define S3C64XX_UCON_CLKMASK	(3<<10)
+#define S3C64XX_UCON_PCLK	(0<<10)
+#define S3C64XX_UCON_PCLK2	(2<<10)
+#define S3C64XX_UCON_UCLK0	(1<<10)
+#define S3C64XX_UCON_UCLK1	(3<<10)
+
+#define S3C_UCON_UCLK	  (1<<10)
+#define S3C_UCON_SBREAK	  (1<<4)
+
+#define S3C_UCON_TXILEVEL	  (1<<9)
+#define S3C_UCON_RXILEVEL	  (1<<8)
+#define S3C_UCON_TXIRQMODE	  (1<<2)
+#define S3C_UCON_RXIRQMODE	  (1<<0)
+#define S3C_UCON_RXFIFO_TOI	  (1<<7)
 
 #define S3C2410_UCON_DEFAULT	  (S3C2410_UCON_TXILEVEL  | \
 				   S3C2410_UCON_RXILEVEL  | \
@@ -117,20 +110,9 @@
 #define S3C2410_UFCON_RXTRIG8	  (1<<4)
 #define S3C2410_UFCON_RXTRIG12	  (2<<4)
 
-/* S3C2440 FIFO trigger levels */
-#define S3C2440_UFCON_RXTRIG1	  (0<<4)
-#define S3C2440_UFCON_RXTRIG8	  (1<<4)
-#define S3C2440_UFCON_RXTRIG16	  (2<<4)
-#define S3C2440_UFCON_RXTRIG32	  (3<<4)
-
-#define S3C2440_UFCON_TXTRIG0	  (0<<6)
-#define S3C2440_UFCON_TXTRIG16	  (1<<6)
-#define S3C2440_UFCON_TXTRIG32	  (2<<6)
-#define S3C2440_UFCON_TXTRIG48	  (3<<6)
-
-#define S3C2410_UFCON_RESETBOTH	  (3<<1)
-#define S3C2410_UFCON_RESETTX	  (1<<2)
-#define S3C2410_UFCON_RESETRX	  (1<<1)
+#define S3C_UFCON_RESETBOTH	  (3<<1)
+#define S3C_UFCON_RESETTX	  (1<<2)
+#define S3C_UFCON_RESETRX	  (1<<1)
 
 #define S3C2410_UFCON_DEFAULT	  (S3C2410_UFCON_FIFOMODE | \
 				   S3C2410_UFCON_TXTRIG0  | \
@@ -139,15 +121,6 @@
 #define	S3C2410_UMCOM_AFC	  (1<<4)
 #define	S3C2410_UMCOM_RTS_LOW	  (1<<0)
 
-#define S3C2412_UMCON_AFC_63	(0<<5)		/* same as s3c2443 */
-#define S3C2412_UMCON_AFC_56	(1<<5)
-#define S3C2412_UMCON_AFC_48	(2<<5)
-#define S3C2412_UMCON_AFC_40	(3<<5)
-#define S3C2412_UMCON_AFC_32	(4<<5)
-#define S3C2412_UMCON_AFC_24	(5<<5)
-#define S3C2412_UMCON_AFC_16	(6<<5)
-#define S3C2412_UMCON_AFC_8	(7<<5)
-
 #define S3C2410_UFSTAT_TXFULL	  (1<<9)
 #define S3C2410_UFSTAT_RXFULL	  (1<<8)
 #define S3C2410_UFSTAT_TXMASK	  (15<<4)
@@ -155,43 +128,164 @@
 #define S3C2410_UFSTAT_RXMASK	  (15<<0)
 #define S3C2410_UFSTAT_RXSHIFT	  (0)
 
-/* UFSTAT S3C24A0 */
-#define S3C24A0_UFSTAT_TXFULL	  (1 << 14)
-#define S3C24A0_UFSTAT_RXFULL	  (1 << 6)
-#define S3C24A0_UFSTAT_TXMASK	  (63 << 8)
-#define S3C24A0_UFSTAT_TXSHIFT	  (8)
-#define S3C24A0_UFSTAT_RXMASK	  (63)
-#define S3C24A0_UFSTAT_RXSHIFT	  (0)
-
-/* UFSTAT S3C2443 same as S3C2440 */
-#define S3C2440_UFSTAT_TXFULL	  (1<<14)
-#define S3C2440_UFSTAT_RXFULL	  (1<<6)
-#define S3C2440_UFSTAT_TXSHIFT	  (8)
-#define S3C2440_UFSTAT_RXSHIFT	  (0)
-#define S3C2440_UFSTAT_TXMASK	  (63<<8)
-#define S3C2440_UFSTAT_RXMASK	  (63)
-
-#define S3C2410_UTRSTAT_TXE	  (1<<2)
-#define S3C2410_UTRSTAT_TXFE	  (1<<1)
-#define S3C2410_UTRSTAT_RXDR	  (1<<0)
-
-#define S3C2410_UERSTAT_OVERRUN	  (1<<0)
-#define S3C2410_UERSTAT_FRAME	  (1<<2)
-#define S3C2410_UERSTAT_BREAK	  (1<<3)
+#define S3C_UTRSTAT_TXE	  (1<<2)
+#define S3C_UTRSTAT_TXFE	  (1<<1)
+#define S3C_UTRSTAT_RXDR	  (1<<0)
+
+#define S3C_UERSTAT_OVERRUN	  (1<<0)
+#define S3C_UERSTAT_FRAME	  (1<<2)
+#define S3C_UERSTAT_BREAK	  (1<<3)
+
 #define S3C2443_UERSTAT_PARITY	  (1<<1)
 
-#define S3C2410_UERSTAT_ANY	  (S3C2410_UERSTAT_OVERRUN | \
-				   S3C2410_UERSTAT_FRAME | \
-				   S3C2410_UERSTAT_BREAK)
+#define S3C_UERSTAT_ANY	  (S3C_UERSTAT_OVERRUN | \
+				   S3C_UERSTAT_FRAME | \
+				   S3C_UERSTAT_BREAK)
 
 #define S3C2410_UMSTAT_CTS	  (1<<0)
 #define S3C2410_UMSTAT_DeltaCTS	  (1<<2)
 
 #define S3C2443_DIVSLOT		  (0x2C)
 
+/* S3C64XX only */
+#define S3C64XX_UFSTAT_TXFULL	  (1<<14)
+#define S3C64XX_UFSTAT_RXFULL	  (1<<6)
+#define S3C64XX_UFSTAT_TXSHIFT	  (8)
+#define S3C64XX_UFSTAT_RXSHIFT	  (0)
+#define S3C64XX_UFSTAT_TXMASK	  (63<<8)
+#define S3C64XX_UFSTAT_RXMASK	  (63)
+
+#define S3C64XX_ULCON_WORD_5BIT	(0 << 0)
+#define S3C64XX_ULCON_WORD_6BIT	(1 << 0)
+#define S3C64XX_ULCON_WORD_7BIT	(2 << 0)
+#define S3C64XX_ULCON_WORD_8BIT	(3 << 0)
+
+#define S3C64XX_UCON_DEFAULT	(S3C2410_UCON_TXILEVEL  | \
+					S3C2410_UCON_RXILEVEL  | \
+					S3C2410_UCON_TXIRQMODE | \
+					S3C2410_UCON_RXIRQMODE | \
+					S3C2410_UCON_RXFIFO_TOI | \
+					S3C2443_UCON_RXERR_IRQEN)
+
+#define S3C64XX_UFCON_DEFAULT	(S3C2410_UFCON_FIFOMODE | \
+					S3C2440_UFCON_TXTRIG16  | \
+					S3C2410_UFCON_RXTRIG8 )
+
+#define S3C64XX_ULCON_DEFAULT	S3C64XX_ULCON_WORD_8BIT
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+#define S3C_ULCON         (0x00)
+#define S3C_UCON          (0x04)
+#define S3C_UFCON         (0x08)
+#define S3C_UMCON         (0x0C)
+#define S3C_UTRSTAT       (0x10)
+#define S3C_UERSTAT       (0x14)
+#define S3C_UFSTAT        (0x18)
+#define S3C_UMSTAT        (0x1C)
+#define S3C_UTXH          (0x20)
+#define S3C_URXH          (0x24)
+#define S3C_UBRDIV        (0x28)
+#define S3C_UDIVSLOT      (0x2C)
+#define S3C_UINTPND       (0x30)
+#define S3C_UINTSP        (0x34)
+#define S3C_UINTMSK       (0x38)
+
+/* base definitions for UART Line Control Register */
+//#define S3C_LCON_CFGMASK        (0x7f)
+
+#define S3C_LCON_CS5    (0x0)
+#define S3C_LCON_CS6    (0x1)
+#define S3C_LCON_CS7    (0x2)
+#define S3C_LCON_CS8    (0x3)
+#define S3C_LCON_CSMASK (0x3)
+
+#define S3C_LCON_PNONE  (0x0)
+#define S3C_LCON_PEVEN  (0x5 << 3)
+#define S3C_LCON_PODD   (0x4 << 3)
+#define S3C_LCON_PMASK  (0x7 << 3)
+
+#define S3C_LCON_STOPB          (1<<2)
+#define S3C_LCON_IRM            (1<<6)
+
+#define S3C_UCON_CLKMASK        (3<<10)
+#define S3C_UCON_PCLK           (0<<10)
+#define S3C_UCON_UCLK           (1<<10)
+#define S3C_UCON_PCLK2          (2<<10)
+#define S3C_UCON_FCLK           (3<<10)
+
+#define S3C_UCON_TXILEVEL       (1<<9)
+#define S3C_UCON_RXILEVEL       (1<<8)
+#define S3C_UCON_TXIRQMODE      (1<<2)
+#define S3C_UCON_RXIRQMODE      (1<<0)
+#define S3C_UCON_RXFIFO_TOI     (1<<7)
+#define S3C_UCON_RX_ESIE        (1<<6)
+#define S3C_UCON_LOOP_OPERATION (0<<5)
+#define S3C_UCON_NO_SBS         (0<<4)
+
+
+#define S3C_UCON_DEFAULT          (S3C_UCON_TXILEVEL  | \
+                                   S3C_UCON_RXILEVEL  | \
+                                   S3C_UCON_TXIRQMODE | \
+                                   S3C_UCON_RXIRQMODE | \
+                                   S3C_UCON_RXFIFO_TOI)
+
+/* base definitions for UART FIFO Control Register */
+#define S3C_UFCON_FIFOMODE        (1<<0)
+#define S3C_UFCON_RXTRIG12        (2<<4)
+
+/* S3C2413 FIFO trigger levels */
+#define S3C_UFCON_RXTRIG1         (0<<4)
+#define S3C_UFCON_RXTRIG8         (1<<4)
+#define S3C_UFCON_RXTRIG16        (2<<4)
+#define S3C_UFCON_RXTRIG32        (3<<4)
+
+#define S3C_UFCON_TXTRIG0         (0<<6)
+#define S3C_UFCON_TXTRIG16        (1<<6)
+#define S3C_UFCON_TXTRIG32        (2<<6)
+#define S3C_UFCON_TXTRIG48        (3<<6)
+
+#define S3C_UFCON_RESETBOTH       (3<<1)
+#define S3C_UFCON_RESETTX         (1<<2)
+#define S3C_UFCON_RESETRX         (1<<1)
+#define S3C_UFCON_FIFO_ENABLE     (1<<0)
+
+#define S3C_UFCON_DEFAULT         (S3C_UFCON_FIFOMODE | \
+                                   S3C_UFCON_TXTRIG0  | \
+                                   S3C_UFCON_RXTRIG8 )
+
+#define S3C_UMCOM_AFC             (1<<4)
+#define S3C_UMCOM_RTS_LOW         (1<<0)
+
+#define S3C_UFSTAT_TXFULL         (1<<14)
+#define S3C_UFSTAT_RXFULL         (1<<6)
+#define S3C_UFSTAT_TXSHIFT        (8)
+#define S3C_UFSTAT_RXSHIFT        (0)
+#define S3C_UFSTAT_TXMASK         (63<<8)
+#define S3C_UFSTAT_RXMASK         (63)
+
+#define S3C_UTRSTAT_TXE           (1<<2)
+#define S3C_UTRSTAT_TXFE          (1<<1)
+#define S3C_UTRSTAT_RXDR          (1<<0)
+
+#define UART_RX_INT             (1<<0)
+#define UART_TX_INT             (1<<2)
+#define UART_ERR_INT            (1<<1)
+#define UART_MODEM_INT          (1<<3)
+
+#define S3C_UERSTAT_OVERRUN       (1<<0)
+#define S3C_UERSTAT_FRAME         (1<<2)
+#define S3C_UERSTAT_BREAK         (1<<3)
+#define S3C_UERSTAT_ANY   (S3C_UERSTAT_OVERRUN | \
+                                   S3C_UERSTAT_FRAME | \
+                                   S3C_UERSTAT_BREAK)
+
+#define S3C_UMSTAT_CTS            (1<<0)
+#define S3C_UMSTAT_DeltaCTS       (1<<2)
+#endif
+
 #ifndef __ASSEMBLY__
 
-/* struct s3c24xx_uart_clksrc
+/* struct s3c_uart_clksrc
  *
  * this structure defines a named clock source that can be used for the
  * uart, so that the best clock can be selected for the requested baud
@@ -204,7 +298,7 @@
  * divisor gives the divisor from the clock to the one seen by the uart
 */
 
-struct s3c24xx_uart_clksrc {
+struct s3c_uart_clksrc {
 	const char	*name;
 	unsigned int	 divisor;
 	unsigned int	 min_baud;
@@ -218,27 +312,31 @@
  * arch/arm/mach-s3c2410/ directory.
 */
 
-struct s3c2410_uartcfg {
+struct s3c_uartcfg {
 	unsigned char	   hwport;	 /* hardware port number */
 	unsigned char	   unused;
 	unsigned short	   flags;
+#if !defined(CONFIG_CPU_S3C6400) && !defined(CONFIG_CPU_S3C6410)
 	upf_t		   uart_flags;	 /* default uart flags */
+#else
+        unsigned long   uart_flags;      /* default uart flags */
+#endif
 
 	unsigned long	   ucon;	 /* value of ucon for port */
 	unsigned long	   ulcon;	 /* value of ulcon for port */
 	unsigned long	   ufcon;	 /* value of ufcon for port */
 
-	struct s3c24xx_uart_clksrc *clocks;
+	struct s3c_uart_clksrc *clocks;
 	unsigned int		    clocks_size;
 };
 
-/* s3c24xx_uart_devs
+/* s3c_uart_devs
  *
  * this is exported from the core as we cannot use driver_register(),
  * or platform_add_device() before the console_initcall()
 */
 
-extern struct platform_device *s3c24xx_uart_devs[4];
+extern struct platform_device *s3c_uart_devs[4];
 
 #endif /* __ASSEMBLY__ */
 
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-timer.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-timer.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-timer.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-timer.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* arch/arm/mach-s3c2410/include/mach/regs-timer.h
+/* linux/arch/arm/plat-s3c/include/plat/regs-timer.h
  *
  * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
  *		      http://www.simtec.co.uk/products/SWLINUX/
@@ -16,72 +16,113 @@
 #define S3C_TIMERREG(x) (S3C_VA_TIMER + (x))
 #define S3C_TIMERREG2(tmr,reg) S3C_TIMERREG((reg)+0x0c+((tmr)*0x0c))
 
-#define S3C2410_TCFG0	      S3C_TIMERREG(0x00)
-#define S3C2410_TCFG1	      S3C_TIMERREG(0x04)
-#define S3C2410_TCON	      S3C_TIMERREG(0x08)
-
-#define S3C64XX_TINT_CSTAT    S3C_TIMERREG(0x44)
-
-#define S3C2410_TCFG_PRESCALER0_MASK (255<<0)
-#define S3C2410_TCFG_PRESCALER1_MASK (255<<8)
-#define S3C2410_TCFG_PRESCALER1_SHIFT (8)
-#define S3C2410_TCFG_DEADZONE_MASK   (255<<16)
-#define S3C2410_TCFG_DEADZONE_SHIFT  (16)
-
-#define S3C2410_TCFG1_MUX4_DIV2	  (0<<16)
-#define S3C2410_TCFG1_MUX4_DIV4	  (1<<16)
-#define S3C2410_TCFG1_MUX4_DIV8	  (2<<16)
-#define S3C2410_TCFG1_MUX4_DIV16  (3<<16)
-#define S3C2410_TCFG1_MUX4_TCLK1  (4<<16)
-#define S3C2410_TCFG1_MUX4_MASK	  (15<<16)
-#define S3C2410_TCFG1_MUX4_SHIFT  (16)
-
-#define S3C2410_TCFG1_MUX3_DIV2	  (0<<12)
-#define S3C2410_TCFG1_MUX3_DIV4	  (1<<12)
-#define S3C2410_TCFG1_MUX3_DIV8	  (2<<12)
-#define S3C2410_TCFG1_MUX3_DIV16  (3<<12)
-#define S3C2410_TCFG1_MUX3_TCLK1  (4<<12)
-#define S3C2410_TCFG1_MUX3_MASK	  (15<<12)
-
-
-#define S3C2410_TCFG1_MUX2_DIV2	  (0<<8)
-#define S3C2410_TCFG1_MUX2_DIV4	  (1<<8)
-#define S3C2410_TCFG1_MUX2_DIV8	  (2<<8)
-#define S3C2410_TCFG1_MUX2_DIV16  (3<<8)
-#define S3C2410_TCFG1_MUX2_TCLK1  (4<<8)
-#define S3C2410_TCFG1_MUX2_MASK	  (15<<8)
-
-
-#define S3C2410_TCFG1_MUX1_DIV2	  (0<<4)
-#define S3C2410_TCFG1_MUX1_DIV4	  (1<<4)
-#define S3C2410_TCFG1_MUX1_DIV8	  (2<<4)
-#define S3C2410_TCFG1_MUX1_DIV16  (3<<4)
-#define S3C2410_TCFG1_MUX1_TCLK0  (4<<4)
-#define S3C2410_TCFG1_MUX1_MASK	  (15<<4)
-
-#define S3C2410_TCFG1_MUX0_DIV2	  (0<<0)
-#define S3C2410_TCFG1_MUX0_DIV4	  (1<<0)
-#define S3C2410_TCFG1_MUX0_DIV8	  (2<<0)
-#define S3C2410_TCFG1_MUX0_DIV16  (3<<0)
-#define S3C2410_TCFG1_MUX0_TCLK0  (4<<0)
-#define S3C2410_TCFG1_MUX0_MASK	  (15<<0)
-
-#define S3C2410_TCFG1_MUX_DIV2	  (0<<0)
-#define S3C2410_TCFG1_MUX_DIV4	  (1<<0)
-#define S3C2410_TCFG1_MUX_DIV8	  (2<<0)
-#define S3C2410_TCFG1_MUX_DIV16   (3<<0)
-#define S3C2410_TCFG1_MUX_TCLK    (4<<0)
-#define S3C2410_TCFG1_MUX_MASK	  (15<<0)
-
-#define S3C64XX_TCFG1_MUX_DIV1	  (0<<0)
-#define S3C64XX_TCFG1_MUX_DIV2	  (1<<0)
-#define S3C64XX_TCFG1_MUX_DIV4	  (2<<0)
-#define S3C64XX_TCFG1_MUX_DIV8    (3<<0)
-#define S3C64XX_TCFG1_MUX_DIV16   (4<<0)
-#define S3C64XX_TCFG1_MUX_TCLK    (5<<0)  /* 3 sets of TCLK */
-#define S3C64XX_TCFG1_MUX_MASK	  (15<<0)
+#define S3C_TCFG0   S3C_TIMERREG(0x00)
+#define S3C_TCFG1   S3C_TIMERREG(0x04)
+#define S3C_TCON    S3C_TIMERREG(0x08)
+
+#define S3C_TINT_CSTAT  S3C_TIMERREG(0x44)
+
+#define S3C_TCFG_PRESCALER0_MASK (255<<0)
+#define S3C_TCFG_PRESCALER1_MASK (255<<8)
+#define S3C_TCFG_PRESCALER1_SHIFT (8)
+#define S3C_TCFG_PRESCALER0_SHIFT (0)
+#define S3C_TCFG_DEADZONE_MASK   (255<<16)
+#define S3C_TCFG_DEADZONE_SHIFT  (16)
+
+#if defined (CONFIG_ARCH_S3C2410)
+#define S3C_TCFG1_MUX4_DIV2   (0<<16)
+#define S3C_TCFG1_MUX4_DIV4   (1<<16)
+#define S3C_TCFG1_MUX4_DIV8   (2<<16)
+#define S3C_TCFG1_MUX4_DIV16  (3<<16)
+#define S3C_TCFG1_MUX4_TCLK1  (4<<16)
+
+#define S3C_TCFG1_MUX3_DIV2	  (0<<12)
+#define S3C_TCFG1_MUX3_DIV4	  (1<<12)
+#define S3C_TCFG1_MUX3_DIV8	  (2<<12)
+#define S3C_TCFG1_MUX3_DIV16  (3<<12)
+#define S3C_TCFG1_MUX3_TCLK1  (4<<12)
+#define S3C_TCFG1_MUX3_MASK	  (15<<12)
+
+#define S3C_TCFG1_MUX2_DIV2	  (0<<8)
+#define S3C_TCFG1_MUX2_DIV4	  (1<<8)
+#define S3C_TCFG1_MUX2_DIV8	  (2<<8)
+#define S3C_TCFG1_MUX2_DIV16  (3<<8)
+#define S3C_TCFG1_MUX2_TCLK1  (4<<8)
+#define S3C_TCFG1_MUX2_MASK	  (15<<8)
+
+#define S3C_TCFG1_MUX1_DIV2	  (0<<4)
+#define S3C_TCFG1_MUX1_DIV4	  (1<<4)
+#define S3C_TCFG1_MUX1_DIV8	  (2<<4)
+#define S3C_TCFG1_MUX1_DIV16  (3<<4)
+#define S3C_TCFG1_MUX1_TCLK0  (4<<4)
+#define S3C_TCFG1_MUX1_MASK	  (15<<4)
+
+#define S3C_TCFG1_MUX0_DIV2	  (0<<0)
+#define S3C_TCFG1_MUX0_DIV4	  (1<<0)
+#define S3C_TCFG1_MUX0_DIV8	  (2<<0)
+#define S3C_TCFG1_MUX0_DIV16  (3<<0)
+#define S3C_TCFG1_MUX0_TCLK0  (4<<0)
+#define S3C_TCFG1_MUX0_MASK	  (15<<0)
+
+#define S3C_TCFG1_MUX_DIV2	  (0<<0)
+#define S3C_TCFG1_MUX_DIV4	  (1<<0)
+#define S3C_TCFG1_MUX_DIV8	  (2<<0)
+#define S3C_TCFG1_MUX_DIV16   (3<<0)
+#define S3C_TCFG1_MUX_TCLK    (4<<0)
+#define S3C_TCFG1_MUX_MASK	  (15<<0)
+
+#elif defined(CONFIG_ARCH_S3C64XX)
+#define S3C_TCFG1_MUX4_DIV1   (0<<16)
+#define S3C_TCFG1_MUX4_DIV2   (1<<16)
+#define S3C_TCFG1_MUX4_DIV4   (2<<16)
+#define S3C_TCFG1_MUX4_DIV8   (3<<16)
+#define S3C_TCFG1_MUX4_DIV16  (4<<16)
+#define S3C_TCFG1_MUX4_TCLK1  (5<<16)
+#define S3C_TCFG1_MUX4_MASK   (15<<16)
+#define S3C_TCFG1_MUX4_SHIFT  (16)
+
+#define S3C_TCFG1_MUX3_DIV1   (0<<12)
+#define S3C_TCFG1_MUX3_DIV2   (1<<12)
+#define S3C_TCFG1_MUX3_DIV4   (2<<12)
+#define S3C_TCFG1_MUX3_DIV8   (3<<12)
+#define S3C_TCFG1_MUX3_DIV16  (4<<12)
+#define S3C_TCFG1_MUX3_TCLK1  (5<<12)
+#define S3C_TCFG1_MUX3_MASK   (15<<12)
+
+#define S3C_TCFG1_MUX2_DIV1   (0<<8)
+#define S3C_TCFG1_MUX2_DIV2   (1<<8)
+#define S3C_TCFG1_MUX2_DIV4   (2<<8)
+#define S3C_TCFG1_MUX2_DIV8   (3<<8)
+#define S3C_TCFG1_MUX2_DIV16  (4<<8)
+#define S3C_TCFG1_MUX2_TCLK1  (5<<8)
+#define S3C_TCFG1_MUX2_MASK   (15<<8)
+
+#define S3C_TCFG1_MUX1_DIV1   (0<<4)
+#define S3C_TCFG1_MUX1_DIV2   (1<<4)
+#define S3C_TCFG1_MUX1_DIV4   (2<<16)
+#define S3C_TCFG1_MUX1_DIV8   (3<<16)
+#define S3C_TCFG1_MUX1_DIV16  (4<<16)
+#define S3C_TCFG1_MUX1_TCLK1  (5<<16)
+#define S3C_TCFG1_MUX1_MASK   (15<<16)
+
+#define S3C_TCFG1_MUX0_DIV2	  (0<<0)
+#define S3C_TCFG1_MUX0_DIV4	  (1<<0)
+#define S3C_TCFG1_MUX0_DIV8	  (2<<0)
+#define S3C_TCFG1_MUX0_DIV16  (3<<0)
+#define S3C_TCFG1_MUX0_TCLK0  (4<<0)
+#define S3C_TCFG1_MUX0_MASK	  (15<<0)
+
+#define S3C_TCFG1_MUX_DIV2	  (0<<0)
+#define S3C_TCFG1_MUX_DIV4	  (1<<0)
+#define S3C_TCFG1_MUX_DIV8	  (2<<0)
+#define S3C_TCFG1_MUX_DIV16   (3<<0)
+#define S3C_TCFG1_MUX_TCLK    (4<<0)
+#define S3C_TCFG1_MUX_MASK	  (15<<0)
 
-#define S3C2410_TCFG1_SHIFT(x)	  ((x) * 4)
+#endif
+
+#define S3C_TCFG1_MUX4_MASK   (15<<16)
+#define S3C_TCFG1_SHIFT(x)	  ((x) * 4)
 
 /* for each timer, we have an count buffer, an compare buffer and
  * an observation buffer
@@ -89,34 +130,45 @@
 
 /* WARNING - timer 4 has no buffer reg, and it's observation is at +4 */
 
-#define S3C2410_TCNTB(tmr)    S3C_TIMERREG2(tmr, 0x00)
-#define S3C2410_TCMPB(tmr)    S3C_TIMERREG2(tmr, 0x04)
-#define S3C2410_TCNTO(tmr)    S3C_TIMERREG2(tmr, (((tmr) == 4) ? 0x04 : 0x08))
-
-#define S3C2410_TCON_T4RELOAD	  (1<<22)
-#define S3C2410_TCON_T4MANUALUPD  (1<<21)
-#define S3C2410_TCON_T4START	  (1<<20)
-
-#define S3C2410_TCON_T3RELOAD	  (1<<19)
-#define S3C2410_TCON_T3INVERT	  (1<<18)
-#define S3C2410_TCON_T3MANUALUPD  (1<<17)
-#define S3C2410_TCON_T3START	  (1<<16)
-
-#define S3C2410_TCON_T2RELOAD	  (1<<15)
-#define S3C2410_TCON_T2INVERT	  (1<<14)
-#define S3C2410_TCON_T2MANUALUPD  (1<<13)
-#define S3C2410_TCON_T2START	  (1<<12)
-
-#define S3C2410_TCON_T1RELOAD	  (1<<11)
-#define S3C2410_TCON_T1INVERT	  (1<<10)
-#define S3C2410_TCON_T1MANUALUPD  (1<<9)
-#define S3C2410_TCON_T1START	  (1<<8)
-
-#define S3C2410_TCON_T0DEADZONE	  (1<<4)
-#define S3C2410_TCON_T0RELOAD	  (1<<3)
-#define S3C2410_TCON_T0INVERT	  (1<<2)
-#define S3C2410_TCON_T0MANUALUPD  (1<<1)
-#define S3C2410_TCON_T0START	  (1<<0)
+#define S3C_TCNTB(tmr)    S3C_TIMERREG2(tmr, 0x00)
+#define S3C_TCMPB(tmr)    S3C_TIMERREG2(tmr, 0x04)
+#define S3C_TCNTO(tmr)    S3C_TIMERREG2(tmr, (((tmr) == 4) ? 0x04 : 0x08))
+
+#define S3C_TCON_T4RELOAD	  (1<<22)
+#define S3C_TCON_T4MANUALUPD  (1<<21)
+#define S3C_TCON_T4START	  (1<<20)
+
+#define S3C_TCON_T3RELOAD	  (1<<19)
+#define S3C_TCON_T3INVERT	  (1<<18)
+#define S3C_TCON_T3MANUALUPD  (1<<17)
+#define S3C_TCON_T3START	  (1<<16)
+
+#define S3C_TCON_T2RELOAD	  (1<<15)
+#define S3C_TCON_T2INVERT	  (1<<14)
+#define S3C_TCON_T2MANUALUPD  (1<<13)
+#define S3C_TCON_T2START	  (1<<12)
+
+#define S3C_TCON_T1RELOAD	  (1<<11)
+#define S3C_TCON_T1INVERT	  (1<<10)
+#define S3C_TCON_T1MANUALUPD	  (1<<9)
+#define S3C_TCON_T1START	  (1<<8)
+
+#define S3C_TCON_T0DEADZONE	  (1<<4)
+#define S3C_TCON_T0RELOAD	  (1<<3)
+#define S3C_TCON_T0INVERT	  (1<<2)
+#define S3C_TCON_T0MANUALUPD  (1<<1)
+#define S3C_TCON_T0START	  (1<<0)
+
+#define S3C_TINT_CSTAT_T4INT    (1<<9)
+#define S3C_TINT_CSTAT_T3INT    (1<<8)
+#define S3C_TINT_CSTAT_T2INT    (1<<7)
+#define S3C_TINT_CSTAT_T1INT    (1<<6)
+#define S3C_TINT_CSTAT_T0INT    (1<<5)
+#define S3C_TINT_CSTAT_T4INTEN  (1<<4)
+#define S3C_TINT_CSTAT_T3INTEN  (1<<3)
+#define S3C_TINT_CSTAT_T2INTEN  (1<<2)
+#define S3C_TINT_CSTAT_T1INTEN  (1<<1)
+#define S3C_TINT_CSTAT_T0INTEN  (1<<0)
 
 #endif /*  __ASM_ARCH_REGS_TIMER_H */
 
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-usb-otg-hs.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-usb-otg-hs.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-usb-otg-hs.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-usb-otg-hs.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,287 @@
+/*  
+ * This include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+*/
+
+#ifndef __ASM_ARCH_REGS_USB_OTG_HS_H
+#define __ASM_ARCH_REGS_USB_OTG_HS_H
+
+#define S3C_USBOTG_PHYREG(x)		((x) + S3C_VA_OTGSFR)
+
+#define S3C_USBOTG_PHYPWR		S3C_USBOTG_PHYREG(0x0)
+#define S3C_USBOTG_PHYCLK		S3C_USBOTG_PHYREG(0x4)
+#define S3C_USBOTG_RSTCON		S3C_USBOTG_PHYREG(0x8)
+
+
+/* USB2.0 OTG Controller register */
+#define S3C_USBOTGREG(x) ((x) + S3C_VA_OTG)
+
+//==============================================================================================
+// Core Global Registers
+#define S3C_UDC_OTG_GOTGCTL			S3C_USBOTGREG(0x000)		// OTG Control & Status
+#define S3C_UDC_OTG_GOTGINT			S3C_USBOTGREG(0x004)		// OTG Interrupt
+#define S3C_UDC_OTG_GAHBCFG			S3C_USBOTGREG(0x008)		// Core AHB Configuration
+#define S3C_UDC_OTG_GUSBCFG			S3C_USBOTGREG(0x00C)		// Core USB Configuration
+#define S3C_UDC_OTG_GRSTCTL			S3C_USBOTGREG(0x010)		// Core Reset
+#define S3C_UDC_OTG_GINTSTS			S3C_USBOTGREG(0x014)		// Core Interrupt
+#define S3C_UDC_OTG_GINTMSK			S3C_USBOTGREG(0x018)		// Core Interrupt Mask
+#define S3C_UDC_OTG_GRXSTSR			S3C_USBOTGREG(0x01C)		// Receive Status Debug Read/Status Read
+#define S3C_UDC_OTG_GRXSTSP			S3C_USBOTGREG(0x020)		// Receive Status Debug Pop/Status Pop
+#define S3C_UDC_OTG_GRXFSIZ			S3C_USBOTGREG(0x024)		// Receive FIFO Size
+#define S3C_UDC_OTG_GNPTXFSIZ		S3C_USBOTGREG(0x028)		// Non-Periodic Transmit FIFO Size
+#define S3C_UDC_OTG_GNPTXSTS		S3C_USBOTGREG(0x02C)		// Non-Periodic Transmit FIFO/Queue Status
+
+#define S3C_UDC_OTG_HPTXFSIZ		S3C_USBOTGREG(0x100)		// Host Periodic Transmit FIFO Size
+#define S3C_UDC_OTG_DIEPTXFSIZ(n)	S3C_USBOTGREG(0x104 + (n-1)*0x4)/* Device IN EP Transmit FIFO Size Register */
+
+#define S3C_UDC_OTG_DPTXFSIZ1		S3C_USBOTGREG(0x104)		// Device Periodic Transmit FIFO-1 Size
+#define S3C_UDC_OTG_DPTXFSIZ2		S3C_USBOTGREG(0x108)		// Device Periodic Transmit FIFO-2 Size
+#define S3C_UDC_OTG_DPTXFSIZ3		S3C_USBOTGREG(0x10C)		// Device Periodic Transmit FIFO-3 Size
+#define S3C_UDC_OTG_DPTXFSIZ4		S3C_USBOTGREG(0x110)		// Device Periodic Transmit FIFO-4 Size
+#define S3C_UDC_OTG_DPTXFSIZ5		S3C_USBOTGREG(0x114)		// Device Periodic Transmit FIFO-5 Size
+#define S3C_UDC_OTG_DPTXFSIZ6		S3C_USBOTGREG(0x118)		// Device Periodic Transmit FIFO-6 Size
+#define S3C_UDC_OTG_DPTXFSIZ7		S3C_USBOTGREG(0x11C)		// Device Periodic Transmit FIFO-7 Size
+#define S3C_UDC_OTG_DPTXFSIZ8		S3C_USBOTGREG(0x120)		// Device Periodic Transmit FIFO-8 Size
+#define S3C_UDC_OTG_DPTXFSIZ9		S3C_USBOTGREG(0x124)		// Device Periodic Transmit FIFO-9 Size
+#define S3C_UDC_OTG_DPTXFSIZ10		S3C_USBOTGREG(0x128)		// Device Periodic Transmit FIFO-10 Size
+#define S3C_UDC_OTG_DPTXFSIZ11		S3C_USBOTGREG(0x12C)		// Device Periodic Transmit FIFO-11 Size
+#define S3C_UDC_OTG_DPTXFSIZ12		S3C_USBOTGREG(0x130)		// Device Periodic Transmit FIFO-12 Size
+#define S3C_UDC_OTG_DPTXFSIZ13		S3C_USBOTGREG(0x134)		// Device Periodic Transmit FIFO-13 Size
+#define S3C_UDC_OTG_DPTXFSIZ14		S3C_USBOTGREG(0x138)		// Device Periodic Transmit FIFO-14 Size
+#define S3C_UDC_OTG_DPTXFSIZ15		S3C_USBOTGREG(0x13C)		// Device Periodic Transmit FIFO-15 Size
+
+//==============================================================================================
+// Host Mode Registers
+//------------------------------------------------
+// Host Global Registers
+#define S3C_UDC_OTG_HCFG		S3C_USBOTGREG(0x400)		// Host Configuration
+#define S3C_UDC_OTG_HFIR		S3C_USBOTGREG(0x404)		// Host Frame Interval
+#define S3C_UDC_OTG_HFNUM		S3C_USBOTGREG(0x408)		// Host Frame Number/Frame Time Remaining
+#define S3C_UDC_OTG_HPTXSTS		S3C_USBOTGREG(0x410)		// Host Periodic Transmit FIFO/Queue Status
+#define S3C_UDC_OTG_HAINT		S3C_USBOTGREG(0x414)		// Host All Channels Interrupt
+#define S3C_UDC_OTG_HAINTMSK	S3C_USBOTGREG(0x418)		// Host All Channels Interrupt Mask
+
+//------------------------------------------------
+// Host Port Control & Status Registers
+#define S3C_UDC_OTG_HPRT		S3C_USBOTGREG(0x440)		// Host Port Control & Status
+
+//------------------------------------------------
+// Host Channel-Specific Registers
+#define S3C_UDC_OTG_HCCHAR0		S3C_USBOTGREG(0x500)		// Host Channel-0 Characteristics
+#define S3C_UDC_OTG_HCSPLT0		S3C_USBOTGREG(0x504)		// Host Channel-0 Split Control
+#define S3C_UDC_OTG_HCINT0		S3C_USBOTGREG(0x508)		// Host Channel-0 Interrupt
+#define S3C_UDC_OTG_HCINTMSK0	S3C_USBOTGREG(0x50C)		// Host Channel-0 Interrupt Mask
+#define S3C_UDC_OTG_HCTSIZ0		S3C_USBOTGREG(0x510)		// Host Channel-0 Transfer Size
+#define S3C_UDC_OTG_HCDMA0		S3C_USBOTGREG(0x514)		// Host Channel-0 DMA Address
+
+
+//==============================================================================================
+// Device Mode Registers
+//------------------------------------------------
+// Device Global Registers
+#define S3C_UDC_OTG_DCFG		S3C_USBOTGREG(0x800)		// Device Configuration
+#define S3C_UDC_OTG_DCTL		S3C_USBOTGREG(0x804)		// Device Control
+#define S3C_UDC_OTG_DSTS		S3C_USBOTGREG(0x808)		// Device Status
+#define S3C_UDC_OTG_DIEPMSK		S3C_USBOTGREG(0x810)		// Device IN Endpoint Common Interrupt Mask
+#define S3C_UDC_OTG_DOEPMSK		S3C_USBOTGREG(0x814)		// Device OUT Endpoint Common Interrupt Mask
+#define S3C_UDC_OTG_DAINT		S3C_USBOTGREG(0x818)		// Device All Endpoints Interrupt
+#define S3C_UDC_OTG_DAINTMSK	S3C_USBOTGREG(0x81C)		// Device All Endpoints Interrupt Mask
+#define S3C_UDC_OTG_DTKNQR1		S3C_USBOTGREG(0x820)		// Device IN Token Sequence Learning Queue Read 1
+#define S3C_UDC_OTG_DTKNQR2		S3C_USBOTGREG(0x824)		// Device IN Token Sequence Learning Queue Read 2
+#define S3C_UDC_OTG_DVBUSDIS	S3C_USBOTGREG(0x828)		// Device VBUS Discharge Time
+#define S3C_UDC_OTG_DVBUSPULSE	S3C_USBOTGREG(0x82C)		// Device VBUS Pulsing Time
+#define S3C_UDC_OTG_DTKNQR3		S3C_USBOTGREG(0x830)		// Device IN Token Sequence Learning Queue Read 3
+#define S3C_UDC_OTG_DTKNQR4		S3C_USBOTGREG(0x834)		// Device IN Token Sequence Learning Queue Read 4
+
+//------------------------------------------------
+// Device Logical IN Endpoint-Specific Registers
+#define S3C_UDC_OTG_DIEPCTL(n)		S3C_USBOTGREG(0x900 + n*0x20)	/* Device IN Endpoint n Control */
+#define S3C_UDC_OTG_DIEPINT(n)		S3C_USBOTGREG(0x908 + n*0x20)	/* Device IN Endpoint n Interrupt */
+#define S3C_UDC_OTG_DIEPTSIZ(n)		S3C_USBOTGREG(0x910 + n*0x20)	/* Device IN Endpoint n Transfer Size */
+#define S3C_UDC_OTG_DIEPDMA(n)		S3C_USBOTGREG(0x914 + n*0x20)	/* Device IN Endpoint n DMA Address */
+
+/*------------------------------------------------ */
+/* Device Logical OUT Endpoint-Specific Registers */
+#define S3C_UDC_OTG_DOEPCTL(n)		S3C_USBOTGREG(0xB00 + n*0x20)	/* Device OUT Endpoint n Control */
+#define S3C_UDC_OTG_DOEPINT(n)		S3C_USBOTGREG(0xB08 + n*0x20)	/* Device OUT Endpoint n Interrupt */
+#define S3C_UDC_OTG_DOEPTSIZ(n)		S3C_USBOTGREG(0xB10 + n*0x20)	/* Device OUT Endpoint n Transfer Size */
+#define S3C_UDC_OTG_DOEPDMA(n)		S3C_USBOTGREG(0xB14 + n*0x20)	/* Device OUT Endpoint n DMA Address */
+
+//------------------------------------------------
+// Endpoint FIFO address
+#define S3C_UDC_OTG_EP0_FIFO		S3C_USBOTGREG(0x1000)
+#define S3C_UDC_OTG_EP1_FIFO		S3C_USBOTGREG(0x2000)
+#define S3C_UDC_OTG_EP2_FIFO		S3C_USBOTGREG(0x3000)
+#define S3C_UDC_OTG_EP3_FIFO		S3C_USBOTGREG(0x4000)
+#define S3C_UDC_OTG_EP4_FIFO		S3C_USBOTGREG(0x5000)
+#define S3C_UDC_OTG_EP5_FIFO		S3C_USBOTGREG(0x6000)
+#define S3C_UDC_OTG_EP6_FIFO		S3C_USBOTGREG(0x7000)
+#define S3C_UDC_OTG_EP7_FIFO		S3C_USBOTGREG(0x8000)
+#define S3C_UDC_OTG_EP8_FIFO		S3C_USBOTGREG(0x9000)
+#define S3C_UDC_OTG_EP9_FIFO		S3C_USBOTGREG(0xa000)
+
+
+//==============================================================================================
+// Power and Clock Gating Registers
+//------------------------------------------------
+#define S3C_UDC_OTG_PCGCCTL		S3C_USBOTGREG(0x0E00)
+
+//=====================================================================
+//definitions related to CSR setting
+
+// S3C_USBOTG_PHYPWR : OTG PHY Power Control Registers
+#define FORCE_SUSPEND		(0)
+#define ANALOG_POWERDOWN	(3)
+#define OTG_DISABLE			(4)
+
+// S3C_UDC_OTG_PCGCCTL : Power and Clock Gating Registers
+#define STOP_PCLK_BIT		(0)
+#define GATE_HCLK_BIT		(1)
+
+// S3C_UDC_OTG_GOTGCTL
+#define B_SESSION_VALID				(0x1<<19)
+#define A_SESSION_VALID				(0x1<<18)
+#define SESSION_REQ					(0x1<<1)
+#define SESSION_REQ_SUCCESS			(0x1<<0)
+
+//S3C_UDC_OTG_DSTS: Device Status
+#define	SUSPEND_STS		(0)
+
+// S3C_UDC_OTG_GAHBCFG
+#define PTXFE_HALF				(0<<8)
+#define PTXFE_ZERO				(1<<8)
+#define NPTXFE_HALF				(0<<7)
+#define NPTXFE_ZERO				(1<<7)
+#define MODE_SLAVE				(0<<5)
+#define MODE_DMA				(1<<5)
+#define BURST_SINGLE			(0<<1)
+#define BURST_INCR				(1<<1)
+#define BURST_INCR4				(3<<1)
+#define BURST_INCR8				(5<<1)
+#define BURST_INCR16			(7<<1)
+#define GBL_INT_UNMASK			(1<<0)
+#define GBL_INT_MASK			(0<<0)
+
+// S3C_UDC_OTG_GRSTCTL
+#define AHB_MASTER_IDLE			(0x1<<31)
+#define CORE_SOFT_RESET			(0x1<<0)
+
+// S3C_UDC_OTG_GINTSTS/S3C_UDC_OTG_GINTMSK core interrupt register
+#define INT_RESUME				(0x1<<31)
+#define INT_DISCONN				(0x1<<29)	/*Host only*/
+#define INT_CONN_ID_STS_CNG		(0x1<<28)
+#define INT_OUT_EP				(0x1<<19)
+#define INT_IN_EP				(0x1<<18)
+#define INT_ENUMDONE			(0x1<<13)
+#define INT_RESET				(0x1<<12)
+#define INT_SUSPEND				(0x1<<11)
+#define INT_EARLY_SUSPEND		(0x1<<10)
+#define	INT_GOUTNakEff			(0x1<<7)
+#define	INT_GINNakEff			(0x1<<6)
+#define INT_NP_TX_FIFO_EMPTY	(0x1<<5)
+#define INT_RX_FIFO_NOT_EMPTY	(0x1<<4)
+#define INT_SOF					(0x1<<3)
+#define INT_OTG					(0x1<<2)
+#define INT_MODE_MIS			(0x1<<1)
+#define INT_CUR_MOD				(0x1<<0)
+
+#define RX_FIFO_SIZE				(2048)
+#define NPTX_FIFO_START_ADDR		RX_FIFO_SIZE
+#define NPTX_FIFO_SIZE				(2048)
+#define PTX_FIFO_SIZE				(2048)
+
+#define DEPCTL_TXFNUM_0			(0x0<<22)
+#define DEPCTL_TXFNUM_1			(0x1<<22)
+#define DEPCTL_TXFNUM_2			(0x2<<22)
+#define DEPCTL_TXFNUM_3			(0x3<<22)
+#define DEPCTL_TXFNUM_4			(0x4<<22)
+
+
+// Enumeration speed
+#define USB_HIGH_30_60MHZ			(0x0<<1)
+#define USB_FULL_30_60MHZ			(0x1<<1)
+#define USB_LOW_6MHZ				(0x2<<1)
+#define USB_FULL_48MHZ				(0x3<<1)
+
+// S3C_UDC_OTG_GRXSTSP STATUS
+#define OUT_PKT_RECEIVED			(0x2<<17)
+#define OUT_TRANSFER_COMPLELTED		(0x3<<17)
+#define SETUP_TRANSACTION_COMPLETED	(0x4<<17)
+#define SETUP_PKT_RECEIVED			(0x6<<17)
+#define GLOBAL_OUT_NAK				(0x1<<17)
+
+
+// S3C_UDC_OTG_DCTL device control register
+#define NORMAL_OPERATION			(0x1<<0)
+#define SOFT_DISCONNECT				(0x1<<1)
+#define REMOTE_WAKEUP_SIG			(0x1<<0)
+
+// S3C_UDC_OTG_DCFG device control register
+#define DCFG_DEV_ADDRESS_BIT		(4)
+#define DCFG_DEV_ADDRESS_MASK		(0x7F)
+#define DCFG_EP_MISMATCH_CNT		(18)
+#define DCFG_DEV_SPEED_BIT			(0)
+#define DCFG_DEV_HIGH_SPEED_2_0		(0)
+#define DCFG_DEV_FULL_SPEED_2_0		(1)
+
+/* S3C_UDC_OTG_DAINT device all endpoint interrupt register */
+#define DAINT_OUT_BIT				(16)
+#define DAINT_MASK				(0xFFFF)
+
+// S3C_UDC_OTG_DIEPCTL0/DOEPCTL0 device control IN/OUT endpoint 0 control register
+#define DEPCTL_EPENA				(0x1<<31)
+#define DEPCTL_EPDIS				(0x1<<30)
+#define DEPCTL_SETD1PID				(0x1<<29)
+#define DEPCTL_SETD0PID				(0x1<<28)
+#define DEPCTL_SNAK					(0x1<<27)
+#define DEPCTL_CNAK					(0x1<<26)
+#define DEPCTL_STALL				(0x1<<21)
+
+#define DEPCTL_TYPE_BIT				(18)
+#define DEPCTL_TYPE_MASK			(0x3<<18)
+#define DEPCTL_CTRL_TYPE			(0x0<<18)
+#define DEPCTL_ISO_TYPE				(0x1<<18)
+#define DEPCTL_BULK_TYPE			(0x2<<18)
+#define DEPCTL_INTR_TYPE			(0x3<<18)
+#define DEPCTL_USBACTEP				(0x1<<15)
+
+#define DEPCTL_NEXT_EP_BIT			(11)
+#define DEPCTL_MPS_BIT				(0)
+#define DEPCTL_MPS_MASK				(0x7FF)
+
+#define DEPCTL0_MPS_MASK			(0x3)
+#define DEPCTL0_MPS_64				(0x0<<DEPCTL_MPS_BIT)
+#define DEPCTL0_MPS_32				(0x1<<DEPCTL_MPS_BIT)
+#define DEPCTL0_MPS_16				(0x2<<DEPCTL_MPS_BIT)
+#define DEPCTL0_MPS_8				(0x3<<DEPCTL_MPS_BIT)
+
+#define DEPCTL_MPS_BULK_512			(512<<DEPCTL_MPS_BIT)
+#define DEPCTL_MPS_INT_MPS_16		(16<<DEPCTL_MPS_BIT)
+#define DIEPCTL_NEXT_EP_BIT			(11)
+
+
+// S3C_UDC_OTG_DIEPMSK/DOEPMSK device IN/OUT endpoint common interrupt mask register
+// S3C_UDC_OTG_DIEPINTn/DOEPINTn device IN/OUT endpoint interrupt register
+#define BACK2BACK_SETUP_RECEIVED		(0x1<<6)
+#define INTKNEPMIS						(0x1<<5)
+#define INTKN_TXFEMP					(0x1<<4)
+#define NON_ISO_IN_EP_TIMEOUT			(0x1<<3)
+#define CTRL_OUT_EP_SETUP_PHASE_DONE	(0x1<<3)
+#define AHB_ERROR						(0x1<<2)
+#define EPDISBLD						(0x1<<1)
+#define TRANSFER_DONE					(0x1<<0)
+
+//DIEPTSIZ0 / DOEPTSIZ0
+
+// DEPTSIZ common bit
+#define DEPTSIZ_PKT_CNT_BIT 	(19)
+#define DEPTSIZ_XFER_SIZE_BIT	(0)
+
+#define	DEPTSIZ_SETUP_PKCNT_1	(1<<29)
+#define	DEPTSIZ_SETUP_PKCNT_2	(2<<29)
+#define	DEPTSIZ_SETUP_PKCNT_3	(3<<29)
+
+
+#endif
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-watchdog.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-watchdog.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/regs-watchdog.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/regs-watchdog.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* arch/arm/mach-s3c2410/include/mach/regs-watchdog.h
+/* arch/arm/plat-s3c/include/plat/regs-watchdog.h
  *
  * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
  *		      http://www.simtec.co.uk/products/SWLINUX/
@@ -7,7 +7,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * S3C2410 Watchdog timer control
+ * S3C Watchdog timer control
 */
 
 
@@ -16,25 +16,33 @@
 
 #define S3C_WDOGREG(x) ((x) + S3C_VA_WATCHDOG)
 
-#define S3C2410_WTCON	   S3C_WDOGREG(0x00)
-#define S3C2410_WTDAT	   S3C_WDOGREG(0x04)
-#define S3C2410_WTCNT	   S3C_WDOGREG(0x08)
+#define S3C_WTCON	   S3C_WDOGREG(0x00)
+#define S3C_WTDAT	   S3C_WDOGREG(0x04)
+#define S3C_WTCNT	   S3C_WDOGREG(0x08)
+
+#define S3C_WTCON_OFFSET	   (0x00)
+#define S3C_WTDAT_OFFSET	   (0x04)
+#define S3C_WTCNT_OFFSET	   (0x08)
+
+#define S3C_WTCNT_CNT	   (0x1)
+#define S3C_WTCNT_CON	   (0x7639)
+#define S3C_WTCNT_DAT	   (0xFFCF)
 
 /* the watchdog can either generate a reset pulse, or an
  * interrupt.
  */
 
-#define S3C2410_WTCON_RSTEN   (0x01)
-#define S3C2410_WTCON_INTEN   (1<<2)
-#define S3C2410_WTCON_ENABLE  (1<<5)
-
-#define S3C2410_WTCON_DIV16   (0<<3)
-#define S3C2410_WTCON_DIV32   (1<<3)
-#define S3C2410_WTCON_DIV64   (2<<3)
-#define S3C2410_WTCON_DIV128  (3<<3)
+#define S3C_WTCON_RSTEN   (0x01)
+#define S3C_WTCON_INTEN   (1<<2)
+#define S3C_WTCON_ENABLE  (1<<5)
+
+#define S3C_WTCON_DIV16   (0<<3)
+#define S3C_WTCON_DIV32   (1<<3)
+#define S3C_WTCON_DIV64   (2<<3)
+#define S3C_WTCON_DIV128  (3<<3)
 
-#define S3C2410_WTCON_PRESCALE(x) ((x) << 8)
-#define S3C2410_WTCON_PRESCALE_MASK (0xff00)
+#define S3C_WTCON_PRESCALE(x) ((x) << 8)
+#define S3C_WTCON_PRESCALE_MASK (0xff00)
 
 #endif /* __ASM_ARCH_REGS_WATCHDOG_H */
 
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/s3c-dma.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/s3c-dma.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/s3c-dma.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/s3c-dma.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,78 @@
+/* linux/arch/arm/plat-s3c/include/plat/dma.h
+ *
+ */
+
+#ifndef __ARM_PLAT_S3C_DMA_H
+#define __ARM_PLAT_S3C_DMA_H 
+
+extern struct sysdev_class dma_sysclass;
+extern struct s3c2410_dma_chan s3c2410_chans[S3C_DMA_CHANNELS];
+
+#define DMA_CH_VALID		(1<<31)
+#define DMA_CH_NEVER		(1<<30)
+
+struct s3c_dma_addr {
+	unsigned long		from;
+	unsigned long		to;
+};
+
+/* struct s3c_dma_map
+ *
+ * this holds the mapping information for the channel selected
+ * to be connected to the specified device
+*/
+
+struct s3c_dma_map {
+	const char		*name;
+	struct s3c_dma_addr  	hw_addr;
+
+	unsigned long		channels[S3C_DMA_CHANNELS];
+	unsigned long		channels_rx[S3C_DMA_CHANNELS];
+
+        unsigned long            sdma_sel;
+};
+
+struct s3c_dma_selection {
+	struct s3c_dma_map	*map;
+	unsigned long		 map_size;
+	unsigned long		 dcon_mask;
+
+	void	(*select)(struct s3c2410_dma_chan *chan,
+			  struct s3c_dma_map *map);
+
+	void	(*direction)(struct s3c2410_dma_chan *chan,
+			     struct s3c_dma_map *map,
+			     enum s3c2410_dmasrc dir);
+};
+
+extern int s3c_dma_init_map(struct s3c_dma_selection *sel);
+
+/* struct s3c_dma_order_ch
+ *
+ * channel map for one of the `enum dma_ch` dma channels. the list
+ * entry contains a set of low-level channel numbers, orred with
+ * DMA_CH_VALID, which are checked in the order in the array.
+*/
+
+struct s3c_dma_order_ch {
+	unsigned int	list[S3C_DMA_CHANNELS];	/* list of channels */
+	unsigned int	flags;				/* flags */
+};
+
+/* struct s3c_dma_order
+ *
+ * information provided by either the core or the board to give the
+ * dma system a hint on how to allocate channels
+*/
+
+struct s3c_dma_order {
+	struct s3c_dma_order_ch	channels[DMACH_MAX];
+};
+
+extern int s3c_dma_order_set(struct s3c_dma_order *map);
+
+/* DMA init code, called from the cpu support code */
+
+extern int s3c_dma_init(unsigned int channels, unsigned int irq,
+			    unsigned int stride);
+#endif //__ARM_PLAT_S3C_DMA_H
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/sdhci.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/sdhci.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/sdhci.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/sdhci.h	2010-05-06 12:42:45.634864134 +0700
@@ -45,8 +45,15 @@
 			    void __iomem *regbase,
 			    struct mmc_ios *ios,
 			    struct mmc_card *card);
+	/* add to deal with EXT_IRQ as a card detect pin */
+	void		(*cfg_ext_cd) (void);
+	unsigned int	(*detect_ext_cd) (void);
+	unsigned int	ext_cd;
+	struct sdhci_host*	sdhci_host;
 };
 
+extern void sdhci_s3c_force_presence_change(struct platform_device *pdev);
+
 /**
  * s3c_sdhci0_set_platdata - Set platform data for S3C SDHCI device.
  * @pd: Platform data to register to device.
@@ -57,6 +64,8 @@
  */
 extern void s3c_sdhci0_set_platdata(struct s3c_sdhci_platdata *pd);
 extern void s3c_sdhci1_set_platdata(struct s3c_sdhci_platdata *pd);
+extern void s3c_sdhci2_set_platdata(struct s3c_sdhci_platdata *pd);
+
 
 /* Default platform data, exported so that per-cpu initialisation can
  * set the correct one when there are more than one cpu type selected.
@@ -64,6 +73,7 @@
 
 extern struct s3c_sdhci_platdata s3c_hsmmc0_def_platdata;
 extern struct s3c_sdhci_platdata s3c_hsmmc1_def_platdata;
+extern struct s3c_sdhci_platdata s3c_hsmmc2_def_platdata;
 
 /* Helper function availablity */
 
@@ -72,6 +82,7 @@
 
 extern void s3c6410_setup_sdhci0_cfg_gpio(struct platform_device *, int w);
 extern void s3c6410_setup_sdhci1_cfg_gpio(struct platform_device *, int w);
+extern void s3c6410_setup_sdhci2_cfg_gpio(struct platform_device *, int w);
 
 extern void s3c6410_setup_sdhci0_cfg_card(struct platform_device *dev,
 					   void __iomem *r,
@@ -100,9 +111,22 @@
 static inline void s3c6410_default_sdhci1(void) { }
 #endif /* CONFIG_S3C_DEV_HSMMC1 */
 
+#ifdef CONFIG_S3C_DEV_HSMMC2
+static inline void s3c6410_default_sdhci2(void)
+{
+	s3c_hsmmc2_def_platdata.clocks = s3c6410_hsmmc_clksrcs;
+	s3c_hsmmc2_def_platdata.cfg_gpio = s3c6410_setup_sdhci2_cfg_gpio;
+	s3c_hsmmc2_def_platdata.cfg_card = s3c6410_setup_sdhci0_cfg_card;
+}
+#else
+static inline void s3c6410_default_sdhci2(void) { }
+#endif /* CONFIG_S3C_DEV_HSMMC2 */
+
+
 #else
 static inline void s3c6410_default_sdhci0(void) { }
 static inline void s3c6410_default_sdhci1(void) { }
+static inline void s3c6410_default_sdhci2(void) { }
 #endif /* CONFIG_S3C6410_SETUP_SDHCI */
 
 #endif /* __PLAT_S3C_SDHCI_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/ts.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/ts.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/ts.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/ts.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,27 @@
+/* linux/arch/arm/plat-s3c/include/plat/ts.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_TS_H
+#define __ASM_ARCH_TS_H __FILE__
+
+struct s3c_ts_mach_info {
+	struct s3c_adcts_channel_info adcts;
+	int             	sampling_time;
+	int			remove_max_min_sampling;
+	int			sampling_interval_ms;
+	int			screen_size_x;
+	int			screen_size_y;
+	int			use_tscal;
+	int			tscal[7];
+};
+
+extern void __init s3c_ts_set_platdata(struct s3c_ts_mach_info *pd);
+
+#endif /* __ASM_ARCH_TS_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c/include/plat/uncompress.h linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/uncompress.h
--- linux-2.6.29/arch/arm/plat-s3c/include/plat/uncompress.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/include/plat/uncompress.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* linux/include/asm-arm/plat-s3c/uncompress.h
+/* linux/arch/arm/plat-s3c/include/plat/uncompress.h
  *
  * Copyright 2003, 2007 Simtec Electronics
  *	http://armlinux.simtec.co.uk/
@@ -31,8 +31,8 @@
 #include <plat/regs-watchdog.h>
 
 /* working in physical space... */
-#undef S3C2410_WDOGREG
-#define S3C2410_WDOGREG(x) ((S3C24XX_PA_WATCHDOG + (x)))
+#undef S3C_WDOGREG
+#define S3C_WDOGREG(x) ((S3C24XX_PA_WATCHDOG + (x)))
 
 /* how many bytes we allow into the FIFO at a time in FIFO mode */
 #define FIFO_MAX	 (14)
@@ -64,11 +64,11 @@
 
 static void putc(int ch)
 {
-	if (uart_rd(S3C2410_UFCON) & S3C2410_UFCON_FIFOMODE) {
+	if (uart_rd(S3C_UFCON) & S3C_UFCON_FIFOMODE) {
 		int level;
 
 		while (1) {
-			level = uart_rd(S3C2410_UFSTAT);
+			level = uart_rd(S3C_UFSTAT);
 			level &= fifo_mask;
 
 			if (level < fifo_max)
@@ -78,12 +78,12 @@
 	} else {
 		/* not using fifos */
 
-		while ((uart_rd(S3C2410_UTRSTAT) & S3C2410_UTRSTAT_TXE) != S3C2410_UTRSTAT_TXE)
+		while ((uart_rd(S3C_UTRSTAT) & S3C_UTRSTAT_TXE) != S3C_UTRSTAT_TXE)
 			barrier();
 	}
 
 	/* write byte to transmission register */
-	uart_wr(S3C2410_UTXH, ch);
+	uart_wr(S3C_UTXH, ch);
 }
 
 static inline void flush(void)
@@ -104,14 +104,14 @@
 
 static inline void arch_decomp_wdog(void)
 {
-	__raw_writel(WDOG_COUNT, S3C2410_WTCNT);
+	__raw_writel(WDOG_COUNT, S3C_WTCNT);
 }
 
 static void arch_decomp_wdog_start(void)
 {
-	__raw_writel(WDOG_COUNT, S3C2410_WTDAT);
-	__raw_writel(WDOG_COUNT, S3C2410_WTCNT);
-	__raw_writel(S3C2410_WTCON_ENABLE | S3C2410_WTCON_DIV128 | S3C2410_WTCON_RSTEN | S3C2410_WTCON_PRESCALE(0x80), S3C2410_WTCON);
+	__raw_writel(WDOG_COUNT, S3C_WTDAT);
+	__raw_writel(WDOG_COUNT, S3C_WTCNT);
+	__raw_writel(S3C_WTCON_ENABLE | S3C_WTCON_DIV128 | S3C_WTCON_RSTEN | S3C_WTCON_PRESCALE(0x80), S3C_WTCON);
 }
 
 #else
@@ -127,9 +127,9 @@
 	putstr(x);
 	putstr("\n\n -- System resetting\n");
 
-	__raw_writel(0x4000, S3C2410_WTDAT);
-	__raw_writel(0x4000, S3C2410_WTCNT);
-	__raw_writel(S3C2410_WTCON_ENABLE | S3C2410_WTCON_DIV128 | S3C2410_WTCON_RSTEN | S3C2410_WTCON_PRESCALE(0x40), S3C2410_WTCON);
+	__raw_writel(0x4000, S3C_WTDAT);
+	__raw_writel(0x4000, S3C_WTCNT);
+	__raw_writel(S3C_WTCON_ENABLE | S3C_WTCON_DIV128 | S3C_WTCON_RSTEN | S3C_WTCON_PRESCALE(0x40), S3C_WTCON);
 
 	while(1);
 }
@@ -142,16 +142,16 @@
 #ifdef CONFIG_S3C_BOOT_UART_FORCE_FIFO
 static inline void arch_enable_uart_fifo(void)
 {
-	u32 fifocon = uart_rd(S3C2410_UFCON);
+	u32 fifocon = uart_rd(S3C_UFCON);
 
-	if (!(fifocon & S3C2410_UFCON_FIFOMODE)) {
-		fifocon |= S3C2410_UFCON_RESETBOTH;
-		uart_wr(S3C2410_UFCON, fifocon);
+	if (!(fifocon & S3C_UFCON_FIFOMODE)) {
+		fifocon |= S3C_UFCON_RESETBOTH;
+		uart_wr(S3C_UFCON, fifocon);
 
 		/* wait for fifo reset to complete */
 		while (1) {
-			fifocon = uart_rd(S3C2410_UFCON);
-			if (!(fifocon & S3C2410_UFCON_RESETBOTH))
+			fifocon = uart_rd(S3C_UFCON);
+			if (!(fifocon & S3C_UFCON_RESETBOTH))
 				break;
 		}
 	}
diff -Nur linux-2.6.29/arch/arm/plat-s3c/init.c linux-2.6.29-spica/arch/arm/plat-s3c/init.c
--- linux-2.6.29/arch/arm/plat-s3c/init.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/init.c	2010-05-06 12:42:45.634864134 +0700
@@ -17,6 +17,7 @@
 #include <linux/ioport.h>
 #include <linux/serial_core.h>
 #include <linux/platform_device.h>
+#include <linux/delay.h>
 
 #include <mach/hardware.h>
 
@@ -63,7 +64,7 @@
 	cpu->map_io();
 }
 
-/* s3c24xx_init_clocks
+/* s3c_init_clocks
  *
  * Initialise the clock subsystem and associated information from the
  * given master crystal value.
@@ -72,16 +73,16 @@
  *      != 0 -> PLL crystal value in Hz
 */
 
-void __init s3c24xx_init_clocks(int xtal)
+void __init s3c_init_clocks(int xtal)
 {
 	if (xtal == 0)
 		xtal = 12*1000*1000;
 
 	if (cpu == NULL)
-		panic("s3c24xx_init_clocks: no cpu setup?\n");
+		panic("s3c_init_clocks: no cpu setup?\n");
 
 	if (cpu->init_clocks == NULL)
-		panic("s3c24xx_init_clocks: cpu has no clock init\n");
+		panic("s3c_init_clocks: cpu has no clock init\n");
 	else
 		(cpu->init_clocks)(xtal);
 }
@@ -90,9 +91,9 @@
 
 static int nr_uarts __initdata = 0;
 
-static struct s3c2410_uartcfg uart_cfgs[CONFIG_SERIAL_SAMSUNG_UARTS];
+static struct s3c_uartcfg uart_cfgs[CONFIG_SERIAL_SAMSUNG_UARTS];
 
-/* s3c24xx_init_uartdevs
+/* s3c_init_uartdevs
  *
  * copy the specified platform data and configuration into our central
  * set of devices, before the data is thrown away after the init process.
@@ -101,23 +102,23 @@
  * early initialisation of the console.
 */
 
-void __init s3c24xx_init_uartdevs(char *name,
-				  struct s3c24xx_uart_resources *res,
-				  struct s3c2410_uartcfg *cfg, int no)
+void __init s3c_init_uartdevs(char *name,
+				  struct s3c_uart_resources *res,
+				  struct s3c_uartcfg *cfg, int no)
 {
 	struct platform_device *platdev;
-	struct s3c2410_uartcfg *cfgptr = uart_cfgs;
-	struct s3c24xx_uart_resources *resp;
+	struct s3c_uartcfg *cfgptr = uart_cfgs;
+	struct s3c_uart_resources *resp;
 	int uart;
 
-	memcpy(cfgptr, cfg, sizeof(struct s3c2410_uartcfg) * no);
+	memcpy(cfgptr, cfg, sizeof(struct s3c_uartcfg) * no);
 
 	for (uart = 0; uart < no; uart++, cfg++, cfgptr++) {
-		platdev = s3c24xx_uart_src[cfgptr->hwport];
+		platdev = s3c_uart_src[cfgptr->hwport];
 
 		resp = res + cfgptr->hwport;
 
-		s3c24xx_uart_devs[uart] = platdev;
+		s3c_uart_devs[uart] = platdev;
 
 		platdev->name = name;
 		platdev->resource = resp->resources;
@@ -129,13 +130,13 @@
 	nr_uarts = no;
 }
 
-void __init s3c24xx_init_uarts(struct s3c2410_uartcfg *cfg, int no)
+void __init s3c_init_uarts(struct s3c_uartcfg *cfg, int no)
 {
 	if (cpu == NULL)
 		return;
 
 	if (cpu->init_uarts == NULL) {
-		printk(KERN_ERR "s3c24xx_init_uarts: cpu has no uart init\n");
+		printk(KERN_ERR "s3c_init_uarts: cpu has no uart init\n");
 	} else
 		(cpu->init_uarts)(cfg, no);
 }
@@ -153,7 +154,7 @@
 	if (ret != 0)
 		return ret;
 
-	ret = platform_add_devices(s3c24xx_uart_devs, nr_uarts);
+	ret = platform_add_devices(s3c_uart_devs, nr_uarts);
 	return ret;
 }
 
diff -Nur linux-2.6.29/arch/arm/plat-s3c/Kconfig linux-2.6.29-spica/arch/arm/plat-s3c/Kconfig
--- linux-2.6.29/arch/arm/plat-s3c/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/Kconfig	2010-05-06 12:42:45.634864134 +0700
@@ -6,7 +6,7 @@
 
 config PLAT_S3C
 	bool
-	depends on ARCH_S3C2410 || ARCH_S3C24A0 || ARCH_S3C64XX
+	depends on ARCH_S3C2410 || ARCH_S3C24A0 || ARCH_S3C64XX || ARCH_S5PC1XX
 	default y
 	select NO_IOPORT
 	help
@@ -14,24 +14,26 @@
 
 # low-level serial option nodes
 
-if PLAT_S3C
-
 config CPU_LLSERIAL_S3C2410_ONLY
 	bool
+	depends on PLAT_S3C
 	default y if CPU_LLSERIAL_S3C2410 && !CPU_LLSERIAL_S3C2440
 
 config CPU_LLSERIAL_S3C2440_ONLY
 	bool
+	depends on PLAT_S3C
 	default y if CPU_LLSERIAL_S3C2440 && !CPU_LLSERIAL_S3C2410
 
 config CPU_LLSERIAL_S3C2410
 	bool
+	depends on PLAT_S3C
 	help
 	  Selected if there is an S3C2410 (or register compatible) serial
 	  low-level implementation needed
 
 config CPU_LLSERIAL_S3C2440
 	bool
+	depends on PLAT_S3C
 	help
 	  Selected if there is an S3C2440 (or register compatible) serial
 	  low-level implementation needed
@@ -42,7 +44,7 @@
 
 config S3C_BOOT_WATCHDOG
 	bool "S3C Initialisation watchdog"
-	depends on S3C2410_WATCHDOG
+	depends on PLAT_S3C && S3C2410_WATCHDOG
 	help
 	  Say y to enable the watchdog during the kernel decompression
 	  stage. If the kernel fails to uncompress, then the watchdog
@@ -50,6 +52,7 @@
 
 config S3C_BOOT_ERROR_RESET
 	bool "S3C Reboot on decompression error"
+	depends on PLAT_S3C
 	help
 	  Say y here to use the watchdog to reset the system if the
 	  kernel decompressor detects an error during decompression.
@@ -63,17 +66,17 @@
 
 comment "Power management"
 
-config S3C2410_PM_DEBUG
-	bool "S3C2410 PM Suspend debug"
-	depends on PM
+config S3C_PM_DEBUG
+	bool "S3C PM Suspend debug"
+	depends on PLAT_S3C && PM
 	help
 	  Say Y here if you want verbose debugging from the PM Suspend and
 	  Resume code. See <file:Documentation/arm/Samsung-S3C24XX/Suspend.txt>
 	  for more information.
 
-config S3C2410_PM_CHECK
-	bool "S3C2410 PM Suspend Memory CRC"
-	depends on PM && CRC32
+config S3C_PM_CHECK
+	bool "S3C PM Suspend Memory CRC"
+	depends on PLAT_S3C && PM && CRC32
 	help
  	  Enable the PM code's memory area checksum over sleep. This option
 	  will generate CRCs of all blocks of memory, and store them before
@@ -85,9 +88,9 @@
 
 	  See <file:Documentation/arm/Samsung-S3C24XX/Suspend.txt>
 
-config S3C2410_PM_CHECK_CHUNKSIZE
-	int "S3C2410 PM Suspend CRC Chunksize (KiB)"
-	depends on PM && S3C2410_PM_CHECK
+config S3C_PM_CHECK_CHUNKSIZE
+	int "S3C PM Suspend CRC Chunksize (KiB)"
+	depends on PLAT_S3C && PM && S3C_PM_CHECK
 	default 64
 	help
 	  Set the chunksize in Kilobytes of the CRC for checking memory
@@ -99,6 +102,7 @@
 
 config S3C_LOWLEVEL_UART_PORT
 	int "S3C UART to use for low-level messages"
+	depends on PLAT_S3C
 	default 0
 	help
 	  Choice of which UART port to use for the low-level messages,
@@ -106,6 +110,12 @@
 	  this configuration should be between zero and two. The port
 	  must have been initialised by the boot-loader before use.
 
+config SPLIT_ROOT_FILESYSTEM
+	bool "S3C MTD has 4 partitions"
+	depends on ARCH_S3C64XX && MTD
+	help
+	  Choose this if you want to use 4 mtd partitions
+
 # options for gpiolib support
 
 config S3C_GPIO_SPACE
@@ -154,22 +164,69 @@
 
 config S3C_DEV_HSMMC
 	bool
+	depends on PLAT_S3C
 	help
 	  Compile in platform device definitions for HSMMC code
 
 config S3C_DEV_HSMMC1
 	bool
+	depends on PLAT_S3C
 	help
 	  Compile in platform device definitions for HSMMC channel 1
 
-config S3C_DEV_I2C1
+config S3C_DEV_HSMMC2
 	bool
+	depends on PLAT_S3C
 	help
-	  Compile in platform device definitions for I2C channel 1
+	  Compile in platform device definitions for HSMMC channel 2
 
-config S3C_DEV_FB
+config S3C_DEV_I2C1
 	bool
+	depends on PLAT_S3C
 	help
-	  Compile in platform device definition for framebuffer
+	  Compile in platform device definitions for I2C channel 1
+
+config S3C_DEV_ADC
+        bool
+	depends on PLAT_S3C
+        help
+          Compile in platform device definitions for ADC
+
+comment "Select DMA Controller"
+choice 
+	prompt"Samsung S3C6410 DMA Controller"
+	default S3C_DMA_PL080_SOL
+
+	config S3C_DMA_PL080_SOL
+	bool "DMA PL080 Sol"
+	depends on PLAT_S3C
+	help
+	  PL080 DMA supported 
+
+	config S3C_DMA_PL080
+	bool "DMA PL080 AP"
+	depends on PLAT_S3C
+	help
+	  PL080 DMA supported
+
+	config S3C_DMA_PL330
+	bool "DMA PL330"
+	depends on PLAT_S3C
+	help
+	  PL330 DMA supported
+endchoice
+
+#option for OS tick timer (fixed/dynamic)
+choice
+	prompt "OS Timer support "
+	default DYNAMIC_TIMER
+
+	config FIXED_TIMER
+	bool "Fixed Tick timer"
+
+	config DYNAMIC_TIMER
+	bool "Tickless and HR Timer"
+	select GENERIC_TIME
+	select GENERIC_CLOCKEVENTS
 
-endif
+endchoice
diff -Nur linux-2.6.29/arch/arm/plat-s3c/Makefile linux-2.6.29-spica/arch/arm/plat-s3c/Makefile
--- linux-2.6.29/arch/arm/plat-s3c/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/Makefile	2010-05-06 12:42:45.634864134 +0700
@@ -11,17 +11,26 @@
 
 # Core support for all Samsung SoCs
 
-obj-y				+=  init.o
+obj-y				+= init.o
+ifdef CONFIG_HIGH_RES_TIMERS
+obj-y                           += hr-time.o
+else
 obj-y				+= time.o
+endif
 obj-y				+= clock.o
 obj-y				+= pwm-clock.o
 obj-y				+= gpio.o
 obj-y				+= gpio-config.o
+obj-y				+= egpio.o
+obj-$(CONFIG_S3C_DMA_PL080)		+= dma-pl080.o
+obj-$(CONFIG_S3C_DMA_PL080_SOL)	+= dma-pl080-sol.o
+obj-$(CONFIG_S3C_DMA_PL330)		+= dma-pl330.o 
 
 # devices
-
 obj-$(CONFIG_S3C_DEV_HSMMC)	+= dev-hsmmc.o
 obj-$(CONFIG_S3C_DEV_HSMMC1)	+= dev-hsmmc1.o
+obj-$(CONFIG_S3C_DEV_HSMMC2)	+= dev-hsmmc2.o
 obj-y				+= dev-i2c0.o
 obj-$(CONFIG_S3C_DEV_I2C1)	+= dev-i2c1.o
-obj-$(CONFIG_S3C_DEV_FB)	+= dev-fb.o
+obj-$(CONFIG_TOUCHSCREEN_S3C)	+= dev-ts.o
+obj-$(CONFIG_SND_S3C6410_SOC_I2S)	+= dev-i2s.o
diff -Nur linux-2.6.29/arch/arm/plat-s3c/pwm-clock.c linux-2.6.29-spica/arch/arm/plat-s3c/pwm-clock.c
--- linux-2.6.29/arch/arm/plat-s3c/pwm-clock.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/pwm-clock.c	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* linux/arch/arm/plat-s3c24xx/pwm-clock.c
+/* linux/arch/arm/plat-s3c/pwm-clock.c
  *
  * Copyright (c) 2007 Simtec Electronics
  * Copyright (c) 2007, 2008 Ben Dooks
@@ -14,7 +14,6 @@
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/errno.h>
-#include <linux/log2.h>
 #include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/io.h>
@@ -27,7 +26,6 @@
 #include <plat/cpu.h>
 
 #include <plat/regs-timer.h>
-#include <mach/pwm-clock.h>
 
 /* Each of the timers 0 through 5 go through the following
  * clock tree, with the inputs depending on the timers.
@@ -73,77 +71,32 @@
  * tclk -------------------------/
 */
 
-static struct clk clk_timer_scaler[];
-
-static unsigned long clk_pwm_scaler_get_rate(struct clk *clk)
+static unsigned long clk_pwm_scaler_getrate(struct clk *clk)
 {
-	unsigned long tcfg0 = __raw_readl(S3C2410_TCFG0);
+	unsigned long tcfg0 = __raw_readl(S3C_TCFG0);
 
-	if (clk == &clk_timer_scaler[1]) {
-		tcfg0 &= S3C2410_TCFG_PRESCALER1_MASK;
-		tcfg0 >>= S3C2410_TCFG_PRESCALER1_SHIFT;
+	if (clk->id == 1) {
+		tcfg0 &= S3C_TCFG_PRESCALER1_MASK;
+		tcfg0 >>= S3C_TCFG_PRESCALER1_SHIFT;
 	} else {
-		tcfg0 &= S3C2410_TCFG_PRESCALER0_MASK;
+		tcfg0 &= S3C_TCFG_PRESCALER0_MASK;
 	}
 
 	return clk_get_rate(clk->parent) / (tcfg0 + 1);
 }
 
-static unsigned long clk_pwm_scaler_round_rate(struct clk *clk,
-					       unsigned long rate)
-{
-	unsigned long parent_rate = clk_get_rate(clk->parent);
-	unsigned long divisor = parent_rate / rate;
-
-	if (divisor > 256)
-		divisor = 256;
-	else if (divisor < 2)
-		divisor = 2;
-
-	return parent_rate / divisor;
-}
-
-static int clk_pwm_scaler_set_rate(struct clk *clk, unsigned long rate)
-{
-	unsigned long round = clk_pwm_scaler_round_rate(clk, rate);
-	unsigned long tcfg0;
-	unsigned long divisor;
-	unsigned long flags;
-
-	divisor = clk_get_rate(clk->parent) / round;
-	divisor--;
-
-	local_irq_save(flags);
-	tcfg0 = __raw_readl(S3C2410_TCFG0);
-
-	if (clk == &clk_timer_scaler[1]) {
-		tcfg0 &= ~S3C2410_TCFG_PRESCALER1_MASK;
-		tcfg0 |= divisor << S3C2410_TCFG_PRESCALER1_SHIFT;
-	} else {
-		tcfg0 &= ~S3C2410_TCFG_PRESCALER0_MASK;
-		tcfg0 |= divisor;
-	}
-
-	__raw_writel(tcfg0, S3C2410_TCFG0);
-	local_irq_restore(flags);
-
-	return 0;
-}
+/* TODO - add set rate calls. */
 
 static struct clk clk_timer_scaler[] = {
 	[0]	= {
 		.name		= "pwm-scaler0",
 		.id		= -1,
-		.get_rate	= clk_pwm_scaler_get_rate,
-		.set_rate	= clk_pwm_scaler_set_rate,
-		.round_rate	= clk_pwm_scaler_round_rate,
+		.get_rate	= clk_pwm_scaler_getrate,
 	},
 	[1]	= {
 		.name		= "pwm-scaler1",
 		.id		= -1,
-		.get_rate	= clk_pwm_scaler_get_rate,
-		.set_rate	= clk_pwm_scaler_set_rate,
-		.round_rate	= clk_pwm_scaler_round_rate,
+		.get_rate	= clk_pwm_scaler_getrate,
 	},
 };
 
@@ -168,15 +121,20 @@
 	return container_of(clk, struct pwm_tdiv_clk, clk);
 }
 
+static inline unsigned long tcfg_to_divisor(unsigned long tcfg1)
+{
+	return 1 << (1 + tcfg1);
+}
+
 static unsigned long clk_pwm_tdiv_get_rate(struct clk *clk)
 {
-	unsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);
+	unsigned long tcfg1 = __raw_readl(S3C_TCFG1);
 	unsigned int divisor;
 
-	tcfg1 >>= S3C2410_TCFG1_SHIFT(clk->id);
-	tcfg1 &= S3C2410_TCFG1_MUX_MASK;
+	tcfg1 >>= S3C_TCFG1_SHIFT(clk->id);
+	tcfg1 &= S3C_TCFG1_MUX_MASK;
 
-	if (pwm_cfg_src_is_tclk(tcfg1))
+	if (tcfg1 == S3C_TCFG1_MUX_TCLK)
 		divisor = to_tdiv(clk)->divisor;
 	else
 		divisor = tcfg_to_divisor(tcfg1);
@@ -193,9 +151,7 @@
 	parent_rate = clk_get_rate(clk->parent);
 	divisor = parent_rate / rate;
 
-	if (divisor <= 1 && pwm_tdiv_has_div1())
-		divisor = 1;
-	else if (divisor <= 2)
+	if (divisor <= 2)
 		divisor = 2;
 	else if (divisor <= 4)
 		divisor = 4;
@@ -209,22 +165,40 @@
 
 static unsigned long clk_pwm_tdiv_bits(struct pwm_tdiv_clk *divclk)
 {
-	return pwm_tdiv_div_bits(divclk->divisor);
+	unsigned long bits;
+
+	switch (divclk->divisor) {
+	case 2:
+		bits = S3C_TCFG1_MUX_DIV2;
+		break;
+	case 4:
+		bits = S3C_TCFG1_MUX_DIV4;
+		break;
+	case 8:
+		bits = S3C_TCFG1_MUX_DIV8;
+		break;
+	case 16:
+	default:
+		bits = S3C_TCFG1_MUX_DIV16;
+		break;
+	}
+
+	return bits;
 }
 
 static void clk_pwm_tdiv_update(struct pwm_tdiv_clk *divclk)
 {
-	unsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);
+	unsigned long tcfg1 = __raw_readl(S3C_TCFG1);
 	unsigned long bits = clk_pwm_tdiv_bits(divclk);
 	unsigned long flags;
-	unsigned long shift =  S3C2410_TCFG1_SHIFT(divclk->clk.id);
+	unsigned long shift =  S3C_TCFG1_SHIFT(divclk->clk.id);
 
 	local_irq_save(flags);
 
-	tcfg1 = __raw_readl(S3C2410_TCFG1);
-	tcfg1 &= ~(S3C2410_TCFG1_MUX_MASK << shift);
+	tcfg1 = __raw_readl(S3C_TCFG1);
+	tcfg1 &= ~(S3C_TCFG1_MUX_MASK << shift);
 	tcfg1 |= bits << shift;
-	__raw_writel(tcfg1, S3C2410_TCFG1);
+	__raw_writel(tcfg1, S3C_TCFG1);
 
 	local_irq_restore(flags);
 }
@@ -232,12 +206,12 @@
 static int clk_pwm_tdiv_set_rate(struct clk *clk, unsigned long rate)
 {
 	struct pwm_tdiv_clk *divclk = to_tdiv(clk);
-	unsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);
+	unsigned long tcfg1 = __raw_readl(S3C_TCFG1);
 	unsigned long parent_rate = clk_get_rate(clk->parent);
 	unsigned long divisor;
 
-	tcfg1 >>= S3C2410_TCFG1_SHIFT(clk->id);
-	tcfg1 &= S3C2410_TCFG1_MUX_MASK;
+	tcfg1 >>= S3C_TCFG1_SHIFT(clk->id);
+	tcfg1 &= S3C_TCFG1_MUX_MASK;
 
 	rate = clk_round_rate(clk, rate);
 	divisor = parent_rate / rate;
@@ -250,7 +224,7 @@
 	/* Update the current MUX settings if we are currently
 	 * selected as the clock source for this clock. */
 
-	if (!pwm_cfg_src_is_tclk(tcfg1))
+	if (tcfg1 != S3C_TCFG1_MUX_TCLK)
 		clk_pwm_tdiv_update(divclk);
 
 	return 0;
@@ -307,15 +281,15 @@
 static int __init clk_pwm_tdiv_register(unsigned int id)
 {
 	struct pwm_tdiv_clk *divclk = &clk_timer_tdiv[id];
-	unsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);
+	unsigned long tcfg1 = __raw_readl(S3C_TCFG1);
 
-	tcfg1 >>= S3C2410_TCFG1_SHIFT(id);
-	tcfg1 &= S3C2410_TCFG1_MUX_MASK;
+	tcfg1 >>= S3C_TCFG1_SHIFT(id);
+	tcfg1 &= S3C_TCFG1_MUX_MASK;
 
 	divclk->clk.id = id;
 	divclk->divisor = tcfg_to_divisor(tcfg1);
 
-	return s3c24xx_register_clock(&divclk->clk);
+	return s3c_register_clock(&divclk->clk);
 }
 
 static inline struct clk *s3c24xx_pwmclk_tclk(unsigned int id)
@@ -334,7 +308,7 @@
 	unsigned long tcfg1;
 	unsigned long flags;
 	unsigned long bits;
-	unsigned long shift = S3C2410_TCFG1_SHIFT(id);
+	unsigned long shift = S3C_TCFG1_SHIFT(id);
 
 	if (parent == s3c24xx_pwmclk_tclk(id))
 		bits = S3C_TCFG1_MUX_TCLK << shift;
@@ -347,9 +321,9 @@
 
 	local_irq_save(flags);
 
-	tcfg1 = __raw_readl(S3C2410_TCFG1);
-	tcfg1 &= ~(S3C2410_TCFG1_MUX_MASK << shift);
-	__raw_writel(tcfg1 | bits, S3C2410_TCFG1);
+	tcfg1 = __raw_readl(S3C_TCFG1);
+	tcfg1 &= ~(S3C_TCFG1_MUX_MASK << shift);
+	__raw_writel(tcfg1 | bits, S3C_TCFG1);
 
 	local_irq_restore(flags);
 
@@ -386,20 +360,20 @@
 
 static __init int clk_pwm_tin_register(struct clk *pwm)
 {
-	unsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);
+	unsigned long tcfg1 = __raw_readl(S3C_TCFG1);
 	unsigned int id = pwm->id;
 
 	struct clk *parent;
 	int ret;
 
-	ret = s3c24xx_register_clock(pwm);
+	ret = s3c_register_clock(pwm);
 	if (ret < 0)
 		return ret;
 
-	tcfg1 >>= S3C2410_TCFG1_SHIFT(id);
-	tcfg1 &= S3C2410_TCFG1_MUX_MASK;
+	tcfg1 >>= S3C_TCFG1_SHIFT(id);
+	tcfg1 &= S3C_TCFG1_MUX_MASK;
 
-	if (pwm_cfg_src_is_tclk(tcfg1))
+	if (tcfg1 == S3C_TCFG1_MUX_TCLK)
 		parent = s3c24xx_pwmclk_tclk(id);
 	else
 		parent = s3c24xx_pwmclk_tdiv(id);
@@ -407,16 +381,7 @@
 	return clk_set_parent(pwm, parent);
 }
 
-/**
- * s3c_pwmclk_init() - initialise pwm clocks
- *
- * Initialise and register the clocks which provide the inputs for the
- * pwm timer blocks.
- *
- * Note, this call is required by the time core, so must be called after
- * the base clocks are added and before any of the initcalls are run.
- */
-__init void s3c_pwmclk_init(void)
+static __init int s3c24xx_pwmclk_init(void)
 {
 	struct clk *clk_timers;
 	unsigned int clk;
@@ -425,23 +390,23 @@
 	clk_timers = clk_get(NULL, "timers");
 	if (IS_ERR(clk_timers)) {
 		printk(KERN_ERR "%s: no parent clock\n", __func__);
-		return;
+		return -EINVAL;
 	}
 
 	for (clk = 0; clk < ARRAY_SIZE(clk_timer_scaler); clk++) {
 		clk_timer_scaler[clk].parent = clk_timers;
-		ret = s3c24xx_register_clock(&clk_timer_scaler[clk]);
+		ret = s3c_register_clock(&clk_timer_scaler[clk]);
 		if (ret < 0) {
 			printk(KERN_ERR "error adding pwm scaler%d clock\n", clk);
-			return;
+			goto err;
 		}
 	}
 
 	for (clk = 0; clk < ARRAY_SIZE(clk_timer_tclk); clk++) {
-		ret = s3c24xx_register_clock(&clk_timer_tclk[clk]);
+		ret = s3c_register_clock(&clk_timer_tclk[clk]);
 		if (ret < 0) {
 			printk(KERN_ERR "error adding pww tclk%d\n", clk);
-			return;
+			goto err;
 		}
 	}
 
@@ -449,7 +414,7 @@
 		ret = clk_pwm_tdiv_register(clk);
 		if (ret < 0) {
 			printk(KERN_ERR "error adding pwm%d tdiv clock\n", clk);
-			return;
+			goto err;
 		}
 	}
 
@@ -457,7 +422,14 @@
 		ret = clk_pwm_tin_register(&clk_tin[clk]);
 		if (ret < 0) {
 			printk(KERN_ERR "error adding pwm%d tin clock\n", clk);
-			return;
+			goto err;
 		}
 	}
+
+	return 0;
+
+ err:
+	return ret;
 }
+
+arch_initcall(s3c24xx_pwmclk_init);
diff -Nur linux-2.6.29/arch/arm/plat-s3c/time.c linux-2.6.29-spica/arch/arm/plat-s3c/time.c
--- linux-2.6.29/arch/arm/plat-s3c/time.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c/time.c	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* linux/arch/arm/plat-s3c24xx/time.c
+/* linux/arch/arm/plat-s3c/time.c
  *
  * Copyright (C) 2003-2005 Simtec Electronics
  *	Ben Dooks, <ben@simtec.co.uk>
@@ -26,7 +26,6 @@
 #include <linux/err.h>
 #include <linux/clk.h>
 #include <linux/io.h>
-#include <linux/platform_device.h>
 
 #include <asm/system.h>
 #include <asm/leds.h>
@@ -104,7 +103,7 @@
 
 	/* work out how many ticks have gone since last timer interrupt */
 
-	tval =  __raw_readl(S3C2410_TCNTO(4));
+	tval =  __raw_readl(S3C_TCNTO(4));
 	tdone = timer_startval - tval;
 
 	/* check to see if there is an interrupt pending */
@@ -115,7 +114,7 @@
 		 * timer has re-loaded from wrapping.
 		 */
 
-		tval =  __raw_readl(S3C2410_TCNTO(4));
+		tval =  __raw_readl(S3C_TCNTO(4));
 		tdone = timer_startval - tval;
 
 		if (tval != 0)
@@ -148,10 +147,6 @@
 	machine_is_anubis()	|| \
 	machine_is_osiris())
 
-static struct clk *tin;
-static struct clk *tdiv;
-static struct clk *timerclk;
-
 /*
  * Set up timer interrupt, and return the current time in seconds.
  *
@@ -167,6 +162,12 @@
 
 	tcnt = TICK_MAX;  /* default value for tcnt */
 
+	/* read the current timer configuration bits */
+
+	tcon = __raw_readl(S3C_TCON);
+	tcfg1 = __raw_readl(S3C_TCFG1);
+	tcfg0 = __raw_readl(S3C_TCFG0);
+
 	/* configure the system for whichever machine is in use */
 
 	if (use_tclk1_12()) {
@@ -174,13 +175,11 @@
 		timer_usec_ticks = timer_mask_usec_ticks(1, 12000000);
 		tcnt = 12000000 / HZ;
 
-		tcfg1 = __raw_readl(S3C2410_TCFG1);
-		tcfg1 &= ~S3C2410_TCFG1_MUX4_MASK;
-		tcfg1 |= S3C2410_TCFG1_MUX4_TCLK1;
-		__raw_writel(tcfg1, S3C2410_TCFG1);
+		tcfg1 &= ~S3C_TCFG1_MUX4_MASK;
+		tcfg1 |= S3C_TCFG1_MUX4_TCLK1;
 	} else {
 		unsigned long pclk;
-		struct clk *tscaler;
+		struct clk *clk;
 
 		/* for the h1940 (and others), we use the pclk from the core
 		 * to generate the timer values. since values around 50 to
@@ -191,25 +190,29 @@
 		 * (8.45 ticks per usec)
 		 */
 
-		pclk = clk_get_rate(timerclk);
+		/* this is used as default if no other timer can be found */
+
+		clk = clk_get(NULL, "timers");
+		if (IS_ERR(clk))
+			panic("failed to get clock for system timer");
+
+		clk_enable(clk);
+
+		pclk = clk_get_rate(clk);
 
 		/* configure clock tick */
 
 		timer_usec_ticks = timer_mask_usec_ticks(6, pclk);
 
-		tscaler = clk_get_parent(tdiv);
+		tcfg1 &= ~S3C_TCFG1_MUX4_MASK;
+		tcfg1 |= S3C_TCFG1_MUX4_DIV2;
 
-		clk_set_rate(tscaler, pclk / 3);
-		clk_set_rate(tdiv, pclk / 6);
-		clk_set_parent(tin, tdiv);
+		tcfg0 &= ~S3C_TCFG_PRESCALER1_MASK;
+		tcfg0 |= ((6 - 1) / 2) << S3C_TCFG_PRESCALER1_SHIFT;
 
-		tcnt = clk_get_rate(tin) / HZ;
+		tcnt = (pclk / 6) / HZ;
 	}
 
-	tcon = __raw_readl(S3C2410_TCON);
-	tcfg0 = __raw_readl(S3C2410_TCFG0);
-	tcfg1 = __raw_readl(S3C2410_TCFG1);
-
 	/* timers reload after counting zero, so reduce the count by 1 */
 
 	tcnt--;
@@ -223,63 +226,148 @@
 		return;
 	}
 
-	__raw_writel(tcfg1, S3C2410_TCFG1);
-	__raw_writel(tcfg0, S3C2410_TCFG0);
+	__raw_writel(tcfg1, S3C_TCFG1);
+	__raw_writel(tcfg0, S3C_TCFG0);
 
 	timer_startval = tcnt;
-	__raw_writel(tcnt, S3C2410_TCNTB(4));
+	__raw_writel(tcnt, S3C_TCNTB(4));
 
 	/* ensure timer is stopped... */
 
 	tcon &= ~(7<<20);
-	tcon |= S3C2410_TCON_T4RELOAD;
-	tcon |= S3C2410_TCON_T4MANUALUPD;
+	tcon |= S3C_TCON_T4RELOAD;
+	tcon |= S3C_TCON_T4MANUALUPD;
 
-	__raw_writel(tcon, S3C2410_TCON);
-	__raw_writel(tcnt, S3C2410_TCNTB(4));
-	__raw_writel(tcnt, S3C2410_TCMPB(4));
+	__raw_writel(tcon, S3C_TCON);
+	__raw_writel(tcnt, S3C_TCNTB(4));
+	__raw_writel(tcnt, S3C_TCMPB(4));
 
 	/* start the timer running */
-	tcon |= S3C2410_TCON_T4START;
-	tcon &= ~S3C2410_TCON_T4MANUALUPD;
-	__raw_writel(tcon, S3C2410_TCON);
+	tcon |= S3C_TCON_T4START;
+	tcon &= ~S3C_TCON_T4MANUALUPD;
+	__raw_writel(tcon, S3C_TCON);
 }
 
-static void __init s3c2410_timer_resources(void)
+static void s3c64xx_timer_setup (void)
 {
-	struct platform_device tmpdev;
+	unsigned long tcon;
+	unsigned long tcnt;
+	unsigned long tcfg1;
+	unsigned long tcfg0;
+
+	tcnt = TICK_MAX;  /* default value for tcnt */
+
+	/* read the current timer configuration bits */
+
+	tcon = __raw_readl(S3C_TCON);
+	tcfg1 = __raw_readl(S3C_TCFG1);
+	tcfg0 = __raw_readl(S3C_TCFG0);
+
+	/* configure the system for whichever machine is in use */
+
+	if (use_tclk1_12()) {
+		/* timer is at 12MHz, scaler is 1 */
+		timer_usec_ticks = timer_mask_usec_ticks(1, 12000000);
+		tcnt = 12000000 / HZ;
+
+		tcfg1 &= ~S3C_TCFG1_MUX4_MASK;
+		tcfg1 |= S3C_TCFG1_MUX4_TCLK1;
+	} else {
+		unsigned long pclk;
+		struct clk *clk;
+
+		/* for the h1940 (and others), we use the pclk from the core
+		 * to generate the timer values. since values around 50 to
+		 * 70MHz are not values we can directly generate the timer
+		 * value from, we need to pre-scale and divide before using it.
+		 *
+		 * for instance, using 50.7MHz and dividing by 6 gives 8.45MHz
+		 * (8.45 ticks per usec)
+		 */
+
+		/* this is used as default if no other timer can be found */
+
+		clk = clk_get(NULL, "timers");
+		if (IS_ERR(clk))
+			panic("failed to get clock for system timer");
 
-	tmpdev.dev.bus = &platform_bus_type;
-	tmpdev.id = 4;
+		clk_enable(clk);
 
-	timerclk = clk_get(NULL, "timers");
-	if (IS_ERR(timerclk))
-		panic("failed to get clock for system timer");
+		pclk = clk_get_rate(clk);
 
-	clk_enable(timerclk);
+		/* configure clock tick */
+
+		timer_usec_ticks = timer_mask_usec_ticks(6, pclk);
+
+		tcfg1 &= ~S3C_TCFG1_MUX4_MASK;
+		tcfg1 |= S3C_TCFG1_MUX4_DIV1;
+
+		tcfg0 &= ~S3C_TCFG_PRESCALER1_MASK;
+		tcfg0 |= (6) << S3C_TCFG_PRESCALER1_SHIFT;
+
+		tcnt = (pclk / 7) / HZ;
+	}
+
+	/* timers reload after counting zero, so reduce the count by 1 */
 
-	if (!use_tclk1_12()) {
-		tin = clk_get(&tmpdev.dev, "pwm-tin");
-		if (IS_ERR(tin))
-			panic("failed to get pwm-tin clock for system timer");
+	tcnt--;
 
-		tdiv = clk_get(&tmpdev.dev, "pwm-tdiv");
-		if (IS_ERR(tdiv))
-			panic("failed to get pwm-tdiv clock for system timer");
+	printk(KERN_DEBUG "timer tcon=%08lx, tcnt %04lx, tcfg %08lx,%08lx, usec %08lx\n",
+	       tcon, tcnt, tcfg0, tcfg1, timer_usec_ticks);
+
+	/* check to see if timer is within 16bit range... */
+	if (tcnt > TICK_MAX) {
+		panic("setup_timer: HZ is too small, cannot configure timer!");
+		return;
 	}
 
-	clk_enable(tin);
+	__raw_writel(tcfg1, S3C_TCFG1);
+	__raw_writel(tcfg0, S3C_TCFG0);
+
+	timer_startval = tcnt;
+	__raw_writel(tcnt, S3C_TCNTB(4));
+
+	/* ensure timer is stopped... */
+
+	tcon &= ~(7<<20);
+	tcon |= S3C_TCON_T4RELOAD;
+	tcon |= S3C_TCON_T4MANUALUPD;
+
+	__raw_writel(tcon, S3C_TCON);
+	__raw_writel(tcnt, S3C_TCNTB(4));
+	__raw_writel(tcnt, S3C_TCMPB(4));
+
+	/* start the timer running */
+	tcon |= S3C_TCON_T4START;
+	tcon &= ~S3C_TCON_T4MANUALUPD;
+	__raw_writel(tcon, S3C_TCON);
+
+	/* Timer interrupt Enable */
+	__raw_writel(__raw_readl(S3C_TINT_CSTAT) | S3C_TINT_CSTAT_T4INTEN , S3C_TINT_CSTAT);
 }
 
+
 static void __init s3c2410_timer_init(void)
 {
-	s3c2410_timer_resources();
 	s3c2410_timer_setup();
 	setup_irq(IRQ_TIMER4, &s3c2410_timer_irq);
 }
 
+static void __init s3c64xx_timer_init(void)
+{
+	s3c64xx_timer_setup();
+	setup_irq(IRQ_TIMER4, &s3c2410_timer_irq);
+}
+
 struct sys_timer s3c24xx_timer = {
 	.init		= s3c2410_timer_init,
 	.offset		= s3c2410_gettimeoffset,
 	.resume		= s3c2410_timer_setup
 };
+
+struct sys_timer s3c64xx_timer = {
+	.init		= s3c64xx_timer_init,
+	.offset		= s3c2410_gettimeoffset,
+	.resume		= s3c64xx_timer_setup
+};
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/changefreq.S linux-2.6.29-spica/arch/arm/plat-s3c64xx/changefreq.S
--- linux-2.6.29/arch/arm/plat-s3c64xx/changefreq.S	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/changefreq.S	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,97 @@
+/* linux/arch/arm/plat-s3c64xx/changefreq.S
+ *
+ * Copyright 2009 Samsung Electronics
+ *	
+ *	http://samsung.samsungsemi.com/
+ *
+ * S3C64XX CPU clock change code
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/map.h>
+
+#define I_Bit	(0x80)
+#define F_Bit	(0x40)
+#define R1_BP	(0x800)	
+
+	.text
+
+	/*---------------------------------
+	 *	s3c6410_changedivider
+	 *--------------------------------- */
+ENTRY(s3c6410_changedivider)
+
+	stmfd	sp!, {r0-r5, r14}
+
+	mov		r5, r0
+	bl		System_DisableIRQ
+	bl		System_EnableBP
+
+	mov		r2, #0
+	mov		r3, #0
+loopcd:
+	add 		r3, r3, #1
+	mov 		r4, #0
+	mcr 		p15, 0, r2, c7, c10, 4 /* data synchronization barrier instruction */
+	mcr 		p15, 0, r2, c7, c10, 5 /* data memory barrier operation */
+	cmp 		r3, #2
+	streq 		r5, [r1]
+
+loop1000:
+	add 		r4, r4, #1
+	cmp 		r4, #0x100
+	bne 		loop1000
+	cmp 		r3, #2
+	bne 		loopcd
+
+	bl		System_DisableBP
+	bl		System_EnableIRQ
+
+	ldmfd   	sp!, {r0-r5, r14}
+	bx		lr
+		
+	/*---------------------
+	 *	Disable IRQ
+	 *-------------------- */
+System_DisableIRQ:
+	mrs		r0,cpsr
+	orr		r0,r0,#I_Bit
+	msr		cpsr_cxsf,r0
+	bx		lr
+
+	/*---------------------
+	 *	Enable IRQ
+ 	 *-------------------- */
+System_EnableIRQ:
+	mrs		r0,cpsr
+	bic		r0,r0,#I_Bit
+	msr		cpsr_cxsf,r0
+	bx		lr
+
+	/*---------------------------------
+	 *	Enable Branch Prediction
+	 *-------------------------------- */
+System_EnableBP:
+	mrc		p15,0,r0,c1,c0,0
+	orr		r0,r0,#R1_BP
+	mcr		p15,0,r0,c1,c0,0
+	bx		lr
+
+	/*---------------------------------
+	 *	Disable Branch Prediction
+	 *-------------------------------- */
+System_DisableBP:
+	mrc		p15,0,r0,c1,c0,0
+	bic		r0,r0,#R1_BP
+	mcr		p15,0,r0,c1,c0,0
+	bx		lr
+
+	.data
+
+	.end
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/clock.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/clock.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/clock.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/clock.c	2010-05-06 12:42:45.644210217 +0700
@@ -16,17 +16,71 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
+#include <linux/delay.h>
 #include <linux/io.h>
+#include <linux/clk.h>
 
 #include <mach/hardware.h>
 #include <mach/map.h>
 
-#include <plat/regs-sys.h>
 #include <plat/regs-clock.h>
 #include <plat/cpu.h>
 #include <plat/devs.h>
 #include <plat/clock.h>
 
+#include <plat/s3c64xx-dvfs.h>
+
+extern int  s3c6410_changedivider(unsigned int value, unsigned int vaddr);
+
+/* definition for cpu freq */
+
+#define ARM_PLL_CON 	S3C_APLL_CON
+#define ARM_CLK_DIV	S3C_CLK_DIV0
+
+#define ARM_DIV_RATIO_BIT		0
+#define ARM_DIV_MASK			(0xf<<ARM_DIV_RATIO_BIT)
+#define HCLK_DIV_RATIO_BIT		9
+#define HCLK_DIV_MASK			(0x7<<HCLK_DIV_RATIO_BIT)
+#define PCLK_DIV_RATIO_BIT		12
+#define PCLK_DIV_MASK			(0xf<<PCLK_DIV_RATIO_BIT)
+
+#define READ_ARM_DIV    		((__raw_readl(ARM_CLK_DIV)&ARM_DIV_MASK) + 1)
+#define READ_HCLKX2_DIV                    ((__raw_readl(ARM_CLK_DIV)&HCLK_DIV_MASK) + 1)
+#define PLL_CALC_VAL(MDIV,PDIV,SDIV)	((1<<31)|(MDIV)<<16 |(PDIV)<<8 |(SDIV))
+#define GET_ARM_CLOCK(baseclk)		s3c6400_get_pll(__raw_readl(S3C_APLL_CON),baseclk)
+
+#define INIT_XTAL			12 * MHZ
+
+/* ARMCLK, HCLKX2, APLL, PDIV, ARM_DIV, HCLKX2_DIV */
+static const u32 s3c_cpu_clk_tab_533MHz[][6] = {
+	{532*MHZ, 266 *MHZ, 266, 3, 0, 1},
+	{266*MHZ, 266 *MHZ, 266, 3, 1, 1},
+	{133*MHZ, 266 *MHZ, 266, 3, 3, 1},
+#ifdef USE_DVFS_AL1_LEVEL
+	{133*MHZ, 133 *MHZ, 266, 1, 3, 3},
+#endif /* USE_DVFS_AL1_LEVEL */
+	{ 66*MHZ, 133 *MHZ, 266, 1, 7, 3},
+};
+
+/* ARMCLK, HCLKX2, APLL, PDIV, ARM_DIV, HCLKX2_DIV */
+static const u32 s3c_cpu_clk_tab_800MHz[][6] = {
+	{800*MHZ,  266 *MHZ, 400, 3, 0, 2},
+	{400*MHZ,  266 *MHZ, 400, 3, 1, 2},
+	{266*MHZ,  266 *MHZ, 400, 3, 2, 2},
+	{133*MHZ,  266 *MHZ, 400, 3, 5, 2},
+#ifdef USE_DVFS_AL1_LEVEL
+	{133*MHZ,  133 *MHZ, 400, 1, 5, 5},
+#endif /* USE_DVFS_AL1_LEVEL */
+	{ 66*MHZ,  133 *MHZ, 400, 1, 11, 5},
+};
+
+unsigned int S3C64XX_FREQ_TAB = 0;
+
+static const u32 (*s3c_cpu_clk_tab[2])[6] = {
+	s3c_cpu_clk_tab_533MHz,
+	s3c_cpu_clk_tab_800MHz,
+} ;
+
 struct clk clk_27m = {
 	.name		= "clk_27m",
 	.id		= -1,
@@ -41,13 +95,13 @@
 	/* can't rely on clock lock, this register has other usages */
 	local_irq_save(flags);
 
-	val = __raw_readl(S3C64XX_OTHERS);
+	val = __raw_readl(S3C_OTHERS);
 	if (enable)
-		val |= S3C64XX_OTHERS_USBMASK;
+		val |= S3C_OTHERS_USB_SIG_MASK;
 	else
-		val &= ~S3C64XX_OTHERS_USBMASK;
+		val &= ~S3C_OTHERS_USB_SIG_MASK;
 
-	__raw_writel(val, S3C64XX_OTHERS);
+	__raw_writel(val, S3C_OTHERS);
 	local_irq_restore(flags);
 
 	return 0;
@@ -60,6 +114,208 @@
 	.enable		= clk_48m_ctrl,
 };
 
+static u32 s3c_cpu_clk_tab_size(void)
+{
+	u32 size;
+	if(S3C64XX_FREQ_TAB)
+		size = ARRAY_SIZE(s3c_cpu_clk_tab_800MHz);
+	else
+		size = ARRAY_SIZE(s3c_cpu_clk_tab_533MHz);
+
+	return size;
+}
+
+unsigned long s3c64xx_get_clk_rate(int *armclk)
+{
+	u32 hclkx2_div;
+	unsigned long apll_con;
+	unsigned long clk_div0;
+	unsigned long m = 0;
+	unsigned long p = 0;
+	unsigned long s = 0;
+	unsigned long ret;
+
+	apll_con = __raw_readl(S3C_APLL_CON);
+	clk_div0 = __raw_readl(S3C_CLK_DIV0);// & 0xf;
+	hclkx2_div = clk_div0 & (HCLK_DIV_MASK);
+	hclkx2_div = hclkx2_div >> HCLK_DIV_RATIO_BIT;
+	clk_div0 = clk_div0 & 0xf;
+	m = (apll_con >> 16) & 0x3ff;
+	p = (apll_con >> 8) & 0x3f;
+	s = apll_con & 0x3;
+
+	ret = (m * (INIT_XTAL / (p * (1 << s))));
+
+	*armclk = (ret / (clk_div0 + 1));
+
+	ret = ret /(hclkx2_div + 1);
+
+	return ret;
+}
+
+unsigned long s3c_fclk_get_rate(void)
+{
+	unsigned long apll_con;
+	unsigned long clk_div0;
+	unsigned long m = 0;
+	unsigned long p = 0;
+	unsigned long s = 0;
+	unsigned long ret;
+
+	apll_con = __raw_readl(S3C_APLL_CON);
+	clk_div0 = __raw_readl(S3C_CLK_DIV0) & 0xf;
+
+	m = (apll_con >> 16) & 0x3ff;
+	p = (apll_con >> 8) & 0x3f;
+	s = apll_con & 0x3;
+
+	ret = (m * (INIT_XTAL / (p * (1 << s))));
+	return (ret / (clk_div0 + 1));
+}
+
+unsigned long s3c_fclk_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 iter;
+	u32 size;
+	static const u32 (*cpu_clk_tab)[6];
+
+	cpu_clk_tab = s3c_cpu_clk_tab[S3C64XX_FREQ_TAB];
+
+	size = s3c_cpu_clk_tab_size();
+
+	for(iter = 1 ; iter < (size - 2) ; iter++) {
+		if(rate > s3c_cpu_clk_tab[S3C64XX_FREQ_TAB][iter][0])
+			return s3c_cpu_clk_tab[S3C64XX_FREQ_TAB][iter-1][0];
+	}
+
+	return s3c_cpu_clk_tab[S3C64XX_FREQ_TAB][iter - 1][0];
+}
+
+int s3c64xx_clk_set_rate(unsigned int target_freq,
+                                unsigned int index )
+{
+	int cur_freq;
+	int hclkx2_freq;
+	unsigned int mask;
+	u32 clk_div0;
+	u32 size;
+	static const u32 (*cpu_clk_tab)[6];
+
+	cpu_clk_tab = s3c_cpu_clk_tab[S3C64XX_FREQ_TAB];
+
+	size = s3c_cpu_clk_tab_size();
+
+	if(index >= size)	{
+		return 1;
+	}
+
+	/* validate target frequency */ 
+	if(cpu_clk_tab[index][0] != target_freq) {
+		return 0;
+	}
+
+	hclkx2_freq = (int)s3c64xx_get_clk_rate(&cur_freq);
+	hclkx2_freq = hclkx2_freq / MHZ;
+	hclkx2_freq = hclkx2_freq * MHZ;
+
+	/* rounding cpu frequency */
+	cur_freq = cur_freq / MHZ;
+	cur_freq = cur_freq * MHZ;
+
+	/* current frquency is same as target frequency */
+	if((cur_freq == cpu_clk_tab[index][0]) &&
+		(hclkx2_freq == cpu_clk_tab[index][1])) {
+		return 0;
+	}
+
+	mask = (~(HCLK_DIV_MASK)) & (~(ARM_DIV_MASK)) & (~(PCLK_DIV_MASK));
+	clk_div0 = __raw_readl(ARM_CLK_DIV) & mask;
+	clk_div0 |= cpu_clk_tab[index][4];
+	clk_div0 |= (cpu_clk_tab[index][5]) << HCLK_DIV_RATIO_BIT;
+	clk_div0 |= (cpu_clk_tab[index][3]) << PCLK_DIV_RATIO_BIT;
+
+#ifdef CONFIG_CPU_FREQ
+	s3c6410_changedivider(clk_div0, ARM_CLK_DIV);
+#endif	/* CONFIG_CPU_FREQ */
+
+	return 0;
+}
+
+#ifdef CONFIG_CPU_FREQ
+extern int s3c64xx_target_freq_index(unsigned int freq);
+#endif	/* CONFIG_CPU_FREQ */
+
+int s3c_fclk_set_rate(struct clk *clk, unsigned long rate)
+{
+#ifdef CONFIG_CPU_FREQ
+	int index, ret;
+
+	index = s3c64xx_cpufreq_index;
+	ret = s3c64xx_clk_set_rate(rate, index);
+
+	return 0;
+#else		
+	u32 round;
+	u32 iter;
+	u32 size;
+	u32 clk_div0;
+	static const u32 (*cpu_clk_tab)[6];
+	cpu_clk_tab = s3c_cpu_clk_tab[S3C64XX_FREQ_TAB];
+
+	round = s3c_fclk_round_rate(clk,rate);
+
+	size = s3c_cpu_clk_tab_size();
+
+	if(round == (int)s3c_fclk_get_rate())
+		return 0;
+
+	for (iter = 0 ; iter < (size - 2) ; iter++) {
+		if(round == cpu_clk_tab[iter][0])
+			break;
+	}
+
+	clk_div0 = __raw_readl(ARM_CLK_DIV) & ~(ARM_DIV_MASK);
+	clk_div0 |= cpu_clk_tab[iter][4];
+
+	__raw_writel(clk_div0, ARM_CLK_DIV);
+
+	clk->rate = cpu_clk_tab[iter][0];
+	return 0;	
+#endif	/* CONFIG_CPU_FREQ */
+}
+
+static int s3c64xx_setrate_sclk_cam(struct clk *clk, unsigned long rate)
+{
+	u32 shift = 20;
+	u32 cam_div, cfg;
+	unsigned long src_clk = clk_get_rate(clk->parent);
+
+	cam_div = src_clk / rate;
+
+	if (cam_div > 32)
+		cam_div = 32;
+
+	cfg = __raw_readl(S3C_CLK_DIV0);
+	cfg &= ~(0xf << shift);
+	cfg |= ((cam_div - 1) << shift);
+	__raw_writel(cfg, S3C_CLK_DIV0);
+
+	printk("parent clock for camera: %ld.%03ld MHz, divisor: %d\n", \
+			print_mhz(src_clk), cam_div);
+
+	return 0;
+}
+
+struct clk clk_cpu = {
+	.name		= "clk_cpu",
+	.id		= -1,
+	.rate		= 0,
+	.parent		= &clk_f,
+	.ctrlbit	= 0,
+	.set_rate	= s3c_fclk_set_rate,
+	.round_rate	= s3c_fclk_round_rate,
+};
+
 static int inline s3c64xx_gate(void __iomem *reg,
 				struct clk *clk,
 				int enable)
@@ -105,6 +361,12 @@
 		.enable		= s3c64xx_pclk_ctrl,
 		.ctrlbit	= S3C_CLKCON_PCLK_TSADC,
 	}, {
+		.name		= "keypad",
+		.id		= -1,
+		.parent		= &clk_p,
+		.enable		= s3c64xx_pclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_PCLK_KEYPAD,
+	}, {
 		.name		= "i2c",
 		.id		= -1,
 		.parent		= &clk_p,
@@ -112,7 +374,7 @@
 		.ctrlbit	= S3C_CLKCON_PCLK_IIC,
 	}, {
 		.name		= "iis",
-		.id		= 0,
+		.id		= -1,
 		.parent		= &clk_p,
 		.enable		= s3c64xx_pclk_ctrl,
 		.ctrlbit	= S3C_CLKCON_PCLK_IIS0,
@@ -159,9 +421,9 @@
 	{
 		.name		= "lcd",
 		.id		= -1,
-		.parent		= &clk_h,
-		.enable		= s3c64xx_hclk_ctrl,
-		.ctrlbit	= S3C_CLKCON_HCLK_LCD,
+		.parent		= &clk_dout_mpll,
+		.enable		= s3c64xx_sclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_SCLK_LCD,
 	}, {
 		.name		= "gpio",
 		.id		= -1,
@@ -175,6 +437,12 @@
 		.enable		= s3c64xx_hclk_ctrl,
 		.ctrlbit	= S3C_CLKCON_SCLK_UHOST,
 	}, {
+		.name		= "otg",
+		.id		= -1,
+		.parent		= &clk_h,
+		.enable		= s3c64xx_hclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_HCLK_USB,
+	}, {
 		.name		= "hsmmc",
 		.id		= 0,
 		.parent		= &clk_h,
@@ -193,6 +461,48 @@
 		.enable		= s3c64xx_hclk_ctrl,
 		.ctrlbit	= S3C_CLKCON_HCLK_HSMMC2,
 	}, {
+		.name    	= "post0",
+		.id		= -1,
+		.parent  	= &clk_h,
+		.enable  	= s3c64xx_hclk_ctrl,
+		.ctrlbit 	= S3C_CLKCON_HCLK_POST0
+	},{
+		.name    	= "hclk_camera",
+		.id	   	= -1,
+		.parent  	= &clk_h,
+		.enable  	= s3c64xx_hclk_ctrl,
+	  	.ctrlbit 	= S3C_CLKCON_HCLK_CAMIF
+	},{ 
+		.name    	= "hclk_g2d",
+		.id	   	= -1,
+		.parent  	= &clk_h,
+		.enable  	= s3c64xx_hclk_ctrl,
+	 	.ctrlbit 	= S3C_CLKCON_HCLK_2D
+	},{
+		.name		= "hclk_g3d",
+		.id		= -1,
+		.parent		= &clk_h,
+		.enable		= s3c64xx_hclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_HCLK_3DSE
+	},{
+		.name		= "hclk_rot",
+		.id		= -1,
+		.parent		= &clk_h,
+		.enable		= s3c64xx_hclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_HCLK_ROT
+	},{
+		.name   	= "tv_encoder",
+		.id	   	= -1,
+		.parent  	= &clk_h,
+		.enable  	= s3c64xx_hclk_ctrl,
+		.ctrlbit 	= S3C_CLKCON_HCLK_TV
+	},{ 
+		.name    	= "tv_scaler",
+		.id	   	= -1,
+		.parent  	= &clk_dout_mpll,
+		.enable  	= s3c64xx_sclk_ctrl,
+		.ctrlbit 	= S3C_CLKCON_SCLK_SCALER
+	},{
 		.name		= "timers",
 		.id		= -1,
 		.parent		= &clk_p,
@@ -238,7 +548,53 @@
 		.id		= -1,
 		.parent		= &clk_p,
 		.ctrlbit	= S3C_CLKCON_PCLK_AC97,
-	}
+	},{ 
+		.name    	= "hclk_mfc",
+		.id		= -1,
+		.parent  	= &clk_h,
+		.enable  	= s3c64xx_hclk_ctrl,
+		.ctrlbit 	= S3C_CLKCON_HCLK_MFC,
+	},{
+		.name    	= "sclk_mfc",
+		.id	   	= -1,
+          	.parent		= &clk_hx2,
+		.enable  	= s3c64xx_sclk_ctrl,
+		.ctrlbit 	= S3C_CLKCON_SCLK_MFC,
+		.usage   	= 0,
+		.rate    	= 48*1000*1000,
+	},{ 
+		.name     	= "pclk_mfc",
+		.id       	= -1,
+		.parent   	= &clk_p,
+		.enable   	= s3c64xx_pclk_ctrl,
+		.ctrlbit  	= S3C_CLKCON_PCLK_MFC,
+	}, { 
+		.name		= "hclk_jpeg",
+          	.id		= -1,
+          	.parent		= &clk_h,
+          	.enable		= s3c64xx_hclk_ctrl,
+          	.ctrlbit	= S3C_CLKCON_HCLK_JPEG,
+        }, { 
+		.name		= "sclk_jpeg",
+          	.id		= -1,
+          	.parent		= &clk_hx2,
+          	.enable		= s3c64xx_sclk_ctrl,
+          	.ctrlbit	= S3C_CLKCON_SCLK_JPEG,
+          	.usage		= 0,
+          	.rate		= 48*1000*1000,
+	},{
+		.name		= "fimc",
+		.id		= -1,
+		.parent		= &clk_h,
+		.ctrlbit	= S3C_CLKCON_HCLK_CAMIF,
+	}, {
+		.name		= "sclk_cam",
+		.id		= -1,
+		.parent		= &clk_hx2,
+		.enable		= s3c64xx_sclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_SCLK_CAM,
+		.set_rate	= s3c64xx_setrate_sclk_cam,
+	},
 };
 
 static struct clk *clks[] __initdata = {
@@ -246,6 +602,7 @@
 	&clk_epll,
 	&clk_27m,
 	&clk_48m,
+	&clk_cpu,
 };
 
 void __init s3c64xx_register_clocks(void)
@@ -254,11 +611,11 @@
 	int ret;
 	int ptr;
 
-	s3c24xx_register_clocks(clks, ARRAY_SIZE(clks));
+	s3c_register_clocks(clks, ARRAY_SIZE(clks));
 
 	clkp = init_clocks;
 	for (ptr = 0; ptr < ARRAY_SIZE(init_clocks); ptr++, clkp++) {
-		ret = s3c24xx_register_clock(clkp);
+		ret = s3c_register_clock(clkp);
 		if (ret < 0) {
 			printk(KERN_ERR "Failed to register clock %s (%d)\n",
 			       clkp->name, ret);
@@ -268,7 +625,7 @@
 	clkp = init_clocks_disable;
 	for (ptr = 0; ptr < ARRAY_SIZE(init_clocks_disable); ptr++, clkp++) {
 
-		ret = s3c24xx_register_clock(clkp);
+		ret = s3c_register_clock(clkp);
 		if (ret < 0) {
 			printk(KERN_ERR "Failed to register clock %s (%d)\n",
 			       clkp->name, ret);
@@ -276,6 +633,4 @@
 
 		(clkp->enable)(clkp, 0);
 	}
-
-	s3c_pwmclk_init();
 }
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/cpu.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/cpu.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/cpu.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/cpu.c	2010-05-06 12:42:45.644210217 +0700
@@ -18,6 +18,7 @@
 #include <linux/ioport.h>
 #include <linux/serial_core.h>
 #include <linux/platform_device.h>
+#include <linux/delay.h>
 #include <linux/io.h>
 
 #include <mach/hardware.h>
@@ -27,6 +28,7 @@
 #include <asm/mach/map.h>
 
 #include <plat/regs-serial.h>
+#include <plat/regs-clock.h>
 
 #include <plat/cpu.h>
 #include <plat/devs.h>
@@ -109,6 +111,6 @@
 	iotable_init(s3c_iodesc, ARRAY_SIZE(s3c_iodesc));
 	iotable_init(mach_desc, size);
 
-	idcode = __raw_readl(S3C_VA_SYS + 0x118);
+	idcode = __raw_readl(S3C_SYS_ID);
 	s3c_init_cpu(idcode, cpu_ids, ARRAY_SIZE(cpu_ids));
 }
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/devs.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/devs.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/devs.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/devs.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,781 @@
+/* linux/arch/arm/plat-s3c64xx/devs.c
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * Base S3C64XX resource and device definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <mach/hardware.h>
+#include <mach/map.h>
+
+#include <plat/regs-spi.h>
+#include <plat/devs.h>
+#include <plat/adc.h>
+#include <plat/adcts.h>
+#include <linux/android_pmem.h>
+#include <plat/reserved_mem.h>
+
+#if defined(CONFIG_S3C_DMA_PL080_SOL)
+/* DMA-PL080 DMA Controller */
+/* DMAC0 */
+static struct resource s3c_dma0_resources[] = {
+      [0] = {
+              .start  = S3C64XX_PA_DMA0,
+              .end    = S3C64XX_PA_DMA0 + S3C64XX_SZ_DMA - 1,
+              .flags  = IORESOURCE_MEM,
+      },
+      [1] = {
+              .start = IRQ_DMA0,
+              .end   = IRQ_DMA0,
+              .flags = IORESOURCE_IRQ,
+        },
+};
+
+struct platform_device s3c_device_dma0 = {
+      .name           = "s3c-dmac",
+      .id             =  0,
+      .num_resources  = ARRAY_SIZE(s3c_dma0_resources),
+      .resource       = s3c_dma0_resources,
+	  .dev			  = {
+	  		.coherent_dma_mask = ~0,
+	  },
+};
+EXPORT_SYMBOL(s3c_device_dma0);
+
+/* DMAC1 */
+static struct resource s3c_dma1_resources[] = {
+      [0] = {
+              .start  = S3C64XX_PA_DMA1,
+              .end    = S3C64XX_PA_DMA1 + S3C64XX_SZ_DMA - 1,
+              .flags  = IORESOURCE_MEM,
+      },
+      [1] = {
+              .start = IRQ_DMA1,
+              .end   = IRQ_DMA1,
+              .flags = IORESOURCE_IRQ,
+        },
+};
+
+struct platform_device s3c_device_dma1 = {
+      .name           = "s3c-dmac",
+      .id             =  1,
+      .num_resources  = ARRAY_SIZE(s3c_dma1_resources),
+      .resource       = s3c_dma1_resources,
+};
+EXPORT_SYMBOL(s3c_device_dma1);
+
+/* DMAC2 */
+static struct resource s3c_dma2_resources[] = {
+      [0] = {
+              .start  = S3C64XX_PA_DMA2,
+              .end    = S3C64XX_PA_DMA2 + S3C64XX_SZ_DMA - 1,
+              .flags  = IORESOURCE_MEM,
+      },
+      [1] = {
+              .start = IRQ_SDMA0,
+              .end   = IRQ_SDMA0,
+              .flags = IORESOURCE_IRQ,
+        },
+};
+
+struct platform_device s3c_device_dma2 = {
+      .name           = "s3c-dmac",
+      .id             =  2,
+      .num_resources  = ARRAY_SIZE(s3c_dma2_resources),
+      .resource       = s3c_dma2_resources,
+};
+EXPORT_SYMBOL(s3c_device_dma2);
+
+/* DMAC3 */
+static struct resource s3c_dma3_resources[] = {
+      [0] = {
+              .start  = S3C64XX_PA_DMA3,
+              .end    = S3C64XX_PA_DMA3 + S3C64XX_SZ_DMA - 1,
+              .flags  = IORESOURCE_MEM,
+      },
+      [1] = {
+              .start = IRQ_SDMA1,
+              .end   = IRQ_SDMA1,
+              .flags = IORESOURCE_IRQ,
+        },
+};
+
+struct platform_device s3c_device_dma3 = {
+      .name           = "s3c-dmac",
+      .id             =  3,
+      .num_resources  = ARRAY_SIZE(s3c_dma3_resources),
+      .resource       = s3c_dma3_resources,
+};
+EXPORT_SYMBOL(s3c_device_dma3);
+#endif
+
+/* SMC9115 LAN via ROM interface */
+
+static struct resource s3c_smc911x_resources[] = {
+	[0] = {
+		.start  = S3C64XX_PA_SMC9115,
+		.end    = S3C64XX_PA_SMC9115 + S3C64XX_SZ_SMC9115 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_EINT(10),
+		.end   = IRQ_EINT(10),
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device s3c_device_smc911x = {
+	.name           = "smc911x",
+	.id             =  -1,
+	.num_resources  = ARRAY_SIZE(s3c_smc911x_resources),
+	.resource       = s3c_smc911x_resources,
+};
+
+/* NAND Controller */
+
+static struct resource s3c_nand_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_NAND,
+		.end   = S3C64XX_PA_NAND + S3C64XX_SZ_NAND - 1,
+		.flags = IORESOURCE_MEM,
+	}
+};
+
+struct platform_device s3c_device_nand = {
+	.name		= "s3c-nand",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(s3c_nand_resource),
+	.resource	= s3c_nand_resource,
+};
+
+EXPORT_SYMBOL(s3c_device_nand);
+
+/* USB Device (Gadget)*/
+
+static struct resource s3c_usbgadget_resource[] = {
+	[0] = {
+		.start = S3C_PA_OTG,
+		.end   = S3C_PA_OTG+S3C_SZ_OTG - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_OTG,
+		.end   = IRQ_OTG,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_usbgadget = {
+	.name		  = "s3c6410-usbgadget",
+	.id		  = -1,
+	.num_resources	  = ARRAY_SIZE(s3c_usbgadget_resource),
+	.resource	  = s3c_usbgadget_resource,
+};
+
+EXPORT_SYMBOL(s3c_device_usbgadget);
+
+static struct resource s3c_rtc_resource[] = {
+	[0] = {
+		.start = S3C_PA_RTC,
+		.end   = S3C_PA_RTC + 0xff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_RTC_ALARM,
+		.end   = IRQ_RTC_ALARM,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = IRQ_RTC_TIC,
+		.end   = IRQ_RTC_TIC,
+		.flags = IORESOURCE_IRQ
+	}
+};
+
+struct platform_device s3c_device_rtc = {
+	.name		  = "s3c-rtc",
+	.id		  = -1,
+	.num_resources	  = ARRAY_SIZE(s3c_rtc_resource),
+	.resource	  = s3c_rtc_resource,
+};
+
+EXPORT_SYMBOL(s3c_device_rtc);
+/* LCD Controller */
+
+static struct resource s3c_lcd_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_LCD,
+		.end   = S3C64XX_PA_LCD + SZ_1M - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LCD_VSYNC,
+		.end   = IRQ_LCD_SYSTEM,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static u64 s3c_device_lcd_dmamask = 0xffffffffUL;
+
+struct platform_device s3c_device_lcd = {
+	.name		  = "s3c-lcd",
+	.id		  = -1,
+	.num_resources	  = ARRAY_SIZE(s3c_lcd_resource),
+	.resource	  = s3c_lcd_resource,
+	.dev              = {
+		.dma_mask		= &s3c_device_lcd_dmamask,
+		.coherent_dma_mask	= 0xffffffffUL
+	}
+};
+
+#ifdef CONFIG_S3C64XX_ADCTS
+/* ADCTS */
+static struct resource s3c_adcts_resource[] = {
+	[0] = {
+		.start = S3C_PA_ADC,
+		.end   = S3C_PA_ADC + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_PENDN,
+		.end   = IRQ_PENDN,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = IRQ_ADC,
+		.end   = IRQ_ADC,
+		.flags = IORESOURCE_IRQ,
+	}
+
+};
+
+struct platform_device s3c_device_adcts = {
+	.name		  = "s3c-adcts",
+	.id		  = -1,
+	.num_resources	  = ARRAY_SIZE(s3c_adcts_resource),
+	.resource	  = s3c_adcts_resource,
+};
+
+void __init s3c_adcts_set_platdata(struct s3c_adcts_plat_info *pd)
+{
+	struct s3c_adcts_plat_info *npd;
+
+	npd = kmalloc(sizeof(*npd), GFP_KERNEL);
+	if (npd) {
+		memcpy(npd, pd, sizeof(*npd));
+		s3c_device_adcts.dev.platform_data = npd;
+	} else {
+		printk(KERN_ERR "no memory for ADC platform data\n");
+	}
+}
+EXPORT_SYMBOL(s3c_device_adcts);
+
+#else
+
+/* ADC : Old ADC driver */
+static struct resource s3c_adc_resource[] = {
+	[0] = {
+		.start = S3C_PA_ADC,
+		.end   = S3C_PA_ADC + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_PENDN,
+		.end   = IRQ_PENDN,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = IRQ_ADC,
+		.end   = IRQ_ADC,
+		.flags = IORESOURCE_IRQ,
+	}
+
+};
+
+struct platform_device s3c_device_adc = {
+	.name		  = "s3c-adc",
+	.id		  = -1,
+	.num_resources	  = ARRAY_SIZE(s3c_adc_resource),
+	.resource	  = s3c_adc_resource,
+};
+
+void __init s3c_adc_set_platdata(struct s3c_adc_mach_info *pd)
+{
+	struct s3c_adc_mach_info *npd;
+
+	npd = kmalloc(sizeof(*npd), GFP_KERNEL);
+	if (npd) {
+		memcpy(npd, pd, sizeof(*npd));
+		s3c_device_adc.dev.platform_data = npd;
+	} else {
+		printk(KERN_ERR "no memory for ADC platform data\n");
+	}
+}
+EXPORT_SYMBOL(s3c_device_adc);
+
+#endif
+
+/* Keypad interface */
+static struct resource s3c_keypad_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_KEYPAD,
+		.end   = S3C64XX_PA_KEYPAD+ S3C64XX_SZ_KEYPAD - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_KEYPAD,
+		.end   = IRQ_KEYPAD,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_keypad = {
+	.name		= "s3c-keypad",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(s3c_keypad_resource),
+	.resource	= s3c_keypad_resource,
+};
+EXPORT_SYMBOL(s3c_device_keypad);
+
+/* 2D interface */
+static struct resource s3c_2d_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_G2D,
+		.end   = S3C64XX_PA_G2D + S3C64XX_SZ_G2D - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_2D,
+		.end   = IRQ_2D,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_2d = {
+        .name             = "s3c-g2d",
+        .id               = -1,
+        .num_resources    = ARRAY_SIZE(s3c_2d_resource),
+        .resource         = s3c_2d_resource
+};
+
+EXPORT_SYMBOL(s3c_device_2d);
+
+/* rotator interface */
+static struct resource s3c_rotator_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_ROTATOR,
+		.end   = S3C64XX_PA_ROTATOR + S3C_SZ_ROTATOR - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_ROTATOR,
+		.end   = IRQ_ROTATOR,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_rotator = {
+	.name             = "s3c-rotator",
+	.id               = -1,
+	.num_resources    = ARRAY_SIZE(s3c_rotator_resource),
+	.resource         = s3c_rotator_resource
+};
+
+EXPORT_SYMBOL(s3c_device_rotator);
+
+/* TV encoder */
+static struct resource s3c_tvenc_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_TVENC,
+		.end   = S3C64XX_PA_TVENC + S3C_SZ_TVENC - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_TVENC,
+		.end   = IRQ_TVENC,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_tvenc = {
+	.name		= "s3c-tvenc",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(s3c_tvenc_resource),
+	.resource	= s3c_tvenc_resource,
+};
+
+EXPORT_SYMBOL(s3c_device_tvenc);
+
+/* board infomation for Hall mouse */
+static struct spi_board_info s3c6410_spi_board_info[] = {
+	{
+		.modalias       = "hm_spi",
+		.bus_num        = 0,
+		.chip_select    = 0,
+		.max_speed_hz   = 2000000,
+		.irq            = IRQ_EINT(17),
+		.mode           = SPI_MODE_1 | SPI_LSB_FIRST,
+	},
+};
+
+struct s3c6410_spi_info spi_plat_data = {
+	.board_info = s3c6410_spi_board_info,
+	.board_size = ARRAY_SIZE(s3c6410_spi_board_info),
+};
+
+/* SPI (0) */
+static struct resource s3c_spi0_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_SPI0,
+		.end   = S3C64XX_PA_SPI0 + S3C64XX_SZ_SPI - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_SPI0,
+		.end   = IRQ_SPI0,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static u64 s3c_device_spi0_dmamask = 0xffffffffUL;
+
+struct platform_device s3c_device_spi0 = {
+	.name		= "s3c-spi",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(s3c_spi0_resource),
+	.resource	= s3c_spi0_resource,
+	.dev = {
+		.dma_mask = &s3c_device_spi0_dmamask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data     = &spi_plat_data,
+	}
+};
+EXPORT_SYMBOL(s3c_device_spi0);
+
+/* TV scaler */
+static struct resource s3c_tvscaler_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_TVSCALER,
+		.end   = S3C64XX_PA_TVSCALER + S3C_SZ_TVSCALER - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_SCALER,
+		.end   = IRQ_SCALER,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_tvscaler = {
+	.name		= "s3c-tvscaler",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(s3c_tvscaler_resource),
+	.resource	= s3c_tvscaler_resource,
+};
+EXPORT_SYMBOL(s3c_device_tvscaler);
+
+/* JPEG controller */
+static struct resource s3c_jpeg_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_JPEG,
+		.end   = S3C64XX_PA_JPEG + S3C_SZ_JPEG - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_JPEG,
+		.end   = IRQ_JPEG,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_jpeg = {
+	.name		= "s3c-jpeg",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(s3c_jpeg_resource),
+	.resource	= s3c_jpeg_resource,
+};
+
+EXPORT_SYMBOL(s3c_device_jpeg);
+
+/* MFC controller */
+static struct resource s3c_mfc_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_MFC,
+		.end   = S3C64XX_PA_MFC + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_MFC,
+		.end   = IRQ_MFC,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_mfc = {
+	.name             = "s3c-mfc",
+	.id               = -1,
+	.num_resources    = ARRAY_SIZE(s3c_mfc_resource),
+	.resource         = s3c_mfc_resource
+};
+
+EXPORT_SYMBOL(s3c_device_mfc);
+
+/* VPP controller */
+static struct resource s3c_vpp_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_VPP,
+		.end   = S3C64XX_PA_VPP + S3C_SZ_VPP - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_POST0,
+		.end   = IRQ_POST0,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_vpp = {
+	.name		= "s3c-vpp",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(s3c_vpp_resource),
+	.resource	= s3c_vpp_resource,
+};
+
+EXPORT_SYMBOL(s3c_device_vpp);
+
+/* 3D interface */
+static struct resource s3c_g3d_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_G3D,
+		.end   = S3C64XX_PA_G3D + S3C64XX_SZ_G3D - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_S3C6410_G3D,
+		.end   = IRQ_S3C6410_G3D,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_g3d = {
+	.name             = "s3c-g3d",
+	.id               = -1,
+	.num_resources    = ARRAY_SIZE(s3c_g3d_resource),
+	.resource         = s3c_g3d_resource
+};
+
+EXPORT_SYMBOL(s3c_device_g3d);
+
+
+/* Camif controller */
+
+static struct resource s3c_camif_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_FIMC,
+		.end   = S3C64XX_PA_FIMC + S3C64XX_SZ_FIMC - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_CAMIF_C,
+		.end   = IRQ_CAMIF_C,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = IRQ_CAMIF_P,
+		.end   = IRQ_CAMIF_P,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_camif = {
+	.name		= "s3c-camif",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(s3c_camif_resource),
+	.resource	= s3c_camif_resource,
+};
+
+EXPORT_SYMBOL(s3c_device_camif);
+
+static struct android_pmem_platform_data pmem_pdata = {
+	.name		= "pmem",
+	.no_allocator	= 1,
+	.cached		= 1,
+	.buffered	= 1,	//09.12.01 hoony: surfaceflinger optimize
+};
+ 
+static struct android_pmem_platform_data pmem_gpu1_pdata = {
+	.name		= "pmem_gpu1",
+	.no_allocator	= 1,
+	.cached		= 1,
+	.buffered	= 1,
+};
+
+static struct android_pmem_platform_data pmem_render_pdata = {
+	.name		= "pmem_render",
+	.no_allocator	= 1,
+	.cached		= 0,
+};
+
+static struct android_pmem_platform_data pmem_stream_pdata = {
+	.name		= "pmem_stream",
+	.no_allocator	= 1,
+	.cached		= 0,
+};
+
+static struct android_pmem_platform_data pmem_stream2_pdata = {
+	.name		= "pmem_stream2",
+	.no_allocator	= 1,
+	.cached		= 0,
+};
+
+static struct android_pmem_platform_data pmem_preview_pdata = {
+	.name		= "pmem_preview",
+	.no_allocator	= 1,
+	.cached		= 0,
+};
+
+static struct android_pmem_platform_data pmem_picture_pdata = {
+	.name		= "pmem_picture",
+	.no_allocator	= 1,
+	.cached		= 0,
+};
+
+static struct android_pmem_platform_data pmem_jpeg_pdata = {
+	.name		= "pmem_jpeg",
+	.no_allocator	= 1,
+	.cached		= 0,
+};
+
+static struct android_pmem_platform_data pmem_skia_pdata = {
+	.name		= "pmem_skia",
+	.no_allocator	= 1,
+	.cached		= 0,
+};
+ 
+static struct platform_device pmem_device = {
+	.name		= "android_pmem",
+	.id		= 0,
+	.dev		= { .platform_data = &pmem_pdata },
+};
+ 
+static struct platform_device pmem_gpu1_device = {
+	.name		= "android_pmem",
+	.id		= 1,
+	.dev		= { .platform_data = &pmem_gpu1_pdata },
+};
+
+static struct platform_device pmem_render_device = {
+	.name		= "android_pmem",
+	.id		= 2,
+	.dev		= { .platform_data = &pmem_render_pdata },
+};
+
+static struct platform_device pmem_stream_device = {
+	.name		= "android_pmem",
+	.id		= 3,
+	.dev		= { .platform_data = &pmem_stream_pdata },
+};
+
+static struct platform_device pmem_stream2_device = {
+	.name		= "android_pmem",
+	.id		= 4,
+	.dev		= { .platform_data = &pmem_stream2_pdata },
+};
+
+static struct platform_device pmem_preview_device = {
+	.name		= "android_pmem",
+	.id		= 5,
+	.dev		= { .platform_data = &pmem_preview_pdata },
+};
+
+static struct platform_device pmem_picture_device = {
+	.name		= "android_pmem",
+	.id		= 6,
+	.dev		= { .platform_data = &pmem_picture_pdata },
+};
+
+static struct platform_device pmem_jpeg_device = {
+	.name		= "android_pmem",
+	.id		= 7,
+	.dev		= { .platform_data = &pmem_jpeg_pdata },
+};
+
+static struct platform_device pmem_skia_device = {
+	.name		= "android_pmem",
+	.id		= 8,
+	.dev		= { .platform_data = &pmem_skia_pdata },
+};
+
+void __init s3c6410_add_mem_devices(struct s3c6410_pmem_setting *setting)
+{
+	if (setting->pmem_size) {
+		pmem_pdata.start = setting->pmem_start;
+		pmem_pdata.size = setting->pmem_size;
+		platform_device_register(&pmem_device);
+	}
+
+	if (setting->pmem_gpu1_size) {
+		pmem_gpu1_pdata.start = setting->pmem_gpu1_start;
+		pmem_gpu1_pdata.size = setting->pmem_gpu1_size;
+		platform_device_register(&pmem_gpu1_device);
+	}
+ 
+	if (setting->pmem_render_size) {
+		pmem_render_pdata.start = setting->pmem_render_start;
+		pmem_render_pdata.size = setting->pmem_render_size;
+		platform_device_register(&pmem_render_device);
+	}
+
+	if (setting->pmem_stream_size) {
+		pmem_stream_pdata.start = setting->pmem_stream_start;
+	        pmem_stream_pdata.size = setting->pmem_stream_size;
+	        platform_device_register(&pmem_stream_device);
+	}
+
+	if (setting->pmem_stream_size) {
+		pmem_stream2_pdata.start = setting->pmem_stream_start;
+		pmem_stream2_pdata.size = setting->pmem_stream_size;
+		platform_device_register(&pmem_stream2_device);
+	}
+
+	if (setting->pmem_preview_size) {
+		pmem_preview_pdata.start = setting->pmem_preview_start;
+		pmem_preview_pdata.size = setting->pmem_preview_size;
+		platform_device_register(&pmem_preview_device);
+	}
+
+	if (setting->pmem_picture_size) {
+		pmem_picture_pdata.start = setting->pmem_picture_start;
+		pmem_picture_pdata.size = setting->pmem_picture_size;
+		platform_device_register(&pmem_picture_device);
+	}
+
+	if (setting->pmem_jpeg_size) {
+		pmem_jpeg_pdata.start = setting->pmem_jpeg_start;
+		pmem_jpeg_pdata.size = setting->pmem_jpeg_size;
+		platform_device_register(&pmem_jpeg_device);
+	}
+
+	if (setting->pmem_skia_size) {
+		pmem_skia_pdata.start = setting->pmem_skia_start;
+		pmem_skia_pdata.size = setting->pmem_skia_size;
+		platform_device_register(&pmem_skia_device);
+	}
+}
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/dev-uart.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/dev-uart.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/dev-uart.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/dev-uart.c	2010-05-06 12:42:45.634864134 +0700
@@ -33,7 +33,7 @@
 static struct resource s3c64xx_uart0_resource[] = {
 	[0] = {
 		.start	= S3C_PA_UART0,
-		.end	= S3C_PA_UART0 + 0x100,
+		.end	= S3C_PA_UART0 + S3C_SZ_UART,
 		.flags	= IORESOURCE_MEM,
 	},
 	[1] = {
@@ -57,7 +57,7 @@
 static struct resource s3c64xx_uart1_resource[] = {
 	[0] = {
 		.start = S3C_PA_UART1,
-		.end   = S3C_PA_UART1 + 0x100,
+		.end   = S3C_PA_UART1 + S3C_SZ_UART,
 		.flags = IORESOURCE_MEM,
 	},
 	[1] = {
@@ -81,7 +81,7 @@
 static struct resource s3c6xx_uart2_resource[] = {
 	[0] = {
 		.start = S3C_PA_UART2,
-		.end   = S3C_PA_UART2 + 0x100,
+		.end   = S3C_PA_UART2 + S3C_SZ_UART,
 		.flags = IORESOURCE_MEM,
 	},
 	[1] = {
@@ -105,7 +105,7 @@
 static struct resource s3c64xx_uart3_resource[] = {
 	[0] = {
 		.start = S3C_PA_UART3,
-		.end   = S3C_PA_UART3 + 0x100,
+		.end   = S3C_PA_UART3 + S3C_SZ_UART,
 		.flags = IORESOURCE_MEM,
 	},
 	[1] = {
@@ -127,7 +127,7 @@
 };
 
 
-struct s3c24xx_uart_resources s3c64xx_uart_resources[] __initdata = {
+struct s3c_uart_resources s3c64xx_uart_resources[] __initdata = {
 	[0] = {
 		.resources	= s3c64xx_uart0_resource,
 		.nr_resources	= ARRAY_SIZE(s3c64xx_uart0_resource),
@@ -148,29 +148,29 @@
 
 /* uart devices */
 
-static struct platform_device s3c24xx_uart_device0 = {
+static struct platform_device s3c_uart_device0 = {
 	.id		= 0,
 };
 
-static struct platform_device s3c24xx_uart_device1 = {
+static struct platform_device s3c_uart_device1 = {
 	.id		= 1,
 };
 
-static struct platform_device s3c24xx_uart_device2 = {
+static struct platform_device s3c_uart_device2 = {
 	.id		= 2,
 };
 
-static struct platform_device s3c24xx_uart_device3 = {
+static struct platform_device s3c_uart_device3 = {
 	.id		= 3,
 };
 
-struct platform_device *s3c24xx_uart_src[4] = {
-	&s3c24xx_uart_device0,
-	&s3c24xx_uart_device1,
-	&s3c24xx_uart_device2,
-	&s3c24xx_uart_device3,
+struct platform_device *s3c_uart_src[4] = {
+	&s3c_uart_device0,
+	&s3c_uart_device1,
+	&s3c_uart_device2,
+	&s3c_uart_device3,
 };
 
-struct platform_device *s3c24xx_uart_devs[4] = {
+struct platform_device *s3c_uart_devs[4] = {
 };
 
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/gpiolib.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/gpiolib.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/gpiolib.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/gpiolib.c	2010-05-06 12:42:45.644210217 +0700
@@ -13,6 +13,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/irq.h>
 #include <linux/io.h>
 
@@ -49,6 +50,11 @@
  * [2] BANK has two control registers, GPxCON0 and GPxCON1
  */
 
+/*
+ *  <YAMAIA><drkim> - 2009.09.21
+ *  local_irq_save() and local_irq_restore() adds in each function
+ */
+
 #define OFF_GPCON	(0x00)
 #define OFF_GPDAT	(0x04)
 
@@ -60,6 +66,7 @@
 #define gpio_dbg(x...) printk(KERN_DEBUG ## x)
 #endif
 
+
 /* The s3c64xx_gpiolib_4bit routines are to control the gpio banks where
  * the gpio configuration register (GPxCON) has 4 bits per GPIO, as the
  * following example:
@@ -80,11 +87,16 @@
 	struct s3c_gpio_chip *ourchip = to_s3c_gpio(chip);
 	void __iomem *base = ourchip->base;
 	unsigned long con;
+	unsigned long flags;
+
+	local_irq_save(flags);
 
 	con = __raw_readl(base + OFF_GPCON);
 	con &= ~(0xf << con_4bit_shift(offset));
 	__raw_writel(con, base + OFF_GPCON);
 
+	local_irq_restore(flags);
+
 	gpio_dbg("%s: %p: CON now %08lx\n", __func__, base, con);
 
 	return 0;
@@ -97,6 +109,9 @@
 	void __iomem *base = ourchip->base;
 	unsigned long con;
 	unsigned long dat;
+	unsigned long flags;
+	
+	local_irq_save(flags);
 
 	con = __raw_readl(base + OFF_GPCON);
 	con &= ~(0xf << con_4bit_shift(offset));
@@ -112,6 +127,8 @@
 	__raw_writel(con, base + OFF_GPCON);
 	__raw_writel(dat, base + OFF_GPDAT);
 
+	local_irq_restore(flags);	
+
 	gpio_dbg("%s: %p: CON %08lx, DAT %08lx\n", __func__, base, con, dat);
 
 	return 0;
@@ -144,7 +161,10 @@
 	void __iomem *base = ourchip->base;
 	void __iomem *regcon = base;
 	unsigned long con;
-
+	unsigned long flags;
+	
+	local_irq_save(flags);
+	
 	if (offset > 7)
 		offset -= 8;
 	else
@@ -154,6 +174,8 @@
 	con &= ~(0xf << con_4bit_shift(offset));
 	__raw_writel(con, regcon);
 
+	local_irq_restore(flags);		
+
 	gpio_dbg("%s: %p: CON %08lx\n", __func__, base, con);
 
 	return 0;
@@ -168,15 +190,19 @@
 	void __iomem *regcon = base;
 	unsigned long con;
 	unsigned long dat;
+	unsigned con_offset = offset;
+	unsigned long flags;
+	
+	local_irq_save(flags);	
 
 	if (offset > 7)
-		offset -= 8;
+		con_offset = offset - 8;
 	else
 		regcon -= 4;
 
 	con = __raw_readl(regcon);
-	con &= ~(0xf << con_4bit_shift(offset));
-	con |= 0x1 << con_4bit_shift(offset);
+	con &= ~(0xf << con_4bit_shift(con_offset));
+	con |= 0x1 << con_4bit_shift(con_offset);
 
 	dat = __raw_readl(base + OFF_GPDAT);
 	if (value)
@@ -187,6 +213,8 @@
 	__raw_writel(dat, base + OFF_GPDAT);
 	__raw_writel(con, regcon);
 	__raw_writel(dat, base + OFF_GPDAT);
+	
+	local_irq_restore(flags);		
 
 	gpio_dbg("%s: %p: CON %08lx, DAT %08lx\n", __func__, base, con, dat);
 
@@ -195,6 +223,7 @@
 
 static struct s3c_gpio_cfg gpio_4bit_cfg_noint = {
 	.set_config	= s3c_gpio_setcfg_s3c64xx_4bit,
+	.get_config	= s3c_gpio_getcfg_s3c64xx_4bit,
 	.set_pull	= s3c_gpio_setpull_updown,
 	.get_pull	= s3c_gpio_getpull_updown,
 };
@@ -202,6 +231,7 @@
 static struct s3c_gpio_cfg gpio_4bit_cfg_eint0111 = {
 	.cfg_eint	= 7,
 	.set_config	= s3c_gpio_setcfg_s3c64xx_4bit,
+	.get_config	= s3c_gpio_getcfg_s3c64xx_4bit,
 	.set_pull	= s3c_gpio_setpull_updown,
 	.get_pull	= s3c_gpio_getpull_updown,
 };
@@ -209,6 +239,7 @@
 static struct s3c_gpio_cfg gpio_4bit_cfg_eint0011 = {
 	.cfg_eint	= 3,
 	.set_config	= s3c_gpio_setcfg_s3c64xx_4bit,
+	.get_config	= s3c_gpio_getcfg_s3c64xx_4bit,
 	.set_pull	= s3c_gpio_setpull_updown,
 	.get_pull	= s3c_gpio_getpull_updown,
 };
@@ -303,6 +334,7 @@
 
 static struct s3c_gpio_cfg gpio_2bit_cfg_noint = {
 	.set_config	= s3c_gpio_setcfg_s3c24xx,
+	.get_config	= s3c_gpio_getcfg_s3c24xx,
 	.set_pull	= s3c_gpio_setpull_updown,
 	.get_pull	= s3c_gpio_getpull_updown,
 };
@@ -310,6 +342,7 @@
 static struct s3c_gpio_cfg gpio_2bit_cfg_eint10 = {
 	.cfg_eint	= 2,
 	.set_config	= s3c_gpio_setcfg_s3c24xx,
+	.get_config	= s3c_gpio_getcfg_s3c24xx,
 	.set_pull	= s3c_gpio_setpull_updown,
 	.get_pull	= s3c_gpio_getpull_updown,
 };
@@ -317,6 +350,7 @@
 static struct s3c_gpio_cfg gpio_2bit_cfg_eint11 = {
 	.cfg_eint	= 3,
 	.set_config	= s3c_gpio_setcfg_s3c24xx,
+	.get_config	= s3c_gpio_getcfg_s3c24xx,
 	.set_pull	= s3c_gpio_setpull_updown,
 	.get_pull	= s3c_gpio_getpull_updown,
 };
@@ -404,6 +438,7 @@
 	}
 }
 
+#if 0
 static __init int s3c64xx_gpiolib_init(void)
 {
 	s3c64xx_gpiolib_add(gpio_4bit, ARRAY_SIZE(gpio_4bit),
@@ -416,5 +451,198 @@
 
 	return 0;
 }
+#else
+void __init s3c64xx_gpiolib_init(void)
+{
+	s3c64xx_gpiolib_add(gpio_4bit, ARRAY_SIZE(gpio_4bit),
+			    s3c64xx_gpiolib_add_4bit);
+
+	s3c64xx_gpiolib_add(gpio_4bit2, ARRAY_SIZE(gpio_4bit2),
+			    s3c64xx_gpiolib_add_4bit2);
+
+	s3c64xx_gpiolib_add(gpio_2bit, ARRAY_SIZE(gpio_2bit), NULL);
+}
+#endif
+
+int s3c_gpio_slp_cfgpin(unsigned int pin, unsigned int config)
+{
+	struct s3c_gpio_chip *chip = s3c_gpiolib_getchip(pin);
+	void __iomem *reg;
+	unsigned long flags;
+	int offset;
+	u32 con;
+	int shift;
+
+	if (!chip)
+		return -EINVAL;
+	if((chip->base == (S3C64XX_GPK_BASE + 0x4)) ||
+   		(chip->base == (S3C64XX_GPL_BASE + 0x4)) ||
+		(chip->base == S3C64XX_GPM_BASE) ||
+		(chip->base == S3C64XX_GPN_BASE))
+	{
+		return -EINVAL;
+	}
+ 	
+	if(config > 3)
+	{
+		 return -EINVAL;
+	}
+
+	reg = chip->base + 0x0C;
+
+	offset = pin - chip->chip.base;
+	shift = offset * 2;
+
+	local_irq_save(flags);
+	
+	con = __raw_readl(reg);
+	con &= ~(3 << shift);
+        con |= config << shift;
+	 __raw_writel(con, reg);	
+	
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c_gpio_slp_cfgpin);
+
+s3c_gpio_pull_t s3c_gpio_get_slp_cfgpin(unsigned int pin)
+{
+	struct s3c_gpio_chip *chip = s3c_gpiolib_getchip(pin);
+	void __iomem *reg;
+	unsigned long flags;
+	int offset;
+	u32 con;
+	int shift;
+
+	if (!chip)
+		return -EINVAL;
+	if((chip->base == (S3C64XX_GPK_BASE + 0x4)) ||
+		(chip->base == (S3C64XX_GPL_BASE + 0x4)) ||
+		(chip->base == S3C64XX_GPM_BASE) ||
+		(chip->base == S3C64XX_GPN_BASE))
+	{
+		return -EINVAL;
+	}
+
+	reg = chip->base + 0x0C;
+
+	offset = pin - chip->chip.base;
+	shift = offset * 2;
+
+	local_irq_save(flags);
+
+	con = __raw_readl(reg);
+	con >>= shift;
+	con &= 0x3;
+
+	local_irq_restore(flags);
+	
+	return (__force s3c_gpio_pull_t)con;
+}
+
+int s3c_gpio_slp_setpull_updown(unsigned int pin, unsigned int config)
+{
+	struct s3c_gpio_chip *chip = s3c_gpiolib_getchip(pin);
+	void __iomem *reg;
+	unsigned long flags;
+	int offset;
+	u32 con;
+	int shift;
+
+	if (!chip)
+		return -EINVAL;
+	if((chip->base == (S3C64XX_GPK_BASE + 0x4)) ||
+		(chip->base == (S3C64XX_GPL_BASE + 0x4)) ||
+		(chip->base == S3C64XX_GPM_BASE) ||
+		(chip->base == S3C64XX_GPN_BASE))
+	{
+		return -EINVAL;
+	}
+	if(config > 3)
+	{
+		return -EINVAL;
+	}
+	reg = chip->base + 0x10;
+
+	offset = pin - chip->chip.base;
+	shift = offset * 2;
+
+	local_irq_save(flags);
+	
+	con = __raw_readl(reg);
+	con &= ~(3 << shift);
+	con |= config << shift;
+	__raw_writel(con, reg);
+
+	con = __raw_readl(reg);
+	
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c_gpio_slp_setpull_updown);
+
+s3c_gpio_pull_t s3c_gpio_slp_getpull_updown(unsigned int pin)
+{
+	struct s3c_gpio_chip *chip = s3c_gpiolib_getchip(pin);
+	void __iomem *reg;
+	unsigned long flags;
+	int offset;
+	u32 con;
+	int shift;
+
+	if (!chip)
+		return -EINVAL;
+	if((chip->base == (S3C64XX_GPK_BASE + 0x4)) ||
+		(chip->base == (S3C64XX_GPL_BASE + 0x4)) ||
+		(chip->base == S3C64XX_GPM_BASE) ||
+		(chip->base == S3C64XX_GPN_BASE))
+	{
+		return -EINVAL;
+	}
+	
+	reg = chip->base + 0x10;
+
+	offset = pin - chip->chip.base;
+	shift = offset * 2;
+
+	local_irq_save(flags);
+
+	con = __raw_readl(reg);
+	con >>= shift;
+	con &= 0x3;
+
+	local_irq_restore(flags);
+
+	return (__force s3c_gpio_pull_t)con;
+}
+#if 0
+arch_initcall(s3c64xx_gpiolib_init);
+#endif
+
+int gpio_to_irq(unsigned gpio)
+{
+	if ( gpio >= S3C64XX_GPN(0) && gpio <= S3C64XX_GPN(15) )
+		return IRQ_EINT(gpio - S3C64XX_GPIO_N_START);
+	else if ( gpio >= S3C64XX_GPL(8) && gpio <= S3C64XX_GPL(14) )
+		return IRQ_EINT(gpio - S3C64XX_GPL(8) + 16);
+	else if ( gpio >= S3C64XX_GPM(0) && gpio <= S3C64XX_GPM(4) )
+		return IRQ_EINT(gpio - S3C64XX_GPM(0) + 23);
+	
+        return -EINVAL;
+}
+ 
+int irq_to_gpio(unsigned irq)
+{
+	if (irq >= IRQ_EINT(0) && irq <= IRQ_EINT(15))
+		return S3C64XX_GPN(irq - IRQ_EINT(0));
+	else if (irq >= IRQ_EINT(16) && irq <= IRQ_EINT(22))
+		return S3C64XX_GPL(irq - IRQ_EINT(16) + 8);
+	else if (irq >= IRQ_EINT(23) && irq <= IRQ_EINT(27))
+		return S3C64XX_GPM(irq - IRQ_EINT(23));
+	
+        return -EINVAL;
+}
+
 
-core_initcall(s3c64xx_gpiolib_init);
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/adcts.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/adcts.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/adcts.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/adcts.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,55 @@
+/* arch/arm/plat-s3c/include/plat/adc.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_ADCTS_H
+#define __ASM_ARCH_ADCTS_H __FILE__
+
+#include <plat/regs-adc.h>
+
+enum s3c_adcts_type {
+	ADC_TYPE_0,
+	ADC_TYPE_1,	/* S3C2416, S3C2450 */
+	ADC_TYPE_2,	/* S3C64XX, S5PC1XX */
+};
+
+#define MAX_SCAN_TIME	(32)
+#define TS_CHANNEL	(8)
+#define MAX_ADC_CHANNEL	(8)
+
+enum s3c_adcts_state {
+	TS_STATUS_UP=0,
+	TS_STATUS_DOWN_NOW,
+	TS_STATUS_DOWN,
+};
+
+struct s3c_adcts_channel_info {
+        int delay;
+        int presc;
+        int resol;	/* S3C_ADCCON_RESSEL_10BIT or S3C_ADCCON_RESSEL_12BIT */
+};
+
+struct s3c_adcts_plat_info {
+	struct s3c_adcts_channel_info channel[MAX_ADC_CHANNEL];
+};
+
+struct s3c_adcts_value{
+	unsigned int	status;			/* 0:UP 1:DOWN NOW 2:DOWN */
+	unsigned int	xp[MAX_SCAN_TIME];
+	unsigned int	yp[MAX_SCAN_TIME];
+};
+
+extern struct s3c_ts_mach_info;
+extern int s3c_adcts_register_ts (struct s3c_ts_mach_info *ts,
+			void (*done_callback)(struct s3c_adcts_value *ts_value));
+extern int s3c_adcts_unregister_ts (void);
+extern int s3c_adc_get_adc_data(int channel);
+
+extern void __init s3c_adcts_set_platdata(struct s3c_adcts_plat_info *pd);
+#endif /* __ASM_ARCH_ADCTS_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/dma.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/dma.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/dma.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/dma.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,12 @@
+/* linux/arch/arm/plat-s3c64xx/include/plat/dma.h
+ *
+ * Copyright (C) 2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Samsung S3C64XX DMA support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+#include <plat/s3c-dma.h>
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-a.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-a.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-a.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-a.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_A_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_A_H __FILE__
+
 #define S3C64XX_GPACON			(S3C64XX_GPA_BASE + 0x00)
 #define S3C64XX_GPADAT			(S3C64XX_GPA_BASE + 0x04)
 #define S3C64XX_GPAPUD			(S3C64XX_GPA_BASE + 0x08)
@@ -46,3 +49,4 @@
 #define S3C64XX_GPA7_UART_nRTS1		(0x02 << 28)
 #define S3C64XX_GPA7_EINT_G1_7		(0x07 << 28)
 
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_A_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-b.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-b.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-b.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-b.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_B_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_B_H __FILE__
+
 #define S3C64XX_GPBCON			(S3C64XX_GPB_BASE + 0x00)
 #define S3C64XX_GPBDAT			(S3C64XX_GPB_BASE + 0x04)
 #define S3C64XX_GPBPUD			(S3C64XX_GPB_BASE + 0x08)
@@ -58,3 +61,4 @@
 #define S3C64XX_GPB6_I2C_SDA0		(0x02 << 24)
 #define S3C64XX_GPB6_EINT_G1_14		(0x07 << 24)
 
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_B_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-c.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-c.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-c.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-c.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_C_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_C_H __FILE__
+
 #define S3C64XX_GPCCON			(S3C64XX_GPC_BASE + 0x00)
 #define S3C64XX_GPCDAT			(S3C64XX_GPC_BASE + 0x04)
 #define S3C64XX_GPCPUD			(S3C64XX_GPC_BASE + 0x08)
@@ -25,29 +28,30 @@
 #define S3C64XX_GPC0_SPI_MISO0		(0x02 << 0)
 #define S3C64XX_GPC0_EINT_G2_0		(0x07 << 0)
 
-#define S3C64XX_GPC1_SPI_CLKO		(0x02 << 4)
+#define S3C64XX_GPC1_SPI_CLK0		(0x02 << 4)
 #define S3C64XX_GPC1_EINT_G2_1		(0x07 << 4)
 
-#define S3C64XX_GPC2_SPI_MOSIO		(0x02 << 8)
+#define S3C64XX_GPC2_SPI_MOSI0		(0x02 << 8)
 #define S3C64XX_GPC2_EINT_G2_2		(0x07 << 8)
 
-#define S3C64XX_GPC3_SPI_nCSO		(0x02 << 12)
+#define S3C64XX_GPC3_SPI_nCS0		(0x02 << 12)
 #define S3C64XX_GPC3_EINT_G2_3		(0x07 << 12)
 
 #define S3C64XX_GPC4_SPI_MISO1		(0x02 << 16)
 #define S3C64XX_GPC4_MMC2_CMD		(0x03 << 16)
-#define S3C64XX_GPC4_I2S0_V40_DO	(0x05 << 16)
+#define S3C64XX_GPC4_I2S_V40_DO0	(0x05 << 16)
 #define S3C64XX_GPC4_EINT_G2_4		(0x07 << 16)
 
 #define S3C64XX_GPC5_SPI_CLK1		(0x02 << 20)
 #define S3C64XX_GPC5_MMC2_CLK		(0x03 << 20)
-#define S3C64XX_GPC5_I2S1_V40_DO	(0x05 << 20)
+#define S3C64XX_GPC5_I2S_V40_DO1	(0x05 << 20)
 #define S3C64XX_GPC5_EINT_G2_5		(0x07 << 20)
 
 #define S3C64XX_GPC6_SPI_MOSI1		(0x02 << 24)
 #define S3C64XX_GPC6_EINT_G2_6		(0x07 << 24)
 
 #define S3C64XX_GPC7_SPI_nCS1		(0x02 << 28)
-#define S3C64XX_GPC7_I2S2_V40_DO	(0x05 << 28)
+#define S3C64XX_GPC7_I2S_V40_DO2	(0x05 << 28)
 #define S3C64XX_GPC7_EINT_G2_7		(0x07 << 28)
 
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_C_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-d.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-d.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-d.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-d.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_D_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_D_H __FILE__
+
 #define S3C64XX_GPDCON			(S3C64XX_GPD_BASE + 0x00)
 #define S3C64XX_GPDDAT			(S3C64XX_GPD_BASE + 0x04)
 #define S3C64XX_GPDPUD			(S3C64XX_GPD_BASE + 0x08)
@@ -43,7 +46,8 @@
 #define S3C64XX_GPD3_EINT_G3_3		(0x07 << 12)
 
 #define S3C64XX_GPD4_PCM0_SOUT		(0x02 << 16)
-#define S3C64XX_GPD4_I2S0_D0		(0x03 << 16)
+#define S3C64XX_GPD4_I2S0_DO		(0x03 << 16)
 #define S3C64XX_GPD4_AC97_SDO		(0x04 << 16)
 #define S3C64XX_GPD4_EINT_G3_4		(0x07 << 16)
 
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_D_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-e.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-e.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-e.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-e.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_E_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_E_H __FILE__
+
 #define S3C64XX_GPECON			(S3C64XX_GPE_BASE + 0x00)
 #define S3C64XX_GPEDAT			(S3C64XX_GPE_BASE + 0x04)
 #define S3C64XX_GPEPUD			(S3C64XX_GPE_BASE + 0x08)
@@ -42,3 +45,4 @@
 #define S3C64XX_GPE4_I2S1_D0		(0x03 << 16)
 #define S3C64XX_GPE4_AC97_SDO		(0x04 << 16)
 
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_E_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-f.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-f.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-f.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-f.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_F_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_F_H __FILE__
+
 #define S3C64XX_GPFCON			(S3C64XX_GPF_BASE + 0x00)
 #define S3C64XX_GPFDAT			(S3C64XX_GPF_BASE + 0x04)
 #define S3C64XX_GPFPUD			(S3C64XX_GPF_BASE + 0x08)
@@ -69,3 +72,4 @@
 
 #define S3C64XX_GPF15_PWM_TOUT1		(0x02 << 30)
 
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_F_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-g.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-g.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-g.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-g.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_G_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_G_H __FILE__
+
 #define S3C64XX_GPGCON			(S3C64XX_GPG_BASE + 0x00)
 #define S3C64XX_GPGDAT			(S3C64XX_GPG_BASE + 0x04)
 #define S3C64XX_GPGPUD			(S3C64XX_GPG_BASE + 0x08)
@@ -40,3 +43,8 @@
 #define S3C64XX_GPG5_MMC0_DATA3		(0x02 << 20)
 #define S3C64XX_GPG5_EINT_G5_5		(0x07 << 20)
 
+#define S3C64XX_GPG6_MMC0_nCD		(0x02 << 24)
+#define S3C64XX_GPG6_MMC1_nCD		(0x03 << 24)
+#define S3C64XX_GPG6_EINT_G5_6		(0x07 << 24)
+
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_G_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-h.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-h.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-h.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-h.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_H_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_H_H __FILE__
+
 #define S3C64XX_GPHCON0			(S3C64XX_GPH_BASE + 0x00)
 #define S3C64XX_GPHCON1			(S3C64XX_GPH_BASE + 0x04)
 #define S3C64XX_GPHDAT			(S3C64XX_GPH_BASE + 0x08)
@@ -61,14 +64,15 @@
 #define S3C64XX_GPH7_ADDR_CF1		(0x06 << 28)
 #define S3C64XX_GPH7_EINT_G6_7		(0x07 << 28)
 
-#define S3C64XX_GPH8_MMC1_DATA6		(0x02 << 32)
-#define S3C64XX_GPH8_MMC2_DATA2		(0x03 << 32)
-#define S3C64XX_GPH8_I2S_V40_LRCLK	(0x05 << 32)
-#define S3C64XX_GPH8_ADDR_CF2		(0x06 << 32)
-#define S3C64XX_GPH8_EINT_G6_8		(0x07 << 32)
-
-#define S3C64XX_GPH9_MMC1_DATA7		(0x02 << 36)
-#define S3C64XX_GPH9_MMC2_DATA3		(0x03 << 36)
-#define S3C64XX_GPH9_I2S_V40_DI		(0x05 << 36)
-#define S3C64XX_GPH9_EINT_G6_9		(0x07 << 36)
+#define S3C64XX_GPH8_MMC1_DATA6		(0x02 << 0)
+#define S3C64XX_GPH8_MMC2_DATA2		(0x03 << 0)
+#define S3C64XX_GPH8_I2S_V40_LRCLK	(0x05 << 0)
+#define S3C64XX_GPH8_ADDR_CF2		(0x06 << 0)
+#define S3C64XX_GPH8_EINT_G6_8		(0x07 << 0)
+
+#define S3C64XX_GPH9_MMC1_DATA7		(0x02 << 4)
+#define S3C64XX_GPH9_MMC2_DATA3		(0x03 << 4)
+#define S3C64XX_GPH9_I2S_V40_DI		(0x05 << 4)
+#define S3C64XX_GPH9_EINT_G6_9		(0x07 << 4)
 
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_H_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-i.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-i.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-i.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-i.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_I_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_I_H __FILE__
+
 #define S3C64XX_GPICON			(S3C64XX_GPI_BASE + 0x00)
 #define S3C64XX_GPIDAT			(S3C64XX_GPI_BASE + 0x04)
 #define S3C64XX_GPIPUD			(S3C64XX_GPI_BASE + 0x08)
@@ -38,3 +41,5 @@
 #define S3C64XX_GPI13_VD13		(0x02 << 26)
 #define S3C64XX_GPI14_VD14		(0x02 << 28)
 #define S3C64XX_GPI15_VD15		(0x02 << 30)
+
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_I_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-j.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-j.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-j.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-j.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_J_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_J_H __FILE__
+
 #define S3C64XX_GPJCON			(S3C64XX_GPJ_BASE + 0x00)
 #define S3C64XX_GPJDAT			(S3C64XX_GPJ_BASE + 0x04)
 #define S3C64XX_GPJPUD			(S3C64XX_GPJ_BASE + 0x08)
@@ -34,3 +37,5 @@
 #define S3C64XX_GPJ9_LCD_VSYNC		(0x02 << 18)
 #define S3C64XX_GPJ10_LCD_VDEN		(0x02 << 20)
 #define S3C64XX_GPJ11_LCD_VCLK		(0x02 << 22)
+
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_J_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-k.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-k.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-k.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-k.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,28 @@
+/* linux/arch/arm/plat-s3c64xx/include/plat/gpio-bank-k.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ * 	Ben Dooks <ben@simtec.co.uk>
+ * 	http://armlinux.simtec.co.uk/
+ *
+ * GPIO Bank J register and configuration definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_K_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_K_H __FILE__
+
+#define S3C64XX_GPKCON			(S3C64XX_GPK_BASE + 0x00)
+#define S3C64XX_GPKCON1			(S3C64XX_GPK_BASE + 0x04)
+#define S3C64XX_GPKDAT			(S3C64XX_GPK_BASE + 0x08)
+#define S3C64XX_GPKPUD			(S3C64XX_GPK_BASE + 0x0c)
+
+#define S3C64XX_GPK_CONMASK(__gpio)	(0x3 << ((__gpio) * 2))
+#define S3C64XX_GPK_INPUT(__gpio)	(0x0 << ((__gpio) * 2))
+#define S3C64XX_GPK_OUTPUT(__gpio)	(0x1 << ((__gpio) * 2))
+
+
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_K_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-l.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-l.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-l.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-l.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,132 @@
+/* linux/arch/arm/plat-s3c64xx/include/plat/gpio-bank-l.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ * 	Ben Dooks <ben@simtec.co.uk>
+ * 	http://armlinux.simtec.co.uk/
+ *
+ * GPIO Bank J register and configuration definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_L_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_L_H __FILE__
+
+#define S3C64XX_GPLCON			(S3C64XX_GPL_BASE + 0x00)
+#define S3C64XX_GPLCON1			(S3C64XX_GPL_BASE + 0x04)
+#define S3C64XX_GPLDAT			(S3C64XX_GPL_BASE + 0x08)
+#define S3C64XX_GPLPUD			(S3C64XX_GPL_BASE + 0x0c)
+
+#define S3C64XX_GPL_CONMASK(__gpio)	(0xf << ((__gpio) * 4))
+#define S3C64XX_GPL_INPUT(__gpio)	(0x0 << ((__gpio) * 4))
+#define S3C64XX_GPL_OUTPUT(__gpio)	(0x1 << ((__gpio) * 4))
+
+#define S3C64XX_GPL0_HOSTIF_ADDR0	(0x2 << 0)
+#define S3C64XX_GPL0_KEYPAD_COL0	(0x3 << 0)
+#define S3C64XX_GPL0_RESERVED1		(0x4 << 0)
+#define S3C64XX_GPL0_RESERVED2		(0x5 << 0)
+#define S3C64XX_GPL0_ADDR_CF0		(0x6 << 0)
+#define S3C64XX_GPL0_OTG_ULPI_DATA0	(0x7 << 0)
+
+#define S3C64XX_GPL1_HOSTIF_ADDR1	(0x2 << 4)
+#define S3C64XX_GPL1_KEYPAD_COL1	(0x3 << 4)
+#define S3C64XX_GPL1_RESERVED1		(0x4 << 4)
+#define S3C64XX_GPL1_RESERVED2		(0x5 << 4)
+#define S3C64XX_GPL1_ADDR_CF1		(0x6 << 4)
+#define S3C64XX_GPL1_OTG_ULPI_DATA1	(0x7 << 4)
+
+#define S3C64XX_GPL2_HOSTIF_ADDR2	(0x2 << 8)
+#define S3C64XX_GPL2_KEYPAD_COL2	(0x3 << 8)
+#define S3C64XX_GPL2_RESERVED1		(0x4 << 8)
+#define S3C64XX_GPL2_RESERVED2		(0x5 << 8)
+#define S3C64XX_GPL2_ADDR_CF2		(0x6 << 8)
+#define S3C64XX_GPL2_OTG_ULPI_DATA2	(0x7 << 8)
+
+#define S3C64XX_GPL3_HOSTIF_ADDR3	(0x2 << 12)
+#define S3C64XX_GPL3_KEYPAD_COL3	(0x3 << 12)
+#define S3C64XX_GPL3_RESERVED1      (0x4 << 12)
+#define S3C64XX_GPL3_RESERVED2		(0x5 << 12)
+#define S3C64XX_GPL3_RESERVED3		(0x6 << 12)
+#define S3C64XX_GPL3_OTG_ULPI_DATA3	(0x7 << 12)
+
+#define S3C64XX_GPL4_HOSTIF_ADDR4	(0x2 << 16)
+#define S3C64XX_GPL4_KEYPAD_COL4	(0x3 << 16)
+#define S3C64XX_GPL4_RESERVED1		(0x4 << 16)
+#define S3C64XX_GPL4_RESERVED2		(0x5 << 16)
+#define S3C64XX_GPL4_RESERVED3		(0x6 << 16)
+#define S3C64XX_GPL4_OTG_ULPI_DATA4	(0x7 << 16)
+
+#define S3C64XX_GPL5_HOSTIF_ADDR5	(0x2 << 20)
+#define S3C64XX_GPL5_KEYPAD_COL5	(0x3 << 20)
+#define S3C64XX_GPL5_RESERVED1		(0x4 << 20)
+#define S3C64XX_GPL5_RESERVED2		(0x5 << 20)
+#define S3C64XX_GPL5_RESERVED3		(0x6 << 20)
+#define S3C64XX_GPL5_OTG_ULPI_DATA5	(0x7 << 20)
+
+#define S3C64XX_GPL6_HOSTIF_ADDR6	(0x2 << 24)
+#define S3C64XX_GPL6_KEYPAD_COL6	(0x3 << 24)
+#define S3C64XX_GPL6_RESERVED1		(0x4 << 24)
+#define S3C64XX_GPL6_RESERVED2		(0x5 << 24)
+#define S3C64XX_GPL6_RESERVED3		(0x6 << 24)
+#define S3C64XX_GPL6_OTG_ULPI_DATA6	(0x7 << 24)
+
+#define S3C64XX_GPL7_HOSTIF_ADDR7	(0x2 << 28)
+#define S3C64XX_GPL7_KEYPAD_COL7	(0x3 << 28)
+#define S3C64XX_GPL7_RESERVED1		(0x4 << 28)
+#define S3C64XX_GPL7_RESERVED2		(0x5 << 28)
+#define S3C64XX_GPL7_RESERVED3		(0x6 << 28)
+#define S3C64XX_GPL7_OTG_ULPI_DATA	(0x7 << 28)
+
+#define S3C64XX_GPL8_HOSTIF_ADDR8	(0x2 << 0)
+#define S3C64XX_GPL8_EXTINT16		(0x3 << 0)
+#define S3C64XX_GPL8_RESERVED1		(0x4 << 0)
+#define S3C64XX_GPL8_CE_CF0			(0x5 << 0)
+#define S3C64XX_GPL8_RESERVED2		(0x6 << 0)
+#define S3C64XX_GPL8_OTG_ULPI_STP	(0x7 << 0)
+
+#define S3C64XX_GPL9_HOSTIF_ADDR9	(0x2 << 4)
+#define S3C64XX_GPL9_EXTINT17		(0x3 << 4)
+#define S3C64XX_GPL9_RESERVED1		(0x4 << 4)
+#define S3C64XX_GPL9_CE_CF1			(0x5 << 4)
+#define S3C64XX_GPL9_RESERVED2		(0x6 << 4)
+#define S3C64XX_GPL9_OTG_ULPI_CLK	(0x7 << 4)
+
+#define S3C64XX_GPL10_SPI_CLK1		(0x2 << 8)
+#define S3C64XX_GPL10_EXTINT18		(0x3 << 8)
+#define S3C64XX_GPL10_RESERVED1		(0x4 << 8)
+#define S3C64XX_GPL10_IORD_CF		(0x5 << 8)
+#define S3C64XX_GPL10_RESERVED2		(0x6 << 8)
+#define S3C64XX_GPL10_OTG_ULPI_NXT	(0x7 << 8)
+
+#define S3C64XX_GPL11_SPI_MOSI1		(0x2 << 12)
+#define S3C64XX_GPL11_EXTINT19		(0x3 << 12)
+#define S3C64XX_GPL11_RESERVED1		(0x4 << 12)
+#define S3C64XX_GPL11_IOWR_CF		(0x5 << 12)
+#define S3C64XX_GPL11_RESERVED2		(0x6 << 12)
+#define S3C64XX_GPL11_OTG_ULPI_DIR	(0x7 << 12)
+
+#define S3C64XX_GPL12_SPI_MISO1		(0x2 << 16)
+#define S3C64XX_GPL12_EXTINT20		(0x3 << 16)
+#define S3C64XX_GPL12_RESERVED1		(0x4 << 16)
+#define S3C64XX_GPL12_IORDY_CF		(0x5 << 16)
+#define S3C64XX_GPL12_RESERVED2		(0x6 << 16)
+#define S3C64XX_GPL12_RESERVED3		(0x7 << 16)
+
+#define S3C64XX_GPL14_nSS0			(0x2 << 20)
+#define S3C64XX_GPL13_EXTINT21		(0x3 << 20)
+#define S3C64XX_GPL13_RESERVED1		(0x4 << 20)
+#define S3C64XX_GPL13_DATA_CF8		(0x5 << 20)
+#define S3C64XX_GPL13_RESERVED2		(0x6 << 20)
+#define S3C64XX_GPL13_RESERVED3		(0x7 << 20)
+
+#define S3C64XX_GPL14_nSS1			(0x2 << 24)
+#define S3C64XX_GPL14_EXTINT22		(0x3 << 24)
+#define S3C64XX_GPL14_RESERVED1		(0x4 << 24)
+#define S3C64XX_GPL14_DATA_CF9		(0x5 << 24)
+#define S3C64XX_GPL14_RESERVED2		(0x6 << 24)
+#define S3C64XX_GPL14_RESERVED3		(0x7 << 24)
+
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_L_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-m.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-m.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-m.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-m.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,67 @@
+/* linux/arch/arm/plat-s3c64xx/include/plat/gpio-bank-m.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *  Ben Dooks <ben@simtec.co.uk>
+ *  http://armlinux.simtec.co.uk/
+ *
+ * GPIO Bank M register and configuration definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_M_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_M_H __FILE__
+
+#define S3C64XX_GPMCON          (S3C64XX_GPM_BASE + 0x00)
+#define S3C64XX_GPMDAT          (S3C64XX_GPM_BASE + 0x04)
+#define S3C64XX_GPMPUD          (S3C64XX_GPM_BASE + 0x08)
+
+#define S3C64XX_GPM_CONMASK(__gpio) (0x3 << ((__gpio) * 2))
+#define S3C64XX_GPM_INPUT(__gpio)   (0x0 << ((__gpio) * 2))
+#define S3C64XX_GPM_OUTPUT(__gpio)  (0x1 << ((__gpio) * 2))
+
+#define S3C64XX_GPM0_HOSTIF_CS      (0x02 << 0)
+#define S3C64XX_GPM0_EINT23      (0x03 << 0)
+#define S3C64XX_GPM0_RESERVED1      (0x04 << 0)
+#define S3C64XX_GPM0_DATA_CF10      (0x05 << 0)
+#define S3C64XX_GPM0_CE_CF0      (0x06 << 0)
+#define S3C64XX_GPM0_RESERVED2      (0x07 << 0)
+
+#define S3C64XX_GPM1_HOSTIF_CS_M      (0x02 << 0)
+#define S3C64XX_GPM1_EINT24      (0x03 << 0)
+#define S3C64XX_GPM1_RESERVED1      (0x04 << 0)
+#define S3C64XX_GPM1_DATA_CF11      (0x05 << 0)
+#define S3C64XX_GPM1_CE_CF1      (0x06 << 0)
+#define S3C64XX_GPM1_RESERVED2      (0x07 << 0)
+
+#define S3C64XX_GPM2_HOSTIF_IF_CS_S      (0x02 << 0)
+#define S3C64XX_GPM2_EINT25      (0x03 << 0)
+#define S3C64XX_GPM2_HOSTIF_MDP_VSYNC      (0x04 << 0)
+#define S3C64XX_GPM2_DATA_CF12      (0x05 << 0)
+#define S3C64XX_GPM2_IORD_CF      (0x06 << 0)
+#define S3C64XX_GPM2_RESERVED2      (0x07 << 0)
+
+#define S3C64XX_GPM3_HOSTIF_WE      (0x02 << 0)
+#define S3C64XX_GPM3_EINT26      (0x03 << 0)
+#define S3C64XX_GPM3_RESERVED1      (0x04 << 0)
+#define S3C64XX_GPM3_DATA_CF13      (0x05 << 0)
+#define S3C64XX_GPM3_IOWR_CF      (0x06 << 0)
+#define S3C64XX_GPM3_RESERVED2      (0x07 << 0)
+
+#define S3C64XX_GPM4_HOSTIF_OE      (0x02 << 0)
+#define S3C64XX_GPM4_EINT27      (0x03 << 0)
+#define S3C64XX_GPM4_RESERVED1      (0x04 << 0)
+#define S3C64XX_GPM4_DATA_CF14      (0x05 << 0)
+#define S3C64XX_GPM4_IORDY_CF      (0x06 << 0)
+#define S3C64XX_GPM4_RESERVED2      (0x07 << 0)
+
+#define S3C64XX_GPM5_HOSTIF_INTR      (0x02 << 0)
+#define S3C64XX_GPM5_CF_DATA_DIR      (0x03 << 0)
+#define S3C64XX_GPM5_RESERVED1      (0x04 << 0)
+#define S3C64XX_GPM5_DATA_CF15      (0x05 << 0)
+#define S3C64XX_GPM5_RESERVED2      (0x06 << 0)
+#define S3C64XX_GPM5_RESERVED3      (0x07 << 0)
+
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_M_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-n.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-n.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-n.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-n.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_N_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_N_H __FILE__
+
 #define S3C64XX_GPNCON			(S3C64XX_GPN_BASE + 0x00)
 #define S3C64XX_GPNDAT			(S3C64XX_GPN_BASE + 0x04)
 #define S3C64XX_GPNPUD			(S3C64XX_GPN_BASE + 0x08)
@@ -52,3 +55,5 @@
 #define S3C64XX_GPN13_EINT13		(0x02 << 26)
 #define S3C64XX_GPN14_EINT14		(0x02 << 28)
 #define S3C64XX_GPN15_EINT15		(0x02 << 30)
+
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_N_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-o.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-o.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-o.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-o.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_O_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_O_H __FILE__
+
 #define S3C64XX_GPOCON			(S3C64XX_GPO_BASE + 0x00)
 #define S3C64XX_GPODAT			(S3C64XX_GPO_BASE + 0x04)
 #define S3C64XX_GPOPUD			(S3C64XX_GPO_BASE + 0x08)
@@ -68,3 +71,4 @@
 #define S3C64XX_GPO15_MEM0_ADDR15	(0x02 << 30)
 #define S3C64XX_GPO15_EINT_G7_15	(0x03 << 30)
 
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_O_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-p.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-p.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-p.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-p.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_P_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_P_H __FILE__
+
 #define S3C64XX_GPPCON			(S3C64XX_GPP_BASE + 0x00)
 #define S3C64XX_GPPDAT			(S3C64XX_GPP_BASE + 0x04)
 #define S3C64XX_GPPPUD			(S3C64XX_GPP_BASE + 0x08)
@@ -67,3 +70,4 @@
 #define S3C64XX_GPP14_MEM0_ATA_CD	(0x02 << 28)
 #define S3C64XX_GPP14_EINT_G8_14	(0x03 << 28)
 
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_P_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-q.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-q.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/gpio-bank-q.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/gpio-bank-q.h	2010-05-06 12:42:45.634864134 +0700
@@ -12,6 +12,9 @@
  * published by the Free Software Foundation.
 */
 
+#ifndef __ASM_PLAT_S3C64XX_GPIO_BANK_Q_H
+#define __ASM_PLAT_S3C64XX_GPIO_BANK_Q_H __FILE__
+
 #define S3C64XX_GPQCON			(S3C64XX_GPQ_BASE + 0x00)
 #define S3C64XX_GPQDAT			(S3C64XX_GPQ_BASE + 0x04)
 #define S3C64XX_GPQPUD			(S3C64XX_GPQ_BASE + 0x08)
@@ -44,3 +47,4 @@
 #define S3C64XX_GPQ8_MEM0_ADDR16_APDMC	(0x02 << 16)
 #define S3C64XX_GPQ8_EINT_G9_8		(0x03 << 16)
 
+#endif	/* __ASM_PLAT_S3C64XX_GPIO_BANK_Q_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/irqs.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/irqs.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/irqs.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/irqs.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* linux/arch/arm/plat-s3c64xx/include/mach/irqs.h
+/* linux/arch/arm/plat-s3c64xx/include/plat/irqs.h
  *
  * Copyright 2008 Openmoko, Inc.
  * Copyright 2008 Simtec Electronics
@@ -117,13 +117,13 @@
 #define IRQ_ONENAND1		S3C64XX_IRQ_VIC1(12)
 #define IRQ_NFC			S3C64XX_IRQ_VIC1(13)
 #define IRQ_CFCON		S3C64XX_IRQ_VIC1(14)
-#define IRQ_USBH		S3C64XX_IRQ_VIC1(15)
+#define IRQ_UHOST		S3C64XX_IRQ_VIC1(15)
 #define IRQ_SPI0		S3C64XX_IRQ_VIC1(16)
 #define IRQ_SPI1		S3C64XX_IRQ_VIC1(17)
 #define IRQ_IIC			S3C64XX_IRQ_VIC1(18)
 #define IRQ_HSItx		S3C64XX_IRQ_VIC1(19)
 #define IRQ_HSIrx		S3C64XX_IRQ_VIC1(20)
-#define IRQ_RESERVED		S3C64XX_IRQ_VIC1(21)
+#define IRQ_EINT_GROUPS		S3C64XX_IRQ_VIC1(21)
 #define IRQ_MSM			S3C64XX_IRQ_VIC1(22)
 #define IRQ_HOSTIF		S3C64XX_IRQ_VIC1(23)
 #define IRQ_HSMMC0		S3C64XX_IRQ_VIC1(24)
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/pll.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/pll.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/pll.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/pll.h	2010-05-06 12:42:45.634864134 +0700
@@ -37,9 +37,9 @@
 	return (unsigned long)fvco;
 }
 
-#define S3C6400_EPLL_MDIV_MASK	((1 << (23-16)) - 1)
-#define S3C6400_EPLL_PDIV_MASK	((1 << (13-8)) - 1)
-#define S3C6400_EPLL_SDIV_MASK	((1 << (2-0)) - 1)
+#define S3C6400_EPLL_MDIV_MASK	((1 << (23-16+1)) - 1)
+#define S3C6400_EPLL_PDIV_MASK	((1 << (13-8+1)) - 1)
+#define S3C6400_EPLL_SDIV_MASK	((1 << (2-0+1)) - 1)
 #define S3C6400_EPLL_MDIV_SHIFT	(16)
 #define S3C6400_EPLL_PDIV_SHIFT	(8)
 #define S3C6400_EPLL_SDIV_SHIFT	(0)
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/pm.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/pm.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/pm.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/pm.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,141 @@
+/* linux/include/asm-arm/plat-s3c24xx/pm.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *	Written by Ben Dooks, <ben@simtec.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/sysdev.h>
+
+/* s3c2410_pm_init
+ *
+ * called from board at initialisation time to setup the power
+ * management
+*/
+
+#ifdef CONFIG_PM
+
+extern __init int s3c6410_pm_init(void);
+
+#else
+
+static inline int s3c6410_pm_init(void)
+{
+	return 0;
+}
+#endif
+
+/* configuration for the IRQ mask over sleep */
+extern unsigned long s3c_irqwake_intmask;
+extern unsigned long s3c_irqwake_eintmask;
+
+/* IRQ masks for IRQs allowed to go to sleep (see irq.c) */
+extern unsigned long s3c_irqwake_intallow;
+extern unsigned long s3c_irqwake_eintallow;
+
+/* per-cpu sleep functions */
+
+extern void (*pm_cpu_prep)(void);
+extern void (*pm_cpu_sleep)(void);
+
+/* Flags for PM Control */
+
+extern unsigned long s3c_pm_flags;
+
+/* from sleep.S */
+
+extern int  s3c6410_cpu_save(unsigned long *saveblk);
+extern void s3c6410_cpu_suspend(void);
+extern void s3c6410_cpu_resume(void);
+
+extern unsigned long s3c6410_sleep_save_phys;
+
+/* sleep save info */
+
+struct sleep_save {
+	void __iomem	*reg;
+	unsigned long	val;
+};
+
+struct sleep_save_phy {
+	unsigned long	reg;
+	unsigned long	val;
+};
+
+#define SAVE_ITEM(x) \
+	{ .reg = (x) }
+
+/* for the power saving unused IP clock list */
+#define S3C_SCLK_MASK	~(S3C_CLKCON_SCLK_CAM | \
+			S3C_CLKCON_SCLK_IRDA | \
+			S3C_CLKCON_SCLK_SECUR |	\
+			S3C_CLKCON_SCLK_AUDIO0 | \
+			S3C_CLKCON_SCLK_AUDIO1 | \
+			S3C_CLKCON_SCLK_POST0 | \
+			S3C6410_CLKCON_SCLK_AUDIO2 | \
+			S3C_CLKCON_SCLK_POST0_27 | \
+			S3C_CLKCON_SCLK_LCD27 | \
+			S3C_CLKCON_SCLK_SCALER | \
+			S3C_CLKCON_SCLK_SCALER27 | \
+			S3C_CLKCON_SCLK_TV27 | \
+			S3C_CLKCON_SCLK_DAC27 | \
+			S3C_CLKCON_SCLK_SPI0 | \
+			S3C_CLKCON_SCLK_SPI1 | \
+			S3C_CLKCON_SCLK_SPI0_48 | \
+			S3C_CLKCON_SCLK_SPI1_48 | \
+			S3C_CLKCON_SCLK_MMC0 | \
+			S3C_CLKCON_SCLK_MMC1 | \
+			S3C_CLKCON_SCLK_MMC2 | \
+			S3C_CLKCON_SCLK_MMC0_48 | \
+			S3C_CLKCON_SCLK_MMC1_48 | \
+			S3C_CLKCON_SCLK_MMC2_48 | \
+			S3C_CLKCON_SCLK_UHOST )
+
+#define S3C_PCLK_MASK	~(S3C_CLKCON_PCLK_UART3 | \
+			S3C_CLKCON_PCLK_PCM0 | \
+			S3C_CLKCON_PCLK_PCM1 | \
+			S3C_CLKCON_PCLK_IRDA | \
+			S3C_CLKCON_PCLK_TZPC | \
+			S3C_CLKCON_PCLK_AC97 | \
+			S3C_CLKCON_PCLK_IIS0 | \
+			S3C_CLKCON_PCLK_HSITX | \
+			S3C_CLKCON_PCLK_HSIRX | \
+			S3C_CLKCON_PCLK_SPI1 | \
+			S3C_CLKCON_PCLK_CHIPID | \
+			S3C_CLKCON_PCLK_SKEY | \
+			S3C6410_CLKCON_PCLK_IIS2 )
+
+#define S3C_HCLK_MASK	~(S3C_CLKCON_HCLK_TZIC | \
+			S3C_CLKCON_HCLK_TV | \
+			S3C_CLKCON_HCLK_SCALER | \
+			S3C_CLKCON_HCLK_CAMIF | \
+			S3C_CLKCON_HCLK_IHOST | \
+			S3C_CLKCON_HCLK_DHOST | \
+			S3C_CLKCON_HCLK_MDP | \
+			S3C_CLKCON_HCLK_HSMMC2 | \
+			S3C_CLKCON_HCLK_UHOST | \
+			S3C_CLKCON_HCLK_IROM | \
+			S3C_CLKCON_HCLK_SDMA2 | \
+			S3C_CLKCON_HCLK_SDMA1 | \
+			S3C_CLKCON_HCLK_SECUR | \
+			S3C_CLKCON_HCLK_3DSE )
+
+extern void s3c6410_pm_do_save_phy(struct sleep_save_phy *ptr, int count);
+extern void s3c6410_pm_do_restore_phy(struct sleep_save_phy *ptr, int count);
+extern void s3c6410_pm_do_save(struct sleep_save *ptr, int count);
+extern void s3c6410_pm_do_restore(struct sleep_save *ptr, int count);
+extern int domain_off_check(unsigned int config);
+#ifdef CONFIG_S3C64XX_DOMAIN_GATING
+extern void s3c_set_normal_cfg(unsigned int config, unsigned int flag, unsigned int ID);
+extern int s3c_wait_blk_pwr_ready(unsigned int config);
+#endif /* CONFIG_S3C64XX_DOMAIN_GATING */
+#ifdef CONFIG_PM
+extern int s3c64xx_irq_suspend(struct sys_device *dev, pm_message_t state);
+extern int s3c64xx_irq_resume(struct sys_device *dev);
+#else
+#define s3c64xx_irq_suspend	NULL
+#define s3c64xx_irq_resume	NULL
+#endif
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/power-clock-domain.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/power-clock-domain.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/power-clock-domain.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/power-clock-domain.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,62 @@
+/* Copyright 2008 Samsung Electronics
+ *     
+ *
+ * S3C64XX NORMAL CONFIG definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __POWER_DOMAIN_H
+#define __POWER_DOMAIN_H __FILE__
+/*NORMAL_CFG*/
+/* 0 -> 8 RESERVED */
+#define S3C64XX_DOMAIN_V	(1 << 9)
+#define S3C64XX_DOMAIN_G	(1 << 10)
+#define S3C64XX_DOMAIN_I	(1 << 12)
+#define S3C64XX_DOMAIN_P	(1 << 13)
+#define S3C64XX_DOMAIN_F	(1 << 14)
+#define S3C64XX_DOMAIN_S	(1 << 15)
+#define S3C64XX_DOMAIN_ETM	(1 << 16)
+#define S3C64XX_DOMAIN_IROM	(1 << 30)
+
+#define S3C64XX_LP_MODE		0
+#define S3C64XX_ACTIVE_MODE	1
+
+#define S3C64XX_BLK_TOP		(1 << 0)
+#define S3C64XX_BLK_V		(1 << 1)
+#define S3C64XX_BLK_I		(1 << 2)
+#define S3C64XX_BLK_P		(1 << 3)
+#define S3C64XX_BLK_F		(1 << 4)
+#define S3C64XX_BLK_S		(1 << 5)
+#define S3C64XX_BLK_ETM		(1 << 6)
+#define S3C64XX_BLK_G		(1 << 7)
+
+#define S3C64XX_3D		(0)
+#define S3C64XX_MFC		(1)
+#define S3C64XX_JPEG		(2)
+#define S3C64XX_CAMERA		(3)
+#define S3C64XX_2D		(4)
+#define S3C64XX_TVENC		(5)
+#define S3C64XX_SCALER		(6)
+#define S3C64XX_ROT		(7)
+#define S3C64XX_POST		(8)
+#define S3C64XX_LCD		(9)
+#define S3C64XX_SDMA0		(10)
+#define S3C64XX_SDMA1		(11)
+#define S3C64XX_SECURITY	(12)
+#define S3C64XX_ETM       	(13)
+#define S3C64XX_IROM	        (14)
+
+#define S3C64XX_DOMAIN_V_MASK	(1 << 1)
+#define S3C64XX_DOMAIN_G_MASK	(1 << 0)
+#define S3C64XX_DOMAIN_I_MASK	(0x3 << 2)
+#define S3C64XX_DOMAIN_P_MASK	(0x7 << 4)
+#define S3C64XX_DOMAIN_F_MASK	(0x7 << 7)
+#define S3C64XX_DOMAIN_S_MASK   (0x7 << 10)
+#define S3C64XX_DOMAIN_ETM_MASK (1 << 13)
+#define S3C64XX_DOMAIN_IROM_MASK (1 << 14)	
+
+
+#endif  
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/regs-clock.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/regs-clock.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/regs-clock.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/regs-clock.h	2010-05-06 12:42:45.634864134 +0700
@@ -25,6 +25,7 @@
 #define S3C_EPLL_CON0		S3C_CLKREG(0x14)
 #define S3C_EPLL_CON1		S3C_CLKREG(0x18)
 #define S3C_CLK_SRC		S3C_CLKREG(0x1C)
+#define S3C_CLK_SRC2            S3C_CLKREG(0x10C)
 #define S3C_CLK_DIV0		S3C_CLKREG(0x20)
 #define S3C_CLK_DIV1		S3C_CLKREG(0x24)
 #define S3C_CLK_DIV2		S3C_CLKREG(0x28)
@@ -32,6 +33,49 @@
 #define S3C_HCLK_GATE		S3C_CLKREG(0x30)
 #define S3C_PCLK_GATE		S3C_CLKREG(0x34)
 #define S3C_SCLK_GATE		S3C_CLKREG(0x38)
+#define S3C_MEM0_CLK_GATE	S3C_CLKREG(0x3C)
+#define	S3C_AHB_CON0		S3C_CLKREG(0x100)
+#define	S3C_AHB_CON1		S3C_CLKREG(0x104)
+#define	S3C_AHB_CON2		S3C_CLKREG(0x108)
+#define S3C_SDMA_SEL            S3C_CLKREG(0x110)
+#define S3C_SW_RST		S3C_CLKREG(0x114)
+#define S3C_SYS_ID		S3C_CLKREG(0x118)
+#define S3C_MEM_SYS_CFG		S3C_CLKREG(0x120)
+#define S3C_QOS_OVERRIDE0	S3C_CLKREG(0x124)
+#define S3C_QOS_OVERRIDE1	S3C_CLKREG(0x128)
+#define S3C_MEM_CFG_STAT	S3C_CLKREG(0x12C)
+#define S3C_PWR_CFG		S3C_CLKREG(0x804)
+#define S3C_EINT_MASK		S3C_CLKREG(0x808)
+#define S3C_NORMAL_CFG		S3C_CLKREG(0x810)
+#define S3C_STOP_CFG		S3C_CLKREG(0x814)
+#define S3C_SLEEP_CFG		S3C_CLKREG(0x818)
+#define S3C_OSC_FREQ		S3C_CLKREG(0x820)
+#define S3C_OSC_STABLE		S3C_CLKREG(0x824)
+#define S3C_PWR_STABLE		S3C_CLKREG(0x828)
+#define S3C_FPC_STABLE		S3C_CLKREG(0x82C)
+#define S3C_MTC_STABLE		S3C_CLKREG(0x830)
+#define S3C_OTHERS			S3C_CLKREG(0x900)
+#define S3C_RST_STAT		S3C_CLKREG(0x904)
+#define S3C_WAKEUP_STAT		S3C_CLKREG(0x908)
+#define S3C_BLK_PWR_STAT	S3C_CLKREG(0x90C)
+#define S3C_INFORM0		S3C_CLKREG(0xA00)
+#define S3C_INFORM1		S3C_CLKREG(0xA04)
+#define S3C_INFORM2		S3C_CLKREG(0xA08)
+#define S3C_INFORM3		S3C_CLKREG(0xA0C)
+#define S3C_INFORM4		S3C_CLKREG(0xA10)
+#define S3C_INFORM5		S3C_CLKREG(0xA14)
+#define S3C_INFORM6		S3C_CLKREG(0xA18)
+#define S3C_INFORM7		S3C_CLKREG(0xA1C)
+
+#define S3C64XX_EPLL_CON0_M_SHIFT	16
+#define S3C64XX_EPLL_CON0_P_SHIFT	8
+#define S3C64XX_EPLL_CON0_S_SHIFT	0
+#define S3C64XX_EPLL_CON1_K_SHIFT	0
+
+#define S3C64XX_EPLL_CON0_M_MASK	(0xff<<S3C64XX_EPLL_CON0_M_SHIFT)
+#define S3C64XX_EPLL_CON0_P_MASK	(0x3f<<S3C64XX_EPLL_CON0_P_SHIFT)
+#define S3C64XX_EPLL_CON0_S_MASK	(0x7<<S3C64XX_EPLL_CON0_S_SHIFT)
+#define S3C64XX_EPLL_CON1_K_MASK	(0xffff<<S3C64XX_EPLL_CON1_K_SHIFT)
 
 /* CLKDIV0 */
 #define S3C6400_CLKDIV0_MFC_MASK	(0xf << 28)
@@ -53,6 +97,7 @@
 #define S3C6400_CLKDIV0_ARM_MASK	(0x3 << 0)
 #define S3C6410_CLKDIV0_ARM_MASK	(0x7 << 0)
 #define S3C6400_CLKDIV0_ARM_SHIFT	(0)
+#define S3C6410_CLKDIV0_ARM_SHIFT	(0)
 
 /* CLKDIV1 */
 #define S3C6410_CLKDIV1_FIMC_MASK	(0xf << 24)
@@ -87,6 +132,7 @@
 #define S3C6400_CLKDIV2_SPI0_SHIFT	(0)
 
 /* HCLK GATE Registers */
+#define S3C_CLKCON_HCLK_3DSE	(1<<31)
 #define S3C_CLKCON_HCLK_BUS	(1<<30)
 #define S3C_CLKCON_HCLK_SECUR	(1<<29)
 #define S3C_CLKCON_HCLK_SDMA1	(1<<28)
@@ -181,6 +227,12 @@
 #define S3C_CLKCON_SCLK_CAM		(1<<2)
 #define S3C_CLKCON_SCLK_JPEG		(1<<1)
 
+/*OTHERS Resgister */
+#define S3C_OTHERS_USB_SIG_MASK		(1<<16)
+#define S3C_OTHERS_SYNCMUXSEL_SYNC	(1<<6)
+#define S3C_OTHERS_SYNCMODE_SYNC	(1<<7)
+
+
 /* CLKSRC */
 
 #define S3C6400_CLKSRC_APLL_MOUT	(1 << 0)
@@ -220,5 +272,14 @@
 #define S3C6400_CLKSRC_UHOST_MASK	(0x3 << 5)
 #define S3C6400_CLKSRC_UHOST_SHIFT	(5)
 
+#define S3C6410_CLKSRC2_AUDIO2_MASK	(0x7 << 0)
+#define S3C6410_CLKSRC2_AUDIO2_SHIFT	(0)
+
+/*CLK SRC BITS*/
+#define S3C_CLKSRC_APLL_CLKSEL          (1<<0)
+#define S3C_CLKSRC_MPLL_CLKSEL          (1<<1)
+#define S3C_CLKSRC_EPLL_CLKSEL          (1<<2)
+#define S3C_CLKSRC_UHOST_EPLL           (1<<5)
+#define S3C_CLKSRC_UHOST_MASK           (3<<5)
 
 #endif /* _PLAT_REGS_CLOCK_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/regs-gpio.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/regs-gpio.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/regs-gpio.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/regs-gpio.h	2010-05-06 12:42:45.634864134 +0700
@@ -1,4 +1,4 @@
-/* linux/arch/arm/plat-s3c64xx/include/mach/regs-gpio.h
+/* linux/arch/arm/plat-s3c64xx/include/plat/regs-gpio.h
  *
  * Copyright 2008 Openmoko, Inc.
  * Copyright 2008 Simtec Electronics
@@ -11,6 +11,25 @@
 #ifndef __ASM_PLAT_S3C64XX_REGS_GPIO_H
 #define __ASM_PLAT_S3C64XX_REGS_GPIO_H __FILE__
 
+#include <plat/gpio-bank-a.h>
+#include <plat/gpio-bank-b.h>
+#include <plat/gpio-bank-c.h>
+#include <plat/gpio-bank-d.h>
+#include <plat/gpio-bank-e.h>
+#include <plat/gpio-bank-f.h>
+#include <plat/gpio-bank-g.h>
+#include <plat/gpio-bank-h.h>
+#include <plat/gpio-bank-i.h>
+#include <plat/gpio-bank-j.h>
+#include <plat/gpio-bank-k.h>
+#include <plat/gpio-bank-l.h>
+#include <plat/gpio-bank-n.h>
+#include <plat/gpio-bank-m.h>
+#include <plat/gpio-bank-o.h>
+#include <plat/gpio-bank-p.h>
+#include <plat/gpio-bank-q.h>
+#include <mach/map.h>
+
 /* Base addresses for each of the banks */
 
 #define S3C64XX_GPA_BASE	(S3C64XX_VA_GPIO + 0x0000)
@@ -30,6 +49,56 @@
 #define S3C64XX_GPO_BASE	(S3C64XX_VA_GPIO + 0x0140)
 #define S3C64XX_GPP_BASE	(S3C64XX_VA_GPIO + 0x0160)
 #define S3C64XX_GPQ_BASE	(S3C64XX_VA_GPIO + 0x0180)
+#define S3C64XX_SPC_BASE	(S3C64XX_VA_GPIO + 0x01A0)
+#define S3C64XX_MEM0CONSTOP	(S3C64XX_VA_GPIO + 0x01B0)
+#define S3C64XX_MEM1CONSTOP	(S3C64XX_VA_GPIO + 0x01B4)
+#define S3C64XX_MEM0CONSLP0	(S3C64XX_VA_GPIO + 0x01C0)
+#define S3C64XX_MEM0CONSLP1	(S3C64XX_VA_GPIO + 0x01C4)
+#define S3C64XX_MEM1CONSLP	(S3C64XX_VA_GPIO + 0x01C8)
+#define S3C64XX_MEM0DRVCON	(S3C64XX_VA_GPIO + 0x01D0)
+#define S3C64XX_MEM1DRVCON	(S3C64XX_VA_GPIO + 0x01D4)
+#define S3C64XX_EINT0CON0	(S3C64XX_VA_GPIO + 0x0900)
+#define S3C64XX_EINT0CON1	(S3C64XX_VA_GPIO + 0x0904)
+#define S3C64XX_EINT0FLTCON0	(S3C64XX_VA_GPIO + 0x0910)
+#define S3C64XX_EINT0FLTCON1	(S3C64XX_VA_GPIO + 0x0914)
+#define S3C64XX_EINT0FLTCON2	(S3C64XX_VA_GPIO + 0x0918)
+#define S3C64XX_EINT0FLTCON3	(S3C64XX_VA_GPIO + 0x091C)
+#define S3C64XX_EINT0MASK	(S3C64XX_VA_GPIO + 0x0920)
+#define S3C64XX_EINT0PEND	(S3C64XX_VA_GPIO + 0x0924)
+#define S3C64XX_SPCONSLP	(S3C64XX_VA_GPIO + 0x0880)
+#define S3C64XX_SLPEN		(S3C64XX_VA_GPIO + 0x0930)
+#define S3C64XX_EINT12CON	(S3C64XX_VA_GPIO + 0x0200)
+#define S3C64XX_EINT34CON	(S3C64XX_VA_GPIO + 0x0204)
+#define S3C64XX_EINT56CON	(S3C64XX_VA_GPIO + 0x0208)
+#define S3C64XX_EINT78CON	(S3C64XX_VA_GPIO + 0x020C)
+#define S3C64XX_EINT9CON	(S3C64XX_VA_GPIO + 0x0210)
+#define S3C64XX_EINT12FLTCON	(S3C64XX_VA_GPIO + 0x0220)
+#define S3C64XX_EINT34FLTCON	(S3C64XX_VA_GPIO + 0x0224)
+#define S3C64XX_EINT56FLTCON	(S3C64XX_VA_GPIO + 0x0228)
+#define S3C64XX_EINT78FLTCON	(S3C64XX_VA_GPIO + 0x022C)
+#define S3C64XX_EINT9FLTCON	(S3C64XX_VA_GPIO + 0x0230)
+#define S3C64XX_EINT12MASK	(S3C64XX_VA_GPIO + 0x0240)
+#define S3C64XX_EINT34MASK	(S3C64XX_VA_GPIO + 0x0244)
+#define S3C64XX_EINT56MASK	(S3C64XX_VA_GPIO + 0x0248)
+#define S3C64XX_EINT78MASK	(S3C64XX_VA_GPIO + 0x024C)
+#define S3C64XX_EINT9MASK	(S3C64XX_VA_GPIO + 0x0250)
+#define S3C64XX_EINT12PEND	(S3C64XX_VA_GPIO + 0x0260)
+#define S3C64XX_EINT34PEND	(S3C64XX_VA_GPIO + 0x0264)
+#define S3C64XX_EINT56PEND	(S3C64XX_VA_GPIO + 0x0268)
+#define S3C64XX_EINT78PEND	(S3C64XX_VA_GPIO + 0x026C)
+#define S3C64XX_EINT9PEND	(S3C64XX_VA_GPIO + 0x0270)
+#define S3C64XX_PRIORITY	(S3C64XX_VA_GPIO + 0x0280)
+#define S3C64XX_SERVICE		(S3C64XX_VA_GPIO + 0x0284)
+#define S3C64XX_SERVICEPEND	(S3C64XX_VA_GPIO + 0x0288)
+
+/* values for S3C_EXTINT0 */
+#define S3C64XX_EXTINT_LOWLEV		(0x00)
+#define S3C64XX_EXTINT_HILEV		(0x01)
+#define S3C64XX_EXTINT_FALLEDGE	(0x02)
+#define S3C64XX_EXTINT_RISEEDGE	(0x04)
+#define S3C64XX_EXTINT_BOTHEDGE	(0x06)
 
+#define S3C_PRIORITY		S3C64XX_PRIORITY
+#define S3C64XX_SPCON                  (S3C64XX_SPC_BASE + 0x00)
 #endif /* __ASM_PLAT_S3C64XX_REGS_GPIO_H */
 
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/regs-onenand.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/regs-onenand.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/regs-onenand.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/regs-onenand.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,90 @@
+/* arch/arm/plat-s3c/include/plat/regs-onenand.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+
+#ifndef ___ASM_ARCH_REGS_ONENAND_H
+#define ___ASM_ARCH_REGS_ONENAND_H
+
+#include <plat/map-base.h>
+
+/***************************************************************************/
+/* ONENAND Registers for S3C2443/2450/S3C6400/6410 */
+#define S3C_ONENANDREG(x)	((x) + S3C_VA_ONENAND)
+#define S3C_ONENANDREG2(x)	((x) + (0x80000) + S3C_VA_ONENAND)
+
+#define S3C_MEM_CFG0		S3C_ONENANDREG(0x00)	/* Bank0 Memory Device Configuration Register */
+#define S3C_BURST_LEN0		S3C_ONENANDREG(0x10)	/* Bank0 Burst Length Register */
+#define S3C_MEM_RESET0		S3C_ONENANDREG(0x20)	/* Bank0 Memory Reset Register */
+#define S3C_INT_ERR_STAT0	S3C_ONENANDREG(0x30)	/* Bank0 Interrupt Error Status Register */
+#define S3C_INT_ERR_MASK0	S3C_ONENANDREG(0x40)	/* Bank0 Interrupt Error Mask Register */
+#define S3C_INT_ERR_ACK0	S3C_ONENANDREG(0x50)	/* Bank0 Interrupt Error Acknowledge Register */
+#define S3C_ECC_ERR_STAT0	S3C_ONENANDREG(0x60)	/* Bank0 ECC Error Status Register */
+#define S3C_MANUFACT_ID0	S3C_ONENANDREG(0x70)	/* Bank0 Manufacturer ID Register */
+#define S3C_DEVICE_ID0		S3C_ONENANDREG(0x80)	/* Bank0 Device ID Register */
+#define S3C_DATA_BUF_SIZE0	S3C_ONENANDREG(0x90)	/* Bank0 Data Buffer Size Register */
+#define S3C_BOOT_BUF_SIZE0   	S3C_ONENANDREG(0xA0)	/* Bank0 Boot Buffer Size Register */
+#define S3C_BUF_AMOUNT0      	S3C_ONENANDREG(0xB0)	/* Bank0 Amount of Buffer Register */
+#define S3C_TECH0            	S3C_ONENANDREG(0xC0)	/* Bank0 Technology Register */
+#define S3C_FBA_WIDTH0       	S3C_ONENANDREG(0xD0)	/* Bank0 FBA Width Register */
+#define S3C_FPA_WIDTH0       	S3C_ONENANDREG(0xE0)	/* Bank0 FPA Width Register */
+#define S3C_FSA_WIDTH0       	S3C_ONENANDREG(0xF0)	/* Bank0 FSA Width Register */
+#define S3C_REVISION0        	S3C_ONENANDREG(0x100)	/* Bank0 Revision Register */
+#define S3C_DATARAM00        	S3C_ONENANDREG(0x110)	/* Bank0 DataRAM0 Code Register */
+#define S3C_DATARAM10        	S3C_ONENANDREG(0x120)	/* Bank0 DataRAM1 Code Register */
+#define S3C_SYNC_MODE0       	S3C_ONENANDREG(0x130)	/* Bank0 Synchronous Mode Register */
+#define S3C_TRANS_SPARE0     	S3C_ONENANDREG(0x140)	/* Bank0 Transfer Size Register */
+#define S3C_DBS_DFS_WIDTH0  	S3C_ONENANDREG(0x160)	/* Bank0 DBS_DFS width Register */
+#define S3C_PAGE_CNT0        	S3C_ONENANDREG(0x170)	/* Bank0 Page Count Register */
+#define S3C_ERR_PAGE_ADDR0   	S3C_ONENANDREG(0x180)	/* Bank0 Error Page Address Register */
+#define S3C_BURST_RD_LAT0    	S3C_ONENANDREG(0x190)	/* Bank0 Burst Read Latency Register */
+#define S3C_INT_PIN_ENABLE0  	S3C_ONENANDREG(0x1A0)	/* Bank0 Interrupt Pin Enable Register */
+#define S3C_INT_MON_CYC0     	S3C_ONENANDREG(0x1B0)	/* Bank0 Interrupt Monitor Cycle Count Register */
+#define S3C_ACC_CLOCK0       	S3C_ONENANDREG(0x1C0)	/* Bank0 Access Clock Register */
+#define S3C_SLOW_RD_PATH0    	S3C_ONENANDREG(0x1D0)	/* Bank0 Slow Read Path Register */
+#define S3C_ERR_BLK_ADDR0    	S3C_ONENANDREG(0x1E0)	/* Bank0 Error Block Address Register */
+#define S3C_FLASH_VER_ID0    	S3C_ONENANDREG(0x1F0)	/* Bank0 Flash Version ID Register */
+#define S3C_FLASH_AUX_CNTRL0 	S3C_ONENANDREG(0x300)	/* Bank0 Flash Auxiliary control register */
+#define S3C_FLASH_AFIFO_CNT0 	S3C_ONENANDREG(0x310)	/* Number of data in asynchronous FIFO in flash controller 0. */
+
+#define S3C_MEM_CFG1		S3C_ONENANDREG2(0x00)	/* Bank1 Memory Device Configuration Register */
+#define S3C_BURST_LEN1		S3C_ONENANDREG2(0x10)	/* Bank1 Burst Length Register */
+#define S3C_MEM_RESET1		S3C_ONENANDREG2(0x20)	/* Bank1 Memory Reset Register */
+#define S3C_INT_ERR_STAT1	S3C_ONENANDREG2(0x30)	/* Bank1 Interrupt Error Status Register */
+#define S3C_INT_ERR_MASK1	S3C_ONENANDREG2(0x40)	/* Bank1 Interrupt Error Mask Register */
+#define S3C_INT_ERR_ACK1	S3C_ONENANDREG2(0x50)	/* Bank1 Interrupt Error Acknowledge Register */
+#define S3C_ECC_ERR_STAT1	S3C_ONENANDREG2(0x60)	/* Bank1 ECC Error Status Register */
+#define S3C_MANUFACT_ID1	S3C_ONENANDREG2(0x70)	/* Bank1 Manufacturer ID Register */
+#define S3C_DEVICE_ID1		S3C_ONENANDREG2(0x80)	/* Bank1 Device ID Register */
+#define S3C_DATA_BUF_SIZE1	S3C_ONENANDREG2(0x90)	/* Bank1 Data Buffer Size Register */
+#define S3C_BOOT_BUF_SIZE1   	S3C_ONENANDREG2(0xA0)	/* Bank1 Boot Buffer Size Register */
+#define S3C_BUF_AMOUNT1      	S3C_ONENANDREG2(0xB0)	/* Bank1 Amount of Buffer Register */
+#define S3C_TECH1            	S3C_ONENANDREG2(0xC0)	/* Bank1 Technology Register */
+#define S3C_FBA_WIDTH1       	S3C_ONENANDREG2(0xD0)	/* Bank1 FBA Width Register */
+#define S3C_FPA_WIDTH1       	S3C_ONENANDREG2(0xE0)	/* Bank1 FPA Width Register */
+#define S3C_FSA_WIDTH1       	S3C_ONENANDREG2(0xF0)	/* Bank1 FSA Width Register */
+#define S3C_REVISION1        	S3C_ONENANDREG2(0x100)	/* Bank1 Revision Register */
+#define S3C_DATARAM01        	S3C_ONENANDREG2(0x110)	/* Bank1 DataRAM0 Code Register */
+#define S3C_DATARAM11        	S3C_ONENANDREG2(0x120)	/* Bank1 DataRAM1 Code Register */
+#define S3C_SYNC_MODE1       	S3C_ONENANDREG2(0x130)	/* Bank1 Synchronous Mode Register */
+#define S3C_TRANS_SPARE1     	S3C_ONENANDREG2(0x140)	/* Bank1 Transfer Size Register */
+#define S3C_DBS_DFS_WIDTH1  	S3C_ONENANDREG2(0x160)	/* Bank1 DBS_DFS width Register */
+#define S3C_PAGE_CNT1        	S3C_ONENANDREG2(0x170)	/* Bank1 Page Count Register */
+#define S3C_ERR_PAGE_ADDR1   	S3C_ONENANDREG2(0x180)	/* Bank1 Error Page Address Register */
+#define S3C_BURST_RD_LAT1    	S3C_ONENANDREG2(0x190)	/* Bank1 Burst Read Latency Register */
+#define S3C_INT_PIN_ENABLE1  	S3C_ONENANDREG2(0x1A0)	/* Bank1 Interrupt Pin Enable Register */
+#define S3C_INT_MON_CYC1     	S3C_ONENANDREG2(0x1B0)	/* Bank1 Interrupt Monitor Cycle Count Register */
+#define S3C_ACC_CLOCK1       	S3C_ONENANDREG2(0x1C0)	/* Bank1 Access Clock Register */
+#define S3C_SLOW_RD_PATH1    	S3C_ONENANDREG2(0x1D0)	/* Bank1 Slow Read Path Register */
+#define S3C_ERR_BLK_ADDR1    	S3C_ONENANDREG2(0x1E0)	/* Bank1 Error Block Address Register */
+#define S3C_FLASH_VER_ID1    	S3C_ONENANDREG2(0x1F0)	/* Bank1 Flash Version ID Register */
+#define S3C_FLASH_AUX_CNTRL1 	S3C_ONENANDREG2(0x300)	/* Bank1 Flash Auxiliary control register */
+#define S3C_FLASH_AFIFO_CNT1 	S3C_ONENANDREG2(0x310)	/* Number of data in asynchronous FIFO in flash controller 1. */
+
+#endif /*  __ASM_ARCH_REGS_ONENAND_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/regs-spi.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/regs-spi.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/regs-spi.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/regs-spi.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,276 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-spi.h
+ *
+ * Copyright (c) 2004 Fetron GmbH
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 SPI register definition
+*/
+
+#ifndef __ASM_ARCH_REGS_SPI_H
+#define __ASM_ARCH_REGS_SPI_H
+
+struct s3c6410_spi_info {
+    unsigned long        	board_size;
+	struct spi_board_info   *board_info;
+};
+
+#define S3C2410_SPCON	(0x00)
+
+#define S3C2410_SPCON_SMOD_DMA	  (2<<5)	/* DMA mode */
+#define S3C2410_SPCON_SMOD_INT	  (1<<5)	/* interrupt mode */
+#define S3C2410_SPCON_SMOD_POLL   (0<<5)	/* polling mode */
+#define S3C2410_SPCON_ENSCK	  (1<<4)	/* Enable SCK */
+#define S3C2410_SPCON_MSTR	  (1<<3)	/* Master/Slave select 0: slave, 1: master */
+#define S3C2410_SPCON_CPOL_HIGH	  (1<<2)	/* Clock polarity select */
+#define S3C2410_SPCON_CPOL_LOW	  (0<<2)	/* Clock polarity select */
+
+#define S3C2410_SPCON_CPHA_FMTB	  (1<<1)	/* Clock Phase Select */
+#define S3C2410_SPCON_CPHA_FMTA	  (0<<1)	/* Clock Phase Select */
+
+#define S3C2410_SPCON_TAGD	  (1<<0)	/* Tx auto garbage data mode */
+
+
+#define S3C2410_SPSTA	 (0x04)
+
+#define S3C2410_SPSTA_DCOL	  (1<<2)	/* Data Collision Error */
+#define S3C2410_SPSTA_MULD	  (1<<1)	/* Multi Master Error */
+#define S3C2410_SPSTA_READY	  (1<<0)	/* Data Tx/Rx ready */
+
+
+#define S3C2410_SPPIN	 (0x08)
+
+#define S3C2410_SPPIN_ENMUL	  (1<<2)	/* Multi Master Error detect */
+#define S3C2410_SPPIN_RESERVED	  (1<<1)
+#define S3C2400_SPPIN_nCS     	  (1<<1)	/* SPI Card Select */
+#define S3C2410_SPPIN_KEEP	  (1<<0)	/* Master Out keep */
+
+
+#define S3C2410_SPPRE	 (0x0C)
+#define S3C2410_SPTDAT	 (0x10)
+#define S3C2410_SPRDAT	 (0x14)
+
+#if defined (CONFIG_CPU_S3C6400) || defined (CONFIG_CPU_S3C6410)
+/*
+ * SPI(High speed) Registers
+ */
+
+#define S3C_SPI_REG_CH0(x)	((x) + S3C_VA_SPI0)
+#define S3C_SPI_REG_CH1(x)	((x) + S3C_VA_SPI1)
+
+#define S3C_CH_CFG		(0x00)      //SPI configuration
+#define S3C_CLK_CFG		(0x04)      //Clock configuration
+#define S3C_MODE_CFG		(0x08)      //SPI FIFO control
+#define S3C_SLAVE_SEL		(0x0C)      //Slave selection
+#define S3C_SPI_INT_EN		(0x10)      //SPI interrupt enable
+#define S3C_SPI_STATUS		(0x14)      //SPI status
+#define S3C_SPI_TX_DATA		(0x18)      //SPI TX data
+#define S3C_SPI_RX_DATA		(0x1C)      //SPI RX data
+#define S3C_PACKET_CNT		(0x20)      //count how many data master gets
+#define S3C_PENDING_CLR		(0x24)      //Pending clear
+#define S3C_SWAP_CFG		(0x28)      //SWAP config register
+#define S3C_FB_CLK		(0x28)      //SWAP FB config register
+
+#define SPI_CH_HSPD_EN      (1<<6)
+#define SPI_CH_SW_RST		(1<<5)
+#define SPI_CH_MASTER		(0<<4)
+#define SPI_CH_SLAVE		(1<<4)
+#define SPI_CH_RISING		(0<<3)
+#define SPI_CH_FALLING		(1<<3)
+#define SPI_CH_FORMAT_A		(0<<2)
+#define SPI_CH_FORMAT_B		(1<<2)
+#define SPI_CH_RXCH_OFF		(0<<1)
+#define SPI_CH_RXCH_ON		(1<<1)
+#define SPI_CH_TXCH_OFF		(0<<0)
+#define SPI_CH_TXCH_ON		(1<<0)
+
+#define SPI_CLKSEL_PCLK		(0<<9)
+#define SPI_CLKSEL_USBCLK	(1<<9)
+#define SPI_CLKSEL_ECLK		(2<<9)
+#define SPI_ENCLK_DISABLE	(0<<8)
+#define SPI_ENCLK_ENABLE	(1<<8)
+
+#define SPI_MODE_CH_TSZ_BYTE	(0<<29)
+#define SPI_MODE_CH_TSZ_HALFWORD	(1<<29)
+#define SPI_MODE_CH_TSZ_WORD	(2<<29)
+#define SPI_MODE_BUS_TSZ_BYTE	(0<<17)
+#define SPI_MODE_BUS_TSZ_HALFWORD	(1<<17)
+#define SPI_MODE_BUS_TSZ_WORD	(2<<17)
+#define SPI_MODE_RXDMA_OFF	(0<<2)
+#define SPI_MODE_RXDMA_ON	(1<<2)
+#define SPI_MODE_TXDMA_OFF	(0<<1)
+#define SPI_MODE_TXDMA_ON	(1<<1)
+#define SPI_MODE_SINGLE		(0<<0)
+#define SPI_MODE_4BURST		(1<<0)
+
+#define SPI_SLAVE_MAN		(0<<1)
+#define SPI_SLAVE_AUTO		(1<<1)
+#define SPI_SLAVE_SIG_ACT	(0<<0)
+#define SPI_SLAVE_SIG_INACT	(1<<0)
+
+#define SPI_INT_TRAILING_DIS	(0<<6)
+#define SPI_INT_TRAILING_EN	(1<<6)
+#define SPI_INT_RX_OVERRUN_DIS	(0<<5)
+#define SPI_INT_RX_OVERRUN_EN	(1<<5)
+#define SPI_INT_RX_UNDERRUN_DIS	(0<<4)
+#define SPI_INT_RX_UNDERRUN_EN	(1<<4)
+#define SPI_INT_TX_OVERRUN_DIS	(0<<3)
+#define SPI_INT_TX_OVERRUN_EN	(1<<3)
+#define SPI_INT_TX_UNDERRUN_DIS	(0<<2)
+#define SPI_INT_TX_UNDERRUN_EN	(1<<2)
+#define SPI_INT_RX_FIFORDY_DIS	(0<<1)
+#define SPI_INT_RX_FIFORDY_EN	(1<<1)
+#define SPI_INT_TX_FIFORDY_DIS	(0<<0)
+#define SPI_INT_TX_FIFORDY_EN	(1<<0)
+#define SPI_INT_ALL_DISABLE		(0)
+
+#define SPI_STUS_TX_DONE	(1<<21)
+#define SPI_STUS_TRAILCNT_ZERO	(1<<20)
+#define SPI_STUS_RX_FIFOLVL	(0x7f << 13)
+#define SPI_STUS_TX_FIFOLVL	(0x7f << 6)
+#define SPI_STUS_RX_OVERRUN_ERR	(1<<5)
+#define SPI_STUS_RX_UNDERRUN_ERR	(1<<4)
+#define SPI_STUS_TX_OVERRUN_ERR	(1<<3)
+#define SPI_STUS_TX_UNDERRUN_ERR	(1<<2)
+#define SPI_STUS_RX_FIFORDY	(1<<1)
+#define SPI_STUS_TX_FIFORDY	(1<<0)
+
+
+#define SPI_PACKET_CNT_DIS	(0<<16)
+#define SPI_PACKET_CNT_EN	(1<<16)
+
+#define SPI_PND_TX_UNDERRUN_CLR	(1<<4)
+#define SPI_PND_TX_OVERRUN_CLR	(1<<3)
+#define SPI_PND_RX_UNDERRUN_CLR	(1<<2)
+#define SPI_PND_RX_OVERRUN_CLR	(1<<1)
+#define SPI_PND_TRAILING_CLR	(1<<0)
+
+#define SPI_SWAP_RX_HALF_WORD	(1<<7)
+#define SPI_SWAP_RX_BYTE	(1<<6)
+#define SPI_SWAP_RX_BIT		(1<<5)
+#define SPI_SWAP_RX_EN		(1<<4)
+#define SPI_SWAP_TX_HALF_WORD	(1<<3)
+#define SPI_SWAP_TX_BYTE	(1<<2)
+#define SPI_SWAP_TX_BIT		(1<<1)
+#define SPI_SWAP_TX_EN		(1<<0)
+
+#define SPI_FBCLK_0NS		(0<<0)
+#define SPI_FBCLK_2NS		(1<<4)
+#define SPI_FBCLK_4NS		(2<<4)
+#define SPI_FBCLK_6NS		(3<<4)
+
+#endif
+
+#if defined (CONFIG_CPU_S3C2450) || defined (CONFIG_CPU_S3C2416)
+/*
+ * SPI(High speed) Registers
+ */
+#define S3C_SPI_REG_CH0(x)	((x) + S3C_VA_SPI0)
+#define S3C_SPI_REG_CH1(x)	((x) + S3C_VA_SPI1)
+
+#define S3C_CH_CFG		(0x00)      //SPI configuration
+#define S3C_CLK_CFG		(0x04)      //Clock configuration
+#define S3C_MODE_CFG		(0x08)      //SPI FIFO control
+#define S3C_SLAVE_SEL		(0x0C)      //Slave selection
+#define S3C_SPI_INT_EN		(0x10)      //SPI interrupt enable
+#define S3C_SPI_STATUS		(0x14)      //SPI status
+#define S3C_SPI_TX_DATA		(0x18)      //SPI TX data
+#define S3C_SPI_RX_DATA		(0x1C)      //SPI RX data
+#define S3C_PACKET_CNT		(0x20)      //count how many data master gets
+#define S3C_PENDING_CLR		(0x24)      //Pending clear
+#define S3C_SWAP_CFG		(0x28)      //SWAP config register
+#define S3C_FB_CLK		(0x28)      //SWAP FB config register
+
+
+#define SPI_CH_SW_RST		(1<<5)
+#define SPI_CH_MASTER		(0<<4)
+#define SPI_CH_SLAVE		(1<<4)
+#define SPI_CH_RISING		(0<<3)
+#define SPI_CH_FALLING		(1<<3)
+#define SPI_CH_FORMAT_A		(0<<2)
+#define SPI_CH_FORMAT_B		(1<<2)
+#define SPI_CH_RXCH_OFF		(0<<1)
+#define SPI_CH_RXCH_ON		(1<<1)
+#define SPI_CH_TXCH_OFF		(0<<0)
+#define SPI_CH_TXCH_ON		(1<<0)
+
+#define SPI_CLKSEL_PCLK		(0<<9)
+#define SPI_CLKSEL_USBCLK	(1<<9)
+#define SPI_CLKSEL_ECLK		(2<<9)
+#define SPI_ENCLK_DISABLE	(0<<8)
+#define SPI_ENCLK_ENABLE	(1<<8)
+
+#define SPI_MODE_CH_TSZ_BYTE	(0<<18)
+#define SPI_MODE_CH_TSZ_HALFWORD	(1<<29)
+#define SPI_MODE_CH_TSZ_WORD	(2<<18)
+#define SPI_MODE_BUS_TSZ_BYTE	(0<<17)
+#define SPI_MODE_BUS_TSZ_HALFWORD	(1<<17)
+#define SPI_MODE_BUS_TSZ_WORD	(2<<17)
+#define SPI_MODE_RXDMA_OFF	(0<<2)
+#define SPI_MODE_RXDMA_ON	(1<<2)
+#define SPI_MODE_TXDMA_OFF	(0<<1)
+#define SPI_MODE_TXDMA_ON	(1<<1)
+#define SPI_MODE_SINGLE		(0<<0)
+#define SPI_MODE_4BURST		(1<<0)
+
+#define SPI_SLAVE_MAN		(0<<1)
+#define SPI_SLAVE_AUTO		(1<<1)
+#define SPI_SLAVE_SIG_ACT	(0<<0)
+#define SPI_SLAVE_SIG_INACT	(1<<0)
+
+#define SPI_INT_TRAILING_DIS	(0<<6)
+#define SPI_INT_TRAILING_EN	(1<<6)
+#define SPI_INT_RX_OVERRUN_DIS	(0<<5)
+#define SPI_INT_RX_OVERRUN_EN	(1<<5)
+#define SPI_INT_RX_UNDERRUN_DIS	(0<<4)
+#define SPI_INT_RX_UNDERRUN_EN	(1<<4)
+#define SPI_INT_TX_OVERRUN_DIS	(0<<3)
+#define SPI_INT_TX_OVERRUN_EN	(1<<3)
+#define SPI_INT_TX_UNDERRUN_DIS	(0<<2)
+#define SPI_INT_TX_UNDERRUN_EN	(1<<2)
+#define SPI_INT_RX_FIFORDY_DIS	(0<<1)
+#define SPI_INT_RX_FIFORDY_EN	(1<<1)
+#define SPI_INT_TX_FIFORDY_DIS	(0<<0)
+#define SPI_INT_TX_FIFORDY_EN	(1<<0)
+
+#define SPI_STUS_TX_DONE	(1<<21)
+#define SPI_STUS_TRAILCNT_ZERO	(1<<20)
+#define SPI_STUS_RX_FIFOLVL	(0x7f << 13)
+#define SPI_STUS_TX_FIFOLVL	(0x7f << 6)
+#define SPI_STUS_RX_OVERRUN_ERR	(1<<5)
+#define SPI_STUS_RX_UNDERRUN_ERR	(1<<4)
+#define SPI_STUS_TX_OVERRUN_ERR	(1<<3)
+#define SPI_STUS_TX_UNDERRUN_ERR	(1<<2)
+#define SPI_STUS_RX_FIFORDY	(1<<1)
+#define SPI_STUS_TX_FIFORDY	(1<<0)
+
+#define SPI_PACKET_CNT_DIS	(0<<16)
+#define SPI_PACKET_CNT_EN	(1<<16)
+
+#define SPI_PND_TX_UNDERRUN_CLR	(1<<4)
+#define SPI_PND_TX_OVERRUN_CLR	(1<<3)
+#define SPI_PND_RX_UNDERRUN_CLR	(1<<2)
+#define SPI_PND_RX_OVERRUN_CLR	(1<<1)
+#define SPI_PND_TRAILING_CLR	(1<<0)
+
+#define SPI_SWAP_RX_HALF_WORD	(1<<7)
+#define SPI_SWAP_RX_BYTE	(1<<6)
+#define SPI_SWAP_RX_BIT		(1<<5)
+#define SPI_SWAP_RX_EN		(1<<4)
+#define SPI_SWAP_TX_HALF_WORD	(1<<3)
+#define SPI_SWAP_TX_BYTE	(1<<2)
+#define SPI_SWAP_TX_BIT		(1<<1)
+#define SPI_SWAP_TX_EN		(1<<0)
+
+#define SPI_FBCLK_0NS		(0<<0)
+#define SPI_FBCLK_2NS		(1<<4)
+#define SPI_FBCLK_4NS		(2<<4)
+#define SPI_FBCLK_6NS		(3<<4)
+
+#endif
+
+
+#endif /* __ASM_ARCH_REGS_SPI_H */
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/reserved_mem.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/reserved_mem.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/reserved_mem.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/reserved_mem.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,97 @@
+#ifndef _ASM_ARM_ARCH_RESERVED_MEM_H
+#define _ASM_ARM_ARCH_RESERVED_MEM_H
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <asm/setup.h>
+
+#define DRAM_END_ADDR 				(PHYS_OFFSET + PHYS_SIZE)
+
+#ifdef CONFIG_SEC_LOG_BUF
+
+#define SEC_LOG_BUF_DATA_SIZE		(1 << CONFIG_LOG_BUF_SHIFT)		
+
+#define SEC_LOG_BUF_FLAG_SIZE		(4 * 1024)		
+
+#define SEC_LOG_BUF_SIZE			(SEC_LOG_BUF_FLAG_SIZE + SEC_LOG_BUF_DATA_SIZE)
+
+#define SEC_LOG_BUF_START			(DRAM_END_ADDR - SEC_LOG_BUF_SIZE)
+
+#define SEC_LOG_BUF_MAGIC			0x404C4F47	/* @LOG */
+
+struct sec_log_buf {
+	unsigned int *flag;	
+	unsigned int *count;
+	char *data;
+};
+
+#define RESERVED_PMEM_END_ADDR 		(DRAM_END_ADDR - (1 * 1024 * 1024))		/* Reserved 1MB for Frame & Log Buffer */
+
+extern void sec_log_buf_init(void);
+
+#else
+
+#define RESERVED_PMEM_END_ADDR 		(DRAM_END_ADDR)
+
+#endif
+
+#define RESERVED_MEM_CMM		(3 * 1024 * 1024)
+#define RESERVED_MEM_MFC		(6 * 1024 * 1024)
+#define RESERVED_PMEM_PICTURE		(6 * 1024 * 1024)	/* PMEM_PIC and MFC use share area */
+#define RESERVED_PMEM_JPEG		(3 * 1024 * 1024)
+#define RESERVED_PMEM_PREVIEW		(2 * 1024 * 1024)
+#define RESERVED_PMEM_RENDER	  	(2 * 1024 * 1024)
+#define RESERVED_PMEM_STREAM	  	(2 * 1024 * 1024)
+#define RESERVED_G3D			(32 * 1024 * 1024) 	/* G3D is shared with uppper memory areas */
+#define RESERVED_PMEM_GPU1		(0)
+#define RESERVED_PMEM			(8 * 1024 * 1024)
+#define RESERVED_PMEM_SKIA		(0)
+
+#define RESERVED_G3D_UI			(6 * 1024 * 1024)
+#define RESERVED_G3D_SHARED		(RESERVED_MEM_CMM + RESERVED_MEM_MFC + RESERVED_PMEM_STREAM + RESERVED_PMEM_JPEG + RESERVED_PMEM_PREVIEW + RESERVED_PMEM_RENDER)
+#define RESERVED_G3D_APP		(RESERVED_G3D - RESERVED_G3D_UI - RESERVED_G3D_SHARED)
+
+#if defined(CONFIG_RESERVED_MEM_CMM_JPEG_MFC_POST_CAMERA)
+#define CMM_RESERVED_MEM_START		(RESERVED_PMEM_END_ADDR - RESERVED_MEM_CMM)
+#define MFC_RESERVED_MEM_START		(CMM_RESERVED_MEM_START - RESERVED_MEM_MFC)
+#define PICTURE_RESERVED_PMEM_START	(MFC_RESERVED_MEM_START)
+#define JPEG_RESERVED_PMEM_START	(MFC_RESERVED_MEM_START - RESERVED_PMEM_JPEG)
+#define PREVIEW_RESERVED_PMEM_START	(JPEG_RESERVED_PMEM_START - RESERVED_PMEM_PREVIEW)
+#define RENDER_RESERVED_PMEM_START	(PREVIEW_RESERVED_PMEM_START - RESERVED_PMEM_RENDER)
+#define STREAM_RESERVED_PMEM_START	(RENDER_RESERVED_PMEM_START - RESERVED_PMEM_STREAM)
+#define G3D_RESERVED_START		(RESERVED_PMEM_END_ADDR - RESERVED_G3D)		 /* G3D is shared */
+#define GPU1_RESERVED_PMEM_START	(G3D_RESERVED_START - RESERVED_PMEM_GPU1)
+#define RESERVED_PMEM_START		(GPU1_RESERVED_PMEM_START - RESERVED_PMEM)
+#define PHYS_UNRESERVED_SIZE		(RESERVED_PMEM_START - PHYS_OFFSET)
+
+#define SKIA_RESERVED_PMEM_START	(0)
+#else
+#define PHYS_UNRESERVED_SIZE		(RESERVED_PMEM_END_ADDR - PHYS_OFFSET)
+
+#endif 
+
+struct s3c6410_pmem_setting{
+        resource_size_t pmem_start;
+        resource_size_t pmem_size;
+        resource_size_t pmem_gpu1_start;
+        resource_size_t pmem_gpu1_size;
+        resource_size_t pmem_render_start;
+        resource_size_t pmem_render_size;
+        resource_size_t pmem_render_pic_start;
+        resource_size_t pmem_render_pic_size;
+        resource_size_t pmem_stream_start;
+        resource_size_t pmem_stream_size;
+        resource_size_t pmem_preview_start;
+        resource_size_t pmem_preview_size;
+        resource_size_t pmem_picture_start;
+        resource_size_t pmem_picture_size;
+        resource_size_t pmem_jpeg_start;
+        resource_size_t pmem_jpeg_size;
+        resource_size_t pmem_skia_start;
+        resource_size_t pmem_skia_size;
+};
+ 
+void s3c6410_add_mem_devices (struct s3c6410_pmem_setting *setting);
+
+#endif /* _ASM_ARM_ARCH_RESERVED_MEM_H */
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/s3c6400.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/s3c6400.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/s3c6400.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/s3c6400.h	2010-05-06 12:42:45.634864134 +0700
@@ -14,9 +14,9 @@
 
 /* Common init code for S3C6400 related SoCs */
 
-extern void s3c6400_common_init_uarts(struct s3c2410_uartcfg *cfg, int no);
-extern void s3c6400_register_clocks(void);
-extern void s3c6400_setup_clocks(void);
+extern void s3c64xx_common_init_uarts(struct s3c_uartcfg *cfg, int no);
+extern void s3c6410_register_clocks(void);
+extern void s3c64xx_setup_clocks(void);
 
 #ifdef CONFIG_CPU_S3C6400
 
@@ -24,7 +24,7 @@
 extern void s3c6400_map_io(void);
 extern void s3c6400_init_clocks(int xtal);
 
-#define s3c6400_init_uarts s3c6400_common_init_uarts
+#define s3c6400_init_uarts s3c64xx_common_init_uarts
 
 #else
 #define s3c6400_init_clocks NULL
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/s3c6410-dma.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/s3c6410-dma.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/s3c6410-dma.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/s3c6410-dma.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,317 @@
+/*
+ *  linux/include/asm-arm/arch-s3c6410/dma.h
+ *
+ *  Copyright (C) 2007 Samsung Electronics TLD.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * 
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/kobject.h>
+#include <linux/spinlock.h>
+
+/************************************************************************************
+ * DMA Controller Number for S3C6410
+ ***********************************************************************************/
+#define DMAC_NR				4
+/***********************************************************************************************/
+/*		Etc Informations										                               */
+/***********************************************************************************************/
+#define MAX_DMA_CHANNELS    8       		/* Max channels of DMAC */
+#define DMA_DEFAULT    		2				/* DMA status for active */				
+#define DMA_USED        	1
+#define DMA_NOUSED      	0
+/***********************************************************************************************/
+/*		Registers Offset										                               */
+/***********************************************************************************************/
+#define	DMACINTSTAT			0x00				/* Interrupt status register */
+#define	DMACINTTCSTAT		0x04				/* Interrupt terminal count status register */
+#define	DMACINTTCCLR		0x08				/* Interrupt terminal count clear register */
+#define	DMACINTERRSTAT		0x0C				/* Interrupt error status register */
+#define	DMACINTERRCLR		0x10				/* Interrupt error clear register */
+#define	DMACRAWINTTCSTAT	0x14				/* RAW Interrupt TC status register */
+#define	DMACRAWINTERRSTAT	0x18				/* RAW Interrupt error clear register */
+#define	DMACENBLDCHAN		0x1C				/* Enabled channel status register */
+#define	DMACSOFTBREQ		0x20				/* Software Burst Request register */
+#define	DMACSOFTSREQ		0x24				/* Software Single Request register */
+#define	DMACSOFTLBREQ		0x28				/* Software Last Burst Request register */ /
+#define	DMACSOFTLSREQ		0x2C				/* Software Last Single Request register */
+#define	DMACCFG				0x30				/* Configuration register */ 
+#define	DMACSYNC			0x34				/* Syncronization register */
+#define DMACCxSRCADDR(x)	0x100 + ((x) << 5)	/* Channel Source Address Register */
+#define DMACCxDSTADDR(x)	0x104 + ((x) << 5)	/* Channel Destination Address Register */
+#define DMACCxLLI(x)		0x108 + ((x) << 5)	/* Channel LLI Register */
+#define DMACCxCTL0(x)		0x10C + ((x) << 5)	/* Channel Control Register 0 */
+#define DMACCxCTL1(x)		0x110 + ((x) << 5)	/* Channel Control Register 1 */
+#define DMACCxCFG(x)		0x114 + ((x) << 5)	/* Channel Configuration Register */
+
+/***********************************************************************************************/
+/*		DMACINTSTAT : Status of the DMA interrupts after masking(R/O, [7:0])                   */
+/***********************************************************************************************/
+#define	INT_STAT_CH(x)			(0x1 << x)			
+
+/***********************************************************************************************/
+/*		DMACINTTCSTAT : Interrupt terminal count request status(R/O, [7:0])					   */
+/***********************************************************************************************/
+#define	INTTC_STAT_CH(x)		(0x1 << x)		
+
+/***********************************************************************************************/
+/*		DMACINTTCCLR : Terminal count request clear(W/O, [7:0])								   */
+/***********************************************************************************************/
+#define	INTTC_CLR_CH(x)			(0x1 << x)	
+
+/***********************************************************************************************/
+/*		DMACINTERRSTAT : Interrupt error status(R/O, [7:0])						    	       */
+/***********************************************************************************************/
+#define	ERR_INT_STAT_CH(x)		(0x1 << x)	
+
+/***********************************************************************************************/
+/*		DMACINTERRCLR : Interrupt error clear(W/O, [7:0])                   				   */
+/***********************************************************************************************/
+#define	ERR_INT_CLR_CH(x)		(0x1 << x)	
+
+/***********************************************************************************************/
+/*		DMACRAWINTTCSTAT : Status of the terminal count interrupt prior to masking(R/O, [7:0]) */
+/***********************************************************************************************/
+#define	RAW_INTTC_STAT_CH(x)	(0x1 << x)	
+
+/***********************************************************************************************/
+/*		DMACRAWINTERRSTAT : Status of the error interrupt prior to masking(R/O, [7:0])         */
+/***********************************************************************************************/
+#define	RAW_ERR_INT_STAT_CH(x)	(0x1 << x)
+
+/***********************************************************************************************/
+/*		DMACENBLDCHAN : Channel enable status(R/O, [7:0])	        	                       */
+/***********************************************************************************************/
+#define	ENABLE_STAT_CH(x)		(0x1 << x)	
+
+/***********************************************************************************************/
+/*		DMACSOFTBREQ : Software burst request for each device connections                      */
+/*					   (R/W, [15:0]) x is connection number.								   */
+/***********************************************************************************************/
+#define	Soft_BREQ(x)			(0x1 << x)
+
+/***********************************************************************************************/
+/*		DMACSOFTSREQ : Software single request for each device connections                     */
+/*					   (R/W, [15:0]) x is connection number.								   */
+/***********************************************************************************************/
+#define	Soft_SREQ(x)			(0x1 << x)
+
+/***********************************************************************************************/
+/*		DMACSOFTLBREQ : Software last burst reqeust for each device connections                */
+/*					    (R/W, [15:0]) x is connection number.								   */
+/***********************************************************************************************/
+#define	Soft_LBREQ(x)			(0x1 << x)
+
+/***********************************************************************************************/
+/*		DMACSOFTLSREQ : Software last single reqeust for each device connections               */
+/*					    (R/W, [15:0]) x is connection number.								   */
+/***********************************************************************************************/
+#define	Soft_LSREQ(x)			(0x1 << x)	
+
+/***********************************************************************************************/
+/*		DMACCFG : DMAC Configuration register 					                               */
+/***********************************************************************************************/
+#define	DMAC_ENABLE				(0x1 << 0) 	  
+#define DMAC_DISABLE		   ~(DMAC_ENABLE) /* DMAC enable: 
+											  0 = disabled
+											  1 = enabled.
+											  This bit is reset to 0.
+											  Disabling the DMAC reduces power consumption mode */
+
+#define M1_ENDIAN				(0x1 << 1) /* AHB Master 1 endianness configuration for PL080
+											  0 = little-endian mode
+											  1 = big-endian mode.
+											  This bit is reset to 0.							*/
+
+#define M2_ENDIAN				(0x1 << 2) /* AHB Master 2 endianness configuration for PL080
+											  0 = little-endian mode
+											  1 = big-endian mode.
+											  This bit is reset to 0.							*/
+
+/***********************************************************************************************/
+/*		DMACSYNC : Synchronization Register								                       */
+/***********************************************************************************************/
+#define	DMAC_SYNC(x)			(0x1 << x)	/* DMA synchronization logic for DMA request 
+											   signals enabled or disabled. A LOW bit indicates 
+											   that the synchronization logic for the request 
+											   signals is enabled. A HIGH bit indicates that 
+											   the synchronization logic is disabled. 		   */	
+
+/***********************************************************************************************/
+/*		DMACCxLLI(x) : Channel Linked List Item Register				                       */
+/***********************************************************************************************/
+#define SELECT_MASTER1_LLI		(0x0 << 0) /* AHB Master1 select for Next LLI				   */
+#define SELECT_MASTER2_LLI		(0x1 << 0) /* AHB Master2 select for Next LLI				   */
+#define NONE_LLI				(0x0)
+/***********************************************************************************************/
+/*		DMACCxCTL0(x) : Channel Control Register										                               */
+/***********************************************************************************************/
+#define SRC_BSIZE_1		(0x0 << 12)			/* Source Burst size = 1byte */
+#define SRC_BSIZE_4		(0x1 << 12)			/* Source Burst size = 4byte */
+#define SRC_BSIZE_8		(0x2 << 12)			/* Source Burst size = 8byte */
+#define SRC_BSIZE_16	(0x3 << 12)			/* Source Burst size = 16byte */
+#define SRC_BSIZE_32	(0x4 << 12)			/* Source Burst size = 32byte */
+#define SRC_BSIZE_64	(0x5 << 12)			/* Source Burst size = 64byte */
+#define SRC_BSIZE_128	(0x6 << 12)			/* Source Burst size = 128byte */
+#define SRC_BSIZE_256	(0x7 << 12)			/* Source Burst size = 256byte */
+#define DST_BSIZE_1		(0x0 << 15)			/* Destination Burst size = 1byte */
+#define DST_BSIZE_4		(0x1 << 15)			/* Destination Burst size = 4byte */
+#define DST_BSIZE_8		(0x2 << 15)			/* Destination Burst size = 8byte */
+#define DST_BSIZE_16	(0x3 << 15)			/* Destination Burst size = 16byte */
+#define DST_BSIZE_32	(0x4 << 15)			/* Destination Burst size = 32byte */
+#define DST_BSIZE_64	(0x5 << 15)			/* Destination Burst size = 64byte */
+#define DST_BSIZE_128	(0x6 << 15)			/* Destination Burst size = 128byte */
+#define DST_BSIZE_256	(0x7 << 15)			/* Destination Burst size = 256byte */
+#define SRC_TWIDTH_8	(0x0 << 18)			/* 8 bit */
+#define SRC_TWIDTH_16	(0x1 << 18)			/* 16 bit */
+#define SRC_TWIDTH_32	(0x2 << 18)			/* 32 bit */
+#define DST_TWIDTH_8	(0x0 << 21)			/* 8 bit */
+#define DST_TWIDTH_16	(0x1 << 21)			/* 16 bit */
+#define DST_TWIDTH_32	(0x2 << 21)			/* 32 bit */
+#define SRC_AHB_SYSTEM	(0x0 << 24)			/* Source      AHB master select(0 : AXI_SYSTEM) */
+#define SRC_AHB_PERI	(0x1 << 24)			/* Source      AHB master select(1 : AXI_PERI)   */
+#define DST_AHB_SYSTEM	(0x0 << 25)			/* Destination AHB master select(0 : AXI_SYSTEM) */
+#define DST_AHB_PERI	(0x1 << 25)			/* Destination AHB master select(1 : AXI_PERI)   */
+#define SRC_INC			(0x1 << 26)			/* Source address increment after transfer */
+#define DST_INC			(0x1 << 27)			/* Destination address increment after transfer */
+#define PROT_ENABLE		(0x1 << 28)			/* Protection */
+#define PROT_DISABLE   ~(PROT_ENABLE)
+#define TC_INT_ENABLE	(0x1 << 31)			/* Terminal Interrupt Enable */
+#define TC_INT_DISABLE ~(TC_INT_EN)
+
+/***********************************************************************************************/
+/*		DMACCxCTL1(x) : Channel Control Register										                               */
+/***********************************************************************************************/
+#define TSFR_SIZE4(x)	(x >> 2)			/* [24:0] ex) Transfer Size(x) = 256Byte -> 0x40 */
+#define TSFR_SIZE2(x)	(x >> 1)			/* [24:0] ex) Transfer Size(x) = 256Byte -> 0x40 */
+
+/***********************************************************************************************/
+/*		DMACCxCFG(x) : Channel Configuration Register										                               */
+/***********************************************************************************************/
+#define	CHAN_ENABLE		(0x1 << 0)			/* Enables this DMA Channel */
+#define CHAN_DISABLE    (0x0 << 0)			/* Disables this DMA Channel */
+#define SRC_CONN(x)		(x << 1)			/* Source peripheral number */
+#define DST_CONN(x)		(x << 6)			/* Destination peripheral number */
+#define FCTL_DMA_M2M	(0x0 << 11)			/* Flow control(DMA) 	: Memory to Memory */
+#define FCTL_DMA_M2P	(0x1 << 11)			/* Flow control(DMA) 	: Memory to Peri. */
+#define FCTL_DMA_P2M	(0x2 << 11)			/* Flow control(DMA) 	: Peri.  to Memory */
+#define FCTL_DMA_P2P	(0x3 << 11)			/* Flow control(DMA) 	: Peri.  to Peri.  */
+#define FCTL_DPERI_P2P	(0x4 << 11)			/* Flow control(D-PERI) : Peri. to Peri. */
+#define FCTL_PERI_M2P	(0x5 << 11)			/* Flow control(PERI) 	: Memory to Peri. */
+#define FCTL_PERI_P2M	(0x6 << 11)			/* Flow control(PERI) 	: Peri. to Memory */
+#define FCTL_SPERI_P2P	(0x7 << 11)			/* Flow control(S-PERI) : Peri to Peri */
+#define INT_ERR_MASK	(0x1 << 14)			/* Error interrupt mask */
+#define INT_ERR_UMASK  ~(INT_ERR_MASK)		/* Error interupt unmask */
+#define INT_TC_MASK		(0x1 << 15)			/* TC interrupt mask */
+#define INT_TC_UMASK   ~(INT_TC_MASK)		/* TC interrupt unmask */		
+#define LOCK_SET		(0x1 << 16)			/* LOCK transfer enable */
+#define LOCK_CLR	   ~(LOCK_SET)			/* LOCK transfer disable */
+#define ACTIVE_SET		(0x1 << 17)			/* There is no data in the FIFO of the channle */
+#define ACTIVE_CLR	   ~(ACTIVE_SET)		/* The FIFO of the channel has data */
+#define HALT_SET		(0x1 << 18)			/* Ignore subsequent source DMA request */
+#define HALT_CLR	   ~(HALT_SET)			/* Enable DMA Request */
+
+/***********************************************************************************************/
+/*		DMAC information for other device						                               */
+/***********************************************************************************************/
+#define CONNECTION_DEVICE_NUM		32
+
+/***********************************************************************************************/
+/*		DMAC Source(Connection Num)						                               		   */
+/***********************************************************************************************/
+#define	I2S0_TX		10
+#define	I2S0_RX		11
+
+extern spinlock_t  s3c6410_dma_spin_lock;					/* spinlock for only dma */
+    
+static inline unsigned long s3c6410_dma_lock(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&s3c6410_dma_spin_lock, flags);
+	return flags;
+}
+
+static inline void s3c6410_dma_unlock(unsigned long flags)
+{  
+	spin_unlock_irqrestore(&s3c6410_dma_spin_lock, flags);
+}   
+
+struct dmac_sel {
+	const char		*name;
+	unsigned long	 dma_sel;
+};
+
+/* If you want to inteface with dma controller, should be add in below structure */
+static struct dmac_sel s3c6410_dmac_sel[CONNECTION_DEVICE_NUM] = {
+	[I2S0_TX] = {
+		.name 		= "i2s0-out",
+		.dma_sel	= 1 << I2S0_TX,
+	},
+
+	[I2S0_RX] = {
+		.name 		= "i2s0-in",
+		.dma_sel	= 1 << I2S0_RX,
+	},	
+};
+
+struct dmac_info {
+	char			modalias[20];
+	unsigned int	dma_port;
+	unsigned int	conn_num;
+	unsigned int	hw_fifo;
+};
+
+struct dmac_conn_info {
+	struct   dmac_info	*connection_num;
+	unsigned long		array_size;
+};
+
+/* structure for making the LLI List */
+struct dmac_lli {
+	unsigned int src_lli;
+	unsigned int dst_lli;
+	unsigned int next_lli;
+	unsigned int chan_ctrl0;
+	unsigned int chan_ctrl1;
+};
+
+/* Data Structure of DMA information for each devices */
+struct dma_data {
+	void				*dma_lli_v;							/* Linked List Item, Virtual address */
+	unsigned int		dma_port;							/* DMA Controller port information */
+	unsigned int		chan_num;							/* DMA Channel number */
+	unsigned int		conn_num;							/* Device & DMA connection information */
+	unsigned int		dst_addr;							/* Destination address for DMAC */ 
+	unsigned int		src_addr;							/* Source address for DMAC */ 
+	unsigned int		lli_addr;							/* LLI address for DMAC */
+	unsigned int 		dmac_cfg;							/* Set mode for flow control bit */
+	unsigned int		dmac_ctrl0;							/* DMACCxControl0 register value (Burst size, Data width..) */
+	unsigned int 		dmac_ctrl1;							/* DMACCxControl1 register value (Transfer Size)*/
+	unsigned int		dmac_bytes;							/* Total Transfer size for DMAC*/
+	void				(*dma_dev_handler)(void *); /* DMAC interrupt handler pointer for each devices */
+	unsigned int		active;								/* DMA active flag */
+	void				*private_data;
+};
+
+extern int s3c6410_dmac_request(struct dma_data *dmadata, void * id);
+extern int s3c6410_dmac_enable(struct dma_data *dmadata);
+extern int s3c6410_dmac_disable(struct dma_data *dmadata);
+extern int s3c6410_dmac_free(struct dma_data *dmadata);
+extern int s3c6410_dmac_halt(struct dma_data *dmadata, unsigned int val);
+extern unsigned int s3c6410_dmac_get_base(unsigned int port);
+
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/s3c6410.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/s3c6410.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/s3c6410.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/s3c6410.h	2010-05-06 12:42:45.634864134 +0700
@@ -13,13 +13,16 @@
 */
 
 #ifdef CONFIG_CPU_S3C6410
+extern void s3c64xx_common_init_uarts(struct s3c_uartcfg *cfg, int no);
+extern void s3c64xx_setup_clocks(void);
 
 extern  int s3c6410_init(void);
 extern void s3c6410_init_irq(void);
 extern void s3c6410_map_io(void);
 extern void s3c6410_init_clocks(int xtal);
+extern void s3c6410_register_clocks(void);
 
-#define s3c6410_init_uarts s3c6400_common_init_uarts
+#define s3c6410_init_uarts s3c64xx_common_init_uarts
 
 #else
 #define s3c6410_init_clocks NULL
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/s3c64xx-dvfs.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/s3c64xx-dvfs.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/include/plat/s3c64xx-dvfs.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/include/plat/s3c64xx-dvfs.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,29 @@
+/* /arch/arm/plat-s3c64xx/include/plat/s3c64xx-dvfs.h
+ *
+ * Copyright (c) 2009 Samsung Electronics
+  *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __PLAT_S3C64XX_DVFS_H
+#define __PLAT_S3C64XX_DVFS_H __FILE__
+
+#define MAXIMUM_FREQ 800000
+//#undef USE_DVS
+#define USE_DVS
+//#define USE_DVFS_AL1_LEVEL
+#undef USE_DVFS_AL1_LEVEL
+#define KHZ_T		1000
+
+#define MPU_CLK		"clk_cpu"
+#define INDX_ERROR  65535
+
+extern unsigned int s3c64xx_cpufreq_index;
+extern unsigned int S3C64XX_FREQ_TAB;
+extern unsigned int S3C64XX_MAXFREQLEVEL;
+extern unsigned int s3c64xx_target_frq(unsigned int pred_freq, int flag);
+extern void set_dvfs_level(int flag);
+extern void set_dvfs_perf_level(void);
+#endif /* __PLAT_S3C64XX_DVFS_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/irq.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/irq.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/irq.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/irq.c	2010-05-06 12:42:45.634864134 +0700
@@ -16,12 +16,18 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/io.h>
+#include <linux/sysdev.h>
 
 #include <asm/hardware/vic.h>
 
 #include <mach/map.h>
 #include <plat/regs-timer.h>
+#include <plat/regs-clock.h>
+#include <plat/regs-gpio.h>
+#include <plat/gpio-cfg.h>
+#include <mach/regs-irq.h>
 #include <plat/cpu.h>
+#include <plat/pm.h>
 
 /* Timer interrupt handling */
 
@@ -59,29 +65,29 @@
 
 static void s3c_irq_timer_mask(unsigned int irq)
 {
-	u32 reg = __raw_readl(S3C64XX_TINT_CSTAT);
+	u32 reg = __raw_readl(S3C_TINT_CSTAT);
 
 	reg &= 0x1f;  /* mask out pending interrupts */
 	reg &= ~(1 << (irq - IRQ_TIMER0));
-	__raw_writel(reg, S3C64XX_TINT_CSTAT);
+	__raw_writel(reg, S3C_TINT_CSTAT);
 }
 
 static void s3c_irq_timer_unmask(unsigned int irq)
 {
-	u32 reg = __raw_readl(S3C64XX_TINT_CSTAT);
+	u32 reg = __raw_readl(S3C_TINT_CSTAT);
 
 	reg &= 0x1f;  /* mask out pending interrupts */
 	reg |= 1 << (irq - IRQ_TIMER0);
-	__raw_writel(reg, S3C64XX_TINT_CSTAT);
+	__raw_writel(reg, S3C_TINT_CSTAT);
 }
 
 static void s3c_irq_timer_ack(unsigned int irq)
 {
-	u32 reg = __raw_readl(S3C64XX_TINT_CSTAT);
+	u32 reg = __raw_readl(S3C_TINT_CSTAT);
 
 	reg &= 0x1f;
 	reg |= (1 << 5) << (irq - IRQ_TIMER0);
-	__raw_writel(reg, S3C64XX_TINT_CSTAT);
+	__raw_writel(reg, S3C_TINT_CSTAT);
 }
 
 static struct irq_chip s3c_irq_timer = {
@@ -207,7 +213,7 @@
 
 static void __init s3c64xx_uart_irq(struct uart_irq *uirq)
 {
-	void __iomem *reg_base = uirq->regs;
+	void *reg_base = uirq->regs;
 	unsigned int irq;
 	int offs;
 
@@ -225,6 +231,65 @@
 
 	set_irq_chained_handler(uirq->parent_irq, s3c_irq_demux_uart);
 }
+#ifdef CONFIG_PM
+static struct sleep_save extirq_save[] = {
+	SAVE_ITEM(S3C64XX_EINT0CON0),
+	SAVE_ITEM(S3C64XX_EINT0CON1),
+	SAVE_ITEM(S3C64XX_EINT0FLTCON0),
+	SAVE_ITEM(S3C64XX_EINT0FLTCON1),
+	SAVE_ITEM(S3C64XX_EINT0FLTCON2),
+	SAVE_ITEM(S3C64XX_EINT0FLTCON3),
+	SAVE_ITEM(S3C64XX_EINT0MASK),
+	SAVE_ITEM(S3C64XX_EINT12CON),
+	SAVE_ITEM(S3C64XX_EINT34CON),
+	SAVE_ITEM(S3C64XX_EINT56CON),
+	SAVE_ITEM(S3C64XX_EINT78CON),
+	SAVE_ITEM(S3C64XX_EINT9CON),
+	SAVE_ITEM(S3C64XX_EINT12FLTCON),
+	SAVE_ITEM(S3C64XX_EINT34FLTCON),
+	SAVE_ITEM(S3C64XX_EINT56FLTCON),
+	SAVE_ITEM(S3C64XX_EINT78FLTCON),
+	SAVE_ITEM(S3C64XX_EINT9FLTCON),
+	SAVE_ITEM(S3C64XX_EINT12MASK),
+	SAVE_ITEM(S3C64XX_EINT34MASK),
+	SAVE_ITEM(S3C64XX_EINT56MASK),
+	SAVE_ITEM(S3C64XX_EINT78MASK),
+	SAVE_ITEM(S3C64XX_EINT9MASK),
+	SAVE_ITEM(S3C64XX_EINT34FLTCON),
+	SAVE_ITEM(S3C64XX_EINT56FLTCON),
+	SAVE_ITEM(S3C64XX_EINT78FLTCON),
+	SAVE_ITEM(S3C64XX_EINT9FLTCON),
+};
+
+int s3c64xx_irq_suspend(struct sys_device *dev, pm_message_t state)
+{
+	s3c6410_pm_do_save(extirq_save, ARRAY_SIZE(extirq_save));
+	return 0;
+}
+
+int s3c64xx_irq_resume(struct sys_device *dev)
+{
+	int irqno;
+	int irqindex = 0;
+	/* For writing the IRQ number into the VICVECTADDR */
+	s3c6410_pm_do_restore(extirq_save, ARRAY_SIZE(extirq_save));
+
+	for (irqno = IRQ_EINT0_3; irqno <= IRQ_LCD_SYSTEM; irqno++) {
+		__raw_writel(irqno, S3C64XX_VIC0VECTADDR0 + irqindex);
+		irqindex = irqindex + 4;
+	}
+
+	irqindex = 0;
+	for (irqno = IRQ_EINT12_19; irqno <= IRQ_ADC; irqno++) {
+		__raw_writel(irqno, S3C64XX_VIC1VECTADDR0 + irqindex);
+		irqindex = irqindex + 4;
+	}
+	return 0;
+}
+#else
+#define s3c64xx_irq_suspend	NULL
+#define s3c64xx_irq_resume	NULL
+#endif
 
 void __init s3c64xx_init_irq(u32 vic0_valid, u32 vic1_valid)
 {
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/irq-eint.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/irq-eint.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/irq-eint.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/irq-eint.c	2010-05-06 12:42:45.644210217 +0700
@@ -14,32 +14,20 @@
 
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
-#include <linux/gpio.h>
 #include <linux/irq.h>
 #include <linux/io.h>
 
 #include <asm/hardware/vic.h>
 
 #include <plat/regs-irqtype.h>
-#include <plat/regs-gpio.h>
-#include <plat/gpio-cfg.h>
 
 #include <mach/map.h>
 #include <plat/cpu.h>
 
-/* GPIO is 0x7F008xxx, */
-#define S3C64XX_GPIOREG(x)	(S3C64XX_VA_GPIO + (x))
-
-#define S3C64XX_EINT0CON0	S3C64XX_GPIOREG(0x900)
-#define S3C64XX_EINT0CON1	S3C64XX_GPIOREG(0x904)
-#define S3C64XX_EINT0FLTCON0	S3C64XX_GPIOREG(0x910)
-#define S3C64XX_EINT0FLTCON1	S3C64XX_GPIOREG(0x914)
-#define S3C64XX_EINT0FLTCON2	S3C64XX_GPIOREG(0x918)
-#define S3C64XX_EINT0FLTCON3	S3C64XX_GPIOREG(0x91C)
-
-#define S3C64XX_EINT0MASK	S3C64XX_GPIOREG(0x920)
-#define S3C64XX_EINT0PEND	S3C64XX_GPIOREG(0x924)
-
+#include <mach/gpio.h>
+#include <plat/gpio-cfg.h>
+#include <plat/gpio-bank-n.h>
+#include <plat/regs-gpio.h>
 
 #define eint_offset(irq)	((irq) - IRQ_EINT(0))
 #define eint_irq_to_bit(irq)	(1 << eint_offset(irq))
@@ -58,7 +46,7 @@
 	u32 mask;
 
 	mask = __raw_readl(S3C64XX_EINT0MASK);
-	mask &= ~eint_irq_to_bit(irq);
+	mask &= ~(eint_irq_to_bit(irq));
 	__raw_writel(mask, S3C64XX_EINT0MASK);
 }
 
@@ -77,7 +65,6 @@
 static int s3c_irq_eint_set_type(unsigned int irq, unsigned int type)
 {
 	int offs = eint_offset(irq);
-	int pin;
 	int shift;
 	u32 ctrl, mask;
 	u32 newvalue = 0;
@@ -86,10 +73,11 @@
 	if (offs > 27)
 		return -EINVAL;
 
-	if (offs <= 15)
-		reg = S3C64XX_EINT0CON0;
+	/* fixed by jsgood */
+	if (offs > 15)
+		reg = S3C64XX_EINT0CON1; /* org: reg = S3C64XX_EINT0CON0; */
 	else
-		reg = S3C64XX_EINT0CON1;
+		reg = S3C64XX_EINT0CON0; /* org: reg = S3C64XX_EINT0CON1; */
 
 	switch (type) {
 	case IRQ_TYPE_NONE:
@@ -121,22 +109,21 @@
 		return -1;
 	}
 
-	shift = (offs / 2) * 4;
+	/* fixed by jsgood */
+	shift = ((offs % 16) / 2) * 4;	/* org: shift = (offs / 2) * 4; */
 	mask = 0x7 << shift;
 
 	ctrl = __raw_readl(reg);
 	ctrl &= ~mask;
 	ctrl |= newvalue << shift;
 	__raw_writel(ctrl, reg);
-
-	/* set the GPIO pin appropriately */
-
-	if (offs < 23)
-		pin = S3C64XX_GPN(offs);
+	
+	if (offs < 16)
+		s3c_gpio_cfgpin(S3C64XX_GPN(offs), 0x2 << (offs * 2));
+	else if (offs < 23)
+		s3c_gpio_cfgpin(S3C64XX_GPL(offs - 8), S3C_GPIO_SFN(3));
 	else
-		pin = S3C64XX_GPM(offs - 23);
-
-	s3c_gpio_cfgpin(pin, S3C_GPIO_SFN(2));
+		s3c_gpio_cfgpin(S3C64XX_GPM(offs - 23), S3C_GPIO_SFN(3));
 
 	return 0;
 }
@@ -194,7 +181,7 @@
 	s3c_irq_demux_eint(20, 27);
 }
 
-static int __init s3c64xx_init_irq_eint(void)
+int __init s3c64xx_init_irq_eint(void)
 {
 	int irq;
 
@@ -209,6 +196,16 @@
 	set_irq_chained_handler(IRQ_EINT12_19, s3c_irq_demux_eint12_19);
 	set_irq_chained_handler(IRQ_EINT20_27, s3c_irq_demux_eint20_27);
 
+	__raw_writel(0x88888888, S3C64XX_EINT0FLTCON0);
+	__raw_writel(0x88888888, S3C64XX_EINT0FLTCON1);
+	__raw_writel(0x88888888, S3C64XX_EINT0FLTCON2);
+	__raw_writel(0x88888888, S3C64XX_EINT0FLTCON3);
+
+	__raw_writel(0x00848484, S3C64XX_EINT12FLTCON);
+	__raw_writel(0x84848484, S3C64XX_EINT34FLTCON);
+	__raw_writel(0x84848484, S3C64XX_EINT56FLTCON);
+	__raw_writel(0x84848484, S3C64XX_EINT78FLTCON);
+	__raw_writel(0x00000084, S3C64XX_EINT9FLTCON);
 	return 0;
 }
 
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/Kconfig linux-2.6.29-spica/arch/arm/plat-s3c64xx/Kconfig
--- linux-2.6.29/arch/arm/plat-s3c64xx/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/Kconfig	2010-05-06 12:42:45.634864134 +0700
@@ -9,10 +9,9 @@
 config PLAT_S3C64XX
 	bool
 	depends on ARCH_S3C64XX
-	default y
-	select CPU_V6
 	select PLAT_S3C
 	select ARM_VIC
+	default y
 	select NO_IOPORT
 	select ARCH_REQUIRE_GPIOLIB
 	select S3C_GPIO_TRACK
@@ -26,13 +25,13 @@
 
 # Configuration options shared by all S3C64XX implementations
 
-config CPU_S3C6400_INIT
+config CPU_S3C64XX_INIT
 	bool
 	help
 	  Common initialisation code for the S3C6400 that is shared
 	  by other CPUs in the series, such as the S3C6410.
 
-config CPU_S3C6400_CLOCK
+config CPU_S3C64XX_CLOCK
 	bool
 	help
 	  Common clock support code for the S3C6400 that is shared
@@ -54,9 +53,34 @@
 	help
 	  Common setup code for i2c bus 1.
 
-config S3C64XX_SETUP_FB_24BPP
+config S3C64XX_ADCTS
 	bool
+	default n
+	help
+	  Common setup code for adc and touchscreen
+
+
+config PWM
+	tristate "Pulse Width Modulation (PWM) Timer support"
+
+config S3C6410_PWM
+         bool "S3C6410 PWM support"
+         depends on CPU_S3C6410 && PWM
+         help
+           S3C6410 PWM support.
+
+config S3C64XX_DOMAIN_GATING
+	bool "Support S3C64XX Domain Gating"
+	depends on PM
+	default n
+	help
+	  domain power enable / disble when each domain is not active / idle
+
+config S3C64XX_DOMAIN_GATING_DEBUG
+	bool "Support S3C64XX Domain Gating Debug"
+	depends on S3C64XX_DOMAIN_GATING
+	default n
 	help
-	  Common setup code for S3C64XX with an 24bpp RGB display helper.
+	  s3c64xx domain gating debug message enable / disable
 
 endif
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/Makefile linux-2.6.29-spica/arch/arm/plat-s3c64xx/Makefile
--- linux-2.6.29/arch/arm/plat-s3c64xx/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/Makefile	2010-05-06 12:42:45.644210217 +0700
@@ -12,7 +12,7 @@
 
 # Core files
 
-obj-y				+= dev-uart.o
+obj-y				+= dev-uart.o devs.o
 obj-y				+= cpu.o
 obj-y				+= irq.o
 obj-y				+= irq-eint.o
@@ -21,11 +21,19 @@
 
 # CPU support
 
-obj-$(CONFIG_CPU_S3C6400_INIT)	+= s3c6400-init.o
-obj-$(CONFIG_CPU_S3C6400_CLOCK)	+= s3c6400-clock.o
+obj-$(CONFIG_CPU_S3C64XX_INIT)	+= s3c64xx-init.o
+obj-$(CONFIG_CPU_S3C64XX_CLOCK)	+= s3c64xx-clock.o
+obj-$(CONFIG_CPU_FREQ)		+= s3c64xx-dvfs.o changefreq.o
+obj-$(CONFIG_PM)                += pm.o
+obj-$(CONFIG_PM)                += sleep.o
 
 # Device setup
 
 obj-$(CONFIG_S3C64XX_SETUP_I2C0) += setup-i2c0.o
 obj-$(CONFIG_S3C64XX_SETUP_I2C1) += setup-i2c1.o
-obj-$(CONFIG_S3C64XX_SETUP_FB_24BPP) += setup-fb-24bpp.o
+obj-$(CONFIG_S3C64XX_ADCTS) += s3c64xx-adcts.o
+
+#
+# Makefile for PWM drivers.
+#
+obj-$(CONFIG_S3C6410_PWM)       += pwm-s3c6410.o
\      
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/pm.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/pm.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/pm.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/pm.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,955 @@
+/* linux/arch/arm/plat-s3c64xx/pm.c
+ *
+ * Copyright (c) 2004,2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C24XX Power Manager (Suspend-To-RAM) support
+ *
+ * See Documentation/arm/Samsung-S3C24XX/Suspend.txt for more information
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Parts based on arch/arm/mach-pxa/pm.c
+ *
+ * Thanks to Dimitry Andric for debugging
+*/
+
+#include <linux/init.h>
+#include <linux/suspend.h>
+#include <linux/errno.h>
+#include <linux/time.h>
+#include <linux/interrupt.h>
+#include <linux/crc32.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/serial_core.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+
+#include <asm/cacheflush.h>
+
+#include <plat/map-base.h>
+#include <plat/regs-serial.h>
+#include <plat/regs-clock.h>
+#include <plat/regs-gpio.h>
+#include <plat/regs-onenand.h>
+#include <plat/gpio-cfg.h>
+
+#include <mach/hardware.h>
+#include <mach/regs-mem.h>
+#include <mach/regs-irq.h>
+#include <asm/gpio.h>
+
+#include <asm/mach/time.h>
+
+#include <plat/pm.h>
+#include <plat/s3c64xx-dvfs.h>
+
+unsigned long s3c_pm_flags;
+
+int (*bml_suspend_fp)(struct device *dev, u32 state, u32 level);
+EXPORT_SYMBOL(bml_suspend_fp);
+
+int (*bml_resume_fp)(struct device *dev, u32 level);
+EXPORT_SYMBOL(bml_resume_fp);
+
+/* for external use */
+#define PFX "s3c64xx-pm: "
+
+#ifdef CONFIG_S3C64XX_DOMAIN_GATING
+#include <plat/power-clock-domain.h>
+
+#ifdef CONFIG_S3C64XX_DOMAIN_GATING_DEBUG
+static int domain_hash_map[15]={0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 7};
+static char *domain_name[] = {"G","V", "I", "P", "F", "S", "ETM", "IROM"}; 
+#endif /* CONFIG_S3C64XX_DOMAIN_GATING_DEBUG */
+
+static spinlock_t power_lock;
+
+static unsigned int s3c_domain_off_stat = 0x1FFC;
+
+static void s3c_init_domain_power(void)
+{
+	spin_lock_init(&power_lock);
+
+	s3c_set_normal_cfg(S3C64XX_DOMAIN_V, S3C64XX_LP_MODE, S3C64XX_MFC);
+//	s3c_set_normal_cfg(S3C64XX_DOMAIN_G, S3C64XX_LP_MODE, S3C64XX_3D);
+	s3c_set_normal_cfg(S3C64XX_DOMAIN_I, S3C64XX_LP_MODE, S3C64XX_JPEG);
+	s3c_set_normal_cfg(S3C64XX_DOMAIN_I, S3C64XX_LP_MODE, S3C64XX_CAMERA);
+//	s3c_set_normal_cfg(S3C64XX_DOMAIN_P, S3C64XX_LP_MODE, S3C64XX_2D);
+	s3c_set_normal_cfg(S3C64XX_DOMAIN_P, S3C64XX_LP_MODE, S3C64XX_TVENC);
+	s3c_set_normal_cfg(S3C64XX_DOMAIN_P, S3C64XX_LP_MODE, S3C64XX_SCALER);
+	s3c_set_normal_cfg(S3C64XX_DOMAIN_F, S3C64XX_LP_MODE, S3C64XX_ROT);
+	s3c_set_normal_cfg(S3C64XX_DOMAIN_F, S3C64XX_LP_MODE, S3C64XX_POST);
+	s3c_set_normal_cfg(S3C64XX_DOMAIN_S, S3C64XX_LP_MODE, S3C64XX_SDMA0);
+	s3c_set_normal_cfg(S3C64XX_DOMAIN_S, S3C64XX_LP_MODE, S3C64XX_SDMA1);
+}
+
+int domain_off_check(unsigned int config)
+{
+	if(config == S3C64XX_DOMAIN_V) {
+		if(s3c_domain_off_stat & S3C64XX_DOMAIN_V_MASK)	
+			return 0;
+	}
+	else if(config == S3C64XX_DOMAIN_G) {
+		if(s3c_domain_off_stat & S3C64XX_DOMAIN_G_MASK)
+			return 0;
+	}
+	else if(config == S3C64XX_DOMAIN_I) {
+		if(s3c_domain_off_stat & S3C64XX_DOMAIN_I_MASK)
+			return 0;
+	}
+	else if(config == S3C64XX_DOMAIN_P) {
+		if(s3c_domain_off_stat & S3C64XX_DOMAIN_P_MASK)
+			return 0;
+	}
+	else if(config == S3C64XX_DOMAIN_F) {
+		if(s3c_domain_off_stat & S3C64XX_DOMAIN_F_MASK)
+			return 0;
+	}
+	else if(config == S3C64XX_DOMAIN_S) {
+		if(s3c_domain_off_stat & S3C64XX_DOMAIN_S_MASK)
+			return 0;
+	}
+	else if(config == S3C64XX_DOMAIN_ETM) {
+		if(s3c_domain_off_stat & S3C64XX_DOMAIN_ETM_MASK)
+			return 0;
+	}
+	else if(config == S3C64XX_DOMAIN_IROM) {
+		if(s3c_domain_off_stat & S3C64XX_DOMAIN_IROM_MASK)
+			return 0;
+	}
+	return 1;
+}
+
+EXPORT_SYMBOL(domain_off_check);
+
+void s3c_set_normal_cfg(unsigned int config, unsigned int flag, unsigned int deviceID)
+{
+	unsigned int normal_cfg;
+	int power_off_flag = 0;
+	spin_lock(&power_lock);
+	normal_cfg = __raw_readl(S3C_NORMAL_CFG);
+	if(flag == S3C64XX_ACTIVE_MODE) {
+		s3c_domain_off_stat |= (1 << deviceID);
+		if(!(normal_cfg & config)) {
+			normal_cfg |= (config);
+			__raw_writel(normal_cfg, S3C_NORMAL_CFG);
+#ifdef CONFIG_S3C64XX_DOMAIN_GATING_DEBUG
+			printk("===== Domain-%s Power ON NORMAL_CFG : %x \n",
+					domain_name[domain_hash_map[deviceID]], normal_cfg);
+#endif /* CONFIG_S3C64XX_DOMAIN_GATING_DEBUG */
+		}
+		
+	}
+	else if(flag == S3C64XX_LP_MODE) {
+		s3c_domain_off_stat &= (~( 1 << deviceID));
+		power_off_flag = domain_off_check(config);
+		if(power_off_flag == 1) {
+			if(normal_cfg & config) {
+				normal_cfg &= (~config);
+				__raw_writel(normal_cfg, S3C_NORMAL_CFG);
+#ifdef CONFIG_S3C64XX_DOMAIN_GATING_DEBUG
+				printk("===== Domain-%s Power OFF NORMAL_CFG : %x \n",
+						domain_name[domain_hash_map[deviceID]], normal_cfg);
+#endif /* CONFIG_S3C64XX_DOMAIN_GATING_DEBUG */
+			}
+		}
+	}	
+	spin_unlock(&power_lock);
+
+}
+EXPORT_SYMBOL(s3c_set_normal_cfg);
+
+int s3c_wait_blk_pwr_ready(unsigned int config)
+{
+	unsigned int blk_pwr_stat;
+	int timeout;
+	int ret = 0;
+	
+	/* Wait max 20 ms */
+	timeout = 20;
+	while (!((blk_pwr_stat = __raw_readl(S3C_BLK_PWR_STAT)) & config)) {
+		if (timeout == 0) {
+			printk(KERN_ERR "config %x: blk power never ready.\n", config);
+			ret = 1;
+			goto s3c_wait_blk_pwr_ready_end;
+		}
+		timeout--;
+		mdelay(1);
+	}
+s3c_wait_blk_pwr_ready_end:
+	return ret;
+}
+EXPORT_SYMBOL(s3c_wait_blk_pwr_ready);
+#endif /* CONFIG_S3C64XX_DOMAIN_GATING */
+
+static struct sleep_save core_save[] = {
+	SAVE_ITEM(S3C_SDMA_SEL),
+	SAVE_ITEM(S3C_HCLK_GATE),
+	SAVE_ITEM(S3C_PCLK_GATE),
+	SAVE_ITEM(S3C_SCLK_GATE),
+	SAVE_ITEM(S3C_MEM0_CLK_GATE),
+	SAVE_ITEM(S3C_CLK_SRC),
+	SAVE_ITEM(S3C_CLK_DIV0),
+	SAVE_ITEM(S3C_CLK_DIV1),
+	SAVE_ITEM(S3C_CLK_DIV2),
+	SAVE_ITEM(S3C_APLL_CON),
+	SAVE_ITEM(S3C_MPLL_CON),
+	SAVE_ITEM(S3C_EPLL_CON0),
+	SAVE_ITEM(S3C_EPLL_CON1),
+	SAVE_ITEM(S3C_NORMAL_CFG),
+	SAVE_ITEM(S3C_AHB_CON0),
+};
+
+static struct sleep_save gpio_save[] = {
+	SAVE_ITEM(S3C64XX_GPACON),
+	SAVE_ITEM(S3C64XX_GPADAT),
+	SAVE_ITEM(S3C64XX_GPAPUD),
+	SAVE_ITEM(S3C64XX_GPACONSLP),
+	SAVE_ITEM(S3C64XX_GPAPUDSLP),
+	SAVE_ITEM(S3C64XX_GPBCON),
+	SAVE_ITEM(S3C64XX_GPBDAT),
+	SAVE_ITEM(S3C64XX_GPBPUD),
+	SAVE_ITEM(S3C64XX_GPBCONSLP),
+	SAVE_ITEM(S3C64XX_GPBPUDSLP),
+	SAVE_ITEM(S3C64XX_GPCCON),
+	SAVE_ITEM(S3C64XX_GPCDAT),
+	SAVE_ITEM(S3C64XX_GPCPUD),
+	SAVE_ITEM(S3C64XX_GPCCONSLP),
+	SAVE_ITEM(S3C64XX_GPCPUDSLP),
+	SAVE_ITEM(S3C64XX_GPDCON),
+	SAVE_ITEM(S3C64XX_GPDDAT),
+	SAVE_ITEM(S3C64XX_GPDPUD),
+	SAVE_ITEM(S3C64XX_GPDCONSLP),
+	SAVE_ITEM(S3C64XX_GPDPUDSLP),
+	SAVE_ITEM(S3C64XX_GPECON),
+	SAVE_ITEM(S3C64XX_GPEDAT),
+	SAVE_ITEM(S3C64XX_GPEPUD),
+	SAVE_ITEM(S3C64XX_GPECONSLP),
+	SAVE_ITEM(S3C64XX_GPEPUDSLP),
+	SAVE_ITEM(S3C64XX_GPFCON),
+	SAVE_ITEM(S3C64XX_GPFDAT),
+	SAVE_ITEM(S3C64XX_GPFPUD),
+	SAVE_ITEM(S3C64XX_GPFCONSLP),
+	SAVE_ITEM(S3C64XX_GPFPUDSLP),
+	SAVE_ITEM(S3C64XX_GPGCON),
+	SAVE_ITEM(S3C64XX_GPGDAT),
+	SAVE_ITEM(S3C64XX_GPGPUD),
+	SAVE_ITEM(S3C64XX_GPGCONSLP),
+	SAVE_ITEM(S3C64XX_GPGPUDSLP),
+	SAVE_ITEM(S3C64XX_GPHCON0),
+	SAVE_ITEM(S3C64XX_GPHCON1),
+	SAVE_ITEM(S3C64XX_GPHDAT),
+	SAVE_ITEM(S3C64XX_GPHPUD),
+	SAVE_ITEM(S3C64XX_GPHCONSLP),
+	SAVE_ITEM(S3C64XX_GPHPUDSLP),
+	SAVE_ITEM(S3C64XX_GPICON),
+	SAVE_ITEM(S3C64XX_GPIDAT),
+	SAVE_ITEM(S3C64XX_GPIPUD),
+	SAVE_ITEM(S3C64XX_GPICONSLP),
+	SAVE_ITEM(S3C64XX_GPIPUDSLP),
+	SAVE_ITEM(S3C64XX_GPJCON),
+	SAVE_ITEM(S3C64XX_GPJDAT),
+	SAVE_ITEM(S3C64XX_GPJPUD),
+	SAVE_ITEM(S3C64XX_GPJCONSLP),
+	SAVE_ITEM(S3C64XX_GPJPUDSLP),
+	SAVE_ITEM(S3C64XX_GPKCON),
+	SAVE_ITEM(S3C64XX_GPKCON1),
+	SAVE_ITEM(S3C64XX_GPKDAT),
+	SAVE_ITEM(S3C64XX_GPKPUD),
+	SAVE_ITEM(S3C64XX_GPLCON),
+	SAVE_ITEM(S3C64XX_GPLCON1),
+	SAVE_ITEM(S3C64XX_GPLDAT),
+	SAVE_ITEM(S3C64XX_GPLPUD),
+	SAVE_ITEM(S3C64XX_GPMCON),
+	SAVE_ITEM(S3C64XX_GPMDAT),
+	SAVE_ITEM(S3C64XX_GPMPUD),
+	SAVE_ITEM(S3C64XX_GPNCON),
+	SAVE_ITEM(S3C64XX_GPNDAT),
+	SAVE_ITEM(S3C64XX_GPNPUD),
+	SAVE_ITEM(S3C64XX_GPOCON),
+	SAVE_ITEM(S3C64XX_GPODAT),
+	SAVE_ITEM(S3C64XX_GPOPUD),
+	SAVE_ITEM(S3C64XX_GPOCONSLP),
+	SAVE_ITEM(S3C64XX_GPOPUDSLP),
+	SAVE_ITEM(S3C64XX_GPPCON),
+	SAVE_ITEM(S3C64XX_GPPDAT),
+	SAVE_ITEM(S3C64XX_GPPPUD),
+	SAVE_ITEM(S3C64XX_GPPCONSLP),
+	SAVE_ITEM(S3C64XX_GPPPUDSLP),
+	SAVE_ITEM(S3C64XX_GPQCON),
+	SAVE_ITEM(S3C64XX_GPQDAT),
+	SAVE_ITEM(S3C64XX_GPQPUD),
+	SAVE_ITEM(S3C64XX_GPQCONSLP),
+	SAVE_ITEM(S3C64XX_GPQPUDSLP),
+	SAVE_ITEM(S3C64XX_PRIORITY),
+	SAVE_ITEM(S3C64XX_SPCON),
+
+	/* Special register */
+	SAVE_ITEM(S3C64XX_SPC_BASE),
+	SAVE_ITEM(S3C64XX_SPCONSLP),
+	SAVE_ITEM(S3C64XX_SLPEN),
+	SAVE_ITEM(S3C64XX_MEM0CONSTOP),
+	SAVE_ITEM(S3C64XX_MEM1CONSTOP),
+	SAVE_ITEM(S3C64XX_MEM0CONSLP0),
+	SAVE_ITEM(S3C64XX_MEM0CONSLP1),
+	SAVE_ITEM(S3C64XX_MEM1CONSLP),
+	SAVE_ITEM(S3C64XX_MEM0DRVCON),
+	SAVE_ITEM(S3C64XX_MEM1DRVCON),
+};
+
+/* this lot should be really saved by the IRQ code */
+/* VICXADDRESSXX initilaization to be needed */
+static struct sleep_save irq_save[] = {
+	SAVE_ITEM(S3C64XX_VIC0INTSELECT),
+	SAVE_ITEM(S3C64XX_VIC1INTSELECT),
+	SAVE_ITEM(S3C64XX_VIC0INTENABLE),
+	SAVE_ITEM(S3C64XX_VIC1INTENABLE),
+	SAVE_ITEM(S3C64XX_VIC0SOFTINT),
+	SAVE_ITEM(S3C64XX_VIC1SOFTINT),
+};
+
+static struct sleep_save sromc_save[] = {
+	SAVE_ITEM(S3C64XX_SROM_BW),
+	SAVE_ITEM(S3C64XX_SROM_BC0),
+	SAVE_ITEM(S3C64XX_SROM_BC1),
+	SAVE_ITEM(S3C64XX_SROM_BC2),
+	SAVE_ITEM(S3C64XX_SROM_BC3),
+	SAVE_ITEM(S3C64XX_SROM_BC4),
+	SAVE_ITEM(S3C64XX_SROM_BC5),
+};
+
+static struct sleep_save onenand_save[] = {
+	SAVE_ITEM(S3C_MEM_CFG0),
+	SAVE_ITEM(S3C_BURST_LEN0),
+	SAVE_ITEM(S3C_MEM_RESET0),
+	SAVE_ITEM(S3C_INT_ERR_STAT0),
+	SAVE_ITEM(S3C_INT_ERR_MASK0),
+	SAVE_ITEM(S3C_INT_ERR_ACK0),
+	SAVE_ITEM(S3C_ECC_ERR_STAT0),
+	SAVE_ITEM(S3C_MANUFACT_ID0),
+	SAVE_ITEM(S3C_DEVICE_ID0),
+	SAVE_ITEM(S3C_DATA_BUF_SIZE0),
+	SAVE_ITEM(S3C_BOOT_BUF_SIZE0),
+	SAVE_ITEM(S3C_BUF_AMOUNT0),
+	SAVE_ITEM(S3C_TECH0),
+	SAVE_ITEM(S3C_FBA_WIDTH0),
+	SAVE_ITEM(S3C_FPA_WIDTH0),
+	SAVE_ITEM(S3C_FSA_WIDTH0),
+	SAVE_ITEM(S3C_REVISION0),
+	SAVE_ITEM(S3C_DATARAM00),
+	SAVE_ITEM(S3C_DATARAM10),
+	SAVE_ITEM(S3C_SYNC_MODE0),
+	SAVE_ITEM(S3C_TRANS_SPARE0),
+	SAVE_ITEM(S3C_DBS_DFS_WIDTH0),
+	SAVE_ITEM(S3C_PAGE_CNT0),
+	SAVE_ITEM(S3C_ERR_PAGE_ADDR0),
+	SAVE_ITEM(S3C_BURST_RD_LAT0),
+	SAVE_ITEM(S3C_INT_PIN_ENABLE0),
+	SAVE_ITEM(S3C_INT_MON_CYC0),
+	SAVE_ITEM(S3C_ACC_CLOCK0),
+	SAVE_ITEM(S3C_SLOW_RD_PATH0),
+	SAVE_ITEM(S3C_ERR_BLK_ADDR0),
+	SAVE_ITEM(S3C_FLASH_VER_ID0),
+	SAVE_ITEM(S3C_FLASH_AUX_CNTRL0),
+	SAVE_ITEM(S3C_FLASH_AFIFO_CNT0),
+
+	SAVE_ITEM(S3C_MEM_CFG1),
+	SAVE_ITEM(S3C_BURST_LEN1),
+	SAVE_ITEM(S3C_MEM_RESET1),
+	SAVE_ITEM(S3C_INT_ERR_STAT1),
+	SAVE_ITEM(S3C_INT_ERR_MASK1),
+	SAVE_ITEM(S3C_INT_ERR_ACK1),
+	SAVE_ITEM(S3C_ECC_ERR_STAT1),
+	SAVE_ITEM(S3C_MANUFACT_ID1),
+	SAVE_ITEM(S3C_DEVICE_ID1),
+	SAVE_ITEM(S3C_DATA_BUF_SIZE1),
+	SAVE_ITEM(S3C_BOOT_BUF_SIZE1),
+	SAVE_ITEM(S3C_BUF_AMOUNT1),
+	SAVE_ITEM(S3C_TECH1),
+	SAVE_ITEM(S3C_FBA_WIDTH1),
+	SAVE_ITEM(S3C_FPA_WIDTH1),
+	SAVE_ITEM(S3C_FSA_WIDTH1),
+	SAVE_ITEM(S3C_REVISION1),
+	SAVE_ITEM(S3C_DATARAM01),
+	SAVE_ITEM(S3C_DATARAM11),
+	SAVE_ITEM(S3C_SYNC_MODE1),
+	SAVE_ITEM(S3C_TRANS_SPARE1),
+	SAVE_ITEM(S3C_DBS_DFS_WIDTH1),
+	SAVE_ITEM(S3C_PAGE_CNT1),
+	SAVE_ITEM(S3C_ERR_PAGE_ADDR1),
+	SAVE_ITEM(S3C_BURST_RD_LAT1),
+	SAVE_ITEM(S3C_INT_PIN_ENABLE1),
+	SAVE_ITEM(S3C_INT_MON_CYC1),
+	SAVE_ITEM(S3C_ACC_CLOCK1),
+	SAVE_ITEM(S3C_SLOW_RD_PATH1),
+	SAVE_ITEM(S3C_ERR_BLK_ADDR1),
+	SAVE_ITEM(S3C_FLASH_VER_ID1),
+	SAVE_ITEM(S3C_FLASH_AUX_CNTRL1),
+	SAVE_ITEM(S3C_FLASH_AFIFO_CNT1),
+};
+
+
+#ifdef CONFIG_S3C_PM_DEBUG
+
+#define SAVE_UART(va) \
+	SAVE_ITEM((va) + S3C_ULCON), \
+	SAVE_ITEM((va) + S3C_UCON), \
+	SAVE_ITEM((va) + S3C_UFCON), \
+	SAVE_ITEM((va) + S3C_UMCON), \
+	SAVE_ITEM((va) + S3C_UBRDIV)
+
+static struct sleep_save uart_save[] = {
+	SAVE_UART(S3C24XX_VA_UART0),
+	SAVE_UART(S3C24XX_VA_UART1),
+#ifndef CONFIG_CPU_S3C2400
+	SAVE_UART(S3C24XX_VA_UART2),
+#endif	/* CONFIG_CPU_S3C2400 */
+};
+
+/* debug
+ *
+ * we send the debug to printascii() to allow it to be seen if the
+ * system never wakes up from the sleep
+*/
+
+extern void printascii(const char *);
+
+void pm_dbg(const char *fmt, ...)
+{
+	va_list va;
+	char buff[256];
+
+	va_start(va, fmt);
+	vsprintf(buff, fmt, va);
+	va_end(va);
+
+	printascii(buff);
+}
+
+static void s3c_pm_debug_init(void)
+{
+	unsigned long tmp = __raw_readl(S3C_CLKCON);
+
+	/* re-start uart clocks */
+	tmp |= S3C_CLKCON_UART0;
+	tmp |= S3C_CLKCON_UART1;
+	tmp |= S3C_CLKCON_UART2;
+
+	__raw_writel(tmp, S3C_CLKCON);
+	udelay(10);
+}
+
+#define DBG(fmt...) pm_dbg(fmt)
+#else
+#define DBG(fmt...)
+
+#define s3c6410_pm_debug_init() do { } while(0)
+#endif	/* CONFIG_S3C_PM_DEBUG */
+
+#if defined(CONFIG_S3C_PM_CHECK) && CONFIG_S3C_PM_CHECK_CHUNKSIZE != 0
+
+/* suspend checking code...
+ *
+ * this next area does a set of crc checks over all the installed
+ * memory, so the system can verify if the resume was ok.
+ *
+ * CONFIG_S3C6410_PM_CHECK_CHUNKSIZE defines the block-size for the CRC,
+ * increasing it will mean that the area corrupted will be less easy to spot,
+ * and reducing the size will cause the CRC save area to grow
+*/
+
+#define CHECK_CHUNKSIZE (CONFIG_S3C_PM_CHECK_CHUNKSIZE * 1024)
+
+static u32 crc_size;	/* size needed for the crc block */
+static u32 *crcs;	/* allocated over suspend/resume */
+
+typedef u32 *(run_fn_t)(struct resource *ptr, u32 *arg);
+
+/* s3c6410_pm_run_res
+ *
+ * go thorugh the given resource list, and look for system ram
+*/
+
+static void s3c6410_pm_run_res(struct resource *ptr, run_fn_t fn, u32 *arg)
+{
+	while (ptr != NULL) {
+		if (ptr->child != NULL)
+			s3c6410_pm_run_res(ptr->child, fn, arg);
+
+		if ((ptr->flags & IORESOURCE_MEM) &&
+		    strcmp(ptr->name, "System RAM") == 0) {
+			DBG("Found system RAM at %08lx..%08lx\n",
+			    ptr->start, ptr->end);
+			arg = (fn)(ptr, arg);
+		}
+
+		ptr = ptr->sibling;
+	}
+}
+
+static void s3c6410_pm_run_sysram(run_fn_t fn, u32 *arg)
+{
+	s3c6410_pm_run_res(&iomem_resource, fn, arg);
+}
+
+static u32 *s3c6410_pm_countram(struct resource *res, u32 *val)
+{
+	u32 size = (u32)(res->end - res->start)+1;
+
+	size += CHECK_CHUNKSIZE-1;
+	size /= CHECK_CHUNKSIZE;
+
+	DBG("Area %08lx..%08lx, %d blocks\n", res->start, res->end, size);
+
+	*val += size * sizeof(u32);
+	return val;
+}
+
+/* s3c6410_pm_prepare_check
+ *
+ * prepare the necessary information for creating the CRCs. This
+ * must be done before the final save, as it will require memory
+ * allocating, and thus touching bits of the kernel we do not
+ * know about.
+*/
+
+static void s3c6410_pm_check_prepare(void)
+{
+	crc_size = 0;
+
+	s3c6410_pm_run_sysram(s3c6410_pm_countram, &crc_size);
+
+	DBG("s3c6410_pm_prepare_check: %u checks needed\n", crc_size);
+
+	crcs = kmalloc(crc_size+4, GFP_KERNEL);
+	if (crcs == NULL)
+		printk(KERN_ERR "Cannot allocated CRC save area\n");
+}
+
+static u32 *s3c6410_pm_makecheck(struct resource *res, u32 *val)
+{
+	unsigned long addr, left;
+
+	for (addr = res->start; addr < res->end;
+	     addr += CHECK_CHUNKSIZE) {
+		left = res->end - addr;
+
+		if (left > CHECK_CHUNKSIZE)
+			left = CHECK_CHUNKSIZE;
+
+		*val = crc32_le(~0, phys_to_virt(addr), left);
+		val++;
+	}
+
+	return val;
+}
+
+/* s3c6410_pm_check_store
+ *
+ * compute the CRC values for the memory blocks before the final
+ * sleep.
+*/
+
+static void s3c6410_pm_check_store(void)
+{
+	if (crcs != NULL)
+		s3c6410_pm_run_sysram(s3c6410_pm_makecheck, crcs);
+}
+
+/* in_region
+ *
+ * return TRUE if the area defined by ptr..ptr+size contatins the
+ * what..what+whatsz
+*/
+
+static inline int in_region(void *ptr, int size, void *what, size_t whatsz)
+{
+	if ((what+whatsz) < ptr)
+		return 0;
+
+	if (what > (ptr+size))
+		return 0;
+
+	return 1;
+}
+
+static u32 *s3c6410_pm_runcheck(struct resource *res, u32 *val)
+{
+	void *save_at = phys_to_virt(s3c6410_sleep_save_phys);
+	unsigned long addr;
+	unsigned long left;
+	void *ptr;
+	u32 calc;
+
+	for (addr = res->start; addr < res->end;
+	     addr += CHECK_CHUNKSIZE) {
+		left = res->end - addr;
+
+		if (left > CHECK_CHUNKSIZE)
+			left = CHECK_CHUNKSIZE;
+
+		ptr = phys_to_virt(addr);
+
+		if (in_region(ptr, left, crcs, crc_size)) {
+			DBG("skipping %08lx, has crc block in\n", addr);
+			goto skip_check;
+		}
+
+		if (in_region(ptr, left, save_at, 32*4 )) {
+			DBG("skipping %08lx, has save block in\n", addr);
+			goto skip_check;
+		}
+
+		/* calculate and check the checksum */
+
+		calc = crc32_le(~0, ptr, left);
+		if (calc != *val) {
+			printk(KERN_ERR PFX "Restore CRC error at "
+			       "%08lx (%08x vs %08x)\n", addr, calc, *val);
+
+			DBG("Restore CRC error at %08lx (%08x vs %08x)\n",
+			    addr, calc, *val);
+		}
+
+	skip_check:
+		val++;
+	}
+
+	return val;
+}
+
+/* s3c6410_pm_check_restore
+ *
+ * check the CRCs after the restore event and free the memory used
+ * to hold them
+*/
+
+static void s3c6410_pm_check_restore(void)
+{
+	if (crcs != NULL) {
+		s3c6410_pm_run_sysram(s3c6410_pm_runcheck, crcs);
+		kfree(crcs);
+		crcs = NULL;
+	}
+}
+
+#else
+
+#define s3c6410_pm_check_prepare() do { } while(0)
+#define s3c6410_pm_check_restore() do { } while(0)
+#define s3c6410_pm_check_store()   do { } while(0)
+#endif	/* defined(CONFIG_S3C_PM_CHECK) && CONFIG_S3C_PM_CHECK_CHUNKSIZE != 0 */
+
+/* helper functions to save and restore register state */
+
+void s3c6410_pm_do_save(struct sleep_save *ptr, int count)
+{
+	for (; count > 0; count--, ptr++) {
+		ptr->val = __raw_readl(ptr->reg);
+		//DBG("saved %p value %08lx\n", ptr->reg, ptr->val);
+	}
+}
+
+/* s3c6410_pm_do_restore
+ *
+ * restore the system from the given list of saved registers
+ *
+ * Note, we do not use DBG() in here, as the system may not have
+ * restore the UARTs state yet
+*/
+
+void s3c6410_pm_do_restore(struct sleep_save *ptr, int count)
+{
+	for (; count > 0; count--, ptr++) {
+		//printk(KERN_DEBUG "restore %p (restore %08lx, was %08x)\n",
+		       //ptr->reg, ptr->val, __raw_readl(ptr->reg));
+
+		__raw_writel(ptr->val, ptr->reg);
+	}
+}
+
+/* s3c6410_pm_do_restore_core
+ *
+ * similar to s36410_pm_do_restore_core
+ *
+ * WARNING: Do not put any debug in here that may effect memory or use
+ * peripherals, as things may be changing!
+*/
+
+/* s3c6410_pm_do_save_phy
+ *
+ * save register of system
+ *
+ * Note, I made this function to support driver with ioremap.
+ * If you want to use this function, you should to input as first parameter
+ * struct sleep_save_phy type
+*/
+
+int s3c_pm_do_save_phy(struct sleep_save_phy *ptr, struct platform_device *pdev, int count)
+{
+	void __iomem *target_reg;
+	struct resource *res;
+	u32 reg_size;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(res == NULL){
+		printk(KERN_ERR "%s resource get error\n",__FUNCTION__);
+		return 0;
+	}
+	reg_size = res->end - res->start + 1;
+	target_reg = ioremap(res->start,reg_size);
+
+	for (; count > 0; count--, ptr++) {
+		ptr->val = readl(target_reg + (ptr->reg));
+	}
+
+	return 0;
+}
+
+/* s3c6410_pm_do_restore_phy
+ *
+ * restore register of system
+ *
+ * Note, I made this function to support driver with ioremap.
+ * If you want to use this function, you should to input as first parameter
+ * struct sleep_save_phy type
+*/
+
+int s3c_pm_do_restore_phy(struct sleep_save_phy *ptr, struct platform_device *pdev, int count)
+{
+	void __iomem *target_reg;
+	struct resource *res;
+	u32 reg_size;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(res == NULL){
+		printk(KERN_ERR "%s resource get error\n",__FUNCTION__);
+		return 0;
+	}
+	reg_size = res->end - res->start + 1;
+	target_reg = ioremap(res->start,reg_size);
+
+	for (; count > 0; count--, ptr++) {
+		writel(ptr->val, (target_reg + ptr->reg));
+	}
+
+	return 0;
+}
+
+static void s3c6410_pm_do_restore_core(struct sleep_save *ptr, int count)
+{
+	for (; count > 0; count--, ptr++) {
+		__raw_writel(ptr->val, ptr->reg);
+	}
+}
+
+extern void s3c_config_wakeup_source(void);
+extern void s3c_config_sleep_gpio(void);
+extern void s3c_config_wakeup_gpio(void);
+
+static unsigned int s3c_eint_mask_val;
+
+static void s3c6410_pm_configure_extint(void)
+{
+	/* for each of the external interrupts (EINT0..EINT15) we
+	 * need to check wether it is an external interrupt source,
+	 * and then configure it as an input if it is not
+	*/
+	s3c_eint_mask_val = __raw_readl(S3C_EINT_MASK);
+
+	s3c_config_wakeup_source();
+}
+
+void (*pm_cpu_prep)(void);
+void (*pm_cpu_sleep)(void);
+
+#define any_allowed(mask, allow) (((mask) & (allow)) != (allow))
+
+/* s3c6410_pm_enter
+ *
+ * central control for sleep/resume process
+*/
+
+extern unsigned int extra_eint0pend = 0x0;
+
+static int s3c6410_pm_enter(suspend_state_t state)
+{
+	unsigned long regs_save[16];
+	unsigned int tmp;
+	unsigned int wakeup_stat = 0x0;
+	unsigned int eint0pend = 0x0;
+
+	/* ensure the debug is initialised (if enabled) */
+
+	DBG("s3c6410_pm_enter(%d)\n", state);
+
+	if (bml_suspend_fp)
+		bml_suspend_fp(NULL, 0, 0);
+
+	if (pm_cpu_prep == NULL || pm_cpu_sleep == NULL) {
+		printk(KERN_ERR PFX "error: no cpu sleep functions set\n");
+		return -EINVAL;
+	}
+
+	/* prepare check area if configured */
+	s3c6410_pm_check_prepare();
+
+	/* store the physical address of the register recovery block */
+	s3c6410_sleep_save_phys = virt_to_phys(regs_save);
+
+	DBG("s3c6410_sleep_save_phys=0x%08lx\n", s3c6410_sleep_save_phys);
+
+	/* save all necessary core registers not covered by the drivers */
+
+	s3c6410_pm_do_save(gpio_save, ARRAY_SIZE(gpio_save));
+	s3c6410_pm_do_save(irq_save, ARRAY_SIZE(irq_save));
+	s3c6410_pm_do_save(core_save, ARRAY_SIZE(core_save));
+	s3c6410_pm_do_save(sromc_save, ARRAY_SIZE(sromc_save));
+	s3c6410_pm_do_save(onenand_save, ARRAY_SIZE(onenand_save));
+
+	/* ensure INF_REG0  has the resume address */
+	__raw_writel(virt_to_phys(s3c6410_cpu_resume), S3C_INFORM0);
+
+	/* set the irq configuration for wake */
+	s3c6410_pm_configure_extint();
+
+	/* call cpu specific preperation */
+
+	pm_cpu_prep();
+
+	/* flush cache back to ram */
+
+	flush_cache_all();
+
+	s3c6410_pm_check_store();
+
+	s3c_config_sleep_gpio();	
+
+	tmp = __raw_readl(S3C64XX_SPCONSLP);
+	tmp &= ~(0x3 << 12);
+	__raw_writel(tmp | (0x1 << 12), S3C64XX_SPCONSLP);
+
+	/* send the cpu to sleep... */
+
+	__raw_writel(0xffffffff, S3C64XX_VIC0INTENCLEAR);
+	__raw_writel(0xffffffff, S3C64XX_VIC1INTENCLEAR);
+	__raw_writel(0xffffffff, S3C64XX_VIC0SOFTINTCLEAR);
+	__raw_writel(0xffffffff, S3C64XX_VIC1SOFTINTCLEAR);
+
+	/* Unmask clock gating and block power turn on */
+	__raw_writel(0x43E00041, S3C_HCLK_GATE); 
+	__raw_writel(0xF2040000, S3C_PCLK_GATE);
+	__raw_writel(0x80000011, S3C_SCLK_GATE);
+	__raw_writel(0x00000000, S3C_MEM0_CLK_GATE);
+
+	__raw_writel(0x1, S3C_OSC_STABLE);
+	__raw_writel(0x3, S3C_PWR_STABLE);
+
+	/* Set WFI instruction to SLEEP mode */
+
+	tmp = __raw_readl(S3C_PWR_CFG);
+	tmp &= ~(0x3<<5);
+	tmp |= (0x3<<5);
+	__raw_writel(tmp, S3C_PWR_CFG);
+
+	tmp = __raw_readl(S3C_SLEEP_CFG);
+	tmp &= ~(0x61<<0);
+	__raw_writel(tmp, S3C_SLEEP_CFG);
+
+	__raw_writel(0x2, S3C64XX_SLPEN);
+
+	/* Clear WAKEUP_STAT register for next wakeup -jc.lee */
+	/* If this register do not be cleared, Wakeup will be failed */
+	__raw_writel(__raw_readl(S3C_WAKEUP_STAT), S3C_WAKEUP_STAT);
+
+	/* s3c6410_cpu_save will also act as our return point from when
+	 * we resume as it saves its own register state, so use the return
+	 * code to differentiate return from save and return from sleep */
+
+	if (s3c6410_cpu_save(regs_save) == 0) {
+		flush_cache_all();
+		pm_cpu_sleep();
+	}
+
+	/* restore the cpu state */
+	cpu_init();
+
+	__raw_writel(s3c_eint_mask_val, S3C_EINT_MASK);
+
+	/* restore the system state */
+	s3c6410_pm_do_restore_core(core_save, ARRAY_SIZE(core_save));
+	s3c6410_pm_do_restore(sromc_save, ARRAY_SIZE(sromc_save));
+	s3c6410_pm_do_restore(gpio_save, ARRAY_SIZE(gpio_save));
+	s3c6410_pm_do_restore(irq_save, ARRAY_SIZE(irq_save));
+	s3c6410_pm_do_restore(onenand_save, ARRAY_SIZE(onenand_save));
+	
+	__raw_writel(0x0, S3C64XX_SLPEN);
+
+	wakeup_stat = __raw_readl(S3C_WAKEUP_STAT);
+	eint0pend = __raw_readl(S3C64XX_EINT0PEND);
+
+	__raw_writel(eint0pend, S3C64XX_EINT0PEND);
+
+	DBG("post sleep, preparing to return\n");
+
+	s3c6410_pm_check_restore();
+
+	extra_eint0pend = eint0pend;
+
+	pr_info("%s: WAKEUP_STAT(0x%08x), EINT0PEND(0x%08x)\n",
+			__func__, wakeup_stat, eint0pend);
+
+	s3c_config_wakeup_gpio();	
+
+	if (bml_resume_fp)
+		bml_resume_fp(NULL, 0);
+
+	/* ok, let's return from sleep */
+	DBG("S3C6410 PM Resume (post-restore)\n");
+	return 0;
+}
+
+static struct platform_suspend_ops s3c6410_pm_ops = {
+	.enter		= s3c6410_pm_enter,
+	.valid		= suspend_valid_only_mem,
+};
+
+/* s3c6410_pm_init
+ *
+ * Attach the power management functions. This should be called
+ * from the board specific initialisation if the board supports
+ * it.
+*/
+
+int __init s3c6410_pm_init(void)
+{
+	printk("S3C6410 Power Management, (c) 2008 Samsung Electronics\n");
+
+	suspend_set_ops(&s3c6410_pm_ops);
+
+#ifdef CONFIG_S3C64XX_DOMAIN_GATING
+	s3c_init_domain_power();
+#endif /* CONFIG_S3C64XX_DOMAIN_GATING */
+	/* set to zero value unused H/W IPs clock */
+	__raw_writel(S3C_HCLK_MASK, S3C_HCLK_GATE);
+	__raw_writel(S3C_SCLK_MASK, S3C_SCLK_GATE);
+	__raw_writel(S3C_PCLK_MASK, S3C_PCLK_GATE);
+	/* enable onenand0, onenand1 memory clock */
+	__raw_writel(0x18, S3C_MEM0_CLK_GATE);
+
+	return 0;
+}
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/pwm-s3c6410.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/pwm-s3c6410.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/pwm-s3c6410.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/pwm-s3c6410.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,361 @@
+/* arch/arm/plat-s3c64xx/pwm-s3c6410.c
+ *
+ * (c) 2003-2005 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C64XX PWM core
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Changelog:
+ * This file is based on the Sangwook Lee/Samsung patches, re-written due
+ * to various ommisions from the code (such as flexible pwm configuration)
+ * for use with the BAST system board.
+ *
+ *
+ */
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <plat/regs-gpio.h>
+#include <plat/gpio-cfg.h>
+
+#include <plat/regs-timer.h>
+#include <mach/regs-irq.h>
+#include "pwm-s3c6410.h"
+
+#define PRESCALER	4
+
+s3c6410_pwm_chan_t s3c_chans[S3C_PWM_CHANNELS];
+
+static inline void
+s3c6410_pwm_buffdone(s3c6410_pwm_chan_t *chan, void *dev)
+{
+
+	if (chan->callback_fn != NULL) {
+		(chan->callback_fn)( dev);
+	}
+}
+
+
+static int s3c6410_pwm_start (int channel)
+{
+	unsigned long tcon;
+	tcon = __raw_readl(S3C_TCON);
+	switch(channel)
+	{
+	case 0:
+		tcon |= S3C_TCON_T0START;
+		tcon &= ~S3C_TCON_T0MANUALUPD;
+	break;
+	case 1:
+		tcon |= S3C_TCON_T1START;
+		tcon &= ~S3C_TCON_T1MANUALUPD;
+	break;
+	case 2:
+		tcon |= S3C_TCON_T2START;
+		tcon &= ~S3C_TCON_T2MANUALUPD;
+	break;
+	case 3:
+		tcon |= S3C_TCON_T3START;
+		tcon &= ~S3C_TCON_T3MANUALUPD;
+	break;
+
+	}
+	__raw_writel(tcon, S3C_TCON);
+
+	return 0;
+}
+
+
+int s3c6410_timer_setup (int channel, int usec, unsigned long g_tcnt, unsigned long g_tcmp)
+{
+	unsigned long tcon;
+	unsigned long tcnt;
+	unsigned long tcmp;
+	unsigned long tcfg1;
+	unsigned long tcfg0;
+	unsigned long pclk;
+	struct clk *clk;
+
+	//printk("\nPWM channel %d set g_tcnt = %ld, g_tcmp = %ld \n", channel, g_tcnt, g_tcmp);
+
+	tcnt = 0xffffffff;  /* default value for tcnt */
+
+	/* read the current timer configuration bits */
+	tcon = __raw_readl(S3C_TCON);
+	tcfg1 = __raw_readl(S3C_TCFG1);
+	tcfg0 = __raw_readl(S3C_TCFG0);
+
+	clk = clk_get(NULL, "timers");
+	if (IS_ERR(clk))
+		panic("failed to get clock for pwm timer");
+
+	clk_enable(clk);
+
+	pclk = clk_get_rate(clk);
+
+	/* configure clock tick */
+	switch(channel)
+	{
+		case 0:
+			/* set gpio as PWM TIMER0 to signal output*/
+			s3c_gpio_cfgpin(S3C64XX_GPF(14), S3C64XX_GPF14_PWM_TOUT0);
+			s3c_gpio_setpull(S3C64XX_GPF(14), S3C_GPIO_PULL_NONE);
+			tcfg1 &= ~S3C_TCFG1_MUX0_MASK;
+			tcfg1 |= S3C_TCFG1_MUX0_DIV2;
+
+			tcfg0 &= ~S3C_TCFG_PRESCALER0_MASK;
+			tcfg0 |= (PRESCALER) << S3C_TCFG_PRESCALER0_SHIFT;
+			tcon &= ~(7<<0);
+			tcon |= S3C_TCON_T0RELOAD;
+			break;
+
+		case 1:
+			/* set gpio as PWM TIMER1 to signal output*/
+			s3c_gpio_cfgpin(S3C64XX_GPF(15), S3C64XX_GPF15_PWM_TOUT1);
+			s3c_gpio_setpull(S3C64XX_GPF(15), S3C_GPIO_PULL_NONE);
+			tcfg1 &= ~S3C_TCFG1_MUX1_MASK;
+			tcfg1 |= S3C_TCFG1_MUX1_DIV2;
+
+			tcfg0 &= ~S3C_TCFG_PRESCALER0_MASK;
+			tcfg0 |= (PRESCALER) << S3C_TCFG_PRESCALER0_SHIFT;
+
+			tcon &= ~(7<<8);
+			tcon |= S3C_TCON_T1RELOAD;
+			break;
+		case 2:
+			tcfg1 &= ~S3C_TCFG1_MUX2_MASK;
+			tcfg1 |= S3C_TCFG1_MUX2_DIV2;
+
+			tcfg0 &= ~S3C_TCFG_PRESCALER1_MASK;
+			tcfg0 |= (PRESCALER) << S3C_TCFG_PRESCALER1_SHIFT;
+
+			tcon &= ~(7<<12);
+			tcon |= S3C_TCON_T2RELOAD;
+			break;
+		case 3:
+			tcfg1 &= ~S3C_TCFG1_MUX3_MASK;
+			tcfg1 |= S3C_TCFG1_MUX3_DIV2;
+
+			tcfg0 &= ~S3C_TCFG_PRESCALER1_MASK;
+			tcfg0 |= (PRESCALER) << S3C_TCFG_PRESCALER1_SHIFT;
+			tcon &= ~(7<<16);
+			tcon |= S3C_TCON_T3RELOAD;
+			break;
+	}
+
+	__raw_writel(tcfg1, S3C_TCFG1);
+	__raw_writel(tcfg0, S3C_TCFG0);
+
+
+	__raw_writel(tcon, S3C_TCON);
+	tcnt = 160;
+	__raw_writel(tcnt, S3C_TCNTB(channel));
+	tcmp = 110;
+	__raw_writel(tcmp, S3C_TCMPB(channel));
+
+	switch(channel)
+	{
+		case 0:
+			tcon |= S3C_TCON_T0MANUALUPD;
+			break;
+		case 1:
+			tcon |= S3C_TCON_T1MANUALUPD;
+			break;
+		case 2:
+			tcon |= S3C_TCON_T2MANUALUPD;
+			break;
+		case 3:
+			tcon |= S3C_TCON_T3MANUALUPD;
+			break;
+	}
+	__raw_writel(tcon, S3C_TCON);
+
+	tcnt = g_tcnt;
+	__raw_writel(tcnt, S3C_TCNTB(channel));
+
+	tcmp = g_tcmp;
+	__raw_writel(tcmp, S3C_TCMPB(channel));
+
+	/* start the timer running */
+	s3c6410_pwm_start ( channel);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(s3c6410_timer_setup);
+
+static irqreturn_t s3c6410_pwm_irq(int irq, void *devpw)
+{
+	s3c6410_pwm_chan_t *chan = (s3c6410_pwm_chan_t *)devpw;
+	void *dev=chan->dev;
+
+	/* modify the channel state */
+	s3c6410_pwm_buffdone(chan, dev);
+
+	return IRQ_HANDLED;
+}
+
+
+int s3c6410_pwm_request(pwmch_t  channel, s3c_pwm_client_t *client, void *dev)
+{
+	s3c6410_pwm_chan_t *chan = &s3c_chans[channel];
+	unsigned long flags;
+	int err;
+
+	pr_debug("pwm%d: s3c_request_pwm: client=%s, dev=%p\n",
+		 channel, client->name, dev);
+
+
+	local_irq_save(flags);
+
+
+	if (chan->in_use) {
+		if (client != chan->client) {
+			printk(KERN_ERR "pwm%d: already in use\n", channel);
+			local_irq_restore(flags);
+			return -EBUSY;
+		} else {
+			printk(KERN_ERR "pwm%d: client already has channel\n", channel);
+		}
+	}
+
+	chan->client = client;
+	chan->in_use = 1;
+	chan->dev = dev;
+
+	if (!chan->irq_claimed) {
+		pr_debug("pwm%d: %s : requesting irq %d\n",
+			 channel, __FUNCTION__, chan->irq);
+
+		err = request_irq(chan->irq, s3c6410_pwm_irq, IRQF_DISABLED,
+				  client->name, (void *)chan);
+
+		if (err) {
+			chan->in_use = 0;
+			local_irq_restore(flags);
+
+			printk(KERN_ERR "%s: cannot get IRQ %d for PWM %d\n",
+			       client->name, chan->irq, chan->number);
+			return err;
+		}
+
+		chan->irq_claimed = 1;
+		chan->irq_enabled = 1;
+	}
+
+	local_irq_restore(flags);
+
+	/* need to setup */
+
+	pr_debug("%s: channel initialised, %p\n", __FUNCTION__, chan);
+
+	return 0;
+}
+
+int s3c6410_pwm_free (pwmch_t channel, s3c_pwm_client_t *client)
+{
+	s3c6410_pwm_chan_t *chan = &s3c_chans[channel];
+	unsigned long flags;
+
+
+	local_irq_save(flags);
+
+	if (chan->client != client) {
+		printk(KERN_WARNING "pwm%d: possible free from different client (channel %p, passed %p)\n",
+		       channel, chan->client, client);
+	}
+
+	/* sort out stopping and freeing the channel */
+
+
+	chan->client = NULL;
+	chan->in_use = 0;
+
+	if (chan->irq_claimed)
+		free_irq(chan->irq, (void *)chan);
+	chan->irq_claimed = 0;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+
+int s3c6410_pwm_set_buffdone_fn(pwmch_t channel, s3c_pwm_cbfn_t rtn)
+{
+	s3c6410_pwm_chan_t *chan = &s3c_chans[channel];
+
+
+	pr_debug("%s: chan=%d, callback rtn=%p\n", __FUNCTION__, channel, rtn);
+
+	chan->callback_fn = rtn;
+
+	return 0;
+}
+
+
+#define s3c6410_pwm_suspend NULL
+#define s3c6410_pwm_resume  NULL
+
+struct sysdev_class pwm_sysclass = {
+	.name		= "s3c-pwm",
+	.suspend	= s3c6410_pwm_suspend,
+	.resume		= s3c6410_pwm_resume,
+};
+
+
+/* initialisation code */
+
+static int __init s3c6410_init_pwm(void)
+{
+	s3c6410_pwm_chan_t *cp;
+	int channel;
+	int ret;
+
+	printk("S3C PWM Driver, (c) 2006-2007 Samsung Electronics\n");
+
+	ret = sysdev_class_register(&pwm_sysclass);
+	if (ret != 0) {
+		printk(KERN_ERR "pwm sysclass registration failed\n");
+		return -ENODEV;
+	}
+
+	for (channel = 0; channel < S3C_PWM_CHANNELS; channel++) {
+		cp = &s3c_chans[channel];
+
+		memset(cp, 0, sizeof(s3c6410_pwm_chan_t));
+
+		cp->number = channel;
+		/* pwm channel irqs are in order.. */
+		cp->irq    = channel + IRQ_TIMER0;
+
+		/* register system device */
+
+		ret = sysdev_register(&cp->sysdev);
+
+		pr_debug("PWM channel %d , irq %d\n",
+		       cp->number,  cp->irq);
+	}
+
+	return ret;
+}
+__initcall(s3c6410_init_pwm);
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/pwm-s3c6410.h linux-2.6.29-spica/arch/arm/plat-s3c64xx/pwm-s3c6410.h
--- linux-2.6.29/arch/arm/plat-s3c64xx/pwm-s3c6410.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/pwm-s3c6410.h	2010-05-06 12:42:45.634864134 +0700
@@ -0,0 +1,124 @@
+/* arch/arm/plat-s3c64xx/pwm-s3c6410.h
+ *
+ * Copyright (C) 2003,2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Samsung S3C PWM support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Changelog:
+ *  ??-May-2003 BJD   Created file
+ *  ??-Jun-2003 BJD   Added more dma functionality to go with arch
+ *  10-Nov-2004 BJD   Added sys_device support
+*/
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H __FILE__
+
+#include <linux/sysdev.h>
+#include <plat/regs-timer.h>
+
+#define pwmch_t int
+
+/* we have 4 pwm channels */
+#define S3C_PWM_CHANNELS        4
+
+
+struct s3c_pwm_client {
+	char                *name;
+};
+
+typedef struct s3c_pwm_client s3c_pwm_client_t;
+
+
+typedef struct s3c_pwm_chan_s s3c6410_pwm_chan_t;
+
+/* s3c_pwm_cbfn_t
+ *
+ * buffer callback routine type
+*/
+
+typedef void (*s3c_pwm_cbfn_t)(void *buf);
+
+
+
+/* struct s3c_pwm_chan_s
+ *
+ * full state information for each DMA channel
+*/
+
+struct s3c_pwm_chan_s {
+	/* channel state flags and information */
+	unsigned char          number;      /* number of this dma channel */
+	unsigned char          in_use;      /* channel allocated */
+	unsigned char          irq_claimed; /* irq claimed for channel */
+	unsigned char          irq_enabled; /* irq enabled for channel */
+
+	/* channel state */
+
+	s3c_pwm_client_t  *client;
+	void 	*dev;
+	/* channel configuration */
+	unsigned int           flags;        /* channel flags */
+
+	/* channel's hardware position and configuration */
+	unsigned int           irq;          /* channel irq */
+
+	/* driver handles */
+	s3c_pwm_cbfn_t     callback_fn;  /* buffer done callback */
+
+	/* system device */
+	struct sys_device	sysdev;
+};
+
+/* the currently allocated channel information */
+extern s3c6410_pwm_chan_t s3c_chans[];
+
+
+/* functions --------------------------------------------------------------- */
+
+/* s3c6410_pwm_request
+ *
+ * request a pwm channel exclusivley
+*/
+
+extern int s3c6410_pwm_request(pwmch_t channel, s3c_pwm_client_t *, void *dev);
+
+
+/* s3c_dma_ctrl
+ *
+ * change the state of the dma channel
+*/
+
+//extern int s3c_dma_ctrl(dmach_t channel, s3c_chan_op_t op);
+
+/* s3c_dma_setflags
+ *
+ * set the channel's flags to a given state
+*/
+
+
+/* s3c6410_pwm_free
+ *
+ * free the dma channel (will also abort any outstanding operations)
+*/
+
+extern int s3c6410_pwm_free(pwmch_t channel, s3c_pwm_client_t *);
+
+
+/* s3c_dma_config
+ *
+ * configure the dma channel
+*/
+
+
+
+
+extern int s3c6410_pwm_set_buffdone_fn(pwmch_t, s3c_pwm_cbfn_t rtn);
+
+extern int s3c6410_timer_setup (int channel, int usec, unsigned long g_tcnt, unsigned long g_tcmp);
+
+#endif /* __ASM_ARCH_DMA_H */
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/s3c64xx-adcts.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/s3c64xx-adcts.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/s3c64xx-adcts.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/s3c64xx-adcts.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,664 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/kthread.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#include <asm/uaccess.h>
+
+#include <plat/regs-adc.h>
+#include <plat/adcts.h>
+#include <plat/ts.h>
+#include <mach/irqs.h>
+
+//#define S3C_ADCTS_DEBUG
+
+#ifdef CONFIG_TOUCHSCREEN_S3C
+
+#define WAIT4INT_OFF(x)  (((x)<<8) | \
+                     S3C_ADCTSC_YM_SEN | S3C_ADCTSC_YP_SEN | S3C_ADCTSC_XP_SEN | \
+                     S3C_ADCTSC_XY_PST(0))
+
+#define WAIT4INT_ON(x)  (((x)<<8) | \
+                     S3C_ADCTSC_YM_SEN | S3C_ADCTSC_YP_SEN | S3C_ADCTSC_XP_SEN | \
+                     S3C_ADCTSC_XY_PST(3))
+ 
+#define AUTOPST      (S3C_ADCTSC_YM_SEN | S3C_ADCTSC_YP_SEN | S3C_ADCTSC_XP_SEN | \
+                     S3C_ADCTSC_AUTO_PST | S3C_ADCTSC_XY_PST(0))
+
+#define TS_START(r,p)   (r) | S3C_ADCCON_PRSCEN | S3C_ADCCON_PRSCVL(p) | \
+			S3C_ADCCON_ENABLE_START
+
+#define INT_MODE_UP			1
+#define INT_MODE_DOWN			0
+#define CHANNEL_MASK	 (0x7FF)  	  	/* ADC0 ~ ADC7 and TS, TS_UP */
+
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+
+#define ADC_START(r,p,x)   (r) | S3C_ADCCON_PRSCEN | S3C_ADCCON_PRSCVL(p) | \
+			S3C_ADCCON_SELMUX(x) | S3C_ADCCON_ENABLE_START
+#define ADC_STOP	S3C_ADCCON_RESSEL_12BIT | S3C_ADCCON_PRSCEN | S3C_ADCCON_PRSCVL(0xff)
+
+#define WAIT_EVENT_TIMEOUT		(HZ/20)					/* 50ms */
+#define ADC_RETRY_NUM			5					/* 5 times */
+#define SLEEP_TIMEOUT			(WAIT_EVENT_TIMEOUT*(ADC_RETRY_NUM-1))	/* 200ms */
+
+#define CHANNEL_ADC_MASK (0xFF)    		/* ADC0 ~ ADC7 */
+
+/*  global struct & variable definition */
+enum ADCTS_THREAD_STATE {
+	ADCTS_THREAD_NONE=0,
+	ADCTS_THREAD_RUN,
+	ADCTS_THREAD_WAIT,
+	ADCTS_THREAD_SLEEP,
+	ADCTS_THREAD_WAKEUP,
+	ADCTS_THEAD_TERMINATED
+};
+
+enum ADCTS_DRIVER_STATE {
+	ADCTS_DRIVER_PROBE = 0,
+	ADCTS_DRIVER_SUSPEND,
+	ADCTS_DRIVER_RESUME,
+	ADCTS_DRIVER_REMOVE
+};
+enum ADCTS_CHANNEL_STATE {
+	CHANNEL_NOT_SELECTED=-2,
+	CHANNEL_ADC_DONE=-1,
+	CHANNEL_ADC0=0,
+	CHANNEL_ADC1,
+	CHANNEL_ADC2,
+	CHANNEL_ADC3,
+	CHANNEL_ADC4,
+	CHANNEL_ADC5,
+	CHANNEL_ADC6,
+	CHANNEL_ADC7,
+#ifdef CONFIG_TOUCHSCREEN_S3C
+	CHANNEL_TS,
+	CHANNEL_TS_SCANNING,
+	CHANNEL_TS_UP
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+};
+
+static struct clk			*adc_clock;
+static void __iomem 			*base_addr;
+static unsigned int 			irq_adc;
+
+static struct s3c_adcts_channel_info 	adc[MAX_ADC_CHANNEL];
+
+static wait_queue_head_t 		adc_wait[MAX_ADC_CHANNEL];
+static wait_queue_head_t		adcts_thread_wait;
+static struct task_struct     		*adcts_thread_task; 
+static int 				adc_value[MAX_ADC_CHANNEL];
+
+static int				adcts_thread_state;
+static int				adc_thread_state[MAX_ADC_CHANNEL];
+static int				adcts_driver_state;
+static int				channel_state;
+static unsigned int 			adcts_request_flag =0;
+
+#ifdef CONFIG_TOUCHSCREEN_S3C
+static unsigned int 			irq_updown;
+static struct s3c_ts_mach_info 		*ts;
+static struct s3c_adcts_value 		ts_value;
+static int 				ts_int_mode;
+static int 				ts_sampling_count;
+
+static void ts_timer_fire(unsigned long data);
+static struct timer_list ts_timer =	TIMER_INITIALIZER(ts_timer_fire, 0, 0);
+static void (*ts_done_callbacks)(struct s3c_adcts_value *ts_values);
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+
+//////////////////////////////////////////////////////////////////////////
+
+static inline void start_hw_adc (int channel)
+{
+	writel (adc[channel].delay, base_addr + S3C_ADCDLY);
+	writel (ADC_START(adc[channel].resol, adc[channel].presc, channel), base_addr+S3C_ADCCON);
+}
+
+#ifdef CONFIG_TOUCHSCREEN_S3C
+static inline void start_hw_ts (void)
+{
+//	writel (WAIT4INT_ON(ts_int_mode), base_addr+S3C_ADCTSC);
+	writel (ts->adcts.delay, base_addr + S3C_ADCDLY);
+//	writel ((ts_int_mode<<8) | S3C_ADCTSC_PULL_UP_DISABLE | AUTOPST, base_addr+S3C_ADCTSC);
+	writel (S3C_ADCTSC_PULL_UP_DISABLE | AUTOPST, base_addr+S3C_ADCTSC);
+	writel (TS_START(ts->adcts.resol, ts->adcts.presc), base_addr+S3C_ADCCON);
+}
+
+static inline void change_ts_int_mode(int int_mode)
+{
+	ts_int_mode = int_mode;
+	writel(WAIT4INT_ON(int_mode), base_addr+S3C_ADCTSC);
+}
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+
+static inline void stop_hw (void)
+{
+	writel (ADC_STOP, base_addr+S3C_ADCCON);
+}
+
+static void _request_adcts(int channel)
+{
+#ifdef CONFIG_TOUCHSCREEN_S3C
+	/* if TS flags exists, TS flag should be cleared */
+	if (channel == CHANNEL_TS_UP)
+		adcts_request_flag &= ~((1<<CHANNEL_TS)|(1<<CHANNEL_TS_SCANNING));
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+		
+	adcts_request_flag |= (1<<channel);
+
+	if (adcts_thread_state == ADCTS_THREAD_SLEEP)
+	{
+		adcts_thread_state = ADCTS_THREAD_WAKEUP;
+		wake_up_interruptible(&adcts_thread_wait);
+	}
+}
+
+#ifdef CONFIG_TOUCHSCREEN_S3C
+static void ts_timer_fire(unsigned long data)
+{
+	_request_adcts(CHANNEL_TS);
+}
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+
+static irqreturn_t irqhandler_adc_done(int irqno, void *param)
+{
+	unsigned long data0;
+	unsigned long data1;
+
+	stop_hw();
+
+	data0 = readl(base_addr+S3C_ADCDAT0);
+	data1 = readl(base_addr+S3C_ADCDAT1);
+				
+	if (channel_state>=CHANNEL_ADC0 && channel_state<=CHANNEL_ADC7)	// adc
+	{
+		if (adc_thread_state[channel_state] == ADCTS_THREAD_WAIT)
+		{
+			adc_thread_state[channel_state] = ADCTS_THREAD_WAKEUP;
+			wake_up_interruptible(&adc_wait[channel_state]);
+
+			adc_value[channel_state] = data0 & S3C_ADCDAT0_XPDATA_MASK_12BIT;
+			channel_state = CHANNEL_ADC_DONE;
+		}
+	}
+#ifdef CONFIG_TOUCHSCREEN_S3C
+	else if (channel_state == CHANNEL_TS)				// ts
+	{
+		int ts_status = (!(data0 & S3C_ADCDAT0_UPDOWN)) && (!(data1 & S3C_ADCDAT1_UPDOWN));
+		if (ts_status)
+		{
+			change_ts_int_mode (INT_MODE_UP);
+
+			ts_value.xp[ts_sampling_count] = data0 & S3C_ADCDAT0_XPDATA_MASK_12BIT;	
+			ts_value.yp[ts_sampling_count] = data1 & S3C_ADCDAT1_YPDATA_MASK_12BIT;
+			ts_sampling_count++;
+		}
+		else
+		{
+			_request_adcts(CHANNEL_TS_UP);
+			change_ts_int_mode (INT_MODE_DOWN);
+		}
+		channel_state = CHANNEL_ADC_DONE;
+	}
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+
+	if (channel_state==CHANNEL_ADC_DONE && adcts_thread_state==ADCTS_THREAD_WAIT)
+	{
+		adcts_thread_state = ADCTS_THREAD_WAKEUP;
+		wake_up_interruptible(&adcts_thread_wait);
+	}
+
+	writel(0x1, base_addr+S3C_ADCCLRINT);
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_TOUCHSCREEN_S3C
+static irqreturn_t irqhandler_updown(int irqno, void *param)
+{
+	unsigned long data0, data1;
+	int	ts_status;
+
+	data0 = readl(base_addr+S3C_ADCDAT0);
+	data1 = readl(base_addr+S3C_ADCDAT1);
+ 
+	ts_status = (!(data0 & S3C_ADCDAT0_UPDOWN)) && (!(data1 & S3C_ADCDAT1_UPDOWN));
+
+//#ifdef S3C_ADCTS_DEBUG
+#if 1
+	printk ("%s: %c\n", __func__, ts_status?'D':'U');
+#endif
+
+	if (ts_status) 		// down
+	{
+		_request_adcts(CHANNEL_TS);
+		change_ts_int_mode (INT_MODE_UP);
+	}
+	else 				// up
+	{
+		_request_adcts(CHANNEL_TS_UP);
+		change_ts_int_mode (INT_MODE_DOWN);
+	}
+
+	writel (0x0, base_addr+S3C_ADCUPDN);
+	writel (0x1, base_addr+S3C_ADCCLRINTPNDNUP);
+
+	return IRQ_HANDLED;
+}
+
+int s3c_adcts_register_ts (struct s3c_ts_mach_info *ts_cfg,
+                           void (*done_callback)(struct s3c_adcts_value *ts_value))
+{
+	ts = ts_cfg;
+	ts_done_callbacks = done_callback;
+
+	change_ts_int_mode (INT_MODE_DOWN);
+	enable_irq (IRQ_PENDN);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(s3c_adcts_register_ts);
+
+int s3c_adcts_unregister_ts (void)
+{
+	ts_done_callbacks = NULL;
+	disable_irq (IRQ_PENDN);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(s3c_adcts_unregister_ts);
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+
+int s3c_adc_get_adc_data(int channel)
+{
+	int i;
+
+	if(channel >= MAX_ADC_CHANNEL || channel < 0) return -EINVAL;
+
+	if (adcts_request_flag & (1<<channel))
+		return -EINVAL;
+
+	for (i=0; i< ADC_RETRY_NUM ; i++)
+	{
+		_request_adcts (channel);
+
+		adc_thread_state[channel] = ADCTS_THREAD_WAIT;
+	        wait_event_interruptible_timeout (adc_wait[channel],
+			adc_thread_state[channel]!=ADCTS_THREAD_WAIT, WAIT_EVENT_TIMEOUT);
+                
+		if (adc_thread_state[channel] == ADCTS_THREAD_WAIT)
+		{
+		}
+	        else 
+			break;
+	}
+
+	if (i==ADC_RETRY_NUM)
+	{
+		printk ("%s: wait_event timeout\n",__func__);
+		return -EINVAL;
+	}
+
+#ifdef S3C_ADCTS_DEBUG
+	printk ("%s: value= %d\n", __func__, adc_value[channel]);
+#endif
+	return adc_value[channel];
+}
+
+EXPORT_SYMBOL(s3c_adc_get_adc_data);
+
+static void _adcts_main_thread_sleep (void)
+{
+	if (adcts_request_flag)
+		return;
+
+	adcts_thread_state = ADCTS_THREAD_SLEEP;
+       	wait_event_interruptible_timeout (adcts_thread_wait, adcts_thread_state!=ADCTS_THREAD_SLEEP, SLEEP_TIMEOUT);
+
+	adcts_thread_state = ADCTS_THREAD_RUN;
+}
+
+#ifdef CONFIG_TOUCHSCREEN_S3C
+static void _adcts_main_thread_ts (void)
+{
+	if (adcts_request_flag & (1<<CHANNEL_TS_UP)) 
+	{
+		stop_hw();
+
+		adcts_request_flag &= ~(1<<CHANNEL_TS_UP);
+		ts_value.status = TS_STATUS_UP;
+
+		ts_done_callbacks(&ts_value);
+		return;
+	}
+
+
+	if (adcts_request_flag & ((1<<CHANNEL_TS)|(1<<CHANNEL_TS_SCANNING)))
+	{
+		if ( ts_int_mode == INT_MODE_DOWN)
+		{
+			adcts_request_flag &= ~((1<<CHANNEL_TS)|(1<<CHANNEL_TS_SCANNING));
+			return;
+		}
+
+		if (adcts_request_flag & (1<<CHANNEL_TS))
+		{
+			ts_sampling_count = 0;
+			adcts_request_flag &= ~(1<<CHANNEL_TS);
+			adcts_request_flag |= (1<<CHANNEL_TS_SCANNING);
+		}
+
+
+		channel_state=CHANNEL_TS;
+		start_hw_ts();
+
+		adcts_thread_state = ADCTS_THREAD_WAIT;
+        	wait_event_interruptible_timeout (adcts_thread_wait,
+			adcts_thread_state!=ADCTS_THREAD_WAIT, WAIT_EVENT_TIMEOUT);
+	
+		if (ts_sampling_count >= ts->sampling_time) 
+		{
+			change_ts_int_mode(INT_MODE_UP);
+
+			adcts_request_flag &= ~(1<<CHANNEL_TS_SCANNING);
+			ts_value.status = TS_STATUS_DOWN;
+
+			ts_done_callbacks(&ts_value);
+			mod_timer (&ts_timer, jiffies + (ts->sampling_interval_ms/(1000/HZ)));
+		}
+	}
+}
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+
+static void _adcts_main_thread_adc (void)
+{
+	int i;
+
+	for (i=CHANNEL_ADC0; (adcts_request_flag&CHANNEL_ADC_MASK) && (i<=CHANNEL_ADC7); i++)
+	{
+		if (adcts_request_flag & (1<<i))
+		{
+			channel_state=i;
+			adcts_request_flag &= ~(1<<i);
+			start_hw_adc(i);
+			adcts_thread_state = ADCTS_THREAD_WAIT;
+	        	wait_event_interruptible_timeout (adcts_thread_wait,
+				adcts_thread_state!=ADCTS_THREAD_WAIT, WAIT_EVENT_TIMEOUT);
+		}
+	}
+}
+
+static int adcts_main_thread(void *data)
+{
+	/* change priority to RT scduler and priority 99 */
+	struct sched_param param = { .sched_priority = MAX_RT_PRIO-1 };
+	sched_setscheduler_nocheck(current, SCHED_FIFO, &param);
+
+	adcts_thread_state = ADCTS_THREAD_RUN;
+	channel_state = CHANNEL_NOT_SELECTED;
+
+	printk ("kadctsd is started\n");
+
+	while (adcts_driver_state!=ADCTS_DRIVER_REMOVE)
+	{
+#ifdef CONFIG_TOUCHSCREEN_S3C
+		/* make sure flag is available */
+		if (ts_done_callbacks != NULL)
+			adcts_request_flag &= CHANNEL_MASK;
+		else
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+			adcts_request_flag &= CHANNEL_ADC_MASK;
+
+		_adcts_main_thread_sleep();
+#ifdef CONFIG_TOUCHSCREEN_S3C
+		_adcts_main_thread_ts();
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+		_adcts_main_thread_adc();
+	}
+	return 0;
+}
+
+
+/*
+ * The functions for inserting/removing us as a module.
+ */
+
+static int __init s3c_adcts_probe(struct platform_device *pdev)
+{
+	struct resource	*res;
+	struct device *dev;
+	int ret, i;
+	int size;
+	struct s3c_adcts_plat_info *s3c_adc_cfg;
+
+	adcts_thread_state = ADCTS_THREAD_NONE;
+	adcts_driver_state = ADCTS_DRIVER_PROBE;
+
+	for (i=CHANNEL_ADC0 ; i<=CHANNEL_ADC7; i++)
+		adc_thread_state[i] = ADCTS_THREAD_RUN;
+
+	dev = &pdev->dev;
+
+	s3c_adc_cfg = (struct s3c_adcts_plat_info *) dev->platform_data;
+        if (s3c_adc_cfg == NULL)
+                return -EINVAL;
+
+	memcpy (&adc, s3c_adc_cfg, sizeof(struct s3c_adcts_plat_info));
+	
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(res == NULL){
+		dev_err(dev,"no memory resource specified\n");
+		ret = -ENOENT;
+		goto get_resource_fail;
+	}
+
+	size = (res->end - res->start) + 1;
+	
+	base_addr = ioremap(res->start, size);
+	if(base_addr ==  NULL){
+		dev_err(dev,"fail to ioremap() region\n");
+		ret = -ENOENT;
+		goto err_map;
+	}
+	
+	adc_clock = clk_get(&pdev->dev, "adc");
+
+	if(IS_ERR(adc_clock)){
+		dev_err(dev,"failed to fine ADC clock source\n");
+		ret = PTR_ERR(adc_clock);
+		goto err_clk;
+	}
+
+	clk_enable(adc_clock);
+
+	stop_hw();
+#ifdef CONFIG_TOUCHSCREEN_S3C
+	ts_done_callbacks = NULL;
+
+	change_ts_int_mode (INT_MODE_DOWN);
+
+        /* For IRQ_PENDUP */
+        res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+        if (res == NULL) {
+                dev_err(dev, "no irq resource specified\n");
+                ret = -ENOENT;
+                goto err_irq_updown;
+        }
+ 
+	irq_updown = res->start;
+	printk ("%s: irq_updown = %d\n", __func__, irq_updown);
+
+        ret = request_irq(irq_updown, irqhandler_updown, IRQF_SAMPLE_RANDOM, "s3c_updown", NULL);
+        if (ret != 0) {
+                dev_err(dev,"s3c_ts.c: Could not allocate ts IRQ_PENDN !\n");
+                ret = -EIO;
+                goto err_irq_updown;
+        }
+	disable_irq (irq_updown);
+ #endif /* CONFIG_TOUCHSCREEN_S3C */
+
+        /* For IRQ_ADC */
+        res = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
+        if (res == NULL) {
+                dev_err(dev, "no irq resource specified\n");
+                ret = -ENOENT;
+                goto err_irq_adc;
+        }
+        irq_adc = res->start;
+	printk ("%s: irq_adc = %d\n", __func__,irq_adc);
+        ret = request_irq(irq_adc, irqhandler_adc_done, IRQF_SAMPLE_RANDOM, "s3c_act_done", NULL);
+        if (ret != 0) {
+                dev_err(dev, "s3c_ts.c: Could not allocate ts IRQ_ADC !\n");
+                ret =  -EIO;
+                goto err_irq_adc;
+        }
+
+	for (i=0; i<MAX_ADC_CHANNEL; i++)
+	{
+		init_waitqueue_head (&adc_wait[i]);
+	}
+	init_waitqueue_head (&adcts_thread_wait);
+
+	adcts_thread_task = kthread_run(adcts_main_thread, NULL, "kadctsd");
+
+	printk(KERN_INFO "S3C64XX ADCTS driver successfully probed !\n");
+
+	return 0;
+
+err_irq_adc:
+#ifdef CONFIG_TOUCHSCREEN_S3C
+        free_irq(irq_updown, pdev);
+
+err_irq_updown:
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+	clk_disable(adc_clock);
+	clk_put(adc_clock);
+
+
+err_clk:
+	iounmap(base_addr);
+
+err_map:
+get_resource_fail:
+	adcts_driver_state = ADCTS_DRIVER_REMOVE;
+
+	return ret;
+}
+
+
+static int s3c_adcts_remove(struct platform_device *pdev)
+{
+	adcts_driver_state = ADCTS_DRIVER_REMOVE;	
+
+	kthread_stop (adcts_thread_task);
+	free_irq(irq_adc, pdev);
+#ifdef CONFIG_TOUCHSCREEN_S3C
+	free_irq(irq_updown, pdev);
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+	clk_disable(adc_clock);
+	clk_put(adc_clock);
+	iounmap(base_addr);
+	printk(KERN_INFO "s3c_adc_remove() of ADC called !\n");
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int s3c_adcts_suspend(struct platform_device *dev, pm_message_t state)
+{
+	adcts_driver_state = ADCTS_DRIVER_SUSPEND;	
+	stop_hw();
+	clk_disable(adc_clock);
+
+	return 0;
+}
+
+static int s3c_adcts_resume(struct platform_device *pdev)
+{
+	int i;
+	adcts_driver_state = ADCTS_DRIVER_RESUME;
+
+	clk_enable(adc_clock);
+
+	for (i=0; i<MAX_ADC_CHANNEL;i++)
+	{
+		if (adcts_request_flag & (1<<i))
+		{
+			adc_value[i] = -1;
+			wake_up_interruptible(&adc_wait[i]);
+		}
+	}
+			
+	adcts_request_flag = 0;
+	channel_state = CHANNEL_NOT_SELECTED;
+#ifdef CONFIG_TOUCHSCREEN_S3C
+	change_ts_int_mode (INT_MODE_DOWN);
+#endif /* CONFIG_TOUCHSCREEN_S3C */
+
+	return 0;
+}
+#else
+#define s3c_adc_suspend NULL
+#define s3c_adc_resume  NULL
+#endif
+
+static struct platform_driver s3c_adcts_driver = {
+       .probe          = s3c_adcts_probe,
+       .remove         = s3c_adcts_remove,
+       .suspend        = s3c_adcts_suspend,
+       .resume         = s3c_adcts_resume,
+       .driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c-adcts",
+	},
+};
+
+static char banner[] __initdata = KERN_INFO "S3C64XX ADC/TS driver, (c) 2009 Samsung Electronics\n";
+
+int __init s3c_adcts_init(void)
+{
+	printk(banner);
+	return platform_driver_register(&s3c_adcts_driver);
+}
+
+void __exit s3c_adcts_exit(void)
+{
+	platform_driver_unregister(&s3c_adcts_driver);
+}
+
+module_init(s3c_adcts_init);
+module_exit(s3c_adcts_exit);
+
+MODULE_AUTHOR("eunki_kim@samsung.com>");
+MODULE_DESCRIPTION("S3C64XX ADC/TS driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/s3c64xx-clock.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/s3c64xx-clock.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/s3c64xx-clock.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/s3c64xx-clock.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,856 @@
+/* linux/arch/arm/plat-s3c64xx/s3c64xx-clock.c
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C64XX based common clock support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/sysdev.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+#include <mach/map.h>
+
+#include <plat/cpu-freq.h>
+
+#include <plat/regs-clock.h>
+#include <plat/clock.h>
+#include <plat/cpu.h>
+#include <plat/pll.h>
+
+/* fin_apll, fin_mpll and fin_epll are all the same clock, which we call
+ * ext_xtal_mux for want of an actual name from the manual.
+*/
+
+struct clk clk_ext_xtal_mux = {
+	.name		= "ext_xtal",
+	.id		= -1,
+};
+
+#define clk_fin_apll clk_ext_xtal_mux
+#define clk_fin_mpll clk_ext_xtal_mux
+#define clk_fin_epll clk_ext_xtal_mux
+
+#define clk_fout_mpll	clk_mpll
+
+struct clk_sources {
+	unsigned int	nr_sources;
+	struct clk	**sources;
+};
+
+struct clksrc_clk {
+	struct clk		clk;
+	unsigned int		mask;
+	unsigned int		shift;
+
+	struct clk_sources	*sources;
+
+	unsigned int		divider_mask;
+	unsigned int		divider_shift;
+	void __iomem		*reg_divider;
+};
+
+struct clk clk_fout_apll = {
+	.name		= "fout_apll",
+	.id		= -1,
+};
+
+static struct clk *clk_src_apll_list[] = {
+	[0] = &clk_fin_apll,
+	[1] = &clk_fout_apll,
+};
+
+static struct clk_sources clk_src_apll = {
+	.sources	= clk_src_apll_list,
+	.nr_sources	= ARRAY_SIZE(clk_src_apll_list),
+};
+
+struct clksrc_clk clk_mout_apll = {
+	.clk	= {
+		.name		= "mout_apll",
+		.id		= -1,
+	},
+	.shift		= S3C6400_CLKSRC_APLL_MOUT_SHIFT,
+	.mask		= S3C6400_CLKSRC_APLL_MOUT,
+	.sources	= &clk_src_apll,
+};
+
+static inline struct clksrc_clk *to_clksrc(struct clk *clk)
+{
+	return container_of(clk, struct clksrc_clk, clk);
+}
+
+int fout_enable(struct clk *clk, int enable)
+{
+	unsigned int ctrlbit = clk->ctrlbit;
+	unsigned int epll_con0 = __raw_readl(S3C_EPLL_CON0) & ~ ctrlbit;
+
+	if(enable)
+	   __raw_writel(epll_con0 | ctrlbit, S3C_EPLL_CON0);
+	else
+	   __raw_writel(epll_con0, S3C_EPLL_CON0);
+
+	return 0;
+}
+
+unsigned long fout_get_rate(struct clk *clk)
+{
+	return clk->rate;
+}
+
+int fout_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int epll_con0, epll_con1;
+
+	if(clk->rate == rate)	/* Return if nothing changed */
+		return 0;
+
+	epll_con0 = __raw_readl(S3C_EPLL_CON0);
+	epll_con1 = __raw_readl(S3C_EPLL_CON1);
+
+	epll_con0 &= ~(S3C64XX_EPLL_CON0_M_MASK | S3C64XX_EPLL_CON0_P_MASK | S3C64XX_EPLL_CON0_S_MASK);
+	epll_con1 &= ~(S3C64XX_EPLL_CON1_K_MASK);
+
+	switch (rate){
+	case 36000000:
+			epll_con1 |= (0 << S3C64XX_EPLL_CON1_K_SHIFT);
+			epll_con0 |= (48 << S3C64XX_EPLL_CON0_M_SHIFT) |
+					(1 << S3C64XX_EPLL_CON0_P_SHIFT) |
+					(4 << S3C64XX_EPLL_CON0_S_SHIFT);
+			break;
+	case 48000000:
+			epll_con1 |= (0 << S3C64XX_EPLL_CON1_K_SHIFT);
+			epll_con0 |= (32 << S3C64XX_EPLL_CON0_M_SHIFT) |
+					(1 << S3C64XX_EPLL_CON0_P_SHIFT) |
+					(3 << S3C64XX_EPLL_CON0_S_SHIFT);
+			break;
+	case 60000000:
+			epll_con1 |= (0 << S3C64XX_EPLL_CON1_K_SHIFT);
+			epll_con0 |= (40 << S3C64XX_EPLL_CON0_M_SHIFT) |
+					(1 << S3C64XX_EPLL_CON0_P_SHIFT) |
+					(3 << S3C64XX_EPLL_CON0_S_SHIFT);
+			break;
+	case 72000000:
+			epll_con1 |= (0 << S3C64XX_EPLL_CON1_K_SHIFT);
+			epll_con0 |= (48 << S3C64XX_EPLL_CON0_M_SHIFT) |
+					(1 << S3C64XX_EPLL_CON0_P_SHIFT) |
+					(3 << S3C64XX_EPLL_CON0_S_SHIFT);
+			break;
+	case 84000000:
+			epll_con1 |= (0 << S3C64XX_EPLL_CON1_K_SHIFT);
+			epll_con0 |= (28 << S3C64XX_EPLL_CON0_M_SHIFT) |
+					(1 << S3C64XX_EPLL_CON0_P_SHIFT) |
+					(2 << S3C64XX_EPLL_CON0_S_SHIFT);
+			break;
+	case 96000000:
+			epll_con1 |= (0 << S3C64XX_EPLL_CON1_K_SHIFT);
+			epll_con0 |= (32 << S3C64XX_EPLL_CON0_M_SHIFT) |
+					(1 << S3C64XX_EPLL_CON0_P_SHIFT) |
+					(2 << S3C64XX_EPLL_CON0_S_SHIFT);
+			break;
+	case 32768000:
+			epll_con1 |= (45264 << S3C64XX_EPLL_CON1_K_SHIFT);
+			epll_con0 |= (43 << S3C64XX_EPLL_CON0_M_SHIFT) |
+					(1 << S3C64XX_EPLL_CON0_P_SHIFT) |
+					(4 << S3C64XX_EPLL_CON0_S_SHIFT);
+			break;
+	case 45158000:
+			epll_con1 |= (6903 << S3C64XX_EPLL_CON1_K_SHIFT);
+			epll_con0 |= (30 << S3C64XX_EPLL_CON0_M_SHIFT) |
+					(1 << S3C64XX_EPLL_CON0_P_SHIFT) |
+					(3 << S3C64XX_EPLL_CON0_S_SHIFT);
+			break;
+	case 49152000:
+			epll_con1 |= (50332 << S3C64XX_EPLL_CON1_K_SHIFT);
+			epll_con0 |= (32 << S3C64XX_EPLL_CON0_M_SHIFT) |
+					(1 << S3C64XX_EPLL_CON0_P_SHIFT) |
+					(3 << S3C64XX_EPLL_CON0_S_SHIFT);
+			break;
+	case 67738000:
+			epll_con1 |= (10398 << S3C64XX_EPLL_CON1_K_SHIFT);
+			epll_con0 |= (45 << S3C64XX_EPLL_CON0_M_SHIFT) |
+					(1 << S3C64XX_EPLL_CON0_P_SHIFT) |
+					(3 << S3C64XX_EPLL_CON0_S_SHIFT);
+			break;
+	case 73728000:
+			epll_con1 |= (9961 << S3C64XX_EPLL_CON1_K_SHIFT);
+			epll_con0 |= (49 << S3C64XX_EPLL_CON0_M_SHIFT) |
+					(1 << S3C64XX_EPLL_CON0_P_SHIFT) |
+					(3 << S3C64XX_EPLL_CON0_S_SHIFT);
+			break;
+	default:
+			printk(KERN_ERR "Invalid Clock Freq!\n");
+			return -EINVAL;
+	}
+
+	__raw_writel(epll_con0, S3C_EPLL_CON0);
+	__raw_writel(epll_con1, S3C_EPLL_CON1);
+
+	clk->rate = rate;
+
+	return 0;
+}
+
+struct clk clk_fout_epll = {
+	.name		= "fout_epll",
+	.id		= -1,
+	.ctrlbit	= (1<<31),
+	.enable		= fout_enable,
+	.get_rate	= fout_get_rate,
+	.set_rate	= fout_set_rate,
+};
+
+int mout_set_parent(struct clk *clk, struct clk *parent)
+{
+	int src_nr = -1;
+	int ptr;
+	u32 clksrc;
+	struct clksrc_clk *sclk = to_clksrc(clk);
+	struct clk_sources *srcs = sclk->sources;
+
+	clksrc = __raw_readl(S3C_CLK_SRC);
+
+	for (ptr = 0; ptr < srcs->nr_sources; ptr++)
+		if (srcs->sources[ptr] == parent) {
+			src_nr = ptr;
+			break;
+		}
+
+	if (src_nr >= 0) {
+		clksrc &= ~sclk->mask;
+		clksrc |= src_nr << sclk->shift;
+		__raw_writel(clksrc, S3C_CLK_SRC);
+		clk->parent = parent;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static struct clk *clk_src_epll_list[] = {
+	[0] = &clk_fin_epll,
+	[1] = &clk_fout_epll,
+};
+
+static struct clk_sources clk_src_epll = {
+	.sources	= clk_src_epll_list,
+	.nr_sources	= ARRAY_SIZE(clk_src_epll_list),
+};
+
+struct clksrc_clk clk_mout_epll = {
+	.clk	= {
+		.name		= "mout_epll",
+		.id		= -1,
+		.set_parent	= mout_set_parent,
+	},
+	.shift		= S3C6400_CLKSRC_EPLL_MOUT_SHIFT,
+	.mask		= S3C6400_CLKSRC_EPLL_MOUT,
+	.sources	= &clk_src_epll,
+};
+
+static struct clk *clk_src_mpll_list[] = {
+	[0] = &clk_fin_mpll,
+	[1] = &clk_fout_mpll,
+};
+
+static struct clk_sources clk_src_mpll = {
+	.sources	= clk_src_mpll_list,
+	.nr_sources	= ARRAY_SIZE(clk_src_mpll_list),
+};
+
+struct clksrc_clk clk_mout_mpll = {
+	.clk = {
+		.name		= "mout_mpll",
+		.id		= -1,
+	},
+	.shift		= S3C6400_CLKSRC_MPLL_MOUT_SHIFT,
+	.mask		= S3C6400_CLKSRC_MPLL_MOUT,
+	.sources	= &clk_src_mpll,
+};
+
+static unsigned long s3c64xx_clk_doutmpll_get_rate(struct clk *clk)
+{
+	unsigned long rate = clk_get_rate(clk->parent);
+
+	printk(KERN_DEBUG "%s: parent is %ld\n", __func__, rate);
+
+	if (__raw_readl(S3C_CLK_DIV0) & S3C6400_CLKDIV0_MPLL_MASK)
+		rate /= 2;
+
+	return rate;
+}
+
+struct clk clk_dout_mpll = {
+	.name		= "dout_mpll",
+	.id		= -1,
+	.parent		= &clk_mout_mpll.clk,
+	.get_rate	= s3c64xx_clk_doutmpll_get_rate,
+};
+
+static struct clk *clkset_spi_mmc_list[] = {
+	&clk_mout_epll.clk,
+	&clk_dout_mpll,
+	&clk_fin_epll,
+	&clk_27m,
+};
+
+static struct clk_sources clkset_spi_mmc = {
+	.sources	= clkset_spi_mmc_list,
+	.nr_sources	= ARRAY_SIZE(clkset_spi_mmc_list),
+};
+
+static struct clk *clkset_irda_list[] = {
+	&clk_mout_epll.clk,
+	&clk_dout_mpll,
+	NULL,
+	&clk_27m,
+};
+
+static struct clk_sources clkset_irda = {
+	.sources	= clkset_irda_list,
+	.nr_sources	= ARRAY_SIZE(clkset_irda_list),
+};
+
+static struct clk *clkset_uart_list[] = {
+	&clk_mout_epll.clk,
+	&clk_dout_mpll,
+	NULL,
+	NULL
+};
+
+static struct clk_sources clkset_uart = {
+	.sources	= clkset_uart_list,
+	.nr_sources	= ARRAY_SIZE(clkset_uart_list),
+};
+
+static struct clk *clkset_uhost_list[] = {
+	&clk_mout_epll.clk,
+	&clk_dout_mpll,
+	&clk_fin_epll,
+	&clk_48m,
+};
+
+static struct clk_sources clkset_uhost = {
+	.sources	= clkset_uhost_list,
+	.nr_sources	= ARRAY_SIZE(clkset_uhost_list),
+};
+
+static struct clk *clkset_lcd_list[] = {
+	&clk_mout_epll.clk,
+	&clk_dout_mpll,
+	&clk_fin_epll,
+	NULL
+};
+
+static struct clk_sources clkset_lcd = {
+	.sources	= clkset_lcd_list,
+	.nr_sources	= ARRAY_SIZE(clkset_lcd_list),
+};
+
+static struct clk clk_iis_cd0 = {
+	.name		= "iis_cdclk0",
+	.id		= -1,
+};
+
+static struct clk clk_iis_cd1 = {
+	.name		= "iis_cdclk1",
+	.id		= -1,
+};
+
+static struct clk clk_pcm_cd = {
+	.name		= "pcm_cdclk",
+	.id		= -1,
+};
+
+static struct clk *clkset_audio0_list[] = {
+	[0] = &clk_mout_epll.clk,
+	[1] = &clk_dout_mpll,
+	[2] = &clk_fin_epll,
+	[3] = &clk_iis_cd0,
+	[4] = &clk_pcm_cd,
+};
+
+static struct clk_sources clkset_audio0 = {
+	.sources	= clkset_audio0_list,
+	.nr_sources	= ARRAY_SIZE(clkset_audio0_list),
+};
+
+/* The peripheral clocks are all controlled via clocksource followed
+ * by an optional divider and gate stage. We currently roll this into
+ * one clock which hides the intermediate clock from the mux.
+ *
+ * Note, the JPEG clock can only be an even divider...
+ *
+ * The scaler and LCD clocks depend on the S3C64XX version, and also
+ * have a common parent divisor so are not included here.
+ */
+
+static unsigned long s3c64xx_getrate_clksrc(struct clk *clk)
+{
+	struct clksrc_clk *sclk = to_clksrc(clk);
+	unsigned long rate = clk_get_rate(clk->parent);
+	u32 clkdiv = __raw_readl(sclk->reg_divider);
+
+	clkdiv >>= sclk->divider_shift;
+	clkdiv &= 0xf;
+	clkdiv++;
+
+	rate /= clkdiv;
+	return rate;
+}
+
+static int s3c64xx_setrate_clksrc(struct clk *clk, unsigned long rate)
+{
+	struct clksrc_clk *sclk = to_clksrc(clk);
+	void __iomem *reg = sclk->reg_divider;
+	unsigned int div;
+	u32 val;
+
+	rate = clk_round_rate(clk, rate);
+	div = clk_get_rate(clk->parent) / rate;
+
+	val = __raw_readl(reg);
+	val &= ~(0xf << sclk->divider_shift);
+		val |= ((div - 1) << sclk->divider_shift);
+	__raw_writel(val, reg);
+
+	return 0;
+}
+
+static int s3c64xx_setparent_clksrc(struct clk *clk, struct clk *parent)
+{
+	struct clksrc_clk *sclk = to_clksrc(clk);
+	struct clk_sources *srcs = sclk->sources;
+	u32 clksrc = __raw_readl(S3C_CLK_SRC);
+	int src_nr = -1;
+	int ptr;
+
+	for (ptr = 0; ptr < srcs->nr_sources; ptr++)
+		if (srcs->sources[ptr] == parent) {
+			src_nr = ptr;
+			break;
+		}
+
+	if (src_nr >= 0) {
+		clksrc &= ~sclk->mask;
+		clksrc |= src_nr << sclk->shift;
+
+		__raw_writel(clksrc, S3C_CLK_SRC);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static unsigned long s3c64xx_roundrate_clksrc(struct clk *clk,
+					      unsigned long rate)
+{
+	unsigned long parent_rate = clk_get_rate(clk->parent);
+	int div;
+	
+	if (rate > parent_rate)
+		rate = parent_rate;
+	else {
+		div = rate / parent_rate;
+
+		if (div == 0)
+			div = 1;
+		if (div > 16)
+			div = 16;
+
+		rate = parent_rate / div;
+	}
+
+	return rate;
+}
+
+static struct clksrc_clk clk_mmc0 = {
+	.clk	= {
+		.name		= "mmc_bus",
+		.id		= 0,
+		.ctrlbit        = S3C_CLKCON_SCLK_MMC0,
+		.enable		= s3c64xx_sclk_ctrl,
+		.set_parent	= s3c64xx_setparent_clksrc,
+		.get_rate	= s3c64xx_getrate_clksrc,
+		.set_rate	= s3c64xx_setrate_clksrc,
+		.round_rate	= s3c64xx_roundrate_clksrc,
+	},
+	.shift		= S3C6400_CLKSRC_MMC0_SHIFT,
+	.mask		= S3C6400_CLKSRC_MMC0_MASK,
+	.sources	= &clkset_spi_mmc,
+	.divider_mask	= S3C6400_CLKDIV1_MMC0_MASK,
+	.divider_shift	= S3C6400_CLKDIV1_MMC0_SHIFT,
+	.reg_divider	= S3C_CLK_DIV1,
+};
+
+static struct clksrc_clk clk_mmc1 = {
+	.clk	= {
+		.name		= "mmc_bus",
+		.id		= 1,
+		.ctrlbit        = S3C_CLKCON_SCLK_MMC1,
+		.enable		= s3c64xx_sclk_ctrl,
+		.get_rate	= s3c64xx_getrate_clksrc,
+		.set_rate	= s3c64xx_setrate_clksrc,
+		.set_parent	= s3c64xx_setparent_clksrc,
+		.round_rate	= s3c64xx_roundrate_clksrc,
+	},
+	.shift		= S3C6400_CLKSRC_MMC1_SHIFT,
+	.mask		= S3C6400_CLKSRC_MMC1_MASK,
+	.sources	= &clkset_spi_mmc,
+	.divider_mask	= S3C6400_CLKDIV1_MMC1_MASK,
+	.divider_shift	= S3C6400_CLKDIV1_MMC1_SHIFT,
+	.reg_divider	= S3C_CLK_DIV1,
+};
+
+static struct clksrc_clk clk_mmc2 = {
+	.clk	= {
+		.name		= "mmc_bus",
+		.id		= 2,
+		.ctrlbit        = S3C_CLKCON_SCLK_MMC2,
+		.enable		= s3c64xx_sclk_ctrl,
+		.get_rate	= s3c64xx_getrate_clksrc,
+		.set_rate	= s3c64xx_setrate_clksrc,
+		.set_parent	= s3c64xx_setparent_clksrc,
+		.round_rate	= s3c64xx_roundrate_clksrc,
+	},
+	.shift		= S3C6400_CLKSRC_MMC2_SHIFT,
+	.mask		= S3C6400_CLKSRC_MMC2_MASK,
+	.sources	= &clkset_spi_mmc,
+	.divider_mask	= S3C6400_CLKDIV1_MMC2_MASK,
+	.divider_shift	= S3C6400_CLKDIV1_MMC2_SHIFT,
+	.reg_divider	= S3C_CLK_DIV1,
+};
+
+static struct clksrc_clk clk_usbhost = {
+	.clk	= {
+		.name		= "usb-host-bus",
+		.id		= -1,
+		.ctrlbit        = S3C_CLKCON_SCLK_UHOST,
+		.enable		= s3c64xx_sclk_ctrl,
+		.set_parent	= s3c64xx_setparent_clksrc,
+		.get_rate	= s3c64xx_getrate_clksrc,
+		.set_rate	= s3c64xx_setrate_clksrc,
+		.round_rate	= s3c64xx_roundrate_clksrc,
+	},
+	.shift		= S3C6400_CLKSRC_UHOST_SHIFT,
+	.mask		= S3C6400_CLKSRC_UHOST_MASK,
+	.sources	= &clkset_uhost,
+	.divider_mask	= S3C6400_CLKDIV1_UHOST_MASK,
+	.divider_shift	= S3C6400_CLKDIV1_UHOST_SHIFT,
+	.reg_divider	= S3C_CLK_DIV1,
+};
+
+static struct clksrc_clk clk_lcd = {
+	.clk	= {
+		.name		= "lcd",
+		.id		= -1,
+		.ctrlbit        = S3C_CLKCON_SCLK_LCD,
+		.enable		= s3c64xx_sclk_ctrl,
+		.set_parent	= s3c64xx_setparent_clksrc,
+		.get_rate	= s3c64xx_getrate_clksrc,
+		.set_rate	= s3c64xx_setrate_clksrc,
+		.round_rate	= s3c64xx_roundrate_clksrc,
+	},
+	.shift		= S3C6400_CLKSRC_LCD_SHIFT,
+	.mask		= S3C6400_CLKSRC_LCD_MASK,
+	.sources	= &clkset_lcd,
+	.divider_mask	= S3C6400_CLKDIV1_LCD_MASK,
+	.divider_shift	= S3C6400_CLKDIV1_LCD_SHIFT,
+	.reg_divider	= S3C_CLK_DIV1,
+};
+
+static struct clksrc_clk clk_uart_uclk1 = {
+	.clk	= {
+		.name		= "uclk1",
+		.id		= -1,
+		.ctrlbit        = S3C_CLKCON_SCLK_UART,
+		.enable		= s3c64xx_sclk_ctrl,
+		.set_parent	= s3c64xx_setparent_clksrc,
+		.get_rate	= s3c64xx_getrate_clksrc,
+		.set_rate	= s3c64xx_setrate_clksrc,
+		.round_rate	= s3c64xx_roundrate_clksrc,
+	},
+	.shift		= S3C6400_CLKSRC_UART_SHIFT,
+	.mask		= S3C6400_CLKSRC_UART_MASK,
+	.sources	= &clkset_uart,
+	.divider_mask	= S3C6400_CLKDIV2_UART_MASK,
+	.divider_shift	= S3C6400_CLKDIV2_UART_SHIFT,
+	.reg_divider	= S3C_CLK_DIV2,
+};
+
+/* Where does UCLK0 come from? */
+
+static struct clksrc_clk clk_spi0 = {
+	.clk	= {
+		.name		= "spi-bus",
+		.id		= 0,
+		.ctrlbit        = S3C_CLKCON_SCLK_SPI0,
+		.enable		= s3c64xx_sclk_ctrl,
+		.set_parent	= s3c64xx_setparent_clksrc,
+		.get_rate	= s3c64xx_getrate_clksrc,
+		.set_rate	= s3c64xx_setrate_clksrc,
+		.round_rate	= s3c64xx_roundrate_clksrc,
+	},
+	.shift		= S3C6400_CLKSRC_SPI0_SHIFT,
+	.mask		= S3C6400_CLKSRC_SPI0_MASK,
+	.sources	= &clkset_spi_mmc,
+	.divider_mask	= S3C6400_CLKDIV2_SPI0_MASK,
+	.divider_shift	= S3C6400_CLKDIV2_SPI0_SHIFT,
+	.reg_divider	= S3C_CLK_DIV2,
+};
+
+static struct clksrc_clk clk_spi1 = {
+	.clk	= {
+		.name		= "spi-bus",
+		.id		= 1,
+		.ctrlbit        = S3C_CLKCON_SCLK_SPI1,
+		.enable		= s3c64xx_sclk_ctrl,
+		.set_parent	= s3c64xx_setparent_clksrc,
+		.get_rate	= s3c64xx_getrate_clksrc,
+		.set_rate	= s3c64xx_setrate_clksrc,
+		.round_rate	= s3c64xx_roundrate_clksrc,
+	},
+	.shift		= S3C6400_CLKSRC_SPI1_SHIFT,
+	.mask		= S3C6400_CLKSRC_SPI1_MASK,
+	.sources	= &clkset_spi_mmc,
+	.divider_mask	= S3C6400_CLKDIV2_SPI1_MASK,
+	.divider_shift	= S3C6400_CLKDIV2_SPI1_SHIFT,
+	.reg_divider	= S3C_CLK_DIV2,
+};
+
+
+static struct clksrc_clk clk_audio0 = {
+	.clk	= {
+		.name		= "audio-bus",
+		.id		= 0,
+		.ctrlbit        = S3C_CLKCON_SCLK_AUDIO0,
+		.enable		= s3c64xx_sclk_ctrl,
+		.set_parent	= s3c64xx_setparent_clksrc,
+		.get_rate	= s3c64xx_getrate_clksrc,
+		.set_rate	= s3c64xx_setrate_clksrc,
+		.round_rate	= s3c64xx_roundrate_clksrc,
+	},
+	.shift		= S3C6400_CLKSRC_AUDIO0_SHIFT,
+	.mask		= S3C6400_CLKSRC_AUDIO0_MASK,
+	.sources	= &clkset_audio0,
+	.divider_mask	= S3C6400_CLKDIV2_AUDIO0_MASK,
+	.divider_shift	= S3C6400_CLKDIV2_AUDIO0_SHIFT,
+	.reg_divider	= S3C_CLK_DIV2,
+};
+
+static struct clk *clkset_audio1_list[] = {
+	[0] = &clk_mout_epll.clk,
+	[1] = &clk_dout_mpll,
+	[2] = &clk_fin_epll,
+	[3] = &clk_iis_cd1,
+	[4] = &clk_pcm_cd,
+};
+
+static struct clk_sources clkset_audio1 = {
+	.sources	= clkset_audio1_list,
+	.nr_sources	= ARRAY_SIZE(clkset_audio1_list),
+};
+
+static struct clksrc_clk clk_audio1 = {
+	.clk	= {
+		.name		= "audio-bus",
+		.id		= 1,
+		.ctrlbit        = S3C_CLKCON_SCLK_AUDIO1,
+		.enable		= s3c64xx_sclk_ctrl,
+		.set_parent	= s3c64xx_setparent_clksrc,
+		.get_rate	= s3c64xx_getrate_clksrc,
+		.set_rate	= s3c64xx_setrate_clksrc,
+		.round_rate	= s3c64xx_roundrate_clksrc,
+	},
+	.shift		= S3C6400_CLKSRC_AUDIO1_SHIFT,
+	.mask		= S3C6400_CLKSRC_AUDIO1_MASK,
+	.sources	= &clkset_audio1,
+	.divider_mask	= S3C6400_CLKDIV2_AUDIO1_MASK,
+	.divider_shift	= S3C6400_CLKDIV2_AUDIO1_SHIFT,
+	.reg_divider	= S3C_CLK_DIV2,
+};
+
+static struct clksrc_clk clk_irda = {
+	.clk	= {
+		.name		= "irda-bus",
+		.id		= 0,
+		.ctrlbit        = S3C_CLKCON_SCLK_IRDA,
+		.enable		= s3c64xx_sclk_ctrl,
+		.set_parent	= s3c64xx_setparent_clksrc,
+		.get_rate	= s3c64xx_getrate_clksrc,
+		.set_rate	= s3c64xx_setrate_clksrc,
+		.round_rate	= s3c64xx_roundrate_clksrc,
+	},
+	.shift		= S3C6400_CLKSRC_IRDA_SHIFT,
+	.mask		= S3C6400_CLKSRC_IRDA_MASK,
+	.sources	= &clkset_irda,
+	.divider_mask	= S3C6400_CLKDIV2_IRDA_MASK,
+	.divider_shift	= S3C6400_CLKDIV2_IRDA_SHIFT,
+	.reg_divider	= S3C_CLK_DIV2,
+};
+
+/* Clock initialisation code */
+
+static struct clksrc_clk *init_parents[] = {
+	&clk_mout_apll,
+	&clk_mout_epll,
+	&clk_mout_mpll,
+	&clk_mmc0,
+	&clk_mmc1,
+	&clk_mmc2,
+	&clk_usbhost,
+	&clk_lcd,
+	&clk_uart_uclk1,
+	&clk_spi0,
+	&clk_spi1,
+	&clk_audio0,
+	&clk_audio1,
+	&clk_irda,
+};
+
+static void __init_or_cpufreq s3c6400_set_clksrc(struct clksrc_clk *clk)
+{
+	struct clk_sources *srcs = clk->sources;
+	u32 clksrc = __raw_readl(S3C_CLK_SRC);
+
+	clksrc &= clk->mask;
+	clksrc >>= clk->shift;
+
+	if (clksrc > srcs->nr_sources || !srcs->sources[clksrc]) {
+		printk(KERN_ERR "%s: bad source %d\n",
+		       clk->clk.name, clksrc);
+		return;
+	}
+
+	clk->clk.parent = srcs->sources[clksrc];
+
+	printk(KERN_INFO "%s: source is %s (%d), rate is %ld\n",
+	       clk->clk.name, clk->clk.parent->name, clksrc,
+	       clk_get_rate(&clk->clk));
+}
+
+#define GET_DIV(clk, field) ((((clk) & field##_MASK) >> field##_SHIFT) + 1)
+
+void __init_or_cpufreq s3c64xx_setup_clocks(void)
+{
+	struct clk *xtal_clk;
+	unsigned long xtal;
+	unsigned long fclk;
+	unsigned long hclk;
+	unsigned long hclkx2;
+	unsigned long pclk;
+	unsigned long epll;
+	unsigned long apll;
+	unsigned long mpll;
+	unsigned int ptr;
+	u32 clkdiv0;
+	u32 clksrc;
+
+	printk(KERN_DEBUG "%s: registering clocks\n", __func__);
+
+	clkdiv0 = __raw_readl(S3C_CLK_DIV0);
+	printk(KERN_DEBUG "%s: clkdiv0 = %08x\n", __func__, clkdiv0);
+
+	xtal_clk = clk_get(NULL, "xtal");
+	BUG_ON(IS_ERR(xtal_clk));
+
+	xtal = clk_get_rate(xtal_clk);
+	clk_put(xtal_clk);
+
+	printk(KERN_DEBUG "%s: xtal is %ld\n", __func__, xtal);
+
+	epll = s3c6400_get_epll(xtal);
+	mpll = s3c6400_get_pll(xtal, __raw_readl(S3C_MPLL_CON));
+	apll = s3c6400_get_pll(xtal, __raw_readl(S3C_APLL_CON));
+
+	fclk = apll / GET_DIV(clkdiv0, S3C6410_CLKDIV0_ARM);
+
+	printk(KERN_INFO "S3C64XX: PLL settings, A=%ld, M=%ld, E=%ld\n",
+	       apll, mpll, epll);
+
+	if(__raw_readl(S3C_OTHERS) & S3C_OTHERS_SYNCMUXSEL_SYNC) {
+		/* Synchronous mode */
+		hclkx2 = apll / GET_DIV(clkdiv0, S3C6400_CLKDIV0_HCLK2);
+	} else {
+		/* Asynchronous mode */
+		hclkx2 = mpll / GET_DIV(clkdiv0, S3C6400_CLKDIV0_HCLK2);
+	}
+
+	hclk = hclkx2 / GET_DIV(clkdiv0, S3C6400_CLKDIV0_HCLK);
+	pclk = hclkx2 / GET_DIV(clkdiv0, S3C6400_CLKDIV0_PCLK);
+
+	printk(KERN_INFO "S3C64XX: HCLKx2=%ld, HCLK=%ld, PCLK=%ld\n",
+	       hclkx2, hclk, pclk);
+
+	clk_fout_mpll.rate = mpll;
+	clk_fout_epll.rate = epll;
+	clk_fout_apll.rate = apll;
+
+	clk_hx2.rate = hclkx2;
+	clk_h.rate = hclk;
+	clk_p.rate = pclk;
+	clk_f.rate = fclk;
+
+	/* lcd & PP clock source change to dout_mpll */
+	clksrc = __raw_readl(S3C_CLK_SRC);
+	clksrc |= (0x1 << 26);
+	__raw_writel(clksrc, S3C_CLK_SRC);
+
+	for (ptr = 0; ptr < ARRAY_SIZE(init_parents); ptr++)
+		s3c6400_set_clksrc(init_parents[ptr]);
+}
+
+static struct clk *clks[] __initdata = {
+	&clk_ext_xtal_mux,
+	&clk_iis_cd0,
+	&clk_iis_cd1,
+	&clk_pcm_cd,
+	&clk_mout_epll.clk,
+	&clk_fout_epll,
+	&clk_mout_mpll.clk,
+	&clk_dout_mpll,
+	&clk_mmc0.clk,
+	&clk_mmc1.clk,
+	&clk_mmc2.clk,
+	&clk_usbhost.clk,
+	&clk_lcd.clk,
+	&clk_uart_uclk1.clk,
+	&clk_spi0.clk,
+	&clk_spi1.clk,
+	&clk_audio0.clk,
+	&clk_audio1.clk,
+	&clk_irda.clk,
+};
+
+void __init s3c6410_register_clocks(void)
+{
+	struct clk *clkp;
+	int ret;
+	int ptr;
+
+	for (ptr = 0; ptr < ARRAY_SIZE(clks); ptr++) {
+		clkp = clks[ptr];
+		ret = s3c_register_clock(clkp);
+		if (ret < 0) {
+			printk(KERN_ERR "Failed to register clock %s (%d)\n",
+			       clkp->name, ret);
+		}
+	}
+
+//	clk_mpll.parent = &clk_mout_mpll.clk;
+	clk_epll.parent = &clk_mout_epll.clk;
+}
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/s3c64xx-dvfs.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/s3c64xx-dvfs.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/s3c64xx-dvfs.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/s3c64xx-dvfs.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,474 @@
+/*
+ *  linux/arch/arm/plat-s3c64xx/s3c64xx-cpufreq.c
+ *
+ *  CPU frequency scaling for S3C64XX
+ *
+ *  Copyright (C) 2008 Samsung Electronics
+ *
+ *  Based on cpu-sa1110.c, Copyright (C) 2001 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/cpufreq.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/i2c/pmic.h>
+
+#include <asm/system.h>
+#include <plat/s3c64xx-dvfs.h>
+
+unsigned int S3C64XX_MAXFREQLEVEL = 3;
+static unsigned int s3c64xx_cpufreq_level = 3;
+unsigned int s3c64xx_cpufreq_index = 0;
+static spinlock_t dvfs_lock;
+
+#define CLIP_LEVEL(a, b) (a > b ? b : a)
+
+static struct cpufreq_frequency_table freq_table_532MHz[] = {
+	{0, 532*KHZ_T},
+	{1, 266*KHZ_T},
+	{2, 133*KHZ_T},
+#ifdef USE_DVFS_AL1_LEVEL
+	{3, 133*KHZ_T},
+	{4, 66*KHZ_T},
+	{5, CPUFREQ_TABLE_END},		
+#else
+	{3, 66*KHZ_T},
+	{4, CPUFREQ_TABLE_END},		
+#endif /* USE_DVFS_AL1_LEVEL */
+};
+
+static struct cpufreq_frequency_table freq_table_800MHz[] = {
+	{0, 800*KHZ_T},
+	{1, 400*KHZ_T},
+	{2, 266*KHZ_T},	
+	{3, 133*KHZ_T},
+#ifdef USE_DVFS_AL1_LEVEL
+	{4, 133*KHZ_T},
+	{5, (66)*KHZ_T},
+	{6, CPUFREQ_TABLE_END},
+#else
+	{4, (66)*KHZ_T},
+	{5, CPUFREQ_TABLE_END},
+#endif /* USE_DVFS_AL1_LEVEL */
+};
+
+static unsigned char transition_state_800MHz[][2] = {
+	{1, 0},
+	{2, 0},
+	{3, 1},
+	{4, 2},
+#ifdef USE_DVFS_AL1_LEVEL
+	{5, 3},
+	{5, 4},
+#else
+	{4, 3},
+#endif /* USE_DVFS_AL1_LEVEL */
+};
+
+static unsigned char transition_state_532MHz[][2] = {
+	{1, 0},
+	{2, 0},
+	{3, 1},
+#ifdef USE_DVFS_AL1_LEVEL
+	{4, 2},
+	{4, 3},		
+#else
+	{3, 2},
+#endif /* USE_DVFS_AL1_LEVEL */
+};
+
+/* frequency voltage matching table */
+static const unsigned int frequency_match_532MHz[][4] = {
+/* frequency, Mathced VDD ARM voltage , Matched VDD INT*/
+	{532000, 1100, 1250, 0},
+	{266000, 1100, 1250, 1},
+	{133000, 1000, 1250, 2},
+#ifdef USE_DVFS_AL1_LEVEL
+	{133000, 1050, 1050, 3},
+	{66000, 1050, 1050, 4},
+#else
+	{66000, 1050, 1050, 3},
+#endif /* USE_DVFS_AL1_LEVEL */
+};
+
+/* frequency voltage matching table */
+static const unsigned int frequency_match_800MHz[][4] = {
+/* frequency, Mathced VDD ARM voltage , Matched VDD INT*/
+	{800000, 1350, 1250, 0},
+	{400000, 1150, 1250, 1},
+	{266000, 1100, 1250, 2},
+	{133000, 1050, 1250, 3},
+#ifdef USE_DVFS_AL1_LEVEL
+	{133000, 1050, 1050, 4},
+	{66000, 1050, 1050, 5},
+#else
+	{66000, 1050, 1050, 4},
+#endif /* USE_DVFS_AL1_LEVEL */
+};
+
+extern int is_pmic_initialized(void);
+static const unsigned int (*frequency_match[2])[4] = {
+	frequency_match_532MHz,
+	frequency_match_800MHz,
+};
+
+static unsigned char (*transition_state[2])[2] = {
+	transition_state_532MHz,
+	transition_state_800MHz,
+};
+
+static struct cpufreq_frequency_table *s3c6410_freq_table[] = {
+	freq_table_532MHz,
+	freq_table_800MHz,
+};
+
+int dvfs_change_quick = 0;
+void set_dvfs_perf_level(void)
+{
+	spin_lock(&dvfs_lock);	
+
+	/* if user input (keypad, touchscreen) occur, raise up 800MHz */
+	/* maximum frequency :800MHz(0), 400MHz(1) */
+	s3c64xx_cpufreq_index = 0;
+	dvfs_change_quick = 1;
+	spin_unlock(&dvfs_lock);
+}
+EXPORT_SYMBOL(set_dvfs_perf_level);
+
+static int dvfs_level_count = 0;
+void set_dvfs_level(int flag)
+{
+	spin_lock(&dvfs_lock);	
+	if(flag == 0) {
+		if (dvfs_level_count > 0) {
+			dvfs_level_count++;	
+			spin_unlock(&dvfs_lock);
+			return;
+		}
+#ifdef USE_DVFS_AL1_LEVEL
+		s3c64xx_cpufreq_level = S3C64XX_MAXFREQLEVEL - 2;
+#else
+		s3c64xx_cpufreq_level = S3C64XX_MAXFREQLEVEL - 1;
+#endif /* USE_DVFS_AL1_LEVEL */
+		dvfs_level_count++;
+	}
+	else {
+		if (dvfs_level_count > 1) {
+			dvfs_level_count--;
+			spin_unlock(&dvfs_lock);
+			return;
+		}
+		s3c64xx_cpufreq_level = S3C64XX_MAXFREQLEVEL;
+		dvfs_level_count--;
+	}
+	spin_unlock(&dvfs_lock);
+}
+EXPORT_SYMBOL(set_dvfs_level);
+
+#ifdef USE_DVS
+int get_voltage(pmic_pm_type pm_type)
+{
+	int volatge = 0;
+	if((pm_type == VCC_ARM) || (pm_type == VCC_INT))
+		get_pmic(pm_type, &volatge);
+
+	return volatge;
+}
+
+int set_voltage(unsigned int freq_index)
+{
+	static int index = 0;
+	unsigned int arm_voltage, int_voltage;
+	unsigned int vcc_arm, vcc_int;
+	unsigned int arm_delay, int_delay, delay;
+	
+	if(index == freq_index)
+		return 0;
+		
+	index = freq_index;
+	
+	vcc_arm = get_voltage(VCC_ARM);
+	vcc_int = get_voltage(VCC_INT);
+	
+	arm_voltage = frequency_match[S3C64XX_FREQ_TAB][index][1];
+	int_voltage = frequency_match[S3C64XX_FREQ_TAB][index][2];
+	
+	arm_delay = ((abs(vcc_arm - arm_voltage) / 50) * 5) + 10;
+	int_delay = ((abs(vcc_int - int_voltage) / 50) * 5) + 10;
+	
+	delay = arm_delay > int_delay ? arm_delay : int_delay;
+
+	if(arm_voltage != vcc_arm) {
+		set_pmic(VCC_ARM, arm_voltage);
+	}
+	if(int_voltage != vcc_int) {
+		set_pmic(VCC_INT, int_voltage);
+	}
+
+	udelay(delay);
+
+	return 0;
+}
+#endif	/* USE_DVS */
+
+unsigned int s3c64xx_target_frq(unsigned int pred_freq, 
+				int flag)
+{
+	int index; 
+	unsigned int freq;
+	struct cpufreq_frequency_table *freq_tab = s3c6410_freq_table[S3C64XX_FREQ_TAB];
+
+	spin_lock(&dvfs_lock);
+
+	if(freq_tab[0].frequency < pred_freq) {
+	   index = 0;	
+	   goto s3c64xx_target_frq_end;
+	}
+
+	if((flag != 1)&&(flag != -1)) {
+		printk(KERN_ERR "s3c64xx_target_frq: flag error!!!!!!!!!!!!!");
+	}
+
+	index = s3c64xx_cpufreq_index;
+	
+	if(freq_tab[index].frequency == pred_freq) {	
+		if(flag == 1)
+			index = transition_state[S3C64XX_FREQ_TAB][index][1];
+		else
+			index = transition_state[S3C64XX_FREQ_TAB][index][0];
+	}
+	else if(flag == -1) {
+		index = 1;
+	}
+	else {
+		index = 0; 
+	}
+s3c64xx_target_frq_end:
+	index = CLIP_LEVEL(index, s3c64xx_cpufreq_level);
+	s3c64xx_cpufreq_index = index;
+	
+	freq = freq_tab[index].frequency;
+	spin_unlock(&dvfs_lock);
+	return freq;
+}
+
+int s3c64xx_target_freq_index(unsigned int freq)
+{
+	int index = 0;
+	
+	struct cpufreq_frequency_table *freq_tab = s3c6410_freq_table[S3C64XX_FREQ_TAB];
+
+	if(freq >= freq_tab[index].frequency) {
+		goto s3c64xx_target_freq_index_end;
+	}
+
+	/*Index might have been calculated before calling this function.
+	check and early return if it is already calculated*/
+	if(freq_tab[s3c64xx_cpufreq_index].frequency == freq) {		
+		return s3c64xx_cpufreq_index;
+	}
+
+	while((freq < freq_tab[index].frequency) &&
+			(freq_tab[index].frequency != CPUFREQ_TABLE_END)) {
+		index++;
+	}
+
+	if(index > 0) {
+		if(freq != freq_tab[index].frequency) {
+			index--;
+		}
+	}
+
+	if(freq_tab[index].frequency == CPUFREQ_TABLE_END) {
+		index--;
+	}
+
+s3c64xx_target_freq_index_end:
+	spin_lock(&dvfs_lock);	
+	index = CLIP_LEVEL(index, s3c64xx_cpufreq_level);
+	spin_unlock(&dvfs_lock);
+	s3c64xx_cpufreq_index = index;
+	
+	return index; 
+} 
+
+int s3c6410_verify_speed(struct cpufreq_policy *policy)
+{
+	if(policy->cpu)
+		return -EINVAL;
+
+	return cpufreq_frequency_table_verify(policy, s3c6410_freq_table[S3C64XX_FREQ_TAB]);
+}
+
+extern unsigned long s3c_fclk_get_rate(void);
+unsigned int s3c6410_getspeed(unsigned int cpu)
+{
+	struct clk * mpu_clk;
+	unsigned long rate;
+
+	if(cpu)
+		return 0;
+
+	mpu_clk = clk_get(NULL, MPU_CLK);
+	if (IS_ERR(mpu_clk))
+		return 0;
+
+	rate = s3c_fclk_get_rate() / KHZ_T;
+	clk_put(mpu_clk);
+
+	return rate;
+}
+
+static int s3c6410_target(struct cpufreq_policy *policy,
+		       unsigned int target_freq,
+		       unsigned int relation)
+{
+	struct clk * mpu_clk;
+	struct cpufreq_freqs freqs;
+	static int prevIndex = 0;
+	int ret = 0;
+	unsigned long arm_clk;
+	unsigned int index;
+
+	if(!is_pmic_initialized())
+		return ret;
+
+	mpu_clk = clk_get(NULL, MPU_CLK);
+	if(IS_ERR(mpu_clk))
+		return PTR_ERR(mpu_clk);
+
+	freqs.old = s3c6410_getspeed(0);
+
+	if(freqs.old == s3c6410_freq_table[S3C64XX_FREQ_TAB][0].frequency) {
+		prevIndex = 0;
+	}
+	
+	index = s3c64xx_target_freq_index(target_freq);
+	if(index == INDX_ERROR) {
+		printk(KERN_ERR "s3c6410_target: INDX_ERROR \n");
+		return -EINVAL;
+	}
+	
+	if(prevIndex == index)
+		return ret;
+
+	arm_clk = s3c6410_freq_table[S3C64XX_FREQ_TAB][index].frequency;
+	freqs.new = arm_clk;
+	freqs.cpu = 0;
+	freqs.new_hclk = 133000;
+  
+	if(index > S3C64XX_MAXFREQLEVEL) {
+		freqs.new_hclk = 66000;         
+	} 
+
+	target_freq = arm_clk;
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+#ifdef USE_DVS
+	if(prevIndex < index) {
+		/* frequency scaling */
+		ret = clk_set_rate(mpu_clk, target_freq * KHZ_T);
+		if(ret != 0) {
+			printk(KERN_ERR "frequency scaling error\n");
+			ret = -EINVAL;
+			goto s3c6410_target_end;
+		}
+		/* voltage scaling */
+		set_voltage(index);
+	}
+	else {
+		/* voltage scaling */
+		set_voltage(index);
+		/* frequency scaling */
+		ret = clk_set_rate(mpu_clk, target_freq * KHZ_T);
+		if(ret != 0) {
+			printk(KERN_ERR "frequency scaling error\n");
+			ret = -EINVAL;
+			goto s3c6410_target_end;
+		}
+	}
+#else
+	ret = clk_set_rate(mpu_clk, target_freq * KHZ_T);
+	if(ret != 0) {
+		printk(KERN_ERR "frequency scaling error\n");
+		ret = -EINVAL;
+		goto s3c6410_target_end;
+	}
+#endif	/* USE_DVS */
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	prevIndex = index;
+	clk_put(mpu_clk);
+s3c6410_target_end:
+	return ret;
+}
+
+unsigned int get_min_cpufreq(void)
+{
+	return (s3c6410_freq_table[S3C64XX_FREQ_TAB][S3C64XX_MAXFREQLEVEL].frequency);
+}
+
+static int __init s3c6410_cpu_init(struct cpufreq_policy *policy)
+{
+	struct clk * mpu_clk;
+
+	mpu_clk = clk_get(NULL, MPU_CLK);
+	if(IS_ERR(mpu_clk))
+		return PTR_ERR(mpu_clk);
+
+	if(policy->cpu != 0)
+		return -EINVAL;
+	policy->cur = policy->min = policy->max = s3c6410_getspeed(0);
+
+	if(policy->max == MAXIMUM_FREQ) {
+		S3C64XX_FREQ_TAB = 1;
+#ifdef USE_DVFS_AL1_LEVEL
+		S3C64XX_MAXFREQLEVEL = 5;
+#else
+		S3C64XX_MAXFREQLEVEL = 4;
+#endif /* USE_DVFS_AL1_LEVEL */
+	}
+	else {
+		S3C64XX_FREQ_TAB = 0;
+#ifdef USE_DVFS_AL1_LEVEL
+		S3C64XX_MAXFREQLEVEL = 4;
+#else
+		S3C64XX_MAXFREQLEVEL = 3;
+#endif /* USE_DVFS_AL1_LEVEL */
+	}
+	s3c64xx_cpufreq_level = S3C64XX_MAXFREQLEVEL;
+
+	cpufreq_frequency_table_get_attr(s3c6410_freq_table[S3C64XX_FREQ_TAB], policy->cpu);
+
+	policy->cpuinfo.transition_latency = 10000;
+
+	clk_put(mpu_clk);
+
+	spin_lock_init(&dvfs_lock);
+
+	return cpufreq_frequency_table_cpuinfo(policy, s3c6410_freq_table[S3C64XX_FREQ_TAB]);
+}
+
+static struct cpufreq_driver s3c6410_driver = {
+	.flags		= CPUFREQ_STICKY,
+	.verify		= s3c6410_verify_speed,
+	.target		= s3c6410_target,
+	.get		= s3c6410_getspeed,
+	.init		= s3c6410_cpu_init,
+	.name		= "s3c6410",
+};
+
+static int __init s3c6410_cpufreq_init(void)
+{
+	return cpufreq_register_driver(&s3c6410_driver);
+}
+
+arch_initcall(s3c6410_cpufreq_init);
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/s3c64xx-init.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/s3c64xx-init.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/s3c64xx-init.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/s3c64xx-init.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,29 @@
+/* linux/arch/arm/plat-s3c64xx/s3c6400-init.c
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * S3C64XX - CPU initialisation (common with other S3C64XX chips)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+
+#include <plat/cpu.h>
+#include <plat/devs.h>
+#include <plat/s3c6400.h>
+#include <plat/s3c6410.h>
+
+/* uart registration process */
+
+void __init s3c64xx_common_init_uarts(struct s3c_uartcfg *cfg, int no)
+{
+	s3c_init_uartdevs("s3c64xx-uart", s3c64xx_uart_resources, cfg, no);
+}
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/setup-i2c1.c linux-2.6.29-spica/arch/arm/plat-s3c64xx/setup-i2c1.c
--- linux-2.6.29/arch/arm/plat-s3c64xx/setup-i2c1.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/setup-i2c1.c	2010-05-06 12:42:45.644210217 +0700
@@ -24,8 +24,10 @@
 
 void s3c_i2c1_cfg_gpio(struct platform_device *dev)
 {
+#if 0
 	s3c_gpio_cfgpin(S3C64XX_GPB(2), S3C64XX_GPB2_I2C_SCL1);
 	s3c_gpio_cfgpin(S3C64XX_GPB(3), S3C64XX_GPB3_I2C_SDA1);
 	s3c_gpio_setpull(S3C64XX_GPB(2), S3C_GPIO_PULL_UP);
 	s3c_gpio_setpull(S3C64XX_GPB(3), S3C_GPIO_PULL_UP);
+#endif
 }
diff -Nur linux-2.6.29/arch/arm/plat-s3c64xx/sleep.S linux-2.6.29-spica/arch/arm/plat-s3c64xx/sleep.S
--- linux-2.6.29/arch/arm/plat-s3c64xx/sleep.S	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/arch/arm/plat-s3c64xx/sleep.S	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,144 @@
+/* linux/0arch/arm/plat-s3c64xx/sleep.S
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C64XX CPU sleep code
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/map.h>
+
+#undef S3C64XX_VA_GPIO
+#define S3C64XX_VA_GPIO (0x0)
+
+#include <plat/regs-gpio.h>
+#include <plat/gpio-bank-n.h>
+
+#define LL_UART (S3C_PA_UART + (0x400 * CONFIG_S3C_LOWLEVEL_UART_PORT))
+
+	.text
+
+	/* s3c_cpu_save
+	 *
+	 * Save enough processor state to allow the restart of the pm.c
+	 * code after resume.
+	 *
+	 * entry:
+	 *	r0 = pointer to the save block
+	 * exit:
+	 *	r0 = exit code: 1 => stored data
+	 *			0 => resumed from sleep
+	*/
+
+ENTRY(s3c6410_cpu_save)
+	stmfd	sp!, { r4 - r12, lr }
+
+	mrc	p15, 0, r4, c13, c0, 0	@ FCSE/PID
+	mrc	p15, 0, r5, c3, c0, 0	@ Domain ID
+	mrc	p15, 0, r6, c2, c0, 0	@ Translation Table BASE0
+	mrc	p15, 0, r7, c2, c0, 1	@ Translation Table BASE1
+	mrc	p15, 0, r8, c2, c0, 2	@ Translation Table Control
+	mrc	p15, 0, r9, c1, c0, 0	@ Control register
+	mrc	p15, 0, r10, c1, c0, 1	@ Auxiliary control register
+	mrc	p15, 0, r11, c1, c0, 2	@ Co-processor access controls
+
+	stmia	r0, { r4 - r13 }	@ Save CP registers and SP
+	mov	r0, #0
+	ldmfd	sp, { r4 - r12, pc }	@ return, not disturbing SP
+
+	@@ return to the caller, after the MMU is turned on.
+	@@ restore the last bits of the stack and return.
+resume_with_mmu:
+	mov	r0, #1
+	ldmfd	sp!, { r4 - r12, pc }	@ return, from sp from s3c_cpu_save
+
+	.data
+
+	/* the next bit is code, but it requires easy access to the
+	 * s3c_sleep_save_phys data before the MMU is switched on, so
+	 * we store the code that needs this variable in the .data where
+	 * the value can be written to (the .text segment is RO).
+	*/
+
+	.global	s3c6410_sleep_save_phys
+s3c6410_sleep_save_phys:
+	.word	0
+
+	/* Sleep magic, the word before the resume entry point so that the
+	 * bootloader can check for a resumeable image. */
+
+	.word	0x2bedf00d
+
+	/* s3c_cpu_reusme
+	 *
+	 * This is the entry point, stored by whatever method the bootloader
+	 * requires to get the kernel runnign again. This code expects to be
+	 * entered with no caches live and the MMU disabled. It will then
+	 * restore the MMU and other basic CP registers saved and restart
+	 * the kernel C code to finish the resume code.
+	*/
+
+ENTRY(s3c6410_cpu_resume)
+	msr	cpsr_c, #PSR_I_BIT | PSR_F_BIT | SVC_MODE
+	ldr	r2, =LL_UART		/* for debug */
+
+#ifdef CONFIG_S3C_PM_DEBUG_LED_SMDK
+	/* Initialise the GPIO state if we are debugging via the SMDK LEDs,
+	 * as the uboot version supplied resets these to inputs during the
+	 * resume checks.
+	*/
+
+	ldr	r3, =S3C64XX_PA_GPIO
+	ldr	r0, [ r3, #S3C64XX_GPNCON ]
+	bic	r0, r0, #(S3C64XX_GPN_CONMASK(12) | S3C64XX_GPN_CONMASK(13) | \
+			  S3C64XX_GPN_CONMASK(14) | S3C64XX_GPN_CONMASK(15))
+	orr	r0, r0, #(S3C64XX_GPN_OUTPUT(12) | S3C64XX_GPN_OUTPUT(13) | \
+			  S3C64XX_GPN_OUTPUT(14) | S3C64XX_GPN_OUTPUT(15))
+	str	r0, [ r3, #S3C64XX_GPNCON ]
+
+	ldr	r0, [ r3, #S3C64XX_GPNDAT ]
+	bic	r0, r0, #0xf << 12			@ GPN12..15
+	orr	r0, r0, #1 << 15			@ GPN15
+	str	r0, [ r3, #S3C64XX_GPNDAT ]
+#endif
+
+	/* __v6_setup from arch/arm/mm/proc-v6.S, ensure that the caches
+	 * are thoroughly cleaned just in case the bootloader didn't do it
+	 * for us. */
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c14, 0		@ clean+invalidate D cache
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate I cache
+	mcr	p15, 0, r0, c7, c15, 0		@ clean+invalidate cache
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
+	@@mcr	p15, 0, r0, c8, c7, 0		@ invalidate I + D TLBs
+	@@mcr	p15, 0, r0, c7, c7, 0		@ Invalidate I + D caches
+
+	ldr	r0, s3c6410_sleep_save_phys
+	ldmia	r0, { r4 - r13 }
+
+	mcr	p15, 0, r4, c13, c0, 0	@ FCSE/PID
+	mcr	p15, 0, r5, c3, c0, 0	@ Domain ID
+	mcr	p15, 0, r6, c2, c0, 0	@ Translation Table BASE0
+	mcr	p15, 0, r7, c2, c0, 1	@ Translation Table BASE1
+	mcr	p15, 0, r8, c2, c0, 2	@ Translation Table Control
+	mcr	p15, 0, r10, c1, c0, 1	@ Auxiliary control register
+
+	mov	r0, #0			@ restore copro access controls
+	mcr	p15, 0, r11, c1, c0, 2	@ Co-processor access controls
+	mcr 	p15, 0, r0, c7, c5, 4
+
+	ldr	r2, =resume_with_mmu
+	mcr	p15, 0, r9, c1, c0, 0		/* turn mmu back on */
+	nop
+	mov	pc, r2				/* jump back */
+
+	.end
+
diff -Nur linux-2.6.29/arch/arm/tools/mach-types linux-2.6.29-spica/arch/arm/tools/mach-types
--- linux-2.6.29/arch/arm/tools/mach-types	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/tools/mach-types	2010-05-06 12:42:45.644210217 +0700
@@ -1618,7 +1618,7 @@
 inc20otter		MACH_INC20OTTER		INC20OTTER		1623
 at91sam9g20ek		MACH_AT91SAM9G20EK	AT91SAM9G20EK		1624
 sc_ge2			MACH_STORCENTER		STORCENTER		1625
-smdk6410		MACH_SMDK6410		SMDK6410		1626
+spica           MACH_SPICA              SPICA           1626
 u300			MACH_U300		U300			1627
 u500			MACH_U500		U500			1628
 ds9260			MACH_DS9260		DS9260			1629
diff -Nur linux-2.6.29/arch/arm/vfp/entry.S linux-2.6.29-spica/arch/arm/vfp/entry.S
--- linux-2.6.29/arch/arm/vfp/entry.S	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/vfp/entry.S	2010-05-06 12:42:45.634864134 +0700
@@ -15,13 +15,16 @@
  *  r10 = thread_info structure
  *  lr  = failure return
  */
-#include <linux/linkage.h>
-#include <linux/init.h>
-#include <asm/asm-offsets.h>
-#include <asm/assembler.h>
+#include <asm/thread_info.h>
 #include <asm/vfpmacros.h>
+#include "../kernel/entry-header.S"
 
 ENTRY(do_vfp)
+#ifdef CONFIG_PREEMPT
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	add	r11, r4, #1		@ increment it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	enable_irq
  	ldr	r4, .LCvfp
 	ldr	r11, [r10, #TI_CPU]	@ CPU number
@@ -30,6 +33,12 @@
 ENDPROC(do_vfp)
 
 ENTRY(vfp_null_entry)
+#ifdef CONFIG_PREEMPT
+	get_thread_info	r10
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	sub	r11, r4, #1		@ decrement it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	mov	pc, lr
 ENDPROC(vfp_null_entry)
 
@@ -41,6 +50,12 @@
 
 	__INIT
 ENTRY(vfp_testing_entry)
+#ifdef CONFIG_PREEMPT
+	get_thread_info	r10
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	sub	r11, r4, #1		@ decrement it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	ldr	r0, VFP_arch_address
 	str	r5, [r0]		@ known non-zero value
 	mov	pc, r9			@ we have handled the fault
diff -Nur linux-2.6.29/arch/arm/vfp/vfp.h linux-2.6.29-spica/arch/arm/vfp/vfp.h
--- linux-2.6.29/arch/arm/vfp/vfp.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/vfp/vfp.h	2010-05-06 12:42:45.634864134 +0700
@@ -377,6 +377,4 @@
 	u32 flags;
 };
 
-#if defined(CONFIG_SMP) || defined(CONFIG_PM)
 extern void vfp_save_state(void *location, u32 fpexc);
-#endif
diff -Nur linux-2.6.29/arch/arm/vfp/vfphw.S linux-2.6.29-spica/arch/arm/vfp/vfphw.S
--- linux-2.6.29/arch/arm/vfp/vfphw.S	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/vfp/vfphw.S	2010-05-06 12:42:45.634864134 +0700
@@ -137,6 +137,12 @@
 	VFPFMXR	FPEXC, r1		@ restore FPEXC last
 	sub	r2, r2, #4
 	str	r2, [sp, #S_PC]		@ retry the instruction
+#ifdef CONFIG_PREEMPT
+	get_thread_info	r10
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	sub	r11, r4, #1		@ decrement it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	mov	pc, r9			@ we think we have handled things
 
 
@@ -155,6 +161,12 @@
 	@ not recognised by VFP
 
 	DBGSTR	"not VFP"
+#ifdef CONFIG_PREEMPT
+	get_thread_info	r10
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	sub	r11, r4, #1		@ decrement it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	mov	pc, lr
 
 process_exception:
@@ -172,7 +184,6 @@
 					@ retry the faulted instruction
 ENDPROC(vfp_support_entry)
 
-#if defined(CONFIG_SMP) || defined(CONFIG_PM)
 ENTRY(vfp_save_state)
 	@ Save the current VFP state
 	@ r0 - save location
@@ -190,7 +201,6 @@
 	stmia	r0, {r1, r2, r3, r12}	@ save FPEXC, FPSCR, FPINST, FPINST2
 	mov	pc, lr
 ENDPROC(vfp_save_state)
-#endif
 
 last_VFP_context_address:
 	.word	last_VFP_context
diff -Nur linux-2.6.29/arch/arm/vfp/vfpmodule.c linux-2.6.29-spica/arch/arm/vfp/vfpmodule.c
--- linux-2.6.29/arch/arm/vfp/vfpmodule.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/arch/arm/vfp/vfpmodule.c	2010-05-06 12:42:45.634864134 +0700
@@ -266,7 +266,7 @@
 		 * on VFP subarch 1.
 		 */
 		 vfp_raise_exceptions(VFP_EXCEPTION_ERROR, trigger, fpscr, regs);
-		 return;
+		goto exit;
 	}
 
 	/*
@@ -297,7 +297,7 @@
 	 * the FPEXC.FP2V bit is valid only if FPEXC.EX is 1.
 	 */
 	if (fpexc ^ (FPEXC_EX | FPEXC_FP2V))
-		return;
+		goto exit;
 
 	/*
 	 * The barrier() here prevents fpinst2 being read
@@ -310,6 +310,8 @@
 	exceptions = vfp_emulate_instruction(trigger, orig_fpscr, regs);
 	if (exceptions)
 		vfp_raise_exceptions(exceptions, trigger, orig_fpscr, regs);
+ exit:
+	preempt_enable();
 }
 
 static void vfp_enable(void *unused)
@@ -377,6 +379,55 @@
 static inline void vfp_pm_init(void) { }
 #endif /* CONFIG_PM */
 
+/*
+ * Synchronise the hardware VFP state of a thread other than current with the
+ * saved one. This function is used by the ptrace mechanism.
+ */
+#ifdef CONFIG_SMP
+void vfp_sync_state(struct thread_info *thread)
+{
+	/*
+	 * On SMP systems, the VFP state is automatically saved at every
+	 * context switch. We mark the thread VFP state as belonging to a
+	 * non-existent CPU so that the saved one will be reloaded when
+	 * needed.
+	 */
+	thread->vfpstate.hard.cpu = NR_CPUS;
+}
+#else
+void vfp_sync_state(struct thread_info *thread)
+{
+	unsigned int cpu = get_cpu();
+	u32 fpexc = fmrx(FPEXC);
+
+	/*
+	 * If VFP is enabled, the previous state was already saved and
+	 * last_VFP_context updated.
+	 */
+	if (fpexc & FPEXC_EN)
+		goto out;
+
+	if (!last_VFP_context[cpu])
+		goto out;
+
+	/*
+	 * Save the last VFP state on this CPU.
+	 */
+	fmxr(FPEXC, fpexc | FPEXC_EN);
+	vfp_save_state(last_VFP_context[cpu], fpexc);
+	fmxr(FPEXC, fpexc);
+
+	/*
+	 * Set the context to NULL to force a reload the next time the thread
+	 * uses the VFP.
+	 */
+	last_VFP_context[cpu] = NULL;
+
+out:
+	put_cpu();
+}
+#endif
+
 #include <linux/smp.h>
 
 /*
@@ -427,6 +478,18 @@
 		 * in place; report VFP support to userspace.
 		 */
 		elf_hwcap |= HWCAP_VFP;
+#ifdef CONFIG_VFPv3
+		if (VFP_arch >= 3) {
+			elf_hwcap |= HWCAP_VFPv3;
+
+			/*
+			 * Check for VFPv3 D16. CPUs in this configuration
+			 * only have 16 x 64bit registers.
+			 */
+			if (((fmrx(MVFR0) & MVFR0_A_SIMD_MASK)) == 1)
+				elf_hwcap |= HWCAP_VFPv3D16;
+		}
+#endif
 #ifdef CONFIG_NEON
 		/*
 		 * Check for the presence of the Advanced SIMD
diff -Nur linux-2.6.29/block/blk-core.c linux-2.6.29-spica/block/blk-core.c
--- linux-2.6.29/block/blk-core.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/block/blk-core.c	2010-05-06 12:42:45.644210217 +0700
@@ -1548,11 +1548,12 @@
 
 		if (unlikely(block_dump)) {
 			char b[BDEVNAME_SIZE];
-			printk(KERN_DEBUG "%s(%d): %s block %Lu on %s\n",
+			printk(KERN_DEBUG "%s(%d): %s block %Lu on %s (%u sectors)\n",
 			current->comm, task_pid_nr(current),
 				(rw & WRITE) ? "WRITE" : "READ",
 				(unsigned long long)bio->bi_sector,
-				bdevname(bio->bi_bdev, b));
+				bdevname(bio->bi_bdev, b),
+				count);
 		}
 	}
 
@@ -1742,7 +1743,8 @@
 		req->errors = 0;
 
 	if (error && (blk_fs_request(req) && !(req->cmd_flags & REQ_QUIET))) {
-		printk(KERN_ERR "end_request: I/O error, dev %s, sector %llu\n",
+		/* Change from KERN_ERR to KERN_DEBUG to eliminate SD card notification sound crach. */
+		printk(KERN_DEBUG "end_request: I/O error, dev %s, sector %llu\n",
 				req->rq_disk ? req->rq_disk->disk_name : "?",
 				(unsigned long long)req->sector);
 	}
diff -Nur linux-2.6.29/block/genhd.c linux-2.6.29-spica/block/genhd.c
--- linux-2.6.29/block/genhd.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/block/genhd.c	2010-05-06 12:42:45.644210217 +0700
@@ -977,6 +977,22 @@
 	free_part_stats(&disk->part0);
 	kfree(disk);
 }
+
+static int disk_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct gendisk *disk = dev_to_disk(dev);
+	struct disk_part_iter piter;
+	struct hd_struct *part;
+	int cnt = 0;
+
+	disk_part_iter_init(&piter, disk, 0);
+	while((part = disk_part_iter_next(&piter)))
+		cnt++;
+	disk_part_iter_exit(&piter);
+	add_uevent_var(env, "NPARTS=%u", cnt);
+	return 0;
+}
+
 struct class block_class = {
 	.name		= "block",
 };
@@ -985,6 +1001,7 @@
 	.name		= "disk",
 	.groups		= disk_attr_groups,
 	.release	= disk_release,
+	.uevent		= disk_uevent,
 };
 
 #ifdef CONFIG_PROC_FS
diff -Nur linux-2.6.29/Documentation/android.txt linux-2.6.29-spica/Documentation/android.txt
--- linux-2.6.29/Documentation/android.txt	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/Documentation/android.txt	2010-03-30 10:59:42.000000000 +0700
@@ -0,0 +1,121 @@
+				=============
+				A N D R O I D
+				=============
+
+Copyright (C) 2009 Google, Inc.
+Written by Mike Chan <mike@android.com>
+
+CONTENTS:
+---------
+
+1. Android
+  1.1 Required enabled config options
+  1.2 Required disabled config options
+  1.3 Recommended enabled config options
+2. Contact
+
+
+1. Android
+==========
+
+Android (www.android.com) is an open source operating system for mobile devices.
+This document describes configurations needed to run the Android framework on
+top of the Linux kernel.
+
+To see a working defconfig look at msm_defconfig or goldfish_defconfig
+which can be found at http://android.git.kernel.org in kernel/common.git
+and kernel/msm.git
+
+
+1.1 Required enabled config options
+-----------------------------------
+After building a standard defconfig, ensure that these options are enabled in
+your .config or defconfig if they are not already. Based off the msm_defconfig.
+You should keep the rest of the default options enabled in the defconfig
+unless you know what you are doing.
+
+ANDROID_PARANOID_NETWORK
+ASHMEM
+CONFIG_FB_MODE_HELPERS
+CONFIG_FONT_8x16
+CONFIG_FONT_8x8
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+DAB
+EARLYSUSPEND
+FB
+FB_CFB_COPYAREA
+FB_CFB_FILLRECT
+FB_CFB_IMAGEBLIT
+FB_DEFERRED_IO
+FB_TILEBLITTING
+HIGH_RES_TIMERS
+INOTIFY
+INOTIFY_USER
+INPUT_EVDEV
+INPUT_GPIO
+INPUT_MISC
+LEDS_CLASS
+LEDS_GPIO
+LOCK_KERNEL
+LkOGGER
+LOW_MEMORY_KILLER
+MISC_DEVICES
+NEW_LEDS
+NO_HZ
+POWER_SUPPLY
+PREEMPT
+RAMFS
+RTC_CLASS
+RTC_LIB
+SWITCH
+SWITCH_GPIO
+TMPFS
+UID_STAT
+UID16
+USB_FUNCTION
+USB_FUNCTION_ADB
+USER_WAKELOCK
+VIDEO_OUTPUT_CONTROL
+WAKELOCK
+YAFFS_AUTO_YAFFS2
+YAFFS_FS
+YAFFS_YAFFS1
+YAFFS_YAFFS2
+
+
+1.2 Required disabled config options
+------------------------------------
+CONFIG_YAFFS_DISABLE_LAZY_LOAD
+DNOTIFY
+
+
+1.3 Recommended enabled config options
+------------------------------
+ANDROID_PMEM
+ANDROID_RAM_CONSOLE
+ANDROID_RAM_CONSOLE_ERROR_CORRECTION
+SCHEDSTATS
+DEBUG_PREEMPT
+DEBUG_MUTEXES
+DEBUG_SPINLOCK_SLEEP
+DEBUG_INFO
+FRAME_POINTER
+CPU_FREQ
+CPU_FREQ_TABLE
+CPU_FREQ_DEFAULT_GOV_ONDEMAND
+CPU_FREQ_GOV_ONDEMAND
+CRC_CCITT
+EMBEDDED
+INPUT_TOUCHSCREEN
+I2C
+I2C_BOARDINFO
+LOG_BUF_SHIFT=17
+SERIAL_CORE
+SERIAL_CORE_CONSOLE
+
+
+2. Contact
+==========
+website: http://android.git.kernel.org
+
+mailing-lists: android-kernel@googlegroups.com
diff -Nur linux-2.6.29/Documentation/filesystems/vfat.txt linux-2.6.29-spica/Documentation/filesystems/vfat.txt
--- linux-2.6.29/Documentation/filesystems/vfat.txt	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/Documentation/filesystems/vfat.txt	2010-03-30 10:59:45.000000000 +0700
@@ -132,6 +132,11 @@
 		 If you want to use ATTR_RO as read-only flag even for
 		 the directory, set this option.
 
+errors=panic|continue|remount-ro
+	      -- specify FAT behavior on critical errors: panic, continue
+		 without doing anything or remount the partition in
+		 read-only mode (default behavior).
+
 <bool>: 0,1,yes,no,true,false
 
 TODO
diff -Nur linux-2.6.29/drivers/base/power/main.c linux-2.6.29-spica/drivers/base/power/main.c
--- linux-2.6.29/drivers/base/power/main.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/base/power/main.c	2010-05-06 12:42:45.674299703 +0700
@@ -23,6 +23,7 @@
 #include <linux/pm.h>
 #include <linux/resume-trace.h>
 #include <linux/rwsem.h>
+#include <linux/timer.h>
 
 #include "../base.h"
 #include "power.h"
@@ -41,6 +42,9 @@
 
 static DEFINE_MUTEX(dpm_list_mtx);
 
+static void dpm_drv_timeout(unsigned long data);
+static DEFINE_TIMER(dpm_drv_wd, dpm_drv_timeout, 0, 0);
+
 /*
  * Set once the preparation of devices for a PM transition has started, reset
  * before starting to resume devices.  Protected by dpm_list_mtx.
@@ -392,6 +396,45 @@
 }
 
 /**
+ *	dpm_drv_timeout - Driver suspend / resume watchdog handler
+ *	@data: struct device which timed out
+ *
+ * 	Called when a driver has timed out suspending or resuming.
+ * 	There's not much we can do here to recover so
+ * 	BUG() out for a crash-dump
+ *
+ */
+static void dpm_drv_timeout(unsigned long data)
+{
+	struct device *dev = (struct device *) data;
+
+	printk(KERN_EMERG "**** DPM device timeout: %s (%s)\n", dev_name(dev),
+	       (dev->driver ? dev->driver->name : "no driver"));
+	BUG();
+}
+
+/**
+ *	dpm_drv_wdset - Sets up driver suspend/resume watchdog timer.
+ *	@dev: struct device which we're guarding.
+ *
+ */
+static void dpm_drv_wdset(struct device *dev)
+{
+	dpm_drv_wd.data = (unsigned long) dev;
+	mod_timer(&dpm_drv_wd, jiffies + (HZ * 3));
+}
+
+/**
+ *	dpm_drv_wdclr - clears driver suspend/resume watchdog timer.
+ *	@dev: struct device which we're no longer guarding.
+ *
+ */
+static void dpm_drv_wdclr(struct device *dev)
+{
+	del_timer_sync(&dpm_drv_wd);
+}
+
+/**
  *	dpm_resume - Resume every device.
  *	@state: PM transition of the system being carried out.
  *
@@ -641,6 +684,7 @@
  *
  *	Execute the appropriate "suspend" callbacks for all devices.
  */
+extern unsigned char ftm_sleep;
 static int dpm_suspend(pm_message_t state)
 {
 	struct list_head list;
@@ -654,13 +698,20 @@
 		get_device(dev);
 		mutex_unlock(&dpm_list_mtx);
 
+		dpm_drv_wdset(dev);
 		error = suspend_device(dev, state);
+		dpm_drv_wdclr(dev);
 
 		mutex_lock(&dpm_list_mtx);
 		if (error) {
 			pm_dev_err(dev, state, "", error);
-			put_device(dev);
-			break;
+			if (ftm_sleep) {
+				pr_err("PM: %s: ftm mode\n", __func__);
+				error = 0;
+			} else {
+				put_device(dev);
+				break;
+			}
 		}
 		dev->power.status = DPM_OFF;
 		if (!list_empty(&dev->power.entry))
diff -Nur linux-2.6.29/drivers/bluetooth/bfusb.c linux-2.6.29-spica/drivers/bluetooth/bfusb.c
--- linux-2.6.29/drivers/bluetooth/bfusb.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/bluetooth/bfusb.c	2010-03-30 11:01:15.000000000 +0700
@@ -257,8 +257,7 @@
 
 	if (hdr & 0x10) {
 		BT_ERR("%s error in block", data->hdev->name);
-		if (data->reassembly)
-			kfree_skb(data->reassembly);
+		kfree_skb(data->reassembly);
 		data->reassembly = NULL;
 		return -EIO;
 	}
diff -Nur linux-2.6.29/drivers/bluetooth/bt3c_cs.c linux-2.6.29-spica/drivers/bluetooth/bt3c_cs.c
--- linux-2.6.29/drivers/bluetooth/bt3c_cs.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/bluetooth/bt3c_cs.c	2010-03-30 11:01:15.000000000 +0700
@@ -359,9 +359,9 @@
 			BT_ERR("Very strange (stat=0x%04x)", stat);
 		} else if ((stat & 0xff) != 0xff) {
 			if (stat & 0x0020) {
-				int stat = bt3c_read(iobase, 0x7002) & 0x10;
+				int status = bt3c_read(iobase, 0x7002) & 0x10;
 				BT_INFO("%s: Antenna %s", info->hdev->name,
-							stat ? "out" : "in");
+							status ? "out" : "in");
 			}
 			if (stat & 0x0001)
 				bt3c_receive(info);
diff -Nur linux-2.6.29/drivers/bluetooth/btusb.c linux-2.6.29-spica/drivers/bluetooth/btusb.c
--- linux-2.6.29/drivers/bluetooth/btusb.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/bluetooth/btusb.c	2010-03-30 11:01:15.000000000 +0700
@@ -35,7 +35,7 @@
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 
-#define VERSION "0.4"
+#define VERSION "0.5"
 
 static int ignore_dga;
 static int ignore_csr;
@@ -171,6 +171,7 @@
 
 	__u8 cmdreq_type;
 
+	unsigned int sco_num;
 	int isoc_altsetting;
 	int suspend_count;
 };
@@ -496,11 +497,23 @@
 		return 0;
 
 	err = btusb_submit_intr_urb(hdev, GFP_KERNEL);
+	if (err < 0)
+		goto failed;
+
+	err = btusb_submit_bulk_urb(hdev, GFP_KERNEL);
 	if (err < 0) {
-		clear_bit(BTUSB_INTR_RUNNING, &data->flags);
-		clear_bit(HCI_RUNNING, &hdev->flags);
+		usb_kill_anchored_urbs(&data->intr_anchor);
+		goto failed;
 	}
 
+	set_bit(BTUSB_BULK_RUNNING, &data->flags);
+	btusb_submit_bulk_urb(hdev, GFP_KERNEL);
+
+	return 0;
+
+failed:
+	clear_bit(BTUSB_INTR_RUNNING, &data->flags);
+	clear_bit(HCI_RUNNING, &hdev->flags);
 	return err;
 }
 
@@ -655,19 +668,10 @@
 
 	BT_DBG("%s evt %d", hdev->name, evt);
 
-	if (hdev->conn_hash.acl_num > 0) {
-		if (!test_and_set_bit(BTUSB_BULK_RUNNING, &data->flags)) {
-			if (btusb_submit_bulk_urb(hdev, GFP_ATOMIC) < 0)
-				clear_bit(BTUSB_BULK_RUNNING, &data->flags);
-			else
-				btusb_submit_bulk_urb(hdev, GFP_ATOMIC);
-		}
-	} else {
-		clear_bit(BTUSB_BULK_RUNNING, &data->flags);
-		usb_unlink_anchored_urbs(&data->bulk_anchor);
+	if (hdev->conn_hash.sco_num != data->sco_num) {
+		data->sco_num = hdev->conn_hash.sco_num;
+		schedule_work(&data->work);
 	}
-
-	schedule_work(&data->work);
 }
 
 static int inline __set_isoc_interface(struct hci_dev *hdev, int altsetting)
@@ -982,9 +986,11 @@
 	}
 
 	if (test_bit(BTUSB_BULK_RUNNING, &data->flags)) {
-		if (btusb_submit_bulk_urb(hdev, GFP_NOIO) < 0)
+		err = btusb_submit_bulk_urb(hdev, GFP_NOIO);
+		if (err < 0) {
 			clear_bit(BTUSB_BULK_RUNNING, &data->flags);
-		else
+			return err;
+		} else
 			btusb_submit_bulk_urb(hdev, GFP_NOIO);
 	}
 
diff -Nur linux-2.6.29/drivers/bluetooth/hci_h4.c linux-2.6.29-spica/drivers/bluetooth/hci_h4.c
--- linux-2.6.29/drivers/bluetooth/hci_h4.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/bluetooth/hci_h4.c	2010-03-30 11:01:15.000000000 +0700
@@ -102,8 +102,7 @@
 
 	skb_queue_purge(&h4->txq);
 
-	if (h4->rx_skb)
-		kfree_skb(h4->rx_skb);
+	kfree_skb(h4->rx_skb);
 
 	hu->priv = NULL;
 	kfree(h4);
diff -Nur linux-2.6.29/drivers/bluetooth/hci_ll.c linux-2.6.29-spica/drivers/bluetooth/hci_ll.c
--- linux-2.6.29/drivers/bluetooth/hci_ll.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/bluetooth/hci_ll.c	2010-03-30 11:01:15.000000000 +0700
@@ -163,8 +163,7 @@
 	skb_queue_purge(&ll->tx_wait_q);
 	skb_queue_purge(&ll->txq);
 
-	if (ll->rx_skb)
-		kfree_skb(ll->rx_skb);
+	kfree_skb(ll->rx_skb);
 
 	hu->priv = NULL;
 
diff -Nur linux-2.6.29/drivers/char/dcc_tty.c linux-2.6.29-spica/drivers/char/dcc_tty.c
--- linux-2.6.29/drivers/char/dcc_tty.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/char/dcc_tty.c	2010-03-30 11:00:38.000000000 +0700
@@ -0,0 +1,326 @@
+/* drivers/char/dcc_tty.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/console.h>
+#include <linux/hrtimer.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+
+MODULE_DESCRIPTION("DCC TTY Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+static spinlock_t g_dcc_tty_lock = SPIN_LOCK_UNLOCKED;
+static struct hrtimer g_dcc_timer;
+static char g_dcc_buffer[16];
+static int g_dcc_buffer_head;
+static int g_dcc_buffer_count;
+static unsigned g_dcc_write_delay_usecs = 1;
+static struct tty_driver *g_dcc_tty_driver;
+static struct tty_struct *g_dcc_tty;
+static int g_dcc_tty_open_count;
+
+static void dcc_poll_locked(void)
+{
+	char ch;
+	int rch;
+	int written;
+
+	while (g_dcc_buffer_count) {
+		ch = g_dcc_buffer[g_dcc_buffer_head];
+		asm(
+			"mrc 14, 0, r15, c0, c1, 0\n"
+			"mcrcc 14, 0, %1, c0, c5, 0\n"
+			"movcc %0, #1\n"
+			"movcs %0, #0\n"
+			: "=r" (written)
+			: "r" (ch)
+		);
+		if (written) {
+			if (ch == '\n')
+				g_dcc_buffer[g_dcc_buffer_head] = '\r';
+			else {
+				g_dcc_buffer_head = (g_dcc_buffer_head + 1) % ARRAY_SIZE(g_dcc_buffer);
+				g_dcc_buffer_count--;
+				if (g_dcc_tty)
+					tty_wakeup(g_dcc_tty);
+			}
+			g_dcc_write_delay_usecs = 1;
+		} else {
+			if (g_dcc_write_delay_usecs > 0x100)
+				break;
+			g_dcc_write_delay_usecs <<= 1;
+			udelay(g_dcc_write_delay_usecs);
+		}
+	}
+
+	if (g_dcc_tty && !test_bit(TTY_THROTTLED, &g_dcc_tty->flags)) {
+		asm(
+			"mrc 14, 0, %0, c0, c1, 0\n"
+			"tst %0, #(1 << 30)\n"
+			"moveq %0, #-1\n"
+			"mrcne 14, 0, %0, c0, c5, 0\n"
+			: "=r" (rch)
+		);
+		if (rch >= 0) {
+			ch = rch;
+			tty_insert_flip_string(g_dcc_tty, &ch, 1);
+			tty_flip_buffer_push(g_dcc_tty);
+		}
+	}
+
+
+	if (g_dcc_buffer_count)
+		hrtimer_start(&g_dcc_timer, ktime_set(0, g_dcc_write_delay_usecs * NSEC_PER_USEC), HRTIMER_MODE_REL);
+	else
+		hrtimer_start(&g_dcc_timer, ktime_set(0, 20 * NSEC_PER_MSEC), HRTIMER_MODE_REL);
+}
+
+static int dcc_tty_open(struct tty_struct * tty, struct file * filp)
+{
+	int ret;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&g_dcc_tty_lock, irq_flags);
+	if (g_dcc_tty == NULL || g_dcc_tty == tty) {
+		g_dcc_tty = tty;
+		g_dcc_tty_open_count++;
+		ret = 0;
+	} else
+		ret = -EBUSY;
+	spin_unlock_irqrestore(&g_dcc_tty_lock, irq_flags);
+
+	printk("dcc_tty_open, tty %p, f_flags %x, returned %d\n", tty, filp->f_flags, ret);
+
+	return ret;
+}
+
+static void dcc_tty_close(struct tty_struct * tty, struct file * filp)
+{
+	printk("dcc_tty_close, tty %p, f_flags %x\n", tty, filp->f_flags);
+	if (g_dcc_tty == tty) {
+		if (--g_dcc_tty_open_count == 0)
+			g_dcc_tty = NULL;
+	}
+}
+
+static int dcc_write(const unsigned char *buf_start, int count)
+{
+	const unsigned char *buf = buf_start;
+	unsigned long irq_flags;
+	int copy_len;
+	int space_left;
+	int tail;
+
+	if (count < 1)
+		return 0;
+
+	spin_lock_irqsave(&g_dcc_tty_lock, irq_flags);
+	do {
+		tail = (g_dcc_buffer_head + g_dcc_buffer_count) % ARRAY_SIZE(g_dcc_buffer);
+		copy_len = ARRAY_SIZE(g_dcc_buffer) - tail;
+		space_left = ARRAY_SIZE(g_dcc_buffer) - g_dcc_buffer_count;
+		if (copy_len > space_left)
+			copy_len = space_left;
+		if (copy_len > count)
+			copy_len = count;
+		memcpy(&g_dcc_buffer[tail], buf, copy_len);
+		g_dcc_buffer_count += copy_len;
+		buf += copy_len;
+		count -= copy_len;
+		if (copy_len < count && copy_len < space_left) {
+			space_left -= copy_len;
+			copy_len = count;
+			if (copy_len > space_left) {
+				copy_len = space_left;
+			}
+			memcpy(g_dcc_buffer, buf, copy_len);
+			buf += copy_len;
+			count -= copy_len;
+			g_dcc_buffer_count += copy_len;
+		}
+		dcc_poll_locked();
+		space_left = ARRAY_SIZE(g_dcc_buffer) - g_dcc_buffer_count;
+	} while(count && space_left);
+	spin_unlock_irqrestore(&g_dcc_tty_lock, irq_flags);
+	return buf - buf_start;
+}
+
+static int dcc_tty_write(struct tty_struct * tty, const unsigned char *buf, int count)
+{
+	int ret;
+	/* printk("dcc_tty_write %p, %d\n", buf, count); */
+	ret = dcc_write(buf, count);
+	if (ret != count)
+		printk("dcc_tty_write %p, %d, returned %d\n", buf, count, ret);
+	return ret;
+}
+
+static int dcc_tty_write_room(struct tty_struct *tty)
+{
+	int space_left;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&g_dcc_tty_lock, irq_flags);
+	space_left = ARRAY_SIZE(g_dcc_buffer) - g_dcc_buffer_count;
+	spin_unlock_irqrestore(&g_dcc_tty_lock, irq_flags);
+	return space_left;
+}
+
+static int dcc_tty_chars_in_buffer(struct tty_struct *tty)
+{
+	int ret;
+	asm(
+		"mrc 14, 0, %0, c0, c1, 0\n"
+		"mov %0, %0, LSR #30\n"
+		"and %0, %0, #1\n"
+		: "=r" (ret)
+	);
+	return ret;
+}
+
+static void dcc_tty_unthrottle(struct tty_struct * tty)
+{
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&g_dcc_tty_lock, irq_flags);
+	dcc_poll_locked();
+	spin_unlock_irqrestore(&g_dcc_tty_lock, irq_flags);
+}
+
+static enum hrtimer_restart dcc_tty_timer_func(struct hrtimer *timer)
+{
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&g_dcc_tty_lock, irq_flags);
+	dcc_poll_locked();
+	spin_unlock_irqrestore(&g_dcc_tty_lock, irq_flags);
+	return HRTIMER_NORESTART;
+}
+
+void dcc_console_write(struct console *co, const char *b, unsigned count)
+{
+#if 1
+	dcc_write(b, count);
+#else
+	/* blocking printk */
+	while (count > 0) {
+		int written;
+		written = dcc_write(b, count);
+		if (written) {
+			b += written;
+			count -= written;
+		}
+	}
+#endif
+}
+
+static struct tty_driver *dcc_console_device(struct console *c, int *index)
+{
+	*index = 0;
+	return g_dcc_tty_driver;
+}
+
+static int __init dcc_console_setup(struct console *co, char *options)
+{
+	if (co->index != 0)
+		return -ENODEV;
+	return 0;
+}
+
+
+static struct console dcc_console =
+{
+	.name		= "ttyDCC",
+	.write		= dcc_console_write,
+	.device		= dcc_console_device,
+	.setup		= dcc_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+};
+
+static struct tty_operations dcc_tty_ops = {
+	.open = dcc_tty_open,
+	.close = dcc_tty_close,
+	.write = dcc_tty_write,
+	.write_room = dcc_tty_write_room,
+	.chars_in_buffer = dcc_tty_chars_in_buffer,
+	.unthrottle = dcc_tty_unthrottle,
+};
+
+static int __init dcc_tty_init(void)
+{
+	int ret;
+
+	hrtimer_init(&g_dcc_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	g_dcc_timer.function = dcc_tty_timer_func;
+
+	g_dcc_tty_driver = alloc_tty_driver(1);
+	if (!g_dcc_tty_driver) {
+		printk(KERN_ERR "dcc_tty_probe: alloc_tty_driver failed\n");
+		ret = -ENOMEM;
+		goto err_alloc_tty_driver_failed;
+	}
+	g_dcc_tty_driver->owner = THIS_MODULE;
+	g_dcc_tty_driver->driver_name = "dcc";
+	g_dcc_tty_driver->name = "ttyDCC";
+	g_dcc_tty_driver->major = 0; // auto assign
+	g_dcc_tty_driver->minor_start = 0;
+	g_dcc_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
+	g_dcc_tty_driver->subtype = SERIAL_TYPE_NORMAL;
+	g_dcc_tty_driver->init_termios = tty_std_termios;
+	g_dcc_tty_driver->flags = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	tty_set_operations(g_dcc_tty_driver, &dcc_tty_ops);
+	ret = tty_register_driver(g_dcc_tty_driver);
+	if (ret) {
+		printk(KERN_ERR "dcc_tty_probe: tty_register_driver failed, %d\n", ret);
+		goto err_tty_register_driver_failed;
+	}
+	tty_register_device(g_dcc_tty_driver, 0, NULL);
+
+	register_console(&dcc_console);
+	hrtimer_start(&g_dcc_timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+
+	return 0;
+
+err_tty_register_driver_failed:
+	put_tty_driver(g_dcc_tty_driver);
+	g_dcc_tty_driver = NULL;
+err_alloc_tty_driver_failed:
+	return ret;
+}
+
+static void  __exit dcc_tty_exit(void)
+{
+	int ret;
+
+	tty_unregister_device(g_dcc_tty_driver, 0);
+	ret = tty_unregister_driver(g_dcc_tty_driver);
+	if (ret < 0) {
+		printk(KERN_ERR "dcc_tty_remove: tty_unregister_driver failed, %d\n", ret);
+	} else {
+		put_tty_driver(g_dcc_tty_driver);
+	}
+	g_dcc_tty_driver = NULL;
+}
+
+module_init(dcc_tty_init);
+module_exit(dcc_tty_exit);
+
+
diff -Nur linux-2.6.29/drivers/char/Kconfig linux-2.6.29-spica/drivers/char/Kconfig
--- linux-2.6.29/drivers/char/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/char/Kconfig	2010-05-06 12:42:45.674299703 +0700
@@ -88,6 +88,19 @@
 	 information. For framebuffer console users, please refer to
 	 <file:Documentation/fb/fbcon.txt>.
 
+config DEVMEM
+	bool "Memory device driver"
+	default y
+	help
+	  The memory driver provides two character devices, mem and kmem, which
+	  provide access to the system's memory. The mem device is a view of
+	  physical memory, and each byte in the device corresponds to the
+	  matching physical address. The kmem device is the same as mem, but
+	  the addresses correspond to the kernel's virtual address space rather
+	  than physical memory. These devices are standard parts of a Linux
+	  system and most users should say Y here. You might say N if very
+	  security conscience or memory is tight.
+
 config DEVKMEM
 	bool "/dev/kmem virtual device support"
 	default y
@@ -880,6 +893,14 @@
 
 endif # RTC_LIB
 
+if S3C64XX_ADCTS=n
+config S3C_ADC
+	bool "S3C ADC Driver"
+	depends on PLAT_S3C
+	help
+	  ADC (A/D Conversion) driver for Samsung S3C2450/2416, S3C6400/6410.
+endif
+
 config DTLK
 	tristate "Double Talk PC internal speech card support"
 	depends on ISA
@@ -1099,7 +1120,20 @@
 	depends on ISA || PCI
 	default y
 
+config DCC_TTY
+	tristate "DCC tty driver"
+	depends on ARM
+
 source "drivers/s390/char/Kconfig"
 
+config S3C_MEM
+	bool "Support for /dev/s3c-mem"
+	default y
+	---help---
+	  If you do say Y here, you can allocate physically linear memories from system memory.
+	  And you can share the memory at the other process using re-allocation ioctl.
+
+	  If unsure, say Y.
+
 endmenu
 
diff -Nur linux-2.6.29/drivers/char/Makefile linux-2.6.29-spica/drivers/char/Makefile
--- linux-2.6.29/drivers/char/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/char/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -77,6 +77,7 @@
 obj-$(CONFIG_GEN_RTC)		+= genrtc.o
 obj-$(CONFIG_EFI_RTC)		+= efirtc.o
 obj-$(CONFIG_DS1302)		+= ds1302.o
+obj-$(CONFIG_S3C_ADC)		+= s3c-adc.o
 obj-$(CONFIG_XILINX_HWICAP)	+= xilinx_hwicap/
 ifeq ($(CONFIG_GENERIC_NVRAM),y)
   obj-$(CONFIG_NVRAM)	+= generic_nvram.o
@@ -106,11 +107,14 @@
 obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM)		+= tpm/
 
+obj-$(CONFIG_DCC_TTY)		+= dcc_tty.o
 obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
 
 obj-$(CONFIG_JS_RTC)		+= js-rtc.o
 js-rtc-y = rtc.o
 
+obj-$(CONFIG_S3C_MEM)       += s3c_mem.o
+
 # Files generated that shall be removed upon make clean
 clean-files := consolemap_deftbl.c defkeymap.c
 
diff -Nur linux-2.6.29/drivers/char/mem.c linux-2.6.29-spica/drivers/char/mem.c
--- linux-2.6.29/drivers/char/mem.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/char/mem.c	2010-05-06 12:42:45.674299703 +0700
@@ -80,6 +80,7 @@
 }
 #endif
 
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM)
 #ifdef CONFIG_STRICT_DEVMEM
 static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 {
@@ -105,7 +106,9 @@
 	return 1;
 }
 #endif
+#endif
 
+#ifdef CONFIG_DEVMEM
 void __attribute__((weak)) unxlate_dev_mem_ptr(unsigned long phys, void *addr)
 {
 }
@@ -254,6 +257,9 @@
 	*ppos += written;
 	return written;
 }
+#endif	/* CONFIG_DEVMEM */
+
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM)
 
 int __attribute__((weak)) phys_mem_access_prot_allowed(struct file *file,
 	unsigned long pfn, unsigned long size, pgprot_t *vma_prot)
@@ -367,6 +373,7 @@
 	}
 	return 0;
 }
+#endif	/* CONFIG_DEVMEM */
 
 #ifdef CONFIG_DEVKMEM
 static int mmap_kmem(struct file * file, struct vm_area_struct * vma)
@@ -755,6 +762,8 @@
 	return file->f_pos = 0;
 }
 
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM) || defined(CONFIG_DEVPORT)
+
 /*
  * The memory devices use the full 32/64 bits of the offset, and so we cannot
  * check against negative addresses: they are ok. The return value is weird,
@@ -786,10 +795,15 @@
 	return ret;
 }
 
+#endif
+
+#if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM) || defined(CONFIG_DEVPORT)
 static int open_port(struct inode * inode, struct file * filp)
 {
-	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
+	return 0;	/* temporary open to all process */
+//	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
 }
+#endif
 
 #define zero_lseek	null_lseek
 #define full_lseek      null_lseek
@@ -799,6 +813,7 @@
 #define open_kmem	open_mem
 #define open_oldmem	open_mem
 
+#ifdef CONFIG_DEVMEM
 static const struct file_operations mem_fops = {
 	.llseek		= memory_lseek,
 	.read		= read_mem,
@@ -807,6 +822,7 @@
 	.open		= open_mem,
 	.get_unmapped_area = get_unmapped_area_mem,
 };
+#endif
 
 #ifdef CONFIG_DEVKMEM
 static const struct file_operations kmem_fops = {
@@ -863,6 +879,16 @@
 };
 #endif
 
+#ifdef CONFIG_S3C_MEM
+extern int s3c_mem_mmap(struct file* filp, struct vm_area_struct *vma);
+extern int s3c_mem_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+
+static const struct file_operations s3c_mem_fops = {
+	.ioctl  = s3c_mem_ioctl,
+	.mmap   = s3c_mem_mmap,
+};
+#endif
+
 static ssize_t kmsg_write(struct file * file, const char __user * buf,
 			  size_t count, loff_t *ppos)
 {
@@ -894,11 +920,13 @@
 
 	lock_kernel();
 	switch (iminor(inode)) {
+#ifdef CONFIG_DEVMEM
 		case 1:
 			filp->f_op = &mem_fops;
 			filp->f_mapping->backing_dev_info =
 				&directly_mappable_cdev_bdi;
 			break;
+#endif
 #ifdef CONFIG_DEVKMEM
 		case 2:
 			filp->f_op = &kmem_fops;
@@ -935,6 +963,11 @@
 			filp->f_op = &oldmem_fops;
 			break;
 #endif
+#ifdef CONFIG_S3C_MEM
+		case 13:
+			filp->f_op = &s3c_mem_fops;
+			break;
+#endif
 		default:
 			unlock_kernel();
 			return -ENXIO;
@@ -955,7 +988,9 @@
 	umode_t			mode;
 	const struct file_operations	*fops;
 } devlist[] = { /* list of minor devices */
+#ifdef CONFIG_DEVMEM
 	{1, "mem",     S_IRUSR | S_IWUSR | S_IRGRP, &mem_fops},
+#endif
 #ifdef CONFIG_DEVKMEM
 	{2, "kmem",    S_IRUSR | S_IWUSR | S_IRGRP, &kmem_fops},
 #endif
@@ -971,6 +1006,9 @@
 #ifdef CONFIG_CRASH_DUMP
 	{12,"oldmem",    S_IRUSR | S_IWUSR | S_IRGRP, &oldmem_fops},
 #endif
+#ifdef CONFIG_S3C_MEM
+	{13,"s3c-mem", S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, &s3c_mem_fops},
+#endif
 };
 
 static struct class *mem_class;
diff -Nur linux-2.6.29/drivers/char/s3c-adc.c linux-2.6.29-spica/drivers/char/s3c-adc.c
--- linux-2.6.29/drivers/char/s3c-adc.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/char/s3c-adc.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,438 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (c) 2004 Arnaud Patard <arnaud.patard@rtp-net.org>
+ * iPAQ H1940 touchscreen support
+ *
+ * ChangeLog
+ *
+ * 2004-09-05: Herbert Ptzl <herbert@13thfloor.at>
+ *	- added clock (de-)allocation code
+ *
+ * 2005-03-06: Arnaud Patard <arnaud.patard@rtp-net.org>
+ *      - h1940_ -> s3c24xx (this driver is now also used on the n30
+ *        machines :P)
+ *      - Debug messages are now enabled with the config option
+ *        TOUCHSCREEN_S3C_DEBUG
+ *      - Changed the way the value are read
+ *      - Input subsystem should now work
+ *      - Use ioremap and readl/writel
+ *
+ * 2005-03-23: Arnaud Patard <arnaud.patard@rtp-net.org>
+ *      - Make use of some undocumented features of the touchscreen
+ *        controller
+ *
+ */
+
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#include <asm/uaccess.h>
+
+#include <plat/regs-adc.h>
+#include <plat/adc.h>
+#include <mach/irqs.h>
+
+#define ADC_MINOR 	131
+#define ADC_INPUT_PIN   _IOW('S', 0x0c, unsigned long)
+
+#define ADC_WITH_TOUCHSCREEN
+
+static struct clk	*adc_clock;
+static void __iomem 	*base_addr;
+static int adc_port =  0;
+struct s3c_adc_mach_info *plat_data;
+
+static int ready_to_work = 0;
+
+#ifdef ADC_WITH_TOUCHSCREEN
+static DEFINE_MUTEX(adc_mutex);
+struct mutex *g_s3c_adc_mutex = &adc_mutex;
+
+#ifndef ADC_WITH_TOUCHSCREEN
+static struct resource	*adc_mem;
+#endif
+
+static unsigned long data_for_ADCCON;
+static unsigned long data_for_ADCTSC;
+
+static void s3c_adc_save_SFR_on_ADC(void) {
+
+	data_for_ADCCON = readl(base_addr+S3C_ADCCON);
+	data_for_ADCTSC = readl(base_addr+S3C_ADCTSC);
+}
+
+static void s3c_adc_restore_SFR_on_ADC(void) {
+
+	writel(data_for_ADCCON, base_addr+S3C_ADCCON);
+	writel(data_for_ADCTSC, base_addr+S3C_ADCTSC);
+}
+#else
+static DEFINE_MUTEX(adc_mutex);
+#endif
+
+static int s3c_adc_open(struct inode *inode, struct file *file)
+{
+	printk(KERN_INFO " s3c_adc_open() entered\n");
+	return 0;
+}
+
+int s3c_adc_convert(void)
+{
+	unsigned int adc_return = 0;
+	unsigned long data0;
+	unsigned long data1;
+	int i = 0;
+
+	if (!ready_to_work) {
+		pr_err("%s:E: tried to read ADC before ready to work\n", __func__);
+		return -EIO;
+	}
+	
+	writel((readl(base_addr+S3C_ADCCON) & ~S3C_ADCCON_MUXMASK)
+			| S3C_ADCCON_SELMUX(adc_port), base_addr+S3C_ADCCON);
+
+	/* Normal Operation Mode */
+	writel(readl(base_addr+S3C_ADCCON) & ~S3C_ADCCON_STDBM,
+			base_addr+S3C_ADCCON);
+
+	do {
+		writel(readl(base_addr+S3C_ADCCON) | S3C_ADCCON_ENABLE_START,
+				base_addr+S3C_ADCCON);
+
+		udelay(10);
+
+		data0 = readl(base_addr+S3C_ADCCON);
+		if (!(data0 & S3C_ADCCON_ENABLE_START) && (data0 & S3C_ADCCON_ECFLG)) {
+			data1 = readl(base_addr+S3C_ADCDAT0);
+			break;
+		} else {
+			pr_err("%s:E: read ADC failed(i=%d,port=%d)\n",
+					__func__, i, adc_port);
+			if (++i > 10)
+				goto __end__;
+		}
+	} while (1);
+
+	if (plat_data->resolution == 12)
+	{
+		adc_return = data1 & S3C_ADCDAT0_XPDATA_MASK_12BIT;
+	} else {
+		adc_return = data1 & S3C_ADCDAT0_XPDATA_MASK;
+	}
+
+__end__:
+	/* Standby Mode */
+	writel(readl(base_addr+S3C_ADCCON) | S3C_ADCCON_STDBM,
+			base_addr+S3C_ADCCON);
+
+	return adc_return;
+}
+
+#if 0
+static int s3c_adc_get(struct s3c_adc_request *req)
+{
+	unsigned adc_channel = req->channel;
+	int adc_value_ret = 0;
+
+	adc_value_ret = s3c_adc_convert();
+
+	req->callback(adc_channel,req->param,adc_value_ret);
+
+	return 0;
+}
+#endif
+
+int s3c_adc_get_adc_data(int channel)
+{	
+	int adc_value = 0;
+	int cur_adc_port = 0;
+
+#ifdef ADC_WITH_TOUCHSCREEN
+        mutex_lock(&adc_mutex);
+	s3c_adc_save_SFR_on_ADC();
+#else
+        mutex_lock(&adc_mutex);
+#endif
+
+	cur_adc_port = adc_port;
+	adc_port = channel;
+
+	adc_value = s3c_adc_convert();
+
+	adc_port = cur_adc_port;
+
+#ifdef ADC_WITH_TOUCHSCREEN
+	s3c_adc_restore_SFR_on_ADC();
+	mutex_unlock(&adc_mutex);
+#else
+	mutex_unlock(&adc_mutex);
+#endif
+
+	pr_debug("%s : Converted Value: %03d\n", __FUNCTION__, adc_value);
+
+	return adc_value;
+}
+EXPORT_SYMBOL(s3c_adc_get_adc_data);
+
+
+static ssize_t
+s3c_adc_read(struct file *file, char __user * buffer,
+		size_t size, loff_t * pos)
+{
+	int  adc_value = 0;
+
+	printk(KERN_INFO " s3c_adc_read() entered\n");
+
+#ifdef ADC_WITH_TOUCHSCREEN
+        mutex_lock(&adc_mutex);
+	s3c_adc_save_SFR_on_ADC();
+#endif
+
+	adc_value = s3c_adc_convert();
+
+#ifdef ADC_WITH_TOUCHSCREEN
+	s3c_adc_restore_SFR_on_ADC();
+	mutex_unlock(&adc_mutex);
+#endif
+
+	printk(KERN_INFO " Converted Value: %03d\n", adc_value);
+
+	if (copy_to_user(buffer, &adc_value, sizeof(unsigned int))) {
+		return -EFAULT;
+	}
+	return sizeof(unsigned int);
+}
+
+
+static int s3c_adc_ioctl(struct inode *inode, struct file *file,
+	unsigned int cmd, unsigned long arg)
+{
+
+       printk(KERN_INFO " s3c_adc_ioctl(cmd:: %d) entered\n", cmd);
+
+	switch (cmd) {
+
+		case ADC_INPUT_PIN:
+			  adc_port = (unsigned int) arg;
+
+                       if (adc_port >= 4)
+                            printk(" %d is already reserved for TouchScreen\n", adc_port);
+                      return 0;
+
+              default:
+			return -ENOIOCTLCMD;
+
+	}
+}
+
+static struct file_operations s3c_adc_fops = {
+	.owner		= THIS_MODULE,
+	.read		= s3c_adc_read,
+	.open		= s3c_adc_open,
+	.ioctl		= s3c_adc_ioctl,
+};
+
+static struct miscdevice s3c_adc_miscdev = {
+	.minor		= ADC_MINOR,
+	.name		= "adc",
+	.fops		= &s3c_adc_fops,
+};
+
+static struct s3c_adc_mach_info *s3c_adc_get_platdata(struct device *dev)
+{
+	if(dev->platform_data != NULL)
+	{
+		printk(KERN_INFO "ADC platform data read\n");
+		return (struct s3c_adc_mach_info*) dev->platform_data;
+	}else{
+		printk(KERN_INFO "No ADC platform data \n");
+		return 0;
+	}
+}
+
+/*
+ * The functions for inserting/removing us as a module.
+ */
+
+static int __init s3c_adc_probe(struct platform_device *pdev)
+{
+	struct resource	*res;
+	struct device *dev;
+	int ret;
+	int size;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev = &pdev->dev;
+
+	if(res == NULL){
+		dev_err(dev,"no memory resource specified\n");
+		return -ENOENT;
+	}
+
+	size = (res->end - res->start) + 1;
+	
+#ifndef ADC_WITH_TOUCHSCREEN
+	adc_mem = request_mem_region(res->start, size, pdev->name);
+	if(adc_mem == NULL){
+		dev_err(dev, "failed to get memory region\n");
+		ret = -ENOENT;
+		goto err_req;
+	}
+#endif
+
+	base_addr = ioremap(res->start, size);
+	if(base_addr ==  NULL){
+		dev_err(dev,"fail to ioremap() region\n");
+		ret = -ENOENT;
+		goto err_map;
+	}
+	
+	adc_clock = clk_get(&pdev->dev, "adc");
+
+	if(IS_ERR(adc_clock)){
+		dev_err(dev,"failed to fine ADC clock source\n");
+		ret = PTR_ERR(adc_clock);
+		goto err_clk;
+	}
+
+	clk_enable(adc_clock);
+
+	/* read platform data from device struct */
+	plat_data = s3c_adc_get_platdata(&pdev->dev);
+
+	if ((plat_data->presc & 0xff) > 0)
+		writel(S3C_ADCCON_PRSCEN | S3C_ADCCON_PRSCVL(plat_data->presc & 0xff), base_addr + S3C_ADCCON);
+	else
+		writel(0, base_addr+S3C_ADCCON);
+
+	/* Initialise registers */
+	if ((plat_data->delay & 0xffff) > 0)
+		writel(plat_data->delay & 0xffff, base_addr + S3C_ADCDLY);
+
+	if (plat_data->resolution == 12) 
+		writel(readl(base_addr + S3C_ADCCON) | S3C_ADCCON_RESSEL_12BIT, base_addr + S3C_ADCCON);
+
+	ret = misc_register(&s3c_adc_miscdev);
+	if (ret) {
+		printk (KERN_ERR "cannot register miscdev on minor=%d (%d)\n",
+			ADC_MINOR, ret);
+		goto err_clk;
+	}
+
+	ready_to_work = 1;
+	printk(KERN_INFO "S3C64XX ADC driver successfully probed !\n");
+
+	return 0;
+
+err_clk:
+	clk_disable(adc_clock);
+	clk_put(adc_clock);
+
+err_map:
+	iounmap(base_addr);
+
+#ifndef ADC_WITH_TOUCHSCREEN
+err_req:
+	release_resource(adc_mem);
+	kfree(adc_mem);
+#endif
+	return ret;
+}
+
+
+static int s3c_adc_remove(struct platform_device *dev)
+{
+	printk(KERN_INFO "s3c_adc_remove() of ADC called !\n");
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static unsigned int adccon, adctsc, adcdly;
+
+static int s3c_adc_suspend(struct platform_device *dev, pm_message_t state)
+{
+	ready_to_work = 0;
+
+	adccon = readl(base_addr+S3C_ADCCON);
+	adctsc = readl(base_addr+S3C_ADCTSC);
+	adcdly = readl(base_addr+S3C_ADCDLY);
+
+	clk_disable(adc_clock);
+
+	return 0;
+}
+
+static int s3c_adc_resume(struct platform_device *pdev)
+{
+	clk_enable(adc_clock);
+
+	writel(adccon, base_addr+S3C_ADCCON);
+	writel(adctsc, base_addr+S3C_ADCTSC);
+	writel(adcdly, base_addr+S3C_ADCDLY);
+
+	ready_to_work = 1;
+
+	return 0;
+}
+#else
+#define s3c_adc_suspend NULL
+#define s3c_adc_resume  NULL
+#endif
+
+static struct platform_driver s3c_adc_driver = {
+       .probe          = s3c_adc_probe,
+       .remove         = s3c_adc_remove,
+       .suspend        = s3c_adc_suspend,
+       .resume         = s3c_adc_resume,
+       .driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c-adc",
+	},
+};
+
+static char banner[] __initdata = KERN_INFO "S3C64XX ADC driver, (c) 2007 Samsung Electronics\n";
+
+int __init s3c_adc_init(void)
+{
+	printk(banner);
+	return platform_driver_register(&s3c_adc_driver);
+}
+
+void __exit s3c_adc_exit(void)
+{
+	platform_driver_unregister(&s3c_adc_driver);
+}
+
+module_init(s3c_adc_init);
+module_exit(s3c_adc_exit);
+
+MODULE_AUTHOR("boyko.lee@samsung.com>");
+MODULE_DESCRIPTION("S3C64XX ADC driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/char/s3c_mem.c linux-2.6.29-spica/drivers/char/s3c_mem.c
--- linux-2.6.29/drivers/char/s3c_mem.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/char/s3c_mem.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,232 @@
+/*
+ * drivers/char/s3c_mem.c
+ *
+ * Revision 1.0
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	    S3C MEM driver
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/types.h>
+#include <linux/timer.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/errno.h> 	/* error codes */
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/dma-mapping.h>
+#include <linux/version.h>
+#include <linux/unistd.h>
+#include <linux/mman.h>
+
+#include <asm/div64.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+#include <mach/map.h>
+#include <mach/hardware.h>
+#include <mach/dma.h>
+#include <plat/dma.h>
+
+#include "s3c_mem.h"
+
+static int flag = 0;
+
+static unsigned int physical_address;
+
+int s3c_mem_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	void * virt_addr;
+	struct mm_struct *mm = current->mm;
+	struct s3c_mem_alloc param;
+
+	DEBUG("s3c_mem ioctl, cmd = 0x%x\n", cmd);
+
+	switch (cmd) {
+		case S3C_MEM_ALLOC:
+			mutex_lock(&mem_alloc_lock);
+			if(copy_from_user(&param, (struct s3c_mem_alloc *)arg, sizeof(struct s3c_mem_alloc))){
+				mutex_unlock(&mem_alloc_lock);			
+				return -EFAULT;
+			}
+			flag = MEM_ALLOC;
+			param.vir_addr = do_mmap(file, 0, param.size, PROT_READ|PROT_WRITE, MAP_SHARED, 0);
+			DEBUG("param.vir_addr = %08x, %d\n", param.vir_addr, __LINE__);
+			if(param.vir_addr == -EINVAL) {
+				printk("S3C_MEM_ALLOC FAILED\n");
+				flag = 0;
+				mutex_unlock(&mem_alloc_lock);			
+				return -EFAULT;
+			}
+			param.phy_addr = physical_address;
+			DEBUG("KERNEL MALLOC : param.phy_addr = 0x%X \t size = %d \t param.vir_addr = 0x%X, %d\n", param.phy_addr, param.size, param.vir_addr, __LINE__);
+
+			if(copy_to_user((struct s3c_mem_alloc *)arg, &param, sizeof(struct s3c_mem_alloc))){
+				flag = 0;
+				mutex_unlock(&mem_alloc_lock);
+				return -EFAULT;		
+			}
+			flag = 0;
+			mutex_unlock(&mem_alloc_lock);
+			
+			break;
+
+		case S3C_MEM_FREE:	
+			mutex_lock(&mem_free_lock);
+			if(copy_from_user(&param, (struct s3c_mem_alloc *)arg, sizeof(struct s3c_mem_alloc))){
+				mutex_unlock(&mem_free_lock);
+				return -EFAULT;
+			}
+
+			DEBUG("KERNEL FREE : param.phy_addr = 0x%X \t size = %d \t param.vir_addr = 0x%X, %d\n", param.phy_addr, param.size, param.vir_addr, __LINE__);
+
+			if (do_munmap(mm, param.vir_addr, param.size) < 0) {
+				printk("do_munmap() failed !!\n");
+				mutex_unlock(&mem_free_lock);
+				return -EINVAL;
+			}
+			virt_addr = phys_to_virt(param.phy_addr);
+
+			kfree(virt_addr);
+			param.size = 0;
+			DEBUG("do_munmap() succeed !!\n");
+
+			if(copy_to_user((struct s3c_mem_alloc *)arg, &param, sizeof(struct s3c_mem_alloc))){
+				mutex_unlock(&mem_free_lock);
+				return -EFAULT;
+			}
+			
+			mutex_unlock(&mem_free_lock);
+			
+			break;
+
+		case S3C_MEM_SHARE_ALLOC:		
+			mutex_lock(&mem_share_alloc_lock);
+			if(copy_from_user(&param, (struct s3c_mem_alloc *)arg, sizeof(struct s3c_mem_alloc))){
+				mutex_unlock(&mem_share_alloc_lock);
+				return -EFAULT;
+			}
+			flag = MEM_ALLOC_SHARE;
+
+			physical_address = param.phy_addr;
+			DEBUG("param.phy_addr = %08x, %d\n", physical_address, __LINE__);
+
+			param.vir_addr = do_mmap(file, 0, param.size, PROT_READ|PROT_WRITE, MAP_SHARED, 0);
+			DEBUG("param.vir_addr = %08x, %d\n", param.vir_addr, __LINE__);
+
+			if(param.vir_addr == -EINVAL) {
+				printk("S3C_MEM_SHARE_ALLOC FAILED\n");
+				flag = 0;
+				mutex_unlock(&mem_share_alloc_lock);
+				return -EFAULT;
+			}
+
+			DEBUG("MALLOC_SHARE : param.phy_addr = 0x%X \t size = %d \t param.vir_addr = 0x%X, %d\n", param.phy_addr, param.size, param.vir_addr, __LINE__);
+
+			if(copy_to_user((struct s3c_mem_alloc *)arg, &param, sizeof(struct s3c_mem_alloc))){
+				flag = 0;
+				mutex_unlock(&mem_share_alloc_lock);
+				return -EFAULT;		
+			}
+
+			flag = 0;
+			
+			mutex_unlock(&mem_share_alloc_lock);
+			
+			break;
+
+		case S3C_MEM_SHARE_FREE:	
+			mutex_lock(&mem_share_free_lock);
+			if(copy_from_user(&param, (struct s3c_mem_alloc *)arg, sizeof(struct s3c_mem_alloc))){
+				mutex_unlock(&mem_share_free_lock);
+				return -EFAULT;		
+			}
+
+			DEBUG("MEM_SHARE_FREE : param.phy_addr = 0x%X \t size = %d \t param.vir_addr = 0x%X, %d\n", param.phy_addr, param.size, param.vir_addr, __LINE__);
+
+			if (do_munmap(mm, param.vir_addr, param.size) < 0) {
+				printk("do_munmap() failed - MEM_SHARE_FREE!!\n");
+				mutex_unlock(&mem_share_free_lock);
+				return -EINVAL;
+			}
+
+			param.vir_addr = 0;
+			DEBUG("do_munmap() succeed !! - MEM_SHARE_FREE\n");
+
+			if(copy_to_user((struct s3c_mem_alloc *)arg, &param, sizeof(struct s3c_mem_alloc))){
+				mutex_unlock(&mem_share_free_lock);
+				return -EFAULT;		
+			}
+
+			mutex_unlock(&mem_share_free_lock);
+			
+			break;
+			
+		default:
+			DEBUG("s3c_mem_ioctl() : default !!\n");
+			return -EINVAL;
+	}
+	
+	return 0;
+}
+
+int s3c_mem_mmap(struct file* filp, struct vm_area_struct *vma)
+{
+	unsigned long pageFrameNo, size, phys_addr;
+	void * virt_addr;
+
+	size = vma->vm_end - vma->vm_start;
+
+	switch (flag) { 
+	case MEM_ALLOC :
+		virt_addr = kmalloc(size, GFP_DMA|GFP_ATOMIC);
+
+		if (virt_addr == NULL) {
+			printk("kmalloc() failed !\n");
+			return -EINVAL;
+		}
+		DEBUG("MMAP_KMALLOC : virt addr = 0x%08x, size = %d, %d\n", virt_addr, size, __LINE__);
+		phys_addr = virt_to_phys(virt_addr);
+		physical_address = (unsigned int)phys_addr;
+
+		//DEBUG("MMAP_KMALLOC : phys addr = 0x%p\n", phys_addr);
+		pageFrameNo = __phys_to_pfn(phys_addr);
+		//DEBUG("MMAP_KMALLOC : PFN = 0x%x\n", pageFrameNo);
+		break;
+
+	case MEM_ALLOC_SHARE :
+		DEBUG("MMAP_KMALLOC_SHARE : phys addr = 0x%08x, %d\n", physical_address, __LINE__);
+		
+		// page frame number of the address for the physical_address to be shared.
+		pageFrameNo = __phys_to_pfn(physical_address);
+		//DEBUG("MMAP_KMALLOC_SHARE: PFN = 0x%x\n", pageFrameNo);
+		DEBUG("MMAP_KMALLOC_SHARE : vma->end = 0x%08x, vma->start = 0x%08x, size = %d, %d\n", vma->vm_end, vma->vm_start, size, __LINE__);
+		break;
+
+	default :
+		break;
+	}
+	
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	vma->vm_flags |= VM_RESERVED;
+
+	if (remap_pfn_range(vma, vma->vm_start, pageFrameNo, size, vma->vm_page_prot)) {
+		printk("s3c_mem_mmap() : remap_pfn_range() failed !\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(s3c_mem_ioctl);
+EXPORT_SYMBOL(s3c_mem_mmap);
diff -Nur linux-2.6.29/drivers/char/s3c_mem.h linux-2.6.29-spica/drivers/char/s3c_mem.h
--- linux-2.6.29/drivers/char/s3c_mem.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/char/s3c_mem.h	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,32 @@
+#undef	DEBUG_S3C_MEM
+
+#ifdef DEBUG_S3C_MEM
+#define DEBUG(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG(fmt,args...) do {} while(0)
+#endif
+
+#define MEM_IOCTL_MAGIC		'M'
+
+#define S3C_MEM_ALLOC			_IOWR(MEM_IOCTL_MAGIC, 310, struct s3c_mem_alloc)
+#define S3C_MEM_FREE			_IOWR(MEM_IOCTL_MAGIC, 311, struct s3c_mem_alloc)
+#define S3C_MEM_SHARE_ALLOC		_IOWR(MEM_IOCTL_MAGIC, 314, struct s3c_mem_alloc)
+#define S3C_MEM_SHARE_FREE		_IOWR(MEM_IOCTL_MAGIC, 315, struct s3c_mem_alloc)
+
+#define MEM_ALLOC		1
+#define MEM_ALLOC_SHARE		2
+
+#define S3C_MEM_MINOR  		13
+
+static DEFINE_MUTEX(mem_alloc_lock);
+static DEFINE_MUTEX(mem_free_lock);
+
+static DEFINE_MUTEX(mem_share_alloc_lock);
+static DEFINE_MUTEX(mem_share_free_lock);
+
+struct s3c_mem_alloc {
+	int		size;
+	unsigned int 	vir_addr;
+	unsigned int 	phy_addr;
+};
+
diff -Nur linux-2.6.29/drivers/cpufreq/cpufreq.c linux-2.6.29-spica/drivers/cpufreq/cpufreq.c
--- linux-2.6.29/drivers/cpufreq/cpufreq.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/cpufreq/cpufreq.c	2010-05-06 12:42:45.684270633 +0700
@@ -1631,6 +1631,61 @@
 }
 EXPORT_SYMBOL(cpufreq_get_policy);
 
+/**
+ * cpufreq_set_policy - get the current cpufreq_policy
+ * @policy: struct cpufreq_policy into which the current cpufreq_policy is written
+ *
+ * Writes appropriate cpufreq policy per request.
+ * by hskang
+ */
+int cpufreq_set_policy(unsigned int cpu, const char *buf)
+{
+	unsigned int ret = -EINVAL;
+	char	str_governor[16];
+	struct cpufreq_policy new_policy;
+	struct cpufreq_policy *data = cpufreq_cpu_get(cpu);
+
+	ret = cpufreq_get_policy(&new_policy, cpu);
+	if (ret)
+		return ret;
+
+	ret = sscanf (buf, "%15s", str_governor);
+	if (ret != 1)
+		return -EINVAL;
+
+	if (cpufreq_parse_governor(str_governor, &new_policy.policy,
+						&new_policy.governor))
+		return -EINVAL;
+
+	/* Do not use cpufreq_set_policy here or the user_policy.max
+	   will be wrongly overridden */
+	ret = __cpufreq_set_policy(data, &new_policy);
+
+	data->user_policy.policy = data->policy;
+	data->user_policy.governor = data->governor;
+
+	if (ret)
+		return ret;
+	else
+		return 0;
+}
+EXPORT_SYMBOL(cpufreq_set_policy);
+
+/**
+ * cpufreq_get_policy_name - get the current cpufreq_policy name
+ * &policy : struct cpufreq_policy into which the current cpufreq_policy is written
+ *
+ * Writes appropriate cpufreq policy per request.
+ * by hskang
+ */
+char cpufreq_governor_name[CPUFREQ_NAME_LEN];
+void cpufreq_get_cpufreq_name(unsigned int cpu)
+{
+	struct cpufreq_policy *data = cpufreq_cpu_get(cpu);
+
+	strcpy (cpufreq_governor_name, data->governor->name);
+}
+EXPORT_SYMBOL(cpufreq_get_cpufreq_name);
 
 /*
  * data   : current policy.
diff -Nur linux-2.6.29/drivers/cpufreq/cpufreq_conservative.c linux-2.6.29-spica/drivers/cpufreq/cpufreq_conservative.c
--- linux-2.6.29/drivers/cpufreq/cpufreq_conservative.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/cpufreq/cpufreq_conservative.c	2010-05-06 12:42:45.684270633 +0700
@@ -34,8 +34,15 @@
  * It helps to keep variable names smaller, simpler
  */
 
-#define DEF_FREQUENCY_UP_THRESHOLD		(80)
-#define DEF_FREQUENCY_DOWN_THRESHOLD		(20)
+#define DEF_FREQUENCY_UP_THRESHOLD		(70)
+#define DEF_FREQUENCY_DOWN_THRESHOLD		(40)
+#ifdef CONFIG_CPU_S3C6410
+#define DEF_SAMPLING_FREQ_STEP	20
+extern int dvfs_change_quick;
+extern unsigned int s3c64xx_target_frq(unsigned int pred_freq, int flag);
+#else
+#define DEF_SAMPLING_FREQ_STEP 5
+#endif /* CONFIG_CPU_S3C6410 */
 
 /*
  * The polling frequency of this governor depends on the capability of
@@ -51,11 +58,10 @@
 #define MIN_SAMPLING_RATE_RATIO			(2)
 /* for correct statistics, we need at least 10 ticks between each measure */
 #define MIN_STAT_SAMPLING_RATE			\
-			(MIN_SAMPLING_RATE_RATIO * jiffies_to_usecs(10))
+	(MIN_SAMPLING_RATE_RATIO * jiffies_to_usecs(CONFIG_CPU_FREQ_MIN_TICKS))
 #define MIN_SAMPLING_RATE			\
 			(def_sampling_rate / MIN_SAMPLING_RATE_RATIO)
 #define MAX_SAMPLING_RATE			(500 * def_sampling_rate)
-#define DEF_SAMPLING_RATE_LATENCY_MULTIPLIER	(1000)
 #define DEF_SAMPLING_DOWN_FACTOR		(1)
 #define MAX_SAMPLING_DOWN_FACTOR		(10)
 #define TRANSITION_LATENCY_LIMIT		(10 * 1000 * 1000)
@@ -99,7 +105,11 @@
 	.down_threshold = DEF_FREQUENCY_DOWN_THRESHOLD,
 	.sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR,
 	.ignore_nice = 0,
+#ifdef CONFIG_CPU_S3C6410
+	.freq_step = DEF_SAMPLING_FREQ_STEP,
+#else
 	.freq_step = 5,
+#endif /* CONFIG_CPU_S3C6410 */
 };
 
 static inline unsigned int get_cpu_idle_time(unsigned int cpu)
@@ -328,12 +338,13 @@
 };
 
 /************************** sysfs end ************************/
-
 static void dbs_check_cpu(int cpu)
 {
 	unsigned int idle_ticks, up_idle_ticks, down_idle_ticks;
 	unsigned int tmp_idle_ticks, total_idle_ticks;
+#ifndef CONFIG_CPU_S3C6410
 	unsigned int freq_target;
+#endif /* CONFIG_CPU_S3C6410 */
 	unsigned int freq_down_sampling_rate;
 	struct cpu_dbs_info_s *this_dbs_info = &per_cpu(cpu_dbs_info, cpu);
 	struct cpufreq_policy *policy;
@@ -374,7 +385,12 @@
 	up_idle_ticks = (100 - dbs_tuners_ins.up_threshold) *
 			usecs_to_jiffies(dbs_tuners_ins.sampling_rate);
 
+#ifdef CONFIG_CPU_S3C6410
+	if ((idle_ticks < up_idle_ticks) || (dvfs_change_quick)) {
+		dvfs_change_quick = 0;
+#else
 	if (idle_ticks < up_idle_ticks) {
+#endif /* CONFIG_CPU_S3C6410 */
 		this_dbs_info->down_skip = 0;
 		this_dbs_info->prev_cpu_idle_down =
 			this_dbs_info->prev_cpu_idle_up;
@@ -382,7 +398,9 @@
 		/* if we are already at full speed then break out early */
 		if (this_dbs_info->requested_freq == policy->max)
 			return;
-
+#ifdef CONFIG_CPU_S3C6410
+		this_dbs_info->requested_freq = s3c64xx_target_frq(this_dbs_info->requested_freq, 1);
+#else
 		freq_target = (dbs_tuners_ins.freq_step * policy->max) / 100;
 
 		/* max freq cannot be less than 100. But who knows.... */
@@ -390,6 +408,8 @@
 			freq_target = 5;
 
 		this_dbs_info->requested_freq += freq_target;
+#endif /* CONFIG_CPU_S3C6410 */
+
 		if (this_dbs_info->requested_freq > policy->max)
 			this_dbs_info->requested_freq = policy->max;
 
@@ -431,6 +451,9 @@
 				|| dbs_tuners_ins.freq_step == 0)
 			return;
 
+#ifdef CONFIG_CPU_S3C6410
+		this_dbs_info->requested_freq = s3c64xx_target_frq(this_dbs_info->requested_freq, -1);
+#else
 		freq_target = (dbs_tuners_ins.freq_step * policy->max) / 100;
 
 		/* max freq cannot be less than 100. But who knows.... */
@@ -438,6 +461,7 @@
 			freq_target = 5;
 
 		this_dbs_info->requested_freq -= freq_target;
+#endif /* CONFIG_CPU_S3C6410 */
 		if (this_dbs_info->requested_freq < policy->min)
 			this_dbs_info->requested_freq = policy->min;
 
@@ -458,11 +482,19 @@
 	mutex_unlock(&dbs_mutex);
 }
 
+static int dbs_timer_count = 0;
 static inline void dbs_timer_init(void)
 {
 	init_timer_deferrable(&dbs_work.timer);
+
+	if (dbs_timer_count == 0) {
+		schedule_delayed_work(&dbs_work, 100 * HZ);
+		dbs_timer_count++;
+	}
+	else {
 	schedule_delayed_work(&dbs_work,
 			usecs_to_jiffies(dbs_tuners_ins.sampling_rate));
+	}
 	return;
 }
 
@@ -524,7 +556,7 @@
 				latency = 1;
 
 			def_sampling_rate = 10 * latency *
-					DEF_SAMPLING_RATE_LATENCY_MULTIPLIER;
+				CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER;
 
 			if (def_sampling_rate < MIN_STAT_SAMPLING_RATE)
 				def_sampling_rate = MIN_STAT_SAMPLING_RATE;
diff -Nur linux-2.6.29/drivers/cpufreq/cpufreq_ondemand.c linux-2.6.29-spica/drivers/cpufreq/cpufreq_ondemand.c
--- linux-2.6.29/drivers/cpufreq/cpufreq_ondemand.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/cpufreq/cpufreq_ondemand.c	2010-05-06 12:42:45.684270633 +0700
@@ -48,13 +48,17 @@
 #define MIN_SAMPLING_RATE_RATIO			(2)
 /* for correct statistics, we need at least 10 ticks between each measure */
 #define MIN_STAT_SAMPLING_RATE 			\
-			(MIN_SAMPLING_RATE_RATIO * jiffies_to_usecs(10))
+	(MIN_SAMPLING_RATE_RATIO * jiffies_to_usecs(CONFIG_CPU_FREQ_MIN_TICKS))
 #define MIN_SAMPLING_RATE			\
 			(def_sampling_rate / MIN_SAMPLING_RATE_RATIO)
 #define MAX_SAMPLING_RATE			(500 * def_sampling_rate)
-#define DEF_SAMPLING_RATE_LATENCY_MULTIPLIER	(1000)
 #define TRANSITION_LATENCY_LIMIT		(10 * 1000 * 1000)
 
+#ifdef CONFIG_CPU_S3C6410
+extern unsigned int s3c6410_getspeed(unsigned int);
+extern unsigned int get_min_cpufreq(void);
+#endif /* CONFIG_CPU_S3C6410 */
+
 static void do_dbs_timer(struct work_struct *work);
 
 /* Sampling types */
@@ -124,7 +128,7 @@
 		*wall = cur_wall_time;
 
 	return idle_time;
-}
+	}
 
 static inline cputime64_t get_cpu_idle_time(unsigned int cpu, cputime64_t *wall)
 {
@@ -136,6 +140,7 @@
 	return idle_time;
 }
 
+#ifndef CONFIG_CPU_S3C6410
 /*
  * Find right freq to be set now with powersave_bias on.
  * Returns the freq_hi to be used right now and will set freq_hi_jiffies,
@@ -189,6 +194,7 @@
 	dbs_info->freq_hi_jiffies = jiffies_hi;
 	return freq_hi;
 }
+#endif /* CONFIG_CPU_S3C6410 */
 
 static void ondemand_powersave_bias_init(void)
 {
@@ -432,9 +438,19 @@
 			max_load_freq = load_freq;
 	}
 
+#ifdef CONFIG_CPU_S3C6410
+	policy->cur = s3c6410_getspeed(0);
+	policy->min = get_min_cpufreq();
+#endif /* CONFIG_CPU_S3C6410 */
 	/* Check for frequency increase */
 	if (max_load_freq > dbs_tuners_ins.up_threshold * policy->cur) {
 		/* if we are already at full speed then break out early */
+#ifdef CONFIG_CPU_S3C6410
+		if (policy->cur == policy->max)
+			return;
+		__cpufreq_driver_target(policy, policy->max,
+                                CPUFREQ_RELATION_H);
+#else
 		if (!dbs_tuners_ins.powersave_bias) {
 			if (policy->cur == policy->max)
 				return;
@@ -447,6 +463,7 @@
 			__cpufreq_driver_target(policy, freq,
 				CPUFREQ_RELATION_L);
 		}
+#endif /* CONFIG_CPU_S3C6410 */
 		return;
 	}
 
@@ -468,6 +485,10 @@
 				(dbs_tuners_ins.up_threshold -
 				 dbs_tuners_ins.down_differential);
 
+#ifdef CONFIG_CPU_S3C6410
+		__cpufreq_driver_target(policy, freq_next,
+                                CPUFREQ_RELATION_L);
+#else
 		if (!dbs_tuners_ins.powersave_bias) {
 			__cpufreq_driver_target(policy, freq_next,
 					CPUFREQ_RELATION_L);
@@ -477,6 +498,7 @@
 			__cpufreq_driver_target(policy, freq,
 				CPUFREQ_RELATION_L);
 		}
+#endif /* CONFIG_CPU_S3C6410 */
 	}
 }
 
@@ -490,6 +512,7 @@
 	/* We want all CPUs to do sampling nearly on same jiffy */
 	int delay = usecs_to_jiffies(dbs_tuners_ins.sampling_rate);
 
+	if (num_online_cpus() > 1)
 	delay -= jiffies % delay;
 
 	if (lock_policy_rwsem_write(cpu) < 0)
@@ -549,6 +572,15 @@
 
 	this_dbs_info = &per_cpu(cpu_dbs_info, cpu);
 
+#ifdef CONFIG_CPU_S3C6410
+	if(!kondemand_wq){
+		kondemand_wq = create_workqueue("kondemand");
+        	if (!kondemand_wq) {
+                	printk(KERN_ERR "Creation of kondemand failed\n");
+                	return -EFAULT;
+        	}
+	}
+#endif /* CONFIG_CPU_S3C6410 */
 	switch (event) {
 	case CPUFREQ_GOV_START:
 		if ((!cpu_online(cpu)) || (!policy->cur))
@@ -592,7 +624,7 @@
 				latency = 1;
 
 			def_sampling_rate = latency *
-					DEF_SAMPLING_RATE_LATENCY_MULTIPLIER;
+				CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER;
 
 			if (def_sampling_rate < MIN_STAT_SAMPLING_RATE)
 				def_sampling_rate = MIN_STAT_SAMPLING_RATE;
diff -Nur linux-2.6.29/drivers/cpufreq/cpufreq_stats.c linux-2.6.29-spica/drivers/cpufreq/cpufreq_stats.c
--- linux-2.6.29/drivers/cpufreq/cpufreq_stats.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/cpufreq/cpufreq_stats.c	2010-05-06 12:42:45.684270633 +0700
@@ -23,10 +23,11 @@
 
 static spinlock_t cpufreq_stats_lock;
 
-#define CPUFREQ_STATDEVICE_ATTR(_name,_mode,_show) \
+#define CPUFREQ_STATDEVICE_ATTR(_name,_mode,_show, _store) \
 static struct freq_attr _attr_##_name = {\
 	.attr = {.name = __stringify(_name), .mode = _mode, }, \
 	.show = _show,\
+	.store = _store,\
 };
 
 struct cpufreq_stats {
@@ -43,6 +44,8 @@
 #endif
 };
 
+static int ignore_idle;
+
 static DEFINE_PER_CPU(struct cpufreq_stats *, cpufreq_stats_table);
 
 struct cpufreq_stats_attribute {
@@ -139,15 +142,33 @@
 		return PAGE_SIZE;
 	return len;
 }
-CPUFREQ_STATDEVICE_ATTR(trans_table,0444,show_trans_table);
+CPUFREQ_STATDEVICE_ATTR(trans_table,0444,show_trans_table, NULL);
 #endif
 
-CPUFREQ_STATDEVICE_ATTR(total_trans,0444,show_total_trans);
-CPUFREQ_STATDEVICE_ATTR(time_in_state,0444,show_time_in_state);
+static ssize_t store_ignore_idle(struct cpufreq_policy *policy, char *buf)
+{
+	int input;
+	if (sscanf(buf, "%d", &input) != 1)
+		return -EINVAL;
+
+	ignore_idle = input;
+	return 1;
+}
+
+static ssize_t show_ignore_idle(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%d\n", ignore_idle);
+}
+
+CPUFREQ_STATDEVICE_ATTR(total_trans,0444,show_total_trans, NULL);
+CPUFREQ_STATDEVICE_ATTR(time_in_state,0444,show_time_in_state, NULL);
+CPUFREQ_STATDEVICE_ATTR(ignore_idle, 0664, show_ignore_idle, store_ignore_idle);
+
 
 static struct attribute *default_attrs[] = {
 	&_attr_total_trans.attr,
 	&_attr_time_in_state.attr,
+	&_attr_ignore_idle.attr,
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	&_attr_trans_table.attr,
 #endif
@@ -308,6 +329,21 @@
 	return 0;
 }
 
+void cpufreq_exit_idle(int cpu, unsigned long ticks)
+{
+	struct cpufreq_stats *stat;
+	stat = per_cpu(cpufreq_stats_table, cpu);
+
+	/* Wait until cpu stats is initalized */
+	if (!ignore_idle || !stat || !stat->time_in_state)
+		return;
+
+	spin_lock(&cpufreq_stats_lock);
+	stat->time_in_state[stat->last_index] =
+		cputime_sub(stat->time_in_state[stat->last_index], ticks);
+	spin_unlock(&cpufreq_stats_lock);
+}
+
 static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 					       unsigned long action,
 					       void *hcpu)
diff -Nur linux-2.6.29/drivers/cpufreq/Kconfig linux-2.6.29-spica/drivers/cpufreq/Kconfig
--- linux-2.6.29/drivers/cpufreq/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/cpufreq/Kconfig	2010-05-06 12:42:45.684270633 +0700
@@ -1,5 +1,6 @@
 config CPU_FREQ
 	bool "CPU Frequency scaling"
+	select CPU_FREQ_TABLE
 	help
 	  CPU Frequency scaling allows you to change the clock speed of 
 	  CPUs on the fly. This is a nice method to save power, because 
@@ -190,4 +191,17 @@
 
 	  If in doubt, say N.
 
+config CPU_FREQ_MIN_TICKS
+	int "Ticks between governor polling interval."
+	default 10
+	help
+	  Minimum number of ticks between polling interval for governors.
+
+config CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER
+	int "Sampling rate multiplier for governors."
+	default 1000
+	help
+	  Sampling latency rate multiplied by the cpu switch latency.
+	  Affects governor polling.
+
 endif	# CPU_FREQ
diff -Nur linux-2.6.29/drivers/i2c/algos/i2c-algo-bit.c linux-2.6.29-spica/drivers/i2c/algos/i2c-algo-bit.c
--- linux-2.6.29/drivers/i2c/algos/i2c-algo-bit.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/i2c/algos/i2c-algo-bit.c	2010-05-06 12:42:45.674299703 +0700
@@ -350,6 +350,7 @@
 	int wrcount = 0;
 
 	while (count > 0) {
+		udelay(30);		//temporary added for touchscreen i2c driver
 		retval = i2c_outb(i2c_adap, *temp);
 
 		/* OK/ACK; or ignored NAK */
@@ -407,6 +408,7 @@
 	const unsigned flags = msg->flags;
 
 	while (count > 0) {
+		udelay(30); //temporary added for touchscreen i2c driver
 		inval = i2c_inb(i2c_adap);
 		if (inval >= 0) {
 			*temp = inval;
@@ -554,6 +556,7 @@
 			}
 		} else {
 			/* write bytes from buffer */
+
 			ret = sendbytes(i2c_adap, pmsg);
 			if (ret >= 1)
 				bit_dbg(2, &i2c_adap->dev, "wrote %d byte%s\n",
diff -Nur linux-2.6.29/drivers/i2c/busses/i2c-s3c.c linux-2.6.29-spica/drivers/i2c/busses/i2c-s3c.c
--- linux-2.6.29/drivers/i2c/busses/i2c-s3c.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/i2c/busses/i2c-s3c.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,1066 @@
+/* linux/drivers/i2c/busses/i2c-s3c.c
+ *
+ * Copyright (C) 2004,2005 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C I2C Controller
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-id.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include <plat/regs-iic.h>
+#include <plat/iic.h>
+
+/* i2c controller state */
+
+enum s3c_i2c_state {
+	STATE_IDLE,
+	STATE_START,
+	STATE_READ,
+	STATE_WRITE,
+	STATE_STOP
+};
+
+struct s3c_i2c {
+	spinlock_t		lock;
+	wait_queue_head_t	wait;
+	unsigned int		suspended:1;
+
+	struct i2c_msg		*msg;
+	unsigned int		msg_num;
+	unsigned int		msg_idx;
+	unsigned int		msg_ptr;
+
+	unsigned int		tx_setup;
+	unsigned int		irq;
+
+	enum s3c_i2c_state	state;
+	unsigned long		clkrate;
+
+	void __iomem		*regs;
+	struct clk		*clk;
+	struct device		*dev;
+	struct resource		*ioarea;
+	struct i2c_adapter	adap;
+
+#ifdef CONFIG_CPU_FREQ
+	struct notifier_block	freq_transition;
+#endif
+};
+
+/* default platform data removed, dev should always carry data. */
+
+/* s3c_i2c_is2440()
+ *
+ * return true is this is an s3c2440
+*/
+
+static inline int s3c_i2c_is2440(struct s3c_i2c *i2c)
+{
+	struct platform_device *pdev = to_platform_device(i2c->dev);
+
+	return !strcmp(pdev->name, "s3c2440-i2c");
+}
+
+/* s3c_i2c_master_complete
+ *
+ * complete the message and wake up the caller, using the given return code,
+ * or zero to mean ok.
+*/
+
+static inline void s3c_i2c_master_complete(struct s3c_i2c *i2c, int ret)
+{
+	dev_dbg(i2c->dev, "master_complete %d\n", ret);
+
+	i2c->msg_ptr = 0;
+	i2c->msg = NULL;
+	i2c->msg_idx++;
+	i2c->msg_num = 0;
+	if (ret)
+		i2c->msg_idx = ret;
+
+	wake_up(&i2c->wait);
+}
+
+static inline void s3c_i2c_disable_ack(struct s3c_i2c *i2c)
+{
+	unsigned long tmp;
+
+	tmp = readl(i2c->regs + S3C_IICCON);
+	writel(tmp & ~S3C_IICCON_ACKEN, i2c->regs + S3C_IICCON);
+}
+
+static inline void s3c_i2c_enable_ack(struct s3c_i2c *i2c)
+{
+	unsigned long tmp;
+
+	tmp = readl(i2c->regs + S3C_IICCON);
+	writel(tmp | S3C_IICCON_ACKEN, i2c->regs + S3C_IICCON);
+}
+
+/* irq enable/disable functions */
+
+static inline void s3c_i2c_disable_irq(struct s3c_i2c *i2c)
+{
+	unsigned long tmp;
+
+	tmp = readl(i2c->regs + S3C_IICCON);
+
+/* S3c2442 datasheet
+ *
+ * If the IICCON[5]=0, IICCON[4] does not operate correctly.
+ * So, It is recommended that you should set IICCON[5]=1,
+ * although you does not use the IIC interrupt.
+ */
+
+	writel(tmp & ~S3C_IICCON_IRQEN, i2c->regs + S3C_IICCON);
+}
+
+static inline void s3c_i2c_enable_irq(struct s3c_i2c *i2c)
+{
+	unsigned long tmp;
+
+	tmp = readl(i2c->regs + S3C_IICCON);
+	writel(tmp | S3C_IICCON_IRQEN, i2c->regs + S3C_IICCON);
+}
+
+
+/* s3c_i2c_message_start
+ *
+ * put the start of a message onto the bus
+*/
+
+static void s3c_i2c_message_start(struct s3c_i2c *i2c,
+				      struct i2c_msg *msg)
+{
+	unsigned int addr = (msg->addr & 0x7f) << 1;
+	unsigned long stat;
+	unsigned long iiccon;
+
+	stat = 0;
+	stat |=  S3C_IICSTAT_TXRXEN;
+
+	if (msg->flags & I2C_M_RD) {
+		stat |= S3C_IICSTAT_MASTER_RX;
+		addr |= 1;
+	} else
+		stat |= S3C_IICSTAT_MASTER_TX;
+
+	if (msg->flags & I2C_M_REV_DIR_ADDR)
+		addr ^= 1;
+
+	/* todo - check for wether ack wanted or not */
+	s3c_i2c_enable_ack(i2c);
+
+	iiccon = readl(i2c->regs + S3C_IICCON);
+	writel(stat, i2c->regs + S3C_IICSTAT);
+
+	dev_dbg(i2c->dev, "START: %08lx to IICSTAT, %02x to DS\n", stat, addr);
+	writeb(addr, i2c->regs + S3C_IICDS);
+
+	/* delay here to ensure the data byte has gotten onto the bus
+	 * before the transaction is started */
+
+	ndelay(i2c->tx_setup);
+
+	dev_dbg(i2c->dev, "iiccon, %08lx\n", iiccon);
+	writel(iiccon, i2c->regs + S3C_IICCON);
+
+	stat |= S3C_IICSTAT_START;
+	writel(stat, i2c->regs + S3C_IICSTAT);
+}
+
+static inline void s3c_i2c_stop(struct s3c_i2c *i2c, int ret)
+{
+	unsigned long iicstat = readl(i2c->regs + S3C_IICSTAT);
+
+	dev_dbg(i2c->dev, "STOP\n");
+
+	/* stop the transfer */
+	iicstat &= ~S3C_IICSTAT_START;
+	writel(iicstat, i2c->regs + S3C_IICSTAT);
+
+	i2c->state = STATE_STOP;
+
+	s3c_i2c_master_complete(i2c, ret);
+	s3c_i2c_disable_irq(i2c);
+}
+
+/* helper functions to determine the current state in the set of
+ * messages we are sending */
+
+/* is_lastmsg()
+ *
+ * returns TRUE if the current message is the last in the set
+*/
+
+static inline int is_lastmsg(struct s3c_i2c *i2c)
+{
+	return i2c->msg_idx >= (i2c->msg_num - 1);
+}
+
+/* is_msglast
+ *
+ * returns TRUE if we this is the last byte in the current message
+*/
+
+static inline int is_msglast(struct s3c_i2c *i2c)
+{
+	return i2c->msg_ptr == i2c->msg->len-1;
+}
+
+/* is_msgend
+ *
+ * returns TRUE if we reached the end of the current message
+*/
+
+static inline int is_msgend(struct s3c_i2c *i2c)
+{
+	return i2c->msg_ptr >= i2c->msg->len;
+}
+
+/* i2s_s3c_irq_nextbyte
+ *
+ * process an interrupt and work out what to do
+ */
+
+static int i2s_s3c_irq_nextbyte(struct s3c_i2c *i2c, unsigned long iicstat)
+{
+	unsigned long tmp;
+	unsigned char byte;
+	int ret = 0;
+
+	switch (i2c->state) {
+
+	case STATE_IDLE:
+		dev_err(i2c->dev, "%s: called in STATE_IDLE\n", __func__);
+		goto out;
+		break;
+
+	case STATE_STOP:
+		dev_err(i2c->dev, "%s: called in STATE_STOP\n", __func__);
+		s3c_i2c_disable_irq(i2c);
+		goto out_ack;
+
+	case STATE_START:
+		/* last thing we did was send a start condition on the
+		 * bus, or started a new i2c message
+		 */
+
+		if (iicstat & S3C_IICSTAT_LASTBIT &&
+		    !(i2c->msg->flags & I2C_M_IGNORE_NAK)) {
+			/* ack was not received... */
+
+			dev_dbg(i2c->dev, "ack was not received\n");
+			s3c_i2c_stop(i2c, -ENXIO);
+			goto out_ack;
+		}
+
+		if (i2c->msg->flags & I2C_M_RD)
+			i2c->state = STATE_READ;
+		else
+			i2c->state = STATE_WRITE;
+
+		/* terminate the transfer if there is nothing to do
+		 * as this is used by the i2c probe to find devices. */
+
+		if (is_lastmsg(i2c) && i2c->msg->len == 0) {
+			s3c_i2c_stop(i2c, 0);
+			goto out_ack;
+		}
+
+		if (i2c->state == STATE_READ)
+			goto prepare_read;
+
+		/* fall through to the write state, as we will need to
+		 * send a byte as well */
+
+	case STATE_WRITE:
+		/* we are writing data to the device... check for the
+		 * end of the message, and if so, work out what to do
+		 */
+
+		if (!(i2c->msg->flags & I2C_M_IGNORE_NAK)) {
+			if (iicstat & S3C_IICSTAT_LASTBIT) {
+				dev_dbg(i2c->dev, "WRITE: No Ack\n");
+
+				s3c_i2c_stop(i2c, -ECONNREFUSED);
+				goto out_ack;
+			}
+		}
+
+ retry_write:
+
+		if (!is_msgend(i2c)) {
+			byte = i2c->msg->buf[i2c->msg_ptr++];
+			writeb(byte, i2c->regs + S3C_IICDS);
+
+			/* delay after writing the byte to allow the
+			 * data setup time on the bus, as writing the
+			 * data to the register causes the first bit
+			 * to appear on SDA, and SCL will change as
+			 * soon as the interrupt is acknowledged */
+
+			ndelay(i2c->tx_setup);
+
+		} else if (!is_lastmsg(i2c)) {
+			/* we need to go to the next i2c message */
+
+			dev_dbg(i2c->dev, "WRITE: Next Message\n");
+
+			i2c->msg_ptr = 0;
+			i2c->msg_idx++;
+			i2c->msg++;
+
+			/* check to see if we need to do another message */
+			if (i2c->msg->flags & I2C_M_NOSTART) {
+
+				if (i2c->msg->flags & I2C_M_RD) {
+					/* cannot do this, the controller
+					 * forces us to send a new START
+					 * when we change direction */
+
+					s3c_i2c_stop(i2c, -EINVAL);
+				}
+
+				goto retry_write;
+			} else {
+				/* send the new start */
+				s3c_i2c_message_start(i2c, i2c->msg);
+				i2c->state = STATE_START;
+			}
+
+		} else {
+			/* send stop */
+
+			s3c_i2c_stop(i2c, 0);
+		}
+		break;
+
+	case STATE_READ:
+		/* we have a byte of data in the data register, do
+		 * something with it, and then work out wether we are
+		 * going to do any more read/write
+		 */
+
+		byte = readb(i2c->regs + S3C_IICDS);
+		i2c->msg->buf[i2c->msg_ptr++] = byte;
+
+ prepare_read:
+		if (is_msglast(i2c)) {
+			/* last byte of buffer */
+
+			if (is_lastmsg(i2c))
+				s3c_i2c_disable_ack(i2c);
+
+		} else if (is_msgend(i2c)) {
+			/* ok, we've read the entire buffer, see if there
+			 * is anything else we need to do */
+
+			if (is_lastmsg(i2c)) {
+				/* last message, send stop and complete */
+				dev_dbg(i2c->dev, "READ: Send Stop\n");
+
+				s3c_i2c_stop(i2c, 0);
+			} else {
+				/* go to the next transfer */
+				dev_dbg(i2c->dev, "READ: Next Transfer\n");
+
+				i2c->msg_ptr = 0;
+				i2c->msg_idx++;
+				i2c->msg++;
+			}
+		}
+
+		break;
+	}
+
+	/* acknowlegde the IRQ and get back on with the work */
+
+ out_ack:
+	tmp = readl(i2c->regs + S3C_IICCON);
+	tmp &= ~S3C_IICCON_IRQPEND;
+	writel(tmp, i2c->regs + S3C_IICCON);
+ out:
+	return ret;
+}
+
+/* s3c_i2c_irq
+ *
+ * top level IRQ servicing routine
+*/
+
+static irqreturn_t s3c_i2c_irq(int irqno, void *dev_id)
+{
+	struct s3c_i2c *i2c = dev_id;
+	unsigned long status;
+	unsigned long tmp;
+
+	status = readl(i2c->regs + S3C_IICSTAT);
+
+	if (status & S3C_IICSTAT_ARBITR) {
+		/* deal with arbitration loss */
+		dev_err(i2c->dev, "deal with arbitration loss\n");
+	}
+
+	if (i2c->state == STATE_IDLE) {
+		dev_dbg(i2c->dev, "IRQ: error i2c->state == IDLE\n");
+
+		tmp = readl(i2c->regs + S3C_IICCON);
+		tmp &= ~S3C_IICCON_IRQPEND;
+		writel(tmp, i2c->regs +  S3C_IICCON);
+		goto out;
+	}
+
+	/* pretty much this leaves us with the fact that we've
+	 * transmitted or received whatever byte we last sent */
+
+	i2s_s3c_irq_nextbyte(i2c, status);
+
+ out:
+	return IRQ_HANDLED;
+}
+
+
+/* s3c_i2c_set_master
+ *
+ * get the i2c bus for a master transaction
+*/
+
+static int s3c_i2c_set_master(struct s3c_i2c *i2c)
+{
+	unsigned long iicstat;
+	int timeout = 400;
+
+	while (timeout-- > 0) {
+		iicstat = readl(i2c->regs + S3C_IICSTAT);
+
+		if (!(iicstat & S3C_IICSTAT_BUSBUSY))
+			return 0;
+
+		msleep(1);
+	}
+
+#if defined(CONFIG_MACH_SPICA)
+	iicstat = readl(i2c->regs + S3C_IICSTAT);
+    iicstat &= ~S3C_IICSTAT_BUSBUSY;
+    writel(iicstat, i2c->regs + S3C_IICSTAT);
+    printk("%s : stop condition \n", __func__);
+#endif
+
+	return -ETIMEDOUT;
+}
+
+/* s3c_i2c_doxfer
+ *
+ * this starts an i2c transfer
+*/
+
+static int s3c_i2c_doxfer(struct s3c_i2c *i2c,
+			      struct i2c_msg *msgs, int num)
+{
+#if !(defined(CONFIG_MACH_CYGNUS) || defined(CONFIG_MACH_SATURN)|| defined(CONFIG_MACH_SPICA))
+	struct s3c_platform_i2c *pdata = i2c->dev->platform_data;
+#endif
+	unsigned long timeout;
+	int ret;
+
+#if defined(CONFIG_MACH_SPICA)
+	int iicstat;
+#endif
+
+	if (i2c->suspended) {
+		dev_err(i2c->dev, "i2c master is suspeded\n");
+		return -EIO;
+	}
+
+	if (i2c->suspended) {
+		dev_err(i2c->dev,
+		    "Hey I am still asleep (suspended: %d), retry later\n",
+		    i2c->suspended);
+		dump_stack();
+		ret = -EAGAIN;
+		goto out;
+	}
+
+	ret = s3c_i2c_set_master(i2c);
+	if (ret != 0) {
+		dev_err(i2c->dev, "cannot get bus (error %d)\n", ret);
+		
+		/* force to write stop control bit */
+		s3c_i2c_stop(i2c, -ENXIO);
+
+#if defined(CONFIG_MACH_SPICA)
+		iicstat = readl(i2c->regs + S3C_IICSTAT);
+        if ((iicstat & S3C_IICSTAT_BUSBUSY)) {
+            iicstat &= ~(S3C_IICSTAT_TXRXEN | S3C_IICSTAT_BUSBUSY);
+            writel(iicstat, i2c->regs + S3C_IICSTAT);
+            printk("IICSTAT reg : 0x%x\n", readl(i2c->regs + S3C_IICSTAT));
+        }
+#endif
+
+		ret = -EAGAIN;
+		goto out;
+	}
+
+	spin_lock_irq(&i2c->lock);
+
+	i2c->msg     = msgs;
+	i2c->msg_num = num;
+	i2c->msg_ptr = 0;
+	i2c->msg_idx = 0;
+	i2c->state   = STATE_START;
+
+	s3c_i2c_enable_irq(i2c);
+	s3c_i2c_message_start(i2c, msgs);
+	spin_unlock_irq(&i2c->lock);
+
+	timeout = wait_event_timeout(i2c->wait, i2c->msg_num == 0, HZ * 5);
+
+	ret = i2c->msg_idx;
+
+	/* having these next two as dev_err() makes life very
+	 * noisy when doing an i2cdetect */
+
+	if (timeout == 0)
+		dev_dbg(i2c->dev, "timeout\n");
+	else if (ret != num)
+		dev_dbg(i2c->dev, "incomplete xfer (%d)\n", ret);
+
+	/* ensure the stop has been through the bus */
+#if !(defined(CONFIG_MACH_CYGNUS) || defined(CONFIG_MACH_SATURN)|| defined(CONFIG_MACH_SPICA))
+	if (pdata->bus_num == 0)
+		msleep(1);
+#endif
+ out:
+	return ret;
+}
+
+/* s3c_i2c_xfer
+ *
+ * first port of call from the i2c bus code when an message needs
+ * transferring across the i2c bus.
+*/
+
+static int s3c_i2c_xfer(struct i2c_adapter *adap,
+			struct i2c_msg *msgs, int num)
+{
+	struct s3c_i2c *i2c = (struct s3c_i2c *)adap->algo_data;
+	int retry;
+	int ret;
+
+	for (retry = 0; retry < adap->retries; retry++) {
+
+		ret = s3c_i2c_doxfer(i2c, msgs, num);
+
+		if (ret != -EAGAIN)
+			return ret;
+
+		dev_dbg(i2c->dev, "Retrying transmission (%d)\n", retry);
+
+		udelay(100);
+	}
+
+	return -EREMOTEIO;
+}
+
+/* declare our i2c functionality */
+static u32 s3c_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;
+}
+
+/* i2c bus registration info */
+
+static const struct i2c_algorithm s3c_i2c_algorithm = {
+	.master_xfer		= s3c_i2c_xfer,
+	.functionality		= s3c_i2c_func,
+};
+
+/* s3c_i2c_calcdivisor
+ *
+ * return the divisor settings for a given frequency
+*/
+
+static int s3c_i2c_calcdivisor(unsigned long clkin, unsigned int wanted,
+				   unsigned int *div1, unsigned int *divs)
+{
+	unsigned int calc_divs = clkin / wanted;
+	unsigned int calc_div1;
+
+	if (calc_divs > (16*16))
+		calc_div1 = 512;
+	else
+		calc_div1 = 16;
+
+	calc_divs += calc_div1-1;
+	calc_divs /= calc_div1;
+
+	if (calc_divs == 0)
+		calc_divs = 1;
+	if (calc_divs > 17)
+		calc_divs = 17;
+
+	*divs = calc_divs;
+	*div1 = calc_div1;
+
+	return clkin / (calc_divs * calc_div1);
+}
+
+/* freq_acceptable
+ *
+ * test wether a frequency is within the acceptable range of error
+*/
+
+static inline int freq_acceptable(unsigned int freq, unsigned int wanted)
+{
+	int diff = freq - wanted;
+
+	return diff >= -2 && diff <= 2;
+}
+
+/* s3c_i2c_clockrate
+ *
+ * work out a divisor for the user requested frequency setting,
+ * either by the requested frequency, or scanning the acceptable
+ * range of frequencies until something is found
+*/
+
+static int s3c_i2c_clockrate(struct s3c_i2c *i2c, unsigned int *got)
+{
+	struct s3c_platform_i2c *pdata = i2c->dev->platform_data;
+	unsigned long clkin = clk_get_rate(i2c->clk);
+	unsigned int divs, div1;
+	u32 iiccon;
+	int freq;
+	int start, end;
+
+	i2c->clkrate = clkin;
+	clkin /= 1000;		/* clkin now in KHz */
+
+	dev_dbg(i2c->dev, "pdata %p, freq %lu %lu..%lu\n",
+		 pdata, pdata->bus_freq, pdata->min_freq, pdata->max_freq);
+
+	if (pdata->bus_freq != 0) {
+		freq = s3c_i2c_calcdivisor(clkin, pdata->bus_freq/1000,
+					       &div1, &divs);
+		if (freq_acceptable(freq, pdata->bus_freq/1000))
+			goto found;
+	}
+
+	/* ok, we may have to search for something suitable... */
+
+	start = (pdata->max_freq == 0) ? pdata->bus_freq : pdata->max_freq;
+	end = pdata->min_freq;
+
+	start /= 1000;
+	end /= 1000;
+
+	/* search loop... */
+
+	for (; start > end; start--) {
+		freq = s3c_i2c_calcdivisor(clkin, start, &div1, &divs);
+		if (freq_acceptable(freq, start))
+			goto found;
+	}
+
+	/* cannot find frequency spec */
+
+	return -EINVAL;
+
+ found:
+	*got = freq;
+
+	iiccon = readl(i2c->regs + S3C_IICCON);
+	iiccon &= ~(S3C_IICCON_SCALEMASK | S3C_IICCON_TXDIV_512);
+	iiccon |= (divs-1);
+
+	if (div1 == 512)
+		iiccon |= S3C_IICCON_TXDIV_512;
+
+	writel(iiccon, i2c->regs + S3C_IICCON);
+
+	return 0;
+}
+
+#ifdef CONFIG_CPU_FREQ
+
+#define freq_to_i2c(_n) container_of(_n, struct s3c_i2c, freq_transition)
+
+static int s3c_i2c_cpufreq_transition(struct notifier_block *nb,
+					  unsigned long val, void *data)
+{
+	struct s3c_i2c *i2c = freq_to_i2c(nb);
+	unsigned long flags;
+	unsigned int got;
+	int delta_f;
+	int ret;
+
+	delta_f = clk_get_rate(i2c->clk) - i2c->clkrate;
+
+	/* if we're post-change and the input clock has slowed down
+	 * or at pre-change and the clock is about to speed up, then
+	 * adjust our clock rate. <0 is slow, >0 speedup.
+	 */
+
+	if ((val == CPUFREQ_POSTCHANGE && delta_f < 0) ||
+	    (val == CPUFREQ_PRECHANGE && delta_f > 0)) {
+		spin_lock_irqsave(&i2c->lock, flags);
+		ret = s3c_i2c_clockrate(i2c, &got);
+		spin_unlock_irqrestore(&i2c->lock, flags);
+
+		if (ret < 0)
+			dev_err(i2c->dev, "cannot find frequency\n");
+		else
+			dev_info(i2c->dev, "setting freq %d\n", got);
+	}
+
+	return 0;
+}
+
+static inline int s3c_i2c_register_cpufreq(struct s3c_i2c *i2c)
+{
+	i2c->freq_transition.notifier_call = s3c_i2c_cpufreq_transition;
+
+	return cpufreq_register_notifier(&i2c->freq_transition,
+					 CPUFREQ_TRANSITION_NOTIFIER);
+}
+
+static inline void s3c_i2c_deregister_cpufreq(struct s3c_i2c *i2c)
+{
+	cpufreq_unregister_notifier(&i2c->freq_transition,
+				    CPUFREQ_TRANSITION_NOTIFIER);
+}
+
+#else
+static inline int s3c_i2c_register_cpufreq(struct s3c_i2c *i2c)
+{
+	return 0;
+}
+
+static inline void s3c_i2c_deregister_cpufreq(struct s3c_i2c *i2c)
+{
+}
+#endif
+
+/* s3c_i2c_init
+ *
+ * initialise the controller, set the IO lines and frequency
+*/
+
+static int s3c_i2c_init(struct s3c_i2c *i2c)
+{
+	unsigned long iicon = S3C_IICCON_IRQEN | S3C_IICCON_ACKEN;
+	struct s3c_platform_i2c *pdata;
+	unsigned int freq;
+
+	/* get the plafrom data */
+
+	pdata = i2c->dev->platform_data;
+
+	/* inititalise the gpio */
+
+	if (pdata->cfg_gpio)
+		pdata->cfg_gpio(to_platform_device(i2c->dev));
+
+	/* write slave address */
+
+	writeb(pdata->slave_addr, i2c->regs + S3C_IICADD);
+
+	dev_info(i2c->dev, "slave address 0x%02x\n", pdata->slave_addr);
+
+	writel(iicon, i2c->regs + S3C_IICCON);
+
+	/* we need to work out the divisors for the clock... */
+
+	if (s3c_i2c_clockrate(i2c, &freq) != 0) {
+		writel(0, i2c->regs + S3C_IICCON);
+		dev_err(i2c->dev, "cannot meet bus frequency required\n");
+		return -EINVAL;
+	}
+
+	/* todo - check that the i2c lines aren't being dragged anywhere */
+
+	dev_info(i2c->dev, "bus frequency set to %d KHz\n", freq);
+	dev_dbg(i2c->dev, "S3C_IICCON=0x%02lx\n", iicon);
+
+	/* check for s3c i2c controller  */
+
+	if (s3c_i2c_is2440(i2c)) {
+		dev_dbg(i2c->dev, "S3C_IICLC=%08x\n", pdata->sda_delay);
+
+		writel(pdata->sda_delay, i2c->regs + S3C_IICLC);
+	}
+
+	return 0;
+}
+
+/* s3c_i2c_probe
+ *
+ * called by the bus driver when a suitable device is found
+*/
+
+static int s3c_i2c_probe(struct platform_device *pdev)
+{
+	struct s3c_i2c *i2c;
+	struct s3c_platform_i2c *pdata;
+	struct resource *res;
+	int ret;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "no platform data\n");
+		return -EINVAL;
+	}
+
+	i2c = kzalloc(sizeof(struct s3c_i2c), GFP_KERNEL);
+	if (!i2c) {
+		dev_err(&pdev->dev, "no memory for state\n");
+		return -ENOMEM;
+	}
+
+	strlcpy(i2c->adap.name, "s3c-i2c", sizeof(i2c->adap.name));
+	i2c->adap.owner   = THIS_MODULE;
+	i2c->adap.algo    = &s3c_i2c_algorithm;
+	i2c->adap.retries = 2;
+	i2c->adap.class   = I2C_CLASS_HWMON | I2C_CLASS_SPD;
+	i2c->tx_setup     = 50;
+
+	spin_lock_init(&i2c->lock);
+	init_waitqueue_head(&i2c->wait);
+
+	/* find the clock and enable it */
+
+	i2c->dev = &pdev->dev;
+	i2c->clk = clk_get(&pdev->dev, "i2c");
+	if (IS_ERR(i2c->clk)) {
+		dev_err(&pdev->dev, "cannot get clock\n");
+		ret = -ENOENT;
+		goto err_noclk;
+	}
+
+	dev_dbg(&pdev->dev, "clock source %p\n", i2c->clk);
+
+	clk_enable(i2c->clk);
+
+	/* map the registers */
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "cannot find IO resource\n");
+		ret = -ENOENT;
+		goto err_clk;
+	}
+
+	i2c->ioarea = request_mem_region(res->start, (res->end-res->start)+1,
+					 pdev->name);
+
+	if (i2c->ioarea == NULL) {
+		dev_err(&pdev->dev, "cannot request IO\n");
+		ret = -ENXIO;
+		goto err_clk;
+	}
+
+	i2c->regs = ioremap(res->start, (res->end-res->start)+1);
+
+	if (i2c->regs == NULL) {
+		dev_err(&pdev->dev, "cannot map IO\n");
+		ret = -ENXIO;
+		goto err_ioarea;
+	}
+
+	dev_dbg(&pdev->dev, "registers %p (%p, %p)\n",
+		i2c->regs, i2c->ioarea, res);
+
+	/* setup info block for the i2c core */
+
+	i2c->adap.algo_data = i2c;
+	i2c->adap.dev.parent = &pdev->dev;
+
+	/* initialise the i2c controller */
+
+	ret = s3c_i2c_init(i2c);
+	if (ret != 0)
+		goto err_iomap;
+
+	/* find the IRQ for this unit (note, this relies on the init call to
+	 * ensure no current IRQs pending
+	 */
+
+	i2c->irq = ret = platform_get_irq(pdev, 0);
+	if (ret <= 0) {
+		dev_err(&pdev->dev, "cannot find IRQ\n");
+		goto err_iomap;
+	}
+
+	ret = request_irq(i2c->irq, s3c_i2c_irq, IRQF_DISABLED,
+			  dev_name(&pdev->dev), i2c);
+
+	if (ret != 0) {
+		dev_err(&pdev->dev, "cannot claim IRQ %d\n", i2c->irq);
+		goto err_iomap;
+	}
+
+	ret = s3c_i2c_register_cpufreq(i2c);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register cpufreq notifier\n");
+		goto err_irq;
+	}
+
+	/* Note, previous versions of the driver used i2c_add_adapter()
+	 * to add the bus at any number. We now pass the bus number via
+	 * the platform data, so if unset it will now default to always
+	 * being bus 0.
+	 */
+
+	i2c->adap.nr = pdata->bus_num;
+
+	ret = i2c_add_numbered_adapter(&i2c->adap);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to add bus to i2c core\n");
+		goto err_cpufreq;
+	}
+
+	platform_set_drvdata(pdev, i2c);
+
+	dev_info(&pdev->dev, "%s: S3C I2C adapter\n", dev_name(&i2c->adap.dev));
+	return 0;
+
+ err_cpufreq:
+	s3c_i2c_deregister_cpufreq(i2c);
+
+ err_irq:
+	free_irq(i2c->irq, i2c);
+
+ err_iomap:
+	iounmap(i2c->regs);
+
+ err_ioarea:
+	release_resource(i2c->ioarea);
+	kfree(i2c->ioarea);
+
+ err_clk:
+	clk_disable(i2c->clk);
+	clk_put(i2c->clk);
+
+ err_noclk:
+	kfree(i2c);
+	return ret;
+}
+
+/* s3c_i2c_remove
+ *
+ * called when device is removed from the bus
+*/
+
+static int s3c_i2c_remove(struct platform_device *pdev)
+{
+	struct s3c_i2c *i2c = platform_get_drvdata(pdev);
+
+	s3c_i2c_deregister_cpufreq(i2c);
+
+	i2c_del_adapter(&i2c->adap);
+	free_irq(i2c->irq, i2c);
+
+	clk_disable(i2c->clk);
+	clk_put(i2c->clk);
+
+	iounmap(i2c->regs);
+
+	release_resource(i2c->ioarea);
+	kfree(i2c->ioarea);
+	kfree(i2c);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int s3c_i2c_suspend_late(struct platform_device *dev,
+				    pm_message_t msg)
+{
+	struct s3c_i2c *i2c = platform_get_drvdata(dev);
+	i2c->suspended = 1;
+	return 0;
+}
+
+static int s3c_i2c_resume(struct platform_device *dev)
+{
+	struct s3c_i2c *i2c = platform_get_drvdata(dev);
+
+	i2c->suspended = 0;
+	s3c_i2c_init(i2c);
+
+	return 0;
+}
+
+#else
+#define s3c_i2c_suspend_late NULL
+#define s3c_i2c_resume NULL
+#endif
+
+/* device driver for platform bus bits */
+
+static struct platform_driver s3c_i2c_driver = {
+	.probe		= s3c_i2c_probe,
+	.remove		= s3c_i2c_remove,
+	.suspend_late	= s3c_i2c_suspend_late,
+	.resume		= s3c_i2c_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c-i2c",
+	},
+};
+
+static int __init i2c_adap_s3c_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&s3c_i2c_driver);
+
+	return ret;
+}
+
+static void __exit i2c_adap_s3c_exit(void)
+{
+	platform_driver_unregister(&s3c_i2c_driver);
+}
+
+module_init(i2c_adap_s3c_init);
+module_exit(i2c_adap_s3c_exit);
+
+MODULE_DESCRIPTION("S3C I2C Bus driver");
+MODULE_AUTHOR("Ben Dooks, <ben@simtec.co.uk>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:s3c-i2c");
+
diff -Nur linux-2.6.29/drivers/i2c/busses/Kconfig linux-2.6.29-spica/drivers/i2c/busses/Kconfig
--- linux-2.6.29/drivers/i2c/busses/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/i2c/busses/Kconfig	2010-05-06 12:42:45.674299703 +0700
@@ -454,12 +454,13 @@
 	  is necessary for systems where the PXA may be a target on the
 	  I2C bus.
 
-config I2C_S3C2410
-	tristate "S3C2410 I2C Driver"
-	depends on ARCH_S3C2410
+config I2C_S3C
+	tristate "Samsung SoC I2C Driver (S3C24XX and S3C64XX series)"
+	depends on ARCH_S3C2410 || ARCH_S3C64XX
 	help
 	  Say Y here to include support for I2C controller in the
-	  Samsung S3C2410 based System-on-Chip devices.
+	  Samsung S3C based System-on-Chip devices such as the S3C2410,
+	  S3C2440, S3C2442, S3C2443 and S3C6410.
 
 config I2C_SH7760
 	tristate "Renesas SH7760 I2C Controller"
diff -Nur linux-2.6.29/drivers/i2c/busses/Makefile linux-2.6.29-spica/drivers/i2c/busses/Makefile
--- linux-2.6.29/drivers/i2c/busses/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/i2c/busses/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -42,7 +42,7 @@
 obj-$(CONFIG_I2C_PASEMI)	+= i2c-pasemi.o
 obj-$(CONFIG_I2C_PNX)		+= i2c-pnx.o
 obj-$(CONFIG_I2C_PXA)		+= i2c-pxa.o
-obj-$(CONFIG_I2C_S3C2410)	+= i2c-s3c2410.o
+obj-$(CONFIG_I2C_S3C)		+= i2c-s3c.o
 obj-$(CONFIG_I2C_SH7760)	+= i2c-sh7760.o
 obj-$(CONFIG_I2C_SH_MOBILE)	+= i2c-sh_mobile.o
 obj-$(CONFIG_I2C_SIMTEC)	+= i2c-simtec.o
diff -Nur linux-2.6.29/drivers/i2c/chips/akm8976.c linux-2.6.29-spica/drivers/i2c/chips/akm8976.c
--- linux-2.6.29/drivers/i2c/chips/akm8976.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/i2c/chips/akm8976.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,1133 @@
+/* drivers/i2c/chips/akm8976.c - akm8976 compass driver
+ *
+ * Copyright (C) 2007-2008 HTC Corporation.
+ * Author: Hou-Kun Chen <houkun.chen@gmail.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/irq.h>
+#include <linux/miscdevice.h>
+#include <linux/gpio.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/freezer.h>
+#include <linux/akm8976.h>
+
+#define DEBUG 0
+#define MAX_FAILURE_COUNT 10
+
+static struct i2c_client *this_client;
+
+struct akm8976_data {
+	struct input_dev *input_dev;
+	struct work_struct work;
+};
+
+/* Addresses to scan -- protected by sense_data_mutex */
+static char sense_data[RBUFF_SIZE + 1];
+static struct mutex sense_data_mutex;
+
+static DECLARE_WAIT_QUEUE_HEAD(data_ready_wq);
+static DECLARE_WAIT_QUEUE_HEAD(open_wq);
+
+static char cspec_num;
+static atomic_t cspec_frq;
+
+static atomic_t data_ready;
+static atomic_t open_count;
+static atomic_t open_flag;
+static atomic_t reserve_open_flag;
+
+static atomic_t m_flag;
+static atomic_t a_flag;
+static atomic_t t_flag;
+static atomic_t mv_flag;
+
+static int pffd_mode = 0;
+static int failure_count = 0;
+
+static short akmd_delay = 0;
+
+static atomic_t suspend_flag = ATOMIC_INIT(0);
+
+static struct akm8976_platform_data *pdata;
+static int revision = -1;
+/* AKM HW info */
+static ssize_t gsensor_vendor_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	sprintf(buf, "AK8976A_%#x\n", revision);
+	ret = strlen(buf) + 1;
+
+	return ret;
+}
+
+static DEVICE_ATTR(vendor, 0444, gsensor_vendor_show, NULL);
+
+static struct kobject *android_gsensor_kobj;
+
+static int gsensor_sysfs_init(void)
+{
+	int ret ;
+
+	android_gsensor_kobj = kobject_create_and_add("android_gsensor", NULL);
+	if (android_gsensor_kobj == NULL) {
+		printk(KERN_ERR
+		       "AKM8976 gsensor_sysfs_init:"\
+		       "subsystem_register failed\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	ret = sysfs_create_file(android_gsensor_kobj, &dev_attr_vendor.attr);
+	if (ret) {
+		printk(KERN_ERR
+		       "AKM8976 gsensor_sysfs_init:"\
+		       "sysfs_create_group failed\n");
+		goto err4;
+	}
+
+	return 0 ;
+err4:
+	kobject_del(android_gsensor_kobj);
+err:
+	return ret ;
+}
+
+/* following are the sysfs callback functions */
+
+#define config_ctrl_reg(name,address) \
+static ssize_t name##_show(struct device *dev, struct device_attribute *attr, \
+			   char *buf) \
+{ \
+	struct i2c_client *client = to_i2c_client(dev); \
+        return sprintf(buf, "%u\n", i2c_smbus_read_byte_data(client,address)); \
+} \
+static ssize_t name##_store(struct device *dev, struct device_attribute *attr, \
+			    const char *buf,size_t count) \
+{ \
+	struct i2c_client *client = to_i2c_client(dev); \
+	unsigned long val = simple_strtoul(buf, NULL, 10); \
+	if (val > 0xff) \
+		return -EINVAL; \
+	i2c_smbus_write_byte_data(client,address, val); \
+        return count; \
+} \
+static DEVICE_ATTR(name, S_IWUSR | S_IRUGO, name##_show, name##_store)
+
+config_ctrl_reg(ms1, AKECS_REG_MS1);
+config_ctrl_reg(ms2, AKECS_REG_MS2);
+config_ctrl_reg(ms3, AKECS_REG_MS3);
+
+static int AKI2C_RxData(char *rxData, int length)
+{
+	struct i2c_msg msgs[] = {
+		{
+		 .addr = this_client->addr,
+		 .flags = 0,
+		 .len = 1,
+		 .buf = rxData,
+		 },
+		{
+		 .addr = this_client->addr,
+		 .flags = I2C_M_RD,
+		 .len = length,
+		 .buf = rxData,
+		 },
+	};
+
+	if (i2c_transfer(this_client->adapter, msgs, 2) < 0) {
+		printk(KERN_ERR "AKM8976 AKI2C_RxData: transfer error\n");
+		return -EIO;
+	} else
+		return 0;
+}
+
+static int AKI2C_TxData(char *txData, int length)
+{
+
+	struct i2c_msg msg[] = {
+		{
+		 .addr = this_client->addr,
+		 .flags = 0,
+		 .len = length,
+		 .buf = txData,
+		 },
+	};
+
+	if (i2c_transfer(this_client->adapter, msg, 1) < 0) {
+		printk(KERN_ERR "AKM8976 AKI2C_TxData: transfer error\n");
+		return -EIO;
+	} else
+		return 0;
+}
+
+static int AKECS_Init(void)
+{
+	char buffer[4];
+
+	cspec_num = CSPEC_SEQ_NUM;
+	atomic_set(&cspec_frq, CSPEC_SFRQ_32);
+
+	/* Prepare data */
+	buffer[0] = AKECS_REG_MS2;
+	buffer[1] = ((CSPEC_AINT << 7) |
+		     (cspec_num << 5) |
+		     (atomic_read(&cspec_frq) << 4) |
+		     (CSPEC_MCS << 1) | (CSPEC_MKS));
+	buffer[2] = (CSPEC_INTEN << 2);
+
+	return AKI2C_TxData(buffer, 3);
+}
+
+static void AKECS_Reset(void)
+{
+	gpio_set_value(pdata->reset, 0);
+	udelay(120);
+	gpio_set_value(pdata->reset, 1);
+}
+
+static int AKECS_StartMeasure(void)
+{
+	char buffer[2];
+	int ret;
+
+	buffer[0] = AKECS_REG_MS2;
+	buffer[1] = ((CSPEC_AINT << 7) |
+		     (cspec_num << 5) |
+		     (atomic_read(&cspec_frq) << 4) |
+		     (CSPEC_MCS << 1) | (CSPEC_MKS));
+
+	/* Set data */
+	ret = AKI2C_TxData(buffer, 2);
+	if (ret < 0)
+		return ret;
+
+	/* Set measure mode */
+	buffer[0] = AKECS_REG_MS1;
+	buffer[1] = AKECS_MODE_MEASURE;
+
+	/* Set data */
+	return AKI2C_TxData(buffer, 2);
+}
+
+static int AKECS_StartPFFD(void)
+{
+	char buffer[2];
+	int ret;
+
+	/* Set PFFD mode */
+	buffer[0] = AKECS_REG_MS1;
+	buffer[1] = AKECS_MODE_PFFD;
+	/* Set data */
+	ret = AKI2C_TxData(buffer, 2);
+	if (ret < 0)
+		return ret;
+
+	ret = gpio_direction_output(pdata->clk_on, 1);
+	if (ret < 0)
+		return ret;
+
+	pffd_mode = 1;
+	return ret;
+}
+
+static int AKECS_PowerDown(void)
+{
+	char buffer[2];
+	int ret;
+
+	/* Set powerdown mode */
+	buffer[0] = AKECS_REG_MS1;
+	buffer[1] = AKECS_MODE_POWERDOWN;
+	/* Set data */
+	ret = AKI2C_TxData(buffer, 2);
+	if (ret < 0)
+		return ret;
+
+	/* Dummy read for clearing INT pin */
+	buffer[0] = AKECS_REG_TMPS;
+	/* Read data */
+	ret = AKI2C_RxData(buffer, 1);
+	if (ret < 0)
+		return ret;
+
+	if (pffd_mode == 1) {
+		pffd_mode = 0;
+		ret = gpio_direction_output(pdata->clk_on, 0);
+	}
+	return ret;
+}
+
+static int AKECS_StartE2PRead(void)
+{
+	char buffer[2];
+
+	/* Set measure mode */
+	buffer[0] = AKECS_REG_MS1;
+	buffer[1] = AKECS_MODE_E2P_READ;
+	/* Set data */
+	return AKI2C_TxData(buffer, 2);
+}
+
+static int AKECS_GetData(void)
+{
+	char buffer[RBUFF_SIZE + 1];
+	int ret;
+
+	memset(buffer, 0, RBUFF_SIZE + 1);
+	buffer[0] = AKECS_REG_ST;
+	ret = AKI2C_RxData(buffer, 32);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&sense_data_mutex);
+	memcpy(sense_data, buffer, sizeof(buffer));
+	atomic_set(&data_ready, 1);
+	wake_up(&data_ready_wq);
+	mutex_unlock(&sense_data_mutex);
+
+	return 0;
+}
+
+static int AKECS_SetMode(char mode)
+{
+	int ret, status;
+	char buffer[1];
+
+	if (mode == AKECS_MODE_MEASURE_SNG) {
+		/* Check INT pin before mode setting */
+		status = gpio_get_value(pdata->intr);
+		if (status) {
+			printk(KERN_INFO
+			       "AKM8976 AKECS_SetMode:"\
+			       "dummy read to reset INT pin \n");
+			buffer[0] = AKECS_REG_TMPS;
+			ret = AKI2C_RxData(buffer, 1);
+			if (ret < 0)
+				return ret;
+			status = gpio_get_value(pdata->intr);
+			printk(KERN_INFO
+			       "AKM8976 AKECS_SetMode:"\
+			       "after dummy read, status = %d \n",
+			       status);
+		}
+	}
+
+	switch (mode) {
+	case AKECS_MODE_MEASURE_SNG:
+		cspec_num = CSPEC_SNG_NUM;
+		ret = AKECS_StartMeasure();
+		break;
+	case AKECS_MODE_MEASURE_SEQ:
+		cspec_num = CSPEC_SEQ_NUM;
+		ret = AKECS_StartMeasure();
+		break;
+	case AKECS_MODE_PFFD:
+		ret = AKECS_StartPFFD();
+		break;
+	case AKECS_MODE_E2P_READ:
+		ret = AKECS_StartE2PRead();
+		break;
+	case AKECS_MODE_POWERDOWN:
+		ret = AKECS_PowerDown();
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* wait at least 300us after changing mode */
+	msleep(1);
+	return ret;
+}
+
+static int AKECS_TransRBuff(char *rbuf, int size)
+{
+	wait_event_interruptible_timeout(data_ready_wq,
+					 atomic_read(&data_ready), 1000);
+
+	if (!atomic_read(&data_ready)) {
+		if (!atomic_read(&suspend_flag)) {
+			printk(KERN_ERR
+			       "AKM8976 AKECS_TransRBUFF: Data not ready\n");
+			failure_count++;
+			if (failure_count >= MAX_FAILURE_COUNT) {
+				printk(KERN_ERR
+				       "AKM8976 AKECS_TransRBUFF:"\
+				       "successive %d failure.\n",
+				       failure_count);
+				atomic_set(&open_flag, -1);
+				wake_up(&open_wq);
+				failure_count = 0;
+			}
+		}
+		return -1;
+	}
+
+	if ((sense_data[0] & 0x02) == 0x02) {
+		printk(KERN_ERR "AKM8976 AKECS_TransRBUFF: Data error\n");
+		return -1;
+	}
+
+	mutex_lock(&sense_data_mutex);
+	memcpy(&rbuf[1], &sense_data[1], size);
+	atomic_set(&data_ready, 0);
+	mutex_unlock(&sense_data_mutex);
+
+
+	failure_count = 0;
+	return 0;
+}
+
+static int AKECS_Set_PERST(void)
+{
+	char buffer[2];
+
+	buffer[0] = AKECS_REG_MS3;
+	buffer[1] = ((CSPEC_INTEN << 2) | 0x01);
+
+	/* Set data */
+	return AKI2C_TxData(buffer, 2);
+}
+
+static int AKECS_Set_G0RST(void)
+{
+	char buffer[2];
+
+	buffer[0] = AKECS_REG_MS3;
+	buffer[1] = ((CSPEC_INTEN << 2) | 0x02);
+
+	/* Set data */
+	return AKI2C_TxData(buffer, 2);
+}
+
+static void AKECS_Report_Value(short *rbuf)
+{
+	struct akm8976_data *data = i2c_get_clientdata(this_client);
+#if DEBUG
+	printk(KERN_INFO
+	       "AKECS_Report_Value: yaw = %d, pitch = %d, roll = %d\n",
+	       rbuf[0], rbuf[1], rbuf[2]);
+	printk(KERN_INFO
+	       "                    tmp = %d, m_stat= %d, g_stat=%d\n",
+	       rbuf[3], rbuf[4], rbuf[5]);
+	printk(KERN_INFO
+	       "          G_Sensor:   x = %d LSB, y = %d LSB, z = %d LSB\n",
+	       rbuf[6], rbuf[7], rbuf[8]);
+#endif
+	/* Report magnetic sensor information */
+	if (atomic_read(&m_flag)) {
+		input_report_abs(data->input_dev, ABS_RX, rbuf[0]);
+		input_report_abs(data->input_dev, ABS_RY, rbuf[1]);
+		input_report_abs(data->input_dev, ABS_RZ, rbuf[2]);
+		input_report_abs(data->input_dev, ABS_RUDDER, rbuf[4]);
+	}
+
+	/* Report acceleration sensor information */
+	if (atomic_read(&a_flag)) {
+		input_report_abs(data->input_dev, ABS_X, rbuf[6]);
+		input_report_abs(data->input_dev, ABS_Y, rbuf[7]);
+		input_report_abs(data->input_dev, ABS_Z, rbuf[8]);
+		input_report_abs(data->input_dev, ABS_WHEEL, rbuf[5]);
+	}
+
+	/* Report temperature information */
+	if (atomic_read(&t_flag)) {
+		input_report_abs(data->input_dev, ABS_THROTTLE, rbuf[3]);
+	}
+
+	if (atomic_read(&mv_flag)) {
+		input_report_abs(data->input_dev, ABS_HAT0X, rbuf[9]);
+		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[10]);
+		input_report_abs(data->input_dev, ABS_BRAKE, rbuf[11]);
+	}
+
+	input_sync(data->input_dev);
+}
+
+static void AKECS_Report_StepCount(short count)
+{
+	struct akm8976_data *data = i2c_get_clientdata(this_client);
+#if DEBUG
+	printk(KERN_INFO"AKECS_Report_StepCount: %d \n", count);
+#endif
+
+	/* Report pedometer information */
+	input_report_abs(data->input_dev, ABS_GAS, count);
+	input_sync(data->input_dev);
+}
+
+static int AKECS_GetOpenStatus(void)
+{
+	wait_event_interruptible(open_wq, (atomic_read(&open_flag) != 0));
+	return atomic_read(&open_flag);
+}
+
+static int AKECS_GetCloseStatus(void)
+{
+	wait_event_interruptible(open_wq, (atomic_read(&open_flag) <= 0));
+	return atomic_read(&open_flag);
+}
+
+static void AKECS_CloseDone(void)
+{
+	atomic_set(&m_flag, 1);
+	atomic_set(&a_flag, 1);
+	atomic_set(&t_flag, 1);
+	atomic_set(&mv_flag, 1);
+}
+
+static int akm_aot_open(struct inode *inode, struct file *file)
+{
+	int ret = -1;
+	if (atomic_cmpxchg(&open_count, 0, 1) == 0) {
+		if (atomic_cmpxchg(&open_flag, 0, 1) == 0) {
+			atomic_set(&reserve_open_flag, 1);
+			wake_up(&open_wq);
+			ret = 0;
+		}
+	}
+	return ret;
+}
+
+static int akm_aot_release(struct inode *inode, struct file *file)
+{
+	atomic_set(&reserve_open_flag, 0);
+	atomic_set(&open_flag, 0);
+	atomic_set(&open_count, 0);
+	wake_up(&open_wq);
+	return 0;
+}
+
+static int
+akm_aot_ioctl(struct inode *inode, struct file *file,
+	      unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	short flag;
+
+	switch (cmd) {
+	case ECS_IOCTL_APP_SET_MFLAG:
+	case ECS_IOCTL_APP_SET_AFLAG:
+	case ECS_IOCTL_APP_SET_TFLAG:
+	case ECS_IOCTL_APP_SET_MVFLAG:
+		if (copy_from_user(&flag, argp, sizeof(flag)))
+			return -EFAULT;
+		if (flag < 0 || flag > 1)
+			return -EINVAL;
+		break;
+	case ECS_IOCTL_APP_SET_DELAY:
+		if (copy_from_user(&flag, argp, sizeof(flag)))
+			return -EFAULT;
+		break;
+	default:
+		break;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_APP_SET_MFLAG:
+		atomic_set(&m_flag, flag);
+		break;
+	case ECS_IOCTL_APP_GET_MFLAG:
+		flag = atomic_read(&m_flag);
+		break;
+	case ECS_IOCTL_APP_SET_AFLAG:
+		atomic_set(&a_flag, flag);
+		break;
+	case ECS_IOCTL_APP_GET_AFLAG:
+		flag = atomic_read(&a_flag);
+		break;
+	case ECS_IOCTL_APP_SET_TFLAG:
+		atomic_set(&t_flag, flag);
+		break;
+	case ECS_IOCTL_APP_GET_TFLAG:
+		flag = atomic_read(&t_flag);
+		break;
+	case ECS_IOCTL_APP_SET_MVFLAG:
+		atomic_set(&mv_flag, flag);
+		break;
+	case ECS_IOCTL_APP_GET_MVFLAG:
+		flag = atomic_read(&mv_flag);
+		break;
+	case ECS_IOCTL_APP_SET_DELAY:
+		akmd_delay = flag;
+		break;
+	case ECS_IOCTL_APP_GET_DELAY:
+		flag = akmd_delay;
+		break;
+	default:
+		return -ENOTTY;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_APP_GET_MFLAG:
+	case ECS_IOCTL_APP_GET_AFLAG:
+	case ECS_IOCTL_APP_GET_TFLAG:
+	case ECS_IOCTL_APP_GET_MVFLAG:
+	case ECS_IOCTL_APP_GET_DELAY:
+		if (copy_to_user(argp, &flag, sizeof(flag)))
+			return -EFAULT;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int akm_pffd_open(struct inode *inode, struct file *file)
+{
+	int ret = -1;
+	if (atomic_cmpxchg(&open_count, 0, 1) == 0) {
+		if (atomic_cmpxchg(&open_flag, 0, 2) == 0) {
+			atomic_set(&reserve_open_flag, 2);
+			wake_up(&open_wq);
+			ret = 0;
+		}
+	}
+	return ret;
+}
+
+static int akm_pffd_release(struct inode *inode, struct file *file)
+{
+	atomic_set(&reserve_open_flag, 0);
+	atomic_set(&open_flag, 0);
+	atomic_set(&open_count, 0);
+	wake_up(&open_wq);
+	return 0;
+}
+
+static int
+akm_pffd_ioctl(struct inode *inode, struct file *file,
+	       unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	short flag;
+	int ret;
+
+	switch (cmd) {
+	case ECS_IOCTL_APP_SET_DELAY:
+		if (copy_from_user(&flag, argp, sizeof(flag)))
+			return -EFAULT;
+		break;
+	default:
+		break;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_APP_RESET_PEDOMETER:
+		ret = AKECS_Set_PERST();
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_APP_SET_DELAY:
+		akmd_delay = flag;
+		break;
+	case ECS_IOCTL_APP_GET_DELAY:
+		flag = akmd_delay;
+		break;
+	default:
+		return -ENOTTY;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_APP_GET_DELAY:
+		if (copy_to_user(argp, &flag, sizeof(flag)))
+			return -EFAULT;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int akmd_open(struct inode *inode, struct file *file)
+{
+	return nonseekable_open(inode, file);
+}
+
+static int akmd_release(struct inode *inode, struct file *file)
+{
+	AKECS_CloseDone();
+	return 0;
+}
+
+static int
+akmd_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+	   unsigned long arg)
+{
+
+	void __user *argp = (void __user *)arg;
+
+	char msg[RBUFF_SIZE + 1], rwbuf[5], numfrq[2];
+	int ret = -1, status;
+	short mode, value[12], step_count, delay;
+	char *pbuffer = 0;
+
+	switch (cmd) {
+	case ECS_IOCTL_READ:
+	case ECS_IOCTL_WRITE:
+		if (copy_from_user(&rwbuf, argp, sizeof(rwbuf)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_SET_MODE:
+		if (copy_from_user(&mode, argp, sizeof(mode)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_SET_YPR:
+		if (copy_from_user(&value, argp, sizeof(value)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_SET_STEP_CNT:
+		if (copy_from_user(&step_count, argp, sizeof(step_count)))
+			return -EFAULT;
+		break;
+	default:
+		break;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_INIT:
+		ret = AKECS_Init();
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_RESET:
+		AKECS_Reset();
+		break;
+	case ECS_IOCTL_READ:
+		if (rwbuf[0] < 1)
+			return -EINVAL;
+		ret = AKI2C_RxData(&rwbuf[1], rwbuf[0]);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_WRITE:
+		if (rwbuf[0] < 2)
+			return -EINVAL;
+		ret = AKI2C_TxData(&rwbuf[1], rwbuf[0]);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_SET_MODE:
+		ret = AKECS_SetMode((char)mode);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_GETDATA:
+		ret = AKECS_TransRBuff(msg, RBUFF_SIZE);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_GET_NUMFRQ:
+		numfrq[0] = cspec_num;
+		numfrq[1] = atomic_read(&cspec_frq);
+		break;
+	case ECS_IOCTL_SET_PERST:
+		ret = AKECS_Set_PERST();
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_SET_G0RST:
+		ret = AKECS_Set_G0RST();
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_SET_YPR:
+		AKECS_Report_Value(value);
+		break;
+	case ECS_IOCTL_GET_OPEN_STATUS:
+		status = AKECS_GetOpenStatus();
+		break;
+	case ECS_IOCTL_GET_CLOSE_STATUS:
+		status = AKECS_GetCloseStatus();
+		break;
+	case ECS_IOCTL_SET_STEP_CNT:
+		AKECS_Report_StepCount(step_count);
+		break;
+	case ECS_IOCTL_GET_CALI_DATA:
+		pbuffer = get_akm_cal_ram();
+		break;
+	case ECS_IOCTL_GET_DELAY:
+		delay = akmd_delay;
+		break;
+	default:
+		return -ENOTTY;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_READ:
+		if (copy_to_user(argp, &rwbuf, sizeof(rwbuf)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_GETDATA:
+		if (copy_to_user(argp, &msg, sizeof(msg)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_GET_NUMFRQ:
+		if (copy_to_user(argp, &numfrq, sizeof(numfrq)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_GET_OPEN_STATUS:
+	case ECS_IOCTL_GET_CLOSE_STATUS:
+		if (copy_to_user(argp, &status, sizeof(status)))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_GET_CALI_DATA:
+		if (copy_to_user(argp, pbuffer, MAX_CALI_SIZE))
+			return -EFAULT;
+		break;
+	case ECS_IOCTL_GET_DELAY:
+		if (copy_to_user(argp, &delay, sizeof(delay)))
+			return -EFAULT;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static void akm_work_func(struct work_struct *work)
+{
+	if (AKECS_GetData() < 0)
+		printk(KERN_ERR "AKM8976 akm_work_func: Get data failed\n");
+	enable_irq(this_client->irq);
+}
+
+static irqreturn_t akm8976_interrupt(int irq, void *dev_id)
+{
+	struct akm8976_data *data = dev_id;
+	disable_irq(this_client->irq);
+	schedule_work(&data->work);
+	return IRQ_HANDLED;
+}
+
+static int akm8976_init_client(struct i2c_client *client)
+{
+	struct akm8976_data *data;
+	int ret;
+
+	data = i2c_get_clientdata(client);
+
+	mutex_init(&sense_data_mutex);
+
+	ret = request_irq(client->irq, akm8976_interrupt, IRQF_TRIGGER_HIGH,
+			  "akm8976", data);
+
+	if (ret < 0) {
+		printk(KERN_ERR "akm8976_init_client: request irq failed\n");
+		goto err;
+	}
+
+	pdata = client->dev.platform_data;
+	if (pdata == NULL) {
+		pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+		if (pdata == NULL) {
+			ret = -ENOMEM;
+			goto err_alloc_data_failed;
+		} else {
+			pdata->reset = ECS_RST;
+			pdata->clk_on = ECS_CLK_ON;
+			pdata->intr = ECS_INTR;
+		}
+	}
+
+	ret = gpio_request(pdata->reset, "akm8976");
+	if (ret < 0) {
+		printk(KERN_ERR
+		       "akm8976_init_client: request reset gpio failed\n");
+		goto err_free_irq;
+	}
+	ret = gpio_direction_output(pdata->reset, 1);
+	if (ret < 0) {
+		printk(KERN_ERR
+		       "akm8976_init_client: request reset gpio failed\n");
+		goto err_free_gpio;
+	}
+
+	ret = gpio_request(pdata->clk_on, "akm8976");
+	if (ret < 0) {
+		printk(KERN_ERR
+		       "akm8976_init_client: request clock gpio failed\n");
+		goto err_free_gpio;
+	}
+
+	ret = gpio_direction_output(pdata->clk_on, 0);
+	if (ret < 0) {
+		printk(KERN_ERR
+		       "akm8976_init_client: request clock gpio failed\n");
+		goto err_free_gpio_2;
+	}
+
+	init_waitqueue_head(&data_ready_wq);
+	init_waitqueue_head(&open_wq);
+
+	/* As default, report all information */
+	atomic_set(&m_flag, 1);
+	atomic_set(&a_flag, 1);
+	atomic_set(&t_flag, 1);
+	atomic_set(&mv_flag, 1);
+
+	return 0;
+
+err_free_gpio_2:
+	gpio_free(pdata->clk_on);
+err_free_gpio:
+	gpio_free(pdata->reset);
+err_free_irq:
+	free_irq(client->irq, 0);
+err_alloc_data_failed:
+err:
+	return ret;
+}
+
+static struct file_operations akmd_fops = {
+	.owner = THIS_MODULE,
+	.open = akmd_open,
+	.release = akmd_release,
+	.ioctl = akmd_ioctl,
+};
+
+static struct file_operations akm_aot_fops = {
+	.owner = THIS_MODULE,
+	.open = akm_aot_open,
+	.release = akm_aot_release,
+	.ioctl = akm_aot_ioctl,
+};
+
+static struct file_operations akm_pffd_fops = {
+	.owner = THIS_MODULE,
+	.open = akm_pffd_open,
+	.release = akm_pffd_release,
+	.ioctl = akm_pffd_ioctl,
+};
+
+static struct miscdevice akm_aot_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "akm8976_aot",
+	.fops = &akm_aot_fops,
+};
+
+static struct miscdevice akm_pffd_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "akm8976_pffd",
+	.fops = &akm_pffd_fops,
+};
+
+static struct miscdevice akmd_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "akm8976_daemon",
+	.fops = &akmd_fops,
+};
+
+static int akm8976_probe(
+	struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct akm8976_data *akm;
+	int err;
+	char rxData[2];
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+	akm = kzalloc(sizeof(struct akm8976_data), GFP_KERNEL);
+	if (!akm) {
+		err = -ENOMEM;
+		goto exit_alloc_data_failed;
+	}
+
+	INIT_WORK(&akm->work, akm_work_func);
+	i2c_set_clientdata(client, akm);
+	akm8976_init_client(client);
+	this_client = client;
+
+	/* Set EEPROM access mode */
+	err = AKECS_StartE2PRead();
+	if (err < 0)
+		goto exit_input_dev_alloc_failed;
+	/* Read ETS from EEPROM */
+	rxData[0] = 0x42;
+	err = AKI2C_RxData(rxData, 1);
+	if (err < 0)
+		goto exit_input_dev_alloc_failed;
+	revision = (0x03 & (rxData[0] >> 6));
+
+	/* Set Power down mode */
+	err = AKECS_PowerDown();
+	if (err < 0)
+		goto exit_input_dev_alloc_failed;
+
+	akm->input_dev = input_allocate_device();
+
+	if (!akm->input_dev) {
+		err = -ENOMEM;
+		printk(KERN_ERR
+		       "akm8976_probe: Failed to allocate input device\n");
+		goto exit_input_dev_alloc_failed;
+	}
+
+	set_bit(EV_ABS, akm->input_dev->evbit);
+	/* yaw */
+	input_set_abs_params(akm->input_dev, ABS_RX, 0, 360, 0, 0);
+	/* pitch */
+	input_set_abs_params(akm->input_dev, ABS_RY, -180, 180, 0, 0);
+	/* roll */
+	input_set_abs_params(akm->input_dev, ABS_RZ, -90, 90, 0, 0);
+	/* x-axis acceleration */
+	input_set_abs_params(akm->input_dev, ABS_X, -1872, 1872, 0, 0);
+	/* y-axis acceleration */
+	input_set_abs_params(akm->input_dev, ABS_Y, -1872, 1872, 0, 0);
+	/* z-axis acceleration */
+	input_set_abs_params(akm->input_dev, ABS_Z, -1872, 1872, 0, 0);
+	/* temparature */
+	input_set_abs_params(akm->input_dev, ABS_THROTTLE, -30, 85, 0, 0);
+	/* status of magnetic sensor */
+	input_set_abs_params(akm->input_dev, ABS_RUDDER, -32768, 3, 0, 0);
+	/* status of acceleration sensor */
+	input_set_abs_params(akm->input_dev, ABS_WHEEL, -32768, 3, 0, 0);
+	/* step count */
+	input_set_abs_params(akm->input_dev, ABS_GAS, 0, 65535, 0, 0);
+	/* x-axis of raw magnetic vector */
+	input_set_abs_params(akm->input_dev, ABS_HAT0X, -2048, 2032, 0, 0);
+	/* y-axis of raw magnetic vector */
+	input_set_abs_params(akm->input_dev, ABS_HAT0Y, -2048, 2032, 0, 0);
+	/* z-axis of raw magnetic vector */
+	input_set_abs_params(akm->input_dev, ABS_BRAKE, -2048, 2032, 0, 0);
+
+	akm->input_dev->name = "compass";
+
+	err = input_register_device(akm->input_dev);
+
+	if (err) {
+		printk(KERN_ERR
+		       "akm8976_probe: Unable to register input device: %s\n",
+		       akm->input_dev->name);
+		goto exit_input_register_device_failed;
+	}
+
+	err = misc_register(&akmd_device);
+	if (err) {
+		printk(KERN_ERR
+		       "akm8976_probe: akmd_device register failed\n");
+		goto exit_misc_device_register_failed;
+	}
+
+	err = misc_register(&akm_aot_device);
+	if (err) {
+		printk(KERN_ERR
+		       "akm8976_probe: akm_aot_device register failed\n");
+		goto exit_misc_device_register_failed;
+	}
+
+	err = misc_register(&akm_pffd_device);
+	if (err) {
+		printk(KERN_ERR
+		       "akm8976_probe: akm_pffd_device register failed\n");
+		goto exit_misc_device_register_failed;
+	}
+
+	err = device_create_file(&client->dev, &dev_attr_ms1);
+	err = device_create_file(&client->dev, &dev_attr_ms2);
+	err = device_create_file(&client->dev, &dev_attr_ms3);
+
+	gsensor_sysfs_init();
+
+	return 0;
+
+exit_misc_device_register_failed:
+exit_input_register_device_failed:
+	input_free_device(akm->input_dev);
+exit_input_dev_alloc_failed:
+	kfree(akm);
+exit_alloc_data_failed:
+exit_check_functionality_failed:
+	return err;
+}
+
+static int akm8976_remove(struct i2c_client *client)
+{
+	struct akm8976_data *akm = i2c_get_clientdata(client);
+	free_irq(client->irq, akm);
+	input_unregister_device(akm->input_dev);
+	i2c_detach_client(client);
+	kfree(akm);
+	return 0;
+}
+
+static int akm8976_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	atomic_set(&suspend_flag, 1);
+	if (atomic_read(&open_flag) == 2)
+		AKECS_SetMode(AKECS_MODE_POWERDOWN);
+
+	atomic_set(&reserve_open_flag, atomic_read(&open_flag));
+	atomic_set(&open_flag, 0);
+	wake_up(&open_wq);
+	disable_irq(this_client->irq);
+	return 0;
+}
+
+static int akm8976_resume(struct i2c_client *client)
+{
+	enable_irq(this_client->irq);
+	if (atomic_read(&open_flag) == 2)
+		AKECS_SetMode(AKECS_MODE_PFFD);
+	atomic_set(&suspend_flag, 0);
+	atomic_set(&open_flag, atomic_read(&reserve_open_flag));
+	wake_up(&open_wq);
+	return 0;
+}
+
+static const struct i2c_device_id akm8976_id[] = {
+	{ "akm8976", 0 },
+	{ }
+};
+
+static struct i2c_driver akm8976_driver = {
+	.probe = akm8976_probe,
+	.remove = akm8976_remove,
+	.suspend	= akm8976_suspend,
+	.resume		= akm8976_resume,
+	.id_table = akm8976_id,
+	.driver = {
+		   .name = "akm8976",
+		   },
+};
+
+static int __init akm8976_init(void)
+{
+	printk(KERN_INFO "AKM8976A compass driver: init\n");
+	return i2c_add_driver(&akm8976_driver);
+}
+
+static void __exit akm8976_exit(void)
+{
+	i2c_del_driver(&akm8976_driver);
+}
+
+module_init(akm8976_init);
+module_exit(akm8976_exit);
+
+MODULE_AUTHOR("Hou-Kun Chen <hk_chen@htc.com>");
+MODULE_DESCRIPTION("AKM8976A compass driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/i2c/chips/Kconfig linux-2.6.29-spica/drivers/i2c/chips/Kconfig
--- linux-2.6.29/drivers/i2c/chips/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/i2c/chips/Kconfig	2010-05-06 12:42:45.674299703 +0700
@@ -102,4 +102,34 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called tsl2550.
 
+config SENSORS_PCA963X
+	tristate "Philips PCA963X 4-bit I2C-bus LED"
+	depends on I2C && EXPERIMENTAL
+	help
+	 If you say yes here you get support for the Philips PCA963X
+	 4-bit I2C-bus LED.
+
+	 This driver can also be built as a module.  If so, the module
+	 will be called pca963X.
+
+config PMIC_MAX8906
+	tristate "Maxim MAX8906 Power Management chip"
+	depends on I2C
+	help
+	  If you say yes here you get support fot the Maxim MAX8906
+	  Power Management chip.
+
+	  This provides Applocations and Baseband Processor Power Management,
+	  ADC/TSC, RTC, and Audio Subsystem for Mobile Applications.
+
+config PMIC_MAX8698
+	tristate "Maxim MAX8698 Power Management chip"
+	depends on I2C
+	help
+	  If you say yes here you get support fot the Maxim MAX8698
+	  Power Management chip.
+
+	  This provides Applocations Processor Power Management,
+	  ADC/TSC, RTC, and Audio Subsystem for Mobile Applications.
+
 endmenu
diff -Nur linux-2.6.29/drivers/i2c/chips/Makefile linux-2.6.29-spica/drivers/i2c/chips/Makefile
--- linux-2.6.29/drivers/i2c/chips/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/i2c/chips/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -13,10 +13,13 @@
 obj-$(CONFIG_DS1682)		+= ds1682.o
 obj-$(CONFIG_SENSORS_MAX6875)	+= max6875.o
 obj-$(CONFIG_SENSORS_PCA9539)	+= pca9539.o
+obj-$(CONFIG_SENSORS_PCA963X)	+= pca963x.o
 obj-$(CONFIG_SENSORS_PCF8574)	+= pcf8574.o
 obj-$(CONFIG_PCF8575)		+= pcf8575.o
 obj-$(CONFIG_SENSORS_PCF8591)	+= pcf8591.o
 obj-$(CONFIG_SENSORS_TSL2550)	+= tsl2550.o
+obj-$(CONFIG_PMIC_MAX8906)	+= max8906.o
+obj-$(CONFIG_PMIC_MAX8698)	+= max8698.o
 
 ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
 EXTRA_CFLAGS += -DDEBUG
diff -Nur linux-2.6.29/drivers/i2c/chips/max8698.c linux-2.6.29-spica/drivers/i2c/chips/max8698.c
--- linux-2.6.29/drivers/i2c/chips/max8698.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/i2c/chips/max8698.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,586 @@
+/*
+ * linux/drivers/i2c/max8698.c
+ *
+ * Battery measurement code for SEC
+ *
+ * based on max8906.c
+ *
+ * Copyright (C) 2009 Samsung Electronics.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/i2c/maximi2c.h>
+#include <linux/i2c/pmic.h>
+
+#ifdef PREFIX
+#undef PREFIX
+#endif
+#define PREFIX "MAX8698: "
+
+max8698_register_type max8698reg[ENDOFREG] =
+{
+	/* Slave addr 		  Reg addr */
+	{ I2C_SLAVE_ADDR_MAX8698, REG_ONOFF1 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_ONOFF2 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_ADISCHG_EN1 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_ADISCHG_EN2 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_DVSARM1_2 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_DVSARM3_4 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_DVSINT1_2 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_BUCK3 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_LDO2_3 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_LDO4 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_LDO5 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_LDO6 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_LDO7 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_LDO8 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_LDO9 },
+	{ I2C_SLAVE_ADDR_MAX8698, REG_LBCNFG },
+};
+
+max8698_function_type max8698pm[ENDOFPM] =
+{
+	/* ONOFF1 register */
+	/* slave_addr              addr   mask   clear  shift */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x00,  0x80,  0x7F,  0x07 }, /* EN1 */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x00,  0x40,  0xBF,  0x06 }, /* EN2 */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x00,  0x20,  0xDF,  0x05 }, /* EN3 */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x00,  0x10,  0xEF,  0x04 }, /* ELDO2 */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x00,  0x08,  0xF7,  0x03 }, /* ELDO3 */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x00,  0x04,  0xFB,  0x02 }, /* ELDO4 */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x00,  0x02,  0xFD,  0x01 }, /* ELDO5 */
+	/* ONOFF2 register */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x01,  0x80,  0x7F,  0x07 }, /* ELDO6 */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x01,  0x40,  0xBF,  0x06 }, /* ELDO7 */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x01,  0x20,  0xDF,  0x05 }, /* ELDO8 */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x01,  0x10,  0xEF,  0x04 }, /* ELDO9 */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x01,  0x01,  0xFE,  0x00 }, /* ELBCNFG */
+	/* ADISCHG_EN1 register */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x02,  0x80,  0x7F,  0x07 }, /* BUCK1_ADEN */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x02,  0x40,  0xBF,  0x06 }, /* BUCK2_ADEN */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x02,  0x20,  0xDF,  0x05 }, /* BUCK3_ADEN */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x02,  0x10,  0xEF,  0x04 }, /* LDO2_ADEN */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x02,  0x08,  0xF7,  0x03 }, /* LDO3_ADEN */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x02,  0x04,  0xFB,  0x02 }, /* LDO4_ADEN */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x02,  0x02,  0xFD,  0x01 }, /* LDO5_ADEN */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x02,  0x01,  0xFE,  0x00 }, /* LDO6_ADEN */
+	/* ADISCHG_EN2 register */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x03,  0x80,  0x7F,  0x07 }, /* LDO7_ADEN */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x03,  0x40,  0xBF,  0x06 }, /* LDO8_ADEN */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x03,  0x20,  0xDF,  0x05 }, /* LDO9_ADEN */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x03,  0x0F,  0xF0,  0x00 }, /* RAMP */
+	/* DVSARM1_2 register */
+	{ I2C_SLAVE_ADDR_MAX8698,  0x04,  0xF0,  0x0F,  0x04 }, /* DVSARM2 */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x04,  0x0F,  0xF0,  0x00 }, /* DVSARM1 */
+	/* DVSARM3_4 register */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x05,  0xF0,  0x0F,  0x04 }, /* DVSARM4 */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x05,  0x0F,  0xF0,  0x00 }, /* DVSARM3 */
+	/* DVSINT1_2 register */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x06,  0xF0,  0x0F,  0x04 }, /* DVSINT2 */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x06,  0x0F,  0xF0,  0x00 }, /* DVSINT1 */
+	/* BUCK3 register */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x07,  0xFF,  0x00,  0x00 }, /* BUCK3 */
+	/* LDO2_3 register */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x08,  0xF0,  0x0F,  0x04 }, /* LDO3 */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x08,  0x0F,  0xF0,  0x00 }, /* LDO2 */
+	/* LDO4 register */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x09,  0xFF,  0x00,  0x00 }, /* LDO4 */
+	/* LDO5 register */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x0A,  0xFF,  0x00,  0x00 }, /* LDO5 */
+	/* LDO6 register */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x0B,  0xFF,  0x00,  0x00 }, /* LDO6 */
+    	/* LDO7 register */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x0C,  0xFF,  0x00,  0x00 }, /* LDO7 */
+	/* LDO8 & BKCHR register */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x0D,  0xF0,  0x0F,  0x04 }, /* LDO8 */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x0D,  0x0F,  0xF0,  0x00 }, /* BKCHR */
+	/* LDO9 register */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x0E,  0xFF,  0x00,  0x00 }, /* LDO9 */
+	/* LBCNFG register */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x0F,  0x30,  0x0E,  0x04 }, /* LBHYST */
+  	{ I2C_SLAVE_ADDR_MAX8698,  0x0F,  0x0E,  0xF1,  0x01 }, /* LBTH */
+};
+
+/* MAX8698 voltage table */
+#define ARM_VCC_TABLE_MAX		0x10
+static const unsigned int arm_voltage_table[ARM_VCC_TABLE_MAX] = {
+	750, 800, 850, 900,	/* 0x0 ~ 0x3 */
+	950, 1000, 1050, 1100,	/* 0x4 ~ 0x7 */
+	1150, 1200, 1250, 1300,	/* 0x8 ~ 0xB */
+	1350, 1400, 1450, 1500,	/* 0xC ~ 0xF */
+};
+
+
+
+/*===========================================================================
+
+      P O W E R     M A N A G E M E N T     S E C T I O N
+
+===========================================================================*/
+
+/*===========================================================================
+
+FUNCTION Set_MAX8698_PM_REG                                
+
+DESCRIPTION
+    This function write the value at the selected register in the PM section.
+
+INPUT PARAMETERS
+    reg_num :   selected register in the register address.
+    value   :   the value for reg_num.
+                This is aligned to the right side of the return value
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+    Set_MAX8698_PM_REG(CHGENB, onoff);
+
+===========================================================================*/
+boolean Set_MAX8698_PM_REG(max8698_pm_function_type reg_num, byte value)
+{
+    byte reg_buff = 0;
+
+    if(pmic_read(max8698pm[reg_num].slave_addr, max8698pm[reg_num].addr, &reg_buff, (byte)1) != PMIC_PASS)
+    {
+        // Register Read command failed
+        return FALSE;
+    }
+
+    reg_buff = (reg_buff & max8698pm[reg_num].clear) | (value << max8698pm[reg_num].shift);
+    if(pmic_write(max8698pm[reg_num].slave_addr, max8698pm[reg_num].addr, &reg_buff, (byte)1) != PMIC_PASS)
+    {
+        // Register Write command failed
+        return FALSE;
+    }
+    return TRUE;
+}
+EXPORT_SYMBOL(Set_MAX8698_PM_REG);
+
+/*===========================================================================
+
+FUNCTION Get_MAX8698_PM_REG                                
+
+DESCRIPTION
+    This function read the value at the selected register in the PM section.
+
+INPUT PARAMETERS
+    reg_num :   selected register in the register address.
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+    reg_buff :  the value of selected register.
+                reg_buff is aligned to the right side of the return value.
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Get_MAX8698_PM_REG(max8698_pm_function_type reg_num, byte *reg_buff)
+{
+    byte temp_buff;
+
+    if(pmic_read(max8698pm[reg_num].slave_addr, max8698pm[reg_num].addr, &temp_buff, (byte)1) != PMIC_PASS)
+    {
+        // Register Read Command failed
+        return FALSE;
+    }
+
+    *reg_buff = (byte)((temp_buff & max8698pm[reg_num].mask) >> max8698pm[reg_num].shift);
+
+    return TRUE;
+}
+EXPORT_SYMBOL(Get_MAX8698_PM_REG);
+
+/*===========================================================================
+
+FUNCTION Set_MAX8698_PM_ADDR                                
+
+DESCRIPTION
+    This function write the value at the selected register address
+    in the PM section.
+
+INPUT PARAMETERS
+    max8698_pm_register_type reg_addr    : the register address.
+    byte *reg_buff   : the array for data of register to write.
+ 	byte length      : the number of the register 
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Set_MAX8698_PM_ADDR(max8698_pm_register_type reg_addr, byte *reg_buff, byte length)
+{
+
+    if(pmic_write(max8698reg[reg_addr].slave_addr, max8698reg[reg_addr].addr, reg_buff, length) != PMIC_PASS)
+    {
+        // Register Write command failed
+        return FALSE;
+    }
+    return TRUE;
+
+}
+
+
+/*===========================================================================
+
+FUNCTION Get_MAX8698_PM_ADDR                                
+
+DESCRIPTION
+    This function read the value at the selected register address
+    in the PM section.
+
+INPUT PARAMETERS
+    max8698_pm_register_type reg_addr   : the register address.
+    byte *reg_buff  : the array for data of register to write.
+ 	byte length     : the number of the register 
+
+RETURN VALUE
+    byte *reg_buff : the pointer parameter for data of sequential registers
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Get_MAX8698_PM_ADDR(max8698_pm_register_type reg_addr, byte *reg_buff, byte length)
+{
+    if(reg_addr > ENDOFREG)
+    {
+        // Invalid Read Register
+        return FALSE; // return error;
+    }
+    if(pmic_read(max8698reg[reg_addr].slave_addr, max8698reg[reg_addr].addr, reg_buff, length) != PMIC_PASS)
+    {
+        // Register Read command failed
+        return FALSE;
+    }
+    return TRUE;
+}
+
+/*===========================================================================*/
+boolean change_vcc_arm(int voltage)
+{
+	byte reg_value = 0;
+
+	pr_debug(PREFIX "%s:I: voltage: %d\n", __func__, voltage);
+
+	if (voltage < DVSARM_MIN_VCC || voltage > DVSARM_MAX_VCC) {
+		pr_err(PREFIX "%s:E: invalid voltage: %d\n", __func__, voltage);
+		return FALSE;
+	}
+
+	if (voltage % 50) {
+		pr_err(PREFIX "%s:E: invalid voltage: %d\n", __func__, voltage);
+		return FALSE;
+	}
+
+	for (reg_value = 0; reg_value <  ARM_VCC_TABLE_MAX; reg_value++) {
+		if ( arm_voltage_table[reg_value] == voltage )
+			break;
+	}
+
+	if (!Set_MAX8698_PM_REG(DVSARM1, reg_value)) {
+		pr_err(PREFIX "%s:E: set pmic reg fail(%d)\n", __func__, reg_value);
+		return FALSE;
+	}
+ 
+	return TRUE;
+}
+
+boolean change_vcc_internal(int voltage)
+{
+	byte reg_value = 0;
+
+	pr_debug(PREFIX "%s:I: voltage: %d\n", __func__, voltage);
+
+	if (voltage < DVSINT_MIN_VCC || voltage > DVSINT_MAX_VCC) {
+		pr_err(PREFIX "%s:E: invalid voltage: %d\n", __func__, voltage);
+		return FALSE;
+	}
+
+	if (voltage % 50) {
+		pr_err(PREFIX "%s:E: invalid voltage: %d\n", __func__, voltage);
+		return FALSE;
+	}
+
+	for (reg_value = 0; reg_value <  ARM_VCC_TABLE_MAX; reg_value++) {
+		if ( arm_voltage_table[reg_value] == voltage )
+			break;
+	}
+
+	if (!Set_MAX8698_PM_REG(DVSINT1, reg_value))
+	{
+		pr_err(PREFIX "%s:E: set pmic reg fail(%d)\n", __func__, reg_value);
+		return FALSE;
+	}
+ 
+	return TRUE;
+}
+
+boolean set_pmic(pmic_pm_type pm_type, int value)
+{
+	boolean rc = FALSE;
+	switch (pm_type) {
+	case VCC_ARM:
+		rc = change_vcc_arm(value);
+		break;
+	case VCC_INT:
+		rc = change_vcc_internal(value);
+		break;
+	default:
+		pr_err(PREFIX "%s:E: invalid pm_type: %d\n", __func__, pm_type);
+		rc = FALSE;
+		break;
+	}
+	return rc;
+}
+
+boolean get_pmic(pmic_pm_type pm_type, int *value)
+{
+	boolean rc = FALSE;
+	byte reg_buff;
+	*value = 0;
+
+	switch (pm_type) {
+	case VCC_ARM:
+		if(! Get_MAX8698_PM_REG(DVSARM1, &reg_buff)) {
+			pr_err(PREFIX "%s:VCC_ARM: get pmic reg fail\n",
+					__func__);
+			return FALSE;
+		}
+		if((reg_buff) < ARM_VCC_TABLE_MAX)
+			*value = arm_voltage_table[reg_buff];
+		break;
+	case VCC_INT:
+		if(!Get_MAX8698_PM_REG(DVSINT1, &reg_buff))
+		{
+			pr_err(PREFIX "%s:VCC_INT: get pmic reg fail\n",
+					__func__);
+			return FALSE;
+		}
+		if((reg_buff) < ARM_VCC_TABLE_MAX)
+			*value = arm_voltage_table[reg_buff];
+		break;
+	default:
+		pr_err(PREFIX "%s:E: invalid pm_type: %d\n", __func__, pm_type);
+		rc = FALSE;
+		break;
+	}
+        return rc;
+}
+
+/*============================================================================*/
+/* MAX8698 I2C Interface                                                      */
+/*============================================================================*/
+
+#include <linux/i2c.h>
+
+#define I2C_GPIO3_DEVICE_ID	3 /* mach-($DEVICE_NAME).c */
+
+static struct i2c_driver max8698_driver;
+static struct i2c_client *max8698_i2c_client = NULL;
+
+static unsigned short max8698_normal_i2c[] = { I2C_CLIENT_END };
+static unsigned short max8698_ignore[] = { I2C_CLIENT_END };
+static unsigned short max8698_probe[] = { I2C_GPIO3_DEVICE_ID,
+	(I2C_SLAVE_ADDR_MAX8698 >> 1), I2C_CLIENT_END };
+
+static struct i2c_client_address_data max8698_addr_data = {
+	.normal_i2c = max8698_normal_i2c,
+	.ignore		= max8698_ignore,
+	.probe		= max8698_probe,
+};
+
+static int max8698_read(struct i2c_client *client, u8 reg, u8 *data)
+{
+	int ret;
+	u8 buf[1];
+	struct i2c_msg msg[2];
+
+	buf[0] = reg; 
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret != 2) 
+		return -EIO;
+
+	*data = buf[0];
+	
+	return 0;
+}
+
+static int max8698_write(struct i2c_client *client, u8 reg, u8 data)
+{
+	int ret;
+	u8 buf[2];
+	struct i2c_msg msg[1];
+
+	buf[0] = reg;
+	buf[1] = data;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 2;
+	msg[0].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msg, 1);
+	if (ret != 1) 
+		return -EIO;
+
+	return 0;
+}
+
+unsigned int pmic_read(u8 slaveaddr, u8 reg, u8 *data, u8 length)
+{
+	struct i2c_client *client;
+#if 0
+	pr_info("%s -> reg 0x%02x, data 0x%02x\n", __func__, reg, *data);
+#endif	
+	if (slaveaddr == I2C_SLAVE_ADDR_MAX8698)
+		client = max8698_i2c_client;
+	else 
+		return PMIC_FAIL;
+
+	if (max8698_read(client, reg, data) < 0) { 
+		pr_err(KERN_ERR "%s -> Failed! (reg 0x%02x, data 0x%02x)\n",
+					__func__, reg, *data);
+		return PMIC_FAIL;
+	}	
+
+	return PMIC_PASS;
+}
+
+unsigned int pmic_write(u8 slaveaddr, u8 reg, u8 *data, u8 length)
+{
+	struct i2c_client *client;
+#if 0
+	pr_info("%s -> reg 0x%02x, data 0x%02x\n", __func__, reg, *data);
+#endif	
+	if (slaveaddr == I2C_SLAVE_ADDR_MAX8698)
+		client = max8698_i2c_client;
+	else 
+		return PMIC_FAIL;
+
+	if (max8698_write(client, reg, *data) < 0) { 
+		pr_err(KERN_ERR "%s -> Failed! (reg 0x%02x, data 0x%02x)\n",
+					__func__, reg, *data);
+		return PMIC_FAIL;
+	}	
+
+	return PMIC_PASS;
+}
+
+unsigned int pmic_tsc_write(u8 slaveaddr, u8 *cmd)
+{
+	return 0;
+}
+
+unsigned int pmic_tsc_read(u8 slaveaddr, u8 *cmd)
+{
+	return 0;
+}
+
+static int max8698_attach(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct i2c_client *c;
+	int ret;
+
+	c = kmalloc(sizeof(*c), GFP_KERNEL);
+	if (!c)
+		return -ENOMEM;
+
+	memset(c, 0, sizeof(struct i2c_client));	
+
+	strncpy(c->name, max8698_driver.driver.name, I2C_NAME_SIZE);
+	c->addr = addr;
+	c->adapter = adap;
+	c->driver = &max8698_driver;
+
+	if ((ret = i2c_attach_client(c)))
+		goto error;
+
+	max8698_i2c_client = c;
+
+error:
+	return ret;
+}
+
+static int max8698_attach_adapter(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &max8698_addr_data, max8698_attach);
+}
+
+static int max8698_detach_client(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+	return 0;
+}
+
+static int max8698_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	return 0;
+}
+
+static struct i2c_driver max8698_driver = {
+	.driver = {
+		.name = "max8698",
+	},
+	.attach_adapter = max8698_attach_adapter,
+	.detach_client = max8698_detach_client,
+	.command = max8698_command
+};
+
+static int pmic_init_status = 0;
+int is_pmic_initialized(void)
+{
+	return pmic_init_status;
+}
+
+static int __init max8698_init(void)
+{
+	int ret;
+	ret = i2c_add_driver(&max8698_driver);
+	pmic_init_status = 1;
+	return ret;
+}
+
+static void __exit max8698_exit(void)
+{
+	i2c_del_driver(&max8698_driver);
+	pmic_init_status = 0;
+}
+
+module_init(max8698_init);
+module_exit(max8698_exit);
+
+MODULE_AUTHOR("Minsung Kim <ms925.kim@samsung.com>");
+MODULE_DESCRIPTION("MAX8698 Driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/i2c/chips/max8906.c linux-2.6.29-spica/drivers/i2c/chips/max8906.c
--- linux-2.6.29/drivers/i2c/chips/max8906.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/i2c/chips/max8906.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,2842 @@
+// Maxim 8906 Command Module: Interface Window
+// Firmware Group
+// 1/2/2008   initialize
+// (C) 2004 Maxim Integrated Products
+//---------------------------------------------------------------------------
+
+#include <linux/kernel.h>
+#include <linux/i2c/maximi2c.h>
+#include <linux/i2c/pmic.h>
+
+#ifdef PREFIX
+#undef PREFIX
+#endif
+#define PREFIX "MAX8906: "
+
+#define MSG_HIGH(a,b,c,d)		{}
+
+max8906_register_type  max8906reg[ENDOFREG] =
+{
+    //========================================================
+    //  B A T T E R Y   C H A R G E R S
+    //========================================================
+    /* Slave addr   Reg addr */
+    {  0x78,        0x7C }, // REG_CHG_CNTL1,
+    {  0x78,        0x7D }, // REG_CHG_CNTL2,
+    {  0x78,        0x7E }, // REG_CHG_IRQ1,
+    {  0x78,        0x7F }, // REG_CHG_IRQ2,
+    {  0x78,        0x80 }, // REG_CHG_IRQ1_MASK,
+    {  0x78,        0x81 }, // REG_CHG_IRQ2_MASK,
+    {  0x78,        0x82 }, // REG_CHG_STAT,
+    {  0x78,        0x78 }, // REG_BBATTCNFG,
+
+    //========================================================
+    //  S T E P - D O W N    R E G U L A T O R S
+    //========================================================
+    /* Slave addr   Reg addr */
+    {  0x78,        0x5C }, // REG_WBBCOREEN,
+    {  0x78,        0x5D }, // REG_WBBCOREFSEQ,
+    {  0x78,        0x5E }, // REG_WBBCORETV,
+    {  0x78,        0x9C }, // REG_WBBRFEN,
+    {  0x78,        0x9D }, // REG_WBBRFFSEQ,
+    {  0x78,        0x9E }, // REG_WBBRFTV,
+    {  0x78,        0x04 }, // REG_APPSEN,
+    {  0x68,        0x10 }, // REG_OVER1,
+    {  0x78,        0x05 }, // REG_APPSFSEQ,
+    {  0x68,        0x23 }, // REG_ADTV1,
+    {  0x68,        0x24 }, // REG_ADTV2,
+    {  0x78,        0x06 }, // REG_APPSCLG,
+    {  0x68,        0x20 }, // REG_VCC1,
+    {  0x78,        0x08 }, // REG_IOEN,
+    {  0x78,        0x09 }, // REG_IOFSEQ,
+    {  0x78,        0x0C }, // REG_MEMEN,
+    {  0x78,        0x0D }, // REG_MEMFSEQ,
+
+    //========================================================
+    //  L I N E A R   R E G U L A T O R S
+    //========================================================
+    /* Slave addr   Reg addr */
+    {  0x78,        0x10 }, // REG_WBBMEMEN,
+    {  0x78,        0x11 }, // REG_WBBMEMFSEQ,
+    {  0x78,        0x12 }, // REG_WBBMEMTV,
+    {  0x78,        0x14 }, // REG_WBBIOEN,
+    {  0x78,        0x15 }, // REG_WBBIOFSEQ,
+    {  0x78,        0x16 }, // REG_WBBIOTV,
+    {  0x78,        0x18 }, // REG_WBBANAEN,
+    {  0x78,        0x19 }, // REG_WBBANAFSEQ,
+    {  0x78,        0x1A }, // REG_WBBANATV,
+    {  0x78,        0x1C }, // REG_RFRXLEN,
+    {  0x78,        0x1D }, // REG_RFRXLFSEQ,
+    {  0x78,        0x1E }, // REG_RFRXLTV,
+    {  0x78,        0x20 }, // REG_RFTXLEN,
+    {  0x78,        0x21 }, // REG_RFTXLFSEQ,
+    {  0x78,        0x22 }, // REG_RFTXLTV,
+    {  0x78,        0x24 }, // REG_RFRXHEN,
+    {  0x78,        0x25 }, // REG_RFRXHFSEQ,
+    {  0x78,        0x26 }, // REG_RFRXHTV,
+    {  0x78,        0x28 }, // REG_RFTCXOEN,
+    {  0x78,        0x29 }, // REG_RFTCXOFSEQ,
+    {  0x78,        0x2A }, // REG_RFTCXOTV,
+    {  0x78,        0x2C }, // REG_LDOAEN,
+    {  0x78,        0x2D }, // REG_LDOAFSEQ,
+    {  0x78,        0x2E }, // REG_LDOATV,
+    {  0x78,        0x30 }, // REG_LDOBEN,
+    {  0x78,        0x31 }, // REG_LDOBFSEQ,
+    {  0x78,        0x32 }, // REG_LDOBTV,
+    {  0x78,        0x34 }, // REG_LDOCEN,
+    {  0x78,        0x35 }, // REG_LDOCFSEQ,
+    {  0x78,        0x36 }, // REG_LDOCTV,
+    {  0x78,        0x38 }, // REG_LDODEN,
+    {  0x78,        0x39 }, // REG_LDODFSEQ,
+    {  0x78,        0x3A }, // REG_LDODTV,
+    {  0x78,        0x3C }, // REG_SIMLTEN,
+    {  0x78,        0x3D }, // REG_SIMLTFSEQ,
+    {  0x78,        0x3E }, // REG_SIMLTTV,
+    {  0x78,        0x40 }, // REG_SRAMEN,
+    {  0x78,        0x41 }, // REG_SRAMFSEQ,
+    {  0x68,        0x29 }, // REG_SDTV1,
+    {  0x68,        0x2A }, // REG_SDTV2,
+    {  0x78,        0x42 }, // REG_SRAMCLG,
+    {  0x78,        0x44 }, // REG_CARD1EN,
+    {  0x78,        0x45 }, // REG_CARD1FSEQ,
+    {  0x78,        0x46 }, // REG_CARD1TV,
+    {  0x78,        0x48 }, // REG_CARD2EN,
+    {  0x78,        0x49 }, // REG_CARD2FSEQ,
+    {  0x78,        0x4A }, // REG_CARD2TV,
+    {  0x78,        0x4C }, // REG_MVTENEN,
+    {  0x78,        0x4D }, // REG_MVTFSEQ,
+    {  0x68,        0x32 }, // REG_MDTV1,
+    {  0x68,        0x33 }, // REG_MDTV2,
+    {  0x78,        0x50 }, // REG_BIASEN,
+    {  0x78,        0x51 }, // REG_BIASFSEQ,
+    {  0x78,        0x52 }, // REG_BIASTV,
+    {  0x78,        0x54 }, // REG_VBUSEN,
+    {  0x78,        0x55 }, // REG_VBUSFSEQ,
+    {  0x78,        0x58 }, // REG_USBTXRXEN,
+    {  0x78,        0x59 }, // REG_USBTXRXFSEQ,
+
+    //========================================================
+    //  M A I N - B A T T E R Y   F A U L T   D E T E C T O R
+    //========================================================
+    /* Slave addr   Reg addr */
+    {  0x78,        0x60 }, // REG_LBCNFG,
+
+    //========================================================
+    //  O N / O F F   C O N T R O L L E R
+    //========================================================
+    /* Slave addr   Reg addr */
+    {  0x78,        0x00 }, // REG_EXTWKSEL,
+    {  0x78,        0x01 }, // REG_ON_OFF_IRQ,
+    {  0x78,        0x02 }, // REG_ON_OFF_IRQ_MASK,
+    {  0x78,        0x03 }, // REG_ON_OFF_STAT,
+
+    //========================================================
+    //  F L E X I B L E   P O W E R   S E Q U E N C E R
+    //========================================================
+    /* Slave addr   Reg addr */
+    {  0x78,        0x64 }, // REG_SEQ1CNFG,
+    {  0x78,        0x65 }, // REG_SEQ2CNFG,
+    {  0x78,        0x66 }, // REG_SEQ3CNFG,
+    {  0x78,        0x67 }, // REG_SEQ4CNFG,
+    {  0x78,        0x68 }, // REG_SEQ5CNFG,
+    {  0x78,        0x69 }, // REG_SEQ6CNFG,
+    {  0x78,        0x6A }, // REG_SEQ7CNFG,
+
+    //========================================================
+    //  U S B   T R A N S C E I V E R
+    //========================================================
+    /* Slave addr   Reg addr */
+    {  0x78,        0x6C }, // REG_USBCNFG,
+
+    //========================================================
+    //  T C X O   B U F F E R
+    //========================================================
+    /* Slave addr   Reg addr */
+    {  0x78,        0x74 }, // REG_TCXOCNFG,
+
+    //========================================================
+    //  R E F E R E N C E   O U T P U T (R E F O U T)
+    //========================================================
+    /* Slave addr   Reg addr */
+    {  0x78,        0x70 }, // REG_REFOUTCNFG,
+
+    //========================================================
+    //  R E A L   T I M E   C L O C K (R T C)
+    //========================================================
+    /* Slave addr   Reg addr */
+    {  0xD0,        0x00 }, // REG_RTC_SEC,
+    {  0xD0,        0x01 }, // REG_RTC_MIN,
+    {  0xD0,        0x02 }, // REG_RTC_HOURS,
+    {  0xD0,        0x03 }, // REG_RTC_WEEKDAY,
+    {  0xD0,        0x04 }, // REG_RTC_DATE,
+    {  0xD0,        0x05 }, // REG_RTC_MONTH,
+    {  0xD0,        0x06 }, // REG_RTC_YEAR1,
+    {  0xD0,        0x07 }, // REG_RTC_YEAR2,
+    {  0xD0,        0x08 }, // REG_ALARM0_SEC,
+    {  0xD0,        0x09 }, // REG_ALARM0_MIN,
+    {  0xD0,        0x0A }, // REG_ALARM0_HOURS,
+    {  0xD0,        0x0B }, // REG_ALARM0_WEEKDAY,
+    {  0xD0,        0x0C }, // REG_ALARM0_DATE,
+    {  0xD0,        0x0D }, // REG_ALARM0_MONTH,
+    {  0xD0,        0x0E }, // REG_ALARM0_YEAR1,
+    {  0xD0,        0x0F }, // REG_ALARM0_YEAR2,
+    {  0xD0,        0x10 }, // REG_ALARM1_SEC,
+    {  0xD0,        0x11 }, // REG_ALARM1_MIN,
+    {  0xD0,        0x12 }, // REG_ALARM1_HOURS,
+    {  0xD0,        0x13 }, // REG_ALARM1_WEEKDAY,
+    {  0xD0,        0x14 }, // REG_ALARM1_DATE,
+    {  0xD0,        0x15 }, // REG_ALARM1_MONTH,
+    {  0xD0,        0x16 }, // REG_ALARM1_YEAR1,
+    {  0xD0,        0x17 }, // REG_ALARM1_YEAR2,
+    {  0xD0,        0x18 }, // REG_ALARM0_CNTL,
+    {  0xD0,        0x19 }, // REG_ALARM1_CNTL,
+    {  0xD0,        0x1A }, // REG_RTC_STATUS,
+    {  0xD0,        0x1B }, // REG_RTC_CNTL,
+    {  0xD0,        0x1C }, // REG_RTC_IRQ,
+    {  0xD0,        0x1D }, // REG_RTC_IRQ_MASK,
+    {  0xD0,        0x1E }, // REG_MPL_CNTL,
+
+    //========================================================
+    //  T O U C H - S C R E E N / A D C   C O N T R O L L E R
+    //========================================================
+    /* Slave addr   Reg addr */
+    {  0x8E,        0x00 }, // REG_TSC_STA_INT,
+    {  0x8E,        0x01 }, // REG_TSC_INT_MASK,
+    {  0x8E,        0x02 }, // REG_TSC_CNFG1,
+    {  0x8E,        0x03 }, // REG_TSC_CNFG2,
+    {  0x8E,        0x04 }, // REG_TSC_CNFG3,
+    {  0x8E,        0x05 }, // REG_TSC_CNFG4,
+    {  0x8E,        0x06 }, // REG_TSC_RES_CNFG1,
+    {  0x8E,        0x07 }, // REG_TSC_AVG_CNFG1,
+    {  0x8E,        0x08 }, // REG_TSC_ACQ_CNFG1,
+    {  0x8E,        0x09 }, // REG_TSC_ACQ_CNFG2,
+    {  0x8E,        0x0A }, // REG_TSC_ACQ_CNFG3,
+    //========== ADC_RESULTS registers
+    {  0x8E,        0x50 }, // REG_ADC_X_MSB,
+    {  0x8E,        0x51 }, // REG_ADC_X_LSB,
+    {  0x8E,        0x52 }, // REG_ADC_Y_MSB,
+    {  0x8E,        0x53 }, // REG_ADC_Y_LSB,
+    {  0x8E,        0x54 }, // REG_ADC_Z1_MSB,
+    {  0x8E,        0x55 }, // REG_ADC_Z1_LSB,
+    {  0x8E,        0x56 }, // REG_ADC_Z2_MSB,
+    {  0x8E,        0x57 }, // REG_ADC_Z2_LSB,
+    {  0x8E,        0x60 }, // REG_ADC_AUX1_MSB,
+    {  0x8E,        0x61 }, // REG_ADC_AUX1_LSB,
+    {  0x8E,        0x62 }, // REG_ADC_VBUS_MSB,
+    {  0x8E,        0x63 }, // REG_ADC_VBUS_LSB,
+    {  0x8E,        0x64 }, // REG_ADC_VAC_MSB,
+    {  0x8E,        0x65 }, // REG_ADC_VAC_LSB,
+    {  0x8E,        0x66 }, // REG_ADC_MBATT_MSB,
+    {  0x8E,        0x67 }, // REG_ADC_MBATT_LSB,
+    {  0x8E,        0x68 }, // REG_ADC_BBATT_MSB,
+    {  0x8E,        0x69 }, // REG_ADC_BBATT_LSB,
+    {  0x8E,        0x6A }, // REG_ADC_ICHG_MSB,
+    {  0x8E,        0x6B }, // REG_ADC_ICHG_LSB,
+    {  0x8E,        0x6C }, // REG_ADC_TDIE_MSB,
+    {  0x8E,        0x6D }, // REG_ADC_TDIE_LSB,
+    {  0x8E,        0x6E }, // REG_ADC_AUX2_MSB,
+    {  0x8E,        0x6F }, // REG_ADC_AUX2_LSB,
+
+    // TOUCH-SCREEN CONVERSION COMMAND registers
+    {  0x8E,        0x80 }, // REG_TSC_X_Drive,
+    {  0x8E,        0x88 }, // REG_TSC_X_Measurement,
+    {  0x8E,        0x90 }, // REG_TSC_Y_Drive,
+    {  0x8E,        0x98 }, // REG_TSC_Y_Measurement,
+    {  0x8E,        0xA0 }, // REG_TSC_Z1_Drive,
+    {  0x8E,        0xA8 }, // REG_TSC_Z1_Measurement,
+    {  0x8E,        0xB0 }, // REG_TSC_Z2_Drive,
+    {  0x8E,        0xB8 }, // REG_TSC_Z2_Measurement,
+    {  0x8E,        0xC0 }, // REG_TSC_AUX1_Measurement,
+    {  0x8E,        0xC8 }, // REG_TSC_VBUS_Measurement,      
+    {  0x8E,        0xD0 }, // REG_TSC_VAC_Measurement,
+    {  0x8E,        0xD8 }, // REG_TSC_MBATT_Measurement,
+    {  0x8E,        0xE0 }, // REG_TSC_BBATT_Measurement,
+    {  0x8E,        0xE8 }, // REG_TSC_ICHG_Measurement,
+    {  0x8E,        0xF0 }, // REG_TSC_TDIE_Measurement,
+    {  0x8E,        0xF8 }, // REG_TSC_AUX2_Measurement,
+
+    //========================================================
+    //  A U D I O   S U B S Y S T E M
+    //========================================================
+    /* Slave addr   Reg addr */
+    {  0x78,        0x84 }, // REG_PGA_CNTL1,
+    {  0x78,        0x85 }, // REG_PGA_CNTL2,
+    {  0x78,        0x86 }, // REG_LMIX_CNTL,
+    {  0x78,        0x87 }, // REG_RMIX_CNTL,
+    {  0x78,        0x88 }, // REG_MMIX_CNTL,
+    {  0x78,        0x89 }, // REG_HS_RIGHT_GAIN_CNTL,
+    {  0x78,        0x8A }, // REG_HS_LEFT_GAIN_CNTL,
+    {  0x78,        0x8B }, // REG_LINE_OUT_GAIN_CNTL,
+    {  0x78,        0x8C }, // REG_LS_GAIN_CNTL,
+    {  0x78,        0x8D }, // REG_AUDIO_CNTL,
+    {  0x78,        0x8E }, // REG_AUDIO_ENABLE1,
+
+    //========================================================
+    //  C H I P   I D E N T I F I C A T I O N
+    //========================================================
+    /* Slave addr   Reg addr */
+    {  0x68,        0x8E }, // REG_II1RR,
+    {  0x68,        0x8F }, // REG_II2RR,
+    {  0x78,        0x98 } // REG_IRQ_STAT,
+};
+
+
+max8906_function_type  max8906pm[ENDOFPM] =
+{
+    //========================================================
+    //  B A T T E R Y   C H A R G E R S
+    //========================================================
+    // CHG_CNTL1 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x7C,       0x80,       0x7F,       0x07 }, // nCHGEN
+    {  0x78,       0x7C,       0x60,       0x9F,       0x05 }, // CHG_TOPOFF_TH
+    {  0x78,       0x7C,       0x18,       0xE7,       0x03 }, // CHG_RST_HYS
+    {  0x78,       0x7C,       0x07,       0xF8,       0x00 }, // AC_FCHG
+
+    // CHG_CNTL2 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x7D,       0xC0,       0x3F,       0x06 }, // VBUS_FCHG
+    {  0x78,       0x7D,       0x30,       0xCF,       0x04 }, // FCHG_TMR
+    {  0x78,       0x7D,       0x08,       0xF7,       0x03 }, // MBAT_REG_TH
+    {  0x78,       0x7D,       0x07,       0xF8,       0x00 }, // MBATT_THERM_REG
+
+    // CHG_IRQ1 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x7E,       0x80,       0x7F,       0x07 }, // VAC_R
+    {  0x78,       0x7E,       0x40,       0xBF,       0x06 }, // VAC_F
+    {  0x78,       0x7E,       0x20,       0xDF,       0x05 }, // VAC_OVP
+    {  0x78,       0x7E,       0x10,       0xEF,       0x04 }, // VBUS_R
+    {  0x78,       0x7E,       0x08,       0xF7,       0x03 }, // VBUS_F
+    {  0x78,       0x7E,       0x04,       0xFB,       0x02 }, // VBUS_OVP
+
+    // CHG_IRQ2 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x7F,       0x80,       0x7F,       0x07 }, // CHG_TMR_FAULT
+    {  0x78,       0x7F,       0x40,       0xBF,       0x06 }, // CHG_TOPOFF
+    {  0x78,       0x7F,       0x20,       0xDF,       0x05 }, // CHG_DONE
+    {  0x78,       0x7F,       0x10,       0xEF,       0x04 }, // CHG_RST
+    {  0x78,       0x7F,       0x08,       0xF7,       0x03 }, // MBATTLOWR
+    {  0x78,       0x7F,       0x04,       0xFB,       0x02 }, // MBATTLOWF
+
+    // CHG_IRQ1_MASK register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x80,       0x80,       0x7F,       0x07 }, // VAC_R_MASK
+    {  0x78,       0x80,       0x40,       0xBF,       0x06 }, // VAC_F_MASK
+    {  0x78,       0x80,       0x20,       0xDF,       0x05 }, // VAC_OVP_MASK
+    {  0x78,       0x80,       0x10,       0xEF,       0x04 }, // VBUS_R_MASK
+    {  0x78,       0x80,       0x08,       0xF7,       0x03 }, // VBUS_F_MASK
+    {  0x78,       0x80,       0x04,       0xFB,       0x02 }, // VBUS_OVP_MASK
+
+    // CHG_IRQ2_MASK register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x81,       0x80,       0x7F,       0x07 }, // CHG_TMR_FAULT_MASK
+    {  0x78,       0x81,       0x40,       0xBF,       0x06 }, // CHG_TOPOFF_MASK
+    {  0x78,       0x81,       0x20,       0xDF,       0x05 }, // CHG_DONE_MASK
+    {  0x78,       0x81,       0x10,       0xEF,       0x04 }, // CHG_RST_MASK
+    {  0x78,       0x81,       0x08,       0xF7,       0x03 }, // MBATTLOWR_MASK
+    {  0x78,       0x81,       0x04,       0xFB,       0x02 }, // MBATTLOWF_MASK
+
+    // CHG_STAT register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x82,       0x80,       0x7F,       0x07 }, // VAC_OK
+    {  0x78,       0x82,       0x40,       0xBF,       0x06 }, // VBUS_OK
+    {  0x78,       0x82,       0x20,       0xDF,       0x05 }, // CHG_TMR
+    {  0x78,       0x82,       0x10,       0xEF,       0x04 }, // CHG_EN_STAT
+    {  0x78,       0x82,       0x0C,       0xF3,       0x02 }, // CHG_MODE
+    {  0x78,       0x82,       0x02,       0xFD,       0x01 }, // MBATT_DET
+    {  0x78,       0x82,       0x01,       0xFE,       0x00 }, // MBATTLOW
+
+    // BBATTCNFG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x78,       0x80,       0x7F,       0x07 }, // APPALLOFF
+    {  0x78,       0x78,       0x03,       0xFC,       0x00 }, // VBBATTCV
+
+    //========================================================
+    //  S T E P - D O W N    R E G U L A T O R S
+    //========================================================
+    // WBBCOREEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x5C,       0x80,       0x7F,       0x07 }, // nWCRADE
+    {  0x78,       0x5C,       0x0E,       0xF1,       0x01 }, // WCRENSRC
+    {  0x78,       0x5C,       0x01,       0xFE,       0x00 }, // WCREN
+
+    // WBBCOREFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x5D,       0xF0,       0x0F,       0x04 }, // WCRFSEQPU
+    {  0x78,       0x5D,       0x0F,       0xF0,       0x00 }, // WCRFSEQPD
+
+    // WBBCORETV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x5E,       0x3F,       0xC0,       0x00 }, // WCRTV
+
+    // WBBRFEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x9C,       0x80,       0x7F,       0x07 }, // nWRFADE
+    {  0x78,       0x9C,       0x0E,       0xF1,       0x01 }, // WRFENSRC
+    {  0x78,       0x9C,       0x01,       0xFE,       0x00 }, // WRFEN
+
+    // WBBRFFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x9D,       0xF0,       0x0F,       0x04 }, // WRFFSEQPU
+    {  0x78,       0x9D,       0x0F,       0xF0,       0x00 }, // WRFFSEQPD
+
+    // WBBRFTV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x9E,       0x3F,       0xC0,       0x00 }, // WRFTV
+
+    // APPSEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x04,       0x80,       0x7F,       0x07 }, // nAPPSADE
+    {  0x78,       0x04,       0x10,       0xEF,       0x04 }, // nOVER1ENAPPS
+    {  0x78,       0x04,       0x0E,       0xF1,       0x01 }, // APPSENSRC
+    {  0x78,       0x04,       0x01,       0xFE,       0x00 }, // APPSEN
+
+    // OVER1 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x68,       0x10,       0x04,       0xFB,       0x02 }, // ENSRAM
+    {  0x68,       0x10,       0x01,       0xFE,       0x00 }, // ENAPPS
+
+    // APPSFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x05,       0xF0,       0x0F,       0x04 }, // APPSFSEQPU
+    {  0x78,       0x05,       0x0F,       0xF0,       0x00 }, // APPSFSEQPD
+
+    // ADTV1 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x68,       0x23,       0x80,       0x7F,       0x07 }, // T1AOST
+    {  0x68,       0x23,       0x3F,       0xC0,       0x00 }, // T1APPS
+
+    // ADTV2 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x68,       0x24,       0x80,       0x7F,       0x07 }, // T2AOST
+    {  0x68,       0x24,       0x3F,       0xC0,       0x00 }, // T2APPS
+
+    // APPSCLG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x06,       0x3F,       0xC0,       0x00 }, // CLGAPPS
+
+    // VCC1 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x68,       0x20,       0x80,       0x7F,       0x07 }, // MVS
+    {  0x68,       0x20,       0x40,       0xBF,       0x06 }, // MGO
+    {  0x68,       0x20,       0x20,       0xDF,       0x05 }, // SVS
+    {  0x68,       0x20,       0x10,       0xEF,       0x04 }, // SGO
+    {  0x68,       0x20,       0x02,       0xFD,       0x01 }, // AVS
+    {  0x68,       0x20,       0x01,       0xFE,       0x00 }, // AGO
+
+    // IOEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x08,       0x80,       0x7F,       0x07 }, // nIOADE
+    {  0x78,       0x08,       0x0E,       0xF1,       0x01 }, // IOENSRC
+    {  0x78,       0x08,       0x01,       0xFE,       0x00 }, // IOEN
+
+    // IOFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x09,       0xF0,       0x0F,       0x04 }, // IOFSEQPU
+    {  0x78,       0x09,       0x0F,       0xF0,       0x00 }, // IOFSEQPD
+
+    // MEMEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x0C,       0x80,       0x7F,       0x07 }, // nMEMADE
+    {  0x78, 	  0x0C, 	 0x30,	  0xCF,	  0x04 }, // MEMDVM
+    {  0x78,       0x0C,       0x0E,       0xF1,       0x01 }, // MEMENSRC
+    {  0x78,       0x0C,       0x01,       0xFE,       0x00 }, // MEMEN
+
+    // MEMFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x0D,       0xF0,       0x0F,       0x04 }, // MEMFSEQPU
+    {  0x78,       0x0D,       0x0F,       0xF0,       0x00 }, // MEMFSEQPD
+
+    //========================================================
+    //  L I N E A R   R E G U L A T O R S
+    //========================================================
+    // WBBMEMEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x10,       0x80,       0x7F,       0x07 }, // nWMEMADE
+    {  0x78,       0x10,       0x0E,       0xF1,       0x01 }, // WMEMENSRC
+    {  0x78,       0x10,       0x01,       0xFE,       0x00 }, // WMEMEN
+
+    // WBBMEMFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x11,       0xF0,       0x0F,       0x04 }, // WMEMFSEQPU
+    {  0x78,       0x11,       0x0F,       0xF0,       0x00 }, // WMEMFSEQPD
+
+    // WBBMEMTV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x12,       0x3F,       0xC0,       0x00 }, // WMEMTV
+
+    // WBBIOEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x14,       0x80,       0x7F,       0x07 }, // nWIOADE
+    {  0x78,       0x14,       0x10,       0xEF,       0x04 }, // SFTRSTWBB
+    {  0x78,       0x14,       0x0E,       0xF1,       0x01 }, // WIOENSRC
+    {  0x78,       0x14,       0x01,       0xFE,       0x00 }, // WIOEN
+
+    // WBBIOFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x15,       0xF0,       0x0F,       0x04 }, // WIOFSEQPU
+    {  0x78,       0x15,       0x0F,       0xF0,       0x00 }, // WIOFSEQPD
+
+    // WBBIOTV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x16,       0x3F,       0xC0,       0x00 }, // WIOTV
+
+    // WBBANAEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x18,       0x80,       0x7F,       0x07 }, // nWANAADE
+    {  0x78,       0x18,       0x0E,       0xF1,       0x01 }, // WANAENSRC
+    {  0x78,       0x18,       0x01,       0xFE,       0x00 }, // WANAEN
+
+    // WBBANAFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x19,       0xF0,       0x0F,       0x04 }, // WANAFSEQPU
+    {  0x78,       0x19,       0x0F,       0xF0,       0x00 }, // WANAFSEQPD
+
+    // WBBANATV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x1A,       0x3F,       0xC0,       0x00 }, // WANATV
+
+    // RFRXLEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x1C,       0x80,       0x7F,       0x07 }, // nRFRXLADE
+    {  0x78,       0x1C,       0x0E,       0xF1,       0x01 }, // RFRXLENSRC
+    {  0x78,       0x1C,       0x01,       0xFE,       0x00 }, // RFRXLEN
+
+    // RFRXLFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x1D,       0xF0,       0x0F,       0x04 }, // RFRXLFSEQPU
+    {  0x78,       0x1D,       0x0F,       0xF0,       0x00 }, // RFRXLFSEQPD
+
+    // RFRXLTV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x1E,       0x3F,       0xC0,       0x00 }, // RFRXLTV
+
+    // RFTXLEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x20,       0x80,       0x7F,       0x07 }, // nRFTXLADE
+    {  0x78,       0x20,       0x0E,       0xF1,       0x01 }, // RFTXLENSRC
+    {  0x78,       0x20,       0x01,       0xFE,       0x00 }, // RFTXLEN
+
+    // RFTXLFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x21,       0xF0,       0x0F,       0x04 }, // RFTXLFSEQPU
+    {  0x78,       0x21,       0x0F,       0xF0,       0x00 }, // RFTXLFSEQPD
+
+    // RFTXLTV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x22,       0x3F,       0xC0,       0x00 }, // RFTXLTV
+
+    // RFRXHEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x24,       0x80,       0x7F,       0x07 }, // nRFRXHADE
+    {  0x78,       0x24,       0x0E,       0xF1,       0x01 }, // RFRXHENSRC
+    {  0x78,       0x24,       0x01,       0xFE,       0x00 }, // RFRXHEN
+
+    // RFRXHFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x25,       0xF0,       0x0F,       0x04 }, // RFRXHFSEQPU
+    {  0x78,       0x25,       0x0F,       0xF0,       0x00 }, // RFRXHFSEQPD
+
+    // RFRXHTV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x26,       0x3F,       0xC0,       0x00 }, // RFRXHTV
+
+    // RFTCXOEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x28,       0x80,       0x7F,       0x07 }, // nRFTCXOADE
+    {  0x78,       0x28,       0x0E,       0xF1,       0x01 }, // RFTCXOENSRC
+    {  0x78,       0x28,       0x01,       0xFE,       0x00 }, // RFTCXOEN
+
+    // RFTCXOFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x29,       0xF0,       0x0F,       0x04 }, // RFTCXOFSEQPU
+    {  0x78,       0x29,       0x0F,       0xF0,       0x00 }, // RFTCXOFSEQPD
+
+    // RFTCXOTV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x2A,       0x3F,       0xC0,       0x00 }, // RFTCXOLTV
+
+    // LDOAEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x2C,       0x80,       0x7F,       0x07 }, // nLDOAADE
+    {  0x78,       0x2C,       0x0E,       0xF1,       0x01 }, // LDOAENSRC
+    {  0x78,       0x2C,       0x01,       0xFE,       0x00 }, // LDOAEN
+
+    // LDOAFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x2D,       0xF0,       0x0F,       0x04 }, // LDOAFSEQPU
+    {  0x78,       0x2D,       0x0F,       0xF0,       0x00 }, // LDOAFSEQPD
+
+    // LDOATV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x2E,       0x3F,       0xC0,       0x00 }, // LDOATV
+
+    // LDOBEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x30,       0x80,       0x7F,       0x07 }, // nLDOBADE
+    {  0x78,       0x30,       0x0E,       0xF1,       0x01 }, // LDOBENSRC
+    {  0x78,       0x30,       0x01,       0xFE,       0x00 }, // LDOBEN
+
+    // LDOBFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x31,       0xF0,       0x0F,       0x04 }, // LDOBFSEQPU
+    {  0x78,       0x31,       0x0F,       0xF0,       0x00 }, // LDOBFSEQPD
+
+    // LDOBTV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x32,       0x3F,       0xC0,       0x00 }, // LDOBTV
+
+    // LDOCEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x34,       0x80,       0x7F,       0x07 }, // nLDOCADE
+    {  0x78,       0x34,       0x0E,       0xF1,       0x01 }, // LDOCENSRC
+    {  0x78,       0x34,       0x01,       0xFE,       0x00 }, // LDOCEN
+
+    // LDOCFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x35,       0xF0,       0x0F,       0x04 }, // LDOCFSEQPU
+    {  0x78,       0x35,       0x0F,       0xF0,       0x00 }, // LDOCFSEQPD
+
+    // LDOCTV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x36,       0x3F,       0xC0,       0x00 }, // LDOCTV
+
+    // LDODEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x38,       0x80,       0x7F,       0x07 }, // nLDODADE
+    {  0x78,       0x38,       0x0E,       0xF1,       0x01 }, // LDODENSRC
+    {  0x78,       0x38,       0x01,       0xFE,       0x00 }, // LDODEN
+
+    // LDODFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x39,       0xF0,       0x0F,       0x04 }, // LDODFSEQPU
+    {  0x78,       0x39,       0x0F,       0xF0,       0x00 }, // LDODFSEQPD
+
+    // LDODTV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x3A,       0x3F,       0xC0,       0x00 }, // LDODTV
+
+    // SIMLTEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x3C,       0x80,       0x7F,       0x07 }, // nSIMLTADE
+    {  0x78,       0x3C,       0x0E,       0xF1,       0x01 }, // SIMLTENSRC
+    {  0x78,       0x3C,       0x01,       0xFE,       0x00 }, // SIMLTEN
+
+    // SIMLTFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x3D,       0xF0,       0x0F,       0x04 }, // SIMLTFSEQPU
+    {  0x78,       0x3D,       0x0F,       0xF0,       0x00 }, // SIMLTFSEQPD
+
+    // SIMLTTV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x3E,       0x3F,       0xC0,       0x00 }, // SIMLTTV
+
+    // SRAMEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x40,       0x80,       0x7F,       0x07 }, // nSRAMADE
+    {  0x78,       0x40,       0x10,       0xEF,       0x04 }, // nOVER1ENSRAM
+    {  0x78,       0x40,       0x0E,       0xF1,       0x01 }, // SRAMENSRC
+    {  0x78,       0x40,       0x01,       0xFE,       0x00 }, // SRAMEN
+
+    // SRAMFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x41,       0xF0,       0x0F,       0x04 }, // SRAMFSEQPU
+    {  0x78,       0x41,       0x0F,       0xF0,       0x00 }, // SRAMFSEQPD
+
+    // SDTV1 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x68,       0x29,       0x80,       0x7F,       0x07 }, // T1SOST
+    {  0x68,       0x29,       0x3F,       0xC0,       0x00 }, // T1SRAM
+
+    // SDTV2 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x68,       0x2A,       0x80,       0x7F,       0x07 }, // T2SOST
+    {  0x68,       0x2A,       0x3F,       0xC0,       0x00 }, // T2SRAM
+
+    // SRAMCLG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x42,       0x3F,       0xC0,       0x00 }, // CLGSRAM
+
+    // CARD1EN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x44,       0x80,       0x7F,       0x07 }, // nCARD1ADE
+    {  0x78,       0x44,       0x0E,       0xF1,       0x01 }, // CARD1ENSRC
+    {  0x78,       0x44,       0x01,       0xFE,       0x00 }, // CARD1EN
+
+    // CARD1FSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x45,       0xF0,       0x0F,       0x04 }, // CARD1FSEQPU
+    {  0x78,       0x45,       0x0F,       0xF0,       0x00 }, // CARD1FSEQPD
+
+    // CARD1TV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x46,       0x3F,       0xC0,       0x00 }, // CARD1TV
+
+    // CARD2EN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x48,       0x80,       0x7F,       0x07 }, // nCARD2ADE
+    {  0x78,       0x48,       0x0E,       0xF1,       0x01 }, // CARD2ENSRC
+    {  0x78,       0x48,       0x01,       0xFE,       0x00 }, // CARD2EN
+
+    // CARD2FSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x49,       0xF0,       0x0F,       0x04 }, // CARD2FSEQPU
+    {  0x78,       0x49,       0x0F,       0xF0,       0x00 }, // CARD2FSEQPD
+
+    // CARD2TV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x4A,       0x3F,       0xC0,       0x00 }, // CARD2TV
+
+    // MVTENEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x4C,       0x80,       0x7F,       0x07 }, // nMVTADE
+    {  0x78,       0x4C,       0x0E,       0xF1,       0x01 }, // MVTENSRC
+    {  0x78,       0x4C,       0x01,       0xFE,       0x00 }, // MVTEN
+
+    // MVTFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x4D,       0xF0,       0x0F,       0x04 }, // MVTFSEQPU
+    {  0x78,       0x4D,       0x0F,       0xF0,       0x00 }, // MVTFSEQPD
+
+    // MDTV1 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x32,       0x0F,       0xF0,       0x00 }, // T1MVT
+
+    // MDTV2 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x33,       0x0F,       0xF0,       0x00 }, // T2MVT
+
+    // BIASEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x50,       0x80,       0x7F,       0x07 }, // nBIASADE
+    {  0x78,       0x50,       0x0E,       0xF1,       0x01 }, // BIASENSRC
+    {  0x78,       0x50,       0x01,       0xFE,       0x00 }, // BIASEN
+
+    // BIASFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x51,       0xF0,       0x0F,       0x04 }, // BIASFSEQPU
+    {  0x78,       0x51,       0x0F,       0xF0,       0x00 }, // BIASFSEQPD
+
+    // BIASTV register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x52,       0x3F,       0xC0,       0x00 }, // BIASTV
+
+    // VBUSEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x54,       0x80,       0x7F,       0x07 }, // nVBUSADE
+    {  0x78,       0x54,       0x10,       0xEF,       0x04 }, // VBUSVINEN
+    {  0x78,       0x54,       0x0E,       0xF1,       0x01 }, // VBUSENSRC
+    {  0x78,       0x54,       0x01,       0xFE,       0x00 }, // VBUSEN
+
+    // VBUSFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x55,       0xF0,       0x0F,       0x04 }, // VBUSFSEQPU
+    {  0x78,       0x55,       0x0F,       0xF0,       0x00 }, // VBUSFSEQPD
+
+    // USBTXRXEN register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x58,       0x80,       0x7F,       0x07 }, // nUSBTXRXADE
+    {  0x78,       0x58,       0x10,       0xEF,       0x04 }, // USBTXRXVINEN
+    {  0x78,       0x58,       0x0E,       0xF1,       0x01 }, // USBTXRXENSRC
+    {  0x78,       0x58,       0x01,       0xFE,       0x00 }, // USBTXRXEN
+
+    // USBTXRXFSEQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x59,       0xF0,       0x0F,       0x04 }, // USBTXRXFSEQPU
+    {  0x78,       0x59,       0x0F,       0xF0,       0x00 }, // USBTXRXFSEQPD
+
+    //========================================================
+    //  M A I N - B A T T E R Y   F A U L T   D E T E C T O R
+    //========================================================
+    // LBCNFG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x60,       0x30,       0xCF,       0x04 }, // LHYST
+    {  0x78,       0x60,       0x0E,       0xF1,       0x01 }, // LBDAC
+    {  0x78,       0x60,       0x01,       0xFE,       0x00 }, // LBEN
+
+    //========================================================
+    //  O N / O F F   C O N T R O L L E R
+    //========================================================
+    // EXTWKSEL register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x00,       0x80,       0x7F,       0x07 }, // HRDRSTEN
+    {  0x78,       0x00,       0x10,       0xEF,       0x04 }, // WKVBUS
+    {  0x78,       0x00,       0x08,       0xF7,       0x03 }, // WKVAC
+    {  0x78,       0x00,       0x04,       0xFB,       0x02 }, // WKALRM1R
+    {  0x78,       0x00,       0x02,       0xFD,       0x01 }, // WKALRM0R
+    {  0x78,       0x00,       0x01,       0xFE,       0x00 }, // WKSW
+
+    // ON_OFF_IRQ register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x01,       0x80,       0x7F,       0x07 }, // SW_R
+    {  0x78,       0x01,       0x40,       0xBF,       0x06 }, // SW_F
+    {  0x78,       0x01,       0x20,       0xDF,       0x05 }, // SW_1SEC
+    {  0x78,       0x01,       0x10,       0xEF,       0x04 }, // JIG_R
+    {  0x78,       0x01,       0x08,       0xF7,       0x03 }, // JIG_F
+    {  0x78,       0x01,       0x04,       0xFB,       0x02 }, // SW_3SEC
+    {  0x78,       0x01,       0x02,       0xFD,       0x01 }, // MPL_EVENT
+
+    // ON_OFF_IRQ_MASK register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x02,       0x80,       0x7F,       0x07 }, // SW_R_MASK
+    {  0x78,       0x02,       0x40,       0xBF,       0x06 }, // SW_F_MASK
+    {  0x78,       0x02,       0x20,       0xDF,       0x05 }, // SW_1SEC_MASK
+    {  0x78,       0x02,       0x10,       0xEF,       0x04 }, // JIG_R_MASK
+    {  0x78,       0x02,       0x08,       0xF7,       0x03 }, // JIG_F_MASK
+    {  0x78,       0x02,       0x04,       0xFB,       0x02 }, // SW_3SEC_MASK
+    {  0x78,       0x02,       0x02,       0xFD,       0x01 }, // MPL_EVENT_MASK
+
+    // ON_OFF_STAT register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x03,       0x80,       0x7F,       0x07 }, // SW
+    {  0x78,       0x03,       0x40,       0xBF,       0x06 }, // SW_1SEC
+    {  0x78,       0x03,       0x20,       0xDF,       0x05 }, // JIG
+    {  0x78,       0x03,       0x10,       0xEF,       0x04 }, // SW_3SEC
+
+    //========================================================
+    //  F L E X I B L E   P O W E R   S E Q U E N C E R
+    //========================================================
+    // SEQ1CNFG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x64,       0x38,       0xC7,       0x03 }, // SEQ1T
+    {  0x78,       0x64,       0x06,       0xF9,       0x01 }, // SEQ1SRC
+    {  0x78,       0x64,       0x01,       0xFE,       0x00 }, // SEQ1EN
+
+    // SEQ2CNFG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x65,       0x38,       0xC7,       0x03 }, // SEQ2T
+    {  0x78,       0x65,       0x06,       0xF9,       0x01 }, // SEQ2SRC
+    {  0x78,       0x65,       0x01,       0xFE,       0x00 }, // SEQ2EN
+
+    // SEQ3CNFG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x66,       0x38,       0xC7,       0x03 }, // SEQ3T
+    {  0x78,       0x66,       0x06,       0xF9,       0x01 }, // SEQ3SRC
+    {  0x78,       0x66,       0x01,       0xFE,       0x00 }, // SEQ3EN
+
+    // SEQ4CNFG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x67,       0x38,       0xC7,       0x03 }, // SEQ4T
+    {  0x78,       0x67,       0x06,       0xF9,       0x01 }, // SEQ4SRC
+    {  0x78,       0x67,       0x01,       0xFE,       0x00 }, // SEQ4EN
+
+    // SEQ5CNFG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x68,       0x38,       0xC7,       0x03 }, // SEQ5T
+    {  0x78,       0x68,       0x06,       0xF9,       0x01 }, // SEQ5SRC
+    {  0x78,       0x68,       0x01,       0xFE,       0x00 }, // SEQ5EN
+
+    // SEQ6CNFG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x69,       0x38,       0xC7,       0x03 }, // SEQ6T
+    {  0x78,       0x69,       0x06,       0xF9,       0x01 }, // SEQ6SRC
+    {  0x78,       0x69,       0x01,       0xFE,       0x00 }, // SEQ6EN
+
+    // SEQ7CNFG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x6A,       0x38,       0xC7,       0x03 }, // SEQ7T
+    {  0x78,       0x6A,       0x06,       0xF9,       0x01 }, // SEQ7SRC
+    {  0x78,       0x6A,       0x01,       0xFE,       0x00 }, // SEQ7EN
+
+    //========================================================
+    //  U S B   T R A N S C E I V E R
+    //========================================================
+    // USBCNFG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x6C,       0x30,       0xCF,       0x04 }, // USB_PU_EN
+    {  0x78,       0x6C,       0x08,       0xF7,       0x03 }, // USB_SUSP
+    {  0x78,       0x6C,       0x06,       0xF9,       0x01 }, // USB_EN
+
+    //========================================================
+    //  T C X O   B U F F E R
+    //========================================================
+    // TCXOCNFG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x74,       0x01,       0xFE,       0x00 }, // TCXOEN
+
+    //========================================================
+    //  R E F E R E N C E   O U T P U T (R E F O U T)
+    //========================================================
+    // REFOUTCNFG register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x70,       0x01,       0xFE,       0x00 }, // REFOUTEN
+
+    //========================================================
+    //  R E A L   T I M E   C L O C K (R T C)
+    //========================================================
+    // R T C registers
+    /* slave addr  addr        mask        clear       shift */
+    {  0xD0,       0x00,       0x0F,       0xF0,       0x00 }, // RTC_SEC,
+    {  0xD0,       0x00,       0x70,       0x8F,       0x04 }, // RTC_10SEC,
+    {  0xD0,       0x01,       0x0F,       0xF0,       0x00 }, // RTC_MIN,
+    {  0xD0,       0x01,       0x70,       0x8F,       0x04 }, // RTC_10MIN,
+    {  0xD0,       0x02,       0x0F,       0xF0,       0x00 }, // RTC_HOURS,
+    {  0xD0,       0x02,       0x30,       0xCF,       0x04 }, // RTC_10HOURS,
+    {  0xD0,       0x02,       0x80,       0x7F,       0x07 }, // RTC_12_n24,
+    {  0xD0,       0x03,       0x07,       0xF8,       0x00 }, // RTC_WEEKDAY,
+    {  0xD0,       0x04,       0x0F,       0xF0,       0x00 }, // RTC_DATE,
+    {  0xD0,       0x04,       0x30,       0xCF,       0x04 }, // RTC_10DATE,
+    {  0xD0,       0x05,       0x0F,       0xF0,       0x00 }, // RTC_MONTH,
+    {  0xD0,       0x05,       0x10,       0xEF,       0x04 }, // RTC_10MONTH,
+    {  0xD0,       0x06,       0x0F,       0xF0,       0x00 }, // RTC_YEAR,
+    {  0xD0,       0x06,       0xF0,       0x0F,       0x04 }, // RTC_10YEAR,
+    {  0xD0,       0x07,       0x0F,       0xF0,       0x00 }, // RTC_100YEAR,
+    {  0xD0,       0x07,       0xF0,       0x0F,       0x04 }, // RTC_1000YEAR,
+
+    // ALARM0 registers
+    /* slave addr  addr        mask        clear       shift */
+    {  0xD0,       0x08,       0x0F,       0xF0,       0x00 }, // ALARM0_SEC,
+    {  0xD0,       0x08,       0x70,       0x8F,       0x04 }, // ALARM0_10SEC,
+    {  0xD0,       0x09,       0x0F,       0xF0,       0x00 }, // ALARM0_MIN,
+    {  0xD0,       0x09,       0x70,       0x8F,       0x04 }, // ALARM0_10MIN,
+    {  0xD0,       0x0A,       0x0F,       0xF0,       0x00 }, // ALARM0_HOURS,
+    {  0xD0,       0x0A,       0x30,       0xCF,       0x04 }, // ALARM0_10HOURS,
+    {  0xD0,       0x0A,       0x80,       0x7F,       0x07 }, // ALARM0_12_n24,
+    {  0xD0,       0x0B,       0x07,       0xF8,       0x00 }, // ALARM0_WEEKDAY,
+    {  0xD0,       0x0C,       0x0F,       0xF0,       0x00 }, // ALARM0_DATE,
+    {  0xD0,       0x0C,       0x30,       0xCF,       0x04 }, // ALARM0_10DATE,
+    {  0xD0,       0x0D,       0x0F,       0xF0,       0x00 }, // ALARM0_MONTH,
+    {  0xD0,       0x0D,       0x10,       0xEF,       0x04 }, // ALARM0_10MONTH,
+    {  0xD0,       0x0E,       0x0F,       0xF0,       0x00 }, // ALARM0_YEAR,
+    {  0xD0,       0x0E,       0xF0,       0x0F,       0x04 }, // ALARM0_10YEAR,
+    {  0xD0,       0x0F,       0x0F,       0xF0,       0x00 }, // ALARM0_100YEAR,
+    {  0xD0,       0x0F,       0xF0,       0x0F,       0x04 }, // ALARM0_1000YEAR,
+
+    // ALARM1 registers
+    /* slave addr  addr        mask        clear       shift */
+    {  0xD0,       0x10,       0x0F,       0xF0,       0x00 }, // ALARM1_SEC,
+    {  0xD0,       0x10,       0x70,       0x8F,       0x04 }, // ALARM1_10SEC,
+    {  0xD0,       0x11,       0x0F,       0xF0,       0x00 }, // ALARM1_MIN,
+    {  0xD0,       0x11,       0x70,       0x8F,       0x04 }, // ALARM1_10MIN,
+    {  0xD0,       0x12,       0x0F,       0xF0,       0x00 }, // ALARM1_HOURS,
+    {  0xD0,       0x12,       0x30,       0xCF,       0x04 }, // ALARM1_10HOURS,
+    {  0xD0,       0x12,       0x80,       0x7F,       0x07 }, // ALARM1_12_n24,
+    {  0xD0,       0x13,       0x07,       0xF8,       0x00 }, // ALARM1_WEEKDAY,
+    {  0xD0,       0x14,       0x0F,       0xF0,       0x00 }, // ALARM1_DATE,
+    {  0xD0,       0x14,       0x30,       0xCF,       0x04 }, // ALARM1_10DATE,
+    {  0xD0,       0x15,       0x0F,       0xF0,       0x00 }, // ALARM1_MONTH,
+    {  0xD0,       0x15,       0x10,       0xEF,       0x04 }, // ALARM1_10MONTH,
+    {  0xD0,       0x16,       0x0F,       0xF0,       0x00 }, // ALARM1_YEAR,
+    {  0xD0,       0x16,       0xF0,       0x0F,       0x04 }, // ALARM1_10YEAR,
+    {  0xD0,       0x17,       0x0F,       0xF0,       0x00 }, // ALARM1_100YEAR,
+    {  0xD0,       0x17,       0xF0,       0x0F,       0x04 }, // ALARM1_1000YEAR,
+
+    // ALARM0_CNTL register
+    /* slave addr  addr        mask        clear       shift */
+    {  0xD0,       0x18,       0xFF,       0x00,       0x00 }, // ALARM0_CNTL,
+
+    // ALARM1_CNTL register
+    /* slave addr  addr        mask        clear       shift */
+    {  0xD0,       0x19,       0xFF,       0x00,       0x00 }, // ALARM1_CNTL,
+
+    // RTC_STATUS register
+    {  0xD0,       0x1A,       0x80,       0x7F,       0x07 }, // RTC_STATUS_DIV_OK,       
+    {  0xD0,       0x1A,       0x40,       0xBF,       0x06 }, // RTC_STATUS_LEAP_OK,      
+    {  0xD0,       0x1A,       0x20,       0xDF,       0x05 }, // RTC_STATUS_MON_OK,       
+    {  0xD0,       0x1A,       0x10,       0xEF,       0x04 }, // RTC_STATUS_CARY_OK,      
+    {  0xD0,       0x1A,       0x08,       0xF7,       0x03 }, // RTC_STATUS_REG_OK,       
+    {  0xD0,       0x1A,       0x04,       0xFB,       0x02 }, // RTC_STATUS_ALARM0,       
+    {  0xD0,       0x1A,       0x02,       0xFD,       0x01 }, // RTC_STATUS_ALARM1,       
+    {  0xD0,       0x1A,       0x01,       0xFE,       0x00 }, // RTC_STATUS_XTAL_FLT,     
+
+    // RTC_CNTL register
+    {  0xD0,       0x1B,       0x20,       0xDF,       0x05 }, // RTC_CNTL_ALARM_WP,       
+    {  0xD0,       0x1B,       0x10,       0xEF,       0x04 }, // RTC_CNTL_RTC_WP,      
+    {  0xD0,       0x1B,       0x08,       0xF7,       0x03 }, // RTC_CNTL_nTCLKWBB_EN,       
+    {  0xD0,       0x1B,       0x02,       0xFD,       0x01 }, // RTC_CNTL_nTCLKAP_EN,       
+    {  0xD0,       0x1B,       0x01,       0xFE,       0x00 }, // RTC_CNTL_nRTC_EN,     
+
+    // RTC_IRQ register
+    {  0xD0,       0x1C,       0x08,       0xF7,       0x03 }, // ALARM0_R,       
+    {  0xD0,       0x1C,       0x04,       0xFB,       0x02 }, // ALARM1_R,       
+
+    // RTC_IRQ_MASK register
+    {  0xD0,       0x1D,       0x08,       0xF7,       0x03 }, // ALARM0_R_MASK,       
+    {  0xD0,       0x1D,       0x04,       0xFB,       0x02 }, // ALARM1_R_MASK,       
+
+    // MPL_CNTL register
+    {  0xD0,       0x1E,       0x10,       0xEF,       0x04 }, // EN_MPL,       
+    {  0xD0,       0x1E,       0x0C,       0xF3,       0x02 }, // TIME_MPL,       
+
+    {  0x1E,      0x40,       0xBF,       0x06 }, // WTSR_SMPL_CNTL_EN_WTSR,  
+    {  0x1E,      0x10,       0xEF,       0x04 }, // WTSR_SMPL_CNTL_EN_SMPL,  
+    {  0x1E,      0x0C,       0xF3,       0x02 }, // WTSR_SMPL_CNTL_TIME_SMPL,
+    {  0x1E,      0x03,       0xFC,       0x00 }, // WTSR_SMPL_CNTL_TIME_WTSR,
+
+    //========================================================
+    //  T O U C H - S C R E E N / A D C   C O N T R O L L E R
+    //========================================================
+    // TSC_STA_INT register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x8E,       0x00,       0x10,       0xEF,       0x04 }, // nREF_OK
+    {  0x8E,       0x00,       0x08,       0xF7,       0x03 }, // nCONV_NS
+    {  0x8E,       0x00,       0x04,       0xFB,       0x02 }, // CONV_S
+    {  0x8E,       0x00,       0x02,       0xFD,       0x01 }, // nTS_NS
+    {  0x8E,       0x00,       0x01,       0xFE,       0x00 }, // nTS_S
+
+    // TSC_INT_MASK register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x8E,       0x01,       0x08,       0xF7,       0x03 }, // nCONV_NS_M
+    {  0x8E,       0x01,       0x04,       0xFB,       0x02 }, // CONV_S_M
+    {  0x8E,       0x01,       0x02,       0xFD,       0x01 }, // nTS_NS_M
+    {  0x8E,       0x01,       0x01,       0xFE,       0x00 }, // nTS_S_M
+
+    // TSC_CNFG1 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x8E,       0x02,       0x80,       0x7F,       0x07 }, // PU_100_50
+    {  0x8E,       0x02,       0x10,       0xEF,       0x04 }, // Four_Wire_CNFG
+    {  0x8E,       0x02,       0x03,       0xFC,       0x00 }, // REF_CNFG
+
+    // TSC_CNFG2 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x8E,       0x03,       0x80,       0x7F,       0x07 }, // RES_X
+    {  0x8E,       0x03,       0x40,       0xBF,       0x06 }, // RES_Y
+    {  0x8E,       0x03,       0x20,       0xDF,       0x05 }, // RES_Z1
+    {  0x8E,       0x03,       0x10,       0xEF,       0x04 }, // RES_Z2
+    {  0x8E,       0x03,       0x08,       0xF7,       0x03 }, // AVG-X
+    {  0x8E,       0x03,       0x04,       0xFB,       0x02 }, // AVG_Y
+    {  0x8E,       0x03,       0x02,       0xFD,       0x01 }, // AVG_Z1
+    {  0x8E,       0x03,       0x01,       0xFE,       0x00 }, // AVG_Z2
+
+    // TSC_CNFG3 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x8E,       0x04,       0xC0,       0x3F,       0x06 }, // T_ACQ_X
+    {  0x8E,       0x04,       0x30,       0xCF,       0x04 }, // T_ACQ_Y
+    {  0x8E,       0x04,       0x0C,       0xF3,       0x02 }, // T_ACQ_Z1
+    {  0x8E,       0x04,       0x03,       0xFC,       0x00 }, // T_ACQ_Z2
+
+    // TSC_CNFG4 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x8E,       0x05,       0x08,       0xF7,       0x03 }, // D_CV_X
+    {  0x8E,       0x05,       0x04,       0xFB,       0x02 }, // D_CV_Y
+    {  0x8E,       0x05,       0x02,       0xFD,       0x01 }, // D_CV_Z1
+    {  0x8E,       0x05,       0x01,       0xFE,       0x00 }, // D_CV-Z2
+
+    // TSC_RES_CNFG1 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x8E,       0x06,       0x80,       0x7F,       0x07 }, // RES_AUX1
+    {  0x8E,       0x06,       0x40,       0xBF,       0x06 }, // RES_VBUS
+    {  0x8E,       0x06,       0x20,       0xDF,       0x05 }, // RES_VAC
+    {  0x8E,       0x06,       0x10,       0xEF,       0x04 }, // RES_MBATT
+    {  0x8E,       0x06,       0x08,       0xF7,       0x03 }, // RES_BBATT
+    {  0x8E,       0x06,       0x04,       0xFB,       0x02 }, // RES_ICHG
+    {  0x8E,       0x06,       0x02,       0xFD,       0x01 }, // RES_TDIE
+    {  0x8E,       0x06,       0x01,       0xFE,       0x00 }, // RES_AUX2
+
+    // TSC_AVG_CNFG1 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x8E,       0x07,       0x80,       0x7F,       0x07 }, // AVG_AUX1
+    {  0x8E,       0x07,       0x40,       0xBF,       0x06 }, // AVG_VBUS
+    {  0x8E,       0x07,       0x20,       0xDF,       0x05 }, // AVG_VAC
+    {  0x8E,       0x07,       0x10,       0xEF,       0x04 }, // AVG_MBATT
+    {  0x8E,       0x07,       0x08,       0xF7,       0x03 }, // AVG_BBATT
+    {  0x8E,       0x07,       0x04,       0xFB,       0x02 }, // AVG_ICHG
+    {  0x8E,       0x07,       0x02,       0xFD,       0x01 }, // AVG_TDIE
+    {  0x8E,       0x07,       0x01,       0xFE,       0x00 }, // AVG_AUX2
+
+    // TSC_ACQ_CNFG1 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x8E,       0x08,       0xC0,       0x3F,       0x06 }, // T_ACQ_AUX1
+    {  0x8E,       0x08,       0x30,       0xCF,       0x04 }, // T_ACQ_VBUS
+    {  0x8E,       0x08,       0x0C,       0xF3,       0x02 }, // T_ACQ_VAC
+    {  0x8E,       0x08,       0x03,       0xFC,       0x00 }, // T_ACQ_MBATT
+
+    // TSC_ACQ_CNFG2 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x8E,       0x09,       0xC0,       0x3F,       0x06 }, // T_ACQ_BBATT
+    {  0x8E,       0x09,       0x30,       0xCF,       0x04 }, // T_ACQ_ICHG
+    {  0x8E,       0x09,       0x0C,       0xF3,       0x02 }, // T_ACQ_TDIE
+    {  0x8E,       0x09,       0x03,       0xFC,       0x00 }, // T_ACQ_AUX2
+
+    // TSC_ACQ_CNFG3 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x8E,       0x0A,       0x80,       0x7F,       0x07 }, // D_CV_AUX1
+    {  0x8E,       0x0A,       0x40,       0xBF,       0x06 }, // D_CV_VBUS
+    {  0x8E,       0x0A,       0x20,       0xDF,       0x05 }, // D_CV_VAC
+    {  0x8E,       0x0A,       0x10,       0xEF,       0x04 }, // D_CV_MBATT
+    {  0x8E,       0x0A,       0x08,       0xF7,       0x03 }, // D_CV_BBATT
+    {  0x8E,       0x0A,       0x04,       0xFB,       0x02 }, // D_CV_ICHG
+    {  0x8E,       0x0A,       0x02,       0xFD,       0x01 }, // D_CV_TDIE
+    {  0x8E,       0x0A,       0x01,       0xFE,       0x00 }, // D_CV_AUX2
+
+    // ADC_RESULTS register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x8E,       0x50,       0xFF,       0x00,       0x00 }, // X_MSB
+    {  0x8E,       0x51,       0xF0,       0x0F,       0x04 }, // X_LSB
+    {  0x8E,       0x52,       0xFF,       0x00,       0x00 }, // Y_MSB
+    {  0x8E,       0x53,       0xF0,       0x0F,       0x04 }, // Y_LSB
+    {  0x8E,       0x54,       0xFF,       0x00,       0x00 }, // Z1_MSB
+    {  0x8E,       0x55,       0xF0,       0x0F,       0x04 }, // Z1_LSB
+    {  0x8E,       0x56,       0xFF,       0x00,       0x00 }, // Z2_MSB
+    {  0x8E,       0x57,       0xF0,       0x0F,       0x04 }, // Z2_LSB
+    {  0x8E,       0x60,       0xFF,       0x00,       0x00 }, // AUX1_MSB
+    {  0x8E,       0x61,       0xF0,       0x0F,       0x04 }, // AUX1_LSB
+    {  0x8E,       0x62,       0xFF,       0x00,       0x00 }, // VBUS_MSB
+    {  0x8E,       0x63,       0xF0,       0x0F,       0x04 }, // VBUS_LSB
+    {  0x8E,       0x64,       0xFF,       0x00,       0x00 }, // VAC_MSB
+    {  0x8E,       0x65,       0xF0,       0x0F,       0x04 }, // VAC_LSB
+    {  0x8E,       0x66,       0xFF,       0x00,       0x00 }, // MBATT_MSB
+    {  0x8E,       0x67,       0xF0,       0x0F,       0x04 }, // MBATT_LSB
+    {  0x8E,       0x68,       0xFF,       0x00,       0x00 }, // BBATT_MSB
+    {  0x8E,       0x69,       0xF0,       0x0F,       0x04 }, // BBATT_LSB
+    {  0x8E,       0x6A,       0xFF,       0x00,       0x00 }, // ICHG_MSB
+    {  0x8E,       0x6B,       0xF0,       0x0F,       0x04 }, // ICHG_LSB
+    {  0x8E,       0x6C,       0xFF,       0x00,       0x00 }, // TDIE_MSB
+    {  0x8E,       0x6D,       0xF0,       0x0F,       0x04 }, // TDIE_LSB
+    {  0x8E,       0x6E,       0xFF,       0x00,       0x00 }, // AUX2_MSB
+    {  0x8E,       0x6F,       0xF0,       0x0F,       0x04 }, // AUX2_LSB
+
+    // TOUCH-SCREEN CONVERSION COMMAND register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x8E,       0x80,       0x07,       0xF8,       0x00 }, // X_Drive
+    {  0x8E,       0x88,       0x07,       0xF8,       0x00 }, // X_Measurement
+    {  0x8E,       0x90,       0x07,       0xF8,       0x00 }, // Y_Drive      
+    {  0x8E,       0x98,       0x07,       0xF8,       0x00 }, // Y_Measurement
+    {  0x8E,       0xA0,       0x07,       0xF8,       0x00 }, // Z1_Drive      
+    {  0x8E,       0xA8,       0x07,       0xF8,       0x00 }, // Z1_Measurement
+    {  0x8E,       0xB0,       0x07,       0xF8,       0x00 }, // Z2_Drive      
+    {  0x8E,       0xB8,       0x07,       0xF8,       0x00 }, // Z2_Measurement
+    {  0x8E,       0xC0,       0x07,       0xF8,       0x00 }, // AUX1_Measurement      
+    {  0x8E,       0xC8,       0x07,       0xF8,       0x00 }, // VBUS_Measurement
+    {  0x8E,       0xD0,       0x07,       0xF8,       0x00 }, // VAC_Measurement      
+    {  0x8E,       0xD8,       0x07,       0xF8,       0x00 }, // MBATT_Measurement
+    {  0x8E,       0xE0,       0x07,       0xF8,       0x00 }, // BBATT_Measurement      
+    {  0x8E,       0xE8,       0x07,       0xF8,       0x00 }, // ICHG_Measurement
+    {  0x8E,       0xF0,       0x07,       0xF8,       0x00 }, // TDIE_Measurement      
+    {  0x8E,       0xF8,       0x07,       0xF8,       0x00 }, // AUX2_Measurement
+
+    //========================================================
+    //  A U D I O   S U B S Y S T E M
+    //========================================================
+    // PGA_CNTL1 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x84,       0xC0,       0x3F,       0x06 }, // VOICE_PGA_CNTL_P
+    {  0x78,       0x84,       0x30,       0xCF,       0x04 }, // VOICE_PGA_CNTL_N
+    {  0x78,       0x84,       0x08,       0xF7,       0x03 }, // VOICE_IN_CONFIG
+    {  0x78,       0x84,       0x03,       0xFC,       0x00 }, // IN1_PGA_CNTL
+
+    // PGA_CNTL2 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x85,       0xC0,       0x3F,       0x06 }, // IN2_PGA_CNTL
+    {  0x78,       0x85,       0x30,       0xCF,       0x04 }, // IN3_PGA_CNTL
+    {  0x78,       0x85,       0x0A,       0xF5,       0x01 }, // IN4_PGA_CNTL
+    {  0x78,       0x85,       0x01,       0xFE,       0x00 }, // ZDC
+
+    // LMIX_CNTL register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x86,       0x20,       0xDF,       0x05 }, // VOICE_IN_P_LMIX
+    {  0x78,       0x86,       0x10,       0xEF,       0x04 }, // VOICE_IN_N_LMIX
+    {  0x78,       0x86,       0x08,       0xF7,       0x03 }, // IN1_LMIX
+    {  0x78,       0x86,       0x04,       0xFB,       0x02 }, // IN2_LMIX
+    {  0x78,       0x86,       0x02,       0xFD,       0x01 }, // IN3_LMIX
+    {  0x78,       0x86,       0x01,       0xFE,       0x00 }, // IN4_LMIX
+
+    // RMIX_CNTL register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x87,       0x20,       0xDF,       0x05 }, // VOICE_IN_P_RMIX
+    {  0x78,       0x87,       0x10,       0xEF,       0x04 }, // VOICE_IN_N_RMIX
+    {  0x78,       0x87,       0x08,       0xF7,       0x03 }, // IN1_RMIX
+    {  0x78,       0x87,       0x04,       0xFB,       0x02 }, // IN2_RMIX
+    {  0x78,       0x87,       0x02,       0xFD,       0x01 }, // IN3_RMIX
+    {  0x78,       0x87,       0x01,       0xFE,       0x00 }, // IN4_RMIX
+
+    // MMIX_CNTL register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x88,       0x03,       0xFC,       0x00 }, // MONO_MIX_CNTL
+
+    // HS_RIGHT_GAIN_CNTL register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x89,       0x1F,       0xE0,       0x00 }, // RIGHT_HS_GAIN
+
+    // HS_LEFT_GAIN_CNTL register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x8A,       0x1F,       0xE0,       0x00 }, // LEFT_HS_GAIN
+
+    // LINE_OUT_GAIN_CNTL register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x8B,       0x1F,       0xE0,       0x00 }, // LINE_OUT_GAIN
+
+    // LS_GAIN_CNTL register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x8C,       0x1F,       0xE0,       0x00 }, // LS_GAIN
+
+    // AUDIO_CNTL register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x8D,       0x80,       0x7F,       0x07 }, // MUTE
+    {  0x78,       0x8D,       0x40,       0xBF,       0x06 }, // AUDIO_SHDN
+    //{  0x78,       0x8D,       0x20,       0xDF,       0x05 }, // LS_BP_EN
+    {  0x78,       0x8D,       0x10,       0xEF,       0x04 }, // AMP_EN_CNTL
+    {  0x78,       0x8D,       0x0C,       0xF3,       0x02 }, // CLASS_D_OSC_CNTL
+    {  0x78,       0x8D,       0x02,       0xFD,       0x01 }, // HS_MONO_SW
+
+    // AUDIO_ENABLE1 register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x8E,       0x20,       0xDF,       0x05 }, // LS_BP_EN
+    {  0x78,       0x8E,       0x08,       0xF7,       0x03 }, // LS_AMP_EN
+    {  0x78,       0x8E,       0x04,       0xFB,       0x02 }, // LS_LINEOUT_EN
+    {  0x78,       0x8E,       0x03,       0xFC,       0x00 }, // HS_EN
+
+    //========================================================
+    //  C H I P   I D E N T I F I C A T I O N
+    //========================================================
+    // II1RR register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x68,       0x8E,       0xFF,       0x00,       0x00 }, // IIR1
+
+    // II2RR register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x68,       0x8F,       0xFF,       0x00,       0x00 }, // IIR2
+
+    //========================================================
+    //  I N T E R R U P T   &   S T A T U S
+    //========================================================
+    // IRQ_STAT register
+    /* slave addr  addr        mask        clear       shift */
+    {  0x78,       0x98,       0x02,       0xFD,       0x01 }, // SFT_nTIRQ
+    {  0x78,       0x98,       0x01,       0xFE,       0x00 } // SFT_nIRQ
+
+};
+
+
+max8906_regulator_name_type regulator_name[NUMOFREG] =
+{
+    /* reg_name  active_discharge   ena_src_item    sw_ena_dis */
+    {  WBBCORE,  nWCRADE,           WCRENSRC,       WCREN      },
+    {  WBBRF,    nWRFADE,           WRFENSRC,       WRFEN      },
+    {  APPS,     nAPPSADE,          APPSENSRC,      APPSEN     },
+	{  IO,       nIOADE,            IOENSRC,        IOEN       },
+    {  MEM,      nMEMADE,           MEMENSRC,       MEMEN      },
+    {  WBBMEM,   nWMEMADE,          WMEMENSRC,      WMEMEN     },
+    {  WBBIO,    nWIOADE,           WIOENSRC,       WIOEN      },
+    {  WBBANA,   nWANAADE,          WANAENSRC,      WANAEN     },
+    {  RFRXL,    nRFRXLADE,         RFRXLENSRC,     RFRXLEN    },
+    {  RFTXL,    nRFTXLADE,         RFTXLENSRC,     RFTXLEN    },
+    {  RFRXH,    nRFRXHADE,         RFRXHENSRC,     RFRXHEN    },
+    {  RFTCXO,   nRFTCXOADE,        RFTCXOENSRC,    RFTCXOEN   },
+    {  LDOA,     nLDOAADE,          LDOAENSRC,      LDOAEN     },
+    {  LDOB,     nLDOBADE,          LDOBENSRC,      LDOBEN     },
+    {  LDOC,     nLDOCADE,          LDOCENSRC,      LDOCEN     },
+    {  LDOD,     nLDODADE,          LDODENSRC,      LDODEN     },
+    {  SIMLT,    nSIMLTADE,         SIMLTENSRC,     SIMLTEN    },
+    {  SRAM,     nSRAMADE,          SRAMENSRC,      SRAMEN     },
+    {  CARD1,    nCARD1ADE,         CARD1ENSRC,     CARD1EN    },
+    {  CARD2,    nCARD2ADE,         CARD2ENSRC,     CARD2EN    },
+    {  MVT,      nMVTADE,           MVTENSRC,       MVTEN      },
+    {  BIAS,     nBIASADE,          BIASENSRC,      BIASEN     },
+    {  VBUS,     nVBUSADE,          VBUSENSRC,      VBUSEN     },
+    {  USBTXRX,  nUSBTXRXADE,       USBTXRXENSRC,   USBTXRXEN  }
+};
+
+
+max8906_irq_mask_type max8906_irq_init_array[NUMOFIRQ] = {
+    { REG_ON_OFF_IRQ_MASK, ON_OFF_IRQ_M},
+    { REG_CHG_IRQ1_MASK,   CHG_IRQ1_M  },
+    { REG_CHG_IRQ2_MASK,   CHG_IRQ2_M  },
+    { REG_RTC_IRQ_MASK,    RTC_IRQ_M   },
+    { REG_TSC_INT_MASK,    TSC_INT_M   }
+};
+
+max8906_irq_table_type max8906_irq_table[ENDOFTIRQ+1] = {
+    /* ON_OFF_IRQ */
+	{ 0, SW_R     , NULL }, // IRQ_SW_R
+    { 0, SW_F     , NULL }, // IRQ_SW_F
+    { 0, SW_1SEC  , NULL }, // IRQ_SW_1SEC
+    { 0, JIG_R    , NULL }, // IRQ_JIG_R
+    { 0, JIG_F    , NULL }, // IRQ_JIG_F
+    { 0, SW_3SEC  , NULL }, // IRQ_SW_3SEC
+    { 0, MPL_EVENT, NULL }, // IRQ_MPL_EVENT
+    /* CHG_IRQ1 */
+    { 1, VAC_R   , NULL }, // IRQ_VAC_R
+    { 1, VAC_F   , NULL }, // IRQ_VAC_F
+    { 1, VAC_OVP , NULL }, // IRQ_VAC_OVP
+    { 1, VBUS_F  , NULL }, // IRQ_VBUS_F
+    { 1, VBUS_R  , NULL }, // IRQ_VBUS_R
+    { 1, VBUS_OVP, NULL }, // IRQ_VBUS_OVP
+    /* CHG_IRQ2 */
+    { 2, CHG_TMR_FAULT, NULL }, // IRQ_CHG_TMR_FAULT
+    { 2, CHG_TOPOFF   , NULL }, // IRQ_CHG_TOPOFF
+    { 2, CHG_DONE     , NULL }, // IRQ_CHG_DONE
+    { 2, CHG_RST      , NULL }, // IRQ_CHG_RST
+    { 2, MBATTLOWR    , NULL }, // IRQ_MBATTLOWR
+    { 2, MBATTLOWF    , NULL }, // IRQ_MBATTLOWF
+    /* RTC_IRQ */
+    { 3, ALARM0_R, NULL }, // IRQ_ALARM0_R
+    { 3, ALARM1_R, NULL }, // IRQ_ALARM1_R
+    /* TSC_STA_INT */
+    { 4, nREF_OK , NULL }, // IRQ_nREF_OK
+    { 4, nCONV_NS, NULL }, // IRQ_nCONV_NS
+    { 4, CONV_S  , NULL }, // IRQ_CONV_S
+    { 4, nTS_NS  , NULL }, // IRQ_nTS_NS
+    { 4, nTS_S   , NULL }  // IRQ_nTS_S
+};
+
+/* MAX8906 voltage table */
+static const unsigned int arm_voltage_table[61] = {
+	725, 750, 775, 800, 825, 850, 875, 900,		/* 0 ~ 7 */
+	925, 950, 975, 1000, 1025, 1050, 1075, 1100,	/* 8 ~ 15 */
+	1125, 1150, 1175, 1200, 1225, 1250, 1275, 1300,	/* 16 ~ 23 */
+	1325, 1350, 1375, 1400, 1425, 1450, 1475, 1500,	/* 24 ~ 31 */
+	1525, 1550, 1575, 1600, 1625, 1650, 1675, 1700,	/* 32 ~ 39 */
+	1725, 1750, 1775, 1800, 1825, 1850, 1875, 1900,	/* 40 ~ 47 */
+	1925, 1950, 1975, 2000, 2025, 2050, 2075, 2100,	/* 48 ~ 55 */
+	2125, 2150, 2175, 2200, 2225,				/* 56 ~ 60 */
+};
+
+static const unsigned int int_voltage_table[3] = {
+	1050, 1200, 1300,
+};
+
+/*===========================================================================
+
+      P O W E R     M A N A G E M E N T     S E C T I O N
+
+===========================================================================*/
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_REG                                
+
+DESCRIPTION
+    This function write the value at the selected register in the PM section.
+
+INPUT PARAMETERS
+    reg_num :   selected register in the register address.
+    value   :   the value for reg_num.
+                This is aligned to the right side of the return value
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+    Set_MAX8906_PM_REG(CHGENB, onoff);
+
+===========================================================================*/
+boolean Set_MAX8906_PM_REG(max8906_pm_function_type reg_num, byte value)
+{
+    byte reg_buff;
+
+    if(pmic_read(max8906pm[reg_num].slave_addr, max8906pm[reg_num].addr, &reg_buff, (byte)1) != PMIC_PASS)
+    {
+        // Register Read command failed
+        return FALSE;
+    }
+
+    reg_buff = (reg_buff & max8906pm[reg_num].clear) | (value << max8906pm[reg_num].shift);
+    if(pmic_write(max8906pm[reg_num].slave_addr, max8906pm[reg_num].addr, &reg_buff, (byte)1) != PMIC_PASS)
+    {
+        // Register Write command failed
+        return FALSE;
+    }
+    return TRUE;
+}
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_PM_REG                                
+
+DESCRIPTION
+    This function read the value at the selected register in the PM section.
+
+INPUT PARAMETERS
+    reg_num :   selected register in the register address.
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+    reg_buff :  the value of selected register.
+                reg_buff is aligned to the right side of the return value.
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Get_MAX8906_PM_REG(max8906_pm_function_type reg_num, byte *reg_buff)
+{
+    byte temp_buff;
+
+    if(pmic_read(max8906pm[reg_num].slave_addr, max8906pm[reg_num].addr, &temp_buff, (byte)1) != PMIC_PASS)
+    {
+        // Register Read Command failed
+        return FALSE;
+    }
+
+    *reg_buff = (temp_buff & max8906pm[reg_num].mask) >> max8906pm[reg_num].shift;
+
+    return TRUE;
+}
+
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_ADDR                                
+
+DESCRIPTION
+    This function write the value at the selected register address
+    in the PM section.
+
+INPUT PARAMETERS
+    max8906_pm_register_type reg_addr    : the register address.
+    byte *reg_buff   : the array for data of register to write.
+ 	byte length      : the number of the register 
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Set_MAX8906_PM_ADDR(max8906_pm_register_type reg_addr, byte *reg_buff, byte length)
+{
+
+    if(pmic_write(max8906reg[reg_addr].slave_addr, max8906reg[reg_addr].addr, reg_buff, length) != PMIC_PASS)
+    {
+        // Register Write command failed
+        return FALSE;
+    }
+    return TRUE;
+
+}
+
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_PM_ADDR                                
+
+DESCRIPTION
+    This function read the value at the selected register address
+    in the PM section.
+
+INPUT PARAMETERS
+    max8906_pm_register_type reg_addr   : the register address.
+    byte *reg_buff  : the array for data of register to write.
+ 	byte length     : the number of the register 
+
+RETURN VALUE
+    byte *reg_buff : the pointer parameter for data of sequential registers
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Get_MAX8906_PM_ADDR(max8906_pm_register_type reg_addr, byte *reg_buff, byte length)
+{
+    if(reg_addr > ENDOFREG)
+    {
+        // Invalid Read Register
+        return FALSE; // return error;
+    }
+    if(pmic_read(max8906reg[reg_addr].slave_addr, max8906reg[reg_addr].addr, reg_buff, length) != PMIC_PASS)
+    {
+        // Register Read command failed
+        return FALSE;
+    }
+    return TRUE;
+}
+
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_TSC_CONV_REG                                
+
+DESCRIPTION
+    This function write the value at the selected register for Touch-Screen
+    Conversion Command.
+
+INPUT PARAMETERS
+    reg_num :   selected register in the register address.
+    byte cmd   : a data(bit0~2) of register to write.
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Set_MAX8906_TSC_CONV_REG(max8906_pm_function_type reg_num, byte cmd)
+{
+    byte tsc_buff;
+
+    if((reg_num < X_Drive) || (reg_num > AUX2_Measurement))
+    {
+        // Incorrect register for TSC
+        return FALSE;
+    }
+
+	tsc_buff = (max8906pm[reg_num].addr | (max8906pm[reg_num].mask & (byte)(cmd)));
+
+    if(pmic_tsc_write(max8906pm[reg_num].slave_addr, &tsc_buff) != PMIC_PASS)
+    {
+        // Register Write command failed
+        return FALSE;
+    }
+    return TRUE;
+}
+
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_TSC_CONV_REG
+
+DESCRIPTION
+    This function read the value at the selected register for Touch-Screen
+    Conversion Command.
+
+INPUT PARAMETERS
+    reg_num :   selected register in the register address.
+    byte cmd   : a data(bit0~2) of register to write.
+
+RETURN VALUE
+    byte *reg_buff : the pointer parameter for data of sequential registers
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Get_MAX8906_TSC_CONV_REG(max8906_pm_function_type reg_num, byte *cmd)
+{
+    byte tsc_buff = 0;
+
+    if((reg_num < X_Drive) || (reg_num > AUX2_Measurement))
+    {
+        // Incorrect register for TSC
+        return FALSE;
+    }
+    if(pmic_tsc_read(max8906pm[reg_num].slave_addr, &tsc_buff) != PMIC_PASS)
+    {
+        // Register Read Command failed
+        return FALSE;
+    }
+
+    *cmd = (tsc_buff & max8906pm[reg_num].mask);
+
+    return TRUE;
+}
+
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_Regulator_Active_Discharge
+
+DESCRIPTION
+    Enable/Disable Active Discharge for regulators.
+
+INPUT PARAMETERS
+    byte onoff : 0 = Active Discharge Enabled
+                 1 = Active Discharge Disabled
+
+    dword  regulators      : multiple regulators using "OR"
+                             WBBCORE    WBBRF   APPS    IO      MEM     WBBMEM  
+                             WBBIO      WBBANA  RFRXL   RFTXL   RFRXH   RFTCXO  
+                             LDOA       LDOB    LDOC    LDOD    SIMLT   SRAM    
+                             CARD1      CARD2   MVT     BIAS    VBUS    USBTXRX 
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+    Set_MAX8906_PM_Regulator_Active_Discharge( 1, WBBCORE | APPS | MEM | WBBMEM);
+    If you want to select one or a few regulators, please use Set_MAX8906_PM_REG().
+    That is, Set_MAX8906_PM_REG(nWCRADE, 0); // APPS uses SEQ7
+
+===========================================================================*/
+boolean Set_MAX8906_PM_Regulator_Active_Discharge(byte onoff, dword regulators)
+{
+    boolean status;
+    int i;
+
+    status = TRUE;
+
+    for(i=0; i < NUMOFREG; i++)
+    {
+        if(regulator_name[i].reg_name | regulators)
+        {
+            if(Set_MAX8906_PM_REG(regulator_name[i].active_discharge, onoff) != TRUE)
+            {
+                status = FALSE;
+            }
+        }
+    }
+
+    return status;
+}
+
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_Regulator_ENA_SRC
+
+DESCRIPTION
+    Control Enable source for regulators from Flexible Power Sequence between
+    SEQ1 ~ SEQ7 and software enable.
+
+INPUT PARAMETERS
+    flex_power_seq_type sequencer : selected Sequence number for each regulator
+                                         SEQ1 ~ SEQ7 or SW_CNTL
+
+    dword  regulators      : multiple regulators using "OR"
+                             WBBCORE    WBBRF   APPS    IO      MEM     WBBMEM  
+                             WBBIO      WBBANA  RFRXL   RFTXL   RFRXH   RFTCXO  
+                             LDOA       LDOB    LDOC    LDOD    SIMLT   SRAM    
+                             CARD1      CARD2   MVT     BIAS    VBUS    USBTXRX 
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+    Set_MAX8906_PM_Regulator_ENA_SRC( SEQ1, WBBCORE | APPS | MEM | WBBMEM);
+    If you want to select one or a few regulators, please use Set_MAX8906_PM_REG().
+    That is, Set_MAX8906_PM_REG(APPSENSRC, 0x06); // APPS uses SEQ7
+
+===========================================================================*/
+boolean Set_MAX8906_PM_Regulator_ENA_SRC(flex_power_seq_type sequencer, dword regulators)
+{
+    boolean status;
+    int i;
+
+    status = TRUE;
+
+    for(i=0; i < NUMOFREG; i++)
+    {
+        if(regulator_name[i].reg_name | regulators)
+        {
+            if(Set_MAX8906_PM_REG(regulator_name[i].ena_src_item, sequencer) != TRUE)
+            {
+                status = FALSE;
+            }
+        }
+    }
+
+    return status;
+}
+
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_Regulator_SW_Enable
+
+DESCRIPTION
+    Enable/Disable Active Discharge for regulators.
+
+INPUT PARAMETERS
+    byte onoff : 
+                 0 = Disabled
+                 1 = Enabled
+
+    dword  regulators      : multiple regulators using "OR"
+                             WBBCORE    WBBRF   APPS    IO      MEM     WBBMEM  
+                             WBBIO      WBBANA  RFRXL   RFTXL   RFRXH   RFTCXO  
+                             LDOA       LDOB    LDOC    LDOD    SIMLT   SRAM    
+                             CARD1      CARD2   MVT     BIAS    VBUS    USBTXRX 
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+    Set_MAX8906_PM_Regulator_Active_Discharge( 1, WBBCORE | APPS | MEM | WBBMEM);
+    If you want to select one or a few regulators, please use Set_MAX8906_PM_REG().
+    That is, Set_MAX8906_PM_REG(nWCRADE, 0); // APPS uses SEQ7
+
+===========================================================================*/
+boolean Set_MAX8906_PM_Regulator_SW_Enable(byte onoff, dword regulators)
+{
+    boolean status;
+    int i;
+
+    status = TRUE;
+
+    for(i=0; i < NUMOFREG; i++)
+    {
+        if(regulator_name[i].reg_name | regulators)
+        {
+            if(Set_MAX8906_PM_REG(regulator_name[i].sw_ena_dis, onoff) != TRUE)
+            {
+                status = FALSE;
+            }
+        }
+    }
+
+    return status;
+}
+
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_PWR_SEQ_Timer_Period
+
+DESCRIPTION
+    Control the Timer Period between each sequencer event for Flexible Power
+    Sequencer.
+
+INPUT PARAMETERS
+    max8906_pm_function_type cntl_item : selected Sequence number for Timer Period
+                                         SEQ1T ~ SEQ7T
+
+    timer_period_type  value           : T_Period_20uS
+                                         T_Period_40uS
+                                         T_Period_80uS
+                                         T_Period_160uS
+                                         T_Period_320uS
+                                         T_Period_640uS
+                                         T_Period_1280uS
+                                         T_Period_2560uS
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Set_MAX8906_PM_PWR_SEQ_Timer_Period(max8906_pm_function_type cntl_item, timer_period_type value)
+{
+    boolean status;
+
+    status = TRUE;
+    switch(cntl_item)
+    {
+    case SEQ1T:    case SEQ2T:
+    case SEQ3T:    case SEQ4T:
+    case SEQ5T:    case SEQ6T:
+    case SEQ7T:
+        if(Set_MAX8906_PM_REG(cntl_item, value) != TRUE)
+        {
+            status =FALSE;
+        }
+        break;
+    default:
+        status = FALSE;
+    }
+
+    return status;
+}
+
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_PM_PWR_SEQ_Timer_Period
+
+DESCRIPTION
+    Read the Timer Period between each sequencer event for Flexible Power
+    Sequencer.
+
+INPUT PARAMETERS
+    max8906_pm_function_type cntl_item : selected Sequence number for Timer Period
+                                         SEQ1T, SEQ2T, SEQ3T, SEQ4T,
+                                         SEQ5T, SEQ6T, SEQ7T
+
+RETURN VALUE
+    timer_period_type  value           : T_Period_20uS
+                                         T_Period_40uS
+                                         T_Period_80uS
+                                         T_Period_160uS
+                                         T_Period_320uS
+                                         T_Period_640uS
+                                         T_Period_1280uS
+                                         T_Period_2560uS
+
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Get_MAX8906_PM_PWR_SEQ_Timer_Period(max8906_pm_function_type cntl_item, timer_period_type *value)
+{
+    boolean status;
+
+    status = TRUE;
+    switch(cntl_item)
+    {
+    case SEQ1T:    case SEQ2T:
+	case SEQ3T:    case SEQ4T:
+    case SEQ5T:    case SEQ6T:
+	case SEQ7T:
+		if(Get_MAX8906_PM_REG(cntl_item, (byte *)value) != TRUE)
+        {
+            status =FALSE;
+        }
+        break;
+    default:
+        status = FALSE;
+    }
+
+    return status;
+}
+
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_PWR_SEQ_Ena_Src
+
+DESCRIPTION
+    Control the enable source for Flexible Power Sequencer.
+
+INPUT PARAMETERS
+    max8906_pm_function_type cntl_item : selected Sequence number for enable source
+                                         SEQ1SRC, SEQ2SRC, SEQ3SRC, SEQ4SRC, 
+                                         SEQ5SRC, SEQ6SRC, SEQ7SRC
+
+    byte value                         : 
+                            SEQ1SRC = 0 : SYSEN hardware input
+                                      1 : PWREN hardware input
+                                      2 : SEQ1EN software bit
+                                         
+                            SEQ2SRC = 0 : PWREN hardware input
+                                      1 : SYSEN hardware input
+                                      2 : SEQ2EN software bit
+                                         
+                            SEQ3SRC = 0 : WBBEN hardware input
+                                      1 : reserved
+                                      2 : SEQ3EN software bit
+                                         
+                            SEQ4SRC = 0 : TCXOEN hardware input
+                                      1 : reserved
+                                      2 : SEQ4EN software bit
+                                         
+                            SEQ5SRC = 0 : RFRXEN hardware input
+                                      1 : reserved
+                                      2 : SEQ5EN software bit
+                                         
+                            SEQ6SRC = 0 : RFTXEN hardware input
+                                      1 : reserved
+                                      2 : SEQ6EN software bit
+                                         
+                            SEQ7SRC = 0 : ENA hardware input
+                                      1 : reserved
+                                      2 : SEQ7EN software bit
+                                         
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Set_MAX8906_PM_PWR_SEQ_Ena_Src(max8906_pm_function_type cntl_item, byte value)
+{
+    boolean status;
+
+    status = TRUE;
+    switch(cntl_item)
+    {
+    case SEQ1SRC:    case SEQ2SRC:
+    case SEQ3SRC:    case SEQ4SRC:
+    case SEQ5SRC:    case SEQ6SRC:
+    case SEQ7SRC:
+        if(Set_MAX8906_PM_REG(cntl_item, value) != TRUE)
+        {
+            status =FALSE;
+        }
+        break;
+    default:
+        status = FALSE;
+    }
+
+    return status;
+}
+
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_PM_PWR_SEQ_Ena_Src
+
+DESCRIPTION
+    Read the enable source for Flexible Power Sequencer.
+
+INPUT PARAMETERS
+    max8906_pm_function_type cntl_item : selected Sequence number for enable source
+                                         SEQ1SRC, SEQ2SRC, SEQ3SRC, SEQ4SRC, 
+                                         SEQ5SRC, SEQ6SRC, SEQ7SRC
+
+RETURN VALUE
+    byte value                         : 
+                            SEQ1SRC = 0 : SYSEN hardware input
+                                      1 : PWREN hardware input
+                                      2 : SEQ1EN software bit
+                                         
+                            SEQ2SRC = 0 : PWREN hardware input
+                                      1 : SYSEN hardware input
+                                      2 : SEQ2EN software bit
+                                         
+                            SEQ3SRC = 0 : WBBEN hardware input
+                                      1 : reserved
+                                      2 : SEQ3EN software bit
+                                         
+                            SEQ4SRC = 0 : TCXOEN hardware input
+                                      1 : reserved
+                                      2 : SEQ4EN software bit
+                                         
+                            SEQ5SRC = 0 : RFRXEN hardware input
+                                      1 : reserved
+                                      2 : SEQ5EN software bit
+                                         
+                            SEQ6SRC = 0 : RFTXEN hardware input
+                                      1 : reserved
+                                      2 : SEQ6EN software bit
+                                         
+                            SEQ7SRC = 0 : ENA hardware input
+                                      1 : reserved
+                                      2 : SEQ7EN software bit
+
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Get_MAX8906_PM_PWR_SEQ_Ena_Src(max8906_pm_function_type cntl_item, byte *value)
+{
+    boolean status;
+
+    status = TRUE;
+    switch(cntl_item)
+    {
+    case SEQ1SRC:    case SEQ2SRC:
+    case SEQ3SRC:    case SEQ4SRC:
+    case SEQ5SRC:    case SEQ6SRC:
+    case SEQ7SRC:
+        if(Get_MAX8906_PM_REG(cntl_item, value) != TRUE)
+        {
+            status =FALSE;
+        }
+        break;
+    default:
+        status = FALSE;
+    }
+
+    return status;
+}
+
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_PWR_SEQ_SW_Enable
+
+DESCRIPTION
+    Control the enable source for Flexible Power Sequencer.
+
+INPUT PARAMETERS
+    max8906_pm_function_type cntl_item : selected Sequence number for enable source
+                                         SEQ1EN, SEQ2EN, SEQ3EN, SEQ4EN, 
+                                         SEQ5EN, SEQ6EN, SEQ7EN
+
+    byte value :       0 = Disable regulators
+                       1 = Enable regulators
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Set_MAX8906_PM_PWR_SEQ_SW_Enable(max8906_pm_function_type cntl_item, byte value)
+{
+    boolean status;
+
+    status = TRUE;
+    switch(cntl_item)
+    {
+    case SEQ1EN:    case SEQ2EN:
+    case SEQ3EN:    case SEQ4EN:
+    case SEQ5EN:    case SEQ6EN:
+    case SEQ7EN:
+        if(Set_MAX8906_PM_REG(cntl_item, value) != TRUE)
+        {
+            status =FALSE;
+        }
+        break;
+    default:
+        status = FALSE;
+    }
+
+    return status;
+}
+
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_PM_PWR_SEQ_SW_Enable
+
+DESCRIPTION
+    Read the enable source for Flexible Power Sequencer.
+
+INPUT PARAMETERS
+    max8906_pm_function_type cntl_item : selected Sequence number for enable source
+                                         SEQ1EN, SEQ2EN, SEQ3EN, SEQ4EN, 
+                                         SEQ5EN, SEQ6EN, SEQ7EN
+
+
+RETURN VALUE
+    byte value :       0 = Disable regulators
+                       1 = Enable regulators
+
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+
+===========================================================================*/
+boolean Get_MAX8906_PM_PWR_SEQ_SW_Enable(max8906_pm_function_type cntl_item, byte *value)
+{
+    boolean status;
+
+    status = TRUE;
+    switch(cntl_item)
+    {
+    case SEQ1EN:    case SEQ2EN:
+    case SEQ3EN:    case SEQ4EN:
+    case SEQ5EN:    case SEQ6EN:
+    case SEQ7EN:
+        if(Get_MAX8906_PM_REG(cntl_item, value) != TRUE)
+        {
+            status =FALSE;
+        }
+        break;
+    default:
+        status = FALSE;
+    }
+
+    return status;
+}
+
+
+/*===========================================================================
+ T O U C H   S C R E E N
+===========================================================================*/
+void Set_MAX8906_PM_TSC_init()
+{
+    // set interrupt & config
+
+    // set averaging for average check
+
+    // 
+}
+
+void Set_MAX8906_PM_TSC_detect_isr()
+{
+    // send TSC detect event
+}
+
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_TSC_measurement
+
+DESCRIPTION
+    Read x, y, z1, and z2 coordinates for Touch_Screen.
+    (z1 and z2 is used for 5-wire mode.)
+
+INPUT PARAMETERS
+
+RETURN VALUE
+    tsc_coordinates : return value for inserting x, y, z1, and z2 coordinates
+
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+
+===========================================================================*/
+boolean Set_MAX8906_TSC_measurement(max8906_coordinates_type *tsc_coordinates)
+{
+    boolean status;
+    byte tsc_buff;
+    byte result[2];
+    
+    // set x drive & measurement
+	Set_MAX8906_TSC_CONV_REG(X_Drive, CONT);
+	Set_MAX8906_TSC_CONV_REG(X_Measurement, CONT);
+
+    // X Measurement done?
+    do {
+        status = Get_MAX8906_PM_REG(nCONV_NS, &tsc_buff);
+    } while ( !(status && (tsc_buff & nCONV_NS_M)) );
+
+    // set y drive & measurement
+	Set_MAX8906_TSC_CONV_REG(Y_Drive, CONT);
+	Set_MAX8906_TSC_CONV_REG(Y_Measurement, CONT);
+
+    // Y Measurement done?
+    do {
+        status = Get_MAX8906_PM_REG(nCONV_NS, &tsc_buff);
+    } while ( !(status && (tsc_buff & nCONV_NS_M)) );
+
+#ifdef TSC_5_WIRE_MODE
+    // set z1 drive & measurement
+    Set_MAX8906_TSC_CONV_REG(Z1_Drive, CONT);
+    Set_MAX8906_TSC_CONV_REG(Z1_Measurement, CONT);
+
+    // Y Measurement done?
+    do {
+        status = Get_MAX8906_PM_REG(nCONV_NS, &tsc_buff);
+    } while ( !(status && (tsc_buff & nCONV_NS_M)) );
+
+    // set z2 drive & measurement
+    Set_MAX8906_TSC_CONV_REG(Z2_Drive, CONT);
+    Set_MAX8906_TSC_CONV_REG(Z2_Measurement, CONT);
+
+    // Y Measurement done?
+    do {
+        status = Get_MAX8906_PM_REG(nCONV_NS, &tsc_buff);
+    } while ( !(status && (tsc_buff & nCONV_NS_M)) );
+
+#endif
+
+    // read irq reg for clearing interrupt
+
+    // read x & y coordinates if nTIRQ is low
+    status = Get_MAX8906_PM_REG(nCONV_NS, &tsc_buff);
+	if(tsc_buff & nTS_NS_MASK)
+	{
+        // No touch event detected on sensor now
+        return FALSE;
+    }
+
+    if(Get_MAX8906_PM_ADDR(REG_ADC_X_MSB, result, 2) != TRUE)
+    {
+        if(Get_MAX8906_PM_ADDR(REG_ADC_X_MSB, result, 2) != TRUE)
+        {
+            // X can't be read
+            return FALSE;
+        }
+    }
+    tsc_coordinates->x = (word)(result[0]<<4) | (word)(result[1]>>4);
+
+    if(Get_MAX8906_PM_ADDR(REG_ADC_Y_MSB, result, 2) != TRUE)
+    {
+        if(Get_MAX8906_PM_ADDR(REG_ADC_Y_MSB, result, 2) != TRUE)
+        {
+            // Y can't be read
+            return FALSE;
+        }
+    }
+    tsc_coordinates->y = (word)(result[0]<<4) | (word)(result[1]>>4);
+
+#ifdef TSC_5_WIRE_MODE
+    if(Get_MAX8906_PM_ADDR(REG_ADC_Z1_MSB, result, 2) != TRUE)
+    {
+        if(Get_MAX8906_PM_ADDR(REG_ADC_Z1_MSB, result, 2) != TRUE)
+        {
+            // Z1 can't be read
+            return FALSE;
+        }
+    }
+    tsc_coordinates->z1 = (word)(result[0]<<4) | (word)(result[1]>>4);
+
+    if(Get_MAX8906_PM_ADDR(REG_ADC_Z2_MSB, result, 2) != TRUE)
+    {
+        if(Get_MAX8906_PM_ADDR(REG_ADC_Z2_MSB, result, 2) != TRUE)
+        {
+            // Z2 can't be read
+            return FALSE;
+        }
+    }
+    tsc_coordinates->z2 = (word)(result[0]<<4) | (word)(result[1]>>4);
+#endif
+
+    // set x drive & measurement
+    Set_MAX8906_TSC_CONV_REG(X_Drive, NON_EN_REF_CONT);
+    Set_MAX8906_TSC_CONV_REG(X_Measurement, NON_EN_REF_CONT);
+
+    // set y drive & measurement
+    Set_MAX8906_TSC_CONV_REG(Y_Drive, NON_EN_REF_CONT);
+    Set_MAX8906_TSC_CONV_REG(Y_Measurement, NON_EN_REF_CONT);
+
+#ifdef TSC_5_WIRE_MODE
+    // set z1 drive & measurement
+    Set_MAX8906_TSC_CONV_REG(Z1_Drive, CONT);
+    Set_MAX8906_TSC_CONV_REG(Z1_Measurement, CONT);
+
+    // set z2 drive & measurement
+    Set_MAX8906_TSC_CONV_REG(Z2_Drive, CONT);
+    Set_MAX8906_TSC_CONV_REG(Z2_Measurement, CONT);
+#endif
+
+    return TRUE;
+}
+
+
+/*===========================================================================*/
+boolean change_vcc_arm(int voltage)
+{
+	byte reg_value = 0;
+
+	pr_info(PREFIX "%s:I: voltage: %d\n", __func__, voltage);
+
+	if(voltage < arm_voltage_table[0] || voltage > arm_voltage_table[60]) {
+		pr_err(PREFIX "%s:E: invalid voltage: %d\n", __func__, voltage);
+		return FALSE;
+	}
+
+	if (voltage % 25) {
+		pr_err(PREFIX "%s:E: invalid voltage: %d\n", __func__, voltage);
+		return FALSE;
+	}
+
+	if(voltage < arm_voltage_table[16]) { //725 ~ 1100 mV
+		for(reg_value = 0; reg_value <= 15; reg_value++) {
+			if(arm_voltage_table[reg_value] == voltage) break;
+		}
+	}
+	else if(voltage < arm_voltage_table[32]) {	//1125 ~ 1500 mV
+		for(reg_value = 16; reg_value <= 31; reg_value++) {
+			if(arm_voltage_table[reg_value] == voltage) break;
+		}
+	}
+	else if(voltage < arm_voltage_table[48]) {	//1525 ~ 1900 mV
+		for(reg_value = 32; reg_value <= 47; reg_value++) {
+			if(arm_voltage_table[reg_value] == voltage) break;
+		}
+	}
+	else if(voltage <= arm_voltage_table[60]) {	//1925 ~ 2225 mV
+		for(reg_value = 48; reg_value <= 60; reg_value++) {
+			if(arm_voltage_table[reg_value] == voltage) break;
+		}
+	}
+	else {
+		pr_err(PREFIX "%s:E: invalid voltage: %d\n", __func__, voltage);
+		return FALSE;
+	}
+
+ 	Set_MAX8906_PM_REG(T1AOST, 0x0);
+
+	Set_MAX8906_PM_REG(T1APPS, reg_value);
+
+	/* Start Voltage Change */
+	Set_MAX8906_PM_REG(AGO, 0x01);
+
+	return TRUE;
+}
+
+boolean change_vcc_internal(int voltage)
+{	
+	byte reg_value = 0;
+
+	pr_info(PREFIX "%s:I: voltage: %d\n", __func__, voltage);
+
+	if(voltage < int_voltage_table[0] || voltage > int_voltage_table[2]) {
+		pr_err(PREFIX "%s:E: invalid voltage: %d\n", __func__, voltage);
+		return FALSE;
+	}
+
+	for(reg_value = 0; reg_value <= 2; reg_value++) {
+		if(int_voltage_table[reg_value] == voltage) break;
+	}
+
+	if (reg_value > 2) {
+		pr_err(PREFIX "%s:E: invalid voltage: %d\n", __func__, voltage);
+		return FALSE;
+	}
+	if (!Set_MAX8906_PM_REG(MEMDVM, reg_value)) {
+		pr_err(PREFIX "%s:E: set pmic reg fail(%d)\n", __func__, reg_value);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+boolean set_pmic(pmic_pm_type pm_type, int value)
+{
+	boolean rc = FALSE;
+	switch (pm_type) {
+	case VCC_ARM:
+		rc = change_vcc_arm(value);
+		break;
+	case VCC_INT:
+		rc = change_vcc_internal(value);
+		break;
+	default:
+		pr_err(PREFIX "%s:E: invalid pm_type: %d\n", __func__, pm_type);
+		rc = FALSE;
+		break;
+	}
+	return rc;
+}
+
+/*===========================================================================
+
+      R T C     S E C T I O N
+
+===========================================================================*/
+/*===========================================================================
+
+FUNCTION Set_MAX8906_RTC                                
+
+DESCRIPTION
+    This function write the value at the selected register address
+    in the RTC section.
+
+INPUT PARAMETERS
+    max8906_rtc_cmd_type :     TIMEKEEPER = timekeeper register 0x0~0x7
+                               ALARM0     = alarm0 register 0x8~0xF
+                               ALARM1     = alarm1 register 0x10~0x18
+
+    byte* max8906_rtc_ptr : the write value for registers.
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Set_MAX8906_RTC(max8906_rtc_cmd_type rtc_cmd,byte *max8906_rtc_ptr)
+{
+    byte reg;
+
+    reg = (byte)rtc_cmd * 8;
+#if 0 
+	if(pmic_rtc_write(reg, max8906_rtc_ptr, (byte)8) != PMIC_PASS)
+    {
+        //Write RTC failed
+        return FALSE;
+    }
+#endif    
+	return TRUE;
+}
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_RTC                                
+
+DESCRIPTION
+    This function read the value at the selected register address
+    in the RTC section.
+
+INPUT PARAMETERS
+    max8906_rtc_cmd_type :     TIMEKEEPER = timekeeper register 0x0~0x7
+                               ALARM0     = alarm0 register 0x8~0xF
+                               ALARM1     = alarm1 register 0x10~0x18
+
+    byte* max8906_rtc_ptr : the return value for registers.
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Get_MAX8906_RTC(max8906_rtc_cmd_type rtc_cmd, byte *max8906_rtc_ptr)
+{
+    byte reg;
+
+    reg = (byte)rtc_cmd * 8;
+#if 0  
+	if(pmic_rtc_read(reg, max8906_rtc_ptr, (byte)8) != PMIC_PASS)
+    {
+        // Read RTC failed
+        return FALSE;
+    }
+#endif    
+	return TRUE;
+}
+
+
+
+/*===========================================================================
+
+      I R Q    R O U T I N E
+
+===========================================================================*/
+/*===========================================================================
+
+FUNCTION MAX8906_IRQ_init                                
+
+DESCRIPTION
+    Initialize the IRQ Mask register for the IRQ handler.
+
+INPUT PARAMETERS
+
+RETURN VALUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+void MAX8906_IRQ_init()
+{
+    int i;
+
+    for(i=0; i<NUMOFIRQ; i++)
+    {
+        if(pmic_write(max8906reg[max8906_irq_init_array[i].irq_reg].slave_addr, 
+                   max8906reg[max8906_irq_init_array[i].irq_reg].addr, &max8906_irq_init_array[i].irq_mask, (byte)1) != PMIC_PASS)
+        {
+            // Write IRQ Mask failed
+        }
+    }
+}
+
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_IRQ                                
+
+DESCRIPTION
+    When some irq mask is changed, this function can be used.
+    If you send max8906_isr as null(0) point, it means that the irq is masked.
+    If max8906_isr points some functions, it means that the irq is unmasked.
+
+INPUT PARAMETERS
+    irq_name                   : IRQ Mask register number
+    void (*max8906_isr)(void) : If irq is happened, then this routine is running.
+
+RETURN VALUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+boolean Set_MAX8906_PM_IRQ(max8906_irq_type irq_name, void (*max8906_isr)(void))
+{
+    byte reg_buff;
+    byte value;
+
+    if(pmic_read(max8906pm[max8906_irq_table[irq_name].irq_reg].slave_addr, 
+                 max8906pm[max8906_irq_table[irq_name].irq_reg].addr, &reg_buff, (byte)1) != PMIC_PASS)
+    {
+        // Read IRQ register failed
+        return FALSE;
+    }
+
+    if(max8906_isr == 0)
+    {   // if max8906_isr is a null pointer
+        value = 1;
+        reg_buff = (reg_buff | max8906pm[max8906_irq_table[irq_name].irq_reg].mask);
+        max8906_irq_table[irq_name].irq_ptr = NULL;
+    }
+    else
+    {
+        value = 0;
+        reg_buff = (reg_buff & max8906pm[max8906_irq_table[irq_name].irq_reg].clear);
+        max8906_irq_table[irq_name].irq_ptr = max8906_isr;
+    }
+
+    if(pmic_write(max8906pm[max8906_irq_table[irq_name].irq_reg].slave_addr, 
+                  max8906pm[max8906_irq_table[irq_name].irq_reg].addr, &reg_buff, (byte)1) != PMIC_PASS)
+    {
+        // Write IRQ register failed
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+
+/*===========================================================================
+
+FUNCTION MAX8906_PM_IRQ_isr                                
+
+DESCRIPTION
+    When nIRQ pin is asserted, this isr routine check the irq bit and then
+    proper function is called.
+    Irq register can be set although irq is masked.
+    So, the isr routine shoud check the irq mask bit, too.
+
+INPUT PARAMETERS
+
+RETURN VALUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+void MAX8906_PM_IRQ_isr(void)
+{
+    byte pm_irq_reg[4];
+    byte pm_irq_mask[4];
+    byte irq_name;
+    if(pmic_read(max8906reg[REG_ON_OFF_IRQ].slave_addr, max8906reg[REG_ON_OFF_IRQ].addr, &pm_irq_reg[0], (byte)1) != PMIC_PASS)
+    {
+        MSG_HIGH("IRQ register isn't read", 0, 0, 0);
+        return; // return error
+    }
+    if(pmic_read(max8906reg[REG_CHG_IRQ1].slave_addr, max8906reg[REG_CHG_IRQ1].addr, &pm_irq_reg[1], (byte)2) != PMIC_PASS)
+    {
+        MSG_HIGH("IRQ register isn't read", 0, 0, 0);
+        return; // return error
+    }
+    if(pmic_read(max8906reg[REG_RTC_IRQ].slave_addr, max8906reg[REG_RTC_IRQ].addr, &pm_irq_reg[3], (byte)1) != PMIC_PASS)
+    {
+        MSG_HIGH("IRQ register isn't read", 0, 0, 0);
+        return; // return error
+    }
+
+    if(pmic_read(max8906reg[REG_ON_OFF_IRQ_MASK].slave_addr, max8906reg[REG_ON_OFF_IRQ].addr, &pm_irq_reg[0], (byte)1) != PMIC_PASS)
+    {
+        MSG_HIGH("IRQ register isn't read", 0, 0, 0);
+        return; // return error
+    }
+    if(pmic_read(max8906reg[REG_CHG_IRQ1_MASK].slave_addr, max8906reg[REG_CHG_IRQ1].addr, &pm_irq_reg[1], (byte)2) != PMIC_PASS)
+    {
+        MSG_HIGH("IRQ register isn't read", 0, 0, 0);
+        return; // return error
+    }
+    if(pmic_read(max8906reg[REG_RTC_IRQ_MASK].slave_addr, max8906reg[REG_RTC_IRQ].addr, &pm_irq_reg[3], (byte)1) != PMIC_PASS)
+    {
+        MSG_HIGH("IRQ register isn't read", 0, 0, 0);
+        return; // return error
+    }
+
+    for(irq_name = START_IRQ; irq_name <= ENDOFIRQ; irq_name++)
+    {
+        if( (pm_irq_reg[max8906_irq_table[irq_name].item_num] & max8906pm[max8906_irq_table[irq_name].irq_reg].mask)
+            && ( (pm_irq_mask[max8906_irq_table[irq_name].item_num] & max8906pm[max8906_irq_table[irq_name].irq_reg].mask) == 0)
+            && (max8906_irq_table[irq_name].irq_ptr != 0) )
+        {
+            (max8906_irq_table[irq_name].irq_ptr)();
+        }
+    }
+}
+
+
+/*===========================================================================
+
+FUNCTION MAX8906_PM_TIRQ_isr                                
+
+DESCRIPTION
+    When nTIRQ pin is asserted for Touch-Screen, this isr routine check the irq bit and then
+    proper function is called.
+    Irq register can be set although irq is masked.
+    So, the isr routine shoud check the irq mask bit, too.
+
+INPUT PARAMETERS
+
+RETURN VALUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+void MAX8906_PM_TIRQ_isr(void)
+{
+    byte pm_irq_reg[4];
+    byte pm_irq_mask[4];
+    byte irq_name;
+
+    if(pmic_read(max8906reg[REG_TSC_STA_INT].slave_addr, max8906reg[REG_TSC_STA_INT].addr, &pm_irq_reg[0], (byte)1) != PMIC_PASS)
+    {
+        MSG_HIGH("IRQ register isn't read", 0, 0, 0);
+	 	return; // return error
+    }
+
+    if(pmic_read(max8906reg[REG_TSC_INT_MASK].slave_addr, max8906reg[REG_TSC_INT_MASK].addr, &pm_irq_reg[0], (byte)1) != PMIC_PASS)
+    {
+	 	MSG_HIGH("IRQ register isn't read", 0, 0, 0);
+	 	return; // return error
+    }
+
+
+    for(irq_name = START_TIRQ; irq_name <= ENDOFTIRQ; irq_name++)
+    {
+        if( (pm_irq_reg[max8906_irq_table[irq_name].item_num] & max8906pm[max8906_irq_table[irq_name].irq_reg].mask)
+            && ( (pm_irq_mask[max8906_irq_table[irq_name].item_num] & max8906pm[max8906_irq_table[irq_name].irq_reg].mask) == 0)
+            && (max8906_irq_table[irq_name].irq_ptr != 0) )
+        {
+            (max8906_irq_table[irq_name].irq_ptr)();
+        }
+    }
+}
+
+
+
+/*===========================================================================
+
+      I N I T    R O U T I N E
+
+===========================================================================*/
+/*===========================================================================
+
+FUNCTION MAX8906_PM_init
+
+DESCRIPTION
+    When power up, MAX8906_PM_init will initialize the MAX8906 for each part
+
+INPUT PARAMETERS
+
+RETURN VALUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+void MAX8906_PM_init(void)
+{
+    // Set the LDO voltage
+    // When PWRSL is connected to GND, the default voltage of MAX8906 is like this.
+    // LDO1 = 2.6V    LDO2  = 2.6V   LDO3 = 2.85V   LDO4 = 2.85V
+    // LDO5 = 2.85V    LDO6  = 2.85V  LDO7 = 2.85V   LDO8 = 2.85V
+    // LDO9 = 2.85V   LDO10 = 2.85V  LDO11 = 1.8V   LDO14 = 2.80V
+
+    // Set the LDO on/off function
+    // the default value for MAX8906
+    // SD1   = On   SD2   = On   SD3  = Off  LDO1  = On   LDO2   = On
+    // LDO3  = Off  LDO4  = Off  LDO5 = Off  LDO6  = Off  LDO7   = Off
+    // LDO8  = Off  LDO9 = Off  LDO10 = Off  LDO11 = Off  LDO12  = Off
+    // LDO11 = Off  LDO12 = On  LDO13 = Off  LDO14 = Off  REFOUT = On 
+
+     // if you use USB transceiver, Connect internal 1.5k pullup resistor.
+     //Set_MAX8906_PM_USB_CNTL(USB_PU_EN,1);
+     // enable SMPL function
+     //Set_MAX8906_RTC_REG(WTSR_SMPL_CNTL_EN_SMPL, (byte)1);
+     // enable WTSR function for soft reset
+     //Set_MAX8906_RTC_REG(WTSR_SMPL_CNTL_EN_WTSR, (byte)1);
+}
+
+/*===================================================================================================================*/
+/* MAX8906 I2C Interface                                                                                             */
+/*===================================================================================================================*/
+
+#include <linux/i2c.h>
+
+#define MAX8906_RTC_ID	0xD0	/* Read Time Clock */
+#define MAX8906_ADC_ID	0x8E	/* ADC/Touchscreen */
+#define MAX8906_GPM_ID	0x78	/* General Power Management */
+#define MAX8906_APM_ID	0x68	/* APP Specific Power Management */
+
+static struct i2c_driver max8906_driver;
+
+static struct i2c_client *max8906_rtc_i2c_client = NULL;
+static struct i2c_client *max8906_adc_i2c_client = NULL;
+static struct i2c_client *max8906_gpm_i2c_client = NULL;
+static struct i2c_client *max8906_apm_i2c_client = NULL;
+
+static unsigned short max8906_normal_i2c[] = { I2C_CLIENT_END };
+static unsigned short max8906_ignore[] = { I2C_CLIENT_END };
+static unsigned short max8906_probe[] = { 3, (MAX8906_RTC_ID >> 1), 3, (MAX8906_ADC_ID >> 1),
+											3, (MAX8906_GPM_ID >> 1), 3, (MAX8906_APM_ID >> 1), I2C_CLIENT_END };
+
+static struct i2c_client_address_data max8906_addr_data = {
+	.normal_i2c = max8906_normal_i2c,
+	.ignore		= max8906_ignore,
+	.probe		= max8906_probe,
+};
+
+static int max8906_read(struct i2c_client *client, u8 reg, u8 *data)
+{
+	int ret;
+	u8 buf[1];
+	struct i2c_msg msg[2];
+
+	buf[0] = reg; 
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret != 2) 
+		return -EIO;
+
+	*data = buf[0];
+	
+	return 0;
+}
+
+static int max8906_write(struct i2c_client *client, u8 reg, u8 data)
+{
+	int ret;
+	u8 buf[2];
+	struct i2c_msg msg[1];
+
+	buf[0] = reg;
+	buf[1] = data;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 2;
+	msg[0].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msg, 1);
+	if (ret != 1) 
+		return -EIO;
+
+	return 0;
+}
+
+unsigned int pmic_read(u8 slaveaddr, u8 reg, u8 *data, u8 length)
+{
+	struct i2c_client *client;
+#if 0	
+	printk("%s -> slaveaddr 0x%02x, reg 0x%02x, data 0x%02x\n",	__FUNCTION__, slaveaddr, reg, *data);
+#endif	
+	if (slaveaddr == MAX8906_GPM_ID)
+		client = max8906_gpm_i2c_client;
+	else if (slaveaddr == MAX8906_APM_ID)
+		client = max8906_apm_i2c_client;
+	else 
+		return PMIC_FAIL;
+
+	if (max8906_read(client, reg, data) < 0) { 
+		printk(KERN_ERR "%s -> Failed! (slaveaddr 0x%02x, reg 0x%02x, data 0x%02x)\n",
+					__FUNCTION__, slaveaddr, reg, *data);
+		return PMIC_FAIL;
+	}	
+
+	return PMIC_PASS;
+}
+
+unsigned int pmic_write(u8 slaveaddr, u8 reg, u8 *data, u8 length)
+{
+	struct i2c_client *client;
+#if 0	
+	printk("%s -> slaveaddr 0x%02x, reg 0x%02x, data 0x%02x\n",	__FUNCTION__, slaveaddr, reg, *data);
+#endif	
+	if (slaveaddr == MAX8906_GPM_ID)
+		client = max8906_gpm_i2c_client;
+	else if (slaveaddr == MAX8906_APM_ID)
+		client = max8906_apm_i2c_client;
+	else 
+		return PMIC_FAIL;
+
+	if (max8906_write(client, reg, *data) < 0) { 
+		printk(KERN_ERR "%s -> Failed! (slaveaddr 0x%02x, reg 0x%02x, data 0x%02x)\n",
+					__FUNCTION__, slaveaddr, reg, *data);
+		return PMIC_FAIL;
+	}	
+
+	return PMIC_PASS;
+}
+
+unsigned int pmic_tsc_write(u8 slaveaddr, u8 *cmd)
+{
+	return 0;
+}
+
+unsigned int pmic_tsc_read(u8 slaveaddr, u8 *cmd)
+{
+	return 0;
+}
+
+static int max8906_attach(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct i2c_client *c;
+	int ret;
+
+	c = kmalloc(sizeof(*c), GFP_KERNEL);
+	if (!c)
+		return -ENOMEM;
+
+	memset(c, 0, sizeof(struct i2c_client));	
+
+	strcpy(c->name, max8906_driver.driver.name);
+	c->addr = addr;
+	c->adapter = adap;
+	c->driver = &max8906_driver;
+
+	if ((ret = i2c_attach_client(c)))
+		goto error;
+
+	if ((addr << 1) == MAX8906_RTC_ID)
+		max8906_rtc_i2c_client = c;
+	else if ((addr << 1) == MAX8906_ADC_ID)
+		max8906_adc_i2c_client = c;
+	else if ((addr << 1) == MAX8906_GPM_ID)
+		max8906_gpm_i2c_client = c;
+	else /* (addr << 1) == MAX8906_APM_ID */
+		max8906_apm_i2c_client = c;
+
+error:
+	return ret;
+}
+
+static int max8906_attach_adapter(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &max8906_addr_data, max8906_attach);
+}
+
+static int max8906_detach_client(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+	return 0;
+}
+
+static int max8906_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	return 0;
+}
+
+static struct i2c_driver max8906_driver = {
+	.driver = {
+		.name = "max8906",
+	},
+	.attach_adapter = max8906_attach_adapter,
+	.detach_client = max8906_detach_client,
+	.command = max8906_command
+};
+
+static int __init max8906_init(void)
+{
+	return i2c_add_driver(&max8906_driver);
+}
+
+static void __exit max8906_exit(void)
+{
+	i2c_del_driver(&max8906_driver);
+}
+
+MODULE_AUTHOR("Jeonghwan Min <jh78.min@samsung.com>");
+MODULE_DESCRIPTION("MAX8906 Driver");
+MODULE_LICENSE("GPL");
+
+module_init(max8906_init);
+module_exit(max8906_exit);
diff -Nur linux-2.6.29/drivers/i2c/chips/pca963x.c linux-2.6.29-spica/drivers/i2c/chips/pca963x.c
--- linux-2.6.29/drivers/i2c/chips/pca963x.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/i2c/chips/pca963x.c	2010-03-30 11:00:35.000000000 +0700
@@ -0,0 +1,431 @@
+/* pca963x.c - 4-bit I2C-bus LED driver
+ *
+ * Copyright (C) 2008 HTC Corporation.
+ * Author: Shan-Fu Chiou <sfchiou@gmail.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/leds.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+
+static uint8_t address[] = { 0x02, 0x03, 0x04 };
+static DEFINE_SPINLOCK(pca963x_lock);
+
+enum op_t {
+	OP_SET_BLINK,
+	OP_SET_GRPPWM,
+	OP_SET_GRPFREQ,
+	OP_SET_BLUE_BRIGHTNESS,
+	OP_SET_GREEN_BRIGHTNESS,
+	OP_SET_RED_BRIGHTNESS,
+};
+
+enum power_mode {
+	MODE_SLEEP,
+	MODE_NORMAL,
+};
+
+struct pca963x_t {
+	uint8_t colors[3];
+	uint8_t blink;
+	uint8_t grppwm;
+	uint8_t grpfreq;
+};
+
+struct pca963x_data {
+	struct pca963x_t data;
+	uint8_t dirty;
+	uint8_t status;
+	enum power_mode mode;
+	struct work_struct work;
+	struct i2c_client *client;
+	struct led_classdev leds[3];	/* blue, green, red */
+};
+
+static ssize_t pca963x_blink_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	if (((pca963x->dirty >> OP_SET_BLINK) & 0x01))
+		flush_scheduled_work();
+	return sprintf(buf, "%u\n", pca963x->data.blink);
+}
+
+static ssize_t pca963x_blink_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	int val = -1;
+
+	sscanf(buf, "%u", &val);
+	if (val < 0 || val > 1)
+		return -EINVAL;
+
+	spin_lock(&pca963x_lock);
+	pca963x->dirty |= 1 << OP_SET_BLINK;
+	pca963x->data.blink = val;
+	spin_unlock(&pca963x_lock);
+	schedule_work(&pca963x->work);
+
+	return count;
+}
+
+static DEVICE_ATTR(blink, 0644, pca963x_blink_show, pca963x_blink_store);
+
+static ssize_t pca963x_grpfreq_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	if (((pca963x->dirty >> OP_SET_GRPFREQ) & 0x01))
+		flush_scheduled_work();
+	return sprintf(buf, "%u\n", pca963x->data.grpfreq);
+}
+
+static ssize_t pca963x_grpfreq_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+
+	if (val > 0xff)
+		return -EINVAL;
+
+	spin_lock(&pca963x_lock);
+	pca963x->dirty |= 1 << OP_SET_GRPFREQ;
+	pca963x->data.grpfreq = val;
+	spin_unlock(&pca963x_lock);
+	schedule_work(&pca963x->work);
+
+	return count;
+}
+
+static DEVICE_ATTR(grpfreq, 0644, pca963x_grpfreq_show, pca963x_grpfreq_store);
+
+static ssize_t pca963x_grppwm_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	if (((pca963x->dirty >> OP_SET_GRPPWM) & 0x01))
+		flush_scheduled_work();
+	return sprintf(buf, "%u\n", pca963x->data.grppwm);
+}
+
+static ssize_t pca963x_grppwm_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+
+	if (val > 0xff)
+		return -EINVAL;
+
+	spin_lock(&pca963x_lock);
+	pca963x->dirty |= 1 << OP_SET_GRPPWM;
+	pca963x->data.grppwm = val;
+	spin_unlock(&pca963x_lock);
+	schedule_work(&pca963x->work);
+
+	return count;
+}
+
+static DEVICE_ATTR(grppwm, 0644, pca963x_grppwm_show, pca963x_grppwm_store);
+
+static void led_brightness_set(struct led_classdev *led_cdev,
+			       enum led_brightness brightness)
+{
+	struct pca963x_data *pca963x;
+	int idx = 2;
+
+	spin_lock(&pca963x_lock);
+	if (!strcmp(led_cdev->name, "blue")) {
+		idx = 0;
+	} else if (!strcmp(led_cdev->name, "green")) {
+		idx = 1;
+	} else {
+		idx = 2;
+	}
+	pca963x = container_of(led_cdev, struct pca963x_data, leds[idx]);
+	pca963x->data.colors[idx] = brightness;
+	pca963x->dirty |= (1 << (OP_SET_BLUE_BRIGHTNESS + idx));
+	spin_unlock(&pca963x_lock);
+
+	schedule_work(&pca963x->work);
+
+}
+
+static void pca963x_update_brightness(struct pca963x_data *pca963x, int idx,
+				      int brightness)
+{
+	if (brightness > LED_OFF) {
+		if (brightness == LED_FULL) {
+			pca963x->status &= ~(1 << idx);
+			pca963x->status |= (1 << (idx + 4));
+		} else {
+			pca963x->status |= (1 << idx);
+			pca963x->status &= ~(1 << (idx + 4));
+		}
+	} else {
+		pca963x->status &= ~(1 << idx);
+		pca963x->status &= ~(1 << (idx + 4));
+	}
+	i2c_smbus_write_byte_data(pca963x->client, address[idx], brightness);
+}
+
+static void pca963x_work_func(struct work_struct *work)
+{
+	int ret;
+	uint8_t dirty = 0;
+	struct pca963x_t work_data;
+	struct pca963x_data *pca963x =
+	    container_of(work, struct pca963x_data, work);
+
+	spin_lock(&pca963x_lock);
+	work_data = pca963x->data;
+	dirty = pca963x->dirty;
+	pca963x->dirty = 0;
+	spin_unlock(&pca963x_lock);
+
+	ret = i2c_smbus_read_byte_data(pca963x->client, 0x00);
+	/* check if should switch to normal mode */
+	if (!pca963x->mode) {
+		i2c_smbus_write_byte_data(pca963x->client, 0x00, 0x01);
+		pca963x->mode = MODE_NORMAL;
+		i2c_smbus_write_byte_data(pca963x->client, 0x08, 0xFF);
+	}
+
+	if ((dirty >> OP_SET_BLINK) & 0x01) {
+		ret = i2c_smbus_read_byte_data(pca963x->client, 0x01);
+		if (work_data.blink)	/* enable blinking */
+			i2c_smbus_write_byte_data(pca963x->client, 0x01,
+						  ret | 0x20);
+		else {
+			/* set group duty cycle control to default */
+			i2c_smbus_write_byte_data(pca963x->client, 0x06, 0xFF);
+			/* set group frequency to default */
+			i2c_smbus_write_byte_data(pca963x->client, 0x07, 0x00);
+			/* enable dimming */
+			i2c_smbus_write_byte_data(pca963x->client, 0x01,
+						  ret & 0xDF);
+		}
+	}
+
+	if ((dirty >> OP_SET_GRPPWM) & 0x01) {
+		i2c_smbus_write_byte_data(pca963x->client, 0x06,
+					  work_data.grppwm);
+	}
+
+	if ((dirty >> OP_SET_GRPFREQ) & 0x01) {
+		i2c_smbus_write_byte_data(pca963x->client, 0x07,
+					  work_data.grpfreq);
+	}
+
+	if ((dirty >> OP_SET_BLUE_BRIGHTNESS) & 0x01)
+		pca963x_update_brightness(pca963x, 0, work_data.colors[0]);
+
+	if ((dirty >> OP_SET_GREEN_BRIGHTNESS) & 0x01)
+		pca963x_update_brightness(pca963x, 1, work_data.colors[1]);
+
+	if ((dirty >> OP_SET_RED_BRIGHTNESS) & 0x01)
+		pca963x_update_brightness(pca963x, 2, work_data.colors[2]);
+
+	/* check if could go to low power mode */
+	if (((pca963x->status & 0x0F) == 0) && (!work_data.blink)) {
+		i2c_smbus_write_byte_data(pca963x->client, 0x08, 0xAA);
+		i2c_smbus_write_byte_data(pca963x->client, 0x00, 0x11);
+		pca963x->mode = MODE_SLEEP;
+	}
+}
+
+static void set_pca963x_default(struct i2c_client *client)
+{
+	i2c_smbus_write_byte_data(client, 0x00, 0x01);
+	i2c_smbus_write_byte_data(client, 0x01, 0x00);
+	/* set all LEDx brightness off */
+	i2c_smbus_write_byte_data(client, address[0], LED_OFF);
+	i2c_smbus_write_byte_data(client, address[1], LED_OFF);
+	i2c_smbus_write_byte_data(client, address[2], LED_OFF);
+	/* set group duty cycle control to default */
+	i2c_smbus_write_byte_data(client, 0x06, 0xFF);
+	/* set group frequency to default */
+	i2c_smbus_write_byte_data(client, 0x07, 0x00);
+	/*
+	 * set LEDx individual brightness and group dimming/blinking
+	 * can be controlled by * its PWMx register and GRPPWM registers.
+	 */
+	i2c_smbus_write_byte_data(client, 0x08, 0xFF);
+	/* low power mode. oscillator off */
+	i2c_smbus_write_byte_data(client, 0x00, 0x11);
+}
+
+static int pca963x_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	int ret = 0;
+
+	struct pca963x_data *pca963x;
+
+	if (!i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_BYTE_DATA)) {
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	pca963x = kzalloc(sizeof(struct pca963x_data), GFP_KERNEL);
+	if (pca963x == NULL) {
+		ret = -ENOMEM;
+		goto err_alloc_failed;
+	}
+
+	INIT_WORK(&pca963x->work, pca963x_work_func);
+
+	pca963x->client = client;
+
+	pca963x->leds[0].name = "blue";
+	pca963x->leds[0].brightness = LED_OFF;
+	pca963x->leds[0].brightness_set = led_brightness_set;
+
+	pca963x->leds[1].name = "green";
+	pca963x->leds[1].brightness = LED_OFF;
+	pca963x->leds[1].brightness_set = led_brightness_set;
+
+	pca963x->leds[2].name = "red";
+	pca963x->leds[2].brightness = LED_OFF;
+	pca963x->leds[2].brightness_set = led_brightness_set;
+
+	pca963x->dirty = 0;
+	pca963x->status = 0;
+
+	pca963x->data.colors[0] = LED_OFF;
+	pca963x->data.colors[1] = LED_OFF;
+	pca963x->data.colors[2] = LED_OFF;
+	pca963x->data.blink = 0;
+	pca963x->data.grppwm = 0;
+	pca963x->data.grpfreq = 0;
+	i2c_set_clientdata(client, pca963x);
+
+	set_pca963x_default(client);
+	pca963x->mode = MODE_SLEEP;
+
+	/* blue */
+	ret = led_classdev_register(&client->dev, &pca963x->leds[0]);
+	if (ret < 0) {
+		printk(KERN_ERR "pca963x: led_classdev_register failed\n");
+		goto err_led0_classdev_register_failed;
+	}
+	/* green */
+	ret = led_classdev_register(&client->dev, &pca963x->leds[1]);
+	if (ret < 0) {
+		printk(KERN_ERR "pca963x: led_classdev_register failed\n");
+		goto err_led1_classdev_register_failed;
+	}
+	/* red */
+	ret = led_classdev_register(&client->dev, &pca963x->leds[2]);
+	if (ret < 0) {
+		printk(KERN_ERR "pca963x: led_classdev_register failed\n");
+		goto err_led2_classdev_register_failed;
+	}
+
+	ret = device_create_file(&client->dev, &dev_attr_blink);
+	ret = device_create_file(&client->dev, &dev_attr_grppwm);
+	ret = device_create_file(&client->dev, &dev_attr_grpfreq);
+
+	return 0;
+
+err_led2_classdev_register_failed:
+	led_classdev_unregister(&pca963x->leds[2]);
+err_led1_classdev_register_failed:
+	led_classdev_unregister(&pca963x->leds[1]);
+err_led0_classdev_register_failed:
+	led_classdev_unregister(&pca963x->leds[0]);
+err_alloc_failed:
+	kfree(pca963x);
+exit:
+	return ret;
+}
+
+static int pca963x_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	flush_scheduled_work();
+	return 0;
+}
+
+static int pca963x_remove(struct i2c_client *client)
+{
+	struct pca963x_data *pca963x = i2c_get_clientdata(client);
+
+	cancel_work_sync(&pca963x->work);
+	device_remove_file(&client->dev, &dev_attr_blink);
+	device_remove_file(&client->dev, &dev_attr_grppwm);
+	device_remove_file(&client->dev, &dev_attr_grpfreq);
+	set_pca963x_default(client);
+	led_classdev_unregister(&pca963x->leds[0]);
+	led_classdev_unregister(&pca963x->leds[1]);
+	led_classdev_unregister(&pca963x->leds[2]);
+	i2c_detach_client(client);
+
+	kfree(pca963x);
+	return 0;
+}
+
+static const struct i2c_device_id pca963x_id[] = {
+	{ "pca963x", 0 },
+	{ }
+};
+
+static struct i2c_driver pca963x_driver = {
+	.driver = {
+		   .name = "pca963x",
+		   },
+	.probe = pca963x_probe,
+	.suspend = pca963x_suspend,
+	.remove = pca963x_remove,
+	.id_table = pca963x_id,
+};
+
+static int __init pca963x_init(void)
+{
+	return i2c_add_driver(&pca963x_driver);
+}
+
+static void __exit pca963x_exit(void)
+{
+	i2c_del_driver(&pca963x_driver);
+}
+
+MODULE_AUTHOR("Shan-Fu Chiou <sfchiou@gmail.com>");
+MODULE_DESCRIPTION("pca963x driver");
+MODULE_LICENSE("GPL");
+
+module_init(pca963x_init);
+module_exit(pca963x_exit);
diff -Nur linux-2.6.29/drivers/i2c/i2c-core.c linux-2.6.29-spica/drivers/i2c/i2c-core.c
--- linux-2.6.29/drivers/i2c/i2c-core.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/i2c/i2c-core.c	2010-05-06 12:42:45.674299703 +0700
@@ -1129,7 +1129,11 @@
 	int err;
 
 	/* Make sure the address is valid */
+#if 0	/* Modified by jhmin to support special chips */	
 	if (addr < 0x03 || addr > 0x77) {
+#else	
+	if (addr < 0x01 || addr > 0x7F) {
+#endif	
 		dev_warn(&adapter->dev, "Invalid probe address 0x%02x\n",
 			 addr);
 		return -EINVAL;
@@ -1270,7 +1274,8 @@
 	int err;
 
 	/* Make sure the address is valid */
-	if (addr < 0x03 || addr > 0x77) {
+	//if (addr < 0x03 || addr > 0x77) {
+	if (addr < 0x01 || addr > 0x7F) {
 		dev_warn(&adapter->dev, "Invalid probe address 0x%02x\n",
 			 addr);
 		return -EINVAL;
diff -Nur linux-2.6.29/drivers/input/evdev.c linux-2.6.29-spica/drivers/input/evdev.c
--- linux-2.6.29/drivers/input/evdev.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/input/evdev.c	2010-05-06 12:42:45.674299703 +0700
@@ -19,6 +19,7 @@
 #include <linux/input.h>
 #include <linux/major.h>
 #include <linux/device.h>
+#include <linux/wakelock.h>
 #include "input-compat.h"
 
 struct evdev {
@@ -43,6 +44,8 @@
 	struct fasync_struct *fasync;
 	struct evdev *evdev;
 	struct list_head node;
+	struct wake_lock wake_lock;
+	char name[28];
 };
 
 static struct evdev *evdev_table[EVDEV_MINORS];
@@ -55,6 +58,7 @@
 	 * Interrupts are disabled, just acquire the lock
 	 */
 	spin_lock(&client->buffer_lock);
+	wake_lock_timeout(&client->wake_lock, 5 * HZ);
 	client->buffer[client->head++] = *event;
 	client->head &= EVDEV_BUFFER_SIZE - 1;
 	spin_unlock(&client->buffer_lock);
@@ -71,8 +75,11 @@
 	struct evdev *evdev = handle->private;
 	struct evdev_client *client;
 	struct input_event event;
+	struct timespec ts;
 
-	do_gettimeofday(&event.time);
+	ktime_get_ts(&ts);
+	event.time.tv_sec = ts.tv_sec;
+	event.time.tv_usec = ts.tv_nsec / NSEC_PER_USEC;
 	event.type = type;
 	event.code = code;
 	event.value = value;
@@ -236,6 +243,7 @@
 	mutex_unlock(&evdev->mutex);
 
 	evdev_detach_client(evdev, client);
+	wake_lock_destroy(&client->wake_lock);
 	kfree(client);
 
 	evdev_close_device(evdev);
@@ -272,6 +280,9 @@
 	}
 
 	spin_lock_init(&client->buffer_lock);
+	snprintf(client->name, sizeof(client->name), "%s-%d", evdev->name,
+			task_tgid_vnr(current));
+	wake_lock_init(&client->wake_lock, WAKE_LOCK_SUSPEND, client->name);
 	client->evdev = evdev;
 	evdev_attach_client(evdev, client);
 
@@ -335,6 +346,8 @@
 	if (have_event) {
 		*event = client->buffer[client->tail++];
 		client->tail &= EVDEV_BUFFER_SIZE - 1;
+		if (client->head == client->tail)
+			wake_unlock(&client->wake_lock);
 	}
 
 	spin_unlock_irq(&client->buffer_lock);
diff -Nur linux-2.6.29/drivers/input/input.c linux-2.6.29-spica/drivers/input/input.c
--- linux-2.6.29/drivers/input/input.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/input/input.c	2010-03-30 11:00:31.000000000 +0700
@@ -29,6 +29,23 @@
 
 #define INPUT_DEVICES	256
 
+/*
+ * EV_ABS events which should not be cached are listed here.
+ */
+static unsigned int input_abs_bypass_init_data[] __initdata = {
+	ABS_MT_TOUCH_MAJOR,
+	ABS_MT_TOUCH_MINOR,
+	ABS_MT_WIDTH_MAJOR,
+	ABS_MT_WIDTH_MINOR,
+	ABS_MT_ORIENTATION,
+	ABS_MT_POSITION_X,
+	ABS_MT_POSITION_Y,
+	ABS_MT_TOOL_TYPE,
+	ABS_MT_BLOB_ID,
+	0
+};
+static unsigned long input_abs_bypass[BITS_TO_LONGS(ABS_CNT)];
+
 static LIST_HEAD(input_dev_list);
 static LIST_HEAD(input_handler_list);
 
@@ -156,6 +173,10 @@
 				disposition = INPUT_PASS_TO_HANDLERS;
 			}
 			break;
+		case SYN_MT_REPORT:
+			dev->sync = 0;
+			disposition = INPUT_PASS_TO_HANDLERS;
+			break;
 		}
 		break;
 
@@ -185,6 +206,11 @@
 	case EV_ABS:
 		if (is_event_supported(code, dev->absbit, ABS_MAX)) {
 
+			if (test_bit(code, input_abs_bypass)) {
+				disposition = INPUT_PASS_TO_HANDLERS;
+				break;
+			}
+
 			value = input_defuzz_abs_event(value,
 					dev->abs[code], dev->absfuzz[code]);
 
@@ -1630,10 +1656,20 @@
 	.open = input_open_file,
 };
 
+static void __init input_init_abs_bypass(void)
+{
+	const unsigned int *p;
+
+	for (p = input_abs_bypass_init_data; *p; p++)
+		input_abs_bypass[BIT_WORD(*p)] |= BIT_MASK(*p);
+}
+
 static int __init input_init(void)
 {
 	int err;
 
+	input_init_abs_bypass();
+
 	err = class_register(&input_class);
 	if (err) {
 		printk(KERN_ERR "input: unable to register input_dev class\n");
diff -Nur linux-2.6.29/drivers/input/Kconfig linux-2.6.29-spica/drivers/input/Kconfig
--- linux-2.6.29/drivers/input/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/input/Kconfig	2010-03-30 11:00:32.000000000 +0700
@@ -149,6 +149,15 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called apm-power.
 
+config INPUT_KEYRESET
+	tristate "Reset key"
+	depends on INPUT
+	---help---
+	  Say Y here if you want to reboot when some keys are pressed;
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called keyreset.
+
 config XEN_KBDDEV_FRONTEND
 	tristate "Xen virtual keyboard and mouse support"
 	depends on XEN_FBDEV_FRONTEND
diff -Nur linux-2.6.29/drivers/input/keyboard/Kconfig linux-2.6.29-spica/drivers/input/keyboard/Kconfig
--- linux-2.6.29/drivers/input/keyboard/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/input/keyboard/Kconfig	2010-05-06 12:42:45.674299703 +0700
@@ -304,6 +304,15 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called gpio-keys.
 
+config KEYPAD_S3C
+	tristate "S3C keypad support"
+	depends on (CPU_S3C6400 || CPU_S3C6410)
+	default n
+	help
+	  Say Y here if you want to use the S3C SMDK keypad.
+	  To compile this driver as a module, choose M here: the
+	  module will be called s3c-keypad.
+
 config KEYBOARD_MAPLE
 	tristate "Maple bus keyboard"
 	depends on SH_DREAMCAST && MAPLE
diff -Nur linux-2.6.29/drivers/input/keyboard/Makefile linux-2.6.29-spica/drivers/input/keyboard/Makefile
--- linux-2.6.29/drivers/input/keyboard/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/input/keyboard/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -28,3 +28,4 @@
 obj-$(CONFIG_KEYBOARD_MAPLE)		+= maple_keyb.o
 obj-$(CONFIG_KEYBOARD_BFIN)		+= bf54x-keys.o
 obj-$(CONFIG_KEYBOARD_SH_KEYSC)		+= sh_keysc.o
+obj-$(CONFIG_KEYPAD_S3C)                += s3c-keypad.o
diff -Nur linux-2.6.29/drivers/input/keyboard/s3c-keypad-board.h linux-2.6.29-spica/drivers/input/keyboard/s3c-keypad-board.h
--- linux-2.6.29/drivers/input/keyboard/s3c-keypad-board.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/input/keyboard/s3c-keypad-board.h	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,55 @@
+/* linux/drivers/input/keyboard/s3c-keypad.h 
+ *
+ * Driver header for Samsung SoC keypad.
+ *
+ * Kim Kyoungil, Copyright (c) 2006-2009 Samsung Electronics
+ *      http://www.samsungsemi.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef _S3C_KEYPAD_BOARD_H_
+#define _S3C_KEYPAD_BOARD_H_
+
+static void __iomem *key_base;
+
+#define KEYPAD_COLUMNS	(4)	/* GPIO_KEYSENSE_0 ~ GPIO_KEYSENSE_3 */
+#define KEYPAD_ROWS	(4)	/* GPIO_KEYSCAN_0 ~ GPIO_KEYSCAN_3 */
+#define MAX_KEYPAD_NR   (KEYPAD_COLUMNS * KEYPAD_ROWS)
+#define MAX_KEYMASK_NR	32
+
+#if 1	// Temporary Code by SYS.LSI
+#define ENDCALL_KEY 249
+#define HOLD_KEY 217
+#endif
+
+u32 g_board_num = CONFIG_SPICA_REV;
+
+struct s3c_keypad_special_key special_key_spica_00[] = {
+	{0x08000000, 0x00000000, KEYCODE_FOCUS},
+	{0x00040100, 0x00000000, KEYCODE_DUMPKEY},
+};
+
+struct s3c_keypad_gpio_key gpio_key_spica_00[] = {
+	{IRQ_EINT(5),  GPIO_POWER_N,      GPIO_POWER_N_AF,      KEYCODE_ENDCALL, 1},
+};
+
+#if (CONFIG_SPICA_REV == CONFIG_SPICA_TEST_REV02)
+struct s3c_keypad_gpio_key gpio_key_spica_02[] = {
+	{IRQ_EINT(5),  GPIO_POWER_N,      GPIO_POWER_N_AF,      KEYCODE_ENDCALL, 1},
+	{IRQ_EINT(17), GPIO_HOLD_KEY_N,   GPIO_HOLD_KEY_N_AF,   KEYCODE_HOLDKEY, 1},
+};
+#endif
+
+struct s3c_keypad_extra s3c_keypad_extra[] = {
+	{0x0000, NULL, &special_key_spica_00[0], 2,  &gpio_key_spica_00[0], 1, 1},
+	{0x0010, NULL, &special_key_spica_00[0], 2,  &gpio_key_spica_00[0], 1, 1},
+#if (CONFIG_SPICA_REV == CONFIG_SPICA_TEST_REV02)
+	{0x0020, NULL, &special_key_spica_00[0], 2,  &gpio_key_spica_02[0], 2, 1},
+#endif
+};
+
+#endif				/* _S3C_KEYIF_H_ */
diff -Nur linux-2.6.29/drivers/input/keyboard/s3c-keypad.c linux-2.6.29-spica/drivers/input/keyboard/s3c-keypad.c
--- linux-2.6.29/drivers/input/keyboard/s3c-keypad.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/input/keyboard/s3c-keypad.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,695 @@
+/* drivers/input/keyboard/s3c-keypad.c
+ *
+ * Driver core for Samsung SoC onboard UARTs.
+ *
+ * Kim Kyoungil, Copyright (c) 2006-2009 Samsung Electronics
+ *      http://www.samsungsemi.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/clk.h>
+
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <asm/delay.h>
+#include <asm/irq.h>
+
+#include <plat/regs-gpio.h>
+#include <plat/regs-keypad.h>
+#include <linux/irq.h>
+#include <asm/io.h>
+#include <plat/gpio-cfg.h>
+#include "s3c-keypad.h"
+#include "s3c-keypad-board.h"
+
+#ifdef CONFIG_CPU_FREQ 
+#include <plat/s3c64xx-dvfs.h>
+#endif
+
+
+
+//[ <<yamaia><system><JKCha>
+#include <linux/wakelock.h>	
+
+static struct wake_lock s3c_key_wake_lock;	
+//] wake lock for keypad scan operation complete
+
+
+//#define S3C_KEYPAD_DEBUG 
+
+#ifdef S3C_KEYPAD_DEBUG
+#define DPRINTK(x...) printk("S3C-Keypad " x)
+#else
+#define DPRINTK(x...)		/* !!!! */
+#endif
+
+#define DEVICE_NAME "s3c-keypad"
+
+#define TRUE 1
+#define FALSE 0
+
+#define FIRST_SCAN_INTERVAL    	(1)
+#define SCAN_INTERVAL    	(HZ/50)
+
+static struct timer_list keypad_timer;
+static int is_timer_on = FALSE;
+static struct clk *keypad_clock;
+static u32 prevmask_low = 0, prevmask_high = 0;
+static int keypad_sleep_flag = 0;	// Temporay Code by SYS.LSI
+
+static int keypad_scan(u32 *keymask_low, u32 *keymask_high)
+{
+	u32 i,cval,rval;
+
+	for (i=0; i<KEYPAD_COLUMNS; i++) {
+		cval = KEYCOL_DMASK & ~((1 << i) | (1 << (i+ 8)));   // clear that column number and 
+		writel(cval, key_base+S3C_KEYIFCOL);               // make that Normal output.
+								   // others shuld be High-Z output.
+
+		udelay(KEYPAD_DELAY);
+
+		rval = ~(readl(key_base+S3C_KEYIFROW)) & ((1<<KEYPAD_ROWS)-1) ;
+		
+#if (KEYPAD_COLUMNS>4)	
+		if (i < 4)
+			*keymask_low |= (rval << (i * 8));
+		else 
+			*keymask_high |= (rval << ((i-4) * 8));
+#else
+		*keymask_low |= (rval << (i * 8));
+#endif
+	}
+
+	//[ <<yamaia><system><JKCha>
+	if(*keymask_low == 0x04040404)
+	{
+		//Preventing Send Key Event in the case of Right & Menu & Send & Home Keys... 
+		*keymask_low = *keymask_low & 0xFFFBFFFF;  
+		// 1111 1111 1111 1011 1111 1111 1111 1111  <<yamaia><system><JKCha>
+	}
+	//] wake lock for keypad scan operation complete
+
+
+	writel(KEYIFCOL_CLEAR, key_base+S3C_KEYIFCOL);
+
+	return 0;
+}
+
+static void process_input_report (struct s3c_keypad *s3c_keypad, u32 prevmask, u32 keymask, u32 index)
+{
+	struct input_dev             *dev = s3c_keypad->dev;
+	int i=0;
+	u32 press_mask = ((keymask ^ prevmask) & keymask); 
+	u32 release_mask = ((keymask ^ prevmask) & prevmask); 
+
+
+#if (CONFIG_SPICA_REV == CONFIG_SPICA_TEST_REV01)	// Temporary Code by SYS.LSI
+        u32 wake_key;
+
+	if (keypad_sleep_flag) {
+		i = 0;
+		while (press_mask) {
+			if (press_mask & 1) {
+				wake_key = GET_KEYCODE(i+index);
+				if(wake_key == ENDCALL_KEY || wake_key == HOLD_KEY) {
+					keypad_sleep_flag = 0;
+					input_report_key(dev, wake_key,1);
+					DPRINTK(": Pressed (index: %d, Keycode: %d)\n", i+index, GET_KEYCODE(i+index));
+					dprintk(KPD_PRS, ": Pressed (index: %d, Keycode: %d)\n", i+index, GET_KEYCODE(i+index));
+				}
+			}
+			press_mask >>= 1;
+			i++;
+		}
+		i = 0;
+		while (release_mask) {
+			if (release_mask & 1) {
+				wake_key = GET_KEYCODE(i+index);
+				if(wake_key == ENDCALL_KEY || wake_key == HOLD_KEY)
+					input_report_key(dev, wake_key,0);
+				DPRINTK(": Released (index: %d, Keycode: %d)\n", i+index, GET_KEYCODE(i+index));
+				dprintk(KPD_RLS, ": Released (index: %d, Keycode: %d)\n", i+index, GET_KEYCODE(i+index));
+			}
+			release_mask >>= 1;
+			i++;
+		}
+	}
+	else {
+#endif
+		i = 0;
+		while (press_mask) {
+			if (press_mask & 1) {
+				input_report_key(dev, GET_KEYCODE(i+index),1);
+				DPRINTK(": Pressed (index: %d, Keycode: %d)\n", i+index, GET_KEYCODE(i+index));
+			}
+			press_mask >>= 1;
+			i++;
+		}
+
+		i = 0;
+		while (release_mask) {
+			if (release_mask & 1) {
+				input_report_key(dev,GET_KEYCODE(i+index),0);
+				DPRINTK(": Released (index: %d, Keycode: %d)\n", i+index, GET_KEYCODE(i+index));
+			}
+			release_mask >>= 1;
+			i++;
+		}
+#if (CONFIG_SPICA_REV == CONFIG_SPICA_TEST_REV01)	// Temporary Code by SYS.LSI
+	}
+#endif
+}
+
+static inline void process_special_key (struct s3c_keypad *s3c_keypad, u32 keymask_low, u32 keymask_high)
+{
+	struct input_dev              *dev = s3c_keypad->dev;
+	struct s3c_keypad_extra       *extra = s3c_keypad->extra;
+	struct s3c_keypad_special_key *special_key = extra->special_key;
+	static int prev_bitmask = 0;
+	int i;
+
+	for (i=0; i<extra->special_key_num; i++, special_key+=1)
+	{
+	        if (keymask_low == special_key->mask_low 
+		    && keymask_high == special_key->mask_high 
+		    && !(prev_bitmask & (1<<i))) {
+        	        input_report_key(dev, special_key->keycode, 1);
+			DPRINTK(": Pressed (Keycode: %d, SPECIAL KEY)\n", special_key->keycode);
+			prev_bitmask |= (1<<i);
+			continue;
+		}
+		if ((prev_bitmask & (1<<i)) 
+ 		    && keymask_low == 0 
+	    	    && keymask_high == 0)
+		{
+	       	        input_report_key(dev, special_key->keycode, 0);
+			DPRINTK(": Released (Keycode: %d, SPECIAL KEY)\n", special_key->keycode);
+			prev_bitmask ^= (1<<i);
+		}
+	}
+}
+
+static void keypad_timer_handler(unsigned long data)
+{
+	struct s3c_keypad *s3c_keypad = (struct s3c_keypad *)data;
+	u32 keymask_low = 0, keymask_high = 0;
+
+	keypad_scan(&keymask_low, &keymask_high);
+
+	process_special_key(s3c_keypad, keymask_low, keymask_high);
+
+	if (keymask_low != prevmask_low) {
+		process_input_report (s3c_keypad, prevmask_low, keymask_low, 0);
+		prevmask_low = keymask_low;
+	}
+#if (KEYPAD_COLUMNS>4)
+	if (keymask_high != prevmask_high) {
+		process_input_report (s3c_keypad, prevmask_high, keymask_high, 32);
+		prevmask_high = keymask_high;
+	}
+#endif
+
+	if (keymask_low | keymask_high) {
+		mod_timer(&keypad_timer,jiffies + SCAN_INTERVAL);
+	} else {
+		writel(KEYIFCON_INIT, key_base+S3C_KEYIFCON);
+		is_timer_on = FALSE;
+		wake_lock_timeout(&s3c_key_wake_lock, 2 * HZ); // <<yamaia><system><JKCha> : wake lock for keypad scan operation complete
+	}	
+}
+
+static irqreturn_t s3c_keypad_isr(int irq, void *dev_id)
+{
+#ifdef  CONFIG_CPU_FREQ
+	set_dvfs_perf_level();
+#endif
+
+	wake_lock(&s3c_key_wake_lock); // <<yamaia><system><JKCha> : wake lock for keypad scan operation complete
+	
+	/* disable keypad interrupt and schedule for keypad timer handler */
+	writel(readl(key_base+S3C_KEYIFCON) & ~(INT_F_EN|INT_R_EN), key_base+S3C_KEYIFCON);
+
+	keypad_timer.expires = jiffies + FIRST_SCAN_INTERVAL;
+	if ( is_timer_on == FALSE) {
+		add_timer(&keypad_timer);
+		is_timer_on = TRUE;
+	} else {
+		mod_timer(&keypad_timer,keypad_timer.expires);
+	}
+	/*Clear the keypad interrupt status*/
+	writel(KEYIFSTSCLR_CLEAR, key_base+S3C_KEYIFSTSCLR);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t slide_int_handler(int irq, void *dev_id)
+{
+	struct s3c_keypad       *s3c_keypad = (struct s3c_keypad *) dev_id;
+	struct s3c_keypad_slide *slide      = s3c_keypad->extra->slide;
+	int state;
+
+#ifdef  CONFIG_CPU_FREQ
+	set_dvfs_perf_level();
+#endif
+	state = gpio_get_value(slide->gpio) ^ slide->state_upset;
+	DPRINTK(": changed Slide state (%d)\n", state);
+
+	input_report_switch(s3c_keypad->dev, SW_LID, state);
+	input_sync(s3c_keypad->dev);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_int_handler(int irq, void *dev_id)
+{
+	struct s3c_keypad          *s3c_keypad = (struct s3c_keypad *) dev_id;
+	struct input_dev           *dev = s3c_keypad->dev;
+	struct s3c_keypad_extra    *extra = s3c_keypad->extra;
+	struct s3c_keypad_gpio_key *gpio_key = extra->gpio_key;
+	int i,state;
+
+       	DPRINTK(": gpio interrupt (IRQ: %d)\n", irq);
+
+#ifdef  CONFIG_CPU_FREQ
+	set_dvfs_perf_level();
+#endif
+	for (i=0; i<extra->gpio_key_num; i++)
+	{
+		if (gpio_key[i].eint == irq)
+		{
+			gpio_key = &gpio_key[i];
+			break;
+		}
+	}
+
+	if (gpio_key != NULL)
+	{
+		state = gpio_get_value(gpio_key->gpio);
+               	DPRINTK(": gpio state (%d, %d)\n", state , state ^ gpio_key->state_upset);
+		state ^= gpio_key->state_upset;
+
+	        if(state) {
+        	        input_report_key(dev, gpio_key->keycode, 1);
+                	DPRINTK(": Pressed (Keycode: %d, GPIO KEY)\n", gpio_key->keycode);
+	        }
+        	else  {
+	                input_report_key(dev, gpio_key->keycode, 0);
+        	        DPRINTK(": Released (Keycode: %d, GPIO KEY)\n", gpio_key->keycode);
+	        }
+	}
+ 
+        return IRQ_HANDLED;
+}
+
+static int __init s3c_keypad_probe(struct platform_device *pdev)
+{
+	struct resource *res, *keypad_mem, *keypad_irq = NULL;
+	struct input_dev *input_dev;
+	struct s3c_keypad *s3c_keypad;
+	int ret, size, key;
+	struct s3c_keypad_extra    	*extra = NULL;
+	struct s3c_keypad_slide    	*slide = NULL;
+	struct s3c_keypad_special_key    *special_key;
+	struct s3c_keypad_gpio_key 	*gpio_key;
+	int i;
+	char * input_dev_name;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev,"no memory resource specified\n");
+		return -ENOENT;
+	}
+
+	size = (res->end - res->start) + 1;
+
+	keypad_mem = request_mem_region(res->start, size, pdev->name);
+	if (keypad_mem == NULL) {
+		dev_err(&pdev->dev, "failed to get memory region\n");
+		ret = -ENOENT;
+		goto err_req;
+	}
+
+	key_base = ioremap(res->start, size);
+	if (key_base == NULL) {
+		printk(KERN_ERR "Failed to remap register block\n");
+		ret = -ENOMEM;
+		goto err_map;
+	}
+
+	keypad_clock = clk_get(&pdev->dev, "keypad");
+	if (IS_ERR(keypad_clock)) {
+		dev_err(&pdev->dev, "failed to find keypad clock source\n");
+		ret = PTR_ERR(keypad_clock);
+		goto err_clk;
+	}
+
+	clk_enable(keypad_clock);
+	
+	s3c_keypad = kzalloc(sizeof(struct s3c_keypad), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	input_dev_name = (char *)kmalloc(sizeof("s3c-keypad-revxxxx"), GFP_KERNEL);
+
+	if (!s3c_keypad || !input_dev || !input_dev_name) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	platform_set_drvdata(pdev, s3c_keypad);
+
+	DPRINTK(": system_rev 0x%04x\n", system_rev);
+	for (i=0; i<sizeof(s3c_keypad_extra)/sizeof(struct s3c_keypad_extra); i++)
+	{
+//		if (s3c_keypad_extra[i].board_num == g_board_num) {
+		if (s3c_keypad_extra[i].board_num == system_rev) {
+			extra = &s3c_keypad_extra[i];
+			sprintf(input_dev_name, "%s%s%04x", DEVICE_NAME, "-rev", system_rev); 
+			DPRINTK(": board rev 0x%04x is detected!\n", s3c_keypad_extra[i].board_num);
+			break;
+		}
+	}
+
+	if(!extra) {
+		extra = &s3c_keypad_extra[0];
+		sprintf(input_dev_name, "%s%s", DEVICE_NAME, "-rev0000"); 			//default revison 
+		DPRINTK(": failed to detect board rev. set default rev00\n");
+	}
+	DPRINTK(": input device name: %s.\n", input_dev_name);
+
+	s3c_keypad->dev = input_dev;
+	s3c_keypad->extra = extra;
+	slide = extra->slide;
+	special_key = extra->special_key;
+	gpio_key = extra->gpio_key;
+
+	writel(KEYIFCON_INIT, key_base+S3C_KEYIFCON);
+	writel(KEYIFFC_DIV, key_base+S3C_KEYIFFC);
+
+	/* Set GPIO Port for keypad mode and pull-up disable*/
+	s3c_setup_keypad_cfg_gpio(KEYPAD_ROWS, KEYPAD_COLUMNS);
+
+	writel(KEYIFCOL_CLEAR, key_base+S3C_KEYIFCOL);
+
+	for(key = 200; key < 232; key++){
+        	input_set_capability(input_dev, EV_KEY, key+1);
+	}
+
+	for (i=0; i<extra->special_key_num; i++ ){
+        	input_set_capability(input_dev, EV_KEY, (special_key+i)->keycode);
+	}
+
+	for (i=0; i<extra->gpio_key_num; i++ ){
+        	input_set_capability(input_dev, EV_KEY, (gpio_key+i)->keycode);
+	}
+
+	if (extra->slide != NULL)
+        	input_set_capability(input_dev, EV_SW, SW_LID);
+
+	input_dev->name = input_dev_name;
+	input_dev->phys = "s3c-keypad/input0";
+	
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->id.vendor = 0x0001;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0001;
+
+	/* Scan timer init */
+	init_timer(&keypad_timer);
+	keypad_timer.function = keypad_timer_handler;
+	keypad_timer.data = (unsigned long)s3c_keypad;
+
+	/* For IRQ_KEYPAD */
+	keypad_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (keypad_irq == NULL) {
+		dev_err(&pdev->dev, "no irq resource specified\n");
+		ret = -ENOENT;
+		goto err_clk;
+	}
+
+	if (slide != NULL)
+	{
+
+		s3c_gpio_cfgpin(slide->gpio, S3C_GPIO_SFN(slide->gpio_af));
+		s3c_gpio_setpull(slide->gpio, S3C_GPIO_PULL_NONE);
+
+		set_irq_type(slide->eint, IRQ_TYPE_EDGE_BOTH);
+
+		ret = request_irq(slide->eint, slide_int_handler, IRQF_DISABLED,
+		    "s3c_keypad gpio key", (void *)s3c_keypad);
+		if (ret) {
+			printk(KERN_ERR "request_irq(%d) failed (IRQ for SLIDE) !!!\n", slide->eint);
+			ret = -EIO;
+			goto err_irq;
+		}
+	}
+
+	for (i=0; i<extra->gpio_key_num; i++, gpio_key+=1)
+	{
+		s3c_gpio_cfgpin(gpio_key->gpio, S3C_GPIO_SFN(gpio_key->gpio_af));
+		s3c_gpio_setpull(gpio_key->gpio, S3C_GPIO_PULL_NONE);
+
+		set_irq_type(gpio_key->eint, IRQ_TYPE_EDGE_BOTH);
+
+		ret = request_irq(gpio_key->eint, gpio_int_handler, IRQF_DISABLED,
+			    "s3c_keypad gpio key", (void *)s3c_keypad);
+		if (ret) {
+			printk(KERN_ERR "request_irq(%d) failed (IRQ for GPIO KEY) !!!\n", gpio_key->eint);
+			ret = -EIO;
+			goto err_irq;
+		}
+	}
+
+	ret = request_irq(keypad_irq->start, s3c_keypad_isr, IRQF_SAMPLE_RANDOM,
+		DEVICE_NAME, (void *) pdev);
+	if (ret) {
+		printk("request_irq failed (IRQ_KEYPAD) !!!\n");
+		ret = -EIO;
+		goto err_irq;
+	}
+
+	ret = input_register_device(input_dev);
+	if (ret) {
+		printk("Unable to register s3c-keypad input device!!!\n");
+		goto out;
+	}
+
+	keypad_timer.expires = jiffies + (HZ/10);
+
+	if (is_timer_on == FALSE) {
+		add_timer(&keypad_timer);
+		is_timer_on = TRUE;
+	} else {
+		mod_timer(&keypad_timer,keypad_timer.expires);
+	}
+
+	printk( DEVICE_NAME " Initialized\n");
+	return 0;
+
+out:
+	input_free_device(input_dev);
+	kfree(s3c_keypad);
+
+err_irq:
+	free_irq(keypad_irq->start, input_dev);
+	free_irq(keypad_irq->end, input_dev);
+
+	if (slide != NULL)
+		free_irq(extra->slide->eint, s3c_keypad);
+
+	gpio_key = extra->gpio_key;
+	for (i=0; i<extra->gpio_key_num; i++, gpio_key+=1)
+		free_irq(gpio_key->eint, s3c_keypad);
+	
+err_clk:
+	clk_disable(keypad_clock);
+	clk_put(keypad_clock);
+
+err_map:
+	iounmap(key_base);
+
+err_req:
+	release_resource(keypad_mem);
+	kfree(keypad_mem);
+
+	return ret;
+}
+
+static int s3c_keypad_remove(struct platform_device *pdev)
+{
+	struct s3c_keypad *s3c_keypad = platform_get_drvdata(pdev);
+	struct input_dev  *dev        = s3c_keypad->dev;
+	struct s3c_keypad_extra *extra = s3c_keypad->extra;
+	struct s3c_keypad_slide *slide = extra->slide;
+	struct s3c_keypad_gpio_key *gpio_key = extra->gpio_key;
+
+	writel(KEYIFCON_CLEAR, key_base+S3C_KEYIFCON);
+
+	if(keypad_clock) {
+		clk_disable(keypad_clock);
+		clk_put(keypad_clock);
+		keypad_clock = NULL;
+	}
+
+	free_irq(IRQ_KEYPAD, (void *) s3c_keypad);
+
+	del_timer(&keypad_timer);	
+
+	if (slide)
+	        free_irq(slide->eint, (void *) s3c_keypad);
+
+	if (gpio_key)
+	{
+		int i;
+		for (i=0; i<extra->gpio_key_num; i++, gpio_key+=1)
+        		free_irq(gpio_key->eint, (void *) s3c_keypad);
+	}
+
+	input_unregister_device(dev);
+	iounmap(key_base);
+	kfree(s3c_keypad);
+
+	printk(DEVICE_NAME " Removed.\n");
+	return 0;
+}
+
+#ifdef CONFIG_PM
+#include <plat/pm.h>
+
+static struct sleep_save s3c_keypad_save[] = {
+	SAVE_ITEM(KEYPAD_ROW_GPIOCON),
+	SAVE_ITEM(KEYPAD_COL_GPIOCON),
+	SAVE_ITEM(KEYPAD_ROW_GPIOPUD),
+	SAVE_ITEM(KEYPAD_COL_GPIOPUD),
+};
+
+static int s3c_keypad_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct s3c_keypad *s3c_keypad = platform_get_drvdata(pdev);
+	struct s3c_keypad_extra *extra = s3c_keypad->extra;
+	struct s3c_keypad_slide *slide = extra->slide;
+	struct s3c_keypad_gpio_key *gpio_key = extra->gpio_key;
+
+	keypad_sleep_flag = 1;
+
+	writel(KEYIFCON_CLEAR, key_base+S3C_KEYIFCON);
+
+	s3c6410_pm_do_save(s3c_keypad_save, ARRAY_SIZE(s3c_keypad_save));
+	
+	if (!extra->wakeup_by_keypad)
+	{
+		writel(~(0x0fffffff), KEYPAD_ROW_GPIOCON);
+		writel(~(0xffffffff), KEYPAD_COL_GPIOCON);
+	}
+	
+	disable_irq(IRQ_KEYPAD);
+
+	if (slide)
+		disable_irq(slide->eint);
+
+	if (gpio_key)
+	{
+		int i;
+		for (i=0; i<extra->gpio_key_num; i++, gpio_key+=1)
+        		disable_irq(gpio_key->eint);
+	}
+
+	clk_disable(keypad_clock);
+
+	return 0;
+}
+
+static int s3c_keypad_resume(struct platform_device *pdev)
+{
+	struct s3c_keypad *s3c_keypad = platform_get_drvdata(pdev);
+	struct s3c_keypad_extra *extra = s3c_keypad->extra;
+	struct s3c_keypad_slide *slide = extra->slide;
+	struct s3c_keypad_gpio_key *gpio_key = extra->gpio_key;
+
+	clk_enable(keypad_clock);
+
+	if (is_timer_on)
+		del_timer (&keypad_timer);
+	is_timer_on = TRUE;
+	prevmask_low = 0;
+	prevmask_high = 0;
+	s3c_keypad_isr (0, NULL);
+	
+	enable_irq(IRQ_KEYPAD);
+
+	if (slide)
+	{
+		enable_irq(slide->eint);
+		slide_int_handler (slide->eint, (void *) s3c_keypad);
+	}
+
+	if (gpio_key)
+	{
+		int i;
+		for (i=0; i<extra->gpio_key_num; i++, gpio_key+=1)
+		{
+        		enable_irq(gpio_key->eint);
+			gpio_int_handler (gpio_key->eint, (void *) s3c_keypad);
+		}
+	}
+
+
+	writel(KEYIFCON_INIT, key_base+S3C_KEYIFCON);
+	writel(KEYIFFC_DIV, key_base+S3C_KEYIFFC);
+
+	s3c6410_pm_do_restore(s3c_keypad_save, ARRAY_SIZE(s3c_keypad_save));
+
+	writel(KEYIFCOL_CLEAR, key_base+S3C_KEYIFCOL);
+
+	return 0;
+}
+#else
+#define s3c_keypad_suspend NULL
+#define s3c_keypad_resume  NULL
+#endif /* CONFIG_PM */
+
+static struct platform_driver s3c_keypad_driver = {
+	.probe		= s3c_keypad_probe,
+	.remove		= s3c_keypad_remove,
+	.suspend	= s3c_keypad_suspend,
+	.resume		= s3c_keypad_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c-keypad",
+	},
+};
+
+static int __init s3c_keypad_init(void)
+{
+	int ret;
+
+	// <<yamaia><system><JKCha><jswoo> : wake lock Init for keypad scan operation complete
+	wake_lock_init(&s3c_key_wake_lock, WAKE_LOCK_SUSPEND,"s3c-keypad");
+
+	ret = platform_driver_register(&s3c_keypad_driver);
+	
+	if(!ret)
+	   printk(KERN_INFO "S3C Keypad Driver\n");
+
+	return ret;
+}
+
+static void __exit s3c_keypad_exit(void)
+{
+	platform_driver_unregister(&s3c_keypad_driver);
+}
+
+module_init(s3c_keypad_init);
+module_exit(s3c_keypad_exit);
+
+MODULE_AUTHOR("Samsung");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("KeyPad interface for Samsung S3C");
diff -Nur linux-2.6.29/drivers/input/keyboard/s3c-keypad.h linux-2.6.29-spica/drivers/input/keyboard/s3c-keypad.h
--- linux-2.6.29/drivers/input/keyboard/s3c-keypad.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/input/keyboard/s3c-keypad.h	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,79 @@
+/* linux/drivers/input/keyboard/s3c-keypad.h 
+ *
+ * Driver header for Samsung SoC keypad.
+ *
+ * Kim Kyoungil, Copyright (c) 2006-2009 Samsung Electronics
+ *      http://www.samsungsemi.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef _S3C_KEYPAD_H_
+#define _S3C_KEYPAD_H_
+
+static void __iomem *key_base;
+
+#define GET_KEYCODE(x)                  (x+201)
+
+#define KEYCODE_DUMPKEY	247
+#define KEYCODE_SENDEND	248
+#define KEYCODE_ENDCALL	249
+#define KEYCODE_FOCUS	250
+#define KEYCODE_HOLDKEY	251
+
+#define KEYPAD_ROW_GPIOCON      S3C64XX_GPKCON1
+#define KEYPAD_ROW_GPIOPUD      S3C64XX_GPKPUD
+#define KEYPAD_COL_GPIOCON      S3C64XX_GPLCON
+#define KEYPAD_COL_GPIOPUD      S3C64XX_GPLPUD
+
+#define KEYPAD_DELAY		(50)
+#define	KEYIFCOL_CLEAR		(readl(key_base+S3C_KEYIFCOL) & ~0xffff)
+#define	KEYIFCON_CLEAR		(readl(key_base+S3C_KEYIFCON) & ~0x1f)
+#define KEYIFFC_DIV			(readl(key_base+S3C_KEYIFFC) | 0x1)
+
+struct s3c_keypad_slide
+{
+    int     eint;
+    int     gpio;
+    int     gpio_af;
+    int     state_upset;
+};
+
+struct s3c_keypad_special_key
+{
+    int     mask_low;
+    int     mask_high;
+    int     keycode;
+};
+ 
+struct s3c_keypad_gpio_key
+{
+    int     eint;
+    int     gpio;
+    int     gpio_af;
+	int		keycode;
+	int     state_upset;
+};
+
+struct s3c_keypad_extra 
+{
+	int 	board_num;
+	struct 	s3c_keypad_slide		*slide;
+	struct 	s3c_keypad_special_key	*special_key;
+	int		special_key_num;
+	struct 	s3c_keypad_gpio_key	*gpio_key;
+	int		gpio_key_num;
+	int		wakeup_by_keypad;
+};
+
+struct s3c_keypad {
+	struct 	input_dev 	*dev;
+	struct 	s3c_keypad_extra *extra;
+};
+
+extern void s3c_setup_keypad_cfg_gpio(int rows, int columns);
+
+#endif				/* _S3C_KEYIF_H_ */
diff -Nur linux-2.6.29/drivers/input/keyreset.c linux-2.6.29-spica/drivers/input/keyreset.c
--- linux-2.6.29/drivers/input/keyreset.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/input/keyreset.c	2010-03-30 11:00:31.000000000 +0700
@@ -0,0 +1,229 @@
+/* drivers/input/keyreset.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/input.h>
+#include <linux/keyreset.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/reboot.h>
+#include <linux/sched.h>
+#include <linux/syscalls.h>
+
+
+struct keyreset_state {
+	struct input_handler input_handler;
+	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
+	unsigned long upbit[BITS_TO_LONGS(KEY_CNT)];
+	unsigned long key[BITS_TO_LONGS(KEY_CNT)];
+	spinlock_t lock;
+	int key_down_target;
+	int key_down;
+	int key_up;
+	int restart_disabled;
+};
+
+int restart_requested;
+static void deferred_restart(struct work_struct *dummy)
+{
+	restart_requested = 2;
+	sys_sync();
+	restart_requested = 3;
+	kernel_restart(NULL);
+}
+static DECLARE_WORK(restart_work, deferred_restart);
+
+static void keyreset_event(struct input_handle *handle, unsigned int type,
+			   unsigned int code, int value)
+{
+	unsigned long flags;
+	struct keyreset_state *state = handle->private;
+
+	if (type != EV_KEY)
+		return;
+
+	if (code >= KEY_MAX)
+		return;
+
+	if (!test_bit(code, state->keybit))
+		return;
+
+	spin_lock_irqsave(&state->lock, flags);
+	if (!test_bit(code, state->key) == !value)
+		goto done;
+	__change_bit(code, state->key);
+	if (test_bit(code, state->upbit)) {
+		if (value) {
+			state->restart_disabled = 1;
+			state->key_up++;
+		} else
+			state->key_up--;
+	} else {
+		if (value)
+			state->key_down++;
+		else
+			state->key_down--;
+	}
+	if (state->key_down == 0 && state->key_up == 0)
+		state->restart_disabled = 0;
+
+	pr_debug("reset key changed %d %d new state %d-%d-%d\n", code, value,
+		 state->key_down, state->key_up, state->restart_disabled);
+
+	if (value && !state->restart_disabled &&
+	    state->key_down == state->key_down_target) {
+		state->restart_disabled = 1;
+		if (restart_requested)
+			panic("keyboard reset failed, %d", restart_requested);
+		pr_info("keyboard reset\n");
+		schedule_work(&restart_work);
+		restart_requested = 1;
+	}
+done:
+	spin_unlock_irqrestore(&state->lock, flags);
+}
+
+static int keyreset_connect(struct input_handler *handler,
+					  struct input_dev *dev,
+					  const struct input_device_id *id)
+{
+	int i;
+	int ret;
+	struct input_handle *handle;
+	struct keyreset_state *state =
+		container_of(handler, struct keyreset_state, input_handler);
+
+	for (i = 0; i < KEY_MAX; i++) {
+		if (test_bit(i, state->keybit) && test_bit(i, dev->keybit))
+			break;
+	}
+	if (i == KEY_MAX)
+		return -ENODEV;
+
+	handle = kzalloc(sizeof(*handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = "keyreset";
+	handle->private = state;
+
+	ret = input_register_handle(handle);
+	if (ret)
+		goto err_input_register_handle;
+
+	ret = input_open_device(handle);
+	if (ret)
+		goto err_input_open_device;
+
+	pr_info("using input dev %s for key reset\n", dev->name);
+
+	return 0;
+
+err_input_open_device:
+	input_unregister_handle(handle);
+err_input_register_handle:
+	kfree(handle);
+	return ret;
+}
+
+static void keyreset_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+static const struct input_device_id keyreset_ids[] = {
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(input, keyreset_ids);
+
+static int keyreset_probe(struct platform_device *pdev)
+{
+	int ret;
+	int key, *keyp;
+	struct keyreset_state *state;
+	struct keyreset_platform_data *pdata = pdev->dev.platform_data;
+
+	if (!pdata)
+		return -EINVAL;
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+
+	spin_lock_init(&state->lock);
+	keyp = pdata->keys_down;
+	while ((key = *keyp++)) {
+		if (key >= KEY_MAX)
+			continue;
+		state->key_down_target++;
+		__set_bit(key, state->keybit);
+	}
+	if (pdata->keys_up) {
+		keyp = pdata->keys_up;
+		while ((key = *keyp++)) {
+			if (key >= KEY_MAX)
+				continue;
+			__set_bit(key, state->keybit);
+			__set_bit(key, state->upbit);
+		}
+	}
+	state->input_handler.event = keyreset_event;
+	state->input_handler.connect = keyreset_connect;
+	state->input_handler.disconnect = keyreset_disconnect;
+	state->input_handler.name = KEYRESET_NAME;
+	state->input_handler.id_table = keyreset_ids;
+	ret = input_register_handler(&state->input_handler);
+	if (ret) {
+		kfree(state);
+		return ret;
+	}
+	platform_set_drvdata(pdev, state);
+	return 0;
+}
+
+int keyreset_remove(struct platform_device *pdev)
+{
+	struct keyreset_state *state = platform_get_drvdata(pdev);
+	input_unregister_handler(&state->input_handler);
+	kfree(state);
+	return 0;
+}
+
+
+struct platform_driver keyreset_driver = {
+	.driver.name = KEYRESET_NAME,
+	.probe = keyreset_probe,
+	.remove = keyreset_remove,
+};
+
+static int __init keyreset_init(void)
+{
+	return platform_driver_register(&keyreset_driver);
+}
+
+static void __exit keyreset_exit(void)
+{
+	return platform_driver_unregister(&keyreset_driver);
+}
+
+module_init(keyreset_init);
+module_exit(keyreset_exit);
diff -Nur linux-2.6.29/drivers/input/Makefile linux-2.6.29-spica/drivers/input/Makefile
--- linux-2.6.29/drivers/input/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/input/Makefile	2010-03-30 11:00:31.000000000 +0700
@@ -23,5 +23,6 @@
 obj-$(CONFIG_INPUT_MISC)	+= misc/
 
 obj-$(CONFIG_INPUT_APMPOWER)	+= apm-power.o
+obj-$(CONFIG_INPUT_KEYRESET)	+= keyreset.o
 
 obj-$(CONFIG_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
diff -Nur linux-2.6.29/drivers/input/misc/gpio_axis.c linux-2.6.29-spica/drivers/input/misc/gpio_axis.c
--- linux-2.6.29/drivers/input/misc/gpio_axis.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/input/misc/gpio_axis.c	2010-03-30 11:00:32.000000000 +0700
@@ -0,0 +1,191 @@
+/* drivers/input/misc/gpio_axis.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/interrupt.h>
+
+struct gpio_axis_state {
+	struct gpio_event_input_devs *input_devs;
+	struct gpio_event_axis_info *info;
+	uint32_t pos;
+};
+
+uint16_t gpio_axis_4bit_gray_map_table[] = {
+	[0x0] = 0x0, [0x1] = 0x1, /* 0000 0001 */
+	[0x3] = 0x2, [0x2] = 0x3, /* 0011 0010 */
+	[0x6] = 0x4, [0x7] = 0x5, /* 0110 0111 */
+	[0x5] = 0x6, [0x4] = 0x7, /* 0101 0100 */
+	[0xc] = 0x8, [0xd] = 0x9, /* 1100 1101 */
+	[0xf] = 0xa, [0xe] = 0xb, /* 1111 1110 */
+	[0xa] = 0xc, [0xb] = 0xd, /* 1010 1011 */
+	[0x9] = 0xe, [0x8] = 0xf, /* 1001 1000 */
+};
+uint16_t gpio_axis_4bit_gray_map(struct gpio_event_axis_info *info, uint16_t in)
+{
+	return gpio_axis_4bit_gray_map_table[in];
+}
+
+uint16_t gpio_axis_5bit_singletrack_map_table[] = {
+	[0x10] = 0x00, [0x14] = 0x01, [0x1c] = 0x02, /*     10000 10100 11100 */
+	[0x1e] = 0x03, [0x1a] = 0x04, [0x18] = 0x05, /*     11110 11010 11000 */
+	[0x08] = 0x06, [0x0a] = 0x07, [0x0e] = 0x08, /*    01000 01010 01110  */
+	[0x0f] = 0x09, [0x0d] = 0x0a, [0x0c] = 0x0b, /*    01111 01101 01100  */
+	[0x04] = 0x0c, [0x05] = 0x0d, [0x07] = 0x0e, /*   00100 00101 00111   */
+	[0x17] = 0x0f, [0x16] = 0x10, [0x06] = 0x11, /*   10111 10110 00110   */
+	[0x02] = 0x12, [0x12] = 0x13, [0x13] = 0x14, /*  00010 10010 10011    */
+	[0x1b] = 0x15, [0x0b] = 0x16, [0x03] = 0x17, /*  11011 01011 00011    */
+	[0x01] = 0x18, [0x09] = 0x19, [0x19] = 0x1a, /* 00001 01001 11001     */
+	[0x1d] = 0x1b, [0x15] = 0x1c, [0x11] = 0x1d, /* 11101 10101 10001     */
+};
+uint16_t gpio_axis_5bit_singletrack_map(
+	struct gpio_event_axis_info *info, uint16_t in)
+{
+	return gpio_axis_5bit_singletrack_map_table[in];
+}
+
+static void gpio_event_update_axis(struct gpio_axis_state *as, int report)
+{
+	struct gpio_event_axis_info *ai = as->info;
+	int i;
+	int change;
+	uint16_t state = 0;
+	uint16_t pos;
+	uint16_t old_pos = as->pos;
+	for (i = ai->count - 1; i >= 0; i--)
+		state = (state << 1) | gpio_get_value(ai->gpio[i]);
+	pos = ai->map(ai, state);
+	if (ai->flags & GPIOEAF_PRINT_RAW)
+		pr_info("axis %d-%d raw %x, pos %d -> %d\n",
+			ai->type, ai->code, state, old_pos, pos);
+	if (report && pos != old_pos) {
+		if (ai->type == EV_REL) {
+			change = (ai->decoded_size + pos - old_pos) %
+				  ai->decoded_size;
+			if (change > ai->decoded_size / 2)
+				change -= ai->decoded_size;
+			if (change == ai->decoded_size / 2) {
+				if (ai->flags & GPIOEAF_PRINT_EVENT)
+					pr_info("axis %d-%d unknown direction, "
+						"pos %d -> %d\n", ai->type,
+						ai->code, old_pos, pos);
+				change = 0; /* no closest direction */
+			}
+			if (ai->flags & GPIOEAF_PRINT_EVENT)
+				pr_info("axis %d-%d change %d\n",
+					ai->type, ai->code, change);
+			input_report_rel(as->input_devs->dev[ai->dev],
+						ai->code, change);
+		} else {
+			if (ai->flags & GPIOEAF_PRINT_EVENT)
+				pr_info("axis %d-%d now %d\n",
+					ai->type, ai->code, pos);
+			input_event(as->input_devs->dev[ai->dev],
+					ai->type, ai->code, pos);
+		}
+		input_sync(as->input_devs->dev[ai->dev]);
+	}
+	as->pos = pos;
+}
+
+static irqreturn_t gpio_axis_irq_handler(int irq, void *dev_id)
+{
+	struct gpio_axis_state *as = dev_id;
+	gpio_event_update_axis(as, 1);
+	return IRQ_HANDLED;
+}
+
+int gpio_event_axis_func(struct gpio_event_input_devs *input_devs,
+			 struct gpio_event_info *info, void **data, int func)
+{
+	int ret;
+	int i;
+	int irq;
+	struct gpio_event_axis_info *ai;
+	struct gpio_axis_state *as;
+
+	ai = container_of(info, struct gpio_event_axis_info, info);
+	if (func == GPIO_EVENT_FUNC_SUSPEND) {
+		for (i = 0; i < ai->count; i++)
+			disable_irq(gpio_to_irq(ai->gpio[i]));
+		return 0;
+	}
+	if (func == GPIO_EVENT_FUNC_RESUME) {
+		for (i = 0; i < ai->count; i++)
+			enable_irq(gpio_to_irq(ai->gpio[i]));
+		return 0;
+	}
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		*data = as = kmalloc(sizeof(*as), GFP_KERNEL);
+		if (as == NULL) {
+			ret = -ENOMEM;
+			goto err_alloc_axis_state_failed;
+		}
+		as->input_devs = input_devs;
+		as->info = ai;
+		if (ai->dev >= input_devs->count) {
+			pr_err("gpio_event_axis: bad device index %d >= %d "
+				"for %d:%d\n", ai->dev, input_devs->count,
+				ai->type, ai->code);
+			ret = -EINVAL;
+			goto err_bad_device_index;
+		}
+
+		input_set_capability(input_devs->dev[ai->dev],
+				     ai->type, ai->code);
+		if (ai->type == EV_ABS) {
+			input_set_abs_params(input_devs->dev[ai->dev], ai->code,
+					     0, ai->decoded_size - 1, 0, 0);
+		}
+		for (i = 0; i < ai->count; i++) {
+			ret = gpio_request(ai->gpio[i], "gpio_event_axis");
+			if (ret < 0)
+				goto err_request_gpio_failed;
+			ret = gpio_direction_input(ai->gpio[i]);
+			if (ret < 0)
+				goto err_gpio_direction_input_failed;
+			ret = irq = gpio_to_irq(ai->gpio[i]);
+			if (ret < 0)
+				goto err_get_irq_num_failed;
+			ret = request_irq(irq, gpio_axis_irq_handler,
+					  IRQF_TRIGGER_RISING |
+					  IRQF_TRIGGER_FALLING,
+					  "gpio_event_axis", as);
+			if (ret < 0)
+				goto err_request_irq_failed;
+		}
+		gpio_event_update_axis(as, 0);
+		return 0;
+	}
+
+	ret = 0;
+	as = *data;
+	for (i = ai->count - 1; i >= 0; i--) {
+		free_irq(gpio_to_irq(ai->gpio[i]), as);
+err_request_irq_failed:
+err_get_irq_num_failed:
+err_gpio_direction_input_failed:
+		gpio_free(ai->gpio[i]);
+err_request_gpio_failed:
+		;
+	}
+err_bad_device_index:
+	kfree(as);
+	*data = NULL;
+err_alloc_axis_state_failed:
+	return ret;
+}
diff -Nur linux-2.6.29/drivers/input/misc/gpio_event.c linux-2.6.29-spica/drivers/input/misc/gpio_event.c
--- linux-2.6.29/drivers/input/misc/gpio_event.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/input/misc/gpio_event.c	2010-03-30 11:00:32.000000000 +0700
@@ -0,0 +1,259 @@
+/* drivers/input/misc/gpio_event.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/earlysuspend.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/gpio_event.h>
+#include <linux/hrtimer.h>
+#include <linux/platform_device.h>
+
+struct gpio_event {
+	struct gpio_event_input_devs *input_devs;
+	const struct gpio_event_platform_data *info;
+	struct early_suspend early_suspend;
+	void *state[0];
+};
+
+static int gpio_input_event(
+	struct input_dev *dev, unsigned int type, unsigned int code, int value)
+{
+	int i;
+	int devnr;
+	int ret = 0;
+	int tmp_ret;
+	struct gpio_event_info **ii;
+	struct gpio_event *ip = input_get_drvdata(dev);
+
+	for (devnr = 0; devnr < ip->input_devs->count; devnr++)
+		if (ip->input_devs->dev[devnr] == dev)
+			break;
+	if (devnr == ip->input_devs->count) {
+		pr_err("gpio_input_event: unknown device %p\n", dev);
+		return -EIO;
+	}
+
+	for (i = 0, ii = ip->info->info; i < ip->info->info_count; i++, ii++) {
+		if ((*ii)->event) {
+			tmp_ret = (*ii)->event(ip->input_devs, *ii,
+						&ip->state[i],
+						devnr, type, code, value);
+			if (tmp_ret)
+				ret = tmp_ret;
+		}
+	}
+	return ret;
+}
+
+static int gpio_event_call_all_func(struct gpio_event *ip, int func)
+{
+	int i;
+	int ret;
+	struct gpio_event_info **ii;
+
+	if (func == GPIO_EVENT_FUNC_INIT || func == GPIO_EVENT_FUNC_RESUME) {
+		ii = ip->info->info;
+		for (i = 0; i < ip->info->info_count; i++, ii++) {
+			if ((*ii)->func == NULL) {
+				ret = -ENODEV;
+				pr_err("gpio_event_probe: Incomplete pdata, "
+					"no function\n");
+				goto err_no_func;
+			}
+			if (func == GPIO_EVENT_FUNC_RESUME && (*ii)->no_suspend)
+				continue;
+			ret = (*ii)->func(ip->input_devs, *ii, &ip->state[i],
+					  func);
+			if (ret) {
+				pr_err("gpio_event_probe: function failed\n");
+				goto err_func_failed;
+			}
+		}
+		return 0;
+	}
+
+	ret = 0;
+	i = ip->info->info_count;
+	ii = ip->info->info + i;
+	while (i > 0) {
+		i--;
+		ii--;
+		if ((func & ~1) == GPIO_EVENT_FUNC_SUSPEND && (*ii)->no_suspend)
+			continue;
+		(*ii)->func(ip->input_devs, *ii, &ip->state[i], func & ~1);
+err_func_failed:
+err_no_func:
+		;
+	}
+	return ret;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void gpio_event_suspend(struct early_suspend *h)
+{
+	struct gpio_event *ip;
+	ip = container_of(h, struct gpio_event, early_suspend);
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_SUSPEND);
+	ip->info->power(ip->info, 0);
+}
+
+void gpio_event_resume(struct early_suspend *h)
+{
+	struct gpio_event *ip;
+	ip = container_of(h, struct gpio_event, early_suspend);
+	ip->info->power(ip->info, 1);
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_RESUME);
+}
+#endif
+
+static int __init gpio_event_probe(struct platform_device *pdev)
+{
+	int err;
+	struct gpio_event *ip;
+	struct gpio_event_platform_data *event_info;
+	int dev_count = 1;
+	int i;
+	int registered = 0;
+
+	event_info = pdev->dev.platform_data;
+	if (event_info == NULL) {
+		pr_err("gpio_event_probe: No pdata\n");
+		return -ENODEV;
+	}
+	if ((!event_info->name && !event_info->names[0]) ||
+	    !event_info->info || !event_info->info_count) {
+		pr_err("gpio_event_probe: Incomplete pdata\n");
+		return -ENODEV;
+	}
+	if (!event_info->name)
+		while (event_info->names[dev_count])
+			dev_count++;
+	ip = kzalloc(sizeof(*ip) +
+		     sizeof(ip->state[0]) * event_info->info_count +
+		     sizeof(*ip->input_devs) +
+		     sizeof(ip->input_devs->dev[0]) * dev_count, GFP_KERNEL);
+	if (ip == NULL) {
+		err = -ENOMEM;
+		pr_err("gpio_event_probe: Failed to allocate private data\n");
+		goto err_kp_alloc_failed;
+	}
+	ip->input_devs = (void*)&ip->state[event_info->info_count];
+	platform_set_drvdata(pdev, ip);
+
+	for (i = 0; i < dev_count; i++) {
+		struct input_dev *input_dev = input_allocate_device();
+		if (input_dev == NULL) {
+			err = -ENOMEM;
+			pr_err("gpio_event_probe: "
+				"Failed to allocate input device\n");
+			goto err_input_dev_alloc_failed;
+		}
+		input_set_drvdata(input_dev, ip);
+		input_dev->name = event_info->name ?
+					event_info->name : event_info->names[i];
+		input_dev->event = gpio_input_event;
+		ip->input_devs->dev[i] = input_dev;
+	}
+	ip->input_devs->count = dev_count;
+	ip->info = event_info;
+	if (event_info->power) {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+		ip->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+		ip->early_suspend.suspend = gpio_event_suspend;
+		ip->early_suspend.resume = gpio_event_resume;
+		register_early_suspend(&ip->early_suspend);
+#endif
+		ip->info->power(ip->info, 1);
+	}
+
+	err = gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_INIT);
+	if (err)
+		goto err_call_all_func_failed;
+
+	for (i = 0; i < dev_count; i++) {
+		err = input_register_device(ip->input_devs->dev[i]);
+		if (err) {
+			pr_err("gpio_event_probe: Unable to register %s "
+				"input device\n", ip->input_devs->dev[i]->name);
+			goto err_input_register_device_failed;
+		}
+		registered++;
+	}
+
+	return 0;
+
+err_input_register_device_failed:
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_UNINIT);
+err_call_all_func_failed:
+	if (event_info->power) {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&ip->early_suspend);
+#endif
+		ip->info->power(ip->info, 0);
+	}
+	for (i = 0; i < registered; i++)
+		input_unregister_device(ip->input_devs->dev[i]);
+	for (i = dev_count - 1; i >= registered; i--) {
+		input_free_device(ip->input_devs->dev[i]);
+err_input_dev_alloc_failed:
+		;
+	}
+	kfree(ip);
+err_kp_alloc_failed:
+	return err;
+}
+
+static int gpio_event_remove(struct platform_device *pdev)
+{
+	struct gpio_event *ip = platform_get_drvdata(pdev);
+	int i;
+
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_UNINIT);
+	if (ip->info->power) {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&ip->early_suspend);
+#endif
+		ip->info->power(ip->info, 0);
+	}
+	for (i = 0; i < ip->input_devs->count; i++)
+		input_unregister_device(ip->input_devs->dev[i]);
+	kfree(ip);
+	return 0;
+}
+
+static struct platform_driver gpio_event_driver = {
+	.probe		= gpio_event_probe,
+	.remove		= gpio_event_remove,
+	.driver		= {
+		.name	= GPIO_EVENT_DEV_NAME,
+	},
+};
+
+static int __devinit gpio_event_init(void)
+{
+	return platform_driver_register(&gpio_event_driver);
+}
+
+static void __exit gpio_event_exit(void)
+{
+	platform_driver_unregister(&gpio_event_driver);
+}
+
+module_init(gpio_event_init);
+module_exit(gpio_event_exit);
+
+MODULE_DESCRIPTION("GPIO Event Driver");
+MODULE_LICENSE("GPL");
+
diff -Nur linux-2.6.29/drivers/input/misc/gpio_input.c linux-2.6.29-spica/drivers/input/misc/gpio_input.c
--- linux-2.6.29/drivers/input/misc/gpio_input.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/input/misc/gpio_input.c	2010-03-30 11:00:32.000000000 +0700
@@ -0,0 +1,354 @@
+/* drivers/input/misc/gpio_input.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/wakelock.h>
+
+enum {
+	DEBOUNCE_UNSTABLE     = BIT(0),	/* Got irq, while debouncing */
+	DEBOUNCE_PRESSED      = BIT(1),
+	DEBOUNCE_NOTPRESSED   = BIT(2),
+	DEBOUNCE_WAIT_IRQ     = BIT(3),	/* Stable irq state */
+	DEBOUNCE_POLL         = BIT(4),	/* Stable polling state */
+
+	DEBOUNCE_UNKNOWN =
+		DEBOUNCE_PRESSED | DEBOUNCE_NOTPRESSED,
+};
+
+struct gpio_key_state {
+	struct gpio_input_state *ds;
+	uint8_t debounce;
+};
+
+struct gpio_input_state {
+	struct gpio_event_input_devs *input_devs;
+	const struct gpio_event_input_info *info;
+	struct hrtimer timer;
+	int use_irq;
+	int debounce_count;
+	spinlock_t irq_lock;
+	struct wake_lock wake_lock;
+	struct gpio_key_state key_state[0];
+};
+
+static enum hrtimer_restart gpio_event_input_timer_func(struct hrtimer *timer)
+{
+	int i;
+	int pressed;
+	struct gpio_input_state *ds =
+		container_of(timer, struct gpio_input_state, timer);
+	unsigned gpio_flags = ds->info->flags;
+	unsigned npolarity;
+	int nkeys = ds->info->keymap_size;
+	const struct gpio_event_direct_entry *key_entry;
+	struct gpio_key_state *key_state;
+	unsigned long irqflags;
+	uint8_t debounce;
+
+#if 0
+	key_entry = kp->keys_info->keymap;
+	key_state = kp->key_state;
+	for (i = 0; i < nkeys; i++, key_entry++, key_state++)
+		pr_info("gpio_read_detect_status %d %d\n", key_entry->gpio,
+			gpio_read_detect_status(key_entry->gpio));
+#endif
+	key_entry = ds->info->keymap;
+	key_state = ds->key_state;
+	spin_lock_irqsave(&ds->irq_lock, irqflags);
+	for (i = 0; i < nkeys; i++, key_entry++, key_state++) {
+		debounce = key_state->debounce;
+		if (debounce & DEBOUNCE_WAIT_IRQ)
+			continue;
+		if (key_state->debounce & DEBOUNCE_UNSTABLE) {
+			debounce = key_state->debounce = DEBOUNCE_UNKNOWN;
+			enable_irq(gpio_to_irq(key_entry->gpio));
+			pr_info("gpio_keys_scan_keys: key %x-%x, %d "
+				"(%d) continue debounce\n",
+				ds->info->type, key_entry->code,
+				i, key_entry->gpio);
+		}
+		npolarity = !(gpio_flags & GPIOEDF_ACTIVE_HIGH);
+		pressed = gpio_get_value(key_entry->gpio) ^ npolarity;
+		if (debounce & DEBOUNCE_POLL) {
+			if (pressed == !(debounce & DEBOUNCE_PRESSED)) {
+				ds->debounce_count++;
+				key_state->debounce = DEBOUNCE_UNKNOWN;
+				if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+					pr_info("gpio_keys_scan_keys: key %x-"
+						"%x, %d (%d) start debounce\n",
+						ds->info->type, key_entry->code,
+						i, key_entry->gpio);
+			}
+			continue;
+		}
+		if (pressed && (debounce & DEBOUNCE_NOTPRESSED)) {
+			if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+				pr_info("gpio_keys_scan_keys: key %x-%x, %d "
+					"(%d) debounce pressed 1\n",
+					ds->info->type, key_entry->code,
+					i, key_entry->gpio);
+			key_state->debounce = DEBOUNCE_PRESSED;
+			continue;
+		}
+		if (!pressed && (debounce & DEBOUNCE_PRESSED)) {
+			if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+				pr_info("gpio_keys_scan_keys: key %x-%x, %d "
+					"(%d) debounce pressed 0\n",
+					ds->info->type, key_entry->code,
+					i, key_entry->gpio);
+			key_state->debounce = DEBOUNCE_NOTPRESSED;
+			continue;
+		}
+		/* key is stable */
+		ds->debounce_count--;
+		if (ds->use_irq)
+			key_state->debounce |= DEBOUNCE_WAIT_IRQ;
+		else
+			key_state->debounce |= DEBOUNCE_POLL;
+		if (gpio_flags & GPIOEDF_PRINT_KEYS)
+			pr_info("gpio_keys_scan_keys: key %x-%x, %d (%d) "
+				"changed to %d\n", ds->info->type,
+				key_entry->code, i, key_entry->gpio, pressed);
+		input_event(ds->input_devs->dev[key_entry->dev], ds->info->type,
+			    key_entry->code, pressed);
+	}
+
+#if 0
+	key_entry = kp->keys_info->keymap;
+	key_state = kp->key_state;
+	for (i = 0; i < nkeys; i++, key_entry++, key_state++) {
+		pr_info("gpio_read_detect_status %d %d\n", key_entry->gpio,
+			gpio_read_detect_status(key_entry->gpio));
+	}
+#endif
+
+	if (ds->debounce_count)
+		hrtimer_start(timer, ds->info->debounce_time, HRTIMER_MODE_REL);
+	else if (!ds->use_irq)
+		hrtimer_start(timer, ds->info->poll_time, HRTIMER_MODE_REL);
+	else
+		wake_unlock(&ds->wake_lock);
+
+	spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t gpio_event_input_irq_handler(int irq, void *dev_id)
+{
+	struct gpio_key_state *ks = dev_id;
+	struct gpio_input_state *ds = ks->ds;
+	int keymap_index = ks - ds->key_state;
+	const struct gpio_event_direct_entry *key_entry;
+	unsigned long irqflags;
+	int pressed;
+
+	if (!ds->use_irq)
+		return IRQ_HANDLED;
+
+	key_entry = &ds->info->keymap[keymap_index];
+
+	if (ds->info->debounce_time.tv64) {
+		spin_lock_irqsave(&ds->irq_lock, irqflags);
+		if (ks->debounce & DEBOUNCE_WAIT_IRQ) {
+			ks->debounce = DEBOUNCE_UNKNOWN;
+			if (ds->debounce_count++ == 0) {
+				wake_lock(&ds->wake_lock);
+				hrtimer_start(
+					&ds->timer, ds->info->debounce_time,
+					HRTIMER_MODE_REL);
+			}
+			if (ds->info->flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+				pr_info("gpio_event_input_irq_handler: "
+					"key %x-%x, %d (%d) start debounce\n",
+					ds->info->type, key_entry->code,
+					keymap_index, key_entry->gpio);
+		} else {
+			disable_irq(irq);
+			ks->debounce = DEBOUNCE_UNSTABLE;
+		}
+		spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+	} else {
+		pressed = gpio_get_value(key_entry->gpio) ^
+			!(ds->info->flags & GPIOEDF_ACTIVE_HIGH);
+		if (ds->info->flags & GPIOEDF_PRINT_KEYS)
+			pr_info("gpio_event_input_irq_handler: key %x-%x, %d "
+				"(%d) changed to %d\n",
+				ds->info->type, key_entry->code, keymap_index,
+				key_entry->gpio, pressed);
+		input_event(ds->input_devs->dev[key_entry->dev], ds->info->type,
+			    key_entry->code, pressed);
+	}
+	return IRQ_HANDLED;
+}
+
+static int gpio_event_input_request_irqs(struct gpio_input_state *ds)
+{
+	int i;
+	int err;
+	unsigned int irq;
+	unsigned long req_flags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;
+
+	for (i = 0; i < ds->info->keymap_size; i++) {
+		err = irq = gpio_to_irq(ds->info->keymap[i].gpio);
+		if (err < 0)
+			goto err_gpio_get_irq_num_failed;
+		err = request_irq(irq, gpio_event_input_irq_handler,
+				  req_flags, "gpio_keys", &ds->key_state[i]);
+		if (err) {
+			pr_err("gpio_event_input_request_irqs: request_irq "
+				"failed for input %d, irq %d\n",
+				ds->info->keymap[i].gpio, irq);
+			goto err_request_irq_failed;
+		}
+		enable_irq_wake(irq);
+	}
+	return 0;
+
+	for (i = ds->info->keymap_size - 1; i >= 0; i--) {
+		free_irq(gpio_to_irq(ds->info->keymap[i].gpio),
+			 &ds->key_state[i]);
+err_request_irq_failed:
+err_gpio_get_irq_num_failed:
+		;
+	}
+	return err;
+}
+
+int gpio_event_input_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func)
+{
+	int ret;
+	int i;
+	unsigned long irqflags;
+	struct gpio_event_input_info *di;
+	struct gpio_input_state *ds = *data;
+
+	di = container_of(info, struct gpio_event_input_info, info);
+
+	if (func == GPIO_EVENT_FUNC_SUSPEND) {
+		spin_lock_irqsave(&ds->irq_lock, irqflags);
+		if (ds->use_irq)
+			for (i = 0; i < di->keymap_size; i++)
+				disable_irq(gpio_to_irq(di->keymap[i].gpio));
+		spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+		hrtimer_cancel(&ds->timer);
+		return 0;
+	}
+	if (func == GPIO_EVENT_FUNC_RESUME) {
+		spin_lock_irqsave(&ds->irq_lock, irqflags);
+		if (ds->use_irq)
+			for (i = 0; i < di->keymap_size; i++)
+				enable_irq(gpio_to_irq(di->keymap[i].gpio));
+		hrtimer_start(&ds->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+		spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+		return 0;
+	}
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		if (ktime_to_ns(di->poll_time) <= 0)
+			di->poll_time = ktime_set(0, 20 * NSEC_PER_MSEC);
+
+		*data = ds = kzalloc(sizeof(*ds) + sizeof(ds->key_state[0]) *
+					di->keymap_size, GFP_KERNEL);
+		if (ds == NULL) {
+			ret = -ENOMEM;
+			pr_err("gpio_event_input_func: "
+				"Failed to allocate private data\n");
+			goto err_ds_alloc_failed;
+		}
+		ds->debounce_count = di->keymap_size;
+		ds->input_devs = input_devs;
+		ds->info = di;
+		wake_lock_init(&ds->wake_lock, WAKE_LOCK_SUSPEND, "gpio_input");
+		spin_lock_init(&ds->irq_lock);
+
+		for (i = 0; i < di->keymap_size; i++) {
+			int dev = di->keymap[i].dev;
+			if (dev >= input_devs->count) {
+				pr_err("gpio_event_input_func: bad device "
+					"index %d >= %d for key code %d\n",
+					dev, input_devs->count,
+					di->keymap[i].code);
+				ret = -EINVAL;
+				goto err_bad_keymap;
+			}
+			input_set_capability(input_devs->dev[dev], di->type,
+					     di->keymap[i].code);
+			ds->key_state[i].ds = ds;
+			ds->key_state[i].debounce = DEBOUNCE_UNKNOWN;
+		}
+
+		for (i = 0; i < di->keymap_size; i++) {
+			ret = gpio_request(di->keymap[i].gpio, "gpio_kp_in");
+			if (ret) {
+				pr_err("gpio_event_input_func: gpio_request "
+					"failed for %d\n", di->keymap[i].gpio);
+				goto err_gpio_request_failed;
+			}
+			ret = gpio_direction_input(di->keymap[i].gpio);
+			if (ret) {
+				pr_err("gpio_event_input_func: "
+					"gpio_direction_input failed for %d\n",
+					di->keymap[i].gpio);
+				goto err_gpio_configure_failed;
+			}
+		}
+
+		ret = gpio_event_input_request_irqs(ds);
+
+		spin_lock_irqsave(&ds->irq_lock, irqflags);
+		ds->use_irq = ret == 0;
+
+		pr_info("GPIO Input Driver: Start gpio inputs for %s%s in %s "
+			"mode\n", input_devs->dev[0]->name,
+			(input_devs->count > 1) ? "..." : "",
+			ret == 0 ? "interrupt" : "polling");
+
+		hrtimer_init(&ds->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ds->timer.function = gpio_event_input_timer_func;
+		hrtimer_start(&ds->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+		spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+		return 0;
+	}
+
+	ret = 0;
+	spin_lock_irqsave(&ds->irq_lock, irqflags);
+	hrtimer_cancel(&ds->timer);
+	if (ds->use_irq) {
+		for (i = di->keymap_size - 1; i >= 0; i--) {
+			free_irq(gpio_to_irq(di->keymap[i].gpio),
+				 &ds->key_state[i]);
+		}
+	}
+	spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+
+	for (i = di->keymap_size - 1; i >= 0; i--) {
+err_gpio_configure_failed:
+		gpio_free(di->keymap[i].gpio);
+err_gpio_request_failed:
+		;
+	}
+err_bad_keymap:
+	wake_lock_destroy(&ds->wake_lock);
+	kfree(ds);
+err_ds_alloc_failed:
+	return ret;
+}
diff -Nur linux-2.6.29/drivers/input/misc/gpio_matrix.c linux-2.6.29-spica/drivers/input/misc/gpio_matrix.c
--- linux-2.6.29/drivers/input/misc/gpio_matrix.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/input/misc/gpio_matrix.c	2010-03-30 11:00:32.000000000 +0700
@@ -0,0 +1,422 @@
+/* drivers/input/misc/gpio_matrix.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/hrtimer.h>
+#include <linux/interrupt.h>
+#include <linux/wakelock.h>
+
+struct gpio_kp {
+	struct gpio_event_input_devs *input_devs;
+	struct gpio_event_matrix_info *keypad_info;
+	struct hrtimer timer;
+	struct wake_lock wake_lock;
+	int current_output;
+	unsigned int use_irq:1;
+	unsigned int key_state_changed:1;
+	unsigned int last_key_state_changed:1;
+	unsigned int some_keys_pressed:2;
+	unsigned long keys_pressed[0];
+};
+
+static void clear_phantom_key(struct gpio_kp *kp, int out, int in)
+{
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	int key_index = out * mi->ninputs + in;
+	unsigned short keyentry = mi->keymap[key_index];
+	unsigned short keycode = keyentry & MATRIX_KEY_MASK;
+	unsigned short dev = keyentry >> MATRIX_CODE_BITS;
+
+	if (!test_bit(keycode, kp->input_devs->dev[dev]->key)) {
+		if (mi->flags & GPIOKPF_PRINT_PHANTOM_KEYS)
+			pr_info("gpiomatrix: phantom key %x, %d-%d (%d-%d) "
+				"cleared\n", keycode, out, in,
+				mi->output_gpios[out], mi->input_gpios[in]);
+		__clear_bit(key_index, kp->keys_pressed);
+	} else {
+		if (mi->flags & GPIOKPF_PRINT_PHANTOM_KEYS)
+			pr_info("gpiomatrix: phantom key %x, %d-%d (%d-%d) "
+				"not cleared\n", keycode, out, in,
+				mi->output_gpios[out], mi->input_gpios[in]);
+	}
+}
+
+static int restore_keys_for_input(struct gpio_kp *kp, int out, int in)
+{
+	int rv = 0;
+	int key_index;
+
+	key_index = out * kp->keypad_info->ninputs + in;
+	while (out < kp->keypad_info->noutputs) {
+		if (test_bit(key_index, kp->keys_pressed)) {
+			rv = 1;
+			clear_phantom_key(kp, out, in);
+		}
+		key_index += kp->keypad_info->ninputs;
+		out++;
+	}
+	return rv;
+}
+
+static void remove_phantom_keys(struct gpio_kp *kp)
+{
+	int out, in, inp;
+	int key_index;
+
+	if (kp->some_keys_pressed < 3)
+		return;
+
+	for (out = 0; out < kp->keypad_info->noutputs; out++) {
+		inp = -1;
+		key_index = out * kp->keypad_info->ninputs;
+		for (in = 0; in < kp->keypad_info->ninputs; in++, key_index++) {
+			if (test_bit(key_index, kp->keys_pressed)) {
+				if (inp == -1) {
+					inp = in;
+					continue;
+				}
+				if (inp >= 0) {
+					if (!restore_keys_for_input(kp, out + 1,
+									inp))
+						break;
+					clear_phantom_key(kp, out, inp);
+					inp = -2;
+				}
+				restore_keys_for_input(kp, out, in);
+			}
+		}
+	}
+}
+
+static void report_key(struct gpio_kp *kp, int key_index, int out, int in)
+{
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	int pressed = test_bit(key_index, kp->keys_pressed);
+	unsigned short keyentry = mi->keymap[key_index];
+	unsigned short keycode = keyentry & MATRIX_KEY_MASK;
+	unsigned short dev = keyentry >> MATRIX_CODE_BITS;
+
+	if (pressed != test_bit(keycode, kp->input_devs->dev[dev]->key)) {
+		if (keycode == KEY_RESERVED) {
+			if (mi->flags & GPIOKPF_PRINT_UNMAPPED_KEYS)
+				pr_info("gpiomatrix: unmapped key, %d-%d "
+					"(%d-%d) changed to %d\n",
+					out, in, mi->output_gpios[out],
+					mi->input_gpios[in], pressed);
+		} else {
+			if (mi->flags & GPIOKPF_PRINT_MAPPED_KEYS)
+				pr_info("gpiomatrix: key %x, %d-%d (%d-%d) "
+					"changed to %d\n", keycode,
+					out, in, mi->output_gpios[out],
+					mi->input_gpios[in], pressed);
+			input_report_key(kp->input_devs->dev[dev], keycode, pressed);
+		}
+	}
+}
+
+static enum hrtimer_restart gpio_keypad_timer_func(struct hrtimer *timer)
+{
+	int out, in;
+	int key_index;
+	int gpio;
+	struct gpio_kp *kp = container_of(timer, struct gpio_kp, timer);
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	unsigned gpio_keypad_flags = mi->flags;
+	unsigned polarity = !!(gpio_keypad_flags & GPIOKPF_ACTIVE_HIGH);
+
+	out = kp->current_output;
+	if (out == mi->noutputs) {
+		out = 0;
+		kp->last_key_state_changed = kp->key_state_changed;
+		kp->key_state_changed = 0;
+		kp->some_keys_pressed = 0;
+	} else {
+		key_index = out * mi->ninputs;
+		for (in = 0; in < mi->ninputs; in++, key_index++) {
+			gpio = mi->input_gpios[in];
+			if (gpio_get_value(gpio) ^ !polarity) {
+				if (kp->some_keys_pressed < 3)
+					kp->some_keys_pressed++;
+				kp->key_state_changed |= !__test_and_set_bit(
+						key_index, kp->keys_pressed);
+			} else
+				kp->key_state_changed |= __test_and_clear_bit(
+						key_index, kp->keys_pressed);
+		}
+		gpio = mi->output_gpios[out];
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(gpio, !polarity);
+		else
+			gpio_direction_input(gpio);
+		out++;
+	}
+	kp->current_output = out;
+	if (out < mi->noutputs) {
+		gpio = mi->output_gpios[out];
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(gpio, polarity);
+		else
+			gpio_direction_output(gpio, polarity);
+		hrtimer_start(timer, mi->settle_time, HRTIMER_MODE_REL);
+		return HRTIMER_NORESTART;
+	}
+	if (gpio_keypad_flags & GPIOKPF_DEBOUNCE) {
+		if (kp->key_state_changed) {
+			hrtimer_start(&kp->timer, mi->debounce_delay,
+				      HRTIMER_MODE_REL);
+			return HRTIMER_NORESTART;
+		}
+		kp->key_state_changed = kp->last_key_state_changed;
+	}
+	if (kp->key_state_changed) {
+		if (gpio_keypad_flags & GPIOKPF_REMOVE_SOME_PHANTOM_KEYS)
+			remove_phantom_keys(kp);
+		key_index = 0;
+		for (out = 0; out < mi->noutputs; out++)
+			for (in = 0; in < mi->ninputs; in++, key_index++)
+				report_key(kp, key_index, out, in);
+	}
+	if (!kp->use_irq || kp->some_keys_pressed) {
+		hrtimer_start(timer, mi->poll_time, HRTIMER_MODE_REL);
+		return HRTIMER_NORESTART;
+	}
+
+	/* No keys are pressed, reenable interrupt */
+	for (out = 0; out < mi->noutputs; out++) {
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(mi->output_gpios[out], polarity);
+		else
+			gpio_direction_output(mi->output_gpios[out], polarity);
+	}
+	for (in = 0; in < mi->ninputs; in++)
+		enable_irq(gpio_to_irq(mi->input_gpios[in]));
+	wake_unlock(&kp->wake_lock);
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t gpio_keypad_irq_handler(int irq_in, void *dev_id)
+{
+	int i;
+	struct gpio_kp *kp = dev_id;
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	unsigned gpio_keypad_flags = mi->flags;
+
+	if (!kp->use_irq) /* ignore interrupt while registering the handler */
+		return IRQ_HANDLED;
+
+	for (i = 0; i < mi->ninputs; i++)
+		disable_irq(gpio_to_irq(mi->input_gpios[i]));
+	for (i = 0; i < mi->noutputs; i++) {
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(mi->output_gpios[i],
+				!(gpio_keypad_flags & GPIOKPF_ACTIVE_HIGH));
+		else
+			gpio_direction_input(mi->output_gpios[i]);
+	}
+	wake_lock(&kp->wake_lock);
+	hrtimer_start(&kp->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+	return IRQ_HANDLED;
+}
+
+static int gpio_keypad_request_irqs(struct gpio_kp *kp)
+{
+	int i;
+	int err;
+	unsigned int irq;
+	unsigned long request_flags;
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+
+	switch (mi->flags & (GPIOKPF_ACTIVE_HIGH|GPIOKPF_LEVEL_TRIGGERED_IRQ)) {
+	default:
+		request_flags = IRQF_TRIGGER_FALLING;
+		break;
+	case GPIOKPF_ACTIVE_HIGH:
+		request_flags = IRQF_TRIGGER_RISING;
+		break;
+	case GPIOKPF_LEVEL_TRIGGERED_IRQ:
+		request_flags = IRQF_TRIGGER_LOW;
+		break;
+	case GPIOKPF_LEVEL_TRIGGERED_IRQ | GPIOKPF_ACTIVE_HIGH:
+		request_flags = IRQF_TRIGGER_HIGH;
+		break;
+	}
+
+	for (i = 0; i < mi->ninputs; i++) {
+		err = irq = gpio_to_irq(mi->input_gpios[i]);
+		if (err < 0)
+			goto err_gpio_get_irq_num_failed;
+		err = request_irq(irq, gpio_keypad_irq_handler, request_flags,
+				  "gpio_kp", kp);
+		if (err) {
+			pr_err("gpiomatrix: request_irq failed for input %d, "
+				"irq %d\n", mi->input_gpios[i], irq);
+			goto err_request_irq_failed;
+		}
+		err = set_irq_wake(irq, 1);
+		if (err) {
+			pr_err("gpiomatrix: set_irq_wake failed for input %d, "
+				"irq %d\n", mi->input_gpios[i], irq);
+		}
+		disable_irq(irq);
+	}
+	return 0;
+
+	for (i = mi->noutputs - 1; i >= 0; i--) {
+		free_irq(gpio_to_irq(mi->input_gpios[i]), kp);
+err_request_irq_failed:
+err_gpio_get_irq_num_failed:
+		;
+	}
+	return err;
+}
+
+int gpio_event_matrix_func(struct gpio_event_input_devs *input_devs,
+	struct gpio_event_info *info, void **data, int func)
+{
+	int i;
+	int err;
+	int key_count;
+	struct gpio_kp *kp;
+	struct gpio_event_matrix_info *mi;
+
+	mi = container_of(info, struct gpio_event_matrix_info, info);
+	if (func == GPIO_EVENT_FUNC_SUSPEND || func == GPIO_EVENT_FUNC_RESUME) {
+		/* TODO: disable scanning */
+		return 0;
+	}
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		if (mi->keymap == NULL ||
+		   mi->input_gpios == NULL ||
+		   mi->output_gpios == NULL) {
+			err = -ENODEV;
+			pr_err("gpiomatrix: Incomplete pdata\n");
+			goto err_invalid_platform_data;
+		}
+		key_count = mi->ninputs * mi->noutputs;
+
+		*data = kp = kzalloc(sizeof(*kp) + sizeof(kp->keys_pressed[0]) *
+				     BITS_TO_LONGS(key_count), GFP_KERNEL);
+		if (kp == NULL) {
+			err = -ENOMEM;
+			pr_err("gpiomatrix: Failed to allocate private data\n");
+			goto err_kp_alloc_failed;
+		}
+		kp->input_devs = input_devs;
+		kp->keypad_info = mi;
+		for (i = 0; i < key_count; i++) {
+			unsigned short keyentry = mi->keymap[i];
+			unsigned short keycode = keyentry & MATRIX_KEY_MASK;
+			unsigned short dev = keyentry >> MATRIX_CODE_BITS;
+			if (dev >= input_devs->count) {
+				pr_err("gpiomatrix: bad device index %d >= "
+					"%d for key code %d\n",
+					dev, input_devs->count, keycode);
+				err = -EINVAL;
+				goto err_bad_keymap;
+			}
+			if (keycode && keycode <= KEY_MAX)
+				input_set_capability(input_devs->dev[dev],
+							EV_KEY, keycode);
+		}
+
+		for (i = 0; i < mi->noutputs; i++) {
+			if (gpio_cansleep(mi->output_gpios[i])) {
+				pr_err("gpiomatrix: unsupported output gpio %d,"
+					" can sleep\n", mi->output_gpios[i]);
+				err = -EINVAL;
+				goto err_request_output_gpio_failed;
+			}
+			err = gpio_request(mi->output_gpios[i], "gpio_kp_out");
+			if (err) {
+				pr_err("gpiomatrix: gpio_request failed for "
+					"output %d\n", mi->output_gpios[i]);
+				goto err_request_output_gpio_failed;
+			}
+			if (mi->flags & GPIOKPF_DRIVE_INACTIVE)
+				err = gpio_direction_output(mi->output_gpios[i],
+					!(mi->flags & GPIOKPF_ACTIVE_HIGH));
+			else
+				err = gpio_direction_input(mi->output_gpios[i]);
+			if (err) {
+				pr_err("gpiomatrix: gpio_configure failed for "
+					"output %d\n", mi->output_gpios[i]);
+				goto err_output_gpio_configure_failed;
+			}
+		}
+		for (i = 0; i < mi->ninputs; i++) {
+			err = gpio_request(mi->input_gpios[i], "gpio_kp_in");
+			if (err) {
+				pr_err("gpiomatrix: gpio_request failed for "
+					"input %d\n", mi->input_gpios[i]);
+				goto err_request_input_gpio_failed;
+			}
+			err = gpio_direction_input(mi->input_gpios[i]);
+			if (err) {
+				pr_err("gpiomatrix: gpio_direction_input failed"
+					" for input %d\n", mi->input_gpios[i]);
+				goto err_gpio_direction_input_failed;
+			}
+		}
+		kp->current_output = mi->noutputs;
+		kp->key_state_changed = 1;
+
+		hrtimer_init(&kp->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		kp->timer.function = gpio_keypad_timer_func;
+		wake_lock_init(&kp->wake_lock, WAKE_LOCK_SUSPEND, "gpio_kp");
+		err = gpio_keypad_request_irqs(kp);
+		kp->use_irq = err == 0;
+
+		pr_info("GPIO Matrix Keypad Driver: Start keypad matrix for "
+			"%s%s in %s mode\n", input_devs->dev[0]->name,
+			(input_devs->count > 1) ? "..." : "",
+			kp->use_irq ? "interrupt" : "polling");
+
+		if (kp->use_irq)
+			wake_lock(&kp->wake_lock);
+		hrtimer_start(&kp->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+
+		return 0;
+	}
+
+	err = 0;
+	kp = *data;
+
+	if (kp->use_irq)
+		for (i = mi->noutputs - 1; i >= 0; i--)
+			free_irq(gpio_to_irq(mi->input_gpios[i]), kp);
+
+	hrtimer_cancel(&kp->timer);
+	wake_lock_destroy(&kp->wake_lock);
+	for (i = mi->noutputs - 1; i >= 0; i--) {
+err_gpio_direction_input_failed:
+		gpio_free(mi->input_gpios[i]);
+err_request_input_gpio_failed:
+		;
+	}
+	for (i = mi->noutputs - 1; i >= 0; i--) {
+err_output_gpio_configure_failed:
+		gpio_free(mi->output_gpios[i]);
+err_request_output_gpio_failed:
+		;
+	}
+err_bad_keymap:
+	kfree(kp);
+err_kp_alloc_failed:
+err_invalid_platform_data:
+	return err;
+}
diff -Nur linux-2.6.29/drivers/input/misc/gpio_output.c linux-2.6.29-spica/drivers/input/misc/gpio_output.c
--- linux-2.6.29/drivers/input/misc/gpio_output.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/input/misc/gpio_output.c	2010-03-30 11:00:32.000000000 +0700
@@ -0,0 +1,97 @@
+/* drivers/input/misc/gpio_output.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+
+int gpio_event_output_event(
+	struct gpio_event_input_devs *input_devs, struct gpio_event_info *info,
+	void **data, unsigned int dev, unsigned int type,
+	unsigned int code, int value)
+{
+	int i;
+	struct gpio_event_output_info *oi;
+	oi = container_of(info, struct gpio_event_output_info, info);
+	if (type != oi->type)
+		return 0;
+	if (!(oi->flags & GPIOEDF_ACTIVE_HIGH))
+		value = !value;
+	for (i = 0; i < oi->keymap_size; i++)
+		if (dev == oi->keymap[i].dev && code == oi->keymap[i].code)
+			gpio_set_value(oi->keymap[i].gpio, value);
+	return 0;
+}
+
+int gpio_event_output_func(
+	struct gpio_event_input_devs *input_devs, struct gpio_event_info *info,
+	void **data, int func)
+{
+	int ret;
+	int i;
+	struct gpio_event_output_info *oi;
+	oi = container_of(info, struct gpio_event_output_info, info);
+
+	if (func == GPIO_EVENT_FUNC_SUSPEND || func == GPIO_EVENT_FUNC_RESUME)
+		return 0;
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		int output_level = !(oi->flags & GPIOEDF_ACTIVE_HIGH);
+
+		for (i = 0; i < oi->keymap_size; i++) {
+			int dev = oi->keymap[i].dev;
+			if (dev >= input_devs->count) {
+				pr_err("gpio_event_output_func: bad device "
+					"index %d >= %d for key code %d\n",
+					dev, input_devs->count,
+					oi->keymap[i].code);
+				ret = -EINVAL;
+				goto err_bad_keymap;
+			}
+			input_set_capability(input_devs->dev[dev], oi->type,
+					     oi->keymap[i].code);
+		}
+
+		for (i = 0; i < oi->keymap_size; i++) {
+			ret = gpio_request(oi->keymap[i].gpio,
+					   "gpio_event_output");
+			if (ret) {
+				pr_err("gpio_event_output_func: gpio_request "
+					"failed for %d\n", oi->keymap[i].gpio);
+				goto err_gpio_request_failed;
+			}
+			ret = gpio_direction_output(oi->keymap[i].gpio,
+						    output_level);
+			if (ret) {
+				pr_err("gpio_event_output_func: "
+					"gpio_direction_output failed for %d\n",
+					oi->keymap[i].gpio);
+				goto err_gpio_direction_output_failed;
+			}
+		}
+		return 0;
+	}
+
+	ret = 0;
+	for (i = oi->keymap_size - 1; i >= 0; i--) {
+err_gpio_direction_output_failed:
+		gpio_free(oi->keymap[i].gpio);
+err_gpio_request_failed:
+		;
+	}
+err_bad_keymap:
+	return ret;
+}
+
diff -Nur linux-2.6.29/drivers/input/misc/Kconfig linux-2.6.29-spica/drivers/input/misc/Kconfig
--- linux-2.6.29/drivers/input/misc/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/input/misc/Kconfig	2010-03-30 11:00:32.000000000 +0700
@@ -212,6 +212,11 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called sgi_btns.
 
+config INPUT_GPIO
+	tristate "GPIO driver support"
+	help
+	  Say Y here if you want to support gpio based keys, wheels etc...
+
 config HP_SDC_RTC
 	tristate "HP SDC Real Time Clock"
 	depends on GSC || HP300
@@ -227,4 +232,15 @@
 	 Say Y to include support for delivering  PMU events via  input
 	 layer on NXP PCF50633.
 
+config INPUT_KEYCHORD
+	tristate "Key chord input driver support"
+	help
+	  Say Y here if you want to enable the key chord driver
+	  accessible at /dev/keychord.  This driver can be used
+	  for receiving notifications when client specified key
+	  combinations are pressed.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called keychord.
+
 endif
diff -Nur linux-2.6.29/drivers/input/misc/keychord.c linux-2.6.29-spica/drivers/input/misc/keychord.c
--- linux-2.6.29/drivers/input/misc/keychord.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/input/misc/keychord.c	2010-03-30 11:00:32.000000000 +0700
@@ -0,0 +1,386 @@
+/*
+ *  drivers/input/misc/keychord.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/smp_lock.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/keychord.h>
+
+#define KEYCHORD_NAME		"keychord"
+#define BUFFER_SIZE			16
+
+MODULE_AUTHOR("Mike Lockwood <lockwood@android.com>");
+MODULE_DESCRIPTION("Key chord input driver");
+MODULE_SUPPORTED_DEVICE("keychord");
+MODULE_LICENSE("GPL");
+
+#define NEXT_KEYCHORD(kc) ((struct input_keychord *) \
+		((char *)kc + sizeof(struct input_keychord) + \
+		kc->count * sizeof(kc->keycodes[0])))
+
+struct keychord_device {
+	struct input_handler	input_handler;
+	int			registered;
+
+	/* list of keychords to monitor */
+	struct input_keychord	*keychords;
+	int			keychord_count;
+
+	/* bitmask of keys contained in our keychords */
+	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
+	/* current state of the keys */
+	unsigned long keystate[BITS_TO_LONGS(KEY_CNT)];
+	/* number of keys that are currently pressed */
+	int key_down;
+
+	/* second input_device_id is needed for null termination */
+	struct input_device_id  device_ids[2];
+
+	spinlock_t		lock;
+	wait_queue_head_t	waitq;
+	unsigned char		head;
+	unsigned char		tail;
+	__u16			buff[BUFFER_SIZE];
+};
+
+static int check_keychord(struct keychord_device *kdev,
+		struct input_keychord *keychord)
+{
+	int i;
+
+	if (keychord->count != kdev->key_down)
+		return 0;
+
+	for (i = 0; i < keychord->count; i++) {
+		if (!test_bit(keychord->keycodes[i], kdev->keystate))
+			return 0;
+	}
+
+	/* we have a match */
+	return 1;
+}
+
+static void keychord_event(struct input_handle *handle, unsigned int type,
+			   unsigned int code, int value)
+{
+	struct keychord_device *kdev = handle->private;
+	struct input_keychord *keychord;
+	unsigned long flags;
+	int i, got_chord = 0;
+
+	if (type != EV_KEY || code >= KEY_MAX)
+		return;
+
+	spin_lock_irqsave(&kdev->lock, flags);
+	/* do nothing if key state did not change */
+	if (!test_bit(code, kdev->keystate) == !value)
+		goto done;
+	__change_bit(code, kdev->keystate);
+	if (value)
+		kdev->key_down++;
+	else
+		kdev->key_down--;
+
+	/* don't notify on key up */
+	if (!value)
+		goto done;
+	/* ignore this event if it is not one of the keys we are monitoring */
+	if (!test_bit(code, kdev->keybit))
+		goto done;
+
+	keychord = kdev->keychords;
+	if (!keychord)
+		goto done;
+
+	/* check to see if the keyboard state matches any keychords */
+	for (i = 0; i < kdev->keychord_count; i++) {
+		if (check_keychord(kdev, keychord)) {
+			kdev->buff[kdev->head] = keychord->id;
+			kdev->head = (kdev->head + 1) % BUFFER_SIZE;
+			got_chord = 1;
+			break;
+		}
+		/* skip to next keychord */
+		keychord = NEXT_KEYCHORD(keychord);
+	}
+
+done:
+	spin_unlock_irqrestore(&kdev->lock, flags);
+
+	if (got_chord)
+		wake_up_interruptible(&kdev->waitq);
+}
+
+static int keychord_connect(struct input_handler *handler,
+					  struct input_dev *dev,
+					  const struct input_device_id *id)
+{
+	int i, ret;
+	struct input_handle *handle;
+	struct keychord_device *kdev =
+		container_of(handler, struct keychord_device, input_handler);
+
+	/*
+	 * ignore this input device if it does not contain any keycodes
+	 * that we are monitoring
+	 */
+	for (i = 0; i < KEY_MAX; i++) {
+		if (test_bit(i, kdev->keybit) && test_bit(i, dev->keybit))
+			break;
+	}
+	if (i == KEY_MAX)
+		return -ENODEV;
+
+	handle = kzalloc(sizeof(*handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = KEYCHORD_NAME;
+	handle->private = kdev;
+
+	ret = input_register_handle(handle);
+	if (ret)
+		goto err_input_register_handle;
+
+	ret = input_open_device(handle);
+	if (ret)
+		goto err_input_open_device;
+
+	pr_info("keychord: using input dev %s for fevent\n", dev->name);
+
+	return 0;
+
+err_input_open_device:
+	input_unregister_handle(handle);
+err_input_register_handle:
+	kfree(handle);
+	return ret;
+}
+
+static void keychord_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+/*
+ * keychord_read is used to read keychord events from the driver
+ */
+static ssize_t keychord_read(struct file *file, char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	struct keychord_device *kdev = file->private_data;
+	__u16   id;
+	int retval;
+	unsigned long flags;
+
+	if (count < sizeof(id))
+		return -EINVAL;
+	count = sizeof(id);
+
+	if (kdev->head == kdev->tail && (file->f_flags & O_NONBLOCK))
+		return -EAGAIN;
+
+	retval = wait_event_interruptible(kdev->waitq,
+			kdev->head != kdev->tail);
+	if (retval)
+		return retval;
+
+	spin_lock_irqsave(&kdev->lock, flags);
+	/* pop a keychord ID off the queue */
+	id = kdev->buff[kdev->tail];
+	kdev->tail = (kdev->tail + 1) % BUFFER_SIZE;
+	spin_unlock_irqrestore(&kdev->lock, flags);
+
+	if (copy_to_user(buffer, &id, count))
+		return -EFAULT;
+
+	return count;
+}
+
+/*
+ * keychord_write is used to configure the driver
+ */
+static ssize_t keychord_write(struct file *file, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	struct keychord_device *kdev = file->private_data;
+	struct input_keychord *keychords = 0;
+	struct input_keychord *keychord, *next, *end;
+	int ret, i, key;
+	unsigned long flags;
+
+	if (count < sizeof(struct input_keychord))
+		return -EINVAL;
+	keychords = kzalloc(count, GFP_KERNEL);
+	if (!keychords)
+		return -ENOMEM;
+
+	/* read list of keychords from userspace */
+	if (copy_from_user(keychords, buffer, count)) {
+		kfree(keychords);
+		return -EFAULT;
+	}
+
+	/* unregister handler before changing configuration */
+	if (kdev->registered) {
+		input_unregister_handler(&kdev->input_handler);
+		kdev->registered = 0;
+	}
+
+	spin_lock_irqsave(&kdev->lock, flags);
+	/* clear any existing configuration */
+	kfree(kdev->keychords);
+	kdev->keychords = 0;
+	kdev->keychord_count = 0;
+	kdev->key_down = 0;
+	memset(kdev->keybit, 0, sizeof(kdev->keybit));
+	memset(kdev->keystate, 0, sizeof(kdev->keystate));
+	kdev->head = kdev->tail = 0;
+
+	keychord = keychords;
+	end = (struct input_keychord *)((char *)keychord + count);
+
+	while (keychord < end) {
+		next = NEXT_KEYCHORD(keychord);
+		if (keychord->count <= 0 || next > end) {
+			pr_err("keychord: invalid keycode count %d\n",
+				keychord->count);
+			goto err_unlock_return;
+		}
+		if (keychord->version != KEYCHORD_VERSION) {
+			pr_err("keychord: unsupported version %d\n",
+				keychord->version);
+			goto err_unlock_return;
+		}
+
+		/* keep track of the keys we are monitoring in keybit */
+		for (i = 0; i < keychord->count; i++) {
+			key = keychord->keycodes[i];
+			if (key < 0 || key >= KEY_CNT) {
+				pr_err("keychord: keycode %d out of range\n",
+					key);
+				goto err_unlock_return;
+			}
+			__set_bit(key, kdev->keybit);
+		}
+
+		kdev->keychord_count++;
+		keychord = next;
+	}
+
+	kdev->keychords = keychords;
+	spin_unlock_irqrestore(&kdev->lock, flags);
+
+	ret = input_register_handler(&kdev->input_handler);
+	if (ret) {
+		kfree(keychords);
+		kdev->keychords = 0;
+		return ret;
+	}
+	kdev->registered = 1;
+
+	return count;
+
+err_unlock_return:
+	spin_unlock_irqrestore(&kdev->lock, flags);
+	kfree(keychords);
+	return -EINVAL;
+}
+
+static unsigned int keychord_poll(struct file *file, poll_table *wait)
+{
+	struct keychord_device *kdev = file->private_data;
+
+	poll_wait(file, &kdev->waitq, wait);
+
+	if (kdev->head != kdev->tail)
+		return POLLIN | POLLRDNORM;
+
+	return 0;
+}
+
+static int keychord_open(struct inode *inode, struct file *file)
+{
+	struct keychord_device *kdev;
+
+	kdev = kzalloc(sizeof(struct keychord_device), GFP_KERNEL);
+	if (!kdev)
+		return -ENOMEM;
+
+	spin_lock_init(&kdev->lock);
+	init_waitqueue_head(&kdev->waitq);
+
+	kdev->input_handler.event = keychord_event;
+	kdev->input_handler.connect = keychord_connect;
+	kdev->input_handler.disconnect = keychord_disconnect;
+	kdev->input_handler.name = KEYCHORD_NAME;
+	kdev->input_handler.id_table = kdev->device_ids;
+
+	kdev->device_ids[0].flags = INPUT_DEVICE_ID_MATCH_EVBIT;
+	__set_bit(EV_KEY, kdev->device_ids[0].evbit);
+
+	file->private_data = kdev;
+
+	return 0;
+}
+
+static int keychord_release(struct inode *inode, struct file *file)
+{
+	struct keychord_device *kdev = file->private_data;
+
+	if (kdev->registered)
+		input_unregister_handler(&kdev->input_handler);
+	kfree(kdev);
+
+	return 0;
+}
+
+static const struct file_operations keychord_fops = {
+	.owner		= THIS_MODULE,
+	.open		= keychord_open,
+	.release	= keychord_release,
+	.read		= keychord_read,
+	.write		= keychord_write,
+	.poll		= keychord_poll,
+};
+
+static struct miscdevice keychord_misc = {
+	.fops		= &keychord_fops,
+	.name		= KEYCHORD_NAME,
+	.minor		= MISC_DYNAMIC_MINOR,
+};
+
+static int __init keychord_init(void)
+{
+	return misc_register(&keychord_misc);
+}
+
+static void __exit keychord_exit(void)
+{
+	misc_deregister(&keychord_misc);
+}
+
+module_init(keychord_init);
+module_exit(keychord_exit);
diff -Nur linux-2.6.29/drivers/input/misc/Makefile linux-2.6.29-spica/drivers/input/misc/Makefile
--- linux-2.6.29/drivers/input/misc/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/input/misc/Makefile	2010-03-30 11:00:32.000000000 +0700
@@ -22,3 +22,5 @@
 obj-$(CONFIG_INPUT_APANEL)		+= apanel.o
 obj-$(CONFIG_INPUT_SGI_BTNS)		+= sgi_btns.o
 obj-$(CONFIG_INPUT_PCF50633_PMU)	+= pcf50633-input.o
+obj-$(CONFIG_INPUT_GPIO)		+= gpio_event.o gpio_matrix.o gpio_input.o gpio_output.o gpio_axis.o
+obj-$(CONFIG_INPUT_KEYCHORD)	+= keychord.o
diff -Nur linux-2.6.29/drivers/input/touchscreen/Kconfig linux-2.6.29-spica/drivers/input/touchscreen/Kconfig
--- linux-2.6.29/drivers/input/touchscreen/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/input/touchscreen/Kconfig	2010-05-06 12:42:45.674299703 +0700
@@ -58,6 +58,52 @@
 	  NOTE: this driver is deprecated, try enable SPI and generic
 	  ADS7846-based touchscreen driver.
 
+config TOUCHSCREEN_QT5480
+	tristate "quantum touchscreen driver"
+	depends on ARCH_S3C2410 || ARCH_S3C64XX
+	default y
+	help
+	  Say Y here to enable the driver for the touchscreen on the
+	  S3C spica board.
+	  
+	  If unsure, say N.
+ 
+	  To compile this driver as a module, choose M here: the
+	  module will be called melfas_ts.
+
+config TOUCHSCREEN_KEYPAD
+    tristate "melfas touchscreen keypad"
+	depends on TOUCHSCREEN_MELFAS
+	default y
+	help
+	  Say Y here to enable the keypad on touchscreen.
+
+	  Say N here to disable the keypad on touchscreen.
+
+config TOUCHSCREEN_S3C
+	tristate "S3C touchscreen driver"
+	depends on ARCH_S3C2410 || ARCH_S3C64XX
+	default n
+	help
+	  Say Y here to enable the driver for the touchscreen on the
+	  S3C SMDK board.
+	  
+	  If unsure, say N.
+ 
+	  To compile this driver as a module, choose M here: the
+	  module will be called s3c_ts.
+
+config TOUCHSCREEN_NEW
+    bool "new flip touch"
+	depends on TOUCHSCREEN_S3C
+	default n
+	help
+	  Say Y here to enable the driver for the new version touchscreen on the
+	  S3C SMDK board.
+
+	  Say N here to enable the driver for the old version touchscreen on the
+	  S3C SMDK board.
+
 config TOUCHSCREEN_DA9034
 	tristate "Touchscreen support for Dialog Semiconductor DA9034"
 	depends on PMIC_DA903X
@@ -206,6 +252,12 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called migor_ts.
 
+config TOUCHSCREEN_SYNAPTICS_I2C_RMI
+	tristate "Synaptics i2c touchscreen"
+	depends on I2C
+	help
+	  This enables support for Synaptics RMI over I2C based touchscreens.
+
 config TOUCHSCREEN_TOUCHRIGHT
 	tristate "Touchright serial touchscreen"
 	select SERIO
diff -Nur linux-2.6.29/drivers/input/touchscreen/Makefile linux-2.6.29-spica/drivers/input/touchscreen/Makefile
--- linux-2.6.29/drivers/input/touchscreen/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/input/touchscreen/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -22,6 +22,7 @@
 obj-$(CONFIG_TOUCHSCREEN_HTCPEN)	+= htcpen.o
 obj-$(CONFIG_TOUCHSCREEN_USB_COMPOSITE)	+= usbtouchscreen.o
 obj-$(CONFIG_TOUCHSCREEN_PENMOUNT)	+= penmount.o
+obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI)	+= synaptics_i2c_rmi.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHIT213)	+= touchit213.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHRIGHT)	+= touchright.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHWIN)	+= touchwin.o
@@ -34,3 +35,5 @@
 wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9712)	+= wm9712.o
 wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9713)	+= wm9713.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE)	+= mainstone-wm97xx.o
+obj-$(CONFIG_TOUCHSCREEN_S3C)		+= s3c-ts.o
+obj-$(CONFIG_TOUCHSCREEN_QT5480)	+= qt5480.o 
diff -Nur linux-2.6.29/drivers/input/touchscreen/qt5480.c linux-2.6.29-spica/drivers/input/touchscreen/qt5480.c
--- linux-2.6.29/drivers/input/touchscreen/qt5480.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/input/touchscreen/qt5480.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,2778 @@
+/* drivers/input/touchscreen/qt5480.c
+ *
+ * Quantum TSP driver.
+ *
+ * Copyright (C) 2009 Samsung Electronics Co. Ltd.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/earlysuspend.h>
+#include <asm/io.h>
+#include <plat/regs-gpio.h>
+#include <plat/gpio-cfg.h>
+#include <mach/hardware.h>
+
+#ifdef CONFIG_CPU_FREQ
+#include <plat/s3c64xx-dvfs.h>
+#endif
+
+// firmware data : version 5.5
+static u8 firmware_data[] =
+{
+	0x00,0x11,0x4E,0x99,0x44,0x8C,0xFB,0xA8,0xB5,0xE0,0x34,0x9C,0x0F,0x7E,0x7A,0x87,0x00,0xFA,0x54,0x00,
+	0x92,0x0E,0xF4,0x72,0xBA,0x51,0x29,0x29,0x94,0x94,0x4A,0xD9,0x7E,0xD4,0xB2,0xA2,0x48,0xFE,0xE6,0xAD,
+	0x2C,0x42,0xC9,0xB4,0x3B,0x4F,0xC3,0x33,0x80,0x12,0xE8,0x32,0x8E,0x6E,0x55,0x5E,0x32,0x4B,0xBC,0x31,
+	0x81,0x1C,0x9F,0x89,0xD6,0xCF,0x8A,0xC8,0x7D,0xF0,0xE1,0xA2,0x4D,0xC5,0xFB,0xBB,0x2E,0xDC,0xC6,0xE2,
+	0xE3,0x84,0x1C,0x02,0x93,0xED,0x58,0x19,0xB9,0x0E,0x80,0x12,0x10,0x5A,0xCD,0x34,0xA4,0x0E,0x1E,0x9B,
+	0xD0,0x5A,0xB7,0x38,0x84,0x10,0x11,0x9B,0x54,0xD9,0x75,0xF0,0xE5,0xEC,0x6F,0xC3,0xE8,0xF5,0xAA,0x07,
+	0xAE,0x97,0xD2,0x5F,0xB6,0x3B,0x04,0xD0,0xF1,0x29,0x8D,0x01,0x19,0xDE,0xF6,0x6E,0x25,0xF4,0xC8,0xF4,
+	0x7B,0x6D,0xE3,0xA2,0x2E,0x45,0xBB,0x0F,0x1E,0x13,0xD0,0x9D,0xB7,0xDA,0x74,0x54,0x25,0x9E,0xC8,0xDD,
+	0xDF,0x26,0x9F,0x52,0x00,0x8A,0x75,0x00,0x19,0x5B,0xA5,0x5A,0x92,0xAE,0x69,0x38,0x2E,0x8C,0x09,0x84,
+	0x62,0x31,0x70,0x23,0x27,0x63,0x97,0x2A,0xCA,0x8B,0x8A,0x00,0x4D,0x7D,0x00,0x8F,0x87,0x4C,0xAE,0x67,
+	0xBF,0x5D,0x2E,0x2E,0x17,0xB7,0xAB,0x34,0x0D,0x11,0xF8,0x62,0x18,0x7A,0x2C,0xFB,0x9E,0xEA,0x94,0x62,
+	0x2F,0x26,0x52,0x00,0xF2,0xD7,0x04,0xFD,0x1B,0x86,0x72,0x5F,0x21,0xCF,0x05,0xAB,0x09,0x37,0x48,0x3A,
+	0xFE,0xF2,0xC2,0x91,0xBE,0x07,0x4D,0x68,0x0B,0x8B,0x33,0x24,0xE7,0xBD,0x5F,0x4D,0xF6,0x6A,0x43,0x25,
+	0x90,0xDB,0x24,0xEC,0xB3,0x29,0xC8,0x77,0x61,0xAC,0xD1,0xB3,0xFD,0x60,0xF4,0x6C,0xEC,0x4D,0xC1,0xCD,
+	0x9F,0x0E,0xAF,0xCD,0xE7,0xCF,0x7D,0x4E,0x14,0x6E,0xC7,0x37,0x07,0x0C,0x07,0x15,0xFA,0x54,0x2F,0xBE,
+	0x0E,0x39,0x34,0x1E,0xBB,0x25,0xC2,0x37,0x9A,0x14,0x7E,0x01,0x6B,0x99,0x10,0xC2,0xE1,0xBF,0xDC,0xBE,
+	0x51,0x27,0xC3,0x43,0x00,0x4E,0xD6,0xDA,0x61,0x75,0xF5,0xDB,0x74,0x9D,0xBC,0x81,0x00,0x41,0x1F,0x00,
+	0x0D,0x93,0x41,0xAD,0x60,0xB9,0x5E,0xEE,0x77,0x5B,0x6D,0x00,0xF4,0xD7,0x00,0x8D,0xFC,0xF6,0x9D,0xBB,
+	0xA6,0x52,0x52,0xA9,0xA8,0xD4,0xF6,0x3B,0x90,0xC2,0x82,0xE6,0x29,0xFB,0x48,0x6D,0x25,0x7D,0x62,0x8C,
+	0xD2,0x0F,0xDB,0x14,0x18,0x60,0x2D,0xA3,0x71,0x19,0x15,0xE4,0xB9,0x63,0xE9,0x5F,0xA2,0xF5,0x5C,0xCE,
+	0xB7,0x87,0x4B,0xF0,0x68,0xE4,0xDF,0x40,0x2B,0xC2,0x89,0x19,0xCC,0xF0,0x87,0x24,0xCC,0x5C,0x96,0xE9,
+	0xE2,0xEA,0x74,0x67,0xE5,0x81,0x52,0xB0,0xD4,0xB7,0x4D,0x2C,0x76,0xD3,0x97,0x75,0xE6,0x55,0x63,0xB1,
+	0xB3,0xB6,0x48,0xC6,0x36,0x73,0xC7,0x4A,0x45,0x4A,0xB7,0x3B,0xCA,0x5A,0xFD,0xDB,0xE0,0xF8,0x6B,0xBC,
+	0x82,0x0B,0xD9,0x77,0xCE,0x67,0xAE,0x0C,0xFC,0xFF,0x4F,0x7E,0xC7,0x72,0xD5,0xE0,0x36,0x0E,0x24,0x7A,
+	0xEE,0x66,0x87,0xFD,0xFD,0x01,0x6F,0x2E,0x3E,0x5D,0x2E,0xBC,0x97,0x58,0x00,0xB7,0xBC,0x00,0x13,0xA1,
+	0x58,0xA4,0x6C,0x3D,0x89,0x9D,0xC4,0x4D,0xE6,0x32,0xA8,0x82,0xD5,0x9F,0xD3,0x00,0xB2,0x9C,0x00,0x8D,
+	0x1E,0x44,0xEC,0x03,0x3D,0x1F,0xC7,0xE3,0x8D,0x71,0x84,0xF8,0xF4,0x59,0xF8,0x15,0x35,0x84,0x3F,0x15,
+	0xB9,0xDD,0x48,0x35,0x40,0xD1,0x69,0x69,0x34,0x09,0x40,0x12,0x52,0x98,0x68,0x86,0x8D,0x22,0xF1,0x00,
+	0xFE,0x6C,0x71,0x88,0xD6,0xFE,0x73,0x84,0x8A,0xB8,0x55,0xF4,0x26,0x73,0xD9,0x04,0x62,0xE1,0xBC,0xB9,
+	0x9C,0x4F,0x49,0x66,0x16,0xCB,0x28,0xD6,0x4C,0x46,0x43,0xC8,0xBB,0x06,0xDF,0xAB,0x64,0xC6,0x22,0x19,
+	0x75,0xBB,0x48,0x17,0xB2,0x6A,0x45,0xD4,0x43,0x61,0xB1,0xBD,0x59,0x57,0xAC,0x0E,0x46,0x60,0x60,0x45,
+	0x14,0xD0,0xEB,0x88,0xFF,0x56,0xFF,0xB7,0x03,0x80,0x48,0xDD,0xC0,0x43,0x1E,0x67,0x93,0x29,0x62,0xA2,
+	0x5D,0x19,0x1B,0xEC,0x18,0x56,0x86,0x23,0x6E,0xC1,0xB0,0xB7,0xC8,0x2F,0xFE,0x8A,0x85,0x00,0x00,0x78,
+	0x97,0x00,0x0D,0x37,0x13,0x66,0x46,0x28,0x16,0x8A,0x8B,0x45,0xE2,0x00,0x47,0xB8,0x00,0x92,0x1A,0x6C,
+	0xEE,0x82,0xCD,0x67,0xAD,0xB3,0xD9,0xDB,0x2F,0x14,0xFB,0xD8,0x12,0xBE,0x13,0xBF,0xA9,0x04,0x62,0x82,
+	0x31,0xA2,0x77,0x0C,0x06,0x46,0x57,0x82,0xA9,0xE0,0x0F,0x95,0x1C,0x05,0x42,0x30,0x5C,0xBD,0xB0,0x60,
+	0xED,0xF8,0x29,0xB3,0x58,0xBC,0x49,0xB5,0xF0,0x4B,0x5F,0xB5,0xF3,0x93,0xD9,0x66,0xA5,0x55,0xBF,0x58,
+	0x17,0x84,0xE5,0x0D,0x20,0xA1,0xC1,0xD9,0x04,0x72,0x53,0x4A,0xBC,0xB6,0x2B,0x9A,0x84,0xD5,0x55,0x57,
+	0x57,0x8E,0x16,0xB9,0xA5,0xD3,0xEC,0xA8,0x34,0x9B,0x8C,0x05,0x35,0x13,0xC6,0xA0,0xA2,0xCB,0x7B,0x3A,
+	0x7B,0x58,0x26,0x03,0x06,0x8E,0x4F,0xB6,0xBE,0x53,0xD7,0xD9,0x40,0x09,0xB5,0xB2,0x67,0x3E,0xE5,0x3D,
+	0xA6,0x6D,0x28,0xAE,0x50,0x11,0x78,0x0A,0xBF,0xBD,0xE2,0xED,0x3D,0xB4,0xBD,0x36,0xEC,0xDE,0x29,0x54,
+	0xFE,0x00,0x59,0xC1,0x00,0x11,0xD0,0x60,0x08,0x70,0x26,0xDE,0x6D,0x34,0x36,0x9B,0xAB,0xA2,0x14,0x59,
+	0x00,0xCA,0x57,0x00,0x8D,0x77,0x8F,0x4F,0x86,0xCF,0x66,0x65,0xB2,0xB3,0xD9,0xA1,0x2D,0xCE,0xC4,0x6F,
+	0x04,0x4A,0xA4,0xB7,0x6A,0x9C,0x8F,0xB5,0xA5,0x55,0x98,0xBC,0xB3,0xCF,0x17,0xFC,0xF6,0x1E,0x5C,0x04,
+	0x30,0xA0,0x3E,0x71,0xA1,0xAC,0x91,0xC6,0x53,0xF8,0x7B,0x00,0x17,0xAC,0xAA,0x87,0xDF,0x61,0x77,0x50,
+	0x35,0x31,0xB7,0xB6,0x69,0x3E,0x10,0x0E,0x4A,0x71,0xA4,0x38,0xEC,0x08,0x6C,0x8C,0x49,0x32,0x27,0xE9,
+	0x1D,0x6B,0xCD,0xBC,0x07,0x03,0x10,0x79,0xA5,0x1E,0xC9,0xC6,0xF0,0xA9,0xD2,0x66,0x1A,0x8A,0xED,0x4D,
+	0x09,0x37,0x1C,0x6B,0x80,0x25,0x9D,0x9A,0xD2,0xCE,0xCD,0xB6,0x8D,0x13,0x96,0x85,0x04,0x92,0x10,0xC7,
+	0x1F,0x24,0xA6,0xE8,0x27,0xF1,0xE3,0x61,0x4D,0x55,0x3C,0x2B,0x0E,0xF6,0x7A,0xFB,0x1F,0xBE,0x5D,0xC3,
+	0x2F,0x45,0x4B,0x00,0x6C,0xB3,0x00,0x10,0x11,0x00,0x6B,0xC0,0x6A,0xB7,0x59,0x2D,0xAD,0x96,0xAC,0xC0,
+	0x8B,0x00,0xE5,0x19,0x00,0x8D,0xDF,0x67,0x0C,0x73,0x35,0x1B,0x6D,0x8D,0x46,0xA3,0xF6,0xE1,0x99,0xE6,
+	0xD9,0x04,0x55,0x7D,0xBB,0x27,0xAD,0x1D,0x6B,0x68,0xE5,0x6C,0x31,0xC9,0x95,0xC5,0x13,0x04,0x55,0x2F,
+	0x82,0x1C,0x24,0xC3,0xE6,0x9B,0xBD,0x56,0xBD,0xB3,0x2E,0x6A,0x09,0xE8,0x0F,0x35,0xCD,0xF5,0xAF,0xCC,
+	0xF0,0xC7,0x64,0x36,0xEB,0x64,0xF5,0x18,0x7B,0x3E,0xDE,0x4F,0x8B,0x2F,0x79,0xC4,0x5D,0xCE,0xCA,0xAE,
+	0x5F,0x50,0x7C,0x1F,0x30,0x70,0x24,0x19,0xA5,0xC6,0x63,0xE6,0x13,0xE3,0x0F,0xC2,0x2A,0x8F,0x47,0x9B,
+	0xAF,0xF4,0x18,0xBC,0x45,0x13,0xA3,0xC1,0x61,0x50,0xC7,0x0B,0xFB,0xEE,0x51,0x18,0x1D,0x8F,0xEE,0x8C,
+	0x77,0x43,0xDA,0x50,0x7C,0xF1,0x35,0x1B,0xBA,0x28,0xC4,0xFF,0xFA,0x69,0x3A,0x8F,0x7D,0x78,0xC0,0x77,
+	0xB5,0xD4,0xF2,0xA8,0x00,0xB0,0xE2,0x00,0x0D,0x56,0x20,0x18,0x79,0x37,0x33,0x9A,0x99,0x4C,0x0C,0x00,
+	0xE0,0x0D,0x00,0x8D,0xCF,0x6F,0x04,0x77,0x6A,0xB4,0xB4,0xDA,0xED,0x76,0x0C,0xE8,0xD7,0xAE,0xA4,0xDD,
+	0x64,0xB5,0x3D,0x01,0x99,0x5B,0xB3,0xF7,0x0E,0xA1,0x68,0x0B,0x06,0x36,0xE8,0xFA,0x83,0x27,0xCE,0x79,
+	0xF8,0xEA,0xB5,0x0B,0xF6,0xDB,0x27,0x06,0xAF,0x09,0xEF,0xFB,0xF4,0xB9,0x79,0xAD,0xA7,0x0F,0x1F,0x16,
+	0x93,0x94,0x1D,0x29,0x13,0xF0,0x66,0x97,0x18,0x6C,0xF5,0x33,0x6D,0x4E,0xF8,0xE9,0xA5,0x4F,0xF7,0x7E,
+	0xB6,0xE6,0x72,0xF2,0xE8,0x5F,0x0E,0x7D,0x8F,0xEA,0x72,0xAD,0x87,0xDB,0x66,0x37,0x6B,0x43,0x80,0xF8,
+	0xCD,0x0B,0xAD,0x03,0xAC,0xDC,0xD0,0x37,0x56,0xC1,0x3C,0xF8,0x51,0xA7,0x1F,0x08,0x38,0x5F,0x1B,0x9A,
+	0xA3,0x17,0x06,0x52,0xBA,0x73,0xBA,0x6B,0x46,0x20,0x73,0x3F,0xB5,0x45,0xE1,0x78,0xFA,0xC2,0x12,0x2F,
+	0x5D,0xCC,0x00,0x7A,0x05,0x00,0x10,0x44,0x2A,0x40,0x55,0x4F,0xA5,0x91,0x49,0x44,0xE2,0xD7,0x17,0x5F,
+	0x00,0xD6,0xD1,0x00,0x8D,0x9A,0x4D,0x2E,0xE9,0x78,0x7B,0xBD,0xBD,0x5E,0x2C,0xEA,0x56,0x2C,0xEB,0x0D,
+	0x44,0xC2,0x53,0x58,0x70,0x28,0x8D,0xA0,0x8D,0x67,0xA6,0xAD,0x37,0x85,0xC1,0xDD,0xF3,0x36,0xD9,0x18,
+	0x6C,0xC7,0xA3,0x63,0xD1,0xFD,0x57,0x65,0x12,0xCC,0x06,0x73,0xAA,0x56,0x1C,0xFC,0x6B,0x34,0x03,0xE2,
+	0x70,0x7B,0xED,0x3D,0x9D,0x20,0x23,0x43,0xF9,0x50,0x5A,0xC2,0xC2,0xD8,0x84,0xFC,0x68,0x7F,0x26,0xC7,
+	0x62,0xF2,0xED,0xFA,0xBF,0x98,0xDE,0x47,0x04,0xF3,0xC6,0x47,0xED,0xD4,0xAC,0x05,0x39,0xC5,0x34,0xD1,
+	0x7B,0x82,0x3F,0xB4,0xEC,0x18,0x65,0x4E,0xFB,0xB5,0x73,0x53,0xD9,0x71,0x0B,0x55,0x3B,0x31,0x55,0xA4,
+	0xD3,0xD5,0xC5,0xCF,0xB5,0xC5,0x3B,0xCB,0xD6,0x4F,0xCF,0xAB,0x64,0xAF,0x6A,0xED,0x86,0xCF,0x74,0x9D,
+	0x73,0x8F,0xA8,0x00,0x88,0x68,0x00,0x0D,0xAD,0xDE,0x51,0x2F,0x47,0x98,0x48,0x4C,0x26,0x10,0x00,0xA8,
+	0x4D,0x00,0x8E,0x42,0xB4,0xC2,0x14,0x0F,0x84,0xC2,0xE0,0xF0,0xF7,0x0C,0xBB,0xBB,0x39,0x2E,0xBD,0x6C,
+	0x17,0x8B,0xBC,0x42,0xF6,0x22,0x2E,0x90,0x7F,0x9D,0xAD,0xCD,0xD9,0xF6,0xA1,0x10,0xC8,0x5E,0x8B,0x2F,
+	0xA2,0x99,0x18,0x73,0x51,0xE9,0x53,0xEA,0xC9,0xB7,0x57,0x56,0xE5,0xA5,0xE7,0xDB,0x05,0xDD,0xBA,0x4B,
+	0xC5,0x82,0x72,0x46,0x30,0x8E,0x74,0xC8,0x3A,0x82,0xF5,0xA1,0xD2,0x59,0xE8,0xAF,0x19,0x58,0xC5,0xAE,
+	0x6D,0xED,0x44,0xBA,0x13,0x99,0x7E,0x97,0x49,0x31,0x8A,0x1D,0xF0,0x44,0x9A,0x23,0x20,0xC7,0xAA,0xE5,
+	0x6C,0xEB,0x56,0x55,0x5D,0x7B,0x8C,0x0F,0x30,0xA7,0x3A,0xAF,0x7F,0x21,0xE4,0xEC,0x3A,0x92,0xFC,0x4E,
+	0xF7,0x4E,0x93,0x98,0xDB,0x9E,0x20,0x14,0x38,0xC0,0xB4,0xD8,0xB7,0xF8,0x54,0x42,0xC7,0xE0,0x24,0x60,
+	0x31,0xC5,0x00,0xC2,0x37,0x00,0x0D,0xB0,0x67,0x3B,0xE8,0xFE,0x7B,0xB9,0x3D,0x5E,0x6F,0x00,0xA6,0x61,
+	0x00,0x8D,0x45,0xAA,0xA1,0xA5,0x90,0xDD,0x49,0xEE,0xA4,0xD2,0x08,0x58,0xA3,0xC1,0x0D,0x5A,0x0C,0x40,
+	0x95,0x5B,0x8D,0x42,0xF2,0x80,0xE8,0x8C,0xB7,0x6D,0x58,0xA4,0x8E,0xE2,0x9D,0x8C,0x24,0xF7,0x11,0xC9,
+	0x84,0xD5,0x05,0x42,0x13,0x90,0xD0,0x33,0xC6,0x50,0x87,0xA3,0x6C,0x20,0x49,0x13,0x26,0xD1,0x88,0x76,
+	0x4B,0x06,0x3C,0xF2,0x7D,0x41,0x1E,0xA1,0x8C,0xD2,0xA2,0x20,0x57,0x62,0x10,0x27,0x6A,0xD4,0x34,0x89,
+	0x6A,0x0C,0x75,0x92,0xFB,0x82,0x82,0x40,0x66,0x50,0xB8,0x40,0x16,0x6C,0x8B,0xD0,0x28,0xBA,0x93,0xDF,
+	0x23,0x87,0x0F,0x9C,0x94,0x64,0x21,0x6F,0x91,0xAF,0x4B,0x2D,0x77,0xB5,0x8A,0x16,0x6B,0xD3,0xBB,0x4E,
+	0xFF,0x48,0xCD,0x15,0x52,0x40,0xBA,0x77,0xDC,0xEE,0xF0,0x5B,0x7F,0xCA,0x42,0x20,0xD3,0x18,0x39,0xC1,
+	0x00,0x2F,0xD5,0x00,0x0D,0x85,0xCA,0x1B,0x25,0x62,0xB3,0xDC,0xE7,0xEC,0xB3,0x00,0xA0,0x13,0x00,0x8D,
+	0x93,0xC1,0x68,0x00,0x8C,0xC7,0x13,0x63,0x31,0xC5,0x7A,0x8D,0x21,0x88,0x51,0x12,0xDD,0x63,0x12,0x88,
+	0x08,0x7F,0x39,0xB4,0x1D,0x8F,0x20,0xDF,0xFC,0xA9,0x76,0x32,0x3E,0xBF,0x1E,0x2F,0xEE,0x2E,0x6D,0x40,
+	0x39,0x65,0x67,0xF1,0x01,0xD2,0xEE,0x6C,0x7A,0xAE,0x1E,0x77,0xCC,0x46,0xBE,0x26,0x93,0xFB,0x2F,0x1A,
+	0xB5,0x55,0xD4,0xF9,0x93,0x93,0xFD,0xF8,0x4B,0xA3,0x3D,0x18,0xF6,0x43,0x33,0xDE,0x1B,0x7B,0xA3,0x34,
+	0x48,0x73,0xBD,0x2B,0x3E,0x0B,0x87,0x90,0x38,0x98,0x05,0x52,0x86,0x41,0x9C,0xB1,0xB7,0xDD,0x24,0xCA,
+	0x91,0xCC,0x4A,0x96,0xC2,0x22,0x66,0xE6,0xB3,0x5D,0x27,0x6D,0x37,0xB7,0x9D,0xAB,0xC5,0x92,0xD4,0x7C,
+	0x58,0xB9,0xAC,0x45,0xA6,0xEB,0x0D,0xEE,0xB5,0x6F,0xDD,0x1E,0x67,0x0E,0xB0,0xEA,0xA1,0xD9,0x00,0xEC,
+	0xA4,0x00,0x0D,0xBC,0x56,0x25,0xE7,0xFD,0x7C,0xBB,0xFE,0x3F,0x5F,0x00,0xFA,0x98,0x00,0x8D,0xBD,0xB2,
+	0x3D,0x6B,0x2F,0x3A,0x95,0x9D,0x4E,0x27,0xA0,0xEA,0xDD,0x62,0x83,0xE6,0xBC,0x0F,0x5F,0x53,0x2D,0x2E,
+	0x4A,0xE7,0xAA,0xC8,0x52,0xEC,0xD2,0xBF,0x55,0x22,0xC1,0xEA,0xE5,0xCD,0x86,0x0E,0xDC,0x06,0xB0,0x67,
+	0xDB,0x7D,0x12,0x37,0x35,0x62,0x0D,0x1D,0x23,0x83,0xC3,0x84,0x6A,0xA5,0x72,0xE0,0x41,0x60,0x43,0xBA,
+	0xA2,0x48,0xAA,0xD2,0x52,0xF6,0xAA,0x56,0x5C,0x7B,0x73,0x64,0x5D,0xEB,0x9C,0xAD,0x9A,0x5C,0x6A,0x33,
+	0x68,0x0C,0x3C,0xF4,0xDA,0x1B,0xB9,0x60,0x04,0x37,0xF4,0xEB,0x77,0x65,0xFD,0x20,0xF0,0xEF,0xB1,0x41,
+	0x7F,0x59,0xBE,0x4B,0xFF,0x66,0x40,0xC2,0xCE,0xCE,0x61,0x03,0xE5,0xED,0xF1,0x04,0x55,0x83,0xD3,0xD7,
+	0x7E,0xAB,0xCC,0x99,0xC7,0xCA,0x99,0x87,0x53,0xC4,0x54,0xD5,0x84,0x6B,0x5F,0xD7,0x00,0x45,0x67,0x00,
+	0x0D,0x10,0x00,0x6A,0xC0,0xDA,0x6E,0xB1,0x5B,0x5B,0xED,0x00,0xB8,0x92,0x00,0x8D,0xC7,0x6B,0x00,0xF5,
+	0xF6,0xF5,0x7A,0x7A,0xBD,0x3D,0x4F,0x39,0x44,0xC2,0xD0,0x6A,0x45,0x0B,0x60,0x0D,0x49,0xCF,0x37,0x46,
+	0x43,0x7E,0xD8,0x3C,0x5F,0x8C,0xD0,0xBD,0xCB,0xA6,0xD6,0x96,0x51,0xB9,0x5F,0x44,0xF2,0x50,0xF4,0xF3,
+	0xCA,0xE1,0x5A,0xFD,0x6F,0x35,0x6F,0x02,0x9C,0x9B,0x84,0x2A,0x6B,0x5D,0x09,0x04,0xCA,0x0D,0x27,0x58,
+	0xE5,0xF0,0x78,0xBA,0xDD,0xDD,0xEE,0xF7,0xF7,0xFB,0x7D,0x7D,0xBE,0x5F,0x5F,0xAF,0xFF,0xD7,0xFF,0x6B,
+	0xB5,0x90,0xC8,0xBE,0x63,0xDF,0xEF,0xEF,0xF7,0x27,0x93,0x1F,0xC9,0x8F,0x47,0xF9,0x7C,0x68,0x34,0x1A,
+	0x86,0x23,0x01,0xDB,0x98,0x89,0xCF,0x7B,0x59,0xC3,0x4C,0xA6,0x19,0x0C,0x0C,0x06,0x06,0x02,0x02,0x01,
+	0x80,0x3F,0x1F,0x4F,0x27,0x73,0x93,0x39,0x9C,0x06,0x03,0x03,0x01,0x01,0x00,0xBF,0xE6,0x00,0x0D,0xEA,
+	0x3D,0x96,0x21,0x1B,0x0D,0x00,0x86,0x03,0x43,0x00,0xD8,0x80,0x00,0x8D,0xEB,0x7D,0xB6,0x2E,0x33,0x97,
+	0x97,0x4B,0x25,0x92,0x12,0x89,0x89,0x44,0x44,0xA2,0xA2,0x50,0xA8,0xA8,0x83,0x92,0x35,0x2D,0x32,0x31,
+	0x52,0x52,0x50,0xC0,0xC1,0xAD,0x8A,0xC5,0xC5,0xE2,0xE2,0x70,0xB8,0xDB,0xDC,0xEE,0x2E,0x76,0x96,0xCB,
+	0x65,0x69,0x32,0xB4,0x5A,0x4C,0xA6,0x16,0xD3,0x0B,0x69,0x34,0x34,0x9A,0x45,0x22,0x26,0x13,0x48,0x89,
+	0xC4,0x62,0x0A,0xB0,0x05,0x58,0x1D,0xEE,0x47,0x13,0x2E,0xD2,0xF0,0x54,0x4D,0xCE,0xF6,0x76,0x7A,0xBB,
+	0xDD,0xDD,0x6E,0x37,0x4B,0x1B,0x25,0x12,0x89,0xAA,0x44,0x55,0xAA,0xAA,0xD5,0xD7,0x6A,0xEB,0x75,0x75,
+	0xBA,0x0A,0xDD,0x05,0x6E,0x02,0x37,0x1B,0x68,0x0D,0xE3,0xA2,0xB8,0x34,0x0A,0x52,0xB8,0x5C,0xA1,0x38,
+	0x40,0x6D,0xC5,0x7B,0xF6,0x20,0xCB,0xB0,0x9B,0xF0,0xEF,0xF4,0x00,0xA5,0x8F,0x00,0x0D,0x90,0x47,0xAB,
+	0x20,0x3A,0x1E,0x08,0x0F,0x07,0x47,0x00,0xA0,0x71,0x00,0x8D,0xE9,0x7C,0x17,0x7E,0xB3,0xD8,0xD7,0xEB,
+	0xEB,0x75,0x6A,0xFA,0x35,0x7D,0x9A,0xCD,0x54,0x66,0xA9,0xD4,0xE5,0xEA,0x72,0x75,0xB9,0xBA,0x5C,0xAE,
+	0xAD,0xD6,0x6B,0x6B,0xB5,0x5A,0xAD,0xAD,0xD6,0xD6,0x6B,0x6A,0x04,0xE2,0xEA,0x2E,0x6D,0x73,0xE5,0xF2,
+	0xF2,0xF9,0xF9,0x7C,0x7C,0xBD,0x5E,0x5E,0x2F,0x2F,0x97,0x97,0x4B,0x4B,0x25,0x25,0x92,0xC9,0xC8,0x64,
+	0xE4,0x72,0x72,0x39,0x1C,0x8E,0xC7,0xC6,0xE3,0x71,0x58,0x2C,0x56,0xC0,0x4F,0x29,0xC3,0xC3,0x9C,0x85,
+	0x66,0x1B,0x47,0x48,0xDC,0x50,0x09,0x32,0x70,0xC4,0xB8,0x5C,0xB1,0x2D,0x58,0xAC,0xB7,0x55,0x5B,0xAB,
+	0xD5,0x6A,0xEB,0x35,0x1A,0xBA,0x8D,0xC6,0xEE,0x77,0x76,0xBB,0xDD,0xEE,0x10,0xF7,0x07,0x83,0x3E,0x9F,
+	0xCF,0xE6,0x73,0xB3,0xB9,0x59,0x2C,0x2C,0x27,0x2E,0x00,0xE1,0x84,0x00,0x0D,0xA1,0x76,0xB3,0x7B,0xB6,
+	0x06,0x5E,0x82,0x81,0x2C,0x00,0x06,0x1E,0x00,0x8D,0xDC,0x8D,0x0D,0x86,0xCF,0xCC,0x66,0x5D,0xB2,0xD9,
+	0x10,0x94,0x6D,0x73,0xCB,0x65,0x32,0x35,0x19,0x1A,0x8C,0xC6,0xE2,0xF1,0xF1,0xF8,0xF8,0xFC,0xFC,0xFD,
+	0xFD,0xFE,0x7F,0x7F,0xBF,0x3F,0x9F,0x3F,0x9F,0x9F,0x4F,0x03,0x27,0x01,0x22,0x54,0x89,0xCB,0x7E,0xD2,
+	0x5E,0x9F,0x67,0x05,0x16,0x14,0x09,0xF5,0x99,0x4F,0x24,0x00,0xEC,0x64,0xAA,0x52,0xB5,0xC9,0x66,0x8B,
+	0xBF,0x37,0x87,0xFA,0x17,0x37,0x2F,0x35,0xE1,0x61,0x74,0x23,0xDE,0xB1,0x50,0xBF,0xAA,0x4C,0x63,0x54,
+	0xCC,0xCD,0xE7,0xF5,0x55,0x0B,0x84,0xAB,0xC4,0xD1,0x19,0x00,0x83,0x3D,0xAC,0x1C,0x1D,0xA8,0xE6,0xAB,
+	0x6F,0xAE,0x19,0xD6,0xF1,0x30,0x14,0x9C,0xF7,0x84,0x75,0x13,0x7C,0x32,0x99,0x11,0x50,0xB4,0x1D,0xF2,
+	0x29,0x05,0x99,0xEE,0x31,0x3F,0x4F,0xFE,0x00,0xAD,0x50,0x00,0x0D,0x7D,0xE5,0x7A,0xB5,0xD1,0xFD,0x76,
+	0xB5,0x5A,0xED,0x00,0x88,0x8D,0x00,0x8D,0xBC,0xD6,0xF3,0x0C,0x19,0x09,0x04,0x02,0xFF,0x7F,0x1F,0xF0,
+	0x8F,0x5F,0x86,0x4D,0x3F,0x5D,0xBC,0x96,0xE0,0x8D,0x93,0x35,0x3E,0x63,0x33,0x30,0x94,0xC3,0xDA,0xF9,
+	0xEB,0x79,0xB7,0x59,0x15,0xB5,0xA1,0x83,0xBC,0xA6,0xF7,0x00,0x4A,0x23,0xE9,0x85,0xE3,0x3B,0xC1,0xC2,
+	0xE0,0xE0,0xF0,0xF0,0x77,0x78,0xBB,0x3B,0x5D,0x9D,0x2E,0x97,0x97,0xCB,0xCB,0x65,0x8E,0x47,0x46,0xA3,
+	0x48,0x51,0x24,0x12,0x06,0x09,0x03,0x81,0x81,0xC0,0xEE,0xD8,0x77,0xE0,0xAC,0x13,0x82,0x0A,0x60,0x74,
+	0x97,0x4B,0xEF,0xF7,0xFB,0xFB,0xFD,0xFE,0xFF,0xFF,0x7F,0x3F,0x3F,0x1F,0x0F,0x07,0x07,0x03,0x01,0x01,
+	0x00,0x80,0xC0,0xC0,0x5F,0x5F,0x78,0x6F,0x76,0x53,0x14,0x22,0x3A,0x9D,0x55,0x42,0x00,0x4B,0xF9,0xBA,
+	0xFC,0xDD,0xEE,0x3F,0x77,0x9F,0x00,0x05,0x93,0x00,0x0D,0x25,0x24,0x71,0x52,0x57,0xA9,0x5C,0x69,0xF4,
+	0xBA,0x00,0x2A,0xDE,0x00,0x8D,0x20,0x18,0x28,0x61,0x7C,0x3F,0x1F,0x1F,0x8F,0xC7,0x52,0xA3,0x51,0x52,
+	0x29,0x14,0x0A,0x44,0x84,0xC2,0x10,0x88,0xB0,0xD8,0xD8,0xEC,0x76,0xBB,0xDD,0xDD,0xEE,0x77,0x37,0x9B,
+	0x2C,0x75,0x21,0x9F,0x88,0xAB,0x56,0xE8,0x11,0x0C,0x97,0x01,0x80,0x80,0xC0,0x8D,0xDF,0x46,0xEF,0x23,
+	0x91,0x91,0xC8,0xC8,0xE4,0x47,0xF2,0xA3,0xD1,0x68,0xDE,0x34,0x9A,0xCD,0xCD,0x66,0xBC,0x0D,0x78,0x62,
+	0x15,0xF9,0xB6,0xB6,0x23,0x4F,0x06,0xCE,0x6B,0xAB,0x9E,0xCB,0x3E,0x6B,0x76,0x1C,0x99,0xBC,0xDE,0xA6,
+	0xD3,0x45,0x69,0x22,0x91,0x90,0xC8,0xC8,0x64,0xAF,0xB1,0x57,0x58,0xAB,0xAC,0x55,0x56,0x2B,0x2B,0x15,
+	0xA4,0xB2,0x42,0x3D,0x39,0x59,0x70,0xB8,0xDB,0xDB,0x6D,0x6D,0x36,0x1B,0x0D,0x06,0x06,0x83,0x83,0xC1,
+	0xC1,0xE0,0xE0,0x70,0x00,0x20,0xB1,0x00,0x0D,0x1A,0x85,0xEE,0x02,0x18,0x8D,0x4F,0xA3,0x51,0x11,0x00,
+	0x5F,0xEF,0x00,0x8D,0x42,0x15,0x82,0x4D,0x2A,0x39,0x1C,0x0E,0x04,0x02,0x41,0xBF,0x5F,0xAF,0xB0,0x58,
+	0x57,0x2B,0x47,0x90,0x65,0x81,0x52,0x7A,0x62,0x59,0xFA,0x55,0x60,0x60,0x48,0x39,0xBC,0x93,0xEB,0x15,
+	0x8A,0x95,0x45,0x4A,0xA2,0xA5,0x52,0xA9,0xA9,0xD4,0x74,0xEA,0x75,0xBA,0xCE,0xDC,0xEE,0x77,0x3B,0x1D,
+	0xFE,0x0F,0x87,0x87,0xC3,0x61,0xAF,0x30,0x18,0x6B,0xBA,0x3D,0xDD,0xB5,0xF6,0x3E,0x86,0xC3,0x3C,0x9E,
+	0x9E,0x4F,0xFD,0xA7,0xFF,0x7F,0x7F,0x3F,0x4A,0xA0,0x25,0x12,0xB3,0x59,0x04,0xAC,0x02,0x81,0xB4,0xE3,
+	0xE9,0x15,0x93,0x3D,0xA9,0x6D,0x9C,0xFF,0xEB,0xE8,0xF7,0x8B,0x06,0xF0,0x7B,0x7F,0x43,0x33,0xE2,0x76,
+	0x87,0xD0,0x7F,0x07,0x31,0x70,0x74,0xD9,0x6D,0x26,0xBD,0xBE,0x28,0x85,0x93,0x50,0x68,0xEA,0x95,0x92,
+	0x48,0xBD,0x00,0x97,0x6F,0x00,0x0D,0x37,0x13,0x78,0xC9,0xD3,0x6B,0x3C,0xB5,0x9A,0x8D,0x00,0x99,0x32,
+	0x00,0x8D,0x8C,0x5B,0xA5,0x27,0x3A,0x9C,0xCD,0xE6,0x73,0xB9,0x53,0x9D,0x28,0x01,0x81,0x59,0x03,0xDD,
+	0xEF,0xD8,0x7D,0x0D,0xEE,0xEA,0xF5,0x86,0x93,0xE0,0xE3,0xE7,0x19,0x98,0x4A,0xBF,0x0F,0xDF,0x7A,0x75,
+	0x56,0x3D,0xA8,0x57,0x7B,0xAB,0xA0,0xDE,0x1B,0xE8,0x96,0x57,0x1A,0x2E,0x20,0x39,0x2D,0x2B,0x42,0xC9,
+	0xE9,0x04,0xC5,0x0A,0x62,0x29,0xE2,0xF2,0x8F,0x82,0x09,0xBA,0xD8,0x2B,0x0F,0xFB,0xF1,0x04,0xD2,0x40,
+	0xE5,0xFB,0x66,0x27,0x39,0x93,0x9C,0xCC,0x9F,0xFF,0x62,0x0D,0xFB,0x15,0x4E,0x8F,0x6B,0x0D,0x7E,0x12,
+	0x28,0x2F,0xCB,0xCB,0x65,0xE0,0x32,0xEF,0xF7,0xF8,0xFC,0xD3,0xE9,0xE9,0x74,0x8F,0x3A,0x47,0x9D,0xCE,
+	0xCE,0x67,0x91,0xC8,0xDA,0xE4,0x43,0x41,0x3D,0xC5,0x45,0x67,0xB8,0x0F,0xE2,0x35,0x11,0x88,0x8E,0x8E,
+	0x00,0xAE,0xA5,0x00,0x0D,0xAD,0x5E,0x27,0xEF,0xFC,0xF8,0xF6,0xED,0x7D,0x36,0x00,0xC5,0x6A,0x00,0x8D,
+	0x51,0xC4,0x4B,0xA2,0xCD,0xDE,0xE7,0xEE,0xF3,0x77,0x7B,0xBC,0x5E,0xAE,0xD7,0xEA,0x75,0xBA,0x5D,0x5D,
+	0x2E,0x17,0x17,0x8B,0x92,0x9A,0x83,0xA9,0x70,0x9C,0x04,0x04,0xFA,0x95,0xEB,0xB8,0x7F,0x80,0xC0,0xC0,
+	0xDF,0xDF,0xEF,0xEF,0x77,0xBB,0xDD,0xDE,0xEF,0x77,0x3B,0x9D,0x9D,0x4E,0x4E,0x27,0x67,0x13,0x33,0x19,
+	0x90,0xA8,0xD7,0xB0,0x32,0x3B,0x3B,0xD3,0xF4,0x12,0xFB,0x7D,0x30,0x18,0x18,0x0C,0x0F,0x87,0x83,0xC1,
+	0x61,0xB0,0xD8,0xD8,0xEC,0xEC,0x76,0xCA,0x6D,0x65,0x53,0x41,0x0F,0xAF,0x9B,0x9E,0xB7,0x5B,0xCC,0xDF,
+	0x63,0xA2,0x9A,0x49,0x38,0x2B,0x75,0x37,0x8C,0xC6,0xC6,0x63,0x31,0x94,0x98,0x4C,0x24,0xA5,0xD2,0xD2,
+	0xE9,0x39,0x74,0x3A,0x39,0xA4,0x03,0xDA,0x9A,0x88,0xC5,0x62,0x87,0x31,0x44,0x22,0xE6,0xF3,0x00,0x4F,
+	0x37,0x00,0x0D,0x99,0x44,0x84,0xE2,0x2C,0x7E,0x35,0xBE,0x9F,0x8A,0x00,0x1D,0x8D,0x00,0x8D,0x0F,0xD8,
+	0xE4,0x29,0x98,0xCC,0x66,0x32,0x99,0x4C,0xE6,0xE6,0x72,0x72,0x39,0x1C,0x1C,0x0E,0x0D,0x86,0xC6,0xD0,
+	0x25,0x21,0xD7,0x38,0xD6,0x07,0xC3,0x4B,0x5D,0x2E,0xD6,0x03,0x7C,0x73,0x63,0x31,0x32,0x19,0x8B,0x45,
+	0x45,0x22,0x91,0x48,0xA4,0xA4,0xD2,0xD1,0x68,0xB4,0x5A,0xAC,0xD6,0x6A,0xB5,0xDA,0xDA,0x6D,0xDD,0x8E,
+	0xF1,0x22,0xB6,0xF5,0xA6,0xA6,0x53,0x52,0x29,0x29,0x14,0x14,0x0A,0x05,0x02,0x81,0x80,0x40,0x3D,0x03,
+	0x19,0xA0,0x06,0x8C,0x04,0xBB,0x75,0x0A,0x11,0xD2,0x89,0x96,0xE8,0x7E,0xBC,0xB8,0xA0,0x53,0x26,0x46,
+	0xBF,0x4C,0x61,0x49,0x26,0x36,0xBB,0x02,0x89,0xF8,0xE7,0x46,0x52,0xD3,0xAD,0xCF,0x28,0x96,0x2B,0x2C,
+	0x17,0x12,0xBC,0x78,0x5F,0x3B,0x2E,0x8E,0x49,0x4A,0x1A,0xA2,0x14,0x39,0x74,0x45,0x00,0x1A,0xAC,0x00,
+	0x0D,0xA8,0xDC,0x7A,0xAE,0xDC,0x6A,0xBE,0xF6,0xDA,0x3B,0x00,0xB9,0x69,0x00,0x8D,0x57,0x80,0xC8,0x65,
+	0x0C,0x3D,0x1E,0x6A,0x35,0xC7,0x61,0xA2,0x1D,0x53,0x3A,0x7F,0x75,0x71,0x26,0x43,0xBC,0xA1,0xA3,0x19,
+	0x3B,0x8B,0xB5,0x25,0x74,0x93,0x3C,0x66,0xB1,0x46,0xC3,0x7D,0x13,0xF5,0x2A,0xBD,0x18,0x31,0x71,0x51,
+	0x78,0x48,0xE3,0xEE,0xF1,0x00,0x31,0x79,0x66,0xC7,0x6F,0x1B,0xEA,0x7A,0x89,0xCE,0xB3,0x9E,0xF4,0xCE,
+	0x82,0xBC,0xD0,0x7C,0x0A,0x3B,0xC6,0x61,0x82,0xA9,0xEA,0xA6,0xAE,0xB7,0x7F,0x93,0x03,0x01,0xF9,0x14,
+	0x2B,0x67,0xEF,0x77,0x77,0x3B,0x1D,0x1E,0x8F,0x8F,0xC7,0x63,0xB1,0xB1,0xD8,0xEC,0x76,0x3B,0xAC,0xA5,
+	0x49,0x7E,0x3C,0x5B,0xB4,0x11,0xED,0x12,0xA4,0x52,0x63,0x67,0x31,0x98,0x59,0xCC,0xAC,0x56,0xA4,0x81,
+	0x21,0xF8,0x47,0x8B,0x1F,0x0F,0xFF,0x97,0xAA,0x18,0xD0,0x68,0xB4,0xB3,0x00,0xC9,0x2A,0x00,0x0D,0xB3,
+	0x7F,0xBA,0x28,0x32,0x1B,0x3B,0x18,0x97,0x0B,0x00,0xC3,0x75,0x00,0x8D,0x49,0x98,0xC4,0x97,0x87,0xC4,
+	0x62,0x62,0x31,0xD9,0xAC,0xCB,0xD6,0xEB,0xF5,0x16,0xFB,0x7D,0x85,0xBE,0xDF,0xE1,0xDE,0x48,0xBF,0xA3,
+	0x76,0x65,0x19,0x42,0x36,0x73,0x5E,0xAF,0xB2,0x57,0x58,0xAB,0xAC,0xD6,0xD6,0x6B,0xBC,0x0D,0xA4,0xE2,
+	0xFA,0xD5,0x40,0xA0,0x28,0x06,0x0C,0xCB,0xD9,0xAB,0x9E,0xA7,0x88,0xDD,0x2D,0x47,0xB4,0xB4,0xDA,0xDA,
+	0xEC,0xF6,0xFA,0x7D,0x0F,0x06,0x98,0x67,0xD4,0xD7,0x97,0x4B,0x4B,0xA5,0xA5,0xD2,0xD2,0xE9,0xE8,0x74,
+	0x34,0xA9,0x5C,0x1D,0xCB,0xB6,0xAF,0x3F,0xFF,0xD7,0x21,0x90,0x69,0x5C,0x23,0xDC,0x32,0x18,0x19,0x0C,
+	0x06,0x02,0x02,0x01,0x00,0x80,0x3F,0x9F,0x4F,0xA7,0xA8,0x53,0x18,0x6C,0xAD,0xD2,0x4E,0x0C,0xDA,0xDA,
+	0x6D,0x6D,0x36,0x1B,0x39,0x2E,0x04,0xF6,0x23,0x4C,0x11,0xB1,0x00,0x22,0x85,0x00,0x0D,0x9A,0xC5,0xEA,
+	0x5A,0x26,0x21,0x9C,0xC8,0xC8,0xA4,0x00,0x73,0x6C,0x00,0x8D,0x98,0x4F,0xAF,0x66,0xBF,0xCF,0x67,0x2C,
+	0x16,0x0B,0xA5,0xC7,0x77,0x14,0x89,0xDD,0x39,0x5B,0x7B,0xAA,0x29,0xB0,0xD7,0x6C,0x2A,0x98,0x3D,0x25,
+	0x90,0xA0,0x90,0x0E,0x9C,0x72,0x52,0x98,0x37,0x17,0x9F,0x98,0x03,0xFF,0x1F,0x18,0x0D,0x1F,0x30,0xFE,
+	0x19,0x18,0x0D,0xA0,0x20,0xA1,0x51,0x7F,0xAE,0x0F,0x24,0x6B,0x34,0xCE,0x37,0x60,0x60,0x67,0xD8,0xCC,
+	0x60,0x22,0x9D,0x10,0x1D,0xEA,0xE5,0x72,0x8F,0x1D,0x68,0x1D,0x72,0xC1,0xF6,0x67,0x6B,0xEE,0x47,0xBC,
+	0x0E,0x2E,0xF2,0xC4,0x84,0x2A,0x0A,0x75,0xDA,0xB3,0x3E,0x06,0x42,0x6F,0xDF,0xCC,0x2E,0xCE,0x4B,0x90,
+	0x52,0xBB,0xDE,0x01,0xD0,0xB7,0x1A,0x00,0x0E,0x98,0x66,0x0D,0x53,0xB4,0x48,0x43,0x3C,0x4D,0xDB,0x85,
+	0xE6,0x5B,0xCF,0xE7,0x1F,0x67,0x18,0xC1,0x79,0x3C,0x00,0xAF,0x18,0x00,0x0D,0x56,0x23,0x48,0xD0,0x63,
+	0x33,0x15,0x8C,0x0C,0x46,0x00,0xFF,0x15,0x00,0x8D,0x6F,0x3F,0x54,0x5F,0x23,0x10,0x08,0x04,0x82,0xC0,
+	0x40,0x20,0x10,0x87,0x43,0xC4,0x53,0x59,0xB7,0x39,0xBB,0x98,0x77,0x70,0xDD,0x49,0x09,0x01,0xC5,0x31,
+	0x29,0xFC,0x6B,0xB6,0x89,0x90,0xB0,0x5E,0x4F,0x5D,0xF2,0x79,0x3C,0x3C,0x9E,0x24,0x12,0x89,0x38,0x7C,
+	0x25,0x55,0x8B,0xCE,0x67,0xFD,0x88,0x2C,0xC6,0x07,0xD4,0x89,0xB9,0xF8,0x58,0x8B,0x8F,0x14,0x72,0x51,
+	0xB9,0x11,0x84,0x77,0xF0,0xFC,0xA0,0xF1,0x78,0x51,0x0E,0xB7,0x18,0xD7,0x94,0x0F,0x91,0xC8,0x88,0xF7,
+	0x39,0xB1,0x78,0x6F,0x36,0x54,0x33,0x62,0x26,0x7A,0x6A,0xDD,0xA2,0x1C,0xD2,0x13,0x89,0xB4,0xDA,0xDA,
+	0xED,0xF2,0xC8,0xC0,0x7B,0xE5,0xD5,0x96,0xB5,0xB4,0xC2,0x13,0xB5,0xE3,0x12,0x3B,0x2D,0x0B,0x14,0xFA,
+	0x97,0xC8,0xE2,0x63,0x8F,0xD5,0x04,0x05,0x00,0xD1,0x79,0x00,0x0D,0x14,0x82,0xE8,0x81,0xCE,0xCF,0x68,
+	0x32,0x18,0x4C,0x00,0x36,0xBB,0x00,0x8D,0x66,0xBB,0xD4,0x1F,0x83,0x80,0x40,0xA0,0xD0,0x4F,0x6D,0x60,
+	0xF3,0xE8,0xA8,0x3A,0x1E,0xB1,0x4D,0xF2,0xBC,0x43,0x1A,0x59,0xEE,0x69,0x3B,0xD6,0x3C,0x0C,0x03,0x1B,
+	0xE8,0xF0,0xAC,0xA0,0x5B,0x6F,0xA0,0xA7,0xD4,0xFE,0xEB,0x7A,0x75,0xB5,0x4A,0xEA,0xF2,0x97,0x38,0x92,
+	0x02,0x17,0x4F,0x2B,0x2B,0x15,0xF9,0x75,0xFD,0x66,0x80,0x79,0xB8,0x60,0xDD,0xAF,0xC8,0x08,0xDC,0xE0,
+	0x0B,0xE6,0x52,0x17,0xE7,0xCD,0x04,0x0B,0x05,0x15,0xF8,0x73,0xF6,0x29,0x4F,0x7B,0x8C,0xCA,0x6B,0x57,
+	0x92,0x14,0xCD,0x77,0x8D,0xF5,0x7F,0x7D,0xBE,0x1E,0xE3,0xE2,0xF0,0x9C,0x58,0x73,0x16,0xBC,0x88,0x4B,
+	0x55,0xD4,0x21,0x2F,0x15,0x34,0x83,0xCA,0x25,0xBB,0xE7,0xF6,0xEB,0x24,0x60,0xD4,0xB8,0x04,0xA5,0xD1,
+	0x72,0x39,0xF4,0xEF,0xFA,0x5A,0x00,0xDA,0x24,0x00,0x0D,0xD0,0x60,0xBB,0x28,0x32,0x1B,0x16,0x0D,0x46,
+	0x06,0x00,0x8A,0x5A,0x00,0x8D,0xC9,0x1F,0x87,0x4F,0xAB,0xD3,0x69,0xF4,0xFA,0x5C,0xEF,0x4D,0xA7,0x6F,
+	0x89,0xF5,0x54,0x07,0x99,0x73,0x42,0xFD,0x29,0x9B,0x07,0x62,0xC9,0x54,0xEA,0xF3,0x10,0xB7,0x34,0xF1,
+	0xF2,0xF6,0xED,0x0C,0xE5,0x16,0x74,0xEE,0x17,0x18,0x1E,0x60,0xA7,0xC2,0x25,0x2E,0x21,0x37,0x73,0xFA,
+	0x16,0xAD,0x54,0x1E,0x28,0xC0,0x30,0x17,0xB4,0x42,0xC9,0x79,0x68,0xDF,0x48,0xA5,0x6A,0x05,0x6B,0xD6,
+	0x7A,0x90,0xB6,0x4A,0x88,0xE8,0x7E,0xCC,0x3E,0xB3,0x0B,0xD9,0x0E,0x8D,0x95,0xC6,0x61,0xF6,0x79,0x92,
+	0xD6,0xF8,0xB7,0x3A,0xE2,0x37,0x58,0x79,0xC1,0x61,0xF0,0x16,0x46,0xD0,0xF4,0xDD,0xFD,0xC1,0x23,0xA6,
+	0x6E,0x09,0x67,0x66,0x60,0xE1,0xF7,0x2D,0x0E,0xB7,0x65,0x13,0xB8,0x88,0x2B,0x90,0x82,0xE3,0x88,0x23,
+	0x10,0x38,0xBC,0x51,0x00,0xEE,0x10,0x00,0x0D,0x39,0x94,0x9C,0xBB,0xA1,0xD2,0xDC,0xE9,0xE8,0x34,0x00,
+	0xFA,0xA1,0x00,0x8D,0x1E,0x87,0xA4,0x02,0xBA,0x0E,0xDC,0x87,0xED,0x76,0xF7,0x4E,0xBD,0x5C,0x3F,0xAE,
+	0x9F,0x09,0x16,0x78,0x8B,0x04,0x60,0x81,0x31,0xF1,0x99,0xAC,0x29,0x11,0x92,0x29,0xEC,0xF1,0x70,0x5A,
+	0x5C,0xB0,0xB6,0x3F,0xAF,0x41,0xCF,0xD8,0x83,0xFB,0x8C,0x6D,0x92,0x4F,0xA6,0x5E,0xC0,0x38,0x61,0xB6,
+	0x2E,0x99,0xC5,0xC7,0x47,0xC3,0x81,0x71,0xC6,0x5C,0xCE,0x54,0xF1,0x96,0xB8,0xCD,0xB2,0xA6,0xDE,0xF7,
+	0xE2,0x81,0xD9,0x7A,0x37,0x5D,0x15,0x6F,0x77,0xF6,0xAA,0x3A,0x9B,0x3D,0x60,0xFA,0x9C,0xFE,0xA5,0x6C,
+	0x3B,0xE7,0x07,0x1C,0x8C,0xD9,0x31,0x84,0x94,0xDC,0xBA,0x25,0xB4,0x13,0x7B,0xE8,0x07,0x1C,0x62,0x40,
+	0x49,0x81,0x90,0x27,0x14,0x9B,0x3C,0x07,0xA4,0x4C,0x71,0xBE,0xD4,0x5F,0x48,0x22,0x6A,0x91,0x7C,0x3A,
+	0x25,0x9C,0x00,0xD5,0x78,0x00,0x0D,0x7E,0xF4,0xF2,0xDB,0x96,0x49,0x2A,0x92,0x12,0x49,0x00,0x3D,0xBF,
+	0x00,0x8D,0xEE,0xFF,0xB5,0x3F,0x93,0x98,0x48,0x4C,0xA6,0x51,0x41,0xB6,0xA4,0x47,0xF6,0xDF,0xB7,0x31,
+	0xC6,0xFE,0x60,0x46,0x3A,0xA0,0x39,0x96,0xCC,0x83,0x37,0x8E,0xC3,0xB4,0x65,0x36,0xE0,0x72,0x41,0x0C,
+	0xAD,0x43,0xE4,0x67,0x7E,0xED,0xCE,0x9F,0xAD,0xCE,0x57,0x47,0x38,0x81,0x11,0xBB,0xF4,0x79,0x68,0x13,
+	0x0C,0x8A,0x07,0x20,0xAA,0x16,0x7F,0x00,0x30,0x5F,0x26,0x71,0x55,0xE4,0x8E,0x2D,0xFB,0x49,0x58,0xA1,
+	0xBD,0x0F,0x7B,0xB0,0xB5,0x07,0xE6,0xBA,0x66,0x4F,0xBC,0x4D,0x7B,0x63,0xDF,0x1B,0x61,0xCC,0x4D,0x23,
+	0xB7,0x56,0x95,0x89,0x67,0x20,0x70,0x7F,0xE5,0x2D,0x83,0xBB,0xD4,0x94,0xEC,0xCA,0x7C,0xE6,0x1A,0x53,
+	0x49,0x00,0x33,0x49,0x03,0xA4,0xB6,0x44,0x42,0xD0,0xA9,0xCC,0xF8,0xC4,0xB3,0x0B,0x82,0x93,0x7E,0x5B,
+	0x00,0x6F,0x3B,0x00,0x0D,0x42,0x29,0x45,0xD7,0x59,0xAE,0xBD,0x59,0x59,0xEC,0x00,0x4F,0xBF,0x00,0x8D,
+	0x3C,0x16,0x85,0xCB,0x69,0x8A,0x45,0x22,0x22,0x11,0xA4,0x78,0xAD,0x3D,0xF1,0xA6,0x54,0x3D,0xAA,0x40,
+	0x7D,0xE2,0x12,0x8C,0x05,0xED,0x8B,0x42,0x0E,0x03,0x99,0x40,0xE0,0xBF,0x6F,0x3D,0xBD,0x58,0x07,0xEE,
+	0x32,0x7B,0xCB,0x43,0x80,0x5F,0x9B,0xAD,0xE1,0x28,0xC0,0x80,0x2F,0x31,0x38,0x19,0x8B,0x4A,0xCD,0x71,
+	0x6D,0xC6,0x4F,0xD6,0xD3,0x6C,0xC6,0x72,0xD4,0x79,0xBC,0x97,0xD1,0xF9,0xCC,0x38,0x5B,0x9D,0x1E,0x03,
+	0xA8,0xE2,0x37,0xA0,0xAB,0x42,0x6A,0xAF,0x47,0x50,0xF9,0x4D,0x14,0xE8,0xE3,0xE6,0x67,0x5B,0xBF,0xC6,
+	0xF5,0xAE,0x92,0xF8,0xCB,0xDC,0x2B,0x39,0x01,0x8C,0x96,0xB1,0x1B,0x90,0xBB,0x51,0xFD,0x62,0x42,0xE6,
+	0x12,0x8E,0x95,0x7A,0x46,0x56,0x34,0xE5,0xF1,0xE9,0x67,0x34,0x1E,0x3D,0x3E,0x7E,0x57,0x27,0x00,0xA4,
+	0x12,0x00,0x0D,0x89,0x4C,0x2E,0xE6,0xF8,0xFE,0x71,0xFF,0xBF,0xFF,0x00,0xA4,0x40,0x00,0x8D,0xB5,0x52,
+	0xB9,0xA9,0x38,0x5B,0x2D,0x35,0x9A,0x1A,0xCF,0x71,0x1B,0x08,0xC4,0x53,0xB2,0x34,0xDE,0x4B,0xDD,0x4C,
+	0x01,0x73,0xF9,0x98,0x7C,0x0E,0x10,0x91,0x8B,0x5F,0x3F,0x8F,0x0D,0xD8,0x2D,0xD2,0x4E,0xCF,0xD0,0xC6,
+	0xF3,0x01,0x6C,0x99,0xB3,0xB0,0x5A,0x8F,0x4D,0xEB,0x22,0x94,0x1A,0xDA,0xD6,0x92,0x1F,0x2F,0xFE,0x25,
+	0xEE,0x67,0x23,0xFB,0xFD,0xED,0xD0,0x3B,0x91,0xFB,0xCF,0x0C,0x08,0xCA,0x67,0xC3,0xD1,0x3E,0x97,0x89,
+	0xC7,0xD3,0x13,0x8C,0x8C,0x18,0x4D,0x40,0x87,0xB0,0x84,0xE1,0x70,0x82,0x58,0x2F,0x98,0x18,0x78,0x8F,
+	0xB3,0x9A,0x55,0xC8,0x8D,0x22,0x16,0x87,0x8B,0x0D,0x03,0xFF,0xC3,0x50,0x65,0x69,0xF6,0x6E,0x70,0xC0,
+	0x36,0x2A,0x44,0x4D,0x47,0x7F,0x4E,0xE7,0x32,0xAB,0x64,0x0D,0xA7,0x5E,0x1E,0x23,0x00,0x63,0xC4,0x00,
+	0x0D,0x33,0x11,0x7B,0x48,0x52,0x2B,0x3B,0x95,0x95,0x0A,0x00,0x8F,0x79,0x00,0x8D,0x4E,0x98,0xC4,0x97,
+	0xC7,0xE2,0x71,0x70,0x38,0xB8,0x15,0xDE,0x2F,0x86,0x42,0xA6,0x99,0xEB,0xF4,0xE4,0x67,0xAD,0x0A,0x89,
+	0x89,0x36,0xE3,0x7E,0x50,0x48,0x5A,0x9D,0xA1,0xB0,0x7A,0x45,0x40,0xB2,0xDC,0xC9,0xF5,0x8B,0xF9,0x1A,
+	0x25,0x07,0xE7,0x7A,0x34,0xDC,0x94,0x60,0x66,0x65,0x52,0x3C,0x53,0xF7,0x66,0x1E,0x97,0x95,0x32,0x3E,
+	0x28,0x07,0xD1,0xDE,0xC9,0x47,0x74,0xC2,0x32,0x79,0x31,0xD9,0x9D,0x2E,0xEA,0xF3,0x53,0xA2,0xB7,0xD6,
+	0x9E,0xDE,0x06,0x96,0x1A,0x9C,0x00,0x69,0xD0,0x20,0x6E,0x24,0x53,0x53,0x14,0x62,0x69,0x25,0xB3,0xCA,
+	0x22,0x24,0x26,0xFB,0xA1,0xBB,0xBF,0x42,0xF5,0x60,0x95,0xC3,0xDB,0xE6,0x3A,0xD6,0x13,0xDE,0x18,0x34,
+	0xDB,0xCA,0xF6,0x46,0x9F,0xF8,0xD0,0xA7,0x9F,0x09,0x57,0xF5,0xB8,0xA0,0x00,0x44,0x6D,0x00,0x0D,0xF3,
+	0xF1,0x9A,0xB8,0x16,0x52,0x19,0x04,0x84,0x82,0x00,0x00,0xC7,0x00,0x8D,0xF2,0xF1,0xD7,0x38,0x03,0x80,
+	0x80,0xC0,0xC0,0x60,0xC8,0x67,0xF7,0x6A,0x7B,0xFB,0xFA,0x01,0x7D,0xFF,0x3D,0x7F,0x9E,0x0F,0xCE,0x07,
+	0xEB,0xF0,0x41,0x48,0x04,0x1D,0x01,0x1B,0xFD,0x7C,0xEF,0x7E,0x7F,0x30,0x3E,0x30,0x8F,0x90,0xC7,0x0D,
+	0x5B,0x85,0xDD,0xE0,0x80,0xC6,0xA2,0x64,0xDB,0x90,0x0E,0x1C,0xD6,0x93,0x29,0x27,0xC3,0x7E,0x6E,0x30,
+	0x7D,0x31,0x0F,0xAF,0x97,0xC7,0x4D,0x07,0xE3,0xEC,0x44,0x4B,0xA5,0x69,0x4D,0xC6,0x12,0x7B,0x09,0xE4,
+	0xF9,0x03,0x05,0x83,0x7C,0xC1,0xCA,0xDE,0xBE,0xD4,0x27,0xBF,0x8A,0x06,0x5B,0xB2,0x25,0x17,0xD8,0x61,
+	0x1A,0xF2,0x7B,0x3F,0x4D,0x9D,0x12,0x96,0x4F,0x8E,0xDF,0x73,0x73,0x3F,0x04,0x7D,0xCF,0x3B,0x4B,0x1E,
+	0x0F,0xE2,0x36,0x4D,0x02,0xC7,0x04,0xD9,0xE2,0x64,0x24,0xD0,0x00,0x28,0xFE,0x00,0x0D,0x76,0x84,0x4A,
+	0x3D,0x15,0xB3,0x19,0x84,0x6C,0xF6,0x00,0xD5,0xB3,0x00,0x8D,0x8B,0xCD,0xA6,0x26,0x3E,0x1E,0x1E,0x0F,
+	0x07,0x83,0xF3,0xE0,0x30,0x01,0xB2,0x98,0x6F,0x2C,0x97,0xD4,0xAE,0xE5,0xD0,0x7A,0x3C,0xF6,0x82,0xAF,
+	0x4A,0x20,0x0F,0xE0,0x6D,0x8E,0x44,0xC2,0xA3,0x5C,0xD2,0xA8,0xB7,0x9C,0xD8,0x0C,0x1E,0xF6,0x9A,0xB2,
+	0x25,0xD3,0x0A,0x2B,0x06,0xE2,0xA2,0x80,0xA2,0x5F,0xD3,0xA7,0xB0,0x9C,0xDA,0x0C,0x28,0xF6,0x18,0xF2,
+	0x85,0x83,0x41,0x8E,0xA5,0xB0,0xF1,0xB4,0xBE,0x23,0x6D,0xAE,0xB4,0xF4,0x68,0xD6,0xE2,0x9B,0x7E,0xC2,
+	0x9D,0x8F,0x26,0xBD,0x55,0x29,0x26,0xD4,0x54,0x75,0x2A,0xD4,0x78,0xA5,0x3A,0xFE,0x45,0x11,0xA0,0x2C,
+	0x77,0xFA,0xE1,0xB3,0x46,0x1C,0x22,0x53,0x97,0xCC,0xA4,0x2D,0xD1,0xA9,0x6A,0x9B,0xBF,0x3B,0x64,0x2E,
+	0x2B,0x1A,0x6E,0xB0,0x8C,0x1F,0x59,0x16,0x03,0xC4,0x00,0x59,0x5E,0x00,0x0D,0xE3,0xF9,0x9B,0x3C,0x95,
+	0x93,0xD9,0xE4,0xB2,0xF1,0x00,0xE9,0x4C,0x00,0x8D,0x32,0x11,0x7A,0xC8,0xD5,0xEB,0xEA,0x75,0x75,0xBA,
+	0x35,0x7D,0xA1,0x92,0x14,0x49,0x24,0x40,0x25,0xAF,0x95,0x35,0xDA,0xA7,0x87,0xE6,0xD8,0x93,0x5A,0xAF,
+	0x18,0xB7,0xB7,0x4D,0x1B,0xE6,0xD3,0x72,0x48,0x3D,0xBE,0xCB,0x5E,0xD0,0xBD,0xF8,0xC8,0x1B,0xF4,0x1E,
+	0x0A,0x13,0x87,0xC4,0xDB,0xA6,0x7C,0x33,0x96,0x24,0x69,0x5D,0x1B,0x83,0x31,0x1E,0xBD,0x50,0xE2,0x77,
+	0xC4,0xE4,0x1E,0x89,0x2C,0xA1,0xCD,0x22,0xD7,0xEE,0x5A,0x32,0x6E,0x2E,0x69,0x81,0x97,0xD5,0x47,0x35,
+	0xB6,0xDA,0xA0,0xC6,0x22,0x97,0x01,0x27,0x1B,0x0A,0x14,0x0D,0x0A,0x00,0xCE,0x54,0x63,0x60,0xA3,0x76,
+	0xAA,0xFB,0xD8,0xFF,0xC7,0x32,0x55,0x33,0xB3,0xC5,0xC1,0x8A,0x5D,0xE6,0x85,0x37,0x08,0x31,0x10,0x51,
+	0x0C,0x02,0x0B,0x55,0x5C,0x8E,0x93,0x74,0x00,0x46,0xD9,0x00,0x0D,0x8A,0xCD,0xB9,0x29,0x1F,0x1B,0x9F,
+	0xA3,0x51,0x11,0x00,0x41,0x93,0x00,0x8D,0x42,0x95,0x42,0xD4,0x49,0x64,0xB2,0x59,0x5C,0x2C,0x16,0xFC,
+	0xFA,0x43,0x5E,0xCD,0x0E,0x18,0x07,0x92,0xD5,0xD4,0xCC,0x15,0xA2,0x37,0xDD,0x6A,0xA2,0x33,0xF4,0xED,
+	0xD7,0x3F,0x9D,0x8A,0x35,0xC6,0xA6,0xF7,0xD4,0x57,0x64,0x9E,0x09,0x0F,0x4A,0xFD,0xCB,0x9E,0x07,0xC5,
+	0xCC,0x91,0x8C,0x29,0x7E,0xB3,0x11,0x30,0x68,0x1F,0x3E,0x8C,0x44,0x9D,0x85,0x53,0x42,0x67,0x65,0x4F,
+	0x56,0x6B,0x24,0x25,0x29,0x45,0xCD,0x4A,0x4D,0x6D,0xED,0xDA,0x52,0x07,0xCA,0x4D,0x2A,0x55,0x91,0xA2,
+	0x69,0xB9,0xAD,0x94,0xC2,0x9C,0x30,0x6A,0x4A,0xDC,0x1E,0x39,0x12,0x18,0x46,0xF7,0xB6,0x01,0x28,0xEB,
+	0x85,0x9D,0x8E,0x10,0x62,0x6C,0x71,0xC1,0xD0,0xE7,0xA7,0xEC,0xA4,0xE7,0xFC,0x1C,0x04,0xFF,0x9A,0x23,
+	0xC5,0x70,0x1F,0x8C,0x0E,0x04,0x00,0xF9,0x6B,0x00,0x0D,0xAD,0xFE,0xF7,0x8E,0xCC,0x64,0x71,0xB1,0x98,
+	0xD8,0x00,0xE5,0x11,0x00,0x8D,0x26,0x1B,0xCD,0x93,0x8E,0x46,0x46,0xA3,0xA2,0xD1,0x5E,0x4A,0xA8,0x4A,
+	0x09,0x9F,0xC8,0xDA,0x7D,0x29,0x63,0x54,0x6D,0xC4,0x12,0xFC,0x09,0x9D,0x05,0x94,0xA9,0x91,0x18,0x17,
+	0x7A,0xF1,0xA5,0xF7,0x4E,0x00,0x27,0x92,0x47,0x2A,0xC5,0xDA,0x7B,0x75,0x35,0x15,0x9D,0x12,0x86,0x89,
+	0xD2,0x0C,0xE1,0x06,0x61,0x1B,0x42,0x03,0xBA,0x7A,0xD6,0xD9,0x96,0x48,0xDA,0xE6,0x00,0x27,0xBE,0x91,
+	0xA8,0x12,0xF0,0x26,0xD0,0xC9,0x6D,0xB9,0xCB,0x64,0xB5,0xCB,0x75,0xE6,0x14,0x11,0x11,0xAA,0x85,0x71,
+	0x9E,0x1F,0xCD,0xFF,0x6E,0x93,0xDB,0x19,0xA4,0x63,0x8F,0x14,0xA1,0xE7,0x8F,0xFD,0xB4,0x01,0xB7,0x98,
+	0x8A,0xD2,0x5F,0xB0,0x30,0x07,0xA0,0xD9,0x62,0xD7,0xE2,0xCB,0xD1,0x04,0xD7,0x55,0x4D,0x8C,0xB4,0xAE,
+	0x78,0xCE,0x05,0x38,0x00,0xF4,0x58,0x00,0x0D,0x61,0xB6,0xD3,0x9C,0x45,0xA0,0xB3,0x4F,0x27,0x67,0x00,
+	0xCA,0xA7,0x00,0x8D,0x79,0xB4,0xD2,0x9C,0xC2,0x60,0xB0,0x58,0x2C,0x16,0x91,0xE5,0xB3,0x35,0xC2,0xE8,
+	0x3B,0xFA,0xEE,0xCD,0xFE,0x0F,0xB2,0x3D,0x5C,0x10,0x89,0x6F,0xC7,0xC0,0x4D,0xF7,0xE4,0x63,0xB1,0x25,
+	0x0A,0x3E,0xE1,0x86,0xB7,0xA7,0x53,0x29,0xB8,0xD4,0xA8,0xAB,0xB0,0x28,0xC5,0x1A,0x8A,0xCF,0x64,0x28,
+	0x6B,0xD4,0x6A,0xAF,0xCB,0xF1,0x8C,0x66,0xE2,0xCB,0x9D,0x85,0x96,0x98,0x4B,0xCB,0xFB,0xAE,0x39,0x57,
+	0xB5,0x8B,0xC2,0x84,0xBC,0x0D,0x05,0x89,0xD2,0x58,0x61,0xF3,0xA5,0x26,0x5E,0xCF,0xAD,0xF7,0x07,0xFD,
+	0x5D,0xEF,0xBA,0x29,0x48,0x10,0xC5,0x55,0xE0,0x06,0x21,0x45,0x79,0x40,0xC1,0xA3,0xB7,0x10,0x55,0x89,
+	0x8E,0x47,0xAA,0xC6,0xF4,0xB8,0xB4,0xC8,0x9E,0x8B,0xD7,0x71,0xFA,0xBF,0x1E,0xBA,0xEF,0xB7,0xDA,0x57,
+	0x25,0xBF,0x00,0xDE,0xC6,0x00,0x0D,0xFF,0x28,0x1C,0xD4,0xE1,0xE4,0xE1,0x76,0xFB,0xBB,0x00,0x4C,0x7D,
+	0x00,0x8D,0x97,0x40,0x28,0xE0,0x7C,0x7F,0x3F,0x3F,0x1F,0x8F,0x25,0x22,0x03,0x8F,0x90,0x5E,0x80,0xA1,
+	0xAB,0x4E,0xA7,0x25,0x42,0xD6,0x3F,0xC1,0x2D,0x3F,0x42,0x7F,0xF3,0x2F,0x2C,0xC8,0xDA,0x3B,0x41,0xFE,
+	0xB2,0xA0,0xB2,0x57,0x9F,0x2C,0xBE,0xBB,0x75,0xB6,0x90,0x89,0xAF,0x42,0x74,0xFB,0x3D,0xCB,0x6C,0xEB,
+	0x09,0x41,0x69,0x79,0x64,0xA3,0xA1,0x1E,0xAC,0xD5,0xB9,0xE0,0x33,0x2A,0x04,0xC2,0xA8,0xB7,0x30,0xCA,
+	0x6D,0x50,0x56,0x08,0x8A,0xE5,0x83,0x04,0x0F,0x19,0x9A,0x8A,0x4E,0xB4,0x7E,0x9B,0xB9,0x5D,0xA6,0xB5,
+	0x79,0x44,0x72,0xB2,0xE3,0xEE,0xA5,0x80,0x3F,0xAD,0xC1,0x2A,0xB2,0x97,0x2A,0x3F,0x39,0xC2,0x7E,0x79,
+	0x64,0x73,0x12,0x42,0xE8,0x6C,0x66,0x97,0xAD,0x05,0x50,0x8F,0x47,0x9C,0x4D,0xBC,0xAD,0xD2,0x0A,0x32,
+	0x00,0x16,0x6E,0x00,0x0D,0xBA,0x68,0x3C,0xF4,0x71,0xBA,0xAE,0x5C,0x5D,0xEE,0x00,0x3E,0xBC,0x00,0x8D,
+	0xBC,0x56,0xA3,0x24,0x9E,0x9D,0x4E,0xA7,0x93,0x53,0xD3,0xFA,0x2E,0x41,0x61,0x3F,0x30,0x27,0xE1,0xE3,
+	0xF8,0x73,0x6D,0xA1,0x46,0x5E,0xBA,0xF2,0x55,0x18,0xAB,0x2A,0x44,0xD7,0xC9,0xC3,0x61,0x75,0xCA,0x49,
+	0xF4,0x71,0xB0,0xC8,0xDC,0x8C,0x58,0xF6,0xFB,0x27,0x89,0xD1,0xD3,0x87,0x9B,0xE6,0x9E,0x65,0x42,0xEC,
+	0x61,0xE5,0xAC,0x53,0x21,0xA8,0xC1,0x1F,0x1F,0x9F,0x9E,0xD7,0x88,0x22,0xEA,0x18,0x8D,0xD6,0xD7,0xF1,
+	0xEF,0xA9,0x42,0x41,0xBD,0x1D,0xA5,0x0C,0x30,0xF4,0x7B,0x2A,0x76,0xAF,0xCA,0x78,0xC4,0x46,0x73,0x24,
+	0x3F,0xBA,0xA6,0x74,0x22,0x40,0xB6,0x51,0xC4,0x59,0x07,0x39,0x4C,0xB8,0x6B,0x70,0x30,0x29,0xB8,0x07,
+	0x99,0x16,0x1B,0x30,0xEF,0xA2,0x34,0xE6,0x4F,0xF4,0x0B,0x9B,0x60,0xCF,0x8E,0x67,0xA2,0xD1,0x00,0x6F,
+	0x88,0x00,0x0D,0x13,0x15,0x82,0xC1,0x6B,0x92,0x23,0xC9,0xA4,0xE4,0x00,0x52,0xE8,0x00,0x8D,0x38,0xEF,
+	0xFF,0x74,0xB6,0xB5,0x5A,0x5A,0x2D,0xAC,0x54,0x9F,0x23,0x3C,0x56,0x45,0x35,0xD9,0x2C,0x34,0x08,0xD8,
+	0x51,0x57,0x76,0xA9,0x1A,0x17,0xF6,0xDE,0x37,0xB2,0xF6,0xDE,0x21,0x97,0xE1,0xAD,0x3D,0xB3,0x3E,0xAE,
+	0xCF,0xB1,0x2A,0x54,0x91,0xDB,0xFE,0x25,0x80,0x7D,0x12,0x1D,0x0A,0x9B,0x5D,0xD3,0x2F,0xF2,0x52,0x97,
+	0x3B,0x9D,0x9F,0xC7,0x47,0x30,0xC0,0x42,0x68,0xF5,0x50,0xEC,0x75,0x29,0xDA,0xC0,0xF1,0xEE,0x2F,0xDD,
+	0x9F,0x01,0x3E,0xE6,0x1E,0x2E,0x47,0xF3,0xFE,0x6F,0xC6,0x76,0x3B,0x80,0x2B,0xEA,0xD7,0x0E,0x9F,0x57,
+	0xDD,0xB0,0x97,0x07,0x41,0xC6,0x7D,0x4B,0x0E,0x78,0xCD,0xC7,0x42,0x93,0xA7,0x6F,0xA6,0xF8,0x72,0x7C,
+	0xBA,0x00,0x92,0xF0,0x59,0x07,0x6D,0x45,0xBA,0x4B,0xFB,0x39,0x66,0xAE,0x3A,0x08,0x00,0x15,0xD4,0x00,
+	0x0D,0xF5,0x72,0xF1,0x8D,0x4D,0x49,0xB1,0xCD,0xE6,0xA8,0x00,0x01,0x2B,0x00,0x8D,0x9E,0xC4,0x6A,0x40,
+	0x9D,0x4F,0xA7,0x4F,0x53,0xA9,0x39,0x54,0x1C,0x9F,0x02,0xC0,0x13,0xBF,0x81,0xD5,0xC5,0xAA,0x59,0xF9,
+	0xF1,0xA5,0x9A,0x08,0x41,0xED,0x35,0x2E,0xE7,0x4F,0xB7,0x7F,0xAA,0x62,0x31,0xE9,0x07,0x7B,0x5E,0x67,
+	0xE0,0xAE,0xB5,0x0D,0x0F,0x89,0xD3,0x06,0xB9,0x74,0x30,0x2E,0x7D,0x85,0x92,0x3D,0xA1,0x13,0x00,0x17,
+	0x80,0xF3,0xB3,0x15,0xE5,0xDD,0x66,0x26,0x7A,0xD4,0x30,0x37,0xD1,0x52,0x58,0xE3,0xC0,0xFE,0xC3,0x67,
+	0xC2,0x3D,0xFF,0x49,0xF5,0x41,0x17,0x04,0xD2,0x22,0xBF,0x10,0xD5,0xD7,0xE0,0x19,0x78,0x93,0xAF,0x2B,
+	0x24,0xE8,0x03,0xDB,0xC4,0x52,0x5E,0x63,0x1D,0x59,0x68,0x23,0x43,0x94,0x85,0x2D,0xD1,0x82,0x66,0x3E,
+	0x0D,0x47,0xF3,0x84,0xF5,0xCB,0x54,0x91,0xF2,0x05,0xC4,0xC7,0x32,0x87,0x00,0xC4,0x5C,0x00,0x0D,0x0E,
+	0x28,0x1C,0xC9,0xEF,0x6E,0x60,0xBA,0xBC,0xDD,0x00,0xA6,0x0C,0x00,0x8D,0xB4,0xD2,0x69,0x41,0x5C,0xAF,
+	0xAF,0xD7,0x2C,0xEB,0x75,0xCA,0x74,0xA4,0x76,0x1D,0x7C,0x9B,0xA0,0xBB,0x92,0x7B,0x88,0xB9,0x80,0x73,
+	0x9E,0x74,0xF7,0xAF,0x9E,0xAF,0xCE,0xAC,0xA0,0x23,0x0F,0x56,0x36,0xE4,0xB3,0xFE,0x2F,0x9B,0xEA,0x68,
+	0xE5,0x75,0x6C,0xEF,0xBA,0x1E,0xD3,0xAC,0xE5,0x88,0x8D,0x8F,0x22,0xD9,0x19,0x08,0xF1,0x20,0xE9,0xFF,
+	0x70,0x2F,0x55,0xBA,0x01,0x84,0x02,0x1F,0xDC,0xD6,0x0A,0xC0,0x11,0xC5,0x1D,0xB9,0x22,0x81,0x88,0xA4,
+	0x4E,0x99,0x11,0xF9,0x08,0x9B,0x68,0x71,0x03,0x58,0xDC,0xDA,0x4C,0x80,0x48,0x03,0xCB,0x2B,0xE5,0x76,
+	0x1E,0x72,0xB9,0x4F,0xB4,0xED,0x7E,0xAE,0x1D,0x8C,0x70,0x01,0x00,0x73,0xF0,0xB0,0x41,0x10,0x66,0x37,
+	0xFC,0xEA,0x5D,0xF8,0x83,0x55,0x57,0xA6,0xB3,0x22,0xA7,0xDF,0x00,0x10,0xF0,0x00,0x0D,0x86,0x51,0x20,
+	0xE8,0x7F,0x3D,0x2B,0x1E,0x1E,0xCF,0x00,0x62,0xEE,0x00,0x8D,0xE5,0x7A,0xB5,0xFD,0xF2,0x58,0x2C,0x3C,
+	0x1E,0x8F,0x02,0xF7,0xCB,0x31,0x80,0x05,0x68,0xF5,0x64,0x06,0x61,0xF1,0x7B,0x29,0xB3,0x9B,0x6C,0x3C,
+	0x28,0x2D,0xDF,0x65,0x61,0xBA,0xF5,0xE9,0xFD,0x95,0x26,0x43,0x3B,0xD0,0x60,0x26,0x9C,0x60,0x4F,0x93,
+	0x88,0x2C,0x44,0xE3,0x7D,0x75,0x75,0x7B,0x68,0x01,0x3E,0xDD,0x8E,0xD2,0x5F,0x25,0x1C,0xF8,0xC0,0x73,
+	0x25,0x81,0x0F,0xA3,0x07,0x5C,0x03,0xDF,0xFF,0x20,0xCC,0x63,0xE8,0x40,0x21,0xCC,0x90,0x89,0xCE,0xD3,
+	0xB4,0x9B,0x2E,0x1F,0xC6,0x4C,0xE1,0x61,0x78,0xFE,0x0F,0xF1,0xC8,0xF0,0xA1,0x5C,0xB8,0xC2,0xE3,0x35,
+	0x80,0x0A,0x95,0x1D,0xD8,0x72,0x7C,0xA1,0xAF,0x40,0x9F,0x33,0xD6,0x4E,0xFA,0x13,0x3C,0x0F,0x7B,0x2A,
+	0xD5,0x7B,0xCE,0x17,0x0E,0x7A,0x9E,0x3A,0x56,0xBA,0x00,0xF5,0x97,0x00,0x0D,0x7C,0xAA,0xDD,0x15,0x81,
+	0x42,0x54,0x21,0xD0,0x27,0x00,0x00,0x72,0x00,0x8D,0x02,0x8E,0xE5,0x87,0xCF,0xCD,0xE6,0x73,0xB9,0xDC,
+	0x4E,0x81,0xBD,0xFC,0x87,0x1A,0x35,0x95,0x43,0xBB,0x1E,0xDA,0xEA,0x29,0xC4,0x6E,0x64,0x19,0x34,0xBE,
+	0xD4,0x72,0x5E,0x83,0xA3,0x54,0xD1,0x90,0xAA,0xCD,0xFE,0x5B,0xCF,0x26,0x4A,0x29,0xEF,0x79,0x63,0x86,
+	0x67,0xAB,0x51,0xEF,0x95,0xA5,0x91,0x30,0x11,0xCA,0x04,0xDF,0x8D,0xB4,0x35,0x56,0xAA,0xC7,0x58,0xE2,
+	0x1C,0x9F,0x11,0x85,0x93,0x01,0x99,0xE1,0x52,0xC4,0x6A,0x42,0xBD,0x43,0x5E,0x81,0x95,0x68,0x21,0x95,
+	0x11,0x12,0x0A,0x68,0xF0,0x58,0x33,0x8F,0x7F,0x74,0xDB,0x46,0x11,0x4E,0xD7,0xA2,0x5A,0x71,0x2A,0x8E,
+	0x24,0xD9,0x1D,0xAD,0xB3,0x16,0x7C,0xC9,0x87,0xD1,0xE1,0xA6,0xB4,0x2A,0xFA,0xE2,0x62,0x20,0xF4,0xCD,
+	0x8B,0xEA,0xF5,0x82,0x72,0xA1,0x48,0x25,0x00,0x19,0x70,0x00,0x0D,0x7D,0xB6,0xDD,0x1B,0x06,0x41,0x96,
+	0x20,0x40,0x4F,0x00,0xBE,0x7B,0x00,0x8D,0xCA,0x3A,0x15,0x23,0x1D,0x1E,0x0F,0xFE,0x7F,0x3A,0xBC,0x9D,
+	0x1F,0xB5,0xE1,0x5C,0xA1,0x94,0xF7,0x5D,0x56,0x95,0xD1,0x90,0x14,0x82,0x7B,0x47,0x26,0x52,0x2B,0x52,
+	0xD7,0xD9,0xF2,0x69,0x9C,0x1B,0x6C,0xEC,0x44,0x09,0x51,0x1C,0xE7,0x9E,0xA1,0x90,0x70,0x40,0xFF,0x38,
+	0x88,0x84,0x3F,0xB4,0xD2,0xCE,0x6D,0x61,0x6A,0x4C,0x05,0xE6,0x0F,0x02,0x05,0x1B,0x95,0xFB,0x43,0x60,
+	0xAA,0x51,0x99,0x56,0x5D,0xAC,0xB1,0x42,0x9A,0x2D,0xB5,0x3E,0xFC,0xE4,0xD4,0xE8,0xCE,0x76,0x90,0x89,
+	0xBF,0xD3,0xF0,0xF3,0xDA,0x7E,0xB8,0x2E,0xCF,0x6A,0x36,0x46,0x47,0x94,0xC6,0x46,0x5B,0x55,0xE8,0x14,
+	0xFC,0x6F,0x02,0x95,0x36,0x0A,0xAC,0x70,0xC0,0xB4,0xC9,0xD9,0xEC,0x12,0xEE,0xE6,0x73,0x55,0xB1,0x49,
+	0x71,0xEF,0x49,0x99,0xC3,0x5B,0x00,0xAE,0x2B,0x00,0x0D,0xD9,0x64,0x41,0x55,0x4F,0xA5,0xB2,0x52,0x7D,
+	0xA9,0x00,0xAC,0x55,0x00,0x8D,0x54,0xA2,0xD9,0x0E,0x0B,0x04,0x82,0x3F,0x40,0xA0,0xCD,0x9E,0xEC,0x19,
+	0x52,0xC2,0x20,0x2E,0xE9,0x89,0xC2,0xE6,0x61,0xB1,0x21,0x99,0x1D,0x8F,0x1A,0x85,0x07,0x83,0x7C,0x00,
+	0xB0,0xD8,0xB9,0xD3,0x55,0xCA,0x28,0x12,0x93,0x4B,0x2C,0xB0,0x58,0x9B,0x3E,0x51,0x68,0x73,0x7A,0xE3,
+	0xB2,0xA4,0xDB,0x63,0x7F,0xD2,0x2A,0x68,0xA5,0xDF,0x2C,0x37,0xA4,0x66,0x48,0x20,0xA4,0xB2,0xD1,0x6E,
+	0x70,0x17,0x09,0x4F,0xEF,0xA7,0x62,0xB2,0x33,0xBA,0x00,0xF8,0x08,0xAB,0xE1,0xB1,0x7E,0x70,0xD6,0x76,
+	0x9F,0xAC,0xA6,0xDA,0x02,0x2C,0xAF,0x1D,0x69,0x8F,0xF7,0xC6,0x64,0xA3,0x47,0x30,0x7A,0x81,0x1F,0x17,
+	0x98,0xDB,0xB9,0xB6,0x43,0xBE,0xB0,0x4B,0x65,0xCB,0xEC,0xE3,0x02,0x5D,0x1B,0x9B,0x9F,0x41,0x5E,0x47,
+	0xD2,0xE9,0x74,0x14,0x00,0x23,0x45,0x00,0x0D,0x51,0xB0,0xCB,0x10,0x0A,0x87,0x5B,0xA0,0x21,0x50,0x00,
+	0x93,0x8A,0x00,0x8D,0x7A,0x35,0x0E,0x5D,0x6F,0x21,0xB5,0x90,0xDA,0x48,0x90,0xE2,0xB0,0x49,0x7C,0x08,
+	0xF6,0xC8,0x73,0x39,0x4D,0x42,0xC0,0xF8,0x0D,0xCB,0x13,0x3D,0x5E,0xF9,0x86,0x37,0x3F,0x72,0x79,0x2E,
+	0x8B,0x22,0x25,0x48,0xFD,0x6D,0x77,0x79,0x42,0xBA,0xDC,0x69,0x6E,0xF6,0x2A,0xBA,0x18,0x7D,0x98,0x7D,
+	0xFD,0xDA,0x3E,0x85,0x11,0x81,0x91,0x3C,0xC2,0x3D,0xE2,0x68,0x2D,0xF6,0xF3,0x68,0x87,0xEC,0x15,0xAD,
+	0x75,0x8D,0xA5,0x1C,0x25,0x54,0xF9,0xF0,0x3B,0xCB,0xEC,0x82,0x0F,0xD4,0x13,0xF4,0xE4,0xFF,0x7B,0x26,
+	0x0F,0xEE,0x1D,0x8A,0x83,0xE7,0xC0,0x44,0xE1,0x01,0x72,0xF7,0x9E,0x77,0x5F,0xAC,0x96,0x08,0x0C,0xD4,
+	0xF6,0xF9,0x7D,0xEB,0x85,0x84,0x13,0x40,0x54,0xD5,0x2D,0xA2,0x57,0x97,0xEA,0x08,0xE3,0x87,0xB2,0x64,
+	0xC4,0x41,0x00,0xA5,0x6B,0x00,0x0D,0x03,0x5D,0xE2,0xF1,0x73,0xCC,0xA3,0x5D,0xF3,0x39,0x00,0x78,0x7B,
+	0x00,0x8D,0x13,0x81,0xEA,0x80,0x9C,0x4F,0x67,0xA7,0x53,0xD3,0x7F,0x95,0xA8,0x0B,0xF6,0xCB,0xA8,0x57,
+	0xCE,0x72,0x60,0xA3,0x0C,0xC3,0x7B,0x1B,0xF7,0x80,0xFB,0xE3,0x9D,0x88,0x31,0x99,0x57,0x05,0x1D,0x71,
+	0x31,0xBE,0x3B,0xFC,0x66,0x93,0xA1,0x2F,0xC1,0x92,0xE4,0x90,0xF3,0xFF,0xA1,0x3A,0x19,0xA3,0xC1,0x98,
+	0xDB,0x38,0xCD,0xC5,0x03,0x3B,0x6C,0x7B,0xA3,0x65,0x9D,0x6A,0x85,0x6E,0xF6,0x6A,0xB5,0x6D,0x45,0xEC,
+	0x35,0xDC,0x0D,0xB4,0xC1,0xB6,0x65,0xBC,0xEE,0x1A,0xE2,0x0C,0x1C,0x03,0x41,0x58,0xE2,0x51,0x53,0xAD,
+	0x33,0x16,0x91,0xAA,0xE7,0x62,0xE6,0x75,0x7D,0x91,0xB8,0x8F,0x86,0x6E,0xD3,0x56,0x6B,0x48,0x9C,0x41,
+	0xD9,0x5F,0x65,0xD6,0xB5,0x5D,0xDB,0x8D,0x72,0x76,0x3F,0x02,0x19,0x16,0x76,0xFA,0xEB,0xBC,0xE7,0x0E,
+	0x00,0x8C,0xC0,0x00,0x0D,0xE5,0xFA,0x91,0xBD,0x55,0x28,0x8D,0x47,0x23,0xA5,0x00,0xC9,0xB5,0x00,0x8D,
+	0xFB,0xF5,0x6F,0x3A,0x11,0x11,0x88,0x88,0x44,0x1A,0x2A,0xA7,0xE3,0x0D,0x01,0x64,0x24,0x9B,0x1A,0x1D,
+	0x90,0xCF,0x2A,0xB7,0x8F,0x39,0x45,0xB3,0xDB,0xCC,0xE9,0x0B,0xA5,0x87,0x73,0x24,0x02,0x47,0x3B,0x93,
+	0x67,0xBA,0x58,0xE6,0x70,0xF1,0xBE,0x3D,0x5E,0x29,0xAB,0x56,0x28,0xED,0xD5,0x44,0x67,0xA4,0x13,0x12,
+	0xCE,0x7A,0x4F,0x06,0x4E,0x8F,0x1A,0xB5,0x65,0x80,0x50,0x88,0xBD,0xCC,0xC7,0x63,0x63,0x4B,0xAB,0x47,
+	0x26,0xDE,0x84,0x29,0x5A,0x36,0xB8,0x2A,0x31,0x05,0x1F,0x15,0xD5,0xFB,0x8A,0x3C,0x3C,0xF1,0xFD,0xF6,
+	0x76,0xB4,0xD1,0x72,0xDD,0x01,0x16,0x91,0x0E,0xDD,0xA7,0xDE,0x46,0x8E,0x21,0xA4,0xC2,0x36,0xE2,0x64,
+	0xF0,0x91,0x7B,0x3C,0xDE,0x5C,0xAE,0xEF,0x23,0x26,0xEB,0x4A,0x7C,0xA1,0x60,0xB4,0xEA,0x4C,0x00,0x1E,
+	0xC4,0x00,0x0D,0x0C,0x8E,0xE5,0x87,0x9D,0xCC,0xD5,0xE6,0x66,0x73,0x00,0x78,0x61,0x00,0x8D,0x58,0xA4,
+	0xCF,0x92,0x46,0x22,0x91,0x91,0x48,0xC8,0x94,0x54,0xD4,0xE9,0x22,0xB5,0xCE,0x53,0x3B,0x43,0x64,0xB6,
+	0x5B,0x9D,0xFF,0x47,0xCB,0x73,0x9F,0xF0,0x73,0x26,0x47,0xF1,0xFA,0xEF,0x00,0x1D,0x49,0x4C,0x30,0x92,
+	0xA3,0xDA,0x7F,0xED,0x45,0x71,0xED,0xD7,0x7D,0xDE,0x1D,0x08,0x26,0x56,0xD8,0xA1,0x3A,0x0C,0x31,0x5F,
+	0x4C,0x76,0xF8,0x2A,0x4D,0xF3,0xB7,0xB6,0x00,0x7D,0xBC,0xD3,0x5E,0xB0,0xB5,0x27,0xDF,0x44,0x3E,0xE4,
+	0x33,0xAA,0x89,0x34,0xC6,0x79,0xCA,0x85,0x90,0xBD,0xCB,0x04,0x67,0x35,0x84,0x39,0xE2,0x21,0x7C,0xF1,
+	0x7D,0x03,0xC3,0xC2,0xF7,0x7A,0x5F,0x3F,0xE7,0x5E,0xE7,0x64,0xE6,0xEA,0x6C,0x29,0x5B,0x00,0x0B,0x18,
+	0x03,0x9B,0x5B,0xBC,0xCC,0x9F,0xFC,0x20,0x2C,0x82,0x34,0x06,0x81,0xD6,0xD2,0x67,0x00,0xF9,0x51,0x00,
+	0x0D,0x0A,0x0D,0x79,0xC9,0xE6,0xF1,0x69,0x39,0x39,0x5C,0x00,0x48,0xCC,0x00,0x8D,0x77,0xB3,0xD8,0x19,
+	0x05,0x03,0x03,0x01,0x00,0x80,0x68,0x8F,0xF2,0x3E,0x74,0xC1,0xEB,0xE0,0x73,0x68,0x43,0xC5,0xD0,0x91,
+	0xF1,0x27,0x86,0x05,0xC2,0x4E,0x5D,0x51,0x29,0x2F,0xD1,0x34,0x68,0xED,0x91,0xF5,0xB7,0x8C,0x62,0x29,
+	0xD7,0x51,0xD5,0x0D,0xB2,0x36,0xBF,0xD2,0xD4,0x65,0xAD,0x34,0x1B,0x52,0x0D,0xEB,0x97,0x35,0xC6,0xD9,
+	0x3B,0x95,0x89,0x0A,0x56,0x23,0x56,0x7A,0x38,0x13,0x99,0x2F,0xE5,0xCE,0xA9,0x38,0x14,0x1D,0x7E,0x57,
+	0xC8,0xF0,0xBB,0xCB,0xAC,0xB9,0xA3,0xCB,0x1C,0x73,0xBE,0xD2,0xAA,0x4E,0x00,0xDB,0x96,0xCF,0x21,0x41,
+	0x11,0x95,0xED,0xA6,0x70,0xC4,0x12,0x61,0xF8,0x71,0x64,0x58,0xC2,0x3A,0x61,0x22,0x6D,0xCD,0xBF,0x28,
+	0x25,0xD3,0xED,0x41,0x33,0x2F,0x14,0xFA,0x0D,0x39,0x77,0x5A,0x0D,0x2C,0x00,0x17,0x66,0x00,0x0D,0x1D,
+	0x3C,0x96,0xBE,0x4A,0x27,0x3D,0x93,0x89,0x04,0x00,0x5F,0x63,0x00,0x8D,0x48,0x9F,0x47,0x56,0x4B,0x23,
+	0x24,0x11,0x08,0x44,0xE2,0x60,0x72,0x57,0xD7,0x61,0xE1,0x7F,0x7D,0x11,0x55,0x67,0x5E,0xB4,0x8E,0x03,
+	0xD8,0x5E,0x99,0x65,0x37,0x1B,0xDA,0x4F,0x64,0xB3,0x21,0x98,0x0B,0x85,0x12,0x06,0x4A,0xC0,0x37,0x4F,
+	0x43,0x22,0xD1,0xCB,0xC1,0x00,0xF7,0xFF,0x78,0x5D,0x3F,0x99,0x0E,0xEF,0x27,0x43,0xA6,0xE1,0x10,0xB5,
+	0x5D,0x0A,0xDD,0xC4,0x64,0x22,0xE2,0x50,0x65,0x25,0xA0,0x4F,0xCC,0x79,0x60,0x04,0x09,0x19,0xB7,0xC1,
+	0x54,0x11,0x48,0x49,0x3E,0xCC,0xD3,0xF6,0xCA,0xBF,0x1F,0x7A,0xA5,0xB1,0xB3,0x33,0xE0,0xB7,0x48,0x06,
+	0x14,0x17,0x03,0x9B,0x7C,0xBF,0xEE,0x0E,0x67,0xEC,0x61,0xE0,0x31,0x57,0x51,0x4A,0xD7,0x2C,0xD0,0x0A,
+	0x66,0xF2,0x02,0xD9,0xB6,0x15,0x2F,0x51,0x89,0xF2,0x81,0x2F,0x00,0xB0,0xDD,0x00,0x0D,0x6A,0x3D,0x56,
+	0x5E,0x44,0x20,0xF1,0x90,0xF5,0x3A,0x00,0xAB,0x3D,0x00,0x8D,0x10,0x00,0x5C,0xC0,0x47,0xEF,0xA2,0xD1,
+	0xD0,0xE8,0x87,0xAE,0x2E,0x17,0x7A,0x30,0xCA,0xC0,0xD7,0x02,0xFD,0xFE,0x7D,0xDD,0xDA,0x59,0xE7,0xC0,
+	0xD1,0xEB,0x34,0xDD,0x8A,0xC6,0x46,0x80,0x38,0xFC,0x0B,0x01,0x81,0x21,0x5B,0xAB,0x71,0xD8,0x18,0x5C,
+	0xFB,0x4F,0xBE,0x62,0xA3,0x72,0xA5,0xF8,0x9E,0x3D,0x6E,0xDF,0xA2,0xC6,0x4B,0xBA,0x3A,0x82,0xCB,0x57,
+	0x6E,0xAB,0xB1,0xC2,0x31,0x89,0x75,0x43,0x23,0x4F,0x43,0x35,0xEB,0xE9,0x34,0x22,0x09,0x1D,0x65,0xFD,
+	0x0B,0x42,0x86,0xFC,0xF4,0xFF,0x73,0x68,0x43,0xC2,0xD0,0x91,0xF0,0x27,0x1A,0x0D,0x10,0x4A,0x3A,0x62,
+	0x50,0x36,0x5D,0x94,0xB8,0xC7,0xD5,0xB1,0x87,0x1E,0x7E,0xF2,0xB9,0x27,0x74,0x78,0x98,0xF1,0x8E,0x6E,
+	0xF0,0x56,0x1F,0xD6,0x64,0xB9,0x42,0x93,0xB7,0x25,0x00,0x2E,0x66,0x00,0x0D,0xF8,0xF4,0xF2,0xCF,0x6C,
+	0x09,0xAF,0xDA,0x82,0x81,0x00,0x71,0x53,0x00,0x8D,0xAA,0xDD,0xE6,0x6C,0x3A,0x0C,0x06,0x03,0x03,0x81,
+	0x01,0xF8,0x00,0x01,0x8E,0xC1,0x25,0x9C,0x99,0x0C,0x45,0xD8,0xB0,0xAD,0xD6,0x15,0x5B,0xFB,0x22,0x5E,
+	0x5D,0x02,0x98,0xCD,0x29,0x70,0x48,0xB0,0xD3,0x2F,0x36,0xCD,0xAF,0xB8,0x4E,0xCA,0x29,0x69,0x23,0x9C,
+	0x8D,0xDD,0x17,0x92,0x60,0x34,0xB1,0x30,0xAF,0xD2,0xB1,0x45,0xDE,0x35,0x15,0xEB,0xC4,0x8B,0x7A,0xAB,
+	0x42,0x7D,0x23,0x01,0x13,0xBE,0x80,0x10,0xA8,0x4F,0x7A,0x8F,0x2A,0x02,0x8F,0xD8,0xB5,0x45,0x94,0x68,
+	0xB1,0x37,0x4C,0xAE,0x94,0x17,0xD9,0x4A,0x62,0xE6,0xA2,0x5E,0xD3,0x0C,0x5E,0xFB,0x99,0xCF,0x4E,0x84,
+	0x8F,0xA7,0xAA,0xD1,0x56,0x4A,0x29,0x12,0xCA,0x04,0x52,0xF8,0x5E,0x9D,0x6C,0x8B,0x0B,0x87,0xD5,0x12,
+	0x6B,0xCC,0x97,0x53,0x9E,0x79,0x68,0x75,0x00,0xBD,0x79,0x00,0x0D,0xD0,0x60,0x84,0x70,0x2C,0x14,0x9E,
+	0xC1,0x60,0x70,0x00,0xCF,0x44,0x00,0x8D,0x5A,0x25,0xEE,0x82,0x4D,0x52,0x29,0x29,0x14,0xE9,0x9B,0x23,
+	0x23,0xF0,0xC8,0xF9,0xFC,0x64,0xA5,0x43,0xD1,0xE0,0x52,0xA8,0x61,0xEE,0x06,0xB0,0x18,0xB7,0x43,0xAF,
+	0xAB,0x23,0xE4,0xB0,0xB8,0x31,0x10,0x15,0xCF,0x9D,0x1D,0x8F,0xFF,0x86,0x8F,0x2C,0xB5,0xDA,0x08,0x22,
+	0x39,0x17,0x60,0x0C,0x74,0x58,0x33,0x1F,0xED,0xF4,0x96,0x1C,0xB9,0x61,0x8D,0x27,0x8E,0x1F,0xBB,0xD6,
+	0x35,0xA8,0x95,0x9B,0xB3,0x25,0x24,0x95,0x09,0x05,0x50,0xC3,0x25,0x13,0x86,0x4B,0x61,0x62,0xA2,0x59,
+	0xDF,0xEF,0x7C,0xB1,0x3E,0x7B,0x98,0xCA,0xCE,0x27,0x82,0x50,0x91,0x21,0x43,0xF6,0x5E,0x14,0x49,0x1D,
+	0x93,0xAE,0xE3,0x1E,0xD1,0x46,0xE2,0xEC,0x88,0x70,0x39,0x1B,0xCE,0x67,0x62,0xF2,0xBC,0xDF,0x4A,0xAD,
+	0x2C,0x97,0x98,0xC4,0x25,0x12,0x00,0x36,0x52,0x00,0x0D,0xFB,0xF5,0x9E,0x3A,0x20,0x12,0x95,0x44,0xE1,
+	0xA2,0x00,0x5C,0xF0,0x00,0x8D,0x1A,0x05,0x8D,0x33,0xAE,0xD6,0x4B,0x25,0x12,0x09,0x54,0xA7,0x19,0x30,
+	0x05,0x04,0x2E,0xC3,0xF2,0xF5,0x4A,0x7F,0x04,0xC4,0x81,0xBC,0x1D,0x0B,0x4C,0x49,0x6A,0xD8,0x20,0x6D,
+	0x68,0xB7,0x1B,0x39,0x24,0xF2,0x12,0x06,0xC3,0x3E,0xAC,0x37,0xD8,0x37,0xCB,0x4C,0x92,0xC4,0x52,0x14,
+	0xFB,0x5E,0x39,0x36,0x79,0x9C,0x1D,0x16,0x4A,0xB2,0x39,0x80,0x19,0x93,0x19,0x5F,0x25,0x2F,0x14,0x3B,
+	0x4D,0xEC,0xC7,0xB7,0xF9,0x34,0x2F,0x88,0x35,0x83,0x81,0x00,0xD2,0x0C,0xED,0x68,0xC1,0x4A,0x21,0x0D,
+	0xF6,0x87,0xC0,0xA9,0x1A,0x8C,0xF7,0x02,0x62,0xEE,0xE2,0x61,0xEF,0x7F,0xC5,0x36,0x1A,0xCA,0x23,0xF3,
+	0x11,0x0E,0xFA,0x6D,0xB5,0xBF,0x5C,0x48,0x14,0x60,0xD8,0x71,0xF0,0x57,0x2C,0x95,0x9A,0x77,0x54,0x0B,
+	0x73,0x9F,0x09,0x58,0x00,0xBF,0xE8,0x00,0x0D,0xF2,0xF6,0x73,0xCC,0xD6,0x69,0x74,0xB4,0xB4,0x1A,0x00,
+	0x21,0x36,0x00,0x8D,0x33,0x91,0xFA,0x88,0x49,0x4B,0x25,0x25,0x92,0x12,0xDB,0x34,0x7C,0xBD,0x40,0xB8,
+	0x5C,0xDD,0x3C,0x97,0x0E,0x06,0x93,0x41,0xC0,0xE0,0x23,0x96,0x1F,0x08,0x9B,0x42,0x68,0x82,0x33,0x1F,
+	0x44,0xB3,0xDC,0x13,0xD4,0x0A,0x7B,0xB6,0xA4,0x91,0x7F,0xAC,0xA7,0xE3,0xC4,0x60,0x62,0x70,0xBA,0x19,
+	0xF8,0xCE,0xA6,0x37,0x6E,0x39,0x90,0x84,0x46,0x4A,0xAD,0x37,0x57,0xFF,0xAE,0x17,0xD9,0x8C,0x69,0xB5,
+	0x9B,0x7A,0xCB,0xE5,0x34,0x0C,0x91,0x59,0x5C,0xE0,0xD9,0x2A,0x5B,0xCF,0xEB,0xA3,0x4F,0x4A,0x21,0x8A,
+	0x5A,0xF2,0x14,0x10,0x51,0xBB,0x38,0x2C,0x2C,0xEE,0xA7,0xDD,0xDF,0x51,0x3A,0xDE,0x30,0x0B,0x50,0xEA,
+	0x7F,0xC8,0x10,0x9B,0x89,0x22,0x7F,0xAF,0x24,0x96,0x2B,0x0A,0x39,0x1D,0xA3,0x02,0xF3,0x43,0xE6,0x61,
+	0x6F,0x53,0x00,0xC6,0x63,0x00,0x0D,0xDD,0x66,0xBB,0xA8,0xB2,0x5B,0x70,0x36,0xBB,0x9B,0x00,0xA5,0x24,
+	0x00,0x8D,0xB7,0xD0,0x38,0x28,0xF4,0xFB,0x6B,0x35,0x35,0x9A,0x39,0x7D,0xD7,0x47,0x7D,0x10,0x23,0x1B,
+	0x59,0xE5,0x83,0x07,0x48,0xDC,0x34,0x64,0xD4,0x71,0xC6,0x5C,0xCE,0x54,0x30,0x16,0x36,0x08,0xAC,0x6B,
+	0x6C,0xA7,0x20,0x08,0xA9,0x5F,0x13,0x2A,0x32,0x93,0x3B,0x07,0x82,0x43,0xC1,0x43,0x31,0xC7,0xAD,0x19,
+	0x01,0x97,0x19,0x13,0xD0,0x77,0xBC,0xA0,0xC5,0x1D,0x89,0x0F,0xE6,0x56,0xE7,0x95,0x70,0x1A,0xB5,0x23,
+	0x73,0x62,0x16,0xAC,0x09,0x2C,0x66,0x99,0x62,0x7E,0xCE,0x3D,0x1F,0x84,0x8A,0xC4,0x21,0x0D,0xD5,0x61,
+	0xB6,0x11,0x76,0xEF,0x0D,0xBB,0xF2,0xDC,0x3B,0x00,0x3E,0xA9,0xA9,0x12,0xCD,0x68,0x54,0x81,0xB8,0x9D,
+	0x4E,0x0D,0x85,0x27,0x56,0x7E,0xAB,0x35,0x32,0x9E,0x04,0x43,0x9A,0xD6,0xC5,0xF0,0x89,0xC7,0x04,0xE4,
+	0x00,0xEA,0xD8,0x00,0x0D,0xE8,0x3F,0x17,0xDF,0xE4,0xE0,0x6E,0xE2,0x37,0xDB,0x00,0xDE,0x2E,0x00,0x8D,
+	0xF1,0xF0,0xAE,0x22,0x3F,0x1E,0x23,0x11,0x11,0x08,0x4A,0xF0,0xF8,0xA1,0x98,0x89,0x35,0x54,0xCD,0xF7,
+	0x89,0x30,0x61,0x99,0xEC,0x5A,0x58,0xE3,0xDD,0xC1,0xBB,0x77,0x7D,0xCC,0x2E,0x75,0x90,0xDE,0x8F,0x80,
+	0xDA,0xD2,0xEE,0x68,0x74,0x57,0x0B,0xED,0x3F,0xBE,0xE7,0x37,0x75,0xA5,0x36,0x8C,0x9A,0x18,0xC2,0xF6,
+	0x14,0x12,0x02,0x7F,0xFD,0x53,0x83,0x64,0x88,0xBC,0xDB,0x1D,0xBF,0xD1,0x7F,0xFE,0xF1,0x6B,0xCF,0xDA,
+	0xF9,0x68,0xA8,0xB8,0x8F,0x1B,0xF2,0x76,0xDB,0x1C,0x95,0xB6,0x48,0x34,0x61,0x90,0x36,0xA8,0xA4,0xBE,
+	0x8B,0x51,0x56,0xE1,0xA1,0xC1,0x89,0xC0,0x73,0x1A,0xF5,0xB9,0xAD,0x30,0x8B,0xFD,0x01,0x91,0x7C,0x5B,
+	0x54,0x57,0x54,0xAA,0x80,0x48,0x8C,0x05,0xEB,0x66,0xA2,0xDC,0xC9,0x3F,0xA9,0x19,0x8F,0x8F,0x00,0xBE,
+	0xFD,0x00,0x0D,0x6D,0xBE,0xD5,0x9F,0xC4,0x5C,0xB0,0x30,0x56,0xEB,0x00,0x9B,0xE6,0x00,0x8D,0x86,0x68,
+	0xA0,0xA5,0x36,0x5D,0x9A,0x4D,0x4C,0x26,0xAD,0x70,0x87,0xD9,0x6A,0xAC,0xF5,0x9A,0xEA,0x3A,0x29,0xEE,
+	0xFE,0xA7,0x35,0x58,0xCC,0x74,0x32,0xD4,0x65,0x9D,0xA7,0xAF,0x11,0x9D,0x48,0xE1,0xF2,0x48,0xBB,0x26,
+	0x5F,0x6B,0x8C,0x36,0xF8,0xF2,0x62,0x0E,0x18,0xFE,0x2B,0xEF,0x09,0x47,0x7B,0xFF,0x9C,0x01,0xCC,0x68,
+	0x46,0xC3,0x3D,0xE9,0x3F,0x65,0x87,0xCD,0xF3,0x6F,0xBF,0x2D,0xF7,0x32,0x5E,0x8D,0x4C,0x79,0x84,0x5A,
+	0x15,0xE2,0x46,0x5B,0xB8,0x4E,0x5B,0xB7,0xB7,0x24,0x66,0x8A,0x6A,0xA0,0x10,0x05,0xE0,0x34,0xC4,0xE5,
+	0xA7,0xCD,0xBA,0xC3,0xEB,0x84,0xD4,0x35,0xFA,0x0A,0xFB,0xEE,0x50,0x98,0x38,0x09,0x07,0x97,0xAD,0xDC,
+	0x5E,0x8C,0x01,0x50,0x54,0x56,0x7C,0xE1,0xF5,0x0E,0x24,0x7A,0x40,0x97,0x5D,0x3C,0x00,0x74,0x04,0x00,
+	0x0D,0x46,0x2B,0xA0,0xD4,0xBF,0xDD,0x2D,0xEE,0x19,0xCC,0x00,0xA3,0xD0,0x00,0x8D,0xFD,0x78,0x1D,0x7D,
+	0xB2,0xD8,0xEC,0xB5,0xF6,0x7B,0xD8,0x76,0x2A,0xD0,0x96,0x70,0x93,0x56,0x4D,0x31,0x42,0xF9,0x0D,0x0B,
+	0xD6,0x6F,0x49,0xB8,0xA3,0x4B,0x53,0xD4,0x3A,0xDA,0x95,0xE4,0xC1,0xFA,0xDF,0x7F,0x69,0x8D,0xF8,0x38,
+	0xCB,0xA2,0x6B,0x88,0x0D,0xA2,0xC8,0x52,0x05,0x06,0x57,0xE9,0xF7,0x61,0x05,0xC2,0x24,0x70,0x0F,0xD8,
+	0x23,0xD0,0x5B,0xAB,0x30,0xD9,0x4C,0x6E,0x16,0xC7,0xED,0x9E,0xE5,0xD8,0x92,0xB9,0x1D,0x33,0x8B,0x6B,
+	0xA3,0x91,0xCB,0x6D,0x9A,0x45,0xC1,0xF7,0xD2,0xB9,0x5B,0xE9,0x45,0x41,0xA0,0x3A,0xDA,0x7C,0xE5,0x7E,
+	0x74,0x4A,0x8F,0x41,0xC7,0x36,0xDB,0xFC,0x0E,0x27,0x70,0xFF,0x1A,0x59,0xEF,0xBB,0xAD,0xC7,0xEA,0xAD,
+	0x49,0xC4,0x3A,0x36,0x09,0x99,0x93,0x55,0x61,0x21,0xBA,0x52,0x57,0x94,0x00,0x29,0x3E,0x00,0x0D,0xBF,
+	0xD7,0x63,0xAB,0xDE,0xED,0xE9,0xFB,0x7B,0xFD,0x00,0xAE,0x9A,0x00,0x8D,0x14,0xE3,0x79,0x01,0xD4,0x6B,
+	0x19,0x0C,0x78,0x06,0x92,0xAD,0xB1,0x6F,0x18,0xE4,0xAC,0xC5,0x21,0x44,0x03,0x25,0x43,0xE8,0x28,0x47,
+	0x5B,0x4C,0xCA,0x7A,0x5F,0xE7,0x98,0xC8,0x7A,0x5E,0xE2,0x04,0xF5,0x64,0xBB,0x5D,0x7D,0x5E,0xCF,0x8F,
+	0x61,0xA3,0x6A,0xB9,0xDD,0xFF,0xF6,0xD0,0x68,0x0A,0xD2,0xA1,0x54,0x84,0x13,0x0A,0x32,0x86,0x2E,0xA0,
+	0x51,0x0E,0x23,0xF1,0x01,0x68,0x86,0x50,0xA7,0xC7,0x46,0xB6,0xA7,0x80,0x98,0x4D,0xD8,0x71,0xF4,0xB1,
+	0x7E,0x5D,0xCB,0xFB,0x63,0x24,0x1E,0x4A,0x54,0xE7,0x7E,0x2E,0x31,0x4E,0x14,0xE4,0x9C,0x28,0x27,0x9C,
+	0x24,0x15,0x9C,0x51,0x13,0x9E,0x18,0xA2,0x5A,0x0B,0xC2,0xDF,0xEB,0x36,0xEA,0x41,0x42,0x27,0x43,0x3F,
+	0xA6,0xC5,0xA4,0xA2,0xBD,0x1F,0x45,0xD4,0x1B,0xA2,0xC1,0x41,0x00,0x77,0x32,0x00,0x0D,0x02,0xD5,0x62,
+	0xAA,0x5D,0x59,0x0C,0x96,0xCB,0x8B,0x00,0xD0,0x63,0x00,0x8D,0x0F,0xD8,0x64,0xAC,0xDA,0xD8,0xEC,0x76,
+	0x3B,0xBB,0xA6,0x1D,0x2F,0xE7,0x92,0x91,0xCE,0x1F,0x29,0x81,0xFE,0x96,0x2A,0x10,0x79,0xD1,0x69,0x70,
+	0xC9,0xE1,0x51,0xA9,0x65,0x60,0x04,0xE8,0x25,0x06,0xE2,0x75,0xCB,0xA8,0xF5,0x2D,0x27,0x17,0xE6,0xA6,
+	0x69,0xAD,0xD7,0x8E,0x0C,0xB1,0xAB,0x90,0xAB,0x6D,0x9B,0x13,0x8B,0x53,0x3F,0x06,0x57,0x43,0xFB,0xAF,
+	0xB4,0xB5,0x8F,0xC8,0xA0,0x66,0x04,0x13,0xE2,0x41,0x4B,0xC1,0xD0,0xFB,0x07,0x33,0x8D,0x79,0xC1,0x5F,
+	0x00,0xE6,0x33,0x45,0xF7,0xD6,0xFF,0x6B,0x63,0xCF,0x35,0xA8,0x91,0x08,0xF4,0xA9,0x74,0x89,0xD9,0x9F,
+	0xDA,0xBC,0x1E,0x7F,0xE8,0x06,0x6B,0xEB,0xB8,0x28,0x96,0x2C,0x74,0x96,0x3B,0xA8,0x67,0x99,0xCA,0xE7,
+	0x81,0x7C,0x7D,0xC4,0x1F,0xF9,0x94,0x25,0x55,0xCE,0x00,0x04,0x43,0x00,0x0D,0x46,0x91,0xC0,0x08,0x0F,
+	0x7C,0x9E,0x5A,0xDE,0x2C,0x00,0x54,0x19,0x00,0x8D,0x05,0x8B,0xCD,0x92,0x45,0x46,0xA3,0xD1,0xD1,0xE8,
+	0xBB,0x6B,0xA4,0x58,0x08,0x17,0xB4,0x7B,0x42,0x55,0xE0,0x92,0x7F,0xB9,0xA8,0x05,0xD8,0x5D,0xC6,0xD9,
+	0xCB,0x0D,0x7B,0x40,0xB7,0x4E,0xAE,0xAF,0x6E,0xD7,0x1B,0x88,0x51,0xC0,0xAB,0x23,0xCE,0xE0,0x62,0xE7,
+	0x75,0x25,0xE4,0xFC,0x1D,0xC5,0xF7,0x1C,0x7D,0xE8,0xD7,0xF4,0x15,0xA6,0xC9,0x68,0x5D,0x5B,0xB7,0x44,
+	0x41,0x89,0x69,0x28,0x6E,0xAD,0x9B,0x4A,0x53,0x36,0x97,0xE4,0x5A,0x74,0x9F,0x3B,0x3D,0x72,0xE0,0x0D,
+	0x2C,0x06,0xCF,0xF0,0xAC,0xDF,0x49,0x3B,0xD4,0xD1,0xF7,0xB2,0x8B,0x0D,0xF8,0xCF,0x70,0x47,0x0F,0x8E,
+	0x02,0xC1,0xD6,0x13,0x9C,0xE5,0x8D,0x76,0x43,0x75,0xF9,0x49,0xE2,0x93,0x68,0x33,0x2D,0x11,0x1F,0xA4,
+	0x8A,0xFE,0x4A,0x32,0xCD,0x40,0xE7,0x4C,0x00,0x38,0xE5,0x00,0x0D,0xE3,0x37,0x93,0x54,0x21,0x10,0x33,
+	0x88,0x89,0x84,0x00,0xC0,0xBF,0x00,0x8D,0x08,0x8C,0xCE,0x92,0x8F,0xC6,0x62,0x63,0x31,0x31,0x87,0x03,
+	0x57,0x36,0x4C,0x40,0x21,0xF8,0x18,0x31,0x08,0x27,0xC2,0x70,0xBF,0x77,0xD3,0x11,0xB5,0x64,0xEF,0x2D,
+	0xFD,0x16,0x5A,0x4B,0x1C,0x6A,0x42,0x74,0xFB,0x60,0xF0,0x19,0x50,0xBC,0x2F,0xA8,0xA2,0xDE,0x77,0x8C,
+	0x9B,0x40,0xD1,0x09,0x52,0xB4,0xDC,0x73,0xBA,0xAE,0xA2,0x26,0xD6,0x59,0xE1,0x40,0xCA,0x3A,0x8C,0x39,
+	0x47,0x44,0x8A,0x47,0xD6,0xF8,0x0E,0x58,0x3C,0x02,0xE1,0x16,0x7E,0x04,0xBE,0x57,0xE4,0x61,0x70,0x41,
+	0xB1,0x2C,0xD2,0x21,0x79,0x83,0xED,0x4D,0xCC,0x6D,0xA7,0xB3,0xAD,0xAA,0x5B,0xC5,0x95,0x07,0x71,0xCA,
+	0x12,0x3D,0x95,0x97,0x4D,0xBC,0x5B,0x2F,0xD7,0xC9,0x62,0x81,0x21,0x84,0x76,0x68,0xC7,0x83,0x85,0x5E,
+	0x2C,0x38,0xE8,0xAF,0x31,0x36,0x00,0x3E,0xE6,0x00,0x0D,0xE1,0xA0,0xD8,0x6D,0xBD,0x92,0xFD,0xC9,0xEE,
+	0xE4,0x00,0x66,0xF4,0x00,0x8D,0x38,0xEF,0xFF,0xDE,0xE3,0xDF,0xEF,0xA2,0xF7,0x51,0x21,0x98,0x2D,0x7D,
+	0xC8,0xDB,0x12,0xC1,0x8F,0x06,0x7B,0xDA,0x68,0x82,0xBD,0x30,0xED,0x7D,0x4B,0xF7,0xA4,0x45,0xF4,0xEC,
+	0xA7,0x8E,0x36,0x9E,0xF6,0x96,0xCA,0x13,0x98,0x51,0x68,0xF5,0x30,0x20,0x97,0x04,0xB2,0x4F,0x25,0xB6,
+	0xA8,0x13,0x8C,0x65,0xC4,0xF2,0xDE,0xB1,0xD0,0xF9,0x36,0x8A,0xB7,0x0D,0x16,0x97,0xFA,0x05,0x01,0x17,
+	0xA9,0x4B,0xBF,0x4E,0xD3,0x70,0x32,0x6D,0x08,0xB2,0x97,0xB3,0x4D,0x35,0xD1,0x4A,0x58,0x3D,0x48,0xD2,
+	0x69,0x14,0x6A,0x1A,0xFB,0xCC,0x3D,0x4E,0x1C,0x1F,0x86,0xBF,0x51,0x65,0xCE,0xC7,0xBF,0xA8,0x47,0xDA,
+	0x39,0x43,0x35,0x5E,0x4C,0xB0,0xA3,0xAB,0x85,0xA2,0xB4,0x15,0xB9,0xFA,0xBC,0x1C,0x7B,0x0F,0x20,0x70,
+	0x48,0x37,0x1F,0xD1,0x00,0x6A,0x4C,0x00,0x0D,0x0C,0x0E,0x8F,0xC4,0xA8,0x56,0xD4,0xAA,0xFB,0xBD,0x00,
+	0x71,0x98,0x00,0x8D,0x7B,0xC3,0xE9,0x81,0xE1,0x71,0x71,0xB8,0xC0,0xDC,0xC8,0x78,0x62,0xAB,0x89,0x45,
+	0x43,0xA0,0x21,0x90,0x1F,0x77,0xBA,0x97,0xE6,0x01,0xAB,0x3B,0x41,0x33,0x40,0xFE,0x1D,0x7E,0x62,0x20,
+	0x2F,0x49,0x50,0xFE,0x4E,0x22,0x50,0xCD,0x18,0x95,0x69,0x1F,0x02,0xEE,0x85,0xC5,0xE0,0x4C,0x86,0x43,
+	0xDB,0x05,0xED,0xE5,0x17,0x3B,0x39,0xFD,0x1D,0x1D,0x46,0x47,0x93,0xA9,0x4C,0x9D,0xEE,0xE6,0x72,0xBE,
+	0xD4,0xFE,0x7B,0xC5,0x1C,0x6C,0x8D,0x06,0xE1,0x04,0xF4,0x48,0xF8,0x18,0x74,0x07,0xB1,0x31,0xE8,0x4E,
+	0xF7,0x9B,0x70,0x84,0x32,0x71,0x94,0x76,0xE2,0x93,0x39,0x0F,0x67,0xCA,0xE7,0x93,0x71,0x00,0xB6,0xBF,
+	0x2F,0x97,0x18,0x6A,0x8B,0xD6,0x5E,0x11,0x1F,0x67,0x44,0xB1,0x5F,0x90,0xA2,0xB0,0xA8,0x42,0x17,0x2A,
+	0x34,0xF5,0x00,0xD8,0x03,0x00,0x0D,0xE0,0x37,0x93,0x98,0xA6,0xC2,0x43,0xE1,0xB0,0x18,0x00,0x2B,0xBE,
+	0x00,0x8D,0x46,0x68,0x3C,0xEB,0x46,0xA2,0x7D,0xD1,0x3E,0x9F,0x8F,0x0E,0xB5,0xE3,0x71,0x99,0x38,0xA6,
+	0x0C,0x67,0x02,0xFD,0x80,0xA1,0x50,0xBB,0xF8,0x2F,0x28,0xF3,0x09,0xDF,0x23,0x23,0x96,0x7E,0x49,0xDE,
+	0x20,0x97,0x12,0xE9,0x64,0x21,0x05,0x5D,0x8E,0xC3,0x16,0xD3,0x80,0x25,0x92,0x70,0xC8,0x54,0xC9,0xE1,
+	0x7C,0xE5,0xF3,0xDD,0xEB,0xB3,0xB1,0x22,0x5B,0x06,0xAC,0xB6,0x80,0x53,0x4D,0xE6,0xE5,0xE3,0x76,0x3C,
+	0x1C,0x3F,0xD4,0x7B,0x40,0xA7,0xAD,0xC5,0x18,0x32,0x3C,0x74,0x4B,0xD6,0x25,0xDF,0xF9,0xA9,0xD5,0x0C,
+	0x74,0xEB,0x7E,0xCE,0x15,0x13,0x9A,0x32,0x6E,0xA1,0x20,0x53,0xD8,0x38,0xEC,0x7F,0x74,0x73,0xB5,0x9D,
+	0xCD,0xCD,0x16,0x6B,0x8B,0xD6,0xA0,0x54,0x59,0xE8,0xB8,0xF7,0x15,0xE9,0x04,0x11,0xC2,0xC4,0xE4,0xB0,
+	0x00,0x90,0xCB,0x00,0x0D,0xDD,0x66,0x0D,0x73,0xB2,0x5B,0x78,0x2D,0x96,0x0B,0x00,0x25,0x32,0x00,0x8D,
+	0x4F,0x98,0x44,0x8C,0xCA,0xE4,0x24,0xF1,0x12,0x09,0x55,0x29,0x62,0x04,0xF2,0x8B,0xFB,0xF9,0xC6,0x6F,
+	0x60,0x34,0x31,0xBB,0xC1,0x3C,0xCF,0x0F,0x33,0xE7,0x5B,0x1D,0x0F,0xEE,0x87,0x0A,0x22,0xA1,0xA2,0x10,
+	0xE8,0x63,0x72,0x78,0x3A,0xAF,0x9C,0x1B,0x4E,0x1E,0x43,0xD6,0x69,0x97,0x11,0x2B,0x08,0x91,0x4D,0xBC,
+	0x1B,0xAB,0x17,0x7F,0x0D,0x8A,0x06,0x66,0x43,0xD0,0x5C,0xF5,0xDC,0x18,0x77,0xD3,0x41,0x33,0xBE,0xDC,
+	0x53,0xEB,0x8C,0x8E,0xF6,0xB6,0xB9,0xB4,0x4F,0x4D,0x22,0x42,0xC5,0xEF,0x65,0x85,0x32,0xCE,0x55,0x48,
+	0xC3,0x73,0x63,0xA9,0x4C,0xA0,0x2A,0xE5,0x94,0x4E,0x64,0x04,0x72,0xE3,0xBB,0x5D,0x2D,0x39,0x5E,0xE2,
+	0xCB,0x95,0x22,0x95,0x84,0x3D,0x32,0xEF,0x89,0x28,0x4C,0xF4,0x4F,0xDC,0xE4,0x81,0x06,0x4B,0x00,0x45,
+	0x68,0x00,0x0D,0x3E,0xE8,0x7C,0xB4,0x51,0x55,0x89,0x2A,0x55,0x15,0x00,0xFE,0x8F,0x00,0x8D,0x40,0xA9,
+	0xC3,0x14,0x06,0x02,0x02,0x81,0x40,0xC0,0x65,0xA1,0xBD,0x10,0xD9,0x67,0x15,0x92,0x07,0x10,0x96,0xD2,
+	0x62,0xE5,0x53,0x13,0xDB,0x7C,0xED,0x77,0x3B,0x7C,0x8E,0x5D,0x6E,0x62,0x33,0xAA,0x9F,0x9C,0x48,0x9A,
+	0x37,0xA8,0xC4,0x03,0x61,0xF5,0x8A,0xA5,0x32,0x83,0x55,0xC1,0x90,0x79,0xC6,0xFD,0x17,0x55,0x53,0x02,
+	0xE2,0x02,0xD9,0xAB,0xEB,0x66,0x9E,0xE2,0xF2,0x69,0x96,0xF7,0x76,0x6E,0x66,0x6E,0xF7,0xEA,0xBF,0x45,
+	0xB9,0xEA,0x7A,0xC0,0xDA,0xED,0xFE,0x03,0xF6,0x9B,0x38,0xFD,0x9E,0xE8,0x5F,0xD7,0x78,0x76,0xC8,0x90,
+	0xE4,0xF9,0xE2,0x42,0x8F,0xE9,0x64,0x0C,0x3B,0x11,0x95,0xB1,0xB7,0x3D,0xA1,0xA6,0x8C,0xCD,0x9F,0x10,
+	0x93,0xE8,0xB4,0x79,0x46,0xDB,0xF3,0x34,0x5F,0x3F,0x03,0xC9,0x02,0x13,0x14,0x2E,0x00,0x4D,0xF9,0x00,
+	0x0D,0x16,0x03,0x68,0x40,0x2B,0x2F,0xB3,0x0B,0x05,0x45,0x00,0xDA,0xF3,0x00,0x8D,0x68,0x4C,0x2E,0xE6,
+	0xFF,0xFC,0x7E,0xAC,0xBF,0xD6,0xA7,0xE5,0xD5,0x54,0xEA,0x57,0x4C,0x4A,0xBB,0x3C,0x3B,0x41,0x9E,0x57,
+	0xB4,0x09,0x55,0xE2,0xD6,0xE8,0x62,0x75,0xB5,0x4B,0x65,0xEA,0xE6,0x16,0x33,0x60,0x64,0x36,0x1A,0x09,
+	0x9A,0x88,0x4F,0x90,0xB1,0x51,0xC8,0x38,0x5B,0x75,0x5E,0x76,0xA3,0x3D,0x97,0x8C,0xC6,0x3F,0x6A,0x1A,
+	0xF1,0x6C,0x0A,0x2E,0xEF,0xC9,0x7D,0x2D,0x8A,0xF8,0x9D,0xFF,0x3E,0x57,0x93,0x54,0x18,0xB0,0x16,0xDB,
+	0x3C,0xD6,0x8B,0xE5,0xA4,0x63,0x4B,0x8E,0x9E,0x4F,0x1E,0xA9,0x06,0x18,0x07,0xC2,0x82,0x82,0x7E,0x2C,
+	0x6C,0x78,0x8D,0xD9,0xDA,0xF4,0xC1,0x4A,0xFD,0x6E,0x78,0xE0,0x97,0x4F,0x5E,0x0B,0xA1,0xE3,0xD6,0x57,
+	0xEB,0x18,0xCC,0xED,0xFB,0x1D,0x52,0x75,0x77,0x23,0x2C,0x33,0xFF,0x4C,0x00,0x65,0x5E,0x00,0x0D,0x69,
+	0x3C,0xC0,0x95,0xF4,0xF8,0xF5,0xE8,0x68,0xF4,0x00,0xB0,0xBA,0x00,0x8D,0x34,0x64,0xBA,0x89,0x48,0x9B,
+	0xCD,0x66,0x33,0xB3,0x19,0x99,0x05,0xCC,0x06,0x12,0x0A,0x47,0xB0,0x40,0xFF,0x8F,0xD4,0x27,0xF1,0xEE,
+	0xEA,0xFB,0x74,0x0D,0xD1,0x10,0xCC,0x1F,0xE4,0x7E,0x34,0xF6,0x4D,0xC2,0x7C,0xE3,0x1F,0x07,0xEB,0x54,
+	0x7E,0xD3,0x1E,0x77,0xD0,0x17,0xDF,0x6B,0xF9,0x3B,0xD2,0x65,0x53,0xE4,0xBF,0xB0,0xF2,0x47,0x75,0xA2,
+	0x86,0xEC,0x23,0x95,0x0C,0x62,0xCB,0x54,0x11,0x17,0xF0,0x38,0xF0,0xE9,0xE1,0xAE,0x0F,0xB1,0x25,0x10,
+	0x6E,0x9C,0x51,0x06,0xF5,0x27,0x53,0xCF,0x01,0x79,0x18,0x1F,0x7D,0x5F,0x73,0x36,0x1C,0x8B,0x52,0x70,
+	0xA5,0x33,0xE7,0x7D,0x03,0x0F,0x72,0x26,0x05,0xB9,0x82,0xBF,0x18,0x11,0xFD,0x85,0xCA,0xE1,0xE6,0x66,
+	0xC3,0x60,0x65,0xA0,0x30,0x1B,0xFB,0x58,0xE7,0x6F,0xE3,0x6A,0x00,0x00,0x75,0x00,0x0D,0x94,0xFC,0xF6,
+	0x3E,0x14,0x18,0xAD,0xC4,0xC6,0x21,0x00,0xA7,0x51,0x00,0x8D,0x5A,0xA5,0xCE,0x92,0xDF,0x45,0x6E,0xA2,
+	0x36,0x51,0xE8,0x0B,0x14,0x71,0x3B,0x84,0x4D,0xF9,0xF4,0xF6,0xF9,0xEE,0x07,0x87,0x81,0xD5,0xC1,0x63,
+	0x03,0x6D,0xB9,0xB7,0x52,0xBA,0x44,0x83,0x97,0x58,0x86,0xEF,0x4E,0xE6,0x64,0xD9,0x1C,0x1F,0x9A,0x43,
+	0x2C,0xE8,0x31,0x59,0x05,0xE3,0xD2,0x9E,0x7B,0x5F,0xB2,0x2D,0xFF,0x53,0xD6,0x19,0x97,0x57,0x30,0x67,
+	0x60,0x81,0xA3,0xA8,0xA2,0xC1,0xA5,0xA4,0x2D,0x3E,0xD5,0x44,0x36,0xEC,0xF4,0x59,0xDD,0xEF,0xFD,0xD3,
+	0x40,0x8E,0xAD,0x45,0xF8,0x26,0x34,0x79,0xF9,0x46,0x24,0xB2,0x24,0x85,0x04,0x9E,0x15,0x96,0xC8,0x35,
+	0x89,0xD0,0x78,0x27,0x13,0x85,0xB2,0x33,0x48,0xAD,0x98,0x0E,0xE9,0x37,0x79,0x7C,0xBE,0x44,0xA4,0x57,
+	0xC0,0x6D,0x68,0xE0,0x91,0x28,0x76,0xF0,0x39,0x87,0x00,0xB7,0x3D,0x00,0x0D,0x6D,0x3E,0x17,0x12,0x82,
+	0x98,0xE9,0xE6,0x88,0x04,0x00,0x8A,0xB5,0x00,0x8D,0x48,0x91,0x46,0x88,0xCB,0xE4,0x72,0xB9,0x9B,0x4D,
+	0x6E,0xEF,0xA2,0x52,0xE3,0x79,0x55,0x69,0xD6,0xF0,0xE9,0x6F,0x47,0x92,0x35,0x9F,0x1F,0x1C,0x6A,0x56,
+	0x4F,0x90,0x25,0x59,0xC8,0x47,0xA9,0xC3,0x4C,0xB9,0x4F,0x00,0x83,0x02,0x39,0x4C,0x08,0x9B,0x6B,0x1B,
+	0x38,0x8F,0xA7,0x89,0x66,0x25,0xD3,0x71,0x48,0x39,0xE9,0xE3,0x68,0xA9,0x92,0x08,0xED,0x34,0xAC,0x06,
+	0x42,0xBE,0x4E,0x09,0x9C,0xDD,0x34,0x36,0x4C,0xC8,0x2D,0x78,0xB7,0xDE,0x2B,0xBE,0xA0,0x46,0x7F,0x78,
+	0x25,0x01,0x29,0x5D,0x37,0x70,0x9C,0x26,0xC6,0x70,0x94,0xEB,0x51,0x6D,0x84,0xE8,0x3E,0xAF,0xAF,0x88,
+	0x47,0xD4,0x0A,0xD6,0xD1,0x08,0xE8,0xE7,0x89,0x3E,0xE4,0x08,0xDD,0x2E,0x65,0xD3,0x97,0x0D,0x3B,0xBC,
+	0xD3,0x42,0xE4,0x73,0x74,0x29,0xD2,0x69,0x00,0x49,0x91,0x00,0x0D,0x5C,0x8A,0xCD,0x13,0x09,0x86,0xB0,
+	0xCB,0x65,0x25,0x00,0xED,0xC2,0x00,0x8D,0x58,0xA4,0xFD,0x12,0x85,0x86,0x43,0x43,0x21,0x02,0xC1,0x20,
+	0xE0,0xE3,0xFF,0x3F,0x77,0xA8,0x97,0x57,0xC0,0xB6,0x4E,0x00,0x08,0x99,0x0D,0x87,0x44,0x75,0xB1,0x39,
+	0xDE,0x7C,0x40,0xA3,0x5C,0xBF,0x29,0x12,0x0B,0xA6,0xDC,0xB2,0x47,0xB4,0xB7,0xE5,0xEA,0x78,0x8E,0x2F,
+	0x7F,0x18,0x0E,0x64,0x43,0xD5,0xA9,0x92,0xB0,0xA4,0xD8,0xB2,0x97,0xA6,0xE1,0xB7,0x16,0xC8,0x77,0x13,
+	0xB8,0x9A,0x3B,0xDD,0x0E,0x84,0x12,0xA2,0x89,0x5F,0x1A,0x9D,0xEA,0x6E,0x52,0xDF,0xC9,0xAA,0xB4,0xCD,
+	0xEF,0xD9,0xFA,0x6E,0xC4,0xFC,0xFD,0xEF,0x00,0x38,0x33,0x6F,0x97,0x3F,0x96,0x57,0xCD,0xC5,0xD5,0x23,
+	0x76,0xBE,0x47,0x86,0x2F,0xF9,0x67,0x69,0xF6,0x9C,0x5E,0x28,0xE7,0xBD,0xA7,0xCD,0x64,0x73,0x49,0xA5,
+	0x1A,0xD7,0x89,0x47,0x6B,0x82,0x00,0x5E,0x80,0x00,0x0D,0x08,0x8C,0xE6,0x86,0xC8,0xE5,0xC3,0x72,0xF2,
+	0xB9,0x00,0xBE,0x21,0x00,0x8D,0x93,0x41,0x2A,0x60,0x7E,0x3E,0x9F,0x9F,0x4F,0xA7,0xA4,0xF3,0x77,0x45,
+	0x96,0x37,0x74,0xB0,0x27,0x7B,0xD5,0x5A,0xE8,0xE7,0x7D,0x5D,0xB3,0xCC,0x85,0x62,0x1E,0x9C,0x98,0x5B,
+	0xF5,0xDB,0x07,0x7F,0x65,0x22,0xD1,0x53,0x9F,0xF7,0xEB,0xA8,0x98,0x6E,0x49,0xE8,0x4E,0xBF,0xBE,0x80,
+	0x30,0xBB,0x96,0x3E,0xA6,0x39,0x1A,0x03,0x69,0x67,0x0A,0xEB,0x8B,0x56,0xF3,0x44,0xA0,0x7B,0xFD,0xA2,
+	0xAA,0x2A,0x95,0x47,0xC6,0x9A,0xE8,0x86,0xB5,0x28,0x5D,0x9C,0xB7,0xA7,0x11,0x86,0x85,0x41,0xDA,0x2B,
+	0x41,0x85,0x4E,0x9E,0x2E,0x01,0x21,0x28,0xF0,0xF0,0x48,0x57,0xC5,0x75,0xF7,0x46,0x41,0x4A,0xB5,0x56,
+	0xC4,0x6C,0x7C,0x9B,0x2B,0xBE,0x55,0x4C,0xBA,0x37,0xDF,0xE8,0xAC,0x36,0xB0,0xDB,0x56,0x57,0xD6,0xEA,
+	0x68,0x45,0x75,0xB4,0x00,0xFA,0xA5,0x00,0x0D,0xEF,0xFF,0x94,0x3F,0x25,0x10,0x37,0x88,0xBF,0x1F,0x00,
+	0x4E,0xBA,0x00,0x8D,0x35,0x12,0x79,0xC9,0xD4,0x6B,0x35,0x35,0x9B,0x1A,0x18,0x82,0x8D,0x52,0x3D,0xBF,
+	0x94,0x9B,0xEA,0x46,0x11,0xB9,0x7F,0xC3,0x14,0x05,0xDB,0xF3,0x8C,0x33,0x4B,0xD9,0xEC,0xD4,0x7B,0xAB,
+	0xE9,0x14,0x0A,0x84,0xC2,0x5A,0x11,0x60,0x04,0x87,0xFD,0x00,0xD7,0xC5,0x18,0x25,0x4A,0xDF,0x49,0x98,
+	0xD5,0x44,0xD4,0xA1,0x95,0x9C,0xB6,0xEF,0x17,0x96,0xDB,0xB7,0x62,0x0D,0xE6,0xE2,0x82,0xD8,0xA4,0x2D,
+	0xEB,0xF4,0x1A,0x21,0xAD,0x0E,0x74,0x34,0x90,0xC0,0xDB,0x95,0xF4,0x15,0xDD,0xDD,0x18,0x4B,0x87,0xE6,
+	0xA6,0x56,0xF2,0xAF,0x99,0xC8,0x54,0xEA,0xC6,0x50,0x70,0xEA,0xB5,0xCC,0x86,0xAD,0x0D,0x63,0xFE,0xAE,
+	0xE7,0xB7,0xF6,0xDB,0xB7,0x80,0x56,0xE2,0x60,0x16,0x00,0xF2,0x19,0xC4,0x85,0xF3,0xB1,0x9E,0x72,0x18,
+	0x02,0x90,0x00,0xB3,0x94,0x00,0x0D,0x41,0xA8,0xC0,0x95,0xC1,0xC8,0xC5,0x63,0x71,0xF8,0x00,0xB2,0x3F,
+	0x00,0x8D,0xD2,0x61,0xB8,0xA8,0xB5,0x5B,0xAD,0xAD,0x56,0xD6,0xB8,0xAD,0x55,0x76,0xDB,0xB4,0x32,0xD9,
+	0x0D,0x2A,0x53,0x81,0xD3,0x28,0xB5,0xFC,0x24,0x31,0x1C,0xDB,0x8D,0xD7,0xEF,0x25,0xC0,0xF0,0xFF,0xE8,
+	0x94,0x05,0xD1,0xDA,0x70,0xE3,0xBE,0x24,0x17,0xDE,0x8A,0xCF,0xDE,0x5E,0x0C,0x3D,0xE3,0x5A,0x4D,0x3B,
+	0xC5,0xF8,0x30,0x1B,0x1D,0x98,0x00,0x93,0x05,0x96,0x71,0x20,0x20,0xCF,0x97,0xE1,0x05,0x14,0x3D,0xBF,
+	0x59,0xA2,0xC8,0xB7,0x89,0x03,0x7F,0xAC,0x1C,0xB9,0xA1,0xED,0x51,0x5C,0x40,0x29,0xE6,0xE4,0x76,0x42,
+	0x37,0xFB,0xFB,0x06,0x83,0x02,0x40,0x90,0xA9,0xA4,0xE3,0xFC,0x95,0xB4,0xC4,0x58,0xBF,0xF2,0x35,0x17,
+	0x6E,0x7B,0x25,0x59,0x33,0xDE,0x95,0x50,0x36,0x99,0xB1,0xC9,0x0E,0x35,0xA6,0x40,0x2D,0xD3,0x1A,0x7D,
+	0x00,0xF0,0x38,0x00,0x0D,0xE3,0xF9,0x2F,0xE2,0xEE,0x75,0x58,0xBA,0x37,0x5B,0x00,0xB6,0x5A,0x00,0x8D,
+	0xD1,0x60,0x93,0xBC,0xA0,0x51,0x51,0xA8,0xA9,0x54,0xBD,0x7D,0x4C,0x28,0xC2,0xE7,0x6F,0x2D,0x08,0x10,
+	0x05,0x86,0x29,0x98,0x70,0x2B,0xA8,0x91,0xC0,0x71,0xF0,0xC2,0x58,0x99,0xAE,0xD9,0xC2,0x1B,0x26,0xE2,
+	0x1A,0xAE,0x1D,0x46,0x0E,0x16,0xA1,0x40,0x8E,0x67,0xAA,0xA3,0xDF,0x34,0x9C,0xFF,0xB4,0xD8,0x18,0x8D,
+	0x33,0x53,0x41,0x31,0xAB,0xCC,0xE6,0x07,0x74,0x14,0xE2,0x51,0x32,0x5E,0x94,0x2E,0x9F,0x02,0x01,0xDE,
+	0xA5,0xAA,0x43,0x36,0x3E,0xEF,0x02,0xF9,0x4E,0x26,0x4B,0x36,0x57,0x9B,0x89,0x27,0x28,0xA0,0xB8,0xC2,
+	0x7E,0x39,0xDC,0xDC,0x67,0xB2,0xC4,0xBB,0x33,0x9E,0x87,0x41,0xD1,0x56,0xB5,0x33,0x5C,0x80,0x08,0x1D,
+	0x16,0x85,0x1C,0x31,0x00,0x9A,0xC2,0x63,0x69,0xA2,0x59,0x22,0x2A,0x4E,0x1D,0xCC,0x13,0x1B,0x00,0x07,
+	0x6B,0x00,0x0D,0x6A,0xC0,0x56,0xDE,0xE4,0xAF,0xFF,0xF7,0xEB,0x7B,0x00,0xAF,0x32,0x00,0x8D,0x77,0x8F,
+	0x58,0xD9,0x60,0xA6,0xD3,0xD9,0x6C,0x36,0xB7,0xC4,0xDD,0x2C,0xF3,0x0A,0xF1,0xCA,0x42,0x78,0x30,0xFD,
+	0x2F,0x1D,0x0D,0x1E,0xF5,0x15,0x6A,0x73,0x35,0x5F,0x84,0xF7,0x38,0x21,0x59,0x6E,0xFC,0xC0,0x9E,0xAF,
+	0x0A,0x2C,0x02,0x29,0xCA,0x04,0x8E,0x74,0x5B,0x8E,0x25,0xA1,0xF6,0x75,0x07,0xFA,0x11,0xA3,0x06,0x30,
+	0xAF,0x1C,0x1F,0xA7,0x5B,0xA6,0x3F,0x82,0x91,0x23,0xB6,0xB5,0xD3,0x8A,0xB4,0x1C,0x4E,0xD3,0x79,0xB0,
+	0xDB,0x55,0x59,0x62,0x52,0x6B,0x76,0xED,0x3E,0x90,0x5F,0x3E,0xA8,0xD1,0x2B,0xA3,0x23,0xD9,0x96,0xF6,
+	0x20,0x2B,0x70,0x02,0x75,0x6D,0x15,0x6E,0xC3,0x5E,0x64,0x43,0x08,0xE9,0x84,0xE9,0x37,0x2E,0xFB,0xED,
+	0x2D,0x8B,0x9D,0x3D,0x7E,0xF3,0x77,0x4C,0x45,0x7C,0xA6,0x40,0x3D,0xE1,0x74,0x57,0x00,0xAA,0x99,0x00,
+	0x0D,0x50,0xA0,0xCB,0x90,0x8A,0xC7,0x7C,0xAA,0xAA,0x95,0x00,0x1E,0x12,0x00,0x8D,0x00,0x51,0xE3,0x04,
+	0xB8,0x5D,0xAE,0x03,0x81,0x01,0xE1,0xE5,0x71,0xD0,0x41,0x8F,0xAC,0x45,0xA4,0xE0,0xF4,0xE5,0x04,0xBA,
+	0x5D,0x4D,0x9A,0x70,0x6E,0xB7,0x9B,0xAE,0x63,0x49,0x70,0x9B,0x9D,0xE1,0xB2,0x5A,0x19,0x6D,0xDA,0xA1,
+	0x62,0x82,0x9D,0xE4,0xEF,0x22,0x1B,0xC8,0xE0,0x3D,0xE5,0x46,0x98,0x70,0x13,0xE5,0x07,0xD4,0x3D,0x31,
+	0x4D,0x43,0xD9,0x7A,0xCE,0xF7,0x10,0x4E,0xF4,0xBF,0x9C,0x88,0xA5,0x1A,0x46,0xCC,0xE3,0x11,0xFA,0x7B,
+	0x10,0x96,0x4A,0x5E,0xDE,0x6E,0xE8,0xA7,0xF7,0x78,0x55,0x50,0x0F,0xC5,0x16,0xA8,0x70,0xE0,0x10,0x19,
+	0x16,0xC5,0xCD,0x7F,0xE4,0xBC,0xAA,0xCA,0xFD,0x1E,0xE6,0x74,0xFA,0x1B,0x76,0xFE,0xBD,0x7E,0x5F,0xCF,
+	0x3F,0x51,0x23,0x96,0x02,0xA7,0xD5,0xA5,0xCA,0xBC,0x61,0x28,0x2D,0x35,0x00,0xCE,0xFB,0x00,0x0D,0x0E,
+	0x8C,0xCE,0x06,0x88,0x8C,0x6F,0xA3,0x23,0x51,0x00,0xDA,0xA1,0x00,0x8D,0xE2,0x35,0x95,0x5A,0xA2,0xA1,
+	0x50,0x91,0x28,0x94,0x70,0x8A,0xC9,0xE3,0xE7,0x82,0xFB,0x7A,0x55,0x8C,0xB6,0xC3,0x5E,0x02,0x01,0xE4,
+	0x89,0xA4,0xAA,0x93,0xFB,0x49,0x62,0x9C,0x41,0x30,0xCD,0x01,0xC3,0x0C,0xCA,0x07,0xB2,0xE5,0xF0,0x8E,
+	0x3C,0x10,0x1B,0x33,0x89,0xD2,0xD5,0x7C,0x35,0xA5,0x0A,0xA4,0x82,0x4A,0x18,0x68,0x3A,0x9F,0xB5,0x46,
+	0xCE,0x61,0xCC,0xB2,0xF0,0xD1,0x42,0xE9,0x46,0xB8,0x55,0x66,0x22,0x9F,0x77,0x97,0x0D,0xBC,0x75,0x80,
+	0x3F,0x0D,0x79,0x35,0x68,0xA1,0x4A,0xE6,0xAB,0x2D,0x8A,0x1D,0x1C,0x27,0x27,0x5A,0x43,0xC1,0xD3,0x11,
+	0x07,0x8B,0xFE,0x80,0xC0,0x69,0xEC,0x9F,0xF9,0x07,0x5B,0x3A,0xC6,0xBC,0x4D,0xBF,0xDF,0x5E,0x65,0xFA,
+	0x06,0x44,0xD1,0xCE,0xD4,0x5D,0x5C,0x33,0xE2,0x23,0xE3,0x7C,0x00,0x4F,0x2A,0x00,0x0D,0x9E,0xC4,0xAC,
+	0x22,0x38,0x1E,0x34,0x8E,0xC7,0xA3,0x00,0x27,0xF2,0x00,0x8D,0x9B,0x45,0xAA,0x62,0xBE,0xBD,0x5E,0xAF,
+	0xAF,0x57,0xDE,0x9F,0x14,0xF4,0x3F,0x0F,0x44,0xB9,0x9D,0xE6,0x18,0x86,0x00,0x70,0x4E,0x60,0xAB,0x45,
+	0x61,0xC7,0x78,0xD8,0xBD,0xCD,0xA0,0x66,0x51,0xB3,0x5B,0xAC,0x94,0x72,0x8B,0xE7,0x4D,0x0F,0x57,0x05,
+	0xE2,0x9C,0xD4,0x33,0xEE,0xEF,0xFE,0xD2,0xFB,0x0B,0x22,0x10,0x39,0x6B,0x8D,0x57,0x59,0x8B,0x86,0x0C,
+	0x61,0x19,0x3A,0x0E,0xEF,0x44,0xA6,0xC2,0xC1,0xAF,0x54,0xC7,0xB9,0xD2,0xE7,0xAB,0x3D,0x97,0x45,0x71,
+	0xAA,0x42,0xBB,0xEB,0xBD,0x5A,0xA2,0xD4,0xAA,0x97,0x24,0xDA,0xC7,0x75,0xC1,0x2A,0x1A,0x0C,0x89,0x26,
+	0x50,0x2B,0xAF,0xB5,0x25,0x2B,0x6A,0x36,0x5D,0x77,0x72,0xCD,0xAC,0xFE,0xB3,0x00,0xB7,0x90,0x5E,0xCB,
+	0x1E,0x8B,0x85,0xA6,0xCB,0x36,0x92,0x31,0x1D,0x18,0x00,0xC7,0x3B,0x00,0x0D,0x91,0x40,0x2B,0xE0,0xFA,
+	0x7F,0x95,0xBF,0xDF,0x2F,0x00,0x14,0x94,0x00,0x8D,0x05,0x0A,0x61,0xC5,0x26,0x6D,0x92,0xB6,0xC9,0x5B,
+	0x93,0x52,0x54,0x2B,0xD0,0xB4,0xE9,0x69,0xFC,0x57,0xA1,0x01,0x04,0xF6,0x7F,0xB6,0x1D,0xAD,0x62,0x29,
+	0x46,0x0D,0x82,0x6B,0x51,0xA4,0xA6,0xAD,0x45,0x4F,0xD0,0x29,0xB4,0x8B,0x34,0x43,0xEC,0x61,0xDE,0xF1,
+	0x9A,0x13,0xAF,0x11,0x17,0x91,0x6F,0xF7,0x05,0xE1,0xF3,0x41,0x00,0x83,0xE2,0x67,0xB4,0x7F,0x21,0x11,
+	0x91,0xA8,0x38,0xE7,0x74,0x9F,0xA9,0xB8,0xC0,0x55,0xEE,0xC4,0xD8,0x8A,0xA6,0xD2,0x3A,0xCE,0x32,0x2B,
+	0x0E,0x77,0x90,0x00,0xCC,0xE7,0xA8,0xD0,0xC9,0xCF,0x7F,0x87,0xF8,0x7A,0xF6,0x06,0x92,0xB3,0x5F,0x32,
+	0x21,0x95,0x3C,0x06,0x63,0xF0,0xF3,0xC0,0xB8,0x6A,0xF0,0xA6,0x0B,0xE9,0xE8,0x37,0xEC,0xE0,0x0A,0xF0,
+	0x15,0xB8,0x37,0xA9,0x0D,0xCD,0x77,0xE0,0x00,0x04,0x29,0x00,0x0D,0xF9,0x48,0x9F,0xE4,0xA0,0xFD,0xD5,
+	0xFE,0x7F,0x3E,0x00,0x4E,0x08,0x00,0x8D,0x55,0x57,0x49,0xEA,0x79,0x3D,0x94,0x4A,0x25,0xA7,0x76,0x04,
+	0x7C,0x0D,0x34,0x36,0xC2,0xF1,0xC8,0x37,0x04,0x1A,0x55,0x4A,0xBE,0x02,0x48,0xD9,0xAB,0x07,0x0F,0x4F,
+	0x80,0x43,0x9D,0x9A,0x4E,0xB2,0x00,0x4D,0xC6,0x88,0x6F,0x23,0x48,0xD9,0xD8,0xEA,0x24,0xB7,0x94,0x92,
+	0xF9,0xA9,0x73,0x3A,0xA8,0xDF,0x45,0xEF,0x3D,0x97,0x0B,0x52,0x74,0x9B,0x6B,0xC8,0x8E,0xF3,0x25,0xBE,
+	0x7C,0x1A,0xED,0xE7,0xDF,0xBC,0xC1,0xFF,0x7E,0xAC,0xAB,0x48,0xDB,0x85,0x2D,0xA7,0xF8,0x1D,0x74,0x6A,
+	0x21,0x09,0x86,0xD4,0xE9,0x64,0xCD,0xF9,0xE4,0x1A,0xD0,0x6A,0xEE,0x7D,0xE7,0x7F,0xFE,0xAF,0xEF,0xBF,
+	0x9D,0x1F,0x64,0xCE,0xB5,0x17,0x07,0x9D,0x01,0x10,0x97,0xDE,0x41,0xB7,0x90,0xF0,0xC1,0x94,0x84,0x72,
+	0x5A,0xCD,0xA0,0x45,0x19,0x2A,0x00,0x74,0xBB,0x00,0x0D,0x9F,0xC7,0x6B,0x40,0x9A,0x4F,0x7C,0x27,0xAB,
+	0x95,0x00,0x42,0x0F,0x00,0x8D,0x83,0xD7,0xE3,0x2B,0x19,0x6A,0x0C,0x86,0x2E,0x97,0xC9,0x26,0x9D,0x2E,
+	0xA1,0xE2,0x42,0x69,0x21,0xE0,0x67,0x2F,0x06,0x30,0x0A,0x88,0x76,0x39,0xA3,0xA8,0x51,0x07,0xC3,0xE0,
+	0xC0,0x17,0xFF,0xE9,0x3F,0xA9,0x12,0x9D,0x0F,0x47,0x1B,0xD0,0xA8,0xD1,0xA8,0x77,0xA0,0x5B,0x14,0x9B,
+	0x75,0x83,0x32,0x54,0x31,0x50,0x2C,0xA5,0x60,0xE8,0xEC,0xEE,0xE2,0xAE,0x62,0x92,0x26,0xA0,0xEF,0x76,
+	0x7D,0x4B,0xAC,0xAE,0x28,0xA7,0xDA,0x91,0x2E,0x4A,0x44,0xAC,0xBD,0x5B,0xDA,0xCE,0x1F,0x8F,0xD4,0x9F,
+	0xFF,0xE7,0xE4,0x5C,0xF9,0xCF,0x82,0x3E,0x40,0xF6,0x7E,0x18,0x77,0xDB,0x54,0x8F,0xE7,0xAC,0x31,0x80,
+	0xD5,0x49,0x11,0x43,0x96,0xC2,0x54,0x51,0xD1,0x46,0x01,0xDC,0x74,0xBD,0x39,0x28,0x07,0xB6,0x0B,0xBE,
+	0x68,0x3D,0x28,0x6E,0x00,0xD3,0x17,0x00,0x0D,0xF5,0xF2,0x71,0xCD,0xD7,0x69,0x26,0x05,0x02,0x42,0x00,
+	0x42,0x8D,0x00,0x8D,0xEB,0x2B,0x9D,0x54,0x26,0x25,0x92,0x49,0x24,0x51,0x71,0xFA,0x23,0x2A,0x04,0xD3,
+	0x85,0xD6,0xC8,0xD7,0x5D,0x01,0x0E,0x10,0x81,0x63,0x09,0xFE,0x62,0xA7,0xB0,0xC3,0x74,0x90,0x8C,0xD0,
+	0x44,0xD4,0x27,0xBA,0x8D,0x14,0xCB,0x2C,0x95,0x0E,0xD0,0x3D,0x8C,0xB1,0xD9,0xBE,0x9F,0xD9,0xAE,0xD6,
+	0x3F,0xBE,0x41,0x72,0x4C,0x82,0x57,0x08,0x0A,0x65,0x96,0xDA,0x37,0x23,0x25,0x01,0x3C,0x4F,0x49,0x44,
+	0xA5,0x48,0x28,0xD5,0x96,0xC9,0xCA,0x57,0x6C,0xC7,0x2A,0x2A,0xD6,0x7B,0xC0,0x7D,0x7C,0xAD,0x4E,0xAB,
+	0x8E,0x22,0x6C,0xD4,0xC6,0x1B,0x1A,0x8E,0x76,0x48,0x67,0x80,0xD6,0x50,0x18,0x55,0x92,0x34,0x99,0x04,
+	0xD2,0xE4,0x64,0xA5,0xA2,0xAD,0xAF,0x43,0xDA,0x78,0xF5,0x64,0xE8,0xBB,0xBD,0xFD,0x66,0x9B,0x56,0x79,
+	0xCB,0x4A,0x00,0x41,0x08,0x00,0x0D,0x07,0x0B,0x60,0xC5,0x1F,0x6D,0x9A,0x46,0xE3,0xA7,0x00,0x95,0x67,
+	0x00,0x8D,0x9B,0xCE,0xEF,0x22,0x1F,0x8E,0x8E,0x47,0x47,0xA3,0x5C,0x97,0x89,0xDD,0xC5,0x12,0xEE,0x57,
+	0x9D,0xF8,0x73,0x6E,0xEF,0x4B,0x9A,0x67,0x0D,0xAD,0x0E,0x18,0x29,0xF3,0x01,0x11,0x28,0xC7,0x0F,0x6F,
+	0xAC,0x94,0x53,0x8F,0x5E,0x0D,0xFA,0xC5,0xC7,0xE2,0x8D,0xEF,0x17,0x3C,0x3A,0x36,0xF7,0xEA,0x2F,0x3B,
+	0x33,0x0F,0x18,0x97,0x71,0xB8,0x9F,0x7C,0x9E,0x2E,0xBC,0x6A,0xB3,0x1A,0x09,0x13,0x82,0x62,0xE0,0xD0,
+	0x69,0xF3,0xFE,0x38,0x54,0x71,0xF7,0x4A,0x2C,0x5C,0xC7,0xAC,0x38,0x35,0x9D,0xD4,0x9A,0x1B,0x65,0xB9,
+	0x24,0x46,0x93,0x10,0x4F,0x44,0x57,0x53,0xE9,0xB4,0x70,0xDA,0xCC,0xDF,0xEA,0xE2,0x79,0xAC,0x71,0xD3,
+	0x1C,0x9F,0x72,0x80,0x40,0xF6,0xC1,0x80,0x6F,0x26,0xA6,0xEB,0xF6,0x68,0x8E,0x7A,0x75,0x13,0xD4,0x52,
+	0x00,0xD7,0x57,0x00,0x0D,0xE5,0xFA,0x75,0xBD,0x55,0xA8,0x79,0x2A,0x14,0x54,0x00,0xDE,0x63,0x00,0x8D,
+	0xE0,0xF9,0x93,0xBC,0x52,0x51,0xA8,0xA8,0xD4,0x6A,0xD8,0x34,0xDE,0xD9,0xA9,0x6F,0x6F,0xEE,0x48,0xEE,
+	0x85,0xB9,0x3C,0x1F,0xCC,0x72,0x73,0xF0,0x54,0xBC,0xBA,0xC6,0x96,0x12,0x4F,0x39,0x35,0x74,0xBF,0x40,
+	0xB0,0x93,0x1A,0x07,0x1D,0xDD,0x1D,0x88,0x15,0x19,0x8D,0x6D,0x11,0x11,0x59,0xE5,0xBC,0x30,0xC7,0x58,
+	0x6C,0xE2,0xE7,0x69,0xBA,0xAD,0x6E,0xBF,0x23,0xE4,0xEE,0x08,0x04,0xC6,0x29,0x13,0xD1,0x69,0xA4,0xAC,
+	0xD1,0xC6,0x93,0x52,0x49,0x8D,0xF4,0x77,0xF2,0x45,0xEE,0x64,0xF6,0x99,0xC1,0x23,0xE1,0x01,0x8B,0xF0,
+	0xC4,0xD8,0x5C,0xDF,0xAC,0x6C,0x58,0x41,0x1A,0x0F,0x9D,0x9C,0x0C,0x0B,0xDA,0xDC,0x0F,0x38,0xEA,0xC5,
+	0x60,0x04,0xFD,0x5A,0x9C,0x74,0x7B,0x62,0xF1,0x69,0xF4,0xAD,0x1F,0xA0,0x43,0x1A,0xE5,0x83,0x00,0x15,
+	0x91,0x00,0x0D,0x5B,0xED,0x4E,0xB6,0xC8,0x53,0x84,0x29,0x54,0x14,0x00,0x18,0x8A,0x00,0x8D,0x40,0x97,
+	0xC3,0x17,0x09,0x84,0x42,0x41,0xA0,0x21,0xB8,0x87,0x58,0xB4,0xB0,0xFB,0x50,0x9B,0x6A,0xE9,0x32,0xD5,
+	0x72,0xE2,0x16,0x06,0x1F,0x22,0x81,0xF3,0xBC,0x5D,0x54,0xFF,0x66,0xA2,0xBD,0x08,0x4D,0x49,0x93,0x63,
+	0x59,0x7A,0xF5,0x25,0xD6,0xFA,0xB5,0x3D,0x55,0x09,0x13,0xED,0x19,0x1D,0x6D,0xCD,0x62,0xF0,0x10,0x19,
+	0x59,0x94,0xA2,0xAB,0x9D,0x09,0xD6,0xC8,0xBA,0xF6,0x4F,0x66,0xDB,0x3A,0x6D,0xFC,0xA6,0x4A,0xB4,0xEA,
+	0x70,0xEE,0xFD,0xA8,0xB8,0x8A,0x68,0xBF,0x91,0x28,0x74,0x83,0xBF,0x4C,0xC7,0x49,0x16,0xB8,0x2C,0x99,
+	0xA7,0x57,0xB0,0x93,0x0E,0x38,0x30,0x9E,0xA3,0x10,0x64,0x07,0xB1,0x41,0xD3,0xEE,0xB6,0x83,0x75,0xEE,
+	0xEA,0x09,0xD3,0x0E,0xFA,0xAE,0xF4,0x3C,0x25,0xED,0x22,0x06,0x01,0xFC,0xB2,0xE4,0x00,0x3C,0x6F,0x00,
+	0x0D,0x68,0x91,0xC0,0x1E,0x0F,0x05,0x2C,0x02,0x81,0xC1,0x00,0x4F,0x72,0x00,0x8D,0xAA,0x7D,0x36,0x6E,
+	0xB4,0x5B,0x5B,0xAD,0xD6,0x6B,0xE3,0xE0,0x7A,0x5D,0x36,0xCB,0x94,0x3C,0x8E,0x28,0x27,0x2C,0x25,0x14,
+	0x91,0x55,0x7D,0x38,0xC2,0x43,0x7C,0xFE,0x23,0x0F,0xBB,0x5A,0x8C,0x52,0x23,0x89,0x56,0x9B,0x35,0x8E,
+	0x15,0x39,0x66,0x3B,0x42,0xDE,0xBC,0xE7,0xEB,0x45,0xAC,0x6A,0x5D,0xD9,0xA6,0xDB,0xCB,0xA3,0xED,0x99,
+	0xCA,0x63,0xF2,0x4A,0xDB,0xAC,0x6F,0x79,0xDE,0x2F,0xDC,0xDD,0x2C,0xC1,0xBB,0x01,0x7B,0x9A,0xB4,0x8F,
+	0x16,0x9A,0xCE,0xD8,0x03,0x46,0x93,0xBB,0xAD,0x8A,0x97,0xF6,0xAA,0x37,0x3B,0xB2,0xA2,0xB1,0xA5,0x67,
+	0xC1,0x7E,0x3D,0xDA,0x65,0x33,0xB1,0x86,0xEC,0xF0,0x76,0xAA,0xC5,0x9B,0x49,0x11,0x2A,0xB7,0x3B,0xDE,
+	0x3D,0x0B,0x94,0xB6,0x2D,0xE4,0x7F,0xA9,0x57,0x44,0x52,0xD0,0x28,0x08,0x00,0x7B,0xD0,0x00,0x0D,0xFE,
+	0x89,0xCC,0xFA,0x76,0xA4,0x17,0xD2,0x9C,0xE8,0x00,0x17,0xB8,0x00,0x8D,0x24,0xE9,0xFC,0x34,0x16,0x15,
+	0x0A,0xDA,0x85,0xED,0x36,0x73,0x9B,0xE6,0x46,0x9B,0x9D,0x5D,0x8C,0x7B,0xB4,0x2F,0x2A,0x65,0xAF,0xF4,
+	0x66,0x1B,0x65,0xE7,0x12,0xBD,0xDC,0xCA,0x6E,0xFF,0x1E,0x5C,0x1D,0xDD,0x73,0xCC,0xBC,0x75,0x5A,0xCB,
+	0xB5,0xB5,0x47,0xD4,0x2E,0xCC,0x15,0xA5,0x5A,0xB2,0xA1,0x2F,0xD0,0x74,0x86,0xFE,0x11,0x9E,0x89,0x5F,
+	0xDF,0x5E,0xE7,0x8F,0xF7,0x78,0x15,0x14,0x09,0x1F,0x7F,0xFE,0x35,0x4F,0x8F,0x0C,0xC8,0x17,0xE1,0x00,
+	0x71,0x2B,0x3F,0x2D,0x95,0x20,0xC5,0x9A,0xE6,0x4D,0x72,0x98,0xB2,0x28,0x3C,0xB5,0x96,0xC3,0x77,0xD4,
+	0x43,0xE1,0x2B,0x05,0xB8,0x3F,0xEC,0xC1,0x9A,0x40,0x4F,0x34,0xDC,0xEF,0xA0,0xE8,0xDB,0xDE,0x45,0xBB,
+	0x6F,0x73,0x73,0xE2,0xC5,0x34,0xD3,0x51,0x7D,0xF2,0x1B,0x1C,0x00,0xAA,0xB8,0x00,0x0D,0xE7,0xFB,0x76,
+	0xBD,0x55,0xA8,0xBC,0xD4,0x6A,0xA4,0x00,0x83,0xF3,0x00,0x8D,0x18,0x04,0x1B,0x42,0xAD,0x33,0x19,0x3A,
+	0x8C,0x46,0xC3,0xE4,0x7C,0xCD,0xDB,0x7F,0x67,0xDD,0x96,0x76,0x35,0xA3,0xB2,0xAF,0xD2,0x5F,0xBB,0xB8,
+	0x49,0xC4,0x24,0x01,0x80,0xFD,0xF3,0x29,0x9F,0x5E,0xBB,0xE0,0x1E,0x50,0x80,0x49,0x4A,0x67,0x43,0x06,
+	0x58,0x54,0x28,0x76,0x1A,0x9D,0xA9,0x0B,0x94,0x42,0xD6,0x00,0xE0,0xE1,0x24,0x9E,0x42,0x5D,0x5D,0x07,
+	0x0A,0xC6,0x54,0x75,0x24,0x75,0x99,0xBF,0xCA,0xC6,0xBC,0x06,0xF2,0xE8,0x37,0x3B,0x10,0x7B,0x86,0x60,
+	0x10,0xD1,0x1E,0x67,0xC3,0x50,0xD3,0x61,0x34,0x78,0x98,0x58,0x7E,0xE2,0x0A,0xAD,0xC1,0x88,0x8D,0x1F,
+	0xBC,0xC0,0x63,0x92,0x71,0x5C,0xD6,0xFB,0xB8,0xB2,0x57,0xD8,0xAD,0xF5,0x9F,0x1B,0x75,0x2B,0x20,0x28,
+	0x97,0xF4,0xBA,0x1B,0xF5,0xEB,0x73,0xBA,0x53,0xDA,0x00,0xA4,0xAD,0x00,0x0D,0x9C,0xC6,0x3D,0xA0,0xDB,
+	0xD3,0xC0,0xE9,0x34,0xD3,0x00,0xE0,0x74,0x00,0x8D,0xA3,0x70,0xB0,0x78,0x30,0x99,0xEA,0x75,0x74,0xBA,
+	0x72,0x3E,0x47,0xAC,0x8C,0x20,0xCE,0xF2,0x54,0x30,0x99,0xAC,0x25,0x9A,0x93,0xD3,0xC9,0x8A,0xFC,0xA0,
+	0xCE,0x23,0x71,0xD8,0x5A,0x0F,0xBE,0xD6,0xEC,0x0C,0x75,0x2A,0x5E,0x1D,0xEB,0x97,0xC4,0x84,0x1D,0x8C,
+	0xF0,0xFB,0x72,0x0E,0x33,0xFC,0x0E,0x92,0x3D,0xD1,0x07,0x6D,0x37,0xF3,0xA5,0xDD,0xD5,0x6F,0xC0,0x86,
+	0x34,0x0B,0xAD,0x66,0x66,0x52,0x19,0x8F,0x6C,0x06,0x06,0xE3,0x81,0xD3,0x20,0x20,0x20,0x1E,0x75,0x43,
+	0x33,0x00,0x3C,0x63,0xB3,0x93,0xCC,0xCC,0x26,0xCA,0x16,0xCC,0x0B,0x50,0x9C,0xC9,0x1F,0xAB,0x00,0x7B,
+	0x01,0xBD,0x79,0x95,0x88,0x6A,0x00,0x91,0x08,0x7A,0x3F,0x63,0x0E,0x7F,0x81,0x53,0x93,0xF9,0x71,0xE0,
+	0xCC,0x5B,0xAE,0x8E,0xDF,0x9F,0x1A,0x15,0x00,0x2C,0xBA,0x00,0x0D,0xB0,0x50,0x20,0xE5,0xF9,0x7E,0x4E,
+	0xBF,0x5F,0xEF,0x00,0x16,0xC6,0x00,0x8D,0xC5,0x6A,0xBD,0x75,0x36,0x9A,0x9A,0x4D,0x26,0x72,0x1D,0x9D,
+	0x3F,0x83,0xC2,0xA4,0xA2,0x63,0x8C,0x7B,0x85,0x09,0xCC,0xA0,0xE2,0x50,0x88,0x2C,0xF4,0x48,0x27,0x77,
+	0x45,0x0F,0xAF,0xD7,0x9E,0x72,0x7B,0xAC,0x78,0x6B,0x06,0x15,0x57,0x0C,0x97,0x5D,0x2D,0xA1,0x89,0x8A,
+	0x26,0x65,0x61,0xB0,0x9B,0x82,0x2A,0x93,0x8A,0x20,0x41,0xB1,0xA1,0x2B,0xFC,0x6B,0xC3,0x94,0xBB,0xD2,
+	0x0B,0x0D,0xCC,0x79,0xB7,0xA4,0xEF,0x08,0x69,0x85,0xB9,0xF8,0xC8,0x9B,0xB3,0xC6,0x58,0x5C,0xEE,0x14,
+	0xA6,0x6F,0xD2,0xDF,0x99,0xF6,0xC9,0x6A,0x4B,0x32,0x2D,0xD0,0xC6,0x9B,0xB4,0x6D,0x73,0x49,0x3A,0x1E,
+	0xDC,0x41,0x6E,0xBB,0xDB,0xD7,0xED,0x61,0xB6,0x1B,0xEB,0x6C,0x6C,0xF8,0xFB,0x3F,0x89,0x4F,0x3C,0xE2,
+	0x47,0xEB,0x53,0x06,0x83,0xF5,0x00,0x20,0xFD,0x00,0x0D,0x45,0x2A,0x41,0xD5,0xCF,0x65,0x55,0xB2,0x32,
+	0xD9,0x00,0x60,0x98,0x00,0x8D,0xF3,0xF1,0x70,0x4C,0x51,0xA9,0x54,0x29,0x2A,0x95,0x44,0x6A,0x6C,0x6A,
+	0xB5,0xC2,0xCD,0x61,0xB1,0x25,0x34,0x63,0xEF,0x4E,0x13,0xCF,0x9A,0x7F,0xE8,0x5E,0x8C,0xD8,0xF2,0x39,
+	0x68,0x97,0xBB,0x2D,0xC1,0xD9,0xDA,0x9C,0x4F,0xDF,0x2B,0x75,0xC3,0x48,0x8E,0xD9,0x47,0xBA,0xB0,0xB2,
+	0x46,0xFE,0xA2,0x08,0xC5,0x4A,0x72,0x0A,0x1E,0x26,0xF7,0x44,0xB8,0x5A,0xD5,0x8A,0x55,0x7B,0x5A,0x79,
+	0xA4,0xA2,0x8F,0xEA,0x49,0xBA,0xB9,0xC5,0xCF,0x0E,0x45,0x9F,0xE2,0xEF,0x43,0xB8,0x5B,0x4E,0xBE,0x34,
+	0xD7,0x67,0x26,0x85,0x14,0xCC,0xA6,0xCA,0xD0,0x99,0x0E,0x72,0xD4,0x29,0x34,0xF1,0x36,0xC2,0xF9,0x63,
+	0x84,0xC7,0x70,0x7A,0xE9,0x5C,0xA4,0x73,0x29,0xAD,0x06,0x94,0x72,0xC6,0xE7,0x62,0xB3,0xD7,0xBA,0x84,
+	0x42,0x91,0x11,0xEF,0x00,0xEA,0x1F,0x00,0x0D,0xA5,0x72,0xB1,0x79,0x37,0x99,0xA8,0x4C,0x26,0x92,0x00,
+	0x21,0x56,0x00,0x8D,0x78,0x54,0xDF,0x6A,0xB9,0xB9,0x5C,0x5C,0x2E,0x04,0x41,0x7C,0xDC,0x01,0xFA,0xA0,
+	0x90,0xB9,0x0A,0x39,0x91,0x42,0x3D,0xFF,0xF2,0x21,0x12,0xAC,0x2C,0xF6,0x06,0xEB,0x0B,0x91,0xA8,0xA7,
+	0xC1,0x6F,0x06,0x47,0xE7,0xB0,0xAB,0xC2,0x21,0xB5,0x3D,0x3E,0x99,0xB3,0xD8,0x58,0x64,0x4D,0xBF,0xC2,
+	0xE7,0x0C,0x4B,0x07,0x15,0xC2,0x63,0xE0,0x7E,0x2C,0x0E,0x6E,0xD1,0x17,0x8B,0xE5,0x42,0xDD,0x20,0x51,
+	0x90,0xA8,0xBB,0xA5,0xCC,0x66,0xE8,0x94,0x8A,0xBB,0xDA,0x6D,0x9B,0xB7,0x58,0x3A,0x67,0xF3,0xFC,0x6D,
+	0x88,0x71,0xAA,0x3F,0x92,0x5A,0x8A,0x68,0x8F,0xB8,0x1F,0x5D,0x7D,0xF6,0xF9,0x32,0x17,0x98,0x63,0xA9,
+	0x3E,0xD2,0xE8,0xF1,0x7D,0x93,0xBB,0xDE,0x96,0xEE,0xD5,0xC8,0xCA,0x05,0xF5,0x92,0x61,0x2D,0x1D,0xF9,
+	0x9B,0x7B,0x00,0x67,0x5F,0x00,0x0D,0x27,0x9B,0x68,0xC1,0xDB,0xEF,0x13,0xF8,0x91,0x7C,0x00,0x86,0x25,
+	0x00,0x8D,0x22,0x19,0x84,0x4C,0x2A,0x14,0x8A,0x8A,0x45,0xA2,0xC3,0x77,0x3F,0x28,0xF5,0x65,0x62,0x51,
+	0xA9,0xDF,0xE5,0x57,0x6A,0x8B,0xA5,0xD5,0x54,0x0E,0x87,0xF3,0x56,0x45,0x4B,0x11,0x41,0x9B,0x73,0xBC,
+	0x3D,0x3D,0x13,0xFF,0x88,0x16,0x4A,0x6A,0x22,0xE1,0x10,0x04,0xC4,0x59,0xEC,0xC5,0x7E,0xE2,0x9A,0x2E,
+	0xD5,0xBC,0xB7,0x07,0x3F,0x5A,0xDC,0xA3,0x7B,0x89,0x40,0x9C,0x65,0x96,0x7F,0x92,0x8B,0x91,0x09,0x95,
+	0x18,0x81,0x79,0x61,0xD5,0xAE,0x73,0x41,0x9E,0x53,0x9C,0x0B,0x72,0x05,0xD8,0xF0,0x32,0xE3,0x11,0x90,
+	0x20,0x00,0xAF,0xE7,0x40,0x96,0x3C,0xFF,0x40,0xBD,0xB8,0xC4,0xDC,0x20,0xB6,0x3A,0x24,0x92,0xED,0xDD,
+	0xB3,0xE8,0x7A,0xF0,0x76,0x1A,0x15,0x52,0x37,0xDF,0x4F,0xDD,0xC4,0xAB,0xA7,0x6D,0xC6,0x9B,0x05,0xA1,
+	0x00,0x56,0xFE,0x00,0x0D,0xF6,0x73,0x31,0x37,0x10,0x7A,0xB8,0x45,0x45,0xE2,0x00,0x92,0x88,0x00,0x8D,
+	0x3B,0xED,0x7E,0x4A,0x57,0xAA,0xFA,0x54,0x7C,0x2A,0xE7,0x48,0x5A,0x47,0x16,0xA8,0xAA,0x97,0xEF,0x8F,
+	0xB8,0x85,0x24,0x49,0x95,0xBD,0xF7,0xFF,0xEA,0x8A,0xE7,0x73,0x31,0x8A,0x4C,0x1B,0xDD,0x18,0x09,0x33,
+	0x1B,0xC3,0x8D,0x80,0x8E,0x9A,0x83,0x17,0x5C,0x43,0x00,0x0E,0xA2,0x3F,0x04,0xA9,0xD3,0x23,0x52,0x4B,
+	0x06,0xC1,0x9A,0xDB,0x30,0x94,0x3E,0x93,0x10,0x97,0xC1,0x60,0x92,0x3F,0x2A,0x21,0xCB,0xEC,0xF3,0x07,
+	0x31,0x95,0x61,0x01,0x31,0xA1,0x39,0x98,0xB8,0x40,0x33,0xD7,0x15,0x3E,0x13,0xC5,0x22,0xF7,0x83,0x4E,
+	0x2F,0x20,0x6D,0x6E,0xB9,0x69,0xF0,0x46,0x87,0x55,0x9E,0xA7,0xF4,0x65,0x06,0xAA,0xA7,0x5B,0x4F,0xB2,
+	0xAD,0x7D,0x0E,0x30,0x69,0xCA,0x25,0xB1,0x3A,0xBD,0xDD,0x64,0xC2,0x51,0xE3,0xB0,0x10,0x34,0x00,0xB2,
+	0x6C,0x00,0x0D,0xC0,0x68,0xA3,0xA4,0x67,0xDD,0xDC,0x6E,0x77,0x7B,0x00,0x98,0x84,0x00,0x8D,0x51,0x20,
+	0x65,0x47,0xA4,0xAC,0x53,0x56,0x2B,0x15,0x68,0xCB,0x85,0x68,0xC3,0x47,0x9F,0x5B,0xB6,0xEA,0x44,0xD7,
+	0x67,0xCC,0x24,0x2E,0x84,0x6A,0xB2,0xED,0x2A,0x99,0xB6,0x6B,0xB6,0x2F,0xDC,0x29,0x89,0x14,0xA5,0x8A,
+	0x6E,0x71,0xF0,0x77,0x07,0x83,0x7E,0xDA,0x40,0x61,0xCE,0x4A,0x18,0xB9,0x2E,0x95,0x2E,0x6A,0x47,0xD1,
+	0x55,0xA4,0xF9,0x18,0x3D,0xA4,0x62,0x3F,0x43,0x91,0x00,0x15,0x49,0xF4,0xAA,0xDF,0xDE,0x8F,0x02,0x7E,
+	0xDF,0x4E,0x06,0xAA,0x47,0xE6,0xAF,0x17,0x39,0x54,0x56,0xE8,0x4D,0xF4,0x03,0x9C,0xA3,0x0C,0xB1,0x1D,
+	0x02,0xFE,0x42,0x81,0xAC,0x7E,0x90,0xD0,0x66,0xF0,0xE6,0xB0,0xAE,0xFC,0xFE,0x1F,0xE3,0xD6,0xEA,0x72,
+	0x2F,0x90,0xDE,0x40,0x2C,0xA6,0xB5,0x0C,0x69,0xC6,0x65,0x75,0xBE,0xBE,0xEE,0xB9,0x00,0x75,0x11,0x00,
+	0x0D,0xBD,0xD6,0xBD,0x2B,0xB1,0x5A,0x3E,0x2D,0x16,0x4B,0x00,0x21,0x9E,0x00,0x8D,0xEF,0x38,0x14,0x9D,
+	0x62,0x30,0x18,0x54,0x8C,0x29,0x0C,0xA4,0x8E,0x87,0xE5,0x0A,0x39,0xD5,0x3A,0xFB,0x1C,0x41,0x27,0x0A,
+	0x32,0xED,0x5A,0x41,0x65,0x21,0x92,0xCE,0x17,0x6C,0xAF,0x97,0x40,0x24,0xBC,0xBE,0xD9,0xC4,0xC0,0xC9,
+	0xA5,0x15,0x83,0xDD,0x3F,0xD3,0xFA,0xB8,0x29,0x59,0x83,0xF3,0xE8,0x62,0x50,0xB9,0xAC,0x86,0x20,0x22,
+	0xC2,0xF1,0x3B,0x23,0x70,0xD9,0xCE,0x43,0x39,0xA9,0xBC,0x44,0xA1,0xF3,0x4A,0xAA,0x05,0x35,0xC0,0x55,
+	0xD1,0x1C,0x1B,0x1F,0x0D,0x13,0xD3,0x8C,0xC5,0xC6,0x87,0x07,0x1B,0x1A,0x63,0x63,0x84,0x7F,0x5F,0xB2,
+	0xAE,0xB2,0xD6,0x47,0xFA,0x45,0xD5,0x66,0xCB,0x29,0xEE,0x8F,0x17,0x23,0xD2,0xF0,0x0C,0xA5,0x97,0x64,
+	0xD7,0xEC,0xA6,0x17,0x89,0x72,0x8E,0x16,0x1D,0xDF,0xB6,0xB6,0x1B,0x1D,0x00,0x06,0xA8,0x00,0x0D,0xE3,
+	0x34,0x92,0x5A,0xA6,0x51,0x1B,0xA8,0x94,0xD4,0x00,0x1C,0x9D,0x00,0x8D,0x20,0x98,0xF2,0x8C,0x4A,0x49,
+	0xA4,0x52,0x51,0xA8,0x31,0x0A,0x30,0x1F,0x94,0x55,0x53,0xBC,0xBB,0xD7,0xAD,0x80,0x9A,0xA4,0x6F,0x66,
+	0x97,0xAD,0xEA,0x5B,0x5A,0xDA,0x16,0x06,0x5A,0x64,0x9C,0x72,0xBA,0x58,0xC7,0x0B,0xE5,0x82,0x6B,0x52,
+	0x14,0xF5,0x55,0x8D,0x33,0xBD,0xCF,0xB2,0x0E,0x0E,0x1D,0x9F,0x22,0x8D,0xD0,0x44,0x12,0xA3,0x59,0xA8,
+	0xBB,0xE9,0x63,0x91,0x1C,0xB7,0x5B,0x6E,0x42,0x78,0xDC,0x53,0x26,0x22,0x62,0x84,0x63,0x4D,0x07,0x16,
+	0xA3,0xA3,0x00,0xC4,0x5E,0x3E,0xA4,0x5E,0x66,0x1F,0x2B,0x06,0xC0,0xDD,0x90,0x4B,0x16,0xCC,0x08,0xC6,
+	0x08,0x17,0x39,0x21,0x60,0x81,0xDC,0xAD,0x18,0xE3,0x95,0x1E,0xB7,0x9A,0x17,0xB1,0xFF,0x2E,0x46,0x37,
+	0x83,0xF3,0x55,0xD8,0x62,0xF8,0xE7,0xCE,0xE5,0x17,0x7F,0x3B,0x00,0x73,0x8A,0x00,0x0D,0x9F,0xC7,0x23,
+	0xE4,0xDC,0xFD,0xD8,0xFE,0xF5,0x3A,0x00,0x38,0x60,0x00,0x8D,0x10,0x80,0xCA,0x10,0x85,0xC3,0x60,0x30,
+	0x17,0x0B,0x9C,0xB6,0xCA,0x4D,0x30,0x31,0x5D,0xE9,0xFD,0xA8,0xA0,0x8D,0xA7,0x96,0xBE,0x92,0x0B,0x94,
+	0x01,0xE2,0x80,0xD3,0x5C,0x0F,0x14,0x6F,0x87,0xD0,0xDB,0xA2,0xDC,0x88,0x62,0x21,0x42,0xAE,0x2C,0x16,
+	0x96,0xDA,0x7F,0x25,0x92,0xFE,0x4D,0x37,0x28,0x29,0x28,0x85,0x70,0x0A,0x83,0x78,0xBE,0x8D,0xA1,0x31,
+	0xA9,0xE8,0x7A,0x14,0x25,0x89,0x77,0xB5,0x8E,0xD6,0x58,0x96,0x68,0x04,0xE0,0xB1,0x02,0x12,0xE8,0xC2,
+	0x79,0x03,0x21,0xC4,0xF8,0x4C,0xD5,0xB6,0xF2,0xA7,0x66,0xEC,0x21,0x81,0xA2,0x9F,0x9D,0x57,0x25,0x75,
+	0xF8,0x10,0x97,0x67,0xBB,0xBD,0x2E,0x7C,0xAB,0x77,0x44,0xDC,0x7D,0x18,0xCC,0x0A,0x40,0x24,0x91,0x70,
+	0x62,0xD0,0x08,0xA6,0xD2,0xC7,0xE1,0xEE,0x83,0x76,0x00,0xAC,0x4E,0x00,0x0D,0x6D,0x3E,0x97,0xBE,0xA5,
+	0x50,0x61,0x2A,0xD3,0x29,0x00,0x39,0xE0,0x00,0x8D,0x00,0x88,0xE2,0x84,0x99,0xCD,0xCD,0xE6,0xE6,0xF2,
+	0x9B,0xD3,0x6B,0xEE,0x05,0x29,0x82,0x3E,0x18,0x9B,0x04,0x9E,0x8F,0x96,0x0B,0xE2,0x06,0xBE,0xE1,0xE0,
+	0x70,0x60,0x44,0x8F,0x1C,0x6F,0xC7,0x41,0xB1,0x78,0x25,0xDC,0xC9,0xC9,0x03,0xEA,0x02,0xBA,0xE2,0x61,
+	0x71,0x20,0xC4,0x4F,0x60,0xD1,0x1B,0x1B,0x8F,0x77,0x95,0x9C,0x28,0xC1,0x17,0xAF,0x6B,0x24,0x34,0x81,
+	0xB4,0xC8,0xD8,0x06,0xA6,0xAB,0xF7,0x3E,0xEB,0x95,0x3A,0xAD,0x19,0x9A,0x4C,0x07,0x6C,0x6E,0x7B,0x5A,
+	0xFF,0x43,0x36,0xFF,0x18,0xB0,0xF1,0xE9,0xFA,0x65,0x21,0x82,0x3A,0x24,0x8A,0x3B,0x0B,0xF1,0xEB,0x5F,
+	0xC9,0xDA,0x17,0xB0,0x7B,0xA6,0xBC,0x44,0xD1,0x32,0x39,0x04,0x63,0x56,0xF4,0x36,0x8F,0x46,0x17,0x98,
+	0x60,0x9F,0xC1,0xCA,0xF8,0x00,0xF2,0x57,0x00,0x8F,0x00,0x00,0x0D,0xD2,0x86,0x4B,0xF0,0xCA,0xF6,0xD2,
+	0x7B,0xF3,0xB9,0x00,0x52,0x15,0x00,0x8D,0x93,0x41,0x2A,0xE0,0x56,0xAA,0x80,0xC0,0xC0,0x60,0x15,0xE4,
+	0x2C,0x92,0xC9,0x1C,0x7E,0x6E,0x0A,0xAE,0x04,0x69,0x4B,0xF7,0x2A,0xF3,0x14,0x1A,0xCD,0xE7,0xEA,0xE4,
+	0x3A,0x2A,0xE1,0x3E,0x07,0xC5,0xCC,0x38,0x9F,0x19,0x8E,0xAB,0x27,0xC2,0x48,0xF1,0xF4,0xD2,0x63,0xA3,
+	0xB6,0x41,0xCA,0x25,0x22,0xD1,0x29,0x7B,0xD4,0x64,0xE1,0xB1,0x89,0x93,0x47,0xDD,0x31,0x01,0x93,0x5E,
+	0xC5,0xF7,0x92,0xF7,0x6A,0x37,0x4D,0xAC,0x23,0x02,0xE6,0xC0,0x2E,0x85,0x47,0x52,0xDF,0x6F,0x61,0xF5,
+	0x71,0x89,0x64,0xF9,0x8E,0x96,0x1A,0xD0,0xE8,0xB1,0x19,0xC1,0x06,0x37,0xDB,0x49,0x74,0xFE,0x3C,0x6B,
+	0x04,0xBA,0xD6,0x12,0xC3,0x52,0x9F,0xE7,0xF3,0x01,0x49,0xC8,0x01,0x85,0x87,0x07,0xE2,0x6B,0xF1,0xEB,
+	0x0C,0x3B,0x9A,0xE4,0x4E,0x97,0x00,0x6A,0x8C,0x00,0x0D,0xD8,0x6E,0x3F,0xF7,0xF0,0xFA,0x4E,0x7C,0x7E,
+	0x7F,0x00,0x56,0x17,0x00,0x8D,0x25,0x22,0x19,0x79,0x64,0xB3,0xD9,0x6C,0xB6,0x4A,0x0A,0x1A,0xED,0x6D,
+	0x83,0xF3,0xA2,0xE1,0x87,0xD6,0x8E,0x32,0xD3,0xC4,0x6F,0x3B,0x2E,0x40,0x03,0x7A,0x4E,0xE6,0x10,0xDA,
+	0xBE,0x35,0x5B,0x41,0x52,0xFA,0xDE,0x27,0x80,0x16,0xA7,0xD1,0x9B,0x25,0x7A,0xBB,0x37,0x05,0x9C,0xD8,
+	0xC4,0x92,0x3A,0xDC,0xC4,0x02,0x79,0x47,0x24,0xA1,0x0A,0x89,0xBF,0x46,0xC9,0xC9,0xE6,0x98,0x18,0x2D,
+	0x06,0xD8,0xFF,0xCD,0xFE,0x82,0x3F,0xAD,0x0C,0x6B,0x61,0x23,0xE4,0x51,0xC8,0xE7,0x45,0x6B,0x9E,0x5F,
+	0xE9,0x6D,0x36,0xF6,0xEA,0x3A,0xBF,0x5C,0x1D,0xEF,0x77,0x14,0xDC,0x92,0x27,0x59,0x52,0x8E,0xD1,0x4B,
+	0xB5,0x71,0x93,0xFB,0x0A,0xBF,0x3C,0x9B,0x98,0xC6,0x46,0xB4,0x89,0x58,0xA8,0xB4,0xAA,0xB3,0x56,0x1D,
+	0xBC,0x26,0x29,0x13,0x00,0x07,0x7C,0x00,0x0D,0xBC,0x37,0xBC,0x2B,0x31,0x9A,0xAC,0x4D,0x4C,0xE6,0x00,
+	0x86,0x9E,0x00,0x8D,0xCC,0x6E,0xBF,0x2A,0xDA,0x6C,0x36,0x86,0x43,0xC3,0xA1,0x30,0xAE,0xEE,0xEB,0x83,
+	0x05,0x34,0x5D,0x72,0x83,0xA1,0x42,0x32,0xD4,0xD7,0x6F,0x23,0x33,0x4B,0x3D,0x4C,0x82,0x88,0x90,0x24,
+	0x45,0xA0,0x13,0x84,0x0E,0x87,0x00,0x83,0x57,0x81,0x00,0x32,0xDC,0x9F,0x6D,0x38,0xA7,0xE8,0x90,0xB0,
+	0x06,0x96,0x1E,0x92,0x04,0x10,0xAF,0x5A,0x82,0xF4,0x3C,0x23,0xDB,0xC8,0x7A,0x3D,0x08,0x90,0x19,0x65,
+	0xD3,0x90,0xB9,0x2E,0x36,0x4E,0x16,0x7E,0xFE,0xAA,0x05,0x9B,0x0E,0x67,0x43,0xB2,0x22,0x17,0x48,0x19,
+	0x58,0x45,0x91,0x5D,0x1C,0x9D,0x50,0x71,0xA6,0xB3,0x20,0xBA,0x3F,0x94,0x40,0xAA,0x24,0x01,0xF9,0x49,
+	0x22,0xC4,0x12,0x81,0x78,0x04,0x0C,0x97,0x01,0x11,0x8D,0x38,0x12,0xFA,0xAE,0xB3,0xA3,0xC0,0x5F,0x2F,
+	0x99,0xBC,0x00,0x33,0x5E,0x00,0x0D,0x8E,0x59,0xA4,0x6C,0xBD,0xB8,0xEA,0x5C,0x6E,0x2E,0x00,0x3E,0xE1,
+	0x00,0x8D,0xDD,0x66,0x0D,0x73,0x6E,0xB6,0xDB,0xDB,0xED,0x76,0xBF,0x8B,0x3D,0x8F,0x5E,0x09,0x88,0x77,
+	0xD2,0x15,0x53,0x12,0x70,0x5F,0xCF,0x48,0x9B,0xEA,0xF1,0xBA,0xEB,0xAC,0xE5,0x38,0x8E,0x6C,0x86,0x54,
+	0xA6,0x7C,0xB8,0xB8,0x6A,0x2C,0x09,0x64,0x96,0xBA,0x4C,0xD6,0x13,0xAB,0x9C,0xA4,0x41,0x32,0xE1,0x2F,
+	0x99,0x05,0x48,0x89,0x57,0x65,0x1A,0xDB,0x96,0xB3,0x02,0xD0,0x0A,0x69,0x98,0xD7,0x13,0x2F,0x51,0x54,
+	0xCA,0x95,0x0E,0x27,0x85,0x06,0x29,0x76,0x8F,0x6C,0x5E,0xFB,0x39,0xC5,0x81,0x6F,0xDC,0x5A,0x77,0xB4,
+	0xC4,0x16,0x8B,0x59,0x60,0xA1,0x38,0xAE,0x0D,0x56,0x94,0x02,0xC2,0xCD,0x69,0xA5,0x3E,0x03,0xA3,0x6E,
+	0x0D,0x45,0xF2,0x43,0x08,0xD3,0xF4,0xFB,0x56,0xB3,0x4A,0xBA,0xD5,0x85,0x75,0x9C,0x3C,0x2F,0xB0,0x54,
+	0x00,0x97,0xE5,0x00,0x0D,0x00,0xD6,0x63,0xC4,0xE9,0xF5,0xC1,0x7B,0xBD,0x9E,0x00,0x9E,0xE4,0x00,0x8D,
+	0xB4,0xD2,0x61,0xA9,0x58,0x2D,0x2D,0x96,0xCB,0xE5,0x30,0xB2,0x99,0x4F,0x84,0x88,0x45,0x52,0xD9,0x58,
+	0xEF,0x63,0xF5,0x79,0xFA,0x6C,0x9C,0x38,0x1F,0xBE,0xCF,0x13,0x4B,0xB1,0x38,0x8D,0xBF,0x8A,0xAA,0x26,
+	0x2B,0x80,0xDD,0xF4,0x7A,0x9F,0x90,0x45,0x89,0x0D,0x5D,0x86,0x86,0x22,0x33,0x5F,0x5C,0xCE,0x39,0x1B,
+	0xC5,0xF5,0xF3,0x1A,0x6F,0xD1,0xEF,0x3F,0x61,0xCC,0xCE,0xC7,0x8B,0x53,0x44,0x03,0x07,0x1C,0xCF,0x99,
+	0x3C,0xCC,0x21,0xC3,0xA7,0xCA,0xD9,0x3E,0x9C,0x46,0x4B,0x25,0x7D,0x12,0x05,0xFD,0x1C,0x25,0xC2,0x71,
+	0x9F,0xCE,0xFF,0xEC,0x4D,0x52,0x55,0x3B,0x56,0x52,0x34,0x85,0x7B,0xD5,0x56,0x1B,0xB3,0xDE,0x83,0x6B,
+	0xC9,0xE5,0x87,0xBE,0x4C,0xF8,0x70,0xC7,0x8B,0x39,0x4C,0xF9,0x4B,0x2D,0xAC,0x59,0x57,0x38,0x00,0xEF,
+	0xB2,0x00,0x0D,0xC1,0xE8,0x83,0x34,0x91,0x95,0x7D,0xA5,0x12,0xD2,0x00,0xAF,0x8B,0x00,0x8D,0x62,0xF4,
+	0xD2,0x9C,0xB3,0xD8,0xD8,0xEC,0xD1,0xE8,0x8E,0xB3,0xD0,0xF9,0x8C,0xB3,0x47,0x3A,0xB7,0x2D,0x95,0x82,
+	0xC1,0x90,0xD2,0x19,0xD9,0xFD,0x55,0xB1,0xCB,0x8D,0x95,0x37,0xF8,0x48,0xF4,0xC9,0x86,0x42,0xC4,0x51,
+	0x68,0xC0,0xCE,0x58,0xCC,0x5A,0x06,0xE2,0xE2,0x13,0x01,0xF8,0x1F,0xA1,0x09,0xB0,0xFE,0x7E,0x7F,0xEC,
+	0x5F,0x58,0xAF,0xD6,0xB7,0x2C,0x25,0xF5,0x8A,0xD4,0x20,0xA5,0x41,0xB1,0x88,0x9B,0xE5,0xF8,0xCB,0x4E,
+	0x3F,0x6B,0x0F,0xA6,0xB3,0x48,0x8F,0xB1,0x16,0xBA,0x83,0xCE,0x07,0x7F,0xC8,0x19,0xE9,0x56,0xFF,0x4F,
+	0x02,0x80,0x91,0xFE,0xD4,0xF3,0xC8,0x6F,0xC7,0xE0,0x36,0xB2,0x18,0x1D,0x20,0xD5,0xF3,0x91,0x71,0x37,
+	0x2B,0x03,0x65,0xCF,0xA3,0x7E,0xEB,0x2F,0x88,0x31,0x55,0x56,0xCC,0x07,0x02,0x48,0x00,0x3E,0x84,0x00,
+	0x0D,0xBE,0x7D,0x36,0x85,0xC9,0xBC,0x5E,0xDE,0xEF,0x8C,0x00,0xC0,0x89,0x00,0x8D,0x1D,0x5B,0xED,0x83,
+	0x9E,0xCE,0xF9,0xFC,0xFD,0x7E,0xFF,0x82,0xEE,0x7C,0x92,0x53,0x48,0xBF,0x5F,0x2E,0x46,0xAA,0xC0,0xF9,
+	0xE1,0xEA,0xAB,0x84,0x74,0x03,0xC3,0xD7,0xF3,0xA0,0x24,0xA7,0x9C,0xC5,0xCC,0x74,0x4A,0xCB,0xB4,0x24,
+	0xBD,0xC4,0xE3,0xF3,0xA9,0x45,0xF5,0x63,0xF3,0x6F,0x2F,0x3B,0x19,0x3E,0x8A,0x8B,0x44,0xB9,0x59,0x2D,
+	0xBD,0x57,0x04,0x19,0x8D,0xDD,0x1C,0x1F,0xFE,0xE6,0xB1,0xCE,0xCA,0xEB,0xC0,0x86,0xBB,0xCC,0xCE,0x10,
+	0x17,0xA8,0xCC,0x96,0x7D,0x47,0x5B,0xDE,0x10,0xF9,0x2B,0x7F,0xB0,0xCE,0x8E,0x09,0xCE,0x56,0x55,0x0C,
+	0xC9,0xA8,0xE3,0xC3,0x1A,0x04,0x98,0xCB,0x31,0xE1,0xD3,0xF6,0x37,0xEC,0x86,0x04,0x48,0x0D,0xA1,0xD3,
+	0x82,0xD3,0x3E,0x0D,0x8F,0xC0,0x7C,0xE0,0xF8,0x2A,0xC1,0xBC,0x4D,0x3C,0x00,0x63,0xFC,0x00,0x0D,0x81,
+	0xD6,0xA3,0x24,0x99,0xBE,0x76,0xDF,0xAF,0x13,0x00,0xF4,0x07,0x00,0x8D,0xC3,0xE9,0xFF,0xB4,0x56,0x0A,
+	0xAA,0x55,0x02,0x01,0x76,0xA0,0x55,0x89,0x4C,0x10,0xA5,0x3A,0x2B,0x42,0x12,0x91,0x93,0x65,0xCF,0xD3,
+	0x9C,0x4F,0xCF,0x4D,0x11,0xB0,0x7A,0x27,0x11,0x06,0xF4,0x5C,0xFF,0x69,0xF9,0xD9,0x3F,0x0F,0x17,0xFF,
+	0x0A,0x83,0xA6,0x51,0x81,0x3C,0x52,0x03,0xA0,0x98,0x50,0x83,0x4C,0xC7,0xE3,0x37,0xC1,0xF8,0x15,0x0D,
+	0x4D,0x29,0xD4,0xFA,0xF3,0x71,0x66,0x4F,0x3B,0xBD,0x5B,0x6E,0x2D,0xB7,0xB4,0x40,0x5C,0x35,0xD5,0xC3,
+	0xB2,0xE4,0xDA,0xC7,0x5E,0x99,0xAA,0xBB,0xCD,0x4D,0xF6,0x4A,0x25,0x83,0xE2,0x6B,0x77,0x5F,0xF0,0x49,
+	0xD2,0x7F,0x88,0xF7,0x7A,0x04,0x8E,0x41,0x16,0xDF,0x99,0xFC,0xCA,0x03,0x12,0x55,0xAC,0x94,0x94,0x64,
+	0x6A,0x75,0x99,0x2E,0x2D,0xB1,0x76,0xA4,0xF3,0x29,0x73,0x66,0x00,0xFE,0x14,0x00,0x0D,0x29,0xDD,0x66,
+	0x4F,0x2C,0x94,0xAD,0x4A,0x49,0xE4,0x00,0x63,0x5D,0x00,0x8D,0x38,0xEF,0xFF,0x0A,0x89,0xBF,0xC4,0xDF,
+	0xE2,0xF1,0xD8,0x63,0x61,0x73,0x5D,0x1B,0x4B,0x4C,0xA6,0xDC,0x8A,0x47,0xA1,0xB6,0x28,0x98,0xB5,0x8E,
+	0x74,0xB8,0x14,0xCF,0x95,0xCC,0x1B,0x24,0xF1,0x6B,0xB3,0xCE,0x5A,0x1C,0x80,0x28,0x91,0x21,0x9A,0x5A,
+	0x53,0xFF,0x2F,0xD9,0xEB,0x4B,0x63,0x6D,0xAF,0xE2,0xCC,0x8A,0xA6,0x06,0x54,0xE2,0xD6,0x58,0x08,0x9E,
+	0x82,0x5A,0xD8,0xC9,0x21,0x93,0x3B,0x34,0x2C,0x2E,0xAF,0xB6,0xE5,0x9F,0x85,0x57,0x5E,0xA2,0xB4,0xBD,
+	0xD2,0xBF,0x58,0xA8,0x25,0x95,0x69,0x61,0xB2,0xA5,0x02,0x1F,0xA0,0x48,0xF0,0x4A,0xB3,0x19,0xE8,0x63,
+	0x8E,0x3E,0x7A,0xC2,0xB5,0x68,0xD3,0x12,0x98,0x65,0x11,0x19,0x0E,0x18,0x3E,0x31,0xED,0x50,0x9D,0x78,
+	0x3C,0xB0,0xE3,0x2F,0x09,0x3B,0xC3,0x56,0x4B,0x7A,0x00,0x1E,0xF7,0x00,0x0D,0xDC,0xE7,0x7B,0xB3,0xD2,
+	0x56,0x12,0xAA,0x15,0x4A,0x00,0x33,0x11,0x00,0x8D,0xEF,0x34,0x94,0xDA,0xE1,0x10,0x08,0x84,0x0A,0x05,
+	0xB3,0x45,0x76,0xD1,0xCF,0x87,0x1F,0x23,0x38,0xE2,0xB2,0x7A,0x08,0x58,0x74,0x0A,0x03,0x55,0x36,0xC8,
+	0xFD,0x8E,0xE6,0xF2,0x6C,0x2E,0x26,0x48,0x93,0xE8,0x24,0x96,0xEB,0x94,0xE9,0xE1,0xF2,0x6A,0xD5,0x4B,
+	0xF2,0xFE,0x68,0xD3,0x3D,0x37,0x9C,0x59,0x9F,0xC7,0xD1,0x40,0xFE,0x0B,0xF6,0xBA,0x6A,0x32,0x78,0xDE,
+	0x2C,0x85,0x8D,0xE5,0x48,0x02,0xAD,0xC6,0x54,0x8E,0xA0,0x85,0x8D,0x9B,0xBD,0x10,0x48,0x7F,0x0C,0x22,
+	0xD1,0x4F,0xB4,0xE7,0x3D,0xA9,0x81,0x8E,0xA4,0x9C,0x9D,0x94,0x89,0x12,0xA4,0x57,0xE8,0xE3,0xE7,0x8B,
+	0x3C,0x55,0xD7,0xAF,0x9E,0x87,0x67,0x23,0x33,0x5F,0x56,0x4C,0xAC,0xF4,0xE1,0x1E,0x72,0x35,0x97,0x97,
+	0xCA,0x7E,0xC2,0xC5,0xBF,0x73,0x42,0xC6,0x00,0xD0,0xED,0x00,0x0D,0x4E,0xAC,0xC4,0x96,0x8C,0xC4,0x58,
+	0x31,0x98,0x0C,0x00,0xD6,0x07,0x00,0x8D,0x4F,0x2F,0x45,0xD7,0xCA,0x64,0x64,0xB2,0x59,0xD8,0x39,0x76,
+	0x7F,0xC8,0xDF,0x91,0x31,0x08,0x15,0xA6,0x70,0xB1,0x91,0x56,0xB8,0xD7,0x9A,0x18,0xD8,0xF5,0x53,0x3A,
+	0xC7,0xDC,0x42,0xBE,0xF1,0x1F,0xDA,0xE3,0xD9,0x7F,0x53,0xD3,0x47,0xEC,0x61,0xFC,0xD7,0x83,0xEC,0x51,
+	0x4A,0x8A,0x5B,0x0D,0x8B,0xDB,0x40,0x3B,0x04,0x91,0xFF,0x11,0x0D,0xF1,0xCF,0x5A,0xF8,0x41,0xF3,0xE5,
+	0xD2,0x89,0xB1,0x8D,0x6E,0x15,0x60,0x8D,0x5D,0x7E,0xD6,0x51,0xB9,0x69,0x29,0x75,0x15,0xCB,0xB5,0x85,
+	0x0C,0x6B,0x48,0xF0,0x0A,0xAD,0x7D,0x84,0xF4,0xBC,0x39,0x62,0x17,0xD5,0x76,0x73,0xF2,0xB1,0xCA,0x59,
+	0x10,0x39,0x2C,0x56,0x8A,0x57,0x58,0xA6,0x7F,0x02,0xCB,0x79,0x4D,0xE6,0xEA,0x16,0xB4,0x38,0xF4,0x7A,
+	0x6D,0x9D,0x5D,0x55,0x28,0x3F,0x00,0x72,0x0E,0x00,0x0D,0x85,0x52,0x21,0xE9,0x7F,0x99,0x87,0xCC,0x26,
+	0xC9,0x00,0xC5,0xBF,0x00,0x8D,0xF8,0xF9,0x9F,0xBC,0x52,0x51,0x28,0x28,0x14,0x89,0xE4,0x0B,0x73,0xDF,
+	0xE5,0x43,0x30,0x1F,0xB8,0xB0,0x5A,0x36,0x7C,0xCC,0xB5,0xCB,0x2D,0xD0,0xD9,0x9B,0xEB,0xFA,0x7A,0x75,
+	0x3D,0x32,0xAE,0xC0,0xF6,0x37,0x82,0x72,0x9D,0x63,0x72,0x3A,0xDE,0x95,0x29,0xE2,0x64,0xBC,0x4D,0xAB,
+	0xBD,0xC9,0xD6,0x64,0xA4,0xAA,0x22,0x6C,0x9B,0xEB,0xC5,0x50,0xC1,0x0E,0x11,0xA1,0xC0,0xFA,0x3F,0xE9,
+	0x40,0x0D,0x14,0xCF,0x20,0xF4,0xAF,0x8E,0x09,0x6C,0xC2,0xC7,0xF7,0xF6,0xD2,0x0F,0x3D,0x25,0x6E,0xDF,
+	0x0B,0xC0,0xF2,0x40,0x2F,0xE6,0x32,0xF9,0x52,0x3A,0x84,0x72,0x59,0x8C,0x33,0x05,0xA4,0xE9,0xA1,0x31,
+	0x50,0xEE,0xE0,0x8C,0xA2,0xFA,0xDD,0x6D,0xE9,0x81,0xF4,0xF5,0xF9,0x73,0x68,0x15,0x0B,0x81,0xDB,0xEF,
+	0x98,0xEB,0x44,0x7B,0x00,0x02,0xE0,0x00,0x0D,0x27,0x6C,0xF0,0x0D,0x8D,0x8A,0xFE,0xCA,0xE5,0xA5,0x00,
+	0x51,0x04,0x00,0x8D,0x98,0x4F,0xAF,0x22,0x3F,0x9E,0x4E,0xA7,0xA7,0x53,0xD2,0x29,0xF4,0x94,0x5F,0xAB,
+	0xB5,0x8F,0x67,0x6E,0x56,0xEE,0xC6,0x2E,0xF6,0xCF,0x06,0x3F,0xC6,0xC7,0xD0,0x44,0x60,0x64,0xFC,0x6F,
+	0x72,0x2A,0x69,0x7A,0x0D,0x80,0x42,0x2F,0x88,0x67,0x5A,0xC1,0xF9,0x11,0x08,0x24,0x43,0x52,0x49,0xC4,
+	0x98,0x2B,0xE9,0x76,0xE3,0x64,0x7A,0x6C,0x05,0x33,0xFA,0x1E,0xAF,0x69,0x47,0x4B,0xF7,0x3A,0xAA,0x7A,
+	0xEF,0x8A,0x55,0x09,0x2B,0xED,0x5D,0x9A,0x71,0x87,0x43,0x43,0xD4,0x64,0x30,0xC8,0xFC,0x5C,0x86,0xE2,
+	0x67,0x53,0x25,0x39,0x62,0xA2,0x31,0xE6,0xFD,0xCF,0x4B,0x12,0xE0,0xB1,0xF0,0x15,0x8E,0x69,0x54,0xF6,
+	0xEA,0x13,0xA0,0x31,0xF4,0x08,0xFB,0x6D,0x26,0x19,0x1B,0x7D,0x47,0xC7,0x24,0x92,0x96,0xA7,0xD1,0x75,
+	0xE3,0x53,0x00,0xE4,0xF5,0x00,0x0D,0xD2,0x61,0x0D,0x73,0xB2,0x33,0x60,0x19,0xCC,0x5C,0x00,0x67,0x70,
+	0x00,0x8D,0x0C,0x30,0x90,0x4E,0xA0,0xA8,0x51,0xD4,0x6A,0x0A,0x34,0xE6,0x6B,0x72,0x81,0xCC,0x61,0xD0,
+	0x39,0x9B,0xE5,0x8F,0x4F,0x7F,0xAF,0xDA,0x13,0x87,0xEE,0xF5,0xCD,0x9E,0x6F,0xD5,0x3D,0x99,0x0F,0x4C,
+	0x89,0x6B,0x33,0xB1,0xC8,0xB9,0x95,0x7F,0xCC,0xDC,0xF1,0x9A,0xFF,0x85,0xCB,0x6D,0xF3,0xEB,0x61,0x3B,
+	0x1F,0xEA,0xCB,0xE2,0xCF,0x83,0xB9,0x5B,0xDF,0x2C,0xE4,0x16,0xFE,0x78,0xF9,0x9D,0xFE,0x90,0xD6,0x00,
+	0x17,0xB5,0xB3,0x5C,0x2E,0x78,0x0F,0x43,0x5F,0x76,0x3D,0xF6,0x72,0xC4,0x02,0x2A,0x8C,0x77,0x9C,0x1D,
+	0xAE,0xC3,0xE6,0x77,0x97,0xBE,0xFF,0x49,0x2C,0xCE,0x19,0x22,0x1F,0x67,0xB0,0xC2,0x02,0x0F,0x86,0x77,
+	0x38,0x9D,0x78,0xAA,0xAE,0xAB,0xAE,0x37,0xD1,0xEF,0xF5,0xCF,0xCB,0xE2,0x9F,0x21,0x4B,0x86,0x01,0xA6,
+	0x00,0x00,0x11,0x00,0x0D,0xC3,0x0E,0x02,0xC7,0x6E,0xB5,0x8A,0x5B,0x5A,0x6D,0x00,0x08,0xF4,0x00,0x8D,
+	0xFC,0x2B,0x9D,0xBB,0xD1,0xD2,0xE9,0x6E,0xB7,0xDB,0x5C,0x00,0x96,0x52,0xD7,0xF4,0xA1,0x11,0x85,0x3F,
+	0x5D,0xB0,0xB6,0x07,0x3E,0x06,0x99,0x18,0x3C,0x1F,0x17,0x6A,0xDA,0x53,0xE6,0x56,0xA6,0x42,0x6C,0xEF,
+	0xCA,0x8B,0x7C,0x43,0x42,0x57,0xB1,0xCF,0x75,0x99,0xB6,0xCA,0x24,0xAB,0xD6,0x58,0xEE,0x79,0x60,0xBE,
+	0x15,0x75,0x4E,0xDF,0xD5,0x10,0xFA,0x56,0x7A,0x29,0xAD,0xB1,0xD7,0xD9,0xE7,0x97,0x06,0x1C,0x97,0x79,
+	0xBB,0x4D,0xC8,0x42,0x7D,0x8D,0xE0,0x60,0x74,0x8E,0x1E,0x2B,0xD4,0xC1,0xFD,0x96,0x8F,0x3A,0xD2,0x4F,
+	0x76,0x08,0x47,0xA2,0x15,0xBE,0xE1,0x34,0xEB,0xCC,0x69,0x17,0x14,0x21,0x84,0x56,0x86,0x60,0x7A,0x55,
+	0xB8,0xFF,0xD8,0x47,0x78,0x63,0x58,0x4C,0x56,0xC5,0x88,0xE3,0x8F,0x61,0xE9,0x17,0x9E,0xD1,0x00,0xC2,
+	0xA1,0x00,0x0D,0xCA,0xED,0x86,0x36,0x10,0x14,0xB6,0x09,0xC4,0x14,0x00,0xDF,0x31,0x00,0x8D,0x08,0x14,
+	0x82,0x34,0x96,0x95,0x4A,0xEB,0x75,0x3A,0x8A,0xC8,0x5C,0x0D,0x22,0xF4,0xB3,0x25,0xA2,0x7D,0xD5,0x69,
+	0xCE,0x59,0x1E,0xD3,0xE6,0x53,0x8B,0xB4,0xFC,0xA2,0x5D,0x85,0xC5,0x8A,0xCD,0x0B,0xF3,0xDF,0x75,0x09,
+	0x48,0xA2,0x15,0x64,0x19,0x59,0xD7,0x94,0xDE,0x4F,0x96,0xF0,0xB8,0x2A,0xF7,0xCA,0x66,0xFF,0x29,0x1C,
+	0x7D,0x20,0x17,0xCE,0xEF,0x16,0xE2,0x59,0x7D,0x0D,0xCB,0xA0,0x14,0xBE,0x99,0x30,0x5A,0xF1,0xC4,0xFD,
+	0x8C,0x29,0xEC,0x72,0x8F,0x6D,0x52,0x41,0xA8,0x51,0x41,0xF5,0xAB,0x1C,0x89,0x28,0x5C,0xB5,0x5D,0x3E,
+	0xDE,0x6F,0x7A,0xE5,0x31,0x14,0x44,0x2E,0xBB,0xF9,0x7B,0xD4,0xCD,0x1B,0xFF,0xDE,0xBE,0x09,0x03,0x10,
+	0x40,0x67,0x34,0xF2,0xE9,0x09,0x61,0xD6,0xB9,0xEF,0x70,0x24,0xB1,0xFC,0xDB,0xC6,0x00,0xB6,0xDE,0x00,
+	0x0D,0x1E,0x07,0x6C,0xC3,0xD9,0xEE,0xD3,0xF7,0xF7,0xBB,0x00,0x76,0x3F,0x00,0x8D,0x97,0x40,0xA8,0x60,
+	0x3C,0x9F,0x9F,0x4F,0xA7,0x53,0x97,0xB9,0x4E,0x8B,0xA0,0xC4,0xE8,0xE8,0x04,0x20,0x8E,0x3E,0x68,0x37,
+	0x3E,0x7E,0x11,0x59,0x60,0xD7,0x7F,0x2B,0x5C,0x05,0x72,0xB8,0xE1,0x7D,0x0E,0x8E,0x84,0x23,0xE6,0xCF,
+	0x56,0xF8,0x3A,0x7C,0xCC,0x58,0xBE,0xD2,0x5E,0x4B,0x51,0xB4,0x7D,0xD3,0x66,0x08,0x74,0x68,0x98,0xB9,
+	0x3E,0xC8,0x3F,0x9B,0x7F,0x28,0xB9,0x7F,0x34,0x5A,0x5F,0x04,0xFD,0x96,0x8E,0x3A,0xB0,0xCF,0x50,0x01,
+	0xD4,0xA6,0xEC,0x45,0x0F,0x4E,0x3A,0xF2,0x97,0x58,0xFC,0x71,0x65,0x11,0x58,0xC7,0xF7,0xEF,0xDB,0x67,
+	0x43,0x20,0x50,0x31,0xA8,0x2B,0xD6,0x89,0xE4,0x9A,0x59,0xED,0x3D,0x80,0x09,0x50,0x83,0x2D,0xC0,0x88,
+	0x0E,0x01,0xA7,0x54,0x2B,0x81,0x80,0x24,0x86,0xC6,0x58,0xE2,0x0B,0x17,0x00,0x96,0x3C,0x00,0x0D,0xF3,
+	0x21,0x1B,0xD0,0x62,0xB3,0xE5,0x6C,0xEC,0xB6,0x00,0x85,0x52,0x00,0x8D,0x90,0x40,0x2B,0xE0,0xFD,0x7F,
+	0xBF,0xBF,0xDF,0xEF,0x2F,0x98,0x5A,0x03,0xF4,0xE4,0x26,0x87,0x4A,0x52,0x79,0x4C,0xE6,0x35,0xEB,0x15,
+	0xE5,0x1A,0x73,0xE9,0x14,0x3A,0x4E,0xA0,0xCF,0xEA,0x46,0x43,0xA1,0x31,0x66,0xE4,0x92,0xFC,0x0B,0x06,
+	0x86,0xF4,0x32,0x6B,0xC5,0x25,0xF3,0xF3,0x24,0xB2,0x8D,0xDB,0x77,0x12,0x5E,0x83,0xB5,0x54,0x9F,0x75,
+	0x64,0xE5,0xCB,0x54,0x74,0x4A,0x59,0x5F,0x76,0x39,0xB8,0xCC,0xBD,0xA2,0xA8,0x64,0xD6,0x41,0x4B,0xB9,
+	0x59,0x80,0xB1,0x7F,0xBD,0xF4,0xEA,0x1F,0x74,0x5F,0x00,0x81,0xF2,0xB1,0x50,0x8D,0x94,0x2E,0x49,0x9F,
+	0x24,0x47,0xD2,0xAC,0x80,0x0B,0x2C,0x85,0x10,0xD1,0xD8,0xE7,0x16,0xF9,0x03,0x1D,0xFC,0x29,0xC5,0x6B,
+	0x9D,0x54,0x69,0xB6,0xBB,0x49,0xBF,0xF1,0xC7,0x2C,0x6C,0x56,0x00,0xA0,0xB4,0x00,0x0D,0x30,0x10,0x7B,
+	0x48,0x2F,0x15,0xB4,0x45,0xA2,0xE2,0x00,0x77,0x6E,0x00,0x8D,0x3B,0x55,0xA2,0x6A,0x39,0x39,0x9C,0x9C,
+	0x4E,0x02,0xA6,0x81,0x52,0xC0,0xB7,0x2C,0xBE,0x10,0x8B,0x54,0x81,0x4F,0x91,0x78,0x56,0xCB,0x3B,0x75,
+	0x98,0x5F,0xE0,0x40,0x55,0x9D,0xF0,0x76,0xAD,0x4C,0x46,0xCA,0x24,0x01,0x60,0x80,0x42,0x06,0xF9,0xE8,
+	0xF2,0xE5,0x82,0x22,0x80,0xCF,0xB0,0x65,0xA8,0x76,0x1E,0x12,0x5C,0x3D,0x16,0x77,0x17,0x60,0xF2,0x9A,
+	0x08,0xDF,0x9D,0xB8,0x1D,0x83,0xBA,0x8C,0x36,0xDE,0x61,0x74,0x36,0x2F,0x02,0x7F,0x80,0xA6,0x18,0xBB,
+	0xAA,0x5D,0x7F,0xD9,0xB7,0x20,0x35,0x3D,0xF5,0x45,0xA6,0x64,0x4F,0x68,0xD1,0xEE,0x24,0xAC,0xD5,0x3C,
+	0xEC,0x3C,0x5C,0x95,0xA7,0xBB,0x5F,0x00,0xD1,0x1C,0x78,0x69,0xF4,0x40,0xDF,0x30,0xFB,0x16,0xF3,0xEA,
+	0xD8,0x23,0xC1,0x29,0x4B,0xF5,0x74,0xDD,0x0D,0x72,0x00,0xD0,0xC6,0x00,0x0D,0x8E,0xCF,0xA7,0x26,0xCC,
+	0x64,0x5D,0x31,0xB2,0x19,0x00,0x65,0xE4,0x00,0x8D,0x6B,0x11,0xD6,0x1E,0xA8,0x00,0x00,0x2A,0x95,0x15,
+	0x48,0x45,0xC7,0x7C,0x53,0x49,0x55,0x55,0x55,0x29,0xAB,0x56,0x1B,0xF4,0xF5,0x79,0x01,0x7C,0x6D,0xBF,
+	0x6A,0xA9,0xB6,0xBB,0x80,0x2F,0x16,0xF6,0xA9,0xF5,0x75,0x97,0xDC,0x43,0x67,0x2A,0x90,0xE7,0x67,0xBE,
+	0x9A,0x38,0xE8,0x73,0x86,0x77,0xDE,0x67,0xE7,0xC1,0x87,0x47,0xB2,0x62,0x0D,0xF0,0x38,0xFB,0x6A,0xBF,
+	0x5F,0x32,0x9F,0x64,0x32,0xE5,0x9D,0xA3,0xB0,0x90,0x50,0x06,0x05,0x30,0x49,0x95,0x85,0x84,0xD2,0xA1,
+	0xEF,0x90,0x8E,0xB7,0xA7,0xBB,0x04,0xEB,0x95,0xC6,0xA7,0x2B,0x10,0x90,0xA0,0x57,0xD8,0x9F,0x75,0x4F,
+	0xF5,0x3B,0x5A,0x3D,0x5E,0xB7,0xCF,0xFC,0x75,0x91,0x37,0x2A,0xEA,0xB3,0x59,0xA1,0x2A,0xE4,0x23,0x9E,
+	0x1B,0x8C,0x8E,0x40,0xD7,0x54,0x56,0x5F,0x00,0xC0,0xD0,0x00,0x0D,0x3A,0xD9,0xFE,0x8A,0xCE,0xE5,0xCD,
+	0xF2,0xF9,0x3C,0x00,0x03,0xDF,0x00,0x8D,0xD0,0x60,0x09,0xF0,0x74,0xB7,0x3B,0x1D,0x0E,0x5F,0x11,0x2F,
+	0xC7,0xC5,0x4A,0xB1,0x8B,0x70,0x53,0x8D,0x26,0x32,0x90,0x5E,0x4D,0xD4,0xB5,0x07,0xF6,0x6C,0x89,0xBD,
+	0x6D,0x83,0x95,0xCB,0x37,0x1B,0xDC,0x50,0x9A,0x69,0x73,0x19,0xC8,0x4C,0x8C,0x6A,0xE2,0x45,0xEC,0xD4,
+	0xFA,0xD7,0xD4,0xEA,0xEA,0xE2,0xC9,0x1F,0x04,0xCD,0xEA,0x9E,0xCA,0x09,0x04,0x79,0xED,0x7D,0x3E,0xEC,
+	0x80,0x98,0x88,0x96,0xE9,0x67,0xC9,0xDC,0x7C,0xFF,0x2F,0xBD,0x1F,0x2B,0x4F,0x67,0x97,0x03,0xB9,0x51,
+	0x5F,0xCB,0x28,0x10,0x88,0x67,0xE6,0xE4,0x5D,0x66,0x23,0xC1,0xE2,0x99,0x9C,0xBE,0xF0,0x18,0xDC,0xF2,
+	0xFE,0x1D,0x4E,0xA1,0xD5,0x4B,0x16,0x9F,0x05,0x88,0xDD,0x31,0xC3,0xB3,0x44,0x44,0x22,0xA4,0x6A,0x56,
+	0x1F,0x0E,0xE7,0xFF,0x79,0x93,0x00,0xBE,0x44,0x00,0x0D,0x59,0x24,0xDA,0x98,0x22,0x13,0xB6,0x09,0x44,
+	0x04,0x00,0xFF,0xFE,0x00,0x8D,0xC8,0x4A,0x06,0xF6,0x77,0x7F,0x39,0x3F,0x9D,0xCE,0x0B,0x39,0x30,0x1C,
+	0x05,0xD7,0x28,0xDF,0xE4,0xD2,0x83,0x81,0x11,0xB8,0x17,0xB4,0xC2,0x30,0x3C,0xC3,0x01,0xB8,0x2D,0x38,
+	0x03,0x35,0xF3,0xC5,0x3C,0x3A,0x82,0xD0,0xCF,0xB0,0xC4,0x83,0x34,0x9A,0x75,0x16,0xDD,0xD3,0xF1,0x33,
+	0x0F,0xC3,0x48,0xBB,0x9E,0x87,0xA0,0x23,0x52,0x21,0xAE,0x3D,0x8B,0x5A,0x72,0xDA,0x6D,0x32,0x06,0x86,
+	0x13,0xE3,0x92,0x00,0x20,0x0F,0xB1,0x5F,0x74,0x23,0x13,0xD3,0x7C,0xCA,0xB8,0x8A,0x1A,0x73,0xD7,0xCC,
+	0x8D,0xD8,0x06,0x89,0x26,0x7F,0xAA,0x50,0x8A,0x93,0x43,0x55,0x16,0x74,0x6C,0xF5,0xF5,0xDF,0xAE,0x4E,
+	0xD9,0xFF,0x9F,0x90,0x55,0x2E,0x05,0x79,0xFC,0x24,0x81,0x1A,0x20,0xCA,0x41,0x63,0x29,0x38,0x66,0x43,
+	0xB8,0x22,0xA4,0xCF,0x00,0x65,0x02,0x00,0x0D,0x87,0xCB,0xA0,0x25,0x3E,0x9D,0x8E,0xE7,0xE6,0x33,0x00,
+	0x59,0x32,0x00,0x8D,0xE9,0x7C,0xB6,0xB0,0xD4,0x6B,0xD5,0xB5,0x5A,0x75,0xDF,0x7B,0x97,0xAE,0x8F,0x0D,
+	0x60,0xA6,0x8A,0x46,0x73,0xE1,0x0B,0x2A,0x5A,0x6D,0xB7,0xE9,0x43,0x17,0x30,0xDE,0xC3,0x9C,0x75,0xF7,
+	0x75,0xE8,0xF3,0xA4,0xD3,0xEC,0x71,0x34,0x1F,0x89,0x36,0x79,0xD7,0xAD,0x87,0x98,0xD5,0xF9,0x4D,0x0D,
+	0x39,0x6C,0x4F,0x18,0x75,0x42,0x73,0x2C,0x61,0x8D,0xC8,0x44,0xF2,0x60,0xB2,0x65,0x60,0xA7,0x5C,0xED,
+	0x3E,0xB8,0xDD,0xB5,0xE0,0xBC,0x26,0xCB,0x43,0xEA,0x1B,0x23,0x10,0xE4,0x38,0xCE,0xF4,0x02,0x40,0x01,
+	0xD1,0x41,0xD0,0x00,0x7F,0xC7,0xB8,0x54,0xCD,0x22,0x67,0xD4,0x0B,0xE6,0xF4,0xB1,0x91,0x5F,0xCD,0x4D,
+	0x1A,0x73,0x7F,0x65,0xC6,0xF5,0xED,0xA1,0x68,0x38,0xAA,0xC8,0x59,0x3B,0xC6,0xF9,0x9B,0x0B,0xFD,0x6D,
+	0x28,0x19,0x00,0xD2,0x58,0x00,0x0D,0x65,0xB2,0xD1,0x9D,0x87,0xC1,0xA0,0x60,0x70,0xF7,0x00,0x9A,0x53,
+	0x00,0x8D,0xDD,0x66,0x3B,0x68,0x75,0x3B,0x3B,0x1D,0x1D,0x0E,0x96,0x37,0xC2,0x03,0x02,0xF9,0xD8,0x5B,
+	0xBE,0xE6,0xAF,0xF5,0x1B,0x28,0x6A,0xE8,0xB7,0xF7,0x0D,0x67,0x74,0x42,0x25,0x17,0xCB,0x2C,0x1F,0xF7,
+	0x5A,0xDE,0x2D,0x27,0x66,0x7B,0x45,0xE4,0xCA,0x17,0xF3,0x79,0xB3,0xFD,0xF2,0x5D,0x2A,0xAA,0xD3,0x94,
+	0x5E,0xCA,0xD4,0x7C,0xD3,0x77,0xCA,0xFC,0xFC,0x68,0x0C,0x38,0x87,0xB3,0xA7,0x2A,0x51,0x68,0x7C,0x4A,
+	0xE1,0xC5,0xAA,0x68,0x14,0xB6,0x11,0x3B,0x71,0x27,0x86,0x03,0x0C,0x15,0xE1,0x4F,0xA8,0xAB,0x30,0x89,
+	0x98,0x0A,0x0C,0xF8,0x87,0x43,0xC6,0x65,0xC6,0x87,0x7D,0xD2,0xE1,0x18,0xE3,0x6C,0xBB,0xA2,0xF1,0xDD,
+	0x0E,0xB7,0x13,0x9A,0x96,0xC5,0x12,0x8E,0xA5,0xB1,0xA8,0x06,0x7D,0x15,0xB3,0xA5,0x12,0x08,0x1B,0xC5,
+	0x00,0xE3,0x6C,0x00,0x0D,0x6B,0x9F,0x56,0x0E,0x44,0x88,0x5E,0x44,0x8F,0x87,0x00,0x9E,0xCE,0x00,0x8D,
+	0x30,0xDE,0x7B,0x48,0x55,0x2B,0x2B,0x15,0x8A,0xC5,0x45,0x01,0x73,0xE1,0x14,0x25,0x8A,0xD5,0x3E,0xB4,
+	0x5D,0xD1,0xC8,0xF2,0x88,0x3B,0x7C,0x52,0x9F,0xB1,0x77,0xA8,0x1A,0x16,0x42,0xAA,0xF5,0xAA,0x5B,0xD3,
+	0xB3,0x28,0x5C,0x0B,0x36,0x65,0x9D,0x17,0x50,0xA6,0x98,0xC6,0xB9,0x5E,0x97,0x48,0xFC,0x78,0xFE,0x36,
+	0x74,0x6F,0x8E,0xDF,0xE7,0x2F,0xA5,0xF1,0xDB,0x81,0x31,0xBC,0x0C,0x2E,0x0E,0x18,0x04,0x6A,0xCB,0xB8,
+	0x81,0x85,0xCD,0xDD,0xA7,0x15,0x26,0x79,0x87,0x05,0x8C,0x55,0x39,0xB6,0x0D,0xF9,0xF7,0x70,0x32,0x1A,
+	0xD5,0xEC,0x78,0xE7,0x11,0x99,0xC9,0xDA,0x1D,0x4E,0x27,0x9F,0x02,0x14,0x00,0x07,0xCE,0x41,0xC1,0x01,
+	0xC0,0x10,0x11,0x79,0x0D,0xD4,0x5D,0x96,0xAB,0x09,0xE1,0xE8,0xC0,0xEC,0xD3,0xFE,0x5A,0x77,0x00,0x33,
+	0x23,0x00,0x0D,0x56,0xA3,0xC8,0x11,0x03,0x1C,0x42,0x01,0x87,0x03,0x00,0xF1,0x72,0x00,0x8D,0xCA,0xED,
+	0xF1,0x36,0x10,0x13,0x09,0x84,0xC2,0x42,0xEC,0x03,0xE8,0x17,0x79,0x74,0xAE,0x21,0x56,0x98,0xB6,0x88,
+	0x05,0x29,0x23,0x63,0xC1,0x6F,0x48,0xCE,0x5C,0x20,0x52,0xD3,0xB6,0x52,0xD5,0xCA,0x8B,0x85,0x70,0x17,
+	0x34,0x89,0xF1,0xD3,0x5F,0xE2,0x0A,0xF0,0x8B,0x39,0x5C,0xDD,0xBF,0x2C,0xD4,0x64,0x78,0x2A,0x35,0x99,
+	0x0B,0x0E,0xDF,0xD2,0xAB,0x26,0x48,0xD4,0x27,0x77,0x8B,0x86,0xC1,0xE3,0x7D,0xB5,0x13,0x0D,0x65,0xAB,
+	0x6D,0x83,0xA9,0x9A,0x85,0x03,0xAD,0x83,0x83,0x76,0x48,0x42,0xCA,0xA5,0xAA,0x46,0xB0,0xF2,0xC9,0x1B,
+	0xBE,0xD6,0x10,0x25,0xD7,0x47,0x6B,0x46,0x72,0x45,0x53,0x6E,0xD9,0x69,0xFB,0x14,0xFB,0x62,0x2F,0x7F,
+	0x9F,0x33,0xAE,0x5A,0xAE,0xC6,0x4F,0x29,0x16,0xF4,0xF5,0x71,0x13,0xF6,0x05,0x4B,0x00,0xE6,0x56,0x00,
+	0x0D,0xAA,0x5D,0xF6,0x71,0x14,0x88,0xC5,0xC3,0x4D,0x66,0x00,0xF1,0xBE,0x00,0x8D,0x23,0x2E,0xF2,0x8C,
+	0x75,0xBB,0xBB,0x5D,0x5D,0x2E,0x39,0xDC,0x2B,0xEB,0x01,0x14,0x89,0x4B,0xE7,0x44,0x71,0x09,0x74,0xEE,
+	0xDF,0xB2,0xAB,0x51,0xC3,0x08,0xE8,0xEB,0xA7,0xBB,0x19,0x51,0xED,0x33,0x9B,0x16,0x55,0x4A,0xBD,0x64,
+	0xA4,0x27,0x6E,0x31,0x3F,0xC7,0x23,0xBD,0x00,0x1A,0x13,0x0B,0x86,0xBC,0x7C,0xD7,0x1F,0x9E,0xBC,0x1E,
+	0x62,0xD0,0x94,0x36,0x76,0xC4,0xAA,0xA7,0xC7,0xF6,0xE9,0xFF,0x2B,0xB1,0x11,0xCF,0x71,0x26,0xB4,0xCC,
+	0x4F,0xB9,0x11,0x9E,0x05,0x9E,0x53,0xEB,0xE5,0x79,0xED,0x71,0x6A,0xE9,0x3A,0xA8,0x88,0xDA,0x48,0x32,
+	0xA7,0x1C,0x78,0x6B,0x49,0x0D,0xE5,0xD0,0x81,0xCC,0xB3,0x1A,0xDF,0x2E,0x66,0xF9,0x60,0xB2,0xF9,0x54,
+	0x1D,0x4B,0xD6,0x2A,0x95,0xC3,0x8B,0xC4,0xC4,0xFC,0x6F,0x21,0x24,0x58,0x00,0x61,0xC6,0x00,0x0D,0x6E,
+	0xBF,0xDA,0x1E,0x02,0x80,0xC1,0xC1,0x20,0x0F,0x00,0x01,0xF2,0x00,0x8D,0xFA,0xF5,0x91,0xBD,0x52,0x66,
+	0xA8,0xB3,0xD9,0x6C,0x30,0x77,0xCD,0x96,0xDA,0x94,0x82,0x30,0xD3,0x7F,0x0F,0x8C,0x46,0x08,0xAF,0xC8,
+	0x35,0xCF,0xB5,0x36,0x56,0xC4,0xBE,0xBD,0x93,0x81,0x82,0x95,0xD4,0xD2,0x62,0xED,0xA6,0x39,0x74,0x6C,
+	0x85,0xE6,0x32,0x75,0x3D,0x9B,0x32,0xF0,0x0E,0x18,0x90,0x42,0x01,0xAF,0xE0,0x4D,0xD5,0x29,0xB4,0x1D,
+	0x7B,0x2D,0x5B,0xD3,0x7F,0x01,0xB3,0xDC,0xCC,0xB1,0x95,0xB1,0x32,0x09,0x38,0xF0,0x70,0xBB,0x83,0x4A,
+	0xD8,0x73,0xE0,0xE7,0xAF,0x2C,0x5B,0xBB,0xB7,0x98,0xFA,0x7A,0x12,0x92,0x29,0x87,0xA1,0xCB,0x77,0x28,
+	0x28,0xD1,0xFE,0xE6,0xBE,0x2F,0xCA,0x48,0x69,0xA2,0x17,0x80,0xFC,0xC6,0xF0,0xF3,0x34,0xCC,0xCF,0x39,
+	0xD1,0xBF,0x02,0x9A,0xAC,0xD5,0x2E,0xEE,0x87,0x52,0xE9,0x71,0x00,0xA1,0x12,0x00,0x0D,0x1C,0x45,0x2A,
+	0x03,0xFA,0x7F,0x44,0x3F,0x83,0x01,0x00,0x4F,0xD0,0x00,0x8D,0x2B,0x9D,0xF6,0x8E,0x90,0xC9,0xC9,0x64,
+	0x05,0x02,0x38,0xA1,0x94,0x3F,0x2A,0xA9,0xD6,0xCF,0x89,0xDB,0x93,0x93,0xCC,0xDD,0x5E,0x1E,0xDF,0x46,
+	0x4E,0x8A,0x85,0x39,0x1E,0x6D,0x36,0x12,0xDC,0x6F,0xE9,0xE7,0x0D,0x28,0xEE,0x1E,0x8E,0xCC,0x32,0xA8,
+	0xD1,0xC1,0xAD,0xD1,0xCA,0x64,0xA5,0x9E,0x16,0x2B,0x51,0x72,0x5A,0xB5,0x1D,0x76,0x36,0x4A,0xBA,0x4E,
+	0xCC,0xA2,0x6D,0x5E,0x4B,0xB6,0x29,0x0E,0x3A,0x4B,0x11,0x9D,0x50,0xA6,0xC0,0x13,0x73,0x32,0x4D,0xA5,
+	0x7E,0x0A,0xAC,0xAF,0x54,0x42,0x11,0x50,0xF9,0x55,0xFF,0x00,0xDF,0x94,0x87,0xBB,0xBC,0x54,0xC9,0x67,
+	0xE3,0x62,0x42,0x69,0xC8,0x3C,0x19,0x94,0x9B,0x4C,0x83,0xEA,0x60,0x1D,0xB8,0x08,0x5A,0x60,0x83,0x52,
+	0x1B,0xBB,0x05,0x2D,0x8D,0x3E,0xC1,0x6E,0xC7,0xF2,0x00,0xAD,0x7D,0x00,0x0D,0xD6,0xE3,0x79,0xB0,0xD3,
+	0xD7,0x28,0xB5,0x1A,0x4D,0x00,0x63,0xEC,0x00,0x8D,0x67,0xBB,0xD0,0x9D,0xC2,0xC1,0x60,0x60,0x30,0xB0,
+	0x91,0x17,0x44,0x84,0x26,0x7A,0x4F,0x3F,0xB6,0x93,0xD7,0x7E,0xCC,0x32,0x7D,0x6E,0x49,0x93,0x19,0x87,
+	0x2C,0x9F,0xB3,0xCE,0x88,0x13,0xAB,0x7A,0x82,0x66,0x95,0xF5,0x79,0xA1,0xA3,0x9F,0xBD,0x15,0x11,0xD0,
+	0xAB,0x03,0x3E,0xDF,0x88,0x24,0xC8,0xE1,0x8A,0xD4,0xC4,0x24,0x1E,0x23,0xAA,0xF4,0x6A,0x45,0x61,0x9A,
+	0xAB,0x64,0xA2,0x25,0x18,0xA8,0xBA,0xA4,0x1B,0xBE,0x42,0xAC,0x25,0xDD,0xFE,0x02,0xBC,0xD6,0x83,0x40,
+	0x30,0x01,0x3C,0x65,0x52,0xB3,0xA5,0x7C,0xB3,0xC7,0xDD,0x75,0xE1,0x8D,0x92,0xD0,0x1C,0xEC,0x10,0xE3,
+	0x13,0x90,0x1C,0x92,0x8A,0x55,0x19,0x28,0xDF,0xFE,0x94,0xBF,0x5B,0xC8,0x09,0x25,0x96,0x76,0xCB,0x8E,
+	0x46,0x06,0x07,0x97,0xA9,0x8B,0xC1,0xC8,0x00,0xE5,0x2D,0x00,0x0D,0x0A,0x10,0x66,0xC9,0xDC,0x6B,0x2F,
+	0x35,0x35,0x5B,0x00,0x1B,0x83,0x00,0x8D,0x70,0x30,0x10,0xFD,0xE0,0xF1,0xF1,0x78,0x78,0x3C,0x90,0xD5,
+	0x56,0xB5,0x6E,0xA4,0x31,0x05,0x8E,0x22,0x8B,0xAE,0x88,0x9C,0x23,0xC4,0x2A,0xF4,0x8A,0x13,0xD5,0x71,
+	0x41,0xC0,0x99,0x13,0xC0,0xEC,0x03,0x0E,0x86,0xD8,0x40,0xB1,0x24,0xA6,0x09,0x33,0xEC,0x7F,0xF0,0x18,
+	0xE8,0x9C,0x21,0x83,0x3D,0xAE,0xDC,0x63,0xF3,0x5A,0xA1,0xDF,0xAD,0xBA,0x15,0x81,0x8B,0x93,0x0D,0xB1,
+	0xB1,0x3A,0xF0,0x60,0x70,0x37,0xDA,0x7C,0x35,0x5C,0x2D,0x5E,0x96,0x79,0xF4,0x51,0xDB,0xD6,0xAB,0xEE,
+	0xEF,0x1B,0x74,0x95,0x33,0xBF,0x15,0x0F,0x47,0x64,0x32,0x83,0x10,0x68,0x80,0x47,0x97,0xDA,0x60,0xAD,
+	0xA7,0x62,0x6E,0x5C,0x00,0x91,0xD5,0xF7,0x01,0x30,0x5C,0xF0,0x65,0xBF,0x3E,0x2A,0x20,0x03,0x6D,0x40,
+	0xA4,0x32,0xD4,0x7B,0xD2,0xFC,0x00,0xE3,0x6F,0x00,0x0D,0x10,0x01,0x6A,0xC0,0x6A,0x6F,0xF3,0x5B,0xED,
+	0xAD,0x00,0x8C,0xC8,0x00,0x8D,0x9C,0xC6,0xAC,0xA3,0xBE,0xDE,0xDE,0x6F,0x6F,0x37,0x5C,0x35,0x2C,0x0D,
+	0xEF,0xF7,0x65,0x3A,0xBA,0xD2,0xEC,0x59,0x3A,0x82,0x8C,0xAE,0x36,0x38,0xB1,0x40,0xD7,0x6D,0x50,0x7E,
+	0x1B,0xB3,0x6C,0x39,0x23,0xF3,0xBA,0x96,0xC6,0xDF,0xF1,0xFB,0xF0,0xDF,0xAD,0xFA,0x5F,0x2B,0xBD,0xD2,
+	0x57,0x24,0x2A,0x3A,0x15,0x95,0x54,0xA5,0x33,0x8E,0x6A,0x05,0x90,0x49,0x40,0xBE,0x7B,0x06,0x8E,0x49,
+	0x7A,0x45,0x61,0x4D,0xAB,0x23,0x8F,0x34,0x9D,0x38,0x5C,0x80,0x43,0xD4,0x8B,0xF5,0xE3,0x04,0xF1,0xE9,
+	0x3B,0xB4,0xDC,0xF4,0x0E,0x83,0xBB,0x2A,0x7E,0xA4,0xAF,0xF4,0x99,0x1F,0x2B,0x04,0xDE,0x42,0xA4,0xE2,
+	0x7E,0x1D,0x74,0x5A,0xDD,0x4D,0xCA,0xFF,0x76,0x9B,0x3D,0x0E,0x38,0x87,0xB6,0x77,0xC8,0x87,0x43,0x54,
+	0x5B,0x2D,0xEE,0x50,0x00,0x75,0x00,0x00,0x0D,0x1C,0x55,0xED,0xEA,0x99,0xFA,0x38,0x7C,0x3E,0x0A,0x00,
+	0x01,0xDD,0x00,0x8D,0xCF,0x19,0x04,0xCC,0x6A,0x13,0xB4,0x5A,0xAD,0x42,0x45,0xAA,0xD3,0x78,0xC4,0x71,
+	0xD5,0x57,0xBC,0xFB,0x49,0x89,0x2C,0x13,0x85,0xCE,0xAA,0x65,0x52,0xB2,0x29,0xBB,0xB1,0x9C,0x4A,0xCF,
+	0x88,0x3A,0xB1,0xFA,0x4E,0x94,0x35,0x07,0xD4,0x26,0x6D,0xF7,0x01,0x14,0x1C,0xBF,0x99,0x2B,0x44,0xCB,
+	0x30,0xAE,0x57,0xF1,0x06,0x9C,0xB4,0x67,0x26,0x86,0x87,0x6F,0xC8,0xC6,0x20,0x97,0x3C,0xBC,0x39,0xA3,
+	0xAF,0x02,0x41,0x0E,0xD1,0x9F,0x00,0x03,0xF1,0x6C,0xC7,0xFC,0xC2,0xF2,0x5E,0x9D,0x4D,0x3D,0xBD,0x7A,
+	0xF4,0x56,0xD5,0x5C,0xCB,0x59,0x57,0x6F,0x3F,0xB0,0xEE,0xC0,0x9B,0xCC,0x3A,0x94,0xBB,0xD6,0xFC,0xED,
+	0xA1,0x60,0xD6,0x42,0x78,0xF1,0xB8,0x7F,0x52,0x5D,0x87,0xA1,0x68,0xB1,0x95,0x69,0x45,0xD2,0x26,0xD3,
+	0x81,0x2D,0x00,0x98,0x67,0x00,0x0D,0xEE,0xFF,0x77,0xD8,0x67,0xB1,0xB6,0xF9,0x2C,0xD6,0x00,0x2C,0xB6,
+	0x00,0x8D,0xA1,0x5C,0xA6,0x6C,0xBB,0x39,0x1C,0xED,0x8E,0x47,0xBA,0xB0,0x4A,0xCE,0xC0,0x61,0xF8,0xF4,
+	0x65,0x55,0x53,0xB7,0xFF,0x9C,0xE3,0xE7,0x08,0x6B,0x59,0xED,0x0B,0x66,0x13,0x65,0x2E,0x91,0xE5,0xBC,
+	0xFF,0xE4,0xF2,0xE0,0x06,0xA9,0x09,0xA1,0xC4,0x6B,0x14,0xAE,0x96,0x77,0x5B,0xAB,0xAB,0x46,0x83,0xCC,
+	0xD4,0xFF,0x3D,0x93,0x02,0xAA,0x90,0x47,0xA0,0xE3,0x5F,0xD6,0x17,0x04,0x53,0xB4,0xB9,0x34,0xDA,0xFE,
+	0x43,0x11,0x9A,0x0F,0x55,0x27,0xC3,0xF0,0xF1,0x6A,0x1F,0x71,0x06,0x79,0x19,0xAF,0x06,0xB0,0x3F,0xD4,
+	0xFE,0x14,0xDD,0x0F,0x98,0x3A,0x43,0xD8,0x2A,0x81,0x9C,0x4A,0x83,0x48,0x42,0x52,0x3D,0x3D,0x94,0xF9,
+	0xDD,0x46,0xE5,0xF7,0x86,0xE0,0xCE,0x15,0xCC,0xFE,0xB1,0x5D,0xEE,0xCD,0x7E,0x6F,0x23,0x0F,0x6E,0xE6,
+	0x00,0x17,0x00,0x00,0x0D,0xD9,0xE4,0x0D,0xB3,0xE9,0xF6,0x01,0x23,0x3D,0x5E,0x00,0x85,0x26,0x00,0x8D,
+	0x0E,0xB2,0x51,0x87,0xCF,0xE1,0xF0,0xF0,0xF8,0x79,0x7C,0x1D,0xB7,0xEA,0x6C,0x6E,0x0F,0xF3,0x6C,0x9D,
+	0xAD,0xBA,0xD2,0xEC,0x8F,0xBB,0xE3,0x45,0xF6,0xC7,0x90,0xA4,0x33,0x72,0x98,0x4F,0x03,0xE3,0x8B,0x5D,
+	0xB8,0x8C,0xEB,0xB0,0x86,0x86,0xB0,0x13,0x9B,0x6B,0xB5,0x31,0xC9,0x16,0x8D,0x2B,0xEB,0x71,0xC2,0xDC,
+	0x61,0xFD,0x75,0x12,0x71,0x2B,0x85,0xF6,0xF8,0xE2,0x32,0x8F,0xE9,0x8C,0x8E,0xC3,0x57,0x26,0xE5,0x31,
+	0xDF,0x7C,0x44,0x5C,0x21,0xBD,0xAD,0x5F,0x2F,0x4E,0x76,0x8E,0x3D,0x93,0x59,0x17,0x99,0x7D,0x37,0x0D,
+	0x86,0x5F,0xE5,0xE8,0xE0,0x66,0x54,0xAD,0xA2,0x0F,0x5E,0x30,0xA5,0x44,0x40,0x2E,0x2C,0x7E,0x8E,0x45,
+	0x0F,0x71,0x0F,0x79,0xBC,0x7D,0xF3,0x6C,0xE3,0xEC,0xAE,0x28,0x55,0xAE,0x94,0x5E,0xEF,0x66,0x00,0x80,
+	0x72,0x00,0x0D,0x98,0xC4,0xAF,0x22,0x9A,0xCE,0x88,0x67,0x27,0x33,0x00,0x95,0x2B,0x00,0x8D,0xD3,0xE1,
+	0xF8,0x2C,0x15,0x98,0xCC,0x05,0xE6,0xF3,0x73,0x58,0xF9,0x52,0x5C,0x4E,0x1F,0xB9,0x51,0x43,0xA0,0xD4,
+	0xF7,0xCA,0xCA,0x0C,0xFD,0x80,0x88,0x25,0xA5,0x6C,0x31,0xF8,0x68,0x92,0xCA,0x43,0xF9,0xE6,0xFF,0x27,
+	0x07,0xF3,0xD7,0x68,0x18,0xF0,0xA9,0x4B,0x63,0x36,0xD5,0xE4,0x62,0xED,0xC6,0x94,0xE1,0xEE,0x28,0xB5,
+	0x19,0x8B,0x0D,0x50,0x96,0x56,0xAD,0x3E,0xDC,0xFB,0x64,0x27,0xA2,0x4E,0xF8,0x8D,0x81,0xB7,0x38,0x62,
+	0xE6,0x60,0x35,0xF0,0xF0,0xAB,0xC2,0x01,0xE6,0x11,0xF5,0x69,0x2A,0x5B,0x1F,0x3C,0xD6,0xFD,0x07,0xE7,
+	0x89,0x00,0x4A,0x80,0xA8,0xD0,0x9A,0x25,0xE5,0x7C,0x55,0xC9,0x79,0xBA,0x2A,0x80,0x4A,0x81,0x6C,0xD6,
+	0x26,0x7B,0x95,0x59,0xE7,0x43,0x46,0x10,0x32,0x6B,0xA5,0xC9,0x5C,0x23,0x33,0x28,0x00,0xA2,0xEF,0x00,
+	0x0D,0xBE,0xD7,0xBC,0xAA,0xB0,0x5A,0x6A,0x16,0x0B,0xC5,0x00,0x0B,0xC8,0x00,0x8D,0xA8,0xDC,0xB6,0xAE,
+	0xB3,0x57,0x2B,0x95,0x4A,0x25,0x23,0xD3,0x29,0xB8,0x32,0x1C,0x0A,0x29,0x0D,0x76,0xCD,0x6F,0x3B,0x51,
+	0x54,0xD5,0xC9,0xE5,0x23,0xBB,0x13,0x89,0xB8,0x5B,0xDD,0x34,0xD9,0x21,0x19,0x59,0x55,0x2D,0x67,0xD4,
+	0xD6,0x14,0x93,0x0B,0xDE,0x64,0xFC,0x0E,0x4F,0xA8,0x28,0x11,0x31,0x8E,0x92,0xCF,0x38,0x49,0xAC,0x08,
+	0x7B,0xD0,0x11,0x1B,0x85,0xFD,0x17,0x0F,0x8F,0xF6,0xE2,0x91,0xE6,0x1B,0xF3,0xFA,0x54,0x1A,0x3B,0x3C,
+	0xB6,0xB6,0xA3,0x62,0xC0,0xE9,0xBE,0x23,0x8D,0xBF,0x5C,0x28,0xE5,0x13,0xF0,0x50,0xAB,0xFE,0x26,0xA3,
+	0x88,0x7A,0xC4,0x5B,0xC2,0xD5,0x98,0xB2,0x89,0x6C,0x7B,0x28,0xF4,0x11,0xF9,0x77,0x25,0x21,0x12,0x8D,
+	0x9F,0x00,0xAC,0xC2,0xD0,0x0E,0x74,0xA4,0xC2,0xAE,0xC0,0x00,0x60,0x97,0x00,0xCB,0xFF,0x00,0x0D,0xD2,
+	0x06,0x8B,0x80,0xCB,0xCF,0xA0,0xCF,0x27,0xC1,0x00,0x50,0xF1,0x00,0x8D,0xF9,0x7D,0x1F,0x7E,0x33,0x2F,
+	0x97,0x98,0xCC,0x4B,0x6B,0xA6,0xB3,0xBC,0x4C,0xE2,0x6E,0xE7,0x3A,0x13,0x90,0x6D,0x70,0x69,0xD4,0x44,
+	0x79,0xD4,0x34,0x95,0x5C,0x53,0xA6,0x5C,0x42,0x36,0x14,0x05,0x95,0x9B,0x42,0x2E,0x81,0x8F,0xE3,0xA6,
+	0x13,0x43,0x71,0xDE,0x59,0x76,0x29,0xB8,0xD7,0x6D,0x38,0x0F,0x8E,0xEA,0x0F,0x99,0x49,0x3D,0xA3,0x59,
+	0xD2,0xF8,0x40,0x3C,0x3C,0xBB,0x84,0xBE,0xA6,0xB6,0x50,0xCF,0x66,0xA4,0xF2,0xBF,0x5E,0xEA,0x60,0x77,
+	0xBB,0x52,0x4C,0x31,0x25,0x10,0x84,0xCB,0x6E,0xB7,0xF0,0xF2,0xCE,0xE8,0x44,0x82,0xE3,0xF6,0x2C,0x83,
+	0x67,0x58,0xBE,0x22,0x63,0x92,0x48,0x40,0x75,0xED,0x3C,0x16,0xFD,0x02,0x71,0x1B,0xEB,0x99,0x61,0x99,
+	0xB4,0x4F,0x2A,0x83,0x99,0x50,0xA0,0xD9,0x48,0x0F,0xFB,0xF6,0x00,0x0A,0xA6,0x00,0x0D,0x1F,0x07,0x8B,
+	0x43,0x2A,0x17,0x64,0x8C,0x46,0x0B,0x00,0x93,0x84,0x00,0x8D,0xCF,0x18,0x84,0x36,0x97,0x94,0x4A,0xA5,
+	0xA5,0x52,0xD2,0x78,0xDD,0xF2,0xF2,0x5C,0x65,0x4E,0xFE,0xCE,0x5C,0x29,0xCD,0xD7,0x27,0x22,0x40,0x65,
+	0xFE,0xB0,0x7C,0x07,0x96,0x1B,0xDB,0x2B,0x90,0x1C,0xDC,0xED,0xBC,0xCD,0xBC,0x22,0x96,0xB5,0x72,0x15,
+	0xE5,0x63,0x50,0x70,0xB4,0x7F,0x3F,0x5F,0xFE,0xC6,0xD0,0x2D,0x08,0x94,0x37,0xCB,0xE7,0x73,0xEA,0x7D,
+	0xB8,0x1E,0xF1,0x6B,0x4F,0x5A,0x7A,0xB0,0x91,0x5B,0xAA,0x29,0x7B,0xBE,0x49,0xC4,0xC1,0xCA,0x6C,0x2A,
+	0x14,0x03,0x51,0x62,0xB0,0x30,0xA5,0x9F,0x22,0x9B,0x9F,0x24,0xB3,0x97,0x0D,0x8E,0xDF,0x9B,0xF7,0xFB,
+	0x9B,0xF4,0xFA,0x3B,0xE9,0xAA,0x89,0x12,0xDC,0x53,0x46,0xD1,0x28,0xB2,0x78,0xDA,0xBE,0x79,0xD8,0x4F,
+	0xF6,0xD0,0x6C,0x97,0x48,0x37,0xBE,0xF4,0xF2,0x40,0x00,0xD1,0xB2,0x00,0x0D,0x9F,0x48,0xAC,0x23,0x39,
+	0x9E,0x87,0xBF,0x67,0xDF,0x00,0xC9,0xF7,0x00,0x8D,0x59,0x72,0x31,0xF9,0x70,0x73,0x39,0x73,0x1C,0x39,
+	0x0E,0xBC,0x07,0xBD,0x48,0x27,0xA4,0xD0,0x02,0x85,0x00,0x14,0xA6,0xD5,0x54,0x9B,0x48,0x28,0xE9,0xA1,
+	0x98,0x7A,0x0C,0xA8,0xA6,0x33,0x39,0x77,0xB6,0xBA,0x3A,0x22,0x96,0xEA,0x75,0xFC,0x0F,0xF4,0x1F,0xBD,
+	0x8F,0xC4,0xD2,0x82,0xEB,0x61,0xED,0x74,0xFB,0x19,0x7C,0xEA,0x76,0xCE,0x68,0xDE,0xA6,0xC6,0x6B,0x0E,
+	0x90,0x28,0xD8,0x84,0x3F,0x8C,0x32,0x29,0x2C,0xA5,0xEA,0x31,0xE1,0x90,0x7A,0xBB,0x18,0x0D,0xBB,0xC5,
+	0x87,0x67,0xF2,0x99,0xAC,0x5C,0x50,0xCA,0x85,0x8B,0xDF,0x54,0xF9,0xC4,0xE5,0x56,0xA3,0xCC,0x97,0x8F,
+	0x1E,0xA4,0x9B,0x25,0x86,0x6D,0xA0,0xC7,0xD8,0xE3,0xFA,0xEA,0xF5,0xF5,0xE7,0xE4,0x7D,0x31,0xCF,0xF0,
+	0x5C,0xA6,0x13,0x43,0xF1,0x5E,0x19,0xCB,0x00,0x45,0xF7,0x00,0x0D,0xBE,0xD7,0xE3,0x21,0x1E,0x1F,0x44,
+	0x06,0x03,0xC1,0x00,0x8F,0x33,0x00,0x8D,0x6A,0xBD,0x56,0x61,0x3C,0x67,0xB3,0xCF,0xE7,0xED,0x76,0xC6,
+	0x58,0xAA,0xCB,0x57,0xD8,0x14,0x15,0x0B,0xD4,0x44,0xEC,0x65,0x3E,0x76,0x38,0x2D,0x78,0x5B,0x11,0x12,
+	0xF2,0xC3,0xC5,0x1A,0x39,0x1D,0x8D,0xCF,0x40,0x33,0x69,0xDD,0x9C,0x68,0x1D,0x16,0x02,0x1D,0x02,0xFF,
+	0xAF,0xEF,0x72,0xE2,0xDD,0xB4,0x66,0xCE,0x25,0x13,0xC9,0xEA,0x55,0x90,0xBA,0x33,0x33,0x82,0x9B,0x56,
+	0x2E,0xB4,0x0D,0x25,0xAB,0x74,0xD7,0x6E,0x8E,0xDC,0xC5,0xF9,0x0D,0x25,0x9C,0xED,0xF7,0xDA,0x5F,0xF4,
+	0x9D,0x56,0x53,0x8A,0x23,0x22,0xEB,0x1C,0x2D,0x95,0x5B,0xCD,0x96,0x05,0x54,0x43,0x25,0xB6,0x32,0x01,
+	0x05,0x85,0x2B,0x14,0x4F,0x88,0x40,0x20,0xA8,0x85,0xEE,0xC7,0x8B,0x26,0xCC,0xDF,0x32,0xD0,0x99,0x27,
+	0x8C,0xC6,0x20,0xF2,0x07,0x90,0x00,0x3F,0x62,0x00,0x0D,0x62,0xBF,0x52,0xDC,0x84,0xC0,0x79,0xE0,0x98,
+	0xEF,0x00,0x3B,0x5B,0x00,0x8D,0x3D,0x20,0x7D,0x50,0x56,0xAA,0x55,0x6A,0xAA,0x55,0x24,0x90,0x06,0x20,
+	0x46,0xF1,0x0E,0xC1,0xEC,0x65,0x44,0x0B,0x0F,0x42,0x5C,0x3D,0xDF,0x70,0x98,0x5E,0x3C,0xC1,0x0B,0x60,
+	0x07,0xB3,0x09,0x15,0xED,0x9F,0x3F,0x27,0xCA,0xEB,0x5B,0xB6,0xDF,0x7B,0x3A,0x7B,0x39,0x65,0x82,0xF8,
+	0x93,0x26,0x41,0xEA,0x6B,0xE0,0x00,0x10,0x6E,0x8D,0xCA,0x9C,0xE8,0x84,0x72,0x83,0x3D,0x16,0xEE,0x4E,
+	0xF8,0xED,0xAC,0x67,0x36,0x30,0x77,0xC7,0x4E,0x92,0x17,0x3B,0xC4,0x27,0xEB,0x7A,0xDB,0xEA,0x15,0x1B,
+	0x0D,0xD2,0xB9,0xE1,0x88,0x87,0xD5,0xCE,0x9A,0xA7,0xB8,0x21,0x92,0xCC,0x36,0x7D,0x80,0x53,0xE4,0x7A,
+	0x0A,0xB8,0xB3,0x48,0x57,0x7C,0x94,0xE5,0x51,0xA9,0xC7,0x0F,0x04,0xDC,0x1C,0x34,0x79,0xFA,0x2E,0x49,
+	0xE7,0xFF,0xBE,0x23,0x00,0x6E,0xA9,0x00,0x0D,0x31,0x10,0x7B,0xC8,0xD2,0x6B,0x7F,0x1A,0x8C,0xCD,0x00,
+	0x8E,0xBE,0x00,0x8D,0x2C,0x9E,0xF5,0x0F,0x12,0x88,0x88,0x43,0xA1,0x21,0x58,0xD5,0x57,0xF3,0xFA,0xCA,
+	0x0F,0xA9,0xDE,0xC9,0xB1,0xA5,0xAE,0x83,0x9B,0x80,0x88,0x01,0x41,0xB8,0xB4,0xA3,0x4D,0x47,0x04,0x74,
+	0xB2,0x9F,0x04,0xE5,0x0A,0x43,0x8C,0xC1,0x18,0x61,0x34,0x58,0xBF,0xA2,0x2E,0xC0,0xB7,0x15,0xA4,0x99,
+	0xBF,0x33,0xC3,0x11,0x05,0xE0,0x37,0x83,0x6D,0x02,0x3A,0x74,0xB2,0x2F,0x7D,0x4E,0xD0,0x87,0x42,0xC2,
+	0xDD,0xFF,0x28,0xA4,0x04,0xD3,0xEB,0x76,0x89,0x55,0x20,0x15,0x18,0x5C,0x22,0xC6,0xB8,0x63,0x6D,0x8D,
+	0xAE,0xC6,0xDE,0x49,0xCF,0x30,0x96,0x34,0x1F,0x8B,0x19,0x97,0xF5,0x83,0xB6,0x57,0x67,0x71,0xC4,0xA9,
+	0xE7,0x8C,0xB9,0xD0,0x06,0x00,0xA5,0xD9,0x26,0x1D,0xBB,0x32,0x65,0x4E,0x47,0xDE,0x2F,0x30,0x64,0xB7,
+	0x6C,0x86,0x00,0x0D,0xFD,0x00,0x8F,0x32,0x11,0x05,0xC8,0x6E,0x35,0xD3,0x1A,0xCC,0xA6,0xF2,0xF3,0xB2,
+	0x7C,0xBE,0x5E,0xEC,0xEF,0xF7,0xF7,0xFB,0x55,0x7B,0x28,0xC4,0x3B,0xE7,0x86,0x4A,0xDC,0x25,0x9E,0x3E,
+	0x8E,0x70,0x43,0xC3,0xA1,0xD1,0xE8,0xF8,0xF4,0xA4,0xF8,0xE1,0x37,0xB7,0x46,0x27,0x10,0x9F,0x80,0xBF,
+	0xB7,0xD0,0xEE,0x94,0x31,0xC1,0x1D,0x73,0x7B,0x3D,0x39,0x57,0x1C,0x8E,0xFF,0x5E,0x63,0xFA,0x32,0xD9,
+	0xF9,0x3D,0x1E,0x52,0x0F,0x5D,0x87,0x82,0x17,0x47,0xA0,0x90,0xC2,0xA0,0xA1,0x1D,0x52,0xA9,0x28,0x55,
+	0xF4,0x67,0x15,0xCA,0x65,0xE4,0x72,0x77,0x7B,0xBD,0x3E,0x5E,0xAF,0xE1,0xD7,0x2B,0x94,0x0B,0x4A,0x4B,
+	0x82,0xD2,0xC1,0xA1,0xBB,0x1F,0x5D,0x6E,0xEE,0x36,0x48,0xCB,0x24,0x92,0x12,0x48,0x49,0x74,0xBD,0x92,
+	0x1E,0xCE,0xCE,0x36,0x33,0x44,0x19,0x00,0xC0,0x09,0x00,0x91,0xA6,0x5B,0x30,0xED,0xF8,0x7C,0xED,0x3E,
+	0xDE,0x6F,0xEF,0xF7,0xA9,0x7D,0xBE,0x5F,0xDE,0xEF,0xA5,0x77,0xFB,0x3D,0x5F,0x5E,0xFC,0xC7,0x57,0xE3,
+	0x30,0xF4,0x4B,0x7A,0x0C,0xFC,0x84,0xBE,0x8B,0xEC,0x76,0x3A,0xDC,0xED,0xBA,0x76,0x7B,0xFB,0xBC,0x5E,
+	0x0B,0x2F,0x2F,0x17,0x4A,0x4B,0x70,0xA5,0x12,0x92,0x08,0x04,0x52,0x81,0x82,0x41,0xC1,0xE0,0xA6,0x78,
+	0xF7,0xFB,0x7A,0xBD,0xE9,0xDF,0xDF,0xEF,0x6E,0x37,0xCC,0x1B,0xCD,0xE6,0x67,0xB3,0xAB,0x59,0x79,0xBC,
+	0x9F,0x4F,0x7D,0x12,0x49,0xC8,0xA5,0x52,0x28,0xB8,0x3F,0xDC,0x1E,0x2D,0xD6,0x16,0x4B,0x25,0xA7,0xD3,
+	0x29,0xB9,0xDC,0x9A,0x6F,0x0C,0xDC,0x5B,0xC3,0xE1,0x31,0x3B,0x43,0x8C,0xC3,0x46,0x62,0x31,0x83,0xEC,
+	0x0C,0xB5,0x9B,0xC2,0xBD,0xE1,0x70,0xB8,0x9D,0x4E,0x12,0x27,0xAF,0x53,0x00,0x4D,0xC4,0x00,0x91,0x03,
+	0xD6,0xE2,0x04,0x8C,0xA6,0x8E,0x23,0x69,0xB4,0x35,0x9A,0xC4,0xCC,0x4C,0x26,0x01,0x53,0xDE,0x29,0x40,
+	0x14,0x1E,0xCA,0xCE,0x48,0x39,0x9C,0x39,0x1C,0x98,0x8E,0xE3,0xF1,0x87,0xB9,0x03,0xE1,0x30,0xB0,0x19,
+	0x18,0xEC,0x45,0x45,0xA2,0x10,0x11,0x68,0x04,0x41,0xC1,0x21,0x10,0x26,0x88,0x23,0xC3,0x10,0xA1,0x69,
+	0xD0,0x84,0x42,0xCF,0xE0,0x85,0x73,0xB4,0x5A,0x6B,0xB5,0x3B,0xDA,0x2C,0x96,0x8B,0x45,0xC1,0xA2,0xD1,
+	0xE8,0x69,0x34,0x79,0x99,0x0C,0x86,0x82,0xC1,0x04,0x30,0x17,0x0B,0x8A,0xC5,0xA2,0x62,0xF1,0x71,0xF9,
+	0xFC,0x99,0x7D,0x7D,0xBE,0x1E,0x0F,0x62,0x83,0x81,0xC0,0xA1,0xA0,0xA9,0xE7,0x68,0x34,0x38,0x9C,0xCB,
+	0xD6,0x2B,0x93,0x88,0x4A,0x23,0x25,0x92,0x12,0x48,0x88,0xC3,0x43,0xD2,0x61,0xE9,0x74,0x52,0x5C,0x9D,
+	0x4E,0x00,0x52,0x1C,0x00,0x91,0x75,0x32,0x59,0x59,0x46,0xA3,0xB9,0x51,0x68,0x34,0xBF,0x59,0x45,0x94,
+	0x96,0xCB,0xCD,0x25,0x0C,0x32,0x89,0x44,0xED,0x76,0xDA,0xBA,0x5D,0x20,0xD1,0xD7,0x82,0xF4,0x74,0x3A,
+	0x5C,0x2D,0x7D,0x57,0x0B,0x85,0x83,0x99,0xAA,0xCC,0x26,0xA6,0x92,0x24,0x7E,0x12,0x09,0x5A,0x85,0xED,
+	0x2E,0xF6,0xBB,0x3B,0xDC,0x44,0x4F,0x21,0x90,0xBB,0x49,0x9D,0x23,0x27,0xC9,0x53,0xE8,0xEC,0x1A,0x76,
+	0xBA,0x3B,0xDC,0xDD,0x80,0x6E,0x77,0x3B,0xBA,0x5D,0x32,0x2E,0xAE,0x97,0x0A,0x65,0xEA,0xB2,0xC2,0x19,
+	0xCD,0xCC,0x96,0xE0,0x70,0xF0,0xB9,0xB8,0x2C,0xDB,0x2D,0x16,0x97,0x4A,0xD4,0x52,0xA9,0x54,0xEB,0x74,
+	0xCB,0xDD,0x2E,0xAE,0x97,0xCB,0x97,0x72,0x39,0x9C,0x1D,0x0E,0x7C,0x86,0x03,0x83,0x00,0x01,0x73,0x80,
+	0x7F,0x3F,0x5E,0x5F,0x5C,0x97,0x0B,0x8C,0x00,0xCC,0x69,0x00,0x45,0xEC,0xFF,0x77,0xCE,0xD1,0x68,0x1C,
+	0x34,0x73,0x19,0xB8,0xDC,0x9A,0x77,0x79,0x7B,0xFC,0xFD,0x8B,0x6F,0xFF,0xB7,0xFE,0x1B,0x0A,0xBF,0x18,
+	0x8C,0x0E,0x07,0xB5,0x04,0x82,0xC1,0xA1,0xA0,0xA6,0x3D,0x67,0x33,0x2E,0x59,0x5B,0x37,0x16,0x9B,0x8A,
+	0x8E,0xB0,0xE3,0x63,0x31,0x52,0xD8,0x6C,0xC8,0xDB,0xD8,0x75,0x13,0xBD,0xDA,0x2B,0xED,0x36,0x76,0x00,
+	0xD4,0xA7,0x00,0x8D,0x71,0x30,0x5B,0x58,0x82,0x23,0xC3,0x61,0x08,0x84,0x03,0x01,0x01,0x00,0xDB,0x80,
+	0x6D,0xC0,0xB6,0x5F,0xDB,0x2F,0x6D,0xB6,0xB6,0xDB,0xDB,0xED,0xED,0xF6,0xA1,0xFB,0x50,0x28,0x94,0x94,
+	0xCA,0xCF,0x67,0x32,0x19,0x19,0x8C,0xC5,0xC6,0x63,0x31,0x31,0x18,0x18,0x0C,0x0C,0x85,0x05,0x42,0x82,
+	0x21,0x90,0x38,0x1C,0x1B,0x8D,0x8D,0xC6,0xC6,0xE3,0xE8,0x74,0x73,0x39,0x1A,0x0D,0x85,0x42,0x42,0x21,
+	0x20,0x90,0x48,0x24,0x91,0x48,0x49,0xA4,0xD2,0xD1,0x68,0x68,0x34,0x19,0x8C,0x8C,0x46,0x46,0xA2,0xA3,
+	0x51,0x51,0x28,0x28,0x14,0x89,0x89,0xC4,0xC4,0xE2,0x71,0x71,0xB8,0xB8,0x5B,0xAD,0x56,0x56,0x2B,0x2B,
+	0x95,0xD5,0xCA,0x65,0x75,0xBA,0x5D,0x5D,0x2E,0x17,0xAA,0x8B,0x45,0xEA,0x23,0x75,0x91,0x3A,0x48,0x1D,
+	0x24,0x92,0x00,0xAB,0x3F,0x00,0x8D,0x23,0xF4,0x72,0x4C,0xAC,0x51,0xD4,0xEA,0x6A,0xB5,0x9A,0x9A,0x4D,
+	0x26,0x31,0x12,0x89,0x89,0xC4,0xC6,0x63,0x62,0x31,0x18,0x3C,0x9E,0xCF,0xF7,0xD5,0xF3,0x49,0xBC,0xDE,
+	0xDE,0xEF,0x77,0x37,0x9B,0x4D,0x4D,0xA6,0xE7,0xD3,0x69,0xB9,0x20,0x59,0x9E,0x2C,0xDA,0x32,0x92,0xB6,
+	0x88,0xDB,0xC4,0x2D,0xA2,0x77,0xB1,0xB8,0xB8,0x3C,0x53,0xFD,0xC9,0x9E,0xAF,0xAF,0xB7,0xBB,0xBD,0xFE,
+	0x7F,0xC4,0x02,0x01,0x60,0x61,0xD0,0x87,0xA3,0xA4,0xB1,0xB1,0x38,0x7C,0xDD,0xDE,0x0E,0xCE,0xD8,0x6F,
+	0x10,0x33,0x09,0x84,0xFA,0x42,0xFC,0x7E,0x7E,0x3F,0x96,0x4B,0x4D,0xB5,0x56,0x38,0x38,0x04,0x89,0xC2,
+	0x44,0x76,0xA2,0xD1,0xE8,0x0B,0x0B,0x86,0x43,0x21,0x21,0x91,0x48,0x48,0x24,0x24,0x12,0x89,0x44,0xA2,
+	0xA2,0xD1,0x68,0x68,0x34,0x00,0x30,0xC9,0x00,0x8D,0x0F,0x0F,0x0E,0xF2,0xE9,0x76,0x77,0xBB,0x5D,0xDD,
+	0xD1,0xD1,0x68,0x34,0x34,0x9A,0x4D,0x4D,0xA6,0xD3,0xE9,0x74,0xBC,0x3A,0x1D,0xEF,0x77,0x07,0xBB,0x5D,
+	0x4B,0x2E,0x25,0x17,0x13,0x89,0x86,0x43,0x62,0x21,0x10,0xC0,0xE0,0xE0,0xF0,0xF0,0xF8,0xA3,0x7C,0x51,
+	0xA8,0x54,0xAF,0x57,0x2E,0x2B,0x15,0x8A,0x06,0x03,0x62,0x81,0x40,0x18,0x0C,0x0C,0x86,0x01,0x00,0x00,
+	0x00,0x00,0xF7,0x7F,0x3F,0x3D,0xA0,0x1E,0x0F,0x0F,0x07,0x83,0x83,0x41,0xB5,0x20,0x5A,0x10,0xAD,0xD6,
+	0xD7,0xEB,0x9F,0xF5,0xCF,0x7A,0xE7,0x3D,0x73,0xB9,0xBA,0xDD,0xC4,0x62,0xB7,0x31,0xDB,0x6D,0x58,0x36,
+	0x2C,0x16,0x13,0x0B,0x09,0x85,0xC2,0x61,0x30,0x30,0x18,0x18,0x8C,0x46,0x46,0xA3,0xA3,0x51,0x52,0x29,
+	0x29,0x14,0x14,0x8A,0x8A,0xC5,0xC5,0xE2,0x00,0x07,0x0B,0x00,0x8D,0x76,0xB3,0xAB,0x99,0x3B,0x43,0x9E,
+	0x21,0xCF,0xE7,0x98,0xCC,0xCC,0xE6,0xF2,0xF9,0xF9,0xFC,0xFE,0x7F,0x7F,0x3F,0x9F,0xD0,0xCF,0x68,0x34,
+	0x33,0x9A,0x4D,0x4D,0xA6,0xA6,0x53,0x29,0x94,0x94,0x4A,0x25,0x93,0x92,0x49,0x49,0x24,0x24,0x12,0x12,
+	0x09,0x09,0x04,0x05,0x82,0xC1,0xE0,0xE1,0x70,0x60,0x30,0x98,0x4E,0x27,0x93,0xAA,0xCA,0x65,0x6A,0x32,
+	0xB5,0xDA,0x7B,0xBD,0x66,0xB3,0xAF,0x57,0x6C,0x36,0x95,0xCA,0xE5,0xC6,0x63,0x63,0x31,0xDC,0x19,0x0C,
+	0x06,0x83,0x83,0x41,0xA3,0x51,0x28,0xA8,0x14,0xD4,0x6A,0x05,0xB5,0xDA,0xC6,0x6D,0x63,0x31,0xEF,0xF7,
+	0x8C,0x7B,0x3D,0xA2,0xD1,0xCF,0x68,0x34,0xF4,0x9A,0xCD,0x7D,0xE6,0xBE,0xF3,0x5F,0x79,0x2F,0xBD,0x18,
+	0xDE,0x6F,0x6F,0x37,0x37,0x9B,0x9B,0xCD,0xCD,0x66,0x5E,0x00,0xC7,0x1C,0x00,0x0D,0x3A,0xED,0xFE,0xCD,
+	0x93,0xCA,0xB0,0x72,0x5E,0x1E,0x00,0xD1,0x09,0x00,0x00
+};
+
+//#define QT5480_DEBUG
+
+// print message
+#if defined(QT5480_DEBUG) || defined(DEBUG)
+	#define DEBUG_MSG(p, x...)			printk("[QT5480]:[%s] ", __func__); printk(p, ## x);		
+#else
+	#define DEBUG_MSG(p, x...)	if(show_debug_message) { printk("[QT5480]:[%s] ", __func__); printk(p, ## x); }
+#endif
+
+#define PRINT_MSG(p, x...)		{ printk("[QT5480]:[%s] ", __func__); printk(p, ## x); }
+
+#ifdef QT5480_DEBUG
+	#define ENTER_FUNC	{ printk("[QT5480] +%s\n", __func__); }
+	#define LEAVE_FUNC	{ printk("[QT5480] -%s\n", __func__); }
+#else
+	#define ENTER_FUNC	if(show_debug_message) { printk("[QT5480] +%s\n", __func__); }
+	#define LEAVE_FUNC	if(show_debug_message) { printk("[QT5480] -%s\n", __func__); }
+#endif
+
+// definition for some macro for convenience
+#define DO_IF_TRUE(b, p)						if((b)) (p)
+#define DO_AND_RETURN_IF_TRUE(b, p)				{if((b)) { (p); return; }}
+#define DO_AND_RETURN_VALUE_IF_TRUE(b, p, r)	{if((b)) { (p); return (r); }}
+
+#define QT5480_I2C_ADDR 				0x60
+#define QT5480_BOOTLOADER_MODE_I2C_ADDR	0x4A
+
+#if (CONFIG_SPICA_REV > CONFIG_SPICA_TEST_REV00)
+#define QT5480_CHIP_ID 0x0F
+#else
+#define QT5480_CHIP_ID 0x40
+#endif
+
+#define IRQ_TOUCH_INT IRQ_EINT(20)
+
+//
+// QT5480 only be able to send a data packet consists of five bytes
+#define BASIC_READ_COUNT	5
+
+//
+// definition for i2c_ts_driver structure
+struct ts_driver 
+	{
+	struct i2c_client		*client;
+	struct input_dev		*input_dev;
+	struct work_struct 		work;
+	struct early_suspend	early_suspend;
+	} __attribute__ ((packed));
+
+//
+// pre-declaration for the global variables
+static int i2c_attach_adapter(struct i2c_adapter *);
+static int qt5480_probe(struct platform_device *);
+static int qt5480_remove(struct platform_device *);
+
+//
+// declaration for the global variables
+static struct ts_driver			*g_qt5480_ts_driver = NULL;
+static struct device			*g_ts_dev = NULL;
+static struct workqueue_struct	*g_qt5480_work_queue;
+
+static u16 g_qt5480_i2c_normal[] 	= {(QT5480_I2C_ADDR >> 1), I2C_CLIENT_END};
+static u16 g_qt5480_i2c_ignore[] 	= {1, (QT5480_I2C_ADDR >> 1), I2C_CLIENT_END};
+static u16 g_qt5480_i2c_probe[] 	= {I2C_CLIENT_END};
+
+static struct i2c_client_address_data g_qt5480_addr_data = {
+	.normal_i2c = g_qt5480_i2c_normal,
+	.ignore = g_qt5480_i2c_ignore,
+	.probe = g_qt5480_i2c_probe,
+};
+
+static struct i2c_driver g_qt5480_i2c_driver = {
+	.driver = {
+		.name	= "qt5480_i2c",
+	},
+	.id	= QT5480_I2C_ADDR,
+	.attach_adapter = i2c_attach_adapter,
+};
+
+static struct platform_driver g_qt5480_driver =  {
+	.probe	= qt5480_probe,
+	.remove = qt5480_remove,
+	.driver = {
+		.name = "qt5480-ts",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int show_debug_message = 0;
+
+// external variable
+extern struct class *sec_class;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	static void qt5480_early_suspend(struct early_suspend*);
+	static void qt5480_late_resume(struct early_suspend*);
+#endif	// End of CONFIG_HAS_EARLYSUSPEND
+
+/* Definition for registers in QT4580 Touch screen driver */
+#define REG_CHIP_ID 						0	// byte 
+#define REG_CODE_VERSION					1 	// byte 
+#define REG_CALIBRATE						2 	// byte 
+#define REG_RESET							3	// byte 
+#define REG_BACKUP_REQUEST					4	// byte 
+#define REG_ADDRESS_POINTER					5 	// byte 
+#define REG_EEPROM_CHKSUM					6 	// word
+#define REG_KEY_STATUS_1 					8	// byte 
+
+#define REG_GENERAL_STATUS_1 				14	// byte
+#define REG_GENERAL_STATUS_2				15	// byte
+#define REG_TOUCHSCR_0_X					16	// word 
+#define REG_TOUCHSCR_0_Y 					18	// word
+
+#define REG_TOUCHSCR_1_X 					20	// word 
+#define REG_TOUCHSCR_1_Y					22 	// word 
+#define REG_SLIDER_POS						20	// 6 bytes
+#define REG_FORCE_MESURE					26 	// byte
+#define REG_CHANNEL_GATING_INPUT_STATUS 	27 	// byte
+
+#define REG_CHANNEL_0_DELTA					256	// word
+
+#define REG_CHANNEL_0_REFERENCE				352	// word
+
+#define REG_CHANNEL_CONTROL					512	// 48 bytes
+#define REG_CHANNEL_NEGATIVE_THRESHHOLD		560	// 48 bytes
+
+#define REG_CHANNEL_BURST_LENGTH			608	// 48 bytes
+#define REG_LP_MODE							656	// byte
+#define REG_MIN_CYCLE_TIME					657	// byte
+#define REG_AWAKE_TIMEOUT					658	// byte
+#define REG_TRIGGER_CONTROL					659	// byte
+#define REG_GUARD_CHANNEL_ENABLE			660	// byte
+#define REG_TOUCHSCREEN_SETUP				661	// byte
+#define REG_TOUCHSCREEN_LENGTH				662	// byte
+#define REG_SLIDER_SETUP					662	// 6 bytes
+#define REG_TOUCHSCREEN_HYSTERESIS			668	// 6 bytes
+#define REG_SLIDER_HYSTERESIS				668	// 6 bytes
+#define REG_GPO_CONTROL						674	// byte
+#define REG_NDRIFT_SETTING					675	// byte
+#define REG_PDRIFT_SETTING					676	// byte
+#define REG_NDIL_SETTING					677	// byte
+#define REG_SDIL_SETTING					678	// byte
+#define REG_NEGATIVE_RECALIBRATION_DELAY	679	// byte
+#define REG_DRIFT_HOLD_TIME					680	// byte
+#define REG_FORCE_SENSOR_THRESHHOLD			681	// byte
+#define REG_POSITION_CLIPPING_LIMITS		682	// 2 bytes
+#define REG_LINEAR_X_OFFSET					684	// 2 bytes
+#define REG_LINEAR_X_SEGMENTS				686	// 16 bytes
+
+#define REG_LINEAR_Y_OFFSET					702	// 2 bytes
+#define REG_LINEAR_Y_SEGMENTS				704	// 16 bytes
+#define REG_BURST_CONTROL					720	// byte
+#define REG_STATUS_MASK						721 // byte
+#define REG_POSITION_FILTER_CONTROL			722	// byte
+#define REG_TOUCH_SIZE_RESOLUTION_CONTROL	723	// byte
+#define REG_TOUCHSCREEN_PLATEAU_CONTROL		724	// byte
+#define REG_SLEW_RATE_FILTER_CONTROL		725 // byte
+#define REG_MEDIAN_FILTER_LENGTH			726	// byte
+#define REG_IIR_FILTER_CONTROL				727 // byte
+#define REG_TOUCHDOWN_HYSTERESIS			728	// byte
+#define REG_GESTURE_CONFIG_REGISTERS		734	// 14 bytes
+
+
+static u8 g_qt5480_setup[] = {
+#if 0
+  0,   0,   0,   0,
+  0,   0,   0,   0,
+  0,   0,   0,   0,
+  0,   0,   0,   0,    
+  0,   0,   0,   0,
+  0,   0,   0,   0,
+  0,   0,   0,   0,
+  0,   0,   0,   0,    
+  0,   0,   0,   0,
+  0,   0,   0,   0,
+  0,   0,   0,   0,
+  0,   0,   0,   0,    
+
+ 50,  50,  50,  50,
+ 50,  50,  50,  50,
+ 50,  50,  50,  50,
+ 45,  45,  45,  45,
+ 50,  50,  50,  50,
+ 45,  45,  45,  45,
+ 50,  50,  50,  50,
+ 45,  45,  45,  45,
+ 50,  50,  50,  50,
+ 45,  45,  45,  45,
+ 50,  50,  50,  50,
+ 50,  50,  50,  50,
+
+ 56,  44,  44,  44,
+ 44,  44,  44,  56,
+ 52,  40,  40,  40,
+ 40,  40,  40,  52,
+ 52,  40,  40,  40,
+ 40,  40,  40,  52,
+ 52,  40,  40,  40,
+ 40,  40,  40,  52,
+ 52,  44,  44,  44,
+ 44,  44,  44,  56,
+ 56,  52,  52,  52,
+ 52,  52,  52,  56,
+ 
+ 32, 255,  25,   0,
+ 48,   6,   8,   0,
+  0,   0,   0,   0,
+  0,   0,   0,   0,    
+  0,   0,   0,  12,
+  2,   2,   1, 150,
+ 20, 255,   0,   0,
+  0,   0,  64,  64,  
+ 64,  64,  64,  64,
+ 64,  64,  64,  64,
+ 64,  64,  64,  64,
+ 64,  64,   0,   0,  
+ 64,  64,  64,  64,
+ 64,  64,  64,  64,
+ 64,  64,  64,  64,
+ 64,  64,  64,  64,
+  3,   6,   8,   3,
+  0,   0,   0,   0,
+  0,   0,   0,   0,
+  0,  33,   0,   6,    
+ 16,   6,  16,  16,
+ 16,   0,  75,   0,
+ 50,   0,   0,   0,
+ 13,  10,   0,   0,
+  0
+#else  
+ 0, 0, 0, 0,
+ 0, 0, 0, 0,
+ 0, 0, 0, 0,
+ 0, 0, 0, 0,
+ 0, 0, 0, 0,
+ 0, 0, 0, 0,
+ 0, 0, 0, 0,
+ 0, 0, 0, 0,
+ 0, 0, 0, 0,
+ 0, 0, 0, 0,
+ 0, 0, 0, 0,
+ 0, 0, 0, 0,
+
+ 48, 48, 48, 48,  
+ 48, 48, 49, 49,  
+ 48, 48, 48, 48,  
+ 48, 48, 49, 49,  
+ 48, 48, 48, 48,  
+ 48, 48, 48, 48,  
+ 48, 48, 48, 48,  
+ 48, 48, 48, 48,  
+ 48, 48, 48, 48,  
+ 48, 48, 49, 49,  
+ 48, 48, 48, 48,  
+ 48, 48, 49, 49,  
+
+ 56, 44, 48, 48,
+ 48, 48, 48, 60,
+ 56, 36, 40, 40,
+ 40, 40, 40, 60,
+ 56, 40, 44, 44,
+ 44, 44, 44, 60,
+ 56, 40, 44, 44,
+ 44, 44, 44, 60,
+ 56, 40, 44, 44,
+ 44, 44, 44, 60,
+ 60, 52, 56, 56,
+ 56, 56, 56, 72,
+ 
+ 16, 255,  50,   0,
+ 48,   6,   8,   0,
+  0,   0,   0,   0,
+  0,   0,   0,   0,
+  0,   0,   0,  12,
+  1,   2,   0, 150,
+  5, 255,   0,   0,
+  0,   0,  64,  64,  
+ 64,  64,  64,  64,
+ 64,  64,  64,  64,
+ 64,  64,  64,  64,
+ 64,  64,   0,   0,  
+ 64,  64,  64,  64,
+ 64,  64,  64,  64,
+ 64,  64,  64,  64,
+ 64,  64,  64,  64,
+  2,   6,   8,   3,
+  0,   0,   1,   0,
+  0,   0,  25,   0,
+  0,  26,   0,   6,
+ 16,   6,  16,  16,
+ 16,   0,  75,   0,
+ 50,   0,   0,   0,
+ 13,  10,   0,   0,
+  0
+
+#endif
+};
+
+
+static u16 g_CRC_poly = 0x8005;
+	
+//
+// Calculate and check using given CRC
+//
+static u16 Calculate_CRC(u8 aChannel, u16 aOldCRC)
+	{
+	int i;
+	u32 result;
+
+	result = ((u32)aOldCRC << 8) | aChannel;
+
+	for(i = 0; i < 8; i++)
+		{
+		if((result <<= 1) & 0x1000000)
+			{
+			result ^= ((u32)g_CRC_poly << 8);
+			}
+		}
+	return (u16)(result >> 8);
+	}
+
+//
+// Calculate_Config_Checksum
+//
+static u16 Calculate_Config_Checksum(void)
+	{
+ 	int i;
+	u16 CRC_val=0;
+
+	ENTER_FUNC;
+	for(i = 0; i < sizeof(g_qt5480_setup); i++)
+		{
+		CRC_val = Calculate_CRC(g_qt5480_setup[i], CRC_val);
+		}
+
+	LEAVE_FUNC;
+	return (CRC_val);
+	}
+
+//
+// qt5480_i2c_write
+//
+static int qt5480_i2c_write(u16 aRegister, u8 aData)
+	{
+	struct i2c_msg wmsg;
+	u8 wbuf[3];
+	int ret;
+
+	ENTER_FUNC;
+	wbuf[0] = aRegister & 0xFF;
+	wbuf[1] = (aRegister & 0xFF00) >> 8;
+	wbuf[2] = aData;
+
+	wmsg.addr = g_qt5480_ts_driver->client->addr;
+	wmsg.flags = 0;
+	wmsg.len = sizeof(wbuf);
+	wmsg.buf = wbuf;
+
+	ret = i2c_transfer(g_qt5480_ts_driver->client->adapter, &wmsg, 1);
+
+	LEAVE_FUNC;
+	return ret;
+	}
+
+//
+// qt5480_i2c_read
+//
+static int qt5480_i2c_read(u8 *aBuf, int aBufSize)
+	{
+	struct i2c_msg rmsg;
+	int ret;
+
+	ENTER_FUNC;
+	rmsg.addr = g_qt5480_ts_driver->client->addr;
+	rmsg.flags = I2C_M_RD;
+	rmsg.len = aBufSize;
+	rmsg.buf = aBuf;
+
+	ret = i2c_transfer(g_qt5480_ts_driver->client->adapter, &rmsg, 1);
+
+	LEAVE_FUNC;
+	return ret;
+	}
+
+//
+// qt5480_check_chip_id
+//
+static int qt5480_check_chip_id(int aId) 
+	{
+	u8 read_buf[5];
+	int ret, retry = 10;
+
+	ENTER_FUNC;
+    ret = qt5480_i2c_write(REG_LP_MODE, 32);		//Write LPmode
+    DO_IF_TRUE(ret < 0, PRINT_MSG("write LP Register address failed(%d)!\n", ret));
+	
+	do
+		{
+		ret = qt5480_i2c_write(REG_ADDRESS_POINTER, REG_CHIP_ID>>2);
+		DO_IF_TRUE(ret < 0, PRINT_MSG("write Register address failed(%d)!\n", ret));
+
+		if(ret >= 0)
+			{
+			ret = qt5480_i2c_read(read_buf, BASIC_READ_COUNT);
+			if(ret >= 0)
+				{
+				DEBUG_MSG("Chip ID(0x00): %x %x %x\n", read_buf[0], read_buf[1], read_buf[2]);
+				if(read_buf[1] == aId)
+					{
+					DEBUG_MSG("Chip ID check OK!\n");
+					return read_buf[1];
+					}
+				}
+			else
+				{
+				PRINT_MSG("Chip ID read failed. retry:%d \n", retry);
+				}
+			}
+		
+		msleep(100);
+		}while(--retry);
+
+	LEAVE_FUNC;
+	return -1;
+	}
+
+//
+// qt5480_verify_checksum
+//
+static int qt5480_verify_checksum(void) 
+	{
+	u16 checksum;
+	u8 read_buf[5];
+	int ret, retry = 10;
+
+	ENTER_FUNC;
+	checksum = Calculate_Config_Checksum();
+	DEBUG_MSG("setup code Checksum: 0x%08x\n", checksum);
+
+	do
+		{
+		ret = qt5480_i2c_write(REG_ADDRESS_POINTER, REG_EEPROM_CHKSUM >> 2);
+		DO_IF_TRUE(ret < 0, PRINT_MSG("checksum write failed\n"));
+		
+		if ((ret >= 0) && (ret = qt5480_i2c_read(read_buf, BASIC_READ_COUNT))) 
+			{
+			DO_IF_TRUE(ret < 0, PRINT_MSG("checksum read failed. retry:%d \n", retry));
+
+			if (ret >= 0) 
+				{
+				DEBUG_MSG("read Checksum: 0x%02x, 0x%02x, 0x%02x\n", read_buf[0], read_buf[3], read_buf[4]);
+			
+				if((read_buf[3] == (checksum&0xff)) && (read_buf[4] == ((checksum>>8)&0xff))) 
+					{
+					return 0;
+					}
+				}
+			}
+		msleep(10);
+		}while(--retry);
+
+	LEAVE_FUNC;
+	return -1;
+	}
+
+//
+// qt5480_write_setup_code
+//
+static int qt5480_write_setup_code(void) 
+	{
+	u16 reg_addr;
+	int i, ret;
+
+	ENTER_FUNC;
+	//WRITE SETUP CODE
+	reg_addr = REG_CHANNEL_CONTROL;
+	PRINT_MSG("setup code size: %d\n", sizeof(g_qt5480_setup));
+	
+	for(i = 0; i < sizeof(g_qt5480_setup); i++, reg_addr++) 
+		{
+		ret = qt5480_i2c_write(reg_addr, g_qt5480_setup[i]);
+		DO_IF_TRUE(ret < 0, PRINT_MSG("setup code(0x%x) write failed\n", reg_addr));
+		
+		DEBUG_MSG("reg_addr: %4d = g_qt5480_setup[%04d] : 0x%02x\n", reg_addr, i, g_qt5480_setup[i]);
+		}
+		
+	ret = qt5480_i2c_write(REG_BACKUP_REQUEST, 0x55);
+	DO_AND_RETURN_VALUE_IF_TRUE(ret < 0, PRINT_MSG("backup write failed.\n"), -1);
+
+	DEBUG_MSG("backup write success.\n");
+	return 0;
+	}
+
+//
+// qt5480_work_func
+//
+u8 palm_touch = 0;
+u8 TouchFlag = 0,DoubleCalFlag= 0;
+static void qt5480_work_func(struct work_struct *aWork)
+	{
+	int ret;
+	int x, y, cal_x, cal_y;
+    u8 read_buf[5];
+
+	ENTER_FUNC;
+	ret = qt5480_i2c_read(read_buf, BASIC_READ_COUNT);
+	DEBUG_MSG(" 0x%x 0x%x 0x%x 0x%x 0x%x\n",read_buf[0], read_buf[1], read_buf[2], read_buf[3], read_buf[4]);
+	enable_irq(g_qt5480_ts_driver->client->irq);
+	
+	DO_AND_RETURN_IF_TRUE(ret < 0, PRINT_MSG("i2c read failed.\n"));
+
+
+#ifdef  CONFIG_CPU_FREQ
+	set_dvfs_perf_level();
+#endif
+
+	// buf[0] == most significant 8 bits of the address
+	if(read_buf[0] == 3) 
+		{
+		if((read_buf[3] & 0x20) == 0x20) 
+			{
+			palm_touch = 1;///
+//			qt5480_i2c_write(REG_CALIBRATE, 0x55);///
+			DEBUG_MSG("palm_touch : %d  %x\n", palm_touch, read_buf[3]);
+			}
+		else if((read_buf[3] & 0x20) == 0x00) 
+			{
+			if(palm_touch == 1)
+				{
+				palm_touch = 0;
+				DEBUG_MSG("palm_touch : %d  %x\n", palm_touch, read_buf[3]);
+				qt5480_i2c_write(REG_CALIBRATE, 0x55);
+				msleep(10);
+				DEBUG_MSG("Palm Release Cal\n");
+				}
+			}
+		if(palm_touch == 0)
+			{
+			if((read_buf[4]&0x40) == 0x40) 
+				{
+				PRINT_MSG("Calibrating : %x\n", read_buf[4]);
+				}
+			else if((read_buf[4]&0x81) == 0x81)  // Press
+				{ 
+//				input_report_key(g_qt5480_ts_driver->input_dev, BTN_TOUCH, 1);
+//				input_sync(g_qt5480_ts_driver->input_dev);
+				TouchFlag = 1;
+				if((read_buf[4]&0x10) == 0x10) 
+					{
+					TouchFlag = 0;
+					DoubleCalFlag = 1;
+					qt5480_i2c_write(REG_CALIBRATE, 0x55);
+					msleep(10);
+					PRINT_MSG("Calibrated: %x\n", read_buf[4]);
+					}
+				}
+			else if(read_buf[4] == 0x00) // Release
+				{
+				input_report_key(g_qt5480_ts_driver->input_dev, BTN_TOUCH, 0);
+				input_sync(g_qt5480_ts_driver->input_dev);
+				TouchFlag = 0;
+				if(DoubleCalFlag == 1)
+					{
+					DoubleCalFlag = 0;
+					qt5480_i2c_write(REG_CALIBRATE, 0x55);
+					msleep(10);
+					PRINT_MSG("Calibrated: %x\n", read_buf[4]);
+					}
+				}		
+			else 
+				{
+				PRINT_MSG("unknown press code : %x\n", read_buf[4]);
+				DO_IF_TRUE(read_buf[4] & 0x20, PRINT_MSG("ERROR BIT set\n"));
+				}
+			}
+		else if(read_buf[3] == 0xFF && read_buf[4] == 0xFF)
+			{
+			input_report_key(g_qt5480_ts_driver->input_dev, BTN_TOUCH, 0);
+			input_sync(g_qt5480_ts_driver->input_dev);
+			TouchFlag = 0;
+			}
+			
+		}
+	else if (read_buf[0] == 4) // indicates a change in te status bytes 16 - 19
+		{
+		y = (read_buf[1]<<2) + ((read_buf[2]>>6)& 0x3);
+		x = (read_buf[3]<<2) + ((read_buf[4]>>6)& 0x3);
+			
+#if (CONFIG_SPICA_REV > CONFIG_SPICA_TEST_REV00)
+		cal_x = (x * 320) / 1024;
+		cal_y = (y * 480) / 1024;
+#else
+		cal_x = ((1024 - x) * 240) / 1024;
+		cal_y = ((1024 - y) * 400) / 1024;
+#endif
+
+		if(palm_touch == 0)
+			{
+			if(TouchFlag)
+				{
+				if(x)	
+					{
+					input_report_abs(g_qt5480_ts_driver->input_dev, ABS_X, cal_x);
+					}
+				
+				if(y)
+					{
+					input_report_abs(g_qt5480_ts_driver->input_dev, ABS_Y, cal_y);
+					}
+				
+				if(TouchFlag == 1)
+					{
+					input_report_key(g_qt5480_ts_driver->input_dev, BTN_TOUCH, 1);
+					TouchFlag = 2;
+					}
+				input_sync(g_qt5480_ts_driver->input_dev);
+				
+				}
+			}
+		}
+	else if((read_buf[0] == 0xFF) &&(read_buf[4] == 0x00))// Release
+		{
+		input_report_key(g_qt5480_ts_driver->input_dev, BTN_TOUCH, 0); 
+		input_sync(g_qt5480_ts_driver->input_dev);
+		TouchFlag = 0;
+		}
+	else
+		{
+		// If the chip is read when the CHANGE line is not asserted, 
+		// it returns a packet with the header byte 0xFF, indicating that the packet data is invalid.
+		PRINT_MSG("unknown code: %x\n", read_buf[0]);
+		}
+	
+//	enable_irq(g_qt5480_ts_driver->client->irq);
+
+	LEAVE_FUNC;
+	}
+
+//
+// qt5480_irq_handler
+//
+static irqreturn_t qt5480_irq_handler(int irq, void *dev_id)
+	{
+	ENTER_FUNC;
+	disable_irq(g_qt5480_ts_driver->client->irq);
+	queue_work(g_qt5480_work_queue, &g_qt5480_ts_driver->work);
+	LEAVE_FUNC;
+	return IRQ_HANDLED;
+	}
+
+//
+// qt5480_read_status
+//
+static int qt5480_read_status(u16 aAddress, u8 *aData)
+	{
+	struct i2c_msg wmsg;
+	int ret;
+	
+	ENTER_FUNC;
+	
+	// read current state
+	wmsg.addr = aAddress;
+	wmsg.flags = I2C_M_RD;
+	wmsg.len = 1;
+	wmsg.buf = aData;
+
+	ret = i2c_transfer(g_qt5480_ts_driver->client->adapter, &wmsg, 1);
+	DEBUG_MSG("Current state[%d]\n", (u8)*aData);
+
+	LEAVE_FUNC;
+	return ret;
+	}
+
+//
+// qt5480_reset
+// H/W reset and wait until it works well
+//
+static void qt5480_reset(void)
+	{
+	int ret = 0;
+	int retry_count = 0;
+	
+	// H/W reset
+	gpio_set_value(GPIO_TOUCH_RST, 0);  // TOUCH RST
+	msleep(10);
+	gpio_set_value(GPIO_TOUCH_RST, 1);  // TOUCH RST
+
+	// we need to verify there is no problem to communicate with TSP for the follows
+	do
+		{
+		u8 status = 0;
+		msleep(20);
+		ret = qt5480_read_status(g_qt5480_ts_driver->client->addr, &status);
+		} while(ret < 0 && retry_count++ < 100);			
+	}
+
+//
+// Update firmware
+//
+static int qt5480_update_firmware(void)
+	{
+	struct i2c_msg wmsg;
+	u8 wbuf[4];
+	int ret;
+	int character_position = 0;
+	int retry_count = 0;
+	int frame_size = 0;
+
+	ENTER_FUNC;
+
+	// Entering the bootloader mode
+	PRINT_MSG("Updating firmware...\nEntering the bootloader mode...\n");
+
+	do
+		{
+		msleep(10);
+		wbuf[0] = 0x00;
+		wbuf[1] = 0xDC;
+		wbuf[2] = 0xAA;
+		wbuf[3] = 0x55;
+		
+		wmsg.addr = g_qt5480_ts_driver->client->addr;
+		wmsg.flags = 0;
+		wmsg.len = sizeof(wbuf);
+		wmsg.buf = wbuf;
+
+		ret = i2c_transfer(g_qt5480_ts_driver->client->adapter, &wmsg, 1);
+		}while(ret < 0 && retry_count++ < 30);
+
+	DO_IF_TRUE(retry_count >= 30, qt5480_reset());
+	DO_AND_RETURN_VALUE_IF_TRUE(retry_count >= 30, PRINT_MSG("Entering the bootloader mode failed(%d)!\n", ret), -1);
+	
+	retry_count = 0;
+
+	// updating
+	do
+		{
+		u8 status = 0;
+
+		msleep(5);	// KSS : We need to add delay for 5 ms. But it doesn't be mentioned by any documents or reference code.
+		ret = qt5480_read_status(QT5480_BOOTLOADER_MODE_I2C_ADDR>>1, &status);
+		DO_IF_TRUE(ret < 0, PRINT_MSG("qt5480_read_status failed(%d)\n", ret));
+
+		// do something according to the current status
+		switch(status)
+			{
+			case 0x0:	// POWER ON
+				// do nothing
+				break;
+			case 0x1:	// WAITING FRAME DATA
+				{
+				u8* current_data = NULL;
+				int count;
+				
+				// send the firmware data
+				frame_size = ((firmware_data[character_position])*16)+(firmware_data[character_position+1])+2;
+				if(frame_size == 2)
+					{
+					// reset TSP
+					qt5480_reset();
+					return 0;
+					}
+
+				// alloc memory for the current frame
+				current_data = kmalloc(frame_size, GFP_KERNEL);
+				if(!current_data)
+					{
+					PRINT_MSG("Alloc free memory for current firmware data was failed!");
+					return -2;
+					}
+
+				// copy from firmware_data for current frame
+				for(count = 0; count < frame_size; count++)
+					{
+					current_data[count] = firmware_data[character_position+count];
+					}
+				
+				wmsg.addr = QT5480_BOOTLOADER_MODE_I2C_ADDR>>1;
+				wmsg.flags = 0;
+				wmsg.len = frame_size;
+				wmsg.buf = current_data;
+
+				ret = i2c_transfer(g_qt5480_ts_driver->client->adapter, &wmsg, 1);
+
+				// free memory
+				kfree(current_data);
+
+				// check result
+				DO_AND_RETURN_VALUE_IF_TRUE(ret < 0, PRINT_MSG("Writing firmware data was failed(%d)!\n", ret), ret);
+
+				character_position += frame_size;
+				}
+				break;
+			case 0x2:	// FRAME CRC CHECK
+				// do nothing
+				break;
+			case 0x3:	// FRAME CRC ERROR
+				character_position -= frame_size;
+				break;
+			case 0x4:	// FRAME CRC PASS
+				{
+				if(firmware_data[character_position] == 0 && firmware_data[character_position+1] == 0)
+					{
+					PRINT_MSG("Update QT5480 successfully.\n");
+					msleep(100);	// KSS : Add delay for 100 ms to avoid an error while writing new firmware.
+					// reset TSP
+					qt5480_reset();
+					return 0;					
+					}
+				}
+				break;
+			default:	// APP CRC FAIL
+				{
+				// reset TSP
+				qt5480_reset();
+				return -3;
+				}				
+			}
+		
+		}while(1==1);
+	}
+
+//
+// read code version from register 1 and update firmware if code version is 5.2
+//
+static int qt5480_check_code_version_update_firmware(void)
+	{
+	int ret;
+	u8 read_buf[5];
+	char major_version, minor_version;
+	
+	ENTER_FUNC;
+
+	do
+		{
+		ret = qt5480_i2c_write(REG_ADDRESS_POINTER, REG_CHIP_ID>>2);
+		DO_IF_TRUE(ret < 0, PRINT_MSG("write Register address failed(%d)!\n", ret));
+
+		ret = qt5480_i2c_read(read_buf, BASIC_READ_COUNT);
+		PRINT_MSG("CODE(2) version [%x %x %x %x %x]\n", read_buf[0], read_buf[1], read_buf[2], read_buf[3], read_buf[4]);
+		DO_AND_RETURN_VALUE_IF_TRUE(ret < 0, PRINT_MSG("i2c read failed(%d)!\n", ret), ret);
+		} while(read_buf[0] != (REG_CHIP_ID>>2));
+	
+	// save version
+	major_version = read_buf[2];
+	
+	msleep(5);
+
+	do
+		{
+		ret = qt5480_i2c_write(REG_ADDRESS_POINTER, 37>>2);
+		DO_IF_TRUE(ret < 0, PRINT_MSG("write Register address failed(%d)!\n", ret));
+
+		ret = qt5480_i2c_read(read_buf, BASIC_READ_COUNT);
+		PRINT_MSG("CODE(3) version [%x %x %x %x %x]\n", read_buf[0], read_buf[1], read_buf[2], read_buf[3], read_buf[4]);
+		DO_AND_RETURN_VALUE_IF_TRUE(ret < 0, PRINT_MSG("i2c read failed(%d)!\n", ret), ret);
+		} while(read_buf[0] != (37>>2));
+	
+	minor_version = read_buf[2];
+	
+	// if the code version is 0x52 and then update firmware now.
+	if(major_version != 0x55 || minor_version != 0x2)
+		{
+		// reset
+		qt5480_i2c_write(REG_RESET, 0xaa);
+		msleep(30);
+		
+		return qt5480_update_firmware();
+		}
+
+	return 0;
+	}
+
+//
+// qt5480_probe
+//
+static int qt5480_probe(struct platform_device *aDevice)
+	{
+	int ret = 0;
+	char read_buf[5];
+	
+	ENTER_FUNC;
+	if(!i2c_check_functionality(g_qt5480_ts_driver->client->adapter, I2C_FUNC_I2C)) 
+		{
+		printk(KERN_ERR "[QT5480]:[%s] need I2C_FUNC_I2C\n", __func__);
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+		}
+
+	INIT_WORK(&g_qt5480_ts_driver->work, qt5480_work_func);
+
+	do
+		{
+		udelay(10);
+		qt5480_i2c_read(read_buf, BASIC_READ_COUNT);
+		} while(!gpio_get_value(GPIO_TOUCH_INT_N));
+
+	if(qt5480_check_chip_id(QT5480_CHIP_ID) < 0)
+		{
+		goto err_chip_id_check_failed;
+		}
+
+	// check firmware version
+	// comment out temporarily
+	if(qt5480_check_code_version_update_firmware())
+		{
+		if(qt5480_check_chip_id(QT5480_CHIP_ID) < 0)
+			{
+			goto err_chip_id_check_failed;
+			}
+		}
+	
+	DO_IF_TRUE((qt5480_verify_checksum() < 0) && (qt5480_write_setup_code() < 0), PRINT_MSG("write setup code failed...\n"));
+
+	//CAL
+	ret = qt5480_i2c_write(REG_CALIBRATE, 0x55);
+	DO_IF_TRUE(ret < 0, PRINT_MSG("calibrate write failed\n"));
+
+	g_qt5480_ts_driver->input_dev = input_allocate_device();
+	if (g_qt5480_ts_driver->input_dev == NULL) 
+		{
+		ret = -ENOMEM;
+		printk(KERN_ERR "[QT5480]:[%s] Failed to allocate input device\n", __func__);
+		goto err_input_dev_alloc_failed;
+		}
+	
+	g_qt5480_ts_driver->input_dev->name = "qt5480_ts_input";
+	set_bit(EV_SYN, g_qt5480_ts_driver->input_dev->evbit);
+	set_bit(EV_KEY, g_qt5480_ts_driver->input_dev->evbit);
+	set_bit(BTN_TOUCH, g_qt5480_ts_driver->input_dev->keybit);
+	set_bit(EV_ABS, g_qt5480_ts_driver->input_dev->evbit);
+	
+#if (CONFIG_SPICA_REV > CONFIG_SPICA_TEST_REV00)
+	input_set_abs_params(g_qt5480_ts_driver->input_dev, ABS_X, 0, 320, 0, 0);
+	input_set_abs_params(g_qt5480_ts_driver->input_dev, ABS_Y, 0, 480, 0, 0);
+#else
+	input_set_abs_params(g_qt5480_ts_driver->input_dev, ABS_X, 0, 240, 0, 0);
+	input_set_abs_params(g_qt5480_ts_driver->input_dev, ABS_Y, 0, 400, 0, 0);
+#endif	
+
+	input_set_abs_params(g_qt5480_ts_driver->input_dev, ABS_PRESSURE, 0, 255, 0, 0);
+	input_set_abs_params(g_qt5480_ts_driver->input_dev, ABS_TOOL_WIDTH, 0, 15, 0, 0);
+
+	ret = input_register_device(g_qt5480_ts_driver->input_dev);
+	if (ret) 
+		{
+		printk(KERN_ERR "[QT5480]:[%s] Unable to register %s input device\n", __func__, g_qt5480_ts_driver->input_dev->name);
+		goto err_input_register_device_failed;
+		}
+
+	ret = request_irq(g_qt5480_ts_driver->client->irq, qt5480_irq_handler, IRQF_DISABLED, "qt5480 irq", 0);
+	if (ret == 0) 
+		{
+		PRINT_MSG("Start touchscreen %s\n", g_qt5480_ts_driver->input_dev->name);
+		}
+	else 
+		{
+		PRINT_MSG("Request_irq failed\n");
+		}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	g_qt5480_ts_driver->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	g_qt5480_ts_driver->early_suspend.suspend = qt5480_early_suspend;
+	g_qt5480_ts_driver->early_suspend.resume = qt5480_late_resume;
+	register_early_suspend(&g_qt5480_ts_driver->early_suspend);
+#endif	// End of CONFIG_HAS_EARLYSUSPEND
+
+	return 0;
+
+err_input_register_device_failed:
+	input_free_device(g_qt5480_ts_driver->input_dev);
+
+err_input_dev_alloc_failed:
+err_chip_id_check_failed:
+	kfree(g_qt5480_ts_driver);
+	
+err_check_functionality_failed:
+	LEAVE_FUNC;
+	return ret;
+}
+
+//
+// qt5480_remove
+//
+static int qt5480_remove(struct platform_device *aDevice)
+	{
+	ENTER_FUNC;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&g_qt5480_ts_driver->early_suspend);
+#endif	// End of CONFIG_HAS_EARLYSUSPEND
+
+	free_irq(g_qt5480_ts_driver->client->irq, 0);
+	input_unregister_device(g_qt5480_ts_driver->input_dev);
+	kfree(g_qt5480_ts_driver);
+
+	LEAVE_FUNC;
+	return 0;
+	}
+
+//
+// check_touch_int
+//
+static void check_touch_int(void)
+	{
+	int ret = 0, retry = 0;
+	u8 read_buf[5];
+
+	ENTER_FUNC;
+	while(!(gpio_get_value(GPIO_TOUCH_INT_N))) 
+		{
+		ret = qt5480_i2c_read(read_buf, BASIC_READ_COUNT);
+		DO_IF_TRUE(ret < 0, PRINT_MSG("i2c read failed.\n"));
+
+		retry++;		
+		if(retry > 10) 
+			{
+			PRINT_MSG("TOUCH Interrupt recovery failed.\n");
+			break;
+			}
+		}
+	LEAVE_FUNC;
+	}
+
+//
+// qt5480_suspend
+//
+static int qt5480_suspend(pm_message_t mesg)
+	{
+	int ret = 0, retry = 0;
+	u8 read_buf[5];
+
+	ENTER_FUNC;
+	disable_irq(g_qt5480_ts_driver->client->irq);
+
+	check_touch_int();
+
+	ret = qt5480_i2c_write(REG_STATUS_MASK, 0); // Status Mask
+	DO_IF_TRUE(ret < 0, PRINT_MSG("write Status Mask failed(%d)!\n", ret));
+
+	while (1) 
+		{
+		ret = qt5480_i2c_write(REG_AWAKE_TIMEOUT, BASIC_READ_COUNT); // Awake Timeout
+		DO_IF_TRUE(ret < 0, PRINT_MSG("write Awake Timeout Register failed(%d)!\n", ret));
+
+		ret = qt5480_i2c_write(REG_ADDRESS_POINTER, REG_AWAKE_TIMEOUT>>2);
+		DO_IF_TRUE(ret < 0, PRINT_MSG("write Awake Timeout Register address failed(%d)!\n", ret));
+
+		ret = qt5480_i2c_read(read_buf, BASIC_READ_COUNT);
+		DO_IF_TRUE(ret < 0, PRINT_MSG("Awake Timeout read failed(%d)!\n", ret));
+
+		DEBUG_MSG("Awake Timeout read: (%x)\n", read_buf[3]);
+
+		if (read_buf[3] == 0x05)
+			{
+			break;
+			}
+		if (++retry > 10)
+			{
+			PRINT_MSG("Writing Awake Timeout reached over 10!\n");
+			break;
+			}
+		}
+
+	retry = 0;
+	while (1) 
+		{
+		ret = qt5480_i2c_write(REG_LP_MODE, 0); // LP Mode
+		DO_IF_TRUE(ret < 0, PRINT_MSG("write LP Mode Register failed(%d)!\n", ret));
+
+		ret = qt5480_i2c_write(REG_ADDRESS_POINTER, REG_LP_MODE>>2);
+		DO_IF_TRUE(ret < 0, PRINT_MSG("write LP Mode Register address failed(%d)!\n", ret));
+
+		ret = qt5480_i2c_read(read_buf, BASIC_READ_COUNT);
+		DO_IF_TRUE(ret < 0, PRINT_MSG("LP Mode read failed(%d)!\n", ret));
+
+		DEBUG_MSG("LP Mode read: (%x)\n", read_buf[1]);
+
+		if (read_buf[1] == 0x00)
+			{
+			break;
+			}
+		if (++retry > 10)
+			{
+			PRINT_MSG("Writing LP Mode reached over 10!\n");
+			break;
+			}
+		}
+	
+	LEAVE_FUNC;
+	return 0;
+	}
+
+//
+// qt5480_resume
+//
+static int qt5480_resume(void)
+	{
+	int ret;
+
+	ENTER_FUNC;
+	ret = qt5480_i2c_write(REG_LP_MODE, 32); // LP Mode
+	DO_IF_TRUE(ret < 0, PRINT_MSG("write LP Mode Register failed(%d)!\n", ret));
+
+	ret = qt5480_i2c_write(REG_AWAKE_TIMEOUT, 50);  // Awake Timeout
+	DO_IF_TRUE(ret < 0, PRINT_MSG("write Awake Timeout  Register failed(%d)!\n", ret));
+
+	ret = qt5480_i2c_write(REG_STATUS_MASK, 6); // Status Mask
+	DO_IF_TRUE(ret < 0, PRINT_MSG(" write Status Mask Register failed(%d)!\n", ret));
+
+	ret = qt5480_i2c_write(REG_CALIBRATE, 0x55);
+	DO_IF_TRUE(ret < 0, PRINT_MSG("calibrate write failed(%d)!\n", ret));
+
+	msleep(10);
+	
+	check_touch_int();
+
+	enable_irq(g_qt5480_ts_driver->client->irq);
+
+	LEAVE_FUNC;
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+//
+// qt5480_early_suspend
+//
+static void qt5480_early_suspend(struct early_suspend *h)
+	{
+	qt5480_suspend(PMSG_SUSPEND);
+	}
+
+//
+// qt5480_late_resume
+//
+static void qt5480_late_resume(struct early_suspend *h)
+	{
+	qt5480_resume();
+	}
+#endif	// End of CONFIG_HAS_EARLYSUSPEND
+
+
+//
+// qt5480_attach
+//
+static int qt5480_attach(struct i2c_adapter *aAdapter, int aAddress, int aKind)
+	{
+	struct i2c_client *c;
+	int ret;
+
+	ENTER_FUNC;
+	c = kmalloc(sizeof(*c), GFP_KERNEL);
+	if(!c)
+		{
+		return -ENOMEM;
+		}
+	
+	memset(c, 0, sizeof(struct i2c_client));
+	
+	strcpy(c->name, "qt5480");
+	c->addr = aAddress;
+	c->adapter = aAdapter;
+	c->irq = IRQ_TOUCH_INT;
+	c->driver = &g_qt5480_i2c_driver;
+	
+	if((ret = i2c_attach_client(c)) < 0)
+		goto error;
+
+	g_qt5480_ts_driver->client = c;
+
+	DEBUG_MSG("i2c is attached(0x%x)..\n", aAddress);
+
+	LEAVE_FUNC;
+error:
+	return ret;
+	}
+
+
+//
+// i2c_attach_adapter
+//
+static int i2c_attach_adapter(struct i2c_adapter *aAdapter)
+	{
+	ENTER_FUNC;
+	return i2c_probe(aAdapter, &g_qt5480_addr_data, qt5480_attach);
+	}
+
+//
+// init_hw_setting
+//
+static void init_hw_setting(void)
+	{
+	ENTER_FUNC;
+	s3c_gpio_cfgpin(GPIO_TOUCH_INT_N, S3C_GPIO_SFN(GPIO_TOUCH_INT_N_AF));
+	s3c_gpio_setpull(GPIO_TOUCH_INT_N, S3C_GPIO_PULL_NONE); 
+	
+	set_irq_type(IRQ_TOUCH_INT, IRQ_TYPE_EDGE_FALLING);
+
+	if (gpio_is_valid(GPIO_TOUCH_EN)) 
+		{
+		if (gpio_request(GPIO_TOUCH_EN, S3C_GPIO_LAVEL(GPIO_TOUCH_EN)))
+			{
+			printk(KERN_ERR "Filed to request GPIO_TOUCH_EN!\n");
+			}
+		gpio_direction_output(GPIO_TOUCH_EN, GPIO_LEVEL_LOW);
+		}
+	
+	s3c_gpio_setpull(GPIO_TOUCH_EN, S3C_GPIO_PULL_NONE); 
+/*	
+	if (gpio_is_valid(GPIO_TOUCH_RST)) 
+		{
+		if (gpio_request(GPIO_TOUCH_RST, S3C_GPIO_LAVEL(GPIO_TOUCH_RST)))
+			{
+			printk(KERN_ERR "Filed to request GPIO_TOUCH_EN!\n");
+			}
+		gpio_direction_output(GPIO_TOUCH_RST, GPIO_LEVEL_LOW);
+		}
+	s3c_gpio_setpull(GPIO_TOUCH_RST, S3C_GPIO_PULL_NONE); 
+*/	
+	LEAVE_FUNC;
+	}
+
+//
+// i2c_show
+//
+static ssize_t i2c_show(struct device *aDevice, struct device_attribute *aAttribute, s8 *aBuf)
+	{		
+	int ret;
+    u8 read_buf[5];
+
+	ret = qt5480_i2c_read(read_buf, BASIC_READ_COUNT);
+	DO_IF_TRUE(ret < 0, PRINT_MSG("i2c read failed.\n"));
+
+	PRINT_MSG("read: %x, %x, %x, %x, %x\n", read_buf[0], 
+												   read_buf[1], 
+												   read_buf[2], 
+												   read_buf[3], 
+												   read_buf[4]);
+
+	return sprintf(aBuf, "%s\n", read_buf);
+	}
+
+// dummy function
+static ssize_t i2c_store(
+		struct device *dev, struct device_attribute *aAttribute,
+		const char *aBuf, size_t aSize)
+	{
+	return aSize;
+	}
+
+// print the current value of GPIO
+static ssize_t gpio_show(struct device *aDevice, struct device_attribute *aAttribute, s8 *aBuf)
+	{
+	PRINT_MSG("GPIO Status\n");
+	printk("TOUCH_EN  : %s\n", gpio_get_value(GPIO_TOUCH_EN)? "High":"Low");
+	printk("TOUCH_RST : %s\n", gpio_get_value(GPIO_TOUCH_RST)? "High":"Low");
+	printk("TOUCH_INT : %s\n", gpio_get_value(GPIO_TOUCH_INT_N)? "High":"Low");
+
+	return sprintf(aBuf, "%s\n", aBuf);
+	}
+
+//
+// For Test
+// Turn on/off TSP
+// Set TOUCH_RST GPIO high/row
+//
+static ssize_t gpio_store(
+	struct device *aDevice, struct device_attribute *aAttribute,
+	const char *aBuf, size_t aSize)
+	{
+	if(strncmp(aBuf, "ENHIGH", 6) == 0 || strncmp(aBuf, "enhigh", 6) == 0) 
+		{
+		gpio_set_value(GPIO_TOUCH_EN, GPIO_LEVEL_HIGH);
+		PRINT_MSG("set TOUCH_EN High.\n");
+		msleep(100);
+		}
+
+	if(strncmp(aBuf, "ENLOW", 5) == 0 || strncmp(aBuf, "enlow", 5) == 0) 
+		{
+		gpio_set_value(GPIO_TOUCH_EN, GPIO_LEVEL_LOW);
+		PRINT_MSG("set TOUCH_EN Low.\n");
+		msleep(100);
+		}
+
+	if(strncmp(aBuf, "RSTHIGH", 7) == 0 || strncmp(aBuf, "rsthigh", 7) == 0) 
+		{
+		gpio_set_value(GPIO_TOUCH_RST, GPIO_LEVEL_HIGH);
+		PRINT_MSG("set TOUCH_RST High.\n");
+		msleep(100);
+		}
+
+	if(strncmp(aBuf, "RSTLOW", 6) == 0 || strncmp(aBuf, "rstlow", 6) == 0) 
+		{
+		gpio_set_value(GPIO_TOUCH_RST, GPIO_LEVEL_LOW);
+		PRINT_MSG("set TOUCH_RST Low.\n");
+		msleep(100);
+		}
+
+	return aSize;
+	}
+
+// print QT setup status
+static ssize_t setup_show(struct device *aDevice, struct device_attribute *aAttribute, s8 *aBuf)
+	{		
+	int i;
+	PRINT_MSG("Setup Status\n");
+	for(i = 0; i < sizeof (g_qt5480_setup); i++) 
+		{
+		printk("%04d\t", g_qt5480_setup[i]);
+		if(!((i+1)%4)) printk("\n");
+		}
+
+	printk("\n");
+	return sprintf(aBuf, "%s\n", aBuf);
+	
+	}
+
+// Do nothing
+static ssize_t setup_store(struct device *aDevice, struct device_attribute *aAttribute, const char *aBuf, size_t aSize)
+	{
+	int i = 0;
+	int value = 0;
+	const char *ptr = aBuf;
+	
+	printk("%s\n", aBuf);
+
+	for(i = 0; i < sizeof(g_qt5480_setup); i++)
+		{
+		value = 0;
+
+		// skip space, new line
+		while(*ptr < '0' || *ptr > '9')
+			ptr++;
+		
+		while(*ptr >= '0' && *ptr <= '9')
+			{
+			value = value * 10 + (*ptr - '0');
+			ptr++;
+			}
+		g_qt5480_setup[i] = value;
+		}
+	
+	PRINT_MSG("Setup Status\n");
+	for(i = 0; i < sizeof (g_qt5480_setup); i++) 
+		{
+		printk("%04d\t", g_qt5480_setup[i]);
+		if(!((i+1)%4)) printk("\n");
+		}
+
+	printk("\n");
+	
+	qt5480_write_setup_code();
+	qt5480_i2c_write(REG_CALIBRATE, 0x55);
+	
+	return aSize;
+	}
+
+static ssize_t debug_flag_show(struct device *aDevice, struct device_attribute *aAttribute, s8 *aBuf)
+	{
+	PRINT_MSG("debug_flag_show %d\n", show_debug_message);
+	return show_debug_message;
+	}
+
+static ssize_t debug_flag_store(struct device *aDevice, struct device_attribute *aAttribute, const char *aBuf, size_t aSize)
+	{
+	if(*aBuf == '0')
+		show_debug_message = 0;
+	else
+		show_debug_message = 1;
+
+	return show_debug_message;
+	}
+
+// Declaration for the attribute of GPIO/I2C
+static DEVICE_ATTR(gpio, S_IRUGO | S_IWUSR, gpio_show, gpio_store);
+static DEVICE_ATTR(i2c, S_IRUGO | S_IWUSR, i2c_show, i2c_store);
+static DEVICE_ATTR(setup, S_IRUGO | S_IWUSR, setup_show, setup_store);
+static DEVICE_ATTR(debug, S_IRUGO | S_IWUSR, debug_flag_show, debug_flag_store);
+
+//
+// Initialize driver
+//
+int __init qt5480_init(void)
+	{
+	int ret;
+
+	ENTER_FUNC;	
+
+	// initialize H/W - initialize GPIO	
+	init_hw_setting();
+	mdelay(1);
+	
+	// Turn power on - turn on VDD_TOUCH_3.0V
+	gpio_set_value(GPIO_TOUCH_EN, 1);  // TOUCH EN
+	msleep(10);
+
+	if (gpio_is_valid(GPIO_TOUCH_RST)) 
+		{
+		if (gpio_request(GPIO_TOUCH_RST, S3C_GPIO_LAVEL(GPIO_TOUCH_RST)))
+			{
+			printk(KERN_ERR "Filed to request GPIO_TOUCH_EN!\n");
+			}
+		gpio_direction_output(GPIO_TOUCH_RST, GPIO_LEVEL_LOW);
+		}
+	s3c_gpio_setpull(GPIO_TOUCH_RST, S3C_GPIO_PULL_NONE); 
+
+	mdelay(1);
+	
+    gpio_set_value(GPIO_TOUCH_RST, 1);  // TOUCH RST
+	msleep(100);
+	
+	g_qt5480_ts_driver = kzalloc(sizeof(struct ts_driver), GFP_KERNEL);
+	if (g_qt5480_ts_driver == NULL) 
+		{
+		return -ENOMEM;
+		}
+	
+	ret = i2c_add_driver(&g_qt5480_i2c_driver);
+	DO_IF_TRUE(ret, PRINT_MSG("i2c_add_driver failed...(%d)\n", ret));
+
+	if(!(g_qt5480_ts_driver->client)) 
+		{
+		printk("###################################################\n");
+		printk("##                                               ##\n");
+		printk("##    WARNING! TOUCHSCREEN DRIVER CAN'T WORK.    ##\n");
+		printk("##    PLEASE CHECK YOUR TOUCHSCREEN CONNECTOR!   ##\n");
+		printk("##                                               ##\n");
+		printk("###################################################\n");
+		i2c_del_driver(&g_qt5480_i2c_driver);
+		return 0;
+		}
+
+	g_qt5480_work_queue= create_singlethread_workqueue("qt5480_work_queue");
+	if (!g_qt5480_work_queue)
+		{
+		return -ENOMEM;
+		}
+	
+	// create device & use sysfs file system
+	g_ts_dev = device_create(sec_class, NULL, 0, NULL, "ts");
+	if (IS_ERR(g_ts_dev))
+		{
+		pr_err("Failed to create device(ts)!\n");
+		}
+
+	if (device_create_file(g_ts_dev, &dev_attr_gpio) < 0)
+		{
+		pr_err("Failed to create device file(%s)!\n", dev_attr_gpio.attr.name);
+		}
+
+	if (device_create_file(g_ts_dev, &dev_attr_i2c) < 0)
+		{
+		pr_err("Failed to create device file(%s)!\n", dev_attr_i2c.attr.name);
+		}
+
+	if (device_create_file(g_ts_dev, &dev_attr_setup) < 0)
+		{
+		pr_err("Failed to create device file(%s)!\n", dev_attr_setup.attr.name);
+		}
+
+	if (device_create_file(g_ts_dev, &dev_attr_debug) < 0)
+		{
+		pr_err("Failed to create device file(%s)!\n", dev_attr_debug.attr.name);
+		}
+	
+	LEAVE_FUNC;
+	return platform_driver_register(&g_qt5480_driver);
+	}
+
+//
+// Handler for release
+//
+void __exit qt5480_exit(void)
+	{
+	ENTER_FUNC;
+	// stop interrupt handling
+	
+	// destroy work queue first
+	// because we need to remove a chance use i2c driver
+	if (g_qt5480_work_queue)
+		{
+		flush_workqueue(g_qt5480_work_queue);
+		destroy_workqueue(g_qt5480_work_queue);
+		}
+	
+	i2c_del_driver(&g_qt5480_i2c_driver);
+	LEAVE_FUNC;
+	}
+
+
+// initialization is postponed because this driver must be started after i2c driver
+late_initcall(qt5480_init);
+module_exit(qt5480_exit);
+
+
+MODULE_DESCRIPTION("Melfas Touchscreen Driver");
+MODULE_LICENSE("GPL");
+
diff -Nur linux-2.6.29/drivers/input/touchscreen/s3c-ts.c linux-2.6.29-spica/drivers/input/touchscreen/s3c-ts.c
--- linux-2.6.29/drivers/input/touchscreen/s3c-ts.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/input/touchscreen/s3c-ts.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,365 @@
+/* linux/drivers/input/touchscreen/s3c-ts.c
+ *
+ * $Id: s3c-ts.c,v 1.13 2008/11/20 06:00:55 ihlee215 Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/string.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+
+#include <plat/regs-adc.h>
+#include <plat/adcts.h>
+#include <plat/ts.h>
+#include <mach/irqs.h>
+
+#include <plat/regs-gpio.h>
+#include <plat/gpio-cfg.h>
+#ifdef CONFIG_CPU_FREQ
+#include <plat/s3c64xx-dvfs.h>
+#endif /* CONFIG_CPU_FREQ */
+
+#ifdef CONFIG_SAMSUNG_CALIBRATION_MODE
+#include "samsung_cal.h" 
+#endif /* CONFIG_SAMSUNG_CALIBRATION_MODE */
+#define CONFIG_TOUCHSCREEN_S3C_DEBUG
+#undef CONFIG_TOUCHSCREEN_S3C_DEBUG
+
+#define S3C_TSVERSION   0x0101
+
+struct s3c_ts_data {
+        struct input_dev        *dev;
+        int                     xp_old;
+        int                     yp_old;
+};
+
+/*
+ * Definitions & global arrays.
+ */
+static char *s3c_ts_name = "S3C TouchScreen";
+static struct s3c_ts_data 	*data;
+static struct s3c_ts_mach_info 	*ts;
+
+static u32 touch_count = 0;
+static void s3c_ts_done_callback (struct s3c_adcts_value *ts_value)
+{
+	long i, x_sum=0, y_sum=0, x_mean = 0, y_mean = 0, xp = 0, yp = 0;
+	int xp_min, xp_max, yp_min, yp_max;
+
+	if (ts_value->status == TS_STATUS_UP)
+	{
+//		printk(KERN_INFO "[s3c_ts_done_callback] Touch is released\n"); 
+                input_report_key(data->dev, BTN_TOUCH, 0);
+                input_sync(data->dev);
+		data->xp_old= data->yp_old = -1;				
+
+		touch_count = 0;
+		return;
+	}
+	else if (ts_value->status == TS_STATUS_DOWN_NOW)
+	{
+		data->xp_old= data->yp_old = -1;
+	}
+
+	xp_min = yp_min = (1<<12) ;
+	xp_max = yp_max = 0;
+
+	for (i=0; i<ts->sampling_time; i++)
+	{
+		x_sum += ts_value->xp[i];
+		y_sum += ts_value->yp[i];
+		if (xp_min>ts_value->xp[i]) xp_min = ts_value->xp[i];
+		if (xp_max<ts_value->xp[i]) xp_max = ts_value->xp[i];
+		if (yp_min>ts_value->yp[i]) yp_min = ts_value->yp[i];
+		if (yp_max<ts_value->yp[i]) yp_max = ts_value->yp[i];
+	}
+
+#ifdef CONFIG_TOUCHSCREEN_S3C_DEBUG
+	struct timeval tv;
+	do_gettimeofday(&tv);
+	printk(KERN_INFO "[RAW]T: %06d, X: %03ld, Y: %03ld\n", (int)tv.tv_usec, x_sum, y_sum);
+#endif /* CONFIG_TOUCHSCREEN_S3C_DEBUG */
+	if (ts->remove_max_min_sampling)
+	{
+		x_sum -= (xp_min + xp_max);
+		y_sum -= (yp_min + yp_min);
+		x_mean  = x_sum / (ts->sampling_time - 2);
+		y_mean  = y_sum / (ts->sampling_time - 2);
+	}
+	else
+	{
+		x_mean = x_sum / (ts->sampling_time);
+		y_mean = y_sum / (ts->sampling_time);
+	}
+
+#ifdef CONFIG_TOUCHSCREEN_S3C_DEBUG
+	{
+		printk(KERN_INFO "[MEAN_RAW]X: %03ld, Y: %03ld\n", x_mean, y_mean);
+	}
+#endif /* CONFIG_TOUCHSCREEN_S3C_DEBUG */
+
+	if (ts->use_tscal)
+	{
+#ifdef CONFIG_SAMSUNG_CALIBRATION_MODE
+		xp=(long) ((current_cal_val[2]+(current_cal_val[0]*x_mean)+(current_cal_val[1]*y_mean))/current_cal_val[6]);
+	        yp=(long) ((current_cal_val[5]+(current_cal_val[3]*x_mean)+(current_cal_val[4]*y_mean))/current_cal_val[6]);		
+#else /* CONFIG_SAMSUNG_CALIBRATION_MODE */
+		xp=(long) ((ts->tscal[2]+(ts->tscal[0]*x_mean)+(ts->tscal[1]*y_mean))/ts->tscal[6]);
+	        yp=(long) ((ts->tscal[5]+(ts->tscal[3]*x_mean)+(ts->tscal[4]*y_mean))/ts->tscal[6]);	
+#endif /* CONFIG_SAMSUNG_CALIBRATION_MODE */
+	}
+	else
+	{
+		xp=x_mean;
+		yp=y_mean;
+	}
+
+#ifdef CONFIG_TOUCHSCREEN_S3C_DEBUG
+	{				
+		printk(KERN_INFO "[After Cal]X: %03ld, Y: %03ld\n", xp, yp);
+	}
+#endif /* CONFIG_TOUCHSCREEN_S3C_DEBUG */
+
+	if((xp!=data->xp_old || yp!=data->yp_old) && (xp >= 0 && yp >= 0) )
+	{
+		touch_count++;		
+			
+		if(touch_count == 1)		// check first touch
+		{
+#ifdef CONFIG_CPU_FREQ
+			set_dvfs_perf_level();
+#endif /* CONFIG_CPU_FREQ */
+
+#ifdef CONFIG_TOUCHSCREEN_S3C_DEBUG
+			printk(KERN_INFO "\nFirst BTN_TOUCH Event(%03ld, %03ld) is discard\n", xp, yp);						
+#endif
+			return;
+		}
+		else if(touch_count == 2)
+		{
+			data->xp_old=xp;
+			data->yp_old=yp;
+			return;
+		}
+//		printk(KERN_INFO "[s3c_ts_done_callback] Touch is pressed. x = %d, y = %d\n", data->xp_old, data->yp_old); 
+        
+		input_report_abs(data->dev, ABS_X, data->xp_old);
+                input_report_abs(data->dev, ABS_Y, data->yp_old);
+                input_report_abs(data->dev, ABS_Z, 0);
+
+                input_report_key(data->dev, BTN_TOUCH, 1);
+                input_sync(data->dev);
+		// [SEC_BSP.khLEE 2009.08.27 : If cal mode, driver gathers coordinates for calculating cal factors				
+#ifdef CONFIG_SAMSUNG_CALIBRATION_MODE
+		if(current_driver_state == CAL_COLLECT_STATE || current_driver_state == CAL_INITIAL_STATE)
+		{
+			if(current_driver_state == CAL_INITIAL_STATE)
+				current_driver_state = CAL_COLLECT_STATE;
+				
+			// check first touch is in center
+			if((calibration_coords.xfb[current_collect_state] - LIMIT_RADIUS <= xp &&
+				xp <= calibration_coords.xfb[current_collect_state] + LIMIT_RADIUS) &&
+				(calibration_coords.yfb[current_collect_state] - LIMIT_RADIUS <= yp &&
+				yp <= calibration_coords.yfb[current_collect_state] + LIMIT_RADIUS))
+			{
+				// save the ADC data for this coordinates
+				calibration_data.x[current_collect_state] = x_mean;
+				calibration_data.y[current_collect_state] = y_mean;
+
+				printk(KERN_DEBUG "[s3c-ts] current coordinate: %d, obtained ADC of x: %d, y: %d\n", 
+					current_collect_state, calibration_data.x[current_collect_state], calibration_data.y[current_collect_state]);
+
+				// step to next coordinates
+				current_collect_state += 1;		
+
+				// check obtaining all coordinates data
+				if(current_collect_state == 5)
+				{
+					current_driver_state = CAL_COLLECT_FINISH_STATE;
+					strcpy(send_msg_buf, "CAL_COLLECT_FINISH");
+				}							
+			}
+		}						
+#endif /* CONFIG_SAMSUNG_CALIBRATION_MODE */
+
+		data->xp_old=xp;
+		data->yp_old=yp;
+	}
+}
+
+/*
+ * The functions for inserting/removing us as a module.
+ */
+static int __init s3c_ts_probe(struct platform_device *pdev)
+{
+	struct device *dev;
+	struct input_dev *input_dev;
+	struct s3c_ts_mach_info * s3c_ts_cfg;
+	int ret;
+	int err;
+
+	dev = &pdev->dev;
+
+	s3c_ts_cfg = (struct s3c_ts_mach_info *) dev->platform_data;
+	if (s3c_ts_cfg == NULL)
+		return -EINVAL;
+
+	ts = kzalloc(sizeof(struct s3c_ts_mach_info), GFP_KERNEL);
+	data = kzalloc(sizeof(struct s3c_ts_data), GFP_KERNEL);
+
+	memcpy (ts, s3c_ts_cfg, sizeof(struct s3c_ts_mach_info));
+	
+	input_dev = input_allocate_device();
+
+	if (!input_dev) {
+		ret = -ENOMEM;
+		goto input_dev_fail;
+	}
+	
+	data->dev = input_dev;
+
+	data->xp_old = data->yp_old = -1;
+	data->dev->evbit[0] = data->dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	data->dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+        input_set_abs_params(data->dev, ABS_X, 0, ts->screen_size_x, 0, 0);
+        input_set_abs_params(data->dev, ABS_Y, 0, ts->screen_size_y, 0, 0);
+	// [SEC_BSP.khLEE 2009.08.24 : Intialize variables for calibration mode
+#ifdef CONFIG_SAMSUNG_CALIBRATION_MODE
+	ret = init_samsung_cal_mode(ts->screen_size_x, ts->screen_size_y, ts->tscal);
+	if(ret) 
+	{
+		dev_err(dev, "s3c_ts.c: Could not initialization(touchscreen)!\n");
+		goto s3c_adcts_register_fail;
+	}
+#endif /* CONFIG_SAMSUNG_CALIBRATION_MODE */
+	// ]
+
+        set_bit(0,data->dev->evbit);
+        set_bit(1,data->dev->evbit);
+        set_bit(2,data->dev->evbit);
+        set_bit(3,data->dev->evbit);
+        set_bit(5,data->dev->evbit);
+
+        set_bit(0,data->dev->relbit);
+        set_bit(1,data->dev->relbit);
+
+        set_bit(0,data->dev->absbit);
+        set_bit(1,data->dev->absbit);
+        set_bit(2,data->dev->absbit);
+
+        set_bit(0,data->dev->swbit);
+
+        for(err=0;err<512;err++) set_bit(err,data->dev->keybit);
+
+        input_event(data->dev,5,0,1);
+
+	input_set_abs_params(data->dev, ABS_PRESSURE, 0, 1, 0, 0);
+
+	data->dev->name = s3c_ts_name;
+	data->dev->id.bustype = BUS_RS232;
+	data->dev->id.vendor = 0xDEAD;
+	data->dev->id.product = 0xBEEF;
+	data->dev->id.version = S3C_TSVERSION;
+
+	ret = s3c_adcts_register_ts (ts, s3c_ts_done_callback);
+	if(ret) {
+		dev_err(dev, "s3c_ts.c: Could not register adcts device(touchscreen)!\n");
+		ret = -EIO;
+		goto s3c_adcts_register_fail;
+	}
+
+	/* All went ok, so register to the input system */
+	ret = input_register_device(data->dev);
+	
+	if(ret) {
+		dev_err(dev, "s3c_ts.c: Could not register input device(touchscreen)!\n");
+		ret = -EIO;
+		goto input_register_fail;
+	}
+	return 0;
+
+input_register_fail:
+	s3c_adcts_unregister_ts();
+
+s3c_adcts_register_fail:
+	input_free_device (data->dev);
+
+input_dev_fail:
+	kfree (ts);
+	kfree (data);
+
+	return ret;
+}
+
+static int s3c_ts_remove(struct platform_device *dev)
+{
+	printk(KERN_INFO "s3c_ts_remove() of TS called !\n");
+
+	input_unregister_device(data->dev);
+	s3c_adcts_unregister_ts();
+	input_free_device (data->dev);
+	kfree (ts);
+	kfree (data);
+
+	return 0;
+}
+
+static struct platform_driver s3c_ts_driver = {
+       .probe          = s3c_ts_probe,
+       .remove         = s3c_ts_remove,
+       .driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c-ts",
+	},
+};
+
+static char banner[] __initdata = KERN_INFO "S3C Touchscreen driver, (c) 2009 Samsung Electronics\n";
+
+static int __init s3c_ts_init(void)
+{
+	printk(banner);
+	return platform_driver_register(&s3c_ts_driver);
+}
+
+static void __exit s3c_ts_exit(void)
+{
+#ifdef CONFIG_SAMSUNG_CALIBRATION_MODE
+	exit_samsung_cal_mode();
+#endif /* CONFIG_SAMSUNG_CALIBRATION_MODE */
+	platform_driver_unregister(&s3c_ts_driver);
+}
+
+module_init(s3c_ts_init);
+module_exit(s3c_ts_exit);
+
+MODULE_AUTHOR("Samsung AP");
+MODULE_DESCRIPTION("S3C touchscreen driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/input/touchscreen/synaptics_i2c_rmi.c linux-2.6.29-spica/drivers/input/touchscreen/synaptics_i2c_rmi.c
--- linux-2.6.29/drivers/input/touchscreen/synaptics_i2c_rmi.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/input/touchscreen/synaptics_i2c_rmi.c	2010-03-30 11:00:31.000000000 +0700
@@ -0,0 +1,674 @@
+/* drivers/input/keyboard/synaptics_i2c_rmi.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/earlysuspend.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/synaptics_i2c_rmi.h>
+
+static struct workqueue_struct *synaptics_wq;
+
+struct synaptics_ts_data {
+	uint16_t addr;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	int use_irq;
+	bool has_relative_report;
+	struct hrtimer timer;
+	struct work_struct  work;
+	uint16_t max[2];
+	int snap_state[2][2];
+	int snap_down_on[2];
+	int snap_down_off[2];
+	int snap_up_on[2];
+	int snap_up_off[2];
+	int snap_down[2];
+	int snap_up[2];
+	uint32_t flags;
+	int reported_finger_count;
+	int8_t sensitivity_adjust;
+	int (*power)(int on);
+	struct early_suspend early_suspend;
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void synaptics_ts_early_suspend(struct early_suspend *h);
+static void synaptics_ts_late_resume(struct early_suspend *h);
+#endif
+
+static int synaptics_init_panel(struct synaptics_ts_data *ts)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x10); /* page select = 0x10 */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
+		goto err_page_select_failed;
+	}
+	ret = i2c_smbus_write_byte_data(ts->client, 0x41, 0x04); /* Set "No Clip Z" */
+	if (ret < 0)
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for No Clip Z\n");
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0x44,
+					ts->sensitivity_adjust);
+	if (ret < 0)
+		pr_err("synaptics_ts: failed to set Sensitivity Adjust\n");
+
+err_page_select_failed:
+	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x04); /* page select = 0x04 */
+	if (ret < 0)
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf0, 0x81); /* normal operation, 80 reports per second */
+	if (ret < 0)
+		printk(KERN_ERR "synaptics_ts_resume: i2c_smbus_write_byte_data failed\n");
+	return ret;
+}
+
+static void synaptics_ts_work_func(struct work_struct *work)
+{
+	int i;
+	int ret;
+	int bad_data = 0;
+	struct i2c_msg msg[2];
+	uint8_t start_reg;
+	uint8_t buf[15];
+	struct synaptics_ts_data *ts = container_of(work, struct synaptics_ts_data, work);
+	int buf_len = ts->has_relative_report ? 15 : 13;
+
+	msg[0].addr = ts->client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = &start_reg;
+	start_reg = 0x00;
+	msg[1].addr = ts->client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = buf_len;
+	msg[1].buf = buf;
+
+	/* printk("synaptics_ts_work_func\n"); */
+	for (i = 0; i < ((ts->use_irq && !bad_data) ? 1 : 10); i++) {
+		ret = i2c_transfer(ts->client->adapter, msg, 2);
+		if (ret < 0) {
+			printk(KERN_ERR "synaptics_ts_work_func: i2c_transfer failed\n");
+			bad_data = 1;
+		} else {
+			/* printk("synaptics_ts_work_func: %x %x %x %x %x %x" */
+			/*        " %x %x %x %x %x %x %x %x %x, ret %d\n", */
+			/*        buf[0], buf[1], buf[2], buf[3], */
+			/*        buf[4], buf[5], buf[6], buf[7], */
+			/*        buf[8], buf[9], buf[10], buf[11], */
+			/*        buf[12], buf[13], buf[14], ret); */
+			if ((buf[buf_len - 1] & 0xc0) != 0x40) {
+				printk(KERN_WARNING "synaptics_ts_work_func:"
+				       " bad read %x %x %x %x %x %x %x %x %x"
+				       " %x %x %x %x %x %x, ret %d\n",
+				       buf[0], buf[1], buf[2], buf[3],
+				       buf[4], buf[5], buf[6], buf[7],
+				       buf[8], buf[9], buf[10], buf[11],
+				       buf[12], buf[13], buf[14], ret);
+				if (bad_data)
+					synaptics_init_panel(ts);
+				bad_data = 1;
+				continue;
+			}
+			bad_data = 0;
+			if ((buf[buf_len - 1] & 1) == 0) {
+				/* printk("read %d coordinates\n", i); */
+				break;
+			} else {
+				int pos[2][2];
+				int f, a;
+				int base;
+				/* int x = buf[3] | (uint16_t)(buf[2] & 0x1f) << 8; */
+				/* int y = buf[5] | (uint16_t)(buf[4] & 0x1f) << 8; */
+				int z = buf[1];
+				int w = buf[0] >> 4;
+				int finger = buf[0] & 7;
+
+				/* int x2 = buf[3+6] | (uint16_t)(buf[2+6] & 0x1f) << 8; */
+				/* int y2 = buf[5+6] | (uint16_t)(buf[4+6] & 0x1f) << 8; */
+				/* int z2 = buf[1+6]; */
+				/* int w2 = buf[0+6] >> 4; */
+				/* int finger2 = buf[0+6] & 7; */
+
+				/* int dx = (int8_t)buf[12]; */
+				/* int dy = (int8_t)buf[13]; */
+				int finger2_pressed;
+
+				/* printk("x %4d, y %4d, z %3d, w %2d, F %d, 2nd: x %4d, y %4d, z %3d, w %2d, F %d, dx %4d, dy %4d\n", */
+				/*	x, y, z, w, finger, */
+				/*	x2, y2, z2, w2, finger2, */
+				/*	dx, dy); */
+
+				base = 2;
+				for (f = 0; f < 2; f++) {
+					uint32_t flip_flag = SYNAPTICS_FLIP_X;
+					for (a = 0; a < 2; a++) {
+						int p = buf[base + 1];
+						p |= (uint16_t)(buf[base] & 0x1f) << 8;
+						if (ts->flags & flip_flag)
+							p = ts->max[a] - p;
+						if (ts->flags & SYNAPTICS_SNAP_TO_INACTIVE_EDGE) {
+							if (ts->snap_state[f][a]) {
+								if (p <= ts->snap_down_off[a])
+									p = ts->snap_down[a];
+								else if (p >= ts->snap_up_off[a])
+									p = ts->snap_up[a];
+								else
+									ts->snap_state[f][a] = 0;
+							} else {
+								if (p <= ts->snap_down_on[a]) {
+									p = ts->snap_down[a];
+									ts->snap_state[f][a] = 1;
+								} else if (p >= ts->snap_up_on[a]) {
+									p = ts->snap_up[a];
+									ts->snap_state[f][a] = 1;
+								}
+							}
+						}
+						pos[f][a] = p;
+						base += 2;
+						flip_flag <<= 1;
+					}
+					base += 2;
+					if (ts->flags & SYNAPTICS_SWAP_XY)
+						swap(pos[f][0], pos[f][1]);
+				}
+				if (z) {
+					input_report_abs(ts->input_dev, ABS_X, pos[0][0]);
+					input_report_abs(ts->input_dev, ABS_Y, pos[0][1]);
+				}
+				input_report_abs(ts->input_dev, ABS_PRESSURE, z);
+				input_report_abs(ts->input_dev, ABS_TOOL_WIDTH, w);
+				input_report_key(ts->input_dev, BTN_TOUCH, finger);
+				finger2_pressed = finger > 1 && finger != 7;
+				input_report_key(ts->input_dev, BTN_2, finger2_pressed);
+				if (finger2_pressed) {
+					input_report_abs(ts->input_dev, ABS_HAT0X, pos[1][0]);
+					input_report_abs(ts->input_dev, ABS_HAT0Y, pos[1][1]);
+				}
+
+				if (!finger)
+					z = 0;
+				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, z);
+				input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, pos[0][0]);
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, pos[0][1]);
+				input_mt_sync(ts->input_dev);
+				if (finger2_pressed) {
+					input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, z);
+					input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+					input_report_abs(ts->input_dev, ABS_MT_POSITION_X, pos[1][0]);
+					input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, pos[1][1]);
+					input_mt_sync(ts->input_dev);
+				} else if (ts->reported_finger_count > 1) {
+					input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+					input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0);
+					input_mt_sync(ts->input_dev);
+				}
+				ts->reported_finger_count = finger;
+				input_sync(ts->input_dev);
+			}
+		}
+	}
+	if (ts->use_irq)
+		enable_irq(ts->client->irq);
+}
+
+static enum hrtimer_restart synaptics_ts_timer_func(struct hrtimer *timer)
+{
+	struct synaptics_ts_data *ts = container_of(timer, struct synaptics_ts_data, timer);
+	/* printk("synaptics_ts_timer_func\n"); */
+
+	queue_work(synaptics_wq, &ts->work);
+
+	hrtimer_start(&ts->timer, ktime_set(0, 12500000), HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t synaptics_ts_irq_handler(int irq, void *dev_id)
+{
+	struct synaptics_ts_data *ts = dev_id;
+
+	/* printk("synaptics_ts_irq_handler\n"); */
+	disable_irq_nosync(ts->client->irq);
+	queue_work(synaptics_wq, &ts->work);
+	return IRQ_HANDLED;
+}
+
+static int synaptics_ts_probe(
+	struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct synaptics_ts_data *ts;
+	uint8_t buf0[4];
+	uint8_t buf1[8];
+	struct i2c_msg msg[2];
+	int ret = 0;
+	uint16_t max_x, max_y;
+	int fuzz_x, fuzz_y, fuzz_p, fuzz_w;
+	struct synaptics_i2c_rmi_platform_data *pdata;
+	unsigned long irqflags;
+	int inactive_area_left;
+	int inactive_area_right;
+	int inactive_area_top;
+	int inactive_area_bottom;
+	int snap_left_on;
+	int snap_left_off;
+	int snap_right_on;
+	int snap_right_off;
+	int snap_top_on;
+	int snap_top_off;
+	int snap_bottom_on;
+	int snap_bottom_off;
+	uint32_t panel_version;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		printk(KERN_ERR "synaptics_ts_probe: need I2C_FUNC_I2C\n");
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL) {
+		ret = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+	INIT_WORK(&ts->work, synaptics_ts_work_func);
+	ts->client = client;
+	i2c_set_clientdata(client, ts);
+	pdata = client->dev.platform_data;
+	if (pdata)
+		ts->power = pdata->power;
+	if (ts->power) {
+		ret = ts->power(1);
+		if (ret < 0) {
+			printk(KERN_ERR "synaptics_ts_probe power on failed\n");
+			goto err_power_failed;
+		}
+	}
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf4, 0x01); /* device command = reset */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed\n");
+		/* fail? */
+	}
+	{
+		int retry = 10;
+		while (retry-- > 0) {
+			ret = i2c_smbus_read_byte_data(ts->client, 0xe4);
+			if (ret >= 0)
+				break;
+			msleep(100);
+		}
+	}
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: Product Major Version %x\n", ret);
+	panel_version = ret << 8;
+	ret = i2c_smbus_read_byte_data(ts->client, 0xe5);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: Product Minor Version %x\n", ret);
+	panel_version |= ret;
+
+	ret = i2c_smbus_read_byte_data(ts->client, 0xe3);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: product property %x\n", ret);
+
+	if (pdata) {
+		while (pdata->version > panel_version)
+			pdata++;
+		ts->flags = pdata->flags;
+		ts->sensitivity_adjust = pdata->sensitivity_adjust;
+		irqflags = pdata->irqflags;
+		inactive_area_left = pdata->inactive_left;
+		inactive_area_right = pdata->inactive_right;
+		inactive_area_top = pdata->inactive_top;
+		inactive_area_bottom = pdata->inactive_bottom;
+		snap_left_on = pdata->snap_left_on;
+		snap_left_off = pdata->snap_left_off;
+		snap_right_on = pdata->snap_right_on;
+		snap_right_off = pdata->snap_right_off;
+		snap_top_on = pdata->snap_top_on;
+		snap_top_off = pdata->snap_top_off;
+		snap_bottom_on = pdata->snap_bottom_on;
+		snap_bottom_off = pdata->snap_bottom_off;
+		fuzz_x = pdata->fuzz_x;
+		fuzz_y = pdata->fuzz_y;
+		fuzz_p = pdata->fuzz_p;
+		fuzz_w = pdata->fuzz_w;
+	} else {
+		irqflags = 0;
+		inactive_area_left = 0;
+		inactive_area_right = 0;
+		inactive_area_top = 0;
+		inactive_area_bottom = 0;
+		snap_left_on = 0;
+		snap_left_off = 0;
+		snap_right_on = 0;
+		snap_right_off = 0;
+		snap_top_on = 0;
+		snap_top_off = 0;
+		snap_bottom_on = 0;
+		snap_bottom_off = 0;
+		fuzz_x = 0;
+		fuzz_y = 0;
+		fuzz_p = 0;
+		fuzz_w = 0;
+	}
+
+	ret = i2c_smbus_read_byte_data(ts->client, 0xf0);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: device control %x\n", ret);
+
+	ret = i2c_smbus_read_byte_data(ts->client, 0xf1);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: interrupt enable %x\n", ret);
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf1, 0); /* disable interrupt */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed\n");
+		goto err_detect_failed;
+	}
+
+	msg[0].addr = ts->client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf0;
+	buf0[0] = 0xe0;
+	msg[1].addr = ts->client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 8;
+	msg[1].buf = buf1;
+	ret = i2c_transfer(ts->client->adapter, msg, 2);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_transfer failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: 0xe0: %x %x %x %x %x %x %x %x\n",
+	       buf1[0], buf1[1], buf1[2], buf1[3],
+	       buf1[4], buf1[5], buf1[6], buf1[7]);
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x10); /* page select = 0x10 */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
+		goto err_detect_failed;
+	}
+	ret = i2c_smbus_read_word_data(ts->client, 0x02);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		goto err_detect_failed;
+	}
+	ts->has_relative_report = !(ret & 0x100);
+	printk(KERN_INFO "synaptics_ts_probe: Sensor properties %x\n", ret);
+	ret = i2c_smbus_read_word_data(ts->client, 0x04);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		goto err_detect_failed;
+	}
+	ts->max[0] = max_x = (ret >> 8 & 0xff) | ((ret & 0x1f) << 8);
+	ret = i2c_smbus_read_word_data(ts->client, 0x06);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		goto err_detect_failed;
+	}
+	ts->max[1] = max_y = (ret >> 8 & 0xff) | ((ret & 0x1f) << 8);
+	if (ts->flags & SYNAPTICS_SWAP_XY)
+		swap(max_x, max_y);
+
+	ret = synaptics_init_panel(ts); /* will also switch back to page 0x04 */
+	if (ret < 0) {
+		printk(KERN_ERR "synaptics_init_panel failed\n");
+		goto err_detect_failed;
+	}
+
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) {
+		ret = -ENOMEM;
+		printk(KERN_ERR "synaptics_ts_probe: Failed to allocate input device\n");
+		goto err_input_dev_alloc_failed;
+	}
+	ts->input_dev->name = "synaptics-rmi-touchscreen";
+	set_bit(EV_SYN, ts->input_dev->evbit);
+	set_bit(EV_KEY, ts->input_dev->evbit);
+	set_bit(BTN_TOUCH, ts->input_dev->keybit);
+	set_bit(BTN_2, ts->input_dev->keybit);
+	set_bit(EV_ABS, ts->input_dev->evbit);
+	inactive_area_left = inactive_area_left * max_x / 0x10000;
+	inactive_area_right = inactive_area_right * max_x / 0x10000;
+	inactive_area_top = inactive_area_top * max_y / 0x10000;
+	inactive_area_bottom = inactive_area_bottom * max_y / 0x10000;
+	snap_left_on = snap_left_on * max_x / 0x10000;
+	snap_left_off = snap_left_off * max_x / 0x10000;
+	snap_right_on = snap_right_on * max_x / 0x10000;
+	snap_right_off = snap_right_off * max_x / 0x10000;
+	snap_top_on = snap_top_on * max_y / 0x10000;
+	snap_top_off = snap_top_off * max_y / 0x10000;
+	snap_bottom_on = snap_bottom_on * max_y / 0x10000;
+	snap_bottom_off = snap_bottom_off * max_y / 0x10000;
+	fuzz_x = fuzz_x * max_x / 0x10000;
+	fuzz_y = fuzz_y * max_y / 0x10000;
+	ts->snap_down[!!(ts->flags & SYNAPTICS_SWAP_XY)] = -inactive_area_left;
+	ts->snap_up[!!(ts->flags & SYNAPTICS_SWAP_XY)] = max_x + inactive_area_right;
+	ts->snap_down[!(ts->flags & SYNAPTICS_SWAP_XY)] = -inactive_area_top;
+	ts->snap_up[!(ts->flags & SYNAPTICS_SWAP_XY)] = max_y + inactive_area_bottom;
+	ts->snap_down_on[!!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_left_on;
+	ts->snap_down_off[!!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_left_off;
+	ts->snap_up_on[!!(ts->flags & SYNAPTICS_SWAP_XY)] = max_x - snap_right_on;
+	ts->snap_up_off[!!(ts->flags & SYNAPTICS_SWAP_XY)] = max_x - snap_right_off;
+	ts->snap_down_on[!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_top_on;
+	ts->snap_down_off[!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_top_off;
+	ts->snap_up_on[!(ts->flags & SYNAPTICS_SWAP_XY)] = max_y - snap_bottom_on;
+	ts->snap_up_off[!(ts->flags & SYNAPTICS_SWAP_XY)] = max_y - snap_bottom_off;
+	printk(KERN_INFO "synaptics_ts_probe: max_x %d, max_y %d\n", max_x, max_y);
+	printk(KERN_INFO "synaptics_ts_probe: inactive_x %d %d, inactive_y %d %d\n",
+	       inactive_area_left, inactive_area_right,
+	       inactive_area_top, inactive_area_bottom);
+	printk(KERN_INFO "synaptics_ts_probe: snap_x %d-%d %d-%d, snap_y %d-%d %d-%d\n",
+	       snap_left_on, snap_left_off, snap_right_on, snap_right_off,
+	       snap_top_on, snap_top_off, snap_bottom_on, snap_bottom_off);
+	input_set_abs_params(ts->input_dev, ABS_X, -inactive_area_left, max_x + inactive_area_right, fuzz_x, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, -inactive_area_top, max_y + inactive_area_bottom, fuzz_y, 0);
+	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, fuzz_p, 0);
+	input_set_abs_params(ts->input_dev, ABS_TOOL_WIDTH, 0, 15, fuzz_w, 0);
+	input_set_abs_params(ts->input_dev, ABS_HAT0X, -inactive_area_left, max_x + inactive_area_right, fuzz_x, 0);
+	input_set_abs_params(ts->input_dev, ABS_HAT0Y, -inactive_area_top, max_y + inactive_area_bottom, fuzz_y, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, -inactive_area_left, max_x + inactive_area_right, fuzz_x, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, -inactive_area_top, max_y + inactive_area_bottom, fuzz_y, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, fuzz_p, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 15, fuzz_w, 0);
+	/* ts->input_dev->name = ts->keypad_info->name; */
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		printk(KERN_ERR "synaptics_ts_probe: Unable to register %s input device\n", ts->input_dev->name);
+		goto err_input_register_device_failed;
+	}
+	if (client->irq) {
+		ret = request_irq(client->irq, synaptics_ts_irq_handler, irqflags, client->name, ts);
+		if (ret == 0) {
+			ret = i2c_smbus_write_byte_data(ts->client, 0xf1, 0x01); /* enable abs int */
+			if (ret)
+				free_irq(client->irq, ts);
+		}
+		if (ret == 0)
+			ts->use_irq = 1;
+		else
+			dev_err(&client->dev, "request_irq failed\n");
+	}
+	if (!ts->use_irq) {
+		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ts->timer.function = synaptics_ts_timer_func;
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ts->early_suspend.suspend = synaptics_ts_early_suspend;
+	ts->early_suspend.resume = synaptics_ts_late_resume;
+	register_early_suspend(&ts->early_suspend);
+#endif
+
+	printk(KERN_INFO "synaptics_ts_probe: Start touchscreen %s in %s mode\n", ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");
+
+	return 0;
+
+err_input_register_device_failed:
+	input_free_device(ts->input_dev);
+
+err_input_dev_alloc_failed:
+err_detect_failed:
+err_power_failed:
+	kfree(ts);
+err_alloc_data_failed:
+err_check_functionality_failed:
+	return ret;
+}
+
+static int synaptics_ts_remove(struct i2c_client *client)
+{
+	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
+	unregister_early_suspend(&ts->early_suspend);
+	if (ts->use_irq)
+		free_irq(client->irq, ts);
+	else
+		hrtimer_cancel(&ts->timer);
+	input_unregister_device(ts->input_dev);
+	kfree(ts);
+	return 0;
+}
+
+static int synaptics_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int ret;
+	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->use_irq)
+		disable_irq(client->irq);
+	else
+		hrtimer_cancel(&ts->timer);
+	ret = cancel_work_sync(&ts->work);
+	if (ret && ts->use_irq) /* if work was pending disable-count is now 2 */
+		enable_irq(client->irq);
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf1, 0); /* disable interrupt */
+	if (ret < 0)
+		printk(KERN_ERR "synaptics_ts_suspend: i2c_smbus_write_byte_data failed\n");
+
+	ret = i2c_smbus_write_byte_data(client, 0xf0, 0x86); /* deep sleep */
+	if (ret < 0)
+		printk(KERN_ERR "synaptics_ts_suspend: i2c_smbus_write_byte_data failed\n");
+	if (ts->power) {
+		ret = ts->power(0);
+		if (ret < 0)
+			printk(KERN_ERR "synaptics_ts_resume power off failed\n");
+	}
+	return 0;
+}
+
+static int synaptics_ts_resume(struct i2c_client *client)
+{
+	int ret;
+	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->power) {
+		ret = ts->power(1);
+		if (ret < 0)
+			printk(KERN_ERR "synaptics_ts_resume power on failed\n");
+	}
+
+	synaptics_init_panel(ts);
+
+	if (ts->use_irq)
+		enable_irq(client->irq);
+
+	if (!ts->use_irq)
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	else
+		i2c_smbus_write_byte_data(ts->client, 0xf1, 0x01); /* enable abs int */
+
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void synaptics_ts_early_suspend(struct early_suspend *h)
+{
+	struct synaptics_ts_data *ts;
+	ts = container_of(h, struct synaptics_ts_data, early_suspend);
+	synaptics_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+static void synaptics_ts_late_resume(struct early_suspend *h)
+{
+	struct synaptics_ts_data *ts;
+	ts = container_of(h, struct synaptics_ts_data, early_suspend);
+	synaptics_ts_resume(ts->client);
+}
+#endif
+
+static const struct i2c_device_id synaptics_ts_id[] = {
+	{ SYNAPTICS_I2C_RMI_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver synaptics_ts_driver = {
+	.probe		= synaptics_ts_probe,
+	.remove		= synaptics_ts_remove,
+#ifndef CONFIG_HAS_EARLYSUSPEND
+	.suspend	= synaptics_ts_suspend,
+	.resume		= synaptics_ts_resume,
+#endif
+	.id_table	= synaptics_ts_id,
+	.driver = {
+		.name	= SYNAPTICS_I2C_RMI_NAME,
+	},
+};
+
+static int __devinit synaptics_ts_init(void)
+{
+	synaptics_wq = create_singlethread_workqueue("synaptics_wq");
+	if (!synaptics_wq)
+		return -ENOMEM;
+	return i2c_add_driver(&synaptics_ts_driver);
+}
+
+static void __exit synaptics_ts_exit(void)
+{
+	i2c_del_driver(&synaptics_ts_driver);
+	if (synaptics_wq)
+		destroy_workqueue(synaptics_wq);
+}
+
+module_init(synaptics_ts_init);
+module_exit(synaptics_ts_exit);
+
+MODULE_DESCRIPTION("Synaptics Touchscreen Driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/Kconfig linux-2.6.29-spica/drivers/Kconfig
--- linux-2.6.29/drivers/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/Kconfig	2010-03-30 11:00:49.000000000 +0700
@@ -88,6 +88,8 @@
 
 source "drivers/leds/Kconfig"
 
+source "drivers/switch/Kconfig"
+
 source "drivers/accessibility/Kconfig"
 
 source "drivers/infiniband/Kconfig"
diff -Nur linux-2.6.29/drivers/leds/Kconfig linux-2.6.29-spica/drivers/leds/Kconfig
--- linux-2.6.29/drivers/leds/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/leds/Kconfig	2010-03-30 11:00:50.000000000 +0700
@@ -223,4 +223,10 @@
 	  This allows LEDs to be initialised in the ON state.
 	  If unsure, say Y.
 
+config LEDS_TRIGGER_SLEEP
+	tristate "LED Sleep Mode Trigger"
+	depends on LEDS_TRIGGERS && HAS_EARLYSUSPEND
+	help
+	  This turns LEDs on when the screen is off but the cpu still running.
+
 endif # NEW_LEDS
diff -Nur linux-2.6.29/drivers/leds/ledtrig-sleep.c linux-2.6.29-spica/drivers/leds/ledtrig-sleep.c
--- linux-2.6.29/drivers/leds/ledtrig-sleep.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/leds/ledtrig-sleep.c	2010-03-30 11:00:50.000000000 +0700
@@ -0,0 +1,80 @@
+/* drivers/leds/ledtrig-sleep.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/earlysuspend.h>
+#include <linux/leds.h>
+#include <linux/suspend.h>
+
+static int ledtrig_sleep_pm_callback(struct notifier_block *nfb,
+					unsigned long action,
+					void *ignored);
+
+DEFINE_LED_TRIGGER(ledtrig_sleep)
+static struct notifier_block ledtrig_sleep_pm_notifier = {
+	.notifier_call = ledtrig_sleep_pm_callback,
+	.priority = 0,
+};
+
+static void ledtrig_sleep_early_suspend(struct early_suspend *h)
+{
+	led_trigger_event(ledtrig_sleep, LED_FULL);
+}
+
+static void ledtrig_sleep_early_resume(struct early_suspend *h)
+{
+	led_trigger_event(ledtrig_sleep, LED_OFF);
+}
+
+static struct early_suspend ledtrig_sleep_early_suspend_handler = {
+	.suspend = ledtrig_sleep_early_suspend,
+	.resume = ledtrig_sleep_early_resume,
+};
+
+static int ledtrig_sleep_pm_callback(struct notifier_block *nfb,
+					unsigned long action,
+					void *ignored)
+{
+	switch (action) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		led_trigger_event(ledtrig_sleep, LED_OFF);
+		return NOTIFY_OK;
+	case PM_POST_HIBERNATION:
+	case PM_POST_SUSPEND:
+		led_trigger_event(ledtrig_sleep, LED_FULL);
+		return NOTIFY_OK;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int __init ledtrig_sleep_init(void)
+{
+	led_trigger_register_simple("sleep", &ledtrig_sleep);
+	register_pm_notifier(&ledtrig_sleep_pm_notifier);
+	register_early_suspend(&ledtrig_sleep_early_suspend_handler);
+	return 0;
+}
+
+static void __exit ledtrig_sleep_exit(void)
+{
+	unregister_early_suspend(&ledtrig_sleep_early_suspend_handler);
+	unregister_pm_notifier(&ledtrig_sleep_pm_notifier);
+	led_trigger_unregister_simple(ledtrig_sleep);
+}
+
+module_init(ledtrig_sleep_init);
+module_exit(ledtrig_sleep_exit);
+
diff -Nur linux-2.6.29/drivers/leds/Makefile linux-2.6.29-spica/drivers/leds/Makefile
--- linux-2.6.29/drivers/leds/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/leds/Makefile	2010-03-30 11:00:49.000000000 +0700
@@ -31,3 +31,4 @@
 obj-$(CONFIG_LEDS_TRIGGER_HEARTBEAT)	+= ledtrig-heartbeat.o
 obj-$(CONFIG_LEDS_TRIGGER_BACKLIGHT)	+= ledtrig-backlight.o
 obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON)	+= ledtrig-default-on.o
+obj-$(CONFIG_LEDS_TRIGGER_SLEEP)	+= ledtrig-sleep.o
diff -Nur linux-2.6.29/drivers/Makefile linux-2.6.29-spica/drivers/Makefile
--- linux-2.6.29/drivers/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -91,6 +91,8 @@
 obj-$(CONFIG_MMC)		+= mmc/
 obj-$(CONFIG_MEMSTICK)		+= memstick/
 obj-$(CONFIG_NEW_LEDS)		+= leds/
+obj-$(CONFIG_NEW_SENSORS)	+= sensor/
+obj-$(CONFIG_SWITCH)		+= switch/
 obj-$(CONFIG_INFINIBAND)	+= infiniband/
 obj-$(CONFIG_SGI_SN)		+= sn/
 obj-y				+= firmware/
diff -Nur linux-2.6.29/drivers/misc/apanic.c linux-2.6.29-spica/drivers/misc/apanic.c
--- linux-2.6.29/drivers/misc/apanic.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/misc/apanic.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,606 @@
+/* drivers/misc/apanic.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Author: San Mehat <san@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/wakelock.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/mtd/mtd.h>
+#include <linux/notifier.h>
+#include <linux/mtd/mtd.h>
+#include <linux/debugfs.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/preempt.h>
+
+extern void ram_console_enable_console(int);
+
+struct panic_header {
+	u32 magic;
+#define PANIC_MAGIC 0xdeadf00d
+
+	u32 version;
+#define PHDR_VERSION   0x01
+
+	u32 console_offset;
+	u32 console_length;
+
+	u32 threads_offset;
+	u32 threads_length;
+};
+
+struct apanic_data {
+	struct mtd_info		*mtd;
+	struct panic_header	curr;
+	void			*bounce;
+	struct proc_dir_entry	*apanic_console;
+	struct proc_dir_entry	*apanic_threads;
+};
+
+static struct apanic_data drv_ctx;
+static struct work_struct proc_removal_work;
+static DEFINE_MUTEX(drv_mutex);
+
+static unsigned int *apanic_bbt;
+static unsigned int apanic_erase_blocks;
+static unsigned int apanic_good_blocks;
+
+static void set_bb(unsigned int block, unsigned int *bbt)
+{
+	unsigned int flag = 1;
+
+	BUG_ON(block >= apanic_erase_blocks);
+
+	flag = flag << (block%32);
+	apanic_bbt[block/32] |= flag;
+	apanic_good_blocks--;
+}
+
+static unsigned int get_bb(unsigned int block, unsigned int *bbt)
+{
+	unsigned int flag;
+
+	BUG_ON(block >= apanic_erase_blocks);
+
+	flag = 1 << (block%32);
+	return apanic_bbt[block/32] & flag;
+}
+
+static void alloc_bbt(struct mtd_info *mtd, unsigned int *bbt)
+{
+	int bbt_size;
+	apanic_erase_blocks = (mtd->size)>>(mtd->erasesize_shift);
+	bbt_size = (apanic_erase_blocks+32)/32;
+
+	apanic_bbt = kmalloc(bbt_size*4, GFP_KERNEL);
+	memset(apanic_bbt, 0, bbt_size*4);
+	apanic_good_blocks = apanic_erase_blocks;
+}
+static void scan_bbt(struct mtd_info *mtd, unsigned int *bbt)
+{
+	int i;
+
+	for (i = 0; i < apanic_erase_blocks; i++) {
+		if (mtd->block_isbad(mtd, i*mtd->erasesize))
+			set_bb(i, apanic_bbt);
+	}
+}
+
+#define APANIC_INVALID_OFFSET 0xFFFFFFFF
+
+static unsigned int phy_offset(struct mtd_info *mtd, unsigned int offset)
+{
+	unsigned int logic_block = offset>>(mtd->erasesize_shift);
+	unsigned int phy_block;
+	unsigned good_block = 0;
+
+	for (phy_block = 0; phy_block < apanic_erase_blocks; phy_block++) {
+		if (!get_bb(phy_block, apanic_bbt))
+			good_block++;
+		if (good_block == (logic_block + 1))
+			break;
+	}
+
+	if (good_block != (logic_block + 1))
+		return APANIC_INVALID_OFFSET;
+
+	return offset + ((phy_block-logic_block)<<mtd->erasesize_shift);
+}
+
+static void apanic_erase_callback(struct erase_info *done)
+{
+	wait_queue_head_t *wait_q = (wait_queue_head_t *) done->priv;
+	wake_up(wait_q);
+}
+
+static int apanic_proc_read(char *buffer, char **start, off_t offset,
+			       int count, int *peof, void *dat)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	size_t file_length;
+	off_t file_offset;
+	unsigned int page_no;
+	off_t page_offset;
+	int rc;
+	size_t len;
+
+	if (!count)
+		return 0;
+
+	mutex_lock(&drv_mutex);
+
+	switch ((int) dat) {
+	case 1:	/* apanic_console */
+		file_length = ctx->curr.console_length;
+		file_offset = ctx->curr.console_offset;
+		break;
+	case 2:	/* apanic_threads */
+		file_length = ctx->curr.threads_length;
+		file_offset = ctx->curr.threads_offset;
+		break;
+	default:
+		pr_err("Bad dat (%d)\n", (int) dat);
+		mutex_unlock(&drv_mutex);
+		return -EINVAL;
+	}
+
+	if ((offset + count) > file_length) {
+		mutex_unlock(&drv_mutex);
+		return 0;
+	}
+
+	/* We only support reading a maximum of a flash page */
+	if (count > ctx->mtd->writesize)
+		count = ctx->mtd->writesize;
+
+	page_no = (file_offset + offset) / ctx->mtd->writesize;
+	page_offset = (file_offset + offset) % ctx->mtd->writesize;
+
+
+	if (phy_offset(ctx->mtd, (page_no * ctx->mtd->writesize))
+		== APANIC_INVALID_OFFSET) {
+		pr_err("apanic: reading an invalid address\n");
+		mutex_unlock(&drv_mutex);
+		return -EINVAL;
+	}
+	rc = ctx->mtd->read(ctx->mtd,
+		phy_offset(ctx->mtd, (page_no * ctx->mtd->writesize)),
+		ctx->mtd->writesize,
+		&len, ctx->bounce);
+
+	if (page_offset)
+		count -= page_offset;
+	memcpy(buffer, ctx->bounce + page_offset, count);
+
+	*start = count;
+
+	if ((offset + count) == file_length)
+		*peof = 1;
+
+	mutex_unlock(&drv_mutex);
+	return count;
+}
+
+static void mtd_panic_erase(void)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	struct erase_info erase;
+	DECLARE_WAITQUEUE(wait, current);
+	wait_queue_head_t wait_q;
+	int rc, i;
+
+	init_waitqueue_head(&wait_q);
+	erase.mtd = ctx->mtd;
+	erase.callback = apanic_erase_callback;
+	erase.len = ctx->mtd->erasesize;
+	erase.priv = (u_long)&wait_q;
+	for (i = 0; i < ctx->mtd->size; i += ctx->mtd->erasesize) {
+		erase.addr = i;
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&wait_q, &wait);
+
+		if (get_bb(erase.addr>>ctx->mtd->erasesize_shift, apanic_bbt)) {
+			printk(KERN_WARNING
+			       "apanic: Skipping erase of bad "
+			       "block @%llx\n", erase.addr);
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&wait_q, &wait);
+			continue;
+		}
+
+		rc = ctx->mtd->erase(ctx->mtd, &erase);
+		if (rc) {
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&wait_q, &wait);
+			printk(KERN_ERR
+			       "apanic: Erase of 0x%llx, 0x%llx failed\n",
+			       (unsigned long long) erase.addr,
+			       (unsigned long long) erase.len);
+			if (rc == -EIO) {
+				if (ctx->mtd->block_markbad(ctx->mtd,
+							    erase.addr)) {
+					printk(KERN_ERR
+					       "apanic: Err marking blk bad\n");
+					goto out;
+				}
+				printk(KERN_INFO
+				       "apanic: Marked a bad block"
+				       " @%llx\n", erase.addr);
+				set_bb(erase.addr>>ctx->mtd->erasesize_shift,
+					apanic_bbt);
+				continue;
+			}
+			goto out;
+		}
+		schedule();
+		remove_wait_queue(&wait_q, &wait);
+	}
+	printk(KERN_DEBUG "apanic: %s partition erased\n",
+	       CONFIG_APANIC_PLABEL);
+out:
+	return;
+}
+
+static void apanic_remove_proc_work(struct work_struct *work)
+{
+	struct apanic_data *ctx = &drv_ctx;
+
+	mutex_lock(&drv_mutex);
+	mtd_panic_erase();
+	memset(&ctx->curr, 0, sizeof(struct panic_header));
+	if (ctx->apanic_console) {
+		remove_proc_entry("apanic_console", NULL);
+		ctx->apanic_console = NULL;
+	}
+	if (ctx->apanic_threads) {
+		remove_proc_entry("apanic_threads", NULL);
+		ctx->apanic_threads = NULL;
+	}
+	mutex_unlock(&drv_mutex);
+}
+
+static int apanic_proc_write(struct file *file, const char __user *buffer,
+				unsigned long count, void *data)
+{
+	schedule_work(&proc_removal_work);
+	return count;
+}
+
+static void mtd_panic_notify_add(struct mtd_info *mtd)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	struct panic_header *hdr = ctx->bounce;
+	size_t len;
+	int rc;
+	int    proc_entry_created = 0;
+
+	if (strcmp(mtd->name, CONFIG_APANIC_PLABEL))
+		return;
+
+	ctx->mtd = mtd;
+
+	alloc_bbt(mtd, apanic_bbt);
+	scan_bbt(mtd, apanic_bbt);
+
+	if (apanic_good_blocks == 0) {
+		printk(KERN_ERR "apanic: no any good blocks?!\n");
+		goto out_err;
+	}
+
+	rc = mtd->read(mtd, phy_offset(mtd, 0), mtd->writesize,
+			&len, ctx->bounce);
+	if (rc && rc == -EBADMSG) {
+		printk(KERN_WARNING
+		       "apanic: Bad ECC on block 0 (ignored)\n");
+	} else if (rc && rc != -EUCLEAN) {
+		printk(KERN_ERR "apanic: Error reading block 0 (%d)\n", rc);
+		goto out_err;
+	}
+
+	if (len != mtd->writesize) {
+		printk(KERN_ERR "apanic: Bad read size (%d)\n", rc);
+		goto out_err;
+	}
+
+	printk(KERN_INFO "apanic: Bound to mtd partition '%s'\n", mtd->name);
+
+	if (hdr->magic != PANIC_MAGIC) {
+		printk(KERN_INFO "apanic: No panic data available\n");
+		mtd_panic_erase();
+		return;
+	}
+
+	if (hdr->version != PHDR_VERSION) {
+		printk(KERN_INFO "apanic: Version mismatch (%d != %d)\n",
+		       hdr->version, PHDR_VERSION);
+		mtd_panic_erase();
+		return;
+	}
+
+	memcpy(&ctx->curr, hdr, sizeof(struct panic_header));
+
+	printk(KERN_INFO "apanic: c(%u, %u) t(%u, %u)\n",
+	       hdr->console_offset, hdr->console_length,
+	       hdr->threads_offset, hdr->threads_length);
+
+	if (hdr->console_length) {
+		ctx->apanic_console = create_proc_entry("apanic_console",
+						      S_IFREG | S_IRUGO, NULL);
+		if (!ctx->apanic_console)
+			printk(KERN_ERR "%s: failed creating procfile\n",
+			       __func__);
+		else {
+			ctx->apanic_console->read_proc = apanic_proc_read;
+			ctx->apanic_console->write_proc = apanic_proc_write;
+			ctx->apanic_console->size = hdr->console_length;
+			ctx->apanic_console->data = (void *) 1;
+			proc_entry_created = 1;
+		}
+	}
+
+	if (hdr->threads_length) {
+		ctx->apanic_threads = create_proc_entry("apanic_threads",
+						       S_IFREG | S_IRUGO, NULL);
+		if (!ctx->apanic_threads)
+			printk(KERN_ERR "%s: failed creating procfile\n",
+			       __func__);
+		else {
+			ctx->apanic_threads->read_proc = apanic_proc_read;
+			ctx->apanic_threads->write_proc = apanic_proc_write;
+			ctx->apanic_threads->size = hdr->threads_length;
+			ctx->apanic_threads->data = (void *) 2;
+			proc_entry_created = 1;
+		}
+	}
+
+	if (!proc_entry_created)
+		mtd_panic_erase();
+
+	return;
+out_err:
+	ctx->mtd = NULL;
+}
+
+static void mtd_panic_notify_remove(struct mtd_info *mtd)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	if (mtd == ctx->mtd) {
+		ctx->mtd = NULL;
+		printk(KERN_INFO "apanic: Unbound from %s\n", mtd->name);
+	}
+}
+
+static struct mtd_notifier mtd_panic_notifier = {
+	.add	= mtd_panic_notify_add,
+	.remove	= mtd_panic_notify_remove,
+};
+
+static int in_panic = 0;
+
+static int apanic_writeflashpage(struct mtd_info *mtd, loff_t to,
+				 const u_char *buf)
+{
+	int rc;
+	size_t wlen;
+	int panic = in_interrupt() | in_atomic();
+
+	if (panic && !mtd->panic_write) {
+		printk(KERN_EMERG "%s: No panic_write available\n", __func__);
+		return 0;
+	} else if (!panic && !mtd->write) {
+		printk(KERN_EMERG "%s: No write available\n", __func__);
+		return 0;
+	}
+
+	to = phy_offset(mtd, to);
+	if (to == APANIC_INVALID_OFFSET) {
+		printk(KERN_EMERG "apanic: write to invalid address\n");
+		return 0;
+	}
+
+	if (panic)
+		rc = mtd->panic_write(mtd, to, mtd->writesize, &wlen, buf);
+	else
+		rc = mtd->write(mtd, to, mtd->writesize, &wlen, buf);
+
+	if (rc) {
+		printk(KERN_EMERG
+		       "%s: Error writing data to flash (%d)\n",
+		       __func__, rc);
+		return rc;
+	}
+
+	return wlen;
+}
+
+extern int log_buf_copy(char *dest, int idx, int len);
+extern void log_buf_clear(void);
+
+/*
+ * Writes the contents of the console to the specified offset in flash.
+ * Returns number of bytes written
+ */
+static int apanic_write_console(struct mtd_info *mtd, unsigned int off)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	int saved_oip;
+	int idx = 0;
+	int rc, rc2;
+	unsigned int last_chunk = 0;
+
+	while (!last_chunk) {
+		saved_oip = oops_in_progress;
+		oops_in_progress = 1;
+		rc = log_buf_copy(ctx->bounce, idx, mtd->writesize);
+		if (rc < 0)
+			break;
+
+		if (rc != mtd->writesize)
+			last_chunk = rc;
+
+		oops_in_progress = saved_oip;
+		if (rc <= 0)
+			break;
+		if (rc != mtd->writesize)
+			memset(ctx->bounce + rc, 0, mtd->writesize - rc);
+
+		rc2 = apanic_writeflashpage(mtd, off, ctx->bounce);
+		if (rc2 <= 0) {
+			printk(KERN_EMERG
+			       "apanic: Flash write failed (%d)\n", rc2);
+			return idx;
+		}
+		if (!last_chunk)
+			idx += rc2;
+		else
+			idx += last_chunk;
+		off += rc2;
+	}
+	return idx;
+}
+
+static int apanic(struct notifier_block *this, unsigned long event,
+			void *ptr)
+{
+	struct apanic_data *ctx = &drv_ctx;
+	struct panic_header *hdr = (struct panic_header *) ctx->bounce;
+	int console_offset = 0;
+	int console_len = 0;
+	int threads_offset = 0;
+	int threads_len = 0;
+	int rc;
+
+	if (in_panic)
+		return NOTIFY_DONE;
+	in_panic = 1;
+#ifdef CONFIG_PREEMPT
+	/* Ensure that cond_resched() won't try to preempt anybody */
+	add_preempt_count(PREEMPT_ACTIVE);
+#endif
+	touch_softlockup_watchdog();
+
+	if (!ctx->mtd)
+		goto out;
+
+	if (ctx->curr.magic) {
+		printk(KERN_EMERG "Crash partition in use!\n");
+		goto out;
+	}
+	console_offset = ctx->mtd->writesize;
+
+	/*
+	 * Write out the console
+	 */
+	console_len = apanic_write_console(ctx->mtd, console_offset);
+	if (console_len < 0) {
+		printk(KERN_EMERG "Error writing console to panic log! (%d)\n",
+		       console_len);
+		console_len = 0;
+	}
+
+	/*
+	 * Write out all threads
+	 */
+	threads_offset = ALIGN(console_offset + console_len,
+			       ctx->mtd->writesize);
+	if (!threads_offset)
+		threads_offset = ctx->mtd->writesize;
+
+	ram_console_enable_console(0);
+
+	log_buf_clear();
+	show_state_filter(0);
+	threads_len = apanic_write_console(ctx->mtd, threads_offset);
+	if (threads_len < 0) {
+		printk(KERN_EMERG "Error writing threads to panic log! (%d)\n",
+		       threads_len);
+		threads_len = 0;
+	}
+
+	/*
+	 * Finally write the panic header
+	 */
+	memset(ctx->bounce, 0, PAGE_SIZE);
+	hdr->magic = PANIC_MAGIC;
+	hdr->version = PHDR_VERSION;
+
+	hdr->console_offset = console_offset;
+	hdr->console_length = console_len;
+
+	hdr->threads_offset = threads_offset;
+	hdr->threads_length = threads_len;
+
+	rc = apanic_writeflashpage(ctx->mtd, 0, ctx->bounce);
+	if (rc <= 0) {
+		printk(KERN_EMERG "apanic: Header write failed (%d)\n",
+		       rc);
+		goto out;
+	}
+
+	printk(KERN_EMERG "apanic: Panic dump sucessfully written to flash\n");
+
+ out:
+#ifdef CONFIG_PREEMPT
+	sub_preempt_count(PREEMPT_ACTIVE);
+#endif
+	in_panic = 0;
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block panic_blk = {
+	.notifier_call	= apanic,
+};
+
+static int panic_dbg_get(void *data, u64 *val)
+{
+	apanic(NULL, 0, NULL);
+	return 0;
+}
+
+static int panic_dbg_set(void *data, u64 val)
+{
+	BUG();
+	return -1;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(panic_dbg_fops, panic_dbg_get, panic_dbg_set, "%llu\n");
+
+int __init apanic_init(void)
+{
+	register_mtd_user(&mtd_panic_notifier);
+	atomic_notifier_chain_register(&panic_notifier_list, &panic_blk);
+	debugfs_create_file("apanic", 0644, NULL, NULL, &panic_dbg_fops);
+	memset(&drv_ctx, 0, sizeof(drv_ctx));
+	drv_ctx.bounce = (void *) __get_free_page(GFP_KERNEL);
+	INIT_WORK(&proc_removal_work, apanic_remove_proc_work);
+	printk(KERN_INFO "Android kernel panic handler initialized (bind=%s)\n",
+	       CONFIG_APANIC_PLABEL);
+	return 0;
+}
+
+module_init(apanic_init);
diff -Nur linux-2.6.29/drivers/misc/Kconfig linux-2.6.29-spica/drivers/misc/Kconfig
--- linux-2.6.29/drivers/misc/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/misc/Kconfig	2010-03-30 11:00:35.000000000 +0700
@@ -13,6 +13,10 @@
 
 if MISC_DEVICES
 
+config ANDROID_PMEM
+	bool "Android pmem allocator"
+	default y
+
 config ATMEL_PWM
 	tristate "Atmel AT32/AT91 PWM support"
 	depends on AVR32 || ARCH_AT91SAM9263 || ARCH_AT91SAM9RL || ARCH_AT91CAP9
@@ -159,6 +163,13 @@
 	  driver (SCSI/ATA) which supports enclosures
 	  or a SCSI enclosure device (SES) to use these services.
 
+config KERNEL_DEBUGGER_CORE
+	bool "Kernel Debugger Core"
+	default n
+	---help---
+	  Generic kernel debugging command processor used by low level
+	  (interrupt context) platform-specific debuggers.
+
 config SGI_XP
 	tristate "Support communication between SGI SSIs"
 	depends on NET
@@ -223,6 +234,32 @@
 	This driver adds support for rfkill and backlight control to Dell
 	laptops.
 
+config UID_STAT
+	bool "UID based statistics tracking exported to /proc/uid_stat"
+	default n
+
+config WL127X_RFKILL
+	tristate "Bluetooth power control driver for TI wl127x"
+	depends on RFKILL
+	default n
+	---help---
+	 Creates an rfkill entry in sysfs for power control of Bluetooth
+	 TI wl127x chips.
+
+config APANIC
+	bool "Android kernel panic diagnostics driver"
+	default n
+	---help---
+	 Driver which handles kernel panics and attempts to write
+	 critical debugging data to flash.
+
+config APANIC_PLABEL
+	string "Android panic dump flash partition label"
+	default "kpanic"
+	---help---
+	 If your platform uses a different flash partition label for storing
+ 	 crashdumps, enter it here.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 
diff -Nur linux-2.6.29/drivers/misc/kernel_debugger.c linux-2.6.29-spica/drivers/misc/kernel_debugger.c
--- linux-2.6.29/drivers/misc/kernel_debugger.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/misc/kernel_debugger.c	2010-03-30 11:00:35.000000000 +0700
@@ -0,0 +1,79 @@
+/* drivers/android/kernel_debugger.c
+ *
+ * Guts of the kernel debugger.
+ * Needs something to actually push commands to it.
+ *
+ * Copyright (C) 2007-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/ctype.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/sysrq.h>
+#include <linux/kernel_debugger.h>
+
+#define dprintf(fmt...) (ctxt->printf(ctxt->cookie, fmt))
+
+static void do_ps(struct kdbg_ctxt *ctxt)
+{
+	struct task_struct *g, *p;
+	unsigned state;
+	static const char stat_nam[] = "RSDTtZX";
+
+	dprintf("pid   ppid  prio task            pc\n");
+	read_lock(&tasklist_lock);
+	do_each_thread(g, p) {
+		state = p->state ? __ffs(p->state) + 1 : 0;
+		dprintf("%5d %5d %4d ", p->pid, p->parent->pid, p->prio);
+		dprintf("%-13.13s %c", p->comm,
+			state >= sizeof(stat_nam) ? '?' : stat_nam[state]);
+		if (state == TASK_RUNNING)
+			dprintf(" running\n");
+		else
+			dprintf(" %08lx\n", thread_saved_pc(p));
+	} while_each_thread(g, p);
+	read_unlock(&tasklist_lock);
+}
+
+int log_buf_copy(char *dest, int idx, int len);
+extern int do_syslog(int type, char __user *bug, int count);
+static void do_sysrq(struct kdbg_ctxt *ctxt, char rq)
+{
+	char buf[128];
+	int ret;
+	int idx = 0;
+	do_syslog(5 /* clear */, NULL, 0);
+	__handle_sysrq(rq, NULL, 0);
+	while (1) {
+		ret = log_buf_copy(buf, idx, sizeof(buf) - 1);
+		if (ret <= 0)
+			break;
+		buf[ret] = 0;
+		dprintf("%s", buf);
+		idx += ret;
+	}
+}
+
+int kernel_debugger(struct kdbg_ctxt *ctxt, char *cmd)
+{
+	if (!strcmp(cmd, "ps"))
+		do_ps(ctxt);
+	if (!strcmp(cmd, "sysrq"))
+		do_sysrq(ctxt, 'h');
+	if (!strncmp(cmd, "sysrq ", 6))
+		do_sysrq(ctxt, cmd[6]);
+
+	return 0;
+}
+
diff -Nur linux-2.6.29/drivers/misc/Makefile linux-2.6.29-spica/drivers/misc/Makefile
--- linux-2.6.29/drivers/misc/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/misc/Makefile	2010-03-30 11:00:35.000000000 +0700
@@ -12,11 +12,16 @@
 obj-$(CONFIG_TIFM_CORE)       	+= tifm_core.o
 obj-$(CONFIG_TIFM_7XX1)       	+= tifm_7xx1.o
 obj-$(CONFIG_PHANTOM)		+= phantom.o
+obj-$(CONFIG_ANDROID_PMEM)	+= pmem.o
 obj-$(CONFIG_SGI_IOC4)		+= ioc4.o
 obj-$(CONFIG_ENCLOSURE_SERVICES) += enclosure.o
+obj-$(CONFIG_KERNEL_DEBUGGER_CORE)	+= kernel_debugger.o
 obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
 obj-$(CONFIG_SGI_XP)		+= sgi-xp/
 obj-$(CONFIG_SGI_GRU)		+= sgi-gru/
 obj-$(CONFIG_HP_ILO)		+= hpilo.o
+obj-$(CONFIG_UID_STAT)		+= uid_stat.o
 obj-$(CONFIG_C2PORT)		+= c2port/
 obj-y				+= eeprom/
+obj-$(CONFIG_WL127X_RFKILL)	+= wl127x-rfkill.o
+obj-$(CONFIG_APANIC)		+= apanic.o
diff -Nur linux-2.6.29/drivers/misc/pmem.c linux-2.6.29-spica/drivers/misc/pmem.c
--- linux-2.6.29/drivers/misc/pmem.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/misc/pmem.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,1335 @@
+/* drivers/android/pmem.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/list.h>
+#include <linux/debugfs.h>
+#include <linux/android_pmem.h>
+#include <linux/mempolicy.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/cacheflush.h>
+
+#define PMEM_MAX_DEVICES 10
+#define PMEM_MAX_ORDER 128
+#define PMEM_MIN_ALLOC PAGE_SIZE
+
+#define PMEM_DEBUG 1
+
+/* indicates that a refernce to this file has been taken via get_pmem_file,
+ * the file should not be released until put_pmem_file is called */
+#define PMEM_FLAGS_BUSY 0x1
+/* indicates that this is a suballocation of a larger master range */
+#define PMEM_FLAGS_CONNECTED 0x1 << 1
+/* indicates this is a master and not a sub allocation and that it is mmaped */
+#define PMEM_FLAGS_MASTERMAP 0x1 << 2
+/* submap and unsubmap flags indicate:
+ * 00: subregion has never been mmaped
+ * 10: subregion has been mmaped, reference to the mm was taken
+ * 11: subretion has ben released, refernece to the mm still held
+ * 01: subretion has been released, reference to the mm has been released
+ */
+#define PMEM_FLAGS_SUBMAP 0x1 << 3
+#define PMEM_FLAGS_UNSUBMAP 0x1 << 4
+
+
+struct pmem_data {
+	/* in alloc mode: an index into the bitmap
+	 * in no_alloc mode: the size of the allocation */
+	int index;
+	/* see flags above for descriptions */
+	unsigned int flags;
+	/* protects this data field, if the mm_mmap sem will be held at the
+	 * same time as this sem, the mm sem must be taken first (as this is
+	 * the order for vma_open and vma_close ops */
+	struct rw_semaphore sem;
+	/* info about the mmaping process */
+	struct vm_area_struct *vma;
+	/* task struct of the mapping process */
+	struct task_struct *task;
+	/* process id of teh mapping process */
+	pid_t pid;
+	/* file descriptor of the master */
+	int master_fd;
+	/* file struct of the master */
+	struct file *master_file;
+	/* a list of currently available regions if this is a suballocation */
+	struct list_head region_list;
+	/* a linked list of data so we can access them for debugging */
+	struct list_head list;
+#if PMEM_DEBUG
+	int ref;
+#endif
+};
+
+struct pmem_bits {
+	unsigned allocated:1;		/* 1 if allocated, 0 if free */
+	unsigned order:7;		/* size of the region in pmem space */
+};
+
+struct pmem_region_node {
+	struct pmem_region region;
+	struct list_head list;
+};
+
+#define PMEM_DEBUG_MSGS 0
+#if PMEM_DEBUG_MSGS
+#define DLOG(fmt,args...) \
+	do { printk(KERN_INFO "[%s:%s:%d] "fmt, __FILE__, __func__, __LINE__, \
+		    ##args); } \
+	while (0)
+#else
+#define DLOG(x...) do {} while (0)
+#endif
+
+struct pmem_info {
+	struct miscdevice dev;
+	/* physical start address of the remaped pmem space */
+	unsigned long base;
+	/* vitual start address of the remaped pmem space */
+	unsigned char __iomem *vbase;
+	/* total size of the pmem space */
+	unsigned long size;
+	/* number of entries in the pmem space */
+	unsigned long num_entries;
+	/* pfn of the garbage page in memory */
+	unsigned long garbage_pfn;
+	/* index of the garbage page in the pmem space */
+	int garbage_index;
+	/* the bitmap for the region indicating which entries are allocated
+	 * and which are free */
+	struct pmem_bits *bitmap;
+	/* indicates the region should not be managed with an allocator */
+	unsigned no_allocator;
+	/* indicates maps of this region should be cached, if a mix of
+	 * cached and uncached is desired, set this and open the device with
+	 * O_SYNC to get an uncached region */
+	unsigned cached;
+	unsigned buffered;
+	/* in no_allocator mode the first mapper gets the whole space and sets
+	 * this flag */
+	unsigned allocated;
+	/* for debugging, creates a list of pmem file structs, the
+	 * data_list_sem should be taken before pmem_data->sem if both are
+	 * needed */
+	struct semaphore data_list_sem;
+	struct list_head data_list;
+	/* pmem_sem protects the bitmap array
+	 * a write lock should be held when modifying entries in bitmap
+	 * a read lock should be held when reading data from bits or
+	 * dereferencing a pointer into bitmap
+	 *
+	 * pmem_data->sem protects the pmem data of a particular file
+	 * Many of the function that require the pmem_data->sem have a non-
+	 * locking version for when the caller is already holding that sem.
+	 *
+	 * IF YOU TAKE BOTH LOCKS TAKE THEM IN THIS ORDER:
+	 * down(pmem_data->sem) => down(bitmap_sem)
+	 */
+	struct rw_semaphore bitmap_sem;
+
+	long (*ioctl)(struct file *, unsigned int, unsigned long);
+	int (*release)(struct inode *, struct file *);
+};
+
+static struct pmem_info pmem[PMEM_MAX_DEVICES];
+static int id_count;
+
+#define PMEM_IS_FREE(id, index) !(pmem[id].bitmap[index].allocated)
+#define PMEM_ORDER(id, index) pmem[id].bitmap[index].order
+#define PMEM_BUDDY_INDEX(id, index) (index ^ (1 << PMEM_ORDER(id, index)))
+#define PMEM_NEXT_INDEX(id, index) (index + (1 << PMEM_ORDER(id, index)))
+#define PMEM_OFFSET(index) (index * PMEM_MIN_ALLOC)
+#define PMEM_START_ADDR(id, index) (PMEM_OFFSET(index) + pmem[id].base)
+#define PMEM_LEN(id, index) ((1 << PMEM_ORDER(id, index)) * PMEM_MIN_ALLOC)
+#define PMEM_END_ADDR(id, index) (PMEM_START_ADDR(id, index) + \
+	PMEM_LEN(id, index))
+#define PMEM_START_VADDR(id, index) (PMEM_OFFSET(id, index) + pmem[id].vbase)
+#define PMEM_END_VADDR(id, index) (PMEM_START_VADDR(id, index) + \
+	PMEM_LEN(id, index))
+#define PMEM_REVOKED(data) (data->flags & PMEM_FLAGS_REVOKED)
+#define PMEM_IS_PAGE_ALIGNED(addr) (!((addr) & (~PAGE_MASK)))
+#define PMEM_IS_SUBMAP(data) ((data->flags & PMEM_FLAGS_SUBMAP) && \
+	(!(data->flags & PMEM_FLAGS_UNSUBMAP)))
+
+static int pmem_release(struct inode *, struct file *);
+static int pmem_mmap(struct file *, struct vm_area_struct *);
+static int pmem_open(struct inode *, struct file *);
+static long pmem_ioctl(struct file *, unsigned int, unsigned long);
+
+struct file_operations pmem_fops = {
+	.release = pmem_release,
+	.mmap = pmem_mmap,
+	.open = pmem_open,
+	.unlocked_ioctl = pmem_ioctl,
+};
+
+static int get_id(struct file *file)
+{
+	return MINOR(file->f_dentry->d_inode->i_rdev);
+}
+
+int is_pmem_file(struct file *file)
+{
+	int id;
+
+	if (unlikely(!file || !file->f_dentry || !file->f_dentry->d_inode))
+		return 0;
+	id = get_id(file);
+	if (unlikely(id >= PMEM_MAX_DEVICES))
+		return 0;
+	if (unlikely(file->f_dentry->d_inode->i_rdev !=
+	     MKDEV(MISC_MAJOR, pmem[id].dev.minor)))
+		return 0;
+	return 1;
+}
+
+static int has_allocation(struct file *file)
+{
+	struct pmem_data *data;
+	/* check is_pmem_file first if not accessed via pmem_file_ops */
+
+	if (unlikely(!file->private_data))
+		return 0;
+	data = (struct pmem_data *)file->private_data;
+	if (unlikely(data->index < 0))
+		return 0;
+	return 1;
+}
+
+static int is_master_owner(struct file *file)
+{
+	struct file *master_file;
+	struct pmem_data *data;
+	int put_needed, ret = 0;
+
+	if (!is_pmem_file(file) || !has_allocation(file))
+		return 0;
+	data = (struct pmem_data *)file->private_data;
+	if (PMEM_FLAGS_MASTERMAP & data->flags)
+		return 1;
+	master_file = fget_light(data->master_fd, &put_needed);
+	if (master_file && data->master_file == master_file)
+		ret = 1;
+	fput_light(master_file, put_needed);
+	return ret;
+}
+
+static int pmem_free(int id, int index)
+{
+	/* caller should hold the write lock on pmem_sem! */
+	int buddy, curr = index;
+	DLOG("index %d\n", index);
+
+	if (pmem[id].no_allocator) {
+		pmem[id].allocated = 0;
+		return 0;
+	}
+	/* clean up the bitmap, merging any buddies */
+	pmem[id].bitmap[curr].allocated = 0;
+	/* find a slots buddy Buddy# = Slot# ^ (1 << order)
+	 * if the buddy is also free merge them
+	 * repeat until the buddy is not free or end of the bitmap is reached
+	 */
+	do {
+		buddy = PMEM_BUDDY_INDEX(id, curr);
+		if (PMEM_IS_FREE(id, buddy) &&
+				PMEM_ORDER(id, buddy) == PMEM_ORDER(id, curr)) {
+			PMEM_ORDER(id, buddy)++;
+			PMEM_ORDER(id, curr)++;
+			curr = min(buddy, curr);
+		} else {
+			break;
+		}
+	} while (curr < pmem[id].num_entries);
+
+	return 0;
+}
+
+static void pmem_revoke(struct file *file, struct pmem_data *data);
+
+static int pmem_release(struct inode *inode, struct file *file)
+{
+	struct pmem_data *data = (struct pmem_data *)file->private_data;
+	struct pmem_region_node *region_node;
+	struct list_head *elt, *elt2;
+	int id = get_id(file), ret = 0;
+
+
+	down(&pmem[id].data_list_sem);
+	/* if this file is a master, revoke all the memory in the connected
+	 *  files */
+	if (PMEM_FLAGS_MASTERMAP & data->flags) {
+		struct pmem_data *sub_data;
+		list_for_each(elt, &pmem[id].data_list) {
+			sub_data = list_entry(elt, struct pmem_data, list);
+			down_read(&sub_data->sem);
+			if (PMEM_IS_SUBMAP(sub_data) &&
+			    file == sub_data->master_file) {
+				up_read(&sub_data->sem);
+				pmem_revoke(file, sub_data);
+			}  else
+				up_read(&sub_data->sem);
+		}
+	}
+	list_del(&data->list);
+	up(&pmem[id].data_list_sem);
+
+
+	down_write(&data->sem);
+
+	/* if its not a conencted file and it has an allocation, free it */
+	if (!(PMEM_FLAGS_CONNECTED & data->flags) && has_allocation(file)) {
+		down_write(&pmem[id].bitmap_sem);
+		ret = pmem_free(id, data->index);
+		up_write(&pmem[id].bitmap_sem);
+	}
+
+	/* if this file is a submap (mapped, connected file), downref the
+	 * task struct */
+	if (PMEM_FLAGS_SUBMAP & data->flags)
+		if (data->task) {
+			put_task_struct(data->task);
+			data->task = NULL;
+		}
+
+	file->private_data = NULL;
+
+	list_for_each_safe(elt, elt2, &data->region_list) {
+		region_node = list_entry(elt, struct pmem_region_node, list);
+		list_del(elt);
+		kfree(region_node);
+	}
+	BUG_ON(!list_empty(&data->region_list));
+
+	up_write(&data->sem);
+	kfree(data);
+	if (pmem[id].release)
+		ret = pmem[id].release(inode, file);
+
+	return ret;
+}
+
+static int pmem_open(struct inode *inode, struct file *file)
+{
+	struct pmem_data *data;
+	int id = get_id(file);
+	int ret = 0;
+
+	DLOG("current %u file %p(%d)\n", current->pid, file, file_count(file));
+	/* setup file->private_data to indicate its unmapped */
+	/*  you can only open a pmem device one time */
+	if (file->private_data != NULL)
+		return -1;
+	data = kmalloc(sizeof(struct pmem_data), GFP_KERNEL);
+	if (!data) {
+		printk("pmem: unable to allocate memory for pmem metadata.");
+		return -1;
+	}
+	data->flags = 0;
+	data->index = -1;
+	data->task = NULL;
+	data->vma = NULL;
+	data->pid = 0;
+	data->master_file = NULL;
+#if PMEM_DEBUG
+	data->ref = 0;
+#endif
+	INIT_LIST_HEAD(&data->region_list);
+	init_rwsem(&data->sem);
+
+	file->private_data = data;
+	INIT_LIST_HEAD(&data->list);
+
+	down(&pmem[id].data_list_sem);
+	list_add(&data->list, &pmem[id].data_list);
+	up(&pmem[id].data_list_sem);
+	return ret;
+}
+
+static unsigned long pmem_order(unsigned long len)
+{
+	int i;
+
+	len = (len + PMEM_MIN_ALLOC - 1)/PMEM_MIN_ALLOC;
+	len--;
+	for (i = 0; i < sizeof(len)*8; i++)
+		if (len >> i == 0)
+			break;
+	return i;
+}
+
+static int pmem_allocate(int id, unsigned long len)
+{
+	/* caller should hold the write lock on pmem_sem! */
+	/* return the corresponding pdata[] entry */
+	int curr = 0;
+	int end = pmem[id].num_entries;
+	int best_fit = -1;
+	unsigned long order = pmem_order(len);
+
+	if (pmem[id].no_allocator) {
+		DLOG("no allocator");
+		if ((len > pmem[id].size) || pmem[id].allocated)
+			return -1;
+		pmem[id].allocated = 1;
+		return len;
+	}
+
+	if (order > PMEM_MAX_ORDER)
+		return -1;
+	DLOG("order %lx\n", order);
+
+	/* look through the bitmap:
+	 * 	if you find a free slot of the correct order use it
+	 * 	otherwise, use the best fit (smallest with size > order) slot
+	 */
+	while (curr < end) {
+		if (PMEM_IS_FREE(id, curr)) {
+			if (PMEM_ORDER(id, curr) == (unsigned char)order) {
+				/* set the not free bit and clear others */
+				best_fit = curr;
+				break;
+			}
+			if (PMEM_ORDER(id, curr) > (unsigned char)order &&
+			    (best_fit < 0 ||
+			     PMEM_ORDER(id, curr) < PMEM_ORDER(id, best_fit)))
+				best_fit = curr;
+		}
+		curr = PMEM_NEXT_INDEX(id, curr);
+	}
+
+	/* if best_fit < 0, there are no suitable slots,
+	 * return an error
+	 */
+	if (best_fit < 0) {
+		printk("pmem: no space left to allocate!\n");
+		return -1;
+	}
+
+	/* now partition the best fit:
+	 * 	split the slot into 2 buddies of order - 1
+	 * 	repeat until the slot is of the correct order
+	 */
+	while (PMEM_ORDER(id, best_fit) > (unsigned char)order) {
+		int buddy;
+		PMEM_ORDER(id, best_fit) -= 1;
+		buddy = PMEM_BUDDY_INDEX(id, best_fit);
+		PMEM_ORDER(id, buddy) = PMEM_ORDER(id, best_fit);
+	}
+	pmem[id].bitmap[best_fit].allocated = 1;
+	return best_fit;
+}
+
+static pgprot_t phys_mem_access_prot(struct file *file, pgprot_t vma_prot)
+{
+	int id = get_id(file);
+#ifdef pgprot_noncached
+	if (pmem[id].cached == 0 || file->f_flags & O_SYNC)
+		return pgprot_noncached(vma_prot);
+#endif
+#ifdef pgprot_ext_buffered
+	else if (pmem[id].buffered)
+		return pgprot_ext_buffered(vma_prot);
+#endif
+	return vma_prot;
+}
+
+static unsigned long pmem_start_addr(int id, struct pmem_data *data)
+{
+	if (pmem[id].no_allocator)
+		return PMEM_START_ADDR(id, 0);
+	else
+		return PMEM_START_ADDR(id, data->index);
+
+}
+
+static void *pmem_start_vaddr(int id, struct pmem_data *data)
+{
+	return pmem_start_addr(id, data) - pmem[id].base + pmem[id].vbase;
+}
+
+static unsigned long pmem_len(int id, struct pmem_data *data)
+{
+	if (pmem[id].no_allocator)
+		return data->index;
+	else
+		return PMEM_LEN(id, data->index);
+}
+
+static int pmem_map_garbage(int id, struct vm_area_struct *vma,
+			    struct pmem_data *data, unsigned long offset,
+			    unsigned long len)
+{
+	int i, garbage_pages = len >> PAGE_SHIFT;
+
+	vma->vm_flags |= VM_IO | VM_RESERVED | VM_PFNMAP | VM_SHARED | VM_WRITE;
+	for (i = 0; i < garbage_pages; i++) {
+		if (vm_insert_pfn(vma, vma->vm_start + offset + (i * PAGE_SIZE),
+		    pmem[id].garbage_pfn))
+			return -EAGAIN;
+	}
+	return 0;
+}
+
+static int pmem_unmap_pfn_range(int id, struct vm_area_struct *vma,
+				struct pmem_data *data, unsigned long offset,
+				unsigned long len)
+{
+	int garbage_pages;
+	DLOG("unmap offset %lx len %lx\n", offset, len);
+
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(len));
+
+	garbage_pages = len >> PAGE_SHIFT;
+	zap_page_range(vma, vma->vm_start + offset, len, NULL);
+	pmem_map_garbage(id, vma, data, offset, len);
+	return 0;
+}
+
+static int pmem_map_pfn_range(int id, struct vm_area_struct *vma,
+			      struct pmem_data *data, unsigned long offset,
+			      unsigned long len)
+{
+	DLOG("map offset %lx len %lx\n", offset, len);
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(vma->vm_start));
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(vma->vm_end));
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(len));
+	BUG_ON(!PMEM_IS_PAGE_ALIGNED(offset));
+
+	if (io_remap_pfn_range(vma, vma->vm_start + offset,
+		(pmem_start_addr(id, data) + offset) >> PAGE_SHIFT,
+		len, vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static int pmem_remap_pfn_range(int id, struct vm_area_struct *vma,
+			      struct pmem_data *data, unsigned long offset,
+			      unsigned long len)
+{
+	/* hold the mm semp for the vma you are modifying when you call this */
+	BUG_ON(!vma);
+	zap_page_range(vma, vma->vm_start + offset, len, NULL);
+	return pmem_map_pfn_range(id, vma, data, offset, len);
+}
+
+static void pmem_vma_open(struct vm_area_struct *vma)
+{
+	struct file *file = vma->vm_file;
+	struct pmem_data *data = file->private_data;
+	int id = get_id(file);
+	/* this should never be called as we don't support copying pmem
+	 * ranges via fork */
+	BUG_ON(!has_allocation(file));
+	down_write(&data->sem);
+	/* remap the garbage pages, forkers don't get access to the data */
+	pmem_unmap_pfn_range(id, vma, data, 0, vma->vm_start - vma->vm_end);
+	up_write(&data->sem);
+}
+
+static void pmem_vma_close(struct vm_area_struct *vma)
+{
+	struct file *file = vma->vm_file;
+	struct pmem_data *data = file->private_data;
+
+	DLOG("current %u ppid %u file %p count %d\n", current->pid,
+	     current->parent->pid, file, file_count(file));
+	if (unlikely(!is_pmem_file(file) || !has_allocation(file))) {
+		printk(KERN_WARNING "pmem: something is very wrong, you are "
+		       "closing a vm backing an allocation that doesn't "
+		       "exist!\n");
+		return;
+	}
+	down_write(&data->sem);
+	if (data->vma == vma) {
+		data->vma = NULL;
+		if ((data->flags & PMEM_FLAGS_CONNECTED) &&
+		    (data->flags & PMEM_FLAGS_SUBMAP))
+			data->flags |= PMEM_FLAGS_UNSUBMAP;
+	}
+	/* the kernel is going to free this vma now anyway */
+	up_write(&data->sem);
+}
+
+static struct vm_operations_struct vm_ops = {
+	.open = pmem_vma_open,
+	.close = pmem_vma_close,
+};
+
+static int pmem_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct pmem_data *data;
+	int index;
+	unsigned long vma_size =  vma->vm_end - vma->vm_start;
+	int ret = 0, id = get_id(file);
+
+	if (vma->vm_pgoff || !PMEM_IS_PAGE_ALIGNED(vma_size)) {
+#if PMEM_DEBUG
+		printk(KERN_ERR "pmem: mmaps must be at offset zero, aligned"
+				" and a multiple of pages_size.\n");
+#endif
+		return -EINVAL;
+	}
+
+	data = (struct pmem_data *)file->private_data;
+	down_write(&data->sem);
+	/* check this file isn't already mmaped, for submaps check this file
+	 * has never been mmaped */
+	if ((data->flags & PMEM_FLAGS_MASTERMAP) ||
+	    (data->flags & PMEM_FLAGS_SUBMAP) ||
+	    (data->flags & PMEM_FLAGS_UNSUBMAP)) {
+#if PMEM_DEBUG
+		printk(KERN_ERR "pmem: you can only mmap a pmem file once, "
+		       "this file is already mmaped. %x\n", data->flags);
+#endif
+		ret = -EINVAL;
+		goto error;
+	}
+	/* if file->private_data == unalloced, alloc*/
+	if (data && data->index == -1) {
+		down_write(&pmem[id].bitmap_sem);
+		index = pmem_allocate(id, vma->vm_end - vma->vm_start);
+		up_write(&pmem[id].bitmap_sem);
+		data->index = index;
+	}
+	/* either no space was available or an error occured */
+	if (!has_allocation(file)) {
+		ret = -EINVAL;
+		printk("pmem: could not find allocation for map.\n");
+		goto error;
+	}
+
+	if (pmem_len(id, data) < vma_size) {
+#if PMEM_DEBUG
+		printk(KERN_WARNING "pmem: mmap size [%lu] does not match"
+		       "size of backing region [%lu].\n", vma_size,
+		       pmem_len(id, data));
+#endif
+		ret = -EINVAL;
+		goto error;
+	}
+
+	vma->vm_pgoff = pmem_start_addr(id, data) >> PAGE_SHIFT;
+	vma->vm_page_prot = phys_mem_access_prot(file, vma->vm_page_prot);
+
+	if (data->flags & PMEM_FLAGS_CONNECTED) {
+		struct pmem_region_node *region_node;
+		struct list_head *elt;
+		if (pmem_map_garbage(id, vma, data, 0, vma_size)) {
+			printk("pmem: mmap failed in kernel!\n");
+			ret = -EAGAIN;
+			goto error;
+		}
+		list_for_each(elt, &data->region_list) {
+			region_node = list_entry(elt, struct pmem_region_node,
+						 list);
+			DLOG("remapping file: %p %lx %lx\n", file,
+				region_node->region.offset,
+				region_node->region.len);
+			if (pmem_remap_pfn_range(id, vma, data,
+						 region_node->region.offset,
+						 region_node->region.len)) {
+				ret = -EAGAIN;
+				goto error;
+			}
+		}
+		data->flags |= PMEM_FLAGS_SUBMAP;
+		get_task_struct(current->group_leader);
+		data->task = current->group_leader;
+		data->vma = vma;
+#if PMEM_DEBUG
+		data->pid = current->pid;
+#endif
+		DLOG("submmapped file %p vma %p pid %u\n", file, vma,
+		     current->pid);
+	} else {
+		if (pmem_map_pfn_range(id, vma, data, 0, vma_size)) {
+			printk(KERN_INFO "pmem: mmap failed in kernel!\n");
+			ret = -EAGAIN;
+			goto error;
+		}
+		data->flags |= PMEM_FLAGS_MASTERMAP;
+		data->pid = current->pid;
+	}
+	vma->vm_ops = &vm_ops;
+error:
+	up_write(&data->sem);
+	return ret;
+}
+
+/* the following are the api for accessing pmem regions by other drivers
+ * from inside the kernel */
+int get_pmem_user_addr(struct file *file, unsigned long *start,
+		   unsigned long *len)
+{
+	struct pmem_data *data;
+	if (!is_pmem_file(file) || !has_allocation(file)) {
+#if PMEM_DEBUG
+		printk(KERN_INFO "pmem: requested pmem data from invalid"
+				  "file.\n");
+#endif
+		return -1;
+	}
+	data = (struct pmem_data *)file->private_data;
+	down_read(&data->sem);
+	if (data->vma) {
+		*start = data->vma->vm_start;
+		*len = data->vma->vm_end - data->vma->vm_start;
+	} else {
+		*start = 0;
+		*len = 0;
+	}
+	up_read(&data->sem);
+	return 0;
+}
+
+int get_pmem_addr(struct file *file, unsigned long *start,
+		  unsigned long *vstart, unsigned long *len)
+{
+	struct pmem_data *data;
+	int id;
+
+	if (!is_pmem_file(file) || !has_allocation(file)) {
+		return -1;
+	}
+
+	data = (struct pmem_data *)file->private_data;
+	if (data->index == -1) {
+#if PMEM_DEBUG
+		printk(KERN_INFO "pmem: requested pmem data from file with no "
+		       "allocation.\n");
+		return -1;
+#endif
+	}
+	id = get_id(file);
+
+	down_read(&data->sem);
+	*start = pmem_start_addr(id, data);
+	*len = pmem_len(id, data);
+	*vstart = (unsigned long)pmem_start_vaddr(id, data);
+	up_read(&data->sem);
+#if PMEM_DEBUG
+	down_write(&data->sem);
+	data->ref++;
+	up_write(&data->sem);
+#endif
+	return 0;
+}
+
+int get_pmem_file(int fd, unsigned long *start, unsigned long *vstart,
+		  unsigned long *len, struct file **filp)
+{
+	struct file *file;
+
+	file = fget(fd);
+	if (unlikely(file == NULL)) {
+		printk(KERN_INFO "pmem: requested data from file descriptor "
+		       "that doesn't exist.");
+		return -1;
+	}
+
+	if (get_pmem_addr(file, start, vstart, len))
+		goto end;
+
+	if (filp)
+		*filp = file;
+	return 0;
+end:
+	fput(file);
+	return -1;
+}
+
+void put_pmem_file(struct file *file)
+{
+	struct pmem_data *data;
+	int id;
+
+	if (!is_pmem_file(file))
+		return;
+	id = get_id(file);
+	data = (struct pmem_data *)file->private_data;
+#if PMEM_DEBUG
+	down_write(&data->sem);
+	if (data->ref == 0) {
+		printk("pmem: pmem_put > pmem_get %s (pid %d)\n",
+		       pmem[id].dev.name, data->pid);
+		BUG();
+	}
+	data->ref--;
+	up_write(&data->sem);
+#endif
+	fput(file);
+}
+
+void flush_pmem_file(struct file *file, unsigned long offset, unsigned long len)
+{
+	struct pmem_data *data;
+	int id;
+	void *vaddr;
+	struct pmem_region_node *region_node;
+	struct list_head *elt;
+	void *flush_start, *flush_end;
+
+	if (!is_pmem_file(file) || !has_allocation(file)) {
+		return;
+	}
+
+	id = get_id(file);
+	data = (struct pmem_data *)file->private_data;
+	if (!pmem[id].cached || file->f_flags & O_SYNC)
+		return;
+
+	down_read(&data->sem);
+	vaddr = pmem_start_vaddr(id, data);
+	/* if this isn't a submmapped file, flush the whole thing */
+	if (unlikely(!(data->flags & PMEM_FLAGS_CONNECTED))) {
+		dmac_flush_range(vaddr, vaddr + pmem_len(id, data));
+		goto end;
+	}
+	/* otherwise, flush the region of the file we are drawing */
+	list_for_each(elt, &data->region_list) {
+		region_node = list_entry(elt, struct pmem_region_node, list);
+		if ((offset >= region_node->region.offset) &&
+		    ((offset + len) <= (region_node->region.offset +
+			region_node->region.len))) {
+			flush_start = vaddr + region_node->region.offset;
+			flush_end = flush_start + region_node->region.len;
+			dmac_flush_range(flush_start, flush_end);
+			break;
+		}
+	}
+end:
+	up_read(&data->sem);
+}
+
+static int pmem_connect(unsigned long connect, struct file *file)
+{
+	struct pmem_data *data = (struct pmem_data *)file->private_data;
+	struct pmem_data *src_data;
+	struct file *src_file;
+	int ret = 0, put_needed;
+
+	down_write(&data->sem);
+	/* retrieve the src file and check it is a pmem file with an alloc */
+	src_file = fget_light(connect, &put_needed);
+	DLOG("connect %p to %p\n", file, src_file);
+	if (!src_file) {
+		printk("pmem: src file not found!\n");
+		ret = -EINVAL;
+		goto err_no_file;
+	}
+	if (unlikely(!is_pmem_file(src_file) || !has_allocation(src_file))) {
+		printk(KERN_INFO "pmem: src file is not a pmem file or has no "
+		       "alloc!\n");
+		ret = -EINVAL;
+		goto err_bad_file;
+	}
+	src_data = (struct pmem_data *)src_file->private_data;
+
+	if (has_allocation(file) && (data->index != src_data->index)) {
+		printk("pmem: file is already mapped but doesn't match this"
+		       " src_file!\n");
+		ret = -EINVAL;
+		goto err_bad_file;
+	}
+	data->index = src_data->index;
+	data->flags |= PMEM_FLAGS_CONNECTED;
+	data->master_fd = connect;
+	data->master_file = src_file;
+
+err_bad_file:
+	fput_light(src_file, put_needed);
+err_no_file:
+	up_write(&data->sem);
+	return ret;
+}
+
+static void pmem_unlock_data_and_mm(struct pmem_data *data,
+				    struct mm_struct *mm)
+{
+	up_write(&data->sem);
+	if (mm != NULL) {
+		up_write(&mm->mmap_sem);
+		mmput(mm);
+	}
+}
+
+static int pmem_lock_data_and_mm(struct file *file, struct pmem_data *data,
+				 struct mm_struct **locked_mm)
+{
+	int ret = 0;
+	struct mm_struct *mm = NULL;
+	*locked_mm = NULL;
+lock_mm:
+	down_read(&data->sem);
+	if (PMEM_IS_SUBMAP(data)) {
+		mm = get_task_mm(data->task);
+		if (!mm) {
+#if PMEM_DEBUG
+			printk("pmem: can't remap task is gone!\n");
+#endif
+			up_read(&data->sem);
+			return -1;
+		}
+	}
+	up_read(&data->sem);
+
+	if (mm)
+		down_write(&mm->mmap_sem);
+
+	down_write(&data->sem);
+	/* check that the file didn't get mmaped before we could take the
+	 * data sem, this should be safe b/c you can only submap each file
+	 * once */
+	if (PMEM_IS_SUBMAP(data) && !mm) {
+		pmem_unlock_data_and_mm(data, mm);
+		up_write(&data->sem);
+		goto lock_mm;
+	}
+	/* now check that vma.mm is still there, it could have been
+	 * deleted by vma_close before we could get the data->sem */
+	if ((data->flags & PMEM_FLAGS_UNSUBMAP) && (mm != NULL)) {
+		/* might as well release this */
+		if (data->flags & PMEM_FLAGS_SUBMAP) {
+			put_task_struct(data->task);
+			data->task = NULL;
+			/* lower the submap flag to show the mm is gone */
+			data->flags &= ~(PMEM_FLAGS_SUBMAP);
+		}
+		pmem_unlock_data_and_mm(data, mm);
+		return -1;
+	}
+	*locked_mm = mm;
+	return ret;
+}
+
+int pmem_remap(struct pmem_region *region, struct file *file,
+		      unsigned operation)
+{
+	int ret;
+	struct pmem_region_node *region_node;
+	struct mm_struct *mm = NULL;
+	struct list_head *elt, *elt2;
+	int id = get_id(file);
+	struct pmem_data *data = (struct pmem_data *)file->private_data;
+
+	/* pmem region must be aligned on a page boundry */
+	if (unlikely(!PMEM_IS_PAGE_ALIGNED(region->offset) ||
+		 !PMEM_IS_PAGE_ALIGNED(region->len))) {
+#if PMEM_DEBUG
+		printk("pmem: request for unaligned pmem suballocation "
+		       "%lx %lx\n", region->offset, region->len);
+#endif
+		return -EINVAL;
+	}
+
+	/* if userspace requests a region of len 0, there's nothing to do */
+	if (region->len == 0)
+		return 0;
+
+	/* lock the mm and data */
+	ret = pmem_lock_data_and_mm(file, data, &mm);
+	if (ret)
+		return 0;
+
+	/* only the owner of the master file can remap the client fds
+	 * that back in it */
+	if (!is_master_owner(file)) {
+#if PMEM_DEBUG
+		printk("pmem: remap requested from non-master process\n");
+#endif
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/* check that the requested range is within the src allocation */
+	if (unlikely((region->offset > pmem_len(id, data)) ||
+		     (region->len > pmem_len(id, data)) ||
+		     (region->offset + region->len > pmem_len(id, data)))) {
+#if PMEM_DEBUG
+		printk(KERN_INFO "pmem: suballoc doesn't fit in src_file!\n");
+#endif
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (operation == PMEM_MAP) {
+		region_node = kmalloc(sizeof(struct pmem_region_node),
+			      GFP_KERNEL);
+		if (!region_node) {
+			ret = -ENOMEM;
+#if PMEM_DEBUG
+			printk(KERN_INFO "No space to allocate metadata!");
+#endif
+			goto err;
+		}
+		region_node->region = *region;
+		list_add(&region_node->list, &data->region_list);
+	} else if (operation == PMEM_UNMAP) {
+		int found = 0;
+		list_for_each_safe(elt, elt2, &data->region_list) {
+			region_node = list_entry(elt, struct pmem_region_node,
+				      list);
+			if (region->len == 0 ||
+			    (region_node->region.offset == region->offset &&
+			    region_node->region.len == region->len)) {
+				list_del(elt);
+				kfree(region_node);
+				found = 1;
+			}
+		}
+		if (!found) {
+#if PMEM_DEBUG
+			printk("pmem: Unmap region does not map any mapped "
+				"region!");
+#endif
+			ret = -EINVAL;
+			goto err;
+		}
+	}
+
+	if (data->vma && PMEM_IS_SUBMAP(data)) {
+		if (operation == PMEM_MAP)
+			ret = pmem_remap_pfn_range(id, data->vma, data,
+						   region->offset, region->len);
+		else if (operation == PMEM_UNMAP)
+			ret = pmem_unmap_pfn_range(id, data->vma, data,
+						   region->offset, region->len);
+	}
+
+err:
+	pmem_unlock_data_and_mm(data, mm);
+	return ret;
+}
+
+static void pmem_revoke(struct file *file, struct pmem_data *data)
+{
+	struct pmem_region_node *region_node;
+	struct list_head *elt, *elt2;
+	struct mm_struct *mm = NULL;
+	int id = get_id(file);
+	int ret = 0;
+
+	data->master_file = NULL;
+	ret = pmem_lock_data_and_mm(file, data, &mm);
+	/* if lock_data_and_mm fails either the task that mapped the fd, or
+	 * the vma that mapped it have already gone away, nothing more
+	 * needs to be done */
+	if (ret)
+		return;
+	/* unmap everything */
+	/* delete the regions and region list nothing is mapped any more */
+	if (data->vma)
+		list_for_each_safe(elt, elt2, &data->region_list) {
+			region_node = list_entry(elt, struct pmem_region_node,
+						 list);
+			pmem_unmap_pfn_range(id, data->vma, data,
+					     region_node->region.offset,
+					     region_node->region.len);
+			list_del(elt);
+			kfree(region_node);
+	}
+	/* delete the master file */
+	pmem_unlock_data_and_mm(data, mm);
+}
+
+static void pmem_get_size(struct pmem_region *region, struct file *file)
+{
+	struct pmem_data *data = (struct pmem_data *)file->private_data;
+	int id = get_id(file);
+
+	if (!has_allocation(file)) {
+		region->offset = 0;
+		region->len = 0;
+		return;
+	} else {
+		region->offset = pmem_start_addr(id, data);
+		region->len = pmem_len(id, data);
+	}
+	DLOG("offset %lx len %lx\n", region->offset, region->len);
+}
+
+
+static long pmem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct pmem_data *data;
+	int id = get_id(file);
+
+	switch (cmd) {
+	case PMEM_GET_PHYS:
+		{
+			struct pmem_region region;
+			DLOG("get_phys\n");
+			if (!has_allocation(file)) {
+				region.offset = 0;
+				region.len = 0;
+			} else {
+				data = (struct pmem_data *)file->private_data;
+				region.offset = pmem_start_addr(id, data);
+				region.len = pmem_len(id, data);
+			}
+//			printk(KERN_INFO "pmem: request for physical address of pmem region "
+//					"from process %d.\n", current->pid);
+			if (copy_to_user((void __user *)arg, &region,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			break;
+		}
+	case PMEM_MAP:
+		{
+			struct pmem_region region;
+			if (copy_from_user(&region, (void __user *)arg,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			data = (struct pmem_data *)file->private_data;
+			return pmem_remap(&region, file, PMEM_MAP);
+		}
+		break;
+	case PMEM_UNMAP:
+		{
+			struct pmem_region region;
+			if (copy_from_user(&region, (void __user *)arg,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			data = (struct pmem_data *)file->private_data;
+			return pmem_remap(&region, file, PMEM_UNMAP);
+			break;
+		}
+	case PMEM_GET_SIZE:
+		{
+			struct pmem_region region;
+			DLOG("get_size\n");
+			pmem_get_size(&region, file);
+			if (copy_to_user((void __user *)arg, &region,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			break;
+		}
+	case PMEM_GET_TOTAL_SIZE:
+		{
+			struct pmem_region region;
+			DLOG("get total size\n");
+			region.offset = 0;
+			get_id(file);
+			region.len = pmem[id].size;
+			if (copy_to_user((void __user *)arg, &region,
+						sizeof(struct pmem_region)))
+				return -EFAULT;
+			break;
+		}
+	case PMEM_ALLOCATE:
+		{
+			if (has_allocation(file))
+				return -EINVAL;
+			data = (struct pmem_data *)file->private_data;
+			data->index = pmem_allocate(id, arg);
+			break;
+		}
+	case PMEM_CONNECT:
+		DLOG("connect\n");
+		return pmem_connect(arg, file);
+		break;
+	default:
+		if (pmem[id].ioctl)
+			return pmem[id].ioctl(file, cmd, arg);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+#if PMEM_DEBUG
+static ssize_t debug_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t debug_read(struct file *file, char __user *buf, size_t count,
+			  loff_t *ppos)
+{
+	struct list_head *elt, *elt2;
+	struct pmem_data *data;
+	struct pmem_region_node *region_node;
+	int id = (int)file->private_data;
+	const int debug_bufmax = 4096;
+	static char buffer[4096];
+	int n = 0;
+
+	DLOG("debug open\n");
+	n = scnprintf(buffer, debug_bufmax,
+		      "pid #: mapped regions (offset, len) (offset,len)...\n");
+
+	down(&pmem[id].data_list_sem);
+	list_for_each(elt, &pmem[id].data_list) {
+		data = list_entry(elt, struct pmem_data, list);
+		down_read(&data->sem);
+		n += scnprintf(buffer + n, debug_bufmax - n, "pid %u:",
+				data->pid);
+		list_for_each(elt2, &data->region_list) {
+			region_node = list_entry(elt2, struct pmem_region_node,
+				      list);
+			n += scnprintf(buffer + n, debug_bufmax - n,
+					"(%lx,%lx) ",
+					region_node->region.offset,
+					region_node->region.len);
+		}
+		n += scnprintf(buffer + n, debug_bufmax - n, "\n");
+		up_read(&data->sem);
+	}
+	up(&pmem[id].data_list_sem);
+
+	n++;
+	buffer[n] = 0;
+	return simple_read_from_buffer(buf, count, ppos, buffer, n);
+}
+
+static struct file_operations debug_fops = {
+	.read = debug_read,
+	.open = debug_open,
+};
+#endif
+
+#if 0
+static struct miscdevice pmem_dev = {
+	.name = "pmem",
+	.fops = &pmem_fops,
+};
+#endif
+
+int pmem_setup(struct android_pmem_platform_data *pdata,
+	       long (*ioctl)(struct file *, unsigned int, unsigned long),
+	       int (*release)(struct inode *, struct file *))
+{
+	int err = 0;
+	int i, index = 0;
+	int id = id_count;
+	id_count++;
+
+	pmem[id].no_allocator = pdata->no_allocator;
+	pmem[id].cached = pdata->cached;
+	pmem[id].buffered = pdata->buffered;
+	pmem[id].base = pdata->start;
+	pmem[id].size = pdata->size;
+	pmem[id].ioctl = ioctl;
+	pmem[id].release = release;
+	init_rwsem(&pmem[id].bitmap_sem);
+	init_MUTEX(&pmem[id].data_list_sem);
+	INIT_LIST_HEAD(&pmem[id].data_list);
+	pmem[id].dev.name = pdata->name;
+	pmem[id].dev.minor = id;
+	pmem[id].dev.fops = &pmem_fops;
+	printk(KERN_INFO "%s: %d init\n", pdata->name, pdata->cached);
+
+	err = misc_register(&pmem[id].dev);
+	if (err) {
+		printk(KERN_ALERT "Unable to register pmem driver!\n");
+		goto err_cant_register_device;
+	}
+	pmem[id].num_entries = pmem[id].size / PMEM_MIN_ALLOC;
+
+	pmem[id].bitmap = kmalloc(pmem[id].num_entries *
+				  sizeof(struct pmem_bits), GFP_KERNEL);
+	if (!pmem[id].bitmap)
+		goto err_no_mem_for_metadata;
+
+	memset(pmem[id].bitmap, 0, sizeof(struct pmem_bits) *
+					  pmem[id].num_entries);
+
+	for (i = sizeof(pmem[id].num_entries) * 8 - 1; i >= 0; i--) {
+		if ((pmem[id].num_entries) &  1<<i) {
+			PMEM_ORDER(id, index) = i;
+			index = PMEM_NEXT_INDEX(id, index);
+		}
+	}
+
+	if (pmem[id].cached)
+		pmem[id].vbase = ioremap_cached(pmem[id].base,
+						pmem[id].size);
+#ifdef ioremap_ext_buffered
+	else if (pmem[id].buffered)
+		pmem[id].vbase = ioremap_ext_buffered(pmem[id].base,
+						      pmem[id].size);
+#endif
+	else
+		pmem[id].vbase = ioremap(pmem[id].base, pmem[id].size);
+
+	if (pmem[id].vbase == 0)
+		goto error_cant_remap;
+
+	pmem[id].garbage_pfn = page_to_pfn(alloc_page(GFP_KERNEL));
+	if (pmem[id].no_allocator)
+		pmem[id].allocated = 0;
+
+#if PMEM_DEBUG
+	debugfs_create_file(pdata->name, S_IFREG | S_IRUGO, NULL, (void *)id,
+			    &debug_fops);
+#endif
+	return 0;
+error_cant_remap:
+	kfree(pmem[id].bitmap);
+err_no_mem_for_metadata:
+	misc_deregister(&pmem[id].dev);
+err_cant_register_device:
+	return -1;
+}
+
+static int pmem_probe(struct platform_device *pdev)
+{
+	struct android_pmem_platform_data *pdata;
+
+	if (!pdev || !pdev->dev.platform_data) {
+		printk(KERN_ALERT "Unable to probe pmem!\n");
+		return -1;
+	}
+	pdata = pdev->dev.platform_data;
+	return pmem_setup(pdata, NULL, NULL);
+}
+
+
+static int pmem_remove(struct platform_device *pdev)
+{
+	int id = pdev->id;
+	__free_page(pfn_to_page(pmem[id].garbage_pfn));
+	misc_deregister(&pmem[id].dev);
+	return 0;
+}
+
+static struct platform_driver pmem_driver = {
+	.probe = pmem_probe,
+	.remove = pmem_remove,
+	.driver = { .name = "android_pmem" }
+};
+
+
+static int __init pmem_init(void)
+{
+	return platform_driver_register(&pmem_driver);
+}
+
+static void __exit pmem_exit(void)
+{
+	platform_driver_unregister(&pmem_driver);
+}
+
+module_init(pmem_init);
+module_exit(pmem_exit);
+
diff -Nur linux-2.6.29/drivers/misc/uid_stat.c linux-2.6.29-spica/drivers/misc/uid_stat.c
--- linux-2.6.29/drivers/misc/uid_stat.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/misc/uid_stat.c	2010-03-30 11:00:35.000000000 +0700
@@ -0,0 +1,153 @@
+/* drivers/misc/uid_stat.c
+ *
+ * Copyright (C) 2008 - 2009 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/atomic.h>
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/stat.h>
+#include <linux/uid_stat.h>
+
+static DEFINE_SPINLOCK(uid_lock);
+static LIST_HEAD(uid_list);
+static struct proc_dir_entry *parent;
+
+struct uid_stat {
+	struct list_head link;
+	uid_t uid;
+	atomic_t tcp_rcv;
+	atomic_t tcp_snd;
+};
+
+static struct uid_stat *find_uid_stat(uid_t uid) {
+	unsigned long flags;
+	struct uid_stat *entry;
+
+	spin_lock_irqsave(&uid_lock, flags);
+	list_for_each_entry(entry, &uid_list, link) {
+		if (entry->uid == uid) {
+			spin_unlock_irqrestore(&uid_lock, flags);
+			return entry;
+		}
+	}
+	spin_unlock_irqrestore(&uid_lock, flags);
+	return NULL;
+}
+
+static int tcp_snd_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	int len;
+	unsigned int bytes;
+	char *p = page;
+	struct uid_stat *uid_entry = (struct uid_stat *) data;
+	if (!data)
+		return 0;
+
+	bytes = (unsigned int) (atomic_read(&uid_entry->tcp_snd) + INT_MIN);
+	p += sprintf(p, "%u\n", bytes);
+	len = (p - page) - off;
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+	return len;
+}
+
+static int tcp_rcv_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	int len;
+	unsigned int bytes;
+	char *p = page;
+	struct uid_stat *uid_entry = (struct uid_stat *) data;
+	if (!data)
+		return 0;
+
+	bytes = (unsigned int) (atomic_read(&uid_entry->tcp_rcv) + INT_MIN);
+	p += sprintf(p, "%u\n", bytes);
+	len = (p - page) - off;
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+	return len;
+}
+
+/* Create a new entry for tracking the specified uid. */
+static struct uid_stat *create_stat(uid_t uid) {
+	unsigned long flags;
+	char uid_s[32];
+	struct uid_stat *new_uid;
+	struct proc_dir_entry *entry;
+
+	/* Create the uid stat struct and append it to the list. */
+	if ((new_uid = kmalloc(sizeof(struct uid_stat), GFP_KERNEL)) == NULL)
+		return NULL;
+
+	new_uid->uid = uid;
+	/* Counters start at INT_MIN, so we can track 4GB of network traffic. */
+	atomic_set(&new_uid->tcp_rcv, INT_MIN);
+	atomic_set(&new_uid->tcp_snd, INT_MIN);
+
+	spin_lock_irqsave(&uid_lock, flags);
+	list_add_tail(&new_uid->link, &uid_list);
+	spin_unlock_irqrestore(&uid_lock, flags);
+
+	sprintf(uid_s, "%d", uid);
+	entry = proc_mkdir(uid_s, parent);
+
+	/* Keep reference to uid_stat so we know what uid to read stats from. */
+	create_proc_read_entry("tcp_snd", S_IRUGO, entry , tcp_snd_read_proc,
+		(void *) new_uid);
+
+	create_proc_read_entry("tcp_rcv", S_IRUGO, entry, tcp_rcv_read_proc,
+		(void *) new_uid);
+
+	return new_uid;
+}
+
+int update_tcp_snd(uid_t uid, int size) {
+	struct uid_stat *entry;
+	if ((entry = find_uid_stat(uid)) == NULL &&
+		((entry = create_stat(uid)) == NULL)) {
+			return -1;
+	}
+	atomic_add(size, &entry->tcp_snd);
+	return 0;
+}
+
+int update_tcp_rcv(uid_t uid, int size) {
+	struct uid_stat *entry;
+	if ((entry = find_uid_stat(uid)) == NULL &&
+		((entry = create_stat(uid)) == NULL)) {
+			return -1;
+	}
+	atomic_add(size, &entry->tcp_rcv);
+	return 0;
+}
+
+static int __init uid_stat_init(void)
+{
+	parent = proc_mkdir("uid_stat", NULL);
+	if (!parent) {
+		pr_err("uid_stat: failed to create proc entry\n");
+		return -1;
+	}
+	return 0;
+}
+
+__initcall(uid_stat_init);
diff -Nur linux-2.6.29/drivers/misc/wl127x-rfkill.c linux-2.6.29-spica/drivers/misc/wl127x-rfkill.c
--- linux-2.6.29/drivers/misc/wl127x-rfkill.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/misc/wl127x-rfkill.c	2010-03-30 11:00:35.000000000 +0700
@@ -0,0 +1,121 @@
+/*
+ * Bluetooth TI wl127x rfkill power control via GPIO
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ * Copyright (C) 2008 Texas Instruments
+ * Initial code: Pavan Savoy <pavan.savoy@gmail.com> (wl127x_power.c)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/rfkill.h>
+#include <linux/platform_device.h>
+#include <linux/wl127x-rfkill.h>
+
+static int wl127x_rfkill_set_power(void *data, enum rfkill_state state)
+{
+	int nshutdown_gpio = (int) data;
+
+	switch (state) {
+	case RFKILL_STATE_UNBLOCKED:
+		gpio_set_value(nshutdown_gpio, 1);
+		break;
+	case RFKILL_STATE_SOFT_BLOCKED:
+		gpio_set_value(nshutdown_gpio, 0);
+		break;
+	default:
+		printk(KERN_ERR "invalid bluetooth rfkill state %d\n", state);
+	}
+	return 0;
+}
+
+static int wl127x_rfkill_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+	struct wl127x_rfkill_platform_data *pdata = pdev->dev.platform_data;
+	enum rfkill_state default_state = RFKILL_STATE_SOFT_BLOCKED;  /* off */
+
+	rc = gpio_request(pdata->nshutdown_gpio, "wl127x_nshutdown_gpio");
+	if (unlikely(rc))
+		return rc;
+
+	rc = gpio_direction_output(pdata->nshutdown_gpio, 0);
+	if (unlikely(rc))
+		return rc;
+
+	rfkill_set_default(RFKILL_TYPE_BLUETOOTH, default_state);
+	wl127x_rfkill_set_power(NULL, default_state);
+
+	pdata->rfkill = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
+	if (unlikely(!pdata->rfkill))
+		return -ENOMEM;
+
+	pdata->rfkill->name = "wl127x";
+	pdata->rfkill->state = default_state;
+	/* userspace cannot take exclusive control */
+	pdata->rfkill->user_claim_unsupported = 1;
+	pdata->rfkill->user_claim = 0;
+	pdata->rfkill->data = (void *) pdata->nshutdown_gpio;
+	pdata->rfkill->toggle_radio = wl127x_rfkill_set_power;
+
+	rc = rfkill_register(pdata->rfkill);
+
+	if (unlikely(rc))
+		rfkill_free(pdata->rfkill);
+
+	return 0;
+}
+
+static int wl127x_rfkill_remove(struct platform_device *pdev)
+{
+	struct wl127x_rfkill_platform_data *pdata = pdev->dev.platform_data;
+
+	rfkill_unregister(pdata->rfkill);
+	rfkill_free(pdata->rfkill);
+	gpio_free(pdata->nshutdown_gpio);
+
+	return 0;
+}
+
+static struct platform_driver wl127x_rfkill_platform_driver = {
+	.probe = wl127x_rfkill_probe,
+	.remove = wl127x_rfkill_remove,
+	.driver = {
+		   .name = "wl127x-rfkill",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init wl127x_rfkill_init(void)
+{
+	return platform_driver_register(&wl127x_rfkill_platform_driver);
+}
+
+static void __exit wl127x_rfkill_exit(void)
+{
+	platform_driver_unregister(&wl127x_rfkill_platform_driver);
+}
+
+module_init(wl127x_rfkill_init);
+module_exit(wl127x_rfkill_exit);
+
+MODULE_ALIAS("platform:wl127x");
+MODULE_DESCRIPTION("wl127x-rfkill");
+MODULE_AUTHOR("Motorola");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/mmc/card/block.c linux-2.6.29-spica/drivers/mmc/card/block.c
--- linux-2.6.29/drivers/mmc/card/block.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/card/block.c	2010-05-06 12:42:45.674299703 +0700
@@ -41,6 +41,8 @@
 
 #include "queue.h"
 
+MODULE_ALIAS("mmc:block");
+
 /*
  * max 8 partitions per card
  */
@@ -145,7 +147,8 @@
 static u32 mmc_sd_num_wr_blocks(struct mmc_card *card)
 {
 	int err;
-	__be32 blocks;
+	u32 result;
+	__be32 *blocks;
 
 	struct mmc_request mrq;
 	struct mmc_command cmd;
@@ -197,14 +200,21 @@
 	mrq.cmd = &cmd;
 	mrq.data = &data;
 
-	sg_init_one(&sg, &blocks, 4);
+	blocks = kmalloc(4, GFP_KERNEL);
+	if (!blocks)
+		return (u32)-1;
+
+	sg_init_one(&sg, blocks, 4);
 
 	mmc_wait_for_req(card->host, &mrq);
 
+	result = ntohl(*blocks);
+	kfree(blocks);
+
 	if (cmd.error || data.error)
-		return (u32)-1;
+		result = (u32)-1;
 
-	return ntohl(blocks);
+	return result;
 }
 
 static u32 get_card_status(struct mmc_card *card, struct request *req)
@@ -224,6 +234,33 @@
 	return cmd.resp[0];
 }
 
+static int
+mmc_blk_set_blksize(struct mmc_blk_data *md, struct mmc_card *card)
+{
+	struct mmc_command cmd;
+	int err;
+
+	/* Block-addressed cards ignore MMC_SET_BLOCKLEN. */
+	if (mmc_card_blockaddr(card))
+		return 0;
+
+	mmc_claim_host(card->host);
+	cmd.opcode = MMC_SET_BLOCKLEN;
+	cmd.arg = 512;
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
+	err = mmc_wait_for_cmd(card->host, &cmd, 5);
+	mmc_release_host(card->host);
+
+	if (err) {
+		printk(KERN_ERR "%s: unable to set block size to %d: %d\n",
+			md->disk->disk_name, cmd.arg, err);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
 static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 {
 	struct mmc_blk_data *md = mq->data;
@@ -231,6 +268,13 @@
 	struct mmc_blk_request brq;
 	int ret = 1, disable_multi = 0;
 
+#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
+	if (mmc_bus_needs_resume(card->host)) {
+		mmc_resume_bus(card->host);
+		mmc_blk_set_blksize(md, card);
+	}
+#endif
+
 	mmc_claim_host(card->host);
 
 	do {
@@ -252,6 +296,14 @@
 		brq.data.blocks = req->nr_sectors;
 
 		/*
+		 * The block layer doesn't support all sector count
+		 * restrictions, so we need to be prepared for too big
+		 * requests.
+		 */
+		if (brq.data.blocks > card->host->max_blk_count)
+			brq.data.blocks = card->host->max_blk_count;
+
+		/*
 		 * After a read error, we redo the request one sector at a time
 		 * in order to accurately determine which sectors can be read
 		 * successfully.
@@ -326,31 +378,26 @@
 				continue;
 			}
 			status = get_card_status(card, req);
+		} else if (disable_multi == 1) {
+			disable_multi = 0;
 		}
 
 		if (brq.cmd.error) {
-			printk(KERN_ERR "%s: error %d sending read/write "
-			       "command, response %#x, card status %#x\n",
-			       req->rq_disk->disk_name, brq.cmd.error,
-			       brq.cmd.resp[0], status);
+			/* Change from KERN_ERR to KERN_DEBUG to eliminate SD card notification sound crach. */
+			printk(KERN_DEBUG "%s: error %d sending read/write command\n",
+			       req->rq_disk->disk_name, brq.cmd.error);
 		}
 
 		if (brq.data.error) {
-			if (brq.data.error == -ETIMEDOUT && brq.mrq.stop)
-				/* 'Stop' response contains card status */
-				status = brq.mrq.stop->resp[0];
-			printk(KERN_ERR "%s: error %d transferring data,"
-			       " sector %u, nr %u, card status %#x\n",
-			       req->rq_disk->disk_name, brq.data.error,
-			       (unsigned)req->sector,
-			       (unsigned)req->nr_sectors, status);
+			/* Change from KERN_ERR to KERN_DEBUG to eliminate SD card notification sound crach. */
+			printk(KERN_DEBUG "%s: error %d transferring data\n",
+			       req->rq_disk->disk_name, brq.data.error);
 		}
 
 		if (brq.stop.error) {
-			printk(KERN_ERR "%s: error %d sending stop command, "
-			       "response %#x, card status %#x\n",
-			       req->rq_disk->disk_name, brq.stop.error,
-			       brq.stop.resp[0], status);
+			/* Change from KERN_ERR to KERN_DEBUG to eliminate SD card notification sound crach. */
+			printk(KERN_DEBUG "%s: error %d sending stop command\n",
+			       req->rq_disk->disk_name, brq.stop.error);
 		}
 
 		if (!mmc_host_is_spi(card->host) && rq_data_dir(req) != READ) {
@@ -362,7 +409,8 @@
 				cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
 				err = mmc_wait_for_cmd(card->host, &cmd, 5);
 				if (err) {
-					printk(KERN_ERR "%s: error %d requesting status\n",
+					/* Change from KERN_ERR to KERN_DEBUG to eliminate SD card notification sound crach. */
+					printk(KERN_DEBUG "%s: error %d requesting status\n",
 					       req->rq_disk->disk_name, err);
 					goto cmd_err;
 				}
@@ -537,32 +585,6 @@
 	return ERR_PTR(ret);
 }
 
-static int
-mmc_blk_set_blksize(struct mmc_blk_data *md, struct mmc_card *card)
-{
-	struct mmc_command cmd;
-	int err;
-
-	/* Block-addressed cards ignore MMC_SET_BLOCKLEN. */
-	if (mmc_card_blockaddr(card))
-		return 0;
-
-	mmc_claim_host(card->host);
-	cmd.opcode = MMC_SET_BLOCKLEN;
-	cmd.arg = 512;
-	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
-	err = mmc_wait_for_cmd(card->host, &cmd, 5);
-	mmc_release_host(card->host);
-
-	if (err) {
-		printk(KERN_ERR "%s: unable to set block size to %d: %d\n",
-			md->disk->disk_name, cmd.arg, err);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
 static int mmc_blk_probe(struct mmc_card *card)
 {
 	struct mmc_blk_data *md;
@@ -591,6 +613,9 @@
 		cap_str, md->read_only ? "(ro)" : "");
 
 	mmc_set_drvdata(card, md);
+#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
+	mmc_set_bus_resume_policy(card->host, 1);
+#endif
 	add_disk(md->disk);
 	return 0;
 
@@ -614,6 +639,9 @@
 		mmc_blk_put(md);
 	}
 	mmc_set_drvdata(card, NULL);
+#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
+	mmc_set_bus_resume_policy(card->host, 0);
+#endif
 }
 
 #ifdef CONFIG_PM
@@ -632,7 +660,9 @@
 	struct mmc_blk_data *md = mmc_get_drvdata(card);
 
 	if (md) {
+#ifndef CONFIG_MMC_BLOCK_DEFERRED_RESUME
 		mmc_blk_set_blksize(md, card);
+#endif
 		mmc_queue_resume(&md->queue);
 	}
 	return 0;
diff -Nur linux-2.6.29/drivers/mmc/card/Kconfig linux-2.6.29-spica/drivers/mmc/card/Kconfig
--- linux-2.6.29/drivers/mmc/card/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/card/Kconfig	2010-03-30 11:01:12.000000000 +0700
@@ -32,6 +32,15 @@
 
 	  If unsure, say Y here.
 
+config MMC_BLOCK_DEFERRED_RESUME
+	bool "Deferr MMC layer resume until I/O is requested"
+	depends on MMC_BLOCK
+	default n
+	help
+	  Say Y here to enable deferred MMC resume until I/O
+	  is requested. This will reduce overall resume latency and
+	  save power when theres an SD card inserted but not being used.
+
 config SDIO_UART
 	tristate "SDIO UART/GPS class support"
 	help
diff -Nur linux-2.6.29/drivers/mmc/core/bus.c linux-2.6.29-spica/drivers/mmc/core/bus.c
--- linux-2.6.29/drivers/mmc/core/bus.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/core/bus.c	2010-03-30 11:01:12.000000000 +0700
@@ -84,6 +84,14 @@
 	}
 
 	retval = add_uevent_var(env, "MMC_NAME=%s", mmc_card_name(card));
+	if (retval)
+		return retval;
+
+	/*
+	 * Request the mmc_block device.  Note: that this is a direct request
+	 * for the module it carries no information as to what is inserted.
+	 */
+	retval = add_uevent_var(env, "MODALIAS=mmc:block");
 
 	return retval;
 }
diff -Nur linux-2.6.29/drivers/mmc/core/core.c linux-2.6.29-spica/drivers/mmc/core/core.c
--- linux-2.6.29/drivers/mmc/core/core.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/core/core.c	2010-05-06 12:42:45.674299703 +0700
@@ -21,6 +21,7 @@
 #include <linux/leds.h>
 #include <linux/scatterlist.h>
 #include <linux/log2.h>
+#include <linux/wakelock.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -36,7 +37,11 @@
 #include "sd_ops.h"
 #include "sdio_ops.h"
 
+#include <linux/io.h>
+#include <plat/regs-gpio.h>
+
 static struct workqueue_struct *workqueue;
+static struct wake_lock mmc_delayed_work_wake_lock;
 
 /*
  * Enabling software CRCs on the data blocks can be a significant (30%)
@@ -52,6 +57,7 @@
 static int mmc_schedule_delayed_work(struct delayed_work *work,
 				     unsigned long delay)
 {
+	wake_lock(&mmc_delayed_work_wake_lock);
 	return queue_delayed_work(workqueue, work, delay);
 }
 
@@ -591,7 +597,7 @@
 	 * This delay should be sufficient to allow the power supply
 	 * to reach the minimum voltage.
 	 */
-	mmc_delay(2);
+	mmc_delay(10);
 
 	host->ios.clock = host->f_min;
 	host->ios.power_mode = MMC_POWER_ON;
@@ -601,7 +607,7 @@
 	 * This delay must be at least 74 clock sizes, or 1 ms, or the
 	 * time required to reach a stable voltage.
 	 */
-	mmc_delay(2);
+	mmc_delay(10);
 }
 
 static void mmc_power_off(struct mmc_host *host)
@@ -657,6 +663,30 @@
 	spin_unlock_irqrestore(&host->lock, flags);
 }
 
+int mmc_resume_bus(struct mmc_host *host)
+{
+	if (!mmc_bus_needs_resume(host))
+		return -EINVAL;
+
+	printk("%s: Starting deferred resume\n", mmc_hostname(host));
+	host->bus_resume_flags &= ~MMC_BUSRESUME_NEEDS_RESUME;
+	mmc_bus_get(host);
+	if (host->bus_ops && !host->bus_dead) {
+		mmc_power_up(host);
+		BUG_ON(!host->bus_ops->resume);
+		host->bus_ops->resume(host);
+	}
+
+	if (host->bus_ops->detect && !host->bus_dead)
+		host->bus_ops->detect(host);
+
+	mmc_bus_put(host);
+	printk("%s: Deferred resume completed\n", mmc_hostname(host));
+	return 0;
+}
+
+EXPORT_SYMBOL(mmc_resume_bus);
+
 /*
  * Assign a mmc bus handler to a host. Only one bus handler may control a
  * host at any given time.
@@ -730,6 +760,7 @@
 
 EXPORT_SYMBOL(mmc_detect_change);
 
+int g_rescan_retry = 0;
 
 void mmc_rescan(struct work_struct *work)
 {
@@ -737,65 +768,117 @@
 		container_of(work, struct mmc_host, detect.work);
 	u32 ocr;
 	int err;
+	int extend_wakelock = 0;
+	int ext_CD_int = 0;
+	unsigned int eint0msk = 0;
+
+	ext_CD_int = readl(S3C64XX_GPNDAT);
+	ext_CD_int &= 0x40;	/* GPN6 */
 
 	mmc_bus_get(host);
 
-	if (host->bus_ops == NULL) {
-		/*
-		 * Only we can add a new handler, so it's safe to
-		 * release the lock here.
-		 */
-		mmc_bus_put(host);
+	/* if there is a card registered, check whether it is still present */
+	if ((host->bus_ops != NULL) &&
+            host->bus_ops->detect && !host->bus_dead) {
+		host->bus_ops->detect(host);
+		/* If the card was removed the bus will be marked
+		 * as dead - extend the wakelock so userspace
+		 * can respond */
+		if (host->bus_dead)
+			extend_wakelock = 1;
+	}
 
-		if (host->ops->get_cd && host->ops->get_cd(host) == 0)
-			goto out;
+	mmc_bus_put(host);
 
-		mmc_claim_host(host);
 
-		mmc_power_up(host);
-		mmc_go_idle(host);
+	mmc_bus_get(host);
 
-		mmc_send_if_cond(host, host->ocr_avail);
+	/* if there still is a card present, stop here */
+	if (host->bus_ops != NULL) {
+		if (host->bus_ops->detect && !host->bus_dead)
+			host->bus_ops->detect(host);
 
-		/*
-		 * First we search for SDIO...
-		 */
-		err = mmc_send_io_op_cond(host, 0, &ocr);
-		if (!err) {
-			if (mmc_attach_sdio(host, ocr))
-				mmc_power_off(host);
-			goto out;
-		}
+		mmc_bus_put(host);
 
-		/*
-		 * ...then normal SD...
-		 */
-		err = mmc_send_app_op_cond(host, 0, &ocr);
-		if (!err) {
-			if (mmc_attach_sd(host, ocr))
-				mmc_power_off(host);
-			goto out;
+		if(host->index ==0 && g_rescan_retry)
+		{
+			ext_CD_int = readl(S3C64XX_GPNDAT);
+			ext_CD_int &= 0x40;	/* GPN6 */
+
+			if (!ext_CD_int)
+			{
+				mmc_detect_change(host, msecs_to_jiffies(200));
+				g_rescan_retry = 0;
+			}
 		}
+		goto out;
+	}
 
-		/*
-		 * ...and finally MMC.
-		 */
-		err = mmc_send_op_cond(host, 0, &ocr);
-		if (!err) {
-			if (mmc_attach_mmc(host, ocr))
-				mmc_power_off(host);
-			goto out;
-		}
+	/* detect a newly inserted card */
 
-		mmc_release_host(host);
-		mmc_power_off(host);
-	} else {
-		if (host->bus_ops->detect && !host->bus_dead)
-			host->bus_ops->detect(host);
+	/*
+	 * Only we can add a new handler, so it's safe to
+	 * release the lock here.
+	 */
+	mmc_bus_put(host);
 
-		mmc_bus_put(host);
+	if (host->ops->get_cd && host->ops->get_cd(host) == 0)
+		goto out;
+
+	mmc_claim_host(host);
+	mmc_power_up(host);
+	mmc_go_idle(host);
+	mmc_send_if_cond(host, host->ocr_avail);
+
+	/*
+	 * First we search for SDIO...
+	 */
+	err = mmc_send_io_op_cond(host, 0, &ocr);
+	if (!err) {
+		if (mmc_attach_sdio(host, ocr))
+			mmc_power_off(host);
+		extend_wakelock = 1;
+		goto out;
+	}
+
+	/*
+	 * ...then normal SD...
+	 */
+	err = mmc_send_app_op_cond(host, 0, &ocr);
+	if (!err) {
+		if (mmc_attach_sd(host, ocr))
+			mmc_power_off(host);
+		extend_wakelock = 1;
+		goto out;
+	}
+
+	/*
+	 * ...and finally MMC.
+	 */
+	err = mmc_send_op_cond(host, 0, &ocr);
+	if (!err) {
+		if (mmc_attach_mmc(host, ocr))
+			mmc_power_off(host);
+		extend_wakelock = 1;
+		goto out;
+	}
+
+	mmc_release_host(host);
+	mmc_power_off(host);
+
+	if (!ext_CD_int)
+	{
+		eint0msk = __raw_readl(S3C64XX_EINT0MASK);
+		eint0msk &= 0x0FFFFFFF & ~(1 << 6);
+		__raw_writel(eint0msk, S3C64XX_EINT0MASK);
 	}
+
 out:
+	if (extend_wakelock)
+		wake_lock_timeout(&mmc_delayed_work_wake_lock, HZ / 2);
+	else
+		wake_unlock(&mmc_delayed_work_wake_lock);
+
 	if (host->caps & MMC_CAP_NEEDS_POLL)
 		mmc_schedule_delayed_work(&host->detect, HZ);
 }
@@ -815,6 +898,7 @@
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 
+	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
 
 	mmc_bus_get(host);
@@ -842,6 +926,10 @@
  */
 int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 {
+	if (mmc_bus_needs_resume(host))
+		return 0;
+
+	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
 
 	mmc_bus_get(host);
@@ -873,8 +961,15 @@
 int mmc_resume_host(struct mmc_host *host)
 {
 	mmc_bus_get(host);
+	if (host->bus_resume_flags & MMC_BUSRESUME_MANUAL_RESUME) {
+		host->bus_resume_flags |= MMC_BUSRESUME_NEEDS_RESUME;
+		mmc_bus_put(host);
+		return 0;
+	}
+
 	if (host->bus_ops && !host->bus_dead) {
 		mmc_power_up(host);
+		mmc_select_voltage(host, host->ocr);
 		BUG_ON(!host->bus_ops->resume);
 		host->bus_ops->resume(host);
 	}
@@ -893,10 +988,28 @@
 
 #endif
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+void mmc_set_embedded_sdio_data(struct mmc_host *host,
+				struct sdio_cis *cis,
+				struct sdio_cccr *cccr,
+				struct sdio_embedded_func *funcs,
+				int num_funcs)
+{
+	host->embedded_sdio_data.cis = cis;
+	host->embedded_sdio_data.cccr = cccr;
+	host->embedded_sdio_data.funcs = funcs;
+	host->embedded_sdio_data.num_funcs = num_funcs;
+}
+
+EXPORT_SYMBOL(mmc_set_embedded_sdio_data);
+#endif
+
 static int __init mmc_init(void)
 {
 	int ret;
 
+	wake_lock_init(&mmc_delayed_work_wake_lock, WAKE_LOCK_SUSPEND, "mmc_delayed_work");
+
 	workqueue = create_singlethread_workqueue("kmmcd");
 	if (!workqueue)
 		return -ENOMEM;
@@ -931,6 +1044,7 @@
 	mmc_unregister_host_class();
 	mmc_unregister_bus();
 	destroy_workqueue(workqueue);
+	wake_lock_destroy(&mmc_delayed_work_wake_lock);
 }
 
 subsys_initcall(mmc_init);
diff -Nur linux-2.6.29/drivers/mmc/core/debugfs.c linux-2.6.29-spica/drivers/mmc/core/debugfs.c
--- linux-2.6.29/drivers/mmc/core/debugfs.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/core/debugfs.c	2010-03-30 11:01:12.000000000 +0700
@@ -184,6 +184,68 @@
 DEFINE_SIMPLE_ATTRIBUTE(mmc_dbg_card_status_fops, mmc_dbg_card_status_get,
 		NULL, "%08llx\n");
 
+#define EXT_CSD_STR_LEN 1025
+
+static int mmc_ext_csd_open(struct inode *inode, struct file *filp)
+{
+	struct mmc_card *card = inode->i_private;
+	char *buf;
+	ssize_t n = 0;
+	u8 *ext_csd;
+	int err, i;
+
+	buf = kmalloc(EXT_CSD_STR_LEN + 1, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ext_csd = kmalloc(512, GFP_KERNEL);
+	if (!ext_csd) {
+		err = -ENOMEM;
+		goto out_free;
+	}
+
+	mmc_claim_host(card->host);
+	err = mmc_send_ext_csd(card, ext_csd);
+	mmc_release_host(card->host);
+	if (err)
+		goto out_free;
+
+	for (i = 511; i >= 0; i--)
+		n += sprintf(buf + n, "%02x", ext_csd[i]);
+	n += sprintf(buf + n, "\n");
+	BUG_ON(n != EXT_CSD_STR_LEN);
+
+	filp->private_data = buf;
+	kfree(ext_csd);
+	return 0;
+
+out_free:
+	kfree(buf);
+	kfree(ext_csd);
+	return err;
+}
+
+static ssize_t mmc_ext_csd_read(struct file *filp, char __user *ubuf,
+				size_t cnt, loff_t *ppos)
+{
+	char *buf = filp->private_data;
+
+	return simple_read_from_buffer(ubuf, cnt, ppos,
+				       buf, EXT_CSD_STR_LEN);
+}
+
+static int mmc_ext_csd_release(struct inode *inode, struct file *file)
+{
+	kfree(file->private_data);
+	return 0;
+}
+
+static struct file_operations mmc_dbg_ext_csd_fops = {
+	.open		= mmc_ext_csd_open,
+	.read		= mmc_ext_csd_read,
+	.release	= mmc_ext_csd_release,
+};
+
 void mmc_add_card_debugfs(struct mmc_card *card)
 {
 	struct mmc_host	*host = card->host;
@@ -211,6 +273,11 @@
 					&mmc_dbg_card_status_fops))
 			goto err;
 
+	if (mmc_card_mmc(card))
+		if (!debugfs_create_file("ext_csd", S_IRUSR, root, card,
+					&mmc_dbg_ext_csd_fops))
+			goto err;
+
 	return;
 
 err:
diff -Nur linux-2.6.29/drivers/mmc/core/Kconfig linux-2.6.29-spica/drivers/mmc/core/Kconfig
--- linux-2.6.29/drivers/mmc/core/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/core/Kconfig	2010-03-30 11:01:12.000000000 +0700
@@ -14,3 +14,19 @@
 	  This option is usually just for embedded systems which use
 	  a MMC/SD card for rootfs. Most people should say N here.
 
+config MMC_EMBEDDED_SDIO
+	boolean "MMC embedded SDIO device support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  If you say Y here, support will be added for embedded SDIO
+	  devices which do not contain the necessary enumeration
+	  support in hardware to be properly detected.
+
+config MMC_PARANOID_SD_INIT
+	bool "Enable paranoid SD card initialization (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  If you say Y here, the MMC layer will be extra paranoid
+	  about re-trying SD init requests. This can be a useful
+	  work-around for buggy controllers and hardware. Enable
+	  if you are experiencing issues with SD detection.
diff -Nur linux-2.6.29/drivers/mmc/core/sd.c linux-2.6.29-spica/drivers/mmc/core/sd.c
--- linux-2.6.29/drivers/mmc/core/sd.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/core/sd.c	2010-05-06 12:42:45.674299703 +0700
@@ -336,7 +336,9 @@
 	int err;
 	u32 cid[4];
 	unsigned int max_dtr;
-
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries;
+#endif
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
@@ -448,11 +450,29 @@
 		err = mmc_decode_scr(card);
 		if (err < 0)
 			goto free_card;
-
 		/*
 		 * Fetch switch information from card.
 		 */
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+		for (retries = 1; retries <= 3; retries++) {
+			err = mmc_read_switch(card);
+			if (!err) {
+				if (retries > 1) {
+					printk(KERN_WARNING
+					       "%s: recovered\n", 
+					       mmc_hostname(host));
+				}
+				break;
+			} else {
+				printk(KERN_WARNING
+				       "%s: read switch failed (attempt %d)\n",
+				       mmc_hostname(host), retries);
+			}
+		}
+#else
 		err = mmc_read_switch(card);
+#endif
+
 		if (err)
 			goto free_card;
 	}
@@ -535,18 +555,36 @@
  */
 static void mmc_sd_detect(struct mmc_host *host)
 {
-	int err;
+	int err = 0;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+        int retries = 5;
+#endif
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
-
+       
 	mmc_claim_host(host);
 
 	/*
 	 * Just check if our card has been removed.
 	 */
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	while(retries) {
+		err = mmc_send_status(host->card, NULL);
+		if (err) {
+			retries--;
+			udelay(5);
+			continue;
+		}
+		break;
+	}
+	if (!retries) {
+		printk(KERN_ERR "%s(%s): Unable to re-detect card (%d)\n",
+		       __func__, mmc_hostname(host), err);
+	}
+#else
 	err = mmc_send_status(host->card, NULL);
-
+#endif
 	mmc_release_host(host);
 
 	if (err) {
@@ -584,12 +622,31 @@
 static void mmc_sd_resume(struct mmc_host *host)
 {
 	int err;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries;
+#endif
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	retries = 5;
+	while (retries) {
+		err = mmc_sd_init_card(host, host->ocr, host->card);
+
+		if (err) {
+			printk(KERN_ERR "%s: Re-init card rc = %d (retries = %d)\n",
+			       mmc_hostname(host), err, retries);
+			mdelay(5);
+			retries--;
+			continue;
+		}
+		break;
+	}
+#else
 	err = mmc_sd_init_card(host, host->ocr, host->card);
+#endif
 	mmc_release_host(host);
 
 	if (err) {
@@ -622,6 +679,9 @@
 int mmc_attach_sd(struct mmc_host *host, u32 ocr)
 {
 	int err;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries;
+#endif
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
@@ -670,9 +730,27 @@
 	/*
 	 * Detect and init the card.
 	 */
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	retries = 5;
+	while (retries) {
+		err = mmc_sd_init_card(host, host->ocr, NULL);
+		if (err) {
+			retries--;
+			continue;
+		}
+		break;
+	}
+
+	if (!retries) {
+		printk(KERN_ERR "%s: mmc_sd_init_card() failure (err = %d)\n",
+		       mmc_hostname(host), err);
+		goto err;
+	}
+#else
 	err = mmc_sd_init_card(host, host->ocr, NULL);
 	if (err)
 		goto err;
+#endif
 
 	mmc_release_host(host);
 
@@ -690,7 +768,8 @@
 	mmc_detach_bus(host);
 	mmc_release_host(host);
 
-	printk(KERN_ERR "%s: error %d whilst initialising SD card\n",
+	/* Change from KERN_ERR to KERN_DEBUG to eliminate SD card notification sound crach. */
+	printk(KERN_DEBUG "%s: error %d whilst initialising SD card\n",
 		mmc_hostname(host), err);
 
 	return err;
diff -Nur linux-2.6.29/drivers/mmc/core/sdio_bus.c linux-2.6.29-spica/drivers/mmc/core/sdio_bus.c
--- linux-2.6.29/drivers/mmc/core/sdio_bus.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/core/sdio_bus.c	2010-03-30 11:01:12.000000000 +0700
@@ -20,6 +20,10 @@
 #include "sdio_cis.h"
 #include "sdio_bus.h"
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+#include <linux/mmc/host.h>
+#endif
+
 #define dev_to_sdio_func(d)	container_of(d, struct sdio_func, dev)
 #define to_sdio_driver(d)      container_of(d, struct sdio_driver, drv)
 
@@ -202,7 +206,14 @@
 {
 	struct sdio_func *func = dev_to_sdio_func(dev);
 
-	sdio_free_func_cis(func);
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	/*
+	 * If this device is embedded then we never allocated
+	 * cis tables for this func
+	 */
+	if (!func->card->host->embedded_sdio_data.funcs)
+#endif
+		sdio_free_func_cis(func);
 
 	if (func->info)
 		kfree(func->info);
diff -Nur linux-2.6.29/drivers/mmc/core/sdio.c linux-2.6.29-spica/drivers/mmc/core/sdio.c
--- linux-2.6.29/drivers/mmc/core/sdio.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/core/sdio.c	2010-03-30 11:01:12.000000000 +0700
@@ -24,6 +24,10 @@
 #include "sdio_ops.h"
 #include "sdio_cis.h"
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+#include <linux/mmc/sdio_ids.h>
+#endif
+
 static int sdio_read_fbr(struct sdio_func *func)
 {
 	int ret;
@@ -314,6 +318,11 @@
 	 */
 	funcs = (ocr & 0x70000000) >> 28;
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	if (host->embedded_sdio_data.funcs)
+		funcs = host->embedded_sdio_data.num_funcs;
+#endif
+
 	/*
 	 * Allocate card structure.
 	 */
@@ -351,17 +360,33 @@
 	/*
 	 * Read the common registers.
 	 */
-	err = sdio_read_cccr(card);
-	if (err)
-		goto remove;
 
-	/*
-	 * Read the common CIS tuples.
-	 */
-	err = sdio_read_common_cis(card);
-	if (err)
-		goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	if (host->embedded_sdio_data.cccr)
+		memcpy(&card->cccr, host->embedded_sdio_data.cccr, sizeof(struct sdio_cccr));
+	else {
+#endif
+		err = sdio_read_cccr(card);
+		if (err)
+			goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	}
+#endif
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	if (host->embedded_sdio_data.cis)
+		memcpy(&card->cis, host->embedded_sdio_data.cis, sizeof(struct sdio_cis));
+	else {
+#endif
+		/*
+		 * Read the common CIS tuples.
+		 */
+		err = sdio_read_common_cis(card);
+		if (err)
+			goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	}
+#endif
 	/*
 	 * Switch to high-speed (if supported).
 	 */
@@ -395,9 +420,27 @@
 	 * Initialize (but don't add) all present functions.
 	 */
 	for (i = 0;i < funcs;i++) {
-		err = sdio_init_func(host->card, i + 1);
-		if (err)
-			goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+		if (host->embedded_sdio_data.funcs) {
+			struct sdio_func *tmp;
+
+			tmp = sdio_alloc_func(host->card);
+			if (IS_ERR(tmp))
+				goto remove;
+			tmp->num = (i + 1);
+			card->sdio_func[i] = tmp;
+			tmp->class = host->embedded_sdio_data.funcs[i].f_class;
+			tmp->max_blksize = host->embedded_sdio_data.funcs[i].f_maxblksize;
+			tmp->vendor = card->cis.vendor;
+			tmp->device = card->cis.device;
+		} else {
+#endif
+			err = sdio_init_func(host->card, i + 1);
+			if (err)
+				goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+		}
+#endif
 	}
 
 	mmc_release_host(host);
@@ -439,3 +482,61 @@
 	return err;
 }
 
+int sdio_reset_comm(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	u32 ocr;
+	int err;
+
+	printk("%s():\n", __func__);
+	mmc_claim_host(host);
+
+	mmc_go_idle(host);
+
+	mmc_set_clock(host, host->f_min);
+
+	err = mmc_send_io_op_cond(host, 0, &ocr);
+	if (err)
+		goto err;
+
+	host->ocr = mmc_select_voltage(host, ocr);
+	if (!host->ocr) {
+		err = -EINVAL;
+		goto err;
+	}
+
+	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
+	if (err)
+		goto err;
+
+	if (mmc_host_is_spi(host)) {
+		err = mmc_spi_set_crc(host, use_spi_crc);
+		if (err)
+		goto err;
+	}
+
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_send_relative_addr(host, &card->rca);
+		if (err)
+			goto err;
+		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
+	}
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_select_card(card);
+		if (err)
+			goto err;
+	}
+
+	mmc_set_clock(host, card->cis.max_dtr);
+	err = sdio_enable_wide(card);
+	if (err)
+		goto err;
+	mmc_release_host(host);
+	return 0;
+err:
+	printk("%s: Error resetting SDIO communications (%d)\n",
+	       mmc_hostname(host), err);
+	mmc_release_host(host);
+	return err;
+}
+EXPORT_SYMBOL(sdio_reset_comm);
diff -Nur linux-2.6.29/drivers/mmc/core/sdio_io.c linux-2.6.29-spica/drivers/mmc/core/sdio_io.c
--- linux-2.6.29/drivers/mmc/core/sdio_io.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/core/sdio_io.c	2010-03-30 11:01:12.000000000 +0700
@@ -378,6 +378,39 @@
 EXPORT_SYMBOL_GPL(sdio_readb);
 
 /**
+ *	sdio_readb_ext - read a single byte from a SDIO function
+ *	@func: SDIO function to access
+ *	@addr: address to read
+ *	@err_ret: optional status value from transfer
+ *	@in: value to add to argument
+ *
+ *	Reads a single byte from the address space of a given SDIO
+ *	function. If there is a problem reading the address, 0xff
+ *	is returned and @err_ret will contain the error code.
+ */
+unsigned char sdio_readb_ext(struct sdio_func *func, unsigned int addr,
+	int *err_ret, unsigned in)
+{
+	int ret;
+	unsigned char val;
+
+	BUG_ON(!func);
+
+	if (err_ret)
+		*err_ret = 0;
+
+	ret = mmc_io_rw_direct(func->card, 0, func->num, addr, (u8)in, &val);
+	if (ret) {
+		if (err_ret)
+			*err_ret = ret;
+		return 0xFF;
+	}
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(sdio_readb_ext);
+
+/**
  *	sdio_writeb - write a single byte to a SDIO function
  *	@func: SDIO function to access
  *	@b: byte to write
diff -Nur linux-2.6.29/drivers/mmc/host/Kconfig linux-2.6.29-spica/drivers/mmc/host/Kconfig
--- linux-2.6.29/drivers/mmc/host/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/host/Kconfig	2010-05-06 12:42:45.674299703 +0700
@@ -48,6 +48,18 @@
 
 	  If unsure, say N.
 
+config MMC_SDHCI_S3C
+	tristate "SDHCI support on Samsung S3C SoC"
+	depends on MMC_SDHCI && (PLAT_S3C24XX || PLAT_S3C64XX)
+	help
+	  This selects the Secure Digital Host Controller Interface (SDHCI)
+	  often referrered to as the HSMMC block in some of the Samsung S3C
+	  range of SoC.
+	
+	  If you have a controller with this interface, say Y or M here.
+	
+	  If unsure, say N.
+
 config MMC_RICOH_MMC
 	tristate "Ricoh MMC Controller Disabler  (EXPERIMENTAL)"
 	depends on MMC_SDHCI_PCI
diff -Nur linux-2.6.29/drivers/mmc/host/Makefile linux-2.6.29-spica/drivers/mmc/host/Makefile
--- linux-2.6.29/drivers/mmc/host/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/host/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -12,6 +12,7 @@
 obj-$(CONFIG_MMC_MXC)		+= mxcmmc.o
 obj-$(CONFIG_MMC_SDHCI)		+= sdhci.o
 obj-$(CONFIG_MMC_SDHCI_PCI)	+= sdhci-pci.o
+obj-$(CONFIG_MMC_SDHCI_S3C)	+= sdhci-s3c.o
 obj-$(CONFIG_MMC_RICOH_MMC)	+= ricoh_mmc.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
 obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
diff -Nur linux-2.6.29/drivers/mmc/host/sdhci.c linux-2.6.29-spica/drivers/mmc/host/sdhci.c
--- linux-2.6.29/drivers/mmc/host/sdhci.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/host/sdhci.c	2010-05-06 12:42:45.674299703 +0700
@@ -22,9 +22,19 @@
 #include <linux/leds.h>
 
 #include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/clk.h>
 
 #include "sdhci.h"
 
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <plat/regs-gpio.h>
+#include <plat/regs-sdhci.h>
+#include <linux/irq.h>
+
+#define S3C_ACMD_MODE
+
 #define DRIVER_NAME "sdhci"
 
 #define DBG(f, x...) \
@@ -36,6 +46,7 @@
 #endif
 
 static unsigned int debug_quirks = 0;
+static int card_detect = 0;
 
 static void sdhci_prepare_data(struct sdhci_host *, struct mmc_data *);
 static void sdhci_finish_data(struct sdhci_host *);
@@ -43,6 +54,33 @@
 static void sdhci_send_command(struct sdhci_host *, struct mmc_command *);
 static void sdhci_finish_command(struct sdhci_host *);
 
+// TODO-JJ From here
+struct mmc_card_pm dhdpm; 
+
+extern int g_rescan_retry;
+
+void register_mmc_card_pm(struct mmc_card_pm *cardpm)
+{
+	if((cardpm != NULL) && (cardpm->suspend !=NULL) && (cardpm->resume != NULL))
+	{
+	   dhdpm.suspend = cardpm->suspend;
+	   dhdpm.resume = cardpm->resume;
+	   printk("%s: [WIFI] Callbacks registered successfully. \n",__FUNCTION__);
+	}
+	else
+	   printk("%s: Error: Null pointer!! \n", __FUNCTION__);
+}
+EXPORT_SYMBOL(register_mmc_card_pm);
+
+void unregister_mmc_card_pm(void)
+{
+   printk("%s: [WIFI] Unregistering suspend/resume callbacks.  \n", __FUNCTION__);
+   dhdpm.suspend = NULL;
+   dhdpm.resume  = NULL;	
+}
+EXPORT_SYMBOL(unregister_mmc_card_pm);
+// TODO-JJ till here
+
 static void sdhci_dumpregs(struct sdhci_host *host)
 {
 	printk(KERN_DEBUG DRIVER_NAME ": ============== REGISTER DUMP ==============\n");
@@ -78,6 +116,11 @@
 		readl(host->ioaddr + SDHCI_CAPABILITIES),
 		readl(host->ioaddr + SDHCI_MAX_CURRENT));
 
+	if (host->flags & SDHCI_USE_ADMA)
+		printk(DRIVER_NAME ": ADMA Err: 0x%08x | ADMA Ptr: 0x%08x\n",
+		       readl(host->ioaddr + SDHCI_ADMA_ERROR),
+		       readl(host->ioaddr + SDHCI_ADMA_ADDRESS));
+
 	printk(KERN_DEBUG DRIVER_NAME ": ===========================================\n");
 }
 
@@ -120,14 +163,14 @@
 
 static void sdhci_init(struct sdhci_host *host)
 {
-	u32 intmask;
+	u32 intmask=0;
 
 	sdhci_reset(host, SDHCI_RESET_ALL);
 
 	intmask = SDHCI_INT_BUS_POWER | SDHCI_INT_DATA_END_BIT |
 		SDHCI_INT_DATA_CRC | SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_INDEX |
 		SDHCI_INT_END_BIT | SDHCI_INT_CRC | SDHCI_INT_TIMEOUT |
-		SDHCI_INT_CARD_REMOVE | SDHCI_INT_CARD_INSERT |
+		//SDHCI_INT_CARD_REMOVE | SDHCI_INT_CARD_INSERT |
 		SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL |
 		SDHCI_INT_DMA_END | SDHCI_INT_DATA_END | SDHCI_INT_RESPONSE |
 		SDHCI_INT_ADMA_ERROR;
@@ -544,7 +587,7 @@
 	 *     (1) / (2) > 2^6
 	 */
 	count = 0;
-	current_timeout = (1 << 13) * 1000 / host->timeout_clk;
+	current_timeout = (1 << 14) * 1000 / host->timeout_clk;
 	while (current_timeout < target_timeout) {
 		count++;
 		current_timeout <<= 1;
@@ -733,9 +776,31 @@
 	if (host->flags & SDHCI_REQ_USE_DMA)
 		mode |= SDHCI_TRNS_DMA;
 
+#if defined(S3C_ACMD_MODE)
+	if (data->stop)
+		mode |= SDHCI_TRNS_ACMD12;
+#endif
+
 	writew(mode, host->ioaddr + SDHCI_TRANSFER_MODE);
 }
 
+static void shdci_check_dma_overrun(struct sdhci_host *host, struct mmc_data *data)
+{
+	u32 dma_pos = readl(host->ioaddr + SDHCI_DMA_ADDRESS);
+	u32 dma_start = sg_dma_address(data->sg);
+	u32 dma_end = dma_start + data->sg->length;
+
+	/* Test whether we ended up moving more data than
+	 * was originally requested. */
+
+	if (dma_pos <= dma_end)
+		return;
+
+	printk(KERN_ERR "%s: dma overrun, dma %08x, req %08x..%08x\n",
+	       mmc_hostname(host->mmc), dma_pos,
+	       dma_start, dma_end);
+}
+
 static void sdhci_finish_data(struct sdhci_host *host)
 {
 	struct mmc_data *data;
@@ -749,6 +814,8 @@
 		if (host->flags & SDHCI_USE_ADMA)
 			sdhci_adma_table_post(host, data);
 		else {
+			shdci_check_dma_overrun(host, data);
+
 			dma_unmap_sg(mmc_dev(host->mmc), data->sg,
 				data->sg_len, (data->flags & MMC_DATA_READ) ?
 					DMA_FROM_DEVICE : DMA_TO_DEVICE);
@@ -767,6 +834,7 @@
 	else
 		data->bytes_xfered = data->blksz * data->blocks;
 
+#if !defined(S3C_ACMD_MODE)
 	if (data->stop) {
 		/*
 		 * The controller needs a reset of internal state machines
@@ -779,6 +847,7 @@
 
 		sdhci_send_command(host, data->stop);
 	} else
+#endif
 		tasklet_schedule(&host->finish_tasklet);
 }
 
@@ -888,6 +957,14 @@
 
 static void sdhci_set_clock(struct sdhci_host *host, unsigned int clock)
 {
+	if (clock == host->clock)
+		return;
+
+	host->ops->change_clock(host, clock);
+}
+
+void sdhci_change_clock(struct sdhci_host *host, unsigned int clock)
+{
 	int div;
 	u16 clk;
 	unsigned long timeout;
@@ -931,6 +1008,8 @@
 	host->clock = clock;
 }
 
+EXPORT_SYMBOL_GPL(sdhci_set_clock);
+
 static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
 {
 	u8 pwr;
@@ -984,6 +1063,137 @@
 
 /*****************************************************************************\
  *                                                                           *
+ * Tasklets                                                                  *
+ *                                                                           *
+\*****************************************************************************/
+
+static void sdhci_tasklet_card(unsigned long param)
+{
+	struct sdhci_host *host;
+	unsigned long flags;
+
+	host = (struct sdhci_host*)param;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	if (!(readl(host->ioaddr + SDHCI_PRESENT_STATE) & SDHCI_CARD_PRESENT)  || !card_detect) {
+		if (host->mrq) {
+			printk(KERN_ERR "%s: Card removed during transfer!\n",
+				mmc_hostname(host->mmc));
+			printk(KERN_ERR "%s: Resetting controller.\n",
+				mmc_hostname(host->mmc));
+
+			sdhci_reset(host, SDHCI_RESET_CMD);
+			sdhci_reset(host, SDHCI_RESET_DATA);
+
+			host->mrq->cmd->error = -ENOMEDIUM;
+			tasklet_schedule(&host->finish_tasklet);
+		}
+	}
+
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	mmc_detect_change(host->mmc, msecs_to_jiffies(200));
+}
+
+static void sdhci_tasklet_finish(unsigned long param)
+{
+	struct sdhci_host *host;
+	unsigned long flags;
+	struct mmc_request *mrq;
+
+	host = (struct sdhci_host*)param;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	del_timer(&host->timer);
+
+	mrq = host->mrq;
+
+	/*
+	 * The controller needs a reset of internal state machines
+	 * upon error conditions.
+	 */
+	
+	if(host == NULL || mrq == NULL)
+	{
+		mmiowb();
+		spin_unlock_irqrestore(&host->lock, flags);
+		return;
+	}
+		
+	if (!(host->flags & SDHCI_DEVICE_DEAD) &&
+		(mrq->cmd->error ||
+		 (mrq->data && (mrq->data->error ||
+		  (mrq->data->stop && mrq->data->stop->error))) ||
+		   (host->quirks & SDHCI_QUIRK_RESET_AFTER_REQUEST))) {
+
+		/* Some controllers need this kick or reset won't work here */
+		if (host->quirks & SDHCI_QUIRK_CLOCK_BEFORE_RESET) {
+			unsigned int clock;
+
+			/* This is to force an update */
+			clock = host->clock;
+			host->clock = 0;
+			sdhci_set_clock(host, clock);
+		}
+
+		/* Spec says we should do both at the same time, but Ricoh
+		   controllers do not like that. */
+		sdhci_reset(host, SDHCI_RESET_CMD);
+		sdhci_reset(host, SDHCI_RESET_DATA);
+	}
+
+	host->mrq = NULL;
+	host->cmd = NULL;
+	host->data = NULL;
+
+#ifndef CONFIG_LEDS_CLASS
+	sdhci_deactivate_led(host);
+#endif
+	mmiowb();
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	mmc_request_done(host->mmc, mrq);
+}
+
+static void sdhci_timeout_timer(unsigned long data)
+{
+	struct sdhci_host *host;
+	unsigned long flags;
+
+	host = (struct sdhci_host*)data;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	if (host->mrq) {
+		printk(KERN_ERR "%s: Timeout waiting for hardware "
+			"interrupt.\n", mmc_hostname(host->mmc));
+		sdhci_dumpregs(host);
+
+		if (host->data) {
+			host->data->error = -ETIMEDOUT;
+			sdhci_finish_data(host);
+		} else {
+			if (host->cmd)
+			{
+				host->cmd->error = -ETIMEDOUT;
+			}
+			else
+			{
+				host->mrq->cmd->error = -ETIMEDOUT;
+			}
+
+			tasklet_schedule(&host->finish_tasklet);
+		}
+	}
+
+	mmiowb();
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+/*****************************************************************************\
+ *                                                                           *
  * MMC callbacks                                                             *
  *                                                                           *
 \*****************************************************************************/
@@ -992,6 +1202,8 @@
 {
 	struct sdhci_host *host;
 	unsigned long flags;
+	bool b_isWlan = 0;
+	unsigned int sd_detect = 0;
 
 	host = mmc_priv(mmc);
 
@@ -1005,12 +1217,35 @@
 
 	host->mrq = mrq;
 
-	if (!(readl(host->ioaddr + SDHCI_PRESENT_STATE) & SDHCI_CARD_PRESENT)
-		|| (host->flags & SDHCI_DEVICE_DEAD)) {
+	switch (host->hwport)
+	{
+		case 0:
+			b_isWlan = 0;
+			sd_detect = readl(S3C64XX_GPNDAT);
+			sd_detect &= 0x40;
+			
+			if(!card_detect && !sd_detect)
+				card_detect = 1;
+			break;
+		case 2:
+			b_isWlan = 1;
+			card_detect = 0;
+			break;
+		default :
+			card_detect = 0;
+			b_isWlan = 0;
+			break;
+	}
+
+	if ( card_detect | b_isWlan) 
+	{
+		sdhci_send_command(host, mrq->cmd);
+	}
+	else
+	{
 		host->mrq->cmd->error = -ENOMEDIUM;
 		tasklet_schedule(&host->finish_tasklet);
-	} else
-		sdhci_send_command(host, mrq->cmd);
+	}		
 
 	mmiowb();
 	spin_unlock_irqrestore(&host->lock, flags);
@@ -1038,6 +1273,9 @@
 		sdhci_init(host);
 	}
 
+	if (host->ops->set_ios)
+		host->ops->set_ios(host, ios);
+
 	sdhci_set_clock(host, ios->clock);
 
 	if (ios->power_mode == MMC_POWER_OFF)
@@ -1052,10 +1290,16 @@
 	else
 		ctrl &= ~SDHCI_CTRL_4BITBUS;
 
+	//kevin
+	//High Speed Enable bit of SDHCI_HOST_CONTROL Register is alwaya low (normal)
+	#if 0
 	if (ios->timing == MMC_TIMING_SD_HS)
 		ctrl |= SDHCI_CTRL_HISPD;
 	else
 		ctrl &= ~SDHCI_CTRL_HISPD;
+	#else
+	ctrl &= ~SDHCI_CTRL_HISPD;
+	#endif
 
 	writeb(ctrl, host->ioaddr + SDHCI_HOST_CONTROL);
 
@@ -1127,125 +1371,7 @@
 	.enable_sdio_irq = sdhci_enable_sdio_irq,
 };
 
-/*****************************************************************************\
- *                                                                           *
- * Tasklets                                                                  *
- *                                                                           *
-\*****************************************************************************/
-
-static void sdhci_tasklet_card(unsigned long param)
-{
-	struct sdhci_host *host;
-	unsigned long flags;
-
-	host = (struct sdhci_host*)param;
-
-	spin_lock_irqsave(&host->lock, flags);
-
-	if (!(readl(host->ioaddr + SDHCI_PRESENT_STATE) & SDHCI_CARD_PRESENT)) {
-		if (host->mrq) {
-			printk(KERN_ERR "%s: Card removed during transfer!\n",
-				mmc_hostname(host->mmc));
-			printk(KERN_ERR "%s: Resetting controller.\n",
-				mmc_hostname(host->mmc));
-
-			sdhci_reset(host, SDHCI_RESET_CMD);
-			sdhci_reset(host, SDHCI_RESET_DATA);
-
-			host->mrq->cmd->error = -ENOMEDIUM;
-			tasklet_schedule(&host->finish_tasklet);
-		}
-	}
-
-	spin_unlock_irqrestore(&host->lock, flags);
-
-	mmc_detect_change(host->mmc, msecs_to_jiffies(200));
-}
-
-static void sdhci_tasklet_finish(unsigned long param)
-{
-	struct sdhci_host *host;
-	unsigned long flags;
-	struct mmc_request *mrq;
-
-	host = (struct sdhci_host*)param;
-
-	spin_lock_irqsave(&host->lock, flags);
-
-	del_timer(&host->timer);
-
-	mrq = host->mrq;
-
-	/*
-	 * The controller needs a reset of internal state machines
-	 * upon error conditions.
-	 */
-	if (!(host->flags & SDHCI_DEVICE_DEAD) &&
-		(mrq->cmd->error ||
-		 (mrq->data && (mrq->data->error ||
-		  (mrq->data->stop && mrq->data->stop->error))) ||
-		   (host->quirks & SDHCI_QUIRK_RESET_AFTER_REQUEST))) {
-
-		/* Some controllers need this kick or reset won't work here */
-		if (host->quirks & SDHCI_QUIRK_CLOCK_BEFORE_RESET) {
-			unsigned int clock;
-
-			/* This is to force an update */
-			clock = host->clock;
-			host->clock = 0;
-			sdhci_set_clock(host, clock);
-		}
-
-		/* Spec says we should do both at the same time, but Ricoh
-		   controllers do not like that. */
-		sdhci_reset(host, SDHCI_RESET_CMD);
-		sdhci_reset(host, SDHCI_RESET_DATA);
-	}
-
-	host->mrq = NULL;
-	host->cmd = NULL;
-	host->data = NULL;
-
-#ifndef SDHCI_USE_LEDS_CLASS
-	sdhci_deactivate_led(host);
-#endif
-
-	mmiowb();
-	spin_unlock_irqrestore(&host->lock, flags);
-
-	mmc_request_done(host->mmc, mrq);
-}
-
-static void sdhci_timeout_timer(unsigned long data)
-{
-	struct sdhci_host *host;
-	unsigned long flags;
-
-	host = (struct sdhci_host*)data;
-
-	spin_lock_irqsave(&host->lock, flags);
-
-	if (host->mrq) {
-		printk(KERN_ERR "%s: Timeout waiting for hardware "
-			"interrupt.\n", mmc_hostname(host->mmc));
-		sdhci_dumpregs(host);
-
-		if (host->data) {
-			host->data->error = -ETIMEDOUT;
-			sdhci_finish_data(host);
-		} else {
-			if (host->cmd)
-				host->cmd->error = -ETIMEDOUT;
-			else
-				host->mrq->cmd->error = -ETIMEDOUT;
-
-			tasklet_schedule(&host->finish_tasklet);
-		}
-	}
 
-	mmiowb();
-	spin_unlock_irqrestore(&host->lock, flags);
-}
 
 /*****************************************************************************\
  *                                                                           *
@@ -1288,17 +1414,31 @@
 	 *       controllers.
 	 */
 	if (host->cmd->flags & MMC_RSP_BUSY) {
+		u32 present;
+
 		if (host->cmd->data)
 			DBG("Cannot wait for busy signal when also "
 				"doing a data transfer");
-		else if (!(host->quirks & SDHCI_QUIRK_NO_BUSY_IRQ))
+		else if (!(host->quirks & SDHCI_QUIRK_NO_TCIRQ_ON_NOT_BUSY))
 			return;
 
-		/* The controller does not support the end-of-busy IRQ,
-		 * fall through and take the SDHCI_INT_RESPONSE */
+		/* The Samsung SDHCI does not seem to provide an INT_DATA_END
+		 * when the system goes non-busy, so check the state of the
+		 * transfer by reading SDHCI_PRESENT_STATE to see if the
+		 * controller is ready
+		 */
+
+		present = readl(host->ioaddr + SDHCI_PRESENT_STATE);
+		DBG("busy? present %08x, intstat %08x\n", present, intmask);
+
+		/* fall through and take the SDHCI_INT_RESPONSE */
 	}
 
-	if (intmask & SDHCI_INT_RESPONSE)
+	if (host->cmd->error) {
+		if(&host->finish_tasklet)
+		tasklet_schedule(&host->finish_tasklet);
+	}
+	else if (intmask & SDHCI_INT_RESPONSE)
 		sdhci_finish_command(host);
 }
 
@@ -1380,12 +1520,10 @@
 		goto out;
 	}
 
-	DBG("*** %s got interrupt: 0x%08x\n",
-		mmc_hostname(host->mmc), intmask);
-
-	if (intmask & (SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE)) {
-		writel(intmask & (SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE),
-			host->ioaddr + SDHCI_INT_STATUS);
+	if (intmask & (SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE)) 
+	{
+		mdelay(10);
+		writel(intmask & (SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE), host->ioaddr + SDHCI_INT_STATUS);
 		tasklet_schedule(&host->card_tasklet);
 	}
 
@@ -1437,12 +1575,53 @@
 	/*
 	 * We have to delay this as it calls back into the driver.
 	 */
-	if (cardint)
+	if (cardint && host->hwport == 2)
+	{
+		if(host->mmc->sdio_irq_thread)
 		mmc_signal_sdio_irq(host->mmc);
+	}
 
 	return result;
 }
 
+static irqreturn_t sdhci_irq_cd(int irq, void *dev_id)
+{
+	struct sdhci_host* host = dev_id;
+	int ext_CD_int = 0;
+	int eint_num = 0;
+	unsigned int eint0msk;
+
+	spin_lock(&host->lock);
+
+	mdelay(1);
+	eint_num = irq - IRQ_EINT(0);
+	__raw_writel((1 << eint_num), S3C64XX_EINT0PEND);
+
+	ext_CD_int = readl(S3C64XX_GPNDAT);
+	ext_CD_int &= 0x40;	/* GPN6 */
+
+	if(ext_CD_int) 
+	{
+		card_detect = 0;
+
+		eint0msk = __raw_readl(S3C64XX_EINT0MASK);
+		eint0msk |= (1 << eint_num);
+		__raw_writel(eint0msk, S3C64XX_EINT0MASK);
+	}
+	else
+	{
+		card_detect = 1;
+		g_rescan_retry = 1;
+	}
+
+	tasklet_schedule(&host->card_tasklet);	
+	mmiowb();
+
+	spin_unlock(&host->lock);
+
+	return IRQ_HANDLED;
+}
+
 /*****************************************************************************\
  *                                                                           *
  * Suspend/resume                                                            *
@@ -1453,13 +1632,44 @@
 
 int sdhci_suspend_host(struct sdhci_host *host, pm_message_t state)
 {
-	int ret;
+	int ret = 0;
 
+	if(host->mmc)
+	{
+		if(host->hwport != 2)
+		{
 	ret = mmc_suspend_host(host->mmc, state);
 	if (ret)
 		return ret;
+		}
+		else
+		{
+			if(dhdpm.suspend != NULL)
+			{
+			    dhdpm.suspend();
+			}
+			else
+			{
+			    printk("[WIFI] %s: dhdpm.suspend=NULL \n",__FUNCTION__);
+			}
+			
+			sdhci_dumpregs(host);
+			writel(0, host->ioaddr + SDHCI_INT_ENABLE);
 
+			clk_disable(host->clk_io);
+			clk_disable(host->clk_bus);	
+			
+		}
+		
+		if(host->irq)
+		{
 	free_irq(host->irq, host);
+		}
+		if(host->irq_cd)
+		{
+			free_irq(host->irq_cd, host);
+		}
+	}
 
 	return 0;
 }
@@ -1468,25 +1678,53 @@
 
 int sdhci_resume_host(struct sdhci_host *host)
 {
-	int ret;
+	int ret = 0;
 
-	if (host->flags & SDHCI_USE_DMA) {
+	if (host->mmc) 
+	{
+		if (host->flags & SDHCI_USE_DMA) 
+		{
 		if (host->ops->enable_dma)
 			host->ops->enable_dma(host);
 	}
 
-	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED,
-			  mmc_hostname(host->mmc), host);
+		set_irq_type(host->irq_cd,IRQ_TYPE_EDGE_BOTH);	
+		ret = request_irq(host->irq_cd, sdhci_irq_cd, IRQF_DISABLED, mmc_hostname(host->mmc), host);
+		ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED,mmc_hostname(host->mmc), host);
 	if (ret)
 		return ret;
 
 	sdhci_init(host);
 	mmiowb();
 
-	ret = mmc_resume_host(host->mmc);
-	if (ret)
-		return ret;
-
+		if (host->hwport !=2)
+		{
+			mmc_resume_host(host->mmc);
+		}
+		else
+		{
+			printk(KERN_INFO "%s: Enabling SDIO Interrupt \n", __FUNCTION__);
+			
+			host->ops->change_clock(host, host->clock);
+			clk_enable(host->clk_io);
+			clk_enable(host->clk_bus);
+
+			sdhci_set_ios(host->mmc, &host->mmc->ios);
+
+			writeb(0xe, host->ioaddr + SDHCI_POWER_CONTROL); 
+			
+			sdhci_enable_sdio_irq(host->mmc, 1);
+
+			if(dhdpm.resume != NULL)
+			{
+				dhdpm.resume();
+			}
+			else
+			{
+				printk("\n[Jithu] %s: dhdpm.suspend=NULL \n",__FUNCTION__);
+			}
+		}
+	} 
 	return 0;
 }
 
@@ -1612,15 +1850,21 @@
 		mmc_dev(host->mmc)->dma_mask = &host->dma_mask;
 	}
 
-	host->max_clk =
-		(caps & SDHCI_CLOCK_BASE_MASK) >> SDHCI_CLOCK_BASE_SHIFT;
+	if (host->ops->get_max_clock)
+		host->max_clk = host->ops->get_max_clock(host);
+	else {
+		host->max_clk =	(caps & SDHCI_CLOCK_BASE_MASK) >> SDHCI_CLOCK_BASE_SHIFT;
+		host->max_clk *= 1000000;
+	}
 	if (host->max_clk == 0) {
 		printk(KERN_ERR "%s: Hardware doesn't specify base clock "
 			"frequency.\n", mmc_hostname(mmc));
 		return -ENODEV;
 	}
-	host->max_clk *= 1000000;
 
+	if (host->ops->get_timeout_clock)
+		host->timeout_clk = host->ops->get_timeout_clock(host);
+	else
 	host->timeout_clk =
 		(caps & SDHCI_TIMEOUT_CLK_MASK) >> SDHCI_TIMEOUT_CLK_SHIFT;
 	if (host->timeout_clk == 0) {
@@ -1639,8 +1883,11 @@
 	mmc->f_max = host->max_clk;
 	mmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;
 
-	if (caps & SDHCI_CAN_DO_HISPD)
-		mmc->caps |= MMC_CAP_SD_HIGHSPEED;
+	if ((caps & SDHCI_CAN_DO_HISPD) ||
+		(host->quirks & SDHCI_QUIRK_FORCE_HIGHSPEED))
+	{
+		mmc->caps |= (MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED);
+	}
 
 	mmc->ocr_avail = 0;
 	if (caps & SDHCI_CAN_VDD_330)
@@ -1713,8 +1960,11 @@
 
 	setup_timer(&host->timer, sdhci_timeout_timer, (unsigned long)host);
 
-	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED,
-		mmc_hostname(mmc), host);
+	set_irq_type(host->irq_cd,IRQ_TYPE_EDGE_BOTH);	
+
+	ret = request_irq(host->irq_cd, sdhci_irq_cd, IRQF_DISABLED, mmc_hostname(mmc), host);
+	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED, mmc_hostname(mmc), host);
+ 
 	if (ret)
 		goto untasklet;
 
@@ -1752,6 +2002,7 @@
 reset:
 	sdhci_reset(host, SDHCI_RESET_ALL);
 	free_irq(host->irq, host);
+	free_irq(host->irq_cd, host);
 #endif
 untasklet:
 	tasklet_kill(&host->card_tasklet);
@@ -1792,6 +2043,7 @@
 		sdhci_reset(host, SDHCI_RESET_ALL);
 
 	free_irq(host->irq, host);
+	free_irq(host->irq_cd, host);
 
 	del_timer_sync(&host->timer);
 
@@ -1823,9 +2075,7 @@
 static int __init sdhci_drv_init(void)
 {
 	printk(KERN_INFO DRIVER_NAME
-		": Secure Digital Host Controller Interface driver\n");
-	printk(KERN_INFO DRIVER_NAME ": Copyright(c) Pierre Ossman\n");
-
+		": Samsung S3C6410 SD/MMC driver\n");
 	return 0;
 }
 
diff -Nur linux-2.6.29/drivers/mmc/host/sdhci.h linux-2.6.29-spica/drivers/mmc/host/sdhci.h
--- linux-2.6.29/drivers/mmc/host/sdhci.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/host/sdhci.h	2010-05-06 12:42:45.674299703 +0700
@@ -57,6 +57,7 @@
 #define  SDHCI_DATA_AVAILABLE	0x00000800
 #define  SDHCI_CARD_PRESENT	0x00010000
 #define  SDHCI_WRITE_PROTECT	0x00080000
+#define  SDHCI_DATA_BIT(x)	(1 << ((x) + 20))
 
 #define SDHCI_HOST_CONTROL 	0x28
 #define  SDHCI_CTRL_LED		0x01
@@ -208,10 +209,18 @@
 #define SDHCI_QUIRK_BROKEN_TIMEOUT_VAL			(1<<12)
 /* Controller has an issue with buffer bits for small transfers */
 #define SDHCI_QUIRK_BROKEN_SMALL_PIO			(1<<13)
+/* Controller supports high speed but doesn't have the caps bit set */
+#define SDHCI_QUIRK_FORCE_HIGHSPEED			(1<<14)
 /* Controller does not provide transfer-complete interrupt when not busy */
 #define SDHCI_QUIRK_NO_BUSY_IRQ				(1<<14)
-
+#define SDHCI_QUIRK_NO_TCIRQ_ON_NOT_BUSY		(1<<15)
 	int			irq;		/* Device IRQ */
+	int			irq_cd;		/* SD Card Detection IRQ */
+
+	unsigned int 		hwport;
+	struct clk		*clk_io;	/* clock for io bus */
+	struct clk		*clk_bus;
+	
 	void __iomem *		ioaddr;		/* Mapped address */
 
 	const struct sdhci_ops	*ops;		/* Low level hw interface */
@@ -263,11 +272,22 @@
 	struct timer_list	timer;		/* Timer for timeouts */
 
 	unsigned long		private[0] ____cacheline_aligned;
+#ifdef CONFIG_CPU_FREQ
+        struct notifier_block           freq_transition;
+#endif
 };
 
 
 struct sdhci_ops {
 	int		(*enable_dma)(struct sdhci_host *host);
+	unsigned int	(*get_max_clock)(struct sdhci_host *host);
+	unsigned int	(*get_timeout_clock)(struct sdhci_host *host);
+
+	void		(*change_clock)(struct sdhci_host *host,
+					unsigned int clock);
+
+	void		(*set_ios)(struct sdhci_host *host,
+				   struct mmc_ios *ios);
 };
 
 
@@ -275,6 +295,8 @@
 	size_t priv_size);
 extern void sdhci_free_host(struct sdhci_host *host);
 
+extern void sdhci_change_clock(struct sdhci_host *host, unsigned int clock);
+
 static inline void *sdhci_priv(struct sdhci_host *host)
 {
 	return (void *)host->private;
diff -Nur linux-2.6.29/drivers/mmc/host/sdhci-pci.c linux-2.6.29-spica/drivers/mmc/host/sdhci-pci.c
--- linux-2.6.29/drivers/mmc/host/sdhci-pci.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mmc/host/sdhci-pci.c	2010-05-06 12:42:45.674299703 +0700
@@ -391,6 +391,7 @@
 
 static struct sdhci_ops sdhci_pci_ops = {
 	.enable_dma	= sdhci_pci_enable_dma,
+	.change_clock   = sdhci_change_clock,
 };
 
 /*****************************************************************************\
diff -Nur linux-2.6.29/drivers/mmc/host/sdhci-s3c.c linux-2.6.29-spica/drivers/mmc/host/sdhci-s3c.c
--- linux-2.6.29/drivers/mmc/host/sdhci-s3c.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/mmc/host/sdhci-s3c.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,538 @@
+/* linux/drivers/mmc/host/sdhci-s3c.c
+ *
+ * Copyright 2008 Openmoko Inc.
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * SDHCI (HSMMC) support for Samsung SoC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <linux/mmc/host.h>
+
+#include <plat/regs-sdhci.h>
+#include <plat/sdhci.h>
+#include <mach/hardware.h>
+#include <linux/cpufreq.h>
+#include "sdhci.h"
+
+//#define SDHCI_S3C_ADMA_MODE
+
+#define MAX_BUS_CLK	(3)
+
+extern void s3c_cpufreq_hclk_change(unsigned int);
+struct sdhci_s3c {
+	struct sdhci_host	*host;
+	struct platform_device	*pdev;
+	struct resource		*ioarea;
+	struct s3c_sdhci_platdata *pdata;
+	unsigned int		cur_clk;
+
+	struct clk		*clk_io;	/* clock for io bus */
+	struct clk		*clk_bus[MAX_BUS_CLK];
+};
+
+static inline struct sdhci_s3c *to_s3c(struct sdhci_host *host)
+{
+	return sdhci_priv(host);
+}
+
+static u32 get_curclk(u32 ctrl2)
+{
+	ctrl2 &= S3C_SDHCI_CTRL2_SELBASECLK_MASK;
+	ctrl2 >>= S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;
+
+	return ctrl2;
+}
+
+static void sdhci_s3c_check_sclk(struct sdhci_host *host)
+{
+	struct sdhci_s3c *ourhost = to_s3c(host);
+	u32 tmp = readl(host->ioaddr + S3C_SDHCI_CONTROL2);
+
+	if (get_curclk(tmp) != ourhost->cur_clk) {
+		dev_dbg(&ourhost->pdev->dev, "restored ctrl2 clock setting\n");
+
+		tmp &= ~S3C_SDHCI_CTRL2_SELBASECLK_MASK;
+		tmp |= ourhost->cur_clk << S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;
+		writel(tmp, host->ioaddr + S3C_SDHCI_CONTROL2);
+	}
+}
+
+static unsigned int sdhci_s3c_get_max_clk(struct sdhci_host *host)
+{
+	struct sdhci_s3c *ourhost = to_s3c(host);
+	struct clk *busclk;
+	unsigned int rate, max;
+	int clk;
+
+	/* note, a reset will reset the clock source */
+
+	sdhci_s3c_check_sclk(host);
+
+	for (max = 0, clk = 0; clk < MAX_BUS_CLK; clk++) {
+		busclk = ourhost->clk_bus[clk];
+		if (!busclk)
+			continue;
+
+		rate = clk_get_rate(busclk);
+		if (rate > max)
+			max = rate;
+	}
+	return max;
+}
+
+static unsigned int sdhci_s3c_get_timeout_clk(struct sdhci_host *host)
+{
+	return sdhci_s3c_get_max_clk(host) / 1000000;
+}
+
+static void sdhci_s3c_set_ios(struct sdhci_host *host,
+			      struct mmc_ios *ios)
+{
+	struct sdhci_s3c *ourhost = to_s3c(host);
+	struct s3c_sdhci_platdata *pdata = ourhost->pdata;
+	int width;
+	
+	sdhci_s3c_check_sclk(host);
+
+	if (ios->power_mode != MMC_POWER_OFF) {
+		switch (ios->bus_width) {
+		case MMC_BUS_WIDTH_4:
+			width = 4;
+			break;
+		case MMC_BUS_WIDTH_1:
+			width = 1;
+			break;
+		default:
+			BUG();
+		}
+
+		if (pdata->cfg_gpio)
+			pdata->cfg_gpio(ourhost->pdev, width);
+	}
+
+	if (pdata->cfg_card)
+		pdata->cfg_card(ourhost->pdev, host->ioaddr,
+				ios, host->mmc->card);
+}
+
+static unsigned int sdhci_s3c_consider_clock(struct sdhci_s3c *ourhost,
+					     unsigned int src,
+					     unsigned int wanted)
+{
+	unsigned long rate;
+	struct clk *clksrc = ourhost->clk_bus[src];
+	int div;
+
+	if (!clksrc)
+		return UINT_MAX;
+
+	rate = clk_get_rate(clksrc);
+
+	for (div = 1; div < 256; div *= 2) {
+		if ((rate / div) <= wanted)
+			break;
+	}
+
+	dev_dbg(&ourhost->pdev->dev, "clk %d: rate %ld, want %d, got %ld\n",
+		src, rate, wanted, rate / div);
+
+	return (wanted - (rate / div));
+}
+
+static void sdhci_s3c_change_clock(struct sdhci_host *host, unsigned int clock)
+{
+	struct sdhci_s3c *ourhost = to_s3c(host);
+	unsigned int best = UINT_MAX;
+	unsigned int delta;
+	int best_src = 0;
+	int src;
+	u32 ctrl;
+
+	for (src = 0; src < MAX_BUS_CLK; src++) {
+		delta = sdhci_s3c_consider_clock(ourhost, src, clock);
+		if (delta < best) {
+			best = delta;
+			best_src = src;
+		}
+	}
+
+	/* turn clock off to card before changing clock source */
+	writew(0, host->ioaddr + SDHCI_CLOCK_CONTROL);
+
+	/* select the new clock source */
+
+	if (ourhost->cur_clk != best_src) {
+		struct clk *clk = ourhost->clk_bus[best_src];
+
+		ourhost->cur_clk = best_src;
+		host->max_clk = clk_get_rate(clk);
+		host->timeout_clk = host->max_clk / 1000000;
+
+		ctrl = readl(host->ioaddr + S3C_SDHCI_CONTROL2);
+		ctrl &= ~S3C_SDHCI_CTRL2_SELBASECLK_MASK;
+		ctrl |= best_src << S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;
+		writel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL2);
+	}
+
+	sdhci_change_clock(host, clock);
+}
+
+#ifdef CONFIG_CPU_FREQ
+
+void static sdhci_cpufreq_set_divider(struct sdhci_host *s3c_host, u16 clk)
+{
+	unsigned long timeout;
+	writew(0, s3c_host->ioaddr + SDHCI_CLOCK_CONTROL);
+	clk = clk << SDHCI_DIVIDER_SHIFT;
+	clk |= SDHCI_CLOCK_INT_EN;
+	writew(clk, s3c_host->ioaddr + SDHCI_CLOCK_CONTROL);
+
+	/* Wait max 10 ms */
+	timeout = 10;
+	while (!((clk = readw(s3c_host->ioaddr + SDHCI_CLOCK_CONTROL))
+		& SDHCI_CLOCK_INT_STABLE)) {
+		if (timeout == 0) {
+			printk(KERN_ERR "%s: Internal clock never "
+				"stabilised.\n", mmc_hostname(s3c_host->mmc));
+			return;
+		}
+		timeout--;
+		mdelay(1);
+	}
+	clk |= SDHCI_CLOCK_CARD_EN;
+	writew(clk, s3c_host->ioaddr + SDHCI_CLOCK_CONTROL);
+	return;
+}
+
+static unsigned int prev_hclk = 0;
+static unsigned int hclk_max = 0;
+static int s3c_sdhci_cpufreq_transition(struct notifier_block *nb,
+                                             unsigned long val, void *data)
+{
+	struct sdhci_host *s3c_host;
+	struct cpufreq_freqs *freqs;
+	u16 clk;
+
+	freqs = data;
+	s3c_host = container_of(nb, struct sdhci_host, freq_transition);
+
+	if(prev_hclk == freqs->new_hclk) {
+		return 0;
+	}	
+
+	clk = readw(s3c_host->ioaddr + SDHCI_CLOCK_CONTROL);
+	clk = clk >> SDHCI_DIVIDER_SHIFT;
+
+	if(val == CPUFREQ_POSTCHANGE) {
+		if(freqs->new_hclk < prev_hclk) {
+			clk = clk >> 1;
+			sdhci_cpufreq_set_divider(s3c_host, clk);
+			prev_hclk = freqs->new_hclk;
+		}
+	}
+	else if(val == CPUFREQ_PRECHANGE) {
+		if(freqs->new_hclk > prev_hclk) {
+			clk = clk << 1;
+			sdhci_cpufreq_set_divider(s3c_host, clk);
+			prev_hclk = freqs->new_hclk;
+		}
+	}
+	return 0;
+}
+
+static inline int s3c_sdhci_cpufreq_register(struct sdhci_host *s3c_host)
+{
+        s3c_host->freq_transition.notifier_call = s3c_sdhci_cpufreq_transition;
+
+        return cpufreq_register_notifier(&s3c_host->freq_transition,
+                                         CPUFREQ_TRANSITION_NOTIFIER);
+}
+
+static inline void s3c_sdhci_cpufreq_deregister(struct sdhci_host *s3c_host)
+{
+        cpufreq_unregister_notifier(&s3c_host->freq_transition,
+                                    CPUFREQ_TRANSITION_NOTIFIER);
+}
+
+#else
+static inline int s3c_sdhci_cpufreq_register(struct sdhci_host *s3c_host)
+{
+        return 0;
+}
+
+static inline void s3c_sdhci_cpufreq_deregister(struct sdhci_host *s3c_host)
+{
+}
+#endif	/* #ifdef CONFIG_CPU_FREQ */
+
+static struct sdhci_ops sdhci_s3c_ops = {
+	.get_max_clock		= sdhci_s3c_get_max_clk,
+	.get_timeout_clock	= sdhci_s3c_get_timeout_clk,
+	.change_clock		= sdhci_s3c_change_clock,
+	.set_ios		= sdhci_s3c_set_ios,
+};
+
+/*
+ * call this when you need sd stack to recognize insertion or removal of card
+ * that can't be told by SDHCI regs
+ */
+void sdhci_s3c_force_presence_change(struct platform_device *pdev)
+{
+       struct s3c_sdhci_platdata *pdata = pdev->dev.platform_data;
+
+       printk("%s : sdhci_s3c_force_presence_change called\n",__FUNCTION__);
+       mmc_detect_change(pdata->sdhci_host->mmc, msecs_to_jiffies(200));
+}
+EXPORT_SYMBOL_GPL(sdhci_s3c_force_presence_change);
+
+static int __devinit sdhci_s3c_probe(struct platform_device *pdev)
+{
+	struct s3c_sdhci_platdata *pdata = pdev->dev.platform_data;
+	struct device *dev = &pdev->dev;
+	struct sdhci_host *host;
+	struct sdhci_s3c *sc;
+	struct resource *res;
+	int ret, irq, ptr, clks;
+	int irq_cd;
+
+	if (!pdata) {
+		dev_err(dev, "no device data specified\n");
+		return -ENOENT;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	irq_cd = platform_get_irq(pdev, 1);
+
+	if (irq < 0) {
+		dev_err(dev, "no irq specified\n");
+		return irq;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "no memory specified\n");
+		return -ENOENT;
+	}
+
+	host = sdhci_alloc_host(dev, sizeof(struct sdhci_s3c));
+	if (IS_ERR(host)) {
+		dev_err(dev, "sdhci_alloc_host() failed\n");
+		return PTR_ERR(host);
+	}
+
+	pdata->sdhci_host = host;
+	
+	sc = sdhci_priv(host);
+
+	sc->host = host;
+	sc->pdev = pdev;
+	sc->pdata = pdata;
+
+	sc->clk_io = clk_get(dev, "hsmmc");
+	host->clk_io = sc->clk_io;
+	
+	if (IS_ERR(sc->clk_io)) {
+		dev_err(dev, "failed to get io clock\n");
+		ret = PTR_ERR(sc->clk_io);
+		goto err_io_clk;
+	}
+
+	/* enable the local io clock and keep it running for the moment. */
+	clk_enable(sc->clk_io);
+#ifdef CONFIG_CPU_FREQ
+	prev_hclk = clk_get_rate(sc->clk_io);
+	prev_hclk = prev_hclk / (1000*1000);
+	prev_hclk = prev_hclk * 1000;
+	hclk_max = prev_hclk;
+#endif
+
+	for (clks = 0, ptr = 0; ptr < MAX_BUS_CLK; ptr++) {
+		struct clk *clk;
+		char *name = pdata->clocks[ptr];
+
+		if (name == NULL)
+			continue;
+
+		clk = clk_get(dev, name);
+		if (IS_ERR(clk)) {
+			dev_err(dev, "failed to get clock %s\n", name);
+			continue;
+		}
+
+		clks++;
+		sc->clk_bus[ptr] = clk;
+		host->clk_bus=clk;
+		clk_enable(clk);
+
+		dev_info(dev, "clock source %d: %s (%ld Hz)\n",
+			 ptr, name, clk_get_rate(clk));
+	}
+
+	if (clks == 0) {
+		dev_err(dev, "failed to find any bus clocks\n");
+		ret = -ENOENT;
+		goto err_no_busclks;
+	}
+
+	sc->ioarea = request_mem_region(res->start, resource_size(res),
+					mmc_hostname(host->mmc));
+	if (!sc->ioarea) {
+		dev_err(dev, "failed to reserve register area\n");
+		ret = -ENXIO;
+		goto err_req_regs;
+	}
+
+	host->ioaddr = ioremap_nocache(res->start, resource_size(res));
+	if (!host->ioaddr) {
+		dev_err(dev, "failed to map registers\n");
+		ret = -ENXIO;
+		goto err_req_regs;
+	}
+
+	/* Ensure we have minimal gpio selected CMD/CLK/Detect */
+	if (pdata->cfg_gpio)
+		pdata->cfg_gpio(pdev, 1);
+
+	sdhci_s3c_check_sclk(host);
+
+	host->hw_name = "samsung-hsmmc";
+	host->ops = &sdhci_s3c_ops;
+	host->quirks = 0;
+	host->irq = irq;
+	host->irq_cd = irq_cd;
+	host->hwport = pdev->id;
+
+#ifdef SDHCI_S3C_ADMA_MODE
+	host->quirks |= SDHCI_QUIRK_NO_TCIRQ_ON_NOT_BUSY;
+
+	host->flags |= (SDHCI_USE_DMA|SDHCI_USE_ADMA);
+	host->quirks |= SDHCI_QUIRK_32BIT_ADMA_SIZE;
+
+#else
+	/* Setup quirks for the controller */
+
+	/* Currently with ADMA enabled we are getting some length
+	 * interrupts that are not being dealt with, do disable
+	 * ADMA until this is sorted out. */
+	host->quirks |= SDHCI_QUIRK_BROKEN_ADMA;
+	host->quirks |= SDHCI_QUIRK_32BIT_ADMA_SIZE;
+
+	/* It seems we do not get an DATA transfer complete on non-busy
+	 * transfers, not sure if this is a problem with this specific
+	 * SDHCI block, or a missing configuration that needs to be set. */
+	host->quirks |= SDHCI_QUIRK_NO_TCIRQ_ON_NOT_BUSY;
+
+	host->quirks |= (SDHCI_QUIRK_32BIT_DMA_ADDR |
+			 SDHCI_QUIRK_32BIT_DMA_SIZE);
+#endif
+
+	ret = sdhci_add_host(host);
+	if (ret) {
+		dev_err(dev, "sdhci_add_host() failed\n");
+		goto err_add_host;
+	}
+
+	ret = s3c_sdhci_cpufreq_register(host);
+        if (ret < 0)
+                dev_err(dev, "sdhci: failed to add cpufreq notifier\n");
+
+	return 0;
+
+ err_add_host:
+	release_resource(sc->ioarea);
+	kfree(sc->ioarea);
+
+ err_req_regs:
+	for (ptr = 0; ptr < MAX_BUS_CLK; ptr++) {
+		clk_disable(sc->clk_bus[ptr]);
+		clk_put(sc->clk_bus[ptr]);
+	}
+
+ err_no_busclks:
+	clk_disable(sc->clk_io);
+	clk_put(sc->clk_io);
+
+ err_io_clk:
+	sdhci_free_host(host);
+
+	return ret;
+}
+
+static int __devexit sdhci_s3c_remove(struct platform_device *pdev)
+{
+	struct s3c_sdhci_platdata *pdata = pdev->dev.platform_data;
+	struct sdhci_host *s3c_host = pdata->sdhci_host;
+	
+	if(s3c_host)
+		s3c_sdhci_cpufreq_deregister(s3c_host);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int sdhci_s3c_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct s3c_sdhci_platdata *pdata = pdev->dev.platform_data;
+	struct sdhci_host *s3c_host = pdata->sdhci_host;
+
+	sdhci_suspend_host(s3c_host, state);
+
+	return 0;
+}
+
+static int sdhci_s3c_resume(struct platform_device *pdev)
+{
+	struct s3c_sdhci_platdata *pdata = pdev->dev.platform_data;
+	struct sdhci_host *s3c_host = pdata->sdhci_host;
+
+	sdhci_resume_host(s3c_host);
+#ifdef CONFIG_CPU_FREQ
+	prev_hclk = hclk_max;
+#endif
+
+	return 0;
+}
+#else
+#define sdhci_s3c_suspend NULL
+#define sdhci_s3c_resume NULL
+#endif
+
+static struct platform_driver sdhci_s3c_driver = {
+	.probe		= sdhci_s3c_probe,
+	.suspend		= sdhci_s3c_suspend,
+	.resume		= sdhci_s3c_resume,
+	.remove		= __devexit_p(sdhci_s3c_remove),
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c-sdhci",
+	},
+};
+
+static int __init sdhci_s3c_init(void)
+{
+	return platform_driver_register(&sdhci_s3c_driver);
+}
+
+static void __exit sdhci_s3c_exit(void)
+{
+	platform_driver_unregister(&sdhci_s3c_driver);
+}
+
+module_init(sdhci_s3c_init);
+module_exit(sdhci_s3c_exit);
+
+MODULE_DESCRIPTION("Samsung SDHCI (HSMMC) glue");
+MODULE_AUTHOR("Ben Dooks, <ben@simtec.co.uk>");
+MODULE_LICENSE("GPLv2");
+MODULE_ALIAS("platform:s3c-sdhci");
diff -Nur linux-2.6.29/drivers/mtd/nand/Kconfig linux-2.6.29-spica/drivers/mtd/nand/Kconfig
--- linux-2.6.29/drivers/mtd/nand/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mtd/nand/Kconfig	2010-05-06 12:42:45.644210217 +0700
@@ -180,6 +180,34 @@
 	  when the is NAND chip selected or released, but will save
 	  approximately 5mA of power when there is nothing happening.
 
+config MTD_NAND_S3C
+	tristate "NAND Flash support for S3C SoC"
+	depends on ARCH_S3C64XX && MTD_NAND
+	help
+	  This enables the NAND flash controller on the S3C.
+
+	  No board specfic support is done by this driver, each board
+	  must advertise a platform_device for the driver to attach.
+
+config MTD_NAND_S3C_DEBUG
+	bool "S3C NAND driver debug"
+	depends on MTD_NAND_S3C
+	help
+	  Enable debugging of the S3C NAND driver
+
+config MTD_NAND_S3C_HWECC
+	bool "S3C NAND Hardware ECC"
+	depends on MTD_NAND_S3C
+	help
+	  Enable the use of the S3C's internal ECC generator when
+	  using NAND. Early versions of the chip have had problems with
+	  incorrect ECC generation, and if using these, the default of
+	  software ECC is preferable.
+	
+	  If you lay down a device with the hardware ECC, then you will
+	  currently not be able to switch to software, as there is no
+	  implementation for ECC method used by the S3C
+
 config MTD_NAND_DISKONCHIP
 	tristate "DiskOnChip 2000, Millennium and Millennium Plus (NAND reimplementation) (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
diff -Nur linux-2.6.29/drivers/mtd/nand/Makefile linux-2.6.29-spica/drivers/mtd/nand/Makefile
--- linux-2.6.29/drivers/mtd/nand/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mtd/nand/Makefile	2010-05-06 12:42:45.644210217 +0700
@@ -14,6 +14,7 @@
 obj-$(CONFIG_MTD_NAND_BF5XX)		+= bf5xx_nand.o
 obj-$(CONFIG_MTD_NAND_PPCHAMELEONEVB)	+= ppchameleonevb.o
 obj-$(CONFIG_MTD_NAND_S3C2410)		+= s3c2410.o
+obj-$(CONFIG_MTD_NAND_S3C)			+= s3c_nand.o
 obj-$(CONFIG_MTD_NAND_DISKONCHIP)	+= diskonchip.o
 obj-$(CONFIG_MTD_NAND_H1900)		+= h1910.o
 obj-$(CONFIG_MTD_NAND_RTC_FROM4)	+= rtc_from4.o
diff -Nur linux-2.6.29/drivers/mtd/nand/nand_base.c linux-2.6.29-spica/drivers/mtd/nand/nand_base.c
--- linux-2.6.29/drivers/mtd/nand/nand_base.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/mtd/nand/nand_base.c	2010-05-06 12:42:45.644210217 +0700
@@ -2519,6 +2519,44 @@
 	return 0;
 }
 
+static void nand_panic_wait(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	int i;
+
+	if (chip->state != FL_READY)
+		for (i = 0; i < 40; i++) {
+			if (chip->dev_ready(mtd))
+				break;
+			mdelay(10);
+		}
+	chip->state = FL_READY;
+}
+
+static int nand_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
+			    size_t *retlen, const u_char *buf)
+{
+	struct nand_chip *chip = mtd->priv;
+	int ret;
+
+	/* Do not allow reads past end of device */
+	if ((to + len) > mtd->size)
+		return -EINVAL;
+	if (!len)
+		return 0;
+
+	nand_panic_wait(mtd);
+
+	chip->ops.len = len;
+	chip->ops.datbuf = (uint8_t *)buf;
+	chip->ops.oobbuf = NULL;
+
+	ret = nand_do_write_ops(mtd, to, &chip->ops);
+
+	*retlen = chip->ops.retlen;
+	return ret;
+}
+
 
 /**
  * nand_scan_tail - [NAND Interface] Scan for the NAND device
@@ -2701,6 +2739,7 @@
 	mtd->write = nand_write;
 	mtd->read_oob = nand_read_oob;
 	mtd->write_oob = nand_write_oob;
+	mtd->panic_write = nand_panic_write;
 	mtd->sync = nand_sync;
 	mtd->lock = NULL;
 	mtd->unlock = NULL;
diff -Nur linux-2.6.29/drivers/mtd/nand/s3c_nand.c linux-2.6.29-spica/drivers/mtd/nand/s3c_nand.c
--- linux-2.6.29/drivers/mtd/nand/s3c_nand.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/mtd/nand/s3c_nand.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,999 @@
+/* linux/drivers/mtd/nand/s3c_nand.c
+ *
+ * Copyright (c) 2007 Samsung Electronics
+ *
+ * Samsung S3C NAND driver
+ *
+ * $Id: s3c_nand.c,v 1.3 2008/11/19 10:07:24 jsgood Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Based on nand driver from Ben Dooks <ben@simtec.co.uk>
+ * modified by scsuh. based on au1550nd.c
+ *
+ * Many functions for hardware ecc are implemented by jsgood.
+ */
+
+/* Simple H/W Table for Implementation of S3C nand driver
+ * by scsuh
+ * ------------------------------------------------------------------
+ * |    En/Dis CE           |  required  |                          |
+ * |    En/Dis ALE          |      X     | * nand controller does   |
+ * |    En/Dis CLE          |      X     | * nand controller does   |
+ * |    Wait/Ready          |  required  |                          |
+ * |    Write Command       |  required  |                          |
+ * |    Write Address       |  required  |                          |
+ * |    Write Data          |  required  |                          |
+ * |    Read Data           |  required  |                          |
+ * |    WP on/off           |  required  | * board specific         |
+ * |    AP Specific Init    |  required  |                          |
+ * ------------------------------------------------------------------
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/jiffies.h>
+#include <linux/sched.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+#include <plat/regs-nand.h>
+#include <plat/nand.h>
+
+enum s3c_cpu_type {
+	TYPE_S3C2450,	/* including s3c2416 */
+	TYPE_S3C6400,
+	TYPE_S3C6410,	/* including s3c6430/31 */
+};
+
+struct s3c_nand_info {
+	/* mtd info */
+	struct nand_hw_control		controller;
+	struct s3c_nand_mtd_info	*mtds;
+	struct s3c2410_platform_nand	*platform;
+
+	/* device info */
+	struct device			*device;
+	struct resource			*area;
+	struct clk			*clk;
+	void __iomem			*regs;
+	void __iomem			*sel_reg;
+	int				sel_bit;
+	int				mtd_count;
+	unsigned long			save_sel;
+	unsigned long			clk_rate;
+
+	enum s3c_cpu_type		cpu_type;
+};
+static struct s3c_nand_info s3c_nand;
+
+static struct mtd_info *s3c_mtd = NULL;
+
+/* Nand flash definition values by jsgood */
+#define S3C_NAND_TYPE_UNKNOWN	0x0
+#define S3C_NAND_TYPE_SLC	0x1
+#define S3C_NAND_TYPE_MLC	0x2
+
+/*
+ * Cached progamming disabled for now, Not sure if its worth the
+ * trouble. The speed gain is not very impressive. (2.3->2.6Mib/s)
+ *
+ * if want to use cached program, define next
+ * by jsgood (modified to keep prevent rule)
+ */
+#undef	CONFIG_MTD_NAND_S3C_CACHEDPROG
+
+/* Nand flash global values by jsgood */
+int cur_ecc_mode = 0;
+int nand_type = S3C_NAND_TYPE_UNKNOWN;
+
+#if defined(CONFIG_MTD_NAND_S3C_HWECC)
+/* Nand flash oob definition for SLC 512b page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_16 = {
+	.eccbytes = 4,
+	.eccpos = {1, 2, 3, 4},
+	.oobfree = {
+		{.offset = 6,
+		 .length = 10}}
+};
+
+/* Nand flash oob definition for SLC 2k page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_64 = {
+	.eccbytes = 16,
+	.eccpos = {40, 41, 42, 43, 44, 45, 46, 47,
+		   48, 49, 50, 51, 52, 53, 54, 55},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 38}}
+};
+
+/* Nand flash oob definition for MLC 2k page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_mlc_64 = {
+	.eccbytes = 32,
+	.eccpos = {
+		   32, 33, 34, 35, 36, 37, 38, 39,
+		   40, 41, 42, 43, 44, 45, 46, 47,
+ 		   48, 49, 50, 51, 52, 53, 54, 55,
+   		   56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 28}}
+};
+#endif
+
+#if defined(CONFIG_MTD_NAND_S3C_DEBUG)
+/*
+ * Function to print out oob buffer for debugging
+ * Written by jsgood
+ */
+void print_oob(const char *header, struct mtd_info *mtd)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+
+	printk("%s:\t", header);
+
+	for(i = 0; i < 64; i++)
+		printk("%02x ", chip->oob_poi[i]);
+
+	printk("\n");
+}
+EXPORT_SYMBOL(print_oob);
+#endif
+
+
+/*
+ * Hardware specific access to control-lines function
+ * Written by jsgood
+ */
+static void s3c_nand_hwcontrol(struct mtd_info *mtd, int dat, unsigned int ctrl)
+{
+	unsigned int cur;
+	void __iomem *regs = s3c_nand.regs;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if (ctrl & NAND_NCE) {
+			if (dat != NAND_CMD_NONE) {
+				cur = readl(regs + S3C_NFCONT);
+				cur &= ~S3C_NFCONT_nFCE0;
+				writel(cur, regs + S3C_NFCONT);
+			}
+		} else {
+			cur = readl(regs + S3C_NFCONT);
+			cur |= S3C_NFCONT_nFCE0;
+			writel(cur, regs + S3C_NFCONT);
+		}
+	}
+
+	if (dat != NAND_CMD_NONE) {
+		if (ctrl & NAND_CLE)
+			writeb(dat, regs + S3C_NFCMMD);
+		else if (ctrl & NAND_ALE)
+			writeb(dat, regs + S3C_NFADDR);
+	}
+}
+
+/*
+ * Function for checking device ready pin
+ * Written by jsgood
+ */
+static int s3c_nand_device_ready(struct mtd_info *mtd)
+{
+	void __iomem *regs = s3c_nand.regs;
+/* it's to check the RnB nand signal bit and return to device ready condition in nand_base.c */
+	return ((readl(regs + S3C_NFSTAT) & S3C_NFSTAT_BUSY));
+}
+
+/*
+ * We don't use a bad block table
+ */
+static int s3c_nand_scan_bbt(struct mtd_info *mtdinfo)
+{
+	return 0;
+}
+
+#if defined(CONFIG_MTD_NAND_S3C_HWECC)
+#if 0
+/*
+ * S3C Nand flash chip enable function
+ * Written by jsgood
+ */
+static void s3c_nand_ce_on(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	chip->cmd_ctrl(mtd, 0x0, NAND_NCE | NAND_CTRL_CHANGE);
+	nand_wait_ready(mtd);
+}
+
+/*
+ * S3C Nand flash chip disable function
+ * Written by jsgood
+ */
+static void s3c_nand_ce_off(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_CTRL_CHANGE);
+	nand_wait_ready(mtd);
+}
+#endif
+
+/*
+ * Function for checking ECCEncDone in NFSTAT
+ * Written by jsgood
+ */
+static void s3c_nand_wait_enc(void)
+{
+        void __iomem *regs = s3c_nand.regs;
+        unsigned long timeo = jiffies;
+ 
+        timeo += 16;    /* when Hz=200,  jiffies interval 1/200=5mS, waiting for 80mS  80/5 = 16 */
+ 
+        /* Apply this short delay always to ensure that we do wait tWB in
+         * any case on any machine. */
+
+        while (time_before(jiffies, timeo)) {
+		if (readl(regs + S3C_NFSTAT) & S3C_NFSTAT_ECCENCDONE)
+				break;
+		cond_resched();
+	}
+}
+
+/*
+ * Function for checking ECCDecDone in NFSTAT
+ * Written by jsgood
+ */
+static void s3c_nand_wait_dec(void)
+{
+	void __iomem *regs = s3c_nand.regs;
+        unsigned long timeo = jiffies;
+ 
+        timeo += 16;    /* when Hz=200,  jiffies interval  1/200=5mS, waiting for 80mS  80/5 = 16 */
+ 
+        /* Apply this short delay always to ensure that we do wait tWB in
+         * any case on any machine. */
+
+        while (time_before(jiffies, timeo)) {
+		if (readl(regs + S3C_NFSTAT) & S3C_NFSTAT_ECCDECDONE)
+			break;
+		cond_resched();
+	}
+}
+
+/*
+ * Function for checking ECC Busy
+ * Written by jsgood
+ */
+static void s3c_nand_wait_ecc_busy(void)
+{
+	void __iomem *regs = s3c_nand.regs;
+        unsigned long timeo = jiffies;
+ 
+        timeo += 16;    /* when Hz=200,  jiffies interval  1/200=5mS, waiting for 80mS  80/5 = 16 */
+ 
+        /* Apply this short delay always to ensure that we do wait tWB in
+         * any case on any machine. */
+
+        while (time_before(jiffies, timeo)) {
+		if (!(readl(regs + S3C_NFMECCERR0) & S3C_NFECCERR0_ECCBUSY))
+			break;
+		cond_resched();
+	}
+}
+
+/*
+ * This function is called before encoding ecc codes to ready ecc engine.
+ * Written by jsgood
+ */
+static void s3c_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	u_long nfcont;
+	u_long nfconf;
+	void __iomem *regs = s3c_nand.regs;
+
+	cur_ecc_mode = mode;
+
+	nfconf = readl(regs + S3C_NFCONF);
+
+	if (s3c_nand.cpu_type == TYPE_S3C6400) {
+		if (nand_type == S3C_NAND_TYPE_SLC)
+			nfconf &= ~S3C_NFCONF_ECC_MLC;	/* SLC */
+		else
+			nfconf |= S3C_NFCONF_ECC_MLC;	/* MLC */
+	} else {
+		nfconf &= ~(0x3 << 23);
+
+		if (nand_type == S3C_NAND_TYPE_SLC)
+			nfconf |= S3C_NFCONF_ECC_1BIT;
+		else
+			nfconf |= S3C_NFCONF_ECC_4BIT;
+	}
+
+	writel(nfconf, regs + S3C_NFCONF);
+
+	/* Init main ECC & unlock */
+	nfcont = readl(regs + S3C_NFCONT);
+	nfcont |= S3C_NFCONT_INITMECC;
+	nfcont &= ~S3C_NFCONT_MECCLOCK;
+
+	if (nand_type == S3C_NAND_TYPE_MLC) {
+		if (mode == NAND_ECC_WRITE)
+			nfcont |= S3C_NFCONT_ECC_ENC;
+		else if (mode == NAND_ECC_READ)
+			nfcont &= ~S3C_NFCONT_ECC_ENC;
+	}
+
+	writel(nfcont, regs + S3C_NFCONT);
+}
+
+/*
+ * This function is called immediately after encoding ecc codes.
+ * This function returns encoded ecc codes.
+ * Written by jsgood
+ */
+static int s3c_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	u_long nfcont, nfmecc0, nfmecc1;
+	void __iomem *regs = s3c_nand.regs;
+
+	/* Lock */
+	nfcont = readl(regs + S3C_NFCONT);
+	nfcont |= S3C_NFCONT_MECCLOCK;
+	writel(nfcont, regs + S3C_NFCONT);
+
+	if (nand_type == S3C_NAND_TYPE_SLC) {
+		nfmecc0 = readl(regs + S3C_NFMECC0);
+
+		ecc_code[0] = nfmecc0 & 0xff;
+		ecc_code[1] = (nfmecc0 >> 8) & 0xff;
+		ecc_code[2] = (nfmecc0 >> 16) & 0xff;
+		ecc_code[3] = (nfmecc0 >> 24) & 0xff;
+	} else {
+		if (cur_ecc_mode == NAND_ECC_READ)
+			s3c_nand_wait_dec();
+		else {
+			s3c_nand_wait_enc();
+			
+			nfmecc0 = readl(regs + S3C_NFMECC0);
+			nfmecc1 = readl(regs + S3C_NFMECC1);
+
+			ecc_code[0] = nfmecc0 & 0xff;
+			ecc_code[1] = (nfmecc0 >> 8) & 0xff;
+			ecc_code[2] = (nfmecc0 >> 16) & 0xff;
+			ecc_code[3] = (nfmecc0 >> 24) & 0xff;			
+			ecc_code[4] = nfmecc1 & 0xff;
+			ecc_code[5] = (nfmecc1 >> 8) & 0xff;
+			ecc_code[6] = (nfmecc1 >> 16) & 0xff;
+			ecc_code[7] = (nfmecc1 >> 24) & 0xff;
+		}
+	}
+	
+	return 0;
+}
+
+/*
+ * This function determines whether read data is good or not.
+ * If SLC, must write ecc codes to controller before reading status bit.
+ * If MLC, status bit is already set, so only reading is needed.
+ * If status bit is good, return 0.
+ * If correctable errors occured, do that.
+ * If uncorrectable errors occured, return -1.
+ * Written by jsgood
+ */
+static int s3c_nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
+{
+	int ret = -1;
+	u_long nfestat0, nfestat1, nfmeccdata0, nfmeccdata1, nfmlcbitpt;
+	u_char err_type;
+	void __iomem *regs = s3c_nand.regs;
+
+	if (!dat) {
+		printk("No page data\n");
+		return ret;
+	}
+
+	if (nand_type == S3C_NAND_TYPE_SLC) {
+		/* SLC: Write ECC data to compare */
+		nfmeccdata0 = (read_ecc[1] << 16) | read_ecc[0];
+		nfmeccdata1 = (read_ecc[3] << 16) | read_ecc[2];
+		writel(nfmeccdata0, regs + S3C_NFMECCDATA0);
+		writel(nfmeccdata1, regs + S3C_NFMECCDATA1);
+
+		/* Read ECC status */
+		nfestat0 = readl(regs + S3C_NFMECCERR0);
+		err_type = nfestat0 & 0x3;
+
+		switch (err_type) {
+		case 0: /* No error */
+			ret = 0;
+			break;
+
+		case 1: /* 1 bit error (Correctable)
+			   (nfestat0 >> 7) & 0x7ff	:error byte number
+			   (nfestat0 >> 4) & 0x7	:error bit number */
+			printk("s3c-nand: 1 bit error detected at byte %ld, correcting from "
+					"0x%02x ", (nfestat0 >> 7) & 0x7ff, dat[(nfestat0 >> 7) & 0x7ff]);
+			dat[(nfestat0 >> 7) & 0x7ff] ^= (1 << ((nfestat0 >> 4) & 0x7));
+			printk("to 0x%02x...OK\n", dat[(nfestat0 >> 7) & 0x7ff]);
+			ret = 1;
+			break;
+
+		case 2: /* Multiple error */
+		case 3: /* ECC area error */
+			printk("s3c-nand: ECC uncorrectable error detected\n");
+			ret = -1;
+			break;
+		}
+	} else {
+		/* MLC: */
+		s3c_nand_wait_ecc_busy();
+		
+		nfestat0 = readl(regs + S3C_NFMECCERR0);
+		nfestat1 = readl(regs + S3C_NFMECCERR1);
+		nfmlcbitpt = readl(regs + S3C_NFMLCBITPT);
+
+		err_type = (nfestat0 >> 26) & 0x7;
+
+		/* No error, If free page (all 0xff) */
+		if ((nfestat0 >> 29) & 0x1) {
+			err_type = 0;
+		} else {
+			/* No error, If all 0xff from 17th byte in oob (in case of JFFS2 format) */
+			if (dat) {
+				if (dat[17] == 0xff && dat[26] == 0xff && dat[35] == 0xff && dat[44] == 0xff && dat[54] == 0xff)
+					err_type = 0;
+			}
+		}
+
+		switch (err_type) {
+		case 5: /* Uncorrectable */
+			printk("s3c-nand: ECC uncorrectable error detected\n");
+			ret = -1;
+			break;
+
+		case 4: /* 4 bit error (Correctable) */
+			dat[(nfestat1 >> 16) & 0x3ff] ^= ((nfmlcbitpt >> 24) & 0xff);
+
+		case 3: /* 3 bit error (Correctable) */
+			dat[nfestat1 & 0x3ff] ^= ((nfmlcbitpt >> 16) & 0xff);
+
+		case 2: /* 2 bit error (Correctable) */
+			dat[(nfestat0 >> 16) & 0x3ff] ^= ((nfmlcbitpt >> 8) & 0xff);
+
+		case 1: /* 1 bit error (Correctable) */
+			printk("s3c-nand: %d bit(s) error detected, corrected successfully\n", err_type);
+			dat[nfestat0 & 0x3ff] ^= (nfmlcbitpt & 0xff);
+			ret = err_type;
+			break;
+
+		case 0: /* No error */
+			ret = 0;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+#if 0
+static int s3c_nand_write_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+			      int page)
+{
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	int status = 0;
+	int eccbytes = chip->ecc.bytes;
+	int secc_start = mtd->oobsize - eccbytes;
+	int i;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+	chip->write_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, 0, &ecc_calc[chip->ecc.total]);
+
+	for (i = 0; i < eccbytes; i++)
+		chip->oob_poi[secc_start + i] = ecc_calc[chip->ecc.total + i];
+
+	chip->write_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+	/* Send command to program the OOB data */
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = chip->waitfunc(mtd, chip);
+
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+static int s3c_nand_read_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+			     int page, int sndcmd)
+{
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	int eccbytes = chip->ecc.bytes;
+	int secc_start = mtd->oobsize - eccbytes;
+	
+	if (sndcmd) {
+		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+		sndcmd = 0;
+	}
+
+	chip->ecc.hwctl(mtd, NAND_ECC_READ);
+	chip->read_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, 0, &ecc_calc[chip->ecc.total]);
+	chip->read_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+	/* jffs2 special case */
+	if (!(chip->oob_poi[2] == 0x85 && chip->oob_poi[3] == 0x19))
+		chip->ecc.correct(mtd, chip->oob_poi, chip->oob_poi + secc_start, 0);
+	
+	return sndcmd;
+}
+
+static void s3c_nand_write_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int secc_start = mtd->oobsize - eccbytes;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	const uint8_t *p = buf;
+	
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+
+	/* main area */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+	}
+
+	for (i = 0; i < chip->ecc.total; i++)
+		chip->oob_poi[eccpos[i]] = ecc_calc[i];
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+	chip->write_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, p, &ecc_calc[chip->ecc.total]);
+
+	for (i = 0; i < eccbytes; i++)
+		chip->oob_poi[secc_start + i] = ecc_calc[chip->ecc.total + i];
+
+	chip->write_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+}
+
+static int s3c_nand_read_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf)
+{
+	int i, stat, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int secc_start = mtd->oobsize - eccbytes;
+	int col = 0;
+	uint8_t *p = buf;	
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+
+	col = mtd->writesize;
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_READ);
+	chip->read_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, p, &ecc_calc[chip->ecc.total]);
+	chip->read_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+	/* jffs2 special case */
+	if (!(chip->oob_poi[2] == 0x85 && chip->oob_poi[3] == 0x19))
+		chip->ecc.correct(mtd, chip->oob_poi, chip->oob_poi + secc_start, 0);
+
+	col = 0;
+
+	/* main area */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+
+		stat = chip->ecc.correct(mtd, p, chip->oob_poi + mecc_pos[0] + ((chip->ecc.steps - eccsteps) * eccbytes), 0);
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+
+		col = eccsize * (chip->ecc.steps + 1 - eccsteps);
+	}
+	
+	return 0;
+}
+#endif
+
+/* 
+ * Hardware specific page read function for MLC.
+ * Written by jsgood
+ */
+static int s3c_nand_read_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf)
+{
+	int i, stat, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int col = 0;
+	uint8_t *p = buf;	
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+
+	/* Step1: read whole oob */
+	col = mtd->writesize;
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	col = 0;
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->write_buf(mtd, chip->oob_poi + mecc_pos[0] + ((chip->ecc.steps - eccsteps) * eccbytes), eccbytes);
+		chip->ecc.calculate(mtd, 0, 0);
+		stat = chip->ecc.correct(mtd, p, 0, 0);
+
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+
+		col = eccsize * (chip->ecc.steps + 1 - eccsteps);
+	}
+
+	return 0;
+}
+
+/* 
+ * Hardware specific page write function for MLC.
+ * Written by jsgood
+ */
+static void s3c_nand_write_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	const uint8_t *p = buf;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+
+	/* Step1: write main data and encode mecc */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+	}
+
+	/* Step2: save encoded mecc */
+	for (i = 0; i < chip->ecc.total; i++)
+		chip->oob_poi[mecc_pos[i]] = ecc_calc[i];
+
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+}
+#endif
+
+/* s3c_nand_probe
+ *
+ * called by device layer when it finds a device matching
+ * one our driver can handled. This code checks to see if
+ * it can allocate all necessary resources then calls the
+ * nand layer to look for devices
+ */
+static int s3c_nand_probe(struct platform_device *pdev, enum s3c_cpu_type cpu_type)
+{	
+	struct s3c_nand_mtd_info *plat_info = pdev->dev.platform_data;
+	struct mtd_partition *partition_info = (struct mtd_partition *)plat_info->partition;
+	struct nand_chip *nand;
+	struct resource *res;
+	int err = 0;
+	int ret = 0;
+	int i, j, size;
+
+#if defined(CONFIG_MTD_NAND_S3C_HWECC)
+	struct nand_flash_dev *type = NULL;
+	u_char tmp;
+#endif
+
+	/* get the clock source and enable it */
+
+	s3c_nand.clk = clk_get(&pdev->dev, "nand");
+	if (IS_ERR(s3c_nand.clk)) {
+		dev_err(&pdev->dev, "failed to get clock");
+		err = -ENOENT;
+		goto exit_error;
+	}
+
+	clk_enable(s3c_nand.clk);
+
+	/* allocate and map the resource */
+
+	/* currently we assume we have the one resource */
+	res  = pdev->resource;
+	size = res->end - res->start + 1;
+
+	s3c_nand.area = request_mem_region(res->start, size, pdev->name);
+
+	if (s3c_nand.area == NULL) {
+		dev_err(&pdev->dev, "cannot reserve register region\n");
+		err = -ENOENT;
+		goto exit_error;
+	}
+
+	s3c_nand.cpu_type   = cpu_type;
+	s3c_nand.device     = &pdev->dev;
+	s3c_nand.regs       = ioremap(res->start, size);
+
+	if (s3c_nand.regs == NULL) {
+		dev_err(&pdev->dev, "cannot reserve register region\n");
+		err = -EIO;
+		goto exit_error;
+	}
+
+	/* allocate memory for MTD device structure and private data */
+	s3c_mtd = kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);
+
+	if (!s3c_mtd) {
+		printk("Unable to allocate NAND MTD dev structure.\n");
+		return -ENOMEM;
+	}
+
+	/* Get pointer to private data */
+	nand = (struct nand_chip *) (&s3c_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) s3c_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) nand, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	s3c_mtd->priv = nand;
+
+	for (i = 0; i < plat_info->chip_nr; i++) {
+		nand->IO_ADDR_R		= (char *)(s3c_nand.regs + S3C_NFDATA);
+		nand->IO_ADDR_W		= (char *)(s3c_nand.regs + S3C_NFDATA);
+		nand->cmd_ctrl		= s3c_nand_hwcontrol;
+		nand->dev_ready		= s3c_nand_device_ready;		
+		nand->scan_bbt		= s3c_nand_scan_bbt;
+		nand->options		= 0;
+
+#if defined(CONFIG_MTD_NAND_S3C_CACHEDPROG)
+		nand->options		|= NAND_CACHEPRG;
+#endif
+
+#if defined(CONFIG_MTD_NAND_S3C_HWECC)
+		nand->ecc.mode		= NAND_ECC_HW;
+		nand->ecc.hwctl		= s3c_nand_enable_hwecc;
+		nand->ecc.calculate	= s3c_nand_calculate_ecc;
+		nand->ecc.correct	= s3c_nand_correct_data;
+		
+		s3c_nand_hwcontrol(0, NAND_CMD_READID, NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+		s3c_nand_hwcontrol(0, 0x00, NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE);
+		s3c_nand_hwcontrol(0, 0x00, NAND_NCE | NAND_ALE);
+		s3c_nand_hwcontrol(0, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
+		s3c_nand_device_ready(0);
+
+		tmp = readb(nand->IO_ADDR_R); /* Maf. ID */
+		tmp = readb(nand->IO_ADDR_R); /* Device ID */
+
+		for (j = 0; nand_flash_ids[j].name != NULL; j++) {
+			if (tmp == nand_flash_ids[j].id) {
+				type = &nand_flash_ids[j];
+				break;
+			}
+		}
+
+		if (!type) {
+			printk("Unknown NAND Device.\n");
+			goto exit_error;
+		}
+		
+		nand->cellinfo = readb(nand->IO_ADDR_R);	/* the 3rd byte */
+		tmp = readb(nand->IO_ADDR_R);			/* the 4th byte */
+
+		if (!type->pagesize) {
+			if (((nand->cellinfo >> 2) & 0x3) == 0) {
+				nand_type = S3C_NAND_TYPE_SLC;				
+				nand->ecc.size = 512;
+				nand->ecc.bytes	= 4;
+
+				if ((1024 << (tmp & 0x3)) > 512) {
+#if 0 //choi
+					nand->ecc.read_page = s3c_nand_read_page_1bit;
+					nand->ecc.write_page = s3c_nand_write_page_1bit;
+					nand->ecc.read_oob = s3c_nand_read_oob_1bit;
+					nand->ecc.write_oob = s3c_nand_write_oob_1bit;
+					nand->ecc.layout = &s3c_nand_oob_64;
+#endif
+					nand->ecc.size = 2048;
+					nand->ecc.bytes = 4;
+					nand->ecc.layout = &s3c_nand_oob_64;
+				} else {
+				  //choi
+					nand->ecc.size = 512;
+					nand->ecc.bytes = 3;
+					nand->ecc.layout = &s3c_nand_oob_16;
+				}
+			} else {
+				nand_type = S3C_NAND_TYPE_MLC;
+				nand->options |= NAND_NO_SUBPAGE_WRITE;	/* NOP = 1 if MLC */
+#if 1 //choi
+				nand->ecc.read_page = s3c_nand_read_page_4bit;
+				nand->ecc.write_page = s3c_nand_write_page_4bit;
+#endif
+//				nand->ecc.read_page = s3c_nand_read_page;
+//				nand->ecc.write_page = s3c_nand_write_page;
+				nand->ecc.size = 512;
+				nand->ecc.bytes = 8;	/* really 7 bytes */
+				nand->ecc.layout = &s3c_nand_oob_mlc_64;
+			}
+		} else {
+			nand_type = S3C_NAND_TYPE_SLC;
+			nand->ecc.size = 512;
+			nand->cellinfo = 0;
+			nand->ecc.bytes = 4;
+			nand->ecc.layout = &s3c_nand_oob_16;
+		}
+
+		printk("S3C NAND Driver is using hardware ECC.\n");
+#else
+		nand->ecc.mode = NAND_ECC_SOFT;
+		printk("S3C NAND Driver is using software ECC.\n");
+#endif
+		if (nand_scan(s3c_mtd, 1)) {
+			ret = -ENXIO;
+			goto exit_error;
+		}
+
+		/* Register the partitions */
+		add_mtd_partitions(s3c_mtd, partition_info, plat_info->mtd_part_nr);
+	}
+
+	pr_debug("initialized ok\n");
+	return 0;
+
+exit_error:
+	kfree(s3c_mtd);
+
+	return ret;
+}
+
+static int s3c2450_nand_probe(struct platform_device *dev)
+{
+	return s3c_nand_probe(dev, TYPE_S3C2450);
+}
+
+static int s3c6400_nand_probe(struct platform_device *dev)
+{
+	return s3c_nand_probe(dev, TYPE_S3C6400);
+}
+
+static int s3c6410_nand_probe(struct platform_device *dev)
+{
+	return s3c_nand_probe(dev, TYPE_S3C6410);
+}
+
+/* PM Support */
+#if defined(CONFIG_PM)
+#include <plat/pm.h>
+
+static struct sleep_save nand_save[17]; 
+
+static int s3c_nand_suspend(struct platform_device *dev, pm_message_t pm)
+{
+	int i;
+
+	void __iomem *regs = s3c_nand.regs;
+
+	for(i = 0; i < 17; i++)
+	{
+		nand_save[i].reg = regs + S3C2410_NFREG(i*4);
+	}
+
+	s3c6410_pm_do_save(nand_save, ARRAY_SIZE(nand_save));
+
+	return 0;
+}
+
+static int s3c_nand_resume(struct platform_device *dev)
+{
+	s3c6410_pm_do_restore(nand_save, ARRAY_SIZE(nand_save));
+	
+	return 0;
+}
+
+#else
+#define s3c_nand_suspend NULL
+#define s3c_nand_resume NULL
+#endif
+
+/* device management functions */
+static int s3c_nand_remove(struct platform_device *dev)
+{
+	platform_set_drvdata(dev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver s3c2450_nand_driver = {
+	.probe		= s3c2450_nand_probe,
+	.remove		= s3c_nand_remove,
+	.suspend	= s3c_nand_suspend,
+	.resume		= s3c_nand_resume,
+	.driver		= {
+		.name	= "s3c2450-nand",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static struct platform_driver s3c6400_nand_driver = {
+	.probe		= s3c6400_nand_probe,
+	.remove		= s3c_nand_remove,
+	.suspend	= s3c_nand_suspend,
+	.resume		= s3c_nand_resume,
+	.driver		= {
+		.name	= "s3c6400-nand",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static struct platform_driver s3c6410_nand_driver = {
+	.probe		= s3c6410_nand_probe,
+	.remove		= s3c_nand_remove,
+	.suspend	= s3c_nand_suspend,
+	.resume		= s3c_nand_resume,
+	.driver		= {
+		.name	= "s3c6410-nand",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init s3c_nand_init(void)
+{
+	printk("S3C NAND Driver, (c) 2008 Samsung Electronics\n");
+
+	platform_driver_register(&s3c2450_nand_driver);
+	platform_driver_register(&s3c6400_nand_driver);
+	return platform_driver_register(&s3c6410_nand_driver);
+}
+
+static void __exit s3c_nand_exit(void)
+{
+	platform_driver_unregister(&s3c2450_nand_driver);
+	platform_driver_unregister(&s3c6400_nand_driver);
+	platform_driver_unregister(&s3c6410_nand_driver);
+}
+
+module_init(s3c_nand_init);
+module_exit(s3c_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jinsung Yang <jsgood.yang@samsung.com>");
+MODULE_DESCRIPTION("S3C MTD NAND driver");
+
diff -Nur linux-2.6.29/drivers/net/Kconfig linux-2.6.29-spica/drivers/net/Kconfig
--- linux-2.6.29/drivers/net/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/net/Kconfig	2010-05-06 12:42:45.644210217 +0700
@@ -967,7 +967,7 @@
 	tristate "SMSC LAN911[5678] support"
 	select CRC32
 	select MII
-	depends on ARM || SUPERH
+	depends on ARM || ARCH_PXA || SUPERH
 	help
 	  This is a driver for SMSC's LAN911x series of Ethernet chipsets
 	  including the new LAN9115, LAN9116, LAN9117, and LAN9118.
@@ -2979,6 +2979,23 @@
 	  and session setup). One such daemon is OpenL2TP
 	  (http://openl2tp.sourceforge.net/).
 
+config PPPOLAC
+	tristate "PPP on L2TP Access Concentrator"
+	depends on PPP && INET
+	help
+	  L2TP (RFC 2661) is a tunneling protocol widely used in virtual private
+	  networks. This driver handles L2TP data packets between a UDP socket
+	  and a PPP channel, but only permits one session per socket. Thus it is
+	  fairly simple and suited for clients.
+
+config PPPOPNS
+	tristate "PPP on PPTP Network Server"
+	depends on PPP && INET
+	help
+	  PPTP (RFC 2637) is a tunneling protocol widely used in virtual private
+	  networks. This driver handles PPTP data packets between a RAW socket
+	  and a PPP channel. It is fairly simple and easy to use.
+
 config SLIP
 	tristate "SLIP (serial line) support"
 	---help---
diff -Nur linux-2.6.29/drivers/net/Makefile linux-2.6.29-spica/drivers/net/Makefile
--- linux-2.6.29/drivers/net/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/net/Makefile	2010-03-30 11:00:56.000000000 +0700
@@ -143,6 +143,8 @@
 obj-$(CONFIG_PPP_MPPE) += ppp_mppe.o
 obj-$(CONFIG_PPPOE) += pppox.o pppoe.o
 obj-$(CONFIG_PPPOL2TP) += pppox.o pppol2tp.o
+obj-$(CONFIG_PPPOLAC) += pppox.o pppolac.o
+obj-$(CONFIG_PPPOPNS) += pppox.o pppopns.o
 
 obj-$(CONFIG_SLIP) += slip.o
 obj-$(CONFIG_SLHC) += slhc.o
diff -Nur linux-2.6.29/drivers/net/pppolac.c linux-2.6.29-spica/drivers/net/pppolac.c
--- linux-2.6.29/drivers/net/pppolac.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/net/pppolac.c	2010-03-30 11:00:51.000000000 +0700
@@ -0,0 +1,366 @@
+/* drivers/net/pppolac.c
+ *
+ * Driver for PPP on L2TP Access Concentrator / PPPoLAC Socket (RFC 2661)
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Author: Chia-chi Yeh <chiachi@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/* This driver handles L2TP data packets between a UDP socket and a PPP channel.
+ * To keep things simple, only one session per socket is permitted. Packets are
+ * sent via the socket, so it must keep connected to the same address. One must
+ * not set sequencing in ICCN but let LNS controll it. Currently this driver
+ * only works on IPv4 due to the lack of UDP encapsulation support in IPv6. */
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/udp.h>
+#include <linux/ppp_defs.h>
+#include <linux/if_ppp.h>
+#include <linux/if_pppox.h>
+#include <linux/ppp_channel.h>
+#include <net/tcp_states.h>
+
+#define L2TP_CONTROL_BIT	0x80
+#define L2TP_LENGTH_BIT		0x40
+#define L2TP_SEQUENCE_BIT	0x08
+#define L2TP_OFFSET_BIT		0x02
+#define L2TP_VERSION		0x02
+#define L2TP_VERSION_MASK	0x0F
+
+#define PPP_ADDR	0xFF
+#define PPP_CTRL	0x03
+
+union unaligned {
+	__u32 u32;
+} __attribute__((packed));
+
+static inline union unaligned *unaligned(void *ptr)
+{
+	return (union unaligned *)ptr;
+}
+
+static int pppolac_recv(struct sock *sk_udp, struct sk_buff *skb)
+{
+	struct sock *sk;
+	struct pppolac_opt *opt;
+	__u8 bits;
+	__u8 *ptr;
+
+	/* Drop the packet if it is too short. */
+	if (skb->len < sizeof(struct udphdr) + 6)
+		goto drop;
+
+	/* Put it back if it is a control packet. */
+	if (skb->data[sizeof(struct udphdr)] & L2TP_CONTROL_BIT)
+		return 1;
+
+	/* Now the packet is ours. Skip UDP header. */
+	skb_pull(skb, sizeof(struct udphdr));
+
+	/* Check the version. */
+	if ((skb->data[1] & L2TP_VERSION_MASK) != L2TP_VERSION)
+		goto drop;
+	bits = skb->data[0];
+	ptr = &skb->data[2];
+
+	/* Check the length if it is present. */
+	if (bits & L2TP_LENGTH_BIT) {
+		if ((ptr[0] << 8 | ptr[1]) != skb->len)
+			goto drop;
+		ptr += 2;
+	}
+
+	/* Skip all fields including optional ones. */
+	if (!skb_pull(skb, 6 + (bits & L2TP_SEQUENCE_BIT ? 4 : 0) +
+			(bits & L2TP_LENGTH_BIT ? 2 : 0) +
+			(bits & L2TP_OFFSET_BIT ? 2 : 0)))
+		goto drop;
+
+	/* Skip the offset padding if it is present. */
+	if (bits & L2TP_OFFSET_BIT &&
+			!skb_pull(skb, skb->data[-2] << 8 | skb->data[-1]))
+		goto drop;
+
+	/* Now ptr is pointing to the tunnel and skb is pointing to the payload.
+	 * We have to lock sk_udp to prevent sk from being closed. */
+	lock_sock(sk_udp);
+	sk = sk_udp->sk_user_data;
+	if (!sk) {
+		release_sock(sk_udp);
+		goto drop;
+	}
+	sock_hold(sk);
+	release_sock(sk_udp);
+	opt = &pppox_sk(sk)->proto.lac;
+
+	/* Check the tunnel and the session. */
+	if (unaligned(ptr)->u32 != opt->local) {
+		sock_put(sk);
+		goto drop;
+	}
+
+	/* Check the sequence if it is present. According to RFC 2661 page 10
+	 * and 43, the only thing to do is updating opt->sequencing. */
+	opt->sequencing = bits & L2TP_SEQUENCE_BIT;
+
+	/* Skip PPP address and control if they are present. */
+	if (skb->len >= 2 && skb->data[0] == PPP_ADDR &&
+			skb->data[1] == PPP_CTRL)
+		skb_pull(skb, 2);
+
+	/* Fix PPP protocol if it is compressed. */
+	if (skb->len >= 1 && skb->data[0] & 1)
+		skb_push(skb, 1)[0] = 0;
+
+	/* Finally, deliver the packet to PPP channel. We have to lock sk to
+	 * prevent another thread from calling pppox_unbind_sock(). */
+	skb_orphan(skb);
+	lock_sock(sk);
+	ppp_input(&pppox_sk(sk)->chan, skb);
+	release_sock(sk);
+	sock_put(sk);
+	return 0;
+
+drop:
+	kfree_skb(skb);
+	return 0;
+}
+
+static int pppolac_xmit(struct ppp_channel *chan, struct sk_buff *skb)
+{
+	struct sock *sk_udp = (struct sock *)chan->private;
+	struct pppolac_opt *opt = &pppox_sk(sk_udp->sk_user_data)->proto.lac;
+	struct msghdr msg = {.msg_flags = MSG_NOSIGNAL | MSG_DONTWAIT};
+	struct kvec iov;
+
+	/* Install PPP address and control. */
+	skb_push(skb, 2);
+	skb->data[0] = PPP_ADDR;
+	skb->data[1] = PPP_CTRL;
+
+	/* Install L2TP header. */
+	if (opt->sequencing) {
+		skb_push(skb, 10);
+		skb->data[0] = L2TP_SEQUENCE_BIT;
+		skb->data[6] = opt->sequence >> 8;
+		skb->data[7] = opt->sequence;
+		skb->data[8] = 0;
+		skb->data[9] = 0;
+		opt->sequence++;
+	} else {
+		skb_push(skb, 6);
+		skb->data[0] = 0;
+	}
+	skb->data[1] = L2TP_VERSION;
+	unaligned(&skb->data[2])->u32 = opt->remote;
+
+	/* Now send the packet via UDP socket. */
+	iov.iov_base = skb->data;
+	iov.iov_len = skb->len;
+	kernel_sendmsg(sk_udp->sk_socket, &msg, &iov, 1, skb->len);
+	kfree_skb(skb);
+	return 1;
+}
+
+/******************************************************************************/
+
+static struct ppp_channel_ops pppolac_channel_ops = {
+	.start_xmit = pppolac_xmit,
+};
+
+static int pppolac_connect(struct socket *sock, struct sockaddr *useraddr,
+	int addrlen, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct pppox_sock *po = pppox_sk(sk);
+	struct sockaddr_pppolac *addr = (struct sockaddr_pppolac *)useraddr;
+	struct socket *sock_udp = NULL;
+	struct sock *sk_udp;
+	int error;
+
+	if (addrlen != sizeof(struct sockaddr_pppolac) ||
+			!addr->local.tunnel || !addr->local.session ||
+			!addr->remote.tunnel || !addr->remote.session) {
+		return -EINVAL;
+	}
+
+	lock_sock(sk);
+	error = -EALREADY;
+	if (sk->sk_state != PPPOX_NONE)
+		goto out;
+
+	sock_udp = sockfd_lookup(addr->udp_socket, &error);
+	if (!sock_udp)
+		goto out;
+	sk_udp = sock_udp->sk;
+	lock_sock(sk_udp);
+
+	/* Remove this check when IPv6 supports UDP encapsulation. */
+	error = -EAFNOSUPPORT;
+	if (sk_udp->sk_family != AF_INET)
+		goto out;
+	error = -EPROTONOSUPPORT;
+	if (sk_udp->sk_protocol != IPPROTO_UDP)
+		goto out;
+	error = -EDESTADDRREQ;
+	if (sk_udp->sk_state != TCP_ESTABLISHED)
+		goto out;
+	error = -EBUSY;
+	if (udp_sk(sk_udp)->encap_type || sk_udp->sk_user_data)
+		goto out;
+	if (!sk_udp->sk_bound_dev_if) {
+		struct dst_entry *dst = sk_dst_get(sk_udp);
+		error = -ENODEV;
+		if (!dst)
+			goto out;
+		sk_udp->sk_bound_dev_if = dst->dev->ifindex;
+		dst_release(dst);
+	}
+
+	po->chan.hdrlen = 12;
+	po->chan.private = sk_udp;
+	po->chan.ops = &pppolac_channel_ops;
+	po->chan.mtu = PPP_MTU - 80;
+	po->proto.lac.local = unaligned(&addr->local)->u32;
+	po->proto.lac.remote = unaligned(&addr->remote)->u32;
+
+	error = ppp_register_channel(&po->chan);
+	if (error)
+		goto out;
+
+	sk->sk_state = PPPOX_CONNECTED;
+	udp_sk(sk_udp)->encap_type = UDP_ENCAP_L2TPINUDP;
+	udp_sk(sk_udp)->encap_rcv = pppolac_recv;
+	sk_udp->sk_user_data = sk;
+
+out:
+	if (sock_udp) {
+		release_sock(sk_udp);
+		if (error)
+			sockfd_put(sock_udp);
+	}
+	release_sock(sk);
+	return error;
+}
+
+static int pppolac_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	if (!sk)
+		return 0;
+
+	lock_sock(sk);
+	if (sock_flag(sk, SOCK_DEAD)) {
+		release_sock(sk);
+		return -EBADF;
+	}
+
+	if (sk->sk_state != PPPOX_NONE) {
+		struct sock *sk_udp = (struct sock *)pppox_sk(sk)->chan.private;
+		pppox_unbind_sock(sk);
+
+		lock_sock(sk_udp);
+		sk_udp->sk_user_data = NULL;
+		udp_sk(sk_udp)->encap_type = 0;
+		udp_sk(sk_udp)->encap_rcv = NULL;
+		release_sock(sk_udp);
+		sockfd_put(sk_udp->sk_socket);
+	}
+
+	sock_orphan(sk);
+	sock->sk = NULL;
+	release_sock(sk);
+	sock_put(sk);
+	return 0;
+}
+
+/******************************************************************************/
+
+static struct proto pppolac_proto = {
+	.name = "PPPOLAC",
+	.owner = THIS_MODULE,
+	.obj_size = sizeof(struct pppox_sock),
+};
+
+static struct proto_ops pppolac_proto_ops = {
+	.family = PF_PPPOX,
+	.owner = THIS_MODULE,
+	.release = pppolac_release,
+	.bind = sock_no_bind,
+	.connect = pppolac_connect,
+	.socketpair = sock_no_socketpair,
+	.accept = sock_no_accept,
+	.getname = sock_no_getname,
+	.poll = sock_no_poll,
+	.ioctl = pppox_ioctl,
+	.listen = sock_no_listen,
+	.shutdown = sock_no_shutdown,
+	.setsockopt = sock_no_setsockopt,
+	.getsockopt = sock_no_getsockopt,
+	.sendmsg = sock_no_sendmsg,
+	.recvmsg = sock_no_recvmsg,
+	.mmap = sock_no_mmap,
+};
+
+static int pppolac_create(struct net *net, struct socket *sock)
+{
+	struct sock *sk;
+
+	sk = sk_alloc(net, PF_PPPOX, GFP_KERNEL, &pppolac_proto);
+	if (!sk)
+		return -ENOMEM;
+
+	sock_init_data(sock, sk);
+	sock->state = SS_UNCONNECTED;
+	sock->ops = &pppolac_proto_ops;
+	sk->sk_protocol = PX_PROTO_OLAC;
+	sk->sk_state = PPPOX_NONE;
+	return 0;
+}
+
+/******************************************************************************/
+
+static struct pppox_proto pppolac_pppox_proto = {
+	.create = pppolac_create,
+	.owner = THIS_MODULE,
+};
+
+static int __init pppolac_init(void)
+{
+	int error;
+
+	error = proto_register(&pppolac_proto, 0);
+	if (error)
+		return error;
+
+	error = register_pppox_proto(PX_PROTO_OLAC, &pppolac_pppox_proto);
+	if (error)
+		proto_unregister(&pppolac_proto);
+	return error;
+}
+
+static void __exit pppolac_exit(void)
+{
+	unregister_pppox_proto(PX_PROTO_OLAC);
+	proto_unregister(&pppolac_proto);
+}
+
+module_init(pppolac_init);
+module_exit(pppolac_exit);
+
+MODULE_DESCRIPTION("PPP on L2TP Access Concentrator (PPPoLAC)");
+MODULE_AUTHOR("Chia-chi Yeh <chiachi@android.com>");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/net/pppopns.c linux-2.6.29-spica/drivers/net/pppopns.c
--- linux-2.6.29/drivers/net/pppopns.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/net/pppopns.c	2010-03-30 11:00:56.000000000 +0700
@@ -0,0 +1,334 @@
+/* drivers/net/pppopns.c
+ *
+ * Driver for PPP on PPTP Network Server / PPPoPNS Socket (RFC 2637)
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Author: Chia-chi Yeh <chiachi@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/* This driver handles PPTP data packets between a RAW socket and a PPP channel.
+ * The socket is created in the kernel space and connected to the same address
+ * of the control socket. To keep things simple, packets are always sent with
+ * sequence but without acknowledgement. This driver should work on both IPv4
+ * and IPv6. */
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/ppp_defs.h>
+#include <linux/if.h>
+#include <linux/if_ppp.h>
+#include <linux/if_pppox.h>
+#include <linux/ppp_channel.h>
+
+#define GRE_HEADER_SIZE		8
+
+#define PPTP_GRE_BITS		htons(0x2001)
+#define PPTP_GRE_BITS_MASK	htons(0xEF7F)
+#define PPTP_GRE_SEQ_BIT	htons(0x1000)
+#define PPTP_GRE_ACK_BIT	htons(0x0080)
+#define PPTP_GRE_TYPE		htons(0x880B)
+
+#define PPP_ADDR	0xFF
+#define PPP_CTRL	0x03
+
+struct header {
+	__u16	bits;
+	__u16	type;
+	__u16	length;
+	__u16	call;
+	__u32	sequence;
+} __attribute__((packed));
+
+static void pppopns_recv(struct sock *sk_raw, int length)
+{
+	struct sock *sk;
+	struct pppopns_opt *opt;
+	struct sk_buff *skb;
+	struct header *hdr;
+
+	/* Lock sk_raw to prevent sk from being closed. */
+	lock_sock(sk_raw);
+	sk = (struct sock *)sk_raw->sk_user_data;
+	if (!sk) {
+		release_sock(sk_raw);
+		return;
+	}
+	sock_hold(sk);
+	release_sock(sk_raw);
+	opt = &pppox_sk(sk)->proto.pns;
+
+	/* Process packets from the receive queue. */
+	while ((skb = skb_dequeue(&sk_raw->sk_receive_queue))) {
+		skb_pull(skb, skb_transport_header(skb) - skb->data);
+
+		/* Drop the packet if it is too short. */
+		if (skb->len < GRE_HEADER_SIZE)
+			goto drop;
+
+		/* Check the header. */
+		hdr = (struct header *)skb->data;
+		if (hdr->type != PPTP_GRE_TYPE || hdr->call != opt->local ||
+			(hdr->bits & PPTP_GRE_BITS_MASK) != PPTP_GRE_BITS)
+			goto drop;
+
+		/* Skip all fields including optional ones. */
+		if (!skb_pull(skb, GRE_HEADER_SIZE +
+				(hdr->bits & PPTP_GRE_SEQ_BIT ? 4 : 0) +
+				(hdr->bits & PPTP_GRE_ACK_BIT ? 4 : 0)))
+			goto drop;
+
+		/* Check the length. */
+		if (skb->len != ntohs(hdr->length))
+			goto drop;
+
+		/* Skip PPP address and control if they are present. */
+		if (skb->len >= 2 && skb->data[0] == PPP_ADDR &&
+				skb->data[1] == PPP_CTRL)
+			skb_pull(skb, 2);
+
+		/* Fix PPP protocol if it is compressed. */
+		if (skb->len >= 1 && skb->data[0] & 1)
+			skb_push(skb, 1)[0] = 0;
+
+		/* Deliver the packet to PPP channel. We have to lock sk to
+		 * prevent another thread from calling pppox_unbind_sock(). */
+		skb_orphan(skb);
+		lock_sock(sk);
+		ppp_input(&pppox_sk(sk)->chan, skb);
+		release_sock(sk);
+		continue;
+drop:
+		kfree_skb(skb);
+	}
+	sock_put(sk);
+}
+
+static int pppopns_xmit(struct ppp_channel *chan, struct sk_buff *skb)
+{
+	struct sock *sk_raw = (struct sock *)chan->private;
+	struct pppopns_opt *opt = &pppox_sk(sk_raw->sk_user_data)->proto.pns;
+	struct msghdr msg = {.msg_flags = MSG_NOSIGNAL | MSG_DONTWAIT};
+	struct kvec iov;
+	struct header *hdr;
+	__u16 length;
+
+	/* Install PPP address and control. */
+	skb_push(skb, 2);
+	skb->data[0] = PPP_ADDR;
+	skb->data[1] = PPP_CTRL;
+	length = skb->len;
+
+	/* Install PPTP GRE header. */
+	hdr = (struct header *)skb_push(skb, 12);
+	hdr->bits = PPTP_GRE_BITS | PPTP_GRE_SEQ_BIT;
+	hdr->type = PPTP_GRE_TYPE;
+	hdr->length = htons(length);
+	hdr->call = opt->remote;
+	hdr->sequence = htonl(opt->sequence);
+	opt->sequence++;
+
+	/* Now send the packet via RAW socket. */
+	iov.iov_base = skb->data;
+	iov.iov_len = skb->len;
+	kernel_sendmsg(sk_raw->sk_socket, &msg, &iov, 1, skb->len);
+	kfree_skb(skb);
+	return 1;
+}
+
+/******************************************************************************/
+
+static struct ppp_channel_ops pppopns_channel_ops = {
+	.start_xmit = pppopns_xmit,
+};
+
+static int pppopns_connect(struct socket *sock, struct sockaddr *useraddr,
+	int addrlen, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct pppox_sock *po = pppox_sk(sk);
+	struct sockaddr_pppopns *addr = (struct sockaddr_pppopns *)useraddr;
+	struct sockaddr_storage ss;
+	struct socket *sock_tcp = NULL;
+	struct socket *sock_raw = NULL;
+	struct sock *sk_tcp;
+	struct sock *sk_raw;
+	int error;
+
+	if (addrlen != sizeof(struct sockaddr_pppopns))
+		return -EINVAL;
+
+	lock_sock(sk);
+	error = -EALREADY;
+	if (sk->sk_state != PPPOX_NONE)
+		goto out;
+
+	sock_tcp = sockfd_lookup(addr->tcp_socket, &error);
+	if (!sock_tcp)
+		goto out;
+	sk_tcp = sock_tcp->sk;
+	error = -EPROTONOSUPPORT;
+	if (sk_tcp->sk_protocol != IPPROTO_TCP)
+		goto out;
+	addrlen = sizeof(struct sockaddr_storage);
+	error = kernel_getpeername(sock_tcp, (struct sockaddr *)&ss, &addrlen);
+	if (error)
+		goto out;
+	if (!sk_tcp->sk_bound_dev_if) {
+		struct dst_entry *dst = sk_dst_get(sk_tcp);
+		error = -ENODEV;
+		if (!dst)
+			goto out;
+		sk_tcp->sk_bound_dev_if = dst->dev->ifindex;
+		dst_release(dst);
+	}
+
+	error = sock_create(ss.ss_family, SOCK_RAW, IPPROTO_GRE, &sock_raw);
+	if (error)
+		goto out;
+	sk_raw = sock_raw->sk;
+	sk_raw->sk_bound_dev_if = sk_tcp->sk_bound_dev_if;
+	error = kernel_connect(sock_raw, (struct sockaddr *)&ss, addrlen, 0);
+	if (error)
+		goto out;
+
+	po->chan.hdrlen = 14;
+	po->chan.private = sk_raw;
+	po->chan.ops = &pppopns_channel_ops;
+	po->chan.mtu = PPP_MTU - 80;
+	po->proto.pns.local = addr->local;
+	po->proto.pns.remote = addr->remote;
+
+	error = ppp_register_channel(&po->chan);
+	if (error)
+		goto out;
+
+	sk->sk_state = PPPOX_CONNECTED;
+	sk_raw->sk_user_data = sk;
+	sk_raw->sk_data_ready = pppopns_recv;
+
+out:
+	if (sock_tcp)
+		sockfd_put(sock_tcp);
+	if (error && sock_raw)
+		sock_release(sock_raw);
+	release_sock(sk);
+	return error;
+}
+
+static int pppopns_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	if (!sk)
+		return 0;
+
+	lock_sock(sk);
+	if (sock_flag(sk, SOCK_DEAD)) {
+		release_sock(sk);
+		return -EBADF;
+	}
+
+	if (sk->sk_state != PPPOX_NONE) {
+		struct sock *sk_raw = (struct sock *)pppox_sk(sk)->chan.private;
+		pppox_unbind_sock(sk);
+		lock_sock(sk_raw);
+		sk_raw->sk_user_data = NULL;
+		release_sock(sk_raw);
+		sock_release(sk_raw->sk_socket);
+	}
+
+	sock_orphan(sk);
+	sock->sk = NULL;
+	release_sock(sk);
+	sock_put(sk);
+	return 0;
+}
+
+/******************************************************************************/
+
+static struct proto pppopns_proto = {
+	.name = "PPPOPNS",
+	.owner = THIS_MODULE,
+	.obj_size = sizeof(struct pppox_sock),
+};
+
+static struct proto_ops pppopns_proto_ops = {
+	.family = PF_PPPOX,
+	.owner = THIS_MODULE,
+	.release = pppopns_release,
+	.bind = sock_no_bind,
+	.connect = pppopns_connect,
+	.socketpair = sock_no_socketpair,
+	.accept = sock_no_accept,
+	.getname = sock_no_getname,
+	.poll = sock_no_poll,
+	.ioctl = pppox_ioctl,
+	.listen = sock_no_listen,
+	.shutdown = sock_no_shutdown,
+	.setsockopt = sock_no_setsockopt,
+	.getsockopt = sock_no_getsockopt,
+	.sendmsg = sock_no_sendmsg,
+	.recvmsg = sock_no_recvmsg,
+	.mmap = sock_no_mmap,
+};
+
+static int pppopns_create(struct net *net, struct socket *sock)
+{
+	struct sock *sk;
+
+	sk = sk_alloc(net, PF_PPPOX, GFP_KERNEL, &pppopns_proto);
+	if (!sk)
+		return -ENOMEM;
+
+	sock_init_data(sock, sk);
+	sock->state = SS_UNCONNECTED;
+	sock->ops = &pppopns_proto_ops;
+	sk->sk_protocol = PX_PROTO_OPNS;
+	sk->sk_state = PPPOX_NONE;
+	return 0;
+}
+
+/******************************************************************************/
+
+static struct pppox_proto pppopns_pppox_proto = {
+	.create = pppopns_create,
+	.owner = THIS_MODULE,
+};
+
+static int __init pppopns_init(void)
+{
+	int error;
+
+	error = proto_register(&pppopns_proto, 0);
+	if (error)
+		return error;
+
+	error = register_pppox_proto(PX_PROTO_OPNS, &pppopns_pppox_proto);
+	if (error)
+		proto_unregister(&pppopns_proto);
+	return error;
+}
+
+static void __exit pppopns_exit(void)
+{
+	unregister_pppox_proto(PX_PROTO_OPNS);
+	proto_unregister(&pppopns_proto);
+}
+
+module_init(pppopns_init);
+module_exit(pppopns_exit);
+
+MODULE_DESCRIPTION("PPP on PPTP Network Server (PPPoPNS)");
+MODULE_AUTHOR("Chia-chi Yeh <chiachi@android.com>");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/net/smc911x.c linux-2.6.29-spica/drivers/net/smc911x.c
--- linux-2.6.29/drivers/net/smc911x.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/net/smc911x.c	2010-05-06 12:42:45.644210217 +0700
@@ -1904,6 +1904,17 @@
 
 	spin_lock_init(&lp->lock);
 
+#if defined(CONFIG_MACH_SMDK6410)||defined(CONFIG_MACH_SMDK2450)||defined(CONFIG_MACH_SMDKC100)
+	dev->dev_addr[0] = 0x00;
+	dev->dev_addr[1] = 0x09;
+	dev->dev_addr[2] = 0xc0;
+	dev->dev_addr[3] = 0xff;
+	dev->dev_addr[4] = 0xec;
+	dev->dev_addr[5] = 0x48;
+
+	SMC_SET_MAC_ADDR(lp, dev->dev_addr);
+#endif
+	
 	/* Get the MAC address */
 	SMC_GET_MAC_ADDR(lp, dev->dev_addr);
 
@@ -2048,6 +2059,7 @@
  */
 static int __devinit smc911x_drv_probe(struct platform_device *pdev)
 {
+	struct smc911x_platdata *pd = pdev->dev.platform_data;
 	struct net_device *ndev;
 	struct resource *res;
 	struct smc911x_local *lp;
diff -Nur linux-2.6.29/drivers/net/smc911x.h linux-2.6.29-spica/drivers/net/smc911x.h
--- linux-2.6.29/drivers/net/smc911x.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/net/smc911x.h	2010-05-06 12:42:45.644210217 +0700
@@ -38,7 +38,8 @@
   #define SMC_USE_16BIT		0
   #define SMC_USE_32BIT		1
   #define SMC_IRQ_SENSE		IRQF_TRIGGER_FALLING
-#elif defined(CONFIG_SH_MAGIC_PANEL_R2)
+#elif defined(CONFIG_SH_MAGIC_PANEL_R2)||defined(CONFIG_MACH_SMDK6410)||defined(CONFIG_MACH_SMDK2450)||defined(CONFIG_MACH_SMDKC100)
+  #undef  SMC_USE_DMA		
   #define SMC_USE_16BIT		0
   #define SMC_USE_32BIT		1
   #define SMC_IRQ_SENSE		IRQF_TRIGGER_LOW
diff -Nur linux-2.6.29/drivers/power/fuel_gauge.c linux-2.6.29-spica/drivers/power/fuel_gauge.c
--- linux-2.6.29/drivers/power/fuel_gauge.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/power/fuel_gauge.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,234 @@
+/* Slave address */
+#define MAX17040_SLAVE_ADDR	0x6D
+
+/* Register address */
+#define VCELL0_REG			0x02
+#define VCELL1_REG			0x03
+#define SOC0_REG			0x04
+#define SOC1_REG			0x05
+#define MODE0_REG			0x06
+#define MODE1_REG			0x07
+#define RCOMP0_REG			0x0C
+#define RCOMP1_REG			0x0D
+#define CMD0_REG			0xFE
+#define CMD1_REG			0xFF
+
+/* Definitions */
+#define VCELL_ARR_SIZE			6
+
+static struct i2c_driver fg_i2c_driver;
+static struct i2c_client *fg_i2c_client = NULL;
+
+static unsigned short fg_normal_i2c[] = { I2C_CLIENT_END };
+static unsigned short fg_ignore[] = { I2C_CLIENT_END };
+static unsigned short fg_probe[] = { 0, (MAX17040_SLAVE_ADDR >> 1),
+	I2C_CLIENT_END };
+
+static struct i2c_client_address_data fg_addr_data = {
+	.normal_i2c	= fg_normal_i2c,
+	.ignore		= fg_ignore,
+	.probe		= fg_probe,
+};
+
+static int is_reset_soc = 0;
+
+static int fg_i2c_read(struct i2c_client *client, u8 reg, u8 *data)
+{
+	int ret;
+	u8 buf[1];
+	struct i2c_msg msg[2];
+
+	buf[0] = reg; 
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret != 2) 
+		return -EIO;
+
+	*data = buf[0];
+	
+	return 0;
+}
+
+static int fg_i2c_write(struct i2c_client *client, u8 reg, u8 *data)
+{
+	int ret;
+	u8 buf[3];
+	struct i2c_msg msg[1];
+
+	buf[0] = reg;
+	buf[1] = *data;
+	buf[2] = *(data + 1);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 3;
+	msg[0].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msg, 1);
+	if (ret != 1) 
+		return -EIO;
+
+	return 0;
+}
+
+static unsigned int fg_get_vcell_data(void)
+{
+	struct i2c_client *client = fg_i2c_client;
+	u8 data[2];
+	u32 vcell = 0;
+
+	if (fg_i2c_read(client, VCELL0_REG, &data[0]) < 0) {
+		pr_err("%s: Failed to read VCELL0\n", __func__);
+		return -1;
+	}
+	if (fg_i2c_read(client, VCELL1_REG, &data[1]) < 0) {
+		pr_err("%s: Failed to read VCELL1\n", __func__);
+		return -1;
+	}
+	vcell = ((((data[0] << 4) & 0xFF0) | ((data[1] >> 4) & 0xF)) * 125)/100;
+	pr_debug("%s: VCELL=%d\n", __func__, vcell);
+	return vcell;
+}
+
+unsigned int fg_read_vcell(void)
+{
+	u32 vcell_arr[VCELL_ARR_SIZE];
+	u32 vcell_max = 0;
+	u32 vcell_min = 0;
+	u32 vcell_total = 0;
+	int i;
+
+	for (i = 0; i < VCELL_ARR_SIZE; i++) {
+		vcell_arr[i] = fg_get_vcell_data();
+		pr_debug("%s: vcell_arr = %d\n", __func__, vcell_arr[i]);
+		if (i != 0) {
+			if (vcell_arr[i] > vcell_max) 
+				vcell_max = vcell_arr[i];
+			else if (vcell_arr[i] < vcell_min)
+				vcell_min = vcell_arr[i];
+		} else {
+			vcell_max = vcell_arr[0];
+			vcell_min = vcell_arr[0];
+		}
+		vcell_total += vcell_arr[i];
+	}
+
+	pr_debug("%s: vcell_max = %d, vcell_min = %d\n",
+			__func__, vcell_max, vcell_min);
+	return (vcell_total - vcell_max - vcell_min) / (VCELL_ARR_SIZE - 2);
+}
+
+unsigned int fg_read_soc(void)
+{
+	struct i2c_client *client = fg_i2c_client;
+	u8 data[2];
+
+	if (fg_i2c_read(client, SOC0_REG, &data[0]) < 0) {
+		pr_err("%s: Failed to read SOC0\n", __func__);
+		return -1;
+	}
+	if (fg_i2c_read(client, SOC1_REG, &data[1]) < 0) {
+		pr_err("%s: Failed to read SOC1\n", __func__);
+		return -1;
+	}
+	pr_debug("%s: SOC [0]=%d [1]=%d\n", __func__, data[0], data[1]);
+
+	if (is_reset_soc) {
+		pr_info("%s: Reseting SOC\n", __func__);
+		return -1;
+	} else {
+#ifndef SOC_LB_FOR_POWER_OFF
+		return data[0];
+#else /* SOC_LB_FOR_POWER_OFF */
+		if (data[0])
+			return data[0];
+		else {
+			if (data[1] > SOC_LB_FOR_POWER_OFF)
+				return 1;
+			else
+				return 0;
+		}
+#endif /* SOC_LB_FOR_POWER_OFF */
+	}
+}
+
+unsigned int fg_reset_soc(void)
+{
+	struct i2c_client *client = fg_i2c_client;
+	u8 rst_cmd[2];
+	s32 ret = 0;
+
+	is_reset_soc = 1;
+	/* Quick-start */
+	rst_cmd[0] = 0x40;
+	rst_cmd[1] = 0x00;
+
+	ret = fg_i2c_write(client, MODE0_REG, rst_cmd);
+	if (ret)
+		pr_err("%s: failed reset SOC(%d)\n", __func__, ret);
+
+	msleep(500);
+	is_reset_soc = 0;
+	return ret;
+}
+
+static int fg_attach(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct i2c_client *c;
+	int ret;
+
+	pr_info("%s\n", __func__);
+
+	c = kmalloc(sizeof(*c), GFP_KERNEL);
+	if (!c)
+		return -ENOMEM;
+
+	memset(c, 0, sizeof(struct i2c_client));
+
+	strncpy(c->name, fg_i2c_driver.driver.name, I2C_NAME_SIZE);
+	c->addr = addr;
+	c->adapter = adap;
+	c->driver = &fg_i2c_driver;
+
+	if ((ret = i2c_attach_client(c)))
+		goto error;
+
+	fg_i2c_client = c;
+
+error:
+	return ret;
+}
+
+static int fg_attach_adapter(struct i2c_adapter *adap)
+{
+	pr_info("%s\n", __func__);
+	return i2c_probe(adap, &fg_addr_data, fg_attach);
+}
+
+static int fg_detach_client(struct i2c_client *client)
+{
+	pr_info("%s\n", __func__);
+	i2c_detach_client(client);
+	return 0;
+}
+
+static struct i2c_driver fg_i2c_driver = {
+	.driver = {
+		.name = "Fuel Gauge I2C",
+		.owner = THIS_MODULE,
+	},
+	.id 		= 0,
+	.attach_adapter	= fg_attach_adapter,
+	.detach_client	= fg_detach_client,
+	.command	= NULL,
+};
diff -Nur linux-2.6.29/drivers/power/Kconfig linux-2.6.29-spica/drivers/power/Kconfig
--- linux-2.6.29/drivers/power/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/power/Kconfig	2010-05-06 12:42:45.644210217 +0700
@@ -22,6 +22,12 @@
 	  one or two external power supplies (AC/USB) connected to main and
 	  backup batteries, and optional builtin charger.
 
+config BATTERY_S3C6410
+	tristate "Battery driver (S3C6410)"
+	depends on ARCH_S3C64XX 
+	help
+	  Say Y to enable support for batteries with s3c6410 chip.
+
 config APM_POWER
 	tristate "APM emulation for class batteries"
 	depends on APM_EMULATION
diff -Nur linux-2.6.29/drivers/power/Makefile linux-2.6.29-spica/drivers/power/Makefile
--- linux-2.6.29/drivers/power/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/power/Makefile	2010-05-06 12:42:45.644210217 +0700
@@ -15,6 +15,7 @@
 obj-$(CONFIG_POWER_SUPPLY)	+= power_supply.o
 
 obj-$(CONFIG_PDA_POWER)		+= pda_power.o
+obj-$(CONFIG_BATTERY_S3C6410)	+= s3c6410_battery.o
 obj-$(CONFIG_APM_POWER)		+= apm_power.o
 obj-$(CONFIG_WM8350_POWER)	+= wm8350_power.o
 
diff -Nur linux-2.6.29/drivers/power/power_supply_sysfs.c linux-2.6.29-spica/drivers/power/power_supply_sysfs.c
--- linux-2.6.29/drivers/power/power_supply_sysfs.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/power/power_supply_sysfs.c	2010-05-06 12:42:45.644210217 +0700
@@ -30,7 +30,7 @@
 
 #define POWER_SUPPLY_ATTR(_name)					\
 {									\
-	.attr = { .name = #_name, .mode = 0444 },	\
+	.attr = { .name = #_name, .mode = 0444, .owner = THIS_MODULE },	\
 	.show = power_supply_show_property,				\
 	.store = NULL,							\
 }
@@ -45,7 +45,7 @@
 	};
 	static char *health_text[] = {
 		"Unknown", "Good", "Overheat", "Dead", "Over voltage",
-		"Unspecified failure", "Cold",
+		"Unspecified failure", "Freeze"
 	};
 	static char *technology_text[] = {
 		"Unknown", "NiMH", "Li-ion", "Li-poly", "LiFe", "NiCd",
diff -Nur linux-2.6.29/drivers/power/s3c6410_battery.c linux-2.6.29-spica/drivers/power/s3c6410_battery.c
--- linux-2.6.29/drivers/power/s3c6410_battery.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/power/s3c6410_battery.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,2353 @@
+/*
+ * linux/drivers/power/s3c6410_battery.c
+ *
+ * Battery measurement code for S3C6410 platform.
+ *
+ * based on palmtx_battery.c
+ *
+ * Copyright (C) 2009 Samsung Electronics.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/power_supply.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/wakelock.h>
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <plat/gpio-cfg.h>
+
+#include "s3c6410_battery.h"
+
+static struct wake_lock vbus_wake_lock;
+#if (defined __TEST_DEVICE_DRIVER__  || defined __ALWAYS_AWAKE_DEVICE__)
+static struct wake_lock wake_lock_for_dev;
+#endif /* __TEST_DEVICE_DRIVER__ || __ALWAYS_AWAKE_DEVICE__ */
+
+#ifdef __USE_EGPIO__
+#include <plat/egpio.h>
+#endif /* __USE_EGPIO__ */
+
+#ifdef __TEST_DEVICE_DRIVER__
+#include <linux/i2c/pmic.h>
+#endif /* __TEST_DEVICE_DRIVER__ */
+
+#ifdef __FUEL_GAUGES_IC__
+#include <linux/i2c.h>
+#include "fuel_gauge.c"
+#endif /* __FUEL_GAUGES_IC__ */
+
+/* Prototypes */
+extern int s3c_adc_get_adc_data(int channel);
+extern int get_usb_power_state(void);
+
+static ssize_t s3c_bat_show_property(struct device *dev,
+                                      struct device_attribute *attr,
+                                      char *buf);
+static ssize_t s3c_bat_store(struct device *dev, 
+			     struct device_attribute *attr,
+			     const char *buf, size_t count);
+static void s3c_set_chg_en(int enable);
+
+#ifdef __TEST_DEVICE_DRIVER__
+extern int amp_enable(int);
+extern int audio_power(int);
+
+static ssize_t s3c_test_show_property(struct device *dev,
+                                      struct device_attribute *attr,
+                                      char *buf);
+static ssize_t s3c_test_store(struct device *dev, 
+			     struct device_attribute *attr,
+			     const char *buf, size_t count);
+static int bat_temper_state = 0; // for test 1: overheat, 2: freeze
+#endif /* __TEST_DEVICE_DRIVER__ */
+
+#ifdef __TEST_MODE_INTERFACE__
+static struct power_supply *s3c_power_supplies_test = NULL;
+static void polling_timer_func(unsigned long unused);
+static void s3c_bat_status_update(struct power_supply *bat_ps);
+#endif /* __TEST_MODE_INTERFACE__ */
+
+#define ADC_DATA_ARR_SIZE	6
+#define ADC_TOTAL_COUNT		10
+#define POLLING_INTERVAL	2000
+#ifdef __TEST_MODE_INTERFACE__
+#define POLLING_INTERVAL_TEST	1000
+#endif /* __TEST_MODE_INTERFACE__ */
+
+#ifdef __BATTERY_COMPENSATION__
+/* Offset Bit Value */
+#define OFFSET_VIBRATOR_ON		(0x1 << 0)
+#define OFFSET_CAMERA_ON		(0x1 << 1)
+#define OFFSET_MP3_PLAY			(0x1 << 2)
+#define OFFSET_VIDEO_PLAY		(0x1 << 3)
+#define OFFSET_VOICE_CALL_2G		(0x1 << 4)
+#define OFFSET_VOICE_CALL_3G		(0x1 << 5)
+#define OFFSET_DATA_CALL		(0x1 << 6)
+#define OFFSET_LCD_ON			(0x1 << 7)
+#define OFFSET_TA_ATTACHED		(0x1 << 8)
+#define OFFSET_CAM_FLASH		(0x1 << 9)
+#define OFFSET_BOOTING			(0x1 << 10)
+#endif /* __BATTERY_COMPENSATION__ */
+
+#ifdef __9BITS_RESOLUTION__
+#define INVALID_VOL_ADC		20
+#else /* __9BITS_RESOLUTION__ */
+#define INVALID_VOL_ADC		160
+#endif /* __9BITS_RESOLUTION__ */
+
+#define ENABLE		1
+#define DISABLE		0
+
+#ifndef convert_adc2voltage
+	#ifdef __9BITS_RESOLUTION__
+	#define convert_adc2voltage(x)		(x * 10000 / 848)
+	#else /* __9BITS_RESOLUTION__ */
+	#define convert_adc2voltage(x)		((x - 2170 ) * 10 / 7 + 3200)
+	#endif /* __9BITS_RESOLUTION__ */
+#endif /* convert_adc2voltage */
+
+static struct work_struct bat_work;
+static struct work_struct cable_work;
+
+#ifdef COMPENSATE_BOOTING
+static struct workqueue_struct *batt_drv_wqueue;
+static struct work_struct compensate_boot_work;
+#endif /* COMPENSATE_BOOTING */
+
+static struct device *dev;
+static struct timer_list polling_timer;
+static struct timer_list cable_timer;
+static int cable_intr_cnt = 0;
+
+static int s3c_battery_initial;
+static int force_update;
+static int full_charge_flag;
+
+static int batt_max;
+static int batt_full;
+static int batt_safe_rech;
+static int batt_almost;
+static int batt_high;
+static int batt_medium;
+static int batt_low;
+static int batt_critical;
+static int batt_min;
+static int batt_off;
+#ifdef __ADJUST_RECHARGE_ADC__
+static int batt_recharging;
+#endif /* __ADJUST_RECHARGE_ADC__ */
+#ifdef __BATTERY_COMPENSATION__
+static int batt_compensation;
+#endif /* __BATTERY_COMPENSATION__ */
+
+static unsigned int start_time_msec;
+static unsigned int total_time_msec;
+
+#ifdef __BOARD_REV_ADC__
+static int board_rev_adc;
+static int is_end_board_rev_adc;
+#endif /* __BOARD_REV_ADC__ */
+
+static char *status_text[] = {
+	[POWER_SUPPLY_STATUS_UNKNOWN] =		"Unknown",
+	[POWER_SUPPLY_STATUS_CHARGING] =	"Charging",
+	[POWER_SUPPLY_STATUS_DISCHARGING] =	"Discharging",
+	[POWER_SUPPLY_STATUS_NOT_CHARGING] =	"Not Charging",
+	[POWER_SUPPLY_STATUS_FULL] =		"Full",
+};
+
+typedef enum {
+	CHARGER_BATTERY = 0,
+	CHARGER_USB,
+	CHARGER_AC,
+	CHARGER_DISCHARGE
+} charger_type_t;
+
+struct battery_info {
+	u32 batt_id;		/* Battery ID from ADC */
+	s32 batt_vol;		/* Battery voltage from ADC */
+	s32 batt_vol_adc;	/* Battery ADC value */
+	s32 batt_vol_adc_cal;	/* Battery ADC value (calibrated)*/
+	s32 batt_temp;		/* Battery Temperature (C) from ADC */
+	s32 batt_temp_adc;	/* Battery Temperature ADC value */
+	s32 batt_temp_adc_cal;	/* Battery Temperature ADC value (calibrated) */
+	s32 batt_current;	/* Battery current from ADC */
+	u32 level;		/* formula */
+	u32 charging_source;	/* 0: no cable, 1:usb, 2:AC */
+	u32 charging_enabled;	/* 0: Disable, 1: Enable */
+	u32 batt_health;	/* Battery Health (Authority) */
+	u32 batt_is_full;       /* 0 : Not full 1: Full */
+	u32 batt_is_recharging; /* 0 : Not recharging 1: Recharging */
+	s32 batt_vol_adc_aver;	/* batt vol adc average */
+#ifdef __TEST_MODE_INTERFACE__
+	u32 batt_test_mode;	/* test mode */
+	s32 batt_vol_aver;	/* batt vol average */
+	s32 batt_temp_aver;	/* batt temp average */
+	s32 batt_temp_adc_aver;	/* batt temp adc average */
+	s32 batt_v_f_adc;	/* batt V_F adc */
+#endif /* __TEST_MODE_INTERFACE__ */
+};
+
+/* lock to protect the battery info */
+static DEFINE_MUTEX(work_lock);
+
+struct s3c_battery_info {
+	int present;
+	int polling;
+	unsigned int polling_interval;
+	unsigned int device_state;
+
+	struct battery_info bat_info;
+};
+static struct s3c_battery_info s3c_bat_info;
+
+struct adc_sample_info {
+	unsigned int cnt;
+	int total_adc;
+	int average_adc;
+	int adc_arr[ADC_TOTAL_COUNT];
+	int index;
+};
+static struct adc_sample_info adc_sample[ENDOFADC];
+
+static inline int s3c_adc_get_adc_data_ex(int channel) {
+#ifndef __9BITS_RESOLUTION__
+	return s3c_adc_get_adc_data(channel);
+#else
+#ifdef __REVERSE_TEMPER_ADC__
+	if (channel == S3C_ADC_TEMPERATURE) 
+		return (4096 - s3c_adc_get_adc_data(channel)) / 8;
+	else
+#endif /* __REVERSE_TEMPER_ADC__ */
+		return s3c_adc_get_adc_data(channel) / 8;
+#endif /* __9BITS_RESOLUTION__ */
+}
+
+#ifdef __CHECK_CHG_CURRENT__
+static inline void clear_adc_sample(adc_channel_type channel)
+{
+	adc_sample[channel].cnt = 0;
+	adc_sample[channel].total_adc = 0;
+}
+#endif /* __CHECK_CHG_CURRENT__ */
+
+static unsigned long calculate_average_adc(adc_channel_type channel, int adc)
+{
+	unsigned int cnt = 0;
+	int total_adc = 0;
+	int average_adc = 0;
+	int index = 0;
+
+	cnt = adc_sample[channel].cnt;
+	total_adc = adc_sample[channel].total_adc;
+
+	if (adc < 0 || adc == 0) {
+		dev_err(dev, "%s: invalid adc : %d(ch:%d)\n", __func__,
+				adc, channel);
+		adc = adc_sample[channel].average_adc;
+	}
+
+	if( cnt < ADC_TOTAL_COUNT ) {
+		adc_sample[channel].adc_arr[cnt] = adc;
+		adc_sample[channel].index = cnt;
+		adc_sample[channel].cnt = ++cnt;
+
+		total_adc += adc;
+		average_adc = total_adc / cnt;
+	} else {
+#if 0
+		if (channel == S3C_ADC_VOLTAGE &&
+				!s3c_bat_info.bat_info.charging_enabled && 
+				adc > adc_sample[channel].average_adc) {
+			dev_dbg(dev, "%s: adc over avg : %d\n", __func__, adc);
+			return adc_sample[channel].average_adc;
+		}
+#endif
+		index = adc_sample[channel].index;
+		if (++index >= ADC_TOTAL_COUNT)
+			index = 0;
+
+		total_adc = (total_adc - adc_sample[channel].adc_arr[index]) + adc;
+		average_adc = total_adc / ADC_TOTAL_COUNT;
+
+		adc_sample[channel].adc_arr[index] = adc;
+		adc_sample[channel].index = index;
+	}
+
+	adc_sample[channel].total_adc = total_adc;
+	adc_sample[channel].average_adc = average_adc;
+
+	dev_dbg(dev, "%s: ch:%d adc=%d, avg_adc=%d\n",
+			__func__, channel, adc, average_adc);
+	return average_adc;
+}
+
+static int s3c_bat_get_adc_data(adc_channel_type adc_ch)
+{
+	int adc_arr[ADC_DATA_ARR_SIZE];
+	int adc_max = 0;
+	int adc_min = 0;
+	int adc_total = 0;
+	int i;
+
+	for (i = 0; i < ADC_DATA_ARR_SIZE; i++) {
+		adc_arr[i] = s3c_adc_get_adc_data_ex(adc_ch);
+		dev_dbg(dev, "%s: adc_arr = %d\n", __func__, adc_arr[i]);
+		if (i != 0) {
+			if (adc_arr[i] > adc_max) 
+				adc_max = adc_arr[i];
+			else if (adc_arr[i] < adc_min)
+				adc_min = adc_arr[i];
+		} else {
+			adc_max = adc_arr[0];
+			adc_min = adc_arr[0];
+		}
+		adc_total += adc_arr[i];
+	}
+
+	dev_dbg(dev, "%s: adc_max = %d, adc_min = %d\n",
+			__func__, adc_max, adc_min);
+	return (adc_total - adc_max - adc_min) / (ADC_DATA_ARR_SIZE - 2);
+}
+
+#ifndef __FUEL_GAUGES_IC__
+static unsigned long s3c_read_bat(struct power_supply *bat_ps)
+{
+	int adc = 0;
+	static int cnt = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	adc = s3c_bat_get_adc_data(S3C_ADC_VOLTAGE);
+	dev_dbg(dev, "%s: adc = %d\n", __func__, adc);
+
+#ifdef __BATTERY_COMPENSATION__
+	adc += batt_compensation;
+#endif /* __BATTERY_COMPENSATION__ */
+	if (adc < s3c_bat_info.bat_info.batt_vol_adc_aver - INVALID_VOL_ADC
+			&& cnt < 10) {
+		dev_err(dev, "%s: invalid adc = %d\n", __func__, adc);
+		adc = s3c_bat_info.bat_info.batt_vol_adc_aver;
+		cnt++;
+	} else {
+		cnt = 0;
+	}
+	s3c_bat_info.bat_info.batt_vol_adc =  adc;
+
+	return calculate_average_adc(S3C_ADC_VOLTAGE, adc);
+}
+#endif /* __FUEL_GAUGES_IC__ */
+
+static unsigned long s3c_read_temp(struct power_supply *bat_ps)
+{
+	int adc = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	adc = s3c_bat_get_adc_data(S3C_ADC_TEMPERATURE);
+	dev_dbg(dev, "%s: adc = %d\n", __func__, adc);
+
+#ifdef __TEST_DEVICE_DRIVER__
+	switch (bat_temper_state) {
+	case 0:
+		break;
+	case 1:
+		adc = TEMP_HIGH_BLOCK;
+		break;
+	case 2:
+		adc = TEMP_LOW_BLOCK;
+		break;
+	default:
+		break;
+	}
+#endif /* __TEST_DEVICE_DRIVER__ */
+
+	s3c_bat_info.bat_info.batt_temp_adc = adc;
+
+#ifdef __AVG_TEMP_ADC__
+	return calculate_average_adc(S3C_ADC_TEMPERATURE, adc);
+#else /* __AVG_TEMP_ADC__ */
+	return adc;
+#endif /* __AVG_TEMP_ADC__ */
+}
+
+static u32 s3c_get_bat_health(void)
+{
+	return s3c_bat_info.bat_info.batt_health;
+}
+
+static void s3c_set_bat_health(u32 batt_health)
+{
+	s3c_bat_info.bat_info.batt_health = batt_health;
+}
+
+static int is_over_abs_time(void)
+{
+	unsigned int total_time;
+
+	if (!start_time_msec)
+		return 0;
+
+	if (s3c_bat_info.bat_info.batt_is_recharging)
+		total_time = TOTAL_RECHARGING_TIME;
+	else
+		total_time = TOTAL_CHARGING_TIME;
+
+	total_time_msec = jiffies_to_msecs(jiffies) - start_time_msec;
+	if (total_time_msec > total_time)
+		return 1;
+	else
+		return 0;
+}
+
+#ifdef __BATTERY_COMPENSATION__
+static void s3c_bat_set_compesation(int mode, 
+				    int offset,
+				    int compensate_value)
+{
+	if (mode) {
+		if (!(s3c_bat_info.device_state & offset)) {
+			s3c_bat_info.device_state |= offset;
+			batt_compensation += compensate_value;
+		}
+	} else {
+		if (s3c_bat_info.device_state & offset) {
+			s3c_bat_info.device_state &= ~offset;
+			batt_compensation -= compensate_value;
+		}
+	}
+	dev_dbg(dev, "%s: device_state=0x%x, compensation=%d\n", __func__,
+			s3c_bat_info.device_state, batt_compensation);
+}
+#endif /* __BATTERY_COMPENSATION__ */
+
+#ifdef __CHECK_CHG_CURRENT__
+static int s3c_read_current(struct power_supply *bat_ps)
+{
+	int adc = 0;
+	adc = s3c_bat_get_adc_data(S3C_ADC_CHG_CURRENT);
+	dev_dbg(dev, "%s: adc = %d\n", __func__, adc);
+
+	return calculate_average_adc(S3C_ADC_CHG_CURRENT, adc);
+}
+
+static void check_chg_current(struct power_supply *bat_ps)
+{
+	static int cnt = 0;
+	int chg_current = 0; 
+
+	chg_current = s3c_read_current(bat_ps);
+	s3c_bat_info.bat_info.batt_current = chg_current;
+	if (chg_current <= CURRENT_OF_FULL_CHG) {
+		cnt++;
+		if (cnt >= 10) {
+			dev_info(dev, "%s: battery full(%d)\n",
+					__func__, chg_current);
+			s3c_set_chg_en(DISABLE);
+			s3c_bat_info.bat_info.batt_is_full = 1;
+			force_update = 1;
+			full_charge_flag = 1;
+			cnt = 0;
+			clear_adc_sample(S3C_ADC_CHG_CURRENT);
+		}
+	} else {
+		cnt = 0;
+	}
+	dev_dbg(dev, "%s: chg_current=%d\n", __func__, chg_current);
+}
+#endif /* __CHECK_CHG_CURRENT__ */
+
+#ifdef __ADJUST_RECHARGE_ADC__
+static void check_recharging_bat(int bat_vol)
+{
+	static int cnt = 0;
+
+	if (s3c_get_bat_health() != POWER_SUPPLY_HEALTH_GOOD)
+		goto out;
+
+	if (!s3c_bat_info.bat_info.batt_is_full || 
+		s3c_bat_info.bat_info.charging_enabled) 
+		goto out;
+
+	if (batt_recharging != -1 && bat_vol <= batt_recharging) {
+		if (++cnt >= 3) {
+			dev_info(dev, "%s: recharging(adj):%d\n", __func__,
+					bat_vol);
+			s3c_bat_info.bat_info.batt_is_recharging = 1;
+			s3c_set_chg_en(ENABLE);
+			goto out;
+		}
+	} else {
+		cnt = 0;
+	}
+
+	if (bat_vol <= batt_safe_rech ) {
+		dev_info(dev, "%s: recharging(safe):%d\n", __func__, bat_vol);
+		s3c_bat_info.bat_info.batt_is_recharging = 1;
+		s3c_set_chg_en(ENABLE);
+		goto out;
+	}
+	
+	return;
+out:
+	cnt = 0;
+	return;
+}
+#else /* __ADJUST_RECHARGE_ADC__ */
+#ifdef __FUEL_GAUGES_IC__
+static void check_recharging_bat(int fg_vcell)
+{
+	static int cnt = 0;
+
+	if (s3c_get_bat_health() != POWER_SUPPLY_HEALTH_GOOD) {
+		cnt = 0;
+		return;
+	}
+
+	if (s3c_bat_info.bat_info.batt_is_full &&
+		!s3c_bat_info.bat_info.charging_enabled &&
+		(fg_vcell <= RECHARGE_COND_VOLTAGE || 
+			fg_vcell <= FULL_CHARGE_COND_VOLTAGE)) {
+		if (++cnt >= 10) {
+			dev_info(dev, "%s: recharging(vcell:%d)\n", __func__,
+					fg_vcell);
+			s3c_bat_info.bat_info.batt_is_recharging = 1;
+			s3c_set_chg_en(ENABLE);
+			cnt = 0;
+		}
+	} else {
+		cnt = 0;
+	}
+}
+#else /* __FUEL_GAUGES_IC__ */
+static void check_recharging_bat(int bat_vol)
+{
+	static int cnt = 0;
+
+	if (s3c_get_bat_health() != POWER_SUPPLY_HEALTH_GOOD) {
+		cnt = 0;
+		return;
+	}
+
+	if (bat_vol > batt_safe_rech ) {
+		cnt = 0;
+		return;
+	}
+
+	if (s3c_bat_info.bat_info.batt_is_full &&
+		!s3c_bat_info.bat_info.charging_enabled) {
+		if (++cnt >= 10) {
+			dev_info(dev, "%s: recharging(safe), (adc:%d)\n",
+					__func__, bat_vol);
+			s3c_bat_info.bat_info.batt_is_recharging = 1;
+			s3c_set_chg_en(ENABLE);
+			cnt = 0;
+		}
+	} else {
+		cnt = 0;
+	}
+}
+#endif /* __FUEL_GAUGES_IC__ */
+#endif /* __ADJUST_RECHARGE_ADC__ */
+
+#ifndef __FUEL_GAUGES_IC__
+#ifdef __ANDROID_BAT_LEVEL_CONCEPT__
+static int s3c_get_bat_level(struct power_supply *bat_ps)
+{
+	int bat_level = 0;
+	int bat_vol = s3c_read_bat(bat_ps);
+
+	s3c_bat_info.bat_info.batt_vol_adc_aver = bat_vol;
+
+	if(is_over_abs_time()) {
+		bat_level = 100;
+		s3c_bat_info.bat_info.batt_is_full = 1;
+		dev_info(dev, "%s: charging time is over\n", __func__);
+		s3c_set_chg_en(DISABLE);
+		goto __end__;
+	}
+
+#ifdef __BATTERY_COMPENSATION__
+	if (s3c_bat_info.bat_info.charging_enabled) {
+		if (bat_vol > batt_full - COMPENSATE_TA) {
+			s3c_bat_set_compesation(0, OFFSET_TA_ATTACHED,
+					COMPENSATE_TA);
+		}
+	}
+#endif /* __BATTERY_COMPENSATION__ */
+
+	check_recharging_bat(bat_vol);
+
+	if (bat_vol > batt_full) {
+		int temp = 5;	/* 100% : 4.03V ADC : 341  Offset : 45 */
+		if (bat_vol > (batt_full + temp) || 
+				s3c_bat_info.bat_info.batt_is_full)
+			bat_level = 100;
+		else
+			bat_level = 90;
+
+#ifdef __CHECK_CHG_CURRENT__
+		if (s3c_bat_info.bat_info.charging_enabled) {
+			check_chg_current(bat_ps);
+			if (!s3c_bat_info.bat_info.batt_is_full)
+				bat_level = 90;
+		}
+#endif /* __CHECK_CHG_CURRENT__ */
+		dev_dbg(dev, "%s: (full)level = %d\n", __func__, bat_level );
+	} else if (batt_full >= bat_vol && bat_vol > batt_almost) {
+		int temp = (batt_full - batt_almost) / 2;
+		if (bat_vol > (batt_almost + temp))
+			bat_level = 80;
+		else
+			bat_level = 70;
+
+		if (s3c_bat_info.bat_info.batt_is_recharging)
+			bat_level = 100;
+
+		dev_dbg(dev, "%s: (almost)level = %d\n", __func__, bat_level);
+	} else if (batt_almost >= bat_vol && bat_vol > batt_high) {
+		int temp = (batt_almost - batt_high) / 2;
+		if (bat_vol > (batt_high + temp))
+			bat_level = 60;
+		else
+			bat_level = 50;
+		dev_dbg(dev, "%s: (high)level = %d\n", __func__, bat_level );
+	} else if (batt_high >= bat_vol && bat_vol > batt_medium) {
+		int temp = (batt_high - batt_medium) / 2;
+		if (bat_vol > (batt_medium + temp))
+			bat_level = 40;
+		else
+			bat_level = 30;
+		dev_dbg(dev, "%s: (med)level = %d\n", __func__, bat_level);
+	} else if (batt_medium >= bat_vol && bat_vol > batt_low) {
+		bat_level = 15;
+		dev_dbg(dev, "%s: (low)level = %d\n", __func__, bat_level);
+	} else if (batt_low >= bat_vol && bat_vol > batt_critical) {
+		bat_level = 5;
+		dev_dbg(dev, "%s: (cri)level = %d, vol = %d\n", __func__,
+				bat_level, bat_vol);
+	} else if (batt_critical >= bat_vol && bat_vol > batt_min) {
+		bat_level = 3;
+		dev_info(dev, "%s: (min)level = %d, vol = %d\n", __func__,
+				bat_level, bat_vol);
+	} else if (batt_min >= bat_vol && bat_vol > batt_off) {
+		bat_level = 1;
+		dev_info(dev, "%s: (off)level = %d, vol = %d\n", __func__,
+				bat_level, bat_vol);
+	} else if (batt_off >= bat_vol)  {
+		bat_level = 0;
+		dev_info(dev, "%s: (off)level = %d, vol = %d", __func__,
+				bat_level, bat_vol);
+	}
+	dev_dbg(dev, "%s: level = %d\n", __func__, bat_level);
+
+__end__:
+	dev_dbg(dev, "%s: bat_vol = %d, level = %d, is_full = %d\n",
+			__func__, bat_vol, bat_level, 
+			s3c_bat_info.bat_info.batt_is_full);
+#ifdef __TEMP_ADC_VALUE__
+	return 80;
+#else
+	return bat_level;
+#endif /* __TEMP_ADC_VALUE__ */
+}
+#else /* __ANDROID_BAT_LEVEL_CONCEPT__ */
+static int s3c_get_bat_level(struct power_supply *bat_ps)
+{
+	int bat_level = 0;
+	int bat_vol = s3c_read_bat(bat_ps);
+
+	s3c_bat_info.bat_info.batt_vol_adc_aver = bat_vol;
+
+	if(is_over_abs_time()) {
+		bat_level = 100;
+		s3c_bat_info.bat_info.batt_is_full = 1;
+		dev_info(dev, "%s: charging time is over\n", __func__);
+		s3c_set_chg_en(DISABLE);
+		goto __end__;
+	}
+
+#ifdef __BATTERY_COMPENSATION__
+	if (s3c_bat_info.bat_info.charging_enabled) {
+		if (bat_vol > batt_almost - COMPENSATE_TA) {
+			s3c_bat_set_compesation(0, OFFSET_TA_ATTACHED,
+					COMPENSATE_TA);
+		}
+	}
+#endif /* __BATTERY_COMPENSATION__ */
+
+	if (bat_vol > batt_full) {
+		bat_level = 100;
+#ifdef __CHECK_CHG_CURRENT__
+		if (s3c_bat_info.bat_info.charging_enabled) {
+			check_chg_current(bat_ps);
+			if (!s3c_bat_info.bat_info.batt_is_full)
+				bat_level = 90;
+		}
+#endif /* __CHECK_CHG_CURRENT__ */
+#ifdef __ADJUST_RECHARGE_ADC__
+		check_recharging_bat(bat_vol);
+#endif /* __ADJUST_RECHARGE_ADC__ */
+		dev_dbg(dev, "%s: (full)level = %d\n", __func__, bat_level );
+	} else if (batt_full >= bat_vol && bat_vol > batt_almost) {
+		int temp = (batt_full - batt_almost) / 3;
+		if (bat_vol > (batt_almost + temp * 2))
+			bat_level = 90;
+		else if (bat_vol > (batt_almost + temp))
+			bat_level = 80;
+		else
+			bat_level = 70;
+
+		if (s3c_bat_info.bat_info.batt_is_recharging)
+			bat_level = 100;
+
+		if (s3c_bat_info.bat_info.batt_is_full &&
+			!s3c_bat_info.bat_info.charging_enabled) {
+			dev_info(dev, "%s: recharging(under full)\n", __func__);
+			s3c_bat_info.bat_info.batt_is_recharging = 1;
+			s3c_set_chg_en(ENABLE);
+			bat_level = 100;
+		}
+		dev_dbg(dev, "%s: (almost)level = %d\n", __func__, bat_level);
+	} else if (batt_almost >= bat_vol && bat_vol > batt_high) {
+		bat_level = 50;
+		dev_dbg(dev, "%s: (high)level = %d\n", __func__, bat_level );
+	} else if (batt_high >= bat_vol && bat_vol > batt_medium) {
+		bat_level = 30;
+		dev_dbg(dev, "%s: (med)level = %d\n", __func__, bat_level);
+	} else if (batt_medium >= bat_vol && bat_vol > batt_low) {
+		bat_level = 15;
+		dev_dbg(dev, "%s: (low)level = %d\n", __func__, bat_level);
+	} else if (batt_low >= bat_vol && bat_vol > batt_critical) {
+		bat_level = 5;
+		dev_info(dev, "%s: (cri)level = %d, vol = %d\n", __func__,
+				bat_level, bat_vol);
+	} else if (batt_critical >= bat_vol && bat_vol > batt_min) {
+		bat_level = 3;
+		dev_info(dev, "%s: (min)level = %d, vol = %d\n", __func__,
+				bat_level, bat_vol);
+	} else if (batt_min >= bat_vol && bat_vol > batt_off) {
+		bat_level = 1;
+		dev_info(dev, "%s: (off)level = %d, vol = %d\n", __func__,
+				bat_level, bat_vol);
+	} else if (batt_off >= bat_vol)  {
+		bat_level = 0;
+		dev_info(dev, "%s: (off)level = %d, vol = %d", __func__,
+				bat_level, bat_vol);
+	}
+	dev_dbg(dev, "%s: level = %d\n", __func__, bat_level);
+
+__end__:
+	dev_dbg(dev, "%s: bat_vol = %d, level = %d, is_full = %d\n",
+			__func__, bat_vol, bat_level, 
+			s3c_bat_info.bat_info.batt_is_full);
+#ifdef __TEMP_ADC_VALUE__
+	return 80;
+#else
+	return bat_level;
+#endif /* __TEMP_ADC_VALUE__ */
+}
+#endif /* __ANDROID_BAT_LEVEL_CONCEPT__ */
+
+static int s3c_get_bat_vol(struct power_supply *bat_ps)
+{
+	int bat_vol = 0;
+	int adc = s3c_bat_info.bat_info.batt_vol_adc;
+#ifdef __TEST_MODE_INTERFACE__
+	int batt_vol_adc_aver = s3c_bat_info.bat_info.batt_vol_adc_aver;
+	s3c_bat_info.bat_info.batt_vol_aver = 
+		convert_adc2voltage(batt_vol_adc_aver);
+#endif /* __TEST_MODE_INTERFACE__ */
+
+	bat_vol = convert_adc2voltage(adc);
+
+	dev_dbg(dev, "%s: adc = %d, bat_vol = %d\n",
+			__func__, adc, bat_vol);
+
+	return bat_vol;
+}
+#else /* __FUEL_GAUGES_IC__ */
+static int s3c_get_bat_level(struct power_supply *bat_ps)
+{
+	int fg_soc = -1;
+	int fg_vcell = -1;
+
+	if ((fg_soc = fg_read_soc()) < 0) {
+		dev_err(dev, "%s: Can't read soc!!!\n", __func__);
+		fg_soc = s3c_bat_info.bat_info.level;
+	}
+	
+	if ((fg_vcell = fg_read_vcell()) < 0) {
+		dev_err(dev, "%s: Can't read vcell!!!\n", __func__);
+		fg_vcell = s3c_bat_info.bat_info.batt_vol;
+	} else
+		s3c_bat_info.bat_info.batt_vol = fg_vcell;
+
+	if (is_over_abs_time()) {
+		fg_soc = 100;
+		s3c_bat_info.bat_info.batt_is_full = 1;
+		dev_info(dev, "%s: charging time is over\n", __func__);
+		s3c_set_chg_en(DISABLE);
+		goto __end__;
+	}
+
+	if (fg_soc > 80) {
+		fg_soc += fg_soc - 80;
+
+		if (fg_soc > 100)
+			fg_soc = 100;
+	}
+#ifdef __CHECK_CHG_CURRENT__
+	if (fg_vcell >= FULL_CHARGE_COND_VOLTAGE) {
+		if (s3c_bat_info.bat_info.charging_enabled) {
+			check_chg_current(bat_ps);
+			if (s3c_bat_info.bat_info.batt_is_full)
+				fg_soc = 100;
+		}
+	}
+#endif /* __CHECK_CHG_CURRENT__ */
+
+	check_recharging_bat(fg_vcell);
+
+__end__:
+	dev_dbg(dev, "%s: fg_vcell = %d, fg_soc = %d, is_full = %d\n",
+			__func__, fg_vcell, fg_soc, 
+			s3c_bat_info.bat_info.batt_is_full);
+	return fg_soc;
+}
+
+static int s3c_get_bat_vol(struct power_supply *bat_ps)
+{
+	return s3c_bat_info.bat_info.batt_vol;
+}
+#endif /* __FUEL_GAUGES_IC__ */
+
+#ifdef __BOARD_REV_ADC__
+static void s3c_get_board_rev_adc(struct power_supply *bat_ps)
+{
+	static unsigned int cnt = 0;
+	int adc = 0;
+
+	adc = s3c_bat_get_adc_data(S3C_ADC_BOARD_REV);
+	board_rev_adc = calculate_average_adc(S3C_ADC_BOARD_REV, adc);
+	dev_dbg(dev, "%s: adc=%d, avg_adc=%d\n", __func__, adc, board_rev_adc);
+
+	if (++cnt >= 10)
+		is_end_board_rev_adc = 1;
+}
+#endif /* __BOARD_REV_ADC__ */
+
+#if (defined __TEST_MODE_INTERFACE__ && defined __BATTERY_V_F__)
+static void s3c_get_v_f_adc(void)
+{
+	s3c_bat_info.bat_info.batt_v_f_adc
+		= s3c_bat_get_adc_data(S3C_ADC_V_F);
+	dev_info(dev, "%s: vf=%d\n", __func__,
+			s3c_bat_info.bat_info.batt_v_f_adc);
+}
+#endif /* __TEST_MODE_INTERFACE__ && __BATTERY_V_F__ */
+
+static inline int gpio_get_value_ex(unsigned int pin)
+{
+#ifndef __USE_EGPIO__
+	return gpio_get_value(pin);
+#else
+	return egpio_get_value(pin);
+#endif /* __USE_EGPIO__ */
+}
+
+static inline void gpio_set_value_ex(unsigned int pin, unsigned int level)
+{
+#ifndef __USE_EGPIO__
+	gpio_set_value(pin, level);
+#else
+	egpio_set_value(pin, level);
+#endif /* __USE_EGPIO__ */
+}
+
+static void s3c_set_time_for_charging(int mode) {
+	if (mode) {
+		/* record start time for abs timer */
+		start_time_msec = jiffies_to_msecs(jiffies);
+		dev_info(dev, "%s: start_time(%d)\n", __func__,
+				start_time_msec);
+	} else {
+		/* initialize start time for abs timer */
+		start_time_msec = 0;
+		total_time_msec = 0;
+		dev_info(dev, "%s: reset abs timer\n", __func__);
+	}
+}
+
+static void s3c_set_chg_en(int enable)
+{
+	int chg_en_val = gpio_get_value_ex(gpio_chg_en);
+
+	if (enable) {
+		if (chg_en_val == GPIO_LEVEL_HIGH) {
+			gpio_set_value_ex(gpio_chg_en, GPIO_LEVEL_LOW);
+//.i [VinsQ] [Start] Charger IC Changed to MAX8922    Pineone hgwoo    2010.01.05
+#if defined(CONFIG_MACH_VINSQ)
+			udelay(2000);
+			gpio_set_value_ex(gpio_chg_en, GPIO_LEVEL_HIGH);
+			udelay(10);
+			gpio_set_value_ex(gpio_chg_en, GPIO_LEVEL_LOW);
+			udelay(2000);
+#endif
+//.i [VinsQ] [End] Charger IC Changed to MAX8922    Pineone hgwoo    2010.01.05
+			dev_info(dev, "%s: gpio_chg_en(0)\n", __func__);
+			s3c_set_time_for_charging(1);
+#ifdef __BATTERY_COMPENSATION__
+			s3c_bat_set_compesation(1, OFFSET_TA_ATTACHED,
+					COMPENSATE_TA);
+#endif /* __BATTERY_COMPENSATION__ */
+		}
+	} else {
+		if (chg_en_val == GPIO_LEVEL_LOW) {
+			gpio_set_value_ex(gpio_chg_en, GPIO_LEVEL_HIGH);
+//.i [VinsQ] [Start] Charger IC Changed to MAX8922    Pineone hgwoo    2010.01.05
+#if defined(CONFIG_MACH_VINSQ)
+			udelay(2000);
+#endif
+//.i [VinsQ] [End] Charger IC Changed to MAX8922    Pineone hgwoo    2010.01.05
+			dev_info(dev, "%s: gpio_chg_en(1)\n", __func__);
+			s3c_set_time_for_charging(0);
+			s3c_bat_info.bat_info.batt_is_recharging = 0;
+#ifdef __BATTERY_COMPENSATION__
+			s3c_bat_set_compesation(0, OFFSET_TA_ATTACHED,
+					COMPENSATE_TA);
+#endif /* __BATTERY_COMPENSATION__ */
+		}
+	}
+	s3c_bat_info.bat_info.charging_enabled = enable;
+}
+
+static void s3c_temp_control(int mode) {
+	int adc = s3c_bat_info.bat_info.batt_temp_adc_aver;
+	dev_info(dev, "%s: temp_adc=%d\n", __func__, adc);
+
+	switch (mode) {
+	case POWER_SUPPLY_HEALTH_GOOD:
+		dev_info(dev, "%s: GOOD\n", __func__);
+		s3c_set_bat_health(mode);
+		break;
+	case POWER_SUPPLY_HEALTH_OVERHEAT:
+		dev_info(dev, "%s: OVERHEAT\n", __func__);
+		s3c_set_bat_health(mode);
+		break;
+	case POWER_SUPPLY_HEALTH_COLD:
+		dev_info(dev, "%s: COLD\n", __func__);
+		s3c_set_bat_health(mode);
+		break;
+	default:
+		break;
+	}
+	schedule_work(&cable_work);
+}
+
+static int s3c_get_bat_temp(struct power_supply *bat_ps)
+{
+	int temp = 0;
+	int array_size = 0;
+	int i = 0;
+	int temp_adc = s3c_read_temp(bat_ps);
+	int health = s3c_get_bat_health();
+#ifdef __BATTERY_COMPENSATION__
+	unsigned int ex_case = 0;
+#endif /* __BATTERY_COMPENSATION__ */
+#ifdef __TEST_MODE_INTERFACE__
+	s3c_bat_info.bat_info.batt_temp_adc_aver = temp_adc;
+#endif /* __TEST_MODE_INTERFACE__ */
+
+#ifdef __BATTERY_COMPENSATION__
+	ex_case = OFFSET_MP3_PLAY | OFFSET_VOICE_CALL_2G | OFFSET_VOICE_CALL_3G
+		| OFFSET_DATA_CALL | OFFSET_VIDEO_PLAY;
+	if (s3c_bat_info.device_state & ex_case)
+		goto __map_temperature__;
+#endif /* __BATTERY_COMPENSATION__ */
+
+	if (s3c_bat_info.bat_info.charging_source == CHARGER_BATTERY) 
+		goto __map_temperature__;
+
+#ifndef __REVERSE_TEMPER_ADC__
+	if (temp_adc <= TEMP_HIGH_BLOCK) {
+		if (health != POWER_SUPPLY_HEALTH_OVERHEAT &&
+				health != POWER_SUPPLY_HEALTH_UNSPEC_FAILURE)
+			s3c_temp_control(POWER_SUPPLY_HEALTH_OVERHEAT);
+	} else if (temp_adc >= TEMP_HIGH_RECOVER &&
+			temp_adc <= TEMP_LOW_RECOVER) {
+		if (health == POWER_SUPPLY_HEALTH_OVERHEAT ||
+				health == POWER_SUPPLY_HEALTH_COLD)
+			s3c_temp_control(POWER_SUPPLY_HEALTH_GOOD);
+	} else if (temp_adc >= TEMP_LOW_BLOCK) {
+		if (health != POWER_SUPPLY_HEALTH_COLD &&
+				health != POWER_SUPPLY_HEALTH_UNSPEC_FAILURE)
+			s3c_temp_control(POWER_SUPPLY_HEALTH_COLD);
+	}
+
+__map_temperature__:	
+	array_size = ARRAY_SIZE(temper_table);
+	for (i = 0; i < (array_size - 1); i++) {
+		if (i == 0) {
+			if (temp_adc >= temper_table[0][0]) {
+				temp = temper_table[0][1];
+				break;
+			} else if (temp_adc <= temper_table[array_size-1][0]) {
+				temp = temper_table[array_size-1][1];
+				break;
+			}
+		}
+
+		if (temper_table[i][0] > temp_adc &&
+				temper_table[i+1][0] <= temp_adc) {
+			temp = temper_table[i+1][1];
+		}
+	}
+#else /* __REVERSE_TEMPER_ADC__ */
+	if (temp_adc >= TEMP_HIGH_BLOCK) {
+		if (health != POWER_SUPPLY_HEALTH_OVERHEAT &&
+				health != POWER_SUPPLY_HEALTH_UNSPEC_FAILURE)
+			s3c_temp_control(POWER_SUPPLY_HEALTH_OVERHEAT);
+	} else if (temp_adc <= TEMP_HIGH_RECOVER &&
+			temp_adc >= TEMP_LOW_RECOVER) {
+		if (health == POWER_SUPPLY_HEALTH_OVERHEAT ||
+				health == POWER_SUPPLY_HEALTH_COLD)
+			s3c_temp_control(POWER_SUPPLY_HEALTH_GOOD);
+	} else if (temp_adc <= TEMP_LOW_BLOCK) {
+		if (health != POWER_SUPPLY_HEALTH_COLD &&
+				health != POWER_SUPPLY_HEALTH_UNSPEC_FAILURE)
+			s3c_temp_control(POWER_SUPPLY_HEALTH_COLD);
+	}
+
+__map_temperature__:	
+	array_size = ARRAY_SIZE(temper_table);
+	for (i = 0; i < (array_size - 1); i++) {
+		if (i == 0) {
+			if (temp_adc <= temper_table[0][0]) {
+				temp = temper_table[0][1];
+				break;
+			} else if (temp_adc >= temper_table[array_size-1][0]) {
+				temp = temper_table[array_size-1][1];
+				break;
+			}
+		}
+
+		if (temper_table[i][0] < temp_adc &&
+				temper_table[i+1][0] >= temp_adc) {
+			temp = temper_table[i+1][1];
+		}
+	}
+#endif /* __REVERSE_TEMPER_ADC__ */
+	dev_dbg(dev, "%s: temp = %d, adc = %d\n",
+			__func__, temp, temp_adc);
+
+#ifdef __TEST_MODE_INTERFACE__
+       	s3c_bat_info.bat_info.batt_temp_aver = temp;
+#endif /* __TEST_MODE_INTERFACE__ */
+	return temp;
+}
+
+static int s3c_bat_get_charging_status(void)
+{
+        charger_type_t charger = CHARGER_BATTERY; 
+        int ret = 0;
+        
+        charger = s3c_bat_info.bat_info.charging_source;
+        
+        switch (charger) {
+        case CHARGER_BATTERY:
+                ret = POWER_SUPPLY_STATUS_NOT_CHARGING;
+                break;
+        case CHARGER_USB:
+        case CHARGER_AC:
+		if (s3c_get_bat_health() != POWER_SUPPLY_HEALTH_GOOD)
+			ret = POWER_SUPPLY_STATUS_DISCHARGING;
+		else {
+			if (s3c_bat_info.bat_info.batt_is_full)
+				ret = POWER_SUPPLY_STATUS_FULL;
+			else
+				ret = POWER_SUPPLY_STATUS_CHARGING;
+		}
+                break;
+	case CHARGER_DISCHARGE:
+		ret = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+        default:
+                ret = POWER_SUPPLY_STATUS_UNKNOWN;
+        }
+
+	dev_dbg(dev, "%s: %s\n", __func__, status_text[ret]);
+        return ret;
+}
+
+static int s3c_bat_get_property(struct power_supply *bat_ps, 
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	dev_dbg(bat_ps->dev, "%s: psp = %d\n", __func__, psp);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = s3c_bat_get_charging_status();
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = s3c_get_bat_health();
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = s3c_bat_info.present;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = s3c_bat_info.bat_info.level;
+		dev_dbg(dev, "%s: level = %d\n", __func__, 
+				val->intval);
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = s3c_bat_info.bat_info.batt_temp;
+		dev_dbg(bat_ps->dev, "%s: temp = %d\n", __func__, 
+				val->intval);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int s3c_power_get_property(struct power_supply *bat_ps, 
+		enum power_supply_property psp, 
+		union power_supply_propval *val)
+{
+	charger_type_t charger;
+	
+	dev_dbg(bat_ps->dev, "%s: psp = %d\n", __func__, psp);
+
+	charger = s3c_bat_info.bat_info.charging_source;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (bat_ps->type == POWER_SUPPLY_TYPE_MAINS)
+			val->intval = (charger == CHARGER_AC ? 1 : 0);
+		else if (bat_ps->type == POWER_SUPPLY_TYPE_USB)
+			val->intval = (charger == CHARGER_USB ? 1 : 0);
+		else
+			val->intval = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+	
+	return 0;
+}
+
+#define SEC_BATTERY_ATTR(_name)								\
+{											\
+        .attr = { .name = #_name, .mode = S_IRUGO | S_IWUGO, .owner = THIS_MODULE },	\
+        .show = s3c_bat_show_property,							\
+        .store = s3c_bat_store,								\
+}
+
+static struct device_attribute s3c_battery_attrs[] = {
+        SEC_BATTERY_ATTR(batt_vol),
+        SEC_BATTERY_ATTR(batt_vol_adc),
+        SEC_BATTERY_ATTR(batt_vol_adc_cal),
+        SEC_BATTERY_ATTR(batt_temp),
+        SEC_BATTERY_ATTR(batt_temp_adc),
+        SEC_BATTERY_ATTR(batt_temp_adc_cal),
+	SEC_BATTERY_ATTR(batt_vol_adc_aver),
+#ifdef __BOARD_REV_ADC__
+        SEC_BATTERY_ATTR(board_rev_adc),
+#endif /* __BOARD_REV_ADC__ */
+#ifdef __TEST_MODE_INTERFACE__
+	/* test mode */
+	SEC_BATTERY_ATTR(batt_test_mode),
+	/* average */
+	SEC_BATTERY_ATTR(batt_vol_aver),
+	SEC_BATTERY_ATTR(batt_temp_aver),
+	SEC_BATTERY_ATTR(batt_temp_adc_aver),
+	SEC_BATTERY_ATTR(batt_v_f_adc),
+#endif /* __TEST_MODE_INTERFACE__ */
+#ifdef __CHECK_CHG_CURRENT__
+	SEC_BATTERY_ATTR(batt_chg_current),
+	SEC_BATTERY_ATTR(batt_chg_current_aver),
+#endif /* __CHECK_CHG_CURRENT__ */
+	SEC_BATTERY_ATTR(charging_source),
+#ifdef __BATTERY_COMPENSATION__
+	SEC_BATTERY_ATTR(vibrator),
+	SEC_BATTERY_ATTR(camera),
+	SEC_BATTERY_ATTR(mp3),
+	SEC_BATTERY_ATTR(video),
+	SEC_BATTERY_ATTR(talk_gsm),
+	SEC_BATTERY_ATTR(talk_wcdma),
+	SEC_BATTERY_ATTR(data_call),
+	SEC_BATTERY_ATTR(device_state),
+	SEC_BATTERY_ATTR(batt_compensation),
+	SEC_BATTERY_ATTR(is_booting),
+#endif /* __BATTERY_COMPENSATION__ */
+#ifdef __FUEL_GAUGES_IC__
+	SEC_BATTERY_ATTR(fg_soc),
+	SEC_BATTERY_ATTR(reset_soc),
+#endif /* __FUEL_GAUGES_IC__ */
+};
+
+enum {
+        BATT_VOL = 0,
+        BATT_VOL_ADC,
+        BATT_VOL_ADC_CAL,
+        BATT_TEMP,
+        BATT_TEMP_ADC,
+        BATT_TEMP_ADC_CAL,
+	BATT_VOL_ADC_AVER,
+#ifdef __BOARD_REV_ADC__
+        BOARD_REV_ADC,
+#endif /* __BOARD_REV_ADC__ */
+#ifdef __TEST_MODE_INTERFACE__
+	BATT_TEST_MODE,
+	BATT_VOL_AVER,
+	BATT_TEMP_AVER,
+	BATT_TEMP_ADC_AVER,
+	BATT_V_F_ADC,
+#endif /* __TEST_MODE_INTERFACE__ */
+#ifdef __CHECK_CHG_CURRENT__
+	BATT_CHG_CURRENT,	
+	BATT_CHG_CURRENT_AVER,	
+#endif /* __CHECK_CHG_CURRENT__ */
+	BATT_CHARGING_SOURCE,
+#ifdef __BATTERY_COMPENSATION__
+	BATT_VIBRATOR,
+	BATT_CAMERA,
+	BATT_MP3,
+	BATT_VIDEO,
+	BATT_VOICE_CALL_2G,
+	BATT_VOICE_CALL_3G,
+	BATT_DATA_CALL,
+	BATT_DEV_STATE,
+	BATT_COMPENSATION,
+	BATT_BOOTING,
+#endif /* __BATTERY_COMPENSATION__ */
+#ifdef __FUEL_GAUGES_IC__
+	BATT_FG_SOC,
+	BATT_RESET_SOC,
+#endif /* __FUEL_GAUGES_IC__ */
+};
+
+static int s3c_bat_create_attrs(struct device * dev)
+{
+        int i, rc;
+        
+        for (i = 0; i < ARRAY_SIZE(s3c_battery_attrs); i++) {
+                rc = device_create_file(dev, &s3c_battery_attrs[i]);
+                if (rc)
+                        goto s3c_attrs_failed;
+        }
+        goto succeed;
+        
+s3c_attrs_failed:
+        while (i--)
+                device_remove_file(dev, &s3c_battery_attrs[i]);
+succeed:        
+        return rc;
+}
+
+static ssize_t s3c_bat_show_property(struct device *dev,
+                                      struct device_attribute *attr,
+                                      char *buf)
+{
+        int i = 0;
+        const ptrdiff_t off = attr - s3c_battery_attrs;
+
+        switch (off) {
+        case BATT_VOL:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+                               s3c_bat_info.bat_info.batt_vol);
+                break;
+        case BATT_VOL_ADC:
+#ifndef __FUEL_GAUGES_IC__
+		s3c_bat_info.bat_info.batt_vol_adc = 
+			s3c_bat_get_adc_data(S3C_ADC_VOLTAGE);
+#else
+		s3c_bat_info.bat_info.batt_vol_adc = 0;
+#endif /* __FUEL_GAUGES_IC__ */
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+                               s3c_bat_info.bat_info.batt_vol_adc);
+                break;
+        case BATT_VOL_ADC_CAL:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+                               s3c_bat_info.bat_info.batt_vol_adc_cal);
+                break;
+        case BATT_TEMP:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+                               s3c_bat_info.bat_info.batt_temp);
+                break;
+        case BATT_TEMP_ADC:
+		s3c_bat_info.bat_info.batt_temp_adc = 
+			s3c_bat_get_adc_data(S3C_ADC_TEMPERATURE);
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+                               s3c_bat_info.bat_info.batt_temp_adc);
+                break;	
+#ifdef __TEST_MODE_INTERFACE__
+	case BATT_TEST_MODE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+		s3c_bat_info.bat_info.batt_test_mode);
+		break;
+#endif /* __TEST_MODE_INTERFACE__ */
+        case BATT_TEMP_ADC_CAL:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+                               s3c_bat_info.bat_info.batt_temp_adc_cal);
+                break;
+        case BATT_VOL_ADC_AVER:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			s3c_bat_info.bat_info.batt_vol_adc_aver);
+		break;
+#ifdef __BOARD_REV_ADC__
+        case BOARD_REV_ADC:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", board_rev_adc);
+                break;
+#endif /* __BOARD_REV_ADC__ */
+#ifdef __TEST_MODE_INTERFACE__
+	case BATT_VOL_AVER:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			s3c_bat_info.bat_info.batt_vol_aver);
+		break;
+	case BATT_TEMP_AVER:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			s3c_bat_info.bat_info.batt_temp_aver);
+		break;
+	case BATT_TEMP_ADC_AVER:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			s3c_bat_info.bat_info.batt_temp_adc_aver);
+		break;
+	case BATT_V_F_ADC:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			s3c_bat_info.bat_info.batt_v_f_adc);
+		break;
+#endif /* __TEST_MODE_INTERFACE__ */
+#ifdef __CHECK_CHG_CURRENT__
+	case BATT_CHG_CURRENT:
+		s3c_bat_info.bat_info.batt_current = 
+			s3c_bat_get_adc_data(S3C_ADC_CHG_CURRENT);
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				s3c_bat_info.bat_info.batt_current);
+		break;
+	case BATT_CHG_CURRENT_AVER:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+				adc_sample[S3C_ADC_CHG_CURRENT].average_adc);
+		break;
+
+#endif /* __CHECK_CHG_CURRENT__ */
+	case BATT_CHARGING_SOURCE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			s3c_bat_info.bat_info.charging_source);
+		break;
+#ifdef __BATTERY_COMPENSATION__
+	case BATT_DEV_STATE:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "0x%08x\n",
+			s3c_bat_info.device_state);
+		break;
+	case BATT_COMPENSATION:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			batt_compensation);
+		break;
+#endif /* __BATTERY_COMPENSATION__ */
+#ifdef __FUEL_GAUGES_IC__
+	case BATT_FG_SOC:
+		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+			fg_read_soc());
+		break;
+#endif /* __FUEL_GAUGES_IC__ */
+        default:
+                i = -EINVAL;
+        }       
+        
+        return i;
+}
+
+static void s3c_bat_set_vol_cal(int batt_cal)
+{
+	int max_cal = 4096;
+#ifdef __9BITS_RESOLUTION__
+	max_cal = 512;
+#endif /* __9BITS_RESOLUTION__ */
+
+	if (!batt_cal)
+		return;
+
+	if (batt_cal >= max_cal) {
+		dev_err(dev, "%s: invalid battery_cal(%d)\n", __func__, batt_cal);
+		return;
+	}
+
+	batt_max = batt_cal + BATT_MAXIMUM;
+	batt_full = batt_cal + BATT_FULL;
+	batt_safe_rech = batt_cal + BATT_SAFE_RECHARGE;
+	batt_almost = batt_cal + BATT_ALMOST_FULL;
+	batt_high = batt_cal + BATT_HIGH;
+	batt_medium = batt_cal + BATT_MED;
+	batt_low = batt_cal + BATT_LOW;
+	batt_critical = batt_cal + BATT_CRITICAL;
+	batt_min = batt_cal + BATT_MINIMUM;
+	batt_off = batt_cal + BATT_OFF;
+}
+
+#ifdef COMPENSATE_BOOTING
+static void s3c_bat_compensate_booting(int mode)
+{
+	if (mode)
+		s3c_bat_set_compesation(1, OFFSET_BOOTING, COMPENSATE_BOOTING);
+	else
+		queue_work(batt_drv_wqueue, &compensate_boot_work);
+}
+#endif /* COMPENSATE_BOOTING */
+
+static ssize_t s3c_bat_store(struct device *dev, 
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int x = 0;
+	int ret = 0;
+	const ptrdiff_t off = attr - s3c_battery_attrs;
+
+        switch (off) {
+        case BATT_VOL_ADC_CAL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			s3c_bat_info.bat_info.batt_vol_adc_cal = x;
+			s3c_bat_set_vol_cal(x);
+			ret = count;
+		}
+		dev_info(dev, "%s: batt_vol_adc_cal = %d\n", __func__, x);
+                break;
+        case BATT_TEMP_ADC_CAL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			s3c_bat_info.bat_info.batt_temp_adc_cal = x;
+			ret = count;
+		}
+		dev_info(dev, "%s: batt_temp_adc_cal = %d\n", __func__, x);
+                break;
+#ifdef __TEST_MODE_INTERFACE__
+	case BATT_TEST_MODE:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			s3c_bat_info.bat_info.batt_test_mode = x;
+			ret = count;
+		}
+		if (s3c_bat_info.bat_info.batt_test_mode) {
+			s3c_bat_info.polling_interval = POLLING_INTERVAL_TEST;			
+			if (s3c_bat_info.polling) {
+				del_timer_sync(&polling_timer);
+				mod_timer(&polling_timer, jiffies + 
+					msecs_to_jiffies(s3c_bat_info.polling_interval));
+			}
+			s3c_bat_status_update(
+				&s3c_power_supplies_test[CHARGER_BATTERY]);
+		} else {
+			s3c_bat_info.polling_interval = POLLING_INTERVAL;		
+			if (s3c_bat_info.polling) {
+				del_timer_sync(&polling_timer);
+				mod_timer(&polling_timer,jiffies + 
+					msecs_to_jiffies(s3c_bat_info.polling_interval));
+			}
+			s3c_bat_status_update(
+				&s3c_power_supplies_test[CHARGER_BATTERY]);
+		}
+		dev_info(dev, "%s: batt_test_mode = %d\n", __func__, x);
+		break;
+#endif /* __TEST_MODE_INTERFACE__ */
+#ifdef __BATTERY_COMPENSATION__
+	case BATT_VIBRATOR:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			s3c_bat_set_compesation(x, OFFSET_VIBRATOR_ON,
+					COMPENSATE_VIBRATOR);
+			ret = count;
+		}
+		dev_info(dev, "%s: vibrator = %d\n", __func__, x);
+                break;
+	case BATT_CAMERA:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			s3c_bat_set_compesation(x, OFFSET_CAMERA_ON,
+					COMPENSATE_CAMERA);
+			ret = count;
+		}
+		dev_info(dev, "%s: camera = %d\n", __func__, x);
+                break;
+	case BATT_MP3:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			s3c_bat_set_compesation(x, OFFSET_MP3_PLAY,
+					COMPENSATE_MP3);
+			ret = count;
+		}
+		dev_info(dev, "%s: mp3 = %d\n", __func__, x);
+                break;
+	case BATT_VIDEO:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			s3c_bat_set_compesation(x, OFFSET_VIDEO_PLAY,
+					COMPENSATE_VIDEO);
+			ret = count;
+		}
+		dev_info(dev, "%s: video = %d\n", __func__, x);
+                break;
+	case BATT_VOICE_CALL_2G:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			s3c_bat_set_compesation(x, OFFSET_VOICE_CALL_2G,
+					COMPENSATE_VOICE_CALL_2G);
+			ret = count;
+		}
+		dev_info(dev, "%s: voice call 2G = %d\n", __func__, x);
+                break;
+	case BATT_VOICE_CALL_3G:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			s3c_bat_set_compesation(x, OFFSET_VOICE_CALL_3G,
+					COMPENSATE_VOICE_CALL_3G);
+			ret = count;
+		}
+		dev_info(dev, "%s: voice call 3G = %d\n", __func__, x);
+                break;
+	case BATT_DATA_CALL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			s3c_bat_set_compesation(x, OFFSET_DATA_CALL,
+					COMPENSATE_DATA_CALL);
+			ret = count;
+		}
+		dev_info(dev, "%s: data call = %d\n", __func__, x);
+                break;
+#ifdef COMPENSATE_BOOTING
+	case BATT_BOOTING:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			s3c_bat_compensate_booting(x);
+			ret = count;
+		}
+		dev_info(dev, "%s: boot complete = %d\n", __func__, x);
+                break;
+#endif /* COMPENSATE_BOOTING */
+#endif /* __BATTERY_COMPENSATION__ */
+#ifdef __FUEL_GAUGES_IC__
+	case BATT_RESET_SOC:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			if (x == 1)
+				fg_reset_soc();
+			ret = count;
+		}
+		dev_info(dev, "%s: Reset SOC:%d\n", __func__, x);
+		break;
+#endif /* __FUEL_GAUGES_IC__ */
+        default:
+                ret = -EINVAL;
+        }       
+
+	return ret;
+}
+
+#ifdef __BATTERY_COMPENSATION__
+void s3c_bat_set_compensation_for_drv(int mode, int offset)
+{
+	switch(offset) {
+	case OFFSET_VIBRATOR_ON:
+		dev_dbg(dev, "%s: vibrator = %d\n", __func__, mode);
+		s3c_bat_set_compesation(mode, offset, COMPENSATE_VIBRATOR);
+		break;
+	case OFFSET_LCD_ON:
+		dev_info(dev, "%s: LCD On = %d\n", __func__, mode);
+		s3c_bat_set_compesation(mode, offset, COMPENSATE_LCD);
+		break;
+	case OFFSET_CAM_FLASH:
+		dev_info(dev, "%s: flash = %d\n", __func__, mode);
+		s3c_bat_set_compesation(mode, offset, COMPENSATE_CAM_FALSH);
+		break;
+	default:
+		break;
+	}
+
+}
+EXPORT_SYMBOL(s3c_bat_set_compensation_for_drv);
+#endif /* __BATTERY_COMPENSATION__ */
+
+#ifdef __TEST_DEVICE_DRIVER__
+#define SEC_TEST_ATTR(_name)								\
+{											\
+        .attr = { .name = #_name, .mode = S_IRUGO | S_IWUGO, .owner = THIS_MODULE },	\
+        .show = s3c_test_show_property,							\
+        .store = s3c_test_store,							\
+}
+
+static struct device_attribute s3c_test_attrs[] = {
+        SEC_TEST_ATTR(pm),
+        SEC_TEST_ATTR(usb),
+        SEC_TEST_ATTR(bt_wl),
+        SEC_TEST_ATTR(tflash),
+        SEC_TEST_ATTR(audio),
+        SEC_TEST_ATTR(lcd),
+        SEC_TEST_ATTR(suspend_lock),
+        SEC_TEST_ATTR(control_tmp),
+};
+
+enum {
+        TEST_PM = 0,
+	USB_OFF,
+	BT_WL_OFF,
+	TFLASH_OFF,
+	AUDIO_OFF,
+	LCD_CHECK,
+	SUSPEND_LOCK,
+	CTRL_TMP,
+};
+
+static int s3c_test_create_attrs(struct device * dev)
+{
+        int i, rc;
+        
+        for (i = 0; i < ARRAY_SIZE(s3c_test_attrs); i++) {
+                rc = device_create_file(dev, &s3c_test_attrs[i]);
+                if (rc)
+                        goto s3c_attrs_failed;
+        }
+        goto succeed;
+        
+s3c_attrs_failed:
+        while (i--)
+                device_remove_file(dev, &s3c_test_attrs[i]);
+succeed:        
+        return rc;
+}
+
+static void s3c_lcd_check(void)
+{
+	unsigned char reg_buff = 0;
+	if (Get_MAX8698_PM_REG(ELDO6, &reg_buff)) {
+		pr_info("%s: VLCD 1.8V (%d)\n", __func__, reg_buff);
+	}
+	if ((Get_MAX8698_PM_REG(ELDO7, &reg_buff))) {
+		pr_info("%s: VLCD 2.8V (%d)\n", __func__, reg_buff);
+	}
+}
+
+static void s3c_usb_off(void)
+{
+	unsigned char reg_buff = 0;
+	if (Get_MAX8698_PM_REG(ELDO3, &reg_buff)) {
+		pr_info("%s: OTGI 1.2V off(%d)\n", __func__, reg_buff);
+		if (reg_buff)
+			Set_MAX8698_PM_REG(ELDO3, 0);
+	}
+	if ((Get_MAX8698_PM_REG(ELDO8, &reg_buff))) {
+		pr_info("%s: OTG 3.3V off(%d)\n", __func__, reg_buff);
+		if (reg_buff)
+			Set_MAX8698_PM_REG(ELDO8, 0);
+	}
+}
+
+static void s3c_bt_wl_off(void)
+{
+	unsigned char reg_buff = 0;
+	if (Get_MAX8698_PM_REG(ELDO4, &reg_buff)) {
+		pr_info("%s: BT_WL 2.6V off(%d)\n", __func__, reg_buff);
+		if (reg_buff)
+			Set_MAX8698_PM_REG(ELDO4, 0);
+	}
+}
+
+static void s3c_tflash_off(void)
+{
+	unsigned char reg_buff = 0;
+	if (Get_MAX8698_PM_REG(ELDO5, &reg_buff)) {
+		pr_info("%s: TF 3.0V off(%d)\n", __func__, reg_buff);
+		if (reg_buff)
+			Set_MAX8698_PM_REG(ELDO5, 0);
+	}
+}
+
+static void s3c_audio_off(void)
+{
+	pr_info("%s: Turn off audio power, amp\n", __func__);
+	amp_enable(0);
+	audio_power(0);
+}
+
+static void s3c_test_pm(void)
+{
+	/* PMIC */
+	s3c_usb_off();
+	s3c_bt_wl_off();
+	s3c_tflash_off();
+	s3c_lcd_check();
+
+	/* AUDIO */
+	s3c_audio_off();
+
+	/* GPIO */
+}
+
+static ssize_t s3c_test_show_property(struct device *dev,
+                                      struct device_attribute *attr,
+                                      char *buf)
+{
+        int i = 0;
+        const ptrdiff_t off = attr - s3c_test_attrs;
+
+        switch (off) {
+        case TEST_PM:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", 0);
+		s3c_test_pm();
+                break;
+        case USB_OFF:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", 1);
+		s3c_usb_off();
+                break;
+        case BT_WL_OFF:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", 2);
+		s3c_bt_wl_off();
+                break;
+        case TFLASH_OFF:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", 3);
+		s3c_tflash_off();
+                break;
+        case AUDIO_OFF:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", 4);
+		s3c_audio_off();
+                break;
+        case LCD_CHECK:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n", 5);
+		s3c_lcd_check();
+                break;
+        default:
+                i = -EINVAL;
+        }       
+        
+        return i;
+}
+
+static ssize_t s3c_test_store(struct device *dev, 
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int mode = 0;
+	int ret = 0;
+	const ptrdiff_t off = attr - s3c_test_attrs;
+
+        switch (off) {
+        case SUSPEND_LOCK:
+		if (sscanf(buf, "%d\n", &mode) == 1) {
+			dev_dbg(dev, "%s: suspend_lock(%d)\n", __func__, mode);
+			if (mode) 
+                		wake_lock(&wake_lock_for_dev);
+			else
+                		wake_lock_timeout(
+						&wake_lock_for_dev, HZ / 2);
+			ret = count;
+		}
+                break;
+	case CTRL_TMP:
+		if (sscanf(buf, "%d\n", &mode) == 1) {
+			dev_info(dev, "%s: control tmp(%d)\n", __func__, mode);
+			bat_temper_state = mode;
+			ret = count;
+		}
+		break;
+        default:
+                ret = -EINVAL;
+        }       
+
+	return ret;
+}
+#endif /* __TEST_DEVICE_DRIVER__ */
+
+static enum power_supply_property s3c_battery_properties[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CAPACITY,
+};
+
+static enum power_supply_property s3c_power_properties[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static char *supply_list[] = {
+	"battery",
+};
+
+static struct power_supply s3c_power_supplies[] = {
+	{
+		.name = "battery",
+		.type = POWER_SUPPLY_TYPE_BATTERY,
+		.properties = s3c_battery_properties,
+		.num_properties = ARRAY_SIZE(s3c_battery_properties),
+		.get_property = s3c_bat_get_property,
+	},
+	{
+		.name = "usb",
+		.type = POWER_SUPPLY_TYPE_USB,
+		.supplied_to = supply_list,
+		.num_supplicants = ARRAY_SIZE(supply_list),
+		.properties = s3c_power_properties,
+		.num_properties = ARRAY_SIZE(s3c_power_properties),
+		.get_property = s3c_power_get_property,
+	},
+	{
+		.name = "ac",
+		.type = POWER_SUPPLY_TYPE_MAINS,
+		.supplied_to = supply_list,
+		.num_supplicants = ARRAY_SIZE(supply_list),
+		.properties = s3c_power_properties,
+		.num_properties = ARRAY_SIZE(s3c_power_properties),
+		.get_property = s3c_power_get_property,
+	},
+};
+
+static int s3c_cable_status_update(int status)
+{
+	int ret = 0;
+	charger_type_t source = CHARGER_BATTERY;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	if(!s3c_battery_initial)
+		return -EPERM;
+
+	switch(status) {
+	case CHARGER_BATTERY:
+		dev_dbg(dev, "%s: cable NOT PRESENT\n", __func__);
+		s3c_bat_info.bat_info.charging_source = CHARGER_BATTERY;
+		break;
+	case CHARGER_USB:
+		dev_dbg(dev, "%s: cable USB\n", __func__);
+		s3c_bat_info.bat_info.charging_source = CHARGER_USB;
+		break;
+	case CHARGER_AC:
+		dev_dbg(dev, "%s: cable AC\n", __func__);
+		s3c_bat_info.bat_info.charging_source = CHARGER_AC;
+		break;
+#if 0
+	case CHARGER_DISCHARGE:
+		dev_dbg(dev, "%s: Discharge\n", __func__);
+		s3c_bat_info.bat_info.charging_source = CHARGER_DISCHARGE;
+		break;
+#endif
+	default:
+		dev_err(dev, "%s: Nat supported status(%d)\n", __func__, status);
+		ret = -EINVAL;
+	}
+	source = s3c_bat_info.bat_info.charging_source;
+
+        if (source == CHARGER_USB || source == CHARGER_AC) {
+                wake_lock(&vbus_wake_lock);
+        } else {
+                /* give userspace some time to see the uevent and update
+                 * LED state or whatnot...
+                 */
+		if (gpio_get_value(gpio_ta_connected)) 
+			wake_lock_timeout(&vbus_wake_lock, HZ / 2);
+        }
+        /* if the power source changes, all power supplies may change state */
+        power_supply_changed(&s3c_power_supplies[CHARGER_BATTERY]);
+	/*
+        power_supply_changed(&s3c_power_supplies[CHARGER_USB]);
+        power_supply_changed(&s3c_power_supplies[CHARGER_AC]);
+	*/
+	dev_dbg(dev, "%s: call power_supply_changed\n", __func__);
+	return ret;
+}
+
+#ifdef __CHECK_BATTERY_V_F__
+static unsigned int s3c_bat_check_v_f(void)
+{
+	unsigned int rc = 0;
+	int adc = 0;
+	
+	adc = s3c_bat_get_adc_data(S3C_ADC_V_F);
+
+	dev_dbg(dev, "%s: V_F ADC = %d\n", __func__, adc);
+
+	if (adc <= BATT_VF_MAX && adc >= BATT_VF_MIN) {
+		/* s3c_set_bat_health(POWER_SUPPLY_HEALTH_GOOD); */
+		rc = 1;
+	} else {
+		dev_info(dev, "%s: Unauthorized battery!\n", __func__);
+		s3c_set_bat_health(POWER_SUPPLY_HEALTH_UNSPEC_FAILURE);
+		s3c_set_chg_en(DISABLE);
+		force_update = 1;
+		rc = 0;
+	}
+	return rc;
+}
+#endif /* __CHECK_BATTERY_V_F__ */
+
+static void s3c_bat_status_update(struct power_supply *bat_ps)
+{
+	int old_level, old_temp, old_is_full;
+	dev_dbg(dev, "%s ++\n", __func__);
+
+	if(!s3c_battery_initial)
+		return;
+
+	mutex_lock(&work_lock);
+	old_temp = s3c_bat_info.bat_info.batt_temp;
+	old_level = s3c_bat_info.bat_info.level; 
+	old_is_full = s3c_bat_info.bat_info.batt_is_full;
+	s3c_bat_info.bat_info.batt_temp = s3c_get_bat_temp(bat_ps);
+
+	s3c_bat_info.bat_info.level = s3c_get_bat_level(bat_ps);
+	if (!s3c_bat_info.bat_info.charging_enabled &&
+			!s3c_bat_info.bat_info.batt_is_full) {
+		if (s3c_bat_info.bat_info.level > old_level)
+			s3c_bat_info.bat_info.level = old_level;
+	}
+	s3c_bat_info.bat_info.batt_vol = s3c_get_bat_vol(bat_ps);
+
+#ifdef __BOARD_REV_ADC__
+	if (!is_end_board_rev_adc)
+		s3c_get_board_rev_adc(bat_ps);
+#endif /* __BOARD_REV_ADC__ */
+
+#if (defined __TEST_MODE_INTERFACE__ && defined __BATTERY_V_F__)
+	if (s3c_bat_info.bat_info.batt_test_mode == 1)
+		s3c_get_v_f_adc();
+#endif /* __TEST_MODE_INTERFACE__ && __BATTERY_V_F__ */
+
+#ifdef __CHECK_BATTERY_V_F__
+	if(s3c_bat_info.bat_info.charging_enabled &&
+		s3c_get_bat_health() != POWER_SUPPLY_HEALTH_UNSPEC_FAILURE)
+		s3c_bat_check_v_f();
+#endif /* __CHECK_BATTERY_V_F__ */
+
+	if (old_level != s3c_bat_info.bat_info.level 
+			|| old_temp != s3c_bat_info.bat_info.batt_temp
+			|| old_is_full != s3c_bat_info.bat_info.batt_is_full
+			|| force_update) {
+		force_update = 0;
+		power_supply_changed(bat_ps);
+		dev_dbg(dev, "%s: call power_supply_changed\n", __func__);
+	}
+
+	mutex_unlock(&work_lock);
+	dev_dbg(dev, "%s --\n", __func__);
+}
+
+static void s3c_cable_check_status(void)
+{
+	charger_type_t status = 0;
+
+	mutex_lock(&work_lock);
+
+	if (!gpio_get_value(gpio_ta_connected)) {
+		if (get_usb_power_state())
+			status = CHARGER_USB;
+		else
+			status = CHARGER_AC;
+
+		if (s3c_get_bat_health() != POWER_SUPPLY_HEALTH_GOOD) {
+			dev_info(dev, "%s: Unhealth battery state!\n", __func__);
+			s3c_set_chg_en(DISABLE);
+		} else 
+			s3c_set_chg_en(ENABLE);
+
+		dev_dbg(dev, "%s: status : %s\n", __func__, 
+				(status == CHARGER_USB) ? "USB" : "AC");
+	} else {
+		u32 health = s3c_get_bat_health();
+
+		status = CHARGER_BATTERY;
+		s3c_set_chg_en(DISABLE);
+
+		if (health == POWER_SUPPLY_HEALTH_OVERHEAT ||
+				health == POWER_SUPPLY_HEALTH_COLD) {
+			s3c_set_bat_health(POWER_SUPPLY_HEALTH_GOOD);
+		}
+	}
+	dev_dbg(dev, "%s: gpio_chg_en %s\n", __func__, 
+			gpio_get_value_ex(gpio_chg_en)?"disabled":"enabled");
+
+	s3c_cable_status_update(status);
+	mutex_unlock(&work_lock);
+}
+
+static void s3c_bat_work(struct work_struct *work)
+{
+#ifdef __ADJUST_RECHARGE_ADC__
+	static int pre_rechar = 0;
+	static int cnt = 0;
+	if (s3c_bat_info.bat_info.batt_is_full == 1 && full_charge_flag == 1) {
+		batt_recharging = -1;
+		pre_rechar = 1;
+		full_charge_flag = 0;
+	}
+
+	if (pre_rechar) {
+		if (++cnt > 10) {
+			int adc = s3c_bat_get_adc_data(S3C_ADC_VOLTAGE);
+			batt_recharging = adc - BATT_RECHARGE_CODE;
+			dev_info(dev, "%s: batt_recharging=%d\n", __func__,
+					batt_recharging);
+			pre_rechar = 0;
+			cnt = 0;
+		}
+	}
+#endif /* __ADJUST_RECHARGE_ADC__ */
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	s3c_bat_status_update(
+			&s3c_power_supplies[CHARGER_BATTERY]);
+}
+
+static void s3c_cable_work(struct work_struct *work)
+{
+	dev_dbg(dev, "%s\n", __func__);
+	s3c_cable_check_status();
+}
+
+#ifdef COMPENSATE_BOOTING
+static void s3c_compensate_boot_work(struct work_struct *work)
+{
+	dev_info(dev, "%s ++\n", __func__);
+	msleep(50000); /* 50sec */
+	s3c_bat_set_compesation(0, OFFSET_BOOTING, COMPENSATE_BOOTING);
+	dev_info(dev, "%s --\n", __func__);
+}
+#endif /* COMPENSATE_BOOTING */
+
+#ifdef CONFIG_PM
+static int s3c_bat_suspend(struct platform_device *pdev, 
+		pm_message_t state)
+{
+	dev_info(dev, "%s\n", __func__);
+
+	if (s3c_bat_info.polling)
+		del_timer_sync(&polling_timer);
+
+	flush_scheduled_work();
+	disable_irq(IRQ_TA_CONNECTED_N);
+	disable_irq(IRQ_TA_CHG_N);
+	return 0;
+}
+
+static int s3c_bat_resume(struct platform_device *pdev)
+{
+	dev_info(dev, "%s\n", __func__);
+	wake_lock(&vbus_wake_lock);
+	enable_irq(IRQ_TA_CONNECTED_N);
+	enable_irq(IRQ_TA_CHG_N);
+	schedule_work(&bat_work);
+	schedule_work(&cable_work);
+
+	if (s3c_bat_info.polling)
+		mod_timer(&polling_timer,
+			  jiffies + msecs_to_jiffies(s3c_bat_info.polling_interval));
+	return 0;
+}
+#else
+#define s3c_bat_suspend NULL
+#define s3c_bat_resume NULL
+#endif /* CONFIG_PM */
+
+static void polling_timer_func(unsigned long unused)
+{
+	dev_dbg(dev, "%s\n", __func__);
+	schedule_work(&bat_work);
+
+	mod_timer(&polling_timer,
+		  jiffies + msecs_to_jiffies(s3c_bat_info.polling_interval));
+}
+
+static void cable_timer_func(unsigned long unused)
+{
+	dev_info(dev, "%s : intr cnt = %d\n", __func__, cable_intr_cnt);
+	cable_intr_cnt = 0;
+	schedule_work(&cable_work);
+}
+
+static irqreturn_t s3c_cable_changed_isr(int irq, void *power_supply)
+{
+	dev_dbg(dev, "%s: irq=0x%x, gpio_ta_connected=%x\n", __func__, irq,
+			gpio_get_value(gpio_ta_connected));
+
+	if (!s3c_battery_initial)
+		return IRQ_HANDLED;
+
+	s3c_bat_info.bat_info.batt_is_full = 0;
+#ifdef __ADJUST_RECHARGE_ADC__
+	batt_recharging = -1;
+#endif /* __ADJUST_RECHARGE_ADC__ */
+#ifdef __CHECK_CHG_CURRENT__
+	clear_adc_sample(S3C_ADC_CHG_CURRENT);
+#endif /* __CHECK_CHG_CURRENT__ */
+
+	cable_intr_cnt++;
+	if (timer_pending(&cable_timer))
+		del_timer(&cable_timer);
+
+	cable_timer.expires = jiffies + msecs_to_jiffies(50);
+	add_timer(&cable_timer);
+
+	/*
+	 * Wait a bit before reading ac/usb line status and setting charger,
+	 * because ac/usb status readings may lag from irq.
+	 */
+	if (s3c_bat_info.polling)
+		mod_timer(&polling_timer,
+			  jiffies + msecs_to_jiffies(s3c_bat_info.polling_interval));
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t s3c_cable_charging_isr(int irq, void *power_supply)
+{
+	int chg_ing = gpio_get_value(gpio_chg_ing);
+	dev_dbg(dev, "%s: irq=0x%x, gpio_chg_ing=%d\n", __func__, irq, chg_ing);
+
+	if (!s3c_battery_initial)
+		return IRQ_HANDLED;
+#ifndef __DISABLE_CHG_ING_INTR__
+	if (chg_ing && !gpio_get_value(gpio_ta_connected) &&
+			s3c_bat_info.bat_info.charging_enabled &&
+			s3c_get_bat_health() == POWER_SUPPLY_HEALTH_GOOD) {
+		s3c_set_chg_en(DISABLE);
+		s3c_bat_info.bat_info.batt_is_full = 1;
+		force_update = 1;
+		full_charge_flag = 1;
+	}
+
+	schedule_work(&bat_work);
+	/*
+	 * Wait a bit before reading ac/usb line status and setting charger,
+	 * because ac/usb status readings may lag from irq.
+	 */
+	if (s3c_bat_info.polling)
+		mod_timer(&polling_timer,
+			  jiffies + msecs_to_jiffies(s3c_bat_info.polling_interval));
+#endif /* __DISABLE_CHG_ING_INTR__ */
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit s3c_bat_probe(struct platform_device *pdev)
+{
+	int i;
+	int ret = 0;
+
+	dev = &pdev->dev;
+	dev_info(dev, "%s\n", __func__);
+
+	s3c_bat_info.present = 1;
+	s3c_bat_info.polling = 1;
+	s3c_bat_info.polling_interval = POLLING_INTERVAL;
+	s3c_bat_info.device_state = 0;
+
+	s3c_bat_info.bat_info.batt_vol_adc_aver = 0;
+#ifdef __TEST_MODE_INTERFACE__
+	s3c_bat_info.bat_info.batt_vol_aver = 0;
+	s3c_bat_info.bat_info.batt_temp_aver = 0;
+	s3c_bat_info.bat_info.batt_temp_adc_aver = 0;
+	s3c_bat_info.bat_info.batt_v_f_adc = 0;
+
+	s3c_bat_info.bat_info.batt_test_mode = 0;
+ 	s3c_power_supplies_test = s3c_power_supplies;
+#endif /* __TEST_MODE_INTERFACE__ */
+	s3c_bat_info.bat_info.batt_id = 0;
+	s3c_bat_info.bat_info.batt_vol = 0;
+	s3c_bat_info.bat_info.batt_vol_adc = 0;
+	s3c_bat_info.bat_info.batt_vol_adc_cal = 0;
+	s3c_bat_info.bat_info.batt_temp = 0;
+	s3c_bat_info.bat_info.batt_temp_adc = 0;
+	s3c_bat_info.bat_info.batt_temp_adc_cal = 0;
+	s3c_bat_info.bat_info.batt_current = 0;
+	s3c_bat_info.bat_info.level = 100;
+	s3c_bat_info.bat_info.charging_source = CHARGER_BATTERY;
+	s3c_bat_info.bat_info.charging_enabled = 0;
+	s3c_bat_info.bat_info.batt_health = POWER_SUPPLY_HEALTH_GOOD;
+
+	memset(adc_sample, 0x00, sizeof adc_sample);
+
+	batt_max = BATT_CAL + BATT_MAXIMUM;
+	batt_full = BATT_CAL + BATT_FULL;
+	batt_safe_rech = BATT_CAL + BATT_SAFE_RECHARGE;
+	batt_almost = BATT_CAL + BATT_ALMOST_FULL;
+	batt_high = BATT_CAL + BATT_HIGH;
+	batt_medium = BATT_CAL + BATT_MED;
+	batt_low = BATT_CAL + BATT_LOW;
+	batt_critical = BATT_CAL + BATT_CRITICAL;
+	batt_min = BATT_CAL + BATT_MINIMUM;
+	batt_off = BATT_CAL + BATT_OFF;
+#ifdef __ADJUST_RECHARGE_ADC__
+	batt_recharging = -1;
+#endif /* __ADJUST_RECHARGE_ADC__ */
+
+#ifdef __BATTERY_COMPENSATION__
+	batt_compensation = 0;
+#ifdef COMPENSATE_BOOTING
+	s3c_bat_set_compesation(1, OFFSET_BOOTING, COMPENSATE_BOOTING);
+	s3c_bat_set_compesation(1, OFFSET_LCD_ON, COMPENSATE_LCD);
+#endif /* COMPENSATE_BOOTING */
+#endif /* __BATTERY_COMPENSATION__ */
+
+	INIT_WORK(&bat_work, s3c_bat_work);
+	INIT_WORK(&cable_work, s3c_cable_work);
+
+#ifdef COMPENSATE_BOOTING
+	INIT_WORK(&compensate_boot_work, s3c_compensate_boot_work);
+	batt_drv_wqueue = create_singlethread_workqueue("batt_drv_workqueue");
+#endif /* COMPENSATE_BOOTING */
+
+#ifdef __ALWAYS_AWAKE_DEVICE__
+	dev_info(dev, "%s: always awake(wake_lock)\n", __func__);
+	wake_lock(&wake_lock_for_dev);
+#endif /* __ALWAYS_AWAKE_DEVICE__ */
+
+	/* init power supplier framework */
+	for (i = 0; i < ARRAY_SIZE(s3c_power_supplies); i++) {
+		ret = power_supply_register(&pdev->dev, 
+				&s3c_power_supplies[i]);
+		if (ret) {
+			dev_err(dev, "Failed to register"
+					"power supply %d,%d\n", i, ret);
+			goto __end__;
+		}
+	}
+
+	/* create sec detail attributes */
+	s3c_bat_create_attrs(s3c_power_supplies[CHARGER_BATTERY].dev);
+
+#ifdef __TEST_DEVICE_DRIVER__
+	s3c_test_create_attrs(s3c_power_supplies[CHARGER_AC].dev);
+#endif /* __TEST_DEVICE_DRIVER__ */
+
+	/* Request IRQ */ 
+	set_irq_type(IRQ_TA_CONNECTED_N, IRQ_TYPE_EDGE_BOTH);
+	ret = request_irq(IRQ_TA_CONNECTED_N, s3c_cable_changed_isr,
+			  IRQF_DISABLED,
+			  DRIVER_NAME,
+			  &s3c_power_supplies[CHARGER_BATTERY]);
+	if(ret)
+		goto __end__;
+
+	set_irq_type(IRQ_TA_CHG_N, IRQ_TYPE_EDGE_BOTH);
+	ret = request_irq(IRQ_TA_CHG_N, s3c_cable_charging_isr,
+			  IRQF_DISABLED,
+			  DRIVER_NAME,
+			  &s3c_power_supplies[CHARGER_BATTERY]);
+
+	if (ret)
+		goto __ta_connected_irq_failed__;
+
+	if (s3c_bat_info.polling) {
+		dev_dbg(dev, "%s: will poll for status\n", 
+				__func__);
+		setup_timer(&polling_timer, polling_timer_func, 0);
+		mod_timer(&polling_timer,
+			  jiffies + msecs_to_jiffies(s3c_bat_info.polling_interval));
+	}
+
+	setup_timer(&cable_timer, cable_timer_func, 0);
+
+	s3c_battery_initial = 1;
+	force_update = 0;
+	full_charge_flag = 0;
+
+	s3c_bat_status_update(
+			&s3c_power_supplies[CHARGER_BATTERY]);
+
+#ifdef __CHECK_BATTERY_V_F__
+#ifdef __CHECK_BOARD_REV__
+	if (system_rev >= rev_to_check)
+#endif /* __CHECK_BOARD_REV__ */
+		s3c_bat_check_v_f();
+#endif /* __CHECK_BATTERY_V_F__ */
+	s3c_cable_check_status();
+__end__:
+	return ret;
+__ta_connected_irq_failed__:
+	free_irq(IRQ_TA_CONNECTED_N, 
+			&s3c_power_supplies[CHARGER_BATTERY]);
+	return ret;
+}
+
+static int __devexit s3c_bat_remove(struct platform_device *pdev)
+{
+	int i;
+	dev_info(dev, "%s\n", __func__);
+
+	if (s3c_bat_info.polling)
+		del_timer_sync(&polling_timer);
+
+	free_irq(IRQ_TA_CONNECTED_N, 
+			&s3c_power_supplies[CHARGER_BATTERY]);
+	free_irq(IRQ_TA_CHG_N, &s3c_power_supplies[CHARGER_BATTERY]);
+
+	for (i = 0; i < ARRAY_SIZE(s3c_power_supplies); i++) {
+		power_supply_unregister(&s3c_power_supplies[i]);
+	}
+ 
+	return 0;
+}
+
+static struct platform_driver s3c_bat_driver = {
+	.driver.name	= DRIVER_NAME,
+	.driver.owner	= THIS_MODULE,
+	.probe		= s3c_bat_probe,
+	.remove		= __devexit_p(s3c_bat_remove),
+	.suspend	= s3c_bat_suspend,
+	.resume		= s3c_bat_resume,
+};
+
+/* Initailize GPIO */
+static void s3c_bat_init_hw(void)
+{
+	s3c_gpio_cfgpin(gpio_ta_connected, 
+			S3C_GPIO_SFN(gpio_ta_connected_af));
+	s3c_gpio_setpull(gpio_ta_connected, S3C_GPIO_PULL_UP);
+
+	s3c_gpio_cfgpin(gpio_chg_ing, 
+			S3C_GPIO_SFN(gpio_chg_ing_af));
+	s3c_gpio_setpull(gpio_chg_ing, S3C_GPIO_PULL_UP);
+#ifndef __USE_EGPIO__
+	s3c_gpio_cfgpin(gpio_chg_en, 
+			S3C_GPIO_SFN(gpio_chg_en_af));
+	s3c_gpio_setpull(gpio_chg_en, S3C_GPIO_PULL_NONE); 
+#endif /* __USE_EGPIO__ */
+	gpio_set_value_ex(gpio_chg_en, GPIO_LEVEL_HIGH);
+}
+
+static int __init s3c_bat_init(void)
+{
+	pr_info("%s\n", __func__);
+	s3c_bat_init_hw();
+
+	wake_lock_init(&vbus_wake_lock, WAKE_LOCK_SUSPEND, "vbus_present");
+#if (defined __TEST_DEVICE_DRIVER__  || defined __ALWAYS_AWAKE_DEVICE__)
+	wake_lock_init(&wake_lock_for_dev, WAKE_LOCK_SUSPEND, "wake_lock_dev");
+#endif /* __TEST_DEVICE_DRIVER__ || __ALWAYS_AWAKE_DEVICE__ */
+
+#ifdef __FUEL_GAUGES_IC__
+	if (i2c_add_driver(&fg_i2c_driver))
+		pr_err("%s: Can't add fg i2c drv\n", __func__);
+#endif /* __FUEL_GAUGES_IC__ */
+	return platform_driver_register(&s3c_bat_driver);
+}
+
+static void __exit s3c_bat_exit(void)
+{
+	pr_info("%s\n", __func__);
+#ifdef __FUEL_GAUGES_IC__
+	i2c_del_driver(&fg_i2c_driver);
+#endif /* __FUEL_GAUGES_IC__ */
+	platform_driver_unregister(&s3c_bat_driver);
+}
+
+module_init(s3c_bat_init);
+module_exit(s3c_bat_exit);
+
+MODULE_AUTHOR("Minsung Kim <ms925.kim@samsung.com>");
+MODULE_DESCRIPTION("S3C6410 battery driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/power/s3c6410_battery.h linux-2.6.29-spica/drivers/power/s3c6410_battery.h
--- linux-2.6.29/drivers/power/s3c6410_battery.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/power/s3c6410_battery.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,173 @@
+/*
+ * linux/drivers/power/s3c6410_battery.h
+ *
+ * Battery measurement code for S3C6410 platform.
+ *
+ * Copyright (C) 2009 Samsung Electronics.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#define DRIVER_NAME	"spica-battery"
+
+/*
+ * Spica Rev00 board Battery Table
+ */
+#define BATT_CAL		2447	/* 3.60V */
+
+#define BATT_MAXIMUM		406	/* 4.176V */
+#define BATT_FULL		353	/* 4.10V  */
+#define BATT_SAFE_RECHARGE 353	/* 4.10V */
+#define BATT_ALMOST_FULL	188 /* 3.8641V */	//322	/* 4.066V */
+#define BATT_HIGH		112 /* 3.7554V */ 		//221	/* 3.919V */
+#define BATT_MED		66 /* 3.6907V */ 		//146	/* 3.811V */
+#define BATT_LOW		43 /* 3.6566V */		//112	/* 3.763V */
+#define BATT_CRITICAL		8 /* 3.6037V */ 	//(74)	/* 3.707V */
+#define BATT_MINIMUM		(-28) /* 3.554V */	//(38)	/* 3.655V */
+#define BATT_OFF		(-128) /* 3.4029V */	//(-103)	/* 3.45V  */
+
+/*
+ * Spica Rev00 board Temperature Table
+ */
+const int temper_table[][2] =  {
+	/* ADC, Temperature (C) */
+	{ 1632,		-50	},
+	{ 1616,		-40	},
+	{ 1599,		-30	},
+	{ 1583,		-20	},
+	{ 1566,		-10	},
+	{ 1550,		0	},
+	{ 1530,		10	},
+	{ 1510,		20	},
+	{ 1490,		30	},
+	{ 1470,		40	},
+	{ 1450,		50	},
+	{ 1428,		60	},
+	{ 1406,		70	},
+	{ 1384,		80	},
+	{ 1362,		90	},
+	{ 1340,		100	},
+	{ 1317,		110	},
+	{ 1294,		120	},
+	{ 1270,		130	},
+	{ 1247,		140	},
+	{ 1224,		150	},
+	{ 1202,		160	},
+	{ 1179,		170	},
+	{ 1157,		180	},
+	{ 1134,		190	},
+	{ 1112,		200	},
+	{ 1088,		210	},
+	{ 1065,		220	},
+	{ 1041,		230	},
+	{ 1018,		240	},
+	{ 994,		250	},
+	{ 972,		260	},
+	{ 951,		270	},
+	{ 929,		280	},
+	{ 908,		290	},
+	{ 886,		300	},
+	{ 866,		310	},
+	{ 845,		320	},
+	{ 825,		330	},
+	{ 804,		340	},
+	{ 784,		350	},
+	{ 764,		360	},
+	{ 744,		370	},
+	{ 724,		380	},
+	{ 704,		390	},
+	{ 684,		400	},
+	{ 666,		410	},
+	{ 648,		420	},
+	{ 629,		430	},
+	{ 611,		440	},
+	{ 593,		450	},
+	{ 577,		460	},
+	{ 560,		470	},
+	{ 544,		480	},
+	{ 527,		490	},
+	{ 511,		500	},
+	{ 497,		510	},
+	{ 482,		520	},
+	{ 468,		530	},
+	{ 453,		540	},
+	{ 439,		550	},
+	{ 426,		560	},
+	{ 414,		570	},
+	{ 401,		580	},
+	{ 388,		590	},
+	{ 375,		600	},
+	{ 364,		610	},
+	{ 354,		620	},
+	{ 343,		630	},
+	{ 334,		640	},
+	{ 324,		650	},
+};
+
+#define TEMP_HIGH_BLOCK		temper_table[68][0]
+#define TEMP_HIGH_RECOVER	temper_table[63][0]
+#define TEMP_LOW_BLOCK		temper_table[0][0]
+#define TEMP_LOW_RECOVER	temper_table[5][0]
+
+/*
+ * Spica Rev00 board ADC channel
+ */
+typedef enum s3c_adc_channel {
+	S3C_ADC_VOLTAGE = 0,
+	S3C_ADC_TEMPERATURE,
+	S3C_ADC_V_F,
+	S3C_ADC_EAR,
+	S3C_ADC_CHG_CURRENT,
+	ENDOFADC
+} adc_channel_type;
+
+#define IRQ_TA_CONNECTED_N	IRQ_EINT(19)
+#define IRQ_TA_CHG_N		IRQ_EINT(25)
+
+/*
+ * Spica GPIO for battery driver
+ */
+const unsigned int gpio_ta_connected	= GPIO_TA_CONNECTED_N;
+const unsigned int gpio_ta_connected_af	= GPIO_TA_CONNECTED_N_AF;
+const unsigned int gpio_chg_ing		= GPIO_TA_CHG_N;
+const unsigned int gpio_chg_ing_af	= GPIO_TA_CHG_N_AF;
+const unsigned int gpio_chg_en		= GPIO_TA_EN;
+const unsigned int gpio_chg_en_af	= GPIO_TA_EN_AF;
+
+/******************************************************************************
+ * Battery driver features
+ * ***************************************************************************/
+/* #define __TEMP_ADC_VALUE__ */
+/* #define __USE_EGPIO__ */
+/* #define __CHECK_BATTERY_V_F__ */
+#define __BATTERY_V_F__
+#define __BATTERY_COMPENSATION__
+/* #define __CHECK_BOARD_REV__ */
+/* #define __BOARD_REV_ADC__ */
+#define __TEST_DEVICE_DRIVER__
+/* #define __ALWAYS_AWAKE_DEVICE__  */
+#define __TEST_MODE_INTERFACE__
+/*****************************************************************************/
+
+#define TOTAL_CHARGING_TIME	(6*60*60*1000)	/* 6 hours */
+#define TOTAL_RECHARGING_TIME	(2*60*60*1000)	/* 2 hours */
+
+#ifdef __BATTERY_COMPENSATION__
+#define COMPENSATE_VIBRATOR		19
+#define COMPENSATE_CAMERA		25
+#define COMPENSATE_MP3			17
+#define COMPENSATE_VIDEO		28
+#define COMPENSATE_VOICE_CALL_2G	13
+#define COMPENSATE_VOICE_CALL_3G	14
+#define COMPENSATE_DATA_CALL		25
+#define COMPENSATE_LCD			0
+#define COMPENSATE_TA			0
+#define COMPENSATE_CAM_FALSH		0
+#define COMPENSATE_BOOTING		52
+#endif /* __BATTERY_COMPENSATION__ */
+
+#define convert_adc2voltage(x)		((x - 2170) * 10 / 7 / 100 * 100 + 3200)
+
diff -Nur linux-2.6.29/drivers/power/s3c6410_fake_battery.c linux-2.6.29-spica/drivers/power/s3c6410_fake_battery.c
--- linux-2.6.29/drivers/power/s3c6410_fake_battery.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/power/s3c6410_fake_battery.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,574 @@
+/*
+ * linux/drivers/power/s3c6410_battery.c
+ *
+ * Battery measurement code for S3C6410 platform.
+ *
+ * based on palmtx_battery.c
+ *
+ * Copyright (C) 2009 Samsung Electronics.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/power_supply.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/wakelock.h>
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <plat/gpio-cfg.h>
+
+#include "s3c6410_battery.h"
+
+static struct wake_lock vbus_wake_lock;
+
+/* Prototypes */
+extern int s3c_adc_get_adc_data(int channel);
+
+static ssize_t s3c_bat_show_property(struct device *dev,
+                                      struct device_attribute *attr,
+                                      char *buf);
+static ssize_t s3c_bat_store(struct device *dev, 
+			     struct device_attribute *attr,
+			     const char *buf, size_t count);
+
+#define FAKE_BAT_LEVEL	80
+
+static struct device *dev;
+static int s3c_battery_initial;
+static int force_update;
+
+static char *status_text[] = {
+	[POWER_SUPPLY_STATUS_UNKNOWN] =		"Unknown",
+	[POWER_SUPPLY_STATUS_CHARGING] =	"Charging",
+	[POWER_SUPPLY_STATUS_DISCHARGING] =	"Discharging",
+	[POWER_SUPPLY_STATUS_NOT_CHARGING] =	"Not Charging",
+	[POWER_SUPPLY_STATUS_FULL] =		"Full",
+};
+
+typedef enum {
+	CHARGER_BATTERY = 0,
+	CHARGER_USB,
+	CHARGER_AC,
+	CHARGER_DISCHARGE
+} charger_type_t;
+
+struct battery_info {
+	u32 batt_id;		/* Battery ID from ADC */
+	u32 batt_vol;		/* Battery voltage from ADC */
+	u32 batt_vol_adc;	/* Battery ADC value */
+	u32 batt_vol_adc_cal;	/* Battery ADC value (calibrated)*/
+	u32 batt_temp;		/* Battery Temperature (C) from ADC */
+	u32 batt_temp_adc;	/* Battery Temperature ADC value */
+	u32 batt_temp_adc_cal;	/* Battery Temperature ADC value (calibrated) */
+	u32 batt_current;	/* Battery current from ADC */
+	u32 level;		/* formula */
+	u32 charging_source;	/* 0: no cable, 1:usb, 2:AC */
+	u32 charging_enabled;	/* 0: Disable, 1: Enable */
+	u32 batt_health;	/* Battery Health (Authority) */
+	u32 batt_is_full;       /* 0 : Not full 1: Full */
+};
+
+/* lock to protect the battery info */
+static DEFINE_MUTEX(work_lock);
+
+struct s3c_battery_info {
+	int present;
+	int polling;
+	unsigned long polling_interval;
+
+	struct battery_info bat_info;
+};
+static struct s3c_battery_info s3c_bat_info;
+
+static int s3c_get_bat_level(struct power_supply *bat_ps)
+{
+	return FAKE_BAT_LEVEL;
+}
+
+static int s3c_get_bat_vol(struct power_supply *bat_ps)
+{
+	int bat_vol = 0;
+
+	return bat_vol;
+}
+
+static u32 s3c_get_bat_health(void)
+{
+	return s3c_bat_info.bat_info.batt_health;
+}
+
+static int s3c_get_bat_temp(struct power_supply *bat_ps)
+{
+	int temp = 0;
+
+	return temp;
+}
+
+static int s3c_bat_get_charging_status(void)
+{
+        charger_type_t charger = CHARGER_BATTERY; 
+        int ret = 0;
+        
+        charger = s3c_bat_info.bat_info.charging_source;
+        
+        switch (charger) {
+        case CHARGER_BATTERY:
+                ret = POWER_SUPPLY_STATUS_NOT_CHARGING;
+                break;
+        case CHARGER_USB:
+        case CHARGER_AC:
+                if (s3c_bat_info.bat_info.level == 100 
+				&& s3c_bat_info.bat_info.batt_is_full) {
+                        ret = POWER_SUPPLY_STATUS_FULL;
+		}else {
+                        ret = POWER_SUPPLY_STATUS_CHARGING;
+		}
+                break;
+	case CHARGER_DISCHARGE:
+		ret = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+        default:
+                ret = POWER_SUPPLY_STATUS_UNKNOWN;
+        }
+
+	dev_dbg(dev, "%s : %s\n", __func__, status_text[ret]);
+        return ret;
+}
+
+static int s3c_bat_get_property(struct power_supply *bat_ps, 
+		enum power_supply_property psp,
+		union power_supply_propval *val)
+{
+	dev_dbg(bat_ps->dev, "%s : psp = %d\n", __func__, psp);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = s3c_bat_get_charging_status();
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = s3c_get_bat_health();
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = s3c_bat_info.present;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = s3c_bat_info.bat_info.level;
+		dev_dbg(dev, "%s : level = %d\n", __func__, 
+				val->intval);
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = s3c_bat_info.bat_info.batt_temp;
+		dev_dbg(bat_ps->dev, "%s : temp = %d\n", __func__, 
+				val->intval);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int s3c_power_get_property(struct power_supply *bat_ps, 
+		enum power_supply_property psp, 
+		union power_supply_propval *val)
+{
+	charger_type_t charger;
+	
+	dev_dbg(bat_ps->dev, "%s : psp = %d\n", __func__, psp);
+
+	charger = s3c_bat_info.bat_info.charging_source;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (bat_ps->type == POWER_SUPPLY_TYPE_MAINS)
+			val->intval = (charger == CHARGER_AC ? 1 : 0);
+		else if (bat_ps->type == POWER_SUPPLY_TYPE_USB)
+			val->intval = (charger == CHARGER_USB ? 1 : 0);
+		else
+			val->intval = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+	
+	return 0;
+}
+
+#define SEC_BATTERY_ATTR(_name)								\
+{											\
+        .attr = { .name = #_name, .mode = S_IRUGO | S_IWUGO, .owner = THIS_MODULE },	\
+        .show = s3c_bat_show_property,							\
+        .store = s3c_bat_store,								\
+}
+
+static struct device_attribute s3c_battery_attrs[] = {
+        SEC_BATTERY_ATTR(batt_vol),
+        SEC_BATTERY_ATTR(batt_vol_adc),
+        SEC_BATTERY_ATTR(batt_vol_adc_cal),
+        SEC_BATTERY_ATTR(batt_temp),
+        SEC_BATTERY_ATTR(batt_temp_adc),
+        SEC_BATTERY_ATTR(batt_temp_adc_cal),
+};
+
+enum {
+        BATT_VOL = 0,
+        BATT_VOL_ADC,
+        BATT_VOL_ADC_CAL,
+        BATT_TEMP,
+        BATT_TEMP_ADC,
+        BATT_TEMP_ADC_CAL,
+};
+
+static int s3c_bat_create_attrs(struct device * dev)
+{
+        int i, rc;
+        
+        for (i = 0; i < ARRAY_SIZE(s3c_battery_attrs); i++) {
+                rc = device_create_file(dev, &s3c_battery_attrs[i]);
+                if (rc)
+                        goto s3c_attrs_failed;
+        }
+        goto succeed;
+        
+s3c_attrs_failed:
+        while (i--)
+                device_remove_file(dev, &s3c_battery_attrs[i]);
+succeed:        
+        return rc;
+}
+
+static ssize_t s3c_bat_show_property(struct device *dev,
+                                      struct device_attribute *attr,
+                                      char *buf)
+{
+        int i = 0;
+        const ptrdiff_t off = attr - s3c_battery_attrs;
+
+        switch (off) {
+        case BATT_VOL:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+                               s3c_bat_info.bat_info.batt_vol);
+                break;
+        case BATT_VOL_ADC:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+                               s3c_bat_info.bat_info.batt_vol_adc);
+                break;
+        case BATT_VOL_ADC_CAL:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+                               s3c_bat_info.bat_info.batt_vol_adc_cal);
+                break;
+        case BATT_TEMP:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+                               s3c_bat_info.bat_info.batt_temp);
+                break;
+        case BATT_TEMP_ADC:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+                               s3c_bat_info.bat_info.batt_temp_adc);
+                break;	
+        case BATT_TEMP_ADC_CAL:
+                i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
+                               s3c_bat_info.bat_info.batt_temp_adc_cal);
+                break;
+        default:
+                i = -EINVAL;
+        }       
+        
+        return i;
+}
+
+static ssize_t s3c_bat_store(struct device *dev, 
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int x = 0;
+	int ret = 0;
+	const ptrdiff_t off = attr - s3c_battery_attrs;
+
+        switch (off) {
+        case BATT_VOL_ADC_CAL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			s3c_bat_info.bat_info.batt_vol_adc_cal = x;
+			ret = count;
+		}
+		dev_info(dev, "%s : batt_vol_adc_cal = %d\n", __func__, x);
+                break;
+        case BATT_TEMP_ADC_CAL:
+		if (sscanf(buf, "%d\n", &x) == 1) {
+			s3c_bat_info.bat_info.batt_temp_adc_cal = x;
+			ret = count;
+		}
+		dev_info(dev, "%s : batt_temp_adc_cal = %d\n", __func__, x);
+                break;
+        default:
+                ret = -EINVAL;
+        }       
+
+	return ret;
+}
+
+static enum power_supply_property s3c_battery_properties[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CAPACITY,
+};
+
+static enum power_supply_property s3c_power_properties[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static char *supply_list[] = {
+	"battery",
+};
+
+static struct power_supply s3c_power_supplies[] = {
+	{
+		.name = "battery",
+		.type = POWER_SUPPLY_TYPE_BATTERY,
+		.properties = s3c_battery_properties,
+		.num_properties = ARRAY_SIZE(s3c_battery_properties),
+		.get_property = s3c_bat_get_property,
+	},
+	{
+		.name = "usb",
+		.type = POWER_SUPPLY_TYPE_USB,
+		.supplied_to = supply_list,
+		.num_supplicants = ARRAY_SIZE(supply_list),
+		.properties = s3c_power_properties,
+		.num_properties = ARRAY_SIZE(s3c_power_properties),
+		.get_property = s3c_power_get_property,
+	},
+	{
+		.name = "ac",
+		.type = POWER_SUPPLY_TYPE_MAINS,
+		.supplied_to = supply_list,
+		.num_supplicants = ARRAY_SIZE(supply_list),
+		.properties = s3c_power_properties,
+		.num_properties = ARRAY_SIZE(s3c_power_properties),
+		.get_property = s3c_power_get_property,
+	},
+};
+
+static int s3c_cable_status_update(int status)
+{
+	int ret = 0;
+	charger_type_t source = CHARGER_BATTERY;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	if(!s3c_battery_initial)
+		return -EPERM;
+
+	switch(status) {
+	case CHARGER_BATTERY:
+		dev_dbg(dev, "%s : cable NOT PRESENT\n", __func__);
+		s3c_bat_info.bat_info.charging_source = CHARGER_BATTERY;
+		break;
+	case CHARGER_USB:
+		dev_dbg(dev, "%s : cable USB\n", __func__);
+		s3c_bat_info.bat_info.charging_source = CHARGER_USB;
+		break;
+	case CHARGER_AC:
+		dev_dbg(dev, "%s : cable AC\n", __func__);
+		s3c_bat_info.bat_info.charging_source = CHARGER_AC;
+		break;
+	case CHARGER_DISCHARGE:
+		dev_dbg(dev, "%s : Discharge\n", __func__);
+		s3c_bat_info.bat_info.charging_source = CHARGER_DISCHARGE;
+		break;
+	default:
+		dev_err(dev, "%s : Nat supported status\n", __func__);
+		ret = -EINVAL;
+	}
+	source = s3c_bat_info.bat_info.charging_source;
+
+        if (source == CHARGER_USB || source == CHARGER_AC) {
+                wake_lock(&vbus_wake_lock);
+        } else {
+                /* give userspace some time to see the uevent and update
+                 * LED state or whatnot...
+                 */
+                wake_lock_timeout(&vbus_wake_lock, HZ / 2);
+        }
+
+        /* if the power source changes, all power supplies may change state */
+        power_supply_changed(&s3c_power_supplies[CHARGER_BATTERY]);
+	/*
+        power_supply_changed(&s3c_power_supplies[CHARGER_USB]);
+        power_supply_changed(&s3c_power_supplies[CHARGER_AC]);
+	*/
+	dev_dbg(dev, "%s : call power_supply_changed\n", __func__);
+	return ret;
+}
+
+static void s3c_bat_status_update(struct power_supply *bat_ps)
+{
+	int old_level, old_temp, old_is_full;
+	dev_dbg(dev, "%s ++\n", __func__);
+
+	if(!s3c_battery_initial)
+		return;
+
+	mutex_lock(&work_lock);
+	old_temp = s3c_bat_info.bat_info.batt_temp;
+	old_level = s3c_bat_info.bat_info.level; 
+	old_is_full = s3c_bat_info.bat_info.batt_is_full;
+	s3c_bat_info.bat_info.batt_temp = s3c_get_bat_temp(bat_ps);
+	s3c_bat_info.bat_info.level = s3c_get_bat_level(bat_ps);
+	s3c_bat_info.bat_info.batt_vol = s3c_get_bat_vol(bat_ps);
+
+	if (old_level != s3c_bat_info.bat_info.level 
+			|| old_temp != s3c_bat_info.bat_info.batt_temp
+			|| old_is_full != s3c_bat_info.bat_info.batt_is_full
+			|| force_update) {
+		force_update = 0;
+		power_supply_changed(bat_ps);
+		dev_dbg(dev, "%s : call power_supply_changed\n", __func__);
+	}
+
+	mutex_unlock(&work_lock);
+	dev_dbg(dev, "%s --\n", __func__);
+}
+
+void s3c_cable_check_status(int flag)
+{
+    charger_type_t status = 0;
+
+    if (flag == 0)  // Battery
+		status = CHARGER_BATTERY;
+    else    // USB
+		status = CHARGER_USB;
+    s3c_cable_status_update(status);
+}
+EXPORT_SYMBOL(s3c_cable_check_status);
+
+#ifdef CONFIG_PM
+static int s3c_bat_suspend(struct platform_device *pdev, 
+		pm_message_t state)
+{
+	dev_info(dev, "%s\n", __func__);
+
+	return 0;
+}
+
+static int s3c_bat_resume(struct platform_device *pdev)
+{
+	dev_info(dev, "%s\n", __func__);
+
+	return 0;
+}
+#else
+#define s3c_bat_suspend NULL
+#define s3c_bat_resume NULL
+#endif /* CONFIG_PM */
+
+static int __devinit s3c_bat_probe(struct platform_device *pdev)
+{
+	int i;
+	int ret = 0;
+
+	dev = &pdev->dev;
+	dev_info(dev, "%s\n", __func__);
+
+	s3c_bat_info.present = 1;
+
+	s3c_bat_info.bat_info.batt_id = 0;
+	s3c_bat_info.bat_info.batt_vol = 0;
+	s3c_bat_info.bat_info.batt_vol_adc = 0;
+	s3c_bat_info.bat_info.batt_vol_adc_cal = 0;
+	s3c_bat_info.bat_info.batt_temp = 0;
+	s3c_bat_info.bat_info.batt_temp_adc = 0;
+	s3c_bat_info.bat_info.batt_temp_adc_cal = 0;
+	s3c_bat_info.bat_info.batt_current = 0;
+	s3c_bat_info.bat_info.level = 0;
+	s3c_bat_info.bat_info.charging_source = CHARGER_BATTERY;
+	s3c_bat_info.bat_info.charging_enabled = 0;
+	s3c_bat_info.bat_info.batt_health = POWER_SUPPLY_HEALTH_GOOD;
+
+	/* init power supplier framework */
+	for (i = 0; i < ARRAY_SIZE(s3c_power_supplies); i++) {
+		ret = power_supply_register(&pdev->dev, 
+				&s3c_power_supplies[i]);
+		if (ret) {
+			dev_err(dev, "Failed to register"
+					"power supply %d,%d\n", i, ret);
+			goto __end__;
+		}
+	}
+
+	/* create sec detail attributes */
+	s3c_bat_create_attrs(s3c_power_supplies[CHARGER_BATTERY].dev);
+
+	s3c_battery_initial = 1;
+	force_update = 0;
+
+	s3c_bat_status_update(
+			&s3c_power_supplies[CHARGER_BATTERY]);
+
+__end__:
+	return ret;
+}
+
+static int __devexit s3c_bat_remove(struct platform_device *pdev)
+{
+	int i;
+	dev_info(dev, "%s\n", __func__);
+
+	for (i = 0; i < ARRAY_SIZE(s3c_power_supplies); i++) {
+		power_supply_unregister(&s3c_power_supplies[i]);
+	}
+ 
+	return 0;
+}
+
+static struct platform_driver s3c_bat_driver = {
+	.driver.name	= DRIVER_NAME,
+	.driver.owner	= THIS_MODULE,
+	.probe		= s3c_bat_probe,
+	.remove		= __devexit_p(s3c_bat_remove),
+	.suspend	= s3c_bat_suspend,
+	.resume		= s3c_bat_resume,
+};
+
+/* Initailize GPIO */
+static void s3c_bat_init_hw(void)
+{
+}
+
+static int __init s3c_bat_init(void)
+{
+	pr_info("%s\n", __func__);
+	s3c_bat_init_hw();
+
+	wake_lock_init(&vbus_wake_lock, WAKE_LOCK_SUSPEND, "vbus_present");
+
+	return platform_driver_register(&s3c_bat_driver);
+}
+
+static void __exit s3c_bat_exit(void)
+{
+	pr_info("%s\n", __func__);
+	platform_driver_unregister(&s3c_bat_driver);
+}
+
+module_init(s3c_bat_init);
+module_exit(s3c_bat_exit);
+
+MODULE_AUTHOR("HuiSung Kang <hs1218.kang@samsung.com>");
+MODULE_DESCRIPTION("S3C6410 battery driver for SMDK6410");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/rtc/alarm.c linux-2.6.29-spica/drivers/rtc/alarm.c
--- linux-2.6.29/drivers/rtc/alarm.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/rtc/alarm.c	2010-03-30 11:00:36.000000000 +0700
@@ -0,0 +1,567 @@
+/* drivers/rtc/alarm.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/mach/time.h>
+#include <linux/android_alarm.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+#include <linux/spinlock.h>
+#include <linux/sysdev.h>
+#include <linux/wakelock.h>
+
+#define ANDROID_ALARM_PRINT_ERRORS (1U << 0)
+#define ANDROID_ALARM_PRINT_INIT_STATUS (1U << 1)
+#define ANDROID_ALARM_PRINT_INFO (1U << 2)
+#define ANDROID_ALARM_PRINT_IO (1U << 3)
+#define ANDROID_ALARM_PRINT_INT (1U << 4)
+#define ANDROID_ALARM_PRINT_FLOW (1U << 5)
+
+#if 0
+#define ANDROID_ALARM_DPRINTF_MASK (~0)
+#define ANDROID_ALARM_DPRINTF(debug_level_mask, args...) \
+	do { \
+		if (ANDROID_ALARM_DPRINTF_MASK & debug_level_mask) { \
+			printk(args); \
+		} \
+	} while (0)
+#else
+#define ANDROID_ALARM_DPRINTF(args...)
+#endif
+
+#define ANDROID_ALARM_WAKEUP_MASK ( \
+	ANDROID_ALARM_RTC_WAKEUP_MASK | \
+	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK)
+
+/* support old usespace code */
+#define ANDROID_ALARM_SET_OLD               _IOW('a', 2, time_t) /* set alarm */
+#define ANDROID_ALARM_SET_AND_WAIT_OLD      _IOW('a', 3, time_t)
+
+static struct rtc_device *alarm_rtc_dev;
+static int alarm_opened;
+static DEFINE_SPINLOCK(alarm_slock);
+static DEFINE_MUTEX(alarm_setrtc_mutex);
+static struct wake_lock alarm_wake_lock;
+static struct wake_lock alarm_rtc_wake_lock;
+static DECLARE_WAIT_QUEUE_HEAD(alarm_wait_queue);
+static uint32_t alarm_pending;
+static uint32_t alarm_enabled;
+static uint32_t wait_pending;
+static struct platform_device *alarm_platform_dev;
+static struct hrtimer alarm_timer[ANDROID_ALARM_TYPE_COUNT];
+static struct timespec alarm_time[ANDROID_ALARM_TYPE_COUNT];
+static struct timespec elapsed_rtc_delta;
+
+static void alarm_start_hrtimer(enum android_alarm_type alarm_type)
+{
+	struct timespec hr_alarm_time;
+	if (!(alarm_enabled & (1U << alarm_type)))
+		return;
+	hr_alarm_time = alarm_time[alarm_type];
+	if (alarm_type == ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP ||
+	    alarm_type == ANDROID_ALARM_ELAPSED_REALTIME)
+		set_normalized_timespec(&hr_alarm_time,
+			hr_alarm_time.tv_sec + elapsed_rtc_delta.tv_sec,
+			hr_alarm_time.tv_nsec + elapsed_rtc_delta.tv_nsec);
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_FLOW,
+		"alarm start hrtimer %d at %ld.%09ld\n",
+		alarm_type, hr_alarm_time.tv_sec, hr_alarm_time.tv_nsec);
+	hrtimer_start(&alarm_timer[alarm_type],
+		      timespec_to_ktime(hr_alarm_time), HRTIMER_MODE_ABS);
+}
+
+static long alarm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int rv = 0;
+	unsigned long flags;
+	int i;
+	struct timespec new_alarm_time;
+	struct timespec new_rtc_time;
+	struct timespec tmp_time;
+	struct rtc_time rtc_new_rtc_time;
+	enum android_alarm_type alarm_type = ANDROID_ALARM_IOCTL_TO_TYPE(cmd);
+	uint32_t alarm_type_mask = 1U << alarm_type;
+
+	if (alarm_type >= ANDROID_ALARM_TYPE_COUNT)
+		return -EINVAL;
+
+	if (ANDROID_ALARM_BASE_CMD(cmd) != ANDROID_ALARM_GET_TIME(0)) {
+		if ((file->f_flags & O_ACCMODE) == O_RDONLY)
+			return -EPERM;
+		if (file->private_data == NULL &&
+		    cmd != ANDROID_ALARM_SET_RTC) {
+			spin_lock_irqsave(&alarm_slock, flags);
+			if (alarm_opened) {
+				spin_unlock_irqrestore(&alarm_slock, flags);
+				return -EBUSY;
+			}
+			alarm_opened = 1;
+			file->private_data = (void *)1;
+			spin_unlock_irqrestore(&alarm_slock, flags);
+		}
+	}
+
+	switch (ANDROID_ALARM_BASE_CMD(cmd)) {
+	case ANDROID_ALARM_CLEAR(0):
+		spin_lock_irqsave(&alarm_slock, flags);
+		ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_IO,
+				      "alarm %d clear\n", alarm_type);
+		hrtimer_try_to_cancel(&alarm_timer[alarm_type]);
+		if (alarm_pending) {
+			alarm_pending &= ~alarm_type_mask;
+			if (!alarm_pending && !wait_pending)
+				wake_unlock(&alarm_wake_lock);
+		}
+		alarm_enabled &= ~alarm_type_mask;
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		break;
+
+	case ANDROID_ALARM_SET_OLD:
+	case ANDROID_ALARM_SET_AND_WAIT_OLD:
+		if (get_user(new_alarm_time.tv_sec, (int __user *)arg)) {
+			rv = -EFAULT;
+			goto err1;
+		}
+		new_alarm_time.tv_nsec = 0;
+		goto from_old_alarm_set;
+
+	case ANDROID_ALARM_SET_AND_WAIT(0):
+	case ANDROID_ALARM_SET(0):
+		if (copy_from_user(&new_alarm_time, (void __user *)arg,
+		    sizeof(new_alarm_time))) {
+			rv = -EFAULT;
+			goto err1;
+		}
+from_old_alarm_set:
+		spin_lock_irqsave(&alarm_slock, flags);
+		ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_IO,
+			"alarm %d set %ld.%09ld\n", alarm_type,
+			new_alarm_time.tv_sec, new_alarm_time.tv_nsec);
+		alarm_time[alarm_type] = new_alarm_time;
+		alarm_enabled |= alarm_type_mask;
+		alarm_start_hrtimer(alarm_type);
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		if (ANDROID_ALARM_BASE_CMD(cmd) != ANDROID_ALARM_SET_AND_WAIT(0)
+		    && cmd != ANDROID_ALARM_SET_AND_WAIT_OLD)
+			break;
+		/* fall though */
+	case ANDROID_ALARM_WAIT:
+		spin_lock_irqsave(&alarm_slock, flags);
+		ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_IO, "alarm wait\n");
+		if (!alarm_pending && wait_pending) {
+			wake_unlock(&alarm_wake_lock);
+			wait_pending = 0;
+		}
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		rv = wait_event_interruptible(alarm_wait_queue, alarm_pending);
+		if (rv)
+			goto err1;
+		spin_lock_irqsave(&alarm_slock, flags);
+		rv = alarm_pending;
+		wait_pending = 1;
+		alarm_pending = 0;
+		if (rv & ANDROID_ALARM_WAKEUP_MASK)
+			wake_unlock(&alarm_rtc_wake_lock);
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		break;
+	case ANDROID_ALARM_SET_RTC:
+		if (copy_from_user(&new_rtc_time, (void __user *)arg,
+		    sizeof(new_rtc_time))) {
+			rv = -EFAULT;
+			goto err1;
+		}
+		rtc_time_to_tm(new_rtc_time.tv_sec, &rtc_new_rtc_time);
+
+		ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_IO,
+			"set rtc %ld %ld - rtc %02d:%02d:%02d %02d/%02d/%04d\n",
+			new_rtc_time.tv_sec, new_rtc_time.tv_nsec,
+			rtc_new_rtc_time.tm_hour, rtc_new_rtc_time.tm_min,
+			rtc_new_rtc_time.tm_sec, rtc_new_rtc_time.tm_mon + 1,
+			rtc_new_rtc_time.tm_mday,
+			rtc_new_rtc_time.tm_year + 1900);
+
+		mutex_lock(&alarm_setrtc_mutex);
+		spin_lock_irqsave(&alarm_slock, flags);
+		for (i = 0; i < ANDROID_ALARM_SYSTEMTIME; i++)
+			hrtimer_try_to_cancel(&alarm_timer[i]);
+		getnstimeofday(&tmp_time);
+		elapsed_rtc_delta = timespec_sub(elapsed_rtc_delta,
+					timespec_sub(tmp_time, new_rtc_time));
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		rv = do_settimeofday(&new_rtc_time);
+		spin_lock_irqsave(&alarm_slock, flags);
+		for (i = 0; i < ANDROID_ALARM_SYSTEMTIME; i++)
+			alarm_start_hrtimer(i);
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		if (rv < 0) {
+			ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_ERRORS,
+					      "Failed to set time\n");
+			mutex_unlock(&alarm_setrtc_mutex);
+			goto err1;
+		}
+		rv = rtc_set_time(alarm_rtc_dev, &rtc_new_rtc_time);
+		spin_lock_irqsave(&alarm_slock, flags);
+		alarm_pending |= ANDROID_ALARM_TIME_CHANGE_MASK;
+		wake_up(&alarm_wait_queue);
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		mutex_unlock(&alarm_setrtc_mutex);
+		if (rv < 0) {
+			ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_ERRORS,
+			    "Failed to set RTC, time will be lost on reboot\n");
+			goto err1;
+		}
+		break;
+	case ANDROID_ALARM_GET_TIME(0):
+		mutex_lock(&alarm_setrtc_mutex);
+		spin_lock_irqsave(&alarm_slock, flags);
+		if (alarm_type != ANDROID_ALARM_SYSTEMTIME) {
+			getnstimeofday(&tmp_time);
+			if (alarm_type >= ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP)
+				tmp_time = timespec_sub(tmp_time,
+							elapsed_rtc_delta);
+		} else
+			ktime_get_ts(&tmp_time);
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		mutex_unlock(&alarm_setrtc_mutex);
+		if (copy_to_user((void __user *)arg, &tmp_time,
+		    sizeof(tmp_time))) {
+			rv = -EFAULT;
+			goto err1;
+		}
+		break;
+
+	default:
+		rv = -EINVAL;
+		goto err1;
+	}
+err1:
+	return rv;
+}
+
+static int alarm_open(struct inode *inode, struct file *file)
+{
+	file->private_data = NULL;
+	return 0;
+}
+
+static int alarm_release(struct inode *inode, struct file *file)
+{
+	int i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&alarm_slock, flags);
+	if (file->private_data != 0) {
+		for (i = 0; i < ANDROID_ALARM_TYPE_COUNT; i++) {
+			uint32_t alarm_type_mask = 1U << i;
+			if (alarm_enabled & alarm_type_mask) {
+				ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
+					"alarm_release: clear alarm, "
+					"pending %d\n",
+					!!(alarm_pending & alarm_type_mask));
+				alarm_enabled &= ~alarm_type_mask;
+			}
+			spin_unlock_irqrestore(&alarm_slock, flags);
+			hrtimer_cancel(&alarm_timer[i]);
+			spin_lock_irqsave(&alarm_slock, flags);
+		}
+		if (alarm_pending | wait_pending) {
+			if (alarm_pending)
+				ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
+					"alarm_release: clear pending alarms "
+					"%x\n", alarm_pending);
+			wake_unlock(&alarm_wake_lock);
+			wait_pending = 0;
+			alarm_pending = 0;
+		}
+		alarm_opened = 0;
+	}
+	spin_unlock_irqrestore(&alarm_slock, flags);
+	return 0;
+}
+
+static enum hrtimer_restart alarm_timer_triggered(struct hrtimer *timer)
+{
+	unsigned long flags;
+	enum android_alarm_type alarm_type = (timer - alarm_timer);
+	uint32_t alarm_type_mask = 1U << alarm_type;
+
+
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INT,
+			      "alarm_timer_triggered type %d\n", alarm_type);
+	spin_lock_irqsave(&alarm_slock, flags);
+	if (alarm_enabled & alarm_type_mask) {
+		wake_lock_timeout(&alarm_wake_lock, 5 * HZ);
+		alarm_enabled &= ~alarm_type_mask;
+		alarm_pending |= alarm_type_mask;
+		wake_up(&alarm_wait_queue);
+	}
+	spin_unlock_irqrestore(&alarm_slock, flags);
+	return HRTIMER_NORESTART;
+}
+
+static void alarm_triggered_func(void *p)
+{
+	struct rtc_device *rtc = alarm_rtc_dev;
+	if (!(rtc->irq_data & RTC_AF))
+		return;
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INT, "rtc alarm triggered\n");
+	wake_lock_timeout(&alarm_rtc_wake_lock, 1 * HZ);
+}
+
+int alarm_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	int                 err = 0;
+	unsigned long       flags;
+	struct rtc_wkalrm   rtc_alarm;
+	struct rtc_time     rtc_current_rtc_time;
+	unsigned long       rtc_current_time;
+	unsigned long       rtc_alarm_time;
+	struct timespec     rtc_current_timespec;
+	struct timespec     rtc_delta;
+	struct timespec     elapsed_realtime_alarm_time;
+
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_FLOW,
+			      "alarm_suspend(%p, %d)\n", pdev, state.event);
+	spin_lock_irqsave(&alarm_slock, flags);
+	if (alarm_pending && !wake_lock_active(&alarm_wake_lock)) {
+		ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
+				      "alarm pending\n");
+		err = -EBUSY;
+		goto err1;
+	}
+	if (alarm_enabled & ANDROID_ALARM_WAKEUP_MASK) {
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		if (alarm_enabled & ANDROID_ALARM_RTC_WAKEUP_MASK)
+			hrtimer_cancel(&alarm_timer[ANDROID_ALARM_RTC_WAKEUP]);
+		if (alarm_enabled & ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK)
+			hrtimer_cancel(&alarm_timer[
+					ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP]);
+
+		rtc_read_time(alarm_rtc_dev, &rtc_current_rtc_time);
+		rtc_current_timespec.tv_nsec = 0;
+		rtc_tm_to_time(&rtc_current_rtc_time,
+			       &rtc_current_timespec.tv_sec);
+		save_time_delta(&rtc_delta, &rtc_current_timespec);
+		set_normalized_timespec(&elapsed_realtime_alarm_time,
+			alarm_time[ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP]
+			.tv_sec + elapsed_rtc_delta.tv_sec,
+			alarm_time[ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP]
+			.tv_nsec + elapsed_rtc_delta.tv_nsec);
+		if ((alarm_enabled & ANDROID_ALARM_RTC_WAKEUP_MASK) &&
+		    (!(alarm_enabled &
+		       ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK) ||
+		     timespec_compare(&alarm_time[ANDROID_ALARM_RTC_WAKEUP],
+				      &elapsed_realtime_alarm_time) < 0))
+			rtc_alarm_time = timespec_sub(
+					alarm_time[ANDROID_ALARM_RTC_WAKEUP],
+					rtc_delta).tv_sec;
+		else
+			rtc_alarm_time = timespec_sub(
+				elapsed_realtime_alarm_time, rtc_delta).tv_sec;
+		rtc_time_to_tm(rtc_alarm_time, &rtc_alarm.time);
+		rtc_alarm.enabled = 1;
+		rtc_set_alarm(alarm_rtc_dev, &rtc_alarm);
+		rtc_read_time(alarm_rtc_dev, &rtc_current_rtc_time);
+		rtc_tm_to_time(&rtc_current_rtc_time, &rtc_current_time);
+		ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
+			"rtc alarm set at %ld, now %ld, rtc delta %ld.%09ld\n",
+			rtc_alarm_time, rtc_current_time,
+			rtc_delta.tv_sec, rtc_delta.tv_nsec);
+		if (rtc_current_time + 1 >= rtc_alarm_time) {
+			ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
+					      "alarm about to go off\n");
+			memset(&rtc_alarm, 0, sizeof(rtc_alarm));
+			rtc_alarm.enabled = 0;
+			rtc_set_alarm(alarm_rtc_dev, &rtc_alarm);
+
+			spin_lock_irqsave(&alarm_slock, flags);
+			wake_lock_timeout(&alarm_rtc_wake_lock, 2 * HZ);
+			alarm_start_hrtimer(ANDROID_ALARM_RTC_WAKEUP);
+			alarm_start_hrtimer(
+				ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP);
+			err = -EBUSY;
+			spin_unlock_irqrestore(&alarm_slock, flags);
+		}
+	} else {
+err1:
+		spin_unlock_irqrestore(&alarm_slock, flags);
+	}
+	return err;
+}
+
+int alarm_resume(struct platform_device *pdev)
+{
+	struct rtc_wkalrm alarm;
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_FLOW,
+			      "alarm_resume(%p)\n", pdev);
+	if (alarm_enabled & ANDROID_ALARM_WAKEUP_MASK) {
+		memset(&alarm, 0, sizeof(alarm));
+		alarm.enabled = 0;
+		rtc_set_alarm(alarm_rtc_dev, &alarm);
+		alarm_start_hrtimer(ANDROID_ALARM_RTC_WAKEUP);
+		alarm_start_hrtimer(ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP);
+	}
+	return 0;
+}
+
+static struct rtc_task alarm_rtc_task = {
+	.func = alarm_triggered_func
+};
+
+static struct file_operations alarm_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = alarm_ioctl,
+	.open = alarm_open,
+	.release = alarm_release,
+};
+
+static struct miscdevice alarm_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "alarm",
+	.fops = &alarm_fops,
+};
+
+static int rtc_alarm_add_device(struct device *dev,
+				struct class_interface *class_intf)
+{
+	int err;
+	struct rtc_device *rtc = to_rtc_device(dev);
+
+	mutex_lock(&alarm_setrtc_mutex);
+
+	if (alarm_rtc_dev) {
+		err = -EBUSY;
+		goto err1;
+	}
+
+	err = misc_register(&alarm_device);
+	if (err)
+		goto err1;
+	alarm_platform_dev =
+		platform_device_register_simple("alarm", -1, NULL, 0);
+	if (IS_ERR(alarm_platform_dev)) {
+		err = PTR_ERR(alarm_platform_dev);
+		goto err2;
+	}
+	err = rtc_irq_register(rtc, &alarm_rtc_task);
+	if (err)
+		goto err3;
+	alarm_rtc_dev = rtc;
+	mutex_unlock(&alarm_setrtc_mutex);
+
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO, "alarm: parent %p\n",
+			      alarm_platform_dev->dev.power.pm_parent);
+	return 0;
+
+err3:
+	platform_device_unregister(alarm_platform_dev);
+err2:
+	misc_deregister(&alarm_device);
+err1:
+	mutex_unlock(&alarm_setrtc_mutex);
+	return err;
+}
+
+static void rtc_alarm_remove_device(struct device *dev,
+				    struct class_interface *class_intf)
+{
+	if (dev == &alarm_rtc_dev->dev) {
+		rtc_irq_unregister(alarm_rtc_dev, &alarm_rtc_task);
+		platform_device_unregister(alarm_platform_dev);
+		misc_deregister(&alarm_device);
+		alarm_rtc_dev = NULL;
+	}
+}
+
+static struct class_interface rtc_alarm_interface = {
+	.add_dev = &rtc_alarm_add_device,
+	.remove_dev = &rtc_alarm_remove_device,
+};
+
+static struct platform_driver alarm_driver = {
+	.suspend = alarm_suspend,
+	.resume = alarm_resume,
+	.driver = {
+		.name = "alarm"
+	}
+};
+
+static int __init alarm_late_init(void)
+{
+	unsigned long   flags;
+	struct timespec system_time;
+
+	/* this needs to run after the rtc is read at boot */
+	spin_lock_irqsave(&alarm_slock, flags);
+	/* We read the current rtc and system time so we can later calulate
+	 * elasped realtime to be (boot_systemtime + rtc - boot_rtc) ==
+	 * (rtc - (boot_rtc - boot_systemtime))
+	 */
+	getnstimeofday(&elapsed_rtc_delta);
+	ktime_get_ts(&system_time);
+	elapsed_rtc_delta = timespec_sub(elapsed_rtc_delta, system_time);
+	spin_unlock_irqrestore(&alarm_slock, flags);
+
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
+		"alarm_late_init: rtc to elapsed realtime delta %ld.%09ld\n",
+		elapsed_rtc_delta.tv_sec, elapsed_rtc_delta.tv_nsec);
+	return 0;
+}
+
+static int __init alarm_init(void)
+{
+	int err;
+	int i;
+
+	for (i = 0; i < ANDROID_ALARM_SYSTEMTIME; i++) {
+		hrtimer_init(&alarm_timer[i], CLOCK_REALTIME, HRTIMER_MODE_ABS);
+		alarm_timer[i].function = alarm_timer_triggered;
+	}
+	hrtimer_init(&alarm_timer[ANDROID_ALARM_SYSTEMTIME],
+		     CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
+	alarm_timer[ANDROID_ALARM_SYSTEMTIME].function = alarm_timer_triggered;
+	err = platform_driver_register(&alarm_driver);
+	if (err < 0)
+		goto err1;
+	wake_lock_init(&alarm_wake_lock, WAKE_LOCK_SUSPEND, "alarm");
+	wake_lock_init(&alarm_rtc_wake_lock, WAKE_LOCK_SUSPEND, "alarm_rtc");
+	rtc_alarm_interface.class = rtc_class;
+	err = class_interface_register(&rtc_alarm_interface);
+	if (err < 0)
+		goto err2;
+
+	return 0;
+
+err2:
+	wake_lock_destroy(&alarm_rtc_wake_lock);
+	wake_lock_destroy(&alarm_wake_lock);
+	platform_driver_unregister(&alarm_driver);
+err1:
+	return err;
+}
+
+static void  __exit alarm_exit(void)
+{
+	class_interface_unregister(&rtc_alarm_interface);
+	wake_lock_destroy(&alarm_rtc_wake_lock);
+	wake_lock_destroy(&alarm_wake_lock);
+	platform_driver_unregister(&alarm_driver);
+}
+
+late_initcall(alarm_late_init);
+module_init(alarm_init);
+module_exit(alarm_exit);
+
diff -Nur linux-2.6.29/drivers/rtc/class.c linux-2.6.29-spica/drivers/rtc/class.c
--- linux-2.6.29/drivers/rtc/class.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/rtc/class.c	2010-03-30 11:00:36.000000000 +0700
@@ -40,25 +40,32 @@
  */
 
 static struct timespec	delta;
+static struct timespec	delta_delta;
 static time_t		oldtime;
 
 static int rtc_suspend(struct device *dev, pm_message_t mesg)
 {
 	struct rtc_device	*rtc = to_rtc_device(dev);
 	struct rtc_time		tm;
-	struct timespec		ts = current_kernel_time();
+	struct timespec		ts;
+	struct timespec		new_delta;
 
 	if (strcmp(dev_name(&rtc->dev), CONFIG_RTC_HCTOSYS_DEVICE) != 0)
 		return 0;
 
+	getnstimeofday(&ts);
 	rtc_read_time(rtc, &tm);
 	rtc_tm_to_time(&tm, &oldtime);
 
 	/* RTC precision is 1 second; adjust delta for avg 1/2 sec err */
-	set_normalized_timespec(&delta,
+	set_normalized_timespec(&new_delta,
 				ts.tv_sec - oldtime,
 				ts.tv_nsec - (NSEC_PER_SEC >> 1));
 
+	/* prevent 1/2 sec errors from accumulating */
+	delta_delta = timespec_sub(new_delta, delta);
+	if (delta_delta.tv_sec < -2 || delta_delta.tv_sec >= 2)
+		delta = new_delta;
 	return 0;
 }
 
@@ -78,6 +85,8 @@
 		return 0;
 	}
 	rtc_tm_to_time(&tm, &newtime);
+	if (delta_delta.tv_sec < -1)
+		newtime++;
 	if (newtime <= oldtime) {
 		if (newtime < oldtime)
 			pr_debug("%s:  time travel!\n", dev_name(&rtc->dev));
diff -Nur linux-2.6.29/drivers/rtc/Kconfig linux-2.6.29-spica/drivers/rtc/Kconfig
--- linux-2.6.29/drivers/rtc/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/rtc/Kconfig	2010-05-06 12:42:45.674299703 +0700
@@ -109,6 +109,16 @@
 	  clock several times per second, please enable this option
 	  only if you know that you really need it.
 
+config RTC_INTF_ALARM
+	bool "Android alarm driver"
+	depends on RTC_CLASS
+	default y
+	help
+	  Provides non-wakeup and rtc backed wakeup alarms based on rtc or
+	  elapsed realtime, and a non-wakeup alarm on the monotonic clock.
+	  Also provides an ioctl to set the wall time which must be used
+	  for elapsed realtime to work.
+
 config RTC_DRV_TEST
 	tristate "Test driver/device"
 	help
@@ -526,7 +536,7 @@
 
 config RTC_DRV_S3C
 	tristate "Samsung S3C series SoC RTC"
-	depends on ARCH_S3C2410
+	depends on ARCH_S3C2410 || ARCH_S3C64XX
 	help
 	  RTC (Realtime Clock) driver for the clock inbuilt into the
 	  Samsung S3C24XX series of SoCs. This can provide periodic
diff -Nur linux-2.6.29/drivers/rtc/Makefile linux-2.6.29-spica/drivers/rtc/Makefile
--- linux-2.6.29/drivers/rtc/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/rtc/Makefile	2010-03-30 11:00:36.000000000 +0700
@@ -11,6 +11,7 @@
 obj-$(CONFIG_RTC_CLASS)		+= rtc-core.o
 rtc-core-y			:= class.o interface.o
 
+rtc-core-$(CONFIG_RTC_INTF_ALARM) += alarm.o
 rtc-core-$(CONFIG_RTC_INTF_DEV)	+= rtc-dev.o
 rtc-core-$(CONFIG_RTC_INTF_PROC) += rtc-proc.o
 rtc-core-$(CONFIG_RTC_INTF_SYSFS) += rtc-sysfs.o
diff -Nur linux-2.6.29/drivers/rtc/rtc-s3c.c linux-2.6.29-spica/drivers/rtc/rtc-s3c.c
--- linux-2.6.29/drivers/rtc/rtc-s3c.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/rtc/rtc-s3c.c	2010-05-06 12:42:45.684270633 +0700
@@ -8,7 +8,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * S3C2410/S3C2440/S3C24XX Internal RTC Driver
+ * S3C Internal RTC Driver
 */
 
 #include <linux/module.h>
@@ -26,8 +26,29 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/irq.h>
+#include <asm/mach/time.h>
 #include <plat/regs-rtc.h>
 
+#define SET_RTC_DEFAULT_RESET_TIME
+#define CONFIG_RTC_SYNC
+
+#ifdef CONFIG_RTC_SYNC
+#include <linux/cpufreq.h>
+
+#include <plat/s3c64xx-dvfs.h>
+#include <linux/kernel_stat.h>
+#endif /* CONFIG_SYNC_RTC */
+
+
+#ifdef SET_RTC_DEFAULT_RESET_TIME
+#define DEFAULT_RESET_TIME_YEAR 	(2000)
+#define DEFAULT_RESET_TIME_MON	 	(1)
+#define DEFAULT_RESET_TIME_DATE	 	(1)
+#define DEFAULT_RESET_TIME_HOUR 	(0)
+#define DEFAULT_RESET_TIME_MIN 		(0)
+#define DEFAULT_RESET_TIME_SEC	 	(0)
+#endif /* SET_RTC_DEFAULT_RESET_TIME */
+
 /* I have yet to find an S3C implementation with more than one
  * of these rtc blocks in */
 
@@ -36,8 +57,173 @@
 static void __iomem *s3c_rtc_base;
 static int s3c_rtc_alarmno = NO_IRQ;
 static int s3c_rtc_tickno  = NO_IRQ;
+static int s3c_rtc_freq    = 1;
 
 static DEFINE_SPINLOCK(s3c_rtc_pie_lock);
+static unsigned int tick_count;
+
+/* common function function  */
+
+extern void s3c_rtc_set_pie(void __iomem *base, uint to);
+extern void s3c_rtc_set_freq_regs(void __iomem *base, uint freq, uint s3c_freq);
+extern void s3c_rtc_enable_set(struct platform_device *dev,void __iomem *base, int en);
+extern unsigned int s3c_rtc_set_bit_byte(void __iomem *base, uint offset, uint val);
+extern unsigned int s3c_rtc_read_alarm_status(void __iomem *base);
+
+static int s3c_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm);
+
+#ifdef CONFIG_RTC_SYNC
+//#define RTC_SYNC_DEBUG_MSG
+
+#define RTC_SYNC_SAVE_DELTA_INTERVAL	(HZ*30)		/* 30 seconds */
+#define RTC_SYNC_ADJUST_INTERVAL	(HZ*60*60)	/* 1 hour */
+#define RTC_SYNC_DETECT_IDLE_INTERVAL 	(HZ*5)		/* 5 seconds */
+#define RTC_SYNC_AFTER_BUSY_INTERVAL	(HZ*55)		/* 55 seconds */
+
+#define RTC_SYNC_FORCE_INTERVAL		(HZ*60*60*4)	/* 4 hours */
+#define RTC_SYNC_MAX_BUSY_COUNT		(RTC_SYNC_FORCE_INTERVAL / (RTC_SYNC_DETECT_IDLE_INTERVAL + RTC_SYNC_AFTER_BUSY_INTERVAL))
+#define RTC_SYNC_IDLE_CPUFREQ  		(66000)
+#define RTC_SYNC_IDLE_PERCENT		(80)
+
+enum rtc_sync_state {RS_SAVE_DELTA, RS_WAIT_ADJUST_TIME, RS_WAIT_ADJUST_TIME_AFTER_BUSY, RS_DETECT_IDLE, RS_TRY_ADJUST};
+
+static void rtc_sync_work_handler(struct work_struct * __unused);
+static DECLARE_DELAYED_WORK(rtc_sync_work, rtc_sync_work_handler);
+static void rtc_sync_start (void);
+static void rtc_sync_start_save_delta(void);
+
+static struct timespec		ts_saved_delta;
+static enum rtc_sync_state   	rtc_sync_state;
+
+static inline int detect_cpu_idle (unsigned int old_idle_tick)
+{
+	unsigned int cpufreq  = cpufreq_quick_get(0);
+	unsigned int idle_tick = kstat_cpu(0).cpustat.idle + kstat_cpu(0).cpustat.iowait;
+	unsigned int unit_idle_tick = idle_tick - old_idle_tick;
+	int	     state = false;
+	
+	old_idle_tick = idle_tick;
+
+	if (cpufreq == RTC_SYNC_IDLE_CPUFREQ && unit_idle_tick > (RTC_SYNC_DETECT_IDLE_INTERVAL * RTC_SYNC_IDLE_PERCENT / 100))
+	{
+		state = true;
+	}
+
+#ifdef RTC_SYNC_DEBUG_MSG
+	printk ("RTC_SYNC: %s cpufreq:%d, idle_tick:%d\n", 
+		(state == true)?"<idle>":"<busy>", cpufreq, unit_idle_tick);
+#endif
+	return state;
+}
+
+static void rtc_sync_adjust(void)
+{
+	struct rtc_time		rtc_time;
+	static time_t		rtc_time_t;
+	struct timespec		ts_system, ts_rtc, ts_delta, ts_delta_delta;
+
+	getnstimeofday(&ts_system);
+	s3c_rtc_gettime(NULL, &rtc_time);
+
+	rtc_tm_to_time(&rtc_time, &rtc_time_t);
+	/* RTC precision is 1 second; adjust delta for avg 1/2 sec err */
+	set_normalized_timespec(&ts_rtc, rtc_time_t, NSEC_PER_SEC>>1);
+	
+	ts_delta = timespec_sub(ts_system, ts_rtc);
+	ts_delta_delta = timespec_sub (ts_saved_delta, ts_delta);
+
+	if (ts_delta_delta.tv_sec < -2 || ts_delta_delta.tv_sec >= 2)
+	{
+		/* 
+		 * A differential beteen system time and rtc is over 2 second
+		 * , let's adjust system time and save time delta
+		 */
+		set_normalized_timespec(&ts_system, rtc_time_t + ts_saved_delta.tv_sec, ts_saved_delta.tv_nsec);
+		do_settimeofday(&ts_system);
+		printk ("RTC_SYNC: adjust system time from rtc\n");
+	}
+}
+
+static void rtc_sync_save_delta(void)
+{
+	struct rtc_time		rtc_time;
+	static time_t		rtc_time_t;
+	struct timespec		ts_system, ts_rtc;
+
+	getnstimeofday(&ts_system);
+	s3c_rtc_gettime(NULL, &rtc_time);
+
+	rtc_tm_to_time(&rtc_time, &rtc_time_t);
+	/* RTC precision is 1 second; adjust delta for avg 1/2 sec err */
+	set_normalized_timespec(&ts_rtc, rtc_time_t, NSEC_PER_SEC>>1);
+
+	ts_saved_delta = timespec_sub(ts_system, ts_rtc);
+
+#ifdef RTC_SYNC_DEBUG_MSG
+	printk ("RTC_SYNC: save delta sec:%d nsec:%d\n", ts_saved_delta.tv_sec, ts_saved_delta.tv_nsec);
+#endif
+}
+
+static void rtc_sync_work_handler(struct work_struct * __unused)
+{
+	static unsigned int 	old_idle_tick, busy_count;
+	int 			next_interval;
+	int 			cpu_idle;
+
+	if (rtc_sync_state == RS_SAVE_DELTA)
+	{
+		rtc_sync_save_delta();
+		rtc_sync_start();
+		return;
+	}
+
+	switch (rtc_sync_state)
+	{
+	case RS_WAIT_ADJUST_TIME:
+		/* start adjust service */
+		busy_count = 0;
+	case RS_WAIT_ADJUST_TIME_AFTER_BUSY:
+		/* prepare detect cpu idle */
+		old_idle_tick = kstat_cpu(0).cpustat.idle + kstat_cpu(0).cpustat.iowait;
+		rtc_sync_state = RS_DETECT_IDLE;
+		next_interval = RTC_SYNC_DETECT_IDLE_INTERVAL;
+		break;
+	case RS_DETECT_IDLE:
+		cpu_idle = detect_cpu_idle(old_idle_tick);
+
+		/* when cpu idle or passing the adjust force time */
+		if (cpu_idle || ++busy_count > RTC_SYNC_MAX_BUSY_COUNT)
+		{
+			rtc_sync_state = RS_TRY_ADJUST;
+			rtc_sync_adjust();
+			rtc_sync_state = RS_WAIT_ADJUST_TIME;
+			next_interval = RTC_SYNC_ADJUST_INTERVAL;
+		}
+		else
+		{
+			rtc_sync_state = RS_WAIT_ADJUST_TIME_AFTER_BUSY;
+			next_interval = RTC_SYNC_AFTER_BUSY_INTERVAL;
+		}
+		break;
+	default:
+		return;
+	}
+	schedule_delayed_work(&rtc_sync_work, next_interval);
+}
+
+static inline void  rtc_sync_start ()
+{
+	rtc_sync_state = RS_WAIT_ADJUST_TIME;
+	schedule_delayed_work(&rtc_sync_work, RTC_SYNC_ADJUST_INTERVAL);
+}
+
+static inline void  rtc_sync_start_save_delta ()
+{
+	rtc_sync_state = RS_SAVE_DELTA;
+	schedule_delayed_work(&rtc_sync_work, RTC_SYNC_SAVE_DELTA_INTERVAL);
+}
+
+#endif	/* CONFIG_RTC_SYNC */
 
 /* IRQ Handlers */
 
@@ -46,6 +232,9 @@
 	struct rtc_device *rdev = id;
 
 	rtc_update_irq(rdev, 1, RTC_AF | RTC_IRQF);
+
+	s3c_rtc_set_bit_byte(s3c_rtc_base,S3C_INTP,S3C_INTP_ALM);
+
 	return IRQ_HANDLED;
 }
 
@@ -54,6 +243,9 @@
 	struct rtc_device *rdev = id;
 
 	rtc_update_irq(rdev, 1, RTC_PF | RTC_IRQF);
+
+	s3c_rtc_set_bit_byte(s3c_rtc_base,S3C_INTP,S3C_INTP_TIC);
+
 	return IRQ_HANDLED;
 }
 
@@ -64,27 +256,22 @@
 
 	pr_debug("%s: aie=%d\n", __func__, to);
 
-	tmp = readb(s3c_rtc_base + S3C2410_RTCALM) & ~S3C2410_RTCALM_ALMEN;
+	tmp = readb(s3c_rtc_base + S3C_RTCALM) & ~S3C_RTCALM_ALMEN;
 
 	if (to)
-		tmp |= S3C2410_RTCALM_ALMEN;
+		tmp |= S3C_RTCALM_ALMEN;
 
-	writeb(tmp, s3c_rtc_base + S3C2410_RTCALM);
+	writeb(tmp, s3c_rtc_base + S3C_RTCALM);
 }
 
 static int s3c_rtc_setpie(struct device *dev, int enabled)
 {
-	unsigned int tmp;
-
 	pr_debug("%s: pie=%d\n", __func__, enabled);
 
 	spin_lock_irq(&s3c_rtc_pie_lock);
-	tmp = readb(s3c_rtc_base + S3C2410_TICNT) & ~S3C2410_TICNT_ENABLE;
 
-	if (enabled)
-		tmp |= S3C2410_TICNT_ENABLE;
+	s3c_rtc_set_pie(s3c_rtc_base,enabled);
 
-	writeb(tmp, s3c_rtc_base + S3C2410_TICNT);
 	spin_unlock_irq(&s3c_rtc_pie_lock);
 
 	return 0;
@@ -92,17 +279,10 @@
 
 static int s3c_rtc_setfreq(struct device *dev, int freq)
 {
-	unsigned int tmp;
-
-	if (!is_power_of_2(freq))
-		return -EINVAL;
-
 	spin_lock_irq(&s3c_rtc_pie_lock);
 
-	tmp = readb(s3c_rtc_base + S3C2410_TICNT) & S3C2410_TICNT_ENABLE;
-	tmp |= (128 / freq)-1;
+	s3c_rtc_set_freq_regs(s3c_rtc_base, freq, s3c_rtc_freq);
 
-	writeb(tmp, s3c_rtc_base + S3C2410_TICNT);
 	spin_unlock_irq(&s3c_rtc_pie_lock);
 
 	return 0;
@@ -116,12 +296,12 @@
 	void __iomem *base = s3c_rtc_base;
 
  retry_get_time:
-	rtc_tm->tm_min  = readb(base + S3C2410_RTCMIN);
-	rtc_tm->tm_hour = readb(base + S3C2410_RTCHOUR);
-	rtc_tm->tm_mday = readb(base + S3C2410_RTCDATE);
-	rtc_tm->tm_mon  = readb(base + S3C2410_RTCMON);
-	rtc_tm->tm_year = readb(base + S3C2410_RTCYEAR);
-	rtc_tm->tm_sec  = readb(base + S3C2410_RTCSEC);
+	rtc_tm->tm_min  = readb(base + S3C_RTCMIN);
+	rtc_tm->tm_hour = readb(base + S3C_RTCHOUR);
+	rtc_tm->tm_mday = readb(base + S3C_RTCDATE);
+	rtc_tm->tm_mon  = readb(base + S3C_RTCMON);
+	rtc_tm->tm_year = readb(base + S3C_RTCYEAR);
+	rtc_tm->tm_sec  = readb(base + S3C_RTCSEC);
 
 	/* the only way to work out wether the system was mid-update
 	 * when we read it is to check the second counter, and if it
@@ -159,6 +339,11 @@
 		 tm->tm_year, tm->tm_mon, tm->tm_mday,
 		 tm->tm_hour, tm->tm_min, tm->tm_sec);
 
+#ifdef CONFIG_RTC_SYNC
+	cancel_delayed_work(&rtc_sync_work);
+	rtc_sync_start_save_delta ();
+#endif	/* CONFIG_RTC_SYNC */
+
 	/* we get around y2k by simply not supporting it */
 
 	if (year < 0 || year >= 100) {
@@ -166,12 +351,12 @@
 		return -EINVAL;
 	}
 
-	writeb(bin2bcd(tm->tm_sec),  base + S3C2410_RTCSEC);
-	writeb(bin2bcd(tm->tm_min),  base + S3C2410_RTCMIN);
-	writeb(bin2bcd(tm->tm_hour), base + S3C2410_RTCHOUR);
-	writeb(bin2bcd(tm->tm_mday), base + S3C2410_RTCDATE);
-	writeb(bin2bcd(tm->tm_mon + 1), base + S3C2410_RTCMON);
-	writeb(bin2bcd(year), base + S3C2410_RTCYEAR);
+	writeb(bin2bcd(tm->tm_sec),  base + S3C_RTCSEC);
+	writeb(bin2bcd(tm->tm_min),  base + S3C_RTCMIN);
+	writeb(bin2bcd(tm->tm_hour), base + S3C_RTCHOUR);
+	writeb(bin2bcd(tm->tm_mday), base + S3C_RTCDATE);
+	writeb(bin2bcd(tm->tm_mon + 1), base + S3C_RTCMON);
+	writeb(bin2bcd(year), base + S3C_RTCYEAR);
 
 	return 0;
 }
@@ -182,16 +367,16 @@
 	void __iomem *base = s3c_rtc_base;
 	unsigned int alm_en;
 
-	alm_tm->tm_sec  = readb(base + S3C2410_ALMSEC);
-	alm_tm->tm_min  = readb(base + S3C2410_ALMMIN);
-	alm_tm->tm_hour = readb(base + S3C2410_ALMHOUR);
-	alm_tm->tm_mon  = readb(base + S3C2410_ALMMON);
-	alm_tm->tm_mday = readb(base + S3C2410_ALMDATE);
-	alm_tm->tm_year = readb(base + S3C2410_ALMYEAR);
+	alm_tm->tm_sec  = readb(base + S3C_ALMSEC);
+	alm_tm->tm_min  = readb(base + S3C_ALMMIN);
+	alm_tm->tm_hour = readb(base + S3C_ALMHOUR);
+	alm_tm->tm_mon  = readb(base + S3C_ALMMON);
+	alm_tm->tm_mday = readb(base + S3C_ALMDATE);
+	alm_tm->tm_year = readb(base + S3C_ALMYEAR);
 
-	alm_en = readb(base + S3C2410_RTCALM);
+	alm_en = readb(base + S3C_RTCALM);
 
-	alrm->enabled = (alm_en & S3C2410_RTCALM_ALMEN) ? 1 : 0;
+	alrm->enabled = (alm_en & S3C_RTCALM_ALMEN) ? 1 : 0;
 
 	pr_debug("read alarm %02x %02x.%02x.%02x %02x/%02x/%02x\n",
 		 alm_en,
@@ -201,34 +386,34 @@
 
 	/* decode the alarm enable field */
 
-	if (alm_en & S3C2410_RTCALM_SECEN)
+	if (alm_en & S3C_RTCALM_SECEN)
 		alm_tm->tm_sec = bcd2bin(alm_tm->tm_sec);
 	else
 		alm_tm->tm_sec = 0xff;
 
-	if (alm_en & S3C2410_RTCALM_MINEN)
+	if (alm_en & S3C_RTCALM_MINEN)
 		alm_tm->tm_min = bcd2bin(alm_tm->tm_min);
 	else
 		alm_tm->tm_min = 0xff;
 
-	if (alm_en & S3C2410_RTCALM_HOUREN)
+	if (alm_en & S3C_RTCALM_HOUREN)
 		alm_tm->tm_hour = bcd2bin(alm_tm->tm_hour);
 	else
 		alm_tm->tm_hour = 0xff;
 
-	if (alm_en & S3C2410_RTCALM_DAYEN)
+	if (alm_en & S3C_RTCALM_DAYEN)
 		alm_tm->tm_mday = bcd2bin(alm_tm->tm_mday);
 	else
 		alm_tm->tm_mday = 0xff;
 
-	if (alm_en & S3C2410_RTCALM_MONEN) {
+	if (alm_en & S3C_RTCALM_MONEN) {
 		alm_tm->tm_mon = bcd2bin(alm_tm->tm_mon);
 		alm_tm->tm_mon -= 1;
 	} else {
 		alm_tm->tm_mon = 0xff;
 	}
 
-	if (alm_en & S3C2410_RTCALM_YEAREN)
+	if (alm_en & S3C_RTCALM_YEAREN)
 		alm_tm->tm_year = bcd2bin(alm_tm->tm_year);
 	else
 		alm_tm->tm_year = 0xffff;
@@ -242,50 +427,107 @@
 	void __iomem *base = s3c_rtc_base;
 	unsigned int alrm_en;
 
+	int year = tm->tm_year - 100;
+
 	pr_debug("s3c_rtc_setalarm: %d, %02x/%02x/%02x %02x.%02x.%02x\n",
 		 alrm->enabled,
 		 tm->tm_mday & 0xff, tm->tm_mon & 0xff, tm->tm_year & 0xff,
 		 tm->tm_hour & 0xff, tm->tm_min & 0xff, tm->tm_sec);
 
-
-	alrm_en = readb(base + S3C2410_RTCALM) & S3C2410_RTCALM_ALMEN;
-	writeb(0x00, base + S3C2410_RTCALM);
+	alrm_en = readb(base + S3C_RTCALM) & S3C_RTCALM_ALMEN;
+	writeb(0x00, base + S3C_RTCALM);
 
 	if (tm->tm_sec < 60 && tm->tm_sec >= 0) {
-		alrm_en |= S3C2410_RTCALM_SECEN;
-		writeb(bin2bcd(tm->tm_sec), base + S3C2410_ALMSEC);
+		alrm_en |= S3C_RTCALM_SECEN;
+		writeb(bin2bcd(tm->tm_sec), base + S3C_ALMSEC);
 	}
 
 	if (tm->tm_min < 60 && tm->tm_min >= 0) {
-		alrm_en |= S3C2410_RTCALM_MINEN;
-		writeb(bin2bcd(tm->tm_min), base + S3C2410_ALMMIN);
+		alrm_en |= S3C_RTCALM_MINEN;
+		writeb(bin2bcd(tm->tm_min), base + S3C_ALMMIN);
 	}
 
 	if (tm->tm_hour < 24 && tm->tm_hour >= 0) {
-		alrm_en |= S3C2410_RTCALM_HOUREN;
-		writeb(bin2bcd(tm->tm_hour), base + S3C2410_ALMHOUR);
+		alrm_en |= S3C_RTCALM_HOUREN;
+		writeb(bin2bcd(tm->tm_hour), base + S3C_ALMHOUR);
 	}
 
-	pr_debug("setting S3C2410_RTCALM to %08x\n", alrm_en);
+	if (tm->tm_mday >= 0) {
+		alrm_en |= S3C_RTCALM_DAYEN;
+		writeb(bin2bcd(tm->tm_mday), base + S3C_ALMDATE);
+	}
 
-	writeb(alrm_en, base + S3C2410_RTCALM);
+	if (tm->tm_mon < 13 && tm->tm_mon >= 0) {
+		alrm_en |= S3C_RTCALM_MONEN;
+		writeb(bin2bcd(tm->tm_mon + 1), base + S3C_ALMMON);
+	}
 
-	s3c_rtc_setaie(alrm->enabled);
+	if (year < 100 && year >= 0) {
+		alrm_en |= S3C_RTCALM_YEAREN;
+		writeb(bin2bcd(year), base + S3C_ALMYEAR);
+	}
 
-	if (alrm->enabled)
-		enable_irq_wake(s3c_rtc_alarmno);
-	else
-		disable_irq_wake(s3c_rtc_alarmno);
+	pr_debug("setting S3C_RTCALM to %08x\n", alrm_en);
+
+	writeb(alrm_en, base + S3C_RTCALM);
+
+	s3c_rtc_setaie(alrm->enabled);
 
 	return 0;
 }
 
+static int s3c_rtc_ioctl(struct device *dev,
+			 unsigned int cmd, unsigned long arg)
+{
+	unsigned int ret = -ENOIOCTLCMD;
+
+	switch (cmd) {
+	case RTC_AIE_OFF:
+	case RTC_AIE_ON:
+		s3c_rtc_setaie((cmd == RTC_AIE_ON) ? 1 : 0);
+		ret = 0;
+		break;
+
+	case RTC_PIE_OFF:
+	case RTC_PIE_ON:
+		tick_count = 0;
+		s3c_rtc_setpie(dev,(cmd == RTC_PIE_ON) ? 1 : 0);
+		ret = 0;
+		break;
+
+	case RTC_IRQP_READ:
+		ret = put_user(s3c_rtc_freq, (unsigned long __user *)arg);
+		break;
+
+	case RTC_IRQP_SET:
+		/* check for power of 2 */
+
+		if ((arg & (arg-1)) != 0 || arg < 1) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		pr_debug("s3c_rtc: setting frequency %ld\n", arg);
+
+		s3c_rtc_setfreq(dev, arg);
+		ret = 0;
+		break;
+
+	case RTC_UIE_ON:
+	case RTC_UIE_OFF:
+		ret = -EINVAL;
+	}
+
+ exit:
+	return ret;
+}
+
 static int s3c_rtc_proc(struct device *dev, struct seq_file *seq)
 {
-	unsigned int ticnt = readb(s3c_rtc_base + S3C2410_TICNT);
+	unsigned int ticnt = readb(s3c_rtc_base + S3C_TICNT);
 
 	seq_printf(seq, "periodic_IRQ\t: %s\n",
-		     (ticnt & S3C2410_TICNT_ENABLE) ? "yes" : "no" );
+		     (ticnt & S3C_TICNT_ENABLE) ? "yes" : "no" );
 	return 0;
 }
 
@@ -296,7 +538,7 @@
 	int ret;
 
 	ret = request_irq(s3c_rtc_alarmno, s3c_rtc_alarmirq,
-			  IRQF_DISABLED,  "s3c2410-rtc alarm", rtc_dev);
+			  IRQF_DISABLED,  "s3c-rtc alarm", rtc_dev);
 
 	if (ret) {
 		dev_err(dev, "IRQ%d error %d\n", s3c_rtc_alarmno, ret);
@@ -304,7 +546,7 @@
 	}
 
 	ret = request_irq(s3c_rtc_tickno, s3c_rtc_tickirq,
-			  IRQF_DISABLED,  "s3c2410-rtc tick", rtc_dev);
+			  IRQF_DISABLED,  "s3c-rtc tick", rtc_dev);
 
 	if (ret) {
 		dev_err(dev, "IRQ%d error %d\n", s3c_rtc_tickno, ret);
@@ -333,6 +575,7 @@
 static const struct rtc_class_ops s3c_rtcops = {
 	.open		= s3c_rtc_open,
 	.release	= s3c_rtc_release,
+	.ioctl		= s3c_rtc_ioctl,
 	.read_time	= s3c_rtc_gettime,
 	.set_time	= s3c_rtc_settime,
 	.read_alarm	= s3c_rtc_getalarm,
@@ -345,44 +588,14 @@
 static void s3c_rtc_enable(struct platform_device *pdev, int en)
 {
 	void __iomem *base = s3c_rtc_base;
-	unsigned int tmp;
 
 	if (s3c_rtc_base == NULL)
 		return;
 
-	if (!en) {
-		tmp = readb(base + S3C2410_RTCCON);
-		writeb(tmp & ~S3C2410_RTCCON_RTCEN, base + S3C2410_RTCCON);
-
-		tmp = readb(base + S3C2410_TICNT);
-		writeb(tmp & ~S3C2410_TICNT_ENABLE, base + S3C2410_TICNT);
-	} else {
-		/* re-enable the device, and check it is ok */
-
-		if ((readb(base+S3C2410_RTCCON) & S3C2410_RTCCON_RTCEN) == 0){
-			dev_info(&pdev->dev, "rtc disabled, re-enabling\n");
-
-			tmp = readb(base + S3C2410_RTCCON);
-			writeb(tmp|S3C2410_RTCCON_RTCEN, base+S3C2410_RTCCON);
-		}
-
-		if ((readb(base + S3C2410_RTCCON) & S3C2410_RTCCON_CNTSEL)){
-			dev_info(&pdev->dev, "removing RTCCON_CNTSEL\n");
-
-			tmp = readb(base + S3C2410_RTCCON);
-			writeb(tmp& ~S3C2410_RTCCON_CNTSEL, base+S3C2410_RTCCON);
+	s3c_rtc_enable_set(pdev,base,en);
 		}
 
-		if ((readb(base + S3C2410_RTCCON) & S3C2410_RTCCON_CLKRST)){
-			dev_info(&pdev->dev, "removing RTCCON_CLKRST\n");
-
-			tmp = readb(base + S3C2410_RTCCON);
-			writeb(tmp & ~S3C2410_RTCCON_CLKRST, base+S3C2410_RTCCON);
-		}
-	}
-}
-
-static int __devexit s3c_rtc_remove(struct platform_device *dev)
+static int s3c_rtc_remove(struct platform_device *dev)
 {
 	struct rtc_device *rtc = platform_get_drvdata(dev);
 
@@ -396,14 +609,19 @@
 	release_resource(s3c_rtc_mem);
 	kfree(s3c_rtc_mem);
 
+#ifdef CONFIG_RTC_SYNC
+	cancel_delayed_work(&rtc_sync_work);
+#endif	/* CONFIG_RTC_SYNC */
+
 	return 0;
 }
 
-static int __devinit s3c_rtc_probe(struct platform_device *pdev)
+static int s3c_rtc_probe(struct platform_device *pdev)
 {
 	struct rtc_device *rtc;
 	struct resource *res;
 	int ret;
+	unsigned char bcd_tmp,bcd_loop;
 
 	pr_debug("%s: probe=%p\n", __func__, pdev);
 
@@ -421,7 +639,7 @@
 		return -ENOENT;
 	}
 
-	pr_debug("s3c2410_rtc: tick irq %d, alarm irq %d\n",
+	printk("s3c_rtc: tick irq %d, alarm irq %d\n",
 		 s3c_rtc_tickno, s3c_rtc_alarmno);
 
 	/* get the memory region */
@@ -453,8 +671,8 @@
 
 	s3c_rtc_enable(pdev, 1);
 
- 	pr_debug("s3c2410_rtc: RTCCON=%02x\n",
-		 readb(s3c_rtc_base + S3C2410_RTCCON));
+ 	pr_debug("s3c_rtc: RTCCON=%02x\n",
+		 readb(s3c_rtc_base + S3C_RTCCON));
 
 	s3c_rtc_setfreq(&pdev->dev, 1);
 
@@ -471,9 +689,44 @@
 		goto err_nortc;
 	}
 
-	rtc->max_user_freq = 128;
+	rtc->max_user_freq = S3C_MAX_CNT;
+
+#ifdef SET_RTC_DEFAULT_RESET_TIME
+	{
+		struct rtc_time tm;
+
+		s3c_rtc_gettime (pdev, &tm);
+		if (rtc_valid_tm (&tm) != 0)
+		{
+			struct rtc_time reset_tm = {
+				.tm_sec = DEFAULT_RESET_TIME_SEC,
+				.tm_min = DEFAULT_RESET_TIME_MIN,
+				.tm_hour = DEFAULT_RESET_TIME_HOUR,
+				.tm_mday = DEFAULT_RESET_TIME_DATE,
+				.tm_mon = DEFAULT_RESET_TIME_MON - 1,
+				.tm_year = DEFAULT_RESET_TIME_YEAR - 1900,
+				};
+
+			s3c_rtc_settime (pdev, &reset_tm);
+		}
+	}
+#else
+
+	/* check rtc time */
+	for (bcd_loop = S3C_RTCSEC ; bcd_loop <= S3C_RTCYEAR ; bcd_loop +=0x4)
+	{
+		bcd_tmp = readb(s3c_rtc_base + bcd_loop);
+		if(((bcd_tmp & 0xf) > 0x9) || ((bcd_tmp & 0xf0) > 0x90))
+			writeb(0, s3c_rtc_base + bcd_loop);
+	}
+#endif
 
 	platform_set_drvdata(pdev, rtc);
+
+#ifdef CONFIG_RTC_SYNC
+	rtc_sync_start_save_delta();
+#endif	/* CONFIG_RTC_SYNC */
+
 	return 0;
 
  err_nortc:
@@ -496,15 +749,23 @@
 static int s3c_rtc_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	/* save TICNT for anyone using periodic interrupts */
-	ticnt_save = readb(s3c_rtc_base + S3C2410_TICNT);
+	ticnt_save = readb(s3c_rtc_base + S3C_TICNT);
 	s3c_rtc_enable(pdev, 0);
+
+#ifdef CONFIG_RTC_SYNC
+	cancel_delayed_work(&rtc_sync_work);
+#endif	/* CONFIG_RTC_SYNC */
 	return 0;
 }
 
 static int s3c_rtc_resume(struct platform_device *pdev)
 {
 	s3c_rtc_enable(pdev, 1);
-	writeb(ticnt_save, s3c_rtc_base + S3C2410_TICNT);
+	writeb(ticnt_save, s3c_rtc_base + S3C_TICNT);
+#ifdef CONFIG_RTC_SYNC
+	rtc_sync_start ();
+#endif
+	printk ("%s\n", __func__);
 	return 0;
 }
 #else
@@ -512,28 +773,28 @@
 #define s3c_rtc_resume  NULL
 #endif
 
-static struct platform_driver s3c2410_rtc_driver = {
+static struct platform_driver s3c_rtc_driver = {
 	.probe		= s3c_rtc_probe,
-	.remove		= __devexit_p(s3c_rtc_remove),
+	.remove		= s3c_rtc_remove,
 	.suspend	= s3c_rtc_suspend,
 	.resume		= s3c_rtc_resume,
 	.driver		= {
-		.name	= "s3c2410-rtc",
+		.name	= "s3c-rtc",
 		.owner	= THIS_MODULE,
 	},
 };
 
-static char __initdata banner[] = "S3C24XX RTC, (c) 2004,2006 Simtec Electronics\n";
+static char __initdata banner[] = "S3C RTC, (c) 2004,2006 Simtec Electronics\n";
 
 static int __init s3c_rtc_init(void)
 {
 	printk(banner);
-	return platform_driver_register(&s3c2410_rtc_driver);
+	return platform_driver_register(&s3c_rtc_driver);
 }
 
 static void __exit s3c_rtc_exit(void)
 {
-	platform_driver_unregister(&s3c2410_rtc_driver);
+	platform_driver_unregister(&s3c_rtc_driver);
 }
 
 module_init(s3c_rtc_init);
@@ -542,4 +803,4 @@
 MODULE_DESCRIPTION("Samsung S3C RTC Driver");
 MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:s3c2410-rtc");
+MODULE_ALIAS("platform:s3c-rtc");
diff -Nur linux-2.6.29/drivers/sensor/accel/bma020_acc.c linux-2.6.29-spica/drivers/sensor/accel/bma020_acc.c
--- linux-2.6.29/drivers/sensor/accel/bma020_acc.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/accel/bma020_acc.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,456 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/device.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+
+#include "bma020_acc.h"
+
+/* add by inter.park */
+//extern void enable_acc_pins(void);
+
+struct class *acc_class;
+
+/* no use */
+//static int bma020_irq_num = NO_IRQ;
+
+/* create bma020 object */
+bma020_t bma020;
+
+/* create bma020 registers object */
+bma020regs_t bma020regs;
+
+#if 0
+static irqreturn_t bma020_acc_isr( int irq, void *unused, struct pt_regs *regs )
+{
+	printk( "bma020_acc_isr event occur!!!\n" );
+	
+	return IRQ_HANDLED;
+}
+#endif
+
+
+int bma020_open (struct inode *inode, struct file *filp)
+{
+	gprintk("start\n");
+	return 0;
+}
+
+ssize_t bma020_read(struct file *filp, char *buf, size_t count, loff_t *f_pos)
+{
+	return 0;
+}
+
+ssize_t bma020_write (struct file *filp, const char *buf, size_t count, loff_t *f_pos)
+{
+	return 0;
+}
+
+int bma020_release (struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+#if 0
+int bma020_ioctl(struct inode *inode, struct file *filp, unsigned int ioctl_num,  unsigned long arg)
+{
+	bma020acc_t accels;
+	unsigned int arg_data; 
+	int err = 0;
+	
+	gprintk("start\n");
+	switch( ioctl_num )
+	{
+		case IOCTL_BMA020_GET_ACC_VALUE :
+			{
+				bma020_read_accel_xyz( &accels );
+
+				gprintk( "acc data x = %d  /  y =  %d  /  z = %d\n", accels.x, accels.y, accels.z );
+				
+				if( copy_to_user( (bma020acc_t*)arg, &accels, sizeof(bma020acc_t) ) )
+				{
+					err = -EFAULT;
+				}   
+
+			}
+			break;
+		
+		case IOC_SET_ACCELEROMETER :  
+			{
+				if( copy_from_user( (unsigned int*)&arg_data, (unsigned int*)arg, sizeof(unsigned int) ) )
+				{
+				
+				}
+				if( arg_data == BMA020_POWER_ON )
+				{
+					printk( "ioctl : bma020 power on\n" );
+					bma020_set_mode( BMA020_MODE_NORMAL );
+				}
+				else
+				{
+					printk( "ioctl : bma020 power off\n" );
+					bma020_set_mode( BMA020_MODE_SLEEP );
+				}
+			}
+			break;
+		default : 
+			break;
+	}
+	return err;
+	
+}
+#endif
+
+
+int bma020_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,  unsigned long arg)
+{
+	int err = 0;
+	unsigned char data[6];
+
+	/* check cmd */
+	if(_IOC_TYPE(cmd) != BMA150_IOC_MAGIC)
+	{
+#if DEBUG       
+		printk("cmd magic type error\n");
+#endif
+		return -ENOTTY;
+	}
+	if(_IOC_NR(cmd) > BMA150_IOC_MAXNR)
+	{
+#if DEBUG
+		printk("cmd number error\n");
+#endif
+		return -ENOTTY;
+	}
+
+	if(_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE,(void __user*)arg, _IOC_SIZE(cmd));
+	else if(_IOC_DIR(cmd) & _IOC_WRITE)
+		err = !access_ok(VERIFY_READ, (void __user*)arg, _IOC_SIZE(cmd));
+	if(err)
+	{
+#if DEBUG
+		printk("cmd access_ok error\n");
+#endif
+		return -EFAULT;
+	}
+	#if 0
+	/* check bam150_client */
+	if( bma150_client == NULL)
+	{
+#if DEBUG
+		printk("I2C driver not install\n");
+#endif
+		return -EFAULT;
+	}
+	#endif
+
+	switch(cmd)
+	{
+		case BMA150_READ_ACCEL_XYZ:
+			err = bma020_read_accel_xyz((bma020acc_t*)data);
+//			printk("#### %s (%d)(%d)(%d)\n", __func__, ((bma020acc_t*)data)->x, ((bma020acc_t*)data)->y, ((bma020acc_t*)data)->z);
+			if(copy_to_user((bma020acc_t*)arg,(bma020acc_t*)data,6)!=0)
+			{
+#if DEBUG
+				printk("copy_to error\n");
+#endif
+				return -EFAULT;
+			}
+			return err;
+
+		case BMA150_SET_RANGE:
+			if(copy_from_user(data,(unsigned char*)arg,1)!=0)
+			{
+#if DEBUG           
+				printk("[BMA150] copy_from_user error\n");
+#endif
+				return -EFAULT;
+			}
+			err = bma020_set_range(*data);
+			return err;
+		
+		case BMA150_SET_MODE:
+			if(copy_from_user(data,(unsigned char*)arg,1)!=0)
+			{
+#if DEBUG           
+				printk("[BMA150] copy_from_user error\n");
+#endif
+				return -EFAULT;
+			}
+			err = bma020_set_mode(*data);
+			return err;
+
+		case BMA150_SET_BANDWIDTH:
+			if(copy_from_user(data,(unsigned char*)arg,1)!=0)
+			{
+#if DEBUG
+				printk("[BMA150] copy_from_user error\n");
+#endif
+				return -EFAULT;
+			}
+			err = bma020_set_bandwidth(*data);
+			return err;
+		case BMA150_CALIBRATE:
+			{
+			printk("#### BMA150_CALIBRATE\n");
+			bma020acc_t data = bma020_calibrate();
+			printk("## Calibration finished. (%d) (%d) (%d)\n", data.x, data.y, data.z);
+			}
+		default:
+			return 0;
+	}
+}
+
+struct file_operations acc_fops =
+{
+	.owner   = THIS_MODULE,
+	.read    = bma020_read,
+	.write   = bma020_write,
+	.open    = bma020_open,
+	.ioctl   = bma020_ioctl,
+	.release = bma020_release,
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bma020_early_suspend(struct early_suspend *handler)
+{
+	printk("#BMA020:SLEEP\n");
+	bma020_set_mode( BMA020_MODE_SLEEP );
+}
+
+static void bma020_early_resume(struct early_suspend *handler)
+{
+	printk("#BMA020:RESUME\n");
+	bma020_set_mode( BMA020_MODE_NORMAL );
+}
+#endif /* CONFIG_HAS_EARLYSUSPEND */ 
+
+void bma020_chip_init(void)
+{
+	/*assign register memory to bma020 object */
+	bma020.image = &bma020regs;
+
+	bma020.bma020_bus_write = i2c_acc_bma020_write;
+	bma020.bma020_bus_read  = i2c_acc_bma020_read;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	bma020.early_suspend.suspend = bma020_early_suspend;
+	bma020.early_suspend.resume = bma020_early_resume;
+	register_early_suspend(&bma020.early_suspend);
+#endif
+
+	/*call init function to set read write functions, read registers */
+	bma020_init( &bma020 );
+
+	/* from this point everything is prepared for sensor communication */
+
+
+	/* set range to 2G mode, other constants: 
+	 * 	   			4G: BMA020_RANGE_4G, 
+	 * 	    		8G: BMA020_RANGE_8G */
+
+	bma020_set_range(BMA020_RANGE_2G); 
+
+	/* set bandwidth to 25 HZ */
+	bma020_set_bandwidth(BMA020_BW_25HZ);
+
+	/* for interrupt setting */
+//	bma020_set_low_g_threshold( BMA020_HG_THRES_IN_G(0.35, 2) );
+
+//	bma020_set_interrupt_mask( BMA020_INT_LG );
+
+}
+
+int bma020_acc_start(void)
+{
+	int result;
+
+	struct device *dev_t;
+	
+	bma020acc_t accels; /* only for test */
+	
+	result = register_chrdev( BMA150_MAJOR, "bma150", &acc_fops);
+
+	if (result < 0) 
+	{
+		return result;
+	}
+	
+	acc_class = class_create (THIS_MODULE, "BMA-dev");
+	
+	if (IS_ERR(acc_class)) 
+	{
+		unregister_chrdev( BMA150_MAJOR, "bma150" );
+		return PTR_ERR( acc_class );
+	}
+
+	dev_t = device_create( acc_class, NULL, MKDEV(BMA150_MAJOR, 0), "%s", "bma150");
+
+	if (IS_ERR(dev_t)) 
+	{
+		return PTR_ERR(dev_t);
+	}
+	
+	result = i2c_acc_bma020_init();
+
+	if(result)
+	{
+		return result;
+	}
+
+	bma020_chip_init();
+
+	gprintk("[BMA020] read_xyz ==========================\n");
+	bma020_read_accel_xyz( &accels );
+	gprintk("[BMA020] x = %d  /  y =  %d  /  z = %d\n", accels.x, accels.y, accels.z );
+
+	gprintk("[BMA020] ===================================\n");
+	
+	/* only for test */
+	#if 0
+	printk( "before get xyz\n" );
+	mdelay(3000);
+
+	while(1)
+	{
+		bma020_read_accel_xyz( &accels );
+
+		printk( "acc data x = %d  /  y =  %d  /  z = %d\n", accels.x, accels.y, accels.z );
+	
+		mdelay(100);
+	}
+	#endif
+
+	bma020_set_mode(BMA020_MODE_SLEEP);
+	gprintk("[BMA020] set_mode BMA020_MODE_SLEEP\n");
+	
+	return 0;
+}
+
+void bma020_acc_end(void)
+{
+	unregister_chrdev( BMA150_MAJOR, "bma150" );
+	
+	i2c_acc_bma020_exit();
+
+	device_destroy( acc_class, MKDEV(BMA150_MAJOR, 0) );
+	class_destroy( acc_class );
+	unregister_early_suspend(&bma020.early_suspend);
+}
+
+
+static int bma020_accelerometer_probe( struct platform_device* pdev )
+{
+/* not use interrupt */
+#if 0	
+	int ret;
+
+	//enable_acc_pins();
+	/*
+	mhn_gpio_set_direction(MFP_ACC_INT, GPIO_DIR_IN);
+	mhn_mfp_set_pull(MFP_ACC_INT, MFP_PULL_HIGH);
+	*/
+
+	bma020_irq_num = platform_get_irq(pdev, 0);
+	ret = request_irq(bma020_irq_num, (void *)bma020_acc_isr, IRQF_DISABLED, pdev->name, NULL);
+	if(ret) {
+		printk("[BMA020 ACC] isr register error\n");
+		return ret;
+	}
+
+	//set_irq_type (bma020_irq_num, IRQT_BOTHEDGE);
+	
+	/* if( request_irq( IRQ_GPIO( MFP2GPIO(MFP_ACC_INT) ), (void *) bma020_acc_isr, 0, "BMA020_ACC_ISR", (void *)0 ) )
+	if(
+	{
+		printk ("[BMA020 ACC] isr register error\n" );
+	}
+	else
+	{
+		printk( "[BMA020 ACC] isr register success!!!\n" );
+	}*/
+	
+	// set_irq_type ( IRQ_GPIO( MFP2GPIO(MFP_ACC_INT) ), IRQT_BOTHEDGE );
+
+	/* if interrupt don't register Process don't stop for polling mode */ 
+
+#endif 
+	return bma020_acc_start();
+}
+
+
+static int bma020_accelerometer_suspend( struct platform_device* pdev, pm_message_t state )
+{
+	return 0;
+}
+
+
+static int bma020_accelerometer_resume( struct platform_device* pdev )
+{
+	return 0;
+}
+
+
+static struct platform_device *bma020_accelerometer_device;
+
+static struct platform_driver bma020_accelerometer_driver = {
+	.probe 	 = bma020_accelerometer_probe,
+	.suspend = bma020_accelerometer_suspend,
+	.resume  = bma020_accelerometer_resume,
+	.driver  = {
+		.name = "bma020-accelerometer", 
+	}
+};
+
+
+static int __init bma020_acc_init(void)
+{
+	int result;
+
+	result = platform_driver_register( &bma020_accelerometer_driver );
+
+	if( result ) 
+	{
+		return result;
+	}
+
+	bma020_accelerometer_device  = platform_device_register_simple( "bma020-accelerometer", -1, NULL, 0 );
+	
+	if( IS_ERR( bma020_accelerometer_device ) )
+	{
+		return PTR_ERR( bma020_accelerometer_device );
+	}
+
+	return 0;
+}
+
+
+static void __exit bma020_acc_exit(void)
+{
+	gprintk("start\n");
+	bma020_acc_end();
+
+//	free_irq(bma020_irq_num, NULL);
+//	free_irq( IRQ_GPIO( MFP2GPIO( MFP_ACC_INT ) ), (void*)0 );
+
+	platform_device_unregister( bma020_accelerometer_device );
+	platform_driver_unregister( &bma020_accelerometer_driver );
+}
+
+
+module_init( bma020_acc_init );
+module_exit( bma020_acc_exit );
+
+MODULE_AUTHOR("inter.park");
+MODULE_DESCRIPTION("accelerometer driver for BMA020");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/sensor/accel/bma020_acc.h linux-2.6.29-spica/drivers/sensor/accel/bma020_acc.h
--- linux-2.6.29/drivers/sensor/accel/bma020_acc.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/accel/bma020_acc.h	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,21 @@
+#ifndef __BMA020_ACC_HEADER__
+#define __BMA020_ACC_HEADER__
+
+#include "bma020_i2c.h"
+#include "bma020.h"
+
+#define ACC_DEV_NAME "accelerometer"
+#define ACC_DEV_MAJOR 241
+
+#define BMA150_MAJOR 	100
+
+/* bma020 ioctl command label */
+#define IOCTL_BMA020_GET_ACC_VALUE		0
+#define DCM_IOC_MAGIC			's'
+#define IOC_SET_ACCELEROMETER	_IO (DCM_IOC_MAGIC, 0x64)
+
+
+#define BMA020_POWER_OFF               0
+#define BMA020_POWER_ON                1
+
+#endif
diff -Nur linux-2.6.29/drivers/sensor/accel/bma020.c linux-2.6.29-spica/drivers/sensor/accel/bma020.c
--- linux-2.6.29/drivers/sensor/accel/bma020.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/accel/bma020.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,936 @@
+
+#include "bma020.h"
+
+
+bma020_t *p_bma020;				/**< pointer to BMA020 device structure  */
+
+bma020acc_t cal_data;
+
+int bma020_init(bma020_t *bma020) 
+{
+	int comres=0;
+	unsigned char data;
+
+	p_bma020 = bma020;															/* assign bma020 ptr */
+	p_bma020->dev_addr = BMA020_I2C_ADDR;										/* preset SM380 I2C_addr */
+	comres += p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, CHIP_ID__REG, &data, 1);	/* read Chip Id */
+	
+	p_bma020->chip_id = BMA020_GET_BITSLICE(data, CHIP_ID);			/* get bitslice */
+		
+	comres += p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, ML_VERSION__REG, &data, 1); /* read Version reg */
+	p_bma020->ml_version = BMA020_GET_BITSLICE(data, ML_VERSION);	/* get ML Version */
+	p_bma020->al_version = BMA020_GET_BITSLICE(data, AL_VERSION);	/* get AL Version */
+
+	return comres;
+
+}
+
+int bma020_soft_reset() 
+{
+	int comres;
+	unsigned char data=0;
+	
+	if (p_bma020==0) 
+		return E_BMA020_NULL_PTR;
+	
+	data = BMA020_SET_BITSLICE(data, SOFT_RESET, 1);
+    comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, SOFT_RESET__REG, &data,1); 
+	
+	return comres;
+}
+
+#if 0
+int bma020_update_image() 
+{
+	int comres;
+	unsigned char data=0;
+	
+	if (p_bma020==0) 
+		return E_BMA020_NULL_PTR;
+	
+	data = BMA020_SET_BITSLICE(data, UPDATE_IMAGE, 1);
+    comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, UPDATE_IMAGE__REG, &data,1); 
+	
+	return comres;
+}
+
+
+int bma020_set_image (bma020regs_t *bma020Image) 
+{
+	int comres;
+	unsigned char data;
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+    
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, EE_W__REG,&data, 1);
+	data = BMA020_SET_BITSLICE(data, EE_W, BMA020_EE_W_ON);
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, EE_W__REG, &data, 1);
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, BMA020_IMAGE_BASE, (unsigned char*)bma020Image, BMA020_IMAGE_LEN);
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, EE_W__REG,&data, 1);
+	data = BMA020_SET_BITSLICE(data, EE_W, BMA020_EE_W_OFF);
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, EE_W__REG, &data, 1);
+	
+	return comres;
+}
+
+
+
+int bma020_get_image(bma020regs_t *bma020Image)
+{
+	int comres;
+	unsigned char data;
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+    
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, EE_W__REG,&data, 1);
+	data = BMA020_SET_BITSLICE(data, EE_W, BMA020_EE_W_ON);
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, EE_W__REG, &data, 1);
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, BMA020_IMAGE_BASE, (unsigned char *)bma020Image, BMA020_IMAGE_LEN);
+	data = BMA020_SET_BITSLICE(data, EE_W, BMA020_EE_W_OFF);
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, EE_W__REG, &data, 1);
+	
+	return comres;
+}
+
+int bma020_get_offset(unsigned char xyz, unsigned short *offset) 
+{
+   int comres;
+   unsigned char data;
+   
+   if (p_bma020==0)
+   		return E_BMA020_NULL_PTR;
+   
+   comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, (OFFSET_X_LSB__REG+xyz), &data, 1);
+   data = BMA020_GET_BITSLICE(data, OFFSET_X_LSB);
+   *offset = data;
+   comres += p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, (OFFSET_X_MSB__REG+xyz), &data, 1);
+   *offset |= (data<<2);
+   
+   return comres;
+}
+
+
+int bma020_set_offset(unsigned char xyz, unsigned short offset) 
+{
+   int comres;
+   unsigned char data;
+   
+   if (p_bma020==0)
+   		return E_BMA020_NULL_PTR;
+   
+   comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, (OFFSET_X_LSB__REG+xyz), &data, 1);
+   data = BMA020_SET_BITSLICE(data, OFFSET_X_LSB, offset);
+   comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, (OFFSET_X_LSB__REG+xyz), &data, 1);
+   data = (offset&0x3ff)>>2;
+   comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, (OFFSET_X_MSB__REG+xyz), &data, 1);
+   
+   return comres;
+}
+
+
+int bma020_set_offset_eeprom(unsigned char xyz, unsigned short offset) 
+{
+   int comres;
+   unsigned char data;
+   
+   if (p_bma020==0)
+   		return E_BMA020_NULL_PTR;   
+   
+   comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, (OFFSET_X_LSB__REG+xyz), &data, 1);
+   data = BMA020_SET_BITSLICE(data, OFFSET_X_LSB, offset);
+   comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, (BMA020_EEP_OFFSET+OFFSET_X_LSB__REG + xyz), &data, 1);   
+   p_bma020->delay_msec(34);
+   data = (offset&0x3ff)>>2;
+   comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, (BMA020_EEP_OFFSET+ OFFSET_X_MSB__REG+xyz), &data, 1);
+   p_bma020->delay_msec(34);
+   
+   return comres;
+}
+
+
+
+
+int bma020_set_ee_w(unsigned char eew)
+{
+    unsigned char data;
+	int comres;
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+    
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, EE_W__REG,&data, 1);
+	data = BMA020_SET_BITSLICE(data, EE_W, eew);
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, EE_W__REG, &data, 1);
+	
+	return comres;
+}
+
+
+
+int bma020_write_ee(unsigned char addr, unsigned char data) 
+{	
+	int comres;
+	
+	if (p_bma020==0) 			/* check pointers */
+		return E_BMA020_NULL_PTR;
+    
+	if (p_bma020->delay_msec == 0)
+	    return E_BMA020_NULL_PTR;
+    
+	comres = bma020_set_ee_w( BMA020_EE_W_ON );
+	addr|=0x20;   /* add eeprom address offset to image address if not applied */
+	comres += bma020_write_reg(addr, &data, 1 );
+	p_bma020->delay_msec( BMA020_EE_W_DELAY );
+	comres += bma020_set_ee_w( BMA020_EE_W_OFF);
+	
+	return comres;
+}
+#endif
+
+
+int bma020_selftest(unsigned char st)
+{
+	int comres;
+	unsigned char data;
+	
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, SELF_TEST__REG, &data, 1);
+	data = BMA020_SET_BITSLICE(data, SELF_TEST, st);
+	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, SELF_TEST__REG, &data, 1);  
+	
+	return comres;  
+
+}
+
+
+int bma020_set_range(char range) 
+{			
+   int comres = 0;
+   unsigned char data;
+
+   if (p_bma020==0)
+	    return E_BMA020_NULL_PTR;
+
+   if (range<3) 
+   {	
+	 	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, RANGE__REG, &data, 1 );
+	 	data = BMA020_SET_BITSLICE(data, RANGE, range);		  	
+		comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, RANGE__REG, &data, 1);
+   }
+   
+   return comres;
+
+}
+
+
+int bma020_get_range(unsigned char *range) 
+{
+	int comres = 0;
+	
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+	
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, RANGE__REG, range, 1 );
+
+	*range = BMA020_GET_BITSLICE(*range, RANGE);
+	
+	return comres;
+
+}
+
+
+int bma020_set_mode(unsigned char mode) {
+	
+	int comres=0;
+	unsigned char data1, data2;
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	if (mode<4 || mode!=1) 
+	{
+		comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, WAKE_UP__REG, &data1, 1 );
+		data1  = BMA020_SET_BITSLICE(data1, WAKE_UP, mode);		  
+        comres += p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, SLEEP__REG, &data2, 1 );
+		data2  = BMA020_SET_BITSLICE(data2, SLEEP, (mode>>1));
+    	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, WAKE_UP__REG, &data1, 1);
+	  	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, SLEEP__REG, &data2, 1);
+	  	p_bma020->mode = mode;
+	} 
+	
+	return comres;
+	
+}
+
+
+
+unsigned char bma020_get_mode(void) 
+{
+    if (p_bma020==0)
+    	return E_BMA020_NULL_PTR;	
+	
+	return p_bma020->mode;
+	
+}
+
+int bma020_set_bandwidth(char bw) 
+{
+	int comres = 0;
+	unsigned char data;
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	if (bw<8) 
+	{
+  	  comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, RANGE__REG, &data, 1 );
+	  data = BMA020_SET_BITSLICE(data, BANDWIDTH, bw);
+	  comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, RANGE__REG, &data, 1 );
+	}
+
+	return comres;
+
+
+}
+
+
+int bma020_get_bandwidth(unsigned char *bw) 
+{
+	int comres = 1;
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, BANDWIDTH__REG, bw, 1 );		
+
+	*bw = BMA020_GET_BITSLICE(*bw, BANDWIDTH);
+	
+	return comres;
+}
+
+int bma020_set_wake_up_pause(unsigned char wup)
+{
+	int comres=0;
+	unsigned char data;
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, WAKE_UP_PAUSE__REG, &data, 1 );
+	data = BMA020_SET_BITSLICE(data, WAKE_UP_PAUSE, wup);
+	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, WAKE_UP_PAUSE__REG, &data, 1 );
+	
+	return comres;
+}
+
+int bma020_get_wake_up_pause(unsigned char *wup)
+{
+    int comres = 1;
+	unsigned char data;
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, WAKE_UP_PAUSE__REG, &data,  1 );		
+	
+	*wup = BMA020_GET_BITSLICE(data, WAKE_UP_PAUSE);
+	
+	return comres;
+
+}
+
+
+int bma020_set_low_g_threshold(unsigned char th) 
+{
+	int comres;	
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;		
+
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, LG_THRES__REG, &th, 1);
+
+	return comres;
+}
+
+
+int bma020_get_low_g_threshold(unsigned char *th)
+{
+
+	int comres=1;	
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;	
+
+		comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, LG_THRES__REG, th, 1);		
+
+	return comres;
+
+}
+
+
+int bma020_set_low_g_countdown(unsigned char cnt)
+{
+	int comres=0;
+	unsigned char data;
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+	
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, COUNTER_LG__REG, &data, 1 );
+	data = BMA020_SET_BITSLICE(data, COUNTER_LG, cnt);
+	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, COUNTER_LG__REG, &data, 1 );
+	
+	return comres;
+}
+
+
+int bma020_get_low_g_countdown(unsigned char *cnt)
+{
+    int comres = 1;
+	unsigned char data;
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, COUNTER_LG__REG, &data,  1 );		
+	*cnt = BMA020_GET_BITSLICE(data, COUNTER_LG);
+	
+	return comres;
+}
+
+
+int bma020_set_high_g_countdown(unsigned char cnt)
+{
+	int comres=1;
+	unsigned char data;
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+    comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, COUNTER_HG__REG, &data, 1 );
+	data = BMA020_SET_BITSLICE(data, COUNTER_HG, cnt);
+	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, COUNTER_HG__REG, &data, 1 );
+	
+	return comres;
+}
+
+
+int bma020_get_high_g_countdown(unsigned char *cnt)
+{
+    int comres = 0;
+	unsigned char data;
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+	
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, COUNTER_HG__REG, &data,  1 );		
+	
+	*cnt = BMA020_GET_BITSLICE(data, COUNTER_HG);
+	
+	return comres;
+
+}
+
+
+int bma020_set_low_g_duration(unsigned char dur) 
+{
+	int comres=0;	
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+		
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, LG_DUR__REG, &dur, 1);
+
+	return comres;
+}
+
+
+int bma020_get_low_g_duration(unsigned char *dur) {
+	
+	int comres=0;	
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, LG_DUR__REG, dur, 1);				  
+	
+	return comres;
+}
+
+
+int bma020_set_high_g_threshold(unsigned char th) 
+{
+	int comres=0;	
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, HG_THRES__REG, &th, 1);
+	
+	return comres;
+}
+
+int bma020_get_high_g_threshold(unsigned char *th)
+{
+	int comres=0;
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, HG_THRES__REG, th, 1);		
+
+	return comres;
+}
+
+
+
+int bma020_set_high_g_duration(unsigned char dur) 
+{
+	int comres=0;	
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, HG_DUR__REG, &dur, 1);
+
+	return comres;
+}
+
+
+int bma020_get_high_g_duration(unsigned char *dur) {	
+	
+	int comres=0;
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+			
+    comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, HG_DUR__REG, dur, 1);		
+
+	return comres;
+}
+
+
+int bma020_set_any_motion_threshold(unsigned char th) 
+{
+	int comres=0;	
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, ANY_MOTION_THRES__REG, &th, 1);
+
+	return comres;
+}
+
+
+int bma020_get_any_motion_threshold(unsigned char *th)
+{
+	int comres=0;
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+	
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, ANY_MOTION_THRES__REG, th, 1);		
+
+	return comres;
+
+}
+
+
+int bma020_set_any_motion_count(unsigned char amc)
+{
+	int comres=0;	
+	unsigned char data;
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+ 	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, ANY_MOTION_DUR__REG, &data, 1 );
+	data = BMA020_SET_BITSLICE(data, ANY_MOTION_DUR, amc);
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, ANY_MOTION_DUR__REG, &data, 1 );
+	
+	return comres;
+}
+
+
+int bma020_get_any_motion_count(unsigned char *amc)
+{
+    int comres = 0;
+	unsigned char data;
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, ANY_MOTION_DUR__REG, &data,  1 );		
+	
+	*amc = BMA020_GET_BITSLICE(data, ANY_MOTION_DUR);
+	
+	return comres;
+}
+
+
+
+int bma020_set_interrupt_mask(unsigned char mask) 
+{
+	int comres=0;
+	unsigned char data[4];
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+	
+	data[0] = mask & BMA020_CONF1_INT_MSK;
+	data[2] = ((mask<<1) & BMA020_CONF2_INT_MSK);		
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, BMA020_CONF1_REG, &data[1], 1);
+	comres += p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, BMA020_CONF2_REG, &data[3], 1);		
+	
+	data[1] &= (~BMA020_CONF1_INT_MSK);
+	data[1] |= data[0];
+	data[3] &=(~(BMA020_CONF2_INT_MSK));
+	data[3] |= data[2];
+
+	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, BMA020_CONF1_REG, &data[1], 1);
+	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, BMA020_CONF2_REG, &data[3], 1);
+
+	return comres;	
+}
+
+
+int bma020_get_interrupt_mask(unsigned char *mask) 
+{
+	int comres=0;
+	unsigned char data;
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, BMA020_CONF1_REG, &data,1);
+	*mask = data & BMA020_CONF1_INT_MSK;
+	p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, BMA020_CONF2_REG, &data,1);
+	*mask = *mask | ((data & BMA020_CONF2_INT_MSK)>>1);
+
+	return comres;
+}
+
+
+int bma020_reset_interrupt(void) 
+{	
+	int comres=0;
+	unsigned char data=(1<<RESET_INT__POS);	
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, RESET_INT__REG, &data, 1);
+	return comres;
+
+}
+
+
+int bma020_read_accel_x(short *a_x) 
+{
+	int comres;
+	unsigned char data[2];
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, ACC_X_LSB__REG, data, 2);
+	
+	*a_x = BMA020_GET_BITSLICE(data[0],ACC_X_LSB) | BMA020_GET_BITSLICE(data[1],ACC_X_MSB)<<ACC_X_LSB__LEN;
+	*a_x = *a_x << (sizeof(short)*8-(ACC_X_LSB__LEN+ACC_X_MSB__LEN));
+	*a_x = *a_x >> (sizeof(short)*8-(ACC_X_LSB__LEN+ACC_X_MSB__LEN));
+	
+	return comres;
+	
+}
+
+
+int bma020_read_accel_y(short *a_y) 
+{
+	int comres;
+	unsigned char data[2];	
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, ACC_Y_LSB__REG, data, 2);
+	
+	*a_y = BMA020_GET_BITSLICE(data[0],ACC_Y_LSB) | BMA020_GET_BITSLICE(data[1],ACC_Y_MSB)<<ACC_Y_LSB__LEN;
+	*a_y = *a_y << (sizeof(short)*8-(ACC_Y_LSB__LEN+ACC_Y_MSB__LEN));
+	*a_y = *a_y >> (sizeof(short)*8-(ACC_Y_LSB__LEN+ACC_Y_MSB__LEN));
+	
+	return comres;
+}
+
+
+/** Z-axis acceleration data readout 
+	\param *a_z pointer for 16 bit 2's complement data output (LSB aligned)
+*/
+int bma020_read_accel_z(short *a_z)
+{
+	int comres;
+	unsigned char data[2];	
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, ACC_Z_LSB__REG, data, 2);
+	
+	*a_z = BMA020_GET_BITSLICE(data[0],ACC_Z_LSB) | BMA020_GET_BITSLICE(data[1],ACC_Z_MSB)<<ACC_Z_LSB__LEN;
+	*a_z = *a_z << (sizeof(short)*8-(ACC_Z_LSB__LEN+ACC_Z_MSB__LEN));
+	*a_z = *a_z >> (sizeof(short)*8-(ACC_Z_LSB__LEN+ACC_Z_MSB__LEN));
+	
+	return comres;
+}
+
+#if 0
+int bma020_read_temperature(unsigned char * temp) 
+{
+	int comres;	
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, TEMPERATURE__REG, temp, 1);
+	
+	return comres;
+
+}
+#endif
+
+
+int bma020_read_accel_xyz(bma020acc_t * acc)
+{
+	int comres;
+	unsigned char data[6];
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+	
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, ACC_X_LSB__REG, &data[0],6);
+	
+	acc->x = BMA020_GET_BITSLICE(data[0],ACC_X_LSB) | (BMA020_GET_BITSLICE(data[1],ACC_X_MSB)<<ACC_X_LSB__LEN);
+	acc->x = acc->x << (sizeof(short)*8-(ACC_X_LSB__LEN+ACC_X_MSB__LEN));
+	acc->x = acc->x >> (sizeof(short)*8-(ACC_X_LSB__LEN+ACC_X_MSB__LEN));
+
+	acc->y = BMA020_GET_BITSLICE(data[2],ACC_Y_LSB) | (BMA020_GET_BITSLICE(data[3],ACC_Y_MSB)<<ACC_Y_LSB__LEN);
+	acc->y = acc->y << (sizeof(short)*8-(ACC_Y_LSB__LEN + ACC_Y_MSB__LEN));
+	acc->y = acc->y >> (sizeof(short)*8-(ACC_Y_LSB__LEN + ACC_Y_MSB__LEN));
+	
+/*	
+	acc->z = BMA020_GET_BITSLICE(data[4],ACC_Z_LSB); 
+	acc->z |= (BMA020_GET_BITSLICE(data[5],ACC_Z_MSB)<<ACC_Z_LSB__LEN);
+	acc->z = acc->z << (sizeof(short)*8-(ACC_Z_LSB__LEN+ACC_Z_MSB__LEN));
+	acc->z = acc->z >> (sizeof(short)*8-(ACC_Z_LSB__LEN+ACC_Z_MSB__LEN));
+*/	
+	acc->z = BMA020_GET_BITSLICE(data[4],ACC_Z_LSB) | (BMA020_GET_BITSLICE(data[5],ACC_Z_MSB)<<ACC_Z_LSB__LEN);
+	acc->z = acc->z << (sizeof(short)*8-(ACC_Z_LSB__LEN + ACC_Z_MSB__LEN));
+	acc->z = acc->z >> (sizeof(short)*8-(ACC_Z_LSB__LEN + ACC_Z_MSB__LEN));
+
+	acc->x -= cal_data.x;
+	acc->y -= cal_data.y;
+	acc->z -= cal_data.z;
+	
+	return comres;
+}
+
+
+int bma020_get_interrupt_status(unsigned char * ist) 
+{
+
+	int comres=0;	
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+	
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, BMA020_STATUS_REG, ist, 1);
+	
+	return comres;
+}
+
+
+int bma020_set_low_g_int(unsigned char onoff) {
+	int comres;
+	unsigned char data;
+	
+	if(p_bma020==0) 
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, ENABLE_LG__REG, &data, 1);				
+	
+	data = BMA020_SET_BITSLICE(data, ENABLE_LG, onoff);
+	
+	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, ENABLE_LG__REG, &data, 1);
+	
+	return comres;
+}
+
+
+int bma020_set_high_g_int(unsigned char onoff) 
+{
+	int comres;
+	
+	unsigned char data;
+	
+	if(p_bma020==0) 
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, ENABLE_HG__REG, &data, 1);				
+	
+	data = BMA020_SET_BITSLICE(data, ENABLE_HG, onoff);
+	
+	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, ENABLE_HG__REG, &data, 1);
+	
+	return comres;
+}
+
+
+int bma020_set_any_motion_int(unsigned char onoff) {
+	int comres;
+	
+	unsigned char data;
+	
+	if(p_bma020==0) 
+		return E_BMA020_NULL_PTR;
+	
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, EN_ANY_MOTION__REG, &data, 1);				
+	data = BMA020_SET_BITSLICE(data, EN_ANY_MOTION, onoff);
+	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, EN_ANY_MOTION__REG, &data, 1);
+	
+	return comres;
+
+}
+
+
+int bma020_set_alert_int(unsigned char onoff) 
+{
+	int comres;
+	unsigned char data;
+	
+	if(p_bma020==0) 
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, ALERT__REG, &data, 1);				
+	data = BMA020_SET_BITSLICE(data, ALERT, onoff);
+	
+	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, ALERT__REG, &data, 1);
+	
+	return comres;
+
+}
+
+
+int bma020_set_advanced_int(unsigned char onoff) 
+{
+	int comres;
+	unsigned char data;
+
+	if(p_bma020==0) 
+		return E_BMA020_NULL_PTR;
+	
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, ENABLE_ADV_INT__REG, &data, 1);				
+	data = BMA020_SET_BITSLICE(data, EN_ANY_MOTION, onoff);
+
+	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, ENABLE_ADV_INT__REG, &data, 1);
+	
+	return comres;
+}
+
+
+int bma020_latch_int(unsigned char latched) 
+{
+	int comres;
+	unsigned char data;
+	
+	if(p_bma020==0) 
+		return E_BMA020_NULL_PTR;
+	
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, LATCH_INT__REG, &data, 1);				
+	data = BMA020_SET_BITSLICE(data, LATCH_INT, latched);
+
+	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, LATCH_INT__REG, &data, 1);
+	
+	return comres;
+}
+
+
+int bma020_set_new_data_int(unsigned char onoff) 
+{
+	int comres;
+	unsigned char data;
+
+	if(p_bma020==0) 
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, NEW_DATA_INT__REG, &data, 1);				
+	data = BMA020_SET_BITSLICE(data, NEW_DATA_INT, onoff);
+	comres += p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, NEW_DATA_INT__REG, &data, 1);
+	
+	return comres;
+}
+
+
+int bma020_pause(int msec) 
+{
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+	else
+		p_bma020->delay_msec(msec);	
+
+	return msec;
+}
+
+
+int bma020_read_reg(unsigned char addr, unsigned char *data, unsigned char len)
+{
+	int comres;
+	
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_READ_FUNC(p_bma020->dev_addr, addr, data, len);
+	
+	return comres;
+}
+
+
+int bma020_write_reg(unsigned char addr, unsigned char *data, unsigned char len) 
+{
+	int comres;
+
+	if (p_bma020==0)
+		return E_BMA020_NULL_PTR;
+
+	comres = p_bma020->BMA020_BUS_WRITE_FUNC(p_bma020->dev_addr, addr, data, len);
+
+	return comres;
+}
+
+bma020acc_t bma020_calibrate()
+{
+	int sum_x = 0;
+	int sum_y = 0;
+	int sum_z = 0;
+	bma020acc_t cur_val;
+ 	int i = 0;
+
+	cal_data.x = cal_data.y = cal_data.z = 0;
+		
+	for(i = 0; i < 20; i++)
+		{
+		bma020_read_accel_xyz(&cur_val);
+		sum_x += cur_val.x;
+		sum_y += cur_val.y;
+		sum_z += cur_val.z;
+		}
+
+	cal_data.x = (sum_x / 20) - 0;
+	cal_data.y = (sum_y / 20) - 0;
+	cal_data.z = (sum_z / 20) - 256;
+
+	return cal_data;
+}
+
diff -Nur linux-2.6.29/drivers/sensor/accel/bma020.h linux-2.6.29-spica/drivers/sensor/accel/bma020.h
--- linux-2.6.29/drivers/sensor/accel/bma020.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/accel/bma020.h	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,837 @@
+#ifndef __BMA020_H__
+#define __BMA020_H__
+
+#include <linux/earlysuspend.h>
+
+/*********** for debug **********************************************************/
+#if 0 
+#define gprintk(fmt, x... ) printk( "[BMA020] %s(%d): " fmt, __FUNCTION__ ,__LINE__, ## x)
+#else
+#define gprintk(x...) do { } while (0)
+#endif 
+/*******************************************************************************/
+
+/* don't use SPI interface */
+#define BMA020_SPI_RD_MASK 0x80   /* for spi read transactions on SPI the MSB has to be set */
+
+
+/* They used to connect i2c_acc_bma020_write. */
+#define BMA020_WR_FUNC_PTR char (* bma020_bus_write)(unsigned char, unsigned char *)
+
+#define BMA020_BUS_WRITE_FUNC(dev_addr, reg_addr, reg_data, len)\
+          bma020_bus_write(reg_addr, reg_data)
+
+
+/* They used to connect i2c_acc_bma020_read. */
+#define BMA020_RD_FUNC_PTR char (* bma020_bus_read)( unsigned char, unsigned char *, unsigned int)
+
+#define BMA020_BUS_READ_FUNC( dev_addr, reg_addr, reg_data, r_len )\
+           bma020_bus_read( reg_addr , reg_data, r_len )
+
+
+/* BMA150 IOCTL */
+#define BMA150_IOC_MAGIC 				'B'
+#define BMA150_CALIBRATE				_IOW(BMA150_IOC_MAGIC,2, unsigned char)
+#define BMA150_SET_RANGE            	_IOWR(BMA150_IOC_MAGIC,4, unsigned char)
+#define BMA150_SET_MODE             	_IOWR(BMA150_IOC_MAGIC,6, unsigned char)
+#define BMA150_SET_BANDWIDTH            _IOWR(BMA150_IOC_MAGIC,8, unsigned char)
+#define BMA150_READ_ACCEL_XYZ           _IOWR(BMA150_IOC_MAGIC,46,short)
+#define BMA150_IOC_MAXNR            	48
+
+#define DEBUG							0
+
+/* BMA020 I2C Address */
+
+#define BMA020_I2C_ADDR		0x38
+
+
+/* BMA020 API error codes */
+
+#define E_BMA020_NULL_PTR		(char)-127
+#define E_COMM_RES		    (char)-1
+#define E_OUT_OF_RANGE		(char)-2
+
+
+
+/* register definitions */
+
+#define BMA020_EEP_OFFSET   0x20
+#define BMA020_IMAGE_BASE	0x0b
+#define BMA020_IMAGE_LEN	19
+
+#define CHIP_ID_REG			0x00
+#define VERSION_REG			0x01
+#define X_AXIS_LSB_REG		0x02
+#define X_AXIS_MSB_REG		0x03
+#define Y_AXIS_LSB_REG		0x04
+#define Y_AXIS_MSB_REG		0x05
+#define Z_AXIS_LSB_REG		0x06
+#define Z_AXIS_MSB_REG		0x07
+//#define TEMP_RD_REG			0x08
+#define BMA020_STATUS_REG	0x09
+#define BMA020_CTRL_REG		0x0a
+#define BMA020_CONF1_REG	0x0b
+#define LG_THRESHOLD_REG	0x0c
+#define LG_DURATION_REG		0x0d
+#define HG_THRESHOLD_REG	0x0e
+#define HG_DURATION_REG		0x0f
+#define MOTION_THRS_REG		0x10
+#define HYSTERESIS_REG		0x11
+#define CUSTOMER1_REG		0x12
+#define CUSTOMER2_REG		0x13
+#define RANGE_BWIDTH_REG	0x14
+#define BMA020_CONF2_REG	0x15
+
+#if 0
+#define OFFS_GAIN_X_REG		0x16
+#define OFFS_GAIN_Y_REG		0x17
+#define OFFS_GAIN_Z_REG		0x18
+#define OFFS_GAIN_T_REG		0x19
+#define OFFSET_X_REG		0x1a
+#define OFFSET_Y_REG		0x1b
+#define OFFSET_Z_REG		0x1c
+#define OFFSET_T_REG		0x1d
+#endif
+
+/* register write and read delays */
+
+#define MDELAY_DATA_TYPE	unsigned int
+#define BMA020_EE_W_DELAY 28	/* delay after EEP write is 28 msec */
+
+
+typedef struct  {
+		short x, /**< holds x-axis acceleration data sign extended. Range -512 to 511. */
+			  y, /**< holds y-axis acceleration data sign extended. Range -512 to 511. */
+			  z; /**< holds z-axis acceleration data sign extended. Range -512 to 511. */
+} bma020acc_t;
+
+
+typedef struct  {
+		unsigned char	
+		bma020_conf1 ,  /**<  image address 0x0b: interrupt enable bits, low-g settings */
+		lg_threshold,	/**<  image address 0x0c: low-g threshold, depends on selected g-range */
+		lg_duration,	/**<  image address 0x0d: low-g duration in ms */
+		hg_threshold,	/**<  image address 0x0e: high-g threshold, depends on selected g-range */
+		hg_duration,	/**<  image address 0x0f: high-g duration in ms */
+		motion_thrs,	/**<  image address 0x10: any motion threshold */
+		hysteresis,		/**<  image address 0x11: low-g and high-g hysteresis register */
+		customer1,		/**<  image address 0x12: customer reserved register 1 */
+		customer2,		/**<  image address 0x13: customer reserved register 2  */
+		range_bwidth,	/**<  image address 0x14: range and bandwidth selection register */
+		bma020_conf2;	/**<  image address 0x15: spi4, latched interrupt, auto-wake-up configuration */
+#if 0
+		offs_gain_x,	/**<  image address 0x16: offset_x LSB and x-axis gain settings */
+		offs_gain_y,	/**<  image address 0x17: offset_y LSB and y-axis gain settings */
+		offs_gain_z,	/**<  image address 0x18: offset_z LSB and z-axis gain settings */
+		offs_gain_t,	/**<  image address 0x19: offset_t LSB and temperature gain settings */
+		offset_x,		/**<  image address 0x1a: offset_x calibration MSB register */
+		offset_y,		/**<  image address 0x1b: offset_y calibration MSB register */ 
+		offset_z,		/**<  image address 0x1c: offset_z calibration MSB register */ 
+		offset_t;		/**<  image address 0x1d: temperature calibration MSB register */
+#endif
+} bma020regs_t;
+
+
+
+typedef struct {	
+	bma020regs_t * image;		/**< pointer to bma020regs_t structure not mandatory */
+	unsigned char mode;			/**< save current BMA020 operation mode */
+	unsigned char chip_id,		/**< save BMA020's chip id which has to be 0x02 after calling bma020_init() */
+				  ml_version, 	/**< holds the BMA020 ML_version number */	
+				  al_version;	/**< holds the BMA020 AL_version number */
+	unsigned char dev_addr;   	/**< initializes BMA020's I2C device address 0x38 */
+	unsigned char int_mask;	  	/**< stores the current BMA020 API generated interrupt mask */
+	BMA020_WR_FUNC_PTR;		  	/**< function pointer to the SPI/I2C write function */
+	BMA020_RD_FUNC_PTR;		  	/**< function pointer to the SPI/I2C read function */
+	void (*delay_msec)( MDELAY_DATA_TYPE ); /**< function pointer to a pause in mili seconds function */
+	struct early_suspend early_suspend;		/**< suspend function */
+} bma020_t;
+
+
+
+
+	
+/* bit slice positions in registers */
+
+/* cond BITSLICE */
+
+#define CHIP_ID__POS		0
+#define CHIP_ID__MSK		0x07
+#define CHIP_ID__LEN		3
+#define CHIP_ID__REG		CHIP_ID_REG
+
+
+#define ML_VERSION__POS		0
+#define ML_VERSION__LEN		4
+#define ML_VERSION__MSK		0x0F
+#define ML_VERSION__REG		VERSION_REG
+
+
+
+#define AL_VERSION__POS  	4
+#define AL_VERSION__LEN  	4
+#define AL_VERSION__MSK		0xF0
+#define AL_VERSION__REG		VERSION_REG
+
+
+
+/* DATA REGISTERS */
+
+#define NEW_DATA_X__POS  	0
+#define NEW_DATA_X__LEN  	1
+#define NEW_DATA_X__MSK  	0x01
+#define NEW_DATA_X__REG		X_AXIS_LSB_REG
+
+#define ACC_X_LSB__POS   	6
+#define ACC_X_LSB__LEN   	2
+#define ACC_X_LSB__MSK		0xC0
+#define ACC_X_LSB__REG		X_AXIS_LSB_REG
+
+#define ACC_X_MSB__POS   	0
+#define ACC_X_MSB__LEN   	8
+#define ACC_X_MSB__MSK		0xFF
+#define ACC_X_MSB__REG		X_AXIS_MSB_REG
+
+#define NEW_DATA_Y__POS  	0
+#define NEW_DATA_Y__LEN  	1
+#define NEW_DATA_Y__MSK  	0x01
+#define NEW_DATA_Y__REG		Y_AXIS_LSB_REG
+
+#define ACC_Y_LSB__POS   	6
+#define ACC_Y_LSB__LEN   	2
+#define ACC_Y_LSB__MSK   	0xC0
+#define ACC_Y_LSB__REG		Y_AXIS_LSB_REG
+
+#define ACC_Y_MSB__POS   	0
+#define ACC_Y_MSB__LEN   	8
+#define ACC_Y_MSB__MSK   	0xFF
+#define ACC_Y_MSB__REG		Y_AXIS_MSB_REG
+
+#define NEW_DATA_Z__POS  	0
+#define NEW_DATA_Z__LEN  	1
+#define NEW_DATA_Z__MSK		0x01
+#define NEW_DATA_Z__REG		Z_AXIS_LSB_REG
+
+#define ACC_Z_LSB__POS   	6
+#define ACC_Z_LSB__LEN   	2
+#define ACC_Z_LSB__MSK		0xC0
+#define ACC_Z_LSB__REG		Z_AXIS_LSB_REG
+
+#define ACC_Z_MSB__POS   	0
+#define ACC_Z_MSB__LEN   	8
+#define ACC_Z_MSB__MSK		0xFF
+#define ACC_Z_MSB__REG		Z_AXIS_MSB_REG
+
+#if 0
+#define TEMPERATURE__POS 	0
+#define TEMPERATURE__LEN 	8
+#define TEMPERATURE__MSK 	0xFF
+#define TEMPERATURE__REG	TEMP_RD_REG
+#endif
+
+
+
+/* STATUS BITS */
+
+#define STATUS_HG__POS		0
+#define STATUS_HG__LEN		1
+#define STATUS_HG__MSK		0x01
+#define STATUS_HG__REG		BMA020_STATUS_REG
+
+#define STATUS_LG__POS		1
+#define STATUS_LG__LEN		1
+#define STATUS_LG__MSK		0x02
+#define STATUS_LG__REG		BMA020_STATUS_REG
+
+#define HG_LATCHED__POS  	2
+#define HG_LATCHED__LEN  	1
+#define HG_LATCHED__MSK		0x04
+#define HG_LATCHED__REG		BMA020_STATUS_REG
+
+#define LG_LATCHED__POS		3
+#define LG_LATCHED__LEN		1
+#define LG_LATCHED__MSK		8
+#define LG_LATCHED__REG		BMA020_STATUS_REG
+
+#define ALERT_PHASE__POS	4
+#define ALERT_PHASE__LEN	1
+#define ALERT_PHASE__MSK	0x10
+#define ALERT_PHASE__REG	BMA020_STATUS_REG
+
+
+#define ST_RESULT__POS		7
+#define ST_RESULT__LEN		1
+#define ST_RESULT__MSK		0x80
+#define ST_RESULT__REG		BMA020_STATUS_REG
+
+
+/* CONTROL BITS */
+
+#define SLEEP__POS			0
+#define SLEEP__LEN			1
+#define SLEEP__MSK			0x01
+#define SLEEP__REG			BMA020_CTRL_REG
+
+#define SOFT_RESET__POS		1
+#define SOFT_RESET__LEN		1
+#define SOFT_RESET__MSK		0x02
+#define SOFT_RESET__REG		BMA020_CTRL_REG
+
+
+
+#define SELF_TEST__POS		2
+#define SELF_TEST__LEN		2
+#define SELF_TEST__MSK		0x0C
+#define SELF_TEST__REG		BMA020_CTRL_REG
+
+
+
+#define SELF_TEST0__POS		2
+#define SELF_TEST0__LEN		1
+#define SELF_TEST0__MSK		0x04
+#define SELF_TEST0__REG		BMA020_CTRL_REG
+
+#define SELF_TEST1__POS		3
+#define SELF_TEST1__LEN		1
+#define SELF_TEST1__MSK		0x08
+#define SELF_TEST1__REG		BMA020_CTRL_REG
+
+
+#if 0
+#define EE_W__POS			4
+#define EE_W__LEN			1
+#define EE_W__MSK			0x10
+#define EE_W__REG			BMA020_CTRL_REG
+
+#define UPDATE_IMAGE__POS	5
+#define UPDATE_IMAGE__LEN	1
+#define UPDATE_IMAGE__MSK	0x20
+#define UPDATE_IMAGE__REG	BMA020_CTRL_REG
+#endif
+
+#define RESET_INT__POS		6
+#define RESET_INT__LEN		1
+#define RESET_INT__MSK		0x40
+#define RESET_INT__REG		BMA020_CTRL_REG
+
+
+
+/* LOW-G, HIGH-G settings */
+
+
+#define ENABLE_LG__POS		0
+#define ENABLE_LG__LEN		1
+#define ENABLE_LG__MSK		0x01
+#define ENABLE_LG__REG		BMA020_CONF1_REG
+
+
+#define ENABLE_HG__POS		1
+#define ENABLE_HG__LEN		1
+#define ENABLE_HG__MSK		0x02
+#define ENABLE_HG__REG		BMA020_CONF1_REG
+
+
+/* LG/HG counter */
+	
+
+#define COUNTER_LG__POS			2
+#define COUNTER_LG__LEN			2
+#define COUNTER_LG__MSK			0x0C
+#define COUNTER_LG__REG			BMA020_CONF1_REG
+	
+#define COUNTER_HG__POS			4
+#define COUNTER_HG__LEN			2
+#define COUNTER_HG__MSK			0x30
+#define COUNTER_HG__REG			BMA020_CONF1_REG
+
+
+
+/* LG/HG duration is in ms */
+
+#define LG_DUR__POS			0
+#define LG_DUR__LEN			8
+#define LG_DUR__MSK			0xFF
+#define LG_DUR__REG			LG_DURATION_REG
+
+#define HG_DUR__POS			0
+#define HG_DUR__LEN			8
+#define HG_DUR__MSK			0xFF
+#define HG_DUR__REG			HG_DURATION_REG
+
+			
+#define LG_THRES__POS		0
+#define LG_THRES__LEN		8
+#define LG_THRES__MSK		0xFF
+#define LG_THRES__REG		LG_THRESHOLD_REG
+
+
+#define HG_THRES__POS		0
+#define HG_THRES__LEN		8
+#define HG_THRES__MSK		0xFF
+#define HG_THRES__REG		HG_THRESHOLD_REG
+
+
+#define LG_HYST__POS			0
+#define LG_HYST__LEN			3
+#define LG_HYST__MSK			0x07
+#define LG_HYST__REG			HYSTERESIS_REG
+
+
+#define HG_HYST__POS			3
+#define HG_HYST__LEN			3
+#define HG_HYST__MSK			0x38
+#define HG_HYST__REG			HYSTERESIS_REG
+
+
+
+/* ANY MOTION and ALERT settings */
+
+#define EN_ANY_MOTION__POS		6
+#define EN_ANY_MOTION__LEN		1
+#define EN_ANY_MOTION__MSK		0x40
+#define EN_ANY_MOTION__REG		BMA020_CONF1_REG
+
+
+/* ALERT settings */
+
+
+#define ALERT__POS			7
+#define ALERT__LEN			1
+#define ALERT__MSK			0x80
+#define ALERT__REG			BMA020_CONF1_REG
+
+
+/* ANY MOTION Duration */
+
+
+#define ANY_MOTION_THRES__POS	0
+#define ANY_MOTION_THRES__LEN	8
+#define ANY_MOTION_THRES__MSK	0xFF
+#define ANY_MOTION_THRES__REG	MOTION_THRS_REG
+
+
+#define ANY_MOTION_DUR__POS		6
+#define ANY_MOTION_DUR__LEN		2
+#define ANY_MOTION_DUR__MSK		0xC0	
+#define ANY_MOTION_DUR__REG		HYSTERESIS_REG
+
+
+#define CUSTOMER_RESERVED1__POS		0
+#define CUSTOMER_RESERVED1__LEN	 	8
+#define CUSTOMER_RESERVED1__MSK		0xFF
+#define CUSTOMER_RESERVED1__REG		CUSTOMER1_REG
+
+#define CUSTOMER_RESERVED2__POS		0
+#define CUSTOMER_RESERVED2__LEN	 	8
+#define CUSTOMER_RESERVED2__MSK		0xFF
+#define CUSTOMER_RESERVED2__REG		CUSTOMER2_REG
+
+
+
+/* BANDWIDTH dependend definitions */
+
+#define BANDWIDTH__POS				0
+#define BANDWIDTH__LEN			 	3
+#define BANDWIDTH__MSK			 	0x07
+#define BANDWIDTH__REG				RANGE_BWIDTH_REG
+
+
+
+/* RANGE */
+
+#define RANGE__POS				3
+#define RANGE__LEN				2
+#define RANGE__MSK				0x18	
+#define RANGE__REG				RANGE_BWIDTH_REG
+
+
+/* WAKE UP */
+
+#define WAKE_UP__POS			0
+#define WAKE_UP__LEN			1
+#define WAKE_UP__MSK			0x01
+#define WAKE_UP__REG			BMA020_CONF2_REG
+
+
+#define WAKE_UP_PAUSE__POS		1
+#define WAKE_UP_PAUSE__LEN		2
+#define WAKE_UP_PAUSE__MSK		0x06
+#define WAKE_UP_PAUSE__REG		BMA020_CONF2_REG
+
+
+
+/* ACCELERATION DATA SHADOW */
+
+#define SHADOW_DIS__POS			3
+#define SHADOW_DIS__LEN			1
+#define SHADOW_DIS__MSK			0x08
+#define SHADOW_DIS__REG			BMA020_CONF2_REG
+
+
+
+/* LATCH Interrupt */
+
+#define LATCH_INT__POS			4
+#define LATCH_INT__LEN			1
+#define LATCH_INT__MSK			0x10
+#define LATCH_INT__REG			BMA020_CONF2_REG
+
+
+/* new data interrupt */
+
+#define NEW_DATA_INT__POS		5
+#define NEW_DATA_INT__LEN		1
+#define NEW_DATA_INT__MSK		0x20
+#define NEW_DATA_INT__REG		BMA020_CONF2_REG
+
+
+#define ENABLE_ADV_INT__POS		6
+#define ENABLE_ADV_INT__LEN		1
+#define ENABLE_ADV_INT__MSK		0x40
+#define ENABLE_ADV_INT__REG		BMA020_CONF2_REG
+
+
+#define BMA020_SPI4_OFF	0
+#define BMA020_SPI4_ON	1
+
+#define SPI4__POS				7
+#define SPI4__LEN				1
+#define SPI4__MSK				0x80
+#define SPI4__REG				BMA020_CONF2_REG
+
+
+#if 0
+#define OFFSET_X_LSB__POS	6
+#define OFFSET_X_LSB__LEN	2
+#define OFFSET_X_LSB__MSK	0xC0
+#define OFFSET_X_LSB__REG	OFFS_GAIN_X_REG
+
+#define GAIN_X__POS			0
+#define GAIN_X__LEN			6
+#define GAIN_X__MSK			0x3f
+#define GAIN_X__REG			OFFS_GAIN_X_REG
+
+#define OFFSET_Y_LSB__POS	6
+#define OFFSET_Y_LSB__LEN	2
+#define OFFSET_Y_LSB__MSK	0xC0
+#define OFFSET_Y_LSB__REG	OFFS_GAIN_Y_REG
+
+#define GAIN_Y__POS			0
+#define GAIN_Y__LEN			6
+#define GAIN_Y__MSK			0x3f
+#define GAIN_Y__REG			OFFS_GAIN_Y_REG
+
+
+#define OFFSET_Z_LSB__POS	6
+#define OFFSET_Z_LSB__LEN	2
+#define OFFSET_Z_LSB__MSK	0xC0
+#define OFFSET_Z_LSB__REG	OFFS_GAIN_Z_REG
+
+#define GAIN_Z__POS			0
+#define GAIN_Z__LEN			6
+#define GAIN_Z__MSK			0x3f
+#define GAIN_Z__REG			OFFS_GAIN_Z_REG
+
+#define OFFSET_T_LSB__POS	6
+#define OFFSET_T_LSB__LEN	2
+#define OFFSET_T_LSB__MSK	0xC0
+#define OFFSET_T_LSB__REG	OFFS_GAIN_T_REG
+
+#define GAIN_T__POS			0
+#define GAIN_T__LEN			6
+#define GAIN_T__MSK			0x3f
+#define GAIN_T__REG			OFFS_GAIN_T_REG
+
+#define OFFSET_X_MSB__POS	0
+#define OFFSET_X_MSB__LEN	8
+#define OFFSET_X_MSB__MSK	0xFF
+#define OFFSET_X_MSB__REG	OFFSET_X_REG
+
+
+#define OFFSET_Y_MSB__POS	0
+#define OFFSET_Y_MSB__LEN	8
+#define OFFSET_Y_MSB__MSK	0xFF
+#define OFFSET_Y_MSB__REG	OFFSET_Y_REG
+
+#define OFFSET_Z_MSB__POS	0
+#define OFFSET_Z_MSB__LEN	8
+#define OFFSET_Z_MSB__MSK	0xFF
+#define OFFSET_Z_MSB__REG	OFFSET_Z_REG
+
+#define OFFSET_T_MSB__POS	0
+#define OFFSET_T_MSB__LEN	8
+#define OFFSET_T_MSB__MSK	0xFF
+#define OFFSET_T_MSB__REG	OFFSET_T_REG
+#endif
+
+#define BMA020_GET_BITSLICE(regvar, bitname)\
+			(regvar & bitname##__MSK) >> bitname##__POS
+
+
+#define BMA020_SET_BITSLICE(regvar, bitname, val)\
+		  (regvar & ~bitname##__MSK) | ((val<<bitname##__POS)&bitname##__MSK)  
+
+
+/** endcond */
+
+
+/* CONSTANTS */
+
+
+/* range and bandwidth */
+
+#define BMA020_RANGE_2G			0 /**< sets range to 2G mode \see bma020_set_range() */
+#define BMA020_RANGE_4G			1 /**< sets range to 4G mode \see bma020_set_range() */
+#define BMA020_RANGE_8G			2 /**< sets range to 8G mode \see bma020_set_range() */
+
+
+#define BMA020_BW_25HZ		0	/**< sets bandwidth to 25HZ \see bma020_set_bandwidth() */
+#define BMA020_BW_50HZ		1	/**< sets bandwidth to 50HZ \see bma020_set_bandwidth() */
+#define BMA020_BW_100HZ		2	/**< sets bandwidth to 100HZ \see bma020_set_bandwidth() */
+#define BMA020_BW_190HZ		3	/**< sets bandwidth to 190HZ \see bma020_set_bandwidth() */
+#define BMA020_BW_375HZ		4	/**< sets bandwidth to 375HZ \see bma020_set_bandwidth() */
+#define BMA020_BW_750HZ		5	/**< sets bandwidth to 750HZ \see bma020_set_bandwidth() */
+#define BMA020_BW_1500HZ	6	/**< sets bandwidth to 1500HZ \see bma020_set_bandwidth() */
+
+/* mode settings */
+
+#define BMA020_MODE_NORMAL      0
+#define BMA020_MODE_SLEEP       2
+#define BMA020_MODE_WAKE_UP     3
+
+/* wake up */
+
+#define BMA020_WAKE_UP_PAUSE_20MS		0
+#define BMA020_WAKE_UP_PAUSE_80MS		1
+#define BMA020_WAKE_UP_PAUSE_320MS		2
+#define BMA020_WAKE_UP_PAUSE_2560MS		3
+
+
+/* LG/HG thresholds are in LSB and depend on RANGE setting */
+/* no range check on threshold calculation */
+
+#define BMA020_SELF_TEST0_ON		1
+#define BMA020_SELF_TEST1_ON		3
+
+#define BMA020_EE_W_OFF			0
+#define BMA020_EE_W_ON			1
+
+
+
+/* low-g, high-g, any_motion */
+
+#define BMA020_COUNTER_LG_RST		0
+#define BMA020_COUNTER_LG_0LSB		BMA020_COUNTER_LG_RST
+#define BMA020_COUNTER_LG_1LSB		1
+#define BMA020_COUNTER_LG_2LSB		2
+#define BMA020_COUNTER_LG_3LSB		3
+
+#define BMA020_COUNTER_HG_RST		0
+#define BMA020_COUNTER_HG_0LSB		BMA020_COUNTER_HG_RST
+#define BMA020_COUNTER_HG_1LSB		1
+#define BMA020_COUNTER_HG_2LSB		2
+#define BMA020_COUNTER_HG_3LSB		3
+
+#define BMA020_COUNTER_RST			0
+#define BMA020_COUNTER_0LSB			BMA020_COUNTER_RST
+#define BMA020_COUNTER_1LSB			1
+#define BMA020_COUNTER_2LSB			2
+#define BMA020_COUNTER_3LSB			3
+
+
+
+
+#define BMA020_LG_THRES_IN_G( gthres, range)			((256 * gthres ) / range)
+#define BMA020_HG_THRES_IN_G(gthres, range)				((256 * gthres ) / range)
+#define BMA020_LG_HYST_IN_G( ghyst, range )				((32 * ghyst) / range)
+#define BMA020_HG_HYST_IN_G( ghyst, range )				((32 * ghyst) / range)
+#define BMA020_ANY_MOTION_THRES_IN_G( gthres, range)	((128 * gthres ) / range)
+
+
+#define BMA020_ANY_MOTION_DUR_1		0
+#define BMA020_ANY_MOTION_DUR_3		1
+#define BMA020_ANY_MOTION_DUR_5		2
+#define BMA020_ANY_MOTION_DUR_7		3
+
+
+
+#define BMA020_SHADOW_DIS_OFF	0
+#define BMA020_SHADOW_DIS_ON	1
+
+#define BMA020_LATCH_INT_OFF	0
+#define BMA020_LATCH_INT_ON		1
+
+#define BMA020_NEW_DATA_INT_OFF	0
+#define BMA020_NEW_DATA_INT_ON	1
+
+#define BMA020_ENABLE_ADV_INT_OFF	0
+#define BMA020_ENABLE_ADV_INT_ON	1
+
+#define BMA020_EN_ANY_MOTION_OFF 	0
+#define BMA020_EN_ANY_MOTION_ON 	1
+
+
+#define BMA020_ALERT_OFF	0
+#define BMA020_ALERT_ON		1
+
+#define BMA020_ENABLE_LG_OFF	0
+#define BMA020_ENABLE_LG_ON		1
+
+#define BMA020_ENABLE_HG_OFF	0
+#define BMA020_ENABLE_HG_ON		1
+
+
+
+#define BMA020_INT_ALERT		(1<<7)
+#define BMA020_INT_ANY_MOTION	(1<<6)
+#define BMA020_INT_EN_ADV_INT	(1<<5)
+#define BMA020_INT_NEW_DATA		(1<<4)
+#define BMA020_INT_LATCH		(1<<3)
+#define BMA020_INT_HG			(1<<1)
+#define BMA020_INT_LG			(1<<0)
+
+
+#define BMA020_INT_STATUS_HG			(1<<0)
+#define BMA020_INT_STATUS_LG			(1<<1)
+#define BMA020_INT_STATUS_HG_LATCHED	(1<<2)
+#define BMA020_INT_STATUS_LG_LATCHED	(1<<3)
+#define BMA020_INT_STATUS_ALERT			(1<<4)
+#define BMA020_INT_STATUS_ST_RESULT		(1<<7)
+
+
+#define BMA020_CONF1_INT_MSK	((1<<ALERT__POS) | (1<<EN_ANY_MOTION__POS) | (1<<ENABLE_HG__POS) | (1<<ENABLE_LG__POS))
+#define BMA020_CONF2_INT_MSK	((1<<ENABLE_ADV_INT__POS) | (1<<NEW_DATA_INT__POS) | (1<<LATCH_INT__POS))
+
+
+
+
+/* Function prototypes */
+
+int bma020_init(bma020_t *);
+
+int bma020_set_image (bma020regs_t *);
+
+int bma020_get_image(bma020regs_t *);
+
+int bma020_get_offset(unsigned char, unsigned short *); 
+
+int bma020_set_offset(unsigned char, unsigned short ); 
+
+int bma020_set_offset_eeprom(unsigned char, unsigned short);
+
+int bma020_soft_reset(void); 
+
+int bma020_update_image(void); 
+
+int bma020_write_ee(unsigned char , unsigned char ) ;
+
+int bma020_set_ee_w(unsigned char);
+
+int bma020_selftest(unsigned char);
+
+int bma020_get_selftest_result(unsigned char *);
+
+int bma020_set_range(char); 
+
+int bma020_get_range(unsigned char*);
+
+int bma020_set_mode(unsigned char); 
+
+unsigned char bma020_get_mode(void);
+
+int bma020_set_wake_up_pause(unsigned char);
+
+int bma020_get_wake_up_pause(unsigned char *);
+
+int bma020_set_bandwidth(char);
+
+int bma020_get_bandwidth(unsigned char *);
+
+int bma020_set_low_g_threshold(unsigned char);
+
+int bma020_get_low_g_threshold(unsigned char*);
+
+int bma020_set_low_g_hysteresis(unsigned char);
+
+int bma020_set_low_g_countdown(unsigned char);
+
+int bma020_get_low_g_countdown(unsigned char *);
+
+int bma020_get_low_g_hysteresis(unsigned char*);
+
+int bma020_set_low_g_duration(unsigned char);
+
+int bma020_get_low_g_duration(unsigned char*);
+
+int bma020_set_high_g_threshold(unsigned char);
+
+int bma020_get_high_g_threshold(unsigned char*);
+
+int bma020_set_high_g_hysteresis(unsigned char);
+
+int bma020_set_high_g_countdown(unsigned char);
+
+int bma020_get_high_g_countdown(unsigned char *);
+
+int bma020_get_high_g_hysteresis(unsigned char*);
+
+int bma020_set_high_g_duration(unsigned char);
+
+int bma020_get_high_g_duration(unsigned char*);
+
+int bma020_set_any_motion_threshold(unsigned char);
+
+int bma020_get_any_motion_threshold(unsigned char*);
+
+int bma020_set_any_motion_count(unsigned char);
+
+int bma020_get_any_motion_count(unsigned char *);
+
+int bma020_read_accel_x(short *);
+
+int bma020_read_accel_y(short *);
+
+int bma020_read_accel_z(short *);
+
+int bma020_read_temperature(unsigned char*);
+
+int bma020_read_accel_xyz(bma020acc_t *);
+
+int bma020_get_interrupt_status(unsigned char *);
+
+int bma020_reset_interrupt(void);
+
+int bma020_set_interrupt_mask(unsigned char);
+
+int bma020_get_interrupt_mask(unsigned char *);
+
+int bma020_set_low_g_int(unsigned char);
+
+int bma020_set_high_g_int(unsigned char);
+
+int bma020_set_any_motion_int(unsigned char);
+
+int bma020_set_alert_int(unsigned char);
+
+int bma020_set_advanced_int(unsigned char);
+
+int bma020_latch_int(unsigned char);
+
+int bma020_set_new_data_int(unsigned char onoff);
+
+int bma020_pause(int);
+
+int bma020_read_reg(unsigned char , unsigned char *, unsigned char);
+
+int bma020_write_reg(unsigned char , unsigned char*, unsigned char );
+
+bma020acc_t bma020_calibrate();
+
+
+
+#endif   // __BMA380_H__
+
+
+
+
+
diff -Nur linux-2.6.29/drivers/sensor/accel/bma020_i2c.c linux-2.6.29-spica/drivers/sensor/accel/bma020_i2c.c
--- linux-2.6.29/drivers/sensor/accel/bma020_i2c.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/accel/bma020_i2c.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,201 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/workqueue.h>
+
+//#include <asm/hardware.h>
+//#include <asm/arch/gpio.h>
+//add by inter.park
+#include <mach/hardware.h>
+#include <linux/gpio.h>
+
+#include <linux/irq.h>
+#include <linux/i2c.h>
+
+#include "bma020_i2c.h"
+
+static int i2c_acc_bma020_attach_adapter(struct i2c_adapter *adapter);
+static int i2c_acc_bma020_probe_client(struct i2c_adapter *, int,  int);
+static int i2c_acc_bma020_detach_client(struct i2c_client *client);
+
+
+#define	ACC_SENSOR_ADDRESS		0x38
+
+#define I2C_M_WR				0x00
+#define I2C_DF_NOTIFY			0x01
+
+struct i2c_driver acc_bma020_i2c_driver =
+{
+	.driver = {
+		.name = "bma020_accelerometer_driver",
+	},
+	.attach_adapter	= &i2c_acc_bma020_attach_adapter,
+	.detach_client	= &i2c_acc_bma020_detach_client,
+};
+
+#if 0
+static struct i2c_client *g_client;
+static unsigned short ignore[] = { I2C_CLIENT_END };
+
+static unsigned short normal_addr[] = {
+	ACC_SENSOR_ADDRESS, 
+	I2C_CLIENT_END 
+};
+#endif
+
+static struct i2c_client *g_client;
+
+static unsigned short ignore[] = { I2C_CLIENT_END };
+static unsigned short normal_addr[] = { I2C_CLIENT_END };
+static unsigned short probe_addr[] = { 0, ACC_SENSOR_ADDRESS, I2C_CLIENT_END };
+
+
+static struct i2c_client_address_data addr_data = {
+	.normal_i2c		= normal_addr,
+	.probe			= probe_addr,
+	.ignore			= ignore,
+};
+
+int i2c_acc_bma020_init(void)
+{
+	int ret;
+
+	if ( (ret = i2c_add_driver(&acc_bma020_i2c_driver)) ) 
+	{
+		printk("Driver registration failed, module not inserted.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+void i2c_acc_bma020_exit(void)
+{
+	i2c_del_driver(&acc_bma020_i2c_driver); 
+}
+
+
+char i2c_acc_bma020_read(u8 reg, u8 *val, unsigned int len )
+{
+	int 	 err;
+	struct 	 i2c_msg msg[1];
+	
+	unsigned char data[1];
+	if( (g_client == NULL) || (!g_client->adapter) )
+	{
+		return -ENODEV;
+	}
+	
+	msg->addr 	= g_client->addr;
+	msg->flags 	= I2C_M_WR;
+	msg->len 	= 1;
+	msg->buf 	= data;
+	*data       = reg;
+
+	err = i2c_transfer(g_client->adapter, msg, 1);
+
+	if (err >= 0) 
+	{
+		msg->flags = I2C_M_RD;
+		msg->len   = len;
+		msg->buf   = val;
+		err = i2c_transfer(g_client->adapter, msg, 1);
+	}
+
+	if (err >= 0) 
+	{
+		return 0;
+	}
+	printk("%s %d i2c transfer error\n", __func__, __LINE__);/* add by inter.park */
+
+	return err;
+
+}
+char i2c_acc_bma020_write( u8 reg, u8 *val )
+{
+	int err;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+
+	if( (g_client == NULL) || (!g_client->adapter) ){
+		return -ENODEV;
+	}
+	
+	data[0] = reg;
+	data[1] = *val;
+
+	msg->addr = g_client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = 2;
+	msg->buf = data;
+	
+	err = i2c_transfer(g_client->adapter, msg, 1);
+
+	if (err >= 0) return 0;
+
+	printk("%s %d i2c transfer error\n", __func__, __LINE__);/* add by inter.park */
+	return err;
+}
+
+static int i2c_acc_bma020_attach_adapter(struct i2c_adapter *adapter)
+{
+	return i2c_probe(adapter, &addr_data, &i2c_acc_bma020_probe_client);
+}
+
+static int i2c_acc_bma020_probe_client(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct i2c_client *new_client;
+	int err = 0;
+   	
+	if ( !i2c_check_functionality(adapter,I2C_FUNC_SMBUS_BYTE_DATA) ) {
+		printk(KERN_INFO "byte op is not permited.\n");
+		goto ERROR0;
+	}
+
+	new_client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL );
+
+	if ( !new_client )  {
+		err = -ENOMEM;
+		goto ERROR0;
+	}
+
+	new_client->addr = address;	
+ 	new_client->adapter = adapter;
+	new_client->driver = &acc_bma020_i2c_driver;
+	new_client->flags = I2C_DF_NOTIFY | I2C_M_IGNORE_NAK;
+
+
+	g_client = new_client;
+
+	strlcpy(new_client->name, "bma020", I2C_NAME_SIZE);
+
+	if ((err = i2c_attach_client(new_client)))
+		goto ERROR1;
+
+		return 0;
+
+	ERROR1:
+		printk("i2c_acc_bma020_probe_client() ERROR1\n");/* add by inter.park */
+		kfree(new_client);
+	ERROR0:
+		printk("i2c_acc_bma020_probe_client() ERROR0\n");/* add by inter.park */
+    	return err;
+}
+
+static int i2c_acc_bma020_detach_client(struct i2c_client *client)
+{
+	int err;
+
+  	/* Try to detach the client from i2c space */
+	if ((err = i2c_detach_client(client))) {
+        return err;
+	}
+	
+
+	kfree(client); /* Frees client data too, if allocated at the same time */
+	g_client = NULL;
+	return 0;
+}
+
diff -Nur linux-2.6.29/drivers/sensor/accel/bma020_i2c.h linux-2.6.29-spica/drivers/sensor/accel/bma020_i2c.h
--- linux-2.6.29/drivers/sensor/accel/bma020_i2c.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/accel/bma020_i2c.h	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,10 @@
+#ifndef __BMA020_I2C_HEADER__
+#define __BMA020_I2C_HEADER__
+
+char  i2c_acc_bma020_read (u8, u8 *, unsigned int);
+char  i2c_acc_bma020_write(u8 reg, u8 *val);
+
+int  i2c_acc_bma020_init(void);
+void i2c_acc_bma020_exit(void);
+
+#endif
diff -Nur linux-2.6.29/drivers/sensor/accel/Kconfig linux-2.6.29-spica/drivers/sensor/accel/Kconfig
--- linux-2.6.29/drivers/sensor/accel/Kconfig	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/accel/Kconfig	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,31 @@
+#
+# Accelerometer Sensor Configuration
+#
+
+
+
+config ACCEL                                                              
+	bool "Accelerometer Sensor"
+	default y
+	help
+	This option enables accelerometer sensors  
+	   
+
+config ACCEL_BMA020
+	depends on ACCEL
+	tristate "BMA020 driver for s3c6410"
+	default y
+	help
+	  This option enables accelerometer sensors using bma020 driver.
+	  It is optimized for s3c6410.
+
+
+config ACCEL_KXSD9
+	depends on ACCEL
+	tristate "KXSD9 driver for s3c6410"
+	default n
+	help
+	  This option enables accelerometer sensors using KXSD9 driver.
+	  It is optimized for s3c6410.
+	  
+
diff -Nur linux-2.6.29/drivers/sensor/accel/kxsd9_2042.c linux-2.6.29-spica/drivers/sensor/accel/kxsd9_2042.c
--- linux-2.6.29/drivers/sensor/accel/kxsd9_2042.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/accel/kxsd9_2042.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,477 @@
+ /*****************************************************************************
+ *
+ * COPYRIGHT(C) : Samsung Electronics Co.Ltd, 2006-2015 ALL RIGHTS RESERVED
+ *
+ *****************************************************************************/
+
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/irq.h>
+#include <linux/miscdevice.h>
+#include <linux/gpio.h>
+#include <linux/earlysuspend.h>
+
+#include <mach/hardware.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/freezer.h>
+
+#include "kxsd9_2042.h"
+
+static struct i2c_client *g_i2c_client;
+
+struct kxsd9_data {
+	struct input_dev *input_dev;
+	struct work_struct work;
+	struct hrtimer timer;
+	struct early_suspend	early_suspend;
+};
+
+#define KXSD9_SADDR 		0x18 	// [0011000]
+#define I2C_DF_NOTIFY       0x01
+#define IRQ_ACC_INT IRQ_EINT(3)
+
+#define TIMER_OFF 	0
+#define TIMER_ON	1
+
+static int kxsd9_timer_oper = TIMER_OFF;
+
+static unsigned short ignore[] = { I2C_CLIENT_END };
+static unsigned short normal_addr[] = { I2C_CLIENT_END };
+static unsigned short probe_addr[] = { 5/*0*/, KXSD9_SADDR, I2C_CLIENT_END };
+
+static struct i2c_client_address_data addr_data = {
+	.normal_i2c     = normal_addr,
+	.probe          = probe_addr,
+	.ignore         = ignore,
+};
+
+static int kxsd9_i2c_attach_adapter(struct i2c_adapter *adapter);
+static int kxsd9_i2c_detach_adapter(struct i2c_client *client);
+static int kxsd9_i2c_probe_found(struct i2c_adapter *adapter, int, int);
+
+static struct i2c_driver kxsd9_2042_i2c_driver = {
+	.attach_adapter = kxsd9_i2c_attach_adapter,
+	.detach_client  = kxsd9_i2c_detach_adapter,
+	.driver = 
+	{
+		.name = "kxsd9_2042",
+	},
+};
+
+#if 0
+static irqreturn_t kxsd9_interrupt_handler(int irq, void *dev_id)
+{
+	gprintk("start\n");
+
+	//TODO: interrupt (XEINT3)
+	return IRQ_HANDLED;
+}
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void kxsd9_early_suspend(struct early_suspend *handler)
+{
+	struct kxsd9_data *data = container_of(handler, struct kxsd9_data, early_suspend);
+	hrtimer_cancel(&data->timer);
+	gprintk("......................\n");
+}
+
+static void kxsd9_early_resume(struct early_suspend *handler)
+{
+	struct kxsd9_data *data = container_of(handler, struct kxsd9_data, early_suspend);
+	if(kxsd9_timer_oper == TIMER_ON)
+		hrtimer_start(&data->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	gprintk("......................\n");
+}
+#endif	/* CONFIG_HAS_EARLYSUSPEND */
+
+static int kxsd9_i2c_write(char *buf_to_write, int length)
+{
+	struct i2c_msg msg[] = {
+		{
+			 .addr = g_i2c_client->addr,
+			 .flags = 0,
+			 .len = length,
+			 .buf = buf_to_write,
+		 },
+	};
+
+	if (i2c_transfer(g_i2c_client->adapter, msg, 1) < 0) {
+		printk(KERN_ERR "kxsd9_i2c_write() failed!\n");
+		return -EIO;
+	} else
+		return 0;
+}
+
+static int kxsd9_i2c_read(char *buf_to_read, int length)
+{
+	struct i2c_msg messages[] = {
+		{
+			 .addr = g_i2c_client->addr,
+			 .flags = 0,
+			 .len = 1,
+			 .buf = buf_to_read,
+		},
+		{
+			 .addr = g_i2c_client->addr,
+			 .flags = I2C_M_RD,
+			 .len = length,
+			 .buf = buf_to_read,
+		},
+	};
+
+	if (i2c_transfer(g_i2c_client->adapter, messages, 2) < 0) {
+		printk(KERN_ERR "kxsd9_i2c_read() failed!\n");
+		return -EIO;
+	} else
+		return 0;
+}
+
+static int kxsd9_aot_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int kxsd9_aot_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static int kxsd9_aot_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	struct kxsd9_data *kxsd9 = i2c_get_clientdata(g_i2c_client);
+	
+	switch(cmd)
+	{
+		case ACCS_IOCTL_OPEN:
+			gprintk("hrtimer_start!\n");
+			kxsd9_timer_oper = TIMER_ON;
+			hrtimer_start(&kxsd9->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+			break;
+		case ACCS_IOCTL_CLOSE:
+			gprintk("hrtimer_cancel!\n");
+			kxsd9_timer_oper = TIMER_OFF;
+			hrtimer_cancel(&kxsd9->timer);
+			break;
+		default:
+			break;
+	}
+	return ret;
+}
+
+
+#ifdef KXSD9_TESTMODE
+static int kxsd9_get_valid_value(char* p)
+{
+	int ret=0;
+	char buf[2]={0,0};
+
+	memcpy(buf, p, 2);
+
+	gprintk("[DBG] buf[0]=%d, buf[1]=%d\n", buf[0], buf[1]);
+
+
+#if 0	//12bit
+	ret = ((int)buf[0]<<4) ^ ((int)buf[1]>>4);
+#else	//8bit
+	ret = (int)buf[0];
+#endif
+	return ret;
+}
+
+static void kxsd9_workqueue_func(struct work_struct *work)
+{
+	char buf_read[RBUFF_SIZE+1];
+	int ret = 0;
+	int x=0, y=0, z=0;
+	struct kxsd9_data *kx_data = i2c_get_clientdata(g_i2c_client);
+	
+	gprintk("has been activated by kxsd9_timer_func()\n");
+
+	memset(buf_read, 0, RBUFF_SIZE+1);
+	buf_read[0] = KXSD9_REG_XOUT_H;
+
+	ret = kxsd9_i2c_read(buf_read, 6);
+	if (ret<0)
+		printk(KERN_ERR "kxsd9_workqueue_func: I2C read failed! \n");
+
+	gprintk("\n");
+	gprintk("[DBG] buf_read[0]=%d, buf_read[1]=%d\n", buf_read[0], buf_read[1]);
+	gprintk("[DBG] buf_read[2]=%d, buf_read[3]=%d\n", buf_read[2], buf_read[3]);
+	gprintk("[DBG] buf_read[4]=%d, buf_read[5]=%d\n\n", buf_read[4], buf_read[5]);
+	
+	x = kxsd9_get_valid_value(&buf_read[0]);
+	y = kxsd9_get_valid_value(&buf_read[2]);
+	z = kxsd9_get_valid_value(&buf_read[4]);
+	gprintk("\ninput_report_abs\n");
+
+	input_report_abs(kx_data->input_dev, ABS_X, x);
+	input_report_abs(kx_data->input_dev, ABS_Y, y);
+	input_report_abs(kx_data->input_dev, ABS_Z, z);
+	input_sync(kx_data->input_dev);
+
+	gprintk("Read value [x=%d, y=%d, z=%d]\n", x, y, z);
+
+	printk("============ END ============\n");
+}
+
+static enum hrtimer_restart kxsd9_timer_func(struct hrtimer *timer)
+{
+	struct kxsd9_data* kxsd9 = container_of(timer, struct kxsd9_data, timer);
+
+	printk("============START============\n");
+
+	// puts a job in the kernel-global workqueue
+	schedule_work(&kxsd9->work);
+	
+	hrtimer_start(&kxsd9->timer, ktime_set(0, KXSD9_TESTMODE_PERIOD), HRTIMER_MODE_REL);
+
+	return HRTIMER_NORESTART;
+}
+#endif
+
+static int kxsd9_init_device(void)
+{
+	int ret = 0;
+	char buf_write[2];
+	
+	gprintk("start!\n");
+	
+	/*
+	 * CLKhld = 1 //held low during A/D conversions
+	 * ENABLE = 1 //normal operation
+	 * ST = 0 //selftest disable
+	 * MOTIen = 0 //normal operation
+	 */
+	buf_write[0] = KXSD9_REG_CTRL_REGB;
+	buf_write[1] = 0xC0;
+	
+	ret = kxsd9_i2c_write(buf_write, 2);	
+	if (ret<0) {
+		printk(KERN_ERR "I2C write failed! \n");
+		return ret;
+	}
+	gprintk("kxsd9 REGB Setting!\n");
+
+	/*
+	 * Filter Coner Frequency : 50Hz
+	 * MOTLev : 0
+	 * MOTLat : 0
+	 * FS1,FS0 : 1,1
+	 */
+	buf_write[0] = KXSD9_REG_CTRL_REGC;
+	buf_write[1] = 0xE3;	//11100011
+	
+	ret = kxsd9_i2c_write(buf_write, 2);	
+	if (ret<0) {
+		printk(KERN_ERR "I2C write failed! \n");
+		return ret;
+	}
+	gprintk("kxsd9 REGC Setting!\n");
+	
+	buf_write[0] = KXSD9_REG_RESET_WRITE;
+	buf_write[1] = KSXD9_VAL_RESET;  //0xCA(11001010)
+	
+	ret = kxsd9_i2c_write(buf_write, 2);	
+	if (ret<0) {
+		printk(KERN_ERR "I2C write failed! \n");
+		return ret;
+	}
+	mdelay(16);  // 16msec delay
+	
+	gprintk("kxsd9 module RESET!\n");
+
+	return ret;
+}
+
+static struct file_operations kxsd9_aot_fops = {
+	.owner = THIS_MODULE,
+	.open = kxsd9_aot_open,
+	.ioctl = kxsd9_aot_ioctl,
+	.release = kxsd9_aot_release,
+};
+
+static struct miscdevice kxsd9_aot_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "kxsd9_aot",
+	.fops = &kxsd9_aot_fops,
+};
+
+static int kxsd9_i2c_probe_found(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct i2c_client *new_client;
+	struct kxsd9_data *kxsd9;
+
+	int ret = 0;
+
+	gprintk("start\n");
+	
+	kxsd9 = kzalloc(sizeof(struct kxsd9_data), GFP_KERNEL);
+	if (!kxsd9) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	//TOCHK: I2C_FUNC_SMBUS_I2C_BLOCK OK? (or I2C_FUNC_SMBUS_BYTE_DATA?)
+	ret = i2c_check_functionality(adapter, I2C_FUNC_SMBUS_I2C_BLOCK);
+	if (!ret)
+		goto exit;
+
+	new_client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (!new_client) 
+	{
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	//TOCHK: Is this flag setting Right?
+	new_client->flags = I2C_DF_NOTIFY|I2C_M_IGNORE_NAK;
+	new_client->addr = address;
+	strlcpy(new_client->name, "kxsd9_2042", I2C_NAME_SIZE);
+	new_client->adapter = adapter;
+	new_client->driver = &kxsd9_2042_i2c_driver;
+	#if 0  //TODO: interrupt (XEINT3)
+	new_client->irq = IRQ_ACC_INT;  //TODO: interrupt (XEINT3)
+	#endif
+	
+	if (ret = i2c_attach_client(new_client))
+		goto exit;
+
+
+#ifdef KXSD9_TESTMODE
+	// initialize variables of workqueue structure
+	INIT_WORK(&kxsd9->work, kxsd9_workqueue_func);
+#endif
+
+	i2c_set_clientdata(new_client, kxsd9);
+
+	g_i2c_client = new_client;
+	if (g_i2c_client  == NULL)	{
+		printk(KERN_ERR "i2c_client is NULL\n");
+		return -ENODEV;
+	}
+
+	kxsd9->input_dev = input_allocate_device();
+	
+	if(!kxsd9->input_dev){
+		gprintk("input_allocate_device failed!\n");
+		return -ENODEV;
+	}
+
+	set_bit(EV_ABS, kxsd9->input_dev->evbit);
+	set_bit(EV_SYN, kxsd9->input_dev->evbit);
+
+	input_set_abs_params(kxsd9->input_dev, ABS_X, 0, 4095, 0, 0);
+	input_set_abs_params(kxsd9->input_dev, ABS_Y, 0, 4095, 0, 0);
+	input_set_abs_params(kxsd9->input_dev, ABS_Z, 0, 4095, 0, 0);
+
+	kxsd9->input_dev->name = "kxsd9";
+
+	ret = input_register_device(kxsd9->input_dev);
+	if(ret)
+	{
+		gprintk("Unable to register input device: %s\n", kxsd9->input_dev->name);
+		goto exit;
+	}
+
+	ret = misc_register(&kxsd9_aot_device);
+	if(ret)
+	{
+		gprintk("kxsd9 misc device register failed\n");
+		goto exit;
+	}
+
+	kxsd9_init_device();
+
+#if 0  //TODO: interrupt (XEINT3)
+	ret = request_irq(new_client->irq, kxsd9_interrupt_handler, IRQF_TRIGGER_HIGH, "kxsd9_2042", kxsd9);
+	if (ret < 0) {
+		gprintk("request() irq failed!\n");
+		goto exit;
+	}
+#endif
+
+#ifdef KXSD9_TESTMODE
+	gprintk("timer init\n");
+
+	hrtimer_init(&kxsd9->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	kxsd9->timer.function = kxsd9_timer_func;
+	//hrtimer_start(&kxsd9->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	//kxsd9_timer_oper = TIMER_ON;
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	kxsd9->early_suspend.suspend = kxsd9_early_suspend;
+	kxsd9->early_suspend.resume = kxsd9_early_resume;
+
+	register_early_suspend(&kxsd9->early_suspend);
+#endif	/* CONFIG_HAS_EARLYSUSPEND */
+
+exit:
+	return ret;
+}
+
+static int kxsd9_i2c_attach_adapter(struct i2c_adapter *adapter)
+{	
+	return i2c_probe(adapter, &addr_data, &kxsd9_i2c_probe_found);
+}
+
+static int kxsd9_i2c_detach_adapter(struct i2c_client *client)
+{
+	struct kxsd9_data *kxsd9 = i2c_get_clientdata(client);
+	int ret;
+
+	//free_irq(client->irq, kxsd9);  //TODO: interrupt
+#ifdef KXSD9_TESTMODE
+	gprintk("timer_cansel\n");
+	hrtimer_cancel(&kxsd9->timer);
+#endif
+	input_unregister_device(kxsd9->input_dev);
+
+	if ( ret = i2c_detach_client(client) )
+		return ret;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&kxsd9->early_suspend);
+#endif	/* CONFIG_HAS_EARLYSUSPEND */
+	misc_deregister(&kxsd9_aot_device);
+	kfree(kxsd9);
+	kfree(client);  //TOCHK
+	g_i2c_client = NULL;
+	kxsd9 = NULL;
+	
+	return 0;
+}
+
+static int __init kxsd9_2042_init(void)
+{
+	gprintk("init\n");
+
+	// for Interrupt GPIO setting
+#if 0
+	s3c_gpio_cfgpin(GPIO_ACC_INT, S3C_GPIO_SFN(GPIO_ACC_INT_AF));
+	s3c_gpio_setpull(GPIO_ACC_INT, S3C_GPIO_PULL_NONE);
+
+	set_irq_type(IRQ_ACC_INT, IRQ_TYPE_EDGE_RISING);
+#endif
+	return i2c_add_driver(&kxsd9_2042_i2c_driver);
+}
+
+static void __exit kxsd9_2042_exit(void)
+{
+	gprintk("exit\n");
+	i2c_del_driver(&kxsd9_2042_i2c_driver);
+}
+
+module_init(kxsd9_2042_init);
+module_exit(kxsd9_2042_exit);
+
+MODULE_AUTHOR("SAMSUNG");
+MODULE_DESCRIPTION("KXSD9-2042 accelerometer driver");
+MODULE_LICENSE("GPL");
+
diff -Nur linux-2.6.29/drivers/sensor/accel/kxsd9_2042.h linux-2.6.29-spica/drivers/sensor/accel/kxsd9_2042.h
--- linux-2.6.29/drivers/sensor/accel/kxsd9_2042.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/accel/kxsd9_2042.h	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,44 @@
+/*
+ * Header for Kionix KXSD9-2042 accelerometer.
+ */
+#ifndef __KXSD9_2042_H__
+#define __KXSD9_2042_H__
+
+
+// Address for KXSD9 embedded registers
+#define KXSD9_REG_XOUT_H	0x00  //R
+#define KXSD9_REG_XOUT_L	0x01  //R
+#define KXSD9_REG_YOUT_H	0x02  //R
+#define KXSD9_REG_YOUT_L	0x03  //R
+#define KXSD9_REG_ZOUT_H	0x04  //R
+#define KXSD9_REG_ZOUT_L	0x05  //R
+#define KXSD9_REG_AUXOUT_H	0x06  //R
+#define KXSD9_REG_AUXOUT_L	0x07  //R
+
+#define KXSD9_REG_RESET_WRITE	0x0A  //W
+
+#define KXSD9_REG_CTRL_REGC	0x0C  //R/W
+#define KXSD9_REG_CTRL_REGB	0x0D  //R/W
+#define KXSD9_REG_CTRL_REGA	0x0E  //R
+
+#define KSXD9_VAL_RESET	0xCA
+
+#define RBUFF_SIZE		31	/* Rx buffer size */
+
+#define ACCS_IOCTL_OPEN 	101
+#define ACCS_IOCTL_CLOSE 	102
+
+/*********** for debug **********************************************************/
+#if 1
+#define gprintk(fmt, x... ) printk( "%s(%d): " fmt, __FUNCTION__ ,__LINE__, ## x)
+#else
+#define gprintk(x...) do { } while (0)
+#endif 
+/*******************************************************************************/
+
+#define KXSD9_TESTMODE
+#define KXSD9_TESTMODE_PERIOD 500000000  // 0.5 sec
+//#define KXSD9_TESTMODE_PERIOD 1000000000  // 1 sec
+
+#endif   // __KXSD9_2042_H__
+
diff -Nur linux-2.6.29/drivers/sensor/accel/Makefile linux-2.6.29-spica/drivers/sensor/accel/Makefile
--- linux-2.6.29/drivers/sensor/accel/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/accel/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,15 @@
+##############################################################################
+# COPYRIGHT(C)	: Samsung Electronics Co.Ltd, 2006-2011 ALL RIGHTS RESERVED
+# AUTHOR		: Throughc
+##############################################################################
+# VERSION&DATE	: Version 1.00	2007/12/25 (Throughc)
+##############################################################################
+
+
+obj-$(CONFIG_ACCEL_KXSD9)	+= kxsd9_2042.o
+
+
+obj-$(CONFIG_ACCEL_BMA020)	+= bma020_i2c.o \
+                               bma020.o \
+	                           bma020_acc.o
+
diff -Nur linux-2.6.29/drivers/sensor/compass/ak8973b.c linux-2.6.29-spica/drivers/sensor/compass/ak8973b.c
--- linux-2.6.29/drivers/sensor/compass/ak8973b.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/compass/ak8973b.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,962 @@
+ 
+ /*****************************************************************************
+ *
+ * COPYRIGHT(C) : Samsung Electronics Co.Ltd, 2006-2015 ALL RIGHTS RESERVED
+ *
+ *****************************************************************************/
+ 
+
+
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/irq.h>
+#include <linux/miscdevice.h>
+#include <linux/gpio.h>
+
+#include <mach/hardware.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/freezer.h>
+
+#include "ak8973b.h"
+
+#include <linux/earlysuspend.h>
+
+#define E_COMPASS_ADDRESS	0x1c	/* CAD0 : 0, CAD1 : 0 */
+#define I2C_DF_NOTIFY       0x01
+#define IRQ_COMPASS_INT IRQ_EINT(2) /* EINT(2) */
+
+static struct i2c_client *this_client;
+
+struct ak8973b_data {
+	struct input_dev *input_dev;
+	struct early_suspend	early_suspend;
+};
+
+static DECLARE_WAIT_QUEUE_HEAD(open_wq);
+
+static atomic_t open_count;
+static atomic_t open_flag;
+static atomic_t reserve_open_flag;
+
+static atomic_t m_flag; 
+static atomic_t a_flag; 
+static atomic_t t_flag; 
+static atomic_t mv_flag;
+
+static short akmd_delay = 0;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static atomic_t suspend_flag = ATOMIC_INIT(0);
+#endif /* CONFIG_HAS_EARLYSUSPEND */ 
+
+/* following are the sysfs callback functions */
+
+#define config_ctrl_reg(name,address) \
+	static ssize_t name##_show(struct device *dev, struct device_attribute *attr, \
+		char *buf) \
+{ \
+	struct i2c_client *client = to_i2c_client(dev); \
+	return sprintf(buf, "%u\n", i2c_smbus_read_byte_data(client,address)); \
+} \
+static ssize_t name##_store(struct device *dev, struct device_attribute *attr, \
+	const char *buf,size_t count) \
+{ \
+	struct i2c_client *client = to_i2c_client(dev); \
+	unsigned long val = simple_strtoul(buf, NULL, 10); \
+	if (val > 0xff) \
+		return -EINVAL; \
+	i2c_smbus_write_byte_data(client,address, val); \
+		return count; \
+} \
+static DEVICE_ATTR(name, S_IWUSR | S_IRUGO, name##_show, name##_store)
+
+config_ctrl_reg(ms1, AKECS_REG_MS1);
+
+
+
+static int i2c_ak8973b_attach_adapter(struct i2c_adapter *adapter);
+static int i2c_ak8973b_detach_client(struct i2c_client *client);
+static int i2c_ak8973b_probe_client(struct i2c_adapter *adapter, int, int);
+
+static struct i2c_driver ak8973b_i2c_driver = {
+	.attach_adapter = i2c_ak8973b_attach_adapter,
+	.detach_client  = i2c_ak8973b_detach_client,
+	.driver = {
+		   .name = "ak8973b",
+		   },
+};
+
+unsigned short ignore[] = { I2C_CLIENT_END };
+static unsigned short normal_addr[] = { I2C_CLIENT_END };
+static unsigned short probe_addr[] = { 0, E_COMPASS_ADDRESS, I2C_CLIENT_END };
+
+
+static struct i2c_client_address_data addr_data = {
+	.normal_i2c     = normal_addr,
+	.probe          = probe_addr,
+	.ignore         = ignore,
+};
+
+
+static char ak_e2prom_data[3];
+
+static int AKI2C_RxData(char *rxData, int length)
+{
+	struct i2c_msg msgs[] = {
+		{
+		 .addr = this_client->addr,
+		 .flags = 0,
+		 .len = 1,
+		 .buf = rxData,
+		 },
+		{
+		 .addr = this_client->addr,
+		 .flags = I2C_M_RD,
+		 .len = length,
+		 .buf = rxData,
+		 },
+	};
+
+	if (i2c_transfer(this_client->adapter, msgs, 2) < 0) {
+		printk(KERN_ERR "AKI2C_RxData: transfer error \n");
+		return -EIO;
+	} else
+		return 0;
+}
+
+static int AKI2C_TxData(char *txData, int length)
+{
+	struct i2c_msg msg[] = {
+		{
+		 .addr = this_client->addr,
+		 .flags = 0,
+		 .len = length,
+		 .buf = txData,
+		 },
+	};
+
+	if (i2c_transfer(this_client->adapter, msg, 1) < 0) {
+		printk(KERN_ERR "AKI2C_TxData: transfer error addr \n");
+		return -EIO;
+	} else
+		return 0;
+}
+
+static int AKECS_Init(void)
+{
+	return 0;
+}
+
+static int akm_aot_open(struct inode *inode, struct file *file)
+{
+	int ret = -1;
+	if (atomic_cmpxchg(&open_count, 0, 1) == 0) {
+		if (atomic_cmpxchg(&open_flag, 0, 1) == 0) {
+			atomic_set(&reserve_open_flag, 1);
+			wake_up(&open_wq);
+			ret = 0;
+		}
+	}
+	return ret;
+}
+
+static int akm_aot_release(struct inode *inode, struct file *file)
+{
+	atomic_set(&reserve_open_flag, 0);
+	atomic_set(&open_flag, 0);
+	atomic_set(&open_count, 0);
+	wake_up(&open_wq);
+	return 0;
+}
+
+static void AKECS_Report_Value(short *rbuf)
+{
+	struct ak8973b_data *data = i2c_get_clientdata(this_client);
+	#if 0
+	gprintk("Orientaion: yaw = %d, pitch = %d, roll = %d\n", rbuf[0],
+			rbuf[1], rbuf[2]);
+	gprintk("tmp = %d, m_stat= %d, g_stat=%d\n", rbuf[3],
+			rbuf[4], rbuf[5]);
+	gprintk("Acceleration:   x = %d LSB, y = %d LSB, z = %d LSB\n",
+			rbuf[6], rbuf[7], rbuf[8]);
+	gprintk("Magnetic:   x = %d LSB, y = %d LSB, z = %d LSB\n\n",
+			rbuf[9], rbuf[10], rbuf[11]);
+	#endif
+	/*if flag is set, execute report */
+	/* Report magnetic sensor information */
+	if (atomic_read(&m_flag)) {
+		input_report_abs(data->input_dev, ABS_RX, rbuf[0]);
+		input_report_abs(data->input_dev, ABS_RY, rbuf[1]);
+		input_report_abs(data->input_dev, ABS_RZ, rbuf[2]);
+		input_report_abs(data->input_dev, ABS_RUDDER, rbuf[4]);
+	}
+
+	/* Report acceleration sensor information */
+	if (atomic_read(&a_flag)) {
+		input_report_abs(data->input_dev, ABS_X, rbuf[6]);
+		input_report_abs(data->input_dev, ABS_Y, rbuf[7]);
+		input_report_abs(data->input_dev, ABS_Z, rbuf[8]);
+		input_report_abs(data->input_dev, ABS_WHEEL, rbuf[5]);
+	}
+
+	/* Report temperature information */
+	if (atomic_read(&t_flag)) {
+		input_report_abs(data->input_dev, ABS_THROTTLE, rbuf[3]);
+	}
+
+	if (atomic_read(&mv_flag)) {
+		input_report_abs(data->input_dev, ABS_HAT0X, rbuf[9]);
+		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[10]);
+		input_report_abs(data->input_dev, ABS_BRAKE, rbuf[11]);
+	}
+	
+	input_sync(data->input_dev);
+}
+
+static int AKECS_GetOpenStatus(void)
+{
+	wait_event_interruptible(open_wq, (atomic_read(&open_flag) != 0));
+	return atomic_read(&open_flag);
+}
+
+static int AKECS_GetCloseStatus(void)
+{
+	wait_event_interruptible(open_wq, (atomic_read(&open_flag) <= 0));
+	return atomic_read(&open_flag);
+}
+
+static void AKECS_CloseDone(void)
+{
+	#if 0
+	atomic_set(&m_flag, 1);
+	atomic_set(&a_flag, 1);
+	atomic_set(&t_flag, 1);
+	atomic_set(&mv_flag, 1);
+	#else
+	atomic_set(&m_flag, 0);
+	atomic_set(&a_flag, 0);
+	atomic_set(&t_flag, 0);
+	atomic_set(&mv_flag, 0);
+	#endif
+}
+
+
+
+/*----------------------------------------------------------------------------*/
+//Description : Resetting AKECS 
+//WHO : AKEK GWLEE
+//DATE : 2008 12 08
+/*----------------------------------------------------------------------------*/
+static void AKECS_Reset (void)
+{
+      
+	gpio_set_value(GPIO_MSENSE_RST, GPIO_LEVEL_LOW);
+	udelay(120);
+	gpio_set_value(GPIO_MSENSE_RST, GPIO_LEVEL_HIGH);
+	gprintk("AKECS RESET COMPLETE\n");
+}
+
+/*----------------------------------------------------------------------------*/
+//Description : Setting measurement to AKECS 
+//WHO : AKEK GWLEE
+//DATE : 2008 12 08
+/*----------------------------------------------------------------------------*/
+static int AKECS_SetMeasure (void)
+{
+	char buffer[2];
+
+	gprintk("MEASURE MODE\n");
+	/* Set measure mode */
+	buffer[0] = AKECS_REG_MS1;
+	buffer[1] = AKECS_MODE_MEASURE;
+
+	/* Set data */
+	return AKI2C_TxData(buffer, 2);
+}
+
+/*----------------------------------------------------------------------------*/
+//Description : Setting EEPROM to AKECS 
+//WHO : AKEK GWLEE
+//DATE : 2008 12 08
+/*----------------------------------------------------------------------------*/
+static int AKECS_SetE2PRead ( void )
+{
+	char buffer[2];
+
+	/* Set measure mode */
+	buffer[0] = AKECS_REG_MS1;
+	buffer[1] = AKECS_MODE_E2P_READ;
+	/* Set data */
+	return AKI2C_TxData(buffer, 2);
+}
+
+
+/*----------------------------------------------------------------------------*/
+//Description : Power Down to AKECS 
+//WHO : AKEK GWLEE
+//DATE : 2008 12 08
+/*----------------------------------------------------------------------------*/
+static int AKECS_PowerDown (void)
+{
+	char buffer[2];
+	int ret;
+
+	/* Set powerdown mode */
+	buffer[0] = AKECS_REG_MS1;
+	buffer[1] = AKECS_MODE_POWERDOWN;
+	/* Set data */
+	ret = AKI2C_TxData(buffer, 2);
+	if (ret < 0)
+		return ret;
+
+	/* Dummy read for clearing INT pin */
+	buffer[0] = AKECS_REG_TMPS;
+	/* Read data */
+	ret = AKI2C_RxData(buffer, 1);
+	if (ret < 0)
+		return ret;
+
+ return ret;
+}
+
+/*----------------------------------------------------------------------------*/
+//Description : Get EEPROM Data to AKECS 
+//WHO : AKEK GWLEE
+//DATE : 2008 12 08
+/*----------------------------------------------------------------------------*/
+static int AKECS_GetEEPROMData (void)
+{ 
+	int ret;
+	char buffer[RBUFF_SIZE + 1];
+
+	ret = AKECS_SetE2PRead();
+	if (ret < 0) return ret;
+
+	memset(buffer, 0, RBUFF_SIZE + 1);
+	buffer[0] = AKECS_EEP_EHXGA;
+	ret =  AKI2C_RxData(buffer, 3);
+
+	if (ret < 0) return ret;
+
+	ak_e2prom_data[0]= buffer[0];
+	ak_e2prom_data[1]= buffer[1];
+	ak_e2prom_data[2]= buffer[2];
+	gprintk("AKE2PROM_Data -->%d , %d, %d ----\n", ak_e2prom_data[0],ak_e2prom_data[1],ak_e2prom_data[2]);
+	
+	return ret;
+}
+
+static int AKECS_SetMode(char mode)
+{
+	int ret = 0;
+	
+	switch (mode) {
+		case AKECS_MODE_MEASURE:
+			ret = AKECS_SetMeasure();
+			break;
+		case AKECS_MODE_E2P_READ:
+			ret = AKECS_SetE2PRead();
+			break;
+		case AKECS_MODE_POWERDOWN:
+			ret = AKECS_PowerDown();
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	/* wait at least 300us after changing mode */
+	msleep(1);
+	return ret;
+}
+
+static int AKECS_TransRBuff(char *rbuf, int size)
+{
+	if(size < RBUFF_SIZE + 1)
+		return -EINVAL;
+
+	// read C0 - C4
+	rbuf[0] = AKECS_REG_ST;
+	return AKI2C_RxData(rbuf, RBUFF_SIZE + 1);
+
+}
+
+
+/*----------------------------------------------------------------------------*/
+//Description : Get EEPROM Data to AKECS 
+//WHO : AKEK GWLEE
+//DATE : 2008 12 08
+/*----------------------------------------------------------------------------*/
+static int AKECS_GetData (short *rbuf)
+{ 
+	int ret;
+  	char buffer[RBUFF_SIZE + 1];
+
+	memset(buffer, 0, RBUFF_SIZE + 1);
+	buffer[0] = AKECS_REG_TMPS;
+
+	ret =  AKI2C_RxData(buffer, 4);  //temp, x, y, z
+	if(ret<0) {
+		printk(KERN_ERR "AKECS_GetData  failed--------------\n");
+		return ret;
+		}
+	else	{
+			
+			rbuf[0] = 35 + (120 -buffer[0])*10/16;
+			rbuf[1] = buffer[1];
+			rbuf[2] = buffer[2];
+			rbuf[3] = buffer[3];
+			gprintk("AKECS_Get_MAG: temp = %d, x = %d, y = %d, z = %d\n", rbuf[0], rbuf[1], rbuf[2], rbuf[3]);
+		}
+  return ret;
+}
+
+static void AKECS_DATA_Measure(void)
+{
+	short  value[12];
+	short mag_sensor[4] ={0, 0, 0, 0};
+
+	AKECS_GetData(mag_sensor);
+	value[0]=0;
+	value[1]=0;
+	value[2]=0;
+	value[3]=mag_sensor[0];		/* temparature */
+	value[4]=0;
+	value[5]=0;
+	value[6]=0;
+	value[7]=0;
+	value[8]=0;
+	value[9]=mag_sensor[1];		/* mag_x */
+	value[10]=mag_sensor[2];	/* mag_y */
+	value[11]=mag_sensor[3];	/* mag_z */
+
+	AKECS_Report_Value(value);
+}
+
+
+static int 
+akm_aot_ioctl(struct inode *inode, struct file *file,
+	      unsigned int cmd, unsigned long arg)
+{
+#if 0
+	struct ak8973b_data *akm = i2c_get_clientdata(this_client);
+
+	switch(cmd)
+	{
+		case EMCS_IOCTL_OPEN:
+			gprintk("hrtimer_start!\n");
+			ak8973b_timer_oper = TIMER_ON;
+			hrtimer_start(&akm->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+			break;
+		case EMCS_IOCTL_CLOSE:
+			gprintk("hrtimer_cancel!\n");
+			ak8973b_timer_oper = TIMER_OFF;
+			hrtimer_cancel(&akm->timer);
+			break;
+		default:
+			break;
+	}
+#endif
+
+	void __user *argp = (void __user *)arg;
+	short flag;
+
+	switch (cmd) {
+		case ECS_IOCTL_APP_SET_MFLAG:
+		case ECS_IOCTL_APP_SET_AFLAG:
+		case ECS_IOCTL_APP_SET_TFLAG:
+		case ECS_IOCTL_APP_SET_MVFLAG:
+			if (copy_from_user(&flag, argp, sizeof(flag)))
+				return -EFAULT;
+			if (flag < 0 || flag > 1)
+				return -EINVAL;
+			break;
+		case ECS_IOCTL_APP_SET_DELAY:
+			if (copy_from_user(&flag, argp, sizeof(flag)))
+				return -EFAULT;
+			break;
+		default:
+			break;
+	}
+
+	switch (cmd) {
+		case ECS_IOCTL_APP_SET_MFLAG:
+			atomic_set(&m_flag, flag);
+			break;
+		case ECS_IOCTL_APP_GET_MFLAG:
+			flag = atomic_read(&m_flag);
+			break;
+		case ECS_IOCTL_APP_SET_AFLAG:
+			atomic_set(&a_flag, flag);
+			break;
+		case ECS_IOCTL_APP_GET_AFLAG:
+			flag = atomic_read(&a_flag);
+			break;
+		case ECS_IOCTL_APP_SET_TFLAG:
+			atomic_set(&t_flag, flag);
+			break;
+		case ECS_IOCTL_APP_GET_TFLAG:
+			flag = atomic_read(&t_flag);
+			break;
+		case ECS_IOCTL_APP_SET_MVFLAG:
+			atomic_set(&mv_flag, flag);
+			break;
+		case ECS_IOCTL_APP_GET_MVFLAG:
+			flag = atomic_read(&mv_flag);
+			break;
+		case ECS_IOCTL_APP_SET_DELAY:
+			akmd_delay = flag;
+			break;
+		case ECS_IOCTL_APP_GET_DELAY:
+			flag = akmd_delay;
+			break;
+		case ECS_IOCTL_DEVMGR_GET_DATA:
+			AKECS_DATA_Measure();
+			break;
+		default:
+			return -ENOTTY;
+	}
+
+	switch (cmd) {
+		case ECS_IOCTL_APP_GET_MFLAG:
+		case ECS_IOCTL_APP_GET_AFLAG:
+		case ECS_IOCTL_APP_GET_TFLAG:
+		case ECS_IOCTL_APP_GET_MVFLAG:
+		case ECS_IOCTL_APP_GET_DELAY:
+			if (copy_to_user(argp, &flag, sizeof(flag)))
+				return -EFAULT;
+			break;
+		default:
+			break;
+	}
+
+	return 0;
+}
+
+static int akmd_open(struct inode *inode, struct file *file)
+{
+	gprintk(KERN_INFO "[AK8973B] %s\n", __FUNCTION__);
+	return nonseekable_open(inode, file);
+}
+
+static int akmd_release(struct inode *inode, struct file *file)
+{
+	gprintk(KERN_INFO "[AK8973B] %s\n", __FUNCTION__);
+	AKECS_CloseDone();
+	return 0;
+}
+
+	static int
+akmd_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	int i;
+	void __user *argp = (void __user *)arg;
+
+	char msg[RBUFF_SIZE + 1], rwbuf[16];//, numfrq[2];
+	int ret = -1, status;
+	short mode, value[12], delay; /* step_count,*/
+	//  char *pbuffer = 0;
+	gprintk("start\n");
+
+	switch (cmd) {
+		case ECS_IOCTL_READ:
+		case ECS_IOCTL_WRITE:
+			if (copy_from_user(&rwbuf, argp, sizeof(rwbuf)))
+				return -EFAULT;
+			break;
+		case ECS_IOCTL_SET_MODE:
+			if (copy_from_user(&mode, argp, sizeof(mode)))
+				return -EFAULT;
+			break;
+		case ECS_IOCTL_SET_YPR:
+			if (copy_from_user(&value, argp, sizeof(value)))
+				return -EFAULT;
+			break;
+			//case ECS_IOCTL_SET_STEP_CNT:
+			// if (copy_from_user(&step_count, argp, sizeof(step_count)))
+			//     return -EFAULT;
+			// break;
+		default:
+			break;
+	}
+
+	switch (cmd) {
+		case ECS_IOCTL_INIT:
+			gprintk("[AK8973B] ECS_IOCTL_INIT %x\n", cmd);
+			ret = AKECS_Init();
+			if (ret < 0)
+				return ret;
+			break;
+		case ECS_IOCTL_RESET:
+			gprintk("[AK8973B] ECS_IOCTL_RESET %x\n", cmd);
+			AKECS_Reset();
+			break;
+		case ECS_IOCTL_READ:
+			gprintk("[AK8973B] ECS_IOCTL_READ %x\n", cmd);
+			gprintk(" len %02x:", rwbuf[0]);
+			gprintk(" addr %02x:", rwbuf[1]);
+			gprintk("\n");
+			if (rwbuf[0] < 1)
+				return -EINVAL;
+			ret = AKI2C_RxData(&rwbuf[1], rwbuf[0]);
+			for(i=0; i<rwbuf[0]; i++){
+				gprintk(" %02x", rwbuf[i+1]);
+			}
+			gprintk(" ret = %d\n", ret);
+			if (ret < 0)
+				return ret;
+			break;
+		case ECS_IOCTL_WRITE:
+			gprintk("[AK8973B] ECS_IOCTL_WRITE %x\n", cmd);
+			gprintk(" len %02x:", rwbuf[0]);
+			for(i=0; i<rwbuf[0]; i++){
+				gprintk(" %02x", rwbuf[i+1]);
+			}
+			gprintk("\n");
+			if (rwbuf[0] < 2)
+				return -EINVAL;
+			ret = AKI2C_TxData(&rwbuf[1], rwbuf[0]);
+			gprintk(" ret = %d\n", ret);
+			if (ret < 0)
+				return ret;
+			break;
+		case ECS_IOCTL_SET_MODE:
+			gprintk("[AK8973B] ECS_IOCTL_SET_MODE %x mode=%x\n", cmd, mode);
+			ret = AKECS_SetMode((char)mode);
+			gprintk(" ret = %d\n", ret);
+			if (ret < 0)
+				return ret;
+			break;
+		case ECS_IOCTL_GETDATA:
+			gprintk("[AK8973B] ECS_IOCTL_GETDATA %x\n", cmd);
+			ret = AKECS_TransRBuff(msg, RBUFF_SIZE+1);
+			gprintk(" ret = %d\n", ret);
+			if (ret < 0)
+				return ret;
+			for(i=0; i<ret; i++){
+				gprintk(" %02x", msg[i]);
+			}
+			break;
+		case ECS_IOCTL_SET_YPR:
+			gprintk("[AK8973B] ECS_IOCTL_SET_YPR %x ypr=%x\n", cmd, (unsigned int)value);
+			AKECS_Report_Value(value);
+			break;
+		case ECS_IOCTL_GET_OPEN_STATUS:
+			gprintk("[AK8973B] ECS_IOCTL_GET_OPEN_STATUS %x start\n", cmd);
+			status = AKECS_GetOpenStatus();
+			gprintk("[AK8973B] ECS_IOCTL_GET_OPEN_STATUS %x end status=%x\n", cmd, status);
+
+			break;
+		case ECS_IOCTL_GET_CLOSE_STATUS:
+			gprintk("[AK8973B] ECS_IOCTL_GET_CLOSE_STATUS %x start\n", cmd);
+			status = AKECS_GetCloseStatus();
+			gprintk("[AK8973B] ECS_IOCTL_GET_CLOSE_STATUS %x end status=%x\n", cmd, status);
+			break;
+		case ECS_IOCTL_GET_DELAY:
+			delay = akmd_delay;
+			gprintk("[AK8973B] ECS_IOCTL_GET_DELAY %x delay=%x\n", cmd, delay);
+			break;
+		default:
+			gprintk("Unknown cmd %x\n", cmd);
+			return -ENOTTY;
+	}
+
+	switch (cmd) {
+		case ECS_IOCTL_READ:
+			if (copy_to_user(argp, &rwbuf, sizeof(rwbuf)))
+				return -EFAULT;
+			break;
+		case ECS_IOCTL_GETDATA:
+			if (copy_to_user(argp, &msg, sizeof(msg)))
+				return -EFAULT;
+			break;
+		case ECS_IOCTL_GET_OPEN_STATUS:
+		case ECS_IOCTL_GET_CLOSE_STATUS:
+			if (copy_to_user(argp, &status, sizeof(status)))
+				return -EFAULT;
+			break;
+
+		case ECS_IOCTL_GET_DELAY:
+			if (copy_to_user(argp, &delay, sizeof(delay)))
+				return -EFAULT;
+			break;
+		default:
+			break;
+	}
+
+	return 0;
+}
+
+
+
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void ak8973b_early_suspend(struct early_suspend *handler)
+{
+	AKECS_SetMode(AKECS_MODE_POWERDOWN);
+	#if 0
+	atomic_set(&suspend_flag, 1);
+	if (atomic_read(&open_flag) == 2)
+		AKECS_SetMode(AKECS_MODE_POWERDOWN);
+
+	atomic_set(&reserve_open_flag, atomic_read(&open_flag));
+	atomic_set(&open_flag, 0);
+	wake_up(&open_wq);
+	#endif
+}
+
+static void ak8973b_early_resume(struct early_suspend *handler)
+{
+	atomic_set(&suspend_flag, 0);
+	atomic_set(&open_flag, atomic_read(&reserve_open_flag));
+	wake_up(&open_wq);
+}
+#endif /* CONFIG_HAS_EARLYSUSPEND */ 
+
+static void ak8973b_init_hw(void)
+{
+#if 0	
+	s3c_gpio_cfgpin(GPIO_MSENSE_INT, S3C_GPIO_SFN(GPIO_MSENSE_INT_AF));
+	s3c_gpio_setpull(GPIO_MSENSE_INT, S3C_GPIO_PULL_NONE);
+	set_irq_type(IRQ_COMPASS_INT, IRQ_TYPE_EDGE_RISING);
+#endif
+
+	if(gpio_is_valid(GPIO_MSENSE_RST)){
+		if(gpio_request(GPIO_MSENSE_RST, S3C_GPIO_LAVEL(GPIO_MSENSE_RST)))
+		{
+			printk(KERN_ERR "Failed to request GPIO_MSENSE_RST!\n");
+		}
+		gpio_direction_output(GPIO_MSENSE_RST, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_MSENSE_RST, S3C_GPIO_PULL_NONE);
+
+	gprintk("gpio setting complete!\n");
+}
+
+static struct file_operations akmd_fops = {
+	.owner = THIS_MODULE,
+	.open = akmd_open,
+	.release = akmd_release,
+	.ioctl = akmd_ioctl,
+};
+
+static struct file_operations akm_aot_fops = {
+	.owner = THIS_MODULE,
+	.open = akm_aot_open,
+	.release = akm_aot_release,
+	.ioctl = akm_aot_ioctl,
+};
+
+static struct miscdevice akm_aot_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "akm8973_aot",
+	.fops = &akm_aot_fops,
+};
+
+static struct miscdevice akmd_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "akm8973_daemon",
+	.fops = &akmd_fops,
+};
+
+
+
+
+
+static int i2c_ak8973b_probe_client(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct i2c_client *new_client;
+	int err = 0;
+	struct ak8973b_data *akm;
+
+	gprintk("start\n");
+
+	if ( !i2c_check_functionality(adapter,I2C_FUNC_SMBUS_BYTE_DATA) ) {
+		printk(KERN_INFO "byte op is not permited.\n");
+		goto ERROR0;
+	}
+
+	akm = kzalloc(sizeof(struct ak8973b_data), GFP_KERNEL);
+	if (!akm) {
+		err = -ENOMEM;
+		goto exit_alloc_data_failed;
+	}
+
+	new_client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL );
+
+	if ( !new_client )  {
+		err = -ENOMEM;
+		goto ERROR0;
+	}
+
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &ak8973b_i2c_driver;
+	new_client->flags = I2C_DF_NOTIFY | I2C_M_IGNORE_NAK;
+	new_client->irq = IRQ_COMPASS_INT; /* EINT(2) */
+
+	strlcpy(new_client->name, "ak8973b", I2C_NAME_SIZE);
+
+	if ((err = i2c_attach_client(new_client)))
+		goto ERROR1;
+
+	i2c_set_clientdata(new_client, akm);
+	
+	this_client = new_client;
+
+	if(this_client == NULL)
+	{
+		printk("i2c_client is NULL\n");
+		return -ENODEV;
+	}
+
+	akm->input_dev = input_allocate_device();
+
+	if (!akm->input_dev) {
+		err = -ENOMEM;
+		printk("input_allocate_device failed\n");
+		goto exit_input_dev_alloc_failed;
+	}
+	
+	set_bit(EV_ABS, akm->input_dev->evbit);
+	set_bit(EV_SYN, akm->input_dev->evbit);
+
+	/* yaw */
+	input_set_abs_params(akm->input_dev, ABS_RX, 0, 23040, 0, 0);
+	/* pitch */
+	input_set_abs_params(akm->input_dev, ABS_RY, -11520, 11520, 0, 0);
+	/* roll */
+	input_set_abs_params(akm->input_dev, ABS_RZ, -5760, 5760, 0, 0);
+	/* x-axis acceleration */
+	input_set_abs_params(akm->input_dev, ABS_X, -5760, 5760, 0, 0);
+	/* y-axis acceleration */
+	input_set_abs_params(akm->input_dev, ABS_Y, -5760, 5760, 0, 0);
+	/* z-axis acceleration */
+	input_set_abs_params(akm->input_dev, ABS_Z, -5760, 5760, 0, 0);
+	/* temparature */
+	input_set_abs_params(akm->input_dev, ABS_THROTTLE, -30, 85, 0, 0);
+	/* status of magnetic sensor */
+	input_set_abs_params(akm->input_dev, ABS_RUDDER, 0, 3, 0, 0);
+	/* status of acceleration sensor */
+	input_set_abs_params(akm->input_dev, ABS_WHEEL, 0, 3, 0, 0);
+	/* x-axis of raw magnetic vector */
+	input_set_abs_params(akm->input_dev, ABS_HAT0X, -2048, 2032, 0, 0);
+	/* y-axis of raw magnetic vector */
+	input_set_abs_params(akm->input_dev, ABS_HAT0Y, -2048, 2032, 0, 0);
+	/* z-axis of raw magnetic vector */
+	input_set_abs_params(akm->input_dev, ABS_BRAKE, -2048, 2032, 0, 0);
+	
+	akm->input_dev->name = "compass";
+
+	err = input_register_device(akm->input_dev);
+	if (err) {
+		printk("Unable to register input device: %s\n",akm->input_dev->name);
+		goto exit_input_register_device_failed;
+	}
+
+	err = misc_register(&akmd_device);
+	if (err) {
+		printk(KERN_ERR "akm8973_probe: akmd_device register failed\n");
+		goto exit_misc_device_register_failed;
+	}
+
+	err = misc_register(&akm_aot_device);
+	if (err) {
+		printk("akm_aot_device register failed\n");
+		goto exit_misc_device_register_failed;
+	}
+
+	err = device_create_file(&new_client->dev, &dev_attr_ms1);
+
+	AKECS_GetEEPROMData();
+
+	AKECS_SetMode(AKECS_MODE_POWERDOWN);
+	udelay(100);
+	
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	akm->early_suspend.suspend = ak8973b_early_suspend;
+	akm->early_suspend.resume = ak8973b_early_resume;
+	register_early_suspend(&akm->early_suspend);
+#endif /* CONFIG_HAS_EARLYSUSPEND */ 
+	
+	return 0;
+
+exit_misc_device_register_failed:
+exit_input_register_device_failed:
+	input_free_device(akm->input_dev);
+exit_input_dev_alloc_failed:
+	kfree(akm);
+exit_alloc_data_failed:
+	return err;
+
+ERROR1:
+	printk("%s ERROR1\n",__func__);/* add by inter.park */
+	kfree(new_client);
+ERROR0:
+	printk("%s ERROR0\n",__func__);/* add by inter.park */
+	return err;
+}
+
+
+static int i2c_ak8973b_attach_adapter(struct i2c_adapter *adapter)
+{	
+	return i2c_probe(adapter, &addr_data, &i2c_ak8973b_probe_client);
+}
+
+static int i2c_ak8973b_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	struct ak8973b_data *akm = i2c_get_clientdata(client);
+	
+	/* Try to detach the client from i2c space */
+	if ((err = i2c_detach_client(client))) {
+		return err;
+	}
+	
+	input_unregister_device(akm->input_dev);
+
+	misc_deregister(&akm_aot_device);
+	misc_deregister(&akmd_device);
+	
+	kfree(akm);
+	kfree(client); 
+	akm = NULL;	
+	this_client = NULL;
+	
+	gpio_free(GPIO_MSENSE_RST);
+	
+	gprintk("end\n");
+	return 0;
+}
+
+
+static int __init ak8973b_init(void)
+{
+	gprintk("__start\n");
+	ak8973b_init_hw();
+	AKECS_Reset(); /*module reset */
+	udelay(200);
+
+	return i2c_add_driver(&ak8973b_i2c_driver);
+}
+
+static void __exit ak8973b_exit(void)
+{
+	gprintk("__exit\n");
+	i2c_del_driver(&ak8973b_i2c_driver);
+}
+
+module_init(ak8973b_init);
+module_exit(ak8973b_exit);
+
+MODULE_AUTHOR("SAMSUNG");
+MODULE_DESCRIPTION("AK8973B compass driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/sensor/compass/ak8973b.h linux-2.6.29-spica/drivers/sensor/compass/ak8973b.h
--- linux-2.6.29/drivers/sensor/compass/ak8973b.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/compass/ak8973b.h	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,124 @@
+/*
+ * Definitions for ak8973 compass chip.
+ */
+#ifndef AK8973B_H
+#define AK8973B_H
+
+#include <linux/ioctl.h>
+
+#define SENSOR_OPER_MODE			1 /*0: acc only, 1: all */
+
+
+/* Compass device dependent definition */
+#define AKECS_MODE_MEASURE  0x00    /* Starts measurement. Please use AKECS_MODE_MEASURE_SNG */
+/* or AKECS_MODE_MEASURE_SEQ instead of this. */
+#define AKECS_MODE_PFFD     0x01    /* Start pedometer and free fall detect. */
+#define AKECS_MODE_E2P_READ 0x02    /* E2P access mode (read). */
+#define AKECS_MODE_POWERDOWN    0x03    /* Power down mode */
+
+#define AKECS_MODE_MEASURE_SNG  0x10    /* Starts single measurement */
+#define AKECS_MODE_MEASURE_SEQ  0x11    /* Starts sequential measurement */
+
+/* Default register settings */
+#define CSPEC_AINT      0x01    /* Amplification for acceleration sensor */
+#define CSPEC_SNG_NUM       0x01    /* Single measurement mode */
+#define CSPEC_SEQ_NUM       0x02    /* Sequential measurement mode */
+#define CSPEC_SFRQ_32       0x00    /* Measurement frequency: 32Hz */
+#define CSPEC_SFRQ_64       0x01    /* Measurement frequency: 64Hz */
+#define CSPEC_MCS       0x07    /* Clock frequency */
+#define CSPEC_MKS       0x01    /* Clock type: CMOS level */
+#define CSPEC_INTEN     0x01    /* Interruption pin enable: Enable */
+
+
+#define RBUFF_SIZE		31	/* Rx buffer size */
+#define MAX_CALI_SIZE	0x1000U	/* calibration buffer size */
+#define AKECS_REG_ST		0xC0
+#define AKECS_REG_TMPS		0xC1
+#define AKECS_REG_H1X		0xC2
+#define AKECS_REG_H1Y		0xC3
+#define AKECS_REG_H1Z		0xC4
+#define AKECS_REG_MS1		0xE0
+
+#define AKECS_REG_HXDA		0xE1
+#define AKECS_REG_HYDA		0xE2
+#define AKECS_REG_HZDA		0xE3
+#define AKECS_REG_HXGA		0xE4
+#define AKECS_REG_HYGA		0xE5
+#define AKECS_REG_HZGA		0xE6
+
+// AKECS EEPROM address
+#define AKECS_EEP_ETS		  0x62
+#define AKECS_EEP_EVIR		0x63
+#define AKECS_EEP_EIHE		0x64
+#define AKECS_EEP_ETST		0x65
+#define AKECS_EEP_EHXGA	  0x66
+#define AKECS_EEP_EHYGA	  0x67
+#define AKECS_EEP_EHZGA	  0x68
+#define AKMIO				0xA1
+
+/* IOCTLs for AKM library */
+#define ECS_IOCTL_INIT                  _IO(AKMIO, 0x01)
+#define ECS_IOCTL_WRITE                 _IOW(AKMIO, 0x02, char[5])
+#define ECS_IOCTL_READ                  _IOWR(AKMIO, 0x03, char[5])
+#define ECS_IOCTL_RESET      	          _IO(AKMIO, 0x04)
+#define ECS_IOCTL_INT_STATUS            _IO(AKMIO, 0x05)
+#define ECS_IOCTL_FFD_STATUS            _IO(AKMIO, 0x06)
+#define ECS_IOCTL_SET_MODE              _IOW(AKMIO, 0x07, short)
+#define ECS_IOCTL_GETDATA               _IOR(AKMIO, 0x08, char[RBUFF_SIZE+1])
+#define ECS_IOCTL_GET_NUMFRQ            _IOR(AKMIO, 0x09, char[2])
+#define ECS_IOCTL_SET_PERST             _IO(AKMIO, 0x0A)
+#define ECS_IOCTL_SET_G0RST             _IO(AKMIO, 0x0B)
+#define ECS_IOCTL_SET_YPR               _IOW(AKMIO, 0x0C, short[12])
+#define ECS_IOCTL_GET_OPEN_STATUS       _IOR(AKMIO, 0x0D, int)
+#define ECS_IOCTL_GET_CLOSE_STATUS      _IOR(AKMIO, 0x0E, int)
+#define ECS_IOCTL_GET_CALI_DATA         _IOR(AKMIO, 0x0F, char[MAX_CALI_SIZE])
+#define ECS_IOCTL_GET_DELAY             _IOR(AKMIO, 0x30, short)
+
+#define EMCS_IOCTL_OPEN		201
+#define EMCS_IOCTL_CLOSE	202
+#define ECS_IOCTL_DEVMGR_GET_DATA	203							/* for Device Manager Test */
+
+/* IOCTLs for APPs */
+#define ECS_IOCTL_APP_SET_MODE		_IOW(AKMIO, 0x10, short)
+#define ECS_IOCTL_APP_SET_MFLAG		_IOW(AKMIO, 0x11, short)
+#define ECS_IOCTL_APP_GET_MFLAG		_IOW(AKMIO, 0x12, short)
+#define ECS_IOCTL_APP_SET_AFLAG		_IOW(AKMIO, 0x13, short)
+#define ECS_IOCTL_APP_GET_AFLAG		_IOR(AKMIO, 0x14, short)
+#define ECS_IOCTL_APP_SET_TFLAG		_IOR(AKMIO, 0x15, short)
+#define ECS_IOCTL_APP_GET_TFLAG		_IOR(AKMIO, 0x16, short)
+#define ECS_IOCTL_APP_RESET_PEDOMETER   _IO(AKMIO, 0x17)
+#define ECS_IOCTL_APP_SET_DELAY		_IOW(AKMIO, 0x18, short)
+#define ECS_IOCTL_APP_GET_DELAY		ECS_IOCTL_GET_DELAY
+#define ECS_IOCTL_APP_SET_MVFLAG	_IOW(AKMIO, 0x19, short)	/* Set raw magnetic vector flag */
+#define ECS_IOCTL_APP_GET_MVFLAG	_IOR(AKMIO, 0x1A, short)	/* Get raw magnetic vector flag */
+
+/* IOCTLs for pedometer */
+#define ECS_IOCTL_SET_STEP_CNT          _IOW(AKMIO, 0x20, short)
+
+#define ECS_IOCTL_APP_SET_ACC_MODE _IO(AKMIO, 0x21)
+
+/* Default GPIO setting */
+#define ECS_RST		108	/*MISC4, bit2 */
+//#define ECS_CLK_ON	103  //for compile,  dont necessary
+//#define ECS_INTR		102	/*INT2, bit1 */
+
+#define AK8973B_PERIOD 500000000 //0.5 sec
+
+/*********** for debug **********************************************************/
+#if 0 
+#define gprintk(fmt, x... ) printk( "%s(%d): " fmt, __FUNCTION__ ,__LINE__, ## x)
+#else
+#define gprintk(x...) do { } while (0)
+#endif 
+/*******************************************************************************/
+
+struct akm8976_platform_data {
+	int reset;
+	int clk_on;
+	int intr;
+};
+
+extern char *get_akm_cal_ram(void);
+
+#endif
+
diff -Nur linux-2.6.29/drivers/sensor/compass/Kconfig linux-2.6.29-spica/drivers/sensor/compass/Kconfig
--- linux-2.6.29/drivers/sensor/compass/Kconfig	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/compass/Kconfig	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,22 @@
+#
+# MAGNETIC Sensor Configuration
+#
+
+
+
+config COMPASS                                                              
+	bool "MAGNETIC Sensor"
+	default y
+	help
+	This option enables magnetic sensors  
+	   
+
+config COMPASS_AK8973B
+	depends on COMPASS
+	tristate "AK8973B driver for s3c6410"
+	default y
+	help
+	  This option enables magnetic sensors using ak8973b driver.
+	  It is optimized for s3c6410.
+	  
+
diff -Nur linux-2.6.29/drivers/sensor/compass/Makefile linux-2.6.29-spica/drivers/sensor/compass/Makefile
--- linux-2.6.29/drivers/sensor/compass/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/compass/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,12 @@
+##############################################################################
+# COPYRIGHT(C)	: Samsung Electronics Co.Ltd, 2006-2011 ALL RIGHTS RESERVED
+# AUTHOR		: Throughc
+##############################################################################
+# VERSION&DATE	: Version 1.00	2007/12/25 (Throughc)
+##############################################################################
+
+
+obj-$(CONFIG_COMPASS_AK8973B)	+= ak8973b.o
+
+
+
diff -Nur linux-2.6.29/drivers/sensor/Kconfig linux-2.6.29-spica/drivers/sensor/Kconfig
--- linux-2.6.29/drivers/sensor/Kconfig	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/Kconfig	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,25 @@
+#
+#
+#
+
+
+menuconfig NEW_SENSORS
+	bool "Sensors Support"
+	help
+	  Say Y to enable Sensors support.  This allows control of supported
+	  Sensors.
+
+	  
+	  
+
+if NEW_SENSORS
+
+source "drivers/sensor/accel/Kconfig"
+
+source "drivers/sensor/compass/Kconfig"
+
+source "drivers/sensor/optical/Kconfig"
+
+
+
+endif # NEW_SENSORS
diff -Nur linux-2.6.29/drivers/sensor/Makefile linux-2.6.29-spica/drivers/sensor/Makefile
--- linux-2.6.29/drivers/sensor/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,12 @@
+#
+# Makefile for the kernel Sensor device drivers.
+#
+
+# Object files in subdirectories
+
+obj-$(CONFIG_OPTICAL)		+= optical/
+
+obj-$(CONFIG_ACCEL)			+= accel/
+
+obj-$(CONFIG_COMPASS)		+= compass/
+
diff -Nur linux-2.6.29/drivers/sensor/optical/gp2a.c linux-2.6.29-spica/drivers/sensor/optical/gp2a.c
--- linux-2.6.29/drivers/sensor/optical/gp2a.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/optical/gp2a.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,877 @@
+/* 
+ *  Title : Optical Sensor(light sensor + proximity sensor) driver for GP2AP002A00F   
+ *  Date  : 2009.02.27
+ *  Name  : ms17.kim
+ *
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/i2c.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/gpio.h>
+#include <mach/hardware.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+
+#include <linux/input.h>
+#include <linux/workqueue.h>
+
+
+
+#include "gp2a.h"
+
+/*********** for debug **********************************************************/
+#if 0 
+#define gprintk(fmt, x... ) printk( "%s(%d): " fmt, __FUNCTION__ ,__LINE__, ## x)
+#else
+#define gprintk(x...) do { } while (0)
+#endif
+/*******************************************************************************/
+
+
+
+
+
+/* global var */
+static struct i2c_client *opt_i2c_client = NULL;
+
+struct class *lightsensor_class;
+
+struct device *switch_cmd_dev;
+
+static bool light_enable = OFF;
+static bool proximity_enable = OFF;
+static state_type cur_state = STATE_0;
+
+static short proximity_value = 0;
+
+
+
+
+
+
+static struct i2c_driver opt_i2c_driver = {
+	.driver = {
+		.name = "gp2a",
+	},
+	//.id = GP2A_ID,
+	.attach_adapter = &opt_attach_adapter,
+};
+
+
+static struct file_operations proximity_fops = {
+	.owner  = THIS_MODULE,
+	.open   = proximity_open,
+    .release = proximity_release,
+    .unlocked_ioctl = proximity_ioctl,
+};
+                 
+static struct miscdevice proximity_device = {
+    .minor  = MISC_DYNAMIC_MINOR,
+    .name   = "proximity",
+    .fops   = &proximity_fops,
+};
+
+static unsigned short opt_normal_i2c[] = {(GP2A_ADDR>>1),I2C_CLIENT_END};
+static unsigned short opt_ignore[] = {1,(GP2A_ADDR>>1),I2C_CLIENT_END};
+static unsigned short opt_probe[] = {I2C_CLIENT_END};
+
+
+
+
+static struct i2c_client_address_data opt_addr_data = {
+	.normal_i2c = opt_normal_i2c,
+	.ignore		= opt_ignore,
+	.probe		= opt_probe,	
+};
+
+short gp2a_get_proximity_value()
+{
+	  return proximity_value;
+
+}
+EXPORT_SYMBOL(gp2a_get_proximity_value);
+
+
+
+/*****************************************************************************************
+ *  
+ *  function    : gp2a_work_func_light 
+ *  description : This function is for light sensor. It has a few state.
+ *                "STATE_0" means that circumstance in which you are now is clear as day.
+ *                The more value is increased, the more circumstance is dark. 
+ *                 
+ */
+
+void gp2a_work_func_light(struct work_struct *work)
+{
+	//struct gp2a_data *gp2a = container_of(work, struct gp2a_data, work_light);
+	int adc=0;
+	int i;
+
+	bool top = false;
+	bool bottom = false; 
+
+	/* read adc data from s3c64xx */
+	adc = s3c_adc_get_adc_data(ADC_CHANNEL);
+	gprintk("adc = %d \n",adc);
+	gprintk("cur_state = %d\n",cur_state);
+	
+	/* decision to check value whether it is suitable for current state */
+	if(adc < light_state[cur_state].adc_bottom_limit)
+	{
+		/* value of ADC is not suitable for current state */
+		/* ask to move state downward */
+		bottom = true;
+		gprintk("bottom flag is set \n");
+	}
+	
+
+	/* decision to check value whether it is suitable for current state */
+	if(adc > light_state[cur_state].adc_top_limit)
+	{
+		/* value of ADC is not suitable for current state */
+		/* ask to move state upward */
+
+		top = true;
+		gprintk("top flag is set \n");
+	}
+
+	/* process to move state downward  */
+	for(i=cur_state;i<STATE_NUM,bottom;i++)
+	{
+		gprintk("for i = %d \n",i);
+
+		/* decison to change state more */
+		/* if condition is true, it is unavailable to move state any more */
+		if(adc > light_state[i+1].adc_bottom_limit)
+		{
+			cur_state = i +1;
+			gprintk("state is changed. cur_state is %d \n",cur_state);
+			break;
+		}
+	}
+
+	/* process to move state upward */
+	for(i=cur_state;i>0,top;i--)
+	{
+		gprintk("for i = %d \n",i);
+		/* decision to change state more */
+		/* if condition is true, it is unavailable to move state any more */
+		if(adc < light_state[i-1].adc_top_limit)
+		{
+			cur_state = i - 1;
+			gprintk("state is changed. cur_state is %d \n",cur_state);
+			break;
+		}
+
+	}
+		
+	/* if state is changed, adjust brightness of lcd */
+	if(bottom || top)
+	{
+
+		backlight_level_ctrl(light_state[cur_state].brightness);
+	}
+
+
+	
+	
+
+
+}
+
+
+/*****************************************************************************************
+ *  
+ *  function    : gp2a_timer_func 
+ *  description : This function is for light sensor. 
+ *                it operates every a few seconds. 
+ *                 
+ */
+
+static enum hrtimer_restart gp2a_timer_func(struct hrtimer *timer)
+{
+	struct gp2a_data *gp2a = container_of(timer, struct gp2a_data, timer);
+				
+	
+	queue_work(gp2a_wq, &gp2a->work_light);
+	hrtimer_start(&gp2a->timer,ktime_set(LIGHT_PERIOD,0),HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+/*****************************************************************************************
+ *  
+ *  function    : gp2a_work_func_prox 
+ *  description : This function is for proximity sensor (using B-1 Mode ). 
+ *                when INT signal is occured , it gets value from VO register.   
+ *
+ *                 
+ */
+
+void gp2a_work_func_prox(struct work_struct *work)
+{
+	struct gp2a_data *gp2a = container_of(work, struct gp2a_data, work_prox);
+	
+	unsigned char value;
+	unsigned char int_val=REGS_PROX;
+	unsigned char vout=0;
+
+	/* Read VO & INT Clear */
+
+	if(INT_CLEAR)
+	{
+		int_val = REGS_PROX | (1 <<7);
+	}
+	opt_i2c_read((u8)(int_val),&value,1);
+	vout = value & 0x01;
+	gprintk("value = %d \n",vout);
+
+
+	/* Report proximity information */
+	/* not fixed. */
+	proximity_value = vout;
+
+	if(USE_INPUT_DEVICE)
+	{
+    	input_report_abs(gp2a->input_dev,ABS_DISTANCE,(int)vout);
+    	input_sync(gp2a->input_dev);
+	
+	
+		mdelay(1);
+	}
+	
+	/* Write HYS Register */
+
+	if(!vout)
+	{
+		value = 0x40;
+
+	}
+	else
+	{
+		value = 0x20;
+
+	}
+
+	opt_i2c_write((u8)(REGS_HYS),&value);
+
+	/* Forcing vout terminal to go high */
+
+	value = 0x18;
+	opt_i2c_write((u8)(REGS_CON),&value);
+
+
+	/* enable INT */
+
+	enable_irq(gp2a->irq);
+
+	/* enabling VOUT terminal in nomal operation */
+
+	value = 0x00;
+
+	opt_i2c_write((u8)(REGS_CON),&value);
+
+}
+
+
+
+irqreturn_t gp2a_irq_handler(int irq, void *dev_id)
+{
+
+	struct gp2a_data *gp2a = dev_id;
+
+	gprintk("gp2a->irq = %d\n",gp2a->irq);
+
+	if(gp2a->irq !=-1)
+	{
+		disable_irq(gp2a->irq);
+
+		queue_work(gp2a_wq, &gp2a->work_prox);
+
+	}
+
+	return IRQ_HANDLED;
+
+
+}
+
+
+static int opt_attach(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct i2c_client *c;
+	int ret,err=0;
+
+	
+	gprintk("\n");
+	if ( !i2c_check_functionality(adap,I2C_FUNC_SMBUS_BYTE_DATA) ) {
+		printk(KERN_INFO "byte op is not permited.\n");
+		return err;
+	}
+	c = kzalloc(sizeof(struct i2c_client),GFP_KERNEL);
+	if (!c)
+	{
+		printk("kzalloc error \n");
+		return -ENOMEM;
+
+	}
+
+	memset(c, 0, sizeof(struct i2c_client));	
+	strncpy(c->name,"gp2a",I2C_NAME_SIZE);
+	c->addr = addr;
+	c->adapter = adap;
+	c->driver = &opt_i2c_driver;
+	c->flags = I2C_DF_NOTIFY | I2C_M_IGNORE_NAK;
+
+	if ((ret = i2c_attach_client(c)) < 0)
+	{
+		printk("i2c_attach_client error\n");
+		goto error;
+	}
+	opt_i2c_client = c;
+
+	gprintk("\n");
+	return ret;
+
+error:
+	printk("in %s , ret = %d \n",__func__,ret);
+	kfree(c);
+	return err;
+}
+
+static int opt_attach_adapter(struct i2c_adapter *adap)
+{
+	int ret;
+	gprintk("\n");
+	ret =  i2c_probe(adap, &opt_addr_data, opt_attach);
+	return ret;
+}
+
+
+static int opt_i2c_init(void) 
+{
+	
+	
+	if( i2c_add_driver(&opt_i2c_driver))
+	{
+		printk("i2c_add_driver failed \n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+
+int opt_i2c_read(u8 reg, u8 *val, unsigned int len )
+{
+
+	int err;
+	u8 buf[1];
+	struct i2c_msg msg[2];
+
+
+	buf[0] = reg; 
+
+	msg[0].addr = opt_i2c_client->addr;
+	msg[0].flags = 1;
+	
+	msg[0].len = 2;
+	msg[0].buf = buf;
+	err = i2c_transfer(opt_i2c_client->adapter, msg, 1);
+
+	
+	*val = buf[1];
+	
+    if (err >= 0) return 0;
+
+    printk("%s %d i2c transfer error\n", __func__, __LINE__);
+    return err;
+}
+
+int opt_i2c_write( u8 reg, u8 *val )
+{
+    int err;
+    struct i2c_msg msg[1];
+    unsigned char data[2];
+
+    if( (opt_i2c_client == NULL) || (!opt_i2c_client->adapter) ){
+        return -ENODEV;
+    }
+
+
+    data[0] = reg;
+    data[1] = *val;
+
+    msg->addr = opt_i2c_client->addr;
+    msg->flags = I2C_M_WR;
+    msg->len = 2;
+    msg->buf = data;
+
+    err = i2c_transfer(opt_i2c_client->adapter, msg, 1);
+
+    if (err >= 0) return 0;
+
+    printk("%s %d i2c transfer error\n", __func__, __LINE__);
+    return err;
+}
+
+
+
+void gp2a_chip_init(void)
+{
+	gprintk("\n");
+	
+	/* Power On */
+	if (gpio_is_valid(GPIO_LUM_PWM))
+	{
+		if (gpio_request(GPIO_LUM_PWM, S3C_GPIO_LAVEL(GPIO_LUM_PWM)))
+			printk(KERN_ERR "Filed to request GPIO_LUM_PWM!\n");
+		gpio_direction_output(GPIO_LUM_PWM, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_LUM_PWM, S3C_GPIO_PULL_NONE); 
+
+	mdelay(5);
+	
+	/* set INT 	*/
+	s3c_gpio_cfgpin(GPIO_PS_VOUT, S3C_GPIO_SFN(GPIO_PS_VOUT_AF));
+	s3c_gpio_setpull(GPIO_PS_VOUT, S3C_GPIO_PULL_NONE);
+
+	set_irq_type(IRQ_GP2A_INT, IRQ_TYPE_EDGE_FALLING);
+		
+	
+}
+
+
+/*****************************************************************************************
+ *  
+ *  function    : gp2a_on 
+ *  description : This function is power-on function for optical sensor.
+ *
+ *  int type    : Sensor type. Two values is available (PROXIMITY,LIGHT).
+ *                it support power-on function separately.
+ *                
+ *                 
+ */
+
+void gp2a_on(struct gp2a_data *gp2a, int type)
+{
+	u8 value;
+	gprintk("gp2a_on(%d)\n",type);
+	if((type ==LIGHT && proximity_enable==OFF) || (type==PROXIMITY && light_enable==OFF)) 
+	{
+		gprintk("gp2a power on \n");
+		value = 0x18;
+		opt_i2c_write((u8)(REGS_CON),&value);
+
+		value = 0x40;
+		opt_i2c_write((u8)(REGS_HYS),&value);
+
+		value = 0x03;
+		opt_i2c_write((u8)(REGS_OPMOD),&value);
+
+		if(type == PROXIMITY)
+		{
+			gprintk("enable irq for proximity\n");
+			enable_irq(gp2a ->irq);
+		}
+
+		value = 0x00;
+		opt_i2c_write((u8)(REGS_CON),&value);
+
+	}
+
+	if(type ==PROXIMITY && light_enable ==ON)
+	{
+		gprintk("enable irq for proximity\n");
+		enable_irq(gp2a->irq);
+
+	}
+
+
+}
+
+/*****************************************************************************************
+ *  
+ *  function    : gp2a_off 
+ *  description : This function is power-off function for optical sensor.
+ *
+ *  int type    : Sensor type. Three values is available (PROXIMITY,LIGHT,ALL).
+ *                it support power-on function separately.
+ *                
+ *                 
+ */
+
+void gp2a_off(struct gp2a_data *gp2a, int type)
+{
+	u8 value;
+
+	gprintk("gp2a_off(%d)\n",type);
+	if((type == LIGHT && proximity_enable ==OFF)|| (type==PROXIMITY && light_enable==OFF)|| type==ALL)
+	{
+	
+		gprintk("gp2a power off \n");
+		if(type == PROXIMITY || type==ALL)
+		{
+			gprintk("disable irq for proximity \n");
+			disable_irq(gp2a ->irq);
+		}
+		value = 0x02;
+		opt_i2c_write((u8)(REGS_OPMOD),&value);
+		
+	}
+
+	if(type==PROXIMITY && light_enable ==ON)
+	{
+
+		gprintk("disable irq for proximity \n");
+		disable_irq(gp2a->irq);
+
+	}
+
+
+
+	
+}
+
+
+
+static ssize_t lightsensor_file_cmd_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+
+
+	return sprintf(buf,"%u\n",light_enable);
+}
+static ssize_t lightsensor_file_cmd_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct gp2a_data *gp2a = dev_get_drvdata(dev);
+	int value;
+    sscanf(buf, "%d", &value);
+
+	gprintk("in lightsensor_file_cmd_store, input value = %d \n",value);
+
+	if(value==1 && light_enable == OFF)
+	{
+		gp2a_on(gp2a,LIGHT);
+		value = ON;
+		light_enable = ON;
+		gprintk("timer start for light sensor\n");
+	    hrtimer_start(&gp2a->timer,ktime_set(LIGHT_PERIOD,0),HRTIMER_MODE_REL);
+	}
+	else if(value==0 && light_enable ==ON) 
+	{
+		gp2a_off(gp2a,LIGHT);
+		light_enable = OFF;
+		gprintk("timer cancel for light sensor\n");
+		hrtimer_cancel(&gp2a->timer);
+	}
+
+	/* temporary test code for proximity sensor */
+	else if(value==3 && proximity_enable == OFF)
+	{
+		gp2a_on(gp2a,PROXIMITY);
+		proximity_enable = ON;
+
+
+	}
+	else if(value==2 && proximity_enable == ON)
+	{
+		gp2a_off(gp2a,PROXIMITY);
+		proximity_enable = OFF;
+
+	}
+
+	return size;
+}
+
+static DEVICE_ATTR(lightsensor_file_cmd,0644, lightsensor_file_cmd_show, lightsensor_file_cmd_store);
+
+static int gp2a_opt_probe( struct platform_device* pdev )
+{
+	
+	struct gp2a_data *gp2a;
+	int irq;
+	int i;
+	int ret;
+
+	/* allocate driver_data */
+	gp2a = kzalloc(sizeof(struct gp2a_data),GFP_KERNEL);
+	if(!gp2a)
+	{
+		pr_err("kzalloc error\n");
+		return -ENOMEM;
+
+	}
+
+
+	gprintk("in %s \n",__func__);
+	
+	/* init i2c */
+	opt_i2c_init();
+
+	if(opt_i2c_client == NULL)
+	{
+		pr_err("opt_probe failed : i2c_client is NULL\n"); 
+		return -ENODEV;
+	}
+
+	/* hrtimer Settings */
+
+	hrtimer_init(&gp2a->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	gp2a->timer.function = gp2a_timer_func;
+
+	/* Input device Settings */
+	if(USE_INPUT_DEVICE)
+	{
+		gp2a->input_dev = input_allocate_device();
+		if (gp2a->input_dev == NULL) 
+		{
+			pr_err("Failed to allocate input device\n");
+			return -ENOMEM;
+		}
+		gp2a->input_dev->name = "proximity";
+	
+		set_bit(EV_SYN,gp2a->input_dev->evbit);
+		set_bit(EV_ABS,gp2a->input_dev->evbit);
+		
+   	 input_set_abs_params(gp2a->input_dev, ABS_DISTANCE, 0, 1, 0, 0);
+		
+	
+		ret = input_register_device(gp2a->input_dev);
+		if (ret) 
+		{
+			pr_err("Unable to register %s input device\n", gp2a->input_dev->name);
+			input_free_device(gp2a->input_dev);
+			kfree(gp2a);
+			return -1;
+		}
+
+	}
+	/* WORK QUEUE Settings */
+
+
+    gp2a_wq = create_singlethread_workqueue("gp2a_wq");
+    if (!gp2a_wq)
+	    return -ENOMEM;
+    INIT_WORK(&gp2a->work_prox, gp2a_work_func_prox);
+    INIT_WORK(&gp2a->work_light, gp2a_work_func_light);
+	gprintk("Workqueue Settings complete\n");
+
+	/* misc device Settings */
+	ret = misc_register(&proximity_device);
+	if(ret) {
+		pr_err(KERN_ERR "misc_register failed \n");
+	}
+
+
+	/* INT Settings */	
+
+	irq = IRQ_GP2A_INT;
+	gp2a->irq = -1;
+	ret = request_irq(irq, gp2a_irq_handler, 0, "gp2a_int", gp2a);
+	if (ret) {
+		pr_err("unable to request irq %d\n", irq);
+		return ret;
+	}       
+	gp2a->irq = irq;
+
+	gprintk("INT Settings complete\n");
+
+	/* set platdata */
+	platform_set_drvdata(pdev, gp2a);
+
+	/* set sysfs for light sensor */
+
+	lightsensor_class = class_create(THIS_MODULE, "lightsensor");
+	if (IS_ERR(lightsensor_class))
+		pr_err("Failed to create class(lightsensor)!\n");
+
+	switch_cmd_dev = device_create(lightsensor_class, NULL, 0, NULL, "switch_cmd");
+	if (IS_ERR(switch_cmd_dev))
+		pr_err("Failed to create device(switch_cmd_dev)!\n");
+
+	if (device_create_file(switch_cmd_dev, &dev_attr_lightsensor_file_cmd) < 0)
+		pr_err("Failed to create device file(%s)!\n", dev_attr_lightsensor_file_cmd.attr.name);
+
+	dev_set_drvdata(switch_cmd_dev,gp2a);
+	
+
+
+	/* GP2A Regs INIT SETTINGS */
+	
+
+	for(i=1;i<5;i++)
+	{
+		opt_i2c_write((u8)(i),&gp2a_original_image[i]);
+	}
+
+	mdelay(2);
+
+
+
+
+	/* maintain power-down mode before using sensor */
+
+	gp2a_off(gp2a,ALL);
+	
+	return 0;
+}
+
+static int gp2a_opt_suspend( struct platform_device* pdev, pm_message_t state )
+{
+	struct gp2a_data *gp2a = platform_get_drvdata(pdev);
+	u8 value;
+	gprintk("gp2a = %x,pdev->dev %x\n",gp2a,pdev->dev);
+
+	if(proximity_enable)
+		disable_irq(gp2a ->irq);
+
+	if(proximity_enable || light_enable)
+	{
+		value = 0x02;
+		opt_i2c_write((u8)(REGS_OPMOD),&value);
+	}
+
+
+
+
+	return 0;
+}
+
+static int gp2a_opt_resume( struct platform_device* pdev )
+{
+
+	struct gp2a_data *gp2a = platform_get_drvdata(pdev);
+	u8 value;
+
+	gprintk("gp2a = %x, pdev->dev.driver_data = %x\n",gp2a,pdev->dev.driver_data);
+
+	if(proximity_enable || light_enable)
+	{
+
+		value = 0x18;
+		opt_i2c_write((u8)(REGS_CON),&value);
+
+		value = 0x40;
+		opt_i2c_write((u8)(REGS_HYS),&value);
+
+		value = 0x03;
+		opt_i2c_write((u8)(REGS_OPMOD),&value);
+
+		if(proximity_enable)
+			enable_irq(gp2a ->irq);
+
+		value = 0x00;
+		opt_i2c_write((u8)(REGS_CON),&value);
+
+	}
+	
+
+
+
+	return 0;
+}
+
+static int proximity_open(struct inode *ip, struct file *fp)
+{
+	return 0;
+
+}
+
+static int proximity_release(struct inode *ip, struct file *fp)
+{
+	return 0;
+
+}
+
+static long proximity_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+
+	struct gp2a_data *gp2a = dev_get_drvdata(switch_cmd_dev);
+	int ret=0;
+	switch(cmd) {
+
+		case SHARP_GP2AP_OPEN:
+			{
+				printk(KERN_INFO "[PROXIMITY] %s : case OPEN\n", __FUNCTION__);
+				gp2a_on(gp2a,PROXIMITY);
+				proximity_enable =1;
+				
+			}
+			break;
+
+		case SHARP_GP2AP_CLOSE:
+			{
+				printk(KERN_INFO "[PROXIMITY] %s : case CLOSE\n", __FUNCTION__);
+				gp2a_off(gp2a,PROXIMITY);
+				proximity_enable=0;
+			}
+			break;
+
+		default:
+			printk(KERN_INFO "[PROXIMITY] unknown ioctl %d\n", cmd);
+			ret = -1;
+			break;
+	}
+	return ret;
+}
+
+
+
+
+
+static struct platform_driver gp2a_opt_driver = {
+	.probe 	 = gp2a_opt_probe,
+	.suspend = gp2a_opt_suspend,
+	.resume  = gp2a_opt_resume,
+	.driver  = {
+		.name = "gp2a-opt",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init gp2a_opt_init(void)
+{
+	int ret;
+	
+	gp2a_chip_init();
+	ret = platform_driver_register(&gp2a_opt_driver);
+	return ret;
+	
+	
+}
+static void __exit gp2a_opt_exit(void)
+{
+	struct gp2a_data *gp2a = dev_get_drvdata(switch_cmd_dev);
+    if (gp2a_wq)
+		destroy_workqueue(gp2a_wq);
+
+	free_irq(IRQ_GP2A_INT,gp2a);
+	
+	
+	gpio_direction_output(GPIO_LUM_PWM,GPIO_LEVEL_LOW);
+
+	
+	if(USE_INPUT_DEVICE)
+		input_unregister_device(gp2a->input_dev);
+	kfree(gp2a);
+
+	gpio_free(GPIO_LUM_PWM);
+	platform_driver_unregister(&gp2a_opt_driver);
+}
+
+
+module_init( gp2a_opt_init );
+module_exit( gp2a_opt_exit );
+
+MODULE_AUTHOR("SAMSUNG");
+MODULE_DESCRIPTION("Optical Sensor driver for gp2ap002a00f");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/sensor/optical/gp2a.h linux-2.6.29-spica/drivers/sensor/optical/gp2a.h
--- linux-2.6.29/drivers/sensor/optical/gp2a.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/optical/gp2a.h	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,139 @@
+#ifndef __GP2A_H__
+#define __GP2A_H__
+
+#define I2C_M_WR 0 /* for i2c */
+#define I2c_M_RD 1 /* for i2c */
+
+
+
+#define IRQ_GP2A_INT IRQ_EINT(20)  /*s3c64xx int number */
+
+#define I2C_DF_NOTIFY			0x01 /* for i2c */
+
+//ADDSEL is LOW
+#define GP2A_ADDR		0x88 /* slave addr for i2c */
+
+#define REGS_PROX 	    0x0 // Read  Only
+#define REGS_GAIN    	0x1 // Write Only
+#define REGS_HYS		0x2 // Write Only
+#define REGS_CYCLE		0x3 // Write Only
+#define REGS_OPMOD		0x4 // Write Only
+#define REGS_CON		0x6 // Write Only
+
+/* sensor type */
+#define LIGHT           0
+#define PROXIMITY		1
+#define ALL				2
+
+/* power control */
+#define ON              1
+#define OFF				0
+
+/* IOCTL for proximity sensor */
+#define SHARP_GP2AP_IOC_MAGIC   'C'                                 
+#define SHARP_GP2AP_OPEN    _IO(SHARP_GP2AP_IOC_MAGIC,1)            
+#define SHARP_GP2AP_CLOSE   _IO(SHARP_GP2AP_IOC_MAGIC,2)      
+
+/* input device for proximity sensor */
+#define USE_INPUT_DEVICE 	0
+
+
+#define INT_CLEAR    1 /* 0 = normal operation, 1 = INT operation */
+#define LIGHT_PERIOD 2 /* sec */
+#define ADC_CHANNEL  5 /* s3c6410 channel for adc */
+
+/*for light sensor */
+#define STATE_NUM				3   /* number of states */
+#define STATE_0_BRIGHTNESS    255   /* brightness of lcd */
+#define STATE_1_BRIGHTNESS 	  130    
+#define STATE_2_BRIGHTNESS     40
+
+#define ADC_CUT_HIGH 800            /* boundary line between STATE_0 and STATE_1 */
+#define ADC_CUT_LOW  300            /* boundary line between STATE_1 and STATE_2 */
+#define ADC_CUT_GAP  200            /* in order to prevent chattering condition */
+
+
+
+
+/* state type */
+typedef enum t_light_state
+{
+	STATE_0   = 0,
+	STATE_1   = 1,
+	STATE_2   = 2,
+	
+
+}state_type;
+
+
+/* initial value for sensor register */
+static u8 gp2a_original_image[8] =
+{
+	0x00,  
+	0x08,  
+	0x40,  	
+	0x04,  
+	0x03,   
+};
+
+
+/* for state transition */
+struct _light_state {
+	state_type type;
+	int adc_bottom_limit;
+	int adc_top_limit;
+	int brightness;
+
+};
+
+
+
+static struct _light_state light_state[] = {
+	[0] = {
+		.type = STATE_0, // 700~20000
+		.adc_bottom_limit = ADC_CUT_HIGH - ADC_CUT_GAP/2, 
+		.adc_top_limit    = 20000, //unlimited
+		.brightness		  = STATE_0_BRIGHTNESS,
+		},
+	[1] = {
+		.type = STATE_1, //200~900
+		.adc_bottom_limit = ADC_CUT_LOW  - ADC_CUT_GAP/2, 
+		.adc_top_limit    = ADC_CUT_HIGH + ADC_CUT_GAP/2, 
+		.brightness		  = STATE_1_BRIGHTNESS,
+		},
+	
+	[2] = {
+		.type = STATE_2,   //1~400
+		.adc_bottom_limit = 1,
+		.adc_top_limit    = ADC_CUT_LOW  + ADC_CUT_GAP/2,
+		.brightness		  = STATE_2_BRIGHTNESS,
+		},
+
+};
+
+
+
+
+/* driver data */
+struct gp2a_data {
+	struct input_dev *input_dev;
+	struct work_struct work_prox;  /* for proximity sensor */
+	struct work_struct work_light; /* for light_sensor     */
+	int             irq;
+    struct hrtimer timer;
+
+};
+
+
+struct workqueue_struct *gp2a_wq;
+
+/* prototype */
+int opt_i2c_read(u8 reg, u8 *val, unsigned int len );
+int opt_i2c_write( u8 reg, u8 *val );
+extern int s3c_adc_get_adc_data(int channel);
+void backlight_level_ctrl(s32 value);
+static int opt_attach_adapter(struct i2c_adapter *adap);
+static int proximity_open(struct inode *ip, struct file *fp);
+static int proximity_release(struct inode *ip, struct file *fp);
+static long proximity_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+#endif
diff -Nur linux-2.6.29/drivers/sensor/optical/Kconfig linux-2.6.29-spica/drivers/sensor/optical/Kconfig
--- linux-2.6.29/drivers/sensor/optical/Kconfig	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/optical/Kconfig	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,22 @@
+#
+# Optical Sensor Configuration
+#
+
+
+
+config OPTICAL                                                              
+	bool "Optical Sensor"
+	default n
+	help
+	This option enables proximity & light sensors  
+	   
+
+config OPTICAL_GP2A
+	depends on OPTICAL
+	tristate "GP2A driver for s3c6410"
+	default y
+	help
+	  This option enables proximity & light sensors using gp2a driver.
+	  It is optimized for s3c6410.
+	  
+
diff -Nur linux-2.6.29/drivers/sensor/optical/Makefile linux-2.6.29-spica/drivers/sensor/optical/Makefile
--- linux-2.6.29/drivers/sensor/optical/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/sensor/optical/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,14 @@
+##############################################################################
+# COPYRIGHT(C)	: Samsung Electronics Co.Ltd, 2006-2011 ALL RIGHTS RESERVED
+# AUTHOR		: Throughc
+##############################################################################
+# VERSION&DATE	: Version 1.00	2007/12/25 (Throughc)
+##############################################################################
+
+
+
+obj-$(CONFIG_OPTICAL_GP2A)	+= gp2a.o
+
+				  
+				  
+
diff -Nur linux-2.6.29/drivers/serial/Kconfig linux-2.6.29-spica/drivers/serial/Kconfig
--- linux-2.6.29/drivers/serial/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/serial/Kconfig	2010-05-06 12:42:45.644210217 +0700
@@ -457,9 +457,9 @@
 
 config SERIAL_SAMSUNG_UARTS
 	int
-	depends on ARM && PLAT_S3C
+	depends on SERIAL_SAMSUNG
 	default 2 if ARCH_S3C2400
-	default 4 if ARCH_S3C64XX || CPU_S3C2443
+	default 4 if ARCH_S3C64XX || CPU_S3C2443 || ARCH_S5PC1XX
 	default 3
 	help
 	  Select the number of available UART ports for the Samsung S3C
@@ -525,7 +525,7 @@
 	help
 	  Serial port support for the Samsung S3C24A0 SoC
 
-config SERIAL_S3C6400
+config SERIAL_S3C64XX
 	tristate "Samsung S3C6400/S3C6410 Serial port support"
 	depends on SERIAL_SAMSUNG && (CPU_S3C600 || CPU_S3C6410)
 	default y
@@ -533,6 +533,13 @@
 	  Serial port support for the Samsung S3C6400 and S3C6410
 	  SoCs
 
+config SERIAL_S5PC100
+	tristate "Samsung S5PC100 Serial port support"
+	depends on SERIAL_SAMSUNG && CPU_S5PC100
+	default y
+	help
+	  Serial port support for the Samsung S5PC100 SoCs
+
 config SERIAL_DZ
 	bool "DECstation DZ serial driver"
 	depends on MACH_DECSTATION && 32BIT
diff -Nur linux-2.6.29/drivers/serial/Makefile linux-2.6.29-spica/drivers/serial/Makefile
--- linux-2.6.29/drivers/serial/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/serial/Makefile	2010-05-06 12:42:45.644210217 +0700
@@ -42,7 +42,11 @@
 obj-$(CONFIG_SERIAL_S3C2412) += s3c2412.o
 obj-$(CONFIG_SERIAL_S3C2440) += s3c2440.o
 obj-$(CONFIG_SERIAL_S3C24A0) += s3c24a0.o
-obj-$(CONFIG_SERIAL_S3C6400) += s3c6400.o
+obj-$(CONFIG_SERIAL_S3C64XX) += s3c64xx.o
+obj-$(CONFIG_SERIAL_S5PC100) += s5pc100.o
+obj-$(CONFIG_SERIAL_SUNCORE) += suncore.o
+obj-$(CONFIG_SERIAL_SUNHV) += sunhv.o
+obj-$(CONFIG_SERIAL_SUNZILOG) += sunzilog.o
 obj-$(CONFIG_SERIAL_IP22_ZILOG) += ip22zilog.o
 obj-$(CONFIG_SERIAL_MUX) += mux.o
 obj-$(CONFIG_SERIAL_68328) += 68328serial.o
diff -Nur linux-2.6.29/drivers/serial/s3c64xx.c linux-2.6.29-spica/drivers/serial/s3c64xx.c
--- linux-2.6.29/drivers/serial/s3c64xx.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/serial/s3c64xx.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,151 @@
+/* linux/drivers/serial/s3c64xx.c
+ *
+ * Driver for Samsung S3C6400 and S3C6410 SoC onboard UARTs.
+ *
+ * Copyright 2008 Openmoko,  Inc.
+ * Copyright 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+
+#include <asm/irq.h>
+#include <mach/hardware.h>
+
+#include <plat/regs-serial.h>
+
+#include "samsung.h"
+
+static int s3c64xx_serial_setsource(struct uart_port *port,
+				    struct s3c_uart_clksrc *clk)
+{
+	unsigned long ucon = rd_regl(port, S3C_UCON);
+
+	if (strcmp(clk->name, "uclk0") == 0) {
+		ucon &= ~S3C64XX_UCON_CLKMASK;
+		ucon |= S3C64XX_UCON_UCLK0;
+	} else if (strcmp(clk->name, "uclk1") == 0)
+		ucon |= S3C64XX_UCON_UCLK1;
+	else if (strcmp(clk->name, "pclk") == 0) {
+		/* See notes about transitioning from UCLK to PCLK */
+		ucon &= ~S3C64XX_UCON_UCLK0;
+	} else {
+		printk(KERN_ERR "unknown clock source %s\n", clk->name);
+		return -EINVAL;
+	}
+
+	wr_regl(port, S3C_UCON, ucon);
+	return 0;
+}
+
+
+static int s3c64xx_serial_getsource(struct uart_port *port,
+				    struct s3c_uart_clksrc *clk)
+{
+	u32 ucon = rd_regl(port, S3C_UCON);
+
+	clk->divisor = 1;
+
+	switch (ucon & S3C64XX_UCON_CLKMASK) {
+	case S3C64XX_UCON_UCLK0:
+		clk->name = "uclk0";
+		break;
+
+	case S3C64XX_UCON_UCLK1:
+		clk->name = "uclk1";
+		break;
+
+	case S3C64XX_UCON_PCLK:
+	case S3C64XX_UCON_PCLK2:
+		clk->name = "pclk";
+		break;
+	}
+
+	return 0;
+}
+
+static int s3c64xx_serial_resetport(struct uart_port *port,
+				    struct s3c_uartcfg *cfg)
+{
+	unsigned long ucon = rd_regl(port, S3C_UCON);
+
+	dbg("s3c64xx_serial_resetport: port=%p (%08lx), cfg=%p\n",
+	    port, port->mapbase, cfg);
+
+	/* ensure we don't change the clock settings... */
+
+	ucon &= S3C64XX_UCON_CLKMASK;
+
+	wr_regl(port, S3C_UCON,  ucon | cfg->ucon);
+	wr_regl(port, S3C_ULCON, cfg->ulcon);
+
+	/* reset both fifos */
+
+	wr_regl(port, S3C_UFCON, cfg->ufcon | S3C_UFCON_RESETBOTH);
+	wr_regl(port, S3C_UFCON, cfg->ufcon);
+
+	return 0;
+}
+
+static struct s3c_uart_info s3c64xx_uart_inf = {
+	.name		= "Samsung S3C64XX UART",
+	.type		= PORT_S3C64XX,
+	.fifosize	= 64,
+	.rx_fifomask	= S3C64XX_UFSTAT_RXMASK,
+	.rx_fifoshift	= S3C64XX_UFSTAT_RXSHIFT,
+	.rx_fifofull	= S3C64XX_UFSTAT_RXFULL,
+	.tx_fifofull	= S3C64XX_UFSTAT_TXFULL,
+	.tx_fifomask	= S3C64XX_UFSTAT_TXMASK,
+	.tx_fifoshift	= S3C64XX_UFSTAT_TXSHIFT,
+	.get_clksrc	= s3c64xx_serial_getsource,
+	.set_clksrc	= s3c64xx_serial_setsource,
+	.reset_port	= s3c64xx_serial_resetport,
+};
+
+/* device management */
+
+static int s3c64xx_serial_probe(struct platform_device *dev)
+{
+	dbg("s3c64xx_serial_probe: dev=%p\n", dev);
+	return s3c_serial_probe(dev, &s3c64xx_uart_inf);
+}
+
+static struct platform_driver s3c64xx_serial_drv = {
+	.probe		= s3c64xx_serial_probe,
+	.remove		= s3c_serial_remove,
+	.driver		= {
+		.name	= "s3c64xx-uart",
+		.owner	= THIS_MODULE,
+	},
+};
+
+s3c_console_init(&s3c64xx_serial_drv, &s3c64xx_uart_inf);
+
+static int __init s3c64xx_serial_init(void)
+{
+	return s3c_serial_init(&s3c64xx_serial_drv, &s3c64xx_uart_inf);
+}
+
+static void __exit s3c64xx_serial_exit(void)
+{
+	platform_driver_unregister(&s3c64xx_serial_drv);
+}
+
+module_init(s3c64xx_serial_init);
+module_exit(s3c64xx_serial_exit);
+
+MODULE_DESCRIPTION("Samsung S3C64XX SoC Serial port driver");
+MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:s3c64xx-uart");
diff -Nur linux-2.6.29/drivers/serial/samsung.c linux-2.6.29-spica/drivers/serial/samsung.c
--- linux-2.6.29/drivers/serial/samsung.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/serial/samsung.c	2010-05-06 12:42:45.644210217 +0700
@@ -10,21 +10,6 @@
  * published by the Free Software Foundation.
 */
 
-/* Hote on 2410 error handling
- *
- * The s3c2410 manual has a love/hate affair with the contents of the
- * UERSTAT register in the UART blocks, and keeps marking some of the
- * error bits as reserved. Having checked with the s3c2410x01,
- * it copes with BREAKs properly, so I am happy to ignore the RESERVED
- * feature from the latter versions of the manual.
- *
- * If it becomes aparrent that latter versions of the 2410 remove these
- * bits, then action will have to be taken to differentiate the versions
- * and change the policy on BREAK
- *
- * BJD, 04-Nov-2004
-*/
-
 #if defined(CONFIG_SERIAL_SAMSUNG_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
 #define SUPPORT_SYSRQ
 #endif
@@ -53,11 +38,14 @@
 
 #include "samsung.h"
 
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+
 /* UART name and device definitions */
 
-#define S3C24XX_SERIAL_NAME	"ttySAC"
-#define S3C24XX_SERIAL_MAJOR	204
-#define S3C24XX_SERIAL_MINOR	64
+#define S3C_SERIAL_NAME	"ttySAC"
+#define S3C_SERIAL_MAJOR	204
+#define S3C_SERIAL_MINOR	64
 
 /* macros to change one thing to another */
 
@@ -67,24 +55,24 @@
 /* flag to ignore all characters comming in */
 #define RXSTAT_DUMMY_READ (0x10000000)
 
-static inline struct s3c24xx_uart_port *to_ourport(struct uart_port *port)
+static inline struct s3c_uart_port *to_ourport(struct uart_port *port)
 {
-	return container_of(port, struct s3c24xx_uart_port, port);
+	return container_of(port, struct s3c_uart_port, port);
 }
 
 /* translate a port to the device name */
 
-static inline const char *s3c24xx_serial_portname(struct uart_port *port)
+static inline const char *s3c_serial_portname(struct uart_port *port)
 {
 	return to_platform_device(port->dev)->name;
 }
 
-static int s3c24xx_serial_txempty_nofifo(struct uart_port *port)
+static int s3c_serial_txempty_nofifo(struct uart_port *port)
 {
-	return (rd_regl(port, S3C2410_UTRSTAT) & S3C2410_UTRSTAT_TXE);
+	return (rd_regl(port, S3C_UTRSTAT) & S3C_UTRSTAT_TXE);
 }
 
-static void s3c24xx_serial_rx_enable(struct uart_port *port)
+static void s3c_serial_rx_enable(struct uart_port *port)
 {
 	unsigned long flags;
 	unsigned int ucon, ufcon;
@@ -92,55 +80,55 @@
 
 	spin_lock_irqsave(&port->lock, flags);
 
-	while (--count && !s3c24xx_serial_txempty_nofifo(port))
+	while (--count && !s3c_serial_txempty_nofifo(port))
 		udelay(100);
 
-	ufcon = rd_regl(port, S3C2410_UFCON);
-	ufcon |= S3C2410_UFCON_RESETRX;
-	wr_regl(port, S3C2410_UFCON, ufcon);
-
-	ucon = rd_regl(port, S3C2410_UCON);
-	ucon |= S3C2410_UCON_RXIRQMODE;
-	wr_regl(port, S3C2410_UCON, ucon);
+	ufcon = rd_regl(port, S3C_UFCON);
+	ufcon |= S3C_UFCON_RESETRX;
+	wr_regl(port, S3C_UFCON, ufcon);
+
+	ucon = rd_regl(port, S3C_UCON);
+	ucon |= S3C_UCON_RXIRQMODE;
+	wr_regl(port, S3C_UCON, ucon);
 
 	rx_enabled(port) = 1;
 	spin_unlock_irqrestore(&port->lock, flags);
 }
 
-static void s3c24xx_serial_rx_disable(struct uart_port *port)
+static void s3c_serial_rx_disable(struct uart_port *port)
 {
 	unsigned long flags;
 	unsigned int ucon;
 
 	spin_lock_irqsave(&port->lock, flags);
 
-	ucon = rd_regl(port, S3C2410_UCON);
-	ucon &= ~S3C2410_UCON_RXIRQMODE;
-	wr_regl(port, S3C2410_UCON, ucon);
+	ucon = rd_regl(port, S3C_UCON);
+	ucon &= ~S3C_UCON_RXIRQMODE;
+	wr_regl(port, S3C_UCON, ucon);
 
 	rx_enabled(port) = 0;
 	spin_unlock_irqrestore(&port->lock, flags);
 }
 
-static void s3c24xx_serial_stop_tx(struct uart_port *port)
+static void s3c_serial_stop_tx(struct uart_port *port)
 {
-	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	struct s3c_uart_port *ourport = to_ourport(port);
 
 	if (tx_enabled(port)) {
 		disable_irq(ourport->tx_irq);
 		tx_enabled(port) = 0;
 		if (port->flags & UPF_CONS_FLOW)
-			s3c24xx_serial_rx_enable(port);
+			s3c_serial_rx_enable(port);
 	}
 }
 
-static void s3c24xx_serial_start_tx(struct uart_port *port)
+static void s3c_serial_start_tx(struct uart_port *port)
 {
-	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	struct s3c_uart_port *ourport = to_ourport(port);
 
 	if (!tx_enabled(port)) {
 		if (port->flags & UPF_CONS_FLOW)
-			s3c24xx_serial_rx_disable(port);
+			s3c_serial_rx_disable(port);
 
 		enable_irq(ourport->tx_irq);
 		tx_enabled(port) = 1;
@@ -148,38 +136,38 @@
 }
 
 
-static void s3c24xx_serial_stop_rx(struct uart_port *port)
+static void s3c_serial_stop_rx(struct uart_port *port)
 {
-	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	struct s3c_uart_port *ourport = to_ourport(port);
 
 	if (rx_enabled(port)) {
-		dbg("s3c24xx_serial_stop_rx: port=%p\n", port);
+		dbg("s3c_serial_stop_rx: port=%p\n", port);
 		disable_irq(ourport->rx_irq);
 		rx_enabled(port) = 0;
 	}
 }
 
-static void s3c24xx_serial_enable_ms(struct uart_port *port)
+static void s3c_serial_enable_ms(struct uart_port *port)
 {
 }
 
-static inline struct s3c24xx_uart_info *s3c24xx_port_to_info(struct uart_port *port)
+static inline struct s3c_uart_info *s3c_port_to_info(struct uart_port *port)
 {
 	return to_ourport(port)->info;
 }
 
-static inline struct s3c2410_uartcfg *s3c24xx_port_to_cfg(struct uart_port *port)
+static inline struct s3c_uartcfg *s3c_port_to_cfg(struct uart_port *port)
 {
 	if (port->dev == NULL)
 		return NULL;
 
-	return (struct s3c2410_uartcfg *)port->dev->platform_data;
+	return (struct s3c_uartcfg *)port->dev->platform_data;
 }
 
-static int s3c24xx_serial_rx_fifocnt(struct s3c24xx_uart_port *ourport,
+static int s3c_serial_rx_fifocnt(struct s3c_uart_port *ourport,
 				     unsigned long ufstat)
 {
-	struct s3c24xx_uart_info *info = ourport->info;
+	struct s3c_uart_info *info = ourport->info;
 
 	if (ufstat & info->rx_fifofull)
 		return info->fifosize;
@@ -189,29 +177,29 @@
 
 
 /* ? - where has parity gone?? */
-#define S3C2410_UERSTAT_PARITY (0x1000)
+#define S3C_UERSTAT_PARITY (0x1000)
 
 static irqreturn_t
-s3c24xx_serial_rx_chars(int irq, void *dev_id)
+s3c_serial_rx_chars(int irq, void *dev_id)
 {
-	struct s3c24xx_uart_port *ourport = dev_id;
+	struct s3c_uart_port *ourport = dev_id;
 	struct uart_port *port = &ourport->port;
 	struct tty_struct *tty = port->info->port.tty;
 	unsigned int ufcon, ch, flag, ufstat, uerstat;
 	int max_count = 64;
 
 	while (max_count-- > 0) {
-		ufcon = rd_regl(port, S3C2410_UFCON);
-		ufstat = rd_regl(port, S3C2410_UFSTAT);
+		ufcon = rd_regl(port, S3C_UFCON);
+		ufstat = rd_regl(port, S3C_UFSTAT);
 
-		if (s3c24xx_serial_rx_fifocnt(ourport, ufstat) == 0)
+		if (s3c_serial_rx_fifocnt(ourport, ufstat) == 0)
 			break;
 
-		uerstat = rd_regl(port, S3C2410_UERSTAT);
-		ch = rd_regb(port, S3C2410_URXH);
+		uerstat = rd_regl(port, S3C_UERSTAT);
+		ch = rd_regb(port, S3C_URXH);
 
 		if (port->flags & UPF_CONS_FLOW) {
-			int txe = s3c24xx_serial_txempty_nofifo(port);
+			int txe = s3c_serial_txempty_nofifo(port);
 
 			if (rx_enabled(port)) {
 				if (!txe) {
@@ -220,8 +208,8 @@
 				}
 			} else {
 				if (txe) {
-					ufcon |= S3C2410_UFCON_RESETRX;
-					wr_regl(port, S3C2410_UFCON, ufcon);
+					ufcon |= S3C_UFCON_RESETRX;
+					wr_regl(port, S3C_UFCON, ufcon);
 					rx_enabled(port) = 1;
 					goto out;
 				}
@@ -234,38 +222,38 @@
 		flag = TTY_NORMAL;
 		port->icount.rx++;
 
-		if (unlikely(uerstat & S3C2410_UERSTAT_ANY)) {
+		if (unlikely(uerstat & S3C_UERSTAT_ANY)) {
 			dbg("rxerr: port ch=0x%02x, rxs=0x%08x\n",
 			    ch, uerstat);
 
 			/* check for break */
-			if (uerstat & S3C2410_UERSTAT_BREAK) {
+			if (uerstat & S3C_UERSTAT_BREAK) {
 				dbg("break!\n");
 				port->icount.brk++;
 				if (uart_handle_break(port))
 				    goto ignore_char;
 			}
 
-			if (uerstat & S3C2410_UERSTAT_FRAME)
+			if (uerstat & S3C_UERSTAT_FRAME)
 				port->icount.frame++;
-			if (uerstat & S3C2410_UERSTAT_OVERRUN)
+			if (uerstat & S3C_UERSTAT_OVERRUN)
 				port->icount.overrun++;
 
 			uerstat &= port->read_status_mask;
 
-			if (uerstat & S3C2410_UERSTAT_BREAK)
+			if (uerstat & S3C_UERSTAT_BREAK)
 				flag = TTY_BREAK;
-			else if (uerstat & S3C2410_UERSTAT_PARITY)
+			else if (uerstat & S3C_UERSTAT_PARITY)
 				flag = TTY_PARITY;
-			else if (uerstat & (S3C2410_UERSTAT_FRAME |
-					    S3C2410_UERSTAT_OVERRUN))
+			else if (uerstat & (S3C_UERSTAT_FRAME |
+					    S3C_UERSTAT_OVERRUN))
 				flag = TTY_FRAME;
 		}
 
 		if (uart_handle_sysrq_char(port, ch))
 			goto ignore_char;
 
-		uart_insert_char(port, uerstat, S3C2410_UERSTAT_OVERRUN,
+		uart_insert_char(port, uerstat, S3C_UERSTAT_OVERRUN,
 				 ch, flag);
 
  ignore_char:
@@ -277,15 +265,15 @@
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t s3c24xx_serial_tx_chars(int irq, void *id)
+static irqreturn_t s3c_serial_tx_chars(int irq, void *id)
 {
-	struct s3c24xx_uart_port *ourport = id;
+	struct s3c_uart_port *ourport = id;
 	struct uart_port *port = &ourport->port;
 	struct circ_buf *xmit = &port->info->xmit;
 	int count = 256;
 
 	if (port->x_char) {
-		wr_regb(port, S3C2410_UTXH, port->x_char);
+		wr_regb(port, S3C_UTXH, port->x_char);
 		port->icount.tx++;
 		port->x_char = 0;
 		goto out;
@@ -296,17 +284,17 @@
 	*/
 
 	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
-		s3c24xx_serial_stop_tx(port);
+		s3c_serial_stop_tx(port);
 		goto out;
 	}
 
 	/* try and drain the buffer... */
 
 	while (!uart_circ_empty(xmit) && count-- > 0) {
-		if (rd_regl(port, S3C2410_UFSTAT) & ourport->info->tx_fifofull)
+		if (rd_regl(port, S3C_UFSTAT) & ourport->info->tx_fifofull)
 			break;
 
-		wr_regb(port, S3C2410_UTXH, xmit->buf[xmit->tail]);
+		wr_regb(port, S3C_UTXH, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		port->icount.tx++;
 	}
@@ -315,19 +303,19 @@
 		uart_write_wakeup(port);
 
 	if (uart_circ_empty(xmit))
-		s3c24xx_serial_stop_tx(port);
+		s3c_serial_stop_tx(port);
 
  out:
 	return IRQ_HANDLED;
 }
 
-static unsigned int s3c24xx_serial_tx_empty(struct uart_port *port)
+static unsigned int s3c_serial_tx_empty(struct uart_port *port)
 {
-	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
-	unsigned long ufstat = rd_regl(port, S3C2410_UFSTAT);
-	unsigned long ufcon = rd_regl(port, S3C2410_UFCON);
+	struct s3c_uart_info *info = s3c_port_to_info(port);
+	unsigned long ufstat = rd_regl(port, S3C_UFSTAT);
+	unsigned long ufcon = rd_regl(port, S3C_UFCON);
 
-	if (ufcon & S3C2410_UFCON_FIFOMODE) {
+	if (ufcon & S3C_UFCON_FIFOMODE) {
 		if ((ufstat & info->tx_fifomask) != 0 ||
 		    (ufstat & info->tx_fifofull))
 			return 0;
@@ -335,47 +323,47 @@
 		return 1;
 	}
 
-	return s3c24xx_serial_txempty_nofifo(port);
+	return s3c_serial_txempty_nofifo(port);
 }
 
 /* no modem control lines */
-static unsigned int s3c24xx_serial_get_mctrl(struct uart_port *port)
+static unsigned int s3c_serial_get_mctrl(struct uart_port *port)
 {
-	unsigned int umstat = rd_regb(port, S3C2410_UMSTAT);
+	unsigned int umstat = rd_regb(port, S3C_UMSTAT);
 
-	if (umstat & S3C2410_UMSTAT_CTS)
+	if (umstat & S3C_UMSTAT_CTS)
 		return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
 	else
 		return TIOCM_CAR | TIOCM_DSR;
 }
 
-static void s3c24xx_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+static void s3c_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
 	/* todo - possibly remove AFC and do manual CTS */
 }
 
-static void s3c24xx_serial_break_ctl(struct uart_port *port, int break_state)
+static void s3c_serial_break_ctl(struct uart_port *port, int break_state)
 {
 	unsigned long flags;
 	unsigned int ucon;
 
 	spin_lock_irqsave(&port->lock, flags);
 
-	ucon = rd_regl(port, S3C2410_UCON);
+	ucon = rd_regl(port, S3C_UCON);
 
 	if (break_state)
-		ucon |= S3C2410_UCON_SBREAK;
+		ucon |= S3C_UCON_SBREAK;
 	else
-		ucon &= ~S3C2410_UCON_SBREAK;
+		ucon &= ~S3C_UCON_SBREAK;
 
-	wr_regl(port, S3C2410_UCON, ucon);
+	wr_regl(port, S3C_UCON, ucon);
 
 	spin_unlock_irqrestore(&port->lock, flags);
 }
 
-static void s3c24xx_serial_shutdown(struct uart_port *port)
+static void s3c_serial_shutdown(struct uart_port *port)
 {
-	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	struct s3c_uart_port *ourport = to_ourport(port);
 
 	if (ourport->tx_claimed) {
 		free_irq(ourport->tx_irq, ourport);
@@ -391,18 +379,18 @@
 }
 
 
-static int s3c24xx_serial_startup(struct uart_port *port)
+static int s3c_serial_startup(struct uart_port *port)
 {
-	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	struct s3c_uart_port *ourport = to_ourport(port);
 	int ret;
 
-	dbg("s3c24xx_serial_startup: port=%p (%08lx,%p)\n",
+	dbg("s3c_serial_startup: port=%p (%08lx,%p)\n",
 	    port->mapbase, port->membase);
 
 	rx_enabled(port) = 1;
 
-	ret = request_irq(ourport->rx_irq, s3c24xx_serial_rx_chars, 0,
-			  s3c24xx_serial_portname(port), ourport);
+	ret = request_irq(ourport->rx_irq, s3c_serial_rx_chars, 0,
+			  s3c_serial_portname(port), ourport);
 
 	if (ret != 0) {
 		printk(KERN_ERR "cannot get irq %d\n", ourport->rx_irq);
@@ -415,8 +403,8 @@
 
 	tx_enabled(port) = 1;
 
-	ret = request_irq(ourport->tx_irq, s3c24xx_serial_tx_chars, 0,
-			  s3c24xx_serial_portname(port), ourport);
+	ret = request_irq(ourport->tx_irq, s3c_serial_tx_chars, 0,
+			  s3c_serial_portname(port), ourport);
 
 	if (ret) {
 		printk(KERN_ERR "cannot get irq %d\n", ourport->tx_irq);
@@ -425,7 +413,7 @@
 
 	ourport->tx_claimed = 1;
 
-	dbg("s3c24xx_serial_startup ok\n");
+	dbg("s3c_serial_startup ok\n");
 
 	/* the port reset code should have done the correct
 	 * register setup for the port controls */
@@ -433,16 +421,16 @@
 	return ret;
 
  err:
-	s3c24xx_serial_shutdown(port);
+	s3c_serial_shutdown(port);
 	return ret;
 }
 
 /* power power management control */
 
-static void s3c24xx_serial_pm(struct uart_port *port, unsigned int level,
+static void s3c_serial_pm(struct uart_port *port, unsigned int level,
 			      unsigned int old)
 {
-	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	struct s3c_uart_port *ourport = to_ourport(port);
 
 	ourport->pm_level = level;
 
@@ -462,13 +450,13 @@
 
 		break;
 	default:
-		printk(KERN_ERR "s3c24xx_serial: unknown pm %d\n", level);
+		printk(KERN_ERR "s3c_serial: unknown pm %d\n", level);
 	}
 }
 
 /* baud rate calculation
  *
- * The UARTs on the S3C2410/S3C2440 can take their clocks from a number
+ * The UARTs on the S3C can take their clocks from a number
  * of different sources, including the peripheral clock ("pclk") and an
  * external clock ("uclk"). The S3C2440 also adds the core clock ("fclk")
  * with a programmable extra divisor.
@@ -482,42 +470,48 @@
 
 #define MAX_CLKS (8)
 
-static struct s3c24xx_uart_clksrc tmp_clksrc = {
-	.name		= "pclk",
+static struct s3c_uart_clksrc tmp_clksrc = {
+	.name		= "uclk1",
 	.min_baud	= 0,
 	.max_baud	= 0,
 	.divisor	= 1,
 };
 
 static inline int
-s3c24xx_serial_getsource(struct uart_port *port, struct s3c24xx_uart_clksrc *c)
+s3c_serial_getsource(struct uart_port *port, struct s3c_uart_clksrc *c)
 {
-	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
+	struct s3c_uart_info *info = s3c_port_to_info(port);
 
 	return (info->get_clksrc)(port, c);
 }
 
 static inline int
-s3c24xx_serial_setsource(struct uart_port *port, struct s3c24xx_uart_clksrc *c)
+s3c_serial_setsource(struct uart_port *port, struct s3c_uart_clksrc *c)
 {
-	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
+	struct s3c_uart_info *info = s3c_port_to_info(port);
 
 	return (info->set_clksrc)(port, c);
 }
 
 struct baud_calc {
-	struct s3c24xx_uart_clksrc	*clksrc;
+	struct s3c_uart_clksrc	*clksrc;
 	unsigned int			 calc;
-	unsigned int			 quot;
+	unsigned int			 ubrdiv;
+	unsigned int			 udivslot;
 	struct clk			*src;
 };
 
-static int s3c24xx_serial_calcbaud(struct baud_calc *calc,
+static unsigned int udivslot_table[16] = {
+	0x0000, 0x0080, 0x0808, 0x0888, 0x2222, 0x4924, 0x4A52, 0x54AA,
+	0x5555, 0xD555, 0XD5D5, 0xDDD5, 0xDDDD, 0xDFDD, 0xDFDF, 0xFFDF
+};
+
+static int s3c_serial_calcbaud(struct baud_calc *calc,
 				   struct uart_port *port,
-				   struct s3c24xx_uart_clksrc *clksrc,
+				   struct s3c_uart_clksrc *clksrc,
 				   unsigned int baud)
 {
-	unsigned long rate;
+	unsigned long rate, temp;
 
 	calc->src = clk_get(port->dev, clksrc->name);
 	if (calc->src == NULL || IS_ERR(calc->src))
@@ -527,22 +521,29 @@
 	rate /= clksrc->divisor;
 
 	calc->clksrc = clksrc;
-	calc->quot = (rate + (8 * baud)) / (16 * baud);
-	calc->calc = (rate / (calc->quot * 16));
 
-	calc->quot--;
+	temp = ((((rate * 10) / baud) * 10) / 16); 	
+	calc->ubrdiv = ((temp / 100) - 1);
+	calc->udivslot = (((((temp % 100) / 10) * 16)) / 10);
+	if ((temp % 10) > 5)
+		calc->udivslot += 1;
+	calc->calc = ((rate * 10) / 
+				((((calc->ubrdiv  + 1) * 10) + ((calc->udivslot * 10) / 16)) * 16));
+
 	return 1;
 }
 
-static unsigned int s3c24xx_serial_getclk(struct uart_port *port,
-					  struct s3c24xx_uart_clksrc **clksrc,
+static unsigned int s3c_serial_getclk(struct uart_port *port,
+					  struct s3c_uart_clksrc **clksrc,
 					  struct clk **clk,
-					  unsigned int baud)
+					  unsigned int baud,
+					  unsigned int *udivslot)
 {
-	struct s3c2410_uartcfg *cfg = s3c24xx_port_to_cfg(port);
-	struct s3c24xx_uart_clksrc *clkp;
+	struct s3c_uartcfg *cfg = s3c_port_to_cfg(port);
+	struct s3c_uart_clksrc *clkp;
 	struct baud_calc res[MAX_CLKS];
 	struct baud_calc *resptr, *best, *sptr;
+	struct clk *uclk1;
 	int i;
 
 	clkp = cfg->clocks;
@@ -557,30 +558,37 @@
 		 */
 
 		if (strcmp(clkp->name, "fclk") == 0) {
-			struct s3c24xx_uart_clksrc src;
+			struct s3c_uart_clksrc src;
 
-			s3c24xx_serial_getsource(port, &src);
+			s3c_serial_getsource(port, &src);
 
 			/* check that the port already using fclk, and if
 			 * not, then re-select fclk
 			 */
 
 			if (strcmp(src.name, clkp->name) == 0) {
-				s3c24xx_serial_setsource(port, clkp);
-				s3c24xx_serial_getsource(port, &src);
+				s3c_serial_setsource(port, clkp);
+				s3c_serial_getsource(port, &src);
 			}
 
 			clkp->divisor = src.divisor;
 		}
 
-		s3c24xx_serial_calcbaud(res, port, clkp, baud);
+		if (strcmp(clkp->name, "uclk1") == 0) {
+			uclk1 = clk_get(NULL, clkp->name);
+			clk_set_parent(uclk1, clk_get(NULL, "dout_mpll"));	
+			clk_set_rate(uclk1, 133000000);	
+			clk_put(uclk1);
+		}
+
+		s3c_serial_calcbaud(res, port, clkp, baud);
 		best = res;
 		resptr = best + 1;
 	} else {
 		resptr = res;
 
 		for (i = 0; i < cfg->clocks_size; i++, clkp++) {
-			if (s3c24xx_serial_calcbaud(resptr, port, clkp, baud))
+			if (s3c_serial_calcbaud(resptr, port, clkp, baud))
 				resptr++;
 		}
 	}
@@ -608,19 +616,21 @@
 	*clksrc = best->clksrc;
 	*clk    = best->src;
 
-	return best->quot;
+	*udivslot = best->udivslot;
+
+	return best->ubrdiv;
 }
 
-static void s3c24xx_serial_set_termios(struct uart_port *port,
+static void s3c_serial_set_termios(struct uart_port *port,
 				       struct ktermios *termios,
 				       struct ktermios *old)
 {
-	struct s3c2410_uartcfg *cfg = s3c24xx_port_to_cfg(port);
-	struct s3c24xx_uart_port *ourport = to_ourport(port);
-	struct s3c24xx_uart_clksrc *clksrc = NULL;
+	struct s3c_uartcfg *cfg = s3c_port_to_cfg(port);
+	struct s3c_uart_port *ourport = to_ourport(port);
+	struct s3c_uart_clksrc *clksrc = NULL;
 	struct clk *clk = NULL;
 	unsigned long flags;
-	unsigned int baud, quot;
+	unsigned int baud, ubrdiv, udivslot;
 	unsigned int ulcon;
 	unsigned int umcon;
 
@@ -634,17 +644,19 @@
 	 * Ask the core to calculate the divisor for us.
 	 */
 
-	baud = uart_get_baud_rate(port, termios, old, 0, 115200*8);
+	baud = uart_get_baud_rate(port, termios, old, 0, 4000000);
 
-	if (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST)
-		quot = port->custom_divisor;
+	if (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST) {
+		ubrdiv = port->custom_divisor;
+		udivslot = 0;
+	}
 	else
-		quot = s3c24xx_serial_getclk(port, &clksrc, &clk, baud);
+		ubrdiv = s3c_serial_getclk(port, &clksrc, &clk, baud, &udivslot);
 
 	/* check to see if we need  to change clock source */
 
 	if (ourport->clksrc != clksrc || ourport->baudclk != clk) {
-		s3c24xx_serial_setsource(port, clksrc);
+		s3c_serial_setsource(port, clksrc);
 
 		if (ourport->baudclk != NULL && !IS_ERR(ourport->baudclk)) {
 			clk_disable(ourport->baudclk);
@@ -661,52 +673,48 @@
 	switch (termios->c_cflag & CSIZE) {
 	case CS5:
 		dbg("config: 5bits/char\n");
-		ulcon = S3C2410_LCON_CS5;
+		ulcon = S3C_LCON_CS5;
 		break;
 	case CS6:
 		dbg("config: 6bits/char\n");
-		ulcon = S3C2410_LCON_CS6;
+		ulcon = S3C_LCON_CS6;
 		break;
 	case CS7:
 		dbg("config: 7bits/char\n");
-		ulcon = S3C2410_LCON_CS7;
+		ulcon = S3C_LCON_CS7;
 		break;
 	case CS8:
 	default:
 		dbg("config: 8bits/char\n");
-		ulcon = S3C2410_LCON_CS8;
+		ulcon = S3C_LCON_CS8;
 		break;
 	}
 
 	/* preserve original lcon IR settings */
-	ulcon |= (cfg->ulcon & S3C2410_LCON_IRM);
+	ulcon |= (cfg->ulcon & S3C_LCON_IRM);
 
 	if (termios->c_cflag & CSTOPB)
-		ulcon |= S3C2410_LCON_STOPB;
+		ulcon |= S3C_LCON_STOPB;
 
-	umcon = (termios->c_cflag & CRTSCTS) ? S3C2410_UMCOM_AFC : 0;
+	umcon = (termios->c_cflag & CRTSCTS) ? S3C_UMCOM_AFC : 0;
 
 	if (termios->c_cflag & PARENB) {
 		if (termios->c_cflag & PARODD)
-			ulcon |= S3C2410_LCON_PODD;
+			ulcon |= S3C_LCON_PODD;
 		else
-			ulcon |= S3C2410_LCON_PEVEN;
+			ulcon |= S3C_LCON_PEVEN;
 	} else {
-		ulcon |= S3C2410_LCON_PNONE;
+		ulcon |= S3C_LCON_PNONE;
 	}
 
 	spin_lock_irqsave(&port->lock, flags);
 
 	dbg("setting ulcon to %08x, brddiv to %d\n", ulcon, quot);
 
-	wr_regl(port, S3C2410_ULCON, ulcon);
-	wr_regl(port, S3C2410_UBRDIV, quot);
-	wr_regl(port, S3C2410_UMCON, umcon);
-
-	dbg("uart: ulcon = 0x%08x, ucon = 0x%08x, ufcon = 0x%08x\n",
-	    rd_regl(port, S3C2410_ULCON),
-	    rd_regl(port, S3C2410_UCON),
-	    rd_regl(port, S3C2410_UFCON));
+	wr_regl(port, S3C_ULCON, ulcon);
+	wr_regl(port, S3C_UBRDIV, ubrdiv);
+	wr_regl(port, S3C_UDIVSLOT, udivslot_table[udivslot]);
+	wr_regl(port, S3C_UMCON, umcon);
 
 	/*
 	 * Update the per-port timeout.
@@ -716,18 +724,18 @@
 	/*
 	 * Which character status flags are we interested in?
 	 */
-	port->read_status_mask = S3C2410_UERSTAT_OVERRUN;
+	port->read_status_mask = S3C_UERSTAT_OVERRUN;
 	if (termios->c_iflag & INPCK)
-		port->read_status_mask |= S3C2410_UERSTAT_FRAME | S3C2410_UERSTAT_PARITY;
+		port->read_status_mask |= S3C_UERSTAT_FRAME | S3C_UERSTAT_PARITY;
 
 	/*
 	 * Which character status flags should we ignore?
 	 */
 	port->ignore_status_mask = 0;
 	if (termios->c_iflag & IGNPAR)
-		port->ignore_status_mask |= S3C2410_UERSTAT_OVERRUN;
+		port->ignore_status_mask |= S3C_UERSTAT_OVERRUN;
 	if (termios->c_iflag & IGNBRK && termios->c_iflag & IGNPAR)
-		port->ignore_status_mask |= S3C2410_UERSTAT_FRAME;
+		port->ignore_status_mask |= S3C_UERSTAT_FRAME;
 
 	/*
 	 * Ignore all characters if CREAD is not set.
@@ -738,17 +746,17 @@
 	spin_unlock_irqrestore(&port->lock, flags);
 }
 
-static const char *s3c24xx_serial_type(struct uart_port *port)
+static const char *s3c_serial_type(struct uart_port *port)
 {
 	switch (port->type) {
-	case PORT_S3C2410:
-		return "S3C2410";
+	case PORT_S3C:
+		return "S3C";
 	case PORT_S3C2440:
 		return "S3C2440";
 	case PORT_S3C2412:
 		return "S3C2412";
-	case PORT_S3C6400:
-		return "S3C6400/10";
+	case PORT_S3C64XX:
+		return "S3C64XX";
 	default:
 		return NULL;
 	}
@@ -756,23 +764,23 @@
 
 #define MAP_SIZE (0x100)
 
-static void s3c24xx_serial_release_port(struct uart_port *port)
+static void s3c_serial_release_port(struct uart_port *port)
 {
 	release_mem_region(port->mapbase, MAP_SIZE);
 }
 
-static int s3c24xx_serial_request_port(struct uart_port *port)
+static int s3c_serial_request_port(struct uart_port *port)
 {
-	const char *name = s3c24xx_serial_portname(port);
+	const char *name = s3c_serial_portname(port);
 	return request_mem_region(port->mapbase, MAP_SIZE, name) ? 0 : -EBUSY;
 }
 
-static void s3c24xx_serial_config_port(struct uart_port *port, int flags)
+static void s3c_serial_config_port(struct uart_port *port, int flags)
 {
-	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
+	struct s3c_uart_info *info = s3c_port_to_info(port);
 
 	if (flags & UART_CONFIG_TYPE &&
-	    s3c24xx_serial_request_port(port) == 0)
+	    s3c_serial_request_port(port) == 0)
 		port->type = info->type;
 }
 
@@ -780,9 +788,9 @@
  * verify the new serial_struct (for TIOCSSERIAL).
  */
 static int
-s3c24xx_serial_verify_port(struct uart_port *port, struct serial_struct *ser)
+s3c_serial_verify_port(struct uart_port *port, struct serial_struct *ser)
 {
-	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
+	struct s3c_uart_info *info = s3c_port_to_info(port);
 
 	if (ser->type != PORT_UNKNOWN && ser->type != info->type)
 		return -EINVAL;
@@ -793,65 +801,65 @@
 
 #ifdef CONFIG_SERIAL_SAMSUNG_CONSOLE
 
-static struct console s3c24xx_serial_console;
+static struct console s3c_serial_console;
 
-#define S3C24XX_SERIAL_CONSOLE &s3c24xx_serial_console
+#define S3C_SERIAL_CONSOLE &s3c_serial_console
 #else
-#define S3C24XX_SERIAL_CONSOLE NULL
+#define S3C_SERIAL_CONSOLE NULL
 #endif
 
-static struct uart_ops s3c24xx_serial_ops = {
-	.pm		= s3c24xx_serial_pm,
-	.tx_empty	= s3c24xx_serial_tx_empty,
-	.get_mctrl	= s3c24xx_serial_get_mctrl,
-	.set_mctrl	= s3c24xx_serial_set_mctrl,
-	.stop_tx	= s3c24xx_serial_stop_tx,
-	.start_tx	= s3c24xx_serial_start_tx,
-	.stop_rx	= s3c24xx_serial_stop_rx,
-	.enable_ms	= s3c24xx_serial_enable_ms,
-	.break_ctl	= s3c24xx_serial_break_ctl,
-	.startup	= s3c24xx_serial_startup,
-	.shutdown	= s3c24xx_serial_shutdown,
-	.set_termios	= s3c24xx_serial_set_termios,
-	.type		= s3c24xx_serial_type,
-	.release_port	= s3c24xx_serial_release_port,
-	.request_port	= s3c24xx_serial_request_port,
-	.config_port	= s3c24xx_serial_config_port,
-	.verify_port	= s3c24xx_serial_verify_port,
+static struct uart_ops s3c_serial_ops = {
+	.pm		= s3c_serial_pm,
+	.tx_empty	= s3c_serial_tx_empty,
+	.get_mctrl	= s3c_serial_get_mctrl,
+	.set_mctrl	= s3c_serial_set_mctrl,
+	.stop_tx	= s3c_serial_stop_tx,
+	.start_tx	= s3c_serial_start_tx,
+	.stop_rx	= s3c_serial_stop_rx,
+	.enable_ms	= s3c_serial_enable_ms,
+	.break_ctl	= s3c_serial_break_ctl,
+	.startup	= s3c_serial_startup,
+	.shutdown	= s3c_serial_shutdown,
+	.set_termios	= s3c_serial_set_termios,
+	.type		= s3c_serial_type,
+	.release_port	= s3c_serial_release_port,
+	.request_port	= s3c_serial_request_port,
+	.config_port	= s3c_serial_config_port,
+	.verify_port	= s3c_serial_verify_port,
 };
 
 
-static struct uart_driver s3c24xx_uart_drv = {
+static struct uart_driver s3c_uart_drv = {
 	.owner		= THIS_MODULE,
-	.dev_name	= "s3c2410_serial",
+	.dev_name	= "s3c_serial",
 	.nr		= CONFIG_SERIAL_SAMSUNG_UARTS,
-	.cons		= S3C24XX_SERIAL_CONSOLE,
-	.driver_name	= S3C24XX_SERIAL_NAME,
-	.major		= S3C24XX_SERIAL_MAJOR,
-	.minor		= S3C24XX_SERIAL_MINOR,
+	.cons		= S3C_SERIAL_CONSOLE,
+	.driver_name	= S3C_SERIAL_NAME,
+	.major		= S3C_SERIAL_MAJOR,
+	.minor		= S3C_SERIAL_MINOR,
 };
 
-static struct s3c24xx_uart_port s3c24xx_serial_ports[CONFIG_SERIAL_SAMSUNG_UARTS] = {
+static struct s3c_uart_port s3c_serial_ports[CONFIG_SERIAL_SAMSUNG_UARTS] = {
 	[0] = {
 		.port = {
-			.lock		= __SPIN_LOCK_UNLOCKED(s3c24xx_serial_ports[0].port.lock),
+			.lock		= __SPIN_LOCK_UNLOCKED(s3c_serial_ports[0].port.lock),
 			.iotype		= UPIO_MEM,
 			.irq		= IRQ_S3CUART_RX0,
 			.uartclk	= 0,
 			.fifosize	= 16,
-			.ops		= &s3c24xx_serial_ops,
+			.ops		= &s3c_serial_ops,
 			.flags		= UPF_BOOT_AUTOCONF,
 			.line		= 0,
 		}
 	},
 	[1] = {
 		.port = {
-			.lock		= __SPIN_LOCK_UNLOCKED(s3c24xx_serial_ports[1].port.lock),
+			.lock		= __SPIN_LOCK_UNLOCKED(s3c_serial_ports[1].port.lock),
 			.iotype		= UPIO_MEM,
 			.irq		= IRQ_S3CUART_RX1,
 			.uartclk	= 0,
 			.fifosize	= 16,
-			.ops		= &s3c24xx_serial_ops,
+			.ops		= &s3c_serial_ops,
 			.flags		= UPF_BOOT_AUTOCONF,
 			.line		= 1,
 		}
@@ -860,12 +868,12 @@
 
 	[2] = {
 		.port = {
-			.lock		= __SPIN_LOCK_UNLOCKED(s3c24xx_serial_ports[2].port.lock),
+			.lock		= __SPIN_LOCK_UNLOCKED(s3c_serial_ports[2].port.lock),
 			.iotype		= UPIO_MEM,
 			.irq		= IRQ_S3CUART_RX2,
 			.uartclk	= 0,
 			.fifosize	= 16,
-			.ops		= &s3c24xx_serial_ops,
+			.ops		= &s3c_serial_ops,
 			.flags		= UPF_BOOT_AUTOCONF,
 			.line		= 2,
 		}
@@ -874,12 +882,12 @@
 #if CONFIG_SERIAL_SAMSUNG_UARTS > 3
 	[3] = {
 		.port = {
-			.lock		= __SPIN_LOCK_UNLOCKED(s3c24xx_serial_ports[3].port.lock),
+			.lock		= __SPIN_LOCK_UNLOCKED(s3c_serial_ports[3].port.lock),
 			.iotype		= UPIO_MEM,
 			.irq		= IRQ_S3CUART_RX3,
 			.uartclk	= 0,
 			.fifosize	= 16,
-			.ops		= &s3c24xx_serial_ops,
+			.ops		= &s3c_serial_ops,
 			.flags		= UPF_BOOT_AUTOCONF,
 			.line		= 3,
 		}
@@ -887,30 +895,30 @@
 #endif
 };
 
-/* s3c24xx_serial_resetport
+/* s3c_serial_resetport
  *
  * wrapper to call the specific reset for this port (reset the fifos
  * and the settings)
 */
 
-static inline int s3c24xx_serial_resetport(struct uart_port *port,
-					   struct s3c2410_uartcfg *cfg)
+static inline int s3c_serial_resetport(struct uart_port *port,
+					   struct s3c_uartcfg *cfg)
 {
-	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
+	struct s3c_uart_info *info = s3c_port_to_info(port);
 
 	return (info->reset_port)(port, cfg);
 }
 
 
-#ifdef CONFIG_CPU_FREQ
+#if 0
 
-static int s3c24xx_serial_cpufreq_transition(struct notifier_block *nb,
+static int s3c_serial_cpufreq_transition(struct notifier_block *nb,
 					     unsigned long val, void *data)
 {
-	struct s3c24xx_uart_port *port;
+	struct s3c_uart_port *port;
 	struct uart_port *uport;
 
-	port = container_of(nb, struct s3c24xx_uart_port, freq_transition);
+	port = container_of(nb, struct s3c_uart_port, freq_transition);
 	uport = &port->port;
 
 	/* check to see if port is enabled */
@@ -937,13 +945,17 @@
 		struct ktermios *termios;
 		struct tty_struct *tty;
 
-		if (uport->info == NULL)
+		if (uport->info == NULL) {
+			printk(KERN_WARNING "%s: info NULL\n", __func__);
 			goto exit;
+		}
 
 		tty = uport->info->port.tty;
 
-		if (tty == NULL)
+		if (tty == NULL) {
+			printk(KERN_WARNING "%s: tty is NULL\n", __func__);
 			goto exit;
+		}
 
 		termios = tty->termios;
 
@@ -952,58 +964,58 @@
 			goto exit;
 		}
 
-		s3c24xx_serial_set_termios(uport, termios, NULL);
+		s3c_serial_set_termios(uport, termios, NULL);
 	}
 
  exit:
 	return 0;
 }
 
-static inline int s3c24xx_serial_cpufreq_register(struct s3c24xx_uart_port *port)
+static inline int s3c_serial_cpufreq_register(struct s3c_uart_port *port)
 {
-	port->freq_transition.notifier_call = s3c24xx_serial_cpufreq_transition;
+	port->freq_transition.notifier_call = s3c_serial_cpufreq_transition;
 
 	return cpufreq_register_notifier(&port->freq_transition,
 					 CPUFREQ_TRANSITION_NOTIFIER);
 }
 
-static inline void s3c24xx_serial_cpufreq_deregister(struct s3c24xx_uart_port *port)
+static inline void s3c_serial_cpufreq_deregister(struct s3c_uart_port *port)
 {
 	cpufreq_unregister_notifier(&port->freq_transition,
 				    CPUFREQ_TRANSITION_NOTIFIER);
 }
 
 #else
-static inline int s3c24xx_serial_cpufreq_register(struct s3c24xx_uart_port *port)
+static inline int s3c_serial_cpufreq_register(struct s3c_uart_port *port)
 {
 	return 0;
 }
 
-static inline void s3c24xx_serial_cpufreq_deregister(struct s3c24xx_uart_port *port)
+static inline void s3c_serial_cpufreq_deregister(struct s3c_uart_port *port)
 {
 }
 #endif
 
-/* s3c24xx_serial_init_port
+/* s3c_serial_init_port
  *
  * initialise a single serial port from the platform device given
  */
 
-static int s3c24xx_serial_init_port(struct s3c24xx_uart_port *ourport,
-				    struct s3c24xx_uart_info *info,
+static int s3c_serial_init_port(struct s3c_uart_port *ourport,
+				    struct s3c_uart_info *info,
 				    struct platform_device *platdev)
 {
 	struct uart_port *port = &ourport->port;
-	struct s3c2410_uartcfg *cfg;
+	struct s3c_uartcfg *cfg;
 	struct resource *res;
 	int ret;
 
-	dbg("s3c24xx_serial_init_port: port=%p, platdev=%p\n", port, platdev);
+	dbg("s3c_serial_init_port: port=%p, platdev=%p\n", port, platdev);
 
 	if (platdev == NULL)
 		return -ENODEV;
 
-	cfg = s3c24xx_dev_to_cfg(&platdev->dev);
+	cfg = s3c_dev_to_cfg(&platdev->dev);
 
 	if (port->mapbase != 0)
 		return 0;
@@ -1021,12 +1033,12 @@
 	/* copy the info in from provided structure */
 	ourport->port.fifosize = info->fifosize;
 
-	dbg("s3c24xx_serial_init_port: %p (hw %d)...\n", port, cfg->hwport);
+	dbg("s3c_serial_init_port: %p (hw %d)...\n", port, cfg->hwport);
 
 	port->uartclk = 1;
 
 	if (cfg->uart_flags & UPF_CONS_FLOW) {
-		dbg("s3c24xx_serial_init_port: enabling flow control\n");
+		dbg("s3c_serial_init_port: enabling flow control\n");
 		port->flags |= UPF_CONS_FLOW;
 	}
 
@@ -1062,52 +1074,55 @@
 	    ourport->rx_irq, ourport->tx_irq, port->uartclk);
 
 	/* reset the fifos (and setup the uart) */
-	s3c24xx_serial_resetport(port, cfg);
+	s3c_serial_resetport(port, cfg);
+
+	s3c_setup_uart_cfg_gpio(cfg->hwport);
+
 	return 0;
 }
 
-static ssize_t s3c24xx_serial_show_clksrc(struct device *dev,
+static ssize_t s3c_serial_show_clksrc(struct device *dev,
 					  struct device_attribute *attr,
 					  char *buf)
 {
-	struct uart_port *port = s3c24xx_dev_to_port(dev);
-	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	struct uart_port *port = s3c_dev_to_port(dev);
+	struct s3c_uart_port *ourport = to_ourport(port);
 
 	return snprintf(buf, PAGE_SIZE, "* %s\n", ourport->clksrc->name);
 }
 
-static DEVICE_ATTR(clock_source, S_IRUGO, s3c24xx_serial_show_clksrc, NULL);
+static DEVICE_ATTR(clock_source, S_IRUGO, s3c_serial_show_clksrc, NULL);
 
 /* Device driver serial port probe */
 
 static int probe_index;
 
-int s3c24xx_serial_probe(struct platform_device *dev,
-			 struct s3c24xx_uart_info *info)
+int s3c_serial_probe(struct platform_device *dev,
+			 struct s3c_uart_info *info)
 {
-	struct s3c24xx_uart_port *ourport;
+	struct s3c_uart_port *ourport;
 	int ret;
 
-	dbg("s3c24xx_serial_probe(%p, %p) %d\n", dev, info, probe_index);
+	dbg("s3c_serial_probe(%p, %p) %d\n", dev, info, probe_index);
 
-	ourport = &s3c24xx_serial_ports[probe_index];
+	ourport = &s3c_serial_ports[probe_index];
 	probe_index++;
 
 	dbg("%s: initialising port %p...\n", __func__, ourport);
 
-	ret = s3c24xx_serial_init_port(ourport, info, dev);
+	ret = s3c_serial_init_port(ourport, info, dev);
 	if (ret < 0)
 		goto probe_err;
 
 	dbg("%s: adding port\n", __func__);
-	uart_add_one_port(&s3c24xx_uart_drv, &ourport->port);
+	uart_add_one_port(&s3c_uart_drv, &ourport->port);
 	platform_set_drvdata(dev, &ourport->port);
 
 	ret = device_create_file(&dev->dev, &dev_attr_clock_source);
 	if (ret < 0)
 		printk(KERN_ERR "%s: failed to add clksrc attr.\n", __func__);
 
-	ret = s3c24xx_serial_cpufreq_register(ourport);
+	ret = s3c_serial_cpufreq_register(ourport);
 	if (ret < 0)
 		dev_err(&dev->dev, "failed to add cpufreq notifier\n");
 
@@ -1117,76 +1132,134 @@
 	return ret;
 }
 
-EXPORT_SYMBOL_GPL(s3c24xx_serial_probe);
+EXPORT_SYMBOL_GPL(s3c_serial_probe);
 
-int s3c24xx_serial_remove(struct platform_device *dev)
+int s3c_serial_remove(struct platform_device *dev)
 {
-	struct uart_port *port = s3c24xx_dev_to_port(&dev->dev);
+	struct uart_port *port = s3c_dev_to_port(&dev->dev);
 
 	if (port) {
-		s3c24xx_serial_cpufreq_deregister(to_ourport(port));
+		s3c_serial_cpufreq_deregister(to_ourport(port));
 		device_remove_file(&dev->dev, &dev_attr_clock_source);
-		uart_remove_one_port(&s3c24xx_uart_drv, port);
+		uart_remove_one_port(&s3c_uart_drv, port);
 	}
 
 	return 0;
 }
 
-EXPORT_SYMBOL_GPL(s3c24xx_serial_remove);
+EXPORT_SYMBOL_GPL(s3c_serial_remove);
 
 /* UART power management code */
 
 #ifdef CONFIG_PM
+#include <plat/pm.h>
+
+#define SAVE_UART(va) \
+	SAVE_ITEM((va) + S3C_ULCON), \
+	SAVE_ITEM((va) + S3C_UCON), \
+	SAVE_ITEM((va) + S3C_UFCON), \
+	SAVE_ITEM((va) + S3C_UMCON), \
+	SAVE_ITEM((va) + S3C_UBRDIV), \
+	SAVE_ITEM((va) + S3C_UDIVSLOT), \
+	SAVE_ITEM((va) + S3C_UINTMSK)
+
+static struct sleep_save uart_save[] = {
+	SAVE_UART(S3C_VA_UART0),
+	SAVE_UART(S3C_VA_UART1),
+	SAVE_UART(S3C_VA_UART2),
+	SAVE_UART(S3C_VA_UART3),
+};
+
+#define SAVE_UART_PORT (ARRAY_SIZE(uart_save)  / 4 )
 
-static int s3c24xx_serial_suspend(struct platform_device *dev, pm_message_t state)
+static int s3c_serial_suspend(struct platform_device *dev, pm_message_t state)
 {
-	struct uart_port *port = s3c24xx_dev_to_port(&dev->dev);
+	struct uart_port *port = s3c_dev_to_port(&dev->dev);
+
+	unsigned int gpadata = 0;
+	unsigned int gpaconslp = 0;
+
+	if(port->line == 1)
+	{
+		s3c_gpio_cfgpin(GPIO_BT_RTS, S3C_GPIO_SFN(1));
+
+		gpaconslp = __raw_readl(S3C64XX_GPACONSLP);
+		gpaconslp |= (1 << 14);
+		gpaconslp &= ~(1 << 15);
+		__raw_writel(gpaconslp, S3C64XX_GPACONSLP);
+
+		gpadata = __raw_readl(S3C64XX_GPADAT);
+		gpadata |= (1 << 7);
+		__raw_writel(gpadata, S3C64XX_GPADAT);
+		
+		s3c_gpio_setpull(GPIO_BT_RTS, S3C_GPIO_PULL_NONE);
+	}
+
+	s3c6410_pm_do_save(uart_save + port->line * SAVE_UART_PORT, SAVE_UART_PORT);
 
 	if (port)
-		uart_suspend_port(&s3c24xx_uart_drv, port);
+		uart_suspend_port(&s3c_uart_drv, port);
 
 	return 0;
 }
 
-static int s3c24xx_serial_resume(struct platform_device *dev)
+static int s3c_serial_resume(struct platform_device *dev)
 {
-	struct uart_port *port = s3c24xx_dev_to_port(&dev->dev);
-	struct s3c24xx_uart_port *ourport = to_ourport(port);
+	struct uart_port *port = s3c_dev_to_port(&dev->dev);
+	struct s3c_uart_port *ourport = to_ourport(port);
+
+	unsigned int gpadata = 0;
 
 	if (port) {
 		clk_enable(ourport->clk);
-		s3c24xx_serial_resetport(port, s3c24xx_port_to_cfg(port));
+		
+		s3c_serial_resetport(port, s3c_port_to_cfg(port));
 		clk_disable(ourport->clk);
 
-		uart_resume_port(&s3c24xx_uart_drv, port);
+		s3c6410_pm_do_restore(uart_save + port->line * SAVE_UART_PORT, SAVE_UART_PORT);
+
+		uart_resume_port(&s3c_uart_drv, port);
+	}
+
+	if(port->line == 1)
+	{
+		s3c_gpio_cfgpin(GPIO_BT_RTS, S3C_GPIO_SFN(1));
+
+		gpadata = __raw_readl(S3C64XX_GPADAT);
+		gpadata &= ~(1<<7);
+		__raw_writel(gpadata, S3C64XX_GPADAT);
+		
+		s3c_gpio_setpull(GPIO_BT_RTS, S3C_GPIO_PULL_NONE);
+
+		s3c_gpio_cfgpin(GPIO_BT_RTS, S3C_GPIO_SFN(GPIO_BT_RTS_AF));
 	}
 
 	return 0;
 }
 #endif
 
-int s3c24xx_serial_init(struct platform_driver *drv,
-			struct s3c24xx_uart_info *info)
+int s3c_serial_init(struct platform_driver *drv,
+			struct s3c_uart_info *info)
 {
-	dbg("s3c24xx_serial_init(%p,%p)\n", drv, info);
+	dbg("s3c_serial_init(%p,%p)\n", drv, info);
 
 #ifdef CONFIG_PM
-	drv->suspend = s3c24xx_serial_suspend;
-	drv->resume = s3c24xx_serial_resume;
+	drv->suspend = s3c_serial_suspend;
+	drv->resume = s3c_serial_resume;
 #endif
 
 	return platform_driver_register(drv);
 }
 
-EXPORT_SYMBOL_GPL(s3c24xx_serial_init);
+EXPORT_SYMBOL_GPL(s3c_serial_init);
 
 /* module initialisation code */
 
-static int __init s3c24xx_serial_modinit(void)
+static int __init s3c_serial_modinit(void)
 {
 	int ret;
 
-	ret = uart_register_driver(&s3c24xx_uart_drv);
+	ret = uart_register_driver(&s3c_uart_drv);
 	if (ret < 0) {
 		printk(KERN_ERR "failed to register UART driver\n");
 		return -1;
@@ -1195,13 +1268,13 @@
 	return 0;
 }
 
-static void __exit s3c24xx_serial_modexit(void)
+static void __exit s3c_serial_modexit(void)
 {
-	uart_unregister_driver(&s3c24xx_uart_drv);
+	uart_unregister_driver(&s3c_uart_drv);
 }
 
-module_init(s3c24xx_serial_modinit);
-module_exit(s3c24xx_serial_modexit);
+module_init(s3c_serial_modinit);
+module_exit(s3c_serial_modexit);
 
 /* Console code */
 
@@ -1210,95 +1283,97 @@
 static struct uart_port *cons_uart;
 
 static int
-s3c24xx_serial_console_txrdy(struct uart_port *port, unsigned int ufcon)
+s3c_serial_console_txrdy(struct uart_port *port, unsigned int ufcon)
 {
-	struct s3c24xx_uart_info *info = s3c24xx_port_to_info(port);
+	struct s3c_uart_info *info = s3c_port_to_info(port);
 	unsigned long ufstat, utrstat;
 
-	if (ufcon & S3C2410_UFCON_FIFOMODE) {
+	if (ufcon & S3C_UFCON_FIFOMODE) {
 		/* fifo mode - check ammount of data in fifo registers... */
 
-		ufstat = rd_regl(port, S3C2410_UFSTAT);
+		ufstat = rd_regl(port, S3C_UFSTAT);
 		return (ufstat & info->tx_fifofull) ? 0 : 1;
 	}
 
 	/* in non-fifo mode, we go and use the tx buffer empty */
 
-	utrstat = rd_regl(port, S3C2410_UTRSTAT);
-	return (utrstat & S3C2410_UTRSTAT_TXE) ? 1 : 0;
+	utrstat = rd_regl(port, S3C_UTRSTAT);
+	return (utrstat & S3C_UTRSTAT_TXE) ? 1 : 0;
 }
 
 static void
-s3c24xx_serial_console_putchar(struct uart_port *port, int ch)
+s3c_serial_console_putchar(struct uart_port *port, int ch)
 {
-	unsigned int ufcon = rd_regl(cons_uart, S3C2410_UFCON);
-	while (!s3c24xx_serial_console_txrdy(port, ufcon))
+	unsigned int ufcon = rd_regl(cons_uart, S3C_UFCON);
+	while (!s3c_serial_console_txrdy(port, ufcon))
 		barrier();
-	wr_regb(cons_uart, S3C2410_UTXH, ch);
+	wr_regb(cons_uart, S3C_UTXH, ch);
 }
 
 static void
-s3c24xx_serial_console_write(struct console *co, const char *s,
+s3c_serial_console_write(struct console *co, const char *s,
 			     unsigned int count)
 {
-	uart_console_write(cons_uart, s, count, s3c24xx_serial_console_putchar);
+	uart_console_write(cons_uart, s, count, s3c_serial_console_putchar);
 }
 
 static void __init
-s3c24xx_serial_get_options(struct uart_port *port, int *baud,
+s3c_serial_get_options(struct uart_port *port, int *baud,
 			   int *parity, int *bits)
 {
-	struct s3c24xx_uart_clksrc clksrc;
+	struct s3c_uart_clksrc clksrc;
 	struct clk *clk;
 	unsigned int ulcon;
 	unsigned int ucon;
 	unsigned int ubrdiv;
+	unsigned int udivslot;
 	unsigned long rate;
 
-	ulcon  = rd_regl(port, S3C2410_ULCON);
-	ucon   = rd_regl(port, S3C2410_UCON);
-	ubrdiv = rd_regl(port, S3C2410_UBRDIV);
-
-	dbg("s3c24xx_serial_get_options: port=%p\n"
-	    "registers: ulcon=%08x, ucon=%08x, ubdriv=%08x\n",
-	    port, ulcon, ucon, ubrdiv);
+	ulcon  = rd_regl(port, S3C_ULCON);
+	ucon   = rd_regl(port, S3C_UCON);
+	ubrdiv = rd_regl(port, S3C_UBRDIV);
+	udivslot = rd_regl(port, S3C_UDIVSLOT);
+
+	dbg("s3c_serial_get_options: port=%p\n"
+	    "registers: ulcon=%08x, ucon=%08x, ubdriv=%08x, udivslot=%08x\n",
+	    port, ulcon, ucon, ubrdiv, udivslot);
 
 	if ((ucon & 0xf) != 0) {
 		/* consider the serial port configured if the tx/rx mode set */
 
-		switch (ulcon & S3C2410_LCON_CSMASK) {
-		case S3C2410_LCON_CS5:
+		switch (ulcon & S3C_LCON_CSMASK) {
+		case S3C_LCON_CS5:
 			*bits = 5;
 			break;
-		case S3C2410_LCON_CS6:
+		case S3C_LCON_CS6:
 			*bits = 6;
 			break;
-		case S3C2410_LCON_CS7:
+		case S3C_LCON_CS7:
 			*bits = 7;
 			break;
 		default:
-		case S3C2410_LCON_CS8:
+		case S3C_LCON_CS8:
 			*bits = 8;
 			break;
 		}
 
-		switch (ulcon & S3C2410_LCON_PMASK) {
-		case S3C2410_LCON_PEVEN:
+		switch (ulcon & S3C_LCON_PMASK) {
+		case S3C_LCON_PEVEN:
 			*parity = 'e';
 			break;
 
-		case S3C2410_LCON_PODD:
+		case S3C_LCON_PODD:
 			*parity = 'o';
 			break;
 
-		case S3C2410_LCON_PNONE:
+		case S3C_LCON_PNONE:
 		default:
 			*parity = 'n';
 		}
 
 		/* now calculate the baud rate */
 
-		s3c24xx_serial_getsource(port, &clksrc);
+		s3c_serial_getsource(port, &clksrc);
 
 		clk = clk_get(port->dev, clksrc.name);
 		if (!IS_ERR(clk) && clk != NULL)
@@ -1313,31 +1388,31 @@
 
 }
 
-/* s3c24xx_serial_init_ports
+/* s3c_serial_init_ports
  *
  * initialise the serial ports from the machine provided initialisation
  * data.
 */
 
-static int s3c24xx_serial_init_ports(struct s3c24xx_uart_info *info)
+static int s3c_serial_init_ports(struct s3c_uart_info *info)
 {
-	struct s3c24xx_uart_port *ptr = s3c24xx_serial_ports;
+	struct s3c_uart_port *ptr = s3c_serial_ports;
 	struct platform_device **platdev_ptr;
 	int i;
 
-	dbg("s3c24xx_serial_init_ports: initialising ports...\n");
+	dbg("s3c_serial_init_ports: initialising ports...\n");
 
-	platdev_ptr = s3c24xx_uart_devs;
+	platdev_ptr = s3c_uart_devs;
 
 	for (i = 0; i < CONFIG_SERIAL_SAMSUNG_UARTS; i++, ptr++, platdev_ptr++) {
-		s3c24xx_serial_init_port(ptr, info, *platdev_ptr);
+		s3c_serial_init_port(ptr, info, *platdev_ptr);
 	}
 
 	return 0;
 }
 
 static int __init
-s3c24xx_serial_console_setup(struct console *co, char *options)
+s3c_serial_console_setup(struct console *co, char *options)
 {
 	struct uart_port *port;
 	int baud = 9600;
@@ -1345,7 +1420,7 @@
 	int parity = 'n';
 	int flow = 'n';
 
-	dbg("s3c24xx_serial_console_setup: co=%p (%d), %s\n",
+	dbg("s3c_serial_console_setup: co=%p (%d), %s\n",
 	    co, co->index, options);
 
 	/* is this a valid port */
@@ -1353,18 +1428,18 @@
 	if (co->index == -1 || co->index >= CONFIG_SERIAL_SAMSUNG_UARTS)
 		co->index = 0;
 
-	port = &s3c24xx_serial_ports[co->index].port;
+	port = &s3c_serial_ports[co->index].port;
 
 	/* is the port configured? */
 
 	if (port->mapbase == 0x0) {
 		co->index = 0;
-		port = &s3c24xx_serial_ports[co->index].port;
+		port = &s3c_serial_ports[co->index].port;
 	}
 
 	cons_uart = port;
 
-	dbg("s3c24xx_serial_console_setup: port=%p (%d)\n", port, co->index);
+	dbg("s3c_serial_console_setup: port=%p (%d)\n", port, co->index);
 
 	/*
 	 * Check whether an invalid uart number has been specified, and
@@ -1374,49 +1449,49 @@
 	if (options)
 		uart_parse_options(options, &baud, &parity, &bits, &flow);
 	else
-		s3c24xx_serial_get_options(port, &baud, &parity, &bits);
+		s3c_serial_get_options(port, &baud, &parity, &bits);
 
-	dbg("s3c24xx_serial_console_setup: baud %d\n", baud);
+	dbg("s3c_serial_console_setup: baud %d\n", baud);
 
 	return uart_set_options(port, co, baud, parity, bits, flow);
 }
 
-/* s3c24xx_serial_initconsole
+/* s3c_serial_initconsole
  *
  * initialise the console from one of the uart drivers
 */
 
-static struct console s3c24xx_serial_console = {
-	.name		= S3C24XX_SERIAL_NAME,
+static struct console s3c_serial_console = {
+	.name		= S3C_SERIAL_NAME,
 	.device		= uart_console_device,
 	.flags		= CON_PRINTBUFFER,
 	.index		= -1,
-	.write		= s3c24xx_serial_console_write,
-	.setup		= s3c24xx_serial_console_setup
+	.write		= s3c_serial_console_write,
+	.setup		= s3c_serial_console_setup
 };
 
-int s3c24xx_serial_initconsole(struct platform_driver *drv,
-			       struct s3c24xx_uart_info *info)
+int s3c_serial_initconsole(struct platform_driver *drv,
+			       struct s3c_uart_info *info)
 
 {
-	struct platform_device *dev = s3c24xx_uart_devs[0];
+	struct platform_device *dev = s3c_uart_devs[0];
 
-	dbg("s3c24xx_serial_initconsole\n");
+	dbg("s3c_serial_initconsole\n");
 
 	/* select driver based on the cpu */
 
 	if (dev == NULL) {
-		printk(KERN_ERR "s3c24xx: no devices for console init\n");
+		printk(KERN_ERR "s3c: no devices for console init\n");
 		return 0;
 	}
 
 	if (strcmp(dev->name, drv->driver.name) != 0)
 		return 0;
 
-	s3c24xx_serial_console.data = &s3c24xx_uart_drv;
-	s3c24xx_serial_init_ports(info);
+	s3c_serial_console.data = &s3c_uart_drv;
+	s3c_serial_init_ports(info);
 
-	register_console(&s3c24xx_serial_console);
+	register_console(&s3c_serial_console);
 	return 0;
 }
 
diff -Nur linux-2.6.29/drivers/serial/samsung.h linux-2.6.29-spica/drivers/serial/samsung.h
--- linux-2.6.29/drivers/serial/samsung.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/serial/samsung.h	2010-05-06 12:42:45.644210217 +0700
@@ -10,7 +10,7 @@
  * published by the Free Software Foundation.
 */
 
-struct s3c24xx_uart_info {
+struct s3c_uart_info {
 	char			*name;
 	unsigned int		type;
 	unsigned int		fifosize;
@@ -23,14 +23,14 @@
 
 	/* clock source control */
 
-	int (*get_clksrc)(struct uart_port *, struct s3c24xx_uart_clksrc *clk);
-	int (*set_clksrc)(struct uart_port *, struct s3c24xx_uart_clksrc *clk);
+	int (*get_clksrc)(struct uart_port *, struct s3c_uart_clksrc *clk);
+	int (*set_clksrc)(struct uart_port *, struct s3c_uart_clksrc *clk);
 
 	/* uart controls */
-	int (*reset_port)(struct uart_port *, struct s3c2410_uartcfg *);
+	int (*reset_port)(struct uart_port *, struct s3c_uartcfg *);
 };
 
-struct s3c24xx_uart_port {
+struct s3c_uart_port {
 	unsigned char			rx_claimed;
 	unsigned char			tx_claimed;
 	unsigned int			pm_level;
@@ -39,8 +39,8 @@
 	unsigned int			rx_irq;
 	unsigned int			tx_irq;
 
-	struct s3c24xx_uart_info	*info;
-	struct s3c24xx_uart_clksrc	*clksrc;
+	struct s3c_uart_info		*info;
+	struct s3c_uart_clksrc		*clksrc;
 	struct clk			*clk;
 	struct clk			*baudclk;
 	struct uart_port		port;
@@ -52,8 +52,8 @@
 
 /* conversion functions */
 
-#define s3c24xx_dev_to_port(__dev) (struct uart_port *)dev_get_drvdata(__dev)
-#define s3c24xx_dev_to_cfg(__dev) (struct s3c2410_uartcfg *)((__dev)->platform_data)
+#define s3c_dev_to_port(__dev) (struct uart_port *)dev_get_drvdata(__dev)
+#define s3c_dev_to_cfg(__dev) (struct s3c_uartcfg *)((__dev)->platform_data)
 
 /* register access controls */
 
@@ -65,29 +65,31 @@
 #define wr_regb(port, reg, val) __raw_writeb(val, portaddr(port, reg))
 #define wr_regl(port, reg, val) __raw_writel(val, portaddr(port, reg))
 
-extern int s3c24xx_serial_probe(struct platform_device *dev,
-				struct s3c24xx_uart_info *uart);
+extern int s3c_serial_probe(struct platform_device *dev,
+				struct s3c_uart_info *uart);
 
-extern int s3c24xx_serial_remove(struct platform_device *dev);
+extern int s3c_serial_remove(struct platform_device *dev);
 
-extern int s3c24xx_serial_initconsole(struct platform_driver *drv,
-				      struct s3c24xx_uart_info *uart);
+extern int s3c_serial_initconsole(struct platform_driver *drv,
+				      struct s3c_uart_info *uart);
 
-extern int s3c24xx_serial_init(struct platform_driver *drv,
-			       struct s3c24xx_uart_info *info);
+extern int s3c_serial_init(struct platform_driver *drv,
+			       struct s3c_uart_info *info);
+
+extern void s3c_setup_uart_cfg_gpio(unsigned char port);
 
 #ifdef CONFIG_SERIAL_SAMSUNG_CONSOLE
 
-#define s3c24xx_console_init(__drv, __inf)			\
+#define s3c_console_init(__drv, __inf)			\
 static int __init s3c_serial_console_init(void)			\
 {								\
-	return s3c24xx_serial_initconsole(__drv, __inf);	\
+	return s3c_serial_initconsole(__drv, __inf);	\
 }								\
 								\
 console_initcall(s3c_serial_console_init)
 
 #else
-#define s3c24xx_console_init(drv, inf) extern void no_console(void)
+#define s3c_console_init(drv, inf) extern void no_console(void)
 #endif
 
 #ifdef CONFIG_SERIAL_SAMSUNG_DEBUG
diff -Nur linux-2.6.29/drivers/serial/serial_core.c linux-2.6.29-spica/drivers/serial/serial_core.c
--- linux-2.6.29/drivers/serial/serial_core.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/serial/serial_core.c	2010-03-30 11:01:10.000000000 +0700
@@ -94,6 +94,9 @@
 	struct uart_state *state = tty->driver_data;
 	struct uart_port *port = state->port;
 
+	if (port->ops->wake_peer)
+		port->ops->wake_peer(port);
+
 	if (!uart_circ_empty(&state->info.xmit) && state->info.xmit.buf &&
 	    !tty->stopped && !tty->hw_stopped)
 		port->ops->start_tx(port);
diff -Nur linux-2.6.29/drivers/spi/hspi-s3c64xx.h linux-2.6.29-spica/drivers/spi/hspi-s3c64xx.h
--- linux-2.6.29/drivers/spi/hspi-s3c64xx.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/spi/hspi-s3c64xx.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,95 @@
+/* ------------------------------------------------------------------------- */
+/* 									     */
+/* spi-s3c6400.h - definitions of s3c6400 specific spi interface	     */
+/* 									     */
+/* ------------------------------------------------------------------------- */
+/*   Copyright (C) 2006 Samsung Electronics Co. ltd.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		     */
+/* ------------------------------------------------------------------------- */
+
+#ifndef _S3C6400_SPI_H
+#define _S3C6400_SPI_H
+
+#include <asm/dma.h>
+#include <plat/dma.h>
+
+//#define SPI_CHANNEL 1	
+
+#if(SPI_CHANNEL==0)
+/* SPI CHANNEL 0 */
+#define S3C_SPI_TX_DATA_REG	0x7F00B018  //SPI TX data
+#define S3C_SPI_RX_DATA_REG	0x7F00B01C  //SPI RX data
+#else
+/* SPI CHANNEL 1 */
+#define S3C_SPI_TX_DATA_REG	0x7F00C018  //SPI TX data
+#define S3C_SPI_RX_DATA_REG	0x7F00C01C  //SPI RX data
+#endif
+
+/* DMA channel to be used for the SPI interface. */
+#define S3C_SPI_DMA		0	
+
+/* DMA transfer unit (byte). */
+#define S3C_DMA_XFER_BYTE   	1
+#define S3C_DMA_XFER_WORD	4	
+
+/* DMA configuration setup byte. */
+#define S3C_DCON_SPI1		(S3C_DCON_HANDSHAKE | S3C_DCON_SYNC_PCLK)
+
+/* DMA hardware configuration mode (DISRCC register). */
+#define S3C_SPI1_DMA_HWCFG	3
+#define S3C_SPI_DMA_HWCFG	3
+
+#define	DMA_BUFFER_SIZE		1500
+
+/* spi controller state */
+int req_dma_flag = 1;
+enum s3c_spi_state {
+	STATE_IDLE,
+	STATE_XFER_TX,
+	STATE_XFER_RX,
+	STATE_STOP
+};
+
+static struct s3c2410_dma_client s3c6400spi_dma_client = {
+	.name		= "s3c6400-spi-dma",
+};
+
+struct s3c_spi {
+	spinlock_t		lock;
+	struct semaphore 	sem;
+	int 			nr;
+	int			dma;
+	u_int			subchannel;/* user fragment index */
+	dma_addr_t		dmabuf_addr;
+
+	struct spi_msg		*msg;
+	unsigned int		msg_num;
+	unsigned int		msg_idx;
+	unsigned int		msg_ptr;
+	unsigned int		msg_rd_ptr;
+
+	enum s3c_spi_state	state;
+
+	void __iomem		*regs;
+	struct clk		*clk;
+	struct device		*dev;
+	struct resource		*irq;
+	struct resource		*ioarea;
+	struct spi_dev		spidev;
+};
+
+
+#endif /* _S3C6400_SPI_H */
diff -Nur linux-2.6.29/drivers/spi/Kconfig linux-2.6.29-spica/drivers/spi/Kconfig
--- linux-2.6.29/drivers/spi/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/spi/Kconfig	2010-05-06 12:42:45.644210217 +0700
@@ -197,6 +197,16 @@
 	  the inbuilt hardware cannot provide the transfer mode, or
 	  where the board is using non hardware connected pins.
 
+config SPI_GPIO
+	tristate "GPIO-based bitbanging SPI"
+	depends on GENERIC_GPIO
+	select SPI_BITBANG
+	help
+	  SPI driver for Samsung S3C24XX series ARM SoCs using
+	  GPIO lines to provide the SPI bus. This can be used where
+	  the inbuilt hardware cannot provide the transfer mode, or
+	  where the board is using non hardware connected pins.
+
 config SPI_SH_SCI
 	tristate "SuperH SCI SPI controller"
 	depends on SUPERH
@@ -204,6 +214,43 @@
 	help
 	  SPI driver for SuperH SCI blocks.
 
+config SPI_S3C6410
+	tristate "SPI Driver for S3C64XX"
+	depends on SPI && ARCH_S3C64XX && !SPI_GPIO
+	help
+	  Say Y here to include support for SPI controller in the
+	  Samsung S3C64XX based System-on-Chip devices.
+
+choice
+    prompt "SPI Clock Implementations"
+	depends on HS_SPI_S3C2450 || SPI_S3C6410 || HS_SPI_S3C2416
+
+config SPICLK_PCLK
+	bool "PCLK"
+	depends on HS_SPI_S3C2450 || SPI_S3C6410 || HS_SPI_S3C2416
+	help
+	  Say Y here to include support for pclk source.
+
+config SPICLK_EPLL
+	bool "EPLL"
+	depends on  HS_SPI_S3C2450 || SPI_S3C6410 || HS_SPI_S3C2416
+	help
+	  Say Y here to include support for EPLL source.
+
+config SPICLK_USBCLK
+	bool "USBCLK"
+	depends on HS_SPI_S3C6400 || HS_SPI_S3C6410
+	help
+	  Say Y here to include support for USB clock source.
+
+endchoice
+
+config WORD_TRANSIZE
+	bool "Tansfer size as Word"
+	depends on HS_SPI_S3C6400 || HS_SPI_S3C6410
+	help
+	  Say Y here to include support for word transfer size.
+
 config SPI_TXX9
 	tristate "Toshiba TXx9 SPI controller"
 	depends on GENERIC_GPIO && CPU_TX49XX
diff -Nur linux-2.6.29/drivers/spi/Makefile linux-2.6.29-spica/drivers/spi/Makefile
--- linux-2.6.29/drivers/spi/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/spi/Makefile	2010-05-06 12:42:45.644210217 +0700
@@ -30,8 +30,11 @@
 obj-$(CONFIG_SPI_TXX9)			+= spi_txx9.o
 obj-$(CONFIG_SPI_XILINX)		+= xilinx_spi.o
 obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
+obj-$(CONFIG_SPI_GPIO)			+= spi_gpio.o
 # 	... add above this line ...
 
+obj-$(CONFIG_SPI_S3C6410)    += spi_s3c64xx.o
+
 # SPI protocol drivers (device/link on bus)
 obj-$(CONFIG_SPI_SPIDEV)	+= spidev.o
 obj-$(CONFIG_SPI_TLE62X0)	+= tle62x0.o
diff -Nur linux-2.6.29/drivers/spi/spi-dev.c linux-2.6.29-spica/drivers/spi/spi-dev.c
--- linux-2.6.29/drivers/spi/spi-dev.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/spi/spi-dev.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,353 @@
+/*
+*    spi-dev.c - spi-bus driver, char device interface
+*
+*	Copyright (C) 2006 Samsung Electronics Co. Ltd.
+*
+*   This program is free software; you can redistribute it and/or modify
+*   it under the terms of the GNU General Public License as published by
+*   the Free Software Foundation; either version 2 of the License, or
+*   (at your option) any later version.
+*
+*   This program is distributed in the hope that it will be useful,
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*   GNU General Public License for more details.
+*
+*   You should have received a copy of the GNU General Public License
+*   along with this program; if not, write to the Free Software
+*   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <mach/s3c-dma.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include "spi-dev.h"
+#include <asm/uaccess.h>
+
+#undef debug
+#ifdef debug
+#define CRDEBUG	printk("%s :: %d\n",__FUNCTION__,__LINE__)
+#else
+#define CRDEBUG
+#endif
+
+static struct spi_dev *spi_dev_array[SPI_MINORS];
+static spinlock_t (spi_dev_array_lock) = SPIN_LOCK_UNLOCKED;
+
+static struct spi_dev *attach_to_spi_dev_array(struct spi_dev *spi_dev)
+{
+	CRDEBUG;
+	spin_lock(&spi_dev_array_lock);
+	if (spi_dev_array[spi_dev->minor]) {
+		spin_unlock(&spi_dev_array_lock);
+		dev_err(&spi_dev->dev, "spi-dev already has a device assigned to this adapter\n");
+		goto error;
+	}
+	spi_dev_array[spi_dev->minor] = spi_dev;
+	spin_unlock(&spi_dev_array_lock);
+	return spi_dev;
+error:
+	return ERR_PTR(-ENODEV);
+}
+
+static void return_spi_dev(struct spi_dev *spi_dev)
+{
+	CRDEBUG;
+	spin_lock(&spi_dev_array_lock);
+	spi_dev_array[spi_dev->minor] = NULL;
+	spin_unlock(&spi_dev_array_lock);
+}
+
+int spi_attach_spidev(struct spi_dev *spidev)
+{
+	struct spi_dev *spi_dev;
+
+	CRDEBUG;
+	spi_dev = attach_to_spi_dev_array(spidev);
+	if (IS_ERR(spi_dev))
+		return PTR_ERR(spi_dev);
+
+	dev_dbg(&spi_dev->dev, "Registered as minor %d\n", spi_dev->minor);
+
+	return 0;
+}
+
+int spi_detach_spidev(struct spi_dev *spi_dev)
+{
+	CRDEBUG;
+	return_spi_dev(spi_dev);
+
+	dev_dbg(&spi_dev->dev, "Adapter unregistered\n");
+	return 0;
+}
+
+struct spi_dev *spi_dev_get_by_minor(unsigned index)
+{
+	struct spi_dev *spi_dev;
+
+	CRDEBUG;
+	spin_lock(&spi_dev_array_lock);
+	spi_dev = spi_dev_array[index];
+	spin_unlock(&spi_dev_array_lock);
+	return spi_dev;
+}
+
+int spi_master_recv(struct spi_dev *spi_dev, char *rbuf ,int count)
+{
+	struct spi_msg msg;
+	int ret;
+
+	CRDEBUG;
+	if (spi_dev->algo->master_xfer) {
+		msg.flags = spi_dev->flags;
+		msg.len = count;
+		msg.wbuf = NULL;
+		msg.rbuf = rbuf;
+
+		dev_dbg(&spi_dev->dev, "master_recv: reading %d bytes.\n",
+			count);
+
+		down(&spi_dev->bus_lock);
+		ret = spi_dev->algo->master_xfer(spi_dev, &msg, 1);
+		up(&spi_dev->bus_lock);
+
+		dev_dbg(&spi_dev->dev, "master_recv: return:%d (count:%d)\n",
+			ret, count);
+
+		/* if everything went ok (i.e. 1 msg transmitted), return #bytes
+	 	* transmitted, else error code.
+	 	*/
+		return (ret == 1 )? count : ret;
+	} else {
+		dev_err(&spi_dev->dev, "SPI level transfers not supported\n");
+		return -ENOSYS;
+	}
+}
+
+int spi_master_send(struct spi_dev *spi_dev, const char *wbuf, int count)
+{
+	int ret;
+	struct spi_msg msg;
+
+	CRDEBUG;
+	if (spi_dev->algo->master_xfer) {
+		msg.flags = spi_dev->flags;
+		msg.len = count;
+		msg.wbuf = (char *)wbuf;
+		msg.rbuf = NULL;
+
+		dev_dbg(&spi_dev->dev, "master_send: writing %d bytes.\n",
+			count);
+		down(&spi_dev->bus_lock);
+		ret = spi_dev->algo->master_xfer(spi_dev, &msg, 1);
+		up(&spi_dev->bus_lock);
+
+		/* if everything went ok (i.e. 1 msg transmitted), return #bytes
+		 * transmitted, else error code.
+		 */
+		return (ret == 1 )? count : ret;
+	} else {
+		dev_err(&spi_dev->dev, "SPI level transfers not supported\n");
+		return -ENOSYS;
+	}
+}
+
+static ssize_t spidev_read (struct file *file, char __user *buf, size_t count,
+                            loff_t *offset)
+{
+	char *tmp;
+	int ret;
+	struct spi_dev *spi_dev = (struct spi_dev *)file->private_data;
+#ifdef CONFIG_WORD_TRANSIZE
+	count = count * 4;
+#endif
+	CRDEBUG;
+	if (count > BUFFER_SIZE)
+		count = BUFFER_SIZE;
+
+	if(spi_dev->flags & SPI_M_DMA_MODE){
+		tmp = dma_alloc_coherent(NULL, BUFFER_SIZE,
+			  &spi_dev->dmabuf, GFP_KERNEL | GFP_DMA);
+	}else{
+		tmp = kmalloc(count,GFP_KERNEL);
+	}
+	if (tmp==NULL)
+		return -ENOMEM;
+
+	pr_debug("%s: tmp=0x%x  dmabuf=0x%x\n",
+		__FUNCTION__,*tmp,spi_dev->dmabuf);
+	pr_debug("spi-dev: spi-%d reading %zd bytes.\n",
+		iminor(file->f_dentry->d_inode), count);
+
+	ret = spi_master_recv(spi_dev,tmp,count);
+	if (ret >= 0)
+		ret = copy_to_user(buf,tmp,count)?-EFAULT:ret;
+	if(spi_dev->flags & SPI_M_DMA_MODE){
+		dma_free_coherent(NULL,BUFFER_SIZE,tmp,spi_dev->dmabuf);
+	}else{
+		kfree(tmp);
+	}
+	return ret;
+}
+
+static ssize_t spidev_write (struct file *file, const char __user *buf, size_t count,
+                             loff_t *offset)
+{
+	int ret;
+	char *tmp;
+	struct spi_dev *spi_dev = (struct spi_dev *)file->private_data;
+#ifdef CONFIG_WORD_TRANSIZE
+	count = count * 4;
+#endif
+	CRDEBUG;
+	if (count > BUFFER_SIZE)
+		count = BUFFER_SIZE;
+	if(spi_dev->flags & SPI_M_DMA_MODE){
+		tmp = dma_alloc_coherent(NULL, BUFFER_SIZE,
+			  &spi_dev->dmabuf, GFP_KERNEL | GFP_DMA);
+	}else{
+		tmp = kmalloc(count,GFP_KERNEL);
+	}
+
+	if (tmp==NULL)
+		return -ENOMEM;
+	pr_debug("%s: tmp=0x%x  dmabuf=0x%x\n",
+		__FUNCTION__,*tmp,spi_dev->dmabuf);
+
+	if (copy_from_user(tmp, buf, count)) {
+		if(spi_dev->flags & SPI_M_DMA_MODE){
+			dma_free_coherent(NULL,BUFFER_SIZE,tmp,spi_dev->dmabuf);
+		}else{
+			kfree(tmp);
+		}
+		return -EFAULT;
+	}
+
+	pr_debug("spi-dev: spi-%d writing %zd bytes.\n",
+		iminor(file->f_dentry->d_inode), count);
+
+	ret = spi_master_send(spi_dev, tmp, count);
+	if(spi_dev->flags & SPI_M_DMA_MODE){
+		dma_free_coherent(NULL,BUFFER_SIZE,tmp,spi_dev->dmabuf);
+	}else{
+		kfree(tmp);
+	}
+	return ret;
+}
+
+int spidev_ioctl (struct inode *inode, struct file *file, unsigned int cmd,
+                  unsigned long arg)
+{
+	struct spi_dev *spi_dev = (struct spi_dev *)file->private_data;
+
+	CRDEBUG;
+	dev_dbg(&spi_dev->dev, "spi-%d ioctl, cmd: 0x%x, arg: %lx.\n",
+		iminor(inode),cmd, arg);
+
+	switch ( cmd ) {
+		case SET_SPI_FLAGS:
+			spi_dev->flags = (unsigned int) arg;
+			break;
+		case SET_SPI_RETRIES:
+			spi_dev->retries = arg;
+			break;
+		case SET_SPI_TIMEOUT:
+			spi_dev->timeout = arg;
+			break;
+		default:
+			printk("Invalid ioctl option\n");
+	}
+	return 0;
+}
+
+static int spidev_open(struct inode *inode, struct file *file)
+{
+	unsigned int minor = iminor(inode);
+	struct spi_dev *spi_dev;
+
+	CRDEBUG;
+
+	spi_dev = spi_dev_get_by_minor(minor);
+	if (!spi_dev)
+		return -ENODEV;
+
+	/* registered with adapter, passed as client to user */
+	file->private_data = spi_dev;
+
+	return 0;
+}
+
+int spi_master_close(struct spi_dev *spi_dev)
+{
+	int ret;
+	CRDEBUG;
+	ret = spi_dev->algo->close(spi_dev);
+	return 0;
+}
+static int spidev_release(struct inode *inode, struct file *file)
+{
+	struct spi_dev *spi_dev = (struct spi_dev *)file->private_data;
+	int ret;
+	CRDEBUG;
+
+	ret = spi_master_close(spi_dev);
+	file->private_data = NULL;
+
+	return 0;
+}
+
+static struct file_operations spidev_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= spidev_read,
+	.write		= spidev_write,
+	.ioctl		= spidev_ioctl,
+	.open		= spidev_open,
+	.release	= spidev_release,
+};
+
+static int spi_dev_init(void)
+{
+	int res;
+
+	printk(KERN_INFO "spi /dev entries driver\n");
+
+#if(SPI_CHANNEL==0)
+	res = register_chrdev(SPI_MAJOR, "spi0", &spidev_fops);
+#elif(SPI_CHANNEL==1)
+	res = register_chrdev(SPI_MAJOR, "spi1", &spidev_fops);
+#else
+	res = register_chrdev(SPI_MAJOR, "spi2", &spidev_fops);
+#endif
+
+	if (res)
+		goto out;
+
+	return 0;
+
+out:
+	printk(KERN_ERR "%s: Driver Initialisation failed\n", __FILE__);
+	return res;
+}
+
+static void spi_dev_exit(void)
+{
+	CRDEBUG;
+	unregister_chrdev(SPI_MAJOR,"spi");
+}
+
+MODULE_AUTHOR("Samsung Electronics");
+MODULE_DESCRIPTION("spi /dev entries driver");
+MODULE_LICENSE("GPL");
+
+module_init(spi_dev_init);
+module_exit(spi_dev_exit);
+
+EXPORT_SYMBOL(spi_attach_spidev);
+EXPORT_SYMBOL(spi_detach_spidev);
diff -Nur linux-2.6.29/drivers/spi/spi-dev.h linux-2.6.29-spica/drivers/spi/spi-dev.h
--- linux-2.6.29/drivers/spi/spi-dev.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/spi/spi-dev.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,140 @@
+/* ------------------------------------------------------------------------- */
+/* 									     */
+/* spi.h - definitions for the spi-bus interface			     */
+/* 									     */
+/* ------------------------------------------------------------------------- */
+/*   Copyright (C) 2006 Samsung Electronics Co. ltd.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		     */
+/* ------------------------------------------------------------------------- */
+
+#ifndef _LINUX_SPI_H
+#define _LINUX_SPI_H
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/device.h>	/* for struct device */
+#include <linux/semaphore.h>
+
+/* --- General options ------------------------------------------------	*/
+
+struct spi_msg;
+struct spi_dev;
+struct spi_algorithm;
+
+/*
+ * The master routines are the ones normally used to transmit data to devices
+ * on a bus (or/and read from them). Apart from these basic transfer functions
+ * to transmit one message at a time, a more complex version can be used to
+ * transmit an arbitrary number of messages without interruption.
+ */
+extern int spi_master_send(struct spi_dev *,const char* ,int);
+extern int spi_master_recv(struct spi_dev *,char* ,int);
+
+#define SPI_CHANNEL 0
+#define BUFFER_SIZE     65536
+#define SPI_MINORS      2
+
+/*
+ * A driver is capable of handling one or more physical devices present on
+ * SPI adapters. This information is used to inform the driver of adapter
+ * events.
+ */
+
+struct spi_dev {
+	int 			minor;
+
+	dma_addr_t		dmabuf;		/* handle for DMA transfer		*/
+	unsigned int 		flags;		/* flags for the SPI operation 		*/
+	struct semaphore 	bus_lock;	/* semaphore for bus access 		*/
+
+	struct spi_algorithm 	*algo;		/* the algorithm to access the bus	*/
+	void 			*algo_data;	/* the bus control struct		*/
+
+	int 			timeout;
+	int 			retries;
+	struct device		dev;		/* the adapter device 			*/
+};
+
+/*
+ * The following structs are for those who like to implement new bus drivers:
+ * spi_algorithm is the interface to a class of hardware solutions which can
+ * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584
+ * to name two of the most common.
+ */
+struct spi_algorithm {
+	char name[32];				/* textual description 	*/
+	unsigned int id;
+
+	/* If an adapter algorithm can't to SPI-level access, set master_xfer
+	   to NULL. If an adapter algorithm can do SMBus access, set
+	   smbus_xfer. If set to NULL, the SMBus protocol is simulated
+	   using common SPI messages */
+	int (*master_xfer)(struct spi_dev *spi_dev,struct spi_msg *msgs,
+	                   int num);
+
+	/* --- ioctl like call to set div. parameters. */
+	int (*algo_control)(struct spi_dev *, unsigned int, unsigned long);
+
+	/* To determine what the adapter supports */
+	u32 (*functionality) (struct spi_dev *);
+	int (*close)(struct spi_dev *spi_dev);
+};
+
+/* ----- functions exported by spi.o */
+
+/* administration...
+ */
+extern int spi_attach_spidev(struct spi_dev *);
+extern int spi_detach_spidev(struct spi_dev *);
+
+/*
+ * SPI Message - used for pure spi transaction, also from /dev interface
+ */
+
+#define SPI_M_MODE_MASTER	0x001
+#define SPI_M_MODE_SLAVE	0x002
+#define SPI_M_USE_FIFO		0x004
+#define SPI_M_CPOL_ACTHIGH	0x010
+#define SPI_M_CPOL_ACTLOW	0x020
+#define SPI_M_CPHA_FORMATA	0x040
+#define SPI_M_CPHA_FORMATB	0x080
+#define SPI_M_DMA_MODE		0x100
+#define SPI_M_INT_MODE		0x200
+#define SPI_M_POLL_MODE		0x400
+#define SPI_M_DEBUG		0x800
+#define SPI_M_FIFO_POLL		0x1000
+
+
+struct spi_msg {
+ 	__u16 flags;
+ 	__u16 len;		/* msg length				*/
+ 	__u8 *wbuf;		/* pointer to msg data to write	*/
+ 	__u8 *rbuf;		/* pointer to msg data for read */
+};
+
+/* ----- commands for the ioctl call:	*/
+				/* -> spi-adapter specific ioctls	*/
+#define SET_SPI_RETRIES	0x0701	/* number of times a device address      */
+				/* should be polled when not            */
+                                /* acknowledging 			*/
+#define SET_SPI_TIMEOUT	0x0702	/* set timeout - call with int 		*/
+#define SET_SPI_FLAGS	0x0704  /* set flags for h/w settings 		*/
+
+#define SPI_MAJOR	153		/* Device major number		*/
+					/* minor 0-15 spi0 - spi15 	*/
+
+#endif /* _LINUX_SPI_H */
+
diff -Nur linux-2.6.29/drivers/spi/spi_s3c64xx.c linux-2.6.29-spica/drivers/spi/spi_s3c64xx.c
--- linux-2.6.29/drivers/spi/spi_s3c64xx.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/spi/spi_s3c64xx.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,791 @@
+/* linux/drivers/spi/spi_s3c64xx.c
+ *
+ * Copyright (C) 2007 Samsung Electronics
+ * Copyright (c) 2006 Ben Dooks
+ * Copyright (c) 2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ * 
+ */
+
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/delay.h>
+
+#include <plat/regs-clock.h>
+#include <plat/regs-gpio.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-spi.h>
+#include <plat/dma.h>
+#include <mach/gpio.h>
+
+#if defined(CONFIG_PM)
+#include <plat/pm.h>
+#endif
+
+struct s3c6410_spi {
+	/* bitbang has to be first */
+	struct spi_bitbang		 bitbang;
+	struct completion		 done;
+
+	void __iomem			*regs;
+	void __iomem			*regs_sys;
+	int			 			irq;
+	int			 			len;
+	int			 			count;
+
+	/* data buffers */
+	const void				*tx;
+	void					*rx;
+	
+	struct clk				*clk;
+	struct resource			*ioarea;
+	struct spi_master		*master;
+	struct spi_device		*curdev;
+	struct device			*dev;
+	struct s3c6410_spi_info *pdata;
+	int						tx_done, rx_done;
+	int						bits_per_word;
+	int						id;
+	int 					lsb_first;
+	unsigned long			in_clk;
+	unsigned int 			flag;
+	spinlock_t      		lock;
+};
+
+/* functions */
+static inline struct s3c6410_spi *to_hw(struct spi_device *sdev);
+static void s3c6410_spi_chipsel(struct spi_device *spi, int value);
+static int s3c6410_spi_setupxfer(struct spi_device *spi,
+				 struct spi_transfer *t);
+static int s3c6410_spi_setup(struct spi_device *spi);
+static unsigned int hw_tx(struct s3c6410_spi *hw);
+static void  hw_rx(struct s3c6410_spi *hw, unsigned int data);
+static int s3c6410_spi_txrx(struct spi_device *spi, struct spi_transfer *t);
+static irqreturn_t s3c6410_spi_irq(int irq, void *dev);
+static int s3c6410_spi_probe(struct platform_device *pdev);
+static int s3c6410_spi_remove(struct platform_device *dev);
+static int __init s3c6410_spi_init(void);
+static void __exit s3c6410_spi_exit(void);
+
+
+
+
+
+static struct s3c6410_spi *test_hw;
+
+
+static struct sleep_save s3c_spi_save[12];
+
+
+
+/*
+ * to_hw  - return the pointer of s3c6410_spi struct 
+ * @sdev   : spi_device sturct
+ *
+ */
+static inline struct s3c6410_spi *to_hw(struct spi_device *sdev)
+{
+	return spi_master_get_devdata(sdev->master);
+}
+
+static void s3c6410_spi_set_cs(struct s3c6410_spi *spi, int value)
+{
+	struct s3c6410_spi *hw = spi;
+	int reg;
+
+	switch (value) {
+	/* Select */
+	case BITBANG_CS_ACTIVE:  
+		reg = readl(hw->regs + S3C_SLAVE_SEL);
+		reg &= ~(SPI_SLAVE_SIG_INACT);
+		writel(reg, hw->regs + S3C_SLAVE_SEL);
+		udelay(30);
+		break;
+	
+	/* Non-Select */
+	case BITBANG_CS_INACTIVE: 
+		reg = readl(hw->regs + S3C_SLAVE_SEL);
+		reg |= SPI_SLAVE_SIG_INACT;
+		writel(reg, hw->regs + S3C_SLAVE_SEL);
+		break;
+	}
+}
+
+/*
+ * s3c6410_spi_chipsel  - select spi slave chip
+ * @spi   : spi_device sturct
+ * @value : chipselect value
+ *
+ * bitbang driver member fuction to select spi slave chip 
+ */
+static void s3c6410_spi_chipsel(struct spi_device *spi, int value)
+{
+	struct s3c6410_spi *hw = to_hw(spi);
+	int reg;
+
+	switch (value) {
+	/* Select */
+	case BITBANG_CS_ACTIVE:  
+		reg = readl(hw->regs + S3C_SLAVE_SEL);
+		reg &= ~(SPI_SLAVE_SIG_INACT);
+		writel(reg, hw->regs + S3C_SLAVE_SEL);
+		udelay(30);
+		break;
+	
+	/* Non-Select */
+	case BITBANG_CS_INACTIVE: 
+		reg = readl(hw->regs + S3C_SLAVE_SEL);
+		reg |= SPI_SLAVE_SIG_INACT;
+		writel(reg, hw->regs + S3C_SLAVE_SEL);
+		break;
+	}
+}
+
+/*
+ * s3c6410_spi_setupxfer  - setup spi control
+ * @spi : spi_device sturct
+ * @t   : spi_transfer struct
+ *
+ * bitbang driver member fuction to setup spi control
+ * it set bit_per_word and serial clock rate.
+ */
+static int s3c6410_spi_setupxfer(struct spi_device *spi,
+				 struct spi_transfer *t)
+{
+	struct s3c6410_spi *hw = to_hw(spi);
+	unsigned int bpw, mode, spi_chcfg;
+	int scr, ret = 0;
+	unsigned int bit_rate, reg = 0;
+	unsigned long pclk;
+
+	/*	bpw = t ? t->bits_per_word : spi->bits_per_word; */
+	bpw = spi->bits_per_word;
+	bit_rate  = t ? t->speed_hz : spi->max_speed_hz;
+
+	/* set bits per word */
+	if (bpw > 32 || bpw < 8) {
+		dev_err(&spi->dev, "spi:  invalid bits-per-word (%d)\n", bpw);
+		return -EINVAL;
+	}
+
+	/* Set SPI_SCALER :
+	   bit rate = PCLK / ( 2 * (1 + SPI_SCALER)) 
+	   SPI_SCALER = (PCLK / bit rate / 2) -1	
+	   SPI_SCALER = 0 (default)	*/
+
+	writel(readl(hw->regs + S3C_CLK_CFG) & (~SPI_ENCLK_ENABLE), hw->regs + S3C_CLK_CFG );	
+
+	pclk =  hw->in_clk;
+	scr = (pclk / bit_rate / 2) - 1;
+
+	if(scr < 0) 	scr = 0;
+	if(scr > 0xff) 	scr = 0xff;
+
+	bit_rate = (unsigned int) (pclk / ( 2 * (scr + 1)));
+	printk("spi:  setting serial clock rate to %d (bit rate = %d hz, pclk = %d)\n", scr, bit_rate, (int)pclk);
+	reg = readl(hw->regs + S3C_CLK_CFG);
+	writel(reg | scr | SPI_ENCLK_ENABLE, hw->regs + S3C_CLK_CFG );	
+
+	if	   (bpw > 16)	mode = SPI_MODE_CH_TSZ_WORD | SPI_MODE_BUS_TSZ_WORD;
+	else if(bpw > 8) 	mode = SPI_MODE_CH_TSZ_HALFWORD | SPI_MODE_BUS_TSZ_HALFWORD;
+	else 				mode = SPI_MODE_CH_TSZ_BYTE | SPI_MODE_BUS_TSZ_BYTE;
+
+	mode |= (SPI_MODE_RXDMA_OFF | SPI_MODE_TXDMA_OFF);
+	writel(mode, hw->regs + S3C_MODE_CFG);
+	mode = readl( hw->regs + S3C_MODE_CFG);
+
+	spi_chcfg = readl(hw->regs + S3C_CH_CFG);
+	spi_chcfg |= SPI_CH_TXCH_ON | SPI_CH_RXCH_ON;
+	writel(spi_chcfg , hw->regs + S3C_CH_CFG);
+
+	spin_lock(&hw->bitbang.lock);
+	if (!hw->bitbang.busy) {
+		hw->bitbang.chipselect(spi, BITBANG_CS_INACTIVE);
+		/* need to ndelay for 0.5 clocktick */
+	}
+	spin_unlock(&hw->bitbang.lock);
+
+	return ret;
+}
+
+/*
+ * s3c6410_spi_setup  - setup spi attribute
+ * @spi : spi_device sturct
+ *
+ * bitbang driver member fuction to setup spi attribute
+ * it set bit_per_word and spi mode.
+ */
+static int s3c6410_spi_setup(struct spi_device *spi)
+{
+	struct s3c6410_spi *hw = to_hw(spi);
+	int ret;
+
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	/* Set Swap Config Reg */
+	if(spi->mode & SPI_LSB_FIRST) 
+		writel(SPI_SWAP_RX_BIT |
+		       SPI_SWAP_RX_EN  |
+		       SPI_SWAP_TX_BIT |
+		       SPI_SWAP_TX_EN, hw->regs + S3C_SWAP_CFG);
+	else 
+		writel(0, hw->regs + S3C_SWAP_CFG);		
+
+	ret = s3c6410_spi_setupxfer(spi, NULL);
+	if (ret < 0) {
+		dev_err(&spi->dev, "setupxfer returned %d\n", ret);
+		return ret;
+	}
+
+	printk("spi:  mode %d, %u bpw, %d hz\n",
+		spi->mode, spi->bits_per_word,spi->max_speed_hz);
+
+	return ret;
+}
+
+/*
+ * hw_tx - load data pointed by a hw->tx pointer to tx fifo.
+ * @hw   : s3c6410_spi struct
+ *
+ * it is a sub funtion to load data pointed by a hw->tx pointer to tx fifo
+ *
+ */
+static unsigned int hw_tx(struct s3c6410_spi *hw)
+{
+	unsigned int tmp;
+
+	// if hw->tx is NULL, return 0
+	if(!hw->tx) return 0;
+	
+	if(hw->bits_per_word > 16) //32 bit
+		tmp=*((unsigned int*)hw->tx+hw->tx_done);
+
+	else if(hw->bits_per_word > 8)	//16 bit
+		tmp=(unsigned int) *((unsigned short*)hw->tx + hw->tx_done);
+
+	else					//8 bit
+		tmp = (unsigned int) *((unsigned char*)hw->tx + hw->tx_done);
+	
+	return tmp;
+}
+
+/*
+ * hw_rx - store data to memory pointed to by a hw->rx pointer
+ * @hw   : s3c6410_spi struct
+ * @data : data
+ *
+ * it is a sub funtion to store data to memory pointed to by a hw->rx pointer.
+ *
+*/
+static void  hw_rx(struct s3c6410_spi *hw, unsigned int data)
+{
+	// if hw->rx is NULL, return
+	if(!hw->rx) return;
+
+	if(hw->bits_per_word>16)
+		*((unsigned int*)hw->rx+hw->rx_done) = data;
+
+	else if(hw->bits_per_word>8)	// 16 bit
+		*((unsigned short*)hw->rx+hw->rx_done)= (unsigned short)data;	
+
+	else 					// 8 bit
+		*((unsigned char*)hw->rx+hw->rx_done)=(unsigned char) data;
+}
+
+
+unsigned int swap_bit(unsigned int data)
+{
+	unsigned char data1 = (unsigned char)data;
+	unsigned char ret = 0;
+	unsigned int val, i;
+
+	for(i=0;i<8;i++)
+	{
+		ret+=(data1&1);
+		data1>>=1;
+		if(i<7)
+		ret<<=1;
+	}
+
+	val = (unsigned int) ret;
+	printk("SPI:swap_bit 0x%x -> 0x%x\n",data, val);
+	return val;
+}
+
+/*
+ * s3c6410_spi_txrx  - handle for spi_message
+ * @spi : spi_device sturct
+ * @t   : spi_transfer struct
+ *
+ * bitbang driver member fuction to handle for spi_message
+ * it send first message.
+ */
+static int s3c6410_spi_txrx(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct s3c6410_spi *hw = to_hw(spi);
+	unsigned int spi_modecfg, spi_inten;
+
+	hw->tx = t->tx_buf;
+	hw->rx = t->rx_buf;
+	hw->len = t->len;
+	hw->count = 0;
+	hw->tx_done = 0;
+	hw->rx_done = 0;
+	hw->flag = 0;	
+
+	init_completion(&hw->done);
+
+	spi_modecfg = readl(hw->regs + S3C_MODE_CFG);
+	spi_modecfg |= (hw->len << 5) | (hw->len << 11);
+	writel(spi_modecfg, hw->regs + S3C_MODE_CFG);
+
+	/* enable SPI Interrupt */
+	if(hw->tx)
+		spi_inten = SPI_INT_TX_FIFORDY_EN|SPI_INT_TX_UNDERRUN_EN|SPI_INT_TX_OVERRUN_EN;
+
+	if(hw->rx)
+		spi_inten = SPI_INT_RX_FIFORDY_EN|SPI_INT_RX_UNDERRUN_EN|SPI_INT_RX_OVERRUN_EN|SPI_INT_TRAILING_EN;
+
+	writel(spi_inten , hw->regs + S3C_SPI_INT_EN); 
+
+	wait_for_completion(&hw->done);
+
+	return hw->rx_done;
+}
+
+
+/*
+ * s3c6410_spi_interrupt  - spi fifo interrupt handler
+ * @irq    : interrupt number
+ * @dev    : device instance
+ *
+ * spi fifo interrupt handler
+ */
+static irqreturn_t s3c6410_spi_irq(int irq, void *dev)
+{
+	struct s3c6410_spi *hw = dev;
+	unsigned int pend = readl(hw->regs + S3C_SPI_STATUS);
+	unsigned int w_tmp;
+	unsigned int r_tmp;
+	int err = 0;
+
+	spin_lock(&hw->lock);
+
+	if(pend & SPI_STUS_RX_OVERRUN_ERR)
+	{
+		printk("spi%d: RX FIFO overrun error\n", hw->id);
+		writel(SPI_PND_RX_OVERRUN_CLR, hw->regs + S3C_PENDING_CLR);
+		err = 1;
+	}
+	if(pend & SPI_STUS_RX_UNDERRUN_ERR)
+	{
+		printk("spi%d: RX FIFO underrun error\n", hw->id);
+		writel(SPI_PND_RX_UNDERRUN_CLR, hw->regs + S3C_PENDING_CLR);
+		err = 1;
+	}
+	if(pend & SPI_STUS_TX_OVERRUN_ERR)
+	{
+		printk("spi%d: TX FIFO overrun error\n", hw->id);
+		writel(SPI_PND_TX_OVERRUN_CLR, hw->regs + S3C_PENDING_CLR);
+		err = 1;
+	}
+	if(pend & SPI_STUS_TX_UNDERRUN_ERR)
+	{
+		printk("spi%d: TX FIFO underrun error\n", hw->id);
+		writel(SPI_PND_TX_UNDERRUN_CLR, hw->regs + S3C_PENDING_CLR);
+		err = 1;
+	}
+
+	if(err)
+	{
+		complete(&hw->done);
+		return IRQ_HANDLED;
+	}
+	
+	if((pend & SPI_STUS_TX_FIFORDY) && (hw->tx_done < hw->len))
+	{
+		w_tmp = hw_tx(hw);
+        writel(w_tmp, hw->regs + S3C_SPI_TX_DATA);
+		udelay(30);
+		
+		hw->flag = 1;
+	    hw->tx_done++;
+	}
+	
+	if(pend & (SPI_STUS_RX_FIFOLVL)) 
+	{
+		r_tmp = readl(hw->regs + S3C_SPI_RX_DATA);
+        hw_rx(hw, r_tmp);
+		hw->flag = 0;
+		hw->rx_done++;
+	}
+
+	if(hw->rx_done == hw->len && hw->tx_done == hw->len)
+	{
+		writel(SPI_INT_ALL_DISABLE, hw->regs + S3C_SPI_INT_EN);
+		udelay(30);
+		complete(&hw->done);
+	}
+	
+	spin_unlock(&hw->lock);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * s3c6410_spi_probe  - probe spi driver
+ * @pdev	: platform device struct
+ *
+ * platform driver member function for probing
+ */
+static int s3c6410_spi_probe(struct platform_device *pdev)
+{
+	struct s3c6410_spi *hw;
+	struct spi_master *master;
+	struct spi_board_info *bi;
+	struct resource *res;
+	int err = 0;
+	int i;
+	unsigned int spi_chcfg;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct s3c6410_spi));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "No memory for spi_master\n");
+		err = -ENOMEM;
+		goto err_nomem;
+	}
+
+	hw = spi_master_get_devdata(master);
+	memset(hw, 0, sizeof(struct s3c6410_spi));
+
+	hw->master = spi_master_get(master);
+	hw->master->num_chipselect = 2;
+	hw->pdata = pdev->dev.platform_data;
+	hw->dev = &pdev->dev;
+	hw->id = pdev->id;
+
+	if (hw->pdata == NULL) {
+		dev_err(&pdev->dev, "No platform data supplied\n");
+		err = -ENOENT;
+		goto err_no_pdata;
+	}
+
+	platform_set_drvdata(pdev, hw);
+
+	/* setup the state for the bitbang driver */
+	hw->bitbang.master         = hw->master;
+	hw->bitbang.setup_transfer = s3c6410_spi_setupxfer;
+	hw->bitbang.chipselect     = s3c6410_spi_chipsel;
+	hw->bitbang.txrx_bufs      = s3c6410_spi_txrx;
+	hw->bitbang.master->setup  = s3c6410_spi_setup;
+	
+	init_completion(&hw->done);
+
+	/* find and map our resources */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");
+		err = -ENOENT;
+		goto err_no_iores;
+	}
+
+	hw->ioarea = request_mem_region(res->start, (res->end - res->start)+1,
+					pdev->name);
+
+	if (hw->ioarea == NULL) {
+		dev_err(&pdev->dev, "Cannot reserve region\n");
+		err = -ENXIO;
+		goto err_no_iores;
+	}
+
+	hw->regs = ioremap(res->start, (res->end - res->start)+1);
+	hw->regs += 0x1000 * hw->id;
+
+
+	if (hw->regs == NULL) {
+		dev_err(&pdev->dev, "Cannot map IO\n");
+		err = -ENXIO;
+		goto err_no_iomap;
+	}
+
+	hw->irq = platform_get_irq(pdev, 0);
+	if (hw->irq < 0) {
+		dev_err(&pdev->dev, "No IRQ specified\n");
+		err = -ENOENT;
+		goto err_no_irq;
+	}
+
+	err = request_irq(hw->irq, s3c6410_spi_irq, IRQF_DISABLED, pdev->name, hw);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot claim IRQ\n");
+		goto err_no_irq;
+	}
+
+	hw->clk = clk_get(&pdev->dev, "spi");
+	if (IS_ERR(hw->clk)) {
+		dev_err(&pdev->dev, "No clock for device\n");
+		err = PTR_ERR(hw->clk);
+		goto err_no_clk;
+	}
+
+	printk("S3C6410 SPI Driver at 0x%x, irq %d\n", (unsigned int)hw->regs, hw->irq);
+
+	/* for the moment, permanently enable the clock */
+#ifdef CONFIG_SPICLK_PCLK
+	clk_enable(hw->clk);
+	hw->in_clk = clk_get_rate(hw->clk);
+#elif defined (CONFIG_SPICLK_EPLL)
+	writel((readl(S3C_PCLK_GATE)|S3C_CLKCON_PCLK_SPI0|S3C_CLKCON_PCLK_SPI1),S3C_PCLK_GATE);
+	writel((readl(S3C_SCLK_GATE)|S3C_CLKCON_SCLK_SPI0|S3C_CLKCON_SCLK_SPI1),S3C_SCLK_GATE);
+
+	writel(readl(S3C_CLK_SRC)|S3C_CLKSRC_MPLL_CLKSEL, S3C_CLK_SRC);
+
+	/* Set SPi Clock to MOUT(266Mhz)*/
+	if(hw->id == 0)		/* SPI_CHANNEL = 0 */
+		writel((readl(S3C_CLK_SRC)&~(0x3<<14))|(1<<14), S3C_CLK_SRC);
+	else  				/* SPI_CHANNEL = 1 */
+		writel((readl(S3C_CLK_SRC)&~(0x3<<16))|(1<<16), S3C_CLK_SRC);
+
+	/* CLK_DIV2 setting */
+	/* SPI Input Clock(88.87Mhz) = 266.66Mhz / (2 + 1)*/
+	writel(((readl(S3C_CLK_DIV2) & ~(0xff << 0)) | 2) , S3C_CLK_DIV2);
+
+	hw->in_clk = 266660000;
+
+#elif defined (CONFIG_SPICLK_USBCLK)
+	writel((readl(S3C_PCLK_GATE)| S3C_CLKCON_PCLK_SPI0|S3C_CLKCON_PCLK_SPI1),S3C_PCLK_GATE);
+	writel((readl(S3C_SCLK_GATE)|S3C_CLKCON_SCLK_SPI0_48|S3C_CLKCON_SCLK_SPI1_48),S3C_SCLK_GATE);
+	hw->in_clk = 48000000;
+#endif
+	
+	printk("SPI: Source Clock = %ldMhz\n", hw->in_clk);
+
+	/* initialize the gpio */
+	if (hw->id == 0) {
+		s3c_gpio_cfgpin(S3C64XX_GPC(0), S3C64XX_GPC0_SPI_MISO0);
+		s3c_gpio_cfgpin(S3C64XX_GPC(1), S3C64XX_GPC1_SPI_CLK0);
+		s3c_gpio_cfgpin(S3C64XX_GPC(2), S3C64XX_GPC2_SPI_MOSI0);
+		s3c_gpio_cfgpin(S3C64XX_GPC(3), S3C64XX_GPC3_SPI_nCS0);
+
+		s3c_gpio_setpull(S3C64XX_GPC(0), S3C_GPIO_PULL_UP);
+		s3c_gpio_setpull(S3C64XX_GPC(1), S3C_GPIO_PULL_UP);
+		s3c_gpio_setpull(S3C64XX_GPC(2), S3C_GPIO_PULL_UP);
+		s3c_gpio_setpull(S3C64XX_GPC(3), S3C_GPIO_PULL_UP);
+	} else {
+		s3c_gpio_cfgpin(S3C64XX_GPC(4), S3C64XX_GPC4_SPI_MISO1);
+		s3c_gpio_cfgpin(S3C64XX_GPC(5), S3C64XX_GPC5_SPI_CLK1);
+		s3c_gpio_cfgpin(S3C64XX_GPC(6), S3C64XX_GPC6_SPI_MOSI1);
+		s3c_gpio_cfgpin(S3C64XX_GPC(7), S3C64XX_GPC7_SPI_nCS1);
+
+		s3c_gpio_setpull(S3C64XX_GPC(4), S3C_GPIO_PULL_UP);
+		s3c_gpio_setpull(S3C64XX_GPC(5), S3C_GPIO_PULL_UP);
+		s3c_gpio_setpull(S3C64XX_GPC(6), S3C_GPIO_PULL_UP);
+		s3c_gpio_setpull(S3C64XX_GPC(7), S3C_GPIO_PULL_UP);
+	}
+
+	/* SW Reset */	
+	writel(readl(hw->regs + S3C_CH_CFG) | SPI_CH_SW_RST, hw->regs + S3C_CH_CFG);
+	udelay(100);
+	writel(readl(hw->regs + S3C_CH_CFG) & (~SPI_CH_SW_RST), hw->regs + S3C_CH_CFG);
+	udelay(100);
+
+	/* disable  SPI Interrupt */
+	writel(SPI_INT_ALL_DISABLE, hw->regs + S3C_SPI_INT_EN);
+
+	/* Set transfer type (CPOL & CPHA set) */
+	spi_chcfg = readl(hw->regs + S3C_CH_CFG);
+	spi_chcfg &= ~SPI_CH_HSPD_EN;
+	spi_chcfg |= SPI_CH_FORMAT_B | SPI_CH_RISING | SPI_CH_MASTER; 
+	writel(spi_chcfg, hw->regs + S3C_CH_CFG);
+
+	/* Set NSSOUT to start high after Reset */
+	s3c6410_spi_set_cs(hw, BITBANG_CS_INACTIVE);
+
+	/* register our spi controller */
+	err = spi_bitbang_start(&hw->bitbang);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to register SPI master\n");
+		goto err_register;
+	}
+
+	/* register all the devices associated */
+	bi = hw->pdata->board_info;
+	for (i = 0; i < hw->pdata->board_size; i++, bi++) {
+		dev_info(hw->dev, "registering %s\n", bi->modalias);
+
+		bi->controller_data = hw;
+		spi_new_device(master, bi);
+	}
+	
+	/* for suspend & resume */
+	test_hw = hw;
+
+	return 0;
+
+ err_register:
+	clk_disable(hw->clk);
+	clk_put(hw->clk);
+
+ err_no_clk:
+	free_irq(hw->irq, hw);
+
+ err_no_irq:
+	iounmap(hw->regs);
+
+ err_no_iomap:
+	release_resource(hw->ioarea);
+	kfree(hw->ioarea);
+
+ err_no_iores:
+ err_no_pdata:
+	spi_master_put(hw->master);;
+
+ err_nomem:
+	return err;
+}
+
+/*
+ * s3c6410_spi_remove  - remove spi driver
+ * @pdev	: platform device struct
+ *
+ * platform driver member function to remove spi driver
+ */
+static int s3c6410_spi_remove(struct platform_device *dev)
+{
+	struct s3c6410_spi *hw = platform_get_drvdata(dev);
+
+	platform_set_drvdata(dev, NULL);
+
+	spi_unregister_master(hw->master);
+
+	clk_disable(hw->clk);
+	clk_put(hw->clk);
+
+	free_irq(hw->irq, hw);
+	iounmap(hw->regs);
+
+	release_resource(hw->ioarea);
+	kfree(hw->ioarea);
+
+	spi_master_put(hw->master);
+	return 0;
+}
+
+
+
+
+#ifdef CONFIG_PM
+/*
+ * s3c6410_spi_suspend  - resume spi driver
+ * @pdev	: platform device struct
+ * @msg		: pm_message_t
+ *
+ * platform driver member function to suspend spi driver
+ */
+static int s3c6410_spi_suspend(struct platform_device *pdev, pm_message_t msg)
+{
+	struct s3c6410_spi *hw = platform_get_drvdata(pdev);
+	printk("test_hw->regs = %x , %s\n",(unsigned int)(test_hw->regs),__func__);
+
+	s3c_spi_save[0].reg = test_hw->regs + S3C_CH_CFG;
+	s3c_spi_save[1].reg = test_hw->regs + S3C_CLK_CFG;
+	s3c_spi_save[2].reg = test_hw->regs + S3C_MODE_CFG;
+	s3c_spi_save[3].reg = test_hw->regs + S3C_SLAVE_SEL;
+	s3c_spi_save[4].reg = test_hw->regs + S3C_SPI_INT_EN;
+	s3c_spi_save[5].reg = test_hw->regs + S3C_SPI_STATUS;
+	s3c_spi_save[6].reg = test_hw->regs + S3C_SPI_TX_DATA;
+	s3c_spi_save[7].reg = test_hw->regs + S3C_SPI_RX_DATA;
+	s3c_spi_save[8].reg = test_hw->regs + S3C_PACKET_CNT;
+	s3c_spi_save[9].reg = test_hw->regs + S3C_PENDING_CLR;
+	s3c_spi_save[10].reg = test_hw->regs + S3C_SWAP_CFG;
+	s3c_spi_save[11].reg = test_hw->regs + S3C_FB_CLK;
+	
+	s3c6410_pm_do_save(s3c_spi_save, ARRAY_SIZE(s3c_spi_save));
+	clk_disable(hw->clk);
+	return 0;
+}
+
+/*
+ * s3c6410_spi_resume  - resume spi driver
+ * @pdev	: platform device struct
+ *
+ * platform driver member function to resume spi driver
+ */
+static int s3c6410_spi_resume(struct platform_device *pdev)
+{
+	struct s3c6410_spi *hw = platform_get_drvdata(pdev);
+
+	printk("%s\n",__func__);
+
+	/* for the moment, permanently enable the clock */
+
+	clk_enable(hw->clk);
+
+    s3c6410_pm_do_restore(s3c_spi_save, ARRAY_SIZE(s3c_spi_save));
+
+	/* sw reset */
+	
+	writel(readl(hw->regs + S3C_CH_CFG) | SPI_CH_SW_RST, hw->regs + S3C_CH_CFG);
+	udelay(100);
+	writel(readl(hw->regs + S3C_CH_CFG) & (~SPI_CH_SW_RST), hw->regs + S3C_CH_CFG);
+	udelay(100);
+
+	return 0;
+}
+
+#else
+#define s3c6410_spi_suspend NULL
+#define s3c6410_spi_resume  NULL
+#endif
+
+static struct platform_driver s3c6410_spidrv = {
+	.probe		= s3c6410_spi_probe,
+	.remove		= s3c6410_spi_remove,
+	.suspend	= s3c6410_spi_suspend,
+	.resume		= s3c6410_spi_resume,
+	.driver		= {
+		.name	= "s3c-spi",
+		.owner	= THIS_MODULE,
+	},
+};
+
+/*
+ * s3c6410_spi_init - module init function for spi driver
+ */
+static int __init s3c6410_spi_init(void)
+{
+	return platform_driver_register(&s3c6410_spidrv);
+}
+
+/*
+ * s3c6410_spi_exit - module exit function for spi driver
+ */
+static void __exit s3c6410_spi_exit(void)
+{
+	platform_driver_unregister(&s3c6410_spidrv);
+}
+
+module_init(s3c6410_spi_init);
+module_exit(s3c6410_spi_exit);
+
+MODULE_DESCRIPTION("Samsung S3C6000 spi driver");
+MODULE_AUTHOR("Donghoon Yu <hoony.yu@samsung.com>");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/staging/android/binder.c linux-2.6.29-spica/drivers/staging/android/binder.c
--- linux-2.6.29/drivers/staging/android/binder.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/staging/android/binder.c	2010-03-30 11:00:20.000000000 +0700
@@ -41,6 +41,8 @@
 static struct proc_dir_entry *binder_proc_dir_entry_root;
 static struct proc_dir_entry *binder_proc_dir_entry_proc;
 static struct hlist_head binder_dead_nodes;
+static HLIST_HEAD(binder_deferred_list);
+static DEFINE_MUTEX(binder_deferred_lock);
 
 static int binder_read_proc_proc(
 	char *page, char **start, off_t off, int count, int *eof, void *data);
@@ -54,11 +56,7 @@
 #define SZ_4M                               0x400000
 #endif
 
-#ifndef __i386__
-#define FORBIDDEN_MMAP_FLAGS                (VM_WRITE | VM_EXEC)
-#else
 #define FORBIDDEN_MMAP_FLAGS                (VM_WRITE)
-#endif
 
 #define BINDER_SMALL_BUF_SIZE (PAGE_SIZE * 64)
 
@@ -236,6 +234,12 @@
 	uint8_t data[0];
 };
 
+enum {
+	BINDER_DEFERRED_PUT_FILES    = 0x01,
+	BINDER_DEFERRED_FLUSH        = 0x02,
+	BINDER_DEFERRED_RELEASE      = 0x04,
+};
+
 struct binder_proc {
 	struct hlist_node proc_node;
 	struct rb_root threads;
@@ -245,8 +249,11 @@
 	int pid;
 	struct vm_area_struct *vma;
 	struct task_struct *tsk;
+	struct files_struct *files;
+	struct hlist_node deferred_work_node;
+	int deferred_work;
 	void *buffer;
-	size_t user_buffer_offset;
+	ptrdiff_t user_buffer_offset;
 
 	struct list_head buffers;
 	struct rb_root free_buffers;
@@ -310,12 +317,14 @@
 	uid_t	sender_euid;
 };
 
+static void binder_defer_work(struct binder_proc *proc, int defer);
+
 /*
  * copied from get_unused_fd_flags
  */
-int task_get_unused_fd_flags(struct task_struct *tsk, int flags)
+int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
 {
-	struct files_struct *files = get_files_struct(tsk);
+	struct files_struct *files = proc->files;
 	int fd, error;
 	struct fdtable *fdt;
 	unsigned long rlim_cur;
@@ -337,9 +346,9 @@
 	 * will limit the total number of files that can be opened.
 	 */
 	rlim_cur = 0;
-	if (lock_task_sighand(tsk, &irqs)) {
-		rlim_cur = tsk->signal->rlim[RLIMIT_NOFILE].rlim_cur;
-		unlock_task_sighand(tsk, &irqs);
+	if (lock_task_sighand(proc->tsk, &irqs)) {
+		rlim_cur = proc->tsk->signal->rlim[RLIMIT_NOFILE].rlim_cur;
+		unlock_task_sighand(proc->tsk, &irqs);
 	}
 	if (fd >= rlim_cur)
 		goto out;
@@ -375,7 +384,6 @@
 
 out:
 	spin_unlock(&files->file_lock);
-	put_files_struct(files);
 	return error;
 }
 
@@ -383,9 +391,9 @@
  * copied from fd_install
  */
 static void task_fd_install(
-	struct task_struct *tsk, unsigned int fd, struct file *file)
+	struct binder_proc *proc, unsigned int fd, struct file *file)
 {
-	struct files_struct *files = get_files_struct(tsk);
+	struct files_struct *files = proc->files;
 	struct fdtable *fdt;
 
 	if (files == NULL)
@@ -396,7 +404,6 @@
 	BUG_ON(fdt->fd[fd] != NULL);
 	rcu_assign_pointer(fdt->fd[fd], file);
 	spin_unlock(&files->file_lock);
-	put_files_struct(files);
 }
 
 /*
@@ -413,10 +420,10 @@
 /*
  * copied from sys_close
  */
-static long task_close_fd(struct task_struct *tsk, unsigned int fd)
+static long task_close_fd(struct binder_proc *proc, unsigned int fd)
 {
 	struct file *filp;
-	struct files_struct *files = get_files_struct(tsk);
+	struct files_struct *files = proc->files;
 	struct fdtable *fdt;
 	int retval;
 
@@ -443,12 +450,10 @@
 		     retval == -ERESTART_RESTARTBLOCK))
 		retval = -EINTR;
 
-	put_files_struct(files);
 	return retval;
 
 out_unlock:
 	spin_unlock(&files->file_lock);
-	put_files_struct(files);
 	return -EBADF;
 }
 
@@ -618,7 +623,8 @@
 			       proc->pid, page_addr);
 			goto err_map_kernel_failed;
 		}
-		user_page_addr = (size_t)page_addr + proc->user_buffer_offset;
+		user_page_addr =
+			(uintptr_t)page_addr + proc->user_buffer_offset;
 		ret = vm_insert_page(vma, user_page_addr, page[0]);
 		if (ret) {
 			printk(KERN_ERR "binder: %d: binder_alloc_buf failed "
@@ -639,7 +645,7 @@
 	     page_addr -= PAGE_SIZE) {
 		page = &proc->pages[(page_addr - proc->buffer) / PAGE_SIZE];
 		if (vma)
-			zap_page_range(vma, (size_t)page_addr +
+			zap_page_range(vma, (uintptr_t)page_addr +
 				proc->user_buffer_offset, PAGE_SIZE, NULL);
 err_vm_insert_page_failed:
 		unmap_kernel_range((unsigned long)page_addr, PAGE_SIZE);
@@ -720,18 +726,19 @@
 		       "er %p size %zd\n", proc->pid, size, buffer, buffer_size);
 
 	has_page_addr =
-		(void *)(((size_t)buffer->data + buffer_size) & PAGE_MASK);
+		(void *)(((uintptr_t)buffer->data + buffer_size) & PAGE_MASK);
 	if (n == NULL) {
 		if (size + sizeof(struct binder_buffer) + 4 >= buffer_size)
 			buffer_size = size; /* no room for other buffers */
 		else
 			buffer_size = size + sizeof(struct binder_buffer);
 	}
-	end_page_addr = (void *)PAGE_ALIGN((size_t)buffer->data + buffer_size);
+	end_page_addr =
+		(void *)PAGE_ALIGN((uintptr_t)buffer->data + buffer_size);
 	if (end_page_addr > has_page_addr)
 		end_page_addr = has_page_addr;
 	if (binder_update_page_range(proc, 1,
-	    (void *)PAGE_ALIGN((size_t)buffer->data), end_page_addr, NULL))
+	    (void *)PAGE_ALIGN((uintptr_t)buffer->data), end_page_addr, NULL))
 		return NULL;
 
 	rb_erase(best_fit, &proc->free_buffers);
@@ -762,12 +769,12 @@
 
 static void *buffer_start_page(struct binder_buffer *buffer)
 {
-	return (void *)((size_t)buffer & PAGE_MASK);
+	return (void *)((uintptr_t)buffer & PAGE_MASK);
 }
 
 static void *buffer_end_page(struct binder_buffer *buffer)
 {
-	return (void *)(((size_t)(buffer + 1) - 1) & PAGE_MASK);
+	return (void *)(((uintptr_t)(buffer + 1) - 1) & PAGE_MASK);
 }
 
 static void binder_delete_free_buffer(
@@ -845,8 +852,8 @@
 	}
 
 	binder_update_page_range(proc, 0,
-		(void *)PAGE_ALIGN((size_t)buffer->data),
-		(void *)(((size_t)buffer->data + buffer_size) & PAGE_MASK),
+		(void *)PAGE_ALIGN((uintptr_t)buffer->data),
+		(void *)(((uintptr_t)buffer->data + buffer_size) & PAGE_MASK),
 		NULL);
 	rb_erase(&buffer->rb_node, &proc->allocated_buffers);
 	buffer->free = 1;
@@ -1345,6 +1352,17 @@
 		if (!(tr->flags & TF_ONE_WAY) && thread->transaction_stack) {
 			struct binder_transaction *tmp;
 			tmp = thread->transaction_stack;
+			if (tmp->to_thread != thread) {
+				binder_user_error("binder: %d:%d got new "
+					"transaction with bad transaction stack"
+					", transaction %d has target %d:%d\n",
+					proc->pid, thread->pid, tmp->debug_id,
+					tmp->to_proc ? tmp->to_proc->pid : 0,
+					tmp->to_thread ?
+					tmp->to_thread->pid : 0);
+				return_error = BR_FAILED_REPLY;
+				goto err_bad_call_stack;
+			}
 			while (tmp) {
 				if (tmp->from && tmp->from->proc == target_proc)
 					target_thread = tmp->from;
@@ -1434,10 +1452,19 @@
 		return_error = BR_FAILED_REPLY;
 		goto err_copy_data_failed;
 	}
+	if (!IS_ALIGNED(tr->offsets_size, sizeof(size_t))) {
+		binder_user_error("binder: %d:%d got transaction with "
+			"invalid offsets size, %zd\n",
+			proc->pid, thread->pid, tr->offsets_size);
+		return_error = BR_FAILED_REPLY;
+		goto err_bad_offset;
+	}
 	off_end = (void *)offp + tr->offsets_size;
 	for (; offp < off_end; offp++) {
 		struct flat_binder_object *fp;
-		if (*offp > t->buffer->data_size - sizeof(*fp)) {
+		if (*offp > t->buffer->data_size - sizeof(*fp) ||
+		    t->buffer->data_size < sizeof(*fp) ||
+		    !IS_ALIGNED(*offp, sizeof(void *))) {
 			binder_user_error("binder: %d:%d got transaction with "
 				"invalid offset, %zd\n",
 				proc->pid, thread->pid, *offp);
@@ -1544,13 +1571,13 @@
 				return_error = BR_FAILED_REPLY;
 				goto err_fget_failed;
 			}
-			target_fd = task_get_unused_fd_flags(target_proc->tsk, O_CLOEXEC);
+			target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);
 			if (target_fd < 0) {
 				fput(file);
 				return_error = BR_FAILED_REPLY;
 				goto err_get_unused_fd_failed;
 			}
-			task_fd_install(target_proc->tsk, target_fd, file);
+			task_fd_install(target_proc, target_fd, file);
 			if (binder_debug_mask & BINDER_DEBUG_TRANSACTION)
 				printk(KERN_INFO "        fd %ld -> %d\n", fp->handle, target_fd);
 			/* TODO: fput? */
@@ -1655,7 +1682,9 @@
 		off_end = (void *)offp + buffer->offsets_size;
 	for (; offp < off_end; offp++) {
 		struct flat_binder_object *fp;
-		if (*offp > buffer->data_size - sizeof(*fp)) {
+		if (*offp > buffer->data_size - sizeof(*fp) ||
+		    buffer->data_size < sizeof(*fp) ||
+		    !IS_ALIGNED(*offp, sizeof(void *))) {
 			printk(KERN_ERR "binder: transaction release %d bad"
 					"offset %zd, size %zd\n", debug_id, *offp, buffer->data_size);
 			continue;
@@ -1691,7 +1720,7 @@
 			if (binder_debug_mask & BINDER_DEBUG_TRANSACTION)
 				printk(KERN_INFO "        fd %ld\n", fp->handle);
 			if (failed_at)
-				task_close_fd(proc->tsk, fp->handle);
+				task_close_fd(proc, fp->handle);
 			break;
 
 		default:
@@ -2340,7 +2369,7 @@
 
 		tr.data_size = t->buffer->data_size;
 		tr.offsets_size = t->buffer->offsets_size;
-		tr.data.ptr.buffer = (void *)((void *)t->buffer->data + proc->user_buffer_offset);
+		tr.data.ptr.buffer = (void *)t->buffer->data + proc->user_buffer_offset;
 		tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t->buffer->data_size, sizeof(void *));
 
 		if (put_user(cmd, (uint32_t __user *)ptr))
@@ -2649,15 +2678,25 @@
 {
 	struct binder_proc *proc = vma->vm_private_data;
 	if (binder_debug_mask & BINDER_DEBUG_OPEN_CLOSE)
-		printk(KERN_INFO "binder: %d open vm area %lx-%lx (%ld K) vma %lx pagep %lx\n", proc->pid, vma->vm_start, vma->vm_end, (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags, pgprot_val(vma->vm_page_prot));
+		printk(KERN_INFO
+			"binder: %d open vm area %lx-%lx (%ld K) vma %lx pagep %lx\n",
+			proc->pid, vma->vm_start, vma->vm_end,
+			(vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags,
+			(unsigned long)pgprot_val(vma->vm_page_prot));
 	dump_stack();
 }
+
 static void binder_vma_close(struct vm_area_struct *vma)
 {
 	struct binder_proc *proc = vma->vm_private_data;
 	if (binder_debug_mask & BINDER_DEBUG_OPEN_CLOSE)
-		printk(KERN_INFO "binder: %d close vm area %lx-%lx (%ld K) vma %lx pagep %lx\n", proc->pid, vma->vm_start, vma->vm_end, (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags, pgprot_val(vma->vm_page_prot));
+		printk(KERN_INFO
+			"binder: %d close vm area %lx-%lx (%ld K) vma %lx pagep %lx\n",
+			proc->pid, vma->vm_start, vma->vm_end,
+			(vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags,
+			(unsigned long)pgprot_val(vma->vm_page_prot));
 	proc->vma = NULL;
+	binder_defer_work(proc, BINDER_DEFERRED_PUT_FILES);
 }
 
 static struct vm_operations_struct binder_vm_ops = {
@@ -2677,7 +2716,11 @@
 		vma->vm_end = vma->vm_start + SZ_4M;
 
 	if (binder_debug_mask & BINDER_DEBUG_OPEN_CLOSE)
-		printk(KERN_INFO "binder_mmap: %d %lx-%lx (%ld K) vma %lx pagep %lx\n", proc->pid, vma->vm_start, vma->vm_end, (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags, pgprot_val(vma->vm_page_prot));
+		printk(KERN_INFO
+			"binder_mmap: %d %lx-%lx (%ld K) vma %lx pagep %lx\n",
+			proc->pid, vma->vm_start, vma->vm_end,
+			(vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags,
+			(unsigned long)pgprot_val(vma->vm_page_prot));
 
 	if (vma->vm_flags & FORBIDDEN_MMAP_FLAGS) {
 		ret = -EPERM;
@@ -2686,6 +2729,12 @@
 	}
 	vma->vm_flags = (vma->vm_flags | VM_DONTCOPY) & ~VM_MAYWRITE;
 
+	if (proc->buffer) {
+		ret = -EBUSY;
+		failure_string = "already mapped";
+		goto err_already_mapped;
+	}
+
 	area = get_vm_area(vma->vm_end - vma->vm_start, VM_IOREMAP);
 	if (area == NULL) {
 		ret = -ENOMEM;
@@ -2693,7 +2742,7 @@
 		goto err_get_vm_area_failed;
 	}
 	proc->buffer = area->addr;
-	proc->user_buffer_offset = vma->vm_start - (size_t)proc->buffer;
+	proc->user_buffer_offset = vma->vm_start - (uintptr_t)proc->buffer;
 
 #ifdef CONFIG_CPU_CACHE_VIPT
 	if (cache_is_vipt_aliasing()) {
@@ -2726,6 +2775,7 @@
 	binder_insert_free_buffer(proc, buffer);
 	proc->free_async_space = proc->buffer_size / 2;
 	barrier();
+	proc->files = get_files_struct(current);
 	proc->vma = vma;
 
 	/*printk(KERN_INFO "binder_mmap: %d %lx-%lx maps %p\n", proc->pid, vma->vm_start, vma->vm_end, proc->buffer);*/
@@ -2733,10 +2783,12 @@
 
 err_alloc_small_buf_failed:
 	kfree(proc->pages);
+	proc->pages = NULL;
 err_alloc_pages_failed:
 	vfree(proc->buffer);
+	proc->buffer = NULL;
 err_get_vm_area_failed:
-	mutex_unlock(&binder_lock);
+err_already_mapped:
 err_bad_arg:
 	printk(KERN_ERR "binder_mmap: %d %lx-%lx %s failed %d\n", proc->pid, vma->vm_start, vma->vm_end, failure_string, ret);
 	return ret;
@@ -2768,6 +2820,7 @@
 	if (binder_proc_dir_entry_proc) {
 		char strbuf[11];
 		snprintf(strbuf, sizeof(strbuf), "%u", proc->pid);
+		remove_proc_entry(strbuf, binder_proc_dir_entry_proc);
 		create_proc_read_entry(strbuf, S_IRUGO, binder_proc_dir_entry_proc, binder_read_proc_proc, proc);
 	}
 
@@ -2776,11 +2829,17 @@
 
 static int binder_flush(struct file *filp, fl_owner_t id)
 {
-	struct rb_node *n;
 	struct binder_proc *proc = filp->private_data;
-	int wake_count = 0;
 
-	mutex_lock(&binder_lock);
+	binder_defer_work(proc, BINDER_DEFERRED_FLUSH);
+
+	return 0;
+}
+
+static void binder_deferred_flush(struct binder_proc *proc)
+{
+	struct rb_node *n;
+	int wake_count = 0;
 	for (n = rb_first(&proc->threads); n != NULL; n = rb_next(n)) {
 		struct binder_thread *thread = rb_entry(n, struct binder_thread, rb_node);
 		thread->looper |= BINDER_LOOPER_STATE_NEED_RETURN;
@@ -2790,28 +2849,35 @@
 		}
 	}
 	wake_up_interruptible_all(&proc->wait);
-	mutex_unlock(&binder_lock);
 
 	if (binder_debug_mask & BINDER_DEBUG_OPEN_CLOSE)
 		printk(KERN_INFO "binder_flush: %d woke %d threads\n", proc->pid, wake_count);
-
-	return 0;
 }
 
 static int binder_release(struct inode *nodp, struct file *filp)
 {
-	struct hlist_node *pos;
-	struct binder_transaction *t;
-	struct rb_node *n;
 	struct binder_proc *proc = filp->private_data;
-	int threads, nodes, incoming_refs, outgoing_refs, buffers, active_transactions, page_count;
-
 	if (binder_proc_dir_entry_proc) {
 		char strbuf[11];
 		snprintf(strbuf, sizeof(strbuf), "%u", proc->pid);
 		remove_proc_entry(strbuf, binder_proc_dir_entry_proc);
 	}
-	mutex_lock(&binder_lock);
+
+	binder_defer_work(proc, BINDER_DEFERRED_RELEASE);
+	
+	return 0;
+}
+
+static void binder_deferred_release(struct binder_proc *proc)
+{
+	struct hlist_node *pos;
+	struct binder_transaction *t;
+	struct rb_node *n;
+	int threads, nodes, incoming_refs, outgoing_refs, buffers, active_transactions, page_count;
+
+	BUG_ON(proc->vma);
+	BUG_ON(proc->files);
+
 	hlist_del(&proc->proc_node);
 	if (binder_context_mgr_node && binder_context_mgr_node->proc == proc) {
 		if (binder_debug_mask & BINDER_DEBUG_DEAD_BINDER)
@@ -2885,7 +2951,6 @@
 	}
 
 	binder_stats.obj_deleted[BINDER_STAT_PROC]++;
-	mutex_unlock(&binder_lock);
 
 	page_count = 0;
 	if (proc->pages) {
@@ -2909,7 +2974,57 @@
 		       proc->pid, threads, nodes, incoming_refs, outgoing_refs, active_transactions, buffers, page_count);
 
 	kfree(proc);
-	return 0;
+}
+
+static void binder_deferred_func(struct work_struct *work)
+{
+	struct binder_proc *proc;
+	struct files_struct *files;
+
+	int defer;
+	do {
+		mutex_lock(&binder_lock);
+		mutex_lock(&binder_deferred_lock);
+		if (!hlist_empty(&binder_deferred_list)) {
+			proc = hlist_entry(binder_deferred_list.first,
+					struct binder_proc, deferred_work_node);
+			hlist_del_init(&proc->deferred_work_node);
+			defer = proc->deferred_work;
+			proc->deferred_work = 0;
+		} else {
+			proc = NULL;
+			defer = 0;
+		}
+		mutex_unlock(&binder_deferred_lock);
+
+		files = NULL;
+		if (defer & BINDER_DEFERRED_PUT_FILES)
+			if ((files = proc->files))
+				proc->files = NULL;
+
+		if (defer & BINDER_DEFERRED_FLUSH)
+			binder_deferred_flush(proc);
+
+		if (defer & BINDER_DEFERRED_RELEASE)
+			binder_deferred_release(proc); /* frees proc */
+	
+		mutex_unlock(&binder_lock);
+		if (files)
+			put_files_struct(files);
+	} while (proc);
+}
+static DECLARE_WORK(binder_deferred_work, binder_deferred_func);
+
+static void binder_defer_work(struct binder_proc *proc, int defer)
+{
+	mutex_lock(&binder_deferred_lock);
+	proc->deferred_work |= defer;
+	if (hlist_unhashed(&proc->deferred_work_node)) {
+		hlist_add_head(&proc->deferred_work_node,
+				&binder_deferred_list);
+		schedule_work(&binder_deferred_work);
+	}
+	mutex_unlock(&binder_deferred_lock);
 }
 
 static char *print_binder_transaction(char *buf, char *end, const char *prefix, struct binder_transaction *t)
diff -Nur linux-2.6.29/drivers/staging/android/Kconfig linux-2.6.29-spica/drivers/staging/android/Kconfig
--- linux-2.6.29/drivers/staging/android/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/staging/android/Kconfig	2010-03-30 11:00:20.000000000 +0700
@@ -73,9 +73,13 @@
 	default 0
 	depends on ANDROID_RAM_CONSOLE_EARLY_INIT
 
+config ANDROID_TIMED_OUTPUT
+	bool "Timed output class driver"
+	default y
+
 config ANDROID_TIMED_GPIO
 	tristate "Android timed gpio driver"
-	depends on GENERIC_GPIO
+	depends on GENERIC_GPIO && ANDROID_TIMED_OUTPUT
 	default n
 
 config ANDROID_LOW_MEMORY_KILLER
diff -Nur linux-2.6.29/drivers/staging/android/logger.c linux-2.6.29-spica/drivers/staging/android/logger.c
--- linux-2.6.29/drivers/staging/android/logger.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/staging/android/logger.c	2010-05-06 12:42:45.684270633 +0700
@@ -27,6 +27,11 @@
 
 #include <asm/ioctls.h>
 
+#if 1
+/* [LINUSYS] added by khoonk for calculating boot-time on 20070508 */
+	unsigned char klog_buf[256];
+/* [LINUSYS] added by khoonk for calculating boot-time on 20070508 */
+#endif
 /*
  * struct logger_log - represents a specific log, such as 'main' or 'radio'
  *
@@ -279,6 +284,19 @@
 	size_t len;
 
 	len = min(count, log->size - log->w_off);
+
+#if 1 //LOGGER_PATCH_MMS_LOCKUP
+	if (count >= LOGGER_ENTRY_MAX_PAYLOAD) {
+		printk("\n");
+		printk("*****************************************************************\n");
+		printk("* LOGGER - ERROR  ( %s )\n", __FUNCTION__);
+		printk("* log:%s log->buffer:%x  log->w_off:%x  count:%x len:%x \n",
+		       log->misc.name, log->buffer, log->w_off, count, len);
+		printk("*****************************************************************\n");
+		return;
+	}
+#endif
+
 	memcpy(log->buffer + log->w_off, buf, len);
 
 	if (count != len)
@@ -308,6 +326,19 @@
 	if (count != len)
 		if (copy_from_user(log->buffer, buf + len, count - len))
 			return -EFAULT;
+#if 1
+/* [LINUSYS] added by khoonk for calculating boot-time on 20070508 */
+	memset(klog_buf,0,255);
+    if(strncmp(log->buffer + log->w_off, "!@", 2) == 0) {
+		if (count < 255) 
+			memcpy(klog_buf,log->buffer + log->w_off, count);	
+		else
+			memcpy(klog_buf,log->buffer + log->w_off, 255);	
+			
+		klog_buf[255]=0;
+	}
+/* [LINUSYS] added by khoonk for calculating boot-time on 20070508 */
+#endif
 
 	log->w_off = logger_offset(log->w_off + count);
 
@@ -371,6 +402,13 @@
 		ret += nr;
 	}
 
+#if 1
+/* [LINUSYS] added by khoonk for calculating boot-time on 20070508 */
+    if(strncmp(klog_buf, "!@", 2) == 0) {
+		printk("%s\n",klog_buf);
+	}
+/* [LINUSYS] added by khoonk for calculating boot-time on 20070508 */
+#endif
 	mutex_unlock(&log->mutex);
 
 	/* wake up any blocked readers */
@@ -553,9 +591,9 @@
 	.size = SIZE, \
 };
 
-DEFINE_LOGGER_DEVICE(log_main, LOGGER_LOG_MAIN, 64*1024)
+DEFINE_LOGGER_DEVICE(log_main, LOGGER_LOG_MAIN, 256*1024)
 DEFINE_LOGGER_DEVICE(log_events, LOGGER_LOG_EVENTS, 256*1024)
-DEFINE_LOGGER_DEVICE(log_radio, LOGGER_LOG_RADIO, 64*1024)
+DEFINE_LOGGER_DEVICE(log_radio, LOGGER_LOG_RADIO, 256*1024)
 
 static struct logger_log * get_log_from_minor(int minor)
 {
@@ -585,10 +623,29 @@
 	return 0;
 }
 
+/* RAM Dump Info */
+
+#include <linux/sec_log.h>
+
+static struct struct_plat_log_mark plat_log_mark = {
+	.special_mark_1 = (('*' << 24) | ('^' << 16) | ('^' << 8) | ('*' << 0)),
+	.special_mark_2 = (('I' << 24) | ('n' << 16) | ('f' << 8) | ('o' << 0)),
+	.special_mark_3 = (('H' << 24) | ('e' << 16) | ('r' << 8) | ('e' << 0)),
+	.special_mark_4 = (('p' << 24) | ('l' << 16) | ('o' << 8) | ('g' << 0)),
+	.p_main = 0, 
+	.p_radio = 0,
+	.p_events = 0, 
+};
+
 static int __init logger_init(void)
 {
 	int ret;
 
+	/* RAM Dump Info */
+	plat_log_mark.p_main = _buf_log_main; 
+	plat_log_mark.p_radio = _buf_log_radio;
+	plat_log_mark.p_events = _buf_log_events;
+
 	ret = init_log(&log_main);
 	if (unlikely(ret))
 		goto out;
@@ -605,3 +662,4 @@
 	return ret;
 }
 device_initcall(logger_init);
+
diff -Nur linux-2.6.29/drivers/staging/android/lowmemorykiller.c linux-2.6.29-spica/drivers/staging/android/lowmemorykiller.c
--- linux-2.6.29/drivers/staging/android/lowmemorykiller.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/staging/android/lowmemorykiller.c	2010-03-30 11:00:20.000000000 +0700
@@ -58,36 +58,48 @@
 	int min_adj = OOM_ADJUST_MAX + 1;
 	int selected_tasksize = 0;
 	int array_size = ARRAY_SIZE(lowmem_adj);
-	int other_free = global_page_state(NR_FREE_PAGES) + global_page_state(NR_FILE_PAGES);
+	int other_free = global_page_state(NR_FREE_PAGES);
+	int other_file = global_page_state(NR_FILE_PAGES);
 	if(lowmem_adj_size < array_size)
 		array_size = lowmem_adj_size;
 	if(lowmem_minfree_size < array_size)
 		array_size = lowmem_minfree_size;
 	for(i = 0; i < array_size; i++) {
-		if(other_free < lowmem_minfree[i]) {
+		if (other_free < lowmem_minfree[i] &&
+		    other_file < lowmem_minfree[i]) {
 			min_adj = lowmem_adj[i];
 			break;
 		}
 	}
 	if(nr_to_scan > 0)
-		lowmem_print(3, "lowmem_shrink %d, %x, ofree %d, ma %d\n", nr_to_scan, gfp_mask, other_free, min_adj);
+		lowmem_print(3, "lowmem_shrink %d, %x, ofree %d %d, ma %d\n", nr_to_scan, gfp_mask, other_free, other_file, min_adj);
+	rem = global_page_state(NR_ACTIVE_ANON) +
+		global_page_state(NR_ACTIVE_FILE) +
+		global_page_state(NR_INACTIVE_ANON) +
+		global_page_state(NR_INACTIVE_FILE);
+	if (nr_to_scan <= 0 || min_adj == OOM_ADJUST_MAX + 1) {
+		lowmem_print(5, "lowmem_shrink %d, %x, return %d\n", nr_to_scan, gfp_mask, rem);
+		return rem;
+	}
+
 	read_lock(&tasklist_lock);
 	for_each_process(p) {
-		if(p->oomkilladj >= 0 && p->mm) {
-			tasksize = get_mm_rss(p->mm);
-			if(nr_to_scan > 0 && tasksize > 0 && p->oomkilladj >= min_adj) {
-				if(selected == NULL ||
-				   p->oomkilladj > selected->oomkilladj ||
-				   (p->oomkilladj == selected->oomkilladj &&
-				    tasksize > selected_tasksize)) {
-					selected = p;
-					selected_tasksize = tasksize;
-					lowmem_print(2, "select %d (%s), adj %d, size %d, to kill\n",
-					             p->pid, p->comm, p->oomkilladj, tasksize);
-				}
-			}
-			rem += tasksize;
+		if (p->oomkilladj < min_adj || !p->mm)
+			continue;
+		tasksize = get_mm_rss(p->mm);
+		if (tasksize <= 0)
+			continue;
+		if (selected) {
+			if (p->oomkilladj < selected->oomkilladj)
+				continue;
+			if (p->oomkilladj == selected->oomkilladj &&
+			    tasksize <= selected_tasksize)
+				continue;
 		}
+		selected = p;
+		selected_tasksize = tasksize;
+		lowmem_print(2, "select %d (%s), adj %d, size %d, to kill\n",
+		             p->pid, p->comm, p->oomkilladj, tasksize);
 	}
 	if(selected != NULL) {
 		lowmem_print(1, "send sigkill to %d (%s), adj %d, size %d\n",
diff -Nur linux-2.6.29/drivers/staging/android/Makefile linux-2.6.29-spica/drivers/staging/android/Makefile
--- linux-2.6.29/drivers/staging/android/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/staging/android/Makefile	2010-03-30 11:00:20.000000000 +0700
@@ -1,5 +1,6 @@
 obj-$(CONFIG_ANDROID_BINDER_IPC)	+= binder.o
 obj-$(CONFIG_ANDROID_LOGGER)		+= logger.o
 obj-$(CONFIG_ANDROID_RAM_CONSOLE)	+= ram_console.o
+obj-$(CONFIG_ANDROID_TIMED_OUTPUT)	+= timed_output.o
 obj-$(CONFIG_ANDROID_TIMED_GPIO)	+= timed_gpio.o
 obj-$(CONFIG_ANDROID_LOW_MEMORY_KILLER)	+= lowmemorykiller.o
diff -Nur linux-2.6.29/drivers/staging/android/ram_console.c linux-2.6.29-spica/drivers/staging/android/ram_console.c
--- linux-2.6.29/drivers/staging/android/ram_console.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/staging/android/ram_console.c	2010-03-30 11:00:20.000000000 +0700
@@ -146,6 +146,14 @@
 	.index	= -1,
 };
 
+void ram_console_enable_console(int enabled)
+{
+	if (enabled)
+		ram_console.flags |= CON_ENABLED;
+	else
+		ram_console.flags &= ~CON_ENABLED;
+}
+
 static void __init
 ram_console_save_old(struct ram_console_buffer *buffer, char *dest)
 {
@@ -225,7 +233,7 @@
 		buffer_size - sizeof(struct ram_console_buffer);
 
 	if (ram_console_buffer_size > buffer_size) {
-		pr_err("ram_console: buffer %p, invalid size %d, datasize %d\n",
+		pr_err("ram_console: buffer %p, invalid size %zu, datasize %zu\n",
 		       buffer, buffer_size, ram_console_buffer_size);
 		return 0;
 	}
@@ -235,8 +243,8 @@
 						ECC_BLOCK_SIZE) + 1) * ECC_SIZE;
 
 	if (ram_console_buffer_size > buffer_size) {
-		pr_err("ram_console: buffer %p, invalid size %d, "
-		       "non-ecc datasize %d\n",
+		pr_err("ram_console: buffer %p, invalid size %zu, "
+		       "non-ecc datasize %zu\n",
 		       buffer, buffer_size, ram_console_buffer_size);
 		return 0;
 	}
@@ -322,7 +330,7 @@
 	}
 	buffer_size = res->end - res->start + 1;
 	start = res->start;
-	printk(KERN_INFO "ram_console: got buffer at %x, size %x\n",
+	printk(KERN_INFO "ram_console: got buffer at %zx, size %zx\n",
 	       start, buffer_size);
 	buffer = ioremap(res->start, buffer_size);
 	if (buffer == NULL) {
diff -Nur linux-2.6.29/drivers/staging/android/timed_gpio.c linux-2.6.29-spica/drivers/staging/android/timed_gpio.c
--- linux-2.6.29/drivers/staging/android/timed_gpio.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/staging/android/timed_gpio.c	2010-03-30 11:00:20.000000000 +0700
@@ -20,13 +20,12 @@
 #include <linux/err.h>
 #include <linux/gpio.h>
 
+#include "timed_output.h"
 #include "timed_gpio.h"
 
 
-static struct class *timed_gpio_class;
-
 struct timed_gpio_data {
-	struct device *dev;
+	struct timed_output_dev dev;
 	struct hrtimer timer;
 	spinlock_t lock;
 	unsigned 	gpio;
@@ -36,70 +35,62 @@
 
 static enum hrtimer_restart gpio_timer_func(struct hrtimer *timer)
 {
-	struct timed_gpio_data *gpio_data = container_of(timer, struct timed_gpio_data, timer);
+	struct timed_gpio_data *data =
+		container_of(timer, struct timed_gpio_data, timer);
 
-	gpio_direction_output(gpio_data->gpio, gpio_data->active_low ? 1 : 0);
+	gpio_direction_output(data->gpio, data->active_low ? 1 : 0);
 	return HRTIMER_NORESTART;
 }
 
-static ssize_t gpio_enable_show(struct device *dev, struct device_attribute *attr, char *buf)
+static int gpio_get_time(struct timed_output_dev *dev)
 {
-	struct timed_gpio_data *gpio_data = dev_get_drvdata(dev);
-	int remaining;
+	struct timed_gpio_data	*data =
+		container_of(dev, struct timed_gpio_data, dev);
 
-	if (hrtimer_active(&gpio_data->timer)) {
-		ktime_t r = hrtimer_get_remaining(&gpio_data->timer);
+	if (hrtimer_active(&data->timer)) {
+		ktime_t r = hrtimer_get_remaining(&data->timer);
 		struct timeval t = ktime_to_timeval(r);
-		remaining = t.tv_sec * 1000 + t.tv_usec / 1000;
+		return t.tv_sec * 1000 + t.tv_usec / 1000;
 	} else
-		remaining = 0;
-
-	return sprintf(buf, "%d\n", remaining);
+		return 0;
 }
 
-static ssize_t gpio_enable_store(
-		struct device *dev, struct device_attribute *attr,
-		const char *buf, size_t size)
+static void gpio_enable(struct timed_output_dev *dev, int value)
 {
-	struct timed_gpio_data *gpio_data = dev_get_drvdata(dev);
-	int value;
+	struct timed_gpio_data	*data =
+		container_of(dev, struct timed_gpio_data, dev);
 	unsigned long	flags;
 
-	sscanf(buf, "%d", &value);
-
-	spin_lock_irqsave(&gpio_data->lock, flags);
+	spin_lock_irqsave(&data->lock, flags);
 
 	/* cancel previous timer and set GPIO according to value */
-	hrtimer_cancel(&gpio_data->timer);
-	gpio_direction_output(gpio_data->gpio, gpio_data->active_low ? !value : !!value);
+	hrtimer_cancel(&data->timer);
+	gpio_direction_output(data->gpio, data->active_low ? !value : !!value);
 
 	if (value > 0) {
-		if (value > gpio_data->max_timeout)
-			value = gpio_data->max_timeout;
+		if (value > data->max_timeout)
+			value = data->max_timeout;
 
-		hrtimer_start(&gpio_data->timer,
-						ktime_set(value / 1000, (value % 1000) * 1000000),
-						HRTIMER_MODE_REL);
+		hrtimer_start(&data->timer,
+			ktime_set(value / 1000, (value % 1000) * 1000000),
+			HRTIMER_MODE_REL);
 	}
 
-	spin_unlock_irqrestore(&gpio_data->lock, flags);
-
-	return size;
+	spin_unlock_irqrestore(&data->lock, flags);
 }
 
-static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, gpio_enable_show, gpio_enable_store);
-
 static int timed_gpio_probe(struct platform_device *pdev)
 {
 	struct timed_gpio_platform_data *pdata = pdev->dev.platform_data;
 	struct timed_gpio *cur_gpio;
 	struct timed_gpio_data *gpio_data, *gpio_dat;
-	int i, ret = 0;
+	int i, j, ret = 0;
 
 	if (!pdata)
 		return -EBUSY;
 
-	gpio_data = kzalloc(sizeof(struct timed_gpio_data) * pdata->num_gpios, GFP_KERNEL);
+	gpio_data = kzalloc(sizeof(struct timed_gpio_data) * pdata->num_gpios,
+			GFP_KERNEL);
 	if (!gpio_data)
 		return -ENOMEM;
 
@@ -107,23 +98,26 @@
 		cur_gpio = &pdata->gpios[i];
 		gpio_dat = &gpio_data[i];
 
-		hrtimer_init(&gpio_dat->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		hrtimer_init(&gpio_dat->timer, CLOCK_MONOTONIC,
+				HRTIMER_MODE_REL);
 		gpio_dat->timer.function = gpio_timer_func;
 		spin_lock_init(&gpio_dat->lock);
 
+		gpio_dat->dev.name = cur_gpio->name;
+		gpio_dat->dev.get_time = gpio_get_time;
+		gpio_dat->dev.enable = gpio_enable;
+		ret = timed_output_dev_register(&gpio_dat->dev);
+		if (ret < 0) {
+			for (j = 0; j < i; j++)
+				timed_output_dev_unregister(&gpio_data[i].dev);
+			kfree(gpio_data);
+			return ret;
+		}
+
 		gpio_dat->gpio = cur_gpio->gpio;
 		gpio_dat->max_timeout = cur_gpio->max_timeout;
 		gpio_dat->active_low = cur_gpio->active_low;
 		gpio_direction_output(gpio_dat->gpio, gpio_dat->active_low);
-
-		gpio_dat->dev = device_create(timed_gpio_class, &pdev->dev, 0, "%s", cur_gpio->name);
-		if (unlikely(IS_ERR(gpio_dat->dev)))
-			return PTR_ERR(gpio_dat->dev);
-
-		dev_set_drvdata(gpio_dat->dev, gpio_dat);
-		ret = device_create_file(gpio_dat->dev, &dev_attr_enable);
-		if (ret)
-			return ret;
 	}
 
 	platform_set_drvdata(pdev, gpio_data);
@@ -137,10 +131,8 @@
 	struct timed_gpio_data *gpio_data = platform_get_drvdata(pdev);
 	int i;
 
-	for (i = 0; i < pdata->num_gpios; i++) {
-		device_remove_file(gpio_data[i].dev, &dev_attr_enable);
-		device_unregister(gpio_data[i].dev);
-	}
+	for (i = 0; i < pdata->num_gpios; i++)
+		timed_output_dev_unregister(&gpio_data[i].dev);
 
 	kfree(gpio_data);
 
@@ -151,22 +143,18 @@
 	.probe		= timed_gpio_probe,
 	.remove		= timed_gpio_remove,
 	.driver		= {
-		.name		= "timed-gpio",
+		.name		= TIMED_GPIO_NAME,
 		.owner		= THIS_MODULE,
 	},
 };
 
 static int __init timed_gpio_init(void)
 {
-	timed_gpio_class = class_create(THIS_MODULE, "timed_output");
-	if (IS_ERR(timed_gpio_class))
-		return PTR_ERR(timed_gpio_class);
 	return platform_driver_register(&timed_gpio_driver);
 }
 
 static void __exit timed_gpio_exit(void)
 {
-	class_destroy(timed_gpio_class);
 	platform_driver_unregister(&timed_gpio_driver);
 }
 
diff -Nur linux-2.6.29/drivers/staging/android/timed_gpio.h linux-2.6.29-spica/drivers/staging/android/timed_gpio.h
--- linux-2.6.29/drivers/staging/android/timed_gpio.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/staging/android/timed_gpio.h	2010-03-30 11:00:20.000000000 +0700
@@ -16,10 +16,12 @@
 #ifndef _LINUX_TIMED_GPIO_H
 #define _LINUX_TIMED_GPIO_H
 
+#define TIMED_GPIO_NAME "timed-gpio"
+
 struct timed_gpio {
 	const char *name;
 	unsigned 	gpio;
-	int     max_timeout;
+	int		max_timeout;
 	u8 		active_low;
 };
 
diff -Nur linux-2.6.29/drivers/staging/android/timed_output.c linux-2.6.29-spica/drivers/staging/android/timed_output.c
--- linux-2.6.29/drivers/staging/android/timed_output.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/staging/android/timed_output.c	2010-03-30 11:00:20.000000000 +0700
@@ -0,0 +1,121 @@
+/* drivers/misc/timed_output.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/err.h>
+
+#include "timed_output.h"
+
+static struct class *timed_output_class;
+static atomic_t device_count;
+
+static ssize_t enable_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct timed_output_dev *tdev = dev_get_drvdata(dev);
+	int remaining = tdev->get_time(tdev);
+
+	return sprintf(buf, "%d\n", remaining);
+}
+
+static ssize_t enable_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct timed_output_dev *tdev = dev_get_drvdata(dev);
+	int value;
+
+	sscanf(buf, "%d", &value);
+	tdev->enable(tdev, value);
+
+	return size;
+}
+
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, enable_show, enable_store);
+
+static int create_timed_output_class(void)
+{
+	if (!timed_output_class) {
+		timed_output_class = class_create(THIS_MODULE, "timed_output");
+		if (IS_ERR(timed_output_class))
+			return PTR_ERR(timed_output_class);
+		atomic_set(&device_count, 0);
+	}
+
+	return 0;
+}
+
+int timed_output_dev_register(struct timed_output_dev *tdev)
+{
+	int ret;
+
+	if (!tdev || !tdev->name || !tdev->enable || !tdev->get_time)
+		return -EINVAL;
+
+	ret = create_timed_output_class();
+	if (ret < 0)
+		return ret;
+
+	tdev->index = atomic_inc_return(&device_count);
+	tdev->dev = device_create(timed_output_class, NULL,
+		MKDEV(0, tdev->index), NULL, tdev->name);
+	if (IS_ERR(tdev->dev))
+		return PTR_ERR(tdev->dev);
+
+	ret = device_create_file(tdev->dev, &dev_attr_enable);
+	if (ret < 0)
+		goto err_create_file;
+
+	dev_set_drvdata(tdev->dev, tdev);
+	tdev->state = 0;
+	return 0;
+
+err_create_file:
+	device_destroy(timed_output_class, MKDEV(0, tdev->index));
+	printk(KERN_ERR "timed_output: Failed to register driver %s\n",
+			tdev->name);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(timed_output_dev_register);
+
+void timed_output_dev_unregister(struct timed_output_dev *tdev)
+{
+	device_remove_file(tdev->dev, &dev_attr_enable);
+	device_destroy(timed_output_class, MKDEV(0, tdev->index));
+	dev_set_drvdata(tdev->dev, NULL);
+}
+EXPORT_SYMBOL_GPL(timed_output_dev_unregister);
+
+static int __init timed_output_init(void)
+{
+	return create_timed_output_class();
+}
+
+static void __exit timed_output_exit(void)
+{
+	class_destroy(timed_output_class);
+}
+
+module_init(timed_output_init);
+module_exit(timed_output_exit);
+
+MODULE_AUTHOR("Mike Lockwood <lockwood@android.com>");
+MODULE_DESCRIPTION("timed output class driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/staging/android/timed_output.h linux-2.6.29-spica/drivers/staging/android/timed_output.h
--- linux-2.6.29/drivers/staging/android/timed_output.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/staging/android/timed_output.h	2010-03-30 11:00:20.000000000 +0700
@@ -0,0 +1,37 @@
+/* include/linux/timed_output.h
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#ifndef _LINUX_TIMED_OUTPUT_H
+#define _LINUX_TIMED_OUTPUT_H
+
+struct timed_output_dev {
+	const char	*name;
+
+	/* enable the output and set the timer */
+	void	(*enable)(struct timed_output_dev *sdev, int timeout);
+
+	/* returns the current number of milliseconds remaining on the timer */
+	int		(*get_time)(struct timed_output_dev *sdev);
+
+	/* private data */
+	struct device	*dev;
+	int		index;
+	int		state;
+};
+
+extern int timed_output_dev_register(struct timed_output_dev *dev);
+extern void timed_output_dev_unregister(struct timed_output_dev *dev);
+
+#endif
diff -Nur linux-2.6.29/drivers/switch/Kconfig linux-2.6.29-spica/drivers/switch/Kconfig
--- linux-2.6.29/drivers/switch/Kconfig	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/switch/Kconfig	2010-03-30 11:00:48.000000000 +0700
@@ -0,0 +1,15 @@
+menuconfig SWITCH
+	tristate "Switch class support"
+	help
+	  Say Y here to enable switch class support. This allows
+	  monitoring switches by userspace via sysfs and uevent.
+
+if SWITCH
+
+config SWITCH_GPIO
+	tristate "GPIO Swith support"
+	depends on GENERIC_GPIO
+	help
+	  Say Y here to enable GPIO based switch support.
+
+endif # SWITCH
diff -Nur linux-2.6.29/drivers/switch/Makefile linux-2.6.29-spica/drivers/switch/Makefile
--- linux-2.6.29/drivers/switch/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/switch/Makefile	2010-03-30 11:00:48.000000000 +0700
@@ -0,0 +1,4 @@
+# Switch Class Driver
+obj-$(CONFIG_SWITCH)		+= switch_class.o
+obj-$(CONFIG_SWITCH_GPIO)	+= switch_gpio.o
+
diff -Nur linux-2.6.29/drivers/switch/switch_class.c linux-2.6.29-spica/drivers/switch/switch_class.c
--- linux-2.6.29/drivers/switch/switch_class.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/switch/switch_class.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,246 @@
+/*
+ *  drivers/switch/switch_class.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/err.h>
+#include <linux/switch.h>
+#include <linux/input.h>
+
+#include <linux/wakelock.h>	//<<yamaia><system><JKCha>
+
+
+struct class *switch_class;
+static atomic_t device_count;
+
+static struct wake_lock switch_class_wake_lock;	//<<yamaia><system><JKCha>
+static int switch_class_wake_lock_inited = 0; //<<yamaia><system><jswoo>
+
+static ssize_t state_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct switch_dev *sdev = (struct switch_dev *)
+		dev_get_drvdata(dev);
+
+	if (sdev->print_state) {
+		int ret = sdev->print_state(sdev, buf);
+		if (ret >= 0)
+			return ret;
+	}
+	return sprintf(buf, "%d\n", sdev->state);
+}
+
+static ssize_t name_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct switch_dev *sdev = (struct switch_dev *)
+		dev_get_drvdata(dev);
+
+	if (sdev->print_name) {
+		int ret = sdev->print_name(sdev, buf);
+		if (ret >= 0)
+			return ret;
+	}
+	return sprintf(buf, "%s\n", sdev->name);
+}
+
+//kvpz: support added for earjack & send end key simulation from sysfs state store command
+extern void sec_headset_sendend_report_key(void);
+
+//kvpz added
+static size_t state_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t size)
+{
+		int val;	
+		printk("kvpz %s\n",__func__);
+      	struct switch_dev *sdev = (struct switch_dev *)
+		dev_get_drvdata(dev);
+		
+		sscanf(buf,"%d",&val);
+		printk("val = %d\n",val);
+		
+		
+		if(strcmp(sdev->name,"h2w") == 0)
+		{
+			printk("kvpz h2w\n");
+			printk("kvpz: h2w event to be simulated\n");
+			if(val == 0)
+				{
+				printk("kvpz: set switch state to 0\n");
+				switch_set_state(sdev,0);
+				}
+			if(val == 1)
+				{
+				printk("kvpz: set switch state to 1\n");
+				switch_set_state(sdev,1);	
+				}
+				
+		}
+		
+		else if(strcmp(sdev->name,"send_end") == 0)
+		{
+			printk("kvpz send_end\n");
+			if(val == 0)
+				{
+				printk("kvpz: simulate send_end release\n");
+				switch_set_state(sdev, 0);
+				}
+			if(val == 1)
+				{
+				printk("kvpz: simulate send_end press\n");
+				switch_set_state(sdev, 1);
+				//input_report_key(hi->input, KEYCODE_SENDEND, 1);
+				//input_sync(hi->input);
+				sec_headset_sendend_report_key();
+				}	
+		
+		}
+
+}
+//kvpz added
+
+static DEVICE_ATTR(state, S_IRUGO | S_IWUSR, state_show, state_store);
+static DEVICE_ATTR(name, S_IRUGO | S_IWUSR, name_show, NULL);
+
+void switch_set_state(struct switch_dev *sdev, int state)
+{
+	char name_buf[120];
+	char state_buf[120];
+	char *prop_buf;
+	char *envp[3];
+	int env_offset = 0;
+	int length;
+
+	if (sdev->state != state) {
+
+		if( switch_class_wake_lock_inited != 0)					//<<yamaia><system><jswoo>
+		wake_lock_timeout(&switch_class_wake_lock, 2 * HZ);	//<<yamaia><system><JKCha>
+		
+		sdev->state = state;
+
+		prop_buf = (char *)get_zeroed_page(GFP_KERNEL);
+		if (prop_buf) {
+			length = name_show(sdev->dev, NULL, prop_buf);
+			if (length > 0) {
+				if (prop_buf[length - 1] == '\n')
+					prop_buf[length - 1] = 0;
+				snprintf(name_buf, sizeof(name_buf),
+					"SWITCH_NAME=%s", prop_buf);
+				envp[env_offset++] = name_buf;
+			}
+			length = state_show(sdev->dev, NULL, prop_buf);
+			if (length > 0) {
+				if (prop_buf[length - 1] == '\n')
+					prop_buf[length - 1] = 0;
+				snprintf(state_buf, sizeof(state_buf),
+					"SWITCH_STATE=%s", prop_buf);
+				envp[env_offset++] = state_buf;
+			}
+			envp[env_offset] = NULL;
+			kobject_uevent_env(&sdev->dev->kobj, KOBJ_CHANGE, envp);
+			free_page((unsigned long)prop_buf);
+		} else {
+			printk(KERN_ERR "out of memory in switch_set_state\n");
+			kobject_uevent(&sdev->dev->kobj, KOBJ_CHANGE);
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(switch_set_state);
+
+static int create_switch_class(void)
+{
+	if (!switch_class) {
+		switch_class = class_create(THIS_MODULE, "switch");
+		if (IS_ERR(switch_class))
+			return PTR_ERR(switch_class);
+		atomic_set(&device_count, 0);
+	}
+
+	return 0;
+}
+
+int switch_dev_register(struct switch_dev *sdev)
+{
+	int ret;
+
+	if (!switch_class) {
+		ret = create_switch_class();
+		if (ret < 0)
+			return ret;
+	}
+
+	sdev->index = atomic_inc_return(&device_count);
+	sdev->dev = device_create(switch_class, NULL,
+		MKDEV(0, sdev->index), NULL, sdev->name);
+	if (IS_ERR(sdev->dev))
+		return PTR_ERR(sdev->dev);
+
+	ret = device_create_file(sdev->dev, &dev_attr_state);
+	if (ret < 0)
+		goto err_create_file_1;
+	ret = device_create_file(sdev->dev, &dev_attr_name);
+	if (ret < 0)
+		goto err_create_file_2;
+
+	dev_set_drvdata(sdev->dev, sdev);
+	sdev->state = 0;
+	return 0;
+
+err_create_file_2:
+	device_remove_file(sdev->dev, &dev_attr_state);
+err_create_file_1:
+	device_destroy(switch_class, MKDEV(0, sdev->index));
+	printk(KERN_ERR "switch: Failed to register driver %s\n", sdev->name);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(switch_dev_register);
+
+void switch_dev_unregister(struct switch_dev *sdev)
+{
+	device_remove_file(sdev->dev, &dev_attr_name);
+	device_remove_file(sdev->dev, &dev_attr_state);
+	device_destroy(switch_class, MKDEV(0, sdev->index));
+	dev_set_drvdata(sdev->dev, NULL);
+}
+EXPORT_SYMBOL_GPL(switch_dev_unregister);
+
+
+
+static int __init switch_class_init(void)
+{
+	//<<yamaia><system><JKCha>
+	wake_lock_init(&switch_class_wake_lock, WAKE_LOCK_SUSPEND,"sec_switch");
+	//<<yamaia><system><jswoo>
+	switch_class_wake_lock_inited =1;
+	return create_switch_class();
+}
+
+static void __exit switch_class_exit(void)
+{
+	class_destroy(switch_class);
+}
+
+module_init(switch_class_init);
+module_exit(switch_class_exit);
+
+MODULE_AUTHOR("Mike Lockwood <lockwood@android.com>");
+MODULE_DESCRIPTION("Switch class driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/switch/switch_gpio.c linux-2.6.29-spica/drivers/switch/switch_gpio.c
--- linux-2.6.29/drivers/switch/switch_gpio.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/switch/switch_gpio.c	2010-03-30 11:00:48.000000000 +0700
@@ -0,0 +1,171 @@
+/*
+ *  drivers/switch/switch_gpio.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/switch.h>
+#include <linux/workqueue.h>
+#include <linux/gpio.h>
+
+struct gpio_switch_data {
+	struct switch_dev sdev;
+	unsigned gpio;
+	const char *name_on;
+	const char *name_off;
+	const char *state_on;
+	const char *state_off;
+	int irq;
+	struct work_struct work;
+};
+
+static void gpio_switch_work(struct work_struct *work)
+{
+	int state;
+	struct gpio_switch_data	*data =
+		container_of(work, struct gpio_switch_data, work);
+
+	state = gpio_get_value(data->gpio);
+	switch_set_state(&data->sdev, state);
+}
+
+static irqreturn_t gpio_irq_handler(int irq, void *dev_id)
+{
+	struct gpio_switch_data *switch_data =
+	    (struct gpio_switch_data *)dev_id;
+
+	schedule_work(&switch_data->work);
+	return IRQ_HANDLED;
+}
+
+static ssize_t switch_gpio_print_state(struct switch_dev *sdev, char *buf)
+{
+	struct gpio_switch_data	*switch_data =
+		container_of(sdev, struct gpio_switch_data, sdev);
+	const char *state;
+	if (switch_get_state(sdev))
+		state = switch_data->state_on;
+	else
+		state = switch_data->state_off;
+
+	if (state)
+		return sprintf(buf, "%s\n", state);
+	return -1;
+}
+
+static int gpio_switch_probe(struct platform_device *pdev)
+{
+	struct gpio_switch_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_switch_data *switch_data;
+	int ret = 0;
+
+	if (!pdata)
+		return -EBUSY;
+
+	switch_data = kzalloc(sizeof(struct gpio_switch_data), GFP_KERNEL);
+	if (!switch_data)
+		return -ENOMEM;
+
+	switch_data->sdev.name = pdata->name;
+	switch_data->gpio = pdata->gpio;
+	switch_data->name_on = pdata->name_on;
+	switch_data->name_off = pdata->name_off;
+	switch_data->state_on = pdata->state_on;
+	switch_data->state_off = pdata->state_off;
+	switch_data->sdev.print_state = switch_gpio_print_state;
+
+    ret = switch_dev_register(&switch_data->sdev);
+	if (ret < 0)
+		goto err_switch_dev_register;
+
+	ret = gpio_request(switch_data->gpio, pdev->name);
+	if (ret < 0)
+		goto err_request_gpio;
+
+	ret = gpio_direction_input(switch_data->gpio);
+	if (ret < 0)
+		goto err_set_gpio_input;
+
+	INIT_WORK(&switch_data->work, gpio_switch_work);
+
+	switch_data->irq = gpio_to_irq(switch_data->gpio);
+	if (switch_data->irq < 0) {
+		ret = switch_data->irq;
+		goto err_detect_irq_num_failed;
+	}
+
+	ret = request_irq(switch_data->irq, gpio_irq_handler,
+			  IRQF_TRIGGER_LOW, pdev->name, switch_data);
+	if (ret < 0)
+		goto err_request_irq;
+
+	/* Perform initial detection */
+	gpio_switch_work(&switch_data->work);
+
+	return 0;
+
+err_request_irq:
+err_detect_irq_num_failed:
+err_set_gpio_input:
+	gpio_free(switch_data->gpio);
+err_request_gpio:
+    switch_dev_unregister(&switch_data->sdev);
+err_switch_dev_register:
+	kfree(switch_data);
+
+	return ret;
+}
+
+static int __devexit gpio_switch_remove(struct platform_device *pdev)
+{
+	struct gpio_switch_data *switch_data = platform_get_drvdata(pdev);
+
+	cancel_work_sync(&switch_data->work);
+	gpio_free(switch_data->gpio);
+    switch_dev_unregister(&switch_data->sdev);
+	kfree(switch_data);
+
+	return 0;
+}
+
+static struct platform_driver gpio_switch_driver = {
+	.probe		= gpio_switch_probe,
+	.remove		= __devexit_p(gpio_switch_remove),
+	.driver		= {
+		.name	= "switch-gpio",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init gpio_switch_init(void)
+{
+	return platform_driver_register(&gpio_switch_driver);
+}
+
+static void __exit gpio_switch_exit(void)
+{
+	platform_driver_unregister(&gpio_switch_driver);
+}
+
+module_init(gpio_switch_init);
+module_exit(gpio_switch_exit);
+
+MODULE_AUTHOR("Mike Lockwood <lockwood@android.com>");
+MODULE_DESCRIPTION("GPIO Switch driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/drivers/usb/gadget/adb_ums_acm.c linux-2.6.29-spica/drivers/usb/gadget/adb_ums_acm.c
--- linux-2.6.29/drivers/usb/gadget/adb_ums_acm.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/adb_ums_acm.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,459 @@
+/*
+ * Gadget Driver for Android, with ADB and UMS and ACM support
+ *
+ * Copyright (C) 2009 Samsung Electronics, Seung-Soo Yang
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/utsname.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+
+#include <linux/usb/android.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/composite.h>
+#include <linux/usb/gadget.h>
+
+#include "u_serial.h"
+#include "f_mass_storage.h"
+#include "f_adb.h"
+#include "f_acm.h"
+
+#include "gadget_chips.h"
+
+/*
+ * Kbuild is not very cooperative with respect to linking separately
+ * compiled library objects into one module.  So for now we won't use
+ * separate compilation ... ensuring init/exit sections work to shrink
+ * the runtime footprint, and giving us at least some parts of what
+ * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
+ */
+#include "usbstring.c"
+#include "config.c"
+#include "epautoconf.c"
+#include "composite.c"
+
+MODULE_AUTHOR("SeungSoo Yange");
+MODULE_DESCRIPTION("Android Composite USB Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+static const char longname[] = "Gadget Android";
+
+#define DRIVER_DESC		"Android Composite USB"
+#define DRIVER_VERSION	__DATE__
+
+/* Default vendor and product IDs, overridden by platform data */
+#define VENDOR_ID		0x04e8	/* Samsung */
+#define ADB_PRODUCT_ID 	0x681C	/* S3C6410 Swallowtail*/
+#define PRODUCT_ID		0x681D
+
+/* 
+ * Originally, adbd will enable adb function at booting 
+ * if the value of persist.service.adb.enable is 1
+ * ADB_ENABLE_AT_BOOT intends to enable adb function 
+ * in case of no enabling by adbd or improper RFS
+ */
+#define ADB_ENABLE_AT_BOOT	0
+
+extern void get_usb_serial(char *usb_serial_number);
+
+
+struct android_dev {
+	struct usb_gadget *gadget;
+	struct usb_composite_dev *cdev;
+
+	int product_id;
+	int adb_product_id;
+	int version;
+
+	int adb_enabled;
+	int nluns;
+};
+
+static atomic_t adb_enable_excl;
+static struct android_dev *_android_dev;
+
+/* string IDs are assigned dynamically */
+
+#define STRING_MANUFACTURER_IDX	0
+#define STRING_PRODUCT_IDX		1
+#define STRING_SERIAL_IDX		2
+
+/* String Table */
+static struct usb_string strings_dev[] = {
+	/* These dummy values should be overridden by platform data */
+	[STRING_MANUFACTURER_IDX].s = "Samsung Electronics",
+	[STRING_PRODUCT_IDX].s = "GT-I5700",
+	[STRING_SERIAL_IDX].s = "S3C6410_Android",
+	{  }			/* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language	= 0x0409,	/* en-us */
+	.strings	= strings_dev,
+};
+
+static struct usb_gadget_strings *dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+static struct usb_device_descriptor device_desc = {
+	.bLength              = sizeof(device_desc),
+	.bDescriptorType      = USB_DT_DEVICE,
+	.bcdUSB               = __constant_cpu_to_le16(0x0200),
+	.bDeviceClass		  = USB_CLASS_MASS_STORAGE,
+	.bDeviceSubClass	  = 0x06,//US_SC_SCSI,
+	.bDeviceProtocol	  = 0x50,//US_PR_BULK,
+	.idVendor             = __constant_cpu_to_le16(VENDOR_ID),
+	.idProduct            = __constant_cpu_to_le16(PRODUCT_ID),
+	.bcdDevice            = __constant_cpu_to_le16(0x0400),
+	.bNumConfigurations   = 1,
+};
+
+static struct usb_otg_descriptor otg_descriptor = {
+	.bLength =		sizeof otg_descriptor,
+	.bDescriptorType =	USB_DT_OTG,
+
+	/* REVISIT SRP-only hardware is possible, although
+	 * it would not be called "OTG" ...
+	 */
+	.bmAttributes =		USB_OTG_SRP | USB_OTG_HNP,
+};
+
+static const struct usb_descriptor_header *otg_desc[] = {
+	(struct usb_descriptor_header *) &otg_descriptor,
+	NULL,
+};
+
+void android_usb_set_connected(int connected)
+{
+	if (_android_dev && _android_dev->cdev && _android_dev->cdev->gadget) {
+		if (connected)
+			usb_gadget_connect(_android_dev->cdev->gadget);
+		else
+			usb_gadget_disconnect(_android_dev->cdev->gadget);
+	}
+}
+
+#if ADB_ENABLE_AT_BOOT
+static void enable_adb(struct android_dev *dev, int enable);
+#endif
+
+static int __init android_bind_config(struct usb_configuration *c)
+{
+	struct android_dev *dev = _android_dev;
+	int ret;
+
+	//ret = acm_bind_config(c, 0);
+	ret = acm_function_add(dev->cdev, c);
+	if (ret) {
+		printk("[%s] Fail to acm_function_add()\n", __func__);
+		return ret;
+	}
+	ret = mass_storage_function_add(dev->cdev, c, dev->nluns);
+	if (ret) {
+		printk("[%s] Fail to mass_storage_function_add()\n", __func__);
+		return ret;
+	}
+	ret = adb_function_add(dev->cdev, c);
+	if (ret) {
+		printk("[%s] Fail to adb_function_add()\n", __func__);
+		return ret;
+	}
+
+#if ADB_ENABLE_AT_BOOT
+	printk("[%s] Enabling adb function at booting\n", __func__);
+	enable_adb(dev, 1);
+#endif
+
+	return ret;
+}
+
+#define	ANDROID_DEBUG_CONFIG_STRING "ACM + UMS + ADB (Debugging mode)"
+#define	ANDROID_NO_DEBUG_CONFIG_STRING "UMS Only (Not debugging mode)"
+
+static struct usb_configuration android_config  = {
+	.label		= ANDROID_NO_DEBUG_CONFIG_STRING,
+	.bind		= android_bind_config,
+	.bConfigurationValue = 1,
+	.bmAttributes	= USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
+	.bMaxPower	= 0x30, /*  x2 = 160ma */
+};
+
+static int __init android_bind(struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+	struct usb_gadget	*gadget = cdev->gadget;
+	int			gcnum;
+	int			id;
+	int			ret;
+	char usb_serial_number[13] = {0,};
+
+//	printk(KERN_INFO "android_bind\n");
+
+	/* Allocate string descriptor numbers ... note that string
+	 * contents can be overridden by the composite_dev glue.
+	 */
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_MANUFACTURER_IDX].id = id;
+	device_desc.iManufacturer = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_PRODUCT_IDX].id = id;
+	device_desc.iProduct = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+
+	get_usb_serial(usb_serial_number);
+	strings_dev[STRING_SERIAL_IDX].id = id;
+
+	if( (usb_serial_number[0] + 
+		 usb_serial_number[1] + 
+		 usb_serial_number[2]) != 0 )
+	strcpy((char *)(strings_dev[STRING_SERIAL_IDX].s), usb_serial_number);
+	printk("[ADB_UMS_ACM] string_dev = %s \n",strings_dev[STRING_SERIAL_IDX].s);
+
+	device_desc.iSerialNumber = id;
+
+	gcnum = usb_gadget_controller_number(gadget);
+	if (gcnum >= 0)
+		device_desc.bcdDevice = cpu_to_le16(0x0200 + gcnum);
+	else {
+		/* gadget zero is so simple (for now, no altsettings) that
+		 * it SHOULD NOT have problems with bulk-capable hardware.
+		 * so just warn about unrcognized controllers -- don't panic.
+		 *
+		 * things like configuration and altsetting numbering
+		 * can need hardware-specific attention though.
+		 */
+		pr_warning("%s: controller '%s' not recognized\n",
+			longname, gadget->name);
+		device_desc.bcdDevice = __constant_cpu_to_le16(0x9999);
+	}
+	
+	if (gadget_is_otg(cdev->gadget)) 
+		android_config.descriptors = otg_desc;
+	
+#if USBCV_CH9_REMOTE_WAKE_UP_TEST 
+	if (gadget->ops->wakeup)
+		android_config.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+#endif
+
+	/* register our configuration */
+	ret = usb_add_config(cdev, &android_config);
+	if (ret) {
+		printk(KERN_ERR "usb_add_config failed\n");
+		return ret;
+	}
+
+	usb_gadget_set_selfpowered(gadget);
+	dev->cdev = cdev;
+	
+	INFO(cdev, "%s, version: " DRIVER_VERSION "\n", DRIVER_DESC);
+
+	return 0;
+}
+
+/*
+	Google gadget doesn't support module type building
+static int __exit android_unbind(struct usb_composite_dev *cdev)
+{
+	gserial_cleanup();
+	return 0;
+}
+*/
+
+static struct usb_composite_driver android_usb_driver = {
+	//driver.name refered by S3C-UDC for setting config_gadget_driver
+	.name		= "android_adb_ums_acm",
+	.dev		= &device_desc,
+	.strings	= dev_strings,
+	.bind		= android_bind,
+//	.unbind 	= __exit_p(android_unbind),
+};
+
+static void enable_adb(struct android_dev *dev, int enable)
+{
+	if (enable != dev->adb_enabled) {
+		dev->adb_enabled = enable;
+		adb_function_enable(enable);
+		acm_function_enable(enable);
+
+		/* set product ID to the appropriate value */
+		if (enable)
+		{
+			device_desc.idProduct =
+				__constant_cpu_to_le16(dev->adb_product_id);
+			device_desc.bDeviceClass	  = USB_CLASS_COMM;
+			device_desc.bDeviceSubClass	  = 0x00;
+			device_desc.bDeviceProtocol	  = 0x00;
+			android_config.label = ANDROID_DEBUG_CONFIG_STRING;
+		}
+		else
+		{
+			device_desc.idProduct =
+				__constant_cpu_to_le16(dev->product_id);
+			device_desc.bDeviceClass	  = USB_CLASS_MASS_STORAGE;
+			device_desc.bDeviceSubClass	  = 0x06;//US_SC_SCSI;
+			device_desc.bDeviceProtocol	  = 0x50;//US_PR_BULK;
+			android_config.label = ANDROID_NO_DEBUG_CONFIG_STRING;
+		}
+
+		/* Host get the following dev->cdev->desc as Device Description */
+		if (dev->cdev)
+		{
+			dev->cdev->desc.idProduct = device_desc.idProduct;
+			dev->cdev->desc.bDeviceClass = device_desc.bDeviceClass;
+			dev->cdev->desc.bDeviceSubClass = device_desc.bDeviceSubClass;
+			dev->cdev->desc.bDeviceProtocol = device_desc.bDeviceProtocol;
+		}
+
+#if 0
+		/* force reenumeration */
+		if (dev->cdev && dev->cdev->gadget &&
+				//the following means that usb device already enumerated by host
+				dev->cdev->gadget->speed != USB_SPEED_UNKNOWN) {
+#else
+/*
+	for reenumeration in case of booting-up connected with host
+	because if connected, host don't enumerate 
+*/
+		if (dev->cdev && dev->cdev->gadget ) {
+#endif			
+			usb_gadget_disconnect(dev->cdev->gadget);
+			msleep(5);
+			usb_gadget_connect(dev->cdev->gadget);
+		}
+	}
+}
+
+static int adb_enable_open(struct inode *ip, struct file *fp)
+{
+	if (atomic_inc_return(&adb_enable_excl) != 1) {
+		atomic_dec(&adb_enable_excl);
+		return -EBUSY;
+	}
+	enable_adb(_android_dev, 1);
+
+	return 0;
+}
+
+static int adb_enable_release(struct inode *ip, struct file *fp)
+{
+	enable_adb(_android_dev, 0);
+	atomic_dec(&adb_enable_excl);
+	return 0;
+}
+
+static const struct file_operations adb_enable_fops = {
+	.owner =   THIS_MODULE,
+	.open =    adb_enable_open,
+	.release = adb_enable_release,
+};
+
+static struct miscdevice adb_enable_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "android_adb_enable",
+	.fops = &adb_enable_fops,
+};
+
+static int __init android_probe(struct platform_device *pdev)
+{
+	struct android_usb_platform_data *pdata = pdev->dev.platform_data;
+	struct android_dev *dev = _android_dev;
+
+	if (pdata) {
+		if (pdata->vendor_id)
+			device_desc.idVendor =
+				__constant_cpu_to_le16(pdata->vendor_id);
+		if (pdata->product_id) {
+			dev->product_id = pdata->product_id;
+			device_desc.idProduct =
+				__constant_cpu_to_le16(pdata->product_id);
+		}
+		if (pdata->adb_product_id)
+			dev->adb_product_id = pdata->adb_product_id;
+		if (pdata->version)
+			dev->version = pdata->version;
+
+		if (pdata->product_name)
+			strings_dev[STRING_PRODUCT_IDX].s = pdata->product_name;
+		if (pdata->manufacturer_name)
+			strings_dev[STRING_MANUFACTURER_IDX].s =
+					pdata->manufacturer_name;
+		if (pdata->serial_number)
+			strings_dev[STRING_SERIAL_IDX].s = pdata->serial_number;
+		dev->nluns = pdata->nluns;
+	}
+
+	return 0;
+}
+
+static struct platform_driver android_platform_driver = {
+	.driver = { .name = "S3C6410 Android USB", },
+	.probe = android_probe,
+};
+
+static int __init init(void)
+{
+	struct android_dev *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	/* set default values, which should be overridden by platform data */
+	dev->product_id = PRODUCT_ID;
+	dev->adb_product_id = ADB_PRODUCT_ID;
+	_android_dev = dev;
+
+	ret = platform_driver_register(&android_platform_driver);
+	if (ret)
+		return ret;
+	ret = misc_register(&adb_enable_device);
+	if (ret) {
+		platform_driver_unregister(&android_platform_driver);
+		return ret;
+	}
+	ret = usb_composite_register(&android_usb_driver);
+	if (ret) {
+		misc_deregister(&adb_enable_device);
+		platform_driver_unregister(&android_platform_driver);
+	}
+	return ret;
+}
+module_init(init);
+
+static void __exit cleanup(void)
+{
+	usb_composite_unregister(&android_usb_driver);
+	misc_deregister(&adb_enable_device);
+	platform_driver_unregister(&android_platform_driver);
+	kfree(_android_dev);
+	_android_dev = NULL;
+}
+module_exit(cleanup);
diff -Nur linux-2.6.29/drivers/usb/gadget/android.c linux-2.6.29-spica/drivers/usb/gadget/android.c
--- linux-2.6.29/drivers/usb/gadget/android.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/android.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,452 @@
+/*
+ * Gadget Driver for Android, with ADB and UMS support
+ *
+ * Copyright (C) 2009 Samsung Electronics
+ * Author: Seung-Soo Yang <ss1.yang@samsung.com>
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/utsname.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+
+#include <linux/usb/android.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/composite.h>
+#include <linux/usb/gadget.h>
+
+#include "f_mass_storage.h"
+#include "f_adb.h"
+
+#include "gadget_chips.h"
+
+/*
+ * Kbuild is not very cooperative with respect to linking separately
+ * compiled library objects into one module.  So for now we won't use
+ * separate compilation ... ensuring init/exit sections work to shrink
+ * the runtime footprint, and giving us at least some parts of what
+ * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
+ */
+#include "usbstring.c"
+#include "config.c"
+#include "epautoconf.c"
+#include "composite.c"
+
+MODULE_AUTHOR("SeungSoo Yange");
+MODULE_DESCRIPTION("Android Composite USB Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+static const char longname[] = "Gadget Android";
+
+#define DRIVER_DESC		"Android Composite USB"
+#define DRIVER_VERSION	__DATE__
+
+/* Default vendor and product IDs, overridden by platform data */
+#define VENDOR_ID		0x18D1
+#define PRODUCT_ID		0x0001
+#define ADB_PRODUCT_ID	0x0002
+
+/* 
+ * Originally, adbd will enable adb function at booting 
+ * if the value of persist.service.adb.enable is 1
+ * ADB_ENABLE_AT_BOOT intends to enable adb function 
+ * in case of no enabling by adbd or improper RFS
+ */
+#define ADB_ENABLE_AT_BOOT	0
+
+extern void get_usb_serial(char *usb_serial_number);
+
+
+struct android_dev {
+	struct usb_gadget *gadget;
+	struct usb_composite_dev *cdev;
+
+	int product_id;
+	int adb_product_id;
+	int version;
+
+	int adb_enabled;
+	int nluns;
+};
+
+static atomic_t adb_enable_excl;
+static struct android_dev *_android_dev;
+
+/* string IDs are assigned dynamically */
+
+#define STRING_MANUFACTURER_IDX		0
+#define STRING_PRODUCT_IDX		1
+#define STRING_SERIAL_IDX		2
+
+/* String Table */
+static struct usb_string strings_dev[] = {
+	/* These dummy values should be overridden by platform data */
+	[STRING_MANUFACTURER_IDX].s = "SAMSUNG",
+	[STRING_PRODUCT_IDX].s = "SAMSUNG_Android",
+	[STRING_SERIAL_IDX].s = "S3C6410_Android",
+	{  }			/* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language	= 0x0409,	/* en-us */
+	.strings	= strings_dev,
+};
+
+static struct usb_gadget_strings *dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+static struct usb_device_descriptor device_desc = {
+	.bLength              = sizeof(device_desc),
+	.bDescriptorType      = USB_DT_DEVICE,
+	.bcdUSB               = __constant_cpu_to_le16(0x0200),
+	.bDeviceClass		  = USB_CLASS_MASS_STORAGE,
+	.bDeviceSubClass	  = 0x06,//US_SC_SCSI,
+	.bDeviceProtocol	  = 0x50,//US_PR_BULK,
+	.idVendor             = __constant_cpu_to_le16(VENDOR_ID),
+	.idProduct            = __constant_cpu_to_le16(PRODUCT_ID),
+	.bcdDevice            = __constant_cpu_to_le16(0xffff),
+	.bNumConfigurations   = 1,
+};
+
+static struct usb_otg_descriptor otg_descriptor = {
+	.bLength =		sizeof otg_descriptor,
+	.bDescriptorType =	USB_DT_OTG,
+
+	/* REVISIT SRP-only hardware is possible, although
+	 * it would not be called "OTG" ...
+	 */
+	.bmAttributes =		USB_OTG_SRP | USB_OTG_HNP,
+};
+
+static const struct usb_descriptor_header *otg_desc[] = {
+	(struct usb_descriptor_header *) &otg_descriptor,
+	NULL,
+};
+
+void android_usb_set_connected(int connected)
+{
+	if (_android_dev && _android_dev->cdev && _android_dev->cdev->gadget) {
+		if (connected)
+			usb_gadget_connect(_android_dev->cdev->gadget);
+		else
+			usb_gadget_disconnect(_android_dev->cdev->gadget);
+	}
+}
+
+#if ADB_ENABLE_AT_BOOT
+static void enable_adb(struct android_dev *dev, int enable);
+#endif
+
+static int __init android_bind_config(struct usb_configuration *c)
+{
+	struct android_dev *dev = _android_dev;
+	int ret;
+
+	ret = mass_storage_function_add(dev->cdev, c, dev->nluns);
+	if (ret) {
+		printk("[%s] Fail to mass_storage_function_add()\n", __func__);
+		return ret;
+	}
+	ret = adb_function_add(dev->cdev, c);
+	if (ret) {
+		printk("[%s] Fail to adb_function_add()\n", __func__);
+		return ret;
+	}
+
+#if ADB_ENABLE_AT_BOOT
+	printk("[%s] Enabling adb function at booting\n", __func__);
+	enable_adb(dev, 1);
+#endif
+
+		return ret;
+}
+
+#define	ANDROID_DEBUG_CONFIG_STRING "UMS + ADB (Debugging mode)"
+#define	ANDROID_NO_DEBUG_CONFIG_STRING "UMS Only (Not debugging mode)"
+
+static struct usb_configuration android_config  = {
+	.label		= ANDROID_NO_DEBUG_CONFIG_STRING,
+	.bind		= android_bind_config,
+	.bConfigurationValue = 1,
+	.bmAttributes	= USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
+	.bMaxPower	= 0x30, /*  x2 = 160ma */
+};
+
+static int __init android_bind(struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+	struct usb_gadget	*gadget = cdev->gadget;
+	int			gcnum;
+	int			id;
+	int			ret;
+	char usb_serial_number[13] = {0,};
+
+//	printk(KERN_INFO "android_bind\n");
+
+	/* Allocate string descriptor numbers ... note that string
+	 * contents can be overridden by the composite_dev glue.
+	 */
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_MANUFACTURER_IDX].id = id;
+	device_desc.iManufacturer = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_PRODUCT_IDX].id = id;
+	device_desc.iProduct = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+
+	get_usb_serial(usb_serial_number);
+	strings_dev[STRING_SERIAL_IDX].id = id;
+
+	if( (usb_serial_number[0] + 
+		 usb_serial_number[1] + 
+		 usb_serial_number[2]) != 0 )
+	strcpy((char *)(strings_dev[STRING_SERIAL_IDX].s), usb_serial_number);
+	printk("[ADB_UMS] string_dev = %s \n",strings_dev[STRING_SERIAL_IDX].s);
+
+	device_desc.iSerialNumber = id;
+
+	gcnum = usb_gadget_controller_number(gadget);
+	if (gcnum >= 0)
+		device_desc.bcdDevice = cpu_to_le16(0x0200 + gcnum);
+	else {
+		/* gadget zero is so simple (for now, no altsettings) that
+		 * it SHOULD NOT have problems with bulk-capable hardware.
+		 * so just warn about unrcognized controllers -- don't panic.
+		 *
+		 * things like configuration and altsetting numbering
+		 * can need hardware-specific attention though.
+		 */
+		pr_warning("%s: controller '%s' not recognized\n",
+			longname, gadget->name);
+		device_desc.bcdDevice = __constant_cpu_to_le16(0x9999);
+	}
+
+	if (gadget_is_otg(cdev->gadget)) 
+		android_config.descriptors = otg_desc;
+	
+#if USBCV_CH9_REMOTE_WAKE_UP_TEST 
+	if (gadget->ops->wakeup)
+		android_config.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+#endif
+
+	/* register our configuration */
+	ret = usb_add_config(cdev, &android_config);
+	if (ret) {
+		printk(KERN_ERR "usb_add_config failed\n");
+	        return ret;
+	}
+
+	usb_gadget_set_selfpowered(gadget);
+	dev->cdev = cdev;
+
+	INFO(cdev, "%s, version: " DRIVER_VERSION "\n", DRIVER_DESC);
+
+	return 0;
+}
+
+/*
+	Google gadget doesn't support module type building
+static int __exit android_unbind(struct usb_composite_dev *cdev)
+{
+	gserial_cleanup();
+	return 0;
+}
+*/
+
+static struct usb_composite_driver android_usb_driver = {
+	.name		= "android_usb",
+	.dev		= &device_desc,
+	.strings	= dev_strings,
+	.bind		= android_bind,
+//	.unbind 	= __exit_p(android_unbind),
+};
+
+static void enable_adb(struct android_dev *dev, int enable)
+{
+	if (enable != dev->adb_enabled) {
+		dev->adb_enabled = enable;
+		adb_function_enable(enable);
+
+		/* set product ID to the appropriate value */
+		if (enable)
+		{
+			device_desc.idProduct =
+				__constant_cpu_to_le16(dev->adb_product_id);
+			device_desc.bDeviceClass	  = USB_CLASS_PER_INTERFACE;
+			device_desc.bDeviceSubClass	  = 0x00;
+			device_desc.bDeviceProtocol	  = 0x00;
+			android_config.label = ANDROID_DEBUG_CONFIG_STRING;
+		}
+		else
+		{
+			device_desc.idProduct =
+				__constant_cpu_to_le16(dev->product_id);
+			device_desc.bDeviceClass	  = USB_CLASS_MASS_STORAGE;
+			device_desc.bDeviceSubClass	  = 0x06;//US_SC_SCSI;
+			device_desc.bDeviceProtocol	  = 0x50;//US_PR_BULK;
+			android_config.label = ANDROID_NO_DEBUG_CONFIG_STRING;
+		}
+
+		/* Host get the following dev->cdev->desc as Device Description */
+		if (dev->cdev)
+		{
+			dev->cdev->desc.idProduct = device_desc.idProduct;
+			dev->cdev->desc.bDeviceClass = device_desc.bDeviceClass;
+			dev->cdev->desc.bDeviceSubClass = device_desc.bDeviceSubClass;
+			dev->cdev->desc.bDeviceProtocol = device_desc.bDeviceProtocol;
+		}
+
+#if 0
+		/* force reenumeration */
+		if (dev->cdev && dev->cdev->gadget &&
+				//the following means that usb device already enumerated by host
+				dev->cdev->gadget->speed != USB_SPEED_UNKNOWN) {
+#else
+/*
+	for reenumeration in case of booting-up connected with host
+	because if connected, host don't enumerate 
+*/
+		if (dev->cdev && dev->cdev->gadget ) {
+#endif			
+			usb_gadget_disconnect(dev->cdev->gadget);
+			msleep(5);
+			usb_gadget_connect(dev->cdev->gadget);
+		}
+	}
+}
+
+static int adb_enable_open(struct inode *ip, struct file *fp)
+{
+	if (atomic_inc_return(&adb_enable_excl) != 1) {
+		atomic_dec(&adb_enable_excl);
+		return -EBUSY;
+	}
+	enable_adb(_android_dev, 1);
+
+	return 0;
+}
+
+static int adb_enable_release(struct inode *ip, struct file *fp)
+{
+	enable_adb(_android_dev, 0);
+	atomic_dec(&adb_enable_excl);
+	return 0;
+}
+
+static const struct file_operations adb_enable_fops = {
+	.owner =   THIS_MODULE,
+	.open =    adb_enable_open,
+	.release = adb_enable_release,
+};
+
+static struct miscdevice adb_enable_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "android_adb_enable",
+	.fops = &adb_enable_fops,
+};
+
+static int __init android_probe(struct platform_device *pdev)
+{
+	struct android_usb_platform_data *pdata = pdev->dev.platform_data;
+	struct android_dev *dev = _android_dev;
+
+	if (pdata) {
+		if (pdata->vendor_id)
+			device_desc.idVendor =
+				__constant_cpu_to_le16(pdata->vendor_id);
+		if (pdata->product_id) {
+			dev->product_id = pdata->product_id;
+			device_desc.idProduct =
+				__constant_cpu_to_le16(pdata->product_id);
+		}
+		if (pdata->adb_product_id)
+			dev->adb_product_id = pdata->adb_product_id;
+		if (pdata->version)
+			dev->version = pdata->version;
+
+		if (pdata->product_name)
+			strings_dev[STRING_PRODUCT_IDX].s = pdata->product_name;
+		if (pdata->manufacturer_name)
+			strings_dev[STRING_MANUFACTURER_IDX].s =
+					pdata->manufacturer_name;
+		if (pdata->serial_number)
+			strings_dev[STRING_SERIAL_IDX].s = pdata->serial_number;
+		dev->nluns = pdata->nluns;
+	}
+
+	return 0;
+}
+
+static struct platform_driver android_platform_driver = {
+	.driver = { .name = "S3C6410 Android USB", },
+	.probe = android_probe,
+};
+
+static int __init init(void)
+{
+	struct android_dev *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	/* set default values, which should be overridden by platform data */
+	dev->product_id = PRODUCT_ID;
+	dev->adb_product_id = ADB_PRODUCT_ID;
+	_android_dev = dev;
+
+	ret = platform_driver_register(&android_platform_driver);
+	if (ret)
+		return ret;
+	ret = misc_register(&adb_enable_device);
+	if (ret) {
+		platform_driver_unregister(&android_platform_driver);
+		return ret;
+	}
+	ret = usb_composite_register(&android_usb_driver);
+	if (ret) {
+		misc_deregister(&adb_enable_device);
+		platform_driver_unregister(&android_platform_driver);
+	}
+	return ret;
+}
+module_init(init);
+
+static void __exit cleanup(void)
+{
+	usb_composite_unregister(&android_usb_driver);
+	misc_deregister(&adb_enable_device);
+	platform_driver_unregister(&android_platform_driver);
+	kfree(_android_dev);
+	_android_dev = NULL;
+}
+module_exit(cleanup);
diff -Nur linux-2.6.29/drivers/usb/gadget/composite.c linux-2.6.29-spica/drivers/usb/gadget/composite.c
--- linux-2.6.29/drivers/usb/gadget/composite.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/usb/gadget/composite.c	2010-05-06 12:42:45.644210217 +0700
@@ -27,7 +27,6 @@
 
 #include <linux/usb/composite.h>
 
-
 /*
  * The code in this file is utility code, used to build a gadget driver
  * from one or more "function" drivers, one or more "configuration"
@@ -235,6 +234,7 @@
 	int				len = USB_BUFSIZ - USB_DT_CONFIG_SIZE;
 	struct usb_function		*f;
 	int				status;
+	int				interfaceCount = 0;
 
 	/* write the config descriptor */
 	c = buf;
@@ -265,8 +265,16 @@
 			descriptors = f->hs_descriptors;
 		else
 			descriptors = f->descriptors;
-		if (!descriptors)
+		if (!descriptors || descriptors[0] == NULL) {
+			for (; f != config->interface[interfaceCount];) {
+				interfaceCount++;
+				c->bNumInterfaces--;
+			}
 			continue;
+		}
+		for (; f != config->interface[interfaceCount];)
+			interfaceCount++;
+
 		status = usb_descriptor_fillbuf(next, len,
 			(const struct usb_descriptor_header **) descriptors);
 		if (status < 0)
@@ -419,7 +427,8 @@
 		struct usb_function	*f = c->interface[tmp];
 
 		if (!f)
-			break;
+			//break;
+			continue;
 
 		result = f->set_alt(f, tmp, 0);
 		if (result < 0) {
@@ -755,11 +764,11 @@
 	case USB_REQ_GET_CONFIGURATION:
 		if (ctrl->bRequestType != USB_DIR_IN)
 			goto unknown;
-		if (cdev->config)
+		if (cdev->config) {
 			*(u8 *)req->buf = cdev->config->bConfigurationValue;
-		else
+			value = min(w_length, (u16) 1);
+		} else
 			*(u8 *)req->buf = 0;
-		value = min(w_length, (u16) 1);
 		break;
 
 	/* function drivers must handle get/set altsetting; if there's
@@ -809,11 +818,25 @@
 		 */
 		if ((ctrl->bRequestType & USB_RECIP_MASK)
 				== USB_RECIP_INTERFACE) {
-			f = cdev->config->interface[intf];
-			if (f && f->setup)
-				value = f->setup(f, ctrl);
-			else
+			if (cdev->config == NULL)
+				return value;
+/* 
+ * by ss1.yang check w_index is proper value 
+ * because of USBCV - MSC Test - MSC ClassRequestTest_DeviceConfigured
+ * Issuing Get Max LUN request with invalid wIndex parameter
+ */
+//			if (cdev->config && w_index < MAX_CONFIG_INTERFACES) {				
+			if (cdev->config && w_index < cdev->config->next_interface_id) {
+				f = cdev->config->interface[intf];
+				if (f && f->setup)
+					value = f->setup(f, ctrl);
+				else
+					f = NULL;
+			}
+			else {
+				printk("\n invalid w_index [interface %d]\n", w_index);
 				f = NULL;
+			}
 		}
 		if (value < 0 && !f) {
 			struct usb_configuration	*c;
@@ -822,7 +845,6 @@
 			if (c && c->setup)
 				value = c->setup(c, ctrl);
 		}
-
 		goto done;
 	}
 
diff -Nur linux-2.6.29/drivers/usb/gadget/epautoconf.c linux-2.6.29-spica/drivers/usb/gadget/epautoconf.c
--- linux-2.6.29/drivers/usb/gadget/epautoconf.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/usb/gadget/epautoconf.c	2010-05-06 12:42:45.644210217 +0700
@@ -265,6 +265,42 @@
 				return ep;
 		}
 
+	} else if (gadget_is_s3c(gadget)) {
+		if (USB_ENDPOINT_XFER_INT == type) {
+			/* single buffering is enough */
+			ep = find_ep (gadget, "ep3-int");
+			if (ep && ep_matches (gadget, ep, desc))
+				return ep;
+			ep = find_ep (gadget, "ep6-int");
+			if (ep && ep_matches (gadget, ep, desc))
+				return ep;
+			ep = find_ep (gadget, "ep9-int");
+			if (ep && ep_matches (gadget, ep, desc))
+				return ep;
+		} else if (USB_ENDPOINT_XFER_BULK == type
+				&& (USB_DIR_IN & desc->bEndpointAddress)) {
+			ep = find_ep (gadget, "ep2-bulk");
+			if (ep && ep_matches (gadget, ep, desc))
+				return ep;		
+			ep = find_ep (gadget, "ep5-bulk");
+			if (ep && ep_matches (gadget, ep, desc))
+				return ep;
+			ep = find_ep (gadget, "ep8-bulk");
+			if (ep && ep_matches (gadget, ep, desc))
+				return ep;
+		}
+		else if (USB_ENDPOINT_XFER_BULK == type
+				&& !(USB_DIR_IN & desc->bEndpointAddress)) {
+			ep = find_ep (gadget, "ep1-bulk");
+			if (ep && ep_matches (gadget, ep, desc))
+				return ep;	
+			ep = find_ep (gadget, "ep4-bulk");
+			if (ep && ep_matches (gadget, ep, desc))
+				return ep;
+			ep = find_ep (gadget, "ep7-bulk");
+			if (ep && ep_matches (gadget, ep, desc))
+				return ep;
+		}
 	} else if (gadget_is_sh (gadget) && USB_ENDPOINT_XFER_INT == type) {
 		/* single buffering is enough; maybe 8 byte fifo is too */
 		ep = find_ep (gadget, "ep3in-bulk");
diff -Nur linux-2.6.29/drivers/usb/gadget/f_acm.c linux-2.6.29-spica/drivers/usb/gadget/f_acm.c
--- linux-2.6.29/drivers/usb/gadget/f_acm.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/usb/gadget/f_acm.c	2010-05-06 12:42:45.644210217 +0700
@@ -19,6 +19,12 @@
 #include "gadget_chips.h"
 
 
+#ifdef CONFIG_USB_DUN_SUPPORT
+extern int modem_register(void * data);
+extern void modem_unregister(void);
+extern void notify_control_line_state(u32 value);
+#endif
+
 /*
  * This CDC ACM function support just wraps control functions and
  * notifications around the generic serial-over-usb code.
@@ -80,6 +86,8 @@
 #define ACM_CTRL_DCD		(1 << 0)
 };
 
+static struct f_acm *_f_acm;
+
 static inline struct f_acm *func_to_acm(struct usb_function *f)
 {
 	return container_of(f, struct f_acm, port.func);
@@ -99,7 +107,7 @@
 
 /* interface and class descriptors: */
 
-static struct usb_interface_descriptor acm_control_interface_desc __initdata = {
+static struct usb_interface_descriptor acm_control_interface_desc = {
 	.bLength =		USB_DT_INTERFACE_SIZE,
 	.bDescriptorType =	USB_DT_INTERFACE,
 	/* .bInterfaceNumber = DYNAMIC */
@@ -110,7 +118,7 @@
 	/* .iInterface = DYNAMIC */
 };
 
-static struct usb_interface_descriptor acm_data_interface_desc __initdata = {
+static struct usb_interface_descriptor acm_data_interface_desc = {
 	.bLength =		USB_DT_INTERFACE_SIZE,
 	.bDescriptorType =	USB_DT_INTERFACE,
 	/* .bInterfaceNumber = DYNAMIC */
@@ -121,7 +129,7 @@
 	/* .iInterface = DYNAMIC */
 };
 
-static struct usb_cdc_header_desc acm_header_desc __initdata = {
+static struct usb_cdc_header_desc acm_header_desc = {
 	.bLength =		sizeof(acm_header_desc),
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_HEADER_TYPE,
@@ -129,7 +137,7 @@
 };
 
 static struct usb_cdc_call_mgmt_descriptor
-acm_call_mgmt_descriptor __initdata = {
+acm_call_mgmt_descriptor = {
 	.bLength =		sizeof(acm_call_mgmt_descriptor),
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_CALL_MANAGEMENT_TYPE,
@@ -137,14 +145,14 @@
 	/* .bDataInterface = DYNAMIC */
 };
 
-static struct usb_cdc_acm_descriptor acm_descriptor __initdata = {
+static struct usb_cdc_acm_descriptor acm_descriptor = {
 	.bLength =		sizeof(acm_descriptor),
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_ACM_TYPE,
 	.bmCapabilities =	USB_CDC_CAP_LINE,
 };
 
-static struct usb_cdc_union_desc acm_union_desc __initdata = {
+static struct usb_cdc_union_desc acm_union_desc = {
 	.bLength =		sizeof(acm_union_desc),
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_UNION_TYPE,
@@ -154,7 +162,7 @@
 
 /* full speed support: */
 
-static struct usb_endpoint_descriptor acm_fs_notify_desc __initdata = {
+static struct usb_endpoint_descriptor acm_fs_notify_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_IN,
@@ -163,21 +171,21 @@
 	.bInterval =		1 << GS_LOG2_NOTIFY_INTERVAL,
 };
 
-static struct usb_endpoint_descriptor acm_fs_in_desc __initdata = {
+static struct usb_endpoint_descriptor acm_fs_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 };
 
-static struct usb_endpoint_descriptor acm_fs_out_desc __initdata = {
+static struct usb_endpoint_descriptor acm_fs_out_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_OUT,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 };
 
-static struct usb_descriptor_header *acm_fs_function[] __initdata = {
+static struct usb_descriptor_header *acm_fs_function[] = {
 	(struct usb_descriptor_header *) &acm_control_interface_desc,
 	(struct usb_descriptor_header *) &acm_header_desc,
 	(struct usb_descriptor_header *) &acm_call_mgmt_descriptor,
@@ -190,9 +198,14 @@
 	NULL,
 };
 
+/* used when acm function is disabled */
+static struct usb_descriptor_header *null_acm_descs[] = {
+	NULL,
+};
+
 /* high speed support: */
 
-static struct usb_endpoint_descriptor acm_hs_notify_desc __initdata = {
+static struct usb_endpoint_descriptor acm_hs_notify_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_IN,
@@ -201,21 +214,21 @@
 	.bInterval =		GS_LOG2_NOTIFY_INTERVAL+4,
 };
 
-static struct usb_endpoint_descriptor acm_hs_in_desc __initdata = {
+static struct usb_endpoint_descriptor acm_hs_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 	.wMaxPacketSize =	__constant_cpu_to_le16(512),
 };
 
-static struct usb_endpoint_descriptor acm_hs_out_desc __initdata = {
+static struct usb_endpoint_descriptor acm_hs_out_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 	.wMaxPacketSize =	__constant_cpu_to_le16(512),
 };
 
-static struct usb_descriptor_header *acm_hs_function[] __initdata = {
+static struct usb_descriptor_header *acm_hs_function[] = {
 	(struct usb_descriptor_header *) &acm_control_interface_desc,
 	(struct usb_descriptor_header *) &acm_header_desc,
 	(struct usb_descriptor_header *) &acm_call_mgmt_descriptor,
@@ -345,6 +358,10 @@
 		 * that bit, we should return to that no-flow state.
 		 */
 		acm->port_handshake_bits = w_value;
+
+#ifdef CONFIG_USB_DUN_SUPPORT
+		notify_control_line_state((unsigned long)w_value);
+#endif
 		break;
 
 	default:
@@ -410,6 +427,28 @@
 	return 0;
 }
 
+void acm_function_enable(int enable)
+{
+	struct f_acm	*acm = _f_acm;
+
+	if(&acm->port)
+	{
+		printk("[%s] acm_function => (%s)\n", __func__, 
+			enable ? "enabled" : "disabled");
+
+		if (enable) {
+			acm->port.func.descriptors = acm_fs_function;
+			acm->port.func.hs_descriptors = acm_hs_function;
+		} else {
+			acm->port.func.descriptors = null_acm_descs;
+			acm->port.func.hs_descriptors = null_acm_descs;
+		}
+	}
+	else
+		printk("[%s] acm->port does not exist\n", __func__);
+}
+
+
 static void acm_disable(struct usb_function *f)
 {
 	struct f_acm	*acm = func_to_acm(f);
@@ -515,26 +554,47 @@
 		acm_notify_serial_state(acm);
 }
 
+
+#ifdef CONFIG_USB_DUN_SUPPORT
+void acm_notify(void * dev, u16 state)
+{	
+	struct f_acm	*acm = (struct f_acm *)dev;
+
+	acm->serial_state = state;
+	acm_notify_serial_state(acm);
+}
+#endif
+
+
 /* connect == the TTY link is open */
 
 static void acm_connect(struct gserial *port)
 {
+#ifndef CONFIG_USB_DUN_SUPPORT 
 	struct f_acm		*acm = port_to_acm(port);
 
 	acm->serial_state |= ACM_CTRL_DSR | ACM_CTRL_DCD;
 	acm_notify_serial_state(acm);
+#else
+	printk("acm_connected\n");
+#endif
 }
 
 static void acm_disconnect(struct gserial *port)
 {
+#ifndef CONFIG_USB_DUN_SUPPORT 
 	struct f_acm		*acm = port_to_acm(port);
 
 	acm->serial_state &= ~(ACM_CTRL_DSR | ACM_CTRL_DCD);
 	acm_notify_serial_state(acm);
+#else
+	printk("acm_disconnected\n");
+#endif
 }
 
 static int acm_send_break(struct gserial *port, int duration)
 {
+#ifndef CONFIG_USB_DUN_SUPPORT 
 	struct f_acm		*acm = port_to_acm(port);
 	u16			state;
 
@@ -545,6 +605,10 @@
 
 	acm->serial_state = state;
 	return acm_notify_serial_state(acm);
+#else
+	printk("acm_send_break\n");
+	return 0;
+#endif
 }
 
 /*-------------------------------------------------------------------------*/
@@ -647,6 +711,17 @@
 			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
 			acm->port.in->name, acm->port.out->name,
 			acm->notify->name);
+
+#ifdef CONFIG_USB_DUN_SUPPORT
+	modem_register(acm);
+#endif
+
+#ifdef CONFIG_USB_ANDROID_ADB_UMS_ACM
+//added by ss1
+	f->descriptors = null_acm_descs;
+	f->hs_descriptors = null_acm_descs;
+#endif
+
 	return 0;
 
 fail:
@@ -676,6 +751,13 @@
 	usb_free_descriptors(f->descriptors);
 	gs_free_req(acm->notify, acm->notify_req);
 	kfree(acm);
+	
+	gserial_disconnect(&acm->port);
+	gserial_cleanup();
+
+#ifdef CONFIG_USB_DUN_SUPPORT
+	modem_unregister();
+#endif
 }
 
 /* Some controllers can't support CDC ACM ... */
@@ -749,15 +831,31 @@
 
 	acm->port.func.name = "acm";
 	acm->port.func.strings = acm_strings;
-	/* descriptors are per-instance copies */
+	
+	/* descriptors are per-instance copies 
+		acm_function_enable() fill it changed by ss1.yang */
+	acm->port.func.descriptors = null_acm_descs;
+	acm->port.func.hs_descriptors = null_acm_descs;
+
 	acm->port.func.bind = acm_bind;
 	acm->port.func.unbind = acm_unbind;
 	acm->port.func.set_alt = acm_set_alt;
 	acm->port.func.setup = acm_setup;
 	acm->port.func.disable = acm_disable;
 
+	_f_acm = acm;
+
 	status = usb_add_function(c, &acm->port.func);
 	if (status)
 		kfree(acm);
 	return status;
 }
+
+int __init acm_function_add(struct usb_composite_dev *cdev,
+	struct usb_configuration *c)
+{
+	int ret = acm_bind_config(c, 0);
+	if (ret == 0)
+		gserial_setup(c->cdev->gadget, 1);
+	return ret;
+}
\      
diff -Nur linux-2.6.29/drivers/usb/gadget/f_acm.h linux-2.6.29-spica/drivers/usb/gadget/f_acm.h
--- linux-2.6.29/drivers/usb/gadget/f_acm.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/f_acm.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,24 @@
+/*
+ * Gadget Driver for Android, with ADB and UMS and ACM support
+ *
+ * Copyright (C) 2009 Samsung Electronics, Seung-Soo Yang
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __F_ACM_H
+#define __F_ACM_H
+
+int acm_function_add(struct usb_composite_dev *cdev,
+	struct usb_configuration *c);
+void acm_function_enable(int enable);
+
+#endif /* __F_ACM_H */
diff -Nur linux-2.6.29/drivers/usb/gadget/f_adb.c linux-2.6.29-spica/drivers/usb/gadget/f_adb.c
--- linux-2.6.29/drivers/usb/gadget/f_adb.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/f_adb.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,729 @@
+/*
+ * Gadget Driver for Android ADB
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/composite.h>
+#include <linux/usb/gadget.h>
+
+#include "f_adb.h"
+
+#define BULK_BUFFER_SIZE           4096
+
+/* number of rx and tx requests to allocate */
+#define RX_REQ_MAX 4
+#define TX_REQ_MAX 4
+
+static const char shortname[] = "android_adb";
+
+struct adb_dev {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+	spinlock_t lock;
+
+	struct usb_ep *ep_in;
+	struct usb_ep *ep_out;
+
+	int online;
+	int error;
+
+	atomic_t read_excl;
+	atomic_t write_excl;
+	atomic_t open_excl;
+
+	struct list_head tx_idle;
+	struct list_head rx_idle;
+	struct list_head rx_done;
+
+	wait_queue_head_t read_wq;
+	wait_queue_head_t write_wq;
+
+	/* the request we're currently reading from */
+	struct usb_request *read_req;
+	unsigned char *read_buf;
+	unsigned read_count;
+};
+
+static struct usb_interface_descriptor adb_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	/* .bInterfaceNumber = DYNAMIC */
+	.bNumEndpoints          = 2,
+	.bInterfaceClass        = 0xFF,
+	.bInterfaceSubClass     = 0x42,
+	.bInterfaceProtocol     = 1,
+	/* .iInterface = DYNAMIC */
+};
+
+static struct usb_endpoint_descriptor adb_highspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor adb_highspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor adb_fullspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor adb_fullspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_descriptor_header *fs_adb_descs[] = {
+	(struct usb_descriptor_header *) &adb_interface_desc,
+	(struct usb_descriptor_header *) &adb_fullspeed_in_desc,
+	(struct usb_descriptor_header *) &adb_fullspeed_out_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *hs_adb_descs[] = {
+	(struct usb_descriptor_header *) &adb_interface_desc,
+	(struct usb_descriptor_header *) &adb_highspeed_in_desc,
+	(struct usb_descriptor_header *) &adb_highspeed_out_desc,
+	NULL,
+};
+
+/* string descriptors: */
+
+#define ADB_IDX	0
+
+/* static strings, in UTF-8 */
+static struct usb_string adb_string_defs[] = {
+	[ADB_IDX].s = "S3C6410 Android ADB",
+	{  /* ZEROES END LIST */ },
+};
+
+static struct usb_gadget_strings adb_string_table = {
+	.language =		0x0409,	/* en-us */
+	.strings =		adb_string_defs,
+};
+
+static struct usb_gadget_strings *adb_strings[] = {
+	&adb_string_table,
+	NULL,
+};
+
+/* used when adb function is disabled */
+static struct usb_descriptor_header *null_adb_descs[] = {
+	NULL,
+};
+
+/* temporary variable used between adb_open() and adb_gadget_bind() */
+static struct adb_dev *_adb_dev;
+
+static inline struct adb_dev *func_to_dev(struct usb_function *f)
+{
+	return container_of(f, struct adb_dev, function);
+}
+
+
+static struct usb_request *adb_request_new(struct usb_ep *ep, int buffer_size)
+{
+	struct usb_request *req = usb_ep_alloc_request(ep, GFP_KERNEL);
+	if (!req)
+		return NULL;
+
+	/* now allocate buffers for the requests */
+	req->buf = kmalloc(buffer_size, GFP_KERNEL);
+	if (!req->buf) {
+		usb_ep_free_request(ep, req);
+		return NULL;
+	}
+
+	return req;
+}
+
+static void adb_request_free(struct usb_request *req, struct usb_ep *ep)
+{
+	if (req) {
+		kfree(req->buf);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+static inline int _lock(atomic_t *excl)
+{
+	if (atomic_inc_return(excl) == 1) {
+		return 0;
+	} else {
+		atomic_dec(excl);
+		return -1;
+	}
+}
+
+static inline void _unlock(atomic_t *excl)
+{
+	atomic_dec(excl);
+}
+
+/* add a request to the tail of a list */
+void inline req_put(struct adb_dev *dev, struct list_head *head,
+		struct usb_request *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	list_add_tail(&req->list, head);
+	spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+/* remove a request from the head of a list */
+struct usb_request *req_get(struct adb_dev *dev, struct list_head *head)
+{
+	unsigned long flags;
+	struct usb_request *req;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (list_empty(head)) {
+		req = 0;
+	} else {
+		req = list_first_entry(head, struct usb_request, list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return req;
+}
+
+static void adb_complete_in(struct usb_ep *ep, struct usb_request *req)
+{
+	struct adb_dev *dev = _adb_dev;
+
+	if (req->status != 0)
+		dev->error = 1;
+
+	req_put(dev, &dev->tx_idle, req);
+
+	wake_up(&dev->write_wq);
+}
+
+static void adb_complete_out(struct usb_ep *ep, struct usb_request *req)
+{
+	struct adb_dev *dev = _adb_dev;
+
+	if (req->status != 0) {
+		dev->error = 1;
+		req_put(dev, &dev->rx_idle, req);
+	} else {
+		req_put(dev, &dev->rx_done, req);
+	}
+
+	wake_up(&dev->read_wq);
+}
+
+static int __init create_bulk_endpoints(struct adb_dev *dev,
+				struct usb_endpoint_descriptor *in_desc,
+				struct usb_endpoint_descriptor *out_desc)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req;
+	struct usb_ep *ep;
+	int i;
+
+	DBG(cdev, "create_bulk_endpoints dev: %p\n", dev);
+
+	ep = usb_ep_autoconfig(cdev->gadget, in_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_in failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for adb ep_in got %s\n", ep->name);
+	dev->ep_in = ep;
+	ep->driver_data = dev;	/* claim */
+
+	ep = usb_ep_autoconfig(cdev->gadget, out_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_out failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for adb ep_out got %s\n", ep->name);
+	dev->ep_out = ep;
+	ep->driver_data = dev;	/* claim */
+
+	/* now allocate requests for our endpoints */
+	for (i = 0; i < RX_REQ_MAX; i++) {
+		req = adb_request_new(dev->ep_out, BULK_BUFFER_SIZE);
+		if (!req)
+			goto fail;
+		req->complete = adb_complete_out;
+		req_put(dev, &dev->rx_idle, req);
+	}
+
+	for (i = 0; i < TX_REQ_MAX; i++) {
+		req = adb_request_new(dev->ep_in, BULK_BUFFER_SIZE);
+		if (!req)
+			goto fail;
+		req->complete = adb_complete_in;
+		req_put(dev, &dev->tx_idle, req);
+	}
+
+	return 0;
+
+fail:
+	printk(KERN_ERR "adb_bind() could not allocate requests\n");
+	return -1;
+}
+
+static ssize_t adb_read(struct file *fp, char __user *buf,
+				size_t count, loff_t *pos)
+{
+	struct adb_dev *dev = fp->private_data;
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req;
+	int r = count, xfer;
+	int ret;
+
+	DBG(cdev, "adb_read(%d)\n", count);
+
+	if (_lock(&dev->read_excl))
+		return -EBUSY;
+
+	/* we will block until we're online */
+	while (!(dev->online || dev->error)) {
+		DBG(cdev, "adb_read: waiting for online state\n");
+		ret = wait_event_interruptible(dev->read_wq,
+				(dev->online || dev->error));
+		if (ret < 0) {
+			_unlock(&dev->read_excl);
+			return ret;
+		}
+	}
+
+	while (count > 0) {
+		if (dev->error) {
+			DBG(cdev, "adb_read dev->error\n");
+			r = -EIO;
+			break;
+		}
+
+		/* if we have idle read requests, get them queued */
+		while ((req = req_get(dev, &dev->rx_idle))) {
+requeue_req:
+			req->length = BULK_BUFFER_SIZE;
+			ret = usb_ep_queue(dev->ep_out, req, GFP_ATOMIC);
+
+			if (ret < 0) {
+				r = -EIO;
+				dev->error = 1;
+				req_put(dev, &dev->rx_idle, req);
+				goto fail;
+			} else {
+				DBG(cdev, "rx %p queue\n", req);
+			}
+		}
+
+		/* if we have data pending, give it to userspace */
+		if (dev->read_count > 0) {
+			if (dev->read_count < count)
+				xfer = dev->read_count;
+			else
+				xfer = count;
+
+			if (copy_to_user(buf, dev->read_buf, xfer)) {
+				r = -EFAULT;
+				break;
+			}
+			dev->read_buf += xfer;
+			dev->read_count -= xfer;
+			buf += xfer;
+			count -= xfer;
+
+			/* if we've emptied the buffer, release the request */
+			if (dev->read_count == 0) {
+				req_put(dev, &dev->rx_idle, dev->read_req);
+				dev->read_req = 0;
+			}
+			continue;
+		}
+
+		/* wait for a request to complete */
+		req = 0;
+		ret = wait_event_interruptible(dev->read_wq,
+			((req = req_get(dev, &dev->rx_done)) || dev->error));
+		if (req != 0) {
+			/* if we got a 0-len one we need to put it back into
+			** service.  if we made it the current read req we'd
+			** be stuck forever
+			*/
+			if (req->actual == 0)
+				goto requeue_req;
+
+			dev->read_req = req;
+			dev->read_count = req->actual;
+			dev->read_buf = req->buf;
+			DBG(cdev, "rx %p %d\n", req, req->actual);
+		}
+
+		if (ret < 0) {
+			r = ret;
+			break;
+		}
+	}
+
+fail:
+	_unlock(&dev->read_excl);
+	DBG(cdev, "adb_read returning %d\n", r);
+	return r;
+}
+
+static ssize_t adb_write(struct file *fp, const char __user *buf,
+				 size_t count, loff_t *pos)
+{
+	struct adb_dev *dev = fp->private_data;
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req = 0;
+	int r = count, xfer;
+	int ret;
+
+	DBG(cdev, "adb_write(%d)\n", count);
+
+	if (_lock(&dev->write_excl))
+		return -EBUSY;
+
+	while (count > 0) {
+		if (dev->error) {
+			DBG(cdev, "adb_write dev->error\n");
+			r = -EIO;
+			break;
+		}
+
+		/* get an idle tx request to use */
+		req = 0;
+		ret = wait_event_interruptible(dev->write_wq,
+			((req = req_get(dev, &dev->tx_idle)) || dev->error));
+
+		if (ret < 0) {
+			r = ret;
+			break;
+		}
+
+		if (req != 0) {
+			if (count > BULK_BUFFER_SIZE)
+				xfer = BULK_BUFFER_SIZE;
+			else
+				xfer = count;
+			if (copy_from_user(req->buf, buf, xfer)) {
+				r = -EFAULT;
+				break;
+			}
+
+			req->length = xfer;
+			ret = usb_ep_queue(dev->ep_in, req, GFP_ATOMIC);
+			if (ret < 0) {
+				DBG(cdev, "adb_write: xfer error %d\n", ret);
+				dev->error = 1;
+				r = -EIO;
+				break;
+			}
+
+			buf += xfer;
+			count -= xfer;
+
+			/* zero this so we don't try to free it on error exit */
+			req = 0;
+		}
+	}
+
+	if (req)
+		req_put(dev, &dev->tx_idle, req);
+
+	_unlock(&dev->write_excl);
+	DBG(cdev, "adb_write returning %d\n", r);
+	return r;
+}
+
+static int adb_open(struct inode *ip, struct file *fp)
+{
+	if (_lock(&_adb_dev->open_excl))
+		return -EBUSY;
+
+	fp->private_data = _adb_dev;
+
+	/* clear the error latch */
+	_adb_dev->error = 0;
+
+	return 0;
+}
+
+static int adb_release(struct inode *ip, struct file *fp)
+{
+	if(_adb_dev != NULL)
+	_unlock(&_adb_dev->open_excl);
+	return 0;
+}
+
+/* file operations for ADB device /dev/android_adb */
+static struct file_operations adb_fops = {
+	.owner = THIS_MODULE,
+	.read = adb_read,
+	.write = adb_write,
+	.open = adb_open,
+	.release = adb_release,
+};
+
+static struct miscdevice adb_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = shortname,
+	.fops = &adb_fops,
+};
+
+#if	USBCV_CH9_REMOTE_WAKE_UP_TEST
+//To send wakeup signal for USBCV test scenario
+static int adb_function_suspend(struct usb_function *f) {
+	mdelay(200);
+	printk("[%s] Request usb_gadget_wakeup()\n", __func__);
+	usb_gadget_wakeup(f->config->cdev->gadget);
+}	
+#endif
+
+
+static int __init
+adb_function_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct adb_dev	*dev = func_to_dev(f);
+	int			id;
+	int			ret;
+
+	dev->cdev = cdev;
+	DBG(cdev, "adb_function_bind dev: %p\n", dev);
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	adb_interface_desc.bInterfaceNumber = id;
+
+	/* allocate endpoints */
+	ret = create_bulk_endpoints(dev, &adb_fullspeed_in_desc,
+			&adb_fullspeed_out_desc);
+	if (ret)
+		return ret;
+
+	/* support high speed hardware */
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		adb_highspeed_in_desc.bEndpointAddress =
+			adb_fullspeed_in_desc.bEndpointAddress;
+		adb_highspeed_out_desc.bEndpointAddress =
+			adb_fullspeed_out_desc.bEndpointAddress;
+	}
+
+	DBG(cdev, "%s speed %s: IN/%s, OUT/%s\n",
+			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+			f->name, dev->ep_in->name, dev->ep_out->name);
+	return 0;
+}
+
+static void
+adb_function_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct adb_dev	*dev = func_to_dev(f);
+	struct usb_request *req;
+
+	spin_lock_irq(&dev->lock);
+
+	while ((req = req_get(dev, &dev->rx_idle)))
+		adb_request_free(req, dev->ep_out);
+	while ((req = req_get(dev, &dev->tx_idle)))
+		adb_request_free(req, dev->ep_in);
+
+	dev->online = 0;
+	dev->error = 1;
+	spin_unlock_irq(&dev->lock);
+
+	misc_deregister(&adb_device);
+	kfree(_adb_dev);
+	_adb_dev = NULL;
+}
+
+static int adb_function_set_alt(struct usb_function *f,
+		unsigned intf, unsigned alt)
+{
+	struct adb_dev	*dev = func_to_dev(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int ret;
+
+	DBG(cdev, "adb_function_set_alt intf: %d alt: %d\n", intf, alt);
+
+	if(dev->ep_in->driver_data)
+		usb_ep_disable(dev->ep_in);
+	ret = usb_ep_enable(dev->ep_in,
+			ep_choose(cdev->gadget,
+				&adb_highspeed_in_desc,
+				&adb_fullspeed_in_desc));
+	if (ret)
+		return ret;
+	dev->ep_in->driver_data = dev;
+	
+	if(dev->ep_out->driver_data)
+		usb_ep_disable(dev->ep_out);
+	ret = usb_ep_enable(dev->ep_out,
+			ep_choose(cdev->gadget,
+				&adb_highspeed_out_desc,
+				&adb_fullspeed_out_desc));
+	if (ret) {
+		usb_ep_disable(dev->ep_in);
+		dev->ep_in->driver_data = NULL;
+		return ret;
+	}
+	dev->ep_out->driver_data = dev;
+
+	dev->online = 1;
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+	return 0;
+}
+
+static void adb_function_disable(struct usb_function *f)
+{
+	struct adb_dev	*dev = func_to_dev(f);
+	struct usb_composite_dev	*cdev = dev->cdev;
+
+	DBG(cdev, "adb_function_disable\n");
+	dev->online = 0;
+	dev->error = 1;
+	
+	usb_ep_disable(dev->ep_in);
+	dev->ep_in->driver_data = NULL;
+	
+	usb_ep_disable(dev->ep_out);
+	dev->ep_out->driver_data = NULL;
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+
+	VDBG(cdev, "%s disabled\n", dev->function.name);
+}
+
+int __init adb_function_add(struct usb_composite_dev *cdev,
+	struct usb_configuration *c)
+{
+	struct adb_dev *dev;
+	int ret, status;
+
+	printk(KERN_INFO "adb_function_add\n");
+
+//by ss1
+	/* maybe allocate device-global string IDs, and patch descriptors */
+	if (adb_string_defs[ADB_IDX].id == 0) {
+		status = usb_string_id(c->cdev);
+		if (status < 0)
+			return status;
+		adb_string_defs[ADB_IDX].id = status;
+		adb_interface_desc.iInterface = status;
+	}
+	
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	spin_lock_init(&dev->lock);
+
+	init_waitqueue_head(&dev->read_wq);
+	init_waitqueue_head(&dev->write_wq);
+
+	atomic_set(&dev->open_excl, 0);
+	atomic_set(&dev->read_excl, 0);
+	atomic_set(&dev->write_excl, 0);
+
+	INIT_LIST_HEAD(&dev->rx_idle);
+	INIT_LIST_HEAD(&dev->rx_done);
+	INIT_LIST_HEAD(&dev->tx_idle);
+
+	dev->cdev = cdev;
+	dev->function.name = "adb";
+	dev->function.strings = adb_strings;
+	dev->function.descriptors = null_adb_descs;
+	dev->function.hs_descriptors = null_adb_descs;
+	dev->function.bind = adb_function_bind;
+	dev->function.unbind = adb_function_unbind;
+	dev->function.set_alt = adb_function_set_alt;
+	dev->function.disable = adb_function_disable;
+#if	USBCV_CH9_REMOTE_WAKE_UP_TEST
+	dev->function.suspend = adb_function_suspend;
+#endif
+
+	/* _adb_dev must be set before calling usb_gadget_register_driver */
+	_adb_dev = dev;
+
+	ret = misc_register(&adb_device);
+	if (ret)
+		goto err1;
+	ret = usb_add_function(c, &dev->function);
+	if (ret)
+		goto err2;
+
+	return 0;
+
+err2:
+	misc_deregister(&adb_device);
+err1:
+	kfree(dev);
+	printk(KERN_ERR "adb gadget driver failed to initialize\n");
+	return ret;
+}
+
+void adb_function_enable(int enable)
+{
+	struct adb_dev *dev = _adb_dev;
+
+	if (dev) {
+		printk("[%s] adb_function => (%s)\n", __func__, 
+			enable ? "enabled" : "disabled");
+
+		if (enable) {
+			dev->function.descriptors = fs_adb_descs;
+			dev->function.hs_descriptors = hs_adb_descs;
+		} else {
+			dev->function.descriptors = null_adb_descs;
+			dev->function.hs_descriptors = null_adb_descs;
+		}
+	}
+	else
+		printk("[%s] dev does not exist\n", __func__);
+}
+
diff -Nur linux-2.6.29/drivers/usb/gadget/f_adb.h linux-2.6.29-spica/drivers/usb/gadget/f_adb.h
--- linux-2.6.29/drivers/usb/gadget/f_adb.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/f_adb.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,33 @@
+/*
+ * Gadget Driver for Android ADB
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __F_ADB_H
+#define __F_ADB_H
+
+/*
+ * set USBCV_CH9_REMOTE_WAKE_UP_TEST 1 ONLY for testing USBCV ch9
+ * RemoteWakeupTestEnabled & RemoteWakeupTestDisabled
+ * Confirm USBCV_CH9_REMOTE_WAKE_UP_TEST 
+ * in s3c-udc-otg-hs.c and f_adb.h 
+ */
+#define	USBCV_CH9_REMOTE_WAKE_UP_TEST 0
+
+int adb_function_add(struct usb_composite_dev *cdev,
+	struct usb_configuration *c);
+void adb_function_enable(int enable);
+
+#endif /* __F_ADB_H */
diff -Nur linux-2.6.29/drivers/usb/gadget/file_storage.c linux-2.6.29-spica/drivers/usb/gadget/file_storage.c
--- linux-2.6.29/drivers/usb/gadget/file_storage.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/usb/gadget/file_storage.c	2010-05-06 12:42:45.644210217 +0700
@@ -247,6 +247,7 @@
 #include <linux/string.h>
 #include <linux/freezer.h>
 #include <linux/utsname.h>
+#include <linux/switch.h>
 
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
@@ -365,9 +366,13 @@
 	char		*protocol_name;
 
 } mod_data = {					// Default values
+//added by ss1.yang
+//	.file = "/lib/modules/gadgetdisk_dev_block_ram0",	
+	.file = "/dev/block/mmcblk0",	
 	.transport_parm		= "BBB",
 	.protocol_parm		= "SCSI",
-	.removable		= 0,
+//modified by ss1.yang
+	.removable		= 1, //0,
 	.can_stall		= 1,
 	.cdrom			= 0,
 	.vendor			= DRIVER_VENDOR_ID,
@@ -712,6 +717,7 @@
 	unsigned int		nluns;
 	struct lun		*luns;
 	struct lun		*curlun;
+	struct switch_dev	sdev;
 };
 
 typedef void (*fsg_routine_t)(struct fsg_dev *);
@@ -3362,6 +3368,7 @@
 			INFO(fsg, "%s speed config #%d\n", speed, fsg->config);
 		}
 	}
+	switch_set_state (&fsg->sdev, new_config);
 	return rc;
 }
 
@@ -3865,6 +3872,7 @@
 	}
 
 	set_gadget_data(gadget, NULL);
+	switch_dev_unregister(&the_fsg->sdev);
 }
 
 
@@ -3956,6 +3964,16 @@
 	return 0;
 }
 
+static ssize_t print_switch_name(struct switch_dev *sdev, char *buf)
+{
+        return sprintf(buf, "usb_mass_storage\n");
+}
+ 
+static ssize_t print_switch_state(struct switch_dev *sdev, char *buf)
+{
+        struct fsg_dev  *fsg = container_of(sdev, struct fsg_dev, sdev);
+        return sprintf(buf, "%s\n", (fsg->config ? "online" : "offline"));
+}
 
 static int __init fsg_bind(struct usb_gadget *gadget)
 {
@@ -4174,6 +4192,11 @@
 
 	set_bit(REGISTERED, &fsg->atomic_bitflags);
 
+        the_fsg->sdev.name = "usb_mass_storage";
+        the_fsg->sdev.print_name = print_switch_name;
+        the_fsg->sdev.print_state = print_switch_state;
+        switch_dev_register(&the_fsg->sdev);
+
 	/* Tell the thread to start working */
 	wake_up_process(fsg->thread_task);
 	return 0;
diff -Nur linux-2.6.29/drivers/usb/gadget/f_mass_storage.c linux-2.6.29-spica/drivers/usb/gadget/f_mass_storage.c
--- linux-2.6.29/drivers/usb/gadget/f_mass_storage.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/f_mass_storage.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,3148 @@
+/*
+ * drivers/usb/gadget/f_mass_storage.c
+ *
+ * Function Driver for USB Mass Storage
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * Based heavily on the file_storage gadget driver in
+ * drivers/usb/gadget/file_storage.c and licensed under the same terms:
+ *
+ * Copyright (C) 2003-2007 Alan Stern
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The names of the above-listed copyright holders may not be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+/* #define DUMP_MSGS */
+
+
+#include <linux/blkdev.h>
+#include <linux/completion.h>
+#include <linux/dcache.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fcntl.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/kref.h>
+#include <linux/kthread.h>
+#include <linux/limits.h>
+#include <linux/rwsem.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/switch.h>
+#include <linux/freezer.h>
+#include <linux/utsname.h>
+#include <linux/wakelock.h>
+#include <linux/platform_device.h>
+
+#include <linux/usb_usual.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/composite.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/android.h>
+
+#include "f_mass_storage.h"
+#include "gadget_chips.h"
+
+
+#define BULK_BUFFER_SIZE           4096
+
+/*-------------------------------------------------------------------------*/
+
+#define DRIVER_NAME		"usb_mass_storage"
+#define MAX_LUNS		8
+
+static const char shortname[] = DRIVER_NAME;
+
+#ifdef DEBUG
+#define LDBG(lun, fmt, args...) \
+	dev_dbg(&(lun)->dev , fmt , ## args)
+#define MDBG(fmt,args...) \
+	printk(KERN_DEBUG DRIVER_NAME ": " fmt , ## args)
+#else
+#define LDBG(lun, fmt, args...) \
+	do { } while (0)
+#define MDBG(fmt,args...) \
+	do { } while (0)
+#undef VERBOSE_DEBUG
+#undef DUMP_MSGS
+#endif /* DEBUG */
+
+#ifdef VERBOSE_DEBUG
+#define VLDBG	LDBG
+#else
+#define VLDBG(lun, fmt, args...) \
+	do { } while (0)
+#endif /* VERBOSE_DEBUG */
+
+#define LERROR(lun, fmt, args...) \
+	dev_err(&(lun)->dev , fmt , ## args)
+#define LWARN(lun, fmt, args...) \
+	dev_warn(&(lun)->dev , fmt , ## args)
+#define LINFO(lun, fmt, args...) \
+	dev_info(&(lun)->dev , fmt , ## args)
+
+#define MINFO(fmt,args...) \
+	printk(KERN_INFO DRIVER_NAME ": " fmt , ## args)
+
+#undef DBG
+#undef VDBG
+#undef ERROR
+#undef WARNING
+#undef INFO
+#define DBG(d, fmt, args...) \
+	dev_dbg(&(d)->cdev->gadget->dev , fmt , ## args)
+#define VDBG(d, fmt, args...) \
+	dev_vdbg(&(d)->cdev->gadget->dev , fmt , ## args)
+#define ERROR(d, fmt, args...) \
+	dev_err(&(d)->cdev->gadget->dev , fmt , ## args)
+#define WARNING(d, fmt, args...) \
+	dev_warn(&(d)->cdev->gadget->dev , fmt , ## args)
+#define INFO(d, fmt, args...) \
+	dev_info(&(d)->cdev->gadget->dev , fmt , ## args)
+
+
+/*-------------------------------------------------------------------------*/
+
+/* Bulk-only data structures */
+
+/* Command Block Wrapper */
+struct bulk_cb_wrap {
+	__le32	Signature;		/* Contains 'USBC' */
+	u32	Tag;			/* Unique per command id */
+	__le32	DataTransferLength;	/* Size of the data */
+	u8	Flags;			/* Direction in bit 7 */
+	u8	Lun;			/* LUN (normally 0) */
+	u8	Length;			/* Of the CDB, <= MAX_COMMAND_SIZE */
+	u8	CDB[16];		/* Command Data Block */
+};
+
+#define USB_BULK_CB_WRAP_LEN	31
+#define USB_BULK_CB_SIG		0x43425355	/* Spells out USBC */
+#define USB_BULK_IN_FLAG	0x80
+
+/* Command Status Wrapper */
+struct bulk_cs_wrap {
+	__le32	Signature;		/* Should = 'USBS' */
+	u32	Tag;			/* Same as original command */
+	__le32	Residue;		/* Amount not transferred */
+	u8	Status;			/* See below */
+};
+
+#define USB_BULK_CS_WRAP_LEN	13
+#define USB_BULK_CS_SIG		0x53425355	/* Spells out 'USBS' */
+#define USB_STATUS_PASS		0
+#define USB_STATUS_FAIL		1
+#define USB_STATUS_PHASE_ERROR	2
+
+/* Bulk-only class specific requests */
+#define USB_BULK_RESET_REQUEST		0xff
+#define USB_BULK_GET_MAX_LUN_REQUEST	0xfe
+
+/* Length of a SCSI Command Data Block */
+#define MAX_COMMAND_SIZE	16
+
+/* SCSI commands that we recognize */
+#define SC_FORMAT_UNIT			0x04
+#define SC_INQUIRY			0x12
+#define SC_MODE_SELECT_6		0x15
+#define SC_MODE_SELECT_10		0x55
+#define SC_MODE_SENSE_6			0x1a
+#define SC_MODE_SENSE_10		0x5a
+#define SC_PREVENT_ALLOW_MEDIUM_REMOVAL	0x1e
+#define SC_READ_6			0x08
+#define SC_READ_10			0x28
+#define SC_READ_12			0xa8
+#define SC_READ_CAPACITY		0x25
+#define SC_READ_FORMAT_CAPACITIES	0x23
+#define SC_RELEASE			0x17
+#define SC_REQUEST_SENSE		0x03
+#define SC_RESERVE			0x16
+#define SC_SEND_DIAGNOSTIC		0x1d
+#define SC_START_STOP_UNIT		0x1b
+#define SC_SYNCHRONIZE_CACHE		0x35
+#define SC_TEST_UNIT_READY		0x00
+#define SC_VERIFY			0x2f
+#define SC_WRITE_6			0x0a
+#define SC_WRITE_10			0x2a
+#define SC_WRITE_12			0xaa
+
+/* SCSI Sense Key/Additional Sense Code/ASC Qualifier values */
+#define SS_NO_SENSE				0
+#define SS_COMMUNICATION_FAILURE		0x040800
+#define SS_INVALID_COMMAND			0x052000
+#define SS_INVALID_FIELD_IN_CDB			0x052400
+#define SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE	0x052100
+#define SS_LOGICAL_UNIT_NOT_SUPPORTED		0x052500
+#define SS_MEDIUM_NOT_PRESENT			0x023a00
+#define SS_MEDIUM_REMOVAL_PREVENTED		0x055302
+#define SS_NOT_READY_TO_READY_TRANSITION	0x062800
+#define SS_RESET_OCCURRED			0x062900
+#define SS_SAVING_PARAMETERS_NOT_SUPPORTED	0x053900
+#define SS_UNRECOVERED_READ_ERROR		0x031100
+#define SS_WRITE_ERROR				0x030c02
+#define SS_WRITE_PROTECTED			0x072700
+
+#define SK(x)		((u8) ((x) >> 16))	/* Sense Key byte, etc. */
+#define ASC(x)		((u8) ((x) >> 8))
+#define ASCQ(x)		((u8) (x))
+
+
+/*-------------------------------------------------------------------------*/
+
+struct lun {
+	struct file	*filp;
+	loff_t		file_length;
+	loff_t		num_sectors;
+
+	unsigned int	ro : 1;
+	unsigned int	prevent_medium_removal : 1;
+	unsigned int	registered : 1;
+	unsigned int	info_valid : 1;
+
+	u32		sense_data;
+	u32		sense_data_info;
+	u32		unit_attention_data;
+
+	struct device	dev;
+};
+
+#define backing_file_is_open(curlun)	((curlun)->filp != NULL)
+
+static struct lun *dev_to_lun(struct device *dev)
+{
+	return container_of(dev, struct lun, dev);
+}
+
+/* Big enough to hold our biggest descriptor */
+#define EP0_BUFSIZE	256
+
+/* Number of buffers we will use.  2 is enough for double-buffering */
+#define NUM_BUFFERS	2
+
+enum fsg_buffer_state {
+	BUF_STATE_EMPTY = 0,
+	BUF_STATE_FULL,
+	BUF_STATE_BUSY
+};
+
+struct fsg_buffhd {
+	void				*buf;
+	enum fsg_buffer_state		state;
+	struct fsg_buffhd		*next;
+
+	/* The NetChip 2280 is faster, and handles some protocol faults
+	 * better, if we don't submit any short bulk-out read requests.
+	 * So we will record the intended request length here. */
+	unsigned int			bulk_out_intended_length;
+
+	struct usb_request		*inreq;
+	int				inreq_busy;
+	struct usb_request		*outreq;
+	int				outreq_busy;
+};
+
+enum fsg_state {
+	/* This one isn't used anywhere */
+	FSG_STATE_COMMAND_PHASE = -10,
+
+	FSG_STATE_DATA_PHASE,
+	FSG_STATE_STATUS_PHASE,
+
+	FSG_STATE_IDLE = 0,
+	FSG_STATE_ABORT_BULK_OUT,
+	FSG_STATE_RESET,
+	FSG_STATE_CONFIG_CHANGE,
+	FSG_STATE_EXIT,
+	FSG_STATE_TERMINATED
+};
+
+enum data_direction {
+	DATA_DIR_UNKNOWN = 0,
+	DATA_DIR_FROM_HOST,
+	DATA_DIR_TO_HOST,
+	DATA_DIR_NONE
+};
+
+struct fsg_dev {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+
+	/* optional "usb_mass_storage" platform device */
+	struct platform_device *pdev;
+
+	/* lock protects: state and all the req_busy's */
+	spinlock_t		lock;
+
+	/* filesem protects: backing files in use */
+	struct rw_semaphore	filesem;
+
+	/* reference counting: wait until all LUNs are released */
+	struct kref		ref;
+
+	unsigned int		bulk_out_maxpacket;
+	enum fsg_state		state;		/* For exception handling */
+
+	u8			config, new_config;
+
+	unsigned int		running : 1;
+	unsigned int		bulk_in_enabled : 1;
+	unsigned int		bulk_out_enabled : 1;
+	unsigned int		phase_error : 1;
+	unsigned int		short_packet_received : 1;
+	unsigned int		bad_lun_okay : 1;
+
+	unsigned long		atomic_bitflags;
+#define REGISTERED		0
+#define CLEAR_BULK_HALTS	1
+#define SUSPENDED		2
+
+	struct usb_ep		*bulk_in;
+	struct usb_ep		*bulk_out;
+
+	struct fsg_buffhd	*next_buffhd_to_fill;
+	struct fsg_buffhd	*next_buffhd_to_drain;
+	struct fsg_buffhd	buffhds[NUM_BUFFERS];
+
+	int			thread_wakeup_needed;
+	struct completion	thread_notifier;
+	struct task_struct	*thread_task;
+
+	int			cmnd_size;
+	u8			cmnd[MAX_COMMAND_SIZE];
+	enum data_direction	data_dir;
+	u32			data_size;
+	u32			data_size_from_cmnd;
+	u32			tag;
+	unsigned int		lun;
+	u32			residue;
+	u32			usb_amount_left;
+
+	unsigned int		nluns;
+	struct lun		*luns;
+	struct lun		*curlun;
+
+	u32				buf_size;
+	const char		*vendor;
+	const char		*product;
+	int				release;
+
+	struct switch_dev sdev;
+
+	struct wake_lock wake_lock;
+};
+
+static inline struct fsg_dev *func_to_dev(struct usb_function *f)
+{
+	return container_of(f, struct fsg_dev, function);
+}
+
+static int exception_in_progress(struct fsg_dev *fsg)
+{
+	return (fsg->state > FSG_STATE_IDLE);
+}
+
+/* Make bulk-out requests be divisible by the maxpacket size */
+static void set_bulk_out_req_length(struct fsg_dev *fsg,
+		struct fsg_buffhd *bh, unsigned int length)
+{
+	unsigned int	rem;
+
+	bh->bulk_out_intended_length = length;
+	rem = length % fsg->bulk_out_maxpacket;
+	if (rem > 0)
+		length += fsg->bulk_out_maxpacket - rem;
+	bh->outreq->length = length;
+}
+
+static struct fsg_dev			*the_fsg;
+
+static void	close_backing_file(struct fsg_dev *fsg, struct lun *curlun);
+static void	close_all_backing_files(struct fsg_dev *fsg);
+
+int MSC_INVALID_CBW_IGNORE_CLEAR_HALT(void)
+{
+	if (test_bit(CLEAR_BULK_HALTS, &the_fsg->atomic_bitflags))
+		return 0;
+	return -1;
+}
+EXPORT_SYMBOL(MSC_INVALID_CBW_IGNORE_CLEAR_HALT);
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef DUMP_MSGS
+
+static void dump_msg(struct fsg_dev *fsg, const char *label,
+		const u8 *buf, unsigned int length)
+{
+	if (length < 512) {
+		DBG(fsg, "%s, length %u:\n", label, length);
+		print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET,
+				16, 1, buf, length, 0);
+	}
+}
+
+static void dump_cdb(struct fsg_dev *fsg)
+{}
+
+#else
+
+static void dump_msg(struct fsg_dev *fsg, const char *label,
+		const u8 *buf, unsigned int length)
+{}
+
+#ifdef VERBOSE_DEBUG
+
+static void dump_cdb(struct fsg_dev *fsg)
+{
+	print_hex_dump(KERN_DEBUG, "SCSI CDB: ", DUMP_PREFIX_NONE,
+			16, 1, fsg->cmnd, fsg->cmnd_size, 0);
+}
+
+#else
+
+static void dump_cdb(struct fsg_dev *fsg)
+{}
+
+#endif /* VERBOSE_DEBUG */
+#endif /* DUMP_MSGS */
+
+
+/*-------------------------------------------------------------------------*/
+
+/* Routines for unaligned data access */
+
+static u16 get_be16(u8 *buf)
+{
+	return ((u16) buf[0] << 8) | ((u16) buf[1]);
+}
+
+static u32 get_be32(u8 *buf)
+{
+	return ((u32) buf[0] << 24) | ((u32) buf[1] << 16) |
+			((u32) buf[2] << 8) | ((u32) buf[3]);
+}
+
+static void put_be16(u8 *buf, u16 val)
+{
+	buf[0] = val >> 8;
+	buf[1] = val;
+}
+
+static void put_be32(u8 *buf, u32 val)
+{
+	buf[0] = val >> 24;
+	buf[1] = val >> 16;
+	buf[2] = val >> 8;
+	buf[3] = val & 0xff;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * DESCRIPTORS ... most are static, but strings and (full) configuration
+ * descriptors are built on demand.  Also the (static) config and interface
+ * descriptors are adjusted during fsg_bind().
+ */
+
+/* There is only one interface. */
+
+static struct usb_interface_descriptor
+intf_desc = {
+	.bLength =		sizeof intf_desc,
+	.bDescriptorType =	USB_DT_INTERFACE,
+
+	.bNumEndpoints =	2,		/* Adjusted during fsg_bind() */
+	.bInterfaceClass =	USB_CLASS_MASS_STORAGE,
+	.bInterfaceSubClass =	US_SC_SCSI,
+	.bInterfaceProtocol =	US_PR_BULK,
+};
+
+/* Three full-speed endpoint descriptors: bulk-in, bulk-out,
+ * and interrupt-in. */
+
+static struct usb_endpoint_descriptor
+fs_bulk_in_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+
+	.bEndpointAddress =	USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	/* wMaxPacketSize set by autoconfiguration */
+};
+
+static struct usb_endpoint_descriptor
+fs_bulk_out_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+
+	.bEndpointAddress =	USB_DIR_OUT,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	/* wMaxPacketSize set by autoconfiguration */
+};
+
+static struct usb_descriptor_header *fs_function[] = {
+	(struct usb_descriptor_header *) &intf_desc,
+	(struct usb_descriptor_header *) &fs_bulk_in_desc,
+	(struct usb_descriptor_header *) &fs_bulk_out_desc,
+	NULL,
+};
+#define FS_FUNCTION_PRE_EP_ENTRIES	2
+
+
+static struct usb_endpoint_descriptor
+hs_bulk_in_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+
+	/* bEndpointAddress copied from fs_bulk_in_desc during fsg_bind() */
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor
+hs_bulk_out_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+
+	/* bEndpointAddress copied from fs_bulk_out_desc during fsg_bind() */
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	__constant_cpu_to_le16(512),
+	.bInterval =		1,	/* NAK every 1 uframe */
+};
+
+
+static struct usb_descriptor_header *hs_function[] = {
+	(struct usb_descriptor_header *) &intf_desc,
+	(struct usb_descriptor_header *) &hs_bulk_in_desc,
+	(struct usb_descriptor_header *) &hs_bulk_out_desc,
+	NULL,
+};
+
+/* Maxpacket and other transfer characteristics vary by speed. */
+static struct usb_endpoint_descriptor *
+ep_desc(struct usb_gadget *g, struct usb_endpoint_descriptor *fs,
+		struct usb_endpoint_descriptor *hs)
+{
+	if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
+		return hs;
+	return fs;
+}
+
+/* string descriptors: */
+
+#define F_UMS_IDX	0
+
+/* static strings, in UTF-8 */
+static struct usb_string f_ums_string_defs[] = {
+	[F_UMS_IDX].s = "Android UMS",
+	{  /* ZEROES END LIST */ },
+};
+
+static struct usb_gadget_strings f_ums_string_table = {
+	.language =		0x0409,	/* en-us */
+	.strings =		f_ums_string_defs,
+};
+
+static struct usb_gadget_strings *f_ums_strings[] = {
+	&f_ums_string_table,
+	NULL,
+};
+
+
+/*-------------------------------------------------------------------------*/
+
+/* These routines may be called in process context or in_irq */
+
+/* Caller must hold fsg->lock */
+static void wakeup_thread(struct fsg_dev *fsg)
+{
+	/* Tell the main thread that something has happened */
+	fsg->thread_wakeup_needed = 1;
+	if (fsg->thread_task)
+		wake_up_process(fsg->thread_task);
+}
+
+
+static void raise_exception(struct fsg_dev *fsg, enum fsg_state new_state)
+{
+	unsigned long		flags;
+
+	DBG(fsg, "raise_exception %d\n", (int)new_state);
+	/* Do nothing if a higher-priority exception is already in progress.
+	 * If a lower-or-equal priority exception is in progress, preempt it
+	 * and notify the main thread by sending it a signal. */
+	spin_lock_irqsave(&fsg->lock, flags);
+	if (fsg->state <= new_state) {
+		fsg->state = new_state;
+		if (fsg->thread_task)
+			send_sig_info(SIGUSR1, SEND_SIG_FORCED,
+					fsg->thread_task);
+	}
+	spin_unlock_irqrestore(&fsg->lock, flags);
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* Bulk and interrupt endpoint completion handlers.
+ * These always run in_irq. */
+
+static void bulk_in_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct fsg_dev		*fsg = ep->driver_data;
+	struct fsg_buffhd	*bh = req->context;
+
+	if (req->status || req->actual != req->length)
+		DBG(fsg, "%s --> %d, %u/%u\n", __func__,
+				req->status, req->actual, req->length);
+
+	/* Hold the lock while we update the request and buffer states */
+	smp_wmb();
+	spin_lock(&fsg->lock);
+	bh->inreq_busy = 0;
+	bh->state = BUF_STATE_EMPTY;
+	wakeup_thread(fsg);
+	spin_unlock(&fsg->lock);
+}
+
+static void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct fsg_dev		*fsg = ep->driver_data;
+	struct fsg_buffhd	*bh = req->context;
+
+	dump_msg(fsg, "bulk-out", req->buf, req->actual);
+	if (req->status || req->actual != bh->bulk_out_intended_length)
+		DBG(fsg, "%s --> %d, %u/%u\n", __func__,
+				req->status, req->actual,
+				bh->bulk_out_intended_length);
+
+	/* Hold the lock while we update the request and buffer states */
+	smp_wmb();
+	spin_lock(&fsg->lock);
+	bh->outreq_busy = 0;
+	bh->state = BUF_STATE_FULL;
+	wakeup_thread(fsg);
+	spin_unlock(&fsg->lock);
+}
+
+static int fsg_function_setup(struct usb_function *f,
+					const struct usb_ctrlrequest *ctrl)
+{
+	struct fsg_dev	*fsg = func_to_dev(f);
+	struct usb_composite_dev *cdev = fsg->cdev;
+	int			value = -EOPNOTSUPP;
+	u16			w_index = le16_to_cpu(ctrl->wIndex);
+	u16			w_value = le16_to_cpu(ctrl->wValue);
+	u16			w_length = le16_to_cpu(ctrl->wLength);
+
+	DBG(fsg, "fsg_function_setup\n");
+	/* Handle Bulk-only class-specific requests */
+	if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS) {
+	DBG(fsg, "USB_TYPE_CLASS\n");
+		switch (ctrl->bRequest) {
+		case USB_BULK_RESET_REQUEST:
+			if (ctrl->bRequestType != (USB_DIR_OUT |
+					USB_TYPE_CLASS | USB_RECIP_INTERFACE))
+				break;
+			//by ss1, 
+			//in case of static w_index(= 0 interface ID for android_adb)
+			//if (w_index != 0 || w_value != 0) {
+			//change dynamic inteface id 
+			if ( w_index != intf_desc.bInterfaceNumber || w_value != 0 || w_length != 0) {
+				ERROR(fsg, " USB_BULK_RESET_REQUEST: w_index != intf_desc.bInterfaceNumber || w_value != 0|| w_length != 0\n");
+				value = -EDOM;
+				break;
+			}
+
+			DBG(fsg, "[%s] USB_BULK_RESET_REQUEST\n", __func__);			 
+			
+			/* Raise an exception to stop the current operation
+			 * and reinitialize our state. */
+			raise_exception(fsg, FSG_STATE_RESET);
+			value = 0;
+			break;
+
+		case USB_BULK_GET_MAX_LUN_REQUEST:
+			if (ctrl->bRequestType != (USB_DIR_IN |
+					USB_TYPE_CLASS | USB_RECIP_INTERFACE))
+				break;
+			//by ss1, in case of static w_index(= 0 interface ID for android_adb)
+			//if (w_index != 0 || w_value != 0) {
+			if ( w_index != intf_desc.bInterfaceNumber || w_value != 0 || w_length != 1) {
+				ERROR(fsg, " USB_BULK_GET_MAX_LUN_REQUEST: w_index != intf_desc.bInterfaceNumber || w_value != 0 || w_length != 1\n");
+				value = -EDOM;
+				break;
+			}
+			VDBG(fsg, "get max LUN\n");
+			*(u8 *)cdev->req->buf = fsg->nluns - 1;
+			value = 1;
+			break;
+			
+		default:			
+			VDBG(fsg,
+				"unknown class-specific control req "
+				"%02x.%02x v%04x i%04x l%u\n",
+				ctrl->bRequestType, ctrl->bRequest,
+				le16_to_cpu(ctrl->wValue), w_index, w_length);
+		}
+	}
+		
+		/* respond with data transfer or status phase? */
+		if (value >= 0) {
+			int rc;
+			cdev->req->zero = value < w_length;
+			cdev->req->length = value;
+			rc = usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);
+			if (rc < 0)
+				printk("%s setup response queue error\n", __func__);
+		}
+
+	if (value == -EOPNOTSUPP)
+		VDBG(fsg,
+			"unknown class-specific control req "
+			"%02x.%02x v%04x i%04x l%u\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			le16_to_cpu(ctrl->wValue), w_index, w_length);
+	return value;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* All the following routines run in process context */
+
+
+/* Use this for bulk or interrupt transfers, not ep0 */
+static void start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,
+		struct usb_request *req, int *pbusy,
+		enum fsg_buffer_state *state)
+{
+	int	rc;
+
+	DBG(fsg, "start_transfer req: %p, req->buf: %p\n", req, req->buf);
+	if (ep == fsg->bulk_in)
+		dump_msg(fsg, "bulk-in", req->buf, req->length);
+
+	spin_lock_irq(&fsg->lock);
+	*pbusy = 1;
+	*state = BUF_STATE_BUSY;
+	spin_unlock_irq(&fsg->lock);
+	rc = usb_ep_queue(ep, req, GFP_KERNEL);
+	if (rc != 0) {
+		*pbusy = 0;
+		*state = BUF_STATE_EMPTY;
+
+		/* We can't do much more than wait for a reset */
+
+		/* Note: currently the net2280 driver fails zero-length
+		 * submissions if DMA is enabled. */
+		if (rc != -ESHUTDOWN && !(rc == -EOPNOTSUPP &&
+						req->length == 0))
+			WARN(fsg, "error in submission: %s --> %d\n",
+				(ep == fsg->bulk_in ? "bulk-in" : "bulk-out"),
+				rc);
+	}
+}
+
+
+static int sleep_thread(struct fsg_dev *fsg)
+{
+	int	rc = 0;
+
+	/* Wait until a signal arrives or we are woken up */
+	for (;;) {
+		try_to_freeze();
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (signal_pending(current)) {
+			rc = -EINTR;
+			break;
+		}
+		if (fsg->thread_wakeup_needed)
+			break;
+		schedule();
+	}
+	__set_current_state(TASK_RUNNING);
+	fsg->thread_wakeup_needed = 0;
+	return rc;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int do_read(struct fsg_dev *fsg)
+{
+	struct lun		*curlun = fsg->curlun;
+	u32			lba;
+	struct fsg_buffhd	*bh;
+	int			rc;
+	u32			amount_left;
+	loff_t			file_offset, file_offset_tmp;
+	unsigned int		amount;
+	unsigned int		partial_page;
+	ssize_t			nread;
+
+	/* Get the starting Logical Block Address and check that it's
+	 * not too big */
+	if (fsg->cmnd[0] == SC_READ_6)
+		lba = (fsg->cmnd[1] << 16) | get_be16(&fsg->cmnd[2]);
+	else {
+		lba = get_be32(&fsg->cmnd[2]);
+
+		/* We allow DPO (Disable Page Out = don't save data in the
+		 * cache) and FUA (Force Unit Access = don't read from the
+		 * cache), but we don't implement them. */
+		if ((fsg->cmnd[1] & ~0x18) != 0) {
+			curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+			return -EINVAL;
+		}
+	}
+	if (lba >= curlun->num_sectors) {
+		curlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+		return -EINVAL;
+	}
+	file_offset = ((loff_t) lba) << 9;
+
+	/* Carry out the file reads */
+	amount_left = fsg->data_size_from_cmnd;
+	if (unlikely(amount_left == 0))
+		return -EIO;		/* No default reply */
+
+	for (;;) {
+
+		/* Figure out how much we need to read:
+		 * Try to read the remaining amount.
+		 * But don't read more than the buffer size.
+		 * And don't try to read past the end of the file.
+		 * Finally, if we're not at a page boundary, don't read past
+		 *	the next page.
+		 * If this means reading 0 then we were asked to read past
+		 *	the end of file. */
+		amount = min((unsigned int) amount_left,
+				(unsigned int)fsg->buf_size);
+		amount = min((loff_t) amount,
+				curlun->file_length - file_offset);
+		partial_page = file_offset & (PAGE_CACHE_SIZE - 1);
+		if (partial_page > 0)
+			amount = min(amount, (unsigned int) PAGE_CACHE_SIZE -
+					partial_page);
+
+		/* Wait for the next buffer to become available */
+		bh = fsg->next_buffhd_to_fill;
+		while (bh->state != BUF_STATE_EMPTY) {
+			rc = sleep_thread(fsg);
+			if (rc)
+				return rc;
+		}
+
+		/* If we were asked to read past the end of file,
+		 * end with an empty buffer. */
+		if (amount == 0) {
+			curlun->sense_data =
+					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+			curlun->sense_data_info = file_offset >> 9;
+			curlun->info_valid = 1;
+			bh->inreq->length = 0;
+			bh->state = BUF_STATE_FULL;
+			break;
+		}
+
+		/* Perform the read */
+		file_offset_tmp = file_offset;
+		nread = vfs_read(curlun->filp,
+				(char __user *) bh->buf,
+				amount, &file_offset_tmp);
+		VLDBG(curlun, "file read %u @ %llu -> %d\n", amount,
+				(unsigned long long) file_offset,
+				(int) nread);
+		if (signal_pending(current))
+			return -EINTR;
+
+		if (nread < 0) {
+			LDBG(curlun, "error in file read: %d\n",
+					(int) nread);
+			nread = 0;
+		} else if (nread < amount) {
+			LDBG(curlun, "partial file read: %d/%u\n",
+					(int) nread, amount);
+			nread -= (nread & 511);	/* Round down to a block */
+		}
+		file_offset  += nread;
+		amount_left  -= nread;
+		fsg->residue -= nread;
+		bh->inreq->length = nread;
+		bh->state = BUF_STATE_FULL;
+
+		/* If an error occurred, report it and its position */
+		if (nread < amount) {
+			curlun->sense_data = SS_UNRECOVERED_READ_ERROR;
+			curlun->sense_data_info = file_offset >> 9;
+			curlun->info_valid = 1;
+			break;
+		}
+
+		if (amount_left == 0)
+			break;		/* No more left to read */
+
+		/* Send this buffer and go read some more */
+		start_transfer(fsg, fsg->bulk_in, bh->inreq,
+				&bh->inreq_busy, &bh->state);
+		fsg->next_buffhd_to_fill = bh->next;
+	}
+
+	return -EIO;		/* No default reply */
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int do_write(struct fsg_dev *fsg)
+{
+	struct lun		*curlun = fsg->curlun;
+	u32			lba;
+	struct fsg_buffhd	*bh;
+	int			get_some_more;
+	u32			amount_left_to_req, amount_left_to_write;
+	loff_t			usb_offset, file_offset, file_offset_tmp;
+	unsigned int		amount;
+	unsigned int		partial_page;
+	ssize_t			nwritten;
+	int			rc;
+
+	if (curlun->ro) {
+		curlun->sense_data = SS_WRITE_PROTECTED;
+		return -EINVAL;
+	}
+	curlun->filp->f_flags &= ~O_SYNC;	/* Default is not to wait */
+
+	/* Get the starting Logical Block Address and check that it's
+	 * not too big */
+	if (fsg->cmnd[0] == SC_WRITE_6)
+		lba = (fsg->cmnd[1] << 16) | get_be16(&fsg->cmnd[2]);
+	else {
+		lba = get_be32(&fsg->cmnd[2]);
+
+		/* We allow DPO (Disable Page Out = don't save data in the
+		 * cache) and FUA (Force Unit Access = write directly to the
+		 * medium).  We don't implement DPO; we implement FUA by
+		 * performing synchronous output. */
+		if ((fsg->cmnd[1] & ~0x18) != 0) {
+			curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+			return -EINVAL;
+		}
+		if (fsg->cmnd[1] & 0x08)	/* FUA */
+			curlun->filp->f_flags |= O_SYNC;
+	}
+	if (lba >= curlun->num_sectors) {
+		curlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+		return -EINVAL;
+	}
+
+	/* Carry out the file writes */
+	get_some_more = 1;
+	file_offset = usb_offset = ((loff_t) lba) << 9;
+	amount_left_to_req = amount_left_to_write = fsg->data_size_from_cmnd;
+
+	while (amount_left_to_write > 0) {
+
+		/* Queue a request for more data from the host */
+		bh = fsg->next_buffhd_to_fill;
+		if (bh->state == BUF_STATE_EMPTY && get_some_more) {
+
+			/* Figure out how much we want to get:
+			 * Try to get the remaining amount.
+			 * But don't get more than the buffer size.
+			 * And don't try to go past the end of the file.
+			 * If we're not at a page boundary,
+			 *	don't go past the next page.
+			 * If this means getting 0, then we were asked
+			 *	to write past the end of file.
+			 * Finally, round down to a block boundary. */
+			amount = min(amount_left_to_req, (u32)fsg->buf_size);
+			amount = min((loff_t) amount, curlun->file_length -
+					usb_offset);
+			partial_page = usb_offset & (PAGE_CACHE_SIZE - 1);
+			if (partial_page > 0)
+				amount = min(amount,
+	(unsigned int) PAGE_CACHE_SIZE - partial_page);
+
+			if (amount == 0) {
+				get_some_more = 0;
+				curlun->sense_data =
+					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+				curlun->sense_data_info = usb_offset >> 9;
+				curlun->info_valid = 1;
+				continue;
+			}
+			amount -= (amount & 511);
+			if (amount == 0) {
+
+				/* Why were we were asked to transfer a
+				 * partial block? */
+				get_some_more = 0;
+				continue;
+			}
+
+			/* Get the next buffer */
+			usb_offset += amount;
+			fsg->usb_amount_left -= amount;
+			amount_left_to_req -= amount;
+			if (amount_left_to_req == 0)
+				get_some_more = 0;
+
+			/* amount is always divisible by 512, hence by
+			 * the bulk-out maxpacket size */
+			bh->outreq->length = bh->bulk_out_intended_length =
+					amount;
+			start_transfer(fsg, fsg->bulk_out, bh->outreq,
+					&bh->outreq_busy, &bh->state);
+			fsg->next_buffhd_to_fill = bh->next;
+			continue;
+		}
+
+		/* Write the received data to the backing file */
+		bh = fsg->next_buffhd_to_drain;
+		if (bh->state == BUF_STATE_EMPTY && !get_some_more)
+			break;			/* We stopped early */
+		if (bh->state == BUF_STATE_FULL) {
+			smp_rmb();
+			fsg->next_buffhd_to_drain = bh->next;
+			bh->state = BUF_STATE_EMPTY;
+
+			/* Did something go wrong with the transfer? */
+			if (bh->outreq->status != 0) {
+				curlun->sense_data = SS_COMMUNICATION_FAILURE;
+				curlun->sense_data_info = file_offset >> 9;
+				curlun->info_valid = 1;
+				break;
+			}
+
+			amount = bh->outreq->actual;
+			if (curlun->file_length - file_offset < amount) {
+				LERROR(curlun,
+	"write %u @ %llu beyond end %llu\n",
+	amount, (unsigned long long) file_offset,
+	(unsigned long long) curlun->file_length);
+				amount = curlun->file_length - file_offset;
+			}
+
+			/* Perform the write */
+			file_offset_tmp = file_offset;
+			nwritten = vfs_write(curlun->filp,
+					(char __user *) bh->buf,
+					amount, &file_offset_tmp);
+			VLDBG(curlun, "file write %u @ %llu -> %d\n", amount,
+					(unsigned long long) file_offset,
+					(int) nwritten);
+			if (signal_pending(current))
+				return -EINTR;		/* Interrupted! */
+
+			if (nwritten < 0) {
+				LDBG(curlun, "error in file write: %d\n",
+						(int) nwritten);
+				nwritten = 0;
+			} else if (nwritten < amount) {
+				LDBG(curlun, "partial file write: %d/%u\n",
+						(int) nwritten, amount);
+				nwritten -= (nwritten & 511);
+						/* Round down to a block */
+			}
+			file_offset += nwritten;
+			amount_left_to_write -= nwritten;
+			fsg->residue -= nwritten;
+
+			/* If an error occurred, report it and its position */
+			if (nwritten < amount) {
+				curlun->sense_data = SS_WRITE_ERROR;
+				curlun->sense_data_info = file_offset >> 9;
+				curlun->info_valid = 1;
+				break;
+			}
+
+			/* Did the host decide to stop early? */
+			if (bh->outreq->actual != bh->outreq->length) {
+				fsg->short_packet_received = 1;
+				break;
+			}
+			continue;
+		}
+
+		/* Wait for something to happen */
+		rc = sleep_thread(fsg);
+		if (rc)
+			return rc;
+	}
+
+	return -EIO;		/* No default reply */
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* Sync the file data, don't bother with the metadata.
+ * The caller must own fsg->filesem.
+ * This code was copied from fs/buffer.c:sys_fdatasync(). */
+static int fsync_sub(struct lun *curlun)
+{
+	struct file	*filp = curlun->filp;
+	struct inode	*inode;
+	int		rc, err;
+
+	if (curlun->ro || !filp)
+		return 0;
+	if (!filp->f_op->fsync)
+		return -EINVAL;
+
+	inode = filp->f_path.dentry->d_inode;
+	mutex_lock(&inode->i_mutex);
+	rc = filemap_fdatawrite(inode->i_mapping);
+	err = filp->f_op->fsync(filp, filp->f_path.dentry, 1);
+	if (!rc)
+		rc = err;
+	err = filemap_fdatawait(inode->i_mapping);
+	if (!rc)
+		rc = err;
+	mutex_unlock(&inode->i_mutex);
+	VLDBG(curlun, "fdatasync -> %d\n", rc);
+	return rc;
+}
+
+static void fsync_all(struct fsg_dev *fsg)
+{
+	int	i;
+
+	for (i = 0; i < fsg->nluns; ++i)
+		fsync_sub(&fsg->luns[i]);
+}
+
+static int do_synchronize_cache(struct fsg_dev *fsg)
+{
+	struct lun	*curlun = fsg->curlun;
+	int		rc;
+
+	/* We ignore the requested LBA and write out all file's
+	 * dirty data buffers. */
+	rc = fsync_sub(curlun);
+	if (rc)
+		curlun->sense_data = SS_WRITE_ERROR;
+	return 0;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static void invalidate_sub(struct lun *curlun)
+{
+	struct file	*filp = curlun->filp;
+	struct inode	*inode = filp->f_path.dentry->d_inode;
+	unsigned long	rc;
+
+	rc = invalidate_mapping_pages(inode->i_mapping, 0, -1);
+	VLDBG(curlun, "invalidate_inode_pages -> %ld\n", rc);
+}
+
+static int do_verify(struct fsg_dev *fsg)
+{
+	struct lun		*curlun = fsg->curlun;
+	u32			lba;
+	u32			verification_length;
+	struct fsg_buffhd	*bh = fsg->next_buffhd_to_fill;
+	loff_t			file_offset, file_offset_tmp;
+	u32			amount_left;
+	unsigned int		amount;
+	ssize_t			nread;
+
+	/* Get the starting Logical Block Address and check that it's
+	 * not too big */
+	lba = get_be32(&fsg->cmnd[2]);
+	if (lba >= curlun->num_sectors) {
+		curlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+		return -EINVAL;
+	}
+
+	/* We allow DPO (Disable Page Out = don't save data in the
+	 * cache) but we don't implement it. */
+	if ((fsg->cmnd[1] & ~0x10) != 0) {
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+
+	verification_length = get_be16(&fsg->cmnd[7]);
+	if (unlikely(verification_length == 0))
+		return -EIO;		/* No default reply */
+
+	/* Prepare to carry out the file verify */
+	amount_left = verification_length << 9;
+	file_offset = ((loff_t) lba) << 9;
+
+	/* Write out all the dirty buffers before invalidating them */
+	fsync_sub(curlun);
+	if (signal_pending(current))
+		return -EINTR;
+
+	invalidate_sub(curlun);
+	if (signal_pending(current))
+		return -EINTR;
+
+	/* Just try to read the requested blocks */
+	while (amount_left > 0) {
+
+		/* Figure out how much we need to read:
+		 * Try to read the remaining amount, but not more than
+		 * the buffer size.
+		 * And don't try to read past the end of the file.
+		 * If this means reading 0 then we were asked to read
+		 * past the end of file. */
+		amount = min((unsigned int) amount_left,
+				(unsigned int)fsg->buf_size);
+		amount = min((loff_t) amount,
+				curlun->file_length - file_offset);
+		if (amount == 0) {
+			curlun->sense_data =
+					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+			curlun->sense_data_info = file_offset >> 9;
+			curlun->info_valid = 1;
+			break;
+		}
+
+		/* Perform the read */
+		file_offset_tmp = file_offset;
+		nread = vfs_read(curlun->filp,
+				(char __user *) bh->buf,
+				amount, &file_offset_tmp);
+		VLDBG(curlun, "file read %u @ %llu -> %d\n", amount,
+				(unsigned long long) file_offset,
+				(int) nread);
+		if (signal_pending(current))
+			return -EINTR;
+
+		if (nread < 0) {
+			LDBG(curlun, "error in file verify: %d\n",
+					(int) nread);
+			nread = 0;
+		} else if (nread < amount) {
+			LDBG(curlun, "partial file verify: %d/%u\n",
+					(int) nread, amount);
+			nread -= (nread & 511);	/* Round down to a sector */
+		}
+		if (nread == 0) {
+			curlun->sense_data = SS_UNRECOVERED_READ_ERROR;
+			curlun->sense_data_info = file_offset >> 9;
+			curlun->info_valid = 1;
+			break;
+		}
+		file_offset += nread;
+		amount_left -= nread;
+	}
+	return 0;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int do_inquiry(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	u8	*buf = (u8 *) bh->buf;
+
+	static char vendor_id[] = "Android   ";
+	static char product_id[] = "UMS Composite";
+
+	if (!fsg->curlun) {		/* Unsupported LUNs are okay */
+		fsg->bad_lun_okay = 1;
+		memset(buf, 0, 36);
+		buf[0] = 0x7f;		/* Unsupported, no device-type */
+		return 36;
+	}
+
+	memset(buf, 0, 8);	/* Non-removable, direct-access device */
+
+	buf[1] = 0x80;	/* set removable bit */
+	buf[2] = 2;		/* ANSI SCSI level 2 */
+	buf[3] = 2;		/* SCSI-2 INQUIRY data format */
+	buf[4] = 31;		/* Additional length */
+				/* No special options */
+
+#define CONFIG_SAMSUNG_KIES_UMS_SUPPORT
+#define CONFIG_SAMSUNG_MODEL_NAME			"GT-I5700"
+
+#if defined(CONFIG_SAMSUNG_KIES_UMS_SUPPORT) && defined(CONFIG_SAMSUNG_MODEL_NAME)
+	{
+		u8 model_name[16];
+
+		strncpy(model_name, CONFIG_SAMSUNG_MODEL_NAME , sizeof(model_name));
+
+		/* Internal Device :Phone, External Device : Card */
+		sprintf(buf + 8, "%s - %s", model_name, "Card");
+		
+//		printk("model_name = %s, buf+8=%s\n",model_name, buf+8);
+	}
+#else
+
+	//by ss1
+	#if 0
+		sprintf(buf + 8, "%-8s%-16s%04x", fsg->vendor,
+				fsg->product, fsg->release);
+	#else
+		sprintf(buf + 8, "%-8s%-16s%04x", vendor_id,
+				product_id, fsg->release);
+	#endif
+
+#endif
+	return 36;
+}
+
+
+static int do_request_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun	*curlun = fsg->curlun;
+	u8		*buf = (u8 *) bh->buf;
+	u32		sd, sdinfo;
+	int		valid;
+
+	/*
+	 * From the SCSI-2 spec., section 7.9 (Unit attention condition):
+	 *
+	 * If a REQUEST SENSE command is received from an initiator
+	 * with a pending unit attention condition (before the target
+	 * generates the contingent allegiance condition), then the
+	 * target shall either:
+	 *   a) report any pending sense data and preserve the unit
+	 *	attention condition on the logical unit, or,
+	 *   b) report the unit attention condition, may discard any
+	 *	pending sense data, and clear the unit attention
+	 *	condition on the logical unit for that initiator.
+	 *
+	 * FSG normally uses option a); enable this code to use option b).
+	 */
+#if 0
+	if (curlun && curlun->unit_attention_data != SS_NO_SENSE) {
+		curlun->sense_data = curlun->unit_attention_data;
+		curlun->unit_attention_data = SS_NO_SENSE;
+	}
+#endif
+
+	if (!curlun) {		/* Unsupported LUNs are okay */
+		fsg->bad_lun_okay = 1;
+		sd = SS_LOGICAL_UNIT_NOT_SUPPORTED;
+		sdinfo = 0;
+		valid = 0;
+	} else {
+		sd = curlun->sense_data;
+		sdinfo = curlun->sense_data_info;
+		valid = curlun->info_valid << 7;
+		curlun->sense_data = SS_NO_SENSE;
+		curlun->sense_data_info = 0;
+		curlun->info_valid = 0;
+	}
+
+	memset(buf, 0, 18);
+	buf[0] = valid | 0x70;			/* Valid, current error */
+	buf[2] = SK(sd);
+	put_be32(&buf[3], sdinfo);		/* Sense information */
+	buf[7] = 18 - 8;			/* Additional sense length */
+	buf[12] = ASC(sd);
+	buf[13] = ASCQ(sd);
+	return 18;
+}
+
+
+static int do_read_capacity(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun	*curlun = fsg->curlun;
+	u32		lba = get_be32(&fsg->cmnd[2]);
+	int		pmi = fsg->cmnd[8];
+	u8		*buf = (u8 *) bh->buf;
+
+	/* Check the PMI and LBA fields */
+	if (pmi > 1 || (pmi == 0 && lba != 0)) {
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+
+	put_be32(&buf[0], curlun->num_sectors - 1);	/* Max logical block */
+	put_be32(&buf[4], 512);				/* Block length */
+	return 8;
+}
+
+
+static int do_mode_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun	*curlun = fsg->curlun;
+	int		mscmnd = fsg->cmnd[0];
+	u8		*buf = (u8 *) bh->buf;
+	u8		*buf0 = buf;
+	int		pc, page_code;
+	int		changeable_values, all_pages;
+	int		valid_page = 0;
+	int		len, limit;
+
+	if ((fsg->cmnd[1] & ~0x08) != 0) {		/* Mask away DBD */
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+	pc = fsg->cmnd[2] >> 6;
+	page_code = fsg->cmnd[2] & 0x3f;
+	if (pc == 3) {
+		curlun->sense_data = SS_SAVING_PARAMETERS_NOT_SUPPORTED;
+		return -EINVAL;
+	}
+	changeable_values = (pc == 1);
+	all_pages = (page_code == 0x3f);
+
+	/* Write the mode parameter header.  Fixed values are: default
+	 * medium type, no cache control (DPOFUA), and no block descriptors.
+	 * The only variable value is the WriteProtect bit.  We will fill in
+	 * the mode data length later. */
+	memset(buf, 0, 8);
+	if (mscmnd == SC_MODE_SENSE_6) {
+		buf[2] = (curlun->ro ? 0x80 : 0x00);		/* WP, DPOFUA */
+		buf += 4;
+		limit = 255;
+	} else {			/* SC_MODE_SENSE_10 */
+		buf[3] = (curlun->ro ? 0x80 : 0x00);		/* WP, DPOFUA */
+		buf += 8;
+		limit = 65535;
+	}
+
+	/* No block descriptors */
+
+	/* Disabled to workaround USB reset problems with a Vista host.
+	 */
+#if 0
+	/* The mode pages, in numerical order.  The only page we support
+	 * is the Caching page. */
+	if (page_code == 0x08 || all_pages) {
+		valid_page = 1;
+		buf[0] = 0x08;		/* Page code */
+		buf[1] = 10;		/* Page length */
+		memset(buf+2, 0, 10);	/* None of the fields are changeable */
+
+		if (!changeable_values) {
+			buf[2] = 0x04;	/* Write cache enable, */
+					/* Read cache not disabled */
+					/* No cache retention priorities */
+			put_be16(&buf[4], 0xffff);  /* Don't disable prefetch */
+					/* Minimum prefetch = 0 */
+			put_be16(&buf[8], 0xffff);  /* Maximum prefetch */
+			/* Maximum prefetch ceiling */
+			put_be16(&buf[10], 0xffff);
+		}
+		buf += 12;
+	}
+#else
+	valid_page = 1;
+#endif
+
+	/* Check that a valid page was requested and the mode data length
+	 * isn't too long. */
+	len = buf - buf0;
+	if (!valid_page || len > limit) {
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+
+	/*  Store the mode data length */
+	if (mscmnd == SC_MODE_SENSE_6)
+		buf0[0] = len - 1;
+	else
+		put_be16(buf0, len - 2);
+	return len;
+}
+
+static int do_start_stop(struct fsg_dev *fsg)
+{
+	struct lun	*curlun = fsg->curlun;
+	int		loej, start;
+
+	/* int immed = fsg->cmnd[1] & 0x01; */
+	loej = fsg->cmnd[4] & 0x02;
+	start = fsg->cmnd[4] & 0x01;
+
+	if (loej) {
+		/* eject request from the host */
+		if (backing_file_is_open(curlun)) {
+			close_backing_file(fsg, curlun);
+			curlun->unit_attention_data = SS_MEDIUM_NOT_PRESENT;
+		}
+	}
+
+	return 0;
+}
+
+static int do_prevent_allow(struct fsg_dev *fsg)
+{
+	struct lun	*curlun = fsg->curlun;
+	int		prevent;
+
+	prevent = fsg->cmnd[4] & 0x01;
+	if ((fsg->cmnd[4] & ~0x01) != 0) {		/* Mask away Prevent */
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+
+	if (curlun->prevent_medium_removal && !prevent)
+		fsync_sub(curlun);
+	curlun->prevent_medium_removal = prevent;
+	return 0;
+}
+
+
+static int do_read_format_capacities(struct fsg_dev *fsg,
+			struct fsg_buffhd *bh)
+{
+	struct lun	*curlun = fsg->curlun;
+	u8		*buf = (u8 *) bh->buf;
+
+	buf[0] = buf[1] = buf[2] = 0;
+	buf[3] = 8;	/* Only the Current/Maximum Capacity Descriptor */
+	buf += 4;
+
+	put_be32(&buf[0], curlun->num_sectors);	/* Number of blocks */
+	put_be32(&buf[4], 512);				/* Block length */
+	buf[4] = 0x02;					/* Current capacity */
+	return 12;
+}
+
+
+static int do_mode_select(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun	*curlun = fsg->curlun;
+
+	/* We don't support MODE SELECT */
+	curlun->sense_data = SS_INVALID_COMMAND;
+	return -EINVAL;
+}
+
+
+/*-------------------------------------------------------------------------*/
+#if 0
+static int write_zero(struct fsg_dev *fsg)
+{
+	struct fsg_buffhd	*bh;
+	int			rc;
+
+	DBG(fsg, "write_zero\n");
+	/* Wait for the next buffer to become available */
+	bh = fsg->next_buffhd_to_fill;
+	while (bh->state != BUF_STATE_EMPTY) {
+		rc = sleep_thread(fsg);
+		if (rc)
+			return rc;
+	}
+
+	bh->inreq->length = 0;
+	start_transfer(fsg, fsg->bulk_in, bh->inreq,
+			&bh->inreq_busy, &bh->state);
+
+	fsg->next_buffhd_to_fill = bh->next;
+	return 0;
+}
+#endif
+
+static int throw_away_data(struct fsg_dev *fsg)
+{
+	struct fsg_buffhd	*bh;
+	u32			amount;
+	int			rc;
+
+	DBG(fsg, "throw_away_data\n");
+	while ((bh = fsg->next_buffhd_to_drain)->state != BUF_STATE_EMPTY ||
+			fsg->usb_amount_left > 0) {
+
+		/* Throw away the data in a filled buffer */
+		if (bh->state == BUF_STATE_FULL) {
+			smp_rmb();
+			bh->state = BUF_STATE_EMPTY;
+			fsg->next_buffhd_to_drain = bh->next;
+
+			/* A short packet or an error ends everything */
+			if (bh->outreq->actual != bh->outreq->length ||
+					bh->outreq->status != 0) {
+				raise_exception(fsg, FSG_STATE_ABORT_BULK_OUT);
+				return -EINTR;
+			}
+			continue;
+		}
+
+		/* Try to submit another request if we need one */
+		bh = fsg->next_buffhd_to_fill;
+		if (bh->state == BUF_STATE_EMPTY && fsg->usb_amount_left > 0) {
+			amount = min(fsg->usb_amount_left, (u32) fsg->buf_size);
+
+			/* amount is always divisible by 512, hence by
+			 * the bulk-out maxpacket size */
+			bh->outreq->length = bh->bulk_out_intended_length =
+					amount;
+			start_transfer(fsg, fsg->bulk_out, bh->outreq,
+					&bh->outreq_busy, &bh->state);
+			fsg->next_buffhd_to_fill = bh->next;
+			fsg->usb_amount_left -= amount;
+			continue;
+		}
+
+		/* Otherwise wait for something to happen */
+		rc = sleep_thread(fsg);
+		if (rc)
+			return rc;
+	}
+	return 0;
+}
+
+
+static int finish_reply(struct fsg_dev *fsg)
+{
+	struct fsg_buffhd	*bh = fsg->next_buffhd_to_fill;
+	int			rc = 0;
+
+	switch (fsg->data_dir) {
+	case DATA_DIR_NONE:
+		break;			/* Nothing to send */
+
+	case DATA_DIR_UNKNOWN:
+		rc = -EINVAL;
+		break;
+
+	/* All but the last buffer of data must have already been sent */
+	case DATA_DIR_TO_HOST:
+		if (fsg->data_size == 0)
+			;		/* Nothing to send */
+
+		/* If there's no residue, simply send the last buffer */
+		else if (fsg->residue == 0) {
+			start_transfer(fsg, fsg->bulk_in, bh->inreq,
+					&bh->inreq_busy, &bh->state);
+			fsg->next_buffhd_to_fill = bh->next;
+		} else {
+			start_transfer(fsg, fsg->bulk_in, bh->inreq,
+					&bh->inreq_busy, &bh->state);
+			fsg->next_buffhd_to_fill = bh->next;
+#if 0
+			/* this is unnecessary, and was causing problems with MacOS */
+			if (bh->inreq->length > 0)
+				write_zero(fsg);
+#endif
+		}
+		break;
+
+	/* We have processed all we want from the data the host has sent.
+	 * There may still be outstanding bulk-out requests. */
+	case DATA_DIR_FROM_HOST:
+		if (fsg->residue == 0)
+			;		/* Nothing to receive */
+
+		/* Did the host stop sending unexpectedly early? */
+		else if (fsg->short_packet_received) {
+			raise_exception(fsg, FSG_STATE_ABORT_BULK_OUT);
+			rc = -EINTR;
+		}
+
+		/* We haven't processed all the incoming data.  Even though
+		 * we may be allowed to stall, doing so would cause a race.
+		 * The controller may already have ACK'ed all the remaining
+		 * bulk-out packets, in which case the host wouldn't see a
+		 * STALL.  Not realizing the endpoint was halted, it wouldn't
+		 * clear the halt -- leading to problems later on. */
+#if 0
+		fsg_set_halt(fsg, fsg->bulk_out);
+		raise_exception(fsg, FSG_STATE_ABORT_BULK_OUT);
+		rc = -EINTR;
+#endif
+
+		/* We can't stall.  Read in the excess data and throw it
+		 * all away. */
+		else
+			rc = throw_away_data(fsg);
+		break;
+	}
+	return rc;
+}
+
+
+static int send_status(struct fsg_dev *fsg)
+{
+	struct lun		*curlun = fsg->curlun;
+	struct fsg_buffhd	*bh;
+	int			rc;
+	u8			status = USB_STATUS_PASS;
+	u32			sd, sdinfo = 0;
+	struct bulk_cs_wrap	*csw;
+
+	DBG(fsg, "send_status\n");
+	/* Wait for the next buffer to become available */
+	bh = fsg->next_buffhd_to_fill;
+	while (bh->state != BUF_STATE_EMPTY) {
+		rc = sleep_thread(fsg);
+		if (rc)
+			return rc;
+	}
+
+	if (curlun) {
+		sd = curlun->sense_data;
+		sdinfo = curlun->sense_data_info;
+	} else if (fsg->bad_lun_okay)
+		sd = SS_NO_SENSE;
+	else
+		sd = SS_LOGICAL_UNIT_NOT_SUPPORTED;
+
+	if (fsg->phase_error) {
+		DBG(fsg, "sending phase-error status\n");
+		status = USB_STATUS_PHASE_ERROR;
+		sd = SS_INVALID_COMMAND;
+	} else if (sd != SS_NO_SENSE) {
+		DBG(fsg, "sending command-failure status\n");
+		status = USB_STATUS_FAIL;
+		VDBG(fsg, "  sense data: SK x%02x, ASC x%02x, ASCQ x%02x;"
+				"  info x%x\n",
+				SK(sd), ASC(sd), ASCQ(sd), sdinfo);
+	}
+
+	csw = bh->buf;
+
+	/* Store and send the Bulk-only CSW */
+	csw->Signature = __constant_cpu_to_le32(USB_BULK_CS_SIG);
+	csw->Tag = fsg->tag;
+	csw->Residue = cpu_to_le32(fsg->residue);
+	csw->Status = status;
+
+	bh->inreq->length = USB_BULK_CS_WRAP_LEN;
+	start_transfer(fsg, fsg->bulk_in, bh->inreq,
+			&bh->inreq_busy, &bh->state);
+
+	fsg->next_buffhd_to_fill = bh->next;
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* Check whether the command is properly formed and whether its data size
+ * and direction agree with the values we already have. */
+static int check_command(struct fsg_dev *fsg, int cmnd_size,
+		enum data_direction data_dir, unsigned int mask,
+		int needs_medium, const char *name)
+{
+	int			i;
+	int			lun = fsg->cmnd[1] >> 5;
+	static const char	dirletter[4] = {'u', 'o', 'i', 'n'};
+	char			hdlen[20];
+	struct lun		*curlun;
+
+	hdlen[0] = 0;
+	if (fsg->data_dir != DATA_DIR_UNKNOWN)
+		sprintf(hdlen, ", H%c=%u", dirletter[(int) fsg->data_dir],
+				fsg->data_size);
+	VDBG(fsg, "SCSI command: %s;  Dc=%d, D%c=%u;  Hc=%d%s\n",
+			name, cmnd_size, dirletter[(int) data_dir],
+			fsg->data_size_from_cmnd, fsg->cmnd_size, hdlen);
+
+	/* We can't reply at all until we know the correct data direction
+	 * and size. */
+	if (fsg->data_size_from_cmnd == 0)
+		data_dir = DATA_DIR_NONE;
+	if (fsg->data_dir == DATA_DIR_UNKNOWN) {	/* CB or CBI */
+		fsg->data_dir = data_dir;
+		fsg->data_size = fsg->data_size_from_cmnd;
+
+	} else {					/* Bulk-only */
+		if (fsg->data_size < fsg->data_size_from_cmnd) {
+
+			/* Host data size < Device data size is a phase error.
+			 * Carry out the command, but only transfer as much
+			 * as we are allowed. */
+			DBG(fsg, "phase error 1\n");
+			fsg->data_size_from_cmnd = fsg->data_size;
+			fsg->phase_error = 1;
+		}
+	}
+	fsg->residue = fsg->usb_amount_left = fsg->data_size;
+
+	/* Conflicting data directions is a phase error */
+	if (fsg->data_dir != data_dir && fsg->data_size_from_cmnd > 0) {
+		fsg->phase_error = 1;
+		DBG(fsg, "phase error 2\n");
+		return -EINVAL;
+	}
+
+	/* Verify the length of the command itself */
+	if (cmnd_size != fsg->cmnd_size) {
+
+		/* Special case workaround: MS-Windows issues REQUEST SENSE
+		 * with cbw->Length == 12 (it should be 6). */
+		if (fsg->cmnd[0] == SC_REQUEST_SENSE && fsg->cmnd_size == 12)
+			cmnd_size = fsg->cmnd_size;
+		else {
+			fsg->phase_error = 1;
+			return -EINVAL;
+		}
+	}
+
+	/* Check that the LUN values are consistent */
+	if (fsg->lun != lun)
+		DBG(fsg, "using LUN %d from CBW, "
+				"not LUN %d from CDB\n",
+				fsg->lun, lun);
+
+	/* Check the LUN */
+	if (fsg->lun >= 0 && fsg->lun < fsg->nluns) {
+		fsg->curlun = curlun = &fsg->luns[fsg->lun];
+		if (fsg->cmnd[0] != SC_REQUEST_SENSE) {
+			curlun->sense_data = SS_NO_SENSE;
+			curlun->sense_data_info = 0;
+			curlun->info_valid = 0;
+		}
+	} else {
+		fsg->curlun = curlun = NULL;
+		fsg->bad_lun_okay = 0;
+
+		/* INQUIRY and REQUEST SENSE commands are explicitly allowed
+		 * to use unsupported LUNs; all others may not. */
+		if (fsg->cmnd[0] != SC_INQUIRY &&
+				fsg->cmnd[0] != SC_REQUEST_SENSE) {
+			DBG(fsg, "unsupported LUN %d\n", fsg->lun);
+			return -EINVAL;
+		}
+	}
+
+	/* If a unit attention condition exists, only INQUIRY and
+	 * REQUEST SENSE commands are allowed; anything else must fail. */
+	if (curlun && curlun->unit_attention_data != SS_NO_SENSE &&
+			fsg->cmnd[0] != SC_INQUIRY &&
+			fsg->cmnd[0] != SC_REQUEST_SENSE) {
+		curlun->sense_data = curlun->unit_attention_data;
+		curlun->unit_attention_data = SS_NO_SENSE;
+		return -EINVAL;
+	}
+
+	/* Check that only command bytes listed in the mask are non-zero */
+	fsg->cmnd[1] &= 0x1f;			/* Mask away the LUN */
+	for (i = 1; i < cmnd_size; ++i) {
+		if (fsg->cmnd[i] && !(mask & (1 << i))) {
+			if (curlun)
+				curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+			DBG(fsg, "SS_INVALID_FIELD_IN_CDB\n");
+			return -EINVAL;
+		}
+	}
+
+	/* If the medium isn't mounted and the command needs to access
+	 * it, return an error. */
+	if (curlun && !backing_file_is_open(curlun) && needs_medium) {
+		curlun->sense_data = SS_MEDIUM_NOT_PRESENT;
+		DBG(fsg, "SS_MEDIUM_NOT_PRESENT\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int do_scsi_command(struct fsg_dev *fsg)
+{
+	struct fsg_buffhd	*bh;
+	int			rc;
+	int			reply = -EINVAL;
+	int			i;
+	static char		unknown[16];
+
+	dump_cdb(fsg);
+
+	/* Wait for the next buffer to become available for data or status */
+	bh = fsg->next_buffhd_to_drain = fsg->next_buffhd_to_fill;
+	while (bh->state != BUF_STATE_EMPTY) {
+		rc = sleep_thread(fsg);
+		if (rc)
+			return rc;
+	}
+	fsg->phase_error = 0;
+	fsg->short_packet_received = 0;
+
+	down_read(&fsg->filesem);	/* We're using the backing file */
+	switch (fsg->cmnd[0]) {
+
+	case SC_INQUIRY:
+		fsg->data_size_from_cmnd = fsg->cmnd[4];
+		if ((reply = check_command(fsg, 6, DATA_DIR_TO_HOST,
+				(1<<4), 0,
+				"INQUIRY")) == 0)
+			reply = do_inquiry(fsg, bh);
+		break;
+
+	case SC_MODE_SELECT_6:
+		fsg->data_size_from_cmnd = fsg->cmnd[4];
+		if ((reply = check_command(fsg, 6, DATA_DIR_FROM_HOST,
+				(1<<1) | (1<<4), 0,
+				"MODE SELECT(6)")) == 0)
+			reply = do_mode_select(fsg, bh);
+		break;
+
+	case SC_MODE_SELECT_10:
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
+		if ((reply = check_command(fsg, 10, DATA_DIR_FROM_HOST,
+				(1<<1) | (3<<7), 0,
+				"MODE SELECT(10)")) == 0)
+			reply = do_mode_select(fsg, bh);
+		break;
+
+	case SC_MODE_SENSE_6:
+		fsg->data_size_from_cmnd = fsg->cmnd[4];
+		if ((reply = check_command(fsg, 6, DATA_DIR_TO_HOST,
+				(1<<1) | (1<<2) | (1<<4), 0,
+				"MODE SENSE(6)")) == 0)
+			reply = do_mode_sense(fsg, bh);
+		break;
+
+	case SC_MODE_SENSE_10:
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
+		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
+				(1<<1) | (1<<2) | (3<<7), 0,
+				"MODE SENSE(10)")) == 0)
+			reply = do_mode_sense(fsg, bh);
+		break;
+
+	case SC_PREVENT_ALLOW_MEDIUM_REMOVAL:
+		fsg->data_size_from_cmnd = 0;
+		if ((reply = check_command(fsg, 6, DATA_DIR_NONE,
+				(1<<4), 0,
+				"PREVENT-ALLOW MEDIUM REMOVAL")) == 0)
+			reply = do_prevent_allow(fsg);
+		break;
+
+	case SC_READ_6:
+		i = fsg->cmnd[4];
+		fsg->data_size_from_cmnd = (i == 0 ? 256 : i) << 9;
+		if ((reply = check_command(fsg, 6, DATA_DIR_TO_HOST,
+				(7<<1) | (1<<4), 1,
+				"READ(6)")) == 0)
+			reply = do_read(fsg);
+		break;
+
+	case SC_READ_10:
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]) << 9;
+		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
+				(1<<1) | (0xf<<2) | (3<<7), 1,
+				"READ(10)")) == 0)
+			reply = do_read(fsg);
+		break;
+
+	case SC_READ_12:
+		fsg->data_size_from_cmnd = get_be32(&fsg->cmnd[6]) << 9;
+		if ((reply = check_command(fsg, 12, DATA_DIR_TO_HOST,
+				(1<<1) | (0xf<<2) | (0xf<<6), 1,
+				"READ(12)")) == 0)
+			reply = do_read(fsg);
+		break;
+
+	case SC_READ_CAPACITY:
+		fsg->data_size_from_cmnd = 8;
+		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
+				(0xf<<2) | (1<<8), 1,
+				"READ CAPACITY")) == 0)
+			reply = do_read_capacity(fsg, bh);
+		break;
+
+	case SC_READ_FORMAT_CAPACITIES:
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
+		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
+				(3<<7), 1,
+				"READ FORMAT CAPACITIES")) == 0)
+			reply = do_read_format_capacities(fsg, bh);
+		break;
+
+	case SC_REQUEST_SENSE:
+		fsg->data_size_from_cmnd = fsg->cmnd[4];
+		if ((reply = check_command(fsg, 6, DATA_DIR_TO_HOST,
+				(1<<4), 0,
+				"REQUEST SENSE")) == 0)
+			reply = do_request_sense(fsg, bh);
+		break;
+
+	case SC_START_STOP_UNIT:
+		fsg->data_size_from_cmnd = 0;
+		if ((reply = check_command(fsg, 6, DATA_DIR_NONE,
+				(1<<1) | (1<<4), 0,
+				"START-STOP UNIT")) == 0)
+			reply = do_start_stop(fsg);
+		break;
+
+	case SC_SYNCHRONIZE_CACHE:
+		fsg->data_size_from_cmnd = 0;
+		if ((reply = check_command(fsg, 10, DATA_DIR_NONE,
+				(0xf<<2) | (3<<7), 1,
+				"SYNCHRONIZE CACHE")) == 0)
+			reply = do_synchronize_cache(fsg);
+		break;
+
+	case SC_TEST_UNIT_READY:
+		fsg->data_size_from_cmnd = 0;
+		reply = check_command(fsg, 6, DATA_DIR_NONE,
+				0, 1,
+				"TEST UNIT READY");
+		break;
+
+	/* Although optional, this command is used by MS-Windows.  We
+	 * support a minimal version: BytChk must be 0. */
+	case SC_VERIFY:
+		fsg->data_size_from_cmnd = 0;
+		if ((reply = check_command(fsg, 10, DATA_DIR_NONE,
+				(1<<1) | (0xf<<2) | (3<<7), 1,
+				"VERIFY")) == 0)
+			reply = do_verify(fsg);
+		break;
+
+	case SC_WRITE_6:
+		i = fsg->cmnd[4];
+		fsg->data_size_from_cmnd = (i == 0 ? 256 : i) << 9;
+		if ((reply = check_command(fsg, 6, DATA_DIR_FROM_HOST,
+				(7<<1) | (1<<4), 1,
+				"WRITE(6)")) == 0)
+			reply = do_write(fsg);
+		break;
+
+	case SC_WRITE_10:
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]) << 9;
+		if ((reply = check_command(fsg, 10, DATA_DIR_FROM_HOST,
+				(1<<1) | (0xf<<2) | (3<<7), 1,
+				"WRITE(10)")) == 0)
+			reply = do_write(fsg);
+		break;
+
+	case SC_WRITE_12:
+		fsg->data_size_from_cmnd = get_be32(&fsg->cmnd[6]) << 9;
+		if ((reply = check_command(fsg, 12, DATA_DIR_FROM_HOST,
+				(1<<1) | (0xf<<2) | (0xf<<6), 1,
+				"WRITE(12)")) == 0)
+			reply = do_write(fsg);
+		break;
+
+	/* Some mandatory commands that we recognize but don't implement.
+	 * They don't mean much in this setting.  It's left as an exercise
+	 * for anyone interested to implement RESERVE and RELEASE in terms
+	 * of Posix locks. */
+	case SC_FORMAT_UNIT:
+	case SC_RELEASE:
+	case SC_RESERVE:
+	case SC_SEND_DIAGNOSTIC:
+		/* Fall through */
+
+	default:
+		fsg->data_size_from_cmnd = 0;
+		sprintf(unknown, "Unknown x%02x", fsg->cmnd[0]);
+		if ((reply = check_command(fsg, fsg->cmnd_size,
+				DATA_DIR_UNKNOWN, 0xff, 0, unknown)) == 0) {
+			fsg->curlun->sense_data = SS_INVALID_COMMAND;
+			reply = -EINVAL;
+		}
+		break;
+	}
+	up_read(&fsg->filesem);
+
+	VDBG(fsg, "reply: %d, fsg->data_size_from_cmnd: %d\n",
+			reply, fsg->data_size_from_cmnd);
+	if (reply == -EINTR || signal_pending(current))
+		return -EINTR;
+
+	/* Set up the single reply buffer for finish_reply() */
+	if (reply == -EINVAL)
+		reply = 0;		/* Error reply length */
+	if (reply >= 0 && fsg->data_dir == DATA_DIR_TO_HOST) {
+		reply = min((u32) reply, fsg->data_size_from_cmnd);
+		bh->inreq->length = reply;
+		bh->state = BUF_STATE_FULL;
+		fsg->residue -= reply;
+	}				/* Otherwise it's already set */
+
+	return 0;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct usb_request	*req = bh->outreq;
+	struct bulk_cb_wrap	*cbw = req->buf;
+
+	/* Was this a real packet? */
+	if (req->status){
+		ERROR(fsg, "[%s] req->status => discarded \n", __func__);
+		return -EINVAL;
+	}		
+
+	/* Is the CBW valid? */
+	if (req->actual != USB_BULK_CB_WRAP_LEN ||
+			cbw->Signature != __constant_cpu_to_le32(
+				USB_BULK_CB_SIG)) {
+		ERROR(fsg, "invalid CBW: len %u sig 0x%x\n",
+				req->actual,
+				le32_to_cpu(cbw->Signature));
+		/* file_storage.c
+		 * The Bulk-only spec says we MUST stall the IN endpoint
+		 * (6.6.1), so it's unavoidable.  It also says we must
+		 * retain this state until the next reset, but there's
+		 * no way to tell the controller driver it should ignore
+		 * Clear-Feature(HALT) requests.
+		 *
+		 * We aren't required to halt the OUT endpoint; instead
+		 * we can simply accept and discard any data received
+		 * until the next reset. */
+
+		DBG(fsg, "usb_ep_set_halt(fsg->bulk_in)\n");
+		usb_ep_set_halt(fsg->bulk_in);
+		set_bit(CLEAR_BULK_HALTS, &fsg->atomic_bitflags);
+		
+		return -EINVAL;
+	}
+
+	/* Is the CBW meaningful? */
+	if (cbw->Lun >= MAX_LUNS || cbw->Flags & ~USB_BULK_IN_FLAG ||
+			cbw->Length <= 0 || cbw->Length > MAX_COMMAND_SIZE) {
+		ERROR(fsg, "non-meaningful CBW: lun = %u, flags = 0x%x, "
+				"cmdlen %u\n",
+				cbw->Lun, cbw->Flags, cbw->Length);
+#if 0
+		//file_storage.c
+		
+		/* We can do anything we want here, so let's stall the
+		 * bulk pipes if we are allowed to. */
+		if (mod_data.can_stall) {
+			fsg_set_halt(fsg, fsg->bulk_out);
+			halt_bulk_in_endpoint(fsg);
+		}
+#else
+		DBG(fsg, "usb_ep_set_halt[ bulk_out & bulk_in]\n");
+		usb_ep_set_halt(fsg->bulk_out);
+		usb_ep_set_halt(fsg->bulk_in);
+#endif
+		return -EINVAL;
+	}
+
+	/* Save the command for later */
+	fsg->cmnd_size = cbw->Length;
+	memcpy(fsg->cmnd, cbw->CDB, fsg->cmnd_size);
+	if (cbw->Flags & USB_BULK_IN_FLAG)
+		fsg->data_dir = DATA_DIR_TO_HOST;
+	else
+		fsg->data_dir = DATA_DIR_FROM_HOST;
+	fsg->data_size = le32_to_cpu(cbw->DataTransferLength);
+	if (fsg->data_size == 0)
+		fsg->data_dir = DATA_DIR_NONE;
+	fsg->lun = cbw->Lun;
+	fsg->tag = cbw->Tag;
+	return 0;
+}
+
+
+static int get_next_command(struct fsg_dev *fsg)
+{
+	struct fsg_buffhd	*bh;
+	int			rc = 0;
+
+	/* Wait for the next buffer to become available */
+	bh = fsg->next_buffhd_to_fill;
+	while (bh->state != BUF_STATE_EMPTY) {
+		rc = sleep_thread(fsg);
+		if (rc) {
+			usb_ep_dequeue(fsg->bulk_out, bh->outreq);
+			bh->outreq_busy = 0;
+			bh->state = BUF_STATE_EMPTY;
+			return rc;
+		}
+	}
+
+	/* Queue a request to read a Bulk-only CBW */
+	set_bulk_out_req_length(fsg, bh, USB_BULK_CB_WRAP_LEN);
+	start_transfer(fsg, fsg->bulk_out, bh->outreq,
+			&bh->outreq_busy, &bh->state);
+
+	/* We will drain the buffer in software, which means we
+	 * can reuse it for the next filling.  No need to advance
+	 * next_buffhd_to_fill. */
+
+	/* Wait for the CBW to arrive */
+	while (bh->state != BUF_STATE_FULL) {
+		rc = sleep_thread(fsg);
+		if (rc) {
+			usb_ep_dequeue(fsg->bulk_out, bh->outreq);
+			bh->outreq_busy = 0;
+			bh->state = BUF_STATE_EMPTY;
+			return rc;
+		}
+	}
+	smp_rmb();
+	rc = received_cbw(fsg, bh);
+	bh->state = BUF_STATE_EMPTY;
+
+	return rc;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int enable_endpoint(struct fsg_dev *fsg, struct usb_ep *ep,
+		const struct usb_endpoint_descriptor *d)
+{
+	int	rc;
+
+	DBG(fsg, "usb_ep_enable %s\n", ep->name);
+	ep->driver_data = fsg;
+	rc = usb_ep_enable(ep, d);
+	if (rc)
+		ERROR(fsg, "can't enable %s, result %d\n", ep->name, rc);
+	return rc;
+}
+
+static int alloc_request(struct fsg_dev *fsg, struct usb_ep *ep,
+		struct usb_request **preq)
+{
+	*preq = usb_ep_alloc_request(ep, GFP_ATOMIC);
+	if (*preq)
+		return 0;
+	ERROR(fsg, "can't allocate request for %s\n", ep->name);
+	return -ENOMEM;
+}
+
+/*
+ * Reset interface setting and re-init endpoint state (toggle etc).
+ * Call with altsetting < 0 to disable the interface.  The only other
+ * available altsetting is 0, which enables the interface.
+ */
+static int do_set_interface(struct fsg_dev *fsg, int altsetting)
+{
+	struct usb_composite_dev *cdev = fsg->cdev;
+	int	rc = 0;
+	int	i;
+	const struct usb_endpoint_descriptor	*d;
+
+	if (fsg->running)
+		DBG(fsg, "reset interface\n");
+reset:
+	 /* Disable the endpoints */
+	if (fsg->bulk_in_enabled) {
+		DBG(fsg, "usb_ep_disable %s\n", fsg->bulk_in->name);
+		usb_ep_disable(fsg->bulk_in);
+		fsg->bulk_in_enabled = 0;
+	}
+	if (fsg->bulk_out_enabled) {
+		DBG(fsg, "usb_ep_disable %s\n", fsg->bulk_out->name);
+		usb_ep_disable(fsg->bulk_out);
+		fsg->bulk_out_enabled = 0;
+	}
+
+	/* Deallocate the requests */
+	for (i = 0; i < NUM_BUFFERS; ++i) {
+		struct fsg_buffhd *bh = &fsg->buffhds[i];
+		if (bh->inreq) {
+			usb_ep_free_request(fsg->bulk_in, bh->inreq);
+			bh->inreq = NULL;
+		}
+		if (bh->outreq) {
+			usb_ep_free_request(fsg->bulk_out, bh->outreq);
+			bh->outreq = NULL;
+		}
+	}
+
+
+	fsg->running = 0;
+	if (altsetting < 0 || rc != 0)
+		return rc;
+
+	DBG(fsg, "set interface %d\n", altsetting);
+
+	/* Enable the endpoints */
+	d = ep_desc(cdev->gadget, &fs_bulk_in_desc, &hs_bulk_in_desc);
+	if ((rc = enable_endpoint(fsg, fsg->bulk_in, d)) != 0)
+		goto reset;
+	fsg->bulk_in_enabled = 1;
+
+	d = ep_desc(cdev->gadget, &fs_bulk_out_desc, &hs_bulk_out_desc);
+	if ((rc = enable_endpoint(fsg, fsg->bulk_out, d)) != 0)
+		goto reset;
+	fsg->bulk_out_enabled = 1;
+	fsg->bulk_out_maxpacket = le16_to_cpu(d->wMaxPacketSize);
+
+	clear_bit(CLEAR_BULK_HALTS, &fsg->atomic_bitflags);
+
+	/* Allocate the requests */
+	for (i = 0; i < NUM_BUFFERS; ++i) {
+		struct fsg_buffhd	*bh = &fsg->buffhds[i];
+
+		rc = alloc_request(fsg, fsg->bulk_in, &bh->inreq);
+		if (rc != 0)
+			goto reset;
+		rc = alloc_request(fsg, fsg->bulk_out, &bh->outreq);
+		if (rc != 0)
+			goto reset;
+		bh->inreq->buf = bh->outreq->buf = bh->buf;
+		bh->inreq->context = bh->outreq->context = bh;
+		bh->inreq->complete = bulk_in_complete;
+		bh->outreq->complete = bulk_out_complete;
+	}
+
+	fsg->running = 1;
+	for (i = 0; i < fsg->nluns; ++i)
+		fsg->luns[i].unit_attention_data = SS_RESET_OCCURRED;
+
+	return rc;
+}
+
+static void adjust_wake_lock(struct fsg_dev *fsg)
+{
+	int ums_active = 0;
+	int i;
+
+	spin_lock_irq(&fsg->lock);
+
+	if (fsg->config) {
+		for (i = 0; i < fsg->nluns; ++i) {
+			if (backing_file_is_open(&fsg->luns[i]))
+				ums_active = 1;
+		}
+	}
+
+	if (ums_active)
+		wake_lock(&fsg->wake_lock);
+	else
+		wake_unlock(&fsg->wake_lock);
+
+	spin_unlock_irq(&fsg->lock);
+}
+
+/*
+ * Change our operational configuration.  This code must agree with the code
+ * that returns config descriptors, and with interface altsetting code.
+ *
+ * It's also responsible for power management interactions.  Some
+ * configurations might not work with our current power sources.
+ * For now we just assume the gadget is always self-powered.
+ */
+static int do_set_config(struct fsg_dev *fsg, u8 new_config)
+{
+	int	rc = 0;
+
+	if (new_config == fsg->config)
+		return rc;
+
+	/* Disable the single interface */
+	if (fsg->config != 0) {
+		DBG(fsg, "reset config\n");
+		fsg->config = 0;
+	}
+
+	/* Enable the interface */
+	if (new_config != 0)
+		fsg->config = new_config;
+
+	switch_set_state(&fsg->sdev, new_config);
+	adjust_wake_lock(fsg);
+	return rc;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static void handle_exception(struct fsg_dev *fsg)
+{
+	siginfo_t		info;
+	int			sig;
+	int			i;
+	struct fsg_buffhd	*bh;
+	enum fsg_state		old_state;
+	u8			new_config;
+	struct lun		*curlun;
+	int			rc;
+
+	struct usb_composite_dev *cdev = fsg->function.config->cdev;		
+	struct usb_request	*req = cdev->req;
+
+	DBG(fsg, "handle_exception state: %d\n", (int)fsg->state);
+	/* Clear the existing signals.  Anything but SIGUSR1 is converted
+	 * into a high-priority EXIT exception. */
+	for (;;) {
+		sig = dequeue_signal_lock(current, &current->blocked, &info);
+		if (!sig)
+			break;
+		if (sig != SIGUSR1) {
+			if (fsg->state < FSG_STATE_EXIT)
+				DBG(fsg, "Main thread exiting on signal\n");
+			raise_exception(fsg, FSG_STATE_EXIT);
+		}
+	}
+
+	/*
+	* Do NOT flush the fifo after set_interface()
+	* Otherwise, it results in some data being lost
+	*/
+	if ((fsg->state != FSG_STATE_CONFIG_CHANGE) ||
+		(fsg->new_config != 1))   {
+		/* Clear out the controller's fifos */
+		if (fsg->bulk_in_enabled)
+			usb_ep_fifo_flush(fsg->bulk_in);
+		if (fsg->bulk_out_enabled)
+			usb_ep_fifo_flush(fsg->bulk_out);
+	}
+	/* Reset the I/O buffer states and pointers, the SCSI
+	 * state, and the exception.  Then invoke the handler. */
+	spin_lock_irq(&fsg->lock);
+
+	for (i = 0; i < NUM_BUFFERS; ++i) {
+		bh = &fsg->buffhds[i];
+		bh->state = BUF_STATE_EMPTY;
+	}
+	fsg->next_buffhd_to_fill = fsg->next_buffhd_to_drain =
+			&fsg->buffhds[0];
+
+	new_config = fsg->new_config;
+	old_state = fsg->state;
+
+	if (old_state == FSG_STATE_ABORT_BULK_OUT)
+		fsg->state = FSG_STATE_STATUS_PHASE;
+	else {
+		for (i = 0; i < fsg->nluns; ++i) {
+			curlun = &fsg->luns[i];
+			curlun->prevent_medium_removal = 0;
+			curlun->sense_data = curlun->unit_attention_data =
+					SS_NO_SENSE;
+			curlun->sense_data_info = 0;
+			curlun->info_valid = 0;
+		}
+		fsg->state = FSG_STATE_IDLE;
+	}
+	spin_unlock_irq(&fsg->lock);
+
+	/* Carry out any extra actions required for the exception */
+	switch (old_state) {
+	default:
+		break;
+
+	case FSG_STATE_ABORT_BULK_OUT:
+		DBG(fsg, "FSG_STATE_ABORT_BULK_OUT\n");
+		spin_lock_irq(&fsg->lock);
+		if (fsg->state == FSG_STATE_STATUS_PHASE)
+			fsg->state = FSG_STATE_IDLE;
+		spin_unlock_irq(&fsg->lock);
+		break;
+
+	case FSG_STATE_RESET:
+/*
+ * spec. say
+ * to reset the mass storage device and its associated interface.
+ * This class-specific request shall ready the device for the next CBW from the host.
+ * The device shall preserve the value of its bulk data toggle bits 
+ * and endpoint STALL conditions despite the Bulk-Only Mass Storage Reset.
+ * The device shall NAK the status stage of the device request 
+ * until the Bulk-Only Mass Storage Reset is complete.
+ *
+ * bInterfaceProtocol =	US_PR_BULK
+ * is_bbb
+ 
+ * In case we were forced against our will to halt a
+ * bulk endpoint, clear the halt now.  (The SuperH UDC
+ * requires this.) 
+ */ 
+#if 0
+		// file_storage.c
+		
+		/* In case we were forced against our will to halt a
+		 * bulk endpoint, clear the halt now.  (The SuperH UDC
+		 * requires this.) */
+		if (test_and_clear_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags))
+			usb_ep_clear_halt(fsg->bulk_in);
+
+		if (transport_is_bbb()) {
+			if (fsg->ep0_req_tag == exception_req_tag)
+				ep0_queue(fsg); // Complete the status stage
+
+		} else if (transport_is_cbi())
+			send_status(fsg);	// Status by interrupt pipe
+
+		/* Technically this should go here, but it would only be
+		 * a waste of time.  Ditto for the INTERFACE_CHANGE and
+		 * CONFIG_CHANGE cases. */
+		// for (i = 0; i < fsg->nluns; ++i)
+		//	fsg->luns[i].unit_attention_data = SS_RESET_OCCURRED;
+
+#endif 
+
+		DBG(fsg, "[%s] FSG_STATE_RESET \n", __func__);
+
+		//OUT first because of read CBW and write CSW
+	//	printk("[%s] usb_ep_clear_halt(fsg->bulk_out) \n", __func__);
+	//	usb_ep_clear_halt(fsg->bulk_out);
+
+		if (test_and_clear_bit(CLEAR_BULK_HALTS, &fsg->atomic_bitflags)) {
+			DBG(fsg, "[%s] usb_ep_clear_halt(fsg->bulk_in) \n", __func__);
+			usb_ep_clear_halt(fsg->bulk_in);
+		}
+		
+		req->zero = true;
+		req->length = 0;
+		rc = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
+			
+		if (rc != 0 && rc != -ESHUTDOWN) {		
+			ERROR(fsg, "[%s] queue req->zero fail with [%d] \n",__func__, rc);
+		}
+		DBG(fsg, "[%s] queue req->zero OK \n", __func__);
+
+		break;
+
+	case FSG_STATE_CONFIG_CHANGE:
+		rc = do_set_config(fsg, new_config);
+		if (new_config == 0) {
+			/* We're using the backing file */
+			down_read(&fsg->filesem);
+			fsync_all(fsg);
+			up_read(&fsg->filesem);
+		}
+		break;
+
+	case FSG_STATE_EXIT:
+	case FSG_STATE_TERMINATED:
+		if (new_config)  {
+			fsg->new_config = 0;
+			do_set_interface(fsg, -1);
+		}
+		do_set_config(fsg, 0);			/* Free resources */
+		spin_lock_irq(&fsg->lock);
+		fsg->state = FSG_STATE_TERMINATED;	/* Stop the thread */
+		spin_unlock_irq(&fsg->lock);
+		break;
+	}
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int fsg_main_thread(void *fsg_)
+{
+	struct fsg_dev		*fsg = fsg_;
+
+	/* Allow the thread to be killed by a signal, but set the signal mask
+	 * to block everything but INT, TERM, KILL, and USR1. */
+	allow_signal(SIGINT);
+	allow_signal(SIGTERM);
+	allow_signal(SIGKILL);
+	allow_signal(SIGUSR1);
+
+	/* Allow the thread to be frozen */
+	set_freezable();
+
+	/* Arrange for userspace references to be interpreted as kernel
+	 * pointers.  That way we can pass a kernel pointer to a routine
+	 * that expects a __user pointer and it will work okay. */
+	set_fs(get_ds());
+
+	/* The main loop */
+	while (fsg->state != FSG_STATE_TERMINATED) {
+		if (exception_in_progress(fsg) || signal_pending(current)) {
+			handle_exception(fsg);
+			continue;
+		}
+
+		if (!fsg->running) {
+			sleep_thread(fsg);
+			continue;
+		}
+
+		if (get_next_command(fsg))
+			continue;
+
+		spin_lock_irq(&fsg->lock);
+		if (!exception_in_progress(fsg))
+			fsg->state = FSG_STATE_DATA_PHASE;
+		spin_unlock_irq(&fsg->lock);
+
+		if (do_scsi_command(fsg) || finish_reply(fsg))
+			continue;
+
+		spin_lock_irq(&fsg->lock);
+		if (!exception_in_progress(fsg))
+			fsg->state = FSG_STATE_STATUS_PHASE;
+		spin_unlock_irq(&fsg->lock);
+
+		if (send_status(fsg))
+			continue;
+
+		spin_lock_irq(&fsg->lock);
+		if (!exception_in_progress(fsg))
+			fsg->state = FSG_STATE_IDLE;
+		spin_unlock_irq(&fsg->lock);
+		}
+
+	spin_lock_irq(&fsg->lock);
+	fsg->thread_task = NULL;
+	spin_unlock_irq(&fsg->lock);
+
+	/* In case we are exiting because of a signal, unregister the
+	 * gadget driver and close the backing file. */
+	if (test_and_clear_bit(REGISTERED, &fsg->atomic_bitflags))
+		close_all_backing_files(fsg);
+
+	/* Let the unbind and cleanup routines know the thread has exited */
+	complete_and_exit(&fsg->thread_notifier, 0);
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* If the next two routines are called while the gadget is registered,
+ * the caller must own fsg->filesem for writing. */
+
+static int open_backing_file(struct fsg_dev *fsg, struct lun *curlun,
+	const char *filename)
+{
+	int				ro;
+	struct file			*filp = NULL;
+	int				rc = -EINVAL;
+	struct inode			*inode = NULL;
+	loff_t				size;
+	loff_t				num_sectors;
+
+	/* R/W if we can, R/O if we must */
+	ro = curlun->ro;
+	if (!ro) {
+		filp = filp_open(filename, O_RDWR | O_LARGEFILE, 0);
+		if (-EROFS == PTR_ERR(filp))
+			ro = 1;
+	}
+	if (ro)
+		filp = filp_open(filename, O_RDONLY | O_LARGEFILE, 0);
+	if (IS_ERR(filp)) {
+		LINFO(curlun, "unable to open backing file: %s\n", filename);
+		return PTR_ERR(filp);
+	}
+
+	if (!(filp->f_mode & FMODE_WRITE))
+		ro = 1;
+
+	if (filp->f_path.dentry)
+		inode = filp->f_path.dentry->d_inode;
+	if (inode && S_ISBLK(inode->i_mode)) {
+		if (bdev_read_only(inode->i_bdev))
+			ro = 1;
+	} else if (!inode || !S_ISREG(inode->i_mode)) {
+		LINFO(curlun, "invalid file type: %s\n", filename);
+		goto out;
+	}
+
+	/* If we can't read the file, it's no good.
+	 * If we can't write the file, use it read-only. */
+	if (!filp->f_op || !(filp->f_op->read || filp->f_op->aio_read)) {
+		LINFO(curlun, "file not readable: %s\n", filename);
+		goto out;
+	}
+	if (!(filp->f_op->write || filp->f_op->aio_write))
+		ro = 1;
+
+	size = i_size_read(inode->i_mapping->host);
+	if (size < 0) {
+		LINFO(curlun, "unable to find file size: %s\n", filename);
+		rc = (int) size;
+		goto out;
+	}
+	num_sectors = size >> 9;	/* File size in 512-byte sectors */
+	if (num_sectors == 0) {
+		LINFO(curlun, "file too small: %s\n", filename);
+		rc = -ETOOSMALL;
+		goto out;
+	}
+
+	get_file(filp);
+	curlun->ro = ro;
+	curlun->filp = filp;
+	curlun->file_length = size;
+	curlun->num_sectors = num_sectors;
+	LDBG(curlun, "open backing file: %s size: %lld num_sectors: %lld\n",
+			filename, size, num_sectors);
+	rc = 0;
+	adjust_wake_lock(fsg);
+
+out:
+	filp_close(filp, current->files);
+	return rc;
+}
+
+
+static void close_backing_file(struct fsg_dev *fsg, struct lun *curlun)
+{
+	if (curlun->filp) {
+		int rc;
+
+		/*
+		 * XXX: San: Ugly hack here added to ensure that
+		 * our pages get synced to disk.
+		 * Also drop caches here just to be extra-safe
+		 */
+		rc = vfs_fsync(curlun->filp, curlun->filp->f_path.dentry, 1);
+		if (rc < 0)
+			printk(KERN_ERR "ums: Error syncing data (%d)\n", rc);
+		/* drop_pagecache and drop_slab are no longer available */
+		/* drop_pagecache(); */
+		/* drop_slab(); */
+
+		LDBG(curlun, "close backing file\n");
+		fput(curlun->filp);
+		curlun->filp = NULL;
+		adjust_wake_lock(fsg);
+	}
+}
+
+static void close_all_backing_files(struct fsg_dev *fsg)
+{
+	int	i;
+
+	for (i = 0; i < fsg->nluns; ++i)
+		close_backing_file(fsg, &fsg->luns[i]);
+}
+
+static ssize_t show_file(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct lun	*curlun = dev_to_lun(dev);
+	struct fsg_dev	*fsg = dev_get_drvdata(dev);
+	char		*p;
+	ssize_t		rc;
+
+	down_read(&fsg->filesem);
+	if (backing_file_is_open(curlun)) {	/* Get the complete pathname */
+		p = d_path(&curlun->filp->f_path, buf, PAGE_SIZE - 1);
+		if (IS_ERR(p))
+			rc = PTR_ERR(p);
+		else {
+			rc = strlen(p);
+			memmove(buf, p, rc);
+			buf[rc] = '\n';		/* Add a newline */
+			buf[++rc] = 0;
+		}
+	} else {				/* No file, return 0 bytes */
+		*buf = 0;
+		rc = 0;
+	}
+	up_read(&fsg->filesem);
+	return rc;
+}
+
+static ssize_t store_file(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct lun	*curlun = dev_to_lun(dev);
+	struct fsg_dev	*fsg = dev_get_drvdata(dev);
+	int		rc = 0;
+
+	DBG(fsg, "store_file: \"%s\"\n", buf);
+#if 0
+	/* disabled because we need to allow closing the backing file if the media was removed */
+	if (curlun->prevent_medium_removal && backing_file_is_open(curlun)) {
+		LDBG(curlun, "eject attempt prevented\n");
+		return -EBUSY;				/* "Door is locked" */
+	}
+#endif
+
+	/* Remove a trailing newline */
+	if (count > 0 && buf[count-1] == '\n')
+		((char *) buf)[count-1] = 0;
+
+	/* Eject current medium */
+	down_write(&fsg->filesem);
+	if (backing_file_is_open(curlun)) {
+		close_backing_file(fsg, curlun);
+		curlun->unit_attention_data = SS_MEDIUM_NOT_PRESENT;
+	}
+
+	/* Load new medium */
+	if (count > 0 && buf[0]) {
+		rc = open_backing_file(fsg, curlun, buf);
+		if (rc == 0)
+			curlun->unit_attention_data =
+					SS_NOT_READY_TO_READY_TRANSITION;
+	}
+	up_write(&fsg->filesem);
+	return (rc < 0 ? rc : count);
+}
+
+
+static DEVICE_ATTR(file, 0444, show_file, store_file);
+
+/*-------------------------------------------------------------------------*/
+
+static void fsg_release(struct kref *ref)
+{
+	struct fsg_dev	*fsg = container_of(ref, struct fsg_dev, ref);
+
+	kfree(fsg->luns);
+	kfree(fsg);
+}
+
+static void lun_release(struct device *dev)
+{
+	struct fsg_dev	*fsg = dev_get_drvdata(dev);
+
+	kref_put(&fsg->ref, fsg_release);
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static int __init fsg_alloc(void)
+{
+	struct fsg_dev		*fsg;
+
+	fsg = kzalloc(sizeof *fsg, GFP_KERNEL);
+	if (!fsg)
+		return -ENOMEM;
+	spin_lock_init(&fsg->lock);
+	init_rwsem(&fsg->filesem);
+	kref_init(&fsg->ref);
+	init_completion(&fsg->thread_notifier);
+
+	the_fsg = fsg;
+	return 0;
+}
+
+static ssize_t print_switch_name(struct switch_dev *sdev, char *buf)
+{
+	return sprintf(buf, "%s\n", DRIVER_NAME);
+}
+
+static ssize_t print_switch_state(struct switch_dev *sdev, char *buf)
+{
+	struct fsg_dev	*fsg = container_of(sdev, struct fsg_dev, sdev);
+	return sprintf(buf, "%s\n", (fsg->config ? "online" : "offline"));
+}
+
+static void
+fsg_function_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct fsg_dev	*fsg = func_to_dev(f);
+	int			i;
+	struct lun		*curlun;
+
+	DBG(fsg, "fsg_function_unbind\n");
+	clear_bit(REGISTERED, &fsg->atomic_bitflags);
+
+	/* Unregister the sysfs attribute files and the LUNs */
+	for (i = 0; i < fsg->nluns; ++i) {
+		curlun = &fsg->luns[i];
+		if (curlun->registered) {
+			device_remove_file(&curlun->dev, &dev_attr_file);
+			device_unregister(&curlun->dev);
+			curlun->registered = 0;
+		}
+	}
+
+	/* If the thread isn't already dead, tell it to exit now */
+	if (fsg->state != FSG_STATE_TERMINATED) {
+		raise_exception(fsg, FSG_STATE_EXIT);
+		wait_for_completion(&fsg->thread_notifier);
+
+		/* The cleanup routine waits for this completion also */
+		complete(&fsg->thread_notifier);
+	}
+
+	/* Free the data buffers */
+	for (i = 0; i < NUM_BUFFERS; ++i)
+		kfree(fsg->buffhds[i].buf);
+	switch_dev_unregister(&fsg->sdev);
+}
+
+static int __init
+fsg_function_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct fsg_dev	*fsg = func_to_dev(f);
+	int			rc;
+	int			i;
+	int			id;
+	struct lun		*curlun;
+	struct usb_ep		*ep;
+	char			*pathbuf, *p;
+
+	fsg->cdev = cdev;
+	DBG(fsg, "fsg_function_bind\n");
+
+	dev_attr_file.attr.mode = 0644;
+
+	/* Find out how many LUNs there should be */
+	i = fsg->nluns;
+	if (i == 0)
+		i = 1;
+	if (i > MAX_LUNS) {
+		ERROR(fsg, "invalid number of LUNs: %d\n", i);
+		rc = -EINVAL;
+		goto out;
+	}
+
+	/* Create the LUNs, open their backing files, and register the
+	 * LUN devices in sysfs. */
+	fsg->luns = kzalloc(i * sizeof(struct lun), GFP_KERNEL);
+	if (!fsg->luns) {
+		rc = -ENOMEM;
+		goto out;
+	}
+	fsg->nluns = i;
+
+	for (i = 0; i < fsg->nluns; ++i) {
+		curlun = &fsg->luns[i];
+		curlun->ro = 0;
+		curlun->dev.release = lun_release;
+		/* use "usb_mass_storage" platform device as parent if available */
+		if (fsg->pdev)
+			curlun->dev.parent = &fsg->pdev->dev;
+		else
+			curlun->dev.parent = &cdev->gadget->dev;
+		dev_set_drvdata(&curlun->dev, fsg);
+		snprintf(curlun->dev.bus_id, BUS_ID_SIZE,
+				"lun%d", i);
+
+		rc = device_register(&curlun->dev);
+		if (rc != 0) {
+			INFO(fsg, "failed to register LUN%d: %d\n", i, rc);
+			goto out;
+		}
+		rc = device_create_file(&curlun->dev, &dev_attr_file);
+		if (rc != 0) {
+			ERROR(fsg, "device_create_file failed: %d\n", rc);
+			device_unregister(&curlun->dev);
+			goto out;
+		}
+		curlun->registered = 1;
+		kref_get(&fsg->ref);
+	}
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	intf_desc.bInterfaceNumber = id;
+
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_bulk_in_desc);
+	if (!ep)
+		goto autoconf_fail;
+	ep->driver_data = fsg;		/* claim the endpoint */
+	fsg->bulk_in = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_bulk_out_desc);
+	if (!ep)
+		goto autoconf_fail;
+	ep->driver_data = fsg;		/* claim the endpoint */
+	fsg->bulk_out = ep;
+
+	rc = -ENOMEM;
+
+	if (gadget_is_dualspeed(cdev->gadget)) {
+		/* Assume endpoint addresses are the same for both speeds */
+		hs_bulk_in_desc.bEndpointAddress =
+				fs_bulk_in_desc.bEndpointAddress;
+		hs_bulk_out_desc.bEndpointAddress =
+				fs_bulk_out_desc.bEndpointAddress;
+
+		f->hs_descriptors = hs_function;
+	}
+
+	/* Allocate the data buffers */
+	for (i = 0; i < NUM_BUFFERS; ++i) {
+		struct fsg_buffhd	*bh = &fsg->buffhds[i];
+
+		/* Allocate for the bulk-in endpoint.  We assume that
+		 * the buffer will also work with the bulk-out (and
+		 * interrupt-in) endpoint. */
+		bh->buf = kmalloc(fsg->buf_size, GFP_KERNEL);
+		if (!bh->buf)
+			goto out;
+		bh->next = bh + 1;
+	}
+	fsg->buffhds[NUM_BUFFERS - 1].next = &fsg->buffhds[0];
+
+	fsg->thread_task = kthread_create(fsg_main_thread, fsg,
+			shortname);
+	if (IS_ERR(fsg->thread_task)) {
+		rc = PTR_ERR(fsg->thread_task);
+		ERROR(fsg, "kthread_create failed: %d\n", rc);
+		goto out;
+	}
+
+	INFO(fsg, "Number of LUNs=%d\n", fsg->nluns);
+
+	pathbuf = kmalloc(PATH_MAX, GFP_KERNEL);
+	for (i = 0; i < fsg->nluns; ++i) {
+		curlun = &fsg->luns[i];
+		if (backing_file_is_open(curlun)) {
+			p = NULL;
+			if (pathbuf) {
+				p = d_path(&curlun->filp->f_path,
+					   pathbuf, PATH_MAX);
+				if (IS_ERR(p))
+					p = NULL;
+			}
+			LINFO(curlun, "ro=%d, file: %s\n",
+					curlun->ro, (p ? p : "(error)"));
+		}
+	}
+	kfree(pathbuf);
+
+	set_bit(REGISTERED, &fsg->atomic_bitflags);
+
+	/* Tell the thread to start working */
+	wake_up_process(fsg->thread_task);
+	return 0;
+
+autoconf_fail:
+	ERROR(fsg, "unable to autoconfigure all endpoints\n");
+	rc = -ENOTSUPP;
+
+out:
+	DBG(fsg, "fsg_function_bind failed: %d\n", rc);
+	fsg->state = FSG_STATE_TERMINATED;	/* The thread is dead */
+	fsg_function_unbind(c, f);
+	close_all_backing_files(fsg);
+	return rc;
+}
+
+static int fsg_function_set_alt(struct usb_function *f,
+		unsigned intf, unsigned alt)
+{
+	struct fsg_dev	*fsg = func_to_dev(f);
+	DBG(fsg, "fsg_function_set_alt intf: %d alt: %d\n", intf, alt);
+	fsg->new_config = 1;
+	do_set_interface(fsg, 0);
+	raise_exception(fsg, FSG_STATE_CONFIG_CHANGE);
+	return 0;
+}
+
+static void fsg_function_disable(struct usb_function *f)
+{
+	struct fsg_dev	*fsg = func_to_dev(f);
+	DBG(fsg, "fsg_function_disable\n");
+	if (fsg->new_config)
+		do_set_interface(fsg, -1);
+	fsg->new_config = 0;
+	raise_exception(fsg, FSG_STATE_CONFIG_CHANGE);
+}
+
+static int __init fsg_probe(struct platform_device *pdev)
+{
+	struct usb_mass_storage_platform_data *pdata = pdev->dev.platform_data;
+	struct fsg_dev *fsg = the_fsg;
+
+	fsg->pdev = pdev;
+	printk(KERN_INFO "fsg_probe pdata: %p\n", pdata);
+
+	if (pdata) {
+		if (pdata->vendor)
+			fsg->vendor = pdata->vendor;
+
+		if (pdata->product)
+			fsg->product = pdata->product;
+
+		if (pdata->release)
+			fsg->release = pdata->release;
+	}
+
+	return 0;
+}
+
+static struct platform_driver fsg_platform_driver = {
+	.driver = { .name = "usb_mass_storage", },
+	.probe = fsg_probe,
+};
+
+int __init mass_storage_function_add(struct usb_composite_dev *cdev,
+	struct usb_configuration *c, int nluns)
+{
+	int		rc;
+	struct fsg_dev	*fsg;
+	int		status;
+
+	printk(KERN_INFO "mass_storage_function_add\n");
+	rc = fsg_alloc();
+	if (rc)
+		return rc;
+	fsg = the_fsg;
+	fsg->nluns = nluns;
+
+	if (f_ums_string_defs[F_UMS_IDX].id == 0) {
+		status = usb_string_id(c->cdev);
+		if (status < 0)
+			return status;
+		f_ums_string_defs[F_UMS_IDX].id = status;
+		intf_desc.iInterface = status;
+	}
+
+	spin_lock_init(&fsg->lock);
+	init_rwsem(&fsg->filesem);
+	kref_init(&fsg->ref);
+	init_completion(&fsg->thread_notifier);
+
+	the_fsg->buf_size = BULK_BUFFER_SIZE;
+	the_fsg->sdev.name = DRIVER_NAME;
+	the_fsg->sdev.print_name = print_switch_name;
+	the_fsg->sdev.print_state = print_switch_state;
+	rc = switch_dev_register(&the_fsg->sdev);
+	if (rc < 0)
+		goto err_switch_dev_register;
+
+	rc = platform_driver_register(&fsg_platform_driver);
+	if (rc != 0)
+		goto err_platform_driver_register;
+
+	wake_lock_init(&the_fsg->wake_lock, WAKE_LOCK_SUSPEND,
+			   "usb_mass_storage");
+
+	fsg->cdev = cdev;
+	fsg->function.name = shortname;
+//added by ss1	
+	fsg->function.strings = f_ums_strings;
+	fsg->function.descriptors = fs_function;
+	fsg->function.hs_descriptors = hs_function;
+	fsg->function.bind = fsg_function_bind;
+	fsg->function.unbind = fsg_function_unbind;
+	fsg->function.setup = fsg_function_setup;
+	fsg->function.set_alt = fsg_function_set_alt;
+	fsg->function.disable = fsg_function_disable;
+
+	rc = usb_add_function(c, &fsg->function);
+	if (rc != 0)
+		goto err_usb_add_function;
+
+	return 0;
+
+err_usb_add_function:
+	wake_lock_destroy(&the_fsg->wake_lock);
+	platform_driver_unregister(&fsg_platform_driver);
+err_platform_driver_register:
+	switch_dev_unregister(&the_fsg->sdev);
+err_switch_dev_register:
+	kref_put(&the_fsg->ref, fsg_release);
+
+	return rc;
+}
diff -Nur linux-2.6.29/drivers/usb/gadget/f_mass_storage.h linux-2.6.29-spica/drivers/usb/gadget/f_mass_storage.h
--- linux-2.6.29/drivers/usb/gadget/f_mass_storage.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/f_mass_storage.h	2010-03-30 11:01:11.000000000 +0700
@@ -0,0 +1,52 @@
+/*
+ * drivers/usb/gadget/f_mass_storage.h
+ *
+ * Function Driver for USB Mass Storage
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * Based heavily on the file_storage gadget driver in
+ * drivers/usb/gadget/file_storage.c and licensed under the same terms:
+ *
+ * Copyright (C) 2003-2007 Alan Stern
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The names of the above-listed copyright holders may not be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __F_MASS_STORAGE_H
+#define __F_MASS_STORAGE_H
+
+int mass_storage_function_add(struct usb_composite_dev *cdev,
+	struct usb_configuration *c, int nluns);
+
+#endif /* __F_MASS_STORAGE_H */
diff -Nur linux-2.6.29/drivers/usb/gadget/f_rndis.c linux-2.6.29-spica/drivers/usb/gadget/f_rndis.c
--- linux-2.6.29/drivers/usb/gadget/f_rndis.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/usb/gadget/f_rndis.c	2010-05-06 12:42:45.644210217 +0700
@@ -462,9 +462,15 @@
 			usb_ep_disable(rndis->notify);
 		} else {
 			VDBG(cdev, "init rndis ctrl %d\n", intf);
+			
+			VDBG(cdev, "rndis->hs.notify %p\n", rndis->hs.notify);
+			VDBG(cdev, "rndis->fs.notify %p\n", rndis->fs.notify);
+			
 			rndis->notify_desc = ep_choose(cdev->gadget,
 					rndis->hs.notify,
 					rndis->fs.notify);
+			
+			VDBG(cdev, "rndis->notify_desc %p\n", rndis->notify_desc);
 		}
 		usb_ep_enable(rndis->notify, rndis->notify_desc);
 		rndis->notify->driver_data = rndis;
diff -Nur linux-2.6.29/drivers/usb/gadget/fsa9480_i2c.c linux-2.6.29-spica/drivers/usb/gadget/fsa9480_i2c.c
--- linux-2.6.29/drivers/usb/gadget/fsa9480_i2c.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/fsa9480_i2c.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,745 @@
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <plat/pm.h>
+#include <plat/s3c64xx-dvfs.h>
+#include <linux/i2c/pmic.h>
+  
+#include <mach/param.h>
+#include "fsa9480_i2c.h"
+
+#include <linux/wakelock.h>
+
+static struct wake_lock fsa9480_wake_lock;
+
+
+extern struct device *switch_dev;
+extern ftm_sleep;
+
+#define FSA9480_UART 	1
+#define FSA9480_USB 	2
+
+#define FSA9480UCX		0x4A
+static unsigned short fsa9480_normal_i2c[] = {I2C_CLIENT_END };
+static unsigned short fsa9480_ignore[] = { I2C_CLIENT_END };
+static unsigned short fsa9480_i2c_probe[] = { 0, FSA9480UCX >> 1, I2C_CLIENT_END };
+
+static struct i2c_client fsa9480_i2c_client;
+static struct i2c_driver fsa9480_i2c_driver;
+
+static int usb_path = 0;
+static int usb_power = 2;
+static int usb_state = 0;
+
+static struct timer_list fsa9480_init_timer;
+static wait_queue_head_t usb_detect_waitq;
+static struct workqueue_struct *fsa9480_workqueue;
+static struct work_struct fsa9480_work;
+
+static struct i2c_client_address_data fsa9480_addr_data = {
+	.normal_i2c = fsa9480_normal_i2c,
+	.ignore     = fsa9480_ignore,
+	.probe      = fsa9480_i2c_probe,
+};
+
+
+/********************************************************************/
+/* function definitions                                                                             */
+/********************************************************************/
+
+//by ss1
+//refer to drivers/usb/gadget/s3c-udc-otg-hs.c	
+void s3c_udc_power_up(void);
+void s3c_udc_power_down(void);
+void fsa9480_SetAutoSWMode(void);
+
+
+int wait_condition = 0;
+static bool ta_connection = false;
+
+
+
+void get_usb_serial(char *usb_serial_number)
+{
+	char temp_serial_number[13] = {0};
+
+	u32 serial_number=0;
+	
+	serial_number = (system_serial_high << 16) + (system_serial_low >> 16);
+
+	sprintf(temp_serial_number,"5700%08x",serial_number);
+	strcpy(usb_serial_number,temp_serial_number);
+}
+
+
+int available_PM_Set(void)
+{
+    DEBUG_FSA9480("[FSA9480]%s ", __func__);
+	if(driver_find("max8698", &i2c_bus_type))
+		return 1;
+	return 0;
+}
+
+int get_usb_power_state(void)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+
+	if(usb_power !=1 )
+	{
+		wait_condition = 0;
+		wait_event_interruptible_timeout(usb_detect_waitq, wait_condition , 2 * HZ); 
+	}
+
+	if(usb_power==2 && ta_connection)
+	{
+		printk("[FSA9480] usb_power = 2 & taconnection is true \n");
+		return 0;
+	}
+
+	return usb_power;
+}
+int get_usb_cable_state(void)
+{
+    //DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+	return usb_state;
+}
+
+void fsa9480_s3c_udc_on(void)
+{	
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+	usb_power = 1;
+
+	//SEC_BSP_WONSUK_20090806 
+	//resolve Power ON/OFF panic issue. do not wake_up function before FSA9480 probe.
+	if(&usb_detect_waitq == NULL)
+		{
+		printk("[FSA9480] fsa9480_s3c_udc_on : usb_detect_waitq is NULL\n");
+		}
+	else
+		{
+		wait_condition = 1;
+		wake_up_interruptible(&usb_detect_waitq);
+		}
+
+    /*LDO control*/
+	if(!Set_MAX8698_PM_REG(ELDO3, 1) || !Set_MAX8698_PM_REG(ELDO8, 1))
+		printk("[FSA9480]%s : Fail to LDO ON\n ", __func__);
+
+}
+
+void fsa9480_s3c_udc_off(void)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+
+	usb_power = 0;
+
+    /*LDO control*/
+	if(!Set_MAX8698_PM_REG(ELDO3, 0) || !Set_MAX8698_PM_REG(ELDO8, 0))
+		printk("[FSA9480]%s : Fail to LDO OFF\n ", __func__);
+
+}
+
+int fsa9480_read(struct i2c_client *client, u8 reg, u8 *data)
+{
+
+	int ret;
+	u8 buf[1];
+	struct i2c_msg msg[2];
+
+	buf[0] = reg; 
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret != 2) 
+		return -EIO;
+
+	*data = buf[0];
+	
+	return 0;
+}
+
+static int fsa9480_write(struct i2c_client *client, u8 reg, u8 data)
+{
+
+	int ret;
+	u8 buf[2];
+	struct i2c_msg msg[1];
+
+	buf[0] = reg;
+	buf[1] = data;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 2;
+	msg[0].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msg, 1);
+	if (ret != 1) 
+		return -EIO;
+
+	return 0;
+}
+
+
+/**********************************************************************
+*    Name         : fsa9480_modify()
+*    Description : used when modify fsa9480 register value via i2c
+*                        
+*    Parameter   : None
+*                       @ client : i2c client
+*                       @ reg : fsa9480 register's address
+*                       @ data : modified data
+*                       @ mask : mask bit
+*    Return        : None
+*
+***********************************************************************/
+static int fsa9480_modify(struct i2c_client *client, u8 reg, u8 data, u8 mask)
+{
+   u8 original_value, modified_value;
+
+   fsa9480_read(client, reg, &original_value);
+   DEBUG_FSA9480("[FSA9480] %s Original value is 0x%02x\n ",__func__, original_value);
+   modified_value = ((original_value&~mask)| data);
+   DEBUG_FSA9480("[FSA9480] %s modified value is 0x%02x\n ",__func__, modified_value);
+   fsa9480_write(client, reg, modified_value);
+
+   return 0;
+}
+
+//called by udc 
+/* UART <-> USB switch (for UART/USB JIG) */
+void fsa9480_check_usb_connection(void)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+	u8 control, int1, deviceType1, deviceType2, manual1, manual2,pData,adc, carkitint1;
+	bool bInitConnect = false;
+
+	fsa9480_read(&fsa9480_i2c_client, REGISTER_INTERRUPT1, &int1); // interrupt clear
+	fsa9480_read(&fsa9480_i2c_client, REGISTER_DEVICETYPE1, &deviceType1);
+	fsa9480_read(&fsa9480_i2c_client, REGISTER_ADC, &adc);
+
+	//in case of carkit we should process the extra interrupt. 1: attach interrupt, 2: carkit interrupt
+	//  (interrupt_cr3 & 0x0) case is when power on after TA is inserted.
+	if (((int1 & ATTACH) || !(int1 & 0x0)) && 
+		               (( deviceType1 & CRA_CARKIT) || adc == CEA936A_TYPE_1_CHARGER ))
+		{
+		DEBUG_FSA9480("[FSA9480] %s : Carkit is inserted! 1'st resolve insert interrupt\n ",__func__);
+		fsa9480_write(&fsa9480_i2c_client, REGISTER_CARKITSTATUS, 0x02);  //use only carkit charger
+
+		fsa9480_read(&fsa9480_i2c_client, REGISTER_CARKITINT1, &carkitint1);    // make INTB to high
+		DEBUG_FSA9480("[FSA9480] %s : Carkit int1 is 0x%02x\n ",__func__, carkitint1);
+
+
+		return;
+		}
+
+
+	fsa9480_read(&fsa9480_i2c_client, REGISTER_CONTROL, &control);
+	fsa9480_read(&fsa9480_i2c_client, REGISTER_INTERRUPT2, &pData); // interrupt clear
+	fsa9480_read(&fsa9480_i2c_client, REGISTER_DEVICETYPE2, &deviceType2);
+	fsa9480_read(&fsa9480_i2c_client, REGISTER_MANUALSW1, &manual1);
+	fsa9480_read(&fsa9480_i2c_client, REGISTER_MANUALSW2, &manual2);
+
+	//DEBUG_FSA9480("[FSA9480] CONTROL is 0x%02x\n ",control);
+	DEBUG_FSA9480("[FSA9480] INTERRUPT1 is 0x%02x\n ",int1);
+	//DEBUG_FSA9480("[FSA9480] INTERRUPT2 is 0x%02x\n ",pData);
+	DEBUG_FSA9480("[FSA9480] DEVICETYPE1 is 0x%02x\n ",deviceType1);
+	//DEBUG_FSA9480("[FSA9480] DEVICETYPE2 is 0x%02x\n ",deviceType2);
+	//DEBUG_FSA9480("[FSA9480] MANUALSW1 is 0x%02x\n ",manual1);
+	//DEBUG_FSA9480("[FSA9480] MANUALSW1 is 0x%02x\n ",manual2);
+
+	/* TA Connection */
+	if(deviceType1 ==0x40)
+	{
+
+		wait_condition = 1;
+		ta_connection = true;
+		wake_up_interruptible(&usb_detect_waitq);
+	}
+
+	
+	usb_state = (deviceType2 << 8) | (deviceType1 << 0);
+	
+	/* Disconnect cable */
+	if (deviceType1 == DEVICE_TYPE_NC && deviceType2 == DEVICE_TYPE_NC) {
+		ta_connection = false;
+		DEBUG_FSA9480("[FSA9480] Cable is not connected\n ");
+		if (usb_power == 1) 
+		{
+			/* reset manual2 s/w register */
+			fsa9480_write(&fsa9480_i2c_client, REGISTER_MANUALSW2, 0x00);
+
+			/* auto mode settings */
+			fsa9480_write(&fsa9480_i2c_client, REGISTER_CONTROL, 0x1E); 
+
+			/* power down mode */
+			s3c_udc_power_down();
+
+
+		return ;
+		}
+	}
+	
+	/* USB Detected */
+	if (deviceType1 == CRA_USB|| (deviceType2 & CRB_JIG_USB)) 
+	{ 
+
+		/* Manual Mode for USB */
+		DEBUG_FSA9480("[FSA9480] MANUAL MODE.. d1:0x%02x, d2:0x%02x\n", deviceType1, deviceType2);
+		if (control != 0x1A) 
+		{ 	
+			
+			fsa9480_write(&fsa9480_i2c_client, REGISTER_CONTROL, 0x1A); 
+
+		}
+
+		/* reset manual2 s/w register */
+		manual2 &= ~(0x1f);
+
+		if(deviceType1 == CRA_USB)
+		{
+			/* ID Switching : ID connected to bypass port */
+			manual2 |= 0x2;
+		}
+		else if(deviceType2 & CRB_JIG_USB_ON)
+		{	
+			/* BOOT_SW : High , JIG_ON : GND */
+			manual2 |= (0x1 << 3) | (0x1 << 2);
+
+
+		}
+		else if(deviceType2 & CRB_JIG_USB_OFF)
+		{
+			/* BOOT_SW : LOW , JIG_ON : GND */
+			manual2 |= (0x1 << 2);
+			
+		}
+
+		fsa9480_write(&fsa9480_i2c_client, REGISTER_MANUALSW2, manual2);
+
+
+
+		/* connect cable */
+
+		if(manual1 == 0x24 && usb_power !=1)
+		{
+			bInitConnect = true;
+			s3c_udc_power_up();
+		}
+
+
+
+			
+	}
+	/* Auto mode settings */
+	else
+	{
+
+		/* Auto Mode except usb */
+		DEBUG_FSA9480("[FSA9480] AUTO MODE.. d1:0x%02x, d2:0x%02x\n", deviceType1, deviceType2);
+		if (control != 0x1E) 
+		{ 
+			fsa9480_write(&fsa9480_i2c_client, REGISTER_CONTROL, 0x1E);
+		
+		}
+
+
+	}
+
+	/* initialization driver */
+	if(usb_power == 2 && bInitConnect ==false )
+	{
+		fsa9480_s3c_udc_off();
+	}
+
+	
+
+}
+
+/* MODEM USB_SEL Pin control */
+/* 1 : PDA, 2 : MODEM */
+#define SWITCH_PDA			1
+#define SWITCH_MODEM		2
+static void usb_sel(int sel)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+	if (sel == SWITCH_PDA) { // PDA
+		gpio_set_value(GPIO_USB_SEL, 0);
+	} else { // MODEM
+		gpio_set_value(GPIO_USB_SEL, 1);
+	}
+
+	usb_path = sel;
+}
+
+/* for sysfs control (/sys/class/sec/switch/usb_sel) */
+static ssize_t usb_sel_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	u8 i, pData;
+
+	sprintf(buf, "USB Switch : %s\n", usb_path==SWITCH_PDA?"PDA":"MODEM");
+
+//	sprintf(buf, "[USB Switch] fsa9480 register\n");
+    for(i = 0; i <= 0x14; i++) {
+		fsa9480_read(&fsa9480_i2c_client, i, &pData);
+//		sprintf(buf, "%s0x%02x = 0x%02x\n", buf, i, pData);
+	}
+//	sprintf(buf, "%s[USB Switch] fsa9480 register done\n", buf);
+
+	return sprintf(buf, "%s\n", buf);
+}
+
+void usb_switch_mode(int sel)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+	if (sel == SWITCH_PDA)
+	{
+		DEBUG_FSA9480("[FSA9480] Path : PDA\n");
+		usb_sel(SWITCH_PDA);
+		fsa9480_write(&fsa9480_i2c_client, 0x13, 0x24); // PDA Port
+	} else if (sel == SWITCH_MODEM) 
+	{
+		DEBUG_FSA9480("[FSA9480] Path : MODEM\n");
+		usb_sel(SWITCH_MODEM);
+		fsa9480_write(&fsa9480_i2c_client, 0x13, 0x90); // V_Audio port (Modem USB)
+	} else
+		DEBUG_FSA9480("[FSA9480] Invalid mode...\n");
+}
+EXPORT_SYMBOL(usb_switch_mode);
+
+static ssize_t usb_sel_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+	int switch_sel;
+
+	if (sec_get_param_value)
+		sec_get_param_value(__SWITCH_SEL, &switch_sel);
+
+	if(strncmp(buf, "PDA", 3) == 0 || strncmp(buf, "pda", 3) == 0) {
+		usb_switch_mode(SWITCH_PDA);
+		switch_sel |= USB_SEL_MASK;
+	}
+
+	if(strncmp(buf, "MODEM", 5) == 0 || strncmp(buf, "modem", 5) == 0) {
+		usb_switch_mode(SWITCH_MODEM);
+		switch_sel &= ~USB_SEL_MASK;
+}
+
+	if (sec_set_param_value)
+		sec_set_param_value(__SWITCH_SEL, &switch_sel);
+
+	return size;
+}
+
+static DEVICE_ATTR(usb_sel, S_IRUGO |S_IWUGO | S_IRUSR | S_IWUSR, usb_sel_show, usb_sel_store);
+
+
+
+/**********************************************************************
+*    Name         : usb_state_show()
+*    Description : for sysfs control (/sys/class/sec/switch/usb_state)
+*                        return usb state using fsa9480's device1 and device2 register
+*                        this function is used only when NPS want to check the usb cable's state.
+*    Parameter   :
+*                       
+*                       
+*    Return        : USB cable state's string
+*                        USB_STATE_CONFIGURED is returned if usb cable is connected
+***********************************************************************/
+static ssize_t usb_state_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int cable_state;
+
+	cable_state = get_usb_cable_state();
+
+	sprintf(buf, "%s\n", (cable_state & (CRB_JIG_USB<<8 | CRA_USB<<0 ))?"USB_STATE_CONFIGURED":"USB_STATE_NOTCONFIGURED");
+
+	return sprintf(buf, "%s\n", buf);
+} 
+
+
+/**********************************************************************
+*    Name         : usb_state_store()
+*    Description : for sysfs control (/sys/class/sec/switch/usb_state)
+*                        noting to do.
+*    Parameter   :
+*                       
+*                       
+*    Return        : None
+*
+***********************************************************************/
+static ssize_t usb_state_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+
+
+	return 0;
+}
+
+/*sysfs for usb cable's state.*/
+static DEVICE_ATTR(usb_state, S_IRUGO |S_IWUGO | S_IRUSR | S_IWUSR, usb_state_show, usb_state_store);
+
+
+/* UART <-> USB switch (for UART/USB JIG) */
+static void mode_switch(struct work_struct *ignored)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+	fsa9480_check_usb_connection();
+}
+
+static irqreturn_t fsa9480_interrupt(int irq, void *ptr)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+#if 0
+	DEBUG_FSA9480("### FSA9480 interrupt(%d) happened! ###\n", irq);
+	DEBUG_FSA9480("GPIO_JACK_INT_N value : %d\n", gpio_get_value(GPIO_JACK_INT_N));
+#endif
+	queue_work(fsa9480_workqueue, &fsa9480_work);
+
+	return IRQ_HANDLED; 
+}
+
+/* pm init check for MAX_Set*/
+void pm_check(void)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+	if (available_PM_Set()) {
+		set_irq_type(IRQ_EINT(9), IRQ_TYPE_EDGE_FALLING);
+		if (request_irq(IRQ_EINT(9), fsa9480_interrupt, IRQF_DISABLED, "FSA9480 Detected", NULL)) 
+		{
+			DEBUG_FSA9480("[FSA9480]fail to register IRQ[%d] for FSA9480 USB Switch \n", IRQ_EINT(9));
+		}
+		queue_work(fsa9480_workqueue, &fsa9480_work);
+	} else {
+		fsa9480_init_timer.expires = get_jiffies_64()+10;
+		add_timer(&fsa9480_init_timer);
+	}
+}
+
+static int fsa9480_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+	int ret;
+	u8 pData;
+
+	init_waitqueue_head(&usb_detect_waitq); 
+	INIT_WORK(&fsa9480_work, mode_switch);
+	fsa9480_workqueue = create_singlethread_workqueue("fsa9480_workqueue");
+
+	if (device_create_file(switch_dev, &dev_attr_usb_sel) < 0)
+		DEBUG_FSA9480("[FSA9480]Failed to create device file(%s)!\n", dev_attr_usb_sel.attr.name);
+
+	if (device_create_file(switch_dev, &dev_attr_usb_state) < 0)
+		DEBUG_FSA9480("[FSA9480]Failed to create device file(%s)!\n", dev_attr_usb_state.attr.name);
+	
+	/* FSA9480 Interrupt */
+	s3c_gpio_cfgpin(GPIO_JACK_INT_N, S3C_GPIO_SFN(GPIO_JACK_INT_N_AF));
+	s3c_gpio_setpull(GPIO_JACK_INT_N, S3C_GPIO_PULL_NONE);
+
+	/* USB_SEL */
+	if (gpio_is_valid(GPIO_USB_SEL)) {
+		if (gpio_request(GPIO_USB_SEL, S3C_GPIO_LAVEL(GPIO_USB_SEL))) 
+			DEBUG_FSA9480(KERN_ERR "[FSA9480]Failed to request GPIO_USB_SEL! \n");
+		gpio_direction_output(GPIO_USB_SEL, 0);
+	}
+	s3c_gpio_setpull(GPIO_USB_SEL, S3C_GPIO_PULL_NONE);
+	
+	fsa9480_i2c_client.adapter = adap;
+	fsa9480_i2c_client.addr = addr;
+
+	ret = i2c_attach_client(&fsa9480_i2c_client);
+	if (ret < 0) {
+		DEBUG_FSA9480("[FSA9480]failed to attach codec at addr %x\n", addr);
+		return -1;
+	}
+
+	/*init wakelock*/
+	wake_lock_init(&fsa9480_wake_lock, WAKE_LOCK_SUSPEND, "fsa9480_wakelock");
+
+    /*clear interrupt mask register*/
+    fsa9480_modify(&fsa9480_i2c_client,REGISTER_CONTROL,~INT_MASK, INT_MASK);
+	
+	fsa9480_read(&fsa9480_i2c_client, 0x13, &pData);
+	if (pData == 0x24) // PDA
+		usb_path = SWITCH_PDA;	
+	else
+		usb_path = SWITCH_MODEM;	
+
+	usb_sel(usb_path);
+
+	init_timer(&fsa9480_init_timer);
+	fsa9480_init_timer.function = (void*) pm_check;
+
+	pm_check();
+
+	return 0;
+}
+
+static int fsa9480_i2c_attach(struct i2c_adapter *adap)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+	return i2c_probe(adap, &fsa9480_addr_data, fsa9480_codec_probe);
+}
+
+static int fsa9480_i2c_detach(struct i2c_client *client)
+{
+	DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+	i2c_detach_client(client);
+
+	wake_lock_destroy(&fsa9480_wake_lock);
+	return 0;
+}
+
+static int fsa9480_i2c_resume(void)
+{
+   DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+   
+   if(ftm_sleep == 1)
+   	{
+   	/*set auto mode in case of ftm_sleep and wake lock*/
+   	wake_lock(&fsa9480_wake_lock);
+	
+   	DEBUG_FSA9480("[FSA9480]%s ftm sleep is on fsa9480_SetAutoSWMode is called \n ", __func__);
+   	fsa9480_SetAutoSWMode();
+
+	//wait 3 seconds
+    wake_lock_timeout(&fsa9480_wake_lock, 15*HZ);
+   	}
+   
+   return 0;
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver fsa9480_i2c_driver = {
+	.driver = {
+		.name = "fsa9480 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             0,
+	.attach_adapter = fsa9480_i2c_attach,
+	.detach_client =  fsa9480_i2c_detach,
+	.command =        NULL,
+	.resume =         fsa9480_i2c_resume,
+};
+
+static struct i2c_client fsa9480_i2c_client = {
+	.name =   "fsa9480",
+	.driver = &fsa9480_i2c_driver,
+};
+
+
+
+//SEC_BSP_WONSUK_20090810 : Add the codes related SLEEP CMD in factory process
+/*================================================
+	When DIAG SLEEP command arrived, UART RXD, TXD port make disable
+	because CP could not enter the sleep mode due to the UART floating voltage.
+================================================*/
+
+
+/**********************************************************************
+*    Name         : fsa9480_SetManualSW()
+*    Description : Control FSA9480's Manual SW1 and SW2
+*                        
+*    Parameter   :
+*                       @ valManualSw1 : the value to set SW1
+*                       @ valManualSw2 : the value to set SW2
+*    Return        : None
+*
+***********************************************************************/
+void fsa9480_SetManualSW(unsigned char valManualSw1, unsigned char valManualSw2)
+{
+    DEBUG_FSA9480("[FSA9480]%s \n", __func__);
+	unsigned char cont_reg, man_sw1, man_sw2;
+
+    /*Set Manual switch*/
+	fsa9480_write(&fsa9480_i2c_client, REGISTER_MANUALSW1, valManualSw1);
+	mdelay(20);
+	
+	fsa9480_write(&fsa9480_i2c_client, REGISTER_MANUALSW2, valManualSw2);
+	mdelay(20);
+
+
+	/*when detached the cable, Control register automatically be restored.*/
+	fsa9480_read(&fsa9480_i2c_client, REGISTER_CONTROL, &cont_reg);
+	mdelay(20);
+	DEBUG_FSA9480("[FSA9480] fsa9480_SetManualSW : [Before]Control Register's value is %s\n",&cont_reg);
+
+	/*set switching mode to MANUAL*/
+	fsa9480_write(&fsa9480_i2c_client, REGISTER_CONTROL, 0x1A);
+
+
+	/* Read current setting value , manual sw1, manual sw2, control register.*/
+	fsa9480_read(&fsa9480_i2c_client, REGISTER_MANUALSW1, &man_sw1);
+	mdelay(20);
+	DEBUG_FSA9480("[FSA9480] fsa9480_SetManualSW : Manual SW1 Register's value is %s\n",&man_sw1);
+
+	fsa9480_read(&fsa9480_i2c_client, REGISTER_MANUALSW2, &man_sw2);
+	mdelay(20);
+	DEBUG_FSA9480("[FSA9480] fsa9480_SetManualSW : Manual SW2 Register's value is %s\n",&man_sw2);
+
+	fsa9480_read(&fsa9480_i2c_client, REGISTER_CONTROL, &cont_reg);
+	DEBUG_FSA9480("[FSA9480] fsa9480_SetManualSW : [After]Control Register's value is %s\n",&cont_reg);
+}
+
+
+
+/**********************************************************************
+*    Name         : fsa9480_SetAutoSWMode()
+*    Description : Set FSA9480 with Auto Switching Mode.
+*                        
+*    Parameter   : None
+*                       @ 
+*                       @ 
+*    Return        : None
+*
+***********************************************************************/
+void fsa9480_SetAutoSWMode(void)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+	unsigned char cont_reg=0xff;
+
+	/*set Auto Swithing mode */
+	fsa9480_write(&fsa9480_i2c_client, REGISTER_CONTROL, 0x1E);
+}
+
+
+/**********************************************************************
+*    Name         : fsa9480_MakeRxdLow()
+*    Description : Make UART port to OPEN state.
+*                        
+*    Parameter   : None
+*                       @ 
+*                       @ 
+*    Return        : None
+*
+***********************************************************************/
+void fsa9480_MakeRxdLow(void)
+{
+    DEBUG_FSA9480("[FSA9480]%s\n ", __func__);
+	unsigned char hidden_reg;
+	
+	fsa9480_write(&fsa9480_i2c_client, HIDDEN_REGISTER_MANUAL_OVERRDES1, 0x0a); 
+	mdelay(20);
+	fsa9480_read(&fsa9480_i2c_client, HIDDEN_REGISTER_MANUAL_OVERRDES1, &hidden_reg);
+	fsa9480_SetManualSW(0x00, 0x00);
+}
+
+
+EXPORT_SYMBOL(fsa9480_SetManualSW);
+EXPORT_SYMBOL(fsa9480_SetAutoSWMode);
+EXPORT_SYMBOL(fsa9480_MakeRxdLow);
+
+
diff -Nur linux-2.6.29/drivers/usb/gadget/fsa9480_i2c.h linux-2.6.29-spica/drivers/usb/gadget/fsa9480_i2c.h
--- linux-2.6.29/drivers/usb/gadget/fsa9480_i2c.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/fsa9480_i2c.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,177 @@
+/*
+* ==============================================================================
+*  Name          : fsa9480_i2c.h
+*  Part of         : MicroUsbDetector Driver
+*  Description :  Definitions of FSA9480
+*  Version       : 0
+*  Author         : wonsuk jung (grant.jung@samsung.com)
+*
+* ==============================================================================
+*/
+
+
+/* enalbing debug massage related with FSA9480*/
+#define FSA9480_DBG_ENABLE	1
+
+#ifdef  FSA9480_DBG_ENABLE
+#define DEBUG_FSA9480(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_FSA9480(fmt,args...) do {} while(0)
+#endif
+
+
+/********************************************************************/
+/* FSA9480 Register definition                                                                                */
+/********************************************************************/
+/* DEVICE ID Register*/
+#define REGISTER_DEVICEID	        0x01     
+/* CONTROL Register*/
+#define REGISTER_CONTROL	        0x02   
+#define REGISTER_INTERRUPT1	        0x03  
+#define REGISTER_INTERRUPT2	        0x04   
+#define REGISTER_INTERRUPTMASK1 	0x05
+#define REGISTER_INTERRUPTMASK2 	0x06
+#define REGISTER_ADC 	            0x07
+#define REGISTER_TIMINGSET1      	0x08
+#define REGISTER_TIMINGSET2 	    0x09
+#define REGISTER_DEVICETYPE1    	0x0A
+#define REGISTER_DEVICETYPE2 	    0x0B
+#define REGISTER_BUTTON1 	        0x0C
+#define REGISTER_BUTTON2 	        0x0D
+#define REGISTER_CARKITSTATUS 	    0x0E
+#define REGISTER_CARKITINT1 	    0x0F
+#define REGISTER_CARKITINT2 	    0x10
+#define REGISTER_CARKITMASK1 	    0x11
+#define REGISTER_CARKITMASK2 	    0x12
+/* Manual SW1 Register*/
+#define REGISTER_MANUALSW1	        0x13                       
+/* Manual SW2 Register */
+#define REGISTER_MANUALSW2	        0x14                   
+/* Hidden Register*/
+#define HIDDEN_REGISTER_MANUAL_OVERRDES1	0x1B     
+
+/*define IRQ INTB*/
+#define IRQ_FSA9480_INTB	IRQ_EINT(9)
+
+
+//CR2 : Control Register
+#define		INT_MASK				(0x1 << 0)
+#define 	SW_WAIT		 			(0x1 << 1)
+#define 	MANUAL_SW 				(0x1 << 2)
+#define 	RAW_DATA				(0x1 << 3)
+#define 	SW_OPEN					(0x1 << 4)
+
+//CR3 : Interrupt 1 Register
+#define		ATTACH					(0x1 << 0)
+#define		DETACH					(0x1 << 1)
+#define		KEY_PRESS				(0x1 << 2)
+#define		LONG_KEY_PRESS			(0x1 << 3)
+#define		LONG_KEY_RELEASE		(0x1 << 4)
+#define		OVP_EN					(0x1 << 5)
+#define		OCP_EN					(0x1 << 6)
+#define		OVP_OCP_DIS				(0x1 << 7)
+
+//CR5 : Interrupt 1 Mask Register
+#define		ATTACH_INT_MASK				(0x1 <<0)
+#define 	DETACH_INT_MASK 			(0x1 <<1)
+#define 	KEY_PRESS_INT_MASK			(0x1 <<2)
+#define 	LONGKEY_PRESS_INT_MASK 		(0x1 <<3)
+#define 	LONGKEY_RELEASE_INT_MASK	(0x1 <<4)
+#define 	OVP_INT_MASK 				(0x1 <<5)
+#define 	OCP_INT_MASK 				(0x1 <<6)
+#define 	OVP_OCP_DIS_INT_MASK 		(0x1 <<7)
+
+//CR7 : ADC Register
+#define		USB_OTG						0x00
+#define		SEND_END					0x01
+#define		AUDIO_REMOTE_S1_BUTTON		0x02
+#define 	AUDIO_REMOTE_S2_BUTTON		0x03
+#define 	AUDIO_REMOTE_S3_BUTTON		0x04
+#define 	AUDIO_REMOTE_S4_BUTTON		0x05
+#define 	AUDIO_REMOTE_S5_BUTTON		0x06
+#define 	AUDIO_REMOTE_S6_BUTTON		0x07
+#define 	AUDIO_REMOTE_S7_BUTTON		0x08
+#define 	AUDIO_REMOTE_S8_BUTTON		0x09
+#define 	AUDIO_REMOTE_S9_BUTTON		0x0A
+#define 	AUDIO_REMOTE_S10_BUTTON		0x0B
+#define 	AUDIO_REMOTE_S11_BUTTON		0x0C
+#define 	AUDIO_REMOTE_S12_BUTTON		0x0D
+#define		RESERVED_ACCESSORY_1		0x0E
+#define 	RESERVED_ACCESSORY_2		0x0F
+#define 	RESERVED_ACCESSORY_3		0x10
+#define 	RESERVED_ACCESSORY_4		0x11
+#define 	RESERVED_ACCESSORY_5		0x12
+#define		AUDIO_DEICE_TYPE_2			0x13
+#define		PHONE_POWERED_DEVICE		0X14
+#define		TTY_CONVERTER				0x15
+#define		UART_CABLE					0x16
+#define 	CEA936A_TYPE_1_CHARGER		0x17
+#define		FACTORY_MODE_BOOT_OFF_USB	0x18
+#define 	FACTORY_MODE_BOOT_ON_USB	0x19
+#define		AUDIO_VEDIO_CABLE			0x1A
+#define		CEA936A_TYPE_2_CHARGER		0x1B
+#define		FACTORY_MODE_BOOT_OFF_UART	0x1C
+#define 	FACTORY_MODE_BOOT_ON_UART	0x1D
+#define 	AUDIO_DEVICE_TYPE_1			0x1E
+#define		USB_OR_ACCESSORY_DETACH		0x1F
+
+//CR8 : Timing Set 1 Register
+#define 	DEVICE_WAKE_UP_TIME_MASK	0x0F
+#define 	KEY_PRESS_TIME_MASK			0xF0
+
+#define		KEY_PRESS_TIME_300MS		0x20
+#define 	KEY_PRESS_TIME_700MS		0x60
+#define 	KEY_PRESS_TIME_1S			0x90
+
+//CR9 : Timing Set 2 Register
+#define		LONGKEY_PRESS_TIME_MASK		0x0F
+#define		SWITCHING_TIME_MASK			0xF0
+
+#define		LONGKEY_PRESS_TIME_1S		0x07
+#define 	LONGKEY_PRESS_TIME_1_5S		0x0C
+
+//CRA : Device Type 1 Register
+#define		CRA_AUDIO_TYPE1             (0x1 <<0)
+#define		CRA_AUDIO_TYPE2             (0x1 <<1)
+#define		CRA_USB                     (0x1 <<2)
+#define		CRA_UART                    (0x1 <<3)
+#define		CRA_CARKIT                  (0x1 <<4)
+#define		CRA_USB_CHARGER             (0x1 <<5)
+#define		CRA_DEDICATED_CHG           (0x1 <<6)
+#define		CRA_USB_OTG                 (0x1 <<7)
+
+//CRB : Device Type 2 Register
+#define		CRB_JIG_USB_ON              (0x1 <<0)
+#define		CRB_JIG_USB_OFF             (0x1 <<1)
+#define		CRB_JIG_UART_ON             (0x1 <<2)
+#define		CRB_JIG_UART_OFF            (0x1 <<3)
+#define		CRB_PPD                     (0x1 <<4)
+#define		CRB_TTY                     (0x1 <<5)
+#define		CRB_AV                      (0x1 <<6)
+//Factory mode cable detected
+#define     CRB_JIG_USB                 (0x3 <<0)
+#define     CRB_JIG_UART                (0x3 <<2)
+
+//Device1, 2 Register's Device Not Connected value
+#define     DEVICE_TYPE_NC              0x00
+
+//CRC : Button 1 Register
+#define		BUTTON_SEND_END				(0x1 <<0)
+#define 	BUTTON_1	 				(0x1 <<1)
+#define 	BUTTON_2 					(0x1 <<2)
+#define 	BUTTON_3 					(0x1 <<3)
+#define 	BUTTON_4 					(0x1 <<4)
+#define 	BUTTON_5 					(0x1 <<5)
+#define 	BUTTON_6 					(0x1 <<6)
+#define 	BUTTON_7 					(0x1 <<7)
+
+//CRD : Button 2 Register
+#define 	BUTTON_8		 			(0x1 <<0)
+#define 	BUTTON_9					(0x1 <<1)
+#define 	BUTTON_10					(0x1 <<2)
+#define 	BUTTON_11					(0x1 <<3)
+#define 	BUTTON_12					(0x1 <<4)
+#define 	BUTTON_ERROR				(0x1 <<5)
+#define 	BUTTON_UNKNOW				(0x1 <<6)
+
+
diff -Nur linux-2.6.29/drivers/usb/gadget/gadget_chips.h linux-2.6.29-spica/drivers/usb/gadget/gadget_chips.h
--- linux-2.6.29/drivers/usb/gadget/gadget_chips.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/usb/gadget/gadget_chips.h	2010-05-06 12:42:45.644210217 +0700
@@ -104,6 +104,12 @@
 #define gadget_is_s3c2410(g)    0
 #endif
 
+#if defined(CONFIG_USB_GADGET_S3C_FS) || defined(CONFIG_USB_GADGET_S3C_HS) || defined(CONFIG_USB_GADGET_S3C_OTGD_HS)
+#define gadget_is_s3c(g)    !strcmp("s3c-udc", (g)->name)
+#else
+#define gadget_is_s3c(g)    0
+#endif
+
 #ifdef CONFIG_USB_GADGET_AT91
 #define gadget_is_at91(g)	!strcmp("at91_udc", (g)->name)
 #else
@@ -231,6 +237,8 @@
 		return 0x22;
 	else if (gadget_is_ci13xxx(gadget))
 		return 0x23;
+	else if (gadget_is_s3c(gadget))
+		return 0x24;
 	return -ENOENT;
 }
 
diff -Nur linux-2.6.29/drivers/usb/gadget/Kconfig linux-2.6.29-spica/drivers/usb/gadget/Kconfig
--- linux-2.6.29/drivers/usb/gadget/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/usb/gadget/Kconfig	2010-05-06 12:42:45.644210217 +0700
@@ -112,6 +112,8 @@
 choice
 	prompt "USB Peripheral Controller"
 	depends on USB_GADGET
+	default USB_GADGET_S3C_OTGD_HS if (PLAT_S3C64XX || PLAT_S5P64XX || PLAT_S5PC1XX || PLAT_S5PC11X)
+	default USB_GADGET_S3C_HS if PLAT_S3C24XX
 	help
 	   A USB device uses a controller to talk to its host.
 	   Systems should have only one such upstream link.
@@ -460,6 +462,23 @@
 	select USB_GADGET_SELECTED
 
 
+config USB_GADGET_S3C_OTGD_HS
+        boolean "S3C high speed(2.0, dual-speed) USB OTG device"
+        depends on (PLAT_S3C64XX || PLAT_S5P64XX || PLAT_S5PC1XX || PLAT_S5PC11X)
+        select USB_GADGET_SELECTED
+	select USB_GADGET_DUALSPEED
+        help
+           Say "y" to link the driver statically, or "m" to build a
+           dynamically linked module called "s3c_udc_hs" and force all
+           gadget drivers to also be dynamically linked.
+
+config USB_GADGET_S3C_OTGD_HS_DMA_MODE
+	bool "S3C OTG DMA MODE support"
+	depends on USB_GADGET_S3C_OTGD_HS
+	default y
+		help
+			Say "y" to make S3C_OTGD working as DMA mode, or it works as slave mode.
+
 #
 # LAST -- dummy/emulated controller
 #
@@ -670,6 +689,12 @@
 	  which includes instructions and a "driver info file" needed to
 	  make MS-Windows work with CDC ACM.
 
+config USB_DUN_SUPPORT
+	bool "ACM line state notification to support DUN"
+	depends on USB_G_SERIAL
+	default y
+	help
+
 config USB_MIDI_GADGET
 	tristate "MIDI Gadget (EXPERIMENTAL)"
 	depends on SND && EXPERIMENTAL
@@ -699,6 +724,28 @@
 	  For more information, see Documentation/usb/gadget_printer.txt
 	  which includes sample code for accessing the device file.
 
+config USB_ANDROID_ADB_UMS
+	bool "Android Composite(ADB + UMS) Gadget"
+	depends on SWITCH
+	help
+	  The Android gadget provides mass storage and adb transport.
+
+	  Say "y" to link the driver statically, not support dynamically linked module
+
+config USB_ANDROID_ADB_UMS_ACM
+	bool "Android Composite(ADB + UMS + ACM) Gadget"
+	depends on SWITCH
+	help
+	  The Android gadget provides mass storage and adb transport and acm.
+
+	  Say "y" to link the driver statically, not support dynamically linked module
+	  
+config USB_DUN_SUPPORT
+	bool "ACM line state notification to support DUN"
+	depends on USB_ANDROID_ADB_UMS_ACM
+	default y
+	help
+
 config USB_CDC_COMPOSITE
 	tristate "CDC Composite Device (Ethernet and ACM)"
 	depends on NET
@@ -713,6 +760,12 @@
 	  Say "y" to link the driver statically, or "m" to build a
 	  dynamically linked module.
 
+config USB_DUN_SUPPORT
+	bool "ACM line state notification to support DUN"
+	depends on USB_CDC_COMPOSITE
+	default y
+	help
+	
 # put drivers that need isochronous transfer support (for audio
 # or video class gadget drivers), or specific hardware, here.
 
diff -Nur linux-2.6.29/drivers/usb/gadget/Makefile linux-2.6.29-spica/drivers/usb/gadget/Makefile
--- linux-2.6.29/drivers/usb/gadget/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/usb/gadget/Makefile	2010-05-06 12:42:45.644210217 +0700
@@ -21,6 +21,7 @@
 obj-$(CONFIG_USB_M66592)	+= m66592-udc.o
 obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
 obj-$(CONFIG_USB_CI13XXX)	+= ci13xxx_udc.o
+obj-$(CONFIG_USB_GADGET_S3C_OTGD_HS)   += s3c-udc-otg-hs.o
 
 #
 # USB gadget drivers
@@ -31,8 +32,20 @@
 g_midi-objs			:= gmidi.o
 gadgetfs-objs			:= inode.o
 g_file_storage-objs		:= file_storage.o
-g_printer-objs			:= printer.o
+g_printer-objs			:= printer.o 
 g_cdc-objs			:= cdc2.o
+g_android_adb_ums-objs	:= android.o f_adb.o f_mass_storage.o 
+g_android_adb_ums_acm-objs	:= adb_ums_acm.o f_adb.o f_mass_storage.o u_serial.o f_acm.o
+
+#ifeq ($(CONFIG_USB_ETH_RNDIS),y)
+#	g_ether-objs		+= f_rndis.o rndis.o
+#endif
+
+ifeq ($(CONFIG_USB_DUN_SUPPORT),y)
+	g_serial-objs		+= serial_acm.o	
+	g_cdc-objs		+= serial_acm.o
+	g_android_adb_ums_acm-objs	+= serial_acm.o
+endif
 
 obj-$(CONFIG_USB_ZERO)		+= g_zero.o
 obj-$(CONFIG_USB_ETH)		+= g_ether.o
@@ -42,4 +55,5 @@
 obj-$(CONFIG_USB_G_PRINTER)	+= g_printer.o
 obj-$(CONFIG_USB_MIDI_GADGET)	+= g_midi.o
 obj-$(CONFIG_USB_CDC_COMPOSITE) += g_cdc.o
-
+obj-$(CONFIG_USB_ANDROID_ADB_UMS)	+= g_android_adb_ums.o
+obj-$(CONFIG_USB_ANDROID_ADB_UMS_ACM)	+= g_android_adb_ums_acm.o
diff -Nur linux-2.6.29/drivers/usb/gadget/s3c-udc.h linux-2.6.29-spica/drivers/usb/gadget/s3c-udc.h
--- linux-2.6.29/drivers/usb/gadget/s3c-udc.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/s3c-udc.h	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,190 @@
+/*
+ * drivers/usb/gadget/s3c-udc.h
+ * Samsung S3C on-chip full/high speed USB device controllers
+ *
+ * Copyright (C) 2009 Samsung Electronics, Seung-Soo Yang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+ 
+#ifndef __S3C_USB_GADGET
+#define __S3C_USB_GADGET
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/dma-mapping.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+
+#include <asm/byteorder.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+
+#include <plat/regs-usb-otg-hs.h>
+#include <plat/regs-clock.h> 
+#include <plat/regs-gpio.h>
+#include <plat/gpio-cfg.h>
+
+#include <mach/map.h>
+#include <mach/hardware.h>
+
+
+//S3C UDC send ZLP if req.zero == 1
+#define S3C_UDC_ZLP		1
+
+//Set delaying or not for serial usb bulk transfer
+#define SERIAL_TRANSFER_DELAY 	1
+
+//Maxium EPs implemented
+#define	SUPPORTING_MAX_EP_NUM	9	//0 ~ 9
+
+/**
+ * Max packet size OTG IP support 
+ */
+#define EP0_FIFO_SIZE		64
+#define BULK_FIFO_SIZE		512
+#define INT_FIFO_SIZE		1024
+#define ISO_FIFO_SIZE		1024
+
+#define S3C_MAX_ENDPOINTS	16
+
+/**
+ * states of control tranfser
+ */
+#define WAIT_FOR_SETUP          0
+#define DATA_STATE_XMIT         1
+#define DATA_STATE_RECV         2
+#define WAIT_FOR_OUT_STATUS     3
+#define DATA_STATE_NEED_ZLP     4
+#define RegReadErr				5
+#define FAIL_TO_SETUP		    6
+
+/**
+ * Definitions of EP index
+ */
+#define EP0_CON		0
+#define EP1_OUT		1
+#define EP2_IN		2
+#define EP3_IN		3
+#define EP4_OUT		4
+#define EP5_IN		5
+#define EP6_IN		6
+#define EP7_OUT		7
+#define EP8_IN		8
+#define EP9_IN		9
+#define EP_MASK		0xF
+
+/**
+ * struct s3c_ep
+ */
+struct s3c_ep {
+	struct usb_ep ep;
+	struct s3c_udc *dev;
+
+	const struct usb_endpoint_descriptor *desc;
+	struct list_head queue;
+	unsigned long pio_irqs;
+
+	u8 stopped;
+	u8 bEndpointAddress;
+	u8 bmAttributes;
+	u32 fifo;
+};
+//---------------------------------------------------------------------------------------
+
+/**
+ * @struct s3c_request
+ */
+struct s3c_request {
+	struct usb_request req;
+	struct list_head queue;	
+#if S3C_UDC_ZLP
+	bool	zlp;
+#endif
+};
+//---------------------------------------------------------------------------------------
+
+
+/**
+ * gadget_driver
+ * USB functional gadget driver registered
+ */
+enum gadget_driver {
+	NO_GADGET_DRIVER,
+	ETHER_RNDIS, 
+	ETHER_CDC,
+	ANDROID_ADB, 
+	ANDROID_ADB_UMS,
+	ANDROID_ADB_UMS_ACM,
+	SERIAL,
+	CDC2,
+	FILE_STORAGE,
+};
+//---------------------------------------------------------------------------------------
+
+/**
+ * @struct s3c_udc
+ * 
+ */
+struct s3c_udc {
+	struct usb_gadget gadget;
+	struct usb_gadget_driver *driver;
+	struct platform_device *dev;
+	struct s3c_ep ep[S3C_MAX_ENDPOINTS];
+	
+	enum usb_device_state udc_state, udc_resume_state;
+	enum gadget_driver config_gadget_driver;
+	enum usb_device_speed udc_resume_speed;
+
+	spinlock_t lock;		
+	u16 devstatus;
+
+	int clocked;
+	int powered;
+
+	int ep0state;
+	unsigned char usb_address;
+	
+	struct timer_list srp_timer;
+};
+//---------------------------------------------------------------------------------------
+
+/**
+ * definition of helper macro
+ * 
+ */
+#define ep_is_in(EP) 		(((EP)->bEndpointAddress&USB_DIR_IN)==USB_DIR_IN)
+#define ep_index(EP) 		((EP)->bEndpointAddress&USB_ENDPOINT_NUMBER_MASK)
+#define ep_maxpacket(EP) 	((EP)->ep.maxpacket)
+
+#define BYTES2MAXP(x)	(x / 8)
+#define MAXP2BYTES(x)	(x * 8)
+//---------------------------------------------------------------------------------------
+
+#endif
diff -Nur linux-2.6.29/drivers/usb/gadget/s3c-udc-otg-hs.c linux-2.6.29-spica/drivers/usb/gadget/s3c-udc-otg-hs.c
--- linux-2.6.29/drivers/usb/gadget/s3c-udc-otg-hs.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/s3c-udc-otg-hs.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,1494 @@
+/*
+ * drivers/usb/gadget/s3c-udc-otg-hs.c
+ * Samsung S3C on-chip full/high speed USB OTG 2.0 device controllers
+ *
+ * Copyright (C) 2009 Samsung Electronics, Seung-Soo Yang
+ * Copyright (C) 2008 Samsung Electronics, Kyu-Hyeok Jang, Seung-Soo Yang
+ * Copyright (C) 2004 Mikko Lahteenmaki, Nordic ID
+ * Copyright (C) 2004 Bo Henriksen, Nordic ID
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ *	The changes of udc_state of struct s3c_udc in functions
+ *	
+ *	  s3c_udc_probe			s3c_udc->udc_state = USB_STATE_NOTATTACHED;
+ *	  s3c_udc_enable		s3c_udc->udc_state = USB_STATE_POWERED;
+ *	  handle_reset_intr		s3c_udc->udc_state = USB_STATE_DEFAULT;
+ *	  s3c_udc_set_address	s3c_udc->udc_state = USB_STATE_ADDRESS;
+ *	  s3c_ep0_setup			s3c_udc->udc_state = USB_STATE_CONFIGURED;
+ *	  handle_suspend_intr	s3c_udc->udc_state = USB_STATE_SUSPENDED;
+ *	  s3c_udc_disable		s3c_udc->udc_state = USB_STATE_NOTATTACHED;
+ *
+ */ 
+
+#include "s3c-udc.h"
+
+//---------------------------------------------------------------------------------------
+
+/* enalbing many debug message could make the USB enumeration process failed */
+#define OTG_DBG_ENABLE	0
+
+/*
+ * set USBCV_CH9_REMOTE_WAKE_UP_TEST 1 ONLY for testing USBCV ch9
+ * RemoteWakeupTestEnabled & RemoteWakeupTestDisabled
+ * Confirm USBCV_CH9_REMOTE_WAKE_UP_TEST 
+ * in s3c-udc-otg-hs.c and f_adb.h 
+ */
+#define	USBCV_CH9_REMOTE_WAKE_UP_TEST 0
+
+/*
+ * setting TESTING_SOFT_CONNCTION 1 make
+ * /sys/class/switch/S3C_UDC_SOFT_SWITCH file
+ * this is only for testing UDC soft connect / disconnect logic 
+ * to find any side-effect related with battery to identify 
+ * a device connected (USB, AC, TA)
+ */
+#define TESTING_SOFT_CONNCTION 0
+
+#if OTG_DBG_ENABLE
+#define DEBUG_S3C_UDC_SETUP
+#define DEBUG_S3C_UDC_EP0
+#define DEBUG_S3C_UDC_ISR
+#define DEBUG_S3C_UDC_OUT_EP
+#define DEBUG_S3C_UDC_IN_EP
+#define DEBUG_S3C_UDC
+#define DEBUG_S3C_UDC_PM
+#define DEBUG_S3C_UDC_SETUP_FEATURE
+#define DEBUG_S3C_UDC_ERROR
+
+#else
+#undef DEBUG_S3C_UDC_SETUP
+#undef DEBUG_S3C_UDC_EP0
+#undef DEBUG_S3C_UDC_ISR
+#undef DEBUG_S3C_UDC_OUT_EP
+#undef DEBUG_S3C_UDC_IN_EP
+#undef DEBUG_S3C_UDC
+#undef DEBUG_S3C_UDC_PM
+#undef DEBUG_S3C_UDC_SETUP_FEATURE
+#undef DEBUG_S3C_UDC_ERROR
+#endif
+
+//temp
+#define DEBUG_S3C_UDC_ERROR
+//#define DEBUG_S3C_UDC_SETUP
+//#define DEBUG_S3C_UDC_EP0
+#define DEBUG_S3C_UDC_PM
+//#define DEBUG_S3C_UDC_SETUP_FEATURE
+	
+#if defined(DEBUG_S3C_UDC_ISR) || defined(DEBUG_S3C_UDC_EP0)
+static char *state_names[] = {
+	"WAIT_FOR_SETUP",
+	"DATA_STATE_XMIT",
+	"DATA_STATE_NEED_ZLP",
+	"WAIT_FOR_OUT_STATUS",
+	"DATA_STATE_RECV",
+	"RegReadErr"
+	};
+#endif
+
+#ifdef DEBUG_S3C_UDC_ERROR
+#define DEBUG_ERROR(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_ERROR(fmt,args...) do {} while(0)
+#endif
+
+#ifdef DEBUG_S3C_UDC_SETUP
+#define DEBUG_SETUP(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_SETUP(fmt,args...) do {} while(0)
+#endif
+
+#ifdef DEBUG_S3C_UDC_PM
+#define DEBUG_PM(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_PM(fmt,args...) do {} while(0)
+#endif
+
+#ifdef DEBUG_S3C_UDC_EP0
+#define DEBUG_EP0(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_EP0(fmt,args...) do {} while(0)
+#endif
+
+#ifdef DEBUG_S3C_UDC
+#define DEBUG(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG(fmt,args...) do {} while(0)
+#endif
+
+#ifdef DEBUG_S3C_UDC_ISR
+#define DEBUG_ISR(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_ISR(fmt,args...) do {} while(0)
+#endif
+
+#ifdef DEBUG_S3C_UDC_OUT_EP
+#define DEBUG_OUT_EP(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_OUT_EP(fmt,args...) do {} while(0)
+#endif
+
+#ifdef DEBUG_S3C_UDC_IN_EP
+#define DEBUG_IN_EP(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_IN_EP(fmt,args...) do {} while(0)
+#endif
+
+#ifdef DEBUG_S3C_UDC_SETUP_FEATURE
+#define DEBUG_FEATURE(fmt,args...) printk(fmt, ##args)
+#else
+#define DEBUG_FEATURE(fmt,args...) do {} while(0)
+#endif
+//---------------------------------------------------------------------------------------
+
+#define	DRIVER_DESC		"Samsung Dual-speed USB 2.0 OTG Device Controller"
+#define	DRIVER_VERSION	__DATE__
+
+static	struct s3c_udc	*the_controller;
+static struct clk	*otg_clock = NULL;
+
+static const char driver_name[] = "s3c-udc";
+static const char driver_desc[] = DRIVER_DESC;
+static const char ep0name[] = "ep0-control";
+//---------------------------------------------------------------------------------------
+
+/*
+ *	Samsung S3C on-chip full/high speed USB OTG 2.0 device operates
+ *	both internal DMA mode and slave mode.
+ *	The implementation of the slave mode is not stable at the time of writing(Feb. 18 2009)
+ *  Make sure CONFIG_USB_GADGET_S3C_OTGD_HS_DMA_MODE is defineds
+ */
+
+#if defined(CONFIG_USB_GADGET_S3C_OTGD_HS_DMA_MODE) 
+#define GINTMSK_INIT	(INT_ENUMDONE|INT_RESET|INT_SUSPEND)
+#define GINTMSK_RESET	(INT_OUT_EP|INT_IN_EP|INT_RESUME|INT_ENUMDONE|INT_RESET\
+							|INT_SUSPEND)
+#define DOEPMSK_INIT	(CTRL_OUT_EP_SETUP_PHASE_DONE|TRANSFER_DONE)
+#define DIEPMSK_INIT	(NON_ISO_IN_EP_TIMEOUT|TRANSFER_DONE)
+#define GAHBCFG_INIT	(PTXFE_HALF|NPTXFE_HALF|MODE_DMA|BURST_SINGLE|GBL_INT_UNMASK)
+#else
+#define GINTMSK_INIT	(INT_RESUME|INT_ENUMDONE|INT_RESET|INT_SUSPEND|	INT_RX_FIFO_NOT_EMPTY\
+						|INT_GOUTNakEff|INT_GINNakEff)
+#define DOEPMSK_INIT	(CTRL_OUT_EP_SETUP_PHASE_DONE|AHB_ERROR|TRANSFER_DONE)
+#define DIEPMSK_INIT	(INTKN_TXFEMP|NON_ISO_IN_EP_TIMEOUT|TRANSFER_DONE|AHB_ERROR)
+#define GAHBCFG_INIT	(PTXFE_HALF|NPTXFE_HALF|MODE_SLAVE|BURST_INCR16|GBL_INT_UNMASK)
+
+#endif
+//---------------------------------------------------------------------------------------
+
+/*
+ * Behavior of Power Management
+ * 
+ * 1. USB Bus PM
+ *		The suspend interrupt happens when USB Host(PC) falls into sleep mode.
+ *		Then handler of suspend calls suspend callback function of gadget 
+ *		and call s3c_udc_stop_activity() if it already enumerated
+ *		Then, s3c_udc_power_down will be invoked by fsa9480 to power down s3c-udc and 
+ *		disable sourcing otg clock
+ *		
+ *		When USB host wakes up, s3c_udc_power_up will be invoked by fsa9480 to 
+ *		power up s3c-udc and enable sourcing otg clock
+ *		And, USB host enumerates S3C-UDC again without resume interrupt
+ *
+ * 2. System PM
+ *		When the target system falls into sleep mode, it calls s3c_udc_suspend().
+ *		Then, s3c_udc_power_down will be invoked by fsa9480 to power down s3c-udc and 
+ *		disable sourcing otg clock
+ * 
+ *		When the target resumes, it calls s3c_udc_resume().
+ *		Then fsa9480_check_usb_connection() will be invoked to check USB connections 
+ * 		if connected s3c_udc_power_up() power up s3c-udc and enable sourcing otg clock
+ * 		or s3c_udc_power_down() power down s3c-udc and disable sourcing otg clock
+ * 
+ *		In case of Android system there is a lock for not falling into the sleep mode when
+ *		USB connected. [settings->Application->Development->Stay awake]
+ *		Although usb connected the target system will fall into sleep mode 
+ *		if [Stay awake] unchecked
+ */
+
+/*
+ * Local declarations.
+ */
+static void s3c_req_done(struct s3c_ep *ep, struct s3c_request *req, int status);
+static void s3c_udc_stop_activity(struct s3c_udc *dev, struct usb_gadget_driver *driver);
+static int	s3c_udc_enable(struct s3c_udc *dev);
+static void s3c_udc_set_address(struct s3c_udc *dev, unsigned char address);
+static void s3c_udc_initialize(struct s3c_udc *dev);
+
+static int  s3c_ep_enable(struct usb_ep *ep, const struct usb_endpoint_descriptor *);
+static int  s3c_ep_disable(struct usb_ep *ep);
+static void s3c_ep_free_request(struct usb_ep *ep, struct usb_request *);
+static int  s3c_ep_queue(struct usb_ep *ep, struct usb_request *, gfp_t gfp_flags);
+static int  s3c_ep_dequeue(struct usb_ep *ep, struct usb_request *);
+static int  s3c_ep_set_halt(struct usb_ep *ep, int);
+static struct usb_request *s3c_ep_alloc_request(struct usb_ep *ep, gfp_t gfp_flags);
+static inline void s3c_ep_send_zlp(u32 ep_num);
+
+static void s3c_ep0_read(struct s3c_udc *dev);
+static void s3c_ep0_handle(struct s3c_udc *dev);
+static int  s3c_ep0_write(struct s3c_udc *dev);
+static int  s3c_ep0_write_fifo(struct s3c_ep *ep, struct s3c_request *req);
+
+//---------------------------------------------------------------------------------------
+
+/**
+ * global usb_ctrlrequest struct to store 
+ * Setup data of Control Request Host sent
+ */
+struct usb_ctrlrequest g_ctrl __attribute__((aligned(8)));
+//---------------------------------------------------------------------------------------
+
+/**
+ * usb_ep_ops s3c_ep_ops
+ * 
+ */
+static struct usb_ep_ops s3c_ep_ops = {
+	.enable = s3c_ep_enable,
+	.disable = s3c_ep_disable,
+
+	.alloc_request = s3c_ep_alloc_request,
+	.free_request = s3c_ep_free_request,
+
+	.queue = s3c_ep_queue,
+	.dequeue = s3c_ep_dequeue,
+
+	.set_halt = s3c_ep_set_halt,
+};
+//---------------------------------------------------------------------------------------
+
+/*
+ * make s3c-udc being connected
+ */ 
+void s3c_udc_soft_connect(void)
+{
+	u32 reg_val;
+	
+	DEBUG("[%s]\n", __func__);
+	reg_val = readl(S3C_UDC_OTG_DCTL);
+	reg_val = reg_val & ~SOFT_DISCONNECT;
+	writel(reg_val, S3C_UDC_OTG_DCTL);
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ * make s3c-udc being disconnected
+ */ 
+void s3c_udc_soft_disconnect(void)
+{
+	u32 reg_val;
+//	struct s3c_udc *dev = the_controller;
+
+	DEBUG("[%s]\n", __func__);	
+	reg_val = readl(S3C_UDC_OTG_DCTL);
+	reg_val |= SOFT_DISCONNECT;
+	writel(reg_val, S3C_UDC_OTG_DCTL);
+
+//	s3c_udc_stop_activity(dev, dev->driver);
+//	s3c_udc_set_disconnect_state(dev);
+}
+//---------------------------------------------------------------------------------------
+
+#if TESTING_SOFT_CONNCTION
+#include <linux/switch.h>
+struct switch_dev soft_switch;
+#define	SOFT_SWITCH_NAME "S3C_UDC_SOFT_SWITCH"
+
+static ssize_t soft_switch_name(struct switch_dev *sdev, char *buf)
+{
+	return sprintf(buf, "%s\n", SOFT_SWITCH_NAME);
+}
+
+static ssize_t soft_switch_state(struct switch_dev *sdev, char *buf)
+{
+	if (soft_switch.state == 0) {
+		s3c_udc_soft_disconnect();
+		udelay(20);
+		s3c_udc_soft_connect();
+		soft_switch.state = 1;
+	}
+	else {
+		s3c_udc_soft_disconnect();
+		udelay(20);
+		s3c_udc_soft_connect();
+		soft_switch.state = 0;
+	}
+	return sprintf(buf, "%s\n", (soft_switch.state ? "1" : "0"));
+}
+#endif
+
+/**
+ * Proc related
+ * 
+ */
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+
+static const char proc_node_name[] = "driver/udc";
+
+static int
+s3c_udc_proc_read(char *page, char **start, off_t off, int count, int *eof, void *_dev)
+{
+	char *buf = page;
+	struct s3c_udc *dev = _dev;
+	char *next = buf;
+	unsigned size = count;
+	unsigned long flags;
+	int t;
+
+	if (off != 0)
+		return 0;
+
+	local_irq_save(flags);
+
+	/* basic device status */
+	t = scnprintf(next, size,
+		      DRIVER_DESC "\n"
+		      "%s version: %s\n"
+		      "Gadget driver: %s\n"
+		      "\n",
+		      driver_name, DRIVER_VERSION,
+		      dev->driver ? dev->driver->driver.name : "(none)");
+	size -= t;
+	next += t;
+
+	local_irq_restore(flags);
+	*eof = 1;
+	return count - size;
+}
+
+#define create_proc_files() \
+	create_proc_read_entry(proc_node_name, 0, NULL, s3c_udc_proc_read, dev)
+#define remove_proc_files() \
+	remove_proc_entry(proc_node_name, NULL)
+
+#else	/* !CONFIG_USB_GADGET_DEBUG_FILES */
+
+#define create_proc_files() do {} while (0)
+#define remove_proc_files() do {} while (0)
+
+#endif	/* CONFIG_USB_GADGET_DEBUG_FILES */
+//---------------------------------------------------------------------------------------
+
+/* 
+ * until it becomes enabled, this UDC should be completely invisible
+ * to any USB host.
+ */
+static int s3c_udc_enable(struct s3c_udc *dev)
+{
+	u32 reg_val;
+	DEBUG_SETUP("%s: %p\n", __func__, dev);
+
+	reg_val = readl(S3C_OTHERS);
+	reg_val |= (1<<16);   // USB_SIG_MASK
+	writel(reg_val, S3C_OTHERS);
+	
+	// 1. Initializes OTG Phy.
+	writel(0x0, S3C_USBOTG_PHYPWR);
+	writel(0x20, S3C_USBOTG_PHYCLK);
+	writel(0x1, S3C_USBOTG_RSTCON);
+	// confirm delay time with thinking pm logic
+	udelay(50);
+	writel(0x0, S3C_USBOTG_RSTCON);
+	udelay(50);
+	
+	dev->udc_state = USB_STATE_POWERED;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+	
+	/* 14. Initialize OTG Link Core. */
+	writel(GAHBCFG_INIT, S3C_UDC_OTG_GAHBCFG);
+	
+	writel( 0<<15		// PHY Low Power Clock sel
+		|1<<14		// Non-Periodic TxFIFO Rewind Enable
+		|0x5<<10	// Turnaround time
+		|0<<9|0<<8	// [0:HNP disable, 1:HNP enable][ 0:SRP disable, 1:SRP enable] H1= 1,1
+		|0<<7		// Ulpi DDR sel
+		|0<<6		// 0: high speed utmi+, 1: full speed serial
+		|0<<4		// 0: utmi+, 1:ulpi
+		|1<<3		// phy i/f	0:8bit, 1:16bit
+		|0x7<<0,	// HS/FS Timeout*
+		S3C_UDC_OTG_GUSBCFG);
+
+	s3c_udc_initialize(dev);
+
+	//change proper register instead of S3C_UDC_OTG_GINTMSK
+	reg_val = readl(S3C_UDC_OTG_GINTMSK);
+	if(!reg_val)
+	{
+		DEBUG_ERROR("[%s] Fail to set GINTMSK 0x%x\n", __func__, reg_val);
+		return -1;
+	}
+	return 0;
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ * 	s3c_udc_disable - disable USB device controller
+ */
+static void s3c_udc_disable(struct s3c_udc *dev)
+{
+	DEBUG_PM("%s: %p\n", __func__, dev);
+
+	s3c_udc_set_address(dev, 0);
+
+	dev->ep0state = WAIT_FOR_SETUP;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+	dev->udc_state = USB_STATE_NOTATTACHED;
+
+	writel(readl(S3C_USBOTG_PHYPWR)|(1<<OTG_DISABLE)|(1<<ANALOG_POWERDOWN), S3C_USBOTG_PHYPWR);
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ * 	s3c_ep_list_reinit - initialize software state
+ */
+static void s3c_ep_list_reinit(struct s3c_udc *dev)
+{
+	u8 i;
+
+	DEBUG_SETUP("%s: %p\n", __func__, dev);
+
+	/* device/ep0 records init */
+	INIT_LIST_HEAD(&dev->gadget.ep_list);
+	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
+	dev->ep0state = WAIT_FOR_SETUP;
+
+	/* basic endpoint records init */
+	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
+		struct s3c_ep *ep = &dev->ep[i];
+
+		if (i != 0)
+			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
+
+		ep->desc = 0;
+		ep->stopped = 0;
+		ep->pio_irqs = 0;
+		INIT_LIST_HEAD(&ep->queue);
+	}
+
+	/* the rest was statically initialized, and is read-only */
+}
+//---------------------------------------------------------------------------------------
+
+
+/*
+ * usb_gadget_register_driver
+ * Register entry point for the peripheral controller driver.
+ */
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	struct s3c_udc *dev = the_controller;
+	int retval;
+
+	DEBUG_SETUP("%s: %s\n", __func__, driver->driver.name);
+#if 1
+/*
+	adb composite fail to !driver->unbind in composite.c as below
+	static struct usb_gadget_driver composite_driver = {
+		.speed		= USB_SPEED_HIGH,
+
+		.bind		= composite_bind,
+		.unbind		= __exit_p(composite_unbind),
+*/
+	if (!driver
+	    || (driver->speed < USB_SPEED_FULL)
+	    || !driver->bind
+	    || !driver->disconnect || !driver->setup)
+		return -EINVAL;		
+#else	
+if (!driver
+	|| (driver->speed != USB_SPEED_FULL && driver->speed != USB_SPEED_HIGH)
+	|| !driver->bind
+	|| !driver->unbind || !driver->disconnect || !driver->setup)
+	return -EINVAL;
+#endif
+	
+	if (!dev)
+		return -ENODEV;
+
+	if (dev->driver)
+		return -EBUSY;
+
+	/* first hook up the driver ... */
+	dev->devstatus = 1 << USB_DEVICE_SELF_POWERED;
+	dev->driver = driver;
+	dev->gadget.dev.driver = &driver->driver;
+	retval = device_add(&dev->gadget.dev);
+
+	if(retval) { /* TODO */
+		DEBUG_ERROR("target device_add failed, error %d\n", retval);
+		return retval;
+	}
+	
+	retval = driver->bind(&dev->gadget);
+	if (retval) {
+		DEBUG_ERROR("%s: bind to driver %s --> error %d\n", dev->gadget.name,
+		       driver->driver.name, retval);
+		device_del(&dev->gadget.dev);
+
+		dev->driver = 0;
+		dev->gadget.dev.driver = 0;
+		return retval;
+	}
+	enable_irq(IRQ_OTG);
+	
+	DEBUG_SETUP("Registered gadget driver '%s'\n", driver->driver.name);
+
+#ifndef CONFIG_PM
+	s3c_udc_enable(dev);
+#endif
+
+/* 	in case of rndis, will be chaned at the time of SET_CONFIGURATION */
+	if (strcmp(driver->driver.name, "g_ether") == 0)
+		dev->config_gadget_driver = ETHER_CDC;	
+	
+	else if (strcmp(driver->driver.name, "android_adb") == 0)
+		dev->config_gadget_driver = ANDROID_ADB;
+	
+	else if (strcmp(driver->driver.name, "android_usb") == 0)
+		dev->config_gadget_driver = ANDROID_ADB_UMS;
+	
+	else if (strcmp(driver->driver.name, "android_adb_ums_acm") == 0)
+		dev->config_gadget_driver = ANDROID_ADB_UMS_ACM;
+	
+	else if (strcmp(driver->driver.name, "g_serial") == 0)
+		dev->config_gadget_driver = SERIAL;
+	
+	else if (strcmp(driver->driver.name, "g_cdc") == 0)
+		dev->config_gadget_driver = CDC2;
+	
+	else if (strcmp(driver->driver.name, "g_file_storage") == 0)
+		dev->config_gadget_driver = FILE_STORAGE;
+
+	else
+		DEBUG_ERROR("Not recognized driver's name '%s'\n", driver->driver.name);
+		
+	return 0;
+}
+
+EXPORT_SYMBOL(usb_gadget_register_driver);
+//---------------------------------------------------------------------------------------
+
+/*
+ * Unregister entry point for the peripheral controller driver.
+ */ 
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct s3c_udc *dev = the_controller;
+	unsigned long flags;
+
+	if (!dev)
+		return -ENODEV;
+	if (!driver || driver != dev->driver)
+		return -EINVAL;
+	
+	disable_irq(IRQ_OTG);
+
+	spin_lock_irqsave(&dev->lock, flags);
+	s3c_udc_stop_activity(dev, driver);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	driver->unbind(&dev->gadget);
+	device_del(&dev->gadget.dev);
+
+	DEBUG_SETUP("Unregistered gadget driver '%s'\n", driver->driver.name);
+
+#ifndef CONFIG_PM
+	s3c_udc_disable(dev);
+#endif	
+	dev->gadget.dev.driver = NULL;
+	dev->driver = NULL;
+	dev->config_gadget_driver = NO_GADGET_DRIVER;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+//---------------------------------------------------------------------------------------
+
+#if defined(CONFIG_USB_GADGET_S3C_OTGD_HS_DMA_MODE) 
+	/* DMA Mode */
+	#include "s3c-udc-otg-hs_dma.c"
+#else 
+	/* Slave Mode */
+	#error Unsupporting slave mode
+#endif
+
+#include "fsa9480_i2c.c"
+//---------------------------------------------------------------------------------------
+
+/*
+ * power up s3c-udc power & enable otg clock
+ */ 
+void s3c_udc_power_up(void)
+{
+	struct s3c_udc *dev = the_controller;
+	if(dev->udc_state == USB_STATE_NOTATTACHED) {		
+		DEBUG_PM("[%s] \n", __func__);
+
+S3C_UDC_POWER_UP:	
+		fsa9480_s3c_udc_on();
+			
+		if(!dev->clocked) {
+			if(clk_enable(otg_clock) != 0) {
+				DEBUG_ERROR("\n[%s] clk_enable(otg_clock) failed.\n", __func__);
+			}
+			else {
+				dev->clocked = 1;
+				DEBUG_PM("\n[%s] clk_enable(otg_clock) OK.\n", __func__);
+			}
+		}
+		else
+			DEBUG_PM("\n[%s] already clk_enabled.\n", __func__);
+		
+		if(s3c_udc_enable(dev) != 0 || !dev->clocked) {
+		/* 	Just in case */
+			DEBUG_ERROR("\n[%s] FAIL TO s3c_udc_enable()\n", __func__);
+			DEBUG_ERROR("\n[%s] Power UP again.\n", __func__);
+			goto S3C_UDC_POWER_UP;
+		}
+		else
+			DEBUG_PM("\n[%s] POWER-UP OK!.\n", __func__);
+	}
+	else {
+		DEBUG_PM("[%s] skipped , already powered up\n", __func__);			
+		
+		if(!readl(S3C_UDC_OTG_GINTMSK) || !dev->clocked) {
+		/* 	Just in case */
+			DEBUG_ERROR("\n[%s] !readl(S3C_UDC_OTG_GINTMSK) || !dev->clocked\n", __func__);
+			DEBUG_ERROR("\n[%s] Power UP again.\n", __func__);
+			goto S3C_UDC_POWER_UP;
+		}
+	}		
+	dev->powered = 1;
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ * power down s3c-udc power & disable otg clock
+ */ 
+void s3c_udc_power_down(void)
+{
+	struct s3c_udc *dev = the_controller;
+
+	/* Confirm 	 */
+	if (dev->udc_state != USB_STATE_SUSPENDED) {
+		//s3c_udc_set_disconnect_state(dev);
+		s3c_udc_stop_activity(dev, dev->driver);
+	}
+	
+	if(dev->udc_state > USB_STATE_NOTATTACHED) {		
+		/* s3c_udc_disable() set dev->udc_state = USB_STATE_NOTATTACHED; */
+		s3c_udc_disable(dev);
+
+S3C_UDC_POWER_OFF:		
+		if(dev->clocked) {
+			if (!IS_ERR(otg_clock) && otg_clock != NULL) {
+				clk_disable(otg_clock);
+				dev->clocked = 0;
+				DEBUG_PM("[%s] clk_disable() OK.\n", __func__);
+			}
+			else
+				DEBUG_ERROR("[%s] otg_clock error\n", __func__);
+		}
+		else 
+			DEBUG_PM("[%s] already clk_disabled\n", __func__);
+		
+		fsa9480_s3c_udc_off();
+
+		if(dev->clocked) {
+			/*	Just in case */
+				DEBUG_ERROR("\n[%s] readl(S3C_UDC_OTG_GINTMSK) || dev->clocked\n", __func__);
+				DEBUG_ERROR("\n[%s] Power OFF again.\n", __func__);
+				goto S3C_UDC_POWER_OFF;
+		}
+		
+		DEBUG_PM("[%s] \n", __func__);
+	}
+	else {		
+		DEBUG_PM("[%s] skipped , already powered off\n", __func__);
+
+		if(dev->clocked) {
+			/*	Just in case */
+			DEBUG_ERROR("\n[%s] readl(S3C_UDC_OTG_GINTMSK) || dev->clocked\n", __func__);
+			DEBUG_ERROR("\n[%s] Power OFF again.\n", __func__);
+			goto S3C_UDC_POWER_OFF;
+		}
+	}
+	dev->powered = 0;
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ * get frame number 
+ */ 
+static int s3c_udc_get_frame(struct usb_gadget *_gadget)
+{
+	/*fram count number [21:8]*/
+	u32 frame = readl(S3C_UDC_OTG_DSTS);
+
+	DEBUG("[%s]: %s\n", __func__, _gadget->name);
+	return (frame & 0x3ff00);
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ * This function is called when the SRP timer expires.	The SRP should
+ * complete within 6 seconds. 
+ */
+static void s3c_udc_srp_timeout(unsigned long _ptr )
+{
+	struct s3c_udc *dev = the_controller;
+	struct timer_list *srp_timer = &dev->srp_timer;
+	u32 usb_otgctl;	
+	
+	DEBUG_SETUP("[%s] SRP Timeout \n", __func__);		
+
+	/*
+		Currently (2009.6.22) OTG not supported
+		Originally GOTGINT.SesReqSucStsChng interrupt handler should read 
+		GOTGCTL.SesReqScs
+		ref. Synopsis Spec. 5.3.2.2 OTG Interrupt Register(GOTGINT)
+	*/
+	usb_otgctl = readl(S3C_UDC_OTG_GOTGCTL);
+	if (usb_otgctl & B_SESSION_VALID &&
+		usb_otgctl & SESSION_REQ_SUCCESS)
+	{
+		DEBUG_SETUP("[%s] SRP Success \n", __func__);		
+		spin_unlock(&dev->lock);
+		dev->driver->resume(&dev->gadget);
+		spin_lock(&dev->lock);
+	
+		del_timer(srp_timer);		
+	}
+	else
+	{
+		DEBUG_SETUP("[%s] Device not connected/responding \n", __func__);		
+	}
+	
+	usb_otgctl &= ~SESSION_REQ;
+	writel(usb_otgctl, S3C_UDC_OTG_GOTGCTL);
+}
+
+/*
+ * usb_gadget_ops wake-up 
+ * This function starts the Protocol if no session is in progress. If
+ * a session is already in progress, but the device is suspended,
+ * remote wakeup signaling is started.
+ */ 
+static int s3c_udc_wakeup(struct usb_gadget *_gadget)
+{
+	struct s3c_udc *dev = the_controller;
+	struct timer_list *srp_timer = &dev->srp_timer;
+	
+	u32 usb_otgctl, usb_dctl, usb_status;	
+	unsigned long flags;
+	int ret = -EINVAL;
+	if (!_gadget)
+	{
+		return -ENODEV;
+	} 
+	DEBUG("[%s]: %s\n", __func__, _gadget->name);
+ 
+	spin_lock_irqsave(&dev->lock, flags);
+	if (!(dev->devstatus & (1 << USB_DEVICE_REMOTE_WAKEUP))) 
+	{
+		DEBUG_ERROR("[%s]Not set USB_DEVICE_REMOTE_WAKEUP \n", __func__);		
+		goto s3c_udc_wakeup_exit;
+	}
+	
+	/* Check if valid session */
+	usb_otgctl = readl(S3C_UDC_OTG_GOTGCTL);
+	if (usb_otgctl & B_SESSION_VALID)
+	{
+		/* Check if suspend state */
+		usb_status = readl(S3C_UDC_OTG_DSTS);
+		if (usb_status & (1<<SUSPEND_STS)) 
+		{
+			//sending remote wake up signaling			
+			DEBUG("[%s]Set Remote Wakeup \n", __func__);		
+			usb_dctl = readl(S3C_UDC_OTG_DCTL);
+			usb_dctl |= REMOTE_WAKEUP_SIG;
+			writel(usb_dctl, S3C_UDC_OTG_DCTL);
+			mdelay(1);
+			
+			DEBUG_SETUP("[%s]Clear Remote Wakeup \n", __func__);		
+			usb_dctl = readl(S3C_UDC_OTG_DCTL);
+			usb_dctl = usb_dctl & ~REMOTE_WAKEUP_SIG;
+			writel(usb_dctl, S3C_UDC_OTG_DCTL);
+		}
+		else
+			DEBUG_SETUP("[%s] Already woked up \n", __func__); 				
+	}
+	else if (usb_otgctl & SESSION_REQ)
+	{
+		DEBUG_SETUP("[%s] Session Request Already active! \n", __func__);		
+		goto s3c_udc_wakeup_exit;	
+	}
+	else
+	{
+		DEBUG_SETUP("[%s] Initiate Session Request  \n", __func__);		
+	//The core clears this bit when the HstNegSucStsChng bit is cleared.
+		usb_otgctl |= SESSION_REQ;
+		writel(usb_otgctl, S3C_UDC_OTG_GOTGCTL);
+		
+		/* Start the SRP timer */
+		init_timer(srp_timer);
+		srp_timer->function = (void*)s3c_udc_srp_timeout;
+		srp_timer->expires = jiffies + (HZ*6);
+		add_timer(srp_timer);
+	}
+	ret = 0;
+
+s3c_udc_wakeup_exit:	
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return ret;
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ * usb_gadget_ops pullup
+ */ 
+static int s3c_udc_pullup(struct usb_gadget *gadget, int is_on)
+{
+#if 0
+	//logical 
+	if (is_on)
+	{
+		s3c_udc_soft_connect();
+	}
+	else
+	{
+		s3c_udc_soft_disconnect();
+	}
+#else
+	struct s3c_udc *dev = the_controller;
+	unsigned long flags;
+
+	//UDC power on/off
+	if (is_on)
+	{
+	/*
+	 * if early s3c_udc_power_up make 
+	 * fsa9480_check_usb_connection failed to detect USB connection
+	 */ 
+	//	s3c_udc_power_up();
+
+		fsa9480_check_usb_connection();
+	}
+	else
+	{
+		/*
+		 * Any transactions on the AHB Master are terminated. 
+		 * And all the transmit FIFOs are flushed.
+		 */
+		writel(CORE_SOFT_RESET, S3C_UDC_OTG_GRSTCTL);
+		udelay(10);
+		if (!(readl(S3C_UDC_OTG_GRSTCTL) & AHB_MASTER_IDLE))
+			printk("OTG Core Reset is not done.\n");
+	
+		spin_lock_irqsave(&dev->lock, flags);
+		s3c_udc_stop_activity(dev, dev->driver);
+		s3c_udc_power_down();
+		spin_unlock_irqrestore(&dev->lock, flags);
+	}
+#endif
+	return 0;
+}
+//---------------------------------------------------------------------------------------
+
+static int s3c_udc_set_selfpowered(struct usb_gadget *gadget, int is_selfpowered)
+{
+	struct s3c_udc *dev = the_controller;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (is_selfpowered)
+		dev->devstatus |= 1 << USB_DEVICE_SELF_POWERED;
+	else
+		dev->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+/**
+ * struct usb_gadget_ops s3c_udc_ops
+ * 
+ */
+static const struct usb_gadget_ops s3c_udc_ops = {
+	.get_frame = s3c_udc_get_frame,
+	.wakeup = s3c_udc_wakeup,
+	.set_selfpowered = s3c_udc_set_selfpowered,
+	.pullup = s3c_udc_pullup,
+};
+//---------------------------------------------------------------------------------------
+
+/*
+ * dev release
+ */ 
+static void nop_release(struct device *dev)
+{
+	DEBUG("%s %s\n", __func__, dev->bus_id);
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * struct s3c_udc memory
+ * 
+ */
+static struct s3c_udc memory = {
+	.usb_address = 0,
+
+	.gadget = {
+		   .ops = &s3c_udc_ops,
+		   .ep0 = &memory.ep[0].ep,
+		   .name = driver_name,
+		   .dev = {
+			   //.bus_id = "gadget",	for 2.6.27
+		   	   .init_name = "gadget",
+	   /*
+		* release function releases the Gadget device.
+		* required by device_unregister().
+		* currently no need
+		*/
+			   .release = nop_release,
+			   },
+		   },
+	/*
+	 * usb_ep.maxpacket will be refered by ep_matches() 
+	 * of epautoconf.c
+	 */
+	
+	/* control endpoint */
+	.ep[0] = {
+		  .ep = {
+			 .name = ep0name,
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP0_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = 0,
+		  .bmAttributes = USB_ENDPOINT_XFER_CONTROL,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP0_FIFO,
+		  },
+
+	/* first group of endpoints */
+	.ep[1] = {
+		  .ep = {
+			 .name = "ep1-bulk",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = BULK_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = 1,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP1_FIFO,
+		  },
+
+	.ep[2] = {
+		  .ep = {
+			 .name = "ep2-bulk",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = BULK_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 2,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP2_FIFO,
+		  },
+
+	.ep[3] = {				// Though NOT USED XXX
+		  .ep = {
+			 .name = "ep3-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = INT_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 3,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP3_FIFO,
+		  },
+		  
+	.ep[4] = {
+		  .ep = {
+			 .name = "ep4-bulk",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = BULK_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = 4,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP4_FIFO,
+		  },
+
+	.ep[5] = {
+		  .ep = {
+			 .name = "ep5-bulk",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = BULK_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 5,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP5_FIFO,
+		  },
+
+	.ep[6] = {				 
+		  .ep = {
+			 .name = "ep6-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = INT_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 6,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP6_FIFO,
+		  },
+		  
+	.ep[7] = {				 
+		  .ep = {
+			 .name = "ep7-bulk",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = BULK_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = 7,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP7_FIFO,
+		  },
+		  
+	.ep[8] = {				 
+		  .ep = {
+			 .name = "ep8-bulk",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = BULK_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 8,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP8_FIFO,
+		  },
+		  
+	.ep[9] = {				 
+		  .ep = {
+			 .name = "ep9-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = INT_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 8,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP8_FIFO,
+		  },
+//following eps are not used		  
+	.ep[10] = {				// Though NOT USED XXX
+		  .ep = {
+			 .name = "ep10-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = INT_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 8,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP8_FIFO,
+		  },
+	.ep[11] = {				// Though NOT USED XXX
+		  .ep = {
+			 .name = "ep11-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = INT_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 8,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP8_FIFO,
+		  },
+	.ep[12] = {				// Though NOT USED XXX
+		  .ep = {
+			 .name = "ep12-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = INT_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 8,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP8_FIFO,
+		  },
+	.ep[13] = {				// Though NOT USED XXX
+		  .ep = {
+			 .name = "ep13-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = INT_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 8,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP8_FIFO,
+		  },
+	.ep[14] = {				// Though NOT USED XXX
+		  .ep = {
+			 .name = "ep14-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = INT_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 8,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP8_FIFO,
+		  },
+	.ep[15] = {				// Though NOT USED XXX
+		  .ep = {
+			 .name = "ep15-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = INT_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 8,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .fifo = (unsigned int) S3C_UDC_OTG_EP8_FIFO,
+		  },
+};
+//---------------------------------------------------------------------------------------
+
+/*
+ * 	probe - binds to the platform device
+ */
+static int s3c_udc_probe(struct platform_device *pdev)
+{
+	struct s3c_udc *dev = &memory;
+	int retval;
+
+	DEBUG("%s: %p\n", __func__, pdev);
+
+	retval = i2c_add_driver(&fsa9480_i2c_driver);
+	if (retval != 0)
+		DEBUG_ERROR("[USB Switch] can't add i2c driver");
+
+	spin_lock_init(&dev->lock);
+	dev->dev = pdev;
+
+	device_initialize(&dev->gadget.dev);
+	dev->gadget.dev.parent = &pdev->dev;
+
+	dev->gadget.is_dualspeed = 1;	// Hack only
+	dev->gadget.is_otg = 0;
+	dev->gadget.is_a_peripheral = 0;
+	dev->gadget.b_hnp_enable = 0;
+	dev->gadget.a_hnp_support = 0;
+	dev->gadget.a_alt_hnp_support = 0;
+	dev->udc_state = USB_STATE_NOTATTACHED;
+	dev->config_gadget_driver = NO_GADGET_DRIVER;
+	dev->clocked = 0;
+	dev->powered = 0;
+	
+	the_controller = dev;
+	platform_set_drvdata(pdev, dev);
+
+	otg_clock = clk_get(&pdev->dev, "otg");
+
+	if (IS_ERR(otg_clock)) {
+		DEBUG_ERROR(KERN_INFO "failed to find otg clock source\n");
+		return -ENOENT;
+	}
+
+#ifndef CONFIG_PM
+	clk_enable(otg_clock);
+#endif
+
+	s3c_ep_list_reinit(dev);
+
+	local_irq_disable();
+
+	/* irq setup after old hardware state is cleaned up */
+	retval =  request_irq(IRQ_OTG, s3c_udc_irq, 0, driver_name, dev);
+
+	if (retval != 0) {
+		DEBUG(KERN_ERR "%s: can't get irq %i, err %d\n", driver_name,
+		      IRQ_OTG, retval);
+		return -EBUSY;
+	}
+
+	disable_irq(IRQ_OTG);
+	local_irq_enable();
+	create_proc_files();
+
+	//it just prints which file included regarding whether DMA mode or SLAVE mode
+	s3c_show_mode();
+
+	
+#if TESTING_SOFT_CONNCTION
+	soft_switch.name = SOFT_SWITCH_NAME;
+	soft_switch.print_name = soft_switch_name;
+	soft_switch.print_state = soft_switch_state;
+	soft_switch.state = 0;
+	if (switch_dev_register(&soft_switch) < 0)
+		switch_dev_unregister(&soft_switch);
+#endif
+
+	return retval;
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ * 	remove - unbinds to the platform device
+ */
+static int s3c_udc_remove(struct platform_device *pdev)
+{
+	struct s3c_udc *dev = platform_get_drvdata(pdev);
+
+	DEBUG("%s: %p\n", __func__, pdev);
+
+	if (otg_clock != NULL) {
+		clk_disable(otg_clock);
+		clk_put(otg_clock);
+		otg_clock = NULL;
+	}
+
+	remove_proc_files();
+	usb_gadget_unregister_driver(dev->driver);
+
+	free_irq(IRQ_OTG, dev);
+
+	platform_set_drvdata(pdev, 0);
+
+	the_controller = 0;
+
+	return 0;
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ * 	AHB clock gating for suspend
+ */
+int s3c_udc_suspend_clock_gating(void)
+{
+	u32	uReg;
+	DEBUG_PM("[%s]\n", __func__);
+	uReg = readl(S3C_UDC_OTG_PCGCCTL);
+
+	writel(uReg|1<<STOP_PCLK_BIT|1<<GATE_HCLK_BIT, S3C_UDC_OTG_PCGCCTL); 
+	DEBUG_PM("[%s] : S3C_UDC_OTG_PCGCCTL 0x%x \n", __func__, uReg);	
+	return 0;
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ * 	AHB clock gating for resume
+ */
+int s3c_udc_resume_clock_gating(void)
+{
+	u32	uReg;
+	DEBUG_PM("[%s]\n", __func__);
+	
+	uReg = readl(S3C_UDC_OTG_PCGCCTL);
+	uReg &= ~(1<<STOP_PCLK_BIT|1<<GATE_HCLK_BIT);
+	writel(uReg, S3C_UDC_OTG_PCGCCTL); 
+	DEBUG_PM("[%s] : S3C_UDC_OTG_PCGCCTL 0x%x \n", __func__, uReg);	
+	return 0;
+}
+//---------------------------------------------------------------------------------------
+
+#ifdef CONFIG_PM
+
+/*
+ *	Synopsys OTG PM supports Partial Power-Down and AHB Clock Gating.
+ *	OTG PM just turns on or off OTG PHYPWR 
+ *	because S3C6410 can only use the clock gating method.		 
+ */
+enum OTG_PM
+{
+	ALL_POWER_DOWN,    		//turn off OTG module
+
+	//the followings are not tested yet
+	CLOCK_GATING,			//using AHB clock gating,
+	OPHYPWR_FORCE_SUSPEND,	//using OPHYPWR.force_suspend
+}; 
+//---------------------------------------------------------------------------------------
+
+//specifying pm_policy
+static enum	OTG_PM pm_policy = ALL_POWER_DOWN;
+
+static int s3c_udc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct s3c_udc *dev = platform_get_drvdata(pdev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	DEBUG_PM("[%s]: System Suspend \n", __func__);
+
+	//save the state of connection to udc_resume_state
+	dev->udc_resume_state = dev->udc_state;
+	dev->udc_resume_speed = dev->gadget.speed;
+
+	if (dev->gadget.speed != USB_SPEED_UNKNOWN) {
+		DEBUG_PM("[%s]: USB enumerated at suspend\n", __func__);
+		//s3c_udc_soft_disconnect();		
+		s3c_udc_stop_activity(dev, dev->driver);
+	}
+	else {
+		DEBUG_PM("[%s] USB not enumerated at suspend\n", __func__);
+		DEBUG_PM("[%s] dev->powered [%d] at suspend\n", __func__, dev->powered);
+		if (dev->powered == 0) {
+			DEBUG_PM("[%s] skip~~ s3c_udc_power_down() at suspend\n", __func__);
+			spin_unlock_irqrestore(&dev->lock, flags);
+		return 0;
+	}
+	}
+
+	switch(pm_policy)
+	{
+		case ALL_POWER_DOWN:			
+//			s3c_udc_stop_activity(dev, dev->driver);
+			//confirm clk disable
+			s3c_udc_power_down();
+			break;
+		case CLOCK_GATING: 		
+			s3c_udc_suspend_clock_gating();
+			break;
+		case OPHYPWR_FORCE_SUSPEND:			
+			writel((readl(S3C_USBOTG_PHYPWR)|(1<<FORCE_SUSPEND)), S3C_USBOTG_PHYPWR);
+			break;
+		default:
+			DEBUG_ERROR("[%s]: not proper pm_policy\n", __func__);
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return 0;
+}
+//---------------------------------------------------------------------------------------
+
+static int s3c_udc_resume(struct platform_device *pdev)
+{
+#if 1
+	//first check status of connection
+	DEBUG_PM("[%s]: fsa9480_check_usb_connection\n", __func__);
+	fsa9480_check_usb_connection();
+	return 0;
+
+#else
+//	chekc udc_resume_speed & udc_resume_state
+	struct s3c_udc *dev = platform_get_drvdata(pdev);
+	u32 tmp;
+	
+	DEBUG_PM("[%s]: System Resume \n", __func__);
+	//if not suspended as connected
+	if (dev->udc_resume_state == USB_STATE_CONFIGURED)
+	{
+		DEBUG_PM("[%s]: USB connected before suspend \n", __func__);
+	}
+	else
+	{	
+		DEBUG_PM("[%s]: USB not connected before suspend\n", __func__);
+		return 0;
+	}
+	
+	switch(pm_policy)
+	{
+		case ALL_POWER_DOWN:			
+			s3c_udc_power_up();
+			break;
+		case CLOCK_GATING:		
+			s3c_udc_resume_clock_gating();
+			break;
+		case OPHYPWR_FORCE_SUSPEND: 		
+			tmp = readl(S3C_USBOTG_PHYPWR);
+			tmp &= ~(1<<FORCE_SUSPEND);
+			writel(tmp, S3C_USBOTG_PHYPWR);
+			break;
+		default:
+			DEBUG_ERROR("[%s]: not proper pm_policy\n", __func__);
+	}
+	return 0;
+#endif
+}
+
+#endif /* CONFIG_PM */
+
+/**
+ * struct platform_driver s3c_udc_driver
+ */
+static struct platform_driver s3c_udc_driver = {
+	.probe		= s3c_udc_probe,
+	.remove 	= s3c_udc_remove,
+	.driver 	= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c6410-usbgadget",
+	},
+#ifdef CONFIG_PM
+	.suspend	= s3c_udc_suspend,
+	.resume 	= s3c_udc_resume,
+#endif /* CONFIG_PM */
+};
+//---------------------------------------------------------------------------------------
+
+static int __init s3c_udc_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&s3c_udc_driver);
+
+	return ret;
+}
+//---------------------------------------------------------------------------------------
+
+static void __exit s3c_udc_exit(void)
+{
+	platform_driver_unregister(&s3c_udc_driver);
+	DEBUG("Unloaded %s version %s\n", driver_name, DRIVER_VERSION);
+}
+//---------------------------------------------------------------------------------------
+
+module_init(s3c_udc_init);
+module_exit(s3c_udc_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("SeungSoo Yange");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
diff -Nur linux-2.6.29/drivers/usb/gadget/s3c-udc-otg-hs_dma.c linux-2.6.29-spica/drivers/usb/gadget/s3c-udc-otg-hs_dma.c
--- linux-2.6.29/drivers/usb/gadget/s3c-udc-otg-hs_dma.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/s3c-udc-otg-hs_dma.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,2569 @@
+/*
+ * drivers/usb/gadget/s3c-udc-otg-hs_dma.c
+ * Samsung S3C on-chip full/high speed USB OTG 2.0 device controller dma mode
+ *
+ * Copyright (C) 2009 Samsung Electronics, Seung-Soo Yang
+ * Copyright (C) 2008 Samsung Electronics, Kyu-Hyeok Jang, Seung-Soo Yang
+ * Copyright (C) 2004 Mikko Lahteenmaki, Nordic ID
+ * Copyright (C) 2004 Bo Henriksen, Nordic ID
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+ * IN Endpoints' next ep setting in case of DMA mode, 
+ *
+ * default:
+ *	EP0 => EP0 if no queue request, or EP list queued
+ *	EP2 => EP3, 	EP3 => EP0
+ *	EP5 => EP6, 	EP6 => EP0
+ *	EP8 => EP9, 	EP9 => EP0
+ *
+ * ADB_UMS_ACM || ADB_UMS:
+ *	EP2 => EP0 in s3c_udc_initialize, add EP0 => EP2 in s3c_udc_set_dma_tx
+	 *  							  add EP0 => EP3 in s3c_udc_set_dma_tx
+ *	EP5 => EP0 in s3c_udc_initialize, add EP0 => EP5 in s3c_udc_set_dma_tx
+ *	EP8 => EP0 in s3c_udc_initialize, add EP0 => EP8 in s3c_udc_set_dma_tx
+ *
+ *	UMS uses EP1(bulk-out), EP2(bulk-in)
+ *	ADB uses EP4(bulk-out), EP5(bulk-in)
+ *	ACM uses EP3(int-in), EP7(bulk-out), EP8(bulk-in)
+ *
+ * CDC:
+ *	EP2 => EP0 in s3c_udc_initialize, add EP0 => EP2 in s3c_udc_set_dma_tx
+ *
+ * RNDIS:
+ *  							 add EP0 => EP3 in s3c_udc_set_dma_tx
+ *
+ **/
+
+#if SERIAL_TRANSFER_DELAY
+#define SERIAL_DELAY_uTIME		800
+#endif
+
+//extern void s3c_udc_soft_connect(void);
+//extern void s3c_udc_soft_disconnect(void);
+#ifdef CONFIG_USB_FILE_STORAGE
+extern int MSC_INVALID_CBW_IGNORE_CLEAR_HALT(void);
+#endif
+static u8 clear_feature_num;
+static int clear_feature_flag = 0;
+static int zero_config_flag = 0;
+
+/**
+ * diepctl_next_ep
+ * next ep linked list
+ */
+struct diepctl_next_ep
+{
+	u8 ep_num;
+	struct list_head list;
+};
+
+static struct diepctl_next_ep ep0_nextep_list;
+
+//---------------------------------------------------------------------------------------
+
+void s3c_show_mode(void)
+{
+	DEBUG("[S3C USB-OTG MODE] : DMA\n");
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_ep_set_next_ep
+ * set ep_num's DIEPCTLn.nextep 4 bits next_ep for EP_IN
+ */
+static void s3c_ep_set_next_ep(u8 ep_num, u8 next_ep)
+{
+	u32 ctrl;
+
+	ctrl = readl(S3C_UDC_OTG_DIEPCTL(ep_num));
+	/* DIEPCTLn.nextep 4bits */
+	ctrl &= ~(0xf<<DIEPCTL_NEXT_EP_BIT);	
+	writel(next_ep<<DIEPCTL_NEXT_EP_BIT |ctrl, S3C_UDC_OTG_DIEPCTL(ep_num));
+	
+	DEBUG_IN_EP("[%s] : set EP[%d].nextep => EP[%d]\n", __func__, ep_num, next_ep);
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_ep0_get_next_ep
+ * get a EP0's nextep linked list entry
+ */
+static u8 s3c_ep0_get_next_ep(void)
+{
+	u8	ep_num = 0;
+	struct diepctl_next_ep *tmp_next_ep;
+
+	if (!list_empty(&ep0_nextep_list.list))
+	{		
+		tmp_next_ep = list_entry(ep0_nextep_list.list.next, struct diepctl_next_ep, list);
+		ep_num = tmp_next_ep->ep_num;
+	}
+	return ep_num;
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_ep0_add_next_ep
+ * add ep_num into EP0's nextep linked list 
+ */
+static void s3c_ep0_add_next_ep(u8 ep_num)
+{
+	u32 ctrl;
+	u8 ep0_nextep;
+
+	struct diepctl_next_ep *tmp_next_ep;
+	
+	ctrl = readl(S3C_UDC_OTG_DIEPCTL(EP0_CON));
+	ep0_nextep = 0xf & (ctrl>>DIEPCTL_NEXT_EP_BIT);	
+
+	if (list_empty(&ep0_nextep_list.list))
+	{		
+		s3c_ep_set_next_ep(EP0_CON, ep_num);
+	}
+
+	tmp_next_ep = kmalloc(sizeof *tmp_next_ep, GFP_ATOMIC);
+	if (!tmp_next_ep)
+	{
+		DEBUG_ERROR("[%s] kmalloc failed \n", __func__);
+	}
+	else 
+	{
+		/* error check code added.
+		 * avoid Prevent bug check */
+		tmp_next_ep->ep_num = ep_num;
+		
+		list_add_tail(&(tmp_next_ep->list), &(ep0_nextep_list.list));
+		DEBUG_IN_EP("[%s] : list_add_tail EP [%d]\n", __func__, ep_num);
+	}
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_ep0_del_next_ep
+ * delete the 1st EP0's nextep linked list entry
+ */
+static void s3c_ep0_del_next_ep(u8 ep_num)
+{
+	struct diepctl_next_ep *tmp_next_ep;
+
+	if (list_empty(&ep0_nextep_list.list))
+	{
+		DEBUG_IN_EP("[%s] : list_empty\n", __func__);
+		return;
+	}
+	
+	tmp_next_ep = list_entry(ep0_nextep_list.list.next, struct diepctl_next_ep, list);
+
+	if(tmp_next_ep->ep_num == ep_num)
+	{
+		list_del(&tmp_next_ep->list);
+		kfree(tmp_next_ep);
+		DEBUG_IN_EP("[%s] : list_del & kfree EP0->next.ep[%d]\n", __func__, ep_num);
+	}
+	else 
+	{				
+		DEBUG_IN_EP("[%s] : ep0_nextep_list->ep_num[%d] != ep_num[%d]\n"
+			, __func__, tmp_next_ep->ep_num, ep_num);
+	}
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_ep0_next_ep_del_one_ep_list_
+ * delete all EP0's nextep linked list entry has ep_num
+ */
+static void s3c_ep0_next_ep_del_one_ep_list_(u8 ep_num)
+{
+	struct diepctl_next_ep *tmp_next_ep;
+	struct list_head	*pos, *tmp;
+
+	if (!list_empty(&ep0_nextep_list.list))
+	{		
+		list_for_each_safe(pos, tmp, &ep0_nextep_list.list) 
+		{
+			tmp_next_ep = list_entry(pos, struct diepctl_next_ep, list);
+			if (tmp_next_ep->ep_num == ep_num)
+			{				
+				list_del(&tmp_next_ep->list);
+				kfree(tmp_next_ep);
+			}
+		}
+	}
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_ep0_pre_setup
+ * setup for receiving data stage of CONTROL SETUP transaction
+ */
+static inline void s3c_ep0_pre_setup(void)
+{
+	u32 ep_ctrl, length;
+
+	DEBUG_SETUP("%s : Prepare Setup packets.\n", __func__);
+	length = sizeof(struct usb_ctrlrequest);
+
+	/*	
+	 *	w/o prefetchw & dma_cache_maint
+	 *	there should be a timing promblem at acm connection 
+	 *	refer [s3c_ep0_setup] CHANGE g_ctrl.wIndex = 0x82 => 0
+	 */
+	prefetchw(&g_ctrl);
+	dma_cache_maint(&g_ctrl, length, DMA_FROM_DEVICE);
+
+	writel((1 << DEPTSIZ_PKT_CNT_BIT)|length, S3C_UDC_OTG_DOEPTSIZ(EP0_CON));	
+	writel(virt_to_phys(&g_ctrl), S3C_UDC_OTG_DOEPDMA(EP0_CON));
+
+	ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL(EP0_CON));
+	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL(EP0_CON));
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_ep_send_zlp
+ * Send Zero Length Packet for ep_num
+ */
+static inline void s3c_ep_send_zlp(u32 ep_num)
+{
+	struct s3c_udc *dev = the_controller;
+	u32 ctrl;
+	
+    if (ep_num == EP0_CON) {
+        dev->ep0state = WAIT_FOR_SETUP;
+        s3c_ep0_pre_setup();
+    }
+
+	ctrl = readl(S3C_UDC_OTG_DIEPCTL(ep_num));
+
+	writel((1<<DEPTSIZ_PKT_CNT_BIT)|(0<<DEPTSIZ_XFER_SIZE_BIT), S3C_UDC_OTG_DIEPTSIZ(ep_num));
+	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl , S3C_UDC_OTG_DIEPCTL(ep_num));
+
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_udc_set_dma_rx
+ * set rx dma to receive a request 
+ */
+static int s3c_udc_set_dma_rx(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 *buf, ctrl;
+	u32 length, pktcnt;
+	u32 ep_num = ep_index(ep);
+	
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+
+	length = req->req.length - req->req.actual;
+	dma_cache_maint(buf, length, DMA_FROM_DEVICE);
+
+	if(length == 0)
+		pktcnt = 1;
+	else
+		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;
+
+	switch(ep_num)
+	{
+		case EP0_CON: 
+		case EP1_OUT: 
+		case EP4_OUT: 			
+		case EP7_OUT: 			
+			ctrl =  readl(S3C_UDC_OTG_DOEPCTL(ep_num));
+			
+			writel(virt_to_phys(buf), S3C_UDC_OTG_DOEPDMA(ep_num));
+			writel((pktcnt<<DEPTSIZ_PKT_CNT_BIT)|(length<<DEPTSIZ_XFER_SIZE_BIT), S3C_UDC_OTG_DOEPTSIZ(ep_num));
+			writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, S3C_UDC_OTG_DOEPCTL(ep_num));
+			
+			DEBUG_OUT_EP("[%s] RX DMA start : DOEPDMA[%d] = 0x%x, DOEPTSIZ[%d] = 0x%x, DOEPCTL[%d] = 0x%x,\
+				pktcnt = %d, xfersize = %d\n", __func__, \
+				    ep_num, readl(S3C_UDC_OTG_DOEPDMA(ep_num)), 
+				    ep_num, readl(S3C_UDC_OTG_DOEPTSIZ(ep_num)), 
+				    ep_num, readl(S3C_UDC_OTG_DOEPCTL(ep_num)), 
+					pktcnt, length);
+			break;
+		default:
+			DEBUG_ERROR("[%s]: Error Unused EP[%d]\n", __func__, ep_num);
+	}
+
+	return 0;
+
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_udc_set_dma_tx
+ * set tx dma to transmit a request 
+ */
+static int s3c_udc_set_dma_tx(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 *buf, ctrl;
+	u32 length, pktcnt;
+	u32 ep_num = ep_index(ep); 
+		
+	buf = req->req.buf + req->req.actual;
+	prefetch(buf);
+	length = req->req.length - req->req.actual;
+	
+	if(ep_num == EP0_CON) 
+		length = min(length, (u32)ep_maxpacket(ep));
+	req->req.actual += length;
+	dma_cache_maint(buf, length, DMA_TO_DEVICE);
+
+	if(length == 0)
+		pktcnt = 1;
+	else
+		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;
+
+	DEBUG_IN_EP("==[%s]: EP [%d]\n", __func__, ep_num);		
+
+	switch(ep_num)
+	{
+		case EP0_CON:
+			s3c_ep_set_next_ep(EP0_CON, s3c_ep0_get_next_ep());
+		case EP2_IN:
+		case EP3_IN:
+		case EP5_IN:
+		case EP6_IN:			
+		case EP8_IN:
+		case EP9_IN:			
+			ctrl = readl(S3C_UDC_OTG_DIEPCTL(ep_num));
+			
+			writel((pktcnt<<DEPTSIZ_PKT_CNT_BIT)|(length<<DEPTSIZ_XFER_SIZE_BIT), S3C_UDC_OTG_DIEPTSIZ(ep_num));
+			writel(virt_to_phys(buf), S3C_UDC_OTG_DIEPDMA(ep_num)); 	
+			writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl , S3C_UDC_OTG_DIEPCTL(ep_num));
+			
+			DEBUG_IN_EP("[%s] :TX DMA start : DIEPDMA[%d] = 0x%x, DIEPTSIZ[%d] = 0x%x, DIEPCTL[%d] = 0x%x,"
+					 "pktcnt = %d, xfersize = %d\n", __func__, 
+					ep_num, readl(S3C_UDC_OTG_DIEPDMA(ep_num)),
+					ep_num, readl(S3C_UDC_OTG_DIEPTSIZ(ep_num)),
+					ep_num, readl(S3C_UDC_OTG_DIEPCTL(ep_num)),
+					pktcnt, length);
+			switch(ep_num)
+			{
+				case EP2_IN:
+				case EP5_IN:
+				case EP8_IN:
+					s3c_ep0_add_next_ep(ep_num);
+					break;
+				case EP3_IN:
+					if (ep->dev->config_gadget_driver == ETHER_RNDIS ||
+						ep->dev->config_gadget_driver == ANDROID_ADB_UMS_ACM)
+						s3c_ep0_add_next_ep(ep_num);
+					break;
+			}
+			break;
+		default:
+			DEBUG_ERROR("[%s]: Error Unused EP[%d]\n", __func__, ep_num);
+	}
+	return length;
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * handle_rx_complete
+ * handle of completing rx 
+ */
+static void handle_rx_complete(struct s3c_udc *dev, u32 ep_num)
+{
+	struct s3c_ep *ep = &dev->ep[ep_num];
+	struct s3c_request *req = NULL;
+	u32 csr = 0, count_bytes=0, xfer_length, is_short = 0;
+	DEBUG_OUT_EP("%s EP [%d]\n",__func__, ep_num);
+
+	if (list_empty(&ep->queue)) 
+	{
+		DEBUG_OUT_EP("[%s] NULL REQ on OUT EP-%d\n", __func__, ep_num);
+		return;
+	}
+	req = list_entry(ep->queue.next, struct s3c_request, queue);
+
+	csr = readl(S3C_UDC_OTG_DOEPTSIZ(ep_num));
+	switch(ep_num)
+	{
+		case EP0_CON: 
+			count_bytes = (csr & 0x7f);
+			break;
+		case EP1_OUT: 
+		case EP4_OUT: 			
+		case EP7_OUT: 			
+			count_bytes = (csr & 0x7fff);
+			break;
+		default:
+			DEBUG_ERROR("[%s]: Error Unused EP[%d]\n", __func__, ep_num);
+	}
+
+	xfer_length = req->req.length-count_bytes;
+	req->req.actual += min(xfer_length, req->req.length-req->req.actual);
+	is_short = (xfer_length < ep->ep.maxpacket);
+
+	DEBUG_OUT_EP("[%s] RX DMA done : %d/%d bytes received%s, DOEPTSIZ = 0x%x, %d bytes remained\n",
+			__func__, req->req.actual, req->req.length,
+			is_short ? "/S" : "", csr, count_bytes);
+	DEBUG_OUT_EP("%s : req->length = %d / req->actual = %d / xfer_length = %d / ep.maxpacket = %d / is_short = %d \n",
+			__func__, req->req.length,req->req.actual,
+			xfer_length,ep->ep.maxpacket, is_short);
+
+	if (is_short || req->req.actual == xfer_length) 
+	{
+		if(ep_num == EP0_CON && dev->ep0state == DATA_STATE_RECV)
+		{
+			dev->ep0state = WAIT_FOR_SETUP;
+			s3c_ep_send_zlp(EP0_CON);	
+		}
+		else
+		{
+			s3c_req_done(ep, req, 0);
+
+			if(!list_empty(&ep->queue)) 
+			{
+				req = list_entry(ep->queue.next, struct s3c_request, queue);
+				DEBUG_OUT_EP("[%s] Next Rx request start...\n", __func__);
+				s3c_udc_set_dma_rx(ep, req);
+			}
+		}
+	}
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * handle_tx_complete
+ * handle of completing tx 
+ */
+static void handle_tx_complete(struct s3c_udc *dev, u32 ep_num)
+{
+	struct s3c_ep *ep = &dev->ep[ep_num];
+	struct s3c_request *req;
+	u32 count_bytes = 0;
+
+	if (list_empty(&ep->queue)) 
+	{
+		DEBUG_IN_EP("[%s] : NULL REQ on IN EP-%d\n", __func__, ep_num);
+		return;
+	}
+
+	req = list_entry(ep->queue.next, struct s3c_request, queue);
+
+	if(ep_num == EP0_CON && dev->ep0state == DATA_STATE_XMIT)
+	{
+		u32 last = s3c_ep0_write_fifo(ep, req);
+		if(last)
+		{
+			dev->ep0state = WAIT_FOR_SETUP;
+		}
+		return;
+	}
+
+	switch(ep_num)
+	{
+		case EP0_CON:
+			count_bytes = (readl(S3C_UDC_OTG_DIEPTSIZ(ep_num))) & 0x7f;
+			req->req.actual = req->req.length-count_bytes;
+			DEBUG_IN_EP("[%s] : TX DMA done : %d/%d bytes sent, DIEPTSIZ0 = 0x%x\n",
+					__func__, req->req.actual, req->req.length,
+					readl(S3C_UDC_OTG_DIEPTSIZ(ep_num)));
+			break;
+		case EP2_IN:
+		case EP3_IN:
+		case EP5_IN:
+		case EP6_IN:						
+		case EP8_IN:
+		case EP9_IN:						
+			count_bytes = (readl(S3C_UDC_OTG_DIEPTSIZ(ep_num))) & 0x7fff;
+			req->req.actual = req->req.length-count_bytes;
+			DEBUG_IN_EP("[%s] : TX DMA done : %d/%d bytes sent, DIEPTSIZ[%d] = 0x%x\n",
+					__func__, req->req.actual, req->req.length,
+					ep_num, readl(S3C_UDC_OTG_DIEPTSIZ(ep_num)));
+			break;
+		default:
+			DEBUG_ERROR("[%s]: Error Unused EP[%d]\n", __func__, ep_num);
+	}
+
+	if (req->req.actual == req->req.length) 
+	{
+#if S3C_UDC_ZLP	
+		if (req->zlp == true)
+		{			
+			DEBUG("[%s] S3C_UDC_ZLP req->req.actual == req->req.length\n", __func__);
+			s3c_ep_send_zlp(ep_num);
+			req->zlp = false;
+			req->req.zero = false;
+		}
+#endif		
+		s3c_req_done(ep, req, 0);
+
+		if(!list_empty(&ep->queue)) 
+		{
+			req = list_entry(ep->queue.next, struct s3c_request, queue);
+			DEBUG_IN_EP("[%s] : Next Tx request start...\n", __func__);
+			s3c_udc_set_dma_tx(ep, req);
+		}
+	}
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ *	s3c_req_done - retire a request; caller blocked irqs
+ */
+static void s3c_req_done(struct s3c_ep *ep, struct s3c_request *req, int status)
+{
+	u32 stopped = ep->stopped;
+	u8 	ep_num = ep_index(ep);
+
+	DEBUG("[%s] %s %p, req = %p, stopped = %d\n",__func__, ep->ep.name, ep, &req->req, stopped);
+	list_del_init(&req->queue);
+
+	if (likely(req->req.status == -EINPROGRESS))
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	if (status && status != -ESHUTDOWN)
+	{
+		DEBUG("complete %s req %p stat %d len %u/%u\n",
+			ep->ep.name, &req->req, status,
+			req->req.actual, req->req.length);
+	}
+
+	/* don't modify queue heads during completion callback */
+	ep->stopped = 1;
+
+	spin_unlock(&ep->dev->lock);
+	req->req.complete(&ep->ep, &req->req);
+	spin_lock(&ep->dev->lock);
+	
+	ep->stopped = stopped;
+
+	if(ep_num != s3c_ep0_get_next_ep())
+		return;
+
+	s3c_ep0_del_next_ep(ep_num);
+	s3c_ep_set_next_ep(EP0_CON, s3c_ep0_get_next_ep());
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ * 	s3c_ep_nuke - dequeue ALL requests
+ */
+void s3c_ep_nuke(struct s3c_ep *ep, int status)
+{
+	struct s3c_request *req;
+
+	DEBUG("[%s] %s %p\n", __func__, ep->ep.name, ep);
+
+	/* called with irqs blocked */
+	while (!list_empty(&ep->queue)) 
+	{
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+		s3c_req_done(ep, req, status);
+	}
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_udc_set_disconnect_state
+ * make s3c-udc logically being disconnected
+ * not physically disconnected
+ * if pullup() doesn't power off UDC
+ */
+static void s3c_udc_set_disconnect_state(struct s3c_udc *dev)
+{
+	u8 i;
+	
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+	
+	/* prevent new request submissions, kill any outstanding requests  */
+	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) 
+	{
+		struct s3c_ep *ep = &dev->ep[i];
+		ep->stopped = 1;
+		s3c_ep_nuke(ep, -ESHUTDOWN);
+	}
+
+	/* report disconnect; the driver is already quiesced */
+	DEBUG_PM("disconnect, gadget %s\n", dev->driver->driver.name);
+	if (dev->driver && dev->driver->disconnect) {
+		spin_unlock(&dev->lock);
+		dev->driver->disconnect(&dev->gadget);
+		spin_lock(&dev->lock);
+	}
+
+	/* re-init driver-visible data structures */
+	s3c_ep_list_reinit(dev);		
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_udc_stop_activity
+ * stop s3c-udc acting related with tx/rx and disconnect
+ * Caller must hold lock for s3c_udc_set_disconnect_state()
+ */
+static void s3c_udc_stop_activity(struct s3c_udc *dev, struct usb_gadget_driver *driver)
+{
+	/* don't disconnect drivers more than once */
+	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = NULL;
+	else
+		s3c_udc_set_disconnect_state(dev);
+}
+//---------------------------------------------------------------------------------------
+
+static void s3c_udc_reset(struct s3c_udc *dev)
+{
+#if 0
+		/*	only re-connect if not configured */
+		if(dev->udc_state != USB_STATE_CONFIGURED)
+		{
+			// 3. Put the OTG device core in the disconnected state.
+			s3c_udc_soft_disconnect();
+			udelay(20);
+	
+			// 4. Make the OTG device core exit from the disconnected state.
+			s3c_udc_soft_connect();
+		}
+#endif	
+	s3c_udc_set_address(dev, 0);
+	s3c_udc_set_disconnect_state(dev);
+
+	/* 	 6. Unmask the core interrupts */
+	writel(GINTMSK_RESET, S3C_UDC_OTG_GINTMSK);
+
+	/* 	 7. Set NAK bit of EP */
+	writel(DEPCTL_EPDIS|DEPCTL_SNAK, S3C_UDC_OTG_DOEPCTL(EP0_CON)); /* EP0: Control OUT */
+//	writel(DEPCTL_EPDIS|DEPCTL_SNAK, S3C_UDC_OTG_DIEPCTL(EP0_CON)); /* EP0: Control IN */
+
+	writel(DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE, S3C_UDC_OTG_DOEPCTL(EP1_OUT)); /* EP1:Data OUT */
+//	writel(DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE|EP3_IN<<DIEPCTL_NEXT_EP_BIT , S3C_UDC_OTG_DIEPCTL(EP2_IN)); /* EP2:Data IN */
+//	writel(DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE|EP0_CON<<DIEPCTL_NEXT_EP_BIT , S3C_UDC_OTG_DIEPCTL(EP3_IN)); /* EP3:IN Interrupt*/
+
+	writel(DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE, S3C_UDC_OTG_DOEPCTL(EP4_OUT)); /* EP4:Data OUT */
+//	writel(DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE|EP6_IN<<DIEPCTL_NEXT_EP_BIT , S3C_UDC_OTG_DIEPCTL(EP5_IN)); /* EP5:Data IN */
+//	writel(DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE|EP0_CON<<DIEPCTL_NEXT_EP_BIT , S3C_UDC_OTG_DIEPCTL(EP6_IN)); /* EP6:IN Interrupt*/
+
+	writel(DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE, S3C_UDC_OTG_DOEPCTL(EP7_OUT)); /* EP7:Data OUT */
+//	writel(DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE|EP9_IN<<DIEPCTL_NEXT_EP_BIT , S3C_UDC_OTG_DIEPCTL(EP8_IN)); /* EP8:Data IN */
+//	writel(DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE|EP0_CON<<DIEPCTL_NEXT_EP_BIT , S3C_UDC_OTG_DIEPCTL(EP9_IN)); /* EP9:IN Interrupt*/
+
+	udelay(10);
+
+	/* 8. Unmask EP interrupts on IN  EPs : 0, 2, 3 */
+	/* 		         		      OUT EPs : 0, 1 */
+	writel( (((1<<EP0_CON))<<16) |(1<<EP0_CON), S3C_UDC_OTG_DAINTMSK);
+
+	/* 9. Unmask device OUT EP common interrupts */
+	writel(DOEPMSK_INIT, S3C_UDC_OTG_DOEPMSK);
+
+	/* 10. Unmask device IN EP common interrupts */
+	writel(DIEPMSK_INIT, S3C_UDC_OTG_DIEPMSK);
+
+	/* 11. Set Rx FIFO Size */
+	writel(RX_FIFO_SIZE, S3C_UDC_OTG_GRXFSIZ);
+
+	/* 12. Set Non Periodic Tx FIFO Size */
+	writel(NPTX_FIFO_SIZE<<16| NPTX_FIFO_START_ADDR<<0, S3C_UDC_OTG_GNPTXFSIZ);
+
+	/* 13. Clear NAK bit of EP0, EP1, EP2 */
+	//writel(DEPCTL_EPDIS|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL(EP0_CON)); /* EP0: Control OUT */
+
+	s3c_ep0_pre_setup();
+
+	/* initialize ep0's next ep linked list */
+	INIT_LIST_HEAD(&ep0_nextep_list.list);
+
+}
+
+/**
+ * s3c_udc_initialize
+ * configure & initialize s3c-udc
+ */
+static void s3c_udc_initialize(struct s3c_udc *dev)
+{
+	/* 	2. Soft-reset OTG Core and then unreset again. */
+	/* 	
+	 * Typically software reset is used during software development
+	 * and also when you dynamically change the PHY selection bits in
+	 * the USB configuration registers 
+	 */
+//	writel(CORE_SOFT_RESET, S3C_UDC_OTG_GRSTCTL);		
+
+//neet to confirm relationship among cable_check of battery, usb pmic, software connection
+#if 0
+	// 3. Put the OTG device core in the disconnected state.
+	s3c_udc_soft_disconnect();
+	udelay(20);
+	
+	// 4. Make the OTG device core exit from the disconnected state.
+	s3c_udc_soft_connect();
+#endif
+
+	/* 	5. Configure OTG Core to initial settings of device mode. */
+	/* 	[1: full speed(30Mhz) 0:high speed] */
+	writel(1<<DCFG_EP_MISMATCH_CNT|DCFG_DEV_HIGH_SPEED_2_0<<DCFG_DEV_SPEED_BIT, S3C_UDC_OTG_DCFG);		
+
+	udelay(100);
+	
+	/* 	 6. Unmask the core interrupts */
+	writel(GINTMSK_INIT, S3C_UDC_OTG_GINTMSK);
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_udc_set_max_pktsize
+ * set maxium packed size of EPs regarding USB speed configured
+ */
+void s3c_udc_set_max_pktsize(struct s3c_udc *dev, enum usb_device_speed speed)
+{
+	u32 ep0_in, ep0_out, i;
+	u32 ep0_fifo_size = 0, bulk_fifo_size = 0;
+	u32 int_fifo_size = 0, iso_fifo_size = 0;
+
+/* USB spec. say (Ch.5)
+	
+	[Control Transfer]
+		HIGH speed: 64 Bytes
+		FULL speed: 8, 16, 32, 64 Bytes
+	  	LOW  speed: 8 Bytes
+	  	
+	[Bulk Transfer]
+		HIGH speed: 512 Bytes
+		FULL speed: 8, 16, 32, 64 Bytes
+	  	LOW  speed: not used
+	  	
+	[Interrupt Transfer]
+		HIGH speed: up to 1024 Bytes
+		FULL speed: up to 64 Bytes
+	  	LOW  speed: up to 8 Bytes
+	  	
+	[Isochronous Transfer]
+		HIGH speed: up to 1024 Bytes
+		FULL speed: up to 1023 Bytes
+	  	LOW  speed: not used
+*/
+
+	if (speed == USB_SPEED_HIGH) 
+	{
+		ep0_fifo_size = 64;
+		bulk_fifo_size = 512;
+		int_fifo_size = 1024;
+		iso_fifo_size = 1024;
+		dev->gadget.speed = USB_SPEED_HIGH;		
+	} 
+	else if (speed == USB_SPEED_FULL) 
+	{
+	/*
+		8, 16, 32, 64 Bytes are available 
+			for bulk_fifo_size, ep0_fifo_size regarding USB spec.
+	*/
+		ep0_fifo_size = 64;
+		bulk_fifo_size = 64;
+		int_fifo_size = 64;
+		iso_fifo_size = 1023;
+		dev->gadget.speed = USB_SPEED_FULL;
+	}
+	else //USB_SPEED_LOW
+	{
+		ep0_fifo_size = 8;
+		int_fifo_size = 8;
+		dev->gadget.speed = USB_SPEED_LOW;				
+	}
+	
+	ep0_in = readl(S3C_UDC_OTG_DIEPCTL(EP0_CON));
+	ep0_out = readl(S3C_UDC_OTG_DOEPCTL(EP0_CON));
+	ep0_in &= ~DEPCTL0_MPS_MASK;
+	ep0_out &= ~DEPCTL0_MPS_MASK;
+
+	switch(ep0_fifo_size)
+	{
+		case 64:
+			writel(ep0_in|DEPCTL0_MPS_64, S3C_UDC_OTG_DIEPCTL(EP0_CON));			
+			writel(ep0_out|DEPCTL0_MPS_64, S3C_UDC_OTG_DOEPCTL(EP0_CON));
+			break;
+		case 32:
+			writel(ep0_in|DEPCTL0_MPS_32, S3C_UDC_OTG_DIEPCTL(EP0_CON));			
+			writel(ep0_out|DEPCTL0_MPS_32, S3C_UDC_OTG_DOEPCTL(EP0_CON));
+			break;
+		case 16:
+			writel(ep0_in|DEPCTL0_MPS_16, S3C_UDC_OTG_DIEPCTL(EP0_CON));			
+			writel(ep0_out|DEPCTL0_MPS_16, S3C_UDC_OTG_DOEPCTL(EP0_CON));
+			break;
+		case 8:
+			writel(ep0_in|DEPCTL0_MPS_8, S3C_UDC_OTG_DIEPCTL(EP0_CON));			
+			writel(ep0_out|DEPCTL0_MPS_8, S3C_UDC_OTG_DOEPCTL(EP0_CON));
+			break;
+		default:
+			DEBUG_ERROR("[%s] Not proper value of ep0_fifo_size [%d] \n", __func__, ep0_fifo_size);
+	}
+	
+	/*
+		s3c_ep_activate() will change 
+		the max packet size gadget driver assigned
+	*/
+	for(i=0; i<=SUPPORTING_MAX_EP_NUM;i++)
+	{
+		switch ((dev->ep[i].bmAttributes) & USB_ENDPOINT_XFERTYPE_MASK) 
+		{
+			case USB_ENDPOINT_XFER_BULK:	
+				if (speed != USB_SPEED_LOW) 
+					dev->ep[i].ep.maxpacket = bulk_fifo_size;
+				break;				
+			case USB_ENDPOINT_XFER_INT: 
+				dev->ep[i].ep.maxpacket = int_fifo_size;
+				break;								
+			case USB_ENDPOINT_XFER_CONTROL:	
+				dev->ep[i].ep.maxpacket = ep0_fifo_size;
+				break;
+			case USB_ENDPOINT_XFER_ISOC:
+				if (speed != USB_SPEED_LOW) 
+					dev->ep[i].ep.maxpacket = iso_fifo_size;
+				break;					
+		}//switch
+	}//for
+}
+//---------------------------------------------------------------------------------------
+
+static inline void s3c_ep_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
+{
+	struct s3c_ep *ep = &dev->ep[ep_num];
+	struct s3c_request *req;
+
+	DEBUG("%s: Check queue, ep_num = %d\n", __func__, ep_num);
+
+	if (!list_empty(&ep->queue)) 
+	{
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+		DEBUG("%s: Next Tx request(0x%p) start...\n", __func__, req);
+
+		if (ep_is_in(ep))
+			s3c_udc_set_dma_tx(ep, req);
+		else
+			s3c_udc_set_dma_rx(ep, req);		
+	} 
+}
+
+/**
+ * handle_enum_done_intr
+ * handler of enumerate done irq
+ */
+static void handle_enum_done_intr(struct s3c_udc *dev)
+{
+	u32	usb_status = readl(S3C_UDC_OTG_DSTS);
+	/* 	EnumSpd 2:1 bits */
+	usb_status &= 0x6;
+	writel(INT_ENUMDONE, S3C_UDC_OTG_GINTSTS);
+
+/*
+ * Low speed is not supported for devices using a UTMI+ PHY
+ * 6410 supports UTMI
+ */	
+	if (usb_status == USB_HIGH_30_60MHZ) 
+	{
+		printk("[%s] Enumerated as HIGH Speed \n", dev->driver->driver.name);
+		DEBUG_SETUP("	 %s: High Speed Detection,  DSTS: 0x%x\n", __func__, usb_status);
+		s3c_udc_set_max_pktsize(dev, USB_SPEED_HIGH);
+	}
+	else if (usb_status & USB_LOW_6MHZ) 
+	{
+		printk("[%s] Enumerated as LOW Speed \n", dev->driver->driver.name);
+		DEBUG_SETUP("	 %s: Low Speed Detection,  DSTS: 0x%x\n", __func__, usb_status);
+		s3c_udc_set_max_pktsize(dev, USB_SPEED_LOW);	
+	}
+	else 
+	{
+		printk("[%s] Enumerated as FULL Speed \n", dev->driver->driver.name);
+		DEBUG_SETUP("	 %s: Full Speed Detection,  DSTS: 0x%x\n", __func__, usb_status);
+		s3c_udc_set_max_pktsize(dev, USB_SPEED_FULL);	
+	}
+	s3c_ep0_pre_setup();
+	
+}
+//---------------------------------------------------------------------------------------
+
+
+/**
+ * handle_reset_intr
+ * handler of reset irq
+ */
+static void handle_reset_intr(struct s3c_udc *dev)
+{	
+	u32	usb_status = readl(S3C_UDC_OTG_GOTGCTL);
+	writel(INT_RESET, S3C_UDC_OTG_GINTSTS);
+	DEBUG_PM("[%s] : Reset interrupt - (GOTGCTL):0x%x\n", __func__, usb_status);
+
+	/* confirm A & B Session Valid  */
+	if((usb_status & 0xc0000) == (0x3 << 18)) 
+	{
+		DEBUG_PM("	   ===> OTG core got reset & execute s3c_udc_reset()\n");
+		dev->udc_state = USB_STATE_DEFAULT;
+		s3c_udc_reset(dev);//s3c_udc_initialize(dev);
+		dev->ep0state = WAIT_FOR_SETUP;
+	} 
+	else 
+	{
+		DEBUG_PM("      RESET handling skipped : Not valid A or B session [GOTGCTL:0x%x] \n", usb_status);
+	}
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * handle_resume_intr
+ * handler of resume irq
+ */
+static void handle_resume_intr(struct s3c_udc *dev)
+{
+	writel(INT_RESUME, S3C_UDC_OTG_GINTSTS);
+	//	s3c_udc_resume_clock_gating();
+	
+	DEBUG_PM("[%s]: USB Bus Resume\n", __func__);
+	
+	dev->udc_state = dev->udc_resume_state;
+	dev->gadget.speed = dev->udc_resume_speed;
+
+	if (dev->gadget.speed != USB_SPEED_UNKNOWN
+		&& dev->driver && dev->driver->resume) 
+	{
+		spin_unlock(&dev->lock);
+		dev->driver->resume(&dev->gadget);
+		spin_lock(&dev->lock);
+	}
+	
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * handle_suspend_intr
+ * handler of suspend irq, USB suspend (host sleep)
+ * Being disconnected make s3c-udc fall into suspend
+ */
+static void handle_suspend_intr(struct s3c_udc *dev)
+{	
+	u32 usb_status;
+	
+	writel(INT_SUSPEND, S3C_UDC_OTG_GINTSTS);
+	
+	//confirm device is attached or not
+	if(dev->udc_state == USB_STATE_NOTATTACHED ||
+		dev->udc_state == USB_STATE_POWERED ||
+		dev->udc_state == USB_STATE_SUSPENDED )
+	{
+		//DEBUG_PM("[%s]: not proper state to go into the suspend mode\n", __func__);
+		return;
+	}
+	
+	usb_status = readl(S3C_UDC_OTG_DSTS);
+	
+	if ( !(usb_status & (1<<SUSPEND_STS)) )
+	{
+		//DEBUG_PM("[%s]: not suspend !~\n", __func__);
+		return;
+	}	
+
+	if (dev->gadget.speed != USB_SPEED_UNKNOWN)
+	{
+		DEBUG_PM("[%s]: USB Bus Suspend (DSTS):0x%x\n", __func__, usb_status);
+			
+		dev->udc_resume_state = dev->udc_state;
+		dev->udc_resume_speed = dev->gadget.speed;
+		
+		dev->udc_state = USB_STATE_SUSPENDED;
+		
+		//s3c_udc_suspend_clock_gating();
+		if (dev->driver && dev->driver->suspend) 
+		{
+			spin_unlock(&dev->lock);
+			dev->driver->suspend(&dev->gadget);
+			spin_lock(&dev->lock);			
+		}
+
+#if USBCV_CH9_REMOTE_WAKE_UP_TEST
+		printk("[%s]: USBCV_CH9_REMOTE_WAKE_UP_TEST just return\n", __func__);
+		return;
+#endif
+		// force s3c-udc to be disconnected for android gadgets
+		if (dev->config_gadget_driver == ANDROID_ADB ||
+			dev->config_gadget_driver == ANDROID_ADB_UMS ||
+			dev->config_gadget_driver == ANDROID_ADB_UMS_ACM)
+		{
+			s3c_udc_stop_activity(dev, dev->driver);
+		}	
+		// Confirm Other gadgets need to be disconnected or not
+		else
+		{
+			s3c_udc_stop_activity(dev, dev->driver);
+		}
+	}
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * handle_ep_in_intr
+ * handling reception of IN token
+ */
+static int handle_ep_in_intr(struct s3c_udc *dev)
+{
+	u32 ep_int, ep_int_status, ep_ctrl;
+	u32 nptxQ_SpcAvail, nptxFifo_SpcAvail, gnptxsts;
+	u8	ep_num = SUPPORTING_MAX_EP_NUM + 1, i;
+
+	ep_int = readl(S3C_UDC_OTG_DAINT);
+	DEBUG_IN_EP("\tDAINT : 0x%x \n", ep_int);
+
+	for(i=0; i<=SUPPORTING_MAX_EP_NUM; i++)
+	{
+		if (ep_int & (1<<i)) 
+		{
+			ep_num = i;
+			break;
+		}
+	}		
+	
+	ep_int_status = readl(S3C_UDC_OTG_DIEPINT(ep_num));
+	writel(ep_int_status, S3C_UDC_OTG_DIEPINT(ep_num)); 	// Interrupt Clear
+
+	if (ep_num > SUPPORTING_MAX_EP_NUM) {
+		DEBUG_ERROR("[%s]: No matching EP DAINT : 0x%x \n", __func__, ep_int);
+		return -1;
+	}
+
+	gnptxsts = readl(S3C_UDC_OTG_GNPTXSTS);
+	
+	nptxQ_SpcAvail = (gnptxsts & (0xff<<16))>>16;
+	nptxFifo_SpcAvail = gnptxsts & 0xffff;
+	
+	DEBUG_IN_EP("	 GNPTXSTS nptxQ_SpcAvail = %d, nptxFifo_SpcAvail = %d\n",nptxQ_SpcAvail ,nptxFifo_SpcAvail);
+	
+	if (nptxQ_SpcAvail == 0 || nptxFifo_SpcAvail == 0)
+	{
+		DEBUG_ERROR("[%s] : nptxQ_SpcAvail == 0 || nptxFifo_SpcAvail == 0 \n", __func__);
+		return -1;
+	}
+	
+	/*
+		The below delaying is dedicated to g_serial for handling 'ls' command in 
+		directory which has many files
+	*/
+	if(ep_num != EP0_CON && (dev->config_gadget_driver == SERIAL || dev->config_gadget_driver == CDC2) )
+	{			
+	#if SERIAL_TRANSFER_DELAY 
+	#if OTG_DBG_ENABLE
+		#ifdef DEBUG_S3C_UDC_IN_EP
+					DEBUG_IN_EP("[%s] : EP In for g_serial or g_cdc\n", __func__);
+		#else
+					printk("[%s] : EP In for g_serial or g_cdc\n", __func__);
+		#endif			
+	#else
+		udelay(SERIAL_DELAY_uTIME);
+	#endif //OTG_DBG_ENABLE
+	#endif //SERIAL_TRANSFER_DELAY
+	}
+
+	if(ep_num == EP2_IN && dev->config_gadget_driver == ANDROID_ADB_UMS_ACM)	
+	{			
+	#if SERIAL_TRANSFER_DELAY 
+	#if OTG_DBG_ENABLE
+	#ifdef DEBUG_S3C_UDC_IN_EP
+		DEBUG_IN_EP("[%s] : EP In for g_serial or g_cdc\n", __func__);
+	#else
+		printk("[%s] : EP In for g_serial or g_cdc\n", __func__);
+	#endif			
+	#else
+		udelay(SERIAL_DELAY_uTIME);
+	#endif //OTG_DBG_ENABLE
+	#endif //SERIAL_TRANSFER_DELAY
+	}
+
+	switch(ep_num)
+	{
+		case EP0_CON: case EP2_IN: 	case EP3_IN: case EP5_IN:
+		case EP6_IN:  case EP8_IN:  case EP9_IN:			
+			
+			ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(ep_num));
+			DEBUG_IN_EP("\tEP[%d]-IN : DIEPINT[%d] = 0x%x, DIEPCTL[%d] = 0x%x \n", 
+				ep_num, ep_num, ep_int_status, ep_num,  ep_ctrl);
+			
+			if (ep_int_status & TRANSFER_DONE) 
+			{
+				DEBUG_IN_EP("\tEP[%d]-IN transaction completed - (TX DMA done)\n", ep_num);
+			
+				handle_tx_complete(dev, ep_num);
+
+				if (ep_num == EP0_CON) 
+				{
+					if(dev->ep0state == WAIT_FOR_SETUP) 
+					{
+						s3c_ep0_pre_setup();
+					}
+#if 0
+					/* continue transfer after set_clear_halt for DMA mode */
+					if (clear_feature_flag == 1)
+					{
+						s3c_ep_check_tx_queue(dev, clear_feature_num);
+						clear_feature_flag = 0;
+					}
+#endif				
+				}
+			}
+			break;
+		default:
+			DEBUG_ERROR("[%s]: Error Unused EP[%d]\n", __func__, ep_num);
+			return -1;
+	} //switch
+	return 0;
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * handle_ep_out_intr
+ * handling reception of OUT token
+ */
+static void handle_ep_out_intr(struct s3c_udc * dev)
+{
+	u32 ep_int, ep_int_status, ep_ctrl;
+	u8	ep_num = SUPPORTING_MAX_EP_NUM + 1, i;
+
+	ep_int = readl(S3C_UDC_OTG_DAINT);
+	DEBUG_OUT_EP("\tDAINT : 0x%x \n", ep_int);
+	
+	for(i=0; i<=SUPPORTING_MAX_EP_NUM; i++)
+		if (ep_int & ((1<<i)<<16)) 
+		{
+			ep_num = i;
+			break;
+		}
+	
+	ep_int_status = readl(S3C_UDC_OTG_DOEPINT(ep_num));
+
+	if (ep_num > SUPPORTING_MAX_EP_NUM) 
+	{
+		DEBUG_ERROR("[%s]: No matching EP DAINT : 0x%x \n", __func__, ep_int);
+		writel(ep_int_status, S3C_UDC_OTG_DOEPINT(ep_num)); 	// ep1 Interrupt Clear
+		return;
+	}
+	
+	switch(ep_num)
+	{
+		case EP0_CON: 
+			ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL(EP0_CON));
+			DEBUG_EP0("\tEP0-OUT : DOEPINT0 = 0x%x, DOEPCTL0 = 0x%x\n", ep_int_status, ep_ctrl);
+			
+			if (ep_int_status & CTRL_OUT_EP_SETUP_PHASE_DONE) 
+			{
+				DEBUG_EP0("\tSETUP packet(transaction) arrived\n");
+				writel(CTRL_OUT_EP_SETUP_PHASE_DONE, S3C_UDC_OTG_DOEPINT(ep_num)); // Interrupt Clear
+			//	s3c_ep0_pre_setup();
+				s3c_ep0_handle(dev);
+			}
+			else if (ep_int_status & TRANSFER_DONE) 
+			{
+				writel(TRANSFER_DONE, S3C_UDC_OTG_DOEPINT(ep_num));	// Interrupt Clear
+				handle_rx_complete(dev, EP0_CON);
+				s3c_ep0_pre_setup();
+			}
+			else
+			{
+				writel(ep_int_status, S3C_UDC_OTG_DOEPINT(ep_num));	// Interrupt Clear
+				s3c_ep0_pre_setup();
+			}
+			break;
+		case EP1_OUT: case EP4_OUT:	case EP7_OUT:			
+			ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL(ep_num));
+			
+			DEBUG_OUT_EP("\tEP[%d]-OUT : DOEPINT[%d] = 0x%x, DOEPCTL[%d] = 0x%x\n", 
+				ep_num, ep_num, ep_int_status, ep_num, ep_ctrl);
+			
+			if (ep_int_status & TRANSFER_DONE) 
+			{
+				DEBUG_OUT_EP("\tBULK OUT packet(transaction) arrived - (RX DMA done)\n");
+				handle_rx_complete(dev, ep_num);
+			}
+			writel(ep_int_status, S3C_UDC_OTG_DOEPINT(ep_num));		// ep1 Interrupt Clear
+			break;
+		default:
+			writel(ep_int_status, S3C_UDC_OTG_DOEPINT(ep_num));		// Interrupt Clear
+			DEBUG_ERROR("[%s]: Error Unused EP[%d]\n", __func__, ep_num);
+	}
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_udc_change_nextep
+ * change next ep s3c-udc
+ */
+static void s3c_udc_change_nextep(struct s3c_udc *dev)
+{
+	DEBUG_SETUP("[%s] \n", __func__);
+	
+	if(dev->config_gadget_driver == ETHER_CDC)
+	{			
+		s3c_ep_set_next_ep(EP2_IN, EP0_CON);
+	}
+	else if(dev->config_gadget_driver == ANDROID_ADB_UMS ||
+		dev->config_gadget_driver == ANDROID_ADB_UMS_ACM)
+	{			
+		s3c_ep_set_next_ep(EP2_IN, EP0_CON);
+		s3c_ep_set_next_ep(EP5_IN, EP0_CON);
+		s3c_ep_set_next_ep(EP8_IN, EP0_CON);
+	}
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_udc_irq
+ * irq handler of s3c-udc
+ */
+static irqreturn_t s3c_udc_irq(int irq, void *_dev)
+{
+	struct s3c_udc *dev = _dev;
+	u32 intr_status, gintmsk;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	intr_status = readl(S3C_UDC_OTG_GINTSTS);
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+
+	DEBUG_ISR("\n**** %s : GINTSTS=0x%x(on state %s), GINTMSK : 0x%x, DAINT : 0x%x, DAINTMSK : 0x%x\n",
+			__func__, intr_status, state_names[dev->ep0state], gintmsk, 
+			readl(S3C_UDC_OTG_DAINT), readl(S3C_UDC_OTG_DAINTMSK));
+
+	if(intr_status & INT_OUT_EP)
+	{
+		DEBUG_OUT_EP("[%s] : EP Out interrupt \n", __func__);
+		handle_ep_out_intr(dev);
+		goto	OK_OUT;
+	}
+
+	if (intr_status & INT_IN_EP) 
+	{
+		DEBUG_IN_EP("[%s] : EP In interrupt \n", __func__);
+		if(handle_ep_in_intr(dev) == -1)
+			goto FAIL_OUT;
+		goto	OK_OUT;
+	}
+	
+	if (intr_status & INT_RESET) {
+		handle_reset_intr(dev);			
+		goto	OK_OUT;
+	}
+
+	if (intr_status & INT_ENUMDONE) 
+	{
+		DEBUG_SETUP("[%s] : Enumeration Done interrupt\n",	__func__);
+		handle_enum_done_intr(dev);
+		goto	OK_OUT;
+	}
+
+/*
+	Currently(Apr 13, 2009)
+	No activities needed during early suspend.
+	
+	if (intr_status & INT_EARLY_SUSPEND) 
+	{
+		DEBUG_PM("[%s] Early suspend interrupt\n", __func__);
+		writel(INT_EARLY_SUSPEND, S3C_UDC_OTG_GINTSTS);
+		goto	OK_OUT;
+	}
+*/
+	if (intr_status & INT_SUSPEND) 
+	{
+		handle_suspend_intr(dev);
+		goto	OK_OUT;
+	}
+	
+	if (intr_status & INT_RESUME) 
+	{
+		handle_resume_intr(dev);
+		goto	OK_OUT;
+	}
+	
+	if (intr_status) 
+		DEBUG_ERROR("no handler for S3C_UDC_OTG_GINTSTS [%d]\n", intr_status);
+	else
+		DEBUG_ERROR("no S3C_UDC_OTG_GINTSTS( == 0)\n");
+
+	goto	FAIL_OUT;
+	
+OK_OUT:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return IRQ_HANDLED;
+
+FAIL_OUT:
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return IRQ_NONE;
+}
+//---------------------------------------------------------------------------------------
+
+void s3c_ep_activate(struct s3c_ep *ep)
+{
+	u8 ep_num;
+	u32 ep_ctrl = 0, daintmsk = 0;
+	
+	ep_num = ep_index(ep);
+
+	/* Read DEPCTLn register */
+	if (ep_is_in(ep)) {
+		ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(ep_num));
+		daintmsk = 1 << ep_num;
+	} else {
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL(ep_num));
+		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
+	}
+
+	DEBUG_SETUP("%s: EPCTRL%d = 0x%x, ep_is_in = %d\n",
+		__func__, ep_num, ep_ctrl, ep_is_in(ep));
+		
+	/* If the EP is already active don't change the EP Control
+	 * register. */
+	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
+		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK)| (ep->bmAttributes << DEPCTL_TYPE_BIT);
+		ep_ctrl = (ep_ctrl & ~DEPCTL_MPS_MASK) | (ep->ep.maxpacket << DEPCTL_MPS_BIT);
+		ep_ctrl |= (DEPCTL_SETD0PID | DEPCTL_USBACTEP);
+
+		if (ep_is_in(ep)) {
+			writel(ep_ctrl, S3C_UDC_OTG_DIEPCTL(ep_num));
+			DEBUG_SETUP("%s: USB Ative EP%d, DIEPCTRL%d = 0x%x\n",
+				__func__, ep_num, ep_num, readl(S3C_UDC_OTG_DIEPCTL(ep_num)));
+		} else {
+			writel(ep_ctrl, S3C_UDC_OTG_DOEPCTL(ep_num));
+			DEBUG_SETUP("%s: USB Ative EP%d, DOEPCTRL%d = 0x%x\n",
+				__func__, ep_num, ep_num, readl(S3C_UDC_OTG_DOEPCTL(ep_num)));
+		}
+	}
+	else		
+		DEBUG_SETUP("%s: already activated EP%d, DIEPCTRL = 0x%x\n",
+			__func__, ep_num, readl(S3C_UDC_OTG_DIEPCTL(ep_num)));
+
+	/* Unmask EP Interrtupt */
+	writel(readl(S3C_UDC_OTG_DAINTMSK)|daintmsk, S3C_UDC_OTG_DAINTMSK);
+	DEBUG_SETUP("%s: DAINTMSK = 0x%x\n", __func__, readl(S3C_UDC_OTG_DAINTMSK));
+}
+
+/**
+ * enable a ep
+ */
+static int s3c_ep_enable(struct usb_ep *_ep,
+			     const struct usb_endpoint_descriptor *desc)
+{
+	struct s3c_ep *ep;
+	struct s3c_udc *dev;
+	unsigned long flags;
+	
+	u8  ep_num;
+	
+	ep = container_of(_ep, struct s3c_ep, ep);
+
+	DEBUG_SETUP("[%s] EP-%d\n", __func__, ep_index(ep));
+
+	if (!_ep || !desc || ep->desc || _ep->name == ep0name
+	    || desc->bDescriptorType != USB_DT_ENDPOINT
+	    || ep->bEndpointAddress != desc->bEndpointAddress)
+	{
+		DEBUG_ERROR("[%s] bad ep or descriptor\n", __func__);
+		return -EINVAL;
+	}
+
+	if (ep_maxpacket(ep) < le16_to_cpu(desc->wMaxPacketSize)) 
+	{
+		DEBUG_ERROR("[%s] ep_maxpacket(ep) < desc->wMaxPacketSize\n", __func__);
+		return -EINVAL;
+	}
+
+	/* xfer types must match, except that interrupt ~= bulk */
+	if (ep->bmAttributes != desc->bmAttributes
+	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
+	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) 
+	{
+		DEBUG_ERROR("[%s] %s type mismatch\n", __func__, _ep->name);
+		return -EINVAL;
+	}
+
+	/* hardware _could_ do smaller, but driver doesn't */
+	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
+	     && le16_to_cpu(desc->wMaxPacketSize) != ep_maxpacket(ep))
+	    || !desc->wMaxPacketSize) 
+	{
+		DEBUG_ERROR("[%s] bad %s maxpacket\n", __func__, _ep->name);
+		return -ERANGE;
+	}
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) 
+	{
+		DEBUG_ERROR("[%s] bogus device state\n", __func__);
+		return -ESHUTDOWN;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	ep->stopped = 0;
+	ep->desc = desc;
+	ep->pio_irqs = 0;
+	ep->ep.maxpacket = le16_to_cpu(desc->wMaxPacketSize);
+
+	/* Reset halt state */
+	s3c_ep_set_halt(_ep, 0);
+
+	ep_num = ep_index(ep);
+	if(ep_num <= SUPPORTING_MAX_EP_NUM)
+	{
+		s3c_ep_activate(ep);
+	}
+	else
+	{
+		DEBUG_ERROR("[%s] not supported ep %d\n",__func__, ep_num); 		
+	}
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	DEBUG_SETUP("[%s] enabled %s, stopped = %d, maxpacket = %d\n",
+		__func__, _ep->name, ep->stopped, ep->ep.maxpacket);
+	return 0;
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * disable a ep
+ */
+static int s3c_ep_disable(struct usb_ep *_ep)
+{
+	struct s3c_ep *ep = NULL;
+	unsigned long flags;
+	u8 ep_num;
+	
+	u32 ep_ctrl, daintmsk;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	
+	DEBUG_SETUP("[%s] EP-%d\n", __func__, ep_index(ep));
+
+	if (!_ep || !ep->desc) 
+	{
+		DEBUG_SETUP("[%s] %s not enabled\n", __func__,
+		      _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+	
+	ep_num = ep_index(ep);
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	/* Nuke all pending requests */
+	s3c_ep_nuke(ep, -ESHUTDOWN);
+
+	ep->desc = 0;
+	ep->stopped = 1;
+	
+	daintmsk = readl(S3C_UDC_OTG_DAINTMSK);
+
+	s3c_ep0_next_ep_del_one_ep_list_(ep_num);
+	
+	if(ep_num <= SUPPORTING_MAX_EP_NUM)
+	{
+		if(ep_is_in(ep))
+		{
+			/* EP: IN */
+			ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(ep_num));
+			writel(ep_ctrl&~(DEPCTL_USBACTEP), S3C_UDC_OTG_DIEPCTL(ep_num)); 
+			writel(daintmsk&(~(1<<ep_num)), S3C_UDC_OTG_DAINTMSK);
+		}
+		else
+		{
+			/* EP: OUT */
+			ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL(ep_num));
+			writel(ep_ctrl&~(DEPCTL_USBACTEP), S3C_UDC_OTG_DOEPCTL(ep_num)); 
+			writel(daintmsk&(~(1<<(ep_num+16))), S3C_UDC_OTG_DAINTMSK);
+		}
+	}
+	else
+	{
+		DEBUG_ERROR("[%s] not supported ep %d\n",__func__, ep_num);		
+	}
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+	
+	return 0;
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_ep_alloc_request
+ * allocate a request for s3c-udc
+ */
+static struct usb_request *s3c_ep_alloc_request(struct usb_ep *ep,
+						 gfp_t gfp_flags)
+{
+	struct s3c_request *req;
+
+	DEBUG("[%s] %s %p\n", __func__, ep->name, ep);
+
+	req = kmalloc(sizeof *req, gfp_flags);
+	if (!req)
+		return 0;
+	
+	memset(req, 0, sizeof *req);
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_ep_free_request
+ * free a request for s3c-udc
+ */
+static void s3c_ep_free_request(struct usb_ep *ep, struct usb_request *_req)
+{
+	struct s3c_request *req;
+
+	DEBUG("[%s] %p\n", __func__, ep);
+
+	req = container_of(_req, struct s3c_request, req);
+	kfree(req);
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ * Queue one request
+ * Kickstart transfer if needed
+ */
+static int s3c_ep_queue(struct usb_ep *_ep, struct usb_request *_req,
+			 gfp_t gfp_flags)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep;
+	struct s3c_udc *dev;
+	unsigned long flags;
+	u32 ep_num;
+
+	req = container_of(_req, struct s3c_request, req);
+	if (unlikely(!_req || !_req->complete || !_req->buf || !list_empty(&req->queue)))
+	{
+		DEBUG_ERROR("[%s] bad params\n", __func__);
+		
+		if (!list_empty(&req->queue))
+			DEBUG_ERROR("[%s] (!list_empty(&req->queue))\n", __func__);
+		else if (!_req->buf )
+			DEBUG_ERROR("[%s] (!_req->buf )\n", __func__);
+		else if (!_req->complete)
+			DEBUG_ERROR("[%s] (!_req->complete)\n", __func__);
+		else // (!_req )
+			DEBUG_ERROR("[%s] (!_req )\n", __func__);
+		
+		return -EINVAL;
+	}
+
+	ep = container_of(_ep, struct s3c_ep, ep);	
+	
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) 
+	{
+		DEBUG_ERROR("[%s] : bad ep\n", __func__);
+		return -EINVAL;
+	}
+
+	ep_num = (u32)ep_index(ep);
+	dev = ep->dev;
+	
+	if (unlikely(!dev->driver)) {
+		DEBUG_ERROR("[%s] EP[%d]: Queueing dev->driver is NULL \n", __func__, ep_num);
+		return -ESHUTDOWN;
+	}
+//	if (unlikely(dev->gadget.speed == USB_SPEED_UNKNOWN && 
+//			dev->udc_state < USB_STATE_ADDRESS)) {
+	if (unlikely(dev->gadget.speed == USB_SPEED_UNKNOWN)) {
+		DEBUG_ERROR("[%s] EP[%d]: Queueing USB_SPEED_UNKNOWN state\n", __func__, ep_num);
+		return -ESHUTDOWN;
+	}
+	
+	DEBUG("\n%s: %s queue req %p, len %d buf %p\n",__func__, _ep->name, _req, _req->length, _req->buf);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	/* kickstart this i/o queue? */
+	DEBUG("[%s] Add to ep=%d, Q empty=%d, stopped=%d\n",__func__, ep_num, list_empty(&ep->queue), ep->stopped);
+
+
+	if(req->req.zero == true && req->req.length == 0) 
+	{				
+		DEBUG("[%s] gadget driver request sending zlp\n", __func__);		
+		s3c_ep_send_zlp(EP0_CON);
+		return 0;
+	}		
+
+#if S3C_UDC_ZLP
+	req->zlp = false;
+	if(req->req.zero)
+	{
+		if((req->req.length % ep->ep.maxpacket == 0) &&
+			(req->req.length != 0) )
+		{				
+			req->zlp = true;
+			DEBUG("[%s] S3C_UDC_ZLP req->zlp = true\n", __func__);
+		}		
+	}
+#endif	
+
+	if (list_empty(&ep->queue) && !ep->stopped) 
+	{
+		u32 csr;
+		
+		/* EP0 */
+		if (ep_num == 0) 
+		{
+			list_add_tail(&req->queue, &ep->queue);
+			DEBUG_EP0("[%s] ep_is_in = %d\n", __func__, ep_is_in(ep));
+			
+			if (ep_is_in(ep)) 
+			{
+				dev->ep0state = DATA_STATE_XMIT;
+				s3c_ep0_write(dev);
+			} 
+			else 
+			{
+				dev->ep0state = DATA_STATE_RECV;
+				s3c_ep0_read(dev);
+			}
+			req = 0;
+
+		} 
+		/* EP-IN */
+		else if(ep_is_in(ep))// 
+		{
+			csr = readl(S3C_UDC_OTG_GINTSTS);
+			DEBUG_IN_EP("[%s] : ep_is_in, S3C_UDC_OTG_GINTSTS=0x%x\n",
+				__func__, csr);
+			s3c_udc_set_dma_tx(ep, req);
+		} 
+		/* EP-OUT */
+		else 
+		{
+			csr = readl(S3C_UDC_OTG_GINTSTS);
+			DEBUG_OUT_EP("[%s] ep_is_out, S3C_UDC_OTG_GINTSTS=0x%x\n",
+				__func__, csr);
+
+			s3c_udc_set_dma_rx(ep, req);
+		}
+	}
+
+	/* pio or dma irq handler advances the queue. */
+	if (likely(req != 0))
+	{
+		list_add_tail(&req->queue, &ep->queue);
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_ep_dequeue
+ * dequeue JUST ONE request
+ */
+static int s3c_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct s3c_ep *ep;
+	struct s3c_request *req;
+	unsigned long flags;
+
+	DEBUG("[%s] %p\n", __func__, _ep);
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep || ep->ep.name == ep0name)
+	{
+		DEBUG("[%s] !_ep || !ep\n", __func__);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) 
+	{
+		if (&req->req == _req)
+			break;
+	}
+	
+	if (&req->req != _req) 
+	{
+		spin_unlock_irqrestore(&ep->dev->lock, flags);
+		return -EINVAL;
+	}
+
+	s3c_req_done(ep, req, -ECONNRESET);
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+	return 0;
+}
+//---------------------------------------------------------------------------------------
+
+void s3c_ep_set_stall(struct s3c_ep *ep)
+{
+	u8		ep_num;
+	u32		ep_ctrl = 0;
+
+	ep_num = ep_index(ep);
+	DEBUG_SETUP("%s: ep_num = %d\n", __func__, ep_num);
+		
+	if (ep_is_in(ep)) {
+		ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(ep_num));
+	
+		/* set the disable and stall bits */
+//		if (ep_ctrl & DEPCTL_EPENA) {
+//			ep_ctrl |= DEPCTL_EPDIS;
+//		}
+		ep_ctrl |= DEPCTL_STALL;
+
+		writel(ep_ctrl, S3C_UDC_OTG_DIEPCTL(ep_num));
+		DEBUG_SETUP("%s: set stall, DIEPCTL%d = 0x%x\n",
+			__func__, ep_num, readl(S3C_UDC_OTG_DIEPCTL(ep_num)));
+
+	} else {
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL(ep_num));
+
+		/* set the stall bit */
+		ep_ctrl |= DEPCTL_STALL;
+
+		writel(ep_ctrl, S3C_UDC_OTG_DOEPCTL(ep_num));
+		DEBUG_SETUP("%s: set stall, DOEPCTL%d = 0x%x\n",
+			__func__, ep_num, readl(S3C_UDC_OTG_DOEPCTL(ep_num)));
+	}
+		
+	return;
+}
+
+void s3c_ep_clear_stall(struct s3c_ep *ep)
+{
+	u8		ep_num;
+	u32		ep_ctrl = 0;
+
+	ep_num = ep_index(ep);	
+	DEBUG_SETUP("%s: ep_num = %d, \n", __func__, ep_num);
+
+	if (ep_num == EP0_CON)
+	{	
+		DEBUG_SETUP("%s: ep_num = %d Core will clear\n", __func__, ep_num);
+		return;
+	}
+#ifdef CONFIG_USB_FILE_STORAGE
+	if(ep_num == EP5_IN && !MSC_INVALID_CBW_IGNORE_CLEAR_HALT()) {
+		DEBUG("[%s] skipped by ep[%d] MSC_INVALID_CBW_IGNORE_CLEAR_HALT \n", __func__, ep_num);
+		return;
+	}
+#endif
+	
+	if (ep_is_in(ep)) {
+		ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(ep_num));
+
+		/* clear stall bit */
+		ep_ctrl &= ~DEPCTL_STALL;
+
+		/* 
+		 * USB Spec 9.4.5: For endpoints using data toggle, regardless
+		 * of whether an endpoint has the Halt feature set, a
+		 * ClearFeature(ENDPOINT_HALT) request always results in the
+		 * data toggle being reinitialized to DATA0.
+		 */
+		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
+		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
+			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
+		}
+
+		writel(ep_ctrl, S3C_UDC_OTG_DIEPCTL(ep_num));
+		DEBUG_SETUP("%s: cleared stall, DIEPCTL%d = 0x%x\n",
+			__func__, ep_num, readl(S3C_UDC_OTG_DIEPCTL(ep_num)));
+
+	} else {
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL(ep_num));
+
+		/* clear stall bit */
+		ep_ctrl &= ~DEPCTL_STALL;
+
+		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
+		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
+			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
+		}
+
+		writel(ep_ctrl, S3C_UDC_OTG_DOEPCTL(ep_num));
+		DEBUG_SETUP("%s: cleared stall, DOEPCTL%d = 0x%x\n",
+			__func__, ep_num, readl(S3C_UDC_OTG_DOEPCTL(ep_num)));
+	}
+
+	return;
+}
+
+static inline void s3c_ep0_set_stall(struct s3c_ep *ep) 
+{
+	struct s3c_udc *dev;
+	u32		ep_ctrl = 0;
+
+	dev = ep->dev;
+	ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(EP0_CON));
+
+	/* set the disable and stall bits ONLY IN direction */
+	if (ep_ctrl & DEPCTL_EPENA) {
+		ep_ctrl |= DEPCTL_EPDIS;
+	}
+	ep_ctrl |= DEPCTL_STALL;
+
+	writel(ep_ctrl, S3C_UDC_OTG_DIEPCTL(EP0_CON));
+
+	DEBUG_SETUP("%s: set ep%d stall, DIEPCTL0 = 0x%x\n",
+		__func__, ep_index(ep), readl(S3C_UDC_OTG_DIEPCTL(EP0_CON)));
+	/* 
+	 * The application can only set this bit, and the core clears it,
+	 * when a SETUP token is received for this endpoint
+	 */
+	dev->ep0state = WAIT_FOR_SETUP;
+	s3c_ep0_pre_setup();
+}
+
+/** Halt specific EP
+ *  Return 0 if success
+ */	
+static int s3c_ep_set_halt(struct usb_ep *_ep, int value)
+{
+	struct s3c_ep	*ep;
+	struct s3c_udc	*dev;
+//	unsigned long	flags;
+	u8		ep_num;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+
+	if (unlikely (!_ep || (!ep->desc && ep->ep.name != ep0name) ||
+			ep->desc->bmAttributes == USB_ENDPOINT_XFER_ISOC)) {
+		DEBUG_ERROR("%s: %s bad ep or descriptor\n", __func__, ep->ep.name);
+		return -EINVAL;
+	}
+
+	/* Attempt to halt IN ep will fail if any transfer requests
+	 * are still queue */
+	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
+		DEBUG_ERROR("%s: %s queue not empty, req = %p\n",
+			__func__, ep->ep.name,
+			list_entry(ep->queue.next, struct s3c_request, queue));
+
+		return -EAGAIN;
+	}
+
+	dev = ep->dev;
+	ep_num = ep_index(ep);
+	DEBUG_SETUP("%s: ep_num = %d, value = %d\n", __func__, ep_num, value);
+
+//caller s3c_ep_enable already locked
+//	spin_lock_irqsave(&dev->lock, flags);
+	/* clear */
+	if (value == 0)
+	{
+		ep->stopped = 0;
+		// EP0 stall will be cleared by OTG Core
+		if (ep_num != 0) 
+			s3c_ep_clear_stall(ep);
+	} 
+	/* set */
+	else 
+	{
+		ep->stopped = 1;
+		if (ep_num == 0) 
+		{
+			s3c_ep0_set_stall(ep);
+		}
+		else
+		{
+			s3c_ep_set_stall(ep);
+		}
+	}
+//	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ *  write a request into ep0's fifo
+ *  return:  0 = still running, 1 = completed, negative = errno
+ */
+static int s3c_ep0_write_fifo(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 max;
+	unsigned count;
+	int is_last;
+
+	max = ep_maxpacket(ep);
+
+	DEBUG_EP0("[%s] max = %d\n", __func__, max);
+
+	count = s3c_udc_set_dma_tx(ep, req);
+
+	/* last packet is usually short (or a zlp) */
+	if (likely(count != max))
+		is_last = 1;
+	else 
+	{
+		if (likely(req->req.length != req->req.actual) || req->req.zero)
+			is_last = 0;
+		else
+			is_last = 1;
+	}
+
+	DEBUG_EP0("[%s] wrote %s %d bytes%s %d left %p\n", __func__,
+		  ep->ep.name, count,
+		  is_last ? "/L" : "", req->req.length - req->req.actual, req);
+
+	/* requests complete when all IN data is in the FIFO */
+	if (is_last) 
+	{
+		ep->dev->ep0state = WAIT_FOR_SETUP;
+		return 1;
+	}
+
+	return 0;
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_udc_set_address - set the USB address for this device
+ *
+ * Called from control endpoint function
+ * after it decodes a set address setup packet.
+ */
+static void s3c_udc_set_address(struct s3c_udc *dev, unsigned char address)
+{
+	u32 ctrl = readl(S3C_UDC_OTG_DCFG);
+
+	ctrl &= ~(DCFG_DEV_ADDRESS_MASK << DCFG_DEV_ADDRESS_BIT);
+	ctrl |= (address << DCFG_DEV_ADDRESS_BIT);
+		
+	writel(ctrl, S3C_UDC_OTG_DCFG);
+
+	DEBUG_EP0("[%s] USB OTG 2.0 Device address=%d, DCFG=0x%x\n",
+		__func__, address, readl(S3C_UDC_OTG_DCFG));
+	
+	dev->usb_address = address;
+	dev->udc_state = USB_STATE_ADDRESS;
+}
+//---------------------------------------------------------------------------------------
+
+//dma read g_status out of function
+static	u16	g_status;
+
+static int s3c_udc_get_status(struct s3c_udc *dev,
+		struct usb_ctrlrequest *crq)
+{
+	u8 ep_num = crq->wIndex & USB_ENDPOINT_NUMBER_MASK;
+	u32 ep_ctrl;
+
+	DEBUG_SETUP("%s: *** USB_REQ_GET_STATUS  \n",__func__);
+
+	switch (crq->bRequestType & USB_RECIP_MASK) 
+	{
+		/* ref. USB spec. p255 */
+		case USB_RECIP_INTERFACE:
+			/* just return 0 */
+			g_status = 0;
+			DEBUG_SETUP("\tGET_STATUS: USB_RECIP_INTERFACE, g_stauts = %d\n", g_status);
+			break;
+
+		case USB_RECIP_DEVICE:
+			/* return RemoteWakeup & SelfPowered */
+			g_status = dev->devstatus; 
+			DEBUG_SETUP("\tGET_STATUS: USB_RECIP_DEVICE, g_stauts = %d\n", g_status);
+			break;
+
+		case USB_RECIP_ENDPOINT:
+			/* return state of halt */
+			if (ep_num > SUPPORTING_MAX_EP_NUM || crq->wLength > 2) {
+				DEBUG_ERROR("\tGET_STATUS: Not support EP or wLength\n");
+				return -1;
+			}
+
+			g_status = dev->ep[ep_num].stopped;
+
+			DEBUG_SETUP("\tGET_STATUS: USB_RECIP_ENDPOINT[ep(%d).stopped]: g_stauts = %d\n", ep_num, g_status);
+
+			if(ep_is_in(&(dev->ep[ep_num]))) {
+				DEBUG_SETUP("\t DIEPCTL[%d] = 0x%x\n", ep_num, readl(S3C_UDC_OTG_DIEPCTL(ep_num)));				
+			}
+			else {
+				DEBUG_SETUP("\t DOEPCTL[%d] = 0x%x\n", ep_num, readl(S3C_UDC_OTG_DOEPCTL(ep_num)));
+			}
+
+			break;
+
+		default:
+			return -1;
+	}
+
+	prefetch(&g_status);
+
+	dma_cache_maint(&g_status, 2, DMA_TO_DEVICE);
+
+	writel(virt_to_phys(&g_status), S3C_UDC_OTG_DIEPDMA(EP0_CON));
+	writel((1<<DEPTSIZ_PKT_CNT_BIT)|(2<<0), S3C_UDC_OTG_DIEPTSIZ(EP0_CON));
+
+	ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL(EP0_CON));
+	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DIEPCTL(EP0_CON));
+	dev->ep0state = WAIT_FOR_SETUP;
+
+	return 0;
+}
+
+/**
+ * s3c_ep0_read
+ * read a transfer at OUT data transaction of control transfer
+ */
+static void s3c_ep0_read(struct s3c_udc *dev)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep = &dev->ep[0];
+	int ret;
+
+	if (!list_empty(&ep->queue))
+	{
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+	}
+	else 
+	{
+		DEBUG_ERROR("[%s] reading data from empty ep->queue\n", __func__);
+		return;
+	}
+
+	DEBUG_EP0("[%s] req.length = 0x%x, req.actual = 0x%x\n",
+		__func__, req->req.length, req->req.actual);
+
+	if(req->req.length == 0) 
+	{
+		dev->ep0state = WAIT_FOR_SETUP;
+		s3c_req_done(ep, req, 0);
+		return;
+	}
+
+	ret = s3c_udc_set_dma_rx(ep, req);
+
+	if (ret) 
+	{
+		dev->ep0state = WAIT_FOR_SETUP;
+		s3c_req_done(ep, req, 0);
+		return;
+	}
+
+}
+//---------------------------------------------------------------------------------------
+
+/**
+ * s3c_ep0_write
+ * write a transfer at IN data transaction of control transfer
+ */
+static int s3c_ep0_write(struct s3c_udc *dev)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep = &dev->ep[0];
+	int ret; //, need_zlp = 0;
+
+	DEBUG_EP0("[%s] ep0 write\n", __func__);
+
+	if (list_empty(&ep->queue))
+	{
+		req = 0;
+	}
+	else
+	{
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+	}
+
+	if (!req) 
+	{
+		DEBUG_EP0("[%s] NULL REQ\n", __func__);
+		return 0;
+	}
+
+	DEBUG_EP0("[%s] req.length = 0x%x, req.actual = 0x%x\n",
+		__func__, req->req.length, req->req.actual);
+#if 0
+
+	if (req->req.length - req->req.actual == ep->ep.maxpacket) 
+	{
+		/* Next write will end with the packet size, */
+		/* so we need Zero-length-packet */
+		need_zlp = 1;
+	}
+#endif	
+
+	ret = s3c_ep0_write_fifo(ep, req);
+
+	//if ((ret == 1) && !need_zlp) 
+	if (ret == 1) 
+	{
+		/* Last packet */
+		DEBUG_EP0("[%s] finished, waiting for status\n", __func__);
+		dev->ep0state = WAIT_FOR_SETUP;
+	} 
+	else 
+	{
+		DEBUG_EP0("[%s] not finished\n", __func__);
+		dev->ep0state = DATA_STATE_XMIT;
+	}
+#if 0
+	if (need_zlp) {
+		DEBUG_EP0("[%s] Need ZLP!\n", __func__);
+		dev->ep0state = DATA_STATE_NEED_ZLP;
+	}
+#endif	
+	return 1;
+}
+//---------------------------------------------------------------------------------------
+#define S3c_EP0_STALL	(-2)
+
+static int s3c_ep0_setup_handle_feature(struct s3c_udc *dev, struct usb_ctrlrequest ctrl_req)
+{
+	struct s3c_ep *ep;
+	u8 ep_num;
+	u32 uTemp ;
+
+	/* returning '-1' to delete gadget_setup */
+	/* returning S3c_EP0_STALL to make EP0 STALL state*/
+	if ((ctrl_req.bRequestType & USB_TYPE_MASK) != (USB_TYPE_STANDARD))
+	{
+		DEBUG_FEATURE("[%s] bRequestType != (USB_DIR_IN | USB_TYPE_STANDARD) : delegated !!!	\n",__func__);
+		return -1;
+	}
+	
+	if ((ctrl_req.bRequestType & USB_RECIP_MASK) != USB_RECIP_ENDPOINT 
+		&& (ctrl_req.bRequestType & USB_RECIP_MASK) != USB_RECIP_DEVICE )
+	{
+		DEBUG_FEATURE("[%s] bRequestType != USB_RECIP : delegated !!!  \n",__func__);
+		return -1;
+	}
+				
+	if (ctrl_req.bRequest == USB_REQ_CLEAR_FEATURE)
+		DEBUG_FEATURE("USB_REQ_CLEAR_FEATURE\n");
+	else
+		DEBUG_FEATURE("USB_REQ_SET_FEATURE\n");
+
+	if ((ctrl_req.bRequestType & USB_RECIP_MASK) == USB_RECIP_ENDPOINT )
+	{
+		DEBUG_FEATURE("\tUSB_RECIP_ENDPOINT\n");
+		ep_num = ctrl_req.wIndex & USB_ENDPOINT_NUMBER_MASK;	
+		ep = &dev->ep[ep_num];
+		
+		if (ctrl_req.wValue != 0 || ctrl_req.wLength != 0
+			|| ep_num > SUPPORTING_MAX_EP_NUM || ep_num < 1)
+		{
+			DEBUG_ERROR("[%s] ctrl_req.wValue != 0 || ctrl_req.wLength != 0 || not support ep_num[%d]  \n",__func__, ep_num);
+			return S3c_EP0_STALL;
+		}
+		//add ep descriptor for exit
+		
+		if (ctrl_req.wValue == USB_ENDPOINT_HALT) 
+		{
+			DEBUG_FEATURE("\tUSB_ENDPOINT_HALT\n");
+			/* USB_REQ_CLEAR_FEATURE */
+			if (ctrl_req.bRequest == USB_REQ_CLEAR_FEATURE)
+			{
+				if (ep_num == 0) 
+					s3c_ep0_set_stall(ep);
+				else
+				{
+					s3c_ep_clear_stall(ep);
+					s3c_ep_activate(ep);
+					ep->stopped = 0;						
+					clear_feature_num = ep_num;
+					clear_feature_flag = 1;
+				}	
+			}
+			/* USB_REQ_SET_FEATURE */
+			else
+			{
+				if (ep_num == 0) 
+					s3c_ep0_set_stall(ep);
+				else
+				{
+					//add deactivate
+					ep->stopped = 1;
+					s3c_ep_set_stall(ep);
+				}
+			}
+		}
+		else
+		{
+			DEBUG_ERROR("\tnot support wValue[%d]\n", ctrl_req.wValue);
+			return S3c_EP0_STALL;
+		}
+	}
+	else if((ctrl_req.bRequestType & USB_RECIP_MASK) == USB_RECIP_DEVICE )
+	{
+		DEBUG_FEATURE("\tUSB_RECIP_DEVICE\n");
+		switch (ctrl_req.wValue) 
+		{
+			case USB_DEVICE_REMOTE_WAKEUP:
+				DEBUG_FEATURE("\tUSB_DEVICE_REMOTE_WAKEUP\n");	
+				if (ctrl_req.bRequest == USB_REQ_CLEAR_FEATURE)
+					dev->devstatus &= ~(1 << USB_DEVICE_REMOTE_WAKEUP);
+				else
+					dev->devstatus |= 1 << USB_DEVICE_REMOTE_WAKEUP;
+				break;
+			
+			/* (wired high speed only) */
+			case USB_DEVICE_TEST_MODE:
+				/* USB_REQ_SET_FEATURE */
+				if (ctrl_req.bRequest != USB_REQ_CLEAR_FEATURE)
+				{
+					if((ctrl_req.wIndex&0xFF) != 0)
+					{
+						DEBUG_ERROR("\tThe lower byte of wIndex must be zero [wIndex = %d]\n", ctrl_req.wIndex);					
+						return S3c_EP0_STALL;
+						//return -1;
+					}
+					/*  
+					 * the "Status" phase of the control transfer
+					 * completes before transmitting the TEST packets. 
+					 */
+					s3c_ep_send_zlp(EP0_CON);
+					
+					uTemp = readl(S3C_UDC_OTG_DCTL);
+					uTemp &= ~(0x70);
+					switch (ctrl_req.wIndex >> 8) 
+					{
+						case 1: // TEST_J
+							DEBUG_FEATURE("\tTEST_J\n");
+							uTemp = (1<<4);
+							break;
+
+						case 2: // TEST_K	 
+							DEBUG_FEATURE("\tTEST_K\n");
+							uTemp = (2<<4);
+							break;
+
+						case 3: // TEST_SE0_NAK
+							DEBUG_FEATURE("\tTEST_SE0_NAK\n");
+							uTemp = (3<<4);
+							break;
+
+						case 4: // TEST_PACKET
+							DEBUG_FEATURE("\tTEST_PACKET\n");
+							uTemp = (4<<4);
+							break;
+
+						case 5: // TEST_FORCE_ENABLE
+							DEBUG_FEATURE("\tTEST_FORCE_ENABLE\n");
+							uTemp = (5<<4);
+							break;
+					}
+					writel(uTemp, S3C_UDC_OTG_DCTL);
+					return USB_DEVICE_TEST_MODE;
+				}
+				/* USB_REQ_CLEAR_FEATURE */
+				else 
+				{
+			/* Test_mode feature cannot be cleared by the ClearFeature() requested */
+					DEBUG_ERROR("\tTest_mode feature cannot be cleared by the ClearFeature()\n");
+					//might be stall
+					return S3c_EP0_STALL;
+//					return -1;
+				}
+				break;
+			
+			case USB_DEVICE_B_HNP_ENABLE:
+				DEBUG_FEATURE("\tNot yet Implemented : USB_DEVICE_B_HNP_ENABLE\n");
+				return S3c_EP0_STALL;
+				break;
+			
+			case USB_DEVICE_A_HNP_SUPPORT:
+				/* RH port supports HNP */
+				DEBUG_FEATURE("\tNot yet Implemented : USB_DEVICE_A_HNP_SUPPORT\n");
+				return S3c_EP0_STALL;
+				break;
+			
+			case USB_DEVICE_A_ALT_HNP_SUPPORT:
+				/* other RH port does */
+				DEBUG_FEATURE("\tNot yet Implemented : USB_DEVICE_A_ALT_HNP_SUPPORT\n");
+				return S3c_EP0_STALL;
+				break;
+			default:
+				DEBUG_ERROR("\tnot support wValue[0x%x]\n", ctrl_req.wValue);
+				return S3c_EP0_STALL;
+				break;
+		}// switch
+	}// if
+	else {		
+		DEBUG_ERROR("\t Must not come here !! \n");
+		return S3c_EP0_STALL;
+	}
+	return 0;
+}
+/*
+ * s3c_ep0_setup
+ * handle of setup transaction data during WAIT_FOR_SETUP 
+ */
+static void s3c_ep0_setup(struct s3c_udc *dev)
+{
+	struct s3c_ep *ep = &dev->ep[0];
+	int i= 0, is_in; 
+	int temp_ret;
+
+	/* Nuke all previous transfers */
+	s3c_ep_nuke(ep, -EPROTO);
+	
+	DEBUG_SETUP("Read CTRL REQ 8 bytes\n");
+	DEBUG_SETUP("  CTRL.bRequestType = 0x%x (direction %s)\n", g_ctrl.bRequestType,
+		    g_ctrl.bRequestType & USB_DIR_IN ? "IN" :"OUT");
+	DEBUG_SETUP("  CTRL.bRequest = 0x%x\n", g_ctrl.bRequest);
+	DEBUG_SETUP("  CTRL.wLength = 0x%x\n", g_ctrl.wLength);
+	DEBUG_SETUP("  CTRL.wValue = 0x%x (%d)\n", g_ctrl.wValue, g_ctrl.wValue >> 8);
+	DEBUG_SETUP("  CTRL.wIndex = 0x%x\n", g_ctrl.wIndex);
+
+	/* Set direction of EP0 */
+	if (likely(g_ctrl.bRequestType & USB_DIR_IN)) 
+	{
+		ep->bEndpointAddress |= USB_DIR_IN;
+		is_in = 1;
+	} 
+	else 
+	{
+		ep->bEndpointAddress &= ~USB_DIR_IN;
+		is_in = 0;
+	}
+	
+/*
+ *	the following is dedicated to class type request
+ *	should make some logic for req->length == 0 , status w/o data stage
+ */
+	// Confirm CLASS TYPE request
+	if ( (g_ctrl.bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS ) 
+	{ 
+		DEBUG_SETUP("CLASS Type request. ep->bEndpointAddress : 0x%02x\n", ep->bEndpointAddress);
+		 
+		switch(g_ctrl.bRequest)
+		{
+/* 
+ *	In case of serial class type such as g_serial, cdc, acm
+ *  in include/linux/usb/cdc.h
+ */
+#define USB_CDC_REQ_SET_LINE_CODING			0x20
+#define USB_CDC_REQ_GET_LINE_CODING			0x21
+#define USB_CDC_REQ_SET_CONTROL_LINE_STATE	0x22
+			case USB_CDC_REQ_SET_LINE_CODING :
+				DEBUG_SETUP("USB_CDC_REQ_SET_LINE_CODING\n");
+				//read more 7 bytes data
+				goto gadget_setup;
+			case USB_CDC_REQ_GET_LINE_CODING :
+				DEBUG_SETUP("USB_CDC_REQ_GET_LINE_CODING\n");
+				DEBUG_SETUP("modify USB_DIR_IN\n");
+				ep->bEndpointAddress |= USB_DIR_IN;
+				goto gadget_setup;
+			case USB_CDC_REQ_SET_CONTROL_LINE_STATE :				
+				DEBUG_SETUP("USB_CDC_REQ_SET_CONTROL_LINE_STATE\n");
+				DEBUG_SETUP("modify USB_DIR_IN\n");
+				ep->bEndpointAddress |= USB_DIR_IN;
+		//changing wIndex for Interface number
+		//ACM interface ID is 0
+				if(dev->config_gadget_driver == ANDROID_ADB_UMS_ACM &&
+					g_ctrl.wIndex != 0)
+				{			
+					DEBUG_ERROR("\n\n[%s] CHANGE g_ctrl.wIndex = 0x%x => 0\n\n",
+						__func__, g_ctrl.wIndex);
+					g_ctrl.wIndex = 0;
+				}
+				goto gadget_setup;
+/* for g_cdc */
+#define USB_CDC_SET_ETHERNET_PACKET_FILTER	0x43
+			case USB_CDC_SET_ETHERNET_PACKET_FILTER :				
+				DEBUG_SETUP("USB_CDC_SET_ETHERNET_PACKET_FILTER\n");
+				DEBUG_SETUP("modify USB_DIR_IN\n");
+				ep->bEndpointAddress |= USB_DIR_IN;
+				goto gadget_setup;
+		}
+	}
+
+	/* Handle some standard request SETUP packets to udc*/
+	switch (g_ctrl.bRequest) {
+		case USB_REQ_CLEAR_FEATURE:
+		case USB_REQ_SET_FEATURE:
+			temp_ret = s3c_ep0_setup_handle_feature(dev, g_ctrl);
+			if( temp_ret == USB_DEVICE_TEST_MODE)
+				return;
+			else if (temp_ret == -1)
+				goto gadget_setup;			
+			else if (temp_ret == S3c_EP0_STALL)
+				goto gadget_stall;
+			s3c_ep_send_zlp(EP0_CON);
+			return;
+
+		case USB_REQ_SET_ADDRESS:
+			if (g_ctrl.bRequestType != (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
+				break;
+			printk("[%s] USB_REQ_SET_ADDRESS (%d)\n", dev->driver->driver.name, g_ctrl.wValue);
+			s3c_udc_set_address(dev, g_ctrl.wValue);
+			s3c_ep_send_zlp(EP0_CON);
+			return;
+
+		case USB_REQ_SET_CONFIGURATION :
+			DEBUG_SETUP("[%s] USB_REQ_SET_CONFIGURATION (%d)\n",
+					__func__, g_ctrl.wValue);
+			/* gadget will queue zlp */
+			//CHECK modify direction
+			DEBUG_SETUP("modify USB_DIR_IN\n");
+			ep->bEndpointAddress |= USB_DIR_IN;
+		
+			/* g_ether's CDC config => 1, RNDIS => 2 */
+			if (strcmp(dev->driver->driver.name, "g_ether") == 0 )
+			{
+				switch(g_ctrl.wValue )
+				{
+					case 1:	//CDC
+						dev->config_gadget_driver = ETHER_CDC;
+						break;
+					case 2: //RNDIS
+						dev->config_gadget_driver = ETHER_RNDIS;
+						break;
+					default:
+						DEBUG_ERROR("[%s]not proper g_ctrl.wValue[%d]\n", __func__, g_ctrl.wValue );
+				}
+			}
+			dev->udc_state = USB_STATE_CONFIGURED;
+			s3c_udc_change_nextep(dev);
+
+			if (g_ctrl.wValue == 0) {	
+				/* prevent new request submissions, kill any outstanding requests  */
+				for (i = 0; i < S3C_MAX_ENDPOINTS; i++) 
+				{
+					ep = &dev->ep[i];
+					ep->stopped = 1;
+					s3c_ep_nuke(ep, -ESHUTDOWN);
+				}
+								
+				/* re-init driver-visible data structures */
+				s3c_ep_list_reinit(dev);		
+				zero_config_flag = 1;
+			}
+			
+			break;
+
+		case USB_REQ_GET_DESCRIPTOR:
+			DEBUG_SETUP("[%s] *** USB_REQ_GET_DESCRIPTOR  \n",__func__);
+			/*
+			 * it only happend at first time connection.
+			 * Host send a packet with wValue has 0x03EE
+			 * 03 is for String Type & EE is a String ID 
+			 * 0xEE is for Microsoft OS Descriptor.
+			 * if not support, response with STALL
+			 */
+			if (g_ctrl.wValue == 0x03ee) 
+			{
+				DEBUG_SETUP("[%s]Not support Microsoft OS String\n", __func__);
+				goto gadget_stall;
+			}
+			break;
+			
+		case USB_REQ_SET_INTERFACE:
+			//confirm USB_RECIP_INTERFACE?
+			if ((g_ctrl.bRequestType & USB_RECIP_MASK) != USB_RECIP_INTERFACE)
+				break;
+			DEBUG_SETUP("[%s] *** USB_REQ_SET_INTERFACE [wIndex = %d] <= wValue (%d)\n",
+				__func__, g_ctrl.wIndex, g_ctrl.wValue);	
+			/* gadget will queue zlp */
+			//CHECK modify direction
+			DEBUG_SETUP("modify USB_DIR_IN\n");
+			ep->bEndpointAddress |= USB_DIR_IN;
+	/* 
+	 * [SW Walk-around] Only for USBCV's MSC test scenario
+	 * USB_REQ_SET_INTERFACE of UMS miss INQUIRY after USB_REQ_SET_CONFIGURATION
+	 * if UMS already set by USB_REQ_SET_CONFIGURATION(1)
+	 * following zero configuration
+	 * USB_REQ_SET_INTERFACE return OK by sending zlp 
+	 * without real handling USB_REQ_SET_INTERFACE of UMS
+	 */
+			if(dev->config_gadget_driver == ANDROID_ADB_UMS_ACM &&
+				g_ctrl.wIndex == 2 && zero_config_flag == 1) {
+				DEBUG_ERROR("\n\n[%s] [SW Walk-around] USBCV's MSC test\n",__func__);
+				zero_config_flag = 0;
+				s3c_ep_send_zlp(EP0_CON);
+				return;
+			}
+			break;
+				
+		case USB_REQ_GET_CONFIGURATION:
+			DEBUG_SETUP("[%s] *** USB_REQ_GET_CONFIGURATION  \n",__func__);
+			break;
+
+		case USB_REQ_GET_STATUS:
+			DEBUG_SETUP("[%s] *** USB_REQ_GET_STATUS  \n",__func__);
+
+			if ((g_ctrl.bRequestType & (USB_DIR_IN | USB_TYPE_MASK))
+					!= (USB_DIR_IN | USB_TYPE_STANDARD))
+			{
+				DEBUG_SETUP("[%s] *** USB_REQ_GET_STATUS : delegated !!!  \n",__func__);
+					break;
+			}
+
+			if (!s3c_udc_get_status(dev, &g_ctrl)) 
+			{
+				return;
+			}
+			break;
+		case USB_REQ_SYNCH_FRAME:
+			DEBUG_SETUP("[%s] *** USB_REQ_SYNCH_FRAME  \n",__func__);
+			break;
+			
+		default:
+			DEBUG_SETUP("[%s] Default of g_ctrl.bRequest=0x%x happened.\n",
+					__func__, g_ctrl.bRequest);
+			break;
+	}// switch
+
+gadget_setup:
+	if (likely(dev->driver)) 
+	{
+		/* device-2-host (IN) or no data setup command,
+		 * process immediately */
+		spin_unlock(&dev->lock);
+		DEBUG_SETUP("[%s] usb_ctrlrequest will be passed to gadget's setup()\n", __func__);
+		i = dev->driver->setup(&dev->gadget, &g_ctrl);
+		spin_lock(&dev->lock);
+
+		if (i < 0) 
+		{
+gadget_stall:
+			/* setup processing failed, force stall */
+			DEBUG_ERROR("[%s] gadget setup FAILED (stalling EP 0), setup returned %d\n",
+				__func__, i);
+			s3c_ep0_set_stall(&dev->ep[0]);
+		}
+	}
+}
+//---------------------------------------------------------------------------------------
+
+/*
+ * s3c_handle_ep
+ * handling EP0's OUT Token for setup transaction of Control transfer 
+ */
+static void s3c_ep0_handle(struct s3c_udc *dev)
+{
+	if (dev->ep0state == WAIT_FOR_SETUP) 
+	{
+		DEBUG_EP0("[%s] WAIT_FOR_SETUP\n", __func__);
+		s3c_ep0_setup(dev);
+	} 
+	else 
+	{
+		DEBUG_EP0("[%s] strange state!!(state = %s)\n",
+			__func__, state_names[dev->ep0state]);
+	}
+}
+//---------------------------------------------------------------------------------------
+
diff -Nur linux-2.6.29/drivers/usb/gadget/s3c-udc-otg-hs_slave.c linux-2.6.29-spica/drivers/usb/gadget/s3c-udc-otg-hs_slave.c
--- linux-2.6.29/drivers/usb/gadget/s3c-udc-otg-hs_slave.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/s3c-udc-otg-hs_slave.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,1976 @@
+/*
+ * drivers/usb/gadget/s3c-udc-otg-hs_slave.c
+ * Samsung S3C on-chip full/high speed USB OTG 2.0 device controller slave mode
+ *
+ * Copyright (C) 2008 Samsung Electronics, Kyu-Hyeok Jang, Seung-Soo Yang
+ * Copyright (C) 2009 Samsung Electronics, Seung-Soo Yang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/*
+	in slave mode
+	ep0(out) & ep_out use INT_RX_FIFO_NOT_EMPTY
+	ep0(in) uses INT_NP_TX_FIFO_EMPTY
+	ep_in use INT_IN_EP
+*/
+
+/*
+#if SPIN_LOCK_IRQ_SAVE
+		spin_lock_irqsave();
+#else
+		local_irq_save();
+#endif
+*/
+#define SPIN_LOCK_IRQ_SAVE 		1
+
+//count of reading register error
+static	u32		ep_reg_err_cnt = 0;
+
+//status bit for each in_ep : 1 means req, 0 means no req
+static	u32		all_ep_req_status = 0;
+
+//confirm to need #ifdef
+//in include/linux/usb/cdc.h
+#define USB_CDC_REQ_SET_LINE_CODING		0x20
+#define USB_CDC_REQ_GET_LINE_CODING		0x21
+#define USB_CDC_REQ_SET_CONTROL_LINE_STATE	0x22
+
+void s3c_show_mode(void)
+{
+	printk("[S3C USB-OTG MODE] : Slave\n");
+}
+
+static void s3c_handle_data_phase(struct s3c_udc *dev)
+{
+	u32 gintmsk, ep_ctrl;
+	u8 	is_in;
+
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+
+	DEBUG_EP0("%s: ep direction is %s\n", __FUNCTION__, ep_is_in(&dev->ep[EP0_CON])?"IN":"OUT");
+	if(dev->ep0state == WAIT_FOR_SETUP)//USB_CDC_REQ_SET_CONTROL_LINE_STATE)
+	{
+		DEBUG_EP0("%s: dev->ep0state == WAIT_FOR_SETUP just return \n", __FUNCTION__);
+		return;
+	}
+	
+	if(dev->ep0state == USB_CDC_REQ_SET_LINE_CODING)//USB_CDC_REQ_SET_LINE_CODING)
+	{
+		DEBUG_EP0("%s: dev->ep0state == USB_CDC_REQ_SET_LINE_CODING just return \n", __FUNCTION__);
+		writel(gintmsk | INT_RX_FIFO_NOT_EMPTY, S3C_UDC_OTG_GINTMSK);
+		return;
+	}
+
+	if(dev->ep0state == FAIL_TO_SETUP)
+	{
+		DEBUG_EP0("%s: dev->ep0state == FAIL_TO_SETUP\n", __FUNCTION__);
+		return;
+	}
+	// enable TX irqu to write zeop length pactet
+	if(dev->ep0state == DATA_STATE_NEED_ZLP)
+	{
+		writel(gintmsk | INT_NP_TX_FIFO_EMPTY, S3C_UDC_OTG_GINTMSK);
+		
+		DEBUG_EP0("%s: DATA_STATE_NEED_ZLP\n", __FUNCTION__);
+		return;
+	}	
+
+	//set the state and enable irq regarding direction of ep
+//need to change is_in to dev->ep0state because s3c_ep3_kick already had state
+	is_in = ep_is_in(&dev->ep[EP0_CON]);
+	switch(is_in)
+	{
+		case 1:	 //EP_IN
+			dev->ep0state = DATA_STATE_XMIT;
+			
+			writel(gintmsk | INT_NP_TX_FIFO_EMPTY, S3C_UDC_OTG_GINTMSK);
+			break;
+		case 0: //EP_OUT
+			dev->ep0state = DATA_STATE_RECV;
+			writel(gintmsk | INT_RX_FIFO_NOT_EMPTY, S3C_UDC_OTG_GINTMSK);
+			
+			ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+			writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+			break;
+			
+		default:
+			DEBUG_EP0("%s: improper dev->ep0state = %d\n", __FUNCTION__, dev->ep0state);
+			break;
+	}
+}
+
+static void s3c_call_done(struct s3c_ep *ep)
+{
+	struct s3c_request *req;
+	
+	if (!list_empty(&ep->queue))
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+	else {
+		DEBUG("%s: NULL REQ on OUT EP-0\n", __FUNCTION__);	
+		BUG();	//logic ensures 	-jassi
+		return;
+	}
+	//0 : status of no error
+	done(ep, req, 0);
+}
+
+static void s3c_fifo_dump(u8 fifo_num, u16 length)
+{
+	u32 byte, fifo_address, i;
+	unsigned count;
+	
+	count = length / 4; // 4 bytes == 32 bits
+
+	fifo_address = (u32)S3C_UDC_OTG_EP0_FIFO + (fifo_num*4096); //4096 = 0x1000)
+	DEBUG("%s: fifo[%d] addr : 0x%x\n", __FUNCTION__, fifo_num, fifo_address);
+
+	for(i=0; i<=count; i++) {
+		byte = (u32) readl(fifo_address);
+		DEBUG("%s: [%d] => 0x%08x\n", __FUNCTION__, i, 
+			le32_to_cpu(get_unaligned((__le32 *)&byte)));		
+	}
+}
+
+//handle reading error of otg register 
+static void s3c_handle_reg_err(struct s3c_udc *dev)
+{
+	int ep0state;
+	u32 ep_ctrl;
+
+	s3c_fifo_dump(0, 8);
+
+	ep0state = dev->ep0state;
+	
+	if (ep0state == RegReadErr) {
+		DEBUG_EP0("%s: DATA_STATE_NEED_ZLP after Err reg\n", __FUNCTION__);
+		DEBUG_EP0("		=> Send ZLP [Status IN #0]\n");
+		s3c_send_zlp();
+		dev->ep0state = WAIT_FOR_SETUP;
+		
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+		writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+
+		s3c_call_done(&dev->ep[EP0_CON]);
+		return;		
+	}
+	else
+	{
+		DEBUG_EP0("%s: improper ep0state\n", __FUNCTION__);
+	}
+}
+
+static inline void s3c_send_zlp(void)
+{
+	u32 ep_ctrl, gintmsk;
+/* 	
+	Just to send ZLP(Zero length Packet) to HOST in response to SET CONFIGURATION
+	1. Program the DIEPTSIZn register with the transfer size and corresponding packet size
+	Packet count = 1, Xfersize = 0
+*/ 
+	DEBUG_EP0("%s\n",__FUNCTION__);
+
+	__raw_writel((1<<DEPTSIZ_PKT_CNT_BIT)| 0<<DEPTSIZ_XFER_SIZE_BIT, S3C_UDC_OTG_DIEPTSIZ0); 
+/*
+	2. Program the DIEPCTLn register with endpoint characteristics and set the CNAK and 
+	   Endpoint enable bits.
+*/
+	ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL0);
+	__raw_writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK|(EP0_CON<<DIEPCTL0_NEXT_EP_BIT), S3C_UDC_OTG_DIEPCTL0); 
+
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+	writel(gintmsk&(~(INT_NP_TX_FIFO_EMPTY)), S3C_UDC_OTG_GINTMSK);
+	
+	ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+	writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+//	udelay(20);
+}
+
+static int write_packet(struct s3c_ep *ep, struct s3c_request *req, int max)
+{
+	u32 *buf;
+	u32 in_ctrl, length, count;
+	u8	ep_num = ep_index(ep);
+	volatile u32 fifo = ep->fifo;
+	
+	buf = req->req.buf + req->req.actual;
+	prefetch(buf);
+
+	length = req->req.length - req->req.actual;
+	length = min(length, (u32)max);
+	req->req.actual += length;
+
+	DEBUG("%s: Write %d (max %d), fifo=0x%x\n",
+		__FUNCTION__, length, max, fifo);
+
+	if(ep_num  == EP0_CON) {
+		writel((1<<DEPTSIZ_PKT_CNT_BIT)|(length<<DEPTSIZ_XFER_SIZE_BIT), (u32) S3C_UDC_OTG_DIEPTSIZ0);
+
+		in_ctrl =  readl(S3C_UDC_OTG_DIEPCTL0);
+		writel(DEPCTL_EPENA|DEPCTL_CNAK|(EP0_CON<<DIEPCTL0_NEXT_EP_BIT)| in_ctrl, (u32) S3C_UDC_OTG_DIEPCTL0);
+
+		DEBUG_EP0("%s:(DIEPTSIZ0):0x%x, (DIEPCTL0):0x%x, (GNPTXSTS):0x%x\n", __FUNCTION__,
+			readl(S3C_UDC_OTG_DIEPTSIZ0),readl(S3C_UDC_OTG_DIEPCTL0),
+			readl(S3C_UDC_OTG_GNPTXSTS));
+
+	} else if ((ep_num  == EP2_IN)) {
+		writel((1<<DEPTSIZ_PKT_CNT_BIT)|(length<<DEPTSIZ_XFER_SIZE_BIT), S3C_UDC_OTG_DIEPTSIZ2);
+
+		in_ctrl =  readl(S3C_UDC_OTG_DIEPCTL2);
+		writel(DEPCTL_EPENA|DEPCTL_CNAK|(EP2_IN<<DIEPCTL0_NEXT_EP_BIT)| in_ctrl, (u32) S3C_UDC_OTG_DIEPCTL2);
+
+		DEBUG_EP2("%s:(DIEPTSIZ2):0x%x, (DIEPCTL2):0x%x, (GNPTXSTS):0x%x\n", __FUNCTION__,
+			readl(S3C_UDC_OTG_DIEPTSIZ2),readl(S3C_UDC_OTG_DIEPCTL2),
+			readl(S3C_UDC_OTG_GNPTXSTS));
+
+	} else if ((ep_num  == EP3_IN)) {
+		writel((1<<DEPTSIZ_PKT_CNT_BIT)|(length<<DEPTSIZ_XFER_SIZE_BIT), S3C_UDC_OTG_DIEPTSIZ3);
+
+		in_ctrl =  readl(S3C_UDC_OTG_DIEPCTL3);
+		writel(DEPCTL_EPENA|DEPCTL_CNAK| in_ctrl, (u32) S3C_UDC_OTG_DIEPCTL3);
+
+		DEBUG_EP2("%s:(DIEPTSIZ3):0x%x, (DIEPCTL3):0x%x, (GNPTXSTS):0x%x\n", __FUNCTION__,
+			readl(S3C_UDC_OTG_DIEPTSIZ3),readl(S3C_UDC_OTG_DIEPCTL3),
+			readl(S3C_UDC_OTG_GNPTXSTS));
+	} else {
+		printk("%s: --> Error Unused Endpoint!!\n",	__FUNCTION__);
+		BUG();
+	}
+
+	for (count=0;count<length;count+=4) {
+	  	writel(*buf++, fifo);
+	}
+	return length;
+}
+
+/** Write request to FIFO (max write == maxp size)
+ *  Return:  0 = still running, 1 = completed, negative = errno
+ */
+static int write_fifo(struct s3c_ep *ep, struct s3c_request *req)
+{
+
+	u32 max, gintmsk,daintmsk;
+	unsigned count;
+	int is_last = 0, is_short = 0;	
+	
+//	struct s3c_ep *ep2 = &ep->dev->ep[2];
+//	struct s3c_ep *ep3 = &ep->dev->ep[3];
+
+	u8	ep_num = ep_index(ep);
+		
+	DEBUG_IN_EP("%s\n",__FUNCTION__);
+
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+	daintmsk = readl(S3C_UDC_OTG_DAINTMSK);
+
+	max = le16_to_cpu(ep->desc->wMaxPacketSize);
+	count = write_packet(ep, req, max);
+
+	/* last packet is usually short (or a zlp) */
+	if (unlikely(count != max))
+		is_last = is_short = 1;
+	else {
+		if (likely(req->req.length != req->req.actual)
+		    || req->req.zero)
+			is_last = 0;
+		else
+			is_last = 1;
+		/* interrupt/iso maxpacket may not fill the fifo */
+		is_short = unlikely(max < ep_maxpacket(ep));
+	}
+
+		DEBUG_IN_EP("%s: wrote %s %d bytes%s%s req %p %d/%d\n",
+			__FUNCTION__,
+      			ep->ep.name, count,
+     	 		is_last ? "/L" : "", is_short ? "/S" : "",
+      			req, req->req.actual, req->req.length);
+
+	/* requests complete when all IN data is in the FIFO */
+	if (is_last) {
+		if(!ep_num){
+			printk("%s: --> Error EP0 must not come here!\n", __FUNCTION__);
+			BUG();
+		}
+		done(ep, req, 0);
+		//if ep->queue is empty mask that ep's irq
+		if (list_empty(&ep->queue))
+		{
+			writel(daintmsk&~(1<<ep_num), S3C_UDC_OTG_DAINTMSK);	
+			all_ep_req_status &= ~(1<<ep_num);
+		}
+		
+		//if all ep_in have no request, mask GINTMSK 		
+		//if (list_empty(&ep2->queue) && list_empty(&ep3->queue))
+		if(all_ep_req_status == 0)
+		{
+			writel(gintmsk&(~INT_IN_EP), S3C_UDC_OTG_GINTMSK);
+		}
+		return 1;
+	}
+	return 0;
+}
+
+/** Read to request from FIFO (max read == bytes in fifo)
+ *  Return:  0 = still running, 1 = completed, negative = errno
+ */
+static int read_fifo(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 csr, gintmsk, byte;
+	u32 *buf;
+	unsigned bufferspace, count, count_bytes, is_short = 0;
+	volatile u32 fifo = ep->fifo;
+
+	csr = readl(S3C_UDC_OTG_GRXSTSP);
+	count_bytes = (csr & 0x7ff0)>>4;
+
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+
+	if(!count_bytes) {
+		DEBUG_OUT_EP("%s: count_bytes %d bytes\n", __FUNCTION__, count_bytes);
+	}
+
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+	bufferspace = req->req.length - req->req.actual;
+
+	count = count_bytes / 4;
+	if(count_bytes%4) count = count + 1;
+
+	req->req.actual += min(count_bytes, bufferspace);
+
+	is_short = (count_bytes < ep->ep.maxpacket);
+	DEBUG_OUT_EP("%s: read %s, %d bytes%s req %p %d/%d GRXSTSP:0x%x\n",
+		__FUNCTION__,
+		ep->ep.name, count_bytes,
+		is_short ? "/S" : "", req, req->req.actual, req->req.length, csr);
+
+	while (likely(count-- != 0)) {
+		byte = (u32) readl(fifo);
+
+		if (unlikely(bufferspace == 0)) {
+			/* this happens when the driver's buffer
+		 	* is smaller than what the host sent.
+		 	* discard the extra data.
+		 	*/
+			if (req->req.status != -EOVERFLOW)
+				printk("%s overflow %d\n", ep->ep.name, count);
+			req->req.status = -EOVERFLOW;
+		} else {
+			*buf++ = byte;
+			bufferspace-=4;
+		}
+ 	 }
+
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+	writel(gintmsk | INT_RX_FIFO_NOT_EMPTY, S3C_UDC_OTG_GINTMSK);
+
+
+	/* completion */
+	if (is_short || req->req.actual == req->req.length) {
+		return 1;
+	}
+
+	/* finished that packet.  the next one may be waiting... */
+	return 0;
+}
+
+
+static void done(struct s3c_ep *ep, struct s3c_request *req, int status)
+{
+	unsigned int stopped = ep->stopped;
+
+	DEBUG("\t%s: %s %p, stopped = %d for req : %p\n", __FUNCTION__, ep->ep.name, ep, stopped, req);
+	list_del_init(&req->queue);
+
+	if (likely(req->req.status == -EINPROGRESS))
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	if (status && status != -ESHUTDOWN)
+		DEBUG("complete %s req %p stat %d len %u/%u\n",
+			ep->ep.name, &req->req, status,
+			req->req.actual, req->req.length);
+
+	/* don't modify queue heads during completion callback */
+	ep->stopped = 1;
+
+	spin_unlock(&ep->dev->lock);
+	req->req.complete(&ep->ep, &req->req);
+	spin_lock(&ep->dev->lock);
+
+	ep->stopped = stopped;
+
+	DEBUG("\t%s: %s %p, stopped = %d for req : %p after complete\n", __FUNCTION__, ep->ep.name, ep, stopped, req);
+}
+
+/*
+ * 	s3c_ep_nuke - dequeue ALL requests
+ */
+void s3c_ep_nuke(struct s3c_ep *ep, int status)
+{
+	struct s3c_request *req;
+
+	DEBUG("%s: %s %p\n", __FUNCTION__, ep->ep.name, ep);
+
+	/* called with irqs blocked */
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+		DEBUG("%s: req->req: %p, len %d buf %p\n",__FUNCTION__, req->req, req->req.length, req->req.buf);
+		done(ep, req, status);
+	}
+}
+
+/**
+ * s3c_in_epn - handle IN interrupt
+ */
+static void s3c_in_epn(struct s3c_udc *dev, u32 ep_idx)
+{
+	struct s3c_ep *ep = &dev->ep[ep_idx];
+	struct s3c_request *req;
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+
+	if (unlikely(!req)) {
+		DEBUG_IN_EP("%s: NULL REQ on IN EP-%d\n", __FUNCTION__, ep_idx);
+		return;
+	}
+	else {
+		DEBUG_IN_EP("%s: Write FIFO on IN EP-%d\n", __FUNCTION__, ep_idx);
+		write_fifo(ep, req);
+	}
+
+}
+
+/* ********************************************************************************************* */
+/* Bulk OUT (recv)
+ */
+
+static void s3c_out_epn(struct s3c_udc *dev, u32 ep_idx)
+{
+	struct s3c_ep *ep = &dev->ep[ep_idx];
+	struct s3c_request *req;
+	u32	ep_ctrl;
+	
+	if (unlikely(!(ep->desc))) {
+		/* Throw packet away.. */
+		DEBUG_OUT_EP("%s: No descriptor?!?\n", __FUNCTION__);
+		return;
+	}
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next,
+				struct s3c_request, queue);
+
+	if (unlikely(!req)) {
+		DEBUG_OUT_EP("%s: NULL REQ on OUT EP-%d\n", __FUNCTION__, ep_idx);
+		return;
+
+	} else {
+		read_fifo(ep, req);
+		
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL1);
+		writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL1);
+	}
+}
+
+static void s3c_udc_stop_activity(struct s3c_udc *dev,
+			  struct usb_gadget_driver *driver)
+{
+	int i;
+
+	/* don't disconnect drivers more than once */
+	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = 0;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	/* prevent new request submissions, kill any outstanding requests  */
+	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
+		struct s3c_ep *ep = &dev->ep[i];
+		ep->stopped = 1;
+		s3c_ep_nuke(ep, -ESHUTDOWN);
+	}
+
+	/* report disconnect; the driver is already quiesced */
+	if (driver) {
+		spin_unlock(&dev->lock);
+		driver->disconnect(&dev->gadget);
+		spin_lock(&dev->lock);
+	}
+
+	/* re-init driver-visible data structures */
+	udc_reinit(dev);
+}
+
+static void s3c_udc_initialize(void)
+{
+	// 2. Soft-reset OTG Core and then unreset again.
+	u32 uTemp = writel(CORE_SOFT_RESET, S3C_UDC_OTG_GRSTCTL);
+
+	writel(	0<<15		// PHY Low Power Clock sel
+		|1<<14		// Non-Periodic TxFIFO Rewind Enable
+		|0x5<<10	// Turnaround time
+		|0<<9|0<<8	// [0:HNP disable, 1:HNP enable][ 0:SRP disable, 1:SRP enable] H1= 1,1
+		|0<<7		// Ulpi DDR sel
+		|0<<6		// 0: high speed utmi+, 1: full speed serial
+		|0<<4		// 0: utmi+, 1:ulpi
+		|1<<3		// phy i/f  0:8bit, 1:16bit
+		|0x7<<0,	// HS/FS Timeout*
+		S3C_UDC_OTG_GUSBCFG);
+
+	udelay(20);
+
+	// 3. Put the OTG device core in the disconnected state.
+	uTemp = readl(S3C_UDC_OTG_DCTL);
+	uTemp |= SOFT_DISCONNECT;
+	writel(uTemp, S3C_UDC_OTG_DCTL);
+
+	udelay(20);
+
+	// 4. Make the OTG device core exit from the disconnected state.
+	uTemp = readl(S3C_UDC_OTG_DCTL);
+	uTemp = uTemp & ~SOFT_DISCONNECT;
+	writel(uTemp, S3C_UDC_OTG_DCTL);
+
+	// 5. Configure OTG Core to initial settings of device mode.
+	writel(1<<18|0x0<<0, S3C_UDC_OTG_DCFG);		// [][1: full speed(30Mhz) 0:high speed]
+
+	mdelay(1);
+
+	// 6. Unmask the core interrupts
+	writel(GINTMSK_INIT, S3C_UDC_OTG_GINTMSK);
+
+	// 7. Set NAK bit of EP0, EP1, EP2
+	writel(DEPCTL_EPDIS|DEPCTL_SNAK|(0<<0), S3C_UDC_OTG_DOEPCTL0); /* EP0: Control OUT */
+	writel(DEPCTL_EPDIS|DEPCTL_SNAK|(0<<0), S3C_UDC_OTG_DIEPCTL0); /* EP0: Control IN */
+
+	writel(DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE|(0<<0), S3C_UDC_OTG_DOEPCTL1); /* EP1:Data OUT */
+	writel(DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE|(0<<0), S3C_UDC_OTG_DIEPCTL2); /* EP2:Data IN */
+	writel(DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_INTR_TYPE|(0<<0), S3C_UDC_OTG_DIEPCTL3); /* EP3:IN Interrupt*/
+
+	/*
+		8. Unmask EP interrupts on IN EPs : 0, 2, 3
+	        	       		      OUT EPs : 0, 1    in case of rndis
+	    s3c_ep_queue unmask irq to reduce irq handling
+	*/
+/*
+	#if 0
+	writel( (((1<<EP1_OUT)|(1<<EP0_CON))<<16) |
+		(1<<EP3_IN)|(1<<EP2_IN)|(1<<EP0_CON),
+		S3C_UDC_OTG_DAINTMSK);
+	#else
+//	writel((1<<EP3_IN)|(1<<EP2_IN)|(1<<EP0_CON),S3C_UDC_OTG_DAINTMSK);
+	#endif
+*/
+
+	// 9. Unmask device OUT EP common interrupts
+	//OUT 1 using Rx_fifo int
+	writel(DOEPMSK_INIT, S3C_UDC_OTG_DOEPMSK);
+
+	// 10. Unmask device IN EP common interrupts
+	writel(DIEPMSK_INIT, S3C_UDC_OTG_DIEPMSK);
+
+	// 11. Set Rx FIFO Size
+	writel(RX_FIFO_SIZE, S3C_UDC_OTG_GRXFSIZ);
+
+	// 12. Set Non Periodic Tx FIFO Size
+	writel(NPTX_FIFO_SIZE<<16| NPTX_FIFO_START_ADDR<<0, S3C_UDC_OTG_GNPTXFSIZ);
+
+	// 13. Clear NAK bit of EP0, EP1, EP2
+	// For Slave mode
+	//for SETUP packet count
+	writel(DEPTSIZ_SETUP_PKCNT_3, (u32) S3C_UDC_OTG_DOEPTSIZ0);
+
+	writel(DEPCTL_EPDIS|DEPCTL_CNAK|(0<<0), S3C_UDC_OTG_DOEPCTL0); /* EP0: Control OUT */
+	writel(DEPCTL_EPDIS|DEPCTL_CNAK|(0<<0), S3C_UDC_OTG_DOEPCTL1); /* EP1: Bulk OUT */
+
+	writel(DEPCTL_EPDIS|DEPCTL_CNAK|DEPCTL_BULK_TYPE|(0<<0), S3C_UDC_OTG_DIEPCTL0); /* EP0: Control IN */
+	writel(DEPCTL_EPDIS|DEPCTL_CNAK|DEPCTL_BULK_TYPE|(0<<0), S3C_UDC_OTG_DIEPCTL2); /* EP2: Bulk IN */
+	writel(DEPCTL_EPDIS|DEPCTL_CNAK|DEPCTL_INTR_TYPE|(0<<0), S3C_UDC_OTG_DIEPCTL3); /* EP3: Intr IN */
+
+	// 14. Initialize OTG Link Core.
+	writel(GAHBCFG_INIT, S3C_UDC_OTG_GAHBCFG);
+	udelay(20);
+
+}
+
+void s3c_udc_set_max_pktsize(struct s3c_udc *dev, enum usb_device_speed speed)
+{
+	u32 ep_ctrl;
+
+	if (speed == USB_SPEED_HIGH) {
+		ep0_fifo_size = 64;
+		ep_fifo_size = 512;
+		ep_fifo_size2 = 1024;
+		dev->gadget.speed = USB_SPEED_HIGH;
+	} else {
+		ep0_fifo_size = 64;
+		ep_fifo_size = 64;
+		ep_fifo_size2 = 64;
+		dev->gadget.speed = USB_SPEED_FULL;
+	}
+
+	dev->ep[EP0_CON].ep.maxpacket = ep0_fifo_size;
+	dev->ep[1].ep.maxpacket = ep_fifo_size;
+	dev->ep[2].ep.maxpacket = ep_fifo_size;
+	dev->ep[3].ep.maxpacket = 16;
+	dev->ep[4].ep.maxpacket = ep_fifo_size;
+	dev->ep[5].ep.maxpacket = ep_fifo_size2;
+	dev->ep[6].ep.maxpacket = ep_fifo_size2;
+	dev->ep[7].ep.maxpacket = ep_fifo_size2;
+	dev->ep[8].ep.maxpacket = ep_fifo_size2;
+
+
+	if (speed == USB_SPEED_HIGH) {
+		// EP0 - Control IN (64 bytes)
+		ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL0);
+		writel(ep_ctrl|DEPCTL0_MPS_64, (u32) S3C_UDC_OTG_DIEPCTL0);
+
+		// EP0 - Control OUT (64 bytes)
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+		writel(ep_ctrl|DEPCTL0_MPS_64, (u32) S3C_UDC_OTG_DOEPCTL0);
+	} else {
+		// EP0 - Control IN (8 bytes)
+		ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL0);
+		writel(ep_ctrl|DEPCTL0_MPS_8, (u32) S3C_UDC_OTG_DIEPCTL0);
+
+		// EP0 - Control OUT (8 bytes)
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+		writel(ep_ctrl|DEPCTL0_MPS_8, (u32) S3C_UDC_OTG_DOEPCTL0);
+	}
+
+//ss1 : the following is replaced in s3c_ep_enable()
+/*
+	// EP1 - Bulk Data OUT (512 bytes)
+	ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL1);
+	writel(ep_ctrl|(ep_fifo_size<<0), (u32) S3C_UDC_OTG_DOEPCTL1);
+
+	// EP2 - Bulk Data IN (512 bytes)
+	ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL2);
+	writel(ep_ctrl|(ep_fifo_size<<0), (u32) S3C_UDC_OTG_DIEPCTL2);
+
+	// EP3 - INTR Data IN (512 bytes)
+	ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL3);
+	writel(ep_ctrl|(ep_fifo_size<<0), (u32) S3C_UDC_OTG_DIEPCTL3);
+*/
+}
+
+static int reset_available = 1;
+
+static irqreturn_t s3c_udc_irq(int irq, void *_dev)
+{
+	struct s3c_udc *dev = _dev;
+	u32 intr_status, dpid;
+	u32 usb_status, ep_ctrl, gintmsk;
+	unsigned long flags;
+	u32 diepint2, diepint3;
+	u32 grx_status;
+	u32 packet_status, ep_num, fifoCntByte = 0;
+	u32 daint, daintmsk, gnptxsts;
+	u32 nptxQ_SpcAvail, nptxFifo_SpcAvail;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	intr_status = readl(S3C_UDC_OTG_GINTSTS);
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+	intr_status &= gintmsk;
+
+	DEBUG_ISR("\n**** %s : GINTSTS=0x%x, GINTMSK : 0x%x\n",__FUNCTION__, intr_status, gintmsk);\
+	
+#if OTG_DBG_ENABLE
+//	udelay(20);
+#else
+//	udelay(100);
+#endif
+
+	if (intr_status & INT_RX_FIFO_NOT_EMPTY) {
+		// Mask USB OTG 2.0 interrupt source : INT_RX_FIFO_NOT_EMPTY
+	//	gintmsk &= ~INT_RX_FIFO_NOT_EMPTY;
+	//	writel(gintmsk, S3C_UDC_OTG_GINTMSK);
+
+		grx_status = readl(S3C_UDC_OTG_GRXSTSR);
+		packet_status = grx_status & 0x1E0000;
+		fifoCntByte = (grx_status & 0x7ff0)>>4;
+		ep_num = grx_status & EP_MASK;
+		dpid = (grx_status & (0x3<<15))>>15;
+		
+		DEBUG_ISR("\n%s : fifoCntByte = %d bytes\n", __FUNCTION__, fifoCntByte);
+		
+		if(dev->ep0state == RegReadErr)
+			goto REG_ERR_SETUP;
+
+		switch(packet_status)
+		{
+			case SETUP_PKT_RECEIVED:
+				DEBUG_ISR("    => SETUP_PKT_RECEIVED: %d bytes\n",	fifoCntByte);
+				if(fifoCntByte !=8 || ep_num != EP0_CON || dpid != 0)
+					DEBUG_ISR("    => improper	~~~~ fifoCntByte !=8 || ep_num != EP0_CON || dpid != 0 ~~~~: fifoCntByte != 0 ep:%d, dpid:%d\n", ep_num, dpid); 					
+				else
+					s3c_ep0_handle(dev);
+				break;
+				
+			case OUT_PKT_RECEIVED:
+				DEBUG_ISR("    => OUT_PKT_RECEIVED: %d bytes\n",	fifoCntByte);
+				if (ep_num == EP0_CON) 
+				{
+					ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+
+					if (fifoCntByte == 0) {
+						DEBUG_ISR(" 	 => An ZLP received (DOEPCTL0):0x%x\n", ep_ctrl);
+						
+						grx_status = readl(S3C_UDC_OTG_GRXSTSP);
+					}
+					else
+					{
+						DEBUG_ISR("    => A CONTROL OUT data packet received : %d bytes, (DOEPCTL0):0x%x\n",
+							fifoCntByte, ep_ctrl);
+						if (dev->ep0state != USB_CDC_REQ_SET_LINE_CODING)//USB_CDC_REQ_SET_LINE_CODING
+							dev->ep0state = DATA_STATE_RECV;
+						s3c_ep0_read(dev);
+					}
+					
+				} 
+				else if(ep_num == EP1_OUT) 
+				{
+					ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL1);
+					DEBUG_ISR(" 	 => A Bulk OUT data packet received : %d bytes, (DOEPCTL1):0x%x\n",
+						fifoCntByte, ep_ctrl);
+					s3c_out_epn(dev, 1);
+				} 
+				else 
+				{
+					DEBUG_ISR(" 	 => Unused EP: %d fifoCntByte %d bytes, (GRXSTSR):0x%x\n", ep_num, fifoCntByte, grx_status);
+					ep_reg_err_cnt++;
+					DEBUG_ISR(" 	===> ep_reg_err_cnt++ : %d\n", ep_reg_err_cnt);
+
+					ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+					writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+					DEBUG_ISR(" 	 =>=>=> DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0, (DOEPCTL0):0x%x\n", ep_ctrl);
+					grx_status = readl(S3C_UDC_OTG_GRXSTSP);
+				}
+				break;
+				
+			case SETUP_TRANSACTION_COMPLETED:
+				ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+				DEBUG_ISR("    => SETUP_STAGE_TRANSACTION_COMPLETED: %d bytes , (DOEPCTL0):0x%x\n", fifoCntByte, ep_ctrl);
+				if(fifoCntByte ==0 && ep_num == EP0_CON)
+				{
+					s3c_handle_data_phase(dev); 				
+					grx_status = readl(S3C_UDC_OTG_GRXSTSP);
+				}
+				else
+				{				
+					DEBUG_ISR("    => improper	~~~~: fifoCntByte !=0 || ep_num != EP0_CON ep:%d\n", ep_num);
+					goto REG_ERR;
+				}
+				
+				writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+				ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+				DEBUG_ISR("    => SETUP_STAGE_TRANSACTION_COMPLETED: %d bytes , (DOEPCTL0):0x%x\n", fifoCntByte, ep_ctrl);
+				break;
+				
+			case OUT_TRANSFER_COMPLELTED:
+				DEBUG_ISR("    => OUT_TRANSFER_COMPLELTED: %d bytes\n", fifoCntByte);
+				if(fifoCntByte !=0 || ep_num == EP2_IN || ep_num == EP3_IN)
+					DEBUG_ISR("    => improper	~~~~: fifoCntByte != 0\n");
+				else
+				{
+					DEBUG_ISR("    => INT_RX_FIFO_NOT_EMPTY enabled\n");
+					gintmsk |= INT_RX_FIFO_NOT_EMPTY;
+					writel(gintmsk, S3C_UDC_OTG_GINTMSK);
+
+					if (ep_num == EP1_OUT) {
+						ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL1);
+						DEBUG_ISR(" 	 => An OUT transaction completed %d bytes, (DOEPCTL1):0x%x\n", fifoCntByte, ep_ctrl);
+						writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL1);
+
+						s3c_call_done(&dev->ep[1]);
+						grx_status = readl(S3C_UDC_OTG_GRXSTSP);
+						
+					} else if (ep_num == EP0_CON) {
+						ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+						DEBUG_ISR(" 	 => An OUT transaction completed %d bytes, (DOEPCTL0):0x%x\n", fifoCntByte, ep_ctrl);
+
+						//control write status stage
+						if(dev->ep0state == DATA_STATE_NEED_ZLP)
+						{
+							writel(gintmsk | INT_NP_TX_FIFO_EMPTY, S3C_UDC_OTG_GINTMSK);							
+							DEBUG_EP0("%s: DATA_STATE_NEED_ZLP\n", __FUNCTION__);
+							s3c_call_done(&dev->ep[EP0_CON]);
+						}	
+						else if (dev->ep0state == USB_CDC_REQ_SET_LINE_CODING)
+						{
+							DEBUG_EP0("%s: dev->ep0state == USB_CDC_REQ_SET_LINE_CODING just go through \n", __FUNCTION__);
+							/*
+							writel(gintmsk | INT_NP_TX_FIFO_EMPTY, S3C_UDC_OTG_GINTMSK);							
+							dev->ep0state = DATA_STATE_NEED_ZLP;
+							*/
+						}
+						writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+						ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+						DEBUG_ISR(" 	 => An OUT transaction completed %d bytes, (DOEPCTL0):0x%x\n", fifoCntByte, ep_ctrl);
+
+						grx_status = readl(S3C_UDC_OTG_GRXSTSP);
+					} else {
+					
+						DEBUG_ISR(" 	 => Unused EP: %d fifoCntByte %d bytes, (GRXSTSR):0x%x\n", ep_num, fifoCntByte, grx_status);
+						ep_reg_err_cnt++;
+						DEBUG_ISR(" 	===> ep_reg_err_cnt++ : %d\n", ep_reg_err_cnt);
+						ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+
+						writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+						DEBUG_ISR(" 	 =>=>=> DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0, (DOEPCTL0):0x%x\n", ep_ctrl);
+						grx_status = readl(S3C_UDC_OTG_GRXSTSP);
+					}
+				}
+				break;
+				
+			case GLOBAL_OUT_NAK:				
+				DEBUG_ISR("    => GLOBAL_OUT_NAK~~~~: %d bytes\n",	fifoCntByte);
+				if(fifoCntByte != 0)
+					DEBUG_ISR("    => improper ~~~~ fifoCntByte != 0 \n");
+				
+				grx_status = readl(S3C_UDC_OTG_GRXSTSP);
+				break;
+				
+			default:
+				DEBUG_ISR(" 	 => EP : %d  Unknown Packet status received : %d bytes, packet_status:	0x%x\n",ep_num,  fifoCntByte, packet_status);
+				if (ep_num == 8 && fifoCntByte == 18) {
+REG_ERR_SETUP:		
+					DEBUG_ISR(" 	 => handling of reading register err [ep 8 & packet cnt = 18 bytes]");				
+					DEBUG_ISR(" 	 => consider setup packet \n");
+					DEBUG_ISR(" 	 => s3c_fifo_dump(0, 8) for reading 3 data from fifo 0\n");
+					s3c_handle_reg_err(dev);
+					break;
+				 }
+REG_ERR:					 
+				if (!list_empty(&(dev->ep[EP0_CON].queue)))
+				{
+					 DEBUG_ISR("	  => consider setup packet !list_empty(&(dev->ep[EP0_CON].queue)\n");
+					 dev->ep0state = RegReadErr;
+					 s3c_handle_reg_err(dev);
+				}
+				grx_status = readl(S3C_UDC_OTG_GRXSTSP);
+				break;
+		}//switch
+		
+		// Un/Mask USB OTG 2.0 interrupt sources
+		gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+		gintmsk |= INT_RX_FIFO_NOT_EMPTY;
+		writel(gintmsk, S3C_UDC_OTG_GINTMSK);
+		
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+		writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+		goto	OK_OUT;
+	}// INT_RX_FIFO_NOT_EMPTY
+
+	if (!intr_status) {
+		goto	OK_OUT;
+	}
+
+	if (intr_status & INT_ENUMDONE) {
+		DEBUG_SETUP("####################################\n");
+		DEBUG_SETUP("    %s: Speed Detection interrupt\n",
+				__FUNCTION__);
+		writel(INT_ENUMDONE, S3C_UDC_OTG_GINTSTS);
+
+		usb_status = (readl(S3C_UDC_OTG_DSTS) & 0x6);
+
+		if (usb_status & (USB_FULL_30_60MHZ | USB_FULL_48MHZ)) {
+			DEBUG_SETUP("    %s: Full Speed Detection\n",__FUNCTION__);
+			s3c_udc_set_max_pktsize(dev, USB_SPEED_FULL);
+
+		} else {
+			DEBUG_SETUP("    %s: High Speed Detection : 0x%x\n", __FUNCTION__, usb_status);
+			s3c_udc_set_max_pktsize(dev, USB_SPEED_HIGH);
+		}
+		goto	OK_OUT;
+	}
+
+	if (intr_status & INT_EARLY_SUSPEND) {
+		DEBUG_SETUP("####################################\n");
+		printk("    %s:Early suspend interrupt\n", __FUNCTION__);
+		writel(INT_EARLY_SUSPEND, S3C_UDC_OTG_GINTSTS);
+		goto	OK_OUT;
+	}
+
+	if (intr_status & INT_SUSPEND) {
+		usb_status = readl(S3C_UDC_OTG_DSTS);
+		DEBUG_SETUP("####################################\n");
+		printk("    %s:Suspend interrupt :(DSTS):0x%x\n", __FUNCTION__, usb_status);
+		writel(INT_SUSPEND, S3C_UDC_OTG_GINTSTS);
+
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+		    && dev->driver
+		    && dev->driver->suspend) {
+			dev->driver->suspend(&dev->gadget);
+		}
+		goto	OK_OUT;
+	}
+
+	if (intr_status & INT_RESUME) {
+		DEBUG_SETUP("####################################\n");
+		printk("    %s: Resume interrupt\n", __FUNCTION__);
+		writel(INT_RESUME, S3C_UDC_OTG_GINTSTS);
+
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+		    && dev->driver
+		    && dev->driver->resume) {
+			dev->driver->resume(&dev->gadget);
+		}
+		goto	OK_OUT;
+	}
+
+	if (intr_status & INT_RESET) {
+		usb_status = readl(S3C_UDC_OTG_GOTGCTL);
+		DEBUG_SETUP("####################################\n");
+		printk("    %s: Reset interrupt - (GOTGCTL):0x%x\n", __FUNCTION__, usb_status);
+		writel(INT_RESET, S3C_UDC_OTG_GINTSTS);
+
+		if((usb_status & 0xc0000) == (0x3 << 18)) {
+			if(reset_available) {
+				DEBUG_SETUP("     ===> OTG core got reset (%d)!! \n", reset_available);
+				s3c_udc_initialize();
+				dev->ep0state = WAIT_FOR_SETUP;
+				reset_available = 0;
+			}
+		} else {
+			reset_available = 1;
+			DEBUG_SETUP("      RESET handling skipped : reset_available : %d\n", reset_available);
+		}
+		goto	OK_OUT;
+	}
+
+	if (intr_status & (INT_NP_TX_FIFO_EMPTY)) {
+
+		daint = readl(S3C_UDC_OTG_DAINT);		
+		daintmsk = readl(S3C_UDC_OTG_DAINTMSK);
+		daint &= daintmsk;
+		
+		DEBUG_ISR("    INT_NP_TX_FIFO_EMPTY daintmsk=0x%x, daint=0x%x\n",daintmsk ,daint);
+
+		gnptxsts = readl(S3C_UDC_OTG_GNPTXSTS);
+		
+		nptxQ_SpcAvail = (gnptxsts & (0xff<<16))>>16;
+		nptxFifo_SpcAvail = gnptxsts & 0xffff;
+		
+		DEBUG_ISR("    GNPTXSTS nptxQ_SpcAvail = %d, nptxFifo_SpcAvail = %d\n",nptxQ_SpcAvail ,nptxFifo_SpcAvail);
+		if (nptxQ_SpcAvail == 0 || nptxFifo_SpcAvail == 0)
+		{
+			DEBUG_ISR("    improper ~~~~ nptxQ_SpcAvail == 0 || nptxFifo_SpcAvail == 0 \n");
+			goto FAIL_OUT;
+		}
+
+		//DATA_STATE_NEED_ZLP is for sending zlp without gadger driver's req queue
+		//zlp gadget driver requested will be send by s3c_ep0_write in case of ep0state is DATA_STATE_XMIT
+		if(dev->ep0state == DATA_STATE_NEED_ZLP ||
+			dev->ep0state == USB_CDC_REQ_SET_LINE_CODING) {
+			s3c_send_zlp();
+			dev->ep0state = WAIT_FOR_SETUP;
+			
+			ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+			writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+			
+		} else if(dev->ep0state == DATA_STATE_XMIT ||
+				  dev->ep0state == USB_CDC_REQ_SET_CONTROL_LINE_STATE) {
+			ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);					
+			s3c_ep0_write(dev);//it set ep0state wait_for_setup
+		} else {
+			DEBUG_ISR("		=> Unwanted IN_TKN in ep0state[%d]\n", dev->ep0state);
+		}
+		goto	OK_OUT;
+	}
+
+	if (intr_status & (INT_IN_EP)) {
+
+		daint = readl(S3C_UDC_OTG_DAINT);		
+		daintmsk = readl(S3C_UDC_OTG_DAINTMSK);
+		daint &= daintmsk;
+		
+		DEBUG_ISR("    INT_IN_EP daintmsk=0x%x, daint=0x%x\n",daintmsk ,daint);
+
+		gnptxsts = readl(S3C_UDC_OTG_GNPTXSTS);
+
+		nptxQ_SpcAvail = (gnptxsts & (0xff<<16))>>16;
+		nptxFifo_SpcAvail = gnptxsts & 0xffff;
+		
+		DEBUG_ISR("    GNPTXSTS nptxQ_SpcAvail = %d, nptxFifo_SpcAvail = %d\n",nptxQ_SpcAvail ,nptxFifo_SpcAvail);
+
+		if (nptxQ_SpcAvail == 0 || nptxFifo_SpcAvail == 0)
+		{
+			DEBUG_ISR("nptxQ_SpcAvail == 0 || nptxFifo_SpcAvail == 0 \n");
+			goto FAIL_OUT;
+		}
+
+		if(daint & (0x1<<EP2_IN)) {	//EP2_IN_INT
+		
+			DEBUG_ISR("      => INT_IN_EP 2\n");
+			diepint2 = readl(S3C_UDC_OTG_DIEPINT2);
+			if(diepint2 & (0x1<<4)) 
+			{	//IN_TKN_RECEIVED
+				DEBUG_ISR("      => IN_TKN_RECEIVED...EP2 (DIEPINT2):0x%x\n", diepint2);
+				s3c_in_epn(dev, EP2_IN);
+			}
+			if(diepint2 & (0x1<<3)) {	//TIMEOUT_CONDITION
+				writel((0x1<<8), S3C_UDC_OTG_DCTL);				
+			}
+			writel(diepint2, S3C_UDC_OTG_DIEPINT2);
+		}
+
+		if(daint & (0x1<<EP3_IN)) {	//EP3_IN_INT
+		
+			DEBUG_ISR("      => INT_IN_EP 3\n");
+			diepint3 = readl(S3C_UDC_OTG_DIEPINT3);
+			if(diepint3 & (0x1<<4)) 
+			{	//IN_TKN_RECEIVED
+				DEBUG_ISR("      => IN_TKN_RECEIVED...EP3(DIEPINT3):0x%x\n", diepint3);
+				s3c_in_epn(dev, EP3_IN);
+			}			
+			if(diepint3 & (0x1<<3)) {	//TIMEOUT_CONDITION
+				writel((0x1<<8), S3C_UDC_OTG_DCTL);				
+			}
+			writel(diepint3, S3C_UDC_OTG_DIEPINT3);
+		}
+		goto	OK_OUT;
+	}
+	
+
+	
+OK_OUT:
+	
+#if SPIN_LOCK_IRQ_SAVE
+	spin_unlock_irqrestore(&dev->lock, flags);
+#else
+	local_irq_restore(flags);
+#endif
+
+	return IRQ_HANDLED;
+
+FAIL_OUT:
+	
+#if SPIN_LOCK_IRQ_SAVE
+	spin_unlock_irqrestore(&dev->lock, flags);
+#else
+	local_irq_restore(flags);
+#endif
+
+	return IRQ_NONE;
+}
+
+static int s3c_ep_enable(struct usb_ep *_ep,
+			     const struct usb_endpoint_descriptor *desc)
+{
+	struct s3c_ep *ep;
+	struct s3c_udc *dev;
+	unsigned long flags;
+	u32 daintmsk;
+
+	DEBUG("%s: %p\n", __FUNCTION__, _ep);
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep || !desc || ep->desc || _ep->name == ep0name
+	    || desc->bDescriptorType != USB_DT_ENDPOINT
+	    || ep->bEndpointAddress != desc->bEndpointAddress
+	    || ep_maxpacket(ep) < le16_to_cpu(desc->wMaxPacketSize)) {
+		DEBUG("%s: bad ep or descriptor\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* xfer types must match, except that interrupt ~= bulk */
+	if (ep->bmAttributes != desc->bmAttributes
+	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
+	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {
+		DEBUG("%s: %s type mismatch\n", __FUNCTION__, _ep->name);
+		return -EINVAL;
+	}
+
+	/* hardware _could_ do smaller, but driver doesn't */
+	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
+	     && le16_to_cpu(desc->wMaxPacketSize) != ep_maxpacket(ep))
+	    || !desc->wMaxPacketSize) {
+		DEBUG("%s: bad %s maxpacket\n", __FUNCTION__, _ep->name);
+		return -ERANGE;
+	}
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		DEBUG("%s: bogus device state\n", __FUNCTION__);
+		return -ESHUTDOWN;
+	}
+
+	
+#if SPIN_LOCK_IRQ_SAVE
+	spin_lock_irqsave(&dev->lock, flags);
+#else
+	local_irq_save(flags);
+#endif
+
+	ep->stopped = 0;
+	ep->desc = desc;
+	ep->ep.maxpacket = le16_to_cpu(desc->wMaxPacketSize);
+
+	/* Reset halt state */
+	s3c_set_halt(_ep, 0);
+
+//by ss1 the follwoing setting is specific with RNDIS of s3c6410
+	daintmsk = readl(S3C_UDC_OTG_DAINTMSK);
+
+	switch(ep_index(ep))
+	{
+		//spec. say: mps, USB active endpoing, start data toggle, type,
+
+		case EP1_OUT :			
+			/* EP1: Bulk OUT */
+			writel(DEPCTL_MPS_BULK_512|DEPCTL_USBACTEP|DEPCTL_BULK_TYPE
+				, S3C_UDC_OTG_DOEPCTL1); 
+			break;
+			
+		case EP2_IN	 :			
+			/* EP2: Bulk IN */
+			writel(DEPCTL_MPS_BULK_512|DEPCTL_USBACTEP|DEPCTL_BULK_TYPE
+				, S3C_UDC_OTG_DIEPCTL2); 
+			break;
+			
+		case EP3_IN	 :			
+			/* EP3: INTR IN */
+			writel(DEPCTL_MPS_INT_MPS_16|DEPCTL_USBACTEP|DEPCTL_INTR_TYPE
+				, S3C_UDC_OTG_DIEPCTL3); 
+			break;
+			
+		default :
+			printk("%s: not supported ep %d\n",__FUNCTION__, ep_index(ep));			
+	}
+
+#if SPIN_LOCK_IRQ_SAVE
+	spin_unlock_irqrestore(&dev->lock, flags);
+#else
+	local_irq_restore(flags);
+#endif
+
+	DEBUG("%s: enabled %s, stopped = %d, maxpacket = %d\n",
+		__FUNCTION__, _ep->name, ep->stopped, ep->ep.maxpacket);
+	return 0;
+}
+
+/** Disable EP
+ */
+static int s3c_ep_disable(struct usb_ep *_ep)
+{
+	struct s3c_ep *ep;
+	unsigned long flags;
+	u32 daintmsk;
+	u32 ep_ctrl;
+
+	DEBUG("%s: %p\n", __FUNCTION__, _ep);
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep || !ep->desc) {
+		DEBUG("%s: %s not enabled\n", __FUNCTION__,
+		      _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+#if SPIN_LOCK_IRQ_SAVE
+	spin_lock_irqsave(&ep->dev->lock, flags);
+#else
+	local_irq_save(flags);
+#endif
+
+	/* Nuke all pending requests */
+	s3c_ep_nuke(ep, -ESHUTDOWN);
+
+	ep->desc = 0;
+	ep->stopped = 1;
+	
+	daintmsk = readl(S3C_UDC_OTG_DAINTMSK);
+
+	switch(ep_index(ep))
+	{
+	//mps, USB active endpoing, start data toggle, type, TxFifo for int
+		case EP1_OUT :			
+			/* EP1: Bulk OUT */			
+			ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL1);
+			writel(ep_ctrl&~(DEPCTL_USBACTEP), S3C_UDC_OTG_DOEPCTL1); 
+			writel(daintmsk&(~(1<<(ep_index(ep)+16))), S3C_UDC_OTG_DAINTMSK);
+			break;
+			
+		case EP2_IN	 :			
+			/* EP2: Bulk IN */
+			ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL2);
+			writel(ep_ctrl&~(DEPCTL_USBACTEP), S3C_UDC_OTG_DIEPCTL2); 
+			writel(daintmsk&(~(1<<ep_index(ep))), S3C_UDC_OTG_DAINTMSK);
+			break;
+			
+		case EP3_IN	 :			
+			/* EP3: INTR IN */
+			ep_ctrl = readl(S3C_UDC_OTG_DIEPCTL3);
+			writel(ep_ctrl&~(DEPCTL_USBACTEP), S3C_UDC_OTG_DIEPCTL3);
+			writel(daintmsk&(~(1<<ep_index(ep))), S3C_UDC_OTG_DAINTMSK);
+			break;
+			
+		default :
+			DEBUG("%s: not supported ep %d\n",__FUNCTION__);			
+	}
+
+#if SPIN_LOCK_IRQ_SAVE
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+#else
+	local_irq_restore(flags);
+#endif
+
+	DEBUG("%s: disabled %s\n", __FUNCTION__, _ep->name);
+	return 0;
+}
+
+static struct usb_request *s3c_ep_alloc_request(struct usb_ep *ep,
+						 gfp_t gfp_flags)
+{
+	struct s3c_request *req;
+
+	DEBUG("%s: %s %p\n", __FUNCTION__, ep->name, ep);
+
+	req = kmalloc(sizeof(struct s3c_request), gfp_flags);
+	if (!req) {
+		DEBUG("%s: kmalloc failed!!!\n", __FUNCTION__);
+		return 0;
+	}
+	memset(req, 0, sizeof(struct s3c_request));
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void s3c_ep_free_request(struct usb_ep *ep, struct usb_request *_req)
+{
+	struct s3c_request *req;
+
+	DEBUG("%s: %p\n", __FUNCTION__, ep);
+
+	req = container_of(_req, struct s3c_request, req);
+	WARN_ON(!list_empty(&req->queue));
+	kfree(req);
+}
+
+/** Queue one request
+ *  Kickstart transfer if needed
+ */
+static int s3c_ep_queue(struct usb_ep *_ep, struct usb_request *_req,
+			 gfp_t gfp_flags)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep;
+	struct s3c_udc *dev;
+	unsigned long flags;
+	u32 gintmsk, daintmsk;
+	u32 csr;
+	u8 is_in, ep_num;
+
+	req = container_of(_req, struct s3c_request, req);
+
+	if (unlikely(!_req || !_req->complete || !_req->buf
+			|| !list_empty(&req->queue)))
+	{
+		DEBUG("%s: bad params\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		DEBUG("%s: bad ep\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	dev = ep->dev;
+	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
+		DEBUG("%s: bogus device state %p\n", __FUNCTION__, dev->driver);
+		return -ESHUTDOWN;
+	}
+
+#if SPIN_LOCK_IRQ_SAVE
+	spin_lock_irqsave(&dev->lock, flags);
+#else
+	local_irq_save (flags);
+#endif
+
+	DEBUG_KEVIN("\n%s: %s queue req %p, len %d buf %p\n",
+		__FUNCTION__, _ep->name, _req, _req->length, _req->buf);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	/* kickstart this i/o queue? */
+	DEBUG("%s: Add to ep=%d, Q empty=%d, stopped=%d\n",
+		__FUNCTION__, ep_index(ep), list_empty(&ep->queue), ep->stopped);
+	
+	is_in = ep_is_in(ep);
+	ep_num = ep_index(ep);
+	
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+	daintmsk = readl(S3C_UDC_OTG_DAINTMSK);
+
+	if (list_empty(&ep->queue) && likely(!ep->stopped)) {
+			
+		if (ep_num == 0) {
+			list_add_tail(&req->queue, &ep->queue);
+			s3c_ep0_kick(dev, ep);
+			req = 0;
+		} 
+		else if (is_in) {			
+			all_ep_req_status |= (1 << ep_num);
+			
+			csr = readl((u32) S3C_UDC_OTG_GINTSTS);
+			DEBUG("%s: ep_is_in, S3C_UDC_OTG_GINTSTS=0x%x\n",
+				__FUNCTION__, csr);
+			
+			list_add_tail(&req->queue, &ep->queue);
+			req = 0;
+#if 0		//for rndis specific logic that works
+			if (ep_num == EP2_IN) {
+				writel(gintmsk | INT_IN_EP, S3C_UDC_OTG_GINTMSK);
+				writel(daintmsk|(1<<ep_num), S3C_UDC_OTG_DAINTMSK);				
+			} else if (ep_num == EP3_IN) {		
+				writel(gintmsk | INT_IN_EP, S3C_UDC_OTG_GINTMSK);
+				writel(daintmsk|(1<<ep_num), S3C_UDC_OTG_DAINTMSK);
+			} else 
+				DEBUG_ISR(">>>>>>>>>  not proper EP num %d\n", ep_index(ep));	
+#else
+			writel(gintmsk | INT_IN_EP, S3C_UDC_OTG_GINTMSK);
+			writel(daintmsk|(1<<ep_num), S3C_UDC_OTG_DAINTMSK); 			
+#endif
+		} // for IN
+		//for OUT
+		else {
+			list_add_tail(&req->queue, &ep->queue);
+			req = 0;
+		}// for OUT
+	}// for empty
+	else
+	{
+		if (ep_num != 0 && is_in) {
+			
+			all_ep_req_status |= (1 << ep_num);
+
+			csr = readl((u32) S3C_UDC_OTG_GINTSTS);
+			DEBUG("%s: ep_is_in, S3C_UDC_OTG_GINTSTS=0x%x\n",
+				__FUNCTION__, csr);
+			
+			list_add_tail(&req->queue, &ep->queue);
+			req = 0;
+
+			if (ep_num == EP2_IN) {
+
+				writel(gintmsk | INT_IN_EP, S3C_UDC_OTG_GINTMSK);
+				writel(daintmsk|(1<<ep_num), S3C_UDC_OTG_DAINTMSK);
+			} else if (ep_index(ep) == EP3_IN) {
+		
+				writel(gintmsk | INT_IN_EP, S3C_UDC_OTG_GINTMSK);
+				writel(daintmsk|(1<<ep_num), S3C_UDC_OTG_DAINTMSK);
+
+			} else 
+				DEBUG_ISR(">>>>>>>>>  not proper EP num %d\n", ep_index(ep));			
+		} // for IN
+	}
+
+	/* pio or dma irq handler advances the queue. */
+	if (likely(req != 0))
+		list_add_tail(&req->queue, &ep->queue);
+
+#if SPIN_LOCK_IRQ_SAVE
+	spin_unlock_irqrestore(&dev->lock, flags);
+#else
+	local_irq_restore(flags);
+#endif
+
+	return 0;
+}
+
+/* dequeue JUST ONE request */
+static int s3c_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct s3c_ep *ep;
+	struct s3c_request *req;
+	unsigned long flags;
+
+	DEBUG("%s: %p\n", __FUNCTION__, _ep);
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep || ep->ep.name == ep0name)
+		return -EINVAL;
+
+#if SPIN_LOCK_IRQ_SAVE
+	spin_lock_irqsave(&ep->dev->lock, flags);
+#else
+	local_irq_save (flags);
+#endif
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		local_irq_restore(flags);
+		return -EINVAL;
+	}
+	done(ep, req, -ECONNRESET);
+
+#if SPIN_LOCK_IRQ_SAVE
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+#else
+	local_irq_restore(flags);
+#endif
+	return 0;
+}
+
+/** Halt specific EP
+ *  Return 0 if success
+ */
+static int s3c_set_halt(struct usb_ep *_ep, int value)
+{
+	return 0;
+}
+
+/** Return bytes in EP FIFO
+ */
+static int s3c_fifo_status(struct usb_ep *_ep)
+{
+	int count = 0;
+	struct s3c_ep *ep;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep) {
+		DEBUG("%s: bad ep\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	DEBUG("%s: %d\n", __FUNCTION__, ep_index(ep));
+
+	/* LPD can't report unclaimed bytes from IN fifos */
+	if (ep_is_in(ep))
+		return -EOPNOTSUPP;
+
+	return count;
+}
+
+/** Flush EP FIFO
+ */
+static void s3c_fifo_flush(struct usb_ep *_ep)
+{
+	struct s3c_ep *ep;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		DEBUG("%s: bad ep\n", __FUNCTION__);
+		return;
+	}
+
+	DEBUG("%s: %d\n", __FUNCTION__, ep_index(ep));
+}
+
+/****************************************************************/
+/* End Point 0 related functions                                */
+/****************************************************************/
+
+/* return:  0 = still running, 1 = completed, negative = errno */
+static int s3c_ep0_write_fifo(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 max;
+	unsigned count;
+	int is_last;
+	u32 gintmsk, daintmsk;
+
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+	daintmsk = readl(S3C_UDC_OTG_DAINTMSK);
+
+	max = ep_maxpacket(ep);
+
+	DEBUG_EP0("%s: max = %d\n", __FUNCTION__, max);
+
+	count = write_packet(ep, req, max);
+
+	/* last packet is usually short (or a zlp) */
+	if (likely(count != max))
+		is_last = 1;
+	else {
+		if (likely(req->req.length != req->req.actual) || req->req.zero)
+			is_last = 0;
+		else
+			is_last = 1;
+	}
+
+	DEBUG_EP0("%s: wrote %s %d bytes%s %d left %p\n", __FUNCTION__,
+		  ep->ep.name, count,
+		  is_last ? "/L" : "", req->req.length - req->req.actual, req);
+
+	/* requests complete when all IN data is in the FIFO */
+	if (is_last) {
+		done(ep, req, 0);
+		writel(gintmsk&(~(INT_NP_TX_FIFO_EMPTY)), S3C_UDC_OTG_GINTMSK);
+		return 1;
+	}
+
+	writel(gintmsk |INT_NP_TX_FIFO_EMPTY, S3C_UDC_OTG_GINTMSK);
+	return 0;
+
+}
+
+static __inline__ int s3c_fifo_read(struct s3c_ep *ep, u32 *cp, int max)
+{
+	int bytes;
+
+	int count;
+	u32 grx_status = readl(S3C_UDC_OTG_GRXSTSP);
+	bytes = (grx_status & 0x7ff0)>>4;
+
+	DEBUG_EP0("%s: GRXSTSP=0x%x, bytes=%d, ep_index=%d, fifo=0x%x\n",
+			__FUNCTION__, grx_status, bytes, ep_index(ep), ep->fifo);
+
+	// 32 bits interface
+	count = bytes / 4;
+
+	while (count--) {
+		*cp++ = (u32) readl(S3C_UDC_OTG_EP0_FIFO);
+	}
+	return bytes;
+}
+
+static int read_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 csr;
+	u32 *buf;
+	unsigned bufferspace, count, is_short, bytes;
+	volatile u32 fifo = ep->fifo;
+
+	DEBUG_EP0("%s\n", __FUNCTION__);
+
+	csr = readl(S3C_UDC_OTG_GRXSTSP);
+	bytes = (csr & 0x7ff0)>>4;
+
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+	bufferspace = req->req.length - req->req.actual;
+
+	/* read all bytes from this packet */
+	if (likely((csr & EP_MASK) == EP0_CON)) {
+		count = bytes / 4;
+		req->req.actual += min(bytes, bufferspace);
+
+	} else	{		// zlp
+		count = 0;
+		bytes = 0;
+	}
+
+	is_short = (bytes < ep->ep.maxpacket);
+	DEBUG_KEVIN("%s: read %s %02x, %d bytes%s req %p %d/%d\n",
+		  __FUNCTION__,
+		  ep->ep.name, csr, bytes,
+		  is_short ? "/S" : "", req, req->req.actual, req->req.length);
+
+	while (likely(count-- != 0)) {
+		u32 byte = (u32) readl(fifo);
+
+		if (unlikely(bufferspace == 0)) {
+			/* this happens when the driver's buffer
+			 * is smaller than what the host sent.
+			 * discard the extra data.
+			 */
+			if (req->req.status != -EOVERFLOW)
+				DEBUG_EP0("%s overflow %d\n", ep->ep.name,
+					  count);
+			req->req.status = -EOVERFLOW;
+		} else {
+			*buf++ = byte;
+			bufferspace = bufferspace - 4;
+		}
+	}
+
+	/* completion */
+	if (is_short || req->req.actual == req->req.length) {
+		return 1;
+	}
+	DEBUG_EP0("%s is not last\n", __FUNCTION__);
+
+	return 0;
+}
+
+/**
+ * s3c_udc_set_address - set the USB address for this device
+ * @address:
+ *
+ * Called from control endpoint function
+ * after it decodes a set address setup packet.
+ */
+static void s3c_udc_set_address(struct s3c_udc *dev, unsigned char address)
+{
+	u32 tmp = readl(S3C_UDC_OTG_DCFG);
+	writel(address << 4 | tmp, S3C_UDC_OTG_DCFG);
+
+// send ZLP : the following logic was replaced in s3c_ep0_setup
+//	tmp = readl(S3C_UDC_OTG_DIEPCTL0);
+//	writel(DEPCTL_EPENA|DEPCTL_CNAK|tmp, S3C_UDC_OTG_DIEPCTL0); /* EP0: Control IN */
+
+	DEBUG_EP0("%s: USB OTG 2.0 Device address=%d, DCFG=0x%x\n",
+		__FUNCTION__, address, readl(S3C_UDC_OTG_DCFG));
+
+	dev->usb_address = address;
+}
+
+static void s3c_ep0_read(struct s3c_udc *dev)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep = &dev->ep[EP0_CON];
+	int ret, is_last = 0;
+	u32 gintmsk;
+	u32 ep_ctrl;
+	
+	DEBUG_EP0("%s: ep0 read\n", __FUNCTION__);
+	
+	if (!list_empty(&ep->queue))
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+	else {
+		DEBUG("%s: NULL REQ on OUT EP-0\n", __FUNCTION__);	
+		return;
+	}
+
+	DEBUG_EP0("%s: req.length = 0x%x, req.actual = 0x%x\n",
+		__FUNCTION__, req->req.length, req->req.actual);
+
+	if(req->req.length == 0) {
+		
+		DEBUG_EP0(" improper req->req.length == 0n");
+		dev->ep0state = WAIT_FOR_SETUP;
+		is_last = 1;
+		done(ep, req, 0);
+		return;
+	}
+
+	ret = read_fifo_ep0(ep, req);
+	//ret 0: not last, 1: last packet
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+	writel(gintmsk | INT_RX_FIFO_NOT_EMPTY, S3C_UDC_OTG_GINTMSK);
+
+	if (ret) {
+		DEBUG_KEVIN("%s : ret = %d : last packet~~~\n", __FUNCTION__, ret);
+		if (dev->ep0state == USB_CDC_REQ_SET_LINE_CODING)
+		{
+			DEBUG_EP0("%s: dev->ep0state == USB_CDC_REQ_SET_LINE_CODING\n", __FUNCTION__);
+			done(ep, req, 0);
+			writel(gintmsk | INT_NP_TX_FIFO_EMPTY, S3C_UDC_OTG_GINTMSK);
+			return;
+		}
+		
+		dev->ep0state = DATA_STATE_NEED_ZLP;
+	//	s3c_send_zlp(); irq will call s3c_send_zlp()
+		if (req->req.length == 34)
+			dev->ep0state = RegReadErr;	
+
+		is_last = 1;
+		return;
+	}
+	else
+	{
+		DEBUG_EP0("%s : ret = %d : not last packet~~~\n", __FUNCTION__, ret);				
+		
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+		writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+	}
+	return;
+
+}
+
+/*
+ * DATA_STATE_XMIT
+ */
+static int s3c_ep0_write(struct s3c_udc *dev)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep = &dev->ep[EP0_CON];
+	int ret, need_zlp = 0;
+	u32 ep_ctrl, gintmsk;
+
+	DEBUG_EP0("%s: ep0 write\n", __FUNCTION__);
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+
+	if (!req) {
+		DEBUG_EP0("%s: NULL REQ\n", __FUNCTION__);
+		return 0;
+	}
+
+	DEBUG_EP0("%s: req.length = 0x%x, req.actual = 0x%x\n",
+		__FUNCTION__, req->req.length, req->req.actual);
+
+	if (req->req.length == 0) {
+		DEBUG_EP0("%s: req->req.length == 0\n", __FUNCTION__);
+
+		s3c_send_zlp();
+	   	done(ep, req, 0);		
+		dev->ep0state = WAIT_FOR_SETUP;				
+
+		gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+		writel(gintmsk&(~(INT_NP_TX_FIFO_EMPTY)), S3C_UDC_OTG_GINTMSK);
+
+		return 1;
+	}
+
+	if (req->req.length - req->req.actual == ep0_fifo_size) {
+		/* Next write will end with the packet size, */
+		/* so we need Zero-length-packet */
+		need_zlp = 1;
+	}
+
+	ret = s3c_ep0_write_fifo(ep, req);
+
+	if ((ret == 1) && !need_zlp) {
+		/* Last packet */
+		DEBUG_KEVIN("%s: finished, waiting for status\n", __FUNCTION__);
+		dev->ep0state = WAIT_FOR_SETUP;
+
+		//writel((readl(S3C_UDC_OTG_GINTMSK) & ~INT_NP_TX_FIFO_EMPTY), S3C_UDC_OTG_GINTMSK);
+	} else {
+		DEBUG_EP0("%s: not finished\n", __FUNCTION__);
+	}
+
+	if (need_zlp) {
+		DEBUG_EP0("%s: Need ZLP!\n", __FUNCTION__);
+		dev->ep0state = DATA_STATE_NEED_ZLP;
+	}
+
+	ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+	writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+
+	return 1;
+}
+
+/*
+ * WAIT_FOR_SETUP (OUT_PKT_RDY)
+ */
+static void s3c_ep0_setup(struct s3c_udc *dev)
+{
+	struct s3c_ep *ep = &dev->ep[EP0_CON];
+	int i, bytes, is_in;
+	u32 gintmsk;
+
+	/* Nuke all previous transfers */
+	s3c_ep_nuke(ep, -EPROTO);
+
+	/* read control req from fifo (8 bytes) */
+	bytes = s3c_fifo_read(ep, (u32 *)&ctrl, 8);
+
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+	writel(gintmsk | INT_RX_FIFO_NOT_EMPTY, S3C_UDC_OTG_GINTMSK);
+
+	DEBUG_SETUP("Read CTRL REQ %d bytes\n", bytes);
+	DEBUG_SETUP("  CTRL.bRequestType = 0x%x (is_in %d)\n", ctrl.bRequestType,
+		    ctrl.bRequestType & USB_DIR_IN);
+	DEBUG_SETUP("  CTRL.bRequest = 0x%x\n", ctrl.bRequest);
+	DEBUG_SETUP("  CTRL.wLength = 0x%x\n", ctrl.wLength);
+	DEBUG_SETUP("  CTRL.wValue = 0x%x (%d)\n", ctrl.wValue, ctrl.wValue >> 8);
+	DEBUG_SETUP("  CTRL.wIndex = 0x%x\n", ctrl.wIndex);
+
+	/* Set direction of EP0 */
+	if (likely(ctrl.bRequestType & USB_DIR_IN)) {
+		ep->bEndpointAddress |= USB_DIR_IN;
+		is_in = 1;
+	} else {
+		ep->bEndpointAddress &= ~USB_DIR_IN;
+		is_in = 0;
+	}
+
+#if 1
+
+	if ( (ctrl.bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS ) { // CLASS TYPE
+		printk("CLASS Type request. ep->bEndpointAddress : 0x%02x\n", ep->bEndpointAddress);
+		switch(ctrl.bRequest)
+		{
+			case USB_CDC_REQ_SET_LINE_CODING :
+				printk("USB_CDC_REQ_SET_LINE_CODING\n");
+				dev->ep0state = USB_CDC_REQ_SET_LINE_CODING;
+				//read more data
+				break;
+			case USB_CDC_REQ_GET_LINE_CODING :
+				printk("USB_CDC_REQ_GET_LINE_CODING\n");
+				printk("modify USB_DIR_IN\n");
+				ep->bEndpointAddress |= USB_DIR_IN;
+				break;
+			case USB_CDC_REQ_SET_CONTROL_LINE_STATE :				
+				printk("USB_CDC_REQ_SET_CONTROL_LINE_STATE\n");
+				printk("modify USB_DIR_IN\n");
+				ep->bEndpointAddress |= USB_DIR_IN;
+				dev->ep0state = USB_CDC_REQ_SET_CONTROL_LINE_STATE;
+				break;
+		}
+	}
+#endif
+
+	/* Handle some SETUP packets ourselves */
+	switch (ctrl.bRequest) {
+
+#if 1
+		case USB_REQ_CLEAR_FEATURE:	//0x01
+			DEBUG_SETUP("%s: *** USB_REQ_CLEAR_FEATURE \n", __FUNCTION__);
+/*
+			if ((ctrl.bRequestType & (USB_DIR_IN | USB_TYPE_MASK))
+					!= (USB_DIR_IN | USB_TYPE_STANDARD))
+			{
+				DEBUG_SETUP("%s: *** USB_REQ_GET_STATUS : delegated !!!  \n",__FUNCTION__);
+					break;
+			}
+*/
+			//USB_TYPE_VENDOR = 0x02
+			if ((ctrl.bRequestType & (USB_DIR_IN | USB_TYPE_MASK))
+					!= (USB_DIR_IN | USB_TYPE_VENDOR))
+			{
+					printk("CLEAR FEATURE request.\n");
+					printk("modify USB_DIR_IN\n");
+					ep->bEndpointAddress |= USB_DIR_IN;
+			}
+			break;
+#endif
+
+		case USB_REQ_SET_ADDRESS:
+			if (ctrl.bRequestType
+				!= (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
+				break;
+
+			DEBUG_SETUP("%s: *** USB_REQ_SET_ADDRESS (%d)\n",
+					__FUNCTION__, ctrl.wValue);
+			s3c_udc_set_address(dev, ctrl.wValue);
+			dev->ep0state = DATA_STATE_NEED_ZLP;
+			
+			return;
+
+		case USB_REQ_SET_CONFIGURATION :
+			DEBUG_SETUP("============================================\n");
+			DEBUG_SETUP("%s: USB_REQ_SET_CONFIGURATION (%d)\n",
+					__FUNCTION__, ctrl.wValue);
+config_change:
+			DEBUG_SETUP("============================================\n");
+
+			reset_available = 1;
+			dev->ep0state = DATA_STATE_NEED_ZLP;
+			break;
+
+		case USB_REQ_GET_DESCRIPTOR:
+			DEBUG_SETUP("%s: *** USB_REQ_GET_DESCRIPTOR  \n",__FUNCTION__);
+			break;
+
+		case USB_REQ_SET_INTERFACE:
+			DEBUG_SETUP("%s: *** USB_REQ_SET_INTERFACE (%d)\n",
+					__FUNCTION__, ctrl.wValue);
+			goto config_change;
+			break;
+
+		case USB_REQ_GET_CONFIGURATION:
+			DEBUG_SETUP("%s: *** USB_REQ_GET_CONFIGURATION  \n",__FUNCTION__);
+			break;
+
+		case USB_REQ_GET_STATUS:
+			DEBUG_SETUP("%s: *** USB_REQ_GET_STATUS  \n",__FUNCTION__);
+			break;
+
+		default:
+//			DEBUG_SETUP("%s: *** Default of ctrl.bRequest=0x%x happened.\n",__FUNCTION__, ctrl.bRequest);
+			break;
+	}
+
+//delegate:
+
+	if (likely(dev->driver)) {
+		/* device-2-host (IN) or no data setup command,
+		 * process immediately */
+		spin_unlock(&dev->lock);
+		i = dev->driver->setup(&dev->gadget, &ctrl);
+		spin_lock(&dev->lock);
+
+		if (i < 0) {
+			/* setup processing failed, force stall */
+			DEBUG_SETUP("%s: gadget setup FAILED (stalling), setup returned %d\n",
+				__FUNCTION__, i);
+			/* ep->stopped = 1; */
+			dev->ep0state = FAIL_TO_SETUP;
+		}
+	}
+}
+
+/*
+ * handle ep0 interrupt
+ */
+static void s3c_ep0_handle(struct s3c_udc *dev)
+{
+	if (dev->ep0state == WAIT_FOR_SETUP) {
+		DEBUG_EP0("%s: WAIT_FOR_SETUP\n", __FUNCTION__);
+		s3c_ep0_setup(dev);
+	} else {
+		DEBUG_EP0("%s: strange state!!(state = %s)\n",
+			__FUNCTION__, state_names[dev->ep0state]);
+		
+		readl(S3C_UDC_OTG_GRXSTSP);
+	}
+}
+
+static void s3c_ep0_kick(struct s3c_udc *dev, struct s3c_ep *ep)
+{
+	u32 gintmsk, ep_ctrl;
+	u8 is_in = ep_is_in(ep);
+
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+
+	DEBUG_EP0("%s: ep_is_in = %d\n", __FUNCTION__, ep_is_in(ep));
+	
+	if(dev->ep0state == USB_CDC_REQ_SET_CONTROL_LINE_STATE)
+	{	
+			writel(gintmsk | INT_NP_TX_FIFO_EMPTY, S3C_UDC_OTG_GINTMSK);
+			return;
+	}
+	
+	if(dev->ep0state == USB_CDC_REQ_SET_LINE_CODING)
+	{	
+		writel(gintmsk | INT_RX_FIFO_NOT_EMPTY, S3C_UDC_OTG_GINTMSK);
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+		writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+		return;
+	}
+	
+		
+	if(dev->ep0state == DATA_STATE_NEED_ZLP)
+	{
+		DEBUG_EP0("%s: DATA_STATE_NEED_ZLP\n", __FUNCTION__);
+		//zlp can be sent after setup transaction complete irq so enabel rxFifonotEmpty
+		writel(gintmsk | INT_RX_FIFO_NOT_EMPTY, S3C_UDC_OTG_GINTMSK);
+		ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+		writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+		return;
+	}
+	if (is_in) {
+		dev->ep0state = DATA_STATE_XMIT;
+	} else {
+		dev->ep0state = DATA_STATE_RECV;
+	}
+	
+	writel(gintmsk | INT_RX_FIFO_NOT_EMPTY, S3C_UDC_OTG_GINTMSK);
+	ep_ctrl = readl(S3C_UDC_OTG_DOEPCTL0);
+	writel(ep_ctrl | DEPCTL_EPENA|DEPCTL_CNAK, S3C_UDC_OTG_DOEPCTL0);
+}
+
diff -Nur linux-2.6.29/drivers/usb/gadget/serial_acm.c linux-2.6.29-spica/drivers/usb/gadget/serial_acm.c
--- linux-2.6.29/drivers/usb/gadget/serial_acm.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/usb/gadget/serial_acm.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,166 @@
+/*
+ * serial_acm.c -- USB modem serial driver
+ *
+ * Copyright 2008 (C) Samsung Electronics
+ *
+ */
+ 
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/usb/cdc.h>
+
+extern void acm_notify(void * dev, u16 state);
+
+
+static wait_queue_head_t modem_wait_q;
+
+static unsigned int read_state = 0;
+static unsigned int control_line_state = 0;
+
+static void * acm_data = NULL;
+
+static int modem_open(struct inode *inode, struct file *file)
+{
+	read_state = 0;
+	
+	return 0;
+}
+
+static int modem_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static ssize_t modem_read(struct file *file, char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	int ret = 0;
+
+	if (file->f_flags & O_NONBLOCK) 
+		return -EAGAIN;
+
+	ret = wait_event_interruptible(modem_wait_q, read_state);
+	if (ret)
+		return ret;
+	
+	if (copy_to_user(buf, &control_line_state, sizeof(u32)))
+		return -EFAULT;
+
+	read_state = 0;
+	
+	return sizeof(u32);
+}
+
+static unsigned int modem_poll(struct file *file, poll_table *wait)
+{
+	poll_wait(file, &modem_wait_q, wait);
+
+	return (read_state ? (POLLIN | POLLRDNORM) : 0);
+}
+
+void notify_control_line_state(u32 value)
+{
+	control_line_state = value;
+
+	read_state = 1;
+
+	wake_up_interruptible(&modem_wait_q);
+}
+EXPORT_SYMBOL(notify_control_line_state);
+
+
+#define GS_CDC_NOTIFY_SERIAL_STATE	_IOW('S', 1, int)
+#define GS_IOC_NOTIFY_DTR_TEST		_IOW('S', 3, int)
+
+static int 
+modem_ioctl (struct inode *inode, struct file *file, unsigned int  cmd,unsigned long arg)
+{
+	printk("modem_ioctl: cmd=0x%x, arg=%lu\n", cmd, arg);
+
+	/* handle ioctls */
+	switch (cmd) 
+	{
+		case GS_CDC_NOTIFY_SERIAL_STATE:
+			acm_notify(acm_data, __constant_cpu_to_le16(arg));
+			break;
+
+		case GS_IOC_NOTIFY_DTR_TEST:
+			{
+			printk(KERN_ALERT"DUN : DTR %d\n",(int)arg);
+			notify_control_line_state((int)arg);
+			break;
+			}
+		
+		default:
+			printk("modem_ioctl: Unknown ioctl cmd(0x%x).\n", cmd);
+			return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+
+static struct file_operations modem_fops = {
+	.owner 		= THIS_MODULE,
+	.open 		= modem_open,
+	.release 	= modem_close,
+	.read 		= modem_read,
+	.poll 		= modem_poll,
+	.llseek 	= no_llseek,
+	.ioctl		= modem_ioctl,
+};
+
+static struct miscdevice modem_device = {
+	.minor	= 123,
+	.name	= "dun",
+	.fops	= &modem_fops,
+};
+
+int modem_register(void * data)
+{
+	int ret;
+
+	if(data == NULL)
+	{
+		printk("DUN register failed. data is null.\n");
+		return -1;
+	}
+
+	acm_data = data;
+
+	ret = misc_register(&modem_device);
+	if (ret) {
+		printk(KERN_ERR "DUN register is failed, ret = %d\n", ret);
+		return ret;
+	}
+
+	init_waitqueue_head(&modem_wait_q);
+
+	printk(KERN_INFO "DUN is registerd\n");
+	
+	return 0;
+}
+EXPORT_SYMBOL(modem_register);
+
+void modem_unregister(void)
+{
+	acm_data = NULL;
+
+	misc_deregister(&modem_device);
+	
+	printk(KERN_INFO "DUN is unregisterd\n");
+}
+EXPORT_SYMBOL(modem_unregister);
diff -Nur linux-2.6.29/drivers/usb/gadget/u_ether.c linux-2.6.29-spica/drivers/usb/gadget/u_ether.c
--- linux-2.6.29/drivers/usb/gadget/u_ether.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/usb/gadget/u_ether.c	2010-05-06 12:42:45.644210217 +0700
@@ -31,6 +31,21 @@
 
 #include "u_ether.h"
 
+/* for memory copying socket buffers, it enhances performance of data communication */
+#define	SKB_MEMCOPY 1
+
+#if SKB_MEMCOPY	
+
+#if defined(CONFIG_USB_GADGET_S3C_OTGD_HS_DMA_MODE) /* DMA Mode */
+	#define MEMCOPY_FOR_DMA
+	#undef 	MEMCOPY_FOR_SLAVE
+#else /* Slave Mode */
+	#define MEMCOPY_FOR_SLAVE
+	#undef	MEMCOPY_FOR_DMA
+#endif
+
+#endif //SKB_MEMCOPY
+
 
 /*
  * This component encapsulates the Ethernet link glue needed to provide
@@ -118,6 +133,7 @@
 #undef ERROR
 #undef INFO
 
+#if 0
 #define xprintk(d, level, fmt, args...) \
 	printk(level "%s: " fmt , (d)->net->name , ## args)
 
@@ -141,7 +157,25 @@
 	xprintk(dev , KERN_ERR , fmt , ## args)
 #define INFO(dev, fmt, args...) \
 	xprintk(dev , KERN_INFO , fmt , ## args)
+#else
+
+#define xprintk(d, level, fmt, args...) \
+	printk(fmt, ##args)
+
+#define DBG(dev, fmt, args...) \
+	printk(fmt, ##args)
+
+#define VDBG(dev, fmt, args...) \
+	printk(fmt, ##args)
+
+#define ERROR(dev, fmt, args...) \
+	printk(fmt, ##args)
+#define INFO(dev, fmt, args...) \
+	printk(fmt, ##args)
+
+
 
+#endif
 /*-------------------------------------------------------------------------*/
 
 /* NETWORK DRIVER HOOKUP (to the layer above this driver) */
@@ -253,7 +287,22 @@
 	 */
 	skb_reserve(skb, NET_IP_ALIGN);
 
+#if	SKB_MEMCOPY
+		
+#ifdef MEMCOPY_FOR_DMA
+		req->buf = kmalloc(size, GFP_ATOMIC| GFP_DMA);
+#endif
+#ifdef MEMCOPY_FOR_SLAVE
+		req->buf = kmalloc(size, GFP_ATOMIC);
+#endif	
+		if (!req->buf) {
 	req->buf = skb->data;
+			printk("%s: fail to kmalloc [req->buf = skb->data]\n", __FUNCTION__);
+		}	
+#else
+	req->buf = skb->data;
+#endif
+
 	req->length = size;
 	req->complete = rx_complete;
 	req->context = skb;
@@ -264,8 +313,13 @@
 		defer_kevent(dev, WORK_RX_MEMORY);
 	if (retval) {
 		DBG(dev, "rx submit --> %d\n", retval);
-		if (skb)
+		if (skb) {
 			dev_kfree_skb_any(skb);
+#ifdef SKB_MEMCOPY
+			if(req->buf != skb->data)
+				kfree(req->buf);
+#endif	
+		}
 		spin_lock_irqsave(&dev->req_lock, flags);
 		list_add(&req->list, &dev->rx_reqs);
 		spin_unlock_irqrestore(&dev->req_lock, flags);
@@ -283,6 +337,10 @@
 
 	/* normal completion */
 	case 0:
+#ifdef SKB_MEMCOPY
+		if(req->buf != skb->data)
+			memcpy(skb->data, req->buf, req->actual);
+#endif
 		skb_put(skb, req->actual);
 		if (dev->unwrap)
 			status = dev->unwrap(skb);
@@ -303,6 +361,10 @@
 		 * use skb buffers.
 		 */
 		status = netif_rx(skb);
+#ifdef SKB_MEMCOPY
+		if(req->buf != skb->data)
+			kfree(req->buf);
+#endif
 		skb = NULL;
 		break;
 
@@ -318,6 +380,10 @@
 		defer_kevent(dev, WORK_RX_MEMORY);
 quiesce:
 		dev_kfree_skb_any(skb);
+#ifdef SKB_MEMCOPY
+		if(req->buf != skb->data)
+			kfree(req->buf);
+#endif
 		goto clean;
 
 	/* data overrun */
@@ -331,8 +397,13 @@
 		break;
 	}
 
-	if (skb)
+	if (skb) {
 		dev_kfree_skb_any(skb);
+#ifdef SKB_MEMCOPY
+		if(req->buf != skb->data)
+			kfree(req->buf);
+#endif
+	}
 	if (!netif_running(dev->net)) {
 clean:
 		spin_lock(&dev->req_lock);
@@ -461,6 +532,11 @@
 	spin_unlock(&dev->req_lock);
 	dev_kfree_skb_any(skb);
 
+#ifdef SKB_MEMCOPY
+	if(req->buf != skb->data)
+		kfree(req->buf);
+#endif
+
 	atomic_dec(&dev->tx_qlen);
 	if (netif_carrier_ok(dev->net))
 		netif_wake_queue(dev->net);
@@ -552,7 +628,27 @@
 		skb = skb_new;
 		length = skb->len;
 	}
+	
+#if	SKB_MEMCOPY
+	
+#ifdef MEMCOPY_FOR_DMA
+	req->buf = kmalloc(skb->len +2, GFP_ATOMIC | GFP_DMA);
+#endif
+#ifdef MEMCOPY_FOR_SLAVE
+	req->buf = kmalloc(skb->len +2, GFP_ATOMIC);
+#endif
+
+	if (!req->buf) {
+	req->buf = skb->data;
+		printk("%s: fail to kmalloc [req->buf = skb->data]\n", __FUNCTION__);
+	}
+	else
+		memcpy((void *)req->buf, (void *)skb->data, skb->len);
+
+#else
 	req->buf = skb->data;
+#endif
+
 	req->context = skb;
 	req->complete = tx_complete;
 
@@ -586,6 +682,11 @@
 drop:
 		dev->net->stats.tx_dropped++;
 		dev_kfree_skb_any(skb);
+#ifdef SKB_MEMCOPY
+		if(req->buf != skb->data)
+			kfree(req->buf);
+#endif
+
 		spin_lock_irqsave(&dev->req_lock, flags);
 		if (list_empty(&dev->tx_reqs))
 			netif_start_queue(net);
diff -Nur linux-2.6.29/drivers/usb/gadget/u_serial.c linux-2.6.29-spica/drivers/usb/gadget/u_serial.c
--- linux-2.6.29/drivers/usb/gadget/u_serial.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/usb/gadget/u_serial.c	2010-05-06 12:42:45.644210217 +0700
@@ -52,7 +52,8 @@
  * is managed in userspace ... OBEX, PTP, and MTP have been mentioned.
  */
 
-#define PREFIX	"ttyGS"
+//#define PREFIX	"ttyGS"
+#define PREFIX	"ttygs"
 
 /*
  * gserial is the lifecycle interface, used by USB functions
@@ -125,7 +126,12 @@
 
 #define GS_CLOSE_TIMEOUT		15		/* seconds */
 
+#define ACM_ZLP		0
 
+#if ACM_ZLP
+static int s3c_multiple = 0;
+static int s3c_need_zlp = 0;
+#endif
 
 #ifdef VERBOSE_DEBUG
 #define pr_vdebug(fmt, arg...) \
@@ -134,7 +140,6 @@
 #define pr_vdebug(fmt, arg...) \
 	({ if (0) pr_debug(fmt, ##arg); })
 #endif
-
 /*-------------------------------------------------------------------------*/
 
 /* Circular Buffer */
@@ -363,10 +368,27 @@
 
 		req = list_entry(pool->next, struct usb_request, list);
 		len = gs_send_packet(port, req->buf, in->maxpacket);
+
+#if ACM_ZLP
+		if (len == 0) {
+			//printk("[%s] len == 0 ;\n", __func__);
+			if (s3c_need_zlp == 0) {
+				req->zero = 0;
+				wake_up_interruptible(&port->drain_wait);
+				break;
+			} else {
+				//printk("[%s] zlp: => req.zero = true ;\n", __func__);
+				req->zero = 1;
+				s3c_need_zlp = 0;
+				s3c_multiple = 0;
+			}
+		}
+#else
 		if (len == 0) {
 			wake_up_interruptible(&port->drain_wait);
 			break;
 		}
+#endif
 		do_tty_wake = true;
 
 		req->length = len;
@@ -819,11 +841,50 @@
 	return cond;
 }
 
+static int gs_chars_in_buffer(struct tty_struct *tty)
+{
+	struct gs_port	*port = tty->driver_data;
+	unsigned long	flags;
+	int		chars = 0;
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	chars = gs_buf_data_avail(&port->port_write_buf);
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+//	printk("[%s] gs_chars_in_buffer: (%d,%p) chars=%d\n", __func__, 
+//		port->port_num, tty, chars);
+
+#if ACM_ZLP
+	if (chars == 0 && s3c_multiple == 1) {
+
+		if (port->port_usb) {
+			int status;
+			//printk("%s: Need zlp.....\n", __func__);
+			s3c_need_zlp = 1;
+
+			spin_lock_irqsave(&port->port_lock, flags);
+			status = gs_start_tx(port);
+			spin_unlock_irqrestore(&port->port_lock, flags);
+		}
+	}
+#endif
+
+	return chars;
+}
+
+
 static void gs_close(struct tty_struct *tty, struct file *file)
 {
 	struct gs_port *port = tty->driver_data;
 	struct gserial	*gser;
 
+#if ACM_ZLP
+	//int ret = gs_chars_in_buffer(tty);
+//	printk("[%s] gs_chars_in_buffer: %d\n", __func__, ret);
+	gs_chars_in_buffer(tty);
+
+#endif
+
 	spin_lock_irq(&port->port_lock);
 
 	if (port->open_count != 1) {
@@ -885,6 +946,9 @@
 	struct gs_port	*port = tty->driver_data;
 	unsigned long	flags;
 	int		status;
+#if ACM_ZLP
+	struct usb_ep	*in;
+#endif
 
 	pr_vdebug("gs_write: ttyGS%d (%p) writing %d bytes\n",
 			port->port_num, tty, count);
@@ -892,6 +956,16 @@
 	spin_lock_irqsave(&port->port_lock, flags);
 	if (count)
 		count = gs_buf_put(&port->port_write_buf, buf, count);
+
+#if ACM_ZLP
+
+	in = port->port_usb->in;
+
+	s3c_multiple = 0;
+	if ( count != 0 && (count % in->maxpacket == 0)) {
+		s3c_multiple = 1;
+	}
+#endif
 	/* treat count == 0 as flush_chars() */
 	if (port->port_usb)
 		status = gs_start_tx(port);
@@ -946,22 +1020,6 @@
 	return room;
 }
 
-static int gs_chars_in_buffer(struct tty_struct *tty)
-{
-	struct gs_port	*port = tty->driver_data;
-	unsigned long	flags;
-	int		chars = 0;
-
-	spin_lock_irqsave(&port->port_lock, flags);
-	chars = gs_buf_data_avail(&port->port_write_buf);
-	spin_unlock_irqrestore(&port->port_lock, flags);
-
-	pr_vdebug("gs_chars_in_buffer: (%d,%p) chars=%d\n",
-		port->port_num, tty, chars);
-
-	return chars;
-}
-
 /* undo side effects of setting TTY_THROTTLED */
 static void gs_unthrottle(struct tty_struct *tty)
 {
@@ -1076,6 +1134,7 @@
 	gs_tty_driver->owner = THIS_MODULE;
 	gs_tty_driver->driver_name = "g_serial";
 	gs_tty_driver->name = PREFIX;
+	gs_tty_driver->major = 127;
 	/* uses dynamically assigned dev_t values */
 
 	gs_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
diff -Nur linux-2.6.29/drivers/video/fbmem.c linux-2.6.29-spica/drivers/video/fbmem.c
--- linux-2.6.29/drivers/video/fbmem.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/video/fbmem.c	2010-05-06 12:42:45.674299703 +0700
@@ -1355,6 +1355,10 @@
 	return 0;
 }
 
+#ifdef CONFIG_FB_S3C
+extern void s3cfb_stop_progress(void);
+#endif
+
 static int
 fb_open(struct inode *inode, struct file *file)
 __acquires(&info->lock)
@@ -1387,6 +1391,9 @@
 	if (info->fbdefio)
 		fb_deferred_io_open(info, inode, file);
 #endif
+#ifdef CONFIG_FB_S3C
+	s3cfb_stop_progress();
+#endif
 out:
 	mutex_unlock(&info->lock);
 	return res;
diff -Nur linux-2.6.29/drivers/video/Kconfig linux-2.6.29-spica/drivers/video/Kconfig
--- linux-2.6.29/drivers/video/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/video/Kconfig	2010-05-06 12:42:45.674299703 +0700
@@ -237,6 +237,105 @@
 comment "Frame buffer hardware drivers"
 	depends on FB
 
+config FB_S3C
+	tristate "S3C Framebuffer Support"
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	depends on FB && ARCH_S3C64XX
+
+	default n
+	---help---
+	TBA
+
+choice
+depends on FB_S3C
+prompt "Select LCD Type"
+default FB_S3C_LTE480WV
+config FB_S3C_LTE480WV
+	bool "LTE480WV/LTP700WV"
+	---help---
+	TBA
+
+config FB_S3C_LTV350QV
+	bool "LTV350QV"
+	---help---
+	TBA
+
+config FB_S3C_LTS222QV
+	bool "LTS222QV"
+	---help---
+	TBA
+
+config FB_S3C_S6D04D1
+	bool "S6D04D1"
+	---help---
+	TBA
+
+config FB_S3C_S6D05A
+	bool "S6D05A"
+	---help---
+	TBA
+
+
+endchoice
+
+
+config FB_S3C_BPP
+	tristate "Advanced options for S3C Framebuffer"
+	depends on FB_S3C
+	default n
+	---help---
+	TBA
+
+choice
+depends on FB_S3C_BPP
+prompt "Select BPP(Bits Per Pixel)"
+default FB_S3C_BPP_16
+config FB_S3C_BPP_8
+	bool "8 BPP"
+	---help---
+	TBA
+
+config FB_S3C_BPP_16
+	bool "16 BPP"
+	---help---
+	TBA
+
+config FB_S3C_BPP_24
+	bool "24 BPP"
+	---help---
+	TBA
+
+config FB_S3C_BPP_32
+	bool "32 BPP"
+	---help---
+	TBA
+endchoice
+
+config FB_S3C_NUM
+	int "Number of Framebuffers"
+	depends on ARCH_S3C64XX && FB_S3C_BPP 
+	default "1"
+	---help---
+	TBA
+
+config FB_S3C_VIRTUAL_SCREEN
+	bool "Enable Virtual Screen"
+	depends on FB_S3C_BPP
+
+	default n
+	---help---
+	TBA
+
+config FB_S3C_DOUBLE_BUFFERING
+	bool "Enable Double Buffering"
+	depends on FB_S3C_BPP
+
+	default n
+	---help---
+	TBA
+
 config FB_CIRRUS
 	tristate "Cirrus Logic support"
 	depends on FB && (ZORRO || PCI)
diff -Nur linux-2.6.29/drivers/video/logo/Kconfig linux-2.6.29-spica/drivers/video/logo/Kconfig
--- linux-2.6.29/drivers/video/logo/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/video/logo/Kconfig	2010-05-06 12:42:45.674299703 +0700
@@ -27,6 +27,11 @@
 	bool "Standard 224-color Linux logo"
 	default y
 
+config LOGO_LINUX_LANDSCAPED_CLUT224
+	bool "Standard landscape 224-color Linux logo"
+	depends on LOGO
+	default y
+
 config LOGO_BLACKFIN_VGA16
 	bool "16-colour Blackfin Processor Linux logo"
 	depends on BLACKFIN
diff -Nur linux-2.6.29/drivers/video/logo/logo.c linux-2.6.29-spica/drivers/video/logo/logo.c
--- linux-2.6.29/drivers/video/logo/logo.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/video/logo/logo.c	2010-05-06 12:42:45.674299703 +0700
@@ -24,6 +24,7 @@
 extern const struct linux_logo logo_linux_mono;
 extern const struct linux_logo logo_linux_vga16;
 extern const struct linux_logo logo_linux_clut224;
+extern const struct linux_logo logo_linux_landscaped_clut224;
 extern const struct linux_logo logo_blackfin_vga16;
 extern const struct linux_logo logo_blackfin_clut224;
 extern const struct linux_logo logo_dec_clut224;
@@ -82,6 +83,9 @@
 		/* Generic Linux logo */
 		logo = &logo_linux_clut224;
 #endif
+#ifdef CONFIG_LOGO_LINUX_LANDSCAPED_CLUT224
+		logo = &logo_linux_landscaped_clut224;
+#endif
 #ifdef CONFIG_LOGO_BLACKFIN_CLUT224
 		/* Blackfin Linux logo */
 		logo = &logo_blackfin_clut224;
diff -Nur linux-2.6.29/drivers/video/logo/Makefile linux-2.6.29-spica/drivers/video/logo/Makefile
--- linux-2.6.29/drivers/video/logo/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/video/logo/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -4,6 +4,7 @@
 obj-$(CONFIG_LOGO_LINUX_MONO)		+= logo_linux_mono.o
 obj-$(CONFIG_LOGO_LINUX_VGA16)		+= logo_linux_vga16.o
 obj-$(CONFIG_LOGO_LINUX_CLUT224)	+= logo_linux_clut224.o
+obj-$(CONFIG_LOGO_LINUX_LANDSCAPED_CLUT224) += logo_linux_landscaped_clut224.o
 obj-$(CONFIG_LOGO_BLACKFIN_CLUT224)	+= logo_blackfin_clut224.o
 obj-$(CONFIG_LOGO_BLACKFIN_VGA16)	+= logo_blackfin_vga16.o
 obj-$(CONFIG_LOGO_DEC_CLUT224)		+= logo_dec_clut224.o
diff -Nur linux-2.6.29/drivers/video/Makefile linux-2.6.29-spica/drivers/video/Makefile
--- linux-2.6.29/drivers/video/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/video/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -110,6 +110,7 @@
 obj-$(CONFIG_FB_SH7760)		  += sh7760fb.o
 obj-$(CONFIG_FB_IMX)              += imxfb.o
 obj-$(CONFIG_FB_S3C2410)	  += s3c2410fb.o
+obj-$(CONFIG_FB_S3C)		  += samsung/
 obj-$(CONFIG_FB_FSL_DIU)	  += fsl-diu-fb.o
 obj-$(CONFIG_FB_COBALT)           += cobalt_lcdfb.o
 obj-$(CONFIG_FB_PNX4008_DUM)	  += pnx4008/
diff -Nur linux-2.6.29/drivers/video/samsung/Makefile linux-2.6.29-spica/drivers/video/samsung/Makefile
--- linux-2.6.29/drivers/video/samsung/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/video/samsung/Makefile	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,13 @@
+#
+# Makefile for the s3c framebuffer driver
+#
+
+obj-$(CONFIG_FB_S3C)		+= s3cfb.o
+obj-$(CONFIG_FB_S3C)		+= s3cfb_spi.o
+obj-$(CONFIG_PLAT_S3C64XX)	+= s3cfb_fimd4x.o
+obj-$(CONFIG_FB_S3C_LTE480WV)	+= s3cfb_lte480wv.o
+obj-$(CONFIG_FB_S3C_LTV350QV)	+= s3cfb_ltv350qv.o
+obj-$(CONFIG_FB_S3C_LTS222QV)	+= s3cfb_lts222qv.o
+obj-$(CONFIG_FB_S3C_S6D04D1)	+= s3cfb_s6d04d1.o
+obj-$(CONFIG_FB_S3C_S6D05A)	+= s3cfb_s6d05a.o
+
diff -Nur linux-2.6.29/drivers/video/samsung/s3cfb.c linux-2.6.29-spica/drivers/video/samsung/s3cfb.c
--- linux-2.6.29/drivers/video/samsung/s3cfb.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/video/samsung/s3cfb.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,1044 @@
+/*
+ * drivers/video/samsung/s3cfb.c
+ *
+ * $Id: s3cfb.c,v 1.1 2008/11/17 11:12:08 jsgood Exp $
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/earlysuspend.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/div64.h>
+
+#include <plat/regs-gpio.h>
+#include <plat/regs-lcd.h>
+
+#include "s3cfb.h"
+
+/*
+ *  Globals
+ */
+s3c_fb_info_t s3c_fb_info[S3C_FB_NUM];
+
+static struct early_suspend *early_suspend_ptr;
+
+struct early_suspend *get_earlysuspend_ptr(void)
+{
+	return early_suspend_ptr;
+}
+
+void s3cfb_set_lcd_power(int to)
+{
+	s3c_fimd.lcd_power = to;
+
+	if (s3c_fimd.set_lcd_power)
+		(s3c_fimd.set_lcd_power)(to);
+}
+EXPORT_SYMBOL(s3cfb_set_lcd_power);
+
+void s3cfb_set_backlight_power(int to)
+{
+	s3c_fimd.backlight_power = to;
+
+	if (s3c_fimd.set_backlight_power)
+		(s3c_fimd.set_backlight_power)(to);
+}
+EXPORT_SYMBOL(s3cfb_set_backlight_power);
+
+void s3cfb_set_backlight_level(int to)
+{
+	s3c_fimd.backlight_level = to;
+
+	if (s3c_fimd.set_brightness)
+		(s3c_fimd.set_brightness)(to);
+}
+EXPORT_SYMBOL(s3cfb_set_backlight_level);
+
+/* RAM Dump Info */
+
+#include <linux/sec_log.h>
+
+static struct struct_frame_buf_mark frame_buf_mark = { 
+	.special_mark_1 = (('*' << 24) | ('^' << 16) | ('^' << 8) | ('*' << 0)),
+	.special_mark_2 = (('I' << 24) | ('n' << 16) | ('f' << 8) | ('o' << 0)),
+	.special_mark_3 = (('H' << 24) | ('e' << 16) | ('r' << 8) | ('e' << 0)),
+	.special_mark_4 = (('f' << 24) | ('b' << 16) | ('u' << 8) | ('f' << 0)),
+	.p_fb = 0,
+	.resX = 320,
+	.resY = 480,
+	.bpp = 24,
+	.frames =5,
+};
+
+static struct struct_marks_ver_mark marks_ver_mark = {
+	.special_mark_1 = (('*' << 24) | ('^' << 16) | ('^' << 8) | ('*' << 0)),
+	.special_mark_2 = (('I' << 24) | ('n' << 16) | ('f' << 8) | ('o' << 0)),
+	.special_mark_3 = (('H' << 24) | ('e' << 16) | ('r' << 8) | ('e' << 0)),
+	.special_mark_4 = (('v' << 24) | ('e' << 16) | ('r' << 8) | ('s' << 0)),
+	.log_mark_version = 0,
+	.framebuffer_mark_version = 1, 
+};
+
+
+
+static int __init s3cfb_map_video_memory(s3c_fb_info_t *fbi)
+{
+	DPRINTK("map_video_memory(fbi=%p)\n", fbi);
+
+	fbi->map_size_f1 = PAGE_ALIGN(fbi->fb.fix.smem_len);
+	fbi->map_cpu_f1 = dma_alloc_writecombine(fbi->dev, fbi->map_size_f1, &fbi->map_dma_f1, GFP_KERNEL);
+	fbi->map_size_f1 = fbi->fb.fix.smem_len;
+
+	if (fbi->map_cpu_f1) {
+		/* prevent initial garbage on screen */
+		printk("Window[%d] - FB1: map_video_memory: clear %p:%08x\n",
+			fbi->win_id, fbi->map_cpu_f1, fbi->map_size_f1);
+		memset(fbi->map_cpu_f1, 0xf0, fbi->map_size_f1);
+
+		fbi->screen_dma_f1 = fbi->map_dma_f1;
+		fbi->fb.screen_base = fbi->map_cpu_f1;
+		fbi->fb.fix.smem_start = fbi->screen_dma_f1;
+
+		printk("            FB1: map_video_memory: dma=%08x cpu=%p size=%08x\n",
+			fbi->map_dma_f1, fbi->map_cpu_f1, fbi->fb.fix.smem_len);
+	}
+
+	/* RAM Dump Info */
+	if ((fbi->win_id == 1) && fbi->map_cpu_f1)
+		frame_buf_mark.p_fb = (void *)fbi->map_dma_f1;	
+
+	if (!fbi->map_cpu_f1)
+		return -ENOMEM;
+
+#if defined(CONFIG_FB_S3C_DOUBLE_BUFFERING)
+	if (fbi->win_id < 2 && fbi->map_cpu_f1) {
+		fbi->map_size_f2 = (fbi->fb.fix.smem_len / 2);
+		fbi->map_cpu_f2 = fbi->map_cpu_f1 + fbi->map_size_f2;
+		fbi->map_dma_f2 = fbi->map_dma_f1 + fbi->map_size_f2;
+
+		/* prevent initial garbage on screen */
+		printk("Window[%d] - FB2: map_video_memory: clear %p:%08x\n",
+			fbi->win_id, fbi->map_cpu_f2, fbi->map_size_f2);
+
+		fbi->screen_dma_f2 = fbi->map_dma_f2;
+
+		printk("            FB2: map_video_memory: dma=%08x cpu=%p size=%08x\n",
+			fbi->map_dma_f2, fbi->map_cpu_f2, fbi->map_size_f2);
+	}
+#endif
+
+	if (s3c_fimd.map_video_memory)
+		(s3c_fimd.map_video_memory)(fbi);
+
+	return 0;
+}
+
+static void s3cfb_unmap_video_memory(s3c_fb_info_t *fbi)
+{
+	dma_free_writecombine(fbi->dev, fbi->map_size_f1, fbi->map_cpu_f1,  fbi->map_dma_f1);
+
+#if defined(CONFIG_FB_S3C_DOUBLE_BUFFERING)
+	dma_free_writecombine(fbi->dev, fbi->map_size_f2, fbi->map_cpu_f2,  fbi->map_dma_f2);
+#endif
+
+	if (s3c_fimd.unmap_video_memory)
+		(s3c_fimd.unmap_video_memory)(fbi);
+}
+
+/*
+ *	s3cfb_check_var():
+ *	Get the video params out of 'var'. If a value doesn't fit, round it up,
+ *	if it's too big, return -EINVAL.
+ *
+ */
+static int s3cfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	DPRINTK("check_var(var=%p, info=%p)\n", var, info);
+
+	switch (var->bits_per_pixel) {
+		case 8:
+			var->red = s3c_fb_rgb_8.red;
+			var->green = s3c_fb_rgb_8.green;
+			var->blue = s3c_fb_rgb_8.blue;
+			var->transp = s3c_fb_rgb_8.transp;
+			s3c_fimd.bytes_per_pixel = 1;
+			break;
+
+		case 16:
+			var->red = s3c_fb_rgb_16.red;
+			var->green = s3c_fb_rgb_16.green;
+			var->blue = s3c_fb_rgb_16.blue;
+			var->transp = s3c_fb_rgb_16.transp;
+			s3c_fimd.bytes_per_pixel = 2;
+			break;
+
+		case 24:
+			var->red = s3c_fb_rgb_24.red;
+			var->green = s3c_fb_rgb_24.green;
+			var->blue = s3c_fb_rgb_24.blue;
+			var->transp = s3c_fb_rgb_24.transp;
+			s3c_fimd.bytes_per_pixel = 4;
+			break;
+
+		case 32:
+			var->red = s3c_fb_rgb_32.red;
+			var->green = s3c_fb_rgb_32.green;
+			var->blue = s3c_fb_rgb_32.blue;
+			var->transp = s3c_fb_rgb_32.transp;
+			s3c_fimd.bytes_per_pixel = 4;
+			break;
+	}
+
+	return 0;
+}
+
+/*
+ *      s3cfb_set_par - Optional function. Alters the hardware state.
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ */
+static int s3cfb_set_par(struct fb_info *info)
+{
+	struct fb_var_screeninfo *var = &info->var;
+	s3c_fb_info_t *fbi = (s3c_fb_info_t *) info;
+
+	if (var->bits_per_pixel == 16 || var->bits_per_pixel == 24)
+		fbi->fb.fix.visual = FB_VISUAL_TRUECOLOR;
+	else
+		fbi->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;
+
+	fbi->fb.fix.line_length = var->width * s3c_fimd.bytes_per_pixel;
+
+	/* activate this new configuration */
+	s3cfb_activate_var(fbi, var);
+
+	return 0;
+}
+
+/**
+ *	s3cfb_pan_display
+ *	@var: frame buffer variable screen structure
+ *	@info: frame buffer structure that represents a single frame buffer
+ *
+ *	Pan (or wrap, depending on the `vmode' field) the display using the
+ *	`xoffset' and `yoffset' fields of the `var' structure.
+ *	If the values don't fit, return -EINVAL.
+ *
+ *	Returns negative errno on error, or zero on success.
+ */
+static int s3cfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	s3c_fb_info_t *fbi = (s3c_fb_info_t *)info;
+
+	DPRINTK("s3c_fb_pan_display(var=%p, info=%p)\n", var, info);
+	
+	if (var->xoffset != 0)
+	{
+		printk("%s::var->xoffset(%d)\n", __func__, var->xoffset);
+		return -EINVAL;
+	}
+
+	if (var->yoffset + info->var.yres > info->var.yres_virtual)
+	{
+		printk("%s::var->yoffset(%d) + info->var.yres(%d) > info->var.yres_virtual(%d)\n", __func__,
+		        var->yoffset, info->var.yres, info->var.yres_virtual);
+		return -EINVAL;
+	}
+
+	fbi->fb.var.xoffset = var->xoffset;
+	fbi->fb.var.yoffset = var->yoffset;
+
+	s3cfb_set_fb_addr(fbi);
+
+	return 0;
+}
+
+/**
+ *      s3cfb_blank
+ *	@blank_mode: the blank mode we want.
+ *	@info: frame buffer structure that represents a single frame buffer
+ *
+ *	Blank the screen if blank_mode != 0, else unblank. Return 0 if
+ *	blanking succeeded, != 0 if un-/blanking failed due to e.g. a
+ *	video mode which doesn't support it. Implements VESA suspend
+ *	and powerdown modes on hardware that supports disabling hsync/vsync:
+ *	blank_mode == 2: suspend vsync
+ *	blank_mode == 3: suspend hsync
+ *	blank_mode == 4: powerdown
+ *
+ *	Returns negative errno on error, or zero on success.
+ *
+ */
+static int s3cfb_blank(int blank_mode, struct fb_info *info)
+{
+	DPRINTK("blank(mode=%d, info=%p)\n", blank_mode, info);
+
+	switch (blank_mode) {
+	case VESA_NO_BLANKING:	/* lcd on, backlight on */
+		s3cfb_set_lcd_power(1);
+		s3cfb_set_backlight_power(1);
+		break;
+
+	case VESA_VSYNC_SUSPEND: /* lcd on, backlight off */
+	case VESA_HSYNC_SUSPEND:
+		s3cfb_set_lcd_power(1);
+		s3cfb_set_backlight_power(0);
+		break;
+
+	case VESA_POWERDOWN: /* lcd and backlight off */
+		s3cfb_set_lcd_power(0);
+		s3cfb_set_backlight_power(0);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_FB_S3C_VIRTUAL_SCREEN)
+int s3cfb_set_vs_info(s3c_vs_info_t vs_info)
+{
+	/* check invalid value */
+	if (vs_info.width != s3c_fimd.xres || vs_info.height != s3c_fimd.yres)
+		return 1;
+
+	if (!(vs_info.bpp == 8 || vs_info.bpp == 16 || vs_info.bpp == 24 || vs_info.bpp == 32))
+		return 1;
+
+	if (vs_info.offset < 0)
+		return 1;
+
+	if (vs_info.v_width != s3c_fimd.xres_virtual || vs_info.v_height != s3c_fimd.yres_virtual)
+		return 1;
+
+	/* save virtual screen information */
+	s3c_fimd.vs_info = vs_info;
+
+	if (s3c_fimd.vs_info.offset < 1)
+		s3c_fimd.vs_info.offset = 1;
+
+	if (s3c_fimd.vs_info.offset > S3C_FB_MAX_DISPLAY_OFFSET)
+		s3c_fimd.vs_info.offset = S3C_FB_MAX_DISPLAY_OFFSET;
+
+	s3c_fimd.vs_offset = s3c_fimd.vs_info.offset;
+
+	return 0;
+}
+#endif
+
+int s3cfb_onoff_win(s3c_fb_info_t *fbi, int onoff)
+{
+	int win_num =  fbi->win_id;
+
+	if (onoff)
+		writel(readl(S3C_WINCON0 + (0x04 * win_num)) | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON0 + (0x04 * win_num));
+	else
+		writel(readl(S3C_WINCON0 + (0x04 * win_num)) &~ (S3C_WINCONx_ENWIN_F_ENABLE), S3C_WINCON0 + (0x04 * win_num));
+
+	return 0;
+}
+
+int s3cfb_onoff_color_key_alpha(s3c_fb_info_t *fbi, int onoff)
+{
+	int win_num =  fbi->win_id - 1;
+
+	if (onoff)
+		writel(readl(S3C_W1KEYCON0 + (0x08 * win_num)) | S3C_WxKEYCON0_KEYBLEN_ENABLE, S3C_W1KEYCON0 + (0x08 * win_num));
+	else
+		writel(readl(S3C_W1KEYCON0 + (0x08 * win_num)) &~ (S3C_WxKEYCON0_KEYBLEN_ENABLE), S3C_W1KEYCON0 + (0x08 * win_num));
+
+	return 0;
+}
+
+int s3cfb_onoff_color_key(s3c_fb_info_t *fbi, int onoff)
+{
+	int win_num =  fbi->win_id - 1;
+
+	if (onoff)
+		writel(readl(S3C_W1KEYCON0 + (0x08 * win_num)) | S3C_WxKEYCON0_KEYEN_F_ENABLE, S3C_W1KEYCON0 + (0x08 * win_num));
+	else
+		writel(readl(S3C_W1KEYCON0 + (0x08 * win_num)) &~ (S3C_WxKEYCON0_KEYEN_F_ENABLE), S3C_W1KEYCON0 + (0x08 * win_num));
+
+	return 0;
+}
+
+int s3cfb_set_color_key_registers(s3c_fb_info_t *fbi, s3c_color_key_info_t colkey_info)
+{
+	unsigned int compkey = 0;
+	int win_num =  fbi->win_id;
+
+	if (win_num == 0) {
+		printk("WIN0 do not support color key\n");
+		return -1;
+	}
+
+	win_num--;
+
+	if (fbi->fb.var.bits_per_pixel == S3C_FB_PIXEL_BPP_16) {
+		/* RGB 5-6-5 mode */
+		compkey  = (((colkey_info.compkey_red & 0x1f) << 19) | 0x70000);
+		compkey |= (((colkey_info.compkey_green & 0x3f) << 10) | 0x300);
+		compkey |= (((colkey_info.compkey_blue  & 0x1f)  << 3 )| 0x7);
+	} else if (fbi->fb.var.bits_per_pixel == S3C_FB_PIXEL_BPP_24) {
+		/* currently RGB 8-8-8 mode  */
+		compkey  = ((colkey_info.compkey_red & 0xff) << 16);
+		compkey |= ((colkey_info.compkey_green & 0xff) << 8);
+		compkey |= ((colkey_info.compkey_blue & 0xff) << 0);
+	} else
+		printk("Invalid BPP has been given!\n");
+
+	if (colkey_info.direction == S3C_FB_COLOR_KEY_DIR_BG)
+		writel(S3C_WxKEYCON0_COMPKEY(compkey) | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE, S3C_W1KEYCON0 + (0x08 * win_num));
+
+	else if (colkey_info.direction == S3C_FB_COLOR_KEY_DIR_FG)
+		writel(S3C_WxKEYCON0_COMPKEY(compkey) | S3C_WxKEYCON0_DIRCON_MATCH_BG_IMAGE, S3C_W1KEYCON0 + (0x08 * win_num));
+
+	else
+		printk("Color key direction is not correct :: %d!\n", colkey_info.direction);
+
+	return 0;
+}
+
+int s3cfb_set_color_value(s3c_fb_info_t *fbi, s3c_color_val_info_t colval_info)
+{
+	unsigned int colval = 0;
+
+	int win_num =  fbi->win_id;
+
+	if (win_num == 0) {
+		printk("WIN0 do not support color key value\n");
+		return -1;
+	}
+
+	win_num--;
+
+	if (fbi->fb.var.bits_per_pixel == S3C_FB_PIXEL_BPP_16) {
+		/* RGB 5-6-5 mode */
+		colval  = (((colval_info.colval_red   & 0x1f) << 19) | 0x70000);
+		colval |= (((colval_info.colval_green & 0x3f) << 10) | 0x300);
+		colval |= (((colval_info.colval_blue  & 0x1f)  << 3 )| 0x7);
+	} else if (fbi->fb.var.bits_per_pixel == S3C_FB_PIXEL_BPP_24) {
+		/* currently RGB 8-8-8 mode  */
+		colval  = ((colval_info.colval_red  & 0xff) << 16);
+		colval |= ((colval_info.colval_green & 0xff) << 8);
+		colval |= ((colval_info.colval_blue  & 0xff) << 0);
+	} else
+		printk("Invalid BPP has been given!\n");
+
+	writel(S3C_WxKEYCON1_COLVAL(colval), S3C_W1KEYCON1 + (0x08 * win_num));
+
+	return 0;
+}
+
+static int s3cfb_set_bpp(s3c_fb_info_t *fbi, int bpp)
+{
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	int win_num =  fbi->win_id;
+	unsigned int val;
+
+	val = readl(S3C_WINCON0 + (0x04 * win_num));
+	val &= ~(S3C_WINCONx_BPPMODE_F_MASK | S3C_WINCONx_BLD_PIX_MASK);
+	val |= S3C_WINCONx_ALPHA_SEL_1;
+		
+	switch (bpp) {
+	case 1:
+	case 2:
+	case 4:
+	case 8:
+		s3c_fimd.bytes_per_pixel = 1;
+		break;
+
+	case 16:
+		writel(val | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE, S3C_WINCON0 + (0x04 * win_num));
+		var->bits_per_pixel = bpp;
+		s3c_fimd.bytes_per_pixel = 2;
+		break;
+
+	case 24:
+		writel(val | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE, S3C_WINCON0 + (0x04 * win_num));
+		var->bits_per_pixel = bpp;
+		s3c_fimd.bytes_per_pixel = 4;
+		break;
+
+	case 25:
+		writel(val | S3C_WINCONx_BPPMODE_F_25BPP_A888 | S3C_WINCONx_BLD_PIX_PLANE, S3C_WINCON0 + (0x04 * win_num));
+		var->bits_per_pixel = bpp;
+		s3c_fimd.bytes_per_pixel = 4;
+		break;
+
+	case 28:
+		writel(val | S3C_WINCONx_BPPMODE_F_28BPP_A888 | S3C_WINCONx_BLD_PIX_PIXEL, S3C_WINCON0 + (0x04 * win_num));
+		var->bits_per_pixel = bpp;
+		s3c_fimd.bytes_per_pixel = 4;
+		break;
+
+	case 32:
+		var->bits_per_pixel = bpp;
+		s3c_fimd.bytes_per_pixel = 4;
+		break;
+	}
+
+	return 0;
+}
+
+void s3cfb_stop_lcd(void)
+{
+	unsigned long flags;
+	unsigned long tmp;
+
+	local_irq_save(flags);
+
+	tmp = readl(S3C_VIDCON0);
+	writel(tmp & ~(S3C_VIDCON0_ENVID_ENABLE | S3C_VIDCON0_ENVID_F_ENABLE), S3C_VIDCON0);
+
+	local_irq_restore(flags);
+}
+
+EXPORT_SYMBOL(s3cfb_stop_lcd);
+
+void s3cfb_start_lcd(void)
+{
+	unsigned long flags;
+	unsigned long tmp;
+
+	local_irq_save(flags);
+
+	tmp = readl(S3C_VIDCON0);
+	writel(tmp | S3C_VIDCON0_ENVID_ENABLE | S3C_VIDCON0_ENVID_F_ENABLE, S3C_VIDCON0);
+
+	local_irq_restore(flags);
+}
+
+EXPORT_SYMBOL(s3cfb_start_lcd);
+
+void s3cfb_set_clock(unsigned int clkval)
+{
+	unsigned int tmp;
+
+	tmp = readl(S3C_VIDCON0);
+
+	tmp &= ~(0x1 << 4);
+	tmp &= ~(0xff << 6);
+
+	writel(tmp | (clkval << 6) | (1 << 4), S3C_VIDCON0);
+}
+
+EXPORT_SYMBOL(s3cfb_set_clock);
+
+int s3cfb_init_win(s3c_fb_info_t *fbi, int bpp, int left_x, int top_y, int width, int height, int onoff)
+{
+	s3cfb_onoff_win(fbi, OFF);
+	s3cfb_set_bpp(fbi, bpp);
+	s3cfb_set_win_position(fbi, left_x, top_y, width, height);
+	s3cfb_set_win_size(fbi, width, height);
+	s3cfb_set_fb_size(fbi);
+	s3cfb_onoff_win(fbi, onoff);
+
+	return 0;
+}
+
+int s3cfb_wait_for_vsync(void)
+{
+	int cnt;
+
+	cnt = s3c_fimd.vsync_info.count;
+	wait_event_interruptible_timeout(s3c_fimd.vsync_info.wait_queue, cnt != s3c_fimd.vsync_info.count, HZ / 10);
+
+  	return cnt;
+}
+
+static void s3cfb_update_palette(s3c_fb_info_t *fbi, unsigned int regno, unsigned int val)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	fbi->palette_buffer[regno] = val;
+
+	if (!fbi->palette_ready) {
+		fbi->palette_ready = 1;
+		s3c_fimd.palette_win = fbi->win_id;
+	}
+
+	local_irq_restore(flags);
+}
+
+static inline unsigned int s3cfb_chan_to_field(unsigned int chan, struct fb_bitfield bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf.length;
+
+	return chan << bf.offset;
+}
+
+static int s3cfb_setcolreg(unsigned int regno, unsigned int red, unsigned int green, unsigned int blue, unsigned int transp, struct fb_info *info)
+{
+	s3c_fb_info_t *fbi = (s3c_fb_info_t *)info;
+	unsigned int val = 0;
+
+	switch (fbi->fb.fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		if (regno < 16) {
+			unsigned int *pal = fbi->fb.pseudo_palette;
+
+			val = s3cfb_chan_to_field(red, fbi->fb.var.red);
+			val |= s3cfb_chan_to_field(green, fbi->fb.var.green);
+			val |= s3cfb_chan_to_field(blue, fbi->fb.var.blue);
+
+			pal[regno] = val;
+		}
+
+		break;
+
+	case FB_VISUAL_PSEUDOCOLOR:
+		if (regno < 256) {
+//			if (info->var.bits_per_pixel == 16) {
+				val = ((red >> 0) & 0xf800);
+				val |= ((green >> 5) & 0x07e0);
+				val |= ((blue >> 11) & 0x001f);
+//			} else if (info->var.bits_per_pixel == 24) {
+//				val = ((red << 8) & 0xff0000);
+//				val |= ((green >> 0) & 0xff00);
+//				val |= ((blue >> 8) & 0xff);
+//			}
+
+			DPRINTK("index = %d, val = 0x%08x\n", regno, val);
+			s3cfb_update_palette(fbi, regno, val);
+		}
+
+		break;
+
+	default:
+		return 1;	/* unknown type */
+	}
+
+	return 0;
+}
+
+/* sysfs export of baclight control */
+static int s3cfb_sysfs_show_lcd_power(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", s3c_fimd.lcd_power);
+}
+
+static int s3cfb_sysfs_store_lcd_power(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
+{
+	if (len < 1)
+		return -EINVAL;
+
+	if (strnicmp(buf, "on", 2) == 0 || strnicmp(buf, "1", 1) == 0)
+		{
+		s3cfb_set_lcd_power(1);
+		s3cfb_set_backlight_level(100);
+		s3cfb_set_backlight_power(1);
+		}
+	else if (strnicmp(buf, "off", 3) == 0 || strnicmp(buf, "0", 1) == 0)
+		s3cfb_set_lcd_power(0);
+	else
+		return -EINVAL;
+
+	return len;
+}
+
+static int s3cfb_sysfs_show_backlight_power(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", s3c_fimd.backlight_power);
+}
+
+static int s3cfb_sysfs_store_backlight_power(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
+{
+	if (len < 1)
+		return -EINVAL;
+
+	if (strnicmp(buf, "on", 2) == 0 || strnicmp(buf, "1", 1) == 0)
+		s3cfb_set_backlight_power(1);
+	else if (strnicmp(buf, "off", 3) == 0 || strnicmp(buf, "0", 1) == 0)
+		s3cfb_set_backlight_power(0);
+	else
+		return -EINVAL;
+
+	return len;
+}
+
+static int s3cfb_sysfs_show_backlight_level(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", s3c_fimd.backlight_level);
+}
+
+static int s3cfb_sysfs_store_backlight_level(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
+{
+	unsigned long value = simple_strtoul(buf, NULL, 10);
+
+	if (value < s3c_fimd.backlight_min || value > s3c_fimd.backlight_max)
+		return -ERANGE;
+
+	s3cfb_set_backlight_level(value);
+
+	return len;
+}
+
+static DEVICE_ATTR(lcd_power, 0777,
+			s3cfb_sysfs_show_lcd_power,
+			s3cfb_sysfs_store_lcd_power);
+
+static DEVICE_ATTR(backlight_power, 0644,
+			s3cfb_sysfs_show_backlight_power,
+			s3cfb_sysfs_store_backlight_power);
+
+static DEVICE_ATTR(backlight_level, 0644,
+			s3cfb_sysfs_show_backlight_level,
+			s3cfb_sysfs_store_backlight_level);
+
+struct fb_ops s3cfb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= s3cfb_check_var,
+	.fb_set_par	= s3cfb_set_par,
+	.fb_blank	= s3cfb_blank,
+	.fb_pan_display	= s3cfb_pan_display,
+	.fb_setcolreg	= s3cfb_setcolreg,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+#if defined(CONFIG_FRAMEBUFFER_CONSOLE)	
+	.fb_cursor	= soft_cursor,
+#endif
+	.fb_ioctl	= s3cfb_ioctl,
+};
+
+static void s3cfb_init_fbinfo(s3c_fb_info_t *finfo, char *drv_name, int index)
+{
+	int i = 0;
+
+	if (index == 0)
+		s3cfb_init_hw();
+
+	strcpy(finfo->fb.fix.id, drv_name);
+
+	finfo->win_id = index;
+	finfo->fb.fix.type = FB_TYPE_PACKED_PIXELS;
+	finfo->fb.fix.type_aux = 0;
+	finfo->fb.fix.xpanstep = 0;
+	finfo->fb.fix.ypanstep = 1;
+	finfo->fb.fix.ywrapstep = 0;
+	finfo->fb.fix.accel = FB_ACCEL_NONE;
+
+	finfo->fb.fbops = &s3cfb_ops;
+	finfo->fb.flags	= FBINFO_FLAG_DEFAULT;
+
+	finfo->fb.pseudo_palette = &finfo->pseudo_pal;
+
+	finfo->fb.var.nonstd = 0;
+	finfo->fb.var.activate = FB_ACTIVATE_NOW;
+	finfo->fb.var.accel_flags = 0;
+	finfo->fb.var.vmode = FB_VMODE_NONINTERLACED;
+
+	finfo->fb.var.xoffset = s3c_fimd.xoffset;
+	finfo->fb.var.yoffset = s3c_fimd.yoffset;
+
+	if (index < 2)
+	{
+		finfo->fb.var.height = s3c_fimd.height;
+		finfo->fb.var.width = s3c_fimd.width;
+
+		finfo->fb.var.xres = s3c_fimd.xres;
+		finfo->fb.var.yres = s3c_fimd.yres;
+
+		finfo->fb.var.xres_virtual = s3c_fimd.xres_virtual;
+		finfo->fb.var.yres_virtual = s3c_fimd.yres_virtual;
+	}
+	else
+	{
+		finfo->fb.var.height = s3c_fimd.osd_height;
+		finfo->fb.var.width = s3c_fimd.osd_width;
+
+		finfo->fb.var.xres = s3c_fimd.osd_xres;
+		finfo->fb.var.yres = s3c_fimd.osd_yres;
+
+		finfo->fb.var.xres_virtual = s3c_fimd.osd_xres_virtual;
+		finfo->fb.var.yres_virtual = s3c_fimd.osd_yres_virtual;
+	}
+
+	finfo->fb.var.bits_per_pixel = s3c_fimd.bpp;
+	finfo->fb.var.pixclock = s3c_fimd.pixclock;
+	finfo->fb.var.hsync_len = s3c_fimd.hsync_len;
+	finfo->fb.var.left_margin = s3c_fimd.left_margin;
+	finfo->fb.var.right_margin = s3c_fimd.right_margin;
+	finfo->fb.var.vsync_len = s3c_fimd.vsync_len;
+	finfo->fb.var.upper_margin = s3c_fimd.upper_margin;
+	finfo->fb.var.lower_margin = s3c_fimd.lower_margin;
+	finfo->fb.var.sync = s3c_fimd.sync;
+	finfo->fb.var.grayscale = s3c_fimd.cmap_grayscale;
+	
+	finfo->fb.fix.smem_len = finfo->fb.var.xres_virtual * finfo->fb.var.yres_virtual * s3c_fimd.bytes_per_pixel;
+
+	finfo->fb.fix.line_length = finfo->fb.var.xres * s3c_fimd.bytes_per_pixel;
+
+#if !defined(CONFIG_FB_S3C_VIRTUAL_SCREEN) && defined(CONFIG_FB_S3C_DOUBLE_BUFFERING)
+	if (index < 2)
+		finfo->fb.fix.smem_len *= 2;
+#endif
+
+	for (i = 0; i < 256; i++)
+		finfo->palette_buffer[i] = S3C_FB_PALETTE_BUFF_CLEAR;
+}
+
+/*
+ *  Probe
+ */
+static int __init s3cfb_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct fb_info *fbinfo;
+	s3c_fb_info_t *info;
+
+	char driver_name[] = "s3cfb";
+	int index = 0, ret, size;
+
+	fbinfo = framebuffer_alloc(sizeof(s3c_fb_info_t), &pdev->dev);
+
+	if (!fbinfo)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, fbinfo);
+
+	info = fbinfo->par;
+	info->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to get memory registers\n");
+		ret = -ENXIO;
+		goto dealloc_fb;
+	}
+
+	size = (res->end - res->start) + 1;
+	info->mem = request_mem_region(res->start, size, pdev->name);
+
+	if (info->mem == NULL) {
+		dev_err(&pdev->dev, "failed to get memory region\n");
+		ret = -ENOENT;
+		goto dealloc_fb;
+	}
+
+	info->io = ioremap(res->start, size);
+
+	if (info->io == NULL) {
+		dev_err(&pdev->dev, "ioremap() of registers failed\n");
+		ret = -ENXIO;
+		goto release_mem;
+	}
+
+	s3cfb_pre_init();
+	s3cfb_set_backlight_power(1);
+	s3cfb_set_lcd_power(1);
+	s3cfb_set_backlight_level(S3C_FB_DEFAULT_BACKLIGHT_LEVEL);
+
+#if defined(CONFIG_PLAT_S5PC1XX)
+	info->clk = clk_get(NULL, "hclkd1");
+#else
+	info->clk = clk_get(NULL, "lcd");
+#endif
+
+	if (!info->clk || IS_ERR(info->clk)) {
+		printk(KERN_INFO "failed to get lcd clock source\n");
+		ret =  -ENOENT;
+		goto release_irq;
+	}
+
+	clk_enable(info->clk);
+	printk("S3C_LCD clock got enabled :: %ld.%03ld Mhz\n", PRINT_MHZ(clk_get_rate(info->clk)));
+
+	s3c_fimd.vsync_info.count = 0;
+	init_waitqueue_head(&s3c_fimd.vsync_info.wait_queue);
+
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+	ret = request_irq(IRQ_S3C2443_LCD3, s3cfb_irq, 0, "s3c-lcd", pdev);
+
+#elif defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+	ret = request_irq(IRQ_LCD_VSYNC, s3cfb_irq, 0, "s3c-lcd", pdev);
+
+#elif defined(CONFIG_PLAT_S5PC1XX)
+	ret = request_irq(IRQ_LCD0, s3cfb_irq, 0, "s3c-lcd", pdev);
+
+#endif
+
+	if (ret != 0) {
+		printk("Failed to install irq (%d)\n", ret);
+		goto release_irq;
+	}
+
+	msleep(5);
+
+	for (index = 0; index < S3C_FB_NUM; index++) {
+		s3c_fb_info[index].mem = info->mem;
+		s3c_fb_info[index].io = info->io;
+		s3c_fb_info[index].clk = info->clk;
+
+		s3cfb_init_fbinfo(&s3c_fb_info[index], driver_name, index);
+
+		/* Initialize video memory */
+		ret = s3cfb_map_video_memory(&s3c_fb_info[index]);
+
+		if (ret) {
+			printk("Failed to allocate video RAM: %d\n", ret);
+			ret = -ENOMEM;
+			goto release_clock;
+		}
+
+		ret = s3cfb_init_registers(&s3c_fb_info[index]);
+		ret = s3cfb_check_var(&s3c_fb_info[index].fb.var, &s3c_fb_info[index].fb);
+
+		if (index < 2){
+			if (fb_alloc_cmap(&s3c_fb_info[index].fb.cmap, 256, 0) < 0)
+				goto dealloc_fb;
+		} else {
+			if (fb_alloc_cmap(&s3c_fb_info[index].fb.cmap, 16, 0) < 0)
+				goto dealloc_fb;
+		}
+
+		ret = register_framebuffer(&s3c_fb_info[index].fb);
+
+		if (ret < 0) {
+			printk(KERN_ERR "Failed to register framebuffer device: %d\n", ret);
+			goto free_video_memory;
+		}
+
+		printk(KERN_INFO "fb%d: %s frame buffer device\n", s3c_fb_info[index].fb.node, s3c_fb_info[index].fb.fix.id);
+	}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	info->early_suspend.suspend = s3cfb_early_suspend;
+	info->early_suspend.resume = s3cfb_late_resume;
+	info->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB;
+	register_early_suspend(&info->early_suspend);
+
+	early_suspend_ptr = &info->early_suspend;
+#endif	/* CONFIG_HAS_EARLYSUSPEND */
+	/* create device files */
+	ret = device_create_file(&(pdev->dev), &dev_attr_backlight_power);
+
+	if (ret < 0)
+		printk(KERN_WARNING "s3cfb: failed to add entries\n");
+
+	ret = device_create_file(&(pdev->dev), &dev_attr_backlight_level);
+
+	if (ret < 0)
+		printk(KERN_WARNING "s3cfb: failed to add entries\n");
+
+	ret = device_create_file(&(pdev->dev), &dev_attr_lcd_power);
+
+	if (ret < 0)
+		printk(KERN_WARNING "s3cfb: failed to add entries\n");
+
+	return 0;
+
+free_video_memory:
+	s3cfb_unmap_video_memory(&s3c_fb_info[index]);
+
+release_clock:
+	clk_disable(info->clk);
+	clk_put(info->clk);
+
+release_mem:
+	release_resource(info->mem);
+	kfree(info->mem);
+
+release_irq:
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+	free_irq(IRQ_S3C2443_LCD3, &info);
+
+#elif defined(CONFIG_CPU_S3C6400)|| defined(CONFIG_CPU_S3C6410)
+	free_irq(IRQ_LCD_VSYNC, &info);
+#endif
+
+dealloc_fb:
+	framebuffer_release(&s3c_fb_info[index].fb);
+	return ret;
+}
+
+/*
+ *  Remove
+ */
+static int s3cfb_remove(struct platform_device *pdev)
+{
+	struct fb_info *fbinfo = platform_get_drvdata(pdev);
+	s3c_fb_info_t *info = fbinfo->par;
+	int index = 0, irq;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&info->early_suspend);
+#endif	/* CONFIG_HAS_EARLYSUSPEND */
+	s3cfb_stop_lcd();
+	msleep(1);
+
+	if (info->clk) {
+		clk_disable(info->clk);
+		clk_put(info->clk);
+	 	info->clk = NULL;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	release_resource(info->mem);
+
+	for (index = 0; index < S3C_FB_NUM; index++) {
+		s3cfb_unmap_video_memory((s3c_fb_info_t *) &s3c_fb_info[index]);
+		free_irq(irq, &s3c_fb_info[index]);
+		unregister_framebuffer(&info[index].fb);
+	}
+
+	return 0;
+}
+
+static struct platform_driver s3cfb_driver = {
+	.probe		= s3cfb_probe,
+	.remove		= s3cfb_remove,
+	.suspend	= s3cfb_suspend,
+	.resume		= s3cfb_resume,
+	.shutdown	= s3cfb_shutdown,
+        .driver		= {
+		.name	= "s3c-lcd",
+		.owner	= THIS_MODULE,
+	},
+};
+
+int __devinit s3cfb_init(void)
+{
+	return platform_driver_register(&s3cfb_driver);
+}
+static void __exit s3cfb_cleanup(void)
+{
+	platform_driver_unregister(&s3cfb_driver);
+}
+
+module_init(s3cfb_init);
+module_exit(s3cfb_cleanup);
+
+MODULE_AUTHOR("Jinsung Yang");
+MODULE_DESCRIPTION("S3C Framebuffer Driver");
+MODULE_LICENSE("GPL");
+
diff -Nur linux-2.6.29/drivers/video/samsung/s3cfb_fimd4x.c linux-2.6.29-spica/drivers/video/samsung/s3cfb_fimd4x.c
--- linux-2.6.29/drivers/video/samsung/s3cfb_fimd4x.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/video/samsung/s3cfb_fimd4x.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,2150 @@
+/*
+ * drivers/video/samsung/s3cfb_fimd4x.c
+ *
+ * $Id: s3cfb_fimd4x.c,v 1.2 2008/11/17 23:44:28 jsgood Exp $
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/string.h>
+#include <linux/ioctl.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/earlysuspend.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <plat/gpio-cfg.h>
+#include <plat/regs-clock.h>
+#include <plat/regs-lcd.h>
+#include <plat/regs-gpio.h>
+
+#include <mach/map.h>
+#include <linux/i2c/pmic.h>
+
+#ifdef CONFIG_S3C64XX_DOMAIN_GATING
+#define USE_LCD_DOMAIN_GATING
+#endif /* CONFIG_S3C64XX_DOMAIN_GATING */
+
+#if defined(CONFIG_PM)
+#include <plat/pm.h>
+#include <plat/power-clock-domain.h>
+extern int backlight_power;
+#endif
+
+#include "s3cfb.h"
+
+s3c_fimd_info_t s3c_fimd = {
+// KSS_2009-09-03 : Change LCD Dot Clk
+#ifndef S3C_FB_USE_CLK_DIRECTED
+	.vidcon0 = S3C_VIDCON0_INTERLACE_F_PROGRESSIVE | S3C_VIDCON0_VIDOUT_RGB_IF | S3C_VIDCON0_L1_DATA16_SUB_16_MODE | \
+	           S3C_VIDCON0_L0_DATA16_MAIN_16_MODE | S3C_VIDCON0_PNRMODE_RGB_P | \
+	           S3C_VIDCON0_CLKVALUP_ALWAYS | S3C_VIDCON0_CLKDIR_DIVIDED | S3C_VIDCON0_CLKSEL(1) | \
+	           S3C_VIDCON0_ENVID_DISABLE | S3C_VIDCON0_ENVID_F_DISABLE,
+#else
+	.vidcon0 = S3C_VIDCON0_INTERLACE_F_PROGRESSIVE | S3C_VIDCON0_VIDOUT_RGB_IF | S3C_VIDCON0_L1_DATA16_SUB_16_MODE | \
+	           S3C_VIDCON0_L0_DATA16_MAIN_16_MODE | S3C_VIDCON0_PNRMODE_RGB_P | \
+	           S3C_VIDCON0_CLKVALUP_ALWAYS | S3C_VIDCON0_CLKDIR_DIRECTED | S3C_VIDCON0_CLKSEL(1) | \
+	           S3C_VIDCON0_ENVID_DISABLE | S3C_VIDCON0_ENVID_F_DISABLE,
+#endif
+// End of KSS_2009-09-03
+	.dithmode = (S3C_DITHMODE_RDITHPOS_5BIT | S3C_DITHMODE_GDITHPOS_6BIT | S3C_DITHMODE_BDITHPOS_5BIT ) & S3C_DITHMODE_DITHERING_DISABLE,
+
+#if defined (CONFIG_FB_S3C_BPP_8)
+	.wincon0 =  S3C_WINCONx_BYTSWP_ENABLE | S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BPPMODE_F_8BPP_PAL,
+	.wincon1 =  S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.bpp = S3C_FB_PIXEL_BPP_8,
+	.bytes_per_pixel = 1,
+	.wpalcon = S3C_WPALCON_W0PAL_16BIT,
+
+#elif defined (CONFIG_FB_S3C_BPP_16)
+	.wincon0 = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_BUFSEL_0 | S3C_WINCONx_BUFAUTOEN_DISABLE | \
+	           S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+	           S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.wincon1 = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_BUFSEL_0 | S3C_WINCONx_BUFAUTOEN_DISABLE | \
+	           S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+	           S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_BPPMODE_F_16BPP_565 | \
+	           S3C_WINCONx_ALPHA_SEL_1 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.wincon2 = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | \
+	           S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BURSTLEN_16WORD | \
+	           S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_ALPHA_SEL_1 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.wincon3 = S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+	           S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BLD_PIX_PLANE | \
+	           S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_ALPHA_SEL_1 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.wincon4 = S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+	           S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BLD_PIX_PLANE |
+	           S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_ALPHA_SEL_1 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.bpp = S3C_FB_PIXEL_BPP_16,
+	.bytes_per_pixel = 2,
+	.wpalcon = S3C_WPALCON_W0PAL_16BIT,
+
+#elif defined (CONFIG_FB_S3C_BPP_24)
+	.wincon0 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888,
+	.wincon1 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.wincon2 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.wincon3 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.wincon4 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.bpp = S3C_FB_PIXEL_BPP_24,
+	.bytes_per_pixel = 4,
+	.wpalcon = S3C_WPALCON_W0PAL_24BIT,
+#endif
+
+	.vidosd1c = S3C_VIDOSDxC_ALPHA1_B(S3C_FB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_G(S3C_FB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_R(S3C_FB_MAX_ALPHA_LEVEL),
+	.vidosd2c = S3C_VIDOSDxC_ALPHA1_B(S3C_FB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_G(S3C_FB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_R(S3C_FB_MAX_ALPHA_LEVEL),
+	.vidosd3c = S3C_VIDOSDxC_ALPHA1_B(S3C_FB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_G(S3C_FB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_R(S3C_FB_MAX_ALPHA_LEVEL),
+	.vidosd4c = S3C_VIDOSDxC_ALPHA1_B(S3C_FB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_G(S3C_FB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_R(S3C_FB_MAX_ALPHA_LEVEL),
+
+	.vidintcon0 = S3C_VIDINTCON0_FRAMESEL0_VSYNC | S3C_VIDINTCON0_FRAMESEL1_NONE | S3C_VIDINTCON0_INTFRMEN_DISABLE | \
+	              S3C_VIDINTCON0_FIFOSEL_WIN0 | S3C_VIDINTCON0_FIFOLEVEL_25 | S3C_VIDINTCON0_INTFIFOEN_DISABLE | S3C_VIDINTCON0_INTEN_ENABLE,
+	.vidintcon1 = 0,
+
+	.xoffset = 0,
+	.yoffset = 0,
+
+	.w1keycon0 = S3C_WxKEYCON0_KEYBLEN_DISABLE | S3C_WxKEYCON0_KEYEN_F_DISABLE | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE | S3C_WxKEYCON0_COMPKEY(0x0),
+	.w1keycon1 = S3C_WxKEYCON1_COLVAL(0xffffff),
+	.w2keycon0 = S3C_WxKEYCON0_KEYBLEN_DISABLE | S3C_WxKEYCON0_KEYEN_F_DISABLE | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE | S3C_WxKEYCON0_COMPKEY(0x0),
+	.w2keycon1 = S3C_WxKEYCON1_COLVAL(0xffffff),
+	.w3keycon0 = S3C_WxKEYCON0_KEYBLEN_DISABLE | S3C_WxKEYCON0_KEYEN_F_DISABLE | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE | S3C_WxKEYCON0_COMPKEY(0x0),
+	.w3keycon1 = S3C_WxKEYCON1_COLVAL(0xffffff),
+	.w4keycon0 = S3C_WxKEYCON0_KEYBLEN_DISABLE | S3C_WxKEYCON0_KEYEN_F_DISABLE | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE | S3C_WxKEYCON0_COMPKEY(0x0),
+	.w4keycon1 = S3C_WxKEYCON1_COLVAL(0xffffff),
+
+	.sync = 0,
+	.cmap_static = 1,
+
+	.vs_offset = S3C_FB_DEFAULT_DISPLAY_OFFSET,
+	.brightness = S3C_FB_DEFAULT_BRIGHTNESS,
+	.backlight_level = S3C_FB_DEFAULT_BACKLIGHT_LEVEL,
+	.backlight_power = 1,
+	.lcd_power = 1,
+};
+
+#if  defined(CONFIG_S3C6410_PWM)
+void s3cfb_set_brightness(int val)
+{
+	int channel = 1;	/* must use channel-1 */
+	int usec = 0;		/* don't care value */
+	unsigned long tcnt = 1000;
+	unsigned long tcmp = 0;
+
+	if (val < 0)
+		val = 0;
+
+	if (val > S3C_FB_MAX_BRIGHTNESS)
+		val = S3C_FB_MAX_BRIGHTNESS;
+
+	s3c_fimd.brightness = val;
+	tcmp = val * 5;
+
+	s3c6410_timer_setup (channel, usec, tcnt, tcmp);
+}
+#endif
+
+#if defined(CONFIG_FB_S3C_DOUBLE_BUFFERING)
+
+static void s3cfb_change_buff(int req_win, int req_fb)
+{
+	switch (req_win) {
+	case 0:
+		if (req_fb == 0)
+			s3c_fimd.wincon0 &= ~S3C_WINCONx_BUFSEL_MASK;
+		else
+			s3c_fimd.wincon0 |= S3C_WINCONx_BUFSEL_1;
+
+		writel(s3c_fimd.wincon0 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON0);
+		break;
+
+	case 1:
+		if (req_fb == 0)
+			s3c_fimd.wincon1 &= ~S3C_WINCONx_BUFSEL_MASK;
+		else
+			s3c_fimd.wincon1 |= S3C_WINCONx_BUFSEL_1;
+
+		writel(s3c_fimd.wincon1 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON1);
+		break;
+
+	default:
+		break;
+	}
+}
+
+#endif
+
+#if defined(CONFIG_FB_S3C_VIRTUAL_SCREEN)
+
+static int s3cfb_vs_start(s3c_fb_info_t *fbi)
+{
+	switch(fbi->win_id)
+	{
+		case 0 :
+			s3c_fimd.wincon0 &= ~(S3C_WINCONx_ENWIN_F_ENABLE);
+			writel(s3c_fimd.wincon0 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON0);
+			break;
+		case 1 :
+			s3c_fimd.wincon1 &= ~(S3C_WINCONx_ENWIN_F_ENABLE);
+			writel(s3c_fimd.wincon1 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON1);
+			break;
+		case 2 :
+			s3c_fimd.wincon2 &= ~(S3C_WINCONx_ENWIN_F_ENABLE);
+			writel(s3c_fimd.wincon2 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON2);
+			break;
+		case 3 :
+			s3c_fimd.wincon3 &= ~(S3C_WINCONx_ENWIN_F_ENABLE);
+			writel(s3c_fimd.wincon3 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON3);
+			break;
+		case 4 :
+			s3c_fimd.wincon4 &= ~(S3C_WINCONx_ENWIN_F_ENABLE);
+			writel(s3c_fimd.wincon4 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON4);
+			break;
+		default : 
+			printk("%s::invalid win_num(%d)\n", __func__, fbi->win_id);
+			return -EINVAL;
+	}
+
+	fbi->fb.var.xoffset = s3c_fimd.xoffset;
+	fbi->fb.var.yoffset = s3c_fimd.yoffset;
+	
+	return 0;
+}
+
+static int s3cfb_vs_stop(s3c_fb_info_t *fbi)
+{		
+	fbi->fb.var.xoffset = 0;
+	fbi->fb.var.yoffset = 0;
+
+	switch(fbi->win_id)
+	{
+		case 0 :
+			s3c_fimd.vidw00add0b0 = fbi->screen_dma_f1;
+			s3c_fimd.vidw00add0b1 = fbi->screen_dma_f2;
+			writel(s3c_fimd.vidw00add0b0, S3C_VIDW00ADD0B0);
+			writel(s3c_fimd.vidw00add0b1, S3C_VIDW00ADD0B1);
+			break;
+		case 1 :
+			s3c_fimd.vidw01add0b0 = fbi->screen_dma_f1;
+			s3c_fimd.vidw01add0b1 = fbi->screen_dma_f2;
+			writel(s3c_fimd.vidw01add0b0, S3C_VIDW01ADD0B0);
+			writel(s3c_fimd.vidw01add0b1, S3C_VIDW01ADD0B1);
+			break;
+		case 2 :
+			s3c_fimd.vidw02add0 = fbi->screen_dma_f1;
+			s3c_fimd.vidw02add1 = fbi->screen_dma_f2;
+			writel(s3c_fimd.vidw02add0, S3C_VIDW02ADD0);
+			writel(s3c_fimd.vidw02add1, S3C_VIDW02ADD0);
+			break;
+		case 3 :
+			s3c_fimd.vidw03add0 = fbi->screen_dma_f1;
+			s3c_fimd.vidw03add1 = fbi->screen_dma_f2;
+			writel(s3c_fimd.vidw03add0, S3C_VIDW03ADD0);
+			writel(s3c_fimd.vidw03add1, S3C_VIDW03ADD1);
+			break;
+		case 4 :
+			s3c_fimd.vidw04add0 = fbi->screen_dma_f1;
+			s3c_fimd.vidw04add1 = fbi->screen_dma_f2;
+			writel(s3c_fimd.vidw04add0, S3C_VIDW04ADD0);
+			writel(s3c_fimd.vidw04add1, S3C_VIDW04ADD1);
+			break;
+		default : 
+			printk("%s::invalid fbi->win_id(%d)\n", __func__, fbi->win_id);
+			return -EINVAL;
+	}
+	
+	return 0;
+}
+
+static int s3cfb_vs_set(s3c_fb_info_t *fbi)
+{
+	int page_width;
+	int offset;
+	unsigned int frame_size;
+	unsigned int start;
+
+	page_width =  s3c_fimd.xres * s3c_fimd.bytes_per_pixel;
+	offset     = (s3c_fimd.xres_virtual - s3c_fimd.xres) * s3c_fimd.bytes_per_pixel;
+	frame_size = (page_width + offset) * (s3c_fimd.yres);
+	start      = fbi->fb.fix.line_length * fbi->fb.var.yoffset;
+
+	switch(fbi->win_id)
+	{
+		case 0 :
+			// size
+			s3c_fimd.vidw00add2 = S3C_VIDWxxADD2_OFFSIZE_F(offset) | S3C_VIDWxxADD2_PAGEWIDTH_F(page_width);
+			writel(s3c_fimd.vidw00add2, S3C_VIDW00ADD2);
+			
+			// start address
+			s3c_fimd.vidw00add0b0 = fbi->screen_dma_f1 + start;
+			s3c_fimd.vidw00add0b1 = fbi->screen_dma_f2 + start;
+			writel(s3c_fimd.vidw00add0b0, S3C_VIDW00ADD0B0);
+			writel(s3c_fimd.vidw00add0b1, S3C_VIDW00ADD0B1);
+
+			// end address
+			s3c_fimd.vidw00add1b0 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw00add0b0 + frame_size);
+			s3c_fimd.vidw00add1b1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw00add0b1 + frame_size);
+			writel(s3c_fimd.vidw00add1b0, S3C_VIDW00ADD1B0);
+			writel(s3c_fimd.vidw00add1b1, S3C_VIDW00ADD1B1);
+			break;
+
+		case 1 :
+			// size
+			s3c_fimd.vidw01add2 = S3C_VIDWxxADD2_OFFSIZE_F(offset) | S3C_VIDWxxADD2_PAGEWIDTH_F(page_width);
+			writel(s3c_fimd.vidw01add2, S3C_VIDW01ADD2);
+			
+			// start address
+			s3c_fimd.vidw01add0b0 = fbi->screen_dma_f1 + start;
+			s3c_fimd.vidw01add0b1 = fbi->screen_dma_f2 + start;
+			writel(s3c_fimd.vidw01add0b0, S3C_VIDW01ADD0B0);
+			writel(s3c_fimd.vidw01add0b1, S3C_VIDW01ADD0B1);
+
+			// end address
+			s3c_fimd.vidw01add1b0 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw01add0b0 + frame_size);
+			s3c_fimd.vidw01add1b1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw01add0b1 + frame_size);
+			writel(s3c_fimd.vidw01add1b0, S3C_VIDW01ADD1B0);
+			writel(s3c_fimd.vidw01add1b1, S3C_VIDW01ADD1B1);
+			break;
+			
+		case 2 :
+			// size
+			s3c_fimd.vidw02add2 = S3C_VIDWxxADD2_OFFSIZE_F(offset) | S3C_VIDWxxADD2_PAGEWIDTH_F(page_width);
+			writel(s3c_fimd.vidw02add2, S3C_VIDW02ADD2);
+			
+			// start address
+			s3c_fimd.vidw02add0 = fbi->screen_dma_f1 + start;
+			writel(s3c_fimd.vidw02add0, S3C_VIDW02ADD0);
+			
+			// end address
+			s3c_fimd.vidw02add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw02add0 + frame_size);
+			writel(s3c_fimd.vidw02add1, S3C_VIDW02ADD1);
+			break;
+
+		case 3 :
+			// size
+			s3c_fimd.vidw03add2 = S3C_VIDWxxADD2_OFFSIZE_F(offset) | S3C_VIDWxxADD2_PAGEWIDTH_F(page_width);
+			writel(s3c_fimd.vidw03add2, S3C_VIDW02ADD2);
+			
+			// start address
+			s3c_fimd.vidw03add0 = fbi->screen_dma_f1 + start;
+			writel(s3c_fimd.vidw03add0, S3C_VIDW03ADD0);
+			
+			// end address
+			s3c_fimd.vidw03add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw03add0 + frame_size);
+			writel(s3c_fimd.vidw03add1, S3C_VIDW03ADD1);
+			break;
+		case 4 :
+			// size
+			s3c_fimd.vidw04add2 = S3C_VIDWxxADD2_OFFSIZE_F(offset) | S3C_VIDWxxADD2_PAGEWIDTH_F(page_width);
+			writel(s3c_fimd.vidw04add2, S3C_VIDW04ADD2);
+			
+			// start address
+			s3c_fimd.vidw04add0 = fbi->screen_dma_f1 + start;
+			writel(s3c_fimd.vidw04add0, S3C_VIDW04ADD0);
+			
+			// end address
+			s3c_fimd.vidw02add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw04add0 + frame_size);
+			writel(s3c_fimd.vidw04add1, S3C_VIDW04ADD1);
+			break;
+
+		default :
+			printk("%s::invalid fbi->win_id(%d)\n", __func__, fbi->win_id);
+			return -EINVAL;
+			break;
+	}
+
+	return 0;
+}
+
+static int s3cfb_vs_move_left(s3c_fb_info_t *fbi)
+{
+	int page_width;
+	int offset;
+	int shift_value;
+	unsigned int shift_pixel;
+	unsigned int frame_size;
+
+	page_width  =  s3c_fimd.xres * s3c_fimd.bytes_per_pixel;
+	offset      = (s3c_fimd.xres_virtual - s3c_fimd.xres) * s3c_fimd.bytes_per_pixel;
+	
+	// get shift 
+	if (s3c_fimd.xoffset < s3c_fimd.vs_offset)
+		shift_value = s3c_fimd.xoffset;
+	else
+		shift_value = s3c_fimd.vs_offset;
+
+	s3c_fimd.xoffset -= shift_value;	
+	
+	shift_pixel = s3c_fimd.bytes_per_pixel * shift_value;
+	frame_size  = (page_width + offset) * (s3c_fimd.yres);
+	
+	switch(fbi->win_id)
+	{
+		case 0 :
+			// start address
+			s3c_fimd.vidw00add0b0 = s3c_fimd.vidw00add0b0 - shift_pixel;
+			s3c_fimd.vidw00add0b1 = s3c_fimd.vidw00add0b1 - shift_pixel;			
+			writel(s3c_fimd.vidw00add0b0, S3C_VIDW00ADD0B0);
+			writel(s3c_fimd.vidw00add0b1, S3C_VIDW00ADD0B1);
+
+			// end address
+			s3c_fimd.vidw00add1b0 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw00add0b0 + frame_size);
+			s3c_fimd.vidw00add1b1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw00add0b1 + frame_size);
+			writel(s3c_fimd.vidw00add1b0, S3C_VIDW00ADD1B0);
+			writel(s3c_fimd.vidw00add1b1, S3C_VIDW00ADD1B1);
+			break;
+
+		case 1 :
+			// start address
+			s3c_fimd.vidw01add0b0 = s3c_fimd.vidw01add0b0 - shift_pixel;
+			s3c_fimd.vidw01add0b1 = s3c_fimd.vidw01add0b1 - shift_pixel;			
+			writel(s3c_fimd.vidw01add0b0, S3C_VIDW01ADD0B0);
+			writel(s3c_fimd.vidw01add0b1, S3C_VIDW01ADD0B1);
+
+			// end address
+			s3c_fimd.vidw01add1b0 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw01add0b0 + frame_size);
+			s3c_fimd.vidw01add1b1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw01add0b1 + frame_size);
+			writel(s3c_fimd.vidw01add1b0, S3C_VIDW01ADD1B0);
+			writel(s3c_fimd.vidw01add1b1, S3C_VIDW01ADD1B1);
+			break;
+			
+		case 2 :		
+			// start address
+			s3c_fimd.vidw02add0 = s3c_fimd.vidw02add0 - shift_pixel;
+			writel(s3c_fimd.vidw02add0, S3C_VIDW02ADD0);
+			
+			// end address
+			s3c_fimd.vidw02add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw02add0 + frame_size);
+			writel(s3c_fimd.vidw02add1, S3C_VIDW02ADD1);
+			break;
+
+		case 3 :
+			// start address
+			s3c_fimd.vidw03add0 = s3c_fimd.vidw03add0 - shift_pixel;
+			writel(s3c_fimd.vidw03add0, S3C_VIDW03ADD0);
+			
+			// end address
+			s3c_fimd.vidw03add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw03add0 + frame_size);
+			writel(s3c_fimd.vidw03add1, S3C_VIDW03ADD1);
+			break;
+
+		case 4 :
+			// start address
+			s3c_fimd.vidw04add0 = s3c_fimd.vidw04add0 - shift_pixel;
+			writel(s3c_fimd.vidw04add0, S3C_VIDW04ADD0);
+			
+			// end address
+			s3c_fimd.vidw04add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw04add0 + frame_size);
+			writel(s3c_fimd.vidw04add1, S3C_VIDW04ADD1);
+			break;
+
+		default :
+			printk("%s::invalid fbi->win_id(%d)\n", __func__, fbi->win_id);
+			return -EINVAL;
+			break;
+	}
+	return 0;
+}
+
+static int s3cfb_vs_move_right(s3c_fb_info_t *fbi)
+{
+	int page_width;
+	int offset;
+	int shift_value;
+	unsigned int shift_pixel;
+	unsigned int frame_size;
+
+	page_width  =  s3c_fimd.xres * s3c_fimd.bytes_per_pixel;
+	offset      = (s3c_fimd.xres_virtual - s3c_fimd.xres) * s3c_fimd.bytes_per_pixel;
+
+	if ((s3c_fimd.vs_info.v_width - (s3c_fimd.xoffset + s3c_fimd.vs_info.width)) < (s3c_fimd.vs_offset))
+		shift_value = s3c_fimd.vs_info.v_width - (s3c_fimd.xoffset + s3c_fimd.vs_info.width);
+	else
+		shift_value = s3c_fimd.vs_offset;
+
+	s3c_fimd.xoffset += shift_value;
+
+	shift_pixel = s3c_fimd.bytes_per_pixel * shift_value;
+	frame_size  = (page_width + offset) * (s3c_fimd.yres);
+	
+	switch(fbi->win_id)
+	{
+		case 0 :
+			// start address
+			s3c_fimd.vidw00add0b0 = s3c_fimd.vidw00add0b0 + shift_pixel;
+			s3c_fimd.vidw00add0b1 = s3c_fimd.vidw00add0b1 + shift_pixel;			
+			writel(s3c_fimd.vidw00add0b0, S3C_VIDW00ADD0B0);
+			writel(s3c_fimd.vidw00add0b1, S3C_VIDW00ADD0B1);
+
+			// end address
+			s3c_fimd.vidw00add1b0 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw00add0b0 + frame_size);
+			s3c_fimd.vidw00add1b1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw00add0b1 + frame_size);
+			writel(s3c_fimd.vidw00add1b0, S3C_VIDW00ADD1B0);
+			writel(s3c_fimd.vidw00add1b1, S3C_VIDW00ADD1B1);
+			break;
+
+		case 1 :
+			// start address
+			s3c_fimd.vidw01add0b0 = s3c_fimd.vidw01add0b0 + shift_pixel;
+			s3c_fimd.vidw01add0b1 = s3c_fimd.vidw01add0b1 + shift_pixel;			
+			writel(s3c_fimd.vidw01add0b0, S3C_VIDW01ADD0B0);
+			writel(s3c_fimd.vidw01add0b1, S3C_VIDW01ADD0B1);
+
+			// end address
+			s3c_fimd.vidw01add1b0 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw01add0b0 + frame_size);
+			s3c_fimd.vidw01add1b1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw01add0b1 + frame_size);
+			writel(s3c_fimd.vidw01add1b0, S3C_VIDW01ADD1B0);
+			writel(s3c_fimd.vidw01add1b1, S3C_VIDW01ADD1B1);
+			break;
+			
+		case 2 :		
+			// start address
+			s3c_fimd.vidw02add0 = s3c_fimd.vidw02add0 + shift_pixel;
+			writel(s3c_fimd.vidw02add0, S3C_VIDW02ADD0);
+			
+			// end address
+			s3c_fimd.vidw02add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw02add0 + frame_size);
+			writel(s3c_fimd.vidw02add1, S3C_VIDW02ADD1);
+			break;
+
+		case 3 :
+			// start address
+			s3c_fimd.vidw03add0 = s3c_fimd.vidw03add0 + shift_pixel;
+			writel(s3c_fimd.vidw03add0, S3C_VIDW03ADD0);
+			
+			// end address
+			s3c_fimd.vidw03add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw03add0 + frame_size);
+			writel(s3c_fimd.vidw03add1, S3C_VIDW03ADD1);
+			break;
+
+		case 4 :
+			// start address
+			s3c_fimd.vidw04add0 = s3c_fimd.vidw04add0 + shift_pixel;
+			writel(s3c_fimd.vidw04add0, S3C_VIDW04ADD0);
+			
+			// end address
+			s3c_fimd.vidw04add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw04add0 + frame_size);
+			writel(s3c_fimd.vidw04add1, S3C_VIDW04ADD1);
+			break;
+
+		default :
+			printk("%s::invalid fbi->win_id(%d)\n", __func__, fbi->win_id);
+			return -EINVAL;
+			break;
+	}
+	return 0;
+}
+
+static int s3cfb_vs_move_up(s3c_fb_info_t *fbi)
+{
+	int page_width;
+	int offset;
+	int shift_value;
+	unsigned int shift_pixel;
+	unsigned int frame_size;
+
+	page_width  =  s3c_fimd.xres * s3c_fimd.bytes_per_pixel;
+	offset      = (s3c_fimd.xres_virtual - s3c_fimd.xres) * s3c_fimd.bytes_per_pixel;
+	
+	// get shift 
+	if (s3c_fimd.yoffset < s3c_fimd.vs_offset)
+		shift_value = s3c_fimd.yoffset;
+	else
+		shift_value = s3c_fimd.vs_offset;
+
+	s3c_fimd.yoffset -= shift_value;
+	
+	shift_pixel = (s3c_fimd.xres_virtual * s3c_fimd.bytes_per_pixel * shift_value);
+	frame_size  = (page_width + offset) * (s3c_fimd.yres);
+	
+	switch(fbi->win_id)
+	{
+		case 0 :
+			// start address
+			s3c_fimd.vidw00add0b0 = s3c_fimd.vidw00add0b0 - shift_pixel;
+			s3c_fimd.vidw00add0b1 = s3c_fimd.vidw00add0b1 - shift_pixel;			
+			writel(s3c_fimd.vidw00add0b0, S3C_VIDW00ADD0B0);
+			writel(s3c_fimd.vidw00add0b1, S3C_VIDW00ADD0B1);
+
+			// end address
+			s3c_fimd.vidw00add1b0 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw00add0b0 + frame_size);
+			s3c_fimd.vidw00add1b1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw00add0b1 + frame_size);
+			writel(s3c_fimd.vidw00add1b0, S3C_VIDW00ADD1B0);
+			writel(s3c_fimd.vidw00add1b1, S3C_VIDW00ADD1B1);
+			break;
+
+		case 1 :
+			// start address
+			s3c_fimd.vidw01add0b0 = s3c_fimd.vidw01add0b0 - shift_pixel;
+			s3c_fimd.vidw01add0b1 = s3c_fimd.vidw01add0b1 - shift_pixel;			
+			writel(s3c_fimd.vidw01add0b0, S3C_VIDW01ADD0B0);
+			writel(s3c_fimd.vidw01add0b1, S3C_VIDW01ADD0B1);
+
+			// end address
+			s3c_fimd.vidw01add1b0 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw01add0b0 + frame_size);
+			s3c_fimd.vidw01add1b1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw01add0b1 + frame_size);
+			writel(s3c_fimd.vidw01add1b0, S3C_VIDW01ADD1B0);
+			writel(s3c_fimd.vidw01add1b1, S3C_VIDW01ADD1B1);
+			break;
+			
+		case 2 :		
+			// start address
+			s3c_fimd.vidw02add0 = s3c_fimd.vidw02add0 - shift_pixel;
+			writel(s3c_fimd.vidw02add0, S3C_VIDW02ADD0);
+			
+			// end address
+			s3c_fimd.vidw02add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw02add0 + frame_size);
+			writel(s3c_fimd.vidw02add1, S3C_VIDW02ADD1);
+			break;
+
+		case 3 :
+			// start address
+			s3c_fimd.vidw03add0 = s3c_fimd.vidw03add0 - shift_pixel;
+			writel(s3c_fimd.vidw03add0, S3C_VIDW03ADD0);
+			
+			// end address
+			s3c_fimd.vidw03add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw03add0 + frame_size);
+			writel(s3c_fimd.vidw03add1, S3C_VIDW03ADD1);
+			break;
+
+		case 4 :
+			// start address
+			s3c_fimd.vidw04add0 = s3c_fimd.vidw04add0 - shift_pixel;
+			writel(s3c_fimd.vidw04add0, S3C_VIDW04ADD0);
+			
+			// end address
+			s3c_fimd.vidw04add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw04add0 + frame_size);
+			writel(s3c_fimd.vidw04add1, S3C_VIDW04ADD1);
+			break;
+
+		default :
+			printk("%s::invalid fbi->win_id(%d)\n", __func__, fbi->win_id);
+			return -EINVAL;
+			break;
+	}
+	return 0;
+}
+
+
+static int s3cfb_vs_move_down(s3c_fb_info_t *fbi)
+{
+	int page_width;
+	int offset;
+	int shift_value;
+	unsigned int shift_pixel;
+	unsigned int frame_size;
+
+	page_width  =  s3c_fimd.xres * s3c_fimd.bytes_per_pixel;
+	offset      = (s3c_fimd.xres_virtual - s3c_fimd.xres) * s3c_fimd.bytes_per_pixel;
+
+	if (s3c_fimd.yoffset < s3c_fimd.vs_offset)
+		shift_value = s3c_fimd.yoffset;
+	else
+		shift_value = s3c_fimd.vs_offset;
+
+	s3c_fimd.yoffset -= shift_value;
+
+	shift_pixel = (s3c_fimd.xres_virtual * s3c_fimd.bytes_per_pixel * shift_value);
+	frame_size  = (page_width + offset) * (s3c_fimd.yres);
+	
+	switch(fbi->win_id)
+	{
+		case 0 :
+			// start address
+			s3c_fimd.vidw00add0b0 = s3c_fimd.vidw00add0b0 + shift_pixel;
+			s3c_fimd.vidw00add0b1 = s3c_fimd.vidw00add0b1 + shift_pixel;			
+			writel(s3c_fimd.vidw00add0b0, S3C_VIDW00ADD0B0);
+			writel(s3c_fimd.vidw00add0b1, S3C_VIDW00ADD0B1);
+
+			// end address
+			s3c_fimd.vidw00add1b0 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw00add0b0 + frame_size);
+			s3c_fimd.vidw00add1b1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw00add0b1 + frame_size);
+			writel(s3c_fimd.vidw00add1b0, S3C_VIDW00ADD1B0);
+			writel(s3c_fimd.vidw00add1b1, S3C_VIDW00ADD1B1);
+			break;
+
+		case 1 :
+			// start address
+			s3c_fimd.vidw01add0b0 = s3c_fimd.vidw01add0b0 + shift_pixel;
+			s3c_fimd.vidw01add0b1 = s3c_fimd.vidw01add0b1 + shift_pixel;			
+			writel(s3c_fimd.vidw01add0b0, S3C_VIDW01ADD0B0);
+			writel(s3c_fimd.vidw01add0b1, S3C_VIDW01ADD0B1);
+
+			// end address
+			s3c_fimd.vidw01add1b0 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw01add0b0 + frame_size);
+			s3c_fimd.vidw01add1b1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw01add0b1 + frame_size);
+			writel(s3c_fimd.vidw01add1b0, S3C_VIDW01ADD1B0);
+			writel(s3c_fimd.vidw01add1b1, S3C_VIDW01ADD1B1);
+			break;
+			
+		case 2 :		
+			// start address
+			s3c_fimd.vidw02add0 = s3c_fimd.vidw02add0 + shift_pixel;
+			writel(s3c_fimd.vidw02add0, S3C_VIDW02ADD0);
+			
+			// end address
+			s3c_fimd.vidw02add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw02add0 + frame_size);
+			writel(s3c_fimd.vidw02add1, S3C_VIDW02ADD1);
+			break;
+
+		case 3 :
+			// start address
+			s3c_fimd.vidw03add0 = s3c_fimd.vidw03add0 + shift_pixel;
+			writel(s3c_fimd.vidw03add0, S3C_VIDW03ADD0);
+			
+			// end address
+			s3c_fimd.vidw03add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw03add0 + frame_size);
+			writel(s3c_fimd.vidw03add1, S3C_VIDW03ADD1);
+			break;
+
+		case 4 :
+			// start address
+			s3c_fimd.vidw04add0 = s3c_fimd.vidw04add0 + shift_pixel;
+			writel(s3c_fimd.vidw04add0, S3C_VIDW04ADD0);
+			
+			// end address
+			s3c_fimd.vidw04add1 = S3C_VIDWxxADD1_VBASEL_F(s3c_fimd.vidw04add0 + frame_size);
+			writel(s3c_fimd.vidw04add1, S3C_VIDW04ADD1);
+			break;
+
+		default :
+			printk("%s::invalid fbi->win_id(%d)\n", __func__, fbi->win_id);
+			return -EINVAL;
+			break;
+	}
+	return 0;
+}
+
+static int s3cfb_set_vs_registers(s3c_fb_info_t *fbi, int vs_cmd)
+{
+	int ret = 0;
+	
+	switch (vs_cmd)
+	{
+		case S3C_FB_VS_SET:
+			ret = s3cfb_vs_set(fbi);
+			break;
+
+		case S3C_FB_VS_MOVE_LEFT:
+			ret = s3cfb_vs_move_left(fbi);
+			break;
+
+		case S3C_FB_VS_MOVE_RIGHT:
+			ret = s3cfb_vs_move_right(fbi);
+			break;
+
+		case S3C_FB_VS_MOVE_UP:
+			ret = s3cfb_vs_move_up(fbi);
+			break;
+
+		case S3C_FB_VS_MOVE_DOWN:
+			ret = s3cfb_vs_move_down(fbi);			
+			break;
+
+		default:
+			return -EINVAL;
+	}
+
+	return ret;
+}
+
+#endif // CONFIG_FB_S3C_VIRTUAL_SCREEN
+
+void s3cfb_write_palette(s3c_fb_info_t *fbi)
+{
+	unsigned int i;
+	unsigned long ent;
+	unsigned int win_num = fbi->win_id;
+
+	fbi->palette_ready = 0;
+
+	writel((s3c_fimd.wpalcon | S3C_WPALCON_PALUPDATEEN), S3C_WPALCON);
+
+	for (i = 0; i < 256; i++) {
+		if ((ent = fbi->palette_buffer[i]) == S3C_FB_PALETTE_BUFF_CLEAR)
+			continue;
+
+		writel(ent, S3C_TFTPAL0(i) + 0x400 * win_num);
+
+		/* it seems the only way to know exactly
+		 * if the palette wrote ok, is to check
+		 * to see if the value verifies ok
+		 */
+		if (readl(S3C_TFTPAL0(i) + 0x400 * win_num) == ent) {
+			fbi->palette_buffer[i] = S3C_FB_PALETTE_BUFF_CLEAR;
+		} else {
+			fbi->palette_ready = 1;   /* retry */
+			printk("Retry writing into the palette\n");
+		}
+	}
+
+	writel(s3c_fimd.wpalcon, S3C_WPALCON);
+}
+
+irqreturn_t s3cfb_irq(int irqno, void *param)
+{
+	unsigned long buffer_size = 0;
+	unsigned int i;
+	unsigned int buffer_page_offset, buffer_page_width;
+	unsigned int fb_start_address, fb_end_address;
+
+	if (s3c_fb_info[s3c_fimd.palette_win].palette_ready)
+		s3cfb_write_palette(&s3c_fb_info[s3c_fimd.palette_win]);
+
+	for (i = 0; i < CONFIG_FB_S3C_NUM; i++)
+	{
+		if (s3c_fb_info[i].next_fb_info_change_req)
+		{
+			/* fb variable setting */
+			s3c_fb_info[i].fb.fix.smem_start   = s3c_fb_info[i].next_fb_info.phy_start_addr;
+
+			s3c_fb_info[i].fb.fix.line_length  =   s3c_fb_info[i].next_fb_info.xres_virtual
+			                                     * s3c_fimd.bytes_per_pixel;
+
+			s3c_fb_info[i].fb.fix.smem_len     =   s3c_fb_info[i].next_fb_info.xres_virtual
+			                                     * s3c_fb_info[i].next_fb_info.yres_virtual
+			                                     * s3c_fimd.bytes_per_pixel;
+
+			s3c_fb_info[i].fb.var.xres         = s3c_fb_info[i].next_fb_info.xres;
+			s3c_fb_info[i].fb.var.yres         = s3c_fb_info[i].next_fb_info.yres;
+			s3c_fb_info[i].fb.var.xres_virtual = s3c_fb_info[i].next_fb_info.xres_virtual;
+			s3c_fb_info[i].fb.var.yres_virtual = s3c_fb_info[i].next_fb_info.yres_virtual;
+			s3c_fb_info[i].fb.var.xoffset      = s3c_fb_info[i].next_fb_info.xoffset;
+			s3c_fb_info[i].fb.var.yoffset      = s3c_fb_info[i].next_fb_info.yoffset;
+			s3c_fb_info[i].lcd_offset_x        = s3c_fb_info[i].next_fb_info.lcd_offset_x;
+			s3c_fb_info[i].lcd_offset_y        = s3c_fb_info[i].next_fb_info.lcd_offset_y;
+
+
+			/* fb start / end address setting */
+			fb_start_address =   (s3c_fb_info[i].next_fb_info.phy_start_addr)
+			                   + (s3c_fb_info[i].fb.fix.line_length * s3c_fb_info[i].next_fb_info.yoffset)
+			                   + (s3c_fb_info[i].next_fb_info.xoffset * s3c_fimd.bytes_per_pixel);
+
+			fb_end_address   =   fb_start_address
+			                   + (s3c_fb_info[i].fb.fix.line_length * s3c_fb_info[i].next_fb_info.yres);
+
+			writel(fb_start_address, S3C_VIDW00ADD0B0 + 0x8 * i);
+			writel(S3C_VIDWxxADD1_VBASEL_F(fb_end_address), S3C_VIDW00ADD1B0 + 0x8 * i);
+
+			/* fb virtual / visible size setting */
+			buffer_page_width  = s3c_fb_info[i].next_fb_info.xres * s3c_fimd.bytes_per_pixel;
+			buffer_page_offset =  (s3c_fb_info[i].next_fb_info.xres_virtual - s3c_fb_info[i].next_fb_info.xres)
+			                     * s3c_fimd.bytes_per_pixel;
+
+			buffer_size =    S3C_VIDWxxADD2_OFFSIZE_F(buffer_page_offset)
+			              | (S3C_VIDWxxADD2_PAGEWIDTH_F(buffer_page_width));
+
+			writel(buffer_size, S3C_VIDW00ADD2 + 0x04 * i);
+
+			/* LCD position setting */
+			writel(  S3C_VIDOSDxA_OSD_LTX_F(s3c_fb_info[i].next_fb_info.lcd_offset_x)
+			       | S3C_VIDOSDxA_OSD_LTY_F(s3c_fb_info[i].next_fb_info.lcd_offset_y),
+				   S3C_VIDOSD0A+(0x10 * i));
+
+			writel(  S3C_VIDOSDxB_OSD_RBX_F(s3c_fb_info[i].next_fb_info.lcd_offset_x - 1 + s3c_fb_info[i].next_fb_info.xres)
+			       | S3C_VIDOSDxB_OSD_RBY_F(s3c_fb_info[i].next_fb_info.lcd_offset_y - 1 + s3c_fb_info[i].next_fb_info.yres),
+			       S3C_VIDOSD0B + (0x10 * i));
+
+
+			/* fb size setting */
+			if (i == 0)
+				writel(S3C_VIDOSD0C_OSDSIZE(s3c_fb_info[i].next_fb_info.xres * s3c_fb_info[i].next_fb_info.yres), S3C_VIDOSD0C);
+			else if (i == 1)
+				writel(S3C_VIDOSD0C_OSDSIZE(s3c_fb_info[i].next_fb_info.xres * s3c_fb_info[i].next_fb_info.yres), S3C_VIDOSD1D);
+			else if (i == 2)
+				writel(S3C_VIDOSD0C_OSDSIZE(s3c_fb_info[i].next_fb_info.xres * s3c_fb_info[i].next_fb_info.yres), S3C_VIDOSD2D);
+
+			s3c_fb_info[i].next_fb_info_change_req = 0;
+		}
+	}
+
+	/* for clearing the interrupt source */
+	writel(readl(S3C_VIDINTCON1), S3C_VIDINTCON1);
+
+	s3c_fimd.vsync_info.count++;
+	wake_up_interruptible(&s3c_fimd.vsync_info.wait_queue);
+
+	return IRQ_HANDLED;
+}
+
+void s3cfb_enable_local_post(int in_yuv)
+{
+	unsigned int value;
+
+	s3c_fimd.wincon0 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	value = S3C_WINCONx_ENLOCAL_POST | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	if (in_yuv)
+		value |= S3C_WINCONx_INRGB_YUV;
+
+	writel(s3c_fimd.wincon0 | value, S3C_WINCON0);
+}
+
+EXPORT_SYMBOL(s3cfb_enable_local_post);
+
+// andyEdit - 2.6.28 Camera driver
+static void s3cfb_check_line_count(void)
+{
+	int timeout = 30 * 5300;
+	unsigned int cfg;
+	int i;
+
+	i = 0;
+	do {
+		if (!(readl(S3C_VIDCON1) & 0x7ff0000))
+			break;
+		i++;
+	} while (i < timeout);
+
+	if (i == timeout) {
+		printk(KERN_WARNING "line count mismatch\n");
+
+		cfg = readl(S3C_VIDCON0);
+		cfg |= (S3C_VIDCON0_ENVID_F_ENABLE | S3C_VIDCON0_ENVID_ENABLE);
+		writel(cfg, S3C_VIDCON0);
+	}	
+}
+
+static void s3cfb_enable_local0(int in_yuv)
+{
+	unsigned int value;
+
+	s3c_fimd.wincon0 = readl(S3C_WINCON0);
+	s3c_fimd.wincon0 &= ~S3C_WINCONx_ENWIN_F_ENABLE;
+	writel(s3c_fimd.wincon0, S3C_WINCON0);	
+
+	s3c_fimd.wincon0 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	value = S3C_WINCONx_ENLOCAL | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	if (in_yuv)
+		value |= S3C_WINCONx_INRGB_YUV;
+
+	writel(s3c_fimd.wincon0 | value, S3C_WINCON0);
+}
+
+static void s3cfb_enable_local1(int in_yuv, int sel)
+{
+	unsigned int value;
+
+	s3c_fimd.wincon1 = readl(S3C_WINCON1);
+	s3c_fimd.wincon1 &= ~S3C_WINCONx_ENWIN_F_ENABLE;
+	writel(s3c_fimd.wincon1, S3C_WINCON1);
+
+	s3c_fimd.wincon1 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	s3c_fimd.wincon1 &= ~(S3C_WINCON1_LOCALSEL_MASK);
+	value = sel | S3C_WINCONx_ENLOCAL | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	if (in_yuv)
+		value |= S3C_WINCONx_INRGB_YUV;
+
+	writel(s3c_fimd.wincon1 | value, S3C_WINCON1);
+}
+
+static void s3cfb_enable_local2(int in_yuv, int sel)
+{
+	unsigned int value;
+
+	s3c_fimd.wincon2 = readl(S3C_WINCON2);
+	s3c_fimd.wincon2 &= ~S3C_WINCONx_ENWIN_F_ENABLE;
+	s3c_fimd.wincon2 &= ~S3C_WINCON2_LOCALSEL_MASK;
+	writel(s3c_fimd.wincon2, S3C_WINCON2);
+
+	s3c_fimd.wincon2 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	value = sel | S3C_WINCONx_ENLOCAL | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	if (in_yuv)
+		value |= S3C_WINCONx_INRGB_YUV;
+
+	writel(s3c_fimd.wincon2 | value, S3C_WINCON2);
+}
+
+void s3cfb_enable_local(int win, int in_yuv, int sel)
+{
+	s3cfb_check_line_count();
+
+	switch (win) {
+	case 0:
+		s3cfb_enable_local0(in_yuv);
+		break;
+
+	case 1:
+		s3cfb_enable_local1(in_yuv, sel);
+		break;
+
+	case 2:
+		s3cfb_enable_local2(in_yuv, sel);
+		break;
+
+	default:
+		break;
+	}
+}
+
+void s3cfb_enable_dma(void)
+{
+	u32 value;
+
+	s3c_fimd.wincon0 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	value = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	__raw_writel(s3c_fimd.wincon0 | value, S3C_WINCON0);
+}
+
+EXPORT_SYMBOL(s3cfb_enable_dma);
+
+int s3cfb_init_registers(s3c_fb_info_t *fbi)
+{
+	struct clk *lcd_clock;
+	struct fb_var_screeninfo *var = &fbi->fb.var;
+	unsigned long flags = 0, page_width = 0, offset = 0;
+	unsigned long video_phy_temp_f1 = fbi->screen_dma_f1;
+	unsigned long video_phy_temp_f2 = fbi->screen_dma_f2;
+	int win_num =  fbi->win_id;
+
+	/* Initialise LCD with values from hare */
+	local_irq_save(flags);
+
+	page_width = var->xres * s3c_fimd.bytes_per_pixel;
+	offset = (var->xres_virtual - var->xres) * s3c_fimd.bytes_per_pixel;
+
+	if (win_num == 0)
+	{
+#if defined(S3C_FB_DISPLAY_LOGO)
+		lcd_clock = clk_get(NULL, "lcd");	/* Early Clock Setting to Sync Bootloader */
+
+// KSS_2009-09-03 : Change LCD Dot Clk
+#ifndef S3C_FB_USE_CLK_DIRECTED
+		s3c_fimd.vidcon0 |= S3C_VIDCON0_CLKVAL_F((int)(((((clk_get_rate(lcd_clock) * 10) / s3c_fimd.pixclock) % 10) > 4) ?
+												(clk_get_rate(lcd_clock) / s3c_fimd.pixclock) :
+												((clk_get_rate(lcd_clock) / s3c_fimd.pixclock) - 1)));
+#else
+		{
+			u32 clkdiv1 = __raw_readl(S3C_CLK_DIV1);
+			clkdiv1 = (clkdiv1 & ~0xF000) | (12<<12);
+			__raw_writel(clkdiv1, S3C_CLK_DIV1);
+		}
+		s3c_fimd.vidcon0 &= ~S3C_VIDCON0_CLKVAL_F(0xFF);
+#endif	// End of S3C_FB_USE_CLK_DIRECTED
+
+		s3c_fimd.vidcon0 = s3c_fimd.vidcon0 | (S3C_VIDCON0_ENVID_ENABLE | S3C_VIDCON0_ENVID_F_ENABLE);
+		writel(s3c_fimd.vidcon0, S3C_VIDCON0);
+#else	// S3C_FB_DISPLAY_LOGO
+		s3c_fimd.vidcon0 = s3c_fimd.vidcon0 & ~(S3C_VIDCON0_ENVID_ENABLE | S3C_VIDCON0_ENVID_F_ENABLE);
+		writel(s3c_fimd.vidcon0, S3C_VIDCON0);
+		lcd_clock = clk_get(NULL, "lcd");
+#ifndef S3C_FB_USE_CLK_DIRECTED
+		s3c_fimd.vidcon0 |= S3C_VIDCON0_CLKVAL_F((int)(((((clk_get_rate(lcd_clock) * 10) / s3c_fimd.pixclock) % 10) > 4) ?
+												(clk_get_rate(lcd_clock) / s3c_fimd.pixclock) :
+												((clk_get_rate(lcd_clock) / s3c_fimd.pixclock) - 1)));
+#else
+		{
+			u32 clkdiv1 = __raw_readl(S3C_CLK_DIV1);
+			clkdiv1 = (clkdiv1 & ~0xF000) | (12<<12);
+			__raw_writel(clkdiv1, S3C_CLK_DIV1);
+		}
+		s3c_fimd.vidcon0 &= ~S3C_VIDCON0_CLKVAL_F(0xFF);
+#endif	// End of S3C_FB_USE_CLK_DIRECTED
+#endif	// End of S3C_FB_DISPLAY_LOGO
+// End of KSS_2009-09-03
+	}
+
+	#if defined(CONFIG_FB_S3C_VIRTUAL_SCREEN)
+	{
+		offset = 0;
+
+		switch(win_num)
+		{
+			case 0 :
+				s3c_fimd.vidw00add0b0 = video_phy_temp_f1;
+				s3c_fimd.vidw00add0b1 = video_phy_temp_f2;
+				s3c_fimd.vidw00add1b0 = S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f1 + (page_width + offset) * (var->yres));
+				s3c_fimd.vidw00add1b1 = S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f2 + (page_width + offset) * (var->yres));
+				break;
+			case 1 :
+				s3c_fimd.vidw01add0b0 = video_phy_temp_f1;
+				s3c_fimd.vidw01add0b1 = video_phy_temp_f2;
+				s3c_fimd.vidw01add1b0 = S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f1 + (page_width + offset) * (var->yres));
+				s3c_fimd.vidw01add1b1 = S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f2 + (page_width + offset) * (var->yres));
+				break;
+			case 2 :
+				s3c_fimd.vidw02add0 = video_phy_temp_f1;
+				s3c_fimd.vidw02add1 = S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f1 + (page_width + offset) * (var->yres));
+				break;
+			case 3 :
+				s3c_fimd.vidw03add0 = video_phy_temp_f1;
+				s3c_fimd.vidw03add1 = S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f1 + (page_width + offset) * (var->yres));
+				break;
+			case 4 :
+				s3c_fimd.vidw04add0 = video_phy_temp_f1;
+				s3c_fimd.vidw04add1 = S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f1 + (page_width + offset) * (var->yres));
+				break;
+			default:
+				break;
+		}
+	}	
+	#endif
+
+#if defined(S3C_FB_DISPLAY_LOGO)
+		s3cfb_display_logo(win_num);
+#endif	
+
+	writel(video_phy_temp_f1, S3C_VIDW00ADD0B0 + (0x08 * win_num));
+	writel(S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f1 + (page_width + offset) * (var->yres)), S3C_VIDW00ADD1B0 + (0x08 * win_num));
+	writel(S3C_VIDWxxADD2_OFFSIZE_F(offset) | (S3C_VIDWxxADD2_PAGEWIDTH_F(page_width)), S3C_VIDW00ADD2 + (0x04 * win_num));
+
+	if (win_num < 2)
+	{
+		writel(video_phy_temp_f2, S3C_VIDW00ADD0B1 + (0x08 * win_num));
+		writel(S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f2 + (page_width + offset) * (var->yres)), S3C_VIDW00ADD1B1 + (0x08 * win_num));
+	}
+	
+	switch (win_num)
+	{
+		case 0:
+#ifndef CONFIG_FB_S3C_BPP_24
+			writel(s3c_fimd.wincon0,    S3C_WINCON0);
+#endif
+			writel(s3c_fimd.vidcon0,    S3C_VIDCON0);
+			writel(s3c_fimd.vidcon1,    S3C_VIDCON1);
+			writel(s3c_fimd.vidtcon0,   S3C_VIDTCON0);
+			writel(s3c_fimd.vidtcon1,   S3C_VIDTCON1);
+			writel(s3c_fimd.vidtcon2,   S3C_VIDTCON2);
+			writel(s3c_fimd.dithmode,   S3C_DITHMODE);
+			writel(s3c_fimd.vidintcon0, S3C_VIDINTCON0);
+			writel(s3c_fimd.vidintcon1, S3C_VIDINTCON1);
+			writel(s3c_fimd.vidosd0a,   S3C_VIDOSD0A);
+			writel(s3c_fimd.vidosd0b,   S3C_VIDOSD0B);
+			writel(s3c_fimd.vidosd0c,   S3C_VIDOSD0C);
+			writel(s3c_fimd.wpalcon,    S3C_WPALCON);
+
+			s3cfb_onoff_win(fbi, ON);
+			break;
+
+		case 1:
+#ifndef CONFIG_FB_S3C_BPP_24
+			writel(s3c_fimd.wincon1,  S3C_WINCON1);
+#endif
+			writel(s3c_fimd.vidosd1a, S3C_VIDOSD1A);
+			writel(s3c_fimd.vidosd1b, S3C_VIDOSD1B);
+			writel(s3c_fimd.vidosd1c, S3C_VIDOSD1C);
+			writel(s3c_fimd.vidosd1d, S3C_VIDOSD1D);
+			writel(s3c_fimd.wpalcon,  S3C_WPALCON);
+
+			s3cfb_onoff_win(fbi, OFF);
+			break;
+
+		case 2:
+			writel(s3c_fimd.wincon2,  S3C_WINCON2);
+			writel(s3c_fimd.vidosd2a, S3C_VIDOSD2A);
+			writel(s3c_fimd.vidosd2b, S3C_VIDOSD2B);
+			writel(s3c_fimd.vidosd2c, S3C_VIDOSD2C);
+			writel(s3c_fimd.vidosd2d, S3C_VIDOSD2D);
+			writel(s3c_fimd.wpalcon,  S3C_WPALCON);
+
+			s3cfb_onoff_win(fbi, OFF);
+#if defined(S3C_FB_DISPLAY_LOGO)
+			s3cfb_start_progress();
+#endif
+			break;
+
+		case 3:
+			writel(s3c_fimd.wincon3,  S3C_WINCON3);
+			writel(s3c_fimd.vidosd3a, S3C_VIDOSD3A);
+			writel(s3c_fimd.vidosd3b, S3C_VIDOSD3B);
+			writel(s3c_fimd.vidosd3c, S3C_VIDOSD3C);
+			writel(s3c_fimd.wpalcon,  S3C_WPALCON);
+
+			s3cfb_onoff_win(fbi, OFF);
+			break;
+
+		case 4:
+			writel(s3c_fimd.wincon4,  S3C_WINCON4);
+			writel(s3c_fimd.vidosd4a, S3C_VIDOSD4A);
+			writel(s3c_fimd.vidosd4b, S3C_VIDOSD4B);
+			writel(s3c_fimd.vidosd4c, S3C_VIDOSD4C);
+			writel(s3c_fimd.wpalcon,  S3C_WPALCON);
+
+			s3cfb_onoff_win(fbi, OFF);
+			break;
+	}
+
+	local_irq_restore(flags);
+
+	return 0;
+ }
+
+void s3cfb_activate_var(s3c_fb_info_t *fbi, struct fb_var_screeninfo *var)
+{
+	DPRINTK("%s: var->bpp = %d\n", __FUNCTION__, var->bits_per_pixel);
+
+	switch (var->bits_per_pixel) {
+	case 8:
+		s3c_fimd.wincon0 = S3C_WINCONx_BYTSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_8BPP_PAL;
+		s3c_fimd.wincon1 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3c_fimd.wincon2 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3c_fimd.wincon3 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3c_fimd.wincon4 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3c_fimd.bpp     = S3C_FB_PIXEL_BPP_8;
+		s3c_fimd.bytes_per_pixel = 1;
+		s3c_fimd.wpalcon = S3C_WPALCON_W0PAL_16BIT;
+		break;
+
+	case 16:
+		s3c_fimd.wincon0 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565;
+		s3c_fimd.wincon1 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3c_fimd.wincon2 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3c_fimd.wincon3 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3c_fimd.wincon4 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3c_fimd.bpp     = S3C_FB_PIXEL_BPP_16;
+		s3c_fimd.bytes_per_pixel = 2;
+		break;
+
+	case 24:
+		s3c_fimd.wincon0 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888;
+		s3c_fimd.wincon1 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3c_fimd.wincon2 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3c_fimd.wincon3 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3c_fimd.wincon4 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+        s3c_fimd.bpp     = S3C_FB_PIXEL_BPP_24;
+		s3c_fimd.bytes_per_pixel = 4;
+		break;
+
+	case 32:
+		s3c_fimd.bytes_per_pixel = 4;
+		break;
+	}
+
+	/* write new registers */
+	writel(s3c_fimd.wincon0, S3C_WINCON0);
+	writel(s3c_fimd.wincon1, S3C_WINCON1);
+	writel(s3c_fimd.wincon2, S3C_WINCON2);
+	writel(s3c_fimd.wincon3, S3C_WINCON3);
+	writel(s3c_fimd.wincon4, S3C_WINCON4);
+	writel(s3c_fimd.wpalcon, S3C_WPALCON);
+	writel(s3c_fimd.wincon0 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON0);
+	writel(s3c_fimd.vidcon0 | S3C_VIDCON0_ENVID_ENABLE | S3C_VIDCON0_ENVID_F_ENABLE, S3C_VIDCON0);
+}
+
+/* JJNAHM comment.
+ * We had some problems related to frame buffer address.
+ * We used 2 frame buffers (FB0 and FB1) and GTK used FB1.
+ * When GTK launched, GTK set FB0's address to FB1's address.
+ * (GTK calls s3c_fb_pan_display() and then it calls this s3c_fb_set_lcdaddr())
+ * Even though fbi->win_id is not 0, above original codes set ONLY FB0's address.
+ * So, I modified the codes like below.
+ * It works by fbi->win_id value.
+ * Below codes are not verified yet
+ * and there are nothing about Double buffering features
+ */
+void s3cfb_set_fb_addr(s3c_fb_info_t *fbi)
+{
+	unsigned long video_phy_temp_f1 = fbi->screen_dma_f1;
+	unsigned long start_address, end_address;
+	unsigned int  start;
+
+	start = fbi->fb.fix.line_length * fbi->fb.var.yoffset;
+
+	/* for buffer start address and end address */
+	start_address = video_phy_temp_f1 + start;
+	end_address   = start_address + (fbi->fb.fix.line_length * fbi->fb.var.yres);
+
+	switch (fbi->win_id)
+	{
+		case 0:
+			s3c_fimd.vidw00add0b0 = start_address;
+			s3c_fimd.vidw00add1b0 = end_address;
+			__raw_writel(0x800, S3C_PRTCON); /* enable protection */
+			__raw_writel(s3c_fimd.vidw00add0b0, S3C_VIDW00ADD0B0);
+			__raw_writel(s3c_fimd.vidw00add1b0, S3C_VIDW00ADD1B0);
+			__raw_writel(0x0, S3C_PRTCON); /* disable protection */
+        	break;
+
+		case 1:
+			s3c_fimd.vidw01add0b0 = start_address;
+			s3c_fimd.vidw01add1b0 = end_address;
+			__raw_writel(0x800, S3C_PRTCON); /* enable protection */
+			__raw_writel(s3c_fimd.vidw01add0b0, S3C_VIDW01ADD0B0);
+			__raw_writel(s3c_fimd.vidw01add1b0, S3C_VIDW01ADD1B0);
+			__raw_writel(0x0, S3C_PRTCON);	/* disable protection */
+			break;
+
+		case 2:
+			s3c_fimd.vidw02add0 = start_address;
+			s3c_fimd.vidw02add1 = end_address;
+			__raw_writel(0x800, S3C_PRTCON); /* enable protection */
+			__raw_writel(s3c_fimd.vidw02add0, S3C_VIDW02ADD0);
+			__raw_writel(s3c_fimd.vidw02add1, S3C_VIDW02ADD1);
+			__raw_writel(0x0, S3C_PRTCON); /* disable protection */
+			break;
+
+		case 3:
+			s3c_fimd.vidw03add0 = start_address;
+			s3c_fimd.vidw03add1 = end_address;
+			__raw_writel(0x800, S3C_PRTCON); /* enable protection */
+			__raw_writel(s3c_fimd.vidw03add0, S3C_VIDW03ADD0);
+			__raw_writel(s3c_fimd.vidw03add1, S3C_VIDW03ADD1);
+			__raw_writel(0x0, S3C_PRTCON); /* disable protection */
+			break;
+
+		case 4:
+			s3c_fimd.vidw04add0 = start_address;
+			s3c_fimd.vidw04add1 = end_address;
+			__raw_writel(0x800, S3C_PRTCON); /* enable protection */
+			__raw_writel(s3c_fimd.vidw04add0, S3C_VIDW04ADD0);
+			__raw_writel(s3c_fimd.vidw04add1, S3C_VIDW04ADD1);
+			__raw_writel(0x0, S3C_PRTCON); /* disable protection */
+			break;
+		default :
+			printk("%s::invalid win_num(%d)\n", __func__, fbi->win_id);
+			break;
+	}
+}
+
+static int s3cfb_set_alpha_level(s3c_fb_info_t *fbi, unsigned int level, unsigned int alpha_index)
+{
+	unsigned long alpha_val;
+	int win_num = fbi->win_id;
+
+	if (win_num == 0) {
+		printk("WIN0 do not support alpha blending.\n");
+		return -1;
+	}
+
+	alpha_val = readl(S3C_VIDOSD0C+(0x10 * win_num));
+
+	if (alpha_index == 0) {
+		alpha_val &= ~(S3C_VIDOSDxC_ALPHA0_B(0xf) | S3C_VIDOSDxC_ALPHA0_G(0xf) | S3C_VIDOSDxC_ALPHA0_R(0xf));
+		alpha_val |= S3C_VIDOSDxC_ALPHA0_B(level) | S3C_VIDOSDxC_ALPHA0_G(level) | S3C_VIDOSDxC_ALPHA0_R(level);
+	} else {
+		alpha_val &= ~(S3C_VIDOSDxC_ALPHA1_B(0xf) | S3C_VIDOSDxC_ALPHA1_G(0xf) | S3C_VIDOSDxC_ALPHA1_R(0xf));
+		alpha_val = S3C_VIDOSDxC_ALPHA1_B(level) | S3C_VIDOSDxC_ALPHA1_G(level) | S3C_VIDOSDxC_ALPHA1_R(level);
+	}
+
+	writel(alpha_val, S3C_VIDOSD0C + (0x10 * win_num));
+
+	return 0;
+}
+
+int s3cfb_set_alpha_mode(s3c_fb_info_t *fbi, int mode)
+{
+	unsigned long alpha_mode;
+	int win_num = fbi->win_id;
+
+	if (win_num == 0) {
+		printk("WIN0 do not support alpha blending.\n");
+		return -1;
+	}
+
+	alpha_mode = readl(S3C_WINCON0 + (0x04 * win_num));
+	alpha_mode &= ~(S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_1);
+
+	switch (mode) {
+	case S3CFB_ALPHA_MODE_PLANE: /* Plane Blending */
+		writel(alpha_mode | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1, S3C_WINCON0 + (0x04 * win_num));
+		break;
+
+	case S3CFB_ALPHA_MODE_PIXEL: /* Pixel Blending & chroma(color) key */
+		writel(alpha_mode | S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_0, S3C_WINCON0 + (0x04 * win_num));
+		break;
+	}
+
+	return 0;
+}
+
+int s3cfb_set_win_position(s3c_fb_info_t *fbi, int left_x, int top_y, int width, int height)
+{
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	int win_num = fbi->win_id;
+
+	writel(S3C_VIDOSDxA_OSD_LTX_F(left_x) | S3C_VIDOSDxA_OSD_LTY_F(top_y), S3C_VIDOSD0A + (0x10 * win_num));
+	writel(S3C_VIDOSDxB_OSD_RBX_F(width - 1 + left_x) | S3C_VIDOSDxB_OSD_RBY_F(height - 1 + top_y), S3C_VIDOSD0B + (0x10 * win_num));
+
+	var->xoffset = left_x;
+	var->yoffset = top_y;
+
+	return 0;
+}
+
+int s3cfb_set_win_size(s3c_fb_info_t *fbi, int width, int height)
+{
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	int win_num = fbi->win_id;
+
+	if (win_num == 1)
+		writel(S3C_VIDOSD0C_OSDSIZE(width * height), S3C_VIDOSD1D);
+	else if (win_num == 2)
+		writel(S3C_VIDOSD0C_OSDSIZE(width * height), S3C_VIDOSD2D);
+
+	var->xres = width;
+	var->yres = height;
+
+	// is this bug?
+	//var->xres_virtual = width;
+	//var->yres_virtual = height;
+
+	return 0;
+}
+
+int s3cfb_set_fb_size(s3c_fb_info_t *fbi)
+{
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	int win_num = fbi->win_id;
+	unsigned long offset = 0;
+	unsigned long page_width = 0;
+	unsigned long fb_size = 0;
+
+	page_width = var->xres * s3c_fimd.bytes_per_pixel;
+	offset = (var->xres_virtual - var->xres) * s3c_fimd.bytes_per_pixel;
+
+#if defined(CONFIG_FB_S3C_VIRTUAL_SCREEN)
+	if (win_num == 0)
+		offset=0;
+#endif
+
+	writel(S3C_VIDWxxADD1_VBASEL_F((unsigned long) readl(S3C_VIDW00ADD0B0 + (0x08 * win_num)) + (page_width + offset) * (var->yres)), S3C_VIDW00ADD1B0 + (0x08 * win_num));
+
+	if (win_num == 1)
+		writel(S3C_VIDWxxADD1_VBASEL_F((unsigned long) readl(S3C_VIDW00ADD0B1 + (0x08 * win_num)) + (page_width + offset) * (var->yres)), S3C_VIDW00ADD1B1 + (0x08 * win_num));
+
+	/* size of frame buffer */
+	fb_size = S3C_VIDWxxADD2_OFFSIZE_F(offset) | (S3C_VIDWxxADD2_PAGEWIDTH_F(page_width));
+
+	writel(fb_size, S3C_VIDW00ADD2 + (0x04 * win_num));
+
+	return 0;
+}
+
+void s3cfb_set_output_path(int out)
+{
+	unsigned int tmp;
+
+	tmp = readl(S3C_VIDCON0);
+
+	/* if output mode is LCD mode, Scan mode always should be progressive mode */
+	if (out == S3C_FB_OUTPUT_TV)
+		tmp &= ~S3C_VIDCON0_INTERLACE_F_MASK;
+
+	tmp &= ~S3C_VIDCON0_VIDOUT_MASK;
+	tmp |= S3C_VIDCON0_VIDOUT(out);
+
+	writel(tmp, S3C_VIDCON0);
+}
+
+EXPORT_SYMBOL(s3cfb_set_output_path);
+
+void s3cfb_enable_rgbport(int on)
+{
+	if (on)
+		writel(S3C_VIDCON2_ORGYUV_CBCRY | S3C_VIDCON2_YUVORD_CRCB, S3C_VIDCON2);
+	else
+		writel(0x0, S3C_VIDCON2);
+}
+
+EXPORT_SYMBOL(s3cfb_enable_rgbport);
+
+int s3cfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+	s3c_fb_info_t *fbi = container_of(info, s3c_fb_info_t, fb);
+
+	s3c_win_info_t       win_info;
+	s3c_color_key_info_t colkey_info;
+	s3c_color_val_info_t colval_info;
+	s3c_fb_dma_info_t    dma_info;
+	s3c_fb_next_info_t   next_fb_info;
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	unsigned int crt, alpha_level, alpha_mode;
+
+#if defined(CONFIG_S3C6410_PWM)
+	int brightness;
+#endif
+
+#if defined(CONFIG_FB_S3C_DOUBLE_BUFFERING)
+	unsigned int f_num_val;
+#endif
+
+#if defined(CONFIG_FB_S3C_VIRTUAL_SCREEN)
+	s3c_vs_info_t vs_info;
+#endif
+
+	switch(cmd){
+	case S3C_FB_GET_INFO:
+		dma_info.map_dma_f1 = fbi->map_dma_f1;
+		dma_info.map_dma_f2 = fbi->map_dma_f2;
+
+		if(copy_to_user((void *) arg, (const void *) &dma_info, sizeof(s3c_fb_dma_info_t)))
+			return -EFAULT;
+		break;
+
+	case S3C_FB_OSD_SET_INFO:
+		if (copy_from_user(&win_info, (s3c_win_info_t *) arg, sizeof(s3c_win_info_t)))
+			return -EFAULT;
+
+		s3cfb_init_win(fbi, win_info.bpp, win_info.left_x, win_info.top_y, win_info.width, win_info.height, OFF);
+		break;
+
+	case S3C_FB_OSD_START:
+		s3cfb_onoff_win(fbi, ON);
+		break;
+
+	case S3C_FB_OSD_STOP:
+		if (fbi->win_id > 0)
+			s3cfb_set_alpha_level(fbi, S3C_FB_MAX_ALPHA_LEVEL, 1);
+
+		s3cfb_onoff_win(fbi, OFF);
+		break;
+
+	case S3C_FB_OSD_ALPHA_UP:
+		alpha_level = readl(S3C_VIDOSD0C + (0x10 * fbi->win_id)) & 0xf;
+
+		if (alpha_level < S3C_FB_MAX_ALPHA_LEVEL)
+			alpha_level++;
+
+		s3cfb_set_alpha_level(fbi, alpha_level, 1);
+		break;
+
+	case S3C_FB_OSD_ALPHA_DOWN:
+		alpha_level = readl(S3C_VIDOSD0C + (0x10 * fbi->win_id)) & 0xf;
+
+		if (alpha_level > 0)
+			alpha_level--;
+
+		s3cfb_set_alpha_level(fbi, alpha_level, 1);
+		break;
+
+	case S3C_FB_OSD_ALPHA0_SET:
+		alpha_level = (unsigned int) arg;
+
+		if (alpha_level > S3C_FB_MAX_ALPHA_LEVEL)
+			alpha_level = S3C_FB_MAX_ALPHA_LEVEL;
+		else if(alpha_level < 0)
+			alpha_level = 0;
+
+		s3cfb_set_alpha_level(fbi, alpha_level, 0);
+		break;
+
+	case S3C_FB_OSD_ALPHA_SET:
+		alpha_level = (unsigned int) arg;
+
+		if (alpha_level > S3C_FB_MAX_ALPHA_LEVEL)
+			alpha_level = S3C_FB_MAX_ALPHA_LEVEL;
+		else if (alpha_level < 0)
+			alpha_level = 0;
+
+		s3cfb_set_alpha_level(fbi, alpha_level, 1);
+		break;
+
+	case S3C_FB_OSD_ALPHA_MODE:
+		alpha_mode = (unsigned int) arg;
+		s3cfb_set_alpha_mode(fbi, alpha_mode);
+		break;
+
+	case S3C_FB_OSD_MOVE_LEFT:
+		if (var->xoffset > 0)
+			var->xoffset--;
+
+		s3cfb_set_win_position(fbi, var->xoffset, var->yoffset, var->xres, var->yres);
+		break;
+
+	case S3C_FB_OSD_MOVE_RIGHT:
+		if (var->xoffset < (s3c_fimd.xres - var->xres))
+			var->xoffset++;
+
+		s3cfb_set_win_position(fbi, var->xoffset, var->yoffset, var->xres, var->yres);
+		break;
+
+	case S3C_FB_OSD_MOVE_UP:
+		if (var->yoffset > 0)
+			var->yoffset--;
+
+		s3cfb_set_win_position(fbi, var->xoffset, var->yoffset, var->xres, var->yres);
+		break;
+
+	case S3C_FB_OSD_MOVE_DOWN:
+		if (var->yoffset < (s3c_fimd.yres - var->yres))
+			var->yoffset++;
+
+		s3cfb_set_win_position(fbi, var->xoffset, var->yoffset, var->xres, var->yres);
+		break;
+
+	case FBIO_WAITFORVSYNC:
+		if (get_user(crt, (unsigned int __user *)arg))
+			return -EFAULT;
+
+		return s3cfb_wait_for_vsync();
+
+	case S3C_FB_COLOR_KEY_START:
+		s3cfb_onoff_color_key(fbi, ON);
+		break;
+
+	case S3C_FB_COLOR_KEY_STOP:
+		s3cfb_onoff_color_key(fbi, OFF);
+		break;
+
+	case S3C_FB_COLOR_KEY_ALPHA_START:
+		s3cfb_onoff_color_key_alpha(fbi, ON);
+		break;
+
+	case S3C_FB_COLOR_KEY_ALPHA_STOP:
+		s3cfb_onoff_color_key_alpha(fbi, OFF);
+		break;
+
+	case S3C_FB_COLOR_KEY_SET_INFO:
+		if (copy_from_user(&colkey_info, (s3c_color_key_info_t *) arg, sizeof(s3c_color_key_info_t)))
+			return -EFAULT;
+
+		s3cfb_set_color_key_registers(fbi, colkey_info);
+		break;
+
+	case S3C_FB_COLOR_KEY_VALUE:
+		if (copy_from_user(&colval_info, (s3c_color_val_info_t *) arg, sizeof(s3c_color_val_info_t)))
+			return -EFAULT;
+
+		s3cfb_set_color_value(fbi, colval_info);
+		break;
+
+	case S3C_FB_SET_VSYNC_INT:
+		s3c_fimd.vidintcon0 &= ~S3C_VIDINTCON0_FRAMESEL0_MASK;
+		s3c_fimd.vidintcon0 |= S3C_VIDINTCON0_FRAMESEL0_VSYNC;
+
+		if (arg)
+			s3c_fimd.vidintcon0 |= S3C_VIDINTCON0_INTFRMEN_ENABLE;
+		else
+			s3c_fimd.vidintcon0 &= ~S3C_VIDINTCON0_INTFRMEN_ENABLE;
+
+		writel(s3c_fimd.vidintcon0, S3C_VIDINTCON0);
+		break;
+
+	case S3C_FB_SET_NEXT_FB_INFO:
+		if (copy_from_user(&next_fb_info, (s3c_fb_next_info_t *) arg, sizeof(s3c_fb_next_info_t)))
+			return -EFAULT;
+
+		/* check arguments */
+		if ((next_fb_info.xres + next_fb_info.xoffset) > next_fb_info.xres_virtual ||
+			(next_fb_info.yres + next_fb_info.yoffset) > next_fb_info.yres_virtual ||
+			(next_fb_info.xres + next_fb_info.lcd_offset_x ) > s3c_fimd.xres ||
+			(next_fb_info.yres + next_fb_info.lcd_offset_y ) > s3c_fimd.yres)
+			return -EINVAL;
+
+		fbi->next_fb_info = next_fb_info;
+		fbi->next_fb_info_change_req = 1;
+		break;
+
+	case S3C_FB_GET_CURR_FB_INFO:
+		next_fb_info.phy_start_addr = fbi->fb.fix.smem_start;
+		next_fb_info.xres = fbi->fb.var.xres;
+		next_fb_info.yres = fbi->fb.var.yres;
+		next_fb_info.xres_virtual = fbi->fb.var.xres_virtual;
+		next_fb_info.yres_virtual = fbi->fb.var.yres_virtual;
+		next_fb_info.xoffset = fbi->fb.var.xoffset;
+		next_fb_info.yoffset = fbi->fb.var.yoffset;
+		next_fb_info.lcd_offset_x = fbi->lcd_offset_x;
+		next_fb_info.lcd_offset_y = fbi->lcd_offset_y;
+
+		if (copy_to_user((void *)arg, (s3c_fb_next_info_t *) &next_fb_info, sizeof(s3c_fb_next_info_t)))
+			return -EFAULT;
+		break;
+
+	case S3C_FB_GET_BRIGHTNESS:
+		if (copy_to_user((void *)arg, (const void *) &s3c_fimd.brightness, sizeof(int)))
+			return -EFAULT;
+		break;
+
+#if defined(CONFIG_S3C6410_PWM)
+	case S3C_FB_SET_BRIGHTNESS:
+		if (copy_from_user(&brightness, (int *) arg, sizeof(int)))
+			return -EFAULT;
+
+		s3cfb_set_brightness(brightness);
+		break;
+#endif
+
+#if defined(CONFIG_FB_S3C_VIRTUAL_SCREEN)
+
+	case S3C_FB_VS_START:
+		if (s3cfb_vs_start(fbi)) {
+			printk("Error S3C_FB_VS_START\n");
+			return -EINVAL;
+		}
+		break;
+
+	case S3C_FB_VS_STOP:
+		if (s3cfb_vs_stop(fbi)) {
+			printk("Error S3C_FB_VS_STOP\n");
+			return -EINVAL;
+		}
+		break;
+
+	case S3C_FB_VS_SET_INFO:
+		if (copy_from_user(&vs_info, (s3c_vs_info_t *) arg, sizeof(s3c_vs_info_t)))
+			return -EFAULT;
+
+		if (s3cfb_set_vs_info(vs_info)) {
+			printk("Error S3C_FB_VS_SET_INFO\n");
+			return -EINVAL;
+		}
+
+		s3cfb_set_vs_registers(fbi, S3C_FB_VS_SET);
+
+		fbi->fb.var.xoffset = s3c_fimd.xoffset;
+		fbi->fb.var.yoffset = s3c_fimd.yoffset;
+		break;
+
+	case S3C_FB_VS_MOVE:
+		s3cfb_set_vs_registers(fbi, arg);
+
+		fbi->fb.var.xoffset = s3c_fimd.xoffset;
+		fbi->fb.var.yoffset = s3c_fimd.yoffset;
+		break;
+#endif
+
+#if defined(CONFIG_FB_S3C_DOUBLE_BUFFERING)
+	case S3C_FB_GET_NUM:
+		if (copy_from_user((void *)&f_num_val, (const void *)arg, sizeof(u_int)))
+			return -EFAULT;
+
+		if (copy_to_user((void *)arg, (const void *) &f_num_val, sizeof(u_int)))
+			return -EFAULT;
+
+		break;
+
+	case S3C_FB_CHANGE_REQ:
+		s3cfb_change_buff(0, (int) arg);
+		break;
+#endif
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void s3cfb_pre_init(void)
+{
+	/* initialize the fimd specific */
+	s3c_fimd.vidintcon0 &= ~S3C_VIDINTCON0_FRAMESEL0_MASK;
+	s3c_fimd.vidintcon0 |= S3C_VIDINTCON0_FRAMESEL0_VSYNC;
+	s3c_fimd.vidintcon0 |= S3C_VIDINTCON0_INTFRMEN_ENABLE;
+
+	writel(s3c_fimd.vidintcon0, S3C_VIDINTCON0);
+}
+
+int s3cfb_set_gpio(void)
+{
+	unsigned long val;
+#if defined (CONFIG_MACH_SMDK6410)
+	int i, err;
+#endif
+	/* Must be '0' for Normal-path instead of By-pass */
+	writel(0x0, S3C_HOSTIFB_MIFPCON);
+
+	/* enable clock to LCD */
+	val = readl(S3C_SCLK_GATE);
+	val |= S3C_CLKCON_SCLK_LCD;
+	writel(val, S3C_SCLK_GATE);
+
+	/* select TFT LCD type (RGB I/F) */
+	val = readl(S3C64XX_SPC_BASE);
+	val &= ~0x3;
+	val |= (1 << 0);
+	writel(val, S3C64XX_SPC_BASE);
+#if defined (CONFIG_MACH_SMDK6410)
+	/* VD */
+	for (i = 0; i < 16; i++)
+		s3c_gpio_cfgpin(S3C64XX_GPI(i), S3C_GPIO_SFN(2));
+
+	for (i = 0; i < 12; i++)
+		s3c_gpio_cfgpin(S3C64XX_GPJ(i), S3C_GPIO_SFN(2));
+
+	/* backlight ON */
+	if (gpio_is_valid(S3C64XX_GPF(15))) {
+		err = gpio_request(S3C64XX_GPF(15), "GPF");
+
+		if (err) {
+			printk(KERN_ERR "failed to request GPF for "
+				"lcd backlight control\n");
+			return err;
+		}
+
+		gpio_direction_output(S3C64XX_GPF(15), 1);
+	}
+
+	/* module reset */
+	if (gpio_is_valid(S3C64XX_GPN(5))) {
+		err = gpio_request(S3C64XX_GPN(5), "GPN");
+
+		if (err) {
+			printk(KERN_ERR "failed to request GPN for "
+				"lcd reset control\n");
+			return err;
+		}
+
+		gpio_direction_output(S3C64XX_GPN(5), 1);
+	}
+	
+	mdelay(100);
+
+	gpio_set_value(S3C64XX_GPN(5), 0);
+	mdelay(10);
+
+	gpio_set_value(S3C64XX_GPN(5), 1);
+	mdelay(10);
+
+	gpio_free(S3C64XX_GPF(15));
+	gpio_free(S3C64XX_GPN(5));
+#endif
+	return 0;
+}
+
+#if defined(CONFIG_PM)
+
+static struct sleep_save s3c_lcd_save[] = {
+	SAVE_ITEM(S3C_VIDCON0),
+	SAVE_ITEM(S3C_VIDCON1),
+
+	SAVE_ITEM(S3C_VIDTCON0),
+	SAVE_ITEM(S3C_VIDTCON1),
+	SAVE_ITEM(S3C_VIDTCON2),
+	SAVE_ITEM(S3C_VIDTCON3),
+
+	SAVE_ITEM(S3C_WINCON0),
+	SAVE_ITEM(S3C_WINCON1),
+	SAVE_ITEM(S3C_WINCON2),
+	SAVE_ITEM(S3C_WINCON3),
+	SAVE_ITEM(S3C_WINCON4),
+
+	SAVE_ITEM(S3C_VIDOSD0A),
+	SAVE_ITEM(S3C_VIDOSD0B),
+	SAVE_ITEM(S3C_VIDOSD0C),
+
+	SAVE_ITEM(S3C_VIDOSD1A),
+	SAVE_ITEM(S3C_VIDOSD1B),
+	SAVE_ITEM(S3C_VIDOSD1C),
+	SAVE_ITEM(S3C_VIDOSD1D),
+
+	SAVE_ITEM(S3C_VIDOSD2A),
+	SAVE_ITEM(S3C_VIDOSD2B),
+	SAVE_ITEM(S3C_VIDOSD2C),
+	SAVE_ITEM(S3C_VIDOSD2D),
+
+	SAVE_ITEM(S3C_VIDOSD3A),
+	SAVE_ITEM(S3C_VIDOSD3B),
+	SAVE_ITEM(S3C_VIDOSD3C),
+
+	SAVE_ITEM(S3C_VIDOSD4A),
+	SAVE_ITEM(S3C_VIDOSD4B),
+	SAVE_ITEM(S3C_VIDOSD4C),
+
+	SAVE_ITEM(S3C_VIDW00ADD0B0),
+	SAVE_ITEM(S3C_VIDW00ADD0B1),
+	SAVE_ITEM(S3C_VIDW01ADD0B0),
+	SAVE_ITEM(S3C_VIDW01ADD0B1),
+	SAVE_ITEM(S3C_VIDW02ADD0),
+	SAVE_ITEM(S3C_VIDW03ADD0),
+	SAVE_ITEM(S3C_VIDW04ADD0),
+	SAVE_ITEM(S3C_VIDW00ADD1B0),
+	SAVE_ITEM(S3C_VIDW00ADD1B1),
+	SAVE_ITEM(S3C_VIDW01ADD1B0),
+	SAVE_ITEM(S3C_VIDW01ADD1B1),
+	SAVE_ITEM(S3C_VIDW02ADD1),
+	SAVE_ITEM(S3C_VIDW03ADD1),
+	SAVE_ITEM(S3C_VIDW04ADD1),
+	SAVE_ITEM(S3C_VIDW00ADD2),
+	SAVE_ITEM(S3C_VIDW01ADD2),
+	SAVE_ITEM(S3C_VIDW02ADD2),
+	SAVE_ITEM(S3C_VIDW03ADD2),
+	SAVE_ITEM(S3C_VIDW04ADD2),
+
+	SAVE_ITEM(S3C_VIDINTCON0),
+	SAVE_ITEM(S3C_VIDINTCON1),
+	SAVE_ITEM(S3C_W1KEYCON0),
+	SAVE_ITEM(S3C_W1KEYCON1),
+	SAVE_ITEM(S3C_W2KEYCON0),
+	SAVE_ITEM(S3C_W2KEYCON1),
+
+	SAVE_ITEM(S3C_W3KEYCON0),
+	SAVE_ITEM(S3C_W3KEYCON1),
+	SAVE_ITEM(S3C_W4KEYCON0),
+	SAVE_ITEM(S3C_W4KEYCON1),
+	SAVE_ITEM(S3C_DITHMODE),
+
+	SAVE_ITEM(S3C_WIN0MAP),
+	SAVE_ITEM(S3C_WIN1MAP),
+	SAVE_ITEM(S3C_WIN2MAP),
+	SAVE_ITEM(S3C_WIN3MAP),
+	SAVE_ITEM(S3C_WIN4MAP),
+	SAVE_ITEM(S3C_WPALCON),
+
+	SAVE_ITEM(S3C_TRIGCON),
+	SAVE_ITEM(S3C_I80IFCONA0),
+	SAVE_ITEM(S3C_I80IFCONA1),
+	SAVE_ITEM(S3C_I80IFCONB0),
+	SAVE_ITEM(S3C_I80IFCONB1),
+	SAVE_ITEM(S3C_LDI_CMDCON0),
+	SAVE_ITEM(S3C_LDI_CMDCON1),
+	SAVE_ITEM(S3C_SIFCCON0),
+	SAVE_ITEM(S3C_SIFCCON1),
+	SAVE_ITEM(S3C_SIFCCON2),
+
+	SAVE_ITEM(S3C_LDI_CMD0),
+	SAVE_ITEM(S3C_LDI_CMD1),
+	SAVE_ITEM(S3C_LDI_CMD2),
+	SAVE_ITEM(S3C_LDI_CMD3),
+	SAVE_ITEM(S3C_LDI_CMD4),
+	SAVE_ITEM(S3C_LDI_CMD5),
+	SAVE_ITEM(S3C_LDI_CMD6),
+	SAVE_ITEM(S3C_LDI_CMD7),
+	SAVE_ITEM(S3C_LDI_CMD8),
+	SAVE_ITEM(S3C_LDI_CMD9),
+	SAVE_ITEM(S3C_LDI_CMD10),
+	SAVE_ITEM(S3C_LDI_CMD11),
+
+	SAVE_ITEM(S3C_W2PDATA01),
+	SAVE_ITEM(S3C_W2PDATA23),
+	SAVE_ITEM(S3C_W2PDATA45),
+	SAVE_ITEM(S3C_W2PDATA67),
+	SAVE_ITEM(S3C_W2PDATA89),
+	SAVE_ITEM(S3C_W2PDATAAB),
+	SAVE_ITEM(S3C_W2PDATACD),
+	SAVE_ITEM(S3C_W2PDATAEF),
+	SAVE_ITEM(S3C_W3PDATA01),
+	SAVE_ITEM(S3C_W3PDATA23),
+	SAVE_ITEM(S3C_W3PDATA45),
+	SAVE_ITEM(S3C_W3PDATA67),
+	SAVE_ITEM(S3C_W3PDATA89),
+	SAVE_ITEM(S3C_W3PDATAAB),
+	SAVE_ITEM(S3C_W3PDATACD),
+	SAVE_ITEM(S3C_W3PDATAEF),
+	SAVE_ITEM(S3C_W4PDATA01),
+	SAVE_ITEM(S3C_W4PDATA23),
+
+	//SAVE_ITEM(S3C_HOSTIFB_MIFPCON),
+	/* for Idle Current GPIO Setting */
+	SAVE_ITEM(S3C64XX_GPICON),
+	SAVE_ITEM(S3C64XX_GPIDAT),
+	SAVE_ITEM(S3C64XX_GPIPUD),
+	SAVE_ITEM(S3C64XX_GPJCON),
+	SAVE_ITEM(S3C64XX_GPJDAT),
+	SAVE_ITEM(S3C64XX_GPJPUD),
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static int lcd_pm_status = 0;
+static int lcd_clock_status = 1;
+int lcd_late_resume = 1;
+
+static int s3cfb_suspend_sub(s3c_fb_info_t *fbi)
+{
+        s3c6410_pm_do_save(s3c_lcd_save, ARRAY_SIZE(s3c_lcd_save));
+
+        /* for Idle Current GPIO Setting */
+        __raw_writel(0x55555555, S3C64XX_GPICON);
+        __raw_writel(0x0, S3C64XX_GPIDAT);
+        __raw_writel(0x55555555, S3C64XX_GPIPUD);
+        __raw_writel(0x55555555, S3C64XX_GPJCON);
+        __raw_writel(0x0, S3C64XX_GPJDAT);
+        __raw_writel(0x55555555, S3C64XX_GPJPUD);
+
+        /* sleep before disabling the clock, we need to ensure
+	 * the LCD DMA engine is not going to get back on the bus
+         * before the clock goes off again (bjd) */
+
+        msleep(1);
+
+        clk_disable(fbi->clk);
+
+#ifdef USE_LCD_DOMAIN_GATING
+        s3c_set_normal_cfg(S3C64XX_DOMAIN_F, S3C64XX_LP_MODE, S3C64XX_LCD);
+#endif /* USE_LCD_DOMAIN_GATING */
+
+        return 0;
+}
+
+static int s3cfb_resume_sub(s3c_fb_info_t *fbi)
+{
+#ifdef USE_LCD_DOMAIN_GATING
+        s3c_set_normal_cfg(S3C64XX_DOMAIN_F, S3C64XX_ACTIVE_MODE, S3C64XX_LCD);
+        if(s3c_wait_blk_pwr_ready(S3C64XX_BLK_F)) {
+                printk(KERN_ERR "[%s] Domain F is not ready\n", __func__);
+                return -1;
+        }
+#endif /* USE_LCD_DOMAIN_GATING */
+
+        clk_enable(fbi->clk);
+
+        s3c6410_pm_do_restore(s3c_lcd_save, ARRAY_SIZE(s3c_lcd_save));
+
+        s3cfb_set_gpio();
+
+        s3cfb_start_lcd();
+
+        return 0;
+}
+
+int s3cfb_is_clock_on(void)
+{
+	return lcd_clock_status;
+}
+
+void s3cfb_enable_clock_power(void)
+{
+	struct early_suspend *early_suspend_ptr;
+	
+	early_suspend_ptr = get_earlysuspend_ptr();
+
+	s3c_fb_info_t *info = container_of(early_suspend_ptr, s3c_fb_info_t, early_suspend);
+	s3cfb_resume_sub(info);
+
+	lcd_clock_status = 1;
+	lcd_pm_status = 1;
+}
+
+void s3cfb_early_suspend(struct early_suspend *h)
+{
+	s3c_fb_info_t *info = container_of(h, s3c_fb_info_t, early_suspend);
+	
+	printk("#%s\n", __func__);
+	
+	lcd_late_resume = 0;
+
+	s3cfb_suspend_sub(info);
+
+	lcd_clock_status = 0; 
+	lcd_pm_status = 0;
+}
+
+void s3cfb_late_resume(struct early_suspend *h)
+{
+	s3c_fb_info_t *info = container_of(h, s3c_fb_info_t, early_suspend);
+
+	printk("#%s\n", __func__);
+
+	if (lcd_pm_status == 0) {
+		s3cfb_resume_sub(info);
+	}
+
+	lcd_clock_status = 1;
+	lcd_late_resume = 1;
+}
+/*
+ *  Suspend
+ */
+int s3cfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct fb_info *fbinfo = platform_get_drvdata(dev);
+	s3c_fb_info_t *info = fbinfo->par;
+	
+	printk("#%s\n", __func__);
+
+	if (lcd_pm_status != 0) {
+		s3cfb_suspend_sub(info);
+	}
+
+	lcd_clock_status = 0;
+
+	return 0;
+}
+
+/*
+ *  Resume
+ */
+int s3cfb_resume(struct platform_device *dev)
+{
+	struct fb_info *fbinfo = platform_get_drvdata(dev);
+	s3c_fb_info_t *info = fbinfo->par;
+
+	printk("#%s\n", __func__);
+
+	s3cfb_resume_sub(info);
+
+	lcd_clock_status = 1;
+	lcd_pm_status = 1;
+
+	return 0;
+}
+
+/*
+ * shutdown
+ */
+extern void lcd_power_ctrl(s32 value);
+int s3cfb_shutdown(struct platform_device *dev)
+{
+	lcd_power_ctrl(0);
+	return 0;
+}
+#else
+
+/*
+ *  Suspend
+ */
+int s3cfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct fb_info *fbinfo = platform_get_drvdata(dev);
+	s3c_fb_info_t *info = fbinfo->par;
+	
+	s3cfb_suspend_sub(info);
+
+	return 0;
+}
+
+/*
+ *  Resume
+ */
+int s3cfb_resume(struct platform_device *dev)
+{
+	struct fb_info *fbinfo = platform_get_drvdata(dev);
+	s3c_fb_info_t *info = fbinfo->par;
+
+	s3cfb_resume_sub(info);
+
+	return 0;
+}
+
+/*
+ * shutdown
+ */
+int s3cfb_shutdown(struct platform_device *dev)
+{
+	lcd_power_ctrl(0);
+}
+#endif	/* CONFIG_HAS_EARLYSUSPEND */
+
+#else
+int s3cfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+int s3cfb_resume(struct platform_device *dev)
+{
+	return 0;
+}
+
+int s3cfb_shutdown(struct platform_device *dev)
+{
+	return 0;
+}
+#endif	/* CONFIG_PM */
diff -Nur linux-2.6.29/drivers/video/samsung/s3cfb.h linux-2.6.29-spica/drivers/video/samsung/s3cfb.h
--- linux-2.6.29/drivers/video/samsung/s3cfb.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/video/samsung/s3cfb.h	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,533 @@
+/*
+ * drivers/video/samsung/s3cfb.h
+ *
+ * $Id: s3cfb.h,v 1.1 2008/11/17 11:12:08 jsgood Exp $
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#ifndef _S3CFB_H_
+#define _S3CFB_H_
+
+#include <linux/interrupt.h>
+#include <linux/earlysuspend.h>
+
+#if  defined(CONFIG_S3C6410_PWM)
+extern int s3c6410_timer_setup (int channel, int usec, unsigned long g_tcnt, unsigned long g_tcmp);
+#endif
+
+/*
+ *  Debug macros
+ */
+#define DEBUG 0
+
+#if DEBUG
+#define DPRINTK(fmt, args...)	printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+/*
+ *  Definitions
+ */
+#ifndef MHZ
+#define MHZ (1000 * 1000)
+#endif
+
+#define ON 	1
+#define OFF	0
+
+#define S3C_FB_PIXEL_BPP_8	8
+#define S3C_FB_PIXEL_BPP_16	16	/*  RGB 5-6-5 format for SMDK EVAL BOARD */
+#define S3C_FB_PIXEL_BPP_24	24	/*  RGB 8-8-8 format for SMDK EVAL BOARD */
+
+#define S3C_FB_OUTPUT_RGB	0
+#define S3C_FB_OUTPUT_TV	1
+#define S3C_FB_OUTPUT_I80_LDI0	2
+#define S3C_FB_OUTPUT_I80_LDI1	3
+
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+#define S3C_FB_MAX_NUM	2
+
+#elif defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410) || defined(CONFIG_CPU_S5P6440)
+#define S3C_FB_MAX_NUM	5
+
+#else
+#define S3C_FB_MAX_NUM	1
+
+#endif
+
+#define S3C_FB_PALETTE_BUFF_CLEAR	(0x80000000)	/* entry is clear/invalid */
+#define S3C_FB_COLOR_KEY_DIR_BG 	0
+#define S3C_FB_COLOR_KEY_DIR_FG 	1
+#define S3C_FB_DEFAULT_BACKLIGHT_LEVEL	93
+#define S3C_FB_MAX_DISPLAY_OFFSET	200
+#define S3C_FB_DEFAULT_DISPLAY_OFFSET	100
+#define S3C_FB_MAX_ALPHA_LEVEL		0xf
+#define S3C_FB_MAX_BRIGHTNESS		90
+#define S3C_FB_DEFAULT_BRIGHTNESS	4
+#define S3C_FB_VS_SET 			12
+#define S3C_FB_VS_MOVE_LEFT		15
+#define S3C_FB_VS_MOVE_RIGHT		16
+#define S3C_FB_VS_MOVE_UP		17
+#define S3C_FB_VS_MOVE_DOWN		18
+#define S3CFB_ALPHA_MODE_PLANE		0
+#define S3CFB_ALPHA_MODE_PIXEL		1
+#define S3C_FB_DISPLAY_LOGO
+
+#if defined(CONFIG_MACH_SPICA)
+	#define S3C_FB_USE_CLK_DIRECTED		// KSS_2009-09-03 : Change LCD Dot Clk
+#endif
+
+/*
+ *  macros
+ */
+#define PRINT_MHZ(m) 			((m) / MHZ), ((m / 1000) % 1000)
+#define FB_MAX_NUM(x, y)		((x) > (y) ? (y) : (x))
+#define S3C_FB_NUM			FB_MAX_NUM(S3C_FB_MAX_NUM, CONFIG_FB_S3C_NUM)
+
+/*
+ *  ioctls
+ */
+#define S3C_FB_GET_BRIGHTNESS		_IOR ('F', 1,  unsigned int)
+#define S3C_FB_SET_BRIGHTNESS		_IOW ('F', 2,  unsigned int)
+#define S3C_FB_WIN_ON			_IOW ('F', 10, unsigned int)
+#define S3C_FB_WIN_OFF			_IOW ('F', 11, unsigned int)
+#define FBIO_WAITFORVSYNC		_IOW ('F', 32, unsigned int)
+
+#if defined(CONFIG_FB_S3C_VIRTUAL_SCREEN)
+#define S3C_FB_VS_START			_IO  ('F', 103)
+#define S3C_FB_VS_STOP			_IO  ('F', 104)
+#define S3C_FB_VS_SET_INFO		_IOW ('F', 105, s3c_vs_info_t)
+#define S3C_FB_VS_MOVE			_IOW ('F', 106, unsigned int)
+#endif
+
+#define S3C_FB_OSD_START		_IO  ('F', 201)
+#define S3C_FB_OSD_STOP			_IO  ('F', 202)
+#define S3C_FB_OSD_ALPHA_UP		_IO  ('F', 203)
+#define S3C_FB_OSD_ALPHA_DOWN		_IO  ('F', 204)
+#define S3C_FB_OSD_MOVE_LEFT		_IO  ('F', 205)
+#define S3C_FB_OSD_MOVE_RIGHT		_IO  ('F', 206)
+#define S3C_FB_OSD_MOVE_UP		_IO  ('F', 207)
+#define S3C_FB_OSD_MOVE_DOWN		_IO  ('F', 208)
+#define S3C_FB_OSD_SET_INFO		_IOW ('F', 209, s3c_win_info_t)
+#define S3C_FB_OSD_ALPHA_SET		_IOW ('F', 210, unsigned int)
+#define S3C_FB_OSD_ALPHA0_SET		_IOW ('F', 211, unsigned int)
+#define S3C_FB_OSD_ALPHA_MODE		_IOW ('F', 212, unsigned int)
+
+#define S3C_FB_COLOR_KEY_START		_IO  ('F', 300)
+#define S3C_FB_COLOR_KEY_STOP		_IO  ('F', 301)
+#define S3C_FB_COLOR_KEY_ALPHA_START	_IO  ('F', 302)
+#define S3C_FB_COLOR_KEY_ALPHA_STOP	_IO  ('F', 303)
+#define S3C_FB_COLOR_KEY_SET_INFO	_IOW ('F', 304, s3c_color_key_info_t)
+#define S3C_FB_COLOR_KEY_VALUE		_IOW ('F', 305, s3c_color_val_info_t)
+
+#if defined(CONFIG_FB_S3C_DOUBLE_BUFFERING)
+#define S3C_FB_GET_NUM			_IOWR('F', 306, unsigned int)
+#endif
+
+#define S3C_FB_GET_INFO			_IOR ('F', 307, s3c_fb_dma_info_t)
+#define S3C_FB_CHANGE_REQ		_IOW ('F', 308, int)
+#define S3C_FB_SET_VSYNC_INT		_IOW ('F', 309, int)
+#define S3C_FB_SET_NEXT_FB_INFO		_IOW ('F', 320, s3c_fb_next_info_t)
+#define S3C_FB_GET_CURR_FB_INFO		_IOR ('F', 321, s3c_fb_next_info_t)
+
+/*
+ *  structures
+ */
+typedef struct {
+	int bpp;
+	int left_x;
+	int top_y;
+	int width;
+	int height;
+} s3c_win_info_t;
+
+typedef struct {
+	int width;
+	int height;
+	int bpp;
+	int offset;
+	int v_width;
+	int v_height;
+} s3c_vs_info_t;
+
+typedef struct {
+	int direction;
+	unsigned int compkey_red;
+	unsigned int compkey_green;
+	unsigned int compkey_blue;
+} s3c_color_key_info_t;
+
+typedef struct {
+	unsigned int colval_red;
+	unsigned int colval_green;
+	unsigned int colval_blue;
+} s3c_color_val_info_t;
+
+typedef struct {
+	wait_queue_head_t wait_queue;
+	int count;
+} s3c_vsync_info_t;
+
+typedef struct
+{
+	dma_addr_t map_dma_f1;
+	dma_addr_t map_dma_f2;
+} s3c_fb_dma_info_t;
+
+typedef struct {
+	__u32 phy_start_addr;
+	__u32 xres;		/* visible resolution*/
+	__u32 yres;
+	__u32 xres_virtual;	/* virtual resolution*/
+	__u32 yres_virtual;
+	__u32 xoffset;		/* offset from virtual to visible */
+	__u32 yoffset;		/* resolution	*/
+	__u32 lcd_offset_x;
+	__u32 lcd_offset_y;
+} s3c_fb_next_info_t;
+
+typedef struct {
+	struct fb_bitfield red;
+	struct fb_bitfield green;
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;
+} s3c_fb_rgb_t;
+
+const static s3c_fb_rgb_t s3c_fb_rgb_8 = {
+	.red    = {.offset = 0,  .length = 8,},
+	.green  = {.offset = 0,  .length = 8,},
+	.blue   = {.offset = 0,  .length = 8,},
+	.transp = {.offset = 0,  .length = 0,},
+};
+
+const static s3c_fb_rgb_t s3c_fb_rgb_16 = {
+	.red    = {.offset = 11, .length = 5,},
+	.green  = {.offset = 5,  .length = 6,},
+	.blue   = {.offset = 0,  .length = 5,},
+	.transp = {.offset = 0,  .length = 0,},
+};
+
+const static s3c_fb_rgb_t s3c_fb_rgb_24 = {
+	.red    = {.offset = 16, .length = 8,},
+	.green  = {.offset = 8,  .length = 8,},
+	.blue   = {.offset = 0,  .length = 8,},
+	.transp = {.offset = 0,  .length = 0,},
+};
+
+const static s3c_fb_rgb_t s3c_fb_rgb_32 = {
+	.red    = {.offset = 16, .length = 8,},
+	.green  = {.offset = 8,  .length = 8,},
+	.blue   = {.offset = 0,  .length = 8,},
+	.transp = {.offset = 24, .length = 8,},
+};
+
+typedef struct {
+	struct fb_info		fb;
+	struct device		*dev;
+
+	struct clk		*clk;
+
+	struct resource		*mem;
+	void __iomem		*io;
+
+	unsigned int		win_id;
+
+	unsigned int		max_bpp;
+	unsigned int		max_xres;
+	unsigned int		max_yres;
+
+	/* raw memory addresses */
+	dma_addr_t		map_dma_f1;	/* physical */
+	u_char *		map_cpu_f1;	/* virtual */
+	unsigned int		map_size_f1;
+
+	/* addresses of pieces placed in raw buffer */
+	u_char *		screen_cpu_f1;	/* virtual address of frame buffer */
+	dma_addr_t		screen_dma_f1;	/* physical address of frame buffer */
+
+	/* raw memory addresses */
+	dma_addr_t		map_dma_f2;	/* physical */
+	u_char *		map_cpu_f2;	/* virtual */
+	unsigned int		map_size_f2;
+
+	/* addresses of pieces placed in raw buffer */
+	u_char *		screen_cpu_f2;	/* virtual address of frame buffer */
+	dma_addr_t		screen_dma_f2;	/* physical address of frame buffer */
+
+	unsigned int		palette_ready;
+	unsigned int		fb_change_ready;
+
+	struct early_suspend	early_suspend;
+	
+	/* keep these registers in case we need to re-write palette */
+	unsigned int		palette_buffer[256];
+	unsigned int		pseudo_pal[16];
+
+	unsigned int		lcd_offset_x;
+	unsigned int		lcd_offset_y;
+	unsigned int		next_fb_info_change_req;
+	s3c_fb_next_info_t	next_fb_info;
+} s3c_fb_info_t;
+
+typedef struct {
+
+	/* Screen size */
+	int width;
+	int height;
+
+	/* Screen info */
+	int xres;
+	int yres;
+
+	/* Virtual Screen info */
+	int xres_virtual;
+	int yres_virtual;
+	int xoffset;
+	int yoffset;
+
+	/* OSD Screen size */
+	int osd_width;
+	int osd_height;
+
+	/* OSD Screen info */
+	int osd_xres;
+	int osd_yres;
+
+	/* OSD Screen info */
+	int osd_xres_virtual;
+	int osd_yres_virtual;
+
+	int bpp;
+	int bytes_per_pixel;
+	unsigned long pixclock;
+
+	int hsync_len;
+	int left_margin;
+	int right_margin;
+	int vsync_len;
+	int upper_margin;
+	int lower_margin;
+	int sync;
+
+	int cmap_grayscale:1;
+	int cmap_inverse:1;
+	int cmap_static:1;
+	int unused:29;
+
+	/* backlight info */
+	int backlight_min;
+	int backlight_max;
+	int backlight_default;
+
+	int vs_offset;
+	int brightness;
+	int palette_win;
+	int backlight_level;
+	int backlight_power;
+	int lcd_power;
+
+	s3c_vsync_info_t vsync_info;
+	s3c_vs_info_t vs_info;
+
+	/* lcd configuration registers */
+	unsigned long lcdcon1;
+	unsigned long lcdcon2;
+
+        unsigned long lcdcon3;
+	unsigned long lcdcon4;
+	unsigned long lcdcon5;
+
+	/* GPIOs */
+	unsigned long gpcup;
+	unsigned long gpcup_mask;
+	unsigned long gpccon;
+	unsigned long gpccon_mask;
+	unsigned long gpdup;
+	unsigned long gpdup_mask;
+	unsigned long gpdcon;
+	unsigned long gpdcon_mask;
+
+	/* lpc3600 control register */
+	unsigned long lpcsel;
+	unsigned long lcdtcon1;
+	unsigned long lcdtcon2;
+	unsigned long lcdtcon3;
+	unsigned long lcdosd1;
+	unsigned long lcdosd2;
+	unsigned long lcdosd3;
+	unsigned long lcdsaddrb1;
+	unsigned long lcdsaddrb2;
+	unsigned long lcdsaddrf1;
+	unsigned long lcdsaddrf2;
+	unsigned long lcdeaddrb1;
+	unsigned long lcdeaddrb2;
+	unsigned long lcdeaddrf1;
+	unsigned long lcdeaddrf2;
+	unsigned long lcdvscrb1;
+	unsigned long lcdvscrb2;
+	unsigned long lcdvscrf1;
+	unsigned long lcdvscrf2;
+	unsigned long lcdintcon;
+	unsigned long lcdkeycon;
+	unsigned long lcdkeyval;
+	unsigned long lcdbgcon;
+	unsigned long lcdfgcon;
+	unsigned long lcddithcon;
+
+	unsigned long vidcon0;
+	unsigned long vidcon1;
+	unsigned long vidtcon0;
+	unsigned long vidtcon1;
+	unsigned long vidtcon2;
+	unsigned long vidtcon3;
+	unsigned long wincon0;
+	unsigned long wincon2;
+	unsigned long wincon1;
+	unsigned long wincon3;
+	unsigned long wincon4;
+
+	unsigned long vidosd0a;
+	unsigned long vidosd0b;
+	unsigned long vidosd0c;
+	unsigned long vidosd1a;
+	unsigned long vidosd1b;
+	unsigned long vidosd1c;
+	unsigned long vidosd1d;
+	unsigned long vidosd2a;
+	unsigned long vidosd2b;
+	unsigned long vidosd2c;
+	unsigned long vidosd2d;
+	unsigned long vidosd3a;
+	unsigned long vidosd3b;
+	unsigned long vidosd3c;
+	unsigned long vidosd4a;
+	unsigned long vidosd4b;
+	unsigned long vidosd4c;
+
+	unsigned long vidw00add0b0;
+	unsigned long vidw00add0b1;
+	unsigned long vidw01add0;
+	unsigned long vidw01add0b0;
+	unsigned long vidw01add0b1;
+
+	unsigned long vidw00add1b0;
+	unsigned long vidw00add1b1;
+	unsigned long vidw01add1;
+	unsigned long vidw01add1b0;
+	unsigned long vidw01add1b1;
+
+	unsigned long vidw00add2b0;
+	unsigned long vidw00add2b1;
+
+	unsigned long vidw02add0;
+	unsigned long vidw03add0;
+	unsigned long vidw04add0;
+
+	unsigned long vidw02add1;
+	unsigned long vidw03add1;
+	unsigned long vidw04add1;
+	unsigned long vidw00add2;
+	unsigned long vidw01add2;
+	unsigned long vidw02add2;
+	unsigned long vidw03add2;
+	unsigned long vidw04add2;
+
+	unsigned long vidintcon;
+	unsigned long vidintcon0;
+	unsigned long vidintcon1;
+	unsigned long w1keycon0;
+	unsigned long w1keycon1;
+	unsigned long w2keycon0;
+	unsigned long w2keycon1;
+	unsigned long w3keycon0;
+	unsigned long w3keycon1;
+	unsigned long w4keycon0;
+	unsigned long w4keycon1;
+
+	unsigned long win0map;
+	unsigned long win1map;
+	unsigned long win2map;
+	unsigned long win3map;
+	unsigned long win4map;
+
+	unsigned long wpalcon;
+	unsigned long dithmode;
+	unsigned long intclr0;
+	unsigned long intclr1;
+	unsigned long intclr2;
+
+	unsigned long win0pal;
+	unsigned long win1pal;
+
+	/* utility functions */
+	void (*set_backlight_power)(int);
+	void (*set_lcd_power)(int);
+	void (*set_brightness)(int);
+	int (*map_video_memory)(s3c_fb_info_t *);
+	int (*unmap_video_memory)(s3c_fb_info_t *);
+}s3c_fimd_info_t;
+
+/*
+ *  Externs
+ */
+extern s3c_fb_info_t s3c_fb_info[];
+extern s3c_fimd_info_t s3c_fimd;
+
+extern int soft_cursor(struct fb_info *info, struct fb_cursor *cursor);
+extern int s3cfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg);
+extern void s3cfb_activate_var(s3c_fb_info_t *fbi, struct fb_var_screeninfo *var);
+extern void s3cfb_set_fb_addr(s3c_fb_info_t *fbi);
+extern void s3cfb_init_hw(void);
+extern irqreturn_t s3cfb_irq(int irqno, void *param);
+extern int s3cfb_init_registers(s3c_fb_info_t *fbi);
+extern int s3cfb_set_win_position(s3c_fb_info_t *fbi, int left_x, int top_y, int width, int height);
+extern int s3cfb_set_win_size(s3c_fb_info_t *fbi, int width, int height);
+extern int s3cfb_set_fb_size(s3c_fb_info_t *fbi);
+extern int s3cfb_set_vs_info(s3c_vs_info_t vs_info);
+extern int s3cfb_wait_for_vsync(void);
+extern int s3cfb_onoff_color_key(s3c_fb_info_t *fbi, int onoff);
+extern int s3cfb_onoff_color_key_alpha(s3c_fb_info_t *fbi, int onoff);
+extern int s3cfb_set_color_key_registers(s3c_fb_info_t *fbi, s3c_color_key_info_t colkey_info);
+extern int s3cfb_set_color_value(s3c_fb_info_t *fbi, s3c_color_val_info_t colval_info);
+extern int s3cfb_init_win(s3c_fb_info_t *fbi, int bpp, int left_x, int top_y, int width, int height, int onoff);
+extern int s3cfb_onoff_win(s3c_fb_info_t *fbi, int onoff);
+extern int s3cfb_set_gpio(void);
+extern void s3cfb_start_lcd(void);
+extern void s3cfb_stop_lcd(void);
+extern int s3cfb_suspend(struct platform_device *dev, pm_message_t state);
+extern int s3cfb_resume(struct platform_device *dev);
+extern int s3cfb_shutdown(struct platform_device *dev);	
+extern int s3cfb_spi_gpio_request(int ch);
+extern void s3cfb_spi_lcd_den(int ch, int value);
+extern void s3cfb_spi_lcd_dseri(int ch, int value);
+extern void s3cfb_spi_lcd_dclk(int ch, int value);
+extern void s3cfb_spi_set_lcd_data(int ch);
+extern int s3cfb_spi_gpio_free(int ch);
+extern void s3cfb_pre_init(void);
+extern void s3cfb_display_logo(int win_num);
+extern void s3cfb_start_progress(void);
+extern void s3cfb_stop_progress(void);
+extern void s3cfb_set_lcd_power(int to);
+extern void s3cfb_set_backlight_power(int to);
+extern void s3cfb_set_backlight_level(int to);
+
+extern struct early_suspend *get_earlysuspend_ptr(void);
+extern void s3cfb_enable_clock_power(void);
+extern int s3cfb_is_clock_on(void);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+extern void s3cfb_early_suspend(struct early_suspend *h);
+extern void s3cfb_late_resume(struct early_suspend *h);
+#endif	/* CONFIG_HAS_EARLYSUSPEND */
+
+#endif
+
diff -Nur linux-2.6.29/drivers/video/samsung/s3cfb_progress.h linux-2.6.29-spica/drivers/video/samsung/s3cfb_progress.h
--- linux-2.6.29/drivers/video/samsung/s3cfb_progress.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/video/samsung/s3cfb_progress.h	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,933 @@
+
+static unsigned char progress_bg[] = {
+		0x42, 0x4D, 0xD6, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x36, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0xF0, 0x00, 
+		0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0xA0, 0x23, 0x00, 0x00, 0x13, 0x0B, 
+		0x00, 0x00, 0x13, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0xC6, 0x18, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 0xE7, 0x1C, 
+		0xE7, 0x1C, 0xC6, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0xEF, 0x3D, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0xEF, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0xEF, 0x3D, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0xEF, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 0x63, 0x0C, 
+		0x63, 0x0C, 0x63, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00
+};
+
+static  unsigned char progress_bar[] = {
+		0x42, 0x4D, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x36, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x01, 0x00, 
+		0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x13, 0x0B, 
+		0x00, 0x00, 0x13, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x6B, 0x2D, 0x00, 0x00, 0x29, 0x25, 
+		0x00, 0x00, 0x29, 0x25, 0x00, 0x00, 0x29, 0x25, 0x00, 0x00, 
+		0x29, 0x25, 0x00, 0x00, 0x29, 0x25, 0x00, 0x00, 0x29, 0x25, 
+		0x00, 0x00, 0x6B, 0x2D, 0x00, 0x00
+};
diff -Nur linux-2.6.29/drivers/video/samsung/s3cfb_progress_hvga.h linux-2.6.29-spica/drivers/video/samsung/s3cfb_progress_hvga.h
--- linux-2.6.29/drivers/video/samsung/s3cfb_progress_hvga.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/video/samsung/s3cfb_progress_hvga.h	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,1622 @@
+static unsigned char progress_bg[] = {
+		0x42, 0x4D, 0xB6, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x36, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x40, 0x01, 
+		0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x80, 0x3E, 0x00, 0x00, 0x13, 0x0B, 
+		0x00, 0x00, 0x13, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x8C, 0x31, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x8C, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0xAD, 0x35, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 0x31, 0x46, 
+		0x31, 0x46, 0xAD, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00
+};
+	
+static unsigned char progress_bar[] = {
+		0x42, 0x4D, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x36, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x01, 0x00, 
+		0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x13, 0x0B, 
+		0x00, 0x00, 0x13, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x8C, 0x31, 0x00, 0x00, 0x29, 0x25, 
+		0x00, 0x00, 0x29, 0x25, 0x00, 0x00, 0x29, 0x25, 0x00, 0x00, 
+		0x29, 0x25, 0x00, 0x00, 0x29, 0x25, 0x00, 0x00, 0x29, 0x25, 
+		0x00, 0x00, 0x29, 0x25, 0x00, 0x00, 0x29, 0x25, 0x00, 0x00, 
+		0x29, 0x25, 0x00, 0x00, 0x29, 0x25, 0x00, 0x00, 0x8C, 0x31, 
+		0x00, 0x00
+};
diff -Nur linux-2.6.29/drivers/video/samsung/s3cfb_s6d04d1.c linux-2.6.29-spica/drivers/video/samsung/s3cfb_s6d04d1.c
--- linux-2.6.29/drivers/video/samsung/s3cfb_s6d04d1.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/video/samsung/s3cfb_s6d04d1.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,702 @@
+/*
+ * drivers/video/samsung/s3cfb_mdj2024wv.c
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#include <linux/wait.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+
+#include <linux/i2c/maximi2c.h>
+
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <plat/regs-lcd.h>
+
+#include <mach/hardware.h>
+
+#include "s3cfb.h"
+
+#define BACKLIGHT_MODE_NORMAL	0x000
+#define BACKLIGHT_MODE_ALC		0x100
+#define BACKLIGHT_MODE_CABC		0x200
+
+#define BACKLIGHT_LEVEL_VALUE	0x0FF	/* 0 ~ 255 */
+
+#define BACKLIGHT_LEVEL_MIN		0
+#define BACKLIGHT_LEVEL_MAX		(BACKLIGHT_MODE_NORMAL | BACKLIGHT_LEVEL_VALUE)
+
+#define BACKLIGHT_LEVEL_DEFAULT	BACKLIGHT_LEVEL_MAX		/* Default Setting */
+
+int lcd_power = OFF;
+EXPORT_SYMBOL(lcd_power);
+
+void lcd_power_ctrl(s32 value);
+EXPORT_SYMBOL(lcd_power_ctrl);
+
+int backlight_power = OFF;
+EXPORT_SYMBOL(backlight_power);
+
+void backlight_power_ctrl(s32 value);
+EXPORT_SYMBOL(backlight_power_ctrl);
+
+int backlight_level = BACKLIGHT_LEVEL_DEFAULT;
+EXPORT_SYMBOL(backlight_level);
+
+void backlight_level_ctrl(s32 value);
+EXPORT_SYMBOL(backlight_level_ctrl);
+
+#define S3C_FB_HFP              8       /* Front Porch */
+#define S3C_FB_HSW              12		/* Hsync Width */
+#define S3C_FB_HBP              24		/* Back Porch */
+
+#define S3C_FB_VFP              8       /* Front Porch */
+#define S3C_FB_VSW              2		/* Vsync Width */
+#define S3C_FB_VBP              8       /* Back Porch */
+
+#define S3C_FB_HRES             240     /* Horizon pixel Resolition */
+#define S3C_FB_VRES             400     /* Vertical pixel Resolution */
+
+#define S3C_FB_HRES_VIRTUAL     S3C_FB_HRES     /* Horizon pixel Resolition */
+#define S3C_FB_VRES_VIRTUAL     (S3C_FB_VRES * 2) 	/* Vertial pixel Resolution */
+
+#define S3C_FB_HRES_OSD         240     /* Horizon pixel Resolition */
+#define S3C_FB_VRES_OSD         400     /* Vertial pixel Resolution */
+
+#define S3C_FB_HRES_OSD_VIRTUAL S3C_FB_HRES_OSD     /* Horizon pixel Resolition */
+#define S3C_FB_VRES_OSD_VIRTUAL (S3C_FB_VRES_OSD * 2) 	/* Vertial pixel Resolution */
+
+#define S3C_FB_VFRAME_FREQ      60      /* Frame Rate Frequency */
+
+#define S3C_FB_PIXEL_CLOCK      (S3C_FB_VFRAME_FREQ * \
+                                (S3C_FB_HFP + S3C_FB_HSW + S3C_FB_HBP + S3C_FB_HRES) * \
+                                (S3C_FB_VFP + S3C_FB_VSW + S3C_FB_VBP + S3C_FB_VRES))
+
+static void s3cfb_set_fimd_info(void)
+{
+	s3c_fimd.vidcon1    =  S3C_VIDCON1_IVCLK_FALL_EDGE | 
+						  S3C_VIDCON1_IHSYNC_INVERT |
+	                      S3C_VIDCON1_IVSYNC_INVERT |
+	                      S3C_VIDCON1_IVDEN_NORMAL;
+
+	s3c_fimd.vidtcon0   = S3C_VIDTCON0_VBPD(S3C_FB_VBP - 1) |
+	                      S3C_VIDTCON0_VFPD(S3C_FB_VFP - 1) |
+	                      S3C_VIDTCON0_VSPW(S3C_FB_VSW - 1);
+	s3c_fimd.vidtcon1   = S3C_VIDTCON1_HBPD(S3C_FB_HBP - 1) |
+	                      S3C_VIDTCON1_HFPD(S3C_FB_HFP - 1) |
+	                      S3C_VIDTCON1_HSPW(S3C_FB_HSW - 1);
+	s3c_fimd.vidtcon2   = S3C_VIDTCON2_LINEVAL(S3C_FB_VRES - 1) |
+	                      S3C_VIDTCON2_HOZVAL(S3C_FB_HRES - 1);
+
+	s3c_fimd.vidosd0a   = S3C_VIDOSDxA_OSD_LTX_F(0) |
+	                      S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3c_fimd.vidosd0b   = S3C_VIDOSDxB_OSD_RBX_F(S3C_FB_HRES - 1) |
+	                      S3C_VIDOSDxB_OSD_RBY_F(S3C_FB_VRES - 1);
+
+	s3c_fimd.vidosd1a   = S3C_VIDOSDxA_OSD_LTX_F(0) |
+	                      S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3c_fimd.vidosd1b   = S3C_VIDOSDxB_OSD_RBX_F(S3C_FB_HRES_OSD - 1) |
+	                      S3C_VIDOSDxB_OSD_RBY_F(S3C_FB_VRES_OSD - 1);
+
+	s3c_fimd.width		= S3C_FB_HRES;
+	s3c_fimd.height 	= S3C_FB_VRES;
+	s3c_fimd.xres 		= S3C_FB_HRES;
+	s3c_fimd.yres 		= S3C_FB_VRES;
+
+#if defined(CONFIG_FB_S3C_VIRTUAL_SCREEN)
+	s3c_fimd.xres_virtual = S3C_FB_HRES_VIRTUAL;
+	s3c_fimd.yres_virtual = S3C_FB_VRES_VIRTUAL;
+#else
+	s3c_fimd.xres_virtual = S3C_FB_HRES;
+	s3c_fimd.yres_virtual = S3C_FB_VRES;
+#endif
+
+	s3c_fimd.osd_width 	= S3C_FB_HRES_OSD;
+	s3c_fimd.osd_height = S3C_FB_VRES_OSD;
+	s3c_fimd.osd_xres 	= S3C_FB_HRES_OSD;
+	s3c_fimd.osd_yres 	= S3C_FB_VRES_OSD;
+
+#if defined(CONFIG_FB_S3C_VIRTUAL_SCREEN)
+	s3c_fimd.osd_xres_virtual = S3C_FB_HRES_OSD_VIRTUAL;
+	s3c_fimd.osd_yres_virtual = S3C_FB_VRES_OSD_VIRTUAL;
+#else
+	s3c_fimd.osd_xres_virtual = S3C_FB_HRES_OSD;
+	s3c_fimd.osd_yres_virtual = S3C_FB_VRES_OSD;
+#endif
+
+	s3c_fimd.pixclock		= S3C_FB_PIXEL_CLOCK;
+
+	s3c_fimd.hsync_len 		= S3C_FB_HSW;
+	s3c_fimd.vsync_len 		= S3C_FB_VSW;
+	s3c_fimd.left_margin 	= S3C_FB_HFP;
+	s3c_fimd.upper_margin 	= S3C_FB_VFP;
+	s3c_fimd.right_margin 	= S3C_FB_HBP;
+	s3c_fimd.lower_margin 	= S3C_FB_VBP;
+
+	s3c_fimd.set_lcd_power		 = lcd_power_ctrl;
+	s3c_fimd.set_backlight_power = backlight_power_ctrl;
+	s3c_fimd.set_brightness 	 = backlight_level_ctrl;
+
+	s3c_fimd.backlight_min = BACKLIGHT_LEVEL_MIN;
+	s3c_fimd.backlight_max = BACKLIGHT_LEVEL_MAX;
+}
+
+static void lcd_gpio_init(void)
+{
+	/* B(0:5) */
+	s3c_gpio_cfgpin(GPIO_LCD_B_0, S3C_GPIO_SFN(GPIO_LCD_B_0_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_B_1, S3C_GPIO_SFN(GPIO_LCD_B_1_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_B_2, S3C_GPIO_SFN(GPIO_LCD_B_2_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_B_3, S3C_GPIO_SFN(GPIO_LCD_B_3_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_B_4, S3C_GPIO_SFN(GPIO_LCD_B_4_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_B_5, S3C_GPIO_SFN(GPIO_LCD_B_5_AF));
+	/* G(0:5) */
+	s3c_gpio_cfgpin(GPIO_LCD_G_0, S3C_GPIO_SFN(GPIO_LCD_G_0_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_G_1, S3C_GPIO_SFN(GPIO_LCD_G_1_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_G_2, S3C_GPIO_SFN(GPIO_LCD_G_2_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_G_3, S3C_GPIO_SFN(GPIO_LCD_G_3_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_G_4, S3C_GPIO_SFN(GPIO_LCD_G_4_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_G_5, S3C_GPIO_SFN(GPIO_LCD_G_5_AF));
+	/* R(0:5) */
+	s3c_gpio_cfgpin(GPIO_LCD_R_0, S3C_GPIO_SFN(GPIO_LCD_R_0_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_R_1, S3C_GPIO_SFN(GPIO_LCD_R_1_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_R_2, S3C_GPIO_SFN(GPIO_LCD_R_2_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_R_3, S3C_GPIO_SFN(GPIO_LCD_R_3_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_R_4, S3C_GPIO_SFN(GPIO_LCD_R_4_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_R_5, S3C_GPIO_SFN(GPIO_LCD_R_5_AF));
+	/* HSYNC */
+	s3c_gpio_cfgpin(GPIO_LCD_HSYNC, S3C_GPIO_SFN(GPIO_LCD_HSYNC_AF));
+	/* VSYNC */
+	s3c_gpio_cfgpin(GPIO_LCD_VSYNC, S3C_GPIO_SFN(GPIO_LCD_VSYNC_AF));
+	/* DE */
+	s3c_gpio_cfgpin(GPIO_LCD_DE, S3C_GPIO_SFN(GPIO_LCD_DE_AF));
+	/* CLK */
+	s3c_gpio_cfgpin(GPIO_LCD_CLK, S3C_GPIO_SFN(GPIO_LCD_CLK_AF));
+	
+	/* LCD_RST_N */
+	if (gpio_is_valid(GPIO_LCD_RST_N)) {
+		if (gpio_request(GPIO_LCD_RST_N, S3C_GPIO_LAVEL(GPIO_LCD_RST_N))) 
+			printk(KERN_ERR "Failed to request GPIO_LCD_RST_N!\n");
+		gpio_direction_output(GPIO_LCD_RST_N, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_LCD_RST_N, S3C_GPIO_PULL_NONE);
+	/* LCD_ID */
+	if (gpio_is_valid(GPIO_LCD_ID)) {
+		if (gpio_request(GPIO_LCD_ID, S3C_GPIO_LAVEL(GPIO_LCD_ID))) 
+			printk(KERN_ERR "Failed to request GPIO_LCD_ID!\n");
+		gpio_direction_input(GPIO_LCD_ID);
+	}
+	s3c_gpio_setpull(GPIO_LCD_ID, S3C_GPIO_PULL_NONE);
+
+	/* LCD_SCLK */
+	if (gpio_is_valid(GPIO_LCD_SCLK)) {
+		if (gpio_request(GPIO_LCD_SCLK, S3C_GPIO_LAVEL(GPIO_LCD_SCLK))) 
+			printk(KERN_ERR "Failed to request GPIO_LCD_SCLK!\n");
+		gpio_direction_output(GPIO_LCD_SCLK, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_LCD_SCLK, S3C_GPIO_PULL_NONE);
+	/* LCD_CS_N */
+	if (gpio_is_valid(GPIO_LCD_CS_N)) {
+		if (gpio_request(GPIO_LCD_CS_N, S3C_GPIO_LAVEL(GPIO_LCD_CS_N))) 
+			printk(KERN_ERR "Failed to request GPIO_LCD_CS_N!\n");
+		gpio_direction_output(GPIO_LCD_CS_N, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_LCD_CS_N, S3C_GPIO_PULL_NONE);
+	/* LCD_SDI */
+	if (gpio_is_valid(GPIO_LCD_SDI)) {
+		if (gpio_request(GPIO_LCD_SDI, S3C_GPIO_LAVEL(GPIO_LCD_SDI))) 
+			printk(KERN_ERR "Failed to request GPIO_LCD_SDI!\n");
+		gpio_direction_output(GPIO_LCD_SDI, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_LCD_SDI, S3C_GPIO_PULL_NONE);
+}
+
+static void backlight_gpio_init(void)
+{
+}
+
+/*
+ * Serial Interface
+ */
+
+#define LCD_CSX_HIGH	gpio_set_value(GPIO_LCD_CS_N, GPIO_LEVEL_HIGH);
+#define LCD_CSX_LOW		gpio_set_value(GPIO_LCD_CS_N, GPIO_LEVEL_LOW);
+
+#define LCD_SCL_HIGH	gpio_set_value(GPIO_LCD_SCLK, GPIO_LEVEL_HIGH);
+#define LCD_SCL_LOW		gpio_set_value(GPIO_LCD_SCLK, GPIO_LEVEL_LOW);
+
+#define LCD_SDI_HIGH	gpio_set_value(GPIO_LCD_SDI, GPIO_LEVEL_HIGH);
+#define LCD_SDI_LOW		gpio_set_value(GPIO_LCD_SDI, GPIO_LEVEL_LOW);
+
+#define DEFAULT_USLEEP	10	
+
+#define POWCTL			0xF3
+#define VCMCTL			0xF4
+#define SRCCTL			0xF5
+#define SLPOUT			0x11
+#define MADCTL			0x36
+#define COLMOD			0x3A
+#define DISCTL			0xF2
+#define IFCTL			0xF6
+#define GATECTL			0xFD
+#define WRDISBV			0x51
+#define WRCABCMB		0x5E
+#define MIECTL1			0xCA
+#define BCMODE			0xCB
+#define MIECTL2			0xCC
+#define MIDCTL3			0xCD
+#define RPGAMCTL		0xF7
+#define RNGAMCTL		0xF8
+#define GPGAMCTL		0xF9
+#define GNGAMCTL		0xFA
+#define BPGAMCTL		0xFB
+#define BNGAMCTL		0xFC
+#define CASET			0x2A
+#define PASET			0x2B
+#define RAMWR           0x2C
+#define WRCTRLD			0x53
+#define WRCABC			0x55
+#define DISPON			0x29
+#define DISPOFF			0x28
+#define SLPIN			0x10
+
+struct setting_table {
+	u8 command;	
+	u8 parameters;
+	u8 parameter[15];
+	s32 wait;
+};
+
+static struct setting_table power_on_setting_table[] = {
+	{   POWCTL,  7, { 0x80, 0x00, 0x00, 0x09, 0x33, 0x75, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
+	{   VCMCTL,  5, { 0x57, 0x57, 0x6C, 0x6C, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
+	{   SRCCTL,  5, { 0x12, 0x00, 0x03, 0xF0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
+	{   SLPOUT,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 120 },
+	{   MADCTL,  1, { 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
+	{   COLMOD,  1, { 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  30 },	
+	{   DISCTL, 11, { 0x15, 0x15, 0x03, 0x08, 0x08, 0x08, 0x08, 0x10, 0x04, 0x16, 0x16, 0x00, 0x00, 0x00, 0x00 },   0 },	
+	{    IFCTL,  4, { 0x00, 0x81, 0x30, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
+	{  GATECTL,  2, { 0x22, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
+	{  WRDISBV,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
+	{ WRCABCMB,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
+	{  MIECTL1,  3, { 0x80, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
+	{   BCMODE,  1, { 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
+	{  MIECTL2,  3, { 0x20, 0x01, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
+	{  MIDCTL3,  2, { 0x7C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
+	{ RPGAMCTL, 15, { 0x00, 0x35, 0x00, 0x02, 0x10, 0x0E, 0x11, 0x1A, 0x24, 0x22, 0x19, 0x0F, 0x00, 0x22, 0x22 },   0 },	
+	{ RNGAMCTL, 15, { 0x2B, 0x00, 0x00, 0x02, 0x10, 0x0E, 0x11, 0x1A, 0x24, 0x22, 0x19, 0x0F, 0x22, 0x22, 0x22 },   0 },	
+	{ GPGAMCTL, 15, { 0x00, 0x35, 0x00, 0x02, 0x10, 0x0C, 0x0D, 0x14, 0x2C, 0x2D, 0x2B, 0x1F, 0x13, 0x22, 0x22 },   0 },	
+	{ GNGAMCTL, 15, { 0x2B, 0x00, 0x00, 0x02, 0x10, 0x0C, 0x0D, 0x14, 0x2C, 0x2D, 0x2B, 0x1F, 0x13, 0x22, 0x22 },   0 },	
+	{ BPGAMCTL, 15, { 0x21, 0x35, 0x00, 0x02, 0x10, 0x14, 0x18, 0x21, 0x1E, 0x20, 0x19, 0x0F, 0x00, 0x22, 0x22 },   0 },	
+	{ BNGAMCTL, 15, { 0x2B, 0x21, 0x00, 0x02, 0x10, 0x14, 0x18, 0x21, 0x1E, 0x20, 0x19, 0x0F, 0x00, 0x22, 0x22 },   0 },	
+	{    CASET,  4, { 0x00, 0x00, 0x00, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
+	{    PASET,  4, { 0x00, 0x00, 0x01, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
+	{    RAMWR,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
+	{  WRCTRLD,  1, { 0x2C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
+	{   WRCABC,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
+	{   DISPON,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  50 },	
+};
+
+#define POWER_ON_SETTINGS	(int)(sizeof(power_on_setting_table)/sizeof(struct setting_table))
+
+static struct setting_table power_off_setting_table[] = {
+	{  WRCTRLD,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
+	{  DISPOFF,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  40 },
+	{    SLPIN,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 120 },
+};
+
+#define POWER_OFF_SETTINGS	(int)(sizeof(power_off_setting_table)/sizeof(struct setting_table))
+#if 0
+static struct setting_table cabc_on_setting_table =
+	{  WRCABC,  1, { 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 };
+
+static struct setting_table cabc_off_setting_table =
+	{  WRCABC,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 };
+#endif
+static struct setting_table backlight_setting_table = 
+	{ WRDISBV,  1, { 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 };
+
+static void setting_table_write(struct setting_table *table)
+{
+	s32 i, j;
+
+	LCD_CSX_HIGH
+	udelay(DEFAULT_USLEEP);
+	LCD_SCL_HIGH 
+	udelay(DEFAULT_USLEEP);
+
+	/* Write Command */
+	LCD_CSX_LOW
+	udelay(DEFAULT_USLEEP);
+	LCD_SCL_LOW 
+	udelay(DEFAULT_USLEEP);		
+	LCD_SDI_LOW 
+	udelay(DEFAULT_USLEEP);
+	
+	LCD_SCL_HIGH 
+	udelay(DEFAULT_USLEEP); 
+
+   	for (i = 7; i >= 0; i--) { 
+		LCD_SCL_LOW
+		udelay(DEFAULT_USLEEP);
+		if ((table->command >> i) & 0x1)
+			LCD_SDI_HIGH
+		else
+			LCD_SDI_LOW
+		udelay(DEFAULT_USLEEP);	
+		LCD_SCL_HIGH
+		udelay(DEFAULT_USLEEP);	
+	}
+
+	LCD_CSX_HIGH
+	udelay(DEFAULT_USLEEP);	
+
+	/* Write Parameter */
+	if ((table->parameters) > 0) {
+	for (j = 0; j < table->parameters; j++) {
+		LCD_CSX_LOW 
+		udelay(DEFAULT_USLEEP); 	
+		
+		LCD_SCL_LOW 
+		udelay(DEFAULT_USLEEP); 	
+		LCD_SDI_HIGH 
+		udelay(DEFAULT_USLEEP);
+		LCD_SCL_HIGH 
+		udelay(DEFAULT_USLEEP); 	
+
+		for (i = 7; i >= 0; i--) { 
+			LCD_SCL_LOW
+			udelay(DEFAULT_USLEEP);	
+			if ((table->parameter[j] >> i) & 0x1)
+				LCD_SDI_HIGH
+			else
+				LCD_SDI_LOW
+			udelay(DEFAULT_USLEEP);	
+			LCD_SCL_HIGH
+			udelay(DEFAULT_USLEEP);					
+		}
+
+			LCD_CSX_HIGH
+			udelay(DEFAULT_USLEEP);	
+	}
+	}
+
+	msleep(table->wait);
+}
+
+/*
+ *	LCD Power Handler
+ */
+
+#define MAX8698_ID		0xCC
+
+#define ONOFF2			0x01
+
+#define ONOFF2_ELDO6	(0x01 << 7)
+#define ONOFF2_ELDO7	(0x03 << 6)
+
+void lcd_power_ctrl(s32 value)
+{
+	s32 i;	
+	u8 data;
+	
+	if (value) {
+	
+		/* Power On Sequence */
+	
+		/* Reset Asseert */
+		gpio_set_value(GPIO_LCD_RST_N, GPIO_LEVEL_LOW);
+
+		/* Power Enable */
+		pmic_read(MAX8698_ID, ONOFF2, &data, 1); 
+		data |= (ONOFF2_ELDO6 | ONOFF2_ELDO7);
+		pmic_write(MAX8698_ID, ONOFF2, &data, 1); 
+
+		msleep(50);	
+
+		/* Reset Deasseert */
+		gpio_set_value(GPIO_LCD_RST_N, GPIO_LEVEL_HIGH);
+
+		msleep(10);	
+
+		for (i = 0; i < POWER_ON_SETTINGS; i++)
+			setting_table_write(&power_on_setting_table[i]);	
+	}
+	else {
+
+		/* Power Off Sequence */
+	
+		for (i = 0; i < POWER_OFF_SETTINGS; i++)
+			setting_table_write(&power_off_setting_table[i]);	
+
+		/* Reset Assert */
+		gpio_set_value(GPIO_LCD_RST_N, GPIO_LEVEL_LOW);
+		
+		/* Power Disable */
+		pmic_read(MAX8698_ID, ONOFF2, &data, 1); 
+		data &= ~(ONOFF2_ELDO6 | ONOFF2_ELDO7);
+		pmic_write(MAX8698_ID, ONOFF2, &data, 1); 
+	}
+
+	lcd_power = value;
+}
+
+void backlight_ctrl(s32 value)
+{
+	if (value) {
+		
+		/* Backlight On Sequence */
+
+		if (lcd_power == OFF)
+			lcd_power_ctrl(ON);
+
+	  	
+		backlight_setting_table.parameter[0] = (value & BACKLIGHT_LEVEL_VALUE);
+		
+		setting_table_write(&backlight_setting_table);	
+	
+		backlight_power = ON;
+	}
+	else {
+		
+		/* Backlight Off Sequence */
+
+		lcd_power_ctrl(OFF);	
+
+		backlight_power = OFF;
+	}
+}
+
+void backlight_level_ctrl(s32 value)
+{
+	if ((value < BACKLIGHT_LEVEL_MIN) ||	/* Invalid Value */
+		(value > BACKLIGHT_LEVEL_MAX) ||
+		(value == backlight_level))	/* Same Value */
+		return;
+
+	if (backlight_power)
+		backlight_ctrl(value);	
+	
+	backlight_level = value;	
+}
+
+void backlight_power_ctrl(s32 value)
+{
+	if ((value < OFF) ||	/* Invalid Value */
+		(value > ON) ||
+		(value == backlight_power))	/* Same Value */
+		return;
+
+	backlight_ctrl((value ? backlight_level : OFF));	
+	
+	backlight_power = (value ? ON : OFF);
+}
+
+#define S6D04D1_DEFAULT_BACKLIGHT_BRIGHTNESS	255
+
+static s32 s6d04d1_backlight_off;
+static s32 s6d04d1_backlight_brightness = S6D04D1_DEFAULT_BACKLIGHT_BRIGHTNESS;
+static u8 s6d04d1_backlight_last_level = 33;
+static DEFINE_MUTEX(s6d04d1_backlight_lock);
+
+static void s6d04d1_set_backlight_level(u8 level)
+{
+	if (s6d04d1_backlight_last_level == level)
+		return;
+
+	backlight_ctrl(level);	
+	
+	s6d04d1_backlight_last_level = level;
+}
+
+static void s6d04d1_brightness_set(struct led_classdev *led_cdev, enum led_brightness value)
+{
+	mutex_lock(&s6d04d1_backlight_lock);
+	s6d04d1_backlight_brightness = value;
+	if(!s6d04d1_backlight_off)
+		s6d04d1_set_backlight_level(s6d04d1_backlight_brightness);
+	mutex_unlock(&s6d04d1_backlight_lock);
+}
+
+static struct led_classdev s6d04d1_backlight_led  = {
+	.name		= "lcd-backlight",
+	.brightness = S6D04D1_DEFAULT_BACKLIGHT_BRIGHTNESS,
+	.brightness_set = s6d04d1_brightness_set,
+};
+
+static int s6d04d1_backlight_probe(struct platform_device *pdev)
+{
+	led_classdev_register(&pdev->dev, &s6d04d1_backlight_led);
+	return 0;
+}
+
+static int s6d04d1_backlight_remove(struct platform_device *pdev)
+{
+	led_classdev_unregister(&s6d04d1_backlight_led);
+	return 0;
+}
+
+static struct platform_driver s6d04d1_backlight_driver = {
+	.probe		= s6d04d1_backlight_probe,
+	.remove		= s6d04d1_backlight_remove,
+	.driver		= {
+		.name		= "s6d04d1-backlight",
+		.owner		= THIS_MODULE,
+	},
+};
+
+static int __init s6d04d1_backlight_init(void)
+{
+	return platform_driver_register(&s6d04d1_backlight_driver);
+}
+
+static void __exit s6d04d1_backlight_exit(void)
+{
+	platform_driver_unregister(&s6d04d1_backlight_driver);
+}
+module_init(s6d04d1_backlight_init);
+module_exit(s6d04d1_backlight_exit);
+
+void s3cfb_init_hw(void)
+{
+	s3cfb_set_fimd_info();
+
+	s3cfb_set_gpio();
+#ifdef CONFIG_FB_S3C_LCD_INIT	
+	lcd_gpio_init();
+	
+	backlight_gpio_init();
+
+	lcd_power_ctrl(ON);
+
+	backlight_level_ctrl(BACKLIGHT_LEVEL_DEFAULT);
+
+	backlight_power_ctrl(ON); 
+#else
+	lcd_gpio_init();
+	
+	backlight_gpio_init();
+	
+	lcd_power = ON;
+
+	backlight_level = BACKLIGHT_LEVEL_DEFAULT;
+
+	backlight_power = ON;
+#endif
+}
+
+#define LOGO_MEM_BASE		(0x50000000 + 0x0D000000 - 0x100000)	/* SDRAM_BASE + SRAM_SIZE(208MB) - 1MB */
+#define LOGO_MEM_SIZE		(S3C_FB_HRES * S3C_FB_VRES * 2)
+
+void s3cfb_display_logo(int win_num)
+{
+	s3c_fb_info_t *fbi = &s3c_fb_info[0];
+	u8 *logo_virt_buf;
+	
+	logo_virt_buf = ioremap_nocache(LOGO_MEM_BASE, LOGO_MEM_SIZE);
+
+	memcpy(fbi->map_cpu_f1, logo_virt_buf, LOGO_MEM_SIZE);	
+
+	iounmap(logo_virt_buf);
+}
+
+#include "s3cfb_progress.h"
+
+static int progress = 0;
+
+static int progress_flag = OFF;
+
+static struct timer_list progress_timer;
+
+static void progress_timer_handler(unsigned long data)
+{
+	s3c_fb_info_t *fbi = &s3c_fb_info[1];
+	unsigned short *bar_src, *bar_dst;	
+	int	i, j, p;
+
+	/* 1 * 8 R5G5B5 BMP (Aligned 4 Bytes) */
+	bar_dst = (unsigned short *)(fbi->map_cpu_f1 + (((240 * 347) + 31) * 2));
+	bar_src = (unsigned short *)(progress_bar + sizeof(progress_bar) - 4);
+
+	for (i = 0; i < 8; i++) {
+		for (j = 0; j < 2; j++) {
+			p = ((240 * i) + (progress * 2) + j);
+			*(bar_dst + p) = (*(bar_src - (i * 2)) | 0x8000);
+		}
+	}	
+
+	progress++;
+
+	if (progress > 88) {
+		del_timer(&progress_timer);
+	}
+	else {
+		progress_timer.expires = (get_jiffies_64() + (HZ/15)); 
+		progress_timer.function = progress_timer_handler; 
+		add_timer(&progress_timer);
+	}
+}
+
+static unsigned int new_wincon1; 
+static unsigned int old_wincon1; 
+
+void s3cfb_start_progress(void)
+{
+	s3c_fb_info_t *fbi = &s3c_fb_info[1];
+	unsigned short *bg_src, *bg_dst;	
+	int	i, j, p;
+	
+	memset(fbi->map_cpu_f1, 0x00, LOGO_MEM_SIZE);	
+
+	/* 240 * 19 R5G5B5 BMP */
+	bg_dst = (unsigned short *)(fbi->map_cpu_f1 + ((240 * 342) * 2));
+	bg_src = (unsigned short *)(progress_bg + sizeof(progress_bg) - 2);
+
+	for (i = 0; i < 19; i++) {
+		for (j = 0; j < 240; j++) {
+			p = ((240 * i) + j);
+			if ((*(bg_src - p) & 0x7FFF) == 0x0000)
+				*(bg_dst + p) = (*(bg_src - p) & ~0x8000);
+			else
+				*(bg_dst + p) = (*(bg_src - p) | 0x8000);
+		}
+	}	
+
+	old_wincon1 = readl(S3C_WINCON1);
+
+	new_wincon1 = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_BUFSEL_0 | S3C_WINCONx_BUFAUTOEN_DISABLE | \
+	           S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+	           S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_BPPMODE_F_16BPP_A555 | \
+	           S3C_WINCONx_ALPHA_SEL_0 | S3C_WINCONx_ENWIN_F_ENABLE,
+
+	writel(new_wincon1, S3C_WINCON1);
+
+	init_timer(&progress_timer);
+	progress_timer.expires = (get_jiffies_64() + (HZ/10)); 
+	progress_timer.function = progress_timer_handler; 
+	add_timer(&progress_timer);
+
+	progress_flag = ON;
+}
+
+void s3cfb_stop_progress(void)
+{
+	if (progress_flag == OFF)
+		return;
+
+	del_timer(&progress_timer);
+	
+	writel(old_wincon1, S3C_WINCON1);
+	
+	progress_flag = OFF;
+}
diff -Nur linux-2.6.29/drivers/video/samsung/s3cfb_s6d05a.c linux-2.6.29-spica/drivers/video/samsung/s3cfb_s6d05a.c
--- linux-2.6.29/drivers/video/samsung/s3cfb_s6d05a.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/video/samsung/s3cfb_s6d05a.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,788 @@
+/*
+ * drivers/video/samsung/s3cfb_mdj2024wv.c
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#include <linux/wait.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+
+#include <linux/i2c/maximi2c.h>
+
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <plat/regs-lcd.h>
+
+#include <mach/hardware.h>
+
+#include "s3cfb.h"
+
+#define BACKLIGHT_MODE_NORMAL	0x000
+#define BACKLIGHT_MODE_ALC		0x100
+#define BACKLIGHT_MODE_CABC		0x200
+
+#define BACKLIGHT_LEVEL_VALUE	0x0FF	/* 0 ~ 255 */
+
+#define BACKLIGHT_LEVEL_MIN		0
+#define BACKLIGHT_LEVEL_MAX		(BACKLIGHT_MODE_NORMAL | BACKLIGHT_LEVEL_VALUE)
+
+#define BACKLIGHT_LEVEL_DEFAULT	BACKLIGHT_LEVEL_MAX		/* Default Setting */
+
+/* sec_bsp_tsim 2009.08.12 : reset lcd before reboot this machine. */
+void lcd_reset(void)
+{
+	gpio_set_value(GPIO_LCD_RST_N, GPIO_LEVEL_LOW);
+};
+EXPORT_SYMBOL(lcd_reset);
+
+int lcd_power = OFF;
+EXPORT_SYMBOL(lcd_power);
+
+void lcd_power_ctrl(s32 value);
+EXPORT_SYMBOL(lcd_power_ctrl);
+
+int backlight_power = OFF;
+EXPORT_SYMBOL(backlight_power);
+
+void backlight_power_ctrl(s32 value);
+EXPORT_SYMBOL(backlight_power_ctrl);
+
+int backlight_level = BACKLIGHT_LEVEL_DEFAULT;
+EXPORT_SYMBOL(backlight_level);
+
+void backlight_level_ctrl(s32 value);
+EXPORT_SYMBOL(backlight_level_ctrl);
+
+#define S3C_FB_HFP				10 		/* Front Porch */
+#define S3C_FB_HSW				10 		/* Hsync Width */
+#define S3C_FB_HBP				10 		/* Back Porch */
+
+#define S3C_FB_VFP				3 		/* Front Porch */
+#define S3C_FB_VSW				2 		/* Vsync Width */
+#define S3C_FB_VBP				8 		/* Back Porch */
+
+#define S3C_FB_HRES				320 	/* Horizon pixel Resolition */
+#define S3C_FB_VRES				480 	/* Vertical pixel Resolution */
+
+
+#define S3C_FB_HRES_VIRTUAL     S3C_FB_HRES     /* Horizon pixel Resolition */
+#define S3C_FB_VRES_VIRTUAL     (S3C_FB_VRES * 2) 	/* Vertial pixel Resolution */
+
+#define S3C_FB_HRES_OSD			320		/* Horizon pixel Resolition */
+#define S3C_FB_VRES_OSD			480 	/* Vertial pixel Resolution */
+
+#define S3C_FB_HRES_OSD_VIRTUAL S3C_FB_HRES_OSD     /* Horizon pixel Resolition */
+#define S3C_FB_VRES_OSD_VIRTUAL (S3C_FB_VRES_OSD * 2) 	/* Vertial pixel Resolution */
+
+#define S3C_FB_VFRAME_FREQ      60      /* Frame Rate Frequency */
+
+#define S3C_FB_PIXEL_CLOCK      (S3C_FB_VFRAME_FREQ * \
+                                (S3C_FB_HFP + S3C_FB_HSW + S3C_FB_HBP + S3C_FB_HRES) * \
+                                (S3C_FB_VFP + S3C_FB_VSW + S3C_FB_VBP + S3C_FB_VRES))
+
+static void s3cfb_set_fimd_info(void)
+{
+	s3c_fimd.vidcon1    = S3C_VIDCON1_IVCLK_RISE_EDGE | 
+						  S3C_VIDCON1_IHSYNC_INVERT |
+	                      S3C_VIDCON1_IVSYNC_INVERT |
+	                      S3C_VIDCON1_IVDEN_NORMAL;
+
+	s3c_fimd.vidtcon0   = S3C_VIDTCON0_VBPD(S3C_FB_VBP - 1) |
+	                      S3C_VIDTCON0_VFPD(S3C_FB_VFP - 1) |
+	                      S3C_VIDTCON0_VSPW(S3C_FB_VSW - 1);
+	s3c_fimd.vidtcon1   = S3C_VIDTCON1_HBPD(S3C_FB_HBP - 1) |
+	                      S3C_VIDTCON1_HFPD(S3C_FB_HFP - 1) |
+	                      S3C_VIDTCON1_HSPW(S3C_FB_HSW - 1);
+	s3c_fimd.vidtcon2   = S3C_VIDTCON2_LINEVAL(S3C_FB_VRES - 1) |
+	                      S3C_VIDTCON2_HOZVAL(S3C_FB_HRES - 1);
+
+	s3c_fimd.vidosd0a   = S3C_VIDOSDxA_OSD_LTX_F(0) |
+	                      S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3c_fimd.vidosd0b   = S3C_VIDOSDxB_OSD_RBX_F(S3C_FB_HRES - 1) |
+	                      S3C_VIDOSDxB_OSD_RBY_F(S3C_FB_VRES - 1);
+
+	s3c_fimd.vidosd1a   = S3C_VIDOSDxA_OSD_LTX_F(0) |
+	                      S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3c_fimd.vidosd1b   = S3C_VIDOSDxB_OSD_RBX_F(S3C_FB_HRES_OSD - 1) |
+	                      S3C_VIDOSDxB_OSD_RBY_F(S3C_FB_VRES_OSD - 1);
+
+	s3c_fimd.width		= 45;
+	s3c_fimd.height 	= 68;
+	s3c_fimd.xres 		= S3C_FB_HRES;
+	s3c_fimd.yres 		= S3C_FB_VRES;
+
+#if defined(CONFIG_FB_S3C_VIRTUAL_SCREEN)
+	s3c_fimd.xres_virtual = S3C_FB_HRES_VIRTUAL;
+	s3c_fimd.yres_virtual = S3C_FB_VRES_VIRTUAL;
+#else
+	s3c_fimd.xres_virtual = S3C_FB_HRES;
+	s3c_fimd.yres_virtual = S3C_FB_VRES;
+#endif
+
+	s3c_fimd.osd_width 	= S3C_FB_HRES_OSD;
+	s3c_fimd.osd_height = S3C_FB_VRES_OSD;
+	s3c_fimd.osd_xres 	= S3C_FB_HRES_OSD;
+	s3c_fimd.osd_yres 	= S3C_FB_VRES_OSD;
+
+#if defined(CONFIG_FB_S3C_VIRTUAL_SCREEN)
+	s3c_fimd.osd_xres_virtual = S3C_FB_HRES_OSD_VIRTUAL;
+	s3c_fimd.osd_yres_virtual = S3C_FB_VRES_OSD_VIRTUAL;
+#else
+	s3c_fimd.osd_xres_virtual = S3C_FB_HRES_OSD;
+	s3c_fimd.osd_yres_virtual = S3C_FB_VRES_OSD;
+#endif
+
+	s3c_fimd.pixclock		= S3C_FB_PIXEL_CLOCK;
+
+	s3c_fimd.hsync_len 		= S3C_FB_HSW;
+	s3c_fimd.vsync_len 		= S3C_FB_VSW;
+	s3c_fimd.left_margin 	= S3C_FB_HFP;
+	s3c_fimd.upper_margin 	= S3C_FB_VFP;
+	s3c_fimd.right_margin 	= S3C_FB_HBP;
+	s3c_fimd.lower_margin 	= S3C_FB_VBP;
+
+	s3c_fimd.set_lcd_power		 = lcd_power_ctrl;
+	s3c_fimd.set_backlight_power = backlight_power_ctrl;
+	s3c_fimd.set_brightness 	 = backlight_level_ctrl;
+
+	s3c_fimd.backlight_min = BACKLIGHT_LEVEL_MIN;
+	s3c_fimd.backlight_max = BACKLIGHT_LEVEL_MAX;
+}
+
+static void lcd_gpio_init(void)
+{
+	/* B(0:5) */
+	s3c_gpio_cfgpin(GPIO_LCD_B_0, S3C_GPIO_SFN(GPIO_LCD_B_0_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_B_1, S3C_GPIO_SFN(GPIO_LCD_B_1_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_B_2, S3C_GPIO_SFN(GPIO_LCD_B_2_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_B_3, S3C_GPIO_SFN(GPIO_LCD_B_3_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_B_4, S3C_GPIO_SFN(GPIO_LCD_B_4_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_B_5, S3C_GPIO_SFN(GPIO_LCD_B_5_AF));
+	/* G(0:5) */
+	s3c_gpio_cfgpin(GPIO_LCD_G_0, S3C_GPIO_SFN(GPIO_LCD_G_0_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_G_1, S3C_GPIO_SFN(GPIO_LCD_G_1_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_G_2, S3C_GPIO_SFN(GPIO_LCD_G_2_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_G_3, S3C_GPIO_SFN(GPIO_LCD_G_3_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_G_4, S3C_GPIO_SFN(GPIO_LCD_G_4_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_G_5, S3C_GPIO_SFN(GPIO_LCD_G_5_AF));
+	/* R(0:5) */
+	s3c_gpio_cfgpin(GPIO_LCD_R_0, S3C_GPIO_SFN(GPIO_LCD_R_0_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_R_1, S3C_GPIO_SFN(GPIO_LCD_R_1_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_R_2, S3C_GPIO_SFN(GPIO_LCD_R_2_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_R_3, S3C_GPIO_SFN(GPIO_LCD_R_3_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_R_4, S3C_GPIO_SFN(GPIO_LCD_R_4_AF));
+	s3c_gpio_cfgpin(GPIO_LCD_R_5, S3C_GPIO_SFN(GPIO_LCD_R_5_AF));
+	/* HSYNC */
+	s3c_gpio_cfgpin(GPIO_LCD_HSYNC, S3C_GPIO_SFN(GPIO_LCD_HSYNC_AF));
+	/* VSYNC */
+	s3c_gpio_cfgpin(GPIO_LCD_VSYNC, S3C_GPIO_SFN(GPIO_LCD_VSYNC_AF));
+	/* DE */
+	s3c_gpio_cfgpin(GPIO_LCD_DE, S3C_GPIO_SFN(GPIO_LCD_DE_AF));
+	/* CLK */
+	s3c_gpio_cfgpin(GPIO_LCD_CLK, S3C_GPIO_SFN(GPIO_LCD_CLK_AF));
+	
+	/* LCD_RST_N */
+	if (gpio_is_valid(GPIO_LCD_RST_N)) {
+		if (gpio_request(GPIO_LCD_RST_N, S3C_GPIO_LAVEL(GPIO_LCD_RST_N))) 
+			printk(KERN_ERR "Failed to request GPIO_LCD_RST_N!\n");
+		gpio_direction_output(GPIO_LCD_RST_N, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_LCD_RST_N, S3C_GPIO_PULL_NONE);
+	/* LCD_ID */
+	if (gpio_is_valid(GPIO_LCD_ID)) {
+		if (gpio_request(GPIO_LCD_ID, S3C_GPIO_LAVEL(GPIO_LCD_ID))) 
+			printk(KERN_ERR "Failed to request GPIO_LCD_ID!\n");
+		gpio_direction_input(GPIO_LCD_ID);
+	}
+	s3c_gpio_setpull(GPIO_LCD_ID, S3C_GPIO_PULL_NONE);
+
+	/* LCD_SCLK */
+	if (gpio_is_valid(GPIO_LCD_SCLK)) {
+		if (gpio_request(GPIO_LCD_SCLK, S3C_GPIO_LAVEL(GPIO_LCD_SCLK))) 
+			printk(KERN_ERR "Failed to request GPIO_LCD_SCLK!\n");
+		gpio_direction_output(GPIO_LCD_SCLK, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_LCD_SCLK, S3C_GPIO_PULL_NONE);
+	/* LCD_CS_N */
+	if (gpio_is_valid(GPIO_LCD_CS_N)) {
+		if (gpio_request(GPIO_LCD_CS_N, S3C_GPIO_LAVEL(GPIO_LCD_CS_N))) 
+			printk(KERN_ERR "Failed to request GPIO_LCD_CS_N!\n");
+		gpio_direction_output(GPIO_LCD_CS_N, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_LCD_CS_N, S3C_GPIO_PULL_NONE);
+	/* LCD_SDI */
+	if (gpio_is_valid(GPIO_LCD_SDI)) {
+		if (gpio_request(GPIO_LCD_SDI, S3C_GPIO_LAVEL(GPIO_LCD_SDI))) 
+			printk(KERN_ERR "Failed to request GPIO_LCD_SDI!\n");
+		gpio_direction_output(GPIO_LCD_SDI, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_LCD_SDI, S3C_GPIO_PULL_NONE);
+}
+
+static void backlight_gpio_init(void)
+{
+}
+
+/*
+ * Serial Interface
+ */
+
+#define LCD_CSX_HIGH	gpio_set_value(GPIO_LCD_CS_N, GPIO_LEVEL_HIGH);
+#define LCD_CSX_LOW		gpio_set_value(GPIO_LCD_CS_N, GPIO_LEVEL_LOW);
+
+#define LCD_SCL_HIGH	gpio_set_value(GPIO_LCD_SCLK, GPIO_LEVEL_HIGH);
+#define LCD_SCL_LOW		gpio_set_value(GPIO_LCD_SCLK, GPIO_LEVEL_LOW);
+
+#define LCD_SDI_HIGH	gpio_set_value(GPIO_LCD_SDI, GPIO_LEVEL_HIGH);
+#define LCD_SDI_LOW		gpio_set_value(GPIO_LCD_SDI, GPIO_LEVEL_LOW);
+
+
+
+#define DEFAULT_USLEEP	5	
+
+#define PWRCTL			0xF3
+#define SLPIN			0x10
+#define SLPOUT			0x11
+#define DISCTL			0xF2
+#define VCMCTL			0xF4
+#define SRCCTL			0xF5
+#define GATECTL			0xFD
+#define MADCTL			0x36
+#define COLMOD			0x3A
+#define GAMCTL1			0xF7
+#define GAMCTL2			0xF8
+#define GAMCTL3			0xF9
+#define GAMCTL4			0xFA
+#define GAMCTL5			0xFB
+#define GAMCTL6			0xFC
+#define BCMODE			0xCB
+#define WRCABC			0x55
+#define DCON			0xEF
+#define WRCTRLD			0x53
+#define WRDISBV         0x51
+#define WRCABCMB		0x5E
+#define MIECTL1			0xCA
+#define MIECTL2			0xCC
+#define MIECTL3			0xCD
+
+
+
+
+
+struct setting_table {
+	u8 command;	
+	u8 parameters;
+	u8 parameter[15];
+	s32 wait;
+};
+
+static struct setting_table power_on_setting_table[] = {
+	{ PWRCTL,  9,  { 0x00, 0x00, 0x2A, 0x00, 0x00, 0x33, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
+	{ SLPOUT,  0,  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  15 },
+	
+	{ DISCTL,  11, { 0x16, 0x16, 0x0F, 0x0A, 0x05, 0x0A, 0x05, 0x10, 0x00, 0x16, 0x16, 0x00, 0x00, 0x00, 0x00 },   0 },
+	{ PWRCTL,  9,  { 0x00, 0x01, 0x2A, 0x00, 0x00, 0x33, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
+	{ VCMCTL,  5,  { 0x1A, 0x1A, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
+	{ SRCCTL,  6,  { 0x00, 0x00, 0x0A, 0x01, 0x01, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
+	{ GATECTL, 3,  { 0x44, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  15 },
+	
+	{ PWRCTL,  9,  { 0x00, 0x03, 0x2A, 0x00, 0x00, 0x33, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  15 },
+	{ PWRCTL,  9,  { 0x00, 0x07, 0x2A, 0x00, 0x00, 0x33, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  15 },
+	{ PWRCTL,  9,  { 0x00, 0x0F, 0x2A, 0x00, 0x02, 0x33, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  15 },
+	{ PWRCTL,  9,  { 0x00, 0x1F, 0x2A, 0x00, 0x02, 0x33, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  15 },
+	{ PWRCTL,  9,  { 0x00, 0x3F, 0x2A, 0x00, 0x08, 0x33, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  25 },
+	{ PWRCTL,  9,  { 0x00, 0x7F, 0x2A, 0x00, 0x08, 0x33, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  35 },
+	
+	{ MADCTL,  1,  { 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
+	{ COLMOD,  1,  { 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
+	{ GAMCTL1, 15, { 0x00, 0x00, 0x00, 0x14, 0x27, 0x2D, 0x2C, 0x2D, 0x10, 0x11, 0x10, 0x16, 0x04, 0x22, 0x22 },   0 },
+	{ GAMCTL2, 15, { 0x00, 0x00, 0x00, 0x14, 0x27, 0x2D, 0x2C, 0x2D, 0x10, 0x11, 0x10, 0x16, 0x04, 0x22, 0x22 },   0 },
+	{ GAMCTL3, 15, { 0x96, 0x00, 0x00, 0x00, 0x00, 0x15, 0x1E, 0x23, 0x16, 0x0D, 0x07, 0x10, 0x00, 0x81, 0x42 },   0 },
+	{ GAMCTL4, 15, { 0x80, 0x16, 0x00, 0x00, 0x00, 0x15, 0x1E, 0x23, 0x16, 0x0D, 0x07, 0x10, 0x00, 0x81, 0x42 },   0 },
+	{ GAMCTL5, 15, { 0x00, 0x00, 0x34, 0x30, 0x2F, 0x2F, 0x2E, 0x2F, 0x0E, 0x0D, 0x09, 0x0E, 0x00, 0x22, 0x12 },   0 },
+	{ GAMCTL6, 15, { 0x00, 0x00, 0x34, 0x30, 0x2F, 0x2F, 0x2E, 0x2F, 0x0E, 0x0D, 0x09, 0x0E, 0x00, 0x22, 0x12 },   0 },
+	{ BCMODE,  1,  { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
+	{ MIECTL3, 2,  { 0x7C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
+	{ WRDISBV, 1,  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
+//	{ MIECTL1, 3,  { 0x80, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
+//	{ MIECTL2, 3,  { 0x20, 0x01, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
+//	{ WRCABC,  1,  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
+	{ DCON,    1,  { 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  40 },
+	
+	{ DCON,    1,  { 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
+	{ WRCTRLD, 1,  { 0x2C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
+};
+
+
+#define POWER_ON_SETTINGS	(int)(sizeof(power_on_setting_table)/sizeof(struct setting_table))
+
+static struct setting_table power_off_setting_table[] = {
+	{    DCON,  1, { 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  40 },
+	{    DCON,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  25 },
+	{  PWRCTL,  9, { 0x00, 0x00, 0x2A, 0x00, 0x00, 0x33, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
+	{   SLPIN,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 200 },
+};
+
+#define POWER_OFF_SETTINGS	(int)(sizeof(power_off_setting_table)/sizeof(struct setting_table))
+
+#if 0
+static struct setting_table cabc_on_setting_table[] = 
+	{  WRCABC,  1, { 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 };
+
+static struct setting_table cabc_off_setting_table[] = 
+	{  WRCABC,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 };
+#endif
+static struct setting_table backlight_setting_table = 
+	{ WRDISBV,  1, { 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 };
+
+static void setting_table_write(struct setting_table *table)
+{
+	s32 i, j;
+
+		LCD_CSX_HIGH
+		udelay(DEFAULT_USLEEP);
+		LCD_SCL_HIGH 
+		udelay(DEFAULT_USLEEP);
+	
+		/* Write Command */
+		LCD_CSX_LOW
+		udelay(DEFAULT_USLEEP);
+		
+		LCD_SCL_LOW 
+		udelay(DEFAULT_USLEEP); 	
+		LCD_SDI_LOW 
+		udelay(DEFAULT_USLEEP);
+		LCD_SCL_HIGH 
+		udelay(DEFAULT_USLEEP); 
+	
+		for (i = 7; i >= 0; i--) { 
+			LCD_SCL_LOW
+			udelay(DEFAULT_USLEEP);
+			if ((table->command >> i) & 0x1)
+				LCD_SDI_HIGH
+			else
+				LCD_SDI_LOW
+			udelay(DEFAULT_USLEEP); 
+			LCD_SCL_HIGH
+			udelay(DEFAULT_USLEEP); 
+		}
+	
+		LCD_CSX_HIGH
+		udelay(DEFAULT_USLEEP); 
+	
+		/* Write Parameter */
+		if ((table->parameters) > 0) {
+			for (j = 0; j < table->parameters; j++) {
+				LCD_CSX_LOW 
+				udelay(DEFAULT_USLEEP); 	
+			
+				LCD_SCL_LOW 
+				udelay(DEFAULT_USLEEP); 	
+				LCD_SDI_HIGH 
+				udelay(DEFAULT_USLEEP);
+				LCD_SCL_HIGH 
+				udelay(DEFAULT_USLEEP); 	
+	
+				for (i = 7; i >= 0; i--) { 
+					LCD_SCL_LOW
+					udelay(DEFAULT_USLEEP); 
+					if ((table->parameter[j] >> i) & 0x1)
+						LCD_SDI_HIGH
+					else
+						LCD_SDI_LOW
+					udelay(DEFAULT_USLEEP); 
+					LCD_SCL_HIGH
+					udelay(DEFAULT_USLEEP); 				
+				}
+			
+				LCD_CSX_HIGH 
+				udelay(DEFAULT_USLEEP); 	
+			}
+		}
+		msleep(table->wait);
+}
+
+/*
+ *	LCD Power Handler
+ */
+
+#define MAX8698_ID		0xCC
+
+#define ONOFF2			0x01
+
+#define ONOFF2_ELDO6	(0x01 << 7)
+#define ONOFF2_ELDO7	(0x03 << 6)
+
+void lcd_power_ctrl(s32 value)
+{
+	s32 i;	
+	u8 data;
+
+	// To prevent from another request while working.
+	if(lcd_power > ON)
+		{
+		printk("LCD POWER CONTROL called with (%d) while working\n", value);
+		return;
+		}
+	lcd_power = ON + 1;
+	
+	printk("#%s:%d s\n",__func__,value);
+
+	if (value) {
+	
+		/* Power On Sequence */
+	
+		/* Power Enable */
+		// Turn on VLCD1.8V first
+		if(pmic_read(MAX8698_ID, ONOFF2, &data, 1) != PMIC_PASS)
+			{
+			printk("LCD POWER CONTROL can't read the status from PMIC to turn on 1.8V\n");
+			}
+		
+		data |= ONOFF2_ELDO6;		// TURN ON VLCD_1.8V
+		if(pmic_write(MAX8698_ID, ONOFF2, &data, 1) != PMIC_PASS)
+			{
+			printk("LCD POWER CONTROL can't write the command to PMIC to turn on 1.8V\n");
+			}
+
+		// wait 0s < t1 < 1ms
+		udelay(10);
+
+		// Turn on VLCD3.0V
+		if(pmic_read(MAX8698_ID, ONOFF2, &data, 1) != PMIC_PASS)
+			{
+			printk("LCD POWER CONTROL can't read the status from PMIC to turn on 3.0V\n");
+			}
+		
+		data |= ONOFF2_ELDO7;		// TURN ON VLCD_3.0V
+		if(pmic_write(MAX8698_ID, ONOFF2, &data, 1) != PMIC_PASS)
+			{
+			printk("LCD POWER CONTROL can't write the command to PMIC to turn on 3.0V\n");
+			}
+
+		// wait longer than 1ms
+		msleep(2);
+		
+		/* Reset Asseert */
+		gpio_set_value(GPIO_LCD_RST_N, GPIO_LEVEL_HIGH);
+		msleep(1);	
+		
+		gpio_set_value(GPIO_LCD_RST_N, GPIO_LEVEL_LOW);
+		msleep(1);		// hold low level longer than 10us
+
+		/* Reset Deasseert */
+		gpio_set_value(GPIO_LCD_RST_N, GPIO_LEVEL_HIGH);
+
+		msleep(10);		// wait longer than 10ms before writing setting table
+
+		for (i = 0; i < POWER_ON_SETTINGS; i++)
+			setting_table_write(&power_on_setting_table[i]);	
+	}
+	else {
+
+		/* Power Off Sequence */
+		for (i = 0; i < POWER_OFF_SETTINGS; i++)
+			setting_table_write(&power_off_setting_table[i]);	
+
+		/* Reset Assert */
+		gpio_set_value(GPIO_LCD_RST_N, GPIO_LEVEL_LOW);
+
+		// Turn off VLCD3.0V first
+		if(pmic_read(MAX8698_ID, ONOFF2, &data, 1) != PMIC_PASS)
+			{
+			printk("LCD POWER CONTROL can't read the status from PMIC to turn off 3.0V\n");
+			}
+		
+		data &= ~ONOFF2_ELDO7;
+		
+		if(pmic_write(MAX8698_ID, ONOFF2, &data, 1) != PMIC_PASS)
+			{
+			printk("LCD POWER CONTROL can't write the command to PMIC to turn off 3.0V\n");
+			}
+
+		/* Power Disable */
+		// Turn off VLCD1.8V next
+		if(pmic_read(MAX8698_ID, ONOFF2, &data, 1) != PMIC_PASS)
+			{
+			printk("LCD POWER CONTROL can't read the status from PMIC to turn off 1.8V\n");
+			}
+		
+		data &= ~ONOFF2_ELDO6;
+		
+		if(pmic_write(MAX8698_ID, ONOFF2, &data, 1) != PMIC_PASS)
+			{
+			printk("LCD POWER CONTROL can't write the command to PMIC to turn off 1.8V\n");
+			}
+
+		// While sleep in state, VDDI couldn't drop to 1.8V because it was affected by CSX and SCL,
+		// so we need to make low them.
+		LCD_CSX_LOW
+		LCD_SCL_LOW
+		
+	}
+
+	lcd_power = value;
+	
+	printk("#%s:%d e\n",__func__,value);
+}
+
+void backlight_ctrl(s32 value)
+{
+	if (value) {
+		/* Backlight On Sequence */
+		
+		if (lcd_power == OFF) {
+			if(!s3cfb_is_clock_on()) {
+				s3cfb_enable_clock_power();
+			}
+			lcd_power_ctrl(ON);
+		}
+
+		backlight_setting_table.parameter[0] = (value & BACKLIGHT_LEVEL_VALUE);
+		
+//		printk("LCD Backlight level setting value ==> %d \n",value);
+		
+		setting_table_write(&backlight_setting_table);	
+	}
+	else {
+		/* Backlight Off Sequence */
+
+		lcd_power_ctrl(OFF);	
+	}
+
+}
+
+void backlight_level_ctrl(s32 value)
+{
+	if ((value < BACKLIGHT_LEVEL_MIN) ||	/* Invalid Value */
+		(value > BACKLIGHT_LEVEL_MAX) ||
+		(value == backlight_level))	/* Same Value */
+		return;
+
+	if (backlight_power)
+		backlight_ctrl(value);	
+	
+	backlight_level = value;	
+}
+
+void backlight_power_ctrl(s32 value)
+{
+	if ((value < OFF) ||	/* Invalid Value */
+		(value > ON))
+		return;
+
+	backlight_ctrl((value ? backlight_level : OFF));	
+	
+	backlight_power = (value ? ON : OFF);
+}
+
+#define S6D05A_DEFAULT_BACKLIGHT_BRIGHTNESS	255
+
+static s32 s6d05a_backlight_off;
+static s32 s6d05a_backlight_brightness = S6D05A_DEFAULT_BACKLIGHT_BRIGHTNESS;
+static u8 s6d05a_backlight_last_level = 33;
+static DEFINE_MUTEX(s6d05a_backlight_lock);
+
+static void s6d05a_set_backlight_level(u8 level)
+{
+	if (backlight_level == level)
+		return;
+
+	backlight_ctrl(level);	
+	
+	backlight_level = level;
+}
+
+static void s6d05a_brightness_set(struct led_classdev *led_cdev, enum led_brightness value)
+{
+	mutex_lock(&s6d05a_backlight_lock);
+	s6d05a_backlight_brightness = value;
+	s6d05a_set_backlight_level(s6d05a_backlight_brightness);
+	mutex_unlock(&s6d05a_backlight_lock);
+}
+
+static struct led_classdev s6d05a_backlight_led  = {
+	.name		= "lcd-backlight",
+	.brightness = S6D05A_DEFAULT_BACKLIGHT_BRIGHTNESS,
+	.brightness_set = s6d05a_brightness_set,
+};
+
+static int s6d05a_backlight_probe(struct platform_device *pdev)
+{
+	led_classdev_register(&pdev->dev, &s6d05a_backlight_led);
+	return 0;
+}
+
+static int s6d05a_backlight_remove(struct platform_device *pdev)
+{
+	led_classdev_unregister(&s6d05a_backlight_led);
+	return 0;
+}
+
+static struct platform_driver s6d05a_backlight_driver = {
+	.probe		= s6d05a_backlight_probe,
+	.remove		= s6d05a_backlight_remove,
+	.driver		= {
+		.name		= "s6d05a-backlight",
+		.owner		= THIS_MODULE,
+	},
+};
+
+static int __init s6d05a_backlight_init(void)
+{
+	return platform_driver_register(&s6d05a_backlight_driver);
+}
+
+static void __exit s6d05a_backlight_exit(void)
+{
+	platform_driver_unregister(&s6d05a_backlight_driver);
+}
+module_init(s6d05a_backlight_init);
+module_exit(s6d05a_backlight_exit);
+
+void s3cfb_init_hw(void)
+{
+	s3cfb_set_fimd_info();
+
+	s3cfb_set_gpio();
+#ifdef CONFIG_FB_S3C_LCD_INIT	
+	lcd_gpio_init();
+	
+	backlight_gpio_init();
+
+	lcd_power_ctrl(ON);
+
+	backlight_level_ctrl(BACKLIGHT_LEVEL_DEFAULT);
+
+	backlight_power_ctrl(ON); 
+#else
+	lcd_gpio_init();
+	
+	backlight_gpio_init();
+	
+	lcd_power = ON;
+
+//	backlight_level = BACKLIGHT_LEVEL_DEFAULT;
+	backlight_level = -1;	// GA_KSS : If we use pre-defined value for backlight level, user can see darker screen just after power on when backlight leve was set as maximum.
+	backlight_power = ON;
+#endif
+}
+
+#define LOGO_MEM_BASE		(0x50000000 + 0x0D000000 - 0x100000)	/* SDRAM_BASE + SRAM_SIZE(208MB) - 1MB */
+#define LOGO_MEM_SIZE		(S3C_FB_HRES * S3C_FB_VRES * 2)
+
+void s3cfb_display_logo(int win_num)
+{
+	s3c_fb_info_t *fbi = &s3c_fb_info[0];
+	u8 *logo_virt_buf;
+	
+	logo_virt_buf = ioremap_nocache(LOGO_MEM_BASE, LOGO_MEM_SIZE);
+
+	memcpy(fbi->map_cpu_f1, logo_virt_buf, LOGO_MEM_SIZE);	
+
+	iounmap(logo_virt_buf);
+}
+
+#include "s3cfb_progress_hvga.h"
+
+static int progress = 0;
+
+static int progress_flag = OFF;
+
+static struct timer_list progress_timer;
+
+static void progress_timer_handler(unsigned long data)
+{
+	s3c_fb_info_t *fbi = &s3c_fb_info[1];
+	unsigned short *bar_src, *bar_dst;	
+	int	i, j, p;
+
+	/* 1 * 12 R5G5B5 BMP (Aligned 4 Bytes) */
+	bar_dst = (unsigned short *)(fbi->map_cpu_f1 + (((320 * 416) + 41) * 2));
+	bar_src = (unsigned short *)(progress_bar + sizeof(progress_bar) - 4);
+
+	for (i = 0; i < 12; i++) {
+		for (j = 0; j < 2; j++) {
+			p = ((320 * i) + (progress * 2) + j);
+			*(bar_dst + p) = (*(bar_src - (i * 2)) | 0x8000);
+		}
+	}	
+
+	progress++;
+
+	if (progress > 118) {
+		del_timer(&progress_timer);
+	}
+	else {
+		progress_timer.expires = (get_jiffies_64() + (HZ/15)); 
+		progress_timer.function = progress_timer_handler; 
+		add_timer(&progress_timer);
+	}
+}
+
+static unsigned int new_wincon1; 
+static unsigned int old_wincon1; 
+
+void s3cfb_start_progress(void)
+{
+	s3c_fb_info_t *fbi = &s3c_fb_info[1];
+	unsigned short *bg_src, *bg_dst;	
+	int	i, j, p;
+	
+	memset(fbi->map_cpu_f1, 0x00, LOGO_MEM_SIZE);	
+
+	/* 320 * 25 R5G5B5 BMP */
+	bg_dst = (unsigned short *)(fbi->map_cpu_f1 + ((320 * 410) * 2));
+	bg_src = (unsigned short *)(progress_bg + sizeof(progress_bg) - 2);
+
+	for (i = 0; i < 25; i++) {
+		for (j = 0; j < 320; j++) {
+			p = ((320 * i) + j);
+			if ((*(bg_src - p) & 0x7FFF) == 0x0000)
+				*(bg_dst + p) = (*(bg_src - p) & ~0x8000);
+			else
+				*(bg_dst + p) = (*(bg_src - p) | 0x8000);
+		}
+	}	
+
+	old_wincon1 = readl(S3C_WINCON1);
+
+	new_wincon1 = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_BUFSEL_0 | S3C_WINCONx_BUFAUTOEN_DISABLE | \
+	           S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+	           S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_BPPMODE_F_16BPP_A555 | \
+	           S3C_WINCONx_ALPHA_SEL_0 | S3C_WINCONx_ENWIN_F_ENABLE,
+
+	writel(new_wincon1, S3C_WINCON1);
+
+	init_timer(&progress_timer);
+	progress_timer.expires = (get_jiffies_64() + (HZ/10)); 
+	progress_timer.function = progress_timer_handler; 
+	add_timer(&progress_timer);
+
+	progress_flag = ON;
+}
+
+void s3cfb_stop_progress(void)
+{
+	if (progress_flag == OFF)
+		return;
+
+	del_timer(&progress_timer);
+#ifdef CONFIG_FB_S3C_BPP_24
+	writel(s3c_fimd.wincon0,    S3C_WINCON0);
+  	s3cfb_onoff_win(&s3c_fb_info[0], ON);
+#endif
+	writel(old_wincon1, S3C_WINCON1);
+	
+	progress_flag = OFF;
+}
diff -Nur linux-2.6.29/drivers/video/samsung/s3cfb_spi.c linux-2.6.29-spica/drivers/video/samsung/s3cfb_spi.c
--- linux-2.6.29/drivers/video/samsung/s3cfb_spi.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/video/samsung/s3cfb_spi.c	2010-05-06 12:42:45.674299703 +0700
@@ -0,0 +1,174 @@
+/*
+ * drivers/video/s3c/s3c24xxfb_spi.c
+ *
+ * $Id: s3cfb_spi.c,v 1.1 2008/11/17 11:12:08 jsgood Exp $
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#include <linux/delay.h>
+
+#include <asm/mach/map.h>
+#include <asm/gpio.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-clock.h>
+#include <plat/regs-lcd.h>
+
+#if 0 //defined(CONFIG_PLAT_S3C24XX)
+
+#define S3C_FB_SPI_CLK(x)	(S3C2443_GPL10 + (ch * 0))
+#define S3C_FB_SPI_MOSI(x)	(S3C2443_GPL11 + (ch * 0))
+#define S3C_FB_SPI_CS(x)	(S3C2443_GPL14 + (ch * 0))
+
+static inline void s3cfb_spi_lcd_dclk(int ch, int value)
+{
+	s3c2410_gpio_setpin(S3C_FB_SPI_CLK(ch), value);
+}
+
+static inline void s3cfb_spi_lcd_dseri(int ch, int value)
+{
+	s3c2410_gpio_setpin(S3C_FB_SPI_MOSI(ch), value);
+}
+
+static inline void s3cfb_spi_lcd_den(int ch, int value)
+{
+	s3c2410_gpio_setpin(S3C_FB_SPI_CS(ch), value);
+}
+
+static inline void s3cfb_spi_set_lcd_data(int ch)
+{
+	s3c2410_gpio_cfgpin(S3C_FB_SPI_CLK(ch), 1);
+	s3c2410_gpio_cfgpin(S3C_FB_SPI_MOSI(ch), 1);
+	s3c2410_gpio_cfgpin(S3C_FB_SPI_CS(ch), 1);
+
+	s3c2410_gpio_pullup(S3C_FB_SPI_CLK(ch), 2);
+	s3c2410_gpio_pullup(S3C_FB_SPI_MOSI(ch), 2);
+	s3c2410_gpio_pullup(S3C_FB_SPI_CS(ch), 2);
+}
+
+#elif defined(CONFIG_PLAT_S3C64XX)
+
+#define S3C_FB_SPI_CLK(x)	(S3C64XX_GPC(1 + (ch * 4)))
+#define S3C_FB_SPI_MOSI(x)	(S3C64XX_GPC(2 + (ch * 4)))
+#define S3C_FB_SPI_CS(x)	(S3C64XX_GPC(3 + (ch * 4)))
+
+int s3cfb_spi_gpio_request(int ch)
+{
+	int err = 0;
+
+	if (gpio_is_valid(S3C_FB_SPI_CLK(ch))) {
+		err = gpio_request(S3C_FB_SPI_CLK(ch), "GPC");
+
+		if (err)
+			goto err_clk;
+	} else {
+		err = 1;
+		goto err_clk;
+	}
+
+	if (gpio_is_valid(S3C_FB_SPI_MOSI(ch))) {
+		err = gpio_request(S3C_FB_SPI_MOSI(ch), "GPC");
+
+		if (err)
+			goto err_mosi;
+	} else {
+		err = 1;
+		goto err_mosi;
+	}
+
+	if (gpio_is_valid(S3C_FB_SPI_CS(ch))) {
+		err = gpio_request(S3C_FB_SPI_CS(ch), "GPC");
+
+		if (err)
+			goto err_cs;
+	} else {
+		err = 1;
+		goto err_cs;
+	}
+
+err_cs:
+	gpio_free(S3C_FB_SPI_MOSI(ch));
+
+err_mosi:
+	gpio_free(S3C_FB_SPI_CLK(ch));
+
+err_clk:
+	return err;
+	
+}
+
+inline void s3cfb_spi_lcd_dclk(int ch, int value)
+{
+	gpio_set_value(S3C_FB_SPI_CLK(ch), value);
+}
+
+inline void s3cfb_spi_lcd_dseri(int ch, int value)
+{
+	gpio_set_value(S3C_FB_SPI_MOSI(ch), value);
+}
+
+inline void s3cfb_spi_lcd_den(int ch, int value)
+{
+	gpio_set_value(S3C_FB_SPI_CS(ch), value);
+}
+
+inline void s3cfb_spi_set_lcd_data(int ch)
+{
+	gpio_direction_output(S3C_FB_SPI_CLK(ch), 1);
+	gpio_direction_output(S3C_FB_SPI_MOSI(ch), 1);
+	gpio_direction_output(S3C_FB_SPI_CS(ch), 1);
+
+	s3c_gpio_setpull(S3C_FB_SPI_CLK(ch), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(S3C_FB_SPI_MOSI(ch), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(S3C_FB_SPI_CS(ch), S3C_GPIO_PULL_NONE);
+}
+
+void s3cfb_spi_gpio_free(int ch)
+{
+	gpio_free(S3C_FB_SPI_CLK(ch));
+	gpio_free(S3C_FB_SPI_MOSI(ch));
+	gpio_free(S3C_FB_SPI_CS(ch));
+}
+
+#elif 0 //defined(CONFIG_PLAT_S5PC1XX)
+
+#define S5P_FB_SPI_MISO(x)	(S5P_GPB0 + (ch * 4))
+#define S5P_FB_SPI_CLK(x)	(S5P_GPB1 + (ch * 4))
+#define S5P_FB_SPI_MOSI(x)	(S5P_GPB2 + (ch * 4))
+#define S5P_FB_SPI_nSS(x)	(S5P_GPB3 + (ch * 4))
+
+inline void s3cfb_spi_lcd_dclk(int ch, int value)
+{
+	gpio_set_value(S5P_FB_SPI_CLK(ch), value);
+}
+
+inline void s3cfb_spi_lcd_dseri(int ch, int value)
+{
+	gpio_set_value(S5P_FB_SPI_MOSI(ch), value);
+}
+
+inline void s3cfb_spi_lcd_den(int ch, int value)
+{
+	gpio_set_value(S5P_FB_SPI_nSS(ch), value);
+}
+
+inline void s3cfb_spi_set_lcd_data(int ch)
+{
+	gpio_direction_output(S5P_FB_SPI_CLK(ch), 1);
+	gpio_direction_output(S5P_FB_SPI_MOSI(ch), 1);
+	gpio_direction_output(S5P_FB_SPI_nSS(ch), 1);
+
+	gpio_pullup(S5P_FB_SPI_CLK(ch), S5P_GPIO_PUD_DISABLE);
+	gpio_pullup(S5P_FB_SPI_MOSI(ch), S5P_GPIO_PUD_DISABLE);
+	gpio_pullup(S5P_FB_SPI_nSS(ch), S5P_GPIO_PUD_DISABLE);
+}
+
+#endif
+
diff -Nur linux-2.6.29/drivers/watchdog/Kconfig linux-2.6.29-spica/drivers/watchdog/Kconfig
--- linux-2.6.29/drivers/watchdog/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/drivers/watchdog/Kconfig	2010-05-06 12:42:45.644210217 +0700
@@ -138,11 +138,11 @@
 	  Watchdog timer embedded into KS8695 processor. This will reboot your
 	  system when the timeout is reached.
 
-config S3C2410_WATCHDOG
-	tristate "S3C2410 Watchdog"
-	depends on ARCH_S3C2410
+config S3C_WATCHDOG
+	tristate "S3C Watchdog"
+	depends on ARCH_S3C2410 || ARCH_S3C64XX
 	help
-	  Watchdog timer block in the Samsung S3C2410 chips. This will
+	  Watchdog timer block in the Samsung S3C chips. This will
 	  reboot the system when the timer expires with the watchdog
 	  enabled.
 
@@ -152,7 +152,7 @@
 	  unavailable.
 
 	  The driver can be built as a module by choosing M, and will
-	  be called s3c2410_wdt
+	  be called s3c_wdt
 
 config SA1100_WATCHDOG
 	tristate "SA1100/PXA2xx watchdog"
diff -Nur linux-2.6.29/drivers/watchdog/s3c_wdt.c linux-2.6.29-spica/drivers/watchdog/s3c_wdt.c
--- linux-2.6.29/drivers/watchdog/s3c_wdt.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/drivers/watchdog/s3c_wdt.c	2010-05-06 12:42:45.644210217 +0700
@@ -0,0 +1,551 @@
+/* linux/drivers/char/watchdog/s3c_wdt.c
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C Watchdog Timer Support
+ *
+ * Based on, softdog.c by Alan Cox,
+ *     (c) Copyright 1996 Alan Cox <alan@lxorguk.ukuu.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/types.h>
+#include <linux/timer.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+
+#include <mach/map.h>
+
+#undef S3C_VA_WATCHDOG
+#define S3C_VA_WATCHDOG (0)
+
+#include <plat/regs-watchdog.h>
+
+#define PFX "s3c-wdt: "
+
+#define CONFIG_S3C_WATCHDOG_ATBOOT		(0)
+#define CONFIG_S3C_WATCHDOG_DEFAULT_TIME	(15)
+
+static int nowayout	= WATCHDOG_NOWAYOUT;
+static int tmr_margin	= CONFIG_S3C_WATCHDOG_DEFAULT_TIME;
+static int tmr_atboot	= CONFIG_S3C_WATCHDOG_ATBOOT;
+static int soft_noboot;
+static int debug;
+
+module_param(tmr_margin,  int, 0);
+module_param(tmr_atboot,  int, 0);
+module_param(nowayout,    int, 0);
+module_param(soft_noboot, int, 0);
+module_param(debug,	  int, 0);
+
+MODULE_PARM_DESC(tmr_margin, "Watchdog tmr_margin in seconds. default="
+		__MODULE_STRING(CONFIG_S3C_WATCHDOG_DEFAULT_TIME) ")");
+MODULE_PARM_DESC(tmr_atboot,
+		"Watchdog is started at boot time if set to 1, default="
+			__MODULE_STRING(CONFIG_S3C_WATCHDOG_ATBOOT));
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default="
+			__MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+MODULE_PARM_DESC(soft_noboot, "Watchdog action, set to 1 to ignore reboots, 0 to reboot (default depends on ONLY_TESTING)");
+MODULE_PARM_DESC(debug, "Watchdog debug, set to >1 for debug, (default 0)");
+
+
+typedef enum close_state {
+	CLOSE_STATE_NOT,
+	CLOSE_STATE_ALLOW = 0x4021
+} close_state_t;
+
+static unsigned long open_lock;
+static struct device    *wdt_dev;	/* platform device attached to */
+static struct resource	*wdt_mem;
+static struct resource	*wdt_irq;
+static struct clk	*wdt_clock;
+static void __iomem	*wdt_base;
+static unsigned int	 wdt_count;
+static close_state_t	 allow_close;
+static DEFINE_SPINLOCK(wdt_lock);
+
+/* watchdog control routines */
+
+#define DBG(msg...) do { \
+	if (debug) \
+		printk(KERN_INFO msg); \
+	} while (0)
+
+/* functions */
+
+static void s3c_wdt_keepalive(void)
+{
+	spin_lock(&wdt_lock);
+	writel(wdt_count, wdt_base + S3C_WTCNT);
+	spin_unlock(&wdt_lock);
+}
+
+static void __s3c_wdt_stop(void)
+{
+	unsigned long wtcon;
+
+	wtcon = readl(wdt_base + S3C_WTCON);
+	wtcon &= ~(S3C_WTCON_ENABLE | S3C_WTCON_RSTEN);
+	writel(wtcon, wdt_base + S3C_WTCON);
+}
+
+static void s3c_wdt_stop(void)
+{
+	spin_lock(&wdt_lock);
+	__s3c_wdt_stop();
+	spin_unlock(&wdt_lock);
+}
+
+static void s3c_wdt_start(void)
+{
+	unsigned long wtcon;
+
+	spin_lock(&wdt_lock);
+
+	__s3c_wdt_stop();
+
+	wtcon = readl(wdt_base + S3C_WTCON);
+	wtcon |= S3C_WTCON_ENABLE | S3C_WTCON_DIV128;
+
+	if (soft_noboot) {
+		wtcon |= S3C_WTCON_INTEN;
+		wtcon &= ~S3C_WTCON_RSTEN;
+	} else {
+		wtcon &= ~S3C_WTCON_INTEN;
+		wtcon |= S3C_WTCON_RSTEN;
+	}
+
+	DBG("%s: wdt_count=0x%08x, wtcon=%08lx\n",
+	    __func__, wdt_count, wtcon);
+
+	writel(wdt_count, wdt_base + S3C_WTDAT);
+	writel(wdt_count, wdt_base + S3C_WTCNT);
+	writel(wtcon, wdt_base + S3C_WTCON);
+	spin_unlock(&wdt_lock);
+}
+
+static int s3c_wdt_set_heartbeat(int timeout)
+{
+	unsigned int freq = clk_get_rate(wdt_clock);
+	unsigned int count;
+	unsigned int divisor = 1;
+	unsigned long wtcon;
+
+	if (timeout < 1)
+		return -EINVAL;
+
+	freq /= 128;
+	count = timeout * freq;
+
+	DBG("%s: count=%d, timeout=%d, freq=%d\n",
+	    __func__, count, timeout, freq);
+
+	/* if the count is bigger than the watchdog register,
+	   then work out what we need to do (and if) we can
+	   actually make this value
+	*/
+
+	if (count >= 0x10000) {
+		for (divisor = 1; divisor <= 0x100; divisor++) {
+			if ((count / divisor) < 0x10000)
+				break;
+		}
+
+		if ((count / divisor) >= 0x10000) {
+			dev_err(wdt_dev, "timeout %d too big\n", timeout);
+			return -EINVAL;
+		}
+	}
+
+	tmr_margin = timeout;
+
+	DBG("%s: timeout=%d, divisor=%d, count=%d (%08x)\n",
+	    __func__, timeout, divisor, count, count/divisor);
+
+	count /= divisor;
+	wdt_count = count;
+
+	/* update the pre-scaler */
+	wtcon = readl(wdt_base + S3C_WTCON);
+	wtcon &= ~S3C_WTCON_PRESCALE_MASK;
+	wtcon |= S3C_WTCON_PRESCALE(divisor-1);
+
+	writel(count, wdt_base + S3C_WTDAT);
+	writel(wtcon, wdt_base + S3C_WTCON);
+
+	return 0;
+}
+
+/*
+ *	/dev/watchdog handling
+ */
+
+static int s3c_wdt_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(0, &open_lock))
+		return -EBUSY;
+
+	if (nowayout)
+		__module_get(THIS_MODULE);
+
+	allow_close = CLOSE_STATE_NOT;
+
+	/* start the timer */
+	s3c_wdt_start();
+	return nonseekable_open(inode, file);
+}
+
+static int s3c_wdt_release(struct inode *inode, struct file *file)
+{
+	/*
+	 *	Shut off the timer.
+	 * 	Lock it in if it's a module and we set nowayout
+	 */
+
+	if (allow_close == CLOSE_STATE_ALLOW)
+		s3c_wdt_stop();
+	else {
+		dev_err(wdt_dev, "Unexpected close, not stopping watchdog\n");
+		s3c_wdt_keepalive();
+	}
+	allow_close = CLOSE_STATE_NOT;
+	clear_bit(0, &open_lock);
+	return 0;
+}
+
+static ssize_t s3c_wdt_write(struct file *file, const char __user *data,
+				size_t len, loff_t *ppos)
+{
+	/*
+	 *	Refresh the timer.
+	 */
+	if (len) {
+		if (!nowayout) {
+			size_t i;
+
+			/* In case it was set long ago */
+			allow_close = CLOSE_STATE_NOT;
+
+			for (i = 0; i != len; i++) {
+				char c;
+
+				if (get_user(c, data + i))
+					return -EFAULT;
+				if (c == 'V')
+					allow_close = CLOSE_STATE_ALLOW;
+			}
+		}
+		s3c_wdt_keepalive();
+	}
+	return len;
+}
+
+#define OPTIONS WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE
+
+static const struct watchdog_info s3c_wdt_ident = {
+	.options          =     OPTIONS,
+	.firmware_version =	0,
+	.identity         =	"S3C Watchdog",
+};
+
+
+static long s3c_wdt_ioctl(struct file *file,	unsigned int cmd,
+							unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+	int new_margin;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		return copy_to_user(argp, &s3c_wdt_ident,
+			sizeof(s3c_wdt_ident)) ? -EFAULT : 0;
+	case WDIOC_GETSTATUS:
+	case WDIOC_GETBOOTSTATUS:
+		return put_user(0, p);
+	case WDIOC_KEEPALIVE:
+		s3c_wdt_keepalive();
+		return 0;
+	case WDIOC_SETTIMEOUT:
+		if (get_user(new_margin, p))
+			return -EFAULT;
+		if (s3c_wdt_set_heartbeat(new_margin))
+			return -EINVAL;
+		s3c_wdt_keepalive();
+		return put_user(tmr_margin, p);
+	case WDIOC_GETTIMEOUT:
+		return put_user(tmr_margin, p);
+	default:
+		return -ENOTTY;
+	}
+}
+
+/* kernel interface */
+
+static const struct file_operations s3c_wdt_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.write		= s3c_wdt_write,
+	.unlocked_ioctl	= s3c_wdt_ioctl,
+	.open		= s3c_wdt_open,
+	.release	= s3c_wdt_release,
+};
+
+static struct miscdevice s3c_wdt_miscdev = {
+	.minor		= WATCHDOG_MINOR,
+	.name		= "watchdog",
+	.fops		= &s3c_wdt_fops,
+};
+
+/* interrupt handler code */
+
+static irqreturn_t s3c_wdt_irq(int irqno, void *param)
+{
+	dev_info(wdt_dev, "watchdog timer expired (irq)\n");
+
+	s3c_wdt_keepalive();
+	return IRQ_HANDLED;
+}
+/* device interface */
+
+static int s3c_wdt_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct device *dev;
+	unsigned int wtcon;
+	int started = 0;
+	int ret;
+	int size;
+
+	DBG("%s: probe=%p\n", __func__, pdev);
+
+	dev = &pdev->dev;
+	wdt_dev = &pdev->dev;
+
+	/* get the memory region for the watchdog timer */
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(dev, "no memory resource specified\n");
+		return -ENOENT;
+	}
+
+	size = (res->end - res->start) + 1;
+	wdt_mem = request_mem_region(res->start, size, pdev->name);
+	if (wdt_mem == NULL) {
+		dev_err(dev, "failed to get memory region\n");
+		ret = -ENOENT;
+		goto err_req;
+	}
+
+	wdt_base = ioremap(res->start, size);
+	if (wdt_base == NULL) {
+		dev_err(dev, "failed to ioremap() region\n");
+		ret = -EINVAL;
+		goto err_req;
+	}
+
+	DBG("probe: mapped wdt_base=%p\n", wdt_base);
+
+	wdt_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (wdt_irq == NULL) {
+		dev_err(dev, "no irq resource specified\n");
+		ret = -ENOENT;
+		goto err_map;
+	}
+
+	ret = request_irq(wdt_irq->start, s3c_wdt_irq, 0, pdev->name, pdev);
+	if (ret != 0) {
+		dev_err(dev, "failed to install irq (%d)\n", ret);
+		goto err_map;
+	}
+
+	wdt_clock = clk_get(&pdev->dev, "watchdog");
+	if (IS_ERR(wdt_clock)) {
+		dev_err(dev, "failed to find watchdog clock source\n");
+		ret = PTR_ERR(wdt_clock);
+		goto err_irq;
+	}
+
+	clk_enable(wdt_clock);
+
+	/* see if we can actually set the requested timer margin, and if
+	 * not, try the default value */
+
+	if (s3c_wdt_set_heartbeat(tmr_margin)) {
+		started = s3c_wdt_set_heartbeat(
+					CONFIG_S3C_WATCHDOG_DEFAULT_TIME);
+
+		if (started == 0)
+			dev_info(dev,
+			   "tmr_margin value out of range, default %d used\n",
+			       CONFIG_S3C_WATCHDOG_DEFAULT_TIME);
+		else
+			dev_info(dev, "default timer value is out of range, cannot start\n");
+	}
+
+	ret = misc_register(&s3c_wdt_miscdev);
+	if (ret) {
+		dev_err(dev, "cannot register miscdev on minor=%d (%d)\n",
+			WATCHDOG_MINOR, ret);
+		goto err_clk;
+	}
+
+	if (tmr_atboot && started == 0) {
+		dev_info(dev, "starting watchdog timer\n");
+		s3c_wdt_start();
+	} else if (!tmr_atboot) {
+		/* if we're not enabling the watchdog, then ensure it is
+		 * disabled if it has been left running from the bootloader
+		 * or other source */
+
+		s3c_wdt_stop();
+	}
+
+	/* print out a statement of readiness */
+
+	wtcon = readl(wdt_base + S3C_WTCON);
+
+	dev_info(dev, "watchdog %sactive, reset %sabled, irq %sabled\n",
+		 (wtcon & S3C_WTCON_ENABLE) ?  "" : "in",
+		 (wtcon & S3C_WTCON_RSTEN) ? "" : "dis",
+		 (wtcon & S3C_WTCON_INTEN) ? "" : "en");
+
+	return 0;
+
+ err_clk:
+	clk_disable(wdt_clock);
+	clk_put(wdt_clock);
+
+ err_irq:
+	free_irq(wdt_irq->start, pdev);
+
+ err_map:
+	iounmap(wdt_base);
+
+ err_req:
+	release_resource(wdt_mem);
+	kfree(wdt_mem);
+
+	return ret;
+}
+
+static int s3c_wdt_remove(struct platform_device *dev)
+{
+	release_resource(wdt_mem);
+	kfree(wdt_mem);
+	wdt_mem = NULL;
+
+	free_irq(wdt_irq->start, dev);
+	wdt_irq = NULL;
+
+	clk_disable(wdt_clock);
+	clk_put(wdt_clock);
+	wdt_clock = NULL;
+
+	iounmap(wdt_base);
+	misc_deregister(&s3c_wdt_miscdev);
+	return 0;
+}
+
+static void s3c_wdt_shutdown(struct platform_device *dev)
+{
+	s3c_wdt_stop();
+}
+
+#ifdef CONFIG_PM
+
+static unsigned long wtcon_save;
+static unsigned long wtdat_save;
+
+static int s3c_wdt_suspend(struct platform_device *dev, pm_message_t state)
+{
+	/* Save watchdog state, and turn it off. */
+	wtcon_save = readl(wdt_base + S3C_WTCON);
+	wtdat_save = readl(wdt_base + S3C_WTDAT);
+
+	/* Note that WTCNT doesn't need to be saved. */
+	s3c_wdt_stop();
+
+	return 0;
+}
+
+static int s3c_wdt_resume(struct platform_device *dev)
+{
+	/* Restore watchdog state. */
+
+	writel(wtdat_save, wdt_base + S3C_WTDAT);
+	writel(wtdat_save, wdt_base + S3C_WTCNT); /* Reset count */
+	writel(wtcon_save, wdt_base + S3C_WTCON);
+
+	printk(KERN_INFO PFX "watchdog %sabled\n",
+	       (wtcon_save & S3C_WTCON_ENABLE) ? "en" : "dis");
+
+	return 0;
+}
+
+#else
+#define s3c_wdt_suspend NULL
+#define s3c_wdt_resume  NULL
+#endif /* CONFIG_PM */
+
+
+static struct platform_driver s3c_wdt_driver = {
+	.probe		= s3c_wdt_probe,
+	.remove		= s3c_wdt_remove,
+	.shutdown	= s3c_wdt_shutdown,
+	.suspend	= s3c_wdt_suspend,
+	.resume		= s3c_wdt_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c-wdt",
+	},
+};
+
+
+static char banner[] __initdata =
+	KERN_INFO "S3C Watchdog Timer, (c) 2004 Simtec Electronics\n";
+
+static int __init watchdog_init(void)
+{
+	printk(banner);
+	return platform_driver_register(&s3c_wdt_driver);
+}
+
+static void __exit watchdog_exit(void)
+{
+	platform_driver_unregister(&s3c_wdt_driver);
+}
+
+module_init(watchdog_init);
+module_exit(watchdog_exit);
+
+MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>, "
+	      "Dimitry Andric <dimitry.andric@tomtom.com>");
+MODULE_DESCRIPTION("S3C Watchdog Device Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
+MODULE_ALIAS("platform:s3c-wdt");
diff -Nur linux-2.6.29/fs/buffer.c linux-2.6.29-spica/fs/buffer.c
--- linux-2.6.29/fs/buffer.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/buffer.c	2010-05-06 12:42:45.684270633 +0700
@@ -111,7 +111,9 @@
 static void buffer_io_error(struct buffer_head *bh)
 {
 	char b[BDEVNAME_SIZE];
-	printk(KERN_ERR "Buffer I/O error on device %s, logical block %Lu\n",
+
+	/* Change from KERN_WARNING to KERN_DEBUG to eliminate SD card notification sound crach. */
+	printk(KERN_DEBUG "Buffer I/O error on device %s, logical block %Lu\n",
 			bdevname(bh->b_bdev, b),
 			(unsigned long long)bh->b_blocknr);
 }
@@ -154,7 +156,8 @@
 	} else {
 		if (!buffer_eopnotsupp(bh) && !quiet_error(bh)) {
 			buffer_io_error(bh);
-			printk(KERN_WARNING "lost page write due to "
+			/* Change from KERN_WARNING to KERN_DEBUG to eliminate SD card notification sound crach. */
+			printk(KERN_DEBUG "lost page write due to "
 					"I/O error on %s\n",
 				       bdevname(bh->b_bdev, b));
 		}
@@ -521,7 +524,8 @@
 	} else {
 		if (!quiet_error(bh)) {
 			buffer_io_error(bh);
-			printk(KERN_WARNING "lost page write due to "
+			/* Change from KERN_WARNING to KERN_DEBUG to eliminate SD card notification sound crach. */
+			printk(KERN_DEBUG "lost page write due to "
 					"I/O error on %s\n",
 			       bdevname(bh->b_bdev, b));
 		}
diff -Nur linux-2.6.29/fs/fat/cache.c linux-2.6.29-spica/fs/fat/cache.c
--- linux-2.6.29/fs/fat/cache.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/fat/cache.c	2010-05-06 12:42:45.684270633 +0700
@@ -29,6 +29,9 @@
 	int dcluster;
 };
 
+
+int error_count=0;
+
 static inline int fat_max_cache(struct inode *inode)
 {
 	return FAT_MAX_CACHE;
@@ -241,7 +244,7 @@
 	while (*fclus < cluster) {
 		/* prevent the infinite loop of cluster chain */
 		if (*fclus > limit) {
-			fat_fs_panic(sb, "%s: detected the cluster chain loop"
+			fat_fs_error(sb, "%s: detected the cluster chain loop"
 				     " (i_pos %lld)", __func__,
 				     MSDOS_I(inode)->i_pos);
 			nr = -EIO;
@@ -252,7 +255,7 @@
 		if (nr < 0)
 			goto out;
 		else if (nr == FAT_ENT_FREE) {
-			fat_fs_panic(sb, "%s: invalid cluster chain"
+			fat_fs_error(sb, "%s: invalid cluster chain"
 				     " (i_pos %lld)", __func__,
 				     MSDOS_I(inode)->i_pos);
 			nr = -EIO;
@@ -285,8 +288,14 @@
 	if (ret < 0)
 		return ret;
 	else if (ret == FAT_ENT_EOF) {
-		fat_fs_panic(sb, "%s: request beyond EOF (i_pos %lld)",
-			     __func__, MSDOS_I(inode)->i_pos);
+	
+		if(error_count%100==0)
+		{
+			fat_fs_error(sb, "%s: request beyond EOF (i_pos %lld)",
+					 __func__, MSDOS_I(inode)->i_pos);
+		}
+		error_count++;
+
 		return -EIO;
 	}
 	return dclus;
diff -Nur linux-2.6.29/fs/fat/dir.c linux-2.6.29-spica/fs/fat/dir.c
--- linux-2.6.29/fs/fat/dir.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/fat/dir.c	2010-05-06 12:42:45.684270633 +0700
@@ -85,8 +85,9 @@
 
 	*bh = sb_bread(sb, phys);
 	if (*bh == NULL) {
-		printk(KERN_ERR "FAT: Directory bread(block %llu) failed\n",
-		       (llu)phys);
+		/* Change from KERN_ERR to KERN_DEBUG to eliminate SD card notification sound crach. */
+		printk(KERN_DEBUG "FAT: Directory bread(block %llu) failed\n",
+		       (unsigned long long)phys);
 		/* skip this block */
 		*pos = (iblock + 1) << sb->s_blocksize_bits;
 		goto next;
@@ -758,6 +759,13 @@
 	return ret;
 }
 
+static int fat_ioctl_volume_id(struct inode *dir)
+{
+	struct super_block *sb = dir->i_sb;
+	struct msdos_sb_info *sbi = MSDOS_SB(sb);
+	return sbi->vol_id;
+}
+
 static int fat_dir_ioctl(struct inode *inode, struct file *filp,
 			 unsigned int cmd, unsigned long arg)
 {
@@ -773,6 +781,8 @@
 		short_only = 0;
 		both = 1;
 		break;
+	case VFAT_IOCTL_GET_VOLUME_ID:
+		return fat_ioctl_volume_id(inode);
 	default:
 		return fat_generic_ioctl(inode, filp, cmd, arg);
 	}
@@ -1334,7 +1344,7 @@
 			goto error_remove;
 		}
 		if (dir->i_size & (sbi->cluster_size - 1)) {
-			fat_fs_panic(sb, "Odd directory size");
+			fat_fs_error(sb, "Odd directory size");
 			dir->i_size = (dir->i_size + sbi->cluster_size - 1)
 				& ~((loff_t)sbi->cluster_size - 1);
 		}
diff -Nur linux-2.6.29/fs/fat/fatent.c linux-2.6.29-spica/fs/fat/fatent.c
--- linux-2.6.29/fs/fat/fatent.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/fat/fatent.c	2010-05-06 12:42:45.684270633 +0700
@@ -93,7 +93,9 @@
 err_brelse:
 	brelse(bhs[0]);
 err:
-	printk(KERN_ERR "FAT: FAT read failed (blocknr %llu)\n", (llu)blocknr);
+	/* Change from KERN_ERR to KERN_DEBUG to eliminate SD card notification sound crach. */
+	printk(KERN_DEBUG "FAT: FAT read failed (blocknr %llu)\n",
+	       (unsigned long long)blocknr);
 	return -EIO;
 }
 
@@ -105,8 +107,9 @@
 	WARN_ON(blocknr < MSDOS_SB(sb)->fat_start);
 	fatent->bhs[0] = sb_bread(sb, blocknr);
 	if (!fatent->bhs[0]) {
-		printk(KERN_ERR "FAT: FAT read failed (blocknr %llu)\n",
-		       (llu)blocknr);
+		/* Change from KERN_ERR to KERN_DEBUG to eliminate SD card notification sound crach. */
+		printk(KERN_DEBUG "FAT: FAT read failed (blocknr %llu)\n",
+		       (unsigned long long)blocknr);
 		return -EIO;
 	}
 	fatent->nr_bhs = 1;
@@ -345,7 +348,7 @@
 
 	if (entry < FAT_START_ENT || sbi->max_cluster <= entry) {
 		fatent_brelse(fatent);
-		fat_fs_panic(sb, "invalid access to FAT (entry 0x%08x)", entry);
+		fat_fs_error(sb, "invalid access to FAT (entry 0x%08x)", entry);
 		return -EIO;
 	}
 
@@ -557,8 +560,9 @@
 			err = cluster;
 			goto error;
 		} else if (cluster == FAT_ENT_FREE) {
-			fat_fs_panic(sb, "%s: deleting FAT entry beyond EOF",
+			fat_fs_error(sb, "%s: deleting FAT entry beyond EOF",
 				     __func__);
+			printk("inode = %lu\n", inode->i_ino);
 			err = -EIO;
 			goto error;
 		}
diff -Nur linux-2.6.29/fs/fat/fat.h linux-2.6.29-spica/fs/fat/fat.h
--- linux-2.6.29/fs/fat/fat.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/fat/fat.h	2010-03-30 11:01:22.000000000 +0700
@@ -17,6 +17,10 @@
 #define VFAT_SFN_CREATE_WIN95	0x0100 /* emulate win95 rule for create */
 #define VFAT_SFN_CREATE_WINNT	0x0200 /* emulate winnt rule for create */
 
+#define FAT_ERRORS_CONT		1      /* ignore error and continue */
+#define FAT_ERRORS_PANIC	2      /* panic on error */
+#define FAT_ERRORS_RO		3      /* remount r/o on error */
+
 struct fat_mount_options {
 	uid_t fs_uid;
 	gid_t fs_gid;
@@ -26,6 +30,7 @@
 	char *iocharset;          /* Charset used for filename input/display */
 	unsigned short shortname; /* flags for shortname display/create rule */
 	unsigned char name_check; /* r = relaxed, n = normal, s = strict */
+	unsigned char errors;	  /* On error: continue, panic, remount-ro */
 	unsigned short allow_utime;/* permission for setting the [am]time */
 	unsigned quiet:1,         /* set = fake successful chmods and chowns */
 		 showexec:1,      /* set = only set x bit for com/exe/bat */
@@ -71,6 +76,7 @@
 	const void *dir_ops;		     /* Opaque; default directory operations */
 	int dir_per_block;	     /* dir entries per block */
 	int dir_per_block_bits;	     /* log2(dir_per_block) */
+	unsigned long vol_id;        /* volume ID */
 
 	int fatent_shift;
 	struct fatent_operations *fatent_ops;
@@ -310,7 +316,7 @@
 extern int fat_flush_inodes(struct super_block *sb, struct inode *i1,
 		            struct inode *i2);
 /* fat/misc.c */
-extern void fat_fs_panic(struct super_block *s, const char *fmt, ...)
+extern void fat_fs_error(struct super_block *s, const char *fmt, ...)
 	__attribute__ ((format (printf, 2, 3))) __cold;
 extern void fat_clusters_flush(struct super_block *sb);
 extern int fat_chain_add(struct inode *inode, int new_dclus, int nr_cluster);
diff -Nur linux-2.6.29/fs/fat/file.c linux-2.6.29-spica/fs/fat/file.c
--- linux-2.6.29/fs/fat/file.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/fat/file.c	2010-03-30 11:01:22.000000000 +0700
@@ -213,7 +213,7 @@
 			fatent_brelse(&fatent);
 			return 0;
 		} else if (ret == FAT_ENT_FREE) {
-			fat_fs_panic(sb,
+			fat_fs_error(sb,
 				     "%s: invalid cluster chain (i_pos %lld)",
 				     __func__, MSDOS_I(inode)->i_pos);
 			ret = -EIO;
diff -Nur linux-2.6.29/fs/fat/inode.c linux-2.6.29-spica/fs/fat/inode.c
--- linux-2.6.29/fs/fat/inode.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/fat/inode.c	2010-03-30 11:01:22.000000000 +0700
@@ -76,7 +76,7 @@
 		return 0;
 
 	if (iblock != MSDOS_I(inode)->mmu_private >> sb->s_blocksize_bits) {
-		fat_fs_panic(sb, "corrupted file size (i_pos %lld, %lld)",
+		fat_fs_error(sb, "corrupted file size (i_pos %lld, %lld)",
 			MSDOS_I(inode)->i_pos, MSDOS_I(inode)->mmu_private);
 		return -EIO;
 	}
@@ -830,6 +830,12 @@
 		seq_puts(m, ",flush");
 	if (opts->tz_utc)
 		seq_puts(m, ",tz=UTC");
+	if (opts->errors == FAT_ERRORS_CONT)
+		seq_puts(m, ",errors=continue");
+	else if (opts->errors == FAT_ERRORS_PANIC)
+		seq_puts(m, ",errors=panic");
+	else
+		seq_puts(m, ",errors=remount-ro");
 
 	return 0;
 }
@@ -842,7 +848,8 @@
 	Opt_charset, Opt_shortname_lower, Opt_shortname_win95,
 	Opt_shortname_winnt, Opt_shortname_mixed, Opt_utf8_no, Opt_utf8_yes,
 	Opt_uni_xl_no, Opt_uni_xl_yes, Opt_nonumtail_no, Opt_nonumtail_yes,
-	Opt_obsolate, Opt_flush, Opt_tz_utc, Opt_rodir, Opt_err,
+	Opt_obsolate, Opt_flush, Opt_tz_utc, Opt_rodir, Opt_err_cont,
+	Opt_err_panic, Opt_err_ro, Opt_err,
 };
 
 static const match_table_t fat_tokens = {
@@ -865,6 +872,11 @@
 	{Opt_showexec, "showexec"},
 	{Opt_debug, "debug"},
 	{Opt_immutable, "sys_immutable"},
+	{Opt_flush, "flush"},
+	{Opt_tz_utc, "tz=UTC"},
+	{Opt_err_cont, "errors=continue"},
+	{Opt_err_panic, "errors=panic"},
+	{Opt_err_ro, "errors=remount-ro"},
 	{Opt_obsolate, "conv=binary"},
 	{Opt_obsolate, "conv=text"},
 	{Opt_obsolate, "conv=auto"},
@@ -876,8 +888,6 @@
 	{Opt_obsolate, "cvf_format=%20s"},
 	{Opt_obsolate, "cvf_options=%100s"},
 	{Opt_obsolate, "posix"},
-	{Opt_flush, "flush"},
-	{Opt_tz_utc, "tz=UTC"},
 	{Opt_err, NULL},
 };
 static const match_table_t msdos_tokens = {
@@ -947,6 +957,7 @@
 	opts->numtail = 1;
 	opts->usefree = opts->nocase = 0;
 	opts->tz_utc = 0;
+	opts->errors = FAT_ERRORS_RO;
 	*debug = 0;
 
 	if (!options)
@@ -1039,6 +1050,15 @@
 		case Opt_tz_utc:
 			opts->tz_utc = 1;
 			break;
+		case Opt_err_cont:
+			opts->errors = FAT_ERRORS_CONT;
+			break;
+		case Opt_err_panic:
+			opts->errors = FAT_ERRORS_PANIC;
+			break;
+		case Opt_err_ro:
+			opts->errors = FAT_ERRORS_RO;
+			break;
 
 		/* msdos specific */
 		case Opt_dots:
@@ -1173,6 +1193,7 @@
 	struct inode *root_inode = NULL;
 	struct buffer_head *bh;
 	struct fat_boot_sector *b;
+	struct fat_boot_bsx *bsx;
 	struct msdos_sb_info *sbi;
 	u16 logical_sector_size;
 	u32 total_sectors, total_clusters, fat_clusters, rootdir_sectors;
@@ -1315,6 +1336,8 @@
 			goto out_fail;
 		}
 
+		bsx = (struct fat_boot_bsx *)(bh->b_data + FAT32_BSX_OFFSET);
+
 		fsinfo = (struct fat_boot_fsinfo *)fsinfo_bh->b_data;
 		if (!IS_FSINFO(fsinfo)) {
 			printk(KERN_WARNING "FAT: Invalid FSINFO signature: "
@@ -1330,8 +1353,14 @@
 		}
 
 		brelse(fsinfo_bh);
+	} else {
+		bsx = (struct fat_boot_bsx *)(bh->b_data + FAT16_BSX_OFFSET);
 	}
 
+	/* interpret volume ID as a little endian 32 bit integer */
+	sbi->vol_id = (((u32)bsx->vol_id[0]) | ((u32)bsx->vol_id[1] << 8) |
+		((u32)bsx->vol_id[2] << 16) | ((u32)bsx->vol_id[3] << 24));
+
 	sbi->dir_per_block = sb->s_blocksize / sizeof(struct msdos_dir_entry);
 	sbi->dir_per_block_bits = ffs(sbi->dir_per_block) - 1;
 
diff -Nur linux-2.6.29/fs/fat/misc.c linux-2.6.29-spica/fs/fat/misc.c
--- linux-2.6.29/fs/fat/misc.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/fat/misc.c	2010-03-30 11:01:22.000000000 +0700
@@ -12,14 +12,19 @@
 #include "fat.h"
 
 /*
- * fat_fs_panic reports a severe file system problem and sets the file system
- * read-only. The file system can be made writable again by remounting it.
+ * fat_fs_error reports a file system problem that might indicate fa data
+ * corruption/inconsistency. Depending on 'errors' mount option the
+ * panic() is called, or error message is printed FAT and nothing is done,
+ * or filesystem is remounted read-only (default behavior).
+ * In case the file system is remounted read-only, it can be made writable
+ * again by remounting it.
  */
-void fat_fs_panic(struct super_block *s, const char *fmt, ...)
+void fat_fs_error(struct super_block *s, const char *fmt, ...)
 {
+	struct fat_mount_options *opts = &MSDOS_SB(s)->options;
 	va_list args;
 
-	printk(KERN_ERR "FAT: Filesystem panic (dev %s)\n", s->s_id);
+	printk(KERN_ERR "FAT: Filesystem error (dev %s)\n", s->s_id);
 
 	printk(KERN_ERR "    ");
 	va_start(args, fmt);
@@ -27,13 +32,14 @@
 	va_end(args);
 	printk("\n");
 
-	if (!(s->s_flags & MS_RDONLY)) {
+	if (opts->errors == FAT_ERRORS_PANIC)
+		panic("    FAT fs panic from previous error\n");
+	else if (opts->errors == FAT_ERRORS_RO && !(s->s_flags & MS_RDONLY)) {
 		s->s_flags |= MS_RDONLY;
 		printk(KERN_ERR "    File system has been set read-only\n");
 	}
 }
-
-EXPORT_SYMBOL_GPL(fat_fs_panic);
+EXPORT_SYMBOL_GPL(fat_fs_error);
 
 /* Flushes the number of free clusters on FAT32 */
 /* XXX: Need to write one per FSINFO block.  Currently only writes 1 */
@@ -124,7 +130,7 @@
 			mark_inode_dirty(inode);
 	}
 	if (new_fclus != (inode->i_blocks >> (sbi->cluster_bits - 9))) {
-		fat_fs_panic(sb, "clusters badly computed (%d != %llu)",
+		fat_fs_error(sb, "clusters badly computed (%d != %llu)",
 			     new_fclus,
 			     (llu)(inode->i_blocks >> (sbi->cluster_bits - 9)));
 		fat_cache_inval_inode(inode);
diff -Nur linux-2.6.29/fs/fat/namei_msdos.c linux-2.6.29-spica/fs/fat/namei_msdos.c
--- linux-2.6.29/fs/fat/namei_msdos.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/fat/namei_msdos.c	2010-03-30 11:01:21.000000000 +0700
@@ -608,7 +608,7 @@
 		sinfo.bh = NULL;
 	}
 	if (corrupt < 0) {
-		fat_fs_panic(new_dir->i_sb,
+		fat_fs_error(new_dir->i_sb,
 			     "%s: Filesystem corrupted (i_pos %lld)",
 			     __func__, sinfo.i_pos);
 	}
diff -Nur linux-2.6.29/fs/fat/namei_vfat.c linux-2.6.29-spica/fs/fat/namei_vfat.c
--- linux-2.6.29/fs/fat/namei_vfat.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/fat/namei_vfat.c	2010-03-30 11:01:22.000000000 +0700
@@ -1030,7 +1030,7 @@
 		sinfo.bh = NULL;
 	}
 	if (corrupt < 0) {
-		fat_fs_panic(new_dir->i_sb,
+		fat_fs_error(new_dir->i_sb,
 			     "%s: Filesystem corrupted (i_pos %lld)",
 			     __func__, sinfo.i_pos);
 	}
diff -Nur linux-2.6.29/fs/fs-writeback.c linux-2.6.29-spica/fs/fs-writeback.c
--- linux-2.6.29/fs/fs-writeback.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/fs-writeback.c	2010-03-30 11:01:22.000000000 +0700
@@ -114,7 +114,7 @@
 	if ((inode->i_state & flags) == flags)
 		return;
 
-	if (unlikely(block_dump)) {
+	if (unlikely(block_dump > 1)) {
 		struct dentry *dentry = NULL;
 		const char *name = "?";
 
diff -Nur linux-2.6.29/fs/Kconfig linux-2.6.29-spica/fs/Kconfig
--- linux-2.6.29/fs/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/Kconfig	2010-03-30 11:01:26.000000000 +0700
@@ -209,6 +209,10 @@
 source "fs/befs/Kconfig"
 source "fs/bfs/Kconfig"
 source "fs/efs/Kconfig"
+
+# Patched by YAFFS
+source "fs/yaffs2/Kconfig"
+
 source "fs/jffs2/Kconfig"
 # UBIFS File system configuration
 source "fs/ubifs/Kconfig"
diff -Nur linux-2.6.29/fs/Makefile linux-2.6.29-spica/fs/Makefile
--- linux-2.6.29/fs/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/Makefile	2010-03-30 11:01:25.000000000 +0700
@@ -124,3 +124,6 @@
 obj-$(CONFIG_OCFS2_FS)		+= ocfs2/
 obj-$(CONFIG_BTRFS_FS)		+= btrfs/
 obj-$(CONFIG_GFS2_FS)           += gfs2/
+
+# Patched by YAFFS
+obj-$(CONFIG_YAFFS_FS)		+= yaffs2/
diff -Nur linux-2.6.29/fs/partitions/check.c linux-2.6.29-spica/fs/partitions/check.c
--- linux-2.6.29/fs/partitions/check.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/partitions/check.c	2010-05-06 12:42:45.684270633 +0700
@@ -304,10 +304,20 @@
 	kfree(p);
 }
 
+static int part_uevent(struct device *dev, struct kobj_uvent_env *env)
+{
+	struct gendisk *disk = dev_to_disk(dev);
+	struct hd_struct *part = dev_to_part(dev);
+
+	add_uevent_var(env, "PARTN=%u", part->partno);
+	return 0;
+}
+
 struct device_type part_type = {
 	.name		= "partition",
 	.groups		= part_attr_groups,
 	.release	= part_release,
+	.uevent		= part_uevent,
 };
 
 static void delete_partition_rcu_cb(struct rcu_head *head)
diff -Nur linux-2.6.29/fs/proc/base.c linux-2.6.29-spica/fs/proc/base.c
--- linux-2.6.29/fs/proc/base.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/fs/proc/base.c	2010-03-30 11:01:27.000000000 +0700
@@ -127,6 +127,12 @@
 		NULL, &proc_single_file_operations,	\
 		{ .proc_show = show } )
 
+/* ANDROID is for special files in /proc. */
+#define ANDROID(NAME, MODE, OTYPE)			\
+	NOD(NAME, (S_IFREG|(MODE)),			\
+		&proc_##OTYPE##_inode_operations,	\
+		&proc_##OTYPE##_operations, {})
+
 /*
  * Count the number of hardlinks for the pid_entry table, excluding the .
  * and .. links.
@@ -252,7 +258,8 @@
 	if (task->mm != mm)
 		goto out;
 	if (task->mm != current->mm &&
-	    __ptrace_may_access(task, PTRACE_MODE_READ) < 0)
+	    __ptrace_may_access(task, PTRACE_MODE_READ) < 0 &&
+	    !capable(CAP_SYS_RESOURCE))
 		goto out;
 	task_unlock(task);
 	return mm;
@@ -1060,6 +1067,33 @@
 	return end - buffer;
 }
 
+static int oom_adjust_permission(struct inode *inode, int mask)
+{
+	uid_t uid;
+	struct task_struct *p = get_proc_task(inode);
+	if(p) {
+		uid = task_uid(p);
+		put_task_struct(p);
+	}
+
+	/*
+	 * System Server (uid == 1000) is granted access to oom_adj of all 
+	 * android applications (uid > 10000) as and services (uid >= 1000)
+	 */
+	if (p && (current_fsuid() == 1000) && (uid >= 1000)) {
+		if (inode->i_mode >> 6 & mask) {
+			return 0;
+		}
+	}
+
+	/* Fall back to default. */
+	return generic_permission(inode, mask, NULL);
+}
+
+static const struct inode_operations proc_oom_adjust_inode_operations = {
+	.permission	= oom_adjust_permission,
+};
+
 static const struct file_operations proc_oom_adjust_operations = {
 	.read		= oom_adjust_read,
 	.write		= oom_adjust_write,
@@ -2542,7 +2576,7 @@
 	REG("cgroup",  S_IRUGO, proc_cgroup_operations),
 #endif
 	INF("oom_score",  S_IRUGO, proc_oom_score),
-	REG("oom_adj",    S_IRUGO|S_IWUSR, proc_oom_adjust_operations),
+	ANDROID("oom_adj",S_IRUGO|S_IWUSR, oom_adjust),
 #ifdef CONFIG_AUDITSYSCALL
 	REG("loginuid",   S_IWUSR|S_IRUGO, proc_loginuid_operations),
 	REG("sessionid",  S_IRUGO, proc_sessionid_operations),
diff -Nur linux-2.6.29/fs/yaffs2/devextras.h linux-2.6.29-spica/fs/yaffs2/devextras.h
--- linux-2.6.29/fs/yaffs2/devextras.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/devextras.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,196 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * This file is just holds extra declarations of macros that would normally
+ * be providesd in the Linux kernel. These macros have been written from
+ * scratch but are functionally equivalent to the Linux ones.
+ *
+ */
+
+#ifndef __EXTRAS_H__
+#define __EXTRAS_H__
+
+
+#if !(defined __KERNEL__)
+
+/* Definition of types */
+typedef unsigned char __u8;
+typedef unsigned short __u16;
+typedef unsigned __u32;
+
+#endif
+
+/*
+ * This is a simple doubly linked list implementation that matches the
+ * way the Linux kernel doubly linked list implementation works.
+ */
+
+struct ylist_head {
+	struct ylist_head *next; /* next in chain */
+	struct ylist_head *prev; /* previous in chain */
+};
+
+
+/* Initialise a static list */
+#define YLIST_HEAD(name) \
+struct ylist_head name = { &(name), &(name)}
+
+
+
+/* Initialise a list head to an empty list */
+#define YINIT_LIST_HEAD(p) \
+do { \
+	(p)->next = (p);\
+	(p)->prev = (p); \
+} while (0)
+
+
+/* Add an element to a list */
+static __inline__ void ylist_add(struct ylist_head *newEntry,
+				struct ylist_head *list)
+{
+	struct ylist_head *listNext = list->next;
+
+	list->next = newEntry;
+	newEntry->prev = list;
+	newEntry->next = listNext;
+	listNext->prev = newEntry;
+
+}
+
+static __inline__ void ylist_add_tail(struct ylist_head *newEntry,
+				 struct ylist_head *list)
+{
+	struct ylist_head *listPrev = list->prev;
+
+	list->prev = newEntry;
+	newEntry->next = list;
+	newEntry->prev = listPrev;
+	listPrev->next = newEntry;
+
+}
+
+
+/* Take an element out of its current list, with or without
+ * reinitialising the links.of the entry*/
+static __inline__ void ylist_del(struct ylist_head *entry)
+{
+	struct ylist_head *listNext = entry->next;
+	struct ylist_head *listPrev = entry->prev;
+
+	listNext->prev = listPrev;
+	listPrev->next = listNext;
+
+}
+
+static __inline__ void ylist_del_init(struct ylist_head *entry)
+{
+	ylist_del(entry);
+	entry->next = entry->prev = entry;
+}
+
+
+/* Test if the list is empty */
+static __inline__ int ylist_empty(struct ylist_head *entry)
+{
+	return (entry->next == entry);
+}
+
+
+/* ylist_entry takes a pointer to a list entry and offsets it to that
+ * we can find a pointer to the object it is embedded in.
+ */
+
+
+#define ylist_entry(entry, type, member) \
+	((type *)((char *)(entry)-(unsigned long)(&((type *)NULL)->member)))
+
+
+/* ylist_for_each and list_for_each_safe  iterate over lists.
+ * ylist_for_each_safe uses temporary storage to make the list delete safe
+ */
+
+#define ylist_for_each(itervar, list) \
+	for (itervar = (list)->next; itervar != (list); itervar = itervar->next)
+
+#define ylist_for_each_safe(itervar, saveVar, list) \
+	for (itervar = (list)->next, saveVar = (list)->next->next; \
+		itervar != (list); itervar = saveVar, saveVar = saveVar->next)
+
+
+#if !(defined __KERNEL__)
+
+
+#ifndef WIN32
+#include <sys/stat.h>
+#endif
+
+
+#ifdef CONFIG_YAFFS_PROVIDE_DEFS
+/* File types */
+
+
+#define DT_UNKNOWN	0
+#define DT_FIFO		1
+#define DT_CHR		2
+#define DT_DIR		4
+#define DT_BLK		6
+#define DT_REG		8
+#define DT_LNK		10
+#define DT_SOCK		12
+#define DT_WHT		14
+
+
+#ifndef WIN32
+#include <sys/stat.h>
+#endif
+
+/*
+ * Attribute flags.  These should be or-ed together to figure out what
+ * has been changed!
+ */
+#define ATTR_MODE	1
+#define ATTR_UID	2
+#define ATTR_GID	4
+#define ATTR_SIZE	8
+#define ATTR_ATIME	16
+#define ATTR_MTIME	32
+#define ATTR_CTIME	64
+
+struct iattr {
+	unsigned int ia_valid;
+	unsigned ia_mode;
+	unsigned ia_uid;
+	unsigned ia_gid;
+	unsigned ia_size;
+	unsigned ia_atime;
+	unsigned ia_mtime;
+	unsigned ia_ctime;
+	unsigned int ia_attr_flags;
+};
+
+#endif
+
+#else
+
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+
+#endif
+
+
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/Kconfig linux-2.6.29-spica/fs/yaffs2/Kconfig
--- linux-2.6.29/fs/yaffs2/Kconfig	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/Kconfig	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,164 @@
+#
+# YAFFS file system configurations
+#
+
+config YAFFS_FS
+	tristate "YAFFS2 file system support"
+	default n
+	depends on MTD_BLOCK
+	select YAFFS_YAFFS1
+	select YAFFS_YAFFS2
+	help
+	  YAFFS2, or Yet Another Flash Filing System, is a filing system
+	  optimised for NAND Flash chips.
+
+	  To compile the YAFFS2 file system support as a module, choose M
+	  here: the module will be called yaffs2.
+
+	  If unsure, say N.
+
+	  Further information on YAFFS2 is available at
+	  <http://www.aleph1.co.uk/yaffs/>.
+
+config YAFFS_YAFFS1
+	bool "512 byte / page devices"
+	depends on YAFFS_FS
+	default y
+	help
+	  Enable YAFFS1 support -- yaffs for 512 byte / page devices
+
+	  Not needed for 2K-page devices.
+
+	  If unsure, say Y.
+
+config YAFFS_9BYTE_TAGS
+	bool "Use older-style on-NAND data format with pageStatus byte"
+	depends on YAFFS_YAFFS1
+	default n
+	help
+
+	  Older-style on-NAND data format has a "pageStatus" byte to record
+	  chunk/page state.  This byte is zero when the page is discarded.
+	  Choose this option if you have existing on-NAND data using this
+	  format that you need to continue to support.  New data written
+	  also uses the older-style format.  Note: Use of this option
+	  generally requires that MTD's oob layout be adjusted to use the
+	  older-style format.  See notes on tags formats and MTD versions
+	  in yaffs_mtdif1.c.
+
+	  If unsure, say N.
+
+config YAFFS_DOES_ECC
+	bool "Lets Yaffs do its own ECC"
+	depends on YAFFS_FS && YAFFS_YAFFS1 && !YAFFS_9BYTE_TAGS
+	default n
+	help
+	  This enables Yaffs to use its own ECC functions instead of using
+	  the ones from the generic MTD-NAND driver.
+
+	  If unsure, say N.
+
+config YAFFS_ECC_WRONG_ORDER
+	bool "Use the same ecc byte order as Steven Hill's nand_ecc.c"
+	depends on YAFFS_FS && YAFFS_DOES_ECC && !YAFFS_9BYTE_TAGS
+	default n
+	help
+	  This makes yaffs_ecc.c use the same ecc byte order as Steven
+	  Hill's nand_ecc.c. If not set, then you get the same ecc byte
+	  order as SmartMedia.
+
+	  If unsure, say N.
+
+config YAFFS_YAFFS2
+	bool "2048 byte (or larger) / page devices"
+	depends on YAFFS_FS
+	default y
+	help
+	  Enable YAFFS2 support -- yaffs for >= 2K bytes per page devices
+
+	  If unsure, say Y.
+
+config YAFFS_AUTO_YAFFS2
+	bool "Autoselect yaffs2 format"
+	depends on YAFFS_YAFFS2
+	default y
+	help
+	  Without this, you need to explicitely use yaffs2 as the file
+	  system type. With this, you can say "yaffs" and yaffs or yaffs2
+	  will be used depending on the device page size (yaffs on
+	  512-byte page devices, yaffs2 on 2K page devices).
+
+	  If unsure, say Y.
+
+config YAFFS_DISABLE_LAZY_LOAD
+	bool "Disable lazy loading"
+	depends on YAFFS_YAFFS2
+	default n
+	help
+	  "Lazy loading" defers loading file details until they are
+	  required. This saves mount time, but makes the first look-up
+	  a bit longer.
+
+	  Lazy loading will only happen if enabled by this option being 'n'
+	  and if the appropriate tags are available, else yaffs2 will
+	  automatically fall back to immediate loading and do the right
+	  thing.
+
+	  Lazy laoding will be required by checkpointing.
+
+	  Setting this to 'y' will disable lazy loading.
+
+	  If unsure, say N.
+
+
+config YAFFS_DISABLE_WIDE_TNODES
+	bool "Turn off wide tnodes"
+	depends on YAFFS_FS
+	default n
+	help
+	  Wide tnodes are only used for NAND arrays >=32MB for 512-byte
+	  page devices and >=128MB for 2k page devices. They use slightly
+	  more RAM but are faster since they eliminate chunk group
+	  searching.
+
+	  Setting this to 'y' will force tnode width to 16 bits and save
+	  memory but make large arrays slower.
+
+	  If unsure, say N.
+
+config YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+	bool "Force chunk erase check"
+	depends on YAFFS_FS
+	default n
+	help
+          Normally YAFFS only checks chunks before writing until an erased
+	  chunk is found. This helps to detect any partially written
+	  chunks that might have happened due to power loss.
+
+	  Enabling this forces on the test that chunks are erased in flash
+	  before writing to them. This takes more time but is potentially
+	  a bit more secure.
+
+	  Suggest setting Y during development and ironing out driver
+	  issues etc. Suggest setting to N if you want faster writing.
+
+	  If unsure, say Y.
+
+config YAFFS_SHORT_NAMES_IN_RAM
+	bool "Cache short names in RAM"
+	depends on YAFFS_FS
+	default y
+	help
+	  If this config is set, then short names are stored with the
+	  yaffs_Object.  This costs an extra 16 bytes of RAM per object,
+	  but makes look-ups faster.
+
+	  If unsure, say Y.
+
+config YAFFS_EMPTY_LOST_AND_FOUND
+	bool "Empty lost and found on mount"
+	depends on YAFFS_FS
+	default n
+	help
+	  If this is enabled then the contents of lost and found is
+	  automatically dumped at mount.
diff -Nur linux-2.6.29/fs/yaffs2/Makefile linux-2.6.29-spica/fs/yaffs2/Makefile
--- linux-2.6.29/fs/yaffs2/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/Makefile	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,10 @@
+#
+# Makefile for the linux YAFFS filesystem routines.
+#
+
+obj-$(CONFIG_YAFFS_FS) += yaffs.o
+
+yaffs-y := yaffs_ecc.o yaffs_fs.o yaffs_guts.o yaffs_checkptrw.o
+yaffs-y += yaffs_packedtags1.o yaffs_packedtags2.o yaffs_nand.o yaffs_qsort.o
+yaffs-y += yaffs_tagscompat.o yaffs_tagsvalidity.o
+yaffs-y += yaffs_mtdif.o yaffs_mtdif1.o yaffs_mtdif2.o
diff -Nur linux-2.6.29/fs/yaffs2/moduleconfig.h linux-2.6.29-spica/fs/yaffs2/moduleconfig.h
--- linux-2.6.29/fs/yaffs2/moduleconfig.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/moduleconfig.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,65 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Martin Fouts <Martin.Fouts@palmsource.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_CONFIG_H__
+#define __YAFFS_CONFIG_H__
+
+#ifdef YAFFS_OUT_OF_TREE
+
+/* DO NOT UNSET THESE THREE. YAFFS2 will not compile if you do. */
+#define CONFIG_YAFFS_FS
+#define CONFIG_YAFFS_YAFFS1
+#define CONFIG_YAFFS_YAFFS2
+
+/* These options are independent of each other.  Select those that matter. */
+
+/* Default: Not selected */
+/* Meaning: Yaffs does its own ECC, rather than using MTD ECC */
+/* #define CONFIG_YAFFS_DOES_ECC */
+
+/* Default: Not selected */
+/* Meaning: ECC byte order is 'wrong'.  Only meaningful if */
+/*          CONFIG_YAFFS_DOES_ECC is set */
+/* #define CONFIG_YAFFS_ECC_WRONG_ORDER */
+
+/* Default: Selected */
+/* Meaning: Disables testing whether chunks are erased before writing to them*/
+#define CONFIG_YAFFS_DISABLE_CHUNK_ERASED_CHECK
+
+/* Default: Selected */
+/* Meaning: Cache short names, taking more RAM, but faster look-ups */
+#define CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+
+/* Default: 10 */
+/* Meaning: set the count of blocks to reserve for checkpointing */
+#define CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS 10
+
+/*
+Older-style on-NAND data format has a "pageStatus" byte to record
+chunk/page state.  This byte is zeroed when the page is discarded.
+Choose this option if you have existing on-NAND data in this format
+that you need to continue to support.  New data written also uses the
+older-style format.
+Note: Use of this option generally requires that MTD's oob layout be
+adjusted to use the older-style format.  See notes on tags formats and
+MTD versions in yaffs_mtdif1.c.
+*/
+/* Default: Not selected */
+/* Meaning: Use older-style on-NAND data format with pageStatus byte */
+/* #define CONFIG_YAFFS_9BYTE_TAGS */
+
+#endif /* YAFFS_OUT_OF_TREE */
+
+#endif /* __YAFFS_CONFIG_H__ */
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_checkptrw.c linux-2.6.29-spica/fs/yaffs2/yaffs_checkptrw.c
--- linux-2.6.29/fs/yaffs2/yaffs_checkptrw.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_checkptrw.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,402 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+const char *yaffs_checkptrw_c_version =
+	"$Id$";
+
+
+#include "yaffs_checkptrw.h"
+#include "yaffs_getblockinfo.h"
+
+static int yaffs_CheckpointSpaceOk(yaffs_Device *dev)
+{
+	int blocksAvailable = dev->nErasedBlocks - dev->nReservedBlocks;
+
+	T(YAFFS_TRACE_CHECKPOINT,
+		(TSTR("checkpt blocks available = %d" TENDSTR),
+		blocksAvailable));
+
+	return (blocksAvailable <= 0) ? 0 : 1;
+}
+
+
+static int yaffs_CheckpointErase(yaffs_Device *dev)
+{
+	int i;
+
+	if (!dev->eraseBlockInNAND)
+		return 0;
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checking blocks %d to %d"TENDSTR),
+		dev->internalStartBlock, dev->internalEndBlock));
+
+	for (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {
+		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, i);
+		if (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT) {
+			T(YAFFS_TRACE_CHECKPOINT, (TSTR("erasing checkpt block %d"TENDSTR), i));
+
+			dev->nBlockErasures++;
+
+			if (dev->eraseBlockInNAND(dev, i - dev->blockOffset /* realign */)) {
+				bi->blockState = YAFFS_BLOCK_STATE_EMPTY;
+				dev->nErasedBlocks++;
+				dev->nFreeChunks += dev->nChunksPerBlock;
+			} else {
+				dev->markNANDBlockBad(dev, i);
+				bi->blockState = YAFFS_BLOCK_STATE_DEAD;
+			}
+		}
+	}
+
+	dev->blocksInCheckpoint = 0;
+
+	return 1;
+}
+
+
+static void yaffs_CheckpointFindNextErasedBlock(yaffs_Device *dev)
+{
+	int  i;
+	int blocksAvailable = dev->nErasedBlocks - dev->nReservedBlocks;
+	T(YAFFS_TRACE_CHECKPOINT,
+		(TSTR("allocating checkpt block: erased %d reserved %d avail %d next %d "TENDSTR),
+		dev->nErasedBlocks, dev->nReservedBlocks, blocksAvailable, dev->checkpointNextBlock));
+
+	if (dev->checkpointNextBlock >= 0 &&
+			dev->checkpointNextBlock <= dev->internalEndBlock &&
+			blocksAvailable > 0) {
+
+		for (i = dev->checkpointNextBlock; i <= dev->internalEndBlock; i++) {
+			yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, i);
+			if (bi->blockState == YAFFS_BLOCK_STATE_EMPTY) {
+				dev->checkpointNextBlock = i + 1;
+				dev->checkpointCurrentBlock = i;
+				T(YAFFS_TRACE_CHECKPOINT, (TSTR("allocating checkpt block %d"TENDSTR), i));
+				return;
+			}
+		}
+	}
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("out of checkpt blocks"TENDSTR)));
+
+	dev->checkpointNextBlock = -1;
+	dev->checkpointCurrentBlock = -1;
+}
+
+static void yaffs_CheckpointFindNextCheckpointBlock(yaffs_Device *dev)
+{
+	int  i;
+	yaffs_ExtendedTags tags;
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("find next checkpt block: start:  blocks %d next %d" TENDSTR),
+		dev->blocksInCheckpoint, dev->checkpointNextBlock));
+
+	if (dev->blocksInCheckpoint < dev->checkpointMaxBlocks)
+		for (i = dev->checkpointNextBlock; i <= dev->internalEndBlock; i++) {
+			int chunk = i * dev->nChunksPerBlock;
+			int realignedChunk = chunk - dev->chunkOffset;
+
+			dev->readChunkWithTagsFromNAND(dev, realignedChunk,
+					NULL, &tags);
+			T(YAFFS_TRACE_CHECKPOINT, (TSTR("find next checkpt block: search: block %d oid %d seq %d eccr %d" TENDSTR),
+				i, tags.objectId, tags.sequenceNumber, tags.eccResult));
+
+			if (tags.sequenceNumber == YAFFS_SEQUENCE_CHECKPOINT_DATA) {
+				/* Right kind of block */
+				dev->checkpointNextBlock = tags.objectId;
+				dev->checkpointCurrentBlock = i;
+				dev->checkpointBlockList[dev->blocksInCheckpoint] = i;
+				dev->blocksInCheckpoint++;
+				T(YAFFS_TRACE_CHECKPOINT, (TSTR("found checkpt block %d"TENDSTR), i));
+				return;
+			}
+		}
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("found no more checkpt blocks"TENDSTR)));
+
+	dev->checkpointNextBlock = -1;
+	dev->checkpointCurrentBlock = -1;
+}
+
+
+int yaffs_CheckpointOpen(yaffs_Device *dev, int forWriting)
+{
+
+
+	dev->checkpointOpenForWrite = forWriting;
+
+	/* Got the functions we need? */
+	if (!dev->writeChunkWithTagsToNAND ||
+			!dev->readChunkWithTagsFromNAND ||
+			!dev->eraseBlockInNAND ||
+			!dev->markNANDBlockBad)
+		return 0;
+
+	if (forWriting && !yaffs_CheckpointSpaceOk(dev))
+		return 0;
+
+	if (!dev->checkpointBuffer)
+		dev->checkpointBuffer = YMALLOC_DMA(dev->totalBytesPerChunk);
+	if (!dev->checkpointBuffer)
+		return 0;
+
+
+	dev->checkpointPageSequence = 0;
+	dev->checkpointByteCount = 0;
+	dev->checkpointSum = 0;
+	dev->checkpointXor = 0;
+	dev->checkpointCurrentBlock = -1;
+	dev->checkpointCurrentChunk = -1;
+	dev->checkpointNextBlock = dev->internalStartBlock;
+
+	/* Erase all the blocks in the checkpoint area */
+	if (forWriting) {
+		memset(dev->checkpointBuffer, 0, dev->nDataBytesPerChunk);
+		dev->checkpointByteOffset = 0;
+		return yaffs_CheckpointErase(dev);
+	} else {
+		int i;
+		/* Set to a value that will kick off a read */
+		dev->checkpointByteOffset = dev->nDataBytesPerChunk;
+		/* A checkpoint block list of 1 checkpoint block per 16 block is (hopefully)
+		 * going to be way more than we need */
+		dev->blocksInCheckpoint = 0;
+		dev->checkpointMaxBlocks = (dev->internalEndBlock - dev->internalStartBlock)/16 + 2;
+		dev->checkpointBlockList = YMALLOC(sizeof(int) * dev->checkpointMaxBlocks);
+		if(!dev->checkpointBlockList)
+			return 0;
+
+		for (i = 0; i < dev->checkpointMaxBlocks; i++)
+			dev->checkpointBlockList[i] = -1;
+	}
+
+	return 1;
+}
+
+int yaffs_GetCheckpointSum(yaffs_Device *dev, __u32 *sum)
+{
+	__u32 compositeSum;
+	compositeSum =  (dev->checkpointSum << 8) | (dev->checkpointXor & 0xFF);
+	*sum = compositeSum;
+	return 1;
+}
+
+static int yaffs_CheckpointFlushBuffer(yaffs_Device *dev)
+{
+	int chunk;
+	int realignedChunk;
+
+	yaffs_ExtendedTags tags;
+
+	if (dev->checkpointCurrentBlock < 0) {
+		yaffs_CheckpointFindNextErasedBlock(dev);
+		dev->checkpointCurrentChunk = 0;
+	}
+
+	if (dev->checkpointCurrentBlock < 0)
+		return 0;
+
+	tags.chunkDeleted = 0;
+	tags.objectId = dev->checkpointNextBlock; /* Hint to next place to look */
+	tags.chunkId = dev->checkpointPageSequence + 1;
+	tags.sequenceNumber =  YAFFS_SEQUENCE_CHECKPOINT_DATA;
+	tags.byteCount = dev->nDataBytesPerChunk;
+	if (dev->checkpointCurrentChunk == 0) {
+		/* First chunk we write for the block? Set block state to
+		   checkpoint */
+		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, dev->checkpointCurrentBlock);
+		bi->blockState = YAFFS_BLOCK_STATE_CHECKPOINT;
+		dev->blocksInCheckpoint++;
+	}
+
+	chunk = dev->checkpointCurrentBlock * dev->nChunksPerBlock + dev->checkpointCurrentChunk;
+
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checkpoint wite buffer nand %d(%d:%d) objid %d chId %d" TENDSTR),
+		chunk, dev->checkpointCurrentBlock, dev->checkpointCurrentChunk, tags.objectId, tags.chunkId));
+
+	realignedChunk = chunk - dev->chunkOffset;
+
+	dev->nPageWrites++;
+
+	dev->writeChunkWithTagsToNAND(dev, realignedChunk,
+			dev->checkpointBuffer, &tags);
+	dev->checkpointByteOffset = 0;
+	dev->checkpointPageSequence++;
+	dev->checkpointCurrentChunk++;
+	if (dev->checkpointCurrentChunk >= dev->nChunksPerBlock) {
+		dev->checkpointCurrentChunk = 0;
+		dev->checkpointCurrentBlock = -1;
+	}
+	memset(dev->checkpointBuffer, 0, dev->nDataBytesPerChunk);
+
+	return 1;
+}
+
+
+int yaffs_CheckpointWrite(yaffs_Device *dev, const void *data, int nBytes)
+{
+	int i = 0;
+	int ok = 1;
+
+
+	__u8 * dataBytes = (__u8 *)data;
+
+
+
+	if (!dev->checkpointBuffer)
+		return 0;
+
+	if (!dev->checkpointOpenForWrite)
+		return -1;
+
+	while (i < nBytes && ok) {
+		dev->checkpointBuffer[dev->checkpointByteOffset] = *dataBytes;
+		dev->checkpointSum += *dataBytes;
+		dev->checkpointXor ^= *dataBytes;
+
+		dev->checkpointByteOffset++;
+		i++;
+		dataBytes++;
+		dev->checkpointByteCount++;
+
+
+		if (dev->checkpointByteOffset < 0 ||
+		   dev->checkpointByteOffset >= dev->nDataBytesPerChunk)
+			ok = yaffs_CheckpointFlushBuffer(dev);
+	}
+
+	return i;
+}
+
+int yaffs_CheckpointRead(yaffs_Device *dev, void *data, int nBytes)
+{
+	int i = 0;
+	int ok = 1;
+	yaffs_ExtendedTags tags;
+
+
+	int chunk;
+	int realignedChunk;
+
+	__u8 *dataBytes = (__u8 *)data;
+
+	if (!dev->checkpointBuffer)
+		return 0;
+
+	if (dev->checkpointOpenForWrite)
+		return -1;
+
+	while (i < nBytes && ok) {
+
+
+		if (dev->checkpointByteOffset < 0 ||
+			dev->checkpointByteOffset >= dev->nDataBytesPerChunk) {
+
+			if (dev->checkpointCurrentBlock < 0) {
+				yaffs_CheckpointFindNextCheckpointBlock(dev);
+				dev->checkpointCurrentChunk = 0;
+			}
+
+			if (dev->checkpointCurrentBlock < 0)
+				ok = 0;
+			else {
+				chunk = dev->checkpointCurrentBlock *
+					dev->nChunksPerBlock +
+					dev->checkpointCurrentChunk;
+
+				realignedChunk = chunk - dev->chunkOffset;
+				
+				dev->nPageReads++;
+
+				/* read in the next chunk */
+				/* printf("read checkpoint page %d\n",dev->checkpointPage); */
+				dev->readChunkWithTagsFromNAND(dev,
+						realignedChunk,
+						dev->checkpointBuffer,
+						&tags);
+
+				if (tags.chunkId != (dev->checkpointPageSequence + 1) ||
+					tags.eccResult > YAFFS_ECC_RESULT_FIXED ||
+					tags.sequenceNumber != YAFFS_SEQUENCE_CHECKPOINT_DATA)
+					ok = 0;
+
+				dev->checkpointByteOffset = 0;
+				dev->checkpointPageSequence++;
+				dev->checkpointCurrentChunk++;
+
+				if (dev->checkpointCurrentChunk >= dev->nChunksPerBlock)
+					dev->checkpointCurrentBlock = -1;
+			}
+		}
+
+		if (ok) {
+			*dataBytes = dev->checkpointBuffer[dev->checkpointByteOffset];
+			dev->checkpointSum += *dataBytes;
+			dev->checkpointXor ^= *dataBytes;
+			dev->checkpointByteOffset++;
+			i++;
+			dataBytes++;
+			dev->checkpointByteCount++;
+		}
+	}
+
+	return 	i;
+}
+
+int yaffs_CheckpointClose(yaffs_Device *dev)
+{
+
+	if (dev->checkpointOpenForWrite) {
+		if (dev->checkpointByteOffset != 0)
+			yaffs_CheckpointFlushBuffer(dev);
+	} else if(dev->checkpointBlockList){
+		int i;
+		for (i = 0; i < dev->blocksInCheckpoint && dev->checkpointBlockList[i] >= 0; i++) {
+			int blk = dev->checkpointBlockList[i];
+			yaffs_BlockInfo *bi = NULL;
+			if( dev->internalStartBlock <= blk && blk <= dev->internalEndBlock)
+				bi = yaffs_GetBlockInfo(dev, blk);
+			if (bi && bi->blockState == YAFFS_BLOCK_STATE_EMPTY)
+				bi->blockState = YAFFS_BLOCK_STATE_CHECKPOINT;
+			else {
+				/* Todo this looks odd... */
+			}
+		}
+		YFREE(dev->checkpointBlockList);
+		dev->checkpointBlockList = NULL;
+	}
+
+	dev->nFreeChunks -= dev->blocksInCheckpoint * dev->nChunksPerBlock;
+	dev->nErasedBlocks -= dev->blocksInCheckpoint;
+
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checkpoint byte count %d" TENDSTR),
+			dev->checkpointByteCount));
+
+	if (dev->checkpointBuffer) {
+		/* free the buffer */
+		YFREE(dev->checkpointBuffer);
+		dev->checkpointBuffer = NULL;
+		return 1;
+	} else
+		return 0;
+}
+
+int yaffs_CheckpointInvalidateStream(yaffs_Device *dev)
+{
+	/* Erase the checkpoint data */
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("checkpoint invalidate of %d blocks"TENDSTR),
+		dev->blocksInCheckpoint));
+
+	return yaffs_CheckpointErase(dev);
+}
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_checkptrw.h linux-2.6.29-spica/fs/yaffs2/yaffs_checkptrw.h
--- linux-2.6.29/fs/yaffs2/yaffs_checkptrw.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_checkptrw.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,35 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_CHECKPTRW_H__
+#define __YAFFS_CHECKPTRW_H__
+
+#include "yaffs_guts.h"
+
+int yaffs_CheckpointOpen(yaffs_Device *dev, int forWriting);
+
+int yaffs_CheckpointWrite(yaffs_Device *dev, const void *data, int nBytes);
+
+int yaffs_CheckpointRead(yaffs_Device *dev, void *data, int nBytes);
+
+int yaffs_GetCheckpointSum(yaffs_Device *dev, __u32 *sum);
+
+int yaffs_CheckpointClose(yaffs_Device *dev);
+
+int yaffs_CheckpointInvalidateStream(yaffs_Device *dev);
+
+
+#endif
+
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_ecc.c linux-2.6.29-spica/fs/yaffs2/yaffs_ecc.c
--- linux-2.6.29/fs/yaffs2/yaffs_ecc.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_ecc.c	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,326 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This code implements the ECC algorithm used in SmartMedia.
+ *
+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+ * The two unused bit are set to 1.
+ * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC
+ * blocks are used on a 512-byte NAND page.
+ *
+ */
+
+/* Table generated by gen-ecc.c
+ * Using a table means we do not have to calculate p1..p4 and p1'..p4'
+ * for each byte of data. These are instead provided in a table in bits7..2.
+ * Bit 0 of each entry indicates whether the entry has an odd or even parity, and therefore
+ * this bytes influence on the line parity.
+ */
+
+const char *yaffs_ecc_c_version =
+	"$Id$";
+
+#include "yportenv.h"
+
+#include "yaffs_ecc.h"
+
+static const unsigned char column_parity_table[] = {
+	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+};
+
+/* Count the bits in an unsigned char or a U32 */
+
+static int yaffs_CountBits(unsigned char x)
+{
+	int r = 0;
+	while (x) {
+		if (x & 1)
+			r++;
+		x >>= 1;
+	}
+	return r;
+}
+
+static int yaffs_CountBits32(unsigned x)
+{
+	int r = 0;
+	while (x) {
+		if (x & 1)
+			r++;
+		x >>= 1;
+	}
+	return r;
+}
+
+/* Calculate the ECC for a 256-byte block of data */
+void yaffs_ECCCalculate(const unsigned char *data, unsigned char *ecc)
+{
+	unsigned int i;
+
+	unsigned char col_parity = 0;
+	unsigned char line_parity = 0;
+	unsigned char line_parity_prime = 0;
+	unsigned char t;
+	unsigned char b;
+
+	for (i = 0; i < 256; i++) {
+		b = column_parity_table[*data++];
+		col_parity ^= b;
+
+		if (b & 0x01) {		/* odd number of bits in the byte */
+			line_parity ^= i;
+			line_parity_prime ^= ~i;
+		}
+	}
+
+	ecc[2] = (~col_parity) | 0x03;
+
+	t = 0;
+	if (line_parity & 0x80)
+		t |= 0x80;
+	if (line_parity_prime & 0x80)
+		t |= 0x40;
+	if (line_parity & 0x40)
+		t |= 0x20;
+	if (line_parity_prime & 0x40)
+		t |= 0x10;
+	if (line_parity & 0x20)
+		t |= 0x08;
+	if (line_parity_prime & 0x20)
+		t |= 0x04;
+	if (line_parity & 0x10)
+		t |= 0x02;
+	if (line_parity_prime & 0x10)
+		t |= 0x01;
+	ecc[1] = ~t;
+
+	t = 0;
+	if (line_parity & 0x08)
+		t |= 0x80;
+	if (line_parity_prime & 0x08)
+		t |= 0x40;
+	if (line_parity & 0x04)
+		t |= 0x20;
+	if (line_parity_prime & 0x04)
+		t |= 0x10;
+	if (line_parity & 0x02)
+		t |= 0x08;
+	if (line_parity_prime & 0x02)
+		t |= 0x04;
+	if (line_parity & 0x01)
+		t |= 0x02;
+	if (line_parity_prime & 0x01)
+		t |= 0x01;
+	ecc[0] = ~t;
+
+#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER
+	/* Swap the bytes into the wrong order */
+	t = ecc[0];
+	ecc[0] = ecc[1];
+	ecc[1] = t;
+#endif
+}
+
+
+/* Correct the ECC on a 256 byte block of data */
+
+int yaffs_ECCCorrect(unsigned char *data, unsigned char *read_ecc,
+		     const unsigned char *test_ecc)
+{
+	unsigned char d0, d1, d2;	/* deltas */
+
+	d0 = read_ecc[0] ^ test_ecc[0];
+	d1 = read_ecc[1] ^ test_ecc[1];
+	d2 = read_ecc[2] ^ test_ecc[2];
+
+	if ((d0 | d1 | d2) == 0)
+		return 0; /* no error */
+
+	if (((d0 ^ (d0 >> 1)) & 0x55) == 0x55 &&
+	    ((d1 ^ (d1 >> 1)) & 0x55) == 0x55 &&
+	    ((d2 ^ (d2 >> 1)) & 0x54) == 0x54) {
+		/* Single bit (recoverable) error in data */
+
+		unsigned byte;
+		unsigned bit;
+
+#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER
+		/* swap the bytes to correct for the wrong order */
+		unsigned char t;
+
+		t = d0;
+		d0 = d1;
+		d1 = t;
+#endif
+
+		bit = byte = 0;
+
+		if (d1 & 0x80)
+			byte |= 0x80;
+		if (d1 & 0x20)
+			byte |= 0x40;
+		if (d1 & 0x08)
+			byte |= 0x20;
+		if (d1 & 0x02)
+			byte |= 0x10;
+		if (d0 & 0x80)
+			byte |= 0x08;
+		if (d0 & 0x20)
+			byte |= 0x04;
+		if (d0 & 0x08)
+			byte |= 0x02;
+		if (d0 & 0x02)
+			byte |= 0x01;
+
+		if (d2 & 0x80)
+			bit |= 0x04;
+		if (d2 & 0x20)
+			bit |= 0x02;
+		if (d2 & 0x08)
+			bit |= 0x01;
+
+		data[byte] ^= (1 << bit);
+
+		return 1; /* Corrected the error */
+	}
+
+	if ((yaffs_CountBits(d0) +
+	     yaffs_CountBits(d1) +
+	     yaffs_CountBits(d2)) ==  1) {
+		/* Reccoverable error in ecc */
+
+		read_ecc[0] = test_ecc[0];
+		read_ecc[1] = test_ecc[1];
+		read_ecc[2] = test_ecc[2];
+
+		return 1; /* Corrected the error */
+	}
+
+	/* Unrecoverable error */
+
+	return -1;
+
+}
+
+
+/*
+ * ECCxxxOther does ECC calcs on arbitrary n bytes of data
+ */
+void yaffs_ECCCalculateOther(const unsigned char *data, unsigned nBytes,
+				yaffs_ECCOther *eccOther)
+{
+	unsigned int i;
+
+	unsigned char col_parity = 0;
+	unsigned line_parity = 0;
+	unsigned line_parity_prime = 0;
+	unsigned char b;
+
+	for (i = 0; i < nBytes; i++) {
+		b = column_parity_table[*data++];
+		col_parity ^= b;
+
+		if (b & 0x01)	 {
+			/* odd number of bits in the byte */
+			line_parity ^= i;
+			line_parity_prime ^= ~i;
+		}
+
+	}
+
+	eccOther->colParity = (col_parity >> 2) & 0x3f;
+	eccOther->lineParity = line_parity;
+	eccOther->lineParityPrime = line_parity_prime;
+}
+
+int yaffs_ECCCorrectOther(unsigned char *data, unsigned nBytes,
+			yaffs_ECCOther *read_ecc,
+			const yaffs_ECCOther *test_ecc)
+{
+	unsigned char cDelta;	/* column parity delta */
+	unsigned lDelta;	/* line parity delta */
+	unsigned lDeltaPrime;	/* line parity delta */
+	unsigned bit;
+
+	cDelta = read_ecc->colParity ^ test_ecc->colParity;
+	lDelta = read_ecc->lineParity ^ test_ecc->lineParity;
+	lDeltaPrime = read_ecc->lineParityPrime ^ test_ecc->lineParityPrime;
+
+	if ((cDelta | lDelta | lDeltaPrime) == 0)
+		return 0; /* no error */
+
+	if (lDelta == ~lDeltaPrime &&
+	    (((cDelta ^ (cDelta >> 1)) & 0x15) == 0x15)) {
+		/* Single bit (recoverable) error in data */
+
+		bit = 0;
+
+		if (cDelta & 0x20)
+			bit |= 0x04;
+		if (cDelta & 0x08)
+			bit |= 0x02;
+		if (cDelta & 0x02)
+			bit |= 0x01;
+
+		if (lDelta >= nBytes)
+			return -1;
+
+		data[lDelta] ^= (1 << bit);
+
+		return 1; /* corrected */
+	}
+
+	if ((yaffs_CountBits32(lDelta) + yaffs_CountBits32(lDeltaPrime) +
+			yaffs_CountBits(cDelta)) == 1) {
+		/* Reccoverable error in ecc */
+
+		*read_ecc = *test_ecc;
+		return 1; /* corrected */
+	}
+
+	/* Unrecoverable error */
+
+	return -1;
+}
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_ecc.h linux-2.6.29-spica/fs/yaffs2/yaffs_ecc.h
--- linux-2.6.29/fs/yaffs2/yaffs_ecc.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_ecc.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,44 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * This code implements the ECC algorithm used in SmartMedia.
+ *
+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+ * The two unused bit are set to 1.
+ * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC
+ * blocks are used on a 512-byte NAND page.
+ *
+ */
+
+#ifndef __YAFFS_ECC_H__
+#define __YAFFS_ECC_H__
+
+typedef struct {
+	unsigned char colParity;
+	unsigned lineParity;
+	unsigned lineParityPrime;
+} yaffs_ECCOther;
+
+void yaffs_ECCCalculate(const unsigned char *data, unsigned char *ecc);
+int yaffs_ECCCorrect(unsigned char *data, unsigned char *read_ecc,
+		const unsigned char *test_ecc);
+
+void yaffs_ECCCalculateOther(const unsigned char *data, unsigned nBytes,
+			yaffs_ECCOther *ecc);
+int yaffs_ECCCorrectOther(unsigned char *data, unsigned nBytes,
+			yaffs_ECCOther *read_ecc,
+			const yaffs_ECCOther *test_ecc);
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_fs.c linux-2.6.29-spica/fs/yaffs2/yaffs_fs.c
--- linux-2.6.29/fs/yaffs2/yaffs_fs.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_fs.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,2699 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2009 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ * Acknowledgements:
+ * Luc van OostenRyck for numerous patches.
+ * Nick Bane for numerous patches.
+ * Nick Bane for 2.5/2.6 integration.
+ * Andras Toth for mknod rdev issue.
+ * Michael Fischer for finding the problem with inode inconsistency.
+ * Some code bodily lifted from JFFS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ *
+ * This is the file system front-end to YAFFS that hooks it up to
+ * the VFS.
+ *
+ * Special notes:
+ * >> 2.4: sb->u.generic_sbp points to the yaffs_Device associated with
+ *         this superblock
+ * >> 2.6: sb->s_fs_info  points to the yaffs_Device associated with this
+ *         superblock
+ * >> inode->u.generic_ip points to the associated yaffs_Object.
+ */
+
+const char *yaffs_fs_c_version =
+    "$Id$";
+extern const char *yaffs_guts_c_version;
+
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/pagemap.h>
+#include <linux/mtd/mtd.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+
+#include "asm/div64.h"
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+#include <linux/statfs.h>	/* Added NCB 15-8-2003 */
+#include <linux/statfs.h>
+#define UnlockPage(p) unlock_page(p)
+#define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
+
+/* FIXME: use sb->s_id instead ? */
+#define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
+
+#else
+
+#include <linux/locks.h>
+#define	BDEVNAME_SIZE		0
+#define	yaffs_devname(sb, buf)	kdevname(sb->s_dev)
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0))
+/* added NCB 26/5/2006 for 2.4.25-vrs2-tcl1 kernel */
+#define __user
+#endif
+
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define YPROC_ROOT  (&proc_root)
+#else
+#define YPROC_ROOT  NULL
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+#define WRITE_SIZE_STR "writesize"
+#define WRITE_SIZE(mtd) ((mtd)->writesize)
+#else
+#define WRITE_SIZE_STR "oobblock"
+#define WRITE_SIZE(mtd) ((mtd)->oobblock)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+#define YAFFS_USE_WRITE_BEGIN_END 1
+#else
+#define YAFFS_USE_WRITE_BEGIN_END 0
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 28))
+static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+{
+	uint64_t result = partition_size;
+	do_div(result, block_size);
+	return (uint32_t)result;
+}
+#else
+#define YCALCBLOCKS(s, b) ((s)/(b))
+#endif
+
+#include <linux/uaccess.h>
+
+#include "yportenv.h"
+#include "yaffs_guts.h"
+
+#include <linux/mtd/mtd.h>
+#include "yaffs_mtdif.h"
+#include "yaffs_mtdif1.h"
+#include "yaffs_mtdif2.h"
+
+unsigned int yaffs_traceMask = YAFFS_TRACE_BAD_BLOCKS;
+unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;
+unsigned int yaffs_auto_checkpoint = 1;
+
+/* Module Parameters */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+module_param(yaffs_traceMask, uint, 0644);
+module_param(yaffs_wr_attempts, uint, 0644);
+module_param(yaffs_auto_checkpoint, uint, 0644);
+#else
+MODULE_PARM(yaffs_traceMask, "i");
+MODULE_PARM(yaffs_wr_attempts, "i");
+MODULE_PARM(yaffs_auto_checkpoint, "i");
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+/* use iget and read_inode */
+#define Y_IGET(sb, inum) iget((sb), (inum))
+static void yaffs_read_inode(struct inode *inode);
+
+#else
+/* Call local equivalent */
+#define YAFFS_USE_OWN_IGET
+#define Y_IGET(sb, inum) yaffs_iget((sb), (inum))
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino);
+#endif
+
+/*#define T(x) printk x */
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+#define yaffs_InodeToObjectLV(iptr) ((iptr)->i_private)
+#else
+#define yaffs_InodeToObjectLV(iptr) ((iptr)->u.generic_ip)
+#endif
+
+#define yaffs_InodeToObject(iptr) ((yaffs_Object *)(yaffs_InodeToObjectLV(iptr)))
+#define yaffs_DentryToObject(dptr) yaffs_InodeToObject((dptr)->d_inode)
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define yaffs_SuperToDevice(sb)	((yaffs_Device *)sb->s_fs_info)
+#else
+#define yaffs_SuperToDevice(sb)	((yaffs_Device *)sb->u.generic_sbp)
+#endif
+
+
+#define update_dir_time(dir) do {\
+			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
+		} while(0)
+		
+static void yaffs_put_super(struct super_block *sb);
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t *pos);
+static ssize_t yaffs_hold_space(struct file *f);
+static void yaffs_release_space(struct file *f);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id);
+#else
+static int yaffs_file_flush(struct file *file);
+#endif
+
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+				int datasync);
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+					struct nameidata *n);
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry);
+#endif
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+			struct dentry *dentry);
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry);
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			const char *symname);
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			dev_t dev);
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			int dev);
+#endif
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry);
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait);
+static void yaffs_write_super(struct super_block *sb);
+#else
+static int yaffs_sync_fs(struct super_block *sb);
+static int yaffs_write_super(struct super_block *sb);
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf);
+#endif
+
+#ifdef YAFFS_HAS_PUT_INODE
+static void yaffs_put_inode(struct inode *inode);
+#endif
+
+static void yaffs_delete_inode(struct inode *);
+static void yaffs_clear_inode(struct inode *);
+
+static int yaffs_readpage(struct file *file, struct page *page);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc);
+#else
+static int yaffs_writepage(struct page *page);
+#endif
+
+
+#if (YAFFS_USE_WRITE_BEGIN_END != 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned flags,
+				struct page **pagep, void **fsdata);
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned copied,
+				struct page *pg, void *fsdadata);
+#else
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+				unsigned offset, unsigned to);
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+				unsigned to);
+
+#endif
+
+static int yaffs_readlink(struct dentry *dentry, char __user *buffer,
+				int buflen);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#endif
+
+static struct address_space_operations yaffs_file_address_operations = {
+	.readpage = yaffs_readpage,
+	.writepage = yaffs_writepage,
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+#else
+	.prepare_write = yaffs_prepare_write,
+	.commit_write = yaffs_commit_write,
+#endif
+};
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.splice_read = generic_file_splice_read,
+	.splice_write = generic_file_splice_write,
+	.llseek = generic_file_llseek,
+};
+
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.sendfile = generic_file_sendfile,
+};
+
+#else
+
+static const struct file_operations yaffs_file_operations = {
+	.read = generic_file_read,
+	.write = generic_file_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	.sendfile = generic_file_sendfile,
+#endif
+};
+#endif
+
+static const struct inode_operations yaffs_file_inode_operations = {
+	.setattr = yaffs_setattr,
+};
+
+static const struct inode_operations yaffs_symlink_inode_operations = {
+	.readlink = yaffs_readlink,
+	.follow_link = yaffs_follow_link,
+	.setattr = yaffs_setattr,
+};
+
+static const struct inode_operations yaffs_dir_inode_operations = {
+	.create = yaffs_create,
+	.lookup = yaffs_lookup,
+	.link = yaffs_link,
+	.unlink = yaffs_unlink,
+	.symlink = yaffs_symlink,
+	.mkdir = yaffs_mkdir,
+	.rmdir = yaffs_unlink,
+	.mknod = yaffs_mknod,
+	.rename = yaffs_rename,
+	.setattr = yaffs_setattr,
+};
+
+static const struct file_operations yaffs_dir_operations = {
+	.read = generic_read_dir,
+	.readdir = yaffs_readdir,
+	.fsync = yaffs_sync_object,
+};
+
+static const struct super_operations yaffs_super_ops = {
+	.statfs = yaffs_statfs,
+
+#ifndef YAFFS_USE_OWN_IGET
+	.read_inode = yaffs_read_inode,
+#endif
+#ifdef YAFFS_HAS_PUT_INODE
+	.put_inode = yaffs_put_inode,
+#endif
+	.put_super = yaffs_put_super,
+	.delete_inode = yaffs_delete_inode,
+	.clear_inode = yaffs_clear_inode,
+	.sync_fs = yaffs_sync_fs,
+	.write_super = yaffs_write_super,
+};
+
+static void yaffs_GrossLock(yaffs_Device *dev)
+{
+	T(YAFFS_TRACE_OS, ("yaffs locking %p\n", current));
+	down(&dev->grossLock);
+	T(YAFFS_TRACE_OS, ("yaffs locked %p\n", current));
+}
+
+static void yaffs_GrossUnlock(yaffs_Device *dev)
+{
+	T(YAFFS_TRACE_OS, ("yaffs unlocking %p\n", current));
+	up(&dev->grossLock);
+}
+
+
+/*-----------------------------------------------------------------*/
+/* Directory search context allows us to unlock access to yaffs during
+ * filldir without causing problems with the directory being modified.
+ * This is similar to the tried and tested mechanism used in yaffs direct.
+ *
+ * A search context iterates along a doubly linked list of siblings in the
+ * directory. If the iterating object is deleted then this would corrupt
+ * the list iteration, likely causing a crash. The search context avoids
+ * this by using the removeObjectCallback to move the search context to the
+ * next object before the object is deleted.
+ *
+ * Many readdirs (and thus seach conexts) may be alive simulateously so
+ * each yaffs_Device has a list of these.
+ *
+ * A seach context lives for the duration of a readdir.
+ *
+ * All these functions must be called while yaffs is locked.
+ */
+
+struct yaffs_SearchContext {
+	yaffs_Device *dev;
+	yaffs_Object *dirObj;
+	yaffs_Object *nextReturn;
+	struct ylist_head others;
+};
+
+/*
+ * yaffs_NewSearch() creates a new search context, initialises it and
+ * adds it to the device's search context list.
+ *
+ * Called at start of readdir.
+ */
+static struct yaffs_SearchContext * yaffs_NewSearch(yaffs_Object *dir)
+{
+	yaffs_Device *dev = dir->myDev;
+	struct yaffs_SearchContext *sc = YMALLOC(sizeof(struct yaffs_SearchContext));
+	if(sc){
+		sc->dirObj = dir;
+		sc->dev = dev;
+		if( ylist_empty(&sc->dirObj->variant.directoryVariant.children))
+			sc->nextReturn = NULL;
+		else
+			sc->nextReturn = ylist_entry(
+                                dir->variant.directoryVariant.children.next,
+				yaffs_Object,siblings);
+		YINIT_LIST_HEAD(&sc->others);
+		ylist_add(&sc->others,&dev->searchContexts);
+	}
+	return sc;
+}
+
+/*
+ * yaffs_EndSearch() disposes of a search context and cleans up.
+ */
+static void yaffs_EndSearch(struct yaffs_SearchContext * sc)
+{
+	if(sc){
+		ylist_del(&sc->others);
+		YFREE(sc);
+	}
+}
+
+/*
+ * yaffs_SearchAdvance() moves a search context to the next object.
+ * Called when the search iterates or when an object removal causes
+ * the search context to be moved to the next object.
+ */
+static void yaffs_SearchAdvance(struct yaffs_SearchContext *sc)
+{
+        if(!sc)
+                return;
+
+        if( sc->nextReturn == NULL ||
+                ylist_empty(&sc->dirObj->variant.directoryVariant.children))
+                sc->nextReturn = NULL;
+        else {
+                struct ylist_head *next = sc->nextReturn->siblings.next;
+
+                if( next == &sc->dirObj->variant.directoryVariant.children)
+                        sc->nextReturn = NULL; /* end of list */
+                else
+                        sc->nextReturn = ylist_entry(next,yaffs_Object,siblings);
+        }
+}
+
+/*
+ * yaffs_RemoveObjectCallback() is called when an object is unlinked.
+ * We check open search contexts and advance any which are currently
+ * on the object being iterated.
+ */
+static void yaffs_RemoveObjectCallback(yaffs_Object *obj)
+{
+
+        struct ylist_head *i;
+        struct yaffs_SearchContext *sc;
+        struct ylist_head *search_contexts = &obj->myDev->searchContexts;
+
+
+        /* Iterate through the directory search contexts.
+         * If any are currently on the object being removed, then advance
+         * the search context to the next object to prevent a hanging pointer.
+         */
+         ylist_for_each(i, search_contexts) {
+                if (i) {
+                        sc = ylist_entry(i, struct yaffs_SearchContext,others);
+                        if(sc->nextReturn == obj)
+                                yaffs_SearchAdvance(sc);
+                }
+	}
+
+}
+
+
+/*-----------------------------------------------------------------*/
+
+static int yaffs_readlink(struct dentry *dentry, char __user *buffer,
+			int buflen)
+{
+	unsigned char *alias;
+	int ret;
+
+	yaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;
+
+	yaffs_GrossLock(dev);
+
+	alias = yaffs_GetSymlinkAlias(yaffs_DentryToObject(dentry));
+
+	yaffs_GrossUnlock(dev);
+
+	if (!alias)
+		return -ENOMEM;
+
+	ret = vfs_readlink(dentry, buffer, buflen, alias);
+	kfree(alias);
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+#endif
+{
+	unsigned char *alias;
+	int ret;
+	yaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;
+
+	yaffs_GrossLock(dev);
+
+	alias = yaffs_GetSymlinkAlias(yaffs_DentryToObject(dentry));
+
+	yaffs_GrossUnlock(dev);
+
+	if (!alias) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = vfs_follow_link(nd, alias);
+	kfree(alias);
+out:
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+	return ERR_PTR(ret);
+#else
+	return ret;
+#endif
+}
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+				yaffs_Object *obj);
+
+/*
+ * Lookup is used to find objects in the fs
+ */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				struct nameidata *n)
+#else
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
+#endif
+{
+	yaffs_Object *obj;
+	struct inode *inode = NULL;	/* NCB 2.5/2.6 needs NULL here */
+
+	yaffs_Device *dev = yaffs_InodeToObject(dir)->myDev;
+
+	yaffs_GrossLock(dev);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_lookup for %d:%s\n",
+		yaffs_InodeToObject(dir)->objectId, dentry->d_name.name));
+
+	obj = yaffs_FindObjectByName(yaffs_InodeToObject(dir),
+					dentry->d_name.name);
+
+	obj = yaffs_GetEquivalentObject(obj);	/* in case it was a hardlink */
+
+	/* Can't hold gross lock when calling yaffs_get_inode() */
+	yaffs_GrossUnlock(dev);
+
+	if (obj) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_lookup found %d\n", obj->objectId));
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+
+		if (inode) {
+			T(YAFFS_TRACE_OS,
+				("yaffs_loookup dentry \n"));
+/* #if 0 asserted by NCB for 2.5/6 compatability - falls through to
+ * d_add even if NULL inode */
+#if 0
+			/*dget(dentry); // try to solve directory bug */
+			d_add(dentry, inode);
+
+			/* return dentry; */
+			return NULL;
+#endif
+		}
+
+	} else {
+		T(YAFFS_TRACE_OS, ("yaffs_lookup not found\n"));
+
+	}
+
+/* added NCB for 2.5/6 compatability - forces add even if inode is
+ * NULL which creates dentry hash */
+	d_add(dentry, inode);
+
+	return NULL;
+}
+
+
+#ifdef YAFFS_HAS_PUT_INODE
+
+/* For now put inode is just for debugging
+ * Put inode is called when the inode **structure** is put.
+ */
+static void yaffs_put_inode(struct inode *inode)
+{
+	T(YAFFS_TRACE_OS,
+		("yaffs_put_inode: ino %d, count %d\n", (int)inode->i_ino,
+		atomic_read(&inode->i_count)));
+
+}
+#endif
+
+/* clear is called to tell the fs to release any per-inode data it holds */
+static void yaffs_clear_inode(struct inode *inode)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+
+	obj = yaffs_InodeToObject(inode);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_clear_inode: ino %d, count %d %s\n", (int)inode->i_ino,
+		atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object"));
+
+	if (obj) {
+		dev = obj->myDev;
+		yaffs_GrossLock(dev);
+
+		/* Clear the association between the inode and
+		 * the yaffs_Object.
+		 */
+		obj->myInode = NULL;
+		yaffs_InodeToObjectLV(inode) = NULL;
+
+		/* If the object freeing was deferred, then the real
+		 * free happens now.
+		 * This should fix the inode inconsistency problem.
+		 */
+
+		yaffs_HandleDeferedFree(obj);
+
+		yaffs_GrossUnlock(dev);
+	}
+
+}
+
+/* delete is called when the link count is zero and the inode
+ * is put (ie. nobody wants to know about it anymore, time to
+ * delete the file).
+ * NB Must call clear_inode()
+ */
+static void yaffs_delete_inode(struct inode *inode)
+{
+	yaffs_Object *obj = yaffs_InodeToObject(inode);
+	yaffs_Device *dev;
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_delete_inode: ino %d, count %d %s\n", (int)inode->i_ino,
+		atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object"));
+
+	if (obj) {
+		dev = obj->myDev;
+		yaffs_GrossLock(dev);
+		yaffs_DeleteObject(obj);
+		yaffs_GrossUnlock(dev);
+	}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+	truncate_inode_pages(&inode->i_data, 0);
+#endif
+	clear_inode(inode);
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id)
+#else
+static int yaffs_file_flush(struct file *file)
+#endif
+{
+	yaffs_Object *obj = yaffs_DentryToObject(file->f_dentry);
+
+	yaffs_Device *dev = obj->myDev;
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_file_flush object %d (%s)\n", obj->objectId,
+		obj->dirty ? "dirty" : "clean"));
+
+	yaffs_GrossLock(dev);
+
+	yaffs_FlushFile(obj, 1);
+
+	yaffs_GrossUnlock(dev);
+
+	return 0;
+}
+
+static int yaffs_readpage_nolock(struct file *f, struct page *pg)
+{
+	/* Lifted from jffs2 */
+
+	yaffs_Object *obj;
+	unsigned char *pg_buf;
+	int ret;
+
+	yaffs_Device *dev;
+
+	T(YAFFS_TRACE_OS, ("yaffs_readpage at %08x, size %08x\n",
+			(unsigned)(pg->index << PAGE_CACHE_SHIFT),
+			(unsigned)PAGE_CACHE_SIZE));
+
+	obj = yaffs_DentryToObject(f->f_dentry);
+
+	dev = obj->myDev;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	BUG_ON(!PageLocked(pg));
+#else
+	if (!PageLocked(pg))
+		PAGE_BUG(pg);
+#endif
+
+	pg_buf = kmap(pg);
+	/* FIXME: Can kmap fail? */
+
+	yaffs_GrossLock(dev);
+
+	ret = yaffs_ReadDataFromFile(obj, pg_buf,
+				pg->index << PAGE_CACHE_SHIFT,
+				PAGE_CACHE_SIZE);
+
+	yaffs_GrossUnlock(dev);
+
+	if (ret >= 0)
+		ret = 0;
+
+	if (ret) {
+		ClearPageUptodate(pg);
+		SetPageError(pg);
+	} else {
+		SetPageUptodate(pg);
+		ClearPageError(pg);
+	}
+
+	flush_dcache_page(pg);
+	kunmap(pg);
+
+	T(YAFFS_TRACE_OS, ("yaffs_readpage done\n"));
+	return ret;
+}
+
+static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+{
+	int ret = yaffs_readpage_nolock(f, pg);
+	UnlockPage(pg);
+	return ret;
+}
+
+static int yaffs_readpage(struct file *f, struct page *pg)
+{
+	return yaffs_readpage_unlock(f, pg);
+}
+
+/* writepage inspired by/stolen from smbfs */
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+#else
+static int yaffs_writepage(struct page *page)
+#endif
+{
+	struct address_space *mapping = page->mapping;
+	loff_t offset = (loff_t) page->index << PAGE_CACHE_SHIFT;
+	struct inode *inode;
+	unsigned long end_index;
+	char *buffer;
+	yaffs_Object *obj;
+	int nWritten = 0;
+	unsigned nBytes;
+
+	if (!mapping)
+		BUG();
+	inode = mapping->host;
+	if (!inode)
+		BUG();
+
+	if (offset > inode->i_size) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_writepage at %08x, inode size = %08x!!!\n",
+			(unsigned)(page->index << PAGE_CACHE_SHIFT),
+			(unsigned)inode->i_size));
+		T(YAFFS_TRACE_OS,
+			("                -> don't care!!\n"));
+		unlock_page(page);
+		return 0;
+	}
+
+	end_index = inode->i_size >> PAGE_CACHE_SHIFT;
+
+	/* easy case */
+	if (page->index < end_index)
+		nBytes = PAGE_CACHE_SIZE;
+	else
+		nBytes = inode->i_size & (PAGE_CACHE_SIZE - 1);
+
+	get_page(page);
+
+	buffer = kmap(page);
+
+	obj = yaffs_InodeToObject(inode);
+	yaffs_GrossLock(obj->myDev);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_writepage at %08x, size %08x\n",
+		(unsigned)(page->index << PAGE_CACHE_SHIFT), nBytes));
+	T(YAFFS_TRACE_OS,
+		("writepag0: obj = %05x, ino = %05x\n",
+		(int)obj->variant.fileVariant.fileSize, (int)inode->i_size));
+
+	nWritten = yaffs_WriteDataToFile(obj, buffer,
+			page->index << PAGE_CACHE_SHIFT, nBytes, 0);
+
+	T(YAFFS_TRACE_OS,
+		("writepag1: obj = %05x, ino = %05x\n",
+		(int)obj->variant.fileVariant.fileSize, (int)inode->i_size));
+
+	yaffs_GrossUnlock(obj->myDev);
+
+	kunmap(page);
+	SetPageUptodate(page);
+	UnlockPage(page);
+	put_page(page);
+
+	return (nWritten == nBytes) ? 0 : -ENOSPC;
+}
+
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned flags,
+				struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+	uint32_t offset = pos & (PAGE_CACHE_SIZE - 1);
+	uint32_t to = offset + len;
+
+	int ret = 0;
+	int space_held = 0;
+
+	T(YAFFS_TRACE_OS, ("start yaffs_write_begin\n"));
+	/* Get a page */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 28)
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+#else
+	pg = __grab_cache_page(mapping, index);
+#endif
+
+	*pagep = pg;
+	if (!pg) {
+		ret =  -ENOMEM;
+		goto out;
+	}
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
+
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
+	}
+
+	/* Update page if required */
+
+	if (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))
+		ret = yaffs_readpage_nolock(filp, pg);
+
+	if (ret)
+		goto out;
+
+	/* Happy path return */
+	T(YAFFS_TRACE_OS, ("end yaffs_write_begin - ok\n"));
+
+	return 0;
+
+out:
+	T(YAFFS_TRACE_OS, ("end yaffs_write_begin fail returning %d\n", ret));
+	if (space_held)
+		yaffs_release_space(filp);
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+#else
+
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+				unsigned offset, unsigned to)
+{
+	T(YAFFS_TRACE_OS, ("yaffs_prepair_write\n"));
+
+	if (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))
+		return yaffs_readpage_nolock(f, pg);
+	return 0;
+}
+#endif
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned copied,
+				struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_write_end addr %x pos %x nBytes %d\n",
+		(unsigned) addr,
+		(int)pos, copied));
+
+	ret = yaffs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_write_end not same size ret %d  copied %d\n",
+			ret, copied));
+		SetPageError(pg);
+		ClearPageUptodate(pg);
+	} else {
+		SetPageUptodate(pg);
+	}
+
+	kunmap(pg);
+
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
+
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+				unsigned to)
+{
+	void *addr, *kva;
+
+	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
+	int nBytes = to - offset;
+	int nWritten;
+
+	unsigned spos = pos;
+	unsigned saddr;
+
+	kva = kmap(pg);
+	addr = kva + offset;
+
+	saddr = (unsigned) addr;
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_commit_write addr %x pos %x nBytes %d\n",
+		saddr, spos, nBytes));
+
+	nWritten = yaffs_file_write(f, addr, nBytes, &pos);
+
+	if (nWritten != nBytes) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_commit_write not same size nWritten %d  nBytes %d\n",
+			nWritten, nBytes));
+		SetPageError(pg);
+		ClearPageUptodate(pg);
+	} else {
+		SetPageUptodate(pg);
+	}
+
+	kunmap(pg);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_commit_write returning %d\n",
+		nWritten == nBytes ? 0 : nWritten));
+
+	return nWritten == nBytes ? 0 : nWritten;
+}
+#endif
+
+
+static void yaffs_FillInodeFromObject(struct inode *inode, yaffs_Object *obj)
+{
+	if (inode && obj) {
+
+
+		/* Check mode against the variant type and attempt to repair if broken. */
+		__u32 mode = obj->yst_mode;
+		switch (obj->variantType) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			if (!S_ISREG(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFREG;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			if (!S_ISLNK(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFLNK;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			if (!S_ISDIR(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFDIR;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+		default:
+			/* TODO? */
+			break;
+		}
+
+		inode->i_flags |= S_NOATIME;
+
+		inode->i_ino = obj->objectId;
+		inode->i_mode = obj->yst_mode;
+		inode->i_uid = obj->yst_uid;
+		inode->i_gid = obj->yst_gid;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+		inode->i_blksize = inode->i_sb->s_blocksize;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+		inode->i_rdev = old_decode_dev(obj->yst_rdev);
+		inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
+		inode->i_atime.tv_nsec = 0;
+		inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
+		inode->i_mtime.tv_nsec = 0;
+		inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
+		inode->i_ctime.tv_nsec = 0;
+#else
+		inode->i_rdev = obj->yst_rdev;
+		inode->i_atime = obj->yst_atime;
+		inode->i_mtime = obj->yst_mtime;
+		inode->i_ctime = obj->yst_ctime;
+#endif
+		inode->i_size = yaffs_GetObjectFileLength(obj);
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+
+		inode->i_nlink = yaffs_GetObjectLinkCount(obj);
+
+		T(YAFFS_TRACE_OS,
+			("yaffs_FillInode mode %x uid %d gid %d size %d count %d\n",
+			inode->i_mode, inode->i_uid, inode->i_gid,
+			(int)inode->i_size, atomic_read(&inode->i_count)));
+
+		switch (obj->yst_mode & S_IFMT) {
+		default:	/* fifo, device or socket */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+			init_special_inode(inode, obj->yst_mode,
+					old_decode_dev(obj->yst_rdev));
+#else
+			init_special_inode(inode, obj->yst_mode,
+					(dev_t) (obj->yst_rdev));
+#endif
+			break;
+		case S_IFREG:	/* file */
+			inode->i_op = &yaffs_file_inode_operations;
+			inode->i_fop = &yaffs_file_operations;
+			inode->i_mapping->a_ops =
+				&yaffs_file_address_operations;
+			break;
+		case S_IFDIR:	/* directory */
+			inode->i_op = &yaffs_dir_inode_operations;
+			inode->i_fop = &yaffs_dir_operations;
+			break;
+		case S_IFLNK:	/* symlink */
+			inode->i_op = &yaffs_symlink_inode_operations;
+			break;
+		}
+
+		yaffs_InodeToObjectLV(inode) = obj;
+
+		obj->myInode = inode;
+
+	} else {
+		T(YAFFS_TRACE_OS,
+			("yaffs_FileInode invalid parameters\n"));
+	}
+
+}
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+				yaffs_Object *obj)
+{
+	struct inode *inode;
+
+	if (!sb) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_get_inode for NULL super_block!!\n"));
+		return NULL;
+
+	}
+
+	if (!obj) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_get_inode for NULL object!!\n"));
+		return NULL;
+
+	}
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_get_inode for object %d\n", obj->objectId));
+
+	inode = Y_IGET(sb, obj->objectId);
+	if (IS_ERR(inode))
+		return NULL;
+
+	/* NB Side effect: iget calls back to yaffs_read_inode(). */
+	/* iget also increments the inode's i_count */
+	/* NB You can't be holding grossLock or deadlock will happen! */
+
+	return inode;
+}
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t *pos)
+{
+	yaffs_Object *obj;
+	int nWritten, ipos;
+	struct inode *inode;
+	yaffs_Device *dev;
+
+	obj = yaffs_DentryToObject(f->f_dentry);
+
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+	inode = f->f_dentry->d_inode;
+
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
+
+	if (!obj)
+		T(YAFFS_TRACE_OS,
+			("yaffs_file_write: hey obj is null!\n"));
+	else
+		T(YAFFS_TRACE_OS,
+			("yaffs_file_write about to write writing %zu bytes"
+			"to object %d at %d\n",
+			n, obj->objectId, ipos));
+
+	nWritten = yaffs_WriteDataToFile(obj, buf, ipos, n, 0);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_file_write writing %zu bytes, %d written at %d\n",
+		n, nWritten, ipos));
+
+	if (nWritten > 0) {
+		ipos += nWritten;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
+
+			T(YAFFS_TRACE_OS,
+				("yaffs_file_write size updated to %d bytes, "
+				"%d blocks\n",
+				ipos, (int)(inode->i_blocks)));
+		}
+
+	}
+	yaffs_GrossUnlock(dev);
+	return (nWritten == 0) && (n > 0) ? -ENOSPC : nWritten;
+}
+
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+static ssize_t yaffs_hold_space(struct file *f)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+
+	int nFreeChunks;
+
+
+	obj = yaffs_DentryToObject(f->f_dentry);
+
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+	nFreeChunks = yaffs_GetNumberOfFreeChunks(dev);
+
+	yaffs_GrossUnlock(dev);
+
+	return (nFreeChunks > 20) ? 1 : 0;
+}
+
+static void yaffs_release_space(struct file *f)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+
+
+	obj = yaffs_DentryToObject(f->f_dentry);
+
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+
+	yaffs_GrossUnlock(dev);
+}
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+        struct yaffs_SearchContext *sc;
+	struct inode *inode = f->f_dentry->d_inode;
+	unsigned long offset, curoffs;
+	yaffs_Object *l;
+        int retVal = 0;
+
+	char name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	obj = yaffs_DentryToObject(f->f_dentry);
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+	offset = f->f_pos;
+
+        sc = yaffs_NewSearch(obj);
+        if(!sc){
+                retVal = -ENOMEM;
+                goto unlock_out;
+        }
+
+	T(YAFFS_TRACE_OS, ("yaffs_readdir: starting at %d\n", (int)offset));
+
+	if (offset == 0) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_readdir: entry . ino %d \n",
+			(int)inode->i_ino));
+		yaffs_GrossUnlock(dev);
+		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR) < 0)
+			goto out;
+		yaffs_GrossLock(dev);
+		offset++;
+		f->f_pos++;
+	}
+	if (offset == 1) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_readdir: entry .. ino %d \n",
+			(int)f->f_dentry->d_parent->d_inode->i_ino));
+		yaffs_GrossUnlock(dev);
+		if (filldir(dirent, "..", 2, offset,
+			f->f_dentry->d_parent->d_inode->i_ino, DT_DIR) < 0)
+			goto out;
+		yaffs_GrossLock(dev);
+		offset++;
+		f->f_pos++;
+	}
+
+	curoffs = 1;
+
+	/* If the directory has changed since the open or last call to
+	   readdir, rewind to after the 2 canned entries. */
+
+	if (f->f_version != inode->i_version) {
+		offset = 2;
+		f->f_pos = offset;
+		f->f_version = inode->i_version;
+	}
+
+	while(sc->nextReturn){
+		curoffs++;
+                l = sc->nextReturn;
+		if (curoffs >= offset) {
+                        int this_inode = yaffs_GetObjectInode(l);
+                        int this_type = yaffs_GetObjectType(l);
+
+			yaffs_GetObjectName(l, name,
+					    YAFFS_MAX_NAME_LENGTH + 1);
+			T(YAFFS_TRACE_OS,
+			  ("yaffs_readdir: %s inode %d\n", name,
+			   yaffs_GetObjectInode(l)));
+
+                        yaffs_GrossUnlock(dev);
+
+			if (filldir(dirent,
+					name,
+					strlen(name),
+					offset,
+					this_inode,
+					this_type) < 0)
+				goto out;
+
+                        yaffs_GrossLock(dev);
+
+			offset++;
+			f->f_pos++;
+		}
+                yaffs_SearchAdvance(sc);
+	}
+
+unlock_out:
+	yaffs_GrossUnlock(dev);
+out:
+        yaffs_EndSearch(sc);
+
+	return retVal;
+}
+
+/*
+ * File creation. Allocate an inode, and we're done..
+ */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+#define YCRED(x) x
+#else
+#define YCRED(x) (x->cred)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			dev_t rdev)
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			int rdev)
+#endif
+{
+	struct inode *inode;
+
+	yaffs_Object *obj = NULL;
+	yaffs_Device *dev;
+
+	yaffs_Object *parent = yaffs_InodeToObject(dir);
+
+	int error = -ENOSPC;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+		mode |= S_ISGID;
+
+	if (parent) {
+		T(YAFFS_TRACE_OS,
+			("yaffs_mknod: parent object %d type %d\n",
+			parent->objectId, parent->variantType));
+	} else {
+		T(YAFFS_TRACE_OS,
+			("yaffs_mknod: could not get parent object\n"));
+		return -EPERM;
+	}
+
+	T(YAFFS_TRACE_OS, ("yaffs_mknod: making oject for %s, "
+			"mode %x dev %x\n",
+			dentry->d_name.name, mode, rdev));
+
+	dev = parent->myDev;
+
+	yaffs_GrossLock(dev);
+
+	switch (mode & S_IFMT) {
+	default:
+		/* Special (socket, fifo, device...) */
+		T(YAFFS_TRACE_OS, ("yaffs_mknod: making special\n"));
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+		obj = yaffs_MknodSpecial(parent, dentry->d_name.name, mode, uid,
+				gid, old_encode_dev(rdev));
+#else
+		obj = yaffs_MknodSpecial(parent, dentry->d_name.name, mode, uid,
+				gid, rdev);
+#endif
+		break;
+	case S_IFREG:		/* file          */
+		T(YAFFS_TRACE_OS, ("yaffs_mknod: making file\n"));
+		obj = yaffs_MknodFile(parent, dentry->d_name.name, mode, uid,
+				gid);
+		break;
+	case S_IFDIR:		/* directory */
+		T(YAFFS_TRACE_OS,
+			("yaffs_mknod: making directory\n"));
+		obj = yaffs_MknodDirectory(parent, dentry->d_name.name, mode,
+					uid, gid);
+		break;
+	case S_IFLNK:		/* symlink */
+		T(YAFFS_TRACE_OS, ("yaffs_mknod: making symlink\n"));
+		obj = NULL;	/* Do we ever get here? */
+		break;
+	}
+
+	/* Can not call yaffs_get_inode() with gross lock held */
+	yaffs_GrossUnlock(dev);
+
+	if (obj) {
+		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		T(YAFFS_TRACE_OS,
+			("yaffs_mknod created object %d count = %d\n",
+			obj->objectId, atomic_read(&inode->i_count)));
+		error = 0;
+	} else {
+		T(YAFFS_TRACE_OS,
+			("yaffs_mknod failed making object\n"));
+		error = -ENOMEM;
+	}
+
+	return error;
+}
+
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int retVal;
+	T(YAFFS_TRACE_OS, ("yaffs_mkdir\n"));
+	retVal = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	return retVal;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n)
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	T(YAFFS_TRACE_OS, ("yaffs_create\n"));
+	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+}
+
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int retVal;
+
+	yaffs_Device *dev;
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_unlink %d:%s\n", (int)(dir->i_ino),
+		dentry->d_name.name));
+
+	dev = yaffs_InodeToObject(dir)->myDev;
+
+	yaffs_GrossLock(dev);
+
+	retVal = yaffs_Unlink(yaffs_InodeToObject(dir), dentry->d_name.name);
+
+	if (retVal == YAFFS_OK) {
+		dentry->d_inode->i_nlink--;
+		dir->i_version++;
+		yaffs_GrossUnlock(dev);
+		mark_inode_dirty(dentry->d_inode);
+		update_dir_time(dir);
+		return 0;
+	}
+	yaffs_GrossUnlock(dev);
+	return -ENOTEMPTY;
+}
+
+/*
+ * Create a link...
+ */
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+			struct dentry *dentry)
+{
+	struct inode *inode = old_dentry->d_inode;
+	yaffs_Object *obj = NULL;
+	yaffs_Object *link = NULL;
+	yaffs_Device *dev;
+
+	T(YAFFS_TRACE_OS, ("yaffs_link\n"));
+
+	obj = yaffs_InodeToObject(inode);
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+	if (!S_ISDIR(inode->i_mode))		/* Don't link directories */
+		link = yaffs_Link(yaffs_InodeToObject(dir), dentry->d_name.name,
+			obj);
+
+	if (link) {
+		old_dentry->d_inode->i_nlink = yaffs_GetObjectLinkCount(obj);
+		d_instantiate(dentry, old_dentry->d_inode);
+		atomic_inc(&old_dentry->d_inode->i_count);
+		T(YAFFS_TRACE_OS,
+			("yaffs_link link count %d i_count %d\n",
+			old_dentry->d_inode->i_nlink,
+			atomic_read(&old_dentry->d_inode->i_count)));
+	}
+
+	yaffs_GrossUnlock(dev);
+
+	if (link){
+		update_dir_time(dir);
+		return 0;
+	}
+
+	return -EPERM;
+}
+
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+				const char *symname)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	T(YAFFS_TRACE_OS, ("yaffs_symlink\n"));
+
+	dev = yaffs_InodeToObject(dir)->myDev;
+	yaffs_GrossLock(dev);
+	obj = yaffs_MknodSymLink(yaffs_InodeToObject(dir), dentry->d_name.name,
+				S_IFLNK | S_IRWXUGO, uid, gid, symname);
+	yaffs_GrossUnlock(dev);
+
+	if (obj) {
+		struct inode *inode;
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		T(YAFFS_TRACE_OS, ("symlink created OK\n"));
+		return 0;
+	} else {
+		T(YAFFS_TRACE_OS, ("symlink not created\n"));
+	}
+
+	return -ENOMEM;
+}
+
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+				int datasync)
+{
+
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+
+	obj = yaffs_DentryToObject(dentry);
+
+	dev = obj->myDev;
+
+	T(YAFFS_TRACE_OS, ("yaffs_sync_object\n"));
+	yaffs_GrossLock(dev);
+	yaffs_FlushFile(obj, 1);
+	yaffs_GrossUnlock(dev);
+	return 0;
+}
+
+/*
+ * The VFS layer already does all the dentry stuff for rename.
+ *
+ * NB: POSIX says you can rename an object over an old object of the same name
+ */
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry)
+{
+	yaffs_Device *dev;
+	int retVal = YAFFS_FAIL;
+	yaffs_Object *target;
+
+	T(YAFFS_TRACE_OS, ("yaffs_rename\n"));
+	dev = yaffs_InodeToObject(old_dir)->myDev;
+
+	yaffs_GrossLock(dev);
+
+	/* Check if the target is an existing directory that is not empty. */
+	target = yaffs_FindObjectByName(yaffs_InodeToObject(new_dir),
+				new_dentry->d_name.name);
+
+
+
+	if (target && target->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&
+		!ylist_empty(&target->variant.directoryVariant.children)) {
+
+		T(YAFFS_TRACE_OS, ("target is non-empty dir\n"));
+
+		retVal = YAFFS_FAIL;
+	} else {
+		/* Now does unlinking internally using shadowing mechanism */
+		T(YAFFS_TRACE_OS, ("calling yaffs_RenameObject\n"));
+
+		retVal = yaffs_RenameObject(yaffs_InodeToObject(old_dir),
+				old_dentry->d_name.name,
+				yaffs_InodeToObject(new_dir),
+				new_dentry->d_name.name);
+	}
+	yaffs_GrossUnlock(dev);
+
+	if (retVal == YAFFS_OK) {
+		if (target) {
+			new_dentry->d_inode->i_nlink--;
+			mark_inode_dirty(new_dentry->d_inode);
+		}
+		
+		update_dir_time(old_dir);
+		if(old_dir != new_dir)
+			update_dir_time(new_dir);
+		return 0;
+	} else {
+		return -ENOTEMPTY;
+	}
+}
+
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	int error;
+	yaffs_Device *dev;
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_setattr of object %d\n",
+		yaffs_InodeToObject(inode)->objectId));
+
+	error = inode_change_ok(inode, attr);
+	if (error == 0) {
+		dev = yaffs_InodeToObject(inode)->myDev;
+		yaffs_GrossLock(dev);
+		if (yaffs_SetAttributes(yaffs_InodeToObject(inode), attr) ==
+				YAFFS_OK) {
+			error = 0;
+		} else {
+			error = -EPERM;
+		}
+		yaffs_GrossUnlock(dev);
+		if (!error)
+			error = inode_setattr(inode, attr);
+	}
+	return error;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	yaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;
+	struct super_block *sb = dentry->d_sb;
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf)
+{
+	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf)
+{
+	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+#endif
+
+	T(YAFFS_TRACE_OS, ("yaffs_statfs\n"));
+
+	yaffs_GrossLock(dev);
+
+	buf->f_type = YAFFS_MAGIC;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_namelen = 255;
+
+	if (dev->nDataBytesPerChunk & (dev->nDataBytesPerChunk - 1)) {
+		/* Do this if chunk size is not a power of 2 */
+
+		uint64_t bytesInDev;
+		uint64_t bytesFree;
+
+		bytesInDev = ((uint64_t)((dev->endBlock - dev->startBlock + 1))) *
+			((uint64_t)(dev->nChunksPerBlock * dev->nDataBytesPerChunk));
+
+		do_div(bytesInDev, sb->s_blocksize); /* bytesInDev becomes the number of blocks */
+		buf->f_blocks = bytesInDev;
+
+		bytesFree  = ((uint64_t)(yaffs_GetNumberOfFreeChunks(dev))) *
+			((uint64_t)(dev->nDataBytesPerChunk));
+
+		do_div(bytesFree, sb->s_blocksize);
+
+		buf->f_bfree = bytesFree;
+
+	} else if (sb->s_blocksize > dev->nDataBytesPerChunk) {
+
+		buf->f_blocks =
+			(dev->endBlock - dev->startBlock + 1) *
+			dev->nChunksPerBlock /
+			(sb->s_blocksize / dev->nDataBytesPerChunk);
+		buf->f_bfree =
+			yaffs_GetNumberOfFreeChunks(dev) /
+			(sb->s_blocksize / dev->nDataBytesPerChunk);
+	} else {
+		buf->f_blocks =
+			(dev->endBlock - dev->startBlock + 1) *
+			dev->nChunksPerBlock *
+			(dev->nDataBytesPerChunk / sb->s_blocksize);
+
+		buf->f_bfree =
+			yaffs_GetNumberOfFreeChunks(dev) *
+			(dev->nDataBytesPerChunk / sb->s_blocksize);
+	}
+
+	buf->f_files = 0;
+	buf->f_ffree = 0;
+	buf->f_bavail = buf->f_bfree;
+
+	yaffs_GrossUnlock(dev);
+	return 0;
+}
+
+
+static int yaffs_do_sync_fs(struct super_block *sb)
+{
+
+	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+	T(YAFFS_TRACE_OS, ("yaffs_do_sync_fs\n"));
+
+	if (sb->s_dirt) {
+		yaffs_GrossLock(dev);
+
+		if (dev) {
+			yaffs_FlushEntireDeviceCache(dev);
+			yaffs_CheckpointSave(dev);
+		}
+
+		yaffs_GrossUnlock(dev);
+
+		sb->s_dirt = 0;
+	}
+	return 0;
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static void yaffs_write_super(struct super_block *sb)
+#else
+static int yaffs_write_super(struct super_block *sb)
+#endif
+{
+
+	T(YAFFS_TRACE_OS, ("yaffs_write_super\n"));
+	if (yaffs_auto_checkpoint >= 2)
+		yaffs_do_sync_fs(sb);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+	return 0;
+#endif
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait)
+#else
+static int yaffs_sync_fs(struct super_block *sb)
+#endif
+{
+	T(YAFFS_TRACE_OS, ("yaffs_sync_fs\n"));
+
+	if (yaffs_auto_checkpoint >= 1)
+		yaffs_do_sync_fs(sb);
+
+	return 0;
+}
+
+#ifdef YAFFS_USE_OWN_IGET
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+	yaffs_Object *obj;
+	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_iget for %lu\n", ino));
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_GrossLock(dev);
+
+	obj = yaffs_FindObjectByNumber(dev, inode->i_ino);
+
+	yaffs_FillInodeFromObject(inode, obj);
+
+	yaffs_GrossUnlock(dev);
+
+	unlock_new_inode(inode);
+	return inode;
+}
+
+#else
+
+static void yaffs_read_inode(struct inode *inode)
+{
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_Object *obj;
+	yaffs_Device *dev = yaffs_SuperToDevice(inode->i_sb);
+
+	T(YAFFS_TRACE_OS,
+		("yaffs_read_inode for %d\n", (int)inode->i_ino));
+
+	yaffs_GrossLock(dev);
+
+	obj = yaffs_FindObjectByNumber(dev, inode->i_ino);
+
+	yaffs_FillInodeFromObject(inode, obj);
+
+	yaffs_GrossUnlock(dev);
+}
+
+#endif
+
+static YLIST_HEAD(yaffs_dev_list);
+
+#if 0 /* not used */
+static int yaffs_remount_fs(struct super_block *sb, int *flags, char *data)
+{
+	yaffs_Device    *dev = yaffs_SuperToDevice(sb);
+
+	if (*flags & MS_RDONLY) {
+		struct mtd_info *mtd = yaffs_SuperToDevice(sb)->genericDevice;
+
+		T(YAFFS_TRACE_OS,
+			("yaffs_remount_fs: %s: RO\n", dev->name));
+
+		yaffs_GrossLock(dev);
+
+		yaffs_FlushEntireDeviceCache(dev);
+
+		yaffs_CheckpointSave(dev);
+
+		if (mtd->sync)
+			mtd->sync(mtd);
+
+		yaffs_GrossUnlock(dev);
+	} else {
+		T(YAFFS_TRACE_OS,
+			("yaffs_remount_fs: %s: RW\n", dev->name));
+	}
+
+	return 0;
+}
+#endif
+
+static void yaffs_put_super(struct super_block *sb)
+{
+	yaffs_Device *dev = yaffs_SuperToDevice(sb);
+
+	T(YAFFS_TRACE_OS, ("yaffs_put_super\n"));
+
+	yaffs_GrossLock(dev);
+
+	yaffs_FlushEntireDeviceCache(dev);
+
+	yaffs_CheckpointSave(dev);
+
+	if (dev->putSuperFunc)
+		dev->putSuperFunc(sb);
+
+	yaffs_Deinitialise(dev);
+
+	yaffs_GrossUnlock(dev);
+
+	/* we assume this is protected by lock_kernel() in mount/umount */
+	ylist_del(&dev->devList);
+
+	if (dev->spareBuffer) {
+		YFREE(dev->spareBuffer);
+		dev->spareBuffer = NULL;
+	}
+
+	kfree(dev);
+}
+
+
+static void yaffs_MTDPutSuper(struct super_block *sb)
+{
+	struct mtd_info *mtd = yaffs_SuperToDevice(sb)->genericDevice;
+
+	if (mtd->sync)
+		mtd->sync(mtd);
+
+	put_mtd_device(mtd);
+}
+
+
+static void yaffs_MarkSuperBlockDirty(void *vsb)
+{
+	struct super_block *sb = (struct super_block *)vsb;
+
+	T(YAFFS_TRACE_OS, ("yaffs_MarkSuperBlockDirty() sb = %p\n", sb));
+	if (sb)
+		sb->s_dirt = 1;
+}
+
+typedef struct {
+	int inband_tags;
+	int skip_checkpoint_read;
+	int skip_checkpoint_write;
+	int no_cache;
+	int empty_lost_and_found_overridden;
+	int empty_lost_and_found;
+} yaffs_options;
+
+#define MAX_OPT_LEN 20
+static int yaffs_parse_options(yaffs_options *options, const char *options_str)
+{
+	char cur_opt[MAX_OPT_LEN + 1];
+	int p;
+	int error = 0;
+
+	/* Parse through the options which is a comma seperated list */
+
+	while (options_str && *options_str && !error) {
+		memset(cur_opt, 0, MAX_OPT_LEN + 1);
+		p = 0;
+
+		while (*options_str == ',')
+			options_str++;
+
+		while (*options_str && *options_str != ',') {
+			if (p < MAX_OPT_LEN) {
+				cur_opt[p] = *options_str;
+				p++;
+			}
+			options_str++;
+		}
+
+		if (!strcmp(cur_opt, "inband-tags"))
+			options->inband_tags = 1;
+		else if (!strcmp(cur_opt, "no-cache"))
+			options->no_cache = 1;
+		else if (!strcmp(cur_opt, "no-checkpoint-read"))
+			options->skip_checkpoint_read = 1;
+		else if (!strcmp(cur_opt, "no-checkpoint-write"))
+			options->skip_checkpoint_write = 1;
+		else if (!strcmp(cur_opt, "no-checkpoint")) {
+			options->skip_checkpoint_read = 1;
+			options->skip_checkpoint_write = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-disable")) {
+			options->empty_lost_and_found = 0;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-enable")) {
+			options->empty_lost_and_found = 1;
+			options->empty_lost_and_found_overridden = 1;
+		} else {
+			printk(KERN_INFO "yaffs: Bad mount option \"%s\"\n",
+					cur_opt);
+			error = 1;
+		}
+	}
+
+	return error;
+}
+
+static struct super_block *yaffs_internal_read_super(int yaffsVersion,
+						struct super_block *sb,
+						void *data, int silent)
+{
+	int nBlocks;
+	struct inode *inode = NULL;
+	struct dentry *root;
+	yaffs_Device *dev = 0;
+	char devname_buf[BDEVNAME_SIZE + 1];
+	struct mtd_info *mtd;
+	int err;
+	char *data_str = (char *)data;
+
+	yaffs_options options;
+
+	sb->s_magic = YAFFS_MAGIC;
+	sb->s_op = &yaffs_super_ops;
+	sb->s_flags |= MS_NOATIME;
+
+	if (!sb)
+		printk(KERN_INFO "yaffs: sb is NULL\n");
+	else if (!sb->s_dev)
+		printk(KERN_INFO "yaffs: sb->s_dev is NULL\n");
+	else if (!yaffs_devname(sb, devname_buf))
+		printk(KERN_INFO "yaffs: devname is NULL\n");
+	else
+		printk(KERN_INFO "yaffs: dev is %d name is \"%s\"\n",
+		       sb->s_dev,
+		       yaffs_devname(sb, devname_buf));
+
+	if (!data_str)
+		data_str = "";
+
+	printk(KERN_INFO "yaffs: passed flags \"%s\"\n", data_str);
+
+	memset(&options, 0, sizeof(options));
+
+	if (yaffs_parse_options(&options, data_str)) {
+		/* Option parsing failed */
+		return NULL;
+	}
+
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	T(YAFFS_TRACE_OS, ("yaffs_read_super: Using yaffs%d\n", yaffsVersion));
+	T(YAFFS_TRACE_OS,
+	  ("yaffs_read_super: block size %d\n", (int)(sb->s_blocksize)));
+
+#ifdef CONFIG_YAFFS_DISABLE_WRITE_VERIFY
+	T(YAFFS_TRACE_OS,
+	  ("yaffs: Write verification disabled. All guarantees "
+	   "null and void\n"));
+#endif
+
+	T(YAFFS_TRACE_ALWAYS, ("yaffs: Attempting MTD mount on %u.%u, "
+			       "\"%s\"\n",
+			       MAJOR(sb->s_dev), MINOR(sb->s_dev),
+			       yaffs_devname(sb, devname_buf)));
+
+	/* Check it's an mtd device..... */
+	if (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR)
+		return NULL;	/* This isn't an mtd device */
+
+	/* Get the device */
+	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	if (!mtd) {
+		T(YAFFS_TRACE_ALWAYS,
+		  ("yaffs: MTD device #%u doesn't appear to exist\n",
+		   MINOR(sb->s_dev)));
+		return NULL;
+	}
+	/* Check it's NAND */
+	if (mtd->type != MTD_NANDFLASH) {
+		T(YAFFS_TRACE_ALWAYS,
+		  ("yaffs: MTD device is not NAND it's type %d\n", mtd->type));
+		return NULL;
+	}
+
+	T(YAFFS_TRACE_OS, (" erase %p\n", mtd->erase));
+	T(YAFFS_TRACE_OS, (" read %p\n", mtd->read));
+	T(YAFFS_TRACE_OS, (" write %p\n", mtd->write));
+	T(YAFFS_TRACE_OS, (" readoob %p\n", mtd->read_oob));
+	T(YAFFS_TRACE_OS, (" writeoob %p\n", mtd->write_oob));
+	T(YAFFS_TRACE_OS, (" block_isbad %p\n", mtd->block_isbad));
+	T(YAFFS_TRACE_OS, (" block_markbad %p\n", mtd->block_markbad));
+	T(YAFFS_TRACE_OS, (" %s %d\n", WRITE_SIZE_STR, WRITE_SIZE(mtd)));
+	T(YAFFS_TRACE_OS, (" oobsize %d\n", mtd->oobsize));
+	T(YAFFS_TRACE_OS, (" erasesize %d\n", mtd->erasesize));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+	T(YAFFS_TRACE_OS, (" size %u\n", mtd->size));
+#else
+	T(YAFFS_TRACE_OS, (" size %lld\n", mtd->size));
+#endif
+
+
+#ifdef CONFIG_YAFFS_EMPTY_LOST_AND_FOUND
+	dev->emptyLostAndFound = 1;
+#endif
+	if(options.empty_lost_and_found_overridden)
+		dev->emptyLostAndFound = options.empty_lost_and_found;
+
+#ifdef CONFIG_YAFFS_AUTO_YAFFS2
+
+	if (yaffsVersion == 1 && WRITE_SIZE(mtd) >= 2048) {
+		T(YAFFS_TRACE_ALWAYS, ("yaffs: auto selecting yaffs2\n"));
+		yaffsVersion = 2;
+	}
+
+	/* Added NCB 26/5/2006 for completeness */
+	if (yaffsVersion == 2 && !options.inband_tags && WRITE_SIZE(mtd) == 512) {
+		T(YAFFS_TRACE_ALWAYS, ("yaffs: auto selecting yaffs1\n"));
+		yaffsVersion = 1;
+	}
+
+#endif
+
+	if (yaffsVersion == 2) {
+		/* Check for version 2 style functions */
+		if (!mtd->erase ||
+		    !mtd->block_isbad ||
+		    !mtd->block_markbad ||
+		    !mtd->read ||
+		    !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
+			T(YAFFS_TRACE_ALWAYS,
+			  ("yaffs: MTD device does not support required "
+			   "functions\n"));;
+			return NULL;
+		}
+
+		if ((WRITE_SIZE(mtd) < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
+		    mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
+		    !options.inband_tags) {
+			T(YAFFS_TRACE_ALWAYS,
+			  ("yaffs: MTD device does not have the "
+			   "right page sizes\n"));
+			return NULL;
+		}
+	} else {
+		/* Check for V1 style functions */
+		if (!mtd->erase ||
+		    !mtd->read ||
+		    !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
+			T(YAFFS_TRACE_ALWAYS,
+			  ("yaffs: MTD device does not support required "
+			   "functions\n"));;
+			return NULL;
+		}
+
+		if (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||
+		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
+			T(YAFFS_TRACE_ALWAYS,
+			  ("yaffs: MTD device does not support have the "
+			   "right page sizes\n"));
+			return NULL;
+		}
+	}
+
+	/* OK, so if we got here, we have an MTD that's NAND and looks
+	 * like it has the right capabilities
+	 * Set the yaffs_Device up for mtd
+	 */
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	sb->s_fs_info = dev = kmalloc(sizeof(yaffs_Device), GFP_KERNEL);
+#else
+	sb->u.generic_sbp = dev = kmalloc(sizeof(yaffs_Device), GFP_KERNEL);
+#endif
+	if (!dev) {
+		/* Deep shit could not allocate device structure */
+		T(YAFFS_TRACE_ALWAYS,
+		  ("yaffs_read_super: Failed trying to allocate "
+		   "yaffs_Device. \n"));
+		return NULL;
+	}
+
+	memset(dev, 0, sizeof(yaffs_Device));
+	dev->genericDevice = mtd;
+	dev->name = mtd->name;
+
+	/* Set up the memory size parameters.... */
+
+	nBlocks = YCALCBLOCKS(mtd->size, (YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK));
+
+	dev->startBlock = 0;
+	dev->endBlock = nBlocks - 1;
+	dev->nChunksPerBlock = YAFFS_CHUNKS_PER_BLOCK;
+	dev->totalBytesPerChunk = YAFFS_BYTES_PER_CHUNK;
+	dev->nReservedBlocks = 5;
+	dev->nShortOpCaches = (options.no_cache) ? 0 : 10;
+	dev->inbandTags = options.inband_tags;
+
+	/* ... and the functions. */
+	if (yaffsVersion == 2) {
+		dev->writeChunkWithTagsToNAND =
+		    nandmtd2_WriteChunkWithTagsToNAND;
+		dev->readChunkWithTagsFromNAND =
+		    nandmtd2_ReadChunkWithTagsFromNAND;
+		dev->markNANDBlockBad = nandmtd2_MarkNANDBlockBad;
+		dev->queryNANDBlock = nandmtd2_QueryNANDBlock;
+		dev->spareBuffer = YMALLOC(mtd->oobsize);
+		dev->isYaffs2 = 1;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		dev->totalBytesPerChunk = mtd->writesize;
+		dev->nChunksPerBlock = mtd->erasesize / mtd->writesize;
+#else
+		dev->totalBytesPerChunk = mtd->oobblock;
+		dev->nChunksPerBlock = mtd->erasesize / mtd->oobblock;
+#endif
+		nBlocks = YCALCBLOCKS(mtd->size, mtd->erasesize);
+
+		dev->startBlock = 0;
+		dev->endBlock = nBlocks - 1;
+	} else {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		/* use the MTD interface in yaffs_mtdif1.c */
+		dev->writeChunkWithTagsToNAND =
+			nandmtd1_WriteChunkWithTagsToNAND;
+		dev->readChunkWithTagsFromNAND =
+			nandmtd1_ReadChunkWithTagsFromNAND;
+		dev->markNANDBlockBad = nandmtd1_MarkNANDBlockBad;
+		dev->queryNANDBlock = nandmtd1_QueryNANDBlock;
+#else
+		dev->writeChunkToNAND = nandmtd_WriteChunkToNAND;
+		dev->readChunkFromNAND = nandmtd_ReadChunkFromNAND;
+#endif
+		dev->isYaffs2 = 0;
+	}
+	/* ... and common functions */
+	dev->eraseBlockInNAND = nandmtd_EraseBlockInNAND;
+	dev->initialiseNAND = nandmtd_InitialiseNAND;
+
+	dev->putSuperFunc = yaffs_MTDPutSuper;
+
+	dev->superBlock = (void *)sb;
+	dev->markSuperBlockDirty = yaffs_MarkSuperBlockDirty;
+
+
+#ifndef CONFIG_YAFFS_DOES_ECC
+	dev->useNANDECC = 1;
+#endif
+
+#ifdef CONFIG_YAFFS_DISABLE_WIDE_TNODES
+	dev->wideTnodesDisabled = 1;
+#endif
+
+	dev->skipCheckpointRead = options.skip_checkpoint_read;
+	dev->skipCheckpointWrite = options.skip_checkpoint_write;
+
+	/* we assume this is protected by lock_kernel() in mount/umount */
+	ylist_add_tail(&dev->devList, &yaffs_dev_list);
+
+        /* Directory search handling...*/
+        YINIT_LIST_HEAD(&dev->searchContexts);
+        dev->removeObjectCallback = yaffs_RemoveObjectCallback;
+
+	init_MUTEX(&dev->grossLock);
+
+	yaffs_GrossLock(dev);
+
+	err = yaffs_GutsInitialise(dev);
+
+	T(YAFFS_TRACE_OS,
+	  ("yaffs_read_super: guts initialised %s\n",
+	   (err == YAFFS_OK) ? "OK" : "FAILED"));
+
+	/* Release lock before yaffs_get_inode() */
+	yaffs_GrossUnlock(dev);
+
+	/* Create root inode */
+	if (err == YAFFS_OK)
+		inode = yaffs_get_inode(sb, S_IFDIR | 0755, 0,
+					yaffs_Root(dev));
+
+	if (!inode)
+		return NULL;
+
+	inode->i_op = &yaffs_dir_inode_operations;
+	inode->i_fop = &yaffs_dir_operations;
+
+	T(YAFFS_TRACE_OS, ("yaffs_read_super: got root inode\n"));
+
+	root = d_alloc_root(inode);
+
+	T(YAFFS_TRACE_OS, ("yaffs_read_super: d_alloc_root done\n"));
+
+	if (!root) {
+		iput(inode);
+		return NULL;
+	}
+	sb->s_root = root;
+	sb->s_dirt = !dev->isCheckpointed;
+	T(YAFFS_TRACE_ALWAYS,
+	  ("yaffs_read_super: isCheckpointed %d\n", dev->isCheckpointed));
+
+	T(YAFFS_TRACE_OS, ("yaffs_read_super: done\n"));
+	return sb;
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,
+					 int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_read_super(struct file_system_type *fs,
+			    int flags, const char *dev_name,
+			    void *data, struct vfsmount *mnt)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs_read_super(struct file_system_type *fs,
+					    int flags, const char *dev_name,
+					    void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs",
+	.get_sb = yaffs_read_super,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs_read_super(struct super_block *sb, void *data,
+					    int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs_fs_type, "yaffs", yaffs_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+
+#ifdef CONFIG_YAFFS_YAFFS2
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,
+					  int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs2_read_super(struct file_system_type *fs,
+			int flags, const char *dev_name, void *data,
+			struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs, flags, dev_name, data,
+			yaffs2_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs2_read_super(struct file_system_type *fs,
+					     int flags, const char *dev_name,
+					     void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs2_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs2",
+	.get_sb = yaffs2_read_super,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs2_read_super(struct super_block *sb,
+					     void *data, int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs2_fs_type, "yaffs2", yaffs2_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+#endif				/* CONFIG_YAFFS_YAFFS2 */
+
+static struct proc_dir_entry *my_proc_entry;
+
+static char *yaffs_dump_dev(char *buf, yaffs_Device * dev)
+{
+	buf += sprintf(buf, "startBlock......... %d\n", dev->startBlock);
+	buf += sprintf(buf, "endBlock........... %d\n", dev->endBlock);
+	buf += sprintf(buf, "totalBytesPerChunk. %d\n", dev->totalBytesPerChunk);
+	buf += sprintf(buf, "nDataBytesPerChunk. %d\n", dev->nDataBytesPerChunk);
+	buf += sprintf(buf, "chunkGroupBits..... %d\n", dev->chunkGroupBits);
+	buf += sprintf(buf, "chunkGroupSize..... %d\n", dev->chunkGroupSize);
+	buf += sprintf(buf, "nErasedBlocks...... %d\n", dev->nErasedBlocks);
+	buf += sprintf(buf, "nReservedBlocks.... %d\n", dev->nReservedBlocks);
+	buf += sprintf(buf, "blocksInCheckpoint. %d\n", dev->blocksInCheckpoint);
+	buf += sprintf(buf, "nTnodesCreated..... %d\n", dev->nTnodesCreated);
+	buf += sprintf(buf, "nFreeTnodes........ %d\n", dev->nFreeTnodes);
+	buf += sprintf(buf, "nObjectsCreated.... %d\n", dev->nObjectsCreated);
+	buf += sprintf(buf, "nFreeObjects....... %d\n", dev->nFreeObjects);
+	buf += sprintf(buf, "nFreeChunks........ %d\n", dev->nFreeChunks);
+	buf += sprintf(buf, "nPageWrites........ %d\n", dev->nPageWrites);
+	buf += sprintf(buf, "nPageReads......... %d\n", dev->nPageReads);
+	buf += sprintf(buf, "nBlockErasures..... %d\n", dev->nBlockErasures);
+	buf += sprintf(buf, "nGCCopies.......... %d\n", dev->nGCCopies);
+	buf += sprintf(buf, "garbageCollections. %d\n", dev->garbageCollections);
+	buf += sprintf(buf, "passiveGCs......... %d\n",
+		    dev->passiveGarbageCollections);
+	buf += sprintf(buf, "nRetriedWrites..... %d\n", dev->nRetriedWrites);
+	buf += sprintf(buf, "nShortOpCaches..... %d\n", dev->nShortOpCaches);
+	buf += sprintf(buf, "nRetireBlocks...... %d\n", dev->nRetiredBlocks);
+	buf += sprintf(buf, "eccFixed........... %d\n", dev->eccFixed);
+	buf += sprintf(buf, "eccUnfixed......... %d\n", dev->eccUnfixed);
+	buf += sprintf(buf, "tagsEccFixed....... %d\n", dev->tagsEccFixed);
+	buf += sprintf(buf, "tagsEccUnfixed..... %d\n", dev->tagsEccUnfixed);
+	buf += sprintf(buf, "cacheHits.......... %d\n", dev->cacheHits);
+	buf += sprintf(buf, "nDeletedFiles...... %d\n", dev->nDeletedFiles);
+	buf += sprintf(buf, "nUnlinkedFiles..... %d\n", dev->nUnlinkedFiles);
+	buf +=
+	    sprintf(buf, "nBackgroudDeletions %d\n", dev->nBackgroundDeletions);
+	buf += sprintf(buf, "useNANDECC......... %d\n", dev->useNANDECC);
+	buf += sprintf(buf, "isYaffs2........... %d\n", dev->isYaffs2);
+	buf += sprintf(buf, "inbandTags......... %d\n", dev->inbandTags);
+
+	return buf;
+}
+
+static int yaffs_proc_read(char *page,
+			   char **start,
+			   off_t offset, int count, int *eof, void *data)
+{
+	struct ylist_head *item;
+	char *buf = page;
+	int step = offset;
+	int n = 0;
+
+	/* Get proc_file_read() to step 'offset' by one on each sucessive call.
+	 * We use 'offset' (*ppos) to indicate where we are in devList.
+	 * This also assumes the user has posted a read buffer large
+	 * enough to hold the complete output; but that's life in /proc.
+	 */
+
+	*(int *)start = 1;
+
+	/* Print header first */
+	if (step == 0) {
+		buf += sprintf(buf, "YAFFS built:" __DATE__ " " __TIME__
+			       "\n%s\n%s\n", yaffs_fs_c_version,
+			       yaffs_guts_c_version);
+	}
+
+	/* hold lock_kernel while traversing yaffs_dev_list */
+	lock_kernel();
+
+	/* Locate and print the Nth entry.  Order N-squared but N is small. */
+	ylist_for_each(item, &yaffs_dev_list) {
+		yaffs_Device *dev = ylist_entry(item, yaffs_Device, devList);
+		if (n < step) {
+			n++;
+			continue;
+		}
+		buf += sprintf(buf, "\nDevice %d \"%s\"\n", n, dev->name);
+		buf = yaffs_dump_dev(buf, dev);
+		break;
+	}
+	unlock_kernel();
+
+	return buf - page < count ? buf - page : count;
+}
+
+/**
+ * Set the verbosity of the warnings and error messages.
+ *
+ * Note that the names can only be a..z or _ with the current code.
+ */
+
+static struct {
+	char *mask_name;
+	unsigned mask_bitfield;
+} mask_flags[] = {
+	{"allocate", YAFFS_TRACE_ALLOCATE},
+	{"always", YAFFS_TRACE_ALWAYS},
+	{"bad_blocks", YAFFS_TRACE_BAD_BLOCKS},
+	{"buffers", YAFFS_TRACE_BUFFERS},
+	{"bug", YAFFS_TRACE_BUG},
+	{"checkpt", YAFFS_TRACE_CHECKPOINT},
+	{"deletion", YAFFS_TRACE_DELETION},
+	{"erase", YAFFS_TRACE_ERASE},
+	{"error", YAFFS_TRACE_ERROR},
+	{"gc_detail", YAFFS_TRACE_GC_DETAIL},
+	{"gc", YAFFS_TRACE_GC},
+	{"mtd", YAFFS_TRACE_MTD},
+	{"nandaccess", YAFFS_TRACE_NANDACCESS},
+	{"os", YAFFS_TRACE_OS},
+	{"scan_debug", YAFFS_TRACE_SCAN_DEBUG},
+	{"scan", YAFFS_TRACE_SCAN},
+	{"tracing", YAFFS_TRACE_TRACING},
+
+	{"verify", YAFFS_TRACE_VERIFY},
+	{"verify_nand", YAFFS_TRACE_VERIFY_NAND},
+	{"verify_full", YAFFS_TRACE_VERIFY_FULL},
+	{"verify_all", YAFFS_TRACE_VERIFY_ALL},
+
+	{"write", YAFFS_TRACE_WRITE},
+	{"all", 0xffffffff},
+	{"none", 0},
+	{NULL, 0},
+};
+
+#define MAX_MASK_NAME_LENGTH 40
+static int yaffs_proc_write(struct file *file, const char *buf,
+					 unsigned long count, void *data)
+{
+	unsigned rg = 0, mask_bitfield;
+	char *end;
+	char *mask_name;
+	const char *x;
+	char substring[MAX_MASK_NAME_LENGTH + 1];
+	int i;
+	int done = 0;
+	int add, len = 0;
+	int pos = 0;
+
+	rg = yaffs_traceMask;
+
+	while (!done && (pos < count)) {
+		done = 1;
+		while ((pos < count) && isspace(buf[pos]))
+			pos++;
+
+		switch (buf[pos]) {
+		case '+':
+		case '-':
+		case '=':
+			add = buf[pos];
+			pos++;
+			break;
+
+		default:
+			add = ' ';
+			break;
+		}
+		mask_name = NULL;
+
+		mask_bitfield = simple_strtoul(buf + pos, &end, 0);
+
+		if (end > buf + pos) {
+			mask_name = "numeral";
+			len = end - (buf + pos);
+			pos += len;
+			done = 0;
+		} else {
+			for (x = buf + pos, i = 0;
+			    (*x == '_' || (*x >= 'a' && *x <= 'z')) &&
+			    i < MAX_MASK_NAME_LENGTH; x++, i++, pos++)
+				substring[i] = *x;
+			substring[i] = '\0';
+
+			for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+				if (strcmp(substring, mask_flags[i].mask_name) == 0) {
+					mask_name = mask_flags[i].mask_name;
+					mask_bitfield = mask_flags[i].mask_bitfield;
+					done = 0;
+					break;
+				}
+			}
+		}
+
+		if (mask_name != NULL) {
+			done = 0;
+			switch (add) {
+			case '-':
+				rg &= ~mask_bitfield;
+				break;
+			case '+':
+				rg |= mask_bitfield;
+				break;
+			case '=':
+				rg = mask_bitfield;
+				break;
+			default:
+				rg |= mask_bitfield;
+				break;
+			}
+		}
+	}
+
+	yaffs_traceMask = rg | YAFFS_TRACE_ALWAYS;
+
+	printk(KERN_DEBUG "new trace = 0x%08X\n", yaffs_traceMask);
+
+	if (rg & YAFFS_TRACE_ALWAYS) {
+		for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+			char flag;
+			flag = ((rg & mask_flags[i].mask_bitfield) == mask_flags[i].mask_bitfield) ? '+' : '-';
+			printk(KERN_DEBUG "%c%s\n", flag, mask_flags[i].mask_name);
+		}
+	}
+
+	return count;
+}
+
+/* Stuff to handle installation of file systems */
+struct file_system_to_install {
+	struct file_system_type *fst;
+	int installed;
+};
+
+static struct file_system_to_install fs_to_install[] = {
+	{&yaffs_fs_type, 0},
+	{&yaffs2_fs_type, 0},
+	{NULL, 0}
+};
+
+static int __init init_yaffs_fs(void)
+{
+	int error = 0;
+	struct file_system_to_install *fsinst;
+
+	T(YAFFS_TRACE_ALWAYS,
+	  ("yaffs " __DATE__ " " __TIME__ " Installing. \n"));
+
+	/* Install the proc_fs entry */
+	my_proc_entry = create_proc_entry("yaffs",
+					       S_IRUGO | S_IFREG,
+					       YPROC_ROOT);
+
+	if (my_proc_entry) {
+		my_proc_entry->write_proc = yaffs_proc_write;
+		my_proc_entry->read_proc = yaffs_proc_read;
+		my_proc_entry->data = NULL;
+	} else
+		return -ENOMEM;
+
+	/* Now add the file system entries */
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst && !error) {
+		error = register_filesystem(fsinst->fst);
+		if (!error)
+			fsinst->installed = 1;
+		fsinst++;
+	}
+
+	/* Any errors? uninstall  */
+	if (error) {
+		fsinst = fs_to_install;
+
+		while (fsinst->fst) {
+			if (fsinst->installed) {
+				unregister_filesystem(fsinst->fst);
+				fsinst->installed = 0;
+			}
+			fsinst++;
+		}
+	}
+
+	return error;
+}
+
+static void __exit exit_yaffs_fs(void)
+{
+
+	struct file_system_to_install *fsinst;
+
+	T(YAFFS_TRACE_ALWAYS, ("yaffs " __DATE__ " " __TIME__
+			       " removing. \n"));
+
+	remove_proc_entry("yaffs", YPROC_ROOT);
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst) {
+		if (fsinst->installed) {
+			unregister_filesystem(fsinst->fst);
+			fsinst->installed = 0;
+		}
+		fsinst++;
+	}
+}
+
+module_init(init_yaffs_fs)
+module_exit(exit_yaffs_fs)
+
+MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
+MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2006");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_getblockinfo.h linux-2.6.29-spica/fs/yaffs2/yaffs_getblockinfo.h
--- linux-2.6.29/fs/yaffs2/yaffs_getblockinfo.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_getblockinfo.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,34 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_GETBLOCKINFO_H__
+#define __YAFFS_GETBLOCKINFO_H__
+
+#include "yaffs_guts.h"
+
+/* Function to manipulate block info */
+static Y_INLINE yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blk)
+{
+	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {
+		T(YAFFS_TRACE_ERROR,
+		  (TSTR
+		   ("**>> yaffs: getBlockInfo block %d is not valid" TENDSTR),
+		   blk));
+		YBUG();
+	}
+	return &dev->blockInfo[blk - dev->internalStartBlock];
+}
+
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_guts.c linux-2.6.29-spica/fs/yaffs2/yaffs_guts.c
--- linux-2.6.29/fs/yaffs2/yaffs_guts.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_guts.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,7739 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+const char *yaffs_guts_c_version =
+    "$Id$";
+
+#include "yportenv.h"
+
+#include "yaffsinterface.h"
+#include "yaffs_guts.h"
+#include "yaffs_tagsvalidity.h"
+#include "yaffs_getblockinfo.h"
+
+#include "yaffs_tagscompat.h"
+#ifndef CONFIG_YAFFS_USE_OWN_SORT
+#include "yaffs_qsort.h"
+#endif
+#include "yaffs_nand.h"
+
+#include "yaffs_checkptrw.h"
+
+#include "yaffs_nand.h"
+#include "yaffs_packedtags2.h"
+
+
+#define YAFFS_PASSIVE_GC_CHUNKS 2
+
+#include "yaffs_ecc.h"
+
+
+/* Robustification (if it ever comes about...) */
+static void yaffs_RetireBlock(yaffs_Device *dev, int blockInNAND);
+static void yaffs_HandleWriteChunkError(yaffs_Device *dev, int chunkInNAND,
+		int erasedOk);
+static void yaffs_HandleWriteChunkOk(yaffs_Device *dev, int chunkInNAND,
+				const __u8 *data,
+				const yaffs_ExtendedTags *tags);
+static void yaffs_HandleUpdateChunk(yaffs_Device *dev, int chunkInNAND,
+				const yaffs_ExtendedTags *tags);
+
+/* Other local prototypes */
+static void yaffs_UpdateParent(yaffs_Object *obj);
+static int yaffs_UnlinkObject(yaffs_Object *obj);
+static int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj);
+
+static void yaffs_HardlinkFixup(yaffs_Device *dev, yaffs_Object *hardList);
+
+static int yaffs_WriteNewChunkWithTagsToNAND(yaffs_Device *dev,
+					const __u8 *buffer,
+					yaffs_ExtendedTags *tags,
+					int useReserve);
+static int yaffs_PutChunkIntoFile(yaffs_Object *in, int chunkInInode,
+				int chunkInNAND, int inScan);
+
+static yaffs_Object *yaffs_CreateNewObject(yaffs_Device *dev, int number,
+					yaffs_ObjectType type);
+static void yaffs_AddObjectToDirectory(yaffs_Object *directory,
+				yaffs_Object *obj);
+static int yaffs_UpdateObjectHeader(yaffs_Object *in, const YCHAR *name,
+				int force, int isShrink, int shadows);
+static void yaffs_RemoveObjectFromDirectory(yaffs_Object *obj);
+static int yaffs_CheckStructures(void);
+static int yaffs_DeleteWorker(yaffs_Object *in, yaffs_Tnode *tn, __u32 level,
+			int chunkOffset, int *limit);
+static int yaffs_DoGenericObjectDeletion(yaffs_Object *in);
+
+static yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device *dev, int blockNo);
+
+
+static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,
+				int chunkInNAND);
+
+static int yaffs_UnlinkWorker(yaffs_Object *obj);
+
+static int yaffs_TagsMatch(const yaffs_ExtendedTags *tags, int objectId,
+			int chunkInObject);
+
+static int yaffs_AllocateChunk(yaffs_Device *dev, int useReserve,
+				yaffs_BlockInfo **blockUsedPtr);
+
+static void yaffs_VerifyFreeChunks(yaffs_Device *dev);
+
+static void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in);
+
+static void yaffs_VerifyDirectory(yaffs_Object *directory);
+#ifdef YAFFS_PARANOID
+static int yaffs_CheckFileSanity(yaffs_Object *in);
+#else
+#define yaffs_CheckFileSanity(in)
+#endif
+
+static void yaffs_InvalidateWholeChunkCache(yaffs_Object *in);
+static void yaffs_InvalidateChunkCache(yaffs_Object *object, int chunkId);
+
+static void yaffs_InvalidateCheckpoint(yaffs_Device *dev);
+
+static int yaffs_FindChunkInFile(yaffs_Object *in, int chunkInInode,
+				yaffs_ExtendedTags *tags);
+
+static __u32 yaffs_GetChunkGroupBase(yaffs_Device *dev, yaffs_Tnode *tn,
+		unsigned pos);
+static yaffs_Tnode *yaffs_FindLevel0Tnode(yaffs_Device *dev,
+					yaffs_FileStructure *fStruct,
+					__u32 chunkId);
+
+/* Function to calculate chunk and offset */
+
+static void yaffs_AddrToChunk(yaffs_Device *dev, loff_t addr, int *chunkOut,
+		__u32 *offsetOut)
+{
+	int chunk;
+	__u32 offset;
+
+	chunk  = (__u32)(addr >> dev->chunkShift);
+
+	if (dev->chunkDiv == 1) {
+		/* easy power of 2 case */
+		offset = (__u32)(addr & dev->chunkMask);
+	} else {
+		/* Non power-of-2 case */
+
+		loff_t chunkBase;
+
+		chunk /= dev->chunkDiv;
+
+		chunkBase = ((loff_t)chunk) * dev->nDataBytesPerChunk;
+		offset = (__u32)(addr - chunkBase);
+	}
+
+	*chunkOut = chunk;
+	*offsetOut = offset;
+}
+
+/* Function to return the number of shifts for a power of 2 greater than or
+ * equal to the given number
+ * Note we don't try to cater for all possible numbers and this does not have to
+ * be hellishly efficient.
+ */
+
+static __u32 ShiftsGE(__u32 x)
+{
+	int extraBits;
+	int nShifts;
+
+	nShifts = extraBits = 0;
+
+	while (x > 1) {
+		if (x & 1)
+			extraBits++;
+		x >>= 1;
+		nShifts++;
+	}
+
+	if (extraBits)
+		nShifts++;
+
+	return nShifts;
+}
+
+/* Function to return the number of shifts to get a 1 in bit 0
+ */
+
+static __u32 Shifts(__u32 x)
+{
+	int nShifts;
+
+	nShifts =  0;
+
+	if (!x)
+		return 0;
+
+	while (!(x&1)) {
+		x >>= 1;
+		nShifts++;
+	}
+
+	return nShifts;
+}
+
+
+
+/*
+ * Temporary buffer manipulations.
+ */
+
+static int yaffs_InitialiseTempBuffers(yaffs_Device *dev)
+{
+	int i;
+	__u8 *buf = (__u8 *)1;
+
+	memset(dev->tempBuffer, 0, sizeof(dev->tempBuffer));
+
+	for (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {
+		dev->tempBuffer[i].line = 0;	/* not in use */
+		dev->tempBuffer[i].buffer = buf =
+		    YMALLOC_DMA(dev->totalBytesPerChunk);
+	}
+
+	return buf ? YAFFS_OK : YAFFS_FAIL;
+}
+
+__u8 *yaffs_GetTempBuffer(yaffs_Device *dev, int lineNo)
+{
+	int i, j;
+
+	dev->tempInUse++;
+	if (dev->tempInUse > dev->maxTemp)
+		dev->maxTemp = dev->tempInUse;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->tempBuffer[i].line == 0) {
+			dev->tempBuffer[i].line = lineNo;
+			if ((i + 1) > dev->maxTemp) {
+				dev->maxTemp = i + 1;
+				for (j = 0; j <= i; j++)
+					dev->tempBuffer[j].maxLine =
+					    dev->tempBuffer[j].line;
+			}
+
+			return dev->tempBuffer[i].buffer;
+		}
+	}
+
+	T(YAFFS_TRACE_BUFFERS,
+	  (TSTR("Out of temp buffers at line %d, other held by lines:"),
+	   lineNo));
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++)
+		T(YAFFS_TRACE_BUFFERS, (TSTR(" %d "), dev->tempBuffer[i].line));
+
+	T(YAFFS_TRACE_BUFFERS, (TSTR(" " TENDSTR)));
+
+	/*
+	 * If we got here then we have to allocate an unmanaged one
+	 * This is not good.
+	 */
+
+	dev->unmanagedTempAllocations++;
+	return YMALLOC(dev->nDataBytesPerChunk);
+
+}
+
+void yaffs_ReleaseTempBuffer(yaffs_Device *dev, __u8 *buffer,
+				    int lineNo)
+{
+	int i;
+
+	dev->tempInUse--;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->tempBuffer[i].buffer == buffer) {
+			dev->tempBuffer[i].line = 0;
+			return;
+		}
+	}
+
+	if (buffer) {
+		/* assume it is an unmanaged one. */
+		T(YAFFS_TRACE_BUFFERS,
+		  (TSTR("Releasing unmanaged temp buffer in line %d" TENDSTR),
+		   lineNo));
+		YFREE(buffer);
+		dev->unmanagedTempDeallocations++;
+	}
+
+}
+
+/*
+ * Determine if we have a managed buffer.
+ */
+int yaffs_IsManagedTempBuffer(yaffs_Device *dev, const __u8 *buffer)
+{
+	int i;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->tempBuffer[i].buffer == buffer)
+			return 1;
+	}
+
+	for (i = 0; i < dev->nShortOpCaches; i++) {
+		if (dev->srCache[i].data == buffer)
+			return 1;
+	}
+
+	if (buffer == dev->checkpointBuffer)
+		return 1;
+
+	T(YAFFS_TRACE_ALWAYS,
+		(TSTR("yaffs: unmaged buffer detected.\n" TENDSTR)));
+	return 0;
+}
+
+
+
+/*
+ * Chunk bitmap manipulations
+ */
+
+static Y_INLINE __u8 *yaffs_BlockBits(yaffs_Device *dev, int blk)
+{
+	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {
+		T(YAFFS_TRACE_ERROR,
+			(TSTR("**>> yaffs: BlockBits block %d is not valid" TENDSTR),
+			blk));
+		YBUG();
+	}
+	return dev->chunkBits +
+		(dev->chunkBitmapStride * (blk - dev->internalStartBlock));
+}
+
+static Y_INLINE void yaffs_VerifyChunkBitId(yaffs_Device *dev, int blk, int chunk)
+{
+	if (blk < dev->internalStartBlock || blk > dev->internalEndBlock ||
+			chunk < 0 || chunk >= dev->nChunksPerBlock) {
+		T(YAFFS_TRACE_ERROR,
+		(TSTR("**>> yaffs: Chunk Id (%d:%d) invalid"TENDSTR),
+			blk, chunk));
+		YBUG();
+	}
+}
+
+static Y_INLINE void yaffs_ClearChunkBits(yaffs_Device *dev, int blk)
+{
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+
+	memset(blkBits, 0, dev->chunkBitmapStride);
+}
+
+static Y_INLINE void yaffs_ClearChunkBit(yaffs_Device *dev, int blk, int chunk)
+{
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+
+	yaffs_VerifyChunkBitId(dev, blk, chunk);
+
+	blkBits[chunk / 8] &= ~(1 << (chunk & 7));
+}
+
+static Y_INLINE void yaffs_SetChunkBit(yaffs_Device *dev, int blk, int chunk)
+{
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+
+	yaffs_VerifyChunkBitId(dev, blk, chunk);
+
+	blkBits[chunk / 8] |= (1 << (chunk & 7));
+}
+
+static Y_INLINE int yaffs_CheckChunkBit(yaffs_Device *dev, int blk, int chunk)
+{
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+	yaffs_VerifyChunkBitId(dev, blk, chunk);
+
+	return (blkBits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;
+}
+
+static Y_INLINE int yaffs_StillSomeChunkBits(yaffs_Device *dev, int blk)
+{
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+	int i;
+	for (i = 0; i < dev->chunkBitmapStride; i++) {
+		if (*blkBits)
+			return 1;
+		blkBits++;
+	}
+	return 0;
+}
+
+static int yaffs_CountChunkBits(yaffs_Device *dev, int blk)
+{
+	__u8 *blkBits = yaffs_BlockBits(dev, blk);
+	int i;
+	int n = 0;
+	for (i = 0; i < dev->chunkBitmapStride; i++) {
+		__u8 x = *blkBits;
+		while (x) {
+			if (x & 1)
+				n++;
+			x >>= 1;
+		}
+
+		blkBits++;
+	}
+	return n;
+}
+
+/*
+ * Verification code
+ */
+
+static int yaffs_SkipVerification(yaffs_Device *dev)
+{
+	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
+}
+
+static int yaffs_SkipFullVerification(yaffs_Device *dev)
+{
+	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_FULL));
+}
+
+static int yaffs_SkipNANDVerification(yaffs_Device *dev)
+{
+	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_NAND));
+}
+
+static const char *blockStateName[] = {
+"Unknown",
+"Needs scanning",
+"Scanning",
+"Empty",
+"Allocating",
+"Full",
+"Dirty",
+"Checkpoint",
+"Collecting",
+"Dead"
+};
+
+static void yaffs_VerifyBlock(yaffs_Device *dev, yaffs_BlockInfo *bi, int n)
+{
+	int actuallyUsed;
+	int inUse;
+
+	if (yaffs_SkipVerification(dev))
+		return;
+
+	/* Report illegal runtime states */
+	if (bi->blockState >= YAFFS_NUMBER_OF_BLOCK_STATES)
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has undefined state %d"TENDSTR), n, bi->blockState));
+
+	switch (bi->blockState) {
+	case YAFFS_BLOCK_STATE_UNKNOWN:
+	case YAFFS_BLOCK_STATE_SCANNING:
+	case YAFFS_BLOCK_STATE_NEEDS_SCANNING:
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has bad run-state %s"TENDSTR),
+		n, blockStateName[bi->blockState]));
+	}
+
+	/* Check pages in use and soft deletions are legal */
+
+	actuallyUsed = bi->pagesInUse - bi->softDeletions;
+
+	if (bi->pagesInUse < 0 || bi->pagesInUse > dev->nChunksPerBlock ||
+	   bi->softDeletions < 0 || bi->softDeletions > dev->nChunksPerBlock ||
+	   actuallyUsed < 0 || actuallyUsed > dev->nChunksPerBlock)
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has illegal values pagesInUsed %d softDeletions %d"TENDSTR),
+		n, bi->pagesInUse, bi->softDeletions));
+
+
+	/* Check chunk bitmap legal */
+	inUse = yaffs_CountChunkBits(dev, n);
+	if (inUse != bi->pagesInUse)
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has inconsistent values pagesInUse %d counted chunk bits %d"TENDSTR),
+			n, bi->pagesInUse, inUse));
+
+	/* Check that the sequence number is valid.
+	 * Ten million is legal, but is very unlikely
+	 */
+	if (dev->isYaffs2 &&
+	   (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING || bi->blockState == YAFFS_BLOCK_STATE_FULL) &&
+	   (bi->sequenceNumber < YAFFS_LOWEST_SEQUENCE_NUMBER || bi->sequenceNumber > 10000000))
+		T(YAFFS_TRACE_VERIFY, (TSTR("Block %d has suspect sequence number of %d"TENDSTR),
+		n, bi->sequenceNumber));
+}
+
+static void yaffs_VerifyCollectedBlock(yaffs_Device *dev, yaffs_BlockInfo *bi,
+		int n)
+{
+	yaffs_VerifyBlock(dev, bi, n);
+
+	/* After collection the block should be in the erased state */
+	/* This will need to change if we do partial gc */
+
+	if (bi->blockState != YAFFS_BLOCK_STATE_COLLECTING &&
+			bi->blockState != YAFFS_BLOCK_STATE_EMPTY) {
+		T(YAFFS_TRACE_ERROR, (TSTR("Block %d is in state %d after gc, should be erased"TENDSTR),
+			n, bi->blockState));
+	}
+}
+
+static void yaffs_VerifyBlocks(yaffs_Device *dev)
+{
+	int i;
+	int nBlocksPerState[YAFFS_NUMBER_OF_BLOCK_STATES];
+	int nIllegalBlockStates = 0;
+
+	if (yaffs_SkipVerification(dev))
+		return;
+
+	memset(nBlocksPerState, 0, sizeof(nBlocksPerState));
+
+	for (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {
+		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, i);
+		yaffs_VerifyBlock(dev, bi, i);
+
+		if (bi->blockState < YAFFS_NUMBER_OF_BLOCK_STATES)
+			nBlocksPerState[bi->blockState]++;
+		else
+			nIllegalBlockStates++;
+	}
+
+	T(YAFFS_TRACE_VERIFY, (TSTR(""TENDSTR)));
+	T(YAFFS_TRACE_VERIFY, (TSTR("Block summary"TENDSTR)));
+
+	T(YAFFS_TRACE_VERIFY, (TSTR("%d blocks have illegal states"TENDSTR), nIllegalBlockStates));
+	if (nBlocksPerState[YAFFS_BLOCK_STATE_ALLOCATING] > 1)
+		T(YAFFS_TRACE_VERIFY, (TSTR("Too many allocating blocks"TENDSTR)));
+
+	for (i = 0; i < YAFFS_NUMBER_OF_BLOCK_STATES; i++)
+		T(YAFFS_TRACE_VERIFY,
+		  (TSTR("%s %d blocks"TENDSTR),
+		  blockStateName[i], nBlocksPerState[i]));
+
+	if (dev->blocksInCheckpoint != nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT])
+		T(YAFFS_TRACE_VERIFY,
+		 (TSTR("Checkpoint block count wrong dev %d count %d"TENDSTR),
+		 dev->blocksInCheckpoint, nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT]));
+
+	if (dev->nErasedBlocks != nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY])
+		T(YAFFS_TRACE_VERIFY,
+		 (TSTR("Erased block count wrong dev %d count %d"TENDSTR),
+		 dev->nErasedBlocks, nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY]));
+
+	if (nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING] > 1)
+		T(YAFFS_TRACE_VERIFY,
+		 (TSTR("Too many collecting blocks %d (max is 1)"TENDSTR),
+		 nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING]));
+
+	T(YAFFS_TRACE_VERIFY, (TSTR(""TENDSTR)));
+
+}
+
+/*
+ * Verify the object header. oh must be valid, but obj and tags may be NULL in which
+ * case those tests will not be performed.
+ */
+static void yaffs_VerifyObjectHeader(yaffs_Object *obj, yaffs_ObjectHeader *oh, yaffs_ExtendedTags *tags, int parentCheck)
+{
+	if (obj && yaffs_SkipVerification(obj->myDev))
+		return;
+
+	if (!(tags && obj && oh)) {
+		T(YAFFS_TRACE_VERIFY,
+				(TSTR("Verifying object header tags %x obj %x oh %x"TENDSTR),
+				(__u32)tags, (__u32)obj, (__u32)oh));
+		return;
+	}
+
+	if (oh->type <= YAFFS_OBJECT_TYPE_UNKNOWN ||
+			oh->type > YAFFS_OBJECT_TYPE_MAX)
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header type is illegal value 0x%x"TENDSTR),
+			tags->objectId, oh->type));
+
+	if (tags->objectId != obj->objectId)
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header mismatch objectId %d"TENDSTR),
+			tags->objectId, obj->objectId));
+
+
+	/*
+	 * Check that the object's parent ids match if parentCheck requested.
+	 *
+	 * Tests do not apply to the root object.
+	 */
+
+	if (parentCheck && tags->objectId > 1 && !obj->parent)
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header mismatch parentId %d obj->parent is NULL"TENDSTR),
+			tags->objectId, oh->parentObjectId));
+
+	if (parentCheck && obj->parent &&
+			oh->parentObjectId != obj->parent->objectId &&
+			(oh->parentObjectId != YAFFS_OBJECTID_UNLINKED ||
+			obj->parent->objectId != YAFFS_OBJECTID_DELETED))
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header mismatch parentId %d parentObjectId %d"TENDSTR),
+			tags->objectId, oh->parentObjectId, obj->parent->objectId));
+
+	if (tags->objectId > 1 && oh->name[0] == 0) /* Null name */
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header name is NULL"TENDSTR),
+			obj->objectId));
+
+	if (tags->objectId > 1 && ((__u8)(oh->name[0])) == 0xff) /* Trashed name */
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d header name is 0xFF"TENDSTR),
+			obj->objectId));
+}
+
+
+
+static int yaffs_VerifyTnodeWorker(yaffs_Object *obj, yaffs_Tnode *tn,
+					__u32 level, int chunkOffset)
+{
+	int i;
+	yaffs_Device *dev = obj->myDev;
+	int ok = 1;
+
+	if (tn) {
+		if (level > 0) {
+
+			for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
+				if (tn->internal[i]) {
+					ok = yaffs_VerifyTnodeWorker(obj,
+							tn->internal[i],
+							level - 1,
+							(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);
+				}
+			}
+		} else if (level == 0) {
+			yaffs_ExtendedTags tags;
+			__u32 objectId = obj->objectId;
+
+			chunkOffset <<=  YAFFS_TNODES_LEVEL0_BITS;
+
+			for (i = 0; i < YAFFS_NTNODES_LEVEL0; i++) {
+				__u32 theChunk = yaffs_GetChunkGroupBase(dev, tn, i);
+
+				if (theChunk > 0) {
+					/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),tags.objectId,tags.chunkId,theChunk)); */
+					yaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL, &tags);
+					if (tags.objectId != objectId || tags.chunkId != chunkOffset) {
+						T(~0, (TSTR("Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),
+							objectId, chunkOffset, theChunk,
+							tags.objectId, tags.chunkId));
+					}
+				}
+				chunkOffset++;
+			}
+		}
+	}
+
+	return ok;
+
+}
+
+
+static void yaffs_VerifyFile(yaffs_Object *obj)
+{
+	int requiredTallness;
+	int actualTallness;
+	__u32 lastChunk;
+	__u32 x;
+	__u32 i;
+	yaffs_Device *dev;
+	yaffs_ExtendedTags tags;
+	yaffs_Tnode *tn;
+	__u32 objectId;
+
+	if (!obj)
+		return;
+
+	if (yaffs_SkipVerification(obj->myDev))
+		return;
+
+	dev = obj->myDev;
+	objectId = obj->objectId;
+
+	/* Check file size is consistent with tnode depth */
+	lastChunk =  obj->variant.fileVariant.fileSize / dev->nDataBytesPerChunk + 1;
+	x = lastChunk >> YAFFS_TNODES_LEVEL0_BITS;
+	requiredTallness = 0;
+	while (x > 0) {
+		x >>= YAFFS_TNODES_INTERNAL_BITS;
+		requiredTallness++;
+	}
+
+	actualTallness = obj->variant.fileVariant.topLevel;
+
+	if (requiredTallness > actualTallness)
+		T(YAFFS_TRACE_VERIFY,
+		(TSTR("Obj %d had tnode tallness %d, needs to be %d"TENDSTR),
+		 obj->objectId, actualTallness, requiredTallness));
+
+
+	/* Check that the chunks in the tnode tree are all correct.
+	 * We do this by scanning through the tnode tree and
+	 * checking the tags for every chunk match.
+	 */
+
+	if (yaffs_SkipNANDVerification(dev))
+		return;
+
+	for (i = 1; i <= lastChunk; i++) {
+		tn = yaffs_FindLevel0Tnode(dev, &obj->variant.fileVariant, i);
+
+		if (tn) {
+			__u32 theChunk = yaffs_GetChunkGroupBase(dev, tn, i);
+			if (theChunk > 0) {
+				/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),objectId,i,theChunk)); */
+				yaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL, &tags);
+				if (tags.objectId != objectId || tags.chunkId != i) {
+					T(~0, (TSTR("Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),
+						objectId, i, theChunk,
+						tags.objectId, tags.chunkId));
+				}
+			}
+		}
+	}
+}
+
+
+static void yaffs_VerifyHardLink(yaffs_Object *obj)
+{
+	if (obj && yaffs_SkipVerification(obj->myDev))
+		return;
+
+	/* Verify sane equivalent object */
+}
+
+static void yaffs_VerifySymlink(yaffs_Object *obj)
+{
+	if (obj && yaffs_SkipVerification(obj->myDev))
+		return;
+
+	/* Verify symlink string */
+}
+
+static void yaffs_VerifySpecial(yaffs_Object *obj)
+{
+	if (obj && yaffs_SkipVerification(obj->myDev))
+		return;
+}
+
+static void yaffs_VerifyObject(yaffs_Object *obj)
+{
+	yaffs_Device *dev;
+
+	__u32 chunkMin;
+	__u32 chunkMax;
+
+	__u32 chunkIdOk;
+	__u32 chunkInRange;
+	__u32 chunkShouldNotBeDeleted;
+	__u32 chunkValid;
+
+	if (!obj)
+		return;
+
+	if (obj->beingCreated)
+		return;
+
+	dev = obj->myDev;
+
+	if (yaffs_SkipVerification(dev))
+		return;
+
+	/* Check sane object header chunk */
+
+	chunkMin = dev->internalStartBlock * dev->nChunksPerBlock;
+	chunkMax = (dev->internalEndBlock+1) * dev->nChunksPerBlock - 1;
+
+	chunkInRange = (((unsigned)(obj->hdrChunk)) >= chunkMin && ((unsigned)(obj->hdrChunk)) <= chunkMax);
+	chunkIdOk = chunkInRange || (obj->hdrChunk == 0);
+	chunkValid = chunkInRange &&
+			yaffs_CheckChunkBit(dev,
+					obj->hdrChunk / dev->nChunksPerBlock,
+					obj->hdrChunk % dev->nChunksPerBlock);
+	chunkShouldNotBeDeleted = chunkInRange && !chunkValid;
+
+	if (!obj->fake &&
+			(!chunkIdOk || chunkShouldNotBeDeleted)) {
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d has chunkId %d %s %s"TENDSTR),
+			obj->objectId, obj->hdrChunk,
+			chunkIdOk ? "" : ",out of range",
+			chunkShouldNotBeDeleted ? ",marked as deleted" : ""));
+	}
+
+	if (chunkValid && !yaffs_SkipNANDVerification(dev)) {
+		yaffs_ExtendedTags tags;
+		yaffs_ObjectHeader *oh;
+		__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);
+
+		oh = (yaffs_ObjectHeader *)buffer;
+
+		yaffs_ReadChunkWithTagsFromNAND(dev, obj->hdrChunk, buffer,
+				&tags);
+
+		yaffs_VerifyObjectHeader(obj, oh, &tags, 1);
+
+		yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
+	}
+
+	/* Verify it has a parent */
+	if (obj && !obj->fake &&
+			(!obj->parent || obj->parent->myDev != dev)) {
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d has parent pointer %p which does not look like an object"TENDSTR),
+			obj->objectId, obj->parent));
+	}
+
+	/* Verify parent is a directory */
+	if (obj->parent && obj->parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Obj %d's parent is not a directory (type %d)"TENDSTR),
+			obj->objectId, obj->parent->variantType));
+	}
+
+	switch (obj->variantType) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		yaffs_VerifyFile(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		yaffs_VerifySymlink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		yaffs_VerifyDirectory(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		yaffs_VerifyHardLink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		yaffs_VerifySpecial(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+	default:
+		T(YAFFS_TRACE_VERIFY,
+		(TSTR("Obj %d has illegaltype %d"TENDSTR),
+		obj->objectId, obj->variantType));
+		break;
+	}
+}
+
+static void yaffs_VerifyObjects(yaffs_Device *dev)
+{
+	yaffs_Object *obj;
+	int i;
+	struct ylist_head *lh;
+
+	if (yaffs_SkipVerification(dev))
+		return;
+
+	/* Iterate through the objects in each hash entry */
+
+	for (i = 0; i <  YAFFS_NOBJECT_BUCKETS; i++) {
+		ylist_for_each(lh, &dev->objectBucket[i].list) {
+			if (lh) {
+				obj = ylist_entry(lh, yaffs_Object, hashLink);
+				yaffs_VerifyObject(obj);
+			}
+		}
+	}
+}
+
+
+/*
+ *  Simple hash function. Needs to have a reasonable spread
+ */
+
+static Y_INLINE int yaffs_HashFunction(int n)
+{
+	n = abs(n);
+	return n % YAFFS_NOBJECT_BUCKETS;
+}
+
+/*
+ * Access functions to useful fake objects.
+ * Note that root might have a presence in NAND if permissions are set.
+ */
+
+yaffs_Object *yaffs_Root(yaffs_Device *dev)
+{
+	return dev->rootDir;
+}
+
+yaffs_Object *yaffs_LostNFound(yaffs_Device *dev)
+{
+	return dev->lostNFoundDir;
+}
+
+
+/*
+ *  Erased NAND checking functions
+ */
+
+int yaffs_CheckFF(__u8 *buffer, int nBytes)
+{
+	/* Horrible, slow implementation */
+	while (nBytes--) {
+		if (*buffer != 0xFF)
+			return 0;
+		buffer++;
+	}
+	return 1;
+}
+
+static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,
+				int chunkInNAND)
+{
+	int retval = YAFFS_OK;
+	__u8 *data = yaffs_GetTempBuffer(dev, __LINE__);
+	yaffs_ExtendedTags tags;
+	int result;
+
+	result = yaffs_ReadChunkWithTagsFromNAND(dev, chunkInNAND, data, &tags);
+
+	if (tags.eccResult > YAFFS_ECC_RESULT_NO_ERROR)
+		retval = YAFFS_FAIL;
+
+	if (!yaffs_CheckFF(data, dev->nDataBytesPerChunk) || tags.chunkUsed) {
+		T(YAFFS_TRACE_NANDACCESS,
+		  (TSTR("Chunk %d not erased" TENDSTR), chunkInNAND));
+		retval = YAFFS_FAIL;
+	}
+
+	yaffs_ReleaseTempBuffer(dev, data, __LINE__);
+
+	return retval;
+
+}
+
+static int yaffs_WriteNewChunkWithTagsToNAND(struct yaffs_DeviceStruct *dev,
+					const __u8 *data,
+					yaffs_ExtendedTags *tags,
+					int useReserve)
+{
+	int attempts = 0;
+	int writeOk = 0;
+	int chunk;
+
+	yaffs_InvalidateCheckpoint(dev);
+
+	do {
+		yaffs_BlockInfo *bi = 0;
+		int erasedOk = 0;
+
+		chunk = yaffs_AllocateChunk(dev, useReserve, &bi);
+		if (chunk < 0) {
+			/* no space */
+			break;
+		}
+
+		/* First check this chunk is erased, if it needs
+		 * checking.  The checking policy (unless forced
+		 * always on) is as follows:
+		 *
+		 * Check the first page we try to write in a block.
+		 * If the check passes then we don't need to check any
+		 * more.	If the check fails, we check again...
+		 * If the block has been erased, we don't need to check.
+		 *
+		 * However, if the block has been prioritised for gc,
+		 * then we think there might be something odd about
+		 * this block and stop using it.
+		 *
+		 * Rationale: We should only ever see chunks that have
+		 * not been erased if there was a partially written
+		 * chunk due to power loss.  This checking policy should
+		 * catch that case with very few checks and thus save a
+		 * lot of checks that are most likely not needed.
+		 */
+		if (bi->gcPrioritise) {
+			yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
+			/* try another chunk */
+			continue;
+		}
+
+		/* let's give it a try */
+		attempts++;
+
+#ifdef CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+		bi->skipErasedCheck = 0;
+#endif
+		if (!bi->skipErasedCheck) {
+			erasedOk = yaffs_CheckChunkErased(dev, chunk);
+			if (erasedOk != YAFFS_OK) {
+				T(YAFFS_TRACE_ERROR,
+				(TSTR("**>> yaffs chunk %d was not erased"
+				TENDSTR), chunk));
+
+				/* try another chunk */
+				continue;
+			}
+			bi->skipErasedCheck = 1;
+		}
+
+		writeOk = yaffs_WriteChunkWithTagsToNAND(dev, chunk,
+				data, tags);
+		if (writeOk != YAFFS_OK) {
+			yaffs_HandleWriteChunkError(dev, chunk, erasedOk);
+			/* try another chunk */
+			continue;
+		}
+
+		/* Copy the data into the robustification buffer */
+		yaffs_HandleWriteChunkOk(dev, chunk, data, tags);
+
+	} while (writeOk != YAFFS_OK &&
+		(yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));
+
+	if (!writeOk)
+		chunk = -1;
+
+	if (attempts > 1) {
+		T(YAFFS_TRACE_ERROR,
+			(TSTR("**>> yaffs write required %d attempts" TENDSTR),
+			attempts));
+
+		dev->nRetriedWrites += (attempts - 1);
+	}
+
+	return chunk;
+}
+
+/*
+ * Block retiring for handling a broken block.
+ */
+
+static void yaffs_RetireBlock(yaffs_Device *dev, int blockInNAND)
+{
+	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);
+
+	yaffs_InvalidateCheckpoint(dev);
+
+	if (yaffs_MarkBlockBad(dev, blockInNAND) != YAFFS_OK) {
+		if (yaffs_EraseBlockInNAND(dev, blockInNAND) != YAFFS_OK) {
+			T(YAFFS_TRACE_ALWAYS, (TSTR(
+				"yaffs: Failed to mark bad and erase block %d"
+				TENDSTR), blockInNAND));
+		} else {
+			yaffs_ExtendedTags tags;
+			int chunkId = blockInNAND * dev->nChunksPerBlock;
+
+			__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);
+
+			memset(buffer, 0xff, dev->nDataBytesPerChunk);
+			yaffs_InitialiseTags(&tags);
+			tags.sequenceNumber = YAFFS_SEQUENCE_BAD_BLOCK;
+			if (dev->writeChunkWithTagsToNAND(dev, chunkId -
+				dev->chunkOffset, buffer, &tags) != YAFFS_OK)
+				T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Failed to "
+					TCONT("write bad block marker to block %d")
+					TENDSTR), blockInNAND));
+
+			yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
+		}
+	}
+
+	bi->blockState = YAFFS_BLOCK_STATE_DEAD;
+	bi->gcPrioritise = 0;
+	bi->needsRetiring = 0;
+
+	dev->nRetiredBlocks++;
+}
+
+/*
+ * Functions for robustisizing TODO
+ *
+ */
+
+static void yaffs_HandleWriteChunkOk(yaffs_Device *dev, int chunkInNAND,
+				const __u8 *data,
+				const yaffs_ExtendedTags *tags)
+{
+}
+
+static void yaffs_HandleUpdateChunk(yaffs_Device *dev, int chunkInNAND,
+				const yaffs_ExtendedTags *tags)
+{
+}
+
+void yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi)
+{
+	if (!bi->gcPrioritise) {
+		bi->gcPrioritise = 1;
+		dev->hasPendingPrioritisedGCs = 1;
+		bi->chunkErrorStrikes++;
+
+		if (bi->chunkErrorStrikes > 3) {
+			bi->needsRetiring = 1; /* Too many stikes, so retire this */
+			T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Block struck out" TENDSTR)));
+
+		}
+	}
+}
+
+static void yaffs_HandleWriteChunkError(yaffs_Device *dev, int chunkInNAND,
+		int erasedOk)
+{
+	int blockInNAND = chunkInNAND / dev->nChunksPerBlock;
+	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);
+
+	yaffs_HandleChunkError(dev, bi);
+
+	if (erasedOk) {
+		/* Was an actual write failure, so mark the block for retirement  */
+		bi->needsRetiring = 1;
+		T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		  (TSTR("**>> Block %d needs retiring" TENDSTR), blockInNAND));
+	}
+
+	/* Delete the chunk */
+	yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
+}
+
+
+/*---------------- Name handling functions ------------*/
+
+static __u16 yaffs_CalcNameSum(const YCHAR *name)
+{
+	__u16 sum = 0;
+	__u16 i = 1;
+
+	const YUCHAR *bname = (const YUCHAR *) name;
+	if (bname) {
+		while ((*bname) && (i < (YAFFS_MAX_NAME_LENGTH/2))) {
+
+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE
+			sum += yaffs_toupper(*bname) * i;
+#else
+			sum += (*bname) * i;
+#endif
+			i++;
+			bname++;
+		}
+	}
+	return sum;
+}
+
+static void yaffs_SetObjectName(yaffs_Object *obj, const YCHAR *name)
+{
+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+	memset(obj->shortName, 0, sizeof(YCHAR) * (YAFFS_SHORT_NAME_LENGTH+1));
+	if (name && yaffs_strlen(name) <= YAFFS_SHORT_NAME_LENGTH)
+		yaffs_strcpy(obj->shortName, name);
+	else
+		obj->shortName[0] = _Y('\0');
+#endif
+	obj->sum = yaffs_CalcNameSum(name);
+}
+
+/*-------------------- TNODES -------------------
+
+ * List of spare tnodes
+ * The list is hooked together using the first pointer
+ * in the tnode.
+ */
+
+/* yaffs_CreateTnodes creates a bunch more tnodes and
+ * adds them to the tnode free list.
+ * Don't use this function directly
+ */
+
+static int yaffs_CreateTnodes(yaffs_Device *dev, int nTnodes)
+{
+	int i;
+	int tnodeSize;
+	yaffs_Tnode *newTnodes;
+	__u8 *mem;
+	yaffs_Tnode *curr;
+	yaffs_Tnode *next;
+	yaffs_TnodeList *tnl;
+
+	if (nTnodes < 1)
+		return YAFFS_OK;
+
+	/* Calculate the tnode size in bytes for variable width tnode support.
+	 * Must be a multiple of 32-bits  */
+	tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
+
+	if (tnodeSize < sizeof(yaffs_Tnode))
+		tnodeSize = sizeof(yaffs_Tnode);
+
+	/* make these things */
+
+	newTnodes = YMALLOC(nTnodes * tnodeSize);
+	mem = (__u8 *)newTnodes;
+
+	if (!newTnodes) {
+		T(YAFFS_TRACE_ERROR,
+			(TSTR("yaffs: Could not allocate Tnodes" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	/* Hook them into the free list */
+#if 0
+	for (i = 0; i < nTnodes - 1; i++) {
+		newTnodes[i].internal[0] = &newTnodes[i + 1];
+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+		newTnodes[i].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
+#endif
+	}
+
+	newTnodes[nTnodes - 1].internal[0] = dev->freeTnodes;
+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+	newTnodes[nTnodes - 1].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
+#endif
+	dev->freeTnodes = newTnodes;
+#else
+	/* New hookup for wide tnodes */
+	for (i = 0; i < nTnodes - 1; i++) {
+		curr = (yaffs_Tnode *) &mem[i * tnodeSize];
+		next = (yaffs_Tnode *) &mem[(i+1) * tnodeSize];
+		curr->internal[0] = next;
+	}
+
+	curr = (yaffs_Tnode *) &mem[(nTnodes - 1) * tnodeSize];
+	curr->internal[0] = dev->freeTnodes;
+	dev->freeTnodes = (yaffs_Tnode *)mem;
+
+#endif
+
+
+	dev->nFreeTnodes += nTnodes;
+	dev->nTnodesCreated += nTnodes;
+
+	/* Now add this bunch of tnodes to a list for freeing up.
+	 * NB If we can't add this to the management list it isn't fatal
+	 * but it just means we can't free this bunch of tnodes later.
+	 */
+
+	tnl = YMALLOC(sizeof(yaffs_TnodeList));
+	if (!tnl) {
+		T(YAFFS_TRACE_ERROR,
+		  (TSTR
+		   ("yaffs: Could not add tnodes to management list" TENDSTR)));
+		   return YAFFS_FAIL;
+	} else {
+		tnl->tnodes = newTnodes;
+		tnl->next = dev->allocatedTnodeList;
+		dev->allocatedTnodeList = tnl;
+	}
+
+	T(YAFFS_TRACE_ALLOCATE, (TSTR("yaffs: Tnodes added" TENDSTR)));
+
+	return YAFFS_OK;
+}
+
+/* GetTnode gets us a clean tnode. Tries to make allocate more if we run out */
+
+static yaffs_Tnode *yaffs_GetTnodeRaw(yaffs_Device *dev)
+{
+	yaffs_Tnode *tn = NULL;
+
+	/* If there are none left make more */
+	if (!dev->freeTnodes)
+		yaffs_CreateTnodes(dev, YAFFS_ALLOCATION_NTNODES);
+
+	if (dev->freeTnodes) {
+		tn = dev->freeTnodes;
+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+		if (tn->internal[YAFFS_NTNODES_INTERNAL] != (void *)1) {
+			/* Hoosterman, this thing looks like it isn't in the list */
+			T(YAFFS_TRACE_ALWAYS,
+			  (TSTR("yaffs: Tnode list bug 1" TENDSTR)));
+		}
+#endif
+		dev->freeTnodes = dev->freeTnodes->internal[0];
+		dev->nFreeTnodes--;
+	}
+
+	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
+
+	return tn;
+}
+
+static yaffs_Tnode *yaffs_GetTnode(yaffs_Device *dev)
+{
+	yaffs_Tnode *tn = yaffs_GetTnodeRaw(dev);
+	int tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
+
+	if (tnodeSize < sizeof(yaffs_Tnode))
+		tnodeSize = sizeof(yaffs_Tnode);
+
+	if (tn)
+		memset(tn, 0, tnodeSize);
+
+	return tn;
+}
+
+/* FreeTnode frees up a tnode and puts it back on the free list */
+static void yaffs_FreeTnode(yaffs_Device *dev, yaffs_Tnode *tn)
+{
+	if (tn) {
+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+		if (tn->internal[YAFFS_NTNODES_INTERNAL] != 0) {
+			/* Hoosterman, this thing looks like it is already in the list */
+			T(YAFFS_TRACE_ALWAYS,
+			  (TSTR("yaffs: Tnode list bug 2" TENDSTR)));
+		}
+		tn->internal[YAFFS_NTNODES_INTERNAL] = (void *)1;
+#endif
+		tn->internal[0] = dev->freeTnodes;
+		dev->freeTnodes = tn;
+		dev->nFreeTnodes++;
+	}
+	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
+}
+
+static void yaffs_DeinitialiseTnodes(yaffs_Device *dev)
+{
+	/* Free the list of allocated tnodes */
+	yaffs_TnodeList *tmp;
+
+	while (dev->allocatedTnodeList) {
+		tmp = dev->allocatedTnodeList->next;
+
+		YFREE(dev->allocatedTnodeList->tnodes);
+		YFREE(dev->allocatedTnodeList);
+		dev->allocatedTnodeList = tmp;
+
+	}
+
+	dev->freeTnodes = NULL;
+	dev->nFreeTnodes = 0;
+}
+
+static void yaffs_InitialiseTnodes(yaffs_Device *dev)
+{
+	dev->allocatedTnodeList = NULL;
+	dev->freeTnodes = NULL;
+	dev->nFreeTnodes = 0;
+	dev->nTnodesCreated = 0;
+}
+
+
+void yaffs_PutLevel0Tnode(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos,
+		unsigned val)
+{
+	__u32 *map = (__u32 *)tn;
+	__u32 bitInMap;
+	__u32 bitInWord;
+	__u32 wordInMap;
+	__u32 mask;
+
+	pos &= YAFFS_TNODES_LEVEL0_MASK;
+	val >>= dev->chunkGroupBits;
+
+	bitInMap = pos * dev->tnodeWidth;
+	wordInMap = bitInMap / 32;
+	bitInWord = bitInMap & (32 - 1);
+
+	mask = dev->tnodeMask << bitInWord;
+
+	map[wordInMap] &= ~mask;
+	map[wordInMap] |= (mask & (val << bitInWord));
+
+	if (dev->tnodeWidth > (32 - bitInWord)) {
+		bitInWord = (32 - bitInWord);
+		wordInMap++;;
+		mask = dev->tnodeMask >> (/*dev->tnodeWidth -*/ bitInWord);
+		map[wordInMap] &= ~mask;
+		map[wordInMap] |= (mask & (val >> bitInWord));
+	}
+}
+
+static __u32 yaffs_GetChunkGroupBase(yaffs_Device *dev, yaffs_Tnode *tn,
+		unsigned pos)
+{
+	__u32 *map = (__u32 *)tn;
+	__u32 bitInMap;
+	__u32 bitInWord;
+	__u32 wordInMap;
+	__u32 val;
+
+	pos &= YAFFS_TNODES_LEVEL0_MASK;
+
+	bitInMap = pos * dev->tnodeWidth;
+	wordInMap = bitInMap / 32;
+	bitInWord = bitInMap & (32 - 1);
+
+	val = map[wordInMap] >> bitInWord;
+
+	if	(dev->tnodeWidth > (32 - bitInWord)) {
+		bitInWord = (32 - bitInWord);
+		wordInMap++;;
+		val |= (map[wordInMap] << bitInWord);
+	}
+
+	val &= dev->tnodeMask;
+	val <<= dev->chunkGroupBits;
+
+	return val;
+}
+
+/* ------------------- End of individual tnode manipulation -----------------*/
+
+/* ---------Functions to manipulate the look-up tree (made up of tnodes) ------
+ * The look up tree is represented by the top tnode and the number of topLevel
+ * in the tree. 0 means only the level 0 tnode is in the tree.
+ */
+
+/* FindLevel0Tnode finds the level 0 tnode, if one exists. */
+static yaffs_Tnode *yaffs_FindLevel0Tnode(yaffs_Device *dev,
+					yaffs_FileStructure *fStruct,
+					__u32 chunkId)
+{
+	yaffs_Tnode *tn = fStruct->top;
+	__u32 i;
+	int requiredTallness;
+	int level = fStruct->topLevel;
+
+	/* Check sane level and chunk Id */
+	if (level < 0 || level > YAFFS_TNODES_MAX_LEVEL)
+		return NULL;
+
+	if (chunkId > YAFFS_MAX_CHUNK_ID)
+		return NULL;
+
+	/* First check we're tall enough (ie enough topLevel) */
+
+	i = chunkId >> YAFFS_TNODES_LEVEL0_BITS;
+	requiredTallness = 0;
+	while (i) {
+		i >>= YAFFS_TNODES_INTERNAL_BITS;
+		requiredTallness++;
+	}
+
+	if (requiredTallness > fStruct->topLevel)
+		return NULL; /* Not tall enough, so we can't find it */
+
+	/* Traverse down to level 0 */
+	while (level > 0 && tn) {
+		tn = tn->internal[(chunkId >>
+			(YAFFS_TNODES_LEVEL0_BITS +
+				(level - 1) *
+				YAFFS_TNODES_INTERNAL_BITS)) &
+			YAFFS_TNODES_INTERNAL_MASK];
+		level--;
+	}
+
+	return tn;
+}
+
+/* AddOrFindLevel0Tnode finds the level 0 tnode if it exists, otherwise first expands the tree.
+ * This happens in two steps:
+ *  1. If the tree isn't tall enough, then make it taller.
+ *  2. Scan down the tree towards the level 0 tnode adding tnodes if required.
+ *
+ * Used when modifying the tree.
+ *
+ *  If the tn argument is NULL, then a fresh tnode will be added otherwise the specified tn will
+ *  be plugged into the ttree.
+ */
+
+static yaffs_Tnode *yaffs_AddOrFindLevel0Tnode(yaffs_Device *dev,
+					yaffs_FileStructure *fStruct,
+					__u32 chunkId,
+					yaffs_Tnode *passedTn)
+{
+	int requiredTallness;
+	int i;
+	int l;
+	yaffs_Tnode *tn;
+
+	__u32 x;
+
+
+	/* Check sane level and page Id */
+	if (fStruct->topLevel < 0 || fStruct->topLevel > YAFFS_TNODES_MAX_LEVEL)
+		return NULL;
+
+	if (chunkId > YAFFS_MAX_CHUNK_ID)
+		return NULL;
+
+	/* First check we're tall enough (ie enough topLevel) */
+
+	x = chunkId >> YAFFS_TNODES_LEVEL0_BITS;
+	requiredTallness = 0;
+	while (x) {
+		x >>= YAFFS_TNODES_INTERNAL_BITS;
+		requiredTallness++;
+	}
+
+
+	if (requiredTallness > fStruct->topLevel) {
+		/* Not tall enough, gotta make the tree taller */
+		for (i = fStruct->topLevel; i < requiredTallness; i++) {
+
+			tn = yaffs_GetTnode(dev);
+
+			if (tn) {
+				tn->internal[0] = fStruct->top;
+				fStruct->top = tn;
+			} else {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR("yaffs: no more tnodes" TENDSTR)));
+			}
+		}
+
+		fStruct->topLevel = requiredTallness;
+	}
+
+	/* Traverse down to level 0, adding anything we need */
+
+	l = fStruct->topLevel;
+	tn = fStruct->top;
+
+	if (l > 0) {
+		while (l > 0 && tn) {
+			x = (chunkId >>
+			     (YAFFS_TNODES_LEVEL0_BITS +
+			      (l - 1) * YAFFS_TNODES_INTERNAL_BITS)) &
+			    YAFFS_TNODES_INTERNAL_MASK;
+
+
+			if ((l > 1) && !tn->internal[x]) {
+				/* Add missing non-level-zero tnode */
+				tn->internal[x] = yaffs_GetTnode(dev);
+
+			} else if (l == 1) {
+				/* Looking from level 1 at level 0 */
+				if (passedTn) {
+					/* If we already have one, then release it.*/
+					if (tn->internal[x])
+						yaffs_FreeTnode(dev, tn->internal[x]);
+					tn->internal[x] = passedTn;
+
+				} else if (!tn->internal[x]) {
+					/* Don't have one, none passed in */
+					tn->internal[x] = yaffs_GetTnode(dev);
+				}
+			}
+
+			tn = tn->internal[x];
+			l--;
+		}
+	} else {
+		/* top is level 0 */
+		if (passedTn) {
+			memcpy(tn, passedTn, (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8);
+			yaffs_FreeTnode(dev, passedTn);
+		}
+	}
+
+	return tn;
+}
+
+static int yaffs_FindChunkInGroup(yaffs_Device *dev, int theChunk,
+				yaffs_ExtendedTags *tags, int objectId,
+				int chunkInInode)
+{
+	int j;
+
+	for (j = 0; theChunk && j < dev->chunkGroupSize; j++) {
+		if (yaffs_CheckChunkBit(dev, theChunk / dev->nChunksPerBlock,
+				theChunk % dev->nChunksPerBlock)) {
+			
+			if(dev->chunkGroupSize == 1)
+				return theChunk;
+			else {
+				yaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL,
+								tags);
+				if (yaffs_TagsMatch(tags, objectId, chunkInInode)) {
+					/* found it; */
+					return theChunk;
+				}
+			}
+		}
+		theChunk++;
+	}
+	return -1;
+}
+
+
+/* DeleteWorker scans backwards through the tnode tree and deletes all the
+ * chunks and tnodes in the file
+ * Returns 1 if the tree was deleted.
+ * Returns 0 if it stopped early due to hitting the limit and the delete is incomplete.
+ */
+
+static int yaffs_DeleteWorker(yaffs_Object *in, yaffs_Tnode *tn, __u32 level,
+			      int chunkOffset, int *limit)
+{
+	int i;
+	int chunkInInode;
+	int theChunk;
+	yaffs_ExtendedTags tags;
+	int foundChunk;
+	yaffs_Device *dev = in->myDev;
+
+	int allDone = 1;
+
+	if (tn) {
+		if (level > 0) {
+			for (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;
+			     i--) {
+				if (tn->internal[i]) {
+					if (limit && (*limit) < 0) {
+						allDone = 0;
+					} else {
+						allDone =
+							yaffs_DeleteWorker(in,
+								tn->
+								internal
+								[i],
+								level -
+								1,
+								(chunkOffset
+									<<
+									YAFFS_TNODES_INTERNAL_BITS)
+								+ i,
+								limit);
+					}
+					if (allDone) {
+						yaffs_FreeTnode(dev,
+								tn->
+								internal[i]);
+						tn->internal[i] = NULL;
+					}
+				}
+			}
+			return (allDone) ? 1 : 0;
+		} else if (level == 0) {
+			int hitLimit = 0;
+
+			for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0 && !hitLimit;
+					i--) {
+				theChunk = yaffs_GetChunkGroupBase(dev, tn, i);
+				if (theChunk) {
+
+					chunkInInode = (chunkOffset <<
+						YAFFS_TNODES_LEVEL0_BITS) + i;
+
+					foundChunk =
+						yaffs_FindChunkInGroup(dev,
+								theChunk,
+								&tags,
+								in->objectId,
+								chunkInInode);
+
+					if (foundChunk > 0) {
+						yaffs_DeleteChunk(dev,
+								  foundChunk, 1,
+								  __LINE__);
+						in->nDataChunks--;
+						if (limit) {
+							*limit = *limit - 1;
+							if (*limit <= 0)
+								hitLimit = 1;
+						}
+
+					}
+
+					yaffs_PutLevel0Tnode(dev, tn, i, 0);
+				}
+
+			}
+			return (i < 0) ? 1 : 0;
+
+		}
+
+	}
+
+	return 1;
+
+}
+
+static void yaffs_SoftDeleteChunk(yaffs_Device *dev, int chunk)
+{
+	yaffs_BlockInfo *theBlock;
+
+	T(YAFFS_TRACE_DELETION, (TSTR("soft delete chunk %d" TENDSTR), chunk));
+
+	theBlock = yaffs_GetBlockInfo(dev, chunk / dev->nChunksPerBlock);
+	if (theBlock) {
+		theBlock->softDeletions++;
+		dev->nFreeChunks++;
+	}
+}
+
+/* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all the chunks in the file.
+ * All soft deleting does is increment the block's softdelete count and pulls the chunk out
+ * of the tnode.
+ * Thus, essentially this is the same as DeleteWorker except that the chunks are soft deleted.
+ */
+
+static int yaffs_SoftDeleteWorker(yaffs_Object *in, yaffs_Tnode *tn,
+				  __u32 level, int chunkOffset)
+{
+	int i;
+	int theChunk;
+	int allDone = 1;
+	yaffs_Device *dev = in->myDev;
+
+	if (tn) {
+		if (level > 0) {
+
+			for (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;
+			     i--) {
+				if (tn->internal[i]) {
+					allDone =
+					    yaffs_SoftDeleteWorker(in,
+								   tn->
+								   internal[i],
+								   level - 1,
+								   (chunkOffset
+								    <<
+								    YAFFS_TNODES_INTERNAL_BITS)
+								   + i);
+					if (allDone) {
+						yaffs_FreeTnode(dev,
+								tn->
+								internal[i]);
+						tn->internal[i] = NULL;
+					} else {
+						/* Hoosterman... how could this happen? */
+					}
+				}
+			}
+			return (allDone) ? 1 : 0;
+		} else if (level == 0) {
+
+			for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {
+				theChunk = yaffs_GetChunkGroupBase(dev, tn, i);
+				if (theChunk) {
+					/* Note this does not find the real chunk, only the chunk group.
+					 * We make an assumption that a chunk group is not larger than
+					 * a block.
+					 */
+					yaffs_SoftDeleteChunk(dev, theChunk);
+					yaffs_PutLevel0Tnode(dev, tn, i, 0);
+				}
+
+			}
+			return 1;
+
+		}
+
+	}
+
+	return 1;
+
+}
+
+static void yaffs_SoftDeleteFile(yaffs_Object *obj)
+{
+	if (obj->deleted &&
+	    obj->variantType == YAFFS_OBJECT_TYPE_FILE && !obj->softDeleted) {
+		if (obj->nDataChunks <= 0) {
+			/* Empty file with no duplicate object headers, just delete it immediately */
+			yaffs_FreeTnode(obj->myDev,
+					obj->variant.fileVariant.top);
+			obj->variant.fileVariant.top = NULL;
+			T(YAFFS_TRACE_TRACING,
+			  (TSTR("yaffs: Deleting empty file %d" TENDSTR),
+			   obj->objectId));
+			yaffs_DoGenericObjectDeletion(obj);
+		} else {
+			yaffs_SoftDeleteWorker(obj,
+					       obj->variant.fileVariant.top,
+					       obj->variant.fileVariant.
+					       topLevel, 0);
+			obj->softDeleted = 1;
+		}
+	}
+}
+
+/* Pruning removes any part of the file structure tree that is beyond the
+ * bounds of the file (ie that does not point to chunks).
+ *
+ * A file should only get pruned when its size is reduced.
+ *
+ * Before pruning, the chunks must be pulled from the tree and the
+ * level 0 tnode entries must be zeroed out.
+ * Could also use this for file deletion, but that's probably better handled
+ * by a special case.
+ */
+
+static yaffs_Tnode *yaffs_PruneWorker(yaffs_Device *dev, yaffs_Tnode *tn,
+				__u32 level, int del0)
+{
+	int i;
+	int hasData;
+
+	if (tn) {
+		hasData = 0;
+
+		for (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {
+			if (tn->internal[i] && level > 0) {
+				tn->internal[i] =
+				    yaffs_PruneWorker(dev, tn->internal[i],
+						      level - 1,
+						      (i == 0) ? del0 : 1);
+			}
+
+			if (tn->internal[i])
+				hasData++;
+		}
+
+		if (hasData == 0 && del0) {
+			/* Free and return NULL */
+
+			yaffs_FreeTnode(dev, tn);
+			tn = NULL;
+		}
+
+	}
+
+	return tn;
+
+}
+
+static int yaffs_PruneFileStructure(yaffs_Device *dev,
+				yaffs_FileStructure *fStruct)
+{
+	int i;
+	int hasData;
+	int done = 0;
+	yaffs_Tnode *tn;
+
+	if (fStruct->topLevel > 0) {
+		fStruct->top =
+		    yaffs_PruneWorker(dev, fStruct->top, fStruct->topLevel, 0);
+
+		/* Now we have a tree with all the non-zero branches NULL but the height
+		 * is the same as it was.
+		 * Let's see if we can trim internal tnodes to shorten the tree.
+		 * We can do this if only the 0th element in the tnode is in use
+		 * (ie all the non-zero are NULL)
+		 */
+
+		while (fStruct->topLevel && !done) {
+			tn = fStruct->top;
+
+			hasData = 0;
+			for (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {
+				if (tn->internal[i])
+					hasData++;
+			}
+
+			if (!hasData) {
+				fStruct->top = tn->internal[0];
+				fStruct->topLevel--;
+				yaffs_FreeTnode(dev, tn);
+			} else {
+				done = 1;
+			}
+		}
+	}
+
+	return YAFFS_OK;
+}
+
+/*-------------------- End of File Structure functions.-------------------*/
+
+/* yaffs_CreateFreeObjects creates a bunch more objects and
+ * adds them to the object free list.
+ */
+static int yaffs_CreateFreeObjects(yaffs_Device *dev, int nObjects)
+{
+	int i;
+	yaffs_Object *newObjects;
+	yaffs_ObjectList *list;
+
+	if (nObjects < 1)
+		return YAFFS_OK;
+
+	/* make these things */
+	newObjects = YMALLOC(nObjects * sizeof(yaffs_Object));
+	list = YMALLOC(sizeof(yaffs_ObjectList));
+
+	if (!newObjects || !list) {
+		if (newObjects)
+			YFREE(newObjects);
+		if (list)
+			YFREE(list);
+		T(YAFFS_TRACE_ALLOCATE,
+		  (TSTR("yaffs: Could not allocate more objects" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	/* Hook them into the free list */
+	for (i = 0; i < nObjects - 1; i++) {
+		newObjects[i].siblings.next =
+				(struct ylist_head *)(&newObjects[i + 1]);
+	}
+
+	newObjects[nObjects - 1].siblings.next = (void *)dev->freeObjects;
+	dev->freeObjects = newObjects;
+	dev->nFreeObjects += nObjects;
+	dev->nObjectsCreated += nObjects;
+
+	/* Now add this bunch of Objects to a list for freeing up. */
+
+	list->objects = newObjects;
+	list->next = dev->allocatedObjectList;
+	dev->allocatedObjectList = list;
+
+	return YAFFS_OK;
+}
+
+
+/* AllocateEmptyObject gets us a clean Object. Tries to make allocate more if we run out */
+static yaffs_Object *yaffs_AllocateEmptyObject(yaffs_Device *dev)
+{
+	yaffs_Object *tn = NULL;
+
+#ifdef VALGRIND_TEST
+	tn = YMALLOC(sizeof(yaffs_Object));
+#else
+	/* If there are none left make more */
+	if (!dev->freeObjects)
+		yaffs_CreateFreeObjects(dev, YAFFS_ALLOCATION_NOBJECTS);
+
+	if (dev->freeObjects) {
+		tn = dev->freeObjects;
+		dev->freeObjects =
+			(yaffs_Object *) (dev->freeObjects->siblings.next);
+		dev->nFreeObjects--;
+	}
+#endif
+	if (tn) {
+		/* Now sweeten it up... */
+
+		memset(tn, 0, sizeof(yaffs_Object));
+		tn->beingCreated = 1;
+
+		tn->myDev = dev;
+		tn->hdrChunk = 0;
+		tn->variantType = YAFFS_OBJECT_TYPE_UNKNOWN;
+		YINIT_LIST_HEAD(&(tn->hardLinks));
+		YINIT_LIST_HEAD(&(tn->hashLink));
+		YINIT_LIST_HEAD(&tn->siblings);
+
+
+		/* Now make the directory sane */
+		if (dev->rootDir) {
+			tn->parent = dev->rootDir;
+			ylist_add(&(tn->siblings), &dev->rootDir->variant.directoryVariant.children);
+		}
+
+		/* Add it to the lost and found directory.
+		 * NB Can't put root or lostNFound in lostNFound so
+		 * check if lostNFound exists first
+		 */
+		if (dev->lostNFoundDir)
+			yaffs_AddObjectToDirectory(dev->lostNFoundDir, tn);
+
+		tn->beingCreated = 0;
+	}
+
+	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
+
+	return tn;
+}
+
+static yaffs_Object *yaffs_CreateFakeDirectory(yaffs_Device *dev, int number,
+					       __u32 mode)
+{
+
+	yaffs_Object *obj =
+	    yaffs_CreateNewObject(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);
+	if (obj) {
+		obj->fake = 1;		/* it is fake so it might have no NAND presence... */
+		obj->renameAllowed = 0;	/* ... and we're not allowed to rename it... */
+		obj->unlinkAllowed = 0;	/* ... or unlink it */
+		obj->deleted = 0;
+		obj->unlinked = 0;
+		obj->yst_mode = mode;
+		obj->myDev = dev;
+		obj->hdrChunk = 0;	/* Not a valid chunk. */
+	}
+
+	return obj;
+
+}
+
+static void yaffs_UnhashObject(yaffs_Object *tn)
+{
+	int bucket;
+	yaffs_Device *dev = tn->myDev;
+
+	/* If it is still linked into the bucket list, free from the list */
+	if (!ylist_empty(&tn->hashLink)) {
+		ylist_del_init(&tn->hashLink);
+		bucket = yaffs_HashFunction(tn->objectId);
+		dev->objectBucket[bucket].count--;
+	}
+}
+
+/*  FreeObject frees up a Object and puts it back on the free list */
+static void yaffs_FreeObject(yaffs_Object *tn)
+{
+	yaffs_Device *dev = tn->myDev;
+
+#ifdef __KERNEL__
+	T(YAFFS_TRACE_OS, (TSTR("FreeObject %p inode %p"TENDSTR), tn, tn->myInode));
+#endif
+
+	if (tn->parent)
+		YBUG();
+	if (!ylist_empty(&tn->siblings))
+		YBUG();
+
+
+#ifdef __KERNEL__
+	if (tn->myInode) {
+		/* We're still hooked up to a cached inode.
+		 * Don't delete now, but mark for later deletion
+		 */
+		tn->deferedFree = 1;
+		return;
+	}
+#endif
+
+	yaffs_UnhashObject(tn);
+
+#ifdef VALGRIND_TEST
+	YFREE(tn);
+#else
+	/* Link into the free list. */
+	tn->siblings.next = (struct ylist_head *)(dev->freeObjects);
+	dev->freeObjects = tn;
+	dev->nFreeObjects++;
+#endif
+	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
+}
+
+#ifdef __KERNEL__
+
+void yaffs_HandleDeferedFree(yaffs_Object *obj)
+{
+	if (obj->deferedFree)
+		yaffs_FreeObject(obj);
+}
+
+#endif
+
+static void yaffs_DeinitialiseObjects(yaffs_Device *dev)
+{
+	/* Free the list of allocated Objects */
+
+	yaffs_ObjectList *tmp;
+
+	while (dev->allocatedObjectList) {
+		tmp = dev->allocatedObjectList->next;
+		YFREE(dev->allocatedObjectList->objects);
+		YFREE(dev->allocatedObjectList);
+
+		dev->allocatedObjectList = tmp;
+	}
+
+	dev->freeObjects = NULL;
+	dev->nFreeObjects = 0;
+}
+
+static void yaffs_InitialiseObjects(yaffs_Device *dev)
+{
+	int i;
+
+	dev->allocatedObjectList = NULL;
+	dev->freeObjects = NULL;
+	dev->nFreeObjects = 0;
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		YINIT_LIST_HEAD(&dev->objectBucket[i].list);
+		dev->objectBucket[i].count = 0;
+	}
+}
+
+static int yaffs_FindNiceObjectBucket(yaffs_Device *dev)
+{
+	static int x;
+	int i;
+	int l = 999;
+	int lowest = 999999;
+
+	/* First let's see if we can find one that's empty. */
+
+	for (i = 0; i < 10 && lowest > 0; i++) {
+		x++;
+		x %= YAFFS_NOBJECT_BUCKETS;
+		if (dev->objectBucket[x].count < lowest) {
+			lowest = dev->objectBucket[x].count;
+			l = x;
+		}
+
+	}
+
+	/* If we didn't find an empty list, then try
+	 * looking a bit further for a short one
+	 */
+
+	for (i = 0; i < 10 && lowest > 3; i++) {
+		x++;
+		x %= YAFFS_NOBJECT_BUCKETS;
+		if (dev->objectBucket[x].count < lowest) {
+			lowest = dev->objectBucket[x].count;
+			l = x;
+		}
+
+	}
+
+	return l;
+}
+
+static int yaffs_CreateNewObjectNumber(yaffs_Device *dev)
+{
+	int bucket = yaffs_FindNiceObjectBucket(dev);
+
+	/* Now find an object value that has not already been taken
+	 * by scanning the list.
+	 */
+
+	int found = 0;
+	struct ylist_head *i;
+
+	__u32 n = (__u32) bucket;
+
+	/* yaffs_CheckObjectHashSanity();  */
+
+	while (!found) {
+		found = 1;
+		n += YAFFS_NOBJECT_BUCKETS;
+		if (1 || dev->objectBucket[bucket].count > 0) {
+			ylist_for_each(i, &dev->objectBucket[bucket].list) {
+				/* If there is already one in the list */
+				if (i && ylist_entry(i, yaffs_Object,
+						hashLink)->objectId == n) {
+					found = 0;
+				}
+			}
+		}
+	}
+
+	return n;
+}
+
+static void yaffs_HashObject(yaffs_Object *in)
+{
+	int bucket = yaffs_HashFunction(in->objectId);
+	yaffs_Device *dev = in->myDev;
+
+	ylist_add(&in->hashLink, &dev->objectBucket[bucket].list);
+	dev->objectBucket[bucket].count++;
+}
+
+yaffs_Object *yaffs_FindObjectByNumber(yaffs_Device *dev, __u32 number)
+{
+	int bucket = yaffs_HashFunction(number);
+	struct ylist_head *i;
+	yaffs_Object *in;
+
+	ylist_for_each(i, &dev->objectBucket[bucket].list) {
+		/* Look if it is in the list */
+		if (i) {
+			in = ylist_entry(i, yaffs_Object, hashLink);
+			if (in->objectId == number) {
+#ifdef __KERNEL__
+				/* Don't tell the VFS about this one if it is defered free */
+				if (in->deferedFree)
+					return NULL;
+#endif
+
+				return in;
+			}
+		}
+	}
+
+	return NULL;
+}
+
+yaffs_Object *yaffs_CreateNewObject(yaffs_Device *dev, int number,
+				    yaffs_ObjectType type)
+{
+	yaffs_Object *theObject;
+	yaffs_Tnode *tn = NULL;
+
+	if (number < 0)
+		number = yaffs_CreateNewObjectNumber(dev);
+
+	theObject = yaffs_AllocateEmptyObject(dev);
+	if (!theObject)
+		return NULL;
+
+	if (type == YAFFS_OBJECT_TYPE_FILE) {
+		tn = yaffs_GetTnode(dev);
+		if (!tn) {
+			yaffs_FreeObject(theObject);
+			return NULL;
+		}
+	}
+
+	if (theObject) {
+		theObject->fake = 0;
+		theObject->renameAllowed = 1;
+		theObject->unlinkAllowed = 1;
+		theObject->objectId = number;
+		yaffs_HashObject(theObject);
+		theObject->variantType = type;
+#ifdef CONFIG_YAFFS_WINCE
+		yfsd_WinFileTimeNow(theObject->win_atime);
+		theObject->win_ctime[0] = theObject->win_mtime[0] =
+		    theObject->win_atime[0];
+		theObject->win_ctime[1] = theObject->win_mtime[1] =
+		    theObject->win_atime[1];
+
+#else
+
+		theObject->yst_atime = theObject->yst_mtime =
+		    theObject->yst_ctime = Y_CURRENT_TIME;
+#endif
+		switch (type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			theObject->variant.fileVariant.fileSize = 0;
+			theObject->variant.fileVariant.scannedFileSize = 0;
+			theObject->variant.fileVariant.shrinkSize = 0xFFFFFFFF;	/* max __u32 */
+			theObject->variant.fileVariant.topLevel = 0;
+			theObject->variant.fileVariant.top = tn;
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			YINIT_LIST_HEAD(&theObject->variant.directoryVariant.
+					children);
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+			/* No action required */
+			break;
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+			/* todo this should not happen */
+			break;
+		}
+	}
+
+	return theObject;
+}
+
+static yaffs_Object *yaffs_FindOrCreateObjectByNumber(yaffs_Device *dev,
+						      int number,
+						      yaffs_ObjectType type)
+{
+	yaffs_Object *theObject = NULL;
+
+	if (number > 0)
+		theObject = yaffs_FindObjectByNumber(dev, number);
+
+	if (!theObject)
+		theObject = yaffs_CreateNewObject(dev, number, type);
+
+	return theObject;
+
+}
+
+
+static YCHAR *yaffs_CloneString(const YCHAR *str)
+{
+	YCHAR *newStr = NULL;
+
+	if (str && *str) {
+		newStr = YMALLOC((yaffs_strlen(str) + 1) * sizeof(YCHAR));
+		if (newStr)
+			yaffs_strcpy(newStr, str);
+	}
+
+	return newStr;
+
+}
+
+/*
+ * Mknod (create) a new object.
+ * equivalentObject only has meaning for a hard link;
+ * aliasString only has meaning for a sumlink.
+ * rdev only has meaning for devices (a subset of special objects)
+ */
+
+static yaffs_Object *yaffs_MknodObject(yaffs_ObjectType type,
+				       yaffs_Object *parent,
+				       const YCHAR *name,
+				       __u32 mode,
+				       __u32 uid,
+				       __u32 gid,
+				       yaffs_Object *equivalentObject,
+				       const YCHAR *aliasString, __u32 rdev)
+{
+	yaffs_Object *in;
+	YCHAR *str = NULL;
+
+	yaffs_Device *dev = parent->myDev;
+
+	/* Check if the entry exists. If it does then fail the call since we don't want a dup.*/
+	if (yaffs_FindObjectByName(parent, name))
+		return NULL;
+
+	in = yaffs_CreateNewObject(dev, -1, type);
+
+	if (!in)
+		return YAFFS_FAIL;
+
+	if (type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		str = yaffs_CloneString(aliasString);
+		if (!str) {
+			yaffs_FreeObject(in);
+			return NULL;
+		}
+	}
+
+
+
+	if (in) {
+		in->hdrChunk = 0;
+		in->valid = 1;
+		in->variantType = type;
+
+		in->yst_mode = mode;
+
+#ifdef CONFIG_YAFFS_WINCE
+		yfsd_WinFileTimeNow(in->win_atime);
+		in->win_ctime[0] = in->win_mtime[0] = in->win_atime[0];
+		in->win_ctime[1] = in->win_mtime[1] = in->win_atime[1];
+
+#else
+		in->yst_atime = in->yst_mtime = in->yst_ctime = Y_CURRENT_TIME;
+
+		in->yst_rdev = rdev;
+		in->yst_uid = uid;
+		in->yst_gid = gid;
+#endif
+		in->nDataChunks = 0;
+
+		yaffs_SetObjectName(in, name);
+		in->dirty = 1;
+
+		yaffs_AddObjectToDirectory(parent, in);
+
+		in->myDev = parent->myDev;
+
+		switch (type) {
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			in->variant.symLinkVariant.alias = str;
+			break;
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+			in->variant.hardLinkVariant.equivalentObject =
+				equivalentObject;
+			in->variant.hardLinkVariant.equivalentObjectId =
+				equivalentObject->objectId;
+			ylist_add(&in->hardLinks, &equivalentObject->hardLinks);
+			break;
+		case YAFFS_OBJECT_TYPE_FILE:
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+			/* do nothing */
+			break;
+		}
+
+		if (yaffs_UpdateObjectHeader(in, name, 0, 0, 0) < 0) {
+			/* Could not create the object header, fail the creation */
+			yaffs_DeleteObject(in);
+			in = NULL;
+		}
+
+		yaffs_UpdateParent(parent);
+	}
+
+	return in;
+}
+
+yaffs_Object *yaffs_MknodFile(yaffs_Object *parent, const YCHAR *name,
+			__u32 mode, __u32 uid, __u32 gid)
+{
+	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,
+				uid, gid, NULL, NULL, 0);
+}
+
+yaffs_Object *yaffs_MknodDirectory(yaffs_Object *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid)
+{
+	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,
+				 mode, uid, gid, NULL, NULL, 0);
+}
+
+yaffs_Object *yaffs_MknodSpecial(yaffs_Object *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid, __u32 rdev)
+{
+	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,
+				 uid, gid, NULL, NULL, rdev);
+}
+
+yaffs_Object *yaffs_MknodSymLink(yaffs_Object *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid,
+				const YCHAR *alias)
+{
+	return yaffs_MknodObject(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,
+				uid, gid, NULL, alias, 0);
+}
+
+/* yaffs_Link returns the object id of the equivalent object.*/
+yaffs_Object *yaffs_Link(yaffs_Object *parent, const YCHAR *name,
+			yaffs_Object *equivalentObject)
+{
+	/* Get the real object in case we were fed a hard link as an equivalent object */
+	equivalentObject = yaffs_GetEquivalentObject(equivalentObject);
+
+	if (yaffs_MknodObject
+	    (YAFFS_OBJECT_TYPE_HARDLINK, parent, name, 0, 0, 0,
+	     equivalentObject, NULL, 0)) {
+		return equivalentObject;
+	} else {
+		return NULL;
+	}
+
+}
+
+static int yaffs_ChangeObjectName(yaffs_Object *obj, yaffs_Object *newDir,
+				const YCHAR *newName, int force, int shadows)
+{
+	int unlinkOp;
+	int deleteOp;
+
+	yaffs_Object *existingTarget;
+
+	if (newDir == NULL)
+		newDir = obj->parent;	/* use the old directory */
+
+	if (newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_ChangeObjectName: newDir is not a directory"
+		    TENDSTR)));
+		YBUG();
+	}
+
+	/* TODO: Do we need this different handling for YAFFS2 and YAFFS1?? */
+	if (obj->myDev->isYaffs2)
+		unlinkOp = (newDir == obj->myDev->unlinkedDir);
+	else
+		unlinkOp = (newDir == obj->myDev->unlinkedDir
+			    && obj->variantType == YAFFS_OBJECT_TYPE_FILE);
+
+	deleteOp = (newDir == obj->myDev->deletedDir);
+
+	existingTarget = yaffs_FindObjectByName(newDir, newName);
+
+	/* If the object is a file going into the unlinked directory,
+	 *   then it is OK to just stuff it in since duplicate names are allowed.
+	 *   else only proceed if the new name does not exist and if we're putting
+	 *   it into a directory.
+	 */
+	if ((unlinkOp ||
+	     deleteOp ||
+	     force ||
+	     (shadows > 0) ||
+	     !existingTarget) &&
+	    newDir->variantType == YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_SetObjectName(obj, newName);
+		obj->dirty = 1;
+
+		yaffs_AddObjectToDirectory(newDir, obj);
+
+		if (unlinkOp)
+			obj->unlinked = 1;
+
+		/* If it is a deletion then we mark it as a shrink for gc purposes. */
+		if (yaffs_UpdateObjectHeader(obj, newName, 0, deleteOp, shadows) >= 0)
+			return YAFFS_OK;
+	}
+
+	return YAFFS_FAIL;
+}
+
+int yaffs_RenameObject(yaffs_Object *oldDir, const YCHAR *oldName,
+		yaffs_Object *newDir, const YCHAR *newName)
+{
+	yaffs_Object *obj = NULL;
+	yaffs_Object *existingTarget = NULL;
+	int force = 0;
+	int result;
+	yaffs_Device *dev;
+
+
+	if (!oldDir || oldDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+		YBUG();
+	if (!newDir || newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+		YBUG();
+
+	dev = oldDir->myDev;
+
+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE
+	/* Special case for case insemsitive systems (eg. WinCE).
+	 * While look-up is case insensitive, the name isn't.
+	 * Therefore we might want to change x.txt to X.txt
+	*/
+	if (oldDir == newDir && yaffs_strcmp(oldName, newName) == 0)
+		force = 1;
+#endif
+
+	if(yaffs_strlen(newName) > YAFFS_MAX_NAME_LENGTH)
+		/* ENAMETOOLONG */
+		return YAFFS_FAIL;
+
+	obj = yaffs_FindObjectByName(oldDir, oldName);
+
+	if (obj && obj->renameAllowed) {
+
+		/* Now do the handling for an existing target, if there is one */
+
+		existingTarget = yaffs_FindObjectByName(newDir, newName);
+		if (existingTarget &&
+			existingTarget->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&
+			!ylist_empty(&existingTarget->variant.directoryVariant.children)) {
+			/* There is a target that is a non-empty directory, so we fail */
+			return YAFFS_FAIL;	/* EEXIST or ENOTEMPTY */
+		} else if (existingTarget && existingTarget != obj) {
+			/* Nuke the target first, using shadowing,
+			 * but only if it isn't the same object.
+			 *
+			 * Note we must disable gc otherwise it can mess up the shadowing.
+			 *
+			 */
+			dev->isDoingGC=1;
+			yaffs_ChangeObjectName(obj, newDir, newName, force,
+						existingTarget->objectId);
+			existingTarget->isShadowed = 1;
+			yaffs_UnlinkObject(existingTarget);
+			dev->isDoingGC=0;
+		}
+
+		result = yaffs_ChangeObjectName(obj, newDir, newName, 1, 0);
+
+		yaffs_UpdateParent(oldDir);
+		if(newDir != oldDir)
+			yaffs_UpdateParent(newDir);
+
+		return result;
+	}
+	return YAFFS_FAIL;
+}
+
+/*------------------------- Block Management and Page Allocation ----------------*/
+
+static int yaffs_InitialiseBlocks(yaffs_Device *dev)
+{
+	int nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;
+
+	dev->blockInfo = NULL;
+	dev->chunkBits = NULL;
+
+	dev->allocationBlock = -1;	/* force it to get a new one */
+
+	/* If the first allocation strategy fails, thry the alternate one */
+	dev->blockInfo = YMALLOC(nBlocks * sizeof(yaffs_BlockInfo));
+	if (!dev->blockInfo) {
+		dev->blockInfo = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockInfo));
+		dev->blockInfoAlt = 1;
+	} else
+		dev->blockInfoAlt = 0;
+
+	if (dev->blockInfo) {
+		/* Set up dynamic blockinfo stuff. */
+		dev->chunkBitmapStride = (dev->nChunksPerBlock + 7) / 8; /* round up bytes */
+		dev->chunkBits = YMALLOC(dev->chunkBitmapStride * nBlocks);
+		if (!dev->chunkBits) {
+			dev->chunkBits = YMALLOC_ALT(dev->chunkBitmapStride * nBlocks);
+			dev->chunkBitsAlt = 1;
+		} else
+			dev->chunkBitsAlt = 0;
+	}
+
+	if (dev->blockInfo && dev->chunkBits) {
+		memset(dev->blockInfo, 0, nBlocks * sizeof(yaffs_BlockInfo));
+		memset(dev->chunkBits, 0, dev->chunkBitmapStride * nBlocks);
+		return YAFFS_OK;
+	}
+
+	return YAFFS_FAIL;
+}
+
+static void yaffs_DeinitialiseBlocks(yaffs_Device *dev)
+{
+	if (dev->blockInfoAlt && dev->blockInfo)
+		YFREE_ALT(dev->blockInfo);
+	else if (dev->blockInfo)
+		YFREE(dev->blockInfo);
+
+	dev->blockInfoAlt = 0;
+
+	dev->blockInfo = NULL;
+
+	if (dev->chunkBitsAlt && dev->chunkBits)
+		YFREE_ALT(dev->chunkBits);
+	else if (dev->chunkBits)
+		YFREE(dev->chunkBits);
+	dev->chunkBitsAlt = 0;
+	dev->chunkBits = NULL;
+}
+
+static int yaffs_BlockNotDisqualifiedFromGC(yaffs_Device *dev,
+					yaffs_BlockInfo *bi)
+{
+	int i;
+	__u32 seq;
+	yaffs_BlockInfo *b;
+
+	if (!dev->isYaffs2)
+		return 1;	/* disqualification only applies to yaffs2. */
+
+	if (!bi->hasShrinkHeader)
+		return 1;	/* can gc */
+
+	/* Find the oldest dirty sequence number if we don't know it and save it
+	 * so we don't have to keep recomputing it.
+	 */
+	if (!dev->oldestDirtySequence) {
+		seq = dev->sequenceNumber;
+
+		for (i = dev->internalStartBlock; i <= dev->internalEndBlock;
+				i++) {
+			b = yaffs_GetBlockInfo(dev, i);
+			if (b->blockState == YAFFS_BLOCK_STATE_FULL &&
+			    (b->pagesInUse - b->softDeletions) <
+			    dev->nChunksPerBlock && b->sequenceNumber < seq) {
+				seq = b->sequenceNumber;
+			}
+		}
+		dev->oldestDirtySequence = seq;
+	}
+
+	/* Can't do gc of this block if there are any blocks older than this one that have
+	 * discarded pages.
+	 */
+	return (bi->sequenceNumber <= dev->oldestDirtySequence);
+}
+
+/* FindDiretiestBlock is used to select the dirtiest block (or close enough)
+ * for garbage collection.
+ */
+
+static int yaffs_FindBlockForGarbageCollection(yaffs_Device *dev,
+					int aggressive)
+{
+	int b = dev->currentDirtyChecker;
+
+	int i;
+	int iterations;
+	int dirtiest = -1;
+	int pagesInUse = 0;
+	int prioritised = 0;
+	yaffs_BlockInfo *bi;
+	int pendingPrioritisedExist = 0;
+
+	/* First let's see if we need to grab a prioritised block */
+	if (dev->hasPendingPrioritisedGCs) {
+		for (i = dev->internalStartBlock; i < dev->internalEndBlock && !prioritised; i++) {
+
+			bi = yaffs_GetBlockInfo(dev, i);
+			/* yaffs_VerifyBlock(dev,bi,i); */
+
+			if (bi->gcPrioritise) {
+				pendingPrioritisedExist = 1;
+				if (bi->blockState == YAFFS_BLOCK_STATE_FULL &&
+				   yaffs_BlockNotDisqualifiedFromGC(dev, bi)) {
+					pagesInUse = (bi->pagesInUse - bi->softDeletions);
+					dirtiest = i;
+					prioritised = 1;
+					aggressive = 1; /* Fool the non-aggressive skip logiv below */
+				}
+			}
+		}
+
+		if (!pendingPrioritisedExist) /* None found, so we can clear this */
+			dev->hasPendingPrioritisedGCs = 0;
+	}
+
+	/* If we're doing aggressive GC then we are happy to take a less-dirty block, and
+	 * search harder.
+	 * else (we're doing a leasurely gc), then we only bother to do this if the
+	 * block has only a few pages in use.
+	 */
+
+	dev->nonAggressiveSkip--;
+
+	if (!aggressive && (dev->nonAggressiveSkip > 0))
+		return -1;
+
+	if (!prioritised)
+		pagesInUse =
+			(aggressive) ? dev->nChunksPerBlock : YAFFS_PASSIVE_GC_CHUNKS + 1;
+
+	if (aggressive)
+		iterations =
+		    dev->internalEndBlock - dev->internalStartBlock + 1;
+	else {
+		iterations =
+		    dev->internalEndBlock - dev->internalStartBlock + 1;
+		iterations = iterations / 16;
+		if (iterations > 200)
+			iterations = 200;
+	}
+
+	for (i = 0; i <= iterations && pagesInUse > 0 && !prioritised; i++) {
+		b++;
+		if (b < dev->internalStartBlock || b > dev->internalEndBlock)
+			b = dev->internalStartBlock;
+
+		if (b < dev->internalStartBlock || b > dev->internalEndBlock) {
+			T(YAFFS_TRACE_ERROR,
+			  (TSTR("**>> Block %d is not valid" TENDSTR), b));
+			YBUG();
+		}
+
+		bi = yaffs_GetBlockInfo(dev, b);
+
+		if (bi->blockState == YAFFS_BLOCK_STATE_FULL &&
+			(bi->pagesInUse - bi->softDeletions) < pagesInUse &&
+				yaffs_BlockNotDisqualifiedFromGC(dev, bi)) {
+			dirtiest = b;
+			pagesInUse = (bi->pagesInUse - bi->softDeletions);
+		}
+	}
+
+	dev->currentDirtyChecker = b;
+
+	if (dirtiest > 0) {
+		T(YAFFS_TRACE_GC,
+		  (TSTR("GC Selected block %d with %d free, prioritised:%d" TENDSTR), dirtiest,
+		   dev->nChunksPerBlock - pagesInUse, prioritised));
+	}
+
+	dev->oldestDirtySequence = 0;
+
+	if (dirtiest > 0)
+		dev->nonAggressiveSkip = 4;
+
+	return dirtiest;
+}
+
+static void yaffs_BlockBecameDirty(yaffs_Device *dev, int blockNo)
+{
+	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockNo);
+
+	int erasedOk = 0;
+
+	/* If the block is still healthy erase it and mark as clean.
+	 * If the block has had a data failure, then retire it.
+	 */
+
+	T(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,
+		(TSTR("yaffs_BlockBecameDirty block %d state %d %s"TENDSTR),
+		blockNo, bi->blockState, (bi->needsRetiring) ? "needs retiring" : ""));
+
+	bi->blockState = YAFFS_BLOCK_STATE_DIRTY;
+
+	if (!bi->needsRetiring) {
+		yaffs_InvalidateCheckpoint(dev);
+		erasedOk = yaffs_EraseBlockInNAND(dev, blockNo);
+		if (!erasedOk) {
+			dev->nErasureFailures++;
+			T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+			  (TSTR("**>> Erasure failed %d" TENDSTR), blockNo));
+		}
+	}
+
+	if (erasedOk &&
+	    ((yaffs_traceMask & YAFFS_TRACE_ERASE) || !yaffs_SkipVerification(dev))) {
+		int i;
+		for (i = 0; i < dev->nChunksPerBlock; i++) {
+			if (!yaffs_CheckChunkErased
+			    (dev, blockNo * dev->nChunksPerBlock + i)) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   (">>Block %d erasure supposedly OK, but chunk %d not erased"
+				    TENDSTR), blockNo, i));
+			}
+		}
+	}
+
+	if (erasedOk) {
+		/* Clean it up... */
+		bi->blockState = YAFFS_BLOCK_STATE_EMPTY;
+		dev->nErasedBlocks++;
+		bi->pagesInUse = 0;
+		bi->softDeletions = 0;
+		bi->hasShrinkHeader = 0;
+		bi->skipErasedCheck = 1;  /* This is clean, so no need to check */
+		bi->gcPrioritise = 0;
+		yaffs_ClearChunkBits(dev, blockNo);
+
+		T(YAFFS_TRACE_ERASE,
+		  (TSTR("Erased block %d" TENDSTR), blockNo));
+	} else {
+		dev->nFreeChunks -= dev->nChunksPerBlock;	/* We lost a block of free space */
+
+		yaffs_RetireBlock(dev, blockNo);
+		T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		  (TSTR("**>> Block %d retired" TENDSTR), blockNo));
+	}
+}
+
+static int yaffs_FindBlockForAllocation(yaffs_Device *dev)
+{
+	int i;
+
+	yaffs_BlockInfo *bi;
+
+	if (dev->nErasedBlocks < 1) {
+		/* Hoosterman we've got a problem.
+		 * Can't get space to gc
+		 */
+		T(YAFFS_TRACE_ERROR,
+		  (TSTR("yaffs tragedy: no more erased blocks" TENDSTR)));
+
+		return -1;
+	}
+
+	/* Find an empty block. */
+
+	for (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {
+		dev->allocationBlockFinder++;
+		if (dev->allocationBlockFinder < dev->internalStartBlock
+		    || dev->allocationBlockFinder > dev->internalEndBlock) {
+			dev->allocationBlockFinder = dev->internalStartBlock;
+		}
+
+		bi = yaffs_GetBlockInfo(dev, dev->allocationBlockFinder);
+
+		if (bi->blockState == YAFFS_BLOCK_STATE_EMPTY) {
+			bi->blockState = YAFFS_BLOCK_STATE_ALLOCATING;
+			dev->sequenceNumber++;
+			bi->sequenceNumber = dev->sequenceNumber;
+			dev->nErasedBlocks--;
+			T(YAFFS_TRACE_ALLOCATE,
+			  (TSTR("Allocated block %d, seq  %d, %d left" TENDSTR),
+			   dev->allocationBlockFinder, dev->sequenceNumber,
+			   dev->nErasedBlocks));
+			return dev->allocationBlockFinder;
+		}
+	}
+
+	T(YAFFS_TRACE_ALWAYS,
+	  (TSTR
+	   ("yaffs tragedy: no more erased blocks, but there should have been %d"
+	    TENDSTR), dev->nErasedBlocks));
+
+	return -1;
+}
+
+
+
+static int yaffs_CalcCheckpointBlocksRequired(yaffs_Device *dev)
+{
+	if (!dev->nCheckpointBlocksRequired &&
+	   dev->isYaffs2) {
+		/* Not a valid value so recalculate */
+		int nBytes = 0;
+		int nBlocks;
+		int devBlocks = (dev->endBlock - dev->startBlock + 1);
+		int tnodeSize;
+
+		tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
+
+		if (tnodeSize < sizeof(yaffs_Tnode))
+			tnodeSize = sizeof(yaffs_Tnode);
+
+		nBytes += sizeof(yaffs_CheckpointValidity);
+		nBytes += sizeof(yaffs_CheckpointDevice);
+		nBytes += devBlocks * sizeof(yaffs_BlockInfo);
+		nBytes += devBlocks * dev->chunkBitmapStride;
+		nBytes += (sizeof(yaffs_CheckpointObject) + sizeof(__u32)) * (dev->nObjectsCreated - dev->nFreeObjects);
+		nBytes += (tnodeSize + sizeof(__u32)) * (dev->nTnodesCreated - dev->nFreeTnodes);
+		nBytes += sizeof(yaffs_CheckpointValidity);
+		nBytes += sizeof(__u32); /* checksum*/
+
+		/* Round up and add 2 blocks to allow for some bad blocks, so add 3 */
+
+		nBlocks = (nBytes/(dev->nDataBytesPerChunk * dev->nChunksPerBlock)) + 3;
+
+		dev->nCheckpointBlocksRequired = nBlocks;
+	}
+
+	return dev->nCheckpointBlocksRequired;
+}
+
+/*
+ * Check if there's space to allocate...
+ * Thinks.... do we need top make this ths same as yaffs_GetFreeChunks()?
+ */
+static int yaffs_CheckSpaceForAllocation(yaffs_Device *dev)
+{
+	int reservedChunks;
+	int reservedBlocks = dev->nReservedBlocks;
+	int checkpointBlocks;
+
+	if (dev->isYaffs2) {
+		checkpointBlocks =  yaffs_CalcCheckpointBlocksRequired(dev) -
+				    dev->blocksInCheckpoint;
+		if (checkpointBlocks < 0)
+			checkpointBlocks = 0;
+	} else {
+		checkpointBlocks = 0;
+	}
+
+	reservedChunks = ((reservedBlocks + checkpointBlocks) * dev->nChunksPerBlock);
+
+	return (dev->nFreeChunks > reservedChunks);
+}
+
+static int yaffs_AllocateChunk(yaffs_Device *dev, int useReserve,
+		yaffs_BlockInfo **blockUsedPtr)
+{
+	int retVal;
+	yaffs_BlockInfo *bi;
+
+	if (dev->allocationBlock < 0) {
+		/* Get next block to allocate off */
+		dev->allocationBlock = yaffs_FindBlockForAllocation(dev);
+		dev->allocationPage = 0;
+	}
+
+	if (!useReserve && !yaffs_CheckSpaceForAllocation(dev)) {
+		/* Not enough space to allocate unless we're allowed to use the reserve. */
+		return -1;
+	}
+
+	if (dev->nErasedBlocks < dev->nReservedBlocks
+			&& dev->allocationPage == 0) {
+		T(YAFFS_TRACE_ALLOCATE, (TSTR("Allocating reserve" TENDSTR)));
+	}
+
+	/* Next page please.... */
+	if (dev->allocationBlock >= 0) {
+		bi = yaffs_GetBlockInfo(dev, dev->allocationBlock);
+
+		retVal = (dev->allocationBlock * dev->nChunksPerBlock) +
+			dev->allocationPage;
+		bi->pagesInUse++;
+		yaffs_SetChunkBit(dev, dev->allocationBlock,
+				dev->allocationPage);
+
+		dev->allocationPage++;
+
+		dev->nFreeChunks--;
+
+		/* If the block is full set the state to full */
+		if (dev->allocationPage >= dev->nChunksPerBlock) {
+			bi->blockState = YAFFS_BLOCK_STATE_FULL;
+			dev->allocationBlock = -1;
+		}
+
+		if (blockUsedPtr)
+			*blockUsedPtr = bi;
+
+		return retVal;
+	}
+
+	T(YAFFS_TRACE_ERROR,
+			(TSTR("!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!" TENDSTR)));
+
+	return -1;
+}
+
+static int yaffs_GetErasedChunks(yaffs_Device *dev)
+{
+	int n;
+
+	n = dev->nErasedBlocks * dev->nChunksPerBlock;
+
+	if (dev->allocationBlock > 0)
+		n += (dev->nChunksPerBlock - dev->allocationPage);
+
+	return n;
+
+}
+
+static int yaffs_GarbageCollectBlock(yaffs_Device *dev, int block,
+		int wholeBlock)
+{
+	int oldChunk;
+	int newChunk;
+	int markNAND;
+	int retVal = YAFFS_OK;
+	int cleanups = 0;
+	int i;
+	int isCheckpointBlock;
+	int matchingChunk;
+	int maxCopies;
+
+	int chunksBefore = yaffs_GetErasedChunks(dev);
+	int chunksAfter;
+
+	yaffs_ExtendedTags tags;
+
+	yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, block);
+
+	yaffs_Object *object;
+
+	isCheckpointBlock = (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT);
+
+
+	T(YAFFS_TRACE_TRACING,
+			(TSTR("Collecting block %d, in use %d, shrink %d, wholeBlock %d" TENDSTR),
+			 block,
+			 bi->pagesInUse,
+			 bi->hasShrinkHeader,
+			 wholeBlock));
+
+	/*yaffs_VerifyFreeChunks(dev); */
+
+	if(bi->blockState == YAFFS_BLOCK_STATE_FULL)
+		bi->blockState = YAFFS_BLOCK_STATE_COLLECTING;
+	
+	bi->hasShrinkHeader = 0;	/* clear the flag so that the block can erase */
+
+	/* Take off the number of soft deleted entries because
+	 * they're going to get really deleted during GC.
+	 */
+	if(dev->gcChunk == 0) /* first time through for this block */
+		dev->nFreeChunks -= bi->softDeletions;
+
+	dev->isDoingGC = 1;
+
+	if (isCheckpointBlock ||
+			!yaffs_StillSomeChunkBits(dev, block)) {
+		T(YAFFS_TRACE_TRACING,
+				(TSTR
+				 ("Collecting block %d that has no chunks in use" TENDSTR),
+				 block));
+		yaffs_BlockBecameDirty(dev, block);
+	} else {
+
+		__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);
+
+		yaffs_VerifyBlock(dev, bi, block);
+
+		maxCopies = (wholeBlock) ? dev->nChunksPerBlock : 10;
+		oldChunk = block * dev->nChunksPerBlock + dev->gcChunk;
+
+		for (/* init already done */;
+		     retVal == YAFFS_OK &&
+		     dev->gcChunk < dev->nChunksPerBlock &&
+		     (bi->blockState == YAFFS_BLOCK_STATE_COLLECTING) &&
+		     maxCopies > 0;
+		     dev->gcChunk++, oldChunk++) {
+			if (yaffs_CheckChunkBit(dev, block, dev->gcChunk)) {
+
+				/* This page is in use and might need to be copied off */
+
+				maxCopies--;
+
+				markNAND = 1;
+
+				yaffs_InitialiseTags(&tags);
+
+				yaffs_ReadChunkWithTagsFromNAND(dev, oldChunk,
+								buffer, &tags);
+
+				object =
+				    yaffs_FindObjectByNumber(dev,
+							     tags.objectId);
+
+				T(YAFFS_TRACE_GC_DETAIL,
+				  (TSTR
+				   ("Collecting chunk in block %d, %d %d %d " TENDSTR),
+				   dev->gcChunk, tags.objectId, tags.chunkId,
+				   tags.byteCount));
+
+				if (object && !yaffs_SkipVerification(dev)) {
+					if (tags.chunkId == 0)
+						matchingChunk = object->hdrChunk;
+					else if (object->softDeleted)
+						matchingChunk = oldChunk; /* Defeat the test */
+					else
+						matchingChunk = yaffs_FindChunkInFile(object, tags.chunkId, NULL);
+
+					if (oldChunk != matchingChunk)
+						T(YAFFS_TRACE_ERROR,
+						  (TSTR("gc: page in gc mismatch: %d %d %d %d"TENDSTR),
+						  oldChunk, matchingChunk, tags.objectId, tags.chunkId));
+
+				}
+
+				if (!object) {
+					T(YAFFS_TRACE_ERROR,
+					  (TSTR
+					   ("page %d in gc has no object: %d %d %d "
+					    TENDSTR), oldChunk,
+					    tags.objectId, tags.chunkId, tags.byteCount));
+				}
+
+				if (object &&
+				    object->deleted &&
+				    object->softDeleted &&
+				    tags.chunkId != 0) {
+					/* Data chunk in a soft deleted file, throw it away
+					 * It's a soft deleted data chunk,
+					 * No need to copy this, just forget about it and
+					 * fix up the object.
+					 */
+
+					object->nDataChunks--;
+
+					if (object->nDataChunks <= 0) {
+						/* remeber to clean up the object */
+						dev->gcCleanupList[cleanups] =
+						    tags.objectId;
+						cleanups++;
+					}
+					markNAND = 0;
+				} else if (0) {
+					/* Todo object && object->deleted && object->nDataChunks == 0 */
+					/* Deleted object header with no data chunks.
+					 * Can be discarded and the file deleted.
+					 */
+					object->hdrChunk = 0;
+					yaffs_FreeTnode(object->myDev,
+							object->variant.
+							fileVariant.top);
+					object->variant.fileVariant.top = NULL;
+					yaffs_DoGenericObjectDeletion(object);
+
+				} else if (object) {
+					/* It's either a data chunk in a live file or
+					 * an ObjectHeader, so we're interested in it.
+					 * NB Need to keep the ObjectHeaders of deleted files
+					 * until the whole file has been deleted off
+					 */
+					tags.serialNumber++;
+
+					dev->nGCCopies++;
+
+					if (tags.chunkId == 0) {
+						/* It is an object Id,
+						 * We need to nuke the shrinkheader flags first
+						 * Also need to clean up shadowing.
+						 * We no longer want the shrinkHeader flag since its work is done
+						 * and if it is left in place it will mess up scanning.
+						 */
+
+						yaffs_ObjectHeader *oh;
+						oh = (yaffs_ObjectHeader *)buffer;
+						oh->isShrink = 0;
+						tags.extraIsShrinkHeader = 0;
+						oh->shadowsObject = 0;
+						oh->inbandShadowsObject = 0;
+						tags.extraShadows = 0;
+
+						yaffs_VerifyObjectHeader(object, oh, &tags, 1);
+					}
+
+					newChunk =
+					    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &tags, 1);
+
+					if (newChunk < 0) {
+						retVal = YAFFS_FAIL;
+					} else {
+
+						/* Ok, now fix up the Tnodes etc. */
+
+						if (tags.chunkId == 0) {
+							/* It's a header */
+							object->hdrChunk =  newChunk;
+							object->serial =   tags.serialNumber;
+						} else {
+							/* It's a data chunk */
+							yaffs_PutChunkIntoFile
+							    (object,
+							     tags.chunkId,
+							     newChunk, 0);
+						}
+					}
+				}
+
+				if (retVal == YAFFS_OK)
+					yaffs_DeleteChunk(dev, oldChunk, markNAND, __LINE__);
+
+			}
+		}
+
+		yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
+
+
+		/* Do any required cleanups */
+		for (i = 0; i < cleanups; i++) {
+			/* Time to delete the file too */
+			object =
+			    yaffs_FindObjectByNumber(dev,
+						     dev->gcCleanupList[i]);
+			if (object) {
+				yaffs_FreeTnode(dev,
+						object->variant.fileVariant.
+						top);
+				object->variant.fileVariant.top = NULL;
+				T(YAFFS_TRACE_GC,
+				  (TSTR
+				   ("yaffs: About to finally delete object %d"
+				    TENDSTR), object->objectId));
+				yaffs_DoGenericObjectDeletion(object);
+				object->myDev->nDeletedFiles--;
+			}
+
+		}
+
+	}
+
+	yaffs_VerifyCollectedBlock(dev, bi, block);
+
+	chunksAfter = yaffs_GetErasedChunks(dev);
+	if (chunksBefore >= chunksAfter) {
+		T(YAFFS_TRACE_GC,
+		  (TSTR
+		   ("gc did not increase free chunks before %d after %d"
+		    TENDSTR), chunksBefore, chunksAfter));
+	}
+
+	/* If the gc completed then clear the current gcBlock so that we find another. */
+	if (bi->blockState != YAFFS_BLOCK_STATE_COLLECTING) {
+		dev->gcBlock = -1;
+		dev->gcChunk = 0;
+	}
+
+	dev->isDoingGC = 0;
+
+	return retVal;
+}
+
+/* New garbage collector
+ * If we're very low on erased blocks then we do aggressive garbage collection
+ * otherwise we do "leasurely" garbage collection.
+ * Aggressive gc looks further (whole array) and will accept less dirty blocks.
+ * Passive gc only inspects smaller areas and will only accept more dirty blocks.
+ *
+ * The idea is to help clear out space in a more spread-out manner.
+ * Dunno if it really does anything useful.
+ */
+static int yaffs_CheckGarbageCollection(yaffs_Device *dev)
+{
+	int block;
+	int aggressive;
+	int gcOk = YAFFS_OK;
+	int maxTries = 0;
+
+	int checkpointBlockAdjust;
+
+	if (dev->isDoingGC) {
+		/* Bail out so we don't get recursive gc */
+		return YAFFS_OK;
+	}
+
+	/* This loop should pass the first time.
+	 * We'll only see looping here if the erase of the collected block fails.
+	 */
+
+	do {
+		maxTries++;
+
+		checkpointBlockAdjust = yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;
+		if (checkpointBlockAdjust < 0)
+			checkpointBlockAdjust = 0;
+
+		if (dev->nErasedBlocks < (dev->nReservedBlocks + checkpointBlockAdjust + 2)) {
+			/* We need a block soon...*/
+			aggressive = 1;
+		} else {
+			/* We're in no hurry */
+			aggressive = 0;
+		}
+
+		if (dev->gcBlock <= 0) {
+			dev->gcBlock = yaffs_FindBlockForGarbageCollection(dev, aggressive);
+			dev->gcChunk = 0;
+		}
+
+		block = dev->gcBlock;
+
+		if (block > 0) {
+			dev->garbageCollections++;
+			if (!aggressive)
+				dev->passiveGarbageCollections++;
+
+			T(YAFFS_TRACE_GC,
+			  (TSTR
+			   ("yaffs: GC erasedBlocks %d aggressive %d" TENDSTR),
+			   dev->nErasedBlocks, aggressive));
+
+			gcOk = yaffs_GarbageCollectBlock(dev, block, aggressive);
+		}
+
+		if (dev->nErasedBlocks < (dev->nReservedBlocks) && block > 0) {
+			T(YAFFS_TRACE_GC,
+			  (TSTR
+			   ("yaffs: GC !!!no reclaim!!! erasedBlocks %d after try %d block %d"
+			    TENDSTR), dev->nErasedBlocks, maxTries, block));
+		}
+	} while ((dev->nErasedBlocks < dev->nReservedBlocks) &&
+		 (block > 0) &&
+		 (maxTries < 2));
+
+	return aggressive ? gcOk : YAFFS_OK;
+}
+
+/*-------------------------  TAGS --------------------------------*/
+
+static int yaffs_TagsMatch(const yaffs_ExtendedTags *tags, int objectId,
+			   int chunkInObject)
+{
+	return (tags->chunkId == chunkInObject &&
+		tags->objectId == objectId && !tags->chunkDeleted) ? 1 : 0;
+
+}
+
+
+/*-------------------- Data file manipulation -----------------*/
+
+static int yaffs_FindChunkInFile(yaffs_Object *in, int chunkInInode,
+				 yaffs_ExtendedTags *tags)
+{
+	/*Get the Tnode, then get the level 0 offset chunk offset */
+	yaffs_Tnode *tn;
+	int theChunk = -1;
+	yaffs_ExtendedTags localTags;
+	int retVal = -1;
+
+	yaffs_Device *dev = in->myDev;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &localTags;
+	}
+
+	tn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);
+
+	if (tn) {
+		theChunk = yaffs_GetChunkGroupBase(dev, tn, chunkInInode);
+
+		retVal =
+		    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,
+					   chunkInInode);
+	}
+	return retVal;
+}
+
+static int yaffs_FindAndDeleteChunkInFile(yaffs_Object *in, int chunkInInode,
+					  yaffs_ExtendedTags *tags)
+{
+	/* Get the Tnode, then get the level 0 offset chunk offset */
+	yaffs_Tnode *tn;
+	int theChunk = -1;
+	yaffs_ExtendedTags localTags;
+
+	yaffs_Device *dev = in->myDev;
+	int retVal = -1;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &localTags;
+	}
+
+	tn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);
+
+	if (tn) {
+
+		theChunk = yaffs_GetChunkGroupBase(dev, tn, chunkInInode);
+
+		retVal =
+		    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,
+					   chunkInInode);
+
+		/* Delete the entry in the filestructure (if found) */
+		if (retVal != -1)
+			yaffs_PutLevel0Tnode(dev, tn, chunkInInode, 0);
+	}
+
+	return retVal;
+}
+
+#ifdef YAFFS_PARANOID
+
+static int yaffs_CheckFileSanity(yaffs_Object *in)
+{
+	int chunk;
+	int nChunks;
+	int fSize;
+	int failed = 0;
+	int objId;
+	yaffs_Tnode *tn;
+	yaffs_Tags localTags;
+	yaffs_Tags *tags = &localTags;
+	int theChunk;
+	int chunkDeleted;
+
+	if (in->variantType != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	objId = in->objectId;
+	fSize = in->variant.fileVariant.fileSize;
+	nChunks =
+	    (fSize + in->myDev->nDataBytesPerChunk - 1) / in->myDev->nDataBytesPerChunk;
+
+	for (chunk = 1; chunk <= nChunks; chunk++) {
+		tn = yaffs_FindLevel0Tnode(in->myDev, &in->variant.fileVariant,
+					   chunk);
+
+		if (tn) {
+
+			theChunk = yaffs_GetChunkGroupBase(dev, tn, chunk);
+
+			if (yaffs_CheckChunkBits
+			    (dev, theChunk / dev->nChunksPerBlock,
+			     theChunk % dev->nChunksPerBlock)) {
+
+				yaffs_ReadChunkTagsFromNAND(in->myDev, theChunk,
+							    tags,
+							    &chunkDeleted);
+				if (yaffs_TagsMatch
+				    (tags, in->objectId, chunk, chunkDeleted)) {
+					/* found it; */
+
+				}
+			} else {
+
+				failed = 1;
+			}
+
+		} else {
+			/* T(("No level 0 found for %d\n", chunk)); */
+		}
+	}
+
+	return failed ? YAFFS_FAIL : YAFFS_OK;
+}
+
+#endif
+
+static int yaffs_PutChunkIntoFile(yaffs_Object *in, int chunkInInode,
+				  int chunkInNAND, int inScan)
+{
+	/* NB inScan is zero unless scanning.
+	 * For forward scanning, inScan is > 0;
+	 * for backward scanning inScan is < 0
+	 */
+
+	yaffs_Tnode *tn;
+	yaffs_Device *dev = in->myDev;
+	int existingChunk;
+	yaffs_ExtendedTags existingTags;
+	yaffs_ExtendedTags newTags;
+	unsigned existingSerial, newSerial;
+
+	if (in->variantType != YAFFS_OBJECT_TYPE_FILE) {
+		/* Just ignore an attempt at putting a chunk into a non-file during scanning
+		 * If it is not during Scanning then something went wrong!
+		 */
+		if (!inScan) {
+			T(YAFFS_TRACE_ERROR,
+			  (TSTR
+			   ("yaffs tragedy:attempt to put data chunk into a non-file"
+			    TENDSTR)));
+			YBUG();
+		}
+
+		yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
+		return YAFFS_OK;
+	}
+
+	tn = yaffs_AddOrFindLevel0Tnode(dev,
+					&in->variant.fileVariant,
+					chunkInInode,
+					NULL);
+	if (!tn)
+		return YAFFS_FAIL;
+
+	existingChunk = yaffs_GetChunkGroupBase(dev, tn, chunkInInode);
+
+	if (inScan != 0) {
+		/* If we're scanning then we need to test for duplicates
+		 * NB This does not need to be efficient since it should only ever
+		 * happen when the power fails during a write, then only one
+		 * chunk should ever be affected.
+		 *
+		 * Correction for YAFFS2: This could happen quite a lot and we need to think about efficiency! TODO
+		 * Update: For backward scanning we don't need to re-read tags so this is quite cheap.
+		 */
+
+		if (existingChunk > 0) {
+			/* NB Right now existing chunk will not be real chunkId if the device >= 32MB
+			 *    thus we have to do a FindChunkInFile to get the real chunk id.
+			 *
+			 * We have a duplicate now we need to decide which one to use:
+			 *
+			 * Backwards scanning YAFFS2: The old one is what we use, dump the new one.
+			 * Forward scanning YAFFS2: The new one is what we use, dump the old one.
+			 * YAFFS1: Get both sets of tags and compare serial numbers.
+			 */
+
+			if (inScan > 0) {
+				/* Only do this for forward scanning */
+				yaffs_ReadChunkWithTagsFromNAND(dev,
+								chunkInNAND,
+								NULL, &newTags);
+
+				/* Do a proper find */
+				existingChunk =
+				    yaffs_FindChunkInFile(in, chunkInInode,
+							  &existingTags);
+			}
+
+			if (existingChunk <= 0) {
+				/*Hoosterman - how did this happen? */
+
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("yaffs tragedy: existing chunk < 0 in scan"
+				    TENDSTR)));
+
+			}
+
+			/* NB The deleted flags should be false, otherwise the chunks will
+			 * not be loaded during a scan
+			 */
+
+			if (inScan > 0) {
+				newSerial = newTags.serialNumber;
+				existingSerial = existingTags.serialNumber;
+			}
+
+			if ((inScan > 0) &&
+			    (in->myDev->isYaffs2 ||
+			     existingChunk <= 0 ||
+			     ((existingSerial + 1) & 3) == newSerial)) {
+				/* Forward scanning.
+				 * Use new
+				 * Delete the old one and drop through to update the tnode
+				 */
+				yaffs_DeleteChunk(dev, existingChunk, 1,
+						  __LINE__);
+			} else {
+				/* Backward scanning or we want to use the existing one
+				 * Use existing.
+				 * Delete the new one and return early so that the tnode isn't changed
+				 */
+				yaffs_DeleteChunk(dev, chunkInNAND, 1,
+						  __LINE__);
+				return YAFFS_OK;
+			}
+		}
+
+	}
+
+	if (existingChunk == 0)
+		in->nDataChunks++;
+
+	yaffs_PutLevel0Tnode(dev, tn, chunkInInode, chunkInNAND);
+
+	return YAFFS_OK;
+}
+
+static int yaffs_ReadChunkDataFromObject(yaffs_Object *in, int chunkInInode,
+					__u8 *buffer)
+{
+	int chunkInNAND = yaffs_FindChunkInFile(in, chunkInInode, NULL);
+
+	if (chunkInNAND >= 0)
+		return yaffs_ReadChunkWithTagsFromNAND(in->myDev, chunkInNAND,
+						buffer, NULL);
+	else {
+		T(YAFFS_TRACE_NANDACCESS,
+		  (TSTR("Chunk %d not found zero instead" TENDSTR),
+		   chunkInNAND));
+		/* get sane (zero) data if you read a hole */
+		memset(buffer, 0, in->myDev->nDataBytesPerChunk);
+		return 0;
+	}
+
+}
+
+void yaffs_DeleteChunk(yaffs_Device *dev, int chunkId, int markNAND, int lyn)
+{
+	int block;
+	int page;
+	yaffs_ExtendedTags tags;
+	yaffs_BlockInfo *bi;
+
+	if (chunkId <= 0)
+		return;
+
+	dev->nDeletions++;
+	block = chunkId / dev->nChunksPerBlock;
+	page = chunkId % dev->nChunksPerBlock;
+
+
+	if (!yaffs_CheckChunkBit(dev, block, page))
+		T(YAFFS_TRACE_VERIFY,
+			(TSTR("Deleting invalid chunk %d"TENDSTR),
+			 chunkId));
+
+	bi = yaffs_GetBlockInfo(dev, block);
+
+	T(YAFFS_TRACE_DELETION,
+	  (TSTR("line %d delete of chunk %d" TENDSTR), lyn, chunkId));
+
+	if (markNAND &&
+	    bi->blockState != YAFFS_BLOCK_STATE_COLLECTING && !dev->isYaffs2) {
+
+		yaffs_InitialiseTags(&tags);
+
+		tags.chunkDeleted = 1;
+
+		yaffs_WriteChunkWithTagsToNAND(dev, chunkId, NULL, &tags);
+		yaffs_HandleUpdateChunk(dev, chunkId, &tags);
+	} else {
+		dev->nUnmarkedDeletions++;
+	}
+
+	/* Pull out of the management area.
+	 * If the whole block became dirty, this will kick off an erasure.
+	 */
+	if (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING ||
+	    bi->blockState == YAFFS_BLOCK_STATE_FULL ||
+	    bi->blockState == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
+	    bi->blockState == YAFFS_BLOCK_STATE_COLLECTING) {
+		dev->nFreeChunks++;
+
+		yaffs_ClearChunkBit(dev, block, page);
+
+		bi->pagesInUse--;
+
+		if (bi->pagesInUse == 0 &&
+		    !bi->hasShrinkHeader &&
+		    bi->blockState != YAFFS_BLOCK_STATE_ALLOCATING &&
+		    bi->blockState != YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+			yaffs_BlockBecameDirty(dev, block);
+		}
+
+	}
+
+}
+
+static int yaffs_WriteChunkDataToObject(yaffs_Object *in, int chunkInInode,
+					const __u8 *buffer, int nBytes,
+					int useReserve)
+{
+	/* Find old chunk Need to do this to get serial number
+	 * Write new one and patch into tree.
+	 * Invalidate old tags.
+	 */
+
+	int prevChunkId;
+	yaffs_ExtendedTags prevTags;
+
+	int newChunkId;
+	yaffs_ExtendedTags newTags;
+
+	yaffs_Device *dev = in->myDev;
+
+	yaffs_CheckGarbageCollection(dev);
+
+	/* Get the previous chunk at this location in the file if it exists */
+	prevChunkId = yaffs_FindChunkInFile(in, chunkInInode, &prevTags);
+
+	/* Set up new tags */
+	yaffs_InitialiseTags(&newTags);
+
+	newTags.chunkId = chunkInInode;
+	newTags.objectId = in->objectId;
+	newTags.serialNumber =
+	    (prevChunkId > 0) ? prevTags.serialNumber + 1 : 1;
+	newTags.byteCount = nBytes;
+
+	if (nBytes < 1 || nBytes > dev->totalBytesPerChunk) {
+		T(YAFFS_TRACE_ERROR,
+		(TSTR("Writing %d bytes to chunk!!!!!!!!!" TENDSTR), nBytes));
+		YBUG();
+	}
+
+	newChunkId =
+	    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,
+					      useReserve);
+
+	if (newChunkId >= 0) {
+		yaffs_PutChunkIntoFile(in, chunkInInode, newChunkId, 0);
+
+		if (prevChunkId > 0)
+			yaffs_DeleteChunk(dev, prevChunkId, 1, __LINE__);
+
+		yaffs_CheckFileSanity(in);
+	}
+	return newChunkId;
+
+}
+
+/* UpdateObjectHeader updates the header on NAND for an object.
+ * If name is not NULL, then that new name is used.
+ */
+int yaffs_UpdateObjectHeader(yaffs_Object *in, const YCHAR *name, int force,
+			     int isShrink, int shadows)
+{
+
+	yaffs_BlockInfo *bi;
+
+	yaffs_Device *dev = in->myDev;
+
+	int prevChunkId;
+	int retVal = 0;
+	int result = 0;
+
+	int newChunkId;
+	yaffs_ExtendedTags newTags;
+	yaffs_ExtendedTags oldTags;
+
+	__u8 *buffer = NULL;
+	YCHAR oldName[YAFFS_MAX_NAME_LENGTH + 1];
+
+	yaffs_ObjectHeader *oh = NULL;
+
+	yaffs_strcpy(oldName, _Y("silly old name"));
+
+
+	if (!in->fake ||
+		in == dev->rootDir || /* The rootDir should also be saved */
+		force) {
+
+		yaffs_CheckGarbageCollection(dev);
+		yaffs_CheckObjectDetailsLoaded(in);
+
+		buffer = yaffs_GetTempBuffer(in->myDev, __LINE__);
+		oh = (yaffs_ObjectHeader *) buffer;
+
+		prevChunkId = in->hdrChunk;
+
+		if (prevChunkId > 0) {
+			result = yaffs_ReadChunkWithTagsFromNAND(dev, prevChunkId,
+							buffer, &oldTags);
+
+			yaffs_VerifyObjectHeader(in, oh, &oldTags, 0);
+
+			memcpy(oldName, oh->name, sizeof(oh->name));
+		}
+
+		memset(buffer, 0xFF, dev->nDataBytesPerChunk);
+
+		oh->type = in->variantType;
+		oh->yst_mode = in->yst_mode;
+		oh->shadowsObject = oh->inbandShadowsObject = shadows;
+
+#ifdef CONFIG_YAFFS_WINCE
+		oh->win_atime[0] = in->win_atime[0];
+		oh->win_ctime[0] = in->win_ctime[0];
+		oh->win_mtime[0] = in->win_mtime[0];
+		oh->win_atime[1] = in->win_atime[1];
+		oh->win_ctime[1] = in->win_ctime[1];
+		oh->win_mtime[1] = in->win_mtime[1];
+#else
+		oh->yst_uid = in->yst_uid;
+		oh->yst_gid = in->yst_gid;
+		oh->yst_atime = in->yst_atime;
+		oh->yst_mtime = in->yst_mtime;
+		oh->yst_ctime = in->yst_ctime;
+		oh->yst_rdev = in->yst_rdev;
+#endif
+		if (in->parent)
+			oh->parentObjectId = in->parent->objectId;
+		else
+			oh->parentObjectId = 0;
+
+		if (name && *name) {
+			memset(oh->name, 0, sizeof(oh->name));
+			yaffs_strncpy(oh->name, name, YAFFS_MAX_NAME_LENGTH);
+		} else if (prevChunkId > 0)
+			memcpy(oh->name, oldName, sizeof(oh->name));
+		else
+			memset(oh->name, 0, sizeof(oh->name));
+
+		oh->isShrink = isShrink;
+
+		switch (in->variantType) {
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+			/* Should not happen */
+			break;
+		case YAFFS_OBJECT_TYPE_FILE:
+			oh->fileSize =
+			    (oh->parentObjectId == YAFFS_OBJECTID_DELETED
+			     || oh->parentObjectId ==
+			     YAFFS_OBJECTID_UNLINKED) ? 0 : in->variant.
+			    fileVariant.fileSize;
+			break;
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+			oh->equivalentObjectId =
+			    in->variant.hardLinkVariant.equivalentObjectId;
+			break;
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+			/* Do nothing */
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			/* Do nothing */
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			yaffs_strncpy(oh->alias,
+				      in->variant.symLinkVariant.alias,
+				      YAFFS_MAX_ALIAS_LENGTH);
+			oh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;
+			break;
+		}
+
+		/* Tags */
+		yaffs_InitialiseTags(&newTags);
+		in->serial++;
+		newTags.chunkId = 0;
+		newTags.objectId = in->objectId;
+		newTags.serialNumber = in->serial;
+
+		/* Add extra info for file header */
+
+		newTags.extraHeaderInfoAvailable = 1;
+		newTags.extraParentObjectId = oh->parentObjectId;
+		newTags.extraFileLength = oh->fileSize;
+		newTags.extraIsShrinkHeader = oh->isShrink;
+		newTags.extraEquivalentObjectId = oh->equivalentObjectId;
+		newTags.extraShadows = (oh->shadowsObject > 0) ? 1 : 0;
+		newTags.extraObjectType = in->variantType;
+
+		yaffs_VerifyObjectHeader(in, oh, &newTags, 1);
+
+		/* Create new chunk in NAND */
+		newChunkId =
+		    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,
+						      (prevChunkId > 0) ? 1 : 0);
+
+		if (newChunkId >= 0) {
+
+			in->hdrChunk = newChunkId;
+
+			if (prevChunkId > 0) {
+				yaffs_DeleteChunk(dev, prevChunkId, 1,
+						  __LINE__);
+			}
+
+			if (!yaffs_ObjectHasCachedWriteData(in))
+				in->dirty = 0;
+
+			/* If this was a shrink, then mark the block that the chunk lives on */
+			if (isShrink) {
+				bi = yaffs_GetBlockInfo(in->myDev,
+					newChunkId / in->myDev->nChunksPerBlock);
+				bi->hasShrinkHeader = 1;
+			}
+
+		}
+
+		retVal = newChunkId;
+
+	}
+
+	if (buffer)
+		yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
+
+	return retVal;
+}
+
+/*------------------------ Short Operations Cache ----------------------------------------
+ *   In many situations where there is no high level buffering (eg WinCE) a lot of
+ *   reads might be short sequential reads, and a lot of writes may be short
+ *   sequential writes. eg. scanning/writing a jpeg file.
+ *   In these cases, a short read/write cache can provide a huge perfomance benefit
+ *   with dumb-as-a-rock code.
+ *   In Linux, the page cache provides read buffering aand the short op cache provides write
+ *   buffering.
+ *
+ *   There are a limited number (~10) of cache chunks per device so that we don't
+ *   need a very intelligent search.
+ */
+
+static int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj)
+{
+	yaffs_Device *dev = obj->myDev;
+	int i;
+	yaffs_ChunkCache *cache;
+	int nCaches = obj->myDev->nShortOpCaches;
+
+	for (i = 0; i < nCaches; i++) {
+		cache = &dev->srCache[i];
+		if (cache->object == obj &&
+		    cache->dirty)
+			return 1;
+	}
+
+	return 0;
+}
+
+
+static void yaffs_FlushFilesChunkCache(yaffs_Object *obj)
+{
+	yaffs_Device *dev = obj->myDev;
+	int lowest = -99;	/* Stop compiler whining. */
+	int i;
+	yaffs_ChunkCache *cache;
+	int chunkWritten = 0;
+	int nCaches = obj->myDev->nShortOpCaches;
+
+	if (nCaches > 0) {
+		do {
+			cache = NULL;
+
+			/* Find the dirty cache for this object with the lowest chunk id. */
+			for (i = 0; i < nCaches; i++) {
+				if (dev->srCache[i].object == obj &&
+				    dev->srCache[i].dirty) {
+					if (!cache
+					    || dev->srCache[i].chunkId <
+					    lowest) {
+						cache = &dev->srCache[i];
+						lowest = cache->chunkId;
+					}
+				}
+			}
+
+			if (cache && !cache->locked) {
+				/* Write it out and free it up */
+
+				chunkWritten =
+				    yaffs_WriteChunkDataToObject(cache->object,
+								 cache->chunkId,
+								 cache->data,
+								 cache->nBytes,
+								 1);
+				cache->dirty = 0;
+				cache->object = NULL;
+			}
+
+		} while (cache && chunkWritten > 0);
+
+		if (cache) {
+			/* Hoosterman, disk full while writing cache out. */
+			T(YAFFS_TRACE_ERROR,
+			  (TSTR("yaffs tragedy: no space during cache write" TENDSTR)));
+
+		}
+	}
+
+}
+
+/*yaffs_FlushEntireDeviceCache(dev)
+ *
+ *
+ */
+
+void yaffs_FlushEntireDeviceCache(yaffs_Device *dev)
+{
+	yaffs_Object *obj;
+	int nCaches = dev->nShortOpCaches;
+	int i;
+
+	/* Find a dirty object in the cache and flush it...
+	 * until there are no further dirty objects.
+	 */
+	do {
+		obj = NULL;
+		for (i = 0; i < nCaches && !obj; i++) {
+			if (dev->srCache[i].object &&
+			    dev->srCache[i].dirty)
+				obj = dev->srCache[i].object;
+
+		}
+		if (obj)
+			yaffs_FlushFilesChunkCache(obj);
+
+	} while (obj);
+
+}
+
+
+/* Grab us a cache chunk for use.
+ * First look for an empty one.
+ * Then look for the least recently used non-dirty one.
+ * Then look for the least recently used dirty one...., flush and look again.
+ */
+static yaffs_ChunkCache *yaffs_GrabChunkCacheWorker(yaffs_Device *dev)
+{
+	int i;
+
+	if (dev->nShortOpCaches > 0) {
+		for (i = 0; i < dev->nShortOpCaches; i++) {
+			if (!dev->srCache[i].object)
+				return &dev->srCache[i];
+		}
+	}
+
+	return NULL;
+}
+
+static yaffs_ChunkCache *yaffs_GrabChunkCache(yaffs_Device *dev)
+{
+	yaffs_ChunkCache *cache;
+	yaffs_Object *theObj;
+	int usage;
+	int i;
+	int pushout;
+
+	if (dev->nShortOpCaches > 0) {
+		/* Try find a non-dirty one... */
+
+		cache = yaffs_GrabChunkCacheWorker(dev);
+
+		if (!cache) {
+			/* They were all dirty, find the last recently used object and flush
+			 * its cache, then  find again.
+			 * NB what's here is not very accurate, we actually flush the object
+			 * the last recently used page.
+			 */
+
+			/* With locking we can't assume we can use entry zero */
+
+			theObj = NULL;
+			usage = -1;
+			cache = NULL;
+			pushout = -1;
+
+			for (i = 0; i < dev->nShortOpCaches; i++) {
+				if (dev->srCache[i].object &&
+				    !dev->srCache[i].locked &&
+				    (dev->srCache[i].lastUse < usage || !cache)) {
+					usage = dev->srCache[i].lastUse;
+					theObj = dev->srCache[i].object;
+					cache = &dev->srCache[i];
+					pushout = i;
+				}
+			}
+
+			if (!cache || cache->dirty) {
+				/* Flush and try again */
+				yaffs_FlushFilesChunkCache(theObj);
+				cache = yaffs_GrabChunkCacheWorker(dev);
+			}
+
+		}
+		return cache;
+	} else
+		return NULL;
+
+}
+
+/* Find a cached chunk */
+static yaffs_ChunkCache *yaffs_FindChunkCache(const yaffs_Object *obj,
+					      int chunkId)
+{
+	yaffs_Device *dev = obj->myDev;
+	int i;
+	if (dev->nShortOpCaches > 0) {
+		for (i = 0; i < dev->nShortOpCaches; i++) {
+			if (dev->srCache[i].object == obj &&
+			    dev->srCache[i].chunkId == chunkId) {
+				dev->cacheHits++;
+
+				return &dev->srCache[i];
+			}
+		}
+	}
+	return NULL;
+}
+
+/* Mark the chunk for the least recently used algorithym */
+static void yaffs_UseChunkCache(yaffs_Device *dev, yaffs_ChunkCache *cache,
+				int isAWrite)
+{
+
+	if (dev->nShortOpCaches > 0) {
+		if (dev->srLastUse < 0 || dev->srLastUse > 100000000) {
+			/* Reset the cache usages */
+			int i;
+			for (i = 1; i < dev->nShortOpCaches; i++)
+				dev->srCache[i].lastUse = 0;
+
+			dev->srLastUse = 0;
+		}
+
+		dev->srLastUse++;
+
+		cache->lastUse = dev->srLastUse;
+
+		if (isAWrite)
+			cache->dirty = 1;
+	}
+}
+
+/* Invalidate a single cache page.
+ * Do this when a whole page gets written,
+ * ie the short cache for this page is no longer valid.
+ */
+static void yaffs_InvalidateChunkCache(yaffs_Object *object, int chunkId)
+{
+	if (object->myDev->nShortOpCaches > 0) {
+		yaffs_ChunkCache *cache = yaffs_FindChunkCache(object, chunkId);
+
+		if (cache)
+			cache->object = NULL;
+	}
+}
+
+/* Invalidate all the cache pages associated with this object
+ * Do this whenever ther file is deleted or resized.
+ */
+static void yaffs_InvalidateWholeChunkCache(yaffs_Object *in)
+{
+	int i;
+	yaffs_Device *dev = in->myDev;
+
+	if (dev->nShortOpCaches > 0) {
+		/* Invalidate it. */
+		for (i = 0; i < dev->nShortOpCaches; i++) {
+			if (dev->srCache[i].object == in)
+				dev->srCache[i].object = NULL;
+		}
+	}
+}
+
+/*--------------------- Checkpointing --------------------*/
+
+
+static int yaffs_WriteCheckpointValidityMarker(yaffs_Device *dev, int head)
+{
+	yaffs_CheckpointValidity cp;
+
+	memset(&cp, 0, sizeof(cp));
+
+	cp.structType = sizeof(cp);
+	cp.magic = YAFFS_MAGIC;
+	cp.version = YAFFS_CHECKPOINT_VERSION;
+	cp.head = (head) ? 1 : 0;
+
+	return (yaffs_CheckpointWrite(dev, &cp, sizeof(cp)) == sizeof(cp)) ?
+		1 : 0;
+}
+
+static int yaffs_ReadCheckpointValidityMarker(yaffs_Device *dev, int head)
+{
+	yaffs_CheckpointValidity cp;
+	int ok;
+
+	ok = (yaffs_CheckpointRead(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	if (ok)
+		ok = (cp.structType == sizeof(cp)) &&
+		     (cp.magic == YAFFS_MAGIC) &&
+		     (cp.version == YAFFS_CHECKPOINT_VERSION) &&
+		     (cp.head == ((head) ? 1 : 0));
+	return ok ? 1 : 0;
+}
+
+static void yaffs_DeviceToCheckpointDevice(yaffs_CheckpointDevice *cp,
+					   yaffs_Device *dev)
+{
+	cp->nErasedBlocks = dev->nErasedBlocks;
+	cp->allocationBlock = dev->allocationBlock;
+	cp->allocationPage = dev->allocationPage;
+	cp->nFreeChunks = dev->nFreeChunks;
+
+	cp->nDeletedFiles = dev->nDeletedFiles;
+	cp->nUnlinkedFiles = dev->nUnlinkedFiles;
+	cp->nBackgroundDeletions = dev->nBackgroundDeletions;
+	cp->sequenceNumber = dev->sequenceNumber;
+	cp->oldestDirtySequence = dev->oldestDirtySequence;
+
+}
+
+static void yaffs_CheckpointDeviceToDevice(yaffs_Device *dev,
+					   yaffs_CheckpointDevice *cp)
+{
+	dev->nErasedBlocks = cp->nErasedBlocks;
+	dev->allocationBlock = cp->allocationBlock;
+	dev->allocationPage = cp->allocationPage;
+	dev->nFreeChunks = cp->nFreeChunks;
+
+	dev->nDeletedFiles = cp->nDeletedFiles;
+	dev->nUnlinkedFiles = cp->nUnlinkedFiles;
+	dev->nBackgroundDeletions = cp->nBackgroundDeletions;
+	dev->sequenceNumber = cp->sequenceNumber;
+	dev->oldestDirtySequence = cp->oldestDirtySequence;
+}
+
+
+static int yaffs_WriteCheckpointDevice(yaffs_Device *dev)
+{
+	yaffs_CheckpointDevice cp;
+	__u32 nBytes;
+	__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);
+
+	int ok;
+
+	/* Write device runtime values*/
+	yaffs_DeviceToCheckpointDevice(&cp, dev);
+	cp.structType = sizeof(cp);
+
+	ok = (yaffs_CheckpointWrite(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	/* Write block info */
+	if (ok) {
+		nBytes = nBlocks * sizeof(yaffs_BlockInfo);
+		ok = (yaffs_CheckpointWrite(dev, dev->blockInfo, nBytes) == nBytes);
+	}
+
+	/* Write chunk bits */
+	if (ok) {
+		nBytes = nBlocks * dev->chunkBitmapStride;
+		ok = (yaffs_CheckpointWrite(dev, dev->chunkBits, nBytes) == nBytes);
+	}
+	return	 ok ? 1 : 0;
+
+}
+
+static int yaffs_ReadCheckpointDevice(yaffs_Device *dev)
+{
+	yaffs_CheckpointDevice cp;
+	__u32 nBytes;
+	__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);
+
+	int ok;
+
+	ok = (yaffs_CheckpointRead(dev, &cp, sizeof(cp)) == sizeof(cp));
+	if (!ok)
+		return 0;
+
+	if (cp.structType != sizeof(cp))
+		return 0;
+
+
+	yaffs_CheckpointDeviceToDevice(dev, &cp);
+
+	nBytes = nBlocks * sizeof(yaffs_BlockInfo);
+
+	ok = (yaffs_CheckpointRead(dev, dev->blockInfo, nBytes) == nBytes);
+
+	if (!ok)
+		return 0;
+	nBytes = nBlocks * dev->chunkBitmapStride;
+
+	ok = (yaffs_CheckpointRead(dev, dev->chunkBits, nBytes) == nBytes);
+
+	return ok ? 1 : 0;
+}
+
+static void yaffs_ObjectToCheckpointObject(yaffs_CheckpointObject *cp,
+					   yaffs_Object *obj)
+{
+
+	cp->objectId = obj->objectId;
+	cp->parentId = (obj->parent) ? obj->parent->objectId : 0;
+	cp->hdrChunk = obj->hdrChunk;
+	cp->variantType = obj->variantType;
+	cp->deleted = obj->deleted;
+	cp->softDeleted = obj->softDeleted;
+	cp->unlinked = obj->unlinked;
+	cp->fake = obj->fake;
+	cp->renameAllowed = obj->renameAllowed;
+	cp->unlinkAllowed = obj->unlinkAllowed;
+	cp->serial = obj->serial;
+	cp->nDataChunks = obj->nDataChunks;
+
+	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE)
+		cp->fileSizeOrEquivalentObjectId = obj->variant.fileVariant.fileSize;
+	else if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)
+		cp->fileSizeOrEquivalentObjectId = obj->variant.hardLinkVariant.equivalentObjectId;
+}
+
+static int yaffs_CheckpointObjectToObject(yaffs_Object *obj, yaffs_CheckpointObject *cp)
+{
+
+	yaffs_Object *parent;
+
+	if (obj->variantType != cp->variantType) {
+		T(YAFFS_TRACE_ERROR, (TSTR("Checkpoint read object %d type %d "
+			TCONT("chunk %d does not match existing object type %d")
+			TENDSTR), cp->objectId, cp->variantType, cp->hdrChunk,
+			obj->variantType));
+		return 0;
+	}
+
+	obj->objectId = cp->objectId;
+
+	if (cp->parentId)
+		parent = yaffs_FindOrCreateObjectByNumber(
+					obj->myDev,
+					cp->parentId,
+					YAFFS_OBJECT_TYPE_DIRECTORY);
+	else
+		parent = NULL;
+
+	if (parent) {
+		if (parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+			T(YAFFS_TRACE_ALWAYS, (TSTR("Checkpoint read object %d parent %d type %d"
+				TCONT(" chunk %d Parent type, %d, not directory")
+				TENDSTR),
+				cp->objectId, cp->parentId, cp->variantType,
+				cp->hdrChunk, parent->variantType));
+			return 0;
+		}
+		yaffs_AddObjectToDirectory(parent, obj);
+	}
+
+	obj->hdrChunk = cp->hdrChunk;
+	obj->variantType = cp->variantType;
+	obj->deleted = cp->deleted;
+	obj->softDeleted = cp->softDeleted;
+	obj->unlinked = cp->unlinked;
+	obj->fake = cp->fake;
+	obj->renameAllowed = cp->renameAllowed;
+	obj->unlinkAllowed = cp->unlinkAllowed;
+	obj->serial = cp->serial;
+	obj->nDataChunks = cp->nDataChunks;
+
+	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE)
+		obj->variant.fileVariant.fileSize = cp->fileSizeOrEquivalentObjectId;
+	else if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)
+		obj->variant.hardLinkVariant.equivalentObjectId = cp->fileSizeOrEquivalentObjectId;
+
+	if (obj->hdrChunk > 0)
+		obj->lazyLoaded = 1;
+	return 1;
+}
+
+
+
+static int yaffs_CheckpointTnodeWorker(yaffs_Object *in, yaffs_Tnode *tn,
+					__u32 level, int chunkOffset)
+{
+	int i;
+	yaffs_Device *dev = in->myDev;
+	int ok = 1;
+	int tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
+
+	if (tnodeSize < sizeof(yaffs_Tnode))
+		tnodeSize = sizeof(yaffs_Tnode);
+
+
+	if (tn) {
+		if (level > 0) {
+
+			for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
+				if (tn->internal[i]) {
+					ok = yaffs_CheckpointTnodeWorker(in,
+							tn->internal[i],
+							level - 1,
+							(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);
+				}
+			}
+		} else if (level == 0) {
+			__u32 baseOffset = chunkOffset <<  YAFFS_TNODES_LEVEL0_BITS;
+			ok = (yaffs_CheckpointWrite(dev, &baseOffset, sizeof(baseOffset)) == sizeof(baseOffset));
+			if (ok)
+				ok = (yaffs_CheckpointWrite(dev, tn, tnodeSize) == tnodeSize);
+		}
+	}
+
+	return ok;
+
+}
+
+static int yaffs_WriteCheckpointTnodes(yaffs_Object *obj)
+{
+	__u32 endMarker = ~0;
+	int ok = 1;
+
+	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE) {
+		ok = yaffs_CheckpointTnodeWorker(obj,
+					    obj->variant.fileVariant.top,
+					    obj->variant.fileVariant.topLevel,
+					    0);
+		if (ok)
+			ok = (yaffs_CheckpointWrite(obj->myDev, &endMarker, sizeof(endMarker)) ==
+				sizeof(endMarker));
+	}
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs_ReadCheckpointTnodes(yaffs_Object *obj)
+{
+	__u32 baseChunk;
+	int ok = 1;
+	yaffs_Device *dev = obj->myDev;
+	yaffs_FileStructure *fileStructPtr = &obj->variant.fileVariant;
+	yaffs_Tnode *tn;
+	int nread = 0;
+	int tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;
+
+	if (tnodeSize < sizeof(yaffs_Tnode))
+		tnodeSize = sizeof(yaffs_Tnode);
+
+	ok = (yaffs_CheckpointRead(dev, &baseChunk, sizeof(baseChunk)) == sizeof(baseChunk));
+
+	while (ok && (~baseChunk)) {
+		nread++;
+		/* Read level 0 tnode */
+
+
+		tn = yaffs_GetTnodeRaw(dev);
+		if (tn)
+			ok = (yaffs_CheckpointRead(dev, tn, tnodeSize) == tnodeSize);
+		else
+			ok = 0;
+
+		if (tn && ok)
+			ok = yaffs_AddOrFindLevel0Tnode(dev,
+							fileStructPtr,
+							baseChunk,
+							tn) ? 1 : 0;
+
+		if (ok)
+			ok = (yaffs_CheckpointRead(dev, &baseChunk, sizeof(baseChunk)) == sizeof(baseChunk));
+
+	}
+
+	T(YAFFS_TRACE_CHECKPOINT, (
+		TSTR("Checkpoint read tnodes %d records, last %d. ok %d" TENDSTR),
+		nread, baseChunk, ok));
+
+	return ok ? 1 : 0;
+}
+
+
+static int yaffs_WriteCheckpointObjects(yaffs_Device *dev)
+{
+	yaffs_Object *obj;
+	yaffs_CheckpointObject cp;
+	int i;
+	int ok = 1;
+	struct ylist_head *lh;
+
+
+	/* Iterate through the objects in each hash entry,
+	 * dumping them to the checkpointing stream.
+	 */
+
+	for (i = 0; ok &&  i <  YAFFS_NOBJECT_BUCKETS; i++) {
+		ylist_for_each(lh, &dev->objectBucket[i].list) {
+			if (lh) {
+				obj = ylist_entry(lh, yaffs_Object, hashLink);
+				if (!obj->deferedFree) {
+					yaffs_ObjectToCheckpointObject(&cp, obj);
+					cp.structType = sizeof(cp);
+
+					T(YAFFS_TRACE_CHECKPOINT, (
+						TSTR("Checkpoint write object %d parent %d type %d chunk %d obj addr %x" TENDSTR),
+						cp.objectId, cp.parentId, cp.variantType, cp.hdrChunk, (unsigned) obj));
+
+					ok = (yaffs_CheckpointWrite(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+					if (ok && obj->variantType == YAFFS_OBJECT_TYPE_FILE)
+						ok = yaffs_WriteCheckpointTnodes(obj);
+				}
+			}
+		}
+	}
+
+	/* Dump end of list */
+	memset(&cp, 0xFF, sizeof(yaffs_CheckpointObject));
+	cp.structType = sizeof(cp);
+
+	if (ok)
+		ok = (yaffs_CheckpointWrite(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs_ReadCheckpointObjects(yaffs_Device *dev)
+{
+	yaffs_Object *obj;
+	yaffs_CheckpointObject cp;
+	int ok = 1;
+	int done = 0;
+	yaffs_Object *hardList = NULL;
+
+	while (ok && !done) {
+		ok = (yaffs_CheckpointRead(dev, &cp, sizeof(cp)) == sizeof(cp));
+		if (cp.structType != sizeof(cp)) {
+			T(YAFFS_TRACE_CHECKPOINT, (TSTR("struct size %d instead of %d ok %d"TENDSTR),
+				cp.structType, sizeof(cp), ok));
+			ok = 0;
+		}
+
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("Checkpoint read object %d parent %d type %d chunk %d " TENDSTR),
+			cp.objectId, cp.parentId, cp.variantType, cp.hdrChunk));
+
+		if (ok && cp.objectId == ~0)
+			done = 1;
+		else if (ok) {
+			obj = yaffs_FindOrCreateObjectByNumber(dev, cp.objectId, cp.variantType);
+			if (obj) {
+				ok = yaffs_CheckpointObjectToObject(obj, &cp);
+				if (!ok)
+					break;
+				if (obj->variantType == YAFFS_OBJECT_TYPE_FILE) {
+					ok = yaffs_ReadCheckpointTnodes(obj);
+				} else if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
+					obj->hardLinks.next =
+						(struct ylist_head *) hardList;
+					hardList = obj;
+				}
+			} else
+				ok = 0;
+		}
+	}
+
+	if (ok)
+		yaffs_HardlinkFixup(dev, hardList);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs_WriteCheckpointSum(yaffs_Device *dev)
+{
+	__u32 checkpointSum;
+	int ok;
+
+	yaffs_GetCheckpointSum(dev, &checkpointSum);
+
+	ok = (yaffs_CheckpointWrite(dev, &checkpointSum, sizeof(checkpointSum)) == sizeof(checkpointSum));
+
+	if (!ok)
+		return 0;
+
+	return 1;
+}
+
+static int yaffs_ReadCheckpointSum(yaffs_Device *dev)
+{
+	__u32 checkpointSum0;
+	__u32 checkpointSum1;
+	int ok;
+
+	yaffs_GetCheckpointSum(dev, &checkpointSum0);
+
+	ok = (yaffs_CheckpointRead(dev, &checkpointSum1, sizeof(checkpointSum1)) == sizeof(checkpointSum1));
+
+	if (!ok)
+		return 0;
+
+	if (checkpointSum0 != checkpointSum1)
+		return 0;
+
+	return 1;
+}
+
+
+static int yaffs_WriteCheckpointData(yaffs_Device *dev)
+{
+	int ok = 1;
+
+	if (dev->skipCheckpointWrite || !dev->isYaffs2) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("skipping checkpoint write" TENDSTR)));
+		ok = 0;
+	}
+
+	if (ok)
+		ok = yaffs_CheckpointOpen(dev, 1);
+
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint validity" TENDSTR)));
+		ok = yaffs_WriteCheckpointValidityMarker(dev, 1);
+	}
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint device" TENDSTR)));
+		ok = yaffs_WriteCheckpointDevice(dev);
+	}
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint objects" TENDSTR)));
+		ok = yaffs_WriteCheckpointObjects(dev);
+	}
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("write checkpoint validity" TENDSTR)));
+		ok = yaffs_WriteCheckpointValidityMarker(dev, 0);
+	}
+
+	if (ok)
+		ok = yaffs_WriteCheckpointSum(dev);
+
+	if (!yaffs_CheckpointClose(dev))
+		ok = 0;
+
+	if (ok)
+		dev->isCheckpointed = 1;
+	else
+		dev->isCheckpointed = 0;
+
+	return dev->isCheckpointed;
+}
+
+static int yaffs_ReadCheckpointData(yaffs_Device *dev)
+{
+	int ok = 1;
+
+	if (dev->skipCheckpointRead || !dev->isYaffs2) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("skipping checkpoint read" TENDSTR)));
+		ok = 0;
+	}
+
+	if (ok)
+		ok = yaffs_CheckpointOpen(dev, 0); /* open for read */
+
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint validity" TENDSTR)));
+		ok = yaffs_ReadCheckpointValidityMarker(dev, 1);
+	}
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint device" TENDSTR)));
+		ok = yaffs_ReadCheckpointDevice(dev);
+	}
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint objects" TENDSTR)));
+		ok = yaffs_ReadCheckpointObjects(dev);
+	}
+	if (ok) {
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint validity" TENDSTR)));
+		ok = yaffs_ReadCheckpointValidityMarker(dev, 0);
+	}
+
+	if (ok) {
+		ok = yaffs_ReadCheckpointSum(dev);
+		T(YAFFS_TRACE_CHECKPOINT, (TSTR("read checkpoint checksum %d" TENDSTR), ok));
+	}
+
+	if (!yaffs_CheckpointClose(dev))
+		ok = 0;
+
+	if (ok)
+		dev->isCheckpointed = 1;
+	else
+		dev->isCheckpointed = 0;
+
+	return ok ? 1 : 0;
+
+}
+
+static void yaffs_InvalidateCheckpoint(yaffs_Device *dev)
+{
+	if (dev->isCheckpointed ||
+			dev->blocksInCheckpoint > 0) {
+		dev->isCheckpointed = 0;
+		yaffs_CheckpointInvalidateStream(dev);
+		if (dev->superBlock && dev->markSuperBlockDirty)
+			dev->markSuperBlockDirty(dev->superBlock);
+	}
+}
+
+
+int yaffs_CheckpointSave(yaffs_Device *dev)
+{
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("save entry: isCheckpointed %d"TENDSTR), dev->isCheckpointed));
+
+	yaffs_VerifyObjects(dev);
+	yaffs_VerifyBlocks(dev);
+	yaffs_VerifyFreeChunks(dev);
+
+	if (!dev->isCheckpointed) {
+		yaffs_InvalidateCheckpoint(dev);
+		yaffs_WriteCheckpointData(dev);
+	}
+
+	T(YAFFS_TRACE_ALWAYS, (TSTR("save exit: isCheckpointed %d"TENDSTR), dev->isCheckpointed));
+
+	return dev->isCheckpointed;
+}
+
+int yaffs_CheckpointRestore(yaffs_Device *dev)
+{
+	int retval;
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("restore entry: isCheckpointed %d"TENDSTR), dev->isCheckpointed));
+
+	retval = yaffs_ReadCheckpointData(dev);
+
+	if (dev->isCheckpointed) {
+		yaffs_VerifyObjects(dev);
+		yaffs_VerifyBlocks(dev);
+		yaffs_VerifyFreeChunks(dev);
+	}
+
+	T(YAFFS_TRACE_CHECKPOINT, (TSTR("restore exit: isCheckpointed %d"TENDSTR), dev->isCheckpointed));
+
+	return retval;
+}
+
+/*--------------------- File read/write ------------------------
+ * Read and write have very similar structures.
+ * In general the read/write has three parts to it
+ * An incomplete chunk to start with (if the read/write is not chunk-aligned)
+ * Some complete chunks
+ * An incomplete chunk to end off with
+ *
+ * Curve-balls: the first chunk might also be the last chunk.
+ */
+
+int yaffs_ReadDataFromFile(yaffs_Object *in, __u8 *buffer, loff_t offset,
+			int nBytes)
+{
+
+	int chunk;
+	__u32 start;
+	int nToCopy;
+	int n = nBytes;
+	int nDone = 0;
+	yaffs_ChunkCache *cache;
+
+	yaffs_Device *dev;
+
+	dev = in->myDev;
+
+	while (n > 0) {
+		/* chunk = offset / dev->nDataBytesPerChunk + 1; */
+		/* start = offset % dev->nDataBytesPerChunk; */
+		yaffs_AddrToChunk(dev, offset, &chunk, &start);
+		chunk++;
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+		if ((start + n) < dev->nDataBytesPerChunk)
+			nToCopy = n;
+		else
+			nToCopy = dev->nDataBytesPerChunk - start;
+
+		cache = yaffs_FindChunkCache(in, chunk);
+
+		/* If the chunk is already in the cache or it is less than a whole chunk
+		 * or we're using inband tags then use the cache (if there is caching)
+		 * else bypass the cache.
+		 */
+		if (cache || nToCopy != dev->nDataBytesPerChunk || dev->inbandTags) {
+			if (dev->nShortOpCaches > 0) {
+
+				/* If we can't find the data in the cache, then load it up. */
+
+				if (!cache) {
+					cache = yaffs_GrabChunkCache(in->myDev);
+					cache->object = in;
+					cache->chunkId = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_ReadChunkDataFromObject(in, chunk,
+								      cache->
+								      data);
+					cache->nBytes = 0;
+				}
+
+				yaffs_UseChunkCache(dev, cache, 0);
+
+				cache->locked = 1;
+
+
+				memcpy(buffer, &cache->data[start], nToCopy);
+
+				cache->locked = 0;
+			} else {
+				/* Read into the local buffer then copy..*/
+
+				__u8 *localBuffer =
+				    yaffs_GetTempBuffer(dev, __LINE__);
+				yaffs_ReadChunkDataFromObject(in, chunk,
+							      localBuffer);
+
+				memcpy(buffer, &localBuffer[start], nToCopy);
+
+
+				yaffs_ReleaseTempBuffer(dev, localBuffer,
+							__LINE__);
+			}
+
+		} else {
+
+			/* A full chunk. Read directly into the supplied buffer. */
+			yaffs_ReadChunkDataFromObject(in, chunk, buffer);
+
+		}
+
+		n -= nToCopy;
+		offset += nToCopy;
+		buffer += nToCopy;
+		nDone += nToCopy;
+
+	}
+
+	return nDone;
+}
+
+int yaffs_WriteDataToFile(yaffs_Object *in, const __u8 *buffer, loff_t offset,
+			int nBytes, int writeThrough)
+{
+
+	int chunk;
+	__u32 start;
+	int nToCopy;
+	int n = nBytes;
+	int nDone = 0;
+	int nToWriteBack;
+	int startOfWrite = offset;
+	int chunkWritten = 0;
+	__u32 nBytesRead;
+	__u32 chunkStart;
+
+	yaffs_Device *dev;
+
+	dev = in->myDev;
+
+	while (n > 0 && chunkWritten >= 0) {
+		/* chunk = offset / dev->nDataBytesPerChunk + 1; */
+		/* start = offset % dev->nDataBytesPerChunk; */
+		yaffs_AddrToChunk(dev, offset, &chunk, &start);
+
+		if (chunk * dev->nDataBytesPerChunk + start != offset ||
+				start >= dev->nDataBytesPerChunk) {
+			T(YAFFS_TRACE_ERROR, (
+			   TSTR("AddrToChunk of offset %d gives chunk %d start %d"
+			   TENDSTR),
+			   (int)offset, chunk, start));
+		}
+		chunk++;
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+
+		if ((start + n) < dev->nDataBytesPerChunk) {
+			nToCopy = n;
+
+			/* Now folks, to calculate how many bytes to write back....
+			 * If we're overwriting and not writing to then end of file then
+			 * we need to write back as much as was there before.
+			 */
+
+			chunkStart = ((chunk - 1) * dev->nDataBytesPerChunk);
+
+			if (chunkStart > in->variant.fileVariant.fileSize)
+				nBytesRead = 0; /* Past end of file */
+			else
+				nBytesRead = in->variant.fileVariant.fileSize - chunkStart;
+
+			if (nBytesRead > dev->nDataBytesPerChunk)
+				nBytesRead = dev->nDataBytesPerChunk;
+
+			nToWriteBack =
+			    (nBytesRead >
+			     (start + n)) ? nBytesRead : (start + n);
+
+			if (nToWriteBack < 0 || nToWriteBack > dev->nDataBytesPerChunk)
+				YBUG();
+
+		} else {
+			nToCopy = dev->nDataBytesPerChunk - start;
+			nToWriteBack = dev->nDataBytesPerChunk;
+		}
+
+		if (nToCopy != dev->nDataBytesPerChunk || dev->inbandTags) {
+			/* An incomplete start or end chunk (or maybe both start and end chunk),
+			 * or we're using inband tags, so we want to use the cache buffers.
+			 */
+			if (dev->nShortOpCaches > 0) {
+				yaffs_ChunkCache *cache;
+				/* If we can't find the data in the cache, then load the cache */
+				cache = yaffs_FindChunkCache(in, chunk);
+
+				if (!cache
+				    && yaffs_CheckSpaceForAllocation(in->
+								     myDev)) {
+					cache = yaffs_GrabChunkCache(in->myDev);
+					cache->object = in;
+					cache->chunkId = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_ReadChunkDataFromObject(in, chunk,
+								      cache->
+								      data);
+				} else if (cache &&
+					!cache->dirty &&
+					!yaffs_CheckSpaceForAllocation(in->myDev)) {
+					/* Drop the cache if it was a read cache item and
+					 * no space check has been made for it.
+					 */
+					 cache = NULL;
+				}
+
+				if (cache) {
+					yaffs_UseChunkCache(dev, cache, 1);
+					cache->locked = 1;
+
+
+					memcpy(&cache->data[start], buffer,
+					       nToCopy);
+
+
+					cache->locked = 0;
+					cache->nBytes = nToWriteBack;
+
+					if (writeThrough) {
+						chunkWritten =
+						    yaffs_WriteChunkDataToObject
+						    (cache->object,
+						     cache->chunkId,
+						     cache->data, cache->nBytes,
+						     1);
+						cache->dirty = 0;
+					}
+
+				} else {
+					chunkWritten = -1;	/* fail the write */
+				}
+			} else {
+				/* An incomplete start or end chunk (or maybe both start and end chunk)
+				 * Read into the local buffer then copy, then copy over and write back.
+				 */
+
+				__u8 *localBuffer =
+				    yaffs_GetTempBuffer(dev, __LINE__);
+
+				yaffs_ReadChunkDataFromObject(in, chunk,
+							      localBuffer);
+
+
+
+				memcpy(&localBuffer[start], buffer, nToCopy);
+
+				chunkWritten =
+				    yaffs_WriteChunkDataToObject(in, chunk,
+								 localBuffer,
+								 nToWriteBack,
+								 0);
+
+				yaffs_ReleaseTempBuffer(dev, localBuffer,
+							__LINE__);
+
+			}
+
+		} else {
+			/* A full chunk. Write directly from the supplied buffer. */
+
+
+
+			chunkWritten =
+			    yaffs_WriteChunkDataToObject(in, chunk, buffer,
+							 dev->nDataBytesPerChunk,
+							 0);
+
+			/* Since we've overwritten the cached data, we better invalidate it. */
+			yaffs_InvalidateChunkCache(in, chunk);
+		}
+
+		if (chunkWritten >= 0) {
+			n -= nToCopy;
+			offset += nToCopy;
+			buffer += nToCopy;
+			nDone += nToCopy;
+		}
+
+	}
+
+	/* Update file object */
+
+	if ((startOfWrite + nDone) > in->variant.fileVariant.fileSize)
+		in->variant.fileVariant.fileSize = (startOfWrite + nDone);
+
+	in->dirty = 1;
+
+	return nDone;
+}
+
+
+/* ---------------------- File resizing stuff ------------------ */
+
+static void yaffs_PruneResizedChunks(yaffs_Object *in, int newSize)
+{
+
+	yaffs_Device *dev = in->myDev;
+	int oldFileSize = in->variant.fileVariant.fileSize;
+
+	int lastDel = 1 + (oldFileSize - 1) / dev->nDataBytesPerChunk;
+
+	int startDel = 1 + (newSize + dev->nDataBytesPerChunk - 1) /
+	    dev->nDataBytesPerChunk;
+	int i;
+	int chunkId;
+
+	/* Delete backwards so that we don't end up with holes if
+	 * power is lost part-way through the operation.
+	 */
+	for (i = lastDel; i >= startDel; i--) {
+		/* NB this could be optimised somewhat,
+		 * eg. could retrieve the tags and write them without
+		 * using yaffs_DeleteChunk
+		 */
+
+		chunkId = yaffs_FindAndDeleteChunkInFile(in, i, NULL);
+		if (chunkId > 0) {
+			if (chunkId <
+			    (dev->internalStartBlock * dev->nChunksPerBlock)
+			    || chunkId >=
+			    ((dev->internalEndBlock +
+			      1) * dev->nChunksPerBlock)) {
+				T(YAFFS_TRACE_ALWAYS,
+				  (TSTR("Found daft chunkId %d for %d" TENDSTR),
+				   chunkId, i));
+			} else {
+				in->nDataChunks--;
+				yaffs_DeleteChunk(dev, chunkId, 1, __LINE__);
+			}
+		}
+	}
+
+}
+
+int yaffs_ResizeFile(yaffs_Object *in, loff_t newSize)
+{
+
+	int oldFileSize = in->variant.fileVariant.fileSize;
+	__u32 newSizeOfPartialChunk;
+	int newFullChunks;
+
+	yaffs_Device *dev = in->myDev;
+
+	yaffs_AddrToChunk(dev, newSize, &newFullChunks, &newSizeOfPartialChunk);
+
+	yaffs_FlushFilesChunkCache(in);
+	yaffs_InvalidateWholeChunkCache(in);
+
+	yaffs_CheckGarbageCollection(dev);
+
+	if (in->variantType != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	if (newSize == oldFileSize)
+		return YAFFS_OK;
+
+	if (newSize < oldFileSize) {
+
+		yaffs_PruneResizedChunks(in, newSize);
+
+		if (newSizeOfPartialChunk != 0) {
+			int lastChunk = 1 + newFullChunks;
+
+			__u8 *localBuffer = yaffs_GetTempBuffer(dev, __LINE__);
+
+			/* Got to read and rewrite the last chunk with its new size and zero pad */
+			yaffs_ReadChunkDataFromObject(in, lastChunk,
+						      localBuffer);
+
+			memset(localBuffer + newSizeOfPartialChunk, 0,
+			       dev->nDataBytesPerChunk - newSizeOfPartialChunk);
+
+			yaffs_WriteChunkDataToObject(in, lastChunk, localBuffer,
+						     newSizeOfPartialChunk, 1);
+
+			yaffs_ReleaseTempBuffer(dev, localBuffer, __LINE__);
+		}
+
+		in->variant.fileVariant.fileSize = newSize;
+
+		yaffs_PruneFileStructure(dev, &in->variant.fileVariant);
+	} else {
+		/* newsSize > oldFileSize */
+		in->variant.fileVariant.fileSize = newSize;
+	}
+
+
+	/* Write a new object header to reflect the resize.
+	 * show we've shrunk the file, if need be
+	 * Do this only if the file is not in the deleted directories
+	 * and is not shadowed.
+	 */
+	if (in->parent &&
+	    !in->isShadowed &&
+	    in->parent->objectId != YAFFS_OBJECTID_UNLINKED &&
+	    in->parent->objectId != YAFFS_OBJECTID_DELETED)
+		yaffs_UpdateObjectHeader(in, NULL, 0,
+					 (newSize < oldFileSize) ? 1 : 0, 0);
+
+	return YAFFS_OK;
+}
+
+loff_t yaffs_GetFileSize(yaffs_Object *obj)
+{
+	obj = yaffs_GetEquivalentObject(obj);
+
+	switch (obj->variantType) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		return obj->variant.fileVariant.fileSize;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		return yaffs_strlen(obj->variant.symLinkVariant.alias);
+	default:
+		return 0;
+	}
+}
+
+
+
+int yaffs_FlushFile(yaffs_Object *in, int updateTime)
+{
+	int retVal;
+	if (in->dirty) {
+		yaffs_FlushFilesChunkCache(in);
+		if (updateTime) {
+#ifdef CONFIG_YAFFS_WINCE
+			yfsd_WinFileTimeNow(in->win_mtime);
+#else
+
+			in->yst_mtime = Y_CURRENT_TIME;
+
+#endif
+		}
+
+		retVal = (yaffs_UpdateObjectHeader(in, NULL, 0, 0, 0) >=
+			0) ? YAFFS_OK : YAFFS_FAIL;
+	} else {
+		retVal = YAFFS_OK;
+	}
+
+	return retVal;
+
+}
+
+static int yaffs_DoGenericObjectDeletion(yaffs_Object *in)
+{
+
+	/* First off, invalidate the file's data in the cache, without flushing. */
+	yaffs_InvalidateWholeChunkCache(in);
+
+	if (in->myDev->isYaffs2 && (in->parent != in->myDev->deletedDir)) {
+		/* Move to the unlinked directory so we have a record that it was deleted. */
+		yaffs_ChangeObjectName(in, in->myDev->deletedDir, _Y("deleted"), 0, 0);
+
+	}
+
+	yaffs_RemoveObjectFromDirectory(in);
+	yaffs_DeleteChunk(in->myDev, in->hdrChunk, 1, __LINE__);
+	in->hdrChunk = 0;
+
+	yaffs_FreeObject(in);
+	return YAFFS_OK;
+
+}
+
+/* yaffs_DeleteFile deletes the whole file data
+ * and the inode associated with the file.
+ * It does not delete the links associated with the file.
+ */
+static int yaffs_UnlinkFileIfNeeded(yaffs_Object *in)
+{
+
+	int retVal;
+	int immediateDeletion = 0;
+
+#ifdef __KERNEL__
+	if (!in->myInode)
+		immediateDeletion = 1;
+#else
+	if (in->inUse <= 0)
+		immediateDeletion = 1;
+#endif
+
+	if (immediateDeletion) {
+		retVal =
+		    yaffs_ChangeObjectName(in, in->myDev->deletedDir,
+					   _Y("deleted"), 0, 0);
+		T(YAFFS_TRACE_TRACING,
+		  (TSTR("yaffs: immediate deletion of file %d" TENDSTR),
+		   in->objectId));
+		in->deleted = 1;
+		in->myDev->nDeletedFiles++;
+		if (1 || in->myDev->isYaffs2)
+			yaffs_ResizeFile(in, 0);
+		yaffs_SoftDeleteFile(in);
+	} else {
+		retVal =
+		    yaffs_ChangeObjectName(in, in->myDev->unlinkedDir,
+					   _Y("unlinked"), 0, 0);
+	}
+
+
+	return retVal;
+}
+
+int yaffs_DeleteFile(yaffs_Object *in)
+{
+	int retVal = YAFFS_OK;
+	int deleted = in->deleted;
+
+	yaffs_ResizeFile(in, 0);
+
+	if (in->nDataChunks > 0) {
+		/* Use soft deletion if there is data in the file.
+		 * That won't be the case if it has been resized to zero.
+		 */
+		if (!in->unlinked)
+			retVal = yaffs_UnlinkFileIfNeeded(in);
+
+		if (retVal == YAFFS_OK && in->unlinked && !in->deleted) {
+			in->deleted = 1;
+			deleted = 1;
+			in->myDev->nDeletedFiles++;
+			yaffs_SoftDeleteFile(in);
+		}
+		return deleted ? YAFFS_OK : YAFFS_FAIL;
+	} else {
+		/* The file has no data chunks so we toss it immediately */
+		yaffs_FreeTnode(in->myDev, in->variant.fileVariant.top);
+		in->variant.fileVariant.top = NULL;
+		yaffs_DoGenericObjectDeletion(in);
+
+		return YAFFS_OK;
+	}
+}
+
+static int yaffs_IsNonEmptyDirectory(yaffs_Object *obj)
+{
+	return (obj->variantType == YAFFS_OBJECT_TYPE_DIRECTORY) &&
+		!(ylist_empty(&obj->variant.directoryVariant.children));
+}
+
+static int yaffs_DeleteDirectory(yaffs_Object *obj)
+{
+	/* First check that the directory is empty. */
+	if (yaffs_IsNonEmptyDirectory(obj))
+		return YAFFS_FAIL;
+
+	return yaffs_DoGenericObjectDeletion(obj);
+}
+
+static int yaffs_DeleteSymLink(yaffs_Object *in)
+{
+	YFREE(in->variant.symLinkVariant.alias);
+
+	return yaffs_DoGenericObjectDeletion(in);
+}
+
+static int yaffs_DeleteHardLink(yaffs_Object *in)
+{
+	/* remove this hardlink from the list assocaited with the equivalent
+	 * object
+	 */
+	ylist_del_init(&in->hardLinks);
+	return yaffs_DoGenericObjectDeletion(in);
+}
+
+int yaffs_DeleteObject(yaffs_Object *obj)
+{
+int retVal = -1;
+	switch (obj->variantType) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		retVal = yaffs_DeleteFile(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		return yaffs_DeleteDirectory(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		retVal = yaffs_DeleteSymLink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		retVal = yaffs_DeleteHardLink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		retVal = yaffs_DoGenericObjectDeletion(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		retVal = 0;
+		break;		/* should not happen. */
+	}
+
+	return retVal;
+}
+
+static int yaffs_UnlinkWorker(yaffs_Object *obj)
+{
+
+	int immediateDeletion = 0;
+
+#ifdef __KERNEL__
+	if (!obj->myInode)
+		immediateDeletion = 1;
+#else
+	if (obj->inUse <= 0)
+		immediateDeletion = 1;
+#endif
+
+	if(obj)
+		yaffs_UpdateParent(obj->parent);
+
+	if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
+		return yaffs_DeleteHardLink(obj);
+	} else if (!ylist_empty(&obj->hardLinks)) {
+		/* Curve ball: We're unlinking an object that has a hardlink.
+		 *
+		 * This problem arises because we are not strictly following
+		 * The Linux link/inode model.
+		 *
+		 * We can't really delete the object.
+		 * Instead, we do the following:
+		 * - Select a hardlink.
+		 * - Unhook it from the hard links
+		 * - Unhook it from its parent directory (so that the rename can work)
+		 * - Rename the object to the hardlink's name.
+		 * - Delete the hardlink
+		 */
+
+		yaffs_Object *hl;
+		int retVal;
+		YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+
+		hl = ylist_entry(obj->hardLinks.next, yaffs_Object, hardLinks);
+
+		ylist_del_init(&hl->hardLinks);
+		ylist_del_init(&hl->siblings);
+
+		yaffs_GetObjectName(hl, name, YAFFS_MAX_NAME_LENGTH + 1);
+
+		retVal = yaffs_ChangeObjectName(obj, hl->parent, name, 0, 0);
+
+		if (retVal == YAFFS_OK)
+			retVal = yaffs_DoGenericObjectDeletion(hl);
+
+		return retVal;
+
+	} else if (immediateDeletion) {
+		switch (obj->variantType) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			return yaffs_DeleteFile(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			return yaffs_DeleteDirectory(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			return yaffs_DeleteSymLink(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+			return yaffs_DoGenericObjectDeletion(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		default:
+			return YAFFS_FAIL;
+		}
+	} else if(yaffs_IsNonEmptyDirectory(obj))
+		return YAFFS_FAIL;
+	else
+		return yaffs_ChangeObjectName(obj, obj->myDev->unlinkedDir,
+					   _Y("unlinked"), 0, 0);
+}
+
+
+static int yaffs_UnlinkObject(yaffs_Object *obj)
+{
+
+	if (obj && obj->unlinkAllowed)
+		return yaffs_UnlinkWorker(obj);
+
+	return YAFFS_FAIL;
+
+}
+int yaffs_Unlink(yaffs_Object *dir, const YCHAR *name)
+{
+	yaffs_Object *obj;
+
+	obj = yaffs_FindObjectByName(dir, name);
+	return yaffs_UnlinkObject(obj);
+}
+
+/*----------------------- Initialisation Scanning ---------------------- */
+
+static void yaffs_HandleShadowedObject(yaffs_Device *dev, int objId,
+				int backwardScanning)
+{
+	yaffs_Object *obj;
+
+	if (!backwardScanning) {
+		/* Handle YAFFS1 forward scanning case
+		 * For YAFFS1 we always do the deletion
+		 */
+
+	} else {
+		/* Handle YAFFS2 case (backward scanning)
+		 * If the shadowed object exists then ignore.
+		 */
+		obj = yaffs_FindObjectByNumber(dev, objId);
+		if(obj)
+			return;
+	}
+
+	/* Let's create it (if it does not exist) assuming it is a file so that it can do shrinking etc.
+	 * We put it in unlinked dir to be cleaned up after the scanning
+	 */
+	obj =
+	    yaffs_FindOrCreateObjectByNumber(dev, objId,
+					     YAFFS_OBJECT_TYPE_FILE);
+	if (!obj)
+		return;
+	obj->isShadowed = 1;
+	yaffs_AddObjectToDirectory(dev->unlinkedDir, obj);
+	obj->variant.fileVariant.shrinkSize = 0;
+	obj->valid = 1;		/* So that we don't read any other info for this file */
+
+}
+
+typedef struct {
+	int seq;
+	int block;
+} yaffs_BlockIndex;
+
+
+static void yaffs_HardlinkFixup(yaffs_Device *dev, yaffs_Object *hardList)
+{
+	yaffs_Object *hl;
+	yaffs_Object *in;
+
+	while (hardList) {
+		hl = hardList;
+		hardList = (yaffs_Object *) (hardList->hardLinks.next);
+
+		in = yaffs_FindObjectByNumber(dev,
+					      hl->variant.hardLinkVariant.
+					      equivalentObjectId);
+
+		if (in) {
+			/* Add the hardlink pointers */
+			hl->variant.hardLinkVariant.equivalentObject = in;
+			ylist_add(&hl->hardLinks, &in->hardLinks);
+		} else {
+			/* Todo Need to report/handle this better.
+			 * Got a problem... hardlink to a non-existant object
+			 */
+			hl->variant.hardLinkVariant.equivalentObject = NULL;
+			YINIT_LIST_HEAD(&hl->hardLinks);
+
+		}
+	}
+}
+
+
+
+
+
+static int ybicmp(const void *a, const void *b)
+{
+	register int aseq = ((yaffs_BlockIndex *)a)->seq;
+	register int bseq = ((yaffs_BlockIndex *)b)->seq;
+	register int ablock = ((yaffs_BlockIndex *)a)->block;
+	register int bblock = ((yaffs_BlockIndex *)b)->block;
+	if (aseq == bseq)
+		return ablock - bblock;
+	else
+		return aseq - bseq;
+}
+
+
+struct yaffs_ShadowFixerStruct {
+	int objectId;
+	int shadowedId;
+	struct yaffs_ShadowFixerStruct *next;
+};
+
+
+static void yaffs_StripDeletedObjects(yaffs_Device *dev)
+{
+	/*
+	*  Sort out state of unlinked and deleted objects after scanning.
+	*/
+	struct ylist_head *i;
+	struct ylist_head *n;
+	yaffs_Object *l;
+
+	/* Soft delete all the unlinked files */
+	ylist_for_each_safe(i, n,
+		&dev->unlinkedDir->variant.directoryVariant.children) {
+		if (i) {
+			l = ylist_entry(i, yaffs_Object, siblings);
+			yaffs_DeleteObject(l);
+		}
+	}
+
+	ylist_for_each_safe(i, n,
+		&dev->deletedDir->variant.directoryVariant.children) {
+		if (i) {
+			l = ylist_entry(i, yaffs_Object, siblings);
+			yaffs_DeleteObject(l);
+		}
+	}
+
+}
+
+/*
+ * This code iterates through all the objects making sure that they are rooted.
+ * Any unrooted objects are re-rooted in lost+found.
+ * An object needs to be in one of:
+ * - Directly under deleted, unlinked
+ * - Directly or indirectly under root.
+ *
+ * Note:
+ *  This code assumes that we don't ever change the current relationships between
+ *  directories:
+ *   rootDir->parent == unlinkedDir->parent == deletedDir->parent == NULL
+ *   lostNfound->parent == rootDir
+ *
+ * This fixes the problem where directories might have inadvertently been deleted
+ * leaving the object "hanging" without being rooted in the directory tree.
+ */
+
+static int yaffs_HasNULLParent(yaffs_Device *dev, yaffs_Object *obj)
+{
+	return (obj == dev->deletedDir ||
+		obj == dev->unlinkedDir||
+		obj == dev->rootDir);
+}
+
+static void yaffs_FixHangingObjects(yaffs_Device *dev)
+{
+	yaffs_Object *obj;
+	yaffs_Object *parent;
+	int i;
+	struct ylist_head *lh;
+	struct ylist_head *n;
+	int depthLimit;
+	int hanging;
+
+
+	/* Iterate through the objects in each hash entry,
+	 * looking at each object.
+	 * Make sure it is rooted.
+	 */
+
+	for (i = 0; i <  YAFFS_NOBJECT_BUCKETS; i++) {
+		ylist_for_each_safe(lh, n, &dev->objectBucket[i].list) {
+			if (lh) {
+				obj = ylist_entry(lh, yaffs_Object, hashLink);
+				parent= obj->parent;
+
+				if(yaffs_HasNULLParent(dev,obj)){
+					/* These directories are not hanging */
+					hanging = 0;
+				}
+				else if(!parent || parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+					hanging = 1;
+				else if(yaffs_HasNULLParent(dev,parent))
+					hanging = 0;
+				else {
+					/*
+					 * Need to follow the parent chain to see if it is hanging.
+					 */
+					hanging = 0;
+					depthLimit=100;
+
+					while(parent != dev->rootDir &&
+						parent->parent &&
+						parent->parent->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&
+						depthLimit > 0){
+						parent = parent->parent;
+						depthLimit--;
+					}
+					if(parent != dev->rootDir)
+						hanging = 1;
+				}
+				if(hanging){
+					T(YAFFS_TRACE_SCAN,
+					(TSTR("Hanging object %d moved to lost and found" TENDSTR),
+					obj->objectId));
+					yaffs_AddObjectToDirectory(dev->lostNFoundDir,obj);
+				}
+			}
+		}
+	}
+}
+
+
+/*
+ * Delete directory contents for cleaning up lost and found.
+ */
+static void yaffs_DeleteDirectoryContents(yaffs_Object *dir)
+{
+	yaffs_Object *obj;
+	struct ylist_head *lh;
+	struct ylist_head *n;
+
+	if(dir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+		YBUG();
+
+	ylist_for_each_safe(lh, n, &dir->variant.directoryVariant.children) {
+		if (lh) {
+			obj = ylist_entry(lh, yaffs_Object, siblings);
+			if(obj->variantType == YAFFS_OBJECT_TYPE_DIRECTORY)
+				yaffs_DeleteDirectoryContents(obj);
+
+			T(YAFFS_TRACE_SCAN,
+				(TSTR("Deleting lost_found object %d" TENDSTR),
+				obj->objectId));
+
+			/* Need to use UnlinkObject since Delete would not handle
+			 * hardlinked objects correctly.
+			 */
+			yaffs_UnlinkObject(obj);
+		}
+	}
+
+}
+
+static void yaffs_EmptyLostAndFound(yaffs_Device *dev)
+{
+	yaffs_DeleteDirectoryContents(dev->lostNFoundDir);
+}
+
+static int yaffs_Scan(yaffs_Device *dev)
+{
+	yaffs_ExtendedTags tags;
+	int blk;
+	int blockIterator;
+	int startIterator;
+	int endIterator;
+	int result;
+
+	int chunk;
+	int c;
+	int deleted;
+	yaffs_BlockState state;
+	yaffs_Object *hardList = NULL;
+	yaffs_BlockInfo *bi;
+	__u32 sequenceNumber;
+	yaffs_ObjectHeader *oh;
+	yaffs_Object *in;
+	yaffs_Object *parent;
+
+	int alloc_failed = 0;
+
+	struct yaffs_ShadowFixerStruct *shadowFixerList = NULL;
+
+
+	__u8 *chunkData;
+
+
+
+	T(YAFFS_TRACE_SCAN,
+	  (TSTR("yaffs_Scan starts  intstartblk %d intendblk %d..." TENDSTR),
+	   dev->internalStartBlock, dev->internalEndBlock));
+
+	chunkData = yaffs_GetTempBuffer(dev, __LINE__);
+
+	dev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;
+
+	/* Scan all the blocks to determine their state */
+	for (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {
+		bi = yaffs_GetBlockInfo(dev, blk);
+		yaffs_ClearChunkBits(dev, blk);
+		bi->pagesInUse = 0;
+		bi->softDeletions = 0;
+
+		yaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);
+
+		bi->blockState = state;
+		bi->sequenceNumber = sequenceNumber;
+
+		if (bi->sequenceNumber == YAFFS_SEQUENCE_BAD_BLOCK)
+			bi->blockState = state = YAFFS_BLOCK_STATE_DEAD;
+
+		T(YAFFS_TRACE_SCAN_DEBUG,
+		  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,
+		   state, sequenceNumber));
+
+		if (state == YAFFS_BLOCK_STATE_DEAD) {
+			T(YAFFS_TRACE_BAD_BLOCKS,
+			  (TSTR("block %d is bad" TENDSTR), blk));
+		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
+			T(YAFFS_TRACE_SCAN_DEBUG,
+			  (TSTR("Block empty " TENDSTR)));
+			dev->nErasedBlocks++;
+			dev->nFreeChunks += dev->nChunksPerBlock;
+		}
+	}
+
+	startIterator = dev->internalStartBlock;
+	endIterator = dev->internalEndBlock;
+
+	/* For each block.... */
+	for (blockIterator = startIterator; !alloc_failed && blockIterator <= endIterator;
+	     blockIterator++) {
+
+		YYIELD();
+
+		YYIELD();
+
+		blk = blockIterator;
+
+		bi = yaffs_GetBlockInfo(dev, blk);
+		state = bi->blockState;
+
+		deleted = 0;
+
+		/* For each chunk in each block that needs scanning....*/
+		for (c = 0; !alloc_failed && c < dev->nChunksPerBlock &&
+		     state == YAFFS_BLOCK_STATE_NEEDS_SCANNING; c++) {
+			/* Read the tags and decide what to do */
+			chunk = blk * dev->nChunksPerBlock + c;
+
+			result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,
+							&tags);
+
+			/* Let's have a good look at this chunk... */
+
+			if (tags.eccResult == YAFFS_ECC_RESULT_UNFIXED || tags.chunkDeleted) {
+				/* YAFFS1 only...
+				 * A deleted chunk
+				 */
+				deleted++;
+				dev->nFreeChunks++;
+				/*T((" %d %d deleted\n",blk,c)); */
+			} else if (!tags.chunkUsed) {
+				/* An unassigned chunk in the block
+				 * This means that either the block is empty or
+				 * this is the one being allocated from
+				 */
+
+				if (c == 0) {
+					/* We're looking at the first chunk in the block so the block is unused */
+					state = YAFFS_BLOCK_STATE_EMPTY;
+					dev->nErasedBlocks++;
+				} else {
+					/* this is the block being allocated from */
+					T(YAFFS_TRACE_SCAN,
+					  (TSTR
+					   (" Allocating from %d %d" TENDSTR),
+					   blk, c));
+					state = YAFFS_BLOCK_STATE_ALLOCATING;
+					dev->allocationBlock = blk;
+					dev->allocationPage = c;
+					dev->allocationBlockFinder = blk;
+					/* Set it to here to encourage the allocator to go forth from here. */
+
+				}
+
+				dev->nFreeChunks += (dev->nChunksPerBlock - c);
+			} else if (tags.chunkId > 0) {
+				/* chunkId > 0 so it is a data chunk... */
+				unsigned int endpos;
+
+				yaffs_SetChunkBit(dev, blk, c);
+				bi->pagesInUse++;
+
+				in = yaffs_FindOrCreateObjectByNumber(dev,
+								      tags.
+								      objectId,
+								      YAFFS_OBJECT_TYPE_FILE);
+				/* PutChunkIntoFile checks for a clash (two data chunks with
+				 * the same chunkId).
+				 */
+
+				if (!in)
+					alloc_failed = 1;
+
+				if (in) {
+					if (!yaffs_PutChunkIntoFile(in, tags.chunkId, chunk, 1))
+						alloc_failed = 1;
+				}
+
+				endpos =
+				    (tags.chunkId - 1) * dev->nDataBytesPerChunk +
+				    tags.byteCount;
+				if (in &&
+				    in->variantType == YAFFS_OBJECT_TYPE_FILE
+				    && in->variant.fileVariant.scannedFileSize <
+				    endpos) {
+					in->variant.fileVariant.
+					    scannedFileSize = endpos;
+					if (!dev->useHeaderFileSize) {
+						in->variant.fileVariant.
+						    fileSize =
+						    in->variant.fileVariant.
+						    scannedFileSize;
+					}
+
+				}
+				/* T((" %d %d data %d %d\n",blk,c,tags.objectId,tags.chunkId));   */
+			} else {
+				/* chunkId == 0, so it is an ObjectHeader.
+				 * Thus, we read in the object header and make the object
+				 */
+				yaffs_SetChunkBit(dev, blk, c);
+				bi->pagesInUse++;
+
+				result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk,
+								chunkData,
+								NULL);
+
+				oh = (yaffs_ObjectHeader *) chunkData;
+
+				in = yaffs_FindObjectByNumber(dev,
+							      tags.objectId);
+				if (in && in->variantType != oh->type) {
+					/* This should not happen, but somehow
+					 * Wev'e ended up with an objectId that has been reused but not yet
+					 * deleted, and worse still it has changed type. Delete the old object.
+					 */
+
+					yaffs_DeleteObject(in);
+
+					in = 0;
+				}
+
+				in = yaffs_FindOrCreateObjectByNumber(dev,
+								      tags.
+								      objectId,
+								      oh->type);
+
+				if (!in)
+					alloc_failed = 1;
+
+				if (in && oh->shadowsObject > 0) {
+
+					struct yaffs_ShadowFixerStruct *fixer;
+					fixer = YMALLOC(sizeof(struct yaffs_ShadowFixerStruct));
+					if (fixer) {
+						fixer->next = shadowFixerList;
+						shadowFixerList = fixer;
+						fixer->objectId = tags.objectId;
+						fixer->shadowedId = oh->shadowsObject;
+					}
+
+				}
+
+				if (in && in->valid) {
+					/* We have already filled this one. We have a duplicate and need to resolve it. */
+
+					unsigned existingSerial = in->serial;
+					unsigned newSerial = tags.serialNumber;
+
+					if (((existingSerial + 1) & 3) == newSerial) {
+						/* Use new one - destroy the exisiting one */
+						yaffs_DeleteChunk(dev,
+								  in->hdrChunk,
+								  1, __LINE__);
+						in->valid = 0;
+					} else {
+						/* Use existing - destroy this one. */
+						yaffs_DeleteChunk(dev, chunk, 1,
+								  __LINE__);
+					}
+				}
+
+				if (in && !in->valid &&
+				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
+				     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND)) {
+					/* We only load some info, don't fiddle with directory structure */
+					in->valid = 1;
+					in->variantType = oh->type;
+
+					in->yst_mode = oh->yst_mode;
+#ifdef CONFIG_YAFFS_WINCE
+					in->win_atime[0] = oh->win_atime[0];
+					in->win_ctime[0] = oh->win_ctime[0];
+					in->win_mtime[0] = oh->win_mtime[0];
+					in->win_atime[1] = oh->win_atime[1];
+					in->win_ctime[1] = oh->win_ctime[1];
+					in->win_mtime[1] = oh->win_mtime[1];
+#else
+					in->yst_uid = oh->yst_uid;
+					in->yst_gid = oh->yst_gid;
+					in->yst_atime = oh->yst_atime;
+					in->yst_mtime = oh->yst_mtime;
+					in->yst_ctime = oh->yst_ctime;
+					in->yst_rdev = oh->yst_rdev;
+#endif
+					in->hdrChunk = chunk;
+					in->serial = tags.serialNumber;
+
+				} else if (in && !in->valid) {
+					/* we need to load this info */
+
+					in->valid = 1;
+					in->variantType = oh->type;
+
+					in->yst_mode = oh->yst_mode;
+#ifdef CONFIG_YAFFS_WINCE
+					in->win_atime[0] = oh->win_atime[0];
+					in->win_ctime[0] = oh->win_ctime[0];
+					in->win_mtime[0] = oh->win_mtime[0];
+					in->win_atime[1] = oh->win_atime[1];
+					in->win_ctime[1] = oh->win_ctime[1];
+					in->win_mtime[1] = oh->win_mtime[1];
+#else
+					in->yst_uid = oh->yst_uid;
+					in->yst_gid = oh->yst_gid;
+					in->yst_atime = oh->yst_atime;
+					in->yst_mtime = oh->yst_mtime;
+					in->yst_ctime = oh->yst_ctime;
+					in->yst_rdev = oh->yst_rdev;
+#endif
+					in->hdrChunk = chunk;
+					in->serial = tags.serialNumber;
+
+					yaffs_SetObjectName(in, oh->name);
+					in->dirty = 0;
+
+					/* directory stuff...
+					 * hook up to parent
+					 */
+
+					parent =
+					    yaffs_FindOrCreateObjectByNumber
+					    (dev, oh->parentObjectId,
+					     YAFFS_OBJECT_TYPE_DIRECTORY);
+					if (!parent)
+						alloc_failed = 1;
+					if (parent && parent->variantType ==
+					    YAFFS_OBJECT_TYPE_UNKNOWN) {
+						/* Set up as a directory */
+						parent->variantType =
+							YAFFS_OBJECT_TYPE_DIRECTORY;
+						YINIT_LIST_HEAD(&parent->variant.
+								directoryVariant.
+								children);
+					} else if (!parent || parent->variantType !=
+						   YAFFS_OBJECT_TYPE_DIRECTORY) {
+						/* Hoosterman, another problem....
+						 * We're trying to use a non-directory as a directory
+						 */
+
+						T(YAFFS_TRACE_ERROR,
+						  (TSTR
+						   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+						    TENDSTR)));
+						parent = dev->lostNFoundDir;
+					}
+
+					yaffs_AddObjectToDirectory(parent, in);
+
+					if (0 && (parent == dev->deletedDir ||
+						  parent == dev->unlinkedDir)) {
+						in->deleted = 1;	/* If it is unlinked at start up then it wants deleting */
+						dev->nDeletedFiles++;
+					}
+					/* Note re hardlinks.
+					 * Since we might scan a hardlink before its equivalent object is scanned
+					 * we put them all in a list.
+					 * After scanning is complete, we should have all the objects, so we run through this
+					 * list and fix up all the chains.
+					 */
+
+					switch (in->variantType) {
+					case YAFFS_OBJECT_TYPE_UNKNOWN:
+						/* Todo got a problem */
+						break;
+					case YAFFS_OBJECT_TYPE_FILE:
+						if (dev->useHeaderFileSize)
+
+							in->variant.fileVariant.
+							    fileSize =
+							    oh->fileSize;
+
+						break;
+					case YAFFS_OBJECT_TYPE_HARDLINK:
+						in->variant.hardLinkVariant.
+							equivalentObjectId =
+							oh->equivalentObjectId;
+						in->hardLinks.next =
+							(struct ylist_head *)
+							hardList;
+						hardList = in;
+						break;
+					case YAFFS_OBJECT_TYPE_DIRECTORY:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SPECIAL:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SYMLINK:
+						in->variant.symLinkVariant.alias =
+						    yaffs_CloneString(oh->alias);
+						if (!in->variant.symLinkVariant.alias)
+							alloc_failed = 1;
+						break;
+					}
+
+/*
+					if (parent == dev->deletedDir) {
+						yaffs_DestroyObject(in);
+						bi->hasShrinkHeader = 1;
+					}
+*/
+				}
+			}
+		}
+
+		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+			/* If we got this far while scanning, then the block is fully allocated.*/
+			state = YAFFS_BLOCK_STATE_FULL;
+		}
+
+		bi->blockState = state;
+
+		/* Now let's see if it was dirty */
+		if (bi->pagesInUse == 0 &&
+		    !bi->hasShrinkHeader &&
+		    bi->blockState == YAFFS_BLOCK_STATE_FULL) {
+			yaffs_BlockBecameDirty(dev, blk);
+		}
+
+	}
+
+
+	/* Ok, we've done all the scanning.
+	 * Fix up the hard link chains.
+	 * We should now have scanned all the objects, now it's time to add these
+	 * hardlinks.
+	 */
+
+	yaffs_HardlinkFixup(dev, hardList);
+
+	/* Fix up any shadowed objects */
+	{
+		struct yaffs_ShadowFixerStruct *fixer;
+		yaffs_Object *obj;
+
+		while (shadowFixerList) {
+			fixer = shadowFixerList;
+			shadowFixerList = fixer->next;
+			/* Complete the rename transaction by deleting the shadowed object
+			 * then setting the object header to unshadowed.
+			 */
+			obj = yaffs_FindObjectByNumber(dev, fixer->shadowedId);
+			if (obj)
+				yaffs_DeleteObject(obj);
+
+			obj = yaffs_FindObjectByNumber(dev, fixer->objectId);
+
+			if (obj)
+				yaffs_UpdateObjectHeader(obj, NULL, 1, 0, 0);
+
+			YFREE(fixer);
+		}
+	}
+
+	yaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);
+
+	if (alloc_failed)
+		return YAFFS_FAIL;
+
+	T(YAFFS_TRACE_SCAN, (TSTR("yaffs_Scan ends" TENDSTR)));
+
+
+	return YAFFS_OK;
+}
+
+static void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in)
+{
+	__u8 *chunkData;
+	yaffs_ObjectHeader *oh;
+	yaffs_Device *dev;
+	yaffs_ExtendedTags tags;
+	int result;
+	int alloc_failed = 0;
+
+	if (!in)
+		return;
+
+	dev = in->myDev;
+
+#if 0
+	T(YAFFS_TRACE_SCAN, (TSTR("details for object %d %s loaded" TENDSTR),
+		in->objectId,
+		in->lazyLoaded ? "not yet" : "already"));
+#endif
+
+	if (in->lazyLoaded && in->hdrChunk > 0) {
+		in->lazyLoaded = 0;
+		chunkData = yaffs_GetTempBuffer(dev, __LINE__);
+
+		result = yaffs_ReadChunkWithTagsFromNAND(dev, in->hdrChunk, chunkData, &tags);
+		oh = (yaffs_ObjectHeader *) chunkData;
+
+		in->yst_mode = oh->yst_mode;
+#ifdef CONFIG_YAFFS_WINCE
+		in->win_atime[0] = oh->win_atime[0];
+		in->win_ctime[0] = oh->win_ctime[0];
+		in->win_mtime[0] = oh->win_mtime[0];
+		in->win_atime[1] = oh->win_atime[1];
+		in->win_ctime[1] = oh->win_ctime[1];
+		in->win_mtime[1] = oh->win_mtime[1];
+#else
+		in->yst_uid = oh->yst_uid;
+		in->yst_gid = oh->yst_gid;
+		in->yst_atime = oh->yst_atime;
+		in->yst_mtime = oh->yst_mtime;
+		in->yst_ctime = oh->yst_ctime;
+		in->yst_rdev = oh->yst_rdev;
+
+#endif
+		yaffs_SetObjectName(in, oh->name);
+
+		if (in->variantType == YAFFS_OBJECT_TYPE_SYMLINK) {
+			in->variant.symLinkVariant.alias =
+						    yaffs_CloneString(oh->alias);
+			if (!in->variant.symLinkVariant.alias)
+				alloc_failed = 1; /* Not returned to caller */
+		}
+
+		yaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);
+	}
+}
+
+static int yaffs_ScanBackwards(yaffs_Device *dev)
+{
+	yaffs_ExtendedTags tags;
+	int blk;
+	int blockIterator;
+	int startIterator;
+	int endIterator;
+	int nBlocksToScan = 0;
+
+	int chunk;
+	int result;
+	int c;
+	int deleted;
+	yaffs_BlockState state;
+	yaffs_Object *hardList = NULL;
+	yaffs_BlockInfo *bi;
+	__u32 sequenceNumber;
+	yaffs_ObjectHeader *oh;
+	yaffs_Object *in;
+	yaffs_Object *parent;
+	int nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;
+	int itsUnlinked;
+	__u8 *chunkData;
+
+	int fileSize;
+	int isShrink;
+	int foundChunksInBlock;
+	int equivalentObjectId;
+	int alloc_failed = 0;
+
+
+	yaffs_BlockIndex *blockIndex = NULL;
+	int altBlockIndex = 0;
+
+	if (!dev->isYaffs2) {
+		T(YAFFS_TRACE_SCAN,
+		  (TSTR("yaffs_ScanBackwards is only for YAFFS2!" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	T(YAFFS_TRACE_SCAN,
+	  (TSTR
+	   ("yaffs_ScanBackwards starts  intstartblk %d intendblk %d..."
+	    TENDSTR), dev->internalStartBlock, dev->internalEndBlock));
+
+
+	dev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;
+
+	blockIndex = YMALLOC(nBlocks * sizeof(yaffs_BlockIndex));
+
+	if (!blockIndex) {
+		blockIndex = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockIndex));
+		altBlockIndex = 1;
+	}
+
+	if (!blockIndex) {
+		T(YAFFS_TRACE_SCAN,
+		  (TSTR("yaffs_Scan() could not allocate block index!" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	dev->blocksInCheckpoint = 0;
+
+	chunkData = yaffs_GetTempBuffer(dev, __LINE__);
+
+	/* Scan all the blocks to determine their state */
+	for (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {
+		bi = yaffs_GetBlockInfo(dev, blk);
+		yaffs_ClearChunkBits(dev, blk);
+		bi->pagesInUse = 0;
+		bi->softDeletions = 0;
+
+		yaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);
+
+		bi->blockState = state;
+		bi->sequenceNumber = sequenceNumber;
+
+		if (bi->sequenceNumber == YAFFS_SEQUENCE_CHECKPOINT_DATA)
+			bi->blockState = state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		if (bi->sequenceNumber == YAFFS_SEQUENCE_BAD_BLOCK)
+			bi->blockState = state = YAFFS_BLOCK_STATE_DEAD;
+
+		T(YAFFS_TRACE_SCAN_DEBUG,
+		  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,
+		   state, sequenceNumber));
+
+
+		if (state == YAFFS_BLOCK_STATE_CHECKPOINT) {
+			dev->blocksInCheckpoint++;
+
+		} else if (state == YAFFS_BLOCK_STATE_DEAD) {
+			T(YAFFS_TRACE_BAD_BLOCKS,
+			  (TSTR("block %d is bad" TENDSTR), blk));
+		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
+			T(YAFFS_TRACE_SCAN_DEBUG,
+			  (TSTR("Block empty " TENDSTR)));
+			dev->nErasedBlocks++;
+			dev->nFreeChunks += dev->nChunksPerBlock;
+		} else if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+
+			/* Determine the highest sequence number */
+			if (sequenceNumber >= YAFFS_LOWEST_SEQUENCE_NUMBER &&
+			    sequenceNumber < YAFFS_HIGHEST_SEQUENCE_NUMBER) {
+
+				blockIndex[nBlocksToScan].seq = sequenceNumber;
+				blockIndex[nBlocksToScan].block = blk;
+
+				nBlocksToScan++;
+
+				if (sequenceNumber >= dev->sequenceNumber)
+					dev->sequenceNumber = sequenceNumber;
+			} else {
+				/* TODO: Nasty sequence number! */
+				T(YAFFS_TRACE_SCAN,
+				  (TSTR
+				   ("Block scanning block %d has bad sequence number %d"
+				    TENDSTR), blk, sequenceNumber));
+
+			}
+		}
+	}
+
+	T(YAFFS_TRACE_SCAN,
+	(TSTR("%d blocks to be sorted..." TENDSTR), nBlocksToScan));
+
+
+
+	YYIELD();
+
+	/* Sort the blocks */
+#ifndef CONFIG_YAFFS_USE_OWN_SORT
+	{
+		/* Use qsort now. */
+		yaffs_qsort(blockIndex, nBlocksToScan, sizeof(yaffs_BlockIndex), ybicmp);
+	}
+#else
+	{
+		/* Dungy old bubble sort... */
+
+		yaffs_BlockIndex temp;
+		int i;
+		int j;
+
+		for (i = 0; i < nBlocksToScan; i++)
+			for (j = i + 1; j < nBlocksToScan; j++)
+				if (blockIndex[i].seq > blockIndex[j].seq) {
+					temp = blockIndex[j];
+					blockIndex[j] = blockIndex[i];
+					blockIndex[i] = temp;
+				}
+	}
+#endif
+
+	YYIELD();
+
+	T(YAFFS_TRACE_SCAN, (TSTR("...done" TENDSTR)));
+
+	/* Now scan the blocks looking at the data. */
+	startIterator = 0;
+	endIterator = nBlocksToScan - 1;
+	T(YAFFS_TRACE_SCAN_DEBUG,
+	  (TSTR("%d blocks to be scanned" TENDSTR), nBlocksToScan));
+
+	/* For each block.... backwards */
+	for (blockIterator = endIterator; !alloc_failed && blockIterator >= startIterator;
+			blockIterator--) {
+		/* Cooperative multitasking! This loop can run for so
+		   long that watchdog timers expire. */
+		YYIELD();
+
+		/* get the block to scan in the correct order */
+		blk = blockIndex[blockIterator].block;
+
+		bi = yaffs_GetBlockInfo(dev, blk);
+
+
+		state = bi->blockState;
+
+		deleted = 0;
+
+		/* For each chunk in each block that needs scanning.... */
+		foundChunksInBlock = 0;
+		for (c = dev->nChunksPerBlock - 1;
+		     !alloc_failed && c >= 0 &&
+		     (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
+		      state == YAFFS_BLOCK_STATE_ALLOCATING); c--) {
+			/* Scan backwards...
+			 * Read the tags and decide what to do
+			 */
+
+			chunk = blk * dev->nChunksPerBlock + c;
+
+			result = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,
+							&tags);
+
+			/* Let's have a good look at this chunk... */
+
+			if (!tags.chunkUsed) {
+				/* An unassigned chunk in the block.
+				 * If there are used chunks after this one, then
+				 * it is a chunk that was skipped due to failing the erased
+				 * check. Just skip it so that it can be deleted.
+				 * But, more typically, We get here when this is an unallocated
+				 * chunk and his means that either the block is empty or
+				 * this is the one being allocated from
+				 */
+
+				if (foundChunksInBlock) {
+					/* This is a chunk that was skipped due to failing the erased check */
+				} else if (c == 0) {
+					/* We're looking at the first chunk in the block so the block is unused */
+					state = YAFFS_BLOCK_STATE_EMPTY;
+					dev->nErasedBlocks++;
+				} else {
+					if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
+					    state == YAFFS_BLOCK_STATE_ALLOCATING) {
+						if (dev->sequenceNumber == bi->sequenceNumber) {
+							/* this is the block being allocated from */
+
+							T(YAFFS_TRACE_SCAN,
+							  (TSTR
+							   (" Allocating from %d %d"
+							    TENDSTR), blk, c));
+
+							state = YAFFS_BLOCK_STATE_ALLOCATING;
+							dev->allocationBlock = blk;
+							dev->allocationPage = c;
+							dev->allocationBlockFinder = blk;
+						} else {
+							/* This is a partially written block that is not
+							 * the current allocation block. This block must have
+							 * had a write failure, so set up for retirement.
+							 */
+
+							 /* bi->needsRetiring = 1; ??? TODO */
+							 bi->gcPrioritise = 1;
+
+							 T(YAFFS_TRACE_ALWAYS,
+							 (TSTR("Partially written block %d detected" TENDSTR),
+							 blk));
+						}
+					}
+				}
+
+				dev->nFreeChunks++;
+
+			} else if (tags.eccResult == YAFFS_ECC_RESULT_UNFIXED) {
+				T(YAFFS_TRACE_SCAN,
+				  (TSTR(" Unfixed ECC in chunk(%d:%d), chunk ignored"TENDSTR),
+				  blk, c));
+
+				  dev->nFreeChunks++;
+
+			} else if (tags.chunkId > 0) {
+				/* chunkId > 0 so it is a data chunk... */
+				unsigned int endpos;
+				__u32 chunkBase =
+				    (tags.chunkId - 1) * dev->nDataBytesPerChunk;
+
+				foundChunksInBlock = 1;
+
+
+				yaffs_SetChunkBit(dev, blk, c);
+				bi->pagesInUse++;
+
+				in = yaffs_FindOrCreateObjectByNumber(dev,
+								      tags.
+								      objectId,
+								      YAFFS_OBJECT_TYPE_FILE);
+				if (!in) {
+					/* Out of memory */
+					alloc_failed = 1;
+				}
+
+				if (in &&
+				    in->variantType == YAFFS_OBJECT_TYPE_FILE
+				    && chunkBase <
+				    in->variant.fileVariant.shrinkSize) {
+					/* This has not been invalidated by a resize */
+					if (!yaffs_PutChunkIntoFile(in, tags.chunkId,
+							       chunk, -1)) {
+						alloc_failed = 1;
+					}
+
+					/* File size is calculated by looking at the data chunks if we have not
+					 * seen an object header yet. Stop this practice once we find an object header.
+					 */
+					endpos =
+					    (tags.chunkId -
+					     1) * dev->nDataBytesPerChunk +
+					    tags.byteCount;
+
+					if (!in->valid &&	/* have not got an object header yet */
+					    in->variant.fileVariant.
+					    scannedFileSize < endpos) {
+						in->variant.fileVariant.
+						    scannedFileSize = endpos;
+						in->variant.fileVariant.
+						    fileSize =
+						    in->variant.fileVariant.
+						    scannedFileSize;
+					}
+
+				} else if (in) {
+					/* This chunk has been invalidated by a resize, so delete */
+					yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
+
+				}
+			} else {
+				/* chunkId == 0, so it is an ObjectHeader.
+				 * Thus, we read in the object header and make the object
+				 */
+				foundChunksInBlock = 1;
+
+				yaffs_SetChunkBit(dev, blk, c);
+				bi->pagesInUse++;
+
+				oh = NULL;
+				in = NULL;
+
+				if (tags.extraHeaderInfoAvailable) {
+					in = yaffs_FindOrCreateObjectByNumber
+					    (dev, tags.objectId,
+					     tags.extraObjectType);
+					if (!in)
+						alloc_failed = 1;
+				}
+
+				if (!in ||
+#ifdef CONFIG_YAFFS_DISABLE_LAZY_LOAD
+				    !in->valid ||
+#endif
+				    tags.extraShadows ||
+				    (!in->valid &&
+				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
+				     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND))) {
+
+					/* If we don't have  valid info then we need to read the chunk
+					 * TODO In future we can probably defer reading the chunk and
+					 * living with invalid data until needed.
+					 */
+
+					result = yaffs_ReadChunkWithTagsFromNAND(dev,
+									chunk,
+									chunkData,
+									NULL);
+
+					oh = (yaffs_ObjectHeader *) chunkData;
+
+					if (dev->inbandTags) {
+						/* Fix up the header if they got corrupted by inband tags */
+						oh->shadowsObject = oh->inbandShadowsObject;
+						oh->isShrink = oh->inbandIsShrink;
+					}
+
+					if (!in) {
+						in = yaffs_FindOrCreateObjectByNumber(dev, tags.objectId, oh->type);
+						if (!in)
+							alloc_failed = 1;
+					}
+
+				}
+
+				if (!in) {
+					/* TODO Hoosterman we have a problem! */
+					T(YAFFS_TRACE_ERROR,
+					  (TSTR
+					   ("yaffs tragedy: Could not make object for object  %d at chunk %d during scan"
+					    TENDSTR), tags.objectId, chunk));
+					continue;
+				}
+
+				if (in->valid) {
+					/* We have already filled this one.
+					 * We have a duplicate that will be discarded, but
+					 * we first have to suck out resize info if it is a file.
+					 */
+
+					if ((in->variantType == YAFFS_OBJECT_TYPE_FILE) &&
+					     ((oh &&
+					       oh->type == YAFFS_OBJECT_TYPE_FILE) ||
+					      (tags.extraHeaderInfoAvailable  &&
+					       tags.extraObjectType == YAFFS_OBJECT_TYPE_FILE))) {
+						__u32 thisSize =
+						    (oh) ? oh->fileSize : tags.
+						    extraFileLength;
+						__u32 parentObjectId =
+						    (oh) ? oh->
+						    parentObjectId : tags.
+						    extraParentObjectId;
+
+
+						isShrink =
+						    (oh) ? oh->isShrink : tags.
+						    extraIsShrinkHeader;
+
+						/* If it is deleted (unlinked at start also means deleted)
+						 * we treat the file size as being zeroed at this point.
+						 */
+						if (parentObjectId ==
+						    YAFFS_OBJECTID_DELETED
+						    || parentObjectId ==
+						    YAFFS_OBJECTID_UNLINKED) {
+							thisSize = 0;
+							isShrink = 1;
+						}
+
+						if (isShrink &&
+						    in->variant.fileVariant.
+						    shrinkSize > thisSize) {
+							in->variant.fileVariant.
+							    shrinkSize =
+							    thisSize;
+						}
+
+						if (isShrink)
+							bi->hasShrinkHeader = 1;
+
+					}
+					/* Use existing - destroy this one. */
+					yaffs_DeleteChunk(dev, chunk, 1, __LINE__);
+
+				}
+
+				if (!in->valid && in->variantType !=
+				    (oh ? oh->type : tags.extraObjectType))
+					T(YAFFS_TRACE_ERROR, (
+						TSTR("yaffs tragedy: Bad object type, "
+					    TCONT("%d != %d, for object %d at chunk ")
+					    TCONT("%d during scan")
+						TENDSTR), oh ?
+					    oh->type : tags.extraObjectType,
+					    in->variantType, tags.objectId,
+					    chunk));
+
+				if (!in->valid &&
+				    (tags.objectId == YAFFS_OBJECTID_ROOT ||
+				     tags.objectId ==
+				     YAFFS_OBJECTID_LOSTNFOUND)) {
+					/* We only load some info, don't fiddle with directory structure */
+					in->valid = 1;
+
+					if (oh) {
+						in->variantType = oh->type;
+
+						in->yst_mode = oh->yst_mode;
+#ifdef CONFIG_YAFFS_WINCE
+						in->win_atime[0] = oh->win_atime[0];
+						in->win_ctime[0] = oh->win_ctime[0];
+						in->win_mtime[0] = oh->win_mtime[0];
+						in->win_atime[1] = oh->win_atime[1];
+						in->win_ctime[1] = oh->win_ctime[1];
+						in->win_mtime[1] = oh->win_mtime[1];
+#else
+						in->yst_uid = oh->yst_uid;
+						in->yst_gid = oh->yst_gid;
+						in->yst_atime = oh->yst_atime;
+						in->yst_mtime = oh->yst_mtime;
+						in->yst_ctime = oh->yst_ctime;
+						in->yst_rdev = oh->yst_rdev;
+
+#endif
+					} else {
+						in->variantType = tags.extraObjectType;
+						in->lazyLoaded = 1;
+					}
+
+					in->hdrChunk = chunk;
+
+				} else if (!in->valid) {
+					/* we need to load this info */
+
+					in->valid = 1;
+					in->hdrChunk = chunk;
+
+					if (oh) {
+						in->variantType = oh->type;
+
+						in->yst_mode = oh->yst_mode;
+#ifdef CONFIG_YAFFS_WINCE
+						in->win_atime[0] = oh->win_atime[0];
+						in->win_ctime[0] = oh->win_ctime[0];
+						in->win_mtime[0] = oh->win_mtime[0];
+						in->win_atime[1] = oh->win_atime[1];
+						in->win_ctime[1] = oh->win_ctime[1];
+						in->win_mtime[1] = oh->win_mtime[1];
+#else
+						in->yst_uid = oh->yst_uid;
+						in->yst_gid = oh->yst_gid;
+						in->yst_atime = oh->yst_atime;
+						in->yst_mtime = oh->yst_mtime;
+						in->yst_ctime = oh->yst_ctime;
+						in->yst_rdev = oh->yst_rdev;
+#endif
+
+						if (oh->shadowsObject > 0)
+							yaffs_HandleShadowedObject(dev,
+									   oh->
+									   shadowsObject,
+									   1);
+
+
+						yaffs_SetObjectName(in, oh->name);
+						parent =
+						    yaffs_FindOrCreateObjectByNumber
+							(dev, oh->parentObjectId,
+							 YAFFS_OBJECT_TYPE_DIRECTORY);
+
+						 fileSize = oh->fileSize;
+						 isShrink = oh->isShrink;
+						 equivalentObjectId = oh->equivalentObjectId;
+
+					} else {
+						in->variantType = tags.extraObjectType;
+						parent =
+						    yaffs_FindOrCreateObjectByNumber
+							(dev, tags.extraParentObjectId,
+							 YAFFS_OBJECT_TYPE_DIRECTORY);
+						 fileSize = tags.extraFileLength;
+						 isShrink = tags.extraIsShrinkHeader;
+						 equivalentObjectId = tags.extraEquivalentObjectId;
+						in->lazyLoaded = 1;
+
+					}
+					in->dirty = 0;
+
+					if (!parent)
+						alloc_failed = 1;
+
+					/* directory stuff...
+					 * hook up to parent
+					 */
+
+					if (parent && parent->variantType ==
+					    YAFFS_OBJECT_TYPE_UNKNOWN) {
+						/* Set up as a directory */
+						parent->variantType =
+							YAFFS_OBJECT_TYPE_DIRECTORY;
+						YINIT_LIST_HEAD(&parent->variant.
+							directoryVariant.
+							children);
+					} else if (!parent || parent->variantType !=
+						   YAFFS_OBJECT_TYPE_DIRECTORY) {
+						/* Hoosterman, another problem....
+						 * We're trying to use a non-directory as a directory
+						 */
+
+						T(YAFFS_TRACE_ERROR,
+						  (TSTR
+						   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+						    TENDSTR)));
+						parent = dev->lostNFoundDir;
+					}
+
+					yaffs_AddObjectToDirectory(parent, in);
+
+					itsUnlinked = (parent == dev->deletedDir) ||
+						      (parent == dev->unlinkedDir);
+
+					if (isShrink) {
+						/* Mark the block as having a shrinkHeader */
+						bi->hasShrinkHeader = 1;
+					}
+
+					/* Note re hardlinks.
+					 * Since we might scan a hardlink before its equivalent object is scanned
+					 * we put them all in a list.
+					 * After scanning is complete, we should have all the objects, so we run
+					 * through this list and fix up all the chains.
+					 */
+
+					switch (in->variantType) {
+					case YAFFS_OBJECT_TYPE_UNKNOWN:
+						/* Todo got a problem */
+						break;
+					case YAFFS_OBJECT_TYPE_FILE:
+
+						if (in->variant.fileVariant.
+						    scannedFileSize < fileSize) {
+							/* This covers the case where the file size is greater
+							 * than where the data is
+							 * This will happen if the file is resized to be larger
+							 * than its current data extents.
+							 */
+							in->variant.fileVariant.fileSize = fileSize;
+							in->variant.fileVariant.scannedFileSize =
+							    in->variant.fileVariant.fileSize;
+						}
+
+						if (isShrink &&
+						    in->variant.fileVariant.shrinkSize > fileSize) {
+							in->variant.fileVariant.shrinkSize = fileSize;
+						}
+
+						break;
+					case YAFFS_OBJECT_TYPE_HARDLINK:
+						if (!itsUnlinked) {
+							in->variant.hardLinkVariant.equivalentObjectId =
+								equivalentObjectId;
+							in->hardLinks.next =
+								(struct ylist_head *) hardList;
+							hardList = in;
+						}
+						break;
+					case YAFFS_OBJECT_TYPE_DIRECTORY:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SPECIAL:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SYMLINK:
+						if (oh) {
+							in->variant.symLinkVariant.alias =
+								yaffs_CloneString(oh->alias);
+							if (!in->variant.symLinkVariant.alias)
+								alloc_failed = 1;
+						}
+						break;
+					}
+
+				}
+
+			}
+
+		} /* End of scanning for each chunk */
+
+		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+			/* If we got this far while scanning, then the block is fully allocated. */
+			state = YAFFS_BLOCK_STATE_FULL;
+		}
+
+		bi->blockState = state;
+
+		/* Now let's see if it was dirty */
+		if (bi->pagesInUse == 0 &&
+		    !bi->hasShrinkHeader &&
+		    bi->blockState == YAFFS_BLOCK_STATE_FULL) {
+			yaffs_BlockBecameDirty(dev, blk);
+		}
+
+	}
+
+	if (altBlockIndex)
+		YFREE_ALT(blockIndex);
+	else
+		YFREE(blockIndex);
+
+	/* Ok, we've done all the scanning.
+	 * Fix up the hard link chains.
+	 * We should now have scanned all the objects, now it's time to add these
+	 * hardlinks.
+	 */
+	yaffs_HardlinkFixup(dev, hardList);
+
+
+	yaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);
+
+	if (alloc_failed)
+		return YAFFS_FAIL;
+
+	T(YAFFS_TRACE_SCAN, (TSTR("yaffs_ScanBackwards ends" TENDSTR)));
+
+	return YAFFS_OK;
+}
+
+/*------------------------------  Directory Functions ----------------------------- */
+
+static void yaffs_VerifyObjectInDirectory(yaffs_Object *obj)
+{
+	struct ylist_head *lh;
+	yaffs_Object *listObj;
+
+	int count = 0;
+
+	if (!obj) {
+		T(YAFFS_TRACE_ALWAYS, (TSTR("No object to verify" TENDSTR)));
+		YBUG();
+		return;
+	}
+
+	if (yaffs_SkipVerification(obj->myDev))
+		return;
+
+	if (!obj->parent) {
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Object does not have parent" TENDSTR)));
+		YBUG();
+		return;
+	}
+
+	if (obj->parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Parent is not directory" TENDSTR)));
+		YBUG();
+	}
+
+	/* Iterate through the objects in each hash entry */
+
+	ylist_for_each(lh, &obj->parent->variant.directoryVariant.children) {
+		if (lh) {
+			listObj = ylist_entry(lh, yaffs_Object, siblings);
+			yaffs_VerifyObject(listObj);
+			if (obj == listObj)
+				count++;
+		}
+	 }
+
+	if (count != 1) {
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory %d times" TENDSTR), count));
+		YBUG();
+	}
+}
+
+static void yaffs_VerifyDirectory(yaffs_Object *directory)
+{
+	struct ylist_head *lh;
+	yaffs_Object *listObj;
+
+	if (!directory) {
+		YBUG();
+		return;
+	}
+
+	if (yaffs_SkipFullVerification(directory->myDev))
+		return;
+
+	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Directory has wrong type: %d" TENDSTR), directory->variantType));
+		YBUG();
+	}
+
+	/* Iterate through the objects in each hash entry */
+
+	ylist_for_each(lh, &directory->variant.directoryVariant.children) {
+		if (lh) {
+			listObj = ylist_entry(lh, yaffs_Object, siblings);
+			if (listObj->parent != directory) {
+				T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory list has wrong parent %p" TENDSTR), listObj->parent));
+				YBUG();
+			}
+			yaffs_VerifyObjectInDirectory(listObj);
+		}
+	}
+}
+
+/*
+ *yaffs_UpdateParent() handles fixing a directories mtime and ctime when a new
+ * link (ie. name) is created or deleted in the directory.
+ *
+ * ie.
+ *   create dir/a : update dir's mtime/ctime
+ *   rm dir/a:   update dir's mtime/ctime
+ *   modify dir/a: don't update dir's mtimme/ctime
+ */
+ 
+static void yaffs_UpdateParent(yaffs_Object *obj)
+{
+	if(!obj)
+		return;
+
+	obj->dirty = 1;
+	obj->yst_mtime = obj->yst_ctime = Y_CURRENT_TIME;
+
+	yaffs_UpdateObjectHeader(obj,NULL,0,0,0);
+}
+
+static void yaffs_RemoveObjectFromDirectory(yaffs_Object *obj)
+{
+	yaffs_Device *dev = obj->myDev;
+	yaffs_Object *parent;
+
+	yaffs_VerifyObjectInDirectory(obj);
+	parent = obj->parent;
+
+	yaffs_VerifyDirectory(parent);
+
+	if (dev && dev->removeObjectCallback)
+		dev->removeObjectCallback(obj);
+
+
+	ylist_del_init(&obj->siblings);
+	obj->parent = NULL;
+	
+	yaffs_VerifyDirectory(parent);
+}
+
+static void yaffs_AddObjectToDirectory(yaffs_Object *directory,
+					yaffs_Object *obj)
+{
+	if (!directory) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: Trying to add an object to a null pointer directory"
+		    TENDSTR)));
+		YBUG();
+		return;
+	}
+	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: Trying to add an object to a non-directory"
+		    TENDSTR)));
+		YBUG();
+	}
+
+	if (obj->siblings.prev == NULL) {
+		/* Not initialised */
+		YBUG();
+	}
+
+
+	yaffs_VerifyDirectory(directory);
+
+	yaffs_RemoveObjectFromDirectory(obj);
+
+
+	/* Now add it */
+	ylist_add(&obj->siblings, &directory->variant.directoryVariant.children);
+	obj->parent = directory;
+
+	if (directory == obj->myDev->unlinkedDir
+			|| directory == obj->myDev->deletedDir) {
+		obj->unlinked = 1;
+		obj->myDev->nUnlinkedFiles++;
+		obj->renameAllowed = 0;
+	}
+
+	yaffs_VerifyDirectory(directory);
+	yaffs_VerifyObjectInDirectory(obj);
+}
+
+yaffs_Object *yaffs_FindObjectByName(yaffs_Object *directory,
+				     const YCHAR *name)
+{
+	int sum;
+
+	struct ylist_head *i;
+	YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];
+
+	yaffs_Object *l;
+
+	if (!name)
+		return NULL;
+
+	if (!directory) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_FindObjectByName: null pointer directory"
+		    TENDSTR)));
+		YBUG();
+		return NULL;
+	}
+	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_FindObjectByName: non-directory" TENDSTR)));
+		YBUG();
+	}
+
+	sum = yaffs_CalcNameSum(name);
+
+	ylist_for_each(i, &directory->variant.directoryVariant.children) {
+		if (i) {
+			l = ylist_entry(i, yaffs_Object, siblings);
+
+			if (l->parent != directory)
+				YBUG();
+
+			yaffs_CheckObjectDetailsLoaded(l);
+
+			/* Special case for lost-n-found */
+			if (l->objectId == YAFFS_OBJECTID_LOSTNFOUND) {
+				if (yaffs_strcmp(name, YAFFS_LOSTNFOUND_NAME) == 0)
+					return l;
+			} else if (yaffs_SumCompare(l->sum, sum) || l->hdrChunk <= 0) {
+				/* LostnFound chunk called Objxxx
+				 * Do a real check
+				 */
+				yaffs_GetObjectName(l, buffer,
+						    YAFFS_MAX_NAME_LENGTH + 1);
+				if (yaffs_strncmp(name, buffer, YAFFS_MAX_NAME_LENGTH) == 0)
+					return l;
+			}
+		}
+	}
+
+	return NULL;
+}
+
+
+#if 0
+int yaffs_ApplyToDirectoryChildren(yaffs_Object *theDir,
+					int (*fn) (yaffs_Object *))
+{
+	struct ylist_head *i;
+	yaffs_Object *l;
+
+	if (!theDir) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_FindObjectByName: null pointer directory"
+		    TENDSTR)));
+		YBUG();
+		return YAFFS_FAIL;
+	}
+	if (theDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("tragedy: yaffs_FindObjectByName: non-directory" TENDSTR)));
+		YBUG();
+		return YAFFS_FAIL;
+	}
+
+	ylist_for_each(i, &theDir->variant.directoryVariant.children) {
+		if (i) {
+			l = ylist_entry(i, yaffs_Object, siblings);
+			if (l && !fn(l))
+				return YAFFS_FAIL;
+		}
+	}
+
+	return YAFFS_OK;
+
+}
+#endif
+
+/* GetEquivalentObject dereferences any hard links to get to the
+ * actual object.
+ */
+
+yaffs_Object *yaffs_GetEquivalentObject(yaffs_Object *obj)
+{
+	if (obj && obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
+		/* We want the object id of the equivalent object, not this one */
+		obj = obj->variant.hardLinkVariant.equivalentObject;
+		yaffs_CheckObjectDetailsLoaded(obj);
+	}
+	return obj;
+}
+
+int yaffs_GetObjectName(yaffs_Object *obj, YCHAR *name, int buffSize)
+{
+	memset(name, 0, buffSize * sizeof(YCHAR));
+
+	yaffs_CheckObjectDetailsLoaded(obj);
+
+	if (obj->objectId == YAFFS_OBJECTID_LOSTNFOUND) {
+		yaffs_strncpy(name, YAFFS_LOSTNFOUND_NAME, buffSize - 1);
+	} else if (obj->hdrChunk <= 0) {
+		YCHAR locName[20];
+		YCHAR numString[20];
+		YCHAR *x = &numString[19];
+		unsigned v = obj->objectId;
+		numString[19] = 0;
+		while (v > 0) {
+			x--;
+			*x = '0' + (v % 10);
+			v /= 10;
+		}
+		/* make up a name */
+		yaffs_strcpy(locName, YAFFS_LOSTNFOUND_PREFIX);
+		yaffs_strcat(locName, x);
+		yaffs_strncpy(name, locName, buffSize - 1);
+
+	}
+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+	else if (obj->shortName[0])
+		yaffs_strcpy(name, obj->shortName);
+#endif
+	else {
+		int result;
+		__u8 *buffer = yaffs_GetTempBuffer(obj->myDev, __LINE__);
+
+		yaffs_ObjectHeader *oh = (yaffs_ObjectHeader *) buffer;
+
+		memset(buffer, 0, obj->myDev->nDataBytesPerChunk);
+
+		if (obj->hdrChunk > 0) {
+			result = yaffs_ReadChunkWithTagsFromNAND(obj->myDev,
+							obj->hdrChunk, buffer,
+							NULL);
+		}
+		yaffs_strncpy(name, oh->name, buffSize - 1);
+
+		yaffs_ReleaseTempBuffer(obj->myDev, buffer, __LINE__);
+	}
+
+	return yaffs_strlen(name);
+}
+
+int yaffs_GetObjectFileLength(yaffs_Object *obj)
+{
+	/* Dereference any hard linking */
+	obj = yaffs_GetEquivalentObject(obj);
+
+	if (obj->variantType == YAFFS_OBJECT_TYPE_FILE)
+		return obj->variant.fileVariant.fileSize;
+	if (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK)
+		return yaffs_strlen(obj->variant.symLinkVariant.alias);
+	else {
+		/* Only a directory should drop through to here */
+		return obj->myDev->nDataBytesPerChunk;
+	}
+}
+
+int yaffs_GetObjectLinkCount(yaffs_Object *obj)
+{
+	int count = 0;
+	struct ylist_head *i;
+
+	if (!obj->unlinked)
+		count++;		/* the object itself */
+
+	ylist_for_each(i, &obj->hardLinks)
+		count++;		/* add the hard links; */
+
+	return count;
+}
+
+int yaffs_GetObjectInode(yaffs_Object *obj)
+{
+	obj = yaffs_GetEquivalentObject(obj);
+
+	return obj->objectId;
+}
+
+unsigned yaffs_GetObjectType(yaffs_Object *obj)
+{
+	obj = yaffs_GetEquivalentObject(obj);
+
+	switch (obj->variantType) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		return DT_REG;
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		return DT_DIR;
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		return DT_LNK;
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		return DT_REG;
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		if (S_ISFIFO(obj->yst_mode))
+			return DT_FIFO;
+		if (S_ISCHR(obj->yst_mode))
+			return DT_CHR;
+		if (S_ISBLK(obj->yst_mode))
+			return DT_BLK;
+		if (S_ISSOCK(obj->yst_mode))
+			return DT_SOCK;
+	default:
+		return DT_REG;
+		break;
+	}
+}
+
+YCHAR *yaffs_GetSymlinkAlias(yaffs_Object *obj)
+{
+	obj = yaffs_GetEquivalentObject(obj);
+	if (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK)
+		return yaffs_CloneString(obj->variant.symLinkVariant.alias);
+	else
+		return yaffs_CloneString(_Y(""));
+}
+
+#ifndef CONFIG_YAFFS_WINCE
+
+int yaffs_SetAttributes(yaffs_Object *obj, struct iattr *attr)
+{
+	unsigned int valid = attr->ia_valid;
+
+	if (valid & ATTR_MODE)
+		obj->yst_mode = attr->ia_mode;
+	if (valid & ATTR_UID)
+		obj->yst_uid = attr->ia_uid;
+	if (valid & ATTR_GID)
+		obj->yst_gid = attr->ia_gid;
+
+	if (valid & ATTR_ATIME)
+		obj->yst_atime = Y_TIME_CONVERT(attr->ia_atime);
+	if (valid & ATTR_CTIME)
+		obj->yst_ctime = Y_TIME_CONVERT(attr->ia_ctime);
+	if (valid & ATTR_MTIME)
+		obj->yst_mtime = Y_TIME_CONVERT(attr->ia_mtime);
+
+	if (valid & ATTR_SIZE)
+		yaffs_ResizeFile(obj, attr->ia_size);
+
+	yaffs_UpdateObjectHeader(obj, NULL, 1, 0, 0);
+
+	return YAFFS_OK;
+
+}
+int yaffs_GetAttributes(yaffs_Object *obj, struct iattr *attr)
+{
+	unsigned int valid = 0;
+
+	attr->ia_mode = obj->yst_mode;
+	valid |= ATTR_MODE;
+	attr->ia_uid = obj->yst_uid;
+	valid |= ATTR_UID;
+	attr->ia_gid = obj->yst_gid;
+	valid |= ATTR_GID;
+
+	Y_TIME_CONVERT(attr->ia_atime) = obj->yst_atime;
+	valid |= ATTR_ATIME;
+	Y_TIME_CONVERT(attr->ia_ctime) = obj->yst_ctime;
+	valid |= ATTR_CTIME;
+	Y_TIME_CONVERT(attr->ia_mtime) = obj->yst_mtime;
+	valid |= ATTR_MTIME;
+
+	attr->ia_size = yaffs_GetFileSize(obj);
+	valid |= ATTR_SIZE;
+
+	attr->ia_valid = valid;
+
+	return YAFFS_OK;
+}
+
+#endif
+
+#if 0
+int yaffs_DumpObject(yaffs_Object *obj)
+{
+	YCHAR name[257];
+
+	yaffs_GetObjectName(obj, name, YAFFS_MAX_NAME_LENGTH + 1);
+
+	T(YAFFS_TRACE_ALWAYS,
+	  (TSTR
+	   ("Object %d, inode %d \"%s\"\n dirty %d valid %d serial %d sum %d"
+	    " chunk %d type %d size %d\n"
+	    TENDSTR), obj->objectId, yaffs_GetObjectInode(obj), name,
+	   obj->dirty, obj->valid, obj->serial, obj->sum, obj->hdrChunk,
+	   yaffs_GetObjectType(obj), yaffs_GetObjectFileLength(obj)));
+
+	return YAFFS_OK;
+}
+#endif
+
+/*---------------------------- Initialisation code -------------------------------------- */
+
+static int yaffs_CheckDevFunctions(const yaffs_Device *dev)
+{
+
+	/* Common functions, gotta have */
+	if (!dev->eraseBlockInNAND || !dev->initialiseNAND)
+		return 0;
+
+#ifdef CONFIG_YAFFS_YAFFS2
+
+	/* Can use the "with tags" style interface for yaffs1 or yaffs2 */
+	if (dev->writeChunkWithTagsToNAND &&
+	    dev->readChunkWithTagsFromNAND &&
+	    !dev->writeChunkToNAND &&
+	    !dev->readChunkFromNAND &&
+	    dev->markNANDBlockBad && dev->queryNANDBlock)
+		return 1;
+#endif
+
+	/* Can use the "spare" style interface for yaffs1 */
+	if (!dev->isYaffs2 &&
+	    !dev->writeChunkWithTagsToNAND &&
+	    !dev->readChunkWithTagsFromNAND &&
+	    dev->writeChunkToNAND &&
+	    dev->readChunkFromNAND &&
+	    !dev->markNANDBlockBad && !dev->queryNANDBlock)
+		return 1;
+
+	return 0;		/* bad */
+}
+
+
+static int yaffs_CreateInitialDirectories(yaffs_Device *dev)
+{
+	/* Initialise the unlinked, deleted, root and lost and found directories */
+
+	dev->lostNFoundDir = dev->rootDir =  NULL;
+	dev->unlinkedDir = dev->deletedDir = NULL;
+
+	dev->unlinkedDir =
+	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);
+
+	dev->deletedDir =
+	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);
+
+	dev->rootDir =
+	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_ROOT,
+				      YAFFS_ROOT_MODE | S_IFDIR);
+	dev->lostNFoundDir =
+	    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_LOSTNFOUND,
+				      YAFFS_LOSTNFOUND_MODE | S_IFDIR);
+
+	if (dev->lostNFoundDir && dev->rootDir && dev->unlinkedDir && dev->deletedDir) {
+		yaffs_AddObjectToDirectory(dev->rootDir, dev->lostNFoundDir);
+		return YAFFS_OK;
+	}
+
+	return YAFFS_FAIL;
+}
+
+int yaffs_GutsInitialise(yaffs_Device *dev)
+{
+	int init_failed = 0;
+	unsigned x;
+	int bits;
+
+	T(YAFFS_TRACE_TRACING, (TSTR("yaffs: yaffs_GutsInitialise()" TENDSTR)));
+
+	/* Check stuff that must be set */
+
+	if (!dev) {
+		T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Need a device" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	dev->internalStartBlock = dev->startBlock;
+	dev->internalEndBlock = dev->endBlock;
+	dev->blockOffset = 0;
+	dev->chunkOffset = 0;
+	dev->nFreeChunks = 0;
+
+	dev->gcBlock = -1;
+
+	if (dev->startBlock == 0) {
+		dev->internalStartBlock = dev->startBlock + 1;
+		dev->internalEndBlock = dev->endBlock + 1;
+		dev->blockOffset = 1;
+		dev->chunkOffset = dev->nChunksPerBlock;
+	}
+
+	/* Check geometry parameters. */
+
+	if ((!dev->inbandTags && dev->isYaffs2 && dev->totalBytesPerChunk < 1024) ||
+	    (!dev->isYaffs2 && dev->totalBytesPerChunk < 512) ||
+	    (dev->inbandTags && !dev->isYaffs2) ||
+	     dev->nChunksPerBlock < 2 ||
+	     dev->nReservedBlocks < 2 ||
+	     dev->internalStartBlock <= 0 ||
+	     dev->internalEndBlock <= 0 ||
+	     dev->internalEndBlock <= (dev->internalStartBlock + dev->nReservedBlocks + 2)) {	/* otherwise it is too small */
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("yaffs: NAND geometry problems: chunk size %d, type is yaffs%s, inbandTags %d "
+		    TENDSTR), dev->totalBytesPerChunk, dev->isYaffs2 ? "2" : "", dev->inbandTags));
+		return YAFFS_FAIL;
+	}
+
+	if (yaffs_InitialiseNAND(dev) != YAFFS_OK) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("yaffs: InitialiseNAND failed" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	/* Sort out space for inband tags, if required */
+	if (dev->inbandTags)
+		dev->nDataBytesPerChunk = dev->totalBytesPerChunk - sizeof(yaffs_PackedTags2TagsPart);
+	else
+		dev->nDataBytesPerChunk = dev->totalBytesPerChunk;
+
+	/* Got the right mix of functions? */
+	if (!yaffs_CheckDevFunctions(dev)) {
+		/* Function missing */
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR
+		   ("yaffs: device function(s) missing or wrong\n" TENDSTR)));
+
+		return YAFFS_FAIL;
+	}
+
+	/* This is really a compilation check. */
+	if (!yaffs_CheckStructures()) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("yaffs_CheckStructures failed\n" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	if (dev->isMounted) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("yaffs: device already mounted\n" TENDSTR)));
+		return YAFFS_FAIL;
+	}
+
+	/* Finished with most checks. One or two more checks happen later on too. */
+
+	dev->isMounted = 1;
+
+	/* OK now calculate a few things for the device */
+
+	/*
+	 *  Calculate all the chunk size manipulation numbers:
+	 */
+	x = dev->nDataBytesPerChunk;
+	/* We always use dev->chunkShift and dev->chunkDiv */
+	dev->chunkShift = Shifts(x);
+	x >>= dev->chunkShift;
+	dev->chunkDiv = x;
+	/* We only use chunk mask if chunkDiv is 1 */
+	dev->chunkMask = (1<<dev->chunkShift) - 1;
+
+	/*
+	 * Calculate chunkGroupBits.
+	 * We need to find the next power of 2 > than internalEndBlock
+	 */
+
+	x = dev->nChunksPerBlock * (dev->internalEndBlock + 1);
+
+	bits = ShiftsGE(x);
+
+	/* Set up tnode width if wide tnodes are enabled. */
+	if (!dev->wideTnodesDisabled) {
+		/* bits must be even so that we end up with 32-bit words */
+		if (bits & 1)
+			bits++;
+		if (bits < 16)
+			dev->tnodeWidth = 16;
+		else
+			dev->tnodeWidth = bits;
+	} else
+		dev->tnodeWidth = 16;
+
+	dev->tnodeMask = (1<<dev->tnodeWidth)-1;
+
+	/* Level0 Tnodes are 16 bits or wider (if wide tnodes are enabled),
+	 * so if the bitwidth of the
+	 * chunk range we're using is greater than 16 we need
+	 * to figure out chunk shift and chunkGroupSize
+	 */
+
+	if (bits <= dev->tnodeWidth)
+		dev->chunkGroupBits = 0;
+	else
+		dev->chunkGroupBits = bits - dev->tnodeWidth;
+
+
+	dev->chunkGroupSize = 1 << dev->chunkGroupBits;
+
+	if (dev->nChunksPerBlock < dev->chunkGroupSize) {
+		/* We have a problem because the soft delete won't work if
+		 * the chunk group size > chunks per block.
+		 * This can be remedied by using larger "virtual blocks".
+		 */
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("yaffs: chunk group too large\n" TENDSTR)));
+
+		return YAFFS_FAIL;
+	}
+
+	/* OK, we've finished verifying the device, lets continue with initialisation */
+
+	/* More device initialisation */
+	dev->garbageCollections = 0;
+	dev->passiveGarbageCollections = 0;
+	dev->currentDirtyChecker = 0;
+	dev->bufferedBlock = -1;
+	dev->doingBufferedBlockRewrite = 0;
+	dev->nDeletedFiles = 0;
+	dev->nBackgroundDeletions = 0;
+	dev->nUnlinkedFiles = 0;
+	dev->eccFixed = 0;
+	dev->eccUnfixed = 0;
+	dev->tagsEccFixed = 0;
+	dev->tagsEccUnfixed = 0;
+	dev->nErasureFailures = 0;
+	dev->nErasedBlocks = 0;
+	dev->isDoingGC = 0;
+	dev->hasPendingPrioritisedGCs = 1; /* Assume the worst for now, will get fixed on first GC */
+
+	/* Initialise temporary buffers and caches. */
+	if (!yaffs_InitialiseTempBuffers(dev))
+		init_failed = 1;
+
+	dev->srCache = NULL;
+	dev->gcCleanupList = NULL;
+
+
+	if (!init_failed &&
+	    dev->nShortOpCaches > 0) {
+		int i;
+		void *buf;
+		int srCacheBytes = dev->nShortOpCaches * sizeof(yaffs_ChunkCache);
+
+		if (dev->nShortOpCaches > YAFFS_MAX_SHORT_OP_CACHES)
+			dev->nShortOpCaches = YAFFS_MAX_SHORT_OP_CACHES;
+
+		dev->srCache =  YMALLOC(srCacheBytes);
+
+		buf = (__u8 *) dev->srCache;
+
+		if (dev->srCache)
+			memset(dev->srCache, 0, srCacheBytes);
+
+		for (i = 0; i < dev->nShortOpCaches && buf; i++) {
+			dev->srCache[i].object = NULL;
+			dev->srCache[i].lastUse = 0;
+			dev->srCache[i].dirty = 0;
+			dev->srCache[i].data = buf = YMALLOC_DMA(dev->totalBytesPerChunk);
+		}
+		if (!buf)
+			init_failed = 1;
+
+		dev->srLastUse = 0;
+	}
+
+	dev->cacheHits = 0;
+
+	if (!init_failed) {
+		dev->gcCleanupList = YMALLOC(dev->nChunksPerBlock * sizeof(__u32));
+		if (!dev->gcCleanupList)
+			init_failed = 1;
+	}
+
+	if (dev->isYaffs2)
+		dev->useHeaderFileSize = 1;
+
+	if (!init_failed && !yaffs_InitialiseBlocks(dev))
+		init_failed = 1;
+
+	yaffs_InitialiseTnodes(dev);
+	yaffs_InitialiseObjects(dev);
+
+	if (!init_failed && !yaffs_CreateInitialDirectories(dev))
+		init_failed = 1;
+
+
+	if (!init_failed) {
+		/* Now scan the flash. */
+		if (dev->isYaffs2) {
+			if (yaffs_CheckpointRestore(dev)) {
+				yaffs_CheckObjectDetailsLoaded(dev->rootDir);
+				T(YAFFS_TRACE_ALWAYS,
+				  (TSTR("yaffs: restored from checkpoint" TENDSTR)));
+			} else {
+
+				/* Clean up the mess caused by an aborted checkpoint load
+				 * and scan backwards.
+				 */
+				yaffs_DeinitialiseBlocks(dev);
+				yaffs_DeinitialiseTnodes(dev);
+				yaffs_DeinitialiseObjects(dev);
+
+
+				dev->nErasedBlocks = 0;
+				dev->nFreeChunks = 0;
+				dev->allocationBlock = -1;
+				dev->allocationPage = -1;
+				dev->nDeletedFiles = 0;
+				dev->nUnlinkedFiles = 0;
+				dev->nBackgroundDeletions = 0;
+				dev->oldestDirtySequence = 0;
+
+				if (!init_failed && !yaffs_InitialiseBlocks(dev))
+					init_failed = 1;
+
+				yaffs_InitialiseTnodes(dev);
+				yaffs_InitialiseObjects(dev);
+
+				if (!init_failed && !yaffs_CreateInitialDirectories(dev))
+					init_failed = 1;
+
+				if (!init_failed && !yaffs_ScanBackwards(dev))
+					init_failed = 1;
+			}
+		} else if (!yaffs_Scan(dev))
+				init_failed = 1;
+
+		yaffs_StripDeletedObjects(dev);
+		yaffs_FixHangingObjects(dev);
+		if(dev->emptyLostAndFound)
+			yaffs_EmptyLostAndFound(dev);
+	}
+
+	if (init_failed) {
+		/* Clean up the mess */
+		T(YAFFS_TRACE_TRACING,
+		  (TSTR("yaffs: yaffs_GutsInitialise() aborted.\n" TENDSTR)));
+
+		yaffs_Deinitialise(dev);
+		return YAFFS_FAIL;
+	}
+
+	/* Zero out stats */
+	dev->nPageReads = 0;
+	dev->nPageWrites = 0;
+	dev->nBlockErasures = 0;
+	dev->nGCCopies = 0;
+	dev->nRetriedWrites = 0;
+
+	dev->nRetiredBlocks = 0;
+
+	yaffs_VerifyFreeChunks(dev);
+	yaffs_VerifyBlocks(dev);
+
+	/* Clean up any aborted checkpoint data */
+	if (!dev->isCheckpointed && dev->blocksInCheckpoint > 0)
+		yaffs_InvalidateCheckpoint(dev);
+
+	T(YAFFS_TRACE_TRACING,
+	  (TSTR("yaffs: yaffs_GutsInitialise() done.\n" TENDSTR)));
+	return YAFFS_OK;
+
+}
+
+void yaffs_Deinitialise(yaffs_Device *dev)
+{
+	if (dev->isMounted) {
+		int i;
+
+		yaffs_DeinitialiseBlocks(dev);
+		yaffs_DeinitialiseTnodes(dev);
+		yaffs_DeinitialiseObjects(dev);
+		if (dev->nShortOpCaches > 0 &&
+		    dev->srCache) {
+
+			for (i = 0; i < dev->nShortOpCaches; i++) {
+				if (dev->srCache[i].data)
+					YFREE(dev->srCache[i].data);
+				dev->srCache[i].data = NULL;
+			}
+
+			YFREE(dev->srCache);
+			dev->srCache = NULL;
+		}
+
+		YFREE(dev->gcCleanupList);
+
+		for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++)
+			YFREE(dev->tempBuffer[i].buffer);
+
+		dev->isMounted = 0;
+
+		if (dev->deinitialiseNAND)
+			dev->deinitialiseNAND(dev);
+	}
+}
+
+static int yaffs_CountFreeChunks(yaffs_Device *dev)
+{
+	int nFree;
+	int b;
+
+	yaffs_BlockInfo *blk;
+
+	for (nFree = 0, b = dev->internalStartBlock; b <= dev->internalEndBlock;
+			b++) {
+		blk = yaffs_GetBlockInfo(dev, b);
+
+		switch (blk->blockState) {
+		case YAFFS_BLOCK_STATE_EMPTY:
+		case YAFFS_BLOCK_STATE_ALLOCATING:
+		case YAFFS_BLOCK_STATE_COLLECTING:
+		case YAFFS_BLOCK_STATE_FULL:
+			nFree +=
+			    (dev->nChunksPerBlock - blk->pagesInUse +
+			     blk->softDeletions);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return nFree;
+}
+
+int yaffs_GetNumberOfFreeChunks(yaffs_Device *dev)
+{
+	/* This is what we report to the outside world */
+
+	int nFree;
+	int nDirtyCacheChunks;
+	int blocksForCheckpoint;
+	int i;
+
+#if 1
+	nFree = dev->nFreeChunks;
+#else
+	nFree = yaffs_CountFreeChunks(dev);
+#endif
+
+	nFree += dev->nDeletedFiles;
+
+	/* Now count the number of dirty chunks in the cache and subtract those */
+
+	for (nDirtyCacheChunks = 0, i = 0; i < dev->nShortOpCaches; i++) {
+		if (dev->srCache[i].dirty)
+			nDirtyCacheChunks++;
+	}
+
+	nFree -= nDirtyCacheChunks;
+
+	nFree -= ((dev->nReservedBlocks + 1) * dev->nChunksPerBlock);
+
+	/* Now we figure out how much to reserve for the checkpoint and report that... */
+	blocksForCheckpoint = yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;
+	if (blocksForCheckpoint < 0)
+		blocksForCheckpoint = 0;
+
+	nFree -= (blocksForCheckpoint * dev->nChunksPerBlock);
+
+	if (nFree < 0)
+		nFree = 0;
+
+	return nFree;
+
+}
+
+static int yaffs_freeVerificationFailures;
+
+static void yaffs_VerifyFreeChunks(yaffs_Device *dev)
+{
+	int counted;
+	int difference;
+
+	if (yaffs_SkipVerification(dev))
+		return;
+
+	counted = yaffs_CountFreeChunks(dev);
+
+	difference = dev->nFreeChunks - counted;
+
+	if (difference) {
+		T(YAFFS_TRACE_ALWAYS,
+		  (TSTR("Freechunks verification failure %d %d %d" TENDSTR),
+		   dev->nFreeChunks, counted, difference));
+		yaffs_freeVerificationFailures++;
+	}
+}
+
+/*---------------------------------------- YAFFS test code ----------------------*/
+
+#define yaffs_CheckStruct(structure, syze, name) \
+	do { \
+		if (sizeof(structure) != syze) { \
+			T(YAFFS_TRACE_ALWAYS, (TSTR("%s should be %d but is %d\n" TENDSTR),\
+				name, syze, sizeof(structure))); \
+			return YAFFS_FAIL; \
+		} \
+	} while (0)
+
+static int yaffs_CheckStructures(void)
+{
+/*      yaffs_CheckStruct(yaffs_Tags,8,"yaffs_Tags"); */
+/*      yaffs_CheckStruct(yaffs_TagsUnion,8,"yaffs_TagsUnion"); */
+/*      yaffs_CheckStruct(yaffs_Spare,16,"yaffs_Spare"); */
+#ifndef CONFIG_YAFFS_TNODE_LIST_DEBUG
+	yaffs_CheckStruct(yaffs_Tnode, 2 * YAFFS_NTNODES_LEVEL0, "yaffs_Tnode");
+#endif
+#ifndef CONFIG_YAFFS_WINCE
+	yaffs_CheckStruct(yaffs_ObjectHeader, 512, "yaffs_ObjectHeader");
+#endif
+	return YAFFS_OK;
+}
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_guts.h linux-2.6.29-spica/fs/yaffs2/yaffs_guts.h
--- linux-2.6.29/fs/yaffs2/yaffs_guts.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_guts.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,912 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_GUTS_H__
+#define __YAFFS_GUTS_H__
+
+#include "devextras.h"
+#include "yportenv.h"
+
+#define YAFFS_OK	1
+#define YAFFS_FAIL  0
+
+/* Give us a  Y=0x59,
+ * Give us an A=0x41,
+ * Give us an FF=0xFF
+ * Give us an S=0x53
+ * And what have we got...
+ */
+#define YAFFS_MAGIC			0x5941FF53
+
+#define YAFFS_NTNODES_LEVEL0	  	16
+#define YAFFS_TNODES_LEVEL0_BITS	4
+#define YAFFS_TNODES_LEVEL0_MASK	0xf
+
+#define YAFFS_NTNODES_INTERNAL 		(YAFFS_NTNODES_LEVEL0 / 2)
+#define YAFFS_TNODES_INTERNAL_BITS 	(YAFFS_TNODES_LEVEL0_BITS - 1)
+#define YAFFS_TNODES_INTERNAL_MASK	0x7
+#define YAFFS_TNODES_MAX_LEVEL		6
+
+#ifndef CONFIG_YAFFS_NO_YAFFS1
+#define YAFFS_BYTES_PER_SPARE		16
+#define YAFFS_BYTES_PER_CHUNK		512
+#define YAFFS_CHUNK_SIZE_SHIFT		9
+#define YAFFS_CHUNKS_PER_BLOCK		32
+#define YAFFS_BYTES_PER_BLOCK		(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)
+#endif
+
+#define YAFFS_MIN_YAFFS2_CHUNK_SIZE 	1024
+#define YAFFS_MIN_YAFFS2_SPARE_SIZE	32
+
+#define YAFFS_MAX_CHUNK_ID		0x000FFFFF
+
+#define YAFFS_UNUSED_OBJECT_ID		0x0003FFFF
+
+#define YAFFS_ALLOCATION_NOBJECTS	100
+#define YAFFS_ALLOCATION_NTNODES	100
+#define YAFFS_ALLOCATION_NLINKS		100
+
+#define YAFFS_NOBJECT_BUCKETS		256
+
+
+#define YAFFS_OBJECT_SPACE		0x40000
+
+#define YAFFS_CHECKPOINT_VERSION 	3
+
+#ifdef CONFIG_YAFFS_UNICODE
+#define YAFFS_MAX_NAME_LENGTH		127
+#define YAFFS_MAX_ALIAS_LENGTH		79
+#else
+#define YAFFS_MAX_NAME_LENGTH		255
+#define YAFFS_MAX_ALIAS_LENGTH		159
+#endif
+
+#define YAFFS_SHORT_NAME_LENGTH		15
+
+/* Some special object ids for pseudo objects */
+#define YAFFS_OBJECTID_ROOT		1
+#define YAFFS_OBJECTID_LOSTNFOUND	2
+#define YAFFS_OBJECTID_UNLINKED		3
+#define YAFFS_OBJECTID_DELETED		4
+
+/* Sseudo object ids for checkpointing */
+#define YAFFS_OBJECTID_SB_HEADER	0x10
+#define YAFFS_OBJECTID_CHECKPOINT_DATA	0x20
+#define YAFFS_SEQUENCE_CHECKPOINT_DATA  0x21
+
+/* */
+
+#define YAFFS_MAX_SHORT_OP_CACHES	20
+
+#define YAFFS_N_TEMP_BUFFERS		6
+
+/* We limit the number attempts at sucessfully saving a chunk of data.
+ * Small-page devices have 32 pages per block; large-page devices have 64.
+ * Default to something in the order of 5 to 10 blocks worth of chunks.
+ */
+#define YAFFS_WR_ATTEMPTS		(5*64)
+
+/* Sequence numbers are used in YAFFS2 to determine block allocation order.
+ * The range is limited slightly to help distinguish bad numbers from good.
+ * This also allows us to perhaps in the future use special numbers for
+ * special purposes.
+ * EFFFFF00 allows the allocation of 8 blocks per second (~1Mbytes) for 15 years,
+ * and is a larger number than the lifetime of a 2GB device.
+ */
+#define YAFFS_LOWEST_SEQUENCE_NUMBER	0x00001000
+#define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xEFFFFF00
+
+/* Special sequence number for bad block that failed to be marked bad */
+#define YAFFS_SEQUENCE_BAD_BLOCK	0xFFFF0000
+
+/* ChunkCache is used for short read/write operations.*/
+typedef struct {
+	struct yaffs_ObjectStruct *object;
+	int chunkId;
+	int lastUse;
+	int dirty;
+	int nBytes;		/* Only valid if the cache is dirty */
+	int locked;		/* Can't push out or flush while locked. */
+#ifdef CONFIG_YAFFS_YAFFS2
+	__u8 *data;
+#else
+	__u8 data[YAFFS_BYTES_PER_CHUNK];
+#endif
+} yaffs_ChunkCache;
+
+
+
+/* Tags structures in RAM
+ * NB This uses bitfield. Bitfields should not straddle a u32 boundary otherwise
+ * the structure size will get blown out.
+ */
+
+#ifndef CONFIG_YAFFS_NO_YAFFS1
+typedef struct {
+	unsigned chunkId:20;
+	unsigned serialNumber:2;
+	unsigned byteCountLSB:10;
+	unsigned objectId:18;
+	unsigned ecc:12;
+	unsigned byteCountMSB:2;
+} yaffs_Tags;
+
+typedef union {
+	yaffs_Tags asTags;
+	__u8 asBytes[8];
+} yaffs_TagsUnion;
+
+#endif
+
+/* Stuff used for extended tags in YAFFS2 */
+
+typedef enum {
+	YAFFS_ECC_RESULT_UNKNOWN,
+	YAFFS_ECC_RESULT_NO_ERROR,
+	YAFFS_ECC_RESULT_FIXED,
+	YAFFS_ECC_RESULT_UNFIXED
+} yaffs_ECCResult;
+
+typedef enum {
+	YAFFS_OBJECT_TYPE_UNKNOWN,
+	YAFFS_OBJECT_TYPE_FILE,
+	YAFFS_OBJECT_TYPE_SYMLINK,
+	YAFFS_OBJECT_TYPE_DIRECTORY,
+	YAFFS_OBJECT_TYPE_HARDLINK,
+	YAFFS_OBJECT_TYPE_SPECIAL
+} yaffs_ObjectType;
+
+#define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL
+
+typedef struct {
+
+	unsigned validMarker0;
+	unsigned chunkUsed;	/*  Status of the chunk: used or unused */
+	unsigned objectId;	/* If 0 then this is not part of an object (unused) */
+	unsigned chunkId;	/* If 0 then this is a header, else a data chunk */
+	unsigned byteCount;	/* Only valid for data chunks */
+
+	/* The following stuff only has meaning when we read */
+	yaffs_ECCResult eccResult;
+	unsigned blockBad;
+
+	/* YAFFS 1 stuff */
+	unsigned chunkDeleted;	/* The chunk is marked deleted */
+	unsigned serialNumber;	/* Yaffs1 2-bit serial number */
+
+	/* YAFFS2 stuff */
+	unsigned sequenceNumber;	/* The sequence number of this block */
+
+	/* Extra info if this is an object header (YAFFS2 only) */
+
+	unsigned extraHeaderInfoAvailable;	/* There is extra info available if this is not zero */
+	unsigned extraParentObjectId;	/* The parent object */
+	unsigned extraIsShrinkHeader;	/* Is it a shrink header? */
+	unsigned extraShadows;		/* Does this shadow another object? */
+
+	yaffs_ObjectType extraObjectType;	/* What object type? */
+
+	unsigned extraFileLength;		/* Length if it is a file */
+	unsigned extraEquivalentObjectId;	/* Equivalent object Id if it is a hard link */
+
+	unsigned validMarker1;
+
+} yaffs_ExtendedTags;
+
+/* Spare structure for YAFFS1 */
+typedef struct {
+	__u8 tagByte0;
+	__u8 tagByte1;
+	__u8 tagByte2;
+	__u8 tagByte3;
+	__u8 pageStatus;	/* set to 0 to delete the chunk */
+	__u8 blockStatus;
+	__u8 tagByte4;
+	__u8 tagByte5;
+	__u8 ecc1[3];
+	__u8 tagByte6;
+	__u8 tagByte7;
+	__u8 ecc2[3];
+} yaffs_Spare;
+
+/*Special structure for passing through to mtd */
+struct yaffs_NANDSpare {
+	yaffs_Spare spare;
+	int eccres1;
+	int eccres2;
+};
+
+/* Block data in RAM */
+
+typedef enum {
+	YAFFS_BLOCK_STATE_UNKNOWN = 0,
+
+	YAFFS_BLOCK_STATE_SCANNING,
+	YAFFS_BLOCK_STATE_NEEDS_SCANNING,
+	/* The block might have something on it (ie it is allocating or full, perhaps empty)
+	 * but it needs to be scanned to determine its true state.
+	 * This state is only valid during yaffs_Scan.
+	 * NB We tolerate empty because the pre-scanner might be incapable of deciding
+	 * However, if this state is returned on a YAFFS2 device, then we expect a sequence number
+	 */
+
+	YAFFS_BLOCK_STATE_EMPTY,
+	/* This block is empty */
+
+	YAFFS_BLOCK_STATE_ALLOCATING,
+	/* This block is partially allocated.
+	 * At least one page holds valid data.
+	 * This is the one currently being used for page
+	 * allocation. Should never be more than one of these
+	 */
+
+	YAFFS_BLOCK_STATE_FULL,
+	/* All the pages in this block have been allocated.
+	 */
+
+	YAFFS_BLOCK_STATE_DIRTY,
+	/* All pages have been allocated and deleted.
+	 * Erase me, reuse me.
+	 */
+
+	YAFFS_BLOCK_STATE_CHECKPOINT,
+	/* This block is assigned to holding checkpoint data.
+	 */
+
+	YAFFS_BLOCK_STATE_COLLECTING,
+	/* This block is being garbage collected */
+
+	YAFFS_BLOCK_STATE_DEAD
+	/* This block has failed and is not in use */
+} yaffs_BlockState;
+
+#define	YAFFS_NUMBER_OF_BLOCK_STATES (YAFFS_BLOCK_STATE_DEAD + 1)
+
+
+typedef struct {
+
+	int softDeletions:10;	/* number of soft deleted pages */
+	int pagesInUse:10;	/* number of pages in use */
+	unsigned blockState:4;	/* One of the above block states. NB use unsigned because enum is sometimes an int */
+	__u32 needsRetiring:1;	/* Data has failed on this block, need to get valid data off */
+				/* and retire the block. */
+	__u32 skipErasedCheck:1; /* If this is set we can skip the erased check on this block */
+	__u32 gcPrioritise:1; 	/* An ECC check or blank check has failed on this block.
+				   It should be prioritised for GC */
+	__u32 chunkErrorStrikes:3; /* How many times we've had ecc etc failures on this block and tried to reuse it */
+
+#ifdef CONFIG_YAFFS_YAFFS2
+	__u32 hasShrinkHeader:1; /* This block has at least one shrink object header */
+	__u32 sequenceNumber;	 /* block sequence number for yaffs2 */
+#endif
+
+} yaffs_BlockInfo;
+
+/* -------------------------- Object structure -------------------------------*/
+/* This is the object structure as stored on NAND */
+
+typedef struct {
+	yaffs_ObjectType type;
+
+	/* Apply to everything  */
+	int parentObjectId;
+	__u16 sum__NoLongerUsed;        /* checksum of name. No longer used */
+	YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	/* The following apply to directories, files, symlinks - not hard links */
+	__u32 yst_mode;         /* protection */
+
+#ifdef CONFIG_YAFFS_WINCE
+	__u32 notForWinCE[5];
+#else
+	__u32 yst_uid;
+	__u32 yst_gid;
+	__u32 yst_atime;
+	__u32 yst_mtime;
+	__u32 yst_ctime;
+#endif
+
+	/* File size  applies to files only */
+	int fileSize;
+
+	/* Equivalent object id applies to hard links only. */
+	int equivalentObjectId;
+
+	/* Alias is for symlinks only. */
+	YCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];
+
+	__u32 yst_rdev;		/* device stuff for block and char devices (major/min) */
+
+#ifdef CONFIG_YAFFS_WINCE
+	__u32 win_ctime[2];
+	__u32 win_atime[2];
+	__u32 win_mtime[2];
+#else
+	__u32 roomToGrow[6];
+
+#endif
+	__u32 inbandShadowsObject;
+	__u32 inbandIsShrink;
+
+	__u32 reservedSpace[2];
+	int shadowsObject;	/* This object header shadows the specified object if > 0 */
+
+	/* isShrink applies to object headers written when we shrink the file (ie resize) */
+	__u32 isShrink;
+
+} yaffs_ObjectHeader;
+
+/*--------------------------- Tnode -------------------------- */
+
+union yaffs_Tnode_union {
+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG
+	union yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL + 1];
+#else
+	union yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL];
+#endif
+/*	__u16 level0[YAFFS_NTNODES_LEVEL0]; */
+
+};
+
+typedef union yaffs_Tnode_union yaffs_Tnode;
+
+struct yaffs_TnodeList_struct {
+	struct yaffs_TnodeList_struct *next;
+	yaffs_Tnode *tnodes;
+};
+
+typedef struct yaffs_TnodeList_struct yaffs_TnodeList;
+
+/*------------------------  Object -----------------------------*/
+/* An object can be one of:
+ * - a directory (no data, has children links
+ * - a regular file (data.... not prunes :->).
+ * - a symlink [symbolic link] (the alias).
+ * - a hard link
+ */
+
+typedef struct {
+	__u32 fileSize;
+	__u32 scannedFileSize;
+	__u32 shrinkSize;
+	int topLevel;
+	yaffs_Tnode *top;
+} yaffs_FileStructure;
+
+typedef struct {
+	struct ylist_head children;     /* list of child links */
+} yaffs_DirectoryStructure;
+
+typedef struct {
+	YCHAR *alias;
+} yaffs_SymLinkStructure;
+
+typedef struct {
+	struct yaffs_ObjectStruct *equivalentObject;
+	__u32 equivalentObjectId;
+} yaffs_HardLinkStructure;
+
+typedef union {
+	yaffs_FileStructure fileVariant;
+	yaffs_DirectoryStructure directoryVariant;
+	yaffs_SymLinkStructure symLinkVariant;
+	yaffs_HardLinkStructure hardLinkVariant;
+} yaffs_ObjectVariant;
+
+struct yaffs_ObjectStruct {
+	__u8 deleted:1;		/* This should only apply to unlinked files. */
+	__u8 softDeleted:1;	/* it has also been soft deleted */
+	__u8 unlinked:1;	/* An unlinked file. The file should be in the unlinked directory.*/
+	__u8 fake:1;		/* A fake object has no presence on NAND. */
+	__u8 renameAllowed:1;	/* Some objects are not allowed to be renamed. */
+	__u8 unlinkAllowed:1;
+	__u8 dirty:1;		/* the object needs to be written to flash */
+	__u8 valid:1;		/* When the file system is being loaded up, this
+				 * object might be created before the data
+				 * is available (ie. file data records appear before the header).
+				 */
+	__u8 lazyLoaded:1;	/* This object has been lazy loaded and is missing some detail */
+
+	__u8 deferedFree:1;	/* For Linux kernel. Object is removed from NAND, but is
+				 * still in the inode cache. Free of object is defered.
+				 * until the inode is released.
+				 */
+	__u8 beingCreated:1;	/* This object is still being created so skip some checks. */
+	__u8 isShadowed:1;      /* This object is shadowed on the way to being renamed. */
+
+	__u8 serial;		/* serial number of chunk in NAND. Cached here */
+	__u16 sum;		/* sum of the name to speed searching */
+
+	struct yaffs_DeviceStruct *myDev;       /* The device I'm on */
+
+	struct ylist_head hashLink;     /* list of objects in this hash bucket */
+
+	struct ylist_head hardLinks;    /* all the equivalent hard linked objects */
+
+	/* directory structure stuff */
+	/* also used for linking up the free list */
+	struct yaffs_ObjectStruct *parent;
+	struct ylist_head siblings;
+
+	/* Where's my object header in NAND? */
+	int hdrChunk;
+
+	int nDataChunks;	/* Number of data chunks attached to the file. */
+
+	__u32 objectId;		/* the object id value */
+
+	__u32 yst_mode;
+
+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+	YCHAR shortName[YAFFS_SHORT_NAME_LENGTH + 1];
+#endif
+
+#ifndef __KERNEL__
+	__u32 inUse;
+#endif
+
+#ifdef CONFIG_YAFFS_WINCE
+	__u32 win_ctime[2];
+	__u32 win_mtime[2];
+	__u32 win_atime[2];
+#else
+	__u32 yst_uid;
+	__u32 yst_gid;
+	__u32 yst_atime;
+	__u32 yst_mtime;
+	__u32 yst_ctime;
+#endif
+
+	__u32 yst_rdev;
+
+#ifdef __KERNEL__
+	struct inode *myInode;
+
+#endif
+
+	yaffs_ObjectType variantType;
+
+	yaffs_ObjectVariant variant;
+
+};
+
+typedef struct yaffs_ObjectStruct yaffs_Object;
+
+struct yaffs_ObjectList_struct {
+	yaffs_Object *objects;
+	struct yaffs_ObjectList_struct *next;
+};
+
+typedef struct yaffs_ObjectList_struct yaffs_ObjectList;
+
+typedef struct {
+	struct ylist_head list;
+	int count;
+} yaffs_ObjectBucket;
+
+
+/* yaffs_CheckpointObject holds the definition of an object as dumped
+ * by checkpointing.
+ */
+
+typedef struct {
+	int structType;
+	__u32 objectId;
+	__u32 parentId;
+	int hdrChunk;
+	yaffs_ObjectType variantType:3;
+	__u8 deleted:1;
+	__u8 softDeleted:1;
+	__u8 unlinked:1;
+	__u8 fake:1;
+	__u8 renameAllowed:1;
+	__u8 unlinkAllowed:1;
+	__u8 serial;
+
+	int nDataChunks;
+	__u32 fileSizeOrEquivalentObjectId;
+} yaffs_CheckpointObject;
+
+/*--------------------- Temporary buffers ----------------
+ *
+ * These are chunk-sized working buffers. Each device has a few
+ */
+
+typedef struct {
+	__u8 *buffer;
+	int line;	/* track from whence this buffer was allocated */
+	int maxLine;
+} yaffs_TempBuffer;
+
+/*----------------- Device ---------------------------------*/
+
+struct yaffs_DeviceStruct {
+	struct ylist_head devList;
+	const char *name;
+
+	/* Entry parameters set up way early. Yaffs sets up the rest.*/
+	int nDataBytesPerChunk;	/* Should be a power of 2 >= 512 */
+	int nChunksPerBlock;	/* does not need to be a power of 2 */
+	int spareBytesPerChunk;	/* spare area size */
+	int startBlock;		/* Start block we're allowed to use */
+	int endBlock;		/* End block we're allowed to use */
+	int nReservedBlocks;	/* We want this tuneable so that we can reduce */
+				/* reserved blocks on NOR and RAM. */
+
+
+	/* Stuff used by the shared space checkpointing mechanism */
+	/* If this value is zero, then this mechanism is disabled */
+
+/*	int nCheckpointReservedBlocks; */ /* Blocks to reserve for checkpoint data */
+
+
+	int nShortOpCaches;	/* If <= 0, then short op caching is disabled, else
+				 * the number of short op caches (don't use too many)
+				 */
+
+	int useHeaderFileSize;	/* Flag to determine if we should use file sizes from the header */
+
+	int emptyLostAndFound;  /* Flasg to determine if lst+found should be emptied on init */
+
+	int useNANDECC;		/* Flag to decide whether or not to use NANDECC */
+
+	void *genericDevice;	/* Pointer to device context
+				 * On an mtd this holds the mtd pointer.
+				 */
+	void *superBlock;
+
+	/* NAND access functions (Must be set before calling YAFFS)*/
+
+	int (*writeChunkToNAND) (struct yaffs_DeviceStruct *dev,
+					int chunkInNAND, const __u8 *data,
+					const yaffs_Spare *spare);
+	int (*readChunkFromNAND) (struct yaffs_DeviceStruct *dev,
+					int chunkInNAND, __u8 *data,
+					yaffs_Spare *spare);
+	int (*eraseBlockInNAND) (struct yaffs_DeviceStruct *dev,
+					int blockInNAND);
+	int (*initialiseNAND) (struct yaffs_DeviceStruct *dev);
+	int (*deinitialiseNAND) (struct yaffs_DeviceStruct *dev);
+
+#ifdef CONFIG_YAFFS_YAFFS2
+	int (*writeChunkWithTagsToNAND) (struct yaffs_DeviceStruct *dev,
+					 int chunkInNAND, const __u8 *data,
+					 const yaffs_ExtendedTags *tags);
+	int (*readChunkWithTagsFromNAND) (struct yaffs_DeviceStruct *dev,
+					  int chunkInNAND, __u8 *data,
+					  yaffs_ExtendedTags *tags);
+	int (*markNANDBlockBad) (struct yaffs_DeviceStruct *dev, int blockNo);
+	int (*queryNANDBlock) (struct yaffs_DeviceStruct *dev, int blockNo,
+			       yaffs_BlockState *state, __u32 *sequenceNumber);
+#endif
+
+	int isYaffs2;
+
+	/* The removeObjectCallback function must be supplied by OS flavours that
+	 * need it.
+         * yaffs direct uses it to implement the faster readdir.
+         * Linux uses it to protect the directory during unlocking.
+	 */
+	void (*removeObjectCallback)(struct yaffs_ObjectStruct *obj);
+
+	/* Callback to mark the superblock dirsty */
+	void (*markSuperBlockDirty)(void *superblock);
+
+	int wideTnodesDisabled; /* Set to disable wide tnodes */
+
+	YCHAR *pathDividers;	/* String of legal path dividers */
+
+
+	/* End of stuff that must be set before initialisation. */
+
+	/* Checkpoint control. Can be set before or after initialisation */
+	__u8 skipCheckpointRead;
+	__u8 skipCheckpointWrite;
+
+	/* Runtime parameters. Set up by YAFFS. */
+
+	__u16 chunkGroupBits;	/* 0 for devices <= 32MB. else log2(nchunks) - 16 */
+	__u16 chunkGroupSize;	/* == 2^^chunkGroupBits */
+
+	/* Stuff to support wide tnodes */
+	__u32 tnodeWidth;
+	__u32 tnodeMask;
+
+	/* Stuff for figuring out file offset to chunk conversions */
+	__u32 chunkShift; /* Shift value */
+	__u32 chunkDiv;   /* Divisor after shifting: 1 for power-of-2 sizes */
+	__u32 chunkMask;  /* Mask to use for power-of-2 case */
+
+	/* Stuff to handle inband tags */
+	int inbandTags;
+	__u32 totalBytesPerChunk;
+
+#ifdef __KERNEL__
+
+	struct semaphore sem;	/* Semaphore for waiting on erasure.*/
+	struct semaphore grossLock;	/* Gross locking semaphore */
+	struct rw_semaphore dirLock; /* Lock the directory structure */
+	__u8 *spareBuffer;	/* For mtdif2 use. Don't know the size of the buffer
+				 * at compile time so we have to allocate it.
+
+				 */
+	void (*putSuperFunc) (struct super_block *sb);
+        struct ylist_head searchContexts;
+
+#endif
+
+	int isMounted;
+
+	int isCheckpointed;
+
+
+	/* Stuff to support block offsetting to support start block zero */
+	int internalStartBlock;
+	int internalEndBlock;
+	int blockOffset;
+	int chunkOffset;
+
+
+	/* Runtime checkpointing stuff */
+	int checkpointPageSequence;   /* running sequence number of checkpoint pages */
+	int checkpointByteCount;
+	int checkpointByteOffset;
+	__u8 *checkpointBuffer;
+	int checkpointOpenForWrite;
+	int blocksInCheckpoint;
+	int checkpointCurrentChunk;
+	int checkpointCurrentBlock;
+	int checkpointNextBlock;
+	int *checkpointBlockList;
+	int checkpointMaxBlocks;
+	__u32 checkpointSum;
+	__u32 checkpointXor;
+
+	int nCheckpointBlocksRequired; /* Number of blocks needed to store current checkpoint set */
+
+	/* Block Info */
+	yaffs_BlockInfo *blockInfo;
+	__u8 *chunkBits;	/* bitmap of chunks in use */
+	unsigned blockInfoAlt:1;	/* was allocated using alternative strategy */
+	unsigned chunkBitsAlt:1;	/* was allocated using alternative strategy */
+	int chunkBitmapStride;	/* Number of bytes of chunkBits per block.
+				 * Must be consistent with nChunksPerBlock.
+				 */
+
+	int nErasedBlocks;
+	int allocationBlock;	/* Current block being allocated off */
+	__u32 allocationPage;
+	int allocationBlockFinder;	/* Used to search for next allocation block */
+
+	/* Runtime state */
+	int nTnodesCreated;
+	yaffs_Tnode *freeTnodes;
+	int nFreeTnodes;
+	yaffs_TnodeList *allocatedTnodeList;
+
+	int isDoingGC;
+	int gcBlock;
+	int gcChunk;
+
+	int nObjectsCreated;
+	yaffs_Object *freeObjects;
+	int nFreeObjects;
+
+	int nHardLinks;
+
+	yaffs_ObjectList *allocatedObjectList;
+
+	yaffs_ObjectBucket objectBucket[YAFFS_NOBJECT_BUCKETS];
+
+	int nFreeChunks;
+
+	int currentDirtyChecker;	/* Used to find current dirtiest block */
+
+	__u32 *gcCleanupList;	/* objects to delete at the end of a GC. */
+	int nonAggressiveSkip;	/* GC state/mode */
+
+	/* Statistcs */
+	int nPageWrites;
+	int nPageReads;
+	int nBlockErasures;
+	int nErasureFailures;
+	int nGCCopies;
+	int garbageCollections;
+	int passiveGarbageCollections;
+	int nRetriedWrites;
+	int nRetiredBlocks;
+	int eccFixed;
+	int eccUnfixed;
+	int tagsEccFixed;
+	int tagsEccUnfixed;
+	int nDeletions;
+	int nUnmarkedDeletions;
+
+	int hasPendingPrioritisedGCs; /* We think this device might have pending prioritised gcs */
+
+	/* Special directories */
+	yaffs_Object *rootDir;
+	yaffs_Object *lostNFoundDir;
+
+	/* Buffer areas for storing data to recover from write failures TODO
+	 *      __u8            bufferedData[YAFFS_CHUNKS_PER_BLOCK][YAFFS_BYTES_PER_CHUNK];
+	 *      yaffs_Spare bufferedSpare[YAFFS_CHUNKS_PER_BLOCK];
+	 */
+
+	int bufferedBlock;	/* Which block is buffered here? */
+	int doingBufferedBlockRewrite;
+
+	yaffs_ChunkCache *srCache;
+	int srLastUse;
+
+	int cacheHits;
+
+	/* Stuff for background deletion and unlinked files.*/
+	yaffs_Object *unlinkedDir;	/* Directory where unlinked and deleted files live. */
+	yaffs_Object *deletedDir;	/* Directory where deleted objects are sent to disappear. */
+	yaffs_Object *unlinkedDeletion;	/* Current file being background deleted.*/
+	int nDeletedFiles;		/* Count of files awaiting deletion;*/
+	int nUnlinkedFiles;		/* Count of unlinked files. */
+	int nBackgroundDeletions;	/* Count of background deletions. */
+
+
+	/* Temporary buffer management */
+	yaffs_TempBuffer tempBuffer[YAFFS_N_TEMP_BUFFERS];
+	int maxTemp;
+	int tempInUse;
+	int unmanagedTempAllocations;
+	int unmanagedTempDeallocations;
+
+	/* yaffs2 runtime stuff */
+	unsigned sequenceNumber;	/* Sequence number of currently allocating block */
+	unsigned oldestDirtySequence;
+
+};
+
+typedef struct yaffs_DeviceStruct yaffs_Device;
+
+/* The static layout of block usage etc is stored in the super block header */
+typedef struct {
+	int StructType;
+	int version;
+	int checkpointStartBlock;
+	int checkpointEndBlock;
+	int startBlock;
+	int endBlock;
+	int rfu[100];
+} yaffs_SuperBlockHeader;
+
+/* The CheckpointDevice structure holds the device information that changes at runtime and
+ * must be preserved over unmount/mount cycles.
+ */
+typedef struct {
+	int structType;
+	int nErasedBlocks;
+	int allocationBlock;	/* Current block being allocated off */
+	__u32 allocationPage;
+	int nFreeChunks;
+
+	int nDeletedFiles;		/* Count of files awaiting deletion;*/
+	int nUnlinkedFiles;		/* Count of unlinked files. */
+	int nBackgroundDeletions;	/* Count of background deletions. */
+
+	/* yaffs2 runtime stuff */
+	unsigned sequenceNumber;	/* Sequence number of currently allocating block */
+	unsigned oldestDirtySequence;
+
+} yaffs_CheckpointDevice;
+
+
+typedef struct {
+	int structType;
+	__u32 magic;
+	__u32 version;
+	__u32 head;
+} yaffs_CheckpointValidity;
+
+
+/*----------------------- YAFFS Functions -----------------------*/
+
+int yaffs_GutsInitialise(yaffs_Device *dev);
+void yaffs_Deinitialise(yaffs_Device *dev);
+
+int yaffs_GetNumberOfFreeChunks(yaffs_Device *dev);
+
+int yaffs_RenameObject(yaffs_Object *oldDir, const YCHAR *oldName,
+		       yaffs_Object *newDir, const YCHAR *newName);
+
+int yaffs_Unlink(yaffs_Object *dir, const YCHAR *name);
+int yaffs_DeleteObject(yaffs_Object *obj);
+
+int yaffs_GetObjectName(yaffs_Object *obj, YCHAR *name, int buffSize);
+int yaffs_GetObjectFileLength(yaffs_Object *obj);
+int yaffs_GetObjectInode(yaffs_Object *obj);
+unsigned yaffs_GetObjectType(yaffs_Object *obj);
+int yaffs_GetObjectLinkCount(yaffs_Object *obj);
+
+int yaffs_SetAttributes(yaffs_Object *obj, struct iattr *attr);
+int yaffs_GetAttributes(yaffs_Object *obj, struct iattr *attr);
+
+/* File operations */
+int yaffs_ReadDataFromFile(yaffs_Object *obj, __u8 *buffer, loff_t offset,
+				int nBytes);
+int yaffs_WriteDataToFile(yaffs_Object *obj, const __u8 *buffer, loff_t offset,
+				int nBytes, int writeThrough);
+int yaffs_ResizeFile(yaffs_Object *obj, loff_t newSize);
+
+yaffs_Object *yaffs_MknodFile(yaffs_Object *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid);
+int yaffs_FlushFile(yaffs_Object *obj, int updateTime);
+
+/* Flushing and checkpointing */
+void yaffs_FlushEntireDeviceCache(yaffs_Device *dev);
+
+int yaffs_CheckpointSave(yaffs_Device *dev);
+int yaffs_CheckpointRestore(yaffs_Device *dev);
+
+/* Directory operations */
+yaffs_Object *yaffs_MknodDirectory(yaffs_Object *parent, const YCHAR *name,
+				__u32 mode, __u32 uid, __u32 gid);
+yaffs_Object *yaffs_FindObjectByName(yaffs_Object *theDir, const YCHAR *name);
+int yaffs_ApplyToDirectoryChildren(yaffs_Object *theDir,
+				   int (*fn) (yaffs_Object *));
+
+yaffs_Object *yaffs_FindObjectByNumber(yaffs_Device *dev, __u32 number);
+
+/* Link operations */
+yaffs_Object *yaffs_Link(yaffs_Object *parent, const YCHAR *name,
+			 yaffs_Object *equivalentObject);
+
+yaffs_Object *yaffs_GetEquivalentObject(yaffs_Object *obj);
+
+/* Symlink operations */
+yaffs_Object *yaffs_MknodSymLink(yaffs_Object *parent, const YCHAR *name,
+				 __u32 mode, __u32 uid, __u32 gid,
+				 const YCHAR *alias);
+YCHAR *yaffs_GetSymlinkAlias(yaffs_Object *obj);
+
+/* Special inodes (fifos, sockets and devices) */
+yaffs_Object *yaffs_MknodSpecial(yaffs_Object *parent, const YCHAR *name,
+				 __u32 mode, __u32 uid, __u32 gid, __u32 rdev);
+
+/* Special directories */
+yaffs_Object *yaffs_Root(yaffs_Device *dev);
+yaffs_Object *yaffs_LostNFound(yaffs_Device *dev);
+
+#ifdef CONFIG_YAFFS_WINCE
+/* CONFIG_YAFFS_WINCE special stuff */
+void yfsd_WinFileTimeNow(__u32 target[2]);
+#endif
+
+#ifdef __KERNEL__
+
+void yaffs_HandleDeferedFree(yaffs_Object *obj);
+#endif
+
+/* Debug dump  */
+int yaffs_DumpObject(yaffs_Object *obj);
+
+void yaffs_GutsTest(yaffs_Device *dev);
+
+/* A few useful functions */
+void yaffs_InitialiseTags(yaffs_ExtendedTags *tags);
+void yaffs_DeleteChunk(yaffs_Device *dev, int chunkId, int markNAND, int lyn);
+int yaffs_CheckFF(__u8 *buffer, int nBytes);
+void yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi);
+
+__u8 *yaffs_GetTempBuffer(yaffs_Device *dev, int lineNo);
+void yaffs_ReleaseTempBuffer(yaffs_Device *dev, __u8 *buffer, int lineNo);
+
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/yaffsinterface.h linux-2.6.29-spica/fs/yaffs2/yaffsinterface.h
--- linux-2.6.29/fs/yaffs2/yaffsinterface.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffsinterface.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,21 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFSINTERFACE_H__
+#define __YAFFSINTERFACE_H__
+
+int yaffs_Initialise(unsigned nBlocks);
+
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_mtdif1.c linux-2.6.29-spica/fs/yaffs2/yaffs_mtdif1.c
--- linux-2.6.29/fs/yaffs2/yaffs_mtdif1.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_mtdif1.c	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,361 @@
+/*
+ * YAFFS: Yet another FFS. A NAND-flash specific file system.
+ * yaffs_mtdif1.c  NAND mtd interface functions for small-page NAND.
+ *
+ * Copyright (C) 2002 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This module provides the interface between yaffs_nand.c and the
+ * MTD API.  This version is used when the MTD interface supports the
+ * 'mtd_oob_ops' style calls to read_oob and write_oob, circa 2.6.17,
+ * and we have small-page NAND device.
+ *
+ * These functions are invoked via function pointers in yaffs_nand.c.
+ * This replaces functionality provided by functions in yaffs_mtdif.c
+ * and the yaffs_TagsCompatability functions in yaffs_tagscompat.c that are
+ * called in yaffs_mtdif.c when the function pointers are NULL.
+ * We assume the MTD layer is performing ECC (useNANDECC is true).
+ */
+
+#include "yportenv.h"
+#include "yaffs_guts.h"
+#include "yaffs_packedtags1.h"
+#include "yaffs_tagscompat.h"	/* for yaffs_CalcTagsECC */
+
+#include "linux/kernel.h"
+#include "linux/version.h"
+#include "linux/types.h"
+#include "linux/mtd/mtd.h"
+
+/* Don't compile this module if we don't have MTD's mtd_oob_ops interface */
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+
+const char *yaffs_mtdif1_c_version = "$Id$";
+
+#ifndef CONFIG_YAFFS_9BYTE_TAGS
+# define YTAG1_SIZE 8
+#else
+# define YTAG1_SIZE 9
+#endif
+
+#if 0
+/* Use the following nand_ecclayout with MTD when using
+ * CONFIG_YAFFS_9BYTE_TAGS and the older on-NAND tags layout.
+ * If you have existing Yaffs images and the byte order differs from this,
+ * adjust 'oobfree' to match your existing Yaffs data.
+ *
+ * This nand_ecclayout scatters/gathers to/from the old-yaffs layout with the
+ * pageStatus byte (at NAND spare offset 4) scattered/gathered from/to
+ * the 9th byte.
+ *
+ * Old-style on-NAND format: T0,T1,T2,T3,P,B,T4,T5,E0,E1,E2,T6,T7,E3,E4,E5
+ * We have/need PackedTags1 plus pageStatus: T0,T1,T2,T3,T4,T5,T6,T7,P
+ * where Tn are the tag bytes, En are MTD's ECC bytes, P is the pageStatus
+ * byte and B is the small-page bad-block indicator byte.
+ */
+static struct nand_ecclayout nand_oob_16 = {
+	.eccbytes = 6,
+	.eccpos = { 8, 9, 10, 13, 14, 15 },
+	.oobavail = 9,
+	.oobfree = { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }
+};
+#endif
+
+/* Write a chunk (page) of data to NAND.
+ *
+ * Caller always provides ExtendedTags data which are converted to a more
+ * compact (packed) form for storage in NAND.  A mini-ECC runs over the
+ * contents of the tags meta-data; used to valid the tags when read.
+ *
+ *  - Pack ExtendedTags to PackedTags1 form
+ *  - Compute mini-ECC for PackedTags1
+ *  - Write data and packed tags to NAND.
+ *
+ * Note: Due to the use of the PackedTags1 meta-data which does not include
+ * a full sequence number (as found in the larger PackedTags2 form) it is
+ * necessary for Yaffs to re-write a chunk/page (just once) to mark it as
+ * discarded and dirty.  This is not ideal: newer NAND parts are supposed
+ * to be written just once.  When Yaffs performs this operation, this
+ * function is called with a NULL data pointer -- calling MTD write_oob
+ * without data is valid usage (2.6.17).
+ *
+ * Any underlying MTD error results in YAFFS_FAIL.
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_WriteChunkWithTagsToNAND(yaffs_Device *dev,
+	int chunkInNAND, const __u8 *data, const yaffs_ExtendedTags *etags)
+{
+	struct mtd_info *mtd = dev->genericDevice;
+	int chunkBytes = dev->nDataBytesPerChunk;
+	loff_t addr = ((loff_t)chunkInNAND) * chunkBytes;
+	struct mtd_oob_ops ops;
+	yaffs_PackedTags1 pt1;
+	int retval;
+
+	/* we assume that PackedTags1 and yaffs_Tags are compatible */
+	compile_time_assertion(sizeof(yaffs_PackedTags1) == 12);
+	compile_time_assertion(sizeof(yaffs_Tags) == 8);
+
+	yaffs_PackTags1(&pt1, etags);
+	yaffs_CalcTagsECC((yaffs_Tags *)&pt1);
+
+	/* When deleting a chunk, the upper layer provides only skeletal
+	 * etags, one with chunkDeleted set.  However, we need to update the
+	 * tags, not erase them completely.  So we use the NAND write property
+	 * that only zeroed-bits stick and set tag bytes to all-ones and
+	 * zero just the (not) deleted bit.
+	 */
+#ifndef CONFIG_YAFFS_9BYTE_TAGS
+	if (etags->chunkDeleted) {
+		memset(&pt1, 0xff, 8);
+		/* clear delete status bit to indicate deleted */
+		pt1.deleted = 0;
+	}
+#else
+	((__u8 *)&pt1)[8] = 0xff;
+	if (etags->chunkDeleted) {
+		memset(&pt1, 0xff, 8);
+		/* zero pageStatus byte to indicate deleted */
+		((__u8 *)&pt1)[8] = 0;
+	}
+#endif
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OOB_AUTO;
+	ops.len = (data) ? chunkBytes : 0;
+	ops.ooblen = YTAG1_SIZE;
+	ops.datbuf = (__u8 *)data;
+	ops.oobbuf = (__u8 *)&pt1;
+
+	retval = mtd->write_oob(mtd, addr, &ops);
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"write_oob failed, chunk %d, mtd error %d\n",
+			chunkInNAND, retval);
+	}
+	return retval ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Return with empty ExtendedTags but add eccResult.
+ */
+static int rettags(yaffs_ExtendedTags *etags, int eccResult, int retval)
+{
+	if (etags) {
+		memset(etags, 0, sizeof(*etags));
+		etags->eccResult = eccResult;
+	}
+	return retval;
+}
+
+/* Read a chunk (page) from NAND.
+ *
+ * Caller expects ExtendedTags data to be usable even on error; that is,
+ * all members except eccResult and blockBad are zeroed.
+ *
+ *  - Check ECC results for data (if applicable)
+ *  - Check for blank/erased block (return empty ExtendedTags if blank)
+ *  - Check the PackedTags1 mini-ECC (correct if necessary/possible)
+ *  - Convert PackedTags1 to ExtendedTags
+ *  - Update eccResult and blockBad members to refect state.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_ReadChunkWithTagsFromNAND(yaffs_Device *dev,
+	int chunkInNAND, __u8 *data, yaffs_ExtendedTags *etags)
+{
+	struct mtd_info *mtd = dev->genericDevice;
+	int chunkBytes = dev->nDataBytesPerChunk;
+	loff_t addr = ((loff_t)chunkInNAND) * chunkBytes;
+	int eccres = YAFFS_ECC_RESULT_NO_ERROR;
+	struct mtd_oob_ops ops;
+	yaffs_PackedTags1 pt1;
+	int retval;
+	int deleted;
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OOB_AUTO;
+	ops.len = (data) ? chunkBytes : 0;
+	ops.ooblen = YTAG1_SIZE;
+	ops.datbuf = data;
+	ops.oobbuf = (__u8 *)&pt1;
+
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 20))
+	/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;
+	 * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.
+	 */
+	ops.len = (ops.datbuf) ? ops.len : ops.ooblen;
+#endif
+	/* Read page and oob using MTD.
+	 * Check status and determine ECC result.
+	 */
+	retval = mtd->read_oob(mtd, addr, &ops);
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"read_oob failed, chunk %d, mtd error %d\n",
+			chunkInNAND, retval);
+	}
+
+	switch (retval) {
+	case 0:
+		/* no error */
+		break;
+
+	case -EUCLEAN:
+		/* MTD's ECC fixed the data */
+		eccres = YAFFS_ECC_RESULT_FIXED;
+		dev->eccFixed++;
+		break;
+
+	case -EBADMSG:
+		/* MTD's ECC could not fix the data */
+		dev->eccUnfixed++;
+		/* fall into... */
+	default:
+		rettags(etags, YAFFS_ECC_RESULT_UNFIXED, 0);
+		etags->blockBad = (mtd->block_isbad)(mtd, addr);
+		return YAFFS_FAIL;
+	}
+
+	/* Check for a blank/erased chunk.
+	 */
+	if (yaffs_CheckFF((__u8 *)&pt1, 8)) {
+		/* when blank, upper layers want eccResult to be <= NO_ERROR */
+		return rettags(etags, YAFFS_ECC_RESULT_NO_ERROR, YAFFS_OK);
+	}
+
+#ifndef CONFIG_YAFFS_9BYTE_TAGS
+	/* Read deleted status (bit) then return it to it's non-deleted
+	 * state before performing tags mini-ECC check. pt1.deleted is
+	 * inverted.
+	 */
+	deleted = !pt1.deleted;
+	pt1.deleted = 1;
+#else
+	deleted = (yaffs_CountBits(((__u8 *)&pt1)[8]) < 7);
+#endif
+
+	/* Check the packed tags mini-ECC and correct if necessary/possible.
+	 */
+	retval = yaffs_CheckECCOnTags((yaffs_Tags *)&pt1);
+	switch (retval) {
+	case 0:
+		/* no tags error, use MTD result */
+		break;
+	case 1:
+		/* recovered tags-ECC error */
+		dev->tagsEccFixed++;
+		if (eccres == YAFFS_ECC_RESULT_NO_ERROR)
+			eccres = YAFFS_ECC_RESULT_FIXED;
+		break;
+	default:
+		/* unrecovered tags-ECC error */
+		dev->tagsEccUnfixed++;
+		return rettags(etags, YAFFS_ECC_RESULT_UNFIXED, YAFFS_FAIL);
+	}
+
+	/* Unpack the tags to extended form and set ECC result.
+	 * [set shouldBeFF just to keep yaffs_UnpackTags1 happy]
+	 */
+	pt1.shouldBeFF = 0xFFFFFFFF;
+	yaffs_UnpackTags1(etags, &pt1);
+	etags->eccResult = eccres;
+
+	/* Set deleted state */
+	etags->chunkDeleted = deleted;
+	return YAFFS_OK;
+}
+
+/* Mark a block bad.
+ *
+ * This is a persistant state.
+ * Use of this function should be rare.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo)
+{
+	struct mtd_info *mtd = dev->genericDevice;
+	int blocksize = dev->nChunksPerBlock * dev->nDataBytesPerChunk;
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "marking block %d bad\n", blockNo);
+
+	retval = mtd->block_markbad(mtd, (loff_t)blocksize * blockNo);
+	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Check any MTD prerequists.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+static int nandmtd1_TestPrerequists(struct mtd_info *mtd)
+{
+	/* 2.6.18 has mtd->ecclayout->oobavail */
+	/* 2.6.21 has mtd->ecclayout->oobavail and mtd->oobavail */
+	int oobavail = mtd->ecclayout->oobavail;
+
+	if (oobavail < YTAG1_SIZE) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"mtd device has only %d bytes for tags, need %d\n",
+			oobavail, YTAG1_SIZE);
+		return YAFFS_FAIL;
+	}
+	return YAFFS_OK;
+}
+
+/* Query for the current state of a specific block.
+ *
+ * Examine the tags of the first chunk of the block and return the state:
+ *  - YAFFS_BLOCK_STATE_DEAD, the block is marked bad
+ *  - YAFFS_BLOCK_STATE_NEEDS_SCANNING, the block is in use
+ *  - YAFFS_BLOCK_STATE_EMPTY, the block is clean
+ *
+ * Always returns YAFFS_OK.
+ */
+int nandmtd1_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+	yaffs_BlockState *pState, __u32 *pSequenceNumber)
+{
+	struct mtd_info *mtd = dev->genericDevice;
+	int chunkNo = blockNo * dev->nChunksPerBlock;
+	loff_t addr = (loff_t)chunkNo * dev->nDataBytesPerChunk;
+	yaffs_ExtendedTags etags;
+	int state = YAFFS_BLOCK_STATE_DEAD;
+	int seqnum = 0;
+	int retval;
+
+	/* We don't yet have a good place to test for MTD config prerequists.
+	 * Do it here as we are called during the initial scan.
+	 */
+	if (nandmtd1_TestPrerequists(mtd) != YAFFS_OK)
+		return YAFFS_FAIL;
+
+	retval = nandmtd1_ReadChunkWithTagsFromNAND(dev, chunkNo, NULL, &etags);
+	etags.blockBad = (mtd->block_isbad)(mtd, addr);
+	if (etags.blockBad) {
+		yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+			"block %d is marked bad\n", blockNo);
+		state = YAFFS_BLOCK_STATE_DEAD;
+	} else if (etags.eccResult != YAFFS_ECC_RESULT_NO_ERROR) {
+		/* bad tags, need to look more closely */
+		state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+	} else if (etags.chunkUsed) {
+		state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+		seqnum = etags.sequenceNumber;
+	} else {
+		state = YAFFS_BLOCK_STATE_EMPTY;
+	}
+
+	*pState = state;
+	*pSequenceNumber = seqnum;
+
+	/* query always succeeds */
+	return YAFFS_OK;
+}
+
+#endif /*MTD_VERSION*/
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_mtdif1.h linux-2.6.29-spica/fs/yaffs2/yaffs_mtdif1.h
--- linux-2.6.29/fs/yaffs2/yaffs_mtdif1.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_mtdif1.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF1_H__
+#define __YAFFS_MTDIF1_H__
+
+int nandmtd1_WriteChunkWithTagsToNAND(yaffs_Device *dev, int chunkInNAND,
+	const __u8 *data, const yaffs_ExtendedTags *tags);
+
+int nandmtd1_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+	__u8 *data, yaffs_ExtendedTags *tags);
+
+int nandmtd1_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);
+
+int nandmtd1_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+	yaffs_BlockState *state, __u32 *sequenceNumber);
+
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_mtdif2.c linux-2.6.29-spica/fs/yaffs2/yaffs_mtdif2.c
--- linux-2.6.29/fs/yaffs2/yaffs_mtdif2.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_mtdif2.c	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,251 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* mtd interface for YAFFS2 */
+
+const char *yaffs_mtdif2_c_version =
+	"$Id$";
+
+#include "yportenv.h"
+
+
+#include "yaffs_mtdif2.h"
+
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+
+#include "yaffs_packedtags2.h"
+
+/* NB For use with inband tags....
+ * We assume that the data buffer is of size totalBytersPerChunk so that we can also
+ * use it to load the tags.
+ */
+int nandmtd2_WriteChunkWithTagsToNAND(yaffs_Device *dev, int chunkInNAND,
+				      const __u8 *data,
+				      const yaffs_ExtendedTags *tags)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#else
+	size_t dummy;
+#endif
+	int retval = 0;
+
+	loff_t addr;
+
+	yaffs_PackedTags2 pt;
+
+	T(YAFFS_TRACE_MTD,
+	  (TSTR
+	   ("nandmtd2_WriteChunkWithTagsToNAND chunk %d data %p tags %p"
+	    TENDSTR), chunkInNAND, data, tags));
+
+	addr  = ((loff_t) chunkInNAND) * dev->totalBytesPerChunk;
+
+	/* For yaffs2 writing there must be both data and tags.
+	 * If we're using inband tags, then the tags are stuffed into
+	 * the end of the data buffer.
+	 */
+	if (!data || !tags)
+		BUG();
+	else if (dev->inbandTags) {
+		yaffs_PackedTags2TagsPart *pt2tp;
+		pt2tp = (yaffs_PackedTags2TagsPart *)(data + dev->nDataBytesPerChunk);
+		yaffs_PackTags2TagsPart(pt2tp, tags);
+	} else
+		yaffs_PackTags2(&pt, tags);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+	ops.mode = MTD_OOB_AUTO;
+	ops.ooblen = (dev->inbandTags) ? 0 : sizeof(pt);
+	ops.len = dev->totalBytesPerChunk;
+	ops.ooboffs = 0;
+	ops.datbuf = (__u8 *)data;
+	ops.oobbuf = (dev->inbandTags) ? NULL : (void *)&pt;
+	retval = mtd->write_oob(mtd, addr, &ops);
+
+#else
+	if (!dev->inbandTags) {
+		retval =
+		    mtd->write_ecc(mtd, addr, dev->nDataBytesPerChunk,
+				   &dummy, data, (__u8 *) &pt, NULL);
+	} else {
+		retval =
+		    mtd->write(mtd, addr, dev->totalBytesPerChunk, &dummy,
+			       data);
+	}
+#endif
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd2_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+				       __u8 *data, yaffs_ExtendedTags *tags)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#endif
+	size_t dummy;
+	int retval = 0;
+	int localData = 0;
+
+	loff_t addr = ((loff_t) chunkInNAND) * dev->totalBytesPerChunk;
+
+	yaffs_PackedTags2 pt;
+
+	T(YAFFS_TRACE_MTD,
+	  (TSTR
+	   ("nandmtd2_ReadChunkWithTagsFromNAND chunk %d data %p tags %p"
+	    TENDSTR), chunkInNAND, data, tags));
+
+	if (dev->inbandTags) {
+
+		if (!data) {
+			localData = 1;
+			data = yaffs_GetTempBuffer(dev, __LINE__);
+		}
+
+
+	}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+	if (dev->inbandTags || (data && !tags))
+		retval = mtd->read(mtd, addr, dev->totalBytesPerChunk,
+				&dummy, data);
+	else if (tags) {
+		ops.mode = MTD_OOB_AUTO;
+		ops.ooblen = sizeof(pt);
+		ops.len = data ? dev->nDataBytesPerChunk : sizeof(pt);
+		ops.ooboffs = 0;
+		ops.datbuf = data;
+		ops.oobbuf = dev->spareBuffer;
+		retval = mtd->read_oob(mtd, addr, &ops);
+	}
+#else
+	if (!dev->inbandTags && data && tags) {
+
+		retval = mtd->read_ecc(mtd, addr, dev->nDataBytesPerChunk,
+					  &dummy, data, dev->spareBuffer,
+					  NULL);
+	} else {
+		if (data)
+			retval =
+			    mtd->read(mtd, addr, dev->nDataBytesPerChunk, &dummy,
+				      data);
+		if (!dev->inbandTags && tags)
+			retval =
+			    mtd->read_oob(mtd, addr, mtd->oobsize, &dummy,
+					  dev->spareBuffer);
+	}
+#endif
+
+
+	if (dev->inbandTags) {
+		if (tags) {
+			yaffs_PackedTags2TagsPart *pt2tp;
+			pt2tp = (yaffs_PackedTags2TagsPart *)&data[dev->nDataBytesPerChunk];
+			yaffs_UnpackTags2TagsPart(tags, pt2tp);
+		}
+	} else {
+		if (tags) {
+			memcpy(&pt, dev->spareBuffer, sizeof(pt));
+			yaffs_UnpackTags2(tags, &pt);
+		}
+	}
+
+	if (localData)
+		yaffs_ReleaseTempBuffer(dev, data, __LINE__);
+
+	if (tags && retval == -EBADMSG && tags->eccResult == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->eccResult = YAFFS_ECC_RESULT_UNFIXED;
+		dev->eccUnfixed++;
+	}
+	if (tags && retval == -EUCLEAN && tags->eccResult == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->eccResult = YAFFS_ECC_RESULT_FIXED;
+		dev->eccFixed++;
+	}
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd2_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+	int retval;
+	T(YAFFS_TRACE_MTD,
+	  (TSTR("nandmtd2_MarkNANDBlockBad %d" TENDSTR), blockNo));
+
+	retval =
+	    mtd->block_markbad(mtd,
+			       blockNo * dev->nChunksPerBlock *
+			       dev->totalBytesPerChunk);
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+
+}
+
+int nandmtd2_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+			    yaffs_BlockState *state, __u32 *sequenceNumber)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+	int retval;
+
+	T(YAFFS_TRACE_MTD,
+	  (TSTR("nandmtd2_QueryNANDBlock %d" TENDSTR), blockNo));
+	retval =
+	    mtd->block_isbad(mtd,
+			     blockNo * dev->nChunksPerBlock *
+			     dev->totalBytesPerChunk);
+
+	if (retval) {
+		T(YAFFS_TRACE_MTD, (TSTR("block is bad" TENDSTR)));
+
+		*state = YAFFS_BLOCK_STATE_DEAD;
+		*sequenceNumber = 0;
+	} else {
+		yaffs_ExtendedTags t;
+		nandmtd2_ReadChunkWithTagsFromNAND(dev,
+						   blockNo *
+						   dev->nChunksPerBlock, NULL,
+						   &t);
+
+		if (t.chunkUsed) {
+			*sequenceNumber = t.sequenceNumber;
+			*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+		} else {
+			*sequenceNumber = 0;
+			*state = YAFFS_BLOCK_STATE_EMPTY;
+		}
+	}
+	T(YAFFS_TRACE_MTD,
+	  (TSTR("block is bad seq %d state %d" TENDSTR), *sequenceNumber,
+	   *state));
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_mtdif2.h linux-2.6.29-spica/fs/yaffs2/yaffs_mtdif2.h
--- linux-2.6.29/fs/yaffs2/yaffs_mtdif2.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_mtdif2.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,29 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF2_H__
+#define __YAFFS_MTDIF2_H__
+
+#include "yaffs_guts.h"
+int nandmtd2_WriteChunkWithTagsToNAND(yaffs_Device *dev, int chunkInNAND,
+				const __u8 *data,
+				const yaffs_ExtendedTags *tags);
+int nandmtd2_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+				__u8 *data, yaffs_ExtendedTags *tags);
+int nandmtd2_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);
+int nandmtd2_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+			yaffs_BlockState *state, __u32 *sequenceNumber);
+
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_mtdif.c linux-2.6.29-spica/fs/yaffs2/yaffs_mtdif.c
--- linux-2.6.29/fs/yaffs2/yaffs_mtdif.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_mtdif.c	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,241 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+const char *yaffs_mtdif_c_version =
+	"$Id$";
+
+#include "yportenv.h"
+
+
+#include "yaffs_mtdif.h"
+
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+#include "linux/mtd/nand.h"
+
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 18))
+static struct nand_oobinfo yaffs_oobinfo = {
+	.useecc = 1,
+	.eccbytes = 6,
+	.eccpos = {8, 9, 10, 13, 14, 15}
+};
+
+static struct nand_oobinfo yaffs_noeccinfo = {
+	.useecc = 0,
+};
+#endif
+
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+static inline void translate_spare2oob(const yaffs_Spare *spare, __u8 *oob)
+{
+	oob[0] = spare->tagByte0;
+	oob[1] = spare->tagByte1;
+	oob[2] = spare->tagByte2;
+	oob[3] = spare->tagByte3;
+	oob[4] = spare->tagByte4;
+	oob[5] = spare->tagByte5 & 0x3f;
+	oob[5] |= spare->blockStatus == 'Y' ? 0 : 0x80;
+	oob[5] |= spare->pageStatus == 0 ? 0 : 0x40;
+	oob[6] = spare->tagByte6;
+	oob[7] = spare->tagByte7;
+}
+
+static inline void translate_oob2spare(yaffs_Spare *spare, __u8 *oob)
+{
+	struct yaffs_NANDSpare *nspare = (struct yaffs_NANDSpare *)spare;
+	spare->tagByte0 = oob[0];
+	spare->tagByte1 = oob[1];
+	spare->tagByte2 = oob[2];
+	spare->tagByte3 = oob[3];
+	spare->tagByte4 = oob[4];
+	spare->tagByte5 = oob[5] == 0xff ? 0xff : oob[5] & 0x3f;
+	spare->blockStatus = oob[5] & 0x80 ? 0xff : 'Y';
+	spare->pageStatus = oob[5] & 0x40 ? 0xff : 0;
+	spare->ecc1[0] = spare->ecc1[1] = spare->ecc1[2] = 0xff;
+	spare->tagByte6 = oob[6];
+	spare->tagByte7 = oob[7];
+	spare->ecc2[0] = spare->ecc2[1] = spare->ecc2[2] = 0xff;
+
+	nspare->eccres1 = nspare->eccres2 = 0; /* FIXME */
+}
+#endif
+
+int nandmtd_WriteChunkToNAND(yaffs_Device *dev, int chunkInNAND,
+			     const __u8 *data, const yaffs_Spare *spare)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#endif
+	size_t dummy;
+	int retval = 0;
+
+	loff_t addr = ((loff_t) chunkInNAND) * dev->nDataBytesPerChunk;
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	__u8 spareAsBytes[8]; /* OOB */
+
+	if (data && !spare)
+		retval = mtd->write(mtd, addr, dev->nDataBytesPerChunk,
+				&dummy, data);
+	else if (spare) {
+		if (dev->useNANDECC) {
+			translate_spare2oob(spare, spareAsBytes);
+			ops.mode = MTD_OOB_AUTO;
+			ops.ooblen = 8; /* temp hack */
+		} else {
+			ops.mode = MTD_OOB_RAW;
+			ops.ooblen = YAFFS_BYTES_PER_SPARE;
+		}
+		ops.len = data ? dev->nDataBytesPerChunk : ops.ooblen;
+		ops.datbuf = (u8 *)data;
+		ops.ooboffs = 0;
+		ops.oobbuf = spareAsBytes;
+		retval = mtd->write_oob(mtd, addr, &ops);
+	}
+#else
+	__u8 *spareAsBytes = (__u8 *) spare;
+
+	if (data && spare) {
+		if (dev->useNANDECC)
+			retval =
+			    mtd->write_ecc(mtd, addr, dev->nDataBytesPerChunk,
+					   &dummy, data, spareAsBytes,
+					   &yaffs_oobinfo);
+		else
+			retval =
+			    mtd->write_ecc(mtd, addr, dev->nDataBytesPerChunk,
+					   &dummy, data, spareAsBytes,
+					   &yaffs_noeccinfo);
+	} else {
+		if (data)
+			retval =
+			    mtd->write(mtd, addr, dev->nDataBytesPerChunk, &dummy,
+				       data);
+		if (spare)
+			retval =
+			    mtd->write_oob(mtd, addr, YAFFS_BYTES_PER_SPARE,
+					   &dummy, spareAsBytes);
+	}
+#endif
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd_ReadChunkFromNAND(yaffs_Device *dev, int chunkInNAND, __u8 *data,
+			      yaffs_Spare *spare)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#endif
+	size_t dummy;
+	int retval = 0;
+
+	loff_t addr = ((loff_t) chunkInNAND) * dev->nDataBytesPerChunk;
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	__u8 spareAsBytes[8]; /* OOB */
+
+	if (data && !spare)
+		retval = mtd->read(mtd, addr, dev->nDataBytesPerChunk,
+				&dummy, data);
+	else if (spare) {
+		if (dev->useNANDECC) {
+			ops.mode = MTD_OOB_AUTO;
+			ops.ooblen = 8; /* temp hack */
+		} else {
+			ops.mode = MTD_OOB_RAW;
+			ops.ooblen = YAFFS_BYTES_PER_SPARE;
+		}
+		ops.len = data ? dev->nDataBytesPerChunk : ops.ooblen;
+		ops.datbuf = data;
+		ops.ooboffs = 0;
+		ops.oobbuf = spareAsBytes;
+		retval = mtd->read_oob(mtd, addr, &ops);
+		if (dev->useNANDECC)
+			translate_oob2spare(spare, spareAsBytes);
+	}
+#else
+	__u8 *spareAsBytes = (__u8 *) spare;
+
+	if (data && spare) {
+		if (dev->useNANDECC) {
+			/* Careful, this call adds 2 ints */
+			/* to the end of the spare data.  Calling function */
+			/* should allocate enough memory for spare, */
+			/* i.e. [YAFFS_BYTES_PER_SPARE+2*sizeof(int)]. */
+			retval =
+			    mtd->read_ecc(mtd, addr, dev->nDataBytesPerChunk,
+					  &dummy, data, spareAsBytes,
+					  &yaffs_oobinfo);
+		} else {
+			retval =
+			    mtd->read_ecc(mtd, addr, dev->nDataBytesPerChunk,
+					  &dummy, data, spareAsBytes,
+					  &yaffs_noeccinfo);
+		}
+	} else {
+		if (data)
+			retval =
+			    mtd->read(mtd, addr, dev->nDataBytesPerChunk, &dummy,
+				      data);
+		if (spare)
+			retval =
+			    mtd->read_oob(mtd, addr, YAFFS_BYTES_PER_SPARE,
+					  &dummy, spareAsBytes);
+	}
+#endif
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd_EraseBlockInNAND(yaffs_Device *dev, int blockNumber)
+{
+	struct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);
+	__u32 addr =
+	    ((loff_t) blockNumber) * dev->nDataBytesPerChunk
+		* dev->nChunksPerBlock;
+	struct erase_info ei;
+	int retval = 0;
+
+	ei.mtd = mtd;
+	ei.addr = addr;
+	ei.len = dev->nDataBytesPerChunk * dev->nChunksPerBlock;
+	ei.time = 1000;
+	ei.retries = 2;
+	ei.callback = NULL;
+	ei.priv = (u_long) dev;
+
+	/* Todo finish off the ei if required */
+
+	sema_init(&dev->sem, 0);
+
+	retval = mtd->erase(mtd, &ei);
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd_InitialiseNAND(yaffs_Device *dev)
+{
+	return YAFFS_OK;
+}
+
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_mtdif.h linux-2.6.29-spica/fs/yaffs2/yaffs_mtdif.h
--- linux-2.6.29/fs/yaffs2/yaffs_mtdif.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_mtdif.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,32 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF_H__
+#define __YAFFS_MTDIF_H__
+
+#include "yaffs_guts.h"
+
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 18))
+extern struct nand_oobinfo yaffs_oobinfo;
+extern struct nand_oobinfo yaffs_noeccinfo;
+#endif
+
+int nandmtd_WriteChunkToNAND(yaffs_Device *dev, int chunkInNAND,
+			const __u8 *data, const yaffs_Spare *spare);
+int nandmtd_ReadChunkFromNAND(yaffs_Device *dev, int chunkInNAND, __u8 *data,
+			yaffs_Spare *spare);
+int nandmtd_EraseBlockInNAND(yaffs_Device *dev, int blockNumber);
+int nandmtd_InitialiseNAND(yaffs_Device *dev);
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_nand.c linux-2.6.29-spica/fs/yaffs2/yaffs_nand.c
--- linux-2.6.29/fs/yaffs2/yaffs_nand.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_nand.c	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,140 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+const char *yaffs_nand_c_version =
+	"$Id$";
+
+#include "yaffs_nand.h"
+#include "yaffs_tagscompat.h"
+#include "yaffs_tagsvalidity.h"
+
+#include "yaffs_getblockinfo.h"
+
+int yaffs_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+					   __u8 *buffer,
+					   yaffs_ExtendedTags *tags)
+{
+	int result;
+	yaffs_ExtendedTags localTags;
+
+	int realignedChunkInNAND = chunkInNAND - dev->chunkOffset;
+
+	dev->nPageReads++;
+
+	/* If there are no tags provided, use local tags to get prioritised gc working */
+	if (!tags)
+		tags = &localTags;
+
+	if (dev->readChunkWithTagsFromNAND)
+		result = dev->readChunkWithTagsFromNAND(dev, realignedChunkInNAND, buffer,
+						      tags);
+	else
+		result = yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(dev,
+									realignedChunkInNAND,
+									buffer,
+									tags);
+	if (tags &&
+	   tags->eccResult > YAFFS_ECC_RESULT_NO_ERROR) {
+
+		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, chunkInNAND/dev->nChunksPerBlock);
+		yaffs_HandleChunkError(dev, bi);
+	}
+
+	return result;
+}
+
+int yaffs_WriteChunkWithTagsToNAND(yaffs_Device *dev,
+						   int chunkInNAND,
+						   const __u8 *buffer,
+						   yaffs_ExtendedTags *tags)
+{
+
+	dev->nPageWrites++;
+
+	chunkInNAND -= dev->chunkOffset;
+
+
+	if (tags) {
+		tags->sequenceNumber = dev->sequenceNumber;
+		tags->chunkUsed = 1;
+		if (!yaffs_ValidateTags(tags)) {
+			T(YAFFS_TRACE_ERROR,
+			  (TSTR("Writing uninitialised tags" TENDSTR)));
+			YBUG();
+		}
+		T(YAFFS_TRACE_WRITE,
+		  (TSTR("Writing chunk %d tags %d %d" TENDSTR), chunkInNAND,
+		   tags->objectId, tags->chunkId));
+	} else {
+		T(YAFFS_TRACE_ERROR, (TSTR("Writing with no tags" TENDSTR)));
+		YBUG();
+	}
+
+	if (dev->writeChunkWithTagsToNAND)
+		return dev->writeChunkWithTagsToNAND(dev, chunkInNAND, buffer,
+						     tags);
+	else
+		return yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(dev,
+								       chunkInNAND,
+								       buffer,
+								       tags);
+}
+
+int yaffs_MarkBlockBad(yaffs_Device *dev, int blockNo)
+{
+	blockNo -= dev->blockOffset;
+
+
+	if (dev->markNANDBlockBad)
+		return dev->markNANDBlockBad(dev, blockNo);
+	else
+		return yaffs_TagsCompatabilityMarkNANDBlockBad(dev, blockNo);
+}
+
+int yaffs_QueryInitialBlockState(yaffs_Device *dev,
+						 int blockNo,
+						 yaffs_BlockState *state,
+						 __u32 *sequenceNumber)
+{
+	blockNo -= dev->blockOffset;
+
+	if (dev->queryNANDBlock)
+		return dev->queryNANDBlock(dev, blockNo, state, sequenceNumber);
+	else
+		return yaffs_TagsCompatabilityQueryNANDBlock(dev, blockNo,
+							     state,
+							     sequenceNumber);
+}
+
+
+int yaffs_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,
+				  int blockInNAND)
+{
+	int result;
+
+	blockInNAND -= dev->blockOffset;
+
+	dev->nBlockErasures++;
+
+	result = dev->eraseBlockInNAND(dev, blockInNAND);
+
+	return result;
+}
+
+int yaffs_InitialiseNAND(struct yaffs_DeviceStruct *dev)
+{
+	return dev->initialiseNAND(dev);
+}
+
+
+
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_nandemul2k.h linux-2.6.29-spica/fs/yaffs2/yaffs_nandemul2k.h
--- linux-2.6.29/fs/yaffs2/yaffs_nandemul2k.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_nandemul2k.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* Interface to emulated NAND functions (2k page size) */
+
+#ifndef __YAFFS_NANDEMUL2K_H__
+#define __YAFFS_NANDEMUL2K_H__
+
+#include "yaffs_guts.h"
+
+int nandemul2k_WriteChunkWithTagsToNAND(struct yaffs_DeviceStruct *dev,
+					int chunkInNAND, const __u8 *data,
+					const yaffs_ExtendedTags *tags);
+int nandemul2k_ReadChunkWithTagsFromNAND(struct yaffs_DeviceStruct *dev,
+					 int chunkInNAND, __u8 *data,
+					 yaffs_ExtendedTags *tags);
+int nandemul2k_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);
+int nandemul2k_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,
+			      yaffs_BlockState *state, __u32 *sequenceNumber);
+int nandemul2k_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,
+				int blockInNAND);
+int nandemul2k_InitialiseNAND(struct yaffs_DeviceStruct *dev);
+int nandemul2k_GetBytesPerChunk(void);
+int nandemul2k_GetChunksPerBlock(void);
+int nandemul2k_GetNumberOfBlocks(void);
+
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_nand.h linux-2.6.29-spica/fs/yaffs2/yaffs_nand.h
--- linux-2.6.29/fs/yaffs2/yaffs_nand.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_nand.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,44 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_NAND_H__
+#define __YAFFS_NAND_H__
+#include "yaffs_guts.h"
+
+
+
+int yaffs_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
+					__u8 *buffer,
+					yaffs_ExtendedTags *tags);
+
+int yaffs_WriteChunkWithTagsToNAND(yaffs_Device *dev,
+						int chunkInNAND,
+						const __u8 *buffer,
+						yaffs_ExtendedTags *tags);
+
+int yaffs_MarkBlockBad(yaffs_Device *dev, int blockNo);
+
+int yaffs_QueryInitialBlockState(yaffs_Device *dev,
+						int blockNo,
+						yaffs_BlockState *state,
+						unsigned *sequenceNumber);
+
+int yaffs_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,
+				  int blockInNAND);
+
+int yaffs_InitialiseNAND(struct yaffs_DeviceStruct *dev);
+
+#endif
+
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_packedtags1.c linux-2.6.29-spica/fs/yaffs2/yaffs_packedtags1.c
--- linux-2.6.29/fs/yaffs2/yaffs_packedtags1.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_packedtags1.c	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,50 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_packedtags1.h"
+#include "yportenv.h"
+
+void yaffs_PackTags1(yaffs_PackedTags1 *pt, const yaffs_ExtendedTags *t)
+{
+	pt->chunkId = t->chunkId;
+	pt->serialNumber = t->serialNumber;
+	pt->byteCount = t->byteCount;
+	pt->objectId = t->objectId;
+	pt->ecc = 0;
+	pt->deleted = (t->chunkDeleted) ? 0 : 1;
+	pt->unusedStuff = 0;
+	pt->shouldBeFF = 0xFFFFFFFF;
+
+}
+
+void yaffs_UnpackTags1(yaffs_ExtendedTags *t, const yaffs_PackedTags1 *pt)
+{
+	static const __u8 allFF[] =
+	    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff };
+
+	if (memcmp(allFF, pt, sizeof(yaffs_PackedTags1))) {
+		t->blockBad = 0;
+		if (pt->shouldBeFF != 0xFFFFFFFF)
+			t->blockBad = 1;
+		t->chunkUsed = 1;
+		t->objectId = pt->objectId;
+		t->chunkId = pt->chunkId;
+		t->byteCount = pt->byteCount;
+		t->eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+		t->chunkDeleted = (pt->deleted) ? 0 : 1;
+		t->serialNumber = pt->serialNumber;
+	} else {
+		memset(t, 0, sizeof(yaffs_ExtendedTags));
+	}
+}
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_packedtags1.h linux-2.6.29-spica/fs/yaffs2/yaffs_packedtags1.h
--- linux-2.6.29/fs/yaffs2/yaffs_packedtags1.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_packedtags1.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,37 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* This is used to pack YAFFS1 tags, not YAFFS2 tags. */
+
+#ifndef __YAFFS_PACKEDTAGS1_H__
+#define __YAFFS_PACKEDTAGS1_H__
+
+#include "yaffs_guts.h"
+
+typedef struct {
+	unsigned chunkId:20;
+	unsigned serialNumber:2;
+	unsigned byteCount:10;
+	unsigned objectId:18;
+	unsigned ecc:12;
+	unsigned deleted:1;
+	unsigned unusedStuff:1;
+	unsigned shouldBeFF;
+
+} yaffs_PackedTags1;
+
+void yaffs_PackTags1(yaffs_PackedTags1 *pt, const yaffs_ExtendedTags *t);
+void yaffs_UnpackTags1(yaffs_ExtendedTags *t, const yaffs_PackedTags1 *pt);
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_packedtags2.c linux-2.6.29-spica/fs/yaffs2/yaffs_packedtags2.c
--- linux-2.6.29/fs/yaffs2/yaffs_packedtags2.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_packedtags2.c	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,209 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_packedtags2.h"
+#include "yportenv.h"
+#include "yaffs_tagsvalidity.h"
+
+/* This code packs a set of extended tags into a binary structure for
+ * NAND storage
+ */
+
+/* Some of the information is "extra" struff which can be packed in to
+ * speed scanning
+ * This is defined by having the EXTRA_HEADER_INFO_FLAG set.
+ */
+
+/* Extra flags applied to chunkId */
+
+#define EXTRA_HEADER_INFO_FLAG	0x80000000
+#define EXTRA_SHRINK_FLAG	0x40000000
+#define EXTRA_SHADOWS_FLAG	0x20000000
+#define EXTRA_SPARE_FLAGS	0x10000000
+
+#define ALL_EXTRA_FLAGS		0xF0000000
+
+/* Also, the top 4 bits of the object Id are set to the object type. */
+#define EXTRA_OBJECT_TYPE_SHIFT (28)
+#define EXTRA_OBJECT_TYPE_MASK  ((0x0F) << EXTRA_OBJECT_TYPE_SHIFT)
+
+#ifndef CONFIG_YAFFS_DOES_ECC
+#define YAFFS_IGNORE_TAGS_ECC 1
+#endif
+
+static void yaffs_DumpPackedTags2TagsPart(const yaffs_PackedTags2TagsPart *ptt)
+{
+	T(YAFFS_TRACE_MTD,
+	  (TSTR("packed tags obj %d chunk %d byte %d seq %d" TENDSTR),
+	   ptt->objectId, ptt->chunkId, ptt->byteCount,
+	   ptt->sequenceNumber));
+}
+static void yaffs_DumpPackedTags2(const yaffs_PackedTags2 *pt)
+{
+	yaffs_DumpPackedTags2TagsPart(&pt->t);
+}
+
+static void yaffs_DumpTags2(const yaffs_ExtendedTags *t)
+{
+	T(YAFFS_TRACE_MTD,
+	  (TSTR
+	   ("ext.tags eccres %d blkbad %d chused %d obj %d chunk%d byte %d del %d ser %d seq %d"
+	    TENDSTR), t->eccResult, t->blockBad, t->chunkUsed, t->objectId,
+	   t->chunkId, t->byteCount, t->chunkDeleted, t->serialNumber,
+	   t->sequenceNumber));
+
+}
+
+void yaffs_PackTags2TagsPart(yaffs_PackedTags2TagsPart *ptt,
+		const yaffs_ExtendedTags *t)
+{
+	ptt->chunkId = t->chunkId;
+	ptt->sequenceNumber = t->sequenceNumber;
+	ptt->byteCount = t->byteCount;
+	ptt->objectId = t->objectId;
+
+	if (t->chunkId == 0 && t->extraHeaderInfoAvailable) {
+		/* Store the extra header info instead */
+		/* We save the parent object in the chunkId */
+		ptt->chunkId = EXTRA_HEADER_INFO_FLAG
+			| t->extraParentObjectId;
+		if (t->extraIsShrinkHeader)
+			ptt->chunkId |= EXTRA_SHRINK_FLAG;
+		if (t->extraShadows)
+			ptt->chunkId |= EXTRA_SHADOWS_FLAG;
+
+		ptt->objectId &= ~EXTRA_OBJECT_TYPE_MASK;
+		ptt->objectId |=
+		    (t->extraObjectType << EXTRA_OBJECT_TYPE_SHIFT);
+
+		if (t->extraObjectType == YAFFS_OBJECT_TYPE_HARDLINK)
+			ptt->byteCount = t->extraEquivalentObjectId;
+		else if (t->extraObjectType == YAFFS_OBJECT_TYPE_FILE)
+			ptt->byteCount = t->extraFileLength;
+		else
+			ptt->byteCount = 0;
+	}
+
+	yaffs_DumpPackedTags2TagsPart(ptt);
+	yaffs_DumpTags2(t);
+}
+
+
+void yaffs_PackTags2(yaffs_PackedTags2 *pt, const yaffs_ExtendedTags *t)
+{
+	yaffs_PackTags2TagsPart(&pt->t, t);
+
+#ifndef YAFFS_IGNORE_TAGS_ECC
+	{
+		yaffs_ECCCalculateOther((unsigned char *)&pt->t,
+					sizeof(yaffs_PackedTags2TagsPart),
+					&pt->ecc);
+	}
+#endif
+}
+
+
+void yaffs_UnpackTags2TagsPart(yaffs_ExtendedTags *t,
+		yaffs_PackedTags2TagsPart *ptt)
+{
+
+	memset(t, 0, sizeof(yaffs_ExtendedTags));
+
+	yaffs_InitialiseTags(t);
+
+	if (ptt->sequenceNumber != 0xFFFFFFFF) {
+		t->blockBad = 0;
+		t->chunkUsed = 1;
+		t->objectId = ptt->objectId;
+		t->chunkId = ptt->chunkId;
+		t->byteCount = ptt->byteCount;
+		t->chunkDeleted = 0;
+		t->serialNumber = 0;
+		t->sequenceNumber = ptt->sequenceNumber;
+
+		/* Do extra header info stuff */
+
+		if (ptt->chunkId & EXTRA_HEADER_INFO_FLAG) {
+			t->chunkId = 0;
+			t->byteCount = 0;
+
+			t->extraHeaderInfoAvailable = 1;
+			t->extraParentObjectId =
+			    ptt->chunkId & (~(ALL_EXTRA_FLAGS));
+			t->extraIsShrinkHeader =
+			    (ptt->chunkId & EXTRA_SHRINK_FLAG) ? 1 : 0;
+			t->extraShadows =
+			    (ptt->chunkId & EXTRA_SHADOWS_FLAG) ? 1 : 0;
+			t->extraObjectType =
+			    ptt->objectId >> EXTRA_OBJECT_TYPE_SHIFT;
+			t->objectId &= ~EXTRA_OBJECT_TYPE_MASK;
+
+			if (t->extraObjectType == YAFFS_OBJECT_TYPE_HARDLINK)
+				t->extraEquivalentObjectId = ptt->byteCount;
+			else
+				t->extraFileLength = ptt->byteCount;
+		}
+	}
+
+	yaffs_DumpPackedTags2TagsPart(ptt);
+	yaffs_DumpTags2(t);
+
+}
+
+
+void yaffs_UnpackTags2(yaffs_ExtendedTags *t, yaffs_PackedTags2 *pt)
+{
+
+	yaffs_ECCResult eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+
+	if (pt->t.sequenceNumber != 0xFFFFFFFF) {
+		/* Page is in use */
+#ifndef YAFFS_IGNORE_TAGS_ECC
+		{
+			yaffs_ECCOther ecc;
+			int result;
+			yaffs_ECCCalculateOther((unsigned char *)&pt->t,
+						sizeof
+						(yaffs_PackedTags2TagsPart),
+						&ecc);
+			result =
+			    yaffs_ECCCorrectOther((unsigned char *)&pt->t,
+						  sizeof
+						  (yaffs_PackedTags2TagsPart),
+						  &pt->ecc, &ecc);
+			switch (result) {
+			case 0:
+				eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+				break;
+			case 1:
+				eccResult = YAFFS_ECC_RESULT_FIXED;
+				break;
+			case -1:
+				eccResult = YAFFS_ECC_RESULT_UNFIXED;
+				break;
+			default:
+				eccResult = YAFFS_ECC_RESULT_UNKNOWN;
+			}
+		}
+#endif
+	}
+
+	yaffs_UnpackTags2TagsPart(t, &pt->t);
+
+	t->eccResult = eccResult;
+
+	yaffs_DumpPackedTags2(pt);
+	yaffs_DumpTags2(t);
+
+}
+
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_packedtags2.h linux-2.6.29-spica/fs/yaffs2/yaffs_packedtags2.h
--- linux-2.6.29/fs/yaffs2/yaffs_packedtags2.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_packedtags2.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,43 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* This is used to pack YAFFS2 tags, not YAFFS1tags. */
+
+#ifndef __YAFFS_PACKEDTAGS2_H__
+#define __YAFFS_PACKEDTAGS2_H__
+
+#include "yaffs_guts.h"
+#include "yaffs_ecc.h"
+
+typedef struct {
+	unsigned sequenceNumber;
+	unsigned objectId;
+	unsigned chunkId;
+	unsigned byteCount;
+} yaffs_PackedTags2TagsPart;
+
+typedef struct {
+	yaffs_PackedTags2TagsPart t;
+	yaffs_ECCOther ecc;
+} yaffs_PackedTags2;
+
+/* Full packed tags with ECC, used for oob tags */
+void yaffs_PackTags2(yaffs_PackedTags2 *pt, const yaffs_ExtendedTags *t);
+void yaffs_UnpackTags2(yaffs_ExtendedTags *t, yaffs_PackedTags2 *pt);
+
+/* Only the tags part (no ECC for use with inband tags */
+void yaffs_PackTags2TagsPart(yaffs_PackedTags2TagsPart *pt, const yaffs_ExtendedTags *t);
+void yaffs_UnpackTags2TagsPart(yaffs_ExtendedTags *t, yaffs_PackedTags2TagsPart *pt);
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_qsort.c linux-2.6.29-spica/fs/yaffs2/yaffs_qsort.c
--- linux-2.6.29/fs/yaffs2/yaffs_qsort.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_qsort.c	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,163 @@
+/*
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "yportenv.h"
+/* #include <linux/string.h> */
+
+/*
+ * Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".
+ */
+#define swapcode(TYPE, parmi, parmj, n) do { 		\
+	long i = (n) / sizeof (TYPE); 			\
+	register TYPE *pi = (TYPE *) (parmi); 		\
+	register TYPE *pj = (TYPE *) (parmj); 		\
+	do { 						\
+		register TYPE	t = *pi;		\
+		*pi++ = *pj;				\
+		*pj++ = t;				\
+	} while (--i > 0);				\
+} while (0)
+
+#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
+	es % sizeof(long) ? 2 : es == sizeof(long) ? 0 : 1;
+
+static __inline void
+swapfunc(char *a, char *b, int n, int swaptype)
+{
+	if (swaptype <= 1)
+		swapcode(long, a, b, n);
+	else
+		swapcode(char, a, b, n);
+}
+
+#define yswap(a, b) do {					\
+	if (swaptype == 0) {				\
+		long t = *(long *)(a);			\
+		*(long *)(a) = *(long *)(b);		\
+		*(long *)(b) = t;			\
+	} else						\
+		swapfunc(a, b, es, swaptype);		\
+} while (0)
+
+#define vecswap(a, b, n) 	if ((n) > 0) swapfunc(a, b, n, swaptype)
+
+static __inline char *
+med3(char *a, char *b, char *c, int (*cmp)(const void *, const void *))
+{
+	return cmp(a, b) < 0 ?
+		(cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a))
+		: (cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c));
+}
+
+#ifndef min
+#define min(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+
+void
+yaffs_qsort(void *aa, size_t n, size_t es,
+	int (*cmp)(const void *, const void *))
+{
+	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
+	int d, r, swaptype, swap_cnt;
+	register char *a = aa;
+
+loop:	SWAPINIT(a, es);
+	swap_cnt = 0;
+	if (n < 7) {
+		for (pm = (char *)a + es; pm < (char *) a + n * es; pm += es)
+			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
+			     pl -= es)
+				yswap(pl, pl - es);
+		return;
+	}
+	pm = (char *)a + (n / 2) * es;
+	if (n > 7) {
+		pl = (char *)a;
+		pn = (char *)a + (n - 1) * es;
+		if (n > 40) {
+			d = (n / 8) * es;
+			pl = med3(pl, pl + d, pl + 2 * d, cmp);
+			pm = med3(pm - d, pm, pm + d, cmp);
+			pn = med3(pn - 2 * d, pn - d, pn, cmp);
+		}
+		pm = med3(pl, pm, pn, cmp);
+	}
+	yswap(a, pm);
+	pa = pb = (char *)a + es;
+
+	pc = pd = (char *)a + (n - 1) * es;
+	for (;;) {
+		while (pb <= pc && (r = cmp(pb, a)) <= 0) {
+			if (r == 0) {
+				swap_cnt = 1;
+				yswap(pa, pb);
+				pa += es;
+			}
+			pb += es;
+		}
+		while (pb <= pc && (r = cmp(pc, a)) >= 0) {
+			if (r == 0) {
+				swap_cnt = 1;
+				yswap(pc, pd);
+				pd -= es;
+			}
+			pc -= es;
+		}
+		if (pb > pc)
+			break;
+		yswap(pb, pc);
+		swap_cnt = 1;
+		pb += es;
+		pc -= es;
+	}
+	if (swap_cnt == 0) {  /* Switch to insertion sort */
+		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
+			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
+			     pl -= es)
+				yswap(pl, pl - es);
+		return;
+	}
+
+	pn = (char *)a + n * es;
+	r = min(pa - (char *)a, pb - pa);
+	vecswap(a, pb - r, r);
+	r = min((long)(pd - pc), (long)(pn - pd - es));
+	vecswap(pb, pn - r, r);
+	r = pb - pa;
+	if (r > es)
+		yaffs_qsort(a, r / es, es, cmp);
+	r = pd - pc;
+	if (r > es) {
+		/* Iterate rather than recurse to save stack space */
+		a = pn - r;
+		n = r / es;
+		goto loop;
+	}
+/*		yaffs_qsort(pn - r, r / es, es, cmp);*/
+}
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_qsort.h linux-2.6.29-spica/fs/yaffs2/yaffs_qsort.h
--- linux-2.6.29/fs/yaffs2/yaffs_qsort.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_qsort.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,23 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+
+#ifndef __YAFFS_QSORT_H__
+#define __YAFFS_QSORT_H__
+
+extern void yaffs_qsort(void *const base, size_t total_elems, size_t size,
+			int (*cmp)(const void *, const void *));
+
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_tagscompat.c linux-2.6.29-spica/fs/yaffs2/yaffs_tagscompat.c
--- linux-2.6.29/fs/yaffs2/yaffs_tagscompat.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_tagscompat.c	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,538 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_tagscompat.h"
+#include "yaffs_ecc.h"
+#include "yaffs_getblockinfo.h"
+
+static void yaffs_HandleReadDataError(yaffs_Device *dev, int chunkInNAND);
+#ifdef NOTYET
+static void yaffs_CheckWrittenBlock(yaffs_Device *dev, int chunkInNAND);
+static void yaffs_HandleWriteChunkOk(yaffs_Device *dev, int chunkInNAND,
+				     const __u8 *data,
+				     const yaffs_Spare *spare);
+static void yaffs_HandleUpdateChunk(yaffs_Device *dev, int chunkInNAND,
+				    const yaffs_Spare *spare);
+static void yaffs_HandleWriteChunkError(yaffs_Device *dev, int chunkInNAND);
+#endif
+
+static const char yaffs_countBitsTable[256] = {
+	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
+	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
+};
+
+int yaffs_CountBits(__u8 x)
+{
+	int retVal;
+	retVal = yaffs_countBitsTable[x];
+	return retVal;
+}
+
+/********** Tags ECC calculations  *********/
+
+void yaffs_CalcECC(const __u8 *data, yaffs_Spare *spare)
+{
+	yaffs_ECCCalculate(data, spare->ecc1);
+	yaffs_ECCCalculate(&data[256], spare->ecc2);
+}
+
+void yaffs_CalcTagsECC(yaffs_Tags *tags)
+{
+	/* Calculate an ecc */
+
+	unsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;
+	unsigned i, j;
+	unsigned ecc = 0;
+	unsigned bit = 0;
+
+	tags->ecc = 0;
+
+	for (i = 0; i < 8; i++) {
+		for (j = 1; j & 0xff; j <<= 1) {
+			bit++;
+			if (b[i] & j)
+				ecc ^= bit;
+		}
+	}
+
+	tags->ecc = ecc;
+
+}
+
+int yaffs_CheckECCOnTags(yaffs_Tags *tags)
+{
+	unsigned ecc = tags->ecc;
+
+	yaffs_CalcTagsECC(tags);
+
+	ecc ^= tags->ecc;
+
+	if (ecc && ecc <= 64) {
+		/* TODO: Handle the failure better. Retire? */
+		unsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;
+
+		ecc--;
+
+		b[ecc / 8] ^= (1 << (ecc & 7));
+
+		/* Now recvalc the ecc */
+		yaffs_CalcTagsECC(tags);
+
+		return 1;	/* recovered error */
+	} else if (ecc) {
+		/* Wierd ecc failure value */
+		/* TODO Need to do somethiong here */
+		return -1;	/* unrecovered error */
+	}
+
+	return 0;
+}
+
+/********** Tags **********/
+
+static void yaffs_LoadTagsIntoSpare(yaffs_Spare *sparePtr,
+				yaffs_Tags *tagsPtr)
+{
+	yaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;
+
+	yaffs_CalcTagsECC(tagsPtr);
+
+	sparePtr->tagByte0 = tu->asBytes[0];
+	sparePtr->tagByte1 = tu->asBytes[1];
+	sparePtr->tagByte2 = tu->asBytes[2];
+	sparePtr->tagByte3 = tu->asBytes[3];
+	sparePtr->tagByte4 = tu->asBytes[4];
+	sparePtr->tagByte5 = tu->asBytes[5];
+	sparePtr->tagByte6 = tu->asBytes[6];
+	sparePtr->tagByte7 = tu->asBytes[7];
+}
+
+static void yaffs_GetTagsFromSpare(yaffs_Device *dev, yaffs_Spare *sparePtr,
+				yaffs_Tags *tagsPtr)
+{
+	yaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;
+	int result;
+
+	tu->asBytes[0] = sparePtr->tagByte0;
+	tu->asBytes[1] = sparePtr->tagByte1;
+	tu->asBytes[2] = sparePtr->tagByte2;
+	tu->asBytes[3] = sparePtr->tagByte3;
+	tu->asBytes[4] = sparePtr->tagByte4;
+	tu->asBytes[5] = sparePtr->tagByte5;
+	tu->asBytes[6] = sparePtr->tagByte6;
+	tu->asBytes[7] = sparePtr->tagByte7;
+
+	result = yaffs_CheckECCOnTags(tagsPtr);
+	if (result > 0)
+		dev->tagsEccFixed++;
+	else if (result < 0)
+		dev->tagsEccUnfixed++;
+}
+
+static void yaffs_SpareInitialise(yaffs_Spare *spare)
+{
+	memset(spare, 0xFF, sizeof(yaffs_Spare));
+}
+
+static int yaffs_WriteChunkToNAND(struct yaffs_DeviceStruct *dev,
+				int chunkInNAND, const __u8 *data,
+				yaffs_Spare *spare)
+{
+	if (chunkInNAND < dev->startBlock * dev->nChunksPerBlock) {
+		T(YAFFS_TRACE_ERROR,
+		  (TSTR("**>> yaffs chunk %d is not valid" TENDSTR),
+		   chunkInNAND));
+		return YAFFS_FAIL;
+	}
+
+	return dev->writeChunkToNAND(dev, chunkInNAND, data, spare);
+}
+
+static int yaffs_ReadChunkFromNAND(struct yaffs_DeviceStruct *dev,
+				   int chunkInNAND,
+				   __u8 *data,
+				   yaffs_Spare *spare,
+				   yaffs_ECCResult *eccResult,
+				   int doErrorCorrection)
+{
+	int retVal;
+	yaffs_Spare localSpare;
+
+	if (!spare && data) {
+		/* If we don't have a real spare, then we use a local one. */
+		/* Need this for the calculation of the ecc */
+		spare = &localSpare;
+	}
+
+	if (!dev->useNANDECC) {
+		retVal = dev->readChunkFromNAND(dev, chunkInNAND, data, spare);
+		if (data && doErrorCorrection) {
+			/* Do ECC correction */
+			/* Todo handle any errors */
+			int eccResult1, eccResult2;
+			__u8 calcEcc[3];
+
+			yaffs_ECCCalculate(data, calcEcc);
+			eccResult1 =
+			    yaffs_ECCCorrect(data, spare->ecc1, calcEcc);
+			yaffs_ECCCalculate(&data[256], calcEcc);
+			eccResult2 =
+			    yaffs_ECCCorrect(&data[256], spare->ecc2, calcEcc);
+
+			if (eccResult1 > 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>yaffs ecc error fix performed on chunk %d:0"
+				    TENDSTR), chunkInNAND));
+				dev->eccFixed++;
+			} else if (eccResult1 < 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>yaffs ecc error unfixed on chunk %d:0"
+				    TENDSTR), chunkInNAND));
+				dev->eccUnfixed++;
+			}
+
+			if (eccResult2 > 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>yaffs ecc error fix performed on chunk %d:1"
+				    TENDSTR), chunkInNAND));
+				dev->eccFixed++;
+			} else if (eccResult2 < 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>yaffs ecc error unfixed on chunk %d:1"
+				    TENDSTR), chunkInNAND));
+				dev->eccUnfixed++;
+			}
+
+			if (eccResult1 || eccResult2) {
+				/* We had a data problem on this page */
+				yaffs_HandleReadDataError(dev, chunkInNAND);
+			}
+
+			if (eccResult1 < 0 || eccResult2 < 0)
+				*eccResult = YAFFS_ECC_RESULT_UNFIXED;
+			else if (eccResult1 > 0 || eccResult2 > 0)
+				*eccResult = YAFFS_ECC_RESULT_FIXED;
+			else
+				*eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+		}
+	} else {
+		/* Must allocate enough memory for spare+2*sizeof(int) */
+		/* for ecc results from device. */
+		struct yaffs_NANDSpare nspare;
+
+		memset(&nspare, 0, sizeof(nspare));
+
+		retVal = dev->readChunkFromNAND(dev, chunkInNAND, data,
+					(yaffs_Spare *) &nspare);
+		memcpy(spare, &nspare, sizeof(yaffs_Spare));
+		if (data && doErrorCorrection) {
+			if (nspare.eccres1 > 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>mtd ecc error fix performed on chunk %d:0"
+				    TENDSTR), chunkInNAND));
+			} else if (nspare.eccres1 < 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>mtd ecc error unfixed on chunk %d:0"
+				    TENDSTR), chunkInNAND));
+			}
+
+			if (nspare.eccres2 > 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>mtd ecc error fix performed on chunk %d:1"
+				    TENDSTR), chunkInNAND));
+			} else if (nspare.eccres2 < 0) {
+				T(YAFFS_TRACE_ERROR,
+				  (TSTR
+				   ("**>>mtd ecc error unfixed on chunk %d:1"
+				    TENDSTR), chunkInNAND));
+			}
+
+			if (nspare.eccres1 || nspare.eccres2) {
+				/* We had a data problem on this page */
+				yaffs_HandleReadDataError(dev, chunkInNAND);
+			}
+
+			if (nspare.eccres1 < 0 || nspare.eccres2 < 0)
+				*eccResult = YAFFS_ECC_RESULT_UNFIXED;
+			else if (nspare.eccres1 > 0 || nspare.eccres2 > 0)
+				*eccResult = YAFFS_ECC_RESULT_FIXED;
+			else
+				*eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+
+		}
+	}
+	return retVal;
+}
+
+#ifdef NOTYET
+static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,
+				  int chunkInNAND)
+{
+	static int init;
+	static __u8 cmpbuf[YAFFS_BYTES_PER_CHUNK];
+	static __u8 data[YAFFS_BYTES_PER_CHUNK];
+	/* Might as well always allocate the larger size for */
+	/* dev->useNANDECC == true; */
+	static __u8 spare[sizeof(struct yaffs_NANDSpare)];
+
+	dev->readChunkFromNAND(dev, chunkInNAND, data, (yaffs_Spare *) spare);
+
+	if (!init) {
+		memset(cmpbuf, 0xff, YAFFS_BYTES_PER_CHUNK);
+		init = 1;
+	}
+
+	if (memcmp(cmpbuf, data, YAFFS_BYTES_PER_CHUNK))
+		return YAFFS_FAIL;
+	if (memcmp(cmpbuf, spare, 16))
+		return YAFFS_FAIL;
+
+	return YAFFS_OK;
+
+}
+#endif
+
+/*
+ * Functions for robustisizing
+ */
+
+static void yaffs_HandleReadDataError(yaffs_Device *dev, int chunkInNAND)
+{
+	int blockInNAND = chunkInNAND / dev->nChunksPerBlock;
+
+	/* Mark the block for retirement */
+	yaffs_GetBlockInfo(dev, blockInNAND + dev->blockOffset)->needsRetiring = 1;
+	T(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+	  (TSTR("**>>Block %d marked for retirement" TENDSTR), blockInNAND));
+
+	/* TODO:
+	 * Just do a garbage collection on the affected block
+	 * then retire the block
+	 * NB recursion
+	 */
+}
+
+#ifdef NOTYET
+static void yaffs_CheckWrittenBlock(yaffs_Device *dev, int chunkInNAND)
+{
+}
+
+static void yaffs_HandleWriteChunkOk(yaffs_Device *dev, int chunkInNAND,
+				     const __u8 *data,
+				     const yaffs_Spare *spare)
+{
+}
+
+static void yaffs_HandleUpdateChunk(yaffs_Device *dev, int chunkInNAND,
+				    const yaffs_Spare *spare)
+{
+}
+
+static void yaffs_HandleWriteChunkError(yaffs_Device *dev, int chunkInNAND)
+{
+	int blockInNAND = chunkInNAND / dev->nChunksPerBlock;
+
+	/* Mark the block for retirement */
+	yaffs_GetBlockInfo(dev, blockInNAND)->needsRetiring = 1;
+	/* Delete the chunk */
+	yaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);
+}
+
+static int yaffs_VerifyCompare(const __u8 *d0, const __u8 *d1,
+			       const yaffs_Spare *s0, const yaffs_Spare *s1)
+{
+
+	if (memcmp(d0, d1, YAFFS_BYTES_PER_CHUNK) != 0 ||
+	    s0->tagByte0 != s1->tagByte0 ||
+	    s0->tagByte1 != s1->tagByte1 ||
+	    s0->tagByte2 != s1->tagByte2 ||
+	    s0->tagByte3 != s1->tagByte3 ||
+	    s0->tagByte4 != s1->tagByte4 ||
+	    s0->tagByte5 != s1->tagByte5 ||
+	    s0->tagByte6 != s1->tagByte6 ||
+	    s0->tagByte7 != s1->tagByte7 ||
+	    s0->ecc1[0] != s1->ecc1[0] ||
+	    s0->ecc1[1] != s1->ecc1[1] ||
+	    s0->ecc1[2] != s1->ecc1[2] ||
+	    s0->ecc2[0] != s1->ecc2[0] ||
+	    s0->ecc2[1] != s1->ecc2[1] || s0->ecc2[2] != s1->ecc2[2]) {
+		return 0;
+	}
+
+	return 1;
+}
+#endif				/* NOTYET */
+
+int yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device *dev,
+						int chunkInNAND,
+						const __u8 *data,
+						const yaffs_ExtendedTags *eTags)
+{
+	yaffs_Spare spare;
+	yaffs_Tags tags;
+
+	yaffs_SpareInitialise(&spare);
+
+	if (eTags->chunkDeleted)
+		spare.pageStatus = 0;
+	else {
+		tags.objectId = eTags->objectId;
+		tags.chunkId = eTags->chunkId;
+
+		tags.byteCountLSB = eTags->byteCount & 0x3ff;
+
+		if (dev->nDataBytesPerChunk >= 1024)
+			tags.byteCountMSB = (eTags->byteCount >> 10) & 3;
+		else
+			tags.byteCountMSB = 3;
+
+
+		tags.serialNumber = eTags->serialNumber;
+
+		if (!dev->useNANDECC && data)
+			yaffs_CalcECC(data, &spare);
+
+		yaffs_LoadTagsIntoSpare(&spare, &tags);
+
+	}
+
+	return yaffs_WriteChunkToNAND(dev, chunkInNAND, data, &spare);
+}
+
+int yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device *dev,
+						     int chunkInNAND,
+						     __u8 *data,
+						     yaffs_ExtendedTags *eTags)
+{
+
+	yaffs_Spare spare;
+	yaffs_Tags tags;
+	yaffs_ECCResult eccResult = YAFFS_ECC_RESULT_UNKNOWN;
+
+	static yaffs_Spare spareFF;
+	static int init;
+
+	if (!init) {
+		memset(&spareFF, 0xFF, sizeof(spareFF));
+		init = 1;
+	}
+
+	if (yaffs_ReadChunkFromNAND
+	    (dev, chunkInNAND, data, &spare, &eccResult, 1)) {
+		/* eTags may be NULL */
+		if (eTags) {
+
+			int deleted =
+			    (yaffs_CountBits(spare.pageStatus) < 7) ? 1 : 0;
+
+			eTags->chunkDeleted = deleted;
+			eTags->eccResult = eccResult;
+			eTags->blockBad = 0;	/* We're reading it */
+			/* therefore it is not a bad block */
+			eTags->chunkUsed =
+			    (memcmp(&spareFF, &spare, sizeof(spareFF)) !=
+			     0) ? 1 : 0;
+
+			if (eTags->chunkUsed) {
+				yaffs_GetTagsFromSpare(dev, &spare, &tags);
+
+				eTags->objectId = tags.objectId;
+				eTags->chunkId = tags.chunkId;
+				eTags->byteCount = tags.byteCountLSB;
+
+				if (dev->nDataBytesPerChunk >= 1024)
+					eTags->byteCount |= (((unsigned) tags.byteCountMSB) << 10);
+
+				eTags->serialNumber = tags.serialNumber;
+			}
+		}
+
+		return YAFFS_OK;
+	} else {
+		return YAFFS_FAIL;
+	}
+}
+
+int yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,
+					    int blockInNAND)
+{
+
+	yaffs_Spare spare;
+
+	memset(&spare, 0xff, sizeof(yaffs_Spare));
+
+	spare.blockStatus = 'Y';
+
+	yaffs_WriteChunkToNAND(dev, blockInNAND * dev->nChunksPerBlock, NULL,
+			       &spare);
+	yaffs_WriteChunkToNAND(dev, blockInNAND * dev->nChunksPerBlock + 1,
+			       NULL, &spare);
+
+	return YAFFS_OK;
+
+}
+
+int yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,
+					  int blockNo,
+					  yaffs_BlockState *state,
+					  __u32 *sequenceNumber)
+{
+
+	yaffs_Spare spare0, spare1;
+	static yaffs_Spare spareFF;
+	static int init;
+	yaffs_ECCResult dummy;
+
+	if (!init) {
+		memset(&spareFF, 0xFF, sizeof(spareFF));
+		init = 1;
+	}
+
+	*sequenceNumber = 0;
+
+	yaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock, NULL,
+				&spare0, &dummy, 1);
+	yaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock + 1, NULL,
+				&spare1, &dummy, 1);
+
+	if (yaffs_CountBits(spare0.blockStatus & spare1.blockStatus) < 7)
+		*state = YAFFS_BLOCK_STATE_DEAD;
+	else if (memcmp(&spareFF, &spare0, sizeof(spareFF)) == 0)
+		*state = YAFFS_BLOCK_STATE_EMPTY;
+	else
+		*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+
+	return YAFFS_OK;
+}
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_tagscompat.h linux-2.6.29-spica/fs/yaffs2/yaffs_tagscompat.h
--- linux-2.6.29/fs/yaffs2/yaffs_tagscompat.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_tagscompat.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_TAGSCOMPAT_H__
+#define __YAFFS_TAGSCOMPAT_H__
+
+#include "yaffs_guts.h"
+int yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device *dev,
+						int chunkInNAND,
+						const __u8 *data,
+						const yaffs_ExtendedTags *tags);
+int yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device *dev,
+						int chunkInNAND,
+						__u8 *data,
+						yaffs_ExtendedTags *tags);
+int yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,
+					    int blockNo);
+int yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,
+					  int blockNo,
+					  yaffs_BlockState *state,
+					  __u32 *sequenceNumber);
+
+void yaffs_CalcTagsECC(yaffs_Tags *tags);
+int yaffs_CheckECCOnTags(yaffs_Tags *tags);
+int yaffs_CountBits(__u8 byte);
+
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_tagsvalidity.c linux-2.6.29-spica/fs/yaffs2/yaffs_tagsvalidity.c
--- linux-2.6.29/fs/yaffs2/yaffs_tagsvalidity.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_tagsvalidity.c	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_tagsvalidity.h"
+
+void yaffs_InitialiseTags(yaffs_ExtendedTags *tags)
+{
+	memset(tags, 0, sizeof(yaffs_ExtendedTags));
+	tags->validMarker0 = 0xAAAAAAAA;
+	tags->validMarker1 = 0x55555555;
+}
+
+int yaffs_ValidateTags(yaffs_ExtendedTags *tags)
+{
+	return (tags->validMarker0 == 0xAAAAAAAA &&
+		tags->validMarker1 == 0x55555555);
+
+}
diff -Nur linux-2.6.29/fs/yaffs2/yaffs_tagsvalidity.h linux-2.6.29-spica/fs/yaffs2/yaffs_tagsvalidity.h
--- linux-2.6.29/fs/yaffs2/yaffs_tagsvalidity.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yaffs_tagsvalidity.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,24 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+
+#ifndef __YAFFS_TAGS_VALIDITY_H__
+#define __YAFFS_TAGS_VALIDITY_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_InitialiseTags(yaffs_ExtendedTags *tags);
+int yaffs_ValidateTags(yaffs_ExtendedTags *tags);
+#endif
diff -Nur linux-2.6.29/fs/yaffs2/yportenv.h linux-2.6.29-spica/fs/yaffs2/yportenv.h
--- linux-2.6.29/fs/yaffs2/yportenv.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/fs/yaffs2/yportenv.h	2010-03-30 11:01:25.000000000 +0700
@@ -0,0 +1,203 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2007 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+
+#ifndef __YPORTENV_H__
+#define __YPORTENV_H__
+
+/*
+ * Define the MTD version in terms of Linux Kernel versions
+ * This allows yaffs to be used independantly of the kernel
+ * as well as with it.
+ */
+
+#define MTD_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + (c))
+
+#if defined CONFIG_YAFFS_WINCE
+
+#include "ywinceenv.h"
+
+#elif defined __KERNEL__
+
+#include "moduleconfig.h"
+
+/* Linux kernel */
+
+#include <linux/version.h>
+#define MTD_VERSION_CODE LINUX_VERSION_CODE
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#define YCHAR char
+#define YUCHAR unsigned char
+#define _Y(x)     x
+#define yaffs_strcat(a, b)     strcat(a, b)
+#define yaffs_strcpy(a, b)     strcpy(a, b)
+#define yaffs_strncpy(a, b, c) strncpy(a, b, c)
+#define yaffs_strncmp(a, b, c) strncmp(a, b, c)
+#define yaffs_strlen(s)	       strlen(s)
+#define yaffs_sprintf	       sprintf
+#define yaffs_toupper(a)       toupper(a)
+
+#define Y_INLINE inline
+
+#define YAFFS_LOSTNFOUND_NAME		"lost+found"
+#define YAFFS_LOSTNFOUND_PREFIX		"obj"
+
+/* #define YPRINTF(x) printk x */
+#define YMALLOC(x) kmalloc(x, GFP_NOFS)
+#define YFREE(x)   kfree(x)
+#define YMALLOC_ALT(x) vmalloc(x)
+#define YFREE_ALT(x)   vfree(x)
+#define YMALLOC_DMA(x) YMALLOC(x)
+
+/* KR - added for use in scan so processes aren't blocked indefinitely. */
+#define YYIELD() schedule()
+
+#define YAFFS_ROOT_MODE			0666
+#define YAFFS_LOSTNFOUND_MODE		0666
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
+#define Y_TIME_CONVERT(x) (x).tv_sec
+#else
+#define Y_CURRENT_TIME CURRENT_TIME
+#define Y_TIME_CONVERT(x) (x)
+#endif
+
+#define yaffs_SumCompare(x, y) ((x) == (y))
+#define yaffs_strcmp(a, b) strcmp(a, b)
+
+#define TENDSTR "\n"
+#define TSTR(x) KERN_WARNING x
+#define TCONT(x) x
+#define TOUT(p) printk p
+
+#define yaffs_trace(mask, fmt, args...) \
+	do { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) \
+		printk(KERN_WARNING "yaffs: " fmt, ## args); \
+	} while (0)
+
+#define compile_time_assertion(assertion) \
+	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
+
+#elif defined CONFIG_YAFFS_DIRECT
+
+#define MTD_VERSION_CODE MTD_VERSION(2, 6, 22)
+
+/* Direct interface */
+#include "ydirectenv.h"
+
+#elif defined CONFIG_YAFFS_UTIL
+
+/* Stuff for YAFFS utilities */
+
+#include "stdlib.h"
+#include "stdio.h"
+#include "string.h"
+
+#include "devextras.h"
+
+#define YMALLOC(x) malloc(x)
+#define YFREE(x)   free(x)
+#define YMALLOC_ALT(x) malloc(x)
+#define YFREE_ALT(x) free(x)
+
+#define YCHAR char
+#define YUCHAR unsigned char
+#define _Y(x)     x
+#define yaffs_strcat(a, b)     strcat(a, b)
+#define yaffs_strcpy(a, b)     strcpy(a, b)
+#define yaffs_strncpy(a, b, c) strncpy(a, b, c)
+#define yaffs_strlen(s)	       strlen(s)
+#define yaffs_sprintf	       sprintf
+#define yaffs_toupper(a)       toupper(a)
+
+#define Y_INLINE inline
+
+/* #define YINFO(s) YPRINTF(( __FILE__ " %d %s\n",__LINE__,s)) */
+/* #define YALERT(s) YINFO(s) */
+
+#define TENDSTR "\n"
+#define TSTR(x) x
+#define TOUT(p) printf p
+
+#define YAFFS_LOSTNFOUND_NAME		"lost+found"
+#define YAFFS_LOSTNFOUND_PREFIX		"obj"
+/* #define YPRINTF(x) printf x */
+
+#define YAFFS_ROOT_MODE				0666
+#define YAFFS_LOSTNFOUND_MODE		0666
+
+#define yaffs_SumCompare(x, y) ((x) == (y))
+#define yaffs_strcmp(a, b) strcmp(a, b)
+
+#else
+/* Should have specified a configuration type */
+#error Unknown configuration
+
+#endif
+
+/* see yaffs_fs.c */
+extern unsigned int yaffs_traceMask;
+extern unsigned int yaffs_wr_attempts;
+
+/*
+ * Tracing flags.
+ * The flags masked in YAFFS_TRACE_ALWAYS are always traced.
+ */
+
+#define YAFFS_TRACE_OS			0x00000002
+#define YAFFS_TRACE_ALLOCATE		0x00000004
+#define YAFFS_TRACE_SCAN		0x00000008
+#define YAFFS_TRACE_BAD_BLOCKS		0x00000010
+#define YAFFS_TRACE_ERASE		0x00000020
+#define YAFFS_TRACE_GC			0x00000040
+#define YAFFS_TRACE_WRITE		0x00000080
+#define YAFFS_TRACE_TRACING		0x00000100
+#define YAFFS_TRACE_DELETION		0x00000200
+#define YAFFS_TRACE_BUFFERS		0x00000400
+#define YAFFS_TRACE_NANDACCESS		0x00000800
+#define YAFFS_TRACE_GC_DETAIL		0x00001000
+#define YAFFS_TRACE_SCAN_DEBUG		0x00002000
+#define YAFFS_TRACE_MTD			0x00004000
+#define YAFFS_TRACE_CHECKPOINT		0x00008000
+
+#define YAFFS_TRACE_VERIFY		0x00010000
+#define YAFFS_TRACE_VERIFY_NAND		0x00020000
+#define YAFFS_TRACE_VERIFY_FULL		0x00040000
+#define YAFFS_TRACE_VERIFY_ALL		0x000F0000
+
+
+#define YAFFS_TRACE_ERROR		0x40000000
+#define YAFFS_TRACE_BUG			0x80000000
+#define YAFFS_TRACE_ALWAYS		0xF0000000
+
+
+#define T(mask, p) do { if ((mask) & (yaffs_traceMask | YAFFS_TRACE_ALWAYS)) TOUT(p); } while (0)
+
+#ifndef YBUG
+#define YBUG() do {T(YAFFS_TRACE_BUG, (TSTR("==>> yaffs bug: " __FILE__ " %d" TENDSTR), __LINE__)); } while (0)
+#endif
+
+#endif
diff -Nur linux-2.6.29/include/linux/akm8976.h linux-2.6.29-spica/include/linux/akm8976.h
--- linux-2.6.29/include/linux/akm8976.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/akm8976.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,90 @@
+/*
+ * Definitions for akm8976 compass chip.
+ */
+#ifndef AKM8976_H
+#define AKM8976_H
+
+#include <linux/ioctl.h>
+
+/* Compass device dependent definition */
+#define AKECS_MODE_MEASURE	0x00	/* Starts measurement. Please use AKECS_MODE_MEASURE_SNG */
+					/* or AKECS_MODE_MEASURE_SEQ instead of this. */
+#define AKECS_MODE_PFFD		0x01	/* Start pedometer and free fall detect. */
+#define AKECS_MODE_E2P_READ	0x02	/* E2P access mode (read). */
+#define AKECS_MODE_POWERDOWN	0x03	/* Power down mode */
+
+#define AKECS_MODE_MEASURE_SNG	0x10	/* Starts single measurement */
+#define AKECS_MODE_MEASURE_SEQ	0x11	/* Starts sequential measurement */
+
+/* Default register settings */
+#define CSPEC_AINT		0x01	/* Amplification for acceleration sensor */
+#define CSPEC_SNG_NUM		0x01	/* Single measurement mode */
+#define CSPEC_SEQ_NUM		0x02	/* Sequential measurement mode */
+#define CSPEC_SFRQ_32		0x00	/* Measurement frequency: 32Hz */
+#define CSPEC_SFRQ_64		0x01	/* Measurement frequency: 64Hz */
+#define CSPEC_MCS		0x07	/* Clock frequency */
+#define CSPEC_MKS		0x01	/* Clock type: CMOS level */
+#define CSPEC_INTEN		0x01	/* Interruption pin enable: Enable */
+
+#define RBUFF_SIZE		31	/* Rx buffer size */
+#define MAX_CALI_SIZE	0x1000U	/* calibration buffer size */
+
+/* AK8976A register address */
+#define AKECS_REG_ST			0xC0
+#define AKECS_REG_TMPS			0xC1
+#define AKECS_REG_MS1			0xE0
+#define AKECS_REG_MS2			0xE1
+#define AKECS_REG_MS3			0xE2
+
+#define AKMIO				0xA1
+
+/* IOCTLs for AKM library */
+#define ECS_IOCTL_INIT                  _IO(AKMIO, 0x01)
+#define ECS_IOCTL_WRITE                 _IOW(AKMIO, 0x02, char[5])
+#define ECS_IOCTL_READ                  _IOWR(AKMIO, 0x03, char[5])
+#define ECS_IOCTL_RESET      	          _IO(AKMIO, 0x04)
+#define ECS_IOCTL_INT_STATUS            _IO(AKMIO, 0x05)
+#define ECS_IOCTL_FFD_STATUS            _IO(AKMIO, 0x06)
+#define ECS_IOCTL_SET_MODE              _IOW(AKMIO, 0x07, short)
+#define ECS_IOCTL_GETDATA               _IOR(AKMIO, 0x08, char[RBUFF_SIZE+1])
+#define ECS_IOCTL_GET_NUMFRQ            _IOR(AKMIO, 0x09, char[2])
+#define ECS_IOCTL_SET_PERST             _IO(AKMIO, 0x0A)
+#define ECS_IOCTL_SET_G0RST             _IO(AKMIO, 0x0B)
+#define ECS_IOCTL_SET_YPR               _IOW(AKMIO, 0x0C, short[12])
+#define ECS_IOCTL_GET_OPEN_STATUS       _IOR(AKMIO, 0x0D, int)
+#define ECS_IOCTL_GET_CLOSE_STATUS      _IOR(AKMIO, 0x0E, int)
+#define ECS_IOCTL_GET_CALI_DATA         _IOR(AKMIO, 0x0F, char[MAX_CALI_SIZE])
+#define ECS_IOCTL_GET_DELAY             _IOR(AKMIO, 0x30, short)
+
+/* IOCTLs for APPs */
+#define ECS_IOCTL_APP_SET_MODE		_IOW(AKMIO, 0x10, short)
+#define ECS_IOCTL_APP_SET_MFLAG		_IOW(AKMIO, 0x11, short)
+#define ECS_IOCTL_APP_GET_MFLAG		_IOW(AKMIO, 0x12, short)
+#define ECS_IOCTL_APP_SET_AFLAG		_IOW(AKMIO, 0x13, short)
+#define ECS_IOCTL_APP_GET_AFLAG		_IOR(AKMIO, 0x14, short)
+#define ECS_IOCTL_APP_SET_TFLAG		_IOR(AKMIO, 0x15, short)
+#define ECS_IOCTL_APP_GET_TFLAG		_IOR(AKMIO, 0x16, short)
+#define ECS_IOCTL_APP_RESET_PEDOMETER   _IO(AKMIO, 0x17)
+#define ECS_IOCTL_APP_SET_DELAY		_IOW(AKMIO, 0x18, short)
+#define ECS_IOCTL_APP_GET_DELAY		ECS_IOCTL_GET_DELAY
+#define ECS_IOCTL_APP_SET_MVFLAG	_IOW(AKMIO, 0x19, short)	/* Set raw magnetic vector flag */
+#define ECS_IOCTL_APP_GET_MVFLAG	_IOR(AKMIO, 0x1A, short)	/* Get raw magnetic vector flag */
+
+/* IOCTLs for pedometer */
+#define ECS_IOCTL_SET_STEP_CNT          _IOW(AKMIO, 0x20, short)
+
+/* Default GPIO setting */
+#define ECS_RST		146	/*MISC4, bit2 */
+#define ECS_CLK_ON	155	/*MISC5, bit3 */
+#define ECS_INTR	161	/*INT2, bit1 */
+
+struct akm8976_platform_data {
+	int reset;
+	int clk_on;
+	int intr;
+};
+
+extern char *get_akm_cal_ram(void);
+
+#endif
+
diff -Nur linux-2.6.29/include/linux/android_aid.h linux-2.6.29-spica/include/linux/android_aid.h
--- linux-2.6.29/include/linux/android_aid.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/android_aid.h	2010-03-30 11:01:37.000000000 +0700
@@ -0,0 +1,26 @@
+/* include/linux/android_aid.h
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_ANDROID_AID_H
+#define _LINUX_ANDROID_AID_H
+
+/* AIDs that the kernel treats differently */
+#define AID_NET_BT_ADMIN 3001
+#define AID_NET_BT       3002
+#define AID_INET         3003
+#define AID_NET_RAW      3004
+#define AID_NET_ADMIN    3005
+
+#endif
diff -Nur linux-2.6.29/include/linux/android_alarm.h linux-2.6.29-spica/include/linux/android_alarm.h
--- linux-2.6.29/include/linux/android_alarm.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/android_alarm.h	2010-03-30 11:01:35.000000000 +0700
@@ -0,0 +1,62 @@
+/* include/linux/android_alarm.h
+ *
+ * Copyright (C) 2006-2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_ANDROID_ALARM_H
+#define _LINUX_ANDROID_ALARM_H
+
+#include <linux/ioctl.h>
+#include <linux/time.h>
+
+enum android_alarm_type {
+	/* return code bit numbers or set alarm arg */
+	ANDROID_ALARM_RTC_WAKEUP,
+	ANDROID_ALARM_RTC,
+	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
+	ANDROID_ALARM_ELAPSED_REALTIME,
+	ANDROID_ALARM_SYSTEMTIME,
+
+	ANDROID_ALARM_TYPE_COUNT,
+
+	/* return code bit numbers */
+	/* ANDROID_ALARM_TIME_CHANGE = 16 */
+};
+
+enum android_alarm_return_flags {
+	ANDROID_ALARM_RTC_WAKEUP_MASK = 1U << ANDROID_ALARM_RTC_WAKEUP,
+	ANDROID_ALARM_RTC_MASK = 1U << ANDROID_ALARM_RTC,
+	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK =
+				1U << ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
+	ANDROID_ALARM_ELAPSED_REALTIME_MASK =
+				1U << ANDROID_ALARM_ELAPSED_REALTIME,
+	ANDROID_ALARM_SYSTEMTIME_MASK = 1U << ANDROID_ALARM_SYSTEMTIME,
+	ANDROID_ALARM_TIME_CHANGE_MASK = 1U << 16
+};
+
+/* Disable alarm */
+#define ANDROID_ALARM_CLEAR(type)           _IO('a', 0 | ((type) << 4))
+
+/* Ack last alarm and wait for next */
+#define ANDROID_ALARM_WAIT                  _IO('a', 1)
+
+#define ALARM_IOW(c, type, size)            _IOW('a', (c) | ((type) << 4), size)
+/* Set alarm */
+#define ANDROID_ALARM_SET(type)             ALARM_IOW(2, type, struct timespec)
+#define ANDROID_ALARM_SET_AND_WAIT(type)    ALARM_IOW(3, type, struct timespec)
+#define ANDROID_ALARM_GET_TIME(type)        ALARM_IOW(4, type, struct timespec)
+#define ANDROID_ALARM_SET_RTC               _IOW('a', 5, struct timespec)
+#define ANDROID_ALARM_BASE_CMD(cmd)         (cmd & ~(_IOC(0, 0, 0xf0, 0)))
+#define ANDROID_ALARM_IOCTL_TO_TYPE(cmd)    (_IOC_NR(cmd) >> 4)
+
+#endif
diff -Nur linux-2.6.29/include/linux/android_pmem.h linux-2.6.29-spica/include/linux/android_pmem.h
--- linux-2.6.29/include/linux/android_pmem.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/android_pmem.h	2010-03-30 11:01:34.000000000 +0700
@@ -0,0 +1,92 @@
+/* include/linux/android_pmem.h
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _ANDROID_PMEM_H_
+#define _ANDROID_PMEM_H_
+
+#define PMEM_IOCTL_MAGIC 'p'
+#define PMEM_GET_PHYS		_IOW(PMEM_IOCTL_MAGIC, 1, unsigned int)
+#define PMEM_MAP		_IOW(PMEM_IOCTL_MAGIC, 2, unsigned int)
+#define PMEM_GET_SIZE		_IOW(PMEM_IOCTL_MAGIC, 3, unsigned int)
+#define PMEM_UNMAP		_IOW(PMEM_IOCTL_MAGIC, 4, unsigned int)
+/* This ioctl will allocate pmem space, backing the file, it will fail
+ * if the file already has an allocation, pass it the len as the argument
+ * to the ioctl */
+#define PMEM_ALLOCATE		_IOW(PMEM_IOCTL_MAGIC, 5, unsigned int)
+/* This will connect a one pmem file to another, pass the file that is already
+ * backed in memory as the argument to the ioctl
+ */
+#define PMEM_CONNECT		_IOW(PMEM_IOCTL_MAGIC, 6, unsigned int)
+/* Returns the total size of the pmem region it is sent to as a pmem_region
+ * struct (with offset set to 0). 
+ */
+#define PMEM_GET_TOTAL_SIZE	_IOW(PMEM_IOCTL_MAGIC, 7, unsigned int)
+
+struct android_pmem_platform_data
+{
+	const char* name;
+	/* starting physical address of memory region */
+	unsigned long start;
+	/* size of memory region */
+	unsigned long size;
+	/* set to indicate the region should not be managed with an allocator */
+	unsigned no_allocator;
+	/* set to indicate maps of this region should be cached, if a mix of
+	 * cached and uncached is desired, set this and open the device with
+	 * O_SYNC to get an uncached region */
+	unsigned cached;
+	/* The MSM7k has bits to enable a write buffer in the bus controller*/
+	unsigned buffered;
+};
+
+struct pmem_region {
+	unsigned long offset;
+	unsigned long len;
+};
+
+#ifdef CONFIG_ANDROID_PMEM
+int is_pmem_file(struct file *file);
+int get_pmem_file(int fd, unsigned long *start, unsigned long *vstart,
+		  unsigned long *end, struct file **filp);
+int get_pmem_user_addr(struct file *file, unsigned long *start,
+		       unsigned long *end);
+void put_pmem_file(struct file* file);
+void flush_pmem_file(struct file *file, unsigned long start, unsigned long len);
+int pmem_setup(struct android_pmem_platform_data *pdata,
+	       long (*ioctl)(struct file *, unsigned int, unsigned long),
+	       int (*release)(struct inode *, struct file *));
+int pmem_remap(struct pmem_region *region, struct file *file,
+	       unsigned operation);
+
+#else
+static inline int is_pmem_file(struct file *file) { return 0; }
+static inline int get_pmem_file(int fd, unsigned long *start,
+				unsigned long *vstart, unsigned long *end,
+				struct file **filp) { return -ENOSYS; }
+static inline int get_pmem_user_addr(struct file *file, unsigned long *start,
+				     unsigned long *end) { return -ENOSYS; }
+static inline void put_pmem_file(struct file* file) { return; }
+static inline void flush_pmem_file(struct file *file, unsigned long start,
+				   unsigned long len) { return; }
+static inline int pmem_setup(struct android_pmem_platform_data *pdata,
+	      long (*ioctl)(struct file *, unsigned int, unsigned long),
+	      int (*release)(struct inode *, struct file *)) { return -ENOSYS; }
+
+static inline int pmem_remap(struct pmem_region *region, struct file *file,
+			     unsigned operation) { return -ENOSYS; }
+#endif
+
+#endif //_ANDROID_PPP_H_
+
diff -Nur linux-2.6.29/include/linux/ashmem.h linux-2.6.29-spica/include/linux/ashmem.h
--- linux-2.6.29/include/linux/ashmem.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/ashmem.h	2010-03-30 11:01:36.000000000 +0700
@@ -0,0 +1,48 @@
+/*
+ * include/linux/ashmem.h
+ *
+ * Copyright 2008 Google Inc.
+ * Author: Robert Love
+ *
+ * This file is dual licensed.  It may be redistributed and/or modified
+ * under the terms of the Apache 2.0 License OR version 2 of the GNU
+ * General Public License.
+ */
+
+#ifndef _LINUX_ASHMEM_H
+#define _LINUX_ASHMEM_H
+
+#include <linux/limits.h>
+#include <linux/ioctl.h>
+
+#define ASHMEM_NAME_LEN		256
+
+#define ASHMEM_NAME_DEF		"dev/ashmem"
+
+/* Return values from ASHMEM_PIN: Was the mapping purged while unpinned? */
+#define ASHMEM_NOT_PURGED	0
+#define ASHMEM_WAS_PURGED	1
+
+/* Return values from ASHMEM_GET_PIN_STATUS: Is the mapping pinned? */
+#define ASHMEM_IS_UNPINNED	0
+#define ASHMEM_IS_PINNED	1
+
+struct ashmem_pin {
+	__u32 offset;	/* offset into region, in bytes, page-aligned */
+	__u32 len;	/* length forward from offset, in bytes, page-aligned */
+};
+
+#define __ASHMEMIOC		0x77
+
+#define ASHMEM_SET_NAME		_IOW(__ASHMEMIOC, 1, char[ASHMEM_NAME_LEN])
+#define ASHMEM_GET_NAME		_IOR(__ASHMEMIOC, 2, char[ASHMEM_NAME_LEN])
+#define ASHMEM_SET_SIZE		_IOW(__ASHMEMIOC, 3, size_t)
+#define ASHMEM_GET_SIZE		_IO(__ASHMEMIOC, 4)
+#define ASHMEM_SET_PROT_MASK	_IOW(__ASHMEMIOC, 5, unsigned long)
+#define ASHMEM_GET_PROT_MASK	_IO(__ASHMEMIOC, 6)
+#define ASHMEM_PIN		_IOW(__ASHMEMIOC, 7, struct ashmem_pin)
+#define ASHMEM_UNPIN		_IOW(__ASHMEMIOC, 8, struct ashmem_pin)
+#define ASHMEM_GET_PIN_STATUS	_IO(__ASHMEMIOC, 9)
+#define ASHMEM_PURGE_ALL_CACHES	_IO(__ASHMEMIOC, 10)
+
+#endif	/* _LINUX_ASHMEM_H */
diff -Nur linux-2.6.29/include/linux/cpufreq.h linux-2.6.29-spica/include/linux/cpufreq.h
--- linux-2.6.29/include/linux/cpufreq.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/cpufreq.h	2010-05-06 12:42:45.684270633 +0700
@@ -124,6 +124,9 @@
 	unsigned int cpu;	/* cpu nr */
 	unsigned int old;
 	unsigned int new;
+#ifdef CONFIG_ARCH_S3C64XX
+	unsigned int new_hclk;
+#endif /* CONFIG_ARCH_S3C64XX */
 	u8 flags;		/* flags of cpufreq_driver, see below. */
 };
 
@@ -252,6 +255,11 @@
 
 void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state);
 
+#ifdef CONFIG_CPU_FREQ_STAT
+extern void cpufreq_exit_idle(int cpu, unsigned long ticks);
+#else
+#define cpufreq_exit_idle(cpu,ticks) do {} while (0)
+#endif
 
 static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy, unsigned int min, unsigned int max) 
 {
@@ -279,6 +287,9 @@
  *                        CPUFREQ 2.6. INTERFACE                     *
  *********************************************************************/
 int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
+int cpufreq_set_policy(unsigned int cpu, const char *buf); // by hskang
+extern char cpufreq_governor_name[CPUFREQ_NAME_LEN];
+void cpufreq_get_cpufreq_name(unsigned int cpu);
 int cpufreq_update_policy(unsigned int cpu);
 
 /* query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it */
diff -Nur linux-2.6.29/include/linux/dprintk.h linux-2.6.29-spica/include/linux/dprintk.h
--- linux-2.6.29/include/linux/dprintk.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/dprintk.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,33 @@
+/*****************************************************************************
+** COPYRIGHT(C)	: Samsung Electronics Co.Ltd, 2006-2011 ALL RIGHTS RESERVED
+** AUTHOR		: KyoungHOON Kim (khoonk)
+******************************************************************************
+**
+** VERSION&DATE	: Version 1.00	2006/06/02 (khoonk)
+** VERSION&DATE	: Version 2.00	2009/08/11 (mizzibi)
+** 
+*****************************************************************************/
+#ifndef	DEBUGPRINTF_H
+#define	DEBUGPRINTF_H
+
+//extern unsigned long long	iPrintFlag;
+extern int 					debug_check(unsigned long long flag);
+
+#ifdef CONFIG_SEC_DPRINTK
+#define	dprintk(x, y...)	debug_check(x) ? printk("["#x"] "y) : 0
+#else
+#define dprintk(x,y...) do { } while(0)
+#endif
+
+/* flag defintion for MODULE (can be ORed) */
+#define ODR_WR			0x0000000000000001
+#define ODR_RD			0x0000000000000002
+#define ODR_IRQ			0x0000000000000004
+#define ODR_MAP			0x0000000000000008
+
+#define TSP_KEY			0x0000000000000010
+#define TSP_ABS			0x0000000000000020
+#define KPD_PRS			0x0000000000000040
+#define KPD_RLS			0x0000000000000080
+
+#endif
diff -Nur linux-2.6.29/include/linux/earlysuspend.h linux-2.6.29-spica/include/linux/earlysuspend.h
--- linux-2.6.29/include/linux/earlysuspend.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/earlysuspend.h	2010-03-30 11:01:34.000000000 +0700
@@ -0,0 +1,56 @@
+/* include/linux/earlysuspend.h
+ *
+ * Copyright (C) 2007-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_EARLYSUSPEND_H
+#define _LINUX_EARLYSUSPEND_H
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/list.h>
+#endif
+
+/* The early_suspend structure defines suspend and resume hooks to be called
+ * when the user visible sleep state of the system changes, and a level to
+ * control the order. They can be used to turn off the screen and input
+ * devices that are not used for wakeup.
+ * Suspend handlers are called in low to high level order, resume handlers are
+ * called in the opposite order. If, when calling register_early_suspend,
+ * the suspend handlers have already been called without a matching call to the
+ * resume handlers, the suspend handler will be called directly from
+ * register_early_suspend. This direct call can violate the normal level order.
+ */
+enum {
+	EARLY_SUSPEND_LEVEL_BLANK_SCREEN = 50,
+	EARLY_SUSPEND_LEVEL_STOP_DRAWING = 100,
+	EARLY_SUSPEND_LEVEL_DISABLE_FB = 150,
+};
+struct early_suspend {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct list_head link;
+	int level;
+	void (*suspend)(struct early_suspend *h);
+	void (*resume)(struct early_suspend *h);
+#endif
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void register_early_suspend(struct early_suspend *handler);
+void unregister_early_suspend(struct early_suspend *handler);
+#else
+#define register_early_suspend(handler) do { } while (0)
+#define unregister_early_suspend(handler) do { } while (0)
+#endif
+
+#endif
+
diff -Nur linux-2.6.29/include/linux/gpio_event.h linux-2.6.29-spica/include/linux/gpio_event.h
--- linux-2.6.29/include/linux/gpio_event.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/gpio_event.h	2010-03-30 11:01:37.000000000 +0700
@@ -0,0 +1,169 @@
+/* include/linux/gpio_event.h
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_GPIO_EVENT_H
+#define _LINUX_GPIO_EVENT_H
+
+#include <linux/input.h>
+
+struct gpio_event_input_devs {
+	int count;
+	struct input_dev *dev[];
+};
+enum {
+	GPIO_EVENT_FUNC_UNINIT  = 0x0,
+	GPIO_EVENT_FUNC_INIT    = 0x1,
+	GPIO_EVENT_FUNC_SUSPEND = 0x2,
+	GPIO_EVENT_FUNC_RESUME  = 0x3,
+};
+struct gpio_event_info {
+	int (*func)(struct gpio_event_input_devs *input_devs,
+		    struct gpio_event_info *info,
+		    void **data, int func);
+	int (*event)(struct gpio_event_input_devs *input_devs,
+		     struct gpio_event_info *info,
+		     void **data, unsigned int dev, unsigned int type,
+		     unsigned int code, int value); /* out events */
+	bool no_suspend;
+};
+
+struct gpio_event_platform_data {
+	const char *name;
+	struct gpio_event_info **info;
+	size_t info_count;
+	int (*power)(const struct gpio_event_platform_data *pdata, bool on);
+	const char *names[]; /* If name is NULL, names contain a NULL */
+			     /* terminated list of input devices to create */
+};
+
+#define GPIO_EVENT_DEV_NAME "gpio-event"
+
+/* Key matrix */
+
+enum gpio_event_matrix_flags {
+	/* unset: drive active output low, set: drive active output high */
+	GPIOKPF_ACTIVE_HIGH              = 1U << 0,
+	GPIOKPF_DEBOUNCE                 = 1U << 1,
+	GPIOKPF_REMOVE_SOME_PHANTOM_KEYS = 1U << 2,
+	GPIOKPF_REMOVE_PHANTOM_KEYS      = GPIOKPF_REMOVE_SOME_PHANTOM_KEYS |
+					   GPIOKPF_DEBOUNCE,
+	GPIOKPF_DRIVE_INACTIVE           = 1U << 3,
+	GPIOKPF_LEVEL_TRIGGERED_IRQ      = 1U << 4,
+	GPIOKPF_PRINT_UNMAPPED_KEYS      = 1U << 16,
+	GPIOKPF_PRINT_MAPPED_KEYS        = 1U << 17,
+	GPIOKPF_PRINT_PHANTOM_KEYS       = 1U << 18,
+};
+
+#define MATRIX_CODE_BITS (10)
+#define MATRIX_KEY_MASK ((1U << MATRIX_CODE_BITS) - 1)
+#define MATRIX_KEY(dev, code) \
+	(((dev) << MATRIX_CODE_BITS) | (code & MATRIX_KEY_MASK))
+
+extern int gpio_event_matrix_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+struct gpio_event_matrix_info {
+	/* initialize to gpio_event_matrix_func */
+	struct gpio_event_info info;
+	/* size must be ninputs * noutputs */
+	const unsigned short *keymap;
+	unsigned int *input_gpios;
+	unsigned int *output_gpios;
+	unsigned int ninputs;
+	unsigned int noutputs;
+	/* time to wait before reading inputs after driving each output */
+	ktime_t settle_time;
+	/* time to wait before scanning the keypad a second time */
+	ktime_t debounce_delay;
+	ktime_t poll_time;
+	unsigned flags;
+};
+
+/* Directly connected inputs and outputs */
+
+enum gpio_event_direct_flags {
+	GPIOEDF_ACTIVE_HIGH         = 1U << 0,
+/*	GPIOEDF_USE_DOWN_IRQ        = 1U << 1, */
+/*	GPIOEDF_USE_IRQ             = (1U << 2) | GPIOIDF_USE_DOWN_IRQ, */
+	GPIOEDF_PRINT_KEYS          = 1U << 8,
+	GPIOEDF_PRINT_KEY_DEBOUNCE  = 1U << 9,
+};
+
+struct gpio_event_direct_entry {
+	uint32_t gpio:16;
+	uint32_t code:10;
+	uint32_t dev:6;
+};
+
+/* inputs */
+extern int gpio_event_input_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+struct gpio_event_input_info {
+	/* initialize to gpio_event_input_func */
+	struct gpio_event_info info;
+	ktime_t debounce_time;
+	ktime_t poll_time;
+	uint16_t flags;
+	uint16_t type;
+	const struct gpio_event_direct_entry *keymap;
+	size_t keymap_size;
+};
+
+/* outputs */
+extern int gpio_event_output_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+extern int gpio_event_output_event(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data,
+			unsigned int dev, unsigned int type,
+			unsigned int code, int value);
+struct gpio_event_output_info {
+	/* initialize to gpio_event_output_func and gpio_event_output_event */
+	struct gpio_event_info info;
+	uint16_t flags;
+	uint16_t type;
+	const struct gpio_event_direct_entry *keymap;
+	size_t keymap_size;
+};
+
+
+/* axes */
+
+enum gpio_event_axis_flags {
+	GPIOEAF_PRINT_UNKNOWN_DIRECTION  = 1U << 16,
+	GPIOEAF_PRINT_RAW                = 1U << 17,
+	GPIOEAF_PRINT_EVENT              = 1U << 18,
+};
+
+extern int gpio_event_axis_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+struct gpio_event_axis_info {
+	/* initialize to gpio_event_axis_func */
+	struct gpio_event_info info;
+	uint8_t  count; /* number of gpios for this axis */
+	uint8_t  dev; /* device index when using multiple input devices */
+	uint8_t  type; /* EV_REL or EV_ABS */
+	uint16_t code;
+	uint16_t decoded_size;
+	uint16_t (*map)(struct gpio_event_axis_info *info, uint16_t in);
+	uint32_t *gpio;
+	uint32_t flags;
+};
+#define gpio_axis_2bit_gray_map gpio_axis_4bit_gray_map
+#define gpio_axis_3bit_gray_map gpio_axis_4bit_gray_map
+uint16_t gpio_axis_4bit_gray_map(
+			struct gpio_event_axis_info *info, uint16_t in);
+uint16_t gpio_axis_5bit_singletrack_map(
+			struct gpio_event_axis_info *info, uint16_t in);
+
+#endif
diff -Nur linux-2.6.29/include/linux/i2c/max8698.h linux-2.6.29-spica/include/linux/i2c/max8698.h
--- linux-2.6.29/include/linux/i2c/max8698.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/i2c/max8698.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,422 @@
+
+/**************************************************************************
+
+Module Name:  max8698.h
+
+Abstract:
+
+
+**************************************************************************/
+
+
+#ifndef __LINUX_MAX8698_H
+#define __LINUX_MAX8698_H
+
+#define TRUE   1   /* Boolean true value. */
+#define FALSE  0   /* Boolean false value. */
+#ifndef NULL
+#define NULL   0
+#endif
+
+typedef  unsigned char      boolean;     /* Boolean value type. */
+
+typedef  unsigned long int  uint32;      /* Unsigned 32 bit value */
+typedef  unsigned short     uint16;      /* Unsigned 16 bit value */
+typedef  unsigned char      uint8;       /* Unsigned 8  bit value */
+
+typedef  signed long int    int32;       /* Signed 32 bit value */
+typedef  signed short       int16;       /* Signed 16 bit value */
+typedef  signed char        int8;        /* Signed 8  bit value */
+
+/* This group are the deprecated types.  Their use should be
+** discontinued and new code should use the types above
+*/
+typedef  unsigned char     byte;         /* Unsigned 8  bit value type. */
+typedef  unsigned short    word;         /* Unsinged 16 bit value type. */
+typedef  unsigned long     dword;        /* Unsigned 32 bit value type. */
+
+typedef  unsigned char     uint1;        /* Unsigned 8  bit value type. */
+typedef  unsigned short    uint2;        /* Unsigned 16 bit value type. */
+typedef  unsigned long     uint4;        /* Unsigned 32 bit value type. */
+
+typedef  signed char       int1;         /* Signed 8  bit value type. */
+typedef  signed short      int2;         /* Signed 16 bit value type. */
+typedef  long int          int4;         /* Signed 32 bit value type. */
+
+typedef  signed long       sint31;       /* Signed 32 bit value */
+typedef  signed short      sint15;       /* Signed 16 bit value */
+typedef  signed char       sint7;        /* Signed 8  bit value */
+
+
+/* MAX8698 PMIC slave address (8-bit aligned) */
+#define I2C_SLAVE_ADDR_MAX8698		0xCC
+
+/* ADISCHG_EN2 Reg bits */
+#define RAMP_1MV_US		(0x0)
+#define RAMP_2MV_US		(0x1)
+#define RAMP_3MV_US		(0x2)
+#define RAMP_4MV_US		(0x3)
+#define RAMP_5MV_US		(0x4)
+#define RAMP_6MV_US		(0x5)
+#define RAMP_7MV_US		(0x6)
+#define RAMP_8MV_US		(0x7)
+#define RAMP_9MV_US		(0x8)
+#define RAMP_10MV_US		(0x9)
+#define RAMP_11MV_US		(0xA)
+#define RAMP_12MV_US		(0xB)
+
+/* DVSARM 1~4 */
+#define DVSARM_MAX_VCC		1500
+#define DVSARM_MIN_VCC		 750
+#define DVSARM_0_75		(0x0)
+#define DVSARM_0_80		(0x1)
+#define DVSARM_0_85		(0x2)
+#define DVSARM_0_90		(0x3)
+#define DVSARM_0_95		(0x4)
+#define DVSARM_1_00		(0x5)
+#define DVSARM_1_05		(0x6)
+#define DVSARM_1_10		(0x7)
+#define DVSARM_1_15		(0x8)
+#define DVSARM_1_20		(0x9)
+#define DVSARM_1_25		(0xA)
+#define DVSARM_1_30		(0xB)
+#define DVSARM_1_35		(0xC)
+#define DVSARM_1_40		(0xD)
+#define DVSARM_1_45		(0xE)
+#define DVSARM_1_50		(0xF)
+
+/* DVSINT 1~2 */
+#define DVSINT_MAX_VCC		1500
+#define DVSINT_MIN_VCC		 750
+#define DVSINT_0_75		(0x0)
+#define DVSINT_0_80		(0x1)
+#define DVSINT_0_85		(0x2)
+#define DVSINT_0_90		(0x3)
+#define DVSINT_0_95		(0x4)
+#define DVSINT_1_00		(0x5)
+#define DVSINT_1_05		(0x6)
+#define DVSINT_1_10		(0x7)
+#define DVSINT_1_15		(0x8)
+#define DVSINT_1_20		(0x9)
+#define DVSINT_1_25		(0xA)
+#define DVSINT_1_30		(0xB)
+#define DVSINT_1_35		(0xC)
+#define DVSINT_1_40		(0xD)
+#define DVSINT_1_45		(0xE)
+#define DVSINT_1_50		(0xF)
+
+/* BUCK3 */
+#define BUCK3_1_60		(0x00)
+#define BUCK3_1_70		(0x01)
+#define BUCK3_1_80		(0x02)
+#define BUCK3_1_90		(0x03)
+#define BUCK3_2_00		(0x04)
+#define BUCK3_2_10		(0x05)
+#define BUCK3_2_20		(0x06)
+#define BUCK3_2_30		(0x07)
+#define BUCK3_2_40		(0x08)
+#define BUCK3_2_50		(0x09)
+#define BUCK3_2_60		(0x0A)
+#define BUCK3_2_70		(0x0B)
+#define BUCK3_2_80		(0x0C)
+#define BUCK3_2_90		(0x0D)
+#define BUCK3_3_00		(0x0E)
+#define BUCK3_3_10		(0x0F)
+#define BUCK3_3_20		(0x10)
+#define BUCK3_3_30		(0x11)
+#define BUCK3_3_40		(0x12)
+#define BUCK3_3_50		(0x13)
+#define BUCK3_3_60		(0x14)
+
+/* LDO 2~3 */
+#define LDO2TO3_0_80		(0x0)
+#define LDO2TO3_0_85		(0x1)
+#define LDO2TO3_0_90		(0x2)
+#define LDO2TO3_0_95		(0x3)
+#define LDO2TO3_1_00		(0x4)
+#define LDO2TO3_1_05		(0x5)
+#define LDO2TO3_1_10		(0x6)
+#define LDO2TO3_1_15		(0x7)
+#define LDO2TO3_1_20		(0x8)
+#define LDO2TO3_1_25		(0x9)
+#define LDO2TO3_1_30		(0xA)
+
+/* LDO 4~7 */
+#define LDO4TO7_1_60		(0x00)
+#define LDO4TO7_1_70		(0x01)
+#define LDO4TO7_1_80		(0x02)
+#define LDO4TO7_1_90		(0x03)
+#define LDO4TO7_2_00		(0x04)
+#define LDO4TO7_2_10		(0x05)
+#define LDO4TO7_2_20		(0x06)
+#define LDO4TO7_2_30		(0x07)
+#define LDO4TO7_2_40		(0x08)
+#define LDO4TO7_2_50		(0x09)
+#define LDO4TO7_2_60		(0x0A)
+#define LDO4TO7_2_70		(0x0B)
+#define LDO4TO7_2_80		(0x0C)
+#define LDO4TO7_2_90		(0x0D)
+#define LDO4TO7_3_00		(0x0E)
+#define LDO4TO7_3_10		(0x0F)
+#define LDO4TO7_3_20		(0x10)
+#define LDO4TO7_3_30		(0x11)
+#define LDO4TO7_3_40		(0x12)
+#define LDO4TO7_3_50		(0x13)
+#define LDO4TO7_3_60		(0x14)
+
+/* LDO8 */
+#define LDO8_3_00		(0x0)
+#define LDO8_3_10		(0x1)
+#define LDO8_3_20		(0x2)
+#define LDO8_3_30		(0x3)
+#define LDO8_3_40		(0x4)
+#define LDO8_3_50		(0x5)
+#define LDO8_3_60		(0x6)
+#define BKCHR_2_90		(0x0)
+#define BKCHR_3_00		(0x1)
+#define BKCHR_3_10		(0x2)
+#define BKCHR_3_20		(0x3)
+#define BKCHR_3_30		(0x4)
+
+/* LDO9 */
+#define LDO9_1_60		(0x00)
+#define LDO9_1_70		(0x01)
+#define LDO9_1_80		(0x02)
+#define LDO9_1_90		(0x03)
+#define LDO9_2_00		(0x04)
+#define LDO9_2_10		(0x05)
+#define LDO9_2_20		(0x06)
+#define LDO9_2_30		(0x07)
+#define LDO9_2_40		(0x08)
+#define LDO9_2_50		(0x09)
+#define LDO9_2_60		(0x0A)
+#define LDO9_2_70		(0x0B)
+#define LDO9_2_80		(0x0C)
+#define LDO9_2_90		(0x0D)
+#define LDO9_3_00		(0x0E)
+#define LDO9_3_10		(0x0F)
+#define LDO9_3_20		(0x10)
+#define LDO9_3_30		(0x11)
+#define LDO9_3_40		(0x12)
+#define LDO9_3_50		(0x13)
+#define LDO9_3_60		(0x14)
+
+/* LBCNFG */
+#define LBHYST_100MV		(0x0)
+#define LBHYST_200MV		(0x1)
+#define LBHYST_300MV		(0x2)
+#define LBHYST_400MV		(0x3)
+#define LBTH_2_80		(0x0)
+#define LBTH_2_90		(0x1)
+#define LBTH_3_00		(0x2)
+#define LBTH_3_10		(0x3)
+#define LBTH_3_20		(0x4)
+#define LBTH_3_30		(0x5)
+#define LBTH_3_40		(0x6)
+#define LBTH_3_50		(0x7)
+
+/* I2C Control Register Address */
+typedef enum {
+	REG_ONOFF1 = 0,
+	REG_ONOFF2,
+	REG_ADISCHG_EN1,
+	REG_ADISCHG_EN2,
+	REG_DVSARM1_2,
+	REG_DVSARM3_4,
+	REG_DVSINT1_2,
+	REG_BUCK3,
+	REG_LDO2_3,
+	REG_LDO4,
+	REG_LDO5,
+	REG_LDO6,
+	REG_LDO7,
+	REG_LDO8,
+	REG_LDO9,
+	REG_LBCNFG,
+
+	ENDOFREG
+} max8698_pm_register_type;
+
+typedef enum {
+	/* ONOFF1 register */
+	EN1,
+	EN2,
+	EN3,
+	ELDO2,
+	ELDO3,
+	ELDO4,
+	ELDO5,
+	/* ONOFF2 register */
+	ELDO6,
+	ELDO7,
+	ELDO8,
+	ELDO9,
+	ELBCNFG,
+	// ADISCHG_EN1 register
+	BUCK1_ADEN,
+	BUCK2_ADEN,
+	BUCK3_ADEN,
+	LDO2_ADEN,
+	LDO3_ADEN,
+	LDO4_ADEN,
+	LDO5_ADEN,
+	LDO6_ADEN,
+	// ADISCHG_EN2 register
+	LDO7_ADEN,
+	LDO8_ADEN,
+	LDO9_ADEN,
+	RAMP,
+	// DVSARM1_2 register
+	DVSARM2,
+	DVSARM1,
+	// DVSARM3_4 register
+	DVSARM4,
+	DVSARM3,
+	// DVSINT1_2 register
+	DVSINT2,
+	DVSINT1,
+	// BUCK3 register
+	BUCK3,
+	// LDO2_3 register
+	LDO3,
+	LDO2,
+	// LDO4 register
+	LDO4,
+	// LDO5 register
+	LDO5,
+	// LDO6 register
+	LDO6,
+	// LDO7 register
+	LDO7,
+	// LDO8 & BKCHR register
+	LDO8,
+	BKCHR,
+	// LDO9 register
+	LDO,
+	// LBCNFG register
+	LBHYST,
+	LBTH,
+
+	ENDOFPM
+} max8698_pm_function_type;
+
+/* MAX8698 each register info */
+typedef const struct {
+	const byte  slave_addr;
+	const byte  addr;
+} max8698_register_type;
+
+/* MAX8698 each function info */
+typedef const struct {
+	const byte  slave_addr;
+	const byte  addr;
+	const byte  mask;
+	const byte  clear;
+	const byte  shift;
+} max8698_function_type;
+
+
+/*===========================================================================
+
+      P O W E R     M A N A G E M E N T     S E C T I O N
+
+===========================================================================*/
+
+/*===========================================================================
+
+FUNCTION Set_MAX8698_PM_REG                                
+
+DESCRIPTION
+    This function write the value at the selected register in the PM section.
+
+INPUT PARAMETERS
+    reg_num :   selected register in the register address.
+    value   :   the value for reg_num.
+                This is aligned to the right side of the return value
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+    Set_MAX8698_PM_REG(CHGENB, onoff);
+
+===========================================================================*/
+extern boolean Set_MAX8698_PM_REG(max8698_pm_function_type reg_num, byte value);
+
+/*===========================================================================
+
+FUNCTION Get_MAX8698_PM_REG                                
+
+DESCRIPTION
+    This function read the value at the selected register in the PM section.
+
+INPUT PARAMETERS
+    reg_num :   selected register in the register address.
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+    reg_buff :  the value of selected register.
+                reg_buff is aligned to the right side of the return value.
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Get_MAX8698_PM_REG(max8698_pm_function_type reg_num, byte *reg_buff);
+
+/*===========================================================================
+
+FUNCTION Set_MAX8698_PM_ADDR                                
+
+DESCRIPTION
+    This function write the value at the selected register address
+    in the PM section.
+
+INPUT PARAMETERS
+    max8698_pm_register_type reg_addr    : the register address.
+    byte *reg_buff   : the array for data of register to write.
+ 	byte length      : the number of the register 
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Set_MAX8698_PM_ADDR(max8698_pm_register_type reg_addr, byte *reg_buff, byte length);
+
+/*===========================================================================
+
+FUNCTION Get_MAX8698_PM_ADDR                                
+
+DESCRIPTION
+    This function read the value at the selected register address
+    in the PM section.
+
+INPUT PARAMETERS
+    max8698_pm_register_type reg_addr   : the register address.
+    byte *reg_buff  : the array for data of register to write.
+    byte length     : the number of the register 
+
+RETURN VALUE
+    byte *reg_buff : the pointer parameter for data of sequential registers
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Get_MAX8698_PM_ADDR(max8698_pm_register_type reg_addr, byte *reg_buff, byte length);
+
+#endif /* __LINUX_MAX8698_H */
+
diff -Nur linux-2.6.29/include/linux/i2c/max8906.h linux-2.6.29-spica/include/linux/i2c/max8906.h
--- linux-2.6.29/include/linux/i2c/max8906.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/i2c/max8906.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,1959 @@
+// Maxim 8906 Command Module: Interface Window
+// Mark Underwood
+// 04/04/2006
+// (C) 2004 Maxim Integrated Products
+//---------------------------------------------------------------------------
+#ifndef MAX8906
+#define MAX8906
+
+#define TRUE   1   /* Boolean true value. */
+#define FALSE  0   /* Boolean false value. */
+#ifndef NULL
+#define NULL   0
+#endif
+
+typedef  unsigned char      boolean;     /* Boolean value type. */
+
+typedef  unsigned long int  uint32;      /* Unsigned 32 bit value */
+typedef  unsigned short     uint16;      /* Unsigned 16 bit value */
+typedef  unsigned char      uint8;       /* Unsigned 8  bit value */
+
+typedef  signed long int    int32;       /* Signed 32 bit value */
+typedef  signed short       int16;       /* Signed 16 bit value */
+typedef  signed char        int8;        /* Signed 8  bit value */
+
+/* This group are the deprecated types.  Their use should be
+** discontinued and new code should use the types above
+*/
+typedef  unsigned char     byte;         /* Unsigned 8  bit value type. */
+typedef  unsigned short    word;         /* Unsinged 16 bit value type. */
+typedef  unsigned long     dword;        /* Unsigned 32 bit value type. */
+
+typedef  unsigned char     uint1;        /* Unsigned 8  bit value type. */
+typedef  unsigned short    uint2;        /* Unsigned 16 bit value type. */
+typedef  unsigned long     uint4;        /* Unsigned 32 bit value type. */
+
+typedef  signed char       int1;         /* Signed 8  bit value type. */
+typedef  signed short      int2;         /* Signed 16 bit value type. */
+typedef  long int          int4;         /* Signed 32 bit value type. */
+
+typedef  signed long       sint31;       /* Signed 32 bit value */
+typedef  signed short      sint15;       /* Signed 16 bit value */
+typedef  signed char       sint7;        /* Signed 8  bit value */
+
+
+//===========================================================================
+// 
+//  MAX8906 Power Management Section
+// 
+//===========================================================================
+// Regulator Name
+#define NUMOFREG    24 // Number of regulators
+
+#define WBBCORE      0x01
+#define WBBRF        0x02
+#define APPS         0x04
+#define IO           0x08
+#define MEM          0x10
+#define WBBMEM       0x20
+#define WBBIO        0x40
+#define WBBANA       0x80
+#define RFRXL      0x0100
+#define RFTXL      0x0200
+#define RFRXH      0x0400
+#define RFTCXO     0x0800
+#define LDOA       0x1000
+#define LDOB       0x2000
+#define LDOC       0x4000
+#define LDOD       0x8000
+#define SIMLT    0x010000
+#define SRAM     0x020000
+#define CARD1    0x040000
+#define CARD2    0x080000
+#define MVT      0x100000
+#define BIAS     0x200000
+#define VBUS     0x400000
+#define USBTXRX  0x800000
+
+// Flexible Power Sequencer Number
+typedef enum {
+    SEQ1 = 0,
+    SEQ2,
+    SEQ3,
+    SEQ4,
+    SEQ5,
+    SEQ6,
+    SEQ7,
+    SW_CNTL
+} flex_power_seq_type;
+
+// IRQ Mask register setting
+/* ON_OFF_IRQ_MASK */
+#define SW_R_M      0x80
+#define SW_F_M      0x40
+#define SW_1SEC_M   0x20
+#define JIG_R_M     0x10
+#define JIG_F_M     0x08
+#define SW_3SEC_M   0x04
+#define MPL_EVENT_M 0x02
+
+/* CHG_IRQ1_MASK */
+#define VAC_R_M     0x80
+#define VAC_F_M     0x40
+#define VAC_OVP_M   0x20
+#define VBUS_F_M    0x10
+#define VBUS_R_M    0x08
+#define VBUS_OVP_M  0x04
+
+/* CHG_IRQ2_M */
+#define CHG_TMR_FAULT_M 0x80
+#define CHG_TOPOFF_M    0x40
+#define CHG_DONE_M      0x20
+#define CHG_RST_M       0x10
+#define MBATTLOWR_M     0x08
+#define MBATTLOWF_M     0x04
+
+/* RTC_IRQ_M */
+#define ALARM0_R_M  0x08
+#define ALARM1_R_M  0x04
+
+/* TSC_INT_M */
+#define nCONV_NS_M  0x08
+#define CONV_S_M    0x04
+#define nTS_NS_M    0x02
+#define nTS_S_M     0x01
+
+// initialize the mask register as belows.
+// If MASK bit is set, then the rising edge detection interrupt for the MASK bit is masked.
+// So, IRQ\ pin is not asserted.
+// If you want to clear some bit, please check the max8906_irq_table[] for interrupt service routine.
+#define NUMOFIRQ    0x05
+#define ON_OFF_IRQ_M    (SW_R_M | SW_F_M | SW_1SEC_M | JIG_R_M | JIG_F_M | SW_3SEC_M | MPL_EVENT_M)
+#define CHG_IRQ1_M      (VAC_R_M | VAC_F_M | VAC_OVP_M | VBUS_F_M | VBUS_R_M | VBUS_OVP_M)
+#define CHG_IRQ2_M      (CHG_TMR_FAULT_M | CHG_TOPOFF_M | CHG_DONE_M | CHG_RST_M | MBATTLOWR_M | MBATTLOWF_M)
+#define RTC_IRQ_M       (ALARM0_R_M | ALARM1_R_M)
+#define TSC_INT_M       (nCONV_NS_M | CONV_S_M | nTS_NS_M | nTS_S_M)
+
+typedef enum {
+    START_IRQ = 0,
+    /* ON_OFF_IRQ */
+    IRQ_SW_R = START_IRQ,
+    IRQ_SW_F,
+    IRQ_SW_1SEC,
+    IRQ_JIG_R,
+    IRQ_JIG_F,
+    IRQ_SW_3SEC,
+    IRQ_MPL_EVENT,
+    /* CHG_IRQ1 */
+    IRQ_VAC_R,
+    IRQ_VAC_F,
+    IRQ_VAC_OVP,
+    IRQ_VBUS_F,
+    IRQ_VBUS_R,
+    IRQ_VBUS_OVP,
+    /* CHG_IRQ2 */
+    IRQ_CHG_TMR_FAULT,
+    IRQ_CHG_TOPOFF,
+    IRQ_CHG_DONE,
+    IRQ_CHG_RST,
+    IRQ_MBATTLOWR,
+    IRQ_MBATTLOWF,
+    /* RTC_IRQ */
+    IRQ_ALARM0_R,
+    IRQ_ALARM1_R,
+    ENDOFIRQ = IRQ_ALARM1_R,
+    /* TSC_STA_INT */
+    START_TIRQ,
+    IRQ_nREF_OK = START_TIRQ,
+    IRQ_nCONV_NS,
+    IRQ_CONV_S,
+    IRQ_nTS_NS,
+    IRQ_nTS_S,
+    ENDOFTIRQ = IRQ_nTS_S
+} max8906_irq_type;
+
+typedef enum {
+    //========================================================
+    //  B A T T E R Y   C H A R G E R S
+    //========================================================
+    REG_CHG_CNTL1,
+    REG_CHG_CNTL2,
+    REG_CHG_IRQ1,
+    REG_CHG_IRQ2,
+    REG_CHG_IRQ1_MASK,
+    REG_CHG_IRQ2_MASK,
+    REG_CHG_STAT,
+    REG_BBATTCNFG,
+    
+    //========================================================
+    //  S T E P - D O W N    R E G U L A T O R S
+    //========================================================
+    REG_WBBCOREEN,
+    REG_WBBCOREFSEQ,
+    REG_WBBCORETV,
+    REG_WBBRFEN,
+    REG_WBBRFFSEQ,
+    REG_WBBRFTV,
+    REG_APPSEN,
+    REG_OVER1,
+    REG_APPSFSEQ,
+    REG_ADTV1,
+    REG_ADTV2,
+    REG_APPSCLG,
+    REG_VCC1,
+    REG_IOEN,
+    REG_IOFSEQ,
+    REG_MEMEN,
+    REG_MEMFSEQ,
+    
+    //========================================================
+    //  L I N E A R   R E G U L A T O R S
+    //========================================================
+    REG_WBBMEMEN,
+    REG_WBBMEMFSEQ,
+    REG_WBBMEMTV,
+    REG_WBBIOEN,
+    REG_WBBIOFSEQ,
+    REG_WBBIOTV,
+    REG_WBBANAEN,
+    REG_WBBANAFSEQ,
+    REG_WBBANATV,
+    REG_RFRXLEN,
+    REG_RFRXLFSEQ,
+    REG_RFRXLTV,
+    REG_RFTXLEN,
+    REG_RFTXLFSEQ,
+    REG_RFTXLTV,
+    REG_RFRXHEN,
+    REG_RFRXHFSEQ,
+    REG_RFRXHTV,
+    REG_RFTCXOEN,
+    REG_RFTCXOFSEQ,
+    REG_RFTCXOTV,
+    REG_LDOAEN,
+    REG_LDOAFSEQ,
+    REG_LDOATV,
+    REG_LDOBEN,
+    REG_LDOBFSEQ,
+    REG_LDOBTV,
+    REG_LDOCEN,
+    REG_LDOCFSEQ,
+    REG_LDOCTV,
+    REG_LDODEN,
+    REG_LDODFSEQ,
+    REG_LDODTV,
+    REG_SIMLTEN,
+    REG_SIMLTFSEQ,
+    REG_SIMLTTV,
+    REG_SRAMEN,
+    REG_SRAMFSEQ,
+    REG_SDTV1,
+    REG_SDTV2,
+    REG_SRAMCLG,
+    REG_CARD1EN,
+    REG_CARD1FSEQ,
+    REG_CARD1TV,
+    REG_CARD2EN,
+    REG_CARD2FSEQ,
+    REG_CARD2TV,
+    REG_MVTENEN,
+    REG_MVTFSEQ,
+    REG_MDTV1,
+    REG_MDTV2,
+    REG_BIASEN,
+    REG_BIASFSEQ,
+    REG_BIASTV,
+    REG_VBUSEN,
+    REG_VBUSFSEQ,
+    REG_USBTXRXEN,
+    REG_USBTXRXFSEQ,
+    
+    //========================================================
+    //  M A I N - B A T T E R Y   F A U L T   D E T E C T O R
+    //========================================================
+    REG_LBCNFG,
+    
+    //========================================================
+    //  O N / O F F   C O N T R O L L E R
+    //========================================================
+    REG_EXTWKSEL,
+    REG_ON_OFF_IRQ,
+    REG_ON_OFF_IRQ_MASK,
+    REG_ON_OFF_STAT,
+    
+    //========================================================
+    //  F L E X I B L E   P O W E R   S E Q U E N C E R
+    //========================================================
+    REG_SEQ1CNFG,
+    REG_SEQ2CNFG,
+    REG_SEQ3CNFG,
+    REG_SEQ4CNFG,
+    REG_SEQ5CNFG,
+    REG_SEQ6CNFG,
+    REG_SEQ7CNFG,
+    
+    //========================================================
+    //  U S B   T R A N S C E I V E R
+    //========================================================
+    REG_USBCNFG,
+    
+    //========================================================
+    //  T C X O   B U F F E R
+    //========================================================
+    REG_TCXOCNFG,
+    
+    //========================================================
+    //  R E F E R E N C E   O U T P U T (R E F O U T)
+    //========================================================
+    REG_REFOUTCNFG,
+    
+    //========================================================
+    //  R E A L   T I M E   C L O C K (R T C)
+    //========================================================
+    REG_RTC_SEC,       
+    REG_RTC_MIN,       
+    REG_RTC_HOURS,     
+    REG_RTC_WEEKDAY,   
+    REG_RTC_DATE,      
+    REG_RTC_MONTH,     
+    REG_RTC_YEAR1,     
+    REG_RTC_YEAR2,     
+    REG_ALARM0_SEC,    
+    REG_ALARM0_MIN,    
+    REG_ALARM0_HOURS,  
+    REG_ALARM0_WEEKDAY,
+    REG_ALARM0_DATE,   
+    REG_ALARM0_MONTH,  
+    REG_ALARM0_YEAR1,  
+    REG_ALARM0_YEAR2,  
+    REG_ALARM1_SEC,    
+    REG_ALARM1_MIN,    
+    REG_ALARM1_HOURS,  
+    REG_ALARM1_WEEKDAY,
+    REG_ALARM1_DATE,   
+    REG_ALARM1_MONTH,  
+    REG_ALARM1_YEAR1,  
+    REG_ALARM1_YEAR2,  
+    REG_ALARM0_CNTL,
+    REG_ALARM1_CNTL,
+    REG_RTC_STATUS,
+    REG_RTC_CNTL,
+    REG_RTC_IRQ,
+    REG_RTC_IRQ_MASK,
+    REG_MPL_CNTL,
+    
+    //========================================================
+    //  T O U C H - S C R E E N / A D C   C O N T R O L L E R
+    //========================================================
+    REG_TSC_STA_INT,
+    REG_TSC_INT_MASK,
+    REG_TSC_CNFG1,
+    REG_TSC_CNFG2,
+    REG_TSC_CNFG3,
+    REG_TSC_CNFG4,
+    REG_TSC_RES_CNFG1,
+    REG_TSC_AVG_CNFG1,
+    REG_TSC_ACQ_CNFG1,
+    REG_TSC_ACQ_CNFG2,
+    REG_TSC_ACQ_CNFG3,
+    //========== ADC_RESULTS registers
+    REG_ADC_X_MSB,
+    REG_ADC_X_LSB,
+    REG_ADC_Y_MSB,
+    REG_ADC_Y_LSB,
+    REG_ADC_Z1_MSB,
+    REG_ADC_Z1_LSB,
+    REG_ADC_Z2_MSB,
+    REG_ADC_Z2_LSB,
+    REG_ADC_AUX1_MSB,
+    REG_ADC_AUX1_LSB,
+    REG_ADC_VBUS_MSB,
+    REG_ADC_VBUS_LSB,
+    REG_ADC_VAC_MSB,
+    REG_ADC_VAC_LSB,
+    REG_ADC_MBATT_MSB,
+    REG_ADC_MBATT_LSB,
+    REG_ADC_BBATT_MSB,
+    REG_ADC_BBATT_LSB,
+    REG_ADC_ICHG_MSB,
+    REG_ADC_ICHG_LSB,
+    REG_ADC_TDIE_MSB,
+    REG_ADC_TDIE_LSB,
+    REG_ADC_AUX2_MSB,
+    REG_ADC_AUX2_LSB,
+    
+    // TOUCH-SCREEN CONVERSION COMMAND registers
+    REG_TSC_X_Drive,
+    REG_TSC_X_Measurement,
+    REG_TSC_Y_Drive,
+    REG_TSC_Y_Measurement,
+    REG_TSC_Z1_Drive,
+    REG_TSC_Z1_Measurement,
+    REG_TSC_Z2_Drive,
+    REG_TSC_Z2_Measurement,
+    REG_TSC_AUX1_Measurement,
+    REG_TSC_VBUS_Measurement,      
+    REG_TSC_VAC_Measurement,
+    REG_TSC_MBATT_Measurement,
+    REG_TSC_BBATT_Measurement,
+    REG_TSC_ICHG_Measurement,
+    REG_TSC_TDIE_Measurement,
+    REG_TSC_AUX2_Measurement,
+    
+    //========================================================
+    //  A U D I O   S U B S Y S T E M
+    //========================================================
+    REG_PGA_CNTL1,
+    REG_PGA_CNTL2,
+    REG_LMIX_CNTL,
+    REG_RMIX_CNTL,
+    REG_MMIX_CNTL,
+    REG_HS_RIGHT_GAIN_CNTL,
+    REG_HS_LEFT_GAIN_CNTL,
+    REG_LINE_OUT_GAIN_CNTL,
+    REG_LS_GAIN_CNTL,
+    REG_AUDIO_CNTL,
+    REG_AUDIO_ENABLE1,
+    
+    //========================================================
+    //  C H I P   I D E N T I F I C A T I O N
+    //========================================================
+    REG_II1RR,
+    REG_II2RR,
+    REG_IRQ_STAT,
+        
+    ENDOFREG
+
+} max8906_pm_register_type;
+
+typedef enum {
+    //========================================================
+    //  B A T T E R Y   C H A R G E R S
+    //========================================================
+    // CHG_CNTL1 register
+    nCHGEN,
+    CHG_TOPOFF_TH,
+    CHG_RST_HYS,
+    AC_FCHG,
+    
+    // CHG_CNTL2 register
+    VBUS_FCHG,
+    FCHG_TMR,
+    MBAT_REG_TH,
+    MBATT_THERM_REG,
+    
+    // CHG_IRQ1 register
+    VAC_R,
+    VAC_F,
+    VAC_OVP,
+    VBUS_R,
+    VBUS_F,
+    VBUS_OVP,
+    
+    // CHG_IRQ2 register
+    CHG_TMR_FAULT,
+    CHG_TOPOFF,
+    CHG_DONE,
+    CHG_RST,
+    MBATTLOWR,
+    MBATTLOWF,
+    
+    // CHG_IRQ1_MASK register
+    VAC_R_MASK,
+    VAC_F_MASK,
+    VAC_OVP_MASK,
+    VBUS_R_MASK,
+    VBUS_F_MASK,
+    VBUS_OVP_MASK,
+    
+    // CHG_IRQ2_MASK register
+    CHG_TMR_FAULT_MASK,
+    CHG_TOPOFF_MASK,
+    CHG_DONE_MASK,
+    CHG_RST_MASK,
+    MBATTLOWR_MASK,
+    MBATTLOWF_MASK,
+    
+    // CHG_STAT register
+    VAC_OK,
+    VBUS_OK,
+    CHG_TMR,
+    CHG_EN_STAT,
+    CHG_MODE,
+    MBATT_DET,
+    MBATTLOW,
+    
+    // BBATTCNGF register
+    APPALLOFF,
+    VBBATTCV,
+    
+    //========================================================
+    //  S T E P - D O W N    R E G U L A T O R S
+    //========================================================
+    // WBBCOREEN register
+    nWCRADE,
+    WCRENSRC,
+    WCREN,
+    
+    // WBBCOREFSEQ register
+    WCRFSEQPU,
+    WCRFSEQPD,
+    
+    // WBBCORETV register
+    WCRTV,
+    
+    // WBBRFEN register
+    nWRFADE,
+    WRFENSRC,
+    WRFEN,
+    
+    // WBBRFFSEQ register
+    WRFFSEQPU,
+    WRFFSEQPD,
+    
+    // WBBRFTV register
+    WRFTV,
+    
+    // APPSEN register
+    nAPPSADE,
+    nOVER1ENAPPS,
+    APPSENSRC,
+    APPSEN,
+    
+    // OVER1 register
+    ENSRAM,
+    ENAPPS,
+    
+    // APPSFSEQ register
+    APPSFSEQPU,
+    APPSFSEQPD,
+    
+    // ADTV1 register
+    T1AOST,
+    T1APPS,
+    
+    // ADTV2 register
+    T2AOST,
+    T2APPS,
+    
+    // APPSCLG register
+    CLGAPPS,
+    
+    // VCC1 register
+    MVS,
+    MGO,
+    SVS,
+    SGO,
+    AVS,
+    AGO,
+    
+    // IOEN register
+    nIOADE,
+    IOENSRC,
+    IOEN,
+    
+    // IOFSEQ register
+    IOFSEQPU,
+    IOFSEQPD,
+    
+    // MEMEN register
+    nMEMADE,
+    MEMDVM,
+    MEMENSRC,
+    MEMEN,
+    
+    // MEMFSEQ register
+    MEMFSEQPU,
+    MEMFSEQPD,
+    
+    //========================================================
+    //  L I N E A R   R E G U L A T O R S
+    //========================================================
+    // WBBMEMEN register
+    nWMEMADE,
+    WMEMENSRC,
+    WMEMEN,
+    
+    // WBBMEMFSEQ register
+    WMEMFSEQPU,
+    WMEMFSEQPD,
+    
+    // WBBMEMTV register
+    WMEMTV,
+    
+    // WBBIOEN register
+    nWIOADE,
+    SFTRSTWBB,
+    WIOENSRC,
+    WIOEN,
+    
+    // WBBIOFSEQ register
+    WIOFSEQPU,
+    WIOFSEQPD,
+    
+    // WBBIOTV register
+    WIOTV,
+    
+    // WBBANAEN register
+    nWANAADE,
+    WANAENSRC,
+    WANAEN,
+    
+    // WBBANAFSEQ register
+    WANAFSEQPU,
+    WANAFSEQPD,
+    
+    // WBBANATV register
+    WANATV,
+    
+    // RFRXLEN register
+    nRFRXLADE,
+    RFRXLENSRC,
+    RFRXLEN,
+    
+    // RFRXLFSEQ register
+    RFRXLFSEQPU,
+    RFRXLFSEQPD,
+    
+    // RFRXLTV register
+    RFRXLTV,
+    
+    // RFTXLEN register
+    nRFTXLADE,
+    RFTXLENSRC,
+    RFTXLEN,
+    
+    // RFTXLFSEQ register
+    RFTXLFSEQPU,
+    RFTXLFSEQPD,
+    
+    // RFTXLTV register
+    RFTXLTV,
+    
+    // RFRXHEN register
+    nRFRXHADE,
+    RFRXHENSRC,
+    RFRXHEN,
+    
+    // RFRXHFSEQ register
+    RFRXHFSEQPU,
+    RFRXHFSEQPD,
+    
+    // RFRXHTV register
+    RFRXHTV,
+    
+    // RFTCXOEN register
+    nRFTCXOADE,
+    RFTCXOENSRC,
+    RFTCXOEN,
+    
+    // RFTCXOFSEQ register
+    RFTCXOFSEQPU,
+    RFTCXOFSEQPD,
+    
+    // RFTCXOTV register
+    RFTCXOLTV,
+    
+    // LDOAEN register
+    nLDOAADE,
+    LDOAENSRC,
+    LDOAEN,
+    
+    // LDOAFSEQ register
+    LDOAFSEQPU,
+    LDOAFSEQPD,
+    
+    // LDOATV register
+    LDOATV,
+    
+    // LDOBEN register
+    nLDOBADE,
+    LDOBENSRC,
+    LDOBEN,
+    
+    // LDOBFSEQ register
+    LDOBFSEQPU,
+    LDOBFSEQPD,
+    
+    // LDOBTV register
+    LDOBTV,
+    
+    // LDOCEN register
+    nLDOCADE,
+    LDOCENSRC,
+    LDOCEN,
+    
+    // LDOCFSEQ register
+    LDOCFSEQPU,
+    LDOCFSEQPD,
+    
+    // LDOCTV register
+    LDOCTV,
+    
+    // LDODEN register
+    nLDODADE,
+    LDODENSRC,
+    LDODEN,
+    
+    // LDODFSEQ register
+    LDODFSEQPU,
+    LDODFSEQPD,
+    
+    // LDODTV register
+    LDODTV,
+    
+    // SIMLTEN register
+    nSIMLTADE,
+    SIMLTENSRC,
+    SIMLTEN,
+    
+    // SIMLTFSEQ register
+    SIMLTFSEQPU,
+    SIMLTFSEQPD,
+    
+    // SIMLTTV register
+    SIMLTTV,
+    
+    // SRAMEN register
+    nSRAMADE,
+    nOVER1ENSRAM,
+    SRAMENSRC,
+    SRAMEN,
+    
+    // SRAMFSEQ register
+    SRAMFSEQPU,
+    SRAMFSEQPD,
+    
+    // SDTV1 register
+    T1SOST,
+    T1SRAM,
+    
+    // SDTV2 register
+    T2SOST,
+    T2SRAM,
+    
+    // SRAMCLG register
+    CLGSRAM,
+    
+    // CARD1EN register
+    nCARD1ADE,
+    CARD1ENSRC,
+    CARD1EN,
+    
+    // CARD1FSEQ register
+    CARD1FSEQPU,
+    CARD1FSEQPD,
+    
+    // CARD1TV register
+    CARD1TV,
+    
+    // CARD2EN register
+    nCARD2ADE,
+    CARD2ENSRC,
+    CARD2EN,
+    
+    // CARD2FSEQ register
+    CARD2FSEQPU,
+    CARD2FSEQPD,
+    
+    // CARD2TV register
+    CARD2TV,
+    
+    // MVTENEN register
+    nMVTADE,
+    MVTENSRC,
+    MVTEN,
+    
+    // MVTFSEQ register
+    MVTFSEQPU,
+    MVTFSEQPD,
+    
+    // MDTV1 register
+    T1MVT,
+    
+    // MDTV2 register
+    T2MVT,
+    
+    // BIASEN register
+    nBIASADE,
+    BIASENSRC,
+    BIASEN,
+    
+    // BIASFSEQ register
+    BIASFSEQPU,
+    BIASFSEQPD,
+    
+    // BIASTV register
+    BIASTV,
+    
+    // VBUSEN register
+    nVBUSADE,
+    VBUSVINEN,
+    VBUSENSRC,
+    VBUSEN,
+    
+    // VBUSFSEQ register
+    VBUSFSEQPU,
+    VBUSFSEQPD,
+    
+    // USBTXRXEN register
+    nUSBTXRXADE,
+    USBTXRXVINEN,
+    USBTXRXENSRC,
+    USBTXRXEN,
+    
+    // USBTXRXFSEQ register
+    USBTXRXFSEQPU,
+    USBTXRXFSEQPD,
+    
+    //========================================================
+    //  M A I N - B A T T E R Y   F A U L T   D E T E C T O R
+    //========================================================
+    // LBCNFG register
+    LHYST,
+    LBDAC,
+    LBEN,
+    
+    //========================================================
+    //  O N / O F F   C O N T R O L L E R
+    //========================================================
+    // EXTWKSEL register
+    HRDRSTEN,
+    WKVBUS,
+    WKVAC,
+    WKALRM1R,
+    WKALRM0R,
+    WKSW,
+    
+    // ON_OFF_IRQ register
+    SW_R,
+    SW_F,
+    SW_1SEC,
+    JIG_R,
+    JIG_F,
+    SW_3SEC,
+    MPL_EVENT,
+    
+    // ON_OFF_IRQ_MASK register
+    SW_R_MASK,
+    SW_F_MASK,
+    SW_1SEC_MASK,
+    JIG_R_MASK,
+    JIG_F_MASK,
+    SW_3SEC_MASK,
+    MPL_EVENT_MASK,
+    
+    // ON_OFF_STAT register
+    STAT_SW,
+    STAT_SW_1SEC,
+    STAT_JIG,
+    STAT_SW_3SEC,
+    
+    //========================================================
+    //  F L E X I B L E   P O W E R   S E Q U E N C E R
+    //========================================================
+    // SEQ1CNFG register
+    SEQ1T,
+    SEQ1SRC,
+    SEQ1EN,
+    
+    // SEQ2CNFG register
+    SEQ2T,
+    SEQ2SRC,
+    SEQ2EN,
+    
+    // SEQ3CNFG register
+    SEQ3T,
+    SEQ3SRC,
+    SEQ3EN,
+    
+    // SEQ4CNFG register
+    SEQ4T,
+    SEQ4SRC,
+    SEQ4EN,
+    
+    // SEQ5CNFG register
+    SEQ5T,
+    SEQ5SRC,
+    SEQ5EN,
+    
+    // SEQ6CNFG register
+    SEQ6T,
+    SEQ6SRC,
+    SEQ6EN,
+    
+    // SEQ7CNFG register
+    SEQ7T,
+    SEQ7SRC,
+    SEQ7EN,
+    
+    //========================================================
+    //  U S B   T R A N S C E I V E R
+    //========================================================
+    // USBCNFG register
+    USB_PU_EN,
+    USB_SUSP,
+    USB_EN,
+    
+    //========================================================
+    //  T C X O   B U F F E R
+    //========================================================
+    // TCXOCNFG register
+    TCXOEN,
+    
+    //========================================================
+    //  R E F E R E N C E   O U T P U T (R E F O U T)
+    //========================================================
+    // REFOUTCNFG register
+    REFOUTEN,
+    
+    //========================================================
+    //  R E A L   T I M E   C L O C K (R T C)
+    //========================================================
+    // R T C registers
+    RTC_SEC,
+    RTC_10SEC,
+    RTC_MIN,
+    RTC_10MIN,
+    RTC_HOURS,
+    RTC_10HOURS,
+    RTC_12_n24,
+    RTC_WEEKDAY,
+    RTC_DATE,
+    RTC_10DATE,
+    RTC_MONTH,
+    RTC_10MONTH,
+    RTC_YEAR,
+    RTC_10YEAR,
+    RTC_100YEAR,
+    RTC_1000YEAR,
+    
+    // ALARM0 registers
+    ALARM0_SEC,
+    ALARM0_10SEC,
+    ALARM0_MIN,
+    ALARM0_10MIN,
+    ALARM0_HOURS,
+    ALARM0_10HOURS,
+    ALARM0_12_n24,
+    ALARM0_WEEKDAY,
+    ALARM0_DATE,
+    ALARM0_10DATE,
+    ALARM0_MONTH,
+    ALARM0_10MONTH,
+    ALARM0_YEAR,
+    ALARM0_10YEAR,
+    ALARM0_100YEAR,
+    ALARM0_1000YEAR,
+    
+    // ALARM1 registers
+    ALARM1_SEC,
+    ALARM1_10SEC,
+    ALARM1_MIN,
+    ALARM1_10MIN,
+    ALARM1_HOURS,
+    ALARM1_10HOURS,
+    ALARM1_12_n24,
+    ALARM1_WEEKDAY,
+    ALARM1_DATE,
+    ALARM1_10DATE,
+    ALARM1_MONTH,
+    ALARM1_10MONTH,
+    ALARM1_YEAR,
+    ALARM1_10YEAR,
+    ALARM1_100YEAR,
+    ALARM1_1000YEAR,
+    
+    // ALARM0_CNTL register
+    ALARM0_CNTL,
+    
+    // ALARM1_CNTL register
+    ALARM1_CNTL,
+    
+    // RTC_STATUS register
+    RTC_STATUS_DIV_OK,       
+    RTC_STATUS_LEAP_OK,      
+    RTC_STATUS_MON_OK,       
+    RTC_STATUS_CARY_OK,      
+    RTC_STATUS_REG_OK,       
+    RTC_STATUS_ALARM0,       
+    RTC_STATUS_ALARM1,       
+    RTC_STATUS_XTAL_FLT,     
+    
+    // RTC_CNTL register
+    RTC_CNTL_ALARM_WP,       
+    RTC_CNTL_RTC_WP,      
+    RTC_CNTL_nTCLKWBB_EN,       
+    RTC_CNTL_nTCLKAP_EN,       
+    RTC_CNTL_nRTC_EN,     
+    
+    // RTC_IRQ register
+    ALARM0_R,       
+    ALARM1_R,       
+    
+    // RTC_IRQ_MASK register
+    ALARM0_R_MASK,       
+    ALARM1_R_MASK,       
+    
+    // MPL_CNTL register
+    EN_MPL,       
+    TIME_MPL, 
+
+    WTSR_SMPL_CNTL_EN_WTSR,
+    WTSR_SMPL_CNTL_EN_SMPL,
+    WTSR_SMPL_CNTL_TIME_SMPL,
+    WTSR_SMPL_CNTL_TIME_WTSR,
+    
+    //========================================================
+    //  T O U C H - S C R E E N / A D C   C O N T R O L L E R
+    //========================================================
+    // TSC_STA_INT register
+    nREF_OK,
+    nCONV_NS,
+    CONV_S,
+    nTS_NS,
+    nTS_S,
+    
+    // TSC_INT_MASK register
+    nCONV_NS_MASK,
+    CONV_S_MASK,
+    nTS_NS_MASK,
+    nTS_S_MASK,
+    
+    // TSC_CNFG1 register
+    PU_100_50,
+    Four_Wire_CNFG,
+    REF_CNFG,
+    
+    // TSC_CNFG2 register
+    RES_X,
+    RES_Y,
+    RES_Z1,
+    RES_Z2,
+    AVG_X,
+    AVG_Y,
+    AVG_Z1,
+    AVG_Z2,
+    
+    // TSC_CNFG3 register
+    T_ACQ_X,
+    T_ACQ_Y,
+    T_ACQ_Z1,
+    T_ACQ_Z2,
+    
+    // TSC_CNFG4 register
+    D_CV_X,
+    D_CV_Y,
+    D_CV_Z1,
+    D_CV_Z2,
+    
+    // TSC_RES_CNFG1 register
+    RES_AUX1,
+    RES_VBUS,
+    RES_VAC,
+    RES_MBATT,
+    RES_BBATT,
+    RES_ICHG,
+    RES_TDIE,
+    RES_AUX2,
+    
+    // TSC_AVG_CNFG1 register
+    AVG_AUX1,
+    AVG_VBUS,
+    AVG_VAC,
+    AVG_MBATT,
+    AVG_BBATT,
+    AVG_ICHG,
+    AVG_TDIE,
+    AVG_AUX2,
+    
+    // TSC_ACQ_CNFG1 register
+    T_ACQ_AUX1,
+    T_ACQ_VBUS,
+    T_ACQ_VAC,
+    T_ACQ_MBATT,
+    
+    // TSC_ACQ_CNFG2 register
+    T_ACQ_BBATT,
+    T_ACQ_ICHG,
+    T_ACQ_TDIE,
+    T_ACQ_AUX2,
+    
+    // TSC_ACQ_CNFG3 register
+    D_CV_AUX1,
+    D_CV_VBUS,
+    D_CV_VAC,
+    D_CV_MBATT,
+    D_CV_BBATT,
+    D_CV_ICHG,
+    D_CV_TDIE,
+    D_CV_AUX2,
+    
+    // ADC_RESULTS register
+    X_MSB,
+    X_LSB,
+    Y_MSB,
+    Y_LSB,
+    Z1_MSB,
+    Z1_LSB,
+    Z2_MSB,
+    Z2_LSB,
+    AUX1_MSB,
+    AUX1_LSB,
+    VBUS_MSB,
+    VBUS_LSB,
+    VAC_MSB,
+    VAC_LSB,
+    MBATT_MSB,
+    MBATT_LSB,
+    BBATT_MSB,
+    BBATT_LSB,
+    ICHG_MSB,
+    ICHG_LSB,
+    TDIE_MSB,
+    TDIE_LSB,
+    AUX2_MSB,
+    AUX2_LSB,
+    
+    // TOUCH-SCREEN CONVERSION COMMAND register
+    X_Drive,
+    X_Measurement,
+    Y_Drive,
+    Y_Measurement,
+    Z1_Drive,
+    Z1_Measurement,
+    Z2_Drive,
+    Z2_Measurement,
+    AUX1_Measurement,
+    VBUS_Measurement,      
+    VAC_Measurement,
+    MBATT_Measurement,
+    BBATT_Measurement,
+    ICHG_Measurement,
+    TDIE_Measurement,
+    AUX2_Measurement,
+    
+    //========================================================
+    //  A U D I O   S U B S Y S T E M
+    //========================================================
+    // PGA_CNTL1 register
+    VOICE_PGA_CNTL_P,
+    VOICE_PGA_CNTL_N,
+    VOICE_IN_CONFIG,
+    IN1_PGA_CNTL,
+    
+    // PGA_CNTL2 register
+    IN2_PGA_CNTL,
+    IN3_PGA_CNTL,
+    IN4_PGA_CNTL,
+    ZDC,
+    
+    // LMIX_CNTL register
+    VOICE_IN_P_LMIX,
+    VOICE_IN_N_LMIX,
+    IN1_LMIX,
+    IN2_LMIX,
+    IN3_LMIX,
+    IN4_LMIX,
+    
+    // RMIX_CNTL register
+    VOICE_IN_P_RMIX,
+    VOICE_IN_N_RMIX,
+    IN1_RMIX,
+    IN2_RMIX,
+    IN3_RMIX,
+    IN4_RMIX,
+    
+    // MMIX_CNTL register
+    MONO_MIX_CNTL,
+    
+    // HS_RIGHT_GAIN_CNTL register
+    RIGHT_HS_GAIN,
+    
+    // HS_LEFT_GAIN_CNTL register
+    LEFT_HS_GAIN,
+    
+    // LINE_OUT_GAIN_CNTL register
+    LINE_OUT_GAIN,
+    
+    // LS_GAIN_CNTL register
+    LS_GAIN,
+    
+    // AUDIO_CNTL register
+    MUTE,
+    AUDIO_SHDN,
+    //LS_BP_EN,
+    AMP_EN_CNTL,
+    CLASS_D_OSC_CNTL,
+    HS_MONO_SW,
+    
+    // AUDIO_ENABLE1 register
+    LS_BP_EN,
+    LS_AMP_EN,
+    LS_LINEOUT_EN,
+    HS_EN,
+    
+    //========================================================
+    //  C H I P   I D E N T I F I C A T I O N
+    //========================================================
+    // II1RR register
+    IIR1,
+    
+    // II2RR register
+    IIR2,
+    
+    //========================================================
+    //  I N T E R R U P T   &   S T A T U S
+    //========================================================
+    // IRQ_STAT register
+    SFT_nTIRQ,
+    SFT_nIRQ,
+        
+    ENDOFPM
+
+} max8906_pm_function_type;
+
+/* MAX8906 each register info */
+typedef const struct {
+    const byte  slave_addr;
+    const byte  addr;
+} max8906_register_type;
+
+typedef struct {
+    max8906_pm_register_type irq_reg;
+    byte    irq_mask;
+} max8906_irq_mask_type;
+
+/* MAX8906 each function info */
+typedef const struct {
+	const byte  slave_addr;
+	const byte  addr;
+	const byte  mask;
+    const byte  clear;
+    const byte  shift;
+} max8906_function_type;
+
+/* IRQ routine */
+typedef struct {
+    byte item_num;
+	max8906_pm_function_type irq_reg;
+    void (*irq_ptr)(void);
+} max8906_irq_table_type;
+
+
+/* MAX8906 each function info */
+typedef const struct {
+    const dword  reg_name;
+    const max8906_pm_function_type active_discharge;
+    const max8906_pm_function_type  ena_src_item;
+    const max8906_pm_function_type  sw_ena_dis;
+} max8906_regulator_name_type;
+
+/* For Touch-Screen Conversion Command Register */
+#define EN_REF 0x04
+#define CONT   0x01
+#define NON_EN_REF_CONT 0x00
+
+typedef struct {
+    word x;
+    word y;
+#ifdef TSC_5_WIRE_MODE
+    word z1;
+    word z2;
+#endif
+} max8906_coordinates_type;
+
+typedef enum {
+    T_Period_20uS = 0,
+    T_Period_40uS,
+    T_Period_80uS,
+    T_Period_160uS,
+    T_Period_320uS,
+    T_Period_640uS,
+    T_Period_1280uS,
+    T_Period_2560uS
+} timer_period_type;
+
+
+//===========================================================================
+// 
+//  MAX8906 RTC Section
+// 
+//===========================================================================
+
+
+typedef enum {
+    TIMEKEEPER = 0,
+    RTC_ALARM0,
+    RTC_ALARM1
+} max8906_rtc_cmd_type;
+
+
+/*===========================================================================
+
+      P O W E R     M A N A G E M E N T     S E C T I O N
+
+===========================================================================*/
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_REG                                
+
+DESCRIPTION
+    This function write the value at the selected register in the PM section.
+
+INPUT PARAMETERS
+    reg_num :   selected register in the register address.
+    value   :   the value for reg_num.
+                This is aligned to the right side of the return value
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+    Set_MAX8906_PM_REG(CHGENB, onoff);
+
+===========================================================================*/
+extern boolean Set_MAX8906_PM_REG(max8906_pm_function_type reg_num, byte value);
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_PM_REG                                
+
+DESCRIPTION
+    This function read the value at the selected register in the PM section.
+
+INPUT PARAMETERS
+    reg_num :   selected register in the register address.
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+    reg_buff :  the value of selected register.
+                reg_buff is aligned to the right side of the return value.
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Get_MAX8906_PM_REG(max8906_pm_function_type reg_num, byte *reg_buff);
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_ADDR                                
+
+DESCRIPTION
+    This function write the value at the selected register address
+    in the PM section.
+
+INPUT PARAMETERS
+    max8906_pm_register_type reg_addr    : the register address.
+    byte *reg_buff   : the array for data of register to write.
+ 	byte length      : the number of the register 
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Set_MAX8906_PM_ADDR(max8906_pm_register_type reg_addr, byte *reg_buff, byte length);
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_PM_ADDR                                
+
+DESCRIPTION
+    This function read the value at the selected register address
+    in the PM section.
+
+INPUT PARAMETERS
+    max8906_pm_register_type reg_addr   : the register address.
+    byte *reg_buff  : the array for data of register to write.
+ 	byte length     : the number of the register 
+
+RETURN VALUE
+    byte *reg_buff : the pointer parameter for data of sequential registers
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Get_MAX8906_PM_ADDR(max8906_pm_register_type reg_addr, byte *reg_buff, byte length);
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_TSC_CONV_REG                                
+
+DESCRIPTION
+    This function write the value at the selected register for Touch-Screen
+    Conversion Command.
+
+INPUT PARAMETERS
+    reg_num :   selected register in the register address.
+    byte cmd   : a data(bit0~2) of register to write.
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Set_MAX8906_TSC_CONV_REG(max8906_pm_function_type reg_num, byte cmd);
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_TSC_CONV_REG
+
+DESCRIPTION
+    This function read the value at the selected register for Touch-Screen
+    Conversion Command.
+
+INPUT PARAMETERS
+    reg_num :   selected register in the register address.
+    byte cmd   : a data(bit0~2) of register to write.
+
+RETURN VALUE
+    byte *reg_buff : the pointer parameter for data of sequential registers
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Get_MAX8906_TSC_CONV_REG(max8906_pm_function_type reg_num, byte *cmd);
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_Regulator_Active_Discharge
+
+DESCRIPTION
+    Enable/Disable Active Discharge for regulators.
+
+INPUT PARAMETERS
+    byte onoff : 0 = Active Discharge Enabled
+                 1 = Active Discharge Disabled
+
+    dword  regulators      : multiple regulators using "OR"
+                             WBBCORE    WBBRF   APPS    IO      MEM     WBBMEM  
+                             WBBIO      WBBANA  RFRXL   RFTXL   RFRXH   RFTCXO  
+                             LDOA       LDOB    LDOC    LDOD    SIMLT   SRAM    
+                             CARD1      CARD2   MVT     BIAS    VBUS    USBTXRX 
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+    Set_MAX8906_PM_Regulator_Active_Discharge( 1, WBBCORE | APPS | MEM | WBBMEM);
+    If you want to select one or a few regulators, please use Set_MAX8906_PM_REG().
+    That is, Set_MAX8906_PM_REG(nWCRADE, 0); // APPS uses SEQ7
+
+===========================================================================*/
+extern boolean Set_MAX8906_PM_Regulator_Active_Discharge(byte onoff, dword regulators);
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_Regulator_ENA_SRC
+
+DESCRIPTION
+    Control Enable source for regulators from Flexible Power Sequence between
+    SEQ1 ~ SEQ7 and software enable.
+
+INPUT PARAMETERS
+    flex_power_seq_type sequencer : selected Sequence number for each regulator
+                                         SEQ1 ~ SEQ7 or SW_CNTL
+
+    dword  regulators      : multiple regulators using "OR"
+                             WBBCORE    WBBRF   APPS    IO      MEM     WBBMEM  
+                             WBBIO      WBBANA  RFRXL   RFTXL   RFRXH   RFTCXO  
+                             LDOA       LDOB    LDOC    LDOD    SIMLT   SRAM    
+                             CARD1      CARD2   MVT     BIAS    VBUS    USBTXRX 
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+    Set_MAX8906_PM_Regulator_ENA_SRC( SEQ1, WBBCORE | APPS | MEM | WBBMEM);
+    If you want to select one or a few regulators, please use Set_MAX8906_PM_REG().
+    That is, Set_MAX8906_PM_REG(APPSENSRC, 0x06); // APPS uses SEQ7
+
+===========================================================================*/
+extern boolean Set_MAX8906_PM_Regulator_ENA_SRC(flex_power_seq_type sequencer, dword regulators);
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_Regulator_SW_Enable
+
+DESCRIPTION
+    Enable/Disable Active Discharge for regulators.
+
+INPUT PARAMETERS
+    byte onoff : 
+                 0 = Disabled
+                 1 = Enabled
+
+    dword  regulators      : multiple regulators using "OR"
+                             WBBCORE    WBBRF   APPS    IO      MEM     WBBMEM  
+                             WBBIO      WBBANA  RFRXL   RFTXL   RFRXH   RFTCXO  
+                             LDOA       LDOB    LDOC    LDOD    SIMLT   SRAM    
+                             CARD1      CARD2   MVT     BIAS    VBUS    USBTXRX 
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+    Set_MAX8906_PM_Regulator_Active_Discharge( 1, WBBCORE | APPS | MEM | WBBMEM);
+    If you want to select one or a few regulators, please use Set_MAX8906_PM_REG().
+    That is, Set_MAX8906_PM_REG(nWCRADE, 0); // APPS uses SEQ7
+
+===========================================================================*/
+extern boolean Set_MAX8906_PM_Regulator_SW_Enable(byte onoff, dword regulators);
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_PWR_SEQ_Timer_Period
+
+DESCRIPTION
+    Control the Timer Period between each sequencer event for Flexible Power
+    Sequencer.
+
+INPUT PARAMETERS
+    max8906_pm_function_type cntl_item : selected Sequence number for Timer Period
+                                         SEQ1T ~ SEQ7T
+
+    timer_period_type  value           : T_Period_20uS
+                                         T_Period_40uS
+                                         T_Period_80uS
+                                         T_Period_160uS
+                                         T_Period_320uS
+                                         T_Period_640uS
+                                         T_Period_1280uS
+                                         T_Period_2560uS
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Set_MAX8906_PM_PWR_SEQ_Timer_Period(max8906_pm_function_type cntl_item, timer_period_type value);
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_PM_PWR_SEQ_Timer_Period
+
+DESCRIPTION
+    Read the Timer Period between each sequencer event for Flexible Power
+    Sequencer.
+
+INPUT PARAMETERS
+    max8906_pm_function_type cntl_item : selected Sequence number for Timer Period
+                                         SEQ1T, SEQ2T, SEQ3T, SEQ4T,
+                                         SEQ5T, SEQ6T, SEQ7T
+
+RETURN VALUE
+    timer_period_type  value           : T_Period_20uS
+                                         T_Period_40uS
+                                         T_Period_80uS
+                                         T_Period_160uS
+                                         T_Period_320uS
+                                         T_Period_640uS
+                                         T_Period_1280uS
+                                         T_Period_2560uS
+
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Get_MAX8906_PM_PWR_SEQ_Timer_Period(max8906_pm_function_type cntl_item, timer_period_type *value);
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_PWR_SEQ_Ena_Src
+
+DESCRIPTION
+    Control the enable source for Flexible Power Sequencer.
+
+INPUT PARAMETERS
+    max8906_pm_function_type cntl_item : selected Sequence number for enable source
+                                         SEQ1SRC, SEQ2SRC, SEQ3SRC, SEQ4SRC, 
+                                         SEQ5SRC, SEQ6SRC, SEQ7SRC
+
+    byte value                         : 
+                            SEQ1SRC = 0 : SYSEN hardware input
+                                      1 : PWREN hardware input
+                                      2 : SEQ1EN software bit
+                                         
+                            SEQ2SRC = 0 : PWREN hardware input
+                                      1 : SYSEN hardware input
+                                      2 : SEQ2EN software bit
+                                         
+                            SEQ3SRC = 0 : WBBEN hardware input
+                                      1 : reserved
+                                      2 : SEQ3EN software bit
+                                         
+                            SEQ4SRC = 0 : TCXOEN hardware input
+                                      1 : reserved
+                                      2 : SEQ4EN software bit
+                                         
+                            SEQ5SRC = 0 : RFRXEN hardware input
+                                      1 : reserved
+                                      2 : SEQ5EN software bit
+                                         
+                            SEQ6SRC = 0 : RFTXEN hardware input
+                                      1 : reserved
+                                      2 : SEQ6EN software bit
+                                         
+                            SEQ7SRC = 0 : ENA hardware input
+                                      1 : reserved
+                                      2 : SEQ7EN software bit
+                                         
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Set_MAX8906_PM_PWR_SEQ_Ena_Src(max8906_pm_function_type cntl_item, byte value);
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_PM_PWR_SEQ_Ena_Src
+
+DESCRIPTION
+    Read the enable source for Flexible Power Sequencer.
+
+INPUT PARAMETERS
+    max8906_pm_function_type cntl_item : selected Sequence number for enable source
+                                         SEQ1SRC, SEQ2SRC, SEQ3SRC, SEQ4SRC, 
+                                         SEQ5SRC, SEQ6SRC, SEQ7SRC
+
+RETURN VALUE
+    byte value                         : 
+                            SEQ1SRC = 0 : SYSEN hardware input
+                                      1 : PWREN hardware input
+                                      2 : SEQ1EN software bit
+                                         
+                            SEQ2SRC = 0 : PWREN hardware input
+                                      1 : SYSEN hardware input
+                                      2 : SEQ2EN software bit
+                                         
+                            SEQ3SRC = 0 : WBBEN hardware input
+                                      1 : reserved
+                                      2 : SEQ3EN software bit
+                                         
+                            SEQ4SRC = 0 : TCXOEN hardware input
+                                      1 : reserved
+                                      2 : SEQ4EN software bit
+                                         
+                            SEQ5SRC = 0 : RFRXEN hardware input
+                                      1 : reserved
+                                      2 : SEQ5EN software bit
+                                         
+                            SEQ6SRC = 0 : RFTXEN hardware input
+                                      1 : reserved
+                                      2 : SEQ6EN software bit
+                                         
+                            SEQ7SRC = 0 : ENA hardware input
+                                      1 : reserved
+                                      2 : SEQ7EN software bit
+
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Get_MAX8906_PM_PWR_SEQ_Ena_Src(max8906_pm_function_type cntl_item, byte *value);
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_PWR_SEQ_SW_Enable
+
+DESCRIPTION
+    Control the enable source for Flexible Power Sequencer.
+
+INPUT PARAMETERS
+    max8906_pm_function_type cntl_item : selected Sequence number for enable source
+                                         SEQ1EN, SEQ2EN, SEQ3EN, SEQ4EN, 
+                                         SEQ5EN, SEQ6EN, SEQ7EN
+
+    byte value :       0 = Disable regulators
+                       1 = Enable regulators
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Set_MAX8906_PM_PWR_SEQ_SW_Enable(max8906_pm_function_type cntl_item, byte value);
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_PM_PWR_SEQ_SW_Enable
+
+DESCRIPTION
+    Read the enable source for Flexible Power Sequencer.
+
+INPUT PARAMETERS
+    max8906_pm_function_type cntl_item : selected Sequence number for enable source
+                                         SEQ1EN, SEQ2EN, SEQ3EN, SEQ4EN, 
+                                         SEQ5EN, SEQ6EN, SEQ7EN
+
+
+RETURN VALUE
+    byte value :       0 = Disable regulators
+                       1 = Enable regulators
+
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+
+===========================================================================*/
+extern boolean Get_MAX8906_PM_PWR_SEQ_SW_Enable(max8906_pm_function_type cntl_item, byte *value);
+
+/*===========================================================================
+ T O U C H   S C R E E N
+===========================================================================*/
+extern void Set_MAX8906_PM_TSC_init(void);
+
+extern void Set_MAX8906_PM_TSC_detect_isr(void);
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_TSC_measurement
+
+DESCRIPTION
+    Read x, y, z1, and z2 coordinates for Touch_Screen.
+    (z1 and z2 is used for 5-wire mode.)
+
+INPUT PARAMETERS
+
+RETURN VALUE
+    tsc_coordinates : return value for inserting x, y, z1, and z2 coordinates
+
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+
+===========================================================================*/
+extern boolean Set_MAX8906_TSC_measurement(max8906_coordinates_type *tsc_coordinates);
+
+
+/*===========================================================================
+
+      R T C     S E C T I O N
+
+===========================================================================*/
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_RTC                                
+
+DESCRIPTION
+    This function write the value at the selected register address
+    in the RTC section.
+
+INPUT PARAMETERS
+    max8906_rtc_cmd_type :     RTC_TIME   = timekeeper register 0x0~0x3
+                               RTC_ALARM  = alarm register 0x8~0xB
+
+    byte* max8906_rtc_ptr : the write value for registers.
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Set_MAX8906_RTC(max8906_rtc_cmd_type rtc_cmd,byte *max8906_rtc_ptr);
+
+/*===========================================================================
+
+FUNCTION Get_MAX8906_RTC                                
+
+DESCRIPTION
+    This function read the value at the selected register address
+    in the RTC section.
+
+INPUT PARAMETERS
+    max8906_rtc_cmd_type :     RTC_TIME   = timekeeper register 0x0~0x3
+                               RTC_ALARM  = alarm register 0x8~0xB
+
+    byte* max8906_rtc_ptr : the return value for registers.
+
+RETURN VALUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Get_MAX8906_RTC(max8906_rtc_cmd_type rtc_cmd, byte *max8906_rtc_ptr);
+
+
+/*===========================================================================
+
+      I R Q    R O U T I N E
+
+===========================================================================*/
+/*===========================================================================
+
+FUNCTION MAX8906_IRQ_init                                
+
+DESCRIPTION
+    Initialize the IRQ Mask register for the IRQ handler.
+
+INPUT PARAMETERS
+
+RETURN VALUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern void MAX8906_IRQ_init(void);
+
+/*===========================================================================
+
+FUNCTION Set_MAX8906_PM_IRQ                                
+
+DESCRIPTION
+    When some irq mask is changed, this function can be used.
+    If you send max8906_isr as null(0) point, it means that the irq is masked.
+    If max8906_isr points some functions, it means that the irq is unmasked.
+
+INPUT PARAMETERS
+    irq_name                   : IRQ Mask register number
+    void (*max8906_isr)(void) : If irq is happened, then this routine is running.
+
+RETURN VALUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern boolean Set_MAX8906_PM_IRQ(max8906_irq_type irq_name, void (*max8906_isr)(void));
+
+/*===========================================================================
+
+FUNCTION MAX8906_PM_IRQ_isr                                
+
+DESCRIPTION
+    When nIRQ pin is asserted, this isr routine check the irq bit and then
+    proper function is called.
+    Irq register can be set although irq is masked.
+    So, the isr routine shoud check the irq mask bit, too.
+
+INPUT PARAMETERS
+
+RETURN VALUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern void MAX8906_PM_IRQ_isr(void);
+
+/*===========================================================================
+
+FUNCTION MAX8906_PM_TIRQ_isr                                
+
+DESCRIPTION
+    When nTIRQ pin is asserted for Touch-Screen, this isr routine check the irq bit and then
+    proper function is called.
+    Irq register can be set although irq is masked.
+    So, the isr routine shoud check the irq mask bit, too.
+
+INPUT PARAMETERS
+
+RETURN VALUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern void MAX8906_PM_TIRQ_isr(void);
+
+
+/*===========================================================================
+
+      I N I T    R O U T I N E
+
+===========================================================================*/
+/*===========================================================================
+
+FUNCTION MAX8906_PM_init
+
+DESCRIPTION
+    When power up, MAX8906_PM_init will initialize the MAX8906 for each part
+
+INPUT PARAMETERS
+
+RETURN VALUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+extern void MAX8906_PM_init(void);
+
+#endif
+
diff -Nur linux-2.6.29/include/linux/i2c/maximi2c.h linux-2.6.29-spica/include/linux/i2c/maximi2c.h
--- linux-2.6.29/include/linux/i2c/maximi2c.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/i2c/maximi2c.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,118 @@
+#if defined (CONFIG_PMIC_MAX8906)
+#include <linux/i2c/max8906.h>
+#elif defined (CONFIG_PMIC_MAX8698)
+#include <linux/i2c/max8698.h>
+#endif
+
+
+typedef enum
+{
+  PMIC_PASS = 0,
+  /* Operation was successful */
+  PMIC_FAIL
+  /* Write operation failed */
+} pmic_status_type;
+
+
+typedef word pmic_err_flag_type;
+
+/*===========================================================================
+
+FUNCTION pmic_write                                
+
+DESCRIPTION
+    It does the following: When we need to write a specific register in Power management section, This is used.
+INPUT PARAMETERS
+    byte slave_addr : slave address
+ 	byte reg : Register address 
+ 	byte data : data 
+ 	byte length : the number of the register 
+RETURN VALUE
+	PMIC_PASS : Operation was successful
+	PMIC_FAIL : Write operation failed
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+    slave_addr = 0x8E;
+	reg = ONOFF1_ADDR;
+	pmic_onoff_buf[i] = (( pmic_onoff_buf[i] & ~(mask))|(mask & data));
+	
+	if (pmic_write(slave_addr, reg, &pmic_onoff_buf[i], 1) != PMIC_PASS) {
+		MSG_HIGH("Write Vreg control failed, reg 0x%x", reg, 0, 0);
+	}
+===========================================================================*/
+extern pmic_status_type pmic_write(byte slave_addr, byte reg, byte *data, byte length);
+
+
+/*===========================================================================
+
+FUNCTION pmic_read                                
+
+DESCRIPTION
+    It does the following: When we need to read a specific register in Power management section, This is used
+INPUT PARAMETERS
+    byte slave_addr : slave address
+ 	byte reg : Register address 
+ 	byte data : data 
+ 	byte length : the number of the register 
+RETURN VALUE
+	PMIC_PASS : Operation was successful
+	PMIC_FAIL : Read operation failed
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+    slave_addr = 0x8E;
+	if (pmic_read(slave_addr, IRQ1_ADDR, &irq1_reg, 1) != PMIC_PASS) {
+		MSG_HIGH("Write Vreg control failed, reg 0x%x", reg, 0, 0);
+	}
+===========================================================================*/
+extern pmic_status_type pmic_read(byte slave_addr, byte reg, byte *data, byte length);
+
+
+/*===========================================================================
+
+FUNCTION pmic_tsc_write                                
+
+DESCRIPTION
+    It does the following: When we need to write a specific register in Power management section, This is used.
+INPUT PARAMETERS
+    byte slave_addr : slave address
+ 	byte cmd : data with cmd bit ( data = [2:0], cmd = [7:3] )
+RETURN VALUE
+	PMIC_PASS : Operation was successful
+	PMIC_FAIL : Write operation failed
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+	cmd = X_DRIVE | 0x01; // enable CONT
+	
+	if (pmic_tsc_write(slave_addr, &cmd) != PMIC_PASS) {
+		MSG_HIGH("Write TSC command failed, reg 0x%x", reg, 0, 0);
+	}
+===========================================================================*/
+extern pmic_status_type pmic_tsc_write(byte slave_addr, byte *cmd);
+
+
+/*===========================================================================
+
+FUNCTION pmic_tsc_read                                
+
+DESCRIPTION
+    It does the following: When we need to read a specific register in Power management section, This is used
+INPUT PARAMETERS
+    byte slave_addr : slave address
+ 	byte cmd : data with cmd bit ( data = [2:0], cmd = [7:3] )
+RETURN VALUE
+	PMIC_PASS : Operation was successful
+	PMIC_FAIL : Read operation failed
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+	if (pmic_read(X_DRIVE, &cmd) != PMIC_PASS) {
+		MSG_HIGH("Read TSC command failed, reg 0x%x", reg, 0, 0);
+	}
+===========================================================================*/
+extern pmic_status_type pmic_tsc_read(byte slave_addr, byte *cmd);
+
+
+
diff -Nur linux-2.6.29/include/linux/i2c/pmic.h linux-2.6.29-spica/include/linux/i2c/pmic.h
--- linux-2.6.29/include/linux/i2c/pmic.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/i2c/pmic.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,41 @@
+#ifndef __LINUX_PMIC_H
+#define __LINUX_PMIC_H
+
+#if defined (CONFIG_PMIC_MAX8906)
+#include <linux/i2c/max8906.h>
+#elif defined (CONFIG_PMIC_MAX8698)
+#include <linux/i2c/max8698.h>
+#endif
+
+/*===========================================================================
+
+FUNCTION set_pmic
+
+DESCRIPTION
+    This function turn on / off block power or change voltage
+    in the PM section.
+
+INPUT PARAMETERS
+    max8698_pm_type pm_type   : type of power control.
+    int value	: value for changing state
+
+RETURN VALUE
+    boolean : 0 = FALSE
+              1 = TRUE
+
+DEPENDENCIES
+SIDE EFFECTS
+EXAMPLE 
+
+===========================================================================*/
+
+typedef enum {
+	VCC_ARM,
+	VCC_INT,
+	ENDOFPMTYPE
+} pmic_pm_type;
+
+extern boolean set_pmic(pmic_pm_type pm_type, int value);
+extern boolean get_pmic(pmic_pm_type pm_type, int *value);
+
+#endif /* __LINUX_PMIC_H */
diff -Nur linux-2.6.29/include/linux/if_pppolac.h linux-2.6.29-spica/include/linux/if_pppolac.h
--- linux-2.6.29/include/linux/if_pppolac.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/if_pppolac.h	2010-03-30 11:01:37.000000000 +0700
@@ -0,0 +1,35 @@
+/* include/linux/if_pppolac.h
+ *
+ * Header for PPP on L2TP Access Concentrator / PPPoLAC Socket (RFC 2661)
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Author: Chia-chi Yeh <chiachi@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_IF_PPPOLAC_H
+#define __LINUX_IF_PPPOLAC_H
+
+#include <linux/socket.h>
+#include <linux/types.h>
+
+#define PX_PROTO_OLAC	2
+
+struct sockaddr_pppolac {
+	sa_family_t	sa_family;	/* AF_PPPOX */
+	unsigned int	sa_protocol;	/* PX_PROTO_OLAC */
+	int		udp_socket;
+	struct __attribute__((packed)) {
+		__u16	tunnel, session;
+	} local, remote;
+} __attribute__((packed));
+
+#endif /* __LINUX_IF_PPPOLAC_H */
diff -Nur linux-2.6.29/include/linux/if_pppopns.h linux-2.6.29-spica/include/linux/if_pppopns.h
--- linux-2.6.29/include/linux/if_pppopns.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/if_pppopns.h	2010-03-30 11:01:35.000000000 +0700
@@ -0,0 +1,34 @@
+/* include/linux/if_pppopns.h
+ *
+ * Header for PPP on PPTP Network Server / PPPoPNS Socket (RFC 2637)
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Author: Chia-chi Yeh <chiachi@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_IF_PPPOPNS_H
+#define __LINUX_IF_PPPOPNS_H
+
+#include <linux/socket.h>
+#include <linux/types.h>
+
+#define PX_PROTO_OPNS	3
+
+struct sockaddr_pppopns {
+	sa_family_t	sa_family;	/* AF_PPPOX */
+	unsigned int	sa_protocol;	/* PX_PROTO_OPNS */
+	int		tcp_socket;
+	__u16		local;
+	__u16		remote;
+} __attribute__((packed));
+
+#endif /* __LINUX_IF_PPPOPNS_H */
diff -Nur linux-2.6.29/include/linux/if_pppox.h linux-2.6.29-spica/include/linux/if_pppox.h
--- linux-2.6.29/include/linux/if_pppox.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/if_pppox.h	2010-03-30 11:01:33.000000000 +0700
@@ -27,6 +27,8 @@
 #include <linux/ppp_channel.h>
 #endif /* __KERNEL__ */
 #include <linux/if_pppol2tp.h>
+#include <linux/if_pppolac.h>
+#include <linux/if_pppopns.h>
 
 /* For user-space programs to pick up these definitions
  * which they wouldn't get otherwise without defining __KERNEL__
@@ -51,7 +53,9 @@
  */ 
 #define PX_PROTO_OE    0 /* Currently just PPPoE */
 #define PX_PROTO_OL2TP 1 /* Now L2TP also */
-#define PX_MAX_PROTO   2
+#define PX_PROTO_OLAC  2
+#define PX_PROTO_OPNS  3
+#define PX_MAX_PROTO   4
 
 struct sockaddr_pppox { 
        sa_family_t     sa_family;            /* address family, AF_PPPOX */ 
@@ -141,6 +145,19 @@
 					     relayed to (PPPoE relaying) */
 };
 
+struct pppolac_opt {
+	__u32	local;
+	__u32	remote;
+	__u16	sequence;
+	__u8	sequencing;
+};
+
+struct pppopns_opt {
+	__u16	local;
+	__u16	remote;
+	__u32	sequence;
+};
+
 #include <net/sock.h>
 
 struct pppox_sock {
@@ -150,6 +167,8 @@
 	struct pppox_sock	*next;	  /* for hash table */
 	union {
 		struct pppoe_opt pppoe;
+		struct pppolac_opt lac;
+		struct pppopns_opt pns;
 	} proto;
 	__be16			num;
 };
diff -Nur linux-2.6.29/include/linux/input.h linux-2.6.29-spica/include/linux/input.h
--- linux-2.6.29/include/linux/input.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/input.h	2010-03-30 11:01:36.000000000 +0700
@@ -106,6 +106,7 @@
 
 #define SYN_REPORT		0
 #define SYN_CONFIG		1
+#define SYN_MT_REPORT		2
 
 /*
  * Keys and buttons
@@ -644,6 +645,17 @@
 #define ABS_TOOL_WIDTH		0x1c
 #define ABS_VOLUME		0x20
 #define ABS_MISC		0x28
+
+#define ABS_MT_TOUCH_MAJOR	0x30	/* Major axis of touching ellipse */
+#define ABS_MT_TOUCH_MINOR	0x31	/* Minor axis (omit if circular) */
+#define ABS_MT_WIDTH_MAJOR	0x32	/* Major axis of approaching ellipse */
+#define ABS_MT_WIDTH_MINOR	0x33	/* Minor axis (omit if circular) */
+#define ABS_MT_ORIENTATION	0x34	/* Ellipse orientation */
+#define ABS_MT_POSITION_X	0x35	/* Center X ellipse position */
+#define ABS_MT_POSITION_Y	0x36	/* Center Y ellipse position */
+#define ABS_MT_TOOL_TYPE	0x37	/* Type of touching device */
+#define ABS_MT_BLOB_ID		0x38	/* Group a set of packets as a blob */
+
 #define ABS_MAX			0x3f
 #define ABS_CNT			(ABS_MAX+1)
 
@@ -742,6 +754,12 @@
 #define BUS_ATARI		0x1B
 
 /*
+ * MT_TOOL types
+ */
+#define MT_TOOL_FINGER		0
+#define MT_TOOL_PEN		1
+
+/*
  * Values describing the status of a force-feedback effect
  */
 #define FF_STATUS_STOPPED	0x00
@@ -1310,6 +1328,11 @@
 	input_event(dev, EV_SYN, SYN_REPORT, 0);
 }
 
+static inline void input_mt_sync(struct input_dev *dev)
+{
+	input_event(dev, EV_SYN, SYN_MT_REPORT, 0);
+}
+
 void input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code);
 
 static inline void input_set_abs_params(struct input_dev *dev, int axis, int min, int max, int fuzz, int flat)
diff -Nur linux-2.6.29/include/linux/kernel_debugger.h linux-2.6.29-spica/include/linux/kernel_debugger.h
--- linux-2.6.29/include/linux/kernel_debugger.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/kernel_debugger.h	2010-03-30 11:01:35.000000000 +0700
@@ -0,0 +1,41 @@
+/*
+ * include/linux/kernel_debugger.h
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _LINUX_KERNEL_DEBUGGER_H_
+#define _LINUX_KERNEL_DEBUGGER_H_
+
+struct kdbg_ctxt {
+	int (*printf)(void *cookie, const char *fmt, ...);
+	void *cookie;
+};
+
+/* kernel_debugger() is called from IRQ context and should
+ * use the kdbg_ctxt.printf to write output (do NOT call
+ * printk, do operations not safe from IRQ context, etc).
+ *
+ * kdbg_ctxt.printf will return -1 if there is not enough
+ * buffer space or if you are being aborted.  In this case
+ * you must return as soon as possible.
+ *
+ * Return non-zero if more data is available -- if buffer
+ * space ran and you had to stop, but could print more,
+ * for example.
+ *
+ * Additional calls where cmd is "more" will be made if
+ * the additional data is desired.
+ */
+int kernel_debugger(struct kdbg_ctxt *ctxt, char *cmd);
+
+#endif
diff -Nur linux-2.6.29/include/linux/keychord.h linux-2.6.29-spica/include/linux/keychord.h
--- linux-2.6.29/include/linux/keychord.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/keychord.h	2010-03-30 11:01:36.000000000 +0700
@@ -0,0 +1,52 @@
+/*
+ *  Key chord input driver
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#ifndef __LINUX_KEYCHORD_H_
+#define __LINUX_KEYCHORD_H_
+
+#include <linux/input.h>
+
+#define KEYCHORD_VERSION		1
+
+/*
+ * One or more input_keychord structs are written to /dev/keychord
+ * at once to specify the list of keychords to monitor.
+ * Reading /dev/keychord returns the id of a keychord when the
+ * keychord combination is pressed.  A keychord is signalled when
+ * all of the keys in the keycode list are in the pressed state.
+ * The order in which the keys are pressed does not matter.
+ * The keychord will not be signalled if keys not in the keycode
+ * list are pressed.
+ * Keychords will not be signalled on key release events.
+ */
+struct input_keychord {
+	/* should be KEYCHORD_VERSION */
+	__u16 version;
+	/*
+	 * client specified ID, returned from read()
+	 * when this keychord is pressed.
+	 */
+	__u16 id;
+
+	/* number of keycodes in this keychord */
+	__u16 count;
+
+	/* variable length array of keycodes */
+	__u16 keycodes[];
+};
+
+#endif	/* __LINUX_KEYCHORD_H_ */
diff -Nur linux-2.6.29/include/linux/keyreset.h linux-2.6.29-spica/include/linux/keyreset.h
--- linux-2.6.29/include/linux/keyreset.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/keyreset.h	2010-03-30 11:01:34.000000000 +0700
@@ -0,0 +1,27 @@
+/*
+ * include/linux/keyreset.h - platform data structure for resetkeys driver
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_KEYRESET_H
+#define _LINUX_KEYRESET_H
+
+#define KEYRESET_NAME "keyreset"
+
+struct keyreset_platform_data {
+	int *keys_up;
+	int keys_down[]; /* 0 terminated */
+};
+
+#endif /* _LINUX_KEYRESET_H */
diff -Nur linux-2.6.29/include/linux/mmc/card.h linux-2.6.29-spica/include/linux/mmc/card.h
--- linux-2.6.29/include/linux/mmc/card.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/mmc/card.h	2010-05-06 12:42:45.684270633 +0700
@@ -12,6 +12,14 @@
 
 #include <linux/mmc/core.h>
 
+// TODO-JJ
+struct mmc_card_pm {
+ int (*suspend) (void);
+ int (*resume) (void);
+};
+
+
+
 struct mmc_cid {
 	unsigned int		manfid;
 	char			prod_name[8];
diff -Nur linux-2.6.29/include/linux/mmc/host.h linux-2.6.29-spica/include/linux/mmc/host.h
--- linux-2.6.29/include/linux/mmc/host.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/mmc/host.h	2010-05-06 12:42:45.684270633 +0700
@@ -118,6 +118,8 @@
 #define MMC_CAP_SPI		(1 << 4)	/* Talks only SPI protocols */
 #define MMC_CAP_NEEDS_POLL	(1 << 5)	/* Needs polling for card-detection */
 #define MMC_CAP_8_BIT_DATA	(1 << 6)	/* Can the host do 8 bit transfers */
+#define MMC_CAP_ON_BOARD	(1 << 7)	/* Do not need to rescan after bootup */
+#define MMC_CAP_BOOT_ONTHEFLY	(1 << 8)	/* Can detect device at boot time */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
@@ -151,6 +153,10 @@
 	const struct mmc_bus_ops *bus_ops;	/* current bus driver */
 	unsigned int		bus_refs;	/* reference counter */
 
+	unsigned int		bus_resume_flags;
+#define MMC_BUSRESUME_MANUAL_RESUME	(1 << 0)
+#define MMC_BUSRESUME_NEEDS_RESUME	(1 << 1)
+
 	unsigned int		sdio_irqs;
 	struct task_struct	*sdio_irq_thread;
 	atomic_t		sdio_irq_thread_abort;
@@ -161,6 +167,15 @@
 
 	struct dentry		*debugfs_root;
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	struct {
+		struct sdio_cis			*cis;
+		struct sdio_cccr		*cccr;
+		struct sdio_embedded_func	*funcs;
+		int				num_funcs;
+	} embedded_sdio_data;
+#endif
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 
@@ -169,6 +184,14 @@
 extern void mmc_remove_host(struct mmc_host *);
 extern void mmc_free_host(struct mmc_host *);
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+extern void mmc_set_embedded_sdio_data(struct mmc_host *host,
+				       struct sdio_cis *cis,
+				       struct sdio_cccr *cccr,
+				       struct sdio_embedded_func *funcs,
+				       int num_funcs);
+#endif
+
 static inline void *mmc_priv(struct mmc_host *host)
 {
 	return (void *)host->private;
@@ -179,6 +202,17 @@
 #define mmc_dev(x)	((x)->parent)
 #define mmc_classdev(x)	(&(x)->class_dev)
 #define mmc_hostname(x)	(dev_name(&(x)->class_dev))
+#define mmc_bus_needs_resume(host) ((host)->bus_resume_flags & MMC_BUSRESUME_NEEDS_RESUME)
+
+static inline void mmc_set_bus_resume_policy(struct mmc_host *host, int manual)
+{
+	if (manual)
+		host->bus_resume_flags |= MMC_BUSRESUME_MANUAL_RESUME;
+	else
+		host->bus_resume_flags &= ~MMC_BUSRESUME_MANUAL_RESUME;
+}
+
+extern int mmc_resume_bus(struct mmc_host *host);
 
 extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
 extern int mmc_resume_host(struct mmc_host *);
diff -Nur linux-2.6.29/include/linux/mmc/sdio_func.h linux-2.6.29-spica/include/linux/mmc/sdio_func.h
--- linux-2.6.29/include/linux/mmc/sdio_func.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/mmc/sdio_func.h	2010-03-30 11:01:36.000000000 +0700
@@ -21,6 +21,14 @@
 typedef void (sdio_irq_handler_t)(struct sdio_func *);
 
 /*
+ * Structure used to hold embedded SDIO device data from platform layer
+ */
+struct sdio_embedded_func {
+	uint8_t f_class;
+	uint32_t f_maxblksize;
+};
+
+/*
  * SDIO function CIS tuple (unknown to the core)
  */
 struct sdio_func_tuple {
@@ -125,6 +133,8 @@
 extern unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz);
 
 extern u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret);
+extern u8 sdio_readb_ext(struct sdio_func *func, unsigned int addr, int *err_ret,
+	unsigned in);
 extern u16 sdio_readw(struct sdio_func *func, unsigned int addr, int *err_ret);
 extern u32 sdio_readl(struct sdio_func *func, unsigned int addr, int *err_ret);
 
diff -Nur linux-2.6.29/include/linux/mm.h linux-2.6.29-spica/include/linux/mm.h
--- linux-2.6.29/include/linux/mm.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/mm.h	2010-03-30 11:01:34.000000000 +0700
@@ -578,12 +578,10 @@
  */
 static inline unsigned long round_hint_to_min(unsigned long hint)
 {
-#ifdef CONFIG_SECURITY
 	hint &= PAGE_MASK;
 	if (((void *)hint != NULL) &&
 	    (hint < mmap_min_addr))
 		return PAGE_ALIGN(mmap_min_addr);
-#endif
 	return hint;
 }
 
@@ -724,8 +722,9 @@
 	return 0;
 }
 #endif
-struct file *shmem_file_setup(char *name, loff_t size, unsigned long flags);
 
+struct file *shmem_file_setup(char *name, loff_t size, unsigned long flags);
+void shmem_set_file(struct vm_area_struct *vma, struct file *file);
 int shmem_zero_setup(struct vm_area_struct *);
 
 #ifndef CONFIG_MMU
diff -Nur linux-2.6.29/include/linux/msdos_fs.h linux-2.6.29-spica/include/linux/msdos_fs.h
--- linux-2.6.29/include/linux/msdos_fs.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/msdos_fs.h	2010-03-30 11:01:37.000000000 +0700
@@ -100,6 +100,7 @@
 /* <linux/videotext.h> has used 0x72 ('r') in collision, so skip a few */
 #define FAT_IOCTL_GET_ATTRIBUTES	_IOR('r', 0x10, __u32)
 #define FAT_IOCTL_SET_ATTRIBUTES	_IOW('r', 0x11, __u32)
+#define VFAT_IOCTL_GET_VOLUME_ID	_IOR('r', 0x12, __u32)
 
 struct fat_boot_sector {
 	__u8	ignored[3];	/* Boot strap short or near jump */
@@ -137,6 +138,17 @@
 	__le32   reserved2[4];
 };
 
+struct fat_boot_bsx {
+	__u8     drive;		    /* drive number */
+	__u8     reserved1;
+	__u8     signature;	    /* extended boot signature */
+	__u8     vol_id[4];     /* volume ID */
+	__u8     vol_label[11]; /* volume label */
+	__u8     type[8];       /* file system type */
+};
+#define FAT16_BSX_OFFSET	36 /* offset of fat_boot_bsx in FAT12 and FAT16 */
+#define FAT32_BSX_OFFSET	64 /* offset of fat_boot_bsx in FAT32 */
+
 struct msdos_dir_entry {
 	__u8	name[MSDOS_NAME];/* name and extension */
 	__u8	attr;		/* attribute bits */
diff -Nur linux-2.6.29/include/linux/personality.h linux-2.6.29-spica/include/linux/personality.h
--- linux-2.6.29/include/linux/personality.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/personality.h	2010-03-30 11:01:34.000000000 +0700
@@ -40,7 +40,10 @@
  * Security-relevant compatibility flags that must be
  * cleared upon setuid or setgid exec:
  */
-#define PER_CLEAR_ON_SETID (READ_IMPLIES_EXEC|ADDR_NO_RANDOMIZE)
+#define PER_CLEAR_ON_SETID (READ_IMPLIES_EXEC  | \
+			    ADDR_NO_RANDOMIZE  | \
+			    ADDR_COMPAT_LAYOUT | \
+			    MMAP_PAGE_ZERO)
 
 /*
  * Personality types.
diff -Nur linux-2.6.29/include/linux/rfs_fs.h linux-2.6.29-spica/include/linux/rfs_fs.h
--- linux-2.6.29/include/linux/rfs_fs.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/rfs_fs.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,686 @@
+/*
+ *---------------------------------------------------------------------------*
+ *                                                                           *
+ *          COPYRIGHT 2003-2009 SAMSUNG ELECTRONICS CO., LTD.                *
+ *                          ALL RIGHTS RESERVED                              *
+ *                                                                           *
+ *   Permission is hereby granted to licensees of Samsung Electronics        *
+ *   Co., Ltd. products to use or abstract this computer program only in     *
+ *   accordance with the terms of the NAND FLASH MEMORY SOFTWARE LICENSE     *
+ *   AGREEMENT for the sole purpose of implementing a product based on       *
+ *   Samsung Electronics Co., Ltd. products. No other rights to reproduce,   *
+ *   use, or disseminate this computer program, whether in part or in        *
+ *   whole, are granted.                                                     *
+ *                                                                           *
+ *   Samsung Electronics Co., Ltd. makes no representation or warranties     *
+ *   with respect to the performance of this computer program, and           *
+ *   specifically disclaims any responsibility for any damages,              *
+ *   special or consequential, connected with the use of this program.       *
+ *                                                                           *
+ *---------------------------------------------------------------------------*
+*/
+/**
+ *  @version	RFS_1.3.1_b072_RTM
+ *  @file	include/linux/rfs_fs.h
+ *  @brief	common header file for RFS
+ *
+ *
+ */
+  
+#ifndef _LINUX_RFS_FS_H
+#define _LINUX_RFS_FS_H
+
+#ifdef XATTR_USER_PREFIX
+#error
+#endif
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+#include <linux/buffer_head.h>
+#include <linux/rfs_fs_i.h>
+#include <linux/rfs_fs_sb.h>
+#else
+#include <linux/locks.h>
+#endif
+#include <linux/byteorder/generic.h>
+
+/*
+ * Constant and Macro definition
+ */
+#define ROOT_INO		1
+#define ROOT_CLU		(0)
+
+#define RFS_MAGIC               (0x2003BAB1L)
+
+#define MAX_NUMERIC	32768 /* 32768 covers 2GB directory */
+
+#define	DOS_NAME_LENGTH		11
+#define EXT_UNAME_LENGTH	13
+#define SHORT_NAME_LENGTH	8
+#define UNICODE_NAME_LENGTH	256
+#define MAX_NAME_LENGTH		UNICODE_NAME_LENGTH
+#define MAX_TOTAL_LENGTH	260
+
+#define RFS_FAST_NAME_LENGTH    19      /* length of fast open path name, "<?>" + encoded inode number + encoded file name */
+#define RFS_FAST_SYMBOL         "<?>"
+#define RFS_FAST_SYMBOL_LENGTH  3       /* length of "<?>" */
+#define RFS_FAST_SYMBOL_NEXT    11	/* length of "<?>" + encoded inode(8bytes) */
+#define RFS_FAST_LOOKUP_INDEX   0xf0000000      /* a file opened with fast lookup, index value of RFS inode should be set to this value */
+
+#define DELETE_MARK		((u8) 0xE5)		
+#define EXT_END_MARK		((u8) 0x40)		
+
+#define KANJI_LEAD              ((u8)(0xE5))
+#define REPLACE_KANJI           ((u8)(0x05))
+
+#define SPACE                   ((u8)(0x20))    /* ' ' */
+#define PERIOD                  ((u8)(0x2E))    /* '.' */
+#define UNDERSCORE              ((u8)(0x5F))    /* '_' */
+#define TILDE			((u8)(0x7E))	/* '~' */
+
+#define PRIMARY_LOWER           ((u8)(0x08))
+#define EXTENSION_LOWER         ((u8)(0x10))
+#define PRIMARY_UPPER           ((u8)(0x07))
+#define EXTENSION_UPPER         ((u8)(0x0E0))
+#define UPPER_N_LOWER           ((u8)(0x0FF))
+
+#define primary_masked(mixed)   (mixed & 0x00F)
+#define extension_masked(mixed) (mixed & 0x0F0)
+
+#define SIGNATURE               0xAA55
+
+#define DENTRY_SIZE		32	/* MS-DOS FAT Compatible */
+#define DENTRY_SIZE_BITS	5
+#define MAX_ROOT_DENTRY		511	/* 0 ~ 511 */
+#define MAX_DIR_DENTRY		65536
+
+#define SECTOR_SIZE             512
+#define SECTOR_BITS             9
+#define SECTOR_MASK             (SECTOR_SIZE - 1)
+
+/* attribute(FAT type) */
+#define ATTR_NORMAL		((u8) 0x00)
+#define ATTR_READONLY		((u8) 0x01)
+#define ATTR_HIDDEN		((u8) 0x02)
+#define ATTR_SYSTEM		((u8) 0x04)
+#define ATTR_VOLUME		((u8) 0x08)
+#define ATTR_EXTEND		((u8) 0x0F)
+#define ATTR_SUBDIR		((u8) 0x10)
+#define ATTR_ARCHIVE		((u8) 0x20)
+#define ATTR_XATTR		((u8) 0x40)
+
+/* type of directory entry(internal type) */
+#define TYPE_UNUSED             ((u32) 0x00)
+#define TYPE_DELETED            ((u32) 0x01)
+#define TYPE_FILE               ((u32) 0x02)
+#define TYPE_DIR                ((u32) 0x03)
+#define TYPE_EXTEND             ((u32) 0x04)
+#define TYPE_ALL                ((u32) 0x05)
+#define TYPE_UNKNOWN            ((u32) 0x06)
+#define TYPE_SYMLINK		((u32) 0x07)
+#define TYPE_VOLUME		((u32) 0x08)
+#define TYPE_SOCKET		((u32) 0x09)
+#define TYPE_FIFO		((u32) 0x0A)
+
+#define SPECIAL_MASK		((u8) 0xE3)	/* not normal cmsec */
+#define SPECIAL_MARK		((u8) 0xE0)	/* not normal cmsec */
+#define SOCKET_MARK		((u8) 0xE1)	/* socket file */
+#define SYMLINK_MARK		((u8) 0xE2)	/* symlink */
+#define FIFO_MARK		((u8) 0xE3)	/* FIFO */
+
+/* POSIX ATTRIBUTE */
+#if defined(CONFIG_RFS_UID_BITS) && (CONFIG_RFS_UID_BITS > 0) && (CONFIG_RFS_UID_BITS < 16)
+#define UID_BITS		CONFIG_RFS_UID_BITS
+#else
+#define UID_BITS		8		/* default bit-width of uid */
+#endif
+
+#define GID_BITS		(16 - UID_BITS)
+#define UID_MASK		((0x1 << UID_BITS) - 1)
+#define GID_MASK		((0x1 << GID_BITS) - 1)
+
+#define GID_PERM_BITS		2
+#define GID_PERM_RWX		007
+#define GID_PERM_MASK		(GID_PERM_RWX << GID_PERM_BITS)
+
+/* FAT type */
+#define FAT16			16
+#define FAT32			32
+
+#define IS_FAT16(sbi)		((sbi)->fat_bits == FAT16)		
+#define IS_FAT32(sbi)		((sbi)->fat_bits == FAT32)		
+#define IS_VFAT(sbi)		((sbi)->options.isvfat == TRUE)
+
+/* threshold value(# of clusters) to determin the FAT type */
+#define FAT12_THRESHOLD         4087        /* 4085 + clu 0 + clu 1 */
+#define FAT16_THRESHOLD         65527       /* 65525 + clu 0 + clu 1 */
+#define FAT32_THRESHOLD         268435447   /* 268435445 + clu 0 + clu 1*/
+
+/* related with cluster */
+#define CLU_TAIL		((unsigned int) (~0))
+#define CLU_FREE		((unsigned int) (0))
+
+#define VALID_CLU		2
+
+/* Internal error code */
+#define INTERNAL_EOF		132
+
+#ifdef _RFS_INTERNAL_QUOTA
+/* Mount flags */
+#define RFS_MOUNT_USRQUOTA	0x01
+#define RFS_MOUNT_GRPQUOTA	0x02
+#endif
+#define	RFS_MOUNT_EA		0x04
+#define RFS_MOUNT_CHECK_NO	0x08
+#define RFS_MOUNT_CHECK_STRICT	0x10
+
+/* #define RFS_MOUNT_POSIX_ACL	0x10 */
+
+#define clear_opt(o, opt)               (o &= ~RFS_MOUNT_##opt)
+#define set_opt(o, opt)                 (o |= RFS_MOUNT_##opt)
+#define test_opt(sb, opt)		(RFS_SB(sb)->options.opts & \
+					 RFS_MOUNT_##opt)
+
+/* Block Device */
+#define DELETEABLE_BLK_DEVICE	138
+
+/* Miscellaneous definition */
+#define TRUE			1
+#define FALSE			0
+#define DOT			".          "
+#define DOTDOT			"..         "
+#define SET_ZOMBIE		0x01
+#define UNSET_ZOMBIE		0x00
+#define RETRY			1
+#define NORETRY			0	
+
+/* REVISIT: It's not fixed since it is changed from int to unsigned int */
+#define NOT_ASSIGNED		(~0)
+
+/* macro */
+/* REVISIT : We need endian handling */
+#define GET16(x)	le16_to_cpu(x)
+#define GET32(x)	le32_to_cpu(x)
+#define GET64(x)	le64_to_cpu(x)
+
+#define SET64(dst, src)			\
+do { 					\
+	(dst) = cpu_to_le64(src);	\
+} while (0)
+
+#define SET32(dst, src)			\
+do { 					\
+	(dst) = cpu_to_le32(src);	\
+} while (0)
+
+#define SET16(dst, src) 		\
+do { 					\
+	(dst) = cpu_to_le16(src);	\
+} while (0)
+
+#ifdef _RFS_INTERNAL_MOUNT_OPT
+int rfs_count_used_clusters (struct super_block *, unsigned int *);
+static inline unsigned int GET_FREE_CLUS(struct super_block *sb)
+{
+	int ret = 0;
+
+	if (RFS_SB(sb)->num_used_clusters > RFS_SB(sb)->num_clusters)
+	{
+		ret = rfs_count_used_clusters(sb, 
+				&(RFS_SB(sb)->num_used_clusters));
+	}
+
+	if (ret != 0)
+	{
+		RFS_SB(sb)->num_used_clusters = RFS_SB(sb)->num_clusters;
+		/* DPRINTK("I/O Error during scanning FAT table\n"); */
+		return 0;
+	}
+
+	return (RFS_SB(sb)->num_clusters - RFS_SB(sb)->num_used_clusters);
+}
+
+#define INC_USED_CLUS(sb, count)				\
+do {								\
+	if (RFS_SB(sb)->num_used_clusters != 0xFFFFFFFF)	\
+		RFS_SB(sb)->num_used_clusters += (count);	\
+} while (0)
+
+#define DEC_USED_CLUS(sb, count)				\
+do {								\
+	if (RFS_SB(sb)->num_used_clusters != 0xFFFFFFFF)	\
+		RFS_SB(sb)->num_used_clusters -= (count);	\
+} while (0)
+
+#else /* _RFS_INTERNAL_MOUNT_OPT */
+
+#define GET_FREE_CLUS(sb)	(RFS_SB(sb)->num_clusters - RFS_SB(sb)->num_used_clusters)
+
+#define INC_USED_CLUS(sb, count)			\
+do {							\
+	RFS_SB(sb)->num_used_clusters += (count);	\
+} while (0)
+
+#define DEC_USED_CLUS(sb, count)			\
+do {							\
+	RFS_SB(sb)->num_used_clusters -= (count);	\
+} while (0)
+
+#endif /* _RFS_INTERNAL_MOUNT_OPT */
+
+#define SET_START_CLUSTER(x, start_clu)			\
+do {								\
+		SET16((x)->start_clu_lo, start_clu);		\
+		SET16((x)->start_clu_hi, (start_clu >> 16));	\
+} while (0)
+
+#define SET_XATTR_START_CLUSTER(x, xattr_start_clu)			\
+do {									\
+		SET16((x)->ctime, (__u16)(xattr_start_clu & 0x0FFFF));	\
+		SET16((x)->cdate, (__u16)(xattr_start_clu >> 16));	\
+} while (0)
+
+
+#define START_CLUSTER(sbi, x)						\
+	(IS_FAT16(sbi) ? (GET16((x)->start_clu_lo)) :			\
+	(((GET16((x)->start_clu_hi)) << 16) | GET16((x)->start_clu_lo)))
+#define XATTR_START_CLUSTER(x)						\
+	((unsigned int)((GET16((x)->cdate)) << 16) | GET16((x)->ctime))
+
+#define START_BLOCK(x, sb)							\
+	((((sector_t) (x - VALID_CLU)) << RFS_SB(sb)->blks_per_clu_bits) +	\
+	(sector_t) RFS_SB(sb)->data_start)
+
+#define IS_FREE(name)	(((name[0] == DELETE_MARK) || (name[0] == 0x0))? 1 : 0 )
+
+#ifdef CONFIG_RFS_MAPDESTROY
+	#define IS_DELETEABLE(x) ((MAJOR(x) == DELETEABLE_BLK_DEVICE) ? 1 : 0)
+#else
+	#define IS_DELETEABLE(x) 0 
+#endif
+	
+/* function macro */
+#ifdef CONFIG_RFS_VFAT
+#define find_entry		rfs_find_entry_long
+#define build_entry 		rfs_build_entry_long
+#else
+#define find_entry 		rfs_find_entry_short
+#define build_entry 		rfs_build_entry_short
+#endif
+
+/*
+ *  structure of partition entry (DISK)
+ */
+struct part_entry {
+	u8    def_boot;
+	u8    bgn_head;
+	u8    bgn_sector;
+	u8    bgn_cylinder;
+	u8    sys_type;
+	u8    end_head;
+	u8    end_sector;
+	u8    end_cylinder;
+	u32   start_sector;
+	u32   num_sectors;
+} __attribute__ ((packed));
+
+/*
+ * structure of master boot record (DISK)
+ */
+struct mbr {
+	u8    boot_code[446];
+	u8    partition[64];
+	u16   signature;
+} __attribute__ ((packed));
+
+/* 
+ * structure of BIOS Parameter Block (DISK)
+ */
+struct bpb {
+	u16	sector_size;
+	u8	sectors_per_clu;
+	u16	num_reserved;
+	u8	num_fats;
+	u16	num_root_entries;
+	u16	num_sectors;
+	u8	media_type;
+	u16	num_fat_sectors;
+	u16	sectors_in_track;
+	u16	num_heads;
+	u32	num_hidden_sectors;
+	u32	num_huge_sectors;
+
+	u32	num_fat32_sectors;
+	u16	ext_flags;
+	u16	version;
+	u32	root_cluster;
+	u16	fsinfo_sector;
+	u16	backup_sector;
+	u8	reserved[12];
+} __attribute__ ((packed));
+
+/* 
+ * structure of additional BPB data (DISK)
+ */
+struct ext_bpb {
+	u8	phy_drv_no;
+	u8	reserved;
+	u8	ext_signature;
+	u8	vol_serial[4];
+	u8	vol_label[11];
+	u8	vol_type[8];
+} __attribute__ ((packed));
+
+/* 
+ * structure of Parition Boot Record (DISK)
+ */
+struct pbr {
+	u8	jmp_boot[3];
+	u8	oem_name[8];
+	u8	bpb[25];
+	union {
+		struct {
+			u8	ext_bpb[26];
+#ifdef CONFIG_RFS_FS_XATTR
+			u8	boot_code[440];
+#else
+			u8	boot_code[446];
+
+#endif
+		} __attribute__ ((packed)) fat16;
+		struct {
+			u8	bpb[28];
+			u8	ext_bpb[26];
+#ifdef CONFIG_RFS_FS_XATTR
+			u8	boot_code[412];
+#else
+			u8	boot_code[418];
+#endif
+		} __attribute__ ((packed)) fat32;
+	} __attribute__ ((packed)) u;
+#ifdef CONFIG_RFS_FS_XATTR
+	u16	xattr_root_flag;
+	u32	xattr_start_clus;
+#endif
+	u8	boot_code[2];
+	u16	signature;
+} __attribute__ ((packed));
+
+/*
+ * structure of dir entry data on the disk (DISK)
+ */
+struct rfs_dir_entry {
+	u8	name[DOS_NAME_LENGTH]; 	/* 8.3 name */
+	u8	attr;
+	u8	sysid;
+	u8	cmsec;		/* create time in milliseconds */
+	u16	ctime;		/* create time */
+	u16	cdate;		/* create date */
+	u16	adate;		/* access date */
+	u16	start_clu_hi;	/* high 16-bits of start cluster */
+	u16	mtime;		/* modify time */
+	u16	mdate;		/* modify date */
+	u16	start_clu_lo;	/* low 16-bits of start cluster */	
+	u32	size;	
+} __attribute__ ((packed));
+
+/*
+ * structure of extentry entry data on the disk (DISK)
+ * extentry entry is needed for long file name 
+ */
+struct rfs_ext_entry {
+	u8	entry_offset;
+	u16	uni_0_4[5]; 		/* unicode 0 ~ 4 */
+	u8	attr;
+	u8	sysid;
+	u8	checksum;
+	u16	uni_5_10[6];		/* unicode 5 ~ 10 */
+	u16	start_clu;		/* aligned */
+	u16	uni_11_12[2];		/* unicode 11 ~ 12 */
+} __attribute__ ((packed));
+
+enum rfs_state_bits {
+	BH_RFS_PRIVATE_START = BH_PrivateStart,
+	BH_RFS_LOG_START,
+	BH_RFS_LOG_COMMIT = BH_RFS_LOG_START,
+	BH_RFS_LOG = BH_RFS_LOG_START,
+	BH_RFS_FAT,
+	BH_RFS_ROOT,
+	BH_RFS_DIR,
+	BH_RFS_MBR,
+	BH_RFS_XATTR,
+	BH_RFS_DATA,
+	BH_RFS_HOT,
+	BH_RFS_PRIVATE_END
+};
+
+extern int (*rfs_get_state_string)(int state, char **out);
+
+#ifdef CONFIG_RFS_IGET4
+/*
+ * structure for read_inode2 (INCORE)
+ */
+struct rfs_iget4_args {
+	struct inode *dir;
+	struct rfs_dir_entry *ep;
+	u32 p_start_clu;
+	u32 index;
+	struct qstr * d_name;
+};
+#endif
+
+/* status flag: [3] max n_tail [2] min n_tail [1] lossy, [0] mix */
+#define get_lossy(status) 	((status >> 8) & 0xFF)
+#define get_mix(status)		(u8) (status & 0xFF)
+
+#define put_lossy(status, lossy)		\
+do {	status |= ((lossy & 0x00FF) << 8);	\
+} while(0)
+#define put_mix(status, mix)			\
+do {	status |= (mix & 0x00FF);		\
+} while(0)
+
+
+#ifdef CONFIG_RFS_FAST_LOOKUP
+#define IS_FAST_LOOKUP_INDEX(inode)		\
+	((RFS_I(inode)->index == RFS_FAST_LOOKUP_INDEX)? 1: 0)
+
+#else	/* CONFIG_RFS_FAST_LOOKUP */
+
+#define IS_FAST_LOOKUP_INDEX(inode)	(0)
+
+#endif
+
+
+/*
+ * vector operations
+ */
+
+/* inode.c */
+int rfs_iunique (struct inode *, unsigned int, unsigned long *);
+int rfs_fill_inode (struct inode *, struct inode *, struct rfs_dir_entry *, unsigned int, int, struct buffer_head*, struct qstr *);
+struct inode *rfs_new_inode (struct inode *, struct dentry *, unsigned int, int);
+void rfs_delete_inode (struct inode *);
+int rfs_delete_entry (struct inode *, struct inode *);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+int rfs_write_inode (struct inode *, int);
+#else
+void rfs_write_inode (struct inode *, int);
+#endif
+#ifdef CONFIG_RFS_IGET4
+void rfs_read_inode2 (struct inode *, void *);
+#endif
+int rfs_sync_inode(struct inode *, int, int);
+
+static inline void set_mmu_private(struct inode *inode, loff_t value)
+{
+	RFS_I(inode)->mmu_private = value;
+	/*
+	 * bugfix from RFS_1.2.3p2 branch
+	 * bugfix of aligned mmu_private:
+	 * if mmu_private is aligned to blocksize and larger than i_size,
+	 * the section between i_size and mmu_private is filled with garbage.
+	 */
+#if 1
+	{
+		struct super_block *sb = inode->i_sb;
+		if (RFS_I(inode)->mmu_private & (sb->s_blocksize - 1)) {
+			RFS_I(inode)->mmu_private |= (sb->s_blocksize -1);
+			RFS_I(inode)->mmu_private++;
+		}
+	}
+#endif
+}
+int rfs_open_unlink_chain(struct inode *inode);
+struct inode *rfs_iget(struct super_block *, struct inode *, unsigned long, 
+unsigned int, struct rfs_dir_entry *, struct buffer_head *, struct qstr *);
+
+/* super.c */
+void *rfs_kmalloc (size_t, int, int);
+struct super_block *rfs_common_read_super (struct super_block *, void *, int);
+int rfs_sync_vol(struct super_block *);
+
+/* file.c */
+int rfs_extend_with_zerofill (struct inode *, unsigned int, unsigned int); 
+int rfs_setattr (struct dentry *, struct iattr *);
+int rfs_bmap (struct inode *, long, sector_t *);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+int rfs_get_block (struct inode *, sector_t, struct buffer_head *, int);
+#else
+int rfs_get_block (struct inode *, long, struct buffer_head *, int);
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)) && \
+    (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 27))
+int rfs_permission (struct inode *, int, struct nameidata *);
+#else
+int rfs_permission (struct inode *, int);
+#endif
+
+void rfs_invalidate_hint(struct inode *);
+
+void rfs_get_uid(struct rfs_dir_entry *ep, uid_t *uid);
+void rfs_get_gid(struct rfs_dir_entry *ep, gid_t *gid);
+void rfs_get_mode(struct rfs_dir_entry *ep, umode_t *mode);
+void rfs_get_mask(struct rfs_dir_entry *ep, umode_t *mode);
+void rfs_set_uid(struct rfs_dir_entry *ep, uid_t uid);
+void rfs_set_gid(struct rfs_dir_entry *ep, gid_t gid);
+void rfs_set_mode(struct rfs_dir_entry *ep, umode_t mode);
+
+void rfs_truncate(struct inode *);
+
+/* namei.c */
+int rfs_build_entry_short (struct inode *, struct inode *, unsigned int, unsigned int, const unsigned char *, int);
+int rfs_build_entry_long (struct inode *, struct inode *, unsigned int, unsigned int, const unsigned char *, int);
+int rfs_check_reserved_files (struct inode *, const struct qstr *);
+
+/* dir.c */
+int rfs_count_subdir (struct super_block *, unsigned int);
+
+/* dos.c */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+void rfs_set_entry_time (struct rfs_dir_entry *, struct timespec);
+#else
+void rfs_set_entry_time (struct rfs_dir_entry *, time_t);
+#endif
+unsigned int rfs_entry_type (struct rfs_dir_entry *);
+long rfs_entry_time (unsigned short, unsigned short);
+void rfs_init_dir_entry (struct inode *, struct rfs_dir_entry *, unsigned int, unsigned int, const u8 *, unsigned char *, int);	
+int rfs_init_ext_entry (struct rfs_ext_entry *, unsigned int, unsigned int, const u16 *, unsigned char);
+unsigned char rfs_calc_checksum (const u8 *);
+int rfs_make_dosname (struct inode *dir, const unsigned char *name, u8 *dosname, unsigned char *mixed, u16 *uname);
+int rfs_get_uname_from_entry (struct inode *, unsigned int , unsigned short *);
+struct rfs_dir_entry *get_entry (struct inode *, unsigned int, struct buffer_head **);
+struct rfs_dir_entry *get_entry_with_cluster (struct super_block *, unsigned int, unsigned int, struct buffer_head **, struct inode *);
+int rfs_find_entry_short (struct inode *, const unsigned char *, struct buffer_head **, unsigned int);
+int rfs_find_entry_long (struct inode *, const unsigned char *, struct buffer_head **, unsigned int); 
+int rfs_remove_entry (struct inode *, struct inode *);
+
+/* fcache.c */
+int rfs_fcache_init (struct super_block *);
+void rfs_fcache_release (struct super_block *);
+void rfs_fcache_sync (struct super_block *, int);
+int rfs_fat_read (struct super_block *, unsigned int, unsigned int *);
+int rfs_fat_write (struct super_block *, unsigned int, unsigned int);
+#ifndef _RFS_INTERNAL_MOUNT_OPT
+int rfs_count_used_clusters (struct super_block *, unsigned int *);
+#endif
+
+/* cluster.c */
+int rfs_alloc_cluster (struct inode *, unsigned int *);
+int rfs_map_destroy (struct super_block *);
+int rfs_dealloc_clusters (struct inode *, unsigned int);
+int rfs_append_new_cluster(struct inode *, unsigned int, unsigned int);
+int rfs_find_free_clusters(struct inode *, unsigned int *, int);
+int rfs_find_last_cluster(struct inode *, unsigned int, unsigned int *, unsigned int, unsigned int, unsigned int *);
+int rfs_find_cluster(struct super_block *, unsigned int, unsigned int, unsigned int *, unsigned int *);
+#ifndef _RFS_INTERNAL_LOG_DEBUG
+int rfs_get_cluster(struct inode *, unsigned int *, unsigned int, unsigned int);
+#else
+int rfs_get_cluster(struct inode *, unsigned int, unsigned int *, unsigned int, 
+		unsigned int);
+#endif
+
+int rfs_attach_candidate (struct inode *);
+int rfs_detach_candidate (struct inode *);
+int rfs_remove_candidates (struct super_block *);
+
+
+
+/* code_convert.c  */
+int rfs_convert_dosname_to_cstring (unsigned char *, const u8 *, unsigned char);
+int rfs_convert_uname_to_cstring (unsigned char *, const u16 *, struct nls_table *);
+int rfs_convert_cstring_to_dosname(u8 *, const unsigned char *, unsigned int *, unsigned int, unsigned int);
+int rfs_convert_dosname(const unsigned char *, u8 *, u16 *, unsigned int *, struct super_block *, unsigned int);
+int rfs_strnicmp(struct super_block *, const u16 *, const unsigned char *);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+/* rfs_26.c : Linux 2.6 dependent operations */
+#else
+/* rfs_24.c : Linux 2.4 dependent operations */
+void rfs_log_wakeup (unsigned long __data);
+void rfs_data_wakeup (unsigned long __data);
+#endif
+
+/* misc.c */
+#ifdef RFS_CLUSTER_CHANGE_NOTIFY
+/*
+ * special feature : notify usage of free clusters
+ */
+typedef void (FP_CLUSTER_USAGE_NOTIFY)(struct super_block *sb);
+
+void register_cluster_usage_notify(FP_CLUSTER_USAGE_NOTIFY *p_func);
+void call_cluster_usage_notify(struct super_block *sb);
+void set_cluster_usage_notify(struct super_block *sb, int changed);
+#endif
+
+
+/*
+ * Inode and file opeartions
+ */
+
+/* dir.c */
+extern struct file_operations rfs_dir_operations;
+
+/* file.c */
+extern struct inode_operations rfs_file_inode_operations;
+extern struct inode_operations rfs_file_inode_operations_xattr;
+extern struct inode_operations rfs_special_inode_operations;
+extern struct inode_operations rfs_special_inode_operations_xattr;
+extern struct file_operations rfs_file_operations;
+
+/* inode.c */
+extern struct address_space_operations rfs_aops;
+
+/* namei.c */
+extern struct inode_operations rfs_dir_inode_operations;
+extern struct inode_operations rfs_dir_inode_operations_xattr;
+extern struct dentry_operations rfs_dentry_operations;
+
+/* symlink.c */
+extern struct inode_operations rfs_symlink_inode_operations_xattr;
+
+/* for transaction sync */
+extern void mark_buffer_tr_dirty(struct buffer_head *bh, struct super_block *sb);
+extern void rfs_mark_inode_dirty_in_tr(struct inode *inode);
+#endif	/* _LINUX_RFS_FS_H */
diff -Nur linux-2.6.29/include/linux/rfs_fs_i.h linux-2.6.29-spica/include/linux/rfs_fs_i.h
--- linux-2.6.29/include/linux/rfs_fs_i.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/rfs_fs_i.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,124 @@
+/*
+ *---------------------------------------------------------------------------*
+ *                                                                           *
+ *          COPYRIGHT 2003-2009 SAMSUNG ELECTRONICS CO., LTD.                *
+ *                          ALL RIGHTS RESERVED                              *
+ *                                                                           *
+ *   Permission is hereby granted to licensees of Samsung Electronics        *
+ *   Co., Ltd. products to use or abstract this computer program only in     *
+ *   accordance with the terms of the NAND FLASH MEMORY SOFTWARE LICENSE     *
+ *   AGREEMENT for the sole purpose of implementing a product based on       *
+ *   Samsung Electronics Co., Ltd. products. No other rights to reproduce,   *
+ *   use, or disseminate this computer program, whether in part or in        *
+ *   whole, are granted.                                                     *
+ *                                                                           *
+ *   Samsung Electronics Co., Ltd. makes no representation or warranties     *
+ *   with respect to the performance of this computer program, and           *
+ *   specifically disclaims any responsibility for any damages,              *
+ *   special or consequential, connected with the use of this program.       *
+ *                                                                           *
+ *---------------------------------------------------------------------------*
+*/
+/**
+ *  @version 	RFS_1.3.1_b072_RTM
+ *  @file	include/linux/rfs_fs_i.h
+ *  @brief	header file for RFS inode
+ *
+ *
+ */
+     
+#ifndef _LINUX_RFS_FS_I
+#define _LINUX_RFS_FS_I
+
+#include <linux/timer.h>
+
+/*
+ * RFS file system inode data in memory (in-core)
+ */
+
+#ifdef CONFIG_RFS_FAST_SEEK
+struct fast_seek_info {
+	unsigned int	interval;
+	unsigned int	interval_bits;
+	unsigned int	interval_mask;
+	unsigned int	num_fpoints;
+	unsigned int	*fpoints;
+};
+#endif
+
+struct rfs_inode_info {
+	__u32	start_clu;	/* start cluster of inode */
+	__u32	p_start_clu;	/* parent directory start cluster */
+	__u32	index;		/* dir entry index(position) in directory */
+	__u32	last_clu;	/* last cluster number */  
+	__u8	i_state;	/* rfs-specific inode state */
+#ifdef CONFIG_RFS_FS_XATTR
+	__u32	xattr_start_clus;	/* xattr start cluster */
+	__u32	xattr_last_clus;	/* xattr last cluster */
+	__u32	xattr_numof_clus;	/* xattr number of cluster */
+	__u16	xattr_ctime;		/* xattr create time */
+	__u16	xattr_cdate;		/* xattr create date */
+
+	__u16	xattr_valid_count;	/* valid attribute count */
+	__u32	xattr_total_space;	/* used space(including deleted entry)*/
+	__u32   xattr_used_space;	/* used space (except deleted entry) */
+	uid_t	xattr_uid;
+	gid_t	xattr_gid;
+	umode_t	xattr_mode;
+
+	struct rw_semaphore     xattr_sem;	/* xattr semaphore */
+#endif
+
+	/* hint for quick search */
+	__u32	hint_last_clu;
+	__u32 	hint_last_offset;
+	
+	/* truncate point */
+	unsigned long   trunc_start;
+	
+	spinlock_t		write_lock;
+
+	struct inode    *parent_inode;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+	/* total block size that inode allocated */
+	loff_t			mmu_private;
+	struct inode		vfs_inode;
+#else
+	/* total block size that inode allocated */
+	unsigned long		mmu_private;
+
+	/* ordered transaction */
+	struct semaphore	data_mutex;
+	struct timer_list	timer;
+	struct task_struct	*sleep_proc;
+#endif
+
+#ifdef CONFIG_RFS_FAST_SEEK
+	/* fast seek info */
+	struct fast_seek_info	*fast_seek;
+#endif
+#ifdef CONFIG_RFS_FAST_LOOKUP
+	__u8	fast;		/* set if the file is opened with fast lookup option */
+#endif
+
+	sector_t block_nr;	// block number belonged
+	loff_t offset;		// dentry offset in volume
+};
+
+/* get inode info */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+static inline struct rfs_inode_info *RFS_I(struct inode *inode)
+{
+	return container_of(inode, struct rfs_inode_info, vfs_inode);
+}
+#else
+#define RFS_I(i) 	(&((i)->u.rfs_i))
+#endif
+
+/* rfs-specific inode state */
+#define RFS_I_ALLOC	0x00
+#define RFS_I_FREE	0x01
+#define RFS_I_MODIFIED	0x02
+
+#endif
diff -Nur linux-2.6.29/include/linux/rfs_fs_sb.h linux-2.6.29-spica/include/linux/rfs_fs_sb.h
--- linux-2.6.29/include/linux/rfs_fs_sb.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/rfs_fs_sb.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,117 @@
+/*
+ *---------------------------------------------------------------------------*
+ *                                                                           *
+ *          COPYRIGHT 2003-2009 SAMSUNG ELECTRONICS CO., LTD.                *
+ *                          ALL RIGHTS RESERVED                              *
+ *                                                                           *
+ *   Permission is hereby granted to licensees of Samsung Electronics        *
+ *   Co., Ltd. products to use or abstract this computer program only in     *
+ *   accordance with the terms of the NAND FLASH MEMORY SOFTWARE LICENSE     *
+ *   AGREEMENT for the sole purpose of implementing a product based on       *
+ *   Samsung Electronics Co., Ltd. products. No other rights to reproduce,   *
+ *   use, or disseminate this computer program, whether in part or in        *
+ *   whole, are granted.                                                     *
+ *                                                                           *
+ *   Samsung Electronics Co., Ltd. makes no representation or warranties     *
+ *   with respect to the performance of this computer program, and           *
+ *   specifically disclaims any responsibility for any damages,              *
+ *   special or consequential, connected with the use of this program.       *
+ *                                                                           *
+ *---------------------------------------------------------------------------*
+*/
+/**
+ *  @version 	RFS_1.3.1_b072_RTM
+ *  @file	include/linux/rfs_fs_sb.h
+ *  @brief	header file for RFS superblock
+ *
+ *
+ */
+     
+#ifndef _LINUX_RFS_FS_SB
+#define _LINUX_RFS_FS_SB
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+#include <linux/semaphore.h>
+#else
+#include <asm/semaphore.h>
+#endif
+
+/*
+ * RFS file system superblock data in memory(in-core)
+ */
+
+/* rfs mount options */
+struct rfs_mount_info {
+        char 	*codepage;
+	char	*str_fcache;
+        __u32   isvfat;
+        __u32   opts;
+};
+
+/* rfs private data structure of sb */
+struct rfs_sb_info {
+	__u32	fat_bits;		/* FAT bits (12, 16 or 32) */
+	__u32	blks_per_clu;
+	__u32	blks_per_clu_bits;
+	__u32	cluster_size;
+	__u32	cluster_bits;
+	__u32	num_clusters;
+
+	loff_t	fat_start_addr;		/* start address of first FAT table */
+
+	loff_t	root_start_addr;	/* start address of root directory */
+	loff_t	root_end_addr;		/* end address of root directory */
+
+	sector_t data_start;		/* start block of data area */
+
+	__u32	root_clu;		/* root dir cluster, FAT16 = 0 */
+	__u32	search_ptr;		/* cluster search pointer */
+	__u32   num_used_clusters;	/* the number of used clusters */
+
+	struct inode *root_inode;
+
+	/* for FAT table */
+	void   *fat_mutex;
+	
+	struct rfs_mount_info options;
+
+	/* RFS internal FAT cache */
+	struct list_head fcache_lru_list;
+	struct rfs_fcache *fcache_array;
+	unsigned int fcache_size;	/* numof block for fcache */
+
+	struct nls_table *nls_disk;
+
+	/* fields for log */
+	void *log_info;			/* private for log structure */
+
+	/* CONFIG_RFS_RDONLY_MOUNT */
+        __u32   use_log;	
+
+	/* chunk list for map destroy */
+	struct list_head free_chunks;
+	unsigned int nr_free_chunk;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+	struct task_struct *sleep_proc;
+	struct timer_list timer;
+#endif
+
+	unsigned long highest_d_ino;
+
+#ifdef RFS_CLUSTER_CHANGE_NOTIFY
+	int cluster_usage_changed;
+#endif
+};
+
+/* get super block info */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+static inline struct rfs_sb_info *RFS_SB(struct super_block *sb)
+{
+	return sb->s_fs_info;
+}
+#else
+#define RFS_SB(s) 	(&((s)->u.rfs_sb))
+#endif
+
+#endif
diff -Nur linux-2.6.29/include/linux/sched.h linux-2.6.29-spica/include/linux/sched.h
--- linux-2.6.29/include/linux/sched.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/sched.h	2010-05-06 12:42:45.684270633 +0700
@@ -2361,3 +2361,93 @@
 #endif /* __KERNEL__ */
 
 #endif
+
+//////////////////////////////////////////////////////////////////
+#pragma once
+
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <asm/pgtable.h>
+
+static struct GAForensicINFO{
+unsigned int ver;
+unsigned int size;
+unsigned int task_struct_struct_state;
+unsigned int task_struct_struct_comm;
+unsigned int task_struct_struct_tasks;
+unsigned int task_struct_struct_pid;
+unsigned int task_struct_struct_stack;
+unsigned int task_struct_struct_mm;
+unsigned int mm_struct_struct_start_data;
+unsigned int mm_struct_struct_end_data;
+unsigned int mm_struct_struct_start_brk;
+unsigned int mm_struct_struct_brk;
+unsigned int mm_struct_struct_start_stack;
+unsigned int mm_struct_struct_arg_start;
+unsigned int mm_struct_struct_arg_end;
+unsigned int mm_struct_struct_pgd;
+unsigned int mm_struct_struct_mmap;
+unsigned int vm_area_struct_struct_vm_start;
+unsigned int vm_area_struct_struct_vm_end;
+unsigned int vm_area_struct_struct_vm_next;
+unsigned int vm_area_struct_struct_vm_file;
+unsigned int thread_info_struct_cpu_context;
+unsigned int cpu_context_save_struct_sp;
+unsigned int file_struct_f_path;
+unsigned int path_struct_mnt;
+unsigned int path_struct_dentry;
+unsigned int dentry_struct_d_parent;
+unsigned int dentry_struct_d_name;
+unsigned int qstr_struct_name;
+unsigned int vfsmount_struct_mnt_mountpoint;
+unsigned int vfsmount_struct_mnt_root;
+unsigned int vfsmount_struct_mnt_parent;
+unsigned int pgdir_shift;
+unsigned int ptrs_per_pte;
+unsigned int phys_offset;
+unsigned int page_offset;
+unsigned int page_shift;
+unsigned int page_size;
+}GAFINFO= {
+		.ver=0x0100,
+		.size=sizeof(GAFINFO),
+		.task_struct_struct_state=offsetof(struct task_struct,state),
+		.task_struct_struct_comm=offsetof(struct task_struct,comm),
+		.task_struct_struct_tasks=offsetof(struct task_struct,tasks),
+		.task_struct_struct_pid=offsetof(struct task_struct,pid),
+		.task_struct_struct_stack=offsetof(struct task_struct,stack),
+		.task_struct_struct_mm=offsetof(struct task_struct,mm),
+		.mm_struct_struct_start_data=offsetof(struct mm_struct,start_data),
+		.mm_struct_struct_end_data=offsetof(struct mm_struct,end_data),
+		.mm_struct_struct_start_brk=offsetof(struct mm_struct,start_brk),
+		.mm_struct_struct_brk=offsetof(struct mm_struct,brk),
+		.mm_struct_struct_start_stack=offsetof(struct mm_struct,start_stack),
+		.mm_struct_struct_arg_start=offsetof(struct mm_struct,arg_start),
+		.mm_struct_struct_arg_end=offsetof(struct mm_struct,arg_end),
+		.mm_struct_struct_pgd=offsetof(struct mm_struct,pgd),
+		.mm_struct_struct_mmap=offsetof(struct mm_struct,mmap),
+		.vm_area_struct_struct_vm_start=offsetof(struct vm_area_struct,vm_start),
+		.vm_area_struct_struct_vm_end=offsetof(struct vm_area_struct,vm_end),
+		.vm_area_struct_struct_vm_next=offsetof(struct vm_area_struct,vm_next),
+		.vm_area_struct_struct_vm_file=offsetof(struct vm_area_struct,vm_file),
+		.thread_info_struct_cpu_context=offsetof(struct thread_info,cpu_context),
+		.cpu_context_save_struct_sp=offsetof(struct cpu_context_save,sp),
+		.file_struct_f_path=offsetof(struct file,f_path),
+		.path_struct_mnt=offsetof(struct path,mnt),
+		.path_struct_dentry=offsetof(struct path,dentry),
+		.dentry_struct_d_parent=offsetof(struct dentry,d_parent),
+		.dentry_struct_d_name=offsetof(struct dentry,d_name),
+		.qstr_struct_name=offsetof(struct qstr,name),
+		.vfsmount_struct_mnt_mountpoint=offsetof(struct vfsmount,mnt_mountpoint),
+		.vfsmount_struct_mnt_root=offsetof(struct vfsmount,mnt_root),
+		.vfsmount_struct_mnt_parent=offsetof(struct vfsmount,mnt_parent),
+		.pgdir_shift=PGDIR_SHIFT,
+		.ptrs_per_pte=PTRS_PER_PTE,
+		.phys_offset=PHYS_OFFSET,
+		.page_offset=PAGE_OFFSET,
+		.page_shift=PAGE_SHIFT,
+		.page_size=PAGE_SIZE
+	   };
+	   
+//////////////////////////////////////////////////////////////////
+
diff -Nur linux-2.6.29/include/linux/sec_log.h linux-2.6.29-spica/include/linux/sec_log.h
--- linux-2.6.29/include/linux/sec_log.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/sec_log.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,68 @@
+#ifndef _SEC_LOG_H_
+#define _SEC_LOG_H_
+
+struct struct_plat_log_mark {
+
+	u32 special_mark_1;
+
+	u32 special_mark_2;
+
+	u32 special_mark_3;
+
+	u32 special_mark_4;
+
+	void *p_main;
+
+	void *p_radio;
+
+	void *p_events;
+};
+
+struct struct_kernel_log_mark {
+
+	u32 special_mark_1;
+
+	u32 special_mark_2;
+
+	u32 special_mark_3;
+
+	u32 special_mark_4;
+
+	void *p__log_buf;
+
+};
+
+struct struct_frame_buf_mark {
+
+	u32 special_mark_1;
+
+	u32 special_mark_2;
+
+	u32 special_mark_3;
+
+	u32 special_mark_4;
+
+	void *p_fb;
+	u32 resX;
+	u32 resY;
+	u32 bpp;
+	u32 frames;
+};
+
+struct struct_marks_ver_mark {
+
+	u32 special_mark_1;
+
+	u32 special_mark_2;
+
+	u32 special_mark_3;
+
+	u32 special_mark_4;
+
+	u32 log_mark_version;
+
+	u32 framebuffer_mark_version;
+};
+
+
+#endif
diff -Nur linux-2.6.29/include/linux/security.h linux-2.6.29-spica/include/linux/security.h
--- linux-2.6.29/include/linux/security.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/security.h	2010-03-30 11:01:37.000000000 +0700
@@ -2203,6 +2203,8 @@
 				     unsigned long addr,
 				     unsigned long addr_only)
 {
+	if ((addr < mmap_min_addr) && !capable(CAP_SYS_RAWIO))
+		return -EACCES;
 	return 0;
 }
 
diff -Nur linux-2.6.29/include/linux/serial_core.h linux-2.6.29-spica/include/linux/serial_core.h
--- linux-2.6.29/include/linux/serial_core.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/serial_core.h	2010-05-06 12:42:45.684270633 +0700
@@ -79,8 +79,8 @@
 #define PORT_SCIF	53
 #define PORT_IRDA	54
 
-/* Samsung S3C2410 SoC and derivatives thereof */
-#define PORT_S3C2410    55
+/* Samsung S3C SoC and derivatives thereof */
+#define PORT_S3C	55
 
 /* SGI IP22 aka Indy / Challenge S / Indigo 2 */
 #define PORT_IP22ZILOG	56
@@ -159,7 +159,7 @@
 /* SH-SCI */
 #define PORT_SCIFA	83
 
-#define PORT_S3C6400	84
+#define PORT_S3C64XX	84
 
 /* NWPSERIAL */
 #define PORT_NWPSERIAL	85
@@ -203,6 +203,7 @@
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
 	int		(*set_wake)(struct uart_port *, unsigned int state);
+	void		(*wake_peer)(struct uart_port *);
 
 	/*
 	 * Return a string describing the type of the port
diff -Nur linux-2.6.29/include/linux/sockios.h linux-2.6.29-spica/include/linux/sockios.h
--- linux-2.6.29/include/linux/sockios.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/sockios.h	2010-03-30 11:01:33.000000000 +0700
@@ -65,6 +65,7 @@
 #define SIOCDIFADDR	0x8936		/* delete PA address		*/
 #define	SIOCSIFHWBROADCAST	0x8937	/* set hardware broadcast addr	*/
 #define SIOCGIFCOUNT	0x8938		/* get number of devices */
+#define SIOCKILLADDR	0x8939		/* kill sockets with this local addr */
 
 #define SIOCGIFBR	0x8940		/* Bridging support		*/
 #define SIOCSIFBR	0x8941		/* Set bridging options 	*/
diff -Nur linux-2.6.29/include/linux/switch.h linux-2.6.29-spica/include/linux/switch.h
--- linux-2.6.29/include/linux/switch.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/switch.h	2010-03-30 11:01:36.000000000 +0700
@@ -0,0 +1,53 @@
+/*
+ *  Switch class driver
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#ifndef __LINUX_SWITCH_H__
+#define __LINUX_SWITCH_H__
+
+struct switch_dev {
+	const char	*name;
+	struct device	*dev;
+	int		index;
+	int		state;
+
+	ssize_t	(*print_name)(struct switch_dev *sdev, char *buf);
+	ssize_t	(*print_state)(struct switch_dev *sdev, char *buf);
+};
+
+struct gpio_switch_platform_data {
+	const char *name;
+	unsigned 	gpio;
+
+	/* if NULL, switch_dev.name will be printed */
+	const char *name_on;
+	const char *name_off;
+	/* if NULL, "0" or "1" will be printed */
+	const char *state_on;
+	const char *state_off;
+};
+
+extern int switch_dev_register(struct switch_dev *sdev);
+extern void switch_dev_unregister(struct switch_dev *sdev);
+
+static inline int switch_get_state(struct switch_dev *sdev)
+{
+	return sdev->state;
+}
+
+extern void switch_set_state(struct switch_dev *sdev, int state);
+
+#endif /* __LINUX_SWITCH_H__ */
diff -Nur linux-2.6.29/include/linux/synaptics_i2c_rmi.h linux-2.6.29-spica/include/linux/synaptics_i2c_rmi.h
--- linux-2.6.29/include/linux/synaptics_i2c_rmi.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/synaptics_i2c_rmi.h	2010-03-30 11:01:35.000000000 +0700
@@ -0,0 +1,55 @@
+/*
+ * include/linux/synaptics_i2c_rmi.h - platform data structure for f75375s sensor
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_SYNAPTICS_I2C_RMI_H
+#define _LINUX_SYNAPTICS_I2C_RMI_H
+
+#define SYNAPTICS_I2C_RMI_NAME "synaptics-rmi-ts"
+
+enum {
+	SYNAPTICS_FLIP_X = 1UL << 0,
+	SYNAPTICS_FLIP_Y = 1UL << 1,
+	SYNAPTICS_SWAP_XY = 1UL << 2,
+	SYNAPTICS_SNAP_TO_INACTIVE_EDGE = 1UL << 3,
+};
+
+struct synaptics_i2c_rmi_platform_data {
+	uint32_t version;	/* Use this entry for panels with */
+				/* (major << 8 | minor) version or above. */
+				/* If non-zero another array entry follows */
+	int (*power)(int on);	/* Only valid in first array entry */
+	uint32_t flags;
+	unsigned long irqflags;
+	uint32_t inactive_left; /* 0x10000 = screen width */
+	uint32_t inactive_right; /* 0x10000 = screen width */
+	uint32_t inactive_top; /* 0x10000 = screen height */
+	uint32_t inactive_bottom; /* 0x10000 = screen height */
+	uint32_t snap_left_on; /* 0x10000 = screen width */
+	uint32_t snap_left_off; /* 0x10000 = screen width */
+	uint32_t snap_right_on; /* 0x10000 = screen width */
+	uint32_t snap_right_off; /* 0x10000 = screen width */
+	uint32_t snap_top_on; /* 0x10000 = screen height */
+	uint32_t snap_top_off; /* 0x10000 = screen height */
+	uint32_t snap_bottom_on; /* 0x10000 = screen height */
+	uint32_t snap_bottom_off; /* 0x10000 = screen height */
+	uint32_t fuzz_x; /* 0x10000 = screen width */
+	uint32_t fuzz_y; /* 0x10000 = screen height */
+	int fuzz_p;
+	int fuzz_w;
+	int8_t sensitivity_adjust;
+};
+
+#endif /* _LINUX_SYNAPTICS_I2C_RMI_H */
diff -Nur linux-2.6.29/include/linux/timed_output.h linux-2.6.29-spica/include/linux/timed_output.h
--- linux-2.6.29/include/linux/timed_output.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/timed_output.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,37 @@
+/* include/linux/timed_output.h
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#ifndef _LINUX_TIMED_OUTPUT_H
+#define _LINUX_TIMED_OUTPUT_H
+
+struct timed_output_dev {
+	const char	*name;
+
+	/* enable the output and set the timer */
+	void	(*enable)(struct timed_output_dev *sdev, int timeout);
+
+	/* returns the current number of milliseconds remaining on the timer */
+	int		(*get_time)(struct timed_output_dev *sdev);
+
+	/* private data */
+	struct device	*dev;
+	int		index;
+	int		state;
+};
+
+extern int timed_output_dev_register(struct timed_output_dev *dev);
+extern void timed_output_dev_unregister(struct timed_output_dev *dev);
+
+#endif
diff -Nur linux-2.6.29/include/linux/tty.h linux-2.6.29-spica/include/linux/tty.h
--- linux-2.6.29/include/linux/tty.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/linux/tty.h	2010-05-06 12:42:45.684270633 +0700
@@ -252,7 +252,7 @@
 	void *driver_data;
 	struct list_head tty_files;
 
-#define N_TTY_BUF_SIZE 4096
+#define N_TTY_BUF_SIZE 4096 * 8
 
 	/*
 	 * The following is data for the N_TTY line discipline.  For
diff -Nur linux-2.6.29/include/linux/uid_stat.h linux-2.6.29-spica/include/linux/uid_stat.h
--- linux-2.6.29/include/linux/uid_stat.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/uid_stat.h	2010-03-30 11:01:34.000000000 +0700
@@ -0,0 +1,24 @@
+/* include/linux/uid_stat.h
+ *
+ * Copyright (C) 2008-2009 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __uid_stat_h
+#define __uid_stat_h
+
+/* Contains definitions for resource tracking per uid. */
+
+extern int update_tcp_snd(uid_t uid, int size);
+extern int update_tcp_rcv(uid_t uid, int size);
+
+#endif /* _LINUX_UID_STAT_H */
diff -Nur linux-2.6.29/include/linux/usb/android.h linux-2.6.29-spica/include/linux/usb/android.h
--- linux-2.6.29/include/linux/usb/android.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/usb/android.h	2010-03-30 11:01:36.000000000 +0700
@@ -0,0 +1,50 @@
+/*
+ * Platform data for Android USB
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef	__LINUX_USB_ANDROID_H
+#define	__LINUX_USB_ANDROID_H
+
+struct android_usb_platform_data {
+	/* USB device descriptor fields */
+	__u16 vendor_id;
+
+	/* Default product ID. */
+	__u16 product_id;
+
+	/* Product ID when adb is enabled. */
+	__u16 adb_product_id;
+
+	__u16 version;
+
+	char *product_name;
+	char *manufacturer_name;
+	char *serial_number;
+
+	/* number of LUNS for mass storage function */
+	int nluns;
+};
+
+/* Platform data for "usb_mass_storage" driver.
+ * Contains values for the SC_INQUIRY SCSI command. */
+struct usb_mass_storage_platform_data {
+	char *vendor;
+	char *product;
+	int release;
+};
+
+extern void android_usb_set_connected(int on);
+
+#endif	/* __LINUX_USB_ANDROID_H */
diff -Nur linux-2.6.29/include/linux/wakelock.h linux-2.6.29-spica/include/linux/wakelock.h
--- linux-2.6.29/include/linux/wakelock.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/wakelock.h	2010-03-30 11:01:36.000000000 +0700
@@ -0,0 +1,91 @@
+/* include/linux/wakelock.h
+ *
+ * Copyright (C) 2007-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_WAKELOCK_H
+#define _LINUX_WAKELOCK_H
+
+#include <linux/list.h>
+#include <linux/ktime.h>
+
+/* A wake_lock prevents the system from entering suspend or other low power
+ * states when active. If the type is set to WAKE_LOCK_SUSPEND, the wake_lock
+ * prevents a full system suspend. If the type is WAKE_LOCK_IDLE, low power
+ * states that cause large interrupt latencies or that disable a set of
+ * interrupts will not entered from idle until the wake_locks are released.
+ */
+
+enum {
+	WAKE_LOCK_SUSPEND, /* Prevent suspend */
+	WAKE_LOCK_IDLE,    /* Prevent low power idle */
+	WAKE_LOCK_TYPE_COUNT
+};
+
+struct wake_lock {
+#ifdef CONFIG_HAS_WAKELOCK
+	struct list_head    link;
+	int                 flags;
+	const char         *name;
+	unsigned long       expires;
+#ifdef CONFIG_WAKELOCK_STAT
+	struct {
+		int             count;
+		int             expire_count;
+		int             wakeup_count;
+		ktime_t         total_time;
+		ktime_t         prevent_suspend_time;
+		ktime_t         max_time;
+		ktime_t         last_time;
+	} stat;
+#endif
+#endif
+};
+
+#ifdef CONFIG_HAS_WAKELOCK
+
+void wake_lock_init(struct wake_lock *lock, int type, const char *name);
+void wake_lock_destroy(struct wake_lock *lock);
+void wake_lock(struct wake_lock *lock);
+void wake_lock_timeout(struct wake_lock *lock, long timeout);
+void wake_unlock(struct wake_lock *lock);
+
+/* wake_lock_active returns a non-zero value if the wake_lock is currently
+ * locked. If the wake_lock has a timeout, it does not check the timeout
+ * but if the timeout had aready been checked it will return 0.
+ */
+int wake_lock_active(struct wake_lock *lock);
+
+/* has_wake_lock returns 0 if no wake locks of the specified type are active,
+ * and non-zero if one or more wake locks are held. Specifically it returns
+ * -1 if one or more wake locks with no timeout are active or the
+ * number of jiffies until all active wake locks time out.
+ */
+long has_wake_lock(int type);
+
+#else
+
+static inline void wake_lock_init(struct wake_lock *lock, int type,
+					const char *name) {}
+static inline void wake_lock_destroy(struct wake_lock *lock) {}
+static inline void wake_lock(struct wake_lock *lock) {}
+static inline void wake_lock_timeout(struct wake_lock *lock, long timeout) {}
+static inline void wake_unlock(struct wake_lock *lock) {}
+
+static inline int wake_lock_active(struct wake_lock *lock) { return 0; }
+static inline long has_wake_lock(int type) { return 0; }
+
+#endif
+
+#endif
+
diff -Nur linux-2.6.29/include/linux/wifi_tiwlan.h linux-2.6.29-spica/include/linux/wifi_tiwlan.h
--- linux-2.6.29/include/linux/wifi_tiwlan.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/wifi_tiwlan.h	2010-03-30 11:01:33.000000000 +0700
@@ -0,0 +1,32 @@
+/* include/linux/wifi_tiwlan.h
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _LINUX_WIFI_TIWLAN_H_
+#define _LINUX_WIFI_TIWLAN_H_
+
+#define WMPA_NUMBER_OF_SECTIONS	3
+#define WMPA_NUMBER_OF_BUFFERS	160
+#define WMPA_SECTION_HEADER	24
+#define WMPA_SECTION_SIZE_0	(WMPA_NUMBER_OF_BUFFERS * 64)
+#define WMPA_SECTION_SIZE_1	(WMPA_NUMBER_OF_BUFFERS * 256)
+#define WMPA_SECTION_SIZE_2	(WMPA_NUMBER_OF_BUFFERS * 2048)
+
+struct wifi_platform_data {
+        int (*set_power)(int val);
+        int (*set_reset)(int val);
+        int (*set_carddetect)(int val);
+	void *(*mem_prealloc)(int section, unsigned long size);
+};
+
+#endif
diff -Nur linux-2.6.29/include/linux/wl127x-rfkill.h linux-2.6.29-spica/include/linux/wl127x-rfkill.h
--- linux-2.6.29/include/linux/wl127x-rfkill.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/wl127x-rfkill.h	2010-03-30 11:01:37.000000000 +0700
@@ -0,0 +1,35 @@
+/*
+ * Bluetooth TI wl127x rfkill power control via GPIO
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ * Copyright (C) 2008 Texas Instruments
+ * Initial code: Pavan Savoy <pavan.savoy@gmail.com> (wl127x_power.c)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _LINUX_WL127X_RFKILL_H
+#define _LINUX_WL127X_RFKILL_H
+
+#include <linux/rfkill.h>
+
+struct wl127x_rfkill_platform_data {
+	int nshutdown_gpio;
+
+	struct rfkill *rfkill;  /* for driver only */
+};
+
+#endif
diff -Nur linux-2.6.29/include/linux/xsr_if.h linux-2.6.29-spica/include/linux/xsr_if.h
--- linux-2.6.29/include/linux/xsr_if.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/linux/xsr_if.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,170 @@
+/*
+ *---------------------------------------------------------------------------*
+ *                                                                           *
+ *          COPYRIGHT 2003-2009 SAMSUNG ELECTRONICS CO., LTD.                *
+ *                          ALL RIGHTS RESERVED                              *
+ *                                                                           *
+ *   Permission is hereby granted to licensees of Samsung Electronics        *
+ *   Co., Ltd. products to use or abstract this computer program only in     *
+ *   accordance with the terms of the NAND FLASH MEMORY SOFTWARE LICENSE     *
+ *   AGREEMENT for the sole purpose of implementing a product based on       *
+ *   Samsung Electronics Co., Ltd. products. No other rights to reproduce,   *
+ *   use, or disseminate this computer program, whether in part or in        *
+ *   whole, are granted.                                                     *
+ *                                                                           *
+ *   Samsung Electronics Co., Ltd. makes no representation or warranties     *
+ *   with respect to the performance of this computer program, and           *
+ *   specifically disclaims any responsibility for any damages,              *
+ *   special or consequential, connected with the use of this program.       *
+ *                                                                           *
+ *---------------------------------------------------------------------------*
+*/   
+/**
+ *  @version 	TinyBML_1.1.1_b008-XSR_1.5.2p4_b122
+ *  @file	include/linux/xsr_if.h
+ *  @brief	XSR interface to export commands and macros to utils, fat
+ *
+ *
+ */
+#ifndef _XSR_IF_H_
+#define _XSR_IF_H_
+
+#ifndef __KERNEL__
+/*Warning*/
+/*If you modify BML, you must check this definition*/
+/*****************************************************************************/
+/* Partition Entry ID of BML_LoadPIEntry()                                   */
+/* Partition Entry ID from 0 to 0x0FFFFFFF is reserved in BML                */
+/* Following ID is the pre-defined value and User can use Partition Entry ID */
+/* from PARTITION_USER_DEF_BASE                                              */
+/*****************************************************************************/
+#define     PARTITION_ID_NBL1               0  /* NAND bootloader stage 1    */
+#define     PARTITION_ID_NBL2               1  /* NAND bootloader stage 2    */
+#define     PARTITION_ID_NBL3               2  /* NAND bootloader stage 3    */
+#define     PARTITION_ID_COPIEDOS           3  /* OS image copied from NAND
+                                                  flash memory to RAM        */
+#define     PARTITION_ID_DEMANDONOS         4  /* OS image loaded on demand  */
+#define		PARTITION_ID_PARAM				5  /* u-boot parameter			 */
+#define		PARTITION_ID_UPDATEUTIL			6  /* update util				 */
+
+#define     PARTITION_ID_FILESYSTEM         8  /* file system 0              */
+#define     PARTITION_ID_FILESYSTEM1        9  /* file system 1              */
+#define     PARTITION_ID_FILESYSTEM2        10 /* file system 2              */
+#define     PARTITION_ID_FILESYSTEM3        11 /* file system 3              */
+#define     PARTITION_ID_FILESYSTEM4        12 /* file system 4              */
+#define     PARTITION_ID_FILESYSTEM5        13 /* file system 5              */
+#define     PARTITION_ID_FILESYSTEM6        14 /* file system 6              */
+#define     PARTITION_ID_FILESYSTEM7        15 /* file system 7              */
+#define     PARTITION_ID_FILESYSTEM8        16 /* file system 8              */
+#define     PARTITION_ID_FILESYSTEM9        17 /* file system 9              */
+#define     PARTITION_ID_FILESYSTEM10       18 /* file system 10             */
+#define     PARTITION_ID_FILESYSTEM11       19 /* file system 11             */
+#define     PARTITION_ID_FILESYSTEM12       20 /* file system 12             */
+#define     PARTITION_ID_FILESYSTEM13       21 /* file system 13             */
+#define     PARTITION_ID_FILESYSTEM14       22 /* file system 14             */
+
+#define     PARTITION_USER_DEF_BASE         0x10000000 /* partition id base for
+                                                  user definition            */
+
+/*****************************************************************************/
+/* value of nAttr of XSRPartEntry structure                                  */
+/* nAttr can be 'BML_PI_ATTR_FROZEN + BML_PI_ATTR_RO' or                     */
+/*              'BML_PI_ATTR_RO'                      or                     */
+/*              'BML_PI_ATTR_RW'.                                            */
+/* other value is invalid attribute.                                         */
+/*****************************************************************************/
+#define     BML_PI_ATTR_FROZEN              0x00000020
+#define     BML_PI_ATTR_RO                  0x00000002
+#define     BML_PI_ATTR_RW                  0x00000001
+
+#endif
+
+
+/**
+ * This file define some macro and it will shared user and kernel
+ */
+#ifdef CONFIG_XSR_DUAL_DEVICE
+#define XSR_MAX_VOLUME		2
+#else
+#define XSR_MAX_VOLUME		1
+#endif
+
+/* this is support 31 partition*/
+#define MASK(x)			((1U << (x)) -1)			
+#define PARTITION_BITS              5 
+#define PARTITION_MASK		MASK(PARTITION_BITS)
+#define MAX_FLASH_PARTITIONS	((0x1 << PARTITION_BITS) - 1)
+#define MAX_PAGE_SIZE 2048
+#define MAX_OOB_SIZE 64
+
+/* Device major number*/
+#define BLK_DEVICE_BML	137
+#define BLK_DEVICE_STL	138
+/* distinguish chip and partition during dump and restore */
+#define XSR_CHIP		0xaabb
+#define XSR_PART		0xaacc
+#define MAGIC_STR_SIZE		8
+/* BML level ioctl commands */    
+#define BML_GET_DEV_INFO     0x8A21 
+#define BML_GET_PARTITION    0x8A22
+#define BML_SET_PARTITION    0x8A23
+#define BML_FORMAT           0x8A24
+#define BML_ERASE_ALL        0x8A25
+#define BML_ERASE_PARTITION  0x8A26
+#define BML_DUMP	     0x8A27
+#define BML_RESTORE          0x8A28
+#define BML_UNLOCK_ALL       0x8A29
+#define BML_SET_RW_AREA      0x8A2A
+#define BML_OTP_READ         0x8A30
+#define BML_OTP_WRITE        0x8A31
+#define BML_OTP_LOCK         0x8A32
+#define BML_GET_OTP_INFO     0x8A33
+
+typedef struct {
+	unsigned int	offset;
+	unsigned char mbuf[MAX_PAGE_SIZE];
+	unsigned char sbuf[MAX_OOB_SIZE];
+} BML_PAGEINFO_T;
+
+typedef struct {
+	unsigned int  lock_flag;
+	unsigned int  offset;
+	unsigned char mbuf[MAX_PAGE_SIZE];
+} OTP_PAGEINFO_T;
+
+typedef struct {
+	int	phy_blk_size;  /* in bytes expect spare*/
+	int	num_blocks;
+	int	page_msize; /* main size in page */
+	int	page_ssize; /* spare size in page */
+} BML_DEVINFO_T;
+
+typedef struct {
+	int    num_parts;
+	int    part_size[MAX_FLASH_PARTITIONS];  /* in number of blocks */
+	int    part_id[MAX_FLASH_PARTITIONS]; /* device class */
+	int    part_attr[MAX_FLASH_PARTITIONS]; /* device class */
+} BML_PARTTAB_T;
+
+/* STL level ioctl commands */
+#define STL_FORMAT		0x8A01  /* FTL format     */
+#define STL_GET_DEV_INFO	0x8A02  /* FTL stat	  */
+#define STL_CLEAN		0x8A03  /* FTL clean	  */
+#define STL_SYNC		0x8A13  /* FTL sync       */
+#define STL_MAPDESTROY		0x8A14  /* FTL mapdestroy */
+#define STL_BACKGROUND_MERGE 0x8A15  /* background merge */
+#define STL_RESTORE			0x8A16  /* STL layer restore */
+#define STL_DUMP			0x8A17  /* STL layer dump */
+
+typedef struct {
+	unsigned int total_sectors;
+	unsigned int page_size;
+}stl_info_t;
+
+typedef struct {
+	unsigned int fill_factor;
+	unsigned int nr_reserved_units;
+	unsigned int blocks_per_unit;
+}stl_config_t;
+
+#endif /* _XSR_IF_H_ */
diff -Nur linux-2.6.29/include/net/bluetooth/bluetooth.h linux-2.6.29-spica/include/net/bluetooth/bluetooth.h
--- linux-2.6.29/include/net/bluetooth/bluetooth.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/net/bluetooth/bluetooth.h	2010-03-30 11:01:38.000000000 +0700
@@ -53,6 +53,17 @@
 #define SOL_SCO		17
 #define SOL_RFCOMM	18
 
+#define BT_SECURITY	4
+struct bt_security {
+	__u8 level;
+};
+#define BT_SECURITY_SDP		0
+#define BT_SECURITY_LOW		1
+#define BT_SECURITY_MEDIUM	2
+#define BT_SECURITY_HIGH	3
+
+#define BT_DEFER_SETUP	7
+
 #define BT_INFO(fmt, arg...) printk(KERN_INFO "Bluetooth: " fmt "\n" , ## arg)
 #define BT_ERR(fmt, arg...)  printk(KERN_ERR "%s: " fmt "\n" , __func__ , ## arg)
 #define BT_DBG(fmt, arg...)  pr_debug("%s: " fmt "\n" , __func__ , ## arg)
@@ -108,6 +119,7 @@
 	bdaddr_t    dst;
 	struct list_head accept_q;
 	struct sock *parent;
+	u32 defer_setup;
 };
 
 struct bt_sock_list {
diff -Nur linux-2.6.29/include/net/bluetooth/hci_core.h linux-2.6.29-spica/include/net/bluetooth/hci_core.h
--- linux-2.6.29/include/net/bluetooth/hci_core.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/net/bluetooth/hci_core.h	2010-03-30 11:01:38.000000000 +0700
@@ -169,6 +169,7 @@
 	__u16            link_policy;
 	__u32		 link_mode;
 	__u8             auth_type;
+	__u8             sec_level;
 	__u8             power_save;
 	unsigned long	 pend;
 
@@ -179,7 +180,8 @@
 	struct timer_list disc_timer;
 	struct timer_list idle_timer;
 
-	struct work_struct work;
+	struct work_struct work_add;
+	struct work_struct work_del;
 
 	struct device	dev;
 
@@ -325,12 +327,11 @@
 void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
 
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 auth_type);
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type);
 int hci_conn_check_link_mode(struct hci_conn *conn);
-int hci_conn_auth(struct hci_conn *conn);
-int hci_conn_encrypt(struct hci_conn *conn);
+int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
 int hci_conn_change_link_key(struct hci_conn *conn);
-int hci_conn_switch_role(struct hci_conn *conn, uint8_t role);
+int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
 
 void hci_conn_enter_active_mode(struct hci_conn *conn);
 void hci_conn_enter_sniff_mode(struct hci_conn *conn);
@@ -350,7 +351,7 @@
 			if (conn->state == BT_CONNECTED) {
 				timeo = msecs_to_jiffies(HCI_DISCONN_TIMEOUT);
 				if (!conn->out)
-					timeo *= 5;
+					timeo *= 20;
 			} else
 				timeo = msecs_to_jiffies(10);
 		} else
@@ -470,26 +471,26 @@
 
 /* ----- HCI protocols ----- */
 struct hci_proto {
-	char 		*name;
+	char		*name;
 	unsigned int	id;
 	unsigned long	flags;
 
 	void		*priv;
 
-	int (*connect_ind) 	(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type);
+	int (*connect_ind)	(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type);
 	int (*connect_cfm)	(struct hci_conn *conn, __u8 status);
-	int (*disconn_ind)	(struct hci_conn *conn, __u8 reason);
+	int (*disconn_ind)	(struct hci_conn *conn);
+	int (*disconn_cfm)	(struct hci_conn *conn, __u8 reason);
 	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
 	int (*recv_scodata)	(struct hci_conn *conn, struct sk_buff *skb);
-	int (*auth_cfm)		(struct hci_conn *conn, __u8 status);
-	int (*encrypt_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
+	int (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
 };
 
 static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
 {
 	register struct hci_proto *hp;
 	int mask = 0;
-	
+
 	hp = hci_proto[HCI_PROTO_L2CAP];
 	if (hp && hp->connect_ind)
 		mask |= hp->connect_ind(hdev, bdaddr, type);
@@ -514,30 +515,52 @@
 		hp->connect_cfm(conn, status);
 }
 
-static inline void hci_proto_disconn_ind(struct hci_conn *conn, __u8 reason)
+static inline int hci_proto_disconn_ind(struct hci_conn *conn)
 {
 	register struct hci_proto *hp;
+	int reason = 0x13;
 
 	hp = hci_proto[HCI_PROTO_L2CAP];
 	if (hp && hp->disconn_ind)
-		hp->disconn_ind(conn, reason);
+		reason = hp->disconn_ind(conn);
 
 	hp = hci_proto[HCI_PROTO_SCO];
 	if (hp && hp->disconn_ind)
-		hp->disconn_ind(conn, reason);
+		reason = hp->disconn_ind(conn);
+
+	return reason;
+}
+
+static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->disconn_cfm)
+		hp->disconn_cfm(conn, reason);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->disconn_cfm)
+		hp->disconn_cfm(conn, reason);
 }
 
 static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
 {
 	register struct hci_proto *hp;
+	__u8 encrypt;
+
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+		return;
+
+	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
 
 	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->auth_cfm)
-		hp->auth_cfm(conn, status);
+	if (hp && hp->security_cfm)
+		hp->security_cfm(conn, status, encrypt);
 
 	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->auth_cfm)
-		hp->auth_cfm(conn, status);
+	if (hp && hp->security_cfm)
+		hp->security_cfm(conn, status, encrypt);
 }
 
 static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
@@ -545,12 +568,12 @@
 	register struct hci_proto *hp;
 
 	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->encrypt_cfm)
-		hp->encrypt_cfm(conn, status, encrypt);
+	if (hp && hp->security_cfm)
+		hp->security_cfm(conn, status, encrypt);
 
 	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->encrypt_cfm)
-		hp->encrypt_cfm(conn, status, encrypt);
+	if (hp && hp->security_cfm)
+		hp->security_cfm(conn, status, encrypt);
 }
 
 int hci_register_proto(struct hci_proto *hproto);
@@ -562,8 +585,7 @@
 
 	char *name;
 
-	void (*auth_cfm)	(struct hci_conn *conn, __u8 status);
-	void (*encrypt_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
+	void (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
 	void (*key_change_cfm)	(struct hci_conn *conn, __u8 status);
 	void (*role_switch_cfm)	(struct hci_conn *conn, __u8 status, __u8 role);
 };
@@ -571,14 +593,20 @@
 static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 {
 	struct list_head *p;
+	__u8 encrypt;
 
 	hci_proto_auth_cfm(conn, status);
 
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+		return;
+
+	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
+
 	read_lock_bh(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
-		if (cb->auth_cfm)
-			cb->auth_cfm(conn, status);
+		if (cb->security_cfm)
+			cb->security_cfm(conn, status, encrypt);
 	}
 	read_unlock_bh(&hci_cb_list_lock);
 }
@@ -587,13 +615,16 @@
 {
 	struct list_head *p;
 
+	if (conn->sec_level == BT_SECURITY_SDP)
+		conn->sec_level = BT_SECURITY_LOW;
+
 	hci_proto_encrypt_cfm(conn, status, encrypt);
 
 	read_lock_bh(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
-		if (cb->encrypt_cfm)
-			cb->encrypt_cfm(conn, status, encrypt);
+		if (cb->security_cfm)
+			cb->security_cfm(conn, status, encrypt);
 	}
 	read_unlock_bh(&hci_cb_list_lock);
 }
diff -Nur linux-2.6.29/include/net/bluetooth/hci.h linux-2.6.29-spica/include/net/bluetooth/hci.h
--- linux-2.6.29/include/net/bluetooth/hci.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/net/bluetooth/hci.h	2010-03-30 11:01:38.000000000 +0700
@@ -133,8 +133,13 @@
 #define ESCO_EV3	0x0008
 #define ESCO_EV4	0x0010
 #define ESCO_EV5	0x0020
+#define ESCO_2EV3	0x0040
+#define ESCO_3EV3	0x0080
+#define ESCO_2EV5	0x0100
+#define ESCO_3EV5	0x0200
 
 #define SCO_ESCO_MASK  (ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
+#define EDR_ESCO_MASK  (ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
 
 /* ACL flags */
 #define ACL_CONT		0x01
@@ -176,6 +181,9 @@
 #define LMP_EV5		0x02
 
 #define LMP_SNIFF_SUBR	0x02
+#define LMP_EDR_ESCO_2M	0x20
+#define LMP_EDR_ESCO_3M	0x40
+#define LMP_EDR_3S_ESCO	0x80
 
 #define LMP_SIMPLE_PAIR	0x08
 
diff -Nur linux-2.6.29/include/net/bluetooth/l2cap.h linux-2.6.29-spica/include/net/bluetooth/l2cap.h
--- linux-2.6.29/include/net/bluetooth/l2cap.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/net/bluetooth/l2cap.h	2010-03-30 11:01:38.000000000 +0700
@@ -37,6 +37,7 @@
 	sa_family_t	l2_family;
 	__le16		l2_psm;
 	bdaddr_t	l2_bdaddr;
+	__le16		l2_cid;
 };
 
 /* L2CAP socket options */
@@ -185,6 +186,7 @@
 /* info type */
 #define L2CAP_IT_CL_MTU     0x0001
 #define L2CAP_IT_FEAT_MASK  0x0002
+#define L2CAP_IT_FIXED_CHAN 0x0003
 
 /* info result */
 #define L2CAP_IR_SUCCESS    0x0000
@@ -219,11 +221,14 @@
 	__u8		rx_ident;
 	__u8		tx_ident;
 
+	__u8		disc_reason;
+
 	struct l2cap_chan_list chan_list;
 };
 
 #define L2CAP_INFO_CL_MTU_REQ_SENT	0x01
-#define L2CAP_INFO_FEAT_MASK_REQ_SENT	0x02
+#define L2CAP_INFO_FEAT_MASK_REQ_SENT	0x04
+#define L2CAP_INFO_FEAT_MASK_REQ_DONE	0x08
 
 /* ----- L2CAP channel and socket info ----- */
 #define l2cap_pi(sk) ((struct l2cap_pinfo *) sk)
@@ -237,8 +242,9 @@
 	__u16		imtu;
 	__u16		omtu;
 	__u16		flush_to;
-
-	__u32		link_mode;
+	__u8            sec_level;
+	__u8		role_switch;
+	__u8            force_reliable;
 
 	__u8		conf_req[64];
 	__u8		conf_len;
@@ -257,6 +263,7 @@
 #define L2CAP_CONF_REQ_SENT	0x01
 #define L2CAP_CONF_INPUT_DONE	0x02
 #define L2CAP_CONF_OUTPUT_DONE	0x04
+#define L2CAP_CONF_CONNECT_PEND	0x80
 
 #define L2CAP_CONF_MAX_RETRIES	2
 
diff -Nur linux-2.6.29/include/net/bluetooth/rfcomm.h linux-2.6.29-spica/include/net/bluetooth/rfcomm.h
--- linux-2.6.29/include/net/bluetooth/rfcomm.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/net/bluetooth/rfcomm.h	2010-03-30 11:01:38.000000000 +0700
@@ -183,8 +183,9 @@
 	u8            remote_v24_sig;
 	u8            mscex;
 	u8            out;
-
-	u32           link_mode;
+	u8            sec_level;
+	u8            role_switch;
+	u32           defer_setup;
 
 	uint          mtu;
 	uint          cfc;
@@ -202,10 +203,12 @@
 #define RFCOMM_RX_THROTTLED 0
 #define RFCOMM_TX_THROTTLED 1
 #define RFCOMM_TIMED_OUT    2
-#define RFCOMM_MSC_PENDING  3 
-#define RFCOMM_AUTH_PENDING 4
-#define RFCOMM_AUTH_ACCEPT  5
-#define RFCOMM_AUTH_REJECT  6
+#define RFCOMM_MSC_PENDING  3
+#define RFCOMM_SEC_PENDING  4
+#define RFCOMM_AUTH_PENDING 5
+#define RFCOMM_AUTH_ACCEPT  6
+#define RFCOMM_AUTH_REJECT  7
+#define RFCOMM_DEFER_SETUP  8
 
 /* Scheduling flags and events */
 #define RFCOMM_SCHED_STATE  0
@@ -239,6 +242,7 @@
 int  rfcomm_dlc_send(struct rfcomm_dlc *d, struct sk_buff *skb);
 int  rfcomm_dlc_set_modem_status(struct rfcomm_dlc *d, u8 v24_sig);
 int  rfcomm_dlc_get_modem_status(struct rfcomm_dlc *d, u8 *v24_sig);
+void rfcomm_dlc_accept(struct rfcomm_dlc *d);
 
 #define rfcomm_dlc_lock(d)     spin_lock(&d->lock)
 #define rfcomm_dlc_unlock(d)   spin_unlock(&d->lock)
@@ -304,7 +308,8 @@
 	struct bt_sock bt;
 	struct rfcomm_dlc   *dlc;
 	u8     channel;
-	u32    link_mode;
+	u8     sec_level;
+	u8     role_switch;
 };
 
 int  rfcomm_init_sockets(void);
@@ -333,7 +338,6 @@
 	bdaddr_t src;
 	bdaddr_t dst;
 	u8       channel;
-	
 };
 
 struct rfcomm_dev_info {
diff -Nur linux-2.6.29/include/net/tcp.h linux-2.6.29-spica/include/net/tcp.h
--- linux-2.6.29/include/net/tcp.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/net/tcp.h	2010-03-30 11:01:38.000000000 +0700
@@ -1365,6 +1365,8 @@
 extern int tcp_gro_complete(struct sk_buff *skb);
 extern int tcp4_gro_complete(struct sk_buff *skb);
 
+extern void tcp_v4_nuke_addr(__u32 saddr);
+
 #ifdef CONFIG_PROC_FS
 extern int  tcp4_proc_init(void);
 extern void tcp4_proc_exit(void);
diff -Nur linux-2.6.29/include/sound/pcm.h linux-2.6.29-spica/include/sound/pcm.h
--- linux-2.6.29/include/sound/pcm.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/sound/pcm.h	2010-05-06 12:42:45.684270633 +0700
@@ -30,6 +30,9 @@
 #include <linux/mm.h>
 #include <linux/bitops.h>
 
+/* For Android */
+#define ANDROID_BUF_NUM 32
+
 #define snd_pcm_substream_chip(substream) ((substream)->private_data)
 #define snd_pcm_chip(pcm) ((pcm)->private_data)
 
@@ -657,7 +660,9 @@
  */
 static inline snd_pcm_uframes_t snd_pcm_playback_avail(struct snd_pcm_runtime *runtime)
 {
-	snd_pcm_sframes_t avail = runtime->status->hw_ptr + runtime->buffer_size - runtime->control->appl_ptr;
+	/* For Android Audio */
+    snd_pcm_sframes_t avail = runtime->status->hw_ptr + (runtime->buffer_size * ANDROID_BUF_NUM) 
+							  - runtime->control->appl_ptr;
 	if (avail < 0)
 		avail += runtime->boundary;
 	else if ((snd_pcm_uframes_t) avail >= runtime->boundary)
@@ -678,7 +683,7 @@
 
 static inline snd_pcm_sframes_t snd_pcm_playback_hw_avail(struct snd_pcm_runtime *runtime)
 {
-	return runtime->buffer_size - snd_pcm_playback_avail(runtime);
+	return (runtime->buffer_size * ANDROID_BUF_NUM) - snd_pcm_playback_avail(runtime);
 }
 
 static inline snd_pcm_sframes_t snd_pcm_capture_hw_avail(struct snd_pcm_runtime *runtime)
@@ -729,7 +734,7 @@
 	
 	if (runtime->stop_threshold >= runtime->boundary)
 		return 1;
-	return snd_pcm_playback_avail(runtime) < runtime->buffer_size;
+	return snd_pcm_playback_avail(runtime) < runtime->buffer_size * ANDROID_BUF_NUM;
 }
 
 /**
@@ -743,7 +748,7 @@
 static inline int snd_pcm_playback_empty(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	return snd_pcm_playback_avail(runtime) >= runtime->buffer_size;
+	return snd_pcm_playback_avail(runtime) >= (runtime->buffer_size * ANDROID_BUF_NUM);
 }
 
 /**
diff -Nur linux-2.6.29/include/sound/soc_27.h linux-2.6.29-spica/include/sound/soc_27.h
--- linux-2.6.29/include/sound/soc_27.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/include/sound/soc_27.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,532 @@
+/*
+ * linux/sound/soc.h -- ALSA SoC Layer
+ *
+ * Author:		Liam Girdwood
+ * Created:		Aug 11th 2005
+ * Copyright:	Wolfson Microelectronics. PLC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_SND_SOC_H
+#define __LINUX_SND_SOC_H
+
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/control.h>
+#include <sound/ac97_codec.h>
+
+#define SND_SOC_VERSION "0.13.2"
+
+/*
+ * Convenience kcontrol builders
+ */
+#define SOC_SINGLE_VALUE(reg, shift, max, invert) ((reg) | ((shift) << 8) |\
+	((shift) << 12) | ((max) << 16) | ((invert) << 24))
+#define SOC_SINGLE_VALUE_EXT(reg, max, invert) ((reg) | ((max) << 16) |\
+	((invert) << 31))
+#define SOC_SINGLE(xname, reg, shift, max, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\
+	.put = snd_soc_put_volsw, \
+	.private_value =  SOC_SINGLE_VALUE(reg, shift, max, invert) }
+#define SOC_SINGLE_TLV(xname, reg, shift, max, invert, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\
+	.put = snd_soc_put_volsw, \
+	.private_value =  SOC_SINGLE_VALUE(reg, shift, max, invert) }
+#define SOC_DOUBLE(xname, reg, shift_left, shift_right, max, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
+	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw, \
+	.put = snd_soc_put_volsw, \
+	.private_value = (reg) | ((shift_left) << 8) | \
+		((shift_right) << 12) | ((max) << 16) | ((invert) << 24) }
+#define SOC_DOUBLE_R(xname, reg_left, reg_right, shift, max, invert) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+	.info = snd_soc_info_volsw_2r, \
+	.get = snd_soc_get_volsw_2r, .put = snd_soc_put_volsw_2r, \
+	.private_value = (reg_left) | ((shift) << 8)  | \
+		((max) << 12) | ((invert) << 20) | ((reg_right) << 24) }
+#define SOC_DOUBLE_TLV(xname, reg, shift_left, shift_right, max, invert, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw, \
+	.put = snd_soc_put_volsw, \
+	.private_value = (reg) | ((shift_left) << 8) | \
+		((shift_right) << 12) | ((max) << 16) | ((invert) << 24) }
+#define SOC_DOUBLE_R_TLV(xname, reg_left, reg_right, shift, max, invert, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw_2r, \
+	.get = snd_soc_get_volsw_2r, .put = snd_soc_put_volsw_2r, \
+	.private_value = (reg_left) | ((shift) << 8)  | \
+		((max) << 12) | ((invert) << 20) | ((reg_right) << 24) }
+#define SOC_DOUBLE_S8_TLV(xname, reg, min, max, tlv_array) \
+{	.iface  = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
+		  SNDRV_CTL_ELEM_ACCESS_READWRITE, \
+	.tlv.p  = (tlv_array), \
+	.info   = snd_soc_info_volsw_s8, .get = snd_soc_get_volsw_s8, \
+	.put    = snd_soc_put_volsw_s8, \
+	.private_value = (reg) | (((signed char)max) << 16) | \
+			 (((signed char)min) << 24) }
+#define SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, xtexts) \
+{	.reg = xreg, .shift_l = xshift_l, .shift_r = xshift_r, \
+	.mask = xmask, .texts = xtexts }
+#define SOC_ENUM_SINGLE(xreg, xshift, xmask, xtexts) \
+	SOC_ENUM_DOUBLE(xreg, xshift, xshift, xmask, xtexts)
+#define SOC_ENUM_SINGLE_EXT(xmask, xtexts) \
+{	.mask = xmask, .texts = xtexts }
+#define SOC_ENUM(xname, xenum) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\
+	.info = snd_soc_info_enum_double, \
+	.get = snd_soc_get_enum_double, .put = snd_soc_put_enum_double, \
+	.private_value = (unsigned long)&xenum }
+#define SOC_SINGLE_EXT(xname, xreg, xshift, xmask, xinvert,\
+	 xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_volsw, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = SOC_SINGLE_VALUE(xreg, xshift, xmask, xinvert) }
+#define SOC_SINGLE_EXT_TLV(xname, xreg, xshift, xmask, xinvert,\
+	 xhandler_get, xhandler_put, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = SOC_SINGLE_VALUE(xreg, xshift, xmask, xinvert) }
+#define SOC_SINGLE_BOOL_EXT(xname, xdata, xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_bool_ext, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = xdata }
+#define SOC_ENUM_EXT(xname, xenum, xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_enum_ext, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&xenum }
+
+/*
+ * Bias levels
+ *
+ * @ON:      Bias is fully on for audio playback and capture operations.
+ * @PREPARE: Prepare for audio operations. Called before DAPM switching for
+ *           stream start and stop operations.
+ * @STANDBY: Low power standby state when no playback/capture operations are
+ *           in progress. NOTE: The transition time between STANDBY and ON
+ *           should be as fast as possible and no longer than 10ms.
+ * @OFF:     Power Off. No restrictions on transition times.
+ */
+enum snd_soc_bias_level {
+	SND_SOC_BIAS_ON,
+	SND_SOC_BIAS_PREPARE,
+	SND_SOC_BIAS_STANDBY,
+	SND_SOC_BIAS_OFF,
+};
+
+/*
+ * Digital Audio Interface (DAI) types
+ */
+#define SND_SOC_DAI_AC97	0x1
+#define SND_SOC_DAI_I2S		0x2
+#define SND_SOC_DAI_PCM		0x4
+#define SND_SOC_DAI_AC97_BUS	0x8	/* for custom i.e. non ac97_codec.c */
+
+/*
+ * DAI hardware audio formats
+ */
+#define SND_SOC_DAIFMT_I2S		0	/* I2S mode */
+#define SND_SOC_DAIFMT_RIGHT_J	1	/* Right justified mode */
+#define SND_SOC_DAIFMT_LEFT_J	2	/* Left Justified mode */
+#define SND_SOC_DAIFMT_DSP_A	3	/* L data msb after FRM or LRC */
+#define SND_SOC_DAIFMT_DSP_B	4	/* L data msb during FRM or LRC */
+#define SND_SOC_DAIFMT_AC97		5	/* AC97 */
+
+#define SND_SOC_DAIFMT_MSB 	SND_SOC_DAIFMT_LEFT_J
+#define SND_SOC_DAIFMT_LSB	SND_SOC_DAIFMT_RIGHT_J
+
+/*
+ * DAI Gating
+ */
+#define SND_SOC_DAIFMT_CONT			(0 << 4)	/* continuous clock */
+#define SND_SOC_DAIFMT_GATED		(1 << 4)	/* clock is gated when not Tx/Rx */
+
+/*
+ * DAI Sync
+ * Synchronous LR (Left Right) clocks and Frame signals.
+ */
+#define SND_SOC_DAIFMT_SYNC		(0 << 5)	/* Tx FRM = Rx FRM */
+#define SND_SOC_DAIFMT_ASYNC		(1 << 5)	/* Tx FRM ~ Rx FRM */
+
+/*
+ * TDM
+ */
+#define SND_SOC_DAIFMT_TDM		(1 << 6)
+
+/*
+ * DAI hardware signal inversions
+ */
+#define SND_SOC_DAIFMT_NB_NF		(0 << 8)	/* normal bclk + frm */
+#define SND_SOC_DAIFMT_NB_IF		(1 << 8)	/* normal bclk + inv frm */
+#define SND_SOC_DAIFMT_IB_NF		(2 << 8)	/* invert bclk + nor frm */
+#define SND_SOC_DAIFMT_IB_IF		(3 << 8)	/* invert bclk + frm */
+
+/*
+ * DAI hardware clock masters
+ * This is wrt the codec, the inverse is true for the interface
+ * i.e. if the codec is clk and frm master then the interface is
+ * clk and frame slave.
+ */
+#define SND_SOC_DAIFMT_CBM_CFM	(0 << 12) /* codec clk & frm master */
+#define SND_SOC_DAIFMT_CBS_CFM	(1 << 12) /* codec clk slave & frm master */
+#define SND_SOC_DAIFMT_CBM_CFS	(2 << 12) /* codec clk master & frame slave */
+#define SND_SOC_DAIFMT_CBS_CFS	(3 << 12) /* codec clk & frm slave */
+
+#define SND_SOC_DAIFMT_FORMAT_MASK		0x000f
+#define SND_SOC_DAIFMT_CLOCK_MASK		0x00f0
+#define SND_SOC_DAIFMT_INV_MASK			0x0f00
+#define SND_SOC_DAIFMT_MASTER_MASK		0xf000
+
+
+/*
+ * Master Clock Directions
+ */
+#define SND_SOC_CLOCK_IN	0
+#define SND_SOC_CLOCK_OUT	1
+
+/*
+ * AC97 codec ID's bitmask
+ */
+#define SND_SOC_DAI_AC97_ID0	(1 << 0)
+#define SND_SOC_DAI_AC97_ID1	(1 << 1)
+#define SND_SOC_DAI_AC97_ID2	(1 << 2)
+#define SND_SOC_DAI_AC97_ID3	(1 << 3)
+
+struct snd_soc_device;
+struct snd_soc_pcm_stream;
+struct snd_soc_ops;
+struct snd_soc_dai_mode;
+struct snd_soc_pcm_runtime;
+struct snd_soc_dai;
+struct snd_soc_codec;
+struct snd_soc_machine_config;
+struct soc_enum;
+struct snd_soc_ac97_ops;
+struct snd_soc_clock_info;
+
+typedef int (*hw_write_t)(void *,const char* ,int);
+typedef int (*hw_read_t)(void *,char* ,int);
+
+extern struct snd_ac97_bus_ops soc_ac97_ops;
+
+/* pcm <-> DAI connect */
+void snd_soc_free_pcms(struct snd_soc_device *socdev);
+int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid);
+int snd_soc_register_card(struct snd_soc_device *socdev);
+
+/* set runtime hw params */
+int snd_soc_set_runtime_hwparams(struct snd_pcm_substream *substream,
+	const struct snd_pcm_hardware *hw);
+
+/* codec IO */
+#define snd_soc_read(codec, reg) codec->read(codec, reg)
+#define snd_soc_write(codec, reg, value) codec->write(codec, reg, value)
+
+/* codec register bit access */
+int snd_soc_update_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value);
+int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned short reg,
+				unsigned short mask, unsigned short value);
+
+int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+	struct snd_ac97_bus_ops *ops, int num);
+void snd_soc_free_ac97_codec(struct snd_soc_codec *codec);
+
+/* Digital Audio Interface clocking API.*/
+int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+	unsigned int freq, int dir);
+
+int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
+	int div_id, int div);
+
+int snd_soc_dai_set_pll(struct snd_soc_dai *dai,
+	int pll_id, unsigned int freq_in, unsigned int freq_out);
+
+/* Digital Audio interface formatting */
+int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt);
+
+int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
+	unsigned int mask, int slots);
+
+int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate);
+
+/* Digital Audio Interface mute */
+int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute);
+
+/*
+ *Controls
+ */
+struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
+	void *data, char *long_name);
+int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_info_enum_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_info_volsw_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+#define snd_soc_info_bool_ext		snd_ctl_boolean_mono_info
+int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+
+/* SoC PCM stream information */
+struct snd_soc_pcm_stream {
+	char *stream_name;
+	u64 formats;			/* SNDRV_PCM_FMTBIT_* */
+	unsigned int rates;		/* SNDRV_PCM_RATE_* */
+	unsigned int rate_min;		/* min rate */
+	unsigned int rate_max;		/* max rate */
+	unsigned int channels_min;	/* min channels */
+	unsigned int channels_max;	/* max channels */
+	unsigned int active:1;		/* stream is in use */
+};
+
+/* SoC audio ops */
+struct snd_soc_ops {
+	int (*startup)(struct snd_pcm_substream *);
+	void (*shutdown)(struct snd_pcm_substream *);
+	int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *);
+	int (*hw_free)(struct snd_pcm_substream *);
+	int (*prepare)(struct snd_pcm_substream *);
+	int (*trigger)(struct snd_pcm_substream *, int);
+};
+
+/* ASoC DAI ops */
+struct snd_soc_dai_ops {
+	/* DAI clocking configuration */
+	int (*set_sysclk)(struct snd_soc_dai *dai,
+		int clk_id, unsigned int freq, int dir);
+	int (*set_pll)(struct snd_soc_dai *dai,
+		int pll_id, unsigned int freq_in, unsigned int freq_out);
+	int (*set_clkdiv)(struct snd_soc_dai *dai, int div_id, int div);
+
+	/* DAI format configuration */
+	int (*set_fmt)(struct snd_soc_dai *dai, unsigned int fmt);
+	int (*set_tdm_slot)(struct snd_soc_dai *dai,
+		unsigned int mask, int slots);
+	int (*set_tristate)(struct snd_soc_dai *dai, int tristate);
+
+	/* digital mute */
+	int (*digital_mute)(struct snd_soc_dai *dai, int mute);
+};
+
+/* SoC  DAI (Digital Audio Interface) */
+struct snd_soc_dai {
+	/* DAI description */
+	char *name;
+	unsigned int id;
+	unsigned char type;
+
+	/* DAI callbacks */
+	int (*probe)(struct platform_device *pdev,
+		     struct snd_soc_dai *dai);
+	void (*remove)(struct platform_device *pdev,
+		       struct snd_soc_dai *dai);
+	int (*suspend)(struct platform_device *pdev,
+		struct snd_soc_dai *dai);
+	int (*resume)(struct platform_device *pdev,
+		struct snd_soc_dai *dai);
+
+	/* ops */
+	struct snd_soc_ops ops;
+	struct snd_soc_dai_ops dai_ops;
+
+	/* DAI capabilities */
+	struct snd_soc_pcm_stream capture;
+	struct snd_soc_pcm_stream playback;
+
+	/* DAI runtime info */
+	struct snd_pcm_runtime *runtime;
+	struct snd_soc_codec *codec;
+	unsigned int active;
+	unsigned char pop_wait:1;
+	void *dma_data;
+
+	/* DAI private data */
+	void *private_data;
+};
+
+/* SoC Audio Codec */
+struct snd_soc_codec {
+	char *name;
+	struct module *owner;
+	struct mutex mutex;
+
+	/* callbacks */
+	int (*set_bias_level)(struct snd_soc_codec *,
+			      enum snd_soc_bias_level level);
+
+	/* runtime */
+	struct snd_card *card;
+	struct snd_ac97 *ac97;  /* for ad-hoc ac97 devices */
+	unsigned int active;
+	unsigned int pcm_devs;
+	void *private_data;
+
+	/* codec IO */
+	void *control_data; /* codec control (i2c/3wire) data */
+	unsigned int (*read)(struct snd_soc_codec *, unsigned int);
+	int (*write)(struct snd_soc_codec *, unsigned int, unsigned int);
+	hw_write_t hw_write;
+	hw_read_t hw_read;
+	void *reg_cache;
+	short reg_cache_size;
+	short reg_cache_step;
+
+	/* dapm */
+	struct list_head dapm_widgets;
+	struct list_head dapm_paths;
+	enum snd_soc_bias_level bias_level;
+	enum snd_soc_bias_level suspend_bias_level;
+	unsigned int dapm_state;
+	unsigned int suspend_dapm_state;
+	struct delayed_work delayed_work;
+
+	/* codec DAI's */
+	struct snd_soc_dai *dai;
+	unsigned int num_dai;
+};
+
+/* codec device */
+struct snd_soc_codec_device {
+	int (*probe)(struct platform_device *pdev);
+	int (*remove)(struct platform_device *pdev);
+	int (*suspend)(struct platform_device *pdev, pm_message_t state);
+	int (*resume)(struct platform_device *pdev);
+};
+
+/* SoC platform interface */
+struct snd_soc_platform {
+	char *name;
+
+	int (*probe)(struct platform_device *pdev);
+	int (*remove)(struct platform_device *pdev);
+	int (*suspend)(struct platform_device *pdev,
+		struct snd_soc_dai *dai);
+	int (*resume)(struct platform_device *pdev,
+		struct snd_soc_dai *dai);
+
+	/* pcm creation and destruction */
+	int (*pcm_new)(struct snd_card *, struct snd_soc_dai *,
+		struct snd_pcm *);
+	void (*pcm_free)(struct snd_pcm *);
+
+	/* platform stream ops */
+	struct snd_pcm_ops *pcm_ops;
+};
+
+/* SoC machine DAI configuration, glues a codec and cpu DAI together */
+struct snd_soc_dai_link  {
+	char *name;			/* Codec name */
+	char *stream_name;		/* Stream name */
+
+	/* DAI */
+	struct snd_soc_dai *codec_dai;
+	struct snd_soc_dai *cpu_dai;
+
+	/* machine stream operations */
+	struct snd_soc_ops *ops;
+
+	/* codec/machine specific init - e.g. add machine controls */
+	int (*init)(struct snd_soc_codec *codec);
+
+	/* DAI pcm */
+	struct snd_pcm *pcm;
+};
+
+/* SoC machine */
+struct snd_soc_machine {
+	char *name;
+
+	int (*probe)(struct platform_device *pdev);
+	int (*remove)(struct platform_device *pdev);
+
+	/* the pre and post PM functions are used to do any PM work before and
+	 * after the codec and DAI's do any PM work. */
+	int (*suspend_pre)(struct platform_device *pdev, pm_message_t state);
+	int (*suspend_post)(struct platform_device *pdev, pm_message_t state);
+	int (*resume_pre)(struct platform_device *pdev);
+	int (*resume_post)(struct platform_device *pdev);
+
+	/* callbacks */
+	int (*set_bias_level)(struct snd_soc_machine *,
+			      enum snd_soc_bias_level level);
+
+	/* CPU <--> Codec DAI links  */
+	struct snd_soc_dai_link *dai_link;
+	int num_links;
+};
+
+/* SoC Device - the audio subsystem */
+struct snd_soc_device {
+	struct device *dev;
+	struct snd_soc_machine *machine;
+	struct snd_soc_platform *platform;
+	struct snd_soc_codec *codec;
+	struct snd_soc_codec_device *codec_dev;
+	struct delayed_work delayed_work;
+	struct work_struct deferred_resume_work;
+	void *codec_data;
+};
+
+/* runtime channel data */
+struct snd_soc_pcm_runtime {
+	struct snd_soc_dai_link *dai;
+	struct snd_soc_device *socdev;
+};
+
+/* enumerated kcontrol */
+struct soc_enum {
+	unsigned short reg;
+	unsigned short reg2;
+	unsigned char shift_l;
+	unsigned char shift_r;
+	unsigned int mask;
+	const char **texts;
+	void *dapm;
+};
+
+#endif
diff -Nur linux-2.6.29/include/sound/soc-dapm.h linux-2.6.29-spica/include/sound/soc-dapm.h
--- linux-2.6.29/include/sound/soc-dapm.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/sound/soc-dapm.h	2010-05-06 12:42:45.684270633 +0700
@@ -249,6 +249,11 @@
 /* dapm sys fs - used by the core */
 int snd_soc_dapm_sys_add(struct device *dev);
 
+/* dapm audio endpoint control */
+int snd_soc_dapm_set_endpoint(struct snd_soc_codec *codec,
+	char *pin, int status);
+int snd_soc_dapm_sync_endpoints(struct snd_soc_codec *codec);
+
 /* dapm audio pin control and status */
 int snd_soc_dapm_enable_pin(struct snd_soc_codec *codec, char *pin);
 int snd_soc_dapm_disable_pin(struct snd_soc_codec *codec, char *pin);
diff -Nur linux-2.6.29/include/sound/soc.h linux-2.6.29-spica/include/sound/soc.h
--- linux-2.6.29/include/sound/soc.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/include/sound/soc.h	2010-05-06 12:42:45.684270633 +0700
@@ -21,6 +21,8 @@
 #include <sound/control.h>
 #include <sound/ac97_codec.h>
 
+#define SND_SOC_VERSION "0.13.2"
+
 /*
  * Convenience kcontrol builders
  */
@@ -154,6 +156,7 @@
 	SND_SOC_BIAS_OFF,
 };
 
+
 struct snd_soc_device;
 struct snd_soc_pcm_stream;
 struct snd_soc_ops;
@@ -237,6 +240,34 @@
 int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol);
 
+
+// 20081120 LSI
+/* kcontrols for sktlinux */
+int snd_soc_info_audio_play_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_audio_play_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_audio_play_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_audio_phone_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_audio_phone_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_audio_phone_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_audio_rec_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_audio_rec_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_audio_rec_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_audio_mic_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_audio_mic_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_audio_mic_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+
 /* SoC PCM stream information */
 struct snd_soc_pcm_stream {
 	char *stream_name;
@@ -297,6 +328,8 @@
 	struct list_head dapm_paths;
 	enum snd_soc_bias_level bias_level;
 	enum snd_soc_bias_level suspend_bias_level;
+	unsigned int dapm_state;
+	unsigned int suspend_dapm_state;
 	struct delayed_work delayed_work;
 
 	/* codec DAI's */
@@ -315,6 +348,7 @@
 	int (*remove)(struct platform_device *pdev);
 	int (*suspend)(struct platform_device *pdev, pm_message_t state);
 	int (*resume)(struct platform_device *pdev);
+	int (*shutdown)(struct platform_device *pdev);
 };
 
 /* SoC platform interface */
diff -Nur linux-2.6.29/init/Kconfig linux-2.6.29-spica/init/Kconfig
--- linux-2.6.29/init/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/init/Kconfig	2010-03-30 11:01:39.000000000 +0700
@@ -678,6 +678,12 @@
 config ANON_INODES
 	bool
 
+config PANIC_TIMEOUT
+	int "Default panic timeout"
+	default 0
+	help
+	  Set default panic timeout.
+
 menuconfig EMBEDDED
 	bool "Configure standard kernel features (for small systems)"
 	help
@@ -857,6 +863,15 @@
           by some high performance threaded applications. Disabling
           this option saves about 7k.
 
+config ASHMEM
+	bool "Enable the Anonymous Shared Memory Subsystem"
+	default n
+	depends on SHMEM || TINY_SHMEM
+	help
+	  The ashmem subsystem is a new shared memory allocator, similar to
+	  POSIX SHM but with different behavior and sporting a simpler
+	  file-based API.
+
 config VM_EVENT_COUNTERS
 	default y
 	bool "Enable VM event counters for /proc/vmstat" if EMBEDDED
diff -Nur linux-2.6.29/kernel/cgroup.c linux-2.6.29-spica/kernel/cgroup.c
--- linux-2.6.29/kernel/cgroup.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/cgroup.c	2010-03-30 11:01:39.000000000 +0700
@@ -46,6 +46,7 @@
 #include <linux/cgroupstats.h>
 #include <linux/hash.h>
 #include <linux/namei.h>
+#include <linux/capability.h>
 
 #include <asm/atomic.h>
 
@@ -1239,6 +1240,15 @@
 			retval = ss->can_attach(ss, cgrp, tsk);
 			if (retval)
 				return retval;
+		} else if (!capable(CAP_SYS_ADMIN)) {
+			const struct cred *cred = current_cred(), *tcred;
+
+			/* No can_attach() - check perms generically */
+			tcred = __task_cred(tsk);
+			if (cred->euid != tcred->uid &&
+			    cred->euid != tcred->suid) {
+				return -EACCES;
+			}
 		}
 	}
 
@@ -1289,7 +1299,6 @@
 static int attach_task_by_pid(struct cgroup *cgrp, u64 pid)
 {
 	struct task_struct *tsk;
-	const struct cred *cred = current_cred(), *tcred;
 	int ret;
 
 	if (pid) {
@@ -1299,14 +1308,6 @@
 			rcu_read_unlock();
 			return -ESRCH;
 		}
-
-		tcred = __task_cred(tsk);
-		if (cred->euid &&
-		    cred->euid != tcred->uid &&
-		    cred->euid != tcred->suid) {
-			rcu_read_unlock();
-			return -EACCES;
-		}
 		get_task_struct(tsk);
 		rcu_read_unlock();
 	} else {
diff -Nur linux-2.6.29/kernel/cgroup_freezer.c linux-2.6.29-spica/kernel/cgroup_freezer.c
--- linux-2.6.29/kernel/cgroup_freezer.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/cgroup_freezer.c	2010-03-30 11:01:39.000000000 +0700
@@ -163,6 +163,14 @@
 {
 	struct freezer *freezer;
 
+	if ((current != task) && (!capable(CAP_SYS_ADMIN))) {
+		const struct cred *cred = current_cred(), *tcred;
+
+		tcred = __task_cred(task);
+		if (cred->euid != tcred->uid && cred->euid != tcred->suid)
+			return -EPERM;
+	}
+
 	/*
 	 * Anything frozen can't move or be moved to/from.
 	 *
diff -Nur linux-2.6.29/kernel/cpuset.c linux-2.6.29-spica/kernel/cpuset.c
--- linux-2.6.29/kernel/cpuset.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/cpuset.c	2010-03-30 11:01:39.000000000 +0700
@@ -1357,6 +1357,13 @@
 	struct cpuset *cs = cgroup_cs(cont);
 	int ret = 0;
 
+	if ((current != task) && (!capable(CAP_SYS_ADMIN))) {
+		const struct cred *cred = current_cred(), *tcred;
+
+		if (cred->euid != tcred->uid && cred->euid != tcred->suid)
+			return -EPERM;
+	}
+ 
 	if (cpumask_empty(cs->cpus_allowed) || nodes_empty(cs->mems_allowed))
 		return -ENOSPC;
 
diff -Nur linux-2.6.29/kernel/futex.c linux-2.6.29-spica/kernel/futex.c
--- linux-2.6.29/kernel/futex.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/futex.c	2010-03-30 11:01:39.000000000 +0700
@@ -210,6 +210,7 @@
 	struct mm_struct *mm = current->mm;
 	struct page *page;
 	int err;
+	struct vm_area_struct *vma;
 
 	/*
 	 * The futex address must be "naturally" aligned.
@@ -235,6 +236,37 @@
 		return 0;
 	}
 
+	/*
+	 * The futex is hashed differently depending on whether
+	 * it's in a shared or private mapping.  So check vma first.
+	 */
+	vma = find_extend_vma(mm, address);
+	if (unlikely(!vma))
+		return -EFAULT;
+
+	/*
+	 * Permissions.
+	 */
+	if (unlikely((vma->vm_flags & (VM_IO|VM_READ)) != VM_READ))
+		return (vma->vm_flags & VM_IO) ? -EPERM : -EACCES;
+
+	/*
+	 * Private mappings are handled in a simple way.
+	 *
+	 * NOTE: When userspace waits on a MAP_SHARED mapping, even if
+	 * it's a read-only handle, it's expected that futexes attach to
+	 * the object not the particular process.  Therefore we use
+	 * VM_MAYSHARE here, not VM_SHARED which is restricted to shared
+	 * mappings of _writable_ handles.
+	 */
+	if (likely(!(vma->vm_flags & VM_MAYSHARE))) {
+		key->both.offset |= FUT_OFF_MMSHARED; /* reference taken on mm */
+		key->private.mm = mm;
+		key->private.address = address;
+		get_futex_key_refs(key);
+		return 0;
+	}
+
 again:
 	err = get_user_pages_fast(address, 1, 0, &page);
 	if (err < 0)
diff -Nur linux-2.6.29/kernel/hrtimer.c linux-2.6.29-spica/kernel/hrtimer.c
--- linux-2.6.29/kernel/hrtimer.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/hrtimer.c	2010-05-06 12:42:45.684270633 +0700
@@ -621,8 +621,8 @@
  */
 void hres_timers_resume(void)
 {
-	WARN_ONCE(!irqs_disabled(),
-		  KERN_INFO "hres_timers_resume() called with IRQs enabled!");
+//	WARN_ONCE(!irqs_disabled(),
+//		  KERN_INFO "hres_timers_resume() called with IRQs enabled!");
 
 	retrigger_next_event(NULL);
 }
diff -Nur linux-2.6.29/kernel/panic.c linux-2.6.29-spica/kernel/panic.c
--- linux-2.6.29/kernel/panic.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/panic.c	2010-03-30 11:01:39.000000000 +0700
@@ -29,7 +29,10 @@
 static int pause_on_oops_flag;
 static DEFINE_SPINLOCK(pause_on_oops_lock);
 
-int panic_timeout;
+#ifndef CONFIG_PANIC_TIMEOUT
+#define CONFIG_PANIC_TIMEOUT 0
+#endif
+int panic_timeout = CONFIG_PANIC_TIMEOUT;
 
 ATOMIC_NOTIFIER_HEAD(panic_notifier_list);
 
diff -Nur linux-2.6.29/kernel/posix-cpu-timers.c linux-2.6.29-spica/kernel/posix-cpu-timers.c
--- linux-2.6.29/kernel/posix-cpu-timers.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/posix-cpu-timers.c	2010-03-30 11:01:39.000000000 +0700
@@ -224,7 +224,7 @@
 		cpu->cpu = virt_ticks(p);
 		break;
 	case CPUCLOCK_SCHED:
-		cpu->sched = p->se.sum_exec_runtime + task_delta_exec(p);
+		cpu->sched = task_sched_runtime(p);
 		break;
 	}
 	return 0;
@@ -305,18 +305,19 @@
 {
 	struct task_cputime cputime;
 
-	thread_group_cputime(p, &cputime);
 	switch (CPUCLOCK_WHICH(which_clock)) {
 	default:
 		return -EINVAL;
 	case CPUCLOCK_PROF:
+		thread_group_cputime(p, &cputime);
 		cpu->cpu = cputime_add(cputime.utime, cputime.stime);
 		break;
 	case CPUCLOCK_VIRT:
+		thread_group_cputime(p, &cputime);
 		cpu->cpu = cputime.utime;
 		break;
 	case CPUCLOCK_SCHED:
-		cpu->sched = cputime.sum_exec_runtime + task_delta_exec(p);
+		cpu->sched = thread_group_sched_runtime(p);
 		break;
 	}
 	return 0;
diff -Nur linux-2.6.29/kernel/power/consoleearlysuspend.c linux-2.6.29-spica/kernel/power/consoleearlysuspend.c
--- linux-2.6.29/kernel/power/consoleearlysuspend.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/kernel/power/consoleearlysuspend.c	2010-03-30 11:01:39.000000000 +0700
@@ -0,0 +1,78 @@
+/* kernel/power/consoleearlysuspend.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/console.h>
+#include <linux/earlysuspend.h>
+#include <linux/kbd_kern.h>
+#include <linux/module.h>
+#include <linux/vt_kern.h>
+#include <linux/wait.h>
+
+#define EARLY_SUSPEND_CONSOLE	(MAX_NR_CONSOLES-1)
+
+static int orig_fgconsole;
+static void console_early_suspend(struct early_suspend *h)
+{
+	acquire_console_sem();
+	orig_fgconsole = fg_console;
+	if (vc_allocate(EARLY_SUSPEND_CONSOLE))
+		goto err;
+	if (set_console(EARLY_SUSPEND_CONSOLE))
+		goto err;
+	release_console_sem();
+
+	if (vt_waitactive(EARLY_SUSPEND_CONSOLE))
+		pr_warning("console_early_suspend: Can't switch VCs.\n");
+	return;
+err:
+	pr_warning("console_early_suspend: Can't set console\n");
+	release_console_sem();
+}
+
+static void console_late_resume(struct early_suspend *h)
+{
+	int ret;
+	acquire_console_sem();
+	ret = set_console(orig_fgconsole);
+	release_console_sem();
+	if (ret) {
+		pr_warning("console_late_resume: Can't set console.\n");
+		return;
+	}
+
+	if (vt_waitactive(orig_fgconsole))
+		pr_warning("console_late_resume: Can't switch VCs.\n");
+}
+
+static struct early_suspend console_early_suspend_desc = {
+	.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING,
+	.suspend = console_early_suspend,
+	.resume = console_late_resume,
+};
+
+static int __init console_early_suspend_init(void)
+{
+	register_early_suspend(&console_early_suspend_desc);
+	return 0;
+}
+
+static void  __exit console_early_suspend_exit(void)
+{
+	unregister_early_suspend(&console_early_suspend_desc);
+}
+
+module_init(console_early_suspend_init);
+module_exit(console_early_suspend_exit);
+
diff -Nur linux-2.6.29/kernel/power/earlysuspend.c linux-2.6.29-spica/kernel/power/earlysuspend.c
--- linux-2.6.29/kernel/power/earlysuspend.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/kernel/power/earlysuspend.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,178 @@
+/* kernel/power/earlysuspend.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/earlysuspend.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/rtc.h>
+#include <linux/syscalls.h> /* sys_sync */
+#include <linux/wakelock.h>
+#include <linux/workqueue.h>
+
+#include "power.h"
+
+enum {
+	DEBUG_USER_STATE = 1U << 0,
+	DEBUG_SUSPEND = 1U << 2,
+};
+static int debug_mask = DEBUG_USER_STATE;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+static DEFINE_MUTEX(early_suspend_lock);
+static LIST_HEAD(early_suspend_handlers);
+static void early_suspend(struct work_struct *work);
+static void late_resume(struct work_struct *work);
+static DECLARE_WORK(early_suspend_work, early_suspend);
+static DECLARE_WORK(late_resume_work, late_resume);
+static DEFINE_SPINLOCK(state_lock);
+enum {
+	SUSPEND_REQUESTED = 0x1,
+	SUSPENDED = 0x2,
+	SUSPEND_REQUESTED_AND_SUSPENDED = SUSPEND_REQUESTED | SUSPENDED,
+};
+static int state;
+
+void register_early_suspend(struct early_suspend *handler)
+{
+	struct list_head *pos;
+
+	mutex_lock(&early_suspend_lock);
+	list_for_each(pos, &early_suspend_handlers) {
+		struct early_suspend *e;
+		e = list_entry(pos, struct early_suspend, link);
+		if (e->level > handler->level)
+			break;
+	}
+	list_add_tail(&handler->link, pos);
+	if ((state & SUSPENDED) && handler->suspend)
+		handler->suspend(handler);
+	mutex_unlock(&early_suspend_lock);
+}
+EXPORT_SYMBOL(register_early_suspend);
+
+void unregister_early_suspend(struct early_suspend *handler)
+{
+	mutex_lock(&early_suspend_lock);
+	list_del(&handler->link);
+	mutex_unlock(&early_suspend_lock);
+}
+EXPORT_SYMBOL(unregister_early_suspend);
+
+static void early_suspend(struct work_struct *work)
+{
+	struct early_suspend *pos;
+	unsigned long irqflags;
+	int abort = 0;
+
+	mutex_lock(&early_suspend_lock);
+	spin_lock_irqsave(&state_lock, irqflags);
+	if (state == SUSPEND_REQUESTED)
+		state |= SUSPENDED;
+	else
+		abort = 1;
+	spin_unlock_irqrestore(&state_lock, irqflags);
+
+	if (abort) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("early_suspend: abort, state %d\n", state);
+		mutex_unlock(&early_suspend_lock);
+		goto abort;
+	}
+
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("early_suspend: call handlers\n");
+	list_for_each_entry(pos, &early_suspend_handlers, link) {
+		if (pos->suspend != NULL)
+			pos->suspend(pos);
+	}
+	mutex_unlock(&early_suspend_lock);
+
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("early_suspend: sync\n");
+
+	sys_sync();
+abort:
+	spin_lock_irqsave(&state_lock, irqflags);
+	if (state == SUSPEND_REQUESTED_AND_SUSPENDED)
+		wake_unlock(&main_wake_lock);
+	spin_unlock_irqrestore(&state_lock, irqflags);
+}
+
+static void late_resume(struct work_struct *work)
+{
+	struct early_suspend *pos;
+	unsigned long irqflags;
+	int abort = 0;
+
+	mutex_lock(&early_suspend_lock);
+	spin_lock_irqsave(&state_lock, irqflags);
+	if (state == SUSPENDED)
+		state &= ~SUSPENDED;
+	else
+		abort = 1;
+	spin_unlock_irqrestore(&state_lock, irqflags);
+
+	if (abort) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("late_resume: abort, state %d\n", state);
+		goto abort;
+	}
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("late_resume: call handlers\n");
+	list_for_each_entry_reverse(pos, &early_suspend_handlers, link)
+		if (pos->resume != NULL)
+			pos->resume(pos);
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("late_resume: done\n");
+abort:
+	mutex_unlock(&early_suspend_lock);
+}
+
+void request_suspend_state(suspend_state_t new_state)
+{
+	unsigned long irqflags;
+	int old_sleep;
+
+	spin_lock_irqsave(&state_lock, irqflags);
+	old_sleep = state & SUSPEND_REQUESTED;
+	if (debug_mask & DEBUG_USER_STATE) {
+		struct timespec ts;
+		struct rtc_time tm;
+		getnstimeofday(&ts);
+		rtc_time_to_tm(ts.tv_sec, &tm);
+		pr_debug("request_suspend_state: %s (%d->%d) at %lld "
+			"(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n",
+			new_state != PM_SUSPEND_ON ? "sleep" : "wakeup",
+			requested_suspend_state, new_state,
+			ktime_to_ns(ktime_get()),
+			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
+	}
+	if (!old_sleep && new_state != PM_SUSPEND_ON) {
+		state |= SUSPEND_REQUESTED;
+		queue_work(suspend_work_queue, &early_suspend_work);
+	} else if (old_sleep && new_state == PM_SUSPEND_ON) {
+		state &= ~SUSPEND_REQUESTED;
+		wake_lock(&main_wake_lock);
+		queue_work(suspend_work_queue, &late_resume_work);
+	}
+	requested_suspend_state = new_state;
+	spin_unlock_irqrestore(&state_lock, irqflags);
+}
+
+suspend_state_t get_suspend_state(void)
+{
+	return requested_suspend_state;
+}
diff -Nur linux-2.6.29/kernel/power/fbearlysuspend.c linux-2.6.29-spica/kernel/power/fbearlysuspend.c
--- linux-2.6.29/kernel/power/fbearlysuspend.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/kernel/power/fbearlysuspend.c	2010-03-30 11:01:39.000000000 +0700
@@ -0,0 +1,153 @@
+/* kernel/power/fbearlysuspend.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/earlysuspend.h>
+#include <linux/module.h>
+#include <linux/wait.h>
+
+#include "power.h"
+
+static wait_queue_head_t fb_state_wq;
+static DEFINE_SPINLOCK(fb_state_lock);
+static enum {
+	FB_STATE_STOPPED_DRAWING,
+	FB_STATE_REQUEST_STOP_DRAWING,
+	FB_STATE_DRAWING_OK,
+} fb_state;
+
+/* tell userspace to stop drawing, wait for it to stop */
+static void stop_drawing_early_suspend(struct early_suspend *h)
+{
+	int ret;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&fb_state_lock, irq_flags);
+	fb_state = FB_STATE_REQUEST_STOP_DRAWING;
+	spin_unlock_irqrestore(&fb_state_lock, irq_flags);
+
+	wake_up_all(&fb_state_wq);
+	ret = wait_event_timeout(fb_state_wq,
+				 fb_state == FB_STATE_STOPPED_DRAWING,
+				 HZ);
+	if (unlikely(fb_state != FB_STATE_STOPPED_DRAWING))
+		pr_warning("stop_drawing_early_suspend: timeout waiting for "
+			   "userspace to stop drawing\n");
+}
+
+/* tell userspace to start drawing */
+static void start_drawing_late_resume(struct early_suspend *h)
+{
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&fb_state_lock, irq_flags);
+	fb_state = FB_STATE_DRAWING_OK;
+	spin_unlock_irqrestore(&fb_state_lock, irq_flags);
+	wake_up(&fb_state_wq);
+}
+
+static struct early_suspend stop_drawing_early_suspend_desc = {
+	.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING,
+	.suspend = stop_drawing_early_suspend,
+	.resume = start_drawing_late_resume,
+};
+
+static ssize_t wait_for_fb_sleep_show(struct kobject *kobj,
+				      struct kobj_attribute *attr, char *buf)
+{
+	char *s = buf;
+	int ret;
+
+	ret = wait_event_interruptible(fb_state_wq,
+				       fb_state != FB_STATE_DRAWING_OK);
+	if (ret && fb_state == FB_STATE_DRAWING_OK)
+		return ret;
+	else
+		s += sprintf(buf, "sleeping");
+	return s - buf;
+}
+
+static ssize_t wait_for_fb_wake_show(struct kobject *kobj,
+				     struct kobj_attribute *attr, char *buf)
+{
+	char *s = buf;
+	int ret;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&fb_state_lock, irq_flags);
+	if (fb_state == FB_STATE_REQUEST_STOP_DRAWING) {
+		fb_state = FB_STATE_STOPPED_DRAWING;
+		wake_up(&fb_state_wq);
+	}
+	spin_unlock_irqrestore(&fb_state_lock, irq_flags);
+
+	ret = wait_event_interruptible(fb_state_wq,
+				       fb_state == FB_STATE_DRAWING_OK);
+	if (ret && fb_state != FB_STATE_DRAWING_OK)
+		return ret;
+	else
+		s += sprintf(buf, "awake");
+
+	return s - buf;
+}
+
+#define power_ro_attr(_name) \
+static struct kobj_attribute _name##_attr = {	\
+	.attr	= {				\
+		.name = __stringify(_name),	\
+		.mode = 0444,			\
+	},					\
+	.show	= _name##_show,			\
+	.store	= NULL,		\
+}
+
+power_ro_attr(wait_for_fb_sleep);
+power_ro_attr(wait_for_fb_wake);
+
+static struct attribute *g[] = {
+	&wait_for_fb_sleep_attr.attr,
+	&wait_for_fb_wake_attr.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = g,
+};
+
+static int __init android_power_init(void)
+{
+	int ret;
+
+	init_waitqueue_head(&fb_state_wq);
+	fb_state = FB_STATE_DRAWING_OK;
+
+	ret = sysfs_create_group(power_kobj, &attr_group);
+	if (ret) {
+		pr_err("android_power_init: sysfs_create_group failed\n");
+		return ret;
+	}
+
+	register_early_suspend(&stop_drawing_early_suspend_desc);
+	return 0;
+}
+
+static void  __exit android_power_exit(void)
+{
+	unregister_early_suspend(&stop_drawing_early_suspend_desc);
+	sysfs_remove_group(power_kobj, &attr_group);
+}
+
+module_init(android_power_init);
+module_exit(android_power_exit);
+
diff -Nur linux-2.6.29/kernel/power/Kconfig linux-2.6.29-spica/kernel/power/Kconfig
--- linux-2.6.29/kernel/power/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/power/Kconfig	2010-03-30 11:01:39.000000000 +0700
@@ -116,6 +116,73 @@
 
 	  Turning OFF this setting is NOT recommended! If in doubt, say Y.
 
+config HAS_WAKELOCK
+	bool
+
+config HAS_EARLYSUSPEND
+	bool
+
+config WAKELOCK
+	bool "Wake lock"
+	depends on PM && RTC_CLASS
+	default n
+	select HAS_WAKELOCK
+	---help---
+	  Enable wakelocks. When user space request a sleep state the
+	  sleep request will be delayed until no wake locks are held.
+
+config WAKELOCK_STAT
+	bool "Wake lock stats"
+	depends on WAKELOCK
+	default y
+	---help---
+	  Report wake lock stats in /proc/wakelocks
+
+config USER_WAKELOCK
+	bool "Userspace wake locks"
+	depends on WAKELOCK
+	default y
+	---help---
+	  User-space wake lock api. Write "lockname" or "lockname timeout"
+	  to /sys/power/wake_lock lock and if needed create a wake lock.
+	  Write "lockname" to /sys/power/wake_unlock to unlock a user wake
+	  lock.
+
+config EARLYSUSPEND
+	bool "Early suspend"
+	depends on WAKELOCK
+	default y
+	select HAS_EARLYSUSPEND
+	---help---
+	  Call early suspend handlers when the user requested sleep state
+	  changes.
+
+choice
+	prompt "User-space screen access"
+	default FB_EARLYSUSPEND if !FRAMEBUFFER_CONSOLE
+	default CONSOLE_EARLYSUSPEND
+	depends on HAS_EARLYSUSPEND
+
+	config NO_USER_SPACE_SCREEN_ACCESS_CONTROL
+		bool "None"
+
+	config CONSOLE_EARLYSUSPEND
+		bool "Console switch on early-suspend"
+		depends on HAS_EARLYSUSPEND && VT
+		---help---
+		  Register early suspend handler to perform a console switch to
+		  when user-space should stop drawing to the screen and a switch
+		  back when it should resume.
+
+	config FB_EARLYSUSPEND
+		bool "Sysfs interface"
+		depends on HAS_EARLYSUSPEND
+		---help---
+		  Register early suspend handler that notifies and waits for
+		  user-space through sysfs when user-space should stop drawing
+		  to the screen and notifies user-space when it should resume.
+endchoice
+
 config HIBERNATION
 	bool "Hibernation (aka 'suspend to disk')"
 	depends on PM && SWAP && ARCH_HIBERNATION_POSSIBLE
diff -Nur linux-2.6.29/kernel/power/main.c linux-2.6.29-spica/kernel/power/main.c
--- linux-2.6.29/kernel/power/main.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/power/main.c	2010-05-06 12:42:45.684270633 +0700
@@ -22,6 +22,8 @@
 #include <linux/freezer.h>
 #include <linux/vmstat.h>
 #include <linux/syscalls.h>
+#include <linux/cpufreq.h>
+#include <linux/wakelock.h>
 
 #include "power.h"
 
@@ -30,6 +32,26 @@
 unsigned int pm_flags;
 EXPORT_SYMBOL(pm_flags);
 
+#if 1	// added by peres to show valid current state
+suspend_state_t global_state;
+#endif
+
+#ifndef FEATURE_FTM_SLEEP
+#define FEATURE_FTM_SLEEP
+#endif
+
+#ifdef FEATURE_FTM_SLEEP
+unsigned char ftm_sleep = 0;
+EXPORT_SYMBOL(ftm_sleep);
+
+void (*ftm_enable_usb_sw)(int mode);
+EXPORT_SYMBOL(ftm_enable_usb_sw);
+
+extern void wakelock_force_suspend(void);
+
+static struct wake_lock ftm_wake_lock;
+#endif
+
 #ifdef CONFIG_PM_SLEEP
 
 /* Routines for PM-transition notifications */
@@ -285,11 +307,22 @@
  *
  *	This function should be called after devices have been suspended.
  */
+#ifdef CONFIG_CPU_FREQ
+static char governor_name[CPUFREQ_NAME_LEN];
+static char userspace_governor[CPUFREQ_NAME_LEN] = "userspace";
+#endif /* CONFIG_CPU_FREQ */
 static int suspend_enter(suspend_state_t state)
 {
 	int error = 0;
 
 	device_pm_lock();
+#ifdef CONFIG_CPU_FREQ
+	cpufreq_get_cpufreq_name(0);
+	strcpy(governor_name, cpufreq_governor_name);
+	if(strnicmp(governor_name, userspace_governor, CPUFREQ_NAME_LEN)) {
+		cpufreq_set_policy(0, "performance");
+	}
+#endif /* CONFIG_CPU_FREQ */
 	arch_suspend_disable_irqs();
 	BUG_ON(!irqs_disabled());
 
@@ -308,6 +341,11 @@
 	device_power_up(PMSG_RESUME);
  Done:
 	arch_suspend_enable_irqs();
+#ifdef CONFIG_CPU_FREQ
+	if(strnicmp(governor_name, userspace_governor, CPUFREQ_NAME_LEN)) {
+		cpufreq_set_policy(0, governor_name);
+	}
+#endif /* CONFIG_CPU_FREQ */
 	BUG_ON(irqs_disabled());
 	device_pm_unlock();
 	return error;
@@ -392,6 +430,9 @@
 
 
 static const char * const pm_states[PM_SUSPEND_MAX] = {
+#ifdef CONFIG_EARLYSUSPEND
+	[PM_SUSPEND_ON]		= "on",
+#endif
 	[PM_SUSPEND_STANDBY]	= "standby",
 	[PM_SUSPEND_MEM]	= "mem",
 };
@@ -488,12 +529,22 @@
 {
 	char *s = buf;
 #ifdef CONFIG_SUSPEND
+#if 0	// deleted by peres for test
 	int i;
-
 	for (i = 0; i < PM_SUSPEND_MAX; i++) {
 		if (pm_states[i] && valid_state(i))
 			s += sprintf(s,"%s ", pm_states[i]);
 	}
+#else
+	switch(global_state) {
+		case PM_SUSPEND_ON :
+			s += sprintf(s,"%s ", pm_states[PM_SUSPEND_ON]);
+			break;
+		case PM_SUSPEND_MEM :
+			s += sprintf(s,"%s ", pm_states[PM_SUSPEND_MEM]);
+			break;
+	}
+#endif
 #endif
 #ifdef CONFIG_HIBERNATION
 	s += sprintf(s, "%s\n", "disk");
@@ -508,8 +559,15 @@
 static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
 			   const char *buf, size_t n)
 {
+#if 1	// added by peres to show valid current state
+	char *b = buf;
+#endif
 #ifdef CONFIG_SUSPEND
+#ifdef CONFIG_EARLYSUSPEND
+	suspend_state_t state = PM_SUSPEND_ON;
+#else
 	suspend_state_t state = PM_SUSPEND_STANDBY;
+#endif
 	const char * const *s;
 #endif
 	char *p;
@@ -530,9 +588,45 @@
 		if (*s && len == strlen(*s) && !strncmp(buf, *s, len))
 			break;
 	}
-	if (state < PM_SUSPEND_MAX && *s)
+
+	if (state < PM_SUSPEND_MAX && *s) {
+		printk(KERN_ERR "%s: state:%d (%s)\n", __func__, state, *s);
+#ifdef CONFIG_EARLYSUSPEND
+		if (state == PM_SUSPEND_ON || valid_state(state)) {
+#if 1	// added by peres to show valid current state
+			if(state == PM_SUSPEND_ON) {
+				if (ftm_sleep == 1) {
+					pr_info("%s: wake lock for FTM\n", __func__);
+					ftm_sleep = 0;
+					wake_lock_timeout(&ftm_wake_lock, 60 * HZ);
+					if (ftm_enable_usb_sw)
+						ftm_enable_usb_sw(1);
+				}
+				sprintf(b,"%s ", pm_states[PM_SUSPEND_ON]);
+				global_state = PM_SUSPEND_ON;
+			} else {
+				if (ftm_sleep == 1) { // when ftm sleep cmd 
+					if (ftm_enable_usb_sw)
+						ftm_enable_usb_sw(0);
+				}
+				sprintf(b,"%s ", pm_states[PM_SUSPEND_MEM]);
+				global_state = PM_SUSPEND_MEM;
+			}
+#endif
+			error = 0;
+			request_suspend_state(state);
+
+#ifdef FEATURE_FTM_SLEEP
+			if (ftm_sleep && global_state == PM_SUSPEND_MEM) {
+				wakelock_force_suspend();
+			}
+#endif /* FEATURE_FTM_SLEEP */
+		}
+#else
 		error = enter_state(state);
 #endif
+	}
+#endif
 
  Exit:
 	return error ? error : n;
@@ -540,6 +634,60 @@
 
 power_attr(state);
 
+#ifdef FEATURE_FTM_SLEEP /* for Factory Sleep cmd check */
+
+
+#define ftm_attr(_name) \
+static struct kobj_attribute _name##_attr = {	\
+	.attr	= {				\
+		.name = __stringify(_name),	\
+		.mode = 0777,			\
+	},					\
+	.show	= _name##_show,			\
+	.store	= _name##_store,		\
+}
+
+
+static ssize_t ftm_sleep_show(struct kobject *kobj, struct kobj_attribute *attr,
+			  char *buf)
+{
+	char *s = buf;
+#ifdef CONFIG_SUSPEND
+	switch(ftm_sleep) {
+		case 0 :
+			s += sprintf(s,"%d ", 0);
+			break;
+		case 1 :
+			s += sprintf(s,"%d ", 1);
+			break;
+	}
+#endif
+
+	if (s != buf)
+		/* convert the last space to a newline */
+		*(s-1) = '\n';
+
+	return (s - buf);
+}
+
+
+static ssize_t ftm_sleep_store(struct kobject *kobj, struct kobj_attribute *attr,
+			   const char *buf, size_t n)
+{
+	ssize_t ret = -EINVAL;
+	char *after;
+	unsigned char state = (unsigned char) simple_strtoul(buf, &after, 10);
+
+	ftm_sleep = state;
+        
+	return ret;
+
+}
+
+ftm_attr(ftm_sleep);
+#endif /* FEATURE_FTM_SLEEP */
+
+
 #ifdef CONFIG_PM_TRACE
 int pm_trace_enabled;
 
@@ -565,6 +713,11 @@
 power_attr(pm_trace);
 #endif /* CONFIG_PM_TRACE */
 
+#ifdef CONFIG_USER_WAKELOCK
+power_attr(wake_lock);
+power_attr(wake_unlock);
+#endif
+
 static struct attribute * g[] = {
 	&state_attr.attr,
 #ifdef CONFIG_PM_TRACE
@@ -573,6 +726,11 @@
 #if defined(CONFIG_PM_SLEEP) && defined(CONFIG_PM_DEBUG)
 	&pm_test_attr.attr,
 #endif
+#ifdef CONFIG_USER_WAKELOCK
+	&wake_lock_attr.attr,
+	&wake_unlock_attr.attr,
+#endif
+	&ftm_sleep_attr.attr,
 	NULL,
 };
 
@@ -586,6 +744,9 @@
 	power_kobj = kobject_create_and_add("power", NULL);
 	if (!power_kobj)
 		return -ENOMEM;
+
+	wake_lock_init(&ftm_wake_lock, WAKE_LOCK_SUSPEND, "ftm_wake_lock");
+
 	return sysfs_create_group(power_kobj, &attr_group);
 }
 
diff -Nur linux-2.6.29/kernel/power/Makefile linux-2.6.29-spica/kernel/power/Makefile
--- linux-2.6.29/kernel/power/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/power/Makefile	2010-03-30 11:01:39.000000000 +0700
@@ -6,6 +6,11 @@
 obj-$(CONFIG_PM)		+= main.o
 obj-$(CONFIG_PM_SLEEP)		+= console.o
 obj-$(CONFIG_FREEZER)		+= process.o
+obj-$(CONFIG_WAKELOCK)		+= wakelock.o
+obj-$(CONFIG_USER_WAKELOCK)	+= userwakelock.o
+obj-$(CONFIG_EARLYSUSPEND)	+= earlysuspend.o
+obj-$(CONFIG_CONSOLE_EARLYSUSPEND)	+= consoleearlysuspend.o
+obj-$(CONFIG_FB_EARLYSUSPEND)	+= fbearlysuspend.o
 obj-$(CONFIG_HIBERNATION)	+= swsusp.o disk.o snapshot.o swap.o user.o
 
 obj-$(CONFIG_MAGIC_SYSRQ)	+= poweroff.o
diff -Nur linux-2.6.29/kernel/power/power.h linux-2.6.29-spica/kernel/power/power.h
--- linux-2.6.29/kernel/power/power.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/power/power.h	2010-03-30 11:01:39.000000000 +0700
@@ -223,3 +223,27 @@
 {
 }
 #endif
+
+#ifdef CONFIG_WAKELOCK
+/* kernel/power/wakelock.c */
+extern struct workqueue_struct *suspend_work_queue;
+extern struct wake_lock main_wake_lock;
+extern suspend_state_t requested_suspend_state;
+#endif
+
+#ifdef CONFIG_USER_WAKELOCK
+ssize_t wake_lock_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf);
+ssize_t wake_lock_store(struct kobject *kobj, struct kobj_attribute *attr,
+			const char *buf, size_t n);
+ssize_t wake_unlock_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf);
+ssize_t  wake_unlock_store(struct kobject *kobj, struct kobj_attribute *attr,
+			const char *buf, size_t n);
+#endif
+
+#ifdef CONFIG_EARLYSUSPEND
+/* kernel/power/earlysuspend.c */
+void request_suspend_state(suspend_state_t state);
+suspend_state_t get_suspend_state(void);
+#endif
diff -Nur linux-2.6.29/kernel/power/process.c linux-2.6.29-spica/kernel/power/process.c
--- linux-2.6.29/kernel/power/process.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/power/process.c	2010-03-30 11:01:39.000000000 +0700
@@ -13,6 +13,7 @@
 #include <linux/module.h>
 #include <linux/syscalls.h>
 #include <linux/freezer.h>
+#include <linux/wakelock.h>
 
 /* 
  * Timeout for stopping processes
@@ -36,6 +37,7 @@
 	struct timeval start, end;
 	u64 elapsed_csecs64;
 	unsigned int elapsed_csecs;
+	unsigned int wakeup = 0;
 
 	do_gettimeofday(&start);
 
@@ -62,6 +64,10 @@
 		} while_each_thread(g, p);
 		read_unlock(&tasklist_lock);
 		yield();			/* Yield is okay here */
+		if (todo && has_wake_lock(WAKE_LOCK_SUSPEND)) {
+			wakeup = 1;
+			break;
+		}
 		if (time_after(jiffies, end_time))
 			break;
 	} while (todo);
@@ -77,11 +83,18 @@
 		 * and caller must call thaw_processes() if something fails),
 		 * but it cleans up leftover PF_FREEZE requests.
 		 */
-		printk("\n");
-		printk(KERN_ERR "Freezing of tasks failed after %d.%02d seconds "
-				"(%d tasks refusing to freeze):\n",
-				elapsed_csecs / 100, elapsed_csecs % 100, todo);
-		show_state();
+		if(wakeup) {
+			printk("\n");
+			printk(KERN_ERR "Freezing of %s aborted\n",
+					sig_only ? "user space " : "tasks ");
+		}
+		else {
+			printk("\n");
+			printk(KERN_ERR "Freezing of tasks failed after %d.%02d seconds "
+					"(%d tasks refusing to freeze):\n",
+					elapsed_csecs / 100, elapsed_csecs % 100, todo);
+			show_state();
+		}
 		read_lock(&tasklist_lock);
 		do_each_thread(g, p) {
 			task_lock(p);
diff -Nur linux-2.6.29/kernel/power/userwakelock.c linux-2.6.29-spica/kernel/power/userwakelock.c
--- linux-2.6.29/kernel/power/userwakelock.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/kernel/power/userwakelock.c	2010-03-30 11:01:39.000000000 +0700
@@ -0,0 +1,218 @@
+/* kernel/power/userwakelock.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/ctype.h>
+#include <linux/module.h>
+#include <linux/wakelock.h>
+
+#include "power.h"
+
+enum {
+	DEBUG_FAILURE	= BIT(0),
+	DEBUG_ERROR	= BIT(1),
+	DEBUG_NEW	= BIT(2),
+	DEBUG_ACCESS	= BIT(3),
+	DEBUG_LOOKUP	= BIT(4),
+};
+static int debug_mask = DEBUG_FAILURE;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+static DEFINE_MUTEX(tree_lock);
+
+struct user_wake_lock {
+	struct rb_node		node;
+	struct wake_lock	wake_lock;
+	char			name[0];
+};
+struct rb_root user_wake_locks;
+
+static struct user_wake_lock *lookup_wake_lock_name(
+	const char *buf, int allocate, long *timeoutptr)
+{
+	struct rb_node **p = &user_wake_locks.rb_node;
+	struct rb_node *parent = NULL;
+	struct user_wake_lock *l;
+	int diff;
+	u64 timeout;
+	int name_len;
+	const char *arg;
+
+	/* Find length of lock name and start of optional timeout string */
+	arg = buf;
+	while (*arg && !isspace(*arg))
+		arg++;
+	name_len = arg - buf;
+	if (!name_len)
+		goto bad_arg;
+	while (isspace(*arg))
+		arg++;
+
+	/* Process timeout string */
+	if (timeoutptr && *arg) {
+		timeout = simple_strtoull(arg, (char **)&arg, 0);
+		while (isspace(*arg))
+			arg++;
+		if (*arg)
+			goto bad_arg;
+		/* convert timeout from nanoseconds to jiffies > 0 */
+		timeout += (NSEC_PER_SEC / HZ) - 1;
+		do_div(timeout, (NSEC_PER_SEC / HZ));
+		if (timeout <= 0)
+			timeout = 1;
+		*timeoutptr = timeout;
+	} else if (*arg)
+		goto bad_arg;
+	else if (timeoutptr)
+		*timeoutptr = 0;
+
+	/* Lookup wake lock in rbtree */
+	while (*p) {
+		parent = *p;
+		l = rb_entry(parent, struct user_wake_lock, node);
+		diff = strncmp(buf, l->name, name_len);
+		if (!diff && l->name[name_len])
+			diff = -1;
+		if (debug_mask & DEBUG_ERROR)
+			pr_info("lookup_wake_lock_name: compare %.*s %s %d\n",
+				name_len, buf, l->name, diff);
+
+		if (diff < 0)
+			p = &(*p)->rb_left;
+		else if (diff > 0)
+			p = &(*p)->rb_right;
+		else
+			return l;
+	}
+
+	/* Allocate and add new wakelock to rbtree */
+	if (!allocate) {
+		if (debug_mask & DEBUG_ERROR)
+			pr_info("lookup_wake_lock_name: %.*s not found\n",
+				name_len, buf);
+		return ERR_PTR(-EINVAL);
+	}
+	l = kzalloc(sizeof(*l) + name_len + 1, GFP_KERNEL);
+	if (l == NULL) {
+		if (debug_mask & DEBUG_FAILURE)
+			pr_err("lookup_wake_lock_name: failed to allocate "
+				"memory for %.*s\n", name_len, buf);
+		return ERR_PTR(-ENOMEM);
+	}
+	memcpy(l->name, buf, name_len);
+	if (debug_mask & DEBUG_NEW)
+		pr_info("lookup_wake_lock_name: new wake lock %s\n", l->name);
+	wake_lock_init(&l->wake_lock, WAKE_LOCK_SUSPEND, l->name);
+	rb_link_node(&l->node, parent, p);
+	rb_insert_color(&l->node, &user_wake_locks);
+	return l;
+
+bad_arg:
+	if (debug_mask & DEBUG_ERROR)
+		pr_info("lookup_wake_lock_name: wake lock, %.*s, bad arg, %s\n",
+			name_len, buf, arg);
+	return ERR_PTR(-EINVAL);
+}
+
+ssize_t wake_lock_show(
+	struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	char *s = buf;
+	char *end = buf + PAGE_SIZE;
+	struct rb_node *n;
+	struct user_wake_lock *l;
+
+	mutex_lock(&tree_lock);
+
+	for (n = rb_first(&user_wake_locks); n != NULL; n = rb_next(n)) {
+		l = rb_entry(n, struct user_wake_lock, node);
+		if (wake_lock_active(&l->wake_lock))
+			s += scnprintf(s, end - s, "%s ", l->name);
+	}
+	s += scnprintf(s, end - s, "\n");
+
+	mutex_unlock(&tree_lock);
+	return (s - buf);
+}
+
+ssize_t wake_lock_store(
+	struct kobject *kobj, struct kobj_attribute *attr,
+	const char *buf, size_t n)
+{
+	long timeout;
+	struct user_wake_lock *l;
+
+	mutex_lock(&tree_lock);
+	l = lookup_wake_lock_name(buf, 1, &timeout);
+	if (IS_ERR(l)) {
+		n = PTR_ERR(l);
+		goto bad_name;
+	}
+
+	if (debug_mask & DEBUG_ACCESS)
+		pr_info("wake_lock_store: %s, timeout %ld\n", l->name, timeout);
+
+	if (timeout)
+		wake_lock_timeout(&l->wake_lock, timeout);
+	else
+		wake_lock(&l->wake_lock);
+bad_name:
+	mutex_unlock(&tree_lock);
+	return n;
+}
+
+
+ssize_t wake_unlock_show(
+	struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	char *s = buf;
+	char *end = buf + PAGE_SIZE;
+	struct rb_node *n;
+	struct user_wake_lock *l;
+
+	mutex_lock(&tree_lock);
+
+	for (n = rb_first(&user_wake_locks); n != NULL; n = rb_next(n)) {
+		l = rb_entry(n, struct user_wake_lock, node);
+		if (!wake_lock_active(&l->wake_lock))
+			s += scnprintf(s, end - s, "%s ", l->name);
+	}
+	s += scnprintf(s, end - s, "\n");
+
+	mutex_unlock(&tree_lock);
+	return (s - buf);
+}
+
+ssize_t wake_unlock_store(
+	struct kobject *kobj, struct kobj_attribute *attr,
+	const char *buf, size_t n)
+{
+	struct user_wake_lock *l;
+
+	mutex_lock(&tree_lock);
+	l = lookup_wake_lock_name(buf, 0, NULL);
+	if (IS_ERR(l)) {
+		n = PTR_ERR(l);
+		goto not_found;
+	}
+
+	if (debug_mask & DEBUG_ACCESS)
+		pr_info("wake_unlock_store: %s\n", l->name);
+
+	wake_unlock(&l->wake_lock);
+not_found:
+	mutex_unlock(&tree_lock);
+	return n;
+}
+
diff -Nur linux-2.6.29/kernel/power/wakelock.c linux-2.6.29-spica/kernel/power/wakelock.c
--- linux-2.6.29/kernel/power/wakelock.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/kernel/power/wakelock.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,615 @@
+/* kernel/power/wakelock.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+#include <linux/suspend.h>
+#include <linux/syscalls.h> /* sys_sync */
+#include <linux/wakelock.h>
+#ifdef CONFIG_WAKELOCK_STAT
+#include <linux/proc_fs.h>
+#endif
+#include "power.h"
+
+enum {
+	DEBUG_EXIT_SUSPEND = 1U << 0,
+	DEBUG_WAKEUP = 1U << 1,
+	DEBUG_SUSPEND = 1U << 2,
+	DEBUG_EXPIRE = 1U << 3,
+	DEBUG_WAKE_LOCK = 1U << 4,
+};
+static int debug_mask = DEBUG_EXIT_SUSPEND | DEBUG_WAKEUP;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+#define WAKE_LOCK_TYPE_MASK              (0x0f)
+#define WAKE_LOCK_INITIALIZED            (1U << 8)
+#define WAKE_LOCK_ACTIVE                 (1U << 9)
+#define WAKE_LOCK_AUTO_EXPIRE            (1U << 10)
+#define WAKE_LOCK_PREVENTING_SUSPEND     (1U << 11)
+
+#define TOO_MAY_LOCKS_WARNING		"\n\ntoo many wakelocks!!!\n"
+
+static DEFINE_SPINLOCK(list_lock);
+static LIST_HEAD(inactive_locks);
+static struct list_head active_wake_locks[WAKE_LOCK_TYPE_COUNT];
+static int current_event_num;
+struct workqueue_struct *suspend_work_queue;
+struct wake_lock main_wake_lock;
+suspend_state_t requested_suspend_state = PM_SUSPEND_MEM;
+static struct wake_lock unknown_wakeup;
+
+#ifdef CONFIG_WAKELOCK_STAT
+static struct wake_lock deleted_wake_locks;
+static ktime_t last_sleep_time_update;
+static int wait_for_wakeup;
+
+int get_expired_time(struct wake_lock *lock, ktime_t *expire_time)
+{
+	struct timespec ts;
+	struct timespec kt;
+	struct timespec tomono;
+	struct timespec delta;
+	unsigned long seq;
+	long timeout;
+
+	if (!(lock->flags & WAKE_LOCK_AUTO_EXPIRE))
+		return 0;
+	do {
+		seq = read_seqbegin(&xtime_lock);
+		timeout = lock->expires - jiffies;
+		if (timeout > 0)
+			return 0;
+		kt = current_kernel_time();
+		tomono = wall_to_monotonic;
+	} while (read_seqretry(&xtime_lock, seq));
+	jiffies_to_timespec(-timeout, &delta);
+	set_normalized_timespec(&ts, kt.tv_sec + tomono.tv_sec - delta.tv_sec,
+				kt.tv_nsec + tomono.tv_nsec - delta.tv_nsec);
+	*expire_time = timespec_to_ktime(ts);
+	return 1;
+}
+
+
+static int print_lock_stat(char *buf, int len, struct wake_lock *lock)
+{
+	int lock_count = lock->stat.count;
+	int expire_count = lock->stat.expire_count;
+	ktime_t active_time = ktime_set(0, 0);
+	ktime_t total_time = lock->stat.total_time;
+	ktime_t max_time = lock->stat.max_time;
+	int n;
+
+	ktime_t prevent_suspend_time = lock->stat.prevent_suspend_time;
+	if (lock->flags & WAKE_LOCK_ACTIVE) {
+		ktime_t now, add_time;
+		int expired = get_expired_time(lock, &now);
+		if (!expired)
+			now = ktime_get();
+		add_time = ktime_sub(now, lock->stat.last_time);
+		lock_count++;
+		if (!expired)
+			active_time = add_time;
+		else
+			expire_count++;
+		total_time = ktime_add(total_time, add_time);
+		if (lock->flags & WAKE_LOCK_PREVENTING_SUSPEND)
+			prevent_suspend_time = ktime_add(prevent_suspend_time,
+					ktime_sub(now, last_sleep_time_update));
+		if (add_time.tv64 > max_time.tv64)
+			max_time = add_time;
+	}
+
+	n = snprintf(buf, len,
+		     "\"%s\"\t%d\t%d\t%d\t%lld\t%lld\t%lld\t%lld\t%lld\n",
+		     lock->name, lock_count, expire_count,
+		     lock->stat.wakeup_count, ktime_to_ns(active_time),
+		     ktime_to_ns(total_time),
+		     ktime_to_ns(prevent_suspend_time), ktime_to_ns(max_time),
+		     ktime_to_ns(lock->stat.last_time));
+
+	return n > len ? len : n;
+}
+
+
+static int wakelocks_read_proc(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	unsigned long irqflags;
+	struct wake_lock *lock;
+	int len = 0;
+	int type;
+
+	spin_lock_irqsave(&list_lock, irqflags);
+
+	len += snprintf(page + len, count - len,
+			"name\tcount\texpire_count\twake_count\tactive_since"
+			"\ttotal_time\tsleep_time\tmax_time\tlast_change\n");
+	list_for_each_entry(lock, &inactive_locks, link) {
+		len += print_lock_stat(page + len, count - len, lock);
+	}
+	for (type = 0; type < WAKE_LOCK_TYPE_COUNT; type++) {
+		list_for_each_entry(lock, &active_wake_locks[type], link)
+			len += print_lock_stat(page + len, count - len, lock);
+	}
+	spin_unlock_irqrestore(&list_lock, irqflags);
+
+	if (len == count)
+		memcpy(page + len - strlen(TOO_MAY_LOCKS_WARNING),
+		       TOO_MAY_LOCKS_WARNING,
+		       strlen(TOO_MAY_LOCKS_WARNING));
+
+	*eof = 1;
+
+	return len;
+}
+
+static void wake_unlock_stat_locked(struct wake_lock *lock, int expired)
+{
+	ktime_t duration;
+	ktime_t now;
+	if (!(lock->flags & WAKE_LOCK_ACTIVE))
+		return;
+	if (get_expired_time(lock, &now))
+		expired = 1;
+	else
+		now = ktime_get();
+	lock->stat.count++;
+	if (expired)
+		lock->stat.expire_count++;
+	duration = ktime_sub(now, lock->stat.last_time);
+	lock->stat.total_time = ktime_add(lock->stat.total_time, duration);
+	if (ktime_to_ns(duration) > ktime_to_ns(lock->stat.max_time))
+		lock->stat.max_time = duration;
+	lock->stat.last_time = ktime_get();
+	if (lock->flags & WAKE_LOCK_PREVENTING_SUSPEND) {
+		duration = ktime_sub(now, last_sleep_time_update);
+		lock->stat.prevent_suspend_time = ktime_add(
+			lock->stat.prevent_suspend_time, duration);
+		lock->flags &= ~WAKE_LOCK_PREVENTING_SUSPEND;
+	}
+}
+
+static void update_sleep_wait_stats_locked(int done)
+{
+	struct wake_lock *lock;
+	ktime_t now, etime, elapsed, add;
+	int expired;
+
+	now = ktime_get();
+	elapsed = ktime_sub(now, last_sleep_time_update);
+	list_for_each_entry(lock, &active_wake_locks[WAKE_LOCK_SUSPEND], link) {
+		expired = get_expired_time(lock, &etime);
+		if (lock->flags & WAKE_LOCK_PREVENTING_SUSPEND) {
+			if (expired)
+				add = ktime_sub(etime, last_sleep_time_update);
+			else
+				add = elapsed;
+			lock->stat.prevent_suspend_time = ktime_add(
+				lock->stat.prevent_suspend_time, add);
+		}
+		if (done || expired)
+			lock->flags &= ~WAKE_LOCK_PREVENTING_SUSPEND;
+		else
+			lock->flags |= WAKE_LOCK_PREVENTING_SUSPEND;
+	}
+	last_sleep_time_update = now;
+}
+#endif
+
+
+static void expire_wake_lock(struct wake_lock *lock)
+{
+#ifdef CONFIG_WAKELOCK_STAT
+	wake_unlock_stat_locked(lock, 1);
+#endif
+	lock->flags &= ~(WAKE_LOCK_ACTIVE | WAKE_LOCK_AUTO_EXPIRE);
+	list_del(&lock->link);
+	list_add(&lock->link, &inactive_locks);
+	if (debug_mask & (DEBUG_WAKE_LOCK | DEBUG_EXPIRE))
+		pr_info("expired wake lock %s\n", lock->name);
+}
+
+/* Caller must acquire the list_lock spinlock */
+static void print_active_locks(int type)
+{
+	unsigned long irqflags;
+	struct wake_lock *lock;
+
+	BUG_ON(type >= WAKE_LOCK_TYPE_COUNT);
+	list_for_each_entry(lock, &active_wake_locks[type], link) {
+		if (lock->flags & WAKE_LOCK_AUTO_EXPIRE) {
+			long timeout = lock->expires - jiffies;
+			if (timeout <= 0)
+				pr_info("wake lock %s, expired\n", lock->name);
+			else
+				pr_info("active wake lock %s, time left %ld\n",
+					lock->name, timeout);
+		} else
+			pr_info("active wake lock %s\n", lock->name);
+	}
+}
+
+static long has_wake_lock_locked(int type)
+{
+	struct wake_lock *lock, *n;
+	long max_timeout = 0;
+
+	BUG_ON(type >= WAKE_LOCK_TYPE_COUNT);
+	list_for_each_entry_safe(lock, n, &active_wake_locks[type], link) {
+		if (lock->flags & WAKE_LOCK_AUTO_EXPIRE) {
+			long timeout = lock->expires - jiffies;
+			if (timeout <= 0)
+				expire_wake_lock(lock);
+			else if (timeout > max_timeout)
+				max_timeout = timeout;
+		} else
+			return -1;
+	}
+	return max_timeout;
+}
+
+extern unsigned char ftm_sleep;
+long has_wake_lock(int type)
+{
+	long ret;
+	unsigned long irqflags;
+
+	if (ftm_sleep)
+		return 0;
+
+	spin_lock_irqsave(&list_lock, irqflags);
+	ret = has_wake_lock_locked(type);
+	spin_unlock_irqrestore(&list_lock, irqflags);
+	return ret;
+}
+
+static void suspend(struct work_struct *work)
+{
+	int ret;
+	int entry_event_num;
+
+	if (has_wake_lock(WAKE_LOCK_SUSPEND)) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("suspend: abort suspend\n");
+		return;
+	}
+
+	entry_event_num = current_event_num;
+	sys_sync();
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("suspend: enter suspend\n");
+	ret = pm_suspend(requested_suspend_state);
+	if (debug_mask & DEBUG_EXIT_SUSPEND) {
+		struct timespec ts;
+		struct rtc_time tm;
+		getnstimeofday(&ts);
+		rtc_time_to_tm(ts.tv_sec, &tm);
+		pr_info("suspend: exit suspend, ret = %d "
+			"(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n", ret,
+			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
+	}
+	if (current_event_num == entry_event_num) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("suspend: pm_suspend returned with no event\n");
+		wake_lock_timeout(&unknown_wakeup, HZ / 2);
+	}
+}
+static DECLARE_WORK(suspend_work, suspend);
+
+static void expire_wake_locks(unsigned long data)
+{
+	long has_lock;
+	unsigned long irqflags;
+	if (debug_mask & DEBUG_EXPIRE)
+		pr_info("expire_wake_locks: start\n");
+	spin_lock_irqsave(&list_lock, irqflags);
+	if (debug_mask & DEBUG_SUSPEND)
+		print_active_locks(WAKE_LOCK_SUSPEND);
+	has_lock = has_wake_lock_locked(WAKE_LOCK_SUSPEND);
+	if (debug_mask & DEBUG_EXPIRE)
+		pr_info("expire_wake_locks: done, has_lock %ld\n", has_lock);
+	if (has_lock == 0)
+		queue_work(suspend_work_queue, &suspend_work);
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+static DEFINE_TIMER(expire_timer, expire_wake_locks, 0, 0);
+
+static int power_suspend_late(struct platform_device *pdev, pm_message_t state)
+{
+	int ret = has_wake_lock(WAKE_LOCK_SUSPEND) ? -EAGAIN : 0;
+#ifdef CONFIG_WAKELOCK_STAT
+	wait_for_wakeup = 1;
+#endif
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("power_suspend_late return %d\n", ret);
+	return ret;
+}
+
+static struct platform_driver power_driver = {
+	.driver.name = "power",
+	.suspend_late = power_suspend_late,
+};
+static struct platform_device power_device = {
+	.name = "power",
+};
+
+void wake_lock_init(struct wake_lock *lock, int type, const char *name)
+{
+	unsigned long irqflags = 0;
+
+	if (name)
+		lock->name = name;
+	BUG_ON(!lock->name);
+
+	if (debug_mask & DEBUG_WAKE_LOCK)
+		pr_info("wake_lock_init name=%s\n", lock->name);
+#ifdef CONFIG_WAKELOCK_STAT
+	lock->stat.count = 0;
+	lock->stat.expire_count = 0;
+	lock->stat.wakeup_count = 0;
+	lock->stat.total_time = ktime_set(0, 0);
+	lock->stat.prevent_suspend_time = ktime_set(0, 0);
+	lock->stat.max_time = ktime_set(0, 0);
+	lock->stat.last_time = ktime_set(0, 0);
+#endif
+	lock->flags = (type & WAKE_LOCK_TYPE_MASK) | WAKE_LOCK_INITIALIZED;
+
+	INIT_LIST_HEAD(&lock->link);
+	spin_lock_irqsave(&list_lock, irqflags);
+	list_add(&lock->link, &inactive_locks);
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+EXPORT_SYMBOL(wake_lock_init);
+
+void wake_lock_destroy(struct wake_lock *lock)
+{
+	unsigned long irqflags;
+	if (debug_mask & DEBUG_WAKE_LOCK)
+		pr_info("wake_lock_destroy name=%s\n", lock->name);
+	spin_lock_irqsave(&list_lock, irqflags);
+	lock->flags &= ~WAKE_LOCK_INITIALIZED;
+#ifdef CONFIG_WAKELOCK_STAT
+	if (lock->stat.count) {
+		deleted_wake_locks.stat.count += lock->stat.count;
+		deleted_wake_locks.stat.expire_count += lock->stat.expire_count;
+		deleted_wake_locks.stat.total_time =
+			ktime_add(deleted_wake_locks.stat.total_time,
+				  lock->stat.total_time);
+		deleted_wake_locks.stat.prevent_suspend_time =
+			ktime_add(deleted_wake_locks.stat.prevent_suspend_time,
+				  lock->stat.prevent_suspend_time);
+		deleted_wake_locks.stat.max_time =
+			ktime_add(deleted_wake_locks.stat.max_time,
+				  lock->stat.max_time);
+	}
+#endif
+	list_del(&lock->link);
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+EXPORT_SYMBOL(wake_lock_destroy);
+
+static void wake_lock_internal(
+	struct wake_lock *lock, long timeout, int has_timeout)
+{
+	int type;
+	unsigned long irqflags;
+	long expire_in;
+
+	spin_lock_irqsave(&list_lock, irqflags);
+	type = lock->flags & WAKE_LOCK_TYPE_MASK;
+	BUG_ON(type >= WAKE_LOCK_TYPE_COUNT);
+	BUG_ON(!(lock->flags & WAKE_LOCK_INITIALIZED));
+#ifdef CONFIG_WAKELOCK_STAT
+	if (type == WAKE_LOCK_SUSPEND && wait_for_wakeup) {
+		if (debug_mask & DEBUG_WAKEUP)
+			pr_info("wakeup wake lock: %s\n", lock->name);
+		wait_for_wakeup = 0;
+		lock->stat.wakeup_count++;
+	}
+	if ((lock->flags & WAKE_LOCK_AUTO_EXPIRE) &&
+	    (long)(lock->expires - jiffies) <= 0) {
+		wake_unlock_stat_locked(lock, 0);
+		lock->stat.last_time = ktime_get();
+	}
+#endif
+	if (!(lock->flags & WAKE_LOCK_ACTIVE)) {
+		lock->flags |= WAKE_LOCK_ACTIVE;
+#ifdef CONFIG_WAKELOCK_STAT
+		lock->stat.last_time = ktime_get();
+#endif
+	}
+	list_del(&lock->link);
+	if (has_timeout) {
+		if (debug_mask & DEBUG_WAKE_LOCK)
+			pr_info("wake_lock: %s, type %d, timeout %ld.%03lu\n",
+				lock->name, type, timeout / HZ,
+				(timeout % HZ) * MSEC_PER_SEC / HZ);
+		lock->expires = jiffies + timeout;
+		lock->flags |= WAKE_LOCK_AUTO_EXPIRE;
+		list_add_tail(&lock->link, &active_wake_locks[type]);
+	} else {
+		if (debug_mask & DEBUG_WAKE_LOCK)
+			pr_info("wake_lock: %s, type %d\n", lock->name, type);
+		lock->expires = LONG_MAX;
+		lock->flags &= ~WAKE_LOCK_AUTO_EXPIRE;
+		list_add(&lock->link, &active_wake_locks[type]);
+	}
+	if (type == WAKE_LOCK_SUSPEND) {
+		current_event_num++;
+#ifdef CONFIG_WAKELOCK_STAT
+		if (lock == &main_wake_lock)
+			update_sleep_wait_stats_locked(1);
+		else if (!wake_lock_active(&main_wake_lock))
+			update_sleep_wait_stats_locked(0);
+#endif
+		if (has_timeout)
+			expire_in = has_wake_lock_locked(type);
+		else
+			expire_in = -1;
+		if (expire_in > 0) {
+			if (debug_mask & DEBUG_EXPIRE)
+				pr_info("wake_lock: %s, start expire timer, "
+					"%ld\n", lock->name, expire_in);
+			mod_timer(&expire_timer, jiffies + expire_in);
+		} else {
+			if (del_timer(&expire_timer))
+				if (debug_mask & DEBUG_EXPIRE)
+					pr_info("wake_lock: %s, stop expire timer\n",
+						lock->name);
+			if (expire_in == 0)
+				queue_work(suspend_work_queue, &suspend_work);
+		}
+	}
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+
+void wake_lock(struct wake_lock *lock)
+{
+	wake_lock_internal(lock, 0, 0);
+}
+EXPORT_SYMBOL(wake_lock);
+
+void wake_lock_timeout(struct wake_lock *lock, long timeout)
+{
+	wake_lock_internal(lock, timeout, 1);
+}
+EXPORT_SYMBOL(wake_lock_timeout);
+
+void wake_unlock(struct wake_lock *lock)
+{
+	int type;
+	unsigned long irqflags;
+	spin_lock_irqsave(&list_lock, irqflags);
+	type = lock->flags & WAKE_LOCK_TYPE_MASK;
+#ifdef CONFIG_WAKELOCK_STAT
+	wake_unlock_stat_locked(lock, 0);
+#endif
+	if (debug_mask & DEBUG_WAKE_LOCK)
+		pr_info("wake_unlock: %s\n", lock->name);
+	lock->flags &= ~(WAKE_LOCK_ACTIVE | WAKE_LOCK_AUTO_EXPIRE);
+	list_del(&lock->link);
+	list_add(&lock->link, &inactive_locks);
+	if (type == WAKE_LOCK_SUSPEND) {
+		long has_lock = has_wake_lock_locked(type);
+		if (has_lock > 0) {
+			if (debug_mask & DEBUG_EXPIRE)
+				pr_info("wake_unlock: %s, start expire timer, "
+					"%ld\n", lock->name, has_lock);
+			mod_timer(&expire_timer, jiffies + has_lock);
+		} else {
+			if (del_timer(&expire_timer))
+				if (debug_mask & DEBUG_EXPIRE)
+					pr_info("wake_unlock: %s, stop expire "
+						"timer\n", lock->name);
+			if (has_lock == 0)
+				queue_work(suspend_work_queue, &suspend_work);
+		}
+		if (lock == &main_wake_lock) {
+			if (debug_mask & DEBUG_SUSPEND)
+				print_active_locks(WAKE_LOCK_SUSPEND);
+#ifdef CONFIG_WAKELOCK_STAT
+			update_sleep_wait_stats_locked(0);
+#endif
+		}
+	}
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+EXPORT_SYMBOL(wake_unlock);
+
+int wake_lock_active(struct wake_lock *lock)
+{
+	return !!(lock->flags & WAKE_LOCK_ACTIVE);
+}
+EXPORT_SYMBOL(wake_lock_active);
+
+void wakelock_force_suspend(void)
+{
+	pr_info("%s: suspend!!!!!\n", __func__);
+	queue_work(suspend_work_queue, &suspend_work);
+}
+EXPORT_SYMBOL(wakelock_force_suspend);
+
+static int __init wakelocks_init(void)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(active_wake_locks); i++)
+		INIT_LIST_HEAD(&active_wake_locks[i]);
+
+#ifdef CONFIG_WAKELOCK_STAT
+	wake_lock_init(&deleted_wake_locks, WAKE_LOCK_SUSPEND,
+			"deleted_wake_locks");
+#endif
+	wake_lock_init(&main_wake_lock, WAKE_LOCK_SUSPEND, "main");
+	wake_lock(&main_wake_lock);
+	wake_lock_init(&unknown_wakeup, WAKE_LOCK_SUSPEND, "unknown_wakeups");
+
+	ret = platform_device_register(&power_device);
+	if (ret) {
+		pr_err("wakelocks_init: platform_device_register failed\n");
+		goto err_platform_device_register;
+	}
+	ret = platform_driver_register(&power_driver);
+	if (ret) {
+		pr_err("wakelocks_init: platform_driver_register failed\n");
+		goto err_platform_driver_register;
+	}
+
+	suspend_work_queue = create_singlethread_workqueue("suspend");
+	if (suspend_work_queue == NULL) {
+		ret = -ENOMEM;
+		goto err_suspend_work_queue;
+	}
+
+#ifdef CONFIG_WAKELOCK_STAT
+	create_proc_read_entry("wakelocks", S_IRUGO, NULL,
+				wakelocks_read_proc, NULL);
+#endif
+
+	return 0;
+
+err_suspend_work_queue:
+	platform_driver_unregister(&power_driver);
+err_platform_driver_register:
+	platform_device_unregister(&power_device);
+err_platform_device_register:
+	wake_lock_destroy(&unknown_wakeup);
+	wake_lock_destroy(&main_wake_lock);
+#ifdef CONFIG_WAKELOCK_STAT
+	wake_lock_destroy(&deleted_wake_locks);
+#endif
+	return ret;
+}
+
+static void  __exit wakelocks_exit(void)
+{
+#ifdef CONFIG_WAKELOCK_STAT
+	remove_proc_entry("wakelocks", NULL);
+#endif
+	destroy_workqueue(suspend_work_queue);
+	platform_driver_unregister(&power_driver);
+	platform_device_unregister(&power_device);
+	wake_lock_destroy(&unknown_wakeup);
+	wake_lock_destroy(&main_wake_lock);
+#ifdef CONFIG_WAKELOCK_STAT
+	wake_lock_destroy(&deleted_wake_locks);
+#endif
+}
+
+core_initcall(wakelocks_init);
+module_exit(wakelocks_exit);
diff -Nur linux-2.6.29/kernel/printk.c linux-2.6.29-spica/kernel/printk.c
--- linux-2.6.29/kernel/printk.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/printk.c	2010-05-06 12:42:45.684270633 +0700
@@ -44,6 +44,10 @@
 
 #define __LOG_BUF_LEN	(1 << CONFIG_LOG_BUF_SHIFT)
 
+#ifdef        CONFIG_DEBUG_LL
+extern void printascii(char *);
+#endif
+
 /* printk's without a loglevel use this.. */
 #define DEFAULT_MESSAGE_LOGLEVEL 4 /* KERN_WARNING */
 
@@ -135,6 +139,17 @@
 static int log_buf_len = __LOG_BUF_LEN;
 static unsigned logged_chars; /* Number of chars produced since last read+clear operation */
 
+/* RAM Dump Info */
+
+#include <linux/sec_log.h>
+
+static struct struct_kernel_log_mark kernel_log_mark = {
+	.special_mark_1 = (('*' << 24) | ('^' << 16) | ('^' << 8) | ('*' << 0)),
+	.special_mark_2 = (('I' << 24) | ('n' << 16) | ('f' << 8) | ('o' << 0)),
+	.special_mark_3 = (('H' << 24) | ('e' << 16) | ('r' << 8) | ('e' << 0)),
+	.special_mark_4 = (('k' << 24) | ('l' << 16) | ('o' << 8) | ('g' << 0)),
+	.p__log_buf = __log_buf, 
+};
 static int __init log_buf_len_setup(char *str)
 {
 	unsigned size = memparse(str, &str);
@@ -171,6 +186,7 @@
 		printk(KERN_NOTICE "log_buf_len: %d\n", log_buf_len);
 	}
 out:
+	kernel_log_mark.p__log_buf = log_buf;
 	return 1;
 }
 
@@ -232,6 +248,53 @@
 #endif
 
 /*
+ * Return the number of unread characters in the log buffer.
+ */
+static int log_buf_get_len(void)
+{
+	return logged_chars;
+}
+
+/*
+ * Clears the ring-buffer
+ */
+void log_buf_clear(void)
+{
+	logged_chars = 0;
+}
+
+/*
+ * Copy a range of characters from the log buffer.
+ */
+int log_buf_copy(char *dest, int idx, int len)
+{
+	int ret, max;
+	bool took_lock = false;
+
+	if (!oops_in_progress) {
+		spin_lock_irq(&logbuf_lock);
+		took_lock = true;
+	}
+
+	max = log_buf_get_len();
+	if (idx < 0 || idx >= max) {
+		ret = -1;
+	} else {
+		if (len > max - idx)
+			len = max - idx;
+		ret = len;
+		idx += (log_end - max);
+		while (len-- > 0)
+			dest[len] = LOG_BUF(idx + len);
+	}
+
+	if (took_lock)
+		spin_unlock_irq(&logbuf_lock);
+
+	return ret;
+}
+
+/*
  * Commands to do_syslog:
  *
  * 	0 -- Close the log.  Currently a NOP.
@@ -668,6 +731,10 @@
 				  sizeof(printk_buf) - printed_len, fmt, args);
 
 
+#ifdef	CONFIG_DEBUG_LL
+	printascii(printk_buf);
+#endif
+
 	/*
 	 * Copy the output into log_buf.  If the caller didn't provide
 	 * appropriate log level tags, we insert them here
diff -Nur linux-2.6.29/kernel/ptrace.c linux-2.6.29-spica/kernel/ptrace.c
--- linux-2.6.29/kernel/ptrace.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/ptrace.c	2010-03-30 11:01:39.000000000 +0700
@@ -186,7 +186,7 @@
 	/* Protect exec's credential calculations against our interference;
 	 * SUID, SGID and LSM creds get determined differently under ptrace.
 	 */
-	retval = mutex_lock_interruptible(&current->cred_exec_mutex);
+	retval = mutex_lock_interruptible(&task->cred_exec_mutex);
 	if (retval  < 0)
 		goto out;
 
@@ -230,7 +230,7 @@
 bad:
 	write_unlock_irqrestore(&tasklist_lock, flags);
 	task_unlock(task);
-	mutex_unlock(&current->cred_exec_mutex);
+	mutex_unlock(&task->cred_exec_mutex);
 out:
 	return retval;
 }
diff -Nur linux-2.6.29/kernel/sched.c linux-2.6.29-spica/kernel/sched.c
--- linux-2.6.29/kernel/sched.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/sched.c	2010-05-06 12:42:45.684270633 +0700
@@ -53,6 +53,7 @@
 #include <linux/rcupdate.h>
 #include <linux/cpu.h>
 #include <linux/cpuset.h>
+#include <linux/cpufreq.h>
 #include <linux/percpu.h>
 #include <linux/kthread.h>
 #include <linux/proc_fs.h>
@@ -4134,9 +4135,25 @@
 EXPORT_PER_CPU_SYMBOL(kstat);
 
 /*
- * Return any ns on the sched_clock that have not yet been banked in
+ * Return any ns on the sched_clock that have not yet been accounted in
  * @p in case that task is currently running.
+ *
+ * Called with task_rq_lock() held on @rq.
  */
+static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
+{
+	u64 ns = 0;
+
+	if (task_current(rq, p)) {
+		update_rq_clock(rq);
+		ns = rq->clock - p->se.exec_start;
+		if ((s64)ns < 0)
+			ns = 0;
+	}
+
+	return ns;
+}
+
 unsigned long long task_delta_exec(struct task_struct *p)
 {
 	unsigned long flags;
@@ -4144,16 +4161,49 @@
 	u64 ns = 0;
 
 	rq = task_rq_lock(p, &flags);
+	ns = do_task_delta_exec(p, rq);
+	task_rq_unlock(rq, &flags);
 
-	if (task_current(rq, p)) {
-		u64 delta_exec;
+	return ns;
+}
 
-		update_rq_clock(rq);
-		delta_exec = rq->clock - p->se.exec_start;
-		if ((s64)delta_exec > 0)
-			ns = delta_exec;
-	}
+/*
+ * Return accounted runtime for the task.
+ * In case the task is currently running, return the runtime plus current's
+ * pending runtime that have not been accounted yet.
+ */
+unsigned long long task_sched_runtime(struct task_struct *p)
+{
+	unsigned long flags;
+	struct rq *rq;
+	u64 ns = 0;
+
+	rq = task_rq_lock(p, &flags);
+	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
+	task_rq_unlock(rq, &flags);
+
+	return ns;
+}
 
+/*
+ * Return sum_exec_runtime for the thread group.
+ * In case the task is currently running, return the sum plus current's
+ * pending runtime that have not been accounted yet.
+ *
+ * Note that the thread group might have other running tasks as well,
+ * so the return value not includes other pending runtime that other
+ * running tasks might have.
+ */
+unsigned long long thread_group_sched_runtime(struct task_struct *p)
+{
+	struct task_cputime totals;
+	unsigned long flags;
+	struct rq *rq;
+	u64 ns;
+
+	rq = task_rq_lock(p, &flags);
+	thread_group_cputime(p, &totals);
+	ns = totals.sum_exec_runtime + do_task_delta_exec(p, rq);
 	task_rq_unlock(rq, &flags);
 
 	return ns;
@@ -4313,6 +4363,7 @@
  */
 void account_idle_ticks(unsigned long ticks)
 {
+	cpufreq_exit_idle(smp_processor_id(), ticks);
 	account_idle_time(jiffies_to_cputime(ticks));
 }
 
@@ -5930,7 +5981,7 @@
 	unsigned state;
 
 	state = p->state ? __ffs(p->state) + 1 : 0;
-	printk(KERN_INFO "%-13.13s %c", p->comm,
+	printk(KERN_INFO "%-15.15s %c", p->comm,
 		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?');
 #if BITS_PER_LONG == 32
 	if (state == TASK_RUNNING)
@@ -8300,6 +8351,10 @@
 	int i, j;
 	unsigned long alloc_size = 0, ptr;
 
+
+	GAFINFO.ver = 0x0100;
+
+
 #ifdef CONFIG_FAIR_GROUP_SCHED
 	alloc_size += 2 * nr_cpu_ids * sizeof(void **);
 #endif
@@ -8506,13 +8561,23 @@
 }
 
 #ifdef CONFIG_DEBUG_SPINLOCK_SLEEP
+static int __might_sleep_init_called;
+int __init __might_sleep_init(void)
+{
+	__might_sleep_init_called = 1;
+	return 0;
+}
+early_initcall(__might_sleep_init);
+
 void __might_sleep(char *file, int line)
 {
 #ifdef in_atomic
 	static unsigned long prev_jiffy;	/* ratelimiting */
 
-	if ((!in_atomic() && !irqs_disabled()) ||
-		    system_state != SYSTEM_RUNNING || oops_in_progress)
+	if ((!in_atomic() && !irqs_disabled()) || oops_in_progress)
+		return;
+	if (system_state != SYSTEM_RUNNING &&
+	    (!__might_sleep_init_called || system_state != SYSTEM_BOOTING))
 		return;
 	if (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)
 		return;
@@ -9326,6 +9391,15 @@
 cpu_cgroup_can_attach(struct cgroup_subsys *ss, struct cgroup *cgrp,
 		      struct task_struct *tsk)
 {
+	if ((current != tsk) && (!capable(CAP_SYS_NICE))) {
+		const struct cred *cred = current_cred(), *tcred;
+
+		tcred = __task_cred(tsk);
+
+		if (cred->euid != tcred->uid && cred->euid != tcred->suid)
+			return -EPERM;
+	}
+
 #ifdef CONFIG_RT_GROUP_SCHED
 	if (!sched_rt_can_attach(cgroup_tg(cgrp), tsk))
 		return -EINVAL;
diff -Nur linux-2.6.29/kernel/sys.c linux-2.6.29-spica/kernel/sys.c
--- linux-2.6.29/kernel/sys.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/sys.c	2010-05-06 12:42:45.684270633 +0700
@@ -44,6 +44,8 @@
 #include <asm/io.h>
 #include <asm/unistd.h>
 
+#include <linux/suspend.h>
+
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
 #endif
@@ -355,6 +357,7 @@
  *
  * reboot doesn't sync: do that yourself before calling this.
  */
+extern void request_suspend_state(suspend_state_t new_state);
 SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,
 		void __user *, arg)
 {
@@ -399,6 +402,9 @@
 		break;
 
 	case LINUX_REBOOT_CMD_POWER_OFF:
+		// to prevent entering sleep state during power off 
+		request_suspend_state(PM_SUSPEND_ON);
+
 		kernel_power_off();
 		unlock_kernel();
 		do_exit(0);
diff -Nur linux-2.6.29/kernel/sysctl.c linux-2.6.29-spica/kernel/sysctl.c
--- linux-2.6.29/kernel/sysctl.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/sysctl.c	2010-03-30 11:01:39.000000000 +0700
@@ -76,6 +76,7 @@
 extern char core_pattern[];
 extern int pid_max;
 extern int min_free_kbytes;
+extern int min_free_order_shift;
 extern int pid_max_min, pid_max_max;
 extern int sysctl_drop_caches;
 extern int percpu_pagelist_fraction;
@@ -1097,6 +1098,14 @@
 		.extra1		= &zero,
 	},
 	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "min_free_order_shift",
+		.data		= &min_free_order_shift,
+		.maxlen		= sizeof(min_free_order_shift),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
 		.ctl_name	= VM_PERCPU_PAGELIST_FRACTION,
 		.procname	= "percpu_pagelist_fraction",
 		.data		= &percpu_pagelist_fraction,
@@ -1213,7 +1222,6 @@
 		.strategy	= &sysctl_jiffies,
 	},
 #endif
-#ifdef CONFIG_SECURITY
 	{
 		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "mmap_min_addr",
@@ -1222,7 +1230,6 @@
 		.mode		= 0644,
 		.proc_handler	= &proc_doulongvec_minmax,
 	},
-#endif
 #ifdef CONFIG_NUMA
 	{
 		.ctl_name	= CTL_UNNUMBERED,
diff -Nur linux-2.6.29/kernel/time/tick-sched.c linux-2.6.29-spica/kernel/time/tick-sched.c
--- linux-2.6.29/kernel/time/tick-sched.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/kernel/time/tick-sched.c	2010-03-30 11:01:39.000000000 +0700
@@ -222,7 +222,6 @@
 
 	cpu = smp_processor_id();
 	ts = &per_cpu(tick_cpu_sched, cpu);
-	now = tick_nohz_start_idle(ts);
 
 	/*
 	 * If this cpu is offline and it is the one which updates
@@ -242,6 +241,7 @@
 	if (!inidle && !ts->inidle)
 		goto end;
 
+	now = tick_nohz_start_idle(ts);
 	ts->inidle = 1;
 
 	if (need_resched())
diff -Nur linux-2.6.29/lib/genalloc.c linux-2.6.29-spica/lib/genalloc.c
--- linux-2.6.29/lib/genalloc.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/lib/genalloc.c	2010-03-30 11:01:39.000000000 +0700
@@ -85,7 +85,6 @@
 	int bit, end_bit;
 
 
-	write_lock(&pool->lock);
 	list_for_each_safe(_chunk, _next_chunk, &pool->chunks) {
 		chunk = list_entry(_chunk, struct gen_pool_chunk, next_chunk);
 		list_del(&chunk->next_chunk);
diff -Nur linux-2.6.29/Makefile linux-2.6.29-spica/Makefile
--- linux-2.6.29/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/Makefile	2010-05-06 12:42:45.684270633 +0700
@@ -190,8 +190,12 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH			:= arm
+CROSS_COMPILE	:= /usr/local/arm/4.3.1-eabi-armv6/usr/bin/arm-linux-
+#CROSS_COMPILE	:= $(shell if [ -f .cross_compile ]; then \
+					cat .cross_compile; \
+					fi)
+
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
@@ -536,6 +540,9 @@
 # Arch Makefiles may override this setting
 KBUILD_CFLAGS += $(call cc-option, -fno-stack-protector)
 
+# 20081219 Linux_LDK
+KBUILD_CFLAGS      += -I$(PRJROOT)/modules/include
+
 ifdef CONFIG_FRAME_POINTER
 KBUILD_CFLAGS	+= -fno-omit-frame-pointer -fno-optimize-sibling-calls
 else
@@ -591,10 +598,10 @@
 endif
 
 # Use --build-id when available.
-LDFLAGS_BUILD_ID = $(patsubst -Wl$(comma)%,%,\
-			      $(call ld-option, -Wl$(comma)--build-id,))
-LDFLAGS_MODULE += $(LDFLAGS_BUILD_ID)
-LDFLAGS_vmlinux += $(LDFLAGS_BUILD_ID)
+#LDFLAGS_BUILD_ID = $(patsubst -Wl$(comma)%,%,\
+#			      $(call ld-option, -Wl$(comma)--build-id,))
+#LDFLAGS_MODULE += $(LDFLAGS_BUILD_ID)
+#LDFLAGS_vmlinux += $(LDFLAGS_BUILD_ID)
 
 # Default kernel image to build when no specific target is given.
 # KBUILD_IMAGE may be overruled on the command line or
@@ -614,9 +621,16 @@
 # makefile but the argument can be passed to make if needed.
 #
 
+# 20081219 Linux_LDK
+INSTALL_MOD_PATH := $(PRJROOT)/root
+MODINST    := $(INSTALL_MOD_PATH)/lib/modules
+
 MODLIB	= $(INSTALL_MOD_PATH)/lib/modules/$(KERNELRELEASE)
 export MODLIB
 
+# 20081219 Linux_LDK
+export MODINST
+
 #
 #  INSTALL_MOD_STRIP, if defined, will cause modules to be
 #  stripped after they are installed.  If INSTALL_MOD_STRIP is '1', then
diff -Nur linux-2.6.29/mm/ashmem.c linux-2.6.29-spica/mm/ashmem.c
--- linux-2.6.29/mm/ashmem.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/mm/ashmem.c	2010-03-30 11:01:40.000000000 +0700
@@ -0,0 +1,670 @@
+/* mm/ashmem.c
+**
+** Anonymous Shared Memory Subsystem, ashmem
+**
+** Copyright (C) 2008 Google, Inc.
+**
+** Robert Love <rlove@google.com>
+**
+** This software is licensed under the terms of the GNU General Public
+** License version 2, as published by the Free Software Foundation, and
+** may be copied, distributed, and modified under those terms.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+*/
+
+#include <linux/module.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/security.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/uaccess.h>
+#include <linux/personality.h>
+#include <linux/bitops.h>
+#include <linux/mutex.h>
+#include <linux/shmem_fs.h>
+#include <linux/ashmem.h>
+
+#define ASHMEM_NAME_PREFIX "dev/ashmem/"
+#define ASHMEM_NAME_PREFIX_LEN (sizeof(ASHMEM_NAME_PREFIX) - 1)
+#define ASHMEM_FULL_NAME_LEN (ASHMEM_NAME_LEN + ASHMEM_NAME_PREFIX_LEN)
+
+/*
+ * ashmem_area - anonymous shared memory area
+ * Lifecycle: From our parent file's open() until its release()
+ * Locking: Protected by `ashmem_mutex'
+ * Big Note: Mappings do NOT pin this structure; it dies on close()
+ */
+struct ashmem_area {
+	char name[ASHMEM_FULL_NAME_LEN];/* optional name for /proc/pid/maps */
+	struct list_head unpinned_list;	/* list of all ashmem areas */
+	struct file *file;		/* the shmem-based backing file */
+	size_t size;			/* size of the mapping, in bytes */
+	unsigned long prot_mask;	/* allowed prot bits, as vm_flags */
+};
+
+/*
+ * ashmem_range - represents an interval of unpinned (evictable) pages
+ * Lifecycle: From unpin to pin
+ * Locking: Protected by `ashmem_mutex'
+ */
+struct ashmem_range {
+	struct list_head lru;		/* entry in LRU list */
+	struct list_head unpinned;	/* entry in its area's unpinned list */
+	struct ashmem_area *asma;	/* associated area */
+	size_t pgstart;			/* starting page, inclusive */
+	size_t pgend;			/* ending page, inclusive */
+	unsigned int purged;		/* ASHMEM_NOT or ASHMEM_WAS_PURGED */
+};
+
+/* LRU list of unpinned pages, protected by ashmem_mutex */
+static LIST_HEAD(ashmem_lru_list);
+
+/* Count of pages on our LRU list, protected by ashmem_mutex */
+static unsigned long lru_count;
+
+/*
+ * ashmem_mutex - protects the list of and each individual ashmem_area
+ *
+ * Lock Ordering: ashmex_mutex -> i_mutex -> i_alloc_sem
+ */
+static DEFINE_MUTEX(ashmem_mutex);
+
+static struct kmem_cache *ashmem_area_cachep __read_mostly;
+static struct kmem_cache *ashmem_range_cachep __read_mostly;
+
+#define range_size(range) \
+  ((range)->pgend - (range)->pgstart + 1)
+
+#define range_on_lru(range) \
+  ((range)->purged == ASHMEM_NOT_PURGED)
+
+#define page_range_subsumes_range(range, start, end) \
+  (((range)->pgstart >= (start)) && ((range)->pgend <= (end)))
+
+#define page_range_subsumed_by_range(range, start, end) \
+  (((range)->pgstart <= (start)) && ((range)->pgend >= (end)))
+
+#define page_in_range(range, page) \
+ (((range)->pgstart <= (page)) && ((range)->pgend >= (page)))
+
+#define page_range_in_range(range, start, end) \
+  (page_in_range(range, start) || page_in_range(range, end) || \
+   page_range_subsumes_range(range, start, end))
+
+#define range_before_page(range, page) \
+  ((range)->pgend < (page))
+
+#define PROT_MASK		(PROT_EXEC | PROT_READ | PROT_WRITE)
+
+static inline void lru_add(struct ashmem_range *range)
+{
+	list_add_tail(&range->lru, &ashmem_lru_list);
+	lru_count += range_size(range);
+}
+
+static inline void lru_del(struct ashmem_range *range)
+{
+	list_del(&range->lru);
+	lru_count -= range_size(range);
+}
+
+/*
+ * range_alloc - allocate and initialize a new ashmem_range structure
+ *
+ * 'asma' - associated ashmem_area
+ * 'prev_range' - the previous ashmem_range in the sorted asma->unpinned list
+ * 'purged' - initial purge value (ASMEM_NOT_PURGED or ASHMEM_WAS_PURGED)
+ * 'start' - starting page, inclusive
+ * 'end' - ending page, inclusive
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static int range_alloc(struct ashmem_area *asma,
+		       struct ashmem_range *prev_range, unsigned int purged,
+		       size_t start, size_t end)
+{
+	struct ashmem_range *range;
+
+	range = kmem_cache_zalloc(ashmem_range_cachep, GFP_KERNEL);
+	if (unlikely(!range))
+		return -ENOMEM;
+
+	range->asma = asma;
+	range->pgstart = start;
+	range->pgend = end;
+	range->purged = purged;
+
+	list_add_tail(&range->unpinned, &prev_range->unpinned);
+
+	if (range_on_lru(range))
+		lru_add(range);
+
+	return 0;
+}
+
+static void range_del(struct ashmem_range *range)
+{
+	list_del(&range->unpinned);
+	if (range_on_lru(range))
+		lru_del(range);
+	kmem_cache_free(ashmem_range_cachep, range);
+}
+
+/*
+ * range_shrink - shrinks a range
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static inline void range_shrink(struct ashmem_range *range,
+				size_t start, size_t end)
+{
+	size_t pre = range_size(range);
+
+	range->pgstart = start;
+	range->pgend = end;
+
+	if (range_on_lru(range))
+		lru_count -= pre - range_size(range);
+}
+
+static int ashmem_open(struct inode *inode, struct file *file)
+{
+	struct ashmem_area *asma;
+	int ret;
+
+	ret = nonseekable_open(inode, file);
+	if (unlikely(ret))
+		return ret;
+
+	asma = kmem_cache_zalloc(ashmem_area_cachep, GFP_KERNEL);
+	if (unlikely(!asma))
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&asma->unpinned_list);
+	memcpy(asma->name, ASHMEM_NAME_PREFIX, ASHMEM_NAME_PREFIX_LEN);
+	asma->prot_mask = PROT_MASK;
+	file->private_data = asma;
+
+	return 0;
+}
+
+static int ashmem_release(struct inode *ignored, struct file *file)
+{
+	struct ashmem_area *asma = file->private_data;
+	struct ashmem_range *range, *next;
+
+	mutex_lock(&ashmem_mutex);
+	list_for_each_entry_safe(range, next, &asma->unpinned_list, unpinned)
+		range_del(range);
+	mutex_unlock(&ashmem_mutex);
+
+	if (asma->file)
+		fput(asma->file);
+	kmem_cache_free(ashmem_area_cachep, asma);
+
+	return 0;
+}
+
+static int ashmem_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct ashmem_area *asma = file->private_data;
+	int ret = 0;
+
+	mutex_lock(&ashmem_mutex);
+
+	/* user needs to SET_SIZE before mapping */
+	if (unlikely(!asma->size)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* requested protection bits must match our allowed protection mask */
+	if (unlikely((vma->vm_flags & ~asma->prot_mask) & PROT_MASK)) {
+		ret = -EPERM;
+		goto out;
+	}
+
+	if (!asma->file) {
+		char *name = ASHMEM_NAME_DEF;
+		struct file *vmfile;
+
+		if (asma->name[ASHMEM_NAME_PREFIX_LEN] != '\0')
+			name = asma->name;
+
+		/* ... and allocate the backing shmem file */
+		vmfile = shmem_file_setup(name, asma->size, vma->vm_flags);
+		if (unlikely(IS_ERR(vmfile))) {
+			ret = PTR_ERR(vmfile);
+			goto out;
+		}
+		asma->file = vmfile;
+	}
+	get_file(asma->file);
+
+	if (vma->vm_flags & VM_SHARED)
+		shmem_set_file(vma, asma->file);
+	else {
+		if (vma->vm_file)
+			fput(vma->vm_file);
+		vma->vm_file = asma->file;
+	}
+	vma->vm_flags |= VM_CAN_NONLINEAR;
+
+out:
+	mutex_unlock(&ashmem_mutex);
+	return ret;
+}
+
+/*
+ * ashmem_shrink - our cache shrinker, called from mm/vmscan.c :: shrink_slab
+ *
+ * 'nr_to_scan' is the number of objects (pages) to prune, or 0 to query how
+ * many objects (pages) we have in total.
+ *
+ * 'gfp_mask' is the mask of the allocation that got us into this mess.
+ *
+ * Return value is the number of objects (pages) remaining, or -1 if we cannot
+ * proceed without risk of deadlock (due to gfp_mask).
+ *
+ * We approximate LRU via least-recently-unpinned, jettisoning unpinned partial
+ * chunks of ashmem regions LRU-wise one-at-a-time until we hit 'nr_to_scan'
+ * pages freed.
+ */
+static int ashmem_shrink(int nr_to_scan, gfp_t gfp_mask)
+{
+	struct ashmem_range *range, *next;
+
+	/* We might recurse into filesystem code, so bail out if necessary */
+	if (nr_to_scan && !(gfp_mask & __GFP_FS))
+		return -1;
+	if (!nr_to_scan)
+		return lru_count;
+
+	mutex_lock(&ashmem_mutex);
+	list_for_each_entry_safe(range, next, &ashmem_lru_list, lru) {
+		struct inode *inode = range->asma->file->f_dentry->d_inode;
+		loff_t start = range->pgstart * PAGE_SIZE;
+		loff_t end = (range->pgend + 1) * PAGE_SIZE - 1;
+
+		vmtruncate_range(inode, start, end);
+		range->purged = ASHMEM_WAS_PURGED;
+		lru_del(range);
+
+		nr_to_scan -= range_size(range);
+		if (nr_to_scan <= 0)
+			break;
+	}
+	mutex_unlock(&ashmem_mutex);
+
+	return lru_count;
+}
+
+static struct shrinker ashmem_shrinker = {
+	.shrink = ashmem_shrink,
+	.seeks = DEFAULT_SEEKS * 4,
+};
+
+static int set_prot_mask(struct ashmem_area *asma, unsigned long prot)
+{
+	int ret = 0;
+
+	mutex_lock(&ashmem_mutex);
+
+	/* the user can only remove, not add, protection bits */
+	if (unlikely((asma->prot_mask & prot) != prot)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* does the application expect PROT_READ to imply PROT_EXEC? */
+	if ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))
+		prot |= PROT_EXEC;
+
+	asma->prot_mask = prot;
+
+out:
+	mutex_unlock(&ashmem_mutex);
+	return ret;
+}
+
+static int set_name(struct ashmem_area *asma, void __user *name)
+{
+	int ret = 0;
+
+	mutex_lock(&ashmem_mutex);
+
+	/* cannot change an existing mapping's name */
+	if (unlikely(asma->file)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (unlikely(copy_from_user(asma->name + ASHMEM_NAME_PREFIX_LEN,
+				    name, ASHMEM_NAME_LEN)))
+		ret = -EFAULT;
+	asma->name[ASHMEM_FULL_NAME_LEN-1] = '\0';
+
+out:
+	mutex_unlock(&ashmem_mutex);
+
+	return ret;
+}
+
+static int get_name(struct ashmem_area *asma, void __user *name)
+{
+	int ret = 0;
+
+	mutex_lock(&ashmem_mutex);
+	if (asma->name[ASHMEM_NAME_PREFIX_LEN] != '\0') {
+		size_t len;
+
+		/*
+		 * Copying only `len', instead of ASHMEM_NAME_LEN, bytes
+		 * prevents us from revealing one user's stack to another.
+		 */
+		len = strlen(asma->name + ASHMEM_NAME_PREFIX_LEN) + 1;
+		if (unlikely(copy_to_user(name,
+				asma->name + ASHMEM_NAME_PREFIX_LEN, len)))
+			ret = -EFAULT;
+	} else {
+		if (unlikely(copy_to_user(name, ASHMEM_NAME_DEF,
+					  sizeof(ASHMEM_NAME_DEF))))
+			ret = -EFAULT;
+	}
+	mutex_unlock(&ashmem_mutex);
+
+	return ret;
+}
+
+/*
+ * ashmem_pin - pin the given ashmem region, returning whether it was
+ * previously purged (ASHMEM_WAS_PURGED) or not (ASHMEM_NOT_PURGED).
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static int ashmem_pin(struct ashmem_area *asma, size_t pgstart, size_t pgend)
+{
+	struct ashmem_range *range, *next;
+	int ret = ASHMEM_NOT_PURGED;
+
+	list_for_each_entry_safe(range, next, &asma->unpinned_list, unpinned) {
+		/* moved past last applicable page; we can short circuit */
+		if (range_before_page(range, pgstart))
+			break;
+
+		/*
+		 * The user can ask us to pin pages that span multiple ranges,
+		 * or to pin pages that aren't even unpinned, so this is messy.
+		 *
+		 * Four cases:
+		 * 1. The requested range subsumes an existing range, so we
+		 *    just remove the entire matching range.
+		 * 2. The requested range overlaps the start of an existing
+		 *    range, so we just update that range.
+		 * 3. The requested range overlaps the end of an existing
+		 *    range, so we just update that range.
+		 * 4. The requested range punches a hole in an existing range,
+		 *    so we have to update one side of the range and then
+		 *    create a new range for the other side.
+		 */
+		if (page_range_in_range(range, pgstart, pgend)) {
+			ret |= range->purged;
+
+			/* Case #1: Easy. Just nuke the whole thing. */
+			if (page_range_subsumes_range(range, pgstart, pgend)) {
+				range_del(range);
+				continue;
+			}
+
+			/* Case #2: We overlap from the start, so adjust it */
+			if (range->pgstart >= pgstart) {
+				range_shrink(range, pgend + 1, range->pgend);
+				continue;
+			}
+
+			/* Case #3: We overlap from the rear, so adjust it */
+			if (range->pgend <= pgend) {
+				range_shrink(range, range->pgstart, pgstart-1);
+				continue;
+			}
+
+			/*
+			 * Case #4: We eat a chunk out of the middle. A bit
+			 * more complicated, we allocate a new range for the
+			 * second half and adjust the first chunk's endpoint.
+			 */
+			range_alloc(asma, range, range->purged,
+				    pgend + 1, range->pgend);
+			range_shrink(range, range->pgstart, pgstart - 1);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+/*
+ * ashmem_unpin - unpin the given range of pages. Returns zero on success.
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static int ashmem_unpin(struct ashmem_area *asma, size_t pgstart, size_t pgend)
+{
+	struct ashmem_range *range, *next;
+	unsigned int purged = ASHMEM_NOT_PURGED;
+
+restart:
+	list_for_each_entry_safe(range, next, &asma->unpinned_list, unpinned) {
+		/* short circuit: this is our insertion point */
+		if (range_before_page(range, pgstart))
+			break;
+
+		/*
+		 * The user can ask us to unpin pages that are already entirely
+		 * or partially pinned. We handle those two cases here.
+		 */
+		if (page_range_subsumed_by_range(range, pgstart, pgend))
+			return 0;
+		if (page_range_in_range(range, pgstart, pgend)) {
+			pgstart = min_t(size_t, range->pgstart, pgstart),
+			pgend = max_t(size_t, range->pgend, pgend);
+			purged |= range->purged;
+			range_del(range);
+			goto restart;
+		}
+	}
+
+	return range_alloc(asma, range, purged, pgstart, pgend);
+}
+
+/*
+ * ashmem_get_pin_status - Returns ASHMEM_IS_UNPINNED if _any_ pages in the
+ * given interval are unpinned and ASHMEM_IS_PINNED otherwise.
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static int ashmem_get_pin_status(struct ashmem_area *asma, size_t pgstart,
+				 size_t pgend)
+{
+	struct ashmem_range *range;
+	int ret = ASHMEM_IS_PINNED;
+
+	list_for_each_entry(range, &asma->unpinned_list, unpinned) {
+		if (range_before_page(range, pgstart))
+			break;
+		if (page_range_in_range(range, pgstart, pgend)) {
+			ret = ASHMEM_IS_UNPINNED;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int ashmem_pin_unpin(struct ashmem_area *asma, unsigned long cmd,
+			    void __user *p)
+{
+	struct ashmem_pin pin;
+	size_t pgstart, pgend;
+	int ret = -EINVAL;
+
+	if (unlikely(!asma->file))
+		return -EINVAL;
+
+	if (unlikely(copy_from_user(&pin, p, sizeof(pin))))
+		return -EFAULT;
+
+	/* per custom, you can pass zero for len to mean "everything onward" */
+	if (!pin.len)
+		pin.len = PAGE_ALIGN(asma->size) - pin.offset;
+
+	if (unlikely((pin.offset | pin.len) & ~PAGE_MASK))
+		return -EINVAL;
+
+	if (unlikely(((__u32) -1) - pin.offset < pin.len))
+		return -EINVAL;
+
+	if (unlikely(PAGE_ALIGN(asma->size) < pin.offset + pin.len))
+		return -EINVAL;
+
+	pgstart = pin.offset / PAGE_SIZE;
+	pgend = pgstart + (pin.len / PAGE_SIZE) - 1;
+
+	mutex_lock(&ashmem_mutex);
+
+	switch (cmd) {
+	case ASHMEM_PIN:
+		ret = ashmem_pin(asma, pgstart, pgend);
+		break;
+	case ASHMEM_UNPIN:
+		ret = ashmem_unpin(asma, pgstart, pgend);
+		break;
+	case ASHMEM_GET_PIN_STATUS:
+		ret = ashmem_get_pin_status(asma, pgstart, pgend);
+		break;
+	}
+
+	mutex_unlock(&ashmem_mutex);
+
+	return ret;
+}
+
+static long ashmem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct ashmem_area *asma = file->private_data;
+	long ret = -ENOTTY;
+
+	switch (cmd) {
+	case ASHMEM_SET_NAME:
+		ret = set_name(asma, (void __user *) arg);
+		break;
+	case ASHMEM_GET_NAME:
+		ret = get_name(asma, (void __user *) arg);
+		break;
+	case ASHMEM_SET_SIZE:
+		ret = -EINVAL;
+		if (!asma->file) {
+			ret = 0;
+			asma->size = (size_t) arg;
+		}
+		break;
+	case ASHMEM_GET_SIZE:
+		ret = asma->size;
+		break;
+	case ASHMEM_SET_PROT_MASK:
+		ret = set_prot_mask(asma, arg);
+		break;
+	case ASHMEM_GET_PROT_MASK:
+		ret = asma->prot_mask;
+		break;
+	case ASHMEM_PIN:
+	case ASHMEM_UNPIN:
+	case ASHMEM_GET_PIN_STATUS:
+		ret = ashmem_pin_unpin(asma, cmd, (void __user *) arg);
+		break;
+	case ASHMEM_PURGE_ALL_CACHES:
+		ret = -EPERM;
+		if (capable(CAP_SYS_ADMIN)) {
+			ret = ashmem_shrink(0, GFP_KERNEL);
+			ashmem_shrink(ret, GFP_KERNEL);
+		}
+		break;
+	}
+
+	return ret;
+}
+
+static struct file_operations ashmem_fops = {
+	.owner = THIS_MODULE,
+	.open = ashmem_open,
+	.release = ashmem_release,
+	.mmap = ashmem_mmap,
+	.unlocked_ioctl = ashmem_ioctl,
+	.compat_ioctl = ashmem_ioctl,
+};
+
+static struct miscdevice ashmem_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "ashmem",
+	.fops = &ashmem_fops,
+};
+
+static int __init ashmem_init(void)
+{
+	int ret;
+
+	ashmem_area_cachep = kmem_cache_create("ashmem_area_cache",
+					  sizeof(struct ashmem_area),
+					  0, 0, NULL);
+	if (unlikely(!ashmem_area_cachep)) {
+		printk(KERN_ERR "ashmem: failed to create slab cache\n");
+		return -ENOMEM;
+	}
+
+	ashmem_range_cachep = kmem_cache_create("ashmem_range_cache",
+					  sizeof(struct ashmem_range),
+					  0, 0, NULL);
+	if (unlikely(!ashmem_range_cachep)) {
+		printk(KERN_ERR "ashmem: failed to create slab cache\n");
+		return -ENOMEM;
+	}
+
+	ret = misc_register(&ashmem_misc);
+	if (unlikely(ret)) {
+		printk(KERN_ERR "ashmem: failed to register misc device!\n");
+		return ret;
+	}
+
+	register_shrinker(&ashmem_shrinker);
+
+	printk(KERN_INFO "ashmem: initialized\n");
+
+	return 0;
+}
+
+static void __exit ashmem_exit(void)
+{
+	int ret;
+
+	unregister_shrinker(&ashmem_shrinker);
+
+	ret = misc_deregister(&ashmem_misc);
+	if (unlikely(ret))
+		printk(KERN_ERR "ashmem: failed to unregister misc device!\n");
+
+	kmem_cache_destroy(ashmem_range_cachep);
+	kmem_cache_destroy(ashmem_area_cachep);
+
+	printk(KERN_INFO "ashmem: unloaded\n");
+}
+
+module_init(ashmem_init);
+module_exit(ashmem_exit);
+
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/mm/Kconfig linux-2.6.29-spica/mm/Kconfig
--- linux-2.6.29/mm/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/mm/Kconfig	2010-03-30 11:01:40.000000000 +0700
@@ -216,3 +216,21 @@
 
 config MMU_NOTIFIER
 	bool
+
+config DEFAULT_MMAP_MIN_ADDR
+        int "Low address space to protect from user allocation"
+        default 4096
+        help
+	  This is the portion of low virtual memory which should be protected
+	  from userspace allocation.  Keeping a user from writing to low pages
+	  can help reduce the impact of kernel NULL pointer bugs.
+
+	  For most ia64, ppc64 and x86 users with lots of address space
+	  a value of 65536 is reasonable and should cause no problems.
+	  On arm and other archs it should not be higher than 32768.
+	  Programs which use vm86 functionality would either need additional
+	  permissions from either the LSM or the capabilities module or have
+	  this protection disabled.
+
+	  This value can be changed after boot using the
+	  /proc/sys/vm/mmap_min_addr tunable.
diff -Nur linux-2.6.29/mm/Makefile linux-2.6.29-spica/mm/Makefile
--- linux-2.6.29/mm/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/mm/Makefile	2010-03-30 11:01:40.000000000 +0700
@@ -21,6 +21,7 @@
 obj-$(CONFIG_NUMA) 	+= mempolicy.o
 obj-$(CONFIG_SPARSEMEM)	+= sparse.o
 obj-$(CONFIG_SPARSEMEM_VMEMMAP) += sparse-vmemmap.o
+obj-$(CONFIG_ASHMEM) += ashmem.o
 obj-$(CONFIG_TMPFS_POSIX_ACL) += shmem_acl.o
 obj-$(CONFIG_SLOB) += slob.o
 obj-$(CONFIG_MMU_NOTIFIER) += mmu_notifier.o
diff -Nur linux-2.6.29/mm/mmap.c linux-2.6.29-spica/mm/mmap.c
--- linux-2.6.29/mm/mmap.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/mm/mmap.c	2010-03-30 11:01:40.000000000 +0700
@@ -86,6 +86,9 @@
 int sysctl_max_map_count __read_mostly = DEFAULT_MAX_MAP_COUNT;
 atomic_long_t vm_committed_space = ATOMIC_LONG_INIT(0);
 
+/* amount of vm to protect from userspace access */
+unsigned long mmap_min_addr = CONFIG_DEFAULT_MMAP_MIN_ADDR;
+
 /*
  * Check that a process has enough memory to allocate a new virtual
  * mapping. 0 means there is enough memory for the allocation to
diff -Nur linux-2.6.29/mm/page_alloc.c linux-2.6.29-spica/mm/page_alloc.c
--- linux-2.6.29/mm/page_alloc.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/mm/page_alloc.c	2010-03-30 11:01:40.000000000 +0700
@@ -119,6 +119,7 @@
 };
 
 int min_free_kbytes = 1024;
+int min_free_order_shift = 1;
 
 unsigned long __meminitdata nr_kernel_pages;
 unsigned long __meminitdata nr_all_pages;
@@ -1256,7 +1257,7 @@
 		free_pages -= z->free_area[o].nr_free << o;
 
 		/* Require fewer higher order pages to be free */
-		min >>= 1;
+		min >>= min_free_order_shift;
 
 		if (free_pages <= min)
 			return 0;
@@ -2550,6 +2551,20 @@
 #define LONG_ALIGN(x) (((x)+(sizeof(long))-1)&~((sizeof(long))-1))
 
 /*
+ * Check if a pageblock contains reserved pages
+ */
+static int pageblock_is_reserved(unsigned long start_pfn)
+{
+	unsigned long end_pfn = start_pfn + pageblock_nr_pages;
+	unsigned long pfn;
+
+	for (pfn = start_pfn; pfn < end_pfn; pfn++)
+		if (PageReserved(pfn_to_page(pfn)))
+			return 1;
+	return 0;
+}
+
+/*
  * Mark a number of pageblocks as MIGRATE_RESERVE. The number
  * of blocks reserved is based on zone->pages_min. The memory within the
  * reserve will tend to store contiguous free pages. Setting min_free_kbytes
@@ -2578,7 +2593,7 @@
 			continue;
 
 		/* Blocks with reserved pages will never free, skip them. */
-		if (PageReserved(page))
+		if (pageblock_is_reserved(pfn))
 			continue;
 
 		block_migratetype = get_pageblock_migratetype(page);
diff -Nur linux-2.6.29/mm/shmem.c linux-2.6.29-spica/mm/shmem.c
--- linux-2.6.29/mm/shmem.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/mm/shmem.c	2010-03-30 11:01:40.000000000 +0700
@@ -2652,6 +2652,14 @@
 }
 EXPORT_SYMBOL_GPL(shmem_file_setup);
 
+void shmem_set_file(struct vm_area_struct *vma, struct file *file)
+{
+	if (vma->vm_file)
+		fput(vma->vm_file);
+	vma->vm_file = file;
+	vma->vm_ops = &shmem_vm_ops;
+}
+
 /**
  * shmem_zero_setup - setup a shared anonymous mapping
  * @vma: the vma to be mmapped is prepared by do_mmap_pgoff
@@ -2664,11 +2672,8 @@
 	file = shmem_file_setup("dev/zero", size, vma->vm_flags);
 	if (IS_ERR(file))
 		return PTR_ERR(file);
+	shmem_set_file(vma, file);
 
-	if (vma->vm_file)
-		fput(vma->vm_file);
-	vma->vm_file = file;
-	vma->vm_ops = &shmem_vm_ops;
 	return 0;
 }
 
diff -Nur linux-2.6.29/net/bluetooth/af_bluetooth.c linux-2.6.29-spica/net/bluetooth/af_bluetooth.c
--- linux-2.6.29/net/bluetooth/af_bluetooth.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/bluetooth/af_bluetooth.c	2010-03-30 11:01:42.000000000 +0700
@@ -41,14 +41,22 @@
 
 #include <net/bluetooth/bluetooth.h>
 
-#define VERSION "2.14"
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+#endif
+
+#ifndef CONFIG_BT_SOCK_DEBUG
+#undef  BT_DBG
+#define BT_DBG(D...)
+#endif
+
+#define VERSION "2.15"
 
 /* Bluetooth sockets */
 #define BT_MAX_PROTO	8
 static struct net_proto_family *bt_proto[BT_MAX_PROTO];
 static DEFINE_RWLOCK(bt_proto_lock);
 
-#ifdef CONFIG_DEBUG_LOCK_ALLOC
 static struct lock_class_key bt_lock_key[BT_MAX_PROTO];
 static const char *bt_key_strings[BT_MAX_PROTO] = {
 	"sk_lock-AF_BLUETOOTH-BTPROTO_L2CAP",
@@ -86,11 +94,6 @@
 			bt_slock_key_strings[proto], &bt_slock_key[proto],
 				bt_key_strings[proto], &bt_lock_key[proto]);
 }
-#else
-static inline void bt_sock_reclassify_lock(struct socket *sock, int proto)
-{
-}
-#endif
 
 int bt_sock_register(int proto, struct net_proto_family *ops)
 {
@@ -132,10 +135,39 @@
 }
 EXPORT_SYMBOL(bt_sock_unregister);
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+static inline int current_has_bt_admin(void)
+{
+	return (!current_euid() || in_egroup_p(AID_NET_BT_ADMIN));
+}
+
+static inline int current_has_bt(void)
+{
+	return (current_has_bt_admin() || in_egroup_p(AID_NET_BT));
+}
+# else
+static inline int current_has_bt_admin(void)
+{
+	return 1;
+}
+
+static inline int current_has_bt(void)
+{
+	return 1;
+}
+#endif
+
 static int bt_sock_create(struct net *net, struct socket *sock, int proto)
 {
 	int err;
 
+	if (proto == BTPROTO_RFCOMM || proto == BTPROTO_SCO ||
+			proto == BTPROTO_L2CAP) {
+		if (!current_has_bt())
+			return -EPERM;
+	} else if (!current_has_bt_admin())
+		return -EPERM;
+
 	if (net != &init_net)
 		return -EAFNOSUPPORT;
 
@@ -217,7 +249,8 @@
 			continue;
 		}
 
-		if (sk->sk_state == BT_CONNECTED || !newsock) {
+		if (sk->sk_state == BT_CONNECTED || !newsock ||
+						bt_sk(parent)->defer_setup) {
 			bt_accept_unlink(sk);
 			if (newsock)
 				sock_graft(sk, newsock);
@@ -232,7 +265,7 @@
 EXPORT_SYMBOL(bt_accept_dequeue);
 
 int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
-	struct msghdr *msg, size_t len, int flags)
+				struct msghdr *msg, size_t len, int flags)
 {
 	int noblock = flags & MSG_DONTWAIT;
 	struct sock *sk = sock->sk;
@@ -277,7 +310,9 @@
 
 	list_for_each_safe(p, n, &bt_sk(parent)->accept_q) {
 		sk = (struct sock *) list_entry(p, struct bt_sock, accept_q);
-		if (sk->sk_state == BT_CONNECTED)
+		if (sk->sk_state == BT_CONNECTED ||
+					(bt_sk(parent)->defer_setup &&
+						sk->sk_state == BT_CONNECT2))
 			return POLLIN | POLLRDNORM;
 	}
 
diff -Nur linux-2.6.29/net/bluetooth/cmtp/core.c linux-2.6.29-spica/net/bluetooth/cmtp/core.c
--- linux-2.6.29/net/bluetooth/cmtp/core.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/bluetooth/cmtp/core.c	2010-03-30 11:01:42.000000000 +0700
@@ -126,8 +126,7 @@
 
 	session->reassembly[id] = nskb;
 
-	if (skb)
-		kfree_skb(skb);
+	kfree_skb(skb);
 }
 
 static inline int cmtp_recv_frame(struct cmtp_session *session, struct sk_buff *skb)
diff -Nur linux-2.6.29/net/bluetooth/hci_conn.c linux-2.6.29-spica/net/bluetooth/hci_conn.c
--- linux-2.6.29/net/bluetooth/hci_conn.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/bluetooth/hci_conn.c	2010-05-06 12:42:45.684270633 +0700
@@ -123,6 +123,8 @@
 	conn->state = BT_CONNECT;
 	conn->out = 1;
 
+	conn->attempt++;
+
 	cp.handle   = cpu_to_le16(handle);
 	cp.pkt_type = cpu_to_le16(conn->pkt_type);
 
@@ -139,6 +141,8 @@
 	conn->state = BT_CONNECT;
 	conn->out = 1;
 
+	conn->attempt++;
+
 	cp.handle   = cpu_to_le16(handle);
 	cp.pkt_type = cpu_to_le16(conn->pkt_type);
 
@@ -155,6 +159,7 @@
 {
 	struct hci_conn *conn = (void *) arg;
 	struct hci_dev *hdev = conn->hdev;
+	__u8 reason;
 
 	BT_DBG("conn %p state %d", conn, conn->state);
 
@@ -173,7 +178,8 @@
 		break;
 	case BT_CONFIG:
 	case BT_CONNECTED:
-		hci_acl_disconn(conn, 0x13);
+		reason = hci_proto_disconn_ind(conn);
+		hci_acl_disconn(conn, reason);
 		break;
 	default:
 		conn->state = BT_CLOSED;
@@ -207,6 +213,7 @@
 	conn->type  = type;
 	conn->mode  = HCI_CM_ACTIVE;
 	conn->state = BT_OPEN;
+	conn->auth_type = HCI_AT_GENERAL_BONDING;
 
 	conn->power_save = 1;
 
@@ -216,12 +223,13 @@
 		break;
 	case SCO_LINK:
 		if (lmp_esco_capable(hdev))
-			conn->pkt_type = hdev->esco_type & SCO_ESCO_MASK;
+			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
+					(hdev->esco_type & EDR_ESCO_MASK);
 		else
 			conn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;
 		break;
 	case ESCO_LINK:
-		conn->pkt_type = hdev->esco_type;
+		conn->pkt_type = hdev->esco_type & ~EDR_ESCO_MASK;
 		break;
 	}
 
@@ -280,6 +288,8 @@
 
 	skb_queue_purge(&conn->data_q);
 
+	hci_conn_del_sysfs(conn);
+
 	return 0;
 }
 
@@ -325,7 +335,7 @@
 
 /* Create SCO or ACL connection.
  * Device _must_ be locked */
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 auth_type)
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type)
 {
 	struct hci_conn *acl;
 	struct hci_conn *sco;
@@ -340,6 +350,7 @@
 	hci_conn_hold(acl);
 
 	if (acl->state == BT_OPEN || acl->state == BT_CLOSED) {
+		acl->sec_level = sec_level;
 		acl->auth_type = auth_type;
 		hci_acl_connect(acl);
 	}
@@ -361,6 +372,9 @@
 
 	if (acl->state == BT_CONNECTED &&
 			(sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
+		acl->power_save = 1;
+		hci_conn_enter_active_mode(acl);
+
 		if (lmp_esco_capable(hdev))
 			hci_setup_sync(sco, acl->handle);
 		else
@@ -385,51 +399,56 @@
 EXPORT_SYMBOL(hci_conn_check_link_mode);
 
 /* Authenticate remote device */
-int hci_conn_auth(struct hci_conn *conn)
+static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
 	BT_DBG("conn %p", conn);
 
-	if (conn->ssp_mode > 0 && conn->hdev->ssp_mode > 0) {
-		if (!(conn->auth_type & 0x01)) {
-			conn->auth_type |= 0x01;
-			conn->link_mode &= ~HCI_LM_AUTH;
-		}
-	}
-
-	if (conn->link_mode & HCI_LM_AUTH)
+	if (sec_level > conn->sec_level)
+		conn->sec_level = sec_level;
+	else if (conn->link_mode & HCI_LM_AUTH)
 		return 1;
 
+	conn->auth_type = auth_type;
+
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
 		struct hci_cp_auth_requested cp;
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
 							sizeof(cp), &cp);
 	}
+
 	return 0;
 }
-EXPORT_SYMBOL(hci_conn_auth);
 
-/* Enable encryption */
-int hci_conn_encrypt(struct hci_conn *conn)
+/* Enable security */
+int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
 	BT_DBG("conn %p", conn);
 
+	if (sec_level == BT_SECURITY_SDP)
+		return 1;
+
+	if (sec_level == BT_SECURITY_LOW &&
+				(!conn->ssp_mode || !conn->hdev->ssp_mode))
+		return 1;
+
 	if (conn->link_mode & HCI_LM_ENCRYPT)
-		return hci_conn_auth(conn);
+		return hci_conn_auth(conn, sec_level, auth_type);
 
 	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
 		return 0;
 
-	if (hci_conn_auth(conn)) {
+	if (hci_conn_auth(conn, sec_level, auth_type)) {
 		struct hci_cp_set_conn_encrypt cp;
 		cp.handle  = cpu_to_le16(conn->handle);
 		cp.encrypt = 1;
 		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT,
 							sizeof(cp), &cp);
 	}
+
 	return 0;
 }
-EXPORT_SYMBOL(hci_conn_encrypt);
+EXPORT_SYMBOL(hci_conn_security);
 
 /* Change link key */
 int hci_conn_change_link_key(struct hci_conn *conn)
@@ -442,12 +461,13 @@
 		hci_send_cmd(conn->hdev, HCI_OP_CHANGE_CONN_LINK_KEY,
 							sizeof(cp), &cp);
 	}
+
 	return 0;
 }
 EXPORT_SYMBOL(hci_conn_change_link_key);
 
 /* Switch role */
-int hci_conn_switch_role(struct hci_conn *conn, uint8_t role)
+int hci_conn_switch_role(struct hci_conn *conn, __u8 role)
 {
 	BT_DBG("conn %p", conn);
 
@@ -460,6 +480,7 @@
 		cp.role = role;
 		hci_send_cmd(conn->hdev, HCI_OP_SWITCH_ROLE, sizeof(cp), &cp);
 	}
+
 	return 0;
 }
 EXPORT_SYMBOL(hci_conn_switch_role);
@@ -542,9 +563,7 @@
 
 		c->state = BT_CLOSED;
 
-		hci_conn_del_sysfs(c);
-
-		hci_proto_disconn_ind(c, 0x16);
+		hci_proto_disconn_cfm(c, 0x16);
 		hci_conn_del(c);
 	}
 }
diff -Nur linux-2.6.29/net/bluetooth/hci_core.c linux-2.6.29-spica/net/bluetooth/hci_core.c
--- linux-2.6.29/net/bluetooth/hci_core.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/bluetooth/hci_core.c	2010-03-30 11:01:42.000000000 +0700
@@ -1565,8 +1565,7 @@
 
 	/* Send queued commands */
 	if (atomic_read(&hdev->cmd_cnt) && (skb = skb_dequeue(&hdev->cmd_q))) {
-		if (hdev->sent_cmd)
-			kfree_skb(hdev->sent_cmd);
+		kfree_skb(hdev->sent_cmd);
 
 		if ((hdev->sent_cmd = skb_clone(skb, GFP_ATOMIC))) {
 			atomic_dec(&hdev->cmd_cnt);
diff -Nur linux-2.6.29/net/bluetooth/hci_event.c linux-2.6.29-spica/net/bluetooth/hci_event.c
--- linux-2.6.29/net/bluetooth/hci_event.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/bluetooth/hci_event.c	2010-05-06 12:42:45.684270633 +0700
@@ -484,6 +484,15 @@
 	if (hdev->features[4] & LMP_EV5)
 		hdev->esco_type |= (ESCO_EV5);
 
+	if (hdev->features[5] & LMP_EDR_ESCO_2M)
+		hdev->esco_type |= (ESCO_2EV3);
+
+	if (hdev->features[5] & LMP_EDR_ESCO_3M)
+		hdev->esco_type |= (ESCO_3EV3);
+
+	if (hdev->features[5] & LMP_EDR_3S_ESCO)
+		hdev->esco_type |= (ESCO_2EV5 | ESCO_3EV5);
+
 	BT_DBG("%s features 0x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x", hdev->name,
 					hdev->features[0], hdev->features[1],
 					hdev->features[2], hdev->features[3],
@@ -914,7 +923,8 @@
 	if (ev->status) {
 		hci_proto_connect_cfm(conn, ev->status);
 		hci_conn_del(conn);
-	}
+	} else if (ev->link_type != ACL_LINK)
+		hci_proto_connect_cfm(conn, ev->status);
 
 unlock:
 	hci_dev_unlock(hdev);
@@ -1009,9 +1019,7 @@
 	if (conn) {
 		conn->state = BT_CLOSED;
 
-		hci_conn_del_sysfs(conn);
-
-		hci_proto_disconn_ind(conn, ev->reason);
+		hci_proto_disconn_cfm(conn, ev->reason);
 		hci_conn_del(conn);
 	}
 
@@ -1600,7 +1608,8 @@
 
 		if (conn->state == BT_CONFIG) {
 			if (!ev->status && hdev->ssp_mode > 0 &&
-					conn->ssp_mode > 0 && conn->out) {
+					conn->ssp_mode > 0 && conn->out &&
+					conn->sec_level != BT_SECURITY_SDP) {
 				struct hci_cp_auth_requested cp;
 				cp.handle = ev->handle;
 				hci_send_cmd(hdev, HCI_OP_AUTH_REQUESTED,
@@ -1637,6 +1646,15 @@
 		conn->type = SCO_LINK;
 	}
 
+	if (conn->out && (ev->status == 0x1a || ev->status == 0x1c ||
+			ev->status == 0x1f || ev->status == 0x10) &&
+			conn->attempt < 2) {
+		conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
+					(hdev->esco_type & EDR_ESCO_MASK);
+		hci_setup_sync(conn, conn->link->handle);
+		goto unlock;
+	}
+
 	if (!ev->status) {
 		conn->handle = __le16_to_cpu(ev->handle);
 		conn->state  = BT_CONNECTED;
diff -Nur linux-2.6.29/net/bluetooth/hci_sysfs.c linux-2.6.29-spica/net/bluetooth/hci_sysfs.c
--- linux-2.6.29/net/bluetooth/hci_sysfs.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/bluetooth/hci_sysfs.c	2010-03-30 11:01:42.000000000 +0700
@@ -9,8 +9,7 @@
 struct class *bt_class = NULL;
 EXPORT_SYMBOL_GPL(bt_class);
 
-static struct workqueue_struct *btaddconn;
-static struct workqueue_struct *btdelconn;
+static struct workqueue_struct *bluetooth;
 
 static inline char *link_typetostr(int type)
 {
@@ -88,9 +87,10 @@
 
 static void add_conn(struct work_struct *work)
 {
-	struct hci_conn *conn = container_of(work, struct hci_conn, work);
+	struct hci_conn *conn = container_of(work, struct hci_conn, work_add);
 
-	flush_workqueue(btdelconn);
+	/* ensure previous add/del is complete */
+	flush_workqueue(bluetooth);
 
 	if (device_add(&conn->dev) < 0) {
 		BT_ERR("Failed to register connection device");
@@ -114,9 +114,9 @@
 
 	device_initialize(&conn->dev);
 
-	INIT_WORK(&conn->work, add_conn);
+	INIT_WORK(&conn->work_add, add_conn);
 
-	queue_work(btaddconn, &conn->work);
+	queue_work(bluetooth, &conn->work_add);
 }
 
 /*
@@ -131,9 +131,12 @@
 
 static void del_conn(struct work_struct *work)
 {
-	struct hci_conn *conn = container_of(work, struct hci_conn, work);
+	struct hci_conn *conn = container_of(work, struct hci_conn, work_del);
 	struct hci_dev *hdev = conn->hdev;
 
+	/* ensure previous add/del is complete */
+	flush_workqueue(bluetooth);
+
 	while (1) {
 		struct device *dev;
 
@@ -156,9 +159,9 @@
 	if (!device_is_registered(&conn->dev))
 		return;
 
-	INIT_WORK(&conn->work, del_conn);
+	INIT_WORK(&conn->work_del, del_conn);
 
-	queue_work(btdelconn, &conn->work);
+	queue_work(bluetooth, &conn->work_del);
 }
 
 static inline char *host_typetostr(int type)
@@ -435,20 +438,13 @@
 
 int __init bt_sysfs_init(void)
 {
-	btaddconn = create_singlethread_workqueue("btaddconn");
-	if (!btaddconn)
-		return -ENOMEM;
-
-	btdelconn = create_singlethread_workqueue("btdelconn");
-	if (!btdelconn) {
-		destroy_workqueue(btaddconn);
+	bluetooth = create_singlethread_workqueue("bluetooth");
+	if (!bluetooth)
 		return -ENOMEM;
-	}
 
 	bt_class = class_create(THIS_MODULE, "bluetooth");
 	if (IS_ERR(bt_class)) {
-		destroy_workqueue(btdelconn);
-		destroy_workqueue(btaddconn);
+		destroy_workqueue(bluetooth);
 		return PTR_ERR(bt_class);
 	}
 
@@ -457,8 +453,7 @@
 
 void bt_sysfs_cleanup(void)
 {
-	destroy_workqueue(btaddconn);
-	destroy_workqueue(btdelconn);
+	destroy_workqueue(bluetooth);
 
 	class_destroy(bt_class);
 }
diff -Nur linux-2.6.29/net/bluetooth/l2cap.c linux-2.6.29-spica/net/bluetooth/l2cap.c
--- linux-2.6.29/net/bluetooth/l2cap.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/bluetooth/l2cap.c	2010-03-30 11:01:42.000000000 +0700
@@ -50,9 +50,10 @@
 #include <net/bluetooth/hci_core.h>
 #include <net/bluetooth/l2cap.h>
 
-#define VERSION "2.11"
+#define VERSION "2.13"
 
-static u32 l2cap_feat_mask = 0x0000;
+static u32 l2cap_feat_mask = 0x0080;
+static u8 l2cap_fixed_chan[8] = { 0x02, };
 
 static const struct proto_ops l2cap_sock_ops;
 
@@ -77,9 +78,10 @@
 
 	bh_lock_sock(sk);
 
-	if (sk->sk_state == BT_CONNECT &&
-			(l2cap_pi(sk)->link_mode & (L2CAP_LM_AUTH |
-					L2CAP_LM_ENCRYPT | L2CAP_LM_SECURE)))
+	if (sk->sk_state == BT_CONNECTED || sk->sk_state == BT_CONFIG)
+		reason = ECONNREFUSED;
+	else if (sk->sk_state == BT_CONNECT &&
+				l2cap_pi(sk)->sec_level != BT_SECURITY_SDP)
 		reason = ECONNREFUSED;
 	else
 		reason = ETIMEDOUT;
@@ -204,6 +206,8 @@
 
 	BT_DBG("conn %p, psm 0x%2.2x, dcid 0x%4.4x", conn, l2cap_pi(sk)->psm, l2cap_pi(sk)->dcid);
 
+	conn->disc_reason = 0x13;
+
 	l2cap_pi(sk)->conn = conn;
 
 	if (sk->sk_type == SOCK_SEQPACKET) {
@@ -259,18 +263,35 @@
 }
 
 /* Service level security */
-static inline int l2cap_check_link_mode(struct sock *sk)
+static inline int l2cap_check_security(struct sock *sk)
 {
 	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+	__u8 auth_type;
 
-	if ((l2cap_pi(sk)->link_mode & L2CAP_LM_ENCRYPT) ||
-				(l2cap_pi(sk)->link_mode & L2CAP_LM_SECURE))
-		return hci_conn_encrypt(conn->hcon);
+	if (l2cap_pi(sk)->psm == cpu_to_le16(0x0001)) {
+		if (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH)
+			auth_type = HCI_AT_NO_BONDING_MITM;
+		else
+                        auth_type = HCI_AT_NO_BONDING;
 
-	if (l2cap_pi(sk)->link_mode & L2CAP_LM_AUTH)
-		return hci_conn_auth(conn->hcon);
+		if (l2cap_pi(sk)->sec_level == BT_SECURITY_LOW)
+			l2cap_pi(sk)->sec_level = BT_SECURITY_SDP;
+	} else {
+		switch (l2cap_pi(sk)->sec_level) {
+		case BT_SECURITY_HIGH:
+			auth_type = HCI_AT_GENERAL_BONDING_MITM;
+			break;
+		case BT_SECURITY_MEDIUM:
+			auth_type = HCI_AT_GENERAL_BONDING;
+			break;
+		default:
+			auth_type = HCI_AT_NO_BONDING;
+			break;
+		}
+	}
 
-	return 1;
+	return hci_conn_security(conn->hcon, l2cap_pi(sk)->sec_level,
+								auth_type);
 }
 
 static inline u8 l2cap_get_ident(struct l2cap_conn *conn)
@@ -312,7 +333,10 @@
 	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
 
 	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) {
-		if (l2cap_check_link_mode(sk)) {
+		if (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))
+			return;
+
+		if (l2cap_check_security(sk)) {
 			struct l2cap_conn_req req;
 			req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
 			req.psm  = l2cap_pi(sk)->psm;
@@ -356,7 +380,7 @@
 		}
 
 		if (sk->sk_state == BT_CONNECT) {
-			if (l2cap_check_link_mode(sk)) {
+			if (l2cap_check_security(sk)) {
 				struct l2cap_conn_req req;
 				req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
 				req.psm  = l2cap_pi(sk)->psm;
@@ -371,10 +395,18 @@
 			rsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);
 			rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);
 
-			if (l2cap_check_link_mode(sk)) {
-				sk->sk_state = BT_CONFIG;
-				rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
-				rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
+			if (l2cap_check_security(sk)) {
+				if (bt_sk(sk)->defer_setup) {
+					struct sock *parent = bt_sk(sk)->parent;
+					rsp.result = cpu_to_le16(L2CAP_CR_PEND);
+					rsp.status = cpu_to_le16(L2CAP_CS_AUTHOR_PEND);
+					parent->sk_data_ready(parent, 0);
+
+				} else {
+					sk->sk_state = BT_CONFIG;
+					rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
+					rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
+				}
 			} else {
 				rsp.result = cpu_to_le16(L2CAP_CR_PEND);
 				rsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);
@@ -426,7 +458,7 @@
 	read_lock(&l->lock);
 
 	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		if (l2cap_pi(sk)->link_mode & L2CAP_LM_RELIABLE)
+		if (l2cap_pi(sk)->force_reliable)
 			sk->sk_err = err;
 	}
 
@@ -437,6 +469,7 @@
 {
 	struct l2cap_conn *conn = (void *) arg;
 
+	conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
 	conn->info_ident = 0;
 
 	l2cap_conn_start(conn);
@@ -470,6 +503,8 @@
 	spin_lock_init(&conn->lock);
 	rwlock_init(&conn->chan_list.lock);
 
+	conn->disc_reason = 0x13;
+
 	return conn;
 }
 
@@ -483,8 +518,7 @@
 
 	BT_DBG("hcon %p conn %p, err %d", hcon, conn, err);
 
-	if (conn->rx_skb)
-		kfree_skb(conn->rx_skb);
+	kfree_skb(conn->rx_skb);
 
 	/* Kill channels */
 	while ((sk = conn->chan_list.head)) {
@@ -608,7 +642,6 @@
 
 	case BT_CONNECTED:
 	case BT_CONFIG:
-	case BT_CONNECT2:
 		if (sk->sk_type == SOCK_SEQPACKET) {
 			struct l2cap_conn *conn = l2cap_pi(sk)->conn;
 			struct l2cap_disconn_req req;
@@ -624,6 +657,27 @@
 			l2cap_chan_del(sk, reason);
 		break;
 
+	case BT_CONNECT2:
+		if (sk->sk_type == SOCK_SEQPACKET) {
+			struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+			struct l2cap_conn_rsp rsp;
+			__u16 result;
+
+			if (bt_sk(sk)->defer_setup)
+				result = L2CAP_CR_SEC_BLOCK;
+			else
+				result = L2CAP_CR_BAD_PSM;
+
+			rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
+			rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
+			rsp.result = cpu_to_le16(result);
+			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
+			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
+					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
+		} else
+			l2cap_chan_del(sk, reason);
+		break;
+
 	case BT_CONNECT:
 	case BT_DISCONN:
 		l2cap_chan_del(sk, reason);
@@ -653,13 +707,19 @@
 
 	if (parent) {
 		sk->sk_type = parent->sk_type;
+		bt_sk(sk)->defer_setup = bt_sk(parent)->defer_setup;
+
 		pi->imtu = l2cap_pi(parent)->imtu;
 		pi->omtu = l2cap_pi(parent)->omtu;
-		pi->link_mode = l2cap_pi(parent)->link_mode;
+		pi->sec_level = l2cap_pi(parent)->sec_level;
+		pi->role_switch = l2cap_pi(parent)->role_switch;
+		pi->force_reliable = l2cap_pi(parent)->force_reliable;
 	} else {
 		pi->imtu = L2CAP_DEFAULT_MTU;
 		pi->omtu = 0;
-		pi->link_mode = 0;
+		pi->sec_level = BT_SECURITY_LOW;
+		pi->role_switch = 0;
+		pi->force_reliable = 0;
 	}
 
 	/* Default config options */
@@ -723,17 +783,24 @@
 	return 0;
 }
 
-static int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
+static int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 {
-	struct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;
 	struct sock *sk = sock->sk;
-	int err = 0;
+	struct sockaddr_l2 la;
+	int len, err = 0;
 
-	BT_DBG("sk %p, %s %d", sk, batostr(&la->l2_bdaddr), la->l2_psm);
+	BT_DBG("sk %p", sk);
 
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
+	memset(&la, 0, sizeof(la));
+	len = min_t(unsigned int, sizeof(la), alen);
+	memcpy(&la, addr, len);
+
+	if (la.l2_cid)
+		return -EINVAL;
+
 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {
@@ -741,7 +808,7 @@
 		goto done;
 	}
 
-	if (la->l2_psm && btohs(la->l2_psm) < 0x1001 &&
+	if (la.l2_psm && btohs(la.l2_psm) < 0x1001 &&
 				!capable(CAP_NET_BIND_SERVICE)) {
 		err = -EACCES;
 		goto done;
@@ -749,14 +816,17 @@
 
 	write_lock_bh(&l2cap_sk_list.lock);
 
-	if (la->l2_psm && __l2cap_get_sock_by_addr(la->l2_psm, &la->l2_bdaddr)) {
+	if (la.l2_psm && __l2cap_get_sock_by_addr(la.l2_psm, &la.l2_bdaddr)) {
 		err = -EADDRINUSE;
 	} else {
 		/* Save source address */
-		bacpy(&bt_sk(sk)->src, &la->l2_bdaddr);
-		l2cap_pi(sk)->psm   = la->l2_psm;
-		l2cap_pi(sk)->sport = la->l2_psm;
+		bacpy(&bt_sk(sk)->src, &la.l2_bdaddr);
+		l2cap_pi(sk)->psm   = la.l2_psm;
+		l2cap_pi(sk)->sport = la.l2_psm;
 		sk->sk_state = BT_BOUND;
+
+		if (btohs(la.l2_psm) == 0x0001 || btohs(la.l2_psm) == 0x0003)
+			l2cap_pi(sk)->sec_level = BT_SECURITY_SDP;
 	}
 
 	write_unlock_bh(&l2cap_sk_list.lock);
@@ -776,7 +846,8 @@
 	__u8 auth_type;
 	int err = 0;
 
-	BT_DBG("%s -> %s psm 0x%2.2x", batostr(src), batostr(dst), l2cap_pi(sk)->psm);
+	BT_DBG("%s -> %s psm 0x%2.2x", batostr(src), batostr(dst),
+							l2cap_pi(sk)->psm);
 
 	if (!(hdev = hci_get_route(dst, src)))
 		return -EHOSTUNREACH;
@@ -785,21 +856,42 @@
 
 	err = -ENOMEM;
 
-	if (l2cap_pi(sk)->link_mode & L2CAP_LM_AUTH ||
-			l2cap_pi(sk)->link_mode & L2CAP_LM_ENCRYPT ||
-				l2cap_pi(sk)->link_mode & L2CAP_LM_SECURE) {
-		if (l2cap_pi(sk)->psm == cpu_to_le16(0x0001))
+	if (sk->sk_type == SOCK_RAW) {
+		switch (l2cap_pi(sk)->sec_level) {
+		case BT_SECURITY_HIGH:
+			auth_type = HCI_AT_DEDICATED_BONDING_MITM;
+			break;
+		case BT_SECURITY_MEDIUM:
+			auth_type = HCI_AT_DEDICATED_BONDING;
+			break;
+		default:
+			auth_type = HCI_AT_NO_BONDING;
+			break;
+		}
+	} else if (l2cap_pi(sk)->psm == cpu_to_le16(0x0001)) {
+		if (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH)
 			auth_type = HCI_AT_NO_BONDING_MITM;
 		else
-			auth_type = HCI_AT_GENERAL_BONDING_MITM;
-	} else {
-		if (l2cap_pi(sk)->psm == cpu_to_le16(0x0001))
 			auth_type = HCI_AT_NO_BONDING;
-		else
+
+		if (l2cap_pi(sk)->sec_level == BT_SECURITY_LOW)
+			l2cap_pi(sk)->sec_level = BT_SECURITY_SDP;
+	} else {
+		switch (l2cap_pi(sk)->sec_level) {
+		case BT_SECURITY_HIGH:
+			auth_type = HCI_AT_GENERAL_BONDING_MITM;
+			break;
+		case BT_SECURITY_MEDIUM:
 			auth_type = HCI_AT_GENERAL_BONDING;
+			break;
+		default:
+			auth_type = HCI_AT_NO_BONDING;
+			break;
+		}
 	}
 
-	hcon = hci_connect(hdev, ACL_LINK, dst, auth_type);
+	hcon = hci_connect(hdev, ACL_LINK, dst,
+					l2cap_pi(sk)->sec_level, auth_type);
 	if (!hcon)
 		goto done;
 
@@ -835,20 +927,25 @@
 
 static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)
 {
-	struct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;
 	struct sock *sk = sock->sk;
-	int err = 0;
-
-	lock_sock(sk);
+	struct sockaddr_l2 la;
+	int len, err = 0;
 
 	BT_DBG("sk %p", sk);
 
-	if (addr->sa_family != AF_BLUETOOTH || alen < sizeof(struct sockaddr_l2)) {
-		err = -EINVAL;
-		goto done;
-	}
+	if (!addr || addr->sa_family != AF_BLUETOOTH)
+		return -EINVAL;
+
+	memset(&la, 0, sizeof(la));
+	len = min_t(unsigned int, sizeof(la), alen);
+	memcpy(&la, addr, len);
+
+	if (la.l2_cid)
+		return -EINVAL;
+
+	lock_sock(sk);
 
-	if (sk->sk_type == SOCK_SEQPACKET && !la->l2_psm) {
+	if (sk->sk_type == SOCK_SEQPACKET && !la.l2_psm) {
 		err = -EINVAL;
 		goto done;
 	}
@@ -875,8 +972,8 @@
 	}
 
 	/* Set destination address and psm */
-	bacpy(&bt_sk(sk)->dst, &la->l2_bdaddr);
-	l2cap_pi(sk)->psm = la->l2_psm;
+	bacpy(&bt_sk(sk)->dst, &la.l2_bdaddr);
+	l2cap_pi(sk)->psm = la.l2_psm;
 
 	if ((err = l2cap_do_connect(sk)))
 		goto done;
@@ -1000,12 +1097,16 @@
 	addr->sa_family = AF_BLUETOOTH;
 	*len = sizeof(struct sockaddr_l2);
 
-	if (peer)
+	if (peer) {
+		la->l2_psm = l2cap_pi(sk)->psm;
 		bacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);
-	else
+		la->l2_cid = htobs(l2cap_pi(sk)->dcid);
+	} else {
+		la->l2_psm = l2cap_pi(sk)->sport;
 		bacpy(&la->l2_bdaddr, &bt_sk(sk)->src);
+		la->l2_cid = htobs(l2cap_pi(sk)->scid);
+	}
 
-	la->l2_psm = l2cap_pi(sk)->psm;
 	return 0;
 }
 
@@ -1106,11 +1207,38 @@
 	return err;
 }
 
-static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, int optlen)
+static int l2cap_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len, int flags)
+{
+	struct sock *sk = sock->sk;
+
+	lock_sock(sk);
+
+	if (sk->sk_state == BT_CONNECT2 && bt_sk(sk)->defer_setup) {
+		struct l2cap_conn_rsp rsp;
+
+		sk->sk_state = BT_CONFIG;
+
+		rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
+		rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
+		rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
+		rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
+		l2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,
+					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
+
+		release_sock(sk);
+		return 0;
+	}
+
+	release_sock(sk);
+
+	return bt_sock_recvmsg(iocb, sock, msg, len, flags);
+}
+
+static int l2cap_sock_setsockopt_old(struct socket *sock, int optname, char __user *optval, int optlen)
 {
 	struct sock *sk = sock->sk;
 	struct l2cap_options opts;
-	int err = 0, len;
+	int len, err = 0;
 	u32 opt;
 
 	BT_DBG("sk %p", sk);
@@ -1140,7 +1268,15 @@
 			break;
 		}
 
-		l2cap_pi(sk)->link_mode = opt;
+		if (opt & L2CAP_LM_AUTH)
+			l2cap_pi(sk)->sec_level = BT_SECURITY_LOW;
+		if (opt & L2CAP_LM_ENCRYPT)
+			l2cap_pi(sk)->sec_level = BT_SECURITY_MEDIUM;
+		if (opt & L2CAP_LM_SECURE)
+			l2cap_pi(sk)->sec_level = BT_SECURITY_HIGH;
+
+		l2cap_pi(sk)->role_switch    = (opt & L2CAP_LM_MASTER);
+		l2cap_pi(sk)->force_reliable = (opt & L2CAP_LM_RELIABLE);
 		break;
 
 	default:
@@ -1152,12 +1288,77 @@
 	return err;
 }
 
-static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)
+static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct bt_security sec;
+	int len, err = 0;
+	u32 opt;
+
+	BT_DBG("sk %p", sk);
+
+	if (level == SOL_L2CAP)
+		return l2cap_sock_setsockopt_old(sock, optname, optval, optlen);
+
+	if (level != SOL_BLUETOOTH)
+		return -ENOPROTOOPT;
+
+	lock_sock(sk);
+
+	switch (optname) {
+	case BT_SECURITY:
+		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_RAW) {
+			err = -EINVAL;
+			break;
+		}
+
+		sec.level = BT_SECURITY_LOW;
+
+		len = min_t(unsigned int, sizeof(sec), optlen);
+		if (copy_from_user((char *) &sec, optval, len)) {
+			err = -EFAULT;
+			break;
+		}
+
+		if (sec.level < BT_SECURITY_LOW ||
+					sec.level > BT_SECURITY_HIGH) {
+			err = -EINVAL;
+			break;
+		}
+
+		l2cap_pi(sk)->sec_level = sec.level;
+		break;
+
+	case BT_DEFER_SETUP:
+		if (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {
+			err = -EINVAL;
+			break;
+		}
+
+		if (get_user(opt, (u32 __user *) optval)) {
+			err = -EFAULT;
+			break;
+		}
+
+		bt_sk(sk)->defer_setup = opt;
+		break;
+
+	default:
+		err = -ENOPROTOOPT;
+		break;
+	}
+
+	release_sock(sk);
+	return err;
+}
+
+static int l2cap_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
 	struct l2cap_options opts;
 	struct l2cap_conninfo cinfo;
 	int len, err = 0;
+	u32 opt;
 
 	BT_DBG("sk %p", sk);
 
@@ -1180,12 +1381,36 @@
 		break;
 
 	case L2CAP_LM:
-		if (put_user(l2cap_pi(sk)->link_mode, (u32 __user *) optval))
+		switch (l2cap_pi(sk)->sec_level) {
+		case BT_SECURITY_LOW:
+			opt = L2CAP_LM_AUTH;
+			break;
+		case BT_SECURITY_MEDIUM:
+			opt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT;
+			break;
+		case BT_SECURITY_HIGH:
+			opt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT |
+							L2CAP_LM_SECURE;
+			break;
+		default:
+			opt = 0;
+			break;
+		}
+
+		if (l2cap_pi(sk)->role_switch)
+			opt |= L2CAP_LM_MASTER;
+
+		if (l2cap_pi(sk)->force_reliable)
+			opt |= L2CAP_LM_RELIABLE;
+
+		if (put_user(opt, (u32 __user *) optval))
 			err = -EFAULT;
 		break;
 
 	case L2CAP_CONNINFO:
-		if (sk->sk_state != BT_CONNECTED) {
+		if (sk->sk_state != BT_CONNECTED &&
+					!(sk->sk_state == BT_CONNECT2 &&
+						bt_sk(sk)->defer_setup)) {
 			err = -ENOTCONN;
 			break;
 		}
@@ -1208,6 +1433,60 @@
 	return err;
 }
 
+static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)
+{
+	struct sock *sk = sock->sk;
+	struct bt_security sec;
+	int len, err = 0;
+
+	BT_DBG("sk %p", sk);
+
+	if (level == SOL_L2CAP)
+		return l2cap_sock_getsockopt_old(sock, optname, optval, optlen);
+
+	if (level != SOL_BLUETOOTH)
+		return -ENOPROTOOPT;
+
+	if (get_user(len, optlen))
+		return -EFAULT;
+
+	lock_sock(sk);
+
+	switch (optname) {
+	case BT_SECURITY:
+		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_RAW) {
+			err = -EINVAL;
+			break;
+		}
+
+		sec.level = l2cap_pi(sk)->sec_level;
+
+		len = min_t(unsigned int, len, sizeof(sec));
+		if (copy_to_user(optval, (char *) &sec, len))
+			err = -EFAULT;
+
+		break;
+
+	case BT_DEFER_SETUP:
+		if (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {
+			err = -EINVAL;
+			break;
+		}
+
+		if (put_user(bt_sk(sk)->defer_setup, (u32 __user *) optval))
+			err = -EFAULT;
+
+		break;
+
+	default:
+		err = -ENOPROTOOPT;
+		break;
+	}
+
+	release_sock(sk);
+	return err;
+}
+
 static int l2cap_sock_shutdown(struct socket *sock, int how)
 {
 	struct sock *sk = sock->sk;
@@ -1270,11 +1549,6 @@
 		 */
 		parent->sk_data_ready(parent, 0);
 	}
-
-	if (l2cap_pi(sk)->link_mode & L2CAP_LM_SECURE) {
-		struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-		hci_conn_change_link_key(conn->hcon);
-	}
 }
 
 /* Copy frame to all raw sockets on that connection */
@@ -1549,8 +1823,11 @@
 
 	if ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&
 					cmd->ident == conn->info_ident) {
-		conn->info_ident = 0;
 		del_timer(&conn->info_timer);
+
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+		conn->info_ident = 0;
+
 		l2cap_conn_start(conn);
 	}
 
@@ -1580,6 +1857,7 @@
 	/* Check if the ACL is secure enough (if not SDP) */
 	if (psm != cpu_to_le16(0x0001) &&
 				!hci_conn_check_link_mode(conn->hcon)) {
+		conn->disc_reason = 0x05;
 		result = L2CAP_CR_SEC_BLOCK;
 		goto response;
 	}
@@ -1621,11 +1899,18 @@
 
 	l2cap_pi(sk)->ident = cmd->ident;
 
-	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) {
-		if (l2cap_check_link_mode(sk)) {
-			sk->sk_state = BT_CONFIG;
-			result = L2CAP_CR_SUCCESS;
-			status = L2CAP_CS_NO_INFO;
+	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {
+		if (l2cap_check_security(sk)) {
+			if (bt_sk(sk)->defer_setup) {
+				sk->sk_state = BT_CONNECT2;
+				result = L2CAP_CR_PEND;
+				status = L2CAP_CS_AUTHOR_PEND;
+				parent->sk_data_ready(parent, 0);
+			} else {
+				sk->sk_state = BT_CONFIG;
+				result = L2CAP_CR_SUCCESS;
+				status = L2CAP_CS_NO_INFO;
+			}
 		} else {
 			sk->sk_state = BT_CONNECT2;
 			result = L2CAP_CR_PEND;
@@ -1695,11 +1980,14 @@
 		l2cap_pi(sk)->dcid = dcid;
 		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
 
+		l2cap_pi(sk)->conf_state &= ~L2CAP_CONF_CONNECT_PEND;
+
 		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
 					l2cap_build_conf_req(sk, req), req);
 		break;
 
 	case L2CAP_CR_PEND:
+		l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
 		break;
 
 	default:
@@ -1908,6 +2196,14 @@
 		put_unaligned(cpu_to_le32(l2cap_feat_mask), (__le32 *) rsp->data);
 		l2cap_send_cmd(conn, cmd->ident,
 					L2CAP_INFO_RSP, sizeof(buf), buf);
+	} else if (type == L2CAP_IT_FIXED_CHAN) {
+		u8 buf[12];
+		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
+		rsp->type   = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
+		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
+		memcpy(buf + 4, l2cap_fixed_chan, 8);
+		l2cap_send_cmd(conn, cmd->ident,
+					L2CAP_INFO_RSP, sizeof(buf), buf);
 	} else {
 		struct l2cap_info_rsp rsp;
 		rsp.type   = cpu_to_le16(type);
@@ -1929,14 +2225,31 @@
 
 	BT_DBG("type 0x%4.4x result 0x%2.2x", type, result);
 
-	conn->info_ident = 0;
-
 	del_timer(&conn->info_timer);
 
-	if (type == L2CAP_IT_FEAT_MASK)
+	if (type == L2CAP_IT_FEAT_MASK) {
 		conn->feat_mask = get_unaligned_le32(rsp->data);
 
-	l2cap_conn_start(conn);
+		if (conn->feat_mask & 0x0080) {
+			struct l2cap_info_req req;
+			req.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
+
+			conn->info_ident = l2cap_get_ident(conn);
+
+			l2cap_send_cmd(conn, conn->info_ident,
+					L2CAP_INFO_REQ, sizeof(req), &req);
+		} else {
+			conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+			conn->info_ident = 0;
+
+			l2cap_conn_start(conn);
+		}
+	} else if (type == L2CAP_IT_FIXED_CHAN) {
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+		conn->info_ident = 0;
+
+		l2cap_conn_start(conn);
+	}
 
 	return 0;
 }
@@ -2143,10 +2456,15 @@
 			continue;
 
 		if (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr)) {
-			lm1 |= (HCI_LM_ACCEPT | l2cap_pi(sk)->link_mode);
+			lm1 |= HCI_LM_ACCEPT;
+			if (l2cap_pi(sk)->role_switch)
+				lm1 |= HCI_LM_MASTER;
 			exact++;
-		} else if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))
-			lm2 |= (HCI_LM_ACCEPT | l2cap_pi(sk)->link_mode);
+		} else if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {
+			lm2 |= HCI_LM_ACCEPT;
+			if (l2cap_pi(sk)->role_switch)
+				lm2 |= HCI_LM_MASTER;
+		}
 	}
 	read_unlock(&l2cap_sk_list.lock);
 
@@ -2172,89 +2490,48 @@
 	return 0;
 }
 
-static int l2cap_disconn_ind(struct hci_conn *hcon, u8 reason)
+static int l2cap_disconn_ind(struct hci_conn *hcon)
 {
-	BT_DBG("hcon %p reason %d", hcon, reason);
+	struct l2cap_conn *conn = hcon->l2cap_data;
 
-	if (hcon->type != ACL_LINK)
-		return 0;
+	BT_DBG("hcon %p", hcon);
 
-	l2cap_conn_del(hcon, bt_err(reason));
+	if (hcon->type != ACL_LINK || !conn)
+		return 0x13;
 
-	return 0;
+	return conn->disc_reason;
 }
 
-static int l2cap_auth_cfm(struct hci_conn *hcon, u8 status)
+static int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason)
 {
-	struct l2cap_chan_list *l;
-	struct l2cap_conn *conn = hcon->l2cap_data;
-	struct sock *sk;
+	BT_DBG("hcon %p reason %d", hcon, reason);
 
-	if (!conn)
+	if (hcon->type != ACL_LINK)
 		return 0;
 
-	l = &conn->chan_list;
-
-	BT_DBG("conn %p", conn);
-
-	read_lock(&l->lock);
-
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		struct l2cap_pinfo *pi = l2cap_pi(sk);
-
-		bh_lock_sock(sk);
-
-		if ((pi->link_mode & (L2CAP_LM_ENCRYPT | L2CAP_LM_SECURE)) &&
-					!(hcon->link_mode & HCI_LM_ENCRYPT) &&
-								!status) {
-			bh_unlock_sock(sk);
-			continue;
-		}
-
-		if (sk->sk_state == BT_CONNECT) {
-			if (!status) {
-				struct l2cap_conn_req req;
-				req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
-				req.psm  = l2cap_pi(sk)->psm;
-
-				l2cap_pi(sk)->ident = l2cap_get_ident(conn);
-
-				l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_REQ, sizeof(req), &req);
-			} else {
-				l2cap_sock_clear_timer(sk);
-				l2cap_sock_set_timer(sk, HZ / 10);
-			}
-		} else if (sk->sk_state == BT_CONNECT2) {
-			struct l2cap_conn_rsp rsp;
-			__u16 result;
+	l2cap_conn_del(hcon, bt_err(reason));
 
-			if (!status) {
-				sk->sk_state = BT_CONFIG;
-				result = L2CAP_CR_SUCCESS;
-			} else {
-				sk->sk_state = BT_DISCONN;
-				l2cap_sock_set_timer(sk, HZ / 10);
-				result = L2CAP_CR_SEC_BLOCK;
-			}
+	return 0;
+}
 
-			rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-			rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
-			rsp.result = cpu_to_le16(result);
-			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
-		}
+static inline void l2cap_check_encryption(struct sock *sk, u8 encrypt)
+{
+	if (sk->sk_type != SOCK_SEQPACKET)
+		return;
 
-		bh_unlock_sock(sk);
+	if (encrypt == 0x00) {
+		if (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM) {
+			l2cap_sock_clear_timer(sk);
+			l2cap_sock_set_timer(sk, HZ * 5);
+		} else if (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH)
+			__l2cap_sock_close(sk, ECONNREFUSED);
+	} else {
+		if (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM)
+			l2cap_sock_clear_timer(sk);
 	}
-
-	read_unlock(&l->lock);
-
-	return 0;
 }
 
-static int l2cap_encrypt_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)
+static int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)
 {
 	struct l2cap_chan_list *l;
 	struct l2cap_conn *conn = hcon->l2cap_data;
@@ -2270,15 +2547,16 @@
 	read_lock(&l->lock);
 
 	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		struct l2cap_pinfo *pi = l2cap_pi(sk);
-
 		bh_lock_sock(sk);
 
-		if ((pi->link_mode & (L2CAP_LM_ENCRYPT | L2CAP_LM_SECURE)) &&
-					(sk->sk_state == BT_CONNECTED ||
-						sk->sk_state == BT_CONFIG) &&
-						!status && encrypt == 0x00) {
-			__l2cap_sock_close(sk, ECONNREFUSED);
+		if (l2cap_pi(sk)->conf_state & L2CAP_CONF_CONNECT_PEND) {
+			bh_unlock_sock(sk);
+			continue;
+		}
+
+		if (!status && (sk->sk_state == BT_CONNECTED ||
+						sk->sk_state == BT_CONFIG)) {
+			l2cap_check_encryption(sk, encrypt);
 			bh_unlock_sock(sk);
 			continue;
 		}
@@ -2376,7 +2654,7 @@
 			goto drop;
 
 		skb_copy_from_linear_data(skb, skb_put(conn->rx_skb, skb->len),
-			      skb->len);
+								skb->len);
 		conn->rx_len = len - skb->len;
 	} else {
 		BT_DBG("Cont: frag len %d (expecting %d)", skb->len, conn->rx_len);
@@ -2398,7 +2676,7 @@
 		}
 
 		skb_copy_from_linear_data(skb, skb_put(conn->rx_skb, skb->len),
-			      skb->len);
+								skb->len);
 		conn->rx_len -= skb->len;
 
 		if (!conn->rx_len) {
@@ -2424,10 +2702,10 @@
 	sk_for_each(sk, node, &l2cap_sk_list.head) {
 		struct l2cap_pinfo *pi = l2cap_pi(sk);
 
-		str += sprintf(str, "%s %s %d %d 0x%4.4x 0x%4.4x %d %d 0x%x\n",
+		str += sprintf(str, "%s %s %d %d 0x%4.4x 0x%4.4x %d %d %d\n",
 				batostr(&bt_sk(sk)->src), batostr(&bt_sk(sk)->dst),
 				sk->sk_state, btohs(pi->psm), pi->scid, pi->dcid,
-				pi->imtu, pi->omtu, pi->link_mode);
+				pi->imtu, pi->omtu, pi->sec_level);
 	}
 
 	read_unlock_bh(&l2cap_sk_list.lock);
@@ -2447,7 +2725,7 @@
 	.accept		= l2cap_sock_accept,
 	.getname	= l2cap_sock_getname,
 	.sendmsg	= l2cap_sock_sendmsg,
-	.recvmsg	= bt_sock_recvmsg,
+	.recvmsg	= l2cap_sock_recvmsg,
 	.poll		= bt_sock_poll,
 	.ioctl		= bt_sock_ioctl,
 	.mmap		= sock_no_mmap,
@@ -2469,8 +2747,8 @@
 	.connect_ind	= l2cap_connect_ind,
 	.connect_cfm	= l2cap_connect_cfm,
 	.disconn_ind	= l2cap_disconn_ind,
-	.auth_cfm	= l2cap_auth_cfm,
-	.encrypt_cfm	= l2cap_encrypt_cfm,
+	.disconn_cfm	= l2cap_disconn_cfm,
+	.security_cfm	= l2cap_security_cfm,
 	.recv_acldata	= l2cap_recv_acldata
 };
 
diff -Nur linux-2.6.29/net/bluetooth/rfcomm/core.c linux-2.6.29-spica/net/bluetooth/rfcomm/core.c
--- linux-2.6.29/net/bluetooth/rfcomm/core.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/bluetooth/rfcomm/core.c	2010-05-06 12:42:45.684270633 +0700
@@ -46,7 +46,7 @@
 #include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/rfcomm.h>
 
-#define VERSION "1.10"
+#define VERSION "1.11"
 
 static int disable_cfc = 0;
 static int channel_mtu = -1;
@@ -223,19 +223,25 @@
 	return err;
 }
 
-static inline int rfcomm_check_link_mode(struct rfcomm_dlc *d)
+static inline int rfcomm_check_security(struct rfcomm_dlc *d)
 {
 	struct sock *sk = d->session->sock->sk;
+	__u8 auth_type;
 
-	if (d->link_mode & (RFCOMM_LM_ENCRYPT | RFCOMM_LM_SECURE)) {
-		if (!hci_conn_encrypt(l2cap_pi(sk)->conn->hcon))
-			return 1;
-	} else if (d->link_mode & RFCOMM_LM_AUTH) {
-		if (!hci_conn_auth(l2cap_pi(sk)->conn->hcon))
-			return 1;
+	switch (d->sec_level) {
+	case BT_SECURITY_HIGH:
+		auth_type = HCI_AT_GENERAL_BONDING_MITM;
+		break;
+	case BT_SECURITY_MEDIUM:
+		auth_type = HCI_AT_GENERAL_BONDING;
+		break;
+	default:
+		auth_type = HCI_AT_NO_BONDING;
+		break;
 	}
 
-	return 0;
+	return hci_conn_security(l2cap_pi(sk)->conn->hcon, d->sec_level,
+								auth_type);
 }
 
 /* ---- RFCOMM DLCs ---- */
@@ -388,10 +394,10 @@
 	d->cfc = (s->cfc == RFCOMM_CFC_UNKNOWN) ? 0 : s->cfc;
 
 	if (s->state == BT_CONNECTED) {
-		if (rfcomm_check_link_mode(d))
-			set_bit(RFCOMM_AUTH_PENDING, &d->flags);
-		else
+		if (rfcomm_check_security(d))
 			rfcomm_send_pn(s, 1, d);
+		else
+			set_bit(RFCOMM_AUTH_PENDING, &d->flags);
 	}
 
 	rfcomm_dlc_set_timer(d, RFCOMM_CONN_TIMEOUT);
@@ -421,9 +427,15 @@
 			d, d->state, d->dlci, err, s);
 
 	switch (d->state) {
-	case BT_CONNECTED:
-	case BT_CONFIG:
 	case BT_CONNECT:
+		if (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {
+			set_bit(RFCOMM_AUTH_REJECT, &d->flags);
+			rfcomm_schedule(RFCOMM_SCHED_AUTH);
+			break;
+		}
+		/* Fall through */
+
+	case BT_CONNECTED:
 		d->state = BT_DISCONN;
 		if (skb_queue_empty(&d->tx_queue)) {
 			rfcomm_send_disc(s, d->dlci);
@@ -434,6 +446,15 @@
 		}
 		break;
 
+	case BT_OPEN:
+	case BT_CONNECT2:
+		if (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {
+			set_bit(RFCOMM_AUTH_REJECT, &d->flags);
+			rfcomm_schedule(RFCOMM_SCHED_AUTH);
+			break;
+		}
+		/* Fall through */
+
 	default:
 		rfcomm_dlc_clear_timer(d);
 
@@ -636,6 +657,7 @@
 	bacpy(&addr.l2_bdaddr, src);
 	addr.l2_family = AF_BLUETOOTH;
 	addr.l2_psm    = 0;
+	addr.l2_cid    = 0;
 	*err = kernel_bind(sock, (struct sockaddr *) &addr, sizeof(addr));
 	if (*err < 0)
 		goto failed;
@@ -657,6 +679,7 @@
 	bacpy(&addr.l2_bdaddr, dst);
 	addr.l2_family = AF_BLUETOOTH;
 	addr.l2_psm    = htobs(RFCOMM_PSM);
+	addr.l2_cid    = 0;
 	*err = kernel_connect(sock, (struct sockaddr *) &addr, sizeof(addr), O_NONBLOCK);
 	if (*err == 0 || *err == -EINPROGRESS)
 		return s;
@@ -1089,7 +1112,8 @@
 			break;
 
 		case BT_DISCONN:
-			rfcomm_session_put(s);
+			if (s->sock->sk->sk_state != BT_CLOSED)
+				rfcomm_session_put(s);
 			break;
 		}
 	}
@@ -1162,7 +1186,7 @@
 	return 0;
 }
 
-static void rfcomm_dlc_accept(struct rfcomm_dlc *d)
+void rfcomm_dlc_accept(struct rfcomm_dlc *d)
 {
 	struct sock *sk = d->session->sock->sk;
 
@@ -1175,12 +1199,31 @@
 	d->state_change(d, 0);
 	rfcomm_dlc_unlock(d);
 
-	if (d->link_mode & RFCOMM_LM_MASTER)
+	if (d->role_switch)
 		hci_conn_switch_role(l2cap_pi(sk)->conn->hcon, 0x00);
 
 	rfcomm_send_msc(d->session, 1, d->dlci, d->v24_sig);
 }
 
+static void rfcomm_check_accept(struct rfcomm_dlc *d)
+{
+	if (rfcomm_check_security(d)) {
+		if (d->defer_setup) {
+			set_bit(RFCOMM_DEFER_SETUP, &d->flags);
+			rfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);
+
+			rfcomm_dlc_lock(d);
+			d->state = BT_CONNECT2;
+			d->state_change(d, 0);
+			rfcomm_dlc_unlock(d);
+		} else
+			rfcomm_dlc_accept(d);
+	} else {
+		set_bit(RFCOMM_AUTH_PENDING, &d->flags);
+		rfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);
+	}
+}
+
 static int rfcomm_recv_sabm(struct rfcomm_session *s, u8 dlci)
 {
 	struct rfcomm_dlc *d;
@@ -1203,11 +1246,7 @@
 	if (d) {
 		if (d->state == BT_OPEN) {
 			/* DLC was previously opened by PN request */
-			if (rfcomm_check_link_mode(d)) {
-				set_bit(RFCOMM_AUTH_PENDING, &d->flags);
-				rfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);
-			} else
-				rfcomm_dlc_accept(d);
+			rfcomm_check_accept(d);
 		}
 		return 0;
 	}
@@ -1219,11 +1258,7 @@
 		d->addr = __addr(s->initiator, dlci);
 		rfcomm_dlc_link(s, d);
 
-		if (rfcomm_check_link_mode(d)) {
-			set_bit(RFCOMM_AUTH_PENDING, &d->flags);
-			rfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);
-		} else
-			rfcomm_dlc_accept(d);
+		rfcomm_check_accept(d);
 	} else {
 		rfcomm_send_dm(s, dlci);
 	}
@@ -1637,11 +1672,12 @@
 		d = list_entry(p, struct rfcomm_dlc, list);
 		if (d->state == BT_CONFIG) {
 			d->mtu = s->mtu;
-			if (rfcomm_check_link_mode(d)) {
+			if (rfcomm_check_security(d)) {
+				rfcomm_send_pn(s, 1, d);
+			} else {
 				set_bit(RFCOMM_AUTH_PENDING, &d->flags);
 				rfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);
-			} else
-				rfcomm_send_pn(s, 1, d);
+			}
 		}
 	}
 }
@@ -1717,11 +1753,17 @@
 			if (d->out) {
 				rfcomm_send_pn(s, 1, d);
 				rfcomm_dlc_set_timer(d, RFCOMM_CONN_TIMEOUT);
-			} else
-				rfcomm_dlc_accept(d);
-			if (d->link_mode & RFCOMM_LM_SECURE) {
-				struct sock *sk = s->sock->sk;
-				hci_conn_change_link_key(l2cap_pi(sk)->conn->hcon);
+			} else {
+				if (d->defer_setup) {
+					set_bit(RFCOMM_DEFER_SETUP, &d->flags);
+					rfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);
+
+					rfcomm_dlc_lock(d);
+					d->state = BT_CONNECT2;
+					d->state_change(d, 0);
+					rfcomm_dlc_unlock(d);
+				} else
+					rfcomm_dlc_accept(d);
 			}
 			continue;
 		} else if (test_and_clear_bit(RFCOMM_AUTH_REJECT, &d->flags)) {
@@ -1734,6 +1776,9 @@
 			continue;
 		}
 
+		if (test_bit(RFCOMM_SEC_PENDING, &d->flags))
+			continue;
+
 		if (test_bit(RFCOMM_TX_THROTTLED, &s->flags))
 			continue;
 
@@ -1876,6 +1921,7 @@
 	bacpy(&addr.l2_bdaddr, ba);
 	addr.l2_family = AF_BLUETOOTH;
 	addr.l2_psm    = htobs(RFCOMM_PSM);
+	addr.l2_cid    = 0;
 	err = kernel_bind(sock, (struct sockaddr *) &addr, sizeof(addr));
 	if (err < 0) {
 		BT_ERR("Bind failed %d", err);
@@ -1947,42 +1993,7 @@
 	return 0;
 }
 
-static void rfcomm_auth_cfm(struct hci_conn *conn, u8 status)
-{
-	struct rfcomm_session *s;
-	struct rfcomm_dlc *d;
-	struct list_head *p, *n;
-
-	BT_DBG("conn %p status 0x%02x", conn, status);
-
-	s = rfcomm_session_get(&conn->hdev->bdaddr, &conn->dst);
-	if (!s)
-		return;
-
-	rfcomm_session_hold(s);
-
-	list_for_each_safe(p, n, &s->dlcs) {
-		d = list_entry(p, struct rfcomm_dlc, list);
-
-		if ((d->link_mode & (RFCOMM_LM_ENCRYPT | RFCOMM_LM_SECURE)) &&
-				!(conn->link_mode & HCI_LM_ENCRYPT) && !status)
-			continue;
-
-		if (!test_and_clear_bit(RFCOMM_AUTH_PENDING, &d->flags))
-			continue;
-
-		if (!status)
-			set_bit(RFCOMM_AUTH_ACCEPT, &d->flags);
-		else
-			set_bit(RFCOMM_AUTH_REJECT, &d->flags);
-	}
-
-	rfcomm_session_put(s);
-
-	rfcomm_schedule(RFCOMM_SCHED_AUTH);
-}
-
-static void rfcomm_encrypt_cfm(struct hci_conn *conn, u8 status, u8 encrypt)
+static void rfcomm_security_cfm(struct hci_conn *conn, u8 status, u8 encrypt)
 {
 	struct rfcomm_session *s;
 	struct rfcomm_dlc *d;
@@ -1999,18 +2010,29 @@
 	list_for_each_safe(p, n, &s->dlcs) {
 		d = list_entry(p, struct rfcomm_dlc, list);
 
-		if ((d->link_mode & (RFCOMM_LM_ENCRYPT | RFCOMM_LM_SECURE)) &&
-					(d->state == BT_CONNECTED ||
-						d->state == BT_CONFIG) &&
-						!status && encrypt == 0x00) {
-			__rfcomm_dlc_close(d, ECONNREFUSED);
-			continue;
+		if (test_and_clear_bit(RFCOMM_SEC_PENDING, &d->flags)) {
+			rfcomm_dlc_clear_timer(d);
+			if (status || encrypt == 0x00) {
+				__rfcomm_dlc_close(d, ECONNREFUSED);
+				continue;
+			}
+		}
+
+		if (d->state == BT_CONNECTED && !status && encrypt == 0x00) {
+			if (d->sec_level == BT_SECURITY_MEDIUM) {
+				set_bit(RFCOMM_SEC_PENDING, &d->flags);
+				rfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);
+				continue;
+			} else if (d->sec_level == BT_SECURITY_HIGH) {
+				__rfcomm_dlc_close(d, ECONNREFUSED);
+				continue;
+			}
 		}
 
 		if (!test_and_clear_bit(RFCOMM_AUTH_PENDING, &d->flags))
 			continue;
 
-		if (!status && encrypt)
+		if (!status)
 			set_bit(RFCOMM_AUTH_ACCEPT, &d->flags);
 		else
 			set_bit(RFCOMM_AUTH_REJECT, &d->flags);
@@ -2023,8 +2045,7 @@
 
 static struct hci_cb rfcomm_cb = {
 	.name		= "RFCOMM",
-	.auth_cfm	= rfcomm_auth_cfm,
-	.encrypt_cfm	= rfcomm_encrypt_cfm
+	.security_cfm	= rfcomm_security_cfm
 };
 
 static ssize_t rfcomm_dlc_sysfs_show(struct class *dev, char *buf)
diff -Nur linux-2.6.29/net/bluetooth/rfcomm/sock.c linux-2.6.29-spica/net/bluetooth/rfcomm/sock.c
--- linux-2.6.29/net/bluetooth/rfcomm/sock.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/bluetooth/rfcomm/sock.c	2010-03-30 11:01:42.000000000 +0700
@@ -261,12 +261,19 @@
 
 	if (parent) {
 		sk->sk_type = parent->sk_type;
-		pi->link_mode = rfcomm_pi(parent)->link_mode;
+		pi->dlc->defer_setup = bt_sk(parent)->defer_setup;
+
+		pi->sec_level = rfcomm_pi(parent)->sec_level;
+		pi->role_switch = rfcomm_pi(parent)->role_switch;
 	} else {
-		pi->link_mode = 0;
+		pi->dlc->defer_setup = 0;
+
+		pi->sec_level = BT_SECURITY_LOW;
+		pi->role_switch = 0;
 	}
 
-	pi->dlc->link_mode = pi->link_mode;
+	pi->dlc->sec_level = pi->sec_level;
+	pi->dlc->role_switch = pi->role_switch;
 }
 
 static struct proto rfcomm_proto = {
@@ -406,7 +413,8 @@
 	bacpy(&bt_sk(sk)->dst, &sa->rc_bdaddr);
 	rfcomm_pi(sk)->channel = sa->rc_channel;
 
-	d->link_mode = rfcomm_pi(sk)->link_mode;
+	d->sec_level = rfcomm_pi(sk)->sec_level;
+	d->role_switch = rfcomm_pi(sk)->role_switch;
 
 	err = rfcomm_dlc_open(d, &bt_sk(sk)->src, &sa->rc_bdaddr, sa->rc_channel);
 	if (!err)
@@ -554,6 +562,9 @@
 	struct sk_buff *skb;
 	int sent = 0;
 
+	if (test_bit(RFCOMM_DEFER_SETUP, &d->flags))
+		return -ENOTCONN;
+
 	if (msg->msg_flags & MSG_OOB)
 		return -EOPNOTSUPP;
 
@@ -570,8 +581,11 @@
 
 		skb = sock_alloc_send_skb(sk, size + RFCOMM_SKB_RESERVE,
 				msg->msg_flags & MSG_DONTWAIT, &err);
-		if (!skb)
+		if (!skb) {
+			if (sent == 0)
+				sent = err;
 			break;
+		}
 		skb_reserve(skb, RFCOMM_SKB_HEAD_RESERVE);
 
 		err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
@@ -630,10 +644,16 @@
 			       struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
+	struct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;
 	int err = 0;
 	size_t target, copied = 0;
 	long timeo;
 
+	if (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {
+		rfcomm_dlc_accept(d);
+		return 0;
+	}
+
 	if (flags & MSG_OOB)
 		return -EOPNOTSUPP;
 
@@ -710,7 +730,7 @@
 	return copied ? : err;
 }
 
-static int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, int optlen)
+static int rfcomm_sock_setsockopt_old(struct socket *sock, int optname, char __user *optval, int optlen)
 {
 	struct sock *sk = sock->sk;
 	int err = 0;
@@ -727,7 +747,14 @@
 			break;
 		}
 
-		rfcomm_pi(sk)->link_mode = opt;
+		if (opt & RFCOMM_LM_AUTH)
+			rfcomm_pi(sk)->sec_level = BT_SECURITY_LOW;
+		if (opt & RFCOMM_LM_ENCRYPT)
+			rfcomm_pi(sk)->sec_level = BT_SECURITY_MEDIUM;
+		if (opt & RFCOMM_LM_SECURE)
+			rfcomm_pi(sk)->sec_level = BT_SECURITY_HIGH;
+
+		rfcomm_pi(sk)->role_switch = (opt & RFCOMM_LM_MASTER);
 		break;
 
 	default:
@@ -739,12 +766,76 @@
 	return err;
 }
 
-static int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)
+static int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct bt_security sec;
+	int len, err = 0;
+	u32 opt;
+
+	BT_DBG("sk %p", sk);
+
+	if (level == SOL_RFCOMM)
+		return rfcomm_sock_setsockopt_old(sock, optname, optval, optlen);
+
+	if (level != SOL_BLUETOOTH)
+		return -ENOPROTOOPT;
+
+	lock_sock(sk);
+
+	switch (optname) {
+	case BT_SECURITY:
+		if (sk->sk_type != SOCK_STREAM) {
+			err = -EINVAL;
+			break;
+		}
+
+		sec.level = BT_SECURITY_LOW;
+
+		len = min_t(unsigned int, sizeof(sec), optlen);
+		if (copy_from_user((char *) &sec, optval, len)) {
+			err = -EFAULT;
+			break;
+		}
+
+		if (sec.level > BT_SECURITY_HIGH) {
+			err = -EINVAL;
+			break;
+		}
+
+		rfcomm_pi(sk)->sec_level = sec.level;
+		break;
+
+	case BT_DEFER_SETUP:
+		if (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {
+			err = -EINVAL;
+			break;
+		}
+
+		if (get_user(opt, (u32 __user *) optval)) {
+			err = -EFAULT;
+			break;
+		}
+
+		bt_sk(sk)->defer_setup = opt;
+		break;
+
+	default:
+		err = -ENOPROTOOPT;
+		break;
+	}
+
+	release_sock(sk);
+	return err;
+}
+
+static int rfcomm_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
 	struct sock *l2cap_sk;
 	struct rfcomm_conninfo cinfo;
 	int len, err = 0;
+	u32 opt;
 
 	BT_DBG("sk %p", sk);
 
@@ -755,12 +846,32 @@
 
 	switch (optname) {
 	case RFCOMM_LM:
-		if (put_user(rfcomm_pi(sk)->link_mode, (u32 __user *) optval))
+		switch (rfcomm_pi(sk)->sec_level) {
+		case BT_SECURITY_LOW:
+			opt = RFCOMM_LM_AUTH;
+			break;
+		case BT_SECURITY_MEDIUM:
+			opt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;
+			break;
+		case BT_SECURITY_HIGH:
+			opt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT |
+							RFCOMM_LM_SECURE;
+			break;
+		default:
+			opt = 0;
+			break;
+		}
+
+		if (rfcomm_pi(sk)->role_switch)
+			opt |= RFCOMM_LM_MASTER;
+
+		if (put_user(opt, (u32 __user *) optval))
 			err = -EFAULT;
 		break;
 
 	case RFCOMM_CONNINFO:
-		if (sk->sk_state != BT_CONNECTED) {
+		if (sk->sk_state != BT_CONNECTED &&
+					!rfcomm_pi(sk)->dlc->defer_setup) {
 			err = -ENOTCONN;
 			break;
 		}
@@ -785,6 +896,60 @@
 	return err;
 }
 
+static int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)
+{
+	struct sock *sk = sock->sk;
+	struct bt_security sec;
+	int len, err = 0;
+
+	BT_DBG("sk %p", sk);
+
+	if (level == SOL_RFCOMM)
+		return rfcomm_sock_getsockopt_old(sock, optname, optval, optlen);
+
+	if (level != SOL_BLUETOOTH)
+		return -ENOPROTOOPT;
+
+	if (get_user(len, optlen))
+		return -EFAULT;
+
+	lock_sock(sk);
+
+	switch (optname) {
+	case BT_SECURITY:
+		if (sk->sk_type != SOCK_STREAM) {
+			err = -EINVAL;
+			break;
+		}
+
+		sec.level = rfcomm_pi(sk)->sec_level;
+
+		len = min_t(unsigned int, len, sizeof(sec));
+		if (copy_to_user(optval, (char *) &sec, len))
+			err = -EFAULT;
+
+		break;
+
+	case BT_DEFER_SETUP:
+		if (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {
+			err = -EINVAL;
+			break;
+		}
+
+		if (put_user(bt_sk(sk)->defer_setup, (u32 __user *) optval))
+			err = -EFAULT;
+
+		break;
+
+	default:
+		err = -ENOPROTOOPT;
+		break;
+	}
+
+	release_sock(sk);
+	return err;
+}
+
 static int rfcomm_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
 {
 	struct sock *sk __maybe_unused = sock->sk;
@@ -888,6 +1053,10 @@
 
 done:
 	bh_unlock_sock(parent);
+
+	if (bt_sk(parent)->defer_setup)
+		parent->sk_state_change(parent);
+
 	return result;
 }
 
diff -Nur linux-2.6.29/net/bluetooth/sco.c linux-2.6.29-spica/net/bluetooth/sco.c
--- linux-2.6.29/net/bluetooth/sco.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/bluetooth/sco.c	2010-03-30 11:01:42.000000000 +0700
@@ -195,7 +195,7 @@
 	else
 		type = SCO_LINK;
 
-	hcon = hci_connect(hdev, type, dst, HCI_AT_NO_BONDING);
+	hcon = hci_connect(hdev, type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);
 	if (!hcon)
 		goto done;
 
@@ -668,7 +668,7 @@
 	return err;
 }
 
-static int sco_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)
+static int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
 	struct sco_options opts;
@@ -723,6 +723,31 @@
 	return err;
 }
 
+static int sco_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)
+{
+	struct sock *sk = sock->sk;
+	int len, err = 0;
+
+	BT_DBG("sk %p", sk);
+
+	if (level == SOL_SCO)
+		return sco_sock_getsockopt_old(sock, optname, optval, optlen);
+
+	if (get_user(len, optlen))
+		return -EFAULT;
+
+	lock_sock(sk);
+
+	switch (optname) {
+	default:
+		err = -ENOPROTOOPT;
+		break;
+	}
+
+	release_sock(sk);
+	return err;
+}
+
 static int sco_sock_release(struct socket *sock)
 {
 	struct sock *sk = sock->sk;
@@ -832,10 +857,30 @@
 /* ----- SCO interface with lower layer (HCI) ----- */
 static int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
 {
+	register struct sock *sk;
+	struct hlist_node *node;
+	int lm = 0;
+
+	if (type != SCO_LINK && type != ESCO_LINK)
+		return 0;
+
 	BT_DBG("hdev %s, bdaddr %s", hdev->name, batostr(bdaddr));
 
-	/* Always accept connection */
-	return HCI_LM_ACCEPT;
+	/* Find listening sockets */
+	read_lock(&sco_sk_list.lock);
+	sk_for_each(sk, node, &sco_sk_list.head) {
+		if (sk->sk_state != BT_LISTEN)
+			continue;
+
+		if (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr) ||
+				!bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {
+			lm |= HCI_LM_ACCEPT;
+			break;
+		}
+	}
+	read_unlock(&sco_sk_list.lock);
+
+	return lm;
 }
 
 static int sco_connect_cfm(struct hci_conn *hcon, __u8 status)
@@ -857,7 +902,7 @@
 	return 0;
 }
 
-static int sco_disconn_ind(struct hci_conn *hcon, __u8 reason)
+static int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason)
 {
 	BT_DBG("hcon %p reason %d", hcon, reason);
 
@@ -940,7 +985,7 @@
 	.id		= HCI_PROTO_SCO,
 	.connect_ind	= sco_connect_ind,
 	.connect_cfm	= sco_connect_cfm,
-	.disconn_ind	= sco_disconn_ind,
+	.disconn_cfm	= sco_disconn_cfm,
 	.recv_scodata	= sco_recv_scodata
 };
 
diff -Nur linux-2.6.29/net/core/dev.c linux-2.6.29-spica/net/core/dev.c
--- linux-2.6.29/net/core/dev.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/core/dev.c	2010-03-30 11:01:40.000000000 +0700
@@ -2588,18 +2588,15 @@
 		local_irq_disable();
 		skb = __skb_dequeue(&queue->input_pkt_queue);
 		if (!skb) {
+			__napi_complete(napi);
 			local_irq_enable();
-			napi_complete(napi);
-			goto out;
+			break;
 		}
 		local_irq_enable();
 
-		napi_gro_receive(napi, skb);
+		netif_receive_skb(skb);
 	} while (++work < quota && jiffies == start_time);
 
-	napi_gro_flush(napi);
-
-out:
 	return work;
 }
 
diff -Nur linux-2.6.29/net/ipv4/af_inet.c linux-2.6.29-spica/net/ipv4/af_inet.c
--- linux-2.6.29/net/ipv4/af_inet.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/ipv4/af_inet.c	2010-03-30 11:01:41.000000000 +0700
@@ -116,6 +116,20 @@
 #include <linux/mroute.h>
 #endif
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+
+static inline int current_has_network(void)
+{
+	return in_egroup_p(AID_INET) || capable(CAP_NET_RAW);
+}
+#else
+static inline int current_has_network(void)
+{
+	return 1;
+}
+#endif
+
 extern void ip_mc_drop_socket(struct sock *sk);
 
 /* The inetsw table contains everything that inet_create needs to
@@ -258,6 +272,7 @@
 	return ipprot->netns_ok;
 }
 
+
 /*
  *	Create an inet socket.
  */
@@ -273,6 +288,9 @@
 	int try_loading_module = 0;
 	int err;
 
+	if (!current_has_network())
+		return -EACCES;
+
 	if (unlikely(!inet_ehash_secret))
 		if (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)
 			build_ehash_secret();
@@ -826,6 +844,7 @@
 		case SIOCSIFPFLAGS:
 		case SIOCGIFPFLAGS:
 		case SIOCSIFFLAGS:
+		case SIOCKILLADDR:
 			err = devinet_ioctl(net, cmd, (void __user *)arg);
 			break;
 		default:
diff -Nur linux-2.6.29/net/ipv4/devinet.c linux-2.6.29-spica/net/ipv4/devinet.c
--- linux-2.6.29/net/ipv4/devinet.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/ipv4/devinet.c	2010-03-30 11:01:41.000000000 +0700
@@ -57,6 +57,7 @@
 
 #include <net/arp.h>
 #include <net/ip.h>
+#include <net/tcp.h>
 #include <net/route.h>
 #include <net/ip_fib.h>
 #include <net/rtnetlink.h>
@@ -631,6 +632,7 @@
 	case SIOCSIFBRDADDR:	/* Set the broadcast address */
 	case SIOCSIFDSTADDR:	/* Set the destination address */
 	case SIOCSIFNETMASK: 	/* Set the netmask for the interface */
+	case SIOCKILLADDR:	/* Nuke all sockets on this address */
 		ret = -EACCES;
 		if (!capable(CAP_NET_ADMIN))
 			goto out;
@@ -680,7 +682,8 @@
 	}
 
 	ret = -EADDRNOTAVAIL;
-	if (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS)
+	if (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS
+	    && cmd != SIOCKILLADDR)
 		goto done;
 
 	switch (cmd) {
@@ -804,6 +807,10 @@
 			inet_insert_ifa(ifa);
 		}
 		break;
+	case SIOCKILLADDR:	/* Nuke all connections on this address */
+		ret = 0;
+		tcp_v4_nuke_addr(sin->sin_addr.s_addr);
+		break;
 	}
 done:
 	rtnl_unlock();
diff -Nur linux-2.6.29/net/ipv4/Makefile linux-2.6.29-spica/net/ipv4/Makefile
--- linux-2.6.29/net/ipv4/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/ipv4/Makefile	2010-03-30 11:01:41.000000000 +0700
@@ -14,6 +14,7 @@
 	     inet_fragment.o
 
 obj-$(CONFIG_SYSCTL) += sysctl_net_ipv4.o
+obj-$(CONFIG_SYSFS) += sysfs_net_ipv4.o
 obj-$(CONFIG_IP_FIB_HASH) += fib_hash.o
 obj-$(CONFIG_IP_FIB_TRIE) += fib_trie.o
 obj-$(CONFIG_PROC_FS) += proc.o
diff -Nur linux-2.6.29/net/ipv4/sysfs_net_ipv4.c linux-2.6.29-spica/net/ipv4/sysfs_net_ipv4.c
--- linux-2.6.29/net/ipv4/sysfs_net_ipv4.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/net/ipv4/sysfs_net_ipv4.c	2010-03-30 11:01:41.000000000 +0700
@@ -0,0 +1,88 @@
+/*
+ * net/ipv4/sysfs_net_ipv4.c
+ *
+ * sysfs-based networking knobs (so we can, unlike with sysctl, control perms)
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * Robert Love <rlove@google.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/init.h>
+#include <net/tcp.h>
+
+#define CREATE_IPV4_FILE(_name, _var) \
+static ssize_t _name##_show(struct kobject *kobj, \
+			    struct kobj_attribute *attr, char *buf) \
+{ \
+	return sprintf(buf, "%d\n", _var); \
+} \
+static ssize_t _name##_store(struct kobject *kobj, \
+			     struct kobj_attribute *attr, \
+			     const char *buf, size_t count) \
+{ \
+	int val, ret; \
+	ret = sscanf(buf, "%d", &val); \
+	if (ret != 1) \
+		return -EINVAL; \
+	if (val < 0) \
+		return -EINVAL; \
+	_var = val; \
+	return count; \
+} \
+static struct kobj_attribute _name##_attr = \
+	__ATTR(_name, 0644, _name##_show, _name##_store)
+
+CREATE_IPV4_FILE(tcp_wmem_min, sysctl_tcp_wmem[0]);
+CREATE_IPV4_FILE(tcp_wmem_def, sysctl_tcp_wmem[1]);
+CREATE_IPV4_FILE(tcp_wmem_max, sysctl_tcp_wmem[2]);
+
+CREATE_IPV4_FILE(tcp_rmem_min, sysctl_tcp_rmem[0]);
+CREATE_IPV4_FILE(tcp_rmem_def, sysctl_tcp_rmem[1]);
+CREATE_IPV4_FILE(tcp_rmem_max, sysctl_tcp_rmem[2]);
+
+static struct attribute *ipv4_attrs[] = {
+	&tcp_wmem_min_attr.attr,
+	&tcp_wmem_def_attr.attr,
+	&tcp_wmem_max_attr.attr,
+	&tcp_rmem_min_attr.attr,
+	&tcp_rmem_def_attr.attr,
+	&tcp_rmem_max_attr.attr,
+	NULL
+};
+
+static struct attribute_group ipv4_attr_group = {
+	.attrs = ipv4_attrs,
+};
+
+static __init int sysfs_ipv4_init(void)
+{
+	struct kobject *ipv4_kobject;
+	int ret;
+
+	ipv4_kobject = kobject_create_and_add("ipv4", kernel_kobj);
+	if (!ipv4_kobject)
+		return -ENOMEM;
+
+	ret = sysfs_create_group(ipv4_kobject, &ipv4_attr_group);
+	if (ret) {
+		kobject_put(ipv4_kobject);
+		return ret;
+	}
+
+	return 0;
+}
+
+subsys_initcall(sysfs_ipv4_init);
diff -Nur linux-2.6.29/net/ipv4/tcp_ipv4.c linux-2.6.29-spica/net/ipv4/tcp_ipv4.c
--- linux-2.6.29/net/ipv4/tcp_ipv4.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/ipv4/tcp_ipv4.c	2010-05-06 12:42:45.684270633 +0700
@@ -1853,6 +1853,49 @@
 
 EXPORT_SYMBOL(tcp_v4_destroy_sock);
 
+/*
+ * tcp_v4_nuke_addr - destroy all sockets on the given local address
+ */
+void tcp_v4_nuke_addr(__u32 saddr)
+{
+	unsigned int bucket;
+
+	for (bucket = 0; bucket < tcp_hashinfo.ehash_size; bucket++) {
+		struct hlist_nulls_node *node;
+		struct sock *sk;
+		spinlock_t *lock = inet_ehash_lockp(&tcp_hashinfo, bucket);
+
+restart:
+		spin_lock_bh(lock);
+		sk_nulls_for_each(sk, node, &tcp_hashinfo.ehash[bucket].chain) {
+			struct inet_sock *inet = inet_sk(sk);
+
+			if (inet->rcv_saddr != saddr)
+				continue;
+			if (sysctl_ip_dynaddr && sk->sk_state == TCP_SYN_SENT)
+				continue;
+			if (sock_flag(sk, SOCK_DEAD))
+				continue;
+
+			sock_hold(sk);
+			spin_unlock_bh(lock);
+
+			local_bh_disable();
+			bh_lock_sock(sk);
+			sk->sk_err = ETIMEDOUT;
+			sk->sk_error_report(sk);
+
+			tcp_done(sk);
+			bh_unlock_sock(sk);
+			local_bh_enable();
+			sock_put(sk);
+
+			goto restart;
+		}
+		spin_unlock_bh(lock);
+	}
+}
+
 #ifdef CONFIG_PROC_FS
 /* Proc filesystem TCP sock list dumping. */
 
@@ -2462,4 +2505,3 @@
 EXPORT_SYMBOL(tcp_proc_unregister);
 #endif
 EXPORT_SYMBOL(sysctl_tcp_low_latency);
-
diff -Nur linux-2.6.29/net/ipv6/af_inet6.c linux-2.6.29-spica/net/ipv6/af_inet6.c
--- linux-2.6.29/net/ipv6/af_inet6.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/ipv6/af_inet6.c	2010-03-30 11:01:41.000000000 +0700
@@ -62,6 +62,20 @@
 #include <asm/system.h>
 #include <linux/mroute6.h>
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+
+static inline int current_has_network(void)
+{
+	return in_egroup_p(AID_INET) || capable(CAP_NET_RAW);
+}
+#else
+static inline int current_has_network(void)
+{
+	return 1;
+}
+#endif
+
 MODULE_AUTHOR("Cast of dozens");
 MODULE_DESCRIPTION("IPv6 protocol stack for Linux");
 MODULE_LICENSE("GPL");
@@ -95,6 +109,9 @@
 	int try_loading_module = 0;
 	int err;
 
+	if (!current_has_network())
+		return -EACCES;
+
 	if (sock->type != SOCK_RAW &&
 	    sock->type != SOCK_DGRAM &&
 	    !inet_ehash_secret)
diff -Nur linux-2.6.29/net/Kconfig linux-2.6.29-spica/net/Kconfig
--- linux-2.6.29/net/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/Kconfig	2010-03-30 11:01:42.000000000 +0700
@@ -61,6 +61,12 @@
 
 endif # if INET
 
+config ANDROID_PARANOID_NETWORK
+	bool "Only allow certain groups to create sockets"
+	default y
+	help
+		none
+
 config NETWORK_SECMARK
 	bool "Security Marking"
 	help
diff -Nur linux-2.6.29/net/rfkill/Kconfig linux-2.6.29-spica/net/rfkill/Kconfig
--- linux-2.6.29/net/rfkill/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/rfkill/Kconfig	2010-03-30 11:01:41.000000000 +0700
@@ -10,6 +10,11 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called rfkill.
 
+config RFKILL_PM
+	bool "Power off on suspend"
+	depends on RFKILL && PM
+	default y
+
 config RFKILL_INPUT
 	tristate "Input layer to RF switch connector"
 	depends on RFKILL && INPUT
diff -Nur linux-2.6.29/net/rfkill/rfkill.c linux-2.6.29-spica/net/rfkill/rfkill.c
--- linux-2.6.29/net/rfkill/rfkill.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/rfkill/rfkill.c	2010-03-30 11:01:41.000000000 +0700
@@ -512,7 +512,7 @@
 	module_put(THIS_MODULE);
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_RFKILL_PM
 static int rfkill_suspend(struct device *dev, pm_message_t state)
 {
 	struct rfkill *rfkill = to_rfkill(dev);
diff -Nur linux-2.6.29/net/socket.c linux-2.6.29-spica/net/socket.c
--- linux-2.6.29/net/socket.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/net/socket.c	2010-03-30 11:01:42.000000000 +0700
@@ -96,6 +96,10 @@
 #include <net/sock.h>
 #include <linux/netfilter.h>
 
+#ifdef CONFIG_UID_STAT
+#include <linux/uid_stat.h>
+#endif
+
 static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
 static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
 			 unsigned long nr_segs, loff_t pos);
@@ -560,7 +564,12 @@
 	if (err)
 		return err;
 
-	return sock->ops->sendmsg(iocb, sock, msg, size);
+	err = sock->ops->sendmsg(iocb, sock, msg, size);
+#ifdef CONFIG_UID_STAT
+	if (err > 0)
+		update_tcp_snd(current_uid(), err);
+#endif
+	return err;
 }
 
 int sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
@@ -642,7 +651,12 @@
 	if (err)
 		return err;
 
-	return sock->ops->recvmsg(iocb, sock, msg, size, flags);
+	err = sock->ops->recvmsg(iocb, sock, msg, size, flags);
+#ifdef CONFIG_UID_STAT
+	if (err > 0)
+		update_tcp_rcv(current_uid(), err);
+#endif
+	return err;
 }
 
 int sock_recvmsg(struct socket *sock, struct msghdr *msg,
@@ -694,7 +708,7 @@
 	if (more)
 		flags |= MSG_MORE;
 
-	return sock->ops->sendpage(sock, page, offset, size, flags);
+	return kernel_sendpage(sock, page, offset, size, flags);
 }
 
 static ssize_t sock_splice_read(struct file *file, loff_t *ppos,
diff -Nur linux-2.6.29/security/commoncap.c linux-2.6.29-spica/security/commoncap.c
--- linux-2.6.29/security/commoncap.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/security/commoncap.c	2010-03-30 11:01:43.000000000 +0700
@@ -28,6 +28,10 @@
 #include <linux/prctl.h>
 #include <linux/securebits.h>
 
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+#include <linux/android_aid.h>
+#endif
+
 int cap_netlink_send(struct sock *sk, struct sk_buff *skb)
 {
 	NETLINK_CB(skb).eff_cap = current_cap();
@@ -60,6 +64,12 @@
 int cap_capable(struct task_struct *tsk, const struct cred *cred, int cap,
 		int audit)
 {
+#ifdef CONFIG_ANDROID_PARANOID_NETWORK
+	if (cap == CAP_NET_RAW && in_egroup_p(AID_NET_RAW))
+		return 0;
+	if (cap == CAP_NET_ADMIN && in_egroup_p(AID_NET_ADMIN))
+		return 0;
+#endif
 	return cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;
 }
 
diff -Nur linux-2.6.29/security/Kconfig linux-2.6.29-spica/security/Kconfig
--- linux-2.6.29/security/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/security/Kconfig	2010-03-30 11:01:43.000000000 +0700
@@ -109,28 +109,8 @@
 
 	  See <http://www.linuxjournal.com/article.php?sid=6279> for
 	  more information about this module.
-	  
-	  If you are unsure how to answer this question, answer N.
-
-config SECURITY_DEFAULT_MMAP_MIN_ADDR
-        int "Low address space to protect from user allocation"
-        depends on SECURITY
-        default 0
-        help
-	  This is the portion of low virtual memory which should be protected
-	  from userspace allocation.  Keeping a user from writing to low pages
-	  can help reduce the impact of kernel NULL pointer bugs.
-
-	  For most ia64, ppc64 and x86 users with lots of address space
-	  a value of 65536 is reasonable and should cause no problems.
-	  On arm and other archs it should not be higher than 32768.
-	  Programs which use vm86 functionality would either need additional
-	  permissions from either the LSM or the capabilities module or have
-	  this protection disabled.
-
-	  This value can be changed after boot using the
-	  /proc/sys/vm/mmap_min_addr tunable.
 
+	  If you are unsure how to answer this question, answer N.
 
 source security/selinux/Kconfig
 source security/smack/Kconfig
diff -Nur linux-2.6.29/security/security.c linux-2.6.29-spica/security/security.c
--- linux-2.6.29/security/security.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/security/security.c	2010-03-30 11:01:43.000000000 +0700
@@ -26,9 +26,6 @@
 
 struct security_operations *security_ops;	/* Initialized to NULL */
 
-/* amount of vm to protect from userspace access */
-unsigned long mmap_min_addr = CONFIG_SECURITY_DEFAULT_MMAP_MIN_ADDR;
-
 static inline int verify(struct security_operations *ops)
 {
 	/* verify the security_operations structure exists */
diff -Nur linux-2.6.29/sound/core/pcm_lib.c linux-2.6.29-spica/sound/core/pcm_lib.c
--- linux-2.6.29/sound/core/pcm_lib.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/sound/core/pcm_lib.c	2010-05-06 12:42:45.684270633 +0700
@@ -29,6 +29,52 @@
 #include <sound/pcm_params.h>
 #include <sound/timer.h>
 
+#undef CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING
+#ifdef CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING
+#include "smallfilter.h"
+
+#define MAX_HWORD (32767)
+#define MIN_HWORD (-32768)
+
+/* Conversion constants */
+#define Nhc       8
+#define Na        7
+#define Np       (Nhc+Na)
+#define Npc      (1<<Nhc)
+#define Amask    ((1<<Na)-1)
+#define Pmask    ((1<<Np)-1)
+#define Nh       16
+#define Nb       16
+#define Nhxn     14
+#define Nhg      (Nh-Nhxn)
+#define NLpScl   13
+
+#ifndef MAX
+#define MAX(x,y) ((x)>(y) ?(x):(y))
+#endif
+#ifndef MIN
+#define MIN(x,y) ((x)<(y) ?(x):(y))
+#endif
+
+#define MUS_SAMPLE_BITS 24
+#define MUS_SAMPLE_TYPE_TO_HWORD(x) ((short)((x)>>(MUS_SAMPLE_BITS-16)))
+#define HWORD_TO_MUS_SAMPLE_TYPE(x) ((mus_sample_t)((x)<<(MUS_SAMPLE_BITS-16)))
+
+#define OLDSAMPLE 44100
+#define NEWSAMPLE 8000
+
+static char *buf_user;
+static char *buf_user_org;
+static unsigned short Xoff = 48;
+static unsigned short Xp = 48;
+static unsigned short Xread = 48;   /* Position in input array to read into */
+static unsigned int Time = (48<<Np);          /* Current-time pointer for converter */
+static char isFirst = 1;
+#endif
+
+unsigned int ring_buf_index = 0;
+unsigned int period_index = 0;
+
 /*
  * fill ring buffer with silence
  * runtime->silence_start: starting pointer to silence area
@@ -127,6 +173,7 @@
 
 static void xrun(struct snd_pcm_substream *substream)
 {
+	printk("%s: [%d]occured XRUN!\n", __func__, substream->stream);
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
 	if (substream->pstr->xrun_debug) {
@@ -151,7 +198,7 @@
 	if (pos == SNDRV_PCM_POS_XRUN)
 		return pos; /* XRUN */
 #ifdef CONFIG_SND_DEBUG
-	if (pos >= runtime->buffer_size) {
+	if (pos >= (runtime->buffer_size * ANDROID_BUF_NUM)) {
 		snd_printk(KERN_ERR  "BUG: stream = %i, pos = 0x%lx, buffer size = 0x%lx, period size = 0x%lx\n", substream->stream, pos, runtime->buffer_size, runtime->period_size);
 	}
 #endif
@@ -163,6 +210,7 @@
 					     struct snd_pcm_runtime *runtime)
 {
 	snd_pcm_uframes_t avail;
+	unsigned int stop_threshold = 0;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		avail = snd_pcm_playback_avail(runtime);
@@ -170,7 +218,13 @@
 		avail = snd_pcm_capture_avail(runtime);
 	if (avail > runtime->avail_max)
 		runtime->avail_max = avail;
-	if (avail >= runtime->stop_threshold) {
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		stop_threshold = runtime->stop_threshold * ANDROID_BUF_NUM;
+	else
+		stop_threshold = runtime->stop_threshold;
+
+	if (avail >= stop_threshold) {
 		if (substream->runtime->status->state == SNDRV_PCM_STATE_DRAINING)
 			snd_pcm_drain_done(substream);
 		else
@@ -212,7 +266,11 @@
 			return 0;
 		}
 	      __next_buf:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			runtime->hw_ptr_base += runtime->buffer_size * ANDROID_BUF_NUM;
+		else
 		runtime->hw_ptr_base += runtime->buffer_size;
+
 		if (runtime->hw_ptr_base == runtime->boundary)
 			runtime->hw_ptr_base = 0;
 		new_hw_ptr = runtime->hw_ptr_base + pos;
@@ -243,7 +301,6 @@
 		return -EPIPE;
 	}
 	new_hw_ptr = runtime->hw_ptr_base + pos;
-
 	delta = old_hw_ptr - new_hw_ptr;
 	if (delta > 0) {
 		if ((snd_pcm_uframes_t)delta < runtime->buffer_size / 2) {
@@ -256,7 +313,11 @@
 #endif
 			return 0;
 		}
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			runtime->hw_ptr_base += runtime->buffer_size * ANDROID_BUF_NUM;
+		else
 		runtime->hw_ptr_base += runtime->buffer_size;
+
 		if (runtime->hw_ptr_base == runtime->boundary)
 			runtime->hw_ptr_base = 0;
 		new_hw_ptr = runtime->hw_ptr_base + pos;
@@ -1574,7 +1635,22 @@
 		if ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)
 			return err;
 	} else {
-		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
+		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff) 
+					  + (ring_buf_index * frames_to_bytes(runtime, runtime->buffer_size));
+	
+        if(frames == runtime->buffer_size) 
+			ring_buf_index = (ring_buf_index + 1) % ANDROID_BUF_NUM;
+
+		else if(frames != runtime->buffer_size) {
+			period_index += frames;
+			if(period_index >= runtime->buffer_size) {			
+				ring_buf_index = (ring_buf_index + 1) % ANDROID_BUF_NUM;
+				period_index -= runtime->buffer_size;
+			} 
+		}
+
+		if (snd_BUG_ON(runtime->dma_area)) return -EFAULT;
+//		printk("########### frames = %d #########\n", frames);
 		if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames)))
 			return -EFAULT;
 	}
@@ -1632,6 +1708,10 @@
 			if (err < 0)
 				goto _end_unlock;
 		}
+
+		if(avail > runtime->buffer_size)
+			avail = runtime->buffer_size;
+			
 		frames = size > avail ? avail : size;
 		cont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;
 		if (frames > cont)
@@ -1697,6 +1777,7 @@
 {
 	struct snd_pcm_runtime *runtime;
 	int nonblock;
+	snd_pcm_sframes_t ret;
 	int err;
 
 	err = pcm_sanity_check(substream);
@@ -1776,6 +1857,116 @@
 
 EXPORT_SYMBOL(snd_pcm_lib_writev);
 
+#ifdef CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING // sangsu fix : down sample
+
+static inline short WordToHword(int v, int scl)
+{
+    short out;
+    int llsb = (1<<(scl-1));
+    v += llsb;          /* round */
+    v >>= scl;
+    if (v>MAX_HWORD) {
+        v = MAX_HWORD;
+    } else if (v < MIN_HWORD) {
+        v = MIN_HWORD;
+    }
+    out = (short) v;
+    return out;
+}
+
+int FilterUD( short Imp[], short ImpD[],
+		     unsigned short Nwing, char Interp,
+		     short *Xp, short Ph, short Inc, unsigned short dhb)
+{
+    short a;
+    short *Hp, *Hdp, *End;
+    int v, t;
+    unsigned int Ho;
+    
+    v=0;
+    Ho = (Ph*(unsigned int)dhb)>>Np;
+    End = &Imp[Nwing];
+    if (Inc == 1)		/* If doing right wing...              */
+    {				/* ...drop extra coeff, so when Ph is  */
+	End--;			/*    0.5, we don't do too many mult's */
+	if (Ph == 0)		/* If the phase is zero...           */
+	  Ho += dhb;		/* ...then we've already skipped the */
+    }				/*    first sample, so we must also  */
+				/*    skip ahead in Imp[] and ImpD[] */
+    if (Interp)
+      while ((Hp = &Imp[Ho>>Na]) < End) {
+	  t = *Hp;		/* Get IR sample */
+	  Hdp = &ImpD[Ho>>Na];  /* get interp (lower Na) bits from diff table*/
+	  a = Ho & Amask;	/* a is logically between 0 and 1 */
+	  t += (((int)*Hdp)*a)>>Na; /* t is now interp'd filter coeff */
+	  t *= *Xp;		/* Mult coeff by input sample */
+	  if (t & 1<<(Nhxn-1))	/* Round, if needed */
+	    t += 1<<(Nhxn-1);
+	  t >>= Nhxn;		/* Leave some guard bits, but come back some */
+	  v += t;			/* The filter output */
+	  Ho += dhb;		/* IR step */
+	  Xp += Inc;		/* Input signal step. NO CHECK ON BOUNDS */
+      }
+    else 
+      while ((Hp = &Imp[Ho>>Na]) < End) {
+	  t = *Hp;		/* Get IR sample */
+	  t *= *Xp;		/* Mult coeff by input sample */
+	  if (t & 1<<(Nhxn-1))	/* Round, if needed */
+	    t += 1<<(Nhxn-1);
+	  t >>= Nhxn;		/* Leave some guard bits, but come back some */
+	  v += t;			/* The filter output */
+	  Ho += dhb;		/* IR step */
+	  Xp += Inc;		/* Input signal step. NO CHECK ON BOUNDS */
+      }
+    return(v);
+}
+
+/* Sampling rate conversion subroutine */
+
+static int SrcUD(short X[], short Y[], int newSample, unsigned int *Time,
+                 unsigned short Nx, unsigned short Nwing, unsigned short LpScl,
+                 short Imp[], short ImpD[], char Interp)
+{
+    short *Xp, *Ystart;
+    int v;
+    
+    double dh;                  /* Step through filter impulse response */
+    double dt;                  /* Step through input signal */
+    unsigned int endTime;              /* When Time reaches EndTime, return to user */
+    unsigned int dhb, dtb;             /* Fixed-point versions of Dh,Dt */
+    double factor = (double)newSample/(double)44100;
+
+    /* Account for increased filter gain when using factors less than 1 */
+    if (factor < 1)
+      LpScl = LpScl*factor + 0.5;
+
+    dt = 1.0/factor;            /* Output sampling period */
+    dtb = dt*(1<<Np) + 0.5;     /* Fixed-point representation */
+    
+    dh = MIN(Npc, factor*Npc);  /* Filter sampling period */
+    dhb = dh*(1<<Na) + 0.5;     /* Fixed-point representation */
+    
+    Ystart = Y;
+    endTime = *Time + (1<<Np)*(int)Nx;
+    while (*Time < endTime)
+    {
+        Xp = &X[*Time>>Np];     /* Ptr to current input sample */
+        v = FilterUD(Imp, ImpD, Nwing, Interp, Xp, (short)(*Time&Pmask),
+                     -1, dhb);  /* Perform left-wing inner product */
+        v += FilterUD(Imp, ImpD, Nwing, Interp, Xp+1, 
+		      /* previous (triggers warning): (short)((-*Time)&Pmask), */
+                      (short)((((*Time)^Pmask)+1)&Pmask),
+                      1, dhb);  /* Perform right-wing inner product */
+        v >>= Nhg;              /* Make guard bits */
+        v *= LpScl;             /* Normalize for unity filter gain */
+        *Y++ = WordToHword(v,NLpScl);   /* strip guard bits, deposit output */
+        *Time += dtb;           /* Move to next sample by time increment */
+    }
+    return (Y - Ystart);        /* Return the number of output samples */
+}
+#endif // sangsu fix : down sample
+
+
 static int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream, 
 				     unsigned int hwoff,
 				     unsigned long data, unsigned int off,
@@ -1789,8 +1980,20 @@
 			return err;
 	} else {
 		char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
+#ifdef CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING
+    if(runtime->rate == 8000)
+    {
+  		memcpy(buf_user + frames_to_bytes(runtime, off) , hwbuf, frames_to_bytes(runtime, frames));
+    }
+    else
+    {
+  		if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames)))
+  			return -EFAULT;
+    }
+#else
 		if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames)))
 			return -EFAULT;
+#endif
 	}
 	return 0;
 }
@@ -1805,10 +2008,31 @@
 	snd_pcm_uframes_t xfer = 0;
 	snd_pcm_uframes_t offset = 0;
 	int err = 0;
+#ifdef CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING
+    unsigned int i;
+    unsigned short oldSize1, oldSize2;
+    unsigned short Ncreep;
+    unsigned short Nout;
+    int Ycount, last;
+    unsigned short Nx = 11288;
+    double factor = (double)(runtime->rate)/(double)44100;
+#endif	
 
 	if (size == 0)
 		return 0;
 
+#ifdef CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING
+//	printk("snd_pcm_lib_read1: sample_rate(%d) \n", runtime->rate);
+  if(runtime->rate == 8000)
+  {
+  	size = (((size*OLDSAMPLE/NEWSAMPLE<<1)+1)>>1)+94;
+        oldSize1 = size;
+  	buf_user = (char *)kmalloc(frames_to_bytes(runtime, oldSize1), GFP_KERNEL);
+        buf_user_org = buf_user;
+//	printk("# %d \n", size);
+  }
+#endif
+
 	snd_pcm_stream_lock_irq(substream);
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_PREPARED:
@@ -1891,9 +2115,48 @@
 		size -= frames;
 		xfer += frames;
 	}
+#ifdef CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING
+  if(runtime->rate == 8000)
+  {
+        /* Calc reach of LP filter wing & give some creeping room */
+        oldSize2 = xfer;
+
+  	xfer = SrcUD((short*)buf_user_org, (short*)buf_user_org, 8000, &Time, Nx, 
+			    SMALL_FILTER_NWING, SMALL_FILTER_SCALE, SMALL_FILTER_IMP, 
+			    SMALL_FILTER_IMPD, 1);
+//	printk("## %d %u %u\n", xfer, Time, Nx, Xoff);
+  	if ((err = copy_to_user((char __user *)data, buf_user_org, frames_to_bytes(runtime, xfer))) < 0) {
+  		xfer = 0;
+  		goto _end;
+  	}
+
+        Time -= (Nx<<Np);       /* Move converter Nx samples back in time */
+
+        Xp += Nx;               /* Advance by number of samples processed */
+        Ncreep = (Time>>Np) - Xoff; /* Calc time accumulation in Time */
+        if (Ncreep) {
+            Time -= (Ncreep<<Np);    /* Remove time accumulation */
+            Xp += Ncreep;            /* and add it to read pointer */
+        }
+
+        for (i=0; i<oldSize2-Xp+Xoff; i++) { /* Copy part of input signal */
+            buf_user_org[i] = buf_user_org[i+Xp-Xoff]; /* that must be re-used */
+        }
+
+        Xread = i;              /* Pos in input buff to read new data into */
+        Xp = Xoff;
+  }
+#endif
+
  _end_unlock:
 	snd_pcm_stream_unlock_irq(substream);
  _end:
+#ifdef CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING
+  if(runtime->rate == 8000)
+  {
+   	kfree(buf_user);
+  }
+#endif
 	return xfer > 0 ? (snd_pcm_sframes_t)xfer : err;
 }
 
diff -Nur linux-2.6.29/sound/core/smallfilter.h linux-2.6.29-spica/sound/core/smallfilter.h
--- linux-2.6.29/sound/core/smallfilter.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/core/smallfilter.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,4617 @@
+/* Included by resamplesubs.c */
+#define SMALL_FILTER_NMULT ((short)13)
+#define SMALL_FILTER_SCALE 13128 /* Unity-gain scale factor */
+#define SMALL_FILTER_NWING 1536 /* Filter table length */
+static short SMALL_FILTER_IMP[] /* Impulse response */ = {
+32767,
+32766,
+32764,
+32760,
+32755,
+32749,
+32741,
+32731,
+32721,
+32708,
+32695,
+32679,
+32663,
+32645,
+32625,
+32604,
+32582,
+32558,
+32533,
+32506,
+32478,
+32448,
+32417,
+32385,
+32351,
+32316,
+32279,
+32241,
+32202,
+32161,
+32119,
+32075,
+32030,
+31984,
+31936,
+31887,
+31836,
+31784,
+31731,
+31676,
+31620,
+31563,
+31504,
+31444,
+31383,
+31320,
+31256,
+31191,
+31124,
+31056,
+30987,
+30916,
+30845,
+30771,
+30697,
+30621,
+30544,
+30466,
+30387,
+30306,
+30224,
+30141,
+30057,
+29971,
+29884,
+29796,
+29707,
+29617,
+29525,
+29433,
+29339,
+29244,
+29148,
+29050,
+28952,
+28852,
+28752,
+28650,
+28547,
+28443,
+28338,
+28232,
+28125,
+28017,
+27908,
+27797,
+27686,
+27574,
+27461,
+27346,
+27231,
+27115,
+26998,
+26879,
+26760,
+26640,
+26519,
+26398,
+26275,
+26151,
+26027,
+25901,
+25775,
+25648,
+25520,
+25391,
+25262,
+25131,
+25000,
+24868,
+24735,
+24602,
+24467,
+24332,
+24197,
+24060,
+23923,
+23785,
+23647,
+23507,
+23368,
+23227,
+23086,
+22944,
+22802,
+22659,
+22515,
+22371,
+22226,
+22081,
+21935,
+21789,
+21642,
+21494,
+21346,
+21198,
+21049,
+20900,
+20750,
+20600,
+20449,
+20298,
+20146,
+19995,
+19842,
+19690,
+19537,
+19383,
+19230,
+19076,
+18922,
+18767,
+18612,
+18457,
+18302,
+18146,
+17990,
+17834,
+17678,
+17521,
+17365,
+17208,
+17051,
+16894,
+16737,
+16579,
+16422,
+16264,
+16106,
+15949,
+15791,
+15633,
+15475,
+15317,
+15159,
+15001,
+14843,
+14685,
+14527,
+14369,
+14212,
+14054,
+13896,
+13739,
+13581,
+13424,
+13266,
+13109,
+12952,
+12795,
+12639,
+12482,
+12326,
+12170,
+12014,
+11858,
+11703,
+11548,
+11393,
+11238,
+11084,
+10929,
+10776,
+10622,
+10469,
+10316,
+10164,
+10011,
+9860,
+9708,
+9557,
+9407,
+9256,
+9106,
+8957,
+8808,
+8659,
+8511,
+8364,
+8216,
+8070,
+7924,
+7778,
+7633,
+7488,
+7344,
+7200,
+7057,
+6914,
+6773,
+6631,
+6490,
+6350,
+6210,
+6071,
+5933,
+5795,
+5658,
+5521,
+5385,
+5250,
+5115,
+4981,
+4848,
+4716,
+4584,
+4452,
+4322,
+4192,
+4063,
+3935,
+3807,
+3680,
+3554,
+3429,
+3304,
+3180,
+3057,
+2935,
+2813,
+2692,
+2572,
+2453,
+2335,
+2217,
+2101,
+1985,
+1870,
+1755,
+1642,
+1529,
+1418,
+1307,
+1197,
+1088,
+979,
+872,
+765,
+660,
+555,
+451,
+348,
+246,
+145,
+44,
+-54,
+-153,
+-250,
+-347,
+-443,
+-537,
+-631,
+-724,
+-816,
+-908,
+-998,
+-1087,
+-1175,
+-1263,
+-1349,
+-1435,
+-1519,
+-1603,
+-1685,
+-1767,
+-1848,
+-1928,
+-2006,
+-2084,
+-2161,
+-2237,
+-2312,
+-2386,
+-2459,
+-2531,
+-2603,
+-2673,
+-2742,
+-2810,
+-2878,
+-2944,
+-3009,
+-3074,
+-3137,
+-3200,
+-3261,
+-3322,
+-3381,
+-3440,
+-3498,
+-3554,
+-3610,
+-3665,
+-3719,
+-3772,
+-3824,
+-3875,
+-3925,
+-3974,
+-4022,
+-4069,
+-4116,
+-4161,
+-4205,
+-4249,
+-4291,
+-4333,
+-4374,
+-4413,
+-4452,
+-4490,
+-4527,
+-4563,
+-4599,
+-4633,
+-4666,
+-4699,
+-4730,
+-4761,
+-4791,
+-4820,
+-4848,
+-4875,
+-4901,
+-4926,
+-4951,
+-4974,
+-4997,
+-5019,
+-5040,
+-5060,
+-5080,
+-5098,
+-5116,
+-5133,
+-5149,
+-5164,
+-5178,
+-5192,
+-5205,
+-5217,
+-5228,
+-5238,
+-5248,
+-5257,
+-5265,
+-5272,
+-5278,
+-5284,
+-5289,
+-5293,
+-5297,
+-5299,
+-5301,
+-5303,
+-5303,
+-5303,
+-5302,
+-5300,
+-5298,
+-5295,
+-5291,
+-5287,
+-5282,
+-5276,
+-5270,
+-5263,
+-5255,
+-5246,
+-5237,
+-5228,
+-5217,
+-5206,
+-5195,
+-5183,
+-5170,
+-5157,
+-5143,
+-5128,
+-5113,
+-5097,
+-5081,
+-5064,
+-5047,
+-5029,
+-5010,
+-4991,
+-4972,
+-4952,
+-4931,
+-4910,
+-4889,
+-4867,
+-4844,
+-4821,
+-4797,
+-4774,
+-4749,
+-4724,
+-4699,
+-4673,
+-4647,
+-4620,
+-4593,
+-4566,
+-4538,
+-4510,
+-4481,
+-4452,
+-4422,
+-4393,
+-4363,
+-4332,
+-4301,
+-4270,
+-4238,
+-4206,
+-4174,
+-4142,
+-4109,
+-4076,
+-4042,
+-4009,
+-3975,
+-3940,
+-3906,
+-3871,
+-3836,
+-3801,
+-3765,
+-3729,
+-3693,
+-3657,
+-3620,
+-3584,
+-3547,
+-3510,
+-3472,
+-3435,
+-3397,
+-3360,
+-3322,
+-3283,
+-3245,
+-3207,
+-3168,
+-3129,
+-3091,
+-3052,
+-3013,
+-2973,
+-2934,
+-2895,
+-2855,
+-2816,
+-2776,
+-2736,
+-2697,
+-2657,
+-2617,
+-2577,
+-2537,
+-2497,
+-2457,
+-2417,
+-2377,
+-2337,
+-2297,
+-2256,
+-2216,
+-2176,
+-2136,
+-2096,
+-2056,
+-2016,
+-1976,
+-1936,
+-1896,
+-1856,
+-1817,
+-1777,
+-1737,
+-1698,
+-1658,
+-1619,
+-1579,
+-1540,
+-1501,
+-1462,
+-1423,
+-1384,
+-1345,
+-1306,
+-1268,
+-1230,
+-1191,
+-1153,
+-1115,
+-1077,
+-1040,
+-1002,
+-965,
+-927,
+-890,
+-854,
+-817,
+-780,
+-744,
+-708,
+-672,
+-636,
+-600,
+-565,
+-530,
+-494,
+-460,
+-425,
+-391,
+-356,
+-322,
+-289,
+-255,
+-222,
+-189,
+-156,
+-123,
+-91,
+-59,
+-27,
+4,
+35,
+66,
+97,
+127,
+158,
+188,
+218,
+247,
+277,
+306,
+334,
+363,
+391,
+419,
+447,
+474,
+501,
+528,
+554,
+581,
+606,
+632,
+657,
+683,
+707,
+732,
+756,
+780,
+803,
+827,
+850,
+872,
+895,
+917,
+939,
+960,
+981,
+1002,
+1023,
+1043,
+1063,
+1082,
+1102,
+1121,
+1139,
+1158,
+1176,
+1194,
+1211,
+1228,
+1245,
+1262,
+1278,
+1294,
+1309,
+1325,
+1340,
+1354,
+1369,
+1383,
+1397,
+1410,
+1423,
+1436,
+1448,
+1461,
+1473,
+1484,
+1496,
+1507,
+1517,
+1528,
+1538,
+1548,
+1557,
+1566,
+1575,
+1584,
+1592,
+1600,
+1608,
+1616,
+1623,
+1630,
+1636,
+1643,
+1649,
+1654,
+1660,
+1665,
+1670,
+1675,
+1679,
+1683,
+1687,
+1690,
+1694,
+1697,
+1700,
+1702,
+1704,
+1706,
+1708,
+1709,
+1711,
+1712,
+1712,
+1713,
+1713,
+1713,
+1713,
+1712,
+1711,
+1710,
+1709,
+1708,
+1706,
+1704,
+1702,
+1700,
+1697,
+1694,
+1691,
+1688,
+1685,
+1681,
+1677,
+1673,
+1669,
+1664,
+1660,
+1655,
+1650,
+1644,
+1639,
+1633,
+1627,
+1621,
+1615,
+1609,
+1602,
+1596,
+1589,
+1582,
+1575,
+1567,
+1560,
+1552,
+1544,
+1536,
+1528,
+1520,
+1511,
+1503,
+1494,
+1485,
+1476,
+1467,
+1458,
+1448,
+1439,
+1429,
+1419,
+1409,
+1399,
+1389,
+1379,
+1368,
+1358,
+1347,
+1337,
+1326,
+1315,
+1304,
+1293,
+1282,
+1271,
+1260,
+1248,
+1237,
+1225,
+1213,
+1202,
+1190,
+1178,
+1166,
+1154,
+1142,
+1130,
+1118,
+1106,
+1094,
+1081,
+1069,
+1057,
+1044,
+1032,
+1019,
+1007,
+994,
+981,
+969,
+956,
+943,
+931,
+918,
+905,
+892,
+879,
+867,
+854,
+841,
+828,
+815,
+802,
+790,
+777,
+764,
+751,
+738,
+725,
+713,
+700,
+687,
+674,
+662,
+649,
+636,
+623,
+611,
+598,
+585,
+573,
+560,
+548,
+535,
+523,
+510,
+498,
+486,
+473,
+461,
+449,
+437,
+425,
+413,
+401,
+389,
+377,
+365,
+353,
+341,
+330,
+318,
+307,
+295,
+284,
+272,
+261,
+250,
+239,
+228,
+217,
+206,
+195,
+184,
+173,
+163,
+152,
+141,
+131,
+121,
+110,
+100,
+90,
+80,
+70,
+60,
+51,
+41,
+31,
+22,
+12,
+3,
+-5,
+-14,
+-23,
+-32,
+-41,
+-50,
+-59,
+-67,
+-76,
+-84,
+-93,
+-101,
+-109,
+-117,
+-125,
+-133,
+-140,
+-148,
+-156,
+-163,
+-170,
+-178,
+-185,
+-192,
+-199,
+-206,
+-212,
+-219,
+-226,
+-232,
+-239,
+-245,
+-251,
+-257,
+-263,
+-269,
+-275,
+-280,
+-286,
+-291,
+-297,
+-302,
+-307,
+-312,
+-317,
+-322,
+-327,
+-332,
+-336,
+-341,
+-345,
+-349,
+-354,
+-358,
+-362,
+-366,
+-369,
+-373,
+-377,
+-380,
+-384,
+-387,
+-390,
+-394,
+-397,
+-400,
+-402,
+-405,
+-408,
+-411,
+-413,
+-416,
+-418,
+-420,
+-422,
+-424,
+-426,
+-428,
+-430,
+-432,
+-433,
+-435,
+-436,
+-438,
+-439,
+-440,
+-442,
+-443,
+-444,
+-445,
+-445,
+-446,
+-447,
+-447,
+-448,
+-448,
+-449,
+-449,
+-449,
+-449,
+-449,
+-449,
+-449,
+-449,
+-449,
+-449,
+-449,
+-448,
+-448,
+-447,
+-447,
+-446,
+-445,
+-444,
+-443,
+-443,
+-442,
+-441,
+-440,
+-438,
+-437,
+-436,
+-435,
+-433,
+-432,
+-430,
+-429,
+-427,
+-426,
+-424,
+-422,
+-420,
+-419,
+-417,
+-415,
+-413,
+-411,
+-409,
+-407,
+-405,
+-403,
+-400,
+-398,
+-396,
+-393,
+-391,
+-389,
+-386,
+-384,
+-381,
+-379,
+-376,
+-374,
+-371,
+-368,
+-366,
+-363,
+-360,
+-357,
+-355,
+-352,
+-349,
+-346,
+-343,
+-340,
+-337,
+-334,
+-331,
+-328,
+-325,
+-322,
+-319,
+-316,
+-313,
+-310,
+-307,
+-304,
+-301,
+-298,
+-294,
+-291,
+-288,
+-285,
+-282,
+-278,
+-275,
+-272,
+-269,
+-265,
+-262,
+-259,
+-256,
+-252,
+-249,
+-246,
+-243,
+-239,
+-236,
+-233,
+-230,
+-226,
+-223,
+-220,
+-217,
+-213,
+-210,
+-207,
+-204,
+-200,
+-197,
+-194,
+-191,
+-187,
+-184,
+-181,
+-178,
+-175,
+-172,
+-168,
+-165,
+-162,
+-159,
+-156,
+-153,
+-150,
+-147,
+-143,
+-140,
+-137,
+-134,
+-131,
+-128,
+-125,
+-122,
+-120,
+-117,
+-114,
+-111,
+-108,
+-105,
+-102,
+-99,
+-97,
+-94,
+-91,
+-88,
+-86,
+-83,
+-80,
+-78,
+-75,
+-72,
+-70,
+-67,
+-65,
+-62,
+-59,
+-57,
+-55,
+-52,
+-50,
+-47,
+-45,
+-43,
+-40,
+-38,
+-36,
+-33,
+-31,
+-29,
+-27,
+-25,
+-22,
+-20,
+-18,
+-16,
+-14,
+-12,
+-10,
+-8,
+-6,
+-4,
+-2,
+0,
+0,
+2,
+4,
+6,
+8,
+9,
+11,
+13,
+14,
+16,
+17,
+19,
+21,
+22,
+24,
+25,
+27,
+28,
+29,
+31,
+32,
+33,
+35,
+36,
+37,
+38,
+40,
+41,
+42,
+43,
+44,
+45,
+46,
+47,
+48,
+49,
+50,
+51,
+52,
+53,
+54,
+55,
+56,
+56,
+57,
+58,
+59,
+59,
+60,
+61,
+62,
+62,
+63,
+63,
+64,
+64,
+65,
+66,
+66,
+66,
+67,
+67,
+68,
+68,
+69,
+69,
+69,
+70,
+70,
+70,
+70,
+71,
+71,
+71,
+71,
+71,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+72,
+71,
+71,
+71,
+71,
+71,
+70,
+70,
+70,
+70,
+69,
+69,
+69,
+69,
+68,
+68,
+68,
+67,
+67,
+67,
+66,
+66,
+66,
+65,
+65,
+64,
+64,
+64,
+63,
+63,
+62,
+62,
+62,
+61,
+61,
+60,
+60,
+59,
+59,
+58,
+58,
+58,
+57,
+57,
+56,
+56,
+55,
+55,
+54,
+54,
+53,
+53,
+52,
+52,
+51,
+51,
+50,
+50,
+49,
+48,
+48,
+47,
+47,
+46,
+46,
+45,
+45,
+44,
+44,
+43,
+43,
+42,
+42,
+41,
+41,
+40,
+39,
+39,
+38,
+38,
+37,
+37,
+36,
+36,
+35,
+35,
+34,
+34,
+33,
+33,
+32,
+32,
+31,
+31,
+30,
+30,
+29,
+29,
+28,
+28,
+27,
+27,
+26,
+26,
+25,
+25,
+24,
+24,
+23,
+23,
+23,
+22,
+22,
+21,
+21,
+20,
+20,
+20,
+19,
+19,
+18,
+18,
+17,
+17,
+17,
+16,
+16,
+15,
+15,
+15,
+14,
+14,
+14,
+13,
+13,
+12,
+12,
+12,
+11,
+11,
+11,
+10,
+10,
+10,
+9,
+9,
+9,
+9,
+8,
+8,
+8,
+7,
+7,
+7,
+7,
+6,
+6,
+6,
+6,
+5,
+5,
+5,
+5,
+4,
+4,
+4,
+4,
+3,
+3,
+3,
+3,
+3,
+2,
+2,
+2,
+2,
+2,
+1,
+1,
+1,
+1,
+1,
+1,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1,
+-1
+};
+
+static short SMALL_FILTER_IMPD[] = {
+-1,
+-2,
+-4,
+-5,
+-6,
+-8,
+-10,
+-10,
+-13,
+-13,
+-16,
+-16,
+-18,
+-20,
+-21,
+-22,
+-24,
+-25,
+-27,
+-28,
+-30,
+-31,
+-32,
+-34,
+-35,
+-37,
+-38,
+-39,
+-41,
+-42,
+-44,
+-45,
+-46,
+-48,
+-49,
+-51,
+-52,
+-53,
+-55,
+-56,
+-57,
+-59,
+-60,
+-61,
+-63,
+-64,
+-65,
+-67,
+-68,
+-69,
+-71,
+-71,
+-74,
+-74,
+-76,
+-77,
+-78,
+-79,
+-81,
+-82,
+-83,
+-84,
+-86,
+-87,
+-88,
+-89,
+-90,
+-92,
+-92,
+-94,
+-95,
+-96,
+-98,
+-98,
+-100,
+-100,
+-102,
+-103,
+-104,
+-105,
+-106,
+-107,
+-108,
+-109,
+-111,
+-111,
+-112,
+-113,
+-115,
+-115,
+-116,
+-117,
+-119,
+-119,
+-120,
+-121,
+-121,
+-123,
+-124,
+-124,
+-126,
+-126,
+-127,
+-128,
+-129,
+-129,
+-131,
+-131,
+-132,
+-133,
+-133,
+-135,
+-135,
+-135,
+-137,
+-137,
+-138,
+-138,
+-140,
+-139,
+-141,
+-141,
+-142,
+-142,
+-143,
+-144,
+-144,
+-145,
+-145,
+-146,
+-146,
+-147,
+-148,
+-148,
+-148,
+-149,
+-149,
+-150,
+-150,
+-151,
+-151,
+-152,
+-151,
+-153,
+-152,
+-153,
+-154,
+-153,
+-154,
+-154,
+-155,
+-155,
+-155,
+-155,
+-156,
+-156,
+-156,
+-156,
+-157,
+-156,
+-157,
+-157,
+-157,
+-157,
+-158,
+-157,
+-158,
+-158,
+-157,
+-158,
+-158,
+-158,
+-158,
+-158,
+-158,
+-158,
+-158,
+-158,
+-158,
+-157,
+-158,
+-158,
+-157,
+-158,
+-157,
+-158,
+-157,
+-157,
+-157,
+-156,
+-157,
+-156,
+-156,
+-156,
+-156,
+-155,
+-155,
+-155,
+-155,
+-154,
+-155,
+-153,
+-154,
+-153,
+-153,
+-152,
+-153,
+-151,
+-152,
+-151,
+-150,
+-151,
+-150,
+-149,
+-149,
+-149,
+-148,
+-147,
+-148,
+-146,
+-146,
+-146,
+-145,
+-145,
+-144,
+-144,
+-143,
+-143,
+-141,
+-142,
+-141,
+-140,
+-140,
+-139,
+-138,
+-138,
+-137,
+-137,
+-136,
+-135,
+-135,
+-134,
+-133,
+-132,
+-132,
+-132,
+-130,
+-130,
+-129,
+-128,
+-128,
+-127,
+-126,
+-125,
+-125,
+-124,
+-123,
+-122,
+-122,
+-121,
+-120,
+-119,
+-118,
+-118,
+-116,
+-116,
+-115,
+-115,
+-113,
+-113,
+-111,
+-111,
+-110,
+-109,
+-109,
+-107,
+-107,
+-105,
+-105,
+-104,
+-103,
+-102,
+-101,
+-101,
+-98,
+-99,
+-97,
+-97,
+-96,
+-94,
+-94,
+-93,
+-92,
+-92,
+-90,
+-89,
+-88,
+-88,
+-86,
+-86,
+-84,
+-84,
+-82,
+-82,
+-81,
+-80,
+-78,
+-78,
+-77,
+-76,
+-75,
+-74,
+-73,
+-72,
+-72,
+-70,
+-69,
+-68,
+-68,
+-66,
+-65,
+-65,
+-63,
+-63,
+-61,
+-61,
+-59,
+-59,
+-58,
+-56,
+-56,
+-55,
+-54,
+-53,
+-52,
+-51,
+-50,
+-49,
+-48,
+-47,
+-47,
+-45,
+-44,
+-44,
+-42,
+-42,
+-41,
+-39,
+-39,
+-38,
+-37,
+-36,
+-36,
+-34,
+-33,
+-33,
+-31,
+-31,
+-30,
+-29,
+-28,
+-27,
+-26,
+-25,
+-25,
+-23,
+-23,
+-22,
+-21,
+-20,
+-20,
+-18,
+-18,
+-17,
+-16,
+-15,
+-14,
+-14,
+-13,
+-12,
+-11,
+-10,
+-10,
+-9,
+-8,
+-7,
+-6,
+-6,
+-5,
+-4,
+-4,
+-2,
+-2,
+-2,
+0,
+0,
+1,
+2,
+2,
+3,
+4,
+4,
+5,
+6,
+6,
+7,
+8,
+9,
+9,
+9,
+11,
+11,
+11,
+12,
+13,
+13,
+14,
+15,
+15,
+16,
+16,
+17,
+17,
+18,
+19,
+19,
+19,
+20,
+21,
+21,
+21,
+22,
+23,
+23,
+24,
+23,
+25,
+25,
+25,
+26,
+26,
+27,
+27,
+27,
+28,
+28,
+29,
+29,
+30,
+29,
+30,
+31,
+31,
+31,
+32,
+32,
+32,
+32,
+33,
+33,
+34,
+33,
+34,
+35,
+34,
+35,
+35,
+35,
+36,
+36,
+36,
+36,
+37,
+36,
+37,
+37,
+38,
+37,
+38,
+37,
+38,
+39,
+38,
+38,
+39,
+39,
+38,
+39,
+39,
+40,
+39,
+39,
+40,
+39,
+40,
+40,
+39,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+41,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+39,
+40,
+40,
+39,
+40,
+39,
+40,
+39,
+39,
+39,
+39,
+39,
+39,
+39,
+38,
+38,
+39,
+38,
+38,
+38,
+37,
+38,
+37,
+38,
+37,
+36,
+37,
+37,
+36,
+36,
+36,
+36,
+36,
+35,
+35,
+36,
+34,
+35,
+34,
+35,
+34,
+33,
+34,
+33,
+33,
+33,
+33,
+32,
+32,
+32,
+31,
+31,
+31,
+31,
+30,
+31,
+30,
+30,
+29,
+30,
+29,
+28,
+29,
+28,
+28,
+28,
+27,
+27,
+27,
+26,
+27,
+25,
+26,
+25,
+26,
+24,
+25,
+24,
+24,
+23,
+24,
+23,
+22,
+23,
+22,
+22,
+21,
+21,
+21,
+21,
+20,
+20,
+19,
+20,
+19,
+18,
+19,
+18,
+18,
+17,
+17,
+17,
+17,
+16,
+16,
+15,
+16,
+15,
+14,
+15,
+14,
+14,
+13,
+13,
+13,
+12,
+13,
+12,
+11,
+12,
+11,
+10,
+11,
+10,
+10,
+9,
+9,
+9,
+9,
+8,
+8,
+8,
+8,
+7,
+7,
+6,
+7,
+6,
+5,
+6,
+5,
+5,
+5,
+4,
+4,
+4,
+3,
+4,
+3,
+3,
+2,
+2,
+2,
+2,
+1,
+2,
+1,
+0,
+1,
+0,
+0,
+0,
+-1,
+-1,
+-1,
+-1,
+-1,
+-2,
+-2,
+-2,
+-2,
+-3,
+-3,
+-3,
+-3,
+-3,
+-4,
+-4,
+-4,
+-4,
+-5,
+-4,
+-5,
+-5,
+-6,
+-5,
+-6,
+-6,
+-6,
+-6,
+-6,
+-7,
+-6,
+-7,
+-7,
+-7,
+-8,
+-7,
+-8,
+-8,
+-8,
+-8,
+-8,
+-9,
+-8,
+-9,
+-9,
+-9,
+-9,
+-9,
+-10,
+-9,
+-10,
+-10,
+-10,
+-10,
+-10,
+-10,
+-11,
+-10,
+-11,
+-10,
+-11,
+-11,
+-11,
+-11,
+-11,
+-11,
+-11,
+-12,
+-11,
+-12,
+-12,
+-11,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-13,
+-12,
+-12,
+-13,
+-12,
+-13,
+-12,
+-13,
+-13,
+-12,
+-13,
+-13,
+-12,
+-13,
+-13,
+-13,
+-13,
+-12,
+-13,
+-13,
+-13,
+-13,
+-13,
+-12,
+-13,
+-13,
+-13,
+-13,
+-13,
+-12,
+-13,
+-13,
+-13,
+-12,
+-13,
+-13,
+-13,
+-12,
+-13,
+-13,
+-12,
+-13,
+-12,
+-13,
+-12,
+-13,
+-12,
+-12,
+-13,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-11,
+-12,
+-11,
+-12,
+-11,
+-12,
+-11,
+-11,
+-11,
+-11,
+-11,
+-11,
+-11,
+-11,
+-11,
+-10,
+-11,
+-11,
+-10,
+-10,
+-11,
+-10,
+-10,
+-10,
+-10,
+-10,
+-9,
+-10,
+-10,
+-9,
+-10,
+-9,
+-8,
+-9,
+-9,
+-9,
+-9,
+-9,
+-9,
+-8,
+-9,
+-8,
+-9,
+-8,
+-8,
+-8,
+-8,
+-8,
+-7,
+-8,
+-8,
+-7,
+-7,
+-8,
+-7,
+-7,
+-7,
+-7,
+-6,
+-7,
+-7,
+-6,
+-7,
+-6,
+-6,
+-6,
+-6,
+-6,
+-6,
+-5,
+-6,
+-5,
+-6,
+-5,
+-5,
+-5,
+-5,
+-5,
+-5,
+-5,
+-4,
+-5,
+-4,
+-4,
+-5,
+-4,
+-4,
+-4,
+-3,
+-4,
+-4,
+-3,
+-4,
+-3,
+-3,
+-4,
+-3,
+-3,
+-2,
+-3,
+-3,
+-3,
+-2,
+-3,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-1,
+-2,
+-1,
+-2,
+-1,
+-1,
+-2,
+-1,
+-1,
+-1,
+0,
+-1,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+1,
+0,
+1,
+0,
+1,
+1,
+1,
+1,
+0,
+1,
+1,
+1,
+2,
+1,
+1,
+1,
+2,
+1,
+2,
+1,
+2,
+1,
+2,
+2,
+2,
+1,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+3,
+2,
+2,
+3,
+2,
+2,
+3,
+2,
+3,
+2,
+3,
+2,
+3,
+3,
+2,
+3,
+3,
+3,
+2,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+2,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+2,
+3,
+3,
+3,
+2,
+3,
+3,
+2,
+3,
+3,
+2,
+3,
+2,
+3,
+3,
+2,
+2,
+3,
+2,
+3,
+2,
+2,
+3,
+2,
+2,
+3,
+2,
+2,
+2,
+2,
+3,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+0,
+2,
+2,
+2,
+2,
+1,
+2,
+2,
+1,
+2,
+1,
+2,
+2,
+1,
+2,
+1,
+2,
+1,
+1,
+2,
+1,
+1,
+2,
+1,
+1,
+1,
+2,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+0,
+1,
+1,
+1,
+0,
+1,
+1,
+1,
+0,
+1,
+0,
+1,
+0,
+1,
+1,
+0,
+0,
+1,
+0,
+1,
+0,
+1,
+0,
+0,
+1,
+0,
+0,
+0,
+1,
+0,
+0,
+0,
+0,
+1,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+1,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+1,
+-1,
+-2,
+-4,
+-5,
+-6,
+-8,
+-10,
+-10,
+-13,
+-13,
+-16,
+-16,
+-18,
+-20,
+-21,
+-22,
+-24,
+-25,
+-27,
+-28,
+-30,
+-31,
+-32,
+-34,
+-35,
+-37,
+-38,
+-39,
+-41,
+-42,
+-44,
+-45,
+-46,
+-48,
+-49,
+-51,
+-52,
+-53,
+-55,
+-56,
+-57,
+-59,
+-60,
+-61,
+-63,
+-64,
+-65,
+-67,
+-68,
+-69,
+-71,
+-71,
+-74,
+-74,
+-76,
+-77,
+-78,
+-79,
+-81,
+-82,
+-83,
+-84,
+-86,
+-87,
+-88,
+-89,
+-90,
+-92,
+-92,
+-94,
+-95,
+-96,
+-98,
+-98,
+-100,
+-100,
+-102,
+-103,
+-104,
+-105,
+-106,
+-107,
+-108,
+-109,
+-111,
+-111,
+-112,
+-113,
+-115,
+-115,
+-116,
+-117,
+-119,
+-119,
+-120,
+-121,
+-121,
+-123,
+-124,
+-124,
+-126,
+-126,
+-127,
+-128,
+-129,
+-129,
+-131,
+-131,
+-132,
+-133,
+-133,
+-135,
+-135,
+-135,
+-137,
+-137,
+-138,
+-138,
+-140,
+-139,
+-141,
+-141,
+-142,
+-142,
+-143,
+-144,
+-144,
+-145,
+-145,
+-146,
+-146,
+-147,
+-148,
+-148,
+-148,
+-149,
+-149,
+-150,
+-150,
+-151,
+-151,
+-152,
+-151,
+-153,
+-152,
+-153,
+-154,
+-153,
+-154,
+-154,
+-155,
+-155,
+-155,
+-155,
+-156,
+-156,
+-156,
+-156,
+-157,
+-156,
+-157,
+-157,
+-157,
+-157,
+-158,
+-157,
+-158,
+-158,
+-157,
+-158,
+-158,
+-158,
+-158,
+-158,
+-158,
+-158,
+-158,
+-158,
+-158,
+-157,
+-158,
+-158,
+-157,
+-158,
+-157,
+-158,
+-157,
+-157,
+-157,
+-156,
+-157,
+-156,
+-156,
+-156,
+-156,
+-155,
+-155,
+-155,
+-155,
+-154,
+-155,
+-153,
+-154,
+-153,
+-153,
+-152,
+-153,
+-151,
+-152,
+-151,
+-150,
+-151,
+-150,
+-149,
+-149,
+-149,
+-148,
+-147,
+-148,
+-146,
+-146,
+-146,
+-145,
+-145,
+-144,
+-144,
+-143,
+-143,
+-141,
+-142,
+-141,
+-140,
+-140,
+-139,
+-138,
+-138,
+-137,
+-137,
+-136,
+-135,
+-135,
+-134,
+-133,
+-132,
+-132,
+-132,
+-130,
+-130,
+-129,
+-128,
+-128,
+-127,
+-126,
+-125,
+-125,
+-124,
+-123,
+-122,
+-122,
+-121,
+-120,
+-119,
+-118,
+-118,
+-116,
+-116,
+-115,
+-115,
+-113,
+-113,
+-111,
+-111,
+-110,
+-109,
+-109,
+-107,
+-107,
+-105,
+-105,
+-104,
+-103,
+-102,
+-101,
+-101,
+-98,
+-99,
+-97,
+-97,
+-96,
+-94,
+-94,
+-93,
+-92,
+-92,
+-90,
+-89,
+-88,
+-88,
+-86,
+-86,
+-84,
+-84,
+-82,
+-82,
+-81,
+-80,
+-78,
+-78,
+-77,
+-76,
+-75,
+-74,
+-73,
+-72,
+-72,
+-70,
+-69,
+-68,
+-68,
+-66,
+-65,
+-65,
+-63,
+-63,
+-61,
+-61,
+-59,
+-59,
+-58,
+-56,
+-56,
+-55,
+-54,
+-53,
+-52,
+-51,
+-50,
+-49,
+-48,
+-47,
+-47,
+-45,
+-44,
+-44,
+-42,
+-42,
+-41,
+-39,
+-39,
+-38,
+-37,
+-36,
+-36,
+-34,
+-33,
+-33,
+-31,
+-31,
+-30,
+-29,
+-28,
+-27,
+-26,
+-25,
+-25,
+-23,
+-23,
+-22,
+-21,
+-20,
+-20,
+-18,
+-18,
+-17,
+-16,
+-15,
+-14,
+-14,
+-13,
+-12,
+-11,
+-10,
+-10,
+-9,
+-8,
+-7,
+-6,
+-6,
+-5,
+-4,
+-4,
+-2,
+-2,
+-2,
+0,
+0,
+1,
+2,
+2,
+3,
+4,
+4,
+5,
+6,
+6,
+7,
+8,
+9,
+9,
+9,
+11,
+11,
+11,
+12,
+13,
+13,
+14,
+15,
+15,
+16,
+16,
+17,
+17,
+18,
+19,
+19,
+19,
+20,
+21,
+21,
+21,
+22,
+23,
+23,
+24,
+23,
+25,
+25,
+25,
+26,
+26,
+27,
+27,
+27,
+28,
+28,
+29,
+29,
+30,
+29,
+30,
+31,
+31,
+31,
+32,
+32,
+32,
+32,
+33,
+33,
+34,
+33,
+34,
+35,
+34,
+35,
+35,
+35,
+36,
+36,
+36,
+36,
+37,
+36,
+37,
+37,
+38,
+37,
+38,
+37,
+38,
+39,
+38,
+38,
+39,
+39,
+38,
+39,
+39,
+40,
+39,
+39,
+40,
+39,
+40,
+40,
+39,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+41,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+40,
+39,
+40,
+40,
+39,
+40,
+39,
+40,
+39,
+39,
+39,
+39,
+39,
+39,
+39,
+38,
+38,
+39,
+38,
+38,
+38,
+37,
+38,
+37,
+38,
+37,
+36,
+37,
+37,
+36,
+36,
+36,
+36,
+36,
+35,
+35,
+36,
+34,
+35,
+34,
+35,
+34,
+33,
+34,
+33,
+33,
+33,
+33,
+32,
+32,
+32,
+31,
+31,
+31,
+31,
+30,
+31,
+30,
+30,
+29,
+30,
+29,
+28,
+29,
+28,
+28,
+28,
+27,
+27,
+27,
+26,
+27,
+25,
+26,
+25,
+26,
+24,
+25,
+24,
+24,
+23,
+24,
+23,
+22,
+23,
+22,
+22,
+21,
+21,
+21,
+21,
+20,
+20,
+19,
+20,
+19,
+18,
+19,
+18,
+18,
+17,
+17,
+17,
+17,
+16,
+16,
+15,
+16,
+15,
+14,
+15,
+14,
+14,
+13,
+13,
+13,
+12,
+13,
+12,
+11,
+12,
+11,
+10,
+11,
+10,
+10,
+9,
+9,
+9,
+9,
+8,
+8,
+8,
+8,
+7,
+7,
+6,
+7,
+6,
+5,
+6,
+5,
+5,
+5,
+4,
+4,
+4,
+3,
+4,
+3,
+3,
+2,
+2,
+2,
+2,
+1,
+2,
+1,
+0,
+1,
+0,
+0,
+0,
+-1,
+-1,
+-1,
+-1,
+-1,
+-2,
+-2,
+-2,
+-2,
+-3,
+-3,
+-3,
+-3,
+-3,
+-4,
+-4,
+-4,
+-4,
+-5,
+-4,
+-5,
+-5,
+-6,
+-5,
+-6,
+-6,
+-6,
+-6,
+-6,
+-7,
+-6,
+-7,
+-7,
+-7,
+-8,
+-7,
+-8,
+-8,
+-8,
+-8,
+-8,
+-9,
+-8,
+-9,
+-9,
+-9,
+-9,
+-9,
+-10,
+-9,
+-10,
+-10,
+-10,
+-10,
+-10,
+-10,
+-11,
+-10,
+-11,
+-10,
+-11,
+-11,
+-11,
+-11,
+-11,
+-11,
+-11,
+-12,
+-11,
+-12,
+-12,
+-11,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-13,
+-12,
+-12,
+-13,
+-12,
+-13,
+-12,
+-13,
+-13,
+-12,
+-13,
+-13,
+-12,
+-13,
+-13,
+-13,
+-13,
+-12,
+-13,
+-13,
+-13,
+-13,
+-13,
+-12,
+-13,
+-13,
+-13,
+-13,
+-13,
+-12,
+-13,
+-13,
+-13,
+-12,
+-13,
+-13,
+-13,
+-12,
+-13,
+-13,
+-12,
+-13,
+-12,
+-13,
+-12,
+-13,
+-12,
+-12,
+-13,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-12,
+-11,
+-12,
+-11,
+-12,
+-11,
+-12,
+-11,
+-11,
+-11,
+-11,
+-11,
+-11,
+-11,
+-11,
+-11,
+-10,
+-11,
+-11,
+-10,
+-10,
+-11,
+-10,
+-10,
+-10,
+-10,
+-10,
+-9,
+-10,
+-10,
+-9,
+-10,
+-9,
+-8,
+-9,
+-9,
+-9,
+-9,
+-9,
+-9,
+-8,
+-9,
+-8,
+-9,
+-8,
+-8,
+-8,
+-8,
+-8,
+-7,
+-8,
+-8,
+-7,
+-7,
+-8,
+-7,
+-7,
+-7,
+-7,
+-6,
+-7,
+-7,
+-6,
+-7,
+-6,
+-6,
+-6,
+-6,
+-6,
+-6,
+-5,
+-6,
+-5,
+-6,
+-5,
+-5,
+-5,
+-5,
+-5,
+-5,
+-5,
+-4,
+-5,
+-4,
+-4,
+-5,
+-4,
+-4,
+-4,
+-3,
+-4,
+-4,
+-3,
+-4,
+-3,
+-3,
+-4,
+-3,
+-3,
+-2,
+-3,
+-3,
+-3,
+-2,
+-3,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-2,
+-1,
+-2,
+-1,
+-2,
+-1,
+-1,
+-2,
+-1,
+-1,
+-1,
+0,
+-1,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+1,
+0,
+1,
+0,
+1,
+1,
+1,
+1,
+0,
+1,
+1,
+1,
+2,
+1,
+1,
+1,
+2,
+1,
+2,
+1,
+2,
+1,
+2,
+2,
+2,
+1,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+3,
+2,
+2,
+3,
+2,
+2,
+3,
+2,
+3,
+2,
+3,
+2,
+3,
+3,
+2,
+3,
+3,
+3,
+2,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+4,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+2,
+3,
+3,
+3,
+3,
+3,
+3,
+3,
+2,
+3,
+3,
+3,
+2,
+3,
+3,
+2,
+3,
+3,
+2,
+3,
+2,
+3,
+3,
+2,
+2,
+3,
+2,
+3,
+2,
+2,
+3,
+2,
+2,
+3,
+2,
+2,
+2,
+2,
+3,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+2,
+0,
+2,
+2,
+2,
+2,
+1,
+2,
+2,
+1,
+2,
+1,
+2,
+2,
+1,
+2,
+1,
+2,
+1,
+1,
+2,
+1,
+1,
+2,
+1,
+1,
+1,
+2,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+1,
+0,
+1,
+1,
+1,
+0,
+1,
+1,
+1,
+0,
+1,
+0,
+1,
+0,
+1,
+1,
+0,
+0,
+1,
+0,
+1,
+0,
+1,
+0,
+0,
+1,
+0,
+0,
+0,
+1,
+0,
+0,
+0,
+0,
+1,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+-1,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+1,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+1
+};
diff -Nur linux-2.6.29/sound/soc/codecs/ak4671.c linux-2.6.29-spica/sound/soc/codecs/ak4671.c
--- linux-2.6.29/sound/soc/codecs/ak4671.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/codecs/ak4671.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,1148 @@
+/*
+ * ak4671.c  --  AK4671 ALSA Soc Audio driver
+ *
+ * Copyright (C) 2008 Samsung Electronics, Seung-Bum Kang
+ *
+ * Based on ak4535.c by Richard Purdie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/i2c/maximi2c.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include <plat/egpio.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <mach/hardware.h>
+
+#include "ak4671.h"
+
+#define AUDIO_NAME "ak4671"
+#define AK4671_VERSION "0.2"
+
+#define SUBJECT "ak4671.c"
+
+//#define AUDIO_SPECIFIC_DEBUG	1
+
+#define P1(format,...)\
+	printk ("["SUBJECT "(%d)] " format "\n", __LINE__, ## __VA_ARGS__);
+
+#if AUDIO_SPECIFIC_DEBUG
+#define P(format,...)\
+	printk ("[ "SUBJECT " (%s,%d) ] " format "\n", __func__, __LINE__, ## __VA_ARGS__);
+#define FI \
+	printk ("[ "SUBJECT " (%s,%d) ] " "%s - IN" "\n", __func__, __LINE__, __func__);
+#define FO \
+	printk ("[ "SUBJECT " (%s,%d) ] " "%s - OUT" "\n", __func__, __LINE__, __func__);
+#else
+#define P(format,...)
+#define FI 
+#define FO 
+#endif
+
+#define DIGITAL_FILTER_CONTROL		0
+
+struct snd_soc_codec_device soc_codec_dev_ak4671;
+static int set_registers(struct snd_soc_codec *, int);
+
+static const char *audio_path[] = { "Playback Path", 
+									"Voice Call Path", 
+									"Voice Memo Path", 
+									"FM Radio Path", 
+									"MIC Path", 
+									NULL};
+
+/* first 8bit : audio_path id
+ * last  8bit : path id */
+int ak4671_path = 0;
+
+/* spk <-> hp path value */
+int ak4671_amp_path = 0;
+
+/* main <-> sub mic path value */
+int ak4671_mic_path = AK4671_MIC_PATH_MAIN; 
+
+/* for idle current */
+int ak4671_idle_mode = IDLE_POWER_DOWN_MODE_OFF; 
+
+/* Recording mode */
+int ak4671_voice_call_rec_mode = 0; 
+/* voicecall response mode */
+int ak4671_voice_call_auto_response_mode = 0;
+
+/* ak4671 AUDIO_EN control */
+static int ak4671_power = 0;
+
+
+/*
+ * ak4671 register cache
+ */
+static const u16 ak4671_reg[AK4671_CACHEREGNUM] = {
+    0x0000, 0x00F6, 0x0000, 0x0002, 0x0000, 0x0055, 0x0000, 0x0000, /* 0x00 ~ 0x07 */
+    0x00B5, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /* 0x08 ~ 0x0F */
+
+    0x0000, 0x0080, 0x0091, 0x0091, 0x00E1, 0x0000, 0x0000, 0x0000, /* 0x10 ~ 0x17 */
+    0x0002, 0x0001, 0x0018, 0x0018, 0x0000, 0x0002, 0x0000, 0x0000, /* 0x18 ~ 0x1F */
+
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /* 0x20 ~ 0x27 */
+    0x00A9, 0x001F, 0x0020, 0x00AD, 0x0000, 0x0000, 0x0000, 0x0000, /* 0x28 ~ 0x2F */
+
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /* 0x30 ~ 0x37 */
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /* 0x38 ~ 0x3F */
+
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /* 0x40 ~ 0x47 */
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, /* 0x48 ~ 0x4F */
+
+    0x0088, 0x0088, 0x0008, 0x0000, 0x0000, 0x0000, 0x0018, 0x0018, /* 0x50 ~ 0x57 */
+    0x0000, 0x0000, 0x0000					 						/* 0x58 ~ 0x5A */
+};
+static u16 ak4671_reg_default[AK4671_CACHEREGNUM];
+
+/*
+ * read ak4671 register cache
+ */
+static inline unsigned int ak4671_read_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+
+	if (reg >= AK4671_CACHEREGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ * read to the AK4671 register space
+ */
+static inline unsigned int ak4671_read(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u8 data;
+	data = reg;
+
+	if (codec->hw_write(codec->control_data, &data, 1) != 1)
+		return -EIO;
+
+	if (codec->hw_read(codec->control_data, &data, 1) != 1)
+		return -EIO;
+
+	return data;
+};
+
+/*
+ * write ak4671 register cache
+ */
+static inline void ak4671_write_reg_cache(struct snd_soc_codec *codec,
+	u16 reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	if (reg >= AK4671_CACHEREGNUM)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the AK4671 register space
+ */
+static int ak4671_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	/* data is
+	 *   D15..D8 AK4671 register offset
+	 *   D7...D0 register data
+	 */
+	data[0] = reg & 0xff;
+	data[1] = value & 0xff;
+
+	//P("--- ak4671 i2c --- write : reg - 0x%02x, val - 0x%02x", reg, value);
+	ak4671_write_reg_cache(codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+static int ak4671_sync(struct snd_soc_codec *codec)
+{
+	u16 *cache = codec->reg_cache;
+
+	memcpy(cache, ak4671_reg_default, sizeof(ak4671_reg_default));
+	
+	return 0;
+};
+
+static int ak4671_get_idle_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = ak4671_idle_mode;
+	return 0;
+}
+
+static int ak4671_set_idle_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	P1(" idle_mode_value : %d", (int)ucontrol->value.integer.value[0]);
+
+	if(ak4671_power == 0 && ak4671_idle_mode == IDLE_POWER_DOWN_MODE_ON)
+	{
+		P1("audio power up");
+		set_registers(codec, ak4671_path);
+		return 1;
+	}
+
+	if ( (ak4671_path & 0xf0) == MM_AUDIO_PLAYBACK)
+	{
+		if (ucontrol->value.integer.value[0] == 0 && ak4671_idle_mode == IDLE_POWER_DOWN_MODE_ON) { // Off
+			idle_mode_enable(codec, ak4671_path);
+		} else if (ucontrol->value.integer.value[0] == 1 && ak4671_idle_mode == IDLE_POWER_DOWN_MODE_OFF) { // On
+			idle_mode_disable(codec, ak4671_path);
+		} else {
+			P1("invalid idle mode value");
+			return -1;
+		}
+
+		ak4671_idle_mode = ucontrol->value.integer.value[0];
+	} else 
+		P1("only Playback mode!");
+
+	return 1;
+}
+
+static int get_external_amp_power(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	//ucontrol->value.integer.value[0] = ak4671_idle_mode;
+	return 0;
+}
+
+static int set_external_amp_power(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	P("amp power : %d", (int)ucontrol->value.integer.value[0]);
+
+	if (ucontrol->value.integer.value[0] == 0) { // Off
+		amp_enable(0);
+	} else if (ucontrol->value.integer.value[0] == 1) { // On
+		amp_enable(1);
+	} else {
+		P("invalid value");
+		return -1;
+	}
+
+	return 1;
+}
+
+static int ak4671_get_voice_call_auto_response_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = ak4671_voice_call_rec_mode;
+	return 0;
+}
+
+static int ak4671_set_voice_call_auto_response_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	P1("Auto Response Mode On/Off :%d, Voicecall Mode :%d", ucontrol->value.integer.value[0], ak4671_voice_call_auto_response_mode);
+	
+	if ( (ak4671_path & 0xf0) == MM_AUDIO_VOICECALL ) 
+	{
+		if (ucontrol->value.integer.value[0] == 0 && ak4671_voice_call_auto_response_mode == 1) { // Off
+			voice_call_auto_response_disable(codec, ak4671_path);
+		} else if (ucontrol->value.integer.value[0] == 1 && ak4671_voice_call_auto_response_mode == 0) { // On
+			voice_call_auto_response_enable(codec, ak4671_path);
+		} else {
+			P("invalid voicecall auto response mode value");
+			return -1;
+		}
+		ak4671_voice_call_auto_response_mode = ucontrol->value.integer.value[0];
+	} else
+		printk("invalid voicecall auto response mode value");
+
+	return 1;
+}
+
+static int ak4671_get_voice_call_rec_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = ak4671_voice_call_rec_mode;
+	return 0;
+}
+
+static int ak4671_set_voice_call_rec_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	P1("Voiceccall Rec Mode On/Off:%d, Voicecall Mode :%d", ucontrol->value.integer.value[0], ak4671_voice_call_rec_mode);
+
+	if ( (ak4671_path & 0xf0) == MM_AUDIO_VOICECALL ) 
+	{
+		if (ucontrol->value.integer.value[0] == 0 && ak4671_voice_call_rec_mode == 1) { // Off
+			voice_call_rec_disable(codec, ak4671_path);
+		} else if (ucontrol->value.integer.value[0] == 1 && ak4671_voice_call_rec_mode == 0) { // On
+			voice_call_rec_enable(codec, ak4671_path);
+		} else {
+			P("invalid recording mode value");
+			return -1;
+		}
+		ak4671_voice_call_rec_mode = ucontrol->value.integer.value[0];
+	} else
+		printk("invalid recording mode value");
+
+	return 1;
+}
+
+static int ak4671_get_mic_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = ak4671_mic_path;
+	return 0;
+}
+
+static int ak4671_set_mic_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	P("");
+	if (ucontrol->value.integer.value[0] == 0) { // MAIN MIC
+		mic_set_path(AK4671_MIC_PATH_MAIN);
+	} else if (ucontrol->value.integer.value[0] == 1) { // SUB MIC
+		mic_set_path(AK4671_MIC_PATH_SUB);
+	} else {
+		P("invalid Mic value");
+		return -1;
+	}
+	ak4671_mic_path = ucontrol->value.integer.value[0];
+
+	return 1;
+}
+
+static int ak4671_get_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int i = 0;
+	while(audio_path[i] != NULL) {
+		if(!strcmp(audio_path[i], kcontrol->id.name) && ((ak4671_path >> 4) == i)) {
+			ucontrol->value.integer.value[0] = ak4671_path & 0xf;
+			break;
+		}
+		i++;
+	}
+	return 0;
+}
+
+static int ak4671_set_path(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int i = 0, new_path;
+
+	P("path_state : 0x%02x, input path = 0x%02x", ak4671_path
+			, (unsigned int)((i << 4) | ucontrol->value.integer.value[0]) );
+	while(audio_path[i] != NULL) {
+		new_path = (i << 4) | ucontrol->value.integer.value[0];
+		if(!strcmp(audio_path[i], kcontrol->id.name) && ak4671_path != new_path)  {
+
+			set_registers(codec, new_path);
+
+			break;
+		}
+		i++;
+	}
+	return 1;
+}
+
+static const char *playback_path[] = { "Off", "RCV", "SPK", "HP", "BT", "SPK_HP", "R_SPK_HP", };
+static const char *voicecall_path[] = { "Off", "RCV", "SPK", "HP", "BT", "SPK_LOOP"};
+static const char *voicememo_path[] = { "Off", "MAIN", "SUB", "EAR", "BT", };
+static const char *fmradio_path[] = { "Off", "RCV", "SPK", "HP", "BT", };
+static const char *mic_path[] = { "Main Mic", "Sub Mic", };
+static const char *idle_mode[] = { "Off", "ON" };
+static const char *voicecall_rec_mode[] = { "Off", "ON" };
+static const char *external_amp_control[] = { "Off", "ON" };
+static const char *voicecall_auto_response_control[] = { "Off", "ON" };
+
+static const struct soc_enum path_control_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(playback_path),playback_path),
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(voicecall_path),voicecall_path),
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(voicememo_path),voicememo_path),
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(fmradio_path),fmradio_path),
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(mic_path),mic_path),
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(idle_mode),idle_mode),
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(voicecall_rec_mode),voicecall_rec_mode),
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(external_amp_control),external_amp_control),
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(voicecall_auto_response_control),voicecall_auto_response_control),
+};
+
+static const struct snd_kcontrol_new ak4671_snd_controls[] = {
+	/* Volume Control */
+	SOC_SINGLE("Output Volume L", AK4671_L_OUTPUT_VOL, 0, 0x30, 0),
+	SOC_SINGLE("Output Volume R", AK4671_R_OUTPUT_VOL, 0, 0x30, 0),
+	SOC_SINGLE("Output Volume - RCV", AK4671_OUTPUT_VOL, 0, 0x7, 0),
+	SOC_SINGLE("Output Volume - SPK/EAR", AK4671_OUTPUT_VOL, 4, 0xf, 0),
+	SOC_SINGLE("Output Volume - MUTE", AK4671_MODE_CONTROL2, 2, 1, 0),
+
+	/* Path Control */
+	SOC_ENUM_EXT("Playback Path", path_control_enum[0],
+		ak4671_get_path, ak4671_set_path),
+	SOC_ENUM_EXT("Voice Call Path", path_control_enum[1],
+		ak4671_get_path, ak4671_set_path),
+	SOC_ENUM_EXT("Voice Memo Path", path_control_enum[2],
+		ak4671_get_path, ak4671_set_path),
+	SOC_ENUM_EXT("MIC Path", path_control_enum[4],
+		ak4671_get_mic_path, ak4671_set_mic_path),
+
+	/* MIC Gain */
+	SOC_DOUBLE("MIC Gain", 							AK4671_MIC_GAIN, 0, 4, 0xf, 0),
+
+	SOC_ENUM_EXT("FM Radio Path", path_control_enum[3],
+		ak4671_get_path, ak4671_set_path),
+
+	SOC_ENUM_EXT("Idle Mode", path_control_enum[5],
+		ak4671_get_idle_mode, ak4671_set_idle_mode),
+
+	SOC_ENUM_EXT("Voice Call Rec Mode", path_control_enum[6],
+		ak4671_get_voice_call_rec_mode, ak4671_set_voice_call_rec_mode),
+
+	SOC_ENUM_EXT("External Amp Power", path_control_enum[7],
+		get_external_amp_power, set_external_amp_power),
+
+	SOC_ENUM_EXT("Voice Call Auto Response Mode", path_control_enum[8],
+		ak4671_get_voice_call_auto_response_mode, ak4671_set_voice_call_auto_response_mode),
+		
+#if DIGITAL_FILTER_CONTROL
+	/* ALC Control */
+	SOC_SINGLE("ALC Enable", 						AK4671_MODE_CONTROL1, 0, 1, 0),
+	SOC_SINGLE("ALC Limiter detection level / Recovery Counter Reset level",
+													AK4671_ALC_MODE_CONTROL, 0, 3, 0),
+	SOC_SINGLE("ALC Recovery GAIN Step",  			AK4671_ALC_MODE_CONTROL, 2, 3, 0),
+	SOC_SINGLE("ALC ATT Step",			  			AK4671_ALC_MODE_CONTROL, 4, 3, 0),
+	SOC_SINGLE("ALC Zero Crossing detection Enable",AK4671_ALC_MODE_CONTROL, 6, 1, 0),
+	SOC_SINGLE("ALC Reference Select", 				AK4671_ALC_REF_SELECT, 0, 0xff, 0),
+	SOC_SINGLE("ALC Timer Select", 					AK4671_ALC_TIMER_SELECT, 0, 0xff, 0),
+
+	/* Digital Filter */
+	SOC_SINGLE("Signal Select of Programmable Filter Block", 	AK4671_DIGITAL_FILTER, 0, 1, 0),
+	SOC_SINGLE("Gain Select at GAIN Block", 	AK4671_DIGITAL_FILTER, 6, 3, 0),
+	SOC_SINGLE("Digital Volume Transition Time Setting", 	AK4671_MODE_CONTROL2, 1, 1, 0),
+
+	SOC_SINGLE("FIL3 Coefficient Setting Enable", 	AK4671_DIGITAL_FILTER, 2, 1, 0),
+	SOC_SINGLE("FIL3 Co-efficient 0 (F3A7-F3A0)", 	AK4671_FIL3_0, 0, 0xff, 0),
+	SOC_SINGLE("FIL3 Co-efficient 1 (F3A13-F3A8)", 	AK4671_FIL3_1, 0, 0x6f, 0),
+	SOC_SINGLE("FIL3 Co-efficient 2 (F3B7-F3B0)", 	AK4671_FIL3_2, 0, 0xff, 0),
+	SOC_SINGLE("FIL3 Co-efficient 3 (F3B13-F3B8)", 	AK4671_FIL3_3, 0, 0x6f, 0),
+
+	SOC_SINGLE("EQ0 Coefficient Setting Enable", 	AK4671_DIGITAL_FILTER, 3, 1, 0),
+	SOC_SINGLE("EQ0 Co-efficient 0 (E0A7-F3A0)", 	AK4671_EQ_0, 0, 0xff, 0),
+	SOC_SINGLE("EQ0 Co-efficient 1 (E0A15-F3A8)", 	AK4671_EQ_1, 0, 0xff, 0),
+	SOC_SINGLE("EQ0 Co-efficient 2 (E0B7-F3B0)", 	AK4671_EQ_2, 0, 0xff, 0),
+	SOC_SINGLE("EQ0 Co-efficient 3 (E0B13-F3B8)", 	AK4671_EQ_3, 0, 0x6f, 0),
+	SOC_SINGLE("EQ0 Co-efficient 4 (E0C7-F3C0)", 	AK4671_EQ_4, 0, 0xff, 0),
+	SOC_SINGLE("EQ0 Co-efficient 5 (E0C15-F3C8)", 	AK4671_EQ_5, 0, 0xff, 0),
+
+	SOC_SINGLE("HPF Coefficient Setting Enable", 	AK4671_DIGITAL_FILTER, 4, 1, 0),
+	SOC_SINGLE("FIL1 Co-efficient 0 (F1A7-F1A0)", 	AK4671_FIL1_0, 0, 0xff, 0),
+	SOC_SINGLE("FIL1 Co-efficient 1 (F1A13-F1A8)", 	AK4671_FIL1_1, 0, 0x6f, 0),
+	SOC_SINGLE("FIL1 Co-efficient 2 (F1B7-F1B0)", 	AK4671_FIL1_2, 0, 0xff, 0),
+	SOC_SINGLE("FIL1 Co-efficient 3 (F1B13-F1B8)", 	AK4671_FIL1_3, 0, 0x6f, 0),
+
+	SOC_SINGLE("LPF Coefficient Setting Enable", 	AK4671_DIGITAL_FILTER, 5, 1, 0),
+	SOC_SINGLE("FIL2 Co-efficient 0 (F2A7-F2A0)", 	AK4671_FIL2_0, 0, 0xff, 0),
+	SOC_SINGLE("FIL2 Co-efficient 1 (F2A13-F2A8)", 	AK4671_FIL2_1, 0, 0x6f, 0),
+	SOC_SINGLE("FIL2 Co-efficient 2 (F2B7-F2B0)", 	AK4671_FIL2_2, 0, 0xff, 0),
+	SOC_SINGLE("FIL2 Co-efficient 3 (F2B13-F2B8)", 	AK4671_FIL2_3, 0, 0x6f, 0),
+
+	/* Equalizer Coefficient */
+	SOC_SINGLE("Select 5-Band Equalizer", 					AK4671_MODE_CONTROL1, 3, 1, 0),
+
+	SOC_SINGLE("Equalizer 1 Enable", 	AK4671_DIGITAL_FILTER2, 0, 1, 0),
+	SOC_SINGLE("Equalizer 2 Enable", 	AK4671_DIGITAL_FILTER2, 1, 1, 0),
+	SOC_SINGLE("Equalizer 3 Enable", 	AK4671_DIGITAL_FILTER2, 2, 1, 0),
+	SOC_SINGLE("Equalizer 4 Enable", 	AK4671_DIGITAL_FILTER2, 3, 1, 0),
+	SOC_SINGLE("Equalizer 5 Enable", 	AK4671_DIGITAL_FILTER2, 4, 1, 0),
+
+	SOC_SINGLE("E1 Co-efficient 0", 	AK4671_E1_0, 0, 0xff, 0),
+	SOC_SINGLE("E1 Co-efficient 1", 	AK4671_E1_1, 0, 0xff, 0),
+	SOC_SINGLE("E1 Co-efficient 2", 	AK4671_E1_2, 0, 0xff, 0),
+	SOC_SINGLE("E1 Co-efficient 3", 	AK4671_E1_3, 0, 0xff, 0),
+	SOC_SINGLE("E1 Co-efficient 4", 	AK4671_E1_4, 0, 0xff, 0),
+	SOC_SINGLE("E1 Co-efficient 5", 	AK4671_E1_5, 0, 0xff, 0),
+	SOC_SINGLE("E2 Co-efficient 0", 	AK4671_E2_0, 0, 0xff, 0),
+	SOC_SINGLE("E2 Co-efficient 1", 	AK4671_E2_1, 0, 0xff, 0),
+	SOC_SINGLE("E2 Co-efficient 2", 	AK4671_E2_2, 0, 0xff, 0),
+	SOC_SINGLE("E2 Co-efficient 3", 	AK4671_E2_3, 0, 0xff, 0),
+	SOC_SINGLE("E2 Co-efficient 4", 	AK4671_E2_4, 0, 0xff, 0),
+	SOC_SINGLE("E2 Co-efficient 5", 	AK4671_E2_5, 0, 0xff, 0),
+	SOC_SINGLE("E3 Co-efficient 0", 	AK4671_E3_0, 0, 0xff, 0),
+	SOC_SINGLE("E3 Co-efficient 1", 	AK4671_E3_1, 0, 0xff, 0),
+	SOC_SINGLE("E3 Co-efficient 2", 	AK4671_E3_2, 0, 0xff, 0),
+	SOC_SINGLE("E3 Co-efficient 3", 	AK4671_E3_3, 0, 0xff, 0),
+	SOC_SINGLE("E3 Co-efficient 4", 	AK4671_E3_4, 0, 0xff, 0),
+	SOC_SINGLE("E3 Co-efficient 5", 	AK4671_E3_5, 0, 0xff, 0),
+	SOC_SINGLE("E4 Co-efficient 0", 	AK4671_E4_0, 0, 0xff, 0),
+	SOC_SINGLE("E4 Co-efficient 1", 	AK4671_E4_1, 0, 0xff, 0),
+	SOC_SINGLE("E4 Co-efficient 2", 	AK4671_E4_2, 0, 0xff, 0),
+	SOC_SINGLE("E4 Co-efficient 3", 	AK4671_E4_3, 0, 0xff, 0),
+	SOC_SINGLE("E4 Co-efficient 4", 	AK4671_E4_4, 0, 0xff, 0),
+	SOC_SINGLE("E4 Co-efficient 5", 	AK4671_E4_5, 0, 0xff, 0),
+	SOC_SINGLE("E5 Co-efficient 0", 	AK4671_E5_0, 0, 0xff, 0),
+	SOC_SINGLE("E5 Co-efficient 1", 	AK4671_E5_1, 0, 0xff, 0),
+	SOC_SINGLE("E5 Co-efficient 2", 	AK4671_E5_2, 0, 0xff, 0),
+	SOC_SINGLE("E5 Co-efficient 3", 	AK4671_E5_3, 0, 0xff, 0),
+	SOC_SINGLE("E5 Co-efficient 4", 	AK4671_E5_4, 0, 0xff, 0),
+	SOC_SINGLE("E5 Co-efficient 5", 	AK4671_E5_5, 0, 0xff, 0),
+#endif
+};
+
+/* add non dapm controls */
+static int ak4671_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(ak4671_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&ak4671_snd_controls[i], codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static int ak4671_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+	int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct ak4671_priv *ak4671 = codec->private_data;
+
+	if (ak4671->sysclk != freq) {
+		set_sample_rate(codec, freq);
+		ak4671->sysclk = freq;
+	}
+
+	return 0;
+}
+
+static int ak4671_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+#if 0
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct ak4671_priv *ak4671 = codec->private_data;
+	u8 mode2 = ak4671_read_reg_cache(codec, AK4671_MODE2) & ~(0x3 << 5);
+	int rate = params_rate(params), fs = 256;
+
+	if (rate)
+		fs = ak4671->sysclk / rate;
+
+	/* set fs */
+	switch (fs) {
+	case 1024:
+		mode2 |= (0x2 << 5);
+		break;
+	case 512:
+		mode2 |= (0x1 << 5);
+		break;
+	case 256:
+		break;
+	}
+
+	/* set rate */
+	ak4671_write(codec, ak4671_mode2, mode2);
+#endif
+	return 0;
+}
+
+static int ak4671_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u8 mode1 = 0;
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		mode1 = 0x03;
+		break;
+	default:
+		printk("!! invalid interface format !!\n");
+		return -EINVAL;
+	}
+
+	ak4671_write(codec, AK4671_FORMAT, mode1);
+
+	return 0;
+}
+
+static int ak4671_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	P("mute %d", mute);
+
+	if(ak4671_path == MM_AUDIO_VOICECALL_BT)
+		return 0;
+
+	u16 mute_reg = ak4671_read_reg_cache(codec, AK4671_MODE_CONTROL2) & 0xfffb;
+	if (!mute)
+		ak4671_write(codec, AK4671_MODE_CONTROL2, mute_reg | 1);
+	else
+		ak4671_write(codec, AK4671_MODE_CONTROL2, mute_reg | 0x4 | 1);
+	
+	return 0;
+}
+
+static int ak4671_set_bias_level(struct snd_soc_codec *codec,
+	enum snd_soc_bias_level level)
+{
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		break;
+	case SND_SOC_BIAS_OFF:
+		break;
+	}
+	codec->bias_level = level;
+	return 0;
+}
+
+#define AK4671_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+		SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\
+		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
+
+struct snd_soc_dai ak4671_dai = {
+	.name = "AK4671",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = AK4671_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = AK4671_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = {
+		.hw_params = ak4671_hw_params,
+		.set_fmt = ak4671_set_dai_fmt,
+		.digital_mute = ak4671_mute,
+		.set_sysclk = ak4671_set_dai_sysclk,
+	},
+};
+EXPORT_SYMBOL_GPL(ak4671_dai);
+
+static int ak4671_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	P("");
+
+	ak4671_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	if ( (ak4671_path & 0xf0) != MM_AUDIO_VOICECALL && (ak4671_path & 0xf0) != MM_AUDIO_VOICEMEMO ) 
+	{
+		path_disable(codec, ak4671_path);
+
+		/* AUDIO_EN & MAX8906_AMP_EN Disable */
+		amp_enable(0); /* Board Specific function */
+		audio_power(0); /* Board Specific function */
+		//mic_enable(0); /* Board Specific function */
+		ak4671_power = 0;
+		ak4671_idle_mode = IDLE_POWER_DOWN_MODE_ON;
+	}
+
+	return 0;
+}
+
+static int ak4671_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	P("");
+
+	ak4671_sync(codec);
+	ak4671_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	ak4671_set_bias_level(codec, codec->suspend_bias_level);
+
+#if 0
+	if ( (ak4671_path & 0xf0) != MM_AUDIO_VOICECALL && (ak4671_path & 0xf0) != MM_AUDIO_VOICEMEMO )
+	{
+		set_registers(codec, ak4671_path);
+	}
+#endif
+
+	return 0;
+}
+
+/*
+ * initialise the AK4671 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int ak4671_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	memcpy(ak4671_reg_default, ak4671_reg, sizeof(ak4671_reg)); // copy ak4671 default register
+
+	codec->name = "AK4671";
+	codec->owner = THIS_MODULE;
+	codec->read = ak4671_read_reg_cache;
+	codec->write = ak4671_write;
+	codec->set_bias_level = ak4671_set_bias_level;
+	codec->dai = &ak4671_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = ARRAY_SIZE(ak4671_reg);
+	codec->reg_cache = kmemdup(ak4671_reg, sizeof(ak4671_reg), GFP_KERNEL);
+
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		printk(KERN_ERR "ak4671: failed to create pcms\n");
+		goto pcm_err;
+	}
+
+	/* power on device */
+	ak4671_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	ak4671_add_controls(codec);
+	ret = snd_soc_init_card(socdev);
+	if (ret < 0) {
+		printk(KERN_ERR "ak4671: failed to register card\n");
+		goto card_err;
+	}
+
+	return ret;
+
+card_err:
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+pcm_err:
+	kfree(codec->reg_cache);
+
+	return ret;
+}
+
+static struct snd_soc_device *ak4671_socdev;
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+
+#define I2C_DRIVERID_AK4671 0xfefe /* liam -  need a proper id */
+
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver ak4671_i2c_driver;
+static struct i2c_client ak4671_client;
+
+static unsigned short ak4671_normal_i2c[] = { 0x24 >> 1, I2C_CLIENT_END };
+static unsigned short ak4671_ignore[] = { 1, 0x24 >> 1, I2C_CLIENT_END };
+static unsigned short ak4671_i2c_probe[] = { I2C_CLIENT_END };
+
+static struct i2c_client_address_data ak4671_addr_data = {
+	.normal_i2c = ak4671_normal_i2c,
+	.ignore     = ak4671_ignore,
+	.probe      = ak4671_i2c_probe,
+};
+
+static void amp_path_control(int mode)
+{
+	int amp_path;
+	/* SPK <- HP */
+	if((mode & 0xf) == MM_AUDIO_OUT_SPK)
+	{
+		amp_path = AK4671_AMP_PATH_SPK;
+	}
+
+	/* SPK -> HP */
+	if((mode & 0xf) == MM_AUDIO_OUT_HP)
+	{ 
+		amp_path = AK4671_AMP_PATH_HP;
+	}
+
+	/* SPK & HP */
+	if(((mode & 0xf) == MM_AUDIO_OUT_SPK_HP) || ((mode & 0xf) == MM_AUDIO_OUT_RING_SPK_HP))
+	{ 
+		amp_path = AK4671_AMP_PATH_SPK_HP;
+	}
+
+	if((mode & 0xf0) == MM_AUDIO_VOICEMEMO)
+	{
+		if((mode & 0xf) == MM_AUDIO_OUT_HP)
+			amp_path = AK4671_AMP_PATH_HP;
+		else
+			amp_path = AK4671_AMP_PATH_SPK;
+	}
+
+	if (ak4671_amp_path != amp_path && ak4671_path != mode) 
+	{
+		amp_set_path(amp_path);
+		ak4671_amp_path = amp_path;
+	} 
+}
+
+static int set_registers(struct snd_soc_codec *codec, int mode)
+{
+	P1("Set Audio PATH : 0x%02x\n", mode);
+	path_disable(codec, ak4671_path);
+
+	/* voice call rec MODE off */
+	if (ak4671_voice_call_rec_mode != 0)
+		ak4671_voice_call_rec_mode = 0; 
+
+	amp_path_control(mode);
+
+	if (ak4671_power == 0) {
+		audio_power(1); /* Board Specific function */
+		ak4671_power = 1;
+	}
+
+	path_enable(codec, mode);
+
+	ak4671_idle_mode = IDLE_POWER_DOWN_MODE_OFF; // IDLE Mode reset (off)
+	ak4671_path = mode;
+
+	return 0;
+}
+
+/* sysfs control */
+int hex2dec(u8 ch)
+{
+	if(ch >= '0' && ch <= '9')
+		return ch - '0';
+	else if(ch >= 'a' && ch <= 'f')
+		return ch - 'a' + 10;
+	else if(ch >= 'A' && ch <= 'F')
+		return ch - 'A' + 10;
+	return -1;
+}
+
+static ssize_t ak4671_control_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	u8 i;
+	struct snd_soc_device *socdev = dev_get_drvdata(dev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	sprintf(buf, "\nMODE:%d\r\n", ak4671_path);
+	for (i = 0; i < AK4671_CACHEREGNUM; i++) {
+		if( i < 0x1E || i > 0x4f )
+			sprintf(buf, "%s[0x%02x] = 0x%02x\r\n", buf, i, ak4671_read(codec, i));
+		if( i == 0x30 )
+			sprintf(buf, "%s[0x%02x] = 0x%02x\r\n", buf, i, ak4671_read(codec, i));
+		//printk("ak4671_reg[%02x] = 0x%02x\n", i, ak4671_reg[i]);
+	}
+	sprintf(buf, "%sAMP Register : ", buf);
+	amp_register_string(buf);
+
+	return sprintf(buf, "%s[AK4671] register read done.\r\n", buf);
+}
+
+static ssize_t ak4671_control_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	u8 reg, value = 0;
+	int ret = 0;
+	struct snd_soc_device *socdev = dev_get_drvdata(dev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	printk("echo [REGISTER NUMBER(HEX)][VALUE(HEX)] > ak4671_control\n");
+	printk("ex) echo 030f > ak4671_control\n");
+
+	P("buf = %s", buf);
+	P("buf size = %d", sizeof(buf));
+	P("buf size = %d", strlen(buf));
+
+	if(sizeof(buf) != 4) {
+		printk("input error\n");
+		printk("store ex) echo 030f\n");
+		return -1;
+	}
+
+	ret = hex2dec(buf[0]);
+	if (ret == -1) {
+		printk("store error.\n");
+		return -1;
+	}
+	reg = ret << 4;
+
+	ret = hex2dec(buf[1]);
+	if (ret == -1) {
+		printk("store error.\n");
+		return -1;
+	}
+	reg |= (ret & 0xf);
+
+	ret = hex2dec(buf[2]);
+	if (ret == -1) {
+		printk("store error.\n");
+		return -1;
+	}
+	value = ret << 4;
+
+	ret = hex2dec(buf[3]);
+	if (ret == -1) {
+		printk("store error.\n");
+		return -1;
+	}
+	value |= (ret & 0xf);
+
+	if (reg == 0xf1) { // path control
+		set_registers(codec, value);
+	} else if (reg >= 0xe0 && reg <= 0xe5)
+		amp_set_register(reg - 0xe0, value);
+	else
+		ak4671_write(codec, reg, value);
+	printk("Set  : reg = 0x%02x, value = 0x%02x\n", reg, value);
+	printk("Read : reg = 0x%02x, value = 0x%02x\n", reg, ak4671_read(codec, reg));
+
+	return size;
+}
+static DEVICE_ATTR(ak4671_control, S_IRUGO | S_IWUSR, ak4671_control_show, ak4671_control_store);
+
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+static int ak4671_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = ak4671_socdev;
+	struct ak4671_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+	ak4671_client.adapter = adap;
+	ak4671_client.addr = addr;
+
+	i2c = kmemdup(&ak4671_client, sizeof(ak4671_client), GFP_KERNEL);
+	if (i2c == NULL)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, codec);
+	codec->control_data = i2c;
+
+	ret = i2c_attach_client(i2c);
+	if (ret < 0) {
+		printk(KERN_ERR "failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = ak4671_init(socdev);
+	if (ret < 0) {
+		printk(KERN_ERR "failed to initialise AK4671\n");
+		goto err;
+	}
+
+	set_registers(codec, MM_AUDIO_PLAYBACK_SPK);
+
+#if 0 // i2c test
+	p("---> 0x01 = 0x%02x\n", ak4671_read(codec, 0x01)); 	
+	ak4671_write(codec, 0x01, 0x78); 	
+	P("---> 0x01 = 0x%02x\n", ak4671_read(codec, 0x01)); 	
+
+	P("---> 0x02 = 0x%02x\n", ak4671_read(codec, 0x02)); 	
+	ak4671_write(codec, 0x02, 0x01); 
+	P("---> 0x02 = 0x%02x\n", ak4671_read(codec, 0x02)); 	
+
+	P("---> 0x03 = 0x%02x\n", ak4671_read(codec, 0x03)); 	
+	ak4671_write(codec, 0x03, 0x03);
+	P("---> 0x03 = 0x%02x\n", ak4671_read(codec, 0x03)); 	
+#endif
+
+	return ret;
+
+err:
+	kfree(i2c);
+	return ret;
+}
+
+static int ak4671_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+
+	i2c_detach_client(client);
+	kfree(codec->reg_cache);
+	kfree(client);
+	return 0;
+}
+
+static int ak4671_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &ak4671_addr_data, ak4671_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver ak4671_i2c_driver = {
+	.driver = {
+		.name = "AK4671 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_AK4671,
+	.attach_adapter = ak4671_i2c_attach,
+	.detach_client =  ak4671_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client ak4671_client = {
+	.name =   "AK4671",
+	.driver = &ak4671_i2c_driver,
+};
+#endif
+
+static int ak4671_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct ak4671_setup_data *setup;
+	struct snd_soc_codec *codec;
+	struct ak4671_priv *ak4671;
+	int ret = 0;
+
+	printk(KERN_INFO "AK4671 Audio Codec %s\n", AK4671_VERSION);
+
+	/* Board Specific function */
+	audio_init();
+	if (amp_init() < 0)
+		printk("amp init failed.\n");
+	audio_power(1);
+	ak4671_power = 1;
+	amp_set_path(AK4671_AMP_PATH_SPK);
+	mic_set_path(AK4671_MIC_PATH_MAIN);
+
+	ret = device_create_file(&pdev->dev, &dev_attr_ak4671_control);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+	{
+		printk("[sound]snd_soc_codec create fail\n");
+		return -ENOMEM;
+	}
+
+	ak4671 = kzalloc(sizeof(struct ak4671_priv), GFP_KERNEL);
+	if (ak4671 == NULL) {
+		printk("[sound]ak4671_priv create fail\n");
+		kfree(codec);
+		return -ENOMEM;
+	}
+
+	codec->private_data = ak4671;
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	ak4671_socdev = socdev;
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		codec->hw_read = (hw_read_t)i2c_master_recv;
+		ret = i2c_add_driver(&ak4671_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
+	}
+#else
+	/* Add other interfaces here */
+#endif
+
+	if (ret != 0) {
+		printk("[sound] sound device create file fail\n");
+		kfree(codec->private_data);
+		kfree(codec);
+	}
+	return ret;
+}
+
+/* power down chip */
+static int ak4671_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		ak4671_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	i2c_del_driver(&ak4671_i2c_driver);
+#endif
+	kfree(codec->private_data);
+	kfree(codec);
+
+	return 0;
+}
+
+/* power down chip */
+static int ak4671_shutdown(struct platform_device *pdev)
+{
+	P1(" ");
+
+	amp_enable(0);
+	
+	return 0;
+}
+
+
+struct snd_soc_codec_device soc_codec_dev_ak4671 = {
+	.probe = 	ak4671_probe,
+	.remove = 	ak4671_remove,
+	.suspend = 	ak4671_suspend,
+	.resume =	ak4671_resume,
+	.shutdown =	ak4671_shutdown,
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_ak4671);
+
+static int __init ak4671_codec_init(void)
+{
+	return snd_soc_register_dai(&ak4671_dai);	
+}
+module_init(ak4671_codec_init);
+
+static void __exit ak4671_codec_exit(void)
+{
+	snd_soc_unregister_dai(&ak4671_dai);
+}
+module_exit(ak4671_codec_exit);
+
+MODULE_DESCRIPTION("Soc AK4671 driver");
+MODULE_AUTHOR("Richard Purdie");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/codecs/ak4671.h linux-2.6.29-spica/sound/soc/codecs/ak4671.h
--- linux-2.6.29/sound/soc/codecs/ak4671.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/codecs/ak4671.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,216 @@
+/*
+ * ak4535.h  --  AK4535 Soc Audio driver
+ *
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on wm8753.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <sound/soc.h>
+
+#ifndef _AK4671_H
+#define _AK4671_H
+
+/* AK4671 Path */
+#define MM_AUDIO_OUT_RCV 			0x01
+#define MM_AUDIO_OUT_SPK 			0x02
+#define MM_AUDIO_OUT_HP 			0x03
+#define MM_AUDIO_OUT_BT 			0x04
+#define MM_AUDIO_OUT_SPK_HP			0x05
+#define MM_AUDIO_OUT_RING_SPK_HP	0x06
+#define MM_AUDIO_PLAYBACK			0x00
+#define MM_AUDIO_PLAYBACK_RCV 		0x01
+#define MM_AUDIO_PLAYBACK_SPK 		0x02
+#define MM_AUDIO_PLAYBACK_HP 		0x03
+#define MM_AUDIO_PLAYBACK_BT 		0x04
+#define MM_AUDIO_PLAYBACK_SPK_HP	0x05
+#define MM_AUDIO_PLAYBACK_RING_SPK_HP	0x06
+#define MM_AUDIO_VOICECALL	 		0x10
+#define MM_AUDIO_VOICECALL_RCV 		0x11
+#define MM_AUDIO_VOICECALL_SPK 		0x12
+#define MM_AUDIO_VOICECALL_HP 		0x13
+#define MM_AUDIO_VOICECALL_BT 		0x14
+#define MM_AUDIO_VOICECALL_SPK_LOOP 	0x15
+#define MM_AUDIO_VOICEMEMO	 		0x20
+#define MM_AUDIO_VOICEMEMO_MAIN		0x21
+#define MM_AUDIO_VOICEMEMO_SUB 		0x22
+#define MM_AUDIO_VOICEMEMO_EAR 		0x23
+#define MM_AUDIO_VOICEMEMO_BT 		0x24
+#define MM_AUDIO_FMRADIO	 		0x30
+#define MM_AUDIO_FMRADIO_RCV		0x31
+#define MM_AUDIO_FMRADIO_SPK 		0x32
+#define MM_AUDIO_FMRADIO_HP 		0x33
+#define MM_AUDIO_FMRADIO_BT 		0x34
+#define MM_AUDIO_FMRADIO_SPK_HP      0x35
+
+#define AK4671_PATH_CHANGE	 		0xf1
+
+#define IDLE_POWER_DOWN_MODE_OFF		0
+#define IDLE_POWER_DOWN_MODE_ON		1
+
+/* AK4671 register space */
+#define AK4671_PM					0x00
+#define AK4671_PLL_MODE0			0x01
+#define AK4671_PLL_MODE1			0x02
+#define AK4671_FORMAT				0x03
+#define AK4671_MIC_SELECT			0x04
+#define AK4671_MIC_GAIN				0x05
+#define AK4671_MIXING_PM0			0x06
+#define AK4671_MIXING_PM1			0x07
+#define AK4671_OUTPUT_VOL			0x08
+#define AK4671_LOUT1_SELECT			0x09
+#define AK4671_ROUT1_SELECT			0x0A
+#define AK4671_LOUT2_SELECT			0x0B
+#define AK4671_ROUT2_SELECT			0x0C
+#define AK4671_LOUT3_SELECT			0x0D
+#define AK4671_ROUT3_SELECT			0x0E
+#define AK4671_LOUT1_PM				0x0F
+#define AK4671_LOUT2_PM				0x10
+#define AK4671_LOUT3_PM				0x11
+#define AK4671_L_INPUT_VOL			0x12
+#define AK4671_R_INPUT_VOL			0x13
+#define AK4671_ALC_REF_SELECT		0x14
+#define AK4671_DIGITAL_MIXING		0x15
+#define AK4671_ALC_TIMER_SELECT		0x16
+#define AK4671_ALC_MODE_CONTROL		0x17
+#define AK4671_MODE_CONTROL1		0x18
+#define AK4671_MODE_CONTROL2		0x19
+#define AK4671_L_OUTPUT_VOL			0x1A
+#define AK4671_R_OUTPUT_VOL			0x1B
+#define AK4671_SIDE_TONE_A			0x1C
+#define AK4671_DIGITAL_FILTER		0x1D
+#define AK4671_FIL3_0				0x1E
+#define AK4671_FIL3_1				0x1F
+#define AK4671_FIL3_2				0x20
+#define AK4671_FIL3_3				0x21
+#define AK4671_EQ_0					0x22
+#define AK4671_EQ_1					0x23
+#define AK4671_EQ_2					0x24
+#define AK4671_EQ_3					0x25
+#define AK4671_EQ_4					0x26
+#define AK4671_EQ_5					0x27
+#define AK4671_FIL1_0				0x28
+#define AK4671_FIL1_1				0x29
+#define AK4671_FIL1_2				0x2A
+#define AK4671_FIL1_3				0x2B
+#define AK4671_FIL2_0				0x2C
+#define AK4671_FIL2_1				0x2D
+#define AK4671_FIL2_2				0x2E
+#define AK4671_FIL2_3				0x2F
+#define AK4671_DIGITAL_FILTER2		0x30
+#define AK4671_E1_0					0x32
+#define AK4671_E1_1					0x33
+#define AK4671_E1_2					0x34
+#define AK4671_E1_3					0x35
+#define AK4671_E1_4					0x36
+#define AK4671_E1_5					0x37
+#define AK4671_E2_0					0x38
+#define AK4671_E2_1					0x39
+#define AK4671_E2_2					0x3A
+#define AK4671_E2_3					0x3B
+#define AK4671_E2_4					0x3C
+#define AK4671_E2_5					0x3D
+#define AK4671_E3_0					0x3E
+#define AK4671_E3_1					0x3F
+#define AK4671_E3_2					0x40
+#define AK4671_E3_3					0x41
+#define AK4671_E3_4					0x42
+#define AK4671_E3_5					0x43
+#define AK4671_E4_0					0x44
+#define AK4671_E4_1					0x45
+#define AK4671_E4_2					0x46
+#define AK4671_E4_3					0x47
+#define AK4671_E4_4					0x48
+#define AK4671_E4_5					0x49
+#define AK4671_E5_0					0x4A
+#define AK4671_E5_1					0x4B
+#define AK4671_E5_2					0x4C
+#define AK4671_E5_3					0x4D
+#define AK4671_E5_4					0x4E
+#define AK4671_E5_5					0x4F
+#define AK4671_EQ_CONTROL1			0x50
+#define AK4671_EQ_CONTROL2			0x51
+#define AK4671_EQ_CONTROL3			0x52
+#define AK4671_PCM_CONTROL0			0x53
+#define AK4671_PCM_CONTROL1			0x54
+#define AK4671_PCM_CONTROL2			0x55
+#define AK4671_DIGITAL_VOL_B		0x56
+#define AK4671_DIGITAL_VOL_C		0x57
+#define AK4671_SIDE_TONE_VOL		0x58
+#define AK4671_DIGITAL_MIXING2		0x59
+#define AK4671_SAR_ADC				0x5A
+
+#define AK4671_CACHEREGNUM 	0x5B
+
+#define AK4535_PM1		0x0
+#define AK4535_PM2		0x1
+#define AK4535_SIG1		0x2
+#define AK4535_SIG2		0x3
+#define AK4535_MODE1		0x4
+#define AK4535_MODE2		0x5
+#define AK4535_DAC		0x6
+#define AK4535_MIC		0x7
+#define AK4535_TIMER		0x8
+#define AK4535_ALC1		0x9
+#define AK4535_ALC2		0xa
+#define AK4535_PGA		0xb
+#define AK4535_LATT		0xc
+#define AK4535_RATT		0xd
+#define AK4535_VOL		0xe
+#define AK4535_STATUS		0xf
+
+#define AK4535_CACHEREGNUM 	0x10
+
+
+/* 1 : Speaker
+ * 2 : Earjack */
+#define AK4671_AMP_PATH_SPK				1
+#define AK4671_AMP_PATH_HP				2
+#define AK4671_AMP_PATH_SPK_HP			3
+
+/* 0 : MAIN
+ * 1 : SUB */
+#define AK4671_MIC_PATH_MAIN			0
+#define AK4671_MIC_PATH_SUB				1
+
+struct ak4671_setup_data {
+	unsigned short i2c_address;
+};
+
+/* codec private data */
+struct ak4671_priv {
+	unsigned int sysclk;
+	unsigned int bitrate;
+};
+
+extern struct snd_soc_dai ak4671_dai;
+extern struct snd_soc_codec_device soc_codec_dev_ak4671;
+
+/* Board specific function */
+extern int voice_call_auto_response_disable(struct snd_soc_codec *, int);
+extern int voice_call_auto_response_enable(struct snd_soc_codec *, int);
+extern int audio_init(void);
+extern int audio_power(int);
+extern int amp_init(void);
+extern int amp_enable(int);
+extern int amp_set_path(int);
+extern int amp_get_path(int);
+extern int amp_register_string(char *);
+extern int amp_set_register(unsigned char, unsigned char);
+extern int mic_enable(int);
+extern int mic_set_path(int);
+extern int path_enable(struct snd_soc_codec *, int);
+extern int path_disable(struct snd_soc_codec *, int);
+extern int set_sample_rate(struct snd_soc_codec *, int);
+extern int idle_mode_enable(struct snd_soc_codec *, int);
+extern int idle_mode_disable(struct snd_soc_codec *, int);
+extern int voice_call_rec_enable(struct snd_soc_codec *, int);
+extern int voice_call_rec_disable(struct snd_soc_codec *, int);
+
+
+#endif
diff -Nur linux-2.6.29/sound/soc/codecs/ak4671_spica.c linux-2.6.29-spica/sound/soc/codecs/ak4671_spica.c
--- linux-2.6.29/sound/soc/codecs/ak4671_spica.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/codecs/ak4671_spica.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,1203 @@
+/*
+ * ak4671_spica.c  --  AK4671 Spica Board specific code
+ *
+ * Copyright (C) 2008 Samsung Electronics, Seung-Bum Kang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/switch.h>
+#include <linux/platform_device.h>
+#include <linux/switch.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/input.h>
+
+#include <plat/egpio.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <mach/hardware.h>
+
+#include <sound/soc.h>
+
+#include "ak4671.h"
+#include "max9877_def.h"
+
+//#define AUDIO_SPECIFIC_DEBUG	1
+//#define MAX9877_SPECIFIC_DEBUG  1
+#define SUBJECT "ak4671_spica.c"
+
+#define P1(format,...)\
+	printk ("["SUBJECT "(%d)] " format "\n", __LINE__, ## __VA_ARGS__);
+
+#if AUDIO_SPECIFIC_DEBUG
+#define P(format,...)\
+	printk ("[ "SUBJECT " (%s,%d) ] " format "\n", __func__, __LINE__, ## __VA_ARGS__);
+#define FI \
+	printk ("[ "SUBJECT " (%s,%d) ] " "%s - IN" "\n", __func__, __LINE__, __func__);
+#define FO \
+	printk ("[ "SUBJECT " (%s,%d) ] " "%s - OUT" "\n", __func__, __LINE__, __func__);
+#else
+#define P(format,...)
+#define FI 
+#define FO 
+#endif
+
+#define AK4671_PLL 			0x08   // 19.2MHz
+#define MAX9877_ADDRESS 	0x9A
+
+static unsigned short reg_pll_mode = 0xf0 | AK4671_PLL; // Default setting : 44.1kHz, 19.2MHz
+static unsigned int sub_mic_path;
+static unsigned int cur_amp_path;
+
+static unsigned short max9877_normal_i2c[] = { I2C_CLIENT_END };
+static unsigned short max9877_ignore[] = { I2C_CLIENT_END };
+static unsigned short max9877_i2c_probe[] = { 5, MAX9877_ADDRESS >> 1, I2C_CLIENT_END };
+
+static struct i2c_driver max9877_i2c_driver;
+static struct i2c_client max9877_i2c_client;
+
+static struct i2c_client_address_data max9877_addr_data = {
+	.normal_i2c = max9877_normal_i2c,
+	.ignore     = max9877_ignore,
+	.probe      = max9877_i2c_probe,
+};
+
+
+short int get_headset_status();//import from arc/arm/s3c6410/sec_headset.c
+
+static int max9877_read(struct i2c_client *client, u8 reg, u8 *data)
+{
+	int ret;
+	u8 buf[1];
+	struct i2c_msg msg[2];
+
+	buf[0] = reg; 
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret != 2) 
+		return -EIO;
+
+	*data = buf[0];
+	
+	return 0;
+}
+
+static int max9877_write(struct i2c_client *client, u8 reg, u8 data)
+{
+	int ret;
+	u8 buf[2];
+	struct i2c_msg msg[1];
+
+	buf[0] = reg;
+	buf[1] = data;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 2;
+	msg[0].buf = buf;
+
+	ret = i2c_transfer(client->adapter, msg, 1);
+	if (ret != 1) 
+		return -EIO;
+
+	return 0;
+}
+
+static int max9877_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	int ret;
+#if MAX9877_SPECIFIC_DEBUG
+	u8 pData = 0, i;
+#endif
+
+//	FI
+	max9877_i2c_client.adapter = adap;
+	max9877_i2c_client.addr = addr;
+
+	ret = i2c_attach_client(&max9877_i2c_client);
+	if (ret < 0) {
+		printk("failed to attach max9877 at addr %x\n", addr);
+		return -1;
+	}
+
+	max9877_write(&max9877_i2c_client, MAX9877_SPEAKER_VOLUME, KMAX9877_Output_Gain_0ToMinus7(0)); 
+	max9877_write(&max9877_i2c_client, MAX9877_LEFT_HEADPHONE_VOLUME, KMAX9877_Output_Gain_0ToMinus7(0));
+	max9877_write(&max9877_i2c_client, MAX9877_RIGHT_HEADPHONE_VOLUME, KMAX9877_Output_Gain_0ToMinus7(0));
+	max9877_write(&max9877_i2c_client, MAX9877_OUTPUT_MODE_CONTROL, 
+		SHDN |  /* Operational mode  */
+		(BYPASS & (~BYPASS)) | /* Bypass mode disabled */
+		(OSC0 & (~OSC0))	 | /* Class D : 1176, CHARGE-PUMP : 588  */
+		(OUTMODE0|OUTMODE3)); 	/* SPK:INA1+INA2+INB1+INB2, LHP:INA1+INB2, RHP:INA2+INB2 */
+
+
+#if MAX9877_SPECIFIC_DEBUG
+	/* real all */
+    for(i = 0; i <= MAX9877_OUTPUT_MODE_CONTROL; i++) {
+		max9877_read(&max9877_i2c_client, i, &pData);
+		P("MAX9877 REG - 0x%02x : 0x%02x", i, pData);
+	}
+#endif
+
+	return 0;
+}
+
+static int max9877_i2c_attach(struct i2c_adapter *adap)
+{
+//   	FI
+	return i2c_probe(adap, &max9877_addr_data, max9877_codec_probe);
+}
+
+static int max9877_i2c_detach(struct i2c_client *client)
+{
+ //	FI
+	i2c_detach_client(client);
+	return 0;
+}
+
+static struct i2c_driver max9877_i2c_driver = {
+	.driver = {
+		.name = "MAX9877 I2C (AMP)",
+		.owner = THIS_MODULE,
+	},
+	.id =             1,
+	.attach_adapter = max9877_i2c_attach,
+	.detach_client =  max9877_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client max9877_i2c_client = {
+	.name =   "max9877",
+	.driver = &max9877_i2c_driver,
+};
+
+int audio_init(void)
+{
+	/* AUDIO_EN */
+	if (gpio_is_valid(GPIO_AUDIO_EN)) {
+		if (gpio_request(GPIO_AUDIO_EN, S3C_GPIO_LAVEL(GPIO_AUDIO_EN))) 
+			printk(KERN_ERR "Failed to request GPIO_AUDIO_EN! \n");
+		gpio_direction_output(GPIO_AUDIO_EN, 0);
+	}
+	s3c_gpio_setpull(GPIO_AUDIO_EN, S3C_GPIO_PULL_NONE);
+
+	/* MICBIAS_EN */
+	if (gpio_is_valid(GPIO_MICBIAS_EN)) {
+		if (gpio_request(GPIO_MICBIAS_EN, S3C_GPIO_LAVEL(GPIO_MICBIAS_EN))) 
+			printk(KERN_ERR "Failed to request GPIO_MICBIAS_EN! \n");
+		gpio_direction_output(GPIO_MICBIAS_EN, 0);
+	}
+	s3c_gpio_setpull(GPIO_MICBIAS_EN, S3C_GPIO_PULL_NONE);
+
+	return 0;
+}
+
+int audio_power(int en)
+{
+	P("AUDIO POWER : %d", en);
+	if (en)
+		gpio_set_value(GPIO_AUDIO_EN, 1);
+	else
+		gpio_set_value(GPIO_AUDIO_EN, 0);
+
+	return 0;
+}
+
+int amp_init(void)
+{
+	int ret;
+
+//	FI
+
+	ret = i2c_add_driver(&max9877_i2c_driver);
+	if (ret != 0)
+		printk(KERN_ERR "can't add i2c driver");
+
+//	FO
+	return ret;
+}
+
+int amp_enable(int en)
+{
+        u8 pData = 0;
+
+        P("AMP EN : %d", en);
+        max9877_read(&max9877_i2c_client, MAX9877_OUTPUT_MODE_CONTROL, &pData);
+
+        if (en){
+                max9877_write(&max9877_i2c_client, MAX9877_SPEAKER_VOLUME, 0);
+                max9877_write(&max9877_i2c_client, MAX9877_LEFT_HEADPHONE_VOLUME,0);
+                max9877_write(&max9877_i2c_client, MAX9877_RIGHT_HEADPHONE_VOLUME,0);
+
+                max9877_write(&max9877_i2c_client, MAX9877_OUTPUT_MODE_CONTROL, pData | SHDN ); /* Low Power shutdown mode : 1 */
+                mdelay(30);
+
+                if (cur_amp_path == AK4671_AMP_PATH_SPK_HP)
+                {/*when ringtone earphone level under 100db for ear : HW require  */
+                     max9877_write(&max9877_i2c_client, MAX9877_SPEAKER_VOLUME, 31);
+                     max9877_write(&max9877_i2c_client, MAX9877_LEFT_HEADPHONE_VOLUME,0x11);
+                     max9877_write(&max9877_i2c_client, MAX9877_RIGHT_HEADPHONE_VOLUME,0x11);
+                }
+                else if (cur_amp_path == AK4671_AMP_PATH_HP)
+                {
+                     max9877_write(&max9877_i2c_client, MAX9877_SPEAKER_VOLUME, 0);
+                     max9877_write(&max9877_i2c_client, MAX9877_LEFT_HEADPHONE_VOLUME,31);
+                     max9877_write(&max9877_i2c_client, MAX9877_RIGHT_HEADPHONE_VOLUME,31);
+                }
+                else if (cur_amp_path == AK4671_AMP_PATH_SPK)
+                {
+                     max9877_write(&max9877_i2c_client, MAX9877_SPEAKER_VOLUME, 31);
+                     max9877_write(&max9877_i2c_client, MAX9877_LEFT_HEADPHONE_VOLUME,0);
+                     max9877_write(&max9877_i2c_client, MAX9877_RIGHT_HEADPHONE_VOLUME,0);
+                }
+
+        }else{
+                max9877_write(&max9877_i2c_client, MAX9877_SPEAKER_VOLUME, 0);
+                max9877_write(&max9877_i2c_client, MAX9877_LEFT_HEADPHONE_VOLUME,0);
+                max9877_write(&max9877_i2c_client, MAX9877_RIGHT_HEADPHONE_VOLUME,0);
+
+                mdelay(30);
+                max9877_write(&max9877_i2c_client, MAX9877_OUTPUT_MODE_CONTROL, pData & ~SHDN ); /* Low Power shutdown mode : 0 */
+
+        }
+        return 0;
+}
+
+int amp_set_path(int path)
+{
+	int i; 
+	
+#if MAX9877_SPECIFIC_DEBUG
+	u8 pData;
+	/* real all */
+    for(i = 0; i <= 0x4; i++) {
+		max9877_read(&max9877_i2c_client, i, &pData);
+		P("MAX9877 REG - 0x%02x : 0x%02x", i, pData);
+	}
+#endif
+
+	if (path == AK4671_AMP_PATH_SPK) {
+		P("AMP Path : SPK");
+		max9877_write(&max9877_i2c_client, MAX9877_OUTPUT_MODE_CONTROL, 
+			//SHDN |  /* Operational mode  */
+			(BYPASS & (~BYPASS)) |  /* Bypass mode disabled */
+			(OSC0 & (~OSC0))	 | /* Class D : 1176, CHARGE-PUMP : 588  */
+			(OUTMODE0) );  	/* SPK:INA1INB1 */
+	} else if (path == AK4671_AMP_PATH_HP) {
+		P("AMP Path : HP");
+			max9877_write(&max9877_i2c_client, MAX9877_OUTPUT_MODE_CONTROL, 
+			//SHDN |  /* Operational mode  */
+			(BYPASS & (~BYPASS)) |  /* Bypass mode disabled */
+			(OSC0 & (~OSC0))	 | /* Class D : 1176, CHARGE-PUMP : 588  */
+			(OUTMODE0 | OUTMODE2) );  	/* LHP:INB1, RHP:INB2 */
+	} else if (path == AK4671_AMP_PATH_SPK_HP) {
+		P("AMP Path : SPK & HP");
+			max9877_write(&max9877_i2c_client, MAX9877_OUTPUT_MODE_CONTROL, 
+			//SHDN |  /* Operational mode  */
+			(BYPASS & (~BYPASS)) |  /* Bypass mode disabled */
+			(OSC0 & (~OSC0))	 | /* Class D : 1176, CHARGE-PUMP : 588  */
+			(OUTMODE1|OUTMODE2) );  	/* SPK:INB1+INB2   LHP:INB1, RHP:INB2 */
+	}
+
+	cur_amp_path =  path ;
+
+#if MAX9877_SPECIFIC_DEBUG
+	/* real all */
+    for(i = 0; i <= MAX9877_OUTPUT_MODE_CONTROL; i++) {
+		max9877_read(&max9877_i2c_client, i, &pData);
+		P("MAX9877 REG - 0x%02x : 0x%02x", i, pData);
+	}
+#endif
+	return 0;
+}
+
+int amp_get_path(int path)
+{
+	/* TODO */
+	P("AMP SET PATH : ?");
+
+	return 0;
+}
+
+int amp_register_string(char *buf)
+{
+	int i; 
+	u8 pData;
+
+	sprintf(buf, "%s MAX9877\r\n", buf);
+    for(i = 0; i <= MAX9877_OUTPUT_MODE_CONTROL; i++) {
+		max9877_read(&max9877_i2c_client, i, &pData);
+		sprintf(buf, "%s[0x%02x] = 0x%02x\r\n", buf, i + 0xe0, pData);
+	}
+
+	return 0;
+}
+
+int amp_set_register(unsigned char reg, unsigned char val)
+{
+	P("AMP Register (Write) reg:0x%02x, val:0x%02x\n", reg, val);
+	max9877_write(&max9877_i2c_client, reg, val);
+	return 0;
+}
+
+int mic_enable(int en)
+{
+	P("MIC EN : %d", en);
+	if (en) {
+		gpio_set_value(GPIO_MICBIAS_EN, 1);
+	} else {
+		gpio_set_value(GPIO_MICBIAS_EN, 0);
+	}
+	return 0;
+}
+
+int mic_set_path(int path)
+{
+	if (path == AK4671_MIC_PATH_MAIN) { // MAIN
+		P("MIC PATH : MAIN");
+		sub_mic_path = 0x9C;		// MIC-AMP Lch=IN1+/-, IN4+/- Differential Input
+	} else { // SUB
+		P("MIC PATH : SUB");
+		sub_mic_path = 0x8D; 		// MIC-AMP Lch= LIN2, Rch= IN4+/-
+	}
+
+	return 0;
+}
+
+int set_sample_rate(struct snd_soc_codec *codec, int bitRate)
+{
+	switch(bitRate) {
+		case 8000: // Sampling 8kHz
+#ifdef CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING // sangsu fix : recording down scaling
+			reg_pll_mode = 0xf0 | AK4671_PLL;
+			break;
+#else // sangsu fix
+			reg_pll_mode = 0x00 | AK4671_PLL;
+			codec->write(codec, 0x01, 0x00 | AK4671_PLL); 	
+			break;
+#endif // sangsu fix
+		case 16000: // Sampling 16kHz
+			reg_pll_mode = 0x20 | AK4671_PLL;
+			break;
+		case 11025: // Sampling 11.025kHz
+			reg_pll_mode = 0x50 | AK4671_PLL;
+			break;
+		case 22050: // Sampling 22.05kHz
+			reg_pll_mode = 0x70 | AK4671_PLL;
+			break;
+		case 32000: // Sampling 32kHz
+			reg_pll_mode = 0xa0 | AK4671_PLL;
+			break;
+		case 44100: // Sampling 44.1kHz
+			reg_pll_mode = 0xf0 | AK4671_PLL;
+			break;
+		case 48000: // Sampling 48kHz
+			reg_pll_mode = 0xb0 | AK4671_PLL;
+			break;
+		default:
+			P("[%s] not support bit rate (%d).\n", __func__, bitRate);
+			reg_pll_mode = 0x70 | AK4671_PLL;
+			break;
+	}
+	printk("[AK4671] Set bitRate : 0x%02x (%d) \n", reg_pll_mode, bitRate);
+	codec->write(codec, 0x01, reg_pll_mode); 	
+
+	return 0;
+}
+
+/* Rx only recorded in spica */
+int voice_call_rec_enable(struct snd_soc_codec *codec, int mode)
+{
+	P1("Rec Enable (mode : 0x%x)\n", mode);
+
+	switch(mode) {
+		case MM_AUDIO_VOICECALL_RCV :
+			P("enable REC (MM_AUDIO_VOICECALL_RCV)");
+			/* MIC-AMP Rch mixing A/P Rch -> RCP/RCN OFF */
+			codec->write(codec, 0x19, 0x04); 	// use soft mute to cut signal
+			mdelay(24);
+			codec->write(codec, 0x0A, 0x00); 	//Swith-off all output
+			codec->write(codec, 0x0D, 0x00);	// Rout3 mute
+			codec->write(codec, 0x00, 0x0D); 	// DAC-Rch power-up
+
+			codec->write(codec, 0x00, 0x2D); 	// ADC-Lch power-down, Rch power up
+			mdelay(24);
+			break;
+
+		case MM_AUDIO_VOICECALL_SPK :
+		case MM_AUDIO_VOICECALL_HP :
+			P("enable REC (MM_AUDIO_VOICECALL_HP_SPK)");
+			/* MIC-AMP Rch mixing A/P Rch -> Lout2/Rout OFF */
+			codec->write(codec, 0x19, 0x04); 	// use soft mute to cut signal
+			mdelay(24);
+			codec->write(codec, 0x0B, 0x00); 	// Swith-off all output
+			codec->write(codec, 0x0C, 0x00); 	// Swith-off all output
+			codec->write(codec, 0x0D, 0x00);	// Rout3 mute
+			codec->write(codec, 0x00, 0x0D); 	// DAC-Rch power-up
+
+			/* MIC-AMP Lch->LOP/LON and ADC Lch->AP Lch */
+			codec->write(codec, 0x00, 0x2D); 	// ADC-Lch power-down, Rch power up
+			mdelay(24);
+			break;
+
+		case MM_AUDIO_VOICECALL_BT :
+			P("enable REC (MM_AUDIO_VOICECALL_BT)");
+			/* mixing ADC Rch and A/P Rch -> SRC-A -> PCM-A */
+			codec->write(codec, 0x15, 0x14); 	// 5-band-EQ-Lch: from SRC-B, Rch: from SVOLA Rch
+
+			/* SRC-B -> DAC Lch -> LOP/LON -> and -> A/P Lch */
+			//codec->write(codec, 0x59, 0x10); 	// SDTO-Lch: from SRC-B
+			codec->write(codec, 0x59, 0x00); 	// SDTO-Lch: from ADM (lch is muted), SDTO-Rch : from ADM (modem)
+			codec->write(codec, 0x53, 0x14);   // Swith-off all output
+			codec->write(codec, 0x0D, 0x00);	// Rout3 mute
+			break;
+		default :
+				printk("[%s] Invalid mode\n", __func__);
+	}
+
+	codec->write(codec, 0x18, 0x06); 	// IVOLC, ADM Mono
+
+	return 0;
+}
+
+int voice_call_rec_disable(struct snd_soc_codec *codec, int mode) 
+{
+	P1("Rec Disable (mode : 0x%x)\n", mode);
+
+	switch(mode) {
+		case MM_AUDIO_VOICECALL_RCV :
+			P("disable REC (MM_AUDIO_VOICECALL_RCV)");
+			/* MIC-AMP Lch->LOP/LON and ADC Lch->AP Lch */
+			codec->write(codec, 0x0A, 0x21); 	// only MIC-AMP-Rch to RCP/RCN	
+			codec->write(codec, 0x0D, 0x20);	
+			codec->write(codec, 0x00, 0x8D); 	// DAC-Rch power-up
+			break;
+
+		case MM_AUDIO_VOICECALL_SPK :
+		case MM_AUDIO_VOICECALL_HP :
+			P("disable REC (MM_AUDIO_VOICECALL_HP_SPK)");
+			/* MIC-AMP Lch->LOP/LON and ADC Lch->AP Lch */
+			codec->write(codec, 0x0B, 0x01); 	// Swith-off DAC-Lch
+			codec->write(codec, 0x0C, 0x21); 	// Swith-off DAC-Rch
+			codec->write(codec, 0x0D, 0x20);	
+
+			codec->write(codec, 0x00, 0xCD); 	// DAC-Rch power-up
+			break;
+
+		case MM_AUDIO_VOICECALL_BT :
+			P("disable REC (MM_AUDIO_VOICECALL_BT)");
+			/* mixing ADC Rch and A/P Rch -> SRC-A -> PCM-A */
+			codec->write(codec, 0x15, 0x18); 	// 5-band-EQ-Lch: from SRC-B, Rch: from SVOLA Rch
+			
+			/* SRC-B -> DAC Lch -> LOP/LON -> and -> A/P Lch */
+			codec->write(codec, 0x59, 0x00); 	// default
+			codec->write(codec, 0x53, 0x17); 		// PLLBT1,PMSRA/B, PMPCM power up
+			codec->write(codec, 0x0D, 0x01);
+			break;
+		
+		default :
+			printk("[%s] Invalid mode\n", __func__);
+	}
+
+	codec->write(codec, 0x18, 0x02); 	// IVOLC
+
+	return 0;
+}
+
+static void set_bias (struct snd_soc_codec *codec, int mode)
+{
+
+	/* Set MIC BIAS */
+	/* VOICECALL, VOICEMEMO, PLAYBACK_HP */
+	if ((mode & 0xf0) == MM_AUDIO_VOICECALL || 
+		(mode & 0xf0) == MM_AUDIO_VOICEMEMO )
+	{
+		if ((mode & 0x0f) == MM_AUDIO_OUT_RCV || (mode & 0x0f) == MM_AUDIO_OUT_SPK
+			|| (mode & 0x0f) == MM_AUDIO_OUT_HP ) 
+			mic_enable(1);
+	}
+	else
+	{
+		if(!get_headset_status())
+			mic_enable(0);
+	}
+
+	/* Set AMP BIAS */
+	/* SPK, EARJACK, VOICEMEMO */
+	if ((mode & 0x0f) == MM_AUDIO_OUT_SPK || 
+		(mode & 0x0f) == MM_AUDIO_OUT_HP || 
+		(mode & 0x0f) == MM_AUDIO_OUT_SPK_HP || 
+		(mode & 0xf0) == MM_AUDIO_VOICEMEMO ) 
+	{
+		if (mode != MM_AUDIO_VOICECALL_BT)
+			amp_enable(1);	
+	} 
+	else
+	{
+			amp_enable(0);	
+	}
+}
+static void set_input_path_gain(struct snd_soc_codec *codec, int mode)
+{
+	P("set INPUT path gain : 0x%x\n", mode);
+	switch(mode)
+	{
+  		case MM_AUDIO_VOICEMEMO_MAIN:		
+			codec->write(codec, 0x05, 0x5B); 	//MIC-AMP 18dB 2009.07.10
+			codec->write(codec, 0x12, 0xD9);
+			codec->write(codec, 0x13, 0xD9);
+			break;		
+  		case MM_AUDIO_VOICEMEMO_SUB:		
+			codec->write(codec, 0x05, 0x5B); 	//MIC-AMP 18dB 2009.07.10
+			codec->write(codec, 0x12, 0xD9);
+			codec->write(codec, 0x13, 0xD9);
+			break;
+  		case MM_AUDIO_VOICEMEMO_EAR:		
+			codec->write(codec, 0x05, 0x5B); 	// => MIC-AMP Gain=0dB (default)
+			codec->write(codec, 0x12, 0xC5);
+			codec->write(codec, 0x13, 0xC5);
+			break;
+		default :
+			//printk("[%s] Invalid input gain path\n", __func__);
+			break;
+	}
+}
+
+static void set_path_gain(struct snd_soc_codec *codec, int mode)
+{
+
+	set_input_path_gain(codec, mode);
+
+	/* VOICEMEMO Path : only SPK */
+    if (mode == MM_AUDIO_VOICEMEMO_MAIN ||
+            mode == MM_AUDIO_VOICEMEMO_SUB )
+            mode = MM_AUDIO_PLAYBACK_SPK;
+    else if(mode  == MM_AUDIO_VOICEMEMO_EAR)
+            mode = MM_AUDIO_PLAYBACK_HP;
+
+
+	P("SET Path gain : 0x%x\n", mode);
+
+	/* Set output tunning value */
+	switch (mode) 
+	{
+		case MM_AUDIO_PLAYBACK_RCV :
+			break;
+		case MM_AUDIO_PLAYBACK_SPK :
+		case MM_AUDIO_PLAYBACK_SPK_HP :
+			codec->write(codec, 0x08, 0x95); 	// Output Volume Control : OUT2[7:4]/OUT1[2:0]
+			codec->write(codec, 0x1A, 0x18); 	// Lch Output Digital Vol
+			codec->write(codec, 0x1B, 0x18); 	// Rch Output Digital Vol
+			break;
+		case MM_AUDIO_PLAYBACK_HP :
+			codec->write(codec, 0x08, 0xB5); 	// Output Volume Control : OUT2[7:4]/OUT1[2:0]
+			codec->write(codec, 0x1A, 0x18); 	// Lch Output Digital Vol
+			codec->write(codec, 0x1B, 0x18); 	// Rch Output Digital Vol
+			break;
+		case MM_AUDIO_VOICECALL_RCV:		
+			//RX
+			//codec->write(codec, 0x0D, 0x20);	//warring this register set in routing sequence also
+			codec->write(codec, 0x05, 0x55);
+			//codec->write(codec, 0x11, 0x10);	//warring this register set in routing sequence also
+			//TX
+			codec->write(codec, 0x08, 0xb4);
+			break;
+	 	case MM_AUDIO_VOICECALL_HP:	
+			//RX
+			//codec->write(codec, 0x0D, 0x20);	//warring 0x0D register set in routing sequence also
+			codec->write(codec, 0x05, 0x55);
+			//codec->write(codec, 0x11, 0x10);	//warring 0x11 register set in routing sequence also
+			//TX
+			codec->write(codec, 0x08, 0xb5);
+			break;
+	 	case MM_AUDIO_VOICECALL_SPK:		
+			//RX
+			//codec->write(codec, 0x0D, 0x20);	//warring 0x0D register set in routing sequence also
+			codec->write(codec, 0x05, 0x5B);
+			//codec->write(codec, 0x11, 0x10);	//warring 0x11 register set in routing sequence also
+			//TX
+			codec->write(codec, 0x08, 0xa4);
+			break;
+		case MM_AUDIO_VOICECALL_SPK_LOOP:
+			//RX
+			//codec->write(codec, 0x0D, 0x20);	//warring 0x0D register set in routing sequence also
+			codec->write(codec, 0x05, 0x5B);
+			//codec->write(codec, 0x11, 0x10);	//warring 0x11 register set in routing sequence also
+			//TX
+			codec->write(codec, 0x08, 0xa4);
+			break;
+	 	case MM_AUDIO_VOICECALL_BT:	
+			//RX
+			codec->write(codec, 0x05, 0x55);
+			codec->write(codec, 0x11, 0x10);
+			//TX
+			codec->write(codec, 0x08, 0xa5);
+			codec->write(codec, 0x56, 0x55);
+			break;
+		default :
+			printk("[%s] Invalid output gain path\n", __func__);
+	}
+}
+
+
+int path_enable(struct snd_soc_codec *codec, int mode)
+{
+	P("Enable PATH : 0x%x\n", mode);
+
+	/* general init register */
+	if(mode) {
+		//codec->write(codec, 0x02, 0x01); 	// PLL Mode and Power up
+		codec->write(codec, 0x01, reg_pll_mode); 	
+		codec->write(codec, 0x02, 0x03); 	// PLL Mode and Power up, Master Mode
+		codec->write(codec, 0x03, 0x03); 	// I2S mode
+	}
+
+	/* Set gain value */
+	set_path_gain(codec, mode);	
+
+	/* Set path register sequence */
+	switch(mode) {
+		case 0:
+			break;
+
+		case MM_AUDIO_PLAYBACK_RCV :
+			//P("set MM_AUDIO_PLAYBACK_RCV");
+			codec->write(codec, 0x09, 0x01); 	// D/A Lch -> Lout1
+			codec->write(codec, 0x0A, 0x01); 	// D/A Rch -> Rout1
+			codec->write(codec, 0x00, 0x01); 	// VCOM power up
+			mdelay(1); 				// wait 100ns
+			codec->write(codec, 0x00, 0xC1); 	// D/A power-up
+			codec->write(codec, 0x0F, 0x04); 	// LOPS1="1",use for pop noise cancel 
+			mdelay(1);				// wait 100ns
+			codec->write(codec, 0x0F, 0x07); 	// PML01, PMRO1 power-up
+			mdelay(30); 				// wait more than 30ms
+			codec->write(codec, 0x0F, 0x23);	// LOPS1='0', RCV mono
+			break;
+
+		case MM_AUDIO_PLAYBACK_SPK :
+		case MM_AUDIO_PLAYBACK_HP :
+		case MM_AUDIO_PLAYBACK_SPK_HP :
+			//P("set MM_AUDIO_PLAYBACK_SPK, HP, SPK_HP");
+			codec->write(codec, 0x0B, 0x01); 	// D/A Lch -> Lout2
+			codec->write(codec, 0x0C, 0x01); 	// D/A Rch -> Rout2
+			codec->write(codec, 0x00, 0x01); 	// VCOM power up
+			mdelay(1); 				// wait 100ns
+			codec->write(codec, 0x00, 0xC1); 	// D/A power-up
+			codec->write(codec, 0x10, 0x63); 	// PMLO2,PMRO2,PMLO2S,PMRO2s='1'
+			mdelay(1);				// wait 100ns
+			codec->write(codec, 0x10, 0x67); 	// MUTEN='1'
+			break;
+
+		case MM_AUDIO_PLAYBACK_BT :
+			//P("set MM_AUDIO_PLAYBACK_BT");
+			codec->write(codec, 0x15, 0x00); 	// 5-band EQ Rch=STDI Rch
+			codec->write(codec, 0x15, 0x41); 	// SRC-A = MIX Rch
+			mdelay(1);				// wait 100ns
+			codec->write(codec, 0x00, 0x01); 	// PMPCM, PMSRA='1', PCM ref = BICKA
+			mdelay(40);
+			
+			break;
+
+		case MM_AUDIO_VOICECALL_RCV :
+			//P("set MM_AUDIO_VOICECALL_RCV");
+			codec->write(codec, 0x0F, 0x20);	// RCP/RCN mode
+			codec->write(codec, 0x11, 0xA0);	// LOP/LON, gain=0dB
+			codec->write(codec, 0x0A, 0x20);	// MIC-AMP Rch -> RCP/RCN
+			codec->write(codec, 0x0D, 0x20);	// MIC-AMP Lch -> LOP/LON
+			codec->write(codec, 0x04, 0x9C);	// MIC-AMP Lch=IN1+/-, IN4+/- Differential Input
+			codec->write(codec, 0x00, 0x01);	// VCOM power-up
+			codec->write(codec, 0x00, 0x0D);	// MIC-AMP, A/D power-up
+			codec->write(codec, 0x06, 0x03);	// PMLOOPL, PMLOOPR power-up
+			codec->write(codec, 0x0F, 0x27);	// PMLO1, PMRO1 power-up
+			mdelay(1);
+			codec->write(codec, 0x0F, 0x23);	// LOPS1=0
+			codec->write(codec, 0x11, 0xA4);	// LOPS3=1, use for pop noise cancel
+			codec->write(codec, 0x11, 0xA7);	// PMLO3, PMRO3 power-up
+			mdelay(30); 				// Wait more than 30ms(Output capacitor=1uF, AVDD=3.3V)
+			codec->write(codec, 0x11, 0xA3);	// LOPS3=0
+
+			/* MIC-AMP Rch + A/P Rch => RCP/RCN */
+			codec->write(codec, 0x00, 0x8D);	// DAC-Rch power-up
+			mdelay(2);
+			codec->write(codec, 0x0A, 0x21);	// (MIC-AMP-Rch mixing DAC-Rch) to RCP/RCN
+			
+
+			break;
+
+		case MM_AUDIO_VOICECALL_SPK :
+		case MM_AUDIO_VOICECALL_HP :
+		case MM_AUDIO_VOICECALL_SPK_LOOP:
+			//P("set MM_AUDIO_VOICECALL_SPK,HP");
+			codec->write(codec, 0x0C, 0x20); 	// MIC-AMP-Lch to Lout2
+			codec->write(codec, 0x10, 0x08); 	// MIC-AMP-Lch to Rout2
+			codec->write(codec, 0x0D, 0x20); 	// MIC-AMP Lch -> LOP/LON
+			codec->write(codec, 0x11, 0xA0); 	// LOP/LON gain=0dB
+			if (mode == MM_AUDIO_VOICECALL_SPK || mode == MM_AUDIO_VOICECALL_SPK_LOOP)
+				codec->write(codec, 0x04, 0x8D); 	// MIC-AMP Lch= LIN2, Rch= IN4+/-
+				//codec->write(codec, 0x04, 0x0D); 	// MIC-AMP Lch= LIN2, Rch= RIN4
+			else
+				codec->write(codec, 0x04, 0xCE); 	// MIC-AMP Lch=IN3+/-, Rch=IN4+/-
+			/* Other setting if needed except for power setting */
+			codec->write(codec, 0x00, 0x01); 	// VCOM power-up
+			codec->write(codec, 0x06, 0x03); 	// PMLOOPL, PMLOOPR power-up
+			codec->write(codec, 0x00, 0x0D); 	// MIC-AMP power-up
+			codec->write(codec, 0x10, 0x73); 	// PMLO2, PMRO2, PMLO2S,PMRO2s=1
+			codec->write(codec, 0x10, 0x77); 	// MUTEN=1
+			codec->write(codec, 0x11, 0xA4); 	// LOPS3=1, use for pop noise cancel
+			codec->write(codec, 0x11, 0xA7); 	// PMLO3, PMRO3 power-up
+			mdelay(30); 				// Wait more than 30ms(Output capacitor=1uF, AVDD=3.3V)
+			codec->write(codec, 0x11, 0xA3); 	// LOPS3=0
+
+			/* MIC-AMP Rch + A/P Rch => Lout2/Rout2 */
+			codec->write(codec, 0x00, 0xCD);	// DAC-Rch power-up
+			mdelay(2);
+			codec->write(codec, 0x0B, 0x01);	// (MIC-AMP-Rch mixing DAC-Rch) to Lout2
+			codec->write(codec, 0x0C, 0x21);	// (MIC-AMP-Rch mixing DAC-Rch) to Rout2
+			
+			break;
+
+		case MM_AUDIO_VOICECALL_BT :
+			//P("set MM_AUDIO_VOICECALL_BT");
+			codec->write(codec, 0x01, 0xF8); 		// fs=44.1kHz, MCKI=19.2MHz input
+
+			codec->write(codec, 0x11, 0xA0); 		// LOP/LON, gain=0dB
+			codec->write(codec, 0x0D, 0x01); 		// D/A Lch -> LOP/LON
+			codec->write(codec, 0x04, 0xCE); 		// MIC-AMP Rch= IN4+/- be selected
+			codec->write(codec, 0x15, 0x14); 		// 5-band EQ Lch=SRC-B, Rch=SVOLA Rch
+			codec->write(codec, 0x19, 0x41); 		// OVOLC, SRC-A : Rch
+			codec->write(codec, 0x00, 0x01); 		// VCOM power-up
+			mdelay(40);
+			codec->write(codec, 0x00, 0x69); 		// PMVCM, PMMICR, PMADR, PMDAL, PMDAR power up
+			codec->write(codec, 0x53, 0x17); 		// PLLBT1,PMSRA/B, PMPCM power up
+								
+			mdelay(40);					//PLLBT lock time: max 40ms (base on BICKA)
+			codec->write(codec, 0x11, 0xA4); 		// LOPS3=1, use for pop noise cancel
+			mdelay(1); 		// Wait more than 100ns
+			codec->write(codec, 0x11, 0xA7); 		// PMLO3, PMRO3 power-up
+			mdelay(100);					// Wait more than 100ms
+									// (Output capacitor=1uF, AVDD=3.3V)
+			codec->write(codec, 0x11, 0xA3); 		// LOPS3=0
+			
+			/* Mixing ADC Rch and A/P Rch */
+			codec->write(codec, 0x15, 0x18); 		// Lch: from SRC-B;
+													//Rch: from (SVOLA Rch + SDTI Rch)
+			break;
+		
+		case MM_AUDIO_VOICEMEMO_MAIN :
+			//P("set MM_AUDIO_VOICEMEMO_MAIN");
+			mic_set_path(AK4671_MIC_PATH_MAIN);
+			codec->write(codec, 0x04, 0x14); 		// => MIC-AMP Lch=IN1+/-
+			codec->write(codec, 0x0B, 0x01); 		// D/A Lch -> Lout2
+			codec->write(codec, 0x0C, 0x01); 		// D/A Rch -> Rout2
+			codec->write(codec, 0x00, 0x01); 		// => VCOM power-up
+			mdelay(2); 		// Wait more than 100ns
+			codec->write(codec, 0x00, 0xD5); 		// D/A power-up
+			codec->write(codec, 0x10, 0x63); 		// PMLO2,PMRO2,PMLO2S,PMRO2s='1'
+			mdelay(1);		// wait 100ns
+			codec->write(codec, 0x10, 0x67); 		// MUTEN='1'
+			break;
+
+		case MM_AUDIO_VOICEMEMO_SUB :
+			//P("set MM_AUDIO_VOICEMEMO_SUB");
+			mic_set_path(AK4671_MIC_PATH_SUB);
+			codec->write(codec, 0x04, 0x04); 		// => MIC-AMP Lch=LIN2
+			codec->write(codec, 0x0B, 0x01); 		// D/A Lch -> Lout2
+			codec->write(codec, 0x0C, 0x01); 		// D/A Rch -> Rout2
+			codec->write(codec, 0x00, 0x01); 		// => VCOM power-up
+			mdelay(2); 		// Wait more than 100ns
+			codec->write(codec, 0x00, 0xD5); 		// D/A power-up
+			codec->write(codec, 0x10, 0x63); 		// PMLO2,PMRO2,PMLO2S,PMRO2s='1'
+			mdelay(1);		// wait 100ns
+			codec->write(codec, 0x10, 0x67); 		// MUTEN='1'
+			break;
+
+		case MM_AUDIO_VOICEMEMO_EAR :
+			//P("set MM_AUDIO_VOICEMEMO_EAR");
+			codec->write(codec, 0x04, 0x42); 		// => MIC-AMP Lch=IN3+/-
+			codec->write(codec, 0x0B, 0x01); 		// D/A Lch -> Lout2
+			codec->write(codec, 0x0C, 0x01); 		// D/A Rch -> Rout2
+			codec->write(codec, 0x00, 0x01); 		// => VCOM power-up
+			mdelay(2); 		// Wait more than 100ns
+			codec->write(codec, 0x00, 0xD5); 		// D/A power-up
+			codec->write(codec, 0x10, 0x63); 		// PMLO2,PMRO2,PMLO2S,PMRO2s='1'
+			mdelay(1);		// wait 100ns
+			codec->write(codec, 0x10, 0x67); 		// MUTEN='1'
+			break;
+
+		case MM_AUDIO_VOICEMEMO_BT :
+			//P("set MM_AUDIO_VOICEMEMO_BT");
+			codec->write(codec, 0x59, 0x10); 		// => SDTO Lch=SRC-B
+			codec->write(codec, 0x00, 0x01); 		// => VCOM power-up
+			mdelay(2); 		//Wait more than 100ns
+			codec->write(codec, 0x53, 0x0F); 		// => PMPCM,PMSRA, PMSRB=1
+													// PCM reference= BICKA(VCOCBT=10kohm&4.7nF)
+			mdelay(40); 		// Lock time= 40ms
+			break;		
+		default :
+			printk("[SOUND MODE] invalid mode!!! \n");
+	}
+
+
+	set_bias(codec, mode);
+	return 0;
+}
+
+int path_disable(struct snd_soc_codec *codec, int mode)
+{
+	P("Diasble PATH : 0x%x\n", mode);
+
+	amp_enable(0);//for noise reduce
+
+	switch(mode) {
+		case 0:
+			P("Path : Off");
+			break;
+
+		case MM_AUDIO_PLAYBACK_RCV :
+			//P("MM_AUDIO_PLAYBACK_RCV Off");
+			codec->write(codec, 0x0F, 0x27); 	// LOPS='1'
+			mdelay(2); 	// wait more than 1ms
+			codec->write(codec, 0x0F, 0x04); 	// RCP/RCN power-donw
+			mdelay(2); 	// wait more than 1ms
+			codec->write(codec, 0x00, 0x01); 	// VCOM power up
+			codec->write(codec, 0x00, 0x00); 	// VCOM power down
+			break;
+
+		case MM_AUDIO_PLAYBACK_SPK :
+		case MM_AUDIO_PLAYBACK_HP :
+		case MM_AUDIO_PLAYBACK_SPK_HP :
+		case MM_AUDIO_PLAYBACK_RING_SPK_HP :
+			//P("MM_AUDIO_PLAYBACK_SPK, HP, SPK_HP Off");
+			codec->write(codec, 0x10, 0x73); 	// MUTEN='0'
+			mdelay(30); 	// wait more than 30ms
+			codec->write(codec, 0x10, 0x00); 	// LOUT2/ROUT2 power-down
+			codec->write(codec, 0x00, 0x01); 	// VCOM power up
+			codec->write(codec, 0x00, 0x00); 	// VCOM power down
+			break;
+
+		case MM_AUDIO_PLAYBACK_BT :
+			codec->write(codec, 0x00, 0x01); 	// VCOM power up
+			codec->write(codec, 0x00, 0x00); 	// VCOM power down
+			break;
+			
+		case MM_AUDIO_VOICECALL_RCV :
+			//P("set MM_AUDIO_VOICECALL_RCV Off");
+			/* MIC-AMP Rch + A/P Rch => RCP/RCN Off */
+			codec->write(codec, 0x19, 0x04);	// use soft mute to cut signal
+			mdelay(24);
+			codec->write(codec, 0x0A, 0x20);	// only MIC-AMP-Rch to RCP/RCN
+			codec->write(codec, 0x00, 0x0D);	// DAC-Rch power-up
+			codec->write(codec, 0x04, 0x00);   // Mic Amp input select default
+			codec->write(codec, 0x0A, 0x00);	//Mic Amp Rch -> RcP/Rcn select default
+			codec->write(codec, 0x0D, 0x00);	//Mic Amp Lch -> Lop/Lon select default
+			codec->write(codec, 0x06, 0x00);	//pmloopl, pmloopr power down
+
+			/* Normal Off */
+			codec->write(codec, 0x11, 0xA7);	// LOPS3=1
+			codec->write(codec, 0x0F, 0x27);	// LOPS1=1
+			codec->write(codec, 0x0F, 0x24);	// RCP/RCN power-down
+			codec->write(codec, 0x11, 0xA4);	// LOP/LON power-down
+			mdelay(30);
+			codec->write(codec, 0x11, 0x10);	// default
+			codec->write(codec, 0x0F, 0x00);	// default
+			//codec->write(codec, 0x01, 0x00); 	// 
+			codec->write(codec, 0x00, 0x00); 	// VCOM power down
+			break;
+
+		case MM_AUDIO_VOICECALL_SPK :
+		case MM_AUDIO_VOICECALL_HP :
+		case MM_AUDIO_VOICECALL_SPK_LOOP:
+			//P("set MM_AUDIO_VOICECALL_SPK,HP Off");
+
+			/* MIC-AMP Rch + A/P Rch => Lout2/Rout2 Off */
+			#if 0
+			codec->write(codec, 0x19, 0x04); 	// use soft mute to shut-down signal
+			mdelay(24);
+			codec->write(codec, 0x0B, 0x00); 	// Swith-off DAC-Lch
+			codec->write(codec, 0x0C, 0x20); 	// Swith-off DAC-Rch 
+			codec->write(codec, 0x00, 0x0D); 	// DAC power-up
+			codec->write(codec, 0x02, 0x00); 	// PLL power-down
+			#endif
+			
+			/* Normal Off */
+			codec->write(codec, 0x11, 0xA7); 	// LOPS3=1
+			codec->write(codec, 0x11, 0xA4); 	// LOP/LON power-down
+			codec->write(codec, 0x10, 0x6B); 	// MUTEN=0
+			mdelay(30);
+			codec->write(codec, 0x11, 0x10); 	// default
+			codec->write(codec, 0x10, 0x00); 	// default
+			//codec->write(codec, 0x01, 0x00); 	//
+			codec->write(codec, 0x00, 0x00); 	//
+			break;
+
+		case MM_AUDIO_VOICECALL_BT :
+			//P("set MM_AUDIO_VOICECALL_BT Off");
+
+			/* Mixing ADC Rch and A/P Rch Off */
+			//codec->write(codec, 0x15, 0x14); 	// 5-band-EQ-Lch: from SRC-B;
+			codec->write(codec, 0x15, 0x00); 	// 5-band-EQ-Lch: from SRC-B;
+												// Rch: from SVOLA Rch
+													
+			/* Normal Off */
+			codec->write(codec, 0x11, 0xA7); 		// LOPS3=1
+			codec->write(codec, 0x11, 0xA4); 	// LOP/LON power-down
+			mdelay(30); 		// Wait more than 30ms
+			codec->write(codec, 0x11, 0x10);	// default
+			codec->write(codec, 0x53, 0x00);	// PMSRA/B, PMPCM power-down
+			//codec->write(codec, 0x02, 0x00); 	// PLL power-down
+			//codec->write(codec, 0x01, 0x00);
+			codec->write(codec, 0x00, 0x00);	// VCOM and others power-down
+
+			break;
+
+		case MM_AUDIO_VOICEMEMO_MAIN :
+			//P("set MM_AUDIO_VOICEMEMO_MAIN Off");
+			codec->write(codec, 0x00, 0x01);
+			codec->write(codec, 0x00, 0x00);
+			break;
+
+		case MM_AUDIO_VOICEMEMO_SUB :
+			//P("set MM_AUDIO_VOICEMEMO_SUB Off");
+			codec->write(codec, 0x00, 0x01);
+			codec->write(codec, 0x00, 0x00);
+			break;
+
+		case MM_AUDIO_VOICEMEMO_EAR :
+			//P("set MM_AUDIO_VOICEMEMO_EAR Off");
+			codec->write(codec, 0x00, 0x01);
+			codec->write(codec, 0x00, 0x00);
+			break;
+
+		case MM_AUDIO_VOICEMEMO_BT :
+			//P("set MM_AUDIO_VOICEMEMO_BT Off");
+			codec->write(codec, 0x00, 0x01);
+			codec->write(codec, 0x00, 0x00);
+			break;	
+
+		default:
+			printk("[SOUND MODE] invalid mode!!! \n");
+	}
+
+	return 0;
+}
+
+int idle_mode_enable(struct snd_soc_codec *codec, int mode)
+{
+	P("Enable Idle Mode : 0x%x\n", mode);
+
+	switch(mode) {
+		case 0:
+			break;
+
+		case MM_AUDIO_PLAYBACK_RCV :
+			//P("set MM_AUDIO_PLAYBACK_RCV");
+			codec->write(codec, 0x00, 0x01); 	// VCOM power up
+			mdelay(1); 		// wait 100ns
+			codec->write(codec, 0x00, 0xC1); 	// D/A power-up
+			codec->write(codec, 0x0F, 0x04); 	// LOPS1="1",use for pop noise cancel 
+			mdelay(1);		// wait 100ns
+			codec->write(codec, 0x0F, 0x07); 	// PML01, PMRO1 power-up
+			mdelay(30); 	// wait more than 300ms
+			codec->write(codec, 0x0F, 0x23);	// LOPS1='0', RCV mono
+			break;
+
+		case MM_AUDIO_PLAYBACK_SPK :
+		case MM_AUDIO_PLAYBACK_HP :
+		case MM_AUDIO_PLAYBACK_SPK_HP :
+		case MM_AUDIO_PLAYBACK_RING_SPK_HP :
+			//P("set MM_AUDIO_PLAYBACK_SPK, HP, SPK_HP");
+			codec->write(codec, 0x00, 0x01); 	// VCOM power up
+			mdelay(1); 		// wait 100ns
+			codec->write(codec, 0x00, 0xC1); 	// D/A power-up
+			codec->write(codec, 0x10, 0x63); 	// PMLO2,PMRO2,PMLO2S,PMRO2s='1'
+			mdelay(1);		// wait 100ns
+			codec->write(codec, 0x10, 0x67); 	// MUTEN='1'
+			break;
+
+		case MM_AUDIO_PLAYBACK_BT :
+			//P("set MM_AUDIO_PLAYBACK_BT");
+			codec->write(codec, 0x15, 0x00); 	// 5-band EQ Rch=STDI Rch
+			codec->write(codec, 0x15, 0x41); 	// SRC-A = MIX Rch
+			mdelay(1);		// wait 100ns
+			codec->write(codec, 0x00, 0x01); 	// PMPCM, PMSRA='1', PCM ref = BICKA
+			mdelay(40);
+			
+			break;
+
+		default :
+			printk("[SOUND MODE] invalid IDLE mode!!! \n");
+	}
+
+	set_bias(codec, mode);
+
+	return 0;
+}
+
+int idle_mode_disable(struct snd_soc_codec *codec, int mode)
+{
+	P("Diasble PATH : 0x%x\n", mode);
+
+
+	if(!get_headset_status())
+		mic_enable(0);
+
+	amp_enable(0);
+
+	switch(mode) {
+		case 0:
+			P("Path : Off");
+			break;
+
+		case MM_AUDIO_PLAYBACK_RCV :
+			//P("MM_AUDIO_PLAYBACK_RCV Off");
+			codec->write(codec, 0x0F, 0x04); 	// RCP/RCN power-down
+			mdelay(2); 	// wait more than 1ms
+			codec->write(codec, 0x00, 0x01); 	// VCOM power up
+			codec->write(codec, 0x00, 0x00); 	// VCOM power down
+			break;
+
+		case MM_AUDIO_PLAYBACK_SPK :
+		case MM_AUDIO_PLAYBACK_HP :
+		case MM_AUDIO_PLAYBACK_SPK_HP :
+		case MM_AUDIO_PLAYBACK_RING_SPK_HP :
+			//P("MM_AUDIO_PLAYBACK_SPK, HP, SPK_HP Off");
+			codec->write(codec, 0x10, 0x73); 	// MUTEN='0'
+			mdelay(30); 	// wait more than 30ms
+			codec->write(codec, 0x10, 0x00); 	// LOUT2/ROUT2 power-down
+			codec->write(codec, 0x00, 0x01); 	// VCOM power up
+			codec->write(codec, 0x00, 0x00); 	// VCOM power down
+			break;
+
+		case MM_AUDIO_PLAYBACK_BT :
+			codec->write(codec, 0x00, 0x01); 	// VCOM power up
+			codec->write(codec, 0x00, 0x00); 	// VCOM power down
+			break;
+			
+		default:
+			printk("[SOUND MODE] invalid IDLE mode!!! \n");
+	}
+
+	return 0;
+}
+
+int voice_call_auto_response_enable(struct snd_soc_codec *codec, int mode)
+{
+	P1("auto response Enable (mode : 0x%x)\n", mode);
+
+	switch(mode) {
+		case MM_AUDIO_VOICECALL_RCV :
+			P("enable Play (MM_AUDIO_VOICECALL_RCV)");
+			codec->write(codec, 0x19, 0x01); 	// use soft mute to cut signal
+			mdelay(24);
+			codec->write(codec, 0x0D, 0x01);	//DAC to LON,LOP 
+			codec->write(codec, 0x0E, 0x01);
+			codec->write(codec, 0x0A, 0x00);	//RCP/RON DAC Off
+
+			codec->write(codec, 0x00, 0xC1);	//DAC-L/R power up
+			
+			mdelay(24);
+			break;
+
+		case MM_AUDIO_VOICECALL_SPK :
+		case MM_AUDIO_VOICECALL_HP :
+			P("enable Play (MM_AUDIO_VOICECALL_HP_SPK)");
+			/* MIC-AMP Rch mixing A/P Rch -> Lout2/Rout OFF */
+			codec->write(codec, 0x19, 0x01); 	// use soft mute to cut signal
+			mdelay(24);
+
+			codec->write(codec, 0x0D, 0x01);	//DAC to LON,LOP 
+			codec->write(codec, 0x0E, 0x01);
+			codec->write(codec, 0x0B, 0x00);	//LOUT2 DAC Off
+			codec->write(codec, 0x0C, 0x00);	//OUT2 DAC Off
+			
+			codec->write(codec, 0x00, 0xC1); 	// DAC-Rch power-up
+
+			/* MIC-AMP Lch->LOP/LON and ADC Lch->AP Lch */
+//			codec->write(codec, 0x00, 0x3D); 	// ADC-Lch power-up
+			mdelay(24);
+			break;
+
+		case MM_AUDIO_VOICECALL_BT :
+			P("enable REC (MM_AUDIO_VOICECALL_BT)");
+			/* mixing ADC Rch and A/P Rch -> SRC-A -> PCM-A */
+			codec->write(codec, 0x15, 0x24); 	// PFMXL -> SDIM Lch, PFMXR -> SVOLA, SRMXL -> PFMXL + SRC-B, SRMXR -> PFMXR
+
+			/* SRC-B -> DAC Lch -> LOP/LON -> and -> A/P Lch */
+			codec->write(codec, 0x59, 0x10); 	// SDTO-Lch: from SRC-B
+			codec->write(codec, 0x53, 0x14);   // Swith-off all output
+			break;
+		default :
+				printk("[%s] Invalid mode\n", __func__);
+	}
+
+	codec->write(codec, 0x18, 0x06); 	// IVOLC, ADM Mono
+
+	return 0;
+}
+
+int voice_call_auto_response_disable(struct snd_soc_codec *codec, int mode) 
+{
+	P1("auto response Disable (mode : 0x%x)\n", mode);
+
+	switch(mode) {
+		case MM_AUDIO_VOICECALL_RCV :
+			P("disable auto reponse (MM_AUDIO_VOICECALL_RCV)");
+
+			codec->write(codec, 0x0A, 0x20);	// (MIC-AMP-Rch mixing DAC-Rch) to RCP/RCN		
+			codec->write(codec, 0x0D, 0x20);	// MIC-AMP Lch -> LOP/LON			
+			codec->write(codec, 0x0E, 0x00);
+			codec->write(codec, 0x00, 0x8D);	// DAC-Rch power-up
+			mdelay(2);						
+			codec->write(codec, 0x0A, 0x21);	// (MIC-AMP-Rch mixing DAC-Rch) to RCP/RCN			
+			break;
+
+		case MM_AUDIO_VOICECALL_SPK :
+		case MM_AUDIO_VOICECALL_HP :
+			P("disable auto response (MM_AUDIO_VOICECALL_HP_SPK)");
+			/* MIC-AMP Lch->LOP/LON and ADC Lch->AP Lch */
+			codec->write(codec, 0x0D, 0x20); 	// MIC-AMP Lch -> LOP/LON
+			codec->write(codec, 0x0E, 0x00);
+			codec->write(codec, 0x00, 0xCD);	// DAC-Rch power-up
+			mdelay(2);	
+			codec->write(codec, 0x0B, 0x01);	// (MIC-AMP-Rch mixing DAC-Rch) to Lout2
+			codec->write(codec, 0x0C, 0x21);	// (MIC-AMP-Rch mixing DAC-Rch) to Rout2
+	
+			break;
+
+		case MM_AUDIO_VOICECALL_BT :
+			P("disable auto response (MM_AUDIO_VOICECALL_BT)");
+			codec->write(codec, 0x15, 0x18); 	// 5-band-EQ-Lch: from SRC-B, Rch: from SVOLA Rch
+			/* SRC-B -> DAC Lch -> LOP/LON -> and -> A/P Lch */
+			codec->write(codec, 0x59, 0x00); 	// default
+			codec->write(codec, 0x53, 0x17); 		// PLLBT1,PMSRA/B, PMPCM power up
+			break;
+		
+		default :
+			printk("[%s] Invalid mode\n", __func__);
+	}
+
+	codec->write(codec, 0x18, 0x02); 	// IVOLC
+
+	return 0;
+}
+	
+
diff -Nur linux-2.6.29/sound/soc/codecs/i2c-emul.c linux-2.6.29-spica/sound/soc/codecs/i2c-emul.c
--- linux-2.6.29/sound/soc/codecs/i2c-emul.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/codecs/i2c-emul.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,529 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+
+#include <asm/io.h>
+
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <mach/hardware.h>
+
+#include "i2c-emul.h"
+
+#define S3C_ADDR_BASE   (0xF4000000)
+#ifndef __ASSEMBLY__
+#define S3C_ADDR(x) ((void __iomem __force *)S3C_ADDR_BASE + (x))
+#else
+#define S3C_ADDR(x) (S3C_ADDR_BASE + (x))
+#endif
+#define S3C_VA_GPIO S3C_ADDR(0x00600000)    /* GPIO */
+#define S3C24XX_VA_GPIO     S3C_VA_GPIO
+#define S3C_GPIOREG(x) ((x) + S3C24XX_VA_GPIO)
+#define S3C_GPBDAT     S3C_GPIOREG(0x24)
+#define S3C_GPCDAT     S3C_GPIOREG(0x44)
+
+#define S3C_GPIONO(bank,offset) ((bank) + (offset))
+#define S3C_GPIO_BANKB   (32*1)
+ 
+#define S3C_GPB2       S3C_GPIONO(S3C_GPIO_BANKB, 2)
+#define S3C_GPB2_INP            (0)
+#define S3C_GPB2_OUTP           (1)
+#define S3C_GPB2_UART_RXD3      (2)
+#define S3C_GPB2_IRDA_RXD       (3)
+#define S3C_GPB2_EXT_DMA_REQ    (4)
+#define S3C_GPB2_ADDR_CF2       (5)
+#define S3C_GPB2_RESERVED       (6)
+#define S3C_GPB2_I2C_SCL        (6) //+anthony [10th Oct.2008]
+#define S3C_GPB2_EXT_INT_G1_10  (7)
+
+#define S3C_GPB3       S3C_GPIONO(S3C_GPIO_BANKB, 3)
+#define S3C_GPB3_INP            (0)
+#define S3C_GPB3_OUTP           (1)
+#define S3C_GPB3_UART_TXD3      (2)
+#define S3C_GPB3_IRDA_RXD       (3)
+#define S3C_GPB3_EXT_DMA_ACK    (4)
+#define S3C_GPB3_RESERVED1      (5)
+#define S3C_GPB3_RESERVED2      (6)
+#define S3C_GPB3_I2C_SDA        (6) //+anthony [10th Oct.2008]
+#define S3C_GPB3_EXT_INT_G1_11  (7)
+
+
+
+
+
+
+
+
+
+
+
+
+
+#if 0
+#define SCL_Hi  { gpdat = __raw_readl(S3C_GPCDAT);\
+                    gpdat |= (0x1 << 7);\
+                    __raw_writel(gpdat,S3C_GPCDAT);\
+                    udelay(DELAY); }
+#define SCL_Lo  { gpdat = __raw_readl(S3C_GPCDAT);\
+                    gpdat &= ~(0x1 << 7);\
+                    __raw_writel(gpdat,S3C_GPCDAT);\
+                    udelay(DELAY); }  
+#define SDA_Hi  { gpdat = __raw_readl(S3C_GPCDAT);\
+                    gpdat |= (0x1 << 6);\
+                    __raw_writel(gpdat,S3C_GPCDAT);\
+                    udelay(DELAY); }
+#define SDA_Lo  { gpdat = __raw_readl(S3C_GPCDAT);\
+                    gpdat &= ~(0x1 << 6);\
+                    __raw_writel(gpdat,S3C_GPCDAT); \
+                    udelay(DELAY); } 
+#endif
+
+#if 0	// GPC case
+#define SCL_Hi  { s3c_gpio_setpin(S3C_GPC7,1);}
+#define SCL_Lo  { s3c_gpio_setpin(S3C_GPC7,0);}
+#define SDA_Hi  { s3c_gpio_setpin(S3C_GPC6,1);}
+#define SDA_Lo  { s3c_gpio_setpin(S3C_GPC6,0);}
+#else
+
+
+
+#if 0
+#define SCL_Hi  { s3c_gpio_setpin(S3C_GPB2,1);}
+#define SCL_Lo  { s3c_gpio_setpin(S3C_GPB2,0);}
+#define SDA_Hi  { s3c_gpio_setpin(S3C_GPB3,1);}
+#define SDA_Lo  { s3c_gpio_setpin(S3C_GPB3,0);}
+#else
+
+#define SCL_Hi  { gpio_set_value(GPIO_I2C1_SCL, GPIO_LEVEL_HIGH); }
+#define SCL_Lo  { gpio_set_value(GPIO_I2C1_SCL, GPIO_LEVEL_LOW); }
+#define SDA_Hi  { gpio_set_value(GPIO_I2C1_SDA, GPIO_LEVEL_HIGH); }
+#define SDA_Lo  { gpio_set_value(GPIO_I2C1_SDA, GPIO_LEVEL_LOW); }
+
+#endif
+
+
+#endif
+
+
+//sktlinux
+//SDA - GPB3
+//SCL - GPB2
+
+#define DELAY       10
+#define	SDA_BIT	3
+
+#define I2C_EMUL_DBG    0
+#if I2C_EMUL_DBG
+#define dbg(x...)      printk(x)
+#else
+#define dbg(x...)
+#endif
+
+static inline void SET_SDA(int val)
+{
+    //dbg("   before SET_SDA: val = %d, GPCDAT = 0x%x\n",val,__raw_readl(S3C_GPCDAT));
+    if(val)
+    {
+        SDA_Hi;
+    }
+    else
+    {
+        SDA_Lo;
+    }
+    //dbg("   after SET_SDA: GPCDAT = 0x%x\n", __raw_readl(S3C_GPCDAT));
+}
+static inline int GET_SDA(void)
+{
+    int ret;
+    //unsigned long reg;
+    unsigned long dat;
+    
+    //s3c_gpio_cfgpin(S3C_GPC6, S3C_GPC6_INP); 
+    
+    dat = __raw_readl(S3C_GPBDAT);
+    //dbg("GET_SDA: GPCDAT = 0x%x\n", dat);
+    
+    if( (0x1 << SDA_BIT) & dat)
+        ret = 1;
+    else
+        ret = 0;
+    
+    //s3c_gpio_cfgpin(S3C_GPC6, S3C_GPC6_OUTP);
+    
+    return ret;       
+}
+
+// read ACK(SDA)
+static inline int GET_ACK(void)
+{
+    int ret;
+    //unsigned long reg;
+    unsigned long ack = 0;
+    
+    s3c_gpio_cfgpin(S3C_GPB3, S3C_GPB3_INP);
+
+    //udelay(DELAY);
+    udelay(DELAY);
+
+    SCL_Hi;
+    udelay(DELAY);
+    ack = __raw_readl(S3C_GPBDAT);
+    udelay(DELAY);
+    SCL_Lo;
+    //udelay(DELAY);
+    //dbg("ACK: GPCDAT = 0x%x\n", ack);
+    
+    
+    if( (0x1 << SDA_BIT) & ack)
+        ret = 1;
+    else
+        ret = 0;
+    
+    s3c_gpio_cfgpin(S3C_GPB3, S3C_GPB3_OUTP);
+    
+    return ret;       
+}
+/* --- other auxiliary functions --------------------------------------	*/
+static void i2c_emul_start(void) 
+{
+	/* assert: scl, sda are high */
+	//unsigned long gpdat;
+	
+    SDA_Hi;
+    SCL_Hi;
+    udelay(DELAY);
+    
+	SDA_Lo;
+    udelay(DELAY);
+	SCL_Lo;
+    udelay(DELAY);
+}
+
+static void i2c_emul_repstart(void) 
+{
+	/* scl, sda may not be high */
+	
+	SDA_Hi;
+	SCL_Hi;
+    udelay(DELAY);
+	
+	SDA_Lo;
+    udelay(DELAY);
+	SCL_Lo;
+    udelay(DELAY);
+}
+static void i2c_emul_stop(void) 
+{
+	/* assert: scl is low */
+	
+	SDA_Lo;
+    udelay(DELAY);
+	SCL_Hi;
+    udelay(DELAY);
+	SDA_Hi;
+    udelay(DELAY);
+}
+
+static int i2c_emul_outb(char c)
+{
+	int i;
+	int sb;
+	int ack;
+	
+    dbg("[i2c-emul] Enter %s, char  = 0x%x\n",__FUNCTION__,c);
+
+	/* assert: scl is low */
+	for ( i=7 ; i>=0 ; i-- ) {
+		sb = c & ( 1 << i );
+
+		SET_SDA(sb);
+		udelay(DELAY);
+		
+		SCL_Hi;
+		udelay(DELAY);
+		
+		SCL_Lo;
+		//udelay(DELAY);
+		//udelay(DELAY);
+	}
+	udelay(DELAY);
+	SDA_Hi;   // set SDA Hi before reading ack
+    //dbg("   after SDA_Hi GPCDAT = 0x%x\n", __raw_readl(S3C_GPCDAT));
+	//udelay(DELAY);
+	udelay(DELAY);
+	
+    ack = GET_ACK();
+	//ack = GET_SDA();
+    dbg("   ack = %d\n",ack);
+	
+	//SCL_Hi;
+	//udelay(DELAY);
+	
+	SCL_Lo;
+	udelay(DELAY);
+	
+	if(ack == 0)    return 0;   // OK
+	else            return -1;  // error
+}
+
+
+static unsigned char i2c_emul_inb(void) 
+{
+	/* read byte via i2c port, without start/stop sequence	*/
+	/* acknowledge is sent in i2c_read.			*/
+	int i;
+	unsigned char indata=0;
+	
+    s3c_gpio_cfgpin(S3C_GPB3, S3C_GPB3_INP);
+	for (i = 0;i < 8;i++)
+	{
+	    udelay(DELAY);
+	    SCL_Hi;
+	    udelay(DELAY);
+	    indata *= 2;    // shift left 
+	    
+	    if(GET_SDA())
+	        indata |= 0x01;
+	        
+	    SCL_Lo;
+	}
+	
+    s3c_gpio_cfgpin(S3C_GPB3, S3C_GPB3_OUTP);
+    
+	//return (int)(indata & 0xff);
+
+    //dbg(" inb : 0x%x\n",indata);
+    return indata;
+}
+
+static inline int doAddress(unsigned char addr, int rw)
+{
+    unsigned char tmp;
+    //unsigned long gpdat;
+    
+    dbg("[i2c-emul] Enter %s\n",__FUNCTION__);
+    
+    //i2c_start();
+    tmp = addr << 1;
+    tmp |= rw;
+    
+    if(i2c_emul_outb((char)tmp) < 0)
+    {
+        dbg("[i2c-emul] error in doAddress\n");
+        return -1;
+    }
+        
+    dbg("[i2c-emul]   doAddress OK\n");
+    return 0;
+}
+
+
+int i2c_emul_test(void)
+{
+    int ret = 0;
+    unsigned char read_val;
+
+    dbg("[i2c-emul] Enter %s\n",__FUNCTION__);
+
+    s3c_gpio_cfgpin(S3C_GPB2, S3C_GPB2_OUTP);
+    s3c_gpio_cfgpin(S3C_GPB3, S3C_GPB3_OUTP);
+    
+    //mdelay(3000);
+    dbg("   set GPC6,7 pull up,down disable\n");
+    //s3c_gpio_pullup(S3C_GPB3, 2);
+    //s3c_gpio_pullup(S3C_GPB2, 2);
+	s3c_gpio_setpull(GPIO_I2C1_SCL, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB5)
+	s3c_gpio_setpull(GPIO_I2C1_SDA, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB6)
+
+    mdelay(3000);
+    i2c_emul_write(0x1a, 0x01, 0x00);
+    i2c_emul_write(0x1a, 0x10, 0x13);
+    i2c_emul_write(0x1a, 0x00, 0x01);
+    ret = i2c_emul_read(0x1a,0x10,&read_val);
+    dbg("   i2c_read : reg 0x10 -> val 0x%x\n",read_val);
+
+
+	 // setup GPIO for I2C
+	s3c_gpio_cfgpin(S3C_GPB2, S3C_GPB2_I2C_SCL);	// IIC SCL (GPB5)
+	s3c_gpio_cfgpin(S3C_GPB3, S3C_GPB3_I2C_SDA);	// IIC SDA (GPB6)
+	//s3c_gpio_pullup(S3C_GPB2, 0x2); // IIC SCL Pull-Up enable (GPB5)
+	//s3c_gpio_pullup(S3C_GPB3, 0x2); // IIC SCL Pull-Up enable (GPB6)
+	s3c_gpio_setpull(GPIO_I2C1_SCL, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB5)
+	s3c_gpio_setpull(GPIO_I2C1_SDA, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB6)
+    
+    return 0;
+}
+
+void gpio_test(void)
+{
+    unsigned char reg;
+
+	dbg("   before : GPBCON = 0x%x, GPBDAT = 0x%x, GPBPU = 0x%x\n",__raw_readl(S3C_GPBCON), __raw_readl(S3C_GPBDAT),__raw_readl(S3C_GPBPU));
+	
+	s3c_gpio_cfgpin(S3C_GPB2, S3C_GPB2_OUTP);
+    s3c_gpio_cfgpin(S3C_GPB3, S3C_GPB3_OUTP);
+    
+    //mdelay(3000);
+    dbg("   set GPC6,7 pull up,down disable\n");
+    //s3c_gpio_pullup(S3C_GPB3, 2);
+    //s3c_gpio_pullup(S3C_GPB2, 2);
+	s3c_gpio_setpull(GPIO_I2C1_SCL, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB5)
+	s3c_gpio_setpull(GPIO_I2C1_SDA, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB6)
+	dbg("   set GPC6 to 0(Low) \n");
+    reg = __raw_readl(S3C_GPBDAT);
+    reg &= ~(0x1 << 6);
+    __raw_writel(reg,S3C_GPBDAT);
+
+	dbg("   after : GPBCON = 0x%x, GPBDAT = 0x%x, GPBPU = 0x%x\n",__raw_readl(S3C_GPBCON), __raw_readl(S3C_GPBDAT),__raw_readl(S3C_GPBPU));
+
+    reg = __raw_readl(S3C_GPBDAT);
+    reg |= 0x1 << 3;
+    __raw_writel(reg,S3C_GPBDAT);
+    mdelay(3000);
+    reg &= ~(0x1 << 3);
+    __raw_writel(reg,S3C_GPBDAT);
+    mdelay(3000);
+    reg |= 0x1 << 3;
+    __raw_writel(reg,S3C_GPBDAT);
+    mdelay(3000);
+
+}
+int i2c_emul_init(void)
+{
+    int ret;
+    unsigned long   reg;
+    unsigned char   read_val=0;
+    unsigned char   msg[2],addr;
+    
+    addr = 0x1a;
+    
+    dbg("[i2c-emul] Enter %s\n",__FUNCTION__);
+    
+    
+    dbg("   before : GPCCON = 0x%x, GPCDAT = 0x%x, GPCPU = 0x%x\n",__raw_readl(S3C_GPCCON), __raw_readl(S3C_GPCDAT),__raw_readl(S3C_GPCPU));
+
+    //mdelay(3000);
+    dbg("   set GPC6,7 output port \n");
+    s3c_gpio_cfgpin(S3C_GPB2, S3C_GPB2_OUTP);
+    s3c_gpio_cfgpin(S3C_GPB3, S3C_GPB3_OUTP);
+    
+    //mdelay(3000);
+    dbg("   set GPC6,7 pull up,down disable\n");
+    //s3c_gpio_pullup(S3C_GPB3, 2);
+    //s3c_gpio_pullup(S3C_GPB2, 2);
+	s3c_gpio_setpull(GPIO_I2C1_SCL, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB5)
+	s3c_gpio_setpull(GPIO_I2C1_SDA, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB6)
+
+    dbg("   set GPC6 to 0(Low) \n");
+    reg = __raw_readl(S3C_GPCDAT);
+    reg &= ~(0x1 << 6);
+    __raw_writel(reg,S3C_GPCDAT);
+    
+    dbg("   after : GPCCON = 0x%x, GPCDAT = 0x%x, GPCPU = 0x%x\n",__raw_readl(S3C_GPCCON), __raw_readl(S3C_GPCDAT),__raw_readl(S3C_GPCPU));
+   
+    //mdelay(3000);
+    CODEC_CLK_EN_SET;
+
+    //while(1);
+    //gpio_test();
+    mdelay(3000);
+
+    dbg("   power on LM49350\n");
+/*    msg[0] = 0x01;
+    msg[1] = 0x00;  // 
+    i2c_emul_write(addr, 0x01, 0x00);
+    i2c_emul_write(addr, 0x10, 0x30);
+    i2c_emul_write(addr, 0x18, 0x00);
+    i2c_emul_write(addr, 0x19, 0x00);
+    i2c_emul_write(addr, 0x00, 0x01);
+*/
+
+    mdelay(3000);
+    ret = i2c_emul_read(0x1a,0x10,&read_val);
+    dbg("   i2c_read : reg 0x10 -> val 0x%x\n",read_val);
+
+    return 0;
+}
+
+int i2c_emul_read(unsigned char dev_addr,unsigned char reg_addr, unsigned char*  reg_val)
+{
+    int ret = 0;
+    int ack;
+
+    dbg("[i2c-emul] Enter %s\n",__FUNCTION__);
+    
+	i2c_emul_start();
+
+	if(doAddress(dev_addr, 0) < 0)
+	{
+	    return -1;
+    }
+    if((ret = i2c_emul_outb(reg_addr)) < 0)
+    {
+	    dbg("[i2c-emul] error in i2c-read\n");
+	    return -1;
+    }
+    i2c_emul_repstart();
+	if(doAddress(dev_addr, 1) < 0)
+	{
+	    return -1;
+    }
+    
+   
+    *(reg_val) = i2c_emul_inb();
+    printk("i2c_emul_read : reg = 0x%x, val = 0x%x\n",reg_addr,*reg_val);
+
+    ack = GET_ACK();
+    // send ACK
+    /*
+    SCL_Lo;
+    SDA_Lo;
+    udelay(DELAY);
+    SCL_Hi;
+    udelay(DELAY);
+    SCL_Lo;
+    */
+
+	i2c_emul_stop();
+
+    return ret;
+}
+
+int i2c_emul_write(unsigned char dev_addr,unsigned char reg_addr , unsigned char reg_val)
+{
+	int ret;
+	
+    dbg("[i2c-emul] Enter %s\n",__FUNCTION__);
+    
+	i2c_emul_start();
+	
+	if(doAddress(dev_addr, 0) < 0)
+	{
+	    return -1;
+	}
+		
+	ret = i2c_emul_outb(reg_addr);
+	if(ret < 0)
+	{
+	    dbg("[i2c-emul] error in writing reg_addr\n");
+	    return -1;
+	}
+    else
+    {
+        if((ret = i2c_emul_outb(reg_val)) < 0)
+        {
+            dbg("[i2c-emul] error in writing reg_val\n");
+            return -1;
+        }
+    }
+	
+	i2c_emul_stop();
+	return 0;
+}
+
+//EXPORT_SYMBOL(i2c_init);
+//EXPORT_SYMBOL(i2c_xfer);
diff -Nur linux-2.6.29/sound/soc/codecs/i2c-emul.h linux-2.6.29-spica/sound/soc/codecs/i2c-emul.h
--- linux-2.6.29/sound/soc/codecs/i2c-emul.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/codecs/i2c-emul.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,6 @@
+int i2c_emul_init(void);
+int i2c_emul_write(unsigned char addr, unsigned char reg, unsigned char val);
+int i2c_emul_read(unsigned char addr, unsigned char reg, unsigned char* val);
+int i2c_emul_test(void);
+void gpio_test(void);
+
diff -Nur linux-2.6.29/sound/soc/codecs/Kconfig linux-2.6.29-spica/sound/soc/codecs/Kconfig
--- linux-2.6.29/sound/soc/codecs/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/sound/soc/codecs/Kconfig	2010-05-06 12:42:45.684270633 +0700
@@ -58,9 +58,18 @@
 config SND_SOC_AD73311
 	tristate
 
+config SND_SOC_AK4671
+	tristate
+
 config SND_SOC_AK4535
 	tristate
 
+config SND_SOC_WM8580
+	tristate
+
+config SND_SOC_LM49350
+	tristate
+
 # Cirrus Logic CS4270 Codec
 config SND_SOC_CS4270
 	tristate
diff -Nur linux-2.6.29/sound/soc/codecs/lm49350.c linux-2.6.29-spica/sound/soc/codecs/lm49350.c
--- linux-2.6.29/sound/soc/codecs/lm49350.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/codecs/lm49350.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,1725 @@
+
+/* LM49350 modified */
+
+/*
+ * wm8753.c  --  WM8753 ALSA Soc Audio driver
+ *
+ * Copyright 2003 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * Notes:
+ *  The WM8753 is a lopw power, high quality stereo codec with integrated PCM
+ *  codec designed for portable digital telephony applications.
+ *
+ * Dual DAI:-
+ *
+ * This driver support 2 DAI PCM's. This makes the default PCM available for
+ * HiFi audio (e.g. MP3, ogg) playback/capture and the other PCM available for
+ * voice.
+ *
+ * Please note that the voice PCM can be connected directly to a Bluetooth
+ * codec or GSM modem and thus cannot be read or written to, although it is
+ * available to be configured with snd_hw_params(), etc and kcontrols in the
+ * normal alsa manner.
+ *
+ * Fast DAI switching:-
+ *
+ * The driver can now fast switch between the DAI configurations via a
+ * an alsa kcontrol. This allows the PCM to remain open.
+ *
+ */
+ 
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <asm/div64.h>
+
+#include "lm49350.h"
+#include "i2c-emul.h"
+#include <mach/map.h>
+#include <asm/io.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <plat/regs-iic.h>
+#include <mach/hardware.h>
+
+#define AUDIO_NAME "lm49350"
+
+
+
+/*
+ * Debug
+ */
+#ifdef CONFIG_SND_DEBUG
+#define s3cdbg(x...) printk(x)
+#else
+#define s3cdbg(x...)
+#endif
+
+#define	LM_MASTER_TEST	0
+
+#define	LM_PLAY_TEST		0
+
+#if LM_PLAY_TEST
+#define	LM_REC_TEST		0
+#else 
+#define	LM_REC_TEST		1
+#endif
+
+#define	EMUL_TEST			0
+
+#define err(format, arg...) \
+	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) \
+	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) \
+	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)
+
+
+#define S3C_IICREG(x) ((x) + S3C24XX_VA_IIC)
+#define M_IDLE          0x00    // Disable Rx/Tx
+#define M_ACTIVE        0x10    // Enable  Rx/Tx
+#define MTX_START       0xF0    // Master Tx Start
+#define MTX_STOP        0xD0    // Master Tx Stop
+#define MRX_START       0xB0    // Master Rx Start
+#define MRX_STOP        0x90    // Master Rx Stop
+#define RESUME_ACK      0xA4    // clear interrupt pending bit, ACK enabled, div=16, IICCLK=PCLK/16
+#define RESUME_NO_ACK   0x24 
+
+
+static int caps_charge = 2000;
+module_param(caps_charge, int, 0);
+MODULE_PARM_DESC(caps_charge, "WM8753 cap charge time (msecs)");
+
+
+/* codec private data */
+struct lm49350_priv {
+	unsigned int sysclk;
+	unsigned int pcmclk;
+};
+/*
+ * lm49350 register cache (0x00 ~ 0xF0)
+ */
+static const u8 lm49350_reg[] = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF,	// 0x00 ~ 0x0F
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,	0xFF, 0xFF,	// 0x10 ~ 0x1F
+	0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	// 0x20 ~ 0x2F
+	0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 	// 0x30 ~ 0x3F
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 	// 0x40 ~ 0x4F
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 	// 0x50 ~ 0x5F
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 	// 0x60 ~ 0x6F
+	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  	// 0x70 ~ 0x7F
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  	// 0x80 ~ 0x8F
+	0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 	// 0x90 ~ 0x9F
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  	// 0xA0 ~ 0xAF
+	0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF,  	// 0xB0 ~ 0xBF
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  	// 0xC0 ~ 0xCF
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  	// 0xD0 ~ 0xDF
+	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 	// 0xE0 ~ 0xEF
+	0x00
+};
+
+
+/*
+ * read lm49350 register cache
+ */
+static inline unsigned int lm49350_read_reg_cache(struct snd_soc_codec *codec,
+	unsigned int reg)
+{
+	u8 *cache = codec->reg_cache;
+	if (reg < 0 || reg > (ARRAY_SIZE(lm49350_reg) + 1))
+		return -1;
+
+	s3cdbg("[lm49350] lm49350_read_reg_cache : reg 0x%x, val : 0x%x\n",reg,cache[reg]);
+	
+	return cache[reg];
+}
+
+/*
+ * write lm49350 register cache
+ */
+static inline void lm49350_write_reg_cache(struct snd_soc_codec *codec,
+	unsigned char reg, unsigned char value)
+{
+	u8 *cache = codec->reg_cache;
+	if (reg < 0 || reg > 0xF0)
+		return;
+	cache[reg] = value;
+}
+
+/*
+ * write to the WM8753 register space
+ */
+static int lm49350_write(struct snd_soc_codec *codec, unsigned char reg,
+	unsigned int value)
+{
+	u8 data[2];
+
+	s3cdbg("######### %s : reg = 0x%x, value = 0x%x\n",__FUNCTION__,reg,value);
+
+	/* data is
+	 *   D15..D9 WM8753 register offset
+	 *   D8...D0 register data
+	 */
+	//data[0] = (reg << 1) | ((value >> 8) & 0x0001);
+	//data[1] = value & 0x00ff;
+	data[0] = reg;
+	data[1] = value;
+
+	lm49350_write_reg_cache (codec, reg, value);
+	if (codec->hw_write(codec->control_data, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+static int lm49350_read(struct snd_soc_codec *codec, unsigned char* pReg,
+	unsigned char *pBuf, int count)
+{
+#if 1
+	int ret, i;
+	unsigned char addr = 0x1a;
+
+	/*
+	GPB2 - CPU_SCL
+	GPB3 - CPU_SDA
+	*/
+	//printk("   before : GPBCON = 0x%x, GPBDAT = 0x%x, GPBPU = 0x%x\n",__raw_readl(S3C_GPBCON), __raw_readl(S3C_GPBDAT),__raw_readl(S3C_GPBPU));
+	//printk("   set GPC6,7 output port \n");
+	
+#if 1
+	if (gpio_is_valid(GPIO_I2C1_SCL)) {
+		if (gpio_request(GPIO_I2C1_SCL, S3C_GPIO_LAVEL(GPIO_I2C1_SCL))) 
+			printk(KERN_ERR "Failed to request GPIO_I2C1_SCL!\n");
+		gpio_direction_output(GPIO_I2C1_SCL, 1);
+		gpio_set_value(GPIO_I2C1_SCL, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_I2C1_SCL, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB5)
+
+	if (gpio_is_valid(GPIO_I2C1_SDA)) {
+		if (gpio_request(GPIO_I2C1_SDA, S3C_GPIO_LAVEL(GPIO_I2C1_SDA))) 
+			printk(KERN_ERR "Failed to request GPIO_I2C1_SDA!\n");
+		gpio_direction_output(GPIO_I2C1_SDA, 1);
+		gpio_set_value(GPIO_I2C1_SDA, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_I2C1_SDA, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB5)
+#else
+	s3c_gpio_cfgpin(S3C_GPB2, S3C_GPB2_OUTP);
+	s3c_gpio_cfgpin(S3C_GPB3, S3C_GPB3_OUTP);
+	s3c_gpio_pullup(S3C_GPB2, 2);
+	s3c_gpio_pullup(S3C_GPB3, 2);
+#endif
+	//printk("   after : GPBCON = 0x%x, GPBDAT = 0x%x, GPBPU = 0x%x\n",__raw_readl(S3C_GPBCON), __raw_readl(S3C_GPBDAT),__raw_readl(S3C_GPBPU));
+
+
+	mdelay(10);
+	for(i = 0; i < count ; i++)
+	{
+		if((ret = i2c_emul_read(addr,pReg[i],&pBuf[i])) < 0)
+		{
+			break;
+		}
+	}
+
+
+//	writel((readl(S3C_PCLK_GATE)|(0x1 << 27) ), S3C_PCLK_GATE);	// pass IIC1
+	
+    // setup GPIO for I2C
+#if 1
+	gpio_free(GPIO_I2C1_SCL);
+	gpio_free(GPIO_I2C1_SDA);
+
+	s3c_gpio_cfgpin(GPIO_I2C1_SCL, S3C_GPIO_SFN(GPIO_I2C1_SCL_AF));	// IIC SCL (GPB5)
+	s3c_gpio_cfgpin(GPIO_I2C1_SDA, S3C_GPIO_SFN(GPIO_I2C1_SDA_AF));	// IIC SDA (GPB6)
+	s3c_gpio_setpull(GPIO_I2C1_SCL, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB5)
+	s3c_gpio_setpull(GPIO_I2C1_SDA, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB6)
+#else
+	s3c_gpio_cfgpin(S3C_GPB2, S3C_GPB2_I2C_SCL);	// IIC SCL (GPB5)
+	s3c_gpio_cfgpin(S3C_GPB3, S3C_GPB3_I2C_SDA);	// IIC SDA (GPB6)
+	s3c_gpio_pullup(S3C_GPB2, 0x2); // IIC SCL Pull-Up enable (GPB5)
+	s3c_gpio_pullup(S3C_GPB3, 0x2); // IIC SCL Pull-Up enable (GPB6)
+#endif
+
+    // config controller
+//	writel(M_IDLE, S3C_IICREG1(S3C2410_IICSTAT));
+//	writel(RESUME_ACK, S3C_IICREG1(S3C2410_IICCON));
+//	writel(0x10, S3C_IICREG1(S3C2410_IICADD));
+	
+	return i;
+#else
+	return 0;
+#endif
+}
+
+static void print_lm49350regs(struct snd_soc_codec *codec)
+{
+	unsigned char reg = 0,val = 0;
+	//int i=0;
+
+	for(reg = 0; reg<0xF0 ; reg++)
+	{
+		if(lm49350_reg[reg] != 0xFF)
+			lm49350_read(codec, &reg, &val,1);
+			//lm49350_read_reg_cache(codec,reg);
+		//printk(" 0x%x :  0x%x \r\n", reg, val);
+	}
+}
+
+#if 0
+/* Not Used */
+static int lm49350_get_dai(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+	int mode = lm49350_read_reg_cache(codec, WM8753_IOCTL);
+
+	ucontrol->value.integer.value[0] = (mode & 0xc) >> 2;
+	return 0;
+}
+
+static int lm49350_set_dai(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+	int mode = lm49350_read_reg_cache(codec, WM8753_IOCTL);
+
+    s3cdbg("%s\n",__FUNCTION__);
+
+	if (((mode &0xc) >> 2) == ucontrol->value.integer.value[0])
+		return 0;
+
+	mode &= 0xfff3;
+	mode |= (ucontrol->value.integer.value[0] << 2);
+
+	return 1;
+}
+#endif
+
+static const struct snd_kcontrol_new lm49350_snd_controls[] = {
+SOC_SINGLE("MicL Volume", LM49350_MICL_LVL, 0, 15, 0),
+SOC_SINGLE("MicR Volume", LM49350_MICR_LVL, 0, 15, 0),
+SOC_DOUBLE_R("ADC Capture Volume", LM49350_ADCL_LVL, LM49350_ADCR_LVL, 0, 63, 0),
+SOC_DOUBLE_R("DAC Playback Volume", LM49350_DACL_LVL, LM49350_DACR_LVL, 0, 63, 0),
+
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Audio Play",
+	.info = snd_soc_info_audio_play_path,
+	.put = snd_soc_put_audio_play_path,
+	.get = snd_soc_get_audio_play_path,
+},
+
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Audio Phone",
+	.info = snd_soc_info_audio_phone_path,
+	.put = snd_soc_put_audio_phone_path,
+	.get = snd_soc_get_audio_phone_path,
+},
+
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Audio Rec",
+	.info = snd_soc_info_audio_rec_path,
+	.put = snd_soc_put_audio_rec_path,
+	.get = snd_soc_get_audio_rec_path,
+},
+
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Audio Mic",
+	.info = snd_soc_info_audio_mic_path,
+	.put = snd_soc_put_audio_mic_path,
+	.get = snd_soc_get_audio_mic_path,
+}
+	
+};
+
+/* add non dapm controls */
+static int lm49350_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	s3cdbg("[lm49350] %s ++++ \n",__FUNCTION__);
+
+	for (i = 0; i < ARRAY_SIZE(lm49350_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&lm49350_snd_controls[i],codec, NULL));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+/* 
+ * _DAPM_ Controls for LM49350
+ */
+#if 0
+/* Not Used */
+static const struct snd_kcontrol_new lm49350_hp_left_mixer_controls[] ={
+};
+
+static const struct snd_kcontrol_new lm49350_hp_right_mixer_controls[] ={
+};
+
+static const struct snd_kcontrol_new lm49350_aux_mixer_controls[] ={
+};
+
+static const char *lm49350_audio_map[][3] = {
+};
+
+static int lm49350_add_widgets(struct snd_soc_codec *codec)
+{
+	int i;
+
+	s3cdbg("[lm49350] %s ++++ \n",__FUNCTION__);
+	
+	for (i = 0; i < ARRAY_SIZE(lm49350_dapm_widgets); i++)
+		snd_soc_dapm_new_control(codec, &lm49350_dapm_widgets[i]);
+
+	/* set up the LM49350 audio map */
+	for (i = 0; lm49350_audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, lm49350_audio_map[i][0],
+			lm49350_audio_map[i][1], lm49350_audio_map[i][2]);
+	}
+
+	snd_soc_dapm_new_widgets(codec);
+
+	s3cdbg("	snd_soc_dapm_new_widgets ++++\n");
+	return 0;
+}
+#endif
+
+/* PLL divisors */
+struct _pll_div {
+	u32 div2:1;
+	u32 n:4;
+	u32 k:24;
+};
+
+/* The size in bits of the pll divide multiplied by 10
+ * to allow rounding later */
+#if 0
+/* Not Used */
+#define FIXED_PLL_SIZE ((1 << 22) * 10)
+
+static void pll_factors(struct _pll_div *pll_div, unsigned int target,
+	unsigned int source)
+{
+	u64 Kpart;
+	unsigned int K, Ndiv, Nmod;
+
+    s3cdbg("[lm49350] pll_factors \n");
+
+	Ndiv = target / source;
+	if (Ndiv < 6) {
+		source >>= 1;
+		pll_div->div2 = 1;
+		Ndiv = target / source;
+	} else
+		pll_div->div2 = 0;
+
+	if ((Ndiv < 6) || (Ndiv > 12))
+		printk(KERN_WARNING
+			"WM8753 N value outwith recommended range! N = %d\n",Ndiv);
+
+	pll_div->n = Ndiv;
+	Nmod = target % source;
+	Kpart = FIXED_PLL_SIZE * (long long)Nmod;
+
+	do_div(Kpart, source);
+
+	K = Kpart & 0xFFFFFFFF;
+
+	/* Check if we need to round */
+	if ((K % 10) >= 5)
+		K += 5;
+
+	/* Move down to proper range now rounding is done */
+	K /= 10;
+
+	pll_div->k = K;
+}
+#endif
+
+static int lm49350_set_dai_pll(struct snd_soc_dai *codec_dai,
+		int pll_id, unsigned int freq_in, unsigned int freq_out)
+{
+	s3cdbg("[lm49350] %s, pll_id = %d, freq_in = %d, freq_out = %d \n",__FUNCTION__, pll_id, freq_in, freq_out);
+
+	// Off lm49350 PLLs
+	return 0;
+}
+
+struct _coeff_div {
+	u32 mclk;
+	u32 rate;
+	u8 sr:5;
+	u8 usb:1;
+};
+
+/*
+ * Clock after PLL and dividers
+ */
+static int lm49350_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	s3cdbg("%s ++++\n",__FUNCTION__);
+	return 0;
+}
+
+/*
+ * Set's ADC and Voice DAC format.
+ */
+/*
+static int lm49350_vdac_adc_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{ ... }
+*/
+
+/*
+ * Set PCM DAI bit size and sample rate.
+ */
+ static int lm49350_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	s3cdbg("[lm49350] %s ++++\n",__FUNCTION__);
+	return 0;
+}
+
+/*
+ * Set's PCM dai fmt and BCLK.
+ */
+ static int lm49350_pcm_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	return 0;
+}
+
+static int lm49350_set_dai_clkdiv(struct snd_soc_dai *codec_dai,
+		int div_id, int div)
+{
+	s3cdbg("%s ++++\n",__FUNCTION__);
+	return 0;
+}
+
+/*
+ * Set's HiFi DAC format.
+ */
+/*
+static int lm49350_hdac_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{ ... }
+*/
+
+/*
+ * Set's I2S DAI format.
+ */
+/*
+static int lm49350_i2s_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{ ... }
+*/
+
+/*
+ * Set PCM DAI bit size and sample rate.
+ */
+static int lm49350_i2s_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	s3cdbg("[lm49350] %s ++++ \n",__FUNCTION__);
+	
+	return 0;
+}
+
+static int lm49350_set_mode(struct snd_soc_dai *codec_dai,struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_codec * codec = codec_dai->codec;
+	unsigned char reg_val = 0xFF;
+	static int	last_mode = -1;
+	
+	s3cdbg("[lm49350] %s ++++,cmd = %d\n",__FUNCTION__, cmd);
+
+	if(substream->stream == last_mode)
+		return 0;
+	
+	if(substream->stream == SNDRV_PCM_STREAM_CAPTURE)	// settings for REC
+	{
+		s3cdbg("----------- set RECORD mode ------------\n");
+
+		last_mode = 1;	//capture == 1
+		
+		lm49350_write(codec,0x01,0x00);
+		lm49350_write(codec,0x02,0x00);
+		lm49350_write(codec,0x03,0x00);
+		lm49350_write(codec,0x04,0x04);
+		lm49350_write(codec,0x05,0x20);
+		lm49350_write(codec,0x07,0x00);
+		lm49350_write(codec,0x08,0x95);
+		lm49350_write(codec,0x15,0x04);
+		lm49350_write(codec,0x17,0x04);
+		lm49350_write(codec,0x20,0x30);
+		lm49350_write(codec,0x43,0x24);
+		lm49350_write(codec,0x44,0x00);
+		lm49350_write(codec,0x45,0x00);
+		lm49350_write(codec,0x60,0x05);
+		lm49350_write(codec,0x64,0x00);
+		lm49350_write(codec,0x65,0x00);
+		lm49350_write(codec,0x66,0x02);
+		lm49350_write(codec,0x80,0x04);
+		lm49350_write(codec,0x81,0x05);
+		lm49350_write(codec,0xa0,0x05);
+		lm49350_write(codec,0x00,0x03);	// chip enable, PLL 1 enable
+	}
+	else		// settings for PLAY
+	{
+		s3cdbg("-----------set PLAY mode  ------------\n");
+
+		last_mode = 0; 	// play == 0
+		
+		lm49350_write(codec,0x01,0x00);	// select  MCLK 
+		lm49350_write(codec,0x02,0x00);	// PMC_CLK_DIV = 1
+		lm49350_write(codec,0x03,0x02);	// PLL1_CLK = PORT2_CLK
+		lm49350_write(codec,0x05,0x7D);	// PLL1 DIVIDER = 7D
+		lm49350_write(codec,0x07,0x1F);
+	//	lm49350_write(codec,0x10,0x03);	// DAC -> LS
+	//	lm49350_write(codec,0x30,0x30);
+		
+		lm49350_write(codec,0x44,0x12);	// PORT2 RX -> DAC
+		lm49350_write(codec,0x45,0x10);	// ADC input = none, Mix clk = MCLK
+		lm49350_write(codec,0x60,0x01);	// stereo mode, RX enable
+
+		lm49350_write(codec,0x64,0x1B);	// PORT2 - 16bit	
+		lm49350_write(codec,0x65,0x02);	// Rx :  MSB, IIS mode
+		lm49350_write(codec,0x66,0x02);	// Tx : MSB, IIS mode
+
+		lm49350_write(codec,0x01,0x0);
+		
+		lm49350_write(codec,0x10,0x3);	 //DAC -> LS
+		
+		lm49350_write(codec,0x30,0x31);	// oversamling = 128, DAC clk = PLL1 clk
+		
+		reg_val = lm49350_read_reg_cache(codec,0x60);
+		reg_val |= 0x2;	
+		lm49350_write(codec,0x60,reg_val);	// RX enable
+		
+		lm49350_write(codec,0xA0,0x05);	// DAC ALC timer 48KHz
+		lm49350_write(codec,0xA8,0x33);	// DAC level 0dB
+		lm49350_write(codec,0xA9,0x33);
+		
+	// ADC
+	//	lm49350_write(codec,0x80,0x04);	// ADC HPF = 32KHz
+	//	lm49350_write(codec,0x81,0x05);	// ADC ALC timer 48KHz
+	//	lm49350_write(codec,0x89,0x33);	// ADC level 0dB
+	//	lm49350_write(codec,0x8A,0x33);
+
+	// DAC
+	//	lm49350_write(codec,0xA0,0x05);	// DAC ALC timer 48KHz
+	//	lm49350_write(codec,0xA8,0x33);	// DAC level 0dB
+	//	lm49350_write(codec,0xA9,0x33);
+		lm49350_write(codec,0x00,0x03);	// chip enable, PLL 1 enable
+	}
+	
+	return 0;
+}
+static int lm49350_mode1v_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec * codec = codec_dai->codec;
+	unsigned char reg_val = 0xFF;
+	
+	
+	s3cdbg("[lm49350] %s ++++,fmt = %d\n",__FUNCTION__, fmt);
+
+	reg_val = lm49350_read_reg_cache(codec, 0x60);
+	reg_val |= 0x4;	
+	lm49350_write(codec,0x60,reg_val);	// Tx enable
+	
+	lm49350_write(codec,0x80,0x04);	// ADC HPF = 32KHz
+	lm49350_write(codec,0x81,0x05);	// ADC ALC timer 48KHz
+	lm49350_write(codec,0x89,0x33);	// ADC level 0dB
+	lm49350_write(codec,0x8A,0x33);
+	return 0;
+}
+
+static int lm49350_mode1h_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+#if 0
+	struct snd_soc_codec * codec = codec_dai->codec;
+	unsigned char reg_val = 0xFF;
+
+	s3cdbg("\n[lm49350] %s ++++, fmt = %d\n",__FUNCTION__,fmt);
+#if 0
+	// set path : PORT2 -> SPK
+	lm49350_write(codec,0x01,0x0);
+	lm49350_write(codec,0x10,0x3);
+	lm49350_write(codec,0x44,0x12);
+	lm49350_write(codec,0x60,0x1B);
+	
+	lm49350_write(codec,0x61,0x05);
+	lm49350_write(codec,0x62,0x0D);
+	lm49350_write(codec,0x63,0x07);
+	lm49350_write(codec,0x64,0x1B);
+	lm49350_write(codec,0x65,0x02);
+	lm49350_write(codec,0x31,0x02);
+	
+	lm49350_write(codec,0xa8,0x30);
+	lm49350_write(codec,0xa9,0x30);
+	lm49350_write(codec,0x00,0x1);
+#endif
+#if !LM_REC_TEST		// play test
+// play
+	lm49350_write(codec,0x01,0x0);
+	lm49350_write(codec,0x10,0x3);	 //DAC -> LS
+
+	lm49350_write(codec,0x30,0x31);	// oversamling = 128, DAC clk = PLL1 clk
+	
+	reg_val = lm49350_read_reg_cache(codec,0x60);
+	reg_val |= 0x2;	
+	lm49350_write(codec,0x60,reg_val);	// RX enable
+	
+	lm49350_write(codec,0xA0,0x05);	// DAC ALC timer 48KHz
+	lm49350_write(codec,0xA8,0x33);	// DAC level 0dB
+	lm49350_write(codec,0xA9,0x33);
+
+// record	
+	lm49350_write(codec,0x15,0x0C);	// MicR -> ADC R, MicL -> ADC L
+	lm49350_write(codec,0x20,0x30);	// stereo mode, ADC clk = PLL1
+	lm49350_write(codec,0x43,0x24);	// ADC R -> Port 2 Right Tx
+	
+	reg_val = lm49350_read_reg_cache(codec, 0x60);
+	reg_val |= 0x4;	
+	lm49350_write(codec,0x60,reg_val);	// Tx enable
+	
+	lm49350_write(codec,0x80,0x04);	// ADC HPF = 32KHz
+	lm49350_write(codec,0x81,0x05);	// ADC ALC timer 48KHz
+	lm49350_write(codec,0x89,0x33);	// ADC level 0dB
+	lm49350_write(codec,0x8A,0x33);
+
+// PLL enable
+	lm49350_write(codec,0x00,0x3);
+
+#else	// rec test
+#endif
+#endif
+	//print_lm49350regs(codec);
+	
+	s3cdbg("\n[lm49350] %s ++++, fmt = %d\n",__FUNCTION__,fmt);
+
+	return 0;
+}
+
+static int lm49350_mute(struct snd_soc_dai *dai, int mute)
+{
+	return 0;
+}
+
+static int lm49350_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		/* set vmid to 50k and unmute dac */
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		/* set vmid to 5k for quick power up */
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		/* mute dac and set vmid to 500k, enable VREF */
+		break;
+	case SND_SOC_BIAS_OFF:
+		break;
+	}
+	codec->bias_level = level;
+	return 0;
+}
+
+
+int lm49350_set_play_path(struct snd_soc_dai *codec_dai, int path,int val)
+{
+#if EMUL_TEST
+	struct snd_soc_codec *codec = codec_dai->codec;
+#endif
+	
+	s3cdbg("%s ++++ (path = %d, val = %d)\n", __FUNCTION__, path,val);
+
+#if EMUL_TEST
+		//write register (path : reg addr)
+	lm49350_write(codec,path,val);
+#endif
+
+	return 0;
+}
+int lm49350_set_phone_path(struct snd_soc_dai *codec_dai, int path, int val)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	
+	s3cdbg("%s ++++ (path = %d,val = %d)\n", __FUNCTION__, path,val);
+
+#if EMUL_TEST
+	if(path == 0)
+	{
+		s3cdbg(" PHONE PATH : GPB 2,3  GPIO TEST \n");
+		gpio_test();		
+	}
+	else if(path ==1)
+	{
+		s3cdbg(" PHONE PATH : EMULATION TEST \n");
+		i2c_emul_test();
+	}
+	else if(path == 2)
+	{
+		s3cdbg(" PHONE PATH : READ LM49350 Registers \n");
+		//print_lm49350regs(codec);
+	}
+	else if(path == 3)
+	{
+		s3cdbg(" PHONE PATH : SET GPB2,3 as I2C PORT \n");
+		s3c_gpio_cfgpin(GPIO_I2C1_SCL, S3C_GPIO_SFN(GPIO_I2C1_SCL_AF));	// IIC SCL (GPB5)
+		s3c_gpio_cfgpin(GPIO_I2C1_SDA, S3C_GPIO_SFN(GPIO_I2C1_SDA_AF));	// IIC SDA (GPB6)
+		s3c_gpio_setpull(GPIO_I2C1_SCL, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB5)
+		s3c_gpio_setpull(GPIO_I2C1_SDA, S3C_GPIO_PULL_UP); // IIC SCL Pull-Up enable (GPB6)
+	}
+	else if(path == 4)
+	{
+		if(val = 1)
+		{
+			s3cdbg("AUDIO_BT_SEL_SET\n");
+			AUDIO_BT_SEL_SET;
+		}
+		else
+		{
+			s3cdbg("AUDIO_BT_SEL_CLR\n");
+			AUDIO_BT_SEL_CLR;
+		}
+	}
+#if 0
+	else if(path ==5)
+	{
+		if(val = 1)
+		{
+			s3cdbg("RCV_SEL_SET\n");
+			RCV_SEL_SET;
+		}
+		else
+		{
+			s3cdbg("RCV_SEL_CLR\n");
+			RCV_SEL_CLR;
+		}
+	}
+#endif
+#endif
+
+	if(path == 0)
+	{
+		lm49350_write(codec,0x13,0x20);
+		lm49350_write(codec,0x18,0x00);	 //
+		lm49350_write(codec,0x19,0x00);
+
+//		RCV_SEL_CLR;		
+		AUDIO_BT_SEL_CLR;
+	}
+	else
+	{
+		CODEC_CLK_EN_SET;
+
+		// MSM -> AUXL,R is difference signal
+		// so use AUX L only
+		lm49350_write(codec,0x00,0x01);
+		lm49350_write(codec,0x01,0x00);
+		lm49350_write(codec,0x02,0x01);
+		lm49350_write(codec,0x18,0x27);	 //
+		lm49350_write(codec,0x19,0x80);
+		lm49350_write(codec,0xfe,0x20);
+		
+		if(path & OUT_SPK)
+		{
+			s3cdbg(" PHONE PATH : OUT_SPK\n");	
+			lm49350_write(codec,0x10,0x20);
+			
+		}
+		if(path & OUT_EAR)
+		{	
+			s3cdbg(" PHONE PATH : OUT_EAR\n");	
+			lm49350_write(codec,0x11,0x20);
+			lm49350_write(codec,0x12,0x20);
+		}
+		if(path & OUT_RCV)	// OUT_SPK
+		{
+			s3cdbg(" PHONE PATH : OUT_RCV\n");
+
+			// MSM -> AUXL,R is difference signal
+			// so use AUX L only
+			//lm49350_write(codec,0x00,0x01);
+			//lm49350_write(codec,0x01,0x00);
+			//lm49350_write(codec,0x02,0x01);
+			lm49350_write(codec,0x13,0x20);
+			//lm49350_write(codec,0x18,0x27);	 //
+			//lm49350_write(codec,0x19,0x80);
+			//lm49350_write(codec,0xfe,0x20);
+
+			// AUDIO_BT_SEL : High
+//	       	RCV_SEL_SET;
+			AUDIO_BT_SEL_SET;		
+
+			//print_lm49350regs(codec);
+		
+		}
+		else if(path & OUT_BT)
+		{
+			s3cdbg(" PHONE PATH : OUT_BT\n");	
+		}
+	}
+	return 0;
+}
+
+int lm49350_set_rec_path(struct snd_soc_dai *codec_dai, int path)
+{
+	s3cdbg("%s ++++ (path = %d\n", __FUNCTION__, path);
+	return 0;
+}
+
+int lm49350_set_mic_path(struct snd_soc_dai *codec_dai, int path)
+{
+	s3cdbg("%s ++++ (path = %d\n", __FUNCTION__, path);
+	if(path == 0)
+	{
+	}
+	else
+	{
+		if (path & MIC_MAIN)
+		{
+			s3cdbg(" MIC PATH : MIC_MAIN\n");
+			// key mic select
+			/*  mic bias enable */
+			VBIAS_EN_SET;
+
+			/*select  key_mic */
+			MIC_SEL_SET;
+		}
+		else if (path & MIC_EAR)
+		{
+			s3cdbg(" MIC PATH : MIC_EAR\n");
+			// ear mic select
+			/*  mic bias enable */
+			VBIAS_EN_SET;
+
+			/*select  key_mic */
+			MIC_SEL_CLR;
+		}
+		else if (path & MIC_CAM)
+		{
+			s3cdbg(" MIC PATH : MIC_CAM\n");
+		}
+		else if (path & MIC_BT)
+		{
+			s3cdbg(" MIC PATH : MIC_BT\n");
+		}
+	}
+	return 0;
+}
+
+int lm49350_ioctl(struct snd_soc_dai *codec_dai, int cmd, int arg1, int arg2)
+{
+	printk("%s ++++ (cmd = %d, arg1 = %d) \n",__FUNCTION__, cmd, arg1);
+
+	/* cmd
+		0 - play path
+		1 - phone path
+		2 - rec path
+		3 - mic path
+	*/
+	switch(cmd)
+	{
+		case AUDIO_IOCTL_PLAY_PATH:
+			lm49350_set_play_path(codec_dai,arg1,arg2);
+			break;
+
+		case AUDIO_IOCTL_PHONE_PATH:
+			lm49350_set_phone_path(codec_dai,arg1,arg2);
+			break;
+			
+		case AUDIO_IOCTL_REC_PATH:
+			lm49350_set_rec_path(codec_dai,arg1);
+			break;
+			
+		case AUDIO_IOCTL_MIC_PATH:
+			lm49350_set_mic_path(codec_dai,arg1);
+			break;
+
+		default:
+			s3cdbg("[lm49350] unused IOCTL command!! \n");
+		
+	}
+
+	return 0;
+}
+
+
+#define LM49350_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+		SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | \
+		SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+#define LM49350_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+static const struct snd_soc_dai lm49350_all_dai[] = {
+/* DAI HiFi mode 1 */
+{	.name = "LM49350 HiFi",
+	.id = 1,
+	.playback = {
+		.stream_name = "HiFi Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LM49350_RATES,
+		.formats = LM49350_FORMATS,},
+	.capture = { /* dummy for fast DAI switching */
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LM49350_RATES,
+		.formats = LM49350_FORMATS,},
+	.ops = {
+		.hw_params = lm49350_i2s_hw_params,
+	},
+	.dai_ops = {
+		.digital_mute = lm49350_mute,
+		.set_fmt = lm49350_mode1h_set_dai_fmt,
+		.set_clkdiv = lm49350_set_dai_clkdiv,
+		.set_pll = lm49350_set_dai_pll,
+		.set_sysclk = lm49350_set_dai_sysclk,
+		.set_mode = lm49350_set_mode,
+		.ioctl = lm49350_ioctl,
+	},
+},
+/* DAI Voice mode 1 */
+{	.name = "LM49350 Voice",
+	.id = 1,
+	.playback = {
+		.stream_name = "Voice Playback",
+		.channels_min = 1,
+		.channels_max = 1,
+		.rates = LM49350_RATES,
+		.formats = LM49350_FORMATS,},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LM49350_RATES,
+		.formats = LM49350_FORMATS,},
+	.ops = {
+		.hw_params = lm49350_pcm_hw_params,},
+	.dai_ops = {
+		.digital_mute = lm49350_mute,
+		.set_fmt = lm49350_mode1v_set_dai_fmt,
+		.set_clkdiv = lm49350_set_dai_clkdiv,
+		.set_pll = lm49350_set_dai_pll,
+		.set_sysclk = lm49350_set_dai_sysclk,
+		.set_mode = lm49350_set_mode,
+	},
+}
+};
+
+struct snd_soc_dai lm49350_dai[2];
+EXPORT_SYMBOL_GPL(lm49350_dai);
+
+static void lm49350_set_dai_mode(struct snd_soc_codec *codec, unsigned int mode)
+{
+	s3cdbg("\n[lm49350] %s ++++, mode = %d  ##################\n",__FUNCTION__,mode);
+	
+	if (mode < 4) {
+		int playback_active, capture_active, codec_active, pop_wait;
+		void *private_data;
+
+		playback_active = lm49350_dai[0].playback.active;
+		capture_active = lm49350_dai[0].capture.active;
+		codec_active = lm49350_dai[0].active;
+		private_data = lm49350_dai[0].private_data;
+		pop_wait = lm49350_dai[0].pop_wait;
+		lm49350_dai[0] = lm49350_all_dai[mode << 1];
+		lm49350_dai[0].playback.active = playback_active;
+		lm49350_dai[0].capture.active = capture_active;
+		lm49350_dai[0].active = codec_active;
+		lm49350_dai[0].private_data = private_data;
+		lm49350_dai[0].pop_wait = pop_wait;
+
+		playback_active = lm49350_dai[1].playback.active;
+		capture_active = lm49350_dai[1].capture.active;
+		codec_active = lm49350_dai[1].active;
+		private_data = lm49350_dai[1].private_data;
+		pop_wait = lm49350_dai[1].pop_wait;
+		lm49350_dai[1] = lm49350_all_dai[(mode << 1) + 1];
+		lm49350_dai[1].playback.active = playback_active;
+		lm49350_dai[1].capture.active = capture_active;
+		lm49350_dai[1].active = codec_active;
+		lm49350_dai[1].private_data = private_data;
+		lm49350_dai[1].pop_wait = pop_wait;
+	}
+	lm49350_dai[0].codec = codec;
+	lm49350_dai[1].codec = codec;
+}
+
+static void lm49350_work(struct work_struct *work)
+{
+	struct snd_soc_codec *codec =
+		container_of(work, struct snd_soc_codec, delayed_work.work);
+
+	s3cdbg("[lm49350] %s ++++ \n",__FUNCTION__);
+	lm49350_set_bias_level(codec, SND_SOC_BIAS_OFF);
+}
+static int lm49350_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	s3cdbg("[lm49350] %s ++++ \n",__FUNCTION__);
+
+	/* we only need to suspend if we are a valid card */
+	if(!codec->card)
+		return 0;
+		
+	lm49350_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int lm49350_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int i;
+	u8 data[2];
+	u16 *cache = codec->reg_cache;
+
+    s3cdbg("[lm49350] %s ++++ \n",__FUNCTION__);
+	/* we only need to resume if we are a valid card */
+	if(!codec->card)
+		return 0;
+
+	/* Sync reg_cache with the hardware */
+	for (i = 0; i < ARRAY_SIZE(lm49350_reg); i++) {
+		if (i + 1 == WM8753_RESET)
+			continue;
+		data[0] = ((i + 1) << 1) | ((cache[i] >> 8) & 0x0001);
+		data[1] = cache[i] & 0x00ff;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+
+	lm49350_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	/* charge lm49350 caps */
+	if (codec->suspend_dapm_state == SNDRV_CTL_POWER_D0) {
+		lm49350_set_bias_level(codec, SND_SOC_BIAS_PREPARE);
+		codec->dapm_state = SNDRV_CTL_POWER_D0;
+		schedule_delayed_work(&codec->delayed_work,
+			msecs_to_jiffies(caps_charge));
+	}
+
+	return 0;
+}
+
+/*
+ * initialise the WM8753 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+#if 0
+
+
+unsigned int i2c_raw_write_snd(
+    unsigned int   SlaveAddr,   // slave address
+    unsigned char  WordAddr,    // starting slave word address
+    unsigned char*  pData,       // pdata
+    unsigned int   DataCount        // bytes to write
+    )
+{
+	int i;
+	
+	__raw_writel(M_ACTIVE, S3C_IICREG(S3C2410_IICSTAT));
+
+	// write slave address
+	__raw_writel(SlaveAddr, S3C_IICREG(S3C2410_IICDS));
+	__raw_writel(MTX_START, S3C_IICREG(S3C2410_IICSTAT));
+
+	mdelay(1);	// need delay between signals
+
+	// write i2c
+	__raw_writel(WordAddr, S3C_IICREG(S3C2410_IICDS));
+	__raw_writel(RESUME_ACK, S3C_IICREG(S3C2410_IICCON));
+
+#if 0	
+
+	mdelay(1);	// need delay between signals
+	__raw_writel(*pData, S3C_IICREG(S3C2410_IICDS));
+	__raw_writel(RESUME_ACK, S3C_IICREG(S3C2410_IICCON));
+	
+#else
+	for (i = 0; i < DataCount; i++) {
+		mdelay(1);	// need delay between signals
+		__raw_writel(pData[i], S3C_IICREG(S3C2410_IICDS));
+		__raw_writel(RESUME_ACK, S3C_IICREG(S3C2410_IICCON));
+		//printk(KERN_INFO "pData[%d]= 0x%x\n", i, pData[i]);
+	}
+#endif
+
+	mdelay(1);	// need delay between signals
+
+	__raw_writel(MTX_STOP, S3C_IICREG(S3C2410_IICSTAT));
+	__raw_writel(RESUME_ACK, S3C_IICREG(S3C2410_IICCON));
+	__raw_writel(M_IDLE, S3C_IICREG(S3C2410_IICSTAT));
+
+	mdelay(1);
+	
+	return 0;
+}
+
+unsigned int i2c_raw_read_snd(
+    unsigned int  SlaveAddr,   // slave address
+    unsigned char  WordAddr,    // starting word address
+    unsigned char*  pData,       // pdata
+    unsigned int  DataCount        // bytes to read
+    )
+{
+	unsigned char ret;
+	//unsigned long tmp;
+	
+	//tmp = __raw_readl(S3C2410_IICCON);
+	//writel(tmp | S3C2410_IICCON_ACKEN, i2c->regs + S3C2410_IICCON);
+	//printk(KERN_INFO "+I2C_Read: 0x%X, 0x%X, 0x%X, %u\n",
+	//	SlaveAddr, WordAddr, *pData, DataCount);
+	//__raw_writel(SlaveAddr, S3C_IICREG(S3C2410_IICADD));
+
+
+	// write slave address
+	__raw_writel(MTX_START, S3C_IICREG(S3C2410_IICSTAT));
+	__raw_writel(SlaveAddr, S3C_IICREG(S3C2410_IICDS));	
+
+	mdelay(1);	// need delay between signals
+
+	// write word address
+	// For setup time of SDA before SCL rising edge, rIICDS must be written
+	// before clearing the interrupt pending bit.
+	__raw_writel(WordAddr, S3C_IICREG(S3C2410_IICDS));
+	// clear interrupt pending bit (resume)
+	__raw_writel(RESUME_NO_ACK, S3C_IICREG(S3C2410_IICCON));
+
+	//printk(KERN_INFO "SET_READ_ADDR  0x%X\n", WordAddr);
+	mdelay(1);	// need delay between signals
+
+	__raw_writel(MTX_STOP, S3C_IICREG(S3C2410_IICSTAT));
+	__raw_writel(RESUME_NO_ACK, S3C_IICREG(S3C2410_IICCON));
+
+
+	// get read data
+
+	mdelay(1);	// need delay between signals
+
+	__raw_writel((SlaveAddr+1), S3C_IICREG(S3C2410_IICDS));
+	__raw_writel(MRX_START, S3C_IICREG(S3C2410_IICSTAT));
+
+	mdelay(10);	// this is critical !!
+
+	__raw_writel(RESUME_NO_ACK, S3C_IICREG(S3C2410_IICCON));
+
+	mdelay(1);
+
+	ret = __raw_readl(S3C_IICREG(S3C2410_IICDS));
+	//printk(KERN_INFO "Read IIC Data(0x%X)\n", ret);
+
+	//The pending bit will not be set after issuing stop condition.
+	__raw_writel(MRX_STOP, S3C_IICREG(S3C2410_IICSTAT));
+	__raw_writel(RESUME_NO_ACK, S3C_IICREG(S3C2410_IICCON));
+
+	__raw_writel(M_IDLE, S3C_IICREG(S3C2410_IICSTAT));
+
+	mdelay(1);	// this is critial to consecutive read operation
+
+
+	return (unsigned int)ret;
+}
+#endif
+#if 0
+unsigned char sensor_read(struct i2c_client *client, unsigned char subaddr)
+{
+	int ret;
+	unsigned char buf[1];
+	struct i2c_msg msg = { client->addr, 0, 1, buf };
+	buf[0] = subaddr;
+
+	//printk("sensor_read \n");
+
+	ret = i2c_transfer(client->adapter, &msg, 1) == 1 ? 0 : -EIO;
+	if (ret == -EIO) {
+		printk(" I2C write Error \n");
+		return -EIO;
+	}
+
+	msg.flags = I2C_M_RD;
+	ret = i2c_transfer(client->adapter, &msg, 1) == 1 ? 0 : -EIO;
+
+	return buf[0];
+}
+#endif
+
+static void lm49350_reset(struct snd_soc_codec *codec)
+{
+	//struct snd_soc_codec *codec = socdev->codec;
+#if 0
+	int ret = -1;
+	unsigned char buf[5] ;
+	unsigned char regs[] = { 0x00, 0x01, 0x10,0x18,0x19 };
+#endif
+
+	s3cdbg("[lm49350] %s ++++ \n",__FUNCTION__);
+
+	CODEC_CLK_EN_SET;
+
+#if 0
+
+	/*  mic bias enable */
+	VBIAS_EN_SET;
+
+	// for key_mic test
+	MIC_SEL_SET;
+	
+		
+
+#if LM_MASTER_TEST
+	lm49350_write(codec,0x01,0x00);
+	lm49350_write(codec,0x02,0x00);
+	lm49350_write(codec,0x10,0x03);
+	lm49350_write(codec,0x18,0x00);
+	lm49350_write(codec,0x19,0x00);
+	lm49350_write(codec,0x31,0x01);
+	lm49350_write(codec,0x44,0x12);	// path: PORT2 LR -> DAC LR
+
+//	lm49350_write(codec,0x54,0x00);	// default 24bit
+//	lm49350_write(codec,0x54,0x1B);	// PORT1 - 16bit
+	lm49350_write(codec,0x60,0x1B);	// Rx enable, clock enable
+//	lm49350_write(codec,0x60,0x1F);	// Rx,Tx enable, clock disable
+	
+	
+	lm49350_write(codec,0x61,0x07);
+	lm49350_write(codec,0x62,0x00);
+	lm49350_write(codec,0x63,0x07);
+//	lm49350_write(codec,0x64,0x00);	// 24bit	
+	lm49350_write(codec,0x64,0x1B);	// PORT2 - 16bit
+//	lm49350_write(codec,0x64,0x3F);	// 8bit
+	lm49350_write(codec,0x65,0x02);	// Rx -  IIS/PCM short  mode
+	lm49350_write(codec,0x66,0x02);	// Tx -  IIS/PCM short  mode
+
+	
+	lm49350_write(codec,0xa8,0x33);	// volume
+	lm49350_write(codec,0xa9,0x33);
+/*	
+	lm49350_write(codec,0x30,0x20);	// for slave test
+	lm49350_write(codec,0x60,0x1F);	//Rx,Tx enable -> for slave test
+	lm49350_write(codec,0x01,0x02);
+*/	
+	lm49350_write(codec,0x00,0x1);
+#else	
+
+#if !LM_REC_TEST		// play test
+	printk("----------- PLAY TEST ------------\n");
+	lm49350_write(codec,0x01,0x00);	// select  MCLK 
+	lm49350_write(codec,0x02,0x00);	// PMC_CLK_DIV = 1
+	lm49350_write(codec,0x03,0x02);	// PLL1_CLK = PORT2_CLK
+	lm49350_write(codec,0x05,0x7D);	// PLL1 DIVIDER = 7D
+	lm49350_write(codec,0x07,0x1F);
+//	lm49350_write(codec,0x10,0x03);	// DAC -> LS
+//	lm49350_write(codec,0x30,0x30);
+	
+	lm49350_write(codec,0x44,0x12);	// PORT2 RX -> DAC
+	lm49350_write(codec,0x45,0x10);	// ADC input = none, Mix clk = MCLK
+	lm49350_write(codec,0x60,0x01);	// stereo mode, RX enable
+
+	lm49350_write(codec,0x64,0x1B);	// PORT2 - 16bit	
+	lm49350_write(codec,0x65,0x02);	// Rx :  MSB, IIS mode
+	lm49350_write(codec,0x66,0x02);	// Tx : MSB, IIS mode
+
+// ADC
+//	lm49350_write(codec,0x80,0x04);	// ADC HPF = 32KHz
+//	lm49350_write(codec,0x81,0x05);	// ADC ALC timer 48KHz
+//	lm49350_write(codec,0x89,0x33);	// ADC level 0dB
+//	lm49350_write(codec,0x8A,0x33);
+
+// DAC
+//	lm49350_write(codec,0xA0,0x05);	// DAC ALC timer 48KHz
+//	lm49350_write(codec,0xA8,0x33);	// DAC level 0dB
+//	lm49350_write(codec,0xA9,0x33);
+	lm49350_write(codec,0x00,0x03);	// chip enable, PLL 1 enable
+
+#else	//rec test
+	printk("----------- RECORD TEST ------------\n");
+	lm49350_write(codec,0x01,0x00);
+	lm49350_write(codec,0x02,0x00);
+	lm49350_write(codec,0x03,0x00);
+	lm49350_write(codec,0x04,0x04);
+	lm49350_write(codec,0x05,0x20);
+	lm49350_write(codec,0x07,0x00);
+	lm49350_write(codec,0x08,0x95);
+	lm49350_write(codec,0x15,0x04);
+	lm49350_write(codec,0x17,0x04);
+	lm49350_write(codec,0x20,0x30);
+	lm49350_write(codec,0x43,0x24);
+	lm49350_write(codec,0x44,0x00);
+	lm49350_write(codec,0x45,0x00);
+	lm49350_write(codec,0x60,0x05);
+	lm49350_write(codec,0x64,0x00);
+	lm49350_write(codec,0x65,0x00);
+	lm49350_write(codec,0x66,0x02);
+	lm49350_write(codec,0x80,0x04);
+	lm49350_write(codec,0x81,0x05);
+	lm49350_write(codec,0xa0,0x05);
+	lm49350_write(codec,0x00,0x03);	// chip enable, PLL 1 enable
+	
+#endif
+
+#endif
+
+#endif	//end of #if 0
+
+/*
+	s3cdbg("============ read start !! ==============\n");
+
+	if((ret = lm49350_read(codec, &regs[0], &buf[0], 5)) < 0)
+	{
+		printk("[lm49350] %s ---- with ERROR ######### \n",__FUNCTION__);
+	}
+
+	print_lm49350regs(codec);
+*/
+	//mdelay(10000);
+
+#if 0
+/* test code */
+	printk("============ raw read/write test !! ==============\n");
+	mdelay(2000);
+	__raw_writel(M_IDLE, S3C_IICREG(S3C2410_IICSTAT));
+	__raw_writel(RESUME_ACK, S3C_IICREG(S3C2410_IICCON));
+	__raw_writel(0x10, S3C_IICREG(S3C2410_IICADD));
+		
+	i2c_raw_write_snd((0x1a<<1),0x10,&buf[0],1);
+	printk("[lm49350] %s ---- (ret = %d, rcvbuf[0] = %d) \n",__FUNCTION__,ret,buf[0]);
+	
+	
+	//msg.addr = client->addr;
+	
+	ret = i2c_raw_read_snd((0x1a<<1),0x10,&buf[0],1);
+	//printk("	p = %d\n",p);
+	printk("[lm49350] %s ---- (ret = %d, rcvbuf[0] = %d) \n",__FUNCTION__,ret,buf[0]);
+#endif
+	
+}
+ static int lm49350_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	//int reg, ret = 0;
+	int ret = 0;
+
+	s3cdbg("[lm49350] %s ++++ \n",__FUNCTION__);
+
+	codec->name = "LM49350";
+	codec->owner = THIS_MODULE;
+	codec->read = lm49350_read_reg_cache;
+	codec->write = lm49350_write;
+	codec->set_bias_level = lm49350_set_bias_level;
+	codec->dai = lm49350_dai;
+	codec->num_dai = 2;
+	codec->reg_cache_size = sizeof(lm49350_reg);
+	codec->reg_cache = kmemdup(lm49350_reg, sizeof(lm49350_reg), GFP_KERNEL);
+
+	lm49350_set_dai_mode(codec, 0);
+	
+	lm49350_reset(codec);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		printk(KERN_ERR "lm49350: failed to create pcms\n");
+		goto pcm_err;
+	}
+	
+	/* charge output caps */
+	codec->dapm_state = SNDRV_CTL_POWER_D3hot;
+	schedule_delayed_work(&codec->delayed_work,
+		msecs_to_jiffies(caps_charge));
+
+	if((ret  = lm49350_add_controls(codec)) < 0)
+	{
+		printk("add_controls returns error \n");
+	}
+
+	/* skip widget registration 
+	if ((ret = lm49350_add_widgets(codec)) < 0)
+	{
+		printk("add_widgets returns error \n");
+	}
+	*/
+	
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0) {
+      	printk(KERN_ERR "lm49350: failed to register card\n");
+		goto card_err;
+    	}
+
+	s3cdbg("[lm49350] %s ---- \n",__FUNCTION__);
+	return ret;
+
+card_err:
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+pcm_err:
+	kfree(codec->reg_cache);
+	return ret;
+
+}
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+static struct snd_soc_device *lm49350_socdev;
+
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+#define LM49350_ID		0x34
+static unsigned short lm49350_normal_i2c[] = { (LM49350_ID >> 1), I2C_CLIENT_END };
+static unsigned short lm49350_ignore[] = { 0, LM49350_ID >> 1, I2C_CLIENT_END };
+static unsigned short lm49350_i2c_probe[] = { I2C_CLIENT_END };
+
+static struct i2c_client_address_data lm49350_addr_data = {
+	.normal_i2c = lm49350_normal_i2c,
+	.ignore     = lm49350_ignore,
+	.probe      = lm49350_i2c_probe,
+};
+
+static struct i2c_client client_template;
+static struct i2c_driver lm49350_i2c_driver;
+
+static int lm49350_codec_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct snd_soc_device *socdev = lm49350_socdev;
+	struct lm49350_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
+	int ret;
+	
+	s3cdbg("[lm49350] %s  ++++ \n",__FUNCTION__);
+
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c = kmemdup(&client_template, sizeof(client_template), GFP_KERNEL);
+	if (i2c == NULL){
+		kfree(codec);
+		return -ENOMEM;
+	}
+	s3cdbg("    start i2c_set_clientdata...\n");
+	
+	i2c_set_clientdata(i2c, codec);
+	codec->control_data = i2c;
+
+    s3cdbg("    start i2c_attach_client...\n");
+	ret = i2c_attach_client(i2c);
+	if (ret < 0) {
+		err("failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
+	ret = lm49350_init(socdev);
+	if (ret < 0) {
+		err("failed to initialise WM8753\n");
+		goto err;
+	}
+	s3cdbg("[lm49350] lm49350_codec_probe -- \n");
+
+	return ret;
+
+	s3cdbg("[lm49350] %s  ---- \n",__FUNCTION__);
+err:
+	kfree(codec);
+	kfree(i2c);
+	s3cdbg("[lm49350] lm49350_codec_probe with error -- \n");
+	return ret;
+}
+
+static int lm49350_i2c_detach(struct i2c_client *client)
+{
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+	
+	s3cdbg("[lm49350] %s ++++ \n",__FUNCTION__);
+	
+	i2c_detach_client(client);
+	kfree(codec->reg_cache);
+	kfree(client);
+	return 0;
+}
+
+static int lm49350_i2c_attach(struct i2c_adapter *adap)
+{
+    s3cdbg("[lm49350] %s ++++ \n",__FUNCTION__);
+    
+	return i2c_probe(adap, &lm49350_addr_data, lm49350_codec_probe);
+}
+
+/* corgi i2c codec control layer */
+static struct i2c_driver lm49350_i2c_driver = {
+	.driver = {
+		.name = "lm49350 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+	.id =             I2C_DRIVERID_WM8753,
+	.attach_adapter = lm49350_i2c_attach,
+	.detach_client =  lm49350_i2c_detach,
+	.command =        NULL,
+};
+
+static struct i2c_client client_template = {
+	.name =   "lm49350",
+	.driver = &lm49350_i2c_driver,
+};
+#endif
+
+
+static int lm49350_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct lm49350_setup_data *setup;
+	struct snd_soc_codec *codec;
+	struct lm49350_priv *lm49350;
+	int ret = 0;
+
+    s3cdbg("[lm49350] lm49350_probe ++++ \n");
+    
+	info("lm49350 Audio Codec");
+
+#if 0
+	CODEC_CLK_EN_SET
+	
+	s3c_gpio_cfgpin(S3C_GPB2, S3C_GPB2_I2C_SCL);	// IIC SCL (GPB5)
+	s3c_gpio_cfgpin(S3C_GPB3, S3C_GPB3_I2C_SDA);	// IIC SDA (GPB6)
+	s3c_gpio_pullup(S3C_GPB2, 0x2); // IIC SCL Pull-Up enable (GPB5)
+	s3c_gpio_pullup(S3C_GPB3, 0x2); // IIC SCL Pull-Up enable (GPB6)
+#endif
+
+	//printk("EGPIO_REG0 address : 0x%08x\n", EGPIO_REG0);
+
+	setup = socdev->codec_data;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	lm49350 = kzalloc(sizeof(struct lm49350_priv), GFP_KERNEL);
+	if (lm49350 == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+
+	codec->private_data = lm49350;
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+	lm49350_socdev = socdev;
+	INIT_DELAYED_WORK(&codec->delayed_work, lm49350_work);
+
+    //ret = i2c_emul_init();
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
+		codec->hw_write = (hw_write_t)i2c_master_send;
+		s3cdbg("[lm49350] i2c_add_driver start , i2c_address = (0x%x)\n",setup->i2c_address);
+		ret = i2c_add_driver(&lm49350_i2c_driver);
+		if (ret != 0)
+			//printk(KERN_ERR "can't add i2c driver");
+			printk("[lm49350] can't add i2c driver");
+	}
+#else
+		/* Add other interfaces here */
+#endif
+	s3cdbg("[lm49350] lm49350_probe ---- \n");
+
+	return ret;
+}
+
+/*
+ * This function forces any delayed work to be queued and run.
+ */
+static int run_delayed_work(struct delayed_work *dwork)
+{
+	int ret;
+
+	/* cancel any work waiting to be queued. */
+	ret = cancel_delayed_work(dwork);
+
+	/* if there was any work waiting then we run it now and
+	 * wait for it's completion */
+	if (ret) {
+		schedule_delayed_work(dwork, 0);
+		flush_scheduled_work();
+	}
+	return ret;
+}
+
+/* power down chip */
+static int lm49350_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+    s3cdbg("[lm49350] %s ++++ \n",__FUNCTION__);
+
+	if (codec->control_data)
+		lm49350_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	run_delayed_work(&codec->delayed_work);
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
+	i2c_del_driver(&lm49350_i2c_driver);
+#endif
+	kfree(codec->private_data);
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_lm49350 = {
+	.probe = 	lm49350_probe,
+	.remove = 	lm49350_remove,
+	.suspend = 	lm49350_suspend,
+	.resume =	lm49350_resume,
+};
+
+EXPORT_SYMBOL_GPL(soc_codec_dev_lm49350);
+
+MODULE_DESCRIPTION("ASoC LM49350 driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/codecs/lm49350.h linux-2.6.29-spica/sound/soc/codecs/lm49350.h
--- linux-2.6.29/sound/soc/codecs/lm49350.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/codecs/lm49350.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,275 @@
+/*
+ * wm8753.h  --  audio driver for WM8753
+ *
+ * Copyright 2003 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#ifndef _LM49350_H
+#define _LM49350_H
+
+/* LM49350 register space */
+#define	LM49350_PMCSET	0x00
+#define	LM49350_PMCCLK	0x01
+#define	LM49350_PMCCLKDIV		0x02
+#define	LM49350_PLL1M			0x04
+#define	LM49350_PLL1N			0x05
+#define	LM49350_PLL1MOD		0x06
+#define	LM49350_PLL1P1		0x07
+#define	LM49350_PLL1P2		0x08
+#define	LM49350_PLL2M		0x09
+#define	LM49350_PLL2N		0x0A
+#define	LM49350_PLL2MOD	0x0B
+#define	LM49350_PLL2P		0x0C
+#define	LM49350_CLASSD	0x10
+#define	LM49350_HPSL		0x11
+#define	LM49350_HPSR		0x12
+#define	LM49350_AUXOUT	0x13
+#define	LM49350_OUTPUT_OP	0x14
+#define	LM49350_ADC_LVL		0x15
+#define	LM49350_MICL_LVL		0x16
+#define	LM49350_MICR_LVL		0x17
+#define	LM49350_AUXL_LVL		0x18
+#define	LM49350_AUXR_LVL		0x19
+#define	LM49350_ADC_BASIC		0x20
+#define	LM49350_ADC_CLK		0x21
+#define	LM49350_ADC_DSP		0x22
+#define	LM49350_DAC_BASIC		0x30
+#define	LM49350_DAC_CLK		0x31
+#define	LM49350_DAC_DSP		0x32
+#define	LM49350_IP_LVL1		0x40
+#define	LM49350_IP_LVL2		0x41
+#define	LM49350_OPPORT1		0x42
+#define	LM49350_OPPORT2		0x43
+#define	LM49350_OPDAC		0x44
+#define	LM49350_OPDECI	0x45
+#define	LM49350_AUD1_BASIC		0x50
+#define	LM49350_AUD1_CLKGEN1		0x51
+#define	LM49350_AUD1_CLKGEN2		0x52
+#define	LM49350_AUD1_SYNCGEN		0x53
+#define	LM49350_AUD1_DATAWD		0x54
+#define	LM49350_AUD1_RX_MODE	0x55
+#define	LM49350_AUD1_TX_MODE	0x56
+#define	LM49350_AUD2_BASIC		0x60
+#define	LM49350_AUD2_CLKGEN1		0x61
+#define	LM49350_AUD2_CLKGEN2		0x62
+#define	LM49350_AUD2_SYNCGEN		0x63
+#define	LM49350_AUD2_DATAWD		0x64
+#define	LM49350_AUD2_RX_MODE	0x65
+#define	LM49350_AUD2_TX_MODE	0x66
+#define	LM49350_ADCFX			0x70
+#define	LM49350_DACFX			0x71
+#define	LM49350_HPF			0x80
+#define	LM49350_ADC_ALC1		0x81
+#define	LM49350_ADC_ALC2		0x82
+#define	LM49350_ADC_ALC3		0x83
+#define	LM49350_ADC_ALC4		0x84
+#define	LM49350_ADC_ALC5		0x85
+#define	LM49350_ADC_ALC6		0x86
+#define	LM49350_ADC_ALC7		0x87
+#define	LM49350_ADC_ALC8		0x88
+#define	LM49350_ADCL_LVL		0x89
+#define	LM49350_ADCR_LVL		0x8A
+#define	LM49350_ADC_EQBAND1		0x8B
+#define	LM49350_ADC_EQBAND2		0x8C
+#define	LM49350_ADC_EQBAND3		0x8D
+#define	LM49350_ADC_EQBAND4		0x8E
+#define	LM49350_ADC_EQBAND5		0x8F
+#define	LM49350_ADC_SOFTCLIP1		0x90
+#define	LM49350_ADC_SOFTCLIP2		0x91
+#define	LM49350_ADC_SOFTCLIP3		0x92
+#define	LM49350_ADC_LVLMONL		0x98
+#define	LM49350_ADC_LVLMONR		0x99
+#define	LM49350_ADC_FXCLIP			0x9A
+#define	LM49350_ADC_ALCMONL		0x9B
+#define	LM49350_ADC_ALCMONR		0x9C
+#define	LM49350_DAC_ALC1		0xA0
+#define	LM49350_DAC_ALC2		0xA1
+#define	LM49350_DAC_ALC3		0xA2
+#define	LM49350_DAC_ALC4		0xA3
+#define	LM49350_DAC_ALC5		0xA4
+#define	LM49350_DAC_ALC6		0xA5
+#define	LM49350_DAC_ALC7		0xA6
+#define	LM49350_DAC_ALC8		0xA7
+#define	LM49350_DACL_LVL		0xA8
+#define	LM49350_DACR_LVL		0xA9
+#define	LM49350_DAC_3D		0xAA
+#define	LM49350_DAC_EQBAND1		0xAB
+#define	LM49350_DAC_EQBAND2		0xAC
+#define	LM49350_DAC_EQBAND3		0xAD
+#define	LM49350_DAC_EQBAND4		0xAE
+#define	LM49350_DAC_EQBAND5		0xAF
+#define	LM49350_DAC_SOFTCLIP1		0xB0
+#define	LM49350_DAC_SOFTCLIP2		0xB1
+#define	LM49350_DAC_SOFTCLIP3		0xB2
+#define	LM49350_DAC_LVLMONL		0xB8
+#define	LM49350_DAC_LVLMONR		0xB9
+#define	LM49350_DAC_FXCLIP			0xBA
+#define	LM49350_DAC_ALCMONL		0xBB
+#define	LM49350_DAC_ALCMONR		0xBC
+#define	LM49350_GPIO		0xE0
+#define	LM49350_DEBUG		0xF0
+
+
+
+/* WM8753 register space */
+
+#define WM8753_DAC		0x01
+#define WM8753_ADC		0x02
+#define WM8753_PCM		0x03
+#define WM8753_HIFI		0x04
+#define WM8753_IOCTL		0x05
+#define WM8753_SRATE1		0x06
+#define WM8753_SRATE2		0x07
+#define WM8753_LDAC		0x08
+#define WM8753_RDAC		0x09
+#define WM8753_BASS		0x0a
+#define WM8753_TREBLE		0x0b
+#define WM8753_ALC1		0x0c
+#define WM8753_ALC2		0x0d
+#define WM8753_ALC3		0x0e
+#define WM8753_NGATE		0x0f
+#define WM8753_LADC		0x10
+#define WM8753_RADC		0x11
+#define WM8753_ADCTL1		0x12
+#define WM8753_3D		0x13
+#define WM8753_PWR1		0x14
+#define WM8753_PWR2		0x15
+#define WM8753_PWR3		0x16
+#define WM8753_PWR4		0x17
+#define WM8753_ID		0x18
+#define WM8753_INTPOL		0x19
+#define WM8753_INTEN		0x1a
+#define WM8753_GPIO1		0x1b
+#define WM8753_GPIO2		0x1c
+#define WM8753_RESET		0x1f
+#define WM8753_RECMIX1		0x20
+#define WM8753_RECMIX2		0x21
+#define WM8753_LOUTM1		0x22
+#define WM8753_LOUTM2		0x23
+#define WM8753_ROUTM1		0x24
+#define WM8753_ROUTM2		0x25
+#define WM8753_MOUTM1		0x26
+#define WM8753_MOUTM2		0x27
+#define WM8753_LOUT1V		0x28
+#define WM8753_ROUT1V		0x29
+#define WM8753_LOUT2V		0x2a
+#define WM8753_ROUT2V		0x2b
+#define WM8753_MOUTV		0x2c
+#define WM8753_OUTCTL		0x2d
+#define WM8753_ADCIN		0x2e
+#define WM8753_INCTL1		0x2f
+#define WM8753_INCTL2		0x30
+#define WM8753_LINVOL		0x31
+#define WM8753_RINVOL		0x32
+#define WM8753_MICBIAS		0x33
+#define WM8753_CLOCK		0x34
+#define WM8753_PLL1CTL1		0x35
+#define WM8753_PLL1CTL2		0x36
+#define WM8753_PLL1CTL3		0x37
+#define WM8753_PLL1CTL4		0x38
+#define WM8753_PLL2CTL1		0x39
+#define WM8753_PLL2CTL2		0x3a
+#define WM8753_PLL2CTL3		0x3b
+#define WM8753_PLL2CTL4		0x3c
+#define WM8753_BIASCTL		0x3d
+#define WM8753_ADCTL2		0x3f
+
+struct wm8753_setup_data {
+	unsigned short i2c_address;
+};
+
+#define WM8753_PLL1			0
+#define WM8753_PLL2			1
+
+/* clock inputs */
+#define WM8753_MCLK		0
+#define WM8753_PCMCLK		1
+
+/* clock divider id's */
+#define WM8753_PCMDIV		0
+#define WM8753_BCLKDIV		1
+#define WM8753_VXCLKDIV		2
+
+/* PCM clock dividers */
+#define WM8753_PCM_DIV_1	(0 << 6)
+#define WM8753_PCM_DIV_3	(2 << 6)
+#define WM8753_PCM_DIV_5_5	(3 << 6)
+#define WM8753_PCM_DIV_2	(4 << 6)
+#define WM8753_PCM_DIV_4	(5 << 6)
+#define WM8753_PCM_DIV_6	(6 << 6)
+#define WM8753_PCM_DIV_8	(7 << 6)
+
+/* BCLK clock dividers */
+#define WM8753_BCLK_DIV_1	(0 << 3)
+#define WM8753_BCLK_DIV_2	(1 << 3)
+#define WM8753_BCLK_DIV_4	(2 << 3)
+#define WM8753_BCLK_DIV_8	(3 << 3)
+#define WM8753_BCLK_DIV_16	(4 << 3)
+
+/* VXCLK clock dividers */
+#define WM8753_VXCLK_DIV_1	(0 << 6)
+#define WM8753_VXCLK_DIV_2	(1 << 6)
+#define WM8753_VXCLK_DIV_4	(2 << 6)
+#define WM8753_VXCLK_DIV_8	(3 << 6)
+#define WM8753_VXCLK_DIV_16	(4 << 6)
+
+#define WM8753_DAI_HIFI		0
+#define WM8753_DAI_VOICE		1
+
+extern struct snd_soc_dai wm8753_dai[2];
+extern struct snd_soc_device soc_codec_dev_wm8753;
+
+
+struct lm49350_setup_data {
+	unsigned short i2c_address;
+};
+
+#define lm49350_DAI_HIFI		0
+#define lm49350_DAI_VOICE		1
+
+#define	MODE_PLAYBACK		0
+#define	MODE_CAPTURE		1
+extern struct snd_soc_dai lm49350_dai[2];
+extern struct snd_soc_codec_device soc_codec_dev_lm49350;
+
+
+/* audio path */
+#define AUDIO_OUT_SEL		(1 << 0)
+#define OUT_SPK			(AUDIO_OUT_SEL << 1)
+#define OUT_EAR			(AUDIO_OUT_SEL << 2)
+#define OUT_RCV			(AUDIO_OUT_SEL << 3)
+#define OUT_PHONE		(AUDIO_OUT_SEL << 4)
+#define OUT_BT			(AUDIO_OUT_SEL << 5)
+
+#define AUDIO_MIC_SEL		(1 << 8) 
+#define MIC_SEL_MASK		(MIC_MAIN|MIC_EAR|MIC_CAM|MIC_BT)
+#define MIC_MAIN		(AUDIO_MIC_SEL << 1)
+#define MIC_EAR			(AUDIO_MIC_SEL << 2)
+#define MIC_CAM			(AUDIO_MIC_SEL << 3)
+#define MIC_BT			(AUDIO_MIC_SEL << 4)
+
+#define AUDIO_REC_SEL		(1 << 16)
+#define ADC_MIC			(AUDIO_REC_SEL << 1)
+#define ADC_PHONE		(AUDIO_REC_SEL << 2)
+#define ADC_MIC_PHONE		(AUDIO_REC_SEL << 3) 
+
+#define AUDIO_PLAY		(1 << 22)
+#define AUDIO_PHONE		(AUDIO_PLAY << 1)
+#define AUDIO_REC		(AUDIO_PLAY << 2) 
+ 
+#define AUDIO_PLAY_OFF		(AUDIO_PLAY << 3) 
+#define AUDIO_PHONE_OFF		(AUDIO_PLAY << 4) 
+#define AUDIO_REC_OFF		(AUDIO_PLAY << 5) 
+ 
+#define AUDIO_AMP_ON		(AUDIO_PLAY << 6) 
+#define AUDIO_AMP_OFF		(AUDIO_PLAY << 7)
+
+#endif
diff -Nur linux-2.6.29/sound/soc/codecs/Makefile linux-2.6.29-spica/sound/soc/codecs/Makefile
--- linux-2.6.29/sound/soc/codecs/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/sound/soc/codecs/Makefile	2010-05-06 12:42:45.684270633 +0700
@@ -2,6 +2,7 @@
 snd-soc-ad1980-objs := ad1980.o
 snd-soc-ad73311-objs := ad73311.o
 snd-soc-ak4535-objs := ak4535.o
+snd-soc-ak4671-spica-objs := ak4671.o ak4671_spica.o 
 snd-soc-cs4270-objs := cs4270.o
 snd-soc-l3-objs := l3.o
 snd-soc-pcm3008-objs := pcm3008.o
@@ -25,11 +26,13 @@
 snd-soc-wm8990-objs := wm8990.o
 snd-soc-wm9712-objs := wm9712.o
 snd-soc-wm9713-objs := wm9713.o
+snd-soc-lm49350-objs := lm49350.o i2c-emul.o
 
 obj-$(CONFIG_SND_SOC_AC97_CODEC)	+= snd-soc-ac97.o
 obj-$(CONFIG_SND_SOC_AD1980)	+= snd-soc-ad1980.o
 obj-$(CONFIG_SND_SOC_AD73311) += snd-soc-ad73311.o
 obj-$(CONFIG_SND_SOC_AK4535)	+= snd-soc-ak4535.o
+obj-$(CONFIG_SND_SOC_AK4671)	+= snd-soc-ak4671-spica.o
 obj-$(CONFIG_SND_SOC_CS4270)	+= snd-soc-cs4270.o
 obj-$(CONFIG_SND_SOC_L3)	+= snd-soc-l3.o
 obj-$(CONFIG_SND_SOC_PCM3008)	+= snd-soc-pcm3008.o
@@ -53,3 +56,4 @@
 obj-$(CONFIG_SND_SOC_WM8990)	+= snd-soc-wm8990.o
 obj-$(CONFIG_SND_SOC_WM9712)	+= snd-soc-wm9712.o
 obj-$(CONFIG_SND_SOC_WM9713)	+= snd-soc-wm9713.o
+obj-$(CONFIG_SND_SOC_LM49350)   += snd-soc-lm49350.o
\      
diff -Nur linux-2.6.29/sound/soc/codecs/max9877_def.h linux-2.6.29-spica/sound/soc/codecs/max9877_def.h
--- linux-2.6.29/sound/soc/codecs/max9877_def.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/codecs/max9877_def.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,96 @@
+/*
+* ==============================================================================
+*  Name 	   : MAX9877_Def.h
+*  Part of		: audio codec driver
+*  Description : max9877 audio amp driver 
+*  Version		: 1
+*  Author		: Changoh.heo (changoh.heo@samsung.com)
+*
+*  Copyright (c) 2008 Samsung Electronics Co., Ltd.
+*  This material, including documentation and any related 
+*  computer programs, is protected by copyright controlled by 
+*  Samsung Electronics Co., Ltd. All rights are reserved. Copying, 
+*  including reproducing, storing, adapting or translating, any 
+*  or all of this material requires the prior written consent of 
+*  Samsung Electronics Co., Ltd. This material also contains confidential 
+*  information which may not be disclosed to others without the 
+*  prior written consent of Electronics Co., Ltd.
+* ==============================================================================
+*/
+
+#ifndef __MAX9877Reg_H__
+#define __MAX9877Reg_H__
+
+#define I2C_MAX9877_SLAVE_ADDR		0x9A // 1001 101R/W
+
+#define MAX9877_INPUT_MODE_CONTROL			0x00
+#define MAX9877_SPEAKER_VOLUME 				0x01
+#define MAX9877_LEFT_HEADPHONE_VOLUME 		0x02
+#define MAX9877_RIGHT_HEADPHONE_VOLUME		0x03
+#define MAX9877_OUTPUT_MODE_CONTROL			0x04
+
+/* MAX9877_INPUT_MODE_CONTROL (0x00) */
+#define ZCD						(0x1 << 6)
+#define INA						(0x1 << 5)
+#define INB						(0x1 << 4)
+#define PGAINA1					(0x1 << 3)
+#define PGAINA0					(0x1 << 2)
+#define PGAINB1					(0x1 << 1)
+#define PGAINB0					(0x1 << 0)
+#define	  PGAINB				(PGAINB0 | PGAINB1)
+#define   PGAINA				(PGAINA0 | PGAINA1)
+
+
+/* MAX9877_SPEAKER_VOLUME (0x01) */
+#define SVOL4 					(0x1 << 4)
+#define SVOL3 					(0x1 << 3)
+#define SVOL2 					(0x1 << 2)
+#define SVOL1 					(0x1 << 1)
+#define SVOL0 					(0x1 << 0)
+
+/* MAX9877_LEFT_HEADPHONE_VOLUME (0x02) */
+#define HPLVOL4					(0x1 << 4)
+#define HPLVOL3					(0x1 << 3)
+#define HPLVOL2					(0x1 << 2)
+#define HPLVOL1					(0x1 << 1)
+#define HPLVOL0					(0x1 << 0)
+
+
+/* MAX9877_LEFT_HEADPHONE_VOLUME (0x03) */
+#define HPRVOL4 				(0x1 << 4)
+#define HPRVOL3 				(0x1 << 3)
+#define HPRVOL2 				(0x1 << 2)
+#define HPRVOL1 				(0x1 << 1)
+#define HPRVOL0 				(0x1 << 0)
+#define	MAX9877_OUTPUT_MUTE		0x0
+
+/* MAX9877_LEFT_HEADPHONE_VOLUME (0x04) */
+#define SHDN					(0x1 << 7)
+#define BYPASS					(0x1 << 6)
+#define OSC1					(0x1 << 5)
+#define OSC0 					(0x1 << 4)
+#define OUTMODE3 				(0x1 << 3)
+#define OUTMODE2 				(0x1 << 2)
+#define OUTMODE1 				(0x1 << 1)
+#define OUTMODE0 				(0x1 << 0)
+#define OUTMODE 				(OUTMODE0 | OUTMODE1 | OUTMODE2 | OUTMODE3)
+
+
+#if 0
+const TUint8 KMAX9877DefaultValueTable[] =
+{
+	/*00*/0x40,/*01*/0x00,/*02*/0x00,/*03*/0x00,/*04*/0x49
+};
+#endif
+
+//0:0dB, 1:9dB, 2:20dB, 3:Reserved
+#define KMAX9877_Preamp_Gain(a) 		((a == 0) ? 0 : ((a == 9) ? 1 : ((a == 20) ? 2 : 0)))
+//24:-7dB, 25:-6dB, 26:-5dB ~ 31:0 dB
+#define KMAX9877_Output_Gain_0ToMinus7(a) 		((a  + 7) / 1) + 24
+//16:-23dB, 17:-21dB, 18:-19dB ~ 23:-9dB
+#define KMAX9877_Output_Gain_Minus9ToMinus23(a)		((a  + 23) / 2) + 16
+//8:-47dB, 9:-44dB, 10:-41dB ~ 16:-23dB
+#define KMAX9877_Output_Gain_Minus23ToMinus47(a)		((a  + 47) / 3) + 8
+//0:mute, 1:-75dB, 2:-71DB ~ 7:-51dB
+#define KMAX9877_Output_Gain_Minus51ToMUTE(a)		((a  + 79) / 4)
+#endif
diff -Nur linux-2.6.29/sound/soc/codecs/s3c_i2c.c linux-2.6.29-spica/sound/soc/codecs/s3c_i2c.c
--- linux-2.6.29/sound/soc/codecs/s3c_i2c.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/codecs/s3c_i2c.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,284 @@
+/*****************************************************************************/
+/*                                                                           */
+/* NAME    : Samsung Secondary BootLoader									 */
+/* FILE    : s3c_i2c.c														 */
+/* PURPOSE : This file implements for Nand Bootloader                        */
+/*                                                                           */
+/*---------------------------------------------------------------------------*/
+/*                                                                           */
+/*              COPYRIGHT 2008 SAMSUNG ELECTRONICS CO., LTD.                 */
+/*                      ALL RIGHTS RESERVED                                  */
+/*                                                                           */
+/*   Permission is hereby granted to licensees of Samsung Electronics        */
+/*   Co., Ltd. products to use or abstract this computer program for the     */
+/*   sole purpose of implementing a product based on Samsung                 */
+/*   Electronics Co., Ltd. products. No other rights to reproduce, use,      */
+/*   or disseminate this computer program, whether in part or in whole,      */
+/*   are granted.                                                            */
+/*                                                                           */
+/*   Samsung Electronics Co., Ltd. makes no representation or warranties     */
+/*   with respect to the performance of this computer program, and           */
+/*   specifically disclaims any responsibility for any damages,              */
+/*   special or consequential, connected with the use of this program.       */
+/*                                                                           */
+/*****************************************************************************/
+
+#if 0
+#include <asm/arch.h>
+#include <asm/command.h>
+#include <asm/util.h>
+#include <asm/error.h>
+#include <asm/main.h>
+#endif
+
+#include <asm/delay.h>
+#include <linux/kernel.h>
+
+#include <mach/hardware.h>
+#include <mach/map.h>
+#include <mach/gpio.h>
+
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <plat/gpio-bank-h.h>
+#include <plat/regs-clock.h>
+
+
+/*
+ * GPIO External I2C Emulation
+ */
+
+#define FM_I2C_FREQ		100
+
+#define FM_I2C_SCL_HIGH	gpio_set_value(GPIO_FM_I2C_SCL, GPIO_LEVEL_HIGH);
+#define FM_I2C_SCL_LOW		gpio_set_value(GPIO_FM_I2C_SCL, GPIO_LEVEL_LOW);
+#define FM_I2C_SDA_HIGH	gpio_set_value(GPIO_FM_I2C_SDA, GPIO_LEVEL_HIGH);
+#define FM_I2C_SDA_LOW		gpio_set_value(GPIO_FM_I2C_SDA, GPIO_LEVEL_LOW);
+
+static void SCLH_SDAH(u32 delay)
+{
+	FM_I2C_SCL_HIGH
+	FM_I2C_SDA_HIGH
+	udelay(delay);
+}
+
+static void SCLH_SDAL(u32 delay)
+{
+	FM_I2C_SCL_HIGH
+	FM_I2C_SDA_LOW
+	udelay(delay);
+}
+
+static void SCLL_SDAH(u32 delay)
+{
+	FM_I2C_SCL_LOW
+	FM_I2C_SDA_HIGH
+	udelay(delay);
+}
+
+static void SCLL_SDAL(u32 delay)
+{
+	FM_I2C_SCL_LOW
+	FM_I2C_SDA_LOW
+	udelay(delay);
+}
+
+static void FM_I2C_LOW(u32 delay)
+{
+	SCLL_SDAL(delay);
+	SCLH_SDAL(delay);
+	SCLH_SDAL(delay);
+	SCLL_SDAL(delay);
+}
+
+static void FM_I2C_HIGH(u32 delay)
+{
+	SCLL_SDAH(delay);
+	SCLH_SDAH(delay);
+	SCLH_SDAH(delay);
+	SCLL_SDAH(delay);
+}
+
+static void FM_I2C_START(u32 delay)
+{
+	SCLH_SDAH(delay);
+	SCLH_SDAL(delay);
+	udelay(delay);
+	SCLL_SDAL(delay);
+}
+
+static void FM_I2C_RESTART(u32 delay)
+{
+	SCLL_SDAH(delay);
+	SCLH_SDAH(delay);
+	SCLH_SDAL(delay);
+	udelay(delay);
+	SCLL_SDAL(delay);
+}
+
+static void FM_I2C_END(u32 delay)
+{
+	SCLL_SDAL(delay);
+	SCLH_SDAL(delay);
+	udelay(delay);
+	SCLH_SDAH(delay);
+}
+
+static void FM_I2C_ACK(u32 delay)
+{
+	u32 ack;
+
+	FM_I2C_SCL_LOW
+	udelay(delay);
+
+	gpio_direction_input(GPIO_FM_I2C_SDA);
+
+	FM_I2C_SCL_HIGH
+	udelay(delay);
+
+	ack = gpio_get_value(GPIO_FM_I2C_SDA);
+
+	FM_I2C_SCL_HIGH
+	udelay(delay);
+	
+	gpio_direction_output(GPIO_FM_I2C_SDA, GPIO_FM_I2C_SDA_AF);
+
+	FM_I2C_SCL_LOW
+	udelay(delay);
+
+	if(ack)
+		printk("FM_I2C -> No ACK\n");
+}
+
+void fm_i2c_read(u32 SlaveAddr, u8 WordAddr, u8 *pData)
+{
+	u32 i;
+	*pData = 0;
+
+	/* Start Conditions*/
+	FM_I2C_START(FM_I2C_FREQ);
+
+	/* Write Slave address */
+	for (i = 8; i > 1; i--) {
+		if ((SlaveAddr >> (i - 1)) & 0x1)
+			FM_I2C_HIGH(FM_I2C_FREQ);
+		else
+			FM_I2C_LOW(FM_I2C_FREQ);
+	}
+
+	FM_I2C_LOW(FM_I2C_FREQ);
+
+	FM_I2C_ACK(FM_I2C_FREQ);
+
+	/* Write Command address */
+	for (i = 8; i > 0; i--) {
+		if ((WordAddr >> (i - 1)) & 0x1)
+			FM_I2C_HIGH(FM_I2C_FREQ);
+		else
+			FM_I2C_LOW(FM_I2C_FREQ);
+	}
+
+	FM_I2C_ACK(FM_I2C_FREQ);
+
+	/* Start Conditions*/
+	FM_I2C_RESTART(FM_I2C_FREQ);
+
+	/* Write Slave address + Read bit*/
+	for (i = 8; i > 1; i--) {
+		if ((SlaveAddr >> (i - 1)) & 0x1)
+			FM_I2C_HIGH(FM_I2C_FREQ);
+		else
+			FM_I2C_LOW(FM_I2C_FREQ);
+	}
+
+	FM_I2C_HIGH(FM_I2C_FREQ);
+
+	FM_I2C_ACK(FM_I2C_FREQ);
+
+	/* Read Data */
+	for (i = 8; i > 0; i--) { 
+		FM_I2C_SCL_LOW
+		udelay(FM_I2C_FREQ);     
+		if (i == 8)
+			gpio_direction_input(GPIO_FM_I2C_SDA);
+		FM_I2C_SCL_HIGH
+		udelay(FM_I2C_FREQ);     
+
+		*pData |= (!!gpio_get_value(GPIO_FM_I2C_SDA)) << (i - 1);
+
+		FM_I2C_SCL_HIGH
+		udelay(FM_I2C_FREQ);     
+		if (i == 1) {	
+			FM_I2C_SDA_HIGH
+			gpio_direction_output(GPIO_FM_I2C_SDA, GPIO_FM_I2C_SDA_AF);
+		}
+		FM_I2C_SCL_LOW
+		udelay(FM_I2C_FREQ);     
+	}
+
+	FM_I2C_HIGH(FM_I2C_FREQ);
+
+	/* End Conditions */
+	FM_I2C_END(FM_I2C_FREQ);
+}
+
+void fm_i2c_write(u32 SlaveAddr, u8 WordAddr, u8 Data)
+{
+	u32 i;
+
+	printk("[I2C EMUL] write transfer - Addr : 0x%02x, Data = 0x%02x \n", WordAddr, Data);
+
+	FM_I2C_START(FM_I2C_FREQ);
+
+	for (i = 8; i > 1; i--) {
+		if ((SlaveAddr >> (i - 1)) & 0x1)
+			FM_I2C_HIGH(FM_I2C_FREQ);
+		else
+			FM_I2C_LOW(FM_I2C_FREQ);
+	}
+
+	FM_I2C_LOW(FM_I2C_FREQ);
+
+	FM_I2C_ACK(FM_I2C_FREQ);
+	
+	for (i = 8; i > 0; i--) {
+		if ((WordAddr >> (i - 1)) & 0x1)
+			FM_I2C_HIGH(FM_I2C_FREQ);
+		else
+			FM_I2C_LOW(FM_I2C_FREQ);
+	}
+
+	FM_I2C_ACK(FM_I2C_FREQ);
+	
+	for (i = 8; i > 0; i--) {
+		if ((Data >> (i - 1)) & 0x1)
+			FM_I2C_HIGH(FM_I2C_FREQ);
+		else
+			FM_I2C_LOW(FM_I2C_FREQ);
+	}
+
+	FM_I2C_ACK(FM_I2C_FREQ);
+
+	FM_I2C_END(FM_I2C_FREQ);
+}
+
+void fm_i2c_init(void)
+{
+	/* FM_I2C_SCL */
+	if (gpio_is_valid(GPIO_FM_I2C_SCL)) {
+		if (gpio_request(GPIO_FM_I2C_SCL, S3C_GPIO_LAVEL(GPIO_FM_I2C_SCL))) 
+			printk(KERN_ERR "Failed to request GPIO_FM_I2C_SCL!\n");
+		gpio_direction_output(GPIO_FM_I2C_SCL, GPIO_FM_I2C_SCL_AF);
+		gpio_set_value(GPIO_FM_I2C_SCL, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_FM_I2C_SCL, S3C_GPIO_PULL_NONE);
+
+	/* FM_I2C_SDA */
+	if (gpio_is_valid(GPIO_FM_I2C_SDA)) {
+		if (gpio_request(GPIO_FM_I2C_SDA, S3C_GPIO_LAVEL(GPIO_FM_I2C_SDA))) 
+			printk(KERN_ERR "Failed to request GPIO_FM_I2C_SDA!\n");
+		gpio_direction_output(GPIO_FM_I2C_SDA, GPIO_FM_I2C_SDA_AF);
+		gpio_set_value(GPIO_FM_I2C_SDA, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_FM_I2C_SDA, S3C_GPIO_PULL_NONE);
+}
diff -Nur linux-2.6.29/sound/soc/codecs/s3c_i2c_pm.c linux-2.6.29-spica/sound/soc/codecs/s3c_i2c_pm.c
--- linux-2.6.29/sound/soc/codecs/s3c_i2c_pm.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/codecs/s3c_i2c_pm.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,278 @@
+/*****************************************************************************/
+/*                                                                           */
+/* NAME    : Samsung Secondary BootLoader									 */
+/* FILE    : s3c_i2c.c														 */
+/* PURPOSE : This file implements for Nand Bootloader                        */
+/*                                                                           */
+/*---------------------------------------------------------------------------*/
+/*                                                                           */
+/*              COPYRIGHT 2008 SAMSUNG ELECTRONICS CO., LTD.                 */
+/*                      ALL RIGHTS RESERVED                                  */
+/*                                                                           */
+/*   Permission is hereby granted to licensees of Samsung Electronics        */
+/*   Co., Ltd. products to use or abstract this computer program for the     */
+/*   sole purpose of implementing a product based on Samsung                 */
+/*   Electronics Co., Ltd. products. No other rights to reproduce, use,      */
+/*   or disseminate this computer program, whether in part or in whole,      */
+/*   are granted.                                                            */
+/*                                                                           */
+/*   Samsung Electronics Co., Ltd. makes no representation or warranties     */
+/*   with respect to the performance of this computer program, and           */
+/*   specifically disclaims any responsibility for any damages,              */
+/*   special or consequential, connected with the use of this program.       */
+/*                                                                           */
+/*****************************************************************************/
+
+#include <asm/delay.h>
+#include <linux/kernel.h>
+
+#include <mach/hardware.h>
+#include <mach/map.h>
+#include <mach/gpio.h>
+
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <plat/gpio-bank-h.h>
+#include <plat/regs-clock.h>
+
+
+/*
+ * GPIO External I2C Emulation
+ */
+
+#define PWR_I2C_FREQ		100
+
+#define PWR_I2C_SCL_HIGH		gpio_set_value(GPIO_PWR_I2C_SCL, GPIO_LEVEL_HIGH);
+#define PWR_I2C_SCL_LOW		gpio_set_value(GPIO_PWR_I2C_SCL, GPIO_LEVEL_LOW);
+#define PWR_I2C_SDA_HIGH		gpio_set_value(GPIO_PWR_I2C_SDA, GPIO_LEVEL_HIGH);
+#define PWR_I2C_SDA_LOW		gpio_set_value(GPIO_PWR_I2C_SDA, GPIO_LEVEL_LOW);
+
+static void SCLH_SDAH(u32 delay)
+{
+	PWR_I2C_SCL_HIGH
+	PWR_I2C_SDA_HIGH
+	udelay(delay);
+}
+
+static void SCLH_SDAL(u32 delay)
+{
+	PWR_I2C_SCL_HIGH
+	PWR_I2C_SDA_LOW
+	udelay(delay);
+}
+
+static void SCLL_SDAH(u32 delay)
+{
+	PWR_I2C_SCL_LOW
+	PWR_I2C_SDA_HIGH
+	udelay(delay);
+}
+
+static void SCLL_SDAL(u32 delay)
+{
+	PWR_I2C_SCL_LOW
+	PWR_I2C_SDA_LOW
+	udelay(delay);
+}
+
+static void PWR_I2C_LOW(u32 delay)
+{
+	SCLL_SDAL(delay);
+	SCLH_SDAL(delay);
+	SCLH_SDAL(delay);
+	SCLL_SDAL(delay);
+}
+
+static void PWR_I2C_HIGH(u32 delay)
+{
+	SCLL_SDAH(delay);
+	SCLH_SDAH(delay);
+	SCLH_SDAH(delay);
+	SCLL_SDAH(delay);
+}
+
+static void PWR_I2C_START(u32 delay)
+{
+	SCLH_SDAH(delay);
+	SCLH_SDAL(delay);
+	udelay(delay);
+	SCLL_SDAL(delay);
+}
+
+static void PWR_I2C_RESTART(u32 delay)
+{
+	SCLL_SDAH(delay);
+	SCLH_SDAH(delay);
+	SCLH_SDAL(delay);
+	udelay(delay);
+	SCLL_SDAL(delay);
+}
+
+static void PWR_I2C_END(u32 delay)
+{
+	SCLL_SDAL(delay);
+	SCLH_SDAL(delay);
+	udelay(delay);
+	SCLH_SDAH(delay);
+}
+
+static void PWR_I2C_ACK(u32 delay)
+{
+	u32 ack;
+
+	PWR_I2C_SCL_LOW
+	udelay(delay);
+
+	gpio_direction_input(GPIO_PWR_I2C_SDA);
+
+	PWR_I2C_SCL_HIGH
+	udelay(delay);
+
+	ack = gpio_get_value(GPIO_PWR_I2C_SDA);
+
+	PWR_I2C_SCL_HIGH
+	udelay(delay);
+	
+	gpio_direction_output(GPIO_PWR_I2C_SDA, GPIO_PWR_I2C_SDA_AF);
+
+	PWR_I2C_SCL_LOW
+	udelay(delay);
+
+	if(ack)
+		printk("PWR_I2C -> No ACK\n");
+
+}
+
+void pwr_i2c_read(u32 SlaveAddr, u8 WordAddr, u8 *pData)
+{
+	u32 i;
+	*pData = 0;
+
+	/* Start Conditions*/
+	PWR_I2C_START(PWR_I2C_FREQ);
+
+	/* Write Slave address */
+	for (i = 8; i > 1; i--) {
+		if ((SlaveAddr >> (i - 1)) & 0x1)
+			PWR_I2C_HIGH(PWR_I2C_FREQ);
+		else
+			PWR_I2C_LOW(PWR_I2C_FREQ);
+	}
+
+	PWR_I2C_LOW(PWR_I2C_FREQ);
+
+	PWR_I2C_ACK(PWR_I2C_FREQ);
+
+	/* Write Command address */
+	for (i = 8; i > 0; i--) {
+		if ((WordAddr >> (i - 1)) & 0x1)
+			PWR_I2C_HIGH(PWR_I2C_FREQ);
+		else
+			PWR_I2C_LOW(PWR_I2C_FREQ);
+	}
+
+	PWR_I2C_ACK(PWR_I2C_FREQ);
+
+	/* Start Conditions*/
+	PWR_I2C_RESTART(PWR_I2C_FREQ);
+
+	/* Write Slave address + Read bit*/
+	for (i = 8; i > 1; i--) {
+		if ((SlaveAddr >> (i - 1)) & 0x1)
+			PWR_I2C_HIGH(PWR_I2C_FREQ);
+		else
+			PWR_I2C_LOW(PWR_I2C_FREQ);
+	}
+
+	PWR_I2C_HIGH(PWR_I2C_FREQ);
+
+	PWR_I2C_ACK(PWR_I2C_FREQ);
+
+	/* Read Data */
+
+	for (i = 8; i > 0; i--) { 
+		PWR_I2C_SCL_LOW
+		udelay(PWR_I2C_FREQ);     
+		if (i == 8)
+			gpio_direction_input(GPIO_PWR_I2C_SDA);	
+		PWR_I2C_SCL_HIGH
+		udelay(PWR_I2C_FREQ);     
+
+		*pData |= (!!gpio_get_value(GPIO_PWR_I2C_SDA)) << (i - 1);
+
+		PWR_I2C_SCL_HIGH
+		udelay(PWR_I2C_FREQ);     
+		if (i == 1) {	
+			PWR_I2C_SDA_HIGH
+			gpio_direction_output(GPIO_PWR_I2C_SDA, GPIO_PWR_I2C_SDA_AF);
+		}
+		PWR_I2C_SCL_LOW
+		udelay(PWR_I2C_FREQ);     
+	}
+
+	PWR_I2C_HIGH(PWR_I2C_FREQ);
+
+	/* End Conditions */
+	PWR_I2C_END(PWR_I2C_FREQ);
+}
+
+void pwr_i2c_write(u32 SlaveAddr, u8 WordAddr, u8 Data)
+{
+	u32 i;
+
+	printk("[I2C EMUL] write transfer - Addr : 0x%02x, Data = 0x%02x \n", WordAddr, Data);
+
+	PWR_I2C_START(PWR_I2C_FREQ);
+
+	for (i = 8; i > 1; i--) {
+		if ((SlaveAddr >> (i - 1)) & 0x1)
+			PWR_I2C_HIGH(PWR_I2C_FREQ);
+		else
+			PWR_I2C_LOW(PWR_I2C_FREQ);
+	}
+
+	PWR_I2C_LOW(PWR_I2C_FREQ);
+
+	PWR_I2C_ACK(PWR_I2C_FREQ);
+	
+	for (i = 8; i > 0; i--) {
+		if ((WordAddr >> (i - 1)) & 0x1)
+			PWR_I2C_HIGH(PWR_I2C_FREQ);
+		else
+			PWR_I2C_LOW(PWR_I2C_FREQ);
+	}
+
+	PWR_I2C_ACK(PWR_I2C_FREQ);
+	
+	for (i = 8; i > 0; i--) {
+		if ((Data >> (i - 1)) & 0x1)
+			PWR_I2C_HIGH(PWR_I2C_FREQ);
+		else
+			PWR_I2C_LOW(PWR_I2C_FREQ);
+	}
+
+	PWR_I2C_ACK(PWR_I2C_FREQ);
+
+	PWR_I2C_END(PWR_I2C_FREQ);
+}
+
+void pwr_i2c_init(void)
+{
+	/* PWR_I2C_SCL */
+	if (gpio_is_valid(GPIO_PWR_I2C_SCL)) {
+		if (gpio_request(GPIO_PWR_I2C_SCL, S3C_GPIO_LAVEL(GPIO_PWR_I2C_SCL))) 
+			printk(KERN_ERR "Failed to request GPIO_PWR_I2C_SCL!\n");
+		gpio_direction_output(GPIO_PWR_I2C_SCL, GPIO_PWR_I2C_SCL_AF);
+		gpio_set_value(GPIO_PWR_I2C_SCL, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_PWR_I2C_SCL, S3C_GPIO_PULL_NONE);
+
+	/* PWR_I2C_SDA */
+	if (gpio_is_valid(GPIO_PWR_I2C_SDA)) {
+		if (gpio_request(GPIO_PWR_I2C_SDA, S3C_GPIO_LAVEL(GPIO_PWR_I2C_SDA))) 
+			printk(KERN_ERR "Failed to request GPIO_PWR_I2C_SDA!\n");
+		gpio_direction_output(GPIO_PWR_I2C_SDA, GPIO_PWR_I2C_SDA_AF);
+		gpio_set_value(GPIO_PWR_I2C_SDA, GPIO_LEVEL_HIGH);
+	}
+	s3c_gpio_setpull(GPIO_PWR_I2C_SDA, S3C_GPIO_PULL_NONE);
+}
diff -Nur linux-2.6.29/sound/soc/codecs/s3c_pwr_i2c.c linux-2.6.29-spica/sound/soc/codecs/s3c_pwr_i2c.c
--- linux-2.6.29/sound/soc/codecs/s3c_pwr_i2c.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/codecs/s3c_pwr_i2c.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,242 @@
+/*****************************************************************************/
+/*                                                                           */
+/* NAME    : Samsung Secondary BootLoader									 */
+/* FILE    : lcd_capela.c													 */
+/* PURPOSE : This file implements for Nand Bootloader                        */
+/*                                                                           */
+/*---------------------------------------------------------------------------*/
+/*                                                                           */
+/*              COPYRIGHT 2008 SAMSUNG ELECTRONICS CO., LTD.                 */
+/*                      ALL RIGHTS RESERVED                                  */
+/*                                                                           */
+/*   Permission is hereby granted to licensees of Samsung Electronics        */
+/*   Co., Ltd. products to use or abstract this computer program for the     */
+/*   sole purpose of implementing a product based on Samsung                 */
+/*   Electronics Co., Ltd. products. No other rights to reproduce, use,      */
+/*   or disseminate this computer program, whether in part or in whole,      */
+/*   are granted.                                                            */
+/*                                                                           */
+/*   Samsung Electronics Co., Ltd. makes no representation or warranties     */
+/*   with respect to the performance of this computer program, and           */
+/*   specifically disclaims any responsibility for any damages,              */
+/*   special or consequential, connected with the use of this program.       */
+/*                                                                           */
+/*****************************************************************************/
+
+#include <asm/arch.h>
+#include <asm/util.h>
+#include <asm/error.h>
+#include <asm/main.h>
+
+#define PWR_I2C_FREQ		1		
+
+#define PWR_I2C_SCL_HIGH	s3c_gpio_setpin(GPIO_PWR_I2C_SCL, GPIO_LEVEL_HIGH);
+#define PWR_I2C_SCL_LOW		s3c_gpio_setpin(GPIO_PWR_I2C_SCL, GPIO_LEVEL_LOW);
+#define PWR_I2C_SDA_HIGH	s3c_gpio_setpin(GPIO_PWR_I2C_SDA, GPIO_LEVEL_HIGH);
+#define PWR_I2C_SDA_LOW		s3c_gpio_setpin(GPIO_PWR_I2C_SDA, GPIO_LEVEL_LOW);
+
+static void SCLH_SDAH(u32 delay)
+{
+	PWR_I2C_SCL_HIGH
+	PWR_I2C_SDA_HIGH
+	usleep(delay);
+}
+
+static void SCLH_SDAL(u32 delay)
+{
+	PWR_I2C_SCL_HIGH
+	PWR_I2C_SDA_LOW
+	usleep(delay);
+}
+
+static void SCLL_SDAH(u32 delay)
+{
+	PWR_I2C_SCL_LOW
+	PWR_I2C_SDA_HIGH
+	usleep(delay);
+}
+
+static void SCLL_SDAL(u32 delay)
+{
+	PWR_I2C_SCL_LOW
+	PWR_I2C_SDA_LOW
+	usleep(delay);
+}
+
+static void PWR_I2C_LOW(u32 delay)
+{
+	SCLL_SDAL(delay);
+	SCLH_SDAL(delay);
+	SCLH_SDAL(delay);
+	SCLL_SDAL(delay);
+}
+
+static void PWR_I2C_HIGH(u32 delay)
+{
+	SCLL_SDAH(delay);
+	SCLH_SDAH(delay);
+	SCLH_SDAH(delay);
+	SCLL_SDAH(delay);
+}
+
+static void PWR_I2C_START(u32 delay)
+{
+	SCLH_SDAH(delay);
+	SCLH_SDAL(delay);
+	usleep(delay);
+	SCLL_SDAL(delay);
+}
+
+static void PWR_I2C_RESTART(u32 delay)
+{
+	SCLL_SDAH(delay);
+	SCLH_SDAH(delay);
+	SCLH_SDAL(delay);
+	usleep(delay);
+	SCLL_SDAL(delay);
+}
+
+static void PWR_I2C_END(u32 delay)
+{
+	SCLL_SDAL(delay);
+	SCLH_SDAL(delay);
+	usleep(delay);
+	SCLH_SDAH(delay);
+}
+
+static void PWR_I2C_ACK(u32 delay)
+{
+	u32 ack;
+
+	PWR_I2C_SCL_LOW
+	usleep(delay);
+
+	s3c_gpio_cfgpin(GPIO_PWR_I2C_SDA, 0);
+	
+	PWR_I2C_SCL_HIGH
+	usleep(delay);
+	ack = s3c_gpio_getpin(GPIO_PWR_I2C_SDA);
+	PWR_I2C_SCL_HIGH
+	usleep(delay);
+
+	s3c_gpio_cfgpin(GPIO_PWR_I2C_SDA, GPIO_PWR_I2C_SDA_AF);
+	
+	PWR_I2C_SCL_LOW
+	usleep(delay);
+
+	while (ack)
+		printf("PWR_I2C -> No ACK\n");
+}
+
+void pwr_i2c_read(u32 SlaveAddr, u8 WordAddr, u8 *pData)
+{
+	u32 i;
+
+	*pData = 0;
+
+	PWR_I2C_START(PWR_I2C_FREQ);
+
+	for (i = 8; i > 1; i--) {
+		if ((SlaveAddr >> (i - 1)) & 0x1)
+			PWR_I2C_HIGH(PWR_I2C_FREQ);
+		else
+			PWR_I2C_LOW(PWR_I2C_FREQ);
+	}
+
+	PWR_I2C_LOW(PWR_I2C_FREQ);
+
+	PWR_I2C_ACK(PWR_I2C_FREQ);
+	
+	for (i = 8; i > 0; i--) {
+		if ((WordAddr >> (i - 1)) & 0x1)
+			PWR_I2C_HIGH(PWR_I2C_FREQ);
+		else
+			PWR_I2C_LOW(PWR_I2C_FREQ);
+	}
+
+	PWR_I2C_ACK(PWR_I2C_FREQ);
+	
+	PWR_I2C_RESTART(PWR_I2C_FREQ);
+	
+	for (i = 8; i > 1; i--) {
+		if ((SlaveAddr >> (i - 1)) & 0x1)
+			PWR_I2C_HIGH(PWR_I2C_FREQ);
+		else
+			PWR_I2C_LOW(PWR_I2C_FREQ);
+	}
+
+	PWR_I2C_HIGH(PWR_I2C_FREQ);
+	
+	PWR_I2C_ACK(PWR_I2C_FREQ);
+	
+	for (i = 8; i > 0; i--) {
+		PWR_I2C_SCL_LOW
+		usleep(PWR_I2C_FREQ);
+		if (i == 8)
+			s3c_gpio_cfgpin(GPIO_PWR_I2C_SDA, 0);
+		PWR_I2C_SCL_HIGH
+		usleep(PWR_I2C_FREQ);
+		*pData |= (!!(s3c_gpio_getpin(GPIO_PWR_I2C_SDA)) << (i - 1));
+		PWR_I2C_SCL_HIGH
+		usleep(PWR_I2C_FREQ);
+		if (i == 1) {	
+			PWR_I2C_SDA_HIGH
+			s3c_gpio_cfgpin(GPIO_PWR_I2C_SDA, GPIO_PWR_I2C_SDA_AF);
+		}
+		PWR_I2C_SCL_LOW
+		usleep(PWR_I2C_FREQ);
+	}	
+
+	PWR_I2C_HIGH(PWR_I2C_FREQ);
+
+	PWR_I2C_END(PWR_I2C_FREQ);
+}
+
+void pwr_i2c_write(u32 SlaveAddr, u8 WordAddr, u8 Data)
+{
+	u32 i;
+
+	PWR_I2C_START(PWR_I2C_FREQ);
+
+	for (i = 8; i > 1; i--) {
+		if ((SlaveAddr >> (i - 1)) & 0x1)
+			PWR_I2C_HIGH(PWR_I2C_FREQ);
+		else
+			PWR_I2C_LOW(PWR_I2C_FREQ);
+	}
+
+	PWR_I2C_LOW(PWR_I2C_FREQ);
+
+	PWR_I2C_ACK(PWR_I2C_FREQ);
+	
+	for (i = 8; i > 0; i--) {
+		if ((WordAddr >> (i - 1)) & 0x1)
+			PWR_I2C_HIGH(PWR_I2C_FREQ);
+		else
+			PWR_I2C_LOW(PWR_I2C_FREQ);
+	}
+
+	PWR_I2C_ACK(PWR_I2C_FREQ);
+	
+	for (i = 8; i > 0; i--) {
+		if((Data >> (i - 1)) & 0x1)
+			PWR_I2C_HIGH(PWR_I2C_FREQ);
+		else
+			PWR_I2C_LOW(PWR_I2C_FREQ);
+	}
+
+	PWR_I2C_ACK(PWR_I2C_FREQ);
+
+	PWR_I2C_END(PWR_I2C_FREQ);
+}
+
+void pwr_i2c_init(void)
+{
+	s3c_gpio_setpin(GPIO_PWR_I2C_SCL, GPIO_LEVEL_HIGH);
+	s3c_gpio_cfgpin(GPIO_PWR_I2C_SCL, GPIO_PWR_I2C_SCL_AF);
+	s3c_gpio_pullup(GPIO_PWR_I2C_SCL, GPIO_PULL_DISABLE);
+
+	s3c_gpio_setpin(GPIO_PWR_I2C_SDA, GPIO_LEVEL_HIGH);
+	s3c_gpio_cfgpin(GPIO_PWR_I2C_SDA, GPIO_PWR_I2C_SDA_AF);
+	s3c_gpio_pullup(GPIO_PWR_I2C_SDA, GPIO_PULL_DISABLE);
+}
diff -Nur linux-2.6.29/sound/soc/codecs/wm8990.c linux-2.6.29-spica/sound/soc/codecs/wm8990.c
--- linux-2.6.29/sound/soc/codecs/wm8990.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/sound/soc/codecs/wm8990.c	2010-05-06 12:42:45.684270633 +0700
@@ -2,22 +2,28 @@
  * wm8990.c  --  WM8990 ALSA Soc Audio driver
  *
  * Copyright 2008 Wolfson Microelectronics PLC.
- * Author: Liam Girdwood <lrg@slimlogic.co.uk>
+ * Author: Liam Girdwood
+ *         lg@opensource.wolfsonmicro.com or linux@wolfsonmicro.com
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
  *  Free Software Foundation;  either version 2 of the  License, or (at your
  *  option) any later version.
+ *
+ *  Revision history
+ *    6th Mar 2008   Initial version.
  */
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
+#include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/pm.h>
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
+#include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -29,7 +35,27 @@
 
 #include "wm8990.h"
 
-#define WM8990_VERSION "0.2"
+#define AUDIO_NAME "wm8990"
+#define WM8990_VERSION "0.1"
+
+/*
+ * Debug
+ */
+
+#define WM8753_DEBUG 0
+
+#ifdef WM8753_DEBUG
+#define dbg(format, arg...) \
+	printk(KERN_DEBUG AUDIO_NAME ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) \
+	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) \
+	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) \
+	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)
 
 /* codec private data */
 struct wm8990_priv {
@@ -38,75 +64,11 @@
 };
 
 /*
- * wm8990 register cache.  Note that register 0 is not included in the
- * cache.
+ * wm8990 register cache
+ * We can't read the WM8990 register space when we
+ * are using 2 wire for device control, so we cache them instead.
  */
-static const u16 wm8990_reg[] = {
-	0x8990,     /* R0  - Reset */
-	0x0000,     /* R1  - Power Management (1) */
-	0x6000,     /* R2  - Power Management (2) */
-	0x0000,     /* R3  - Power Management (3) */
-	0x4050,     /* R4  - Audio Interface (1) */
-	0x4000,     /* R5  - Audio Interface (2) */
-	0x01C8,     /* R6  - Clocking (1) */
-	0x0000,     /* R7  - Clocking (2) */
-	0x0040,     /* R8  - Audio Interface (3) */
-	0x0040,     /* R9  - Audio Interface (4) */
-	0x0004,     /* R10 - DAC CTRL */
-	0x00C0,     /* R11 - Left DAC Digital Volume */
-	0x00C0,     /* R12 - Right DAC Digital Volume */
-	0x0000,     /* R13 - Digital Side Tone */
-	0x0100,     /* R14 - ADC CTRL */
-	0x00C0,     /* R15 - Left ADC Digital Volume */
-	0x00C0,     /* R16 - Right ADC Digital Volume */
-	0x0000,     /* R17 */
-	0x0000,     /* R18 - GPIO CTRL 1 */
-	0x1000,     /* R19 - GPIO1 & GPIO2 */
-	0x1010,     /* R20 - GPIO3 & GPIO4 */
-	0x1010,     /* R21 - GPIO5 & GPIO6 */
-	0x8000,     /* R22 - GPIOCTRL 2 */
-	0x0800,     /* R23 - GPIO_POL */
-	0x008B,     /* R24 - Left Line Input 1&2 Volume */
-	0x008B,     /* R25 - Left Line Input 3&4 Volume */
-	0x008B,     /* R26 - Right Line Input 1&2 Volume */
-	0x008B,     /* R27 - Right Line Input 3&4 Volume */
-	0x0000,     /* R28 - Left Output Volume */
-	0x0000,     /* R29 - Right Output Volume */
-	0x0066,     /* R30 - Line Outputs Volume */
-	0x0022,     /* R31 - Out3/4 Volume */
-	0x0079,     /* R32 - Left OPGA Volume */
-	0x0079,     /* R33 - Right OPGA Volume */
-	0x0003,     /* R34 - Speaker Volume */
-	0x0003,     /* R35 - ClassD1 */
-	0x0000,     /* R36 */
-	0x0100,     /* R37 - ClassD3 */
-	0x0079,     /* R38 - ClassD4 */
-	0x0000,     /* R39 - Input Mixer1 */
-	0x0000,     /* R40 - Input Mixer2 */
-	0x0000,     /* R41 - Input Mixer3 */
-	0x0000,     /* R42 - Input Mixer4 */
-	0x0000,     /* R43 - Input Mixer5 */
-	0x0000,     /* R44 - Input Mixer6 */
-	0x0000,     /* R45 - Output Mixer1 */
-	0x0000,     /* R46 - Output Mixer2 */
-	0x0000,     /* R47 - Output Mixer3 */
-	0x0000,     /* R48 - Output Mixer4 */
-	0x0000,     /* R49 - Output Mixer5 */
-	0x0000,     /* R50 - Output Mixer6 */
-	0x0180,     /* R51 - Out3/4 Mixer */
-	0x0000,     /* R52 - Line Mixer1 */
-	0x0000,     /* R53 - Line Mixer2 */
-	0x0000,     /* R54 - Speaker Mixer */
-	0x0000,     /* R55 - Additional Control */
-	0x0000,     /* R56 - AntiPOP1 */
-	0x0000,     /* R57 - AntiPOP2 */
-	0x0000,     /* R58 - MICBIAS */
-	0x0000,     /* R59 */
-	0x0008,     /* R60 - PLL1 */
-	0x0031,     /* R61 - PLL2 */
-	0x0026,     /* R62 - PLL3 */
-	0x0000,	    /* R63 - Driver internal */
-};
+static const u16 wm8990_reg[] = WM8990_REGISTER_DEFAULTS;
 
 /*
  * read wm8990 register cache
@@ -115,8 +77,9 @@
 	unsigned int reg)
 {
 	u16 *cache = codec->reg_cache;
-	BUG_ON(reg > (ARRAY_SIZE(wm8990_reg)) - 1);
-	return cache[reg];
+	if (reg < 1 || reg > (ARRAY_SIZE(wm8990_reg) + 1))
+		return -1;
+	return cache[reg - 1];
 }
 
 /*
@@ -126,12 +89,9 @@
 	unsigned int reg, unsigned int value)
 {
 	u16 *cache = codec->reg_cache;
-
-	/* Reset register and reserved registers are uncached */
-	if (reg == 0 || reg > ARRAY_SIZE(wm8990_reg) - 1)
+	if (reg < 1 || reg > 0x3f)
 		return;
-
-	cache[reg] = value;
+	cache[reg - 1] = value;
 }
 
 /*
@@ -146,8 +106,7 @@
 	data[1] = (value >> 8) & 0xFF;
 	data[2] = value & 0xFF;
 
-	wm8990_write_reg_cache(codec, reg, value);
-
+	wm8990_write_reg_cache (codec, reg, value);
 	if (codec->hw_write(codec->control_data, data, 3) == 2)
 		return 0;
 	else
@@ -156,46 +115,66 @@
 
 #define wm8990_reset(c) wm8990_write(c, WM8990_RESET, 0)
 
-static const DECLARE_TLV_DB_LINEAR(rec_mix_tlv, -1500, 600);
+static const unsigned int rec_mix_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 7, TLV_DB_LINEAR_ITEM(-1500, 600),
+};
 
-static const DECLARE_TLV_DB_LINEAR(in_pga_tlv, -1650, 3000);
+static const unsigned int in_pga_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 0x1F, TLV_DB_LINEAR_ITEM(-1650, 3000),
+};
 
-static const DECLARE_TLV_DB_LINEAR(out_mix_tlv, 0, -2100);
+static const unsigned int out_mix_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 7, TLV_DB_LINEAR_ITEM(0, -2100),
+};
 
-static const DECLARE_TLV_DB_LINEAR(out_pga_tlv, -7300, 600);
+static const unsigned int out_pga_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 127, TLV_DB_LINEAR_ITEM(-7300, 600),
+};
 
-static const DECLARE_TLV_DB_LINEAR(out_omix_tlv, -600, 0);
+static const unsigned int out_omix_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 7, TLV_DB_LINEAR_ITEM(-600, 0),
+};
 
-static const DECLARE_TLV_DB_LINEAR(out_dac_tlv, -7163, 0);
+static const unsigned int out_dac_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 255, TLV_DB_LINEAR_ITEM(-7163, 0),
+};
 
-static const DECLARE_TLV_DB_LINEAR(in_adc_tlv, -7163, 1763);
+static const unsigned int in_adc_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 255, TLV_DB_LINEAR_ITEM(-7163, 1763),
+};
 
-static const DECLARE_TLV_DB_LINEAR(out_sidetone_tlv, -3600, 0);
+static const unsigned int out_sidetone_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	0, 31, TLV_DB_LINEAR_ITEM(-3600, 0),
+};
 
 static int wm899x_outpga_put_volsw_vu(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
+        struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	int reg = mc->reg;
-	int ret;
-	u16 val;
+        struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+        int reg = kcontrol->private_value & 0xff;
+        int ret;
+        u16 val;
+
+        ret = snd_soc_put_volsw(kcontrol, ucontrol);
+        if (ret < 0)
+                return ret;
 
-	ret = snd_soc_put_volsw(kcontrol, ucontrol);
-	if (ret < 0)
-		return ret;
-
-	/* now hit the volume update bits (always bit 8) */
-	val = wm8990_read_reg_cache(codec, reg);
-	return wm8990_write(codec, reg, val | 0x0100);
+        /* now hit the volume update bits (always bit 8) */
+        val = wm8990_read_reg_cache(codec, reg);
+        return wm8990_write(codec, reg, val | 0x0100);
 }
 
-#define SOC_WM899X_OUTPGA_SINGLE_R_TLV(xname, reg, shift, max, invert,\
-	 tlv_array) {\
-	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
-	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
-		  SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+#define SOC_WM899X_OUTPGA_SINGLE_R_TLV(xname, reg, shift, max, invert, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | SNDRV_CTL_ELEM_ACCESS_READWRITE,\
 	.tlv.p = (tlv_array), \
 	.info = snd_soc_info_volsw, \
 	.get = snd_soc_get_volsw, .put = wm899x_outpga_put_volsw_vu, \
@@ -311,15 +290,11 @@
 	WM8990_CDMODE_BIT, 1, 0),
 
 SOC_SINGLE("Speaker Output Attenuation Volume", WM8990_SPEAKER_VOLUME,
-	WM8990_SPKATTN_SHIFT, WM8990_SPKATTN_MASK, 0),
+	WM8990_SPKVOL_SHIFT, WM8990_SPKVOL_MASK, 0),
 SOC_SINGLE("Speaker DC Boost Volume", WM8990_CLASSD3,
 	WM8990_DCGAIN_SHIFT, WM8990_DCGAIN_MASK, 0),
 SOC_SINGLE("Speaker AC Boost Volume", WM8990_CLASSD3,
 	WM8990_ACGAIN_SHIFT, WM8990_ACGAIN_MASK, 0),
-SOC_SINGLE_TLV("Speaker Volume", WM8990_CLASSD4,
-	WM8990_SPKVOL_SHIFT, WM8990_SPKVOL_MASK, 0, out_pga_tlv),
-SOC_SINGLE("Speaker ZC Switch", WM8990_CLASSD4,
-	WM8990_SPKZC_SHIFT, WM8990_SPKZC_MASK, 0),
 
 SOC_WM899X_OUTPGA_SINGLE_R_TLV("Left DAC Digital Volume",
 	WM8990_LEFT_DAC_DIGITAL_VOLUME,
@@ -425,7 +400,7 @@
 
 	for (i = 0; i < ARRAY_SIZE(wm8990_snd_controls); i++) {
 		err = snd_ctl_add(codec->card,
-				snd_soc_cnew(&wm8990_snd_controls[i], codec,
+				snd_soc_cnew(&wm8990_snd_controls[i],codec,
 					NULL));
 		if (err < 0)
 			return err;
@@ -437,13 +412,13 @@
  * _DAPM_ Controls
  */
 
-static int inmixer_event(struct snd_soc_dapm_widget *w,
+static int inmixer_event (struct snd_soc_dapm_widget *w,
 	struct snd_kcontrol *kcontrol, int event)
 {
 	u16 reg, fakepower;
 
-	reg = wm8990_read_reg_cache(w->codec, WM8990_POWER_MANAGEMENT_2);
-	fakepower = wm8990_read_reg_cache(w->codec, WM8990_INTDRIVBITS);
+	reg=wm8990_read_reg_cache(w->codec, WM8990_POWER_MANAGEMENT_2);
+	fakepower=wm8990_read_reg_cache(w->codec, WM8990_INTDRIVBITS);
 
 	if (fakepower & ((1 << WM8990_INMIXL_PWR_BIT) |
 		(1 << WM8990_AINLMUX_PWR_BIT))) {
@@ -463,16 +438,19 @@
 	return 0;
 }
 
-static int outmixer_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
+static int outmixer_event (struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol * kcontrol, int event)
 {
 	u32 reg_shift = kcontrol->private_value & 0xfff;
 	int ret = 0;
 	u16 reg;
 
+//	printk("reg_shift %4.4x\n", reg_shift);
+
 	switch (reg_shift) {
 	case WM8990_SPEAKER_MIXER | (WM8990_LDSPK_BIT << 8) :
 		reg = wm8990_read_reg_cache(w->codec, WM8990_OUTPUT_MIXER1);
+		printk("reg %4.4x\n", reg);
 		if (reg & WM8990_LDLO) {
 			printk(KERN_WARNING
 			"Cannot set as Output Mixer 1 LDLO Set\n");
@@ -511,7 +489,7 @@
 /* INMIX dB values */
 static const unsigned int in_mix_tlv[] = {
 	TLV_DB_RANGE_HEAD(1),
-	0, 7, TLV_DB_LINEAR_ITEM(-1200, 600),
+	0,7, TLV_DB_LINEAR_ITEM(-1200, 600),
 };
 
 /* Left In PGA Connections */
@@ -542,10 +520,8 @@
 	WM8990_LDBVOL_SHIFT, WM8990_LDBVOL_MASK, 0, in_mix_tlv),
 SOC_DAPM_SINGLE_TLV("LIN2 Volume", WM8990_INPUT_MIXER5, WM8990_LI2BVOL_SHIFT,
 	7, 0, in_mix_tlv),
-SOC_DAPM_SINGLE("LINPGA12 Switch", WM8990_INPUT_MIXER3, WM8990_L12MNB_BIT,
-	1, 0),
-SOC_DAPM_SINGLE("LINPGA34 Switch", WM8990_INPUT_MIXER3, WM8990_L34MNB_BIT,
-	1, 0),
+SOC_DAPM_SINGLE("LINPGA12 Switch", WM8990_INPUT_MIXER3, WM8990_L12MNB_BIT, 1, 0),
+SOC_DAPM_SINGLE("LINPGA34 Switch", WM8990_INPUT_MIXER3, WM8990_L34MNB_BIT, 1, 0),
 };
 
 /* INMIXR */
@@ -565,7 +541,7 @@
 	{"INMIXL Mix", "RXVOICE Mix", "DIFFINL Mix"};
 
 static const struct soc_enum wm8990_ainlmux_enum =
-SOC_ENUM_SINGLE(WM8990_INPUT_MIXER1, WM8990_AINLMODE_SHIFT,
+SOC_ENUM_SINGLE( WM8990_INPUT_MIXER1, WM8990_AINLMODE_SHIFT,
 	ARRAY_SIZE(wm8990_ainlmux), wm8990_ainlmux);
 
 static const struct snd_kcontrol_new wm8990_dapm_ainlmux_controls =
@@ -578,7 +554,7 @@
 	{"INMIXR Mix", "RXVOICE Mix", "DIFFINR Mix"};
 
 static const struct soc_enum wm8990_ainrmux_enum =
-SOC_ENUM_SINGLE(WM8990_INPUT_MIXER1, WM8990_AINRMODE_SHIFT,
+SOC_ENUM_SINGLE( WM8990_INPUT_MIXER1, WM8990_AINRMODE_SHIFT,
 	ARRAY_SIZE(wm8990_ainrmux), wm8990_ainrmux);
 
 static const struct snd_kcontrol_new wm8990_dapm_ainrmux_controls =
@@ -848,7 +824,7 @@
 SND_SOC_DAPM_OUTPUT("Internal DAC Sink"),
 };
 
-static const struct snd_soc_dapm_route audio_map[] = {
+static const char *audio_map[][3] = {
 	/* Make DACs turn on when playing even if not mixed into any outputs */
 	{"Internal DAC Sink", NULL, "Left DAC"},
 	{"Internal DAC Sink", NULL, "Right DAC"},
@@ -924,7 +900,7 @@
 	{"SPKMIX", "SPKMIX Left Mixer PGA Switch", "LOPGA"},
 	{"SPKMIX", "SPKMIX Right Mixer PGA Switch", "ROPGA"},
 	{"SPKMIX", "SPKMIX Right DAC Switch", "Right DAC"},
-	{"SPKMIX", "SPKMIX Left DAC Switch", "Left DAC"},
+	{"SPKMIX", "SPKMIX Left DAC Switch", "Right DAC"},
 
 	/* LONMIX */
 	{"LONMIX", "LONMIX Left Mixer PGA Switch", "LOPGA"},
@@ -971,15 +947,23 @@
 	{"OUT4", NULL, "OUT4MIX"},
 	{"ROP", NULL, "ROPMIX"},
 	{"RON", NULL, "RONMIX"},
+
+	/* terminator */
+	{NULL, NULL, NULL},
 };
 
 static int wm8990_add_widgets(struct snd_soc_codec *codec)
 {
-	snd_soc_dapm_new_controls(codec, wm8990_dapm_widgets,
-				  ARRAY_SIZE(wm8990_dapm_widgets));
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8990_dapm_widgets); i++)
+		snd_soc_dapm_new_control(codec, &wm8990_dapm_widgets[i]);
 
 	/* set up the WM8990 audio map */
-	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
 
 	snd_soc_dapm_new_widgets(codec);
 	return 0;
@@ -1013,7 +997,7 @@
 
 	if ((Ndiv < 6) || (Ndiv > 12))
 		printk(KERN_WARNING
-		"WM8990 N value outwith recommended range! N = %d\n", Ndiv);
+		"WM8990 N value outwith recommended range! N = %d\n",Ndiv);
 
 	pll_div->n = Ndiv;
 	Nmod = target % source;
@@ -1173,8 +1157,7 @@
  * Set PCM DAI bit size and sample rate.
  */
 static int wm8990_hw_params(struct snd_pcm_substream *substream,
-			    struct snd_pcm_hw_params *params,
-			    struct snd_soc_dai *dai)
+	struct snd_pcm_hw_params *params)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
@@ -1182,9 +1165,11 @@
 	u16 audio1 = wm8990_read_reg_cache(codec, WM8990_AUDIO_INTERFACE_1);
 
 	audio1 &= ~WM8990_AIF_WL_MASK;
+
 	/* bit size */
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
+		audio1 |= WM8990_AIF_WL_16BITS;
 		break;
 	case SNDRV_PCM_FORMAT_S20_3LE:
 		audio1 |= WM8990_AIF_WL_20BITS;
@@ -1198,16 +1183,15 @@
 	}
 
 	wm8990_write(codec, WM8990_AUDIO_INTERFACE_1, audio1);
+	//wm8990_write(codec, WM8990_AUDIO_INTERFACE_1, 0x4010);
 	return 0;
 }
 
 static int wm8990_mute(struct snd_soc_dai *dai, int mute)
 {
 	struct snd_soc_codec *codec = dai->codec;
-	u16 val;
-
-	val  = wm8990_read_reg_cache(codec, WM8990_DAC_CTRL) & ~WM8990_DAC_MUTE;
-
+	u16 val = wm8990_read_reg_cache(codec, WM8990_DAC_CTRL) & ~WM8990_DAC_MUTE;
+	
 	if (mute)
 		wm8990_write(codec, WM8990_DAC_CTRL, val | WM8990_DAC_MUTE);
 	else
@@ -1224,14 +1208,8 @@
 	switch (level) {
 	case SND_SOC_BIAS_ON:
 		break;
-
 	case SND_SOC_BIAS_PREPARE:
-		/* VMID=2*50k */
-		val = wm8990_read_reg_cache(codec, WM8990_POWER_MANAGEMENT_1) &
-			~WM8990_VMID_MODE_MASK;
-		wm8990_write(codec, WM8990_POWER_MANAGEMENT_1, val | 0x2);
 		break;
-
 	case SND_SOC_BIAS_STANDBY:
 		if (codec->bias_level == SND_SOC_BIAS_OFF) {
 			/* Enable all output discharge bits */
@@ -1280,17 +1258,10 @@
 
 			/* disable POBCTRL, SOFT_ST and BUFDCOPEN */
 			wm8990_write(codec, WM8990_ANTIPOP2, WM8990_BUFIOEN);
+		} else {
+			/* ON -> standby */
 
-			/* Enable workaround for ADC clocking issue. */
-			wm8990_write(codec, WM8990_EXT_ACCESS_ENA, 0x2);
-			wm8990_write(codec, WM8990_EXT_CTL1, 0xa003);
-			wm8990_write(codec, WM8990_EXT_ACCESS_ENA, 0);
 		}
-
-		/* VMID=2*250k */
-		val = wm8990_read_reg_cache(codec, WM8990_POWER_MANAGEMENT_1) &
-			~WM8990_VMID_MODE_MASK;
-		wm8990_write(codec, WM8990_POWER_MANAGEMENT_1, val | 0x4);
 		break;
 
 	case SND_SOC_BIAS_OFF:
@@ -1335,10 +1306,10 @@
 
 #define WM8990_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
 	SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | \
-	SNDRV_PCM_RATE_48000)
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
 
 #define WM8990_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
-	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+	SNDRV_PCM_FMTBIT_S24_LE)
 
 /*
  * The WM8990 supports 2 different and mutually exclusive DAI
@@ -1364,7 +1335,8 @@
 		.rates = WM8990_RATES,
 		.formats = WM8990_FORMATS,},
 	.ops = {
-		.hw_params = wm8990_hw_params,
+		.hw_params = wm8990_hw_params,},
+	.dai_ops = {
 		.digital_mute = wm8990_mute,
 		.set_fmt = wm8990_set_dai_fmt,
 		.set_clkdiv = wm8990_set_dai_clkdiv,
@@ -1380,7 +1352,7 @@
 	struct snd_soc_codec *codec = socdev->codec;
 
 	/* we only need to suspend if we are a valid card */
-	if (!codec->card)
+	if(!codec->card)
 		return 0;
 
 	wm8990_set_bias_level(codec, SND_SOC_BIAS_OFF);
@@ -1408,7 +1380,7 @@
 		codec->hw_write(codec->control_data, data, 2);
 	}
 
-	wm8990_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	wm8990_set_bias_level(codec, SND_SOC_BIAS_OFF);
 	return 0;
 }
 
@@ -1429,7 +1401,7 @@
 	codec->set_bias_level = wm8990_set_bias_level;
 	codec->dai = &wm8990_dai;
 	codec->num_dai = 2;
-	codec->reg_cache_size = ARRAY_SIZE(wm8990_reg);
+	codec->reg_cache_size = sizeof(wm8990_reg);
 	codec->reg_cache = kmemdup(wm8990_reg, sizeof(wm8990_reg), GFP_KERNEL);
 
 	if (codec->reg_cache == NULL)
@@ -1437,6 +1409,28 @@
 
 	wm8990_reset(codec);
 
+#if (defined CONFIG_SND_S3C64XX_SOC_SMDK6410_WM8990) || (defined CONFIG_SND_S3C64XX_SOC_SMDK6410_WM8990_MODULE)
+	/* Enable the left and right output mixers by default so a
+	   headphone output path will work */
+	printk("Entered : %s, %d 8990 write..\n",__FUNCTION__,__LINE__);
+	wm8990_write(codec, WM8990_OUTPUT_MIXER1, WM8990_LDLO);
+	wm8990_write(codec, WM8990_OUTPUT_MIXER2, WM8990_RDRO);
+#endif
+
+#if (defined CONFIG_SND_S3C64XX_SOC_SMDK6410_WM8990) || (defined CONFIG_SND_S3C64XX_SOC_SMDK6410_WM8990_MODULE)
+	/* Enable the left and right output mixers by default so a
+	   headphone output path will work */
+	wm8990_write(codec, WM8990_OUTPUT_MIXER1, WM8990_LDLO);
+	wm8990_write(codec, WM8990_OUTPUT_MIXER2, WM8990_RDRO);
+#endif
+
+#if (defined CONFIG_SND_S3C64XX_SOC_SMDK6410_WM8990) || (defined CONFIG_SND_S3C64XX_SOC_SMDK6410_WM8990_MODULE)
+	/* Enable the left and right output mixers by default so a
+	   headphone output path will work */
+	wm8990_write(codec, WM8990_OUTPUT_MIXER1, WM8990_LDLO);
+	wm8990_write(codec, WM8990_OUTPUT_MIXER2, WM8990_RDRO);
+#endif
+
 	/* register pcms */
 	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
 	if (ret < 0) {
@@ -1448,22 +1442,64 @@
 	codec->bias_level = SND_SOC_BIAS_OFF;
 	wm8990_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
 
-	reg = wm8990_read_reg_cache(codec, WM8990_AUDIO_INTERFACE_4);
-	wm8990_write(codec, WM8990_AUDIO_INTERFACE_4, reg | WM8990_ALRCGPIO1);
-
-	reg = wm8990_read_reg_cache(codec, WM8990_GPIO1_GPIO2) &
-		~WM8990_GPIO1_SEL_MASK;
-	wm8990_write(codec, WM8990_GPIO1_GPIO2, reg | 1);
+	/* set up ADCLR clock internally */
+	//reg = wm8990_read_reg_cache(codec, WM8990_AUDIO_INTERFACE_4);
+	//wm8990_write(codec, WM8990_AUDIO_INTERFACE_4, reg | WM8990_ALRCGPIO1);
+
+	/* set GPIO1 as clk output */
+	//reg = wm8990_read_reg_cache(codec, WM8990_GPIO1_GPIO2) &
+//		~WM8990_GPIO1_SEL_MASK;
+//	wm8990_write(codec, WM8990_GPIO1_GPIO2, reg | 1);
 
+// 	set Line-In and Mic-In Path.
+//
 	reg = wm8990_read_reg_cache(codec, WM8990_POWER_MANAGEMENT_2);
 	wm8990_write(codec, WM8990_POWER_MANAGEMENT_2, reg | WM8990_OPCLK_ENA);
 
 	wm8990_write(codec, WM8990_LEFT_OUTPUT_VOLUME, 0x50 | (1<<8));
 	wm8990_write(codec, WM8990_RIGHT_OUTPUT_VOLUME, 0x50 | (1<<8));
 
+	reg = wm8990_read_reg_cache(codec, WM8990_POWER_MANAGEMENT_2);
+	wm8990_write(codec, WM8990_POWER_MANAGEMENT_2, reg | WM8990_AINR_ENA | WM8990_ADCR_ENA | WM8990_ADCL_ENA);
+
+	reg = wm8990_read_reg_cache(codec, WM8990_INPUT_MIXER5);
+	wm8990_write(codec, WM8990_INPUT_MIXER5, (reg & ~WM8990_LI2BVOL_MASK) | (0x50 | (1<<8)));
+	
+	wm8990_write(codec, WM8990_LEFT_ADC_DIGITAL_VOLUME, 0xff | (1<<8));
+
+	reg = wm8990_read_reg_cache(codec, WM8990_INPUT_MIXER6);
+	wm8990_write(codec, WM8990_INPUT_MIXER6, (reg & ~WM8990_RI2BVOL_MASK) | (0x50 | (1<<8)));
+	
+	wm8990_write(codec, WM8990_RIGHT_ADC_DIGITAL_VOLUME, 0xff | (1<<8));
+
+	reg = wm8990_read_reg_cache(codec, WM8990_POWER_MANAGEMENT_2);
+	wm8990_write(codec, WM8990_POWER_MANAGEMENT_2, reg | WM8990_LIN12_ENA | WM8990_AINL_ENA); 
+
+	reg = wm8990_read_reg_cache(codec, WM8990_INPUT_MIXER2);
+	wm8990_write(codec, WM8990_INPUT_MIXER2, reg | WM8990_LMN1); 
+
+	reg = wm8990_read_reg_cache(codec, WM8990_LEFT_LINE_INPUT_1_2_VOLUME);
+	wm8990_write(codec, WM8990_LEFT_LINE_INPUT_1_2_VOLUME, (reg & ~WM8990_LIN12VOL_MASK) | (0x5f | (1<<8)));
+
+	reg = wm8990_read_reg_cache(codec, WM8990_INPUT_MIXER4);
+	wm8990_write(codec, WM8990_INPUT_MIXER4, (reg & ~WM8990_RDBVOL_MASK) | (0x5f | (1<<8)));
+
+	reg = wm8990_read_reg_cache(codec, WM8990_INPUT_MIXER3);
+	wm8990_write(codec, WM8990_INPUT_MIXER3, reg | WM8990_L12MNB);
+
+	reg = wm8990_read_reg_cache(codec, WM8990_INPUT_MIXER3);
+	wm8990_write(codec, WM8990_INPUT_MIXER3, reg | WM8990_L12MNBST);
+
+#if  defined(CONFIG_SOUND_WM8990_INPUT_STREAM_MIC_IN)
+	/* For Mono MIC-In */
+	reg = wm8990_read_reg_cache(codec, WM8990_AUDIO_INTERFACE_1);
+	wm8990_write(codec, WM8990_AUDIO_INTERFACE_1, reg & (0<<14));
+
+#endif
+
 	wm8990_add_controls(codec);
 	wm8990_add_widgets(codec);
-	ret = snd_soc_init_card(socdev);
+	ret = snd_soc_register_card(socdev);
 	if (ret < 0) {
 		printk(KERN_ERR "wm8990: failed to register card\n");
 		goto card_err;
@@ -1482,94 +1518,93 @@
    around */
 static struct snd_soc_device *wm8990_socdev;
 
-#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
 
 /*
- * WM891 2 wire address is determined by GPIO5
+ * WM8912 wire address is determined by GPIO5
  * state during powerup.
  *    low  = 0x34
  *    high = 0x36
  */
+static unsigned short normal_i2c[] = { 0, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static struct i2c_driver wm8990_i2c_driver;
+static struct i2c_client client_template;
 
-static int wm8990_i2c_probe(struct i2c_client *i2c,
-			    const struct i2c_device_id *id)
+static int wm8990_codec_probe(struct i2c_adapter *adap, int addr, int kind)
 {
 	struct snd_soc_device *socdev = wm8990_socdev;
+	struct wm8990_setup_data *setup = socdev->codec_data;
 	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *i2c;
 	int ret;
 
+	if (addr != setup->i2c_address)
+		return -ENODEV;
+
+	client_template.adapter = adap;
+	client_template.addr = addr;
+
+	i2c =  kmemdup(&client_template, sizeof(client_template), GFP_KERNEL);
+	if (i2c == NULL){
+		kfree(codec);
+		return -ENOMEM;
+	}
 	i2c_set_clientdata(i2c, codec);
 	codec->control_data = i2c;
 
+	ret = i2c_attach_client(i2c);
+	if (ret < 0) {
+		err("failed to attach codec at addr %x\n", addr);
+		goto err;
+	}
+
 	ret = wm8990_init(socdev);
-	if (ret < 0)
-		pr_err("failed to initialise WM8990\n");
+	if (ret < 0) {
+		err("failed to initialise WM8990\n");
+		goto err;
+	}
+	return ret;
 
+err:
+	kfree(codec);
+	kfree(i2c);
 	return ret;
 }
 
-static int wm8990_i2c_remove(struct i2c_client *client)
+static int wm8990_i2c_detach(struct i2c_client *client)
 {
 	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+	i2c_detach_client(client);
 	kfree(codec->reg_cache);
+	kfree(client);
 	return 0;
 }
 
-static const struct i2c_device_id wm8990_i2c_id[] = {
-	{ "wm8990", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, wm8990_i2c_id);
+static int wm8990_i2c_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, wm8990_codec_probe);
+}
 
+/* corgi i2c codec control layer */
 static struct i2c_driver wm8990_i2c_driver = {
 	.driver = {
 		.name = "WM8990 I2C Codec",
 		.owner = THIS_MODULE,
 	},
-	.probe =    wm8990_i2c_probe,
-	.remove =   wm8990_i2c_remove,
-	.id_table = wm8990_i2c_id,
+	.id =             I2C_DRIVERID_WM8753,
+	.attach_adapter = wm8990_i2c_attach,
+	.detach_client =  wm8990_i2c_detach,
+	.command =        NULL,
 };
 
-static int wm8990_add_i2c_device(struct platform_device *pdev,
-				 const struct wm8990_setup_data *setup)
-{
-	struct i2c_board_info info;
-	struct i2c_adapter *adapter;
-	struct i2c_client *client;
-	int ret;
-
-	ret = i2c_add_driver(&wm8990_i2c_driver);
-	if (ret != 0) {
-		dev_err(&pdev->dev, "can't add i2c driver\n");
-		return ret;
-	}
-
-	memset(&info, 0, sizeof(struct i2c_board_info));
-	info.addr = setup->i2c_address;
-	strlcpy(info.type, "wm8990", I2C_NAME_SIZE);
-
-	adapter = i2c_get_adapter(setup->i2c_bus);
-	if (!adapter) {
-		dev_err(&pdev->dev, "can't get i2c adapter %d\n",
-			setup->i2c_bus);
-		goto err_driver;
-	}
-
-	client = i2c_new_device(adapter, &info);
-	i2c_put_adapter(adapter);
-	if (!client) {
-		dev_err(&pdev->dev, "can't add i2c device at 0x%x\n",
-			(unsigned int)info.addr);
-		goto err_driver;
-	}
-
-	return 0;
-
-err_driver:
-	i2c_del_driver(&wm8990_i2c_driver);
-	return -ENODEV;
-}
+static struct i2c_client client_template = {
+	.name =   "WM8990",
+	.driver = &wm8990_i2c_driver,
+};
 #endif
 
 static int wm8990_probe(struct platform_device *pdev)
@@ -1578,9 +1613,9 @@
 	struct wm8990_setup_data *setup;
 	struct snd_soc_codec *codec;
 	struct wm8990_priv *wm8990;
-	int ret;
+	int ret = 0;
 
-	pr_info("WM8990 Audio Codec %s\n", WM8990_VERSION);
+	info("WM8990 Audio Codec %s", WM8990_VERSION);
 
 	setup = socdev->codec_data;
 	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
@@ -1600,19 +1635,17 @@
 	INIT_LIST_HEAD(&codec->dapm_paths);
 	wm8990_socdev = socdev;
 
-	ret = -ENODEV;
-
-#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
 	if (setup->i2c_address) {
+		normal_i2c[0] = setup->i2c_address;
 		codec->hw_write = (hw_write_t)i2c_master_send;
-		ret = wm8990_add_i2c_device(pdev, setup);
+		ret = i2c_add_driver(&wm8990_i2c_driver);
+		if (ret != 0)
+			printk(KERN_ERR "can't add i2c driver");
 	}
+#else
+		/* Add other interfaces here */
 #endif
-
-	if (ret != 0) {
-		kfree(codec->private_data);
-		kfree(codec);
-	}
 	return ret;
 }
 
@@ -1626,8 +1659,7 @@
 		wm8990_set_bias_level(codec, SND_SOC_BIAS_OFF);
 	snd_soc_free_pcms(socdev);
 	snd_soc_dapm_free(socdev);
-#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
-	i2c_unregister_device(codec->control_data);
+#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
 	i2c_del_driver(&wm8990_i2c_driver);
 #endif
 	kfree(codec->private_data);
@@ -1642,19 +1674,8 @@
 	.suspend =	wm8990_suspend,
 	.resume =	wm8990_resume,
 };
-EXPORT_SYMBOL_GPL(soc_codec_dev_wm8990);
-
-static int __init wm8990_modinit(void)
-{
-	return snd_soc_register_dai(&wm8990_dai);
-}
-module_init(wm8990_modinit);
 
-static void __exit wm8990_exit(void)
-{
-	snd_soc_unregister_dai(&wm8990_dai);
-}
-module_exit(wm8990_exit);
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8990);
 
 MODULE_DESCRIPTION("ASoC WM8990 driver");
 MODULE_AUTHOR("Liam Girdwood");
diff -Nur linux-2.6.29/sound/soc/codecs/wm8990.h linux-2.6.29-spica/sound/soc/codecs/wm8990.h
--- linux-2.6.29/sound/soc/codecs/wm8990.h	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/sound/soc/codecs/wm8990.h	2010-05-06 12:42:45.684270633 +0700
@@ -54,7 +54,6 @@
 #define WM8990_SPEAKER_VOLUME                   0x22
 #define WM8990_CLASSD1                          0x23
 #define WM8990_CLASSD3                          0x25
-#define WM8990_CLASSD4                          0x26
 #define WM8990_INPUT_MIXER1                     0x27
 #define WM8990_INPUT_MIXER2                     0x28
 #define WM8990_INPUT_MIXER3                     0x29
@@ -90,7 +89,7 @@
 /*
  * R0 (0x00) - Reset
  */
-#define WM8990_SW_RESET_CHIP_ID_MASK            0xFFFF  /* SW_RESET_CHIP_ID */
+#define WM8990_SW_RESET_CHIP_ID_MASK            0xFFFF  /* SW_RESET_CHIP_ID - [15:0] */
 
 /*
  * R1 (0x01) - Power Management (1)
@@ -190,7 +189,7 @@
 #define WM8990_DACR_SRC                         0x4000  /* DACR_SRC */
 #define WM8990_AIFDAC_TDM                       0x2000  /* AIFDAC_TDM */
 #define WM8990_AIFDAC_TDM_CHAN                  0x1000  /* AIFDAC_TDM_CHAN */
-#define WM8990_DAC_BOOST_MASK                   0x0C00  /* DAC_BOOST */
+#define WM8990_DAC_BOOST_MASK                   0x0C00  /* DAC_BOOST - [11:10] */
 #define WM8990_DAC_COMP                         0x0010  /* DAC_COMP */
 #define WM8990_DAC_COMPMODE                     0x0008  /* DAC_COMPMODE */
 #define WM8990_ADC_COMP                         0x0004  /* ADC_COMP */
@@ -232,7 +231,7 @@
 #define WM8990_MCLK_DIV_1			(0 << 11)
 #define WM8990_MCLK_DIV_2			(2 << 11)
 #define WM8990_MCLK_INV                         0x0400  /* MCLK_INV */
-#define WM8990_ADC_CLKDIV_MASK                  0x00E0  /* ADC_CLKDIV */
+#define WM8990_ADC_CLKDIV_MASK                  0x00E0  /* ADC_CLKDIV - [7:5] */
 #define WM8990_ADC_CLKDIV_1			(0 << 5)
 #define WM8990_ADC_CLKDIV_1_5			(1 << 5)
 #define WM8990_ADC_CLKDIV_2			(2 << 5)
@@ -256,7 +255,7 @@
 #define WM8990_AIF_MSTR2                        0x4000  /* AIF_MSTR2 */
 #define WM8990_AIF_SEL                          0x2000  /* AIF_SEL */
 #define WM8990_ADCLRC_DIR                       0x0800  /* ADCLRC_DIR */
-#define WM8990_ADCLRC_RATE_MASK                 0x07FF  /* ADCLRC_RATE */
+#define WM8990_ADCLRC_RATE_MASK                 0x07FF  /* ADCLRC_RATE - [10:0] */
 
 /*
  * R9 (0x09) - Audio Interface (4)
@@ -265,7 +264,7 @@
 #define WM8990_ALRCBGPIO6                       0x4000  /* ALRCBGPIO6 */
 #define WM8990_AIF_TRIS                         0x2000  /* AIF_TRIS */
 #define WM8990_DACLRC_DIR                       0x0800  /* DACLRC_DIR */
-#define WM8990_DACLRC_RATE_MASK                 0x07FF  /* DACLRC_RATE */
+#define WM8990_DACLRC_RATE_MASK                 0x07FF  /* DACLRC_RATE - [10:0] */
 
 /*
  * R10 (0x0A) - DAC CTRL
@@ -295,9 +294,9 @@
 /*
  * R13 (0x0D) - Digital Side Tone
  */
-#define WM8990_ADCL_DAC_SVOL_MASK               0x0F  /* ADCL_DAC_SVOL */
+#define WM8990_ADCL_DAC_SVOL_MASK               0x0F  /* ADCL_DAC_SVOL - [12:9] */
 #define WM8990_ADCL_DAC_SVOL_SHIFT		9
-#define WM8990_ADCR_DAC_SVOL_MASK               0x0F  /* ADCR_DAC_SVOL */
+#define WM8990_ADCR_DAC_SVOL_MASK               0x0F  /* ADCR_DAC_SVOL - [8:5] */
 #define WM8990_ADCR_DAC_SVOL_SHIFT		5
 #define WM8990_ADC_TO_DACL_MASK                 0x03  /* ADC_TO_DACL - [3:2] */
 #define WM8990_ADC_TO_DACL_SHIFT		2
@@ -529,8 +528,8 @@
 /*
  * R34 (0x22) - Speaker Volume
  */
-#define WM8990_SPKATTN_MASK                      0x0003  /* SPKATTN - [1:0] */
-#define WM8990_SPKATTN_SHIFT			 0
+#define WM8990_SPKVOL_MASK                      0x0003  /* SPKVOL - [1:0] */
+#define WM8990_SPKVOL_SHIFT			0
 
 /*
  * R35 (0x23) - ClassD1
@@ -545,15 +544,6 @@
 #define WM8990_DCGAIN_SHIFT			3
 #define WM8990_ACGAIN_MASK                      0x0007  /* ACGAIN - [2:0] */
 #define WM8990_ACGAIN_SHIFT			0
-
-/*
- * R38 (0x26) - ClassD4
- */
-#define WM8990_SPKZC_MASK                       0x0001  /* SPKZC */
-#define WM8990_SPKZC_SHIFT                           7  /* SPKZC */
-#define WM8990_SPKVOL_MASK                      0x007F  /* SPKVOL - [6:0] */
-#define WM8990_SPKVOL_SHIFT                          0  /* SPKVOL - [6:0] */
-
 /*
  * R39 (0x27) - Input Mixer1
  */
@@ -826,6 +816,76 @@
 #define WM8990_INMIXR_PWR_BIT			2
 #define WM8990_AINRMUX_PWR_BIT			3
 
+/*
+ * Default values.
+ */
+#define WM8990_REGISTER_DEFAULTS \
+{ \
+    /*0x8990,*/     /* R0  - Reset */ \
+    0x0000,     /* R1  - Power Management (1) */ \
+    0x6000,     /* R2  - Power Management (2) */ \
+    0x0000,     /* R3  - Power Management (3) */ \
+    0x4050,     /* R4  - Audio Interface (1) */ \
+    0x4000,     /* R5  - Audio Interface (2) */ \
+    0x01C8,     /* R6  - Clocking (1) */ \
+    0x0000,     /* R7  - Clocking (2) */ \
+    0x0040,     /* R8  - Audio Interface (3) */ \
+    0x0040,     /* R9  - Audio Interface (4) */ \
+    0x0004,     /* R10 - DAC CTRL */ \
+    0x00C0,     /* R11 - Left DAC Digital Volume */ \
+    0x00C0,     /* R12 - Right DAC Digital Volume */ \
+    0x0000,     /* R13 - Digital Side Tone */ \
+    0x0100,     /* R14 - ADC CTRL */ \
+    0x00C0,     /* R15 - Left ADC Digital Volume */ \
+    0x00C0,     /* R16 - Right ADC Digital Volume */ \
+    0x0000,     /* R17 */ \
+    0x0000,     /* R18 - GPIO CTRL 1 */ \
+    0x1000,     /* R19 - GPIO1 & GPIO2 */ \
+    0x1010,     /* R20 - GPIO3 & GPIO4 */ \
+    0x1010,     /* R21 - GPIO5 & GPIO6 */ \
+    0x8000,     /* R22 - GPIOCTRL 2 */ \
+    0x0800,     /* R23 - GPIO_POL */ \
+    0x008B,     /* R24 - Left Line Input 1&2 Volume */ \
+    0x008B,     /* R25 - Left Line Input 3&4 Volume */ \
+    0x008B,     /* R26 - Right Line Input 1&2 Volume */ \
+    0x008B,     /* R27 - Right Line Input 3&4 Volume */ \
+    0x0000,     /* R28 - Left Output Volume */ \
+    0x0000,     /* R29 - Right Output Volume */ \
+    0x0066,     /* R30 - Line Outputs Volume */ \
+    0x0022,     /* R31 - Out3/4 Volume */ \
+    0x0079,     /* R32 - Left OPGA Volume */ \
+    0x0079,     /* R33 - Right OPGA Volume */ \
+    0x0003,     /* R34 - Speaker Volume */ \
+    0x0003,     /* R35 - ClassD1 */ \
+    0x0000,     /* R36 */ \
+    0x0100,     /* R37 - ClassD3 */ \
+    0x0000,     /* R38 */ \
+    0x0000,     /* R39 - Input Mixer1 */ \
+    0x0000,     /* R40 - Input Mixer2 */ \
+    0x0000,     /* R41 - Input Mixer3 */ \
+    0x0000,     /* R42 - Input Mixer4 */ \
+    0x0000,     /* R43 - Input Mixer5 */ \
+    0x0000,     /* R44 - Input Mixer6 */ \
+    0x0000,     /* R45 - Output Mixer1 */ \
+    0x0000,     /* R46 - Output Mixer2 */ \
+    0x0000,     /* R47 - Output Mixer3 */ \
+    0x0000,     /* R48 - Output Mixer4 */ \
+    0x0000,     /* R49 - Output Mixer5 */ \
+    0x0000,     /* R50 - Output Mixer6 */ \
+    0x0180,     /* R51 - Out3/4 Mixer */ \
+    0x0000,     /* R52 - Line Mixer1 */ \
+    0x0000,     /* R53 - Line Mixer2 */ \
+    0x0000,     /* R54 - Speaker Mixer */ \
+    0x0000,     /* R55 - Additional Control */ \
+    0x0000,     /* R56 - AntiPOP1 */ \
+    0x0000,     /* R57 - AntiPOP2 */ \
+    0x0000,     /* R58 - MICBIAS */ \
+    0x0000,     /* R59 */ \
+    0x0008,     /* R60 - PLL1 */ \
+    0x0031,     /* R61 - PLL2 */ \
+    0x0026,     /* R62 - PLL3 */ \
+}
+
 struct wm8990_setup_data {
 	unsigned i2c_bus;
 	unsigned short i2c_address;
@@ -836,6 +896,8 @@
 #define WM8990_ADCCLK_DIV 2
 #define WM8990_BCLK_DIV 3
 
+#define WM8990_MCLK	0
+
 extern struct snd_soc_dai wm8990_dai;
 extern struct snd_soc_codec_device soc_codec_dev_wm8990;
 
diff -Nur linux-2.6.29/sound/soc/Kconfig linux-2.6.29-spica/sound/soc/Kconfig
--- linux-2.6.29/sound/soc/Kconfig	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/sound/soc/Kconfig	2010-05-06 12:42:45.684270633 +0700
@@ -6,6 +6,8 @@
 	tristate "ALSA for SoC audio support"
 	select SND_PCM
 	select AC97_BUS if SND_SOC_AC97_BUS
+	select SND_S3C64XX_SOC if S3C_DMA_PL080
+	select SND_S3C64XX_SOC_SOL if S3C_DMA_PL080_SOL
 	---help---
 
 	  If you want ASoC support, you should say Y here and also to the
@@ -31,6 +33,7 @@
 source "sound/soc/omap/Kconfig"
 source "sound/soc/pxa/Kconfig"
 source "sound/soc/s3c24xx/Kconfig"
+source "sound/soc/s3c64xx/Kconfig"
 source "sound/soc/sh/Kconfig"
 
 # Supported codecs
diff -Nur linux-2.6.29/sound/soc/Makefile linux-2.6.29-spica/sound/soc/Makefile
--- linux-2.6.29/sound/soc/Makefile	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/sound/soc/Makefile	2010-05-06 12:42:45.684270633 +0700
@@ -9,5 +9,5 @@
 obj-$(CONFIG_SND_SOC)	+= fsl/
 obj-$(CONFIG_SND_SOC)	+= omap/
 obj-$(CONFIG_SND_SOC)	+= pxa/
-obj-$(CONFIG_SND_SOC)	+= s3c24xx/
+obj-$(CONFIG_SND_SOC)	+= s3c64xx/
 obj-$(CONFIG_SND_SOC)	+= sh/
diff -Nur linux-2.6.29/sound/soc/s3c64xx/ga6410_lm49350.c linux-2.6.29-spica/sound/soc/s3c64xx/ga6410_lm49350.c
--- linux-2.6.29/sound/soc/s3c64xx/ga6410_lm49350.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/ga6410_lm49350.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,498 @@
+/*
+ * smdk6400_wm8753.c  --  SoC audio for Neo1973
+ *
+ * Copyright 2007 Wolfson Microelectronics PLC.
+ * Author: Graeme Gregory
+ *         graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Copyright (C) 2007, Ryu Euiyoul <ryu.real@gmail.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    20th Jan 2007   Initial version.
+ *    05th Feb 2007   Rename all to Neo1973
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware/scoop.h>
+#include <asm/io.h>
+
+#include <mach/hardware.h>
+#include <mach/audio.h>
+#include <mach/map.h>
+
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <plat/regs-iic.h>
+#include <plat/regs-clock.h>
+#include <plat/regs-iis.h>
+
+#include "../codecs/lm49350.h"
+#include "s3c-pcm.h"
+#include "s3c-i2s.h"
+
+/* define the scenarios */
+#define SMDK6400_AUDIO_OFF		0
+#define SMDK6400_CAPTURE_MIC1		3
+#define SMDK6400_STEREO_TO_HEADPHONES	2
+#define SMDK6400_CAPTURE_LINE_IN	1
+
+
+#define SUBJECT "ga6410_lm49350"
+#define P(format,...)\
+	printk ("[ "SUBJECT " (%s,%d) ] " format "\n", __func__, __LINE__, ## __VA_ARGS__);
+#define FI \
+	printk ("[ "SUBJECT " (%s,%d) ] " "%s - IN" "\n", __func__, __LINE__, __func__);
+#define FO \
+	printk ("[ "SUBJECT " (%s,%d) ] " "%s - OUT" "\n", __func__, __LINE__, __func__);
+
+
+#ifdef CONFIG_SND_DEBUG
+#define s3cdbg(x...) P(x)
+#else
+#define s3cdbg(x...)
+#endif
+
+#define S3C_VA_IIS          S3C_ADDR(0x03e40000) /*IIS*/
+#define S3C24XX_VA_IIS     S3C_VA_IIS
+#define S3C_IIS0REG(x)      ((x) + S3C24XX_VA_IIS)
+#define S3C_IIS0MOD     S3C_IIS0REG(0x04)
+#define S3C_IIS0PSR     S3C_IIS0REG(0x0C)  
+#define S3C_IIS0MOD_256FS       (0x0<<3)
+
+static int smdk6400_hifi_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	unsigned int pll_out = 0, bclk = 0;
+	int ret = 0;
+	unsigned long iispsr, iismod,iiscon;
+	unsigned long epll_con0=0;
+	unsigned int prescaler = 4;
+	unsigned int m,p,s,k = 0;
+	unsigned long val;
+
+    u32*    regs;
+
+	regs = ioremap(S3C64XX_PA_IIS, 0x100);
+	if (regs == NULL)
+		return -ENXIO;
+
+	s3cdbg("Entered %s, rate = %d\n", __FUNCTION__, params_rate(params));
+	s3cdbg("before :   IISMOD: %lx,IISPSR: %lx\n",
+			 readl((regs + S3C64XX_IIS0MOD)), 
+			readl((regs + S3C64XX_IIS0PSR)));
+	s3cdbg("	GPDCON = 0x%x \n",readl(S3C64XX_GPDCON));
+	
+	/*PCLK & SCLK gating enable*/
+	writel(readl(S3C_PCLK_GATE)|S3C_CLKCON_PCLK_IIS0, S3C_PCLK_GATE);
+	writel(readl(S3C_SCLK_GATE)|S3C_CLKCON_SCLK_AUDIO0, S3C_SCLK_GATE);
+
+	iismod = readl((regs + S3C64XX_IIS0MOD)); 
+	iismod &=~(S3C64XX_IIS0MOD_FS_MASK);		// 256fs
+	iismod &= ~(S3C64XX_IIS0MOD_BLC_MASK);		// 16bit
+
+	/*Clear I2S prescaler value [13:8] and disable prescaler*/
+	iispsr = readl((regs + S3C64XX_IIS0PSR));	
+	//printk("iispsr = 0x%lx\n",iispsr);
+	iispsr &=~((0x3f<<8)|(1<<15)); 
+	writel(iispsr, (regs + S3C64XX_IIS0PSR));
+
+	//(1<<31) |  (m<<16) | (p<<8) | (s<<0)
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+		//(49.152 / divider)
+		m = 32; p = 2; s = 3; k= 50332;
+		//writel(50332, S3C_EPLL_CON1);
+		//writel((1<<31)|(32<<16)|(1<<8)|(3<<0) ,S3C_EPLL_CON0);
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		// (45.158 / divider)
+		m = 30; p = 1; s = 3; k= 6903;
+		//writel(10398, S3C_EPLL_CON1);
+		//writel((1<<31)|(45<<16)|(1<<8)|(3<<0) ,S3C_EPLL_CON0);
+		break;
+	case 48000:
+	case 96000:
+		m = 49; p = 1; s = 3; k= 9961;
+		//writel(9961, S3C_EPLL_CON1);
+		//writel((1<<31)|(49<<16)|(1<<8)|(3<<0) ,S3C_EPLL_CON0);
+		break;
+	default:
+		m = 128; p = 25; s = 0; k= 0;
+		//writel(0, S3C_EPLL_CON1);
+		//writel((1<<31)|(128<<16)|(25<<8)|(0<<0) ,S3C_EPLL_CON0);
+		break;
+	}
+	writel(k, S3C_EPLL_CON1);
+	writel((1<<31)|(m<<16)|(p<<8)|(s<<0) ,S3C_EPLL_CON0);
+	s3cdbg("m = %d, EPLL_CON0 : 0x%x, epll_con0:0x%x\n",m,readl(S3C_EPLL_CON0),epll_con0);
+	
+	while(!(__raw_readl(S3C_EPLL_CON0)&(1<<30)));
+
+	s3cdbg(" !!!! EPLL set - m:%d, p:%d, s:%d, k:%d  => EPLL_CON0 : 0x%x, EPLL_CON1: 0x%x !!!!\n",\
+		m,p,s,k,readl(S3C_EPLL_CON0),readl(S3C_EPLL_CON1) );
+
+	
+	/* MUXepll : FOUTepll */
+	writel(readl(S3C_CLK_SRC)|S3C_CLKSRC_EPLL_CLKSEL, S3C_CLK_SRC);
+	/* AUDIO0 sel : FOUTepll */
+	writel((readl(S3C_CLK_SRC)&~(0x7<<7))|(0<<7), S3C_CLK_SRC);
+
+	/* CLK_DIV2 setting */
+	writel(readl(S3C_CLK_DIV2)&~(0xf<<8),S3C_CLK_DIV2);
+	
+	switch (params_rate(params)) {
+	case 8000:
+		pll_out = 49152000;
+		prescaler = 24; 
+		break;
+	case 11025:
+		pll_out = 45158000;
+		prescaler = 16; 
+		break;
+	case 16000:
+		pll_out = 49152000;
+		prescaler = 12; 
+		break;
+	case 22050:
+		pll_out = 45158000;
+		prescaler = 8; 
+		break;
+	case 32000:
+		pll_out = 49152000;
+		prescaler = 6; 
+		break;
+	case 44100:
+		pll_out = 45158000;
+		prescaler = 4;  
+		break;
+	case 48000:
+		pll_out = 49152000;
+		prescaler = 4; 
+		break;
+	case 64000:
+		pll_out = 49152000;
+		prescaler = 3;  
+		break;
+	case 88200:
+		pll_out = 45158000;
+		prescaler = 2; 
+		break;
+	case 96000:
+		pll_out = 49152000;
+		prescaler = 2; 
+		break;
+	default:		// same as 44.1Khz
+		pll_out = 45158000;
+		prescaler = 4; 
+		break;
+	}
+
+	iismod |= S3C_IIS0MOD_256FS;
+	writel(iismod , (regs + S3C64XX_IIS0MOD));
+	
+	/* set codec DAI configuration */		//lm49350_mode1h_set_dai_fmt
+	ret = codec_dai->dai_ops.set_fmt(codec_dai,
+		SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS ); 
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */		//s3c_i2s_set_fmt
+	ret = cpu_dai->dai_ops.set_fmt(cpu_dai,
+		SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS ); 
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */		//	lm49350_set_dai_sysclk
+	ret = codec_dai->dai_ops.set_sysclk(codec_dai, WM8753_MCLK, pll_out,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	/* set MCLK division for sample rate */		//s3c_i2s_set_clkdiv
+//	ret = cpu_dai->dai_ops.set_clkdiv(cpu_dai, S3C24XX_DIV_MCLK,
+//		S3C2410_IISMOD_32FS );
+//	if (ret < 0)
+//		return ret;
+
+	/* set codec BCLK division for sample rate */	//lm49350_set_dai_clkdiv
+	ret = codec_dai->dai_ops.set_clkdiv(codec_dai, WM8753_BCLKDIV, bclk);
+	if (ret < 0)
+		return ret;
+
+	/* set prescaler division for sample rate */		// s3c_i2s_set_clkdiv
+	//ret = cpu_dai->dai_ops.set_clkdiv(cpu_dai, S3C24XX_DIV_PRESCALER,prescaler);
+	ret = cpu_dai->dai_ops.set_clkdiv(cpu_dai, 2,prescaler);
+	if (ret < 0)
+		return ret;
+
+#if 0
+	s3cdbg("after :  IISCON: %x IISMOD: %x,IISFIC: %x,IISPSR: %x\n",
+			 readl(S3C64XX_IIS0REG(S3C64XX_IIS0CON)), readl(S3C64XX_IIS0REG(S3C64XX_IIS0MOD)), 
+			readl(S3C64XX_IIS0REG(S3C64XX_IIS0FIC)), readl(S3C64XX_IIS0REG(S3C64XX_IIS0PSR)));
+	s3cdbg("	: EPLL_CON0: 0x%x EPLLCON1:0x%x CLK_SRC:0x%x CLK_DIV2:0x%x\n",\
+		readl(S3C_EPLL_CON0),readl(S3C_EPLL_CON1),readl(S3C_CLK_SRC), readl(S3C_CLK_DIV2));
+#endif
+
+	return 0;
+}
+
+static int smdk6400_hifi_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+
+	/* disable the PLL */
+	return codec_dai->dai_ops.set_pll(codec_dai, WM8753_PLL1, 0, 0);
+}
+
+/*
+ * Neo1973 WM8753 HiFi DAI opserations.
+ */
+static struct snd_soc_ops smdk6400_hifi_ops = {
+	.hw_params = smdk6400_hifi_hw_params,
+	.hw_free = smdk6400_hifi_hw_free,
+};
+
+static int smdk6400_scenario = 0;
+
+static int smdk6400_get_scenario(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = smdk6400_scenario;
+	return 0;
+}
+
+static int set_scenario_endpoints(struct snd_soc_codec *codec, int scenario)
+{
+	s3cdbg("Entered %s, scenario = %d\n", __FUNCTION__, scenario);
+	
+	switch(smdk6400_scenario) {
+	case SMDK6400_AUDIO_OFF:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    0);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  0);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  0);
+		break;
+	case SMDK6400_STEREO_TO_HEADPHONES:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    1);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  0);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  0);
+		break;
+	case SMDK6400_CAPTURE_MIC1:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    0);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  1);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  0);
+		break;
+	case SMDK6400_CAPTURE_LINE_IN:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    0);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  0);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  1);
+		break;
+	default:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    1);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  1);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  1);
+		break;
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+
+	return 0;
+}
+
+static int smdk6400_set_scenario(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	s3cdbg("Entered %s \n", __FUNCTION__);
+
+	if (smdk6400_scenario == ucontrol->value.integer.value[0])
+		return 0;
+
+	smdk6400_scenario = ucontrol->value.integer.value[0];
+	set_scenario_endpoints(codec, smdk6400_scenario);
+	return 1;
+}
+
+static const struct snd_soc_dapm_widget wm8753_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_MIC("Mic1 Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+};
+
+
+/* example machine audio_mapnections */
+static const char* audio_map[][3] = {
+
+	{"Headphone Jack", NULL, "LOUT1"},
+	{"Headphone Jack", NULL, "ROUT1"},
+
+	/* mic is connected to mic1 - with bias */
+	/* mic is connected to mic1 - with bias */
+	{"MIC1", NULL, "Mic1 Jack"},
+
+	{"LINE1", NULL, "Line In Jack"},
+	{"LINE2", NULL, "Line In Jack"},
+
+	/* Connect the ALC pins */
+	{"ACIN", NULL, "ACOP"},
+		
+	{NULL, NULL, NULL},
+};
+
+static const char *smdk_scenarios[] = {
+	"Off",
+	"Capture Line In",
+	"Headphones",
+	"Capture Mic1",
+};
+
+static const struct soc_enum smdk_scenario_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(smdk_scenarios),smdk_scenarios),
+};
+
+static const struct snd_kcontrol_new wm8753_smdk6400_controls[] = {
+	SOC_ENUM_EXT("SMDK Mode", smdk_scenario_enum[0],
+		smdk6400_get_scenario, smdk6400_set_scenario),
+};
+
+
+
+/*
+ * This is an example machine initialisation for a wm8753 connected to a
+ * smdk6400. It is missing logic to detect hp/mic insertions and logic
+ * to re-route the audio in such an event.
+ */
+static int smdk6400_wm8753_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+    s3cdbg("[smdk_wm8753] smdk6400_wm8753_init\n");
+    
+	/* set endpoints to default mode */
+	set_scenario_endpoints(codec, SMDK6400_AUDIO_OFF);
+
+	/* Add smdk6400 specific widgets */
+	for (i = 0; i < ARRAY_SIZE(wm8753_dapm_widgets); i++)
+		snd_soc_dapm_new_control(codec, &wm8753_dapm_widgets[i]);
+
+	/* add smdk6400 specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8753_smdk6400_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8753_smdk6400_controls[i],
+				codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* set up smdk6400 specific audio path audio_mapnects */
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	/* always connected */
+	snd_soc_dapm_set_endpoint(codec, "Mic1 Jack", 1);
+	snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 1);
+	snd_soc_dapm_set_endpoint(codec, "Line In Jack", 1);
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+static struct snd_soc_dai_link smdk6400_dai[] = {
+	{ /* Hifi Playback - for similatious use with voice below */
+		.name = "LM49350",
+		.stream_name = "LM49350 HiFi",
+		//.cpu_dai = &s3c_i2s_dai,
+		.cpu_dai = &s3c_i2s_v40_dai,
+		.codec_dai = &lm49350_dai[WM8753_DAI_HIFI],
+		.init = smdk6400_wm8753_init,
+		.ops = &smdk6400_hifi_ops,
+	},
+};
+
+static struct snd_soc_machine smdk6400 = {
+	.name = "smdk6400",
+	.dai_link = smdk6400_dai,
+	.num_links = ARRAY_SIZE(smdk6400_dai),
+};
+
+static struct wm8753_setup_data smdk6400_lm49350_setup = {
+	.i2c_address = 0x1a,
+};
+
+static struct snd_soc_device smdk6400_snd_devdata = {
+	.machine = &smdk6400,
+	.platform = &s3c24xx_soc_platform,
+	.codec_dev = &soc_codec_dev_lm49350,
+	.codec_data = &smdk6400_lm49350_setup,
+};
+static struct platform_device *smdk6400_snd_device;
+
+static int __init smdk6400_init(void)
+{
+	int ret;
+	
+	s3cdbg("[smdk_wm8753] smdk6400_init ++\n");
+
+	smdk6400_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!smdk6400_snd_device)
+		return -ENOMEM;
+
+    s3cdbg("[smdk_wm8753] platform_set_drvdata\n");
+	platform_set_drvdata(smdk6400_snd_device, &smdk6400_snd_devdata);
+	smdk6400_snd_devdata.dev = &smdk6400_snd_device->dev;
+	
+	s3cdbg("[smdk_wm8753] platform_device_add\n");
+	ret = platform_device_add(smdk6400_snd_device);
+
+	if (ret)
+		platform_device_put(smdk6400_snd_device);
+	
+	s3cdbg("[smdk_wm8753] smdk6400_init --\n");
+	return ret;
+}
+
+static void __exit smdk6400_exit(void)
+{
+	platform_device_unregister(smdk6400_snd_device);
+}
+
+module_init(smdk6400_init);
+module_exit(smdk6400_exit);
+
+/* Module information */
+MODULE_AUTHOR("Ryu Euiyoul");
+MODULE_DESCRIPTION("ALSA SoC WM8753 Neo1973");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/s3c64xx/Kconfig linux-2.6.29-spica/sound/soc/s3c64xx/Kconfig
--- linux-2.6.29/sound/soc/s3c64xx/Kconfig	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/Kconfig	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,118 @@
+if S3C_DMA_PL080
+config SND_S3C64XX_SOC
+	tristate "Samsung SoC Audio AP"
+	depends on ARCH_S3C64XX 
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the S3C AC97, I2S or SSP interface. You will also need
+	  to select the audio interfaces to support below.
+endif
+
+if S3C_DMA_PL080_SOL
+config SND_S3C64XX_SOC_SOL
+	tristate "Samsung SoC Audio Sol"
+	depends on ARCH_S3C64XX  
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the S3C AC97, I2S or SSP interface. You will also need
+	  to select the audio interfaces to support below.
+endif
+
+config SND_S5P64XX_SOC
+	tristate "Samsung SoC Audio"
+	depends on ARCH_S5P64XX
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the S3C AC97, I2S or SSP interface. You will also need
+	  to select the audio interfaces to support below.
+
+config SND_S5PC1XX_SOC
+	tristate "Samsung SoC Audio"
+	depends on ARCH_S5PC1XX
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the S3C AC97, I2S or SSP interface. You will also need
+	  to select the audio interfaces to support below.
+
+config SND_S3C_I2S_V32
+	tristate
+
+config SND_S3C_I2S_V40
+	tristate
+
+config SND_S3C_I2S_V50
+	tristate
+
+config SND_S3C_AC97
+	tristate
+
+choice
+	prompt "Select the codec driver"
+	default SND_S3C64XX_SOC_AK4671
+	depends on SND_S3C64XX_SOC || SND_S5P64XX_SOC || SND_S5PC1XX_SOC || SND_S3C64XX_SOC_SOL
+
+config SND_S3C64XX_SOC_AK4671
+	bool "SoC I2S Audio support - AK4671"
+	depends on SND_S3C64XX_SOC || SND_S3C64XX_SOC_SOL
+	select SND_S3C_I2S_V32
+	select SND_SOC_AK4671
+	select SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING
+	help
+	 Say Y if you want to add support for SoC audio with the AK4671.
+
+config SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING
+	tristate "SoC I2S Audio support - rec downsampling for Android platform"
+	depends on SND_S3C64XX_SOC_AK4671
+	help
+	 Say Y if you want to add support for Rec Downsampling with the AK4671.
+
+
+config  SND_SMDK6410_WM8580
+	tristate "WM8580-I2S on SMDK6410"
+	depends on SND_S3C64XX_SOC || SND_S3C64XX_SOC_SOL
+	select SND_S3C_I2S_V40
+	select SND_SOC_WM8580
+
+config  SND_SMDK6410_S5M8751
+	tristate "S5M8751-I2S on SMDK6410"
+	depends on SND_S3C64XX_SOC || SND_S3C64XX_SOC_SOL
+	select SND_S3C_I2S_V32
+	select SND_SOC_S5M8751
+
+config  SND_SMDK6410_WM9713
+	tristate "WM9713-AC97 on SMDK6410"
+	depends on SND_S3C64XX_SOC || SND_S3C64XX_SOC_SOL
+	select SND_S3C_AC97
+	select SND_SOC_WM9713
+
+config  SND_SMDK6440_WM8580
+	tristate "WM8580-I2S on SMDK6440"
+	depends on SND_S5P64XX_SOC
+	select SND_S3C_I2S_V40
+	select SND_SOC_WM8580
+
+config  SND_SMDK6440_S5M8751
+	tristate "S5M8751-I2S on SMDK6440"
+	depends on SND_S5P64XX_SOC
+	select SND_S3C_I2S_V40
+	select SND_SOC_S5M8751
+
+config  SND_SMDKC100_WM8580
+	tristate "WM8580-I2S on SMDKC100"
+	depends on SND_S5PC1XX_SOC
+	select SND_S3C_I2S_V50
+	select SND_SOC_WM8580
+
+config  SND_SMDKC100_S5M8751
+	tristate "S5M8751-I2S on SMDKC100"
+	depends on SND_S5PC1XX_SOC
+	select SND_S3C_I2S_V32
+	select SND_SOC_S5M8751
+
+config  SND_SMDKC100_WM9713
+	tristate "WM9713-AC97 on SMDKC100"
+	depends on SND_S5PC1XX_SOC
+	select SND_S3C_AC97
+	select SND_SOC_WM9713
+
+endchoice
diff -Nur linux-2.6.29/sound/soc/s3c64xx/Makefile linux-2.6.29-spica/sound/soc/s3c64xx/Makefile
--- linux-2.6.29/sound/soc/s3c64xx/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/Makefile	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,46 @@
+# Machine Support
+snd-soc-smdk6410-s5m8751-objs := smdk6410_s5m8751.o
+snd-soc-smdk6410-wm8580-objs  := smdk6410_wm8580.o
+snd-soc-smdk6410-wm9713-objs  := smdk6410_wm9713.o
+
+snd-soc-smdk6440-s5m8751-objs := smdk6440_s5m8751.o
+snd-soc-smdk6440-wm8580-objs  := smdk6440_wm8580.o
+
+snd-soc-smdkc100-wm8580-objs  := smdkc100_wm8580.o
+snd-soc-smdkc100-s5m8751-objs := smdkc100_s5m8751.o
+snd-soc-smdkc100-wm9713-objs  := smdkc100_wm9713.o
+
+snd-soc-s3c6410-i2s-objs := s3c6410-i2s.o
+
+obj-$(CONFIG_SND_S3C64XX_SOC)	 	+= s3c-pcm.o
+obj-$(CONFIG_SND_S3C64XX_SOC_SOL)	+= s3c-pcm-sol.o
+obj-$(CONFIG_SND_S5P64XX_SOC) 		+= s3c-pcm.o
+obj-$(CONFIG_SND_S5PC1XX_SOC) 		+= s3c-pcm.o
+
+obj-$(CONFIG_SND_S3C_I2S_V32)  += s3c6410-i2s.o
+#obj-$(CONFIG_SND_S3C_I2S_V32)  += s3c-i2s.o
+obj-$(CONFIG_SND_S3C_I2S_V40)  += s3c-i2s.o
+obj-$(CONFIG_SND_S3C_I2S_V50)  += s3c-i2s.o
+obj-$(CONFIG_SND_S3C_AC97)     += s3c-ac97.o
+
+snd-soc-ak4671-objs := s3c6410-ak4671.o
+
+# S3C6410 has AC97 and I2S(v-3.2 and 4.0) controller.
+# SMDK6410 has WM8580 and WM9713 onboard and S5M8751 as a module.
+obj-$(CONFIG_SND_SMDK6410_S5M8751) += snd-soc-smdk6410-s5m8751.o
+obj-$(CONFIG_SND_SMDK6410_WM8580)  += snd-soc-smdk6410-wm8580.o
+obj-$(CONFIG_SND_SMDK6410_WM9713)  += snd-soc-smdk6410-wm9713.o
+
+# S5P6440 has only I2S(v-4.0) controller.
+# SMDK6410 has WM8580 onboard and S5M8751 as a module.
+obj-$(CONFIG_SND_SMDK6440_S5M8751) += snd-soc-smdk6440-s5m8751.o
+obj-$(CONFIG_SND_SMDK6440_WM8580)  += snd-soc-smdk6440-wm8580.o
+
+# S5PC100 has AC97 and I2S(v-3.2 and 5.0) controller.
+# SMDKC100 has WM8580 and WM9713 onboard and S5M8751 as a module.
+obj-$(CONFIG_SND_SMDKC100_S5M8751) += snd-soc-smdkc100-s5m8751.o
+obj-$(CONFIG_SND_SMDKC100_WM8580)  += snd-soc-smdkc100-wm8580.o
+obj-$(CONFIG_SND_SMDKC100_WM9713)  += snd-soc-smdkc100-wm9713.o
+
+# S3C6410 has AK4671 and I2S(v-3.2 and 4.0) controller.
+obj-$(CONFIG_SND_S3C64XX_SOC_AK4671) += snd-soc-ak4671.o
diff -Nur linux-2.6.29/sound/soc/s3c64xx/s3c6410-ak4671.c linux-2.6.29-spica/sound/soc/s3c64xx/s3c6410-ak4671.c
--- linux-2.6.29/sound/soc/s3c64xx/s3c6410-ak4671.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/s3c6410-ak4671.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,356 @@
+/*
+ * 
+ *
+ * Copyright 2007 Wolfson Microelectronics PLC.
+ * Author: Graeme Gregory
+ *         graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Copyright (C) 2007, Ryu Euiyoul <ryu.real@gmail.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    20th Jan 2007   Initial version.
+ *    05th Feb 2007   Rename all to Neo1973
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware/scoop.h>
+#include <asm/io.h>
+
+#include <mach/hardware.h>
+#include <mach/audio.h>
+#include <mach/map.h>
+
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <plat/regs-iic.h>
+#include <plat/regs-clock.h>
+#include <plat/regs-iis.h>
+
+#include "../codecs/ak4671.h"
+#include "s3c-pcm.h"
+#include "s3c6410-i2s.h"
+
+#define SUBJECT "capella_ak4671"
+#define P(format,...)\
+	printk ("[ "SUBJECT " (%s,%d) ] " format "\n", __func__, __LINE__, ## __VA_ARGS__);
+#define FI \
+	printk ("[ "SUBJECT " (%s,%d) ] " "%s - IN" "\n", __func__, __LINE__, __func__);
+#define FO \
+	printk ("[ "SUBJECT " (%s,%d) ] " "%s - OUT" "\n", __func__, __LINE__, __func__);
+
+//#define CONFIG_SND_DEBUG
+
+#ifdef CONFIG_SND_DEBUG
+#define s3cdbg(x...) P(x)
+#else
+#define s3cdbg(x...)
+#endif
+static int android_hifi_hw_params(struct snd_pcm_substream *, struct snd_pcm_hw_params *);
+static int android_hifi_hw_free(struct snd_pcm_substream *);
+
+static struct snd_soc_ops android_hifi_ops = {
+	.hw_params = android_hifi_hw_params,
+	.hw_free = android_hifi_hw_free,
+};
+
+static struct snd_soc_dai_link android_dai[] = {
+	{ /* Hifi Playback - for similatious use with voice below */
+		.name = "AK4671",
+		.stream_name = "AK4671 Codec",
+		.cpu_dai = &s3c_i2s_dai,
+		.codec_dai = &ak4671_dai,
+		.ops = &android_hifi_ops,
+	},
+};
+
+static struct snd_soc_card android = {
+	.name = "android",
+	.platform = &s3c24xx_soc_platform,
+	.dai_link = android_dai,
+	.num_links = ARRAY_SIZE(android_dai),
+};
+
+static struct ak4671_setup_data android_ak4671_setup = {
+	.i2c_address = (0x24 >> 1),
+};
+
+static struct snd_soc_device android_snd_devdata = {
+	.card = &android,
+	.codec_dev = &soc_codec_dev_ak4671,
+	.codec_data = &android_ak4671_setup,
+};
+static struct platform_device *android_snd_device;
+
+
+
+static int android_hifi_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	unsigned int pll_out = 0, bclk = 0;
+	int ret = 0;
+	unsigned long iispsr, iismod;
+	unsigned long epll_con0=0;
+	unsigned int prescaler = 4;
+	unsigned int m,p,s,k = 0;
+
+    u32*    regs;
+
+	regs = ioremap(S3C64XX_PA_IIS, 0x100);
+	if (regs == NULL)
+		return -ENXIO;
+
+	s3cdbg("Entered %s, rate = %d\n", __FUNCTION__, params_rate(params));
+	s3cdbg("before :   IISMOD: %lx,IISPSR: %lx\n",
+			 readl((regs + S3C64XX_IIS0MOD)), 
+			readl((regs + S3C64XX_IIS0PSR)));
+	s3cdbg("	GPDCON = 0x%x \n",readl(S3C64XX_GPDCON));
+	
+	/*PCLK & SCLK gating enable*/
+	writel(readl(S3C_PCLK_GATE)|S3C_CLKCON_PCLK_IIS0, S3C_PCLK_GATE);
+	writel(readl(S3C_SCLK_GATE)|S3C_CLKCON_SCLK_AUDIO0, S3C_SCLK_GATE);
+
+	iismod = readl((regs + S3C64XX_IIS0MOD)); 
+	iismod &=~(S3C64XX_IIS0MOD_FS_MASK);		// 256fs
+	iismod &= ~(S3C64XX_IIS0MOD_BLC_MASK);		// 16bit
+
+	/*Clear I2S prescaler value [13:8] and disable prescaler*/
+	iispsr = readl((regs + S3C64XX_IIS0PSR));	
+	//printk("iispsr = 0x%lx\n",iispsr);
+	iispsr &=~((0x3f<<8)|(1<<15)); 
+	writel(iispsr, (regs + S3C64XX_IIS0PSR));
+
+	//(1<<31) |  (m<<16) | (p<<8) | (s<<0)
+	switch (params_rate(params)) {
+	case 8000:
+#ifdef CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING // sangsu fix : recording down scaling
+		// (45.158 / divider)
+		m = 30; p = 1; s = 3; k= 6903;
+		//writel(10398, S3C_EPLL_CON1);
+		//writel((1<<31)|(45<<16)|(1<<8)|(3<<0) ,S3C_EPLL_CON0);
+		break;
+#endif // sangsu fix
+	case 16000:
+	case 32000:
+	case 64000:
+		//(49.152 / divider)
+		m = 32; p = 1; s = 3; k= 50332;
+		//writel(50332, S3C_EPLL_CON1);
+		//writel((1<<31)|(32<<16)|(1<<8)|(3<<0) ,S3C_EPLL_CON0);
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		// (45.158 / divider)
+		m = 30; p = 1; s = 3; k= 6903;
+		//writel(10398, S3C_EPLL_CON1);
+		//writel((1<<31)|(45<<16)|(1<<8)|(3<<0) ,S3C_EPLL_CON0);
+		break;
+	case 48000:
+	case 96000:
+		m = 49; p = 1; s = 3; k= 9961;
+		//writel(9961, S3C_EPLL_CON1);
+		//writel((1<<31)|(49<<16)|(1<<8)|(3<<0) ,S3C_EPLL_CON0);
+		break;
+	default:
+		m = 128; p = 25; s = 0; k= 0;
+		//writel(0, S3C_EPLL_CON1);
+		//writel((1<<31)|(128<<16)|(25<<8)|(0<<0) ,S3C_EPLL_CON0);
+		break;
+	}
+	writel(k, S3C_EPLL_CON1);
+	writel((1<<31)|(m<<16)|(p<<8)|(s<<0) ,S3C_EPLL_CON0);
+	s3cdbg("m = %d, EPLL_CON0 : 0x%x, epll_con0:0x%x\n",m,readl(S3C_EPLL_CON0),epll_con0);
+	
+	while(!(__raw_readl(S3C_EPLL_CON0)&(1<<30)));
+
+	s3cdbg(" !!!! EPLL set - m:%d, p:%d, s:%d, k:%d  => EPLL_CON0 : 0x%x, EPLL_CON1: 0x%x !!!!\n",\
+		m,p,s,k,readl(S3C_EPLL_CON0),readl(S3C_EPLL_CON1) );
+
+	
+	/* MUXepll : FOUTepll */
+	writel(readl(S3C_CLK_SRC)|S3C_CLKSRC_EPLL_CLKSEL, S3C_CLK_SRC);
+	/* AUDIO0 sel : FOUTepll */
+	writel((readl(S3C_CLK_SRC)&~(0x7<<7))|(0<<7), S3C_CLK_SRC);
+
+	/* CLK_DIV2 setting */
+	writel(readl(S3C_CLK_DIV2)&~(0xf<<8),S3C_CLK_DIV2);
+	
+	switch (params_rate(params)) {
+	case 8000:
+#ifdef CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING  // sangsu fix : recording down scaling
+		pll_out = 45158000;
+		prescaler = 4;  
+		break;
+#else // sangsu fix
+		pll_out = 49152000;
+		prescaler = 24; 
+		break;
+#endif // sangsu fix
+	case 11025:
+		pll_out = 45158000;
+		prescaler = 16; 
+		break;
+	case 16000:
+		pll_out = 49152000;
+		prescaler = 12; 
+		break;
+	case 22050:
+		pll_out = 45158000;
+		prescaler = 8; 
+		break;
+	case 32000:
+		pll_out = 49152000;
+		prescaler = 6; 
+		break;
+	case 44100:
+		pll_out = 45158000;
+		prescaler = 4;  
+		break;
+	case 48000:
+		pll_out = 49152000;
+		prescaler = 4; 
+		break;
+	case 64000:
+		pll_out = 49152000;
+		prescaler = 3;  
+		break;
+	case 88200:
+		pll_out = 45158000;
+		prescaler = 2; 
+		break;
+	case 96000:
+		pll_out = 49152000;
+		prescaler = 2; 
+		break;
+	default:		// same as 44.1Khz
+		pll_out = 45158000;
+		prescaler = 4; 
+		break;
+	}
+
+	iismod |= S3C_IISMOD_256FS;
+	writel(iismod , (regs + S3C64XX_IIS0MOD));
+	
+	/* set codec DAI configuration */		//lm49350_mode1h_set_dai_fmt
+	ret = codec_dai->ops.set_fmt(codec_dai,
+		SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBM_CFM ); 
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */		//s3c_i2s_set_fmt
+	ret = cpu_dai->ops.set_fmt(cpu_dai,
+		SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBM_CFM ); 
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */		// for codec sample rate
+	ret = codec_dai->ops.set_sysclk(codec_dai, 0, params_rate(params), SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, S3C_CLKSRC_I2SEXT, 0, SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+#if 0
+	/* set MCLK division for sample rate */		//s3c_i2s_set_clkdiv
+	ret = cpu_dai->dai_ops.set_clkdiv(cpu_dai, S3C24XX_DIV_MCLK,
+		S3C2410_IISMOD_32FS );
+	if (ret < 0)
+		return ret;
+
+	/* set codec BCLK division for sample rate */	//lm49350_set_dai_clkdiv
+	//ret = codec_dai->dai_ops.set_clkdiv(codec_dai, WM8753_BCLKDIV, bclk);
+	ret = codec_dai->dai_ops.set_clkdiv(codec_dai, 1, bclk);
+	if (ret < 0)
+		return ret;
+#endif
+	/* set prescaler division for sample rate */		// s3c_i2s_set_clkdiv
+	ret = cpu_dai->ops.set_clkdiv(cpu_dai, S3C_DIV_PRESCALER,prescaler);
+	if (ret < 0)
+		return ret;
+
+	s3cdbg("after :  IISCON: %x IISMOD: %x,IISFIC: %x,IISPSR: %x\n",
+			 readl(regs + S3C64XX_IIS0CON), readl(regs + S3C64XX_IIS0MOD), 
+			readl(regs + S3C64XX_IIS0FIC), readl(regs + S3C64XX_IIS0PSR));
+	s3cdbg("	: EPLL_CON0: 0x%x EPLLCON1:0x%x CLK_SRC:0x%x CLK_DIV2:0x%x\n",\
+		readl(S3C_EPLL_CON0),readl(S3C_EPLL_CON1),readl(S3C_CLK_SRC), readl(S3C_CLK_DIV2));
+
+	return 0;
+}
+
+static int android_hifi_hw_free(struct snd_pcm_substream *substream)
+{
+#if 0
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+
+	/* disable the PLL */
+	return codec_dai->dai_ops.set_pll(codec_dai, WM8753_PLL1, 0, 0);
+#endif
+	return 0;
+}
+static int __init android_init(void)
+{
+	int ret;
+	
+	s3cdbg("[android_ak4671] android_init ++\n");
+
+	android_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!android_snd_device)
+	{	
+		printk("[android_ak4671] soc-audio create fail \n");
+		return -ENOMEM;
+	}
+
+    	s3cdbg("[android_ak4671] platform_set_drvdata\n");
+	platform_set_drvdata(android_snd_device, &android_snd_devdata);
+	android_snd_devdata.dev = &android_snd_device->dev;
+	
+	s3cdbg("[android_ak4671] platform_device_add\n");
+	ret = platform_device_add(android_snd_device);
+
+	if (ret)
+		platform_device_put(android_snd_device);
+	else
+		printk("[android_ak4671] android_snd_device add fail \n");
+	
+	s3cdbg("[android_ak4671] android_init --\n");
+	return ret;
+}
+
+static void __exit android_exit(void)
+{
+	platform_device_unregister(android_snd_device);
+}
+
+module_init(android_init);
+module_exit(android_exit);
+
+/* Module information */
+MODULE_AUTHOR("SB Kang");
+MODULE_DESCRIPTION("ALSA SoC AK4671");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/s3c64xx/s3c6410-i2s.c linux-2.6.29-spica/sound/soc/s3c64xx/s3c6410-i2s.c
--- linux-2.6.29/sound/soc/s3c64xx/s3c6410-i2s.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/s3c6410-i2s.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,856 @@
+/*
+ * s3c6410-i2s.c  --  ALSA Soc Audio Layer
+ *
+ * (c) 2009 Samsung Electronics   - Jaswinder Singh Brar <jassi.brar@samsung.com>
+ *  Derived from Ben Dooks' driver for s3c24xx
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+#include <mach/map.h>
+
+#include <mach/hardware.h>
+#include <plat/gpio-cfg.h>
+#ifdef CONFIG_S3C_DMA_PL080_SOL
+#include <plat/s3c6410-dma.h>
+#endif
+#include "s3c-pcm.h"
+#include "s3c6410-i2s.h"
+
+//#define CONFIG_SND_DEBUG
+#ifdef CONFIG_SND_DEBUG
+#define debug_msg(x...) printk(x)
+#else
+#define debug_msg(x...)
+#endif
+
+#ifdef CONFIG_S3C_DMA_PL080	
+static struct s3c2410_dma_client s3c_dma_client_out = {
+	.name = "I2S PCM Stereo out"
+};
+
+static struct s3c2410_dma_client s3c_dma_client_in = {
+	.name = "I2S PCM Stereo in"
+};
+
+static struct s3c24xx_pcm_dma_params s3c_i2s_pcm_stereo_out = {
+	.client		= &s3c_dma_client_out,
+	.channel	= S3C_DMACH_I2S_OUT,
+	.dma_addr	= S3C_IIS_PABASE + S3C_IISTXD,
+	.dma_size	= 4,
+};
+
+static struct s3c24xx_pcm_dma_params s3c_i2s_pcm_stereo_in = {
+	.client		= &s3c_dma_client_in,
+	.channel	= S3C_DMACH_I2S_IN,
+	.dma_addr	= S3C_IIS_PABASE + S3C_IISRXD,
+	.dma_size	= 4,
+};
+#endif
+
+struct s3c_i2s_info {
+	void __iomem	*regs;
+	struct clk	*iis_clk;
+	struct clk	*audio_bus;
+	u32		iiscon;
+	u32		iismod;
+	u32		iisfic;
+	u32		iispsr;
+	u32		slave;
+	u32		clk_rate;
+};
+static struct s3c_i2s_info s3c_i2s;
+
+/*
+static void dump_i2s(void)
+{
+	printk("S3C_IISCON : %x\n", readl(s3c_i2s.regs + S3C_IISCON));
+	printk("S3C_IISMOD : %x\n", readl(s3c_i2s.regs + S3C_IISMOD));
+	printk("S3C_IISFIC : %x\n", readl(s3c_i2s.regs + S3C_IISFIC));
+	printk("S3C_IISPSR : %x\n", readl(s3c_i2s.regs + S3C_IISPSR));
+}
+*/
+
+static void s3c_snd_txctrl(int on)
+{
+	u32 iiscon;
+
+	debug_msg("%s\n", __FUNCTION__);
+
+	iiscon  = readl(s3c_i2s.regs + S3C_IISCON);
+
+	if (on) {
+		iiscon |= S3C_IISCON_I2SACTIVE;
+		iiscon  &= ~S3C_IISCON_TXCHPAUSE;
+		iiscon  &= ~S3C_IISCON_TXDMAPAUSE;
+		iiscon  |= S3C_IISCON_TXDMACTIVE;
+		writel(iiscon,  s3c_i2s.regs + S3C_IISCON);
+	} else {
+	
+		//if recording is running, do not disable IIS clock
+		if ( (iiscon & S3C_IISCON_RXDMACTIVE) != S3C_IISCON_RXDMACTIVE)
+			{
+		iiscon &= ~S3C_IISCON_I2SACTIVE;
+			debug_msg("I2S off\n");
+			}
+		iiscon  |= S3C_IISCON_TXCHPAUSE;
+		iiscon  |= S3C_IISCON_TXDMAPAUSE;
+		iiscon  &= ~S3C_IISCON_TXDMACTIVE;
+		writel(iiscon,  s3c_i2s.regs + S3C_IISCON);
+	}
+}
+
+static void s3c_snd_rxctrl(int on)
+{
+	u32 iiscon;
+
+	debug_msg("%s\n", __FUNCTION__);
+
+	iiscon  = readl(s3c_i2s.regs + S3C_IISCON);
+
+	if(on){
+		iiscon |= S3C_IISCON_I2SACTIVE;
+		iiscon  &= ~S3C_IISCON_RXCHPAUSE;
+		iiscon  &= ~S3C_IISCON_RXDMAPAUSE;
+		iiscon  |= S3C_IISCON_RXDMACTIVE;
+		writel(iiscon,  s3c_i2s.regs + S3C_IISCON);
+	}else{
+	
+		//if playback is running, do not disable IIS clock
+		if ( (iiscon & S3C_IISCON_TXDMACTIVE)  != S3C_IISCON_TXDMACTIVE)
+			{
+			iiscon &= ~S3C_IISCON_I2SACTIVE;
+			debug_msg("I2S off\n");
+			}
+		
+		iiscon  |= S3C_IISCON_RXCHPAUSE;
+		iiscon  |= S3C_IISCON_RXDMAPAUSE;
+		iiscon  &= ~S3C_IISCON_RXDMACTIVE;
+		writel(iiscon,  s3c_i2s.regs + S3C_IISCON);
+	}
+
+}
+
+/*
+ * Wait for the LR signal to allow synchronisation to the L/R clock
+ * from the codec. May only be needed for slave mode.
+ */
+static int s3c_snd_lrsync(void)
+{
+	u32 iiscon;
+	int timeout = 50; /* 5ms */
+
+	debug_msg("%s\n", __FUNCTION__);
+
+	while (1) {
+		iiscon = readl(s3c_i2s.regs + S3C_IISCON);
+		if (iiscon & S3C_IISCON_LRI)
+			break;
+
+		if (!timeout--)
+			return -ETIMEDOUT;
+		udelay(100);
+	}
+
+	return 0;
+}
+
+/*
+ * Set s3c_ I2S DAI format
+ */
+static int s3c_i2s_set_fmt(struct snd_soc_dai *cpu_dai,
+		unsigned int fmt)
+{
+	u32 iismod;
+
+	debug_msg("%s\n", __FUNCTION__);
+
+	iismod = readl(s3c_i2s.regs + S3C_IISMOD);
+	iismod &= ~S3C_IISMOD_SDFMASK;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		//printk("AP Slave Mode\n");
+		s3c_i2s.slave = 1;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		//printk("AP Master Mode\n");
+		s3c_i2s.slave = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iismod &= ~S3C_IISMOD_MSB;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iismod |= S3C_IISMOD_MSB;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		iismod |= S3C_IISMOD_LSB;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		iismod &= ~S3C_IISMOD_LRP;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iismod |= S3C_IISMOD_LRP;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+	case SND_SOC_DAIFMT_IB_NF:
+	default:
+		printk("Inv-combo(%d) not supported!\n", fmt & SND_SOC_DAIFMT_FORMAT_MASK);
+		return -EINVAL;
+	}
+
+	writel(iismod, s3c_i2s.regs + S3C_IISMOD);
+
+	return 0;
+}
+
+static int s3c_i2s_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	u32 iismod;
+	
+	debug_msg("%s\n", __FUNCTION__);
+
+#ifdef CONFIG_S3C_DMA_PL080_SOL
+	rtd->dai->cpu_dai->dma_data = s3c_i2s_dai.dma_data;
+#endif
+
+#ifdef CONFIG_S3C_DMA_PL080	
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		rtd->dai->cpu_dai->dma_data = &s3c_i2s_pcm_stereo_out;
+	else
+		rtd->dai->cpu_dai->dma_data = &s3c_i2s_pcm_stereo_in;
+#endif
+	/* Working copies of register */
+	iismod = readl(s3c_i2s.regs + S3C_IISMOD);
+	iismod &= ~S3C_IISMOD_BLCMASK;
+
+#ifdef CONFIG_S3C_DMA_PL080	
+	/* TODO */
+	switch(params_channels(params)) {
+	case 1:
+		s3c_i2s_pcm_stereo_in.dma_size = 2;
+		break;
+	case 2:
+		s3c_i2s_pcm_stereo_in.dma_size = 4;
+		break;
+	case 4:
+		break;
+	case 6:
+		break;
+	default:
+		break;
+	}
+#endif
+
+	/* RFS & BFS are set by dai_link(machine specific) code via set_clkdiv */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		iismod |= S3C_IISMOD_8BIT;
+ 		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+ 		iismod |= S3C_IISMOD_16BIT;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+ 		iismod |= S3C_IISMOD_24BIT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+
+	writel(iismod, s3c_i2s.regs + S3C_IISMOD);
+
+
+	debug_msg("s3c iis mode: 0x%08x\n", readl(s3c6410_i2s.regs + S3C64XX_IIS0MOD));
+	debug_msg("s3c: params_channels %d\n", params_channels(params));
+	debug_msg("s3c: params_format %d\n", params_format(params));
+	debug_msg("s3c: params_subformat %d\n", params_subformat(params));
+	debug_msg("s3c: params_period_size %d\n", params_period_size(params));
+	debug_msg("s3c: params_period_bytes %d\n", params_period_bytes(params));
+	debug_msg("s3c: params_periods %d\n", params_periods(params));
+	debug_msg("s3c: params_buffer_size %d\n", params_buffer_size(params));
+	debug_msg("s3c: params_buffer_bytes %d\n", params_buffer_bytes(params));
+	debug_msg("hw_params: IISMOD: %x\n", iismod);
+
+	return 0;
+}
+
+static int s3c_i2s_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	u32 iiscon, iisfic;
+	int timeout;
+
+	debug_msg("%s\n", __FUNCTION__);
+
+
+	/*Empty Tx FIFO*/
+	timeout = 50;
+	if (substream->stream  == SNDRV_PCM_STREAM_PLAYBACK){
+		iisfic = readl(s3c_i2s.regs + S3C_IISFIC);
+		iisfic |= S3C_IISFIC_TFLUSH;
+		writel(iisfic, s3c_i2s.regs + S3C_IISFIC);
+
+	do{
+	   iiscon = readl(s3c_i2s.regs + S3C_IISCON);
+		   if (!timeout--)
+		   	{
+		   	printk("Warning: Tx FIFO is not empty\n");
+		   	return 0;
+		   	}
+	}while((iiscon & S3C_IISCON_FTX0EMPT) != (S3C_IISCON_FTX0EMPT));
+	}
+
+
+	/*Empty Rx FIFO*/
+	timeout = 50;
+	if (substream->stream  == SNDRV_PCM_STREAM_CAPTURE){
+		iisfic = readl(s3c_i2s.regs + S3C_IISFIC);
+		iisfic |= S3C_IISFIC_RFLUSH;
+		writel(iisfic, s3c_i2s.regs + S3C_IISFIC);
+
+	do{
+	   iiscon = readl(s3c_i2s.regs + S3C_IISCON);
+		   if (!timeout--)
+		   	{
+		   	printk("Warning: Rx FIFO is not empty\n");
+		   	return 0;
+		   	}
+	}while((iiscon & S3C_IISCON_FRXEMPT) != (S3C_IISCON_FRXEMPT));
+	}
+	iisfic = readl(s3c_i2s.regs + S3C_IISFIC);
+	iisfic &= ~(S3C_IISFIC_TFLUSH | S3C_IISFIC_RFLUSH);
+	writel(iisfic, s3c_i2s.regs + S3C_IISFIC);
+
+	return 0;
+}
+
+static int s3c_i2s_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	u32 iismod;
+	
+	debug_msg("%s\n", __FUNCTION__);
+
+	iismod = readl(s3c_i2s.regs + S3C_IISMOD);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		if((iismod & S3C_IISMOD_TXRMASK) == S3C_IISMOD_RX){
+			iismod &= ~S3C_IISMOD_TXRMASK;
+			iismod |= S3C_IISMOD_TXRX;
+		}
+	}else{
+		if((iismod & S3C_IISMOD_TXRMASK) == S3C_IISMOD_TX){
+			iismod &= ~S3C_IISMOD_TXRMASK;
+			iismod |= S3C_IISMOD_TXRX;
+		}
+	}
+
+	writel(iismod, s3c_i2s.regs + S3C_IISMOD);
+
+
+	return 0;
+}
+
+
+static int s3c_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+				struct snd_soc_dai *dai)
+{
+	int ret = 0;
+
+	debug_msg("%s, stream:%d \n", __FUNCTION__, substream->stream);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (s3c_i2s.slave) {
+			ret = s3c_snd_lrsync();
+			if (ret)
+				goto exit_err;
+		}
+
+		debug_msg("Start\n");
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			s3c_snd_rxctrl(1);
+		else
+			s3c_snd_txctrl(1);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		debug_msg("Stop\n");
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			s3c_snd_rxctrl(0);
+		else
+			s3c_snd_txctrl(0);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+
+exit_err:
+	return ret;
+}
+
+/*
+ * Set s3c_ Clock source
+ * Since, we set frequencies using PreScaler and BFS, RFS, we select input clock source to the IIS here.
+ */
+static int s3c_i2s_set_sysclk(struct snd_soc_dai *cpu_dai,
+	int clk_id, unsigned int freq, int dir)
+{
+#if USE_CLKAUDIO
+	struct clk *clk;
+#endif
+	u32 iismod = readl(s3c_i2s.regs + S3C_IISMOD);
+
+	debug_msg("%s\n", __FUNCTION__);
+
+	switch (clk_id) {
+	case S3C_CLKSRC_PCLK:
+		if(s3c_i2s.slave)
+			return -EINVAL;
+		iismod &= ~S3C_IISMOD_IMSMASK;
+		iismod |= clk_id;
+		s3c_i2s.clk_rate = clk_get_rate(s3c_i2s.iis_clk);
+		break;
+
+#if USE_CLKAUDIO
+	case S3C_CLKSRC_CLKAUDIO:
+		if(s3c_i2s.slave)
+			return -EINVAL;
+		iismod &= ~S3C_IISMOD_IMSMASK;
+		iismod |= clk_id;
+/*
+8000 x 256 = 2048000
+         49152000 mod 2048000 = 0
+         32768000 mod 2048000 = 0 
+         73728000 mod 2048000 = 0
+
+11025 x 256 = 2822400
+         67738000 mod 2822400 = 400
+
+16000 x 256 = 4096000
+         49152000 mod 4096000 = 0
+         32768000 mod 4096000 = 0 
+         73728000 mod 4096000 = 0
+
+22050 x 256 = 5644800
+         67738000 mod 5644800 = 400
+
+32000 x 256 = 8192000
+         49152000 mod 8192000 = 0
+         32768000 mod 8192000 = 0
+         73728000 mod 8192000 = 0
+
+44100 x 256 = 11289600
+         67738000 mod 11289600 = 400
+
+48000 x 256 = 12288000
+         49152000 mod 12288000 = 0
+         73728000 mod 12288000 = 0
+
+64000 x 256 = 16384000
+         49152000 mod 16384000 = 0
+         32768000 mod 16384000 = 0
+
+88200 x 256 = 22579200
+         67738000 mod 22579200 = 400
+
+96000 x 256 = 24576000
+         49152000 mod 24576000 = 0
+         73728000 mod 24576000 = 0
+
+	From the table above, we find that 49152000 gives least(0) residue 
+	for most sample rates, followed by 67738000.
+*/
+		clk = clk_get(NULL, "fout_epll");
+		if (IS_ERR(clk)) {
+			printk("failed to get FOUTepll\n");
+			return -EBUSY;
+		}
+		clk_disable(clk);
+		switch (freq) {
+		case 8000:
+#ifdef CONFIG_SND_S3C64XX_SOC_I2S_REC_DOWNSAMPLING // sangsu fix
+			clk_set_rate(clk, 67738000);
+			break;
+#endif // sangsu fix
+		case 16000:
+		case 32000:
+		case 48000:
+		case 64000:
+		case 96000:
+			clk_set_rate(clk, 49152000);
+			break;
+		case 11025:
+		case 22050:
+		case 44100:
+		case 88200:
+		default:
+			clk_set_rate(clk, 67738000);
+			break;
+		}
+		clk_enable(clk);
+		s3c_i2s.clk_rate = clk_get_rate(s3c_i2s.audio_bus);
+		//printk("Setting FOUTepll to %dHz", s3c_i2s.clk_rate);
+		clk_put(clk);
+		break;
+#endif
+
+	case S3C_CLKSRC_SLVPCLK:
+	case S3C_CLKSRC_I2SEXT:
+#if USE_AP_MASTER
+		if(!s3c_i2s.slave)
+			{
+			printk("[warning]slave is not set\n");
+			return -EINVAL;
+			}
+#endif		
+		iismod &= ~S3C_IISMOD_IMSMASK;
+		iismod |= clk_id;
+		break;
+
+	/* Not sure about these two! */
+	case S3C_CDCLKSRC_INT:
+		iismod &= ~S3C_IISMOD_CDCLKCON;
+		break;
+
+	case S3C_CDCLKSRC_EXT:
+		iismod |= S3C_IISMOD_CDCLKCON;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	writel(iismod, s3c_i2s.regs + S3C_IISMOD);
+
+	return 0;
+}
+
+/*
+ * Set s3c_ Clock dividers
+ * NOTE: NOT all combinations of RFS, BFS and BCL are supported! XXX
+ * Machine specific(dai-link) code must consider that while setting MCLK and BCLK in this function. XXX
+ */
+/* XXX BLC(bits-per-channel) --> BFS(bit clock shud be >= FS*(Bit-per-channel)*2) XXX */
+/* XXX BFS --> RFS_VAL(must be a multiple of BFS)                                 XXX */
+/* XXX RFS_VAL & SRC_CLK --> Prescalar Value(SRC_CLK / RFS_VAL / fs - 1)          XXX */
+static int s3c_i2s_set_clkdiv(struct snd_soc_dai *cpu_dai,
+	int div_id, int div)
+{
+	u32 reg;
+
+	debug_msg("%s\n", __FUNCTION__);
+
+	switch (div_id) {
+	case S3C_DIV_MCLK:
+		reg = readl(s3c_i2s.regs + S3C_IISMOD) & ~S3C_IISMOD_RFSMASK;
+		switch(div) {
+		case 256: div = S3C_IISMOD_256FS; break;
+		case 512: div = S3C_IISMOD_512FS; break;
+		case 384: div = S3C_IISMOD_384FS; break;
+		case 768: div = S3C_IISMOD_768FS; break;
+		default: return -EINVAL;
+		}
+		writel(reg | div, s3c_i2s.regs + S3C_IISMOD);
+		break;
+	case S3C_DIV_BCLK:
+		reg = readl(s3c_i2s.regs + S3C_IISMOD) & ~S3C_IISMOD_BFSMASK;
+		switch(div) {
+		case 16: div = S3C_IISMOD_16FS; break;
+		case 24: div = S3C_IISMOD_24FS; break;
+		case 32: div = S3C_IISMOD_32FS; break;
+		case 48: div = S3C_IISMOD_48FS; break;
+		default: return -EINVAL;
+		}
+		writel(reg | div, s3c_i2s.regs + S3C_IISMOD);
+		break;
+	case S3C_DIV_PRESCALER:
+		reg = readl(s3c_i2s.regs + S3C_IISPSR) & ~S3C_IISPSR_PSRAEN;
+		writel(reg, s3c_i2s.regs + S3C_IISPSR);
+		reg = readl(s3c_i2s.regs + S3C_IISPSR) & ~S3C_IISPSR_PSVALA;
+		div &= 0x3f;
+		writel(reg | (div<<8) | S3C_IISPSR_PSRAEN, s3c_i2s.regs + S3C_IISPSR);
+		break;
+	default:
+		return -EINVAL;
+	}
+	
+	return 0;
+}
+
+/*
+ * To avoid duplicating clock code, allow machine driver to
+ * get the clockrate from here.
+ */
+u32 s3c_i2s_get_clockrate(void)
+{
+	debug_msg("%s\n", __FUNCTION__);
+
+	return s3c_i2s.clk_rate;
+}
+EXPORT_SYMBOL_GPL(s3c_i2s_get_clockrate);
+
+static irqreturn_t s3c_iis_irq(int irqno, void *dev_id)
+{
+	u32 iiscon;
+	
+	debug_msg("%s\n", __FUNCTION__);
+
+	iiscon  = readl(s3c_i2s.regs + S3C_IISCON);
+	if(S3C_IISCON_FTXURSTATUS & iiscon) {
+		iiscon &= ~S3C_IISCON_FTXURINTEN;
+		iiscon |= S3C_IISCON_FTXURSTATUS;
+		writel(iiscon, s3c_i2s.regs + S3C_IISCON);
+		printk("underrun interrupt IISCON = 0x%08x\n", readl(s3c_i2s.regs + S3C_IISCON));
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int s3c_i2s_probe(struct platform_device *pdev,
+	struct snd_soc_dai *dai)
+{
+	int ret = 0;
+#if USE_CLKAUDIO
+	struct clk *cm, *cf;
+#endif
+
+	debug_msg("%s\n", __FUNCTION__);
+
+	s3c_i2s.regs = ioremap(S3C_IIS_PABASE, 0x100);
+
+	/* Configure the I2S pins in correct mode */
+	s3c_gpio_cfgpin(GPIO_I2S_LRCLK, S3C_GPIO_SFN(GPIO_I2S_LRCLK_AF)); 
+	s3c_gpio_cfgpin(GPIO_I2S_CLK, S3C_GPIO_SFN(GPIO_I2S_CLK_AF)); 
+	s3c_gpio_cfgpin(GPIO_I2S_DI, S3C_GPIO_SFN(GPIO_I2S_DI_AF));   
+	s3c_gpio_cfgpin(GPIO_I2S_DO, S3C_GPIO_SFN(GPIO_I2S_DO_AF));
+
+    /* pull-up-enable, pull-down-disable*/
+	s3c_gpio_setpull(GPIO_I2S_CLK, S3C_GPIO_PULL_UP); 
+	s3c_gpio_setpull(GPIO_I2S_LRCLK, S3C_GPIO_PULL_UP); 
+	s3c_gpio_setpull(GPIO_I2S_DI, S3C_GPIO_PULL_UP); 
+	s3c_gpio_setpull(GPIO_I2S_DO, S3C_GPIO_PULL_UP); 
+
+	if (s3c_i2s.regs == NULL)
+		return -ENXIO;
+
+	ret = request_irq(S3C_IISIRQ, s3c_iis_irq, 0, "s3c-i2s", pdev);
+	if (ret < 0) {
+		printk("fail to claim i2s irq , ret = %d\n", ret);
+		iounmap(s3c_i2s.regs);
+		return -ENODEV;
+	}
+
+	s3c_i2s.iis_clk = clk_get(&pdev->dev, PCLKCLK);
+	if (IS_ERR(s3c_i2s.iis_clk)) {
+		printk("failed to get clk(%s)\n", PCLKCLK);
+		goto lb5;
+	}
+	clk_enable(s3c_i2s.iis_clk);
+	s3c_i2s.clk_rate = clk_get_rate(s3c_i2s.iis_clk);
+
+#if USE_CLKAUDIO
+	s3c_i2s.audio_bus = clk_get(NULL, EXTCLK);
+	if (IS_ERR(s3c_i2s.audio_bus)) {
+		printk("failed to get clk(%s)\n", EXTCLK);
+		goto lb4;
+	}
+
+	cm = clk_get(NULL, "mout_epll");
+	if (IS_ERR(cm)) {
+		printk("failed to get mout_epll\n");
+		goto lb3;
+	}
+	if(clk_set_parent(s3c_i2s.audio_bus, cm)){
+		printk("failed to set MOUTepll as parent of CLKAUDIO0\n");
+		goto lb2;
+	}
+
+	cf = clk_get(NULL, "fout_epll");
+	if (IS_ERR(cf)) {
+		printk("failed to get fout_epll\n");
+		goto lb2;
+	}
+	clk_enable(cf);
+	if(clk_set_parent(cm, cf)){
+		printk("failed to set FOUTepll as parent of MOUTepll\n");
+		goto lb1;
+	}
+	s3c_i2s.clk_rate = clk_get_rate(s3c_i2s.audio_bus);
+	clk_put(cf);
+	clk_put(cm);
+#endif
+
+#if defined(CONFIG_SND_S3C_I2S_V50)
+	writel(readl(s3c_i2s.regs + S3C_IISCON) | S3C_IISCON_SWRESET, s3c_i2s.regs + S3C_IISCON);
+#else
+	writel(S3C_IISCON_I2SACTIVE, s3c_i2s.regs + S3C_IISCON);
+#endif
+
+
+	s3c_snd_txctrl(0);
+	s3c_snd_rxctrl(0);
+
+
+	return 0;
+
+#if USE_CLKAUDIO
+lb1:
+	clk_put(cf);
+lb2:
+	clk_put(cm);
+lb3:
+	clk_put(s3c_i2s.audio_bus);
+lb4:
+	clk_disable(s3c_i2s.iis_clk);
+	clk_put(s3c_i2s.iis_clk);
+#endif
+lb5:
+	free_irq(S3C_IISIRQ, pdev);
+	iounmap(s3c_i2s.regs);
+	
+	return -ENODEV;
+}
+
+#ifdef CONFIG_PM
+static int s3c_i2s_suspend(struct snd_soc_dai *cpu_dai)
+{
+	debug_msg("%s\n", __FUNCTION__);
+
+	s3c_i2s.iiscon = readl(s3c_i2s.regs + S3C_IISCON);
+	s3c_i2s.iismod = readl(s3c_i2s.regs + S3C_IISMOD);
+	s3c_i2s.iisfic = readl(s3c_i2s.regs + S3C_IISFIC);
+	s3c_i2s.iispsr = readl(s3c_i2s.regs + S3C_IISPSR);
+
+	clk_disable(s3c_i2s.iis_clk);
+	debug_msg("%s-done\n", __FUNCTION__);
+
+	return 0;
+}
+
+static int s3c_i2s_resume(struct snd_soc_dai *cpu_dai)
+{
+	debug_msg("%s\n", __FUNCTION__);
+
+	clk_enable(s3c_i2s.iis_clk);
+
+	writel(s3c_i2s.iiscon, s3c_i2s.regs + S3C_IISCON);
+	writel(s3c_i2s.iismod, s3c_i2s.regs + S3C_IISMOD);
+	writel(s3c_i2s.iisfic, s3c_i2s.regs + S3C_IISFIC);
+	writel(s3c_i2s.iispsr, s3c_i2s.regs + S3C_IISPSR);
+
+	debug_msg("%s-done\n", __FUNCTION__);
+
+	return 0;
+}
+#else
+#define s3c_i2s_suspend NULL
+#define s3c_i2s_resume NULL
+#endif
+
+#if defined(CONFIG_S3C_DMA_PL080_SOL)
+/* Platform data structure for using DMAC - by jung */
+static struct dmac_info i2s0_info[] = {
+	{
+		.modalias	= "i2s0_tx",
+		.dma_port	= 0,
+		.conn_num	= I2S0_TX,
+		.hw_fifo	= S3C_IIS_PABASE + S3C_IISTXD,
+	},
+
+	{
+		.modalias	= "i2s0_rx",
+		.dma_port	= 0,
+		.conn_num	= I2S0_RX,
+		.hw_fifo	= S3C_IIS_PABASE + S3C_IISRXD,		
+	}
+};
+
+struct dmac_conn_info dmac_i2s0_info = {
+	.connection_num  = i2s0_info,
+	.array_size = ARRAY_SIZE(i2s0_info),
+};
+#endif
+
+struct snd_soc_dai s3c_i2s_dai = {
+	.name = "s3c-i2s",
+	.id = 0,
+	.probe = s3c_i2s_probe,
+	.suspend = s3c_i2s_suspend,
+	.resume = s3c_i2s_resume,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_96000,
+		.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_96000,
+		.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.ops = {
+		.hw_params = s3c_i2s_hw_params,
+		.prepare   = s3c_i2s_prepare,
+		.startup   = s3c_i2s_startup,
+		.trigger   = s3c_i2s_trigger,
+		.set_fmt = s3c_i2s_set_fmt,
+		.set_clkdiv = s3c_i2s_set_clkdiv,
+		.set_sysclk = s3c_i2s_set_sysclk,
+	},
+
+#ifdef CONFIG_S3C_DMA_PL080_SOL
+	.dma_data = &dmac_i2s0_info,
+#endif
+};
+EXPORT_SYMBOL_GPL(s3c_i2s_dai);
+
+static int __init s3c_i2s_init(void)
+{
+	return snd_soc_register_dai(&s3c_i2s_dai);
+}
+module_init(s3c_i2s_init);
+
+static void __exit s3c_i2s_exit(void)
+{
+	snd_soc_unregister_dai(&s3c_i2s_dai);
+}
+module_exit(s3c_i2s_exit);
+
+/* Module information */
+MODULE_AUTHOR("Jaswinder Singh <jassi.brar@samsung.com>");
+MODULE_DESCRIPTION(S3C_DESC);
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/s3c64xx/s3c6410-i2s.h linux-2.6.29-spica/sound/soc/s3c64xx/s3c6410-i2s.h
--- linux-2.6.29/sound/soc/s3c64xx/s3c6410-i2s.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/s3c6410-i2s.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,195 @@
+/*
+ * s3c-i2s.h  --  ALSA Soc Audio Layer
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#ifndef S3C_I2S_H_
+#define S3C_I2S_H_
+
+#define USE_CLKAUDIO	0
+#define USE_AP_MASTER   1 // 1: AP Master Mode, 0: Codec Master Mode
+
+/* Clock dividers */
+#define S3C_DIV_MCLK	0
+#define S3C_DIV_BCLK	1
+#define S3C_DIV_PRESCALER	2
+
+#define S3C_IISCON		(0x00)
+#define S3C_IISMOD		(0x04)
+#define S3C_IISFIC		(0x08)
+#define S3C_IISPSR		(0x0C)
+#define S3C_IISTXD		(0x10)
+#define S3C_IISRXD		(0x14)
+
+#define S3C_IISCON_I2SACTIVE	(0x1<<0)
+#define S3C_IISCON_RXDMACTIVE	(0x1<<1)
+#define S3C_IISCON_TXDMACTIVE	(0x1<<2)
+#define S3C_IISCON_RXCHPAUSE	(0x1<<3)
+#define S3C_IISCON_TXCHPAUSE	(0x1<<4)
+#define S3C_IISCON_RXDMAPAUSE	(0x1<<5)
+#define S3C_IISCON_TXDMAPAUSE	(0x1<<6)
+#define S3C_IISCON_FRXFULL		(0x1<<7)
+#if defined(CONFIG_SND_S3C_I2S_V40)
+#define S3C_IISCON_FTX0FULL		(0x1<<8)
+#else
+#define S3C_IISCON_FTXFULL		(0x1<<8)
+#endif
+#define S3C_IISCON_FRXEMPT		(0x1<<9)
+#define S3C_IISCON_FTX0EMPT		(0x1<<10)
+#define S3C_IISCON_LRI		(0x1<<11)
+#if defined(CONFIG_SND_S3C_I2S_V40)
+#define S3C_IISCON_FTX1FULL		(0x1<<12)
+#define S3C_IISCON_FTX2FULL		(0x1<<13)
+#define S3C_IISCON_FTX1EMPT		(0x1<<14)
+#define S3C_IISCON_FTX2EMPT		(0x1<<15)
+#endif
+#define S3C_IISCON_FTXURINTEN	(0x1<<16)
+#define S3C_IISCON_FTXURSTATUS	(0x1<<17)
+#if defined(CONFIG_SND_S3C_I2S_V32)
+#define S3C_IISCON_FRXORINTEN	(0x1<<18)
+#define S3C_IISCON_FRXORSTATUS	(0x1<<19)
+#endif
+#if defined(CONFIG_SND_S3C_I2S_V50)
+#define S3C_IISCON_SWRESET	(0x1<<31)
+#endif
+
+#define S3C_IISMOD_BFSMASK		(3<<1)
+#define S3C_IISMOD_32FS		(0<<1)
+#define S3C_IISMOD_48FS		(1<<1)
+#define S3C_IISMOD_16FS		(2<<1)
+#define S3C_IISMOD_24FS		(3<<1)
+
+#define S3C_IISMOD_RFSMASK		(3<<3)
+#define S3C_IISMOD_256FS		(0<<3)
+#define S3C_IISMOD_512FS		(1<<3)
+#define S3C_IISMOD_384FS		(2<<3)
+#define S3C_IISMOD_768FS		(3<<3)
+
+#define S3C_IISMOD_SDFMASK		(3<<5)
+#define S3C_IISMOD_IIS		(0<<5)
+#define S3C_IISMOD_MSB		(1<<5)
+#define S3C_IISMOD_LSB		(2<<5)
+
+#define S3C_IISMOD_LRP		(1<<7)
+
+#define S3C_IISMOD_TXRMASK		(3<<8)
+#define S3C_IISMOD_TX		(0<<8)
+#define S3C_IISMOD_RX		(1<<8)
+#define S3C_IISMOD_TXRX		(2<<8)
+
+#define S3C_IISMOD_IMSMASK		(3<<10)
+#define S3C_IISMOD_MSTPCLK		(0<<10)
+#define S3C_IISMOD_MSTCLKAUDIO	(1<<10)
+#define S3C_IISMOD_SLVPCLK		(2<<10)
+#define S3C_IISMOD_SLVI2SCLK	(3<<10)
+
+#define S3C_IISMOD_CDCLKCON		(1<<12)
+
+#define S3C_IISMOD_BLCMASK		(3<<13)
+#define S3C_IISMOD_16BIT		(0<<13)
+#define S3C_IISMOD_8BIT		(1<<13)
+#define S3C_IISMOD_24BIT		(2<<13)
+
+#if defined(CONFIG_SND_S3C_I2S_V40)
+
+#define S3C_IISMOD_SD1EN		(1<<16)
+#define S3C_IISMOD_SD2EN		(1<<17)
+
+#define S3C_IISMOD_CCD1MASK		(3<<18)
+#define S3C_IISMOD_CCD1ND		(0<<18)
+#define S3C_IISMOD_CCD11STD		(1<<18)
+#define S3C_IISMOD_CCD12NDD		(2<<18)
+
+#define S3C_IISMOD_CCD2MASK		(3<<20)
+#define S3C_IISMOD_CCD2ND		(0<<20)
+#define S3C_IISMOD_CCD21STD		(1<<20)
+#define S3C_IISMOD_CCD22NDD		(2<<20)
+
+#endif
+
+#define S3C_IISFIC_FRXCNTMSK	(0xf<<0)
+#define S3C_IISFIC_RFLUSH		(1<<7)
+#define S3C_IISFIC_FTX0CNTMSK	(0xf<<8)
+#define S3C_IISFIC_TFLUSH		(1<<15)
+#if defined(CONFIG_SND_S3C_I2S_V40)
+#define S3C_IISFIC_FTX1CNTMSK	(0xf<<16)
+#define S3C_IISFIC_FTX2CNTMSK	(0xf<<24)
+#endif
+
+#define S3C_IISPSR_PSVALA		(0x3f<<8)
+#define S3C_IISPSR_PSRAEN		(1<<15)
+
+/* clock sources */
+#define S3C_CLKSRC_PCLK		S3C_IISMOD_MSTPCLK
+#define S3C_CLKSRC_CLKAUDIO	S3C_IISMOD_MSTCLKAUDIO
+#define S3C_CLKSRC_SLVPCLK	S3C_IISMOD_SLVPCLK
+#define S3C_CLKSRC_I2SEXT	S3C_IISMOD_SLVI2SCLK
+#define S3C_CDCLKSRC_INT	(4<<10)
+#define S3C_CDCLKSRC_EXT	(5<<10)
+
+#if defined(CONFIG_CPU_S3C6410)
+#define S3C_PA_IIS_V32		S3C64XX_PA_IIS
+#define S3C_PA_IIS_V40		S3C64XX_PA_IIS_V40
+#define IRQ_S3C_IISV32		IRQ_S3C6410_IIS
+#define IRQ_S3C_IISV40		IRQ_S3C6410_IIS
+#elif defined(CONFIG_CPU_S5P6440)
+#define S3C_PA_IIS_V40		S5P64XX_PA_IIS_V40
+#define IRQ_S3C_IISV40		IRQ_IISV40
+#elif defined(CONFIG_CPU_S5PC100)
+#define S3C_PA_IIS_V32		S5PC1XX_PA_IIS_V32
+#define S3C_PA_IIS_V50		S5PC1XX_PA_IIS_V50
+#define IRQ_S3C_IISV32		IRQ_I2S1
+#define IRQ_S3C_IISV50		IRQ_I2S0
+#endif
+
+#if defined(CONFIG_SND_S3C_I2S_V32)
+
+#define S3C_DMACH_I2S_OUT	DMACH_I2S_OUT
+#define S3C_DMACH_I2S_IN	DMACH_I2S_IN
+#define S3C_IIS_PABASE		S3C_PA_IIS_V32
+#define S3C_IISIRQ		IRQ_S3C_IISV32
+//#define PCLKCLK			"i2s_v32"
+#define PCLKCLK			"iis"
+#if defined(CONFIG_CPU_S5PC100)
+#define EXTCLK			"sclk_audio1"
+#else
+//#define EXTCLK			"sclk_audio0"
+#define EXTCLK			"audio-bus0"
+#endif
+#define PLBK_CHAN		2
+#define S3C_DESC		"S3C AP I2S-V3.2 Interface"
+
+#elif defined(CONFIG_SND_S3C_I2S_V40)
+
+#define S3C_DMACH_I2S_OUT	DMACH_I2S_V40_OUT
+#define S3C_DMACH_I2S_IN	DMACH_I2S_V40_IN
+#define S3C_IIS_PABASE		S3C_PA_IIS_V40
+#define S3C_IISIRQ		IRQ_S3C_IISV40
+#define PCLKCLK			"i2s_v40"
+#define EXTCLK			"sclk_audio2"
+#define PLBK_CHAN		6
+#define S3C_DESC		"S3C AP I2S-V4.0 Interface"
+
+#elif defined(CONFIG_SND_S3C_I2S_V50)
+
+#define S3C_DMACH_I2S_OUT	DMACH_I2S_V50_OUT
+#define S3C_DMACH_I2S_IN	DMACH_I2S_V50_IN
+#define S3C_IIS_PABASE		S3C_PA_IIS_V50
+#define S3C_IISIRQ		IRQ_S3C_IISV50
+#define PCLKCLK			"i2s_v50"
+#define EXTCLK			"sclk_audio0"
+#define PLBK_CHAN		6
+#define S3C_DESC		"S3C AP I2S-V5.0 Interface"
+
+#endif
+
+u32 s3c_i2s_get_clockrate(void);
+
+extern struct snd_soc_dai s3c_i2s_dai;
+
+#endif /*S3C_I2S_H_*/
diff -Nur linux-2.6.29/sound/soc/s3c64xx/s3c6410-i2s-v32.c linux-2.6.29-spica/sound/soc/s3c64xx/s3c6410-i2s-v32.c
--- linux-2.6.29/sound/soc/s3c64xx/s3c6410-i2s-v32.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/s3c6410-i2s-v32.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,540 @@
+/*
+ * s3c-i2s.c  --  ALSA Soc Audio Layer
+ *
+ * (c) 2006 Wolfson Microelectronics PLC.
+ * Graeme Gregory graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ * (c) 2004-2005 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	Ryu Euiyoul <ryu.real@gmail.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *
+ *  Revision history
+ *    11th Dec 2006   Merged with Simtec driver
+ *    10th Nov 2006   Initial version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+
+#include <mach/map.h>
+#include <mach/gpio.h>
+#include <plat/regs-iis.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <plat/gpio-bank-b.h>
+#include <plat/gpio-bank-d.h>
+#include <plat/regs-clock.h>
+
+#include <mach/audio.h>
+#include <mach/dma.h>
+
+#include "s3c-pcm.h"
+#include "s3c-i2s.h"
+
+#ifdef CONFIG_SND_DEBUG
+#define s3cdbg(x...) printk(x)
+#else
+#define s3cdbg(x...)
+#endif
+
+/* used to disable sysclk if external crystal is used */
+static int extclk = 0;
+module_param(extclk, int, 0);
+MODULE_PARM_DESC(extclk, "set to 1 to disable s3c24XX i2s sysclk");
+
+static struct s3c2410_dma_client s3c24xx_dma_client_out = {
+	.name = "I2S PCM Stereo out"
+};
+
+static struct s3c2410_dma_client s3c24xx_dma_client_in = {
+	.name = "I2S PCM Stereo in"
+};
+
+static struct s3c24xx_pcm_dma_params s3c24xx_i2s_pcm_stereo_out = {
+	.client		= &s3c24xx_dma_client_out,
+	.channel	= DMACH_I2S_OUT,
+	.dma_addr	= S3C64XX_PA_IIS + S3C64XX_IISFIFO,
+	.dma_size	= 4,
+};
+
+static struct s3c24xx_pcm_dma_params s3c24xx_i2s_pcm_stereo_in = {
+	.client		= &s3c24xx_dma_client_in,
+	.channel	= DMACH_I2S_IN,
+	.dma_addr	= S3C64XX_PA_IIS + S3C64XX_IISFIFORX,
+	.dma_size	= 4,
+};
+
+struct s3c24xx_i2s_info {
+	void __iomem	*regs;
+	struct clk	*iis_clk;
+	int master;
+};
+static struct s3c24xx_i2s_info s3c24xx_i2s;
+
+static void s3c24xx_snd_txctrl(int on)
+{
+	u32 iisfcon;
+	u32 iiscon;
+	u32 iismod;
+
+	s3cdbg("Entered %s : on = %d \n", __FUNCTION__, on);
+
+	iiscon  = readl(s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+	iismod  = readl(s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+	iisfcon = readl(s3c24xx_i2s.regs + S3C64XX_IISFCON);
+
+	s3cdbg("r: IISCON: %x IISMOD: %x IISFCON: %x\n", iiscon, iismod, iisfcon);
+
+	if (on) {
+		iiscon |= S3C64XX_IIS0CON_I2SACTIVE;
+		writel(iismod,  s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+		writel(iisfcon, s3c24xx_i2s.regs + S3C64XX_IISFCON);
+		writel(iiscon,  s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+	} else {
+		/* note, we have to disable the FIFOs otherwise bad things
+		 * seem to happen when the DMA stops. According to the
+		 * Samsung supplied kernel, this should allow the DMA
+		 * engine and FIFOs to reset. If this isn't allowed, the
+		 * DMA engine will simply freeze randomly.
+		 */
+
+		iiscon &=~(S3C64XX_IIS0CON_I2SACTIVE);
+		iismod &= ~S3C64XX_IIS0MOD_TXMODE;
+
+		writel(iiscon,  s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+		writel(iisfcon, s3c24xx_i2s.regs + S3C64XX_IISFCON);
+		writel(iismod,  s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+	}
+
+	s3cdbg("w: IISCON: %x IISMOD: %x IISFCON: %x\n", iiscon, iismod, iisfcon);
+}
+
+static void s3c24xx_snd_rxctrl(int on)
+{
+	u32 iisfcon;
+	u32 iiscon;
+	u32 iismod;
+
+	s3cdbg("Entered %s: on = %d\n", __FUNCTION__, on);
+
+	iisfcon = readl(s3c24xx_i2s.regs + S3C64XX_IISFCON);
+	iiscon  = readl(s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+	iismod  = readl(s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	s3cdbg("r: IISCON: %x IISMOD: %x IISFCON: %x\n", iiscon, iismod, iisfcon);
+
+	if (on) {
+		
+		iiscon |= S3C64XX_IIS0CON_I2SACTIVE;
+
+		writel(iismod,  s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+		writel(iisfcon, s3c24xx_i2s.regs + S3C64XX_IISFCON);
+		writel(iiscon,  s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+	} else {
+		/* note, we have to disable the FIFOs otherwise bad things
+		 * seem to happen when the DMA stops. According to the
+		 * Samsung supplied kernel, this should allow the DMA
+		 * engine and FIFOs to reset. If this isn't allowed, the
+		 * DMA engine will simply freeze randomly.
+		 */
+
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410)
+		iisfcon &= ~S3C2410_IISFCON_RXENABLE;
+		iisfcon &= ~S3C2410_IISFCON_RXDMA;
+		iiscon  |= S3C2410_IISCON_RXIDLE;
+		iiscon  &= ~S3C2410_IISCON_RXDMAEN;
+		iismod  &= ~S3C2410_IISMOD_RXMODE;
+#else
+		iiscon &=~ S3C64XX_IIS0CON_I2SACTIVE;
+		iismod &= ~S3C64XX_IIS0MOD_RXMODE;
+#endif
+		writel(iisfcon, s3c24xx_i2s.regs + S3C64XX_IISFCON);
+		writel(iiscon,  s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+		writel(iismod,  s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	}
+	s3cdbg("w: IISCON: %x IISMOD: %x IISFCON: %x\n", iiscon, iismod, iisfcon);
+}
+
+/*
+ * Wait for the LR signal to allow synchronisation to the L/R clock
+ * from the codec. May only be needed for slave mode.
+ */
+static int s3c24xx_snd_lrsync(void)
+{
+	u32 iiscon;
+	unsigned long timeout = jiffies + msecs_to_jiffies(5);
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	while (1) {
+		iiscon = readl(s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+		if (iiscon & S3C64XX_IISCON_LRINDEX)
+			break;
+
+		if (timeout < jiffies)
+			return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+/*
+ * Check whether CPU is the master or slave
+ */
+static inline int s3c24xx_snd_is_clkmaster(void)
+{
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	return (readl(s3c24xx_i2s.regs + S3C64XX_IIS0MOD) & S3C64XX_IISMOD_SLAVE) ? 0:1;
+}
+
+/*
+ * Set S3C24xx I2S DAI format
+ */
+static int s3c_i2s_set_fmt(struct snd_soc_dai *cpu_dai,
+		unsigned int fmt)
+{
+#if 0
+	u32 iismod;
+
+	s3cdbg("Entered %s: fmt = %d\n", __FUNCTION__, fmt);
+
+	iismod = readl(s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410)
+		iismod |= S3C64XX_IISMOD_SLAVE;
+#else
+		iismod |= S3C2410_IISMOD_MASTER;
+#endif
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_LEFT_J:
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410)
+		iismod |= S3C2410_IISMOD_MSB;
+#else
+		iismod |= S3C_IIS0MOD_MSB;
+#endif
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	writel(iismod, s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+#endif
+	return 0;
+
+}
+
+static int s3c_i2s_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	unsigned long iiscon;
+	unsigned long iismod;
+	unsigned long iisfcon;
+
+	unsigned int *reg_GPDCON;
+	unsigned int *reg_GPBCON;
+	
+	reg_GPDCON = ioremap(0x7f008060,0x100);
+	reg_GPBCON = ioremap(0x7f008020,0x100);
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	/*Set I2C port to controll WM8753 codec*/
+	s3c_gpio_setpull(S3C64XX_GPB(5), S3C_GPIO_PULL_DOWN);
+	s3c_gpio_setpull(S3C64XX_GPB(6), S3C_GPIO_PULL_DOWN);
+	s3c_gpio_cfgpin(S3C64XX_GPB(5), S3C64XX_GPB5_I2C_SCL0);
+	s3c_gpio_cfgpin(S3C64XX_GPB(6), S3C64XX_GPB6_I2C_SDA0);
+
+	s3c24xx_i2s.master = 1;
+	
+	/* Configure the I2S pins in correct mode */
+	s3c_gpio_cfgpin(S3C64XX_GPD(2),S3C64XX_GPD2_I2S0_LRCLK);
+
+	if (s3c24xx_i2s.master && !extclk){
+		s3cdbg("Setting Clock Output as we are Master\n");
+		s3c_gpio_cfgpin(S3C64XX_GPD(0),S3C64XX_GPD0_I2S0_CLK);
+		
+	}
+	s3c_gpio_cfgpin(S3C64XX_GPD(1),S3C64XX_GPD1_I2S0_CDCLK);
+	s3c_gpio_cfgpin(S3C64XX_GPD(3),S3C64XX_GPD3_I2S0_DI);
+	s3c_gpio_cfgpin(S3C64XX_GPD(4),S3C64XX_GPD4_I2S0_DO);
+
+	/* pull-up-enable, pull-down-disable*/
+	s3c_gpio_setpull(S3C64XX_GPD(0), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S3C64XX_GPD(1), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S3C64XX_GPD(2), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S3C64XX_GPD(3), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S3C64XX_GPD(4), S3C_GPIO_PULL_UP);
+
+	s3cdbg("substream->stream : %d\n", substream->stream);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		rtd->dai->cpu_dai->dma_data = &s3c24xx_i2s_pcm_stereo_out;
+	} else {
+		rtd->dai->cpu_dai->dma_data = &s3c24xx_i2s_pcm_stereo_in;
+	}
+
+	/* Working copies of registers */
+	iiscon = readl(s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+	iismod = readl(s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+	iisfcon = readl(s3c24xx_i2s.regs + S3C64XX_IIS0FIC);
+	/* is port used by another stream */
+	if (!(iiscon & S3C64XX_IIS0CON_I2SACTIVE)) {
+
+		// Clear BFS field [2:1]
+		iismod &= ~(0x3<<1);
+		iismod |= S3C64XX_IIS0MOD_32FS | S3C64XX_IIS0MOD_INTERNAL_CLK;
+
+		if (!s3c24xx_i2s.master)
+			iismod |= S3C64XX_IIS0MOD_IMS_SLAVE;
+		else
+			iismod |= S3C64XX_IIS0MOD_IMS_EXTERNAL_MASTER;
+	}
+
+	/* enable TX & RX all to support Full-duplex */
+	iismod |= S3C64XX_IIS0MOD_TXRXMODE;
+	iiscon |= S3C64XX_IIS0CON_TXDMACTIVE;
+	iisfcon |= S3C64XX_IIS_TX_FLUSH;
+	iiscon |= S3C64XX_IIS0CON_RXDMACTIVE;
+	iisfcon |= S3C64XX_IIS_RX_FLUSH;
+
+	writel(iiscon, s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+	writel(iismod, s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+	writel(iisfcon, s3c24xx_i2s.regs + S3C64XX_IIS0FIC);
+
+	// Tx, Rx fifo flush bit clear
+	iisfcon  &= ~(S3C64XX_IIS_TX_FLUSH | S3C64XX_IIS_RX_FLUSH);
+	writel(iisfcon, s3c24xx_i2s.regs + S3C64XX_IIS0FIC);
+
+	s3cdbg("IISCON: %lx IISMOD: %lx", iiscon, iismod);
+
+	return 0;
+
+}
+
+static int s3c_i2s_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	int ret = 0;
+
+	s3cdbg("Entered %s: cmd = %d\n", __FUNCTION__, cmd);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (!s3c24xx_snd_is_clkmaster()) {
+			ret = s3c24xx_snd_lrsync();
+			if (ret)
+				goto exit_err;
+		}
+
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			s3c24xx_snd_rxctrl(1);
+		else
+			s3c24xx_snd_txctrl(1);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			s3c24xx_snd_rxctrl(0);
+		else
+			s3c24xx_snd_txctrl(0);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+exit_err:
+	return ret;
+}
+
+static void s3c64xx_i2s_shutdown(struct snd_pcm_substream *substream)
+{
+	unsigned long iismod, iiscon;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+	
+	iismod=readl(s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		iismod &= ~S3C64XX_IIS0MOD_TXMODE;
+	} else {
+		iismod &= ~S3C64XX_IIS0MOD_RXMODE;
+	}
+
+	writel(iismod,s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	iiscon=readl(s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+	iiscon &= !S3C64XX_IIS0CON_I2SACTIVE;
+	writel(iiscon,s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+
+	/* Clock disable 
+	 * PCLK & SCLK gating disable 
+	 */
+	__raw_writel(__raw_readl(S3C_PCLK_GATE)&~(S3C_CLKCON_PCLK_IIS0), S3C_PCLK_GATE);
+	__raw_writel(__raw_readl(S3C_SCLK_GATE)&~(S3C_CLKCON_SCLK_AUDIO0), S3C_SCLK_GATE);
+
+	/* EPLL disable */
+	__raw_writel(__raw_readl(S3C_EPLL_CON0)&~(1<<31) ,S3C_EPLL_CON0);	
+	
+}
+
+
+/*
+ * Set S3C24xx Clock source
+ */
+static int s3c_i2s_set_sysclk(struct snd_soc_dai *cpu_dai,
+	int clk_id, unsigned int freq, int dir)
+{
+	u32 iismod = readl(s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	s3cdbg("Entered %s : clk_id = %d\n", __FUNCTION__, clk_id);
+
+	iismod &= ~S3C64XX_IISMOD_MPLL;
+
+	switch (clk_id) {
+	case S3C24XX_CLKSRC_PCLK:
+		break;
+	case S3C24XX_CLKSRC_MPLL:
+		iismod |= S3C64XX_IISMOD_MPLL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	writel(iismod, s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+	return 0;
+}
+
+/*
+ * Set S3C24xx Clock dividers
+ */
+static int s3c_i2s_set_clkdiv(struct snd_soc_dai *cpu_dai,
+	int div_id, int div)
+{
+	u32 reg;
+
+	s3cdbg("Entered %s : div_id = %d, div = %d\n", __FUNCTION__, div_id, div);
+
+	switch (div_id) {
+	case S3C24XX_DIV_MCLK:
+		break;
+	case S3C24XX_DIV_BCLK:
+		reg = readl(s3c24xx_i2s.regs + S3C64XX_IIS0MOD) & ~(S3C64XX_IISMOD_384FS);
+		writel(reg | div, s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+		break;
+	case S3C24XX_DIV_PRESCALER:
+		writel(div|(1<<15),s3c24xx_i2s.regs + S3C64XX_IIS0PSR);
+		break;
+	default:
+		return -EINVAL;
+	}
+	
+	return 0;
+}
+
+static int s3c_i2s_probe(struct platform_device *pdev)
+{
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	s3c24xx_i2s.regs = ioremap(S3C64XX_PA_IIS, 0x100);
+	if (s3c24xx_i2s.regs == NULL)
+		return -ENXIO;
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int s3c_i2s_suspend(struct platform_device *dev,
+	struct snd_soc_cpu_dai *dai)
+{
+	s3cdbg("Entered %s\n", __FUNCTION__);
+	return 0;
+}
+
+static int s3c_i2s_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	s3cdbg("Entered %s\n", __FUNCTION__);
+	return 0;
+}
+
+#else
+#define s3c_i2s_suspend	NULL
+#define s3c_i2s_resume	NULL
+#endif
+
+
+#define S3C24XX_I2S_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+struct snd_soc_dai s3c_i2s_dai = {
+	.name = "s3c-i2s",
+	.id = 0,
+	.type = SND_SOC_DAI_I2S,
+	.probe = s3c_i2s_probe,
+	.suspend = s3c_i2s_suspend,
+	.resume = s3c_i2s_resume,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = S3C24XX_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE,},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = S3C24XX_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = {
+		.shutdown = s3c64xx_i2s_shutdown,
+		.trigger = s3c_i2s_trigger,
+		.hw_params = s3c_i2s_hw_params,},
+	.dai_ops = {
+		.set_fmt = s3c_i2s_set_fmt,
+		.set_clkdiv = s3c_i2s_set_clkdiv,
+		.set_sysclk = s3c_i2s_set_sysclk,
+	},
+};
+EXPORT_SYMBOL_GPL(s3c_i2s_dai);
+
+/* Module information */
+MODULE_AUTHOR("Ben Dooks, <ben@simtec.co.uk>");
+MODULE_DESCRIPTION("s3c24xx I2S SoC Interface");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/s3c64xx/s3c6410-i2s-v40.c linux-2.6.29-spica/sound/soc/s3c64xx/s3c6410-i2s-v40.c
--- linux-2.6.29/sound/soc/s3c64xx/s3c6410-i2s-v40.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/s3c6410-i2s-v40.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,664 @@
+/*
+ * s3c-i2s.c  --  ALSA Soc Audio Layer
+ *
+ * (c) 2006 Wolfson Microelectronics PLC.
+ * Graeme Gregory graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ * (c) 2004-2005 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	Ryu Euiyoul <ryu.real@gmail.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *
+ *  Revision history
+ *    11th Dec 2006   Merged with Simtec driver
+ *    10th Nov 2006   Initial version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+//#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+
+#include <mach/map.h>
+#include <mach/gpio.h>
+#include <plat/regs-iis.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <plat/gpio-bank-h.h>
+#include <plat/regs-clock.h>
+
+#include <mach/audio.h>
+#include <mach/dma.h>
+
+#include <plat/regs-clock.h>
+
+#include "s3c-pcm.h"
+#include "s3c-i2s.h"
+
+#ifdef CONFIG_SND_DEBUG
+#define s3cdbg(x...) printk(x)
+#else
+#define s3cdbg(x...)
+#endif
+
+/* used to disable sysclk if external crystal is used */
+static int extclk = 0;
+module_param(extclk, int, 0);
+MODULE_PARM_DESC(extclk, "set to 1 to disable s3c24XX i2s sysclk");
+
+static struct s3c2410_dma_client s3c24xx_dma_client_out = {
+	.name = "I2S PCM Stereo out"
+};
+
+static struct s3c2410_dma_client s3c24xx_dma_client_in = {
+	.name = "I2S PCM Stereo in"
+};
+
+static struct s3c24xx_pcm_dma_params s3c64xx_i2s_pcm_stereo_out = {
+	.client		= &s3c24xx_dma_client_out,
+	.channel	= DMACH_I2S_OUT,
+	.dma_addr	= S3C64XX_PA_IIS + S3C64XX_IISFIFO,
+	.dma_size	= 4,
+};
+
+static struct s3c24xx_pcm_dma_params s3c64xx_i2s_pcm_stereo_in = {
+	.client		= &s3c24xx_dma_client_in,
+	.channel	= DMACH_I2S_IN,
+	.dma_addr	= S3C64XX_PA_IIS + S3C64XX_IISFIFORX,
+	.dma_size	= 4,
+};
+
+struct s3c64xx_i2s_info {
+	void __iomem	*regs;
+	struct clk	*iis_clk;
+	u32		iiscon;
+	u32		iismod;
+	u32		iisfcon;
+	u32		iispsr;
+	int master;
+};
+static struct s3c64xx_i2s_info s3c64xx_i2s;
+
+static void s3c24xx_snd_txctrl(int on)
+{
+	u32 iiscon;
+	u32 iismod;
+
+	s3cdbg("Entered %s : on = %d \n", __FUNCTION__, on);
+
+	iiscon  = readl(s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+	iismod  = readl(s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	s3cdbg("r: IISCON: %x IISMOD: %x\n", iiscon, iismod);
+
+	if (on) {
+		iiscon |= S3C64XX_IIS0CON_I2SACTIVE; 	// IIS interface active
+
+		writel(iismod,  s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+		writel(iiscon,  s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+
+	} else {
+		/* note, we have to disable the FIFOs otherwise bad things
+		 * seem to happen when the DMA stops. According to the
+		 * Samsung supplied kernel, this should allow the DMA
+		 * engine and FIFOs to reset. If this isn't allowed, the
+		 * DMA engine will simply freeze randomly.
+		 */
+		iiscon &=~(S3C64XX_IIS0CON_I2SACTIVE);
+		iismod &= ~S3C64XX_IIS0MOD_TXMODE;
+
+		writel(iiscon,  s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+		writel(iismod,  s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+	}
+
+	s3cdbg("w: IISCON: %x IISMOD: %x\n", iiscon, iismod);
+}
+
+static void s3c24xx_snd_rxctrl(int on)
+{
+	u32 iisfcon;
+	u32 iiscon;
+	u32 iismod;
+
+	s3cdbg("Entered %s: on = %d\n", __FUNCTION__, on);
+
+	iisfcon = readl(s3c64xx_i2s.regs + S3C64XX_IIS0FIC);
+	iiscon  = readl(s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+	iismod  = readl(s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	s3cdbg("r: IISCON: %x IISMOD: %x IISFCON: %x\n", iiscon, iismod, iisfcon);
+
+	if (on) {
+		iiscon |= S3C64XX_IIS0CON_I2SACTIVE;
+
+		writel(iismod,  s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+		writel(iisfcon, s3c64xx_i2s.regs + S3C64XX_IIS0FIC);
+		writel(iiscon,  s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+	} else {
+		/* note, we have to disable the FIFOs otherwise bad things
+		 * seem to happen when the DMA stops. According to the
+		 * Samsung supplied kernel, this should allow the DMA
+		 * engine and FIFOs to reset. If this isn't allowed, the
+		 * DMA engine will simply freeze randomly.
+		 */
+
+		iiscon &=~ S3C64XX_IIS0CON_I2SACTIVE;
+		iismod &= ~S3C64XX_IIS0MOD_RXMODE;
+
+		writel(iisfcon, s3c64xx_i2s.regs + S3C64XX_IIS0FIC);
+		writel(iiscon,  s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+		writel(iismod,  s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	}
+	s3cdbg("w: IISCON: %x IISMOD: %x IISFCON: %x\n", iiscon, iismod, iisfcon);
+}
+
+/*
+ * Wait for the LR signal to allow synchronisation to the L/R clock
+ * from the codec. May only be needed for slave mode.
+ */
+static int s3c24xx_snd_lrsync(void)
+{
+	u32 iiscon;
+	unsigned long timeout = jiffies + msecs_to_jiffies(5);
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	while (1) {
+		iiscon = readl(s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+		if (iiscon & S3C64XX_IISCON_LRINDEX) // !! invalid register (IIS0CON : 1<<8) !!
+			break;
+
+		if (timeout < jiffies)
+			return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+/*
+ * Check whether CPU is the master or slave
+ */
+static inline int s3c24xx_snd_is_clkmaster(void)
+{
+	s3cdbg("Entered %s\n", __FUNCTION__);
+#if 0
+printk("[I2S] !!! -> IISMOD_SLAVE bit is invalid\n");
+	return (readl(s3c64xx_i2s.regs + S3C64XX_IIS0MOD) & S3C64XX_IISMOD_SLAVE) ? 0:1;
+#else
+	return (readl(s3c64xx_i2s.regs + S3C64XX_IIS0MOD) & (1 << 11)) ? 0:1;
+#endif
+}
+
+/*
+ * Set S3C24xx I2S DAI format
+ */
+static int s3c_i2s_v40_set_fmt(struct snd_soc_dai *cpu_dai,
+		unsigned int fmt)
+{
+#if 0
+	u32 iismod;
+
+	s3cdbg("Entered %s: fmt = %d\n", __FUNCTION__, fmt);
+
+	iismod = readl(s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+#ifndef CONFIG_CPU_S3C6400
+		iismod |= S3C_IIS0MOD_SLAVE;
+#else
+		iismod |= S3C_IIS0MOD_MASTER;
+#endif
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_LEFT_J:
+#ifndef CONFIG_CPU_S3C6400
+		iismod |= S3C_IIS0MOD_MSB;
+#else
+		iismod |= S3C_IIS0MOD_MSB;
+#endif
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	writel(iismod, s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+#endif
+	return 0;
+
+}
+
+static int s3c_i2s_v40_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	unsigned long iiscon;
+	unsigned long iismod;
+	unsigned long iisfcon;
+	
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+#ifdef CONFIG_MACH_INSTINCTQ
+	s3c64xx_i2s.master = 1;
+#else
+	s3c64xx_i2s.master = 0;
+#endif
+	
+	/* Configure the I2S pins in correct mode */
+	s3c_gpio_cfgpin(GPIO_I2S_LRCLK, S3C_GPIO_SFN(GPIO_I2S_LRCLK_AF)); 
+	s3c_gpio_cfgpin(GPIO_I2S_CLK, S3C_GPIO_SFN(GPIO_I2S_CLK_AF)); 
+	s3c_gpio_cfgpin(GPIO_I2S_DI, S3C_GPIO_SFN(GPIO_I2S_DI_AF));   
+	s3c_gpio_cfgpin(GPIO_I2S_DO, S3C_GPIO_SFN(GPIO_I2S_DO_AF));
+
+    /* pull-up-enable, pull-down-disable*/
+	s3c_gpio_setpull(GPIO_I2S_CLK, S3C_GPIO_PULL_UP); 
+	s3c_gpio_setpull(GPIO_I2S_LRCLK, S3C_GPIO_PULL_UP); 
+	s3c_gpio_setpull(GPIO_I2S_DI, S3C_GPIO_PULL_UP); 
+	s3c_gpio_setpull(GPIO_I2S_DO, S3C_GPIO_PULL_UP); 
+
+	if (s3c64xx_i2s.master && !extclk){
+		s3cdbg("Setting Clock Output as we are Master\n");
+		//s3c_gpio_cfgpin(S3C64XX_GPH(6),S3C64XX_GPH6_I2S_V40_BCLK); // BCLK??
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		rtd->dai->cpu_dai->dma_data = &s3c64xx_i2s_pcm_stereo_out;
+	} else {
+		rtd->dai->cpu_dai->dma_data = &s3c64xx_i2s_pcm_stereo_in;
+	}
+
+	/* Working copies of registers */
+	iiscon = readl(s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+	iismod = readl(s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+	iisfcon = readl(s3c64xx_i2s.regs + S3C64XX_IIS0FIC);
+
+	/* is port used by another stream */
+	if (!(iiscon & S3C64XX_IIS0CON_I2SACTIVE)) {
+
+		/* Clear BFS field [2:1] */
+		iismod &= ~(0x3<<1);
+		iismod |= S3C64XX_IIS0MOD_32FS | S3C64XX_IIS0MOD_INTERNAL_CLK;
+
+		if (!s3c64xx_i2s.master)
+			iismod |= S3C64XX_IIS0MOD_IMS_I2SCLK_SLAVE;
+		else
+			iismod |= S3C64XX_IIS0MOD_IMS_EXTERNAL_MASTER;
+	}
+#if 0
+	iiscon |= S3C64XX_IISCON_FTXURINTEN;
+	iiscon |= S3C64XX_IIS0CON_TXDMACTIVE;
+	iiscon |= S3C64XX_IIS0CON_RXDMACTIVE;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		iismod |= S3C64XX_IIS0MOD_TXMODE;
+		iisfcon |= S3C64XX_IIS_TX_FLUSH;
+	} else {
+		iismod |= S3C64XX_IIS0MOD_RXMODE;
+		iisfcon |= S3C64XX_IIS_RX_FLUSH;
+	}
+#else
+	iiscon |= S3C64XX_IISCON_FTXURINTEN;
+	iismod |= S3C64XX_IIS0MOD_TXRXMODE; 
+	iiscon |= S3C64XX_IIS0CON_TXDMACTIVE;
+	iisfcon |= S3C64XX_IIS_TX_FLUSH;
+	iiscon |= S3C64XX_IIS0CON_RXDMACTIVE;
+	iisfcon |= S3C64XX_IIS_RX_FLUSH;
+#endif
+
+#if 0
+/* multi channel manual? */
+
+	/* Multi channel enable */
+	iismod &= ~S3C64XX_IIS0MOD_DCE_MASK;
+	switch (params_channels(params)) {
+	case 6:
+		printk("s3c i2s: 5.1channel\n");
+		iismod |= S3C64XX_IIS0MOD_DCE_SD2;
+		iismod |= S3C64XX_IIS0MOD_DCE_SD2;
+		break;
+	case 4:
+		printk("s3c i2s: 4 channel\n");
+		iismod |= S3C64XX_IIS0MOD_DCE_SD2;
+		break;
+	case 2:
+		printk("s3c i2s: 2 channel\n");
+		break;
+	default:
+		printk(KERN_ERR "s3c-i2s-v40: %d channels unsupported\n",
+		       params_channels(params));
+		return -EINVAL;
+	}
+#endif
+
+	/* Set the bit rate */
+	iismod &= ~0x6000;
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		iismod &= ~S3C64XX_IIS0MOD_FS_MASK;
+		iismod |= S3C64XX_IIS0MOD_256FS | S3C64XX_IIS0MOD_32FS;
+		iismod &= ~(0x3<<13); 		// BLC(Bit Length Control) bit clear
+		iismod |= S3C64XX_IIS0MOD_16BIT;
+		break;
+	case SNDRV_PCM_FORMAT_S8:
+		iismod |= S3C64XX_IIS0MOD_8BIT;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		iismod &= ~S3C64XX_IIS0MOD_FS_MASK;
+		iismod |= S3C64XX_IIS0MOD_384FS | S3C64XX_IIS0MOD_48FS;
+		iismod &= ~(0x3<<13);		// BLC(Bit Length Control) bit clear
+		iismod |= S3C64XX_IIS0MOD_24BIT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	writel(iisfcon, s3c64xx_i2s.regs + S3C64XX_IIS0FIC);
+	writel(iiscon, s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+	writel(iismod, s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	// Tx, Rx fifo flush bit clear
+	iisfcon  &= ~(S3C64XX_IIS_TX_FLUSH | S3C64XX_IIS_RX_FLUSH);
+	writel(iisfcon, s3c64xx_i2s.regs + S3C64XX_IIS0FIC);
+
+	s3cdbg("s3c iis mode: 0x%08x\n", readl(s3c64xx_i2s.regs + S3C64XX_IIS0MOD));
+	s3cdbg("s3c: params_channels %d\n", params_channels(params));
+	s3cdbg("s3c: params_format %d\n", params_format(params));
+	s3cdbg("s3c: params_subformat %d\n", params_subformat(params));
+	s3cdbg("s3c: params_period_size %d\n", params_period_size(params));
+	s3cdbg("s3c: params_period_bytes %d\n", params_period_bytes(params));
+	s3cdbg("s3c: params_periods %d\n", params_periods(params));
+	s3cdbg("s3c: params_buffer_size %d\n", params_buffer_size(params));
+	s3cdbg("s3c: params_buffer_bytes %d\n", params_buffer_bytes(params));
+//	s3cdbg("s3c: params_tick_time %d\n", params_tick_time(params));
+	s3cdbg("hw_params: IISCON: %lx IISMOD: %lx\n", iiscon, iismod);
+
+	return 0;
+
+}
+
+static int s3c_i2s_v40_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	int ret = 0;
+
+	s3cdbg("Entered %s: cmd = %d\n", __FUNCTION__, cmd);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (!s3c24xx_snd_is_clkmaster()) {
+			ret = s3c24xx_snd_lrsync();
+			if (ret)
+				goto exit_err;
+		}
+
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			s3c24xx_snd_rxctrl(1);
+		else
+			s3c24xx_snd_txctrl(1);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			s3c24xx_snd_rxctrl(0);
+		else
+			s3c24xx_snd_txctrl(0);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+exit_err:
+	return ret;
+}
+
+static void s3c64xx_i2s_shutdown(struct snd_pcm_substream *substream)
+{
+	unsigned long iismod, iiscon;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+	
+	iismod=readl(s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		iismod &= ~S3C64XX_IIS0MOD_TXMODE;
+	} else {
+		iismod &= ~S3C64XX_IIS0MOD_RXMODE;
+	}
+
+	writel(iismod, s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	iiscon=readl(s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+	iiscon &= !S3C64XX_IIS0CON_I2SACTIVE;
+	writel(iiscon, s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+
+	/* Clock disable 
+	 * PCLK & SCLK gating disable 
+	 */
+	__raw_writel(__raw_readl(S3C_PCLK_GATE)&~(S3C_CLKCON_PCLK_IIS0), S3C_PCLK_GATE);
+	__raw_writel(__raw_readl(S3C_SCLK_GATE)&~(S3C_CLKCON_SCLK_AUDIO0), S3C_SCLK_GATE);
+
+	/* EPLL disable */
+	__raw_writel(__raw_readl(S3C_EPLL_CON0)&~(1<<31) ,S3C_EPLL_CON0);	
+}
+
+
+/*
+ * Set S3C24xx Clock source
+ */
+static int s3c_i2s_v40_set_sysclk(struct snd_soc_dai *cpu_dai,
+	int clk_id, unsigned int freq, int dir)
+{
+	u32 iismod = readl(s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	s3cdbg("Entered %s : clk_id = %d\n", __FUNCTION__, clk_id);
+
+	iismod &= ~S3C64XX_IISMOD_MPLL;
+
+	switch (clk_id) {
+	case S3C24XX_CLKSRC_PCLK:
+		break;
+	case S3C24XX_CLKSRC_MPLL:
+		//iismod |= S3C64XX_IISMOD_MPLL;
+		iismod |= S3C64XX_IIS0MOD_IMS_I2SCLK_SLAVE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	writel(iismod, s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+	return 0;
+}
+
+/*
+ * Set S3C24xx Clock dividers
+ */
+static int s3c_i2s_v40_set_clkdiv(struct snd_soc_dai *cpu_dai,
+	int div_id, int div)
+{
+	u32 reg;
+
+	s3cdbg("Entered %s : div_id = %d, div = %x\n", __FUNCTION__, div_id, div);
+
+	switch (div_id) {
+	case S3C24XX_DIV_MCLK:
+		break;
+	case S3C24XX_DIV_BCLK:
+		// bit clock frequency select
+		reg = readl(s3c64xx_i2s.regs + S3C64XX_IIS0MOD) & ~(S3C64XX_IIS0MOD_FS_MASK);
+printk("[I2S] set BFS : %d\n", div);
+		writel(reg | div, s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+		break;
+	case S3C24XX_DIV_PRESCALER:
+		if (div)
+			div = (1 << 15) | ((div-1) << 8);
+		s3cdbg("[I2S] set div prescaler : 0x%x\n", div);
+
+		writel(div, s3c64xx_i2s.regs + S3C64XX_IIS0PSR);
+		break;
+	default:
+		return -EINVAL;
+	}
+	
+	return 0;
+}
+
+/*
+ * To avoid duplicating clock code, allow machine driver to
+ * get the clockrate from here.
+ */
+u32 s3c_i2s_v40_get_clockrate(void)
+{
+	return clk_get_rate(s3c64xx_i2s.iis_clk);
+}
+EXPORT_SYMBOL_GPL(s3c_i2s_v40_get_clockrate);
+
+static irqreturn_t s3c_iis_irq(int irqno, void *dev_id)
+{
+	u32 iiscon;
+	
+printk("[I2S] interrupt! ----> s3c_iis_irq \n");
+	iiscon  = readl(s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+	if((1<<17) & iiscon) {
+		iiscon &= ~(1<<16);
+		iiscon |= (1<<17);
+		writel(iiscon, s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+		printk("underrun interrupt IISCON = 0x%08x\n", readl(s3c64xx_i2s.regs + S3C64XX_IIS0CON));
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int s3c_i2s_v40_probe(struct platform_device *pdev,
+	struct snd_soc_dai *dai)
+{
+	int ret;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+	s3c64xx_i2s.regs = ioremap(S3C64XX_PA_IIS, 0x100);
+
+	if (s3c64xx_i2s.regs == NULL)
+		return -ENXIO;
+
+	s3c64xx_i2s.iis_clk=clk_get(&pdev->dev, "iis");
+	if (s3c64xx_i2s.iis_clk == NULL) {
+		printk("failed to get iis_clock\n");
+		iounmap(s3c64xx_i2s.regs);
+		return -ENODEV;
+	}
+	clk_enable(s3c64xx_i2s.iis_clk);
+
+	ret = request_irq(IRQ_S3C6410_IIS, s3c_iis_irq, 0,
+			 "s3c-i2s-v40", pdev);
+	if (ret < 0) {
+		printk("fail to claim i2s irq , ret = %d\n", ret);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int s3c_i2s_v40_suspend(struct platform_device *dev,
+	struct snd_soc_dai *dai)
+{
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	s3c64xx_i2s.iiscon = readl(s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+	s3c64xx_i2s.iismod = readl(s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+	s3c64xx_i2s.iisfcon = readl(s3c64xx_i2s.regs + S3C64XX_IIS0FIC);
+	s3c64xx_i2s.iispsr = readl(s3c64xx_i2s.regs + S3C64XX_IIS0PSR);
+
+	clk_disable(s3c64xx_i2s.iis_clk);
+
+	return 0;
+}
+
+static int s3c_i2s_v40_resume(struct platform_device *pdev,
+	struct snd_soc_dai *dai)
+{
+	s3cdbg("Entered %s\n", __FUNCTION__);
+	clk_enable(s3c64xx_i2s.iis_clk);
+
+	writel(s3c64xx_i2s.iiscon, s3c64xx_i2s.regs + S3C64XX_IIS0CON);
+	writel(s3c64xx_i2s.iismod, s3c64xx_i2s.regs + S3C64XX_IIS0MOD);
+	writel(s3c64xx_i2s.iisfcon, s3c64xx_i2s.regs + S3C64XX_IIS0FIC);
+	writel(s3c64xx_i2s.iispsr, s3c64xx_i2s.regs + S3C64XX_IIS0PSR);
+
+	return 0;
+}
+
+#else
+#define s3c_i2s_v40_suspend	NULL
+#define s3c_i2s_v40_resume	NULL
+#endif
+
+
+#define S3C24XX_I2S_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+struct snd_soc_dai s3c_i2s_v40_dai = {
+	.name = "s3c-i2s-v40",
+	.id = 0,
+	.type = SND_SOC_DAI_I2S,
+	.probe = s3c_i2s_v40_probe,
+	.suspend = s3c_i2s_v40_suspend,
+	.resume = s3c_i2s_v40_resume,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 6,
+		.rates = S3C24XX_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = S3C24XX_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,},
+	.ops = {
+		.shutdown = s3c64xx_i2s_shutdown,
+		.trigger = s3c_i2s_v40_trigger,
+		.hw_params = s3c_i2s_v40_hw_params,},
+	.dai_ops = {
+		.set_fmt = s3c_i2s_v40_set_fmt,
+		.set_clkdiv = s3c_i2s_v40_set_clkdiv,
+		.set_sysclk = s3c_i2s_v40_set_sysclk,
+	},
+};
+EXPORT_SYMBOL_GPL(s3c_i2s_v40_dai);
+
+/* Module information */
+MODULE_AUTHOR("Ben Dooks, <ben@simtec.co.uk>");
+MODULE_DESCRIPTION("s3c24xx I2S SoC Interface");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/s3c64xx/s3c64xx-ac97.c linux-2.6.29-spica/sound/soc/s3c64xx/s3c64xx-ac97.c
--- linux-2.6.29/sound/soc/s3c64xx/s3c64xx-ac97.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/s3c64xx-ac97.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,489 @@
+/*
+ * s3c6400-ac97.c  --  ALSA Soc Audio Layer
+ *
+ *  Copyright (C) 2007, Ryu Euiyoul <ryu.real@gmail.com>
+ *
+ * (c) 2007 Wolfson Microelectronics PLC.
+ * Graeme Gregory graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Copyright (C) 2007, Ryu Euiyoul <ryu.real@gmail.com>
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  Revision history
+ *	21st Mar 2007   Initial Version
+ *	20th Sep 2007   Apply at s3c6400
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <plat/regs-ac97.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-gpio.h>
+#include <plat/gpio-bank-h.h>
+#include <plat/regs-clock.h>
+#include <mach/audio.h>
+#include <mach/dma.h>
+#include <asm/dma.h>
+
+#include "../s3c24xx/s3c-pcm.h"
+#include "s3c64xx-ac97.h"
+
+#ifdef CONFIG_SND_DEBUG
+#define s3cdbg(x...) printk(x)
+#else
+#define s3cdbg(x...)
+#endif
+
+extern struct clk *clk_get(struct device *dev, const char *id);
+extern int clk_enable(struct clk *clk);
+extern void clk_disable(struct clk *clk);
+
+struct s3c24xx_ac97_info {
+	void __iomem	*regs;
+	struct clk	*ac97_clk;
+};
+static struct s3c24xx_ac97_info s3c24xx_ac97;
+
+static u32 codec_ready;
+static DEFINE_MUTEX(ac97_mutex);
+static DECLARE_WAIT_QUEUE_HEAD(gsr_wq);
+
+static unsigned short s3c6400_ac97_read(struct snd_ac97 *ac97,
+	unsigned short reg)
+{
+	u32 ac_glbctrl;
+	u32 ac_codec_cmd;
+	u32 stat, addr, data;
+
+	s3cdbg("Entered %s: reg=0x%x\n", __FUNCTION__, reg);
+
+	mutex_lock(&ac97_mutex);
+
+	codec_ready = S3C_AC97_GLBSTAT_CODECREADY;
+	ac_codec_cmd = S3C_AC97_CODEC_CMD_READ | AC_CMD_ADDR(reg);
+	writel(ac_codec_cmd, s3c24xx_ac97.regs + S3C_AC97_CODEC_CMD);
+
+	udelay(1000);
+
+	ac_glbctrl = readl(s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	ac_glbctrl |= S3C_AC97_GLBCTRL_CODECREADYIE;
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+
+	stat = readl(s3c24xx_ac97.regs + S3C_AC97_STAT);
+	addr = (stat >> 16) & 0x7f;
+	data = (stat & 0xffff);
+
+	wait_event_timeout(gsr_wq,addr==reg,1);
+	if(addr!=reg){
+		printk(KERN_ERR"AC97: read error (ac97_reg=%x addr=%x)\n", reg, addr);
+		printk(KERN_ERR"Check audio codec jumpper settings\n\n");
+		goto out;
+	}
+
+out:	mutex_unlock(&ac97_mutex);
+	return (unsigned short)data;
+}
+
+static void s3c6400_ac97_write(struct snd_ac97 *ac97, unsigned short reg,
+	unsigned short val)
+{
+	u32 ac_glbctrl;
+	u32 ac_codec_cmd;
+	u32 stat, data;
+
+	s3cdbg("Entered %s: reg=0x%x, val=0x%x\n", __FUNCTION__,reg,val);
+
+	mutex_lock(&ac97_mutex);
+
+	codec_ready = S3C_AC97_GLBSTAT_CODECREADY;
+	ac_codec_cmd = AC_CMD_ADDR(reg) | AC_CMD_DATA(val);
+	writel(ac_codec_cmd, s3c24xx_ac97.regs + S3C_AC97_CODEC_CMD);
+
+	udelay(50);
+
+	ac_glbctrl = readl(s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	ac_glbctrl |= S3C_AC97_GLBCTRL_CODECREADYIE;
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+
+	ac_codec_cmd |= S3C_AC97_CODEC_CMD_READ;
+	writel(ac_codec_cmd, s3c24xx_ac97.regs + S3C_AC97_CODEC_CMD);
+
+	stat = readl(s3c24xx_ac97.regs + S3C_AC97_CODEC_CMD);
+	data = (stat & 0xffff);
+
+	wait_event_timeout(gsr_wq,data==val,1);
+	if(data!=val){
+		printk("%s: write error (ac97_val=%x data=%x)\n",
+				__FUNCTION__, val, data);
+	}
+
+	mutex_unlock(&ac97_mutex);
+}
+
+static void s3c6400_ac97_warm_reset(struct snd_ac97 *ac97)
+{
+	u32 ac_glbctrl;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	ac_glbctrl = readl(s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	ac_glbctrl |= S3C_AC97_GLBCTRL_WARMRESET;
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	msleep(1);
+
+	ac_glbctrl &= ~S3C_AC97_GLBCTRL_WARMRESET;
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	msleep(1);
+	
+	ac_glbctrl = S3C_AC97_GLBCTRL_ACLINKON;
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	msleep(1);
+
+	ac_glbctrl = S3C_AC97_GLBCTRL_TRANSFERDATAENABLE;
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	msleep(1);
+
+	ac_glbctrl |= S3C_AC97_GLBCTRL_PCMOUTTM_DMA |
+		S3C_AC97_GLBCTRL_PCMINTM_DMA | S3C_AC97_GLBCTRL_MICINTM_DMA;
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+
+	ac_glbctrl = readl(s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	ac_glbctrl |= S3C_AC97_GLBCTRL_ACLINKON;
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	udelay(1000);
+}
+
+static void s3c6400_ac97_cold_reset(struct snd_ac97 *ac97)
+{
+	u32 ac_glbctrl;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	ac_glbctrl = S3C_AC97_GLBCTRL_COLDRESET;
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	msleep(1);
+
+	ac_glbctrl &= ~S3C_AC97_GLBCTRL_COLDRESET;
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	msleep(1);
+
+	ac_glbctrl = S3C_AC97_GLBCTRL_COLDRESET;
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	msleep(1);
+
+	ac_glbctrl &= ~S3C_AC97_GLBCTRL_COLDRESET;
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	msleep(1);
+}
+
+static irqreturn_t s3c6400_ac97_irq(int irq, void *dev_id)
+{
+	int status;
+	u32 ac_glbctrl, ac_glbstat;
+
+	ac_glbstat = readl(s3c24xx_ac97.regs + S3C_AC97_GLBSTAT);
+
+	s3cdbg("Entered %s: AC_GLBSTAT = 0x%x\n", __FUNCTION__, ac_glbstat);
+
+	status = ac_glbstat & codec_ready;
+
+
+	if (status) {
+		ac_glbctrl = readl(s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+		ac_glbctrl &= ~S3C_AC97_GLBCTRL_CODECREADYIE;
+		writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+		wake_up(&gsr_wq);
+	}
+	return IRQ_HANDLED;
+}
+
+struct snd_ac97_bus_ops soc_ac97_ops = {
+	.read	= s3c6400_ac97_read,
+	.write	= s3c6400_ac97_write,
+	.warm_reset	= s3c6400_ac97_warm_reset,
+	.reset	= s3c6400_ac97_cold_reset,
+};
+
+static struct s3c2410_dma_client s3c6400_dma_client_out = {
+	.name = "AC97 PCM Stereo out"
+};
+
+static struct s3c24xx_pcm_dma_params s3c6400_ac97_pcm_stereo_out = {
+	.client		= &s3c6400_dma_client_out,
+	.channel	= DMACH_AC97_PCM_OUT,
+	.dma_addr	= S3C6400_PA_AC97 + S3C_AC97_PCM_DATA,
+	.dma_size	= 4,
+};
+
+#ifdef CONFIG_SOUND_WM9713_INPUT_STREAM_MIC
+static struct s3c2410_dma_client s3c6400_dma_client_micin = {
+	.name = "AC97 Mic Mono in"
+};
+
+static struct s3c24xx_pcm_dma_params s3c6400_ac97_mic_mono_in = {
+	.client		= &s3c6400_dma_client_micin,
+	.channel	= DMACH_AC97_MIC_IN,
+	.dma_addr	= S3C6400_PA_AC97 + S3C_AC97_MIC_DATA,
+	.dma_size	= 4,
+};
+#else /* Input Stream is LINE-IN */
+static struct s3c2410_dma_client s3c6400_dma_client_in = {
+	.name = "AC97 PCM Stereo Line in"
+};
+
+static struct s3c24xx_pcm_dma_params s3c6400_ac97_pcm_stereo_in = {
+	.client		= &s3c6400_dma_client_in,
+	.channel	= DMACH_AC97_PCM_IN,
+	.dma_addr	= S3C6400_PA_AC97 + S3C_AC97_PCM_DATA,
+	.dma_size	= 4,
+};
+#endif
+
+static int s3c6400_ac97_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	s3c24xx_ac97.regs = ioremap(S3C6400_PA_AC97, 0x100);
+	if (s3c24xx_ac97.regs == NULL)
+		return -ENXIO;
+
+	s3c24xx_ac97.ac97_clk = clk_get(&pdev->dev, "ac97");
+	if (s3c24xx_ac97.ac97_clk == NULL) {
+		printk(KERN_ERR "s3c6400-ac97 failed to get ac97_clock\n");
+		iounmap(s3c24xx_ac97.regs);
+		return -ENODEV;
+	}
+	clk_enable(s3c24xx_ac97.ac97_clk);
+	
+        s3c_gpio_cfgpin(S3C_GPD0,S3C_GPD0_AC97_BITCLK);
+        s3c_gpio_cfgpin(S3C_GPD1,S3C_GPD1_AC97_RESET);
+        s3c_gpio_cfgpin(S3C_GPD2,S3C_GPD2_AC97_SYNC);
+        s3c_gpio_cfgpin(S3C_GPD3,S3C_GPD3_AC97_SDI);
+        s3c_gpio_cfgpin(S3C_GPD4,S3C_GPD4_AC97_SDO);
+
+        s3c_gpio_pullup(S3C_GPD0,0);
+        s3c_gpio_pullup(S3C_GPD1,0);
+        s3c_gpio_pullup(S3C_GPD2,0);
+        s3c_gpio_pullup(S3C_GPD3,0);
+        s3c_gpio_pullup(S3C_GPD4,0);
+
+	ret = request_irq(IRQ_AC97, s3c6400_ac97_irq,
+		IRQF_DISABLED, "AC97", NULL);
+	if (ret < 0) {
+		printk(KERN_ERR "s3c24xx-ac97: interrupt request failed.\n");
+		clk_disable(s3c24xx_ac97.ac97_clk);
+		clk_put(s3c24xx_ac97.ac97_clk);
+		iounmap(s3c24xx_ac97.regs);
+	}
+
+	return ret;
+}
+
+static void s3c6400_ac97_remove(struct platform_device *pdev)
+{
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	free_irq(IRQ_AC97, NULL);
+	clk_disable(s3c24xx_ac97.ac97_clk);
+	clk_put(s3c24xx_ac97.ac97_clk);
+	iounmap(s3c24xx_ac97.regs);
+}
+
+static int s3c6400_ac97_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->dai->cpu_dai;
+	
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		cpu_dai->dma_data = &s3c6400_ac97_pcm_stereo_out;
+	else
+#ifdef CONFIG_SOUND_WM9713_INPUT_STREAM_MIC
+		cpu_dai->dma_data = &s3c6400_ac97_mic_mono_in;
+#else /* Input Stream is LINE-IN */
+		cpu_dai->dma_data = &s3c6400_ac97_pcm_stereo_in;
+#endif
+
+	
+	return 0;
+}
+
+static int s3c6400_ac97_hifi_prepare(struct snd_pcm_substream *substream)
+{
+	/*
+	 * To support full duplex  
+	 * Tested by cat /dev/dsp > /dev/dsp
+	 */
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	s3c6400_ac97_write(0,0x26,0x0);
+	s3c6400_ac97_write(0, 0x0c, 0x0808);
+	s3c6400_ac97_write(0,0x3c, 0xf803);
+	s3c6400_ac97_write(0,0x3e,0xb990);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		s3c6400_ac97_write(0,0x02, 0x8080);	
+		s3c6400_ac97_write(0, 0x04, 0x0606);	
+		s3c6400_ac97_write(0,0x1c, 0x00aa);
+	}
+	else
+	{
+		s3c6400_ac97_write(0, 0x12, 0x0f0f);
+#ifdef CONFIG_SOUND_WM9713_INPUT_STREAM_MIC
+		s3c6400_ac97_write(0,0x5c,0x2);
+		s3c6400_ac97_write(0,0x10,0x68);
+		s3c6400_ac97_write(0,0x14,0xfe00);
+#else /* Input Stream is LINE-IN */
+		s3c6400_ac97_write(0, 0x14, 0xd612);
+#endif
+	}
+
+	return 0;
+}
+
+
+static int s3c6400_ac97_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	u32 ac_glbctrl;
+
+	s3cdbg("Entered %s: cmd = %d\n", __FUNCTION__, cmd);
+
+	ac_glbctrl = readl(s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	switch(cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			ac_glbctrl |= S3C_AC97_GLBCTRL_PCMINTM_DMA;
+		else
+			ac_glbctrl |= S3C_AC97_GLBCTRL_PCMOUTTM_DMA;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			ac_glbctrl &= ~S3C_AC97_GLBCTRL_PCMINTM_MASK;
+		else
+			ac_glbctrl &= ~S3C_AC97_GLBCTRL_PCMOUTTM_MASK;
+		break;
+	}
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+
+	return 0;
+}
+
+#if 0
+static int s3c6400_ac97_hw_mic_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->dai->cpu_dai;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		return -ENODEV;
+	else
+		cpu_dai->dma_data = &s3c6400_ac97_mic_mono_in;
+
+	return 0;
+}
+
+static int s3c6400_ac97_mic_trigger(struct snd_pcm_substream *substream,
+	int cmd)
+{
+	u32 ac_glbctrl;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	ac_glbctrl = readl(s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+	switch(cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		ac_glbctrl |= S3C_AC97_GLBCTRL_PCMINTM_DMA;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		ac_glbctrl &= ~S3C_AC97_GLBCTRL_PCMINTM_MASK;
+	}
+	writel(ac_glbctrl, s3c24xx_ac97.regs + S3C_AC97_GLBCTRL);
+
+	return 0;
+}
+#endif
+
+#define s3c6400_AC97_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+		SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | \
+		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
+
+struct snd_soc_cpu_dai s3c6400_ac97_dai[] = {
+{
+	.name = "s3c64xx-ac97",
+	.id = 0,
+	.type = SND_SOC_DAI_AC97,
+	.probe = s3c6400_ac97_probe,
+	.remove = s3c6400_ac97_remove,
+	.playback = {
+		.stream_name = "AC97 Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = s3c6400_AC97_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.capture = {
+		.stream_name = "AC97 Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = s3c6400_AC97_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = {
+		.hw_params = s3c6400_ac97_hw_params,
+		.prepare = s3c6400_ac97_hifi_prepare,
+		.trigger = s3c6400_ac97_trigger},
+},
+#if 0
+{
+	.name = "s3c6400-ac97-mic",
+	.id = 1,
+	.type = SND_SOC_DAI_AC97,
+	.capture = {
+		.stream_name = "AC97 Mic Capture",
+		.channels_min = 1,
+		.channels_max = 1,
+		.rates = s3c6400_AC97_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = {
+		.hw_params = s3c6400_ac97_hw_mic_params,
+		.trigger = s3c6400_ac97_mic_trigger,},
+},
+#endif
+};
+
+EXPORT_SYMBOL_GPL(s3c6400_ac97_dai);
+EXPORT_SYMBOL_GPL(soc_ac97_ops);
+
+MODULE_AUTHOR("Ryu Euiyoul");
+MODULE_DESCRIPTION("AC97 driver for the Samsung s3c6400 chip");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/s3c64xx/s3c64xx-ac97.h linux-2.6.29-spica/sound/soc/s3c64xx/s3c64xx-ac97.h
--- linux-2.6.29/sound/soc/s3c64xx/s3c64xx-ac97.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/s3c64xx-ac97.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,25 @@
+/*
+ * s3c24xx-ac97.c  --  ALSA Soc Audio Layer
+ *
+ * (c) 2007 Wolfson Microelectronics PLC.
+ * Author: Graeme Gregory
+ *         graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    10th Nov 2006   Initial version.
+ */
+
+#ifndef S3C6400AC97_H_
+#define S3C6400AC97_H_
+
+#define AC_CMD_ADDR(x) (x << 16)
+#define AC_CMD_DATA(x) (x & 0xffff)
+
+extern struct snd_soc_cpu_dai s3c6400_ac97_dai[];
+
+#endif /*S3C6400AC97_H_*/
diff -Nur linux-2.6.29/sound/soc/s3c64xx/s3c-i2s.c linux-2.6.29-spica/sound/soc/s3c64xx/s3c-i2s.c
--- linux-2.6.29/sound/soc/s3c64xx/s3c-i2s.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/s3c-i2s.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,599 @@
+/*
+ * s3c-i2s.c  --  ALSA Soc Audio Layer
+ *
+ * (c) 2006 Wolfson Microelectronics PLC.
+ * Graeme Gregory graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ * (c) 2004-2005 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	Ryu Euiyoul <ryu.real@gmail.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *
+ *  Revision history
+ *    11th Dec 2006   Merged with Simtec driver
+ *    10th Nov 2006   Initial version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+
+#include <asm-arm/plat-s3c64xx/regs-iis.h>
+//#include <asm/arch/regs-iis.h>
+#include <asm/arch/regs-gpio.h>
+#include <asm/arch/audio.h>
+#include <asm/arch/dma.h>
+#include <asm/arch/regs-s3c-clock.h>
+
+#include "s3c-pcm.h"
+#include "s3c-i2s.h"
+
+#ifdef CONFIG_SND_DEBUG
+#define s3cdbg(x...) printk(x)
+#else
+#define s3cdbg(x...)
+#endif
+
+#define    CPU_MASTER_MODE 1
+
+/* used to disable sysclk if external crystal is used */
+static int extclk = 0;
+module_param(extclk, int, 0);
+MODULE_PARM_DESC(extclk, "set to 1 to disable s3c24XX i2s sysclk");
+
+static struct s3c2410_dma_client s3c24xx_dma_client_out = {
+	.name = "I2S PCM Stereo out"
+};
+
+static struct s3c2410_dma_client s3c24xx_dma_client_in = {
+	.name = "I2S PCM Stereo in"
+};
+
+static struct s3c24xx_pcm_dma_params s3c24xx_i2s_pcm_stereo_out = {
+	.client		= &s3c24xx_dma_client_out,
+	.channel	= DMACH_I2S_OUT,
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410)
+	.dma_addr	= S3C2410_PA_IIS + S3C2410_IISFIFO,
+	.dma_size	= 2,
+#else
+    .dma_addr   = S3C64XX_PA_IIS + S3C64XX_IISFIFO,
+	.dma_size	= 4,
+#endif
+};
+
+static struct s3c24xx_pcm_dma_params s3c24xx_i2s_pcm_stereo_in = {
+	.client		= &s3c24xx_dma_client_in,
+	.channel	= DMACH_I2S_IN,
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410)
+	.dma_addr	= S3C2410_PA_IIS + S3C2410_IISFIFORX,
+	.dma_size	= 2,
+#else
+    .dma_addr   = S3C64XX_PA_IIS + S3C64XX_IISFIFORX,
+	.dma_size	= 4,
+#endif
+};
+
+struct s3c24xx_i2s_info {
+	void __iomem	*regs;
+	struct clk	*iis_clk;
+	int master;
+};
+static struct s3c24xx_i2s_info s3c24xx_i2s;
+
+static void s3c24xx_snd_txctrl(int on)
+{
+	u32 iisfcon;
+	u32 iiscon;
+	u32 iismod;
+
+	s3cdbg("Entered %s : on = %d \n", __FUNCTION__, on);
+
+   	iiscon  = readl(s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+    iismod  = readl(s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+    iisfcon = readl(s3c24xx_i2s.regs + S3C64XX_IIS0FIC);
+
+	s3cdbg("r: IISCON: %x IISMOD: %x IISFCON: %x\n", iiscon, iismod, iisfcon);
+
+	if (on) {
+#if 0
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410)
+		iisfcon |= S3C2410_IISFCON_TXDMA | S3C2410_IISFCON_TXENABLE;
+		iiscon  |= S3C2410_IISCON_TXDMAEN | S3C2410_IISCON_IISEN;
+		iiscon  &= ~S3C2410_IISCON_TXIDLE;
+		iismod  |= S3C2410_IISMOD_TXMODE;
+#else
+		iiscon |= S3C_IIS0CON_I2SACTIVE;
+#endif
+		writel(iismod,  s3c24xx_i2s.regs + S3C2410_IISMOD);
+		writel(iisfcon, s3c24xx_i2s.regs + S3C2410_IISFCON);
+		writel(iiscon,  s3c24xx_i2s.regs + S3C2410_IISCON);
+#endif
+      	iiscon |= S3C64XX_IIS0CON_I2SACTIVE;
+
+      	writel(iismod,  s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+      	writel(iisfcon, s3c24xx_i2s.regs + S3C64XX_IIS0FIC);
+      	writel(iiscon,  s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+	} else {
+		/* note, we have to disable the FIFOs otherwise bad things
+		 * seem to happen when the DMA stops. According to the
+		 * Samsung supplied kernel, this should allow the DMA
+		 * engine and FIFOs to reset. If this isn't allowed, the
+		 * DMA engine will simply freeze randomly.
+		 */
+#if 0
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410)
+		iisfcon &= ~S3C2410_IISFCON_TXENABLE;
+		iisfcon &= ~S3C2410_IISFCON_TXDMA;
+		iiscon  |=  S3C2410_IISCON_TXIDLE;
+		iiscon  &= ~S3C2410_IISCON_TXDMAEN;
+		iismod  &= ~S3C2410_IISMOD_TXMODE;
+#else
+		iiscon &=~(S3C_IIS0CON_I2SACTIVE);
+		iismod &= ~S3C_IIS0MOD_TXMODE;
+#endif
+#endif
+        iiscon &=~(S3C64XX_IIS0CON_I2SACTIVE);
+       	iismod &= ~S3C64XX_IIS0MOD_TXMODE;
+
+#if 0
+		writel(iiscon,  s3c24xx_i2s.regs + S3C2410_IISCON);
+		writel(iisfcon, s3c24xx_i2s.regs + S3C2410_IISFCON);
+		writel(iismod,  s3c24xx_i2s.regs + S3C2410_IISMOD);
+#endif
+       	writel(iiscon,  s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+       	writel(iisfcon, s3c24xx_i2s.regs + S3C64XX_IIS0FIC);
+       	writel(iismod,  s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+	}
+
+	s3cdbg("w: IISCON: %x IISMOD: %x IISFCON: %x\n", iiscon, iismod, iisfcon);
+}
+
+static void s3c24xx_snd_rxctrl(int on)
+{
+	u32 iisfcon;
+	u32 iiscon;
+	u32 iismod;
+
+	s3cdbg("\n<s3c-i2s>Entered %s: on = %d\n", __FUNCTION__, on);
+
+   	iisfcon = readl(s3c24xx_i2s.regs + S3C64XX_IIS0FIC);
+   	iiscon  = readl(s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+   	iismod  = readl(s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+
+	s3cdbg("r: IISCON: %x IISMOD: %x IISFCON: %x\n", iiscon, iismod, iisfcon);
+
+	if (on) {
+#if 0
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410)
+		iisfcon |= S3C2410_IISFCON_RXDMA | S3C2410_IISFCON_RXENABLE;
+		iiscon  |= S3C2410_IISCON_RXDMAEN | S3C2410_IISCON_IISEN;
+		iiscon  &= ~S3C2410_IISCON_RXIDLE;
+		iismod  |= S3C2410_IISMOD_RXMODE;
+#else
+		iiscon |= S3C_IIS0CON_I2SACTIVE;
+#endif
+		writel(iismod,  s3c24xx_i2s.regs + S3C2410_IISMOD);
+		writel(iisfcon, s3c24xx_i2s.regs + S3C2410_IISFCON);
+		writel(iiscon,  s3c24xx_i2s.regs + S3C2410_IISCON);
+	} else {
+#endif
+       	/*  mic bias enable */
+       	VBIAS_EN_SET;
+
+       	/*select  key_mic */
+       	MIC_SEL_SET;
+
+       	iiscon |= S3C64XX_IIS0CON_I2SACTIVE;
+
+       	writel(iismod,  s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+       	writel(iisfcon, s3c24xx_i2s.regs + S3C64XX_IIS0FIC);
+       	writel(iiscon,  s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+   	}
+   	else
+   	{
+
+		/* note, we have to disable the FIFOs otherwise bad things
+		 * seem to happen when the DMA stops. According to the
+		 * Samsung supplied kernel, this should allow the DMA
+		 * engine and FIFOs to reset. If this isn't allowed, the
+		 * DMA engine will simply freeze randomly.
+		 */
+
+       	/* mic bias disable*/
+       	//VBIAS_EN_CLR;
+
+       	iiscon &=~ S3C64XX_IIS0CON_I2SACTIVE;
+       	iismod &= ~S3C64XX_IIS0MOD_RXMODE;
+
+       	writel(iisfcon, s3c24xx_i2s.regs + S3C64XX_IIS0FIC);
+       	writel(iiscon,  s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+       	writel(iismod,  s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+	}
+	s3cdbg("w: IISCON: %x IISMOD: %x IISFCON: %x\n", iiscon, iismod, iisfcon);
+}
+
+/*
+ * Wait for the LR signal to allow synchronisation to the L/R clock
+ * from the codec. May only be needed for slave mode.
+ */
+static int s3c24xx_snd_lrsync(void)
+{
+	u32 iiscon;
+	unsigned long timeout = jiffies + msecs_to_jiffies(5);
+
+    s3cdbg("<s3c-i2s> Entered %s, iiscon = 0x%x\n", __FUNCTION__, readl(s3c24xx_i2s.regs + S3C64XX_IIS0CON));
+
+	while (1) {
+       	iiscon = readl(s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+       	if (iiscon & S3C64XX_IISCON_LRINDEX)
+			break;
+
+		if (timeout < jiffies)
+			return -ETIMEDOUT;
+	}
+
+	s3cdbg("<s3c-i2s> returned %s with 0 \n",__FUNCTION__);
+	return 0;
+}
+
+/*
+ * Check whether CPU is the master or slave
+ * 0 : slave, 1 : master
+ */
+static inline int s3c24xx_snd_is_clkmaster(void)
+{
+   	int ret;
+   	unsigned long iismod;
+   	s3cdbg("<s3c-i2s> Entered %s\n", __FUNCTION__);
+
+   	iismod = readl(s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+   	ret =  (iismod & S3C64XX_IISMOD_SLAVE) ? 0:1;
+   	s3cdbg(" IISMOD = 0x%x, S3C2410_IISMOD_SLAVE = 0x%x,    ret = %d\n",iismod,S3C64XX_IISMOD_SLAVE,ret);
+   	return ret;
+
+   //return (readl(s3c24xx_i2s.regs + S3C2410_IISMOD) & S3C2410_IISMOD_SLAVE) ? 0:1;
+}
+
+/*
+ * Set S3C24xx I2S DAI format
+ */
+static int s3c_i2s_set_fmt(struct snd_soc_dai *cpu_dai,
+		unsigned int fmt)
+{
+#if 0
+	u32 iismod;
+
+	s3cdbg("Entered %s: fmt = %d\n", __FUNCTION__, fmt);
+
+	iismod = readl(s3c24xx_i2s.regs + S3C2410_IISMOD);
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410)
+		iismod |= S3C2410_IISMOD_SLAVE;
+#else
+		iismod |= S3C2410_IISMOD_MASTER;
+#endif
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_LEFT_J:
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410)
+		iismod |= S3C2410_IISMOD_MSB;
+#else
+		iismod |= S3C_IIS0MOD_MSB;
+#endif
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	writel(iismod, s3c24xx_i2s.regs + S3C2410_IISMOD);
+#endif
+	return 0;
+
+}
+
+static int s3c_i2s_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	unsigned long iiscon;
+	unsigned long iismod;
+	unsigned long iisfcon;
+   	unsigned long iispsr;
+   	unsigned long epll0, epll1,clk_src;
+
+#if CPU_MASTER_MODE	
+	s3c24xx_i2s.master = 1;
+	
+	/* Configure the I2S pins in correct mode */
+   	s3c_gpio_cfgpin(GPIO_I2S_LRCK, S3C_GPIO_SFN(GPIO_I2S_LRCK_AF));
+   	s3c_gpio_cfgpin(GPIO_I2S_SCLK, S3C_GPIO_SFN(GPIO_I2S_SCLK_AF));
+   	s3c_gpio_cfgpin(GPIO_I2S_SDI, S3C_GPIO_SFN(GPIO_I2S_SDI_AF));
+   	s3c_gpio_cfgpin(GPIO_I2S_SDO, S3C_GPIO_SFN(GPIO_I2S_SDO_AF));
+#else
+   	s3c24xx_i2s.master = 0;
+#endif
+
+	if (s3c24xx_i2s.master && !extclk){
+		s3cdbg("Setting Clock Output as we are Master\n");
+		s3c_gpio_cfgpin(GPIO_I2S_SCLK, S3C_GPIO_SFN(GPIO_I2S_SCLK_AF));	
+	}
+
+	/* pull-up-enable, pull-down-disable*/
+   	s3c_gpio_setpull(GPIO_I2S_SCLK, S3C_GPIO_PULL_UP);
+   	s3c_gpio_setpull(GPIO_I2S_LRCK, S3C_GPIO_PULL_UP);
+   	s3c_gpio_setpull(GPIO_I2S_SDI, S3C_GPIO_PULL_UP);
+   	s3c_gpio_setpull(GPIO_I2S_SDO, S3C_GPIO_PULL_UP);
+
+	s3cdbg("substream->stream : %d\n", substream->stream);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		rtd->dai->cpu_dai->dma_data = &s3c24xx_i2s_pcm_stereo_out;
+	} else {
+		rtd->dai->cpu_dai->dma_data = &s3c24xx_i2s_pcm_stereo_in;
+	}
+
+   	/* read epll setting */
+   	epll0 = readl(S3C_EPLL_CON0);
+   	epll1 = readl(S3C_EPLL_CON1);
+   	clk_src = readl(S3C_CLK_SRC);
+   	s3cdbg("r: EPLL_CON0 : 0x%lx, EPLL_CON1 : 0x%lx, CLK_SRC : 0x%lx \n",epll0,epll1,clk_src);
+
+	/* Working copies of registers */
+   	iiscon  = readl(s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+   	iismod  = readl(s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+   	iisfcon = readl(s3c24xx_i2s.regs + S3C64XX_IIS0FIC);
+   	iispsr = readl(s3c24xx_i2s.regs + S3C64XX_IIS0PSR);
+   	s3cdbg("r : IISCON: %lx IISMOD: %lx IISFCON: %lx, IISPSR : 0x%lx\n", iiscon, iismod, iisfcon,iispsr);
+
+	/* is port used by another stream */
+	if (!(iiscon & S3C64XX_IIS0CON_I2SACTIVE)) {
+		// Clear BFS field [2:1]
+		iismod &= ~(0x3<<1);
+		iismod |= S3C64XX_IIS0MOD_32FS | S3C64XX_IIS0MOD_INTERNAL_CLK;
+
+		if (!s3c24xx_i2s.master)
+			iismod |= 0x3<<10;//S3C_IIS0MOD_IMS_SLAVE;
+		else
+			iismod |= S3C64XX_IIS0MOD_IMS_EXTERNAL_MASTER;
+	}
+
+	/* enable TX & RX all to support Full-duplex */
+   	iismod |= S3C64XX_IIS0MOD_TXRXMODE;
+   	iiscon |= S3C64XX_IIS0CON_TXDMACTIVE;
+   	iisfcon |= S3C64XX_IIS_TX_FLUSH;
+   	iiscon |= S3C64XX_IIS0CON_RXDMACTIVE;
+   	iisfcon |= S3C64XX_IIS_RX_FLUSH;
+
+   	writel(iiscon, s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+   	writel(iismod, s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+   	writel(iisfcon, s3c24xx_i2s.regs + S3C64XX_IIS0FIC);
+	// Tx, Rx fifo flush bit clear
+   	iisfcon  &= ~(S3C64XX_IIS_TX_FLUSH | S3C64XX_IIS_RX_FLUSH);
+   	writel(iisfcon, s3c24xx_i2s.regs + S3C64XX_IIS0FIC);
+
+	s3cdbg("w : IISCON: %lx IISMOD: %lx IISFCON: %lx\n", iiscon, iismod, iisfcon);
+
+	return 0;
+
+}
+
+static int s3c_i2s_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	int ret = 0;
+
+	s3cdbg("Entered %s: cmd = %d\n", __FUNCTION__, cmd);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (!s3c24xx_snd_is_clkmaster()) {
+			ret = s3c24xx_snd_lrsync();
+			if (ret)
+				goto exit_err;
+		}
+
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			s3c24xx_snd_rxctrl(1);
+		else
+			s3c24xx_snd_txctrl(1);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			s3c24xx_snd_rxctrl(0);
+		else
+			s3c24xx_snd_txctrl(0);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+exit_err:
+	return ret;
+}
+
+static void s3c64xx_i2s_shutdown(struct snd_pcm_substream *substream)
+{
+	unsigned long iismod, iiscon;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	iismod=readl(s3c24xx_i2s.regs + S3C64XX_IIS0MOD);	
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		iismod &= ~S3C64XX_IIS0MOD_TXMODE;
+	} else {
+		iismod &= ~S3C64XX_IIS0MOD_RXMODE;
+	}
+
+   	writel(iismod,s3c24xx_i2s.regs + S3C64XX_IIS0MOD);
+
+   	iiscon=readl(s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+   	iiscon &= !S3C64XX_IIS0CON_I2SACTIVE;
+   	writel(iiscon,s3c24xx_i2s.regs + S3C64XX_IIS0CON);
+
+	/* Clock disable 
+	 * PCLK & SCLK gating disable 
+	 */
+	__raw_writel(__raw_readl(S3C_PCLK_GATE)&~(S3C_CLKCON_PCLK_IIS0), S3C_PCLK_GATE);
+	__raw_writel(__raw_readl(S3C_SCLK_GATE)&~(S3C_CLKCON_SCLK_AUDIO0), S3C_SCLK_GATE);
+
+	/* EPLL disable */
+	__raw_writel(__raw_readl(S3C_EPLL_CON0)&~(1<<31) ,S3C_EPLL_CON0);	
+	
+}
+
+
+/*
+ * Set S3C24xx Clock source
+ */
+static int s3c_i2s_set_sysclk(struct snd_soc_dai *cpu_dai,
+	int clk_id, unsigned int freq, int dir)
+{
+	s3cdbg("<s3c-i2s> Entered %s : clk_id = %d\n", __FUNCTION__, clk_id);
+
+	return 0;
+}
+
+/*
+ * Set S3C24xx Clock dividers
+ */
+static int s3c_i2s_set_clkdiv(struct snd_soc_dai *cpu_dai,
+	int div_id, int div)
+{
+	u32 iispsr = 0;
+
+	s3cdbg("<s3c-i2s> Entered %s : div_id = %d, div = %d\n", __FUNCTION__,div_id, div);
+   	//lm49350 code
+   	iispsr = (1<<15) | ((div-1) << 8); 
+	//s3cdbg("iispsr = 0x%lx\n",iispsr);
+   	writel(iispsr,s3c24xx_i2s.regs + S3C64XX_IIS0PSR);
+	
+	return 0;
+}
+
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410)
+/*
+ * To avoid duplicating clock code, allow machine driver to
+ * get the clockrate from here.
+ */
+u32 s3c24xx_i2s_get_clockrate(void)
+{
+	return clk_get_rate(s3c24xx_i2s.iis_clk);
+}
+EXPORT_SYMBOL_GPL(s3c24xx_i2s_get_clockrate);
+#endif
+
+static int s3c_i2s_probe(struct platform_device *pdev)
+{
+	s3cdbg("\n<s3c-i2s> Entered %s (S3C24XX_PA_IIS = 0x%x)\n", __FUNCTION__, S3C64XX_PA_IIS);
+
+	s3c24xx_i2s.regs = ioremap(S3C64XX_PA_IIS, 0x100);
+	if (s3c24xx_i2s.regs == NULL)
+		return -ENXIO;
+
+#if 1
+   	s3c_gpio_cfgpin(GPIO_I2S_LRCK, S3C_GPIO_SFN(GPIO_I2S_LRCK_AF));
+   	s3c_gpio_cfgpin(GPIO_I2S_SCLK, S3C_GPIO_SFN(GPIO_I2S_SCLK_AF));
+   	s3c_gpio_cfgpin(GPIO_I2S_SDI, S3C_GPIO_SFN(GPIO_I2S_SDI_AF));
+   	s3c_gpio_cfgpin(GPIO_I2S_SDO, S3C_GPIO_SFN(GPIO_I2S_SDO_AF));
+
+   	s3c_gpio_setpull(GPIO_I2S_SCLK, S3C_GPIO_PULL_UP);
+   	s3c_gpio_setpull(GPIO_I2S_LRCK, S3C_GPIO_PULL_UP);
+   	s3c_gpio_setpull(GPIO_I2S_SDI, S3C_GPIO_PULL_UP);
+   	s3c_gpio_setpull(GPIO_I2S_SDO, S3C_GPIO_PULL_UP);
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int s3c_i2s_suspend(struct platform_device *dev,
+	struct snd_soc_cpu_dai *dai)
+{
+	s3cdbg("<s3c-i2s> Entered %s\n", __FUNCTION__);
+	return 0;
+}
+
+static int s3c_i2s_resume(struct platform_device *pdev,
+	struct snd_soc_cpu_dai *dai)
+{
+	s3cdbg("<s3c-i2s> Entered %s\n", __FUNCTION__);
+	return 0;
+}
+
+#else
+#define s3c_i2s_suspend	NULL
+#define s3c_i2s_resume	NULL
+#endif
+
+
+#define S3C24XX_I2S_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+struct snd_soc_dai s3c_i2s_dai = {
+	.name = "s3c-i2s",
+	.id = 0,
+	.type = SND_SOC_DAI_I2S,
+	.probe = s3c_i2s_probe,
+	.suspend = s3c_i2s_suspend,
+	.resume = s3c_i2s_resume,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = S3C24XX_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE,},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = S3C24XX_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE,},
+	.ops = {
+		.shutdown = s3c64xx_i2s_shutdown,
+		.trigger = s3c_i2s_trigger,
+		.hw_params = s3c_i2s_hw_params,},
+	.dai_ops = {
+		.set_fmt = s3c_i2s_set_fmt,
+		.set_clkdiv = s3c_i2s_set_clkdiv,
+		.set_sysclk = s3c_i2s_set_sysclk,
+	},
+};
+EXPORT_SYMBOL_GPL(s3c_i2s_dai);
+
+/* Module information */
+MODULE_AUTHOR("Ben Dooks, <ben@simtec.co.uk>");
+MODULE_DESCRIPTION("s3c24xx I2S SoC Interface");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/s3c64xx/s3c-i2s.h linux-2.6.29-spica/sound/soc/s3c64xx/s3c-i2s.h
--- linux-2.6.29/sound/soc/s3c64xx/s3c-i2s.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/s3c-i2s.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,44 @@
+/*
+ * s3c24xx-i2s.c  --  ALSA Soc Audio Layer
+ *
+ * Copyright 2005 Wolfson Microelectronics PLC.
+ * Author: Graeme Gregory
+ *         graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    10th Nov 2006   Initial version.
+ */
+
+#ifndef S3C24XXI2S_H_
+#define S3C24XXI2S_H_
+
+/* clock sources */
+#define S3C24XX_CLKSRC_PCLK 0
+#define S3C24XX_CLKSRC_MPLL 1
+
+/* Clock dividers */
+#define S3C24XX_DIV_MCLK	0
+#define S3C24XX_DIV_BCLK	1
+#define S3C24XX_DIV_PRESCALER	2
+
+/* prescaler */
+#if !defined(CONFIG_CPU_S3C6400) && !defined(CONFIG_CPU_S3C6410)
+#define S3C24XX_PRESCALE(a,b) \
+	(((a - 1) << S3C2410_IISPSR_INTSHIFT) | ((b - 1) << S3C2410_IISPSR_EXTSHFIT))
+#else
+#define S3C24XX_PRESCALE(a,b) \
+	(((a - 1) << S3C_IISPSR_INTSHIFT) | ((b - 1) << S3C_IISPSR_INTSHIFT))
+#endif
+
+u32 s3c24xx_i2s_get_clockrate(void);
+
+extern struct snd_soc_dai s3c_i2s_dai;
+extern struct snd_soc_dai	s3c_i2s_v40_dai;
+extern struct snd_soc_dai	s5p_i2s_v40_dai;
+
+#endif /*S3C24XXI2S_H_*/
diff -Nur linux-2.6.29/sound/soc/s3c64xx/s3c-pcm.c linux-2.6.29-spica/sound/soc/s3c64xx/s3c-pcm.c
--- linux-2.6.29/sound/soc/s3c64xx/s3c-pcm.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/s3c-pcm.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,585 @@
+/*
+ * s3c-pcm.c  --  ALSA Soc Audio Layer
+ *
+ * (c) 2006 Wolfson Microelectronics PLC.
+ * Graeme Gregory graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ * (c) 2004-2005 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	Ryu Euiyoul <ryu.real@gmail.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    11th Dec 2006   Merged with Simtec driver
+ *    10th Nov 2006   Initial version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+//#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <plat/dma.h>
+#include <mach/audio.h>
+
+#include "s3c-pcm.h"
+
+#if defined CONFIG_SND_S3C6400_SOC_AC97
+#define MAIN_DMA_CH 1
+#else /*S3C6400 I2S */ 
+#define MAIN_DMA_CH 0
+#endif
+
+#define ANDROID_BUF_SIZE	4096
+
+//#define CONFIG_SND_DEBUG
+#ifdef CONFIG_SND_DEBUG
+#define s3cdbg(x...) printk(x)
+#else
+#define s3cdbg(x...)
+#endif
+
+static const struct snd_pcm_hardware s3c24xx_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED |
+				    SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				    SNDRV_PCM_INFO_MMAP |
+				    SNDRV_PCM_INFO_MMAP_VALID,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_U16_LE |
+				    SNDRV_PCM_FMTBIT_U8 |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S8,
+	.channels_min		= 2,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 128*1024,
+	.period_bytes_min	= 128,
+	.period_bytes_max	= 16*1024,
+	.periods_min		= 2,
+	.periods_max		= 128,
+	.fifo_size		= 32,
+};
+
+struct s3c24xx_runtime_data {
+	spinlock_t lock;
+	int state;
+	unsigned int dma_loaded;
+	unsigned int dma_limit;
+	unsigned int dma_period;
+	dma_addr_t dma_start;
+	dma_addr_t dma_pos;
+	dma_addr_t dma_end;
+	struct s3c24xx_pcm_dma_params *params;
+};
+
+extern unsigned int ring_buf_index;
+extern unsigned int period_index;
+
+/* s3c24xx_pcm_enqueue
+ *
+ * place a dma buffer onto the queue for the dma system
+ * to handle.
+*/
+static void s3c24xx_pcm_enqueue(struct snd_pcm_substream *substream)
+{
+	struct s3c24xx_runtime_data *prtd = substream->runtime->private_data;
+	unsigned long len = prtd->dma_period;
+	dma_addr_t    pos = prtd->dma_pos;
+	int ret;
+	unsigned long next_len = 0;
+#if defined (CONFIG_CPU_S3C6400) || defined (CONFIG_CPU_S3C6410)
+	/* Next length prediction */
+	dma_addr_t pred_pos;
+#endif
+	
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	if ((pos + len) > prtd->dma_end) {
+		len  = prtd->dma_end - pos;
+		s3cdbg(KERN_DEBUG "%s: corrected dma len %ld\n", __FUNCTION__, len);
+	}
+#if defined (CONFIG_CPU_S3C6400) || defined (CONFIG_CPU_S3C6410)
+    /* DMA with I2S might be unstable when length is too short. */
+    pred_pos = pos + prtd->dma_period;
+
+    next_len = prtd->dma_period;
+
+    if ((pred_pos + next_len) > prtd->dma_end) {
+        next_len  = prtd->dma_end - pred_pos;
+    }
+
+    if (next_len <= 32) { /* next transfer is too short */
+        len += next_len; /* transfer with next small period */
+        ret = s3c2410_dma_enqueue(prtd->params->channel, 
+                           substream, pos, len);
+        pos += next_len;
+    }
+    else
+        ret = s3c2410_dma_enqueue(prtd->params->channel, 
+			        substream, pos, len);
+#else
+		ret = s3c2410_dma_enqueue(prtd->params->channel, 
+			substream, pos, len);
+#endif
+
+	prtd->dma_pos = pos;
+}
+
+static void s3c24xx_audio_buffdone(struct s3c2410_dma_chan *channel,
+				void *dev_id, int size,
+				enum s3c2410_dma_buffresult result)
+{
+	struct snd_pcm_substream *substream = dev_id;
+	struct s3c24xx_runtime_data *prtd;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	if (result == S3C2410_RES_ABORT || result == S3C2410_RES_ERR){
+		return;
+	}
+	else {
+		
+		if (!substream)
+			return;
+
+		prtd = substream->runtime->private_data;
+		
+		prtd->dma_pos += prtd->dma_period;
+		if (prtd->dma_pos >= prtd->dma_end)
+			prtd->dma_pos = prtd->dma_start;
+
+		snd_pcm_period_elapsed(substream);
+
+		spin_lock(&prtd->lock);
+
+		if (prtd->state & ST_RUNNING) 
+			s3c24xx_pcm_enqueue(substream);
+
+		spin_unlock(&prtd->lock);
+	}
+}
+
+static int s3c24xx_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct s3c24xx_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct s3c24xx_pcm_dma_params *dma = rtd->dai->cpu_dai->dma_data;
+	unsigned long totbytes;
+	int ret=0;
+	
+	s3cdbg("Entered %s, params = %p \n", __FUNCTION__, prtd->params);
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		totbytes = params_buffer_bytes(params) * ANDROID_BUF_NUM;
+	
+	else 
+		totbytes = params_buffer_bytes(params);
+
+//	printk("[%d]:ring_buf_num %d\n", substream->stream, ring_buf_num);
+
+	/* return if this is a bufferless transfer e.g.
+	 * codec <--> BT codec or GSM modem -- lg FIXME */
+	if (!dma)
+		return 0;
+
+	/* this may get called several times by oss emulation
+	 * with different params */
+	if (prtd->params == NULL) {
+		prtd->params = dma;
+		s3cdbg("params %p, client %p, channel %d\n", prtd->params,
+			prtd->params->client, prtd->params->channel);
+
+
+		/* prepare DMA */
+		ret = s3c2410_dma_request(prtd->params->channel,
+					  prtd->params->client, NULL);
+
+		if (ret) {
+			printk(KERN_ERR "failed to get dma channel\n");
+			return ret;
+		}
+	} else if (prtd->params != dma) {
+		s3c2410_dma_free(prtd->params->channel, prtd->params->client);
+		prtd->params = dma;
+		s3cdbg("params %p, client %p, channel %d\n", prtd->params,
+			prtd->params->client, prtd->params->channel);
+
+
+		/* prepare DMA */
+		ret = s3c2410_dma_request(prtd->params->channel,
+					  prtd->params->client, NULL);
+
+		if (ret) {
+			printk(KERN_ERR "failed to get dma channel\n");
+			return ret;
+		}
+	}
+
+	/* channel needs configuring for mem=>device, increment memory addr,
+	 * sync to pclk, half-word transfers to the IIS-FIFO. */
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410)  && !defined(CONFIG_CPU_S5PC100) && !defined (CONFIG_CPU_S5P6440)
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		s3c2410_dma_devconfig(prtd->params->channel,
+				S3C2410_DMASRC_MEM, S3C2410_DISRCC_INC |
+				S3C2410_DISRCC_APB, prtd->params->dma_addr);
+
+		s3c2410_dma_config(prtd->params->channel,
+				prtd->params->dma_size,
+				S3C2410_DCON_SYNC_PCLK | 
+				S3C2410_DCON_HANDSHAKE);
+	} else {
+		s3c2410_dma_config(prtd->params->channel,
+				prtd->params->dma_size,
+				S3C2410_DCON_HANDSHAKE | 
+				S3C2410_DCON_SYNC_PCLK);
+
+		s3c2410_dma_devconfig(prtd->params->channel,
+					S3C2410_DMASRC_HW, 0x3,
+					prtd->params->dma_addr);
+	}
+
+#else
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		s3c2410_dma_devconfig(prtd->params->channel,
+				S3C2410_DMASRC_MEM, 0,
+				prtd->params->dma_addr);
+
+		s3c2410_dma_config(prtd->params->channel,
+				prtd->params->dma_size, 0);
+	} else {
+		s3c2410_dma_devconfig(prtd->params->channel,
+				S3C2410_DMASRC_HW, 0,
+				prtd->params->dma_addr);		
+
+		s3c2410_dma_config(prtd->params->channel,
+				prtd->params->dma_size, 0);
+	}
+#endif
+
+	s3c2410_dma_set_buffdone_fn(prtd->params->channel,
+				    s3c24xx_audio_buffdone);
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	runtime->dma_bytes = totbytes;
+
+	spin_lock_irq(&prtd->lock);
+	prtd->dma_limit = runtime->hw.periods_min;
+	prtd->dma_period = params_period_bytes(params);
+	prtd->dma_start = runtime->dma_addr;
+	prtd->dma_pos = prtd->dma_start;
+	prtd->dma_end = prtd->dma_start + totbytes;
+	spin_unlock_irq(&prtd->lock);
+
+	s3cdbg("Entered %s, line %d \n", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static int s3c24xx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct s3c24xx_runtime_data *prtd = substream->runtime->private_data;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	/* TODO - do we need to ensure DMA flushed */
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	if (prtd->params) {
+		s3c2410_dma_free(prtd->params->channel, prtd->params->client);
+		prtd->params = NULL;
+	}
+
+	return 0;
+}
+
+static int s3c24xx_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct s3c24xx_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410) 
+	/* return if this is a bufferless transfer e.g.
+	 * codec <--> BT codec or GSM modem -- lg FIXME */
+	if (!prtd->params)
+	 	return 0;
+#endif
+
+	/* flush the DMA channel */
+	s3c2410_dma_ctrl(prtd->params->channel, S3C2410_DMAOP_FLUSH);
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		ring_buf_index 	 = 0;
+		period_index	 = 0;
+	}
+
+	prtd->dma_pos = prtd->dma_start;
+
+	/* enqueue dma buffers */
+	s3c24xx_pcm_enqueue(substream);
+
+	return ret;
+}
+
+static int s3c24xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct s3c24xx_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	spin_lock(&prtd->lock);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		prtd->state |= ST_RUNNING;
+		
+		s3c2410_dma_ctrl(prtd->params->channel, S3C2410_DMAOP_START);
+#if !defined (CONFIG_CPU_S3C6400) && !defined (CONFIG_CPU_S3C6410) && !defined (CONFIG_CPU_S5P6440)
+		s3c2410_dma_ctrl(prtd->params->channel, S3C2410_DMAOP_STARTED);
+#endif		
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		prtd->state &= ~ST_RUNNING;
+		s3c2410_dma_ctrl(prtd->params->channel, S3C2410_DMAOP_STOP);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&prtd->lock);
+
+	return ret;
+}
+
+static snd_pcm_uframes_t 
+	s3c24xx_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct s3c24xx_runtime_data *prtd = runtime->private_data;
+	unsigned long res;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	spin_lock(&prtd->lock);
+
+#if defined (CONFIG_CPU_S3C6400) || defined (CONFIG_CPU_S3C6410)
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)  
+		res = prtd->dma_pos - prtd->dma_start;
+	else 
+		res = prtd->dma_pos - prtd->dma_start;	
+#else
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		res = dst - prtd->dma_start;
+	else
+		res = src - prtd->dma_start;
+#endif
+
+	spin_unlock(&prtd->lock);
+
+	/* we seem to be getting the odd error from the pcm library due
+	 * to out-of-bounds pointers. this is maybe due to the dma engine
+	 * not having loaded the new values for the channel before being
+	 * callled... (todo - fix )
+	 */
+	
+	/* Playback mode */	
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {	
+		if (res >= (snd_pcm_lib_buffer_bytes(substream) * ANDROID_BUF_NUM)) {
+			if (res == (snd_pcm_lib_buffer_bytes(substream) * ANDROID_BUF_NUM))
+				res = 0;
+		}
+	}
+
+	/* Capture mode */	
+	else {	
+		if (res >= (snd_pcm_lib_buffer_bytes(substream))) {
+			if (res == (snd_pcm_lib_buffer_bytes(substream)))
+				res = 0;
+		}
+	}
+
+	return bytes_to_frames(substream->runtime, res);
+}
+
+static int s3c24xx_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct s3c24xx_runtime_data *prtd;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	snd_soc_set_runtime_hwparams(substream, &s3c24xx_pcm_hardware);
+
+	prtd = kzalloc(sizeof(struct s3c24xx_runtime_data), GFP_KERNEL);
+//	printk("[%d]: prtd addr 0x%x\n", substream->stream, prtd);
+	if (prtd == NULL)
+		return -ENOMEM;
+
+	spin_lock_init(&prtd->lock);
+
+	runtime->private_data = prtd;
+	return 0;
+}
+
+static int s3c24xx_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct s3c24xx_runtime_data *prtd = runtime->private_data;
+
+	s3cdbg("Entered %s, prtd = %p\n", __FUNCTION__, prtd);
+
+	if (prtd)
+		kfree(prtd);
+	else
+		printk("s3c24xx_pcm_close called with prtd == NULL\n");
+
+	return 0;
+}
+
+static int s3c24xx_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+                                     runtime->dma_area,
+                                     runtime->dma_addr,
+                                     runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops s3c24xx_pcm_ops = {
+	.open		= s3c24xx_pcm_open,
+	.close		= s3c24xx_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= s3c24xx_pcm_hw_params,
+	.hw_free	= s3c24xx_pcm_hw_free,
+	.prepare	= s3c24xx_pcm_prepare,
+	.trigger	= s3c24xx_pcm_trigger,
+	.pointer	= s3c24xx_pcm_pointer,
+	.mmap		= s3c24xx_pcm_mmap,
+};
+
+static int s3c24xx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = s3c24xx_pcm_hardware.buffer_bytes_max;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	return 0;
+}
+
+static void s3c24xx_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+static u64 s3c24xx_pcm_dmamask = DMA_32BIT_MASK;
+
+static int s3c24xx_pcm_new(struct snd_card *card, 
+	struct snd_soc_dai *dai, struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &s3c24xx_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->playback.channels_min) {
+		ret = s3c24xx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->capture.channels_min) {
+		ret = s3c24xx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+ out:
+	return ret;
+}
+
+struct snd_soc_platform s3c24xx_soc_platform = {
+	.name		= "s3c24xx-audio",
+	.pcm_ops 	= &s3c24xx_pcm_ops,
+	.pcm_new	= s3c24xx_pcm_new,
+	.pcm_free	= s3c24xx_pcm_free_dma_buffers,
+};
+
+EXPORT_SYMBOL_GPL(s3c24xx_soc_platform);
+
+static int __init s3c_soc_platform_init(void)
+{
+	return snd_soc_register_platform(&s3c24xx_soc_platform);
+}	
+
+module_init(s3c_soc_platform_init);
+
+static void __exit s3c_soc_platform_exit(void)
+{
+	snd_soc_unregister_platform(&s3c24xx_soc_platform);
+}
+module_exit(s3c_soc_platform_exit);
+
+MODULE_AUTHOR("Ben Dooks, <ben@simtec.co.uk>");
+MODULE_DESCRIPTION("Samsung S3C24XX PCM DMA module");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/s3c64xx/s3c-pcm.h linux-2.6.29-spica/sound/soc/s3c64xx/s3c-pcm.h
--- linux-2.6.29/sound/soc/s3c64xx/s3c-pcm.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/s3c-pcm.h	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,46 @@
+/*
+ *  s3c24xx-pcm.h --
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  ALSA PCM interface for the Samsung S3C24xx CPU
+ */
+
+#ifndef _S3C24XX_PCM_H
+#define _S3C24XX_PCM_H
+
+#define ST_RUNNING		(1<<0)
+#define ST_OPENED		(1<<1)
+
+struct s3c24xx_pcm_dma_params {
+	struct s3c2410_dma_client *client;	/* stream identifier */
+	int channel;				/* Channel ID */
+	dma_addr_t dma_addr;
+	int dma_size;			/* Size of the DMA transfer */
+};
+
+#define S3C24XX_DAI_I2S			0
+
+#if defined (CONFIG_CPU_S3C6400) || defined (CONFIG_CPU_S3C6410) 
+#define S3CPCM_DCON 	0
+#define S3CPCM_HWCFG	0
+#else
+//#include <asm/arch/dma.h>
+#define S3CPCM_DCON 	S3C2410_DCON_SYNC_PCLK|S3C2410_DCON_HANDSHAKE
+#define S3CPCM_HWCFG 	S3C2410_DISRCC_INC|S3C2410_DISRCC_APB	
+#endif
+
+#if defined (CONFIG_CPU_S5P6440) | defined (CONFIG_CPU_S5PC100)
+#define FLASH_PROBLEM_PATCH	0
+#else
+#define FLASH_PROBLEM_PATCH	1
+#endif
+
+/* platform data */
+extern struct snd_soc_platform s3c24xx_soc_platform;
+extern struct snd_ac97_bus_ops s3c24xx_ac97_ops;
+
+#endif
diff -Nur linux-2.6.29/sound/soc/s3c64xx/s3c-pcm-sol.c linux-2.6.29-spica/sound/soc/s3c64xx/s3c-pcm-sol.c
--- linux-2.6.29/sound/soc/s3c64xx/s3c-pcm-sol.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/s3c-pcm-sol.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,631 @@
+/*
+ * s3c-pcm.c  --  ALSA Soc Audio Layer
+ *
+ * (c) 2006 Wolfson Microelectronics PLC.
+ * Graeme Gregory graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ * (c) 2004-2005 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	Ryu Euiyoul <ryu.real@gmail.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    11th Dec 2006   Merged with Simtec driver
+ *    10th Nov 2006   Initial version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+//#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <plat/s3c6410-dma.h>
+#include <mach/audio.h>
+
+#include "s3c-pcm.h"
+
+#if defined CONFIG_SND_S3C6400_SOC_AC97
+#define MAIN_DMA_CH 1
+#else /*S3C6400 I2S */ 
+#define MAIN_DMA_CH 0
+#endif
+
+#define PLAYBACK			0
+#define CAPTURE				1
+#define ANDROID_BUF_SIZE	4096
+
+#define USE_LLI_INTERFACE	
+#undef USE_LLI_INTERFACE	
+
+//#define CONFIG_SND_DEBUG
+#ifdef CONFIG_SND_DEBUG
+#define s3cdbg(x...) printk(x)
+#else
+#define s3cdbg(x...)
+#endif
+
+static const struct snd_pcm_hardware s3c24xx_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED |
+				    SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				    SNDRV_PCM_INFO_MMAP |
+				    SNDRV_PCM_INFO_MMAP_VALID,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_U16_LE |
+				    SNDRV_PCM_FMTBIT_U8 |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S8,
+	.channels_min		= 2,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 128*1024,
+	.period_bytes_min	= 128,
+	.period_bytes_max	= 16*1024,
+	.periods_min		= 2,
+	.periods_max		= 128,
+	.fifo_size		= 32,
+};
+
+struct s3c24xx_runtime_data {
+	spinlock_t lock;
+	int state;
+	unsigned int dma_loaded;
+	unsigned int dma_limit;
+	unsigned int dma_period;
+	unsigned long dma_totsize;
+	dma_addr_t dma_start;
+	dma_addr_t dma_pos;
+	dma_addr_t dma_end;
+	struct dma_data			*dma_param;
+	struct dmac_conn_info	*dinfo;
+
+#ifdef USE_LLI_INTERFACE
+	struct dmac_lli				*lli_data;
+	unsigned int 				num_lli;
+#endif
+};
+
+extern unsigned int ring_buf_index;
+extern unsigned int period_index;
+
+/* s3c6410_pcm_dma_param_init
+ *
+ * Initiaize parameters for using dma controller.
+*/
+static void s3c6410_pcm_dma_param_init(struct s3c24xx_runtime_data *prtd)
+{
+	/* Initialize DMA Param */
+    prtd->dma_param->dma_lli_v  = NULL;
+    prtd->dma_param->src_addr   = 0;
+    prtd->dma_param->dst_addr   = 0;
+    prtd->dma_param->lli_addr   = 0;
+    prtd->dma_param->dmac_cfg   = 0;
+    prtd->dma_param->dmac_ctrl0 = 0;
+    prtd->dma_param->dmac_ctrl1 = 0;
+    prtd->dma_param->dmac_bytes = 0;
+    prtd->dma_param->active     = DMA_DEFAULT;
+    prtd->dma_param->chan_num   = MAX_DMA_CHANNELS;
+}
+
+
+/* s3c24xx_pcm_enqueue
+ *
+ * place a dma buffer onto the queue for the dma system
+ * to handle.
+*/
+static void s3c24xx_pcm_enqueue(struct snd_pcm_substream *substream)
+{
+	struct s3c24xx_runtime_data *prtd = substream->runtime->private_data;
+	unsigned long len = prtd->dma_period;
+	dma_addr_t    pos = prtd->dma_pos;
+	unsigned long next_len = 0;
+#if defined (CONFIG_CPU_S3C6400) || defined (CONFIG_CPU_S3C6410)
+	/* Next length prediction */
+	dma_addr_t pred_pos;
+#endif
+	
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	if ((pos + len) > prtd->dma_end) {
+		len  = prtd->dma_end - pos;
+		s3cdbg(KERN_DEBUG "%s: corrected dma len %ld\n", __FUNCTION__, len);
+	}
+ 
+	/* DMA with I2S might be unstable when length is too short. */
+    pred_pos = pos + prtd->dma_period;
+
+    next_len = prtd->dma_period;
+
+    if ((pred_pos + next_len) > prtd->dma_end) {
+        next_len  = prtd->dma_end - pred_pos;
+    }
+
+    if (next_len <= 32) { 			/* next transfer is too short */
+        len += next_len; 			/* transfer with next small period */
+		if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			prtd->dma_param->dmac_ctrl1 = TSFR_SIZE4(len);
+			prtd->dma_param->src_addr	= pos;
+		}
+		else {
+			prtd->dma_param->dmac_ctrl1 = TSFR_SIZE2(len);
+			prtd->dma_param->dst_addr	= pos;
+		}
+		s3c6410_dmac_enable(prtd->dma_param);
+		pos += next_len;
+    }
+
+    else {
+		if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			prtd->dma_param->dmac_ctrl1 = TSFR_SIZE4(len);
+			prtd->dma_param->src_addr	= pos;
+		}
+		else {
+			prtd->dma_param->dmac_ctrl1 = TSFR_SIZE2(len);
+			prtd->dma_param->dst_addr	= pos;
+		}
+		s3c6410_dmac_enable(prtd->dma_param);
+	}
+
+	prtd->dma_pos = pos;
+}
+
+static void s3c6410_audio_buffdone(void *id)
+{
+	struct snd_pcm_substream *substream = id;
+	struct s3c24xx_runtime_data *prtd;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+		
+	if (!substream)
+		return;
+
+	prtd = substream->runtime->private_data;
+		
+	prtd->dma_pos += prtd->dma_period;
+	if (prtd->dma_pos >= prtd->dma_end)
+		prtd->dma_pos = prtd->dma_start;
+
+	snd_pcm_period_elapsed(substream);
+
+	spin_lock(&prtd->lock);
+
+#ifdef USE_LLI_INTERFACE
+	/* We don't have something to do */
+
+#else
+	if (prtd->state & ST_RUNNING) 
+		s3c24xx_pcm_enqueue(substream);
+#endif
+
+	spin_unlock(&prtd->lock);
+}
+
+#ifdef USE_LLI_INTERFACE
+static struct dmac_lli *s3c6410_audio_make_dmalli(struct snd_pcm_substream *substream, struct dma_data *dmadata, 
+												  unsigned int num_lli)
+{
+	struct snd_pcm_runtime		*runtime = substream->runtime;
+	struct s3c24xx_runtime_data *prtd 	 = runtime->private_data;
+	struct dmac_lli		*dma_lli = dmadata->dma_lli_v;
+	int i;
+
+	for(i = 0 ; i < num_lli - 1 ; i++){
+		if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			dma_lli[i].src_lli    = dmadata->src_addr + (i * prtd->dma_period);
+			dma_lli[i].dst_lli    = dmadata->dst_addr;
+		}else {
+			dma_lli[i].dst_lli    = dmadata->dst_addr + (i * prtd->dma_period);
+			dma_lli[i].src_lli    = dmadata->src_addr;
+		}	
+
+		dma_lli[i].chan_ctrl0 = dmadata->dmac_ctrl0 | TC_INT_ENABLE;
+		dma_lli[i].chan_ctrl1 = dmadata->dmac_ctrl1;
+		dma_lli[i].next_lli   = dmadata->lli_addr + ((i * 20) + 0x14);
+	}
+	
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dma_lli[i].src_lli    = dmadata->src_addr + (i * prtd->dma_period); 
+		dma_lli[i].dst_lli    = dmadata->dst_addr;
+	} else {
+		dma_lli[i].dst_lli    = dmadata->dst_addr + (i * prtd->dma_period);
+		dma_lli[i].src_lli    = dmadata->src_addr;
+	}
+
+	dma_lli[i].chan_ctrl0 = dmadata->dmac_ctrl0 | TC_INT_ENABLE;
+	dma_lli[i].chan_ctrl1 = dmadata->dmac_ctrl1;
+	dma_lli[i].next_lli   = dmadata->lli_addr;
+
+	return dma_lli;
+}
+#endif
+
+static int s3c24xx_pcm_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime 		*runtime  = substream->runtime;
+	struct s3c24xx_runtime_data *prtd 	  = runtime->private_data;
+	struct snd_soc_pcm_runtime 	*rtd 	  = substream->private_data;
+	struct dma_data		   		*dma_data = prtd->dma_param;
+	struct dmac_conn_info 		*dinfo	  = rtd->dai->cpu_dai->dma_data;
+
+	s3cdbg("Entered %s, params = %p \n", __FUNCTION__, prtd->params);
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		prtd->dma_totsize = params_buffer_bytes(params) * ANDROID_BUF_NUM;
+	
+	else 
+		prtd->dma_totsize = params_buffer_bytes(params);
+
+	prtd->dinfo = dinfo;
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dma_data->dma_port = prtd->dinfo->connection_num[PLAYBACK].dma_port;
+		dma_data->conn_num = prtd->dinfo->connection_num[PLAYBACK].conn_num;
+	}else {
+		dma_data->dma_port = prtd->dinfo->connection_num[CAPTURE].dma_port;
+		dma_data->conn_num = prtd->dinfo->connection_num[CAPTURE].conn_num;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	runtime->dma_bytes = prtd->dma_totsize;
+
+	spin_lock_irq(&prtd->lock);
+	prtd->dma_limit = runtime->hw.periods_min;
+	prtd->dma_period = params_period_bytes(params);
+	prtd->dma_start = runtime->dma_addr;
+	prtd->dma_pos = prtd->dma_start;
+	prtd->dma_end = prtd->dma_start + prtd->dma_totsize;
+	spin_unlock_irq(&prtd->lock);
+
+	dma_data->dma_dev_handler = (void *)s3c6410_audio_buffdone;
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dma_data->src_addr      = prtd->dma_start;
+		dma_data->dst_addr      = dinfo->connection_num[PLAYBACK].hw_fifo;
+		dma_data->dmac_cfg      = FCTL_DMA_M2P | DST_CONN(dma_data->conn_num) | INT_TC_MASK;
+		dma_data->dmac_ctrl0    = SRC_BSIZE_1 | DST_BSIZE_1 | SRC_TWIDTH_32 | DST_TWIDTH_32 | SRC_INC | 
+								  DST_AHB_PERI | SRC_AHB_SYSTEM;
+		dma_data->dmac_ctrl1	= TSFR_SIZE4(prtd->dma_period);
+	}
+	
+	else {
+		dma_data->src_addr      = dinfo->connection_num[CAPTURE].hw_fifo;
+	    dma_data->dst_addr      = prtd->dma_start;
+	    dma_data->dmac_cfg      = FCTL_DMA_P2M | SRC_CONN(dma_data->conn_num) | INT_TC_MASK;
+	    dma_data->dmac_ctrl0    = SRC_BSIZE_1 | DST_BSIZE_1 | SRC_TWIDTH_16 | DST_TWIDTH_16 | DST_INC |
+								  SRC_AHB_PERI | DST_AHB_SYSTEM;
+		dma_data->dmac_ctrl1	= TSFR_SIZE2(prtd->dma_period);
+	}
+
+#ifdef USE_LLI_INTERFACE
+	prtd->num_lli = runtime->dma_bytes / prtd->dma_period;
+
+	prtd->lli_data = dma_alloc_coherent(substream->pcm->card->dev, sizeof(struct dmac_lli) * prtd->num_lli, 
+									 	&dma_data->lli_addr, GFP_KERNEL | GFP_DMA);
+	if(!prtd->lli_data)
+		printk("Failed to allocate memory for using dmac lli interface\n");
+
+	dma_data->dma_lli_v = (void *)prtd->lli_data;
+	prtd->lli_data = s3c6410_audio_make_dmalli(substream, dma_data, prtd->num_lli);
+
+#else
+	dma_data->dmac_ctrl0 |= TC_INT_ENABLE;
+
+#endif
+
+	s3c6410_dmac_request(dma_data, substream);
+
+	s3cdbg("Entered %s, line %d \n", __FUNCTION__, __LINE__);
+
+	return 0;
+}
+
+static int s3c24xx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	/* TODO - do we need to ensure DMA flushed */
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	return 0;
+}
+
+static int s3c24xx_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct s3c24xx_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	if(!prtd->dinfo)
+		return 0;
+	
+	/* Flush dma area */
+	memset(substream->runtime->dma_area, 0, prtd->dma_totsize);
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		ring_buf_index 	 = 0;
+		period_index	 = 0;
+	}
+
+	prtd->dma_pos = prtd->dma_start;
+		
+	s3c24xx_pcm_enqueue(substream);
+
+	return ret;
+}
+
+static int s3c24xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct s3c24xx_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	spin_lock(&prtd->lock);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		prtd->state |= ST_RUNNING;
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		prtd->state &= ~ST_RUNNING;
+		s3c6410_dmac_disable(prtd->dma_param);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&prtd->lock);
+
+	return ret;
+}
+
+static snd_pcm_uframes_t 
+	s3c24xx_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct s3c24xx_runtime_data *prtd = runtime->private_data;
+	unsigned long res;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	spin_lock(&prtd->lock);
+
+#if defined (CONFIG_CPU_S3C6400) || defined (CONFIG_CPU_S3C6410)
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)  
+		res = prtd->dma_pos - prtd->dma_start;
+	else 
+		res = prtd->dma_pos - prtd->dma_start;	
+#else
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		res = dst - prtd->dma_start;
+	else
+		res = src - prtd->dma_start;
+#endif
+
+	spin_unlock(&prtd->lock);
+
+	/* we seem to be getting the odd error from the pcm library due
+	 * to out-of-bounds pointers. this is maybe due to the dma engine
+	 * not having loaded the new values for the channel before being
+	 * callled... (todo - fix )
+	 */
+	
+	/* Playback mode */	
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {	
+		if (res >= (snd_pcm_lib_buffer_bytes(substream) * ANDROID_BUF_NUM)) {
+			if (res == (snd_pcm_lib_buffer_bytes(substream) * ANDROID_BUF_NUM))
+				res = 0;
+		}
+	}
+
+	/* Capture mode */	
+	else {	
+		if (res >= (snd_pcm_lib_buffer_bytes(substream))) {
+			if (res == (snd_pcm_lib_buffer_bytes(substream)))
+				res = 0;
+		}
+	}
+
+	return bytes_to_frames(substream->runtime, res);
+}
+
+static int s3c24xx_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct s3c24xx_runtime_data *prtd;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	snd_soc_set_runtime_hwparams(substream, &s3c24xx_pcm_hardware);
+
+	prtd = kmalloc(sizeof(struct s3c24xx_runtime_data), GFP_KERNEL);
+	if (prtd == NULL)
+		return -ENOMEM;
+
+	prtd->dma_param = (struct dma_data *)kzalloc(sizeof(struct dma_data), GFP_KERNEL);
+	if (prtd->dma_param == NULL)
+		return -ENOMEM;
+
+	s3c6410_pcm_dma_param_init(prtd);
+
+	spin_lock_init(&prtd->lock);
+
+	runtime->private_data = prtd;
+
+	return 0;
+}
+
+static int s3c24xx_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct s3c24xx_runtime_data *prtd = runtime->private_data;
+
+	s3cdbg("Entered %s, prtd = %p\n", __FUNCTION__, prtd);
+
+#ifdef USE_LLI_INTERFACE
+	if(prtd->lli_data)
+		dma_free_coherent(substream->pcm->card->dev, sizeof(struct dmac_lli) * prtd->num_lli, prtd->dma_param->dma_lli_v,
+						  prtd->dma_param->lli_addr);
+#endif
+
+	s3c6410_dmac_free(prtd->dma_param);
+	s3c6410_pcm_dma_param_init(prtd);
+
+	if (prtd->dma_param)
+		kfree(prtd->dma_param);
+
+	if (prtd)
+		kfree(prtd);
+	else
+		printk("s3c24xx_pcm_close called with prtd == NULL\n");
+
+	return 0;
+}
+
+static int s3c24xx_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+                                     runtime->dma_area,
+                                     runtime->dma_addr,
+                                     runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops s3c24xx_pcm_ops = {
+	.open		= s3c24xx_pcm_open,
+	.close		= s3c24xx_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= s3c24xx_pcm_hw_params,
+	.hw_free	= s3c24xx_pcm_hw_free,
+	.prepare	= s3c24xx_pcm_prepare,
+	.trigger	= s3c24xx_pcm_trigger,
+	.pointer	= s3c24xx_pcm_pointer,
+	.mmap		= s3c24xx_pcm_mmap,
+};
+
+static int s3c24xx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = s3c24xx_pcm_hardware.buffer_bytes_max;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	return 0;
+}
+
+static void s3c24xx_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+static u64 s3c24xx_pcm_dmamask = DMA_32BIT_MASK;
+
+static int s3c24xx_pcm_new(struct snd_card *card, 
+	struct snd_soc_dai *dai, struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	s3cdbg("Entered %s\n", __FUNCTION__);
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &s3c24xx_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->playback.channels_min) {
+		ret = s3c24xx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->capture.channels_min) {
+		ret = s3c24xx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+ out:
+	return ret;
+}
+
+struct snd_soc_platform s3c24xx_soc_platform = {
+	.name		= "s3c24xx-audio",
+	.pcm_ops 	= &s3c24xx_pcm_ops,
+	.pcm_new	= s3c24xx_pcm_new,
+	.pcm_free	= s3c24xx_pcm_free_dma_buffers,
+};
+
+EXPORT_SYMBOL_GPL(s3c24xx_soc_platform);
+
+static int __init s3c_soc_platform_init(void)
+{
+    return snd_soc_register_platform(&s3c24xx_soc_platform);
+}
+
+module_init(s3c_soc_platform_init);
+
+static void __exit s3c_soc_platform_exit(void)
+{
+    snd_soc_unregister_platform(&s3c24xx_soc_platform);
+}
+
+module_exit(s3c_soc_platform_exit);
+
+
+MODULE_AUTHOR("Ben Dooks, <ben@simtec.co.uk>");
+MODULE_DESCRIPTION("Samsung S3C24XX PCM DMA module");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/s3c64xx/smdk6400_wm8753.c linux-2.6.29-spica/sound/soc/s3c64xx/smdk6400_wm8753.c
--- linux-2.6.29/sound/soc/s3c64xx/smdk6400_wm8753.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/smdk6400_wm8753.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,436 @@
+/*
+ * smdk6400_wm8753.c  --  SoC audio for Neo1973
+ *
+ * Copyright 2007 Wolfson Microelectronics PLC.
+ * Author: Graeme Gregory
+ *         graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Copyright (C) 2007, Ryu Euiyoul <ryu.real@gmail.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    20th Jan 2007   Initial version.
+ *    05th Feb 2007   Rename all to Neo1973
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware/scoop.h>
+#include <asm/arch/regs-iis.h>
+
+#include <asm/arch/regs-gpio.h>
+#include <asm/hardware.h>
+#include <asm/arch/audio.h>
+#include <asm/io.h>
+#include <asm/arch/spi-gpio.h>
+#include <asm/arch/regs-s3c-clock.h>
+
+#include "../codecs/wm8753.h"
+#include "s3c-pcm.h"
+#include "s3c-i2s.h"
+
+/* define the scenarios */
+#define SMDK6400_AUDIO_OFF		0
+#define SMDK6400_CAPTURE_MIC1		3
+#define SMDK6400_STEREO_TO_HEADPHONES	2
+#define SMDK6400_CAPTURE_LINE_IN	1
+
+#ifdef CONFIG_SND_DEBUG
+#define s3cdbg(x...) printk(x)
+#else
+#define s3cdbg(x...)
+#endif
+
+static int smdk6400_hifi_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_cpu_dai *cpu_dai = rtd->dai->cpu_dai;
+	unsigned int pll_out = 0, bclk = 0;
+	int ret = 0;
+	unsigned int iispsr, iismod;
+	unsigned int prescaler = 4;
+
+	s3cdbg("Entered %s, rate = %d\n", __FUNCTION__, params_rate(params));
+
+	/*PCLK & SCLK gating enable*/
+	writel(readl(S3C_PCLK_GATE)|S3C_CLKCON_PCLK_IIS0, S3C_PCLK_GATE);
+	writel(readl(S3C_SCLK_GATE)|S3C_CLKCON_SCLK_AUDIO0, S3C_SCLK_GATE);
+
+	iismod = readl(S3C_IIS0MOD);
+	iismod &=~(0x3<<3);
+
+	/*Clear I2S prescaler value [13:8] and disable prescaler*/
+	iispsr = readl(S3C_IIS0PSR);	
+	iispsr &=~((0x3f<<8)|(1<<15)); 
+	writel(iispsr, S3C_IIS0PSR);
+	
+	s3cdbg("%s: %d , params = %d \n", __FUNCTION__, __LINE__, params_rate(params));
+
+	switch (params_rate(params)) {
+	case 16000:
+	case 32000:
+		writel(0, S3C_EPLL_CON1);
+		writel((1<<31)|(128<<16)|(25<<8)|(0<<0) ,S3C_EPLL_CON0);
+		break;
+	//case 8000:
+	//	prescaler = 0xe; 
+	case 48000:
+		writel(0, S3C_EPLL_CON1);
+		writel((1<<31)|(192<<16)|(25<<8)|(0<<0) ,S3C_EPLL_CON0);
+		break;
+	case 11025:
+		prescaler = 9; 
+	case 8000:
+	case 22050:
+	case 44100:
+		writel(0, S3C_EPLL_CON1);
+		writel((1<<31)|(254<<16)|(9<<8)|(2<<0) ,S3C_EPLL_CON0);
+		break;
+	default:
+		/* somtimes 32000 rate comes to 96000 
+		   default values are same as 32000 */
+		writel(0, S3C_EPLL_CON1);
+		writel((1<<31)|(128<<16)|(25<<8)|(0<<0) ,S3C_EPLL_CON0);
+
+		/* for 96000 rate : error 0.3% 
+		 * prescaler = 1; 
+		 * writel((1<<31)|(154<<16)|(25<<8)|(0<<0) ,S3C_EPLL_CON0);
+		 */
+		break;
+	}
+
+	s3cdbg("%s, IISCON: %x IISMOD: %x,IISFIC: %x,IISPSR: %x",
+			__FUNCTION__ , readl(S3C_IIS0CON), readl(S3C_IIS0MOD), 
+			readl(S3C_IIS0FIC), readl(S3C_IIS0PSR));
+	
+	while(!(__raw_readl(S3C_EPLL_CON0)&(1<<30)));
+
+	/* MUXepll : FOUTepll */
+	writel(readl(S3C_CLK_SRC)|S3C_CLKSRC_EPLL_CLKSEL, S3C_CLK_SRC);
+	/* AUDIO0 sel : FOUTepll */
+	writel((readl(S3C_CLK_SRC)&~(0x7<<7))|(0<<7), S3C_CLK_SRC);
+
+	/* CLK_DIV2 setting */
+	writel(0x0,S3C_CLK_DIV2);
+
+	switch (params_rate(params)) {
+//	case 8000:
+//		iismod |= S3C_IIS0MOD_768FS;	
+//		pll_out = 12288000;
+//		break;
+	case 11025:
+		iismod |= S3C_IIS0MOD_768FS;	
+		bclk = WM8753_BCLK_DIV_16;
+		pll_out = 16934400;
+		break;
+	case 16000:
+		iismod |= S3C_IIS0MOD_768FS;	
+		bclk = WM8753_BCLK_DIV_2;
+		pll_out = 12288000;
+		break;
+	case 22050:
+		iismod |= S3C_IIS0MOD_768FS;	
+		bclk = WM8753_BCLK_DIV_8;
+		pll_out = 16934400;
+		break;
+	case 32000:
+		iismod |= S3C_IIS0MOD_384FS;
+		bclk = WM8753_BCLK_DIV_2;
+		pll_out = 12288000;
+		break;
+	case 44100:
+	case 8000:
+		iismod |= S3C_IIS0MOD_384FS;
+		bclk = WM8753_BCLK_DIV_4;
+		pll_out = 16934400;
+		break;
+	case 48000:
+		iismod |= S3C_IIS0MOD_384FS;
+		bclk = WM8753_BCLK_DIV_4;
+		pll_out = 18432000;
+		break;
+	default:
+		/* somtimes 32000 rate comes to 96000 
+		   default values are same as 32000 */
+		iismod |= S3C_IIS0MOD_384FS;
+		bclk = WM8753_BCLK_DIV_2;
+		pll_out = 12288000;
+		break;
+	}
+
+	writel(iismod , S3C_IIS0MOD);
+
+	/* set codec DAI configuration */
+	ret = codec_dai->dai_ops.set_fmt(codec_dai,
+		SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS ); 
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = cpu_dai->dai_ops.set_fmt(cpu_dai,
+		SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS ); 
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */
+	ret = codec_dai->dai_ops.set_sysclk(codec_dai, WM8753_MCLK, pll_out,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	/* set MCLK division for sample rate */
+	ret = cpu_dai->dai_ops.set_clkdiv(cpu_dai, S3C24XX_DIV_MCLK,
+		S3C2410_IISMOD_32FS );
+	if (ret < 0)
+		return ret;
+
+	/* set codec BCLK division for sample rate */
+	ret = codec_dai->dai_ops.set_clkdiv(codec_dai, WM8753_BCLKDIV, bclk);
+	if (ret < 0)
+		return ret;
+
+	/* set prescaler division for sample rate */
+	ret = cpu_dai->dai_ops.set_clkdiv(cpu_dai, S3C24XX_DIV_PRESCALER,
+		(prescaler << 0x8));
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int smdk6400_hifi_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec_dai *codec_dai = rtd->dai->codec_dai;
+
+	/* disable the PLL */
+	return codec_dai->dai_ops.set_pll(codec_dai, WM8753_PLL1, 0, 0);
+}
+
+/*
+ * Neo1973 WM8753 HiFi DAI opserations.
+ */
+static struct snd_soc_ops smdk6400_hifi_ops = {
+	.hw_params = smdk6400_hifi_hw_params,
+	.hw_free = smdk6400_hifi_hw_free,
+};
+
+static int smdk6400_scenario = 0;
+
+static int smdk6400_get_scenario(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = smdk6400_scenario;
+	return 0;
+}
+
+static int set_scenario_endpoints(struct snd_soc_codec *codec, int scenario)
+{
+	switch(smdk6400_scenario) {
+	case SMDK6400_AUDIO_OFF:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    0);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  0);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  0);
+		break;
+	case SMDK6400_STEREO_TO_HEADPHONES:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    1);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  0);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  0);
+		break;
+	case SMDK6400_CAPTURE_MIC1:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    0);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  1);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  0);
+		break;
+	case SMDK6400_CAPTURE_LINE_IN:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    0);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  0);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  1);
+		break;
+	default:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    1);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  1);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  1);
+		break;
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+
+	return 0;
+}
+
+static int smdk6400_set_scenario(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (smdk6400_scenario == ucontrol->value.integer.value[0])
+		return 0;
+
+	smdk6400_scenario = ucontrol->value.integer.value[0];
+	set_scenario_endpoints(codec, smdk6400_scenario);
+	return 1;
+}
+
+static const struct snd_soc_dapm_widget wm8753_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_MIC("Mic1 Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+};
+
+
+/* example machine audio_mapnections */
+static const char* audio_map[][3] = {
+
+	{"Headphone Jack", NULL, "LOUT1"},
+	{"Headphone Jack", NULL, "ROUT1"},
+
+	/* mic is connected to mic1 - with bias */
+	/* mic is connected to mic1 - with bias */
+	{"MIC1", NULL, "Mic1 Jack"},
+
+	{"LINE1", NULL, "Line In Jack"},
+	{"LINE2", NULL, "Line In Jack"},
+
+	/* Connect the ALC pins */
+	{"ACIN", NULL, "ACOP"},
+		
+	{NULL, NULL, NULL},
+};
+
+static const char *smdk_scenarios[] = {
+	"Off",
+	"Capture Line In",
+	"Headphones",
+	"Capture Mic1",
+};
+
+static const struct soc_enum smdk_scenario_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(smdk_scenarios),smdk_scenarios),
+};
+
+static const struct snd_kcontrol_new wm8753_smdk6400_controls[] = {
+	SOC_ENUM_EXT("SMDK Mode", smdk_scenario_enum[0],
+		smdk6400_get_scenario, smdk6400_set_scenario),
+};
+
+/*
+ * This is an example machine initialisation for a wm8753 connected to a
+ * smdk6400. It is missing logic to detect hp/mic insertions and logic
+ * to re-route the audio in such an event.
+ */
+static int smdk6400_wm8753_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	/* set endpoints to default mode */
+	set_scenario_endpoints(codec, SMDK6400_AUDIO_OFF);
+
+	/* Add smdk6400 specific widgets */
+	for (i = 0; i < ARRAY_SIZE(wm8753_dapm_widgets); i++)
+		snd_soc_dapm_new_control(codec, &wm8753_dapm_widgets[i]);
+
+	/* add smdk6400 specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8753_smdk6400_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8753_smdk6400_controls[i],
+				codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* set up smdk6400 specific audio path audio_mapnects */
+	for (i = 0; audio_map[i][0] != NULL; i++) {
+		snd_soc_dapm_connect_input(codec, audio_map[i][0],
+			audio_map[i][1], audio_map[i][2]);
+	}
+
+	/* always connected */
+	snd_soc_dapm_set_endpoint(codec, "Mic1 Jack", 1);
+	snd_soc_dapm_set_endpoint(codec, "Headphone Jack", 1);
+	snd_soc_dapm_set_endpoint(codec, "Line In Jack", 1);
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+static struct snd_soc_dai_link smdk6400_dai[] = {
+{ /* Hifi Playback - for similatious use with voice below */
+	.name = "WM8753",
+	.stream_name = "WM8753 HiFi",
+	.cpu_dai = &s3c_i2s_dai,
+	.codec_dai = &wm8753_dai[WM8753_DAI_HIFI],
+	.init = smdk6400_wm8753_init,
+	.ops = &smdk6400_hifi_ops,
+},
+};
+
+static struct snd_soc_machine smdk6400 = {
+	.name = "smdk6400",
+	.dai_link = smdk6400_dai,
+	.num_links = ARRAY_SIZE(smdk6400_dai),
+};
+
+static struct wm8753_setup_data smdk6400_wm8753_setup = {
+	.i2c_address = 0x1a,
+};
+
+static struct snd_soc_device smdk6400_snd_devdata = {
+	.machine = &smdk6400,
+	.platform = &s3c24xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8753,
+	.codec_data = &smdk6400_wm8753_setup,
+};
+
+static struct platform_device *smdk6400_snd_device;
+
+static int __init smdk6400_init(void)
+{
+	int ret;
+
+	smdk6400_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!smdk6400_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(smdk6400_snd_device, &smdk6400_snd_devdata);
+	smdk6400_snd_devdata.dev = &smdk6400_snd_device->dev;
+	ret = platform_device_add(smdk6400_snd_device);
+
+	if (ret)
+		platform_device_put(smdk6400_snd_device);
+	
+	return ret;
+}
+
+static void __exit smdk6400_exit(void)
+{
+	platform_device_unregister(smdk6400_snd_device);
+}
+
+module_init(smdk6400_init);
+module_exit(smdk6400_exit);
+
+/* Module information */
+MODULE_AUTHOR("Ryu Euiyoul");
+MODULE_DESCRIPTION("ALSA SoC WM8753 Neo1973");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/s3c64xx/smdk6410_wm8580.c linux-2.6.29-spica/sound/soc/s3c64xx/smdk6410_wm8580.c
--- linux-2.6.29/sound/soc/s3c64xx/smdk6410_wm8580.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/smdk6410_wm8580.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,333 @@
+/*
+ * smdk6400_wm8580.c
+ *
+ * Copyright 2007, 2008 Wolfson Microelectronics PLC.
+ *
+ * Copyright (C) 2007, Ryu Euiyoul <ryu.real@gmail.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+
+#include <plat/regs-iis.h>
+#include <plat/map-base.h>
+#include <asm/gpio.h> 
+#include <plat/gpio-cfg.h> 
+#include <plat/regs-gpio.h>
+#include <plat/gpio-bank-h.h>
+#include <plat/gpio-bank-c.h>
+
+#include <mach/hardware.h>
+#include <mach/audio.h>
+#include <asm/io.h>
+#include <plat/regs-clock.h>
+
+#include "../codecs/wm8580.h"
+#include "s3c-pcm.h"
+#include "s3c-i2s.h"
+
+#ifdef CONFIG_SND_DEBUG
+#define s3cdbg(x...) printk(x)
+#else
+#define s3cdbg(x...)
+#endif
+
+static int smdk6410_hifi_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	//struct snd_soc_codec_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	unsigned int pll_out = 0; /*bclk = 0; */
+	int ret = 0;
+	unsigned int prescaler;
+
+	s3cdbg("Entered %s, rate = %d\n", __FUNCTION__, params_rate(params));
+
+	/*PCLK & SCLK gating enable*/
+	writel(readl(S3C_PCLK_GATE)|S3C6410_CLKCON_PCLK_IIS2, S3C_PCLK_GATE);
+	writel(readl(S3C_SCLK_GATE)|S3C_CLKCON_SCLK_AUDIO0, S3C_SCLK_GATE);
+
+	/*Clear I2S prescaler value [13:8] and disable prescaler*/
+	/* set prescaler division for sample rate */
+	ret = cpu_dai->dai_ops.set_clkdiv(cpu_dai, S3C24XX_DIV_PRESCALER, 0);
+	if (ret < 0)
+		return ret;
+	
+	s3cdbg("%s: %d , params = %d\n", __FUNCTION__, __LINE__, params_rate(params));
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64100:
+		writel(50332, S3C_EPLL_CON1);
+		writel((1<<31)|(32<<16)|(1<<8)|(3<<0) ,S3C_EPLL_CON0);
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		/* K=10398, M=45, P=1, S=3 -- Fout=67.738 */
+		writel(10398, S3C_EPLL_CON1);
+		writel((1<<31)|(45<<16)|(1<<8)|(3<<0) ,S3C_EPLL_CON0);
+		break;
+	case 48000:
+	case 96000:
+		/* K=9961, M=49, P=1, S=3 -- Fin=12, Fout=73.728; r=1536 */
+		writel(9961, S3C_EPLL_CON1);
+		writel((1<<31)|(49<<16)|(1<<8)|(3<<0) ,S3C_EPLL_CON0);
+		break;
+	default:
+		writel(0, S3C_EPLL_CON1);
+		writel((1<<31)|(128<<16)|(25<<8)|(0<<0) ,S3C_EPLL_CON0);
+		break;
+	}
+
+	while(!(__raw_readl(S3C_EPLL_CON0)&(1<<30)));
+
+	/* MUXepll : FOUTepll */
+	writel(readl(S3C_CLK_SRC)|S3C6400_CLKSRC_EPLL_MOUT, S3C_CLK_SRC);
+
+	/* AUDIO2 sel : FOUTepll */
+	writel((readl(S3C_CLK_SRC2)&~(0x7<<0))|(0<<0), S3C_CLK_SRC2);
+
+	/* CLK_DIV2 setting */
+	writel(0x0,S3C_CLK_DIV2);
+
+	switch (params_rate(params)) {
+	case 8000:
+		pll_out = 2048000;
+		prescaler = 8;
+		break;
+	case 11025:
+		pll_out = 2822400;
+		prescaler = 8; 
+		break;
+	case 16000:
+		pll_out = 4096000;
+		prescaler = 4; 
+		break;
+	case 22050:
+		pll_out = 5644800;
+		prescaler = 4; 
+		break;
+	case 32000:
+		pll_out = 8192000;
+		prescaler = 2; 
+		break;
+	case 44100:
+		/* Fout=73.728 */
+		pll_out = 11289600;
+		prescaler = 2;
+		break;
+	case 48000:
+		/* Fout=67.738 */
+		pll_out = 12288000;
+		prescaler = 2; 
+		break;
+	case 88200:
+		pll_out = 22579200;
+		prescaler = 1; 
+		break;
+	case 96000:
+		pll_out = 24576000;
+		prescaler = 1;
+		break;
+	default:
+		/* somtimes 32000 rate comes to 96000 
+		   default values are same as 32000 */
+		prescaler = 4;
+		pll_out = 12288000;
+		break;
+	}
+
+	/* set MCLK division for sample rate */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+	case SNDRV_PCM_FORMAT_S16_LE:
+		prescaler *= 3;
+		break;
+	case SNDRV_PCM_FORMAT_S24_3LE:
+		prescaler *= 2;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		prescaler *= 2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	prescaler = prescaler - 1; 
+
+	/* set cpu DAI configuration */
+	ret = cpu_dai->dai_ops.set_fmt(cpu_dai,
+		SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS); 
+	if (ret < 0)
+		return ret;
+
+	ret = cpu_dai->dai_ops.set_clkdiv(cpu_dai, S3C24XX_DIV_BCLK,
+		S3C64XX_IIS0MOD_256FS);
+	if (ret < 0)
+		return ret;
+
+	/* set prescaler division for sample rate */
+	ret = cpu_dai->dai_ops.set_clkdiv(cpu_dai, S3C24XX_DIV_PRESCALER,
+		(prescaler << 0x8));
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+/*
+ * WM8580 HiFi DAI opserations.
+ */
+static struct snd_soc_ops smdk6410_hifi_ops = {
+	.hw_params = smdk6410_hifi_hw_params,
+};
+
+static const struct snd_soc_dapm_widget wm8580_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("I2S Front Jack", NULL),
+	SND_SOC_DAPM_LINE("I2S Center Jack", NULL),
+	SND_SOC_DAPM_LINE("I2S Rear Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+};
+
+/* example machine audio_mapnections */
+static const struct snd_soc_dapm_route audio_map[] = {
+
+	{ "I2S Front Jack", NULL, "VOUT1L" },
+	{ "I2S Front Jack", NULL, "VOUT1R" },
+
+	{ "I2S Center Jack", NULL, "VOUT2L" },
+	{ "I2S Center Jack", NULL, "VOUT2R" },
+
+	{ "I2S Rear Jack", NULL, "VOUT3L" },
+	{ "I2S Rear Jack", NULL, "VOUT3R" },
+
+	{ "AINL", NULL, "Line In Jack" },
+	{ "AINR", NULL, "Line In Jack" },
+		
+};
+
+static int smdk6410_wm8580_init(struct snd_soc_codec *codec)
+{
+	int i;
+
+	/* Add smdk6410 specific widgets */
+		snd_soc_dapm_new_controls(codec, wm8580_dapm_widgets,ARRAY_SIZE(wm8580_dapm_widgets));
+
+	/* set up smdk6410 specific audio paths */
+		snd_soc_dapm_add_routes(codec, audio_map,ARRAY_SIZE(audio_map));
+
+	/* No jack detect - mark all jacks as enabled */
+	for (i = 0; i < ARRAY_SIZE(wm8580_dapm_widgets); i++)
+		snd_soc_dapm_set_endpoint(codec,
+					  wm8580_dapm_widgets[i].name, 1);
+
+	snd_soc_dapm_sync_endpoints(codec);
+
+	return 0;
+}
+
+static struct snd_soc_dai_link smdk6410_dai[] = {
+{
+	.name = "WM8580",
+	.stream_name = "WM8580 HiFi Playback",
+	.cpu_dai = &s3c_i2s_v40_dai,
+	.codec_dai = &wm8580_dai[WM8580_DAI_PAIFRX],
+	.init = smdk6410_wm8580_init,
+	.ops = &smdk6410_hifi_ops,
+},
+};
+
+static struct snd_soc_machine smdk6410 = {
+	.name = "smdk6410",
+	.dai_link = smdk6410_dai,
+	.num_links = ARRAY_SIZE(smdk6410_dai),
+};
+
+static struct wm8580_setup_data smdk6410_wm8580_setup = {
+	.i2c_address = 0x1b,
+};
+
+static struct snd_soc_device smdk6410_snd_devdata = {
+	.machine = &smdk6410,
+	.platform = &s3c24xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8580,
+	.codec_data = &smdk6410_wm8580_setup,
+};
+
+static struct platform_device *smdk6410_snd_device;
+
+static int __init smdk6410_init(void)
+{
+	int ret;
+	unsigned int *reg_GPHCON1;
+	unsigned int *reg_GPCCON;
+
+	reg_GPHCON1 = ioremap(0x7f0080e4,0x100);
+	reg_GPCCON = ioremap(0x7f008040,0x100);
+
+	s3c_gpio_cfgpin(S3C64XX_GPH(6), S3C64XX_GPH6_I2S_V40_BCLK);
+	s3c_gpio_cfgpin(S3C64XX_GPH(7), S3C64XX_GPH7_I2S_V40_CDCLK);
+	writel(0x50550000, reg_GPCCON);
+	writel(0x00000055, reg_GPHCON1);
+
+	s3c_gpio_cfgpin(S3C64XX_GPC(4), S3C64XX_GPC4_I2S_V40_DO0);
+	s3c_gpio_cfgpin(S3C64XX_GPC(5), S3C64XX_GPC5_I2S_V40_DO1);
+	s3c_gpio_cfgpin(S3C64XX_GPC(7), S3C64XX_GPC7_I2S_V40_DO2);
+
+	/* pull-up-enable, pull-down-disable*/
+	s3c_gpio_setpull(S3C64XX_GPH(6), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S3C64XX_GPH(7), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S3C64XX_GPH(8), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S3C64XX_GPH(9), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S3C64XX_GPC(4), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S3C64XX_GPC(5), S3C_GPIO_PULL_UP);
+	s3c_gpio_setpull(S3C64XX_GPC(7), S3C_GPIO_PULL_UP);
+
+	smdk6410_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!smdk6410_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(smdk6410_snd_device, &smdk6410_snd_devdata);
+	smdk6410_snd_devdata.dev = &smdk6410_snd_device->dev;
+	ret = platform_device_add(smdk6410_snd_device);
+
+	if (ret)
+		platform_device_put(smdk6410_snd_device);
+	
+	return ret;
+}
+
+static void __exit smdk6410_exit(void)
+{
+	platform_device_unregister(smdk6410_snd_device);
+}
+
+module_init(smdk6410_init);
+module_exit(smdk6410_exit);
+
+/* Module information */
+MODULE_AUTHOR("Mark Brown");
+MODULE_DESCRIPTION("ALSA SoC SMDK6410 WM8580");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/s3c64xx/smdk6410_wm8990.c linux-2.6.29-spica/sound/soc/s3c64xx/smdk6410_wm8990.c
--- linux-2.6.29/sound/soc/s3c64xx/smdk6410_wm8990.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/smdk6410_wm8990.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,432 @@
+/*
+* smdk6410_wm8990.c  --  SoC audio for SMDK6410 with WM8990
+ *
+ * Copyright 2007, 2008 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         lg@opensource.wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  Copyright (C) 2007, Ryu Euiyoul <ryu.real@gmail.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    28th Feb 2008   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+//#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <plat/regs-iis.h>
+#include <mach/map.h>
+
+#include <plat/regs-gpio.h>
+#include <mach/hardware.h>
+#include <mach/audio.h>
+#include <asm/io.h>
+#include <plat/regs-clock.h>
+
+#include "../codecs/wm8990.h"
+#include "s3c-pcm.h"
+#include "s3c-i2s.h"
+
+/* define the scenarios */
+#define SMDK6410_AUDIO_OFF		0
+#define SMDK6410_CAPTURE_MIC1		3
+#define SMDK6410_STEREO_TO_HEADPHONES	2
+#define SMDK6410_CAPTURE_LINE_IN	1
+
+#ifdef CONFIG_SND_DEBUG
+#define s3cdbg(x...) printk(x)
+#else
+#define s3cdbg(x...)
+#endif
+
+/*
+ * TODO: - We need to work out PLL values for 256FS for every rate.
+ */
+static int smdk6410_hifi_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	unsigned int pll_out = 0;//, bclk = 0;
+	int ret = 0;
+	unsigned int iispsr, iismod;
+	unsigned int prescaler = 4;
+
+	u32*	regs;
+	regs = ioremap(S3C64XX_PA_IIS, 0x100);
+
+	s3cdbg("Entered %s, rate = %d\n", __FUNCTION__, params_rate(params));
+
+	/*PCLK & SCLK gating enable*/
+	writel(readl(S3C_PCLK_GATE)|S3C_CLKCON_PCLK_IIS0, S3C_PCLK_GATE);
+	writel(readl(S3C_SCLK_GATE)|S3C_CLKCON_SCLK_AUDIO0, S3C_SCLK_GATE);
+
+	iismod = readl(regs + S3C64XX_IIS0MOD);
+	iismod &= ~S3C64XX_IIS0MOD_FS_MASK;
+	iismod &= ~S3C64XX_IIS0MOD_BFS_MASK;
+
+	/*Clear I2S prescaler value [13:8] and disable prescaler*/
+	iispsr = readl(regs + S3C64XX_IIS0PSR);	
+	iispsr &=~((0x3f<<8)|(1<<15)); 
+	writel(iispsr, regs + S3C64XX_IIS0PSR);
+	
+	s3cdbg("%s: %d , params = %d\n", __FUNCTION__, __LINE__, params_rate(params));
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64100:
+		writel(50332, S3C_EPLL_CON1);
+		writel((1<<31)|(32<<16)|(1<<8)|(3<<0) ,S3C_EPLL_CON0);
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		writel(10398, S3C_EPLL_CON1);
+		writel((1<<31)|(45<<16)|(1<<8)|(3<<0) ,S3C_EPLL_CON0);
+		break;
+	case 48000:
+	case 96000:
+		writel(9961, S3C_EPLL_CON1);
+		writel((1<<31)|(49<<16)|(1<<8)|(3<<0) ,S3C_EPLL_CON0);
+		break;
+	default:
+		writel(0, S3C_EPLL_CON1);
+		writel((1<<31)|(128<<16)|(25<<8)|(0<<0) ,S3C_EPLL_CON0);
+		break;
+	}
+
+	s3cdbg("%s, IISCON: %x IISMOD: %x,IISFIC: %x,IISPSR: %x\n",
+			__FUNCTION__ , readl(S3C_IIS0CON), readl(S3C_IIS0MOD), 
+			readl(S3C_IIS0FIC), readl(S3C_IIS0PSR));
+	
+	while(!(__raw_readl(S3C_EPLL_CON0)&(1<<30)));
+
+	/* MUXepll : FOUTepll */
+	writel(readl(S3C_CLK_SRC)|S3C_CLKSRC_EPLL_CLKSEL, S3C_CLK_SRC);
+	/* AUDIO0 sel : FOUTepll */
+	writel((readl(S3C_CLK_SRC)&~(0x7<<7))|(0<<7), S3C_CLK_SRC);
+
+	/* CLK_DIV2 setting */
+	writel(0x0,S3C_CLK_DIV2);
+
+	switch (params_rate(params)) {
+	case 8000:
+		pll_out = 2048000;
+		prescaler = 8;
+		break;
+	case 11025:
+		pll_out = 2822400;
+		prescaler = 8; 
+		break;
+	case 16000:
+		pll_out = 4096000;
+		prescaler = 4; 
+		break;
+	case 22050:
+		pll_out = 5644800;
+		prescaler = 4; 
+		break;
+	case 32000:
+		pll_out = 8192000;
+		prescaler = 2; 
+		break;
+	case 44100:
+		pll_out = 11289600;
+		//prescaler = 6; 
+		prescaler = 2; 
+		break;
+	case 48000:
+		pll_out = 12288000;
+		prescaler = 2; 
+		break;
+	case 88200:
+		pll_out = 22579200;
+		prescaler = 1; 
+		break;
+	case 96000:
+		pll_out = 24576000;
+		prescaler = 1;
+		break;
+	default:
+		/* somtimes 32000 rate comes to 96000 
+		   default values are same as 32000 */
+		iismod |= S3C64XX_IIS0MOD_384FS;
+		pll_out = 12288000;
+		break;
+	}
+
+	/* set MCLK division for sample rate */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+	case SNDRV_PCM_FORMAT_S16_LE:
+		iismod |= S3C64XX_IIS0MOD_256FS | S3C64XX_IIS0MOD_32FS;
+		prescaler *= 3;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		iismod |= S3C64XX_IIS0MOD_384FS | S3C64XX_IIS0MOD_48FS;
+		prescaler *= 2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	prescaler = prescaler - 1; 
+	writel(iismod , regs + S3C64XX_IIS0MOD);
+
+	/* set codec DAI configuration */
+	ret = codec_dai->dai_ops.set_fmt(codec_dai,
+		SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS ); 
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = cpu_dai->dai_ops.set_fmt(cpu_dai,
+		SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS ); 
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */
+	ret = codec_dai->dai_ops.set_sysclk(codec_dai, WM8990_MCLK, pll_out,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	/* set prescaler division for sample rate */
+	ret = cpu_dai->dai_ops.set_clkdiv(cpu_dai, S3C24XX_DIV_PRESCALER,
+		(prescaler << 0x8));
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+/*
+ * Neo1973 WM8990 HiFi DAI opserations.
+ */
+static struct snd_soc_ops smdk6410_hifi_ops = {
+	.hw_params = smdk6410_hifi_hw_params,
+};
+
+static int smdk6410_scenario = 0;
+
+static int smdk6410_get_scenario(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = smdk6410_scenario;
+	return 0;
+}
+
+static int set_scenario_endpoints(struct snd_soc_codec *codec, int scenario)
+{
+	smdk6410_scenario = scenario;
+	switch (smdk6410_scenario) {
+	case SMDK6410_AUDIO_OFF:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    0);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  0);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  0);
+		break;
+	case SMDK6410_STEREO_TO_HEADPHONES:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    1);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  0);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  0);
+		break;
+	case SMDK6410_CAPTURE_MIC1:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    0);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  1);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  0);
+		break;
+	case SMDK6410_CAPTURE_LINE_IN:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    0);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  0);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  1);
+		break;
+	default:
+		snd_soc_dapm_set_endpoint(codec, "Headphone Jack",    1);
+		snd_soc_dapm_set_endpoint(codec, "Mic1 Jack",  1);
+		snd_soc_dapm_set_endpoint(codec, "Line In Jack",  1);
+		break;
+	}
+
+	snd_soc_dapm_sync_endpoints(codec);
+	return 0;
+}
+
+static int smdk6410_set_scenario(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (smdk6410_scenario == ucontrol->value.integer.value[0])
+		return 0;
+
+	set_scenario_endpoints(codec, ucontrol->value.integer.value[0]);
+	return 1;
+}
+
+static const struct snd_soc_dapm_widget wm8990_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_MIC("Mic1 Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+};
+
+/* example machine audio_mapnections */
+static const struct snd_soc_dapm_route audio_map[] = {
+
+	/* no irq jack detect */
+	{"Headphone Jack", NULL, "LOUT"},
+	{"Headphone Jack", NULL, "ROUT"},
+
+	/* mic is connected to LIN1 and LIN2 - with bias */
+	{"LIN1", NULL, "Mic1 Jack"},
+	//{"LIN2", NULL, "Mic1 Jack"},
+
+	{"LIN2", NULL, "Line In Jack"},
+	{"RIN2", NULL, "Line In Jack"},
+		
+};
+
+static const char *smdk_scenarios[] = {
+	"Off",
+	"Capture Line In",
+	"Headphones",
+	"Capture Mic1",
+};
+
+static const struct soc_enum smdk_scenario_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(smdk_scenarios),smdk_scenarios),
+};
+
+static const struct snd_kcontrol_new wm8990_smdk6410_controls[] = {
+	SOC_ENUM_EXT("SMDK Mode", smdk_scenario_enum[0],
+		smdk6410_get_scenario, smdk6410_set_scenario),
+};
+
+/*
+ * This is an example machine initialisation for a wm8990 connected to a
+ * smdk6410. It is missing logic to detect hp/mic insertions and logic
+ * to re-route the audio in such an event.
+ */
+static int smdk6410_wm8990_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	/* Add smdk6410 specific widgets */
+	for (i = 0; i < ARRAY_SIZE(wm8990_dapm_widgets); i++)
+		snd_soc_dapm_new_control(codec, &wm8990_dapm_widgets[i]);
+
+	/* add smdk6410 specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8990_smdk6410_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				snd_soc_cnew(&wm8990_smdk6410_controls[i],
+				codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* set up smdk6410 specific audio paths */
+	snd_soc_dapm_add_routes(codec, audio_map,ARRAY_SIZE(audio_map));
+
+	/* not connected */
+	snd_soc_dapm_set_endpoint(codec, "RIN1", 0);
+	snd_soc_dapm_set_endpoint(codec, "LIN3", 0);
+	snd_soc_dapm_set_endpoint(codec, "LIN4", 0);
+	snd_soc_dapm_set_endpoint(codec, "RIN3", 0);
+	snd_soc_dapm_set_endpoint(codec, "RIN4", 0);
+	snd_soc_dapm_set_endpoint(codec, "OUT3", 0);
+	snd_soc_dapm_set_endpoint(codec, "OUT4", 0);
+	snd_soc_dapm_set_endpoint(codec, "SPKP", 0);
+	snd_soc_dapm_set_endpoint(codec, "SPKN", 0);
+	snd_soc_dapm_set_endpoint(codec, "ROP", 0);
+	snd_soc_dapm_set_endpoint(codec, "RON", 0);
+	snd_soc_dapm_set_endpoint(codec, "LOP", 0);
+	snd_soc_dapm_set_endpoint(codec, "LON", 0);
+
+	/* set endpoints to default mode & sync with DAPM */
+	set_scenario_endpoints(codec, SMDK6410_STEREO_TO_HEADPHONES);
+		
+	return 0;
+}
+
+static struct snd_soc_dai_link smdk6410_dai[] = {
+{ /* Hifi Playback - for similatious use with voice below */
+	.name = "WM8990",
+	.stream_name = "WM8990 HiFi",
+	.cpu_dai = &s3c_i2s_dai,
+	.codec_dai = &wm8990_dai,
+	.init = smdk6410_wm8990_init,
+	.ops = &smdk6410_hifi_ops,
+},
+};
+
+static struct snd_soc_machine smdk6410 = {
+	.name = "smdk6410",
+	.dai_link = smdk6410_dai,
+	.num_links = ARRAY_SIZE(smdk6410_dai),
+};
+
+static struct wm8990_setup_data smdk6410_wm8990_setup = {
+	.i2c_address = 0x1b,
+};
+
+static struct snd_soc_device smdk6410_snd_devdata = {
+	.machine = &smdk6410,
+	.platform = &s3c24xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm8990,
+	.codec_data = &smdk6410_wm8990_setup,
+};
+
+static struct platform_device *smdk6410_snd_device;
+
+static int __init smdk6410_init(void)
+{
+	int ret;
+
+	smdk6410_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!smdk6410_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(smdk6410_snd_device, &smdk6410_snd_devdata);
+	smdk6410_snd_devdata.dev = &smdk6410_snd_device->dev;
+	ret = platform_device_add(smdk6410_snd_device);
+
+	if (ret)
+		platform_device_put(smdk6410_snd_device);
+	
+	return ret;
+}
+
+static void __exit smdk6410_exit(void)
+{
+	platform_device_unregister(smdk6410_snd_device);
+}
+
+module_init(smdk6410_init);
+module_exit(smdk6410_exit);
+
+/* Module information */
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_DESCRIPTION("ALSA SoC WM8990 SMDK6410");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/s3c64xx/smdk64xx_wm9713.c linux-2.6.29-spica/sound/soc/s3c64xx/smdk64xx_wm9713.c
--- linux-2.6.29/sound/soc/s3c64xx/smdk64xx_wm9713.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.29-spica/sound/soc/s3c64xx/smdk64xx_wm9713.c	2010-05-06 12:42:45.684270633 +0700
@@ -0,0 +1,88 @@
+/*
+ * smdk6400_wm9713.c  --  SoC audio for smdk6400
+ *
+ * Copyright (C) 2007, Ryu Euiyoul <ryu.real@gmail.com>
+ *
+ * Copyright 2007 Wolfson Microelectronics PLC.
+ * Author: Graeme Gregory
+ *         graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    8th  Mar 2007   Initial version.
+ *    20th Sep 2007   Apply at smdk6400
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include "../codecs/wm9713.h"
+#include "s3c-pcm.h"
+#include "s3c64xx-ac97.h"
+
+static struct snd_soc_machine smdk6400;
+
+static struct snd_soc_dai_link smdk6400_dai[] = {
+{
+	.name = "AC97",
+	.stream_name = "AC97 HiFi",
+	.cpu_dai = &s3c6400_ac97_dai[0],
+	.codec_dai = &wm9713_dai[WM9713_DAI_AC97_HIFI],
+},
+};
+
+static struct snd_soc_machine smdk6400 = {
+	.name = "SMDK6400",
+	.dai_link = smdk6400_dai,
+	.num_links = ARRAY_SIZE(smdk6400_dai),
+};
+
+static struct snd_soc_device smdk6400_snd_ac97_devdata = {
+	.machine = &smdk6400,
+	.platform = &s3c24xx_soc_platform,
+	.codec_dev = &soc_codec_dev_wm9713,
+};
+
+static struct platform_device *smdk6400_snd_ac97_device;
+
+static int __init smdk6400_init(void)
+{
+	int ret;
+
+	smdk6400_snd_ac97_device = platform_device_alloc("soc-audio", -1);
+	if (!smdk6400_snd_ac97_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(smdk6400_snd_ac97_device,
+				&smdk6400_snd_ac97_devdata);
+	smdk6400_snd_ac97_devdata.dev = &smdk6400_snd_ac97_device->dev;
+	ret = platform_device_add(smdk6400_snd_ac97_device);
+
+	if (ret)
+		platform_device_put(smdk6400_snd_ac97_device);
+
+	return ret;
+}
+
+static void __exit smdk6400_exit(void)
+{
+	platform_device_unregister(smdk6400_snd_ac97_device);
+}
+
+module_init(smdk6400_init);
+module_exit(smdk6400_exit);
+
+/* Module information */
+MODULE_AUTHOR("Samsung: Ryu");
+MODULE_DESCRIPTION("ALSA SoC WM9713 SMDK6400");
+MODULE_LICENSE("GPL");
diff -Nur linux-2.6.29/sound/soc/soc-core.c linux-2.6.29-spica/sound/soc/soc-core.c
--- linux-2.6.29/sound/soc/soc-core.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/sound/soc/soc-core.c	2010-05-06 12:42:45.684270633 +0700
@@ -966,6 +966,17 @@
 	return 0;
 }
 
+static int soc_shutdown(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
+
+	if (codec_dev->shutdown)
+		codec_dev->shutdown(pdev);
+
+	return 0;
+}
+
 /* ASoC platform driver */
 static struct platform_driver soc_driver = {
 	.driver		= {
diff -Nur linux-2.6.29/sound/soc/soc-dapm.c linux-2.6.29-spica/sound/soc/soc-dapm.c
--- linux-2.6.29/sound/soc/soc-dapm.c	2009-03-24 05:12:14.000000000 +0600
+++ linux-2.6.29-spica/sound/soc/soc-dapm.c	2010-05-06 12:42:45.684270633 +0700
@@ -1627,6 +1627,45 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_dapm_free);
 
+/* snd_soc_dapm_set_endpoint - set audio endpoint status
+  * @codec: audio codec
+  * @endpoint: audio signal endpoint (or start point)
+  * @status: point status
+  *
+  * Set audio endpoint status - connected or disconnected.
+  *
+  * Returns 0 for success else error.
+  */
+int snd_soc_dapm_set_endpoint(struct snd_soc_codec *codec,
+      char *endpoint, int status)
+{
+      struct snd_soc_dapm_widget *w;
+
+      list_for_each_entry(w, &codec->dapm_widgets, list) {
+              if (!strcmp(w->name, endpoint)) {
+                      w->connected = status;
+              }
+      }
+
+      return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_set_endpoint);
+
+/**
+ * snd_soc_dapm_sync_endpoints - scan and power dapm paths
+ * @codec: audio codec
+ *
+ * Walks all dapm audio paths and powers widgets according to their
+ * stream or path usage.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_sync_endpoints(struct snd_soc_codec *codec)
+{
+	return dapm_power_widgets(codec, SND_SOC_DAPM_STREAM_NOP);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_sync_endpoints);
+
 /* Module information */
 MODULE_AUTHOR("Liam Girdwood, lrg@slimlogic.co.uk");
 MODULE_DESCRIPTION("Dynamic Audio Power Management core for ALSA SoC");
