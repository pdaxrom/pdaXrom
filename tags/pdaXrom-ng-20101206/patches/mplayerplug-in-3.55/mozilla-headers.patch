diff -Nur mplayerplug-in-3.55-orig/include/jni.h mplayerplug-in-3.55/include/jni.h
--- mplayerplug-in-3.55-orig/include/jni.h	1970-01-01 07:00:00.000000000 +0700
+++ mplayerplug-in-3.55/include/jni.h	2007-08-04 02:59:37.000000000 +0700
@@ -0,0 +1,1810 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Java Runtime Interface.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation and Sun Microsystems, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 1993-1996
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef JNI_H
+#define JNI_H
+
+#include <stdio.h>
+#include <stdarg.h>
+
+/* jni_md.h contains the machine-dependent typedefs for jbyte, jint 
+   and jlong */ 
+
+#include "jni_md.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * JNI Types
+ */
+
+typedef unsigned char	jboolean;
+typedef unsigned short	jchar;
+typedef short		jshort;
+typedef float		jfloat;
+typedef double		jdouble;
+
+typedef jint            jsize;
+
+#ifdef __cplusplus
+
+class _jobject {};
+class _jclass : public _jobject {};
+class _jthrowable : public _jobject {};
+class _jstring : public _jobject {};
+class _jarray : public _jobject {};
+class _jbooleanArray : public _jarray {};
+class _jbyteArray : public _jarray {};
+class _jcharArray : public _jarray {};
+class _jshortArray : public _jarray {};
+class _jintArray : public _jarray {};
+class _jlongArray : public _jarray {};
+class _jfloatArray : public _jarray {};
+class _jdoubleArray : public _jarray {};
+class _jobjectArray : public _jarray {};
+
+typedef _jobject *jobject;
+typedef _jclass *jclass;
+typedef _jthrowable *jthrowable;
+typedef _jstring *jstring;
+typedef _jarray *jarray;
+typedef _jbooleanArray *jbooleanArray;
+typedef _jbyteArray *jbyteArray;
+typedef _jcharArray *jcharArray;
+typedef _jshortArray *jshortArray;
+typedef _jintArray *jintArray;
+typedef _jlongArray *jlongArray;
+typedef _jfloatArray *jfloatArray;
+typedef _jdoubleArray *jdoubleArray;
+typedef _jobjectArray *jobjectArray;
+
+#else
+
+struct _jobject;
+
+typedef struct _jobject *jobject;
+typedef jobject jclass;
+typedef jobject jthrowable;
+typedef jobject jstring;
+typedef jobject jarray;
+typedef jarray jbooleanArray;
+typedef jarray jbyteArray;
+typedef jarray jcharArray;
+typedef jarray jshortArray;
+typedef jarray jintArray;
+typedef jarray jlongArray;
+typedef jarray jfloatArray;
+typedef jarray jdoubleArray;
+typedef jarray jobjectArray;
+
+#endif
+
+#if 0	/* moved to jri_md.h */
+typedef jobject jref; /* For transition---not meant to be part of public 
+			 API anymore.*/
+#endif
+
+typedef union jvalue {
+    jboolean z;
+    jbyte    b;
+    jchar    c;
+    jshort   s;
+    jint     i;
+    jlong    j;
+    jfloat   f;
+    jdouble  d;
+    jobject  l;
+} jvalue;
+
+struct _jfieldID;
+typedef struct _jfieldID *jfieldID;
+
+struct _jmethodID;
+typedef struct _jmethodID *jmethodID;
+
+/*
+ * jboolean constants
+ */
+
+#define JNI_FALSE 0
+#define JNI_TRUE 1
+
+/*
+ * possible return values for JNI functions.
+ */
+
+#define JNI_OK 0
+#define JNI_ERR (-1)
+
+/*
+ * used in ReleaseScalarArrayElements
+ */
+  
+#define JNI_COMMIT 1
+#define JNI_ABORT 2
+
+/*
+ * used in RegisterNatives to describe native method name, signature,
+ * and function pointer.
+ */
+
+typedef struct {
+    char *name;
+    char *signature;
+    void *fnPtr;
+} JNINativeMethod;
+
+/*
+ * JNI Native Method Interface.
+ */
+
+struct JNINativeInterface_;
+
+struct JNIEnv_;
+
+#ifdef __cplusplus
+typedef JNIEnv_ JNIEnv;
+#else
+typedef const struct JNINativeInterface_ *JNIEnv;
+#endif
+
+/*
+ * JNI Invocation Interface.
+ */
+
+struct JNIInvokeInterface_;
+
+struct JavaVM_;
+
+#ifdef __cplusplus
+typedef JavaVM_ JavaVM;
+#else
+typedef const struct JNIInvokeInterface_ *JavaVM;
+#endif
+
+struct JNINativeInterface_ {
+    void *reserved0;
+    void *reserved1;
+    void *reserved2;
+
+    void *reserved3;
+    jint (JNICALL *GetVersion)(JNIEnv *env);
+
+    jclass (JNICALL *DefineClass)
+      (JNIEnv *env, const char *name, jobject loader, const jbyte *buf, 
+       jsize len);
+    jclass (JNICALL *FindClass)
+      (JNIEnv *env, const char *name);
+
+    void *reserved4;
+    void *reserved5;
+    void *reserved6;
+
+    jclass (JNICALL *GetSuperclass)
+      (JNIEnv *env, jclass sub);
+    jboolean (JNICALL *IsAssignableFrom)
+      (JNIEnv *env, jclass sub, jclass sup);
+    void *reserved7;
+
+
+    jint (JNICALL *Throw)
+      (JNIEnv *env, jthrowable obj);
+    jint (JNICALL *ThrowNew)
+      (JNIEnv *env, jclass clazz, const char *msg);
+    jthrowable (JNICALL *ExceptionOccurred)
+      (JNIEnv *env);
+    void (JNICALL *ExceptionDescribe)
+      (JNIEnv *env);
+    void (JNICALL *ExceptionClear)
+      (JNIEnv *env);
+    void (JNICALL *FatalError)
+      (JNIEnv *env, const char *msg);
+    void *reserved8;
+    void *reserved9;
+
+    jobject (JNICALL *NewGlobalRef)
+      (JNIEnv *env, jobject lobj);
+    void (JNICALL *DeleteGlobalRef)
+      (JNIEnv *env, jobject gref);
+    void (JNICALL *DeleteLocalRef)
+      (JNIEnv *env, jobject obj);
+    jboolean (JNICALL *IsSameObject)
+      (JNIEnv *env, jobject obj1, jobject obj2);
+    void *reserved10;
+    void *reserved11;
+
+    jobject (JNICALL *AllocObject)
+      (JNIEnv *env, jclass clazz);
+    jobject (JNICALL *NewObject)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jobject (JNICALL *NewObjectV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jobject (JNICALL *NewObjectA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);
+
+    jclass (JNICALL *GetObjectClass)
+      (JNIEnv *env, jobject obj);
+    jboolean (JNICALL *IsInstanceOf)
+      (JNIEnv *env, jobject obj, jclass clazz);
+
+    jmethodID (JNICALL *GetMethodID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+
+    jobject (JNICALL *CallObjectMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jobject (JNICALL *CallObjectMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jobject (JNICALL *CallObjectMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, jvalue * args);
+
+    jboolean (JNICALL *CallBooleanMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jboolean (JNICALL *CallBooleanMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jboolean (JNICALL *CallBooleanMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, jvalue * args);
+
+    jbyte (JNICALL *CallByteMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jbyte (JNICALL *CallByteMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jbyte (JNICALL *CallByteMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, jvalue *args);
+
+    jchar (JNICALL *CallCharMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jchar (JNICALL *CallCharMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jchar (JNICALL *CallCharMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, jvalue *args);
+
+    jshort (JNICALL *CallShortMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jshort (JNICALL *CallShortMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jshort (JNICALL *CallShortMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, jvalue *args);
+
+    jint (JNICALL *CallIntMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jint (JNICALL *CallIntMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jint (JNICALL *CallIntMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, jvalue *args);
+
+    jlong (JNICALL *CallLongMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jlong (JNICALL *CallLongMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jlong (JNICALL *CallLongMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, jvalue *args);
+
+    jfloat (JNICALL *CallFloatMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jfloat (JNICALL *CallFloatMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jfloat (JNICALL *CallFloatMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, jvalue *args);
+
+    jdouble (JNICALL *CallDoubleMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jdouble (JNICALL *CallDoubleMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jdouble (JNICALL *CallDoubleMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, jvalue *args);
+
+    void (JNICALL *CallVoidMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    void (JNICALL *CallVoidMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    void (JNICALL *CallVoidMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, jvalue * args);
+
+    jobject (JNICALL *CallNonvirtualObjectMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jobject (JNICALL *CallNonvirtualObjectMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, 
+       va_list args);
+    jobject (JNICALL *CallNonvirtualObjectMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, 
+       jvalue * args);
+
+    jboolean (JNICALL *CallNonvirtualBooleanMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jboolean (JNICALL *CallNonvirtualBooleanMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jboolean (JNICALL *CallNonvirtualBooleanMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       jvalue * args);
+
+    jbyte (JNICALL *CallNonvirtualByteMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jbyte (JNICALL *CallNonvirtualByteMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jbyte (JNICALL *CallNonvirtualByteMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, 
+       jvalue *args);
+
+    jchar (JNICALL *CallNonvirtualCharMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jchar (JNICALL *CallNonvirtualCharMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jchar (JNICALL *CallNonvirtualCharMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       jvalue *args);
+
+    jshort (JNICALL *CallNonvirtualShortMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jshort (JNICALL *CallNonvirtualShortMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jshort (JNICALL *CallNonvirtualShortMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       jvalue *args);
+
+    jint (JNICALL *CallNonvirtualIntMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jint (JNICALL *CallNonvirtualIntMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jint (JNICALL *CallNonvirtualIntMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       jvalue *args);
+
+    jlong (JNICALL *CallNonvirtualLongMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jlong (JNICALL *CallNonvirtualLongMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jlong (JNICALL *CallNonvirtualLongMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, 
+       jvalue *args);
+
+    jfloat (JNICALL *CallNonvirtualFloatMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jfloat (JNICALL *CallNonvirtualFloatMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jfloat (JNICALL *CallNonvirtualFloatMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       jvalue *args);
+
+    jdouble (JNICALL *CallNonvirtualDoubleMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jdouble (JNICALL *CallNonvirtualDoubleMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jdouble (JNICALL *CallNonvirtualDoubleMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       jvalue *args);
+
+    void (JNICALL *CallNonvirtualVoidMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    void (JNICALL *CallNonvirtualVoidMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    void (JNICALL *CallNonvirtualVoidMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       jvalue * args);
+
+    jfieldID (JNICALL *GetFieldID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+
+    jobject (JNICALL *GetObjectField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jboolean (JNICALL *GetBooleanField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jbyte (JNICALL *GetByteField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jchar (JNICALL *GetCharField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jshort (JNICALL *GetShortField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jint (JNICALL *GetIntField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jlong (JNICALL *GetLongField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jfloat (JNICALL *GetFloatField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jdouble (JNICALL *GetDoubleField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+
+    void (JNICALL *SetObjectField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jobject val);
+    void (JNICALL *SetBooleanField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jboolean val);
+    void (JNICALL *SetByteField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jbyte val);
+    void (JNICALL *SetCharField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jchar val);
+    void (JNICALL *SetShortField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jshort val);
+    void (JNICALL *SetIntField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jint val);
+    void (JNICALL *SetLongField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jlong val);
+    void (JNICALL *SetFloatField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jfloat val);
+    void (JNICALL *SetDoubleField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jdouble val);
+
+    jmethodID (JNICALL *GetStaticMethodID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+
+    jobject (JNICALL *CallStaticObjectMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jobject (JNICALL *CallStaticObjectMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jobject (JNICALL *CallStaticObjectMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);
+
+    jboolean (JNICALL *CallStaticBooleanMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jboolean (JNICALL *CallStaticBooleanMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jboolean (JNICALL *CallStaticBooleanMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);
+
+    jbyte (JNICALL *CallStaticByteMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jbyte (JNICALL *CallStaticByteMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jbyte (JNICALL *CallStaticByteMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);
+
+    jchar (JNICALL *CallStaticCharMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jchar (JNICALL *CallStaticCharMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jchar (JNICALL *CallStaticCharMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);
+
+    jshort (JNICALL *CallStaticShortMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jshort (JNICALL *CallStaticShortMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jshort (JNICALL *CallStaticShortMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);
+
+    jint (JNICALL *CallStaticIntMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jint (JNICALL *CallStaticIntMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jint (JNICALL *CallStaticIntMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);
+
+    jlong (JNICALL *CallStaticLongMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jlong (JNICALL *CallStaticLongMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jlong (JNICALL *CallStaticLongMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);
+
+    jfloat (JNICALL *CallStaticFloatMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jfloat (JNICALL *CallStaticFloatMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jfloat (JNICALL *CallStaticFloatMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);
+
+    jdouble (JNICALL *CallStaticDoubleMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jdouble (JNICALL *CallStaticDoubleMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jdouble (JNICALL *CallStaticDoubleMethodA)       
+      (JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);
+
+    void (JNICALL *CallStaticVoidMethod)
+      (JNIEnv *env, jclass cls, jmethodID methodID, ...);
+    void (JNICALL *CallStaticVoidMethodV)
+      (JNIEnv *env, jclass cls, jmethodID methodID, va_list args);
+    void (JNICALL *CallStaticVoidMethodA)
+      (JNIEnv *env, jclass cls, jmethodID methodID, jvalue * args);
+
+    jfieldID (JNICALL *GetStaticFieldID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+    jobject (JNICALL *GetStaticObjectField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jboolean (JNICALL *GetStaticBooleanField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jbyte (JNICALL *GetStaticByteField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jchar (JNICALL *GetStaticCharField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jshort (JNICALL *GetStaticShortField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jint (JNICALL *GetStaticIntField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jlong (JNICALL *GetStaticLongField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jfloat (JNICALL *GetStaticFloatField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jdouble (JNICALL *GetStaticDoubleField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+
+    void (JNICALL *SetStaticObjectField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value);
+    void (JNICALL *SetStaticBooleanField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jboolean value);
+    void (JNICALL *SetStaticByteField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jbyte value);
+    void (JNICALL *SetStaticCharField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jchar value);
+    void (JNICALL *SetStaticShortField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jshort value);
+    void (JNICALL *SetStaticIntField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jint value);
+    void (JNICALL *SetStaticLongField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jlong value);
+    void (JNICALL *SetStaticFloatField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jfloat value);
+    void (JNICALL *SetStaticDoubleField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jdouble value);
+
+    jstring (JNICALL *NewString)
+      (JNIEnv *env, const jchar *unicode, jsize len);
+    jsize (JNICALL *GetStringLength)
+      (JNIEnv *env, jstring str);
+    const jchar *(JNICALL *GetStringChars)
+      (JNIEnv *env, jstring str, jboolean *isCopy);
+    void (JNICALL *ReleaseStringChars)
+      (JNIEnv *env, jstring str, const jchar *chars);
+  
+    jstring (JNICALL *NewStringUTF)
+      (JNIEnv *env, const char *utf);
+    jsize (JNICALL *GetStringUTFLength)
+      (JNIEnv *env, jstring str);
+    const char* (JNICALL *GetStringUTFChars)
+      (JNIEnv *env, jstring str, jboolean *isCopy);
+    void (JNICALL *ReleaseStringUTFChars)
+      (JNIEnv *env, jstring str, const char* chars);
+  
+
+    jsize (JNICALL *GetArrayLength)
+      (JNIEnv *env, jarray array);
+
+    jobjectArray (JNICALL *NewObjectArray)
+      (JNIEnv *env, jsize len, jclass clazz, jobject init);
+    jobject (JNICALL *GetObjectArrayElement)
+      (JNIEnv *env, jobjectArray array, jsize index);
+    void (JNICALL *SetObjectArrayElement)
+      (JNIEnv *env, jobjectArray array, jsize index, jobject val);
+
+    jbooleanArray (JNICALL *NewBooleanArray)
+      (JNIEnv *env, jsize len);
+    jbyteArray (JNICALL *NewByteArray)
+      (JNIEnv *env, jsize len);
+    jcharArray (JNICALL *NewCharArray)
+      (JNIEnv *env, jsize len);
+    jshortArray (JNICALL *NewShortArray)
+      (JNIEnv *env, jsize len);
+    jintArray (JNICALL *NewIntArray)
+      (JNIEnv *env, jsize len);
+    jlongArray (JNICALL *NewLongArray)
+      (JNIEnv *env, jsize len);
+    jfloatArray (JNICALL *NewFloatArray)
+      (JNIEnv *env, jsize len);
+    jdoubleArray (JNICALL *NewDoubleArray)
+      (JNIEnv *env, jsize len);
+
+    jboolean * (JNICALL *GetBooleanArrayElements)
+      (JNIEnv *env, jbooleanArray array, jboolean *isCopy);
+    jbyte * (JNICALL *GetByteArrayElements)
+      (JNIEnv *env, jbyteArray array, jboolean *isCopy);
+    jchar * (JNICALL *GetCharArrayElements)
+      (JNIEnv *env, jcharArray array, jboolean *isCopy);
+    jshort * (JNICALL *GetShortArrayElements)
+      (JNIEnv *env, jshortArray array, jboolean *isCopy);
+    jint * (JNICALL *GetIntArrayElements)
+      (JNIEnv *env, jintArray array, jboolean *isCopy);
+    jlong * (JNICALL *GetLongArrayElements)
+      (JNIEnv *env, jlongArray array, jboolean *isCopy);
+    jfloat * (JNICALL *GetFloatArrayElements)
+      (JNIEnv *env, jfloatArray array, jboolean *isCopy);
+    jdouble * (JNICALL *GetDoubleArrayElements)
+      (JNIEnv *env, jdoubleArray array, jboolean *isCopy);
+
+    void (JNICALL *ReleaseBooleanArrayElements)
+      (JNIEnv *env, jbooleanArray array, jboolean *elems, jint mode);
+    void (JNICALL *ReleaseByteArrayElements)
+      (JNIEnv *env, jbyteArray array, jbyte *elems, jint mode);
+    void (JNICALL *ReleaseCharArrayElements)
+      (JNIEnv *env, jcharArray array, jchar *elems, jint mode);
+    void (JNICALL *ReleaseShortArrayElements)
+      (JNIEnv *env, jshortArray array, jshort *elems, jint mode);
+    void (JNICALL *ReleaseIntArrayElements)
+      (JNIEnv *env, jintArray array, jint *elems, jint mode);
+    void (JNICALL *ReleaseLongArrayElements)
+      (JNIEnv *env, jlongArray array, jlong *elems, jint mode);
+    void (JNICALL *ReleaseFloatArrayElements)
+      (JNIEnv *env, jfloatArray array, jfloat *elems, jint mode);
+    void (JNICALL *ReleaseDoubleArrayElements)
+      (JNIEnv *env, jdoubleArray array, jdouble *elems, jint mode);
+
+    void (JNICALL *GetBooleanArrayRegion)
+      (JNIEnv *env, jbooleanArray array, jsize start, jsize l, jboolean *buf);
+    void (JNICALL *GetByteArrayRegion)
+      (JNIEnv *env, jbyteArray array, jsize start, jsize len, jbyte *buf);
+    void (JNICALL *GetCharArrayRegion)
+      (JNIEnv *env, jcharArray array, jsize start, jsize len, jchar *buf);
+    void (JNICALL *GetShortArrayRegion)
+      (JNIEnv *env, jshortArray array, jsize start, jsize len, jshort *buf);
+    void (JNICALL *GetIntArrayRegion)
+      (JNIEnv *env, jintArray array, jsize start, jsize len, jint *buf);
+    void (JNICALL *GetLongArrayRegion)
+      (JNIEnv *env, jlongArray array, jsize start, jsize len, jlong *buf);
+    void (JNICALL *GetFloatArrayRegion)
+      (JNIEnv *env, jfloatArray array, jsize start, jsize len, jfloat *buf);
+    void (JNICALL *GetDoubleArrayRegion)
+      (JNIEnv *env, jdoubleArray array, jsize start, jsize len, jdouble *buf);
+
+    void (JNICALL *SetBooleanArrayRegion)
+      (JNIEnv *env, jbooleanArray array, jsize start, jsize l, jboolean *buf);
+    void (JNICALL *SetByteArrayRegion)
+      (JNIEnv *env, jbyteArray array, jsize start, jsize len, jbyte *buf);
+    void (JNICALL *SetCharArrayRegion)
+      (JNIEnv *env, jcharArray array, jsize start, jsize len, jchar *buf);
+    void (JNICALL *SetShortArrayRegion)
+      (JNIEnv *env, jshortArray array, jsize start, jsize len, jshort *buf);
+    void (JNICALL *SetIntArrayRegion)
+      (JNIEnv *env, jintArray array, jsize start, jsize len, jint *buf);
+    void (JNICALL *SetLongArrayRegion)
+      (JNIEnv *env, jlongArray array, jsize start, jsize len, jlong *buf);
+    void (JNICALL *SetFloatArrayRegion)
+      (JNIEnv *env, jfloatArray array, jsize start, jsize len, jfloat *buf);
+    void (JNICALL *SetDoubleArrayRegion)
+      (JNIEnv *env, jdoubleArray array, jsize start, jsize len, jdouble *buf);
+
+    jint (JNICALL *RegisterNatives)
+      (JNIEnv *env, jclass clazz, const JNINativeMethod *methods, 
+       jint nMethods);
+    jint (JNICALL *UnregisterNatives)
+      (JNIEnv *env, jclass clazz);
+
+    jint (JNICALL *MonitorEnter)
+      (JNIEnv *env, jobject obj);
+    jint (JNICALL *MonitorExit)
+      (JNIEnv *env, jobject obj);
+ 
+    jint (JNICALL *GetJavaVM)
+      (JNIEnv *env, JavaVM **vm);
+};
+
+/*
+ * We use inlined functions for C++ so that programmers can write:
+ * 
+ *    env->FindClass("java/lang/String")
+ *
+ * in C++ rather than:
+ *
+ *    (*env)->FindClass(env, "java/lang/String")
+ *
+ * in C.
+ */
+
+struct JNIEnv_ {
+    const struct JNINativeInterface_ *functions;
+    void *reserved0;
+    void *reserved1[6];
+#ifdef __cplusplus
+
+    jint GetVersion() {
+        return functions->GetVersion(this);
+    }
+    jclass DefineClass(const char *name, jobject loader, const jbyte *buf,
+		       jsize len) {
+        return functions->DefineClass(this, name, loader, buf, len);
+    }
+    jclass FindClass(const char *name) {
+        return functions->FindClass(this, name);
+    }
+    jclass GetSuperclass(jclass sub) {
+        return functions->GetSuperclass(this, sub);
+    }
+    jboolean IsAssignableFrom(jclass sub, jclass sup) {
+        return functions->IsAssignableFrom(this, sub, sup);
+    }
+
+    jint Throw(jthrowable obj) {
+        return functions->Throw(this, obj);
+    }    
+    jint ThrowNew(jclass clazz, const char *msg) {
+        return functions->ThrowNew(this, clazz, msg);
+    }
+    jthrowable ExceptionOccurred() {
+        return functions->ExceptionOccurred(this);
+    }
+    void ExceptionDescribe() {
+        functions->ExceptionDescribe(this);
+    }
+    void ExceptionClear() {
+        functions->ExceptionClear(this);
+    }
+    void FatalError(const char *msg) {
+        functions->FatalError(this, msg);
+    }
+
+    jobject NewGlobalRef(jobject lobj) {
+        return functions->NewGlobalRef(this,lobj);
+    }
+    void DeleteGlobalRef(jobject gref) {
+        functions->DeleteGlobalRef(this,gref);
+    }
+    void DeleteLocalRef(jobject obj) {
+        functions->DeleteLocalRef(this, obj);
+    }
+
+    jboolean IsSameObject(jobject obj1, jobject obj2) {
+        return functions->IsSameObject(this,obj1,obj2);
+    }
+
+    jobject AllocObject(jclass clazz) {
+        return functions->AllocObject(this,clazz);
+    }
+    jobject NewObject(jclass clazz, jmethodID methodID, ...) {
+        va_list args;
+	jobject result;
+	va_start(args, methodID);
+        result = functions->NewObjectV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jobject NewObjectV(jclass clazz, jmethodID methodID, 
+		       va_list args) {
+        return functions->NewObjectV(this,clazz,methodID,args);
+    }
+    jobject NewObjectA(jclass clazz, jmethodID methodID, 
+		       jvalue *args) {
+        return functions->NewObjectA(this,clazz,methodID,args);
+    }
+
+    jclass GetObjectClass(jobject obj) {
+        return functions->GetObjectClass(this,obj);
+    }
+    jboolean IsInstanceOf(jobject obj, jclass clazz) {
+        return functions->IsInstanceOf(this,obj,clazz);
+    }
+
+    jmethodID GetMethodID(jclass clazz, const char *name, 
+			  const char *sig) {
+        return functions->GetMethodID(this,clazz,name,sig);
+    }
+
+    jobject CallObjectMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jobject result;
+	va_start(args,methodID);
+	result = functions->CallObjectMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jobject CallObjectMethodV(jobject obj, jmethodID methodID, 
+			va_list args) {
+        return functions->CallObjectMethodV(this,obj,methodID,args);
+    }
+    jobject CallObjectMethodA(jobject obj, jmethodID methodID, 
+			jvalue * args) {
+        return functions->CallObjectMethodA(this,obj,methodID,args);
+    }
+
+    jboolean CallBooleanMethod(jobject obj, 
+			       jmethodID methodID, ...) {
+        va_list args;
+	jboolean result;
+	va_start(args,methodID);
+	result = functions->CallBooleanMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jboolean CallBooleanMethodV(jobject obj, jmethodID methodID, 
+				va_list args) {
+        return functions->CallBooleanMethodV(this,obj,methodID,args);
+    }
+    jboolean CallBooleanMethodA(jobject obj, jmethodID methodID, 
+				jvalue * args) {
+        return functions->CallBooleanMethodA(this,obj,methodID, args);
+    }
+
+    jbyte CallByteMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jbyte result;
+	va_start(args,methodID);
+	result = functions->CallByteMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jbyte CallByteMethodV(jobject obj, jmethodID methodID, 
+			  va_list args) {
+        return functions->CallByteMethodV(this,obj,methodID,args);
+    }
+    jbyte CallByteMethodA(jobject obj, jmethodID methodID, 
+			  jvalue * args) {
+        return functions->CallByteMethodA(this,obj,methodID,args);
+    }
+
+    jchar CallCharMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jchar result;
+	va_start(args,methodID);
+	result = functions->CallCharMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jchar CallCharMethodV(jobject obj, jmethodID methodID, 
+			  va_list args) {
+        return functions->CallCharMethodV(this,obj,methodID,args);
+    }
+    jchar CallCharMethodA(jobject obj, jmethodID methodID, 
+			  jvalue * args) {
+        return functions->CallCharMethodA(this,obj,methodID,args);
+    }
+
+    jshort CallShortMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jshort result;
+	va_start(args,methodID);
+	result = functions->CallShortMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jshort CallShortMethodV(jobject obj, jmethodID methodID, 
+			    va_list args) {
+        return functions->CallShortMethodV(this,obj,methodID,args);
+    }
+    jshort CallShortMethodA(jobject obj, jmethodID methodID, 
+			    jvalue * args) {
+        return functions->CallShortMethodA(this,obj,methodID,args);
+    }
+
+    jint CallIntMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jint result;
+	va_start(args,methodID);
+	result = functions->CallIntMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jint CallIntMethodV(jobject obj, jmethodID methodID, 
+			va_list args) {
+        return functions->CallIntMethodV(this,obj,methodID,args);
+    }
+    jint CallIntMethodA(jobject obj, jmethodID methodID, 
+			jvalue * args) {
+        return functions->CallIntMethodA(this,obj,methodID,args);
+    }
+
+    jlong CallLongMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jlong result;
+	va_start(args,methodID);
+	result = functions->CallLongMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jlong CallLongMethodV(jobject obj, jmethodID methodID, 
+			  va_list args) {
+        return functions->CallLongMethodV(this,obj,methodID,args);
+    }
+    jlong CallLongMethodA(jobject obj, jmethodID methodID, 
+			  jvalue * args) {
+        return functions->CallLongMethodA(this,obj,methodID,args);
+    }
+
+    jfloat CallFloatMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jfloat result;
+	va_start(args,methodID);
+	result = functions->CallFloatMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jfloat CallFloatMethodV(jobject obj, jmethodID methodID, 
+			    va_list args) {
+        return functions->CallFloatMethodV(this,obj,methodID,args);
+    }
+    jfloat CallFloatMethodA(jobject obj, jmethodID methodID, 
+			    jvalue * args) {
+        return functions->CallFloatMethodA(this,obj,methodID,args);
+    }
+
+    jdouble CallDoubleMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jdouble result;
+	va_start(args,methodID);
+	result = functions->CallDoubleMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jdouble CallDoubleMethodV(jobject obj, jmethodID methodID, 
+			va_list args) {
+        return functions->CallDoubleMethodV(this,obj,methodID,args);
+    }
+    jdouble CallDoubleMethodA(jobject obj, jmethodID methodID, 
+			jvalue * args) {
+        return functions->CallDoubleMethodA(this,obj,methodID,args);
+    }
+
+    void CallVoidMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	va_start(args,methodID);
+	functions->CallVoidMethodV(this,obj,methodID,args);
+	va_end(args);
+    }
+    void CallVoidMethodV(jobject obj, jmethodID methodID, 
+			 va_list args) {
+        functions->CallVoidMethodV(this,obj,methodID,args);
+    }
+    void CallVoidMethodA(jobject obj, jmethodID methodID, 
+			 jvalue * args) {
+        functions->CallVoidMethodA(this,obj,methodID,args);
+    }
+
+    jobject CallNonvirtualObjectMethod(jobject obj, jclass clazz, 
+				       jmethodID methodID, ...) {
+        va_list args;
+	jobject result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualObjectMethodV(this,obj,clazz,
+							methodID,args);
+	va_end(args);
+	return result;
+    }
+    jobject CallNonvirtualObjectMethodV(jobject obj, jclass clazz, 
+					jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualObjectMethodV(this,obj,clazz,
+						      methodID,args);
+    }
+    jobject CallNonvirtualObjectMethodA(jobject obj, jclass clazz, 
+					jmethodID methodID, jvalue * args) {
+        return functions->CallNonvirtualObjectMethodA(this,obj,clazz,
+						      methodID,args);
+    }
+
+    jboolean CallNonvirtualBooleanMethod(jobject obj, jclass clazz, 
+					 jmethodID methodID, ...) {
+        va_list args;
+	jboolean result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualBooleanMethodV(this,obj,clazz,
+							 methodID,args);
+	va_end(args);
+	return result;
+    }
+    jboolean CallNonvirtualBooleanMethodV(jobject obj, jclass clazz, 
+					  jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualBooleanMethodV(this,obj,clazz,
+						       methodID,args);
+    }
+    jboolean CallNonvirtualBooleanMethodA(jobject obj, jclass clazz, 
+					  jmethodID methodID, jvalue * args) {
+        return functions->CallNonvirtualBooleanMethodA(this,obj,clazz,
+						       methodID, args);
+    }
+
+    jbyte CallNonvirtualByteMethod(jobject obj, jclass clazz, 
+				   jmethodID methodID, ...) {
+        va_list args;
+	jbyte result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualByteMethodV(this,obj,clazz,
+						      methodID,args);
+	va_end(args);
+	return result;
+    }
+    jbyte CallNonvirtualByteMethodV(jobject obj, jclass clazz, 
+				    jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualByteMethodV(this,obj,clazz,
+						    methodID,args);
+    }
+    jbyte CallNonvirtualByteMethodA(jobject obj, jclass clazz, 
+				    jmethodID methodID, jvalue * args) {
+        return functions->CallNonvirtualByteMethodA(this,obj,clazz,
+						    methodID,args);
+    }
+
+    jchar CallNonvirtualCharMethod(jobject obj, jclass clazz, 
+				   jmethodID methodID, ...) {
+        va_list args;
+	jchar result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualCharMethodV(this,obj,clazz,
+						      methodID,args);
+	va_end(args);
+	return result;
+    }
+    jchar CallNonvirtualCharMethodV(jobject obj, jclass clazz, 
+				    jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualCharMethodV(this,obj,clazz,
+						    methodID,args);
+    }
+    jchar CallNonvirtualCharMethodA(jobject obj, jclass clazz, 
+				    jmethodID methodID, jvalue * args) {
+        return functions->CallNonvirtualCharMethodA(this,obj,clazz,
+						    methodID,args);
+    }
+
+    jshort CallNonvirtualShortMethod(jobject obj, jclass clazz, 
+				     jmethodID methodID, ...) {
+        va_list args;
+	jshort result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualShortMethodV(this,obj,clazz,
+						       methodID,args);
+	va_end(args);
+	return result;
+    }
+    jshort CallNonvirtualShortMethodV(jobject obj, jclass clazz, 
+				      jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualShortMethodV(this,obj,clazz,
+						     methodID,args);
+    }
+    jshort CallNonvirtualShortMethodA(jobject obj, jclass clazz,
+				      jmethodID methodID, jvalue * args) {
+        return functions->CallNonvirtualShortMethodA(this,obj,clazz,
+						     methodID,args);
+    }
+
+    jint CallNonvirtualIntMethod(jobject obj, jclass clazz, 
+				 jmethodID methodID, ...) {
+        va_list args;
+	jint result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualIntMethodV(this,obj,clazz,
+						     methodID,args);
+	va_end(args);
+	return result;
+    }
+    jint CallNonvirtualIntMethodV(jobject obj, jclass clazz, 
+				  jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualIntMethodV(this,obj,clazz,
+						   methodID,args);
+    }
+    jint CallNonvirtualIntMethodA(jobject obj, jclass clazz, 
+				  jmethodID methodID, jvalue * args) {
+        return functions->CallNonvirtualIntMethodA(this,obj,clazz,
+						   methodID,args);
+    }
+
+    jlong CallNonvirtualLongMethod(jobject obj, jclass clazz,
+				   jmethodID methodID, ...) {
+        va_list args;
+	jlong result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualLongMethodV(this,obj,clazz,
+						      methodID,args);
+	va_end(args);
+	return result;
+    }
+    jlong CallNonvirtualLongMethodV(jobject obj, jclass clazz,
+				    jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualLongMethodV(this,obj,clazz,
+						    methodID,args);
+    }
+    jlong CallNonvirtualLongMethodA(jobject obj, jclass clazz, 
+				    jmethodID methodID, jvalue * args) {
+        return functions->CallNonvirtualLongMethodA(this,obj,clazz,
+						    methodID,args);
+    }
+
+    jfloat CallNonvirtualFloatMethod(jobject obj, jclass clazz, 
+				     jmethodID methodID, ...) {
+        va_list args;
+	jfloat result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualFloatMethodV(this,obj,clazz,
+						       methodID,args);
+	va_end(args);
+	return result;
+    }
+    jfloat CallNonvirtualFloatMethodV(jobject obj, jclass clazz,
+				      jmethodID methodID, 
+				      va_list args) {
+        return functions->CallNonvirtualFloatMethodV(this,obj,clazz,
+						     methodID,args);
+    }
+    jfloat CallNonvirtualFloatMethodA(jobject obj, jclass clazz, 
+				      jmethodID methodID, 
+				      jvalue * args) {
+        return functions->CallNonvirtualFloatMethodA(this,obj,clazz,
+						     methodID,args);
+    }
+
+    jdouble CallNonvirtualDoubleMethod(jobject obj, jclass clazz,
+				       jmethodID methodID, ...) {
+        va_list args;
+	jdouble result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualDoubleMethodV(this,obj,clazz,
+							methodID,args);
+	va_end(args);
+	return result;
+    }
+    jdouble CallNonvirtualDoubleMethodV(jobject obj, jclass clazz,
+					jmethodID methodID, 
+					va_list args) {
+        return functions->CallNonvirtualDoubleMethodV(this,obj,clazz,
+						      methodID,args);
+    }
+    jdouble CallNonvirtualDoubleMethodA(jobject obj, jclass clazz, 
+					jmethodID methodID, 
+					jvalue * args) {
+        return functions->CallNonvirtualDoubleMethodA(this,obj,clazz,
+						      methodID,args);
+    }
+
+    void CallNonvirtualVoidMethod(jobject obj, jclass clazz,
+				  jmethodID methodID, ...) {
+        va_list args;
+	va_start(args,methodID);
+	functions->CallNonvirtualVoidMethodV(this,obj,clazz,methodID,args);
+	va_end(args);
+    }
+    void CallNonvirtualVoidMethodV(jobject obj, jclass clazz,
+				   jmethodID methodID, 
+				   va_list args) {
+        functions->CallNonvirtualVoidMethodV(this,obj,clazz,methodID,args);
+    }
+    void CallNonvirtualVoidMethodA(jobject obj, jclass clazz,
+				   jmethodID methodID, 
+				   jvalue * args) {
+        functions->CallNonvirtualVoidMethodA(this,obj,clazz,methodID,args);
+    }
+
+    jfieldID GetFieldID(jclass clazz, const char *name, 
+			const char *sig) {
+        return functions->GetFieldID(this,clazz,name,sig);
+    }
+
+    jobject GetObjectField(jobject obj, jfieldID fieldID) {
+        return functions->GetObjectField(this,obj,fieldID);
+    }
+    jboolean GetBooleanField(jobject obj, jfieldID fieldID) {
+        return functions->GetBooleanField(this,obj,fieldID);
+    }
+    jbyte GetByteField(jobject obj, jfieldID fieldID) {
+        return functions->GetByteField(this,obj,fieldID);
+    }
+    jchar GetCharField(jobject obj, jfieldID fieldID) {
+        return functions->GetCharField(this,obj,fieldID);
+    }
+    jshort GetShortField(jobject obj, jfieldID fieldID) {
+        return functions->GetShortField(this,obj,fieldID);
+    }
+    jint GetIntField(jobject obj, jfieldID fieldID) {
+        return functions->GetIntField(this,obj,fieldID);
+    }
+    jlong GetLongField(jobject obj, jfieldID fieldID) {
+        return functions->GetLongField(this,obj,fieldID);
+    }
+    jfloat GetFloatField(jobject obj, jfieldID fieldID) {
+        return functions->GetFloatField(this,obj,fieldID);
+    }
+    jdouble GetDoubleField(jobject obj, jfieldID fieldID) {
+        return functions->GetDoubleField(this,obj,fieldID);
+    }
+
+    void SetObjectField(jobject obj, jfieldID fieldID, jobject val) {
+        functions->SetObjectField(this,obj,fieldID,val);
+    }
+    void SetBooleanField(jobject obj, jfieldID fieldID, 
+			 jboolean val) {
+        functions->SetBooleanField(this,obj,fieldID,val);
+    }
+    void SetByteField(jobject obj, jfieldID fieldID, 
+		      jbyte val) {
+        functions->SetByteField(this,obj,fieldID,val);
+    }
+    void SetCharField(jobject obj, jfieldID fieldID, 
+		      jchar val) {
+        functions->SetCharField(this,obj,fieldID,val);
+    }
+    void SetShortField(jobject obj, jfieldID fieldID,
+		       jshort val) {
+        functions->SetShortField(this,obj,fieldID,val);
+    }
+    void SetIntField(jobject obj, jfieldID fieldID, 
+		     jint val) {
+        functions->SetIntField(this,obj,fieldID,val);
+    }
+    void SetLongField(jobject obj, jfieldID fieldID, 
+		      jlong val) {
+        functions->SetLongField(this,obj,fieldID,val);
+    }
+    void SetFloatField(jobject obj, jfieldID fieldID, 
+		       jfloat val) {
+        functions->SetFloatField(this,obj,fieldID,val);
+    }
+    void SetDoubleField(jobject obj, jfieldID fieldID, 
+			jdouble val) {
+        functions->SetDoubleField(this,obj,fieldID,val);
+    }
+
+    jmethodID GetStaticMethodID(jclass clazz, const char *name, 
+				const char *sig) {
+        return functions->GetStaticMethodID(this,clazz,name,sig);
+    }
+
+    jobject CallStaticObjectMethod(jclass clazz, jmethodID methodID, 
+			     ...) {
+        va_list args;
+	jobject result;
+	va_start(args,methodID);
+	result = functions->CallStaticObjectMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jobject CallStaticObjectMethodV(jclass clazz, jmethodID methodID, 
+			      va_list args) {
+        return functions->CallStaticObjectMethodV(this,clazz,methodID,args);
+    }
+    jobject CallStaticObjectMethodA(jclass clazz, jmethodID methodID, 
+			      jvalue *args) {
+        return functions->CallStaticObjectMethodA(this,clazz,methodID,args);
+    }
+
+    jboolean CallStaticBooleanMethod(jclass clazz, 
+				     jmethodID methodID, ...) {
+        va_list args;
+	jboolean result;
+	va_start(args,methodID);
+	result = functions->CallStaticBooleanMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jboolean CallStaticBooleanMethodV(jclass clazz,
+				      jmethodID methodID, va_list args) {
+        return functions->CallStaticBooleanMethodV(this,clazz,methodID,args);
+    }
+    jboolean CallStaticBooleanMethodA(jclass clazz,
+				      jmethodID methodID, jvalue *args) {
+        return functions->CallStaticBooleanMethodA(this,clazz,methodID,args);
+    }
+
+    jbyte CallStaticByteMethod(jclass clazz,
+			       jmethodID methodID, ...) {
+        va_list args;
+	jbyte result;
+	va_start(args,methodID);
+	result = functions->CallStaticByteMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jbyte CallStaticByteMethodV(jclass clazz,
+				jmethodID methodID, va_list args) {
+        return functions->CallStaticByteMethodV(this,clazz,methodID,args);
+    }
+    jbyte CallStaticByteMethodA(jclass clazz, 
+				jmethodID methodID, jvalue *args) {
+        return functions->CallStaticByteMethodA(this,clazz,methodID,args);
+    }
+
+    jchar CallStaticCharMethod(jclass clazz,
+			       jmethodID methodID, ...) {
+        va_list args;
+	jchar result;
+	va_start(args,methodID);
+	result = functions->CallStaticCharMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jchar CallStaticCharMethodV(jclass clazz,
+				jmethodID methodID, va_list args) {
+        return functions->CallStaticCharMethodV(this,clazz,methodID,args);
+    }
+    jchar CallStaticCharMethodA(jclass clazz,
+				jmethodID methodID, jvalue *args) {
+        return functions->CallStaticCharMethodA(this,clazz,methodID,args);
+    }
+
+    jshort CallStaticShortMethod(jclass clazz,
+				 jmethodID methodID, ...) {
+        va_list args;
+	jshort result;
+	va_start(args,methodID);
+	result = functions->CallStaticShortMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jshort CallStaticShortMethodV(jclass clazz,
+				  jmethodID methodID, va_list args) {
+        return functions->CallStaticShortMethodV(this,clazz,methodID,args);
+    }
+    jshort CallStaticShortMethodA(jclass clazz,
+				  jmethodID methodID, jvalue *args) {
+        return functions->CallStaticShortMethodA(this,clazz,methodID,args);
+    }
+
+    jint CallStaticIntMethod(jclass clazz,
+			     jmethodID methodID, ...) {
+        va_list args;
+	jint result;
+	va_start(args,methodID);
+	result = functions->CallStaticIntMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jint CallStaticIntMethodV(jclass clazz,
+			      jmethodID methodID, va_list args) {
+        return functions->CallStaticIntMethodV(this,clazz,methodID,args);
+    }
+    jint CallStaticIntMethodA(jclass clazz, 
+			      jmethodID methodID, jvalue *args) {
+        return functions->CallStaticIntMethodA(this,clazz,methodID,args);
+    }
+
+    jlong CallStaticLongMethod(jclass clazz,
+			       jmethodID methodID, ...) {
+        va_list args;
+	jlong result;
+	va_start(args,methodID);
+	result = functions->CallStaticLongMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jlong CallStaticLongMethodV(jclass clazz, 
+				jmethodID methodID, va_list args) {
+        return functions->CallStaticLongMethodV(this,clazz,methodID,args);
+    }
+    jlong CallStaticLongMethodA(jclass clazz, 
+				jmethodID methodID, jvalue *args) {
+        return functions->CallStaticLongMethodA(this,clazz,methodID,args);
+    }
+
+    jfloat CallStaticFloatMethod(jclass clazz, 
+				 jmethodID methodID, ...) {
+        va_list args;
+	jfloat result;
+	va_start(args,methodID);
+	result = functions->CallStaticFloatMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jfloat CallStaticFloatMethodV(jclass clazz, 
+				  jmethodID methodID, va_list args) {
+        return functions->CallStaticFloatMethodV(this,clazz,methodID,args);
+    }
+    jfloat CallStaticFloatMethodA(jclass clazz, 
+				  jmethodID methodID, jvalue *args) {
+        return functions->CallStaticFloatMethodA(this,clazz,methodID,args);
+    }
+
+    jdouble CallStaticDoubleMethod(jclass clazz, 
+				   jmethodID methodID, ...) {
+        va_list args;
+	jdouble result;
+	va_start(args,methodID);
+	result = functions->CallStaticDoubleMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jdouble CallStaticDoubleMethodV(jclass clazz, 
+				    jmethodID methodID, va_list args) {
+        return functions->CallStaticDoubleMethodV(this,clazz,methodID,args);
+    }
+    jdouble CallStaticDoubleMethodA(jclass clazz, 
+				    jmethodID methodID, jvalue *args) {
+        return functions->CallStaticDoubleMethodA(this,clazz,methodID,args);
+    }
+
+    void CallStaticVoidMethod(jclass cls, jmethodID methodID, ...) {
+        va_list args;
+	va_start(args,methodID);
+	functions->CallStaticVoidMethodV(this,cls,methodID,args);
+	va_end(args);
+    }
+    void CallStaticVoidMethodV(jclass cls, jmethodID methodID, 
+			       va_list args) {
+        functions->CallStaticVoidMethodV(this,cls,methodID,args);
+    }
+    void CallStaticVoidMethodA(jclass cls, jmethodID methodID, 
+			       jvalue * args) {
+        functions->CallStaticVoidMethodA(this,cls,methodID,args);
+    }
+
+    jfieldID GetStaticFieldID(jclass clazz, const char *name, 
+			      const char *sig) {
+        return functions->GetStaticFieldID(this,clazz,name,sig);
+    }
+    jobject GetStaticObjectField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticObjectField(this,clazz,fieldID);
+    }
+    jboolean GetStaticBooleanField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticBooleanField(this,clazz,fieldID);
+    }
+    jbyte GetStaticByteField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticByteField(this,clazz,fieldID);
+    }
+    jchar GetStaticCharField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticCharField(this,clazz,fieldID);
+    }
+    jshort GetStaticShortField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticShortField(this,clazz,fieldID);
+    }
+    jint GetStaticIntField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticIntField(this,clazz,fieldID);
+    }
+    jlong GetStaticLongField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticLongField(this,clazz,fieldID);
+    }
+    jfloat GetStaticFloatField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticFloatField(this,clazz,fieldID);
+    }
+    jdouble GetStaticDoubleField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticDoubleField(this,clazz,fieldID);
+    }
+
+    void SetStaticObjectField(jclass clazz, jfieldID fieldID,
+			jobject value) {
+      functions->SetStaticObjectField(this,clazz,fieldID,value);
+    }
+    void SetStaticBooleanField(jclass clazz, jfieldID fieldID,
+			jboolean value) {
+      functions->SetStaticBooleanField(this,clazz,fieldID,value);
+    }
+    void SetStaticByteField(jclass clazz, jfieldID fieldID,
+			jbyte value) {
+      functions->SetStaticByteField(this,clazz,fieldID,value);
+    }
+    void SetStaticCharField(jclass clazz, jfieldID fieldID,
+			jchar value) {
+      functions->SetStaticCharField(this,clazz,fieldID,value);
+    }
+    void SetStaticShortField(jclass clazz, jfieldID fieldID,
+			jshort value) {
+      functions->SetStaticShortField(this,clazz,fieldID,value);
+    }
+    void SetStaticIntField(jclass clazz, jfieldID fieldID,
+			jint value) {
+      functions->SetStaticIntField(this,clazz,fieldID,value);
+    }
+    void SetStaticLongField(jclass clazz, jfieldID fieldID,
+			jlong value) {
+      functions->SetStaticLongField(this,clazz,fieldID,value);
+    }
+    void SetStaticFloatField(jclass clazz, jfieldID fieldID,
+			jfloat value) {
+      functions->SetStaticFloatField(this,clazz,fieldID,value);
+    }
+    void SetStaticDoubleField(jclass clazz, jfieldID fieldID,
+			jdouble value) {
+      functions->SetStaticDoubleField(this,clazz,fieldID,value);
+    }
+
+    jstring NewString(const jchar *unicode, jsize len) {
+        return functions->NewString(this,unicode,len);
+    }
+    jsize GetStringLength(jstring str) {
+        return functions->GetStringLength(this,str);
+    }
+    const jchar *GetStringChars(jstring str, jboolean *isCopy) {
+        return functions->GetStringChars(this,str,isCopy);
+    }
+    void ReleaseStringChars(jstring str, const jchar *chars) {
+        functions->ReleaseStringChars(this,str,chars);
+    }
+  
+    jstring NewStringUTF(const char *utf) {
+        return functions->NewStringUTF(this,utf);
+    }
+    jsize GetStringUTFLength(jstring str) {
+        return functions->GetStringUTFLength(this,str);
+    }
+    const char* GetStringUTFChars(jstring str, jboolean *isCopy) {
+        return functions->GetStringUTFChars(this,str,isCopy);
+    }
+    void ReleaseStringUTFChars(jstring str, const char* chars) {
+        functions->ReleaseStringUTFChars(this,str,chars);
+    }
+
+    jsize GetArrayLength(jarray array) {
+        return functions->GetArrayLength(this,array);
+    }
+
+    jobjectArray NewObjectArray(jsize len, jclass clazz, 
+				jobject init) {
+        return functions->NewObjectArray(this,len,clazz,init);
+    }
+    jobject GetObjectArrayElement(jobjectArray array, jsize index) {
+        return functions->GetObjectArrayElement(this,array,index);
+    }
+    void SetObjectArrayElement(jobjectArray array, jsize index, 
+			       jobject val) {
+        functions->SetObjectArrayElement(this,array,index,val);
+    }
+
+    jbooleanArray NewBooleanArray(jsize len) {
+        return functions->NewBooleanArray(this,len);
+    }
+    jbyteArray NewByteArray(jsize len) {
+        return functions->NewByteArray(this,len);
+    }
+    jcharArray NewCharArray(jsize len) {
+        return functions->NewCharArray(this,len);
+    }
+    jshortArray NewShortArray(jsize len) {
+        return functions->NewShortArray(this,len);
+    }
+    jintArray NewIntArray(jsize len) {
+        return functions->NewIntArray(this,len);
+    }
+    jlongArray NewLongArray(jsize len) {
+        return functions->NewLongArray(this,len);
+    }
+    jfloatArray NewFloatArray(jsize len) {
+        return functions->NewFloatArray(this,len);
+    }
+    jdoubleArray NewDoubleArray(jsize len) {
+        return functions->NewDoubleArray(this,len);
+    }
+
+    jboolean * GetBooleanArrayElements(jbooleanArray array, jboolean *isCopy) {
+        return functions->GetBooleanArrayElements(this,array,isCopy);
+    }
+    jbyte * GetByteArrayElements(jbyteArray array, jboolean *isCopy) {
+        return functions->GetByteArrayElements(this,array,isCopy);
+    }
+    jchar * GetCharArrayElements(jcharArray array, jboolean *isCopy) {
+        return functions->GetCharArrayElements(this,array,isCopy);
+    }
+    jshort * GetShortArrayElements(jshortArray array, jboolean *isCopy) {
+        return functions->GetShortArrayElements(this,array,isCopy);
+    }
+    jint * GetIntArrayElements(jintArray array, jboolean *isCopy) {
+        return functions->GetIntArrayElements(this,array,isCopy);
+    }
+    jlong * GetLongArrayElements(jlongArray array, jboolean *isCopy) {
+        return functions->GetLongArrayElements(this,array,isCopy);
+    }
+    jfloat * GetFloatArrayElements(jfloatArray array, jboolean *isCopy) {
+        return functions->GetFloatArrayElements(this,array,isCopy);
+    }
+    jdouble * GetDoubleArrayElements(jdoubleArray array, jboolean *isCopy) {
+        return functions->GetDoubleArrayElements(this,array,isCopy);
+    }
+
+    void ReleaseBooleanArrayElements(jbooleanArray array, 
+				     jboolean *elems,
+				     jint mode) {
+        functions->ReleaseBooleanArrayElements(this,array,elems,mode);
+    }
+    void ReleaseByteArrayElements(jbyteArray array, 
+				  jbyte *elems,
+				  jint mode) {
+        functions->ReleaseByteArrayElements(this,array,elems,mode);
+    }
+    void ReleaseCharArrayElements(jcharArray array, 
+				  jchar *elems,
+				  jint mode) {
+        functions->ReleaseCharArrayElements(this,array,elems,mode);
+    }
+    void ReleaseShortArrayElements(jshortArray array, 
+				   jshort *elems,
+				   jint mode) {
+        functions->ReleaseShortArrayElements(this,array,elems,mode);
+    }
+    void ReleaseIntArrayElements(jintArray array, 
+				 jint *elems,
+				 jint mode) {
+        functions->ReleaseIntArrayElements(this,array,elems,mode);
+    }
+    void ReleaseLongArrayElements(jlongArray array, 
+				  jlong *elems,
+				  jint mode) {
+        functions->ReleaseLongArrayElements(this,array,elems,mode);
+    }
+    void ReleaseFloatArrayElements(jfloatArray array, 
+				   jfloat *elems,
+				   jint mode) {
+        functions->ReleaseFloatArrayElements(this,array,elems,mode);
+    }
+    void ReleaseDoubleArrayElements(jdoubleArray array, 
+				    jdouble *elems,
+				    jint mode) {
+        functions->ReleaseDoubleArrayElements(this,array,elems,mode);
+    }
+
+    void GetBooleanArrayRegion(jbooleanArray array, 
+			       jsize start, jsize len, jboolean *buf) {
+        functions->GetBooleanArrayRegion(this,array,start,len,buf);
+    }
+    void GetByteArrayRegion(jbyteArray array, 
+			    jsize start, jsize len, jbyte *buf) {
+        functions->GetByteArrayRegion(this,array,start,len,buf);
+    }
+    void GetCharArrayRegion(jcharArray array, 
+			    jsize start, jsize len, jchar *buf) {
+        functions->GetCharArrayRegion(this,array,start,len,buf);
+    }
+    void GetShortArrayRegion(jshortArray array, 
+			     jsize start, jsize len, jshort *buf) {
+        functions->GetShortArrayRegion(this,array,start,len,buf);
+    }
+    void GetIntArrayRegion(jintArray array, 
+			   jsize start, jsize len, jint *buf) {
+        functions->GetIntArrayRegion(this,array,start,len,buf);
+    }
+    void GetLongArrayRegion(jlongArray array, 
+			    jsize start, jsize len, jlong *buf) {
+        functions->GetLongArrayRegion(this,array,start,len,buf);
+    }
+    void GetFloatArrayRegion(jfloatArray array, 
+			     jsize start, jsize len, jfloat *buf) {
+        functions->GetFloatArrayRegion(this,array,start,len,buf);
+    }
+    void GetDoubleArrayRegion(jdoubleArray array, 
+			      jsize start, jsize len, jdouble *buf) {
+        functions->GetDoubleArrayRegion(this,array,start,len,buf);
+    }
+
+    void SetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len, 
+			       jboolean *buf) {
+        functions->SetBooleanArrayRegion(this,array,start,len,buf);
+    }
+    void SetByteArrayRegion(jbyteArray array, jsize start, jsize len,
+			    jbyte *buf) {
+        functions->SetByteArrayRegion(this,array,start,len,buf);
+    }
+    void SetCharArrayRegion(jcharArray array, jsize start, jsize len, 
+			    jchar *buf) {
+        functions->SetCharArrayRegion(this,array,start,len,buf);
+    }
+    void SetShortArrayRegion(jshortArray array, jsize start, jsize len, 
+			     jshort *buf) {
+        functions->SetShortArrayRegion(this,array,start,len,buf);
+    }
+    void SetIntArrayRegion(jintArray array, jsize start, jsize len,
+			   jint *buf) {
+        functions->SetIntArrayRegion(this,array,start,len,buf);
+    }
+    void SetLongArrayRegion(jlongArray array, jsize start, jsize len,
+			    jlong *buf) {
+        functions->SetLongArrayRegion(this,array,start,len,buf);
+    }
+    void SetFloatArrayRegion(jfloatArray array, jsize start, jsize len, 
+			     jfloat *buf) {
+        functions->SetFloatArrayRegion(this,array,start,len,buf);
+    }
+    void SetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len,
+			      jdouble *buf) {
+        functions->SetDoubleArrayRegion(this,array,start,len,buf);
+    }
+
+    jint RegisterNatives(jclass clazz, const JNINativeMethod *methods,
+			 jint nMethods) {
+        return functions->RegisterNatives(this,clazz,methods,nMethods);
+    }
+    jint UnregisterNatives(jclass clazz) {
+        return functions->UnregisterNatives(this,clazz);
+    }  
+   
+    jint MonitorEnter(jobject obj) {
+        return functions->MonitorEnter(this,obj);
+    }
+    jint MonitorExit(jobject obj) {
+        return functions->MonitorExit(this,obj);
+    }
+
+    jint GetJavaVM(JavaVM **vm) {
+        return functions->GetJavaVM(this,vm);
+    }
+  
+#endif /* __cplusplus */
+};
+
+/* These structures will be VM-specific. */
+
+typedef struct JDK1_1InitArgs {
+    jint version;
+
+    char **properties;
+    jint checkSource; 
+    jint nativeStackSize;
+    jint javaStackSize;
+    jint minHeapSize;
+    jint maxHeapSize;
+    jint verifyMode;
+    char *classpath;
+
+    jint (JNICALL *vfprintf)(FILE *fp, const char *format, va_list args);
+    void (JNICALL *exit)(jint code);
+    void (JNICALL *abort)();
+    
+    jint enableClassGC;
+    jint enableVerboseGC;
+    jint disableAsyncGC;
+    jint verbose;
+    jboolean debugging;
+    jint debugPort;
+} JDK1_1InitArgs;
+
+typedef struct JDK1_1AttachArgs {
+    void * __padding; /* C compilers don't allow empty structures. */
+} JDK1_1AttachArgs;
+
+/* End VM-specific. */
+
+struct JNIInvokeInterface_ {
+    void *reserved0;
+    void *reserved1;
+    void *reserved2;
+
+    jint (JNICALL *DestroyJavaVM)(JavaVM *vm);
+
+    jint (JNICALL *AttachCurrentThread)
+      (JavaVM *vm, JNIEnv **penv, void *args);
+
+    jint (JNICALL *DetachCurrentThread)(JavaVM *vm);
+};
+
+struct JavaVM_ {
+    const struct JNIInvokeInterface_ *functions;
+    void *reserved0;
+    void *reserved1;
+    void *reserved2;
+#ifdef __cplusplus
+
+    jint DestroyJavaVM() {
+        return functions->DestroyJavaVM(this);
+    }
+    jint AttachCurrentThread(JNIEnv **penv, void *args) {
+        return functions->AttachCurrentThread(this, penv, args);
+    }
+    jint DetachCurrentThread() {
+        return functions->DetachCurrentThread(this);
+    }
+
+#endif
+};
+
+JNI_PUBLIC_API(void) JNI_GetDefaultJavaVMInitArgs(void *);
+
+JNI_PUBLIC_API(jint) JNI_CreateJavaVM(JavaVM **, JNIEnv **, void *);
+
+JNI_PUBLIC_API(jint) JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *);
+JNI_PUBLIC_API(jref) JNI_MakeLocalRef(JNIEnv *pJNIEnv, void *pHObject);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif /* __cplusplus */
+
+#endif /* JNI_H */
+
+
diff -Nur mplayerplug-in-3.55-orig/include/jni_md.h mplayerplug-in-3.55/include/jni_md.h
--- mplayerplug-in-3.55-orig/include/jni_md.h	1970-01-01 07:00:00.000000000 +0700
+++ mplayerplug-in-3.55/include/jni_md.h	2007-08-04 02:59:37.000000000 +0700
@@ -0,0 +1,182 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * The contents of this file are subject to the Netscape Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/NPL/
+ *
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Netscape
+ * Communications Corporation.  Portions created by Netscape are
+ * Copyright (C) 1998 Netscape Communications Corporation. All
+ * Rights Reserved.
+ *
+ * Contributor(s): 
+ *
+ *
+ * This Original Code has been modified by IBM Corporation.
+ * Modifications made by IBM described herein are
+ * Copyright (c) International Business Machines
+ * Corporation, 2000
+ *
+ * Modifications to Mozilla code or documentation
+ * identified per MPL Section 3.3
+ *
+ * Date         Modified by     Description of modification
+ * 03/27/2000   IBM Corp.       Set JNICALL to Optlink for
+ *                               use in OS2
+ */
+
+/*******************************************************************************
+ * Netscape version of jni_md.h -- depends on jri_md.h
+ ******************************************************************************/
+
+#ifndef JNI_MD_H
+#define JNI_MD_H
+
+#include "prtypes.h" /* needed for _declspec */
+
+/*******************************************************************************
+ * WHAT'S UP WITH THIS FILE?
+ * 
+ * This is where we define the mystical JNI_PUBLIC_API macro that works on all
+ * platforms. If you're running with Visual C++, Symantec C, or Borland's 
+ * development environment on the PC, you're all set. Or if you're on the Mac
+ * with Metrowerks, Symantec or MPW with SC you're ok too. For UNIX it shouldn't
+ * matter.
+
+ * Changes by sailesh on 9/26 
+
+ * There are two symbols used in the declaration of the JNI functions
+ * and native code that uses the JNI:
+ * JNICALL - specifies the calling convention 
+ * JNIEXPORT - specifies export status of the function 
+ * 
+ * The syntax to specify calling conventions is different in Win16 and
+ * Win32 - the brains at Micro$oft at work here. JavaSoft in their
+ * infinite wisdom cares for no platform other than Win32, and so they
+ * just define these two symbols as:
+
+ #define JNIEXPORT __declspec(dllexport)
+ #define JNICALL __stdcall
+
+ * We deal with this, in the way JRI defines the JRI_PUBLIC_API, by
+ * defining a macro called JNI_PUBLIC_API. Any of our developers who
+ * wish to use code for Win16 and Win32, _must_ use JNI_PUBLIC_API to
+ * be able to export functions properly.
+
+ * Since we must also maintain compatibility with JavaSoft, we
+ * continue to define the symbol JNIEXPORT. However, use of this
+ * internally is deprecated, since it will cause a mess on Win16.
+
+ * We _do not_ need a new symbol called JNICALL. Instead we
+ * redefine JNICALL in the same way JRI_CALLBACK was defined.
+
+ ******************************************************************************/
+
+/* DLL Entry modifiers... */
+#if defined(XP_OS2)
+#  ifdef XP_OS2_VACPP
+#     define JNI_PUBLIC_API(ResultType)      ResultType _System
+#     define JNI_PUBLIC_VAR(VarType)         VarType
+#     define JNICALL                         _Optlink
+#     define JNIEXPORT
+#  else
+#     define JNI_PUBLIC_API(ResultType)	   ResultType
+#     define JNI_PUBLIC_VAR(VarType)         VarType
+#     define JNICALL
+#     define JNIEXPORT
+#  endif
+/* Win32 */
+#elif defined(XP_WIN) || defined(_WINDOWS) || defined(WIN32) || defined(_WIN32)
+#	include <windows.h>
+#	if defined(_MSC_VER) || defined(__GNUC__)
+#		if defined(WIN32) || defined(_WIN32)
+#			define JNI_PUBLIC_API(ResultType)	_declspec(dllexport) ResultType __stdcall
+#			define JNI_PUBLIC_VAR(VarType)		VarType
+#			define JNI_NATIVE_STUB(ResultType)	_declspec(dllexport) ResultType
+#			define JNICALL                          __stdcall
+#		else /* !_WIN32 */
+#		    if defined(_WINDLL)
+#			define JNI_PUBLIC_API(ResultType)	ResultType __cdecl __export __loadds 
+#			define JNI_PUBLIC_VAR(VarType)		VarType
+#			define JNI_NATIVE_STUB(ResultType)	ResultType __cdecl __loadds
+#			define JNICALL			        __loadds
+#		    else /* !WINDLL */
+#			define JNI_PUBLIC_API(ResultType)	ResultType __cdecl __export
+#			define JNI_PUBLIC_VAR(VarType)		VarType
+#			define JNI_NATIVE_STUB(ResultType)	ResultType __cdecl __export
+#			define JNICALL			        __export
+#                   endif /* !WINDLL */
+#		endif /* !_WIN32 */
+#	elif defined(__BORLANDC__)
+#		if defined(WIN32) || defined(_WIN32)
+#			define JNI_PUBLIC_API(ResultType)	__export ResultType
+#			define JNI_PUBLIC_VAR(VarType)		VarType
+#			define JNI_NATIVE_STUB(ResultType)	 __export ResultType
+#			define JNICALL
+#		else /* !_WIN32 */
+#			define JNI_PUBLIC_API(ResultType)	ResultType _cdecl _export _loadds 
+#			define JNI_PUBLIC_VAR(VarType)		VarType
+#			define JNI_NATIVE_STUB(ResultType)	ResultType _cdecl _loadds
+#			define JNICALL			_loadds
+#		endif
+#	else
+#		error Unsupported PC development environment.	
+#	endif
+#	ifndef IS_LITTLE_ENDIAN
+#		define IS_LITTLE_ENDIAN
+#	endif
+	/*  This is the stuff inherited from JavaSoft .. */
+#	define JNIEXPORT __declspec(dllexport)
+
+
+/* Mac */
+#elif macintosh || Macintosh || THINK_C
+#	if defined(__MWERKS__)				/* Metrowerks */
+#		if !__option(enumsalwaysint)
+#			error You need to define 'Enums Always Int' for your project.
+#		endif
+#		if defined(TARGET_CPU_68K) && !TARGET_RT_MAC_CFM 
+#			if !__option(fourbyteints) 
+#				error You need to define 'Struct Alignment: 68k' for your project.
+#			endif
+#		endif /* !GENERATINGCFM */
+#		define JNI_PUBLIC_API(ResultType)	__declspec(export) ResultType 
+#		define JNI_PUBLIC_VAR(VarType)		JNI_PUBLIC_API(VarType)
+#		define JNI_NATIVE_STUB(ResultType)	JNI_PUBLIC_API(ResultType)
+#	elif defined(__SC__)				/* Symantec */
+#		error What are the Symantec defines? (warren@netscape.com)
+#	elif macintosh && applec			/* MPW */
+#		error Please upgrade to the latest MPW compiler (SC).
+#	else
+#		error Unsupported Mac development environment.
+#	endif
+#	define JNICALL
+	/*  This is the stuff inherited from JavaSoft .. */
+#	define JNIEXPORT
+
+/* Unix or else */
+#else
+#	define JNI_PUBLIC_API(ResultType)		ResultType
+#       define JNI_PUBLIC_VAR(VarType)                  VarType
+#       define JNI_NATIVE_STUB(ResultType)              ResultType
+#	define JNICALL
+	/*  This is the stuff inherited from JavaSoft .. */
+#	define JNIEXPORT
+#endif
+
+#ifndef FAR		/* for non-Win16 */
+#define FAR
+#endif
+
+/* Get the rest of the stuff from jri_md.h */
+#include "jri_md.h"
+
+#endif /* JNI_MD_H */
diff -Nur mplayerplug-in-3.55-orig/include/jri.h mplayerplug-in-3.55/include/jri.h
--- mplayerplug-in-3.55-orig/include/jri.h	1970-01-01 07:00:00.000000000 +0700
+++ mplayerplug-in-3.55/include/jri.h	2007-08-04 02:59:37.000000000 +0700
@@ -0,0 +1,689 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: NPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Netscape Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/NPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is 
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or 
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the NPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the NPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*******************************************************************************
+ * Java Runtime Interface
+ ******************************************************************************/
+
+#ifndef JRI_H
+#define JRI_H
+
+#include "jritypes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/*******************************************************************************
+ * JRIEnv
+ ******************************************************************************/
+
+/* The type of the JRIEnv interface. */
+typedef struct JRIEnvInterface	JRIEnvInterface;
+
+/* The type of a JRIEnv instance. */
+typedef const JRIEnvInterface*	JRIEnv;
+
+/*******************************************************************************
+ * JRIEnv Operations
+ ******************************************************************************/
+
+#define JRI_DefineClass(env, classLoader, buf, bufLen)	\
+	(((*(env))->DefineClass)(env, JRI_DefineClass_op, classLoader, buf, bufLen))
+
+#define JRI_FindClass(env, name)	\
+	(((*(env))->FindClass)(env, JRI_FindClass_op, name))
+
+#define JRI_Throw(env, obj)	\
+	(((*(env))->Throw)(env, JRI_Throw_op, obj))
+
+#define JRI_ThrowNew(env, clazz, message)	\
+	(((*(env))->ThrowNew)(env, JRI_ThrowNew_op, clazz, message))
+
+#define JRI_ExceptionOccurred(env)	\
+	(((*(env))->ExceptionOccurred)(env, JRI_ExceptionOccurred_op))
+
+#define JRI_ExceptionDescribe(env)	\
+	(((*(env))->ExceptionDescribe)(env, JRI_ExceptionDescribe_op))
+
+#define JRI_ExceptionClear(env)	\
+	(((*(env))->ExceptionClear)(env, JRI_ExceptionClear_op))
+
+#define JRI_NewGlobalRef(env, ref)	\
+	(((*(env))->NewGlobalRef)(env, JRI_NewGlobalRef_op, ref))
+
+#define JRI_DisposeGlobalRef(env, gref)	\
+	(((*(env))->DisposeGlobalRef)(env, JRI_DisposeGlobalRef_op, gref))
+
+#define JRI_GetGlobalRef(env, gref)	\
+	(((*(env))->GetGlobalRef)(env, JRI_GetGlobalRef_op, gref))
+
+#define JRI_SetGlobalRef(env, gref, ref)	\
+	(((*(env))->SetGlobalRef)(env, JRI_SetGlobalRef_op, gref, ref))
+
+#define JRI_IsSameObject(env, a, b)	\
+	(((*(env))->IsSameObject)(env, JRI_IsSameObject_op, a, b))
+
+#define JRI_NewObject(env)	((*(env))->NewObject)
+#define JRI_NewObjectV(env, clazz, methodID, args)	\
+	(((*(env))->NewObjectV)(env, JRI_NewObject_op_va_list, clazz, methodID, args))
+#define JRI_NewObjectA(env, clazz, method, args)	\
+	(((*(env))->NewObjectA)(env, JRI_NewObject_op_array, clazz, methodID, args))
+
+#define JRI_GetObjectClass(env, obj)	\
+	(((*(env))->GetObjectClass)(env, JRI_GetObjectClass_op, obj))
+
+#define JRI_IsInstanceOf(env, obj, clazz)	\
+	(((*(env))->IsInstanceOf)(env, JRI_IsInstanceOf_op, obj, clazz))
+
+#define JRI_GetMethodID(env, clazz, name, sig)	\
+	(((*(env))->GetMethodID)(env, JRI_GetMethodID_op, clazz, name, sig))
+
+#define JRI_CallMethod(env)	((*(env))->CallMethod)
+#define JRI_CallMethodV(env, obj, methodID, args)	\
+	(((*(env))->CallMethodV)(env, JRI_CallMethod_op_va_list, obj, methodID, args))
+#define JRI_CallMethodA(env, obj, methodID, args)	\
+	(((*(env))->CallMethodA)(env, JRI_CallMethod_op_array, obj, methodID, args))
+
+#define JRI_CallMethodBoolean(env)	((*(env))->CallMethodBoolean)
+#define JRI_CallMethodBooleanV(env, obj, methodID, args)	\
+	(((*(env))->CallMethodBooleanV)(env, JRI_CallMethodBoolean_op_va_list, obj, methodID, args))
+#define JRI_CallMethodBooleanA(env, obj, methodID, args)	\
+	(((*(env))->CallMethodBooleanA)(env, JRI_CallMethodBoolean_op_array, obj, methodID, args))
+
+#define JRI_CallMethodByte(env)	((*(env))->CallMethodByte)
+#define JRI_CallMethodByteV(env, obj, methodID, args)	\
+	(((*(env))->CallMethodByteV)(env, JRI_CallMethodByte_op_va_list, obj, methodID, args))
+#define JRI_CallMethodByteA(env, obj, methodID, args)	\
+	(((*(env))->CallMethodByteA)(env, JRI_CallMethodByte_op_array, obj, methodID, args))
+
+#define JRI_CallMethodChar(env)	((*(env))->CallMethodChar)
+#define JRI_CallMethodCharV(env, obj, methodID, args)	\
+	(((*(env))->CallMethodCharV)(env, JRI_CallMethodChar_op_va_list, obj, methodID, args))
+#define JRI_CallMethodCharA(env, obj, methodID, args)	\
+	(((*(env))->CallMethodCharA)(env, JRI_CallMethodChar_op_array, obj, methodID, args))
+
+#define JRI_CallMethodShort(env)	((*(env))->CallMethodShort)
+#define JRI_CallMethodShortV(env, obj, methodID, args)	\
+	(((*(env))->CallMethodShortV)(env, JRI_CallMethodShort_op_va_list, obj, methodID, args))
+#define JRI_CallMethodShortA(env, obj, methodID, args)	\
+	(((*(env))->CallMethodShortA)(env, JRI_CallMethodShort_op_array, obj, methodID, args))
+
+#define JRI_CallMethodInt(env)	((*(env))->CallMethodInt)
+#define JRI_CallMethodIntV(env, obj, methodID, args)	\
+	(((*(env))->CallMethodIntV)(env, JRI_CallMethodInt_op_va_list, obj, methodID, args))
+#define JRI_CallMethodIntA(env, obj, methodID, args)	\
+	(((*(env))->CallMethodIntA)(env, JRI_CallMethodInt_op_array, obj, methodID, args))
+
+#define JRI_CallMethodLong(env)	((*(env))->CallMethodLong)
+#define JRI_CallMethodLongV(env, obj, methodID, args)	\
+	(((*(env))->CallMethodLongV)(env, JRI_CallMethodLong_op_va_list, obj, methodID, args))
+#define JRI_CallMethodLongA(env, obj, methodID, args)	\
+	(((*(env))->CallMethodLongA)(env, JRI_CallMethodLong_op_array, obj, methodID, args))
+
+#define JRI_CallMethodFloat(env)	((*(env))->CallMethodFloat)
+#define JRI_CallMethodFloatV(env, obj, methodID, args)	\
+	(((*(env))->CallMethodFloatV)(env, JRI_CallMethodFloat_op_va_list, obj, methodID, args))
+#define JRI_CallMethodFloatA(env, obj, methodID, args)	\
+	(((*(env))->CallMethodFloatA)(env, JRI_CallMethodFloat_op_array, obj, methodID, args))
+
+#define JRI_CallMethodDouble(env)	((*(env))->CallMethodDouble)
+#define JRI_CallMethodDoubleV(env, obj, methodID, args)	\
+	(((*(env))->CallMethodDoubleV)(env, JRI_CallMethodDouble_op_va_list, obj, methodID, args))
+#define JRI_CallMethodDoubleA(env, obj, methodID, args)	\
+	(((*(env))->CallMethodDoubleA)(env, JRI_CallMethodDouble_op_array, obj, methodID, args))
+
+#define JRI_GetFieldID(env, clazz, name, sig)	\
+	(((*(env))->GetFieldID)(env, JRI_GetFieldID_op, clazz, name, sig))
+
+#define JRI_GetField(env, obj, fieldID)	\
+	(((*(env))->GetField)(env, JRI_GetField_op, obj, fieldID))
+
+#define JRI_GetFieldBoolean(env, obj, fieldID)	\
+	(((*(env))->GetFieldBoolean)(env, JRI_GetFieldBoolean_op, obj, fieldID))
+
+#define JRI_GetFieldByte(env, obj, fieldID)	\
+	(((*(env))->GetFieldByte)(env, JRI_GetFieldByte_op, obj, fieldID))
+
+#define JRI_GetFieldChar(env, obj, fieldID)	\
+	(((*(env))->GetFieldChar)(env, JRI_GetFieldChar_op, obj, fieldID))
+
+#define JRI_GetFieldShort(env, obj, fieldID)	\
+	(((*(env))->GetFieldShort)(env, JRI_GetFieldShort_op, obj, fieldID))
+
+#define JRI_GetFieldInt(env, obj, fieldID)	\
+	(((*(env))->GetFieldInt)(env, JRI_GetFieldInt_op, obj, fieldID))
+
+#define JRI_GetFieldLong(env, obj, fieldID)	\
+	(((*(env))->GetFieldLong)(env, JRI_GetFieldLong_op, obj, fieldID))
+
+#define JRI_GetFieldFloat(env, obj, fieldID)	\
+	(((*(env))->GetFieldFloat)(env, JRI_GetFieldFloat_op, obj, fieldID))
+
+#define JRI_GetFieldDouble(env, obj, fieldID)	\
+	(((*(env))->GetFieldDouble)(env, JRI_GetFieldDouble_op, obj, fieldID))
+
+#define JRI_SetField(env, obj, fieldID, value)	\
+	(((*(env))->SetField)(env, JRI_SetField_op, obj, fieldID, value))
+
+#define JRI_SetFieldBoolean(env, obj, fieldID, value)	\
+	(((*(env))->SetFieldBoolean)(env, JRI_SetFieldBoolean_op, obj, fieldID, value))
+
+#define JRI_SetFieldByte(env, obj, fieldID, value)	\
+	(((*(env))->SetFieldByte)(env, JRI_SetFieldByte_op, obj, fieldID, value))
+
+#define JRI_SetFieldChar(env, obj, fieldID, value)	\
+	(((*(env))->SetFieldChar)(env, JRI_SetFieldChar_op, obj, fieldID, value))
+
+#define JRI_SetFieldShort(env, obj, fieldID, value)	\
+	(((*(env))->SetFieldShort)(env, JRI_SetFieldShort_op, obj, fieldID, value))
+
+#define JRI_SetFieldInt(env, obj, fieldID, value)	\
+	(((*(env))->SetFieldInt)(env, JRI_SetFieldInt_op, obj, fieldID, value))
+
+#define JRI_SetFieldLong(env, obj, fieldID, value)	\
+	(((*(env))->SetFieldLong)(env, JRI_SetFieldLong_op, obj, fieldID, value))
+
+#define JRI_SetFieldFloat(env, obj, fieldID, value)	\
+	(((*(env))->SetFieldFloat)(env, JRI_SetFieldFloat_op, obj, fieldID, value))
+
+#define JRI_SetFieldDouble(env, obj, fieldID, value)	\
+	(((*(env))->SetFieldDouble)(env, JRI_SetFieldDouble_op, obj, fieldID, value))
+
+#define JRI_IsSubclassOf(env, a, b)	\
+	(((*(env))->IsSubclassOf)(env, JRI_IsSubclassOf_op, a, b))
+
+#define JRI_GetStaticMethodID(env, clazz, name, sig)	\
+	(((*(env))->GetStaticMethodID)(env, JRI_GetStaticMethodID_op, clazz, name, sig))
+
+#define JRI_CallStaticMethod(env)	((*(env))->CallStaticMethod)
+#define JRI_CallStaticMethodV(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodV)(env, JRI_CallStaticMethod_op_va_list, clazz, methodID, args))
+#define JRI_CallStaticMethodA(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodA)(env, JRI_CallStaticMethod_op_array, clazz, methodID, args))
+
+#define JRI_CallStaticMethodBoolean(env)	((*(env))->CallStaticMethodBoolean)
+#define JRI_CallStaticMethodBooleanV(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodBooleanV)(env, JRI_CallStaticMethodBoolean_op_va_list, clazz, methodID, args))
+#define JRI_CallStaticMethodBooleanA(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodBooleanA)(env, JRI_CallStaticMethodBoolean_op_array, clazz, methodID, args))
+
+#define JRI_CallStaticMethodByte(env)	((*(env))->CallStaticMethodByte)
+#define JRI_CallStaticMethodByteV(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodByteV)(env, JRI_CallStaticMethodByte_op_va_list, clazz, methodID, args))
+#define JRI_CallStaticMethodByteA(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodByteA)(env, JRI_CallStaticMethodByte_op_array, clazz, methodID, args))
+
+#define JRI_CallStaticMethodChar(env)	((*(env))->CallStaticMethodChar)
+#define JRI_CallStaticMethodCharV(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodCharV)(env, JRI_CallStaticMethodChar_op_va_list, clazz, methodID, args))
+#define JRI_CallStaticMethodCharA(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodCharA)(env, JRI_CallStaticMethodChar_op_array, clazz, methodID, args))
+
+#define JRI_CallStaticMethodShort(env)	((*(env))->CallStaticMethodShort)
+#define JRI_CallStaticMethodShortV(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodShortV)(env, JRI_CallStaticMethodShort_op_va_list, clazz, methodID, args))
+#define JRI_CallStaticMethodShortA(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodShortA)(env, JRI_CallStaticMethodShort_op_array, clazz, methodID, args))
+
+#define JRI_CallStaticMethodInt(env)	((*(env))->CallStaticMethodInt)
+#define JRI_CallStaticMethodIntV(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodIntV)(env, JRI_CallStaticMethodInt_op_va_list, clazz, methodID, args))
+#define JRI_CallStaticMethodIntA(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodIntA)(env, JRI_CallStaticMethodInt_op_array, clazz, methodID, args))
+
+#define JRI_CallStaticMethodLong(env)	((*(env))->CallStaticMethodLong)
+#define JRI_CallStaticMethodLongV(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodLongV)(env, JRI_CallStaticMethodLong_op_va_list, clazz, methodID, args))
+#define JRI_CallStaticMethodLongA(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodLongA)(env, JRI_CallStaticMethodLong_op_array, clazz, methodID, args))
+
+#define JRI_CallStaticMethodFloat(env)	((*(env))->CallStaticMethodFloat)
+#define JRI_CallStaticMethodFloatV(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodFloatV)(env, JRI_CallStaticMethodFloat_op_va_list, clazz, methodID, args))
+#define JRI_CallStaticMethodFloatA(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodFloatA)(env, JRI_CallStaticMethodFloat_op_array, clazz, methodID, args))
+
+#define JRI_CallStaticMethodDouble(env)	((*(env))->CallStaticMethodDouble)
+#define JRI_CallStaticMethodDoubleV(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodDoubleV)(env, JRI_CallStaticMethodDouble_op_va_list, clazz, methodID, args))
+#define JRI_CallStaticMethodDoubleA(env, clazz, methodID, args)	\
+	(((*(env))->CallStaticMethodDoubleA)(env, JRI_CallStaticMethodDouble_op_array, clazz, methodID, args))
+
+#define JRI_GetStaticFieldID(env, clazz, name, sig)	\
+	(((*(env))->GetStaticFieldID)(env, JRI_GetStaticFieldID_op, clazz, name, sig))
+
+#define JRI_GetStaticField(env, clazz, fieldID)	\
+	(((*(env))->GetStaticField)(env, JRI_GetStaticField_op, clazz, fieldID))
+
+#define JRI_GetStaticFieldBoolean(env, clazz, fieldID)	\
+	(((*(env))->GetStaticFieldBoolean)(env, JRI_GetStaticFieldBoolean_op, clazz, fieldID))
+
+#define JRI_GetStaticFieldByte(env, clazz, fieldID)	\
+	(((*(env))->GetStaticFieldByte)(env, JRI_GetStaticFieldByte_op, clazz, fieldID))
+
+#define JRI_GetStaticFieldChar(env, clazz, fieldID)	\
+	(((*(env))->GetStaticFieldChar)(env, JRI_GetStaticFieldChar_op, clazz, fieldID))
+
+#define JRI_GetStaticFieldShort(env, clazz, fieldID)	\
+	(((*(env))->GetStaticFieldShort)(env, JRI_GetStaticFieldShort_op, clazz, fieldID))
+
+#define JRI_GetStaticFieldInt(env, clazz, fieldID)	\
+	(((*(env))->GetStaticFieldInt)(env, JRI_GetStaticFieldInt_op, clazz, fieldID))
+
+#define JRI_GetStaticFieldLong(env, clazz, fieldID)	\
+	(((*(env))->GetStaticFieldLong)(env, JRI_GetStaticFieldLong_op, clazz, fieldID))
+
+#define JRI_GetStaticFieldFloat(env, clazz, fieldID)	\
+	(((*(env))->GetStaticFieldFloat)(env, JRI_GetStaticFieldFloat_op, clazz, fieldID))
+
+#define JRI_GetStaticFieldDouble(env, clazz, fieldID)	\
+	(((*(env))->GetStaticFieldDouble)(env, JRI_GetStaticFieldDouble_op, clazz, fieldID))
+
+#define JRI_SetStaticField(env, clazz, fieldID, value)	\
+	(((*(env))->SetStaticField)(env, JRI_SetStaticField_op, clazz, fieldID, value))
+
+#define JRI_SetStaticFieldBoolean(env, clazz, fieldID, value)	\
+	(((*(env))->SetStaticFieldBoolean)(env, JRI_SetStaticFieldBoolean_op, clazz, fieldID, value))
+
+#define JRI_SetStaticFieldByte(env, clazz, fieldID, value)	\
+	(((*(env))->SetStaticFieldByte)(env, JRI_SetStaticFieldByte_op, clazz, fieldID, value))
+
+#define JRI_SetStaticFieldChar(env, clazz, fieldID, value)	\
+	(((*(env))->SetStaticFieldChar)(env, JRI_SetStaticFieldChar_op, clazz, fieldID, value))
+
+#define JRI_SetStaticFieldShort(env, clazz, fieldID, value)	\
+	(((*(env))->SetStaticFieldShort)(env, JRI_SetStaticFieldShort_op, clazz, fieldID, value))
+
+#define JRI_SetStaticFieldInt(env, clazz, fieldID, value)	\
+	(((*(env))->SetStaticFieldInt)(env, JRI_SetStaticFieldInt_op, clazz, fieldID, value))
+
+#define JRI_SetStaticFieldLong(env, clazz, fieldID, value)	\
+	(((*(env))->SetStaticFieldLong)(env, JRI_SetStaticFieldLong_op, clazz, fieldID, value))
+
+#define JRI_SetStaticFieldFloat(env, clazz, fieldID, value)	\
+	(((*(env))->SetStaticFieldFloat)(env, JRI_SetStaticFieldFloat_op, clazz, fieldID, value))
+
+#define JRI_SetStaticFieldDouble(env, clazz, fieldID, value)	\
+	(((*(env))->SetStaticFieldDouble)(env, JRI_SetStaticFieldDouble_op, clazz, fieldID, value))
+
+#define JRI_NewString(env, unicode, len)	\
+	(((*(env))->NewString)(env, JRI_NewString_op, unicode, len))
+
+#define JRI_GetStringLength(env, string)	\
+	(((*(env))->GetStringLength)(env, JRI_GetStringLength_op, string))
+
+#define JRI_GetStringChars(env, string)	\
+	(((*(env))->GetStringChars)(env, JRI_GetStringChars_op, string))
+
+#define JRI_NewStringUTF(env, utf, len)	\
+	(((*(env))->NewStringUTF)(env, JRI_NewStringUTF_op, utf, len))
+
+#define JRI_GetStringUTFLength(env, string)	\
+	(((*(env))->GetStringUTFLength)(env, JRI_GetStringUTFLength_op, string))
+
+#define JRI_GetStringUTFChars(env, string)	\
+	(((*(env))->GetStringUTFChars)(env, JRI_GetStringUTFChars_op, string))
+
+#define JRI_NewScalarArray(env, length, elementSig, initialElements)	\
+	(((*(env))->NewScalarArray)(env, JRI_NewScalarArray_op, length, elementSig, initialElements))
+
+#define JRI_GetScalarArrayLength(env, array)	\
+	(((*(env))->GetScalarArrayLength)(env, JRI_GetScalarArrayLength_op, array))
+
+#define JRI_GetScalarArrayElements(env, array)	\
+	(((*(env))->GetScalarArrayElements)(env, JRI_GetScalarArrayElements_op, array))
+
+#define JRI_NewObjectArray(env, length, elementClass, initialElement)	\
+	(((*(env))->NewObjectArray)(env, JRI_NewObjectArray_op, length, elementClass, initialElement))
+
+#define JRI_GetObjectArrayLength(env, array)	\
+	(((*(env))->GetObjectArrayLength)(env, JRI_GetObjectArrayLength_op, array))
+
+#define JRI_GetObjectArrayElement(env, array, index)	\
+	(((*(env))->GetObjectArrayElement)(env, JRI_GetObjectArrayElement_op, array, index))
+
+#define JRI_SetObjectArrayElement(env, array, index, value)	\
+	(((*(env))->SetObjectArrayElement)(env, JRI_SetObjectArrayElement_op, array, index, value))
+
+#define JRI_RegisterNatives(env, clazz, nameAndSigArray, nativeProcArray)	\
+	(((*(env))->RegisterNatives)(env, JRI_RegisterNatives_op, clazz, nameAndSigArray, nativeProcArray))
+
+#define JRI_UnregisterNatives(env, clazz)	\
+	(((*(env))->UnregisterNatives)(env, JRI_UnregisterNatives_op, clazz))
+
+#define JRI_NewStringPlatform(env, string, len, encoding, encodingLength)	\
+	(((*(env))->NewStringPlatform)(env, JRI_NewStringPlatform_op, string, len, encoding, encodingLength))
+
+#define JRI_GetStringPlatformChars(env, string, encoding, encodingLength)	\
+	(((*(env))->GetStringPlatformChars)(env, JRI_GetStringPlatformChars_op, string, encoding, encodingLength))
+
+
+/*******************************************************************************
+ * JRIEnv Interface
+ ******************************************************************************/
+
+struct java_lang_ClassLoader;
+struct java_lang_Class;
+struct java_lang_Throwable;
+struct java_lang_Object;
+struct java_lang_String;
+
+struct JRIEnvInterface {
+	void*	reserved0;
+	void*	reserved1;
+	void*	reserved2;
+	void*	reserved3;
+	struct java_lang_Class*	(*FindClass)(JRIEnv* env, jint op, const char* a);
+	void	(*Throw)(JRIEnv* env, jint op, struct java_lang_Throwable* a);
+	void	(*ThrowNew)(JRIEnv* env, jint op, struct java_lang_Class* a, const char* b);
+	struct java_lang_Throwable*	(*ExceptionOccurred)(JRIEnv* env, jint op);
+	void	(*ExceptionDescribe)(JRIEnv* env, jint op);
+	void	(*ExceptionClear)(JRIEnv* env, jint op);
+	jglobal	(*NewGlobalRef)(JRIEnv* env, jint op, void* a);
+	void	(*DisposeGlobalRef)(JRIEnv* env, jint op, jglobal a);
+	void*	(*GetGlobalRef)(JRIEnv* env, jint op, jglobal a);
+	void	(*SetGlobalRef)(JRIEnv* env, jint op, jglobal a, void* b);
+	jbool	(*IsSameObject)(JRIEnv* env, jint op, void* a, void* b);
+	void*	(*NewObject)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, ...);
+	void*	(*NewObjectV)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, va_list c);
+	void*	(*NewObjectA)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, JRIValue* c);
+	struct java_lang_Class*	(*GetObjectClass)(JRIEnv* env, jint op, void* a);
+	jbool	(*IsInstanceOf)(JRIEnv* env, jint op, void* a, struct java_lang_Class* b);
+	jint	(*GetMethodID)(JRIEnv* env, jint op, struct java_lang_Class* a, const char* b, const char* c);
+	void*	(*CallMethod)(JRIEnv* env, jint op, void* a, jint b, ...);
+	void*	(*CallMethodV)(JRIEnv* env, jint op, void* a, jint b, va_list c);
+	void*	(*CallMethodA)(JRIEnv* env, jint op, void* a, jint b, JRIValue* c);
+	jbool	(*CallMethodBoolean)(JRIEnv* env, jint op, void* a, jint b, ...);
+	jbool	(*CallMethodBooleanV)(JRIEnv* env, jint op, void* a, jint b, va_list c);
+	jbool	(*CallMethodBooleanA)(JRIEnv* env, jint op, void* a, jint b, JRIValue* c);
+	jbyte	(*CallMethodByte)(JRIEnv* env, jint op, void* a, jint b, ...);
+	jbyte	(*CallMethodByteV)(JRIEnv* env, jint op, void* a, jint b, va_list c);
+	jbyte	(*CallMethodByteA)(JRIEnv* env, jint op, void* a, jint b, JRIValue* c);
+	jchar	(*CallMethodChar)(JRIEnv* env, jint op, void* a, jint b, ...);
+	jchar	(*CallMethodCharV)(JRIEnv* env, jint op, void* a, jint b, va_list c);
+	jchar	(*CallMethodCharA)(JRIEnv* env, jint op, void* a, jint b, JRIValue* c);
+	jshort	(*CallMethodShort)(JRIEnv* env, jint op, void* a, jint b, ...);
+	jshort	(*CallMethodShortV)(JRIEnv* env, jint op, void* a, jint b, va_list c);
+	jshort	(*CallMethodShortA)(JRIEnv* env, jint op, void* a, jint b, JRIValue* c);
+	jint	(*CallMethodInt)(JRIEnv* env, jint op, void* a, jint b, ...);
+	jint	(*CallMethodIntV)(JRIEnv* env, jint op, void* a, jint b, va_list c);
+	jint	(*CallMethodIntA)(JRIEnv* env, jint op, void* a, jint b, JRIValue* c);
+	jlong	(*CallMethodLong)(JRIEnv* env, jint op, void* a, jint b, ...);
+	jlong	(*CallMethodLongV)(JRIEnv* env, jint op, void* a, jint b, va_list c);
+	jlong	(*CallMethodLongA)(JRIEnv* env, jint op, void* a, jint b, JRIValue* c);
+	jfloat	(*CallMethodFloat)(JRIEnv* env, jint op, void* a, jint b, ...);
+	jfloat	(*CallMethodFloatV)(JRIEnv* env, jint op, void* a, jint b, va_list c);
+	jfloat	(*CallMethodFloatA)(JRIEnv* env, jint op, void* a, jint b, JRIValue* c);
+	jdouble	(*CallMethodDouble)(JRIEnv* env, jint op, void* a, jint b, ...);
+	jdouble	(*CallMethodDoubleV)(JRIEnv* env, jint op, void* a, jint b, va_list c);
+	jdouble	(*CallMethodDoubleA)(JRIEnv* env, jint op, void* a, jint b, JRIValue* c);
+	jint	(*GetFieldID)(JRIEnv* env, jint op, struct java_lang_Class* a, const char* b, const char* c);
+	void*	(*GetField)(JRIEnv* env, jint op, void* a, jint b);
+	jbool	(*GetFieldBoolean)(JRIEnv* env, jint op, void* a, jint b);
+	jbyte	(*GetFieldByte)(JRIEnv* env, jint op, void* a, jint b);
+	jchar	(*GetFieldChar)(JRIEnv* env, jint op, void* a, jint b);
+	jshort	(*GetFieldShort)(JRIEnv* env, jint op, void* a, jint b);
+	jint	(*GetFieldInt)(JRIEnv* env, jint op, void* a, jint b);
+	jlong	(*GetFieldLong)(JRIEnv* env, jint op, void* a, jint b);
+	jfloat	(*GetFieldFloat)(JRIEnv* env, jint op, void* a, jint b);
+	jdouble	(*GetFieldDouble)(JRIEnv* env, jint op, void* a, jint b);
+	void	(*SetField)(JRIEnv* env, jint op, void* a, jint b, void* c);
+	void	(*SetFieldBoolean)(JRIEnv* env, jint op, void* a, jint b, jbool c);
+	void	(*SetFieldByte)(JRIEnv* env, jint op, void* a, jint b, jbyte c);
+	void	(*SetFieldChar)(JRIEnv* env, jint op, void* a, jint b, jchar c);
+	void	(*SetFieldShort)(JRIEnv* env, jint op, void* a, jint b, jshort c);
+	void	(*SetFieldInt)(JRIEnv* env, jint op, void* a, jint b, jint c);
+	void	(*SetFieldLong)(JRIEnv* env, jint op, void* a, jint b, jlong c);
+	void	(*SetFieldFloat)(JRIEnv* env, jint op, void* a, jint b, jfloat c);
+	void	(*SetFieldDouble)(JRIEnv* env, jint op, void* a, jint b, jdouble c);
+	jbool	(*IsSubclassOf)(JRIEnv* env, jint op, struct java_lang_Class* a, struct java_lang_Class* b);
+	jint	(*GetStaticMethodID)(JRIEnv* env, jint op, struct java_lang_Class* a, const char* b, const char* c);
+	void*	(*CallStaticMethod)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, ...);
+	void*	(*CallStaticMethodV)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, va_list c);
+	void*	(*CallStaticMethodA)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, JRIValue* c);
+	jbool	(*CallStaticMethodBoolean)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, ...);
+	jbool	(*CallStaticMethodBooleanV)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, va_list c);
+	jbool	(*CallStaticMethodBooleanA)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, JRIValue* c);
+	jbyte	(*CallStaticMethodByte)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, ...);
+	jbyte	(*CallStaticMethodByteV)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, va_list c);
+	jbyte	(*CallStaticMethodByteA)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, JRIValue* c);
+	jchar	(*CallStaticMethodChar)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, ...);
+	jchar	(*CallStaticMethodCharV)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, va_list c);
+	jchar	(*CallStaticMethodCharA)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, JRIValue* c);
+	jshort	(*CallStaticMethodShort)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, ...);
+	jshort	(*CallStaticMethodShortV)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, va_list c);
+	jshort	(*CallStaticMethodShortA)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, JRIValue* c);
+	jint	(*CallStaticMethodInt)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, ...);
+	jint	(*CallStaticMethodIntV)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, va_list c);
+	jint	(*CallStaticMethodIntA)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, JRIValue* c);
+	jlong	(*CallStaticMethodLong)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, ...);
+	jlong	(*CallStaticMethodLongV)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, va_list c);
+	jlong	(*CallStaticMethodLongA)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, JRIValue* c);
+	jfloat	(*CallStaticMethodFloat)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, ...);
+	jfloat	(*CallStaticMethodFloatV)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, va_list c);
+	jfloat	(*CallStaticMethodFloatA)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, JRIValue* c);
+	jdouble	(*CallStaticMethodDouble)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, ...);
+	jdouble	(*CallStaticMethodDoubleV)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, va_list c);
+	jdouble	(*CallStaticMethodDoubleA)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, JRIValue* c);
+	jint	(*GetStaticFieldID)(JRIEnv* env, jint op, struct java_lang_Class* a, const char* b, const char* c);
+	void*	(*GetStaticField)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b);
+	jbool	(*GetStaticFieldBoolean)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b);
+	jbyte	(*GetStaticFieldByte)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b);
+	jchar	(*GetStaticFieldChar)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b);
+	jshort	(*GetStaticFieldShort)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b);
+	jint	(*GetStaticFieldInt)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b);
+	jlong	(*GetStaticFieldLong)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b);
+	jfloat	(*GetStaticFieldFloat)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b);
+	jdouble	(*GetStaticFieldDouble)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b);
+	void	(*SetStaticField)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, void* c);
+	void	(*SetStaticFieldBoolean)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, jbool c);
+	void	(*SetStaticFieldByte)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, jbyte c);
+	void	(*SetStaticFieldChar)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, jchar c);
+	void	(*SetStaticFieldShort)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, jshort c);
+	void	(*SetStaticFieldInt)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, jint c);
+	void	(*SetStaticFieldLong)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, jlong c);
+	void	(*SetStaticFieldFloat)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, jfloat c);
+	void	(*SetStaticFieldDouble)(JRIEnv* env, jint op, struct java_lang_Class* a, jint b, jdouble c);
+	struct java_lang_String*	(*NewString)(JRIEnv* env, jint op, const jchar* a, jint b);
+	jint	(*GetStringLength)(JRIEnv* env, jint op, struct java_lang_String* a);
+	const jchar*	(*GetStringChars)(JRIEnv* env, jint op, struct java_lang_String* a);
+	struct java_lang_String*	(*NewStringUTF)(JRIEnv* env, jint op, const jbyte* a, jint b);
+	jint	(*GetStringUTFLength)(JRIEnv* env, jint op, struct java_lang_String* a);
+	const jbyte*	(*GetStringUTFChars)(JRIEnv* env, jint op, struct java_lang_String* a);
+	void*	(*NewScalarArray)(JRIEnv* env, jint op, jint a, const char* b, const jbyte* c);
+	jint	(*GetScalarArrayLength)(JRIEnv* env, jint op, void* a);
+	jbyte*	(*GetScalarArrayElements)(JRIEnv* env, jint op, void* a);
+	void*	(*NewObjectArray)(JRIEnv* env, jint op, jint a, struct java_lang_Class* b, void* c);
+	jint	(*GetObjectArrayLength)(JRIEnv* env, jint op, void* a);
+	void*	(*GetObjectArrayElement)(JRIEnv* env, jint op, void* a, jint b);
+	void	(*SetObjectArrayElement)(JRIEnv* env, jint op, void* a, jint b, void* c);
+	void	(*RegisterNatives)(JRIEnv* env, jint op, struct java_lang_Class* a, char** b, void** c);
+	void	(*UnregisterNatives)(JRIEnv* env, jint op, struct java_lang_Class* a);
+	struct java_lang_Class*	(*DefineClass)(JRIEnv* env, jint op, struct java_lang_ClassLoader* a, jbyte* b, jsize bLen);
+	struct java_lang_String*	(*NewStringPlatform)(JRIEnv* env, jint op, const jbyte* a, jint b, const jbyte* c, jint d);
+	const jbyte*	(*GetStringPlatformChars)(JRIEnv* env, jint op, struct java_lang_String* a, const jbyte* b, jint c);
+};
+
+/*
+** ****************************************************************************
+** JRIEnv Operation IDs
+** ***************************************************************************
+*/
+
+typedef enum JRIEnvOperations {
+	JRI_Reserved0_op,
+	JRI_Reserved1_op,
+	JRI_Reserved2_op,
+	JRI_Reserved3_op,
+	JRI_FindClass_op,
+	JRI_Throw_op,
+	JRI_ThrowNew_op,
+	JRI_ExceptionOccurred_op,
+	JRI_ExceptionDescribe_op,
+	JRI_ExceptionClear_op,
+	JRI_NewGlobalRef_op,
+	JRI_DisposeGlobalRef_op,
+	JRI_GetGlobalRef_op,
+	JRI_SetGlobalRef_op,
+	JRI_IsSameObject_op,
+	JRI_NewObject_op,
+	JRI_NewObject_op_va_list,
+	JRI_NewObject_op_array,
+	JRI_GetObjectClass_op,
+	JRI_IsInstanceOf_op,
+	JRI_GetMethodID_op,
+	JRI_CallMethod_op,
+	JRI_CallMethod_op_va_list,
+	JRI_CallMethod_op_array,
+	JRI_CallMethodBoolean_op,
+	JRI_CallMethodBoolean_op_va_list,
+	JRI_CallMethodBoolean_op_array,
+	JRI_CallMethodByte_op,
+	JRI_CallMethodByte_op_va_list,
+	JRI_CallMethodByte_op_array,
+	JRI_CallMethodChar_op,
+	JRI_CallMethodChar_op_va_list,
+	JRI_CallMethodChar_op_array,
+	JRI_CallMethodShort_op,
+	JRI_CallMethodShort_op_va_list,
+	JRI_CallMethodShort_op_array,
+	JRI_CallMethodInt_op,
+	JRI_CallMethodInt_op_va_list,
+	JRI_CallMethodInt_op_array,
+	JRI_CallMethodLong_op,
+	JRI_CallMethodLong_op_va_list,
+	JRI_CallMethodLong_op_array,
+	JRI_CallMethodFloat_op,
+	JRI_CallMethodFloat_op_va_list,
+	JRI_CallMethodFloat_op_array,
+	JRI_CallMethodDouble_op,
+	JRI_CallMethodDouble_op_va_list,
+	JRI_CallMethodDouble_op_array,
+	JRI_GetFieldID_op,
+	JRI_GetField_op,
+	JRI_GetFieldBoolean_op,
+	JRI_GetFieldByte_op,
+	JRI_GetFieldChar_op,
+	JRI_GetFieldShort_op,
+	JRI_GetFieldInt_op,
+	JRI_GetFieldLong_op,
+	JRI_GetFieldFloat_op,
+	JRI_GetFieldDouble_op,
+	JRI_SetField_op,
+	JRI_SetFieldBoolean_op,
+	JRI_SetFieldByte_op,
+	JRI_SetFieldChar_op,
+	JRI_SetFieldShort_op,
+	JRI_SetFieldInt_op,
+	JRI_SetFieldLong_op,
+	JRI_SetFieldFloat_op,
+	JRI_SetFieldDouble_op,
+	JRI_IsSubclassOf_op,
+	JRI_GetStaticMethodID_op,
+	JRI_CallStaticMethod_op,
+	JRI_CallStaticMethod_op_va_list,
+	JRI_CallStaticMethod_op_array,
+	JRI_CallStaticMethodBoolean_op,
+	JRI_CallStaticMethodBoolean_op_va_list,
+	JRI_CallStaticMethodBoolean_op_array,
+	JRI_CallStaticMethodByte_op,
+	JRI_CallStaticMethodByte_op_va_list,
+	JRI_CallStaticMethodByte_op_array,
+	JRI_CallStaticMethodChar_op,
+	JRI_CallStaticMethodChar_op_va_list,
+	JRI_CallStaticMethodChar_op_array,
+	JRI_CallStaticMethodShort_op,
+	JRI_CallStaticMethodShort_op_va_list,
+	JRI_CallStaticMethodShort_op_array,
+	JRI_CallStaticMethodInt_op,
+	JRI_CallStaticMethodInt_op_va_list,
+	JRI_CallStaticMethodInt_op_array,
+	JRI_CallStaticMethodLong_op,
+	JRI_CallStaticMethodLong_op_va_list,
+	JRI_CallStaticMethodLong_op_array,
+	JRI_CallStaticMethodFloat_op,
+	JRI_CallStaticMethodFloat_op_va_list,
+	JRI_CallStaticMethodFloat_op_array,
+	JRI_CallStaticMethodDouble_op,
+	JRI_CallStaticMethodDouble_op_va_list,
+	JRI_CallStaticMethodDouble_op_array,
+	JRI_GetStaticFieldID_op,
+	JRI_GetStaticField_op,
+	JRI_GetStaticFieldBoolean_op,
+	JRI_GetStaticFieldByte_op,
+	JRI_GetStaticFieldChar_op,
+	JRI_GetStaticFieldShort_op,
+	JRI_GetStaticFieldInt_op,
+	JRI_GetStaticFieldLong_op,
+	JRI_GetStaticFieldFloat_op,
+	JRI_GetStaticFieldDouble_op,
+	JRI_SetStaticField_op,
+	JRI_SetStaticFieldBoolean_op,
+	JRI_SetStaticFieldByte_op,
+	JRI_SetStaticFieldChar_op,
+	JRI_SetStaticFieldShort_op,
+	JRI_SetStaticFieldInt_op,
+	JRI_SetStaticFieldLong_op,
+	JRI_SetStaticFieldFloat_op,
+	JRI_SetStaticFieldDouble_op,
+	JRI_NewString_op,
+	JRI_GetStringLength_op,
+	JRI_GetStringChars_op,
+	JRI_NewStringUTF_op,
+	JRI_GetStringUTFLength_op,
+	JRI_GetStringUTFChars_op,
+	JRI_NewScalarArray_op,
+	JRI_GetScalarArrayLength_op,
+	JRI_GetScalarArrayElements_op,
+	JRI_NewObjectArray_op,
+	JRI_GetObjectArrayLength_op,
+	JRI_GetObjectArrayElement_op,
+	JRI_SetObjectArrayElement_op,
+	JRI_RegisterNatives_op,
+	JRI_UnregisterNatives_op,
+	JRI_DefineClass_op,
+	JRI_NewStringPlatform_op,
+	JRI_GetStringPlatformChars_op
+} JRIEnvOperations;
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif /* __cplusplus */
+
+#endif /* JRI_H */
+/******************************************************************************/
diff -Nur mplayerplug-in-3.55-orig/include/jri_md.h mplayerplug-in-3.55/include/jri_md.h
--- mplayerplug-in-3.55-orig/include/jri_md.h	1970-01-01 07:00:00.000000000 +0700
+++ mplayerplug-in-3.55/include/jri_md.h	2007-08-04 02:59:37.000000000 +0700
@@ -0,0 +1,565 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: NPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Netscape Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/NPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is 
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or 
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the NPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the NPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*******************************************************************************
+ * Java Runtime Interface - Machine Dependent Types
+ ******************************************************************************/
+ 
+#ifndef JRI_MD_H
+#define JRI_MD_H
+
+#include <assert.h>
+#include "prtypes.h" /* Needed for HAS_LONG_LONG ifdefs */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+ * WHAT'S UP WITH THIS FILE?
+ * 
+ * This is where we define the mystical JRI_PUBLIC_API macro that works on all
+ * platforms. If you're running with Visual C++, Symantec C, or Borland's 
+ * development environment on the PC, you're all set. Or if you're on the Mac
+ * with Metrowerks, Symantec or MPW with SC you're ok too. For UNIX it shouldn't
+ * matter.
+ *
+ * On UNIX though you probably care about a couple of other symbols though:
+ *	IS_LITTLE_ENDIAN must be defined for little-endian systems
+ *	HAVE_LONG_LONG must be defined on systems that have 'long long' integers
+ *	HAVE_ALIGNED_LONGLONGS must be defined if long-longs must be 8 byte aligned
+ *	HAVE_ALIGNED_DOUBLES must be defined if doubles must be 8 byte aligned
+ *	IS_64 must be defined on 64-bit machines (like Dec Alpha)
+ ******************************************************************************/
+
+/* DLL Entry modifiers... */
+
+/* PC */
+#if defined(XP_OS2)
+#  ifdef XP_OS2_VACPP
+#	  define JRI_PUBLIC_API(ResultType)	    ResultType _Optlink
+#	  define JRI_PUBLIC_VAR(VarType)        VarType
+#     define JRI_CALLBACK
+#  else
+#	  define JRI_PUBLIC_API(ResultType)	    ResultType
+#	  define JRI_PUBLIC_VAR(VarType)        VarType
+#     define JRI_CALLBACK
+#  endif
+#elif defined(XP_WIN) || defined(_WINDOWS) || defined(WIN32) || defined(_WIN32)
+#	include <windows.h>
+#	if defined(_MSC_VER) || defined(__GNUC__)
+#		if defined(WIN32) || defined(_WIN32)
+#			define JRI_PUBLIC_API(ResultType)  __declspec(dllexport) ResultType
+#			define JRI_PUBLIC_VAR(VarType)	   VarType
+#			define JRI_PUBLIC_VAR_EXP(VarType) __declspec(dllexport) VarType
+#			define JRI_PUBLIC_VAR_IMP(VarType) __declspec(dllimport) VarType
+#			define JRI_NATIVE_STUB(ResultType) __declspec(dllexport) ResultType
+#			define JRI_CALLBACK
+#		else /* !_WIN32 */
+#		    if defined(_WINDLL)
+#			define JRI_PUBLIC_API(ResultType)	ResultType __cdecl __export __loadds 
+#			define JRI_PUBLIC_VAR(VarType)		VarType
+#			define JRI_PUBLIC_VAR_EXP(VarType)	JRI_PUBLIC_VAR(VarType)
+#			define JRI_PUBLIC_VAR_IMP(VarType)	JRI_PUBLIC_VAR(VarType)
+#			define JRI_NATIVE_STUB(ResultType)	ResultType __cdecl __loadds
+#			define JRI_CALLBACK			__loadds
+#		else /* !WINDLL */
+#			define JRI_PUBLIC_API(ResultType)	ResultType __cdecl __export
+#			define JRI_PUBLIC_VAR(VarType)		VarType
+#			define JRI_PUBLIC_VAR_EXP(VarType)	JRI_PUBLIC_VAR(VarType)
+#			define JRI_PUBLIC_VAR_IMP(VarType)	JRI_PUBLIC_VAR(VarType)
+#			define JRI_NATIVE_STUB(ResultType)	ResultType __cdecl __export
+#			define JRI_CALLBACK			__export
+#                   endif /* !WINDLL */
+#		endif /* !_WIN32 */
+#	elif defined(__BORLANDC__)
+#		if defined(WIN32) || defined(_WIN32)
+#			define JRI_PUBLIC_API(ResultType)	__export ResultType
+#			define JRI_PUBLIC_VAR(VarType)		VarType
+#			define JRI_PUBLIC_VAR_EXP(VarType)	__export VarType
+#			define JRI_PUBLIC_VAR_IMP(VarType)	__import VarType
+#			define JRI_NATIVE_STUB(ResultType)	 __export ResultType
+#			define JRI_CALLBACK
+#		else /* !_WIN32 */
+#			define JRI_PUBLIC_API(ResultType)	ResultType _cdecl _export _loadds 
+#			define JRI_PUBLIC_VAR(VarType)		VarType
+#			define JRI_PUBLIC_VAR_EXP(VarType)	__cdecl __export VarType
+#			define JRI_PUBLIC_VAR_IMP(VarType)	__cdecl __import VarType
+#			define JRI_NATIVE_STUB(ResultType)	ResultType _cdecl _loadds
+#			define JRI_CALLBACK			_loadds
+#		endif
+#	else
+#		error Unsupported PC development environment.	
+#	endif
+#	ifndef IS_LITTLE_ENDIAN
+#		define IS_LITTLE_ENDIAN
+#	endif
+
+/* Mac */
+#elif defined (macintosh) || Macintosh || THINK_C
+#	if defined(__MWERKS__)				/* Metrowerks */
+#		if !__option(enumsalwaysint)
+#			error You need to define 'Enums Always Int' for your project.
+#		endif
+#		if defined(TARGET_CPU_68K) && !TARGET_RT_MAC_CFM 
+#			if !__option(fourbyteints) 
+#				error You need to define 'Struct Alignment: 68k' for your project.
+#			endif
+#		endif /* !GENERATINGCFM */
+#		define JRI_PUBLIC_API(ResultType)	__declspec(export) ResultType
+#		define JRI_PUBLIC_VAR(VarType)		JRI_PUBLIC_API(VarType)
+#		define JRI_PUBLIC_VAR_EXP(VarType)	JRI_PUBLIC_API(VarType)
+#		define JRI_PUBLIC_VAR_IMP(VarType)	JRI_PUBLIC_API(VarType)
+#		define JRI_NATIVE_STUB(ResultType)	JRI_PUBLIC_API(ResultType)
+#	elif defined(__SC__)				/* Symantec */
+#		error What are the Symantec defines? (warren@netscape.com)
+#	elif macintosh && applec			/* MPW */
+#		error Please upgrade to the latest MPW compiler (SC).
+#	else
+#		error Unsupported Mac development environment.
+#	endif
+#	define JRI_CALLBACK
+
+/* Unix or else */
+#else
+#	define JRI_PUBLIC_API(ResultType)		ResultType
+#   define JRI_PUBLIC_VAR(VarType)          VarType
+#   define JRI_PUBLIC_VAR_EXP(VarType)		JRI_PUBLIC_VAR(VarType)
+#   define JRI_PUBLIC_VAR_IMP(VarType)		JRI_PUBLIC_VAR(VarType)
+#   define JRI_NATIVE_STUB(ResultType)		ResultType
+#	define JRI_CALLBACK
+#endif
+
+#ifndef FAR		/* for non-Win16 */
+#define FAR
+#endif
+
+/******************************************************************************/
+
+/* Java Scalar Types */
+
+#if 0	/* now in jni.h */
+typedef short			jchar;
+typedef short			jshort;
+typedef float			jfloat;
+typedef double			jdouble;
+typedef juint			jsize;
+#endif
+
+/* moved from jni.h -- Sun's new jni.h doesn't have this anymore */
+#ifdef __cplusplus
+typedef class _jobject *jref;
+#else
+typedef struct _jobject *jref;
+#endif
+
+typedef unsigned char	jbool;
+typedef signed char	jbyte;
+#ifdef IS_64 /* XXX ok for alpha, but not right on all 64-bit architectures */
+typedef unsigned int	juint;
+typedef int				jint;
+#else
+typedef unsigned long	juint;
+typedef long			jint;
+#endif
+
+/*******************************************************************************
+ * jlong : long long (64-bit signed integer type) support.
+ ******************************************************************************/
+
+/*
+** Bit masking macros.  (n must be <= 31 to be portable)
+*/
+#define JRI_BIT(n)			((juint)1 << (n))
+#define JRI_BITMASK(n)		(JRI_BIT(n) - 1)
+
+#ifdef HAVE_LONG_LONG
+
+#ifdef OSF1
+
+/* long is default 64-bit on OSF1, -std1 does not allow long long */
+typedef long                  jlong;
+typedef unsigned long         julong;
+#define jlong_MAXINT          0x7fffffffffffffffL
+#define jlong_MININT          0x8000000000000000L
+#define jlong_ZERO            0x0L
+
+#elif (defined(WIN32) || defined(_WIN32))
+
+typedef LONGLONG              jlong;
+typedef DWORDLONG             julong;
+#define jlong_MAXINT          0x7fffffffffffffffi64
+#define jlong_MININT          0x8000000000000000i64
+#define jlong_ZERO            0x0i64
+
+#else
+
+typedef long long             jlong;
+typedef unsigned long long    julong;
+#define jlong_MAXINT          0x7fffffffffffffffLL
+#define jlong_MININT          0x8000000000000000LL
+#define jlong_ZERO            0x0LL
+
+#endif
+
+#define jlong_IS_ZERO(a)	((a) == 0)
+#define jlong_EQ(a, b)		((a) == (b))
+#define jlong_NE(a, b)		((a) != (b))
+#define jlong_GE_ZERO(a)	((a) >= 0)
+#define jlong_CMP(a, op, b)	((a) op (b))
+
+#define jlong_AND(r, a, b)	((r) = (a) & (b))
+#define jlong_OR(r, a, b)	((r) = (a) | (b))
+#define jlong_XOR(r, a, b)	((r) = (a) ^ (b))
+#define jlong_OR2(r, a)		((r) = (r) | (a))
+#define jlong_NOT(r, a)		((r) = ~(a))
+
+#define jlong_NEG(r, a)		((r) = -(a))
+#define jlong_ADD(r, a, b)	((r) = (a) + (b))
+#define jlong_SUB(r, a, b)	((r) = (a) - (b))
+
+#define jlong_MUL(r, a, b)	((r) = (a) * (b))
+#define jlong_DIV(r, a, b)	((r) = (a) / (b))
+#define jlong_MOD(r, a, b)	((r) = (a) % (b))
+
+#define jlong_SHL(r, a, b)	((r) = (a) << (b))
+#define jlong_SHR(r, a, b)	((r) = (a) >> (b))
+#define jlong_USHR(r, a, b)	((r) = (julong)(a) >> (b))
+#define jlong_ISHL(r, a, b)	((r) = ((jlong)(a)) << (b))
+
+#define jlong_L2I(i, l)		((i) = (int)(l))
+#define jlong_L2UI(ui, l)	((ui) =(unsigned int)(l))
+#define jlong_L2F(f, l)		((f) = (l))
+#define jlong_L2D(d, l)		((d) = (l))
+
+#define jlong_I2L(l, i)		((l) = (i))
+#define jlong_UI2L(l, ui)	((l) = (ui))
+#define jlong_F2L(l, f)		((l) = (f))
+#define jlong_D2L(l, d)		((l) = (d))
+
+#define jlong_UDIVMOD(qp, rp, a, b)  \
+    (*(qp) = ((julong)(a) / (b)), \
+     *(rp) = ((julong)(a) % (b)))
+
+#else  /* !HAVE_LONG_LONG */
+
+typedef struct {
+#ifdef IS_LITTLE_ENDIAN
+    juint lo, hi;
+#else
+    juint hi, lo;
+#endif
+} jlong;
+typedef jlong				julong;
+
+extern jlong jlong_MAXINT, jlong_MININT, jlong_ZERO;
+
+#define jlong_IS_ZERO(a)	(((a).hi == 0) && ((a).lo == 0))
+#define jlong_EQ(a, b)		(((a).hi == (b).hi) && ((a).lo == (b).lo))
+#define jlong_NE(a, b)		(((a).hi != (b).hi) || ((a).lo != (b).lo))
+#define jlong_GE_ZERO(a)	(((a).hi >> 31) == 0)
+
+/*
+ * NB: jlong_CMP and jlong_UCMP work only for strict relationals (<, >).
+ */
+#define jlong_CMP(a, op, b)	(((int32)(a).hi op (int32)(b).hi) ||          \
+				 (((a).hi == (b).hi) && ((a).lo op (b).lo)))
+#define jlong_UCMP(a, op, b)	(((a).hi op (b).hi) ||                    \
+				 (((a).hi == (b).hi) && ((a).lo op (b).lo)))
+
+#define jlong_AND(r, a, b)	((r).lo = (a).lo & (b).lo,                    \
+				 (r).hi = (a).hi & (b).hi)
+#define jlong_OR(r, a, b)	((r).lo = (a).lo | (b).lo,                    \
+				 (r).hi = (a).hi | (b).hi)
+#define jlong_XOR(r, a, b)	((r).lo = (a).lo ^ (b).lo,                    \
+				 (r).hi = (a).hi ^ (b).hi)
+#define jlong_OR2(r, a)		((r).lo = (r).lo | (a).lo,                    \
+				 (r).hi = (r).hi | (a).hi)
+#define jlong_NOT(r, a)		((r).lo = ~(a).lo,	                          \
+				 (r).hi = ~(a).hi)
+
+#define jlong_NEG(r, a)		((r).lo = -(int32)(a).lo,                     \
+				 (r).hi = -(int32)(a).hi - ((r).lo != 0))
+#define jlong_ADD(r, a, b) {                                              \
+    jlong _a, _b;                                                         \
+    _a = a; _b = b;                                                       \
+    (r).lo = _a.lo + _b.lo;                                               \
+    (r).hi = _a.hi + _b.hi + ((r).lo < _b.lo);                            \
+}
+
+#define jlong_SUB(r, a, b) {                                              \
+    jlong _a, _b;                                                         \
+    _a = a; _b = b;                                                       \
+    (r).lo = _a.lo - _b.lo;                                               \
+    (r).hi = _a.hi - _b.hi - (_a.lo < _b.lo);                             \
+}                                                                         \
+
+/*
+ * Multiply 64-bit operands a and b to get 64-bit result r.
+ * First multiply the low 32 bits of a and b to get a 64-bit result in r.
+ * Then add the outer and inner products to r.hi.
+ */
+#define jlong_MUL(r, a, b) {                                              \
+    jlong _a, _b;                                                         \
+    _a = a; _b = b;                                                       \
+    jlong_MUL32(r, _a.lo, _b.lo);                                         \
+    (r).hi += _a.hi * _b.lo + _a.lo * _b.hi;                              \
+}
+
+/* XXX _jlong_lo16(a) = ((a) << 16 >> 16) is better on some archs (not on mips) */
+#define _jlong_lo16(a)		((a) & JRI_BITMASK(16))
+#define _jlong_hi16(a)		((a) >> 16)
+
+/*
+ * Multiply 32-bit operands a and b to get 64-bit result r.
+ * Use polynomial expansion based on primitive field element (1 << 16).
+ */
+#define jlong_MUL32(r, a, b) {                                            \
+     juint _a1, _a0, _b1, _b0, _y0, _y1, _y2, _y3;                        \
+     _a1 = _jlong_hi16(a), _a0 = _jlong_lo16(a);                          \
+     _b1 = _jlong_hi16(b), _b0 = _jlong_lo16(b);                          \
+     _y0 = _a0 * _b0;                                                     \
+     _y1 = _a0 * _b1;                                                     \
+     _y2 = _a1 * _b0;                                                     \
+     _y3 = _a1 * _b1;                                                     \
+     _y1 += _jlong_hi16(_y0);                   /* can't carry */         \
+     _y1 += _y2;                                /* might carry */         \
+     if (_y1 < _y2) _y3 += 1 << 16;             /* propagate */           \
+     (r).lo = (_jlong_lo16(_y1) << 16) + _jlong_lo16(_y0);                \
+     (r).hi = _y3 + _jlong_hi16(_y1);                                     \
+}
+
+/*
+ * Divide 64-bit unsigned operand a by 64-bit unsigned operand b, setting *qp
+ * to the 64-bit unsigned quotient, and *rp to the 64-bit unsigned remainder.
+ * Minimize effort if one of qp and rp is null.
+ */
+#define jlong_UDIVMOD(qp, rp, a, b)	jlong_udivmod(qp, rp, a, b)
+
+extern JRI_PUBLIC_API(void)
+jlong_udivmod(julong *qp, julong *rp, julong a, julong b);
+
+#define jlong_DIV(r, a, b) {                                              \
+    jlong _a, _b;                                                         \
+    juint _negative = (int32)(a).hi < 0;                                  \
+    if (_negative) {                                                      \
+	jlong_NEG(_a, a);                                                     \
+    } else {                                                              \
+	_a = a;                                                               \
+    }                                                                     \
+    if ((int32)(b).hi < 0) {                                              \
+	_negative ^= 1;                                                       \
+	jlong_NEG(_b, b);                                                     \
+    } else {                                                              \
+	_b = b;                                                               \
+    }                                                                     \
+    jlong_UDIVMOD(&(r), 0, _a, _b);                                       \
+    if (_negative)                                                        \
+	jlong_NEG(r, r);                                                      \
+}
+
+#define jlong_MOD(r, a, b) {                                              \
+    jlong _a, _b;                                                         \
+    juint _negative = (int32)(a).hi < 0;                                  \
+    if (_negative) {                                                      \
+	jlong_NEG(_a, a);                                                     \
+    } else {                                                              \
+	_a = a;                                                               \
+    }                                                                     \
+    if ((int32)(b).hi < 0) {                                              \
+	jlong_NEG(_b, b);                                                     \
+    } else {                                                              \
+	_b = b;                                                               \
+    }                                                                     \
+    jlong_UDIVMOD(0, &(r), _a, _b);                                       \
+    if (_negative)                                                        \
+	jlong_NEG(r, r);                                                      \
+}
+
+/*
+ * NB: b is a juint, not jlong or julong, for the shift ops.
+ */
+#define jlong_SHL(r, a, b) {                                              \
+    if (b) {                                                              \
+	jlong _a;                                                             \
+        _a = a;                                                           \
+        if ((b) < 32) {                                                   \
+	    (r).lo = _a.lo << (b);                                            \
+	    (r).hi = (_a.hi << (b)) | (_a.lo >> (32 - (b)));                  \
+	} else {                                                              \
+	    (r).lo = 0;                                                       \
+	    (r).hi = _a.lo << ((b) & 31);                                     \
+	}                                                                     \
+    } else {                                                              \
+	(r) = (a);                                                            \
+    }                                                                     \
+}
+
+/* a is an int32, b is int32, r is jlong */
+#define jlong_ISHL(r, a, b) {                                             \
+    if (b) {                                                              \
+	jlong _a;                                                             \
+	_a.lo = (a);                                                          \
+	_a.hi = 0;                                                            \
+        if ((b) < 32) {                                                   \
+	    (r).lo = (a) << (b);                                              \
+	    (r).hi = ((a) >> (32 - (b)));                                     \
+	} else {                                                              \
+	    (r).lo = 0;                                                       \
+	    (r).hi = (a) << ((b) & 31);                                       \
+	}                                                                     \
+    } else {                                                              \
+	(r).lo = (a);                                                         \
+	(r).hi = 0;                                                           \
+    }                                                                     \
+}
+
+#define jlong_SHR(r, a, b) {                                              \
+    if (b) {                                                              \
+	jlong _a;                                                             \
+        _a = a;                                                           \
+	if ((b) < 32) {                                                       \
+	    (r).lo = (_a.hi << (32 - (b))) | (_a.lo >> (b));                  \
+	    (r).hi = (int32)_a.hi >> (b);                                     \
+	} else {                                                              \
+	    (r).lo = (int32)_a.hi >> ((b) & 31);                              \
+	    (r).hi = (int32)_a.hi >> 31;                                      \
+	}                                                                     \
+    } else {                                                              \
+	(r) = (a);                                                            \
+    }                                                                     \
+}
+
+#define jlong_USHR(r, a, b) {                                             \
+    if (b) {                                                              \
+	jlong _a;                                                             \
+        _a = a;                                                           \
+	if ((b) < 32) {                                                       \
+	    (r).lo = (_a.hi << (32 - (b))) | (_a.lo >> (b));                  \
+	    (r).hi = _a.hi >> (b);                                            \
+	} else {                                                              \
+	    (r).lo = _a.hi >> ((b) & 31);                                     \
+	    (r).hi = 0;                                                       \
+	}                                                                     \
+    } else {                                                              \
+	(r) = (a);                                                            \
+    }                                                                     \
+}
+
+#define jlong_L2I(i, l)		((i) = (l).lo)
+#define jlong_L2UI(ui, l)	((ui) = (l).lo)
+#define jlong_L2F(f, l)		{ double _d; jlong_L2D(_d, l); (f) = (float) _d; }
+
+#define jlong_L2D(d, l) {                                                 \
+    int32 _negative;                                                      \
+    jlong _absval;                                                        \
+                                                                          \
+    _negative = (l).hi >> 31;                                             \
+    if (_negative) {                                                      \
+	jlong_NEG(_absval, l);                                                \
+    } else {                                                              \
+	_absval = l;                                                          \
+    }                                                                     \
+    (d) = (double)_absval.hi * 4.294967296e9 + _absval.lo;                \
+    if (_negative)                                                        \
+	(d) = -(d);                                                           \
+}
+
+#define jlong_I2L(l, i)		((l).hi = (i) >> 31, (l).lo = (i))
+#define jlong_UI2L(l, ui)	((l).hi = 0, (l).lo = (ui))
+#define jlong_F2L(l, f)		{ double _d = (double) f; jlong_D2L(l, _d); }
+
+#define jlong_D2L(l, d) {                                                 \
+    int _negative;                                                        \
+    double _absval, _d_hi;                                                \
+    jlong _lo_d;                                                          \
+                                                                          \
+    _negative = ((d) < 0);                                                \
+    _absval = _negative ? -(d) : (d);                                     \
+                                                                          \
+    (l).hi = (juint)(_absval / 4.294967296e9);                            \
+    (l).lo = 0;                                                           \
+    jlong_L2D(_d_hi, l);                                                  \
+    _absval -= _d_hi;                                                     \
+    _lo_d.hi = 0;                                                         \
+    if (_absval < 0) {                                                    \
+	_lo_d.lo = (juint) -_absval;                                          \
+	jlong_SUB(l, l, _lo_d);                                               \
+    } else {                                                              \
+	_lo_d.lo = (juint) _absval;                                           \
+	jlong_ADD(l, l, _lo_d);                                               \
+    }                                                                     \
+                                                                          \
+    if (_negative)                                                        \
+	jlong_NEG(l, l);                                                      \
+}
+
+#endif /* !HAVE_LONG_LONG */
+
+/******************************************************************************/
+
+#ifdef HAVE_ALIGNED_LONGLONGS
+#define JRI_GET_INT64(_t,_addr) ( ((_t).x[0] = ((jint*)(_addr))[0]), \
+                              ((_t).x[1] = ((jint*)(_addr))[1]),      \
+                              (_t).l )
+#define JRI_SET_INT64(_t, _addr, _v) ( (_t).l = (_v),                \
+                                   ((jint*)(_addr))[0] = (_t).x[0], \
+                                   ((jint*)(_addr))[1] = (_t).x[1] )
+#else
+#define JRI_GET_INT64(_t,_addr) (*(jlong*)(_addr))
+#define JRI_SET_INT64(_t, _addr, _v) (*(jlong*)(_addr) = (_v))
+#endif
+
+/* If double's must be aligned on doubleword boundaries then define this */
+#ifdef HAVE_ALIGNED_DOUBLES
+#define JRI_GET_DOUBLE(_t,_addr) ( ((_t).x[0] = ((jint*)(_addr))[0]), \
+                               ((_t).x[1] = ((jint*)(_addr))[1]),      \
+                               (_t).d )
+#define JRI_SET_DOUBLE(_t, _addr, _v) ( (_t).d = (_v),                \
+                                    ((jint*)(_addr))[0] = (_t).x[0], \
+                                    ((jint*)(_addr))[1] = (_t).x[1] )
+#else
+#define JRI_GET_DOUBLE(_t,_addr) (*(jdouble*)(_addr))
+#define JRI_SET_DOUBLE(_t, _addr, _v) (*(jdouble*)(_addr) = (_v))
+#endif
+
+/******************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+#endif /* JRI_MD_H */
+/******************************************************************************/
diff -Nur mplayerplug-in-3.55-orig/include/jritypes.h mplayerplug-in-3.55/include/jritypes.h
--- mplayerplug-in-3.55-orig/include/jritypes.h	1970-01-01 07:00:00.000000000 +0700
+++ mplayerplug-in-3.55/include/jritypes.h	2007-08-04 02:59:37.000000000 +0700
@@ -0,0 +1,243 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: NPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Netscape Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/NPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is 
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or 
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the NPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the NPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*******************************************************************************
+ * Java Runtime Interface
+ ******************************************************************************/
+
+#ifndef JRITYPES_H
+#define JRITYPES_H
+
+#include "jri_md.h"
+#include "jni.h"
+#include <stddef.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+ * Types
+ ******************************************************************************/
+
+struct JRIEnvInterface;
+
+typedef void*		JRIRef;
+typedef void*		JRIGlobalRef;
+
+typedef jint		JRIFieldID;
+typedef jint		JRIMethodID;
+
+/* synonyms: */
+typedef JRIGlobalRef	jglobal;
+
+typedef union JRIValue {
+	jbool			z;
+	jbyte			b;
+	jchar			c;
+	jshort			s;
+	jint			i;
+	jlong			l;
+	jfloat			f;
+	jdouble			d;
+	jref			r;
+} JRIValue;
+
+typedef enum JRIBoolean {
+    JRIFalse		= 0,
+    JRITrue			= 1
+} JRIBoolean;
+
+typedef enum JRIConstant {
+	JRIUninitialized	= -1
+} JRIConstant;
+
+/* convenience types (these must be distinct struct types for c++ overloading): */
+#if 0	/* now in jni.h */
+typedef struct jbooleanArrayStruct*		jbooleanArray;
+typedef struct jbyteArrayStruct*		jbyteArray;
+typedef struct jcharArrayStruct*		jcharArray;
+typedef struct jshortArrayStruct*		jshortArray;
+typedef struct jintArrayStruct*			jintArray;
+typedef struct jlongArrayStruct*		jlongArray;
+typedef struct jfloatArrayStruct*		jfloatArray;
+typedef struct jdoubleArrayStruct*		jdoubleArray;
+typedef struct jobjectArrayStruct*		jobjectArray;
+#endif
+typedef struct jstringArrayStruct*		jstringArray;
+typedef struct jarrayArrayStruct*		jarrayArray;
+
+#define JRIConstructorMethodName	"<init>"
+
+/*******************************************************************************
+ * Signature Construction Macros
+ ******************************************************************************/
+
+/*
+** These macros can be used to construct signature strings. Hopefully their names
+** are a little easier to remember than the single character they correspond to.
+** For example, to specify the signature of the method:
+**
+**	public int read(byte b[], int off, int len);
+**
+** you could write something like this in C:
+**
+**	char* readSig = JRISigMethod(JRISigArray(JRISigByte)
+**								 JRISigInt
+**								 JRISigInt) JRISigInt;
+**
+** Of course, don't put commas between the types.
+*/
+#define JRISigArray(T)		"[" T
+#define JRISigByte			"B"
+#define JRISigChar			"C"
+#define JRISigClass(name)	"L" name ";"
+#define JRISigFloat			"F"
+#define JRISigDouble		"D"
+#define JRISigMethod(args)	"(" args ")"
+#define JRISigNoArgs		""
+#define JRISigInt			"I"
+#define JRISigLong			"J"
+#define JRISigShort			"S"
+#define JRISigVoid			"V"
+#define JRISigBoolean		"Z"
+
+/*******************************************************************************
+ * Environments
+ ******************************************************************************/
+
+extern JRI_PUBLIC_API(const struct JRIEnvInterface**)
+JRI_GetCurrentEnv(void);
+
+/*******************************************************************************
+ * Specific Scalar Array Types
+ ******************************************************************************/
+
+/*
+** The JRI Native Method Interface does not support boolean arrays. This
+** is to allow Java runtime implementations to optimize boolean array
+** storage. Using the ScalarArray operations on boolean arrays is bound
+** to fail, so convert any boolean arrays to byte arrays in Java before
+** passing them to a native method.
+*/
+
+#define JRI_NewByteArray(env, length, initialValues)	\
+	JRI_NewScalarArray(env, length, JRISigByte, (jbyte*)(initialValues))
+#define JRI_GetByteArrayLength(env, array)	\
+	JRI_GetScalarArrayLength(env, array)
+#define JRI_GetByteArrayElements(env, array)	\
+	JRI_GetScalarArrayElements(env, array)
+
+#define JRI_NewCharArray(env, length, initialValues)	\
+	JRI_NewScalarArray(env, ((length) * sizeof(jchar)), JRISigChar, (jbyte*)(initialValues))
+#define JRI_GetCharArrayLength(env, array)	\
+	JRI_GetScalarArrayLength(env, array)
+#define JRI_GetCharArrayElements(env, array)		   \
+	((jchar*)JRI_GetScalarArrayElements(env, array))
+
+#define JRI_NewShortArray(env, length, initialValues)	\
+	JRI_NewScalarArray(env, ((length) * sizeof(jshort)), JRISigShort, (jbyte*)(initialValues))
+#define JRI_GetShortArrayLength(env, array)	\
+	JRI_GetScalarArrayLength(env, array)
+#define JRI_GetShortArrayElements(env, array)		   \
+	((jshort*)JRI_GetScalarArrayElements(env, array))
+
+#define JRI_NewIntArray(env, length, initialValues)	\
+	JRI_NewScalarArray(env, ((length) * sizeof(jint)), JRISigInt, (jbyte*)(initialValues))
+#define JRI_GetIntArrayLength(env, array)	\
+	JRI_GetScalarArrayLength(env, array)
+#define JRI_GetIntArrayElements(env, array)		   \
+	((jint*)JRI_GetScalarArrayElements(env, array))
+
+#define JRI_NewLongArray(env, length, initialValues)	\
+	JRI_NewScalarArray(env, ((length) * sizeof(jlong)), JRISigLong, (jbyte*)(initialValues))
+#define JRI_GetLongArrayLength(env, array)	\
+	JRI_GetScalarArrayLength(env, array)
+#define JRI_GetLongArrayElements(env, array)		   \
+	((jlong*)JRI_GetScalarArrayElements(env, array))
+
+#define JRI_NewFloatArray(env, length, initialValues)	\
+	JRI_NewScalarArray(env, ((length) * sizeof(jfloat)), JRISigFloat, (jbyte*)(initialValues))
+#define JRI_GetFloatArrayLength(env, array)	\
+	JRI_GetScalarArrayLength(env, array)
+#define JRI_GetFloatArrayElements(env, array)		   \
+	((jfloat*)JRI_GetScalarArrayElements(env, array))
+
+#define JRI_NewDoubleArray(env, length, initialValues)	\
+	JRI_NewScalarArray(env, ((length) * sizeof(jdouble)), JRISigDouble, (jbyte*)(initialValues))
+#define JRI_GetDoubleArrayLength(env, array)	\
+	JRI_GetScalarArrayLength(env, array)
+#define JRI_GetDoubleArrayElements(env, array)		   \
+	((jdouble*)JRI_GetScalarArrayElements(env, array))
+
+/******************************************************************************/
+/*
+** JDK Stuff -- This stuff is still needed while we're using the JDK
+** dynamic linking strategy to call native methods.
+*/
+
+typedef union JRI_JDK_stack_item {
+    /* Non pointer items */
+    jint           i;
+    jfloat         f;
+    jint           o;
+    /* Pointer items */
+    void          *h;
+    void          *p;
+    unsigned char *addr;
+#ifdef IS_64
+    double         d;
+    long           l;		/* == 64bits! */
+#endif
+} JRI_JDK_stack_item;
+
+typedef union JRI_JDK_Java8Str {
+    jint x[2];
+    jdouble d;
+    jlong l;
+    void *p;
+    float f;
+} JRI_JDK_Java8;
+
+/******************************************************************************/
+#ifdef __cplusplus
+}
+#endif
+#endif /* JRITYPES_H */
+/******************************************************************************/
diff -Nur mplayerplug-in-3.55-orig/include/npapi.h mplayerplug-in-3.55/include/npapi.h
--- mplayerplug-in-3.55-orig/include/npapi.h	1970-01-01 07:00:00.000000000 +0700
+++ mplayerplug-in-3.55/include/npapi.h	2008-05-27 15:59:03.000000000 +0700
@@ -0,0 +1,728 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+/*
+ *  npapi.h $Revision: 3.40.4.1 $
+ *  Netscape client plug-in API spec
+ */
+
+#ifndef _NPAPI_H_
+#define _NPAPI_H_
+
+#ifdef __OS2__
+#pragma pack(1)
+#endif
+
+#include "prtypes.h"
+/* Copied from xp_core.h */
+/* removed #ifdef for hpux defined in /usr/include/model.h */
+#ifndef XP_MAC
+#ifndef _INT16
+#define _INT16
+#endif
+#ifndef _INT32
+#define _INT32
+#endif
+#ifndef _UINT16
+#define _UINT16
+#endif
+#ifndef _UINT32
+#define _UINT32
+#endif
+#endif
+
+/* 
+ * NO_NSPR_10_SUPPORT disables the inclusion 
+ * of obsolete/protypes.h, whose int16, uint16, 
+ * int32, and uint32 typedefs conflict with those 
+ * in this file. 
+ */ 
+#ifndef NO_NSPR_10_SUPPORT
+#define NO_NSPR_10_SUPPORT
+#endif
+#ifdef OJI
+#include "jri.h"                /* Java Runtime Interface */
+#endif
+
+#if defined (__OS2__ ) || defined (OS2)
+#	ifndef XP_OS2
+#		define XP_OS2 1
+#	endif /* XP_OS2 */
+#endif /* __OS2__ */
+
+#ifdef _WINDOWS
+#	include <windef.h>
+#	ifndef XP_WIN
+#		define XP_WIN 1
+#	endif /* XP_WIN */
+#endif /* _WINDOWS */
+
+#ifdef __MWERKS__
+#	define _declspec __declspec
+#	ifdef macintosh
+#		ifndef XP_MAC
+#			define XP_MAC 1
+#		endif /* XP_MAC */
+#	endif /* macintosh */
+#	ifdef __INTEL__
+#		undef NULL
+#		ifndef XP_WIN
+#			define XP_WIN 1
+#		endif /* XP_WIN */
+#	endif /* __INTEL__ */
+#endif /* __MWERKS__ */
+
+#if defined(XP_MAC) || defined(XP_MACOSX)
+	#include <Quickdraw.h>
+	#include <Events.h>
+#endif
+
+#if defined(XP_UNIX) 
+#	include <stdio.h>
+#	if defined(MOZ_X11)
+#		include <X11/Xlib.h>
+#		include <X11/Xutil.h>
+#	endif
+#endif
+
+/*----------------------------------------------------------------------*/
+/*                        Plugin Version Constants                      */
+/*----------------------------------------------------------------------*/
+
+#define NP_VERSION_MAJOR 0
+#define NP_VERSION_MINOR 16
+
+
+/* The OS/2 version of Netscape uses RC_DATA to define the
+   mime types, file extensions, etc that are required.
+   Use a vertical bar to separate types, end types with \0.
+   FileVersion and ProductVersion are 32bit ints, all other
+   entries are strings the MUST be terminated wwith a \0.
+
+AN EXAMPLE:
+
+RCDATA NP_INFO_ProductVersion { 1,0,0,1,}
+
+RCDATA NP_INFO_MIMEType    { "video/x-video|",
+                             "video/x-flick\0" }
+RCDATA NP_INFO_FileExtents { "avi|",
+                             "flc\0" }
+RCDATA NP_INFO_FileOpenName{ "MMOS2 video player(*.avi)|",
+                             "MMOS2 Flc/Fli player(*.flc)\0" }
+
+RCDATA NP_INFO_FileVersion       { 1,0,0,1 }
+RCDATA NP_INFO_CompanyName       { "Netscape Communications\0" }
+RCDATA NP_INFO_FileDescription   { "NPAVI32 Extension DLL\0"
+RCDATA NP_INFO_InternalName      { "NPAVI32\0" )
+RCDATA NP_INFO_LegalCopyright    { "Copyright Netscape Communications \251 1996\0"
+RCDATA NP_INFO_OriginalFilename  { "NVAPI32.DLL" }
+RCDATA NP_INFO_ProductName       { "NPAVI32 Dynamic Link Library\0" }
+
+*/
+
+
+/* RC_DATA types for version info - required */
+#define NP_INFO_ProductVersion      1
+#define NP_INFO_MIMEType            2
+#define NP_INFO_FileOpenName        3
+#define NP_INFO_FileExtents         4
+
+/* RC_DATA types for version info - used if found */
+#define NP_INFO_FileDescription     5
+#define NP_INFO_ProductName         6
+
+/* RC_DATA types for version info - optional */
+#define NP_INFO_CompanyName         7
+#define NP_INFO_FileVersion         8
+#define NP_INFO_InternalName        9
+#define NP_INFO_LegalCopyright      10
+#define NP_INFO_OriginalFilename    11
+
+#ifndef RC_INVOKED
+
+
+
+/*----------------------------------------------------------------------*/
+/*                       Definition of Basic Types                      */
+/*----------------------------------------------------------------------*/
+
+#ifndef _UINT16
+typedef unsigned short uint16;
+#endif
+
+#ifndef _UINT32
+#    if defined(__alpha) || defined(__amd64__) || defined(__x86_64__)
+typedef unsigned int uint32;
+#    else  /* __alpha */
+typedef unsigned long uint32;
+#    endif /* __alpha */
+#endif
+
+/*
+ * AIX defines these in sys/inttypes.h included from sys/types.h
+ */
+#ifndef AIX
+#ifndef _INT16
+typedef short int16;
+#endif
+
+#ifndef _INT32
+#    if defined(__alpha) || defined(__amd64__) || defined(__x86_64__)
+typedef int int32;
+#    else  /* __alpha */
+typedef long int32;
+#    endif /* __alpha */
+#endif
+#endif
+
+#ifndef FALSE
+#define FALSE (0)
+#endif
+#ifndef TRUE
+#define TRUE (1)
+#endif
+#ifndef NULL
+#define NULL (0L)
+#endif
+
+typedef unsigned char	NPBool;
+typedef int16			NPError;
+typedef int16			NPReason;
+typedef char*			NPMIMEType;
+
+
+
+/*----------------------------------------------------------------------*/
+/*                       Structures and definitions                     */
+/*----------------------------------------------------------------------*/
+
+#ifdef XP_MAC
+#pragma options align=mac68k
+#endif
+
+/*
+ *  NPP is a plug-in's opaque instance handle
+ */
+typedef struct _NPP
+{
+  void*	pdata;      /* plug-in private data */
+  void*	ndata;      /* netscape private data */
+} NPP_t;
+
+typedef NPP_t*  NPP;
+
+
+typedef struct _NPStream
+{
+  void*  pdata; /* plug-in private data */
+  void*  ndata; /* netscape private data */
+  const  char* url;
+  uint32 end;
+  uint32 lastmodified;
+  void*  notifyData;
+} NPStream;
+
+
+typedef struct _NPByteRange
+{
+  int32  offset; /* negative offset means from the end */
+  uint32 length;
+  struct _NPByteRange* next;
+} NPByteRange;
+
+
+typedef struct _NPSavedData
+{
+  int32	len;
+  void*	buf;
+} NPSavedData;
+
+
+typedef struct _NPRect
+{
+  uint16 top;
+  uint16 left;
+  uint16 bottom;
+  uint16 right;
+} NPRect;
+
+typedef struct _NPSize 
+{ 
+  int32 width; 
+  int32 height; 
+} NPSize; 
+
+#ifdef XP_UNIX
+/*
+ * Unix specific structures and definitions
+ */
+
+/*
+ * Callback Structures.
+ *
+ * These are used to pass additional platform specific information.
+ */
+enum {
+  NP_SETWINDOW = 1,
+  NP_PRINT
+};
+
+typedef struct
+{
+  int32 type;
+} NPAnyCallbackStruct;
+
+typedef struct
+{
+  int32        type;
+#ifdef MOZ_X11
+  Display*     display;
+  Visual*      visual;
+  Colormap     colormap;
+  unsigned int depth;
+#endif
+} NPSetWindowCallbackStruct;
+
+typedef struct
+{
+  int32 type;
+  FILE* fp;
+} NPPrintCallbackStruct;
+
+#endif /* XP_UNIX */
+
+
+/*
+ *   The following masks are applied on certain platforms to NPNV and 
+ *   NPPV selectors that pass around pointers to COM interfaces. Newer 
+ *   compilers on some platforms may generate vtables that are not 
+ *   compatible with older compilers. To prevent older plugins from 
+ *   not understanding a new browser's ABI, these masks change the 
+ *   values of those selectors on those platforms. To remain backwards
+ *   compatible with differenet versions of the browser, plugins can 
+ *   use these masks to dynamically determine and use the correct C++
+ *   ABI that the browser is expecting. This does not apply to Windows 
+ *   as Microsoft's COM ABI will likely not change.
+ */
+
+#define NP_ABI_GCC3_MASK  0x10000000
+/*
+ *   gcc 3.x generated vtables on UNIX and OSX are incompatible with 
+ *   previous compilers.
+ */
+#if (defined (XP_UNIX) && defined(__GNUC__) && (__GNUC__ >= 3))
+#define _NP_ABI_MIXIN_FOR_GCC3 NP_ABI_GCC3_MASK
+#else
+#define _NP_ABI_MIXIN_FOR_GCC3 0
+#endif
+
+
+#define NP_ABI_MACHO_MASK 0x01000000
+/*
+ *   On OSX, the Mach-O executable format is significantly
+ *   different than CFM. In addition to having a different
+ *   C++ ABI, it also has has different C calling convention.
+ *   You must use glue code when calling between CFM and
+ *   Mach-O C functions. 
+ */
+#if (defined(TARGET_RT_MAC_MACHO))
+#define _NP_ABI_MIXIN_FOR_MACHO NP_ABI_MACHO_MASK
+#else
+#define _NP_ABI_MIXIN_FOR_MACHO 0
+#endif
+
+
+#define NP_ABI_MASK (_NP_ABI_MIXIN_FOR_GCC3 | _NP_ABI_MIXIN_FOR_MACHO)
+
+/*
+ * List of variable names for which NPP_GetValue shall be implemented
+ */
+typedef enum {
+  NPPVpluginNameString = 1,
+  NPPVpluginDescriptionString,
+  NPPVpluginWindowBool,
+  NPPVpluginTransparentBool,
+  NPPVjavaClass,                /* Not implemented in Mozilla 1.0 */
+  NPPVpluginWindowSize,
+  NPPVpluginTimerInterval,
+
+  NPPVpluginScriptableInstance = (10 | NP_ABI_MASK),
+  NPPVpluginScriptableIID = 11,
+
+  /* Introduced in Mozilla 0.9.9 */
+  NPPVjavascriptPushCallerBool = 12,
+
+  /* Introduced in Mozilla 1.0 */
+  NPPVpluginKeepLibraryInMemory = 13,
+  NPPVpluginNeedsXEmbed         = 14,
+
+  /* Get the NPObject for scripting the plugin. Introduced in Firefox
+   * 1.0 (NPAPI minor version 14).
+   */
+  NPPVpluginScriptableNPObject  = 15,
+
+  /* Get the plugin value (as \0-terminated UTF-8 string data) for
+   * form submission if the plugin is part of a form. Use
+   * NPN_MemAlloc() to allocate memory for the string data. Introduced
+   * in Mozilla 1.8b2 (NPAPI minor version 15).
+   */
+  NPPVformValue = 16
+} NPPVariable;
+
+/*
+ * List of variable names for which NPN_GetValue is implemented by Mozilla
+ */
+typedef enum {
+  NPNVxDisplay = 1,
+  NPNVxtAppContext,
+  NPNVnetscapeWindow,
+  NPNVjavascriptEnabledBool,
+  NPNVasdEnabledBool,
+  NPNVisOfflineBool,
+
+  /* 10 and over are available on Mozilla builds starting with 0.9.4 */
+  NPNVserviceManager = (10 | NP_ABI_MASK),
+  NPNVDOMElement     = (11 | NP_ABI_MASK),   /* available in Mozilla 1.2 */
+  NPNVDOMWindow      = (12 | NP_ABI_MASK),
+  NPNVToolkit        = (13 | NP_ABI_MASK),
+  NPNVSupportsXEmbedBool = 14,
+
+  /* Get the NPObject wrapper for the browser window. */
+  NPNVWindowNPObject = 15,
+
+  /* Get the NPObject wrapper for the plugins DOM element. */
+  NPNVPluginElementNPObject = 16,
+
+  NPNVSupportsWindowless = 17
+} NPNVariable;
+
+/*
+ * The type of Tookkit the widgets use
+ */
+typedef enum {
+  NPNVGtk12 = 1,
+  NPNVGtk2
+} NPNToolkitType;
+
+/*
+ * The type of a NPWindow - it specifies the type of the data structure
+ * returned in the window field.
+ */
+typedef enum {
+  NPWindowTypeWindow = 1,
+  NPWindowTypeDrawable
+} NPWindowType;
+
+typedef struct _NPWindow
+{
+  void* window;  /* Platform specific window handle */
+                 /* OS/2: x - Position of bottom left corner  */
+                 /* OS/2: y - relative to visible netscape window */
+  int32 x;       /* Position of top left corner relative */
+  int32 y;       /* to a netscape page.					*/
+  uint32 width;  /* Maximum window size */
+  uint32 height;
+  NPRect clipRect; /* Clipping rectangle in port coordinates */
+                   /* Used by MAC only.			  */
+#if defined(XP_UNIX) && !defined(XP_MACOSX)
+  void * ws_info; /* Platform-dependent additonal data */
+#endif /* XP_UNIX */
+  NPWindowType type; /* Is this a window or a drawable? */
+} NPWindow;
+
+
+typedef struct _NPFullPrint
+{
+  NPBool pluginPrinted;/* Set TRUE if plugin handled fullscreen printing */
+  NPBool printOne;		 /* TRUE if plugin should print one copy to default printer */
+  void* platformPrint; /* Platform-specific printing info */
+} NPFullPrint;
+
+typedef struct _NPEmbedPrint
+{
+  NPWindow window;
+  void* platformPrint; /* Platform-specific printing info */
+} NPEmbedPrint;
+
+typedef struct _NPPrint
+{
+  uint16 mode;               /* NP_FULL or NP_EMBED */
+  union
+  {
+    NPFullPrint fullPrint;   /* if mode is NP_FULL */
+    NPEmbedPrint embedPrint; /* if mode is NP_EMBED */
+  } print;
+} NPPrint;
+
+#if defined(XP_MAC) || defined(XP_MACOSX)
+typedef EventRecord	NPEvent;
+#elif defined(XP_WIN)
+typedef struct _NPEvent
+{
+  uint16 event;
+  uint32 wParam;
+  uint32 lParam;
+} NPEvent;
+#elif defined(XP_OS2)
+typedef struct _NPEvent
+{
+  uint32 event;
+  uint32 wParam;
+  uint32 lParam;
+} NPEvent;
+#elif defined (XP_UNIX) && defined(MOZ_X11)
+typedef XEvent NPEvent;
+#else
+typedef void*			NPEvent;
+#endif /* XP_MAC */
+
+#if defined(XP_MAC) || defined(XP_MACOSX)
+typedef RgnHandle NPRegion;
+#elif defined(XP_WIN)
+typedef HRGN NPRegion;
+#elif defined(XP_UNIX) && defined(MOZ_X11)
+typedef Region NPRegion;
+#else
+typedef void *NPRegion;
+#endif /* XP_MAC */
+
+#if defined(XP_MAC) || defined(XP_MACOSX)
+/*
+ *  Mac-specific structures and definitions.
+ */
+
+typedef struct NP_Port
+{
+  CGrafPtr port; /* Grafport */
+  int32 portx;   /* position inside the topmost window */
+  int32 porty;
+} NP_Port;
+
+/*
+ *  Non-standard event types that can be passed to HandleEvent
+ */
+
+enum NPEventType {
+  NPEventType_GetFocusEvent = (osEvt + 16),
+  NPEventType_LoseFocusEvent,
+  NPEventType_AdjustCursorEvent,
+  NPEventType_MenuCommandEvent,
+  NPEventType_ClippingChangedEvent,
+  NPEventType_ScrollingBeginsEvent = 1000,
+  NPEventType_ScrollingEndsEvent
+};
+
+#ifdef OBSOLETE
+#define getFocusEvent     (osEvt + 16)
+#define loseFocusEvent    (osEvt + 17)
+#define adjustCursorEvent (osEvt + 18)
+#endif
+#endif /* XP_MAC */
+
+/*
+ * Values for mode passed to NPP_New:
+ */
+#define NP_EMBED 1
+#define NP_FULL  2
+
+/*
+ * Values for stream type passed to NPP_NewStream:
+ */
+#define NP_NORMAL     1
+#define NP_SEEK       2
+#define NP_ASFILE     3
+#define NP_ASFILEONLY 4
+
+#define NP_MAXREADY	(((unsigned)(~0)<<1)>>1)
+
+#ifdef XP_MAC
+#pragma options align=reset
+#endif
+
+
+/*----------------------------------------------------------------------*/
+/*		     Error and Reason Code definitions			*/
+/*----------------------------------------------------------------------*/
+
+/*
+ * Values of type NPError:
+ */
+#define NPERR_BASE                         0
+#define NPERR_NO_ERROR                    (NPERR_BASE + 0)
+#define NPERR_GENERIC_ERROR               (NPERR_BASE + 1)
+#define NPERR_INVALID_INSTANCE_ERROR      (NPERR_BASE + 2)
+#define NPERR_INVALID_FUNCTABLE_ERROR     (NPERR_BASE + 3)
+#define NPERR_MODULE_LOAD_FAILED_ERROR    (NPERR_BASE + 4)
+#define NPERR_OUT_OF_MEMORY_ERROR         (NPERR_BASE + 5)
+#define NPERR_INVALID_PLUGIN_ERROR        (NPERR_BASE + 6)
+#define NPERR_INVALID_PLUGIN_DIR_ERROR    (NPERR_BASE + 7)
+#define NPERR_INCOMPATIBLE_VERSION_ERROR  (NPERR_BASE + 8)
+#define NPERR_INVALID_PARAM               (NPERR_BASE + 9)
+#define NPERR_INVALID_URL                 (NPERR_BASE + 10)
+#define NPERR_FILE_NOT_FOUND              (NPERR_BASE + 11)
+#define NPERR_NO_DATA                     (NPERR_BASE + 12)
+#define NPERR_STREAM_NOT_SEEKABLE         (NPERR_BASE + 13)
+
+/*
+ * Values of type NPReason:
+ */
+#define NPRES_BASE          0
+#define NPRES_DONE         (NPRES_BASE + 0)
+#define NPRES_NETWORK_ERR  (NPRES_BASE + 1)
+#define NPRES_USER_BREAK   (NPRES_BASE + 2)
+
+/*
+ * Don't use these obsolete error codes any more.
+ */
+#define NP_NOERR  NP_NOERR_is_obsolete_use_NPERR_NO_ERROR
+#define NP_EINVAL NP_EINVAL_is_obsolete_use_NPERR_GENERIC_ERROR
+#define NP_EABORT NP_EABORT_is_obsolete_use_NPRES_USER_BREAK
+
+/*
+ * Version feature information
+ */
+#define NPVERS_HAS_STREAMOUTPUT      8
+#define NPVERS_HAS_NOTIFICATION      9
+#define NPVERS_HAS_LIVECONNECT       9
+#define NPVERS_WIN16_HAS_LIVECONNECT 9
+#define NPVERS_68K_HAS_LIVECONNECT   11
+#define NPVERS_HAS_WINDOWLESS        11
+#define NPVERS_HAS_XPCONNECT_SCRIPTING 13
+
+/*----------------------------------------------------------------------*/
+/*                        Function Prototypes                           */
+/*----------------------------------------------------------------------*/
+
+#if defined(_WINDOWS) && !defined(WIN32)
+#define NP_LOADDS  _loadds
+#else
+#if defined(__OS2__)
+#define NP_LOADDS _System
+#else
+#define NP_LOADDS
+#endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * NPP_* functions are provided by the plugin and called by the navigator.
+ */
+
+#ifdef XP_UNIX
+char* NPP_GetMIMEDescription(void);
+#endif /* XP_UNIX */
+
+NPError NP_LOADDS NPP_Initialize(void);
+void    NP_LOADDS NPP_Shutdown(void);
+NPError NP_LOADDS NPP_New(NPMIMEType pluginType, NPP instance,
+                          uint16 mode, int16 argc, char* argn[],
+                          char* argv[], NPSavedData* saved);
+NPError NP_LOADDS NPP_Destroy(NPP instance, NPSavedData** save);
+NPError NP_LOADDS NPP_SetWindow(NPP instance, NPWindow* window);
+NPError NP_LOADDS NPP_NewStream(NPP instance, NPMIMEType type,
+                                NPStream* stream, NPBool seekable,
+                                uint16* stype);
+NPError NP_LOADDS NPP_DestroyStream(NPP instance, NPStream* stream,
+                                    NPReason reason);
+int32   NP_LOADDS NPP_WriteReady(NPP instance, NPStream* stream);
+int32   NP_LOADDS NPP_Write(NPP instance, NPStream* stream, int32 offset,
+                            int32 len, void* buffer);
+void    NP_LOADDS NPP_StreamAsFile(NPP instance, NPStream* stream,
+                                   const char* fname);
+void    NP_LOADDS NPP_Print(NPP instance, NPPrint* platformPrint);
+int16   NP_LOADDS NPP_HandleEvent(NPP instance, void* event);
+void    NP_LOADDS NPP_URLNotify(NPP instance, const char* url,
+                                NPReason reason, void* notifyData);
+#ifdef OJI
+jref    NP_LOADDS NPP_GetJavaClass(void);
+#endif
+NPError NP_LOADDS NPP_GetValue(NPP instance, NPPVariable variable, void *value);
+NPError NP_LOADDS NPP_SetValue(NPP instance, NPNVariable variable, void *value);
+
+/*
+ * NPN_* functions are provided by the navigator and called by the plugin.
+ */
+void    NP_LOADDS NPN_Version(int* plugin_major, int* plugin_minor,
+                              int* netscape_major, int* netscape_minor);
+NPError NP_LOADDS NPN_GetURLNotify(NPP instance, const char* url,
+                                   const char* target, void* notifyData);
+NPError NP_LOADDS NPN_GetURL(NPP instance, const char* url,
+                             const char* target);
+NPError NP_LOADDS NPN_PostURLNotify(NPP instance, const char* url,
+                                    const char* target, uint32 len,
+                                    const char* buf, NPBool file,
+                                    void* notifyData);
+NPError NP_LOADDS NPN_PostURL(NPP instance, const char* url,
+                              const char* target, uint32 len,
+                              const char* buf, NPBool file);
+NPError NP_LOADDS NPN_RequestRead(NPStream* stream, NPByteRange* rangeList);
+NPError NP_LOADDS NPN_NewStream(NPP instance, NPMIMEType type,
+                                const char* target, NPStream** stream);
+int32   NP_LOADDS NPN_Write(NPP instance, NPStream* stream, int32 len, void* buffer);
+NPError NP_LOADDS NPN_DestroyStream(NPP instance, NPStream* stream, NPReason reason);
+void    NP_LOADDS NPN_Status(NPP instance, const char* message);
+const char* NP_LOADDS	NPN_UserAgent(NPP instance);
+void*   NP_LOADDS NPN_MemAlloc(uint32 size);
+void    NP_LOADDS NPN_MemFree(void* ptr);
+uint32  NP_LOADDS NPN_MemFlush(uint32 size);
+void    NP_LOADDS NPN_ReloadPlugins(NPBool reloadPages);
+#ifdef OJI
+JRIEnv* NP_LOADDS NPN_GetJavaEnv(void);
+jref    NP_LOADDS NPN_GetJavaPeer(NPP instance);
+#endif
+NPError NP_LOADDS NPN_GetValue(NPP instance, NPNVariable variable, void *value);
+NPError NP_LOADDS NPN_SetValue(NPP instance, NPPVariable variable, void *value);
+void    NP_LOADDS NPN_InvalidateRect(NPP instance, NPRect *invalidRect);
+void    NP_LOADDS NPN_InvalidateRegion(NPP instance, NPRegion invalidRegion);
+void    NP_LOADDS NPN_ForceRedraw(NPP instance);
+void    NP_LOADDS NPN_PushPopupsEnabledState(NPP instance, NPBool enabled);
+void    NP_LOADDS NPN_PopPopupsEnabledState(NPP instance);
+
+#ifdef __cplusplus
+}  /* end extern "C" */
+#endif
+
+#endif /* RC_INVOKED */
+#ifdef __OS2__
+#pragma pack()
+#endif
+
+#endif /* _NPAPI_H_ */
diff -Nur mplayerplug-in-3.55-orig/include/npruntime.h mplayerplug-in-3.55/include/npruntime.h
--- mplayerplug-in-3.55-orig/include/npruntime.h	1970-01-01 07:00:00.000000000 +0700
+++ mplayerplug-in-3.55/include/npruntime.h	2007-08-04 02:59:37.000000000 +0700
@@ -0,0 +1,397 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * Copyright  2004, Apple Computer, Inc. and The Mozilla Foundation. 
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 3. Neither the names of Apple Computer, Inc. ("Apple") or The Mozilla
+ * Foundation ("Mozilla") nor the names of their contributors may be used
+ * to endorse or promote products derived from this software without
+ * specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY APPLE, MOZILLA AND THEIR CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE, MOZILLA OR
+ * THEIR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Revision 1 (March 4, 2004):
+ * Initial proposal.
+ *
+ * Revision 2 (March 10, 2004):
+ * All calls into script were made asynchronous.  Results are
+ * provided via the NPScriptResultFunctionPtr callback.
+ *
+ * Revision 3 (March 10, 2004):
+ * Corrected comments to not refer to class retain/release FunctionPtrs.
+ *
+ * Revision 4 (March 11, 2004):
+ * Added additional convenience NPN_SetExceptionWithUTF8().
+ * Changed NPHasPropertyFunctionPtr and NPHasMethodFunctionPtr to take NPClass
+ * pointers instead of NPObject pointers.
+ * Added NPIsValidIdentifier().
+ *
+ * Revision 5 (March 17, 2004):
+ * Added context parameter to result callbacks from ScriptObject functions.
+ *
+ * Revision 6 (March 29, 2004):
+ * Renamed functions implemented by user agent to NPN_*.  Removed _ from
+ * type names.
+ * Renamed "JavaScript" types to "Script".
+ *
+ * Revision 7 (April 21, 2004):
+ * NPIdentifier becomes a void*, was int32_t
+ * Remove NP_IsValidIdentifier, renamed NP_IdentifierFromUTF8 to NP_GetIdentifier
+ * Added NPVariant and modified functions to use this new type.
+ *
+ * Revision 8 (July 9, 2004):
+ * Updated to joint Apple-Mozilla license.
+ *
+ */
+#ifndef _NP_RUNTIME_H_
+#define _NP_RUNTIME_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "nptypes.h"
+
+/*
+    This API is used to facilitate binding code written in C to script
+    objects.  The API in this header does not assume the presence of a
+    user agent.  That is, it can be used to bind C code to scripting
+    environments outside of the context of a user agent.
+    
+    However, the normal use of the this API is in the context of a
+    scripting environment running in a browser or other user agent.
+    In particular it is used to support the extended Netscape
+    script-ability API for plugins (NP-SAP).  NP-SAP is an extension
+    of the Netscape plugin API.  As such we have adopted the use of
+    the "NP" prefix for this API.
+
+    The following NP{N|P}Variables were added to the Netscape plugin
+    API (in npapi.h):
+
+    NPNVWindowNPObject
+    NPNVPluginElementNPObject
+    NPPVpluginScriptableNPObject
+
+    These variables are exposed through NPN_GetValue() and
+    NPP_GetValue() (respectively) and are used to establish the
+    initial binding between the user agent and native code.  The DOM
+    objects in the user agent can be examined and manipulated using
+    the NPN_ functions that operate on NPObjects described in this
+    header.
+
+    To the extent possible the assumptions about the scripting
+    language used by the scripting environment have been minimized.
+*/
+
+#define NP_BEGIN_MACRO  do {
+#define NP_END_MACRO    } while (0)
+
+/*
+    Objects (non-primitive data) passed between 'C' and script is
+    always wrapped in an NPObject.  The 'interface' of an NPObject is
+    described by an NPClass.
+*/
+typedef struct NPObject NPObject;
+typedef struct NPClass NPClass;
+
+typedef char NPUTF8;
+typedef struct _NPString {
+    const NPUTF8 *utf8characters;
+    uint32_t utf8length;
+} NPString;
+
+typedef enum {
+    NPVariantType_Void,
+    NPVariantType_Null,
+    NPVariantType_Bool,
+    NPVariantType_Int32,
+    NPVariantType_Double,
+    NPVariantType_String,
+    NPVariantType_Object
+} NPVariantType;
+
+typedef struct _NPVariant {
+    NPVariantType type;
+    union {
+        bool boolValue;
+        uint32_t intValue;
+        double doubleValue;
+        NPString stringValue;
+        NPObject *objectValue;
+    } value;
+} NPVariant;
+
+/*
+    NPN_ReleaseVariantValue is called on all 'out' parameters
+    references.  Specifically it is to be called on variants that own
+    their value, as is the case with all non-const NPVariant*
+    arguments after a successful call to any methods (except this one)
+    in this API.
+
+    After calling NPN_ReleaseVariantValue, the type of the variant
+    will be NPVariantType_Void.
+*/
+void NPN_ReleaseVariantValue(NPVariant *variant);
+
+#define NPVARIANT_IS_VOID(_v)    ((_v).type == NPVariantType_Void)
+#define NPVARIANT_IS_NULL(_v)    ((_v).type == NPVariantType_Null)
+#define NPVARIANT_IS_BOOLEAN(_v) ((_v).type == NPVariantType_Bool)
+#define NPVARIANT_IS_INT32(_v)   ((_v).type == NPVariantType_Int32)
+#define NPVARIANT_IS_DOUBLE(_v)  ((_v).type == NPVariantType_Double)
+#define NPVARIANT_IS_STRING(_v)  ((_v).type == NPVariantType_String)
+#define NPVARIANT_IS_OBJECT(_v)  ((_v).type == NPVariantType_Object)
+
+#define NPVARIANT_TO_BOOLEAN(_v) ((_v).value.boolValue)
+#define NPVARIANT_TO_INT32(_v)   ((_v).value.intValue)
+#define NPVARIANT_TO_DOUBLE(_v)  ((_v).value.doubleValue)
+#define NPVARIANT_TO_STRING(_v)  ((_v).value.stringValue)
+#define NPVARIANT_TO_OBJECT(_v)  ((_v).value.objectValue)
+
+#define VOID_TO_NPVARIANT(_v)                                                 \
+NP_BEGIN_MACRO                                                                \
+    (_v).type = NPVariantType_Void;                                           \
+    (_v).value.objectValue = NULL;                                            \
+NP_END_MACRO
+
+#define NULL_TO_NPVARIANT(_v)                                                 \
+NP_BEGIN_MACRO                                                                \
+    (_v).type = NPVariantType_Null;                                           \
+    (_v).value.objectValue = NULL;                                            \
+NP_END_MACRO
+
+#define BOOLEAN_TO_NPVARIANT(_val, _v)                                        \
+NP_BEGIN_MACRO                                                                \
+    (_v).type = NPVariantType_Bool;                                           \
+    (_v).value.boolValue = !!(_val);                                          \
+NP_END_MACRO
+
+#define INT32_TO_NPVARIANT(_val, _v)                                          \
+NP_BEGIN_MACRO                                                                \
+    (_v).type = NPVariantType_Int32;                                          \
+    (_v).value.intValue = _val;                                               \
+NP_END_MACRO
+
+#define DOUBLE_TO_NPVARIANT(_val, _v)                                         \
+NP_BEGIN_MACRO                                                                \
+    (_v).type = NPVariantType_Double;                                         \
+    (_v).value.doubleValue = _val;                                            \
+NP_END_MACRO
+
+#define STRINGZ_TO_NPVARIANT(_val, _v)                                        \
+NP_BEGIN_MACRO                                                                \
+    (_v).type = NPVariantType_String;                                         \
+    NPString str = { _val, strlen(_val) };                                    \
+    (_v).value.stringValue = str;                                             \
+NP_END_MACRO
+
+#define STRINGN_TO_NPVARIANT(_val, _len, _v)                                  \
+NP_BEGIN_MACRO                                                                \
+    (_v).type = NPVariantType_String;                                         \
+    NPString str = { _val, _len };                                            \
+    (_v).value.stringValue = str;                                             \
+NP_END_MACRO
+
+#define OBJECT_TO_NPVARIANT(_val, _v)                                         \
+NP_BEGIN_MACRO                                                                \
+    (_v).type = NPVariantType_Object;                                         \
+    (_v).value.objectValue = _val;                                            \
+NP_END_MACRO
+
+
+/*
+	Type mappings (JavaScript types have been used for illustration
+    purposes):
+
+	JavaScript       to             C (NPVariant with type:)
+	undefined                       NPVariantType_Void
+	null                            NPVariantType_Null
+	Boolean                         NPVariantType_Bool
+	Number                          NPVariantType_Double or NPVariantType_Int32
+	String                          NPVariantType_String
+	Object                          NPVariantType_Object
+
+	C (NPVariant with type:)   to   JavaScript
+	NPVariantType_Void              undefined
+	NPVariantType_Null              null
+	NPVariantType_Bool              Boolean	
+	NPVariantType_Int32             Number
+	NPVariantType_Double            Number
+	NPVariantType_String            String
+	NPVariantType_Object            Object
+*/
+
+typedef void *NPIdentifier;
+
+/*
+    NPObjects have methods and properties.  Methods and properties are
+    identified with NPIdentifiers.  These identifiers may be reflected
+    in script.  NPIdentifiers can be either strings or integers, IOW,
+    methods and properties can be identified by either strings or
+    integers (i.e. foo["bar"] vs foo[1]). NPIdentifiers can be
+    compared using ==.  In case of any errors, the requested
+    NPIdentifier(s) will be NULL.
+*/
+NPIdentifier NPN_GetStringIdentifier(const NPUTF8 *name);
+void NPN_GetStringIdentifiers(const NPUTF8 **names, int32_t nameCount,
+                              NPIdentifier *identifiers);
+NPIdentifier NPN_GetIntIdentifier(int32_t intid);
+bool NPN_IdentifierIsString(NPIdentifier identifier);
+
+/*
+    The NPUTF8 returned from NPN_UTF8FromIdentifier SHOULD be freed.
+*/
+NPUTF8 *NPN_UTF8FromIdentifier(NPIdentifier identifier);
+
+/*
+    Get the integer represented by identifier. If identifier is not an
+    integer identifier, the behaviour is undefined.
+*/
+int32_t NPN_IntFromIdentifier(NPIdentifier identifier);
+
+/*
+    NPObject behavior is implemented using the following set of
+    callback functions.
+
+    The NPVariant *result argument of these functions (where
+    applicable) should be released using NPN_ReleaseVariantValue().
+*/
+typedef NPObject *(*NPAllocateFunctionPtr)(NPP npp, NPClass *aClass);
+typedef void (*NPDeallocateFunctionPtr)(NPObject *npobj);
+typedef void (*NPInvalidateFunctionPtr)(NPObject *npobj);
+typedef bool (*NPHasMethodFunctionPtr)(NPObject *npobj, NPIdentifier name);
+typedef bool (*NPInvokeFunctionPtr)(NPObject *npobj, NPIdentifier name,
+                                    const NPVariant *args, uint32_t argCount,
+                                    NPVariant *result);
+typedef bool (*NPInvokeDefaultFunctionPtr)(NPObject *npobj,
+                                           const NPVariant *args,
+                                           uint32_t argCount,
+                                           NPVariant *result);
+typedef bool (*NPHasPropertyFunctionPtr)(NPObject *npobj, NPIdentifier name);
+typedef bool (*NPGetPropertyFunctionPtr)(NPObject *npobj, NPIdentifier name,
+                                         NPVariant *result);
+typedef bool (*NPSetPropertyFunctionPtr)(NPObject *npobj, NPIdentifier name,
+                                         const NPVariant *value);
+typedef bool (*NPRemovePropertyFunctionPtr)(NPObject *npobj,
+                                            NPIdentifier name);
+
+/*
+    NPObjects returned by create, retain, invoke, and getProperty pass
+    a reference count to the caller.  That is, the callee adds a
+    reference count which passes to the caller.  It is the caller's
+    responsibility to release the returned object.
+
+    NPInvokeFunctionPtr function may return 0 to indicate a void
+    result.
+
+    NPInvalidateFunctionPtr is called by the scripting environment
+    when the native code is shutdown.  Any attempt to message a
+    NPObject instance after the invalidate callback has been
+    called will result in undefined behavior, even if the native code
+    is still retaining those NPObject instances.  (The runtime
+    will typically return immediately, with 0 or NULL, from an attempt
+    to dispatch to a NPObject, but this behavior should not be
+    depended upon.)
+*/
+struct NPClass
+{
+    uint32_t structVersion;
+    NPAllocateFunctionPtr allocate;
+    NPDeallocateFunctionPtr deallocate;
+    NPInvalidateFunctionPtr invalidate;
+    NPHasMethodFunctionPtr hasMethod;
+    NPInvokeFunctionPtr invoke;
+    NPInvokeDefaultFunctionPtr invokeDefault;
+    NPHasPropertyFunctionPtr hasProperty;
+    NPGetPropertyFunctionPtr getProperty;
+    NPSetPropertyFunctionPtr setProperty;
+    NPRemovePropertyFunctionPtr removeProperty;
+};
+
+#define NP_CLASS_STRUCT_VERSION 1
+
+struct NPObject {
+    NPClass *_class;
+    uint32_t referenceCount;
+    /*
+     * Additional space may be allocated here by types of NPObjects
+     */
+};
+
+/*
+    If the class has an allocate function, NPN_CreateObject invokes
+    that function, otherwise a NPObject is allocated and
+    returned. This method will initialize the referenceCount member of
+    the NPObject to 1.
+*/
+NPObject *NPN_CreateObject(NPP npp, NPClass *aClass);
+
+/*
+    Increment the NPObject's reference count.
+*/
+NPObject *NPN_RetainObject(NPObject *npobj);
+
+/*
+    Decremented the NPObject's reference count.  If the reference
+    count goes to zero, the class's destroy function is invoke if
+    specified, otherwise the object is freed directly.
+*/
+void NPN_ReleaseObject(NPObject *npobj);
+
+/*
+    Functions to access script objects represented by NPObject.
+
+    Calls to script objects are synchronous.  If a function returns a
+    value, it will be supplied via the result NPVariant
+    argument. Successful calls will return true, false will be
+    returned in case of an error.
+    
+    Calls made from plugin code to script must be made from the thread
+    on which the plugin was initialized.
+*/
+
+bool NPN_Invoke(NPP npp, NPObject *npobj, NPIdentifier methodName,
+                const NPVariant *args, uint32_t argCount, NPVariant *result);
+bool NPN_InvokeDefault(NPP npp, NPObject *npobj, const NPVariant *args,
+                       uint32_t argCount, NPVariant *result);
+bool NPN_Evaluate(NPP npp, NPObject *npobj, NPString *script,
+                  NPVariant *result);
+bool NPN_GetProperty(NPP npp, NPObject *npobj, NPIdentifier propertyName,
+                     NPVariant *result);
+bool NPN_SetProperty(NPP npp, NPObject *npobj, NPIdentifier propertyName,
+                     const NPVariant *value);
+bool NPN_RemoveProperty(NPP npp, NPObject *npobj, NPIdentifier propertyName);
+bool NPN_HasProperty(NPP npp, NPObject *npobj, NPIdentifier propertyName);
+bool NPN_HasMethod(NPP npp, NPObject *npobj, NPIdentifier methodName);
+
+/*
+    NPN_SetException may be called to trigger a script exception upon
+    return from entry points into NPObjects.  Typical usage:
+
+    NPN_SetException (npobj, message);
+*/
+void NPN_SetException(NPObject *npobj, const NPUTF8 *message);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Nur mplayerplug-in-3.55-orig/include/nptypes.h mplayerplug-in-3.55/include/nptypes.h
--- mplayerplug-in-3.55-orig/include/nptypes.h	1970-01-01 07:00:00.000000000 +0700
+++ mplayerplug-in-3.55/include/nptypes.h	2007-08-04 02:59:37.000000000 +0700
@@ -0,0 +1,105 @@
+/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * mozilla.org.
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Johnny Stenback <jst@mozilla.org> (Original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Header file for ensuring that C99 types ([u]int32_t and bool) are
+ * available.
+ */
+
+#if defined(WIN32) || defined(OS2)
+  /*
+   * Win32 and OS/2 don't know C99, so define [u]int_32 here. The bool
+   * is predefined tho, both in C and C++.
+   */
+  typedef int int32_t;
+  typedef unsigned int uint32_t;
+#elif defined(_AIX) || defined(__sun) || defined(__osf__) || defined(IRIX) || defined(HPUX)
+  /*
+   * AIX and SunOS ship a inttypes.h header that defines [u]int32_t,
+   * but not bool for C.
+   */
+  #include <inttypes.h>
+
+  #ifndef __cplusplus
+    typedef int bool;
+  #endif
+#elif defined(bsdi) || defined(FREEBSD) || defined(OPENBSD)
+  /*
+   * BSD/OS, FreeBSD, and OpenBSD ship sys/types.h that define int32_t and 
+   * u_int32_t.
+   */
+  #include <sys/types.h>
+
+  /*
+   * BSD/OS ships no header that defines uint32_t, nor bool (for C)
+   * OpenBSD ships no header that defines uint32_t and using its bool macro is
+   * unsafe.
+   */
+  #if defined(bsdi) || defined(OPENBSD)
+  typedef u_int32_t uint32_t;
+
+  #if !defined(__cplusplus)
+    typedef int bool;
+  #endif
+  #else
+  /*
+   * FreeBSD defines uint32_t and bool.
+   */
+    #include <inttypes.h>
+    #include <stdbool.h>
+  #endif
+#elif defined(BEOS)
+  #include <inttypes.h>
+#else
+  /*
+   * For those that ship a standard C99 stdint.h header file, include
+   * it. Can't do the same for stdbool.h tho, since some systems ship
+   * with a stdbool.h file that doesn't compile!
+   */
+  #include <stdint.h>
+
+  #if !defined(__GNUC__) || (__GNUC__ > 2 || __GNUC_MINOR__ > 95)
+    #include <stdbool.h>
+  #else
+    /*
+     * GCC 2.91 can't deal with a typedef for bool, but a #define
+     * works.
+     */
+    #define bool int
+  #endif
+#endif
diff -Nur mplayerplug-in-3.55-orig/include/npupp.h mplayerplug-in-3.55/include/npupp.h
--- mplayerplug-in-3.55-orig/include/npupp.h	1970-01-01 07:00:00.000000000 +0700
+++ mplayerplug-in-3.55/include/npupp.h	2007-08-04 02:59:37.000000000 +0700
@@ -0,0 +1,1889 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+/*
+ *  npupp.h $Revision: 3.20 $
+ *  function call mecahnics needed by platform specific glue code.
+ */
+
+
+#ifndef _NPUPP_H_
+#define _NPUPP_H_
+
+#if defined(__OS2__)
+#pragma pack(1)
+#endif
+
+#ifndef GENERATINGCFM
+#define GENERATINGCFM 0
+#endif
+
+#ifndef _NPAPI_H_
+#include "npapi.h"
+#endif
+
+#include "npruntime.h"
+
+#include "jri.h"
+
+/******************************************************************************************
+   plug-in function table macros
+ 	        for each function in and out of the plugin API we define
+                    typedef NPP_FooUPP
+					#define NewNPP_FooProc
+					#define CallNPP_FooProc
+			for mac, define the UPP magic for PPC/68K calling
+ *******************************************************************************************/
+
+
+/* NPP_Initialize */
+
+#define _NPUPP_USE_UPP_ (TARGET_RT_MAC_CFM && !TARGET_API_MAC_CARBON)
+
+#if _NPUPP_USE_UPP_
+typedef UniversalProcPtr NPP_InitializeUPP;
+
+enum {
+	uppNPP_InitializeProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(0))		
+		| RESULT_SIZE(SIZE_CODE(0))
+};
+
+#define NewNPP_InitializeProc(FUNC)		\
+		(NPP_InitializeUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_InitializeProcInfo, GetCurrentArchitecture())
+#define CallNPP_InitializeProc(FUNC)		\
+		(void)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_InitializeProcInfo)
+		
+#else
+
+typedef void (* NP_LOADDS NPP_InitializeUPP)(void);
+#define NewNPP_InitializeProc(FUNC)		\
+		((NPP_InitializeUPP) (FUNC))
+#define CallNPP_InitializeProc(FUNC)		\
+		(*(FUNC))()
+
+#endif
+
+
+/* NPP_Shutdown */
+
+#if _NPUPP_USE_UPP_
+typedef UniversalProcPtr NPP_ShutdownUPP;
+
+enum {
+	uppNPP_ShutdownProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(0))		
+		| RESULT_SIZE(SIZE_CODE(0))
+};
+
+#define NewNPP_ShutdownProc(FUNC)		\
+		(NPP_ShutdownUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_ShutdownProcInfo, GetCurrentArchitecture())
+#define CallNPP_ShutdownProc(FUNC)		\
+		(void)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_ShutdownProcInfo)
+		
+#else
+
+typedef void (* NP_LOADDS NPP_ShutdownUPP)(void);
+#define NewNPP_ShutdownProc(FUNC)		\
+		((NPP_ShutdownUPP) (FUNC))
+#define CallNPP_ShutdownProc(FUNC)		\
+		(*(FUNC))()
+
+#endif
+
+
+/* NPP_New */
+
+#if _NPUPP_USE_UPP_
+typedef UniversalProcPtr NPP_NewUPP;
+
+enum {
+	uppNPP_NewProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPMIMEType)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(uint16)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(int16)))
+		| STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(char **)))
+		| STACK_ROUTINE_PARAMETER(6, SIZE_CODE(sizeof(char **)))
+		| STACK_ROUTINE_PARAMETER(7, SIZE_CODE(sizeof(NPSavedData *)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+
+#define NewNPP_NewProc(FUNC)		\
+		(NPP_NewUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_NewProcInfo, GetCurrentArchitecture())
+#define CallNPP_NewProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) \
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_NewProcInfo, \
+								   (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7))
+#else
+
+typedef NPError	(* NP_LOADDS NPP_NewUPP)(NPMIMEType pluginType, NPP instance, uint16 mode, int16 argc, char* argn[], char* argv[], NPSavedData* saved);
+#define NewNPP_NewProc(FUNC)		\
+		((NPP_NewUPP) (FUNC))
+#define CallNPP_NewProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7))
+
+#endif
+
+
+/* NPP_Destroy */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPP_DestroyUPP;
+enum {
+	uppNPP_DestroyProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPSavedData **)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPP_DestroyProc(FUNC)		\
+		(NPP_DestroyUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_DestroyProcInfo, GetCurrentArchitecture())
+#define CallNPP_DestroyProc(FUNC, ARG1, ARG2)		\
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_DestroyProcInfo, (ARG1), (ARG2))
+#else
+
+typedef NPError	(* NP_LOADDS NPP_DestroyUPP)(NPP instance, NPSavedData** save);
+#define NewNPP_DestroyProc(FUNC)		\
+		((NPP_DestroyUPP) (FUNC))
+#define CallNPP_DestroyProc(FUNC, ARG1, ARG2)		\
+		(*(FUNC))((ARG1), (ARG2))
+
+#endif
+
+
+/* NPP_SetWindow */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPP_SetWindowUPP;
+enum {
+	uppNPP_SetWindowProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPWindow *)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPP_SetWindowProc(FUNC)		\
+		(NPP_SetWindowUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_SetWindowProcInfo, GetCurrentArchitecture())
+#define CallNPP_SetWindowProc(FUNC, ARG1, ARG2)		\
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_SetWindowProcInfo, (ARG1), (ARG2))
+
+#else
+
+typedef NPError	(* NP_LOADDS NPP_SetWindowUPP)(NPP instance, NPWindow* window);
+#define NewNPP_SetWindowProc(FUNC)		\
+		((NPP_SetWindowUPP) (FUNC))
+#define CallNPP_SetWindowProc(FUNC, ARG1, ARG2)		\
+		(*(FUNC))((ARG1), (ARG2))
+
+#endif
+
+
+/* NPP_NewStream */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPP_NewStreamUPP;
+enum {
+	uppNPP_NewStreamProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPMIMEType)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(NPStream *)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(NPBool)))
+		| STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(uint16 *)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPP_NewStreamProc(FUNC)		\
+		(NPP_NewStreamUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_NewStreamProcInfo, GetCurrentArchitecture())
+#define CallNPP_NewStreamProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5)		\
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_NewStreamProcInfo, (ARG1), (ARG2), (ARG3), (ARG4), (ARG5))
+#else
+
+typedef NPError	(* NP_LOADDS NPP_NewStreamUPP)(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16* stype);
+#define NewNPP_NewStreamProc(FUNC)		\
+		((NPP_NewStreamUPP) (FUNC))
+#define CallNPP_NewStreamProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5) \
+		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4), (ARG5))
+#endif
+
+
+/* NPP_DestroyStream */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPP_DestroyStreamUPP;
+enum {
+	uppNPP_DestroyStreamProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPStream *)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(NPReason)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPP_DestroyStreamProc(FUNC)		\
+		(NPP_DestroyStreamUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_DestroyStreamProcInfo, GetCurrentArchitecture())
+#define CallNPP_DestroyStreamProc(FUNC,  NPParg, NPStreamPtr, NPReasonArg)		\
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_DestroyStreamProcInfo, (NPParg), (NPStreamPtr), (NPReasonArg))
+
+#else
+
+typedef NPError	(* NP_LOADDS NPP_DestroyStreamUPP)(NPP instance, NPStream* stream, NPReason reason);
+#define NewNPP_DestroyStreamProc(FUNC)		\
+		((NPP_DestroyStreamUPP) (FUNC))
+#define CallNPP_DestroyStreamProc(FUNC,  NPParg, NPStreamPtr, NPReasonArg)		\
+		(*(FUNC))((NPParg), (NPStreamPtr), (NPReasonArg))
+
+#endif
+
+
+/* NPP_WriteReady */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPP_WriteReadyUPP;
+enum {
+	uppNPP_WriteReadyProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPStream *)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(int32)))
+};
+#define NewNPP_WriteReadyProc(FUNC)		\
+		(NPP_WriteReadyUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_WriteReadyProcInfo, GetCurrentArchitecture())
+#define CallNPP_WriteReadyProc(FUNC,  NPParg, NPStreamPtr)		\
+		(int32)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_WriteReadyProcInfo, (NPParg), (NPStreamPtr))
+
+#else
+
+typedef int32 (* NP_LOADDS NPP_WriteReadyUPP)(NPP instance, NPStream* stream);
+#define NewNPP_WriteReadyProc(FUNC)		\
+		((NPP_WriteReadyUPP) (FUNC))
+#define CallNPP_WriteReadyProc(FUNC,  NPParg, NPStreamPtr)		\
+		(*(FUNC))((NPParg), (NPStreamPtr))
+
+#endif
+
+
+/* NPP_Write */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPP_WriteUPP;
+enum {
+	uppNPP_WriteProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPStream *)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(int32)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(int32)))
+		| STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(void*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(int32)))
+};
+#define NewNPP_WriteProc(FUNC)		\
+		(NPP_WriteUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_WriteProcInfo, GetCurrentArchitecture())
+#define CallNPP_WriteProc(FUNC,  NPParg, NPStreamPtr, offsetArg, lenArg, bufferPtr)		\
+		(int32)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_WriteProcInfo, (NPParg), (NPStreamPtr), (offsetArg), (lenArg), (bufferPtr))
+
+#else
+
+typedef int32 (* NP_LOADDS NPP_WriteUPP)(NPP instance, NPStream* stream, int32 offset, int32 len, void* buffer);
+#define NewNPP_WriteProc(FUNC)		\
+		((NPP_WriteUPP) (FUNC))
+#define CallNPP_WriteProc(FUNC,  NPParg, NPStreamPtr, offsetArg, lenArg, bufferPtr)		\
+		(*(FUNC))((NPParg), (NPStreamPtr), (offsetArg), (lenArg), (bufferPtr))
+
+#endif
+
+
+/* NPP_StreamAsFile */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPP_StreamAsFileUPP;
+enum {
+	uppNPP_StreamAsFileProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPStream *)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(const char *)))
+		| RESULT_SIZE(SIZE_CODE(0))
+};
+#define NewNPP_StreamAsFileProc(FUNC)		\
+		(NPP_StreamAsFileUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_StreamAsFileProcInfo, GetCurrentArchitecture())
+#define CallNPP_StreamAsFileProc(FUNC, ARG1, ARG2, ARG3)		\
+		(void)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_StreamAsFileProcInfo, (ARG1), (ARG2), (ARG3))
+
+#else
+
+typedef void (* NP_LOADDS NPP_StreamAsFileUPP)(NPP instance, NPStream* stream, const char* fname);
+#define NewNPP_StreamAsFileProc(FUNC)		\
+		((NPP_StreamAsFileUPP) (FUNC))
+#define CallNPP_StreamAsFileProc(FUNC,  ARG1, ARG2, ARG3)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3))
+#endif
+
+
+/* NPP_Print */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPP_PrintUPP;
+enum {
+	uppNPP_PrintProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPPrint *)))
+		| RESULT_SIZE(SIZE_CODE(0))
+};
+#define NewNPP_PrintProc(FUNC)		\
+		(NPP_PrintUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_PrintProcInfo, GetCurrentArchitecture())
+#define CallNPP_PrintProc(FUNC,  NPParg, voidPtr)		\
+		(void)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_PrintProcInfo, (NPParg), (voidPtr))
+
+#else
+
+typedef void (* NP_LOADDS NPP_PrintUPP)(NPP instance, NPPrint* platformPrint);
+#define NewNPP_PrintProc(FUNC)		\
+		((NPP_PrintUPP) (FUNC))
+#define CallNPP_PrintProc(FUNC,  NPParg, NPPrintArg)		\
+		(*(FUNC))((NPParg), (NPPrintArg))
+
+#endif
+
+
+/* NPP_HandleEvent */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPP_HandleEventUPP;
+enum {
+	uppNPP_HandleEventProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(void *)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(int16)))
+};
+#define NewNPP_HandleEventProc(FUNC)		\
+		(NPP_HandleEventUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_HandleEventProcInfo, GetCurrentArchitecture())
+#define CallNPP_HandleEventProc(FUNC,  NPParg, voidPtr)		\
+		(int16)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_HandleEventProcInfo, (NPParg), (voidPtr))
+
+#else
+
+typedef int16 (* NP_LOADDS NPP_HandleEventUPP)(NPP instance, void* event);
+#define NewNPP_HandleEventProc(FUNC)		\
+		((NPP_HandleEventUPP) (FUNC))
+#define CallNPP_HandleEventProc(FUNC,  NPParg, voidPtr)		\
+		(*(FUNC))((NPParg), (voidPtr))
+
+#endif
+
+
+/* NPP_URLNotify */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPP_URLNotifyUPP;
+enum {
+	uppNPP_URLNotifyProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(const char*)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(NPReason)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(void*)))
+		| RESULT_SIZE(SIZE_CODE(SIZE_CODE(0)))
+};
+#define NewNPP_URLNotifyProc(FUNC)		\
+		(NPP_URLNotifyUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_URLNotifyProcInfo, GetCurrentArchitecture())
+#define CallNPP_URLNotifyProc(FUNC,  ARG1, ARG2, ARG3, ARG4)		\
+		(void)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_URLNotifyProcInfo, (ARG1), (ARG2), (ARG3), (ARG4))
+
+#else
+
+typedef void (* NP_LOADDS NPP_URLNotifyUPP)(NPP instance, const char* url, NPReason reason, void* notifyData);
+#define NewNPP_URLNotifyProc(FUNC)		\
+		((NPP_URLNotifyUPP) (FUNC))
+#define CallNPP_URLNotifyProc(FUNC,  ARG1, ARG2, ARG3, ARG4)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4))
+
+#endif
+
+
+/* NPP_GetValue */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPP_GetValueUPP;
+enum {
+	uppNPP_GetValueProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPPVariable)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(void *)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPP_GetValueProc(FUNC)		\
+		(NPP_GetValueUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_GetValueProcInfo, GetCurrentArchitecture())
+#define CallNPP_GetValueProc(FUNC, ARG1, ARG2, ARG3) \
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_GetValueProcInfo, (ARG1), (ARG2), (ARG3))
+#else
+
+typedef NPError	(* NP_LOADDS NPP_GetValueUPP)(NPP instance, NPPVariable variable, void *ret_alue);
+#define NewNPP_GetValueProc(FUNC)		\
+		((NPP_GetValueUPP) (FUNC))
+#define CallNPP_GetValueProc(FUNC, ARG1, ARG2, ARG3)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3))
+#endif
+
+
+/* NPP_SetValue */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPP_SetValueUPP;
+enum {
+	uppNPP_SetValueProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPNVariable)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(void *)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPP_SetValueProc(FUNC)		\
+		(NPP_SetValueUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_SetValueProcInfo, GetCurrentArchitecture())
+#define CallNPP_SetValueProc(FUNC, ARG1, ARG2, ARG3) \
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPP_SetValueProcInfo, (ARG1), (ARG2), (ARG3))
+#else
+
+typedef NPError	(* NP_LOADDS NPP_SetValueUPP)(NPP instance, NPNVariable variable, void *ret_alue);
+#define NewNPP_SetValueProc(FUNC)		\
+		((NPP_SetValueUPP) (FUNC))
+#define CallNPP_SetValueProc(FUNC, ARG1, ARG2, ARG3)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3))
+#endif
+
+
+/*
+ *  Netscape entry points
+ */
+
+
+/* NPN_GetValue */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_GetValueUPP;
+enum {
+	uppNPN_GetValueProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPNVariable)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(void *)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPN_GetValueProc(FUNC)		\
+		(NPN_GetValueUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_GetValueProcInfo, GetCurrentArchitecture())
+#define CallNPN_GetValueProc(FUNC, ARG1, ARG2, ARG3) \
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_GetValueProcInfo, (ARG1), (ARG2), (ARG3))
+#else
+
+typedef NPError	(* NP_LOADDS NPN_GetValueUPP)(NPP instance, NPNVariable variable, void *ret_alue);
+#define NewNPN_GetValueProc(FUNC)		\
+		((NPN_GetValueUPP) (FUNC))
+#define CallNPN_GetValueProc(FUNC, ARG1, ARG2, ARG3)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3))
+#endif
+
+
+/* NPN_SetValue */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_SetValueUPP;
+enum {
+	uppNPN_SetValueProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPPVariable)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(void *)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPN_SetValueProc(FUNC)		\
+		(NPN_SetValueUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_SetValueProcInfo, GetCurrentArchitecture())
+#define CallNPN_SetValueProc(FUNC, ARG1, ARG2, ARG3) \
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_SetValueProcInfo, (ARG1), (ARG2), (ARG3))
+#else
+
+typedef NPError	(* NP_LOADDS NPN_SetValueUPP)(NPP instance, NPPVariable variable, void *ret_alue);
+#define NewNPN_SetValueProc(FUNC)		\
+		((NPN_SetValueUPP) (FUNC))
+#define CallNPN_SetValueProc(FUNC, ARG1, ARG2, ARG3)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3))
+#endif
+
+
+/* NPN_GetUrlNotify */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_GetURLNotifyUPP;
+enum {
+	uppNPN_GetURLNotifyProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(const char*)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(const char*)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(void*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPN_GetURLNotifyProc(FUNC)		\
+		(NPN_GetURLNotifyUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_GetURLNotifyProcInfo, GetCurrentArchitecture())
+#define CallNPN_GetURLNotifyProc(FUNC, ARG1, ARG2, ARG3, ARG4) \
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_GetURLNotifyProcInfo, (ARG1), (ARG2), (ARG3), (ARG4))
+#else
+
+typedef NPError	(* NP_LOADDS NPN_GetURLNotifyUPP)(NPP instance, const char* url, const char* window, void* notifyData);
+#define NewNPN_GetURLNotifyProc(FUNC)		\
+		((NPN_GetURLNotifyUPP) (FUNC))
+#define CallNPN_GetURLNotifyProc(FUNC, ARG1, ARG2, ARG3, ARG4)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4))
+#endif
+
+
+/* NPN_PostUrlNotify */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_PostURLNotifyUPP;
+enum {
+	uppNPN_PostURLNotifyProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(const char*)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(const char*)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(uint32)))
+		| STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(const char*)))
+		| STACK_ROUTINE_PARAMETER(6, SIZE_CODE(sizeof(NPBool)))
+		| STACK_ROUTINE_PARAMETER(7, SIZE_CODE(sizeof(void*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPN_PostURLNotifyProc(FUNC)		\
+		(NPN_PostURLNotifyUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_PostURLNotifyProcInfo, GetCurrentArchitecture())
+#define CallNPN_PostURLNotifyProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) \
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_PostURLNotifyProcInfo, (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7))
+#else
+
+typedef NPError (* NP_LOADDS NPN_PostURLNotifyUPP)(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file, void* notifyData);
+#define NewNPN_PostURLNotifyProc(FUNC)		\
+		((NPN_PostURLNotifyUPP) (FUNC))
+#define CallNPN_PostURLNotifyProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) \
+		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7))
+#endif
+
+
+/* NPN_GetUrl */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_GetURLUPP;
+enum {
+	uppNPN_GetURLProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(const char*)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(const char*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPN_GetURLProc(FUNC)		\
+		(NPN_GetURLUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_GetURLProcInfo, GetCurrentArchitecture())
+#define CallNPN_GetURLProc(FUNC, ARG1, ARG2, ARG3) \
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_GetURLProcInfo, (ARG1), (ARG2), (ARG3))
+#else
+
+typedef NPError	(* NP_LOADDS NPN_GetURLUPP)(NPP instance, const char* url, const char* window);
+#define NewNPN_GetURLProc(FUNC)		\
+		((NPN_GetURLUPP) (FUNC))
+#define CallNPN_GetURLProc(FUNC, ARG1, ARG2, ARG3)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3))
+#endif
+
+
+/* NPN_PostUrl */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_PostURLUPP;
+enum {
+	uppNPN_PostURLProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(const char*)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(const char*)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(uint32)))
+		| STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(const char*)))
+		| STACK_ROUTINE_PARAMETER(6, SIZE_CODE(sizeof(NPBool)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPN_PostURLProc(FUNC)		\
+		(NPN_PostURLUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_PostURLProcInfo, GetCurrentArchitecture())
+#define CallNPN_PostURLProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) \
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_PostURLProcInfo, (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6))
+#else
+
+typedef NPError (* NP_LOADDS NPN_PostURLUPP)(NPP instance, const char* url, const char* window, uint32 len, const char* buf, NPBool file);
+#define NewNPN_PostURLProc(FUNC)		\
+		((NPN_PostURLUPP) (FUNC))
+#define CallNPN_PostURLProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) \
+		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6))
+#endif
+
+
+/* NPN_RequestRead */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_RequestReadUPP;
+enum {
+	uppNPN_RequestReadProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPStream *)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPByteRange *)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPN_RequestReadProc(FUNC)		\
+		(NPN_RequestReadUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_RequestReadProcInfo, GetCurrentArchitecture())
+#define CallNPN_RequestReadProc(FUNC,  stream, range)		\
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_RequestReadProcInfo, (stream), (range))
+
+#else
+
+typedef NPError	(* NP_LOADDS NPN_RequestReadUPP)(NPStream* stream, NPByteRange* rangeList);
+#define NewNPN_RequestReadProc(FUNC)		\
+		((NPN_RequestReadUPP) (FUNC))
+#define CallNPN_RequestReadProc(FUNC, stream, range)		\
+		(*(FUNC))((stream), (range))
+
+#endif
+
+
+/* NPN_NewStream */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_NewStreamUPP;
+enum {
+	uppNPN_NewStreamProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPMIMEType)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(const char *)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(NPStream **)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPN_NewStreamProc(FUNC)		\
+		(NPN_NewStreamUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_NewStreamProcInfo, GetCurrentArchitecture())
+#define CallNPN_NewStreamProc(FUNC, npp, type, window, stream)		\
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_NewStreamProcInfo, (npp), (type), (window), (stream))	
+
+#else
+
+typedef NPError	(* NP_LOADDS NPN_NewStreamUPP)(NPP instance, NPMIMEType type, const char* window, NPStream** stream);
+#define NewNPN_NewStreamProc(FUNC)		\
+		((NPN_NewStreamUPP) (FUNC))
+#define CallNPN_NewStreamProc(FUNC, npp, type, window, stream)		\
+		(*(FUNC))((npp), (type), (window), (stream))
+
+#endif
+
+
+/* NPN_Write */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_WriteUPP;
+enum {
+	uppNPN_WriteProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPStream *)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(int32)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(void*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(int32)))
+};
+#define NewNPN_WriteProc(FUNC)		\
+		(NPN_WriteUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_WriteProcInfo, GetCurrentArchitecture())
+#define CallNPN_WriteProc(FUNC, npp, stream, len, buffer)		\
+		(int32)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_WriteProcInfo, (npp), (stream), (len), (buffer))	
+
+#else
+
+typedef int32 (* NP_LOADDS NPN_WriteUPP)(NPP instance, NPStream* stream, int32 len, void* buffer);
+#define NewNPN_WriteProc(FUNC)		\
+		((NPN_WriteUPP) (FUNC))
+#define CallNPN_WriteProc(FUNC, npp, stream, len, buffer)		\
+		(*(FUNC))((npp), (stream), (len), (buffer))
+
+#endif
+
+
+/* NPN_DestroyStream */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_DestroyStreamUPP;
+enum {
+	uppNPN_DestroyStreamProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP )))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPStream *)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(NPReason)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPN_DestroyStreamProc(FUNC)		\
+		(NPN_DestroyStreamUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_DestroyStreamProcInfo, GetCurrentArchitecture())
+#define CallNPN_DestroyStreamProc(FUNC, npp, stream, reason)		\
+		(NPError)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_DestroyStreamProcInfo, (npp), (stream), (reason))	
+
+#else
+
+typedef NPError (* NP_LOADDS NPN_DestroyStreamUPP)(NPP instance, NPStream* stream, NPReason reason);
+#define NewNPN_DestroyStreamProc(FUNC)		\
+		((NPN_DestroyStreamUPP) (FUNC))
+#define CallNPN_DestroyStreamProc(FUNC, npp, stream, reason)		\
+		(*(FUNC))((npp), (stream), (reason))
+
+#endif
+
+
+/* NPN_Status */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_StatusUPP;
+enum {
+	uppNPN_StatusProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char *)))
+};
+
+#define NewNPN_StatusProc(FUNC)		\
+		(NPN_StatusUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_StatusProcInfo, GetCurrentArchitecture())
+#define CallNPN_StatusProc(FUNC, npp, msg)		\
+		(void)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_StatusProcInfo, (npp), (msg))	
+
+#else
+
+typedef void (* NP_LOADDS NPN_StatusUPP)(NPP instance, const char* message);
+#define NewNPN_StatusProc(FUNC)		\
+		((NPN_StatusUPP) (FUNC))
+#define CallNPN_StatusProc(FUNC, npp, msg)		\
+		(*(FUNC))((npp), (msg))	
+
+#endif
+
+
+/* NPN_UserAgent */
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_UserAgentUPP;
+enum {
+        uppNPN_UserAgentProcInfo = kThinkCStackBased
+                | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+                | RESULT_SIZE(SIZE_CODE(sizeof(const char *)))
+};
+
+#define NewNPN_UserAgentProc(FUNC)              \
+                (NPN_UserAgentUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_UserAgentProcInfo, GetCurrentArchitecture())
+#define CallNPN_UserAgentProc(FUNC, ARG1)               \
+                (const char*)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_UserAgentProcInfo, (ARG1))
+
+#else
+
+typedef const char*	(* NP_LOADDS NPN_UserAgentUPP)(NPP instance);
+#define NewNPN_UserAgentProc(FUNC)              \
+                ((NPN_UserAgentUPP) (FUNC))
+#define CallNPN_UserAgentProc(FUNC, ARG1)               \
+                (*(FUNC))((ARG1))
+
+#endif
+
+
+/* NPN_MemAlloc */
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_MemAllocUPP;
+enum {
+	uppNPN_MemAllocProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(uint32)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(void *)))
+};
+
+#define NewNPN_MemAllocProc(FUNC)		\
+		(NPN_MemAllocUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_MemAllocProcInfo, GetCurrentArchitecture())
+#define CallNPN_MemAllocProc(FUNC, ARG1)		\
+		(void*)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_MemAllocProcInfo, (ARG1))	
+
+#else
+
+typedef void* (* NP_LOADDS NPN_MemAllocUPP)(uint32 size);
+#define NewNPN_MemAllocProc(FUNC)		\
+		((NPN_MemAllocUPP) (FUNC))
+#define CallNPN_MemAllocProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))	
+
+#endif
+
+
+/* NPN__MemFree */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_MemFreeUPP;
+enum {
+	uppNPN_MemFreeProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(void *)))
+};
+
+#define NewNPN_MemFreeProc(FUNC)		\
+		(NPN_MemFreeUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_MemFreeProcInfo, GetCurrentArchitecture())
+#define CallNPN_MemFreeProc(FUNC, ARG1)		\
+		(void)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_MemFreeProcInfo, (ARG1))
+
+#else
+
+typedef void (* NP_LOADDS NPN_MemFreeUPP)(void* ptr);
+#define NewNPN_MemFreeProc(FUNC)		\
+		((NPN_MemFreeUPP) (FUNC))
+#define CallNPN_MemFreeProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))	
+
+#endif
+
+
+/* NPN_MemFlush */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_MemFlushUPP;
+enum {
+	uppNPN_MemFlushProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(uint32)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(uint32)))
+};
+
+#define NewNPN_MemFlushProc(FUNC)		\
+		(NPN_MemFlushUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_MemFlushProcInfo, GetCurrentArchitecture())
+#define CallNPN_MemFlushProc(FUNC, ARG1)		\
+		(uint32)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_MemFlushProcInfo, (ARG1))	
+
+#else
+
+typedef uint32 (* NP_LOADDS NPN_MemFlushUPP)(uint32 size);
+#define NewNPN_MemFlushProc(FUNC)		\
+		((NPN_MemFlushUPP) (FUNC))
+#define CallNPN_MemFlushProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))	
+
+#endif
+
+
+
+/* NPN_ReloadPlugins */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_ReloadPluginsUPP;
+enum {
+	uppNPN_ReloadPluginsProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPBool)))
+		| RESULT_SIZE(SIZE_CODE(0))
+};
+
+#define NewNPN_ReloadPluginsProc(FUNC)		\
+		(NPN_ReloadPluginsUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_ReloadPluginsProcInfo, GetCurrentArchitecture())
+#define CallNPN_ReloadPluginsProc(FUNC, ARG1)		\
+		(void)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_ReloadPluginsProcInfo, (ARG1))	
+
+#else
+
+typedef void (* NP_LOADDS NPN_ReloadPluginsUPP)(NPBool reloadPages);
+#define NewNPN_ReloadPluginsProc(FUNC)		\
+		((NPN_ReloadPluginsUPP) (FUNC))
+#define CallNPN_ReloadPluginsProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))	
+
+#endif
+
+/* NPN_GetJavaEnv */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_GetJavaEnvUPP;
+enum {
+	uppNPN_GetJavaEnvProcInfo = kThinkCStackBased
+		| RESULT_SIZE(SIZE_CODE(sizeof(JRIEnv*)))
+};
+
+#define NewNPN_GetJavaEnvProc(FUNC)		\
+		(NPN_GetJavaEnvUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_GetJavaEnvProcInfo, GetCurrentArchitecture())
+#define CallNPN_GetJavaEnvProc(FUNC)		\
+		(JRIEnv*)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_GetJavaEnvProcInfo)	
+
+#else
+typedef JRIEnv* (* NP_LOADDS NPN_GetJavaEnvUPP)(void);
+#define NewNPN_GetJavaEnvProc(FUNC)		\
+		((NPN_GetJavaEnvUPP) (FUNC))
+#define CallNPN_GetJavaEnvProc(FUNC)		\
+		(*(FUNC))()	
+
+#endif
+
+
+/* NPN_GetJavaPeer */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_GetJavaPeerUPP;
+enum {
+	uppNPN_GetJavaPeerProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(jref)))
+};
+
+#define NewNPN_GetJavaPeerProc(FUNC)		\
+		(NPN_GetJavaPeerUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_GetJavaPeerProcInfo, GetCurrentArchitecture())
+#define CallNPN_GetJavaPeerProc(FUNC, ARG1)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_GetJavaPeerProcInfo, (ARG1))	
+
+#else
+
+typedef jref (* NP_LOADDS NPN_GetJavaPeerUPP)(NPP instance);
+#define NewNPN_GetJavaPeerProc(FUNC)		\
+		((NPN_GetJavaPeerUPP) (FUNC))
+#define CallNPN_GetJavaPeerProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))	
+
+#endif
+
+/* NPN_InvalidateRect */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_InvalidateRectUPP;
+enum {
+	uppNPN_InvalidateRectProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPRect *)))
+		| RESULT_SIZE(SIZE_CODE(0))
+};
+
+#define NewNPN_InvalidateRectProc(FUNC)		\
+		(NPN_InvalidateRectUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_InvalidateRectProcInfo, GetCurrentArchitecture())
+#define CallNPN_InvalidateRectProc(FUNC, ARG1, ARG2)		\
+		(void)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_InvalidateRectProcInfo, (ARG1), (ARG2))	
+
+#else
+
+typedef void (* NP_LOADDS NPN_InvalidateRectUPP)(NPP instance, NPRect *rect);
+#define NewNPN_InvalidateRectProc(FUNC)		\
+		((NPN_InvalidateRectUPP) (FUNC))
+#define CallNPN_InvalidateRectProc(FUNC, ARG1, ARG2)		\
+		(*(FUNC))((ARG1), (ARG2))	
+
+#endif
+
+
+/* NPN_InvalidateRegion */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_InvalidateRegionUPP;
+enum {
+	uppNPN_InvalidateRegionProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPRegion)))
+		| RESULT_SIZE(SIZE_CODE(0))
+};
+
+#define NewNPN_InvalidateRegionProc(FUNC)		\
+		(NPN_InvalidateRegionUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_InvalidateRegionProcInfo, GetCurrentArchitecture())
+#define CallNPN_InvalidateRegionProc(FUNC, ARG1, ARG2)		\
+		(void)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_InvalidateRegionProcInfo, (ARG1), (ARG2))	
+
+#else
+
+typedef void (* NP_LOADDS NPN_InvalidateRegionUPP)(NPP instance, NPRegion region);
+#define NewNPN_InvalidateRegionProc(FUNC)		\
+		((NPN_InvalidateRegionUPP) (FUNC))
+#define CallNPN_InvalidateRegionProc(FUNC, ARG1, ARG2)		\
+		(*(FUNC))((ARG1), (ARG2))	
+
+#endif
+
+/* NPN_ForceRedraw */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_ForceRedrawUPP;
+enum {
+	uppNPN_ForceRedrawProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(0)))
+};
+
+#define NewNPN_ForceRedrawProc(FUNC)		\
+		(NPN_ForceRedrawUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_ForceRedrawProcInfo, GetCurrentArchitecture())
+#define CallNPN_ForceRedrawProc(FUNC, ARG1)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_ForceRedrawProcInfo, (ARG1))	
+
+#else
+
+typedef void (* NP_LOADDS NPN_ForceRedrawUPP)(NPP instance);
+#define NewNPN_ForceRedrawProc(FUNC)		\
+		((NPN_ForceRedrawUPP) (FUNC))
+#define CallNPN_ForceRedrawProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))	
+
+#endif
+
+/* NPN_GetStringIdentifier */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_GetStringIdentifierUPP;
+enum {
+	uppNPN_GetStringIdentifierProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(const NPUTF8*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPIdentifier)))
+};
+
+#define NewNPN_GetStringIdentifierProc(FUNC)		\
+		(NPN_GetStringIdentifierUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_GetStringIdentifierProcInfo, GetCurrentArchitecture())
+#define CallNPN_GetStringIdentifierProc(FUNC, ARG1)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_GetStringIdentifierProcInfo, (ARG1))	
+
+#else
+
+typedef NPIdentifier (* NP_LOADDS NPN_GetStringIdentifierUPP)(const NPUTF8* name);
+#define NewNPN_GetStringIdentifierProc(FUNC)		\
+		((NPN_GetStringIdentifierUPP) (FUNC))
+#define CallNPN_GetStringIdentifierProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))
+
+#endif
+
+/* NPN_GetStringIdentifiers */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_GetStringIdentifiersUPP;
+enum {
+	uppNPN_GetStringIdentifiersProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(const NPUTF8**)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(int32_t)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(NPIdentifier*)))
+        | RESULT_SIZE(SIZE_CODE(0))
+};
+
+#define NewNPN_GetStringIdentifiersProc(FUNC)		\
+		(NPN_GetStringIdentifiersUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_GetStringIdentifiersProcInfo, GetCurrentArchitecture())
+#define CallNPN_GetStringIdentifiersProc(FUNC, ARG1, ARG2, ARG3)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_GetStringIdentifiersProcInfo, (ARG1), (ARG2), (ARG3))	
+
+#else
+
+typedef void (* NP_LOADDS NPN_GetStringIdentifiersUPP)(const NPUTF8** names,
+                                                 int32_t nameCount,
+                                                 NPIdentifier* identifiers);
+#define NewNPN_GetStringIdentifiersProc(FUNC)		\
+		((NPN_GetStringIdentifiersUPP) (FUNC))
+#define CallNPN_GetStringIdentifiersProc(FUNC, ARG1, ARG2, ARG3)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3))
+
+#endif
+
+/* NPN_GetIntIdentifier */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_GetIntIdentifierUPP;
+enum {
+	uppNPN_GetIntIdentifierProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(int32_t)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPIdentifier)))
+};
+
+#define NewNPN_GetIntIdentifierProc(FUNC)		\
+		(NPN_GetIntIdentifierUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_GetIntIdentifierProcInfo, GetCurrentArchitecture())
+#define CallNPN_GetIntIdentifierProc(FUNC, ARG1)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_GetIntIdentifierProcInfo, (ARG1))	
+
+#else
+
+typedef NPIdentifier (* NP_LOADDS NPN_GetIntIdentifierUPP)(int32_t intid);
+#define NewNPN_GetIntIdentifierProc(FUNC)		\
+		((NPN_GetIntIdentifierUPP) (FUNC))
+#define CallNPN_GetIntIdentifierProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))
+
+#endif
+
+/* NPN_IdentifierIsString */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_IdentifierIsStringUPP;
+enum {
+	uppNPN_IdentifierIsStringProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPIdentifier identifier)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(bool)))
+};
+
+#define NewNPN_IdentifierIsStringProc(FUNC)		\
+		(NPN_IdentifierIsStringUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_IdentifierIsStringProcInfo, GetCurrentArchitecture())
+#define CallNPN_IdentifierIsStringProc(FUNC, ARG1)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_IdentifierIsStringProcInfo, (ARG1))	
+
+#else
+
+typedef bool (* NP_LOADDS NPN_IdentifierIsStringUPP)(NPIdentifier identifier);
+#define NewNPN_IdentifierIsStringProc(FUNC)		\
+		((NPN_IdentifierIsStringUPP) (FUNC))
+#define CallNPN_IdentifierIsStringProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))
+
+#endif
+
+/* NPN_UTF8FromIdentifier */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_UTF8FromIdentifierUPP;
+enum {
+	uppNPN_UTF8FromIdentifierProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPIdentifier)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPUTF8*)))
+};
+
+#define NewNPN_UTF8FromIdentifierProc(FUNC)		\
+		(NPN_UTF8FromIdentifierUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_UTF8FromIdentifierProcInfo, GetCurrentArchitecture())
+#define CallNPN_UTF8FromIdentifierProc(FUNC, ARG1)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_UTF8FromIdentifierProcInfo, (ARG1))	
+
+#else
+
+typedef NPUTF8* (* NP_LOADDS NPN_UTF8FromIdentifierUPP)(NPIdentifier identifier);
+#define NewNPN_UTF8FromIdentifierProc(FUNC)		\
+		((NPN_UTF8FromIdentifierUPP) (FUNC))
+#define CallNPN_UTF8FromIdentifierProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))
+
+#endif
+
+/* NPN_IntFromIdentifier */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_IntFromIdentifierUPP;
+enum {
+	uppNPN_IntFromIdentifierProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPIdentifier)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(int32_t)))
+};
+
+#define NewNPN_IntFromIdentifierProc(FUNC)		\
+		(NPN_IntFromIdentifierUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_IntFromIdentifierProcInfo, GetCurrentArchitecture())
+#define CallNPN_IntFromIdentifierProc(FUNC, ARG1)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_IntFromIdentifierProcInfo, (ARG1))	
+
+#else
+
+typedef int32_t (* NP_LOADDS NPN_IntFromIdentifierUPP)(NPIdentifier identifier);
+#define NewNPN_IntFromIdentifierProc(FUNC)		\
+		((NPN_IntFromIdentifierUPP) (FUNC))
+#define CallNPN_IntFromIdentifierProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))
+
+#endif
+
+/* NPN_CreateObject */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_CreateObjectUPP;
+enum {
+	uppNPN_CreateObjectProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPClass*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPObject*)))
+};
+
+#define NewNPN_CreateObjectProc(FUNC)		\
+		(NPN_CreateObjectUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_CreateObjectProcInfo, GetCurrentArchitecture())
+#define CallNPN_CreateObjectProc(FUNC, ARG1, ARG2)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_CreateObjectProcInfo, (ARG1), (ARG2))	
+
+#else
+
+typedef NPObject* (* NP_LOADDS NPN_CreateObjectUPP)(NPP npp, NPClass *aClass);
+#define NewNPN_CreateObjectProc(FUNC)		\
+		((NPN_CreateObjectUPP) (FUNC))
+#define CallNPN_CreateObjectProc(FUNC, ARG1, ARG2)		\
+		(*(FUNC))((ARG1), (ARG2))
+
+#endif
+
+/* NPN_RetainObject */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_RetainObjectUPP;
+enum {
+	uppNPN_RetainObjectProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPObject*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPObject*)))
+};
+
+#define NewNPN_RetainObjectProc(FUNC)		\
+		(NPN_RetainObjectUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_RetainObjectProcInfo, GetCurrentArchitecture())
+#define CallNPN_RetainObjectProc(FUNC, ARG1)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_RetainObjectProcInfo, (ARG1))	
+
+#else
+
+typedef NPObject* (* NP_LOADDS NPN_RetainObjectUPP)(NPObject *obj);
+#define NewNPN_RetainObjectProc(FUNC)		\
+		((NPN_RetainObjectUPP) (FUNC))
+#define CallNPN_RetainObjectProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))
+
+#endif
+
+/* NPN_ReleaseObject */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_ReleaseObjectUPP;
+enum {
+	uppNPN_ReleaseObjectProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPObject*)))
+		| RESULT_SIZE(SIZE_CODE(0))
+};
+
+#define NewNPN_ReleaseObjectProc(FUNC)		\
+		(NPN_ReleaseObjectUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_ReleaseObjectProcInfo, GetCurrentArchitecture())
+#define CallNPN_ReleaseObjectProc(FUNC, ARG1)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_ReleaseObjectProcInfo, (ARG1))
+
+#else
+
+typedef void (* NP_LOADDS NPN_ReleaseObjectUPP)(NPObject *obj);
+#define NewNPN_ReleaseObjectProc(FUNC)		\
+		((NPN_ReleaseObjectUPP) (FUNC))
+#define CallNPN_ReleaseObjectProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))
+
+#endif
+
+/* NPN_Invoke */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_InvokeUPP;
+enum {
+	uppNPN_InvokeProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPObject*)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(NPIdentifier)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(const NPVariant*)))
+		| STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(uint32_t)))
+		| STACK_ROUTINE_PARAMETER(6, SIZE_CODE(sizeof(NPVariant*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(bool)))
+};
+
+#define NewNPN_InvokeProc(FUNC)		\
+		(NPN_InvokeUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_InvokeProcInfo, GetCurrentArchitecture())
+#define CallNPN_InvokeProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_InvokeProcInfo, (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6))
+
+#else
+
+typedef bool (* NP_LOADDS NPN_InvokeUPP)(NPP npp, NPObject* obj, NPIdentifier methodName, const NPVariant *args, uint32_t argCount, NPVariant *result);
+#define NewNPN_InvokeProc(FUNC)		\
+		((NPN_InvokeUPP) (FUNC))
+#define CallNPN_InvokeProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6))
+
+#endif
+
+/* NPN_InvokeDefault */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_InvokeDefaultUPP;
+enum {
+	uppNPN_InvokeDefaultProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPObject*)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(const NPVariant*)))
+		| STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(uint32_t)))
+		| STACK_ROUTINE_PARAMETER(6, SIZE_CODE(sizeof(NPVariant*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(bool)))
+};
+
+#define NewNPN_InvokeDefaultProc(FUNC)		\
+		(NPN_InvokeDefaultUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_InvokeDefaultProcInfo, GetCurrentArchitecture())
+#define CallNPN_InvokeDefaultProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_InvokeDefaultProcInfo, (ARG1), (ARG2), (ARG3), (ARG4), (ARG5))
+
+#else
+
+typedef bool (* NP_LOADDS NPN_InvokeDefaultUPP)(NPP npp, NPObject* obj, const NPVariant *args, uint32_t argCount, NPVariant *result);
+#define NewNPN_InvokeDefaultProc(FUNC)		\
+		((NPN_InvokeDefaultUPP) (FUNC))
+#define CallNPN_InvokeDefaultProc(FUNC, ARG1, ARG2, ARG3, ARG4, ARG5)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4), (ARG5))
+
+#endif
+
+/* NPN_Evaluate */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_EvaluateUPP;
+enum {
+	uppNPN_EvaluateProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPObject*)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(NPString*)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(NPVariant*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(bool)))
+};
+
+#define NewNPN_EvaluateProc(FUNC)		\
+		(NPN_EvaluateUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_EvaluateProcInfo, GetCurrentArchitecture())
+#define CallNPN_EvaluateProc(FUNC, ARG1, ARG2, ARG3, ARG4)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_EvaluateProcInfo, (ARG1), (ARG2), (ARG3), (ARG4))
+
+#else
+
+typedef bool (* NP_LOADDS NPN_EvaluateUPP)(NPP npp, NPObject *obj, NPString *script, NPVariant *result);
+#define NewNPN_EvaluateProc(FUNC)		\
+		((NPN_EvaluateUPP) (FUNC))
+#define CallNPN_EvaluateProc(FUNC, ARG1, ARG2, ARG3, ARG4)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4))
+
+#endif
+
+/* NPN_GetProperty */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_GetPropertyUPP;
+enum {
+	uppNPN_GetPropertyProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPObject*)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(NPIdentifier)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(NPVariant*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(bool)))
+};
+
+#define NewNPN_GetPropertyProc(FUNC)		\
+		(NPN_GetPropertyUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_GetPropertyProcInfo, GetCurrentArchitecture())
+#define CallNPN_GetPropertyProc(FUNC, ARG1, ARG2, ARG3, ARG4)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_GetPropertyProcInfo, (ARG1), (ARG2), (ARG3), (ARG4))
+
+#else
+
+typedef bool (* NP_LOADDS NPN_GetPropertyUPP)(NPP npp, NPObject *obj, NPIdentifier propertyName, NPVariant *result);
+#define NewNPN_GetPropertyProc(FUNC)		\
+		((NPN_GetPropertyUPP) (FUNC))
+#define CallNPN_GetPropertyProc(FUNC, ARG1, ARG2, ARG3, ARG4)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4))
+
+#endif
+
+/* NPN_SetProperty */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_SetPropertyUPP;
+enum {
+	uppNPN_SetPropertyProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPObject*)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(NPIdentifier)))
+		| STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(const NPVariant*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(bool)))
+};
+
+#define NewNPN_SetPropertyProc(FUNC)		\
+		(NPN_SetPropertyUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_SetPropertyProcInfo, GetCurrentArchitecture())
+#define CallNPN_SetPropertyProc(FUNC, ARG1, ARG2, ARG3, ARG4)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_SetPropertyProcInfo, (ARG1), (ARG2), (ARG3), (ARG4))
+
+#else
+
+typedef bool (* NP_LOADDS NPN_SetPropertyUPP)(NPP npp, NPObject *obj, NPIdentifier propertyName, const NPVariant *value);
+#define NewNPN_SetPropertyProc(FUNC)		\
+		((NPN_SetPropertyUPP) (FUNC))
+#define CallNPN_SetPropertyProc(FUNC, ARG1, ARG2, ARG3, ARG4)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4))
+
+#endif
+
+/* NPN_RemoveProperty */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_RemovePropertyUPP;
+enum {
+	uppNPN_RemovePropertyProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPObject*)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(NPIdentifier)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(bool)))
+};
+
+#define NewNPN_RemovePropertyProc(FUNC)		\
+		(NPN_RemovePropertyUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_RemovePropertyProcInfo, GetCurrentArchitecture())
+#define CallNPN_RemovePropertyProc(FUNC, ARG1, ARG2, ARG3)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_RemovePropertyProcInfo, (ARG1), (ARG2), (ARG3))
+
+#else
+
+typedef bool (* NP_LOADDS NPN_RemovePropertyUPP)(NPP npp, NPObject *obj, NPIdentifier propertyName);
+#define NewNPN_RemovePropertyProc(FUNC)		\
+		((NPN_RemovePropertyUPP) (FUNC))
+#define CallNPN_RemovePropertyProc(FUNC, ARG1, ARG2, ARG3)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3))
+
+#endif
+
+/* NPN_HasProperty */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_HasPropertyUPP;
+enum {
+	uppNPN_HasPropertyProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPObject*)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(NPIdentifier)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(bool)))
+};
+
+#define NewNPN_HasPropertyProc(FUNC)		\
+		(NPN_HasPropertyUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_HasPropertyProcInfo, GetCurrentArchitecture())
+#define CallNPN_HasPropertyProc(FUNC, ARG1, ARG2, ARG3)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_HasPropertyProcInfo, (ARG1), (ARG2), (ARG3))
+
+#else
+
+typedef bool (* NP_LOADDS NPN_HasPropertyUPP)(NPP npp, NPObject *obj, NPIdentifier propertyName);
+#define NewNPN_HasPropertyProc(FUNC)		\
+		((NPN_HasPropertyUPP) (FUNC))
+#define CallNPN_HasPropertyProc(FUNC, ARG1, ARG2, ARG3)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3))
+
+#endif
+
+/* NPN_HasMethod */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_HasMethodUPP;
+enum {
+	uppNPN_HasMethodProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPObject*)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(NPIdentifier)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(bool)))
+};
+
+#define NewNPN_HasMethodProc(FUNC)		\
+		(NPN_HasMethodUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_HasMethodProcInfo, GetCurrentArchitecture())
+#define CallNPN_HasMethodProc(FUNC, ARG1, ARG2, ARG3)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_HasMethodProcInfo, (ARG1), (ARG2), (ARG3))
+
+#else
+
+typedef bool (* NP_LOADDS NPN_HasMethodUPP)(NPP npp, NPObject *obj, NPIdentifier propertyName);
+#define NewNPN_HasMethodProc(FUNC)		\
+		((NPN_HasMethodUPP) (FUNC))
+#define CallNPN_HasMethodProc(FUNC, ARG1, ARG2, ARG3)		\
+		(*(FUNC))((ARG1), (ARG2), (ARG3))
+
+#endif
+
+/* NPN_ReleaseVariantValue */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_ReleaseVariantValue;
+enum {
+	uppNPN_ReleaseVariantValueProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPVariant*)))
+		| RESULT_SIZE(SIZE_CODE(0))
+};
+
+#define NewNPN_ReleaseVariantValueProc(FUNC)		\
+		(NPN_ReleaseVariantValueUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_ReleaseVariantValueProcInfo, GetCurrentArchitecture())
+#define CallNPN_ReleaseVariantValueProc(FUNC, ARG1)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_ReleaseVariantValueProcInfo, (ARG1))	
+
+#else
+
+typedef void (* NP_LOADDS NPN_ReleaseVariantValueUPP)(NPVariant *variant);
+#define NewNPN_ReleaseVariantValueProc(FUNC)		\
+		((NPN_ReleaseVariantValueUPP) (FUNC))
+#define CallNPN_ReleaseVariantValueProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))
+
+#endif
+
+/* NPN_SetException */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_SetExceptionUPP;
+enum {
+	uppNPN_SetExceptionProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPObject*)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(const NPUTF8*)))
+		| RESULT_SIZE(SIZE_CODE(0))
+};
+
+#define NewNPN_SetExceptionProc(FUNC)		\
+		(NPN_SetExceptionUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_SetExceptionProcInfo, GetCurrentArchitecture())
+#define CallNPN_SetExceptionProc(FUNC, ARG1, ARG2)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_SetExceptionProcInfo, (ARG1), (ARG2))	
+
+#else
+
+typedef void (* NP_LOADDS NPN_SetExceptionUPP)(NPObject *obj, const NPUTF8 *message);
+#define NewNPN_SetExceptionProc(FUNC)		\
+		((NPN_SetExceptionUPP) (FUNC))
+#define CallNPN_SetExceptionProc(FUNC, ARG1, ARG2)		\
+		(*(FUNC))((ARG1), (ARG2))	
+
+#endif
+
+/* NPN_PushPopupsEnabledStateUPP */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_PushPopupsEnabledStateUPP;
+enum {
+	uppNPN_PushPopupsEnabledStateProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+        | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPBool)))
+		| RESULT_SIZE(SIZE_CODE(0))
+};
+
+#define NewNPN_PushPopupsEnabledStateProc(FUNC)		\
+		(NPN_PushPopupsEnabledStateUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_PushPopupsEnabledStateProcInfo, GetCurrentArchitecture())
+#define CallNPN_PushPopupsEnabledStateProc(FUNC, ARG1, ARG2)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_PushPopupsEnabledStateProcInfo, (ARG1), (ARG2))
+
+#else
+
+typedef bool (* NP_LOADDS NPN_PushPopupsEnabledStateUPP)(NPP npp, NPBool enabled);
+#define NewNPN_PushPopupsEnabledStateProc(FUNC)		\
+		((NPN_PushPopupsEnabledStateUPP) (FUNC))
+#define CallNPN_PushPopupsEnabledStateProc(FUNC, ARG1, ARG2)		\
+		(*(FUNC))((ARG1), (ARG2))
+
+#endif
+
+/* NPN_PopPopupsEnabledState */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPN_PopPopupsEnabledStateUPP;
+enum {
+	uppNPN_PopPopupsEnabledStateProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPP)))
+		| RESULT_SIZE(SIZE_CODE(0))
+};
+
+#define NewNPN_PopPopupsEnabledStateProc(FUNC)		\
+		(NPN_PopPopupsEnabledStateUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPN_PopPopupsEnabledStateProcInfo, GetCurrentArchitecture())
+#define CallNPN_PopPopupsEnabledStateProc(FUNC, ARG1)		\
+		(jref)CallUniversalProc((UniversalProcPtr)(FUNC), uppNPN_PopPopupsEnabledStateProcInfo, (ARG1))
+
+#else
+
+typedef bool (* NP_LOADDS NPN_PopPopupsEnabledStateUPP)(NPP npp);
+#define NewNPN_PopPopupsEnabledStateProc(FUNC)		\
+		((NPN_PopPopupsEnabledStateUPP) (FUNC))
+#define CallNPN_PopPopupsEnabledStateProc(FUNC, ARG1)		\
+		(*(FUNC))((ARG1))
+
+#endif
+
+
+
+/******************************************************************************************
+ * The actual plugin function table definitions
+ *******************************************************************************************/
+
+#ifdef XP_MAC
+#if PRAGMA_STRUCT_ALIGN
+#pragma options align=mac68k
+#endif
+#endif
+
+typedef struct _NPPluginFuncs {
+    uint16 size;
+    uint16 version;
+    NPP_NewUPP newp;
+    NPP_DestroyUPP destroy;
+    NPP_SetWindowUPP setwindow;
+    NPP_NewStreamUPP newstream;
+    NPP_DestroyStreamUPP destroystream;
+    NPP_StreamAsFileUPP asfile;
+    NPP_WriteReadyUPP writeready;
+    NPP_WriteUPP write;
+    NPP_PrintUPP print;
+    NPP_HandleEventUPP event;
+    NPP_URLNotifyUPP urlnotify;
+    JRIGlobalRef javaClass;
+    NPP_GetValueUPP getvalue;
+    NPP_SetValueUPP setvalue;
+} NPPluginFuncs;
+
+typedef struct _NPNetscapeFuncs {
+    uint16 size;
+    uint16 version;
+    NPN_GetURLUPP geturl;
+    NPN_PostURLUPP posturl;
+    NPN_RequestReadUPP requestread;
+    NPN_NewStreamUPP newstream;
+    NPN_WriteUPP write;
+    NPN_DestroyStreamUPP destroystream;
+    NPN_StatusUPP status;
+    NPN_UserAgentUPP uagent;
+    NPN_MemAllocUPP memalloc;
+    NPN_MemFreeUPP memfree;
+    NPN_MemFlushUPP memflush;
+    NPN_ReloadPluginsUPP reloadplugins;
+    NPN_GetJavaEnvUPP getJavaEnv;
+    NPN_GetJavaPeerUPP getJavaPeer;
+    NPN_GetURLNotifyUPP geturlnotify;
+    NPN_PostURLNotifyUPP posturlnotify;
+    NPN_GetValueUPP getvalue;
+    NPN_SetValueUPP setvalue;
+    NPN_InvalidateRectUPP invalidaterect;
+    NPN_InvalidateRegionUPP invalidateregion;
+    NPN_ForceRedrawUPP forceredraw;
+    NPN_GetStringIdentifierUPP getstringidentifier;
+    NPN_GetStringIdentifiersUPP getstringidentifiers;
+    NPN_GetIntIdentifierUPP getintidentifier;
+    NPN_IdentifierIsStringUPP identifierisstring;
+    NPN_UTF8FromIdentifierUPP utf8fromidentifier;
+    NPN_IntFromIdentifierUPP intfromidentifier;
+    NPN_CreateObjectUPP createobject;
+    NPN_RetainObjectUPP retainobject;
+    NPN_ReleaseObjectUPP releaseobject;
+    NPN_InvokeUPP invoke;
+    NPN_InvokeDefaultUPP invokeDefault;
+    NPN_EvaluateUPP evaluate;
+    NPN_GetPropertyUPP getproperty;
+    NPN_SetPropertyUPP setproperty;
+    NPN_RemovePropertyUPP removeproperty;
+    NPN_HasPropertyUPP hasproperty;
+    NPN_HasMethodUPP hasmethod;
+    NPN_ReleaseVariantValueUPP releasevariantvalue;
+    NPN_SetExceptionUPP setexception;
+    NPN_PushPopupsEnabledStateUPP pushpopupsenabledstate;
+    NPN_PopPopupsEnabledStateUPP poppopupsenabledstate;
+} NPNetscapeFuncs;
+
+#ifdef XP_MAC
+#if PRAGMA_STRUCT_ALIGN
+#pragma options align=reset
+#endif
+#endif
+
+
+#if defined(XP_MAC) || defined(XP_MACOSX)
+/******************************************************************************************
+ * Mac platform-specific plugin glue stuff
+ *******************************************************************************************/
+
+/*
+ * Main entry point of the plugin.
+ * This routine will be called when the plugin is loaded. The function
+ * tables are passed in and the plugin fills in the NPPluginFuncs table
+ * and NPPShutdownUPP for Netscape's use.
+ */
+
+#if _NPUPP_USE_UPP_
+
+typedef UniversalProcPtr NPP_MainEntryUPP;
+enum {
+	uppNPP_MainEntryProcInfo = kThinkCStackBased
+		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(NPNetscapeFuncs*)))
+		| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(NPPluginFuncs*)))
+		| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(NPP_ShutdownUPP*)))
+		| RESULT_SIZE(SIZE_CODE(sizeof(NPError)))
+};
+#define NewNPP_MainEntryProc(FUNC)		\
+		(NPP_MainEntryUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNPP_MainEntryProcInfo, GetCurrentArchitecture())
+#define CallNPP_MainEntryProc(FUNC,  netscapeFunc, pluginFunc, shutdownUPP)		\
+		CallUniversalProc((UniversalProcPtr)(FUNC), (ProcInfoType)uppNPP_MainEntryProcInfo, (netscapeFunc), (pluginFunc), (shutdownUPP))
+
+#else
+
+typedef NPError (* NP_LOADDS NPP_MainEntryUPP)(NPNetscapeFuncs*, NPPluginFuncs*, NPP_ShutdownUPP*);
+#define NewNPP_MainEntryProc(FUNC)		\
+		((NPP_MainEntryUPP) (FUNC))
+#define CallNPP_MainEntryProc(FUNC,  netscapeFunc, pluginFunc, shutdownUPP)		\
+		(*(FUNC))((netscapeFunc), (pluginFunc), (shutdownUPP))
+
+#endif
+
+
+/*
+ * Mac version(s) of NP_GetMIMEDescription(const char *)
+ * These can be called to retreive MIME information from the plugin dynamically
+ *
+ * Note: For compatibility with Quicktime, BPSupportedMIMEtypes is another way
+ *       to get mime info from the plugin only on OSX and may not be supported 
+ *       in furture version--use NP_GetMIMEDescription instead
+ */
+
+enum
+{
+ kBPSupportedMIMETypesStructVers_1    = 1
+};
+
+typedef struct _BPSupportedMIMETypes
+{
+ SInt32    structVersion;      /* struct version */
+ Handle    typeStrings;        /* STR# formated handle, allocated by plug-in */
+ Handle    infoStrings;        /* STR# formated handle, allocated by plug-in */
+} BPSupportedMIMETypes;
+OSErr BP_GetSupportedMIMETypes(BPSupportedMIMETypes *mimeInfo, UInt32 flags);
+
+#if _NPUPP_USE_UPP_
+
+#define NP_GETMIMEDESCRIPTION_NAME "NP_GetMIMEDescriptionRD"
+typedef UniversalProcPtr NP_GetMIMEDescriptionUPP;
+enum {
+	uppNP_GetMIMEDescEntryProc = kThinkCStackBased
+		| RESULT_SIZE(SIZE_CODE(sizeof(const char *)))
+};
+#define NewNP_GetMIMEDescEntryProc(FUNC)		\
+		(NP_GetMIMEDescriptionUPP) NewRoutineDescriptor((ProcPtr)(FUNC), uppNP_GetMIMEDescEntryProc, GetCurrentArchitecture())
+#define CallNP_GetMIMEDescEntryProc(FUNC)		\
+		(const char *)CallUniversalProc((UniversalProcPtr)(FUNC), (ProcInfoType)uppNP_GetMIMEDescEntryProc)
+
+
+#else  /* !_NPUPP_USE_UPP_ */
+
+ /* NP_GetMIMEDescription */
+#define NP_GETMIMEDESCRIPTION_NAME "NP_GetMIMEDescription"
+typedef const char* (* NP_LOADDS NP_GetMIMEDescriptionUPP)();
+#define NewNP_GetMIMEDescEntryProc(FUNC)		\
+		((NP_GetMIMEDescriptionUPP) (FUNC))
+#define CallNP_GetMIMEDescEntryProc(FUNC)		\
+		(*(FUNC))()
+/* BP_GetSupportedMIMETypes */
+typedef OSErr (* NP_LOADDS BP_GetSupportedMIMETypesUPP)(BPSupportedMIMETypes*, UInt32);
+#define NewBP_GetSupportedMIMETypesEntryProc(FUNC)		\
+		((BP_GetSupportedMIMETypesUPP) (FUNC))
+#define CallBP_GetMIMEDescEntryProc(FUNC,  mimeInfo, flags)		\
+		(*(FUNC))((mimeInfo), (flags))
+
+#endif
+#endif /* MAC */
+
+#if defined(_WINDOWS)
+#define OSCALL WINAPI
+#else
+#if defined(__OS2__)
+#define OSCALL _System
+#else
+#define OSCALL
+#endif
+#endif
+
+#if defined( _WINDOWS ) || defined (__OS2__)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* plugin meta member functions */
+#if defined(__OS2__)
+
+typedef struct _NPPluginData {   /* Alternate OS2 Plugin interface */
+    char *pMimeTypes;
+    char *pFileExtents;
+    char *pFileOpenTemplate;
+    char *pProductName;
+    char *pProductDescription;
+    unsigned long dwProductVersionMS;
+    unsigned long dwProductVersionLS;
+} NPPluginData;
+
+NPError OSCALL NP_GetPluginData(NPPluginData * pPluginData);
+
+#endif
+
+NPError OSCALL NP_GetEntryPoints(NPPluginFuncs* pFuncs);
+
+NPError OSCALL NP_Initialize(NPNetscapeFuncs* pFuncs);
+
+NPError OSCALL NP_Shutdown();
+
+char*	NP_GetMIMEDescription();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _WINDOWS || __OS2__ */
+
+#if defined(__OS2__)
+#pragma pack()
+#endif
+
+#ifdef XP_UNIX
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* plugin meta member functions */
+
+char*	NP_GetMIMEDescription(void);
+NPError	NP_Initialize(NPNetscapeFuncs*, NPPluginFuncs*);
+NPError	NP_Shutdown(void);
+NPError NP_GetValue(void *future, NPPVariable aVariable, void *aValue);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* XP_UNIX */
+
+#endif /* _NPUPP_H_ */
diff -Nur mplayerplug-in-3.55-orig/include/prcpucfg.h mplayerplug-in-3.55/include/prcpucfg.h
--- mplayerplug-in-3.55-orig/include/prcpucfg.h	1970-01-01 07:00:00.000000000 +0700
+++ mplayerplug-in-3.55/include/prcpucfg.h	2007-08-04 02:59:37.000000000 +0700
@@ -0,0 +1,707 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Netscape Portable Runtime (NSPR).
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998-2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nspr_cpucfg___
+#define nspr_cpucfg___
+
+#ifndef XP_UNIX
+#define XP_UNIX
+#endif
+
+#ifndef LINUX
+#define LINUX
+#endif
+
+#define PR_AF_INET6 10  /* same as AF_INET6 */
+
+#ifdef __powerpc64__
+
+#undef  IS_LITTLE_ENDIAN
+#define IS_BIG_ENDIAN    1
+#define IS_64
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   8
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_DOUBLE 8
+#define PR_BYTES_PER_WORD   8
+#define PR_BYTES_PER_DWORD  8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    64
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_DOUBLE  64
+#define PR_BITS_PER_WORD    64
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   6
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_DOUBLE_LOG2 6
+#define PR_BITS_PER_WORD_LOG2   6
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    8
+#define PR_ALIGN_OF_INT64   8
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_DOUBLE  8
+#define PR_ALIGN_OF_POINTER 8
+#define PR_ALIGN_OF_WORD    8
+
+#define PR_BYTES_PER_WORD_LOG2   3
+#define PR_BYTES_PER_DWORD_LOG2  3
+
+#elif defined(__powerpc__)
+
+#undef  IS_LITTLE_ENDIAN
+#define IS_BIG_ENDIAN    1
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   4
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_DOUBLE 8
+#define PR_BYTES_PER_WORD   4
+#define PR_BYTES_PER_DWORD  8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    32
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_DOUBLE  64
+#define PR_BITS_PER_WORD    32
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   5
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_DOUBLE_LOG2 6
+#define PR_BITS_PER_WORD_LOG2   5
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    4
+#define PR_ALIGN_OF_INT64   8
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_DOUBLE  8
+#define PR_ALIGN_OF_POINTER 4
+#define PR_ALIGN_OF_WORD    4
+
+#define PR_BYTES_PER_WORD_LOG2   2
+#define PR_BYTES_PER_DWORD_LOG2  3
+
+#elif defined(__alpha)
+
+#define IS_LITTLE_ENDIAN 1
+#undef  IS_BIG_ENDIAN
+#define IS_64
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   8
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_DOUBLE 8
+#define PR_BYTES_PER_WORD   8
+#define PR_BYTES_PER_DWORD  8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    64
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_DOUBLE  64
+#define PR_BITS_PER_WORD    64
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   6
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_DOUBLE_LOG2 6
+#define PR_BITS_PER_WORD_LOG2   6
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    8
+#define PR_ALIGN_OF_INT64   8
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_DOUBLE  8
+#define PR_ALIGN_OF_POINTER 8
+#define PR_ALIGN_OF_WORD    8
+
+#define PR_BYTES_PER_WORD_LOG2  3
+#define PR_BYTES_PER_DWORD_LOG2 3
+
+#elif defined(__ia64__)
+
+#define IS_LITTLE_ENDIAN 1
+#undef  IS_BIG_ENDIAN
+#define IS_64
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   8
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_DOUBLE 8
+#define PR_BYTES_PER_WORD   8
+#define PR_BYTES_PER_DWORD  8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    64
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_DOUBLE  64
+#define PR_BITS_PER_WORD    64
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   6
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_DOUBLE_LOG2 6
+#define PR_BITS_PER_WORD_LOG2   6
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    8
+#define PR_ALIGN_OF_INT64   8
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_DOUBLE  8
+#define PR_ALIGN_OF_POINTER 8
+#define PR_ALIGN_OF_WORD    8
+
+#define PR_BYTES_PER_WORD_LOG2  3
+#define PR_BYTES_PER_DWORD_LOG2 3
+
+#elif defined(__x86_64__)
+
+#define IS_LITTLE_ENDIAN 1
+#undef  IS_BIG_ENDIAN
+#define IS_64
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   8
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_DOUBLE 8
+#define PR_BYTES_PER_WORD   8
+#define PR_BYTES_PER_DWORD  8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    64
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_DOUBLE  64
+#define PR_BITS_PER_WORD    64
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   6
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_DOUBLE_LOG2 6
+#define PR_BITS_PER_WORD_LOG2   6
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    8
+#define PR_ALIGN_OF_INT64   8
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_DOUBLE  8
+#define PR_ALIGN_OF_POINTER 8
+#define PR_ALIGN_OF_WORD    8
+
+#define PR_BYTES_PER_WORD_LOG2  3
+#define PR_BYTES_PER_DWORD_LOG2 3
+
+#elif defined(__mc68000__)
+
+#undef  IS_LITTLE_ENDIAN
+#define IS_BIG_ENDIAN 1
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   4
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_DOUBLE 8
+#define PR_BYTES_PER_WORD   4
+#define PR_BYTES_PER_DWORD  8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    32
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_DOUBLE  64
+#define PR_BITS_PER_WORD    32
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   5
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_DOUBLE_LOG2 6
+#define PR_BITS_PER_WORD_LOG2   5
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     2
+#define PR_ALIGN_OF_LONG    2
+#define PR_ALIGN_OF_INT64   2
+#define PR_ALIGN_OF_FLOAT   2
+#define PR_ALIGN_OF_DOUBLE  2
+#define PR_ALIGN_OF_POINTER 2
+#define PR_ALIGN_OF_WORD    2
+
+#define PR_BYTES_PER_WORD_LOG2   2
+#define PR_BYTES_PER_DWORD_LOG2  3
+
+#elif defined(__sparc__)
+
+#undef	IS_LITTLE_ENDIAN
+#define	IS_BIG_ENDIAN 1
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   4
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_DOUBLE 8
+#define PR_BYTES_PER_WORD   4
+#define PR_BYTES_PER_DWORD  8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    32
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_DOUBLE  64
+#define PR_BITS_PER_WORD    32
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   5
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_DOUBLE_LOG2 6
+#define PR_BITS_PER_WORD_LOG2   5
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    4
+#define PR_ALIGN_OF_INT64   8
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_DOUBLE  8
+#define PR_ALIGN_OF_POINTER 4
+#define PR_ALIGN_OF_WORD    4
+
+#define PR_BYTES_PER_WORD_LOG2   2
+#define PR_BYTES_PER_DWORD_LOG2  3
+
+#elif defined(__i386__)
+
+#define IS_LITTLE_ENDIAN 1
+#undef  IS_BIG_ENDIAN
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   4
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_DOUBLE 8
+#define PR_BYTES_PER_WORD   4
+#define PR_BYTES_PER_DWORD  8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    32
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_DOUBLE  64
+#define PR_BITS_PER_WORD    32
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   5
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_DOUBLE_LOG2 6
+#define PR_BITS_PER_WORD_LOG2   5
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    4
+#define PR_ALIGN_OF_INT64   4
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_DOUBLE  4
+#define PR_ALIGN_OF_POINTER 4
+#define PR_ALIGN_OF_WORD    4
+
+#define PR_BYTES_PER_WORD_LOG2   2
+#define PR_BYTES_PER_DWORD_LOG2  3
+
+#elif defined(__mips__)
+
+#ifdef __MIPSEB__
+#define IS_BIG_ENDIAN 1
+#undef  IS_LITTLE_ENDIAN
+#elif defined(__MIPSEL__)
+#define IS_LITTLE_ENDIAN 1
+#undef  IS_BIG_ENDIAN
+#else
+#error "Unknown MIPS endianness."
+#endif
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   4
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_DOUBLE 8
+#define PR_BYTES_PER_WORD   4
+#define PR_BYTES_PER_DWORD  8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    32
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_DOUBLE  64
+#define PR_BITS_PER_WORD    32
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   5
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_DOUBLE_LOG2 6
+#define PR_BITS_PER_WORD_LOG2   5
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    4
+#define PR_ALIGN_OF_INT64   8
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_DOUBLE  8
+#define PR_ALIGN_OF_POINTER 4
+#define PR_ALIGN_OF_WORD    4
+
+#define PR_BYTES_PER_WORD_LOG2   2
+#define PR_BYTES_PER_DWORD_LOG2  3
+
+#elif defined(__arm__)
+
+#define IS_LITTLE_ENDIAN 1
+#undef  IS_BIG_ENDIAN
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   4
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_DOUBLE 8
+#define PR_BYTES_PER_WORD   4
+#define PR_BYTES_PER_DWORD  8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    32
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_DOUBLE  64
+#define PR_BITS_PER_WORD    32
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   5
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_DOUBLE_LOG2 6
+#define PR_BITS_PER_WORD_LOG2   5
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    4
+#define PR_ALIGN_OF_INT64   4
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_DOUBLE  4
+#define PR_ALIGN_OF_POINTER 4
+#define PR_ALIGN_OF_WORD    4
+
+#define PR_BYTES_PER_WORD_LOG2   2
+#define PR_BYTES_PER_DWORD_LOG2  3
+
+#elif defined(__hppa__)
+
+#undef  IS_LITTLE_ENDIAN
+#define IS_BIG_ENDIAN    1
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   4
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_DOUBLE 8
+#define PR_BYTES_PER_WORD   4
+#define PR_BYTES_PER_DWORD  8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    32
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_DOUBLE  64
+#define PR_BITS_PER_WORD    32
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   5
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_DOUBLE_LOG2 6
+#define PR_BITS_PER_WORD_LOG2   5
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    4
+#define PR_ALIGN_OF_INT64   8
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_DOUBLE  8
+#define PR_ALIGN_OF_POINTER 4
+#define PR_ALIGN_OF_WORD    4
+
+#define PR_BYTES_PER_WORD_LOG2   2
+#define PR_BYTES_PER_DWORD_LOG2  3
+
+#elif defined(__s390x__)
+
+#define IS_BIG_ENDIAN 1
+#undef  IS_LITTLE_ENDIAN
+#define IS_64
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   8
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_DOUBLE 8
+#define PR_BYTES_PER_WORD   8
+#define PR_BYTES_PER_DWORD  8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    64
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_DOUBLE  64
+#define PR_BITS_PER_WORD    64
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   6
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_DOUBLE_LOG2 6
+#define PR_BITS_PER_WORD_LOG2   6
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    8
+#define PR_ALIGN_OF_INT64   8
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_DOUBLE  8
+#define PR_ALIGN_OF_POINTER 8
+#define PR_ALIGN_OF_WORD    8
+
+#define PR_BYTES_PER_WORD_LOG2   3
+#define PR_BYTES_PER_DWORD_LOG2  3
+
+#elif defined(__s390__)
+
+#define IS_BIG_ENDIAN 1
+#undef  IS_LITTLE_ENDIAN
+
+#define PR_BYTES_PER_BYTE   1
+#define PR_BYTES_PER_SHORT  2
+#define PR_BYTES_PER_INT    4
+#define PR_BYTES_PER_INT64  8
+#define PR_BYTES_PER_LONG   4
+#define PR_BYTES_PER_FLOAT  4
+#define PR_BYTES_PER_DOUBLE 8
+#define PR_BYTES_PER_WORD   4
+#define PR_BYTES_PER_DWORD  8
+
+#define PR_BITS_PER_BYTE    8
+#define PR_BITS_PER_SHORT   16
+#define PR_BITS_PER_INT     32
+#define PR_BITS_PER_INT64   64
+#define PR_BITS_PER_LONG    32
+#define PR_BITS_PER_FLOAT   32
+#define PR_BITS_PER_DOUBLE  64
+#define PR_BITS_PER_WORD    32
+
+#define PR_BITS_PER_BYTE_LOG2   3
+#define PR_BITS_PER_SHORT_LOG2  4
+#define PR_BITS_PER_INT_LOG2    5
+#define PR_BITS_PER_INT64_LOG2  6
+#define PR_BITS_PER_LONG_LOG2   5
+#define PR_BITS_PER_FLOAT_LOG2  5
+#define PR_BITS_PER_DOUBLE_LOG2 6
+#define PR_BITS_PER_WORD_LOG2   5
+
+#define PR_ALIGN_OF_SHORT   2
+#define PR_ALIGN_OF_INT     4
+#define PR_ALIGN_OF_LONG    4
+#define PR_ALIGN_OF_INT64   4
+#define PR_ALIGN_OF_FLOAT   4
+#define PR_ALIGN_OF_DOUBLE  4
+#define PR_ALIGN_OF_POINTER 4
+#define PR_ALIGN_OF_WORD    4
+
+#define PR_BYTES_PER_WORD_LOG2   2
+#define PR_BYTES_PER_DWORD_LOG2  3
+
+#else
+
+#error "Unknown CPU architecture"
+
+#endif
+
+#define	HAVE_LONG_LONG
+#if PR_ALIGN_OF_DOUBLE == 8
+#define HAVE_ALIGNED_DOUBLES
+#endif
+#if PR_ALIGN_OF_INT64 == 8
+#define HAVE_ALIGNED_LONGLONGS
+#endif
+
+#ifndef NO_NSPR_10_SUPPORT
+
+#define BYTES_PER_BYTE		PR_BYTES_PER_BYTE
+#define BYTES_PER_SHORT 	PR_BYTES_PER_SHORT
+#define BYTES_PER_INT 		PR_BYTES_PER_INT
+#define BYTES_PER_INT64		PR_BYTES_PER_INT64
+#define BYTES_PER_LONG		PR_BYTES_PER_LONG
+#define BYTES_PER_FLOAT		PR_BYTES_PER_FLOAT
+#define BYTES_PER_DOUBLE	PR_BYTES_PER_DOUBLE
+#define BYTES_PER_WORD		PR_BYTES_PER_WORD
+#define BYTES_PER_DWORD		PR_BYTES_PER_DWORD
+
+#define BITS_PER_BYTE		PR_BITS_PER_BYTE
+#define BITS_PER_SHORT		PR_BITS_PER_SHORT
+#define BITS_PER_INT		PR_BITS_PER_INT
+#define BITS_PER_INT64		PR_BITS_PER_INT64
+#define BITS_PER_LONG		PR_BITS_PER_LONG
+#define BITS_PER_FLOAT		PR_BITS_PER_FLOAT
+#define BITS_PER_DOUBLE		PR_BITS_PER_DOUBLE
+#define BITS_PER_WORD		PR_BITS_PER_WORD
+
+#define BITS_PER_BYTE_LOG2	PR_BITS_PER_BYTE_LOG2
+#define BITS_PER_SHORT_LOG2	PR_BITS_PER_SHORT_LOG2
+#define BITS_PER_INT_LOG2	PR_BITS_PER_INT_LOG2
+#define BITS_PER_INT64_LOG2	PR_BITS_PER_INT64_LOG2
+#define BITS_PER_LONG_LOG2	PR_BITS_PER_LONG_LOG2
+#define BITS_PER_FLOAT_LOG2	PR_BITS_PER_FLOAT_LOG2
+#define BITS_PER_DOUBLE_LOG2 	PR_BITS_PER_DOUBLE_LOG2
+#define BITS_PER_WORD_LOG2	PR_BITS_PER_WORD_LOG2
+
+#define ALIGN_OF_SHORT		PR_ALIGN_OF_SHORT
+#define ALIGN_OF_INT		PR_ALIGN_OF_INT
+#define ALIGN_OF_LONG		PR_ALIGN_OF_LONG
+#define ALIGN_OF_INT64		PR_ALIGN_OF_INT64
+#define ALIGN_OF_FLOAT		PR_ALIGN_OF_FLOAT
+#define ALIGN_OF_DOUBLE		PR_ALIGN_OF_DOUBLE
+#define ALIGN_OF_POINTER	PR_ALIGN_OF_POINTER
+#define ALIGN_OF_WORD		PR_ALIGN_OF_WORD
+
+#define BYTES_PER_WORD_LOG2	PR_BYTES_PER_WORD_LOG2
+#define BYTES_PER_DWORD_LOG2	PR_BYTES_PER_DWORD_LOG2
+#define WORDS_PER_DWORD_LOG2	PR_WORDS_PER_DWORD_LOG2
+
+#endif /* NO_NSPR_10_SUPPORT */
+
+#endif /* nspr_cpucfg___ */
diff -Nur mplayerplug-in-3.55-orig/include/prtypes.h mplayerplug-in-3.55/include/prtypes.h
--- mplayerplug-in-3.55-orig/include/prtypes.h	1970-01-01 07:00:00.000000000 +0700
+++ mplayerplug-in-3.55/include/prtypes.h	2007-08-04 02:59:37.000000000 +0700
@@ -0,0 +1,547 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Netscape Portable Runtime (NSPR).
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998-2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+** File:                prtypes.h
+** Description: Definitions of NSPR's basic types
+**
+** Prototypes and macros used to make up for deficiencies that we have found
+** in ANSI environments.
+**
+** Since we do not wrap <stdlib.h> and all the other standard headers, authors
+** of portable code will not know in general that they need these definitions.
+** Instead of requiring these authors to find the dependent uses in their code
+** and take the following steps only in those C files, we take steps once here
+** for all C files.
+**/
+
+#ifndef prtypes_h___
+#define prtypes_h___
+
+#ifdef MDCPUCFG
+#include MDCPUCFG
+#else
+#include "prcpucfg.h"
+#endif
+
+#include <stddef.h>
+
+/***********************************************************************
+** MACROS:      PR_EXTERN
+**              PR_IMPLEMENT
+** DESCRIPTION:
+**      These are only for externally visible routines and globals.  For
+**      internal routines, just use "extern" for type checking and that
+**      will not export internal cross-file or forward-declared symbols.
+**      Define a macro for declaring procedures return types. We use this to
+**      deal with windoze specific type hackery for DLL definitions. Use
+**      PR_EXTERN when the prototype for the method is declared. Use
+**      PR_IMPLEMENT for the implementation of the method.
+**
+** Example:
+**   in dowhim.h
+**     PR_EXTERN( void ) DoWhatIMean( void );
+**   in dowhim.c
+**     PR_IMPLEMENT( void ) DoWhatIMean( void ) { return; }
+**
+**
+***********************************************************************/
+#if defined(WIN32)
+
+#define PR_EXPORT(__type) extern __declspec(dllexport) __type
+#define PR_EXPORT_DATA(__type) extern __declspec(dllexport) __type
+#define PR_IMPORT(__type) __declspec(dllimport) __type
+#define PR_IMPORT_DATA(__type) __declspec(dllimport) __type
+
+#define PR_EXTERN(__type) extern __declspec(dllexport) __type
+#define PR_IMPLEMENT(__type) __declspec(dllexport) __type
+#define PR_EXTERN_DATA(__type) extern __declspec(dllexport) __type
+#define PR_IMPLEMENT_DATA(__type) __declspec(dllexport) __type
+
+#define PR_CALLBACK
+#define PR_CALLBACK_DECL
+#define PR_STATIC_CALLBACK(__x) static __x
+
+#elif defined(XP_BEOS)
+
+#define PR_EXPORT(__type) extern __declspec(dllexport) __type
+#define PR_EXPORT_DATA(__type) extern __declspec(dllexport) __type
+#define PR_IMPORT(__type) extern __declspec(dllexport) __type
+#define PR_IMPORT_DATA(__type) extern __declspec(dllexport) __type
+
+#define PR_EXTERN(__type) extern __declspec(dllexport) __type
+#define PR_IMPLEMENT(__type) __declspec(dllexport) __type
+#define PR_EXTERN_DATA(__type) extern __declspec(dllexport) __type
+#define PR_IMPLEMENT_DATA(__type) __declspec(dllexport) __type
+
+#define PR_CALLBACK
+#define PR_CALLBACK_DECL
+#define PR_STATIC_CALLBACK(__x) static __x
+
+#elif defined(WIN16)
+
+#define PR_CALLBACK_DECL        __cdecl
+
+#if defined(_WINDLL)
+#define PR_EXPORT(__type) extern __type _cdecl _export _loadds
+#define PR_IMPORT(__type) extern __type _cdecl _export _loadds
+#define PR_EXPORT_DATA(__type) extern __type _export
+#define PR_IMPORT_DATA(__type) extern __type _export
+
+#define PR_EXTERN(__type) extern __type _cdecl _export _loadds
+#define PR_IMPLEMENT(__type) __type _cdecl _export _loadds
+#define PR_EXTERN_DATA(__type) extern __type _export
+#define PR_IMPLEMENT_DATA(__type) __type _export
+
+#define PR_CALLBACK             __cdecl __loadds
+#define PR_STATIC_CALLBACK(__x) static __x PR_CALLBACK
+
+#else /* this must be .EXE */
+#define PR_EXPORT(__type) extern __type _cdecl _export
+#define PR_IMPORT(__type) extern __type _cdecl _export
+#define PR_EXPORT_DATA(__type) extern __type _export
+#define PR_IMPORT_DATA(__type) extern __type _export
+
+#define PR_EXTERN(__type) extern __type _cdecl _export
+#define PR_IMPLEMENT(__type) __type _cdecl _export
+#define PR_EXTERN_DATA(__type) extern __type _export
+#define PR_IMPLEMENT_DATA(__type) __type _export
+
+#define PR_CALLBACK             __cdecl __loadds
+#define PR_STATIC_CALLBACK(__x) __x PR_CALLBACK
+#endif /* _WINDLL */
+
+#elif defined(XP_MAC)
+
+#define PR_EXPORT(__type) extern __declspec(export) __type
+#define PR_EXPORT_DATA(__type) extern __declspec(export) __type
+#define PR_IMPORT(__type) extern __declspec(export) __type
+#define PR_IMPORT_DATA(__type) extern __declspec(export) __type
+
+#define PR_EXTERN(__type) extern __declspec(export) __type
+#define PR_IMPLEMENT(__type) __declspec(export) __type
+#define PR_EXTERN_DATA(__type) extern __declspec(export) __type
+#define PR_IMPLEMENT_DATA(__type) __declspec(export) __type
+
+#define PR_CALLBACK
+#define PR_CALLBACK_DECL
+#define PR_STATIC_CALLBACK(__x) static __x
+
+#elif defined(XP_OS2_VACPP) 
+
+#define PR_EXPORT(__type) extern __type
+#define PR_EXPORT_DATA(__type) extern __type
+#define PR_IMPORT(__type) extern __type
+#define PR_IMPORT_DATA(__type) extern __type
+
+#define PR_EXTERN(__type) extern __type
+#define PR_IMPLEMENT(__type) __type
+#define PR_EXTERN_DATA(__type) extern __type
+#define PR_IMPLEMENT_DATA(__type) __type
+#define PR_CALLBACK _Optlink
+#define PR_CALLBACK_DECL
+#define PR_STATIC_CALLBACK(__x) static __x PR_CALLBACK
+
+#else /* Unix */
+
+#ifdef HAVE_VISIBILITY_PRAGMA
+#define PR_VISIBILITY_DEFAULT __attribute__((visibility("default")))
+#else
+#define PR_VISIBILITY_DEFAULT
+#endif
+
+#define PR_EXPORT(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_EXPORT_DATA(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_IMPORT(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_IMPORT_DATA(__type) extern PR_VISIBILITY_DEFAULT __type
+
+#define PR_EXTERN(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_IMPLEMENT(__type) PR_VISIBILITY_DEFAULT __type
+#define PR_EXTERN_DATA(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_IMPLEMENT_DATA(__type) PR_VISIBILITY_DEFAULT __type
+#define PR_CALLBACK
+#define PR_CALLBACK_DECL
+#define PR_STATIC_CALLBACK(__x) static __x
+
+#endif
+
+#if defined(_NSPR_BUILD_)
+#define NSPR_API(__type) PR_EXPORT(__type)
+#define NSPR_DATA_API(__type) PR_EXPORT_DATA(__type)
+#else
+#define NSPR_API(__type) PR_IMPORT(__type)
+#define NSPR_DATA_API(__type) PR_IMPORT_DATA(__type)
+#endif
+
+/***********************************************************************
+** MACROS:      PR_BEGIN_MACRO
+**              PR_END_MACRO
+** DESCRIPTION:
+**      Macro body brackets so that macros with compound statement definitions
+**      behave syntactically more like functions when called.
+***********************************************************************/
+#define PR_BEGIN_MACRO  do {
+#define PR_END_MACRO    } while (0)
+
+/***********************************************************************
+** MACROS:      PR_BEGIN_EXTERN_C
+**              PR_END_EXTERN_C
+** DESCRIPTION:
+**      Macro shorthands for conditional C++ extern block delimiters.
+***********************************************************************/
+#ifdef __cplusplus
+#define PR_BEGIN_EXTERN_C       extern "C" {
+#define PR_END_EXTERN_C         }
+#else
+#define PR_BEGIN_EXTERN_C
+#define PR_END_EXTERN_C
+#endif
+
+/***********************************************************************
+** MACROS:      PR_BIT
+**              PR_BITMASK
+** DESCRIPTION:
+** Bit masking macros.  XXX n must be <= 31 to be portable
+***********************************************************************/
+#define PR_BIT(n)       ((PRUint32)1 << (n))
+#define PR_BITMASK(n)   (PR_BIT(n) - 1)
+
+/***********************************************************************
+** MACROS:      PR_ROUNDUP
+**              PR_MIN
+**              PR_MAX
+**              PR_ABS
+** DESCRIPTION:
+**      Commonly used macros for operations on compatible types.
+***********************************************************************/
+#define PR_ROUNDUP(x,y) ((((x)+((y)-1))/(y))*(y))
+#define PR_MIN(x,y)     ((x)<(y)?(x):(y))
+#define PR_MAX(x,y)     ((x)>(y)?(x):(y))
+#define PR_ABS(x)       ((x)<0?-(x):(x))
+
+PR_BEGIN_EXTERN_C
+
+/************************************************************************
+** TYPES:       PRUint8
+**              PRInt8
+** DESCRIPTION:
+**  The int8 types are known to be 8 bits each. There is no type that
+**      is equivalent to a plain "char". 
+************************************************************************/
+#if PR_BYTES_PER_BYTE == 1
+typedef unsigned char PRUint8;
+/*
+** Some cfront-based C++ compilers do not like 'signed char' and
+** issue the warning message:
+**     warning: "signed" not implemented (ignored)
+** For these compilers, we have to define PRInt8 as plain 'char'.
+** Make sure that plain 'char' is indeed signed under these compilers.
+*/
+#if (defined(HPUX) && defined(__cplusplus) \
+        && !defined(__GNUC__) && __cplusplus < 199707L) \
+    || (defined(SCO) && defined(__cplusplus) \
+        && !defined(__GNUC__) && __cplusplus == 1L)
+typedef char PRInt8;
+#else
+typedef signed char PRInt8;
+#endif
+#else
+#error No suitable type for PRInt8/PRUint8
+#endif
+
+/************************************************************************
+ * MACROS:      PR_INT8_MAX
+ *              PR_INT8_MIN
+ *              PR_UINT8_MAX
+ * DESCRIPTION:
+ *  The maximum and minimum values of a PRInt8 or PRUint8.
+************************************************************************/
+
+#define PR_INT8_MAX 127
+#define PR_INT8_MIN (-128)
+#define PR_UINT8_MAX 255U
+
+/************************************************************************
+** TYPES:       PRUint16
+**              PRInt16
+** DESCRIPTION:
+**  The int16 types are known to be 16 bits each. 
+************************************************************************/
+#if PR_BYTES_PER_SHORT == 2
+typedef unsigned short PRUint16;
+typedef short PRInt16;
+#else
+#error No suitable type for PRInt16/PRUint16
+#endif
+
+/************************************************************************
+ * MACROS:      PR_INT16_MAX
+ *              PR_INT16_MIN
+ *              PR_UINT16_MAX
+ * DESCRIPTION:
+ *  The maximum and minimum values of a PRInt16 or PRUint16.
+************************************************************************/
+
+#define PR_INT16_MAX 32767
+#define PR_INT16_MIN (-32768)
+#define PR_UINT16_MAX 65535U
+
+/************************************************************************
+** TYPES:       PRUint32
+**              PRInt32
+** DESCRIPTION:
+**  The int32 types are known to be 32 bits each. 
+************************************************************************/
+#if PR_BYTES_PER_INT == 4
+typedef unsigned int PRUint32;
+typedef int PRInt32;
+#define PR_INT32(x)  x
+#define PR_UINT32(x) x ## U
+#elif PR_BYTES_PER_LONG == 4
+typedef unsigned long PRUint32;
+typedef long PRInt32;
+#define PR_INT32(x)  x ## L
+#define PR_UINT32(x) x ## UL
+#else
+#error No suitable type for PRInt32/PRUint32
+#endif
+
+/************************************************************************
+ * MACROS:      PR_INT32_MAX
+ *              PR_INT32_MIN
+ *              PR_UINT32_MAX
+ * DESCRIPTION:
+ *  The maximum and minimum values of a PRInt32 or PRUint32.
+************************************************************************/
+
+#define PR_INT32_MAX PR_INT32(2147483647)
+#define PR_INT32_MIN (-PR_INT32_MAX - 1)
+#define PR_UINT32_MAX PR_UINT32(4294967295)
+
+/************************************************************************
+** TYPES:       PRUint64
+**              PRInt64
+** DESCRIPTION:
+**  The int64 types are known to be 64 bits each. Care must be used when
+**      declaring variables of type PRUint64 or PRInt64. Different hardware
+**      architectures and even different compilers have varying support for
+**      64 bit values. The only guaranteed portability requires the use of
+**      the LL_ macros (see prlong.h).
+************************************************************************/
+#ifdef HAVE_LONG_LONG
+#if PR_BYTES_PER_LONG == 8
+typedef long PRInt64;
+typedef unsigned long PRUint64;
+#elif defined(WIN16)
+typedef __int64 PRInt64;
+typedef unsigned __int64 PRUint64;
+#elif defined(WIN32) && !defined(__GNUC__)
+typedef __int64  PRInt64;
+typedef unsigned __int64 PRUint64;
+#else
+typedef long long PRInt64;
+typedef unsigned long long PRUint64;
+#endif /* PR_BYTES_PER_LONG == 8 */
+#else  /* !HAVE_LONG_LONG */
+typedef struct {
+#ifdef IS_LITTLE_ENDIAN
+    PRUint32 lo, hi;
+#else
+    PRUint32 hi, lo;
+#endif
+} PRInt64;
+typedef PRInt64 PRUint64;
+#endif /* !HAVE_LONG_LONG */
+
+/************************************************************************
+** TYPES:       PRUintn
+**              PRIntn
+** DESCRIPTION:
+**  The PRIntn types are most appropriate for automatic variables. They are
+**      guaranteed to be at least 16 bits, though various architectures may
+**      define them to be wider (e.g., 32 or even 64 bits). These types are
+**      never valid for fields of a structure. 
+************************************************************************/
+#if PR_BYTES_PER_INT >= 2
+typedef int PRIntn;
+typedef unsigned int PRUintn;
+#else
+#error 'sizeof(int)' not sufficient for platform use
+#endif
+
+/************************************************************************
+** TYPES:       PRFloat64
+** DESCRIPTION:
+**  NSPR's floating point type is always 64 bits. 
+************************************************************************/
+typedef double          PRFloat64;
+
+/************************************************************************
+** TYPES:       PRSize
+** DESCRIPTION:
+**  A type for representing the size of objects. 
+************************************************************************/
+typedef size_t PRSize;
+
+
+/************************************************************************
+** TYPES:       PROffset32, PROffset64
+** DESCRIPTION:
+**  A type for representing byte offsets from some location. 
+************************************************************************/
+typedef PRInt32 PROffset32;
+typedef PRInt64 PROffset64;
+
+/************************************************************************
+** TYPES:       PRPtrDiff
+** DESCRIPTION:
+**  A type for pointer difference. Variables of this type are suitable
+**      for storing a pointer or pointer subtraction. 
+************************************************************************/
+typedef ptrdiff_t PRPtrdiff;
+
+/************************************************************************
+** TYPES:       PRUptrdiff
+** DESCRIPTION:
+**  A type for pointer difference. Variables of this type are suitable
+**      for storing a pointer or pointer sutraction. 
+************************************************************************/
+typedef unsigned long PRUptrdiff;
+
+/************************************************************************
+** TYPES:       PRBool
+** DESCRIPTION:
+**  Use PRBool for variables and parameter types. Use PR_FALSE and PR_TRUE
+**      for clarity of target type in assignments and actual arguments. Use
+**      'if (bool)', 'while (!bool)', '(bool) ? x : y' etc., to test booleans
+**      just as you would C int-valued conditions. 
+************************************************************************/
+typedef PRIntn PRBool;
+#define PR_TRUE 1
+#define PR_FALSE 0
+
+/************************************************************************
+** TYPES:       PRPackedBool
+** DESCRIPTION:
+**  Use PRPackedBool within structs where bitfields are not desirable
+**      but minimum and consistant overhead matters.
+************************************************************************/
+typedef PRUint8 PRPackedBool;
+
+/*
+** Status code used by some routines that have a single point of failure or 
+** special status return.
+*/
+typedef enum { PR_FAILURE = -1, PR_SUCCESS = 0 } PRStatus;
+
+#ifdef MOZ_UNICODE
+/*
+ * EXPERIMENTAL: This type may be removed in a future release.
+ */
+#ifndef __PRUNICHAR__
+#define __PRUNICHAR__
+#if defined(WIN32) || defined(XP_MAC)
+typedef wchar_t PRUnichar;
+#else
+typedef PRUint16 PRUnichar;
+#endif
+#endif
+#endif /* MOZ_UNICODE */
+
+/*
+** WARNING: The undocumented data types PRWord and PRUword are
+** only used in the garbage collection and arena code.  Do not
+** use PRWord and PRUword in new code.
+**
+** A PRWord is an integer that is the same size as a void*.
+** It implements the notion of a "word" in the Java Virtual
+** Machine.  (See Sec. 3.4 "Words", The Java Virtual Machine
+** Specification, Addison-Wesley, September 1996.
+** http://java.sun.com/docs/books/vmspec/index.html.)
+*/
+typedef long PRWord;
+typedef unsigned long PRUword;
+
+#if defined(NO_NSPR_10_SUPPORT)
+#else
+/********* ???????????????? FIX ME       ??????????????????????????? *****/
+/********************** Some old definitions until pr=>ds transition is done ***/
+/********************** Also, we are still using NSPR 1.0. GC ******************/
+/*
+** Fundamental NSPR macros, used nearly everywhere.
+*/
+
+#define PR_PUBLIC_API		PR_IMPLEMENT
+
+/*
+** Macro body brackets so that macros with compound statement definitions
+** behave syntactically more like functions when called.
+*/
+#define NSPR_BEGIN_MACRO        do {
+#define NSPR_END_MACRO          } while (0)
+
+/*
+** Macro shorthands for conditional C++ extern block delimiters.
+*/
+#ifdef NSPR_BEGIN_EXTERN_C
+#undef NSPR_BEGIN_EXTERN_C
+#endif
+#ifdef NSPR_END_EXTERN_C
+#undef NSPR_END_EXTERN_C
+#endif
+
+#ifdef __cplusplus
+#define NSPR_BEGIN_EXTERN_C     extern "C" {
+#define NSPR_END_EXTERN_C       }
+#else
+#define NSPR_BEGIN_EXTERN_C
+#define NSPR_END_EXTERN_C
+#endif
+
+#ifdef XP_MAC
+#include "protypes.h"
+#else
+#include "obsolete/protypes.h"
+#endif
+
+/********* ????????????? End Fix me ?????????????????????????????? *****/
+#endif /* NO_NSPR_10_SUPPORT */
+
+PR_END_EXTERN_C
+
+#endif /* prtypes_h___ */
+
